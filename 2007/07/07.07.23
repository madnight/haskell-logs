00:12:48 <glguy> dons ?
00:13:09 <dons> glguy: ?
00:13:17 <dons> ?bot?
00:13:18 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
00:13:22 <glguy> these commodity 8 core amd64 boxes
00:13:25 <glguy> where can I get mine
00:13:32 <dons> let's see..
00:13:47 <Pseudonym> I read that as "commodity 8 core cbm64 boxes".
00:13:50 <Pseudonym> Now that'd be something.
00:13:57 <dons> just for fun!
00:14:45 <glguy> is that 2 processor x 4 core?
00:14:47 <SamB> commodore 64's?
00:14:51 <SamB> with 8 cores?
00:14:54 <Pseudonym> Why not?
00:15:07 <SamB> how do you get the other 7 cores in place?
00:15:11 <SamB> cart slot?
00:15:15 <Pseudonym> I'd like to see a beowulf cluster of those, naked with hot grits, you insensitive clod.
00:15:16 <dons> so we got our 16 core box, not so cheap, https://ipspty.com.au/index.php?comp=op4
00:15:22 <dons> well, fairly cheap, 2 laptops
00:15:28 <dons> for a 8 core box
00:15:36 <dons> 7 laptops for a 16 core box
00:15:36 <SamB> hot grits would be bad for the naked cirtuitry
00:17:07 <dons> glguy: this is the 16 core machine, https://ipspty.com.au/index.php?comp=op3, iirc.
00:17:17 <dons> price has come down
00:17:26 <dons> they're bloody noisy though
00:17:41 <glguy> if you have a 16 core machine you ought to have a couple extra rooms too
00:17:42 <dons> the other option is the 16 core mips boxes
00:19:15 <dons> these guys, http://www.movidis.com/products/rev.asp
00:19:16 <lambdabot> Title: Movidis
00:19:48 <dons> a 16-core, 64-bit MIPS processor, pretty cheap
00:20:18 <glguy> what runs on MIPS?
00:20:25 * glguy has never had experience with it
00:20:25 <dons> everything?
00:20:30 <dons> linux + ghc
00:20:40 <glguy> good enough for me ;)
00:20:54 <glguy> how does 1 mips core compare to one amd64
00:21:06 <dons> heaps slower, iirc
00:21:19 <dons> 500 Mhz mips? cores versus 2G amds
00:21:22 <SamB> how about the heap?
00:21:32 <dons> @slap SamB
00:21:32 <SamB> er. stack.
00:21:32 * lambdabot smacks SamB about with a large trout
00:21:40 * SamB needs sleep
00:21:43 <SamB> okay, to bed I go
00:21:53 <glguy> if you keep slapping him you'll end up needing a new @slapsam command
00:22:01 <dons> ah, good idea!
00:22:02 <glguy> something that gets progressively worse
00:22:15 <glguy> with each beating
00:22:17 <dons> it can have different threat levels
00:22:26 <glguy> today's threat level is orange
00:22:42 <AStorm> glguy, well, it does compare if the mips is really fast
00:22:43 <glguy> err
00:22:44 <SamB> so...
00:22:44 <glguy> yellow
00:22:51 <SamB> why does it have to be exclusive to me
00:22:53 <AStorm> but these are expensive
00:23:00 <glguy> but it's orange in the airline sector
00:23:02 <glguy> (still)
00:23:03 <SamB> it would be like another @get-shapr
00:23:09 <AStorm> maybe ask the Chinese to build a custom 16-core Godson
00:23:11 <AStorm> :P
00:23:14 <glguy> SamB: I've just seen dons slap you around a couple of times in recent memory
00:23:21 <SamB> glguy: so?
00:23:30 <glguy> SamB: so, that was the inspiration for the command
00:23:40 <SamB> lambdabot is actually the one who gets the most beat up around here
00:23:40 <glguy> that's all there is to it
00:23:42 <dons> glguy: its either that, or the terrorists win.
00:24:03 <SamB> dons: you wil not justify this based on 9/11
00:24:11 <dons> sure i will
00:24:11 <SamB> it makes even less sense than Iraq
00:24:18 <glguy> Yellow: "significant risk of terrorist attack"
00:24:22 <glguy> must not be voting time
00:24:28 <dons> hah
00:24:29 <SamB> and you're name ain't dubya
00:24:47 <dons> you say that from your cave in the mountains, SamB, but I don't believe you
00:24:48 <SamB> and my spellin' ain't what I'd like
00:24:54 <slava> i wonder if someone has made a DHS thread level dashboard widget for OS X
00:25:02 <SamB> dons: actually I live in greater philadelphia
00:25:09 <dons> slava: i think there was, yeah
00:25:12 <glguy> slava: yeah, you can paste images to your dashboard
00:25:19 <glguy> slava: and it doesn't change...
00:25:20 <glguy> so
00:25:26 <glguy> next problem
00:25:37 <SamB> dons: use my hometown from facebook in google maps to see approximately where
00:25:55 <dons> SamB: i won't fall for your sneaky attacks
00:26:06 <SamB> dons: what sneaky attacks
00:26:18 <SamB> I'm far too tired to do any sneaking
00:26:25 <dons> your improvised google devices and lambdabot IUDs. no no!
00:26:25 <glguy> myspacebook performs the valuable service of keeping a group of people isolated, much like ruby
00:26:29 <SamB> I can't even overtly make it to bed, apparantly
00:26:51 <kilimanjaro> gonna have to stay on IRC all night I guess
00:26:55 <SamB> dons: are you talking about those LED advertisement panels?
00:27:16 <dons> that's what you would say, if you were sneaky, yes!
00:27:28 <SamB> okay, that's it.
00:27:33 <SamB> @smack dons
00:27:33 <lambdabot> Unknown command, try @list
00:27:41 <dons> haha
00:27:41 <SamB> @slap dons
00:27:41 * lambdabot beats up dons
00:27:51 <SamB> dons: well it *ought* to work
00:28:03 <SamB> i'ts just a little too levenstien far
00:28:10 <glguy> ?losers
00:28:10 <lambdabot> Maximum users seen in #haskell: 340, currently: 331 (97.4%), active: 12 (3.6%)
00:28:17 * lambdabot slaps SamB
00:28:25 * lambdabot sits on SamB
00:28:35 * lambdabot squooshes SamB
00:28:52 <SamB> @slap glguy
00:28:52 * lambdabot slaps glguy
00:29:06 <SamB> @slap lambdabot
00:29:07 * lambdabot kicks SamB in the ear
00:29:07 <lambdabot> why on earth would I slap lambdabot
00:29:08 * glguy kicks SamB [bed time]
00:29:13 <SamB> @slap lambdabot
00:29:13 <lambdabot> why on earth would I slap lambdabot
00:29:15 <SamB> @slap lambdabot
00:29:15 * lambdabot smacks lambdabot about with a large trout
00:29:17 <SamB> @slap lambdabot
00:29:18 * lambdabot slaps lambdabot
00:29:19 <SamB> @slap lambdabot
00:29:19 * lambdabot smacks lambdabot about with a large trout
00:29:20 --- mode: ChanServ set +o glguy
00:29:20 <SamB> @slap lambdabot
00:29:20 <lambdabot> why on earth would I slap lambdabot
00:29:23 <Cin> :\
00:29:24 --- mode: glguy set +b *!*i=naesten@*.c3-0.upd-ubr7.trpr-upd.pa.cable.rcn.com
00:29:24 --- kick: SamB was kicked by glguy (glguy)
00:29:29 <dons> bout time!
00:30:23 <glguy> it will clear in 5 minutes, so he'll be back after a good rest ;)
00:30:45 <slava>  threat-level .
00:30:45 <slava> "elevated"
00:31:03 <dons> :)
00:31:08 <Pseudonym> I think so long as nobody is handing around any SIM cards, we're all safe.
00:31:19 <slava> : threat-level ( -- str )
00:31:20 <slava>     "http://www.whitehouse.gov/infocus/homeland/" http-get 2nip
00:31:20 <slava>     "/homeland/images/threat/"  split1 nip
00:31:20 <slava>     ".jpg\"" split1 drop ;
00:31:22 <lambdabot> Title: Homeland Security
00:31:39 <slava> dons: that page is valid xml but its easier to just split the string
00:31:55 <glguy> do the other .jpgs exist?
00:31:59 <glguy> or is there only yellow?
00:32:10 <glguy> more importantly, is there blue or green?
00:32:28 <slava> glguy: they don't exist!
00:32:38 <AStorm> glguy, they do exist, but are unused
00:32:41 <slava> oh, wait
00:32:42 <slava> they do exist
00:32:45 <slava> http://www.whitehouse.gov/homeland/images/threat/high.jpg
00:32:46 <ski> how about the color out of space ?
00:32:54 <slava> http://www.whitehouse.gov/homeland/images/threat/severe.jpg
00:33:09 <glguy> level 2: Blue, Guarded, "General risk of terrorist attack"
00:33:27 <AStorm> blah, they are indeed paranoid :P
00:33:32 <glguy> they could stike *anywhere*
00:33:38 --- mode: glguy set -c
00:33:45 <glguy> anywhere
00:33:46 <AStorm> Anyone _ever_ seen a level lower than yellow?
00:34:08 <slava> no
00:34:11 <glguy> blue and green exist to let us know that yellow is serious business
00:34:26 --- mode: glguy set -b *!*i=naesten@*.c3-0.upd-ubr7.trpr-upd.pa.cable.rcn.com
00:34:34 --- mode: glguy set -o glguy
00:35:52 <glguy> The thread level is 8yellow.
00:35:55 <glguy> bah
00:35:56 <glguy> threat
00:36:05 <Pseudonym> http://www.zefrank.com/redalert/index_better.html
00:36:06 <lambdabot> Title: red alert
00:36:11 <glguy> it could be 7orange
00:36:18 <glguy> or 5red
00:36:34 <glguy> but never 2blue or 3green ;)
00:37:09 <slava> i've improved this a bit
00:37:10 <Binkley> Anyone know why GHC and GHC-compiled programs would be nondeterministically segfaulting on my machine?
00:37:16 <Binkley> Is this a sign of imminent cpu death?
00:37:17 <slava> threat-level elevated < [ "We got 'em" print ] when
00:37:22 <slava> this works now
00:37:25 <glguy> They should make a 6magenta threat level... I wonder what percent of people know what that color is
00:37:53 <glguy> slava: isn't that a no-op?
00:38:26 <slava> glguy: a sufficiently smart compiler will optimize it away
00:39:57 <pejo> Binkley, heat problems? (Is it just ghc compiled ones?)
00:39:57 <glguy> :-/ colors do make the logs ugly
00:40:14 <Binkley> pejo: well, ghc-compiled ones are all I'm running, except for firefox and gaim
00:40:19 <Binkley> it could be heat problems, yeah
00:40:34 <Binkley> the air condition in here is br0xx0red
00:40:47 --- mode: ChanServ set +ntc
00:41:27 <dons> Binkley: hmm, so random ghc program?
00:41:35 <Binkley> dons: yeah. it's probably what pejo said
00:41:41 <dons> yeah
00:41:44 <Binkley> we should have chosen a room with air conditioning to work on the ICFP contest :-(
00:42:17 <glguy> the ICFP problem sounds interesting
00:42:18 <glguy> but
00:42:35 <glguy> I liked how the last one was a bunch of sub problems, that were each small enough to play with a litte
00:42:42 <Olathe> I wish the problem was more interesting.
00:42:57 <dons> it seems that 20 or so teams are making progress now though
00:43:11 <dons> just took getting over a 2 1/2 day hump
00:43:17 <Binkley> heh
00:43:23 <dons> 19 teams above 4% now
00:43:27 <Binkley> yeah. the contest would have been fun if we had another week :-)
00:43:36 <glguy> the idea is to use the DNA to create image manipulation instructions, right?
00:43:51 <glguy> or did I misread that entirely :)
00:44:32 <glguy> and its a shame that 2d never really took off ;)
00:44:44 <glguy> I figured we'd all be using that by now
00:44:58 <Binkley> glguy: well, you have to implement DNA->image manipulation instruction code, but that's just the start
00:45:14 <Binkley> the real task is to figure out how to generate a DNA prefix that does the right transformation ont he source DNA
00:45:34 <Binkley> and after 2 1/2 days, my team still didn't have a good idea where to start with that -- it just took too long to get the basic tools working and running at a decent speed
00:45:40 <dons> so compiler-ish stuff.. ?
00:46:06 <glguy> I figured you'd have to write some kind of optimizing compiler to take image manip instructions and turn them into part of the prefix
00:46:06 <dons> all the good icfp contests involve writing compilers in the end, so i wonder.
00:46:09 <Binkley> dons: kind of like a combination of decompilation and compilation
00:46:13 <dons> yeah
00:46:23 <Binkley> since you basically have machine code from a compiler you don't have access to
00:46:27 <Binkley> for a high-level language you don't know
00:46:32 <dons> right
00:48:38 <Olathe> Pseudonym: Heheh
00:48:57 <pejo> dons, so in other words they favour pl grad students. ;)
00:49:16 <glguy> laughing at something from 15 minutes ago should require a quote ;)
00:49:31 <Pseudonym> But how would you quote that?
00:49:40 <Binkley> pejo: well, we had a team with 2 PL grad students, one advanced PL undergrad, and 2 others, and we still were at a loss :-)
00:50:05 <Binkley> 3 PL grad students and 2 others, rather
00:52:31 <glguy> "we needed a system to let the general public know how close they were to dying "  LOL ;)
00:53:24 <Pseudonym> I like the way he pronounces "HSAS" as "his ass".
00:53:30 <Binkley> "You have a 100% chance of dying between 0 and 150 years from today"
00:53:36 <Binkley> there's your system :-)
00:54:10 <Pseudonym> Anyway, must dash.
00:54:12 <Pseudonym> Nytol.
00:55:54 <glguy> "hey, I'm reading this sign, so I must not have gotten killed by a terrorist"
00:56:03 <glguy> ...but it could happen
00:56:52 <slava> should factor print the threat level on startup? i could have a cached value which is updated daily to avoid excessive http requests
00:57:02 <glguy> lol
00:57:07 <glguy> You'll be on a list somewhere
00:57:10 <glguy> and won't be able to fly
00:59:44 <Binkley> Dear gmail: plz stop labelling haskell-cafe posts as spam kthx.
01:01:43 <opqdonut> :)
01:18:43 <mm_freak> the SCGI protocol is somehow amateurish
01:19:07 <yakov> hello
01:25:30 <quicksilver> WOOOO! HWN!
01:25:31 <quicksilver> dons++
01:27:48 <dolio> Perhaps the acronym should be changed to mean Haskell Whenever News. :)
01:28:05 <quicksilver> Haskell Wonderful News
01:30:19 <dons> dolio: i like that :)
01:30:44 <dons> i'm expecting it to get a bit more 'weekly' once i start my new job. i will try to be roughly fortnightly till then though
01:31:07 <dolio> That'll be nice.
01:33:08 <quicksilver> haskell >>= when news
01:34:27 <gmosx> hello
01:38:03 <dons> hi, welcome.
01:38:28 <mux> hello there
01:40:10 <ejt> is there a way to get an execution trace from a ghc compiled program ?
01:40:57 <dons> only with profiling. or hmm, ghc head with hpc or the ghc debugger
01:41:17 <ejt> ah, perhaps I should look at the debugger, thx
01:42:28 <gmosx> is it possible to dynamically call functions in Haskell? ie I have the name of the function as a string, is it possible to call/evaluate the function?
01:45:31 <ejt> gmosx: you could set up a map of string -> fn before hand
01:45:39 <ejt> but in general, no
01:46:17 <gmosx> ejt: !
01:47:02 <gmosx> and I guess there is nothing equivalent to Ruby's method_missing ?
01:47:41 <norpan> gmosx: i expect you'd get into trouble with the type system
01:48:03 <norpan> but using Dynamic should be possible
01:48:05 <gmosx> norpan: hmm right...
01:49:38 <quicksilver> gmosx: there is a program called hsplugins which lets you do that kind of thing
01:49:58 <hpaste>  fdfgdf pasted "irc" at http://hpaste.org/1851
01:49:59 <quicksilver> it is essentially a wrapper around the kind of thing ghci does
01:50:51 <gmosx> qs: thanks will have a look at this...
01:51:08 <quicksilver> gmosx: in my experience it's very unusual to actually need eval, though
01:52:05 <gmosx> I was just courious...
01:52:50 <gmosx> I am experimenting with haskell these days... I would like to attempt to write a small web framework...
01:53:16 <gmosx> I would like to port some of the ideas from my ruby web framework though... (nitroproject.org)
01:53:23 <mux> gmosx: heard about HAppS?
01:53:29 <mux> ?where happs
01:53:29 <lambdabot> http://happs.org
01:53:32 <gmosx> yeah I heard about it
01:53:45 <quicksilver> happs is a very different web framework
01:53:46 <gmosx> I am reasearching this...
01:53:56 <gmosx> i dont like the db system...
01:54:06 <gmosx> I used a similar technique some years ago...
01:54:10 <gmosx> had many many problems
01:54:27 <quicksilver> for a web framework, I'd expect a map from strings -> fns
01:54:27 <gmosx> had to switch back to an ORM over RDBMS solution...
01:54:30 <quicksilver> that's fine
01:54:38 <quicksilver> you don't need eval for that
01:54:48 <gmosx> qs: yeah you are probably right, that would be safer too i guess...
01:54:49 <quicksilver> just a (possibly rather complicated) map from URLs to actions
01:55:21 <gmosx> yeah... I am trying to figure out how to implement the dispatcher... (urls - actions)
01:56:03 <kilimanjaro> just out of curiosity, are there any good benchmark comparisons of idiomatic haskell to other languages? the stuff in the shootout is pretty ugly
01:56:35 <dons> its not so bad now, for low level code
01:56:55 <dons> you should expect to be somewhere between C and python
01:57:32 <pejo> It would be quite interesting to know how often people write things that are "too slow" in Haskell.
01:57:51 <wli> System.Console.readline behaves weirdly wrt. signals.
01:58:31 <kilimanjaro> pejo, probably not that often, I dont thing performance matters a lot in general
01:58:38 <kilimanjaro> i was just curious about benchmarks
01:58:39 <steven_ashley> pejo: most of the problems I have are regarding space leaks which in turn, causes speed issues
01:58:51 <dons> is good to know that you can get down to C if you need it, or close.
01:58:58 <dons> space leaks are usually obvious though, which is good
01:59:04 <steven_ashley> yep :)
01:59:04 <dons> if you have one, you really know it :)
01:59:06 <kilimanjaro> ghc does have some nifty low level features
01:59:45 <dons> yeah, other high level languages, like python or ruby, don't really have the option : they must go to C for that kind of performance
02:01:20 <dons> interesting icfp team #16 is now at 7.6915%.
02:01:27 <dons> so i wonder, maybe endo will live after all
02:01:50 <|Steve|> Endo?
02:02:04 <dons> icfp contest is running this weekend, must be almost over now..
02:02:14 <|Steve|> I'm afraid I don't know what icfp is.
02:02:27 <dons> http://www.icfpcontest.org/ :)
02:02:28 <lambdabot> Title: ICFP Programming Contest 2007
02:02:34 <dons> big contest haskell keeps winning... :)
02:02:45 <|Steve|> Ah.
02:02:47 <dons> 850 teams this year
02:02:57 <ejt> no sleep this weekend
02:03:11 <wli> Wasn't the ICFP started by Caml types?
02:03:16 <matthew-_> so I guess about 2550 /very/ tired people by this point
02:03:25 <|Steve|> When you said endo, I was thinking of endomorphisms.
02:03:27 <dons> i think spj et al won the first one, didn't they?
02:03:39 <|Steve|> I was hoping you were talking about endomorphisms because #math has been so horribly boring this summer.
02:04:14 <Syzygy-> |Steve|: The backstory for the competition is about an alien named endo traveling a ship called arrow.
02:04:30 <Syzygy-> |Steve|: It all is pretty damned close to the Haskellite terminology even to begin with.
02:04:43 <xerox> Morph Endo!    Endomorh
02:04:50 <Igloo> I think we should ask the organisers to make the boilerplate contest available, and to tell us what non-disclosable parts of it Jurriaan Hage worked on
02:06:57 <quicksilver> dons: which are the good haskell teams this year?
02:08:31 <matthew-_> tail call recursion is just a special case of tail call optimisations right?
02:08:54 <matthew-_> and Haskell does both doesn't it?
02:08:54 <gmosx> is there a templating system for Haskell? StringTemplate perhaps?
02:09:16 <matthew-_> gmosx: you want to do string substitutions yes?
02:09:22 <gmosx> yeah
02:09:24 <wli> I'm not sure there's a direct translation of tailcall optimization in lazy languages.
02:09:52 <matthew-_> gmosx: if this is for html, the only one I know of is html chunks
02:10:07 <gmosx> let me google this
02:10:13 <matthew-_> but there are a couple of others I think were mentioned on the mailing list recently
02:10:56 <matthew-_> gmosx: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/chunks
02:11:03 <xerox> quicksilver: solo r6 did very well, he's roconnor
02:11:14 <matthew-_> gmosx: I wrote it ;-) It's ok, I'm not sure it's really great.
02:12:03 <matthew-_> gmosx: most people seem very happy just using the xhtml combinators and then eliminating the need for the substitutions
02:12:07 <gmosx> matthew-_: I 'll check this out
02:12:15 <matthew-_> but that argueably breaks abstractions anyway
02:12:29 <gmosx> i would like to use templates (that a designer can handle)
02:12:32 <quicksilver> matthew-_: also not great if your target is to allow non-technical designers
02:12:41 <quicksilver> matthew-_: to modify/create the HTML
02:12:48 <gmosx> it would be difficult to educate a designer to use combinators
02:12:57 <matthew-_> right. Yeah, I've suffered that a few a few times
02:13:09 <dons> quicksilver: well, 'solo r6' is roconnor, working on his own
02:13:14 <matthew-_> we tend to get the designers to build a static walkthrough of the site
02:13:20 <|Steve|> How is the laziness obtained anyway? Is the compiler free to do more work than strictly required? For example, if you have a lazily constructed list and you want the 5th element, is the compiler (or runtime really) free to calculate up to the 10th element, for example?
02:13:21 <quicksilver> damn, even by the standards of ICFP that's a complex problem
02:13:33 <matthew-_> ...then we grab their html, tell them to sod off and then get on with it ourselves
02:13:42 <quicksilver> |Steve|: only if it has managed to prove that is a safe thing to do
02:14:00 <|Steve|> Can it be unsafe ever?
02:14:02 <quicksilver> |Steve|: if the 6th element is a computation that runs forever...
02:14:10 <quicksilver> then it could be a mistake to calculate that before producing the 5th
02:14:10 <|Steve|> Ah.
02:14:23 <wli> |Steve|: Basically leftmost reduction strategy with memoization so substitution reductions don't cause explosive space usage.
02:14:46 <dons> quicksilver: he's the top rank. then 'Team PDX'
02:15:02 <dons> quicksilver: then Lazy Bottoms, cdmsith, a few others
02:15:02 <quicksilver> particularly complex to explain rather than particularly complex to solve
02:15:07 <dons> "Subject: [Haskell] View patterns in GHC: Request for feedback
02:15:07 <dons> Hi everyone,
02:15:07 <dons> Simon PJ and I are implementing view patterns, a way of pattern matching
02:15:07 <dons> against abstract datatypes, in GHC.  Our design is described here:
02:15:10 <dons> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
02:15:10 <quicksilver> dons: *nods*
02:15:12 <lambdabot> Title: ViewPatterns - GHC - Trac
02:15:12 <dons> "
02:15:14 <dons> !
02:15:30 <wli> quicksilver: I took one look and said no way in Hell.
02:15:32 <xerox> quicksilver: I think it's particularly opaquely described :)
02:15:32 <quicksilver> my gut feeling is that this ICFP has quite a lot of luck involved
02:15:35 <mm_freak> hmm…  there aren't many real world haskell programs to read the source and learn from =/
02:15:42 <|Steve|> Do you find that the laziness makes it very hard to reason about the performance of algorithms or do you get used to it?
02:15:57 <matthew-_> wli: that was roughly my reaction too
02:16:02 <fasta> I have c1 calling fail "foo" or returning a number and cd calling fail "bar" or returning a number. When both fail, the whole computations fails, when one fails return the other number, when both succeed take the smallest number. What's the best way to do that? The code is currently running in runMaybeT
02:16:23 <fasta> s/cd/c2
02:16:25 <wli> |Steve|: It doesn't really make a dent as far as I'm concerned.
02:16:25 <matthew-_> wli: so my "team" spent the wk/end hacking our latest game rather than just swearing at our own incompetance and the ICFP
02:16:27 <quicksilver> |Steve|: it most cases, "worst-case" reasoning is still easy enough, and occasionally the 'best case' is better than you expected
02:16:45 <wli> matthew-: Game?
02:17:00 <quicksilver> |Steve|: but it is certainly possible to get surprised by a space leak until you're used to them
02:17:11 <fasta> mm_freak: You can learn plenty of GHC (large) or xmonad(small)
02:17:19 <|Steve|> Why do you call them space leaks? Memory leaks is what every other language calls'em.
02:17:22 <matthew-_> wli: a thing you play, in this case involving a computer. :-P
02:17:29 * matthew-_ apologises
02:17:38 <fasta> |Steve|: because it was invented by academics
02:17:45 * fasta ducks
02:17:49 <wli> matthew-: Are you writing video games? Text adventures? Playing video games? Or what?
02:17:53 * |Steve| is an academic.
02:18:06 * |Steve| enjoys writing video games at times.
02:18:11 <matthew-_> wli, ahh, sorry. It's a video game. We're writing it.
02:18:28 <mm_freak> fasta: xmonad is a good idea…  GHC is probably too complex for now
02:18:47 <gmosx> matthew-_: does html chunks support loops too?
02:18:52 <matthew-_> wli: it's the second one we've tried to write. The first was a desaster but was a great learning experience. The second is simpler and we have a much greater chance of finishing it.
02:18:55 <fasta> mm_freak: xmonad is not Haskell 98, though
02:19:02 <fasta> mm_freak: if you care about portability...
02:19:10 <fasta> mm_freak: xmonad is "modern Haskell"
02:19:11 <matthew-_> gmosx: yes - look at the examples - there's the shopping list in there which is looping
02:19:16 <gmosx> ok
02:19:32 <matthew-_> gmosx: the looping is done in the application code, not in any embedded dsl in the html
02:19:52 <gmosx> matthew-_: hmmm
02:20:00 <matthew-_> fasta: meh, the best bits of Haskell are found in GHC 6.7 upwards ;)
02:20:11 <mm_freak> fasta: that's ok…  most likely my own code isn't going to be haskell 98, too
02:20:31 <fasta> mm_freak: does your IRC client convert ... to three little dots automatically?
02:20:52 <mm_freak> fasta: i type them manually (xmodmapped to AltGr + .)
02:20:54 <fasta> mm_freak: they use ATs already?
02:21:02 <wli> matthew-: I sort of had a shocking experience with monad transformers today.
02:21:09 <mm_freak> AT?
02:21:19 <fasta> matthew-_: that was for you
02:21:31 <fasta> mm_freak: wrong person
02:21:54 <wli> matthew-: I did all the problems in YAHT today, and the monad chapter had some stuff I managed to sort of barely get to work that blew me away.
02:21:56 <matthew-_> fasta: no, I have to say I currently prefer fundeps to ATs. That may change if I'm forced to change.
02:22:15 <fasta> I have c1 calling fail "foo" or returning a number and c2 calling fail "bar" or returning a number. When both fail, the whole computations fails, when one fails return the other number, when both succeed take the smallest number. What's the best way to do that? The code is currently running in runMaybeT
02:22:20 <matthew-_> fasta: just the better implementation of GADTs with context propogation etc. It's "better"
02:22:27 <wli> What's AT supposed tostand for?
02:22:38 <wli> Oh, AT == GADT++?
02:22:46 <matthew-_> no
02:22:48 <fasta> matthew-_: I don't use GADTs, so I don't care.
02:22:53 <matthew-_> wli: AT == Associated Types
02:22:53 <fasta> matthew-_: but that might change.
02:23:23 <matthew-_> it's sortof roughly similar to functional dependencies
02:23:28 <matthew-_> kinda
02:23:30 <wli> I've not got a grip on how GADT's are used, and I've never even seen associated types.
02:23:45 <wli> I'm mostly clueless in the fundep department, too.
02:23:46 <fasta> The semantics are supposed to be easier to understand of ATs
02:23:55 <mux> ATs and GADTs are totally different things
02:24:14 <fasta> wli: ATs are new in 6.7
02:24:32 <wli> mux: That's okay. I'm clueless on both fronts, or perhaps all three.
02:24:57 <fasta> wli: fundeps resolve ambiguity
02:25:34 <fasta> wli: in the case of MonadState: the monad contains the state type already, so given the monad type, we know the state type
02:25:41 <matthew-_> wli: GADTs are very useful when you want to manually specify type parameters in a non-obvious way. Normal ADTs are very regimented as to how type parameters must work.
02:25:43 <wli> I'm having trouble enough with monads and monad transformers in the Haskell 98 sphere. All this will come later.
02:25:55 <fasta> wli: with ATs often MPTCs convert to single parameter type classes.
02:26:03 <matthew-_> wli: give it 6 weeks, or 6 months, depending on how much time you have ;-)
02:26:09 <fasta> wli: that is the "associated types" become truly associated.
02:26:20 <fasta> wli: from that point of view fundeps are a hack.
02:26:28 <mux> associated data types are already in GHC HEAD, but associated type synonyms aren't there yet
02:26:42 <quicksilver> although they have recently been completed
02:26:45 <quicksilver> and should be in head soon
02:26:58 <matthew-_> mux: yeah, and aren't the synonynms the ones that are closest to fundeps?
02:27:08 <fasta> So, anyone got a suggestion for my computation?
02:27:24 <mux> I think so; at least to rewrite MonadState with ATs, you'd need associated type synonyms
02:27:29 <matthew-_> yeah
02:27:34 <mux> I did that some time ago and sent a mail to haskell-cafe@ because it wasn't working
02:27:44 <mux> and spj replied saying associated type synonyms aren't there yet
02:28:16 <quicksilver> fasta: a <- foo; b <- bar; return (min a b) ?
02:28:26 <mux> associated data types allow very interesting things; such as the GMap library you can find in GHC's trac
02:28:30 <wli> Well, the way this went was that I learned Haskell as a sort of instance of the ML family back around 1998.
02:28:50 <quicksilver> wli: yes, my first introduction to haskell was 'ML without the annoyances'
02:28:54 <fasta> quicksilver: failure is returned when one of the two fails in your code
02:28:56 <matthew-_> mux: yeah, I've read all those papers. And yes you can do interesting things.
02:29:05 <wli> There was overloading, which was convenient, and I never bothered with all the monad bits.
02:29:12 <fasta> quicksilver: unless I miss a point about runMaybeT
02:29:37 <quicksilver> fasta: oh, good point, I didn't understand you correctly
02:29:41 <matthew-_> fasta: you could always expand it out using two Either s and then combine them as you want
02:29:47 <mux> http://hackage.haskell.org/trac/ghc/wiki/TypeFunctionsExamples
02:29:48 <lambdabot> Title: TypeFunctionsExamples - GHC - Trac
02:29:50 <quicksilver> fasta: I don't think there is a built-in combinator for that
02:30:15 <wli> So for the past 8-9 years I've been writing ML in Haskell, to the extent I write any Haskell at all.
02:30:49 <fasta> matthew-_: I don't see what you mean.
02:30:55 <wli> In all honesty I only really dust ghc off maybe a few times a year, often in/around the ICFP.
02:32:39 <wli> It's become apparent to me that the "ML with overloading" subset of Haskell is rather grossly backward relative to the state of the art (vastly worse than was the case in 1998, if you care to make the point).
02:33:16 <matthew-_> fasta: Well, I can't remember if Either is a Monad - isn't Either Error a monad? Something like that. Anyway, I think that should do what you want. - get two Eithers from foo and bar and combine them
02:33:48 <opqdonut> ?instances Monad
02:33:49 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
02:33:59 <fasta> matthew-_: I was thinking in Maybe
02:34:09 <opqdonut> ?src ErrorT
02:34:09 <lambdabot> newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }
02:34:17 <opqdonut> there :)
02:34:41 <matthew-_> fasta: yeah, well that should be the same. So it could also be in MonadPlus which might give you some ideas
02:35:52 <wli> So anyway, my plot is to do some learning, which will probably be quite a bit more sporadic now that the ICFP is over.
02:37:29 <ejt> dons: how stable is ghc6.7 ?
02:42:52 <wli> I need something like "A Rough Introduction to Monads" that beats you in the face with a huge number of programming exercises.
02:43:37 <mm_freak> what if a package has thousands of data files…  can't i use directories in cabal's data-files property?
02:46:36 <fasta> matthew-_: It's not really elegant (and not generic), but I wonder whether it can be improved at all: http://paste.debian.net/33235
02:46:51 <chylli> what's the common newsgroup of haskell? There are too many newsgroups about haskell. I don't know which one  I should subscribe at first.
02:47:33 <ejt> chylli: haskell-cafe is good
02:47:39 <fasta> chylli: haskell-cafe, but that is a mailing list, not a newsgroup.
02:47:57 <chylli> ok, thanks
02:47:57 <opqdonut> fasta: using monadic maybe operations might improve it slightly
02:48:04 <matthew-_> fasta: err, you may have just written liftM2
02:48:29 <opqdonut> yeah, that's it except for the c1/c2 return
02:48:30 <matthew-_> ahh, no you haven't. I see
02:48:40 <mm_freak> chylli: there's also comp.lang.haskell
02:48:41 <matthew-_> opqdonut: exactly ;)
02:48:50 <fasta> opqdonut: well, that's the problem.
02:49:11 <fasta> opqdonut: the "monadic" matching on failure.
02:49:19 <chylli> gmane.comp.lang.haskell.cafe. I think it is a newsgroup at all time. :p
02:49:31 <opqdonut> fasta: thought about using mplus?
02:49:39 <fasta> opqdonut: yes, about 20 seconds.
02:49:53 <fasta> opqdonut: but I didn't see how it would help
02:50:57 <fasta> opqdonut: oh, well, I think I found it.
02:51:04 <matthew-_> opqdonut: there seems to be a loop in this conversation!
02:51:08 <fasta> opqdonut: or maynbe not.
02:51:21 <fasta> matthew-_: all conversations have that property
02:51:33 <opqdonut> if isJust result1 and isJust result2 then f (fromJust result1) (fromJust result2) else mplus result2 result1
02:51:46 <opqdonut> pseudo-codish but that's it
02:52:13 <fasta> opqdonut: that's worse than my code, imho.
02:52:32 <opqdonut> clearer imo
02:52:35 <opqdonut> :)
02:52:43 <matthew-_> the f would need to be :: a -> b -> Maybe c wouldn't it?
02:52:49 <fasta> I know it.
02:52:56 <fasta> I will code it up now.
02:53:04 <opqdonut> if isJust result1 and isJust result2 then liftM2 f result1 result2 else mplus result2 result1
02:53:08 <opqdonut> slightly better
02:53:37 <opqdonut> you could just do a pattern match against (result1,result2) if that's clearer
02:53:58 <matthew-_> yeah, I prefer that - keeps the type of f out of Maybe
02:54:28 <matthew-_> (err, to the revised code, not to the tuple)
02:54:39 <opqdonut> yeh
02:55:43 <opqdonut> and of course, using "Just result1 <- c1" pattern matching in the original do-code might clear it up a bit
02:57:14 <fasta> combine_computations :: (MonadPlus t) => (t1 -> t1 -> t1) -> t t1 -> t t1 -> t t1
02:57:18 <fasta> I win :)
02:57:44 <matthew-_> (isJust result1 and isJust result2) would be (isJust . liftM2 const) though it's less clear I guess
02:57:45 <fasta> Thinking something is not possible makes it harder.
03:01:04 <dons> ?users
03:01:04 <lambdabot> Maximum users seen in #haskell: 340, currently: 338 (99.4%), active: 18 (5.3%)
03:02:07 <swiert> dons: Are you still planning on writing something about XMonad for TMR?
03:02:11 <xerox> 4/AWAY
03:02:21 <swiert> Or has your thesis taken over your life?
03:02:39 <dons> swiert: it has taken over, yes :/
03:03:00 <dons> swiert: maybe you could get lennart to gather together his blog posts about Harpy and writing little compilers?
03:03:17 <pejo> Look at the bright side of things though, once you're done with it you can focus on all the Haskelly things again. :-)
03:03:20 <dons> (today's HWN has a few other bloggers who might be worth hitting for an article)
03:03:32 <dons> pejo: yeah!!
03:03:47 <xerox> oops
03:03:55 <swiert> dons: Yes. I've been asking Lennart to write up something as well.
03:04:20 <swiert> dons: When do you intend to submit?
03:04:34 <dons> probably Oct, but I need to get most of it done by Sept
03:05:04 <swiert> And then the big move?
03:05:20 <dons> big move at the start of Sept :)
03:05:54 <pejo> dons, is there a forced amount of time between submission and defense?
03:05:59 <swiert> Cool. Did you know Graham's at Galois at the moment? He seems to having a good time.
03:07:07 <dons> oh? didn't know that.
03:08:08 <dons> ah yes, i see he mentions it on his website. cool.
03:10:24 <quicksilver> in my experience the main determining factor for defense timing is the availability of your examiners
03:11:10 <pejo> quicksilver, no regulations about how long it must be printed before defense?
03:11:22 <quicksilver> I'm sure there are regulations
03:11:29 <quicksilver> I broke most of them
03:11:36 <pejo> Haha, ok.
03:11:37 <quicksilver> they still gave me the award in the end ;)
03:11:57 <quicksilver> around 3 years from completion to award though, not the ideal profile
03:17:29 <hpaste>  vincenz pasted "DNA.Compiler" at http://hpaste.org/1852
03:20:21 <dons> so, maybe PurelyFunctionalInfrastructure was a haskell team, if so , that's a team in the top 20. otherwise looks like roconnor at #32 was the highest rank.
03:20:44 <dons> so hopefully some other secret haskell team gets us over the line for the 4th year in a row, will be interesting..
03:24:12 <roconnor> the difficulty of the puzzle was a signifigant factor.
03:24:28 <roconnor> the cules that were scattered were really really light.
03:25:28 <quicksilver> it looked to me like luck would be involved
03:25:37 <swiert> Does anyone here know whether the Haddock in HEAD can cope with infix type constructors?
03:25:54 <roconnor> some bugs helped me find some of the clues
03:26:15 <dons> yes, it seems hard. i guess only 10 or so teams got above 10%
03:26:56 <quicksilver> when will they publish the results?
03:27:06 <swiert> quicksilver: At ICFP.
03:27:32 * quicksilver nods
03:27:36 <dons> i'm glad the haskell teams seemed to manage with bytestrings
03:27:57 <dons> i think it would have been a lot harder a couple of years ago, with all that big string processing.
03:28:07 <quicksilver> roconnor: was computational power an issue for you?
03:28:07 <roconnor> I'm also interested in these Seq implementations
03:28:19 <roconnor> quicksilver: Probably
03:28:22 <dons> roconnor: yes, do you think having acces to large machines would have helped?
03:28:32 <roconnor> oh
03:28:48 <roconnor> Well, it would have helped me because my interpreter was so slow
03:29:02 <roconnor> but after a point, I'm don't think it would help anymore
03:29:17 <matthew-_> dons: speaking of bytestring and lazy IO, are there weird special cases for hPut-ing to a handle to a network socket?
03:29:34 <roconnor> improving my code would have been just as good.
03:29:50 <quicksilver> matthew-_: output is never lazy, afaik
03:29:58 <matthew-_> quicksilver: ahh, only input right?
03:30:01 <quicksilver> matthew-_: I've not been aware of any special cases and I've done network IO
03:30:08 <dons> matthew-_: not that i know of, other than ensuring buffering on the Handle is set correctly
03:30:19 <matthew-_> sure, I've set it to NoBuffering
03:30:21 <roconnor> oh, and I want to see this GUI that I've heard about.
03:30:33 <matthew-_> cool, well that clears up some of my confusion. :)
03:30:47 <roconnor> I spent my time with GHCi
03:30:55 <blackdog> i'm kinda curious: did anyone try ignoring endo's dna and just constructing a prefix that created the picture?
03:31:19 <fasta> find f s.t. f [mplus_v1, mplus_v2, ...] == mplus_v1 `mplus` mplus_v2 `mplus`. ...
03:31:40 <blackdog> sort of a brute force approach, but doing it with the clues semed really hard
03:31:44 <quicksilver> fasta: msum ?
03:31:45 <xerox> roconnor: http://cale.yi.org/autoshare/Screenshot-RNA%20GUI-1.png
03:31:50 <fasta> quicksilver: right
03:32:03 <fasta> quicksilver: it's hard to be aware of all combinators :)
03:32:17 <quicksilver> :)
03:32:22 <roconnor> damn
03:32:33 <roconnor> I missed out on that
03:32:50 <roconnor> is that a usefull string?
03:32:54 <xerox> no idea
03:33:16 <roconnor> is that in every picture?
03:33:21 <dons> seafoodX: how'd you go?
03:33:42 <xerox> Cale: how did you find that?
03:33:43 <dons> oh, do we know some people in that picture?
03:34:37 <dons> xerox: did cale write a little gtk gui?
03:34:44 <xerox> yes
03:34:53 <dons> very nice.
03:35:05 <xerox> Gtk2Hs is fantastic
03:35:09 <fasta> Did endo survive?
03:35:25 <dons> fasta, possibly, we don't know what the top 15 teams got
03:35:26 <kosmikus> fasta: Arrow's silent right now, but we hope so ...
03:35:38 <xerox> I hope somebody will make a video of this year ICFP
03:35:50 <fasta> Team Smartass did well again.
03:35:57 <xerox> like malcolm did last year
03:36:11 <fasta> I wouldn't be surprised if they win again.
03:37:02 <roconnor> I expect them to win every year from now on
03:39:10 <fasta> Maybe it's a secreat company goal.
03:39:17 <fasta> Win ICFP every year :)
03:39:22 <fasta> secret*
03:39:54 <pejo> I don't think it's a secret that google wants to do well in everything they do.
03:40:36 <fasta> Doesn't everyone who competes wants to do well?
03:40:38 <bartw> xerox: did you use an 8point fill ?
03:40:43 <Cale> xerox: It was fun
03:40:54 <Cale> xerox: I'd actually like to continue a bit.
03:41:19 <xerox> Yeah.
03:41:27 * roconnor thinks of Team Smartass as a Waterloo team
03:41:41 <Cale> Is it?
03:41:43 <Cale> Who is on it?
03:41:54 <dons> would some clever parallel programming have helped? do the problems look terribly parallel?
03:42:20 <roconnor> Derek Kinsmen (sp?) and Chris Hendrei (sp?) when to Watelroo
03:42:25 <quicksilver> it struck me as more of a human problem than a programming one?
03:42:29 <roconnor> and I think they are on the team
03:42:30 <quicksilver> I mean, sure, you need to write a computer program
03:42:31 <xerox> dons: likely 0 parallelization possible, in the program, but it was usefulto have more executions in parallel
03:42:50 <quicksilver> but the 'trick' is in understanding endo's DNA and thinking of cunning ways to subvert/re-use it
03:42:59 <Cale> roconnor: cool
03:43:01 <dons> xerox: string search is parallisable though
03:43:01 <quicksilver> all the computer can do is give you tools to make that tractable
03:43:17 <quicksilver> how long was endo's DNA string?
03:43:28 <Cale> quicksilver: I actually came across a big clue just by corrupting the dna.
03:43:31 <xerox> dons: yes, right
03:43:45 <roconnor> quicksilver: 7523060
03:43:48 <Cale> (by hand in an editor)
03:43:48 <roconnor> base pairs
03:43:58 <quicksilver> Cale: did it have big unused chunks like real DNA does?
03:44:16 <dons> did anyone pack bases into bits? or was Word8 the standard type?
03:44:22 <roconnor> quicksilver: they have dormant genes
03:44:30 <quicksilver> roconnor: ah yes, there was a clue about that
03:44:53 <quicksilver> I wonder if anyone got anywhere by random mutation + combining GA style
03:44:54 <bartw> started with 2 bits per base 4 in a byte
03:45:12 <bartw> but after seeing memory usage i quicly reverted back to bytes for simplicity
03:45:14 <quicksilver> how fast did people's interpreters run?
03:45:22 <bartw> 1.5k iter/sec
03:45:30 <roconnor> It took me about 15 minutes to process endo
03:45:43 <roconnor> a barely acceptable rate for me
03:45:49 <quicksilver> bartw: so how long to process all of endo?
03:46:04 <dons> bartw, oh? memory use suffered in your implementation of bit packing?
03:46:09 <roconnor> I'd say it was unacceptable if it were for the fact that I used it.
03:46:10 <bartw> 15mins for before image
03:46:33 * quicksilver nods
03:46:39 <matthew-_> dons: you still awake?
03:46:41 <quicksilver> same as roconnor
03:46:44 <dons> matthew-_: ?
03:46:48 <dons> ?time
03:46:52 <lambdabot> Local time for dons is Mon Jul 23 20:45:49 2007
03:46:54 <quicksilver> bartw: were you working solo too?
03:46:55 <matthew-_> right, with Data.Binary and Put and ByteString
03:47:08 <matthew-_> Put seems to construct lazy bytestringns
03:47:13 <dons> it does
03:47:14 <bartw> i had two people round, but it ended up being of little help
03:47:20 <matthew-_> which then means they're not exactly efficient over the wire
03:47:26 <dons> desp wrote a strict builder during the contest, but it reallocated too much to be useful
03:47:31 <matthew-_> so I want to compact them as much as possible
03:47:33 <dons> i think most people used lazy bytestrings?
03:47:42 <matthew-_> so that I'm sending the least amount of data over the network
03:47:46 <bartw> quicksilver: the communication overhead combined with the social nature of my teammates meant that coding didn't go as fast as it could have
03:47:48 <matthew-_> how would I do that?!
03:47:55 <dons> matthew-_: lazy bytestrings should be very efficient?
03:48:12 <bartw> they only had time on saturday, 12-24 so also for little time
03:48:20 <dons> matthew-_: oh, you want to compress the dta with gzip or something?
03:48:23 <matthew-_> but if you put one word8 into in, then send it down a handle to a network socket, 8 words are sent due to the chunk
03:48:40 <matthew-_> no, I don't want to compress it. I just don't want to send lots of 0-word8s
03:48:45 <dons> matthew-_: hmm? oh, due to the encoding of some value?
03:48:53 <dons> bytes will just be sent as bytes
03:49:02 <bartw> so what datastructure did you use ? i had a bigass byte[] with sequence and concat wrappers around it
03:49:11 <dons> but some values, such as [a], will be encoded in a form with length data and so on
03:49:14 <matthew-_> right, but sending the bytestring - the bytestring seems to have a minimum size of 1 chunk
03:49:15 <bartw> and i flattend it whenever the depth became greater then 100
03:49:46 <dons> bartw: yeah, others did that too, coalescing/copying bytestring chunks when the spine got too big
03:50:05 <bartw> that was attempt #4
03:50:28 <bartw> annoyingly attemp #1 would have worked if it had had flatteing
03:50:38 <dons> matthew-_: can you clarify the problem you're having a bit?
03:50:39 <bartw> would have saved me maybe 12 hours in the end
03:50:48 <matthew-_> dons: sure
03:51:01 <dons> what type are you 'put'ing onto the network?
03:51:20 <mm_freak> which cabal Category should i choose for PRNGs?
03:52:12 <Igloo> mm_freak: The first part of the module name is what you normally use
03:52:39 <quicksilver> bartw: 12 hours barely enough time to understand this problem properly, let alone solve it :(
03:52:48 <mm_freak> igloo: what is the first part of X.Y.Z?  is it X.Y or X?
03:52:52 <matthew-_> dons: I have an instance Binary Foo where the put just does put (1::Word8). Then I do encode Foo to get a lazy byte string. Then I do BSL.hPut hdl theEncodedFoo. Wireshark seems to show that the values going over the network consist of more than just 1::Word8. So I'm guessing that it's sending the whole chunck. I.e. encode returns a Lazy ByteString with length greater than or equal to the amount of "encoded" data rounded to the ceiling chunk.
03:53:07 <vincenz> dons: sorry about the bot
03:53:10 <vincenz> dons: lambda was out
03:53:20 <vincenz> @bot
03:53:20 <lambdabot> :)
03:53:39 <matthew-_> dons: I think. This is largely guess work ;)
03:53:49 <dons> matthew-_: hmm, it shouldn't write more than the data you put.
03:53:54 <bartw> quicksilver: next year i need some better teammates, or go it alone once again
03:53:55 <quicksilver> bartw: I was thinking that in a team, it would be good to devote one member to the pure task of getting the interpreter as fast as possible
03:54:08 <Igloo> mm_freak: X
03:54:08 <matthew-_> dons: oh, ok. In which case I'll to write out a test and check it properly.
03:54:09 <dons> vincenz: can you give me ops on oasisbot though, so i can fix this when it happens?
03:54:18 <mm_freak> thank you
03:54:18 <dons> matthew-_: yeah, just write it to a file, and 'od' it
03:54:19 <vincenz> ok
03:54:22 <quicksilver> bartw: *nods*
03:54:25 <vincenz> dons: tho he won't be aroud for much longer
03:54:26 <bartw> quicksilver: that would work, we did that, they wrote the rna2image, but that was an easy task
03:54:28 <dons> matthew-_: send me a test case if that doesn't work.
03:54:33 <matthew-_> dons: will do
03:54:45 <bartw> quicksilver: i asked them to work on the dna but didn't, also asked them to write unittests and didnt
03:56:00 * quicksilver nods
03:56:25 <matthew-_> dons: is that the case even if you directly call putLazyByteString in Data.Binary.Put ?
03:56:28 <mm_freak> hmm…  the System category seems inappropriate for my generator, because it's more like an experimental number-theoretic generator
03:56:44 <dons> matthew-_: putLazyByteString just makes a chunk out of its arguments
03:56:55 <dons> so it should place , with 0 copies, your bytes into output
03:57:13 <bartw> quicksilver: not using a version control system was another mistake
03:57:52 <quicksilver> bartw: yeah, the trick with those things is familiarity
03:58:05 <mm_freak> should i name it Data.Random.DLPGen or System.Random.DLPGen ?
03:58:06 <Cale> quicksilver: unused, I'm not sure. But on most runs, most of the DNA would be inactive.
03:58:08 <quicksilver> bartw: you need (the whole team) to be familiar with the same testing framework, the same VCS, etc etc
03:58:19 <mm_freak> or even something completely different?
03:58:31 <quicksilver> Cale: I was thinking about using random mutations to identify active and inactive DNA portions
03:58:46 <bartw> quicksilver: lets move to #oasis with the other icfp chat
03:58:47 <Cale> quicksilver: One way to look at it is that the DNA is an encoding of an object (in the OO sense)
03:58:48 <quicksilver> Cale: but this would only be sensible if people had interpreters running faster than 15 mins
03:59:49 <Cale> quicksilver: Well, a little more than that -- it has an area where code is loaded and executed, it has a table of methods and parameters, and then it has a stack.
03:59:50 <quicksilver> Cale: as in, it's the code for a bunch of methods which aren't all called?
03:59:56 <ejt> don't tell me how; but did anyone get an efficient implementation of dna -> rna written in haskell for the ICFP contest ?
03:59:59 <Cale> quicksilver: yes
04:00:01 <quicksilver> Cale: yeah
04:00:09 <Cale> ejt: we did
04:00:24 <ejt> k, I shall persist with my one then ...
04:00:39 <Cale> ejt: The data structures you choose are absolutely crucial.
04:00:51 <ejt> y, this is the third one I'm on
04:01:24 <Cale> ejt: yeah, it took us an unfortunately long time before we wrote it properly
04:01:38 <dons> ejt, yeah, several people seem to have properly efficient bytestring or Data.Sequence versions
04:01:53 <dons> we should have a little shootout page like last year
04:01:59 <Cale> I'd really like to see the ByteString version.
04:02:01 <bartw> hehe
04:02:18 <Shimei2_> I tried to implement a Haskell VM with lists and bytestrings in parallel with our C VM, but it never ran right. I think more algorithmic than with data structures though.
04:02:18 <dons> desp, roconnor, genneth all had good bytestring versions
04:02:20 <bartw> so i heared about 40ki/s versions ?
04:02:25 <lorne> http://varsztat.com/clfp/dna2rna-src/ <- bytestrings
04:02:26 <lambdabot> Title: Index of /clfp/dna2rna-src
04:02:29 <dons> yeah, desp was running 40ki/s
04:02:42 <matthew-_> dons: ignore all of that. I'm very wrong. In fact, so wrong, I'm not sure from where I got the idea I was right!
04:02:49 <dons> matthew-_: phew :)
04:03:01 <Cale> <spoilers> We used [RNAOp] -> [RNAOp] and Seq Base
04:03:12 <ejt> I have a FastString data type.  data FastString = Packed ByteString | Simple String | Cat FastString FastString | Range Int Int FastString
04:03:28 <Cale> applying the RNA function at the end of each iteration
04:03:29 <bartw> ejt: same, but in c# :)
04:03:43 <bartw> flattening it when the depth becomes 100+
04:03:43 <matthew-_> dons: there is something odd going on with packet fragmentation though - the length of the bytestring is always written first, and always seems to be in a separate packet. Mmm. Must be some socket option I guess...
04:03:45 <Cale> (to the empty list, which was ++'d onto the output)
04:04:08 <Cale> That way, the output was lazy and the input was strict.
04:04:35 <Cale> and we had log time operations everywhere that it mattered
04:04:42 <matthew-_> dons: which a pain, when then bytestring has 1 word8 in it => 2 packets, one with an Int64 as the data, and the second packet with one Word8 as the data. Bit of a waste!
04:04:43 <bartw> matthew-_: sockets may start flushing when they want to, but maybe your write function allwas flushes ?
04:05:14 <quicksilver> matthew-_: it's probably silly to worry about packet fragmentation. TCP stacks do what they want to do. Normally when the bandwidth starts to rise the packets fragment less
04:05:26 <matthew-_> bartw: I'm not doing any explicit flushing
04:05:39 <matthew-_> mmm. I wonder if the NoBuffering option on the handle is causing this
04:05:53 <dons> matthew-_: hmm, that's interesting. you could write your own 'put' instance for whatever format   you want though
04:06:13 <dons> matthew-_: you could concat chunks before you write them out, that might help
04:06:30 <dons> or write them in whatever format you want, since you want byte-level control
04:06:39 <matthew-_> dons: true but for "sending" I'm encoding to one big bytestring, then writing its length and itself
04:06:39 <dons> or just run GZip.encode on the result :)
04:06:45 <matthew-_> just like the encode for bytestring does
04:07:08 <matthew-_> also, wireshark is reporting that all the checksums of all the packets are wrong. This slightly alarms me!
04:07:33 <mux> this may just be because your OS uses checksum offloading
04:07:45 <mux> that is, letting the NIC compute the checksum itself
04:07:52 <mux> are your checksums all zero?
04:07:54 <matthew-_> mux: that's what wireshark suggests. I guess I'd have to look that up.
04:08:02 <matthew-_> mux: no, checksums are nonzero
04:08:05 <bartw> matthew-_: if your not explicitly flushing it must autoflush all the time, which is inefficient, allways turn it off and flush at the end of complete groups of senddata
04:08:23 <matthew-_> bartw: ok. thanks for that.
04:08:45 <bartw> sorry, too obvious ?
04:08:46 <matthew-_> mux: this is Debian Unstable, 2.6.21
04:09:03 <matthew-_> bartw: that was not meant to sound sarcastic, sorry. That was genuine thanks :)
04:10:15 <matthew-_> dons: there's nothing to concat - it's just one bytestring.
04:10:36 <dons> anyway, you can always check exactly what string is being generated, before you write it.
04:10:37 <mux> matthew-_: can't tell about Linux;  I know that in FreeBSD, if checksum offloading is getting used, you end up with checksums that are all zero
04:10:44 <matthew-_> dons: this is probably laziness - the length is precalculated so it gets sent quickly whilst the rest of the body is being calculated.
04:10:44 <dons> anythiing else is out of haskell's hands, really
04:11:03 <matthew-_> ok, thanks for all the help, I'll have a play.
04:11:47 <dozer> where is the darcs for the Data.** modules?
04:12:01 <lorne> http://darcs.haskell.org/ghc-6.6/packages/base/Data/
04:12:03 <lambdabot> Title: Index of /ghc-6.6/packages/base/Data
04:12:08 <dozer> thanks
04:12:16 <lorne> was in my recently visited :)
04:14:07 <profmakx> wee
04:14:26 <profmakx> i think i will try sigfpes Buchberger fries with my automatic groups :)
04:14:45 * dozer may be being a noob - darcs get on that URL is failing
04:15:30 <profmakx> its not a darcs repo as far as i can see
04:15:52 <lorne> I don't think you can pull from a subdir, the root of that repo is http://darcs.haskell.org/ghc-6.6/ghc/
04:15:53 <lambdabot> Title: Index of /ghc-6.6/ghc
04:16:21 <dozer> that works better - thx
04:17:27 <Igloo> The root is actually http://darcs.haskell.org/ghc-6.6/packages/base/
04:17:28 <lambdabot> Title: Index of /ghc-6.6/packages/base
04:17:57 <lorne> oh, sorry, didn't notice that
04:18:33 <Lemmih> @seen Igloo
04:18:33 <lambdabot> Igloo is in #haskell-icfp07, #haskell-soc, #haskell, #ghc and #darcs. I last heard Igloo speak 1m 6s ago.
04:18:45 <Igloo> Hello
04:20:08 <Lemmih> Igloo: You didn't compete in the ICFPc?
04:21:06 <Igloo> Lemmih: Not really. I had a brief feint at it but decided against it
04:22:30 <earthy> wise :)
04:22:59 * earthy had dreams about the assignment for 2 nights and decided to code up something else to get the contest out of my mind ;)
04:28:42 <profmakx> hm
04:28:59 <fasta> @pl \comp -> liftM foo (zork =<< comp)
04:28:59 <lambdabot> fmap foo . (zork =<<)
04:29:31 <opqdonut> gotta love that liftM->fmap rewrite :)
04:31:48 <fasta> (MonadST s f, Functor f, MonadPlus f, Show a, MonadFix f) => <- nice context
04:32:19 <fasta> I wonder how that looks when it blows up in C++ :)
04:33:02 <quicksilver> I think I would write that as (fmap foo) . (>>= zork)
04:33:07 <quicksilver> hmm
04:33:08 <quicksilver> maybe not
04:33:14 <quicksilver> maybe (zork =<<) is nicer
04:33:21 <dolio> @pl m >>= f
04:33:21 <lambdabot> f =<< m
04:33:29 <dolio>  @pl likes =<<
04:34:34 <fasta> I think <== would have been more natural
04:34:47 <fasta> (and ==> )
04:35:46 <Botje> not arrow-y enough :)
04:36:08 <matthew-_> ==> is not nearly scary looking enough as >>=
04:36:16 <quicksilver> if you used ==> for bind
04:36:20 <quicksilver> what would you use for >>
04:36:20 <quicksilver> ?
04:36:31 <matthew-_> ==
04:36:34 <earthy> => ? :)
04:36:39 <matthew-_> might cause problems down the line though...
04:37:09 * dozer wishes we had full toolchain support for fancy characters so that we'd be able to choose a squiggle for these arrow
04:37:26 <opqdonut> >>= is miles better than ===> imo
04:37:45 <opqdonut> >>= even looks like a chute that stuff is thrown into :)
04:37:55 <matthew-_> >>= should argueably be >>\
04:37:57 <opqdonut> and arrows are way too overloaded
04:38:07 <opqdonut> why >>\?
04:38:15 <Cale> and it combines the fairly natural >> with = on the correct side of the symbol
04:38:18 <dozer> =>, ==>, ===> and so on all look like they should be boolean ops doing some level of implication
04:38:18 <mux> >>_
04:38:47 <matthew-_> the lambda - showing that you need to consume the value produced?
04:38:58 <Cale> Making bind polymorphic so that it could take a monadic computation or a function would be pretty evil. It would break the (->) e monad though.
04:39:02 <matthew-_> mux: yes, I like that - >>= should be >> and >> should be >>_
04:39:09 <matthew-_> just like mapM vs mapM_
04:39:14 * mux nods
04:39:21 <mux> would be rather intuitive I guess
04:39:45 <opqdonut> matthew-_: ahh
04:39:47 <Cale> I've learned that when teaching IO, it's always best to introduce >> first
04:40:17 <opqdonut> yeah, from an IO perspective yes
04:40:18 <Cale> and then immediately follow it with >>=, after describing the problem with getting the results of computations to affect what happens
04:40:25 <opqdonut> mhmm
04:43:19 <mdmkolbe> In the course of my work I've come accross an interesting problem that I need to solve and am wondering if it has been solved before or already has a name.  It is about finding linearizations of dependancy graphs in the presence of a cache (http://www.mathbin.net/12034).  Can anyone give any pointers on where to look for info on this problem?
04:46:57 <dozer> mdmkolbe|work: any restrictions about multiple computations writing to the same location?
04:47:38 <Cale> (I don't think topological sorting won't work.)....
04:47:53 <Cale> You think topological sorting will work?
04:48:01 <mdmkolbe> dozer: writting to a location overwrites the old value there.  So if C needs the value from A and B is done in between and writes to the location that C is using from A, then that would be invalid
04:48:42 <mdmkolbe> Cale: heh, sorry, I didn't mean the double negative
04:49:14 <dozer> mdmkolbe|work: so all computations know not only which locations they are reading from, but also what computation should have written to that? sort of like all time-sharing postal boxes?
04:49:27 <cods> Is there a place to find Haskell books reviews? (Looking for one but not sure of the one to pick as a haskell-newbie)
04:49:51 <mdmkolbe> dozer: yes
04:50:30 <Cale> cods: http://www.cs.nott.ac.uk/~gmh/coutts.pdf is a very positive review of Hutton's new book
04:50:30 <mdmkolbe> dozer: (well, I'm not exactly sure what you mean by "time-sharing postal boxes", but the rest is right)
04:50:53 <cods> Cale: thanks
04:50:54 <Cale> cods: from what I've heard, it's very good if you're just starting out
04:51:47 <dozer> mdmkolbe|work: and can the dependencies form cycles, so that a computation depends (directly or indirectly) on it's own outputs?
04:51:50 <matthew-_> mmm. Is there a reason why msum shouldn't be abstracted to (Foldable f, MonadPlus m) => f (m a) -> m a ?
04:52:36 <matthew-_> @type msum
04:52:38 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
04:52:46 <matthew-_> the list seems a little arbitrary
04:52:52 <dcoutts_> Cale: I'm glad you keep recommending my review :-)
04:53:08 <Cale> :)
04:53:25 <dcoutts_> dons: sounds like I owe you and rl a beer or two when we get to Freiburg
04:54:01 <dons> rl did a good job
04:54:10 <mdmkolbe> dozer: no cycles if you consider each node to be a computation/location pair, but there may be cycles if you only consider locations
04:54:23 <dons> dcoutts_: this icfp contest is interesting: data.binary and bytestrings got hammered a lot
04:54:39 <dcoutts_> dons: really? in what way?
04:54:42 <Cale> matthew-_: msum was defined earlier, before Foldable existed.
04:54:44 <dons> several teams implemented `rebalancing' for lzy bytestrings, to fix fragmentation of chunks
04:54:52 <dcoutts_> interesting
04:54:55 <psykotic> dons: we ended up using Data.Sequence.
04:54:57 <matthew-_> Cale: yep, that's what I guessed
04:55:07 <dons> psykotic: yeah, i think you guys are the only ones who went with that?
04:55:18 <dons> the other teams seemed to go with lazy bytestrings, with rebalancing
04:55:21 <dcoutts_> dons: I've considered adding a rechunking function before
04:55:28 <fasta> psykotic: was it efficient?
04:55:32 <dons> dcoutts_: yes, i think it might be very important
04:55:33 <fasta> psykotic: I guess not
04:55:43 <dons> dcoutts_: also, desp wrote a Builder for strict bytestrings
04:55:45 <dons> that reallocs
04:55:51 <dons> rather than breaking off new chunks
04:55:56 <quicksilver> I've wondered about rechunking before, too
04:55:58 <dcoutts_> right, power of two growth
04:56:09 <dons> so we could use that, tune it up a bit .
04:56:14 <dons> and the rebalancing stuff
04:56:19 <quicksilver> it's not obvious to me what the right rechunking algortihm is, though
04:56:20 <dons> either do it , or provide a function for it
04:56:29 <Cale> matthew-_: Even though it might be appropriate here, I must say I don't usually like the view that lists are an arbitrary sequence structure.
04:56:30 <psykotic> fasta, it was okay but i think the people who used lazy bytestrings had much better perf.
04:56:35 <kosmikus> interesting that we might actually have triggered the development of new libraries :)
04:56:43 <dons> kosmikus: definitely!
04:56:43 <dcoutts_> kosmikus: heh, yes
04:56:53 <dcoutts_> when does/did the contest close?
04:56:59 <psykotic> 2 hours ago
04:57:02 * dcoutts_ should go look at the problem
04:57:02 <dons> people relied, dcoutts_, on the put methods for lazy and strict bytestrings not to copy
04:57:03 <kosmikus> it did close about 2 hours ago
04:57:19 <dons> rankings of known haskell teams are here, http://haskell.org/haskellwiki/ICFP_Programming_Contest/Teams_2007#Teams
04:57:20 <fasta> The problem was just screaming Data.Sequence to me if you just wanted an elegant solution.
04:57:21 <dcoutts_> dons: right, and they don't copy
04:57:21 <lambdabot> Title: ICFP Programming Contest/Teams 2007 - HaskellWiki, http://tinyurl.com/3dx5mv
04:57:22 <psykotic> dcoutts, like last year, the problem spec doesn't really give a feel for the real problem.
04:57:28 <dcoutts_> psykotic: right
04:57:40 <dons> dcoutts_: yeah, so the other thing was an efficient findSubstring
04:57:45 <psykotic> the initial infrastructural bits were probably 10-20x harder than last year, though
04:57:51 <psykotic> but once you had those in place, the fun was only getting started.
04:57:52 <dons> and there is none in the bytestring lib for lazy bytestrings
04:57:58 <dcoutts_> dons: right
04:58:02 <kosmikus> finding substrings efficiently wasn't *that* important in our experience
04:58:07 <dons> dcoutts_: so we have to do that, and do it ourselves i think.
04:58:24 <dcoutts_> yeah
04:58:28 <dons> kosmikus: yes, it seemed people got away with just linear search
04:58:31 <dcoutts_> fast string searching
04:58:42 <dozer> mdmkolbe|work: then I think you have a generalised linear programming problem
04:58:45 <dons> but they had to avoid the current bytestring findSubstring, which is poorly implemented
04:58:46 <fasta> kosmikus: what team were you on?
04:58:54 <dcoutts_> dons: right
04:59:03 <matthew-_> Cale: can you give an example? Or is this just a "let's abstract as far as possible and as general as possible" "is dangerous" issue?
04:59:05 <earthy> fasta: the organisers'. :)
04:59:07 <kosmikus> fasta: hmm, good question
04:59:12 <dcoutts_> fasta: kosmikus was on the organising team :-)
04:59:33 <dons> so, better findsubtring, a Builder monoid for strict bytestrings, and rebalancing for lazy bytestrings all seem worth doing
04:59:40 <Cale> matthew-_: Well, lists are our loops. They essentially reify linear recursion.
04:59:47 <fasta> kosmikus: I thought you were in Germany....
04:59:50 <dcoutts_> dons: right, lemme add that to the TODO
04:59:57 <Cale> No other sequence structure really does that properly.
05:00:02 <kosmikus> I was surprised so many people seemed to try ByteStrings over Sequence, even though the task spoke of sequences everywhere ...
05:00:03 <dons> dcoutts_: i dare say we can use some of these programs as benchmarks for improving lazy bytestrings too
05:00:11 <dcoutts_> cool
05:00:14 <kosmikus> fasta: is that forbidden?
05:00:14 <dons> kosmikus: i think they used lazy bytestrings mostly?
05:00:16 <dcoutts_> benchmarks are good
05:00:23 <fasta> kosmikus: no
05:00:23 <psykotic> kosmikus, it even used the notation from the Sequence paper, right? :)
05:00:26 <psykotic> koffein, <| etc
05:00:27 <xerox> hiya dcoutts_ :)
05:00:33 <fasta> kosmikus: lots of people live in Germany.
05:00:34 <kosmikus> psykotic: that was an accident
05:00:36 <fasta> kosmikus: ;)
05:00:42 <psykotic> kosmikus, ah. we all read something into it :)
05:00:42 <dcoutts_> hia xerox :-)
05:00:42 <mm_freak> does GHC convert (32*i) into a bit-shift for i :: Integral t => t ?
05:00:49 <kosmikus> psykotic: no problem.
05:00:59 <dozer> mdmkolbe|work: make the list of all permutations of your computations, discard all where a location is read before it is written, then discard all where the 'wrong' computation sets the value that is read, and what is left should let you build your output
05:01:02 <kosmikus> psykotic: but it seems it hasn't helped people enough ...
05:01:02 <dons> mm_freak: maybe for Int, check the asm output
05:01:14 <quicksilver> mm_freak: with via-c, it should, for unboxed numbers
05:01:14 <mm_freak> hmm k
05:01:16 <dons> mm_freak: generally you should do it yourself though , or provide a rewrite rule for it
05:01:22 <psykotic> kosmikus, honestly, i think the scoring curve, relating effort to score, was too flat.
05:01:24 <quicksilver> mm_freak: because gcc will do that, if it thinks it's quicker
05:01:33 <mm_freak> quicksilver: i'm not using via-C
05:01:36 <dons> psykotic: last year was similar though, a long tail
05:01:40 <kosmikus> psykotic: well, you had the risk, of course, which was much more "linear"
05:01:42 <xerox> dcoutts_: check out this year's task? (:
05:01:42 <psykotic> kosmikus, there was an initial boost when you got rotatetosun, but then it seemed that you didn't get any score until almost the end, aside from chipping away a base or two.
05:01:45 <dons> maybe it was a bit longer this time.
05:01:45 <mdmkolbe> dozer: you mean this kind of linear programming? http://en.wikipedia.org/wiki/Linear_programming  I don't understand how that applies
05:01:46 <xerox> *checked
05:01:46 <lambdabot> Title: Linear programming - Wikipedia, the free encyclopedia
05:01:47 <mm_freak> not anymore, since -fasm appears to be faster
05:01:51 <quicksilver> mm_freak: are you not using -O2?
05:01:54 <psykotic> dons: itw as quite different...
05:01:56 <kosmikus> psykotic: the survival function was supposed to be somewhat realistic
05:02:00 <mm_freak> quicksilver: -O2 -fasm
05:02:01 <Cale> matthew-_: and even those which have O(1) head and tail which are sufficiently lazy are either going to be used suboptimally when used like lists, and will probably cost a little more while they're at it.
05:02:04 <psykotic> dons: with last year you had a bunch of problems you could tackle, and score on, independently, more or less.
05:02:06 <dcoutts_> xerox: not yet
05:02:09 <quicksilver> mm_freak: I thought -O2 forced via-C
05:02:11 <xerox> dcoutts_: your last-year team name was inside the DNA (:
05:02:22 <mm_freak> quicksilver: it doesn't…  and the code is even faster with -fasm
05:02:35 <mm_freak> quicksilver: at least up to now i haven't found any counterexample
05:02:38 <psykotic> kosmikus, realistic? :)
05:02:52 <Cale> Er, I had an either there without an or...
05:03:01 <matthew-_> Cale: yep, ok. So pushing lists on people is good for them ;)
05:03:09 <Cale> To some extent
05:03:13 <matthew-_> Interesting.
05:03:15 <kosmikus> psykotic: well, having daylight score 10% even though all that's changed is the shade of the whole picture would not have been really "realistic"
05:03:15 <Cale> it's just that lists are the common case
05:03:18 <dons> dcoutts_: so one thing also would be to use strict-in-element lists ofr lazy bytestrings, as we discussed
05:03:29 <psykotic> kosmikus, it's not so much about the amount, but giving it out in small bites.
05:03:32 <Cale> Just like loops are the common case in imperative programming, over general recursion
05:03:47 <psykotic> kosmikus, compare to last year, for example. there were (1) a lot of problem sthat could be solved/scored on independently and (2) within each problem there were a lot of score milestones.
05:04:05 <dcoutts_> kosmikus: someone should probably implement a finger tree of chunks, ie the Data.Sequence rather than list version of a lazy bytestring
05:04:06 <dons> psykotic: so it seemed that the break throughs happened mostly today, where the top 30 teams started scoring, while nothing much changed yesterday?
05:04:19 <psykotic> dons: i think so. the exception might be jabber-ru guy, aleksey.
05:04:22 <dons> dcoutts_: hmm. yes.
05:04:28 <kosmikus> psykotic: oh, at least I personally certainly hoped that (a) more teams would get daylight ealier, and (b) that the step from daylight to anything better would be really easy
05:04:30 <Cale> That said, monads are pretty important things too, and many of the operations which work in a general monad, not just lists, really ought to be generalised
05:04:33 <matthew-_> oh yes, am I right in thinking that ghc will do nice stack collapsing for all tail calls, not just recursion?
05:04:35 <dozer> mdmkolbe|work: no ... try: http://en.wikipedia.org/wiki/Linear_logic
05:04:36 <lambdabot> Title: Linear logic - Wikipedia, the free encyclopedia
05:04:37 <psykotic> dons: he didn't use the built in dna _at all_. he just basically recreated the target image by using the low-level built in RNA instructions.
05:04:38 <mux> CIRCS.REV=35@2783|0d85b39fefcee95b6268ce4cd8d5014
05:04:40 <dcoutts_> dons: yes, I'm planning to use strict list element lazy bs
05:04:42 * mux giggles
05:04:49 <mux> 2d was good
05:04:54 <dons> mux hehe
05:05:13 <dons> matthew-_: yes, usually you'll just get gotos
05:05:19 <Cale> matthew-_: all tail calls. Also, some list operations are reduced away so the list never actually gets created
05:05:20 <quicksilver> matthew-_: yes. Also, beware; the stack isn't quite what you think it is, in a G-machine
05:05:26 <Cale> (though it could do much better)
05:05:28 <kosmikus> psykotic: actually, I still don't understand what was so difficult about (b), but I hope that looking at a few of the submissions will yield some clues
05:05:37 <matthew-_> @quote stereo
05:05:37 <lambdabot> No quotes match. It can only be attributed to human error.
05:05:40 <matthew-_> wah!
05:05:55 <quicksilver> we've lost our quotes db?
05:05:57 <Cale> Oh yeah, dons / dcoutts... is list stream fusion in the upcoming GHC?
05:06:00 <quicksilver> @quote cale
05:06:00 <lambdabot> Daveman says: Cale, what if I don't want to obey the laws?  Do they throw me in jail with the other bad monads?
05:06:10 <Cale> hahaha
05:06:12 <dcoutts_> xerox: really? heh
05:06:14 <dons> Cale, hmm, maybe. depends on list comprehensions
05:06:21 <mux> the Haskell community is the only community that is *too* helpful ;-)
05:06:25 <matthew-_> the stero quote should be hard coded into λb
05:06:31 <dons> certainly for bytestrings, we'll be putting the kick-butt latest fusion stuff into bytestring 1.0
05:06:36 <Cale> finally I will not have to put up with people getting my attention needlessly by using the stereo quote!
05:06:39 <dcoutts_> Cale: not in ghc 6.8, that's too soon
05:06:50 <Cale> dcoutts: ah
05:06:51 <dons> yeah, not 6.8
05:06:59 <dons> which is a pity. all those foldl/length users
05:07:03 <dons> but the library will be available
05:07:11 <dons> which may be of use to people who just use its combinators
05:07:12 <dcoutts_> though as dons says, bytestring 1.0 is targeting ghc 6.8
05:07:39 <jcd__> our team used some haskell, if whoever is maintaining that wiki page wants to add us
05:07:46 <dons> jcd__: yes, team name?
05:07:52 <jcd__> Basically Awesome
05:07:59 <Nopik> hi there
05:08:02 <dons> jcd__: cool!
05:08:03 <mux> one day I will need to finish that adventure IA
05:08:04 <Cale> It would be nice if GHC also implemented some more general fusion.
05:08:04 <dons> well done :)
05:08:09 <jcd__> thanks :)
05:08:09 <Cale> Nopik: hi
05:08:12 <psykotic> kosmikus, anyway, good job :)
05:08:22 <psykotic> kosmikus, must have been a crapload of work
05:08:26 * mux notes he solved adventure up to the USB thing by hand, heh
05:08:53 <kosmikus> psykotic: thanks. well, we had a lot of people. I'm sorry that it turned out to be such a difficult contest. I hope it was fun nevertheless.
05:09:06 <dons> jcd__: that's good news. you're our hope then for a haskell win for the 4th year :)
05:09:06 <psykotic> kosmikus, it was.
05:09:12 <jcd__> heh
05:09:22 <jcd__> we're not going to claim haskell as our main language probably, but we'll see
05:09:25 <jcd__> anyway I don't think we won
05:09:29 <Cale> kosmikus: yeah, it was quite fun. I hope to keep working on it for some time :)
05:09:43 <Cale> kosmikus: It would have made a much better week-long contest.
05:09:45 <jcd__> we prefer to claim non-functional languages just to be contrary ;)
05:09:45 <dons> jcd__: how do you think the google guys went? any thoughts?
05:09:46 <psykotic> kosmikus, we had some bad initial luck, which set us back. we only placed around ~50, i think we would have hit top 20 at least if we hadn't miscalculated.
05:09:50 <mux> 8.4% of survival chance isn't very high :-)
05:09:51 <matthew-_> Cale: people would have died
05:09:52 <dons> jcd__: yes of course :)
05:09:54 <psykotic> cale: yeah :)
05:10:00 <kosmikus> it'll be nice if people continue to work on it. some of the people here seem slightly disappointed that their "stuff" hasn't been found
05:10:09 <jcd__> dons: well we were one google team.  I haven't talked to the other one yet
05:10:13 <Lemmih> mux: endo is doomed (:
05:10:18 <mux> heh
05:10:18 <Nopik> i am trying to compare two images (using gd library), i have create function which takes 2 images and tries to foldl on all their pixels.. the foldl first argument function is 'check pixel' function which does call getPixel on both images and try to compare.. but I get IO Color from getPixel, instead of Color, so I can not call == on it
05:10:24 <dons> kosmikus: yes, a few have wished for "just" 1 more day :)
05:10:27 <mdmkolbe> Cale: what was the problem given this year?
05:10:37 <mux> endo will end up with dysfonctional lungs, 3 arms, etc
05:10:38 <jcd__> dons: but one of them works in the next office so I'm sure I'll hear all about it tomorrow :)
05:10:41 <kosmikus> yes, I would also have liked for the contest to go on
05:10:42 <Nopik> so, everything 'works' instead i got the error, that there is no instance of Eq (IO Color)
05:10:46 <kosmikus> but it's just unfair to extend it
05:10:47 <wolverian> what should I use to parse date strings of the type yyyymmddss...?
05:10:52 <matthew-_> Nopik: don't you want zipWithM (==) ?
05:10:53 <dons> jcd__: ah yes, of course. i forget :)
05:10:58 <AStorm> @hoogle case
05:10:59 <lambdabot> Prelude.case :: keyword
05:10:59 <lambdabot> Language.Haskell.TH.caseE :: ExpQ -> [MatchQ] -> ExpQ
05:10:59 <lambdabot> Test.HUnit.Base.cases :: Counts -> Int
05:11:18 <AStorm> Hmm, how does one switch character case?
05:11:21 <matthew-_> Nopik: actually no, sorry! I should have checked that first!
05:11:31 <dons> jcd__: did you take advantage of any interesting computing resources?
05:11:51 <jcd__> heh like giant google clusters?  :)
05:11:52 <dons> i'm intrigued if we're at the point yet where people start doing multicore or cluster entries, by default
05:11:55 <jcd__> no we didn't
05:12:00 <wolverian> Data.Time.Format.parseTime I assume
05:12:01 <dons> jcd__: oh, just maybe parallel arrays or something
05:12:09 <dons> i've used clusters for testing in previous years, for example
05:12:10 <jcd__> nah just regular machines
05:12:20 <Cale> mdmkolbe: Basically a string rewriting system whose output is treated as instructions for drawing an image. You write prefixes for a massive blob which implements all kinds of cool stuff.
05:12:22 <jcd__> the first ICFP was for multiprocessor machines actually
05:12:30 <jcd__> one of my team members won that first contest with a parallel language
05:12:38 <dons> ah yes, that's right.
05:12:45 <Nopik> teoretically i could use 'do' expression and produce IO Bool, but then i do not know how to match that with foldl
05:12:58 <Cale> mdmkolbe: The blob is kind of like a big object with an execution environment, lots of methods, and then a stack.
05:13:02 <mdmkolbe> Cale: cool
05:13:09 <dons> dcoutts_: a parallel substring search for the 16 core box , for bytestrings, might have been useful to some people :)
05:13:14 <roconnor> what is the haskell-icfp channel?
05:13:24 <amiddelk> #haskell-icfp07
05:13:35 <dons> dcoutts_: and i imagine ndp arrays might have been useful. we should talk to rl  :)
05:13:45 <Cale> Nopik: just going up to read your question, I missed it :)
05:13:54 <quicksilver> Nopik: you want to use a do, or simply liftM2 (==)
05:13:59 <roconnor> Okay, my big beef is, why does the MArray interface suck?
05:14:04 <quicksilver> Nopik: but yes, it will be an IO Bool
05:14:06 <roconnor> there is no in place map.
05:14:07 <quicksilver> Nopik: that's OK, though
05:14:18 <roconnor> there is no modify array index function
05:14:20 <Cale> Nopik: do you understand how IO works in Haskell yet?
05:14:23 <roconnor> what gives?
05:14:55 <Cale> Nopik: an (IO Bool) is nothing like a boolean, it's more like a program which runs to produce a boolean.
05:15:45 <Nopik> Cale: yes, i think i understand it (somehow).. and i think i know how to write function which match my needs, but produce IO Bool instead of Bool
05:15:49 <Cale> Nopik: The way things in Haskell are set up, the only things which are allowed to run these IO programs are other IO programs (and eventually main is run by the runtime system)
05:15:51 <dozer> is there a 'how to build base' readme I'm missing?
05:15:58 <Nopik> .. which may turn out to be necessary, actually
05:16:40 <Cale> So you want something like: do { c1 <- getPixel ... ; c2 <- getPixel ...; return (c1 == c2) }
05:16:49 <matthew-_> roconnor: that could be dangerous - couldn't you have an IOUArray value which you share between threads and then the in place maps would collide?
05:16:58 <Nopik> Cale: yes, exactly
05:17:06 <Cale> or, if you know the monad libraries well, you write that as  liftM2 (==) (getPixel ...) (getPixel ...)
05:17:28 <opqdonut> @. pl undo do { c1 <- getPixel; c2 <- getPixel; return (c1 == c2) }
05:17:28 <lambdabot> (`fmap` getPixel) . (==) =<< getPixel
05:17:32 <opqdonut> :D
05:17:43 <Cale> Nopik: Most of the control structures, loops and so on are in Control.Monad
05:17:49 <matthew-_> and then you just want foldM (&&) True (liftM2 (==) (getPixel ...) (getPixel ...))
05:17:58 <dcoutts_> dons: mmm, yes I suppose substring search does parallelise very well
05:18:00 <matthew-_> err, with some list!
05:18:11 <wolverian> ugh. my ubuntu doesn't have Data.Time.Format.
05:18:11 <Nopik> Cale: yeah, i am newbie here, so i do not know Control.Monad well yet
05:18:13 <zeeeee> jcd__: hi :)
05:18:15 <quicksilver> matthew-_: but that kind of collision is inherent in sharing an IOUArray between threads
05:18:17 <dons> dcoutts_: there are known algos for the gpu, for example
05:18:18 * Nopik must go away for lunch
05:18:28 <Nopik> i'll be back soon
05:18:31 <quicksilver> matthew-_: with or without an in-place map
05:18:38 <dons> dcoutts_: oh, sean got zipwith (+) running on the nvidia last week :)
05:18:45 <jcd__> zeeeee: yo
05:18:48 <dons> dcoutts_: we're not far away from proper haskell on the gpu now.
05:18:53 <matthew-_> quicksilver: yeah I guess. Ok, so IOUArray should be wrapped in an MVar!
05:18:59 <dcoutts_> dons: cool
05:19:18 <dcoutts_> dons: this is by a combinator lib to generate gpu code right? not compiling Haskell to gpu
05:19:22 <dons> yeah
05:19:34 <quicksilver> matthew-_: if you use IORefs and threads, you're expected to know what you're doing
05:19:45 <quicksilver> matthew-_: the problems are no worse than other threaded languages. Better, in some ways :)
05:19:48 <dons> the function arguments to map/fold etc are actually in an EDSL that turns into gpu code
05:19:58 <dons> and gets compiled into a shader by nvidia's compiler
05:20:17 <bartw> woot 100kiter/s
05:20:19 <dons> ld then links that with the cpu code, and you get gpuMap, a parallel, gpu'd combinator
05:20:28 <dozer> dons: that's realy nice
05:20:45 <dons> yeh, these gpus make nice combinator machines :)
05:20:50 <dons> hardware support for map/fold/ zip :)
05:21:09 <matthew-_> quicksilver: yeah, it's a shame that http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-IO.html doesn't have any mention whatsoever of such issues
05:21:09 <dons> bartw: oh, in haskell?
05:21:10 <lambdabot> http://tinyurl.com/3dydza
05:21:19 <bartw> dons: c#
05:21:29 <dons> oh ;)
05:21:34 <bartw> but only on the beautifull numbers page
05:21:51 <mux> dons: that's really fearsome :D
05:21:56 <bartw> eh, it only took 30 hours of profiling and recoding the dna structre, leaving no time for the contest ;p
05:22:04 <dons> ah well
05:23:01 <dons> so there's a lot of secret surprises in the dna people haven't found yet, it seems
05:24:19 <fasta> Can I define my own Data.Maybe without naming it Data.MyMaybe?
05:24:39 <dons> sure
05:24:40 <kosmikus> dons: I don't know exactly. but I think it's safe to assume that at least not many people have found them ...
05:24:54 <fasta> dons: but how does GHC knows it should take my Data.Maybe?
05:25:01 <fasta> dons: and not the one in base?
05:25:09 <dons> bartw mentions hidden mp3s .. sounds intriguing :)
05:25:11 <Cale> dons: I found a picture of the devs using corrupted DNA -- I'd hacked off n `mod` 80 of the characters at the end and changed the wrong I to a C in my text editor, and ended up getting RNA that did all kinds of wonky stuff, but in the process revealed some clues we wouldn't otherwise have had :)
05:25:22 <dons> fasta, scoping.
05:25:34 <chris2> where can i find epigram hackers? i'm curious about the judder paper/example
05:25:37 <dons> fasta, see for example, the Maybe type in the 'strict' package on hackage
05:25:52 <dons> fasta,oh, you can't define a module 'Data.Maybe' though, without conflicting with base
05:26:01 <dozer> dons: what kinds of things are you intending to run on nvidia cards?
05:26:02 <dons> you wouldn't be able to use the base package simultaneously
05:26:05 <swiert> chris2: I wouldn't call myself an "epigram hacker", but I know some stuff.
05:26:22 <chris2> are you familiar with that paper?
05:26:46 <swiert> What's the "judder" paper?
05:26:58 <chris2> in darcs, epigram/doc/Judder/Judder.lhs
05:27:11 <AStorm> Hmm, is there any good titlecase string function in Haskell, or should I write one?
05:27:23 <Cale> AStorm: write one.
05:27:30 <Cale> AStorm: it shouldn't be hard
05:27:39 <bartw> dons: fidn the big ass Nat() regions, easy to find, just a sea of I,C pairs terminated by P
05:27:43 <AStorm> Yep, shouldn't
05:27:49 <dons> dozer: array hacking.
05:27:54 <fasta> dons: so, the strict package is basically base - epsilon1 + epsilon2?
05:28:11 <mdmkolbe> AStorm: some composition of 'words', 'unwords', 'map' and 'toUpper' should do the trick
05:28:14 <dozer> dons: we could use something like that for biological sequence alignments
05:28:25 <swiert> chris2: Hang on. Let me have a look.
05:28:31 <chris2> okay
05:28:41 <Cale> > unwords . map (\(x:xs) -> toUpper x:xs) . words $ "i can has title case?"
05:28:46 <lambdabot>  "I Can Has Title Case?"
05:28:55 <dons> dozer: quite likely. people do buy gpu *servers* these days for that kind of stuff
05:28:58 <mdmkolbe> :-)
05:29:28 <AStorm> Cale, I'll have to lowercase other letters too :P
05:29:40 <Cale> well, yeah, if you want to be *correct* about it :)
05:30:01 <Cale> > unwords . map (\(x:xs) -> toUpper x : map toLower xs) . words $ "i can HAS title CASE?"
05:30:03 <lambdabot>  "I Can Has Title Case?"
05:30:03 <dozer> dons: yeah, but they cost $$$ because of the proprietary retargeting of the algorithms
05:30:08 <roconnor> matthew-_: I dont' see how that is different from normal threading issues.
05:30:10 <dozer> base$ make
05:30:10 <dozer> Makefile:2: ../mk/boilerplate.mk: No such file or directory
05:30:10 <dozer> Makefile:140: ../mk/target.mk: No such file or directory
05:30:10 <dozer> make: *** No rule to make target `../mk/target.mk'. Stop.
05:30:16 <fasta> dons: never mind
05:30:18 <roconnor> Just note that map isn't atomic
05:30:44 <opqdonut> next up: the GPU monad
05:30:45 <Igloo> dozer: What are you trying to do?
05:30:49 <roconnor> matthew-_: Ah, sorry, I'm a bit late in the conversation
05:31:01 <mdmkolbe> Cale: now add all the exceptions (e.g. "a" and "the" and "of" are all lower (except when the first or last word)
05:31:11 <dozer> Igloo: rebuild the base library - it has a makefile that won't run for me, and a cabal file but no Setup.lhs to launch it
05:31:14 <mdmkolbe> Cale: ;-P
05:31:23 <Cale> mdmkolbe: And if you want to get really fancy, detect roman numerals.
05:31:35 <mdmkolbe> Cale: lol
05:31:40 <matthew-_> roconnor: np - I think quicksilver took your place! ;)
05:31:46 <swiert> chris2: Do you have any specific questions?
05:31:47 <Cale> (I've written this before, and needed that feature :)
05:31:49 <mdmkolbe> Cale: I think that problem is AI complete
05:32:22 <swiert> chris2: Btw, this is just a very sketchy draft Conor wrote - it's far from complete, and probably not entirely comprehensible if you are not Conor.
05:32:23 <chris2> swiert: i get GHOUL, but i wonder how one practically types it
05:32:31 <chris2> yeah, i guess
05:32:35 <Igloo> dozer: Why are you trying to do that, though?
05:32:40 <MyCatVerbs> mdmkolbe: just looks for strings of uppercase I's, V's, C's... then check to see whether the captured regions are valid roman numerals?
05:32:56 <dozer> Igloo: trying to add a load of TypeableN instances to Data.Typeable
05:32:59 <MyCatVerbs> (as in, don't have more than three of any one letter in a row, etc)
05:32:59 <Cale> mdmkolbe: I wrote a set of scripts at one point to reformat music filenames.
05:33:04 <mdmkolbe> Cale: e.g. "The lift of Liv; part LIV"
05:33:13 <b_jonas> lol
05:33:13 <mdmkolbe> s/lift/life/
05:33:24 <b_jonas> that's difficult
05:33:59 <Cale> mdmkolbe: Turns out that Liv is an elevator repairman.
05:34:02 <xerox> MyCatVerbs: http://haskell.org/haskellwiki/Roman_numerals I write the stuff in the type system, it only compiles valid roman numberals ;-)
05:34:03 <lambdabot> Title: Roman numerals - HaskellWiki
05:34:04 <b_jonas> though I guess not as much as the code that reverts an uppercase text to whatever case it should be.
05:34:26 <swiert> chris2: The U in Ghoul stands for untyped.
05:34:41 <MyCatVerbs> xerox: ...nice!
05:34:43 <swiert> chris2: You're not meant to type it. Think of it as a core language.
05:34:49 <chris2> okay
05:34:55 <MyCatVerbs> mdmkolbe: that's not a problem, false positives are fine.
05:35:02 <Igloo> dozer: OK, it might be easier to do it by building GHC. If you really want to go this route then there is a Setup.hs which I think might work
05:35:25 <Igloo> dozer: Oh, wait, you're on the 6.6 branch?
05:35:36 <dozer> Igloo: yeah I am
05:35:43 <Igloo> dozer: Building the HEAD is almost certainly the way to do this
05:35:50 <Igloo> And altering its base
05:36:43 <dozer> Igloo: ok - the whole ghc head? that will take like 2 hours or something :(
05:37:15 <Igloo> dozer: Hmm, you'd only need a stage 1 build. You could also stop it building all the other libraries
05:37:43 <Igloo> Assuming you're only trying to test the patch, and don't want to use it immediately
05:37:44 <dozer> Igloo: let me grab it from darcs and I'll get back to you if I can't figure out what to do
05:38:08 <dozer> Igloo: I want to see if some other code I have will compile against it
05:40:06 <AStorm> hmm, what would be reverse function to concat $ intersperse a [a]
05:41:35 <mdmkolbe> > concat $ intersperse 1 [1]
05:41:36 <lambdabot>   add an instance declaration for (Num [a])
05:41:36 <lambdabot>     In the expression: 1
05:41:48 <mdmkolbe> > concat $ intersperse 'a' ['a']
05:41:49 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
05:41:58 <mdmkolbe> @type interspese
05:42:00 <lambdabot> Not in scope: `interspese'
05:42:05 <opqdonut> > concat $ intersperse [1] [[1]]
05:42:06 <lambdabot>  [1]
05:42:07 <mdmkolbe> @type intersperse
05:42:09 <lambdabot> forall a. a -> [a] -> [a]
05:42:10 <opqdonut> thar ya go
05:42:22 <opqdonut> > concat . intersperse [1] $ repeat [[1]]
05:42:23 <lambdabot>   add an instance declaration for (Num [t])
05:42:23 <lambdabot>     In the expression: 1
05:42:27 <swiert> chris2: If you're interested in Epigram, there are quite a lot of much more readable papers out there.
05:42:31 <opqdonut> > concat . intersperse [1] $ repeat [1]
05:42:32 <opqdonut> bah
05:42:32 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:42:34 <AStorm> opqdonut, it's usually used with strings
05:42:40 <opqdonut> yes i know
05:42:48 <chris2> yeah, i read some of them already
05:42:55 <AStorm> I'm asking for some split function, more general than words
05:43:38 <chris2> i just pondered the idea of considering data as unevaluated functions myself and was happy when i saw the idea already. probably not very practical, tho
05:44:19 <AStorm> > intersect "blah;blah;blah" ";"
05:44:20 <lambdabot>  ";;"
05:44:29 <AStorm> inverse to that
05:44:40 <AStorm> and also returning [[a]]
05:44:53 <opqdonut> > "blah;blah;blah" \\ ";"
05:44:54 <lambdabot>  "blahblah;blah"
05:45:03 <matthew-_> @src words
05:45:03 <lambdabot> words s = case dropWhile isSpace s of
05:45:03 <lambdabot>     "" -> []
05:45:03 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
05:45:23 <mdmkolbe> AStorm: combine 'foldl' or 'foldr' with 'break' or 'split'
05:45:26 <matthew-_> mmm. not sure there is..- maybe using groupBy ?
05:45:28 <AStorm> I know itcan be done this way :P
05:45:32 <opqdonut> i'd recommend Text.Regex.splitRegex
05:45:37 <AStorm> matthew-_, not really
05:45:42 <AStorm> hmm
05:45:46 <mdmkolbe> @src groupBy
05:45:46 <lambdabot> groupBy _  []       =  []
05:45:46 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
05:45:46 <lambdabot>     where (ys,zs) = span (eq x) xs
05:46:00 <AStorm> matthew-_, more like with break or partition
05:46:15 <matthew-_> ok
05:46:28 <mdmkolbe> > groupBy (\x y -> y == ';') "abc;def;;g"
05:46:29 <lambdabot>  ["a","b","c;","d","e","f;;","g"]
05:46:36 <mdmkolbe> > groupBy (\x y -> y /= ';') "abc;def;;g"
05:46:37 <lambdabot>  ["abc",";def",";",";g"]
05:46:42 <swiert> chris2: Fair enough.
05:47:08 <mdmkolbe> AStorm: groupBy doesn't pre-sort, so something like that could work
05:47:21 <mdmkolbe> > groupBy (\x y -> x /= ';') "abc;def;;g"
05:47:22 <lambdabot>  ["abc;def;;g"]
05:47:22 <swiert> chris2: I wouldn't beat my head against the wall trying to understand this (in its current state).
05:47:32 <mdmkolbe> > groupBy (\x y -> x == ';') "abc;def;;g"
05:47:32 <AStorm> mdmkolbe, :>
05:47:33 <lambdabot>  ["a","b","c",";def;;g"]
05:47:56 <matthew-_> the y /= seems best
05:48:32 <opqdonut> esp. if you remove the remaining initial ';' and empty strings
05:48:34 <mdmkolbe> > groupBy (\x y -> y /= ';') "abc;def;;;;;g"
05:48:35 <lambdabot>  ["abc",";def",";",";",";",";",";g"]
05:48:44 <paolino> anyone can explain what is the meaning of "evenly divisible" in this context http://projecteuler.net/index.php?section=problems&id=5 please
05:48:45 <lambdabot> Title: Project Euler
05:48:49 * b_jonas smiles thinking of other languages that have bulitins helping this
05:48:56 <AStorm> mdmkolbe, and then I have to filter out ";"
05:49:01 <matthew-_> > filter (/= ';') . groupBy (\x y -> y /= ';') $ "abc;def;;;;;g"
05:49:01 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
05:49:05 <opqdonut> map (\\';') $ groupBy (\x y -> y /= ';') "abc;def;;;;;g"
05:49:07 <opqdonut> > map (\\';') $ groupBy (\x y -> y /= ';') "abc;def;;;;;g"
05:49:08 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
05:49:14 <opqdonut> > map (\\";") $ groupBy (\x y -> y /= ';') "abc;def;;;;;g"
05:49:17 <lambdabot>  ["abc","def","","","","","g"]
05:49:26 <opqdonut> > filter (not null) . map (\\";") $ groupBy (\x y -> y /= ';') "abc;def;;;;;g"
05:49:27 <lambdabot>  Couldn't match expected type `Bool'
05:49:30 <mdmkolbe> > groupBy (\x y -> (x == ';') == (y == ';')) "abc;def;;gh;;;;;j"
05:49:31 <AStorm> > filter (/= ";") . groupBy (\x y -> y /= ';') $ "abc;def;;;g"
05:49:31 <lambdabot>  ["abc",";","def",";;","gh",";;;;;","j"]
05:49:32 <lambdabot>  ["abc",";def",";g"]
05:49:43 <AStorm> > filter (/= ";") . groupBy (\x y -> y /= ';') $ "abc;def;;;g"
05:49:44 <lambdabot>  ["abc",";def",";g"]
05:49:47 <AStorm> hmm, close
05:49:52 <opqdonut> > filter (/="") . map (\\";") $ groupBy (\x y -> y /= ';') "abc;def;;;;;g"
05:49:53 <b_jonas> why not just drop the last element instead of \\";"
05:49:54 <lambdabot>  ["abc","def","g"]
05:49:58 <mdmkolbe> AStorm: try this
05:49:59 <mdmkolbe> > groupBy (\x y -> (x == ';') == (y == ';')) "abc;def;;gh;;;;;j"
05:50:00 <lambdabot>  ["abc",";","def",";;","gh",";;;;;","j"]
05:50:13 <opqdonut> mdmkolbe: nice
05:50:15 <matthew-_> super!
05:50:25 <AStorm> > groupBy (\x y -> y /= ';') $ "abc;def;;;g"
05:50:27 <lambdabot>  ["abc",";def",";",";",";g"]
05:50:30 <AStorm> hmm
05:50:52 <AStorm> > groupBy (\x y -> and [x == ';', y == ';']) $ "abc;def;;;g"
05:50:53 <lambdabot>  ["a","b","c",";","d","e","f",";;;","g"]
05:50:58 <AStorm> hmm
05:51:09 <AStorm> > groupBy (\x y -> x == y == ';') $ "abc;def;;;g"
05:51:10 <lambdabot>      precedence parsing error
05:51:10 <lambdabot>         cannot mix `(==)' [infix 4] and `(==)' ...
05:51:15 <matthew-_> > filter ((/= ';') . head) . groupBy (\x y -> (x == ';') == (y == ';')) $ "abc;def;;gh;;;;;j"
05:51:17 <lambdabot>  ["abc","def","gh","j"]
05:51:19 <AStorm> boo hoo ;P
05:51:30 <AStorm> > groupBy (\x y -> x == (y == ';')) $ "abc;def;;;g"
05:51:31 <lambdabot>  Couldn't match expected type `Char' against inferred type `Bool'
05:51:54 <xerox> > filter ((/= ';') . head) . groupBy (\x y -> (x == ';') && (y == ';')) $ "abc;def;;gh;;;;;j"
05:51:56 <AStorm> :t both
05:51:56 <lambdabot>  ["a","b","c","d","e","f","g","h","j"]
05:51:57 <mdmkolbe> In general "splitBetween f = groupBy (\x y -> not (f x y))"
05:51:57 <lambdabot> Not in scope: `both'
05:52:02 <AStorm> :t all
05:52:04 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
05:52:14 <mdmkolbe> @type (&&)
05:52:16 <lambdabot> Bool -> Bool -> Bool
05:52:21 <AStorm> > groupBy (\x y -> all [x == ';', y == ';']) $ "abc;def;;;g"
05:52:22 <lambdabot>  Couldn't match expected type `a -> Bool'
05:52:23 <xerox> just wondering
05:53:03 <AStorm> > groupBy (\x y -> all (==';') [x,y]) $ "abc;def;;;g"
05:53:05 <lambdabot>  ["a","b","c",";","d","e","f",";;;","g"]
05:53:15 <AStorm> hmm
05:53:33 <mdmkolbe> > groupBy (\x y -> x == ';' && y == ';') $ "abc;def;;;g"
05:53:34 <lambdabot>  ["a","b","c",";","d","e","f",";;;","g"]
05:58:07 <AStorm> > deleteFirstsBy (=) (groupBy (\x y -> (x==';') == (y==';')) (heads $ cycle ";")
05:58:08 <lambdabot>  Parse error
05:58:28 <AStorm> > deleteFirstsBy (=) (groupBy (\x y -> (x==';') == (y==';')) "Test;test;test;;;test" (heads $ cycle ";")
05:58:29 <lambdabot>  Parse error
05:58:31 <AStorm> hmm
05:58:48 <AStorm> > deleteFirstsBy (==) (groupBy (\x y -> (x==';') == (y==';')) "Test;test;test;;;test" (heads $ cycle ";")
05:58:49 <lambdabot>  Parse error
05:59:01 <AStorm> > deleteFirstsBy (==) (groupBy (\x y -> (x==';') == (y==';'))) "Test;test;test;;;test" (heads $ cycle ";")
05:59:02 <lambdabot>   Not in scope: `heads'
05:59:11 <AStorm> > deleteFirstsBy (==) (groupBy (\x y -> (x==';') == (y==';'))) "Test;test;test;;;test" (inits $ cycle ";")
05:59:12 <lambdabot>  Couldn't match expected type `[a]'
05:59:18 <AStorm> Ok, back to ghci :>
05:59:23 <opqdonut> thanks
06:01:07 <vincenz> roconnor: what approach did you use
06:01:18 <AStorm> hmm, nonterminating :>
06:01:31 <roconnor> vincenz: sorry, for what?
06:01:35 <AStorm> can't use an infinite delete list :/
06:01:37 <vincenz> roconnor: competition?
06:01:47 <roconnor> vincenz: Haskell!
06:02:01 <roconnor> oh you mean what did I do to the dna?
06:02:49 <vincenz> nod
06:03:05 <roconnor> Did you ever read the encyrpted page on how to activage genes?
06:03:10 <vincenz> Nope
06:03:13 <vincenz> We didn't find the key
06:03:14 <xerox> :O
06:03:27 <xerox> that's how you managed to hide the ufo?
06:03:40 <xerox> we nopped him out.
06:03:50 <roconnor> vincenz: that page was helpful
06:03:56 <vincenz> roconnor: where did oyu find the key
06:04:02 <vincenz> roconnor: and how did you decrypt?
06:04:07 <vincenz> roconnor: just decrypt the entire dna ?
06:04:22 <roconnor> vincenz: it was encrypted with an easy to decrypt hand cifer
06:04:46 <roconnor> at about 5am I figured out how the ufo function worked
06:04:57 <roconnor> the ufo-with-smoke function specifically
06:05:14 <roconnor> then I devised a no-op to stop over the calls to ufo and smoke
06:05:24 <roconnor> then i did the same with endo
06:05:38 <vincenz> roconnor: ou were alone?
06:05:54 <roconnor> vincenz: other than chatting on haskell-icfp07, I was alone
06:06:04 <roconnor> my friends left for France and Poland
06:06:05 <vincenz> did you use haskell for dna->rna?
06:06:10 <paolino> > 2*2*2*2*3*3*5*7*11*13*17*19
06:06:12 <lambdabot>  232792560
06:06:15 <roconnor> vincenz: yes, it was very slow
06:06:19 <roconnor> 15 min per run
06:06:22 <vincenz> wince
06:06:39 <roconnor> well, it gave me time to do things like eat
06:06:40 <vincenz> That part we seem to have done reasonably ok on
06:07:05 <roconnor> vincenz: I could have done more work on it, but I figured my time was better spent puzzling
06:07:15 <vincenz> roconnor: we only started puzzling very late in the game
06:07:32 <roconnor> vincenz: how late, and how come?
06:08:03 <Syzygy-> vincenz: As for me, I almost wrote a dna2rna according to the given spec, then gave up and organized the party I was hosting this weekend.
06:08:09 <roconnor> vincenz: did you get all 14 pages of gene commands?
06:08:14 <Syzygy-> I still haven't heard from the rest of my team, and we never registered.
06:08:42 <vincenz> roconnor: no
06:09:00 <roconnor> vincenz: ah, you need that to decrypt the activing gene page
06:09:19 <roconnor> vincenz: what's the first entry on the gene command page?
06:09:52 * Nopik is back
06:12:16 <vincenz> roconnor: AAA ?
06:12:25 <roconnor> the whole name of it.
06:12:30 <roconnor> that one
06:12:44 <vincenz> Ho do you decrypt
06:12:46 <vincenz> How
06:13:09 <bartw> i have a little question
06:13:20 <roconnor> vincenz: first, what is the full name of that entry?
06:13:42 <bartw> i have the selfcheck prefix the audio prefix and the prefix embedded in the selfcheck
06:14:00 <bartw> so what a, i supposed to do to find another prefix from this point onward ?
06:14:04 * roconnor missed this audio prefix
06:14:30 <roconnor> bartw: didn't you execute the prefix embedded in the self check?
06:14:57 <bartw> i did, it gives an apparently blank page with the same prefix encoded again in that page
06:15:08 <roconnor> that isn't right
06:15:58 <bartw> IPIFFCPICFPPICIICCIICIPPPFIIC right ?
06:16:26 <roconnor> bartw: do you use vi?
06:17:20 <MyCatVerbs> roconnor: can I just interrupt you for a second with one question born of curiosity? Would you count someone using emacs with vi-bindings (something like viper-mode) in which category, please?
06:17:20 <matthew-_> because if you do, if you type in IPIFFCPICFPPICIICCIICIPPPFIIC in command mode, it'll give you the answer in arabic
06:17:38 <roconnor> MyCatVerbs: yes
06:17:59 <MyCatVerbs> s/Would/In which/, s/in which/would/
06:18:04 <roconnor> MyCatVerbs: for the purposes of this question
06:18:39 <roconnor> MyCatVerbs: specifically because bartw has droped the leading I.
06:19:04 <roconnor> which I have done on oh so many occasions
06:19:35 <MyCatVerbs> roconnor: "yes"?
06:19:47 <bartw> no that isn't the problem
06:20:00 <MyCatVerbs> roconnor: is that as in, "yes, I count viper-mode+emacs as a vi user," or, "yes, viper-mode+emacs is still an emacs user?"
06:21:01 <roconnor> MyCatVerbs: as in yes, presumably if you cut and paste a string begining with I and you are in command mode you will end up pasting everything but the leading I which can be hard to see when your string is a piece of alien DNA.
06:21:59 <MyCatVerbs> roconnor: "aByE, "ap
06:22:10 <MyCatVerbs> Or are you talking copy-paste from one xterm to another?
06:22:29 <roconnor> cut and paste between xterms
06:23:11 <roconnor> vincenz has vanished
06:23:18 <MyCatVerbs> Then putting it into insert mode first oughta be instinctive. ¬¬
06:23:38 <roconnor> MyCatVerbs:  I did that 80% of the time.
06:25:13 <b_jonas> if you do that often, you could turn on the option to automatically get to insert mode when you paste to xterm
06:25:21 <b_jonas> though you need a patched xterm for that
06:26:14 <bartw> generating "before" and "beautifull" numbers works fine but not the prefix for the next step, urgh
06:35:36 <EvilTerran> is there an RPM for xmonad?
06:35:59 <dons> not that i'm aware of, but there might be.
06:36:35 <EvilTerran> nothing came up from a cursory google... cabal it is, then.
06:36:42 <dons> its easy enough to build though
06:36:43 <ndm> @seen dcoutts
06:36:43 <lambdabot> dcoutts is in #haskell-overflow, #haskell and #ghc. I don't know when dcoutts last spoke.
06:37:01 <ndm> dcoutts: this time i'm reporting a Gtk bug, rather than a Neil bug :)
06:37:13 <ndm> (Main.exe:3268): Pango-WARNING **: couldn't load font "Normal 10", falling back to "Sans 10", expect ugly output.
06:37:21 <ndm> and indeed, its correct - i get ugly output
06:37:42 <dons> Neil bugs are the hardest to fix. You better come up with a good test case :D)
06:37:48 <dcoutts_> heh
06:37:52 <ndm> dons: i've been putting them on a wiki :)
06:38:13 <dcoutts_> ndm: and what is it that's expecting to find "Normal 10" ?
06:38:38 <ndm> dcoutts_ i have a large number of labels, which i want to all be monospace font, but some aren't
06:39:01 <dcoutts_> ndm: so you've set them "Mono 10" ?
06:39:12 <ndm> dcoutts_ - i would have said that Normal 10 should be ""Lucida Console,Courier New,monospace"
06:39:29 <ndm> i have, and it usually works
06:39:41 <ndm> its just every so often it decides that fonts suck, and goes screwy
06:40:02 <ndm> possibly memory corruption? it sometimes has other strings which might be nearby instead of "Normal"
06:40:15 <dcoutts_> ndm: which gtk+ / gtk2hs are you using?
06:40:37 <ndm> dcoutts_ - 6.6.1 windows installer, the latest 0.12.3, i think is the version
06:40:38 <dcoutts_> ndm: the first installer I gave you or the current RC1 ?
06:40:58 <ndm> hmm, could be either
06:41:10 <dcoutts_> they have different bundled Gtk+ versions
06:41:15 <ndm> are there more than one which is 6.6.1 compatible?
06:41:29 <dcoutts_> yes, you got the very first working installer
06:41:37 <dcoutts_> then there is also the current RC1
06:41:43 <vincenz> roconnor: ?
06:41:52 <ndm> probably the first then, i don't fix things that aren't broken :)
06:41:55 <dcoutts_> ndm: current is http://haskell.org/gtk2hs/gtk2hs-0.9.11.3.exe
06:42:01 <roconnor> vincenz: did you look up the full name of the first entry?
06:42:22 <ndm> dcoutts, just upgrading...
06:42:23 <vincenz> roconnor: lemme check
06:42:32 <dcoutts_> ndm: I've never seen Normal as a standard font name
06:42:49 <ndm> it was some text out of the program earlier, looked corrupty
06:42:58 <vincenz> AAA_geneTablePageNr
06:43:19 <roconnor> what do you think it contains?
06:43:33 <ndm> btw, i've nearly got a formal proof that my words has exactly the same strictness as the original
06:43:47 <ndm> would have been quicker if i didn't have to write a theorem prover first...
06:44:01 <dcoutts_> ndm: the font alias list is in $GTK2HS/etc/pango.aliases
06:44:09 <bartw> roconnor: hmz now i got the selfcheck prefix, one char shorter then yours still
06:44:18 <roconnor> what the?
06:44:23 <ndm> dcoutts_, it does work most of hte time, so it appears i'm doing the right thing, it just occasionally doesn't, and its nothing to do with my code
06:44:51 <dcoutts_> ok, oddness, could be memory corruption
06:45:04 <dcoutts_> which is always hard since it could be ghc, gtk+ or gtk2hs
06:45:06 <ndm> its definately oddness
06:45:25 <ndm> and the string it claims it wants seems to come from the strings in haskell, but not hte one i gave it
06:45:30 <ndm> fontDescriptionSetFamily font "Lucida Console,Courier New,monospace"
06:45:37 <ndm> that is the single font changing line i have
06:45:44 <ndm> if i set a parent to a font, does the child inherit it?
06:45:49 <ndm> that might get round this entirely
06:45:59 <ndm> i have a Fixed with a lot of Label's inside it
06:46:30 <dcoutts_> ndm: I don't think there's any inheritance like that
06:46:43 <ndm> didn't think so :(
06:46:58 <dcoutts_> it'd probably just be annoying most of the time
06:47:06 <dcoutts_> there is a function that gets all the children though
06:47:10 <ndm> exactly, this is the only case i really play with fonts
06:47:12 <dcoutts_> so it's no hard to iterate over them
06:47:19 <ndm> i create the children at runtime, so set them as i create them
06:47:26 <dcoutts_> or do that
06:48:06 <ndm> so you can get a feeling of what i'm doing: http://www-users.cs.york.ac.uk/~ndm/temp/proof.png
06:48:18 <ndm> each one of those lexemes is a label, and they are contained in a fixed
06:49:10 <dcoutts_> ndm: I can think of easier ways of doing precise layout like that
06:49:19 <ndm> dcoutts_ such as?
06:49:30 <ndm> dcoutts_ i also need to be able to detect clicks on each item
06:49:33 <dcoutts_> using cairo, or a Source/TextView
06:49:43 <vincenz> roconnor: no idea
06:50:06 <ndm> i thought it could be done better, but this is fairly easy, and i can switch it out once i've got the other bits working better
06:50:11 <dcoutts_> 'k
06:50:13 <EvilTerran> ...do i want to be root when installing a cabal doodad?
06:50:40 <dcoutts_> EvilTerran: if you want it installed globally then yes, otherwise install with --user
06:52:33 <EvilTerran> okay. what's this "--prefix" flag do?
06:52:46 * EvilTerran is working through the build instructions for xmonad
06:53:33 <dcoutts_> EvilTerran: it says where to install, eg --prefix=/usr/local (which is the default) or --prefix=$HOME
06:53:50 <EvilTerran> ta. the default works for me, then.
06:54:16 <EvilTerran> hm. "configure: error: X11 libraries not found, so X11 package cannot be built"
06:55:33 <EvilTerran> yay dependency chasing **fires up the packaga manager**
06:58:53 <dcoutts_> ndm: I'd probably try and do it with a TextView + TextBuffer and TextTags for the lexmes/spans. They allow you to attach events to the tags and you can retrieve all the tags that apply to a particular location in the buffer.
06:59:13 <dcoutts_> the tags can also control visual properties of the text
06:59:32 <ndm> dcoutts_, that would be neat, i did do something similar for GuiHaskell, i'll take a shot once i've got the proof side working
06:59:50 <ndm> btw, if i submit a formally verified proof that my words == the original words, would that satisfy you?
06:59:55 <dcoutts_> ndm: is this buffer supposed to be editable by the user or is it read old?
07:00:05 <dcoutts_> ndm: I'd be satisfied with less :-)
07:00:07 <ndm> dcoutts_ - read only, its a reflection of the program state
07:00:13 <byorgey> @pl \(xs,xsss) -> map (xs:) xsss
07:00:13 <lambdabot> uncurry (map . (:))
07:00:15 <ndm> this seems more fun :)
07:00:34 <dcoutts_> ndm: ok, that's no problem, you can make the buffer non-editable (either globally or on a per-span basis)
07:01:00 <ndm> yeah, i'd make it globally read only
07:01:05 <roconnor> vincenz: AAA_geneTablePageNr is a global variable.
07:01:13 <vincenz> roconnor: oh
07:01:56 <roconnor> vincenz: look at it's size
07:02:05 <byorgey> what are you guys working on?
07:02:12 <vincenz> roconnor: I'm rather tired :|
07:02:20 * vincenz is burned out on the contest
07:02:27 <roconnor> vincenz: it took me 3-9 hours to figure that out.
07:03:05 <roconnor> I think the clues in this contest were a bit too subtle.
07:03:46 * vincenz agres
07:03:47 <vincenz> +e
07:04:01 <vincenz> roconnor: and the scoring gradient is too flat
07:04:11 <vincenz> no hillclimbing at all
07:04:18 <vincenz> just ... marathon run and then a big cliff
07:04:30 <roconnor> vincenz: I'm not certain of that.
07:04:38 <roconnor> I conjecture that no one got to the hill
07:04:54 <vincenz> roconnor: hence, too flat a gradient
07:05:18 <roconnor> yes, it turned out that way.
07:08:06 <bartw> better then cops and robbers
07:08:17 <roconnor> bartw: oh, how did that go?
07:08:23 <bartw> but manybe not as ants, umix still my favorit
07:08:46 <bartw> your agent needed to cooperate with other peoples agents, but nobody did
07:09:24 <roconnor> bartw: did you participate?
07:10:05 <bartw> in those 3 ? yes
07:10:39 <roconnor> I never did antz
07:10:45 <roconnor> nor cops and robbers
07:11:37 <Arhuaco> I didn't like the cops thing.
07:11:44 <Arhuaco> 2 weeks?
07:11:58 <Arhuaco> I mean, have time to fix what you do?
07:12:16 <Arhuaco> It's hard to get a team for 1 weekend, let alone 2.
07:12:17 <mm_freak> is there any way to add some data to IO?  like an StdGen instance is contained in IO…
07:12:30 <quicksilver>  sure, that's what IORefs are
07:12:57 <mm_freak> ah, thank you
07:14:05 <norpan> maybe i should enter that contest some year
07:14:26 <bartw> it has been cornered by #haskell
07:14:35 <bartw> i'm here mostly because of icfp actually
07:14:45 <Arhuaco> me too :)
07:14:47 <bartw> year round
07:14:51 <earthy> :)
07:17:11 <dozer> I've build a new base library, and it's been put into: /usr/local/lib/ghc-6.6.1.20070507/
07:17:42 <dozer> is there a trick to compiling against this base library?
07:18:11 <roconnor> bartw: how do you find this audio prefix?
07:19:22 <bartw> lets go to #oasis
07:19:31 <dozer> or should I be asking in #ghc?
07:19:42 <wolverian> is System.Process the nicest interface to getting the output of an external program?
07:19:51 <bartw> roconner: lets go to #oasis
07:20:07 <matthew-_> wolverian: rewriting it in Haskell would be nicer! ;-)
07:20:23 <matthew-_> wolverian: I've had no problems with using those handles to read output
07:20:30 <Nopik> ok, i'm still stuck at my getpixel problem :(
07:20:36 <wolverian> matthew-_, yeah, but it's mplayer... ;)
07:20:38 <matthew-_> wolverian: DisTract interfaces with monotone that way
07:21:10 <matthew-_> wolverian: oh, I didn't know you were trying to interface with hideously written, unreliable and disgusting programs. ;)
07:21:18 <wolverian> matthew-_, anyway, thanks. I want to use runInteractiveProcess I assume? or create my own handles and give them to runProcess?
07:21:31 <matthew-_> I always let it create the handles for me
07:21:33 <wolverian> (I'm not actually going to output anything to mplayer.)
07:22:02 <matthew-_> wolverian: yeah, I use runInteractiveProcess all over the place
07:22:10 <matthew-_> just be aware that input is lazy
07:22:40 <matthew-_> wolverian: literally, for interacting with monotone, I do hGetContents and then feed that into parsec. But you may have more pain with mplayer.
07:23:11 <wolverian> I think I'd almost rather run a shell script to get the information out of mplayer that I want..
07:23:22 <wolverian> anyway, this is ok, thanks!
07:23:29 <matthew-_> wolverian: yeah, using expect or something similar may save you pain
07:23:37 <fasta> Why is ./darcs-all pull in GHC so slow? Are their servers overloaded or is it just darcs that's uber slow?
07:23:39 <matthew-_> haskell wasn't really designed for that
07:23:52 <fasta> I got about 6KB/s
07:27:52 <Nopik> here is the thing: i want to operate on images (given to me as IO Image).. image operations give me IO things like getImageSize :: Image -> IO (Int, Int)
07:28:16 <Nopik> i would like to write pure functions (without IO) to work on them
07:28:30 <Nopik> e.g. compare 2 images, copy region etc.
07:28:42 <Nopik> is it possible at all, or I have to infect all my functions with IO?
07:28:56 <SamB_XP_> what does Image look like?
07:29:14 <quicksilver> Nopik: it is possible
07:29:18 <quicksilver> Nopik: you write pure functions
07:29:29 <quicksilver> Nopik: and then you 'lift' them when you use them
07:29:43 <Nopik> quicksilver: ok, and if in my pure function i need to call not pure function?
07:29:51 <quicksilver> that, you can't do
07:29:53 <quicksilver> nor should you
07:29:57 <quicksilver> it doesn't make sense
07:30:09 <norpan> why is getImageSize :: Image -> IO ...?
07:30:15 <Nopik> probably this is why i am failing at doing this ;)
07:30:25 <Nopik> norpan: dont ask me :)
07:30:34 <SamB_XP_> Nopik: where do they come from?
07:30:41 <EvilTerran> norpan, i'm guessing images are mutable
07:30:52 <Nopik> SamB_XP_: from gd library
07:30:58 <SamB_XP_> Nopik: aha!
07:31:10 <EvilTerran> Nopik, i mean
07:31:10 <Nopik> yes, images are mutable.. inside of gd they are hold as pointers to native representation
07:31:16 <EvilTerran> whoever
07:31:42 <norpan> well, then you can't expect any function operating on an Image to be pure
07:31:52 <EvilTerran> in which case, as the results of the functions may change, they have to return values in IO.
07:31:58 <Nopik> ok, i'll live with IO everywhere, then ;p
07:32:01 <SamB_XP_> probably you want a real Haskell type for images
07:32:23 <SamB_XP_> than you can convert these gd images to haskelly images
07:33:31 <EvilTerran> you *could*, however, newtype ImmutableImage = ImmutableImage Image, and then write unsafePerformIO-laced functions for all the Image-taking functions that act pure
07:33:56 <EvilTerran> but it'd be dodgey. or, you could do what SamB suggests.
07:35:32 <Nopik> SamB_XP_: how should i do that?
07:36:01 <quicksilver> probably just as an UArray of pixels
07:36:10 <quicksilver> using whichever pixel type GD uses normally
07:37:01 <Nopik> but that will still be infected with IO once i load those pixels from disk?
07:38:04 <quicksilver> yes, but you'll still be able to write pure functions over it
07:38:47 <Nopik> hm, i think i dont understand how it will improve over gd Image type
07:39:00 <Nopik> my knowledge of haskell is still very small ;)
07:39:03 <quicksilver> well you wanted to write pure functions to manipulate Images
07:39:12 <Nopik> yes
07:39:13 <quicksilver> but you apparently can't, because all the GD functions are in IO
07:39:17 <EvilTerran> Nopik, do img <- loadImage "blah"; pixelArray <- purifyImage img; pureFunction pixelArray
07:39:30 <quicksilver> this is a limitation of the GD API (apparently)
07:39:37 <quicksilver> so we're suggesting a better Image type
07:39:43 <quicksilver> which pure functions work on
07:40:35 <Nopik> ok, so everything will be in do .. over IO Image, and inside i can get pure functions, while GD functions would require more IO and do expressions nested?
07:40:43 <norpan> manipulating images using pure functions seems tricky
07:40:54 <norpan> if you're not careful it will be very inefficient
07:41:05 <Nopik> norpan: yeah, it seems so
07:41:14 <Nopik> maybe i'll just stick to IO
07:41:20 <EvilTerran> Nopik, what exactly are you trying to do to your images?
07:41:49 <Nopik> EvilTerran: right now i have 'simple' problem: given two images (one small and one big) scan big image if it contains smaller one somewhere
07:42:14 <norpan> that should be easy to do with a pure function
07:42:22 <EvilTerran> hm. i think that lends itself to expressing purely, yes
07:42:37 <Nopik> norpan: yes, unless you have getPixel and getImageSize returing IO things ;p
07:42:59 * EvilTerran headdesk
07:43:11 <Nopik> i have pure function broken down to comparing 2 pixels.. and stopped at this point ;)
07:43:18 <Nopik> EvilTerran: /me too ;p
07:43:48 <vincenz> EvilTerran: your desk must have a deep hole by now
07:44:55 <EvilTerran> do { (width,height) <- getImageSize img; pixels <- liftM (array ((0,0),(width-1,height-1))) $ sequence [getPixel img x y | x <- [0..width-1], y <- [0..height-1]]; return pureFunction pixels }
07:45:38 <EvilTerran> ...with a "$" after "return" there. also, this is all pseudocode, i don't know GD's interface.
07:46:46 <ndm> dcoutts: (Main.exe:2468): Pango-WARNING **: couldn't load font "Prelude.True Not-Rotated10", falling back to "Sans Not-Rotated 10", expect ugly output.
07:46:57 <ndm> dcoutts, now that strongly suggests corruption :)
07:47:22 <EvilTerran> Nopik, but that's the gist of it. the point of do{ foo <- somethingReturningIO; ... } is that it lets you do pure things to "foo", but still forces your function to have an IO type in the end, because the do {...} must have an IO type overall
07:47:50 <dcoutts_> ndm: certainly does
07:48:04 <mm_freak> quicksilver: i guess, IORef isn't what i'm looking for
07:48:06 <ndm> dcoutts_ thats as per the latest one
07:48:25 <dcoutts_> ndm: does that also happen when you do not set the font explicitly? eg perhaps the error is in the binding for the function that sets the font family.
07:48:37 <EvilTerran> Nopik, think of "IO" as a box. you can put anything you like in the box, but can't take anything out of the box. everything with side-effects *starts* in the box.
07:48:46 <ndm> dcoutts_ i only have widgets on whom i have set the font
07:48:55 <mm_freak> IO carries an StdGen variable around, which you can use with random*IO
07:49:22 <mm_freak> now i've written another instance of RandomGen and would like to write functions similar to random*IO
07:49:34 <dcoutts_> ndm: yes and I'm suggesting as a test to not set them explicitly, avoiding the function that sets the font family.
07:49:43 <Nopik> yeah
07:49:51 <EvilTerran> Nopik, so you can still use pure functions on these things, you can say "do foo <- ioFoo; somePureFn foo"; you could see the <- as "getting inside the box" to work with the values in it
07:49:55 <Nopik> EvilTerran: wont it be too slow top copy all pixels?
07:50:15 <Nopik> EvilTerran: yeah, i have figured it out already
07:50:28 <EvilTerran> okay. wasn't sure how familiar you were with that sort of thing
07:50:31 <Nopik> EvilTerran: though i had problem with folding over all pixels
07:50:40 <ndm> dcoutts_ i'll try
07:51:02 <dcoutts_> ndm: what was the name of that function, setFontFamily or something ?
07:51:04 <EvilTerran> given that you're gonna have to look at all the pixels anyway, copying them should be fairly negligable
07:51:09 <Nopik> EvilTerran: lets say, that i'll stick with IO and give up on pure functions.. how to iterate over pixels and compare them?
07:51:27 <EvilTerran> especially as i imagine reading from some kind of pure array could well be faster than reading from Images
07:51:43 <EvilTerran> and may be lazier
07:51:53 <EvilTerran> @where gd
07:51:54 <lambdabot> I know nothing about gd.
07:52:02 <ndm> @hpaste
07:52:02 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:52:11 <hpaste>  ndm pasted "display code for dcoutts" at http://hpaste.org/1854
07:52:20 <dcoutts_> ndm: ta
07:52:21 <ndm> dcoutts: the fragment is in there
07:53:08 <EvilTerran> Nopik, can you point me to the GD docs? i don't know the interface, so can't help you without 'em
07:53:50 <Nopik> http://www.cs.chalmers.se/~bringert/darcs/haskell-gd/
07:53:53 <lambdabot> Title: Index of /~bringert/darcs/haskell-gd
07:56:10 <dcoutts_> ndm: the code for fontDescriptionSetFamily was broken :-(
07:56:18 <dcoutts_> ndm: will be fixed in 0.9.12 final version
07:56:39 <ndm> dcoutts_ cheers, i'll probably move on to using a text widget properly by then anyway, but good to catch
07:56:52 <Nopik> .. or i can stick to other imaging library which allows me to load png/gif, modify it and write back ;p
07:57:19 <EvilTerran> ...how do you read pixels? i don't see it
07:58:12 <quicksilver> there is an undocumented getPixel, I think
07:59:12 <EvilTerran> ...it's not in the export list, from what i see
08:01:09 <Nopik> EvilTerran: i added getPixels myself, just like setPixels
08:02:06 <EvilTerran> ...what type is it?
08:03:30 <kolmodin> http://picasaweb.google.com/kolmodin/Blueberries/photo#5090355118961122754
08:03:33 <lambdabot> Title: Picasa Web Albums - Lennart Kolmodin - Blueberries, http://tinyurl.com/2bmfjl
08:03:52 <Nopik> getPixel :: Point -> Image -> IO Color      getPixel (x,y) i = withImagePtr i $ \p -> gdImageGetPixel p (int x) (int y)
08:07:03 <byorgey> kolmodin: my mouth is watering... =D
08:07:07 <kolmodin> :)
08:07:13 <fasta> Nopik: do you intend to put up a new package on hackage?
08:07:35 <kolmodin> yeah, quite nice :D
08:07:59 <EvilTerran> Nopik, well, as i said, i'd really be inclined to <- your images into arrays and manipulate the arrays with pure functions inside a do{...}
08:08:38 <fasta> You need to make an ImageMonad
08:08:46 <fasta> Then you can write:
08:09:09 <fasta> do rotate;brightness (+200)
08:09:30 <mux> scale (1/x) (1/y)
08:09:36 <fasta> Anyway, I think that's quite a Haskelly solution.
08:09:44 <mux> reminds me of the Render monad in gtk2hs
08:10:08 <fasta> Also more practical than doing everything pure.
08:10:09 <dcoutts_> which is pretty cool imho
08:10:15 <EvilTerran> fasta, would this all be in a "runOnImage img $ do {...}"?
08:10:21 <dcoutts_> though it would be nice to have a pure layer on top of that
08:10:35 <fasta> Code written in the ImageMonad could be implemented in a pure way, though.
08:10:38 <mux> dcoutts_: yeah, i'd go as far as saying it rocks :)
08:10:42 <EvilTerran> as i mentioned earlier, an immutable image type would be nice
08:10:52 <fasta> If it's written in the monad it's just more general.
08:11:34 <fasta> EvilTerran: yes
08:12:16 <fasta> I suppose runOnImageT would be better
08:12:27 <EvilTerran> mm, true
08:12:35 <fasta> It seems that any non-trivial use of monads calls for transformers after some time.
08:13:06 <EvilTerran> well, from the moment you want more than one at once, i guess
08:17:05 <Nopik> EvilTerran: i'll consider the arrays, then
08:17:11 <Nopik> fasta: actually, interesting idea ;)
08:17:46 <fasta> EvilTerran: which is generally always :)
08:17:59 <EvilTerran> quite, quite
08:18:53 <Nopik> fasta: how such ImageMonad be usable? main = do image <- load; rotate; save ?
08:19:06 <Nopik> .. that would be IO monad ;p
08:19:31 <quicksilver> more like runTransform (do rotate; brightness (+10)) image
08:19:50 <Nopik> @src runTransform
08:19:51 <lambdabot> Source not found. I've seen penguins that can type better than that.
08:19:54 <quicksilver> fasta's idea is definitely cool, but it's more-or-less orthogonal to your current dilemma
08:20:20 <fasta> Oh, I completely ignored his current dilemma :)
08:20:37 <EvilTerran> Nopik, i think the idea would be that you'd "select" an image, then do a series of transformations on it. either like what quicksilver said, or do { selectImage img; rotate; brightness (+10) } or somesuch
08:20:55 <Nopik> EvilTerran: how it would support operations on 2 images?
08:21:00 <Nopik> EvilTerran: e.g. compare 2 images?
08:21:21 <fasta> Nopik: you can have a list of images instead of just one
08:21:22 <wolverian> hrm. I'm reading data from an external program, which prints some lines per each line I give to it. how can I make sure this stays in sync? that is, should I make hGetContents strict, or so?
08:21:41 <fasta> Nopik: anyway, those are exactly the things you need to find out to write something practical
08:21:59 <fasta> Nopik: if you are learning Haskell, it's an excellent exercise.
08:22:28 <wolverian> meh, I suppose it'll just work. it's just a bit hard to reason about.
08:22:40 <wolverian> (for me)
08:23:08 <Nopik> fasta: yeah, i figured it out.. and actually i would like to do it this way (I mean ImageMonad), though I have no idea how to start ;p
08:23:28 <Nopik> can i do it over gd's IO Image, or I do need to create my own Image somehow?
08:23:56 <fasta> Nopik: a good way is to just write down the code you would like to write and then make it work.
08:24:34 <Nopik> fasta: not at my level of haskell knowledge, i'm afraid
08:24:39 <fasta> Nopik: understanding how xmonad works can help
08:24:58 <Nopik> fasta: yeah, but what is xmonad? :P
08:25:03 <fasta> @where xmonad
08:25:03 <lambdabot> http://xmonad.org/
08:25:10 <Nopik> thanks
08:26:56 <quicksilver> wolverian: turn off buffering
08:27:13 <quicksilver> wolverian: and, probably, don't use hGetContents
08:27:13 <gmosx> anyone has any idea about the ETA for ghc 6.8?
08:27:18 <quicksilver> use strict IO instead
08:27:25 <wolverian> quicksilver, ah. how do I do that?
08:27:34 <wolverian> (use strict IO)
08:27:35 <quicksilver> hGetNonBlock
08:27:38 <quicksilver> and friends
08:27:40 <quicksilver> probably
08:27:46 <quicksilver> or maybe even just hGetLine
08:27:52 <quicksilver> depends if you need not to block
08:28:03 <wolverian> blocking is fine.
08:28:40 <quicksilver> sounds like you want hGetLine then
08:28:43 <dmead> we are the mustaches the beatles grew when they dropped acid
08:29:04 <matthew-_> it never ceases to amaze me the amount of effort that goes into building apis around such an arbitrary character as 13
08:29:15 <wolverian> quicksilver, thanks.
08:29:23 <matthew-_> and then the subsequent non-abstraction to any arbitrary character.
08:31:50 <phoniq> Text.Regex.Posix let's you do a very perlish mystring =~ "\\.txt$"
08:31:54 <phoniq> that's insane
08:32:06 <phoniq> haskell boggles the mind
08:33:00 <phoniq> bos thanks for that blog entry
08:34:30 <fasta> Anyone tried Qi here already?
08:35:19 <fasta> When I tried it a year ago or more, the implementation was... rough, to say the least...
08:36:14 <blackdog> sort of a weird non haskelly question, but are there any windows guys around? i'm looking for a decent terminal emulator... tabbed windows would be awesome, f'rinstance...
08:37:08 * blackdog has not used windows for a while and wants to see if his haskell program is slow because it's on his laptop, or slow because it's just plain crap...
08:37:35 <dozer> blackdog: you may be able to get xemacs running under cygwin
08:37:52 <dozer> blackdog: I've heard that has everything you need to develop on windows
08:37:55 * dozer ducks
08:37:58 <blackdog> ... uh, does that help me?
08:38:03 <blackdog> smartarse :)
08:38:10 <byorgey> blackdog: ndm is a windows guy, I think, but there are probably others as well...?  (I am not...)
08:38:38 <matthew-_> @users
08:38:38 <lambdabot> Maximum users seen in #haskell: 351, currently: 350 (99.7%), active: 21 (6.0%)
08:38:42 <blackdog> i don't really want to develop under windows - just want to use it as a compute server, basically. my lovely powerbook is not the fastest machine around.
08:38:48 <hpaste>  vincenz pasted "CMonad" at http://hpaste.org/1855
08:38:50 <blackdog> thanks byorgey
08:38:54 <matthew-_> mmm. so you're assuming that more than 1 in 351 haskellers are windowsers
08:39:10 <blackdog> it's a bit iffy, hey
08:39:20 <blackdog> but simonpj still works for the evil empire, right?
08:39:25 <byorgey> matthew-_: dodgy, I know...
08:39:36 <matthew-_> right. and uses the worst email client on earth
08:39:51 <matthew-_> which sends 1000 char lines to the mailing lists...
08:40:01 <blackdog> heh. yes. i think he just chews on the ethernet port...
08:40:07 <phoniq> lol
08:41:08 <matthew-_> and woe betide you if you send an attachment with mime type text/x-haskell or text/x-literate-haskell as mailman will pull it right off. Yay.
08:41:28 * EvilTerran is a windows user
08:41:34 <matthew-_> that's 2!
08:41:34 * EvilTerran ducks as well
08:42:12 <EvilTerran> and, TBH, the NT-series cmd.exe is perfectly good for everything i've needed. they snuck in an awful lot of unix functionality when no-one was looking.
08:42:17 <Nopik> @src ask
08:42:18 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
08:42:21 <Nopik> @src asks
08:42:21 <lambdabot> asks f = do
08:42:21 <lambdabot>     r <- ask
08:42:21 <lambdabot>     return (f r)
08:42:26 <blackdog> EvilTerran: any tips? i vaguely remember cygwin being usable (barely)
08:42:27 <eivuokko> Hmmm.  I use Windows, if that alone is interesting.  I just didn't have answer to terminal emulation program question.
08:42:32 <Nopik> @src get
08:42:33 <lambdabot> Source not found. I feel much better now.
08:42:56 <eivuokko> I use Windows console and putty for remote unixy stuff, no tabs or anything.  Works for me...
08:43:14 <Nopik> hm... what is 'ask' in 'asks' definition?
08:43:18 <blackdog> fair enough. I've been spoilt, i guess.
08:43:25 <EvilTerran> blackdog, well, i personally can't stand the bloody thing, and get annoyed when people go "ooh, look, we run on windows" and then, when you actually look, step 1 is "install cygwin"
08:43:33 <matthew-_> Nopik: it depends on the implementation of Reader
08:43:43 <mux> Nopik: I think it's liftM f get
08:44:22 <blackdog> EvilTerran: i have some sympathy for that. I'd almost prefer a flat-out different experience than something that's desperately trying to be Unix and running thin at the edges
08:44:25 <Nopik> magic, in other words ;p
08:44:27 <EvilTerran> cygwin's a nice idea, but poorly executed. and probably impossible to actually do well.
08:44:42 <mux> @src State get
08:44:43 <lambdabot> Source not found. Just what do you think you're doing Dave?
08:44:47 <earthy> evilterran: mingw is reasonable
08:45:16 <EvilTerran> earthy, indeed, mingw is fine. MSYS, on the other hand, is mingw and cygwin's inbred bastard child
08:45:26 <byorgey> Nopik: the implementation of ask depends on the particular instance of MonadReader
08:45:40 <Nopik> the problem with understanding XMonad is that it is using a lot of existing libraries and monads.. which i do not understand yet
08:45:52 <EvilTerran> and gets my bile going even more than cygwin
08:45:55 <byorgey> Nopik: do you know what a reader monad is for?
08:46:24 <Nopik> byorgey: more or less.. seems like deserializing to me
08:47:06 <byorgey> Nopik: mmm, not really, although maybe you could use it for that
08:47:18 <byorgey> Nopik: it's sort of like State except that you can't write to the state
08:47:28 <byorgey> Nopik: you can only get things out
08:47:55 <pjd> it's Reader as in "read from shared environment"
08:48:15 <Nopik> byorgey: thats fine, as long as you understand what State does ;p
08:48:17 <byorgey> Nopik: as for deserializing, maybe you are thinking of Read, which is different
08:49:13 <byorgey> Nopik: ah.  a State monad just gives you a hidden state (i.e. variable) threaded through your computations, which you can examine (get) or update (put)
08:49:37 <Nopik> byorgey: any examples of usage?
08:50:38 <byorgey> Nopik: hmm...
08:52:39 <byorgey> Nopik: well, there's http://www.alpheccar.org/en/posts/show/60
08:52:40 <lambdabot> Title: A newbie in Haskell land or another monad tutorial
08:53:19 <Nopik> how should i read this declaration: newtype X a = X (ReaderT XConf (StateT XState IO) a) ?
08:53:35 <Nopik> especially things like (StateT XState IO) ?
08:53:48 <byorgey> Nopik: things ending with T like that are usually monad transformers
08:53:53 <Nopik> I would understand newtype X a = X XConf XState a
08:54:08 <byorgey> Nopik: which take some existing monad and wrap it inside another
08:54:12 <Nopik> hm
08:54:31 <byorgey> Nopik: so StateT XState IO adds state functionality to the IO monad
08:54:38 <byorgey> with XState as the type of the state
08:54:42 <Nopik> ok, i see that every *T gets its own ()
08:55:06 <Nopik> ok, this starts to make sense
08:55:30 <byorgey> then ReaderT adds a Reader environment on top of that, with XConf as the environment
08:55:54 <byorgey> so anywhere you see 'put' or 'get', it's operating on the XState
08:55:57 <Nopik> hm, what is 'environment' here?
08:56:09 <byorgey> anywhere you see 'ask', it's reading from the XConf
08:56:31 <byorgey> 'environment' as in, something you can read from but not modify
08:58:56 <Nopik> so, to construct any X monad I need XConf value?
08:59:03 <Nopik> erm, probably not
09:00:24 <byorgey> Nopik: no, an expression of type X a represents a computation inside the X monad, which returns an a
09:00:40 <byorgey> Nopik: it assumes there already is an XConf value which it can read from
09:00:42 <Nopik> yeah, this question did not made any sense even to me ;p
09:01:06 <byorgey> Nopik: to actually *run* something of type X a, you need to provide it with an XConf value
09:01:24 <Nopik> @src lift
09:01:25 <lambdabot> Source not found. Just what do you think you're doing Dave?
09:02:12 <byorgey> lift is from MonadTrans (the type class of all monad transformers, such as ReaderT)
09:02:37 <byorgey> it 'lifts' a computation in the inner monad into a computation in the outer (transformed) monad
09:03:21 <Nopik> @src local
09:03:22 <lambdabot> Source not found. Where did you learn to type?
09:03:38 <byorgey> Nopik: you might also want to take a look at http://haskell.org/haskellwiki/Monads_as_containers
09:03:40 <lambdabot> Title: Monads as containers - HaskellWiki
09:05:30 <byorgey> local lets you perform a nested computation using a modification of the contents of a Reader monad.
09:08:26 <matthew-_> Nopik: you may want to read http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
09:09:59 <Nopik> i'll read that too
09:10:47 <Nopik> i'm goes home, brb ;p
09:12:20 * rho is away: (watching house)
09:19:22 <wolverian> heh. putting debugging prints in my program changes its behaviour completely.
09:19:49 <matthew-_> wolverian: talking to mplayer?
09:19:52 <wolverian> yup
09:20:05 <wolverian> I get sporadic behaviour, sometimes getting an EOF while mplayer should still be writing to the buffer
09:20:11 <matthew-_> yeah, I've had that
09:20:15 <wolverian> so I'm misusing hGetLine, I'm sure.
09:20:23 <matthew-_> set NoBuffering ?
09:20:33 <wolverian> I have line buffering now, I'll try that
09:20:56 <matthew-_> or, in Perl speak: $| = 0;
09:20:56 <wolverian> nope, that didn't help.
09:20:59 <matthew-_> ok
09:21:07 <wolverian> well, it did change the behaviour
09:21:10 <wolverian> now I get EOF immediately all the time
09:21:11 <matthew-_> mmm. Mplayer could do with a sane external api
09:21:20 <matthew-_> wolverian: at least it's deterministic
09:21:35 <wolverian> argh! now it worked.
09:21:36 <wolverian> dammit.
09:22:01 <wolverian> I think I'll revert to the version that spawns mplayer for each file and doesn't try to talk to its slave mode.
09:22:08 <wolverian> it is slower, but at least it worked..
09:30:19 <fasta> @where ListT
09:30:19 <lambdabot> I know nothing about listt.
09:30:27 <chessguy> dons, are you still tracking haskell entries for the contest?
09:31:31 <fax> hi
09:31:38 <fasta> How do I make this work? the code is in the list monad.   head (do a <- function_existing_in_some_other_monad; guard (a ==2))
09:31:39 <chessguy> @seen dons
09:31:40 <lambdabot> dons is in #haskell-icfp07, #xmonad, #haskell-soc and #haskell. I last heard dons speak 2h 51m 2s ago.
09:32:16 <fasta> I suppose I need to use runListT, but I don't have that.
09:33:28 <EvilTerran> fasta, that doesn't return a value, does it?
09:33:35 <AStorm> fasta, isn't that in Control.Monad.List?
09:33:57 <EvilTerran> well, it'll be a [()]...
09:35:03 <EvilTerran> > head (do guard True)
09:35:05 <lambdabot>  ()
09:35:15 <EvilTerran> > head (do guard False)
09:35:16 <lambdabot>  Exception: Prelude.head: empty list
09:35:40 * EvilTerran notes that those "do"s were unnecessary
09:36:33 <fax> :t (->)
09:36:35 <lambdabot> parse error on input `->'
09:36:39 <fax> :`
09:38:26 <ddarius> :k (->)
09:38:26 <quicksilver> more likely you want { a <- foo; guard (a==2); return a }
09:38:28 <lambdabot> ?? -> ? -> *
09:38:32 <quicksilver> well that wort of thing is more likely
09:38:47 <fax> What is :k?
09:39:28 <opqdonut> fax: kind
09:40:49 <byorgey> fax: kinds are sort of like types for "type functions"
09:41:11 <byorgey> fax: for example, Maybe has kind (* -> *), since it takes some type (e.g. Int) and produces another (Maybe Int).
09:41:31 <ejt> could anyone tell me what 'Node' and 'Digit' are in a heap profile (-hy) please ?
09:41:37 <fax> so * there is just like a wildcard
09:42:16 <_roconnor> anyone know what to put in a .htaccess file to set a different file for the index page?
09:42:57 <byorgey> fax: right, * means something like "any concrete type"
09:43:25 <_roconnor> DirectoryIndex
09:44:06 <_roconnor> perfect!
09:44:16 <fax> ok cheers everyone
09:44:17 <_roconnor> darcs get http://r6.ca/icfp2007/
09:45:11 * rho is back
09:48:05 * EvilTerran installs darcs
09:52:07 <fax> hm...
09:52:24 <fax> I wonder why I had to just convert yaht.pdf into postscript and back to be able to copy and paste from it
09:59:16 <Syzygy-> Because there is some metadata for searching and copy-pasting that PDFLatex doesn't quite get right on its own.
09:59:21 <Syzygy-> Most likely.
09:59:43 * fax grumbles about pdf being less than perfect
10:05:51 <fax> I can write f (x+1) = x * f x
10:06:09 <fax> where is it defined what you can use as a parameter?
10:06:26 <profmakx> huh?
10:06:29 <fax> like you can also write f (x:xs) =
10:06:39 <profmakx> this is inferred by the type system
10:06:40 <fax> I wonder what things it can pattern match
10:07:08 <_roconnor> fax: haskell has special synatx for (x+1) patterns
10:07:32 <fax> what  is the syntax?
10:07:40 <ddarius> Forget n+k patterns.
10:07:45 <Syzygy-> > let f (x+2) = x in f 3
10:07:45 <lambdabot>  Parse error in pattern
10:07:46 <quicksilver> fax: normally, you can only pattern match on constructors
10:07:48 <Syzygy-> Awwwww
10:07:56 <quicksilver> x+1 is an exception
10:07:56 <Syzygy-> > let f (x+1) = x in f 3
10:07:57 <lambdabot>  Parse error in pattern
10:08:06 <roconnor> why doens't that work?
10:08:11 <fax> quicksilver: normally?:S
10:08:17 <fax> I don't understand
10:08:31 <quicksilver> fax: n+k is a special, and ratheer controversial extension to the language
10:08:41 <ddarius> It's not an extension.
10:08:41 <quicksilver> fax: other than that, you can only patter match constructors
10:08:43 <quicksilver> (like :)
10:08:44 <Syzygy-> GOA> let f (x+2) = x in f 3
10:08:44 <Syzygy-> 1
10:08:52 <quicksilver> s/extension to/feature of/
10:08:54 <fax> GOA?
10:08:54 <Syzygy-> n+k works in my GHCi.
10:08:56 <Syzygy-> :)
10:09:02 <Syzygy-> GHCi on Acid
10:09:07 <fax> > let f (x:xs) = x in f [1,2,3]
10:09:08 <lambdabot>  1
10:09:09 <Syzygy-> IT's GHCi + lambdabot + some more.
10:09:20 <fax> quicksilver: oh I see, what are the constructors?
10:09:33 <Syzygy-> What are the main arguments against n+k?
10:10:04 <fasta> Syzygy-: it's not a general mechanism, I think.
10:10:07 <fax> n+k considered harmful
10:10:11 <quicksilver> fax: ':' is a constructor of lists
10:10:13 <AStorm> Exactly, it's not general
10:10:20 <Syzygy-> ?go n+k considered harmful
10:10:23 <lambdabot> http://www.thocp.net/biographies/papers/goto_considered_harmful.htm
10:10:23 <lambdabot> Title: GoTo considered Harmfull
10:10:26 <fax> :o
10:10:27 <fax> its real
10:10:29 <Syzygy-> Nope. That's not it.
10:10:29 <fax> lol
10:10:35 <quicksilver> fax: 0,1,2,3,4.... are all constructors of Num s, although they're a bit special too
10:10:46 <quicksilver> fax: Left and Right are consturctors of eithers, etc etc
10:10:50 <fax> quicksilver: constructors of zero arguments
10:10:55 <fax> ooh :D
10:11:05 <fax> I see, thats cool
10:11:21 * quicksilver nods
10:11:23 <quicksilver> that's quite common
10:11:24 <fax> can you define your own infix constructors?
10:11:31 <quicksilver> 'Nothing' is a zero-arg constructor, too
10:11:37 <lightstep> fax, you can
10:11:43 <fax> cool
10:11:43 <quicksilver> yeah, any symbol beginning with ':' is an infix constructor
10:12:10 <AStorm> is that mandated, or only a convention?
10:12:27 <dcoutts_> AStorm: mandated, like Constructors being upper case
10:12:27 <AStorm> @where n+k
10:12:27 <lambdabot> I know nothing about n+k.
10:12:41 <AStorm> dcoutts_, mhm :>
10:14:39 <fax> let f ((1+x):xs) = x:xs in f [1,2,3]
10:14:47 <fax> GOA> let f ((1+x):xs) = x:xs in f [1,2,3]
10:15:06 <fax> hmpf
10:15:10 <ddarius> Syzygy-: n+k patterns are also unintuitive (e.g. they only work for positive numbers) and lead to some really confusing function declarations.
10:15:20 <EvilTerran> altho you can use Constructors infix with ``s, and :constructors prefix with ()s
10:15:42 <quicksilver> It was recently announced that people are working on Views for haskell
10:15:54 <quicksilver> arguably these include 'things like n+k' but done more regularly
10:15:55 <fax> can you do f ((1+x):xs) =
10:16:27 <EvilTerran> hm...
10:16:33 <ddarius> Actually it looks more like they're finally implementing transformational patterns rather than views.
10:16:41 <quicksilver> under the view proposal you could do f ((-k) -> n) =
10:16:45 <ddarius> fax: You can nest patterns arbitrarily deep.
10:16:46 <quicksilver> which would be much like n+k
10:16:56 <EvilTerran> > Left True :: Bool `Either` Int
10:16:56 <lambdabot>  Parse error
10:16:58 <EvilTerran> aw.
10:17:11 <ddarius> EvilTerran: You can do that with -fglasgow-exts
10:17:12 <quicksilver> no infix at the type level for you!
10:17:42 <EvilTerran> ddarius, i thought so. still can't have infix classes with that, tho, iirc
10:17:44 <littledan> I don't understand; what's the justification for n+k patterns?
10:18:00 <fax> it is like induction
10:18:09 <mux> it's mathematical feeling is appealing
10:18:11 <lightstep> quicksilver, you have, you just must use constructors starting with ':' in '98
10:18:16 <ddarius> littledan: The only sensical reason for them ever being introduced is in relation to induction on naturals.
10:19:05 <EvilTerran> hm. views/transformational patterns seem reminiscent of pattern guards
10:19:05 <quicksilver> littledan: that's still the value level
10:19:08 <AStorm> well, it's better to define boundary cases and global case instead of n and n+1 :P
10:19:11 <fax> :k ::
10:19:17 <quicksilver> littledan: sorry that was for lightstep, but he left
10:19:19 <ddarius> E.g. data Nat = Z | S Nat, fac Z = 1; fac n@(S n') = n*fac n  fac 0 = 1; fac n@(n'+1) = n*fac n'
10:19:19 <lambdabot> parse error on input `::'
10:19:24 <EvilTerran> altho terse in other places
10:19:27 <AStorm> Induction is assumed in recursion
10:19:40 <ddarius> EvilTerran: Transformational patterns were introduced in the same paper as pattern guards.
10:19:41 <EvilTerran> fax, :: is not an operator, it's a special syntax
10:19:58 <fax> where is :: defined?
10:20:03 <EvilTerran> @where report
10:20:03 <lambdabot> http://www.haskell.org/onlinereport/
10:20:09 <ddarius> fax: It's syntax.
10:20:12 <fax> ah thanks
10:21:32 <littledan> ddarius, is that done very often in practice?
10:21:39 <ddarius> littledan: What?
10:21:54 <littledan> induction on naturals using n+k patterns; is it a common idiom in haskell
10:22:04 <ddarius> No one uses n+k patterns.
10:22:07 <littledan> oh
10:22:12 <ari> ... I do :(
10:22:16 <EvilTerran> fax, http://www.haskell.org/onlinereport/decls.html#type-signatures
10:22:17 <lambdabot> Title: The Haskell 98 Report: Declarations
10:22:23 <fasta> ab x y = liftM (head . head) $
10:22:23 <fasta>           runListT (do candidate <-  zork y
10:22:23 <fasta>                        guard (candidate /= x)
10:22:25 <fasta>                        return candidate)
10:22:27 <littledan> ari, you're nobody!
10:22:30 <EvilTerran> fax, also http://www.haskell.org/onlinereport/exps.html#sect3.16
10:22:31 <lambdabot> Title: The Haskell 98 Report: Expressions
10:22:38 <fasta> Isn't this a bit ridiculous?
10:22:46 <fax> thank "D
10:22:48 <ari> It was only a little thing, though
10:22:50 <AStorm> littledan, use 1 and n case
10:22:56 <AStorm> you don't need n+1 at all :>
10:23:07 <littledan> ok, thanks
10:23:26 <fasta> zork is a function that gets exectuted in a FooMonad.
10:23:44 <fasta> It returns a [Int]
10:23:45 <ari> A definition of lengthIs :: Int -> [a] -> Bool that was made so wonderfully symmetric by matching on (n+1) (x:xs)
10:24:09 <ddarius> ari: Indeed, Nat ~ [()]
10:24:24 <AStorm> ari, too cheap
10:24:27 <AStorm> and slow :>
10:24:35 <fasta> The real question is: where are those layers of lists coming from?
10:24:59 <ari> AStorm: Not as slow as calling length on potentially infinite lists, and the first thing I came up with :)
10:25:03 <fasta> I would have expected I could just take the head of it, but that's not how it apparently works.
10:25:19 <AStorm> ari, uhm... that should _|_
10:25:23 <phoniq> what's the difference between 'let x = something' and 'x <- something' inside a do block?
10:25:26 <AStorm> so you can match on it
10:25:38 <fax> :t _|_
10:25:38 <fasta> phoniq: only one works generally
10:25:40 <lambdabot> parse error on input `|'
10:25:47 <AStorm> :t error
10:25:48 <lambdabot> forall a. [Char] -> a
10:25:49 <fasta> phoniq: easy answer, isn't it?
10:25:56 <AStorm> > _|_
10:25:56 <lambdabot>  Parse error
10:25:57 <phoniq> feh
10:26:00 <ddarius> phoniq: in x <- something, something must have type m a for some Monad m and type a.
10:26:02 <AStorm> > error "foo!"
10:26:03 <lambdabot>  Exception: foo!
10:26:07 <AStorm> hmm
10:26:13 <AStorm> no bottom?
10:26:16 <phoniq> ddarius, that much i got
10:26:19 <littledan> AStorm, if the list is infinte, but the number is finite, it won't be _|_
10:26:22 <phoniq> and in the let case it is different?
10:26:27 <ddarius> Now, x <- return something is very similar, but not the same as let x = something
10:26:32 <AStorm> littledan, nope
10:26:36 <ddarius> phoniq: The let is just a let
10:26:42 <fasta> No, ListT experts around?
10:26:49 <AStorm> it should bottom out, because you can't compare an infinite value with a finite one
10:26:53 <AStorm> bottom propagates up
10:27:07 <fasta> Google: did you mean list haskell?
10:27:14 <fasta> No, I didn't mean that.
10:27:30 <fasta> Google gets a bit too "smart"
10:27:47 <AStorm> fasta, it's stupid heuristics and it shows :>
10:27:56 <fasta> It should just search for what I tell it to search for, not what X millions of other people did.
10:28:10 <fasta> Since there are not X million other people searching for listt
10:28:11 <AStorm> BTW, does someone have OSB matching algorithm description?
10:28:19 <AStorm> (or even implementation in Haskell)
10:28:29 <AStorm> OSB == Orthogonal Sparse Bigram
10:28:41 <AStorm> much like Markov chains
10:28:44 <Maddas> fasta: it does search for what you tell it to search for, doesn't it?
10:28:51 <mrd> @type liftM (head . head)
10:28:52 <fasta> Maddas: no
10:28:53 <lambdabot> forall a (m :: * -> *). (Monad m) => m [[a]] -> m a
10:28:57 <Maddas> oh, hm, apparently not
10:29:06 <fasta> Maddas: I think it used to do that.
10:29:15 <fasta> Maddas: but some idiot changed the behaviour.
10:29:18 <opqdonut> :t lift . liftM
10:29:20 <lambdabot> forall (t :: (* -> *) -> * -> *) a1 r (m :: * -> *). (MonadTrans t, Monad m) => (a1 -> r) -> t ((->) (m a1)) (m r)
10:29:20 <AStorm> fasta, use "ListT"
10:29:23 <Maddas> fasta: Do you have an example?
10:29:31 <AStorm> quotes disable auto-stupidity
10:29:45 <fasta> AStorm: thanks
10:29:58 <fasta> AStorm: I only used that for "two or more words"
10:30:10 <fasta> Maddas: of what?
10:30:52 <Maddas> fasta: I'm confused by the behaviour, but googling for haskell listt does seem to search for listt, though somehow differently than if you use "listt"
10:30:54 * Maddas shrugs :-)
10:33:05 <fasta> But why does the code I posted need two calls to head?
10:33:48 <AStorm> two items?
10:34:17 <AStorm> nested lists?
10:34:29 <fasta> Yes, they are nested lists, but why?
10:34:40 <AStorm> first head gets you the first list
10:34:45 <AStorm> second, the first item of that list
10:34:49 <fasta> That's basic.
10:34:54 <fasta> I don't want to know that.
10:34:55 <AStorm> yep
10:35:02 <fasta> I'
10:35:11 <fasta> d have expected it to return just one list.
10:35:19 <AStorm> what is that zork?
10:35:20 <fasta> Not a nested list.
10:35:26 <fasta> AStorm: it returns a list
10:35:27 <AStorm> runListT can return more than one item
10:35:43 <AStorm> uhm, s/runListT/liftM/
10:35:45 <fasta> AStorm: a list containing [1,2,3,4]
10:35:57 <AStorm> :type liftM
10:36:13 <AStorm> lambdabot, ping
10:36:23 <ari> @bot
10:36:23 <lambdabot> :)
10:36:32 <AStorm> @type liftM
10:36:34 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
10:36:45 <fasta>    lift m = ListT $ do
10:36:45 <fasta>         a <- m
10:36:46 <fasta>         return [a]
10:36:49 <fasta> This is the reason
10:36:52 <AStorm> yes
10:36:54 <ari> :t id
10:36:55 <lambdabot> forall a. a -> a
10:37:13 <fasta> It cannot know that zork already returns a list.
10:37:29 <fasta> Well, it could, but that's now how the system works.
10:37:34 <fasta> not*
10:37:40 <fasta> fasta: thanks
10:37:45 <fasta> fasta: don't mention it.
10:37:51 <AStorm> fasta, you see, you got it yourself :D
10:38:12 <fasta> AStorm: yes, the more Haskell I write the less questions are answerable.
10:38:32 <paolino_> hi, which is a good way to invert a list of lists [[1,2,3],[4,5,6]] -> [[1,4],[2,5],[3,6]] ?
10:38:48 <ari> paolino_: transpose
10:38:55 <AStorm> ari, beat me to it
10:39:00 <ari> > transpose [[1,2,3],[4,5,6]]
10:39:01 <lambdabot>  [[1,4],[2,5],[3,6]]
10:39:07 <paolino_> :t transpose
10:39:09 <lambdabot> forall a. [[a]] -> [[a]]
10:39:23 <paolino_> :)
10:39:29 <AStorm> @botsnack
10:39:30 <lambdabot> :)
10:40:18 <AStorm> really, breakBy should be added to Prelude
10:40:28 <fax> what is breakBy
10:40:37 <AStorm> uhm, wrong
10:40:40 <AStorm> I meant splitBy
10:40:49 <AStorm> much like words
10:40:53 <ihope> So we have guards, case statements, lets, do notation, lambdas, implicit parameters...
10:41:02 <AStorm> ihope, and more :-)
10:41:06 <ihope> Indeed.
10:41:14 <ihope> Heck, we have function declaration notation.
10:41:34 <oerjan> AStorm: last i heard that discussed, the problem was that there were too many different possibilities
10:41:35 <ihope> Oh, and wheres. You can't forget about those. And if, as well...
10:41:44 <fasta> What does guard mean in the state monad?
10:41:54 <ihope> @hoogle guard
10:41:54 <lambdabot> Monad.guard :: MonadPlus a => Bool -> a ()
10:41:55 <lambdabot> Control.Monad.guard :: MonadPlus m => Bool -> m ()
10:41:55 <lambdabot> Language.Haskell.TH.Guard :: data Guard
10:42:05 <AStorm> oerjan, uhm? Just break on an item of list
10:42:08 <ari> @instances MonadPlus
10:42:10 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
10:42:12 <AStorm> example follows
10:42:28 <ihope> fasta: I think guard True = return (); guard False = mzero
10:42:29 <oerjan> whether to keep the delimiter, whether to allow multiword delimiters...
10:42:30 <paolino_> @src transpose
10:42:30 <lambdabot> transpose []             = []
10:42:30 <lambdabot> transpose ([]   : xss)   = transpose xss
10:42:30 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
10:42:37 <ihope> @src Control.Monad.guard
10:42:38 <lambdabot> Source not found. That's something I cannot allow to happen.
10:42:40 <oerjan> whether to group the result
10:42:48 <fasta> ihope: ok, and what is mzero for the state monad?
10:42:56 <oerjan> *multicharacter
10:43:02 <dolio> There is no mzero for State.
10:43:06 <fax> why is tranpose not, apply map list
10:43:10 <dolio> StateT has mzero if the underlying monad does.
10:43:12 <AStorm> oerjan, I suggest dropping the delimiter, multiitem
10:43:19 <AStorm> (not only characters)
10:43:27 <fasta> dolio: right, it was StateT
10:43:52 <AStorm> oerjan, just an extended words
10:43:59 <dolio> Well, then, it means approximately what it does in the underlying monad.
10:44:02 <fax> oh I see why
10:44:06 <dolio> Probably backtracking state changes.
10:44:37 <ihope> instance (MonadPlus m) => MonadPlus (StateT s m)
10:45:04 <oerjan> > let s = "\na\n\nb\c\n\n" in (words s, lines s)
10:45:04 <lambdabot>  Illegal escape sequence
10:45:07 <fasta> oops n e = liftM Prelude.head (do  candidates <- zork e guard (n /= candidates) return candidates)
10:45:17 <oerjan> > let s = "\na\n\nbc\n\n" in (words s, lines s)
10:45:19 <lambdabot>  (["a","bc"],["","a","","bc",""])
10:45:19 <fasta> This is what I intended to write.
10:45:45 <oerjan> AStorm: as you see, lines and words follow different principles
10:45:53 <AStorm> Exactly what I'm after
10:46:01 <ihope> @src words
10:46:01 <lambdabot> words s = case dropWhile isSpace s of
10:46:01 <lambdabot>     "" -> []
10:46:01 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
10:46:09 <AStorm> make two functions, one for multiitem drops
10:46:19 <ihope> words breaks on whitespace?
10:46:20 <AStorm> and one for "one of this items" drops
10:46:26 <AStorm> ihope, yep
10:46:36 <AStorm> *these
10:46:58 <oerjan> and you may note that lines drops a final \n
10:47:10 <AStorm> I consider that a bug :>
10:47:25 <oerjan> that's not a bug the way most files are organized
10:47:42 <AStorm> I'd rather know that it ends with a whitespace
10:47:42 <oerjan> with each line \n-terminated
10:47:42 <ihope> unlines . lines being id would be nice.
10:47:50 <AStorm> it doesn't have to
10:48:15 <fax> :k =>
10:48:17 <lambdabot> parse error on input `=>'
10:48:22 <fax> @_@
10:48:22 <lambdabot> Maybe you meant: . bf ft id pl rc v wn
10:48:29 <oerjan> also, you may want a function that _keeps_ the delimiters, which neither of them does
10:48:48 <oerjan> so you end up with at least 3-4 versions
10:48:51 <AStorm> :k (=>)
10:48:53 <lambdabot> parse error on input `=>'
10:49:00 <AStorm> :t (=>)
10:49:02 <lambdabot> parse error on input `=>'
10:49:09 <AStorm> Nope, syntax.
10:49:29 <oerjan> => is not a type constructor
10:49:38 <ihope> => not being syntax would be nice.
10:49:53 <ihope> Lambdas not being syntax would also be nice. >:-)
10:50:21 <fasta> No, what I wrote was wrong.
10:52:29 <ihope> Are there by any chance any plans to make lambdas not syntax?
10:53:00 <oerjan> ihope: how in the world would you do that? they are binding constructs
10:53:37 <oerjan> their parts don't fit into anything first-class
10:54:00 <oerjan> otoh maybe once you have first-class patterns
10:54:42 <littledan> lambdas not being syntax would require a crazy type system, or untyped macros, wouldn' tit
10:55:10 <ihope> What about first-class patterns?
10:55:51 <littledan> how would those work?
10:55:57 <oerjan> it might still be difficult to parse, now the syntax distinguishes where you have a pattern and where you have an expression
10:56:31 <ihope> Indeed, syntax distinguishing patterns from expressions would be necessary.
10:56:53 <ihope> ...probably.
10:57:15 <oerjan> \ would have to be a kind of "pattern function"
10:58:50 <ihope> Since Haskell has a limitation that can't nicely be removed just by adding stuff, we must abandon it in favor of a completely new language with entirely different syntax to support this.
10:58:52 <ihope> :-P
11:00:30 <moltarx> snap :)
11:00:31 <dolio> There are papers on first-class patterns in Haskell. You don't need to add much, really.
11:00:48 <dolio> I don't find the one I read recently very pretty, though.
11:01:00 <littledan> ihope, I've implemented first class patterns in a different language, though you'd probably hate that language (and the pattern system isn't all that good)
11:01:07 <littledan> dolio, link?
11:01:33 <oerjan> something like Prolog, where just about every language element can be given an operator precedence...
11:01:46 <dolio> Hmm... I'll have to figure out wich of the 50 papers it is first... :)
11:02:15 <littledan> oh yeah, prolog basically has first class patterns, doesn't it
11:02:32 <oerjan> heh, i guess so
11:02:54 <dolio> http://citeseer.ist.psu.edu/337368.html
11:02:55 <ihope> littledan: where is that language?
11:03:00 <lambdabot> Title: First Class Patterns - Tullsen (ResearchIndex)
11:03:07 <oerjan> i don't remember if Mercury (which is typed) has the same syntactic flexibility...
11:03:17 <littledan> ihope, which one, prolog or the other one?
11:03:24 <ihope> littledan: the other one.
11:03:31 <EvilTerran> there's also the idea of (|x -> ...) that's in the Haskell' wiki somewhere ("compositional lambdas" or something, i think)
11:04:12 <dolio> In short, the only thing he says you *need* to add to Haskell is 'Constructor#' as a pattern matcher for thing built with 'Constructor'.
11:04:51 <littledan> I don't want to get too off-topic here, but it's called Factor, a language that's a cross between Forth and Lisp. I wrote about the pattern system at http://useless-factor.blogspot.com/2007/06/concatenative-pattern-matching.html
11:04:53 <lambdabot> Title: Useless Factor: Concatenative pattern matching, http://tinyurl.com/2jyk97
11:05:23 <ihope> dolio: that approach is sort of... not what I had in mind.
11:05:36 <ihope> Not how I was thinking of doing it, I mean.
11:07:55 <littledan> ihope, the thing I linked to doesn't focus very much on the fact that they are first class, but they are
11:08:18 <littledan> (and arbitrarily extensible)
11:11:01 <Syzygy-> > let True ||' _ = True; _ ||' True = True; False ||' False = False in foldr (||') True $ repeat False
11:11:01 <lambdabot>  Improperly terminated character constant
11:11:01 <wli> orejan: Prolog-based languages have far greater pattern flexibility. For instance, equality constraints appear for variables appearing in multiple places in a pattern match, including multiple places on both sides of the match.
11:11:11 <Syzygy-> Huh?
11:11:31 <Syzygy-> > let True || _ = True; _ || True = True; False || False = False in foldr (||) True $ repeat False
11:11:32 <lambdabot>  Exception: <<loop>>
11:12:49 <wli> oerjan: The pattern matches in Prolog are inherently bidirectional in addition to automatically generating such equality constraints.
11:13:02 <oerjan> wli: why are you telling me things i know?
11:13:41 <wli> oerjan: I misread something you wrote earliar.
11:13:44 <EvilTerran> Syzygy-, ' is a word character, not a punctuation character. i think that was the problem.
11:14:01 <Syzygy-> Right.
11:15:22 <oerjan> wli: sorry for being rash :)
11:16:25 <wli> oerjan: No need. I'm not so thin-skinned.
11:17:43 <Syzygy-> roconnor: Congratulations on making a power of 2 in the ICFP contest!
11:18:18 <paolino> is it possible to span a 100 digit number on more lines ?
11:18:24 <littledan> ihope: I think I just found a paper that did waht I did, but in haskell, and much better. It might be what you're interested in: http://citeseer.ist.psu.edu/337368.html
11:18:26 <lambdabot> Title: First Class Patterns - Tullsen (ResearchIndex)
11:18:46 <timthelion> I'm writing a set of unix utilities that require that there be files dependent on other files, and I need a naming convention so that my file copy utility knows what files to copy when copying the parent file.  Does anyone know if, for copying "fname" there would be anything wrong with copying all files of the form .<*>-fname where star is any string
11:19:17 <pjd> does it have to be in the filename?
11:19:35 <pjd> or could it be in a header comment?
11:19:37 <oerjan> > 1\ \2
11:19:37 <lambdabot>  Parse error
11:19:54 <oerjan> hmph
11:20:18 <doserj> read "1\ \2"::Int
11:20:19 <oerjan> apparently that only works for strings
11:20:22 <doserj> > read "1\ \2"::Int
11:20:30 <lambdabot>  12
11:20:31 <timthelion> pjd: I don't think so, because what I'm doing is making it so that the dependant files, are patch files, and older versions of the file.
11:20:37 <oerjan> >_O
11:21:00 <oerjan> oh, i misread
11:21:46 <pjd> timthelion: the BSDs come with a tool to manage dependencies based on headers of the form:
11:21:47 <pjd> # REQUIRE: foo
11:21:47 <pjd> # PROVIDE: bar
11:21:49 <timthelion> pjd: and though what I'm versioning is source, I would then need to have my utilities aware of comment syntax for each type of source
11:22:28 <paolino> oerjan: do I need to respect haskell layout for that ?
11:23:29 <EvilTerran> ah, here's what i was looking for -- http://hackage.haskell.org/trac/haskell-prime/ticket/114
11:23:31 <lambdabot> Title: #114 (introduce lambda-match (explicit match failure and fall-through)) - Haskel ...
11:25:07 <EvilTerran> ^ looks like a great idea to me
11:25:10 <oerjan> paolino: no, see http://haskell.org/onlinereport/syntax-iso.html#layout
11:25:11 <lambdabot> Title: Haskell 98 Syntax
11:25:31 <paolino> ok
11:26:01 <oerjan> particularly, item 1.3 of the bullet list
11:33:37 <fasta> Heh, of all the monads in mtl, I only didn't use Writer, RWS and Reader. Of these I never used RWS.
11:35:35 <fax> deriving MyTypeclass is possible?
11:35:57 <EvilTerran> fax, only in a newtype
11:36:34 <fax> ok
11:36:43 <EvilTerran> "newtype ... = Foo a deriving Bar" creates an instance Bar a => Bar (Foo a) that just passes everything through to the "a" instance
11:37:03 <littledan> in H98, only Eq, Ord, Enum, Bounded, Show, or Read can be in a deriving clause
11:37:12 <EvilTerran> yeah, this is an extension.
11:37:52 <EvilTerran> if you want to write something more general, that would work with data declerations as well, i think you have to roll something involving Template Haskell. it's not generally worth it, tho.
11:40:01 <Saizan> ?hackage derive
11:40:01 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/derive
11:43:56 <JohGro> I have a pattern matching question:
11:45:16 <JohGro> I can do let f 0 = 1; f 2 = 5; f _ = 99 in ghci to define the function pattern matching on an integer
11:45:17 <JohGro> But I can not do the same on a rational number let f (0%1) = 1; f (1%2) = 5; f _ = 99 as this gives me
11:45:19 <JohGro> <interactive>:1:7: Parse error in pattern
11:45:31 <JohGro> Is there a way to do what I want?
11:45:54 <dcoutts_> JohGro: not with pattern matching, you can't pattern match on rationals iirc
11:46:14 <dcoutts_> you can test them for equality of course
11:46:25 <JohGro> Ok, so would guards be  a next best option?
11:46:31 <dcoutts_> yep
11:46:37 <JohGro> OK, thanks.
11:46:50 <dcoutts_> quick survey about what this new cabal flag should be called...
11:46:55 <dcoutts_> Cabal can now hyperlink haddock docs to the sources, the original author had it as: ./setup haddock --hscolour
11:47:17 <dcoutts_> but that seems to say more about the implementation than the intention of the user
11:47:37 <dcoutts_> I was thinking of making it: ./setup haddock --hyperlink-source
11:47:45 <dcoutts_> anyone else with an opinion?
11:48:08 <dcoutts_> the point is that it actually generates syntax highlighted sources as html
11:48:12 <dcoutts_> and hyperlinks to that
11:48:37 <dcoutts_> it links on a per-module and per-variable basis to named anchors in the html
11:48:38 <EvilTerran> so it doesn't generate coloured sources without the flag, and it does with?
11:48:46 <dcoutts_> correct
11:49:09 <bos> i like that new name.
11:49:13 <dcoutts_> (at the moment it doesn't actually generate coloured sources because it doesn't use a css file, but we can probably fix that)
11:49:37 <dcoutts_> bos: ok, that'll do for me :-)
11:50:16 <dcoutts_> to have it actually colour it by default we need some way of making hscolour give us the default hscolour.css file
11:50:22 <dcoutts_> so we can copy it to the right place
11:50:40 <dcoutts_> otherwise there's nowhere to get the hscolour.css file from
11:50:54 <bos> malcolmw loves getting patches
11:50:57 <dcoutts_> at the moment it's easy to set a css file, but no way to get the default one
11:51:09 <bos> i bet he
11:51:11 <dcoutts_> I've sent him a couple hscolour patches, but not one solving that problem
11:51:21 <bos> ugh. bet he'd take one that printed the path to the default css file.
11:51:58 <dcoutts_> bos: mm, think that's the nicest? c2hs has a --copy-thigie flag
11:52:39 <dcoutts_> or what might be cool is to generate the .css file from the .hscolour spec that it uses for all the other output formats
11:53:15 <bos> --copy-thingie would of course work.
11:53:49 <dcoutts_> for all formats except 'css' it uses "a configuration file called .hscolour in the current directory."
11:54:36 <dcoutts_> it'd be nice if it could use that for css too, ie generate a css file from the .hscolour file (for which there exists a default compiled into HsColour)
11:54:45 <fasta> runListT (do  candidate <- lift (return [1,2,3]) guard (candidate == 2) return candidate)
11:55:26 <fasta> This works, but instead of (return [1,2,3]) I would like to have a custom function returning a FooMonad [Int]
11:55:43 <Saizan> dcoutts_: (still on gtkstatusicon binding), apiGen had inserted this pragmas {-# DEPRECATED onActivate "instead of 'onActivate obj' use 'on obj activate'" #-}, but i can't find "on" anywhere, is it yet to be implemented?
11:55:51 <fasta> When I try this however I get that there is no instance Num [t]
11:56:15 <dcoutts_> Saizan: oh yeah, I've not added that yet, it'll be in this dev cycle
11:56:20 <fasta> Anyone with a suggestion?
11:57:13 <Saizan> dcoutts_: so i leave the pragma there and add the activate signal?
11:58:13 <dcoutts_> Saizan: yes. Though actually we've not entirely decided if we'll use 'activate' or 'statusIconActivate'. Annoying namespace issues.
12:00:07 <ari> Good evening, #haskell. I vaguely recall reading somewhere that (:) is not just a constructor for [] but a keyword... is there any reason for this other than that it can't be defined in a datatype declaration?
12:01:20 <kpreid> perhaps so that both (:) and [] (empty list constructor) can't be rebound?
12:01:43 <kpreid> (whereas otherwise, you could rebind (:) but not [] unless [] were made part of data syntax, which would be ...funny)
12:05:22 <fasta> Oh, finally.
12:05:44 <fasta> The only way to convert a m [a] to a ListT m a is:.....?
12:05:49 <fasta> Haskell Quiz Time.
12:06:31 <fasta> @seen wli
12:06:31 <lambdabot> wli is in #haskell-soc, #haskell-blah and #haskell. I last heard wli speak 50m 6s ago.
12:06:54 <fasta> wli: an exercise for you ^^
12:07:55 <int-e> @type liftM head . lift
12:07:57 <lambdabot> forall a (m :: * -> *) (t :: (* -> *) -> * -> *). (Monad (t m), MonadTrans t, Monad m) => m [a] -> t m a
12:08:22 <Saizan> ?type ListT
12:08:24 <lambdabot> forall (m :: * -> *) a. m [a] -> ListT m a
12:08:35 <Saizan> fasta: ListT?
12:08:39 <fasta> Saizan: yes
12:08:51 <fasta> int-e: that's cheating
12:09:05 <fasta> int-e: but according to spec.
12:09:31 <fasta> Better spec: Convert m [a] to a ListT m a without losing information
12:11:40 <fasta> shapr: bounce around, the channel is occupied ;0
12:12:49 <ihope> @index :+
12:12:49 <lambdabot> Data.Complex
12:16:13 <ihope> @src Data.Complex.Complex
12:16:13 <lambdabot> Source not found. stty: unknown mode: doofus
12:16:16 <ihope> Woot.
12:18:52 <fasta> Saizan: heh, I thought you were asking what monad, but you had the right answer.
12:19:04 <paolino> @pl map (read . (:[]))
12:19:04 <lambdabot> map (read . return)
12:20:06 <Saizan> fasta: ah :D
12:20:18 <Saizan> fasta: i should be more explicit perhaps
12:20:28 <nuffer> can someone point me towards info on getting GHC to output C code?
12:20:38 <fasta> Saizan: I just didn't expect someone to answer that fast, I guess.
12:20:54 <fasta> Saizan: you have used ListT before?
12:20:56 <nuffer> and on what sort of C code it's outputting (I'm interested in targetting non-standard platforms)
12:22:01 <Saizan> fasta: i've toyed with it yesterday reading an old sigfpe post
12:22:11 <nuffer> or even info on GHC's Core/STG?
12:22:45 <fasta> Saizan: I have a bias for thinking constructors are not part of the API.
12:23:06 <fasta> Saizan: well, for *T code
12:23:07 <Saizan> nuffer: there should be a flag
12:24:05 <Saizan> fasta: and you're probably right, but if there's not an equivalent primitive..
12:25:19 <Nopik> re
12:25:32 <byorgey> hey Nopik, how goes it?
12:26:26 <Nopik> byorgey: i suspended reading at the moment when i left channel few hours ago (went to see some madrit places), now i'm resuming reading those tutorials
12:26:43 <Nopik> anyone from madrid here? :)
12:26:59 <byorgey> ah, excellent.
12:27:34 <kuribas> What is the best way to get the before last element of a list?
12:27:58 <kuribas> last . init ?
12:29:02 <byorgey> kuribas: sure, that works
12:29:05 <nomeata> kuribas: sounds good enough
12:39:01 <timtheli`> I have a recursive function which walks up a directory tree, is there something I need to do to prevent it from following symlinks that would cause this to become an infinite recursion?
12:39:41 <opqdonut> well you could for example not follow links at all
12:41:51 <AStorm> timtheli`, not follow links and use lstat
12:42:05 <AStorm> or not follow directory links
12:42:18 <AStorm> (lstat vs stat)
12:42:52 <timtheli`> where are there functions dealing with the designation of a directory as a symlink? they are not in System.Directory
12:43:29 <AStorm> lstat...
12:43:31 <Nopik> heh.. i thought i know haskell a little, but when i'm reading Control/Monad/Reader.hs it is (almost) all greek to me, even though it is documented
12:43:48 * Nopik goes back to the tutorial
12:43:49 <Heffalump> I find it a bit hard to read too
12:44:00 <Heffalump> given that it abstracts everything behind a typeclass
12:44:20 <magnus__> If I do this on the ghc repl: endo <- readFile "endo.dna", why is the contents of endo printed out?
12:44:29 * timtheli` sugests reading the example code at the bottom first
12:44:29 <magnus__> can that be avoided?
12:44:42 <Heffalump> magnus__: if you find out, let me know :-)
12:44:51 <Saizan> there's a flag for that
12:45:49 <Saizan> which i can never remeber..
12:45:53 <magnus__> can't see it in :help
12:46:12 <Nopik> in this: test = do theVarA <- asks vara ; lift . putStrLn $ show theVarA `runReaderT` initState             where 'do' is ended?
12:46:22 <Nopik> i suppose that whole 'do' is first argument to runReaderT?
12:46:24 <byorgey> Nopik: the more Haskell I learn, the more I realize I don't know =)
12:46:29 * shapr bounces on fasta 
12:46:56 <byorgey> Nopik: that whole thing is part of the 'do'
12:47:02 <Nopik> hm
12:47:03 <timtheli`> AStorm: where is this lstat function?
12:47:09 <Saizan> magnus__: found, -fno-print-bind-result
12:47:18 <byorgey> Nopik: (my first comment was re: your earlier one about Reader.hs being Greek to you)
12:47:23 <AStorm> timtheli`, it's a C function, trying to find a haskell equivalent
12:47:42 <oerjan> Nopik: nope, at most from the last semicolon, depending on precedence
12:47:48 <Nopik> hm, ghc cannot find Control.Monad.Reader ?
12:48:00 <Heffalump> -package mtl
12:48:23 <oerjan> (is argument of runReaderT)
12:48:28 <AStorm> timtheli`, http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Files.html
12:48:30 <lambdabot> http://tinyurl.com/323y98
12:48:33 <Nopik> unknown package mtl?
12:48:57 <magnus__> Siazan: thanks! where did you find it?
12:48:59 <byorgey> Nopik: you have to install it separately
12:49:06 <Nopik> byorgey: nice
12:49:07 <byorgey> Nopik: what system are you on?
12:49:14 <Nopik> i thought that this one is bundled
12:49:27 <byorgey> Nopik: it probably should be, but it isn't
12:49:34 <AStorm> timtheli`, getSymbolicLinkStatus
12:49:43 <timtheli`> AStorm: thanks,  I did not know that there was both a System.Directory and a System.Posix to look at
12:49:59 <oerjan> Nopik: you can do: flip runReaderT initState $ if you want it first
12:50:54 <AStorm> timtheli`, or even isSymbolicLink
12:51:03 <JohGro> :pl \f g x y -> g (f x) (f y)
12:51:33 <timtheli`> AStorm: any idea if I can import that without breaking the program for windows?
12:51:35 <Saizan> magnus__: http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html
12:51:37 <lambdabot> Title: 4.17. Flag reference, http://tinyurl.com/ydk2e6
12:51:40 <opqdonut> ?pl \f g x y -> g (f x) (f y)
12:51:40 <lambdabot> flip =<< ((flip . ((.) .)) .) . flip (.)
12:51:41 <byorgey> Nopik: apt-get install libghc6-mtl-dev on Debian/Ubuntu
12:51:44 <AStorm> timtheli`, no idea
12:51:44 <opqdonut> JohGro: there ya go
12:51:57 <JohGro> Ahh, thanks!
12:52:03 <AStorm> I think that these should work under Windows and not be marked unix
12:52:03 <magnus__> Saizan: k, cheers
12:52:10 <JohGro> But not an elegant answer
12:52:15 <moonlite_> JohGro: thats the `on`-operator right?
12:52:16 <opqdonut> JohGro: but the usual idiom is: (f `on` g) x y = g x `f` g y
12:52:20 <AStorm> windows does have stat
12:52:34 <byorgey> JohGro: if you flip f and g I think it's just liftM2
12:52:48 <AStorm> or maybe not :P
12:52:49 <byorgey> @pl \f g x y -> f (g x) (g y)
12:52:50 <lambdabot> join . ((flip . ((.) .)) .) . (.)
12:52:54 <byorgey> erm...
12:53:04 <byorgey> never mind =)
12:53:05 <AStorm> really clean :>
12:53:14 <AStorm> @type liftM2
12:53:15 <JohGro> I used "maximumBy (\m n -> compare (f n) (f m))" several times, and wanted something more elegant.
12:53:17 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:53:34 <byorgey> @pl \f g h x -> f (g x) (h x)
12:53:35 <lambdabot> liftM2
12:53:35 <Nopik> byorgey: i'm gentoo ;) but it installed easily, too
12:53:41 <byorgey> ah, that's what I'm thinking of
12:53:43 <opqdonut> JohGro:
12:53:46 <opqdonut> ?src comparing
12:53:46 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
12:53:47 <byorgey> that's a bit different
12:53:50 <opqdonut> bah
12:53:56 <byorgey> Nopik: ok, good
12:53:56 <Nopik> now, example from tutorial borks ghc - it says that some types do not match ;p
12:54:04 <opqdonut> anyways, that's "comparing f"
12:54:35 <byorgey> Nopik: maybe paste the code on hpaste?
12:55:26 <JohGro> opqdonut: hoogle did not find any function named comparing, it seems.
12:55:35 <oerjan> Nopik: not to forget the error message
12:55:53 <oerjan> opqdonut: Data.Ord.comparing
12:55:53 <AStorm> JohGro, what is that "compare"?
12:56:12 <AStorm> Ah, now I know.
12:56:13 <oerjan> @src Ord
12:56:14 <lambdabot> class  (Eq a) => Ord a  where
12:56:14 <lambdabot>     compare      :: a -> a -> Ordering
12:56:15 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
12:56:17 <lambdabot>     max, min         :: a -> a -> a
12:57:18 <AStorm> Hmm, how does one conditionally import a module in Haskell? Is that possible at all?
12:57:37 <EvilTerran> ?type \f -> curry $ uncurry compare . join (***) f
12:57:39 <lambdabot> forall b c. (Ord c) => (b -> c) -> b -> b -> Ordering
12:57:58 <JohGro> I would like a function of type (Ord b) => (a -> b) -> a -> a -> Ordering, but I did not find a nice way.
12:58:08 <Lemmih> AStorm: Not possible.
12:58:10 <JohGro> I have never seen (***) before...
12:58:15 <AStorm> ?type (***)
12:58:16 <JohGro> (understood rather)
12:58:17 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
12:58:18 <oerjan> AStorm: not in pure Haskell
12:58:25 <byorgey> JohGro: it's from Control.Arrow.
12:58:27 <AStorm> oerjan, :-/
12:58:38 <EvilTerran> (f *** g) (x, y) = (f x, g y)
12:58:42 <byorgey> *** actually is pretty easy to understand
12:58:47 <EvilTerran> @src (***)
12:58:47 <lambdabot> f *** g = first f >>> second g
12:58:53 <oerjan> AStorm: there is a variant of the C preprocessor adapted for Haskell.
12:58:55 <AStorm> @src (>>>)
12:58:56 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
12:59:02 <AStorm> :>
12:59:03 <JohGro> @src first
12:59:03 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
12:59:12 <EvilTerran> (>>>) = flip (.)
12:59:19 <EvilTerran> first f (x,y) = (f x, y)
12:59:24 <byorgey> both >>> and first are part of the Arrow class, so the implementation depends on the instance
12:59:33 <EvilTerran> second f (x,y) = (x, f y)
12:59:37 <AStorm> @src Arrow
12:59:38 <lambdabot> class Arrow a where
12:59:38 <lambdabot>     arr, pure   :: (b -> c) -> a b c
12:59:38 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
12:59:38 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
12:59:38 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
12:59:40 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
12:59:42 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
12:59:43 <byorgey> but EvilTerran has posted the definitions for the (->) instance above =)
12:59:47 <AStorm> long one
13:00:01 <EvilTerran> @src (->) (>>>)
13:00:02 <lambdabot> f >>> g = g . f
13:00:06 <EvilTerran> @src (->) first
13:00:06 <lambdabot> first f = f *** id
13:00:13 <EvilTerran> @src (->) (***)
13:00:13 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
13:00:15 <EvilTerran> etc
13:00:27 <byorgey> there's a good introduction to Arrows on the wiki
13:00:29 <AStorm> oh, didn't know you can do that
13:00:51 <oerjan> AStorm: you only need to define a couple of the Arrow methods, i think
13:01:18 <byorgey> http://haskell.org/arrows/
13:01:19 <lambdabot> Title: Arrows: A General Interface to Computation
13:01:24 <AStorm> the arrows sound like generalisations of Unix pipes
13:01:25 <EvilTerran> AStorm, in general, you can look up instance-specific functions with @src <instance> <method>
13:01:33 <EvilTerran> @src [] mzero
13:01:33 <lambdabot> mzero = []
13:01:39 <EvilTerran> @src Maybe return
13:01:39 <lambdabot> return              = Just
13:01:41 <EvilTerran> etc
13:01:41 <byorgey> AStorm: they are, sort of
13:01:58 <oerjan> "Any instance must define either arr or pure (which are synonyms), as well as >>> and first."
13:02:36 <JohGro> Ok. Thanks very much, I feel I need to take a timeout and think before continuing.
13:03:05 <EvilTerran> but, to go back to my original example (\f -> curry $ uncurry compare . join (***) f), join (***) f = (f *** f) = \~(x,y) -> (f x,f y)
13:03:41 <byorgey> EvilTerran: yeesh
13:03:51 <AStorm> that can be made a lot shorter
13:04:05 <byorgey> EvilTerran: I grok that, but don't you think that's overkill? =)
13:04:07 <EvilTerran> hey, it's called pointless for a reason
13:04:13 <byorgey> hehe
13:04:23 <AStorm> ?type (f *** f)
13:04:25 <lambdabot> Not in scope: `f'
13:04:25 <lambdabot>  
13:04:25 <lambdabot> <interactive>:1:7: Not in scope: `f'
13:04:31 <AStorm> uhm
13:04:37 <EvilTerran> and yes, you could just write (\f x y -> f x `compare` f y)
13:04:54 <byorgey> @type \f -> (f *** f)
13:04:56 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
13:05:05 <Saizan> type comparing
13:05:08 <Saizan> ?type comparing
13:05:09 <AStorm> isn't that just (>>>)?
13:05:10 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
13:05:23 <byorgey> AStorm: no.
13:05:27 <EvilTerran> that looks nicer if you call the arrow "~>" instead of "a"
13:05:33 <byorgey> AStorm: f *** g performs f and g "in parallel"
13:05:52 <AStorm> ahh
13:05:53 <byorgey> whereas f >>> g does them "in series"
13:05:57 <AStorm> and >>> is sequential
13:06:00 <byorgey> right
13:06:02 <JohGro> I think I will stick to that solution ((\f x y -> f x `compare` f y)) and look at the rest again later, thanks again all, this channel really is as good as the commercials (on haskell-cafe) say.
13:06:03 <EvilTerran> > (***) :: b ~> c -> (b,b) ~> (c,c)
13:06:04 <lambdabot>  Parse error
13:06:08 <byorgey> there are nice pictures at http://haskell.org/arrows/
13:06:08 <lambdabot> Title: Arrows: A General Interface to Computation
13:06:09 <AStorm> I wonder if that's currently implemented in a multithreaded way
13:06:20 <Saizan> JohGro: you can use comparing f
13:06:27 <nominolo> > sortBy (comparing length) [[],[1,2,3],[1],[4..10]]
13:06:28 <lambdabot>  [[],[1],[1,2,3],[4,5,6,7,8,9,10]]
13:06:44 <EvilTerran> but that's an extension, unfortunately.
13:06:57 <EvilTerran> @src comparing
13:06:57 <lambdabot> Source not found. Wrong!  You cheating scum!
13:06:59 <AStorm> It's not, it's from Data.Ord
13:07:03 <JohGro> extension?
13:07:06 <AStorm> @src Data.Ord.comparing
13:07:06 <lambdabot> Source not found. I feel much better now.
13:07:10 <AStorm> hmm
13:07:11 <fasta> How easy is it to parallelize mapM_ <action> in current GHC?
13:07:21 <EvilTerran> JohGro, type variables called "~>" is an extension, i mean
13:07:23 <JohGro> Is is in some other module, or not in my normal ghc library?
13:07:35 <Saizan> ?index comparing
13:07:36 <lambdabot> bzzt
13:07:38 <fasta> I.e. can you replace it by pMapM_ <action>?
13:07:42 <AStorm> @hoogle comparing
13:07:43 <lambdabot> No matches found
13:07:46 <AStorm> ?
13:07:49 <Saizan> JohGro: it's in Data.Ord iirc
13:07:54 <AStorm> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Ord.html#v%3Acomparing
13:07:56 <lambdabot> http://tinyurl.com/2fxrex
13:08:01 <fasta> Where pMapM_ is a pseudo-operation.
13:08:29 <Lemmih> fasta: There's no standard function for that. You can write it yourself, though.
13:09:01 <Saizan> fasta: it will be hard to do the sequence_ in parallel i think
13:09:14 <fasta> Lemmih: but.. don't I need to lock my data structures then?
13:09:18 <JohGro> Yes, I see it in data.ord now, I misssed it as hoogle did not seem to know it.
13:09:21 <fasta> Lemmih: i.e. a non-local change?
13:09:50 <nominolo> hoogle doesn't know about a lot of things, sadly
13:09:56 <Lemmih> fasta: I don't understand the question.
13:10:28 <fasta> Lemmih: can one write a function pMapM_ with the same semantics as mapM_ as a drop in replacement for mapM_?
13:10:43 <Nopik> ok, this one: test = do theVarA <- asks vara ; lift . putStrLn $ show theVarA; `runReaderT` initState         how to transform it to >>= version? especially with runReaderT as prefix, not infix?
13:10:44 <fasta> Lemmih: (but that works in paralell)
13:11:06 * EvilTerran -> restarting X
13:11:18 <Lemmih> fasta: More or less, yes.
13:11:55 <Nopik> i see, that "runReaderT (asks vara) initState" works, but it is very simplified ;p
13:11:56 <byorgey> runReaderT (asks vara >>= lift . putStrLn . show) initState
13:12:17 <fasta> That's nice... so if anyone wants a nice blog posting subject...
13:12:22 <fasta> ^^ there it is.
13:12:25 <monochrom> How to parallel this, and what is its semantics? pMapM_ modify [ (+ 1), (+ 1), (+ 1) ]  in Control.Monad.State
13:12:27 <Nopik> byorgey: thanks
13:12:51 <byorgey> lift . putStrLn . show gets applied to the result of asks vara
13:13:14 <fasta> monochrom: Is that pseudo syntax?
13:13:27 <byorgey> Nopik: sure =)
13:13:55 <Nopik> byorgey: the whole (asks.. ) need a monad to run? and this is what runReaderT does? run the argument over initState?
13:13:57 <oerjan> Nopik: as i said above, you can do flip runReaderT initState to get it first
13:14:22 <Nopik> oerjan: yeah, i just want to understand their inner mechanisms
13:14:33 <Lemmih> fasta: I was assuming IO to be the monad in question.
13:14:37 <Nopik> oerjan: as my program do consist of this single line, i do not need any flip :)
13:14:45 <oerjan> ok
13:14:49 <Nopik> (ok, almost this line :D)
13:14:52 <fasta> Lemmih: I wasn't
13:15:05 <fasta> Lemmih: I was thinking of State
13:15:23 <byorgey> Nopik: (runReaderT m initState) takes the monadic computation m and runs it with initState as the state.
13:15:46 <Lemmih> fasta: A generic solution is not possible.
13:15:55 <fasta> Lemmih: where the function given to pMap_ touches different parts of the structure I am playing with
13:16:03 <byorgey> Nopik: I'm not sure I understand your first question.
13:16:15 <fasta> Lemmih: i.e. it are independent computations.
13:16:36 <Nopik> byorgey: is (asks vara >>= lift . putStrLn . show) is of type ReaderT r m a ? how come?
13:16:57 <Lemmih> fasta: You could go with the split/merge approach.
13:16:57 <Heffalump> @type asks vara >>= lift . putStrLn . show
13:17:06 <lambdabot> Not in scope: `vara'
13:17:12 <Heffalump> @type \vara -> asks vara >>= lift . putStrLn . show
13:17:14 <lambdabot> forall r a (t :: (* -> *) -> * -> *). (MonadTrans t, Show a, MonadReader r (t IO)) => (r -> a) -> t IO ()
13:17:36 <fasta> Lemmih: what do you mean?
13:17:52 <byorgey> Nopik: essentially, yes.
13:18:05 <oerjan> @type \vara -> asks vara >>= liftIo . print
13:18:06 <Lemmih> fasta: Execute the actions in parallel and then merge their resulting states.
13:18:07 <lambdabot> Not in scope: `liftIo'
13:18:08 * Heffalump looks confused by the t
13:18:12 <oerjan> @type \vara -> asks vara >>= liftIO . print
13:18:14 <lambdabot> forall r a (m :: * -> *). (MonadIO m, Show a, MonadReader r m) => (r -> a) -> m ()
13:18:35 <Nopik> ah, because asks produce monad
13:18:46 <Nopik> thats why >>= applies and a result is a monad too
13:18:52 <byorgey> Nopik: right, the asks function is part of the MonadReader class.
13:19:07 <byorgey> Nopik: right.
13:20:04 <byorgey> Nopik: (asks f) reads the state from the enclosing monad, and returns the result of applying f to it.
13:20:22 <fasta> Lemmih: Hmm, that doesn't map to my problem I think. Consider an n-ary tree. Suppose you want to branch in all n-directions at the same time. The state is the tree.
13:20:34 <chrismbrown_> beelsebob: ping
13:20:50 <fasta> Lemmih: the action would be to replace the value in the node by a random number.
13:20:55 <byorgey> Heffalump: why are you confused by the t?
13:21:54 <Nopik> how can i define new datatypes in ghci? is this possible?
13:22:00 <ddarius> no
13:22:03 <Lemmih> fasta: How do you get the random numbers?
13:22:17 <byorgey> Nopik: unfortunately, no. =P
13:22:22 <Nopik> too bad ;(
13:22:24 <araujo> hello
13:22:28 <ddarius> You could Church encode them...
13:22:36 <byorgey> Nopik: just put them in a file and load the file into ghci.
13:22:37 <fasta> Lemmih: I don't care. You can choose.
13:22:43 <byorgey> ddarius: haha =)
13:23:12 <fasta> Lemmih: replacing everything by 1 would be OK too.
13:23:41 <Lemmih> fasta: Why do you want to use a state monad?
13:24:05 <fasta> Lemmih: because I don't like to pass around state by hand.
13:24:16 <fasta> Lemmih: which, AFAIK, is the reason they exist,
13:24:18 <fasta> .
13:24:23 <shapr> yarrgh!
13:24:25 <Lemmih> fasta: What state do you have?
13:25:00 <fasta> Lemmih: it's a graph based on DiffArray
13:25:12 <Nopik> asks vara :: (MonadReader MyState m) => m Int
13:25:17 <Nopik> how to understand this?
13:25:26 <Nopik> vara is :: MyState -> Int of course
13:25:43 <Lemmih> fasta: Why do you need the state if you just want to replace nodes in a tree with static values?
13:25:47 <Nopik> asks vara produce monad containing Int, I already learned that ;p
13:25:57 <fasta> Lemmih: ...
13:26:22 <fasta> Lemmih: Maybe because it's part of a larger computation?
13:26:38 <fasta> Lemmih: and it are not static values in my application.
13:26:39 <byorgey> Nopik: what are you still confused by?
13:27:06 <fasta> Lemmih: All I know is that if I had a machine with n processors all having access to the memory in parallel I could make it n times faster
13:27:13 <Lemmih> fasta: So you want to replace nodes with some value that you get from the state? And replacing a node also updates the state?
13:27:24 <Nopik> byorgey: it seems, that i do not understand context declaration.. the whole thing in () confuses me
13:27:31 <Lemmih> fasta: State makes it difficult to run things in parallel.
13:27:46 <fasta> Lemmih: replacing a node updates the state, but not the part the other processors would need.
13:28:08 <fasta> Lemmih: ok... so how is all this multi-core business going to scale up for larger programs?
13:28:09 <Lemmih> fasta: Then split the state, run the nodes in parallel and merge the result.
13:28:17 <Nopik> byorgey: so, the above is: asks vara :: m Int which means, that asks vara produce monad, under some conditions.. and those conditions are written like this: (MonadReader MyState m)... which I do not know how they work
13:28:58 <byorgey> Nopik: right, you're almost there.  basically (MonadReader MyState m) is declaring some restrictions on m, since otherwise m could be any type
13:29:01 <fasta> Lemmih: if the state is a graph, splitting it takes more work then traversing it.
13:29:07 <byorgey> @info MonadReader
13:29:07 <lambdabot> MonadReader
13:29:10 <fasta> Lemmih: and putting it back together.
13:29:12 <byorgey> @src MonadReader
13:29:12 <lambdabot> Source not found. It can only be attributed to human error.
13:29:36 <byorgey> Nopik: well, anyway, it means that the combination of MyState and m have to be an instance of MonadReader.
13:29:47 <byorgey> Nopik: do you know about type classes?
13:29:51 <Nopik> byorgey: ok, i suspected thing like this
13:30:03 <fasta> Lemmih: If that's really how bad the compilers are, Haskell multi-core will never be a great success.
13:30:04 <Lemmih> fasta: If you can't guarantee that running it in parallel won't mess things up then you're not gonna run things in parallel.
13:30:10 <Nopik> byorgey: well, yesterday i would say: "probably yes".. now i am not so sure ;)
13:30:19 <fasta> Lemmih: I can guarantee that
13:30:31 <Lemmih> fasta: How so?
13:30:41 <Nopik> byorgey: i'm afraid that i still do not have a grip of a concept of 'computation inside a monad'
13:30:42 <fasta> Lemmih: Because that's the nature of the computation.
13:30:51 <Lemmih> fasta: That's not enough.
13:30:57 <byorgey> Nopik: well, don't feel bad, the MTL will stretch your understanding of type classes etc. quite far =)
13:31:00 <fasta> Lemmih: what is?
13:31:09 <Lemmih> fasta: We need static guarantees.
13:31:17 <Nopik> byorgey: i.e. i see do expression, i know that it directly relates to >>= version, but still something is missing
13:31:21 <Philippa> Nopik: think of it in the same way you might "computation in C" or "computation in Java"
13:31:21 <fasta> Lemmih: and how do I communicate that guarantree?
13:31:30 <fasta> guarantee*
13:31:58 <Nopik> Philippa: what do you mean?
13:32:22 <Lemmih> fasta: By making it impossible for the nodes to update each others state.
13:32:23 <Nopik> byorgey: actually, i am still wondering what 'instance' is for ;p
13:32:32 <Nopik> byorgey: as it seem superfluous to me
13:33:03 <byorgey> Nopik: well, if you delete that word from my sentence it still basically means the same thing =)
13:33:50 <byorgey> Nopik: a type class specifies certain functions that must be defined for a given type in that class, right?
13:34:08 <Lemmih> fasta: No Haskell compiler (nor any other compilers) will ever run an algorithm in parallel if they can't guarantee it'll work. This is in no way whats keeping Haskell from scaling.
13:35:22 <Philippa> Nopik: imagine that monads are different languages
13:35:34 <Philippa> (there's a slightly difficult to pin down sense in which they /are/)
13:35:44 <SamB> I was going to say
13:35:44 <Lemmih> fasta: What you said is comparable to "Haskell will never be a success if it can't solve the halting-problem."
13:35:44 <Philippa> then "a computation in IO" makes sense, right?
13:35:57 <SamB> why do you need your imagination to concieve that ;-)
13:35:58 <fasta> Lemmih: in C you can say: "trust me this works in parallel"
13:36:26 <Lemmih> fasta: So you can in Haskell, just use mutable variables.
13:36:36 <SamB> Haskell does solve the halting problem.
13:36:41 <SamB> > let x = x in x
13:36:44 <lambdabot>  Exception: <<loop>>
13:36:49 <beelsebob> chrismbrown_: pong
13:36:49 <Philippa> <fasta> Lemmih: All I know is that if I had a machine with n processors all having access to the memory in parallel I could make it n times faster <- *hah*
13:36:54 <Lemmih> > let x () = x () in x ()
13:36:55 <lambdabot>  Exception: <<loop>>
13:37:03 <SamB> it's limited, but still fairly good
13:37:10 <fasta> Philippa: hah?
13:37:14 <olsner> SamB: how's that solving the halting problem?
13:37:15 <chrismbrown_> beelsebob: are you getting my messages through the pm?
13:37:20 <Lemmih> Ah, it has gotten smarter.
13:37:21 <fasta> Philippa: to theoretical?
13:37:21 <Nopik> Philippa: i dont get it ;)
13:37:30 <beelsebob> o.O
13:37:30 <beelsebob> no
13:37:30 <fasta> Philippa: too*
13:37:32 <SamB> olsner: it's only a partial solution
13:37:35 <Philippa> there aren't many problems that's true for given any value of n much above 1
13:37:38 <beelsebob> two secs
13:37:39 <chrismbrown_> beelsebob: are you on MSN then?
13:37:43 <SamB> olsner: the compiler has proved that that program will *not* halt
13:37:48 <beelsebob> am now :P
13:37:56 <fasta> Philippa: define much
13:37:57 <monochrom> Eh, someone doesn't understand monads? It's perfectly ok! No one understands monads or numbers, we can only claim we somewhat know how to use them. :)
13:38:01 <SamB> at least, I assume it has
13:38:06 <Philippa> Nopik: okay, you see this broomhandle? I'm about to use it to engage in some IO with you until you understand :-)
13:38:07 <Nopik> now, the bit which puzzless me is that: asks vara produces monad containing Int.. but you cannot get this Int value until you run the expression over some monad
13:38:12 <SamB> some of those are only at runtim,e
13:38:20 <olsner> SamB: aah, okay! I just thought <<loop>> was the equivalent of out-of-stack ;-)
13:38:21 <byorgey> Nopik: ok, good question.
13:38:29 <Nopik> so, the result of asks vara should expect some argument
13:38:34 <byorgey> Nopik: actually, asks vara produces a computation
13:38:41 <fasta> Philippa: er many
13:38:45 <byorgey> Nopik: it doesn't actually *do* the computation yet
13:38:51 <Nopik> byorgey: yes, i figured it out
13:38:59 <Nopik> byorgey: but this computation requires argument
13:39:04 <SamB> anyway, I suppose the issue is that the compiler and it's RTS have determined that the program isn't going to terminate
13:39:10 <byorgey> Nopik: right.
13:39:22 <byorgey> Nopik: in the case of MonadReader it does.
13:39:29 <Nopik> byorgey: so, why type of asks vara is just 'm a' ?
13:39:38 <Nopik> hm, m Int in this case
13:39:47 <magnus__> olsner: loop happens at runtime when a thunk being forced forces itself
13:39:57 <Philippa> Nopik: there'll be a function to "run" the computation and that will take the argument
13:39:58 <byorgey> Nopik: here, 'm Int' means 'a computation which, when run, produces an Int'.
13:40:26 <magnus__> olsner; oh wait, that's something else. nevermind me
13:40:42 <Philippa> fasta: let me rephrase then - CPUs are faster than RAM, what's your specific problem that touches RAM little enough that you're nowhere near being bottlenecked by RAM speeds?
13:40:49 <Nopik> byorgey: can it happen, that something of type m Int requires 2 arguments? (i.e. 2 monads)?
13:41:11 <monochrom> "requires 2 arguments" != "2 monads"
13:41:12 <Nopik> byorgey: and, does monad always mean a 'computation which have to be runned'?
13:41:13 <fasta> Philippa: ok, so you found it a theoretic problem.
13:41:35 <Philippa> fasta: no, more that I'm skeptical about what your actual problem is
13:41:37 <fasta> Philippa: yes, it is theoretic... now.. but that might change.
13:41:55 <msouth> damn, spj is a good speaker
13:41:59 <fasta> Philippa: there would be little point in explaining it, since it takes more than half an hour to do so.
13:42:02 <byorgey> Nopik: your first question is worded strangely, but I think the answer is yes.  there could be a monadic computation requiring two arguments to "get things started"
13:42:27 <Philippa> some do
13:42:34 <Nopik> byorgey: yes, this is what i asked about.. and the weird words come from my little knowledge of haskell ;)
13:42:44 <Philippa> StateT (StateT ...), for example :-)
13:42:50 <byorgey> Nopik: as for your second question, that can be a useful way to think about it, although it's not the whole story
13:42:57 <Nopik> byorgey: it is hard to ask correctly about something if you do not know what you are asking about ;D
13:43:04 <Philippa> fasta: if there's that little interference then data parallel haskell should work a treat, no?
13:43:04 <byorgey> Nopik: yes, I know, that's ok =)
13:43:11 <Nopik> byorgey: what is the rest of the story?
13:43:21 <fasta> Philippa: I don't know. You tell me?
13:43:39 <byorgey> Nopik: the way I like to think about it is (and I think this is what Philippa was saying earlier), each monad represents a certain *way* of performing computations
13:43:54 <Nopik> hm, ok, now the bit of 'putStrLn "ok"' being of type IO () but not doing anything before run makes sense
13:44:04 <byorgey> Nopik: for example, the State monad is "computations accompanied by a state which can be read/updated"
13:44:08 <byorgey> Nopik: right
13:44:24 <Philippa> fasta: Yes, yes it should
13:44:30 <byorgey> Nopik: as another, much simpler example, the Maybe monad is "computations which may or may not result in a value"
13:44:37 <monochrom> This monad needs no argument.  do { x <- [1,2,3]; return (x+1) }
13:44:38 <fasta> Philippa: can I still use State then?
13:44:39 <wli> fasta: Modern CPU's spend the vast majority of their time running programs stalling on cache misses and other sorts of fetches from the memory hierarchy. The closest thing to a solution is to get a CPU with as large of L1, L2, etc. caches as possible, and then to write software organized around locality of reference. For parallel computations, partitioning problems to the maximum extent possible and various lockless algorithms are involved, along with memory ban
13:44:45 <Nopik> byorgey: i am afraid i did not understood you correctly here, but i think you are talking about something which i would describe as 'computation template'
13:44:50 <fasta> wli: I know that.
13:45:08 <Philippa> fasta: you can use a State monad no problem. You'd have to ask the implementors how well ST works
13:45:27 <fasta> Philippa: ST? You mean State?
13:45:33 <Philippa> fasta: RTFM
13:45:47 <Nopik> monochrom: yeah, if some computation requires 1 argument and can be stored to monad and other can require 2 arguments and can be stored to monad of the same type, computation with 0 arguments is no surprising :D i asked about number of arguments because i was curoius if '1' is fixed here
13:45:51 <fasta> Philippa: for DPH?
13:45:52 <byorgey> Nopik: ok, sure... although it's hard to know what you have in your head when you say that =)
13:46:08 <fasta> Philippa: this discussion started from State, btw.
13:46:09 <Nopik> byorgey: vice versa :D
13:46:25 <Toxaris> Nopik: There is no such thing as a Monad
13:46:38 <Toxaris> Nopik: Monads are conceptual, monadic actions are real
13:46:40 <fasta> Hmm, probably state compiles to st.
13:46:41 <Philippa> fasta: do you mean the State monad, or state in general? The ST monad provides references into a mutable heap...
13:46:41 <byorgey> Nopik: the problem is that there are many conceptual ways to think about monads, and most of them don't quite cover all the cases =)
13:46:42 * wli is struggling to understand StateT vs. ErrorT non-commutation.
13:46:47 <Syzygy-> Toxaris: Ummmm. Say what?
13:46:56 <Philippa> wli: "do exceptions roll back state updates or not?"
13:47:00 <fasta> Philippa: I know what the ST monad is.
13:47:01 <Nopik> byorgey: yeah, i figured it out, too :(
13:47:05 <byorgey> Nopik: how is your math background?
13:47:10 <fasta> Philippa: I probably have written more code in it that you.
13:47:13 <fasta> than*
13:47:15 * Syzygy- considers adjoint functors as existing. Thus, so do their compositions. Thus monads really do exist.
13:47:27 * Toxaris speaks about software engineering in Haskell
13:47:34 <fasta> Philippa: I said I had a graph as state in a State monad.
13:47:37 <Syzygy-> Toxaris: Even then.
13:47:43 <Nopik> byorgey: well, i do not afraid heavy math, though i had no regular education on it, unfortunately
13:47:57 * jfredett says something generic and smartsounding
13:48:04 <Philippa> fasta: then as I already said, State works fine
13:48:09 <fasta> Philippa: I also said that I had n operations that could in theory work on this graph in parallel.
13:48:10 * Syzygy- rebuts jfredett using abstract nonsense
13:48:15 <wli> Philippa: Why each ordering has the effect it does is the trick. Not so tough to get the idea of what each effect is (though why they arise from a given ordering is beyond me).
13:48:18 <fasta> Philippa: that's great news.
13:48:30 <fasta> Philippa: then it ends the discussion. Thanks
13:48:32 <ddarius> Toxaris: A monad is a triple of a functor and two natural transformations satisfying some laws.
13:48:33 <Philippa> right, actually parallel ops is trickier
13:48:35 * oerjan is awed by jfredett's explanation
13:48:39 <Toxaris> Syzygy-: I would say, in Haskell, a monad  is a triple of a type constructor and two functions
13:48:42 * jfredett ignores Syzygy, snobbishly
13:48:52 <jfredett> lol
13:48:53 <Nopik> byorgey: i have just strict mind and i want to understand every bit until i go further.. if i do not understand something, usually it is harder to proceed with next parts of the tutorial
13:48:58 <fasta> Philippa: Are you now saying the same as Lemmih?
13:49:02 <Heffalump> wli: do you see why one would do one thing and the other the other, even if you're not sure which way round they match up?
13:49:03 <Philippa> wli: okay, let's picture the transformer stack for a moment, innermost monad on the bottom
13:49:18 <wli> Heffalump: Yes.
13:49:29 <ddarius> Toxaris: I think what you want to say is that there aren't "monad values".
13:49:32 <Toxaris> Syzygy, ddarius: and this is nothing "real" in the sense of "a Haskell value"
13:49:34 <Toxaris> ddarius: yes
13:49:35 <Syzygy-> Toxaris: Yeah. With what wacko semantics behind _exists_ are you working?
13:49:35 <Philippa> fasta: yes. State will parallelise, and you certainly won't have to force all the thunks from one op before you can start evaluating those from another, but there'll be one op that nominally happens first
13:49:43 <Syzygy-> Toxaris: How is [1,2,3] not a Haskell value?
13:49:45 <Nopik> byorgey: for me, monad concept looks now more like functor
13:49:56 <byorgey> Nopik: yes!  every monad is a functor.
13:49:59 <Toxaris> Syzygy: it is. But is it "a monad"?
13:50:11 <Philippa> however, once the operations've got far enough that they're clearly working on separate subgraphs there'll be no interference and it'll drop out
13:50:31 <Syzygy-> Toxaris: If you're going to be that way about it, then neither do "types", "arrows" or "functors" exist. Or for that matter "numbers"
13:50:39 <Nopik> byorgey: nice.. is this the 'whole' story? :)
13:50:51 <Philippa> wli: imagine that each monad transformer is an entry in a rulebook. The rules stated first have precedence - that's the bottom of the stack
13:50:55 <Toxaris> Syzygy-: I see [1, 2, 3] as nullary monadic action
13:51:02 <Philippa> that's why there's no IOT - no monad transformer can override reality
13:51:07 <fasta> Philippa: is there an article that makes such strong claims somewhere?
13:51:14 <dozer> I've just tried to build the network package and got an error: Network/Socket.hsc:2070:9: Not in scope: `fdToHandle''
13:51:15 <Nopik> byorgey: so, do expression is just for creating complex functors, and >>= is just for composing functors?
13:51:23 <Philippa> fasta: no, it's a consequence of the execution model. RTFPaper
13:51:31 <byorgey> Nopik: no, monads are more than just functors
13:51:31 <fasta> Philippa: ok
13:51:34 <Syzygy-> Toxaris: And I'm saying that with the view of existence you seem to be professing, a LOT of the more abstract toolbox in Haskell gets thrown out with the monadic bathwater.
13:51:36 <Philippa> graph operations don't work how you might expect in a lazy language anyway
13:51:41 <Nopik> byorgey: i was afraid of this answer ;)
13:51:46 <ddarius> Syzygy-: [1,2,3] is a value not a monad.
13:51:49 <wli> Philippa: Okay.
13:52:14 <Syzygy-> ddarius: I have already conceded that point - which was originally made to figure out what, exactly, Toxaris meant. A task I still toil at.
13:52:16 <monochrom> Hi channel! I don't understand Nums. What is a Num?
13:52:20 <Philippa> wli: so if ErrorT is innermost, errors have precedence over State - and that's why State'll get rolled back
13:52:22 <byorgey> Nopik: formally, a monad in Haskell is some type along with two functions (return and >>=) which satisfy certain rules.
13:52:38 <byorgey> Nopik: read about the rules (the monad laws) here: Nopik: try reading http://haskell.org/haskellwiki/Monad_Laws
13:52:39 <lambdabot> Title: Monad laws - HaskellWiki
13:52:40 <dozer> monochrom: something that behaves like a number
13:52:43 <Syzygy-> monochrom: A Num is a ring object in the category of Haskell types.
13:53:01 <Toxaris> Syzygy-: I answered Nopiks " if some computation requires 1 argument and can be stored to monad"
13:53:01 <Syzygy-> Sorry. Graded, signed ring object. Possibly a valuation domain object.
13:53:09 <ddarius> Syzygy-: All he's saying is there is no run-time object that corresponds to a "monad".
13:53:12 <Aleksi> lastlog tissit
13:53:16 <byorgey> Nopik: if you're not afraid of some math, you might also try reading http://en.wikibooks.org/wiki/Haskell/Category_theory
13:53:30 <Syzygy-> Right. Then apologies for missing the context. ;)
13:53:32 <fasta> Philippa: are you tkinking of a specific implementation of these graphs? It seems you are.
13:53:46 <oerjan> ddarius: there may be a dictionary
13:53:56 * Syzygy- finds the fixation with runtime objects boring in comparison to what Haskell offers anyway...
13:53:58 <ddarius> oerjan: Which still doesn't correspond to the monad.
13:53:58 <Toxaris> Syzygy-: wich shows a basic misunderstanding about the difference between monad and monadic action in my eyes
13:54:04 <byorgey> Nopik: it's more advanced but it's really an excellent description of monads in the context of category theory... I don't know if you will find it helpful or not
13:54:07 <wli> (One thing I think would be nice is to have something Eiffel-like where you can specify invariants and turn on dynamic checks of said invariants.)
13:54:20 <ddarius> And anyway, it is not observable.
13:54:20 <Philippa> fasta: I don't have time to clue you up. Lazy evaluation affects how things behave
13:54:29 <Syzygy-> Toxaris: Sure. In the context - which I missed - your comments are perfectly understandable and justifiable. Taken out of context, I have serious issue with them though.
13:54:32 <byorgey> Nopik: if it's not helpful you can ignore it =)
13:54:55 <Nopik> byorgey: i think i have gone through those document quickly and didnt went into details due to too complex math inside :D
13:55:05 <Philippa> wli: invariants per se're tricky, but you could have an assert that compiles to either id or the check...
13:55:05 <Nopik> byorgey: yeah, at least for the time being
13:55:21 <Toxaris> Syzygy-: So don't take them out of context :)
13:55:29 <byorgey> Nopik: yes, you definitely want to take time to go through it
13:55:35 <monochrom> dozer, Syzygy-: Thanks. The two answers from you actually bracket the whole spectrum of answers to the parallel question "what is a monad". Apparently, in that case it is also from "something like a computation" to "functor with additional structure". :)
13:55:45 <Syzygy-> Toxaris: That is occasionally difficult, since I'm not glued to the screen.
13:55:53 <Syzygy-> monochrom: @quote stereo
13:55:56 <Syzygy-> :)
13:56:20 <byorgey> Nopik: but anyway, viewing monads as a 'computation template', you really only have to understand the functions return and >>=
13:56:35 <byorgey> Nopik: return just puts a value "inside" the monad
13:56:47 <byorgey> Nopik: and >>= describes how to sequence two computations into one
13:57:34 <Syzygy-> Hmmmm.
13:57:44 <byorgey> Nopik: have you tried reading the source for Maybe?  that's a nice simple place to start
13:57:48 <monochrom> How would you explain numbers to infants? We know some techniques. I think those techniques should be applied to explaining monads. You bombard the infant with examples and exercises, make him/her practice 24/7 for several years, but never answer directly "a number *is* ...".
13:57:49 <Toxaris> Syzygy-: here we go again
13:58:03 <Toxaris> Syzygy-: there is no such place as "in" a monad where a value could be
13:58:24 <Toxaris> because only types can be "in" a monad (as in: on the right of the type constructor)
13:58:36 <Nopik> byorgey: yeah, i got familiar with return and >>= (more or less :D).. and i did read Maybe, but I think I'll read again
13:58:41 <Toxaris> all the talk about values being "in" monads is nonsense from my point of view
13:58:45 <Nopik> this way my list of tutorials to read grows
13:58:56 <Nopik> and i thought that yaht and 'gentle introduction to haskell' will be enough ;p
13:59:31 <fasta> Philippa: ok, how about a reference to a RTFPaper?
13:59:36 <Syzygy-> Given a monad as a unit return and a µ:M M a -> M a, is a >>= f the same as µ . return . f $ a  (adding fmaps where necessary) ?
13:59:42 <Syzygy-> Toxaris: What did I say now to trigger that?
13:59:43 <mrd> Toxaris: what relation do you refer to the value in 'return value' being to the monad?
13:59:57 <fasta> Philippa: Still, I believe I have a pretty good idea of how things work.
14:00:01 <Philippa> @go data parallel haskell
14:00:02 <lambdabot> http://www.cse.unsw.edu.au/~chak/project/dph/
14:00:02 <lambdabot> Title: Manuel M T Chakravarty - Data Parallel Haskell
14:00:06 <Toxaris> <byorgey> Nopik: return just puts a value "inside" the monad
14:00:10 <fasta> Philippa: no, not that paper.
14:00:20 * wli needs "99 Monadic Programming Problems" with a bit more infrastructure and method-of-implementation specification than the stock 99.
14:00:21 <fasta> Philippa:  about "graphs don't work like you expect"
14:00:23 <Toxaris> syzygy-: that explanation of byorgey
14:00:27 <Nopik> Maybe is in which package? do you have any http url for its sources?
14:00:28 <Syzygy-> Toxaris: So why do you tell off ME?
14:00:29 <Nopik> @where Maybe
14:00:30 <lambdabot> I know nothing about maybe.
14:00:31 <Toxaris> ahhh too many names at once
14:00:54 <Syzygy-> @index Maybe
14:00:55 <lambdabot> Data.Maybe, Prelude
14:00:57 <byorgey> Toxaris: well, how would you explain what "return" does?
14:01:01 <Syzygy-> @docs Data.Maybe
14:01:01 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Maybe.html
14:01:09 <Syzygy-> Nopik: That what you wanted?
14:01:35 <Nopik> Syzygy-: i think so, thanks
14:01:38 <Toxaris> Syzygy-: to show you that everyone uses the term monad very misleading (leading to values, leading away from type constructor-value-triples)
14:01:55 <ddarius> Toxaris: Not everyone.
14:02:00 <Toxaris> Syzygy-: so i propose to stop using monad, only using monadic action wich is clear, and using monad only in research papers
14:02:17 <Syzygy-> Toxaris: With that approach, I would have never started learning Haskell.
14:02:21 <Toxaris> ddarius: no not everyone of course
14:02:23 <Philippa> fasta: you realise that when you perform a number of update operations on a graph in Haskell, barely anything gets done? And that when you start doing things with values in the graph, bits of the updated graph get evaluated as needed?
14:02:37 <byorgey> Toxaris: I think the distinction would be lost on most people learning Haskell.
14:02:41 <monochrom> I'm guilty of the misuse too. I should have said, "do { x<-[1,2,3]; return (x+1) }" is an action needing no parameter to run.
14:02:55 <Philippa> that being, amongst other things, a common source of runaway memory consumption - piling up update thunks that don't get forced
14:02:55 <Syzygy-> Toxaris: And thus, I am opposed to that proposal, since it speaks against what I value in this communiuty.
14:03:05 <Nopik> Syzygy-: no, i also wanted Maybe source code
14:03:07 <Toxaris> Syzygy-: i don't understand you?
14:03:21 <byorgey> Nopik: click on "Source" in the upper right corner.
14:03:33 <CosmicRay> @seen syntaxninja
14:03:33 <lambdabot> I haven't seen syntaxninja.
14:03:39 <Syzygy-> Toxaris: The very thing that made me enter the Haskell world is the dominating prevalence of a category theoretic point of view and mode of discussion.
14:03:50 <AStorm> CosmicRay, you can't see ninjas if they don't want to be seen
14:03:58 <Syzygy-> Toxaris: Hadn't this community been prepared to discuss things in terms of morphisms and functors of a specific category, I would have never bothered.
14:04:08 <CosmicRay> heh
14:04:22 <Toxaris> byorgey: but it is important i think
14:04:29 <fasta> Philippa: ok, and reducing that can be done by adding strictness annotations. Or are you suggesting doing graph algorithms in Haskell is a very stupid idea in the first place?
14:04:50 <ddarius> Syzygy-: All Toxaris is calling for is precise speech which you should value if you value those things.
14:05:05 <Philippa> fasta: no, I'm saying that this affects how evaluation works when two updates touch unrelated subgraphs
14:05:07 <Nopik> yeah, thanks
14:05:30 <Toxaris> Syzygy_: my point is: most people understand monadic actions and their composition, so they should speak about monadic actions and their composition. most people don't understand monads, so they should speak about them
14:05:33 <Philippa> if you start forcing thunks for the first, then after a while it narrows down to just the subgraph it's working on. If you don't force it any further, you still know that the rest's untouched
14:05:55 <byorgey> Toxaris: so what words would you use to explain what the return function does?
14:05:56 <Philippa> at that point, it's possible to start forcing thunks from the /second/ update, piece in the bit that's not finished yet as untouched and carry on
14:06:05 <Philippa> at that point, the order in which you force thunks from either update /doesn't matter/
14:06:07 <Syzygy-> ddarius: I'm all for precise speech. But what Toxaris comes across calling for is the abolishment of the category theoretical language in the discourse of the community. Go ahead and do all the weird metaphors you want for the newbies: space ships don't help me much either, so I just ignore those. But don't rebuild the discourse in a way that drops the entire category theoretic language, since then the very thing that drew me in vanishes.
14:06:11 <Philippa> which means they can run in parallel
14:06:22 <ddarius> byorgey: It makes a monadic action that does nothing and returns a
14:06:30 <Syzygy-> Toxaris: This community never made the impression on me to adapt much to the concept of "most people".
14:06:46 <Toxaris> Syzygy_: I don't understand monads, for example. I know enough maths to understand what it's about, but that's it. That doesn't stop me from understanding monadic actions, and explaining them, and using them. and i certainly plan to learn about monads soon :)
14:06:48 <byorgey> ddarius: hmm, fair enough, I like that.
14:07:06 <Toxaris> Syzygy-: "most people writing so called monad tutorials" maybe?
14:07:17 <ddarius> Syzygy-: Okay, he is going a bit farther.
14:07:22 <EvilTerran> do I need the darcs version of xmonad if i want to use an extension?
14:07:37 <Syzygy-> Toxaris: Certainly, a qualification for the genreralisiations you're doing would have made my reaction less averse.
14:07:51 <ddarius> Syzygy-: His issue is that he seems to think you can't understand monads in Haskell for some reason.
14:08:06 <ddarius> That they aren't monadic actions is no reason you still can't understand monads.
14:08:12 <Syzygy-> Toxaris: There is a huge difference between "people should X", "most people should X" and "people who don't understand the things I'm hazy on should X".
14:08:40 <Toxaris> Syzygy-: I started with "you should X" as reaction to the question someone asked here
14:08:45 <fasta> Philippa: ok, I will finish SPJ's book and then DPH first hopefully I might talk to you again on this subject. It wasn't entirely clear, but I can imagine IRC can be blamed for that and lack of your time. It did help a bit. Thanks
14:09:02 <Nopik> what is difference between 'fromMaybe' and 'maybe'?
14:09:09 <wli> Understanding monads as a generality seems to be a wrong approach. Going after specific ones (State, Reader, Writer) and transformers in terms of practical usage seems to be the way to go.
14:09:11 <EvilTerran> ?type fromMaybe
14:09:14 <lambdabot> forall a. a -> Maybe a -> a
14:09:14 <EvilTerran> ?type maybe
14:09:16 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:09:30 <Nopik> ah, ok, wrong question ;)
14:09:32 <quicksilver> Nopik: maybe is more general
14:09:34 <Syzygy-> Even sitting down and saying "All we're going to talk about is monadic actions" is silly in my mind. It reduces - if my understanding is anywhere near correct - the monadic viewpoint to only bind / >>=, and it obfuscate everything that can be won by getting the categorical viewpoint.
14:09:35 <Toxaris> Syzygy-: as i said, software engineering in Haskell
14:09:41 <Syzygy-> Yeah...
14:09:41 <quicksilver> Nopik: fromMaybe merely has a default value
14:09:42 <ddarius> wli: Certainly that's the practical way to go.  Monads in general mostly don't apply to Haskell (in a direct way).
14:09:45 <Nopik> i didnt noticed taht maybe gets function as argument
14:09:52 <Syzygy-> I think that may well be the central point.
14:09:54 <fasta> wli: newbies also want to write their own monads, but don't know what to write.
14:09:56 <quicksilver> Nopik: maybe has a function to convert the 'Just' to, as well as a default
14:10:04 <Toxaris> Syzygy-: it's the first step, hopefully not the last step.
14:10:16 <Syzygy-> I do Haskell because it is so close to mathematics. You, Toxaris, seem to be here because it makes software engineering a nicer thing to do.
14:10:24 <byorgey> > fromMaybe (Just 3)
14:10:26 <lambdabot>  <Maybe (Maybe Integer) -> Maybe Integer>
14:10:35 <wli> fasta: Probably not worth writing one's own monads until one understands how to use the canned ones.
14:10:37 <quicksilver> Nopik: in fact, fromMaybe x is the same as maybe x id
14:10:51 * Syzygy- is also of the opinion that fmap clouds its issues a little bit - but I guess I should swallow that pill. I certainly don't have any decent proposals to replace it.
14:10:52 <fasta> wli: right, but newbies don't think like that often.
14:11:00 <ddarius> wli: Often there -is- no reason to make your own monad (from scratch).
14:11:02 <Toxaris> Syzygy-: I'm here (in this Channel) because ICFP contest ended and I forgot how to sleep
14:11:16 <Philippa> yeah, wrapping an existing one however is often a good idea
14:11:19 <Nopik> byorgey: ok, i've read Maybe.. what should i learn from it? :)
14:11:20 <ddarius> Syzygy-: What are you talking about?
14:11:21 <Syzygy-> Toxaris: Note, by the way, that I learned homological algebra and category theory first, and Haskell LONG after I got used to categories.
14:11:24 <EvilTerran> fromMaybe a = maybe a id, i think
14:11:44 <EvilTerran> whups, didn't scroll down properly. ignore me. =/
14:12:00 <Toxaris> Syzygy-: Cool. I learned programming, then Haskell, now I'm interested in higher mathematics because I see that it's usefull to know about this stuff
14:12:15 <Toxaris> Syzygy-: Your way to Haskell is better I think
14:12:24 <Syzygy-> ddarius: A "decent" functor is something that moves objects and moves morphisms. So, rather than fmap f (return blah), I would think that (m f) (return blah) might be a more "natural" way to talk about it.
14:12:31 <Toxaris> Syzygy-: It's most times better to understand first, use then
14:12:37 <Syzygy-> So you'd have (Maybe f) :: Maybe a -> Maybe b et.c....
14:12:40 <byorgey> Nopik: do you understand what this means: (return 3 >>= (*2)) :: Maybe Int?
14:12:47 <Toxaris> Syzygy-: But most people (arriving at Haskell) don't go this way, I thinik
14:12:54 <Syzygy-> Using fmap and a Functor typeclass makes the functoriality less transparent.
14:12:58 <Syzygy-> Toxaris: That, again, is a good point.
14:13:01 <ddarius> Syzygy-: You've been looking at categorical texts too long.  It is they that (purposely) confuse them.
14:13:13 <Toxaris> Syzygy-: So is it possible to have both points of view in the same community?
14:13:21 <Syzygy-> Toxaris: And there also probably is a good idea not to let me get tooo close to programmer newbies. ;)
14:13:23 <Nopik> byorgey: it returns Maybe 6, for sure ;)
14:13:34 <Syzygy-> ddarius: Nonono. I'm happy here in my pink cloud.
14:13:46 <Syzygy-> Toxaris: I believe it is, which is why I was so allergic to sweeping generalities.
14:13:57 <byorgey> Nopik: and how about (Nothing >>= (*2))?
14:13:59 * Toxaris finally thinks about byorgey's question about return
14:14:03 <Syzygy-> Toxaris: Since my (out of context) reading of your argument sounded much like "We don't want the categorical viewpoint"
14:14:07 <Nopik> byorgey: returns Nothing
14:14:29 <byorgey> Nopik: right.  so do you see how the Maybe monad represents a certain method of computation?
14:14:39 <wli> liftM (*2) please.
14:15:04 <byorgey> wli: I know, that wasn't the point =)
14:15:13 <ddarius> Nothing >>= (*2) is a type error unless you have a funky instance of Num
14:15:35 <Syzygy-> :t (>>=)
14:15:37 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:15:46 <Syzygy-> :t liftM (*2)
14:15:48 <lambdabot> forall a1 (m :: * -> *). (Num a1, Monad m) => m a1 -> m a1
14:15:51 <Nopik> byorgey: yeah, i think i get more grasp on this.. though it is hard to define what other ways of computations can be expressed using monads.. and which types of computations do not ;)
14:15:58 <Toxaris> byorgey: for intermediate programmers I would try like "return is a function wich lifts it's argument to a monadic computation returning this precise argument"
14:15:58 <Syzygy-> wli: return . (*2) I should think...
14:16:32 <Syzygy-> Toxaris: And leave "return is the unit of the monad" for us REALLY weird mathematicians? ;)
14:16:35 <wli> Yes, thanks.
14:16:40 <byorgey> > Nothing >>= (*2)
14:16:41 <lambdabot>   add an instance declaration for (Num (Maybe b))
14:16:49 <Toxaris> Syzygy-: and maybe adding "so, return is the unit of the monad"
14:16:49 <Syzygy-> > Nothing >>= return . (*2)
14:16:50 <lambdabot>  Nothing
14:16:56 * ari is having trouble with trying to build lambdabot... well, it did build, but... it doesn't... work... quite:
14:17:00 <ari> ari@hikahi:~/lambdabot-4.0.1$ echo "1 + 1" | ./runplugs
14:17:02 <ari> runplugs: /home/ari/lambdabot-4.0.1/ShowQ.o: unknown symbol `templatezmhaskell_LanguageziHaskellziTHziPpr_pprint_closure'
14:17:05 <byorgey> oh, right, sorry
14:17:05 <ari> runplugs: user error (resolvedObjs failed.)
14:17:13 <ddarius> Syzygy-: The fact that return is a unit for the monad falls out after playing around at the "monadic computation" level.
14:17:15 <Syzygy-> Toxaris: Yeah, that sounds good for the intermediate programmer wanting to get a grip on the math-y side.
14:17:16 <Toxaris> byorgey: for newbies I would try to paraphrase lifting
14:17:25 <byorgey> Toxaris: ok, that makes sense
14:17:26 <EvilTerran> "return is kinda like id, but it produces a value in the monad."
14:17:44 <Syzygy-> ddarius: For me, recognizing it as the unit was the key to understanding what monads (monadic computation) was about.
14:17:54 <EvilTerran> s/a value.../the value in the monad, instead of just producing the value as-is/
14:17:55 <ddarius> "return is the result of the mediating morphism on id"
14:17:59 * byorgey ducks as Toxaris runs screaming at EvilTerran
14:18:13 <wli> Well, map (liftM (*2)) [Just 1, Nothing]
14:18:13 <Syzygy-> ddarius: mediating morphism???
14:18:27 <Syzygy-> > map (liftM (*2)) [Just 1, Nothing]
14:18:28 <lambdabot>  [Just 2,Nothing]
14:18:29 <Toxaris> EvilTerran: what does it mean for a value to be in a monad?
14:18:30 <Syzygy-> :t mapM
14:18:32 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
14:18:36 <fasta> Do we have a typeclass F with method foo where foo = id and foo = return?
14:18:37 <byorgey> Nopik: well, don't expect to grok everything perfectly all at once =)
14:18:57 <EvilTerran> i only came on here just now to ask for help with xmonad, but that's all been lost in the kerfuffle about how to explain monads (a very thoroughly thrashed-out topic already)
14:19:01 <byorgey> Nopik: but as another example, the list monad represents computations with non-deterministic choice
14:19:04 <ddarius> mediating isomorphism of any adjunction that the monad factors into
14:19:19 <EvilTerran> Toxaris, it means fnord. that's just the definition that works well intuitively in my mind.
14:19:39 <Toxaris> Syzygy-: very important for my newbieish understanding of monads is join
14:19:44 <Syzygy-> ddarius: Ah, you use mediating for the iso Hom(F A, B) <-> Hom(A, F B) ??
14:19:58 <Toxaris> Syzygy-: introducing it would lead straight to more mathematical definition of class Monad
14:20:17 <olsner> if you view monads as wrappers, an Int is a non-monadic, or outside-the-monad, Int, but Wrap Int is a wrapped, monadic or in-the-monad Int
14:20:20 <Toxaris> Syzygy-: by saying: we could characterise a monad like this, or like that, and now we show that it's equivalent
14:20:22 <Syzygy-> Toxaris: Which of the thingies is join? Is that the name for the m m a -> m a? Or for the (>>=) ?
14:20:27 <wli> Syzygy: mapM (liftM (*2)) is somewhat less informative to those trying to see what it does.
14:20:32 <EvilTerran> @src join
14:20:33 <lambdabot> join x =  x >>= id
14:20:36 <ddarius> Syzygy-: Well Hom(FA,B) ~ Hom (A,UB) where T, the monad, is UF
14:20:46 <Toxaris> Syzygy-: I dont know the greek word... joing :: m (m a) -> m a
14:20:50 <Syzygy-> ddarius: And the mediating morphism is that isomorphism?
14:20:57 <EvilTerran> anyway, as i asked when i arrived: do I need the darcs version of xmonad if i want to use an extension?
14:21:03 <Nopik> byorgey: yeah.. though every tutorial i see is just making the same mistake.. section 'monad as containers', section 'monad as control method of side effects' and so on... while it looks like trying to desribe 3d cube using 2d figures to the 2d creatures ;)
14:21:11 <Syzygy-> Toxaris: Right!!! THAT's what I mean by grokking monads...
14:21:16 <ddarius> Syzygy-: I believe that is one terminology (though not one I'm particularly fond of)
14:21:22 <ddarius> mu?
14:21:23 <wli> The existence of join is a sort of idempotence condition.
14:21:25 <Nopik> byorgey: kind of: 'cube' may be a 'square' or 'line' or 'point' or '3 points' etc.
14:21:27 <Syzygy-> Toxaris: I really, really do think about monads in terms of the unit and the "join".
14:21:39 <byorgey> Nopik: yes, that's exactly how I felt when learning about them.
14:21:39 <ddarius> wli: Indeed, related to closure.
14:21:59 <Syzygy-> So for me, bind and >>= and all that jazz is syntactic sugar that I had to wrap my head around for a while before grokking.
14:22:00 <wli> ddarius: Which notion of closure?
14:22:03 <Nopik> byorgey: it seems, that the wiki entry on cathegory theory explains it.. at least i have hope for that
14:22:05 <byorgey> Nopik: you just read enough and get enough perspectives until you can finally see the whole thing (or at least most of it...)
14:22:09 <Toxaris> Syzygy-: yep, thats grokking monads. But I think it's easier (for newbies of both Haskell and CT) to learn monadic actions first, then proceed to monads over the join/unit bridge
14:22:18 <AStorm> Nopik, Monads are just a tool :-)
14:22:23 <Syzygy-> wli: Closure, as I know it, means T T x = T x, for some notion of =.
14:22:36 <Nopik> byorgey: yeah, thats fine as long as i have description of full view.. then i can know how much parts i am still missing ;)
14:22:41 <byorgey> Nopik: yes, the wiki entry on category theory is very good.  just sit down sometime and patiently work your way through it.
14:22:50 <Nopik> byorgey: this way, every day i think i have know everything ;)
14:22:52 <ddarius> wli: A monad in a partially ordered set viewed as a category is exactly a closure operator.
14:22:57 <Syzygy-> Toxaris: That may well be the sake. My main reason for making noise is that what we were talking about earlier, about both cultures fitting into the community.
14:23:39 <mgsloan> actually the best monad metaphor is a wet noodle that can fit other wet noodles inside it
14:23:50 * ari ends up "fixing" his problem by removing the last two lines of scripts/ShowQ.hs (the ones using TH)... it makes using IO somewhat uglier, but works, it seems
14:23:54 * byorgey needs to go... being late to a dinner reservation on one's second wedding anniversary would be a Bad Thing =)
14:23:55 <Syzygy-> mgsloan: Rrrriiiiiight...
14:23:56 <monochrom> Why wet?
14:24:04 <Toxaris> Syzygy-: Ok that one is very important, we humble programmers can learn so much of you mathematicians, it would be a shame to have the community split up
14:24:05 <Nopik> monochrom: to get situation worse
14:24:07 <mgsloan> so its more stretchy
14:24:14 <AStorm> mgsloan, :D
14:24:35 <slava> mathematicians who are not category theorists view monads much like programmers who are not haskell programmers
14:24:38 <Nopik> byorgey: thanks a lot and bye ;)
14:24:58 <byorgey> Nopik: you're welcome, any time. good luck with your tutorial-reading! =)
14:25:02 <Syzygy-> slava: You mean non-haskellite programmers have a working notion of monadicity??
14:25:23 <AStorm> slava, uhm, you can view them as simple "actors"
14:25:24 <ddarius> monadicity is something else entirely!
14:25:25 <slava> no, i mean non-haskellers and non-category theorists don't care much for monads :)
14:25:28 <AStorm> this always works
14:25:29 <Syzygy-> Oh right.
14:25:29 <AStorm> :>
14:25:32 <Syzygy-> I missed one negation.
14:25:47 <Syzygy-> slava: Actually. I'd like to point out, pro forma, that I am not, in fact, a category theorist.
14:25:49 <ddarius> slava: Yet work with them all the time.
14:25:51 <Syzygy-> I'm a homological algebraist.
14:26:02 <Syzygy-> There ... is a difference!
14:26:08 <slava> not much of a difference ;)
14:26:13 * Syzygy- was tempted to say big, but thought better of it.
14:26:14 <AStorm> Syzygy-, that's close enough
14:26:15 <slava> i study lie algebra cohomology
14:26:26 <Syzygy-> slava: Neat. Group cohomology here. At least for the moment.
14:26:59 <Syzygy-> Some of my best friends, though, are really hardcore CT... :P
14:27:17 <ddarius> CT is fun!
14:27:34 <Toxaris> slava, Syzygy-: hey cool another "co" I like "co"s. my next haskell task: understanding comonadic actions
14:27:51 <Syzygy-> Toxaris: You know what you get when you dualize commutativity?
14:27:56 <Syzygy-> mmutativity!
14:28:04 <slava> actually, co-commutativity
14:28:07 <olsner> Yarr! Head 'splodes!
14:28:08 <ddarius> Toxaris: Well look at free comonads
14:28:11 <Syzygy-> slava: Spoilsport!!
14:28:28 * Toxaris said "comonadic actions" clearly, not "comonads"
14:28:40 <wli> Syzygy: Closure means a lot of different things.
14:28:41 * Syzygy- applauds Toxaris' consistency.
14:28:45 <Syzygy-> wli: Sure.
14:28:49 <Toxaris> but ok, if you want to, you may try to teach my about comonads :)
14:28:59 <Toxaris> but maybe monads first would be better, i don't know
14:29:09 <Syzygy-> wli: Though if you restrict to meanings of closure that fit with the type signatures of the monadic thingies, you restrict the playing field a bit.
14:29:15 <fasta> Where does the word antisymmetry come from? I am not interested in its math. definition, just why it's named that way.
14:29:24 <ddarius> Toxaris: You can talk about free monads easily in Haskell.
14:29:27 <wli> [Just 1, Just 2, Just 3] :: forall t. (Num t) => [Maybe t] -- error as an inner monad
14:29:36 <Syzygy-> fasta: My feeling is that it originates somewhere close-ish to physics.
14:29:58 <fasta> Syzygy-: like in the context of mirrors?
14:30:19 <wli> mapM (liftM (*2)) [Just 1, Just 2, Just 3, Nothing] == Nothing -- error as the inner monad kills the whole computation when there's one error
14:30:23 <ddarius> xRy => yRx (symmetry), antisymmetry means xRy => yRx only when x==y, i.e. for x/=y, xRy =/=> yRx
14:30:26 <Syzygy-> fasta: Hmmmm.... Don't see how to make that work.
14:30:33 <ddarius> So, anti - symmetry
14:30:40 <Syzygy-> Oh bugger.
14:30:46 <Syzygy-> I was thinking about anti-commutativity. Sorry.
14:34:00 <wli> OTOH if you've got Maybe (State blah ...) your state vaporizes when there's an error vs. State blah (Maybe ...) where you've still got state you're working with even though your result's an error.
14:34:26 <Toxaris> ddarius: "talk in Haskell" as in "express as Haskell program" or "talk about in human language using concepts familiar to haskell programmers"?
14:34:32 <fasta> ddarius: hmm, I suppose that it's the only sensible name since xRy =/=> yRx would always be an empty relation.
14:34:32 <EvilTerran> :k StateT
14:34:34 <lambdabot> * -> (* -> *) -> * -> *
14:34:36 <wli> In principle you could "recover from the error" in the second case.
14:35:11 <EvilTerran> StateT blah Maybe ...?
14:35:16 <monochrom> > not True
14:35:17 <lambdabot>  False
14:38:12 * Toxaris reads http://en.wikipedia.org/wiki/Monads_in_functional_programming
14:38:14 <lambdabot> Title: Monads in functional programming - Wikipedia, the free encyclopedia
14:38:43 <Toxaris> this article describes Monads in FP as exploiting loopholes to achieve I/O in pure languages
14:39:22 <mgsloan> not really
14:41:05 <mgsloan> oh, loophole
14:41:10 <mgsloan> yeah, that does sound bad
14:41:23 <mgsloan> probably a recent edit by some anti-pure-FPer
14:41:47 <Toxaris> "that the caller should apply at a convenient time" is good in my eyes
14:42:16 <wli> It's an encapsulation of CPS-style IO, and also a sufficiently expressive type system to type it.
14:42:19 <mgsloan> thing is, it's not really a loophole
14:42:25 <Toxaris> but it should be stated that because of laziness, this time may be the creation time of the monadic action
14:42:45 <Toxaris> yes, it's more like clever software design to need no loopholes
14:42:46 <ddarius> Toxaris: As express in code.
14:43:21 <Toxaris> mapM_ putStrLn ["1", "2"]
14:43:49 <Toxaris> I think/hope/believe/don't know for sure that putStrLn "1" is executed before putStrLn "2" is constructed
14:44:13 <AStorm> Toxaris, it will be, because mapM_ is so defined
14:44:35 <AStorm> unlike map, which doesn't specify ordering
14:44:39 <AStorm> @src mapM_
14:44:39 <lambdabot> mapM_ f as = sequence_ (map f as)
14:44:53 <AStorm> @src sequence_
14:44:53 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
14:44:55 <Toxaris> so this is exactly equivalent in terms of evaluation order to "printf "1"; printf "2"" in c
14:45:15 <Toxaris> so it's possible to use monadic IO to simulate impure effects
14:45:21 <Toxaris> this is only possible because of laziness
14:45:30 <AStorm> Not really :>
14:45:42 <EvilTerran> you'd have to use explicit thunks otherwise
14:45:46 <Toxaris> or CPS to simulate laziness in strict languages
14:46:14 <Toxaris> it's only possible conveniently because of laziness
14:48:08 <ddarius> Laziness has nothing to do with monadic IO.
14:48:30 <Toxaris> hmm... thinking about it, do notations introduces explicit thunks
14:48:48 <mgsloan> I dunno.  I think the monads as data and monads as computation are basically the same thing due to laziness
14:49:13 <AStorm> data _is_ computation
14:49:17 <wli> Or perhaps due to higher-order functions.
14:49:18 <AStorm> @type id
14:49:20 <lambdabot> forall a. a -> a
14:49:28 <mgsloan> [a], to me doesn't represent a list of a, it represents a computation yielding the list
14:50:01 <mgsloan> well, the type of a computation yielding a list...
14:50:32 <AStorm> actually, yielding elements in response to some class methods
14:50:39 <AStorm> like !! or head or tail
14:50:41 <ddarius> mgsloan: I can only assume that you mean due to laziness as that is not very consistent if you mean it as relating to monads.
14:50:57 <mgsloan> yeah, it's due to laziness
14:51:00 <EvilTerran> consider putStrLnAndThen :: String -> (() -> Action), say, in a strict language. if you get your layout rules right, you can write do{br}    putStrLnAndThen "blah" $ \()->{br}    <other action> $ \()->{br}...
14:51:10 <Toxaris> so we have now "computations" and "monadic computations" to think about
14:51:28 <EvilTerran> it just means that your end-of-line marker is "$\()->"
14:51:44 <wli> No, not even higher-order functions. Functions as first-class objects.
14:52:08 * mgsloan wonders if we could represent normal evaluation monadically..  probably sorta chicken-and-egg
14:52:44 <EvilTerran> before i'd even heard of haskell, i wrote something to that effect for StdML, because the lack of purity bothered me
14:52:56 <AStorm> mgsloan, you could do that, but then, you get an imperative language, not a functional one
14:53:03 <AStorm> read: C
14:53:09 <AStorm> ;-)
14:53:22 <mgsloan> I don't think so..
14:53:28 <wli> AStorm: C is too huge of a disaster for that.
14:53:28 <ddarius> AStorm: You can perfectly well describe pure computation monadically.
14:53:43 <mgsloan> monads abstract execution order
14:53:44 <AStorm> ddarius, but pure computation doesn't specify ordering
14:54:16 <ddarius> AStorm: Monads don't enforce ordering.
14:54:24 <AStorm> oh, yes they do
14:54:32 <Philippa> monadic style doesn't in and of itself
14:54:42 <Philippa> the "ordering" associated with >>= can just be dependency
14:54:53 <Philippa> which you already have in the pure lambda calculus
14:54:58 <AStorm> hmmm
14:55:05 <AStorm> you're right
14:55:19 <AStorm> but it'd introduce ordering where none is needed
14:55:26 <AStorm> or a lot of one-shot monads
14:55:38 <newsham> any bytestring enhancements come out of icfp?
14:55:40 <Toxaris> AStorm: you are aware that monadic computations can be lazy?
14:55:43 <Philippa> that ordering's already there
14:55:45 <EvilTerran> "datatype Action = PrintAnd String (() -> Action) | ReadAnd (String -> Action) | Stop", iirc, and one outer function that did all the actual IO.
14:55:47 <dcoutts> newsham: some ideas
14:55:47 <mgsloan> monads don't mean execution like IO
14:55:51 <Philippa> it's exactly the same ordering you see in function application
14:56:07 <mgsloan> they don't imply linear ordering
14:56:20 <AStorm> Toxaris, hmmmm, they can
14:56:35 <AStorm> you're right, lazy ordering - determined as needed
14:56:53 <EvilTerran> :t (>>=)
14:56:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:57:19 <wli> You just unravel the things the same way you do any other higher-order function applications. It's more software engineering -relevant than operational per se.
14:57:35 <ddarius> EvilTerran: PrintAnd does not need to take a thunk as a second argument (even in a strict language).
14:58:53 <ddarius> Well maybe.
14:59:01 <ari> Can you define names for later use (i.e. on a scope larger than just one line) in lambdabot 4.0.1? (and for that matter, how do you do it on the most recent lambdabot?)
14:59:11 <EvilTerran> ddarius, what happens if the second argument is _|_? i still want my output, damnit!
14:59:17 <oerjan> @let yes = True
14:59:19 <lambdabot> Defined.
14:59:35 <ddarius> EvilTerran: Clearly you should have written codatatype
14:59:46 <Toxaris> and here we are again
14:59:47 <EvilTerran> class Monad Ignore where return _ = undefined; _ >>= _ = undefined  -- lazy monad >;]
14:59:51 <Toxaris> a codiscussion
14:59:59 <Toxaris> never reaching a final state
15:00:01 <ari> oerjan: Thanks
15:00:01 <EvilTerran> ddarius, i don't think ML has those
15:00:09 <therp> toxaris ;)
15:00:17 <ddarius> EvilTerran: Well clearly it should grow them.
15:00:20 <EvilTerran> ...actually, looking at it, that lazy monad is also strict, in the sense of f _|_ = _|_...
15:00:45 <Toxaris> EvilTerran: how can a monad be strict? functions are strict, a monad is not a function
15:00:52 <Toxaris> :)
15:01:02 <AStorm> Toxaris, by evaluating all its arguments
15:01:02 <EvilTerran> okay, all computations in that monad are strict
15:01:09 <EvilTerran> **coughpedantcough**
15:02:02 <Philippa> "strict monad" by analogy to "strict language"
15:02:09 * EvilTerran is reminded of being asked to write a strict fn :: Bool -> Bool that behaves differently to id and not
15:02:28 <EvilTerran> i wrote "const undefined"...
15:02:28 <mgsloan> fn = fn
15:02:29 <Philippa> that's easy - id && not doesn't typecheck
15:02:32 <mgsloan> or that
15:02:33 <Philippa> heh
15:02:58 <EvilTerran> it was either going to be a _|_ or some hack like f x = if x then True else True
15:03:12 <AStorm> EvilTerran, wht about and?
15:03:16 <EvilTerran> flip seq True?
15:03:22 <mgsloan> or just f x = True
15:03:24 <Philippa> AStorm: wrong type
15:03:25 <EvilTerran> AStorm, Bool -> Bool. one parameter.
15:03:33 <EvilTerran> mgsloan, not strict
15:03:33 <AStorm> ah, right :>
15:03:35 <chessguy> @seen SamB
15:03:35 <lambdabot> SamB is in #haskell, #haskell-blah, #haskell-icfp07, #xmonad, #perl6, #oasis and #haskell-overflow. I last heard SamB speak 29s ago.
15:03:39 <AStorm> there are 4 such functions
15:03:39 <mgsloan> oh, right
15:03:52 <AStorm> identity, negation, always-true, always-false
15:03:55 <chessguy> SamB, did you see the images at that link?
15:04:04 <SamB> link?
15:04:08 <EvilTerran> as i said, i think the only possibilities were either _|_ or language-dependent
15:04:11 <chessguy> http://tapani.cs.chalmers.se/icfp/2007/
15:04:13 <lambdabot> Title: Index of /icfp/2007/
15:04:19 <chessguy> i /msg'd it to you
15:04:23 <SamB> chessguy: did you see http://img69.imageshack.us/my.php?image=nullmv9.png
15:04:24 <lambdabot> Title: ImageShack - Hosting :: nullmv9.png
15:04:26 <EvilTerran> (a good compiler might optimise away "if x then True else True"...
15:04:28 <mgsloan> AStorm - yeah, due to the multiplication of domain and range
15:04:38 <SamB> chessguy: I don't seem to have gotten it
15:04:41 <Philippa> EvilTerran: that's a bad compiler
15:05:00 <chessguy> hm, what is that?
15:05:05 <EvilTerran> okay, "a compiler", then. i never said this was haskell, anyway.
15:05:07 <Toxaris> EvilTerran: i don't understand what you mean by strict monad? i say strict monad to monads with bind strict in the first argument
15:05:18 <ddarius> AStorm: There are more than four.
15:05:19 <AStorm> mgsloan, well, _|_ is always a possibility :>
15:05:20 <SamB> that's what happens when I use my C renderer on the RNA from endo.dna
15:05:24 <EvilTerran> 2259<EvilTerran> okay, all computations in that monad are strict
15:05:29 <AStorm> ddarius, yes, error or loop
15:05:47 <AStorm> and various combinations with these
15:05:49 <SamB> chessguy: it's, uh, not finished yet ;-)
15:05:57 <ddarius> Also he asked for strict which rules out const (True/False)
15:06:06 <chessguy> you're writing an rna->image?
15:06:59 <Philippa> Toxaris: people mean ones with bind strict in the result of the first argument as a computation, rather than as a haskell value
15:07:21 <Toxaris> EvilTerran: but still, (return _|_ >> return ()) may be /= _|_ in such a monad
15:07:34 <Toxaris> Philippa: ok, so that return _|_ >> return () is indeed _|_
15:08:02 <Toxaris> Philippa: but return _|_ may be /= _|_  ?
15:08:10 <EvilTerran> i was being sloppy with my use of language. don't overthink it, i know i didn't ;]
15:08:54 <Toxaris> EvilTerran: hehe I just try to find the best words to describe things
15:09:00 <Philippa> Toxaris: something like that
15:09:19 <Toxaris> Philippa: thanks that's usefull
15:09:27 <chessguy> SamB?
15:09:35 <SamB> chessguy: yeah
15:09:35 <Philippa> though it's more what happens with return _|_ >>= ... than with >>
15:09:50 * Toxaris thinks that IO is not strict in that sense, but isn't sure
15:10:13 <chessguy> in haskell, or c?
15:10:20 <Toxaris> chessguy: in haskell
15:10:37 <chessguy> Toxaris, sorry, that was meant for SamB
15:10:44 <Philippa> hmm. It's probably a bad idea to define in terms of return actually
15:10:59 <Toxaris> chessguy: oh ok
15:10:59 <Philippa> it's meaningful for a strict computation to return the lazy value _|_
15:11:34 <Toxaris> > return undefined >>= const (putStrLn "3")
15:11:36 <lambdabot>  <IO ()>
15:11:41 <SamB> chessguy: in C
15:13:39 <chessguy> SamB, did your overnight run finish?
15:13:40 <Philippa> normally by "strict monad" people're discussing how things other than return behave
15:13:48 <SamB> chessguy: not even close
15:14:01 <chessguy> yeah, my RAM blew out
15:14:47 <chessguy> wonder why it's so slow
15:14:48 <Toxaris> Philippa: but if return is out-of-scope, everything may be, since it may happen to be equivalent to return.
15:15:17 <SamB> chessguy: see http://naesten.dyndns.org:8080/repos/icfp2007/
15:15:19 <Philippa> and then it wouldn't be a strict monad, would it?
15:15:20 <lambdabot> Title: Directory listing for /repos/icfp2007/
15:15:23 <SamB> it seems to work now
15:15:31 <SamB> ah, nice, lambdabot agrees
15:16:44 <Toxaris> Philippa: every monadic computation could be equivalent to a return, unknown to the person trying to use it's knowledge of "but this monad is supposed to be strict"
15:18:27 <chessguy> SamB, it works? you got the source image?
15:18:38 <SamB> chessguy: no!
15:18:47 <SamB> but that's because I didn't implement everything yet
15:18:49 <Toxaris> Philippa: I think with "strict" monad is meant a monad wich does side-effects during evaluation of >>=, while a lazy monad does side-effects during evaluation of the side effects result
15:19:23 <cdsmith> SamB: Is there a working DNA -> RNA implementation there?  I'd really like to see one of those.
15:19:27 <chessguy> ah yes, you still need the fun fill and compose functions
15:19:33 <SamB> cdsmith: there appears to be
15:19:41 <SamB> though you could find others on #oasis
15:19:51 <cdsmith> SamB: #oasis?
15:19:52 <ddarius> I think the term is not clear and that people don't speak of "strict/lazy monads" in general.
15:19:58 <Toxaris> Philippa: but then, IO has to be lazy, because the side effects affect outside world, and are to be executed only if this IO action created is actually handed over to the magic IO interpreter sitting outside of Haskell waiting for impure stuff to do
15:20:00 <SamB> such as desp's (http://varsztat.com/clfp/dna2rna-src/
15:20:00 <lambdabot> Title: Index of /clfp/dna2rna-src
15:20:28 <Toxaris> Philippa: not in advance when an IO action is created
15:20:46 <Philippa> uh, no
15:20:53 <Toxaris> Philippa: but of course, strictness could be achieved artificially without really executing the side effect
15:21:03 <Philippa> that is specifically /not/ a valid argument about strictness
15:21:13 <SamB> chessguy: anyway, if you ghc --make dna2rna, you should be able to run the tests and see the front page of the repair guide
15:21:27 <SamB> perhaps with -O2
15:21:52 <chessguy> wait, how did you get the repair guide?
15:22:10 <SamB> chessguy: I misidentified that prefix that shows up at the beginning
15:22:19 <Philippa> if you like, >>= is never actually evaluated by anything other than the magic IO interpreter
15:22:20 <chessguy> aha
15:22:30 <Philippa> (in the IO monad's case, of course)
15:22:36 <Toxaris> Philippa: what? my definition of strict monad or my reasoning about IO being lazy?
15:22:43 <Philippa> your reasoning about IO being lazy
15:24:25 <Philippa> IO is normally considered largely strict, with exceptions for things like getContents
15:24:30 <Toxaris> Philippa: oh I should assume >>= = IOBind for IO?
15:24:44 <EvilTerran> getContents is cheating ;]
15:24:52 <Philippa> you should assume that nothing is evaluated until its evaluation is demanded :-)
15:25:17 <Philippa> and only the magic IO interpreter can demand the execution of an IO operation
15:25:48 <slava> or unsafePerformIO
15:26:04 <slava> :t unsafePerformIO
15:26:06 <lambdabot> Not in scope: `unsafePerformIO'
15:26:13 <monochrom> pattern matching also takes part, but of course only after some higher chain of demand gets to the pattern matching stage.
15:26:23 <Philippa> slava: assume for the purpose of discussion that we're talking about Haskell98. Compiler hacks don't count.
15:26:38 <Philippa> monochrom: there's a reason IO's abstract. You can't pattern match on it
15:26:41 <monochrom> Hahaha this is trendy. imperative "chain of command", lazy functional "chain of demand".
15:26:52 <Saizan> unsafePerformIO doesn't demand evaluation by itself, btw
15:26:58 <chessguy> ?where dlist
15:26:58 <lambdabot> http://www.cse.unsw.edu.au/~dons/dlist.html
15:27:13 <Philippa> saizan: it demands evaluation in exactly the sense that seq does
15:27:48 <Toxaris> const (unsafePerformIO $ putStrLn "never printed")
15:28:29 <Philippa> yes. That's because unsafePerformIO isn't itself evaluated there
15:28:44 <monochrom> Philippa: Yeah I mean if the IO interpreter executes some action and eventually reaches pattern matching of some user-written pure function.
15:28:53 <SamB> hmm.
15:29:19 <Toxaris> so unsafePerformIO turns "demand for pure computation" to "demand for IO action"
15:29:25 <Toxaris> but doesn't generate demand by itself
15:29:43 <Toxaris> the only root demand comes from the OS askind the magic IO interpreter to do something
15:29:47 <Toxaris> "asking"
15:31:15 <Toxaris> I think I see what you mean Philippa about my reasoning
15:31:25 <chessguy> SamB so running it is just dna2rna filename?
15:32:08 <SamB> chessguy: look at the Makefile
15:32:30 <Toxaris> so back to when is monad static or lazy: it's easy to understand for concrete monads (State is strict when >>= is strict in the state)), but may be not defined for monads in general
15:33:08 <desp> chessguy: yes
15:33:13 <desp> uses stdio
15:33:17 <desp> so < dna > rna
15:33:33 <Philippa> I have a fairly clear idea what I mean by it, but it's tricky to define - not least because it (potentially) involves a different _|_ to the haskell _|_
15:34:02 <Toxaris> oh there are different flavours of _|_?
15:34:22 <EvilTerran> well, there's <<loop>>, undefined, error "zomg"...
15:34:24 <Philippa> there's a _|_ for every type anyway :-) But I mean that monadic divergence isn't necessarily the same as haskell divergence
15:34:55 <Philippa> that's why I consider it possible for there to be a "strict" monad in which return is a non-strict function
15:35:03 <chessguy> desp, i'm talking about SamB's program :)
15:35:20 <ddarius> forever (putStr "hi")
15:35:26 <desp> chessguy: SamB actually referred you to my program
15:35:34 <Philippa> where return would in a sense be taking a thunk rather than a value as a parameter
15:35:44 <chessguy> oh
15:35:53 <desp> :)
15:36:06 <SamB> chessguy: hmm, which program are you looking at?
15:36:17 <SamB> desp: didn't I refer cdsmith to your program?
15:36:25 <desp> lol, yes.
15:36:29 <chessguy> dna2rna.hs on http://naesten.dyndns.org:8080/repos/icfp2007/
15:36:31 <lambdabot> Title: Directory listing for /repos/icfp2007/
15:36:40 <desp> chessguy: oh, no. that isn't mine, then.
15:36:47 <Philippa> whereas the big issue is the "strictness" of >>= viewed as application
15:36:58 <chessguy> i didn't think it was
15:37:03 <SamB> chessguy: again: look at Makefile ;-)
15:37:16 <chessguy> yeah, i am, but i don't really know what it means
15:37:16 <desp> chessguy: but pgup for SamB giving you a link
15:37:31 <desp> chessguy: what do you need help with?
15:37:32 <chessguy> desp, yes, i saw that
15:37:33 <Philippa> that is, if the LHS as a computation doesn't terminate (it's okay for the value yielded to be _|_ though), then LHS >>= ... doesn't either
15:37:44 <chessguy> desp, i'm trying to build/run SamB's program
15:37:52 <desp> chessguy: come to #haskell-icfp07, there's less traffic there
15:38:08 <SamB> chessguy: well, it means that if you have a DNA prefix in foo.prefix, you can run make foo.png and it should generate the rna followed by the requested png
15:38:13 <Philippa> does that make sense?
15:39:16 <EvilTerran> @paste
15:39:16 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:39:19 <Toxaris> Philippa: "doesn't terminate as a computation" = has a infinite representation in the initial term algebra {>>=, return}?
15:39:40 * Toxaris tries to use mathematical wording but surely fails with details telling pure crap in the end
15:40:01 <Philippa> Toxaris: nope, it's enough for me to introduce an equivalent of _|_ as a new operation
15:40:53 <Philippa> Maybe exhibits a property analogous to strictness...
15:41:32 <Philippa> (but it's not, because the evaluation function - fromMaybe - terminates for Nothing >>= ...)
15:41:57 <Toxaris> Philippa: oh that sounds interesting
15:43:13 <Toxaris> > Nothing >>= return "not returned" :: Maybe String
15:43:14 <lambdabot>  Couldn't match expected type `Maybe String'
15:43:30 <Toxaris> > (Nothing >>= return "not returned") "not used" :: Maybe String
15:43:31 <lambdabot>  Couldn't match expected type `t -> a'
15:43:38 <gnuvince_> Does anyone here know if there is a Vim indentation scheme for Haskell?
15:44:20 <jargonjustin> Is there a moderately implementation independent way to disable the monomorphishm restriction with a comment?
15:46:02 <magnus__> what is a CAF in a gch profile?
15:47:16 <ddarius> gnuvince: There's a mode for it.  I don't know if it includes any indentation stuff.  I just use ai.
15:47:52 <Toxaris> Philippa: so a monad is strict with respect to some bottom
15:48:36 <Philippa> right. Which may not be the haskell one because in the case of examples like IO it clearly can't be
15:48:48 <oerjan> isn't there supposed to be a LANGUAGE pragma?
15:48:58 <Toxaris> Philippa: it's not like a lifting of the Haskell-strict to monads, but it's an application of the mathematical idea of strictness to monads
15:49:10 <Philippa> yep
15:49:52 <dibblego> ?src foldl1'
15:49:52 <lambdabot> Source not found. The more you drive -- the dumber you get.
15:49:54 <dibblego> ?src foldl1
15:49:54 <lambdabot> foldl1 f (x:xs) = foldl f x xs
15:49:54 <lambdabot> foldl1 _ []     = undefined
15:50:05 <Toxaris> and a monad is strict with respect to a bottom if it's bind function is strict with respect to that bottom
15:50:17 <Toxaris> with bottom being a class of Haskell values, including _|_ or not
15:50:32 <Toxaris> and strictness w.r.t a bottom is: if the argument is in the class, the result is, too
15:50:54 <oerjan> found it. jargonjustin: {-# LANGUAGE NoMonomorphismRestriction #-} is the portable syntax
15:50:57 <ddarius> Preservation of "bottoms"
15:51:24 <jargonjustin> oerjan: Thanks, is there documentation on the portable options anywhere?
15:52:18 <oerjan> http://haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#language-pragma
15:52:20 <lambdabot> Title: 7.10. Pragmas, http://tinyurl.com/ysbfs7
15:52:41 <chessguy> ddarius, that sounds like a great team name
15:53:15 <jargonjustin> oerjan, wonderful, thank you
15:53:18 <chessguy> or maybe "Preservation of fuun 'bottoms'
15:53:22 <Toxaris> chessguy: but it's kind of a synonym for strictness, and who want's strictness in it's team name
15:53:30 <Toxaris> chessguy: Haskell is about ignoring bottoms
15:53:38 <chessguy> @quote bottoms
15:53:38 <lambdabot> monochrom says: 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice.  Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.
15:53:38 <lambdabot> Licence to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
15:53:48 <chessguy> @quote interested.bottoms
15:53:48 <lambdabot> No quotes match. Are you on drugs?
15:54:03 <chessguy> @quote bottoms
15:54:03 <lambdabot> xerox says: I am really interested specifically in bottoms in this very moment.
15:54:06 <chessguy> there we go
15:56:02 <desp> is anyone in the mood to explain to me exactly what bang patterns and `seq` do?
15:56:18 <desp> I think I mostly have the idea
15:56:54 <Toxaris> desp: exactly like Core output generated? or exactly like clearly?
15:56:56 <ddarius> undefined `seq` 3 = undefined, AnythingElse undefined `seq` 3 = 3
15:57:11 <ddarius> Bang patterns expand to usages of seq
15:57:29 <desp> Toxaris: clearly :)
15:57:56 <desp> ddarius: so seq make the order of evaluation explicit
15:57:58 <desp> makes*
15:58:00 <jedai> @src sequence
15:58:00 <lambdabot> sequence ms = foldr k (return []) ms
15:58:00 <lambdabot>     where
15:58:00 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
15:58:48 <ddarius> desp: No, it changes it.  It forces it's first argument even if it is not needed.
15:58:56 <Toxaris> desp: seq enables you to specify the order of evaluation explicitly
15:59:08 <desp> right
15:59:31 <desp> and bang patterns?
15:59:44 <desp> I can't parse "expand to usages of seq"
15:59:45 <desp> :)
15:59:57 <Toxaris> f !x = expr    ==    f x = x `seq` expr
16:00:02 <desp> ohh.
16:00:06 <desp> thanks a lot!
16:00:23 <Toxaris> hmm wait
16:00:24 <desp> now I can.
16:00:51 <Toxaris> that would mean: if f is evaluated at all, x is evaluated to whnf
16:01:00 <Toxaris> is this what we want? yes, we want
16:01:03 <Toxaris> stop waiting
16:01:06 <desp> :)
16:01:10 * desp resumes
16:01:22 * Toxaris is confused by talking about different kinds of bottoms
16:01:41 <jethr0> could someone help me with a space leak problem?
16:02:01 <ddarius> jethr0: God.
16:02:11 <jethr0> god?
16:02:41 <Saizan> how many olegs is god?
16:02:45 <ddarius> Well, if God can't help you, I doubt anyone else can.
16:03:02 <jethr0> god = 0.98 olegs
16:03:15 <Saizan> thought so :)
16:03:22 <Pseudonym> ?quote OlegFacts
16:03:22 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
16:03:22 <jethr0> i meant that rather as a call for help in this channel ;)
16:03:47 <Toxaris> Philippa: It may be worth to speak about "monotone monads" instead of "strict monads", given that monotonicity is strictness for a simple enough lattice. But strictness sounds like Haskell strictness, and monotonicity sounds like "ok, wich lattice?", wich may be more approbiate for your custom bottoms
16:03:48 <jethr0> ?quote OlegFacts
16:03:48 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
16:04:06 <ddarius> which
16:04:13 * Pseudonym likes the phrase "custom bottoms"
16:04:21 <Saizan> jethr0: can you reduce it to something that can be pasted?
16:04:37 <dibblego> please don't talk about custom bottoms on Haskell-Cafe (I cringe at the amount of noise it will generate)
16:04:39 <jethr0> Saizan: not really, i've written a compiler for the icfp contest
16:04:48 <jethr0> so it's a lot of code
16:04:59 <oerjan> "Savant Syndrome describes a person having both a severe developmental or mental handicap and extraordinary mental abilities not found in most people."
16:05:01 <jethr0> do you have any pointers as how to approach this generally
16:05:03 <oerjan> argh!
16:05:07 <oerjan> wrong channel
16:05:31 <jethr0> Saizan: i ran it with -hc and it shows me one "thingey" that grows rapidly
16:05:34 <Toxaris> oerjan: it's not about hackers?
16:05:38 <ddarius> Ahh, the secret to Fresca, carob bean gum.
16:05:59 <jethr0> @paste
16:05:59 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:06:25 <hpaste>  jethr0 pasted "-hc output" at http://hpaste.org/1857
16:06:31 <oerjan> Toxaris: ?
16:08:16 <magnus__> Do monad transformers kill performance?
16:08:28 <Toxaris> oerjan: should have been a joke about extraordinary mental abilities found in Hackers but not in most peoples.
16:08:42 <Saizan> jethr0: i've not seen much written on space leaks, sometimes they are caused by building a huge thunk reducing a big structure down to a simple value
16:08:56 <jethr0> hmm
16:09:13 <jethr0> i've had my fair share of problems with them, but never managed to tackle them in a structured way
16:09:30 <ddarius> Extraordinary mental abilities including such things as: following simple directions, using logic.
16:09:35 <oerjan> Toxaris: i guess there is some intersection between the groups.
16:09:43 <Saizan> or by keeping  references to something that should be GCed
16:10:26 <jethr0> ddarius: no, i think "following simple instructions" falls under the "severe developmental handicap"
16:11:23 <Toxaris> oerjan: http://en.wikipedia.org/wiki/Asperger_syndrome
16:11:24 <lambdabot> Title: Asperger syndrome - Wikipedia, the free encyclopedia
16:12:31 <Toxaris> oerjan: from a naive point of view, it's the medical name for being a geek
16:13:48 <Toxaris> oerjan: or better, a light form of asperger syndrome is being a geek, the full thing is far worse, of course
16:14:55 <oerjan> yeah
16:15:28 <Pseudonym> In general, autism is a spectrum.
16:15:37 <Pseudonym> There's slightly geeky at one end and Rain Man at the other.
16:16:07 <Pseudonym> But don't forget, interest in celebrities, or sport, or pop culture, is just a geeky interest that happens to be shared by the majority.
16:16:26 <Pseudonym> Unless it's feigned interest, I guess.
16:16:28 <jargonjustin> Will "filter f . map m" require one or two passes over a list?
16:16:35 <Pseudonym> jargonjuston: One.
16:16:42 <Pseudonym> justin
16:16:45 <jargonjustin> Pseudonym: Thanks, go go lazyness
16:16:48 <Pseudonym> Yeah.
16:17:02 <Pseudonym> In the absence of optimisation, there will be an "intermediate list" formed.
16:17:11 <Pseudonym> But it's transient storage.
16:17:14 <Pseudonym> The whole list is never stored.
16:17:19 <Pseudonym> Only the cell you're working on.
16:17:26 <Pseudonym> In the presence of optimisation, there probably won't even be that.
16:17:37 <jargonjustin> I'm more concerned with time than space performance anyway.
16:17:43 <jargonjustin> Thanks again.
16:17:43 <Pseudonym> Right.
16:17:46 <Pseudonym> No problem./
16:18:03 <ddarius> space performance is highly related to time performance
16:18:41 <Pseudonym> In this case, even when there's no optimisation, the locality is high.
16:18:53 <Pseudonym> Because the cell that filter is reading is the one that map just made.
16:19:13 <Pseudonym> And it's also the one that the generational GC sees next.
16:19:22 <ddarius> Well the space performance is good either way in terms of live data.
16:19:27 <Pseudonym> Yeah.
16:19:27 <jargonjustin> ddarius: Yes, but I was essentially trying to decide if I would need to rewrite my function using a fold to achieve good performance (the non-fold way is more readable)
16:19:41 <Pseudonym> jargonjustin: There's only one way to find out.
16:19:55 <Pseudonym> Profile.
16:19:56 <ddarius> Assuming finding out is even worthwhile.
16:20:37 <jargonjustin> Pseudonym: Yeah, but I'd rather get things working first.  The question was part premature optimization and part making sure I understood Haskell's semantics properly
16:20:46 <Pseudonym> Yeah.
16:21:00 <ddarius> jargonjustin: You can always calculate.
16:21:02 <Pseudonym> One thing you'll find is that Haskell performance is really different from imperative languages.
16:21:24 <Pseudonym> Generally speaking, unless it's something dumb like an O(N^2) algorithm, you almost always can't predict where the bottleneck will be.
16:21:27 <ddarius> Strict, not (just) imperative.
16:21:28 <EvilTerran> (head . sort) could very well be linear
16:21:43 <Pseudonym> Assuming there is one.
16:22:15 <Pseudonym> You wouldn't write the equivalent of filter f . map m in a strict language unless you knew it wasn't critical.
16:23:14 <Pseudonym> (I did it once in C++/STL, but it was generating an error message in a compiler.  Generating error messages is almost always not performance-critical in a compiler.)
16:23:52 <ddarius> Pseudonym: Was this before the advent of "modern C++"? (STL suggests no.)
16:24:25 <Pseudonym> No, but it was in an existing codebase.
16:24:29 <EvilTerran> modern C++?
16:24:45 <Pseudonym> EvilTerran: All praise Sutter and Andrescu.
16:24:57 <Eelis> EvilTerran: C++ programs look a lot different now from 10 years ago
16:25:04 <Eelis> let alone 20 years ago
16:25:05 <Pseudonym> Andreescu
16:25:09 <EvilTerran> i have no idea what you guys're talking about
16:25:19 <phoniq> and the boost crew
16:25:21 <Pseudonym> EvilTerran: If you don't speak C++, you don'
16:25:27 <Pseudonym> t need to worry.
16:25:45 <EvilTerran> i've done a little C++, but just tinkering, no full-scale projects.
16:25:50 <Pseudonym> Right.
16:26:26 * EvilTerran goes back to fiddling with cabal
16:26:33 <phoniq> when they figured out that c++ templates were a little purely-functional programming language, things started to get interesting
16:26:36 <Pseudonym> Alexandrescu
16:26:38 <Pseudonym> That's his name.
16:26:58 <EvilTerran> phoniq, aha... i like where this is going...
16:28:04 <Pseudonym> "Modern C++ Design" is the name of a book by Alexandrescu.
16:28:14 <Pseudonym> Templates were introduced to make things like arrays.
16:28:16 <Pseudonym> Then came the STL.
16:28:22 <phoniq> there are features in the new c++ standard inspired directly by haskell type classes
16:28:30 <Pseudonym> And "Modern C++" is the natural extension of that.
16:28:32 <phoniq> Concept Maps
16:28:37 <Pseudonym> Yeah.
16:29:09 <phoniq> the guy who did the first implementation in gcc confirmed this to me
16:29:12 <EvilTerran> how recently did all this happen? it may well be before i even looked at C++
16:29:26 <phoniq> c++ used to look like java looks today
16:29:35 <phoniq> classes and virtual functions, not much else
16:29:42 <phoniq> (not my cup of tea)
16:29:51 <phoniq> its much different now
16:29:52 <EvilTerran> java is coffee...
16:30:06 <Toxaris> so programming language research done for and in Haskell trickle's through to mainstream languages, even if Haskell stays non-mainstream?
16:30:09 * ddarius doesn't drink coffee.
16:30:24 <ddarius> Toxaris: This is happening all over the place.
16:30:25 <Toxaris> java has interesting stuff, too
16:30:26 <phoniq> they're exploiting the type inference that you get from c++ templates as much as they can
16:30:33 <augustss> Toxaris: look at LINK in C#
16:30:35 <Pseudonym> Toxaris: Basically, yes.
16:30:41 <ddarius> LINQ
16:30:44 <augustss> sorry, LINQ
16:30:48 <qwr> EvilTerran: C++ standard has not much changed past 9 (?) years. although working compilers appeared later. and interesting boost libs even more later i think.
16:31:12 <EvilTerran> so the STL's been around ~9yr in its current form, then?
16:31:13 <augustss> LINQ is just monads
16:31:14 <phoniq> yah, the boost libraries have pushed the compiler vendors
16:31:24 <phoniq> to get it together and implement the standard
16:31:26 <qwr> although there is new C++ standard draft
16:31:32 <Pseudonym> So have big software houses who want to use the features, like Adobe.
16:31:33 <thorat> I think STL is since 1994
16:31:44 <thorat> templates were implemented before standardized
16:31:51 <Toxaris> java syntax is unusable, but there's parametric polymorphism (aka generics), closures (aka anonymous inner classes), ...
16:32:16 <ddarius> broken parametric polymorphism and broken closures
16:32:22 <ddarius> Use C# instead.
16:32:22 <dibblego> ddarius++
16:32:22 <phoniq> but the generics are just syntactic sugar on virtual functions iiuc
16:32:49 <dibblego> use *Scala* instead
16:32:52 <Saizan> yeah there's not JIT specialization like in C#
16:32:56 <Toxaris> I use Haskell instead
16:32:58 <Saizan> *no
16:33:00 <ddarius> Preferably Scala, yes.
16:33:14 <Pseudonym> What I'd like is C++ where the inner C stuff has a worse syntax.
16:33:18 <dibblego> I am annotating a type parameter as co-variant as we speak :)
16:33:21 <qwr> scala or kawa. if you need to run on jvm.
16:33:29 <Pseudonym> Freeing up the operators for something more useful.
16:33:44 <Pseudonym> Rather than int* foo; *foo = 1;
16:33:46 * qwr likes creating little dsl's with scheme macros in kawa
16:33:50 <Toxaris> ddarius: why broken?
16:33:53 <Pseudonym> I'd like: ptr<int> foo; deref<foo> = 1;
16:34:04 <Pseudonym> deref(foo) = 1;
16:34:15 <Pseudonym> That way, "*" can be used for something nice.
16:34:22 <Toxaris> phoniq: generics in java are typesystem only
16:34:25 <Saizan> writeRef foo 1 :)
16:34:28 <dibblego> Toxaris, all type parameters are invariant, a type parameter cannot be defined over another type parameter (just a start)
16:34:44 <ddarius> Parametric polymorphism: A List<T> is actually just a List underneath with implications on performance and reflection, Closures: They don't close over mutable variables properly (or at all, I forget which).
16:34:53 <slava> ddarius: at all
16:34:54 <Pseudonym> Saixan: Something like that, yeah.
16:35:03 <ddarius> Pseudonym: Such as?
16:35:08 <ddarius> slava: That's what I thought.
16:35:40 <Toxaris> ddarius, dibblego: broken /= restricted
16:35:43 <Saizan> Pseudonym: it's also more readable imo
16:35:45 <EvilTerran> and who needs standardized GC anyway!
16:35:56 <qwr> i don't miss the mutable vars in closure much. at worst they can be emulated with array... but the syntax is horribly verbose
16:35:56 <dibblego> Toxaris, that qualifies as broken for me, by a long shot
16:36:01 <Pseudonym> The benefit of such a language is that a) it retains the main strengths of C++ (link compatibility with C, the ability to write the library in the language), while getting rid of the main problem (C syntax).
16:36:08 <dibblego> Toxaris, a fart is not a "restricted car"
16:36:15 <ddarius> Toxaris: The reflection thing is broken.  The closure thing is broken to.  Restricted can well mean broken.
16:36:15 <Pseudonym> I left out a b), but you can put it in.
16:36:43 <augustss> Java is crippled because they wanted to keep backwards compatibility
16:37:00 <dibblego> augustss, that and it was never well written in the first place
16:37:04 <ddarius> The should have started with a better legacy.  They definitely could've.
16:37:17 <augustss> C# is in a little better shape because they added generics early in the life cycle
16:37:23 <slava> who cares about java?
16:37:24 <Pseudonym> I'm not certain about that.
16:37:27 <slava> this is #haskell
16:37:35 <Pseudonym> Fact is, you don't know what you want until you've done it.
16:37:44 <Pseudonym> That's one strength of Haskell, actually.
16:37:52 <ddarius> Pseudonym: They'd done it!
16:37:53 <Pseudonym> It was a clean break with Miranda, which let us clean out the cruft.
16:38:15 <Pseudonym> Well, some of the cruft.
16:38:15 <augustss> Miranda and half a dozen other languages
16:38:45 * Pseudonym used a couple of those other languages
16:38:59 <ddarius> Pseudonym: You don't like (>>=) :: * ** -> (** -> * ***) -> * ***?
16:39:02 <phoniq> OT: anybody happen to know if there is good haskell/FP stuff going on at the University of Maryland in the u.s.?
16:39:06 <thorat> my boss used Miranda back in the early 80's
16:39:07 <Pseudonym> Why no.  No, I don't.
16:39:11 <thorat> how that for PHB
16:39:14 <thorat> :)
16:39:16 <Pseudonym> That's impressive.
16:39:25 <Pseudonym> Miracula wasn't too bad.
16:39:28 <ddarius> Pseudonym: What the heck were they thinking?
16:39:31 <Pseudonym> Orwell was... uh... crap.
16:39:37 <ddarius> (And by they, I mean, Turner)
16:39:53 <Pseudonym> ddarius: See above comment about not knowing what you want until you've done it.
16:40:11 <ddarius> So you settle on a unary notation for type variables?!
16:40:24 <Pseudonym> And for the record, Miranda was a huge improvement on KRC.
16:40:30 <augustss> unary is ok if you don't have more than 3 variables
16:40:34 <Pseudonym> I never used KRC, but I translated some KRC code into Miranda.
16:40:52 <augustss> man, KRC was slow
16:41:30 <Saizan> mmh maybe they wanted to telegraph their types?
16:41:34 <augustss> but by that time i was writing a compiler to machine code anyway
16:42:43 <dibblego> does the term "side effect" have any other meaning among the Java/C programmers?
16:43:13 <augustss> dunno, my brain has been warped for too long now
16:43:29 <ddarius> I think the term "side effect" is pretty universal in broad strokes.
16:43:35 <phoniq> me too
16:44:01 <dibblego> a Java/C programmer told me that a "memory leak was a side effect" (because it was unintended? I'm a bit vague on the definition)
16:44:27 <ddarius> Depending on context, that could just be the general use of the phrase.
16:44:29 <Toxaris> there is   side effect = effect of functions besides returned value  as in Haskell
16:44:34 <dibblego> and that "side effect" only meant what I meant it to be in "functional programming"
16:44:58 <dibblego> I want to break the divide between "the functional programmers" and "the other programmers"
16:44:59 <qwr> dibblego: they would probably restrict it to unexpected side effects - since in their world the program consists of sequence of side effects and therefore the general meaning of sideeffect would be meaningless
16:45:06 <Toxaris> but it's not used that often due to lack of laziness (there's only a couple of lazy functions after all, like (||) and (&&))
16:46:04 <Toxaris> so side effect is also used as unintended effect frequently
16:46:24 <dibblego> so then, I should accept this definition?
16:46:29 <Toxaris> even as "i know about but can't help because i need some other part of the effect"
16:46:30 <Philippa> Toxaris: in mainstream english, yes
16:46:47 <Toxaris> in mainstream english used by imperative computer programmers talking about their programs, too
16:46:57 <EvilTerran> i think it's side-effect as in side-effect of a drug
16:46:58 <Toxaris> but not by Haskell programmers talking about their programs
16:47:24 * sfultong enters #haskell
16:47:25 <Toxaris> because the mainstream definition is shadowed in Haskell community
16:47:26 <dibblego> Toxaris, but not by Java programmers, who have used Haskell (where Haskell is a metaphor for knowing any decent language)
16:47:44 <dibblego> Haskell doesn't shadow it; programming shadows it
16:48:00 <EvilTerran> compare "this stops you dying, but makes your hair fall out"; "this finds the shortest path between two points, but leaks like a sieve"
16:49:04 <Toxaris> dibblego: hmm ok, there's "this function is called for it's side effect"
16:49:43 <Saizan> well some imperative programmers make a  distrinction between functions and procedures, where the formers don't have side effects
16:50:00 <EvilTerran> um. i just started xmonad with another WM running. this is... interesting...
16:50:08 <dibblego> Saizan, so that means those programmers acknowledge the "Haskell definition" of side-effect
16:50:46 <Toxaris> Saizan: I do it all the time, restricting Haskell-like side effects to as few methods as possible when forced to use Java
16:51:15 <dibblego> Toxaris, even the least skilled Java programmer does it; he just calls it something else
16:51:27 <dibblego> usually a marketing term with lots of loading
16:51:41 <Toxaris> dibblego: "Immutable Object Pattern"
16:51:55 <dibblego> Toxaris, "refactor"
16:52:02 <Saizan> yeah, but i had this concept way before knowing FP, pascal has this distinction in the language maybe? i can't remember
16:52:19 <dibblego> Saizan, I agree, that's my point too
16:52:34 <EvilTerran> excuse me, i think i need to restart X...
16:53:58 <Toxaris> In a sense, it's obvious: don't change anything, so you don't destroy anything
16:54:18 <dibblego> if it were obvious, then marketing would cease to exist
16:54:26 <dibblego> it might be obvious to you and I
16:55:38 <Toxaris> after learning a language, my understanding and usage of all languages I know improves
16:56:11 <qwr> dibblego: C++ has const methods which can't change class fields. pascal function/procedure distinction was that procedure didn't returned a value
16:56:14 <Toxaris> so maybe I've learned this lesson using some other language, and applied it to java
16:56:29 <Toxaris> C++ consts are cool
16:56:47 <Toxaris> but not really safe i remember reading somewhere
16:56:50 <dibblego> qwr, I understand all that; my point is, should I accept this broadly unfamiliar definition of "side-effect"? I think no
16:57:21 <qwr> const_cast can override all constness iirc
16:58:00 <qwr> dibblego: better accept both meanings depending on context ;)
16:58:16 <dibblego> qwr, but does that meaning even exist?
16:58:36 <dibblego> how many people accept this meaning?
16:59:47 * qwr thinks the meaning as used sometimes in the imperative programming world is a bit fuzzy ;)
17:00:30 <dibblego> I think "fuzzy" can mean "contains an inherent contradiction if the subject purporting that meaning were to be guided as Socrates suggests"
17:01:04 <Saizan> i see it as "don't do I/O and not modify global state"
17:01:19 <dibblego> so do I, but does everyone?
17:03:38 <qwr> (I/O modifies the global state anyway)
17:03:56 <dibblego> if you look at it that way
17:28:12 <jedai> @src token
17:28:12 <lambdabot> Source not found. Just what do you think you're doing Dave?
17:28:20 <jedai> @src Parsec.token
17:28:20 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
17:28:32 <timtheli`> hi, I have a multiline function that requires several custom types defined with data.  I would like to test this function interactively in ghci are there any like elisp scrips for doing this?
17:28:57 <mm_freak> @src getStdGen
17:28:58 <lambdabot> Source not found. Wrong!  You cheating scum!
17:29:22 <mm_freak> @src System.Random.getStdGen
17:29:22 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
17:29:33 <timtheli`> how many phrases are there?
17:30:12 <mm_freak> probably infinitely many, since lambdabot is written in haskell =)
17:30:41 <timtheli`> mm_freak: ;)
17:30:43 <oerjan> jedai: Text.ParserCombinators.Parsec.Prim.token
17:30:50 <oerjan> @index token
17:30:51 <lambdabot> Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec
17:30:55 <timtheli`> does lambdabot have a homework mode?
17:31:01 <jedai> @src Text.ParserCombinators.Parsec.Prim.token
17:31:02 <lambdabot> Source not found. Maybe if you used more than just two fingers...
17:31:14 <oerjan> timtheli`: you can /msg it
17:31:31 <Pseudonym> timtheli: Yes.  It posts a message to haskell-cafe claiming that the problem can't be solved in the type system, then waits for Oleg to write a paper.
17:31:54 <timtheli`> lol
17:32:01 <ddarius> @quote cafe
17:32:01 <lambdabot> DavidRoundy says: ... the fun of haskell-cafe is that it's where all the cool people hang out
17:32:05 <ddarius> @quote cafe
17:32:06 <lambdabot> DavidRoundy says: ... the fun of haskell-cafe is that it's where all the cool people hang out
17:32:18 <Pseudonym> ?quote Oleg
17:32:18 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
17:32:22 <Pseudonym> ?quote Oleg
17:32:22 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
17:32:31 <mnislaih> Toxaris, there? I pushed a patch to the icfp repo.
17:32:33 <Pseudonym> ?quote type system
17:32:33 <lambdabot> No quotes for this person. Sorry about this, I know it's a bit silly.
17:32:33 <Toxaris> hi mnislaih
17:32:35 <ddarius> @quote OlegFact
17:32:36 <lambdabot> No quotes match. Wrong!  You cheating scum!
17:32:38 <Toxaris> here i am
17:32:38 <Pseudonym> ?quote system
17:32:39 <lambdabot> apfelmus says: Haskell is the first programming language that really offers the possibility to specify data dependencies exactly as they are because Haskell is pure, higher order and has a powerful
17:32:39 <lambdabot> type system.
17:32:42 <Pseudonym> ?quote system
17:32:42 <lambdabot> Cale says: I should actually think before coding, but the type system is so good :)
17:32:47 <mnislaih> The stack of monads was producing a severe performance hit !
17:32:50 <mnislaih> up to 3X
17:32:53 <Pseudonym> There _is_ a quote about that somewhere.
17:33:03 <mnislaih> I am surprised that the wiki page on performance doesn't mention this
17:33:06 <Toxaris> you mean, we are 3x faster now
17:33:12 <mnislaih> yep
17:33:20 <mnislaih> who cares anyway, heh
17:33:50 <mnislaih> I also stole some improved compacting routines from desp
17:34:00 <mnislaih> we are more than 3x faster
17:34:03 <desp> thief, thief
17:34:05 <mnislaih> around 6x
17:34:21 <mnislaih> but I still dont understand why desp code beats us by 3X more
17:34:26 <mnislaih> :S
17:34:26 <Toxaris> how fast? about 20k/s?
17:34:28 <timtheli`> desp: you let him get away with it, you better hide your sorry...
17:34:32 <mnislaih> about 15ks
17:34:33 <oerjan> @source Text.ParserCombinators.Parsec.Prim
17:34:33 <lambdabot> http://darcs.haskell.org/packages/parsec/Text/ParserCombinators/Parsec/Prim.hs
17:34:54 <Toxaris> i have so many ideas about improving at a high level
17:34:56 <mnislaih> so, we are 7.5x faster
17:35:10 <phoniq> are there libs/examples around to help with pruning/transforming a Data.Tree?
17:35:23 <mnislaih> Toxaris: try them
17:35:35 <Toxaris> but i probably will never code them up to "oh well it's over anyway"
17:36:15 <Toxaris> ...code them up due to "oh well...
17:36:50 <mnislaih> I learnt a few things during the process. Didnt know that stacked monads could bite so heavily
17:37:07 * mnislaih wonders if he should add a note in the performance wiki page
17:37:08 <desp> mnislaih: can I see your code?
17:37:14 <desp> I want to use more monads
17:37:26 <dons> mnislaih: about mtl and performance?
17:37:30 <mnislaih> desp sure, I can give a link. But I flattened them
17:37:35 <mnislaih> dons yup
17:37:49 <desp> ok, I still wanna see
17:37:54 <desp> looking for haskell inspiration
17:38:01 <dons> might be a good idea; mtl doesn't inline well, and may even have been built without optimisations
17:38:13 <dons> we had to inilne our own defns, in Data.Binary
17:38:15 <dons> rather than use mtl
17:38:38 <mnislaih> http://ender4.dsic.upv.es:81/darcs/tnt/
17:38:39 <lambdabot> Title: Index of /darcs/tnt
17:38:44 <dons> so my suspicion is that mtl would be fine with some aggressive inlining
17:39:02 <mnislaih> dons it is extremely slow, so I'd better add a note to the wiki
17:39:09 * mnislaih will do that tomorrow
17:39:59 * jethr0 heads to the wiki page on speed optimization
17:40:12 <mnislaih> desp: I just updated the repo, in case you were looking at it
17:40:19 <zeeeee> mnislaih: what team are you?
17:40:28 <desp> I did a darcs get
17:40:33 <mnislaih> Team Named Thunk (tnt)
17:40:36 * Toxaris waves TNT banner
17:40:36 <desp> I'll look into it later on
17:40:41 <mnislaih> desp: unpull two patches, and pull
17:40:51 <mnislaih> otherwise you'll get conflicts
17:40:59 <desp> ok
17:41:05 <desp> unpulled   * Fix conflicts
17:41:07 <mnislaih> desp: you won't understand our DNA code ...
17:41:12 <desp> and   * Remove all the Gtk dependencies
17:41:14 <desp> that ok?
17:41:17 <mnislaih> yep
17:41:31 <desp> wow, that's a lot of patches
17:41:43 <desp> I wish I wasn't the only haskeller on my team
17:49:04 <dons> kolmodin   oriiginally wrote @unmtl because of the performance issues in mtl :)
17:49:13 <dons> ?unmtl StateT Int IO a
17:49:13 <lambdabot> Int -> IO (a, Int)
17:49:23 <oerjan> @help unmtl
17:49:23 <lambdabot> unroll mtl monads
17:52:52 <Pseudonym> Mind you, it's arguably insufficient optimisation issues.
17:54:00 <mnislaih> what kind of optimisations would help it ? Specialization rules or something so '
17:54:02 <mnislaih> ?
17:54:30 <Pseudonym> StateT Int IO a should be the same as Int -> IO (a, Int)
17:54:47 <Pseudonym> I have no idea without looking at the generated code, though.
17:58:17 <dons> Pseudonym: yeah, i think itis just inlining, and possibly even mtl not being compiled with optimisations, due to cabal bugs
17:58:26 <Pseudonym> Right.
17:58:26 <dons> ghc-options:	-Wall
17:58:51 <dons> i'm not sure which version of cabal will even optimise this. it should have -O2 to get maximum unfolding
18:00:56 <mnislaih> does unmtl unroll monads or only the types ?
18:06:04 <mnislaih> dons: I'm not sure about -O2. I recompiled and reinstalled mtl with -O2 to make sure, but performance numbers look the same
18:06:34 <mnislaih> which means either it was already compiled with -O2, or that -O2 didn't make a difference
18:07:49 <mnislaih> I would say it was not, since I had the hackage version which doesn't have -O2
18:13:57 <mnislaih> http://www.haskell.org/haskellwiki/Performance/Monads
18:13:58 <lambdabot> Title: Performance/Monads - HaskellWiki
18:14:45 <hpaste>  ptolomy pasted "semi-obfuscated haskell" at http://hpaste.org/1858
18:17:49 <ptolomy> I don't remember how that works anymore, and it hurts my head to bother trying.
18:19:04 <ihope> What does main do?
18:19:15 <ptolomy> prints "Hello there. :)".
18:19:24 <ihope> !
18:19:38 <ihope> Well, cccC x = replicate x 'c'
18:19:46 <ihope> cc = map, obviously.
18:20:08 <ihope> cCCc is (.)... well, sheesh, let's do this from the top down.
18:20:35 <ptolomy> the lack of an internal distinction between 'c' and 'C' makes it tricky without manually subtituting.
18:20:38 <ptolomy> Really, that's the only way.
18:21:10 <ptolomy> (lack of internal distinction for me, that is. I say "ccCc" the same way I say "cCcC" in my head)
18:21:22 <ihope> Say C louder than c.
18:21:31 <ihope> Much louder.
18:21:40 <ihope> main = (putStrLn . const ((const cCCC) (...))) putStrLn
18:21:54 <ptolomy> I'm trying it tonally. :)
18:22:25 <ihope> main = (putStrLn . const cCCC) putStrLn; main = putStrLn (const cCCC putStrLn); main = putStrLn cCCC
18:23:22 <ihope> ...where's cCC defined?
18:23:39 <ihope> Oh, I see.
18:23:55 <ihope> cCC = (`cCcC` 31)
18:23:56 <ptolomy> cCCC = map (chr . $ 31) (map (...) ccc)
18:24:36 <LordBrain> Anyone here familiar with MaybeT ?
18:24:50 <LordBrain> i'm googling for examples, but it appears they are scarce
18:25:32 <LordBrain> first question, is this transformer provided with the latest GHC?
18:25:42 <ihope> cCCC = map (chr . (`cCcC` 31)) (map ((foldr1 (.)) . map (const succ)) ccc)
18:26:03 <ihope> map (const succ)? Sheesh.
18:26:28 <slava> :t const
18:26:32 <lambdabot> forall a b. a -> b -> a
18:26:41 <halassocracy> hi LordBrain
18:26:47 <LordBrain> hi halassocracy
18:26:57 <ihope> Some bracing for clarity: map {chr . (`cCcC` 31)} {map ({foldr1 (.)} . map {const succ}) ccc}
18:28:11 <ihope> Much better. ({foldr1 (.)} . map {const succ}) x = (+ length x)
18:29:24 <ihope> cCCC = map {chr . ($ 31)} {map (\x -> {+ length x}) ccc}
18:29:52 <ihope> Take the length of each element of ccc, add 31, and translate to a character.
18:30:26 <ptolomy> Ah, simple enough. :)
18:30:40 <jedai> I have a tailcall that I can't strictify, is there something I'm missing ?
18:30:58 <dibblego> jedai, seq? foldl' ?
18:31:16 <dibblego> ?src foldl'
18:31:16 <lambdabot> foldl' f a []     = a
18:31:17 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
18:31:17 <ihope> cccC returns a list with the given length, so ccc as numbers is [41,74,1,85,73,70,83,70,15,1,27,10]
18:31:25 <jedai> I know about them...
18:31:31 <ihope> > map (chr . (+31)) [41,74,1,85,73,70,83,70,15,1,27,10]
18:31:33 <lambdabot>  "Hi there. :)"
18:31:48 <ihope> c = cccC 1
18:32:00 <jedai> But I still have a problem... (which is where I wonder if I'm really tailcall
18:32:30 <dibblego> jedai, a tail call is not executed in constant stack space, just because it is a tail call
18:32:36 <dibblego> (necessarily)
18:32:52 <jedai> dibblego: Not in Haskell, no
18:33:20 <sgillespie> Help me understand how to use seq to force evaluation of the first argument
18:33:28 <sgillespie> I can't seem to get that...
18:33:28 <dibblego> ?type seq
18:33:30 <lambdabot> forall a t. a -> t -> t
18:33:40 <dibblego> > seq 7 undefined
18:33:41 <lambdabot>  Undefined
18:33:56 <dibblego> ?type flip seq
18:33:58 <lambdabot> forall a b. b -> a -> b
18:34:04 <jedai> dibblego: Most of the time it is, still (since Haskell and friends don't put real data on the stack but rather boxed data)
18:35:04 <jedai> sgillespie: f a b = a `seq` whatever your function did before
18:36:07 <jedai> sgillespie: note that with GHC, you can write f !a b = ... for the same effects (with -fbang-patterns option)
18:36:21 <sgillespie> huh...
18:38:06 <LordBrain> @type maybe
18:38:08 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
18:39:15 <jedai> dibblego: Ok, I got it, the laziness was hidden in one of the
18:39:29 <sgillespie> can you give me a more concrete example?  I still can't figure it out
18:39:32 <jedai> datatype I used (nasty thing that)
18:40:40 <jedai> sgillespie: second a b = b, second undefined 3 -> 3, second' a b = a `seq` b, second' undefined 3 -> undefined
18:44:02 <LordBrain> i have two functions: getSavedNodeFromFile:: IO (Maybe Node)    getRandomNode:: IO Node    and I want to combine them into one function which tries the first and then tries the next if it gets back Nothing.  What is an elegant way to do this? and is this a place I could use something like MaybeT ?
18:44:51 <EvilTerran> ?type fromMaybe
18:44:53 <lambdabot> forall a. a -> Maybe a -> a
18:44:54 <LordBrain> could i rewrite it so that each of them have type: MaybeT IO node
18:45:07 <EvilTerran> liftM2 getRandomNode getSavedNodeFromFile
18:45:08 <LordBrain> and i use the `mplus` operator from Maybe
18:45:11 <EvilTerran> er, wait
18:45:18 <EvilTerran> this: "liftM2 fromMaybe getRandomNode getSavedNodeFromFile"
18:46:03 <Toxaris> EvilTerran: but IO is strict (whatever this means...)
18:46:19 <Toxaris> so getRandomNode is called even if it's result is not used by fromMaybe?
18:47:02 <EvilTerran> ...shouldn't be... **thinks**
18:47:24 <Toxaris> but i'm not sure about it
18:47:42 <sgillespie> so seq doesn't seem to evaluate anything IO
18:48:16 <EvilTerran> sgillespie, indeed not
18:48:34 <Toxaris> EvilTerran: LiftM2 will introduce >>=, but mplus seems more approbiate
18:48:37 <sgillespie> that makes me feel better
18:49:05 <EvilTerran> Toxaris, ah, yes, you're right.
18:49:08 <EvilTerran> @src liftM2
18:49:08 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
18:49:26 <chessguy> @type gets
18:49:28 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
18:49:59 <newsham> @endo IIPIFFCPICICIICPIICIPPPICIIC
18:49:59 <lambdabot> IIPIFFCPICICIICPIICIPPPICIIC
18:51:01 <sgillespie> so what if I want to evaluate something and then return another type?? (and guarantee evaluation of both)
18:51:13 <EvilTerran> Toxaris, actually, i don't think the IO strictness is a problem here
18:51:54 <EvilTerran> > do { x1 <- Just 1; x2 <- undefined; return (fromMaybe x2 x1) }
18:51:55 <lambdabot>   add an instance declaration for (Num (Maybe t))
18:52:03 <Toxaris> sgillespie: a `seq` b `seq` b -- evalutes a and b, returns b
18:52:09 <EvilTerran> > do { x1 <- return $ Just 1; x2 <- undefined; return (fromMaybe x2 x1) }
18:52:09 <lambdabot>   add an instance declaration for (Show (m t))
18:52:22 <EvilTerran> > do { x1 <- return $ Just 1; x2 <- undefined; return (fromMaybe x2 x1) } :: IO Int
18:52:23 <lambdabot>  <IO Int>
18:53:41 <dons> ?uptime
18:53:41 <lambdabot> uptime: 1d 36m 45s, longest uptime: 1m 10d 23h 44m 29s
18:53:42 <sgillespie> Toxaris: does that _guarantee_ evaluation of a?
18:54:37 <Toxaris> if it is itself evaluated, a and b are evaluated up to whnf
18:54:43 <EvilTerran> okay, yeah, IO strictness applies there... =/
18:54:49 <sgillespie> I mean, what if 'a' happens to be IO
18:54:57 <sgillespie> or 'b'
18:55:20 <Toxaris> sgillespie: so it will be fully evaluated to a monadic IO action in whnf
18:55:21 <EvilTerran> sgillespie, `seq` only evaluates its LHS far enough to determine that it's not wholly undefined
18:55:28 <Toxaris> sgillespie: no IO performed, of course
18:55:54 <EvilTerran> it finds the "outermost constructor" of the LHS, if you will
18:56:49 <sgillespie> maybe i should try to explain what i'm trying to do
18:56:51 <Toxaris> sgillespie: whnf = weak head normal form ~ a constructor call
18:58:05 <sgillespie> I don't know...IO is confusing
18:58:17 <Toxaris> sgillespie: what do you try to do
18:59:02 <LordBrain> a >> return b
18:59:04 <sgillespie> Get a list of Data, throw it away, and return IO ()
18:59:18 <LordBrain> getListOfData >> return ()
18:59:47 <Cale> Hmm... exactly how much more costly is  data U a = A a | B a  than  data U = A | B ?
18:59:55 <sgillespie> LordBrain: I tried that, but it complains about 'getListOfData' not being expected type IO ()
19:00:00 <Toxaris> LordBrain, EvilTerran: I would try    x >>= return . fromMaybe y
19:00:09 <dons> Cale: hmm, a Word, a pointer, some info tables
19:00:19 <dons> Cale, allocate a big array of them and check the profiling
19:00:34 <EvilTerran> Toxaris, that... looks good. tell LordBrain, tho, he's the one who asked.
19:00:34 <dons> Cale, you might want to {-# UNPACK #-} the fields to save one indirection
19:00:45 <LordBrain> he put both our nicks there
19:00:57 <dons> has anyone started collecting/ranking speed for the icfp contst haskell programs yet?
19:01:02 <EvilTerran> oh, right. sorry. i'm really not with it today.
19:01:31 <LordBrain> yeah that looks right
19:01:49 <sgillespie> but I guess I should be asking
19:01:56 <sgillespie> in ... a >> b
19:01:59 <LordBrain> getNodeFromFile >>= return . fromMaybe getRandomNode
19:02:12 <sgillespie> do they need to be the same type?
19:02:31 <EvilTerran> ?type (>>=)
19:02:33 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:02:48 <Toxaris> LordBrain, EvilTerran: if used often, invent your own combinator... like   (?>>=)
19:03:06 <LordBrain> sgillespie, it sounds like you are trying to do IO actions in a pure context or something.
19:03:23 <LordBrain> sgillespie, do you have a wider context you can paste fo rus
19:03:23 <sgillespie> I don't think so
19:03:33 <sgillespie> not really, I left all my code at work
19:04:50 <sgillespie> I guess I should ask when I actually have stuff
19:05:45 <sgillespie> anyway, i gotta go...I appreciate the help
19:06:12 <LordBrain> sgillespie, make sure your getListData was not the last thing in your function
19:06:52 <sgillespie> okay...lets say i have...
19:07:07 <sgillespie> f :: listOfData -> IO ()
19:07:19 <sgillespie> err...
19:07:29 <sgillespie> yeah
19:07:55 <sgillespie> f x = processListAndGetAnotherList >> return ()
19:09:14 <LordBrain> processListAndGetAnotherList :: IO ListOfData
19:09:34 <sgillespie> that can't be a pure function?
19:09:43 <LordBrain> no
19:09:56 <LordBrain> you could use fmap or liftM if you have a pure function
19:10:06 <LordBrain> by the way, did you mean to discard x?
19:10:12 <LordBrain> or is that a parameter?
19:10:17 <sgillespie> no sorry
19:10:21 <sgillespie> it should have been
19:10:26 <sgillespie> f x = processListAndGetAnotherList >> return ()
19:10:26 <LordBrain> f x = processListAndGetAnotherList x >> return ()
19:10:42 <sgillespie> thats what i meant
19:10:52 <sgillespie> what you said, not what I said (crappy pasting)
19:11:06 <LordBrain> ok then processListAndGetANotherList :: ListOfData -> IO ListOfData
19:11:23 <sgillespie> alright, so I think that will solve my problem
19:11:27 <sgillespie> thanks a lot!
19:11:33 <LordBrain> if you have a pure function, you could use this
19:12:24 <LordBrain> f x = liftM processListAndGetAnotherList x >> return ()
19:13:04 <sgillespie> good stuff
19:14:00 <LordBrain> actually
19:14:03 <LordBrain> no
19:14:17 <LordBrain> that's assuming x is in the IO monad
19:14:45 <sgillespie> oh
19:14:55 <LordBrain> if neither is
19:15:30 <LordBrain> you can write it.. but... why would you, since there are no side effects and you are discarding the result...
19:16:43 <LordBrain> I'm guessing you want the processing to have a side effect and so it should return IO ListOfData
19:17:40 <LordBrain> you follow?
19:20:54 <MarcWeber> That's a stupid question, but is catMaybes a typo? I mean cat is an animal but cut is used to trim or .. you know what I mean? aiksaurus lists cat in "being" as well. I've never met this word used this way before ? Merriam-webster.com 3 : a strong tackle used to hoist an anchor to the cathead of a ship ? Can you shed some light?
19:22:46 <oklofok> cat is usually used for like piping
19:22:55 * msouth hasn't been paying attention MarcWeber , but "cat" might be from "concatenate"
19:23:00 <msouth> like the unix utility
19:23:33 <EvilTerran> yeah, cat's from concatenate
19:23:56 <EvilTerran> well, catenate.
19:24:21 <EvilTerran> "(v) catenate, catenulate (arrange in a series of rings or chains, as for spores)"
19:24:22 <sgillespie> yeah, i get what your saying
19:24:35 <sgillespie> (dog ran away)
19:24:38 <LordBrain> hmmm
19:24:44 <LordBrain> wouldn't sequence do that?
19:24:51 <LordBrain> @type sequence
19:24:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
19:24:53 <EvilTerran> it's like concat, from concatenate
19:24:53 <MarcWeber> Haven't thought of cat. You are totally right ;)
19:24:59 <LordBrain> hmm
19:25:00 <sgillespie> thanks for the help
19:25:35 <LordBrain> sequence would leave it in the maybe monad...
19:25:36 <TSC> > sequence [Just 10, Nothing, Just 5, Nothing, Just 1]
19:25:37 <lambdabot>  Nothing
19:25:58 <LordBrain> > sequence [Just 1, Just 2, Just 4]
19:26:00 <lambdabot>  Just [1,2,4]
19:26:22 <LordBrain> i guess we want to discard the Nothings...
19:26:27 <TSC> Yes
19:26:32 <TSC> You'd have to filter by isJust first
19:26:46 <TSC> fromJust . sequence . filter isJust == catMaybes ?
19:26:50 <LordBrain> catMaybe [Just 10, Nothing, Just 5, Nothing, Just 1]
19:26:59 <LordBrain> > catMaybes [Just 10, Nothing, Just 5, Nothing, Just 1]
19:27:01 <lambdabot>  [10,5,1]
19:27:08 <dons> http://programming.reddit.com/info/28vvo/comments
19:27:09 <lambdabot> Title: Ord, countable ordinals and sigfpe : further countable ordinals in Haskell (redd ...
19:27:15 <LordBrain> @src catMaybes
19:27:16 <lambdabot> catMaybes ls = [x | Just x <- ls]
19:27:29 <TSC> > fromJust . sequence . filter isJust $ [Just 10, Nothing, Just 5, Nothing, Just 1]
19:27:30 <LordBrain> nice
19:27:30 <lambdabot>  [10,5,1]
19:27:53 <EvilTerran> TSC, i think catMaybes is easier
19:28:00 <TSC> I agree
19:28:13 <dons> ?users
19:28:13 <lambdabot> Maximum users seen in #haskell: 363, currently: 318 (87.6%), active: 11 (3.5%)
19:28:42 <oklofok> what's the definition of 'active'?
19:29:03 <LordBrain> low idle time perhaps...
19:29:38 <LordBrain> hmmm
19:29:47 <Korollary> I think it's having said something in the last four hours
19:30:10 <dons> 30 minutes
19:30:14 <dons> ?help users
19:30:14 <lambdabot> users [chan]. Report the maximum number of users seen in a channel, and active users in the last 30 minutes
19:30:30 <oklofok> maximum number ever?
19:30:59 <mgsloan> > msum [Just 10, Nothing, Just 5, Nothing, Just 1]
19:31:01 <lambdabot>  Just 10
19:31:23 <slava> @src msum
19:31:23 <lambdabot> msum =  foldr mplus mzero
19:31:34 <TSC> @src Maybe mplus
19:31:34 <lambdabot> Nothing `mplus` ys  = ys
19:31:34 <lambdabot> xs      `mplus` _ys = xs
19:31:57 <mgsloan> kinda handy sometimes for lists of maybe.  not really what you want here though
19:32:50 <TSC> It seems similar to what someone was after recently on the cafe
19:33:05 <TSC> A sort-of inverse Maybe monad, that stops when it hits the first Just
19:33:13 <dons> oklofok: current maximum.
19:33:20 <dons> maximum ever active is around 70
19:33:21 <oklofok> hmm
19:33:23 <mgsloan> exciting
19:33:27 <oklofok> 700?
19:33:30 <oklofok> oh
19:33:32 <oklofok> active.
19:33:50 <dons> maximum users is 368, achieved yesterday, but then lambdabot had a blackout :)
19:34:34 <oklofok> i remember seeing > 400 here at some point
19:35:15 <dons> don't think so.
19:35:50 <Korollary> dons: When are you moving again?
19:35:54 <dons> September
19:36:02 <Korollary> Ah
19:41:11 <shmel> Hello, people. Can anybode help me with this:
19:41:11 <LordBrain> TSC, that sounds kind of like what i needed earlier
19:41:18 <shmel> I have function
19:41:19 <shmel> divis x = recip (1.0 - (recip x))
19:41:34 <LordBrain> except i only had two functions, but the monad approach seems more useful
19:41:34 <shmel> and I need signature something like this
19:41:35 <shmel> divis :: Num -> Fractional
19:41:51 <shmel> but ghc does not agree with me :-(
19:42:02 <EvilTerran> ?type \x -> recip (1.0 - (recip x))
19:42:04 <lambdabot> forall a. (Fractional a) => a -> a
19:42:25 <littledan> shmel, the input type for a numeric operation is the same as the output type
19:42:43 <littledan> shmel, also, have you read about type classes?
19:43:02 <shmel> a chapter in "Gentle Intro"
19:43:09 <littledan> well, not all input types are the same as output types, but here they are
19:44:07 <shmel> and how can i make integer as input and fractional as output type?
19:44:42 <littledan> you need to cast the integer to a fractional type
19:44:53 <littledan> explicitly
19:45:22 <littledan> ?type recip
19:45:24 <lambdabot> forall a. (Fractional a) => a -> a
19:45:47 <littledan> recip expects an argument in the class Fractional. There is no instance for integers in that class
19:46:03 <shmel> oh... and how can i cast to integer
19:46:30 <LordBrain> TSC, we could call it the Default monad... for modeling computations which may default to the next computation
19:46:58 <shmel> i have something working with (recip . fromIntegral) but not very well :-(
19:47:19 <LordBrain> TSC, did someone post the inverse Maybe ?
19:48:35 <mgsloan> > msum [Nothing, Just 10, Nothing, Just 5]
19:48:36 <lambdabot>  Just 10
19:49:03 <LordBrain> hmm
19:49:12 <LordBrain> yeah Maybe seems good enough
19:49:17 <littledan> shmel, what's the problem with that? that's what you should be using (or fromInteger, which is what I was going to suggest)
19:49:33 <littledan> actually, fromIntegral is better here
19:50:45 <shmel>     Could not deduce (Integral a) from the context (Fractional a)
19:50:45 <shmel>       arising from use of `fromIntegral' at Problem69.hs:49:33-44
19:50:45 <shmel>     Possible fix: add (Integral a) to the type signature(s) for `divis'
19:50:45 <shmel>     In the second argument of `(.)', namely `fromIntegral'
19:50:45 <shmel>     In the second argument of `(-)', namely
19:50:45 <shmel>         `((recip . fromIntegral) x)'
19:50:46 <LordBrain> well the default would translate >>= into `mplus`
19:50:47 <shmel>     In the first argument of `recip', namely
19:50:49 <shmel>         `(1.0 - ((recip . fromIntegral) x))'
19:50:49 <littledan> ?type \x -> recip (1.0 - (recip $ fromIntegral x))
19:50:51 <lambdabot> forall a a1. (Integral a1, Fractional a) => a1 -> a
19:51:08 <phoniq> data O_RLY a = YA_RLY a | NOWAI
19:51:39 <chessguy> @paste
19:51:40 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:51:44 <chessguy> shmel ^^
19:52:38 <shmel> thanks, I will use hpaste
19:52:49 <chessguy> paste your code while you're at it
19:52:56 <littledan> shmel, From that, I'm guessing you explicitly gave a type signature that was wrong
19:53:53 <shmel> may be, I have problems with signatures more complex than Int -> Int :-)
19:55:16 <shmel> littledan++
19:55:18 <shmel> thanks!
19:55:44 <mgsloan> shmel - there's a few ways to think about them.  the transitional, still thinking non-haskelly view is that all the types before the last are the function parameters, and the last type is the result.
19:56:41 <dmwit> LordBrain: I don't think the (>>=) = mplus definition (for Maybe) is actually a monad...
19:56:54 <littledan> shmel, here's a basic introduction to type declarations with classes: http://en.wikibooks.org/wiki/Haskell/Classes_and_types
19:57:00 <mgsloan> The true way of thinking of it is that, for example, f :: a -> b -> c, is the same as f :: a -> (b -> c), or in other words, f is a function taking a, and returning a function which takes b and returns c
19:57:02 <LordBrain> you're probably right
19:57:16 <LordBrain> i'm just thinking out loud
19:57:31 <littledan> shmel, are you familiar with type variables?
19:57:34 <timtheli`> um, is there a filter which instead of filtering for Bool filters for Maybe?
19:57:35 <LordBrain> well... not loud since i'm only typing... hmmm
19:57:54 <shmel> no :-(
19:57:59 <chessguy> hmm, that article starts out on a bad note
19:58:01 <timtheli`> LordBrain: you have a silent keyboard?
19:58:16 <chessguy> "Obviously x and y must be of the same type because you can't add different numbers together."
19:58:31 <kilimanjaro> wha
19:58:32 <dmwit> LordBrain: In particular, the monad law "(m >>= f) >>= g = m >>= (\x -> f x >>= g)" fails.
19:58:34 <littledan> ok, maybe not the best one...
19:58:34 <mgsloan> haha
19:58:41 <LordBrain> thanks for checking
19:58:47 <mgsloan> I always hated that restriction
19:58:56 <LordBrain> which restriction?
19:59:02 <mgsloan> the prelude classes are horrid examples of classes
19:59:10 <dmwit> timtheli`: catMaybe?
19:59:12 <dmwit> :t catMaybe
19:59:15 <kilimanjaro> chessguy, maybe he just had a flashback to ML
19:59:19 <dmwit> :t catMaybes
19:59:20 <lambdabot> Not in scope: `catMaybe'
19:59:21 <mgsloan> the Num restrictions, like + :: Num a => a -> a -> a
19:59:22 <lambdabot> forall a. [Maybe a] -> [a]
19:59:34 <LordBrain> oh
19:59:39 <LordBrain> hmmm
19:59:45 <LordBrain> its worse in ocaml
19:59:58 <timtheli`> dmwit: so just catMaybe $ map ...
20:00:20 <LordBrain> ocaml has no type classes, so you have different fuctions + and +.
20:00:21 <timtheli`> :t .
20:00:22 <lambdabot> parse error on input `.'
20:00:25 <littledan> mgsloan: if it were (Num a b c) => a -> b -> c it'd be unworkably complex, wouldn't it?
20:00:29 <mgsloan> filterMaybe = catMaybe . map
20:00:30 <dmwit> :t (.)
20:00:31 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
20:00:36 <dmwit> :t catMaybe . map
20:00:38 <lambdabot> Not in scope: `catMaybe'
20:00:42 <dmwit> :t catMaybes . map
20:00:43 <lambdabot>     Couldn't match expected type `[Maybe a]'
20:00:43 <lambdabot>            against inferred type `[a1] -> [b]'
20:00:59 <dmwit> :t (catMaybes .) . map -- =(
20:01:01 <lambdabot> forall a a1. (a1 -> Maybe a) -> [a1] -> [a]
20:01:06 <timtheli`> :t  map . catMaybes
20:01:08 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a1]'
20:01:08 <lambdabot>     In the second argument of `(.)', namely `catMaybes'
20:01:15 <mgsloan> littledan - yeah, it can get messy.  Functional Dependencies help some
20:01:27 <slava> hi littledan
20:01:32 <littledan> hi slava!
20:01:41 <dmwit> timtheli`: The problem is that you need to pass two parameters through, and (.) only passes one through.
20:01:54 <timtheli`> dmwit: oh, that's silly.
20:02:00 <dmwit> No, it's not.
20:02:08 <timtheli`> it's just lambdaing.
20:02:30 <timtheli`> I guess it could be usefull, but $ is what I want
20:02:33 <dmwit> Anyway, yes; map $ catMaybes ... is probably what you want.
20:02:49 <timtheli`> no, have the map on the other side.
20:02:53 <LordBrain> @type isJust
20:02:55 <lambdabot> forall a. Maybe a -> Bool
20:02:57 <dmwit> timtheli`: right
20:02:58 <timtheli`> to get filter effect
20:03:06 <dibblego> ?type catMaybes $ map
20:03:08 <lambdabot>     Couldn't match expected type `[Maybe a]'
20:03:09 <lambdabot>            against inferred type `(a1 -> b) -> [a1] -> [b]'
20:03:24 <timtheli`> lol
20:03:33 <timtheli`> dibblego: map takes 2 args
20:04:15 <LordBrain> filter (isJust . f) xs
20:04:29 <dmwit> :t let (..) = (\x -> if x then return x else mzero); (...) = [True, False] in catMaybes $ map .. ...
20:04:31 <lambdabot> parse error on input `..'
20:04:43 <dmwit> :t let (..) = (\x -> if x then return x else mzero); (...) = [True, False] in catMaybes $ map `..` `...`
20:04:45 <lambdabot> parse error on input `..'
20:05:44 <LordBrain> hmmm i think .. is explicitely dissallowed as an operator symbol
20:05:59 <dmwit> Oh, right.
20:07:25 <dmwit> > let (...) = (\x -> if x then return x else mzero); (....) = [True, False] in catMaybes $ map (...) (....)
20:07:27 <lambdabot>  [True]
20:07:46 <dmwit> pesky parentheses
20:25:35 <Cale> vincenz: newtype DNAMonad a = DNAM (StateT DNA (ErrorT () (Writer RNAChunk)) a) deriving (Functor, Monad, MonadState DNA, MonadWriter RNAChunk, MonadError ())
20:25:35 <Cale> vincenz: It's isomorphic to the monad we were using :)
20:25:35 <LordBr4in> i didn't know the deriving key word would work with all those fancy classes
20:25:35 <dmwit> -fglasgow-extensions -fnewtype-deriving or so
20:25:35 <Cale> Yeah, it's the right way to use monad transformers.
20:25:35 <LordBr4in> what is?
20:25:35 <LordBr4in> using deriving?
20:25:35 <Cale> Newtyping and using deriving
20:25:35 <Cale> That way you can also decide not to derive a class, and implement more restricted functionality if you want.
20:25:35 <Cale> (For example, to add consistency checks to state updates)
20:25:35 <LordBr4in> did dmwit give the right options?
20:25:35 <Cale> -fglasgow-exts
20:25:35 <Cale> it should imply -fnewtype-deriving
20:25:35 <Cale> actually, I think I might just do that here :)
20:28:46 <dons> perhaps teams can add links to their repos on this page, http://haskell.org/haskellwiki/ICFP_Programming_Contest/Teams_2007
20:28:49 <lambdabot> Title: ICFP Programming Contest/Teams 2007 - HaskellWiki, http://tinyurl.com/3dx5mv
20:28:52 <dons> Cale, desp, et al?
20:29:06 <dino-> dons: Yay, HWN
20:29:07 <desp> I will
20:29:11 <desp> once I clean up the code
20:34:35 <Cale> dons: hehe, I'm already writing a new toolchain :)
20:35:04 <wli> Cale: Interesting. Please do elaborate.
20:35:05 <desp> yeah ;)
20:35:10 <desp> same here
20:35:16 <dons> could someone maybe come up with a standard performance test, in order to get some speed rankings for the haskell entries?
20:35:26 <desp> dons: there is
20:35:38 <desp> ./dna2rna < endo.dna > /dev/null
20:35:49 <desp> I'd say that's a pretty good test
20:35:50 <dons> desp, perhaps then just put the speed results on a table on that wiki page then?
20:36:00 <dons> and bench mark other people's implementations on the same machine
20:36:02 <Cale> wli: There were a lot of things which you can only realise after writing one working version about how you would have written it.
20:36:16 <Cale> Or should have written it, I should say.
20:36:28 <wli> Cale: You mean for the ICFP problem?
20:36:29 <desp> Cale: were you writing in Haskell?
20:36:31 <Cale> yeah
20:36:40 <Cale> (in both cases)
20:36:41 <desp> have you published your source?
20:36:44 <Cale> nope
20:36:57 <Cale> At least, I didn't. Maybe one of my other team members did...
20:37:07 <dons> so perhaps link to the repos on the wiki page
20:37:13 <dons> and start a new section for speed rankings
20:38:10 <Cale> Speed rankings are sort of a funny way to measure this year compared to last.
20:38:26 <desp> yeah
20:38:41 <dons> yes, it would only be so people can work out what a good impl. in haskell would look like, for data munging
20:38:41 <desp> although that's the Haskell-relevant part
20:38:48 <Cale> Instrumenting the DNA -> RNA process becomes more important than speed after you get things to the right order of magnitude.
20:38:51 <dankna> Haha, I see the topic has changed to reflect the most recent ICFP.
20:39:08 <Cale> Who were the winners this year?
20:39:10 <SamB> Cale: hmm.
20:39:11 <dons> dankna: ?
20:39:23 <desp> the winners haven't been announced
20:39:35 <SamB> dankna: if by "most recent" you mean ICFP 2006
20:39:38 <dankna> Oh, okay.  I vaguely remembered it saying "two years running" before but I must have been mistaken.
20:39:45 <SamB> yes.
20:39:48 <dons> no, its been 3 years for the last 3 years :)
20:39:52 <dankna> Haha.
20:39:53 <dons> well, for the past year.
20:39:59 <SamB> it used to say "The language of choice for discriminating hackers"
20:40:00 --- mode: ChanServ set +o dons
20:40:04 --- topic: set to '["The Haskell programming language: Write less, think more!","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","The language of ICFP winners 3 years running"]' by dons
20:40:09 --- mode: ChanServ set -o dons
20:40:21 * dankna nods
20:40:30 <SamB> but then that ridicerous Team Smartass won last year and appointed 2d
20:40:40 <desp> heh
20:41:01 <SamB> they had their pick of smartass answers that year at least
20:41:38 <SamB> I think qvicbasic would have been a cooler choice, though ;-)
20:42:24 <dons> right, but then on their blog they said they used haskell, C++ and python
20:42:28 * mgsloan has semi-fond memories of 'ol QB
20:42:34 <dons> this year they used just C++ and python, according to Zeeeee.
20:42:47 <dons> though 'Basically Awesome' did use haskell this year, the other google team
20:43:47 <SamB> well, team smartass obviously can't pick their favorite language when given a choice
20:43:52 <SamB> it wouldn't be smartass enough
20:45:00 * mgsloan would have said lambda calculus
20:45:20 <SamB> mgsloan: wasn't that just used in the key?
20:45:33 <SamB> I don't think you got to write any programs in or about it...
20:46:13 <wli> It's a shame that no one tries to use anything wild like Squiggol, Cayenne, or whatever (Epigram?).
20:47:07 <wli> Though in all honesty, Haskell with sufficient extensions is already quite far along in terms of such "wildness."
20:47:41 <mgsloan> yeah, it'd be pretty amazing if someone used epigram
20:48:18 <wli> I think it has some maturity issues.
20:48:46 <mgsloan> well, I don't think its really intended to be a 'real' programming language
20:48:58 <wli> I'm not sure if e.g. Coq has the programming facilities for use as such either.
20:50:17 <mgsloan> someone should use one of these langs - http://strlen.com/proglang/index.html
20:50:19 <lambdabot> Title: Wouter's programming language page
20:50:25 <Cale> mgsloan: Then again, Haskell wasn't really a 'real' programming language for quite a while :)
20:50:36 <mgsloan> really? I didn't know that
20:50:55 <mgsloan> I suppose IO wasn't really there from the start
20:50:59 <Cale> yeah
20:51:05 <mgsloan> but you don't need IO to make useful programs
20:51:05 * wli wonders what comes after Haskell'
20:51:11 <Cale> and even once it was, the performane sucked for a long time
20:51:16 <Cale> c*
20:51:31 <dolio> Their current implementation might not be for real use, but I think real programming in Epigram is the eventual goal, no?
20:51:33 <dons> http://www.cs.nott.ac.uk/~wss/Thesisometer/thesisometer.png
20:51:37 <dons> swiert is a funny guy
20:51:39 <Cale> and the libraries have come a *huge* distance since I started
20:51:57 <wli> The naming system seems to lack a certain extensibility.
20:52:22 <rashakil> wli: Haskell' 2 Echoes
20:52:24 <Cale> Haskell'', Haskell''', Haskell^(4), ...
20:52:51 <wli> Haskell^\omega?
20:52:56 <dons> we've > 300 libs on hackage now. that's great
20:53:38 <wli> Cale: How are we doing vs. ocaml?
20:54:04 <mgsloan> I suppose I can imagine using epigram in 10 years.  It probably isn't that bad either.  I remember when haskell looked like black magic too
20:54:27 <wli> mgsloan: It still does to a lot of people.
20:54:57 <dmwit> like me
20:54:58 <dmwit> =)
20:55:25 <wli> dons: I suppose one library adequacy stress test would be ACID for an RDBMS.
20:55:44 <mgsloan> yeah, probably to ~99.999% of people
20:56:01 <dons> i think we've got that already. or at least pretty close, wli. MACID in Happs? the 25 db libs on hackage?
20:56:08 <Cale> wli: I'd say we're as practical as ocaml now.
20:56:19 <Cale> If not more, at some things.
20:56:25 <wli> dons: hAppS has its own RDBMS?
20:56:25 <dons> seems like there's more libs available for haskell, anyway
20:56:29 <Cale> yeah
20:56:46 <wli> Not via FFI and/or DB access libs?
20:56:50 <dons> in terms of coverage, its hard to see things that are obviously missing
20:57:13 <dons> but depth and perforamnce could be improved, and just getting more people experience writing large systems
20:57:51 <wli> dons: A bunch of layered network protocols, file format codecs, etc. are probably missing and/or disorganized.
20:57:56 <Nafai> mgsloan: It still looks like black magic to me :)
20:58:15 <dons> wli, yep. more depth to the existing network and codec stuff
20:58:33 <dons> they're 2 of the largest categories already though, which is interesting
20:58:38 <mgsloan> Nafai - yeah, just stare at it a few months and it'll start looking normal
20:58:56 <dmwit> Nafai: Be realistic, by now it's probably mere gray magic. =)
20:59:25 <Nafai> =)
20:59:58 <wli> dons: Probably also low-level network protocol support, too, in some cases (e.g. SCTP).
21:00:29 <dons> i don't think there's any technical issues, so dive in if you've got something that needs doing :)
21:00:59 <dons> we know how to do very low level stuff, so i expect to continue to see those lib categories growing
21:01:01 <wli> dons: I've got pedagogical issues to address for the most part.
21:02:24 <wli> I don't really know enough to produce very useful libs, though I've done a couple of things that may end up being useful.
21:02:42 <brad_> i need to rtfm on quickcheck, but a simple question - is it appropriate for testing a program that is I/O centric?
21:02:56 <Nafai> wli: What kinds of things have you worked on?
21:03:18 <dons> brad_: hmm, not really for testing IO itself
21:03:21 <dibblego> brad_, no, but then, should a program be I/O centric? (no)
21:03:27 <dons> it is a bit hard to test monadic things
21:03:42 <brad_> dibblego - this one is! its getting webservice data
21:03:48 <dons> to test functions with IO type, proabbly easiest to use HUnit ?
21:03:54 <dibblego> brad_, and then what does it do?
21:04:03 <brad_> okay dons! i will look at hunit
21:04:20 <brad_> dibblego - it is my Finance.Quote.Yahoo library - i have added new features
21:04:21 <dibblego> brad_, perform some transformation on that data and prepare it for writing back I assume?
21:04:40 <brad_> yes dibblego
21:04:46 <wli> Nafai: Nothing meaningful in Haskell. Probably the only things that have seen (re)use are some bits of Grobner basis code (people asked), a permutation calculator (used by people on #math), and a differential profiling program that qualifies mostly as a text processing script.
21:04:47 <dibblego> so that is not I/O centric
21:04:57 <dibblego> you can do all that outside IO
21:05:23 <dons> yeah, if the functions aren't actually of IO type, you can use QuickCheck
21:05:51 <Nafai> wli: Cool
21:06:00 <brad_> well put it this way, as the module grows i would like to be able to make more robust statements as to its stability
21:06:12 <brad_> and i am looking into the methods peope are already using
21:06:26 <dons> you'll want to ensure a good purely functional set of operatoins then, stated with QuickCheck properties
21:06:29 <blackdog> dons: am installing openbsd in a vmware env on windows. i don't know whether i should feel virtuous or disgusted :)
21:06:34 <dons> check the haskel wiki for blog articles about it, brad_
21:06:44 <brad_> cool, thanks dons and dibblego!
21:06:45 <wli> Nafai: Given my advancement in module-foo, I can probably redo the permutation calculator in a vastly superior fashion.
21:06:50 <dibblego> brad_, np
21:06:53 <dons> blackdog: heh
21:06:59 <wli> Nafai: s/module-foo/monad-fu/
21:07:52 <wli> Nafai: I can probably redo the Grobner basis bits, too.
21:07:52 <Nafai> wli: Awesome that you are progressing in your knowledge
21:08:04 <Nafai> wli: I don't know enough to do anything worthwhile just yet
21:08:41 <wli> Nafai: I blew through YAHT over this past weekend and got quite a bit out of the monad chapter, though I'm still digesting it.
21:08:58 * wli did all the problems.
21:09:04 <sfultong> YAHT seems the best introductory resource I have come across
21:09:08 <sfultong> online
21:09:36 <Nafai> I probably should work on that this week now that I'm on vacation
21:09:38 <wli> sfultong: There needs to be a "beating your face in with monads and monadic programming problems" resource.
21:09:57 <Korollary> wli: Have you read all about monads?
21:10:14 <Korollary> I mean "All About Monads"
21:10:17 <wli> Korollary: I think so. Let me check.
21:11:12 <wli> Korollary: Yeah, I need more programming exercises.
21:11:32 <Korollary> There's not much to do, though.
21:12:20 <sfultong> allegedly monads help structure your programs... at least that's what I read somewhere... but I've been doing just fine using minimal IO... and a tiny bit of Maybe stuff
21:13:04 <Korollary> sfultong: There's no rule that says monads are to be found under every rock.
21:14:54 <wli> I think there is.
21:14:58 <sfultong> monads seem kinda neat to me, but not overwhelmingly so... it seems to me that there can be so many ways to organize structure in functional programming, and I'm not sure why monads are standardized as the defacto one...
21:15:21 <wli> sfultong: Well, they aren't. There are arrows, for instance.
21:15:33 <sfultong> yeah, I've been thinking about trying to use arrows...
21:15:45 <magnus> Is there a way to catch errors in the Error monad, sort of like exceptions?
21:16:02 <dolio> @type catchError
21:16:04 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
21:16:05 <wli> magnus: catchError
21:16:10 <magnus> thanks
21:16:43 <sfultong> I wonder if really good haskell programmers spend most of their time in monads... if they've figured out a monad for every occasion
21:17:16 <sfultong> also... can CPS be related to something, either arrows or monads?
21:17:35 <magnus> sfultong: when you have the right monad it can reduce a lot of clutter in your code
21:17:56 <magnus> there is a continuations monad I think
21:18:10 <sfultong> magnus: yeah,  I guess that's true... in my experience with using the maybe monad, at least
21:18:27 <sfultong> oh! that's what the continuation monad is... heh, for some reason I never made that connection
21:19:03 <sfultong> now that I've gotten somewhat comfortable with point-free style, I think  I should start trying to do everything CPS style
21:19:19 <magnus> I only grokked monad transformers yesterday but I can already see they are very powerful
21:19:55 <magnus> what is CPS style?
21:20:09 <sfultong> continuation passing style
21:20:14 <sfultong> err... heheheh
21:20:16 <sfultong> silly me
21:20:21 <magnus> :)
21:20:21 <sfultong> ATM machine
21:20:30 <shapr> magnus: You want a definition?
21:20:37 <sfultong> no, he was poking fun at me
21:20:44 <shapr> oh
21:20:59 <magnus> i was a bit confused by the duplicate "style"
21:22:22 <shapr> Yay, my girlfriend assembled my new computer. 4Gb of ram, w00!
21:22:47 <dibblego> > let isSorted = \xs -> sort xs == xs in isSorted [1..10]
21:22:48 <lambdabot>  True
21:22:51 <Korollary> computer-assembling girlfriends? and you celebrate more RAM. Nice.
21:23:30 <shapr> Korollary: Yeah, blonde blue-eyed Swedish computer-assembling girlfriend.
21:23:41 <magnus> dibblego: that's a funny implementation :D
21:23:51 <sfultong> I wish I had a girlfriend to... assemble my computer
21:24:04 <dibblego> magnus, I'm just hacking for ScalaCheck :)
21:24:17 <dibblego> magnus, but I know it can be done much more efficiently
21:24:28 <shapr> sfultong: It's okay, she has sex with me too.
21:24:54 <slava> shapr: do you experience monadic effects?
21:25:33 <sfultong> does she ask you to bind your value in her?
21:25:40 <shapr> slava: That's a great straight man line... so many jokes...
21:26:02 <sfultong> yeah, it was
21:26:03 <slava> dibblego: like QuickCheck?
21:26:13 <dibblego> slava, yes, but I'm actually using Scala
21:26:18 <slava> right
21:26:59 <shapr> Aanyway... I have a dual core, I can barely wait to try GHC-SMP!
21:28:10 <sfultong> how's GHC's ability to automatically parallelize stuff?
21:28:34 <magnus> can it do that?
21:28:36 <shapr> dons: Are there some set of recommendations for +RTS -Mxxx settings once more than 1/2/4/etc gb of ram is available?
21:28:56 <sfultong> i imagine it would be very easy...
21:29:54 <dons> shapr: hmm.
21:30:18 <dons> big numbers, probably. ask rl, he uses the really really big (80G) servers with haskell
21:30:25 <shapr> Whoa, 80GB of ram??
21:30:34 <dons> yeah, $2M sun machines
21:30:37 <dons> (midrange...)
21:30:50 <magnus> am I the only one who doesn't like using $ in code?
21:30:58 <slava> do you prefer £?
21:31:03 <shapr> dons: Wow, impressive.
21:31:06 <magnus> I prefer ()
21:31:13 <mgsloan> nowadays i save $ till the last bit
21:31:16 <mgsloan> and make the rest .
21:31:39 <sfultong> I use () often, but I really should use $ more
21:31:47 <dons> new sel4 haskell paper, http://programming.reddit.com/info/28wo7/comments
21:31:49 <lambdabot> Title: Towards a Practical, Verified Kernel : microkernels in Haskell + Isabelle/HOL (r ...
21:31:49 <magnus> I think $ is too visually standing out
21:32:05 <sfultong> magnus: yeah, sometimes I feel that way as well
21:32:06 <shapr> Anyway, Lemmih cut something like ~20% of the compile time off of HAppS with +RTS -H256M -RTS and I wondered whether there's a good total ram to heap size ratio.
21:32:17 <mgsloan> and big honking parens don't stand out?
21:32:17 <magnus> with ( you both save space and it gets out of the way visually
21:32:24 <dons> i suspect there is, shapr . you could ask on cvs-ghc@
21:32:27 <dons> to see what people have to say
21:32:28 <shapr> Ok, thanks.
21:32:37 <magnus> mgsloan: not if you're used to lisp :)
21:32:52 <dolio> Save space?
21:32:57 <dankna> as a newcomer, incidentally, I had to learn about the existence of $ from reading other people's code.  and then I found it in the reference material, but ... if I ever feel sufficiently experienced to write a tutorial, that's definitely something I'll put in it...
21:33:03 <sfultong> yeah, I dunno how saving space makes sense..
21:33:20 <rashakil> '(' saves space?  How?
21:33:27 <magnus> a $ b   vs a (b) .... are equally long but a and b are closer in a (b)
21:33:28 <dankna> I am used to lisp and I'm still bothered by the parens in Haskell, cause it's infix :)
21:33:32 <mgsloan> magnus - true!
21:34:09 <mgsloan> magnus - aren't using a fixed-width font, eh?
21:34:13 <brad_> can you insert html into haddock docs?
21:34:32 <magnus> mgsloan: I'm using fixed width
21:35:09 <mgsloan> oh, i see your point
21:35:12 <mgsloan> 3 vs 2 char
21:35:37 <magnus> yes, this saves horizontal space when you go both vertically and horizontally
21:35:40 <mgsloan> I think one of the big reasons for it is it's easy to type
21:35:53 <mgsloan> and you don't have to match parens all over the place
21:35:55 <magnus> it's a saver on the repl
21:36:06 <falconair> dons, I noticed you updated the Ports library, will we get updated docs too? Are you planning on using ByteStrings in it?
21:37:26 <brad_> is there a way to specify a minimum ghc version in cabal?
21:38:03 <wli> I don't think MACID in hAppS includes an actual RDBMS implementation.
21:38:06 <dons> falconair: i'm not suing it, and at the moment am working 100% on my thesis writeup. so no, i just salvaged it from cvs, and put it on hackage
21:38:16 <dons> falconair: feel free to work on the haddocks, or use it for your own work
21:38:34 <wli> I think it just calls an RDBMS but I'm not sure.
21:40:13 <falconair> dons: good enough, I exchanged a couple of emails about it with Manuel a few months ago... looks interesting!  I'm trying to write an api to read real-time stock quotes (from a free service) ... I was trying to figure out how to do it ... eventually I'll try to use some FRP magic
21:40:16 <falconair> in any case, thanks
21:40:19 <magnus> I wish GHC mode would align function applications lisp style
21:40:27 <magnus> vertically
21:41:09 <magnus> it has a lot of weird ideas about where to indent things to
21:41:18 <magnus> some options are rather useless
21:42:10 <magnus> especially the one indenting 8 chars in from a previous line is useless
21:42:45 * sfultong uses 3 space tab stops
21:43:22 <dons> falconair: yeah, something like that, or ports.
21:43:38 <dons> you want values that vary, coming in over the network, nicely, i guess?
21:43:47 <dmwit> brad_: Yes.
21:43:55 <falconair> dons: yup
21:44:16 <dons> yeah, so perhaps start with the ports paper, and design your own from scratch for your requirements (that's probably what i would do now)
21:44:29 <dons> and things like yampa are also relevant here
21:44:48 <falconair> you mean design my own Ports library or design my app to use the ports lib?
21:45:40 <dons> i'd probably write a stripped down ports for your needs but then again, i like wasting time
21:45:51 <dons> ^h^h^h hacking
21:45:55 <falconair> I don't know about Yamap (arrows and all), but Conal Eliot has been writing recently about using Applicative + Fran type FRP ... the whole point is to learn Haskell, so I"ll see how far I get :)
21:46:22 <dons> go for it!
21:46:44 <falconair> pretty excited, thanks!
21:46:45 * wli snarfs hscurses.
21:48:44 <timthelion> I'm trying to sort a list of patches(which have file names represented by numbers. by those numbers. I have >map (read . takeFileName) patches to convert the list of patches to a list of numbers to be sorted. but how do I then do the sorting? and in such a way that read knows to be reading the strings I'm feeding it as numbers?
21:49:41 <TSC> Convert the strings to numbers, then sort the numbers
21:49:55 <ClaudiusMaximus> @type (read::String->Integer)
21:49:57 <lambdabot> String -> Integer
21:50:02 <timthelion> TSC, but then I have a sorted list of numbers, not a sorted list of patches
21:50:16 <TSC> Can you convert from a number back to its patch name?
21:50:30 <TSC> If not, use sortBy
21:50:44 <timthelion> :t sortBy
21:50:46 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
21:50:58 <TSC> You can do something like
21:50:59 <ClaudiusMaximus> @type sortBy (compare . fst) ([]::(Integer,String))
21:51:01 <lambdabot>     Occurs check: cannot construct the infinite type: a = (a, b)
21:51:01 <lambdabot>       Expected type: (a, b) -> (a, b) -> Ordering
21:51:08 <ClaudiusMaximus> hmm, oops
21:51:18 <TSC> sortBy (comparing patchToNumberFunction) listOfPatches
21:51:38 <mgsloan> sortBy (comparing $ read . takeFileName)
21:52:07 <timthelion> comparing?
21:52:38 <mgsloan> > sortBy (comparing $ read . fst) [("1", "a"), ("2", "b"), ("3", "c")]
21:52:40 <lambdabot>  [("1","a"),("2","b"),("3","c")]
21:52:42 <TSC> :t comparing
21:52:43 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
21:52:51 <mgsloan> > sortBy (comparing $ read . fst) [("3", "a"), ("2", "b"), ("1", "c")]
21:52:52 <lambdabot>  [("1","c"),("2","b"),("3","a")]
21:53:01 <TSC> compraing takes a "conversion" function, and then sorts by the output of the conversion
21:53:05 <TSC> For example:
21:53:27 <TSC> > sortBy (comparing length) ["hello", "hi", "bonjour", "g'day"]
21:53:28 <lambdabot>  ["hi","hello","g'day","bonjour"]
21:53:42 <mgsloan> reads like prose, eh :)
21:54:12 <timthelion> interesting, that works well.
21:54:25 * timthelion seriously doubts the efficiency
21:54:32 <mgsloan> psh
21:54:32 <slava> heh
21:54:40 <TSC> It shouldn't be very inefficient
21:54:50 <TSC> Each comparison would have two extra "conversions"
21:55:05 <TSC> So if your conversion is simple, the sort will only be a bit slower
21:55:12 <TSC> comparing length is probably slow
21:55:21 <mgsloan> hmm
21:55:23 <TSC> But, say, "comparing head" ought to be fast
21:55:33 <mgsloan> I guess it doesn't manage to memoize then
21:55:41 <mgsloan> yeah, it couldn't
21:55:51 <mgsloan> well, maybe..
21:56:05 <newsham> schwartzian
21:56:41 <timthelion> my program is already horribly inefficient as it is.  the problem with haskell,both revealing, and inefficient. with elisp, at least you can't tell your code sucks till you run it...
21:57:58 <newsham> at least
21:58:03 <wli> What database interface should one use?
21:58:14 <SamB> timthelion: I have a function to tell if an elisp program is inefficient or not
21:58:34 <wli> HaskellDB?
21:59:38 <mgsloan> map fst . sortBy snd . zip listOfPatches $ map ((read :: String -> Integer) . takeFileName) listOfPatches
21:59:47 <mgsloan> something along these lines'll probably work
22:00:16 <mgsloan> maybe some syntax issues in there, I'm fairly trial and error with regards to that sometimes
22:02:10 <timthelion> SamB: ya, but it still doesn't hurt to look at. like >let foo (x:xs) t = foo x : t in foo (reverse "hello") "" does. when extracting one string from another.
22:02:39 <timthelion> oops, I forgot an xs in there. but you get the point
22:04:43 <wli> Latest file release 18 August 2004?
22:05:07 <dons> wli, hmm, look on hackage. and then in the blog articles about haskell dbs
22:05:22 <dons> there are some recommended ones, hdbc? , but i don't recall which one is reocmmneded
22:06:45 <wli> CoddFish looked interesting until the database connectivity vaporized. I was sort of hoping someone would recommend something.
22:09:02 <dibblego> what is the feature name of the ys' in ys'@(y:ys)?
22:09:10 <wli> as-pattern
22:09:18 <dibblego> thanks
22:09:56 <mgsloan> something I learned from the xmonad code is that you can do stuff like (x :: Int) in patterns
22:10:51 <mgsloan> At one point in time I actually used x@(MyDataType _ _ _ _)
22:11:56 <Korollary> That's a GHC extension
22:12:04 <Korollary> the types in patterns I mean
22:12:15 <mgsloan> oh, that'd explain why I didn't know about it
22:15:16 <Heffalump> a neat trick on the quickcheck page is to do foo x = ... where types = (x :: Int)
22:15:25 <Heffalump> (in H98)
22:15:50 <mgsloan> haha
22:17:20 <Korollary> There's also asTypeOf, but I don't think it's useful often
22:20:24 <desp> does anyone know what's the current status of Haskell SDL bindings?
22:20:32 <desp> the sourceforge page looks dead
22:21:04 <dons> check hackage, lemmih uploaded some new ones recently
22:21:10 <desp> oh
22:21:26 <desp> ?whereis sdl
22:21:26 <lambdabot> Maybe you meant: where where+
22:21:32 <desp> ?where sdl
22:21:32 <lambdabot> I know nothing about sdl.
22:22:03 <desp> ?where+ sdl http://hackage.haskell.org/cgi-bin/hackage-scripts/package/SDL-0.4.0
22:22:03 <lambdabot> Done.
23:49:48 <profmakx> @users
23:49:49 <lambdabot> Maximum users seen in #haskell: 363, currently: 320 (88.2%), active: 8 (2.5%)
