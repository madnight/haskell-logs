00:03:53 <dons> ooh, exciting, http://programming.reddit.com/info/23e4s/comments
00:03:54 <lambdabot> Title: Lightweight concurrency primitives for GHC (reddit.com)
00:04:34 <dons> dcoutts: all my c2hs fail to run with:
00:04:36 <dons> $ c2hs Simple.chs
00:04:36 <dons> ("Simple","","Simple.chs.h","Simple.chs.h","Simple.i")
00:04:36 <dons> cc1: stdout: Resource temporarily unavailable
00:04:36 <dons> c2hs: Error during preprocessing custom header file
00:04:38 <dons> :(
00:10:42 <pierre-> hello
00:10:58 <dons> hey pierre-
00:11:07 <glguy> hi dons
00:12:09 <dons> hey glguy. you're up late?
00:12:31 <sorear> 'night all.
00:12:36 <glguy> its midnight here... but we are off tomorrow :)
00:13:09 <mgsloan> dons - http://adrinael.net/wrong1.jpg
00:13:38 <glguy> ?where wrong
00:13:38 <lambdabot> http://adrinael.net/wrong.jpg
00:13:42 <glguy> ;-)
00:13:46 <dons> mgsloan: ?
00:14:25 * glguy is in console mode only and can't see that image... could you remind me what it was?
00:14:31 <glguy> maybe a guy falling off a motorcycle?
00:14:35 <mgsloan> kinda
00:14:38 <dons> yep
00:14:42 <mgsloan> there's a few different ones
00:14:50 <mgsloan> this one looks like he's trying to ride it side ways
00:15:39 <mgsloan> anyway, clearly in regards to c2hs, well, the pic says it all
00:15:49 <dons> ah
00:15:53 * mgsloan should have waited to use that pic when he knew what exactly was being done wrong
00:16:08 <dons> well, i'm not sure `Resource temporarily unavailable' is a good sign.
00:17:28 <mgsloan> oh, :(
00:17:42 <mgsloan> yeah, clearly the network is doing it wrong
00:21:37 <notadev> http://beej.us/guide/bgnet/output/html/multipage/theory.html
00:21:38 <lambdabot> Title: What is a socket?
00:42:20 <DRMacIver> Morning
00:42:28 <matthew-_> Morning David
00:42:38 <glguy> morning matthew-_ , DRMacIver
00:42:56 <matthew-_> morning glguy
00:42:57 <DRMacIver> Hi matthew-_, glguy. How goes?
00:43:02 <matthew-_> forwards
00:43:04 <matthew-_> you?
00:43:36 <DRMacIver> Taking great comfort from the number 8.
00:43:58 <DRMacIver> (Number of working days left)
00:43:59 <matthew-_> lol. is that working days or total days or hours?
00:44:15 <matthew-_> ahh.
00:44:32 <matthew-_> Either I'm blind or some lag issue... better have brekkie
00:44:37 <DRMacIver> Heh
00:44:43 <DRMacIver> Enjoy. :)
01:00:01 <notadev> heh resignation ftw ;)
01:00:26 <osfameron> notadev: yay!
01:00:44 <glguy> its a shame that more people don't learn to live in a command line world
01:00:44 <glguy> #gentoo is full of people spending all their time trying to make their gnome look pretty
01:01:01 <osfameron> glguy: but a computer should be pretty too
01:01:14 <osfameron> glguy: I mainly use command line, but for those things that I use gui for, why not?
01:01:40 <osfameron> though to be fair, I would be happier if it was fugly but things like the file choose were not batshit insane
01:01:45 <osfameron> *chooser
01:02:19 <notadev> hehe
01:02:25 <glguy> when I run GUI, it is to run full screened PuTTY sessions
01:02:26 * mgsloan would only mess with themes if it was all svg based
01:02:33 <glguy> so the themes don't even show up
01:02:44 <notadev> when i run a gui it's so i can pretend i don;t need cli for a bit :-)
01:02:49 <osfameron> glguy: you don't use a web browser?
01:03:03 <glguy> I use a full screened firefox some times
01:03:07 <glguy> but I don't need any themes for that
01:03:11 <osfameron> true
01:03:13 <notadev> s/cli/to type/
01:03:15 <glguy> the default serves just fine
01:03:37 <osfameron> yes.  from a purely utilitarian standpoint I agree with you
01:03:52 <dons> so, given STM, data parallel arrays, Control.Parallel.Strategies, and the unified events and threads lib, why do the erlang guys think haskell can't do concurrency?
01:04:08 <dons> what do we have to do to flip that around -- erlang concurrency looks boring in comparison to the toys over here.
01:04:18 <osfameron> dons: does a default haskell install do that=
01:04:19 <osfameron> ?
01:04:42 <glguy> osfameron: yeah
01:04:43 <dons> default haskell as points 2, MVars/Chans/forkIO.
01:04:48 <dons> and STM.
01:04:49 <osfameron> dons: and also erlang may be "easier" ?
01:05:04 <dons> yes, but why? is it really? where's the impression coming from?
01:05:08 <dons> see this thread: http://www.erlang.org/pipermail/erlang-questions/2007-July/027643.html
01:05:10 <glguy> erlang's dynamic loading is better
01:05:12 <lambdabot> Title: [erlang-questions] Erlang vs. Haskell, http://tinyurl.com/33oazg
01:05:12 <mgsloan> I use full screen command line, then the other screen for the other stuff :)
01:05:22 <DRMacIver> Presumably the same place as "Haskell can't do IO"?
01:05:23 <dons> basically, "yeah, haskell's faster, better typed, but i'd use erlang for concurrency"
01:05:26 <glguy> erlang is sweet if you want to alter a running system
01:05:27 <Vq^> glguy: the default ff theme is a bit to fancy
01:05:28 <glguy> one that can't go down
01:05:56 <dons> and haskell seems to have 5 new parallel abstractions for each one in erlang. so hmm: how to fix that.
01:05:56 <osfameron> well my impression is only from a) Haskell is hard to learn for me, and b) the blogs like the tenerife skunkworks comparison, where the guy actually implemented a biggish concurrent system, came out for erlang
01:06:13 <dons> he implemented a big system, and didn't do the serialisation right.
01:06:22 <dons> and already knew erlang
01:06:42 <dons> yeah, they site Joel in the above thread to.
01:06:46 <dons> 1 data point :(
01:06:52 <osfameron> fair enough :-)  I didn't read all the other blog posts where people did both and found haskell easier ;-)
01:07:10 <dons> everyone likes to cite joel's failed haskell server.
01:07:27 <dons> even joel!
01:07:28 <glguy> People find Haskell hard because they think that it is supposed to be hard
01:07:32 <glguy> (largely)
01:07:34 <dons> :/
01:07:34 <glguy> imho
01:07:46 <Vq^> glguy: supposed to?
01:07:52 <glguy> everyone says its hard
01:07:55 <glguy> they believe it
01:07:56 <dons> yeah, erlang's pretty much the same ball park.
01:08:10 <glguy> monads are much easier to teach if you don't admit you are teaching them
01:08:21 * Vq^ had a look at ML the other day
01:08:23 <dons> i think the 'can't do IO issue' is long dead.
01:08:28 <Vq^> i find Haskell much clearer
01:08:36 <dons> but now the 'don't want to do concurrency -- see joel's page' has to be tackled.
01:08:41 <dons> since concurrency is a very strong point.
01:09:08 <quicksilver> I don't really think joel's case study says much about concurrency
01:09:27 <quicksilver> the things which stick in my mind are "loosely typed pattern matching on message passing"
01:09:46 <Cale> "Foreign calls and concurrency interact in delightfully subtle ways"
01:09:55 <quicksilver> so it was the communication part, rather than the concurrency part, which he couldn't get right in haskell
01:09:57 * Cale reads the new paper :)
01:10:35 <Cale> He was expecting unreasonable performance which he never got from his Erlang program either, because it was actually impossible.
01:10:44 <Cale> (joel)
01:11:11 <quicksilver> maybe
01:11:12 <dons> and he went against our advice many times, the whole pickler saga :/
01:11:18 <dons> i'm not sure why joel has so much trouble with haskell.
01:11:21 <quicksilver> but I wasn't really struck by the performance part anyway
01:11:31 <quicksilver> as I say, the part which really struck me was the messaging
01:11:37 <quicksilver> marshalling/demarshalling/dispatching
01:11:57 <quicksilver> erlangs loose types + pattern matching were a nice solution to that
01:12:10 <dons> i can understand distribution is easier in erlang, and hot reloading. but people don't ask for that: they ask for threading/simple concurrency.
01:12:13 <quicksilver> and I'm not aware of any other language which makes that idiomatic
01:13:21 <notadev> deriving (Show,Eq) -- just means allow print and comparison?
01:13:29 <Cale> notadev: yep
01:13:32 <notadev> ty
01:13:44 <Cale> notadev: It derives code for those things from the structure of the type.
01:14:02 <notadev> cool, it's just a string typedef :-)
01:14:59 <glguy> notadev: a type or a newtype?
01:15:22 <notadev> a new type i think; i'm looking at more complex stuff now
01:15:31 <Cale> Well, it's either newtype or data :)
01:15:52 <notadev> Maybe means can be null?
01:15:54 <dons> dolio++ wins the hack of the day award
01:15:57 <glguy> Cale: I was just going to point out that type doesn't have deriving
01:16:02 <notadev> Cale: hmm
01:16:19 <dons> http://article.gmane.org/gmane.comp.lang.haskell.cafe/24923
01:16:21 <lambdabot> Title: Gmane -- Mail To News And Back Again
01:16:22 <Cale> notadev: Yeah, data Maybe a = Nothing | Just a
01:16:30 <notadev> well it's used for data, but so are all types no?
01:16:46 <notadev> cool
01:17:48 <Cale> notadev: The differences between newtype and data are subtle, but the biggest ones are that newtype can only be used when you have a single constructor with a single field, and you can (with a GHC extension) derive basically any class which was supported on the original type.
01:18:11 <Cale> newtype is implemented by creating a new type in the type system, but leaving the runtime-implementation of the data the same
01:18:11 <notadev> single-field?
01:18:15 <Cale> yeah
01:18:27 <notadev> scalar you mean, or..?
01:18:30 <Cale> like:  newtype Dollars = D Integer
01:18:38 <notadev> ah
01:18:42 <notadev> what is D there?
01:18:51 <ski> 'newtype Cat = C Dog Horse' is not allowed
01:18:52 <glguy> A constructor that takes an Integer
01:18:55 <Cale> D is the name of the data-constructor for values of type Dollars
01:18:59 <notadev> oh ok
01:19:00 <glguy> notadev: and returns something of type Dollars
01:19:04 <notadev> cool
01:19:06 <Cale> D :: Integer -> Dollars, as a function
01:19:19 <notadev> :: is has type yes?
01:19:22 <Cale> right
01:19:24 <notadev> k
01:19:36 <Cale> You also have to pattern match against it when you write functions that use Dollars.
01:19:43 <notadev> i don;t get the foo -> bar -> baz tbh
01:19:49 <dolio> dons: A lot of that was pulling code out of the paper. Only the type classes and related stuff was new at all.
01:20:00 <Cale> Oh, A -> B -> C = A -> (B -> C)
01:20:14 <Wild_Cat> notadev: just look at it as a regular, multi-argument type declaration. Even though it's not.
01:20:16 <notadev> how do you separate params and ret tho?
01:20:18 <ski> f x y  =  (f x) y
01:20:31 <glguy> notadev: -> is what makes it a function
01:20:42 <Cale> That is, if we say that f :: A -> B -> C, we mean that it takes a value of type A and returns a (function which takes a value of type B and returns a C)
01:20:44 <glguy> give me an A, I give you a B->C
01:20:47 <notadev> eg f a b ret c d
01:20:48 <glguy> give me a B I give you a C
01:21:09 <notadev> oh ok glguy
01:21:12 <ski> > let f = gcd 10 in f 15
01:21:13 <lambdabot>  5
01:21:22 <Cale> notadev: If it helps, in some sense, every function in Haskell takes one parameter.
01:21:30 <ski> > let f = gcd 10 in map f [11,13..19]
01:21:32 <lambdabot>  [1,1,5,1,1]
01:21:36 <Cale> It's just that many such functions happen to return other functions :)
01:21:42 <notadev> hehe ok it does, but it makes me laugh Cale :-)
01:21:56 <notadev> yeah first-order fns, cool
01:22:13 <glguy> (A -> B) -> C -- give me a function I'll give you a value :)
01:22:29 <notadev> heh ok
01:22:38 <ski> filter :: (a -> Bool) -> [a] -> [a]
01:22:46 <notadev> f a b ret c d # just seems clean
01:22:51 <ski> > filter odd [0..9]
01:22:53 <lambdabot>  [1,3,5,7,9]
01:23:01 <notadev> hmm
01:23:02 <dons> dolio's post deserves a link, http://programming.reddit.com/info/23ej0/comments
01:23:03 <lambdabot> Title: Playing with delimited continuations in Haskell (reddit.com)
01:23:04 <notadev> @src filter
01:23:04 <lambdabot> filter _ []     = []
01:23:05 <lambdabot> filter p (x:xs)
01:23:05 <lambdabot>     | p x       = x : filter p xs
01:23:05 <lambdabot>     | otherwise = filter p xs
01:23:06 <Cale> > (filter odd) [0..9]
01:23:08 <lambdabot>  [1,3,5,7,9]
01:23:19 <notadev> recursion on list cool
01:23:25 <Cale> > let odds = filter odd in odds [0..9]
01:23:27 <lambdabot>  [1,3,5,7,9]
01:23:41 <Cale> See how you don't have to supply all the parameters that way?
01:24:13 <Cale> You can always just supply one of the parameters and get back a function which is going to take the rest of them.
01:24:15 <notadev> (a -> Bool) -> [a] -> [a] -- f a ret bool?
01:24:25 <notadev> hmm
01:24:48 <Cale> filter takes a function from values of some type a to booleans, and a list of values of type a, and returns a list of values of type a
01:24:49 <notadev> so takes f and data and rets data
01:24:57 <notadev> cool
01:25:01 <notadev> list sorry
01:25:30 <Cale> > odd 5
01:25:31 <lambdabot>  True
01:25:33 <Cale> > odd 6
01:25:35 <lambdabot>  False
01:25:40 <Cale> > filter odd [1,2,3,4,5]
01:25:44 <lambdabot>  [1,3,5]
01:25:47 <notadev> @t odd
01:25:47 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
01:25:47 <ski> > map (filter odd) [[1,2,3,4],[1,3,6,10],[1,4,10,20]]
01:25:50 <lambdabot>  [[1,3],[1,3],[1]]
01:25:53 <ski> @type odd
01:25:56 <lambdabot> forall a. (Integral a) => a -> Bool
01:25:59 <notadev> ah thanks
01:26:15 <notadev> forall is nice
01:26:22 <ski> @type map
01:26:22 <notadev> (guard) ?
01:26:24 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
01:26:36 <ski> @type (+)
01:26:38 <lambdabot> forall a. (Num a) => a -> a -> a
01:26:41 <Cale> The forall there is implicitly at the start of every type signature in Haskell if you leave it out.
01:26:59 <quicksilver> notadev: the answer to your f a b ret c d question is f :: a -> b -> (c,d)
01:26:59 <notadev> f a ret b, takes list of a rets list of b
01:27:09 <notadev> quicksilver: thanks!
01:27:11 <quicksilver> notadev: if you want to return two things, you return a tuple
01:27:19 <notadev> cool
01:27:37 <ski> @type uncurry map
01:27:40 <lambdabot> forall a b. (a -> b, [a]) -> [b]
01:27:44 <quicksilver> :t let f a b = (a+b,a-b) in f
01:27:46 <lambdabot> forall a. (Num a) => a -> a -> (a, a)
01:27:54 <quicksilver> > let f a b = (a+b,a-b) in f 4 8
01:27:55 <Cale> You can also have functions which take tuples as parameters, but they're not automatically the same as the usual way to have multiple parameters.
01:27:56 <lambdabot>  (12,-4)
01:27:57 <ski> @type divMod
01:27:59 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
01:28:02 <notadev> hmm
01:28:15 <ski> > 17 `divMod` 7
01:28:17 <lambdabot>  (2,3)
01:28:24 <notadev> Cale: how so?
01:28:27 <ski> > 2*7 + 2
01:28:29 <lambdabot>  16
01:28:31 <ski> > 2*7 + 3
01:28:32 <lambdabot>  17
01:28:39 <notadev> `backticks`?
01:28:44 <Cale> notadev: Well, tuples are data structures in their own right, so the type is different.
01:28:49 <quicksilver> backticks make something infix
01:28:50 <notadev> hmm i've heard this one somewhere
01:28:51 <Cale> > let f (x,y) = x + y in f (5,6)
01:28:53 <lambdabot>  11
01:29:00 <Cale> > let f x y = x + y in f 5 6
01:29:03 <lambdabot>  11
01:29:07 <notadev> quicksilver: ty again :)
01:29:19 <Cale> :t let f x y = x + y in f
01:29:21 <lambdabot> forall a. (Num a) => a -> a -> a
01:29:26 <Cale> :t let f (x, y) = x + y in f
01:29:28 <lambdabot> forall t. (Num t) => (t, t) -> t
01:29:28 <ski> '(..foo..) `f` (..bar..)' is the same as 'f (..foo..) (..bar..)'
01:29:32 <notadev> wow
01:29:38 <notadev> seems odd tho
01:29:40 <ski> > 17 `divMod` 7
01:29:42 <lambdabot>  (2,3)
01:29:46 <ski> > divMod 17 7
01:29:48 <lambdabot>  (2,3)
01:29:52 <notadev> f (a,b) c ret blah
01:30:08 <ski> > odd `map` [0,1,3,6,10]
01:30:10 <lambdabot>  [False,True,True,False,False]
01:30:18 <notadev> nice ski :)
01:30:34 <notadev> @src fu
01:30:34 <lambdabot> Source not found. Maybe if you used more than just two fingers...
01:30:46 <ski> > 5 `elem` [0..9]
01:30:47 <lambdabot>  True
01:31:07 <ski> 'fu' ?
01:31:07 <glguy> > not `fmap` odd $ 5
01:31:09 <lambdabot>  False
01:31:36 <Cale> > (++) `foldr` [] $ ["This ", "is ", "a ", "list."]
01:31:37 <notadev> > let fu (a,b) c=a**2+b**2+4ac in fu
01:31:37 <lambdabot>  "This is a list."
01:31:38 <lambdabot>   Not in scope: `ac'
01:31:47 <notadev> > let fu (a,b) c=a**2+b**2+4a*c in fu
01:31:48 <lambdabot>   add an instance declaration for (Num (a -> a))
01:31:48 <lambdabot>     In the expression:
01:31:48 <lambdabot>      ...
01:32:02 <Cale> > let fu (a,b) c = a**2+b**2+4*a*c in fu
01:32:04 <lambdabot>  <(Double,Double) -> Double -> Double>
01:32:10 <notadev> woah
01:32:28 <Cale> hehe, it defaulted the number type :)
01:32:29 <notadev> spacing is relevant round =
01:32:33 <ski> @src $
01:32:33 <lambdabot> f $ x = f x
01:32:38 <Cale> no, you were missing a *
01:32:41 <quicksilver> notadev: no, your mistake was '4a'
01:32:42 <notadev> lol
01:32:44 <notadev> thanks
01:32:46 <Cale> after the 4
01:33:13 <notadev> > let fu (a,b) c=a**2+b**2+4*a*c in fu (2,3) 4
01:33:16 <lambdabot>  45.0
01:33:19 <notadev> yay!
01:33:28 <Cale> Incidentally, it thought you meant to apply 4 as a function, which prompted it to tell you that it doesn't know how to treat functions as numbers :)
01:33:38 <notadev> hmm
01:33:46 <notadev> 4(a)?
01:33:51 <Cale> yeah
01:33:52 <notadev> interesting
01:34:13 <notadev> (Num (a -> a)) ?
01:34:15 <Cale> right
01:34:19 <notadev> how to do that?
01:34:41 <notadev> sorry tangent
01:34:50 <Cale> If there was an instance of Num for (a -> a), then it could proceed to treat 4 as a function of type a -> a, and the 4a would work.
01:35:00 <haskell> a -> a a useful instance does not make
01:35:02 <Cale> (but there isn't)
01:35:11 <notadev> cool
01:35:38 <ski> instance Num a => Num (x -> a) where {(+) = liftM2 (+); ...}
01:35:40 <dons> glguy just ruined my irc nick counting script
01:35:46 <haskell> ?
01:35:53 <dons> ?where stats
01:35:53 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
01:36:03 <notadev> :t let fu (a,b) c=a**2+b**2+4*a*c in fu
01:36:06 <lambdabot> forall t. (Floating t) => (t, t) -> t -> t
01:36:18 <dons> does Peng Li ever hang out here?
01:36:27 <ski> :t \(a,b) c -> a**2+b**2+4*a*c
01:36:29 <lambdabot> forall t. (Floating t) => (t, t) -> t -> t
01:36:36 <quicksilver> dons: those scripts are normally pretty robust to nick changes
01:36:36 <notadev> lamda fun?
01:36:49 <glguy> dons: I'm in console, viewing that page is hard
01:36:59 <notadev> -> is described how ski?
01:37:01 <dons> quicksilver: i think it will say "haskell' is the top user.
01:37:02 <ski> > map (\x -> x^2 + 1) [-3,-4..-9]
01:37:03 <lambdabot>   Not in scope: `..-'
01:37:09 <ski> > map (\x -> x^2 + 1) [-3,-4 .. -9]
01:37:12 <lambdabot>  [10,17,26,37,50,65,82]
01:37:20 <notadev> hehe
01:37:21 <Cale> notadev: in an expression, it's part of the syntax of lambdas
01:37:21 <earthy> > uncurry (ap (+) . (*)) $ (17 `divMod` 7)
01:37:23 <lambdabot>  9
01:37:25 <ski> notadev : do you mean "pronounced" ?
01:37:28 <glguy> dons: why would that break it?
01:37:32 <quicksilver> dons: it remembers people by the first nick it sees for them
01:37:34 <notadev> ski: i guess
01:37:37 <quicksilver> dons: and it tracks them through nick changes
01:37:48 <quicksilver> dons: at least, that's how it's worked on other chanells I've seen those scripts run on
01:37:57 <notadev> Cale: i just mean nomenclature
01:37:58 <Cale> (\x -> x^2 + x + 1) is the function which sends x to x^2 + x + 1
01:38:10 <notadev> derives or summat
01:38:15 <Cale> > (\x -> x^2 + x + 1) 5
01:38:16 <ski> notadev : '\x -> frotz' could be read as "lambda x maps to frotz"
01:38:17 <lambdabot>  31
01:38:24 <notadev> ski: cool :)
01:38:31 <quicksilver> notadev: in a type it's often read "arrow"
01:38:40 <quicksilver> "a -> b -> c" "a arrow b arrow c"
01:38:43 <notadev> meh not mathematical
01:38:43 <ski> note that the '->' in types is not the same (but related)
01:38:47 <Cale> I read it as "to" in most cases.
01:38:48 <notadev> hmm
01:38:59 <Cale> "a to b to c"
01:39:03 <notadev> Cale: ah ok thanks :)
01:39:31 <notadev> `derives' feels right to me somehow
01:39:43 <notadev> or is there a derives op?
01:39:55 <Cale> hm?
01:40:11 <notadev> dunno only heard of bind tbh, and seen $
01:40:22 <Cale> f :: Integer -> Double is read as "f is a function from Integer to Double"
01:40:36 <notadev> ok
01:40:43 <notadev> bindSingle and GG?
01:40:48 <quicksilver> notadev: yea, 'deriving' is a keyword meaning something quite different
01:40:56 <notadev> quicksilver: ah nm then :)
01:40:57 <Cale> Or "f has type Integer to Double", but that's a little more awkward-sounding.
01:41:15 <notadev> yeah second sounds more correct Cale
01:41:29 <notadev> to it is then :D
01:42:02 <notadev> what is deriving in hs then?
01:42:05 <ski> "f goes from Integer to Double"
01:42:14 <notadev> heh
01:42:23 <quicksilver> notadev: it's a way of automatically writing type classes for you
01:42:28 <notadev> ?
01:42:43 <ski> s/tupe classes/(type class) instances/
01:42:48 <notadev> hmm i saw something on class extension
01:43:18 <earthy> okay, small tiny cabal question
01:44:01 <glguy> there is a smaller version of cabal out?
01:44:07 <notadev> meh didn't bookmark it; it seemed to be implying that overloading and inheritance were difficult tho
01:44:21 <earthy> when you want to install a cabal package locally instead of globally (that is, in your user dir instead of in e.g. /usr/local), is there a default option to request that?
01:44:25 <notadev> some implementation paper
01:44:28 <notadev> nm
01:44:40 <glguy> earthy: runghc Setup configure --prefix=$HOME
01:44:46 <glguy> earthy: runghc Setup install --user
01:45:11 <earthy> and it has no way of figuring that out itself, the $HOME part?
01:45:38 <earthy> as in configure --user
01:45:39 <glguy> no, because you could install to /usr/local
01:45:42 <glguy> but register to --user
01:45:48 <Cale> notadev: It's important to note that "class" doesn't mean the same thing in Haskell as it does in all the OO languages.
01:46:14 <notadev> you mean metaclass or?
01:46:14 <glguy> yeah, in OO class means "we got lazy and forced name spaces and encapsulation into the same entity"
01:46:20 <Cale> hehe
01:46:28 <earthy> right, got it. thanks glguy
01:46:46 <ski>   data MyBool = Never | Inadmissible
01:46:47 <earthy> (DoCon has an absolutely shitty default installation location :))
01:46:50 <ski>   instance Eq MyBool
01:46:51 <Cale> notadev: It's something completely different. It's closer an interface in Java, if you know about those.
01:46:53 <ski>     where
01:46:57 <ski>     Never        == Never        = True
01:46:59 <Cale> to*
01:47:01 <ski>     Inadmissible == _            = False
01:47:03 <ski>     _            == Inadmissible = False
01:47:27 <notadev> Cale: yeah i do :)
01:47:40 <ski> notadev : that's an example of making the type 'MyBool' an instance of the type class 'Eq'
01:48:04 <notadev> nice one ski :)
01:48:27 <notadev> looks a bit like ML
01:48:41 <Cale> Basically, a typeclass can be thought of as a predicate (something which is true or false) on types, and wherever the predicate is true, it implies that some collection of functions exist for that type (or types, in the case of multiparameter typeclasses)
01:48:43 <glguy_> damned linux support for ipw3945 wireless is unstable :(
01:48:58 <notadev> Cale: yeah exactly same as i/f
01:49:13 <ski> to implement 'Eq a' for a type 'a' (here 'MyBool') one has to implement '(==) :: a -> a -> Bool' or '(/=) :: a -> a -> Bool' for the type 'a' in question
01:49:15 <notadev> except for the last bit ofc :)
01:49:45 <ski> type classes are somewhat like interfaces in some OO languages
01:49:46 <notadev> ski: cool
01:49:55 <Cale> One neat thing is that functions written using the functions in a typeclass can themselves be polymorphic, as if they were part of that interface.
01:50:10 <notadev> so overloading is easy?
01:50:16 <Cale> yeah
01:50:17 <ski> (there's default implementation of '(==)' and '(/=)' in terms of each other, which is why you only need to define one of them)
01:50:19 <notadev> nice
01:50:20 <quicksilver> type classes are the overloading mechanism
01:50:30 <notadev> hmm
01:50:39 <Cale> It's a much more structured form of overloading than the ad-hoc overloading you get in, say, C.
01:50:49 <notadev> meaning?
01:50:50 <ski> Cale : itym C++
01:50:55 <Cale> Er, yes, C++
01:51:03 <notadev> heh same diff ;)
01:51:16 <ski> (C has no overloading of functions)
01:51:22 <Cale> :t sort
01:51:25 <lambdabot> forall a. (Ord a) => [a] -> [a]
01:51:36 <notadev> Ord=enumerable?
01:51:44 <glguy> Enum = enumerable
01:51:46 <glguy> Ord is orderable
01:51:49 <notadev> ah ok
01:51:50 <Cale> Ord = ordered
01:51:58 <Cale> That is, comparable with (<) and so on.
01:51:58 <glguy> ?src Ord
01:51:58 <lambdabot> class  (Eq a) => Ord a  where
01:51:58 <lambdabot>     compare      :: a -> a -> Ordering
01:51:58 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
01:51:58 <lambdabot>     max, min         :: a -> a -> a
01:52:02 <notadev> thought it was Ordinal, sorry
01:52:04 <ski> > sort "the quick brown fox jumps over the lazy dog"
01:52:06 <lambdabot>  "        abcdeeefghhijklmnoooopqrrsttuuvwxyz"
01:52:20 <mgsloan> would be interesting, perhaps useful to have an enum for floating types
01:52:28 <mgsloan> ?src Enum
01:52:28 <lambdabot> class  Enum a   where
01:52:28 <lambdabot>     succ                     :: a -> a
01:52:28 <lambdabot>     pred                     :: a -> a
01:52:28 <lambdabot>     toEnum                   :: Int -> a
01:52:28 <lambdabot>     fromEnum                 :: a -> Int
01:52:28 <glguy> mgsloan: we do
01:52:30 <lambdabot> [3 @more lines]
01:52:31 <Cale> > sort ["these", "sort", "into", "dictionary", "order"]
01:52:32 <mgsloan> do we?
01:52:32 <lambdabot>  ["dictionary","into","order","sort","these"]
01:52:35 <notadev> oh man those to chains
01:52:36 <mgsloan> sweet
01:52:46 <glguy> > [1.0, 1.1.. 2.0]
01:52:48 <lambdabot>  [1.0,1.1,1.2000000000000002,1.3000000000000003,1.4000000000000004,1.50000000...
01:52:57 <Cale> heh
01:52:57 <mgsloan> > succ (3.5 :: float)
01:52:58 <lambdabot>        add (Fractional float) to the expected type of an expression
01:52:59 <lambdabot>     In th...
01:53:12 <glguy> hmm
01:53:12 <mgsloan> :(
01:53:13 <Cale> > succ (3.5 :: Float)
01:53:15 <lambdabot>  4.5
01:53:17 * notadev 's brain fries... *bzzt* ;)
01:53:20 <mgsloan> oh
01:53:30 <Cale> hehe
01:53:36 <mgsloan> I should stop staying up so late, it kinda impedes coding
01:53:42 <Cale> Rapid cranial expansion.
01:53:46 <mgsloan> hah
01:53:48 <glguy> ?src Enum
01:53:48 <lambdabot> class  Enum a   where
01:53:49 <lambdabot>     succ                     :: a -> a
01:53:49 <lambdabot>     pred                     :: a -> a
01:53:49 <lambdabot>     toEnum                   :: Int -> a
01:53:49 <lambdabot>     fromEnum                 :: a -> Int
01:53:51 <lambdabot> [3 @more lines]
01:53:55 <ski> @more
01:53:55 <lambdabot>     enumFrom                 :: a -> [a]
01:53:55 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
01:53:56 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
01:53:57 <mgsloan> Cale - really, succ on float shouldn't add one
01:54:02 <glguy> > fromEnum (4.5 :: Float)
01:54:04 <lambdabot>  4
01:54:05 <Cale> mgsloan: It's convenient.
01:54:08 * glguy doesn't much like that
01:54:11 <mgsloan> it should go to the next float
01:54:21 <mgsloan> i suppose
01:54:31 <ski> dual numbers ?
01:54:42 <quicksilver> the enum instance for Float is very bogus indeed
01:54:43 <mgsloan> next actual float value representable
01:54:44 <Cale> It makes [1..] work sort of the way that you'd expect, rather than in a kind of useless way.
01:55:11 <quicksilver> Cale: I'd rather force you to do map fromIntegral [1..] personally :)
01:55:38 <glguy> quicksilver: iterate (+1) 0
01:56:05 <mgsloan> I think being able to succ/pred floats might be handy for finding a good floating point approximation for something, indeed perhaps the best floating point approximation for that precision
01:56:38 <mgsloan> I think [1..] should just have an implicit stepsize of 1
01:56:50 <quicksilver> mgsloan: yes, that might be useful. But the current instance is totally bogus
01:56:59 <quicksilver> mgsloan: that doesn't make sense
01:57:09 <quicksilver> mgsloan: [1..] is based on stepping through enums
01:57:11 <quicksilver> > [False..]
01:57:12 <lambdabot>  Parse error
01:57:13 <glguy> > [False .. ]
01:57:15 <lambdabot>  [False,True]
01:57:26 * glguy high fives quicksilver (I was thinking the same thign)
01:57:26 <quicksilver> mgsloan: what does 'implicit stepsize 1' mean for other types?
01:57:48 <ski> enumFrom x = enumFromThen x (x+1)  -- mayhaps ?
01:57:54 <mgsloan> ok, so i guess maybe not then
01:57:58 <ski> enumFrom x = enumFromThen x (succ x)  -- or perchance ?
01:58:12 <mgsloan> yeah, that notation already has numerics specific variants
01:58:12 <quicksilver> of course Double couldn't be a Enum instance in the 'natural' way, anyway
01:58:18 <mgsloan> > [1,3..10]
01:58:20 <quicksilver> it's too big to fit in an Int
01:58:20 <lambdabot>  [1,3,5,7,9]
01:58:31 <quicksilver> mgsloan: that's not numerics specific
01:58:39 <mgsloan> hmm
01:58:47 <mgsloan> > ['a', 'c'..]
01:58:48 <quicksilver> data Color = Red | Orange | Pink | Blue; [Red,Pink..]
01:58:50 <lambdabot>  "acegikmoqsuwy{}\DEL\129\131\133\135\137\139\141\143\145\147\149\151\153\155...
01:58:54 <mgsloan> i guess not
01:58:56 <ski> polynomial interpolation ftw !
01:59:03 <mgsloan> :)
01:59:37 <Cale> Heh, we should have something which looks up a formula for the provided terms by searching Sloane's OEIS.
01:59:37 <ski> [1,3,6 ..] -- thing should then yield the positive triangular numbers
01:59:54 <ski> Cale : !
02:00:04 <Cale> [1,2,3,6,11,23,47,106,235..]
02:00:15 <Cale> Would give the number of trees on n unlabelled nodes.
02:01:12 <mgsloan> > concatMap (\x -> ['a', x..]) ['b','z']
02:01:15 <lambdabot>  "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137\...
02:01:21 <mgsloan> oh yeah
02:01:27 <mgsloan> > concatMap (\x -> ['a', x..'z']) ['b','z']
02:01:29 <lambdabot>  "abcdefghijklmnopqrstuvwxyzaz"
02:01:46 <mgsloan> > concatMap (\x -> ['a', x..'z']) ['b'..'z']
02:01:47 <lambdabot>  "abcdefghijklmnopqrstuvwxyzacegikmoqsuwyadgjmpsvyaeimquyafkpuzagmsyahovaiqya...
02:01:50 <mgsloan> ok, I'm done
02:01:55 <Cale> @v
02:01:56 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
02:02:04 <mgsloan> def. time to go to sleep
02:02:23 <earthy> nighty night mgsloan
02:04:46 <glguy> > fix show
02:04:48 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
02:06:10 <matthew-_> ok, your challenge today is, how would you represent a finite state machine as types
02:06:24 <ski> > fix read
02:06:26 <lambdabot>  Exception: <<loop>>
02:06:50 <dons> so i asked about the haskell-no-idea-concurrency issue on reddit, and the response is along the lines of "i don't know if ghc can handle multiple cores, but i know erlang can".
02:06:53 <dons> we need some branding .
02:07:02 <matthew-_> eh?
02:07:06 <dons> should i take photos of ghc sitting on my 16 core box? :)
02:07:29 <vincenz> o.O
02:07:32 <matthew-_> dons: there was just a thread on the erlang mailing list two days ago in which I + joelr + others were talking about this!
02:07:35 <vincenz> you can take pictures of moving electrons?
02:07:38 <dons> oh, earlier discussion we had re. haskell v erlang, and why people don't see haskell as a reasonable langauge for big concurrency.
02:08:06 <matthew-_> dons: http://www.erlang.org/pipermail/erlang-questions/2007-July/027643.html
02:08:07 <dons> matthew-_: right. and no one pointed out the paralell, multicore support in haskell/ghc
02:08:08 <lambdabot> Title: [erlang-questions] Erlang vs. Haskell, http://tinyurl.com/33oazg
02:08:45 <dons> yep, that's the thread i was referring to. i pondered it here, http://programming.reddit.com/info/2330q/comments/c23egr
02:08:46 <lambdabot> Title: Erlang vs. Haskell (reddit.com)
02:08:53 <matthew-_> dons: I don't see Haskell as a reasonably language for message passing concurrency
02:09:54 <dons> maybe not, but there's also data parallel arrays, parallel strategies, Chans, MVars, STM, user-land schedulers, and big (40 core) support. which was not raised :/
02:10:09 <matthew-_> well, it was on Erlang.
02:10:14 <dons> is message passing the end of concurrency abstractions? is it a "support this, or perish" story?
02:10:15 <matthew-_> they tend to like message passing
02:10:19 <dons> yes :)
02:10:37 <matthew-_> I like message passing too. But it's really hard to type. It's pretty much the focus of my PhD
02:10:54 <dons> my point on reddit was that everyone knows erlang has message passing, but no one knows much about the haskell abstractions.
02:10:55 <matthew-_> and I did mention Chans, MVars and STM
02:11:04 <matthew-_> well, STM basically doesn't work
02:11:08 * matthew-_ ducks
02:11:18 <dons> well.. that's the older generation of abstractions anyway
02:11:33 <dons> no data parallel arrays, or user-land schedulers, or parallel strategies
02:11:50 <matthew-_> Chans are normally less useful than building your own chain of MVars yourself as knowing the position within the Chan is normally very useful
02:12:01 <matthew-_> and MVars, which you're left with, are pretty primitive
02:12:14 <osfameron> maybe haskell has *too many* ways to do it, while Erlang has some basic, documented ones that are known to work?
02:12:32 <notadev> so what;s a clean way in hs then?
02:12:42 <matthew-_> yes, the other stuff is interesting but, err, user-land schedulers? - do you mean co-routines or just the workqueue stuff?
02:12:43 <osfameron> also "message passing" sounds much less scary than "Chan", "MVars", "STM" etc.
02:12:54 <dons> matthew-_: the unified events abstractions.
02:12:54 <notadev> chan is nicer imo
02:12:58 <dons> Peng Li et al.
02:13:03 <matthew-_> ahh
02:13:10 <notadev> Z and SDL are cool for FSM stuff
02:13:13 <matthew-_> right, so Erlang has that anyway
02:13:16 <dons> matthew-_: http://research.microsoft.com/~simonpj/papers/lw-conc/index.htm / http://www.seas.upenn.edu/~lipeng/homepage/unify.html
02:13:17 <lambdabot> Title: Lightweight concurrency primitives for GHC
02:13:31 <notadev> s/are/were/
02:13:34 <malcolmw> matthew-_: I wrote a paper on type-checked message passing, at the glasgow FP workshop 1993(?)
02:13:45 <dons> and even in the end, ghc wipes hipe off the map performance wise.
02:13:59 <dons> so, what to do?
02:14:06 <matthew-_> dons: oh come on, hipe is not in the same league as GHC
02:14:29 <matthew-_> the fact that Erlang can compete with GHC on some work loads is pretty impressive (for Erlang)
02:14:34 <malcolmw> message-passing in Haskell is far from impossible
02:15:18 <matthew-_> malcolmw: well yes, but for example, the general actor model is very hard (impossible?) to do as you can't statically type the mailbox
02:15:23 <malcolmw> mind you, back then I insisted on a static assignment of threads - dynamic thread creation + typed message passing might be more tricky
02:15:24 <dons> what has to happen to have haskell taken seriously for high perf parallelism? do we need to implement the erlang api? more documentation? tutorials?
02:15:47 <dons> i really like writing haskell code for the 16 core server at work, so its disheartening to see people don't even realise ghc can do smp/multicore :/
02:15:47 <notadev> dons: make it run faster than Erlang
02:16:07 <dons> it does already, notadev... i don't think performance is the issue here.
02:16:14 <notadev> oh ok
02:16:19 <notadev> fsck em then ;)
02:16:28 <dons> its some mind share/ documentation issue -- or is it an API/abstraction issue, as matthew-_ says?
02:16:29 <notadev> they'll learn soon enuff :D
02:16:50 <matthew-_> it's simply fear of change
02:16:55 <malcolmw> I'm thinking about how to do multi-threading across heterogeneous machines (non-SMP)
02:17:01 <matthew-_> and that Haskell is changing too quickly
02:17:05 <dons> matthew-_: i mean, a Typeable message api could be done simply enough -- we have dynamic typing for the few things that need it.
02:17:15 <matthew-_> eg the endless API library changes that break code
02:17:17 <notadev> malcolmw: you mean distr computing?
02:17:31 <matthew-_> with Erlang, if it worked ten years ago, odds are it works now
02:17:39 <matthew-_> plus Erlang has a huge track record
02:17:44 <malcolmw> I reckon it isn't too hard to (a) send a function from machine A to machine B, then send messages from A to B for the function at B to consume
02:17:47 <dons> yes. so stability, familiarity, "branding" as a concurrent language.
02:17:52 <matthew-_> and has clearly been built by engineers rather than academics
02:17:55 <malcolmw> typechecking comes for free
02:17:58 <matthew-_> and I mean that in the nicest possible way
02:18:07 <notadev> stability reliability and consistency
02:18:08 <dons> matthew-_: yeah, some of the erlang semantics gives me shivers :)
02:18:42 <dons> so, how do we address this? lock down the apis, document them better, write more apps that use 16 cores.
02:18:48 <matthew-_> dons: ok, I really dislike dynamic typing. And yes, Erlang is certainly not pure, but it gets the job done, and proveably so
02:18:50 <dons> build a culture of *expecting* to use 16 cores.
02:18:51 <Olathe> I thought it was funny when someone claimed that Haskell was a functional language couldn't flatten lists.
02:18:54 <notadev> malcolmw: no course it isn't :)
02:19:14 <notadev> dons: don't break old code
02:19:19 <dons> the erlang blogs tend to toss parMap into everything. why don't we start doing that?
02:19:27 <osfameron> of course the "why aren't we as popular as Erlang" question is odd given that people are still frightened of Erlang :-)
02:19:32 <dons> "oh, and we could spark off 1000 threads to do this"
02:19:32 <matthew-_> Olathe: err, that was me. You can't (easily) implement the Erlang lists:flatten/1 function
02:19:33 <notadev> hehe
02:19:56 <notadev> "The Judean's People's Front.." osfameron? ;)
02:20:17 <matthew-_> and I would say that Haskell has a much more active community than Erlang and a much better chance of surviving the next ten years
02:20:19 <osfameron> (we're using Perl or Java variously for things which would probly be more robust in Erlang.  Actually we now have 2 Erlang hackers, so we're *finally* doing chat with that, which is cool, but not message queueing or anything else)
02:20:37 <matthew-_> osfameron: what's the use case?
02:20:39 <notadev> chat?
02:20:45 <dons> matthew-_: yeah, i can see it surviving. the academic base won't let it die. but maybe it will live on like scheme.
02:20:48 <osfameron> as in Jabber chat
02:20:54 <dons> whereas it could break out, and we'd all have jobs
02:20:56 <notadev> heh
02:21:25 <glguy> dons: who'd all have jobs doing what?
02:21:47 <dons> not writing dodgy python programs that don't quite use their 64 cores properly^h^h^h at all
02:21:52 <matthew-_> dons: I'd love to see that happen, but it's effectively an eugenics program; as Jan Vitek says: the problem with Haskell is that you have to too clever to do anything in it
02:22:06 <osfameron> matthew-_: various things involved in running a "social network" (so chat, event handling, image uploads etc.  lots of which could be well served by a message queue, and idealy not one rolled together in house by one of the most junior perl devs...) /me cries
02:22:09 <glguy> dons: but we already have jobs writing haskell :-p
02:22:10 <dons> yes, that's probably the most devastating meme.
02:22:23 <dons> considering people don't say that about erlang .. and its 3/4 haskell
02:22:33 <dons> glguy: we do. but we're the only ones :P
02:22:55 <glguy> syntaxninja, shapr, alexj, a bunch of others that I don't rmemeber
02:22:58 <dons> its good to see the commercial guys uploading new strange libs to hackage.
02:22:59 <glguy> that's just in #haskell
02:23:03 <dons> that's a promising sign.
02:23:13 <dons> yeah, i know, glguy :-)
02:23:26 * Vq^ has been payed for writing a few Haskell programs
02:23:30 <glguy> you going to run openbsd at galois?
02:23:42 <dons> we'll see, i'd have to give it up on my personal laptop
02:23:53 <matthew-_> dons: no no no, Erlang is "functional" in that it's not Java. But the gulf of difference between Erlang and Haskell is as wide as the atlantic
02:23:55 <dons> admining linux is to openbsd, as c++ is to haskell ;)
02:24:13 <Vq^> heh
02:24:14 <glguy> I'm running linux on my work laptop
02:24:23 <glguy> but I don't think there is a work reason I couldn't run obsd
02:24:28 <notadev> Gentoo is quite good tho imo
02:24:32 <Vq^> i'm running gnu on my workstation
02:24:33 * glguy is on Gentoo atm
02:24:39 <notadev> hehe me too
02:24:44 <glguy> Vq^: how is hurd working out?
02:24:51 <dons> matthew-_: hmm, maybe you should write up some technical comparisons? when i look at erlang, i see a sort of broken FP interpreter, without a type system, but nothing too shocking.
02:24:53 <Vq^> glguy: no idea, i don't use hurd
02:25:00 <notadev> is that still going?
02:25:01 <glguy> Vq^: oh, emacs then :)
02:25:03 <glguy> that's a cool os
02:25:04 <dons> ok. dinner time. bbl
02:25:06 <notadev> hehe
02:25:18 <Vq^> glguy: for some things, yes
02:25:22 <matthew-_> dons: indeed, as you're looking "down" from Haskell. It's a cliff drop. Looking up is harder!
02:25:32 <Vq^> glguy: i swap between emacs and elvis for editing
02:25:40 <glguy> elvis?
02:25:46 * glguy has heard the name, can't place it
02:25:52 <glguy> emacs vi mode?
02:26:03 <Vq^> vi editor with fairly good X11 support
02:26:16 <glguy> how does that compare to gvim?
02:26:22 <Vq^> i started using it in the days when it was as popular as vim
02:26:35 <Vq^> dunno, i don't use gvim
02:26:35 <notadev> gvim is quite nice as well
02:26:44 <notadev> altho i like kate for C
02:26:48 <Vq^> i always miss the :bb command when im using vim :/
02:26:51 <glguy> bb?
02:26:59 <Vq^> haven't found a good replacement for it in vim
02:27:03 <notadev> blub ;)
02:27:12 <Vq^> glguy: buffer-list
02:27:21 <notadev> gvim has buffers
02:27:27 <Vq^> i know
02:27:29 <notadev> dunno about keystrokes
02:27:34 <glguy> :buffer-list
02:27:34 <notadev> just installed it
02:27:34 <glguy> ?
02:27:45 <glguy> errr
02:27:46 <glguy> :buffers?
02:27:50 <Vq^> but find it much easier to swap buffers in elvis
02:27:59 <notadev> can you shorten it tho glguy?
02:28:05 <earthy> :ls
02:28:07 <ski> C-x b
02:28:08 <earthy> shows the open buffers in vim
02:28:15 <notadev> cool
02:28:19 <Vq^> ski: yeah, that works :)
02:28:24 <glguy> yeah, :ls seems to work
02:28:37 <ski> (iswitchb-mode :)
02:28:39 <earthy> ofcourse, you might want to install MiniBufExplorer
02:28:42 <glguy> I don't use separate buffers so much, I use CTRL-I and CTRL-O a lot
02:29:06 <earthy> which also shows you a list of buffers in the top line or two of your window
02:29:16 <glguy> gvim has tabs
02:29:17 <earthy> unless you have less than a configurable number of buffers opened
02:29:19 <Vq^> earthy: actually i would like to uninstall it
02:29:23 <earthy> glguy: that too. ;)
02:29:24 <notadev> lol
02:29:39 <earthy> Vq^: uninstalling minibufexplorer is trivial. just throw away the plugin's code
02:29:45 <earthy> you can also turn it off
02:30:00 <Vq^> throwing it away seems best
02:30:31 <glguy> Have you used CTRL-I/O for moving between recent positions in recent files before?
02:30:54 <earthy> glguy: I have. it kinda depends on having a good completionregexp though
02:31:09 <Vq^> earthy: thanks about the :ls tip
02:31:37 <earthy> setlocal include=\\(^\\s*\\\|;\\s*\\)import\\s\\+\\(qualified\\)\\?\\s*
02:31:37 <earthy> setlocal includeexpr=substitute(v:fname,'\\.','/','g')
02:31:37 <earthy> setlocal suffixesadd=.hs,.lhs
02:31:49 <glguy> I need to learn about buffers in vim
02:31:57 <glguy> I've spent a lot of time with editing commands
02:32:03 <earthy> buffers and tabs are useful
02:32:11 <glguy> do tabs work in the console vim
02:32:11 <Vq^> :ls seems to have a weird side-effect thought
02:32:17 <earthy> what's that then?
02:32:31 <Vq^> sometimes the next time i press : it writes a lot of other junk
02:32:43 <earthy> hm. never saw that
02:32:47 <Vq^> :.,.+1 for example
02:32:58 <profmakx> glguy yes, the do
02:33:00 <profmakx> +y
02:33:32 * glguy needs to learn tabs in vim then
02:33:42 <glguy> I've only used them with gvim's open new tab... menu item
02:34:01 <earthy> :tabnew
02:34:17 * earthy virtually never uses gvim's menus
02:34:22 <profmakx> :tabnext ;)
02:34:35 <earthy> gT, right? :)
02:34:49 <glguy> yeah, gT
02:34:52 <glguy> brilliant!
02:35:13 <glguy> and gt
02:35:15 <glguy> gt is forward
02:35:17 <glguy> gT is back
02:35:17 <Vq^> another nice command in elvis is ^Wd
02:35:18 * earthy nods
02:35:23 <Vq^> for switching display mode
02:35:30 <Vq^> for example between text and hex-editor
02:35:36 <glguy> ahh
02:35:40 <Vq^> or web-browser and text
02:35:44 <glguy> g? is for rot-13 :)
02:35:49 <earthy> :)
02:35:59 <glguy> I like the diw daw, di" ci" commands
02:36:17 <glguy> etc
02:36:49 <glguy> I've added those to the commands I'm trying to really ingrain lately
02:37:08 <matthew-_> just use edlin. It's the one true editor!
02:37:20 <matthew-_> (from about 1975...(
02:37:22 <glguy> yeah, but you also write about Erlang...
02:37:23 <glguy> so
02:37:30 <glguy> ;)
02:37:51 <matthew-_> glguy: I write about many things!
02:38:06 <glguy> ruby?
02:38:11 <matthew-_> ewwwww!
02:38:16 <glguy> ok, we're cool
02:38:38 <Vq^> matthew-_: theres nothing true about edlin
02:39:44 <matthew-_> glguy: that's the #haskell equiv. of "a/s/l?" isn't it?! "Do you blog about ruby?"
02:39:47 <Vq^> damn ed(1) ripoff :)
02:40:40 <glguy> matthew-_: maybe? :)
02:42:55 <glguy> hmm... the later I stay up, the more trouble I'm going to be in
02:42:58 <glguy> good night!
02:43:25 <ski> http://recycledknowledge.blogspot.com/2006/11/being-haxeor.html
02:43:26 <lambdabot> Title: Recycled Knowledge: Being a HAXEor
03:03:38 <roconnor> Patterns I Hate #1: Global Variables.
03:03:57 <profmakx> o.o
03:04:18 <profmakx> in reference to Singletons?
03:04:22 <roconnor> yep
03:04:40 <roconnor> not that I really know what a Singleton is.
03:04:49 <roconnor> but it sounds awfully like a global variable.
03:04:57 <profmakx> in some way it is
03:05:21 <profmakx> i never really understood what the point of a singleton is
03:05:27 <roconnor> The problems being complained about seem like the problems of a global variables.
03:07:13 <WP-Gast856> why
03:11:19 <Cale> It's exactly like a cluster of global variables.
03:11:37 <Cale> With all the same problems.
03:11:38 <WP-Gast856> Cale sucks
03:11:46 --- mode: ChanServ set +o Cale
03:11:55 --- mode: Cale set +b *!*@77-56-92-231.dclient.hispeed.ch
03:11:56 --- kick: WP-Gast856 was kicked by Cale (Cale)
03:13:15 --- mode: Cale set +b WP-Gast*!*@*
03:13:29 <Cale> Those are always bots
03:13:35 --- mode: Cale set -o Cale
03:13:57 <eivuokko> Those who advocate singletons over global variables typically show how extra abstraction on creation and member access make it safer.
03:14:30 <osfameron> singletons for things like configuration are always handy and easy to implement, up until the point that they're not.
03:14:44 <osfameron> if you don't get to that point, then they're a good idea :-)
03:15:24 <dons> Cale: you've seen them elsewhere? in #math?
03:16:40 <Cale> yes
03:17:10 <matthew-_> malcolmw: ok, I've read that. Thanks for the pointer. But as you say, you demand staticly known processes.
03:17:23 <matthew-_> or, in particular, addresses.
03:17:30 <malcolmw> matthew-_: indeed
03:17:32 <Cale> dons: They always sit around and ask "why?" and randomly insult people.
03:18:01 <Cale> In a very mechanical fashion
03:18:36 <dons> silly bots
03:18:39 <malcolmw> matthew-_: it was sufficient for the simple embedded control systems I was programming in Haskell back then
03:20:04 <matthew-_> malcolmw: sure. It's a shame you didn't actually talk about the implementation of primsend and primrecv
03:20:10 <matthew-_> was sending async?
03:20:11 <Cale> http://irc-archive.com/read/FreeNode/apache/2007-05-27/17 -- heh, here's another run of what appears to be the same bot
03:20:12 <lambdabot> Title: apache @ FreeNode IRC archive (2007-05-27 17:00) Page 1 of 2
03:20:31 <Cale> There, the nick is "turmo", but WP-Gast is the username
03:20:36 <malcolmw> matthew-_: yes, sending was asynchronous
03:20:48 <malcolmw> matthew-_: there was a queue of messages for every thread
03:21:11 <malcolmw> matthew-_: and hardware interrupts could jump the queue to get serviced faster
03:21:25 <matthew-_> malcolmw: wow - it really was embedded eh?
03:21:39 <matthew-_> so the prims were implemented in C?
03:21:49 <malcolmw> matthew-_: yeah, running on a M68000 board connected by serial line to a terminal
03:22:08 <malcolmw> yes, all the prims were in C.  the Haskell implementation was gofer
03:22:25 <matthew-_> right.
03:24:02 <dons> well spotted, Cale
03:24:34 <matthew-_> malcolmw: mmm. Session types have far more information in them and effectively allow a richer specification of communication than you have, but higher order sessions are hard, and with my current implementation I have issues with Haskell's unfriendly attitude towards infinite types
03:24:47 <malcolmw> 256Kb on-board memory, two DUARTs for controlling light sensors and motors
03:25:34 <matthew-_> right, I need about 600MB to compile my main test file!
03:25:48 <dons> wow, malcolmw.
03:25:52 <malcolmw> nothing was compiled on the board itself
03:25:59 <matthew-_> I think it's safe to say I'm looking at a very different "end" of the domain
03:26:35 <malcolmw> I compiled to bytecode on a workstation, then squirted RTS + bytecodes down the serial line to the machine
03:28:19 <genneth> anyone tried using the svn pandoc recently?
03:28:37 <malcolmw> actually, I was worried that 256Kb might be too small for the heap + program, so bought an upgrade to 768Kb (cost > Â£100), but it turned out that 256Kb was OK
03:29:34 <genneth> oh nvm. found the problem... awesome. blogging software coming up...
03:34:24 <dons> sounds exciting, genneth
03:36:00 <genneth> the idea is dead simple -- no database, no fanciness -- just a directory of markdown or RST or whatever pandoc can handle, served up as html by a happs app, with some caching and ability for atom feeds
03:36:34 <dons> sounds nice
03:36:39 <dons> so the markdown could be a darcs repo
03:36:47 <dons> and you publish by just 'darcs push' into that repo/
03:36:57 <dons> and the happs app just reads, and publishes?
03:37:14 <dons> (a bit like a non-cgi version of blosxom?)
03:37:19 <dons> only faster
03:37:26 <dons> and doesn't need apache
03:37:35 <arcatan> blog engine is a wheel that has been reinvented several times
03:39:05 <quicksilver> that's because it hasn't been got convincingly right, yet
03:39:13 <genneth> yeah, but I find all the current ones too heavy for my tastes
03:39:32 <arcatan> they all suck, anyway
03:39:39 <arcatan> just use wordpress
03:40:07 <genneth> dons: indeed -- i hadn't even thought about using darcs for that. but that's the point -- i want something with an open interface in the unix-y sense so that people can use it as part of a toolchest
03:41:08 <quicksilver> yes, there is attractive simplicity to files-as-posts
03:41:24 <quicksilver> people can mirror with rsync, they can push with darcs, or bzr, or other_vcs_of_choie
03:41:36 <quicksilver> they can backup with any of anumber of common backup techniques
03:43:01 <dons> genneth: yeah, it'd be very attractive to publish via the command line (i.e. darcs or scp), and not have to touch the server once its running
03:43:05 <careo> dons: that's actually something I've been thinking wanting and thinking of writing
03:43:18 <careo> -1st thinking
03:43:21 <dons> blosxom works like that, but needs cgi/apache on the remote machine
03:43:27 <dons> it then just scans and reads the markdown
03:43:58 <dons> i'd be happy with offline compilation of blog pages too :}
03:44:16 <careo> yeah. or it could even convert it all to html and just serve the whole thing statically
03:44:25 <dons> yeah.
03:44:35 <genneth> i believe google blogger still has that mode
03:44:46 <dons> darcs record locally; ./generate ; darcs add * ; darcs push
03:45:03 <careo> I think google code does something like that with its wiki pages.
03:45:28 * genneth is happy. he can not write the happs bit now!
03:46:21 <careo> so the generate script would read when the article was first added to the repository and use that for creating the archive pages?
03:47:42 <ari> You know, every time I read an Oleg mail, my first thought is that he's speaking with pluralis majestatis
03:51:30 <yakov> hello
03:54:39 <roconnor> ``Corn flour should never be confused with cornstarch, which is known as `cornflour' in British English.''
03:54:50 <roconnor> *sigh*
04:00:28 <Gigantic> m... I try to compile GHC but I get "GHC is required unless bootstrapping from .hc files"
04:00:53 <Gigantic> how that that ghc need ghc to compile (??)
04:01:31 <Gigantic> might just be that I'm sleepy but I'm confussed
04:02:50 <etnt> anyone got a pointer to a Haskell vs. OCaml comparision?
04:03:21 <eivuokko> Gigantic, ghc is written in haskell, and only haskell compiler at the moment cabable of compilign ghc is ghc.  Your probably want to grab a binary bundle for your platform and use that to compile your new ghc.  Ghc might also be available in conviently via package manager or installer.
04:03:22 <malcolmw> Gigantic: ghc is written in (extended) Haskell, so you need a haskell compiler to build it, and ghc is the only one (currently) capable of all the extensions needed
04:03:40 <malcolmw>  @ stereo (etc)
04:03:44 <eivuokko> -.-
04:04:02 <Gigantic> :o
04:04:23 <eivuokko> @quote stereo
04:04:23 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
04:05:31 <dons> etnt: in what respect? language details?
04:06:24 <dons> etnt: compare http://haskell.org/haskellwiki/A_brief_introduction_to_Haskell with http://www.cs.jhu.edu/~scott/pl/lectures/caml-intro.html
04:06:25 <lambdabot> Title: A brief introduction to Haskell - HaskellWiki
04:06:32 <Gigantic> :)
04:06:36 <etnt> dons: yes, as a beginner I'm curious about the main differences
04:06:54 <etnt> dons: ok, thx!
04:07:03 <dons> yeah, the main differences are summarised in the `A_brief_introduction_to_Haskell' (you might need to read it concurrently with the ocaml version)
04:07:46 <roconnor> Haskell: lazy evaluation; OCaml: strict evaluation
04:08:19 <etnt> roconnor: yes, thats about all I know :-)
04:08:22 <roconnor> Haskell: pure; OCaml: side-effects
04:08:32 <mauke> Haskell: beautiful; OCaml: ugly
04:08:33 <dons> lazy/strict, pure/impure, type classes/module functors, pretty/ugly :)
04:08:36 <dons> hah
04:08:39 <roconnor> Haskell: type-classes; OCaml: module functors
04:08:52 <dons> ok. so we got consensus
04:08:56 <vincenz> firstclass dataconstructors/non firstclass dataconstructures
04:08:58 <roconnor> dons: That is all that comes to mind.
04:09:19 <dons> multicore runtime/not multicore runtime
04:09:27 <vincenz> slow/fast
04:09:27 <dons> 8 implementations/1 implementation
04:09:29 <vincenz> oh wait, not anymore!
04:09:36 <mauke> sane == / insane ==
04:09:40 <dons> fastish/fast
04:09:48 <int-e> insane / insane ;)
04:09:50 <vincenz> potay-toe/potah-toe
04:09:55 <dons> new/old
04:10:03 <vincenz> britain/france
04:10:05 <gour> popular/?
04:10:20 <kfish> hey, haskell can do strict and ocaml can do lazy, and oleg likes both languages
04:10:20 <dons> big community/some guys at inria
04:10:23 <roconnor> I'm not sure speed is a language issue.
04:10:26 <dons> oleg/oleg
04:10:28 <vincenz> dons/no-dons
04:10:36 <mauke> haha
04:10:40 <Vq^> :)
04:11:00 <dons> lambdabot/no bot
04:11:24 <mauke> I think oleg is a pretty important feature for programming languages
04:11:25 <gour> #324/#54
04:11:32 <dons> ?users
04:11:32 <lambdabot> Maximum users seen in #haskell: 354, currently: 326 (92.1%), active: 17 (5.2%)
04:11:43 <dons> huh. #354 / #54? ;)
04:11:55 <gour> :-)
04:12:02 <dons> last year it was 250/50
04:12:02 <mauke> why does lambdabot think there are 326 users here?
04:12:11 <vincenz> mauke: /who
04:12:11 <Gigantic> nice bot...
04:12:14 <dons> i think it ignores bots/forgets things.
04:12:31 <gour> i.e. lazy
04:13:13 <dons> credit suisse/jane st
04:13:21 <roconnor> dons: *l*
04:13:34 <roconnor> that's a good comparison point
04:13:42 <apfelmus> warm fuzzy things/side effects
04:13:49 <dons> hah
04:14:10 <dons> Deutsche Bank/ ?
04:14:22 <jaapweel> also, haskell has a well specified standard, and ocaml has a manual that turns out to be a little rough around the edges when you actually try to implement it
04:14:30 <etnt> but both has an Edinburgh heritage I guess... :-)
04:14:32 <Tychom> i'm having an issue with ghc on osx (a fink src build), i'm trying to compile a file: 'ghc reader.hs' and its not linking, I get the error: "/usr/bin/ld: can't locate file for -lHShaskell98". I've modified the ghc script to include "-L/sw/lib/ghc-6.6" which is where HShaskell98.o lives but ld still complains. anyone come across this before and have a work-around?
04:14:38 <roconnor> pfffft, haskell doesn't even have formal semantics.
04:14:44 <apfelmus> eh, the Deutsche Bank's gonna use Haskell?
04:14:57 <dons> apfelmus: according to http://haskell.org/haskellwiki/Haskell_in_industry
04:14:58 <lambdabot> Title: Haskell in industry - HaskellWiki
04:15:01 <mauke> The Directional Credit Trading group uses Haskell as the primary implementation language for all its software infrastructure.
04:15:11 <jaapweel> roconnor, true, but what usable languages do, besides scheme?
04:15:36 <dons> hey, i've got a haskell running in twelf. well, bits of it. that's close enough
04:15:42 <dons> jaapweel: Standard ML.
04:16:02 <roconnor> SML has formal semantics?
04:16:09 <jaapweel> dons, i didn't know that
04:16:13 <jaapweel> interesting
04:16:16 <roconnor> cool
04:16:17 <dons> there's twelf implementations for 98% of SML, afaik.
04:16:25 <apfelmus> hm, the link for the deutsche bank does not really point to something specific
04:16:57 <dons> apfelmus: maybe check the mailing list. there's been deutsche bank email addresses used.
04:17:50 <apfelmus> ah, indeed
04:18:30 <kfish> aren't haskell's formal semantics defined in terms of Hask! anyway?
04:18:46 <roconnor> @what Hask!
04:18:47 <lambdabot> I know nothing about hask!.
04:19:05 <kfish> the category of strict haskell functions
04:19:10 <Philippa> kfish: what formal semantics?
04:20:08 * apfelmus `liftM` lunch
04:20:10 <roconnor> kfish: I would expect haskell semenatics to be defined in terms of some CPO.
04:20:17 <dons> apfelmus: http://article.gmane.org/gmane.comp.lang.haskell.cafe/18606/match=deutsche
04:20:20 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/33kl8j
04:20:26 <dons> "I work at Deutsche Bank. I am using Haskell to manage several
04:20:26 <dons> databases, using HDBC and HAppS, and do some data mining and (light)
04:20:26 <dons> numerical calculation."
04:20:40 <dons> same jeff p who added the entry on the wiki, iirc
04:21:16 <dons> apfelmus: also http://article.gmane.org/gmane.comp.lang.haskell.cafe/21856/match=deutsche (NYFP meeting)
04:21:19 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/2p4ar6
04:21:52 <apfelmus> aha
04:22:07 <apfelmus> well, in the end, using haskell is only natural
04:22:28 <apfelmus> i for one switched to Haskell long ago and don't use anything else anymore :)
04:22:44 <dons> its a black hole. once you're in, you can't get out!
04:22:54 <roconnor> dons: it's like a monad.
04:22:57 <Lemmih> Tychom: Reinstall it?
04:23:27 <apfelmus> getting out can only be done with unsafeSwitchMindOff
04:23:51 <profmakx> why would that be unsafe?
04:24:11 <apfelmus> switching your mind off?
04:24:53 <apfelmus> well, in the best case, the computer takes control of you. in the worst case, you stop breathing
04:25:21 <sphynx> hi!
04:25:53 <sphynx> I'd like to ask again about some way of packaging haskell project in .deb package
04:25:56 * apfelmus `catch` (\Hungry -> runForLunch)
04:26:14 <profmakx> hm
04:26:16 <sphynx> I've tried to ask John Goerzen aka cosmicus, but still have no answer from hi, :(
04:26:22 <sphynx> him *
04:26:24 <dons> sphynx: gimme a sec. looking up the answer.
04:26:33 <siti> yep, once you know haskell you hate most other programming languages ;)
04:26:41 <dons> http://pupeno.com/2006/12/12/the-lambda-revolution-v/
04:26:43 <lambdabot> Title: Pupeno&#8217;s web site » Blog Archive » The lambda revolution, Episode V, the d ...
04:26:48 <dons> `Creating a .deb from a Haskell Cabal package'
04:26:54 <sphynx> dons: Yeah, I'vre read this article
04:27:13 <dons> ok. so the story is: cabalise it as normal. then run one of these cabal2deb scripts floating around
04:27:21 <dons> or write your own if you know .deb
04:27:29 <sphynx> but it is a bit hackerish and don't describe many things :( It's a bit hard to build .deb using only this article with no help from outside
04:27:39 <siti> on this subject the ubuntu gutsy haskell packages need updating
04:27:41 <siti> :)
04:27:51 <siti> I might attempt it, but I still suck with .deb packaging
04:28:03 <sphynx> dons: the problem is I don't know deb fromat well :(
04:28:20 <sphynx> siti: my application is pretty simple
04:28:50 <siti> I have never done haskell .deb packaging but I can attempt to help... any errors?
04:29:02 <siti> can't you just copy a prexisting package and just make it suit your application?
04:32:21 <dons> why do you need .deb? cabal should do well enough, shouldn't it?
04:33:59 <sphynx> sorry, I had a call
04:34:11 <mauke> A TAIL CALL
04:34:27 <vincenz> TAIL = BOOTY
04:34:46 <sphynx> siti: here is my darcs repo: http://histoma.com/repos/allknow
04:34:49 <lambdabot> Title: Index of /repos/allknow
04:34:59 <sphynx> siti: I have installed haskell-dev-scripts package
04:35:10 <sphynx> and tried to follow the manual
04:35:38 <sphynx> there is a dh_haskell helper script, but there were some strange errors..
04:35:46 <sphynx> Also I have tried 'checkinstall' utility
04:36:06 <sphynx> with no success too
04:36:20 <siti> hmm
04:36:44 <sphynx> dons: I want .deb or .rpm because it's a simple tool and I think many people would not like to install ghc just to build this source :)
04:36:55 <siti> :D
04:37:20 <siti> you could just distribute the 1MB binary that ghc makes ;)
04:38:49 <siti> I've gtg now
04:38:52 <siti> sorry
04:41:50 <sphynx> dons: It's just a tool for analyzing centericq logs, so I think it could be interesting only for small centericq community ) but theu would not like installing additional tools )
04:42:01 <sphynx> siti: OK, see you later
04:42:57 <sphynx> siti: sure, I can distribute bin, but I'm not sure if it will works on another (even debian based) platforms..
04:44:38 <kfish> vincenz, i'm never going to think about "tail call optimization" the same way ever again :-/
04:49:39 <etnt> another (stupid) question: aren't there lots of Haskell people behind F# which apparently is compared with OCaml ?
04:50:22 <dons> there's Don Syme, so 1 Haskellish guy anyway. its an ocaml reimplementation, to bind with windows libraries.
04:51:11 <etnt> ok, I thought SPJ and others at Mic.Research was behind it
04:51:46 <dons> nah
04:52:11 <dons> oh, SimonM helped with the new layout system for F#, based on haskells
04:52:35 <mauke> layout system?
04:52:48 <mauke> I thought OCaml didn't have blocks
04:53:03 <dons> F# has a haskell layout thingy preprocessor
04:54:23 * etnt wonders if M$ is serious about F#...
04:54:40 <sphynx> dons: while googling for 'cabal2deb' I've just found some old logs from this channel )
04:56:35 <Lemmih> sphynx: http://www.penguin-soft.com/penguin/man/1/dh_haskell.html ?
04:56:38 <lambdabot> Title: dh_haskell - Builds Cabalized libraries, calculates Haskell dependencies, and ad ...
04:57:09 <Lemmih> Ah, you've seen it already.
04:59:41 <sphynx> Lemmih: yeah, I just need some person to talk about this utility :) It's a bit hard to cope with all of these debian packaging tricks along with Haskell specific builds for me..
05:30:31 <dons> this is how languages should work. any comp1A student could work out how this evaluates. but give it to them 6 months later, after a bit of C or Java, and its all over:
05:30:34 <dons> let ghc = "( ghc " ++ cmm
05:30:37 <dons>     cmm = "( cmm " ++ ghc
05:30:39 <dons> in ghc
05:32:02 <blackdog_> and you never have to close the brackets if you never stop recurring... :)
05:34:16 <vincenz> sure you do
05:34:17 <vincenz> you do
05:34:32 <vincenz> in ghc ++ repeat ')'
05:35:35 <Adamant> heh, I can think of multiple ways for that to evaluate
05:35:38 <blackdog_> that's a very theoretical distinction :)
05:35:43 <Syzygy-> dons: It should be "( ghc ( cmm ( ghc ( cmm ( ghc ( cmm ( ...", right?
05:35:47 <vincenz> Syzygy-: yep
05:35:51 * Syzygy- tries to prove something, not sure what though :P
05:36:08 * blackdog_ is sad that c2hs won't compile
05:36:29 <Syzygy-> c2hs? Converts c code to Haskell? Sounds like an abomination.
05:36:37 <blackdog_> heh
05:36:46 <blackdog_> c2hs is a wrapper generator
05:36:50 <Syzygy-> Ah.
05:36:54 <blackdog_> makes it easier to wrap C libraries
05:36:55 <Syzygy-> Ok. Less abominable then... :P
05:38:02 <careo> etnt: isn't F# out of their cambridge office?
05:51:30 <etnt> careo: don't know, is F# something to take seriously ?
05:52:35 <careo> etnt: I don't do anything on the CLR, and have no experience with F#. but the in concept it sounds pretty awesome. supposedly more or less identical to ocaml
05:54:06 <careo> I know ocaml's somewhat big in the financial world. so I wonder if this isn't part of an effort on the part of MS to break into that more
05:55:47 <etnt> careo: yes sounds very interesting, Windoze has been a non-option for me bc of its lack of a reasonable language. F# could perhaps make me reconsider...
05:57:47 <careo> etnt: it looks like it can run in Mono currently, so that could certainly be a good route if you wanted to give it a shot without installing windows
05:57:51 <osfameron> I thought there were ocaml and haskell and erlang etc. ports for windows?
05:58:53 <MyCatSchemes> There are, yes.
05:59:16 <MyCatSchemes> But they're usually kinda... eh.
05:59:41 <etnt> osfameron: but are anyone using them in real applications ?
05:59:44 <MyCatSchemes> Second class citizens, so to speak. A bit clunky.
05:59:50 <careo> Having full access to the .NET goodies might be nice, if that's your kind of thing.
05:59:55 <ketil> > matchRegex (mkRegex ".*phd.*") "clones/CE12311.phd.1asdf"
05:59:56 <lambdabot>   Not in scope: `mkRegex'
06:00:07 * ketil grmphs.
06:00:29 <etnt> careo: ok, never tried mono, is it easy to get going ?
06:00:58 <careo> etnt: dunno. me neither :). I only use it in the Unity game framework
06:01:14 <ketil> Do I need any tricks to get Text.Regex to work?
06:02:20 <profmakx> ketil what kind of tricks?
06:02:28 <Svrog> there is nothing wrong with ocaml, haskell and erlang ports for windows
06:02:43 <Svrog> no better or worse than ocaml, haskell and erlang on linux or os x really
06:02:54 <osfameron> etnt: oh, no idea.  I moved to Linux because it's a better dev environment for web (and tbh Win32 Perl sucked for a long time and is still a bit of a second class citizen)
06:03:13 <MyCatSchemes> Svrog: you can't get as good terminal emulators, for one thing.
06:03:23 <ketil> Hmm.. I guess the problem is substituting a fixed substring.  One moment..
06:03:24 <Svrog> ?
06:03:31 <Svrog> what does that have to do with haskell or caml?
06:03:44 <osfameron> it has to do with the dev environment, which is important
06:03:46 <etnt> Svrog: I know of lots of commercial applications in Erlang on Linux, none on Windows
06:04:10 <Svrog> that doesn't really mean erlang port for windows is bad
06:04:21 <Svrog> in fact that doesnt really say much of anything about the quality of the port
06:04:39 <etnt> Svrog: correct, I wasn't implying that
06:04:40 <Svrog> actually unlike erlang and caml, erlang under windows does miss something that the linux port does have
06:04:44 <Svrog> like hipe
06:04:49 <Svrog> the native code compiler
06:04:55 <ketil> I only get "Just []" from matchRegex - basically I want to do a substitution, but the returned segment doesn't reflect the search pattern.
06:05:20 <Svrog> but with caml and haskell you get the same stuff on just about any platform that's supported as far as i know
06:05:33 <Svrog> it's definitely the case on the platforms i use which are windows, linux and os x
06:05:48 <ketil> subRegex (mkRegex "[0-9]+") "x" "asdf123dasf"
06:05:52 <etnt> Svrog: I just imagined that F# may open up the job market for me personally
06:06:08 <Svrog> oops - i meant to say unlike haskell and caml
06:06:20 <ketil> replaces the entire string with "x", I want something like 's/[0-9]+/x/g'
06:06:31 <careo> etnt: heh. knowing .NET might open up some doors, but are they ones you want step through...
06:06:55 <Svrog> open up the job market?
06:07:40 <Svrog> how?
06:07:51 <MyCatSchemes> A lot of companies use it.
06:08:02 <Svrog> hmm.. i dont know about that
06:08:20 <Svrog> a lot of companies view it as an unsupported research project that's too risky to rely on
06:08:24 <Svrog> i know from personal experience
06:08:24 <quicksilver> .NET? It's one of the most widely deployed technologies in the world.
06:08:34 <Svrog> too risky in that it's unsupported
06:08:34 <quicksilver> love or it or hate it, you can't pretend it isn't out there
06:08:35 <ketil> I guess Text.Regex is just broken, then?
06:08:53 <Svrog> not .net but f# specifically
06:08:57 <quicksilver> ketil: I don't think so, no
06:09:38 <quicksilver> ketil: what exactly are you trying to do?
06:11:04 <ivant> hi everybody
06:11:41 <quicksilver> ketil: or at least; it isn't broken for me, so it isn't unconditionally broken
06:12:04 <quicksilver> ketil: either you have a broken install, or you're using it wrong :)
06:12:39 <ketil> Probably using it wrong. What is the semantics for subRegex?
06:12:54 <Svrog> another thing i've noticed with f# is that you lose most of the benefits of it if you have to write code that the other programmers can't tell was written in f# without seeing the sources - as in in a team that is allowed to use c# and f# and where everything has to have an interface that doesn't look and feel odd from c#
06:13:01 <ketil> I expect it to replace the portion of the string returned by matchRegex, but clearly it doesn't.
06:13:40 <ketil> It seems to be more like if the string matches (at all), replace the entire string with the replacement.
06:14:13 <quicksilver> I think you just have the parameters in the wrong order :P
06:14:20 <Svrog> all the c# programmers continue doing their stuff and you have to use their code and wrap your modules so they appear like c# - in the end you end up with the same object oriented mess
06:14:23 <quicksilver>  subRegex (mkRegex "[0-9]+") "asdf123dasf" "x"
06:14:27 <quicksilver> ketil: ^^ works for me
06:14:38 * ketil laughs.
06:14:47 <ketil> Right!
06:15:12 <ketil> Why does matchRegex always(?) return Just [] on a match?
06:15:31 <ketil>  matchRegex (mkRegex "[0-9]") "asdf123dasf"
06:15:35 <ketil> => Just []
06:15:39 <quicksilver> ketil: it returns the subexpressions matched
06:15:44 <quicksilver> (did you read the docs? :)
06:16:01 <ketil> Yes, but which subexpression is []?
06:16:12 <quicksilver> that r.e. has no subexpressions
06:16:18 <quicksilver> subexpressions are denoted with ()
06:16:37 <quicksilver> there is also matchRegexAll if you want to get the before and after bits
06:17:01 <ketil> Ah, okay.  So I can do mkRegexp "(0|1|2..9)" to see what I matched in this case.
06:17:04 <ketil> Thanks!
06:17:13 <mauke> ([0-9])
06:17:15 <quicksilver> or just use matchRegexAll
06:18:47 * ketil apologizes for his mental density, and goes off to code some more.
06:19:12 <quicksilver> :)
06:19:34 <fasta> Who is using undecidable instances in this channel? It seems those features are used way too little.
06:19:47 <fasta> Judging by the abundance of bugs around them.
06:21:44 <Svrog> i use them a bit
06:22:15 <fasta> It could also help cause that nobody uses them, of course.
06:25:17 <matthew-_> is there an equivalence between FSMs and NFAs?
06:25:42 <matthew-_> I'm thinking that every NFA is a FSM, but I'm not sure the converse is true
06:26:48 <fasta> matthew-_: you can compile from one to the other, yes.
06:26:55 <fasta> matthew-_: it's a famous theorem
06:26:57 <yaarg> er, yes
06:27:09 <matthew-_> yes, so wikipedia says
06:27:18 <alexj> anyone played with SYB with class?
06:27:22 <matthew-_> NFAs are more general than regular expressions?
06:27:39 <fasta> matthew-_: why would they be?
06:27:53 <roconnor> where they going to add monadic IO to Ocaml or SML or something?
06:28:23 <roconnor> s/h//
06:28:32 <fasta> roconnor: I would be far more interested in having a correct implementation of everything the GHC manual promises.
06:28:35 <Svrog> roconnor: unlikely i think
06:28:57 <Svrog> i think it's safe to say they won't do that
06:29:47 <fasta> My screen is full of compiler panics...
06:29:51 <matthew-_> fasta: ok, ignore me, I'm being dumb
06:29:55 <fasta> I am trying to make a simple test case.
06:30:07 <Svrog> caml and sml are strict and impure - they have no need for monadic io
06:30:08 <fasta> matthew-_: doesn't matter, I am sometimes too
06:31:00 <fasta> This delimited continuations thing is pretty interesting, btw. If only Sun had implemented them in Java in 1995, they would now surely rule the world.
06:31:29 <quicksilver> people certainly write monads in caml/sml though
06:31:35 <Svrog> yes
06:31:47 <quicksilver> I was using parsing monads in caml before I knew that's what they were called
06:31:49 <Svrog> but it's impractical
06:32:00 <quicksilver> not at all, it's perfectly practical ;)
06:32:16 <quicksilver> and freed from the the 'constraints' of do { } and always using >>=
06:32:25 <quicksilver> you just pick the best combinator for the job
06:32:34 <Svrog> hmm
06:32:38 <quicksilver> (you can do this in haskell too of course)
06:32:50 <quicksilver> I quite often use combinators which combine >>= with some kind of fmap
06:33:00 <quicksilver> to modify the results before or after binding them
06:34:23 <fasta> How cool is that: merely importing a specific module makes GHC panic when evaluating putStrLn "hi"
06:34:31 <Syzygy-> fasta: Oo
06:34:42 <profmakx> like not cool at all?
06:34:46 <fasta> profmakx: right
06:35:08 <Syzygy-> fasta: What module? *curious*
06:35:16 <fasta> Haskell98 works nicely in GHC, and even that is not perfect, but anything beyond that....
06:35:34 <fasta> But those extensions are just what makes GHC practical.
06:36:00 <fasta> They make GHC a kind of Python, but with static guarantees
06:36:19 <fasta> (and Haskell is of course pure)
06:36:25 <roconnor> Is there a haskell library for making dot files for graphviz?
06:37:03 <fasta> roconnor: I just call graphviz myself
06:37:36 <roconnor> fasta: how do you generate the input?
06:37:55 <fasta> roconnor: ? They are just Strings
06:38:22 <ketil> roconnor: I think FGL has some functionality for GraphViz
06:38:27 <Svrog> roconnor: http://www.haskell.org/ghc/docs/latest/html/libraries/fgl/Data-Graph-Inductive-Graphviz.html
06:38:28 <lambdabot> http://tinyurl.com/3y3cmy
06:38:43 <ketil> Svrog: right.
06:39:19 <roconnor> fasta: they aren't just strings, they have a certain structure ;)
06:39:49 <fasta> roconnor: yes, well I read the manpage and I generate such strings.
06:39:53 <roconnor> :)
06:40:00 <fasta> roconnor: there is nothing difficult about it.
06:40:04 <greenrd> Can anyone help me with Data.Generics?
06:40:11 <fasta> @ask
06:40:11 <lambdabot> Plugin `tell' failed with: IRCRaised Prelude.head: empty list
06:40:12 <greenrd> I've done some simple stuff with it already
06:40:25 <fasta> :( All software I touch crashes.
06:40:34 <greenrd> fasta - that's a useful skill!
06:40:39 <greenrd> you should be a software tester!
06:41:01 <fasta> greenrd: I am already testing GHC, and luckily they listen to me :)
06:41:04 <greenrd> heh
06:41:14 <fasta> greenrd: unfortunately, there are so many bugs.
06:41:19 <greenrd> wow
06:41:33 <greenrd> I haven't found many bugs in ghc and I've done some obscure stuff
06:41:49 <greenrd> ok maybe not that much obscure stuff
06:42:27 <greenrd> anyway - I want to recurse over an ADT with Data.Generics and replace all strings (not substrings) "foo" with "foo_param"
06:42:41 <greenrd> but _only_ where foo is free, not where it is bound
06:42:54 <fasta> greenrd: For example this one in <= 6.6.1 http://hackage.haskell.org/trac/ghc/attachment/ticket/1485/MaybeBug.hs
06:42:56 <lambdabot> Title: #1485: MaybeBug.hs - GHC - Trac, http://tinyurl.com/2stylp
06:43:24 <fasta> greenrd: Or that one: http://hackage.haskell.org/trac/ghc/ticket/1456
06:43:24 <lambdabot> Title: #1456 (Wrong type being derived) - GHC - Trac
06:44:42 <greenrd> I thought of using something like everywhereM and the Reader monad
06:44:59 <greenrd> using the Reader to keep track of what is in scope
06:45:23 <greenrd> sorry, I meant to say "AST" above, not "ADT"
06:48:24 <greenrd> however, I have two problems
06:48:43 <greenrd> 1) I need to process both bindings and strings, which are of different types
06:48:48 <fasta> Meh, that bug is hard to make into a small test case.
06:49:16 <greenrd> 2) I need to (I guess) process the AST in a top-down manner, whereas from my reading, everywhereM is bottom-up
06:50:34 <fasta> greenrd: why not use Uniplate?
06:50:44 <fasta> @where uniplate
06:50:44 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/uniplate
06:51:05 <fasta> greenrd: and thinking about the problem before thinking of data structures in a sane idea too
06:51:12 <greenrd> hehe
06:51:20 <greenrd> hey, I'm maintaining my code here!
06:51:27 <greenrd> I didn't even have this requirement until yesterday
06:52:04 <fasta> greenrd: There is some refactoring tool for Haskell
06:52:12 <fasta> greenrd: I don't know whether it works.
06:52:21 <fasta> greenrd: but that might be more efficient use of your time
06:52:27 <greenrd> well
06:52:43 <roconnor> @type (\\)
06:52:45 <greenrd> I considered refactoring to add free/bound info in the data structure
06:52:45 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
06:53:00 <greenrd> but that's not always needed
06:54:05 <greenrd> It's a tough call, but I guess I am philosophically against adding redundant information to a data structure, generally speaking
06:54:14 <greenrd> because that could lead to data structure bloat
06:54:37 <Japsu> @src reverse
06:54:37 <lambdabot> reverse = foldl (flip (:)) []
06:54:59 <greenrd> I don't want to be wading through lots of redundant information whenever I'm walking through a data structure
06:55:14 <quicksilver> greenrd: one pattern is to parameterise your data structure with an annotation type
06:55:27 <quicksilver> greenrd: then you can have Expr ()  {- not annotated -}
06:55:34 <||NanoX||> @src (\\)
06:55:35 <lambdabot> (\\) = foldl (flip delete)
06:55:48 <quicksilver> as well as Expr [Name] {- annotated with lists of names -}
06:55:58 <greenrd> yeah, that's true
06:56:08 <||NanoX||> @src delete
06:56:09 <lambdabot> delete = deleteBy (==)
06:56:11 <quicksilver> greenrd: then generic functions have type Expr a -> Expr a
06:56:22 <quicksilver> greenrd: so, parametricity guarantees they ignore the annotation
06:56:37 <quicksilver> greenrd: and specific functions, well, have types which show what kind of annotation they expect :)
06:56:49 <fasta> I use making types more generic to get rid of mutual-recursive modules.
06:57:01 <fasta> That seems to be a nice solution.
06:57:49 <Socrates> > let facs x = [ n | n <- [1..floor $ sqrt x, mod x n == 0 ]
06:57:49 <lambdabot>  Parse error
06:57:54 <Socrates> > let facs x = [ n | n <- [1..floor $ sqrt x, mod x n == 0 ] in facs 10
06:57:54 <||NanoX||> @where (\\)
06:57:54 <lambdabot>  Parse error
06:57:54 <lambdabot> I know nothing about (\\).
06:58:05 <Socrates> > let facs x = [ n | n <- [1..floor $ sqrt x], mod x n == 0 ] in facs 10
06:58:06 <lambdabot>  Add a type signature
06:58:40 <Socrates> > let facs x = [ n | n <- [1..floor $ sqrt x], mod x n == 0 ] in facs 10 :: [Int]
06:58:41 <lambdabot>        add an instance declaration for (RealFrac Int, Floating Int)
06:58:41 <lambdabot>     In th...
06:58:57 <fasta> Meh, I hate performing something for which I can explain in a few sentences what should happen...
07:00:35 <osfameron> you're playing charades?
07:01:07 <Socrates> Anyone know how to fix that factors function by any chance? :(
07:02:24 <kpreid> Socrates: you have incompatible numeric classes
07:02:38 <kpreid> @type sqrt
07:02:40 <lambdabot> forall a. (Floating a) => a -> a
07:02:43 <kpreid> @type mod
07:02:45 <lambdabot> forall a. (Integral a) => a -> a -> a
07:02:52 <Socrates> I'm afraid I don't really know much about numeric classes
07:02:55 <kpreid> so you need sqrt (fromIntegral x)
07:03:02 <Socrates> Ah, okey
07:03:06 <kpreid> sqrt takes a floating-point x, mod takes an integral x
07:03:28 <kpreid> so you need to convert at one or the other place (which determines what the argument type for facs is)
07:03:40 <Socrates> Works now, thanks kpreid
07:04:43 <greenrd> quicksilver: that's a good idea, but I think it would be cleaner to do what I'm trying to do using the reader monad - if I could figure out how
07:04:59 <quicksilver> greenrd: I doubt the reader monad does what you want
07:05:10 <quicksilver> greenrd: that's just like threading a shared parameter
07:05:29 <greenrd> well, you can say "set the parameter to be this within this call"
07:05:39 <greenrd> I forget what the name of the function that does that is
07:05:47 <quicksilver> local
07:05:51 <SamB_XP_> @src MonadReader
07:05:51 <lambdabot> Source not found. Just what do you think you're doing Dave?
07:06:03 <quicksilver> I think you're going beyond the bounds of everywhereM, though
07:06:09 <quicksilver> everywhereM isn't going to call 'local' for you :)
07:06:12 <quicksilver> as I understand it
07:06:33 <greenrd> right
07:06:44 <greenrd> so I need something more powerful than everywhereM
07:07:27 <Socrates> Is floor or round more efficient, or is the difference negligible?
07:07:42 <quicksilver> negligible
07:07:53 <Socrates> Thanks, quicksilver
07:07:57 <SamB_XP_> @type round
07:07:59 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
07:08:19 <SamB_XP_> hmm, that seems awful general
07:08:25 <Botje> > [floor 3.70, round 3.70]
07:08:27 <lambdabot>  [3,4]
07:08:52 <SamB_XP_> > round (3/7)
07:08:54 <lambdabot>  0
07:09:03 <Socrates> I know they have slightly different results
07:09:27 <SamB_XP_> @src round
07:09:27 <lambdabot> Source not found. Are you on drugs?
07:09:40 <SamB_XP_> @hoogle round
07:09:41 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
07:09:41 <lambdabot> Text.Html.background :: String -> HtmlAttr
07:09:41 <lambdabot> System.Win32.Info.cOLOR_BACKGROUND :: SystemColor
07:10:16 <SamB_XP_> @src RealFrac
07:10:16 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
07:10:16 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
07:10:16 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
07:10:49 <SamB_XP_> oh, okay, I guess they're probably equally efficient on floating-point types, then
07:18:46 <greenrd> OK, I should be able to do it with gmapM and extT
07:19:26 <vincenz> Anyone know how to deal with something like
07:19:37 <vincenz> data Fix m = Fix (m Fix)
07:19:45 <vincenz> data Fix m = Fix (m (Fix m))
07:19:56 <vincenz> and have generic transformations:  Fix m -> Fix n
07:20:39 <SamB_XP_> generic?
07:20:43 <vincenz> nod
07:21:18 <ivant> is there some easy way to write IOUArray of Word32s to a file (in binary, without converting big-endian/little-endian conversion)?
07:21:26 * SamB tries
07:21:43 <SamB> perhaps we really *should* add a type-definition facility to GHCi
07:21:55 <swiert> vincenz: I'd guess you'd need m to be a functor, then you could fmap.
07:22:08 <SamB> swiert: nonsense
07:22:15 <SamB> at least I think so
07:22:16 <ketil> ivant: isn't there hPutArray or something like that?
07:22:42 <ivant> ketil, yep, it does the work, but for Word8s!
07:22:59 <quicksilver> ivant: it's quite easy to write word32toWord8s :)
07:23:20 <quicksilver> ivant: but "without converting big-endian/little-endian" is a strange thing to say
07:23:28 <quicksilver> ivant: you cannot help but make that decision
07:23:35 <quicksilver> ivant: when you convert a word32 to word8s
07:23:38 <SamB> arg
07:24:21 <SamB> oh, there it goes
07:24:50 <SamB> fixmap :: ((Fix t -> Fix m) -> t (Fix t) -> m (Fix m)) -> Fix t -> Fix m
07:24:55 <earthy> drat. still no HWN. okay. let's read those 1421 mails...
07:24:59 <SamB> fixmap f (Fix p) = Fix (f (fixmap f) p)
07:25:35 <chessguy> @src Fix
07:25:35 <lambdabot> Source not found. You type like i drive.
07:25:47 <SamB> chessguy: see above
07:25:54 <SamB> vincenz just defined it
07:25:59 <chessguy> oh
07:26:08 <SamB> I have no idea what for
07:26:11 * chessguy wasn't paying attention
07:26:39 <SamB> but he wanted a generic transformation Fix m -> Fix n
07:26:48 <roconnor> @type ($1)
07:26:53 <lambdabot> forall a b. (Num a) => (a -> b) -> b
07:27:28 <SamB> @vixen hi
07:27:28 <lambdabot> <undefined>
07:27:31 <SamB> aww.
07:28:27 <blackdog_> Samb: sorry :(
07:28:29 <SamB> vincenz: is that good enough for you?
07:28:31 <ivant_> oops, the internet connection died
07:28:34 <roconnor> @type filterBy
07:28:35 <lambdabot> Not in scope: `filterBy'
07:28:37 <SamB> blackdog_: why do you apologize?
07:28:42 <blackdog_> tried to fix it a while back but timed out on it...
07:28:47 <blackdog_> @vixen no worky
07:28:48 <lambdabot> <undefined>
07:29:16 <ivant_> quicksilver, I know that the way Word32s are stored in memory is correct for the purposes of the presentation of them in a file
07:29:22 <SamB> blackdog_: I fixed it a few days ago, and dons says he's applied my patch, but apparantly either he botched it or he hasn't finished rebuilding / restarting lambdabot yet...
07:29:44 <quicksilver> ivant_: but haskell doesn't permit you to know how they are stored in memory
07:29:54 <quicksilver> ivant_: haskell permits itself to randomly permute each word32
07:30:26 <quicksilver> ivant_: you may *think* you know, and you may even be right. But that's not part of the language's semantics
07:30:40 <blackdog_> ... SamB, you rock
07:30:43 <blackdog_> thank you. :)
07:31:13 <swiert> SamB: I'm not sure I agree.
07:31:14 <SamB> blackdog_: all *I* did was write some Binary code to read vixen's data structures in the old, 32-bit format
07:31:26 <SamB> swiert: agree about what?
07:31:29 <swiert> @where hpaste
07:31:30 <lambdabot> I know nothing about hpaste.
07:31:38 <swiert> Your conversion function.
07:31:43 <Japsu> :O
07:31:49 <SamB> swiert: you saw it?
07:32:01 <oerjan> @hpaste
07:32:02 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:32:11 <swiert> Is hpaste down?
07:32:17 <SamB> probably
07:32:27 <blackdog_> SamB: that's all that needed doing, though :)
07:32:37 <swiert> Excuse me for pasting three lines: data Nat f g = Nat (forall a . f a -> g a)
07:32:42 <SamB> blackdog_: so how did you time out?
07:32:51 <swiert> convert :: (Functor f, Functor g) => Nat f g -> Fix f -> Fix g
07:32:56 <swiert> convert (Nat f) (In t) = In (f (fmap (convert (Nat f)) t))
07:33:02 <blackdog_> Oh, paying work intervened and i couldn't justify  spending any more time on it...
07:33:20 <SamB> blackdog_: how much time had you already spent on it?
07:33:28 <blackdog_> a couple of hours
07:33:43 <SamB> for some reason that sounds long to me, though I don't know for sure how long I spent
07:33:48 <blackdog_> I still don't understand the binary data stuff in lambdabot very well
07:33:59 <swiert> Nat is just a natural transformation between functors.
07:34:17 <SamB> swiert: who said anything about functors?
07:34:18 <blackdog_> don's code is strange to me - it's very concise, but i'm not always sure what the hell is happening
07:34:41 <SamB> blackdog_: well, it uses the new Data.Binary now
07:35:01 <SamB> perhaps you tried it when it was in a less obvious state?
07:35:16 <blackdog_> cool. is it in a darcs repo somewhere?
07:35:25 <SamB> data.binary?
07:35:30 <blackdog_> no, your code
07:35:49 <swiert> You're function is "cheating" - I'd lay a small wager that there is no polymorphic function that you could pass to the first argument of your fixmap.
07:36:17 <SamB> swiert: it doesn't have to be polymorphic
07:37:35 <SamB> blackdog_: it seems to be in dons's repo now
07:38:33 <SamB> most of it is in a comment
07:39:45 <ivant__> quicksilver, oops, my response to your suggestion regarding word32toWord8s was lost because of disconnection: I guess it'd be very slow, unless there is some trick not to copy all the data
07:40:07 <quicksilver> shouldn't be all that slow with optimisation on
07:40:10 <SamB> however, the State/vixen file in dons' repo now doesn't need conversion ;-)
07:40:16 <quicksilver> what kind of volumes of data are you talking about?
07:40:50 <ivant__> quicksilver, several megabytes, but the problem is that I can't compile
07:40:57 <quicksilver> ?
07:41:01 <ivant__> quicksilver, well, that's another story
07:41:02 <blackdog_> SamB: ah, nice. :)
07:41:13 <quicksilver> I know nothing about interpreted UArrays I'm afraid
07:41:23 <quicksilver> I don't even know if they're 'really' unboxed or not
07:41:46 <SamB> quicksilver: what do you mean by "interpreted"
07:41:52 <blackdog_> there was another thing i was thinking about adding but couldn't think of a good interface - it'd be nice to be able to add to the quotes from the channel
07:41:59 <quicksilver> SamB: I have no idea, ask ivant__ :)
07:42:21 <SamB> blackdog_: how does @remember look to you?
07:42:34 <ivant__> quicksilver, I wrote a program, and then it typedechecked and then the linker said that it can't find the functions from Control.Monad.Trans
07:42:50 <SamB> ivant: -package mtl
07:43:00 <blackdog_> SamB: yeah, that's fine for that. but the point would be to slot it somewhere into the tree of responses
07:43:23 <blackdog_> although just a regex,response pair added on to the end would probably be enough...
07:43:29 <SamB> blackdog_: oh, you mean you want to insert *@vixen* responses
07:43:43 <SamB> I don't think that inserting those from the channel is a great idea...
07:43:49 <blackdog_> yep. i want her to talk nerdy pickup too. :)
07:44:09 <ivant__> SamB, now that is weird: ghc told me that compilation is not required
07:44:22 <ivant__> oh, I had .o files, that's write
07:44:29 <SamB> ivant: you already compiled, though. you just need to link now ;-)
07:45:04 <ivant__> thanks, so now the only problem I have is copy-conversion to word8s
07:46:46 <earthy> wasabi icecream?!
07:47:04 <matthew-_> earthy: that's a new flavour!
07:49:49 <rretzbach> Hi, I've only eaten wasabi peas.
07:50:00 <rretzbach> They were somewhat strange...
07:50:35 <vincenz> SamB: ah, sorry, was busy
07:51:00 <SamB> vincenz: so take your pick, swiert's code or mine...
07:51:06 <vincenz> not quite
07:51:10 <vincenz> and I can't use a functor
07:51:14 <vincenz> it must be distached from functor
07:51:21 <SamB> mine doesn't touch functor
07:51:33 <quicksilver> ivant: http://scsys.co.uk:8001/8425
07:51:34 <lambdabot> Title: perl_web paste from "quicksilver" at 81.149.28.129...
07:51:37 <quicksilver> ivant: thats how I do it
07:52:25 <vincenz> hmm
07:52:29 <vincenz> I'd have to try it out to see if that'd work
07:52:40 <vincenz> I'll mull on it a bit
07:52:44 <ivant> quicksilver, and then concatMapping them all?
07:53:28 * vincenz gets the impression it's too simplistic
07:53:41 * SamB wonders how you can teach a Haskell compiler to use assembly instructions -- say, for byteswapping...
07:53:56 <koffein> hi
07:54:17 <koffein> stupid question: how do I get the nth element of a list
07:54:18 <koffein> ?
07:54:23 <oerjan> l !! n
07:54:23 <quicksilver> ivant: yes, effectively
07:54:23 <Jaak> !!
07:54:25 <SamB> vincenz: you didn't really say much about what you wanted ;-)
07:54:25 <quicksilver> koffein: !!
07:54:29 <vincenz> SamB: If you want I cant demonstrate the reason :)
07:54:39 <koffein> thanks
07:54:44 <oerjan> or actually, l !! (n-1)
07:54:44 <SamB> you can't?
07:55:06 <vincenz> s/t//
07:55:10 <vincenz> @paste
07:55:10 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:55:15 <vincenz> down
07:55:25 <fasta> Replacing (\e-> e) with id makes ghci panic
07:55:28 <koffein> oerjan, it's ok. I start at 0
07:55:32 <fasta> That's hilarious.
07:55:44 <opqdonut> fasta: code?
07:55:47 <ivant> quicksilver, hmm, so you depend on the property of fromIntegral, which says that it truncates higher bytes when casting to a "shorter" integral?
07:56:07 <fasta> opqdonut: you will see it soon enough in a Trac bug
07:56:13 <opqdonut> :)
07:57:03 <oerjan> @src fromIntegral
07:57:03 <lambdabot> fromIntegral = fromInteger . toInteger
07:57:08 <quicksilver> ivant: yes, I do
07:57:25 <oerjan> that would be a property of fromInteger
07:57:31 <quicksilver> ivant: it just seemed like the easiest way to write it at the time
07:58:08 <ivant> quicksilver, agreed, but my first thought was "where are those .&.'s"?
07:58:10 <fasta> We really need a way to automatically make GHC bug reports given a ghc panic.
07:58:29 <fasta> The process is easy to describe in words.
07:58:37 <fasta> Is anyone interested in doing that?
07:58:42 <quicksilver> ivant: :)
07:59:05 <fasta> I don't expect anyone to, though.
07:59:17 <oerjan> is that property of fromInteger actually mandated anywhere?
07:59:35 <vincenz> SamB: ah I might be able to use your system by changing the types around a bit
08:00:21 <vincenz> swiert: and no, I don't want m a functor, m must be a functor in another tyvar
08:00:43 <vincenz> which is the annoying bit, cause to make SamB's solution work, the last tyvar must be the Fix, while for a functor, the last tyvar must be the element
08:01:09 <roconnor> are there any nice lightweight svg viewers for linux (specifically ubuntu)?
08:01:46 <quicksilver> oerjan: I don't know
08:02:00 <oerjan> i think not: "The results of exceptional conditions (such as overflow or underflow) on the fixed-precision numeric types are undefined; an implementation may choose error (_|_, semantically), a truncated value, or a special value such as infinity, indefinite, etc."
08:02:24 <fasta> This bug is going to me a nightmare to the Simons.
08:02:37 <oerjan> (from 6.4 of the H98 report)
08:02:45 <fasta> Removing any line or removing anything equivalent to id makes it work again.
08:03:29 <glen_quagmire> hola friends
08:03:44 <vincenz> hpaste = down :(
08:03:51 <fasta> Also commenting deriving Monad makes it work again.
08:03:58 <glen_quagmire> > hpaste = down :(
08:03:58 <lambdabot>  Parse error
08:04:09 <fasta> I had no idea a compiler could break in so many ways
08:04:32 <glen_quagmire> compiler never breaks
08:04:40 <glen_quagmire> what do you mean? you found a bug in compier?
08:04:45 * shapr yawns
08:04:52 <shapr> Good morning #haskell!
08:04:57 <vincenz> SamB, swiert: http://rafb.net/p/kHTA9931.html
08:04:58 <lambdabot> Title: Nopaste - No description
08:05:30 <shapr> ricky_clarkson: Hiya, how's code?
08:05:48 <fasta> glen_quagmire: yes, I found a bug in the compiler.
08:05:54 <fasta> glen_quagmire: the nth one already. I lost count.
08:05:57 <SamB> oerjan: which types did they mean in H98?
08:06:19 <fasta> This is even H98 code that doesn't work in GHC.
08:06:22 <SamB> I don't remember any of Word8..Word64 being in H98
08:06:25 <vincenz> SamB: obviously it should be: data F m = F (m (F m))
08:06:37 <oerjan> SamB: Int and Integer I guess
08:06:47 <SamB> um
08:06:50 <fasta> Well, StateT is H98, IIRC.
08:06:57 <SamB> Integer is not fixed precision...
08:06:58 <fasta> I thought that one didn't use fundeps
08:07:34 <SamB> fasta: last I checked, "deriving Monad" wasn't H98
08:08:13 <fasta> SamB: Uh, right, I forgot about that minor thing
08:08:25 <oerjan> well, Float and Double also
08:10:30 <SamB> oerjan: okay. so we're down to Int where people might expect things not in fitting with this fragment of the report?
08:11:09 <oerjan> SamB: very well, so this has just about nothing to do with H98
08:11:11 <vincenz> SamB: see the issue?
08:12:53 <chessguy_> 'morning shapr!
08:13:02 <sphynx> hi!
08:13:57 <sphynx> is there some article describing haskell  numerical classes in wiki?
08:14:17 <sphynx> I've found only 'Convertion between numbers' and 'Generic number type'
08:14:18 <vincenz> swiert: haskell.dut voor nederlandstaligen ;)
08:14:19 <SamB> vincenz: so you want what would be fmap, but on the next-to-last parameter
08:14:29 <vincenz> SamB: right
08:14:50 <vincenz> it'd be stupid to reinvent the weheel and make an fmap2
08:15:13 <SamB> oh? that'd be stupid how?
08:15:25 <vincenz> cause we're reinventing the wheel?
08:15:37 <vincenz> class Functor2 f where
08:15:44 <vincenz>   fmap2 :: f a c -> f b c
08:15:56 <SamB> that's not reinventing the wheel unless you just made that up ;-P
08:16:03 * vincenz just made that up
08:16:11 <SamB> okay, see, someone already made that up
08:16:16 <SamB> so yes you are inventing the wheel
08:16:20 <vincenz> :)
08:16:20 <vincenz> where?
08:16:27 <vincenz> @hoogle fmap2
08:16:28 <lambdabot> No matches found
08:16:29 <SamB> I wish I could remember
08:16:32 <vincenz> @google fmap2
08:16:38 <lambdabot> http://nssdc.gsfc.nasa.gov/cd-rom/web_store.cgi?category=fmap2
08:16:38 <lambdabot> Title: NSSDC CD-ROM CATALOG - fmap2
08:16:39 <SamB> probably an email
08:17:21 <shapr> Good morning chessguy_!
08:17:25 <SamB> ah, yes, the "deriving Functor" thread
08:17:26 <vincenz> there's another one in a presentation
08:17:46 <vincenz> but there, fmap2 is for :: (a -> c) -> (b -> d) -> f a b - > f c d
08:17:57 <SamB> http://www.haskell.org/pipermail/haskell-prime/2007-March/002137.html
08:17:59 <lambdabot> Title: Deriving Functor, http://tinyurl.com/3yvp77
08:18:23 <vincenz> alright, thx :)
08:18:46 <chessguy> @hoogle m a -> b
08:18:47 <lambdabot> Prelude.id :: a -> a
08:18:47 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
08:18:47 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
08:18:57 <chessguy> @hoogle (Monad m) => m a -> b
08:18:58 <lambdabot> Prelude.id :: a -> a
08:18:58 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
08:18:58 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
08:19:23 * vincenz wonders whether there's a generic fold for Fix
08:19:29 <fasta> http://hackage.haskell.org/trac/ghc/ticket/1494
08:19:30 <lambdabot> Title: #1494 (panic! (the 'impossible' happened)) - GHC - Trac
08:19:37 <fasta> That's the bug I was talking about.
08:21:18 <SamB> vincenz: huh...
08:21:36 <SamB> vincenz: what type would you be hoping for?
08:22:26 <vincenz> let me mull on that a bit, anyways there's an issue of Functor2
08:22:50 * vincenz sighs, never mind, there isn't ... ugh tired
08:33:31 <rretzbach> mcons p q = p >>= \x -> q >>= \y -> return (x:y)
08:33:50 <rretzbach> Why can I return x?
08:34:01 <rretzbach> Shouldn't it be unknown to the 2nd bind?
08:34:31 <kpreid> no
08:34:40 <kpreid> the lambda extends over the entire right side
08:35:00 <kpreid> mcons p q = (p >>= (\x -> (q >>= (\y -> return (x:y)))))
08:35:09 <rretzbach> whoa
08:35:30 <quicksilver> \x -> behaves like a "church dot"
08:35:41 <quicksilver> its scope continues as far right as syntactically possibly
08:35:53 <quicksilver> (i.e. to the end of the enclosing syntactic thing)
08:36:15 <quicksilver> this turns out to be convenient in practice
08:36:29 <quicksilver> if you'd written (\x -> q) >>= \y -> return (x:y)
08:36:37 <quicksilver> then it would have been an error as you expected
08:36:49 <rretzbach> Aye.
08:38:53 <quicksilver> as well, actually, as being a type error most likely :)
08:39:29 <rretzbach> So writing it as do notation, would fail: mcons p q = do x <- p; y <- q; return (x:y)
08:40:51 <oerjan> um no, do x <- bindings extend to the end of the block as well
08:41:13 <quicksilver> do unsugars to the first form you wrote
08:41:17 <quicksilver> and thus bindings extend
08:45:43 <mdmkolbe|work> @hoogle Maybe a -> [a]
08:45:44 <lambdabot> Maybe.maybeToList :: Maybe a -> [a]
08:48:02 <glen_quagmire> kelly_clarkson: when is your new album comming out?
08:49:34 <dcoutts> Gtk2Hs 0.9.12 - RC1 is now available,
08:49:41 <dcoutts> tarball: http://haskell.org/gtk2hs/gtk2hs-0.9.11.3.tar.gz
08:49:41 <dcoutts> windows installer: http://haskell.org/gtk2hs/gtk2hs-0.9.11.3.exe
08:50:53 <Jaak> yay! what's new?
08:51:04 <fasta> darcs whatsnew
08:51:17 <fasta> ;)
08:51:41 <dcoutts> http://www.haskell.org/pipermail/libraries/2007-July/007711.html
08:51:41 <lambdabot> Title: Gtk2Hs 0.9.12 release candidate 1 available for testing
08:51:59 <dcoutts> Jaak: ^^ that has more detail
08:52:05 <hkBst> does pattern matching work with mulptiple arguments, like for example `eval (Symbol s) e m k = k (m $ e s) m' ?
08:52:06 <Jaak> ooh, drag and drop
08:52:17 <fasta> dcoutts: what ps backend is used?
08:52:19 <quicksilver> hkBst: yes, that looks fine
08:52:29 <quicksilver> hkBst: depending what you wanted it to me
08:52:30 <quicksilver> mean
08:52:59 <dcoutts> fasta: it's a cairo feature, ie it's implemented in code in cairo, not a separate ps writer lib
08:53:03 <quicksilver> hkBst: that means 'eval expects four parameters, the first is of the form 'Symbol s' and the other three are e, m, and k
08:53:26 <dcoutts> fasta: same for the pdf & svg
08:53:52 <dcoutts> fasta: on the other hand cairo uses libpng for the png backend and glitz for the opengl stuff
08:54:12 <sioraiocht> why is the instance of Functor for Either for (Either a) and not (Either)
08:54:55 <oerjan> sioraiocht: because Either takes two type arguments
08:55:07 <oerjan> and a Functor must take one
08:55:12 <sioraiocht> ohhh
08:55:21 <hkBst> quicksilver: yeah, and it will work with `eval (List l) e m k = ... ' ? Can I do that on other arguments too, or match on multiple args?
08:55:25 <sioraiocht> so it's just using the convention that Left is often an error value, then?
08:55:34 <quicksilver> hkBst: yup, and you can nest matches too
08:55:49 <quicksilver> hkBst: eval (List (x:xs)) (Symbol s) (Something else) =
08:55:54 <oerjan> well, or that convention was made because it makes it easy to make Either a a Monad
08:56:15 <quicksilver> and we don't have bifunctors :(
08:56:18 <oerjan> *an error Monad
08:56:22 <sioraiocht> oerjan: aye, although I see by default Either is not an instance of th emonad class,
08:56:25 <hkBst> quicksilver: good to know :) I shan't be afraid to do that then :D
08:56:25 <quicksilver> or 2-functors, or whatever that would be
08:56:36 <sioraiocht> is that because it's too specific to roll an error monad for ag iven situation?
08:56:39 <quicksilver> sioraiocht: it is, just not an instance in the prelude
08:56:46 <quicksilver> sioraiocht: the instance is in Control.Monad.Error
08:56:53 <sioraiocht> quicksilver: oh, thanks :)
08:57:15 <quicksilver> it's fiddly cos of the way fail expects a string
08:57:17 <quicksilver> *curse*
08:57:33 <fasta> dcoutts: does it support zooming arbitrarily far?
08:58:08 <sioraiocht> If something can be a monad, it is be definition a functor, correct?
08:58:15 <quicksilver> sioraiocht: you'd imagine so
08:58:19 <fasta> dcoutts:  e.g. http://bugzilla.gnome.org/show_bug.cgi?id=303365
08:58:20 <sioraiocht> as a monad is a (functor,bind,return)
08:58:21 <lambdabot> Title: Bug 303365 - increase zooming level (evince)
08:58:27 <quicksilver> sioraiocht: that is not reflected by the typeclasses we have though
08:58:37 <sioraiocht> quicksilver: no, it's just in theory
08:58:41 <quicksilver> sioraiocht: so you have 'liftM' which is presumably equivalent to 'fmap'
08:58:55 <quicksilver> sioraiocht: yes, there is a valid Functor instance for every Monad, given by 'fmap = liftM'
08:59:36 <quicksilver> I forget if there is a good reason why it's not Functor m => Monad m
08:59:52 <quicksilver> I think it's just because you'd have to write two instance definitions to define a new monad
08:59:55 <quicksilver> (which is a daft reason)
09:00:27 <sioraiocht> quicksilver: that is kinda silly, given one of the purpose of haskell is rigourous mathematical proof of your code =p
09:01:37 <dcoutts> fasta: yes, it supports arbitrary (invertible) affine transforms, so arbitrary zoom
09:01:52 <hkBst> sioraiocht: http://www.haskell.org/haskellwiki/Class_system_extension_proposal
09:01:54 <lambdabot> Title: Class system extension proposal - HaskellWiki, http://tinyurl.com/ypupbe
09:02:11 <dcoutts> fasta: the evince bug is because they hold the whole image in memory
09:02:54 <SamB> and every monad should have such a Functor instance, too...
09:02:56 <quicksilver> sioraiocht: http://www.mail-archive.com/haskell-prime@haskell.org/msg01580.html
09:02:58 <lambdabot> Title: All Monads are Functors, http://tinyurl.com/yuc96g
09:03:49 <sioraiocht> is there any goal to provide an update to the haskell 98 report? (i.e. the "new" standard haskell?)
09:04:15 <dcoutts> sioraiocht: yes, Haskell' aka Haskell-prime
09:04:23 <dcoutts> which will become the next standard
09:04:36 <sioraiocht> dcoutts: will ghc support it? =)))
09:04:41 <dcoutts> of course
09:05:31 <EvilTerran> it already supports quite a few bits of it with -fglasgow-exts
09:05:42 <sioraiocht> how would it be "ratified"
09:05:50 <quicksilver> it will be, essentially a distillation of what ghc does + what the new libraries do
09:05:58 <quicksilver> sioraiocht: there is a committee, the deatils are on the website
09:06:10 <sioraiocht> quicksilver: ah, thanks =)
09:06:29 <sioraiocht> I have to say the haskell community is fascinating
09:06:38 <sioraiocht> the most intellectually stimulating one I've been a part of
09:07:35 <EvilTerran> as the topic says, "Haskell[...]: [...] think more!"
09:08:31 <quicksilver> sioraiocht: amen to that
09:08:45 <quicksilver> on bad days, it's the only thing that stops my brain atrophying
09:09:28 <sioraiocht> quicksilver: not to mention, before coming here I would just eschew anything dealing with such higher pure mathematics; haskell has actually forced me to become more confident in my maths skills
09:10:43 <quicksilver> hopefully, it's also forced you to recognise that they are valuable skills
09:10:54 <quicksilver> and not just something stupid taught at school, as is believed widely in my country, at least :)P
09:11:09 <sioraiocht> quicksilver: what country?
09:11:20 <quicksilver> UK
09:12:34 <sioraiocht> quicksilver: mathematics not directly appliable to engineering is often considered useless, so anything beyond calculus, differential equations, basic linear alg is for "weird" people
09:12:45 <sioraiocht> quicksilver: where are you studying? you're a PhD student, right?
09:12:50 <quicksilver> not any more :)
09:12:58 <sioraiocht> ah, where DID you study?
09:12:59 <quicksilver> I did my PhD at Queen Mary, which is in the east end of london
09:13:04 <sioraiocht> cool
09:13:16 <sioraiocht> I'm starting grad school in Oct in the UK (I'm from the US)
09:13:31 <quicksilver> where?
09:13:53 <sioraiocht> Oxford
09:14:04 <sioraiocht> for Computer Science
09:14:12 <quicksilver> should be great
09:14:14 <quicksilver> enjoy...
09:14:18 <sioraiocht> I hope so, hehe
09:14:20 <EvilTerran> which college (if i may ask)?
09:14:26 <sioraiocht> EvilTerran: St Anne's
09:14:57 <sioraiocht> quicksilver: thanks, most people's reply is "cambridge is better" lol
09:15:12 <quicksilver> well, of course it is, but it would be mean to say that :P
09:16:07 <sioraiocht> LOL
09:16:23 <EvilTerran> that's really well placed for the comlab. good choice ;)
09:16:41 <sioraiocht> you go there, EvilTerran ?
09:17:01 <sioraiocht> it wasn't mine, i was rejected by keble and balliol =p
09:17:03 <EvilTerran> i'm at Keble (one block south of the comlab). well, not at the moment, but in term-time
09:21:49 <sioraiocht> EvilTerran: grad or ugrad?
09:22:01 <sioraiocht> and St Anne's grad housing is in Summertown =p
09:22:40 <EvilTerran> undergrad, just finished first year
09:22:44 <sioraiocht> quicksilver: Cambridge's app was ridiculous, and the people answering my questions were so snotty as to ask me for my prior published works applying from an undergrad program that I said, "well, fuck you"
09:22:51 <sioraiocht> EvilTerran: in CS, i take?
09:22:59 <sioraiocht> EvilTerran: my boyfriend might be your TA, LOL
09:23:11 <EvilTerran> yeah, CS. waiting for my mods results just now :X
09:23:28 <hkBst> what is the closest legal Haskell identifier to say "e*"?
09:24:08 <scook0> "e'"? "e_"?
09:24:26 <vincenz> eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee....
09:24:34 <hkBst> :)
09:24:44 <dmead> MY NAME IS THE LORAX
09:24:48 <dmead> I SPEAK FOR THE TREES
09:25:09 <scook0> vincenz: surely that one's only legal if you never use it, lazy-style ;)
09:25:31 <sioraiocht> EvilTerran: very cool, are you going for the BA in CS or the M. CS?
09:25:36 <EvilTerran> my main tutors're S.Clark and C.Dilloway. i've had practicals taken by a certain D.Coutts, too...
09:25:46 <shachaf> scook0: You can use it, as long as you don't try to do something with all of its name.
09:26:02 <dcoutts> hmm :-)
09:26:10 <sioraiocht> dcoutts is an oxy prof? *hides* I didn't know that.
09:26:26 <dcoutts> not a prof, fear not :-)
09:26:35 <sioraiocht> dcoutts: TA?
09:26:39 <shachaf> > let var = fix ('e':) in take 20 var -- using it, maybe even referring to it, but not using all of it
09:26:39 <dcoutts> right
09:26:40 <lambdabot>  "eeeeeeeeeeeeeeeeeeee"
09:26:46 <EvilTerran> MCS, i think. don't need to decide 'til this time next year. oh, hi, dcoutts; i was hoping that putting the dot in would save you from being beeped.
09:27:01 <dcoutts> EvilTerran: heh heh
09:27:49 <sioraiocht> dcoutts: my bf is in worcester college
09:28:03 <dcoutts> sioraiocht: I'm a Worcester too
09:28:03 * EvilTerran is reminded of an ircop on another network he frequents who has alerts on such things as "<his first initial>***"
09:28:06 <dcoutts> a/at
09:28:30 <sioraiocht> dcoutts: I know, I checked your comlab profile.  He was wondering if you tell him the sort of things TA's do, if it differs from US schools
09:28:41 <sioraiocht> can he harass you on irc later a lil bit?
09:29:09 <chessguy> anyone care to help me a bit with getting haskell-mode on emacs working?
09:29:10 <dcoutts> sioraiocht: I'm (almost) always happy to talk to my students :-)
09:29:38 <sioraiocht> dcoutts: okies, hye's just been shortlisted for a TAship to pay his tuition, he wants to be prepared for the phone interview
09:29:43 <chessguy> i have it installed, put the (load "path") in my _emacs file, but not sure how to tell whether it's actually working
09:29:53 <sioraiocht> chessguy: fighting with haskell-mode?
09:30:00 <rretzbach> chessguy: (require 'haskell-mode)
09:30:06 <rretzbach> M-x haskell-mode
09:30:14 <dcoutts> sioraiocht: ah, that's the job I had, as I'm finishing the lab is recruiting another.
09:30:22 <chessguy> did i mention i'm an emacs noob?
09:30:44 <hkBst> chessguy: load some .hs file, look for "Haskell" in the staus bar...
09:31:17 * EvilTerran finds emacs intimidating. I tend to use screen with ghci in the top half and vim (or pico, if i'm feeling lazy) in the bottom...
09:31:26 <sioraiocht> dcoutts: lol neat
09:31:53 <hkBst> chessguy: what distro are you on?
09:31:55 <rretzbach> EvilTerran: I have the same window setup as buffer setup in emacs.
09:32:02 <edward1> @seen ndm
09:32:03 <lambdabot> I saw ndm leaving #xmonad, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 23h 24m 34s ago, and .
09:32:07 <rretzbach> hitting F7 in my .hs loads it directly in ghci
09:32:16 <dcoutts> sioraiocht: so the main requirement for the TA job is enthusiasm, common sense and being open to learning how to teach effectively.
09:32:18 <EvilTerran> unfortunately, vim doesn't and probably never will support embedded terminals
09:32:24 <rretzbach> If there are errors it jumps to the error line
09:32:28 <chessguy> hkBst, windows
09:32:38 <sioraiocht> dcoutts: he's definitely that, his reserach is into designing multi-paradigm programming languages for pedagogical purposes
09:32:41 <shachaf> EvilTerran: Any reason you want it to?
09:32:48 <hkBst> chessguy: hmm, never heard of...
09:33:03 <EvilTerran> shachaf, well, feature creep. ;p
09:33:11 <EvilTerran> ...also emacs does it
09:33:17 <sioraiocht> dcoutts: CS pedagogy is his big "thing"
09:33:20 <shachaf> EvilTerran: But you can use screen, as you said, or a window manager like xmonad.
09:33:38 <chessguy> ah, ok, syntax highlighting works when i open a .hs file
09:33:40 <dcoutts> sioraiocht: oh interesting, I especially enjoy teaching programming languages to our first year students. I've designed and organised the FP practicals for the last couple years.
09:33:55 <dcoutts> FP being our very first course
09:33:57 <sioraiocht> dcoutts: do you do any lecturing? what about grading?
09:34:08 <sioraiocht> (now he's just asking me questions right now to ask you, lol)
09:34:21 <dcoutts> sioraiocht: no lecturing, organising, running and grading practical work.
09:34:22 <EvilTerran> ooh, that reminds me. i should install xmonad the next time i'm booted into fedora (off a USB disc, which added some interesting difficulties)
09:34:45 <rretzbach> wth is an usb disc?
09:35:07 <dcoutts> sioraiocht: to be clear; no lecturing, *just* organising, running and grading practical work.
09:35:20 <shachaf> EvilTerran: There's a difference between vim and emacs. Vim is an editor. Emacs is an OS written in elisp which happens to have a nice editor (VIPER).
09:35:30 <dcoutts> sioraiocht: though one has the option of doing classes too, but they're more work, so I avoid them :-)
09:35:43 <EvilTerran> rretzbach, one of these: http://www.wdc.com/en/products/products.asp?driveid=262
09:35:45 <lambdabot> Title: WD Passport Portable (Black) 160 GB USB 2.0 Hard Drives ( WDXMS1600 )
09:36:28 <EvilTerran> shachaf, yes, i became significantly more tolerant of emacs after i realised that it was more of a lisp interpreter than a text editor. before that, i just thought it monsterously bloated.
09:36:37 <shachaf> EvilTerran: Why would you *want* a terminal in your editor? That's the job of external tools.
09:36:51 <quicksilver> because, then you have access to your editor commands in your terminal
09:36:56 <chessguy> so the keybindings at http://haskell.org/haskellwiki/Haskell_mode_for_Emacs#Tips_and_use already exist if you have haskell-mode installed?
09:36:58 <lambdabot> Title: Haskell mode for Emacs - HaskellWiki, http://tinyurl.com/w7vnb
09:36:58 <quicksilver> like navigation of complex haskell expressions
09:37:05 <quicksilver> (if the terminal is running ghci)
09:37:08 <hkBst> can I do: `(\(List ls) m -> ...'
09:37:22 <quicksilver> hkBst: yes
09:37:39 <quicksilver> > (\(Just m) -> m) $ Just 4
09:37:47 <lambdabot>  4
09:37:55 <hkBst> :) amazing
09:37:56 <shachaf> EvilTerran: Yes, except that it's elisp. If you use a LISP, I'd much prefer, say, Scheme to elisp.
09:38:42 <rretzbach> EvilTerran: Ah, I see, thanks.
09:40:42 <chessguy> whoah
09:40:53 <chessguy> ghci in an emacs buffer, very nice
09:45:18 <sioraiocht> stupid IRC licent
09:45:19 <sioraiocht> *kicks*
09:52:37 <Tychom> perhaps a silly question, but why in the Data.HashTable module do all HashTable related functions return 'IO a' for some type a. Why IO at all? is there something impure about them?
09:53:38 <sioraiocht> Tychom: if it's a mutable data structure, then yes
09:54:19 <Tychom> hm, i notice now that none of the funcitons return new HashTables
09:54:31 <sioraiocht> aye, instead they reutrn IO actions
09:54:55 <sioraiocht> because an immutable hash table woudl be, uhh, not fast, at all
09:55:26 <quicksilver> Tychom: rule-of-thumb: don't use hashtable
09:55:44 <quicksilver> Tychom: it's not what you usually need, and it isn't even a particularly fast implementation
09:55:51 <sioraiocht> quicksilver: for fast lookups what else would you use?
09:55:56 <quicksilver> Data.Map
09:55:58 <chessguy_> mmmm, hoogle support, ghci, and source code, all combined into one program. it's about time
09:56:12 <quicksilver> Data.Map is actually faster than hashtable most of the time
09:56:16 <quicksilver> (all the time, perhaps?)
09:56:20 <quicksilver> and it's pure functional, and much purtier
09:56:24 <sioraiocht> a Map is a dictionary based on trees, right?
09:56:28 * quicksilver nods
09:56:42 <sioraiocht> *remembers his 2nd year data structures course...honeset*
09:56:47 <Tychom> ha, well i'm just looking at the libraries right now. done Data.Map already, was about to try simply 'dropping in' the hashtable, but doesnt look likely.
09:57:18 <sioraiocht> not to mention, HashTables are strict, are Maps?
09:57:35 <quicksilver> maps are pretty lazy AFAIK
09:57:35 <Tychom> only if you try to find something
09:58:00 <sorear> re.
09:58:10 <sioraiocht> quicksilver: but doesn't it have to evalulate a thunk to know where to put it in the tree?
09:58:26 <quicksilver> sioraiocht: depends on the Ord instance you give it
09:58:27 <oerjan> sioraiocht: only the key
09:58:35 <sioraiocht> oerjan: right.
09:58:37 <quicksilver> sioraiocht: but it doesn't have to put it in the tree, even, straight away
09:58:38 <sioraiocht> quicksilver: true
09:58:42 <Tychom> issue i have now is that i can add lots of stuff very quickly to a mpa but as soon as i try to get something out it all slows down.
09:58:48 <sioraiocht> quicksilver: ahhh, good point
09:59:07 <quicksilver> tbh, I normally use it with fromList
09:59:10 <quicksilver> rather than insert
09:59:19 <quicksilver> lists are such a natural 'intermediate structure' in haskell
09:59:27 <sioraiocht> Tychom: well, tree lookups are O(log n)
09:59:56 <sioraiocht> quicksilver: fomrList is O(nlogn)
10:00:44 <quicksilver> sioraiocht: indeed
10:00:54 <quicksilver> sioraiocht: as is any way of inserting all that data into a tree :)
10:01:06 <quicksilver> sioraiocht: inserting => sorting, and sort >= n log n
10:01:07 <sioraiocht> quicksilver: aren't tose just logn?
10:01:13 <sorear> quicksilver: There are slower ways.
10:01:30 <quicksilver> sioraiocht: log n per entry, yes
10:01:38 <quicksilver> sioraiocht: n log n to insert n entries :)
10:01:41 <sioraiocht> right
10:01:42 <sioraiocht> :)
10:01:45 <quicksilver> sioraiocht: which is what fromList does
10:01:56 <sioraiocht> quicksilver: touchÃ©
10:02:03 <Tychom> sioraiocht: true, and i'm adding 60k items in no time, but the moment i try to get a single item out it takes a number of seconds to work it out (the first time only), which gives some strange performance characteristics for sure
10:02:15 <quicksilver> Tychom: that's laziness for you
10:02:21 <quicksilver> Tychom: when you add the items it's doing nothign at all :)
10:02:28 <quicksilver> Tychom: just building up a nice list of things to add later
10:02:47 <quicksilver> Tychom: it's notoriously hard to time the 'right parts' of a lazy program
10:02:59 <quicksilver> you often end up with all the real work happening at the end, just when its needed
10:03:02 <sioraiocht> Tychom: that's what seq is for, imo, hehe
10:03:04 <Tychom> yeah i figured that much out, just thinking of ways where i can get the timing to average out rather than be bottle necked
10:03:27 <quicksilver> Tychom: you could force the spine of the map by calling size on it
10:03:27 <sorear> strictness!
10:03:41 <quicksilver> Tychom: as long as you seq the size :)
10:03:51 <sorear> quicksilver: Maps are already spine-strict iirc, so you just need to seq the whole thing
10:04:05 <sorear> quicksilver: besides, size wouldn't work since it is cached in the root
10:04:14 <quicksilver> sorear: depends where you think the laziness is
10:04:24 <quicksilver> sorear: I was just assuming we had a big thunk of nested inserts
10:04:34 <quicksilver> sorear: but you're right, seq'ing the whole thing should have the same effect
10:04:51 <quicksilver> sorear: unless Data.Map pops up with an intermediate constructor after only doing part of the work
10:05:02 <quicksilver> sorear: (i.e. your solution assumes more about the implementation of Data.Map than mine does)
10:05:39 <sorear> quicksilver: Why do you think callling size would force the entire Map spine?
10:06:21 <sorear> size t
10:06:21 <sorear>   = case t of
10:06:21 <sorear>       Tip             -> 0
10:06:21 <sorear>       Bin sz k x l r  -> sz
10:06:26 <sorear> no recursion!
10:06:57 <quicksilver> sorear: because I assume it can't build that Bin sz without spining the map
10:07:04 <quicksilver> sorear: so yes, I am assuming something too :)
10:10:23 <kpreid> what about fromDistinctAscList?
10:10:33 <kpreid> that *could* have a size without a computed tree
10:11:25 <Saizan> even fromList could have it then, length . nub
10:12:00 <glen_quagmire> ima nub
10:12:02 <kpreid> well, but that would be going out of its way. fDAL could do it accidentally
10:17:27 <Tychom> to be clear on my issue - i was hoping (naively?) that the lazy inserts would take next to no time (which is the case - yay) but that queries would be as lazy as needed too (building as much of the spine as needed), but i'm finding that when you perform the first query it takes the same amount of time as forcing the spine in the first place (e.g. by a call to size).
10:18:16 <Toxaris> Tychom: sounds like you want an unbalanced tree
10:18:38 <Tychom> perhaps some more testing will show a performance issue elsewhere anyway :)
10:20:00 <Toxaris> Tychom: because with an balanced tree, you can't begin searching before all elements are inserted, because where you have to search depends on balancing operations
10:20:01 <Tychom> Toxaris: it could do the trick tbh
10:44:33 <crazy_code2> hello
10:46:19 <sorear> Hello.
10:46:34 <sioraiocht> hey crazy_code2
10:47:01 <sorear> @seen shapr
10:47:01 <lambdabot> shapr is in #xmonad, #scannedinavian, #haskell-blah and #haskell. I last heard shapr speak 2h 29m 39s ago.
10:51:34 <sioraiocht> #haskell-blah
10:51:37 <sioraiocht> ?
10:52:07 <EvilTerran> non-haskell conversation amoungst haskellers, iirc
10:53:05 <osfameron> yeah
10:55:14 <sioraiocht> aha
11:00:47 <Serdar> hi
11:02:10 <sorear> Hello.
11:03:56 <Serdar> errors at haskell are hard to understand for me, I hope, I get help here
11:04:26 <Serdar> http://rafb.net/p/UVNJVQ56.html <-- I don't understand why I get this ausr :: forall a a1. (Num a1) => [[a]] -> a1 -> [a]
11:04:27 <lambdabot> Title: Nopaste - No description
11:04:39 <Serdar> ?
11:04:50 <shapr> sorear: You called?
11:05:10 <sorear> shapr: Yup.
11:05:23 <sorear> shapr: I have the spam-filter working on localhost
11:05:46 <Lemmih> Serdar: Perhaps you meant 'ausr (b:x) o = [b]'?
11:05:51 <Serdar> I hoped I get something like this [a] -> Int -> [a]
11:05:56 * shapr throws distributed lambdas at Lemmih 
11:06:04 <shapr> sorear: Yay! Send me the patch!
11:06:10 <Serdar> Lemmih, is b not an element?
11:06:16 <sorear> shapr: --to=?
11:06:36 <shapr> shae pÃ¥ scanned in avian punkt com
11:07:04 <Lemmih> Serdar: An element? The world 'element' is terribly overloaded.
11:07:05 <Eelis> Serdar: the easiest way to find the problem is by explicitly adding a type declaration. you'll then get errors when your function definition cannot be typed the way you wanted it to
11:07:17 <Lemmih> *word
11:07:22 <shapr> word up
11:07:32 <shapr> word to ya momma!
11:07:56 <Eelis> Serdar: and these errors will tell you exactly which (sub)terms are problematic
11:07:57 <shapr> (word64 probably, as mothers often have large vocabularies)
11:08:15 <Serdar> Eelis, you mean something like this: ausr :: [a] -> Int -> [a]?
11:08:21 <Eelis> Serdar: yes.
11:09:14 <sorear> shapr: Sent; note that on my system happs randomly stalls, but since that happened even before I started hacking hpaste I presume it's a happs-devel issue and not a result of my changes.
11:10:00 <chessguy> > takeWhile (\s -> s .&. 0x88 /= 0) (iterate (+ 11) 0
11:10:00 <lambdabot>  Parse error
11:10:08 <chessguy> > takeWhile (\s -> s .&. 0x88 /= 0) (iterate (+ 11) 0)
11:10:09 <lambdabot>  Add a type signature
11:10:18 <chessguy> why am i getting that ambiguous type?
11:11:04 <kpreid> you haven't specified what kind of number you want
11:11:11 <shapr> sorear: Any idea why it stalls?
11:11:39 <chessguy> well
11:11:42 <sorear> shapr: No. And alexj couldn't explain it either.
11:11:46 <chessguy> i guess i haven't said the whole story
11:12:15 <chessguy> what i'm actually doing is this:
11:12:16 <chessguy> ray :: Int -> Int -> [Int]
11:12:16 <chessguy> ray d sq = takeWhile (\s -> s .&. (0x88 :: Int) /= 0) (iterate (+ d) sq)
11:12:20 <sorear> shapr: He said browser bugs were definitely the cause, I told him my browser worked fine with the kakapo instance, he gave up.
11:12:51 <chessguy> > takeWhile (\s -> s .&. (0x88 :: Int) /= 0) (iterate (+ 11) 0)
11:12:52 <lambdabot>  []
11:12:59 * chessguy sighs
11:13:00 <chessguy> never mind
11:13:13 <chessguy> that's not the right answer, but it's at least not an ambiguous type anymore
11:13:41 <oerjan> :t (.&.)
11:13:43 <lambdabot> forall a. (Bits a) => a -> a -> a
11:13:58 <kpreid> > takeWhile (\s -> s .&. (0x88 :: Int) /= 0) (tail (iterate (+ 11) 0))
11:14:00 <lambdabot>  [11]
11:14:13 <kpreid> > iterate (+ 11) 0)
11:14:13 <kpreid> > iterate (+ 11) 0
11:14:13 <lambdabot>  Parse error
11:14:15 <lambdabot>  [0,11,22,33,44,55,66,77,88,99,110,121,132,143,154,165,176,187,198,209,220,23...
11:14:25 <kpreid> the first element is 0, so your takeWhile stops at it
11:15:23 <chessguy> err, how do i stop an infinite computation in ghci in an emacs buffer
11:15:36 <sorear> chessguy: C-c
11:15:43 <sorear> chessguy: twice
11:15:54 <shapr> sorear: bizarre
11:16:42 <kpreid> it's just a multi-key binding
11:16:45 <kpreid> C-c C-c
11:16:46 * sorear ponders fixing haxml for ghc-6.7 and then using the debugger
11:17:37 <Igloo> What's broken about it with 6.7? Just package splitups?
11:18:22 <savanni> Can anybody tell me what the /> operator means in the context of this page: http://tinyurl.com/2jooar
11:18:25 <lambdabot> Title: XML Matters: Transcending the limits of DOM, SAX, and XSLT
11:18:27 <Lemmih> sorear: There's a simple debugger for 6.6.
11:18:55 <sorear> savanni: <foo/>  == <foo></foo>
11:19:13 <sorear> oh, not what you menat
11:19:22 <savanni> Right...
11:19:31 <savanni> drat... more detail
11:19:36 <savanni> Listing 3: HaXml program to...
11:19:44 <savanni> (sorry, I forgot the page was as long as it is)
11:20:13 <savanni> Also, is HaXml sorta the most common XML library for Haskell?
11:20:51 <EvilTerran> http://www.cs.york.ac.uk/fp/HaXml/HaXml/Text-XML-HaXml-Combinators.html#v%3A%2F%3E
11:20:53 <chessguy_> oh!
11:20:54 <lambdabot> http://tinyurl.com/24wc7h
11:21:06 <chessguy_> it helps if i actually read the paper i'm ripping the idea off of correctly
11:21:29 <savanni> Oh, sweet, thanks EvilTerran!
11:21:59 <EvilTerran> np. that's probably a useful page in general, if you're learning haxml as you go along.
11:22:06 <savanni> I pretty much am.
11:25:30 <chessguy> is there some way to repeat the last command in ghci in emacs?
11:25:58 <Saizan> chessguy: M-p RET
11:26:18 <chessguy> what about from the other buffer :)
11:27:06 <Saizan> i don't know, then
11:27:22 <chessguy> hey, finally, a limitation to emacs :)
11:27:40 <chessguy> (barely)
11:27:44 <EvilTerran> you can almost certainly script it up
11:28:43 <chessguy> don't ruin my fun :)
11:28:44 <sorear> C-x z might do what you want :)
11:29:05 <chessguy> "There is nothing to repeat"
11:30:53 <chessguy> edward1, ping
11:31:26 <chessguy> @seen edwardk
11:31:26 <lambdabot> I saw edwardk leaving #haskell 22h 35m 12s ago, and .
11:31:30 <chessguy> mmm
11:31:34 <chessguy> @seen edward1
11:31:34 <lambdabot> edward1 is in #haskell. I last heard edward1 speak 1h 59m 32s ago.
11:32:33 <Igel> hi
11:32:42 <chessguy> now i just have to figure out how to bind @pl to a key :)
11:32:54 <Igel> is there a way to find out the endian of the os?
11:33:03 <Igel> it would save us a sleepless night :)
11:33:26 <chessguy> @pl r d sq = t (\s -> s 0x88 == 0) (iterate (+d) sq)
11:33:26 <lambdabot> r = (t ((0 ==) . ($ 136)) .) . iterate . (+)
11:33:54 <chessguy> @pl r d sq = t (\s -> s .&. 0x88 == 0) (iterate (+d) sq)
11:33:55 <lambdabot> r = (t ((0 ==) . (.&. 136)) .) . iterate . (+)
11:36:36 <SamB> hmm, it looks like hugs is confused by many things that I am also confused by. I have to wonder if it isn't really a feature, when it comes to the lexical stuff...
11:36:49 <chessguy> err, hpaste is down?
11:36:52 <chessguy> !paste
11:37:00 <chessguy> @paste
11:37:00 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:37:01 <shapr> It's been down for about 24 hours, for reasons of spam.
11:37:20 <shapr> sorear sent me a patch, hpaste will be back up after I apply that patch and restart hpaste.
11:37:40 <chessguy> shapr, so what are you waiting for, darnit!
11:37:46 <shapr> I haven't gotten the patch yet.
11:37:53 <chessguy> details, details!
11:38:12 <shapr> Do you want to fix it?
11:38:25 <chessguy> will we be able to access old pastes?
11:38:32 <shapr> I dunno
11:38:33 <chessguy> shapr, i'm just teasing
11:38:47 <sorear> shapr: I sent it to map succ "rg`d?rb`mmdchm`uh`m-bnl".  Correct?
11:39:13 <shapr> yup
11:41:02 <shapr> I want to send a sound event across vnc, and firefox can send something like a system bell. Does anyone know if that's \BEL ? If so, how do I send it from a Haskell program so that I can hear when a long running process completes?
11:41:31 <sorear> I suspect it's XkbBell
11:41:43 <sorear> so try system "xkbbell"
11:42:05 <shapr> ah spiffy
11:42:37 <chessguy> sorear, you are insanely smart
11:42:40 <shapr> that's it, thanks
11:42:48 <chessguy> that's just ridiculous, that you would know that off the top of your hea
11:42:49 <chessguy> d
11:45:16 <shapr> chessguy: You should read Hamming's "The Art of Science and Engineering : Learning to Learn."
11:45:23 <chessguy> oh?
11:45:33 <chessguy> why's that?
11:45:50 <shapr> It's sort of about how to be smart.
11:46:26 <Heffalump> the point shapr is referring to here is the bit about knowledge being like compound interest in how much more productive it makes you
11:46:40 <Heffalump> the more you know, the more chance you have to discover new stuff
11:48:18 <chessguy> sounds interesting
11:48:37 <DRMacIver> I'm not convinced knowledge makes me more productive.
11:49:03 <astrolabe> It would explain why I know so little
11:49:03 <shapr> I wish Network.* showed up in ghc6-doc.
11:49:15 <Heffalump> it does when it saves you having to look stuff up, or helps you make connections you wouldn't otherwise
11:49:16 <DRMacIver> I've found that far more often it makes me insanely frustrated because I know the correct way of doing things and am unable to adopt it due to political constraints.
11:49:31 <Igloo> shapr: In unstable, it should do
11:49:31 <sorear> libghc6-network-doc maybe?
11:49:35 <Heffalump> bear in mind that Hamming was talking about research
11:49:52 <DRMacIver> Yes, for pure researchy things I agree that it does. :)
11:49:52 <shapr> sorear: too easy :-)
11:50:07 <DRMacIver> Or even impure non-researchy things in a good environment.
11:50:21 <shapr> Or even figuring out the best way to sort socks.
11:50:29 <shapr> (a modified mergesort, btw)
11:50:33 <DRMacIver> Really I was just using the opportunity to insert a mini-rant. Don't mind me. :)
11:50:56 <Igloo> The best way to sort socks is to define all your socks as "blackish"
11:51:02 <SamB> sorear: do you happen to know if I can rely on a JHC representing a monomorphic value as a single word?
11:51:31 <sorear> SamB: Yes.
11:51:32 <shapr> Igloo: what was the magic reindex haddocks command for debian ghc6 docs?
11:51:47 <SamB> can I?
11:51:51 <shapr> Igloo: heh
11:51:54 <sorear> SamB: The answer is "No" - How could JHC possibly represent Double in one word?
11:52:06 <Igloo> shapr: The latest unstable packages should Just Work
11:52:08 <sorear> yay for the pidgeonhole principle!
11:52:12 <ricky_clarkson> Sort socks lazily.  The tolerance level for mismatched pairs increases the more lazy your approach to laundry is.
11:52:15 <shapr> sorear: 256 bit words?
11:52:20 <SamB> well, what if I meant a monomorphic function value.
11:52:51 <SamB> would it use one word (which points to other stuff)?
11:53:32 <sorear> SamB: Not sure about JHC, but Boquist's original GRIN had a habit of passing around functions as unpacked multi-word partial applications
11:53:52 <SamB> sorear: see, that's exactly what I'm afraid of.
11:54:26 <MarcWeber> Does Daan Leijen show up here occasionally ?
11:54:38 <shapr> sorear: Oh hey, did you read the GRIN thesis?
11:54:39 <sorear> Not afair.
11:54:57 <shapr> MarcWeber: I think once, at the end of 2003.
11:54:58 <sorear> shapr: I think I got a third of the way through it. :)
11:55:18 <sorear> that is one long paper ;)
11:55:23 <shapr> sorear: Too bad, I have a question about his 'generating pure machine code' comment.
11:56:18 <SamB> sorear: I'm wondering how you'd implement foreign import "wrapper"
11:56:50 <MarcWeber> shapr: I've sent some mails to him twice about a month ago and about 1 year ago. But I didn't get any response. I'd like to contact him to make some suggestions about parsec...
11:57:03 <sorear> SamB: I can never remember which of "wrapper" and "dynamic" is which; can you give a type signature?
11:57:24 <sorear> doh
11:57:27 <sorear> @where ffi
11:57:27 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
11:57:29 <MarcWeber> shapr: Do you know wether he might be interested?
11:57:38 <SamB> foreign import "wrapper" name :: (Int -> Float -> Char) -> IO (FunPtr (Int -> Float -> Char))
11:58:06 <sorear> Daan Leijen is *very* hard to reach.  I've tried myself without success.
11:58:25 <sorear> You might have more luck asking SPJ to tell Daan
11:58:28 <sorear> :)
11:59:02 <SamB> are you implying that SPJ has Daan's phone number?
11:59:34 <MarcWeber> sorear: I don't think its that important...
11:59:52 <shapr> salut Lunar^
12:00:05 <MarcWeber> Is it crazy to use parsec to create a lexer for happy?
12:00:19 <shapr> MarcWeber: I think that instead, you should take over maintainership of Parsec and gather up the last five years worth of suggestions and integrate them :-)
12:00:50 <shapr> I suggested some parsec extensions in 2001 I think. I even met Daan at ICFP 2003. I still don't think I've gotten a response from him.
12:00:51 <SamB> MarcWeber: yeah, you should ask SPJ to tell Daan you want his inbox ;-)
12:01:22 <SamB> or, well, at least set up a parsec@haskell.org list with a gmane group
12:01:24 <MarcWeber> Does he read haskellcafe?
12:01:45 <sorear> SamB: They share an office.
12:01:52 <SamB> sorear: ah
12:02:14 <Serdar> filter :: forall a. (a -> Bool) -> [a] -> [a] <-- filter needs a function that needs an a and returns Bool and a list and returns a list?
12:02:17 <sorear> well, an office building anyhow (MSR)
12:02:32 <shapr> Serdar: That's correct.
12:02:56 <Serdar> hmm
12:03:28 <sorear> SamB: " Full support for Haskell 98, The FFI and some extensions." <- jhc info page
12:03:33 <sorear> the ffi?!
12:03:43 <MarcWeber> So perhaps I should start another haskellcafe thread asking for improvements and wether it's worth creating yet another mailinglist ? What I really like about haskellcafe is that you get input from all directions and topics. At least we can collect patches this way easily
12:04:11 <sorear> MarcWeber: Great idea
12:05:17 <shapr> sorear: The one point of Boquist's GRIN thesis that niggles at me is his comment on page 194 that SSA machine code also has benefits that were discovered too late to be put into the thesis. What are those benefits?!?
12:05:29 <sorear> SamB: "Produces 100% portable ISO C. The same C file can compile on machines of different byte order or bit-width without trouble." <- it's not possible to implement foreign import wrapper without some form of dynamic code generation.  system("gcc -shared") && dlopen would work, but it still wouldn't be ISO C
12:05:40 <SamB> sorear: yes I know.
12:06:03 <SamB> JHC doesn't yet implement that, and the implementation for foreign export seems bitrotted too
12:06:35 <SamB> sorear: but I'm not sure tagged pointers are actually ANSI-compatible anyway
12:07:02 <SamB> or ISO, same thing anyway...
12:07:21 <SamB> (the C standards, not the entities)
12:07:24 <Serdar> hmm
12:09:36 <shapr> Serdar: Got questions about filter?
12:10:18 <Cale> > even 5
12:10:20 <lambdabot>  False
12:10:26 <Cale> > filter even [1,2,3,4,5]
12:10:28 <lambdabot>  [2,4]
12:11:08 <Serdar> ahh I see
12:11:14 <savanni> So, another HaXml question:
12:11:55 <savanni> Other than the function processXmlWith, how do I connect an XML string to the CFilter functions?
12:13:53 <sorear> SamB: Does JHC have StablePtrs?
12:14:11 <savanni> And the only reason I want to avoid processXmlWith at the moment is that I am trying to play on the GHCI command line, and processXmlWith only seems to want to grab stuff from stdin
12:16:27 <SamB> sorear: ah, those would do nicely I guess
12:16:46 <sorear> SamB: well that's how ghc handles it :)
12:17:10 <sorear> Ooh cool!
12:17:13 <sorear> @seen ghcbot
12:17:13 <lambdabot> ghcbot is in #ghc. I don't know when ghcbot last spoke.
12:17:28 <SamB> I guess it would be nice if we could tie the making of them to the use of them, when we use them for that...
12:19:52 <SamB> sorear: so, how does GHC build thunks?
12:20:57 <Serdar> hmm rewriting filter sucks :/
12:21:04 <sorear> SamB: if (Hp + 18 > HpLim) { blah blah } word[Hp], word[Hp+4], ...   and then Hp = Hp + 18;
12:21:10 <sorear> SamB: in the heap
12:24:04 <shachaf> Serdar: Rewriting filter?
12:24:47 <Serdar> jap I must do it
12:25:41 <shachaf> Serdar: Why?
12:27:18 <Serdar> shachaf, because it's the task
12:27:52 <shachaf> Serdar: Oh, there's nothing wrong with filter the regular filter, you're just rewriting it?
12:27:55 <shachaf> Serdar: OK.
12:31:07 <shapr> Dude, I am SO not strict.
12:32:26 <opqdonut> shapr: i'm so lazy :(
12:34:19 <Serdar> > :t filter
12:34:19 <lambdabot>  Parse error
12:34:25 <Serdar> hm
12:34:31 <shachaf> @ty filter
12:34:39 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
12:35:08 <shachaf> Serdar: Lambdabot's > isn't a ghci prompt, it's an expression evaluator.
12:35:27 <Serdar> filter2 :: (a -> Bool) -> [a] -> [a] that's correct then
12:36:13 <Serdar> hmm
12:40:18 <Serdar>       Expected type: Bool -> Bool
12:40:53 <Serdar> why he expect that If I have defined like above?
12:42:08 <shachaf> Serdar: You'll have to give some more context.
12:42:28 <shachaf> Serdar: How are you calling it?
12:42:50 <Serdar> this problem arrieves at loading
12:45:46 <Serdar> aah
12:50:08 <Serdar> I tried (fkt a) : that was wrong
12:50:41 <Serdar> I think I need a If then else part
12:52:03 <chessguy> dangit, i need something that's not quite a takeWhile
12:52:08 <chessguy> @src takeWhile
12:52:08 <lambdabot> takeWhile _ []                 =  []
12:52:08 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
12:52:08 <lambdabot>                    | otherwise =  []
12:52:57 <chessguy> @type takeWhile
12:52:59 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
12:53:21 <Serdar> ahh great, it works
12:54:55 <MarcWeber> shapr: If you still have your patches haskellcafe is now the right place to put them.
12:57:47 <chessguy> hmm, that was way easier than it should have been
12:57:50 <chessguy> takeWhile' :: (a -> Bool) -> (a -> Bool) -> [a] -> [a]
12:57:50 <chessguy> takeWhile' _ _ [] = []
12:57:50 <chessguy> takeWhile' p p' (x:xs) | p  x = x : takeWhile' p p' xs
12:57:50 <chessguy> takeWhile' p p' (x:xs) | p' x      = [x]
12:57:50 <chessguy> takeWhile' p p' (x:xs) | otherwise = []
12:59:27 <chessguy> @hoogle (a -> Bool) -> (a -> Bool) -> [a] -> [a]
12:59:28 <lambdabot> No matches, try a more general search
13:00:48 <kpreid> what's that useful for?
13:01:21 <chessguy> kpreid, chess :)
13:01:40 <chessguy> kpreid, consider generating legal moves for, say, a bishop
13:01:44 <opqdonut> p' is the ending condition?
13:02:09 <chessguy> p' in this case would be a way to tell if a square has an opponent's piece on it
13:02:46 <Baughn> :t takeWhile
13:02:48 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
13:03:19 <chessguy> p is whether or not a piece is on the square
13:03:22 <chessguy> at all
13:05:23 <opqdonut> takeWhile' p p' list = (\(a,b) -> a++head b) $ break p' $ takeWhile p list
13:05:36 <opqdonut> dunno if that's better, but it's more idiomatic
13:05:53 <opqdonut> ?pl (\(a,b) -> a++head b) $ break p' $ takeWhile p list
13:05:54 <lambdabot> uncurry ((. head) . (++)) (break p' (takeWhile p list))
13:06:01 <chessguy> hmm. is it more efficient?
13:06:13 <opqdonut> ?pl \p p' list -> (\(a,b) -> a++head b) $ break p' $ takeWhile p list
13:06:13 <lambdabot> ((uncurry ((. head) . (++)) .) .) . flip ((.) . break) . takeWhile
13:06:20 <opqdonut> chessguy: should be about as efficient
13:06:23 <opqdonut> due to laziness
13:06:52 <opqdonut> tail b is not evaluated for example
13:09:56 <DRMacIver> It's been occurring to me recently that lazy evaluation is really a form of side effect. :)
13:09:56 <chessguy> tail b?
13:10:40 <opqdonut> chessguy: all the other elements in b except the first one
13:10:50 <opqdonut> "the tail of b" might've been clearer
13:10:56 <conal> DRMacIver: do you mean has the semantics of a side-effect, or is implemented via a side-effect?  or something else?
13:11:02 <DRMacIver> It has a lot of the same symptoms in terms of preventing sharing an unpredictable behaviour, it's just that the side effects are mostly constrained to space usage.
13:11:10 <chessguy> yeah, but i don't get your point. when would tail b be evaluated
13:11:11 <DRMacIver> s/an/and
13:12:30 <Korollary> That's not a side effect
13:12:33 <opqdonut> chessguy: well, tail b not getting evaluated is the main reason for that being as efficient as your version
13:12:57 <DRMacIver> Korollary: If it quacks like a duck...
13:13:06 <Korollary> I don't argue with analogies
13:13:12 <chessguy> but...it doesn't get evaluated in my version either. i don't get it
13:13:43 <Korollary> http://en.wikipedia.org/wiki/Side_effect_%28computer_science%29
13:13:45 <opqdonut> chessguy: yes, exactly.
13:14:04 <opqdonut> chessguy: in a strict language the whole of b would be evalled
13:14:08 <DRMacIver> Korollary: Ok. Pretend I said "Lazy evaluation is a fnord. Fnords have many of the same symptoms as side effects."
13:14:10 <opqdonut> and my version would be slower
13:14:48 <opqdonut> DRMacIver: i'm still not getting you
13:14:51 <SamB> DRMacIver: but some different ones two
13:15:50 <DRMacIver> SamB: Hm. Fewer, certainly. I don't see "different" given the obvious trivial embedding of lazy evaluation in side effects + strict evaluation.
13:15:54 <SamB> opqdonut: some of the symptoms that they share are the big-Os on certain things
13:16:26 <opqdonut> SamB: an example?
13:16:29 <SamB> well, with side effects intsead of laziness I think it's easier to see when something will happen
13:16:53 <SamB> but with laziness insetad of side effects you never have to worry about something mutating the wrong thing
13:17:17 <DRMacIver> SamB: But you do have to worry about something evaluating the wrong thing and hanging onto it.
13:17:24 <DRMacIver> And your hanging onto it.
13:17:32 <SamB> yeah.
13:17:40 <SamB> but you can *profile* that, you can't profile bugs
13:17:45 <DRMacIver> Sure.
13:17:54 <opqdonut> :9
13:18:10 * shapr tries ticky ticky profiling on the nearest list of airline passengers.
13:18:11 <DRMacIver> It's a very managable effect. :) I'm not saying "Lazy evaluation has all the problems of unrestricted side effects". That would be a silly thing to claim.
13:18:53 <shapr> @remember SamB but you can *profile* that, you can't profile bugs
13:18:54 <lambdabot> Done.
13:19:16 <DRMacIver> But a lot of the difficulties of reasoning about features of lazy evaluated programs are in some sense the difficulties of reasoning about side effects in disguise.
13:19:19 <Baughn> DRMacIver: I find that lazy evaluation almost always does the smart thing. My only issues are when it's smarter than expected. ;)
13:19:55 <shapr> DRMacIver: Can you expand on that?
13:20:42 <DRMacIver> shapr: Possibly not very well. I've not thought this through clearly. :) I'll try though.
13:21:13 <DRMacIver> Baughn: It does the smart thing when all you care about is the correct termination of your program. When you have to worry about performance metrics it suddenly becomes less smart.
13:22:23 <DRMacIver> The problem is that although you cannot see mutation from within the program, in the 'real world' mutation occurs. This only changes the internal state of the terms, but this can have drastic effects on program performance because it affects the size in memory of data structures.
13:22:46 <DRMacIver> e.g. you can't do CSE for much the same reason you couldn't do CSE on mutable structures.
13:22:59 <opqdonut> well in stream programming you can get deadlocks if you don't reason the laziness
13:23:13 <DRMacIver> (fix (1:), fix (1:)) is not the same as let x = fix (1:) in (x, x) in a lot of cases.
13:23:29 <opqdonut> true
13:23:32 <DRMacIver> (Well, it's not the same. But it doesn't behave the same if you look at memory usage)
13:24:41 <SamB> hmm, can a cabal package re-export modules exported by other packages?
13:24:51 <Igloo> Nope
13:25:15 <DRMacIver> And trying to analyse the performance of heavily lazy code means you need to start reasoning about exactly when and what gets evaluated, which bears a lot of resemblance to trying to track the effects of the code as it runs.
13:25:34 <SamB> Igloo: aww.
13:26:08 <DRMacIver> Anyway, this isn't supposed to be some shocking revelation or an indictment of lazy evaluation.
13:26:20 <SamB> I was gonna make a microbase package for Jhc, that basically only had the Foreign and Jhc trees in it...
13:26:33 <SamB> Igloo: why not?
13:27:12 <Igloo> No reason, it just hasn't been defined or implemented
13:27:16 <SamB> ah.
13:27:27 <ihope_> Can @src give the implementation of a value for a certain instance of a class?
13:27:33 <Igloo> No technical reason, that is
13:29:08 <Saizan> @src [] mzero
13:29:08 <lambdabot> mzero = []
13:33:10 <Serdar> did I am thinking wrong?
13:33:22 <Serdar> map f x <=> map3 f x = foldr f [] x
13:33:57 <monochrom> Who is map3?
13:34:28 <Serdar> I should rewrite map with useing foldr
13:34:37 <monochrom> map f x = foldr (\x ys -> f x : ys) [] x.
13:35:03 <monochrom> @pl \x ys -> f x : ys
13:35:03 <Serdar> wait wait
13:35:03 <lambdabot> (:) . f
13:35:19 <monochrom> @src foldr
13:35:19 <lambdabot> foldr k z xs = go xs
13:35:19 <lambdabot>     where go []     = z
13:35:19 <lambdabot>           go (y:ys) = y `k` go ys
13:35:26 <monochrom> @src map
13:35:27 <lambdabot> map _ []     = []
13:35:27 <lambdabot> map f (x:xs) = f x : map f xs
13:35:33 <Serdar> oh
13:35:40 <monochrom> Nevermind my latest @src queries.
13:35:48 <Serdar> this foldr is not equal as mine
13:35:51 <Cale> hello
13:36:08 <Serdar> foldr f z [] = z
13:36:09 <Cale> Serdar: that foldr is sort of a hack to get GHC to compile it better.
13:36:33 <Serdar> args
13:36:34 <monochrom> > foldr (\x ys -> x+1 : ys) [] [1,2,3,4]
13:36:36 <lambdabot>  [2,3,4,5]
13:36:58 <Cale> > let map f = foldr ((:) . f) [] in map (+1) [1..4]
13:36:59 <lambdabot>  [2,3,4,5]
13:37:23 <Serdar> foldr fkt st [] = st
13:37:23 <Serdar> foldr fkt st (h:t) = fkt h (foldr fkt st t)
13:37:34 <Serdar> is that the same foldr?
13:37:35 <Cale> yeah
13:37:37 <monochrom> That is equivalent.
13:37:42 <Serdar> hmmm
13:38:05 <monochrom> You can't just compare program text letter by letter.
13:38:05 <Serdar> there stand it not easy to understand for beginner
13:38:14 <Cale> The way to think about foldr f z is that it goes through the list and structurally replaces each (:) with f and the [] with z
13:38:19 <Serdar> what was \x? a lambda function?
13:38:23 <Cale> yeah
13:38:24 <monochrom> Yes.
13:38:43 <monochrom> (\x y -> ...x...y...) 1 2 = ...1...2...
13:38:47 <Serdar> let me think about it
13:38:59 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
13:39:00 <lambdabot> Title: Fold Diagrams - CaleWiki
13:39:10 <Cale> there are some diagrams which might help to understand the transformation
13:39:30 <Serdar> lambdabot has a html parser?
13:39:41 <Cale> A little bit of one.
13:39:56 <monochrom> Very few things are easy to understand for beginners.
13:41:08 <ricky_clarkson> I was talking to dibblego, who says that Haskell is easy to learn for beginners.
13:41:38 <ricky_clarkson> I disagreed, based on the fact that you need to graduate from being a beginner or have your hand held to get started.
13:41:53 <monochrom> I don't believe in beginners.
13:41:57 <ricky_clarkson> [beginner to programming, not Haskell in particular]
13:41:59 <Cale> I think it depends heavily on your background. While you don't really need to know very much mathematics to use Haskell, being mathematically minded helps quite a lot.
13:42:12 <Cale> Being a beginner to programming actually sometimes helps.
13:42:22 <Serdar> I am thinking imperative :
13:42:25 <Serdar> :/
13:42:29 <Cale> Teaching Haskell to 11 year old kids is easy.
13:42:29 <monochrom> An axiomatic mind helps.
13:42:41 <ricky_clarkson> dibblego is teaching it to his 6-year-old.
13:42:55 <ihope_> I think I knew some Pascal at about that age.
13:43:01 <Serdar> lambda is hard to understand
13:43:27 <ihope_> Stuff like "\x -> x + 3"?
13:43:35 <Cale> Yeah, if your brain hasn't already been squashed into an imperative mold, it's about as easy as learning your first programming language.
13:43:35 <ricky_clarkson> I've explained lambdas, using Lisp syntax, to a non-technical girlfriend, and there was no problem.
13:43:43 <Cale> (regardless of what that was)
13:43:51 <kowey> alligator eggs? (lambdas)
13:43:56 <thorat> Cale: I agree.  The imperative languages made us unlearn mathematics.
13:44:03 <Serdar> yes, is that the same like let x = x+1?
13:44:14 <Cale> Serdar: not quite
13:44:29 <Cale> Serdar: (\x -> x + 1) is the function which takes a parameter and adds one to it.
13:44:32 <ihope_> "\x -> x + 3" is a function that adds 3 to its argument.
13:44:35 <mgsloan> the stuff on the left side defines the parameters
13:44:42 <ihope_> (\x -> x + 3) foo === foo + 3
13:44:43 <Cale> > (\x -> x + 1) 5
13:44:44 <mgsloan> or names them, rather
13:44:48 <monochrom> I mean this. A rule-driven or inference-driven mind learns Haskell quickly. An intuition-driven or feeling-driven mind doesn't.
13:44:50 <Serdar> and \x is not the same x?
13:44:51 <lambdabot>  6
13:44:58 <Cale> lambdabot is slow right now :)
13:45:05 <thorat> I think the only reason continuations are hard is Java.
13:45:14 <mgsloan> \ really should be a lambda symbol, if we could type it.  it begins the lambda expression
13:45:20 <ricky_clarkson> Learning imperative first focuses on side-effects.  Side effects are easy to get people interested in.
13:45:26 <Cale> Serdar: \ was chosen to look like Î»
13:45:33 <Cale> It's just a delimiter.
13:45:38 <Cale> \ ... -> ...
13:45:39 <ihope_> Serdar: it's the same x. The x in \x specifies what to use on the other side to represent the argument.
13:45:42 <Serdar> the x does not matter?
13:45:45 <ricky_clarkson> mgsloan: While I found it ugly at first, I don't mind the whole word lambda.
13:45:47 <Serdar> ahh k
13:45:48 <Cale> \ <parameters> -> <result>
13:45:53 <ihope_> (\y -> y + 3) is exactly the same.
13:46:10 <thorat> and \lambda was chosen to look like /\ by a typesetter :)
13:46:17 <mgsloan> ricky_clarkson: yeah, the term 'anonymous function' is probably better
13:46:21 <ihope_> (\x -> x^2 + 3*x) 5 === 5^2 + 3*5
13:46:45 <ricky_clarkson> JavaScript just uses 'function' for that, and it seems to make sense.
13:46:54 <Cale> Eventually, we should support Greek letters directly in source code :)
13:47:05 <ihope_> Î»
13:47:05 <mgsloan> part of haskell, and mathematics is learning to not fear funny sounding things
13:47:09 <ihope_> Yup, I can type Greek.
13:47:12 <bos> Cale: ghc already does
13:47:29 <Cale> bos: In 6.7, right?
13:47:40 <sjanssen> Î», however, is treated as an alphabetic character
13:47:54 <ricky_clarkson> I find it difficult to read papers written in terms of Greek symbols.
13:48:15 <bos> Cale: afaik, even in 6.4
13:48:18 * ihope_ ponders a variable monad
13:48:24 <mgsloan> takes getting used to
13:48:26 <ricky_clarkson> I can cope with a few, those that seem important, like lambda and sigma.
13:48:28 <monochrom> Side effects are easy to get intuition-driven minds interested in. Rule-driven minds are indifferent; they probably even eliminate side effects by "world -> world" and its all rules again.
13:48:48 <ricky_clarkson> monochrom: I expect most people think in both ways.
13:48:53 <Cale> You can often tell how much mathematics a person who doesn't know Greek knows by looking at how good their handwritten Î¾ looks.
13:49:17 <Saizan> it's a pain to write that!
13:49:39 <Cale> It's not that bad, it just takes practice :)
13:49:54 <Cale> Probably the hardest Greek letter to commit to muscle memory :)
13:50:23 <monochrom> ricky_clarkson: There seems to be something in the culture that discourages rule-driven thinking.
13:50:27 <ricky_clarkson> I find & hard enough.
13:50:42 <ricky_clarkson> monochrom: Which culture?
13:50:53 <pastorn> is there any way to run haskell code on beos?
13:50:56 <monochrom> Our culture.
13:51:14 <ricky_clarkson> Western, programming, American, English, or what?
13:51:15 <mgsloan> I dunno, I think its more than culture
13:51:21 <monochrom> All of them.
13:51:23 <bos> i'll see you that and raise you a Ò
13:51:27 <mgsloan> humans are naturally good at imperative planning
13:51:38 <Cale> pastorn: that's a good question, I have no idea.
13:51:55 <Cale> pastorn: You might be able to port hugs relatively easily.
13:52:06 <DRMacIver> Hi ricky_clarkson
13:52:08 <pastorn> hs2c to bootstrap?
13:52:14 <DRMacIver> Another ##java refugee here I see. :)
13:52:15 <ricky_clarkson> DRMacIver: Hello.
13:52:24 <Serdar> grml
13:52:34 <ricky_clarkson> DRMacIver: I haven't been there for over a year.
13:52:37 <Serdar> I crushed my head now
13:52:46 <Cale> Serdar: having trouble?
13:53:06 <Serdar> this lambda stuff
13:53:12 <ricky_clarkson> DRMacIver: I'm mainly using Java and Lisp at the moment, but dibblego recommended here for reasonable discussion about PL theory.
13:53:13 <DRMacIver> Yeah, I've noticed.
13:53:28 <DRMacIver> (That you've not been there in over a year)
13:53:40 <ricky_clarkson> Oh, that's odd, because I don't recognise your nick.
13:53:52 <Cale> Serdar: Lambdas are just functions which don't have names.
13:53:54 <DRMacIver> Hm. I'm sortof intrigued at the notion of dibblego involved in a reasonable discussion. :)
13:54:00 <Cale> Serdar: Suppose you write  f x = x + 1
13:54:10 <Cale> Serdar: You could also write  f = \x -> x + 1
13:54:11 <DRMacIver> I probably hadn't been there for very long when you left.
13:54:30 <Cale> (modulo some annoying technical rules in Haskell regarding polymorphism)
13:54:37 <mgsloan> hehe, monomorphism
13:55:00 <ricky_clarkson> DRMacIver: Are you receiving your opinions from a ##java op?
13:55:02 <Cale> We'll assume -fno-monomorphism-restriction then :)
13:55:17 <DRMacIver> ricky_clarkson: Which ones?
13:55:20 <mgsloan> can you set that as default somewhere in ghc?
13:55:24 <ricky_clarkson> About dibblego.
13:55:24 * Cale shakes his fist at the MR
13:55:31 <monochrom> But this is unproblematic.  "let f x = x+1 in map f [1,2,3]" = "map (\x -> x+1) [1,2,3]"
13:55:34 <DRMacIver> ricky_clarkson: No, I'm receiving them from having talked to him. :)
13:55:46 <SamB> DRMacIver: does that mean you are recieving *some* of your opinions form a ##java op?
13:55:51 <Cale> right
13:56:02 <ricky_clarkson> He and I have useful discussions sometimes.  He usually infuriates me and makes me think.
13:56:02 <SamB> s/form/from/
13:56:10 <Cale> Serdar: does what monochrom wrote make some sense?
13:56:18 <monochrom> In Perl it's "sub ... something rather"
13:56:27 <DRMacIver> SamB: I have opinions on Java which have certainly originated from ##java ops. Some of them are even not the result of my saying "No, you're wrong!" to said op.
13:56:40 <Cale> Serdar: it saves you from having to give a name to the function which you want to use, and instead, you can write the code for it in-place.
13:57:12 <mgsloan> I don't know why, but I've never liked java, yet was fairly taken with C#
13:57:29 <Serdar> don't know how to say, I understand all of that, but if I want to use it, it does not make sence
13:57:33 <DRMacIver> ricky_clarkson: I don't deny that conversations with dibblego can be both useful and interesting. I'm skeptical that they can be rational. :)
13:57:45 <ricky_clarkson> For me, Java was a bit like C++ with less ridiculous compile errors.
13:57:48 <Cale> > (\x y -> x^2 + y^2) 3 4
13:57:53 <lambdabot>  25
13:58:13 <ricky_clarkson> ..now it's just a pretty poor mandatory type system with a reasonable set of APIs.
13:58:30 <monochrom> A thing makes sense iff you practice it.
13:58:33 <mgsloan> ah, well, I'd rather just use C++ in that case.  If you're going to write in a C++ style, might as well do the real deal
13:58:49 <ricky_clarkson> C++ has nothing similar to lambdas afaik.
13:59:00 <DRMacIver> At least not without Boost.
13:59:03 <ricky_clarkson> C++0x on the other hand..
13:59:32 <mgsloan> yeah, higher order functions would be nice
13:59:58 <mgsloan> There are 'functors' (In c++ land, function objects) but eh, kinda nasty to use
14:00:13 <monochrom> Higher order functions take away the mystism surrounding callbacks.
14:00:20 <ihope_> Serdar: well, you know how often functions in Haskell will take functions as arguments.
14:00:23 <Serdar> in example: map3 f (a:x) = foldr ( \f a -> map3 f x) [] (a:x)
14:00:38 <ricky_clarkson> ihope_: That just seems so natural.
14:00:40 <Serdar> this stuff between ( ) does not make sence
14:00:54 <Serdar> f must be a function
14:00:57 <Cale> > map (\x -> x^2) [1..10]
14:01:01 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
14:01:02 <sjanssen> Serdar: that doesn't look correct
14:01:10 <Cale> Serdar: does looking at that help?
14:01:17 <ihope_> Serdar: where was that example?
14:01:19 <Cale> > map (\x -> (x,x^2)) [1..10]
14:01:21 <lambdabot>  [(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]
14:01:24 <monochrom> map3 f (a:x) = foldr ( \f a -> map3 f x) [] (a:x)  is terribly wrong.
14:01:30 <chessguy|> sigh
14:01:48 <chessguy|> there are way too many of me in here
14:02:08 <monochrom> kill -a chessguy
14:02:10 <Serdar> I know that I know that!!
14:02:16 <DRMacIver> chessguy|: You should start a game with yourself. Hm. But which one to choose? :)
14:02:23 <sjanssen> @type let map3 f xs = foldr (\y ys -> f y : ys) [] xs in map3
14:02:24 <lambdabot> forall a a1. (a -> a1) -> [a] -> [a1]
14:02:29 <chessguy> @seen chessguy|
14:02:30 <ihope_> Well, lambdas are useful whenever you want to give a function a very simple function without defining that very simple function in another declaration...
14:02:30 <lambdabot> chessguy| has changed nick to chessguy.
14:02:30 <lambdabot> You are in #haskell-icfp07 and #haskell. I last heard you speak just now.
14:02:36 <Serdar> but don't understand why
14:02:39 <Cale> Serdar: does that map (\x -> (x,x^2)) [1..10] make sense?
14:02:42 <Serdar> that f ix a function
14:02:50 <ihope_> Serdar: you don't understand why what?
14:03:11 <ricky_clarkson> Lambdas are useful in escaping the tendency of programming languages to force names on things.
14:03:15 <mgsloan> f is just a variable
14:03:20 <Cale> It applies the function \x -> (x,x^2) to each of the elements of the list [1..10], giving a list of results.
14:03:21 <monochrom> Yeah, try to say your complete thought in one line.
14:03:23 <ricky_clarkson> If I want to use something twice I must name it or pass a reference to it.
14:03:23 <mgsloan> bit it takes a function as its parameter
14:03:50 <Serdar> okay I think again
14:04:07 <ricky_clarkson> It's like there's gravity pulling code to the left margin.  I'd like an environment in which snippets of code can be reused without names.
14:04:31 <Cale> Serdar: try evaluating (\x -> (x,x^2)) 5 on your own, what do you get?
14:04:38 <Serdar> map3 f (a:x) = foldr (...) [] (a:x) seems correct for me
14:04:59 <Serdar> now I must understand this ...
14:04:59 <sjanssen> Serdar: the problem is the stuff you put in the ...
14:05:06 * ihope_ ponders
14:05:08 <monochrom> ok, but why not map3 f x = foldr (...) [] x.
14:05:33 <Serdar> monochrom, I think I need the head in ...
14:05:37 <Cale> Let's take another route.
14:05:51 <Serdar> map2 x (a:y) = x a : map2 x y <-- that's my map2
14:05:51 <monochrom> > foldr undefined [] []
14:05:53 <lambdabot>  []
14:05:56 <Cale> Let's look at some simple functions and derive foldr from them, and then look at this problem again.
14:06:02 <monochrom> You don't even get to the (...)
14:06:30 <Cale> Consider the problem of summing up all the elements of a list.
14:06:36 <ihope_> What's map3 supposed to do, anyway?
14:06:41 <Cale> You might write it like this:
14:06:45 <Cale> sum [] = 0
14:06:50 <Cale> sum (x:xs) = x + sum xs
14:06:56 <monochrom> "implement map using foldr. call it map3 to avoid name clash."
14:07:23 <Cale> The sum of the empty list is 0, and the sum of the list whose head is x and tail is xs is x plus the sum of xs.
14:07:35 <Cale> Now consider multiplying the elements of a list
14:07:39 <Cale> product [] = 1
14:07:47 <Cale> product (x:xs) = x * product xs
14:07:52 <monochrom> Note that clearly the original asker did not ask in the same great clarity as quoted. :)
14:07:59 <Cale> this looks very very similar to the code for sum
14:08:06 <Cale> Only two things have changed
14:08:11 <Cale> The 0 has become a 1
14:08:18 <Cale> and the (+) has become a (*)
14:08:44 <Serdar> > (\f -> f*f) [1..4]
14:08:45 <lambdabot>   add an instance declaration for (Num [t])
14:08:45 <lambdabot>     In the expression: f * f
14:08:45 <lambdabot>     ...
14:09:00 <Cale> > map (\f -> f*f) [1..4]
14:09:01 <lambdabot>  [1,4,9,16]
14:09:07 <monochrom> (\f -> f*f) [1..4] is wrong. Please pay 100% attention to Cale first.
14:09:12 <Cale> > (\f -> f*f) 4
14:09:14 <monochrom> Actually make it 110%.
14:09:14 <lambdabot>  16
14:09:44 <chessguy> @type (\f -> f*f)
14:09:46 <lambdabot> forall a. (Num a) => a -> a
14:09:51 <Cale> Have you read the code for sum and product I wrote above?
14:09:57 <Serdar> ahh, I see
14:10:06 <Cale> You ought to be comfortable with that before I go on
14:10:57 <Cale> foldr is what you get when you try to capture the common structure of the 'sum' and 'product' functions I wrote above.
14:11:14 <chessguy> so here i am, thinking about monads again. this time it's in terms of chess. i'm thinking that if i have a data structure that represents a board, and i want to be able to chain together multiple actions on the same board, then i want to use State Board, right?
14:11:15 <Cale> Adding parameters for the two parts which changed between them.
14:11:25 <Serdar> (\x y -> x^2 + y^2) 3 4 <-- why that and not (\x \y -> x^2 + y^2) 3 4?
14:11:32 <Cale> chessguy: sure, that'd work
14:11:35 <sjanssen> chessguy: do these functions modify the board?
14:11:40 <Cale> Serdar: it's a shorthand
14:11:42 <chessguy> sjanssen, sure
14:11:49 <monochrom> \x -> \y -> x^2 + y^2
14:11:50 <Cale> You could also write (\x -> \y -> x^2 + y^2)
14:11:55 <chessguy> at least potentially
14:11:56 <sjanssen> chessguy: yes, this is what the State monad is for :)
14:12:03 <chessguy> ok, i got that much
14:12:05 <chessguy> but
14:12:06 <Cale> Which means (\x -> (\y -> x^2 + y^2))
14:12:15 <Cale> (\x -> (\y -> x^2 + y^2)) 3 4
14:12:20 <chessguy> when would i want to make my own monad Board then?
14:12:23 <Cale> = (\y -> 3^2 + y^2) 4
14:12:31 <Cale> = 3^2 + 4^2
14:12:37 <Serdar> \x y is equal to \x -> \y am I right?
14:12:38 <Cale> = 9 + 16
14:12:38 <sjanssen> chessguy: you probably wouldn't want to
14:12:40 <Cale> = 25
14:12:59 <ihope_> Serdar: pretty much, but it's sort of better to say \x y -> is equal to \x -> \y ->.
14:13:15 <chessguy> sjanssen, why not?
14:13:28 <Serdar> hmm okay
14:13:29 <Cale> Or (\x y -> z) = (\x -> \y -> z)
14:13:35 <monochrom> chessguy finally considers monads of chess, for his namesake. :)
14:13:38 <sjanssen> chessguy: you might consider making 'newtype ChessSim a = ChessSim (State Board a)', just to have a shorthand for stateful board manipulations
14:14:04 <Cale> chessguy: Have a close look at my Sudoku solver :)
14:14:09 <Serdar> wait is that the same like x(y(z)) or (x Â° y)(z)?
14:14:11 <ihope_> Can you say anything like "newtype Foo = Foo Bar deriving everything"? :-)
14:14:13 <chessguy> ChessSim?
14:14:15 <sjanssen> chessguy: Monads are schemes of computation, I can't think of a model where 'Board' is a scheme of computation
14:14:17 <chessguy> Simulator?
14:14:26 <ihope_> Serdar: \x y -> is currying.
14:14:29 <Cale> Serdar: not really, it's just a shorthand syntax which you're allowed.
14:14:48 <int-e> sjanssen: why not? you can compute the result of a sequence of moves
14:14:55 <chessguy> @where cale
14:14:55 <lambdabot> I know nothing about cale.
14:14:58 <Cale> You can imagine that the compiler converts one into the other automatically.
14:14:59 <monochrom> Many cellular automaton boards are schemes of computation.
14:15:00 <chessguy> @where calewiki
14:15:00 <lambdabot> I know nothing about calewiki.
14:15:07 <Philippa> int-e: that would suggest that the monad is "Game", though
14:15:15 <Cale> @where+ calewiki http://cale.yi.org/index.php/Main_Page
14:15:15 <Philippa> or perhaps "Play"
14:15:15 <lambdabot> Done.
14:15:31 <Cale> @where Sudoku
14:15:32 <lambdabot> I know nothing about sudoku.
14:15:33 <int-e> Philippa: yes maybe
14:15:34 <chessguy> sjanssen, ok, so then when might i want to use a monad transformer on a State Board
14:15:39 <Cale> @where+ Sudoku http://www.haskell.org/haskellwiki/Sudoku
14:15:39 <lambdabot> Done.
14:15:48 <sjanssen> chessguy: when you need additional capabilities
14:16:05 <chessguy> whoah, calewiki has a new look
14:16:12 <Cale> yeah
14:16:21 <monochrom> You can add a backtracking transformer.
14:16:24 <Cale> It's still MediaWiki though :)
14:16:25 <sjanssen> chessguy: say you need to also log some data as you're modifying the board, use WriterT LogMessage (State Board))
14:16:36 <chessguy> what's LogMessage?
14:16:37 <Cale> Serdar: so does lambda make more sense?
14:17:03 <sjanssen> chessguy: whatever you want, could be String or something
14:17:16 <Serdar> Cale,  I am reading about currying
14:17:31 <chessguy> oh, you mean the data structure i'm logging the messages to
14:17:38 <sjanssen> chessguy: correct
14:17:43 <Cale> Serdar: all functions in Haskell are curried
14:18:05 <Cale> Which just means that we don't really have a separate notion of multiparameter functions.
14:18:37 <Cale> A multiparameter function is just one which takes one parameter and returns a function that's willing to take the rest.
14:18:49 <sorear> re.
14:19:16 <Cale> > let f x y = x^2 + y^2 in map (f 5) [1..10]
14:19:24 <lambdabot>  [26,29,34,41,50,61,74,89,106,125]
14:19:26 <sjanssen> Serdar: currying just means that functions of many arguments are written '\x y z... -> ...' instead of '\(x, y, z...) -> ...'
14:19:31 <mgsloan> well, currying is usual style.  traditional function calling can be expressed with tuples
14:19:34 <Serdar> (\x -> x + 1) y is replaceing x with y right?
14:19:35 <mgsloan> yeah
14:20:12 <Cale> > (\x -> x + 1) 5
14:20:14 <lambdabot>  6
14:20:17 <Cale> > (\x -> x + 1) 6
14:20:19 <Baughn> mgsloan: Though functions like curry/uncurry are handy, it doesn't really change anything since there's no partial evaluation
14:20:20 <lambdabot>  7
14:20:33 <Baughn> Except when the programmer inserts it by hand, anyhow
14:21:17 <Cale> mgsloan: But functions that take tuples are again single parameter functions which just happen to take tuple data structures as their argument :)
14:21:37 <chessguy> so if i had some functions that were guaranteed to only read from the board, i really ought to make them work in the Reader monad?
14:21:42 <Cale> Of course, it's usually the same in mathematics.
14:21:48 <monochrom> \(x,y,z) (p,q,r) -> x+p
14:21:49 <Serdar> okay I understand currying and lambda
14:21:57 <Cale> Serdar: great :)
14:22:07 <monochrom> chessguy: seems so.
14:22:11 <mgsloan> Cale - of course, but that's how functions work in other languages
14:22:16 <Serdar> monochrom, \(x,y,z)?
14:22:20 <Cale> mgsloan: not quite
14:22:31 <monochrom> Don't worry about that yet, Serdar.
14:22:40 <chessguy> but what if i wanted to chain together a function which only reads from the board with a function that both reads and writes
14:22:43 <Serdar> is that the same \x -> \y -> \z->?
14:22:44 <mgsloan> well, maybe they don't explicitly talk about the tuple they're passing
14:22:47 <monochrom> No.
14:22:48 <Cale> mgsloan: Constructing (x,y) really builds a data structure with two pointers to its fields.
14:22:50 <mgsloan> but it is basically, i think
14:22:53 <monochrom> Don't learn too much in a day.
14:22:57 <Baughn> Cale: Ooh. I remember the week, just after learning C, when I was writing imperative, state-based math.
14:23:00 <Saizan> chessguy: you can make a MonadReader instance for your State monad
14:23:02 <ihope_> Serdar: (x,y,z) is a tuple, which is a single value containing the values of x, y and z.
14:23:08 <sjanssen> chessguy: you'd probably just make everything State, then
14:23:08 <mgsloan> Cale - well, that's one implementation
14:23:13 <Cale> mgsloan: sure
14:23:14 <ihope_> > (2+3, 2*3, 2^3)
14:23:15 <lambdabot>  (5,6,8)
14:23:43 <Saizan> chessguy: and have your read-only function of type MonadReader Board m =>
14:23:44 <Baughn> > map ($ 2 3) [(+),(*),(^)]
14:23:44 <Cale> mgsloan: There is something strange with laziness though :)  undefined isn't the same as (undefined, 5)
14:23:45 <lambdabot>   add an instance declaration for (Num (t -> a))
14:23:52 <Serdar>  (\(x,y,z) -> x+y+z) 2 , 3 , 4 <=> (2,3,4) = 9?!
14:24:15 <ihope_> Serdar: if it occurs in the left side of a lambda expression, it takes a tuple--say, (5,6,8)--and assigns x to 5, y to 6, and z to 8.
14:24:16 <mgsloan> Cale - ah yes, bottom throwing the wrench in the gears once again
14:24:30 <int-e> > map (($ 3) . ($ 2)) [(+),(*),(^)]
14:24:32 <chessguy> sjanssen, what do you mean make everything State?
14:24:33 <lambdabot>  [5,6,8]
14:24:34 <Cale> Also, usually in those languages you can't construct a tuple of parameters and then pass it to a function later.
14:24:51 <mgsloan> yeah. would be pretty cool, though
14:24:55 <Cale> yeah
14:25:01 <ihope_> (\(x,y,z) -> x+y+z) (2,3,4) assigns x to 2, y to 3 and z to 4, then returns 2+3+4.
14:25:05 <Baughn> > map ($ 2 (3 :: Integer)) [(+),(*),(^)]
14:25:07 <lambdabot>   add an instance declaration for (Num (Integer -> a))
14:25:11 <sjanssen> chessguy: if some functions only read, and some read and write, just make all of them State (ie. all of them able to read and write)
14:25:17 <mgsloan> sometimes you do things like that, like in the win32 api you construct a struct to represent the parameters for the window creation function
14:25:29 <Cale> > (\(x,y,z) -> x+y+z) (2,3,4)
14:25:32 <lambdabot>  9
14:25:34 <chessguy> ah, ok
14:25:36 <sjanssen> chessguy: unless you *really* need to formally show that some functions don't modify the board
14:25:37 <ihope_> Baughn: ($ 2 3) applies something to 2 3...
14:25:41 <int-e> > liftM3 id [(+),(*),(^)] [2] [3]
14:25:43 <lambdabot>  [5,6,8]
14:25:56 <chessguy> i don't necessarily
14:25:58 <Baughn> ihope_: Yep. I was hoping it'd apply +, ^ and * to them, but..
14:26:07 <Baughn> > map ($ 2 (3 :: Integer)) [(+),(*),(^)] :: [Integer]
14:26:08 <lambdabot>  Couldn't match expected type `Integer'
14:26:17 <monochrom> It hurts my feeling that other languages don't have anonymous tuples.
14:26:30 <Cale> Serdar: So, on with foldr?
14:26:30 <Baughn> monochrom: Erlang
14:26:37 <Saizan> ?type ($ 2 3)
14:26:37 <Serdar> > (\(x,y,z) -> x+y+z) 2,3,4
14:26:38 <lambdabot>  Parse error
14:26:39 <lambdabot> forall a b. (Num (Integer -> a)) => (a -> b) -> b
14:26:40 <glguy> > [(+)] `ap` [2,3] `ap` [3,4]
14:26:40 <Serdar> hmm
14:26:42 <lambdabot>  [5,6,6,7]
14:26:52 <Serdar> ahh
14:27:02 <Serdar> (..) is one replacement?
14:27:19 <Serdar> like a point in carthesis coords?
14:27:27 * Cale wonders which (..) Serdar is referring to
14:27:42 <Cale> Oh, (2,3,4)
14:27:53 <Cale> The parens to construct the tuple aren't optional.
14:27:53 * chessguy thinks of E4X when he sees (..)
14:27:53 <Serdar> (\(x,y,z) -> x+y+z) 2,3,4 <-- \(x,y,z)
14:27:54 <Heffalump> It hurts my feelings that Haskell doesn't have anonymous disjoint sums ;-)
14:28:13 <int-e> Heffalump: you make little type checkers cry
14:28:31 <Heffalump> they aren't hard to typecheck, surely?
14:28:42 <int-e> oh, I guess I meant inference really
14:28:46 <Heffalump> or even infer
14:28:55 <monochrom> "little" is the keyword
14:29:00 <ihope_> Serdar: yeah, it's pretty much one replacement.
14:29:03 <Cale> Heffalump: do you want subtype polymorphism?
14:29:05 <int-e> Inference is hard I think. Or trivial.
14:29:06 <ihope_> Setting (x,y) to (2,3).
14:29:15 <DRMacIver> Cale: Yes please. :)
14:29:18 <ihope_> Things like that.
14:29:24 <Heffalump> why do disjoint sums require subtype polymorphism?
14:29:40 <Cale> Well, I suppose it depends on what you mean by "anonymous disjoint sums"
14:29:41 <int-e> But in the trivial case you get into a "everything is a Icky Smelly Thing" universe.
14:29:44 <glguy> > fix $ ~(a,b,c) -> (b+1,c+1,1)
14:29:44 <lambdabot>  Parse error
14:29:48 <glguy> > fix $ \ ~(a,b,c) -> (b+1,c+1,1)
14:29:51 <lambdabot>  (3,2,1)
14:30:02 <monochrom> Anonymous disjoint sums require a naming convention for the data constructors.
14:30:04 <Cale> If you can write the type (X | Y | Z) and also the type (W | X), then what's the inferred type of X ?
14:30:30 <Heffalump> I mean with imaginary data constructors, as monochrom says.
14:30:36 <Heffalump> s/imaginary/implied/
14:30:42 <Heffalump> I dunno what the syntax would be.
14:31:08 <Cale> Perhaps you could just require type signatures.
14:31:17 <Cale> But that would get ugly rather quickly :)
14:33:08 <Cale> Or I suppose you could have a single type with infinitely many constructors.
14:33:16 <Cale> But that's cheap :)
14:33:34 <DRMacIver> Out of curiousity, what's the intended use case for this?
14:33:34 <monochrom> I propose Summand_1_of_3 :: a -> (c | a | b).  Thus if you write Summand_1_of_3 X, its inferred type is (c | X | b).
14:34:33 <mgsloan> would be nice to have lists [a | b]
14:34:52 <mgsloan> heterogeneous but constrained
14:35:03 <monochrom> Anyway you can draw inspiration from (,), (,,), (,,,), ... fst, snd, ...  and then just dualize.  Any "problem" or "solution" of anon sum type has a dual in anon product type.
14:36:34 <sorear> @botsnack
14:36:34 <lambdabot> :)
14:36:41 <Heffalump> DRMacIver: I've forgotten now :-) But I quite often find myself wanting it.
14:36:53 <DRMacIver> ok. :)
14:36:54 <Serdar> map3 f (a:x) = foldr (\y z -> f a : z ) [] x
14:36:56 <Heffalump> though to be fair, Left (Right x) isn't exactly hard to use.
14:37:03 <Serdar> is my las thought
14:37:18 <Serdar> but  it's wrong too
14:37:22 <sjanssen> Serdar: closer
14:37:40 <sjanssen> Serdar: you don't need to pattern match (a:x)
14:37:53 <monochrom> Have you tested it?
14:38:04 <quicksilver> Cale: the constructors would be like this (X||)
14:38:07 <int-e> monochrom: what's the dual of pattern matching?
14:38:08 <quicksilver> Cale: (||X)
14:38:10 <quicksilver> Cale: etc
14:38:11 <Serdar> yes I do, therfore I know it's wrong
14:38:14 <Cale> Serdar: let's go over this foldr thing, since I didn't get to finish that with you
14:38:15 <DRMacIver> I think I've wanted union and intersection types for a neat way of representing ad hoc overloading before (yes, I know that's what type classes are for :) )
14:38:32 <Cale> Let's look at sum and product again
14:38:34 <quicksilver> Cale: (||"foo") :: forall a b . (a|b|String)
14:38:40 <monochrom> try (\y z -> f y : z )
14:38:51 <Cale> sum [] = 0
14:38:57 <Cale> sum (x:xs) = x + sum xs
14:39:05 <Cale> product [] = 1
14:39:13 <Cale> product (x:xs) = x * product xs
14:39:26 <monochrom> int-e: I feel that the dual of pattern matching is value construction.
14:39:32 <int-e> monochrom: I suspect that to really dualize tuples you'd also have to reverse execution flow or something weird like that.
14:39:49 <Cale> So the bits which are changing are the 0 is swapped out for 1 and the (+) is swapped out for (*)
14:40:04 <Serdar> monochrom, \y will curried with []
14:40:04 <Philippa> int-e: you mean have what amounts to a specialised case construct as a deconstructor?
14:40:09 <Cale> Now, let's add parameters in order to generalise this
14:40:12 <int-e> Philippa: yep
14:40:21 <Cale> foldr f z [] = z
14:40:32 <quicksilver> int-e: I don't think it's that hard, is it?
14:40:40 <Philippa> int-e: no particular need for it, you've still got constructors and pattern matching
14:40:40 <Cale> foldr f z (x:xs) = x `f` foldr f z xs
14:40:51 <quicksilver> int-e: just use (| x) for Left, (x |) for Right
14:40:52 <Philippa> it won't make a difference semantically
14:40:52 <monochrom> I think quicksilver's syntax works perfectly.
14:40:54 <Cale> Serdar: see how that works?
14:41:00 <Cale> or if you want...
14:41:08 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
14:41:24 <Cale> So then: sum = foldr (+) 0
14:41:26 <Serdar> yes
14:41:27 <int-e> quicksilver: with tuples you can use them with the (a,b,c) notation in both construction and pattern matches. (||) would require 3 different names for that.
14:41:30 <Cale> and  product = foldr (*) 1
14:41:43 <Cale> Serdar: okay, now let's write map, but not in terms of foldr
14:41:48 <Cale> map f [] = []
14:41:58 <Cale> map f (x:xs) = f x : map f xs
14:42:00 <Serdar> foldr (*) 1 [1,2,3] testet that on paper
14:42:02 <int-e> quicksilver: and I'm wondering why, i.e. what arrow we'd have to turn around to get the symmetric equivalent of (,,)
14:42:33 <Serdar> Cale, my map2 looks like thaat
14:42:34 <int-e> or dual
14:42:45 <Cale> We see here that map applied to the empty list is just the empty list again, so if we can write map as foldr f z, then z = []
14:42:46 <Serdar> map2 x [] = []
14:42:46 <Serdar> map2 x (a:y) = x a : map2 x y
14:42:51 <Serdar> or it's the same
14:42:58 <Cale> Right?
14:43:06 <monochrom> case (|1|) of (x||) -> "First!"; (|x|) -> "Second!"; (||x) -> "Third!"
14:43:15 <Cale> Now, let's compare the non-empty cases
14:43:36 <Serdar> Cale, yes that's why I used [] as the first parameter
14:43:48 <int-e> quicksilver: and I suspect that it's the direction of data flow which makes this quite confusing :)
14:43:53 <monochrom> The number of |'s tells you how many summands there are in this sum type. The position of 1 or x tells you which summand you're interested in.
14:44:13 <Cale> We want to find g such that: map f (x:xs) = foldr g [] (x:xs)
14:44:16 <Cale> that is...
14:44:40 <Serdar> yes
14:44:45 <Cale> f x : map f xs = g x (foldr g z xs)
14:45:33 <dcoutts> @seen kfish
14:45:33 <lambdabot> I saw kfish leaving #haskell 7h 16m 19s ago, and .
14:45:55 <Serdar> Cale, wait gimme a minute
14:46:00 <dcoutts> @tell kfish my iconv code is at: darcs get http://haskell.org/~duncan/iconv/
14:46:00 <lambdabot> Consider it noted.
14:46:29 <dcoutts> dons: same for you, if you were interested in the iconv binding
14:46:37 <quicksilver> monochrom: yes, exactly
14:46:52 <chessguy_> Cale, so your Sudoku monad transforms Nondet by allowing stateful computations on top of it?
14:46:53 <quicksilver> monochrom: this has been proposed before, I don't rember who by
14:47:07 <quicksilver> monochrom: I remember thinking it would be neat, even if I wouldn't use it all that often
14:47:13 <ihope_> Hmm. Is x >>= f sort of like saying "apply f to x, except really it's x that decides what happens"?
14:47:16 <Cale> chessguy_: yes
14:47:29 <quicksilver> I agree completely with the earlier comment 'sometimes [a|b] would be handy'
14:47:31 <monochrom> Suppose Haskell did not provide (,).  You would just define data Pair2 a b = Pair2 a b.  It would even not be that terrible.  It's the same deal as Either.
14:47:38 <quicksilver> agreed
14:47:41 <chessguy> Cale, do you remember why you did it that way instead of the other way around?
14:47:59 <ihope_> If so, that might make explaining monads a lot easier :-)
14:48:06 <mauke> @index InvalidArgument
14:48:06 <lambdabot> bzzt
14:48:15 <Cale> chessguy: absolutely. I wanted the state to be rolled back when backtracking.
14:48:39 <mgsloan> yeah, I think the anonymous sums are most useful as parameters to data types ([a|b|c], etc)
14:48:48 <chessguy> hm. and you can't do that with the state as the inner monad
14:48:48 <chessguy> ?
14:49:00 <Serdar> Cale, is that z []?
14:49:06 <mauke> @source System.Directory
14:49:06 <lambdabot> http://darcs.haskell.org/packages/base/System/Directory.hs
14:49:09 <ihope_> Well, in x >>= f, x :: m a and f :: a -> m b, and since we don't know what a is, f has no say over the matter unless we extract an a from x.
14:49:27 <Cale> chessguy: NonDet transforming a State monad would give you something where state was preserved even when backtracking.
14:49:34 <Cale> Serdar: yes
14:49:42 <Cale> Serdar: that's what we've solved so far.
14:49:42 <mauke> wtf
14:49:46 <Serdar> Cale, okay, than I got that
14:49:53 <Cale> Serdar: I'm making up a little diagram which should help things along :)
14:50:15 <chessguy> hmm, i don't get why that is
14:50:37 <Cale> chessguy: You have to look carefully at the types to figure it out. It's not obvious.
14:50:41 <int-e> eek. a|b|c would have to have 3 different bottoms
14:50:45 <int-e> or 4?
14:50:49 <Saizan> ihope_: it's (>>=) that decides what happens, it's the outhermost function :)
14:50:58 <monochrom> There is always only one bottom.
14:51:19 <chessguy> @quote specific.bottom
14:51:19 <lambdabot> No quotes match. That's something I cannot allow to happen.
14:51:26 <chessguy> @quote bottom
14:51:26 <monochrom> Note that even with Either, Left _|_ and Right _|_ are not bottom.
14:51:26 <lambdabot> monochrom says: 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice.  Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.
14:51:26 <lambdabot> Licence to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
14:51:45 <monochrom> Heh heh heh!
14:52:55 <monochrom> Later I preferred the last one to be RealWorld# Is Not Enough. :)
14:52:57 <ihope_> Saizan: well, yes, that's true. :-)
14:54:01 <Serdar> Cale, f = g or am I wrong?
14:54:21 <ihope_> But if >>= hasn't looked at g, the only things it can do with f are seq it and pass it bottom.
14:54:44 <ihope_> Er, hasn't looked at x.
14:55:05 <Cale> Serdar: not quite -- the (:) has to come from somewhere
14:55:16 <oerjan> ihope_: not true for the Id monad
14:55:54 <monochrom> Consider x >>= const (return 0).  Here >>= is entitled to skip x.  In fact Control.Monad.State.Lazy does exactly that.
14:55:54 <ihope_> oerjan: that's the one where every value can be produced by return, isn't it?
14:56:03 <ihope_> (Except bottoms, of course.)
14:56:24 <oerjan> newtype Id a = Id a
14:56:34 <oerjan> @src Id return
14:56:34 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:56:55 <ihope_> monochrom: how does >>= know to ignore x?
14:57:15 <Cale> http://cale.yi.org/autoshare/foldr-map.png
14:57:20 <Cale> have a look at that
14:57:21 <ihope_> So Id x >>= f = Id (f x), right?
14:57:37 <ihope_> It's still pattern matching over the first argument.
14:57:40 <oerjan> Id x >>= f = f x
14:57:40 <DRMacIver> monochrom: I'm not sure I agree that it wouldn't be that terrible. :)
14:57:41 <Cale> It should help give some idea of what's got to happen :)
14:57:53 <ihope_> How about "depending on the monad, x has the final say in the matter"? :-)
14:57:59 <oerjan> no, newtypes give irrefutable patterns
14:58:04 <monochrom> Heheh, actually it doesn't. It just chains up x with const (return 0) using the most lazy way possible, i.e., a let binding. Then the rest sorts itself out using lazy evaluation.
14:58:05 <DRMacIver> monochrom: I've written code involving explicit things like Pair2, Pair3, etc. and it gets pretty nasty.
14:58:14 <Cale> Serdar: looking?
14:58:37 <monochrom> See the source code of Control.Monad.State.Lazy for details.
14:58:45 <ihope_> Er, right, just f x, not Id (f x).
14:58:51 <Serdar> Cale, yes I do gimme a minute
14:59:09 * ihope_ ponders
14:59:29 <ihope_> Since Id is a newtype constructor, is undefined the same as Id undefined?
14:59:35 <monochrom> Yes.
15:00:05 <ihope_> So there's one place newtype isn't the same as data...
15:00:31 <sorear> Two.
15:00:51 <sorear> @src State
15:00:51 <lambdabot> Source not found. Take a stress pill and think things over.
15:00:53 <ihope_> "There is" meaning "that is".
15:01:02 <int-e> 'pattern matching' bottom works with newtypes
15:01:25 <int-e> sorear: is that the second one you mean?
15:01:26 <monochrom> x >>= f expands to: \s -> let (a,s') = runState x s in runState (f a) s'.  You see how x becomes immaterial if f doesn't care about a or s', e.g., f = const (return 0).
15:01:30 <sorear> int-e: yes
15:01:30 <Cale> Serdar: does that diagram make some sense?
15:01:39 <monochrom> http://darcs.haskell.org/packages/mtl/Control/Monad/State/Lazy.hs
15:01:45 <oerjan> @todo+ Update @src with lots of modules it doesn't have
15:01:45 <lambdabot> Plugin `todo' failed with: IRCRaised @todo has no args, try @todo-add or @list todo
15:01:56 <oerjan> @todo-add Update @src with lots of modules it doesn't have
15:01:56 <lambdabot> Entry added to the todo list
15:01:58 <Serdar> Cale, the first is {f/:,z/[]}? but the second hm..
15:02:27 <Serdar> why is : not f?
15:02:28 <Cale> Serdar: foldr f z replaces each (:) in the list with f and the [] with z
15:02:31 <ihope_> Are automatic lazy patterns, deriving, and the fact that there can only be one constructor and it has to take only one argument the only differences between newtype and data?
15:02:43 <monochrom> DRMacIver: Indeed, anon sum type is preferrable to Either, Either3, Either4, ... for the same reason.
15:02:49 <Cale> map g replaces each (:) in the list with ...
15:03:00 <DRMacIver> monochrom: Sure
15:03:13 <oerjan> ihope_: also, the constructor is strict i guess
15:03:16 <glguy> (:) . f
15:03:19 <edward1> oh yeah i guess it would make sense that a pattern on a newtype would be lazy
15:03:19 <chessguy> Cale, so...
15:03:20 <Cale> Well, something that applies g to its first parameter before consing it onto the list :)
15:03:31 <chessguy> your Sudoku monad really has nothing to do with Sudoku...
15:03:36 <DRMacIver> monochrom: I'm not sure I see the utility, but I'd probably find a use for them if they were available. :)
15:03:45 <chessguy> it has to do with combining nondeterminism and state
15:03:46 <ihope_> That and those, then?
15:03:49 <DRMacIver> Well, I guess the same as Either really.
15:03:50 <Cale> chessguy: yes :)
15:03:55 <DRMacIver> Ignore my previous comment.
15:04:13 <Cale> chessguy: With different datastructures, it would be suitable for lots of things.
15:04:23 <chessguy> err, wait
15:04:26 <monochrom> This one is particularly easy to dualize to answer all questions and objections.
15:04:35 <chessguy> no, it also restricts how you can update the state
15:04:35 <Serdar> ann this replacement is only for the first cube?
15:04:40 <Serdar> ahh
15:04:44 <chessguy> with the rules of sudoku
15:04:51 <Cale> chessguy: yes
15:04:53 <DRMacIver> monochrom: Duality is not an interest preserving operation. :)
15:05:10 <Cale> chessguy: but you're right in that the general idea holds in lots of cases
15:05:27 <oerjan> hm, actually newtype constructors don't create irrefutable patterns, they just _preserve_ the irrefutability of whatever they enclose
15:05:29 <Serdar> Cale, is this infix?
15:06:02 <Cale> Serdar: sort of -- I'm drawing the code-graphs, so functions have edges which run downward to their parameters.
15:06:05 <chessguy> i wonder if it would be possible to generalize the notion of restricting how State can be modified
15:06:14 <monochrom> I disagree that newtype data constructors are strict. I also disagree that they're lazy. I say they're nothing, they don't exist in compiled code.
15:06:29 <Cale> Serdar: it's sort of the tree structures which are independent of infix/prefix/etc.
15:06:45 <fasta> There is no spoon.
15:06:56 <monochrom> I think it's pretty much like id.
15:06:58 <ihope_> newtype is really just type except that the new type isn't the same as the old type, isn't it?
15:07:13 * sorear just wrote a program without using Arrays or unsafe* that crashes - and passes core lint
15:07:14 <Serdar> : g 1 : g 2 or 1 g : 3 g :..
15:07:26 <Serdar> hmm kay
15:07:26 <int-e> ihope_: except that with type, it is the same old type. :-P
15:07:28 <monochrom> The typechecker thinks it's a different type. The code generator thinks it's the same code. That's the deal.
15:07:31 <ihope_> And you have things that are id except with a different type.
15:07:31 <dcoutts> monochrom: I'm not sure that's necessary, how about: newtype Foo = exists a. Bar a => Foo (Baz a)
15:07:32 <Cale> (:) (g 1) ((:) (g 2) (...))
15:07:40 <Cale> Or:
15:07:47 <monochrom> That doesn't exist yet, does that?
15:07:52 <Cale> g 1 : g 2 : g 3 : g 4 : g 5 : []
15:08:01 <dcoutts> monochrom: not yet, in ghc, I think hugs can do it
15:08:04 <Cale> Where that's parenthesized to the right.
15:08:12 <int-e> ihope_: for the type checker it's a new type. an implementation can treat construction and deconstruction as identity at runtime (after the types are dropped)
15:08:13 <ihope_> Hugs has exists but not GHC?
15:08:17 <monochrom> newtype with existential will make a difference, yes.
15:08:20 <dcoutts> monochrom: though it's forall, not exists, but you know what I mean.
15:08:27 <monochrom> I know what you mean.
15:08:50 <Cale> So, if the diagrams are right
15:08:52 <dcoutts> semantically newtype needs an explanation, you can't just appeal to the implementation
15:09:05 <Serdar> Cale, that means that f got g and :?
15:09:06 <Cale> We want to replace f x y with (:) (g x) y
15:09:16 <Cale> That is, f x y = (:) (g x) y
15:09:31 <Cale> Or f x y = g x : y
15:09:37 <dcoutts> monochrom: semantically it's pretty close to being a single strict constructor, but as I recall there is a subtle semantic difference
15:09:39 <ihope_> Is "newtype Foo = exists a. Bar a => Foo (Baz a)" the same as "newtype Foo = Foo (forall a. Bar a => Baz a)"?
15:09:47 <dcoutts> ihope_: no
15:09:50 <int-e> dcoutts: yes we already had the semantic explanation
15:09:51 <Cale> Or: f = (\x y -> g x : y)
15:09:58 * ihope_ shrugs
15:09:59 <int-e> dcoutts: pattern matching is the subtle difference
15:10:01 <dcoutts> int-e: oh, I'm late to the discussion :-)
15:10:01 <monochrom> Semantically it's type isomorphism. ihope_: do you know "type isomorphism"? newtype is best summed up as "type isomorphism".
15:10:14 <dcoutts> int-e: ah yes! so it is
15:10:22 <Serdar> wait
15:10:24 <ihope_> Eh, I guess I really don't care just now.
15:11:40 <dcoutts> ihope_: "newtype Foo = forall a. Bar a => Foo (Baz a)" is the same as "newtype Foo = Foo (exists a. Bar a => Baz a)"
15:11:48 <monochrom> How about this, different type but same semantics.
15:12:21 <dcoutts> semantics includes the type, so I'm not sure it helps
15:12:37 <dcoutts> semantics tells you what you can do with it, how it behaves, and type affects that a lot
15:12:52 <monochrom> I guess I understand newtype because I have seen Pascal.
15:13:03 <Serdar> Cale, that : in f = (\x y -> g x : y) is not the list : but the (:) :?
15:13:18 <mauke> there is only one :
15:13:55 <Serdar> mauke, at the context it stands: That is, f x y = (:) (g x) y
15:13:56 <oerjan> surprisingly, : is _not_ overloaded to mean mappend . return :)
15:14:23 <Cale> (:) is the operator which takes an element and adds it to the start of a list
15:14:25 <monochrom> Did you know that you could write "(+) 1 2" for "1 + 2"?
15:14:32 <oerjan> or should that be mplus . return
15:14:32 <Cale> > (:) 1 [2,3,4]
15:14:34 <lambdabot>  [1,2,3,4]
15:14:38 <Cale> > 1 : [2,3,4]
15:14:40 <lambdabot>  [1,2,3,4]
15:14:40 <Serdar> args
15:14:42 <Cale> same thing
15:14:57 <oerjan> > (mplus . return) 1 [2,3,4]
15:14:58 <lambdabot>  [1,2,3,4]
15:15:05 <Serdar> I thought the whole time you use the divisor
15:15:14 <Cale> divisor?
15:15:28 <Serdar> 4:2 = 2
15:15:32 <Cale> oh, like /
15:15:34 <Serdar> division
15:15:39 <Serdar> yes
15:15:44 <Serdar> that was confusing me
15:15:46 <therp> that's traditionally '/' in programming language syntax
15:15:47 <Cale> yeah, that's not a notation which I tend to use for division :)
15:16:04 <monochrom> Gosh, this is dense.
15:16:09 <therp> make
15:16:11 <therp> ups
15:16:14 <Serdar> therp, you know the Pascal tradition?
15:16:25 <int-e> there's this division symbol, Ã·
15:16:32 <int-e> but it's not really a colon
15:16:48 <therp> serdar: I did some pascal programming, but hmm.. too long ago maybe
15:16:49 <Cale> I've seen : used for division, but very rarely.
15:17:05 <Syzygy-> I occassionally use : for division. Mainly when I'm doing .. say .. polynomial division, and want the initial problem on one line.
15:17:07 <int-e> I've learned it at school but never seen it afterwards ;)
15:17:07 <monochrom> The Pascal tradition is that writeln(1:4) means write 1 with field width of 4. Still nothing to do with division.
15:17:08 <mgsloan> I think : might be used in rations sometimes
15:17:12 <oerjan> int-e: i can't see it but do you mean a : overlaid on a - ?
15:17:15 <mgsloan> like 1:2 ratio
15:17:19 <int-e> oerjan: yes
15:17:19 <Syzygy-> I find the Ã· horrribly ugly though.
15:17:43 <oerjan> int-e: i think that's essentially a fraction with the numerator and denominator replaced by dots
15:17:58 <monochrom> I like Ã·. It's what I learned as a kid.
15:18:00 <Serdar> Cale, yeah but your diagramm was not a language
15:18:14 <Serdar> I thought mathematicaly
15:18:20 <Cale> Serdar: This is still Haskell -- it's just Haskell that's already been parsed :)
15:18:45 <Serdar> I think it's because of 00:15 early in the morning
15:18:57 <Cale> Well, the arrows are largely my doing :)
15:19:06 <mauke> > 00:15
15:19:07 <lambdabot>   add an instance declaration for (Num [t])
15:19:13 <int-e> > 00:17:37:[]
15:19:15 <lambdabot>  [0,17,37]
15:19:23 <Cale> An arrow with words over it, as you might have guessed, means what happens to the thing when you apply that function.
15:19:25 <mgsloan> would be fun to have an IDE that showed haskell mathly
15:19:41 <monochrom> What is mathly?
15:19:45 <mgsloan> eg, division becomes an actual fraction, other things are symbolized
15:19:47 <Cale> I'd really like to have a Haskell interpreter which showed small-step transformations on code graphs.
15:19:53 <chessguy> @type maybe
15:19:55 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:19:56 <mgsloan> that'd be cool
15:20:00 <monochrom> OK. See, "mathly" is ambiguous.
15:20:19 <Cale> monochrom: I think he means in the typesetting sense.
15:20:22 <monochrom> I like overusing unicode symbols too.
15:20:50 <mgsloan> yeah, I mean more than unicode
15:20:52 <Cale> http://wxhaskell.sourceforge.net/images/proxima-win32.png
15:20:54 <mgsloan> layout, like latexish
15:21:03 <Cale> http://wxhaskell.sourceforge.net/images/proxima-mac.png
15:21:05 <Cale> like those
15:21:07 <mgsloan> ooh!
15:21:34 <Cale> I don't know how well-maintained Proxima is though.
15:22:09 <Cale> That's not what I'm looking for, of course -- I'm looking for something more like HOPS for Haskell: http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html
15:22:11 <lambdabot> Title: HOPS - Animations
15:22:51 <Serdar> f = (\x y -> g x : y) -- f x y = g x : y I think I go sleeping and ask later, why this is equal or read something or crush my head
15:23:01 <Cale> oh
15:23:11 <Cale> You don't see why?
15:23:35 <Cale> The left one defines f as the function which takes parameters x and y and returns g x : y
15:23:46 <Cale> the right one defines f x y to be g x : y
15:23:49 <Serdar> you put the x and y at the right side that's what I see
15:23:58 <Cale> Which is the same thing
15:24:06 <monochrom> That's all to it.
15:25:06 <mgsloan> Cale - I'm surprised that that would have all the cool math stuff, and arrows for lambdas, but not lambdas themselves
15:25:17 <Cale> mgsloan: hehe
15:25:39 <Serdar> the right has a function with 2 parameters x and y returning g x : y that's I understand, but the righ
15:25:41 <Serdar> args
15:26:39 <Serdar> but the left has a function which returns a function which has a function as parameter which has g x : y as parameter
15:26:51 <Serdar> that's confuseing
15:27:31 <monochrom> For beginners you can pretend "function takes two parameters" rather than "function returns function which ...".
15:27:38 <chessguy> @pl \x -> f (g x)
15:27:38 <Cale> Serdar: that's true of the right as well
15:27:38 <lambdabot> f . g
15:28:15 <Cale> Serdar: functions which take multiple parameters in Haskell are the same thing as functions which take one parameter and returns another function which ...
15:28:30 <monochrom> And yes, whether you write "f = \x y ->..." or "f = \x -> \y -> ..." or "f x y = ..." or "f x = \y -> ..."  it's all the same deal.
15:29:25 <sorear> !paste is it there yet?
15:29:49 <monochrom> No. Still 503. I curse the ISP.
15:29:51 <Serdar> hmm
15:30:09 <Serdar> okay I take that how it is
15:30:13 <sorear> monochrom: You know who the ISP is, right?
15:30:52 <monochrom> No.
15:31:01 <sorear> shapr
15:31:29 <monochrom> Does shapr subscribe to an ISP or does shapr runs the whole show?
15:31:58 <sorear> well he has an ISP of course, he doesn't hook directly into one of the backbones
15:32:03 <sorear> he runs his own webserver
15:32:47 <monochrom> Hrm, it's hard to believe shapr would let this state of 503 prevail. Is he facing some difficulty?
15:33:13 <ihope_> Is (x >> y) >> z always the same as x >> (y >> z)?
15:33:14 <sorear> yeah.
15:33:19 <sorear> yeah.
15:33:44 <monochrom> If the author of the monad observes the monad laws.
15:33:46 <mgsloan> if the instance follows the monad laws
15:33:46 <sorear> ihope_: it's a monad law, so yes unless you have buggy libraries
15:33:47 <mgsloan> yeah
15:34:16 <ihope_> What are the monad laws, again?
15:34:24 <sorear> fmap join . join = join . join
15:34:29 <DRMacIver> The code of conduct by which we all must live our lives.
15:34:30 <sorear> join . return = it
15:34:35 <oerjan> @quote stereo
15:34:35 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
15:34:37 <sorear> join . fmap return = id
15:34:50 <sorear> monochrom: shapr shut down hpaste due to spam.  I sent him the filtering patches yesterday. but he says they haven't arrived
15:34:54 <sorear> (and they didn't bounce)
15:34:55 <monochrom> There are some in terms of >>=
15:35:15 <mgsloan> it wasn't getting spammed that hard...
15:35:23 <oerjan> return x >>= f = f x
15:35:34 <oerjan> x >>= return = x
15:35:35 <sorear> mgsloan: I agree.
15:35:39 <monochrom> How do paste sites fight spam in general?
15:35:50 <Cale> Serdar: So, in hindsight, there's another way to come to this answer of map f = foldr (\x y -> f x : y) []
15:35:53 <ihope_> oerjan's imply all the monad laws?
15:35:59 <mgsloan> monochrom: most don't care
15:36:01 <Serdar> Cale, is that g in  f = (\x y -> g x : y) the same g in g x (foldr g [] xs)?
15:36:08 <Cale> Serdar: yes
15:36:17 <Serdar> hmm
15:36:21 <oerjan> x >>= (\t -> f t >>= g) = (x >>= f) >>= g
15:36:25 <monochrom> oerjan's imply all the monad laws.
15:36:26 <Cale> er, no
15:36:36 <sorear> monochrom: The bad ones (like lisppaste circa the creation of hpaste) use visual-only captchas drawn using table background colors.
15:36:38 <Cale> sorry, we must have switched somewhere ;)
15:36:53 <Cale> The f and g have been swapped there
15:36:56 * mgsloan like's sorear's edition better
15:37:11 <Cale> We're going to use (\x y -> g x : y) as a parameter to foldr
15:37:25 <Cale> So if f = (\x y -> g x : y)
15:37:35 <sorear> @unpl (:) . g
15:37:36 <lambdabot> (\ c -> ((:)) (g c))
15:37:43 <Cale> then foldr f z (x:xs) = f x (foldr f z xs)
15:38:01 <Cale> = g x : (foldr f z xs)
15:38:31 <Cale> which is exactly what we want, in order for foldr f z to equal map g
15:39:18 <Serdar> g?
15:39:31 <Serdar> that g
15:39:40 <Serdar> too dark here
15:39:42 <chessguy> v s = s .&. 3 == 0
15:39:48 <chessguy> @pl v s = s .&. 3 == 0
15:39:48 <lambdabot> v = (0 ==) . (.&. 3)
15:39:52 <Cale> yeah, somewhere along the line, g and f got swapped, sorry for any confusion -- this g and f match my diagrams.
15:40:20 <Cale> We're looking for f and z so that  map g = foldr f z
15:40:38 <greenrd> My code using Data.Generics is not working as I expected
15:40:39 <Serdar> Cale, I think it's because of my bad english, you mean f == g here?
15:40:42 <Cale> no
15:40:43 <greenrd> here is a test case:
15:40:50 <greenrd> http://pastebin.ca/603609
15:40:56 <Cale> in fact,  f = (\x y -> g x : y)
15:41:18 <greenrd> the first line of the output is "Hi! The string was oo"
15:41:27 <Serdar> but we have a = and g is not used left
15:41:40 <greenrd> when I expected it to be "Hi! The string was foo"
15:42:10 <Cale> Serdar: yes, because we're assuming g is defined somewhere
15:42:28 <Serdar> okay
15:42:28 <Cale> In particular, when we're defining map g, it'll be available
15:42:40 <Cale> map g = foldr f z where f = ...; z = ...
15:42:54 <Cale> we're allowed to use g in the definition of f and z there.
15:45:10 <greenrd> my code looks to be skipping odd-numbered constructors, but why?
15:45:27 <greenrd> I mean constructors at an odd-numbered depth
15:46:53 * Cale grumbles at the pastebin's inclusion of line numbers and instead copies from the textbox
15:47:03 <greenrd> there is a tiny raw link on the right btw
15:47:19 <greenrd> http://pastebin.ca/raw/603609
15:47:24 <oerjan> greenrd: maybe handleOther = rec would work better?
15:47:40 <oerjan> (this from someone who has never used generics)
15:48:08 <Serdar> I think I should sleep and think after again
15:48:23 <Serdar> Cale, thanks for helping and your Patience
15:48:29 <greenrd> oerjan: yup, that did it, thanks!
15:48:37 <Serdar> good night guys
15:49:06 <oerjan> :)
15:49:11 <Cale> Ser^zZz: g'night
15:50:46 <Vulpyne> This has nothing to do with Haskell, but... What was the speed reading method where text alternates direction per line called? I seem to remember that it start with a "B".
15:51:06 <Cale> Boustrophedon
15:51:12 <Vulpyne> Thanks!
15:51:21 <Vulpyne> No wonder I couldn't remember. :)
15:51:23 <Cale> "as the ox ploughs"
15:54:09 <mgsloan> sounds like a name for a dinosaur
15:54:37 <dons> sorear: saying 'System Fc .. is unsound' is a hmm, big call. Like theatrics? Or is it just an implementation bug?
15:54:55 <sorear> FC(X) would be a big call.
15:55:13 <sorear> but FC() is parameterized on a consistant set of axioms
15:55:22 <Cale> greenrd: what did you actually expect?
15:55:23 <sorear> and what ghc generates, er, isn't.
15:55:51 <Cale> Do you perhaps mean  everywhereM in place of gmapM and handleOther = return ?
15:56:07 <dons> sorear: are you saying the rules in the paper are unsound, or the implementation has a bug?
15:56:18 <greenrd> obviously I could have used everywhereM to do this dummy stuff
15:56:38 <greenrd> but the dummy stuff was just to bang out a test case fast
15:56:53 <dons> or, basically, there's an interaction with newtype deriving, which is buggy.
15:56:53 <greenrd> the real code can't use everywhereM
15:56:55 <sorear> the rules in the paper are unsound, nor do they claim to be sound.  instead they show that *if* you use a consistant axiom set, you get a sound type system
15:57:15 <sorear> newtype deriving left the picture as soon as the program passed core lint
15:57:34 <sorear> FC(x) is unsound for inconsistant x.  everyone knew that.
15:57:57 * dibblego issues DRMacIver with a Get Stuffed Notice
15:59:39 <DRMacIver> Oh noes. Whatever shall I do.
15:59:47 <dibblego> Get Stuffed of course :)
15:59:55 <DRMacIver> Nope. Can't be bothered.
16:00:21 * DRMacIver has already had dinner.
16:01:16 <dibblego> our only conversation that I can recall is me making a mistake, finding out the fact, then admitting it
16:03:50 <monochrom> Write docs for Control.Monad.*
16:04:51 <Cale> greenrd: hmm, perhaps you're looking for handleOther = rec ?
16:05:19 <Cale> (btw, that code gave me syntax errors until I renamed rec -- perhaps it's become a keyword)
16:05:29 <greenrd> yes
16:05:33 <dons> sorear: my point is that 'unsound' might be considered rude. so be careful with the hysterics -- perhaps you don't realise it would be read as such?
16:05:40 <edward1> isn't the whole point of Fc is it kind of lets you roll your own axioms? you translate from something else that is consistent and express it in the Fc context.
16:06:01 <dons> you're just coming across an interaction, similar to the few found with GADTs, that just get sorted out.
16:06:14 <DRMacIver> There have been a few others. It's probably more from tangential exposure to conversations you've had with other people.
16:06:18 <DRMacIver> Anyway, I'm off to bed.
16:06:18 <greenrd> Cale: oerjan gave me that answer some minutes ago - and it works - thanks
16:06:23 <Cale> greenrd: ah, okay
16:06:27 <ihope_> monochrom: as Haskell is a declarative language, not an imperative one, it seems appropriate to ask you to state "write docs for Control.Monad.*" declaratively.
16:06:28 <ihope_> :-P
16:06:38 <chessguy> high traffic channel today
16:06:39 <Cale> greenrd: you can see why it was skipping layers :)
16:06:43 <chessguy> @losers
16:06:43 <lambdabot> Maximum users seen in #haskell: 354, currently: 315 (89.0%), active: 17 (5.4%)
16:06:45 <edward1> kind of like sulzmann's HM(X) as long as X satisfies some simple rules its consistent
16:07:01 <Cale> chessguy: yes, it's a bit crazy to try to follow it all :)
16:07:06 <greenrd> yeah, it's obvious now, d'oh
16:07:27 <dibblego> ricky_clarkson, welcome to #haskell anyhow - I'm sure there is lots to learn here
16:07:39 <monochrom> Hrm, let me think how to do that.
16:08:00 <dons> sorear: are we just looking the new type families code not handling newtype deriving at all?
16:08:20 * mgsloan keeps on accidentally trying to use -- in C++ as a comment...
16:08:20 <monochrom> Here: Conjure a new state of the world such that Control.Monad.* has docs.
16:08:29 <sorear> dons: Newtype deriving has nothing to do with this, because it has no effect on the generated axioms.
16:08:54 * chessguy sighs
16:08:54 <chessguy> http://paste.lisp.org/display/43939
16:09:30 <dons> sorear: why is the newtype deriving required to produce the bug then? doesn't it cause some bogus code to be generated?
16:09:43 <edward1> how bad do you think the loss of phantom types in a haskell-like language analogue would be? i.e. data Foo a = SomethingNotInvolving_a would then identify Foo Int and Foo Bool, etc.
16:09:44 <sorear> dons: -dcore-lint
16:10:01 <sorear> dons: if bogus *code* were being generated, core lint would have caught it.
16:10:16 <sorear> dons: and my point is that the *core language* is unsound - not haskell
16:10:20 <MarcWebe1> dons: How does syntax highlighting work on in yi currently? Is there a difference between the vty and sourceview gui frontend?
16:10:33 <oerjan> chessguy: you have a problem with that?
16:10:34 <dons> vty doesn't work, currently, iirc.
16:10:47 <chessguy> oerjan, well, what's written so far seems to work
16:10:49 <dons> sorear: do we know if core lint , lints Fc core properly?
16:10:53 <chessguy> i just wonder if i'm going about it the wrong way
16:11:11 <sorear> dons: if I need to exploit bugs in the desugarer in order to test the core language, I will
16:11:35 <dons> sorear: anyway, its a good idea to contact ChilliX directly, since he's working on this.
16:11:43 <edward1> a lot of the existing 'using phantom types as proof' mechanisms can be handled with subset types in this setting. Bar = { x : Foo Int | proposition x } Baz = { y : Foo Bool | proposition y }, so with subset types i'm not sure the loss of phantom types would be TOO bad
16:11:47 <dons> he's probably less likely to see the bug report otherwise
16:12:02 <chessguy> hey edward1!
16:12:06 <edward1> heya chessguy
16:12:21 <chessguy> edwardk, remember my ray problem from the other day?
16:12:24 <edwardk> yep
16:12:29 <edwardk> find a better way?
16:12:29 <dolio> edward1: You could probably do without phantom types without much trouble, but having them, but identifying things with different phantom types might be weird.
16:12:33 <chessguy> i changed the numbering scheme and solved it much more cleanly
16:13:01 <dons> as the page says, there are known gaps in the implementation. and this would be one of the newtype type family gaps, i guess.
16:13:09 <chessguy> check out the first diagram at http://www.cis.uab.edu/hyatt/boardrep.html
16:13:10 <lambdabot> Title: Chess program board representations
16:13:40 <edwardk> dolio: the problem is they interact very badly with subtypes, if a is a subtype of b then list a should be a subtype of list b, because its covariant, so i can identify covariant uses, and contravariant uses, and make invariant when you have to subtype both covariantly and contravariantly, but if you don't USE the type, the 'constrained' answer is that its anyvariant.
16:13:46 <chessguy> using that, ray practically falls out:
16:13:47 <chessguy> ray :: Int -> Int -> [Int]
16:13:47 <chessguy> ray d sq = takeWhile ((0 ==) . (.&. 0x88)) (iterate (+ d) (sq+d))
16:13:57 <monochrom> edwardk: Ah, I see. Do you have a great implementation of subset typing? Yes that may eliminate phantom types.
16:14:05 <dufflebunk> Are there any cross platform GUI libraries that are more than parial/experimental implmentations?
16:14:18 <edwardk> monochrom: i have an implementation of it, not sure its all that great =)
16:14:31 <dons> sorear: at a miminum, ask on ghc-users, cc chillix, and spj.
16:14:45 <edwardk> monochrom: its basically ESC/Haskell resugared.
16:14:50 <monochrom> It depends on how many propositions your compiler can handle.
16:15:13 <monochrom> OK, ESC may take forever but it is also all-powerful. :)
16:15:14 <lispy> dufflebunk: have you looked at the gtk bindings?
16:15:26 <edwardk> monochrom: right now i try to handle them, provide a counterexample and terminate if i can, and if i can't, i turn around and warn you and offer to insert runtime checks
16:15:41 <monochrom> good good good.
16:15:49 <lispy> dufflebunk: iirc, it's gtk2hs
16:15:56 <edwardk> monochrom: i'm looking into alternate ways to implement it than the unrolled abstract interpretation using an approach stolen from the termination checking people
16:16:15 <dolio> edwardk: Ah. I was just saying that if phantom types aren't going to work, you should probably enforce that in 'Foo a = Something', 'Something' has to involve a.
16:16:16 <dufflebunk> lispy: I haven't looked at any very carefully. I've started looking at the high level list on the haskell wiki
16:16:23 <edwardk> i can insert runtime checks for subset types, but i can't check the 'quotient-preservingness' of quotient types yet
16:16:25 <monochrom> Some prover is necessary no matter what.
16:16:36 <dufflebunk> lispy: I'll take a look at that one, thanks.
16:16:39 <edwardk> dolio: won't work, since i allow arbitrary functions at the type level as long as they are terminating
16:16:44 <lispy> dufflebunk: wxhaskell works great for simple GUIs, i've found
16:16:51 <edwardk> dolio: so enforcing that constraint kind of cripples the set of functions allowed
16:16:54 <dolio> edwardk: Ah. Oh well, then. :)
16:17:16 <dons> sorear: also, check through the status of each of data/type/newtype on the Fc page, to see if it falls under a 'known issue' in the implementation.
16:17:18 <lispy> dufflebunk: and if you're doing something really fancy you'll probably want to use some C/C++ to create some custom widgets on the platforms you support and bind them to haskell anyway
16:17:39 <edwardk> monochrom: sure, i'm just trying to cut down the scope of proof a bit
16:17:42 <dufflebunk> lispy: that's cheating ;)
16:17:55 <monochrom> Good good good.
16:18:11 <lispy> dufflebunk: well you could extend directly in haskell, but that means you'll need to have bindings from haskell to the direct platform APIs
16:19:05 <dufflebunk> lispy: so there are no libs that are useful for complex UIs yet?
16:19:10 <lispy> dufflebunk: guis are one of those things that's really, really hard to be truely fully featured while being fully cross platform
16:19:26 <dufflebunk> That's true.
16:19:43 <lispy> IMO, even java fails here
16:20:11 <mgsloan> what's wrong with gtk2hs?
16:20:17 <edwardk> monochrom: right now the main issue is i track termination where i can figure it out in my compiler (to permit functions to work transparently on higher sorts) and the proofs when inserted as runtime checks can change termination behavior, since there isn't a termination criterion on the proofs. so i need to allow the insertion of  runtime code to 'lift' the code and the code using it into the pointed type, which i haven't figured out how to
16:20:17 <lispy> the biggest complaint a hear about wxhaskell is that it look right on the osx
16:20:35 <lispy> mgsloan: non-native dialogs on windows always bugs me :)
16:20:44 <lispy> although, that may be fixed by now
16:21:00 <mgsloan> i think there's a gtk theme that makes it look a bit less out of place
16:21:19 <mgsloan> (and it defaults to that on windows)
16:21:23 <edwardk> that and that i can't figure out a 'right' way to lift quotient-safety into a runtime check other than checking it loosely with some sort of quickcheck pass at compile time.
16:21:49 <mgsloan> well, native widgets are too hard to get right
16:21:50 <lispy> mgsloan: i mean specifically, things like the file chooser and the color picker...last time i checked gtk2hs was using the same dialogs that it uses on linux.  They're okay dialogs, but they don't look native when you're on windows
16:21:59 <mgsloan> native & cross platoform that is
16:22:05 <mgsloan> ah, good point
16:22:14 <mgsloan> that, at least, should be fixable
16:22:41 <lispy> right, i was looking into doing it quite awhile ago, but i really didn't like getting so deeping into the win32api without really understanding it
16:22:45 <lispy> so, i gave up :)
16:22:55 <mgsloan> I think the dialogs should be pretty simple
16:23:16 <lispy> the hard part with the file dialog was how the api deals with the buffer size to hold the file name
16:23:32 <mgsloan> ah
16:23:48 <edwardk> so, i.e. if i define Int, and then define Parity = Int \\ (\x y -> x mod 2 == y mod 2); then even = 0 :: Parity; odd = 1 :: Parity; that + and * are parity preserving for all members of the typeclass, so you can safely use even + even = even despite the wrong subtype direction on the arguments.
16:23:51 <lispy> iirc, you need a callback inorder to know what size of buffer to privode
16:23:55 <lispy> provide*
16:24:01 <mgsloan> hah
16:24:26 <mgsloan> well, i dunno ffi, but sounds surmountable
16:24:29 <edwardk> er s/typeclass/for all members of each partition of the quotient type/
16:24:30 <lispy> it's like, "We'll call your allocation function if your buffer is too small" sort of logic
16:24:44 <dufflebunk> You need a callback to give the size of a buffer??
16:24:53 <mgsloan> that's win32 for yah
16:25:00 <lispy> mgsloan: yeah, i think that by itself wasn't too bad, but then i started running into all these cases about dealing with unicode
16:25:06 <mgsloan> worst api ever, pretty much
16:25:27 <lispy> i'm locale ignorant, so mention of unicode was scary to me
16:25:31 <mgsloan> mm, unicode. good point
16:25:36 <mgsloan> yep unicode is freaky
16:25:36 * dufflebunk has only ever done GUI stuff in Java before
16:26:07 <edwardk> chessguy: cute board rep trick
16:26:11 <mgsloan> win32 it takes around 100 lines to properly make your window
16:26:17 <lispy> dufflebunk: if you really wanted to be preverse you could code your gui in java and then use jni + haskell-ffi to make the GUI talk to the application logic :)
16:26:54 <dufflebunk> lispy: If I wanted to be perverse there are a number of things I could do ;)
16:26:59 <glen_quagmire> is haskell the language the most resemble math equations?
16:27:15 <edwardk> glen_quagmire: pretty close =)
16:27:16 <mgsloan> one of them
16:27:28 <dufflebunk> I think matlab more closely resembles math
16:27:37 <Cale> I don't
16:27:41 <lispy> i bet prolog is closer than haskell
16:27:51 <Cale> matlab largely isn't referentially transparent
16:28:01 <lispy> oh, maybe dufflebunk meant mathematica?
16:28:13 <dufflebunk> oops, yeah.
16:28:14 <mgsloan> there are things more crazily symbolic, like APL or epigram
16:28:25 <Cale> Mathematica and Maple are perhaps closer (although they're impure as well)
16:28:44 <Cale> epigram literally looks like formal logic
16:28:51 <edwardk> chessguy: i'd probably fragment that pieceMoves thing into alot more pieces
16:28:55 <edwardk> no pun intended
16:29:18 <mgsloan> though math stuff that's out of the scope of the prelude isn't really supported
16:29:27 <chessguy> edwardk, what do you mean?
16:29:28 <edwardk> and migrate your GameState into a monad so you don't have to carry it around everywhere
16:29:31 <mgsloan> try to make a matrix type, for example..
16:30:44 <edwardk> chessguy: i just mean it'll probably me more legible if you broke that apart into a function per piece type, then had one wrapper that just invoked them
16:31:01 <glguy> mgsloan: you mean one that checks dimensional compatibility for (+), (*), etc?
16:31:02 <chessguy> that's likely to give me a performance hit then isn't it?
16:31:10 <edwardk> not likely once it inlines
16:31:28 <edwardk> the monad? maybe a little one
16:31:51 <edwardk> but trust me its easier to refactor OUT of the monad than into one and easier to figure out what you're doing when in one ;)
16:32:28 <chessguy> i don't really see how the monad helps
16:32:41 <edwardk> because you're going to be carrying around gamestate into a lot of functions
16:32:51 <lispy> oh, someone's making a game?
16:33:04 <edwardk> how many things do you call with foo something g, bar something g, etc.
16:33:07 * lispy sits on edge of chair waiting for details
16:33:33 <edwardk> jason: not so sure he's writing a game, but he's got a few fragments of code for manipulating a chessboard. you do the math ;)
16:33:41 <mgsloan> glguy - yeah, though I've just realized that can probably be managed with type trickery
16:34:03 <mgsloan> and if vector is defined in terms of matrix, there you have vector*matrix/matrix*vector
16:34:10 <lispy> edwardk: ah, he would be doing nqueens or hamiltonian paths or lots of other things tho :)
16:34:28 <chessguy> hmm
16:34:36 <lispy> edwardk: BTW, it's really weird not being called lispy on irc ;)
16:34:44 <edwardk> heh
16:34:59 <lispy> edwardk: doubly so because friends usually call me by last name :)
16:35:06 <edwardk> ok dagit it is
16:35:21 * lispy has almost changed his nick to dagit on many occasions
16:35:24 <edwardk> heh
16:36:04 <edwardk> i turn around and anyone i talk to for some length i usually wind up adding to my buddy list by their real name, so after a while i forget nicks since i don't see nicks ;)
16:36:20 <edwardk> helpful when i want to put a name to a face later on
16:36:35 <edwardk> and i'm not sitting there going 'you're malc aren't you?' =)
16:36:59 <Lemmih> @seen dons
16:37:00 <lambdabot> dons is in #haskell-icfp07, #xmonad and #haskell. I last heard dons speak 5m 32s ago.
16:37:04 * glguy will have to get used to calling dons don :)
16:37:09 <edwardk> heh
16:37:13 <edwardk> yeah
16:37:31 <Cale> Heh, yeah, I've been pronouncing his name "dons" in my head for quite a while.
16:37:42 * lispy too,
16:37:49 <Korollary> We have a dons at work, too.
16:37:49 <edwardk> that one i'll admit i've internalized as dons =)
16:37:52 <lispy> it's weird when i try to takl about dons to droundy
16:38:00 <chessguy_> edwardk, i asume that by turning into a monad, you mean something like State BoardState, right?
16:38:03 <lispy> fortunately, he knows that don goes by dons...
16:38:21 <edwardk> chessguy: yeah State GameState or something
16:38:40 <Lemmih> dons: The default buffer size in Data.Binary.Builder is killing me.
16:38:41 <lispy> chessguy: have you read the paper about using monad transformers to make a scheme interpreter?
16:38:41 <chessguy> then i guess i still don't get how it's going to help
16:38:58 <lispy> it's a very straightforward paper that explains this approach
16:39:03 <edwardk> then writing monadically, which would let you later change monads out so you can say add logging to a writer when things go wrong, a reader for other things
16:39:08 <chessguy> lispy, what approach?
16:39:12 <Cale> "Don dons an expensive suit and hat, but Jason decides to dag it."
16:39:17 <chessguy> lispy, are you talking about the semantic lego one?
16:39:28 <Cale> (Sorry)
16:39:32 <edwardk> cale: =)
16:39:46 <edwardk> @remember Cale Don dons an expensive suit and hat, but Jason decides to dag it.
16:39:46 <lambdabot> Done.
16:40:37 <edwardk> chessguy: anyways its a lot harder to retrofit in such a monad after the fact than it is to accept that you have some state and some interactivity and just roll with it from the beginning and add pieces to the monad as you need them
16:40:38 <dons> ok you guys are weird.
16:40:41 <dons> Lemmih: do tell!
16:40:53 <lispy> shoot, i can't kind the paper now
16:40:58 <sorear> @where ffi
16:40:58 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
16:41:51 <bos> @seen sjanssen
16:41:51 <lambdabot> I saw sjanssen leaving #haskell, #xmonad and #haskell-icfp07 1h 5m 17s ago, and .
16:41:55 <bos> bah.
16:42:33 <lispy> chessguy: this is probably worth a read, but not the article i was looking for http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
16:42:37 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
16:42:41 <Lemmih> dons: I'm do 73011 encodings of small bytestrings.
16:42:44 <chessguy> been there, read that
16:42:50 <chessguy> multiple times
16:42:56 <dons> Lemmih: ok...
16:43:04 <dons> bos, you just looking for the repo?
16:43:09 <Lemmih> dons: That amounts to 2.3 gigs of allocated memory with the curent buffer size.
16:43:14 <bos> dons: yeah
16:43:17 <lispy> chessguy: then try this one: http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.pdf
16:43:39 <bos> dons: i assume this is from last year's SoC, and has probably bitrotted something awful?
16:44:33 <dons> bos, hmm, only a little, i'd think. it'd be a good starting point.
16:44:42 <bos> cool.
16:44:49 <chessguy> lispy, that one looks interesting. not sure if i've read that one
16:45:06 <chessguy> lispy, edwardk wasn't talking about MonadTs though
16:45:09 <lispy> chessguy: it's pretty well written for beginners to monad transformers
16:45:11 <chessguy> (to my knowledge
16:45:17 <dons> Lemmih: mail kolmodin, dcoutts_ and I. including an example
16:45:34 <lispy> chessguy: well, the transformers give you an easy way to create custom monads by reusing existing structure
16:45:54 <lispy> chessguy: they're just a short cut, so that makes them related :)
16:45:55 <chessguy> lispy, i don't see how they're relevant to my problem though
16:46:01 <dons> bos, yeha, i can't seem to find it on d.h.o. we'll have to ask him when he reappears
16:46:13 <lispy> chessguy: your problem is one of managing state, right? (I admit, i wasn't watching closely)
16:46:13 <dons> bos, oh, i have a copy
16:46:19 <chessguy> lispy, yes
16:46:41 <lispy> chessguy: well, the interpreter in that example has to manage state as well, so they use a monad
16:46:42 <chessguy> lispy, of using the State Monad to manage it instead of threading it around
16:47:02 <chessguy> lispy, yes, but there's a big difference between needing a monad and needing a monad transformer...
16:47:04 <edwardk> chessguy: well i figured we'd start you on the State monad then add MonadT's as needed for other things ;)
16:47:22 <lispy> chessguy: there is nothing wrong with just using the state monad, but i bet you'll find it's more elegant and easier to grok if you use a custom monad :)
16:47:27 <bos> dons: is it the fps-soc repo?
16:47:31 <dons> that's it.
16:47:37 <dons> did you find it?
16:47:42 <bos> yeah.
16:47:48 <lispy> chessguy: for now, i'd just checkout that pdf and then decide on your own what you want to use
16:47:50 <bos> http://darcs.haskell.org/SoC/fps-soc
16:47:51 <lambdabot> Title: Index of /SoC/fps-soc
16:47:55 <dons> look for Storable a => ByteString a or some such.
16:47:57 <dons> yeah. that's it.
16:48:06 <lispy> chessguy: you'll be pretty informed after reading it
16:48:07 <chessguy> edwardk, i still don't see how State is going to help me here. i mean, all those functions are still going to be in the state monad so they're just going to do a s <- get; at the beginning, and then i don't see how it's going to be that much different
16:48:12 <edwardk> lispy: well, i think right now the argument is monad or not =)
16:48:15 <bos> it's Data.StorableVector
16:48:25 <lispy> ah
16:48:30 <lispy> i'm just ahead of the game :)
16:48:38 <edwardk> chessguy: its mostly a matter of saving you later refactorings
16:48:54 <bos> desfortunately, it just clones the ByteString code and changes the types.
16:49:06 <dons> yup
16:49:10 <bos> would have been nice if it did a SPECIALIZE for Word8 everywhere :-)
16:49:16 <chessguy> oy. i guess my haskell time for the day is gone. the fiancee wants to talk..
16:49:22 <dons> let the ndp lib do that.
16:49:34 <johan_> i have a function f which takes an int and returns an int and a list x to apply the elements of x to f but in all different combinations..
16:49:43 <dons> reminds me: i'm wonder if we can rip out the parallel layer of the ndp lib, and stick that under Data.ByteString.Parallel
16:49:44 <edwardk> i tend to accumulate a bunch of monad transformer then just figure out what my monad is based on what i need, sad eh?
16:50:00 <bos> hmm, whatever ndp is doing is not known to me.
16:50:00 <johan_> i want to achieve some sort of backtracking that funtion over a list
16:50:29 <dons> bos, oh, its the general unboxed/parallel array lib with fusion
16:50:32 <lispy> backtracking on a list...i was just reading about zippers...
16:50:55 <edwardk> woops i need transactions, ok, i'm over IO, so i can atomically call into STM, i need a state i'm changing thread locally ok i'm in a StateT, i need an environment of TVars for the transactions, i'm in a ReaderT...
16:50:58 <dons> ?users
16:50:58 <lambdabot> Maximum users seen in #haskell: 354, currently: 309 (87.3%), active: 15 (4.9%)
16:51:04 <bos> i knew that much, but that was about it. is it worth building on instead of sjanssen's stuff?
16:51:21 <glguy> johan_: can you try to give a more concrete example?
16:51:24 <dons> nah, too experimental
16:51:27 <bos> k.
16:51:31 <dons> but its why i'm not pushing generalised bytestrings terribly hard
16:51:38 <bos> i see.
16:51:54 <dons> a tuned version for utf8 is needed though
16:52:01 <dons> to get rid of PackedString
16:52:05 <edwardk> I heart zippers.
16:52:11 <chessguy> ok one more question about State and chess
16:52:22 <dons> if you're hacking on this, you'll want the `bytestring' repo on darcs.haskell.org/ bos.
16:52:34 <dons> that's the head branch of fps
16:52:40 <edwardk> chessguy shoot
16:52:41 <chessguy> i asked dons once about why he didn't use State to avoid threading information around his functions in http://cgi.cse.unsw.edu.au/~dons/blog/2007/05/01#xmonad_part1_model
16:52:42 <lambdabot> Title: Haskell hacking, http://tinyurl.com/232r46
16:52:44 <ihope_> Generic zippers!
16:52:47 <bos> ok, thanks.
16:52:57 <chessguy> he said it wasn't much of a gain there
16:53:01 <chessguy> so how is this different?
16:53:07 <dons> there's the stream fusion thing in another branch, but you'll probably not get that far
16:53:21 <johan_> glguy: well i have a list of values and a function f. i want (cant write square brackets) f x : y : z   f x : fy : z  f x : f y : f z   x : f y : z etc
16:53:36 <johan_> those are different lists
16:53:48 <chessguy> i mean, he's passing around the StackSet just like i am my GameState
16:53:57 <ihope_> johan_: perhaps you should use {}, () or <> instead...
16:53:59 <glguy> johan_: so you want all the ways you could either apply or not apply the function?
16:54:05 <dons> chessguy: hmm. inside StackSet, we don't want to thread StackSet in State
16:54:10 <dons> but outside, its another story
16:54:14 <johan_> ihope_: yep
16:54:19 <johan_> glguy: yep
16:54:23 <edwardk> chessguy: maybe a choice of perspective, being in the monad is like being in the stackset or the game, being outside the monad is like looking in
16:54:36 <Cale> > mapM (\x -> [x,x*10]) [1,2,3]
16:54:44 <lambdabot>  [[1,2,3],[1,2,30],[1,20,3],[1,20,30],[10,2,3],[10,2,30],[10,20,3],[10,20,30]]
16:55:17 <johan_> Cale: thats neat :)
16:55:19 <Toxaris> johan_: use g x = [x, f x] and the list monad
16:55:28 <chessguy> edwardk, so your saying that in his code you're at a lower level, being inside the monad, where in my code you're not?
16:55:35 <Toxaris> hmm, as Cale suggested just some seconds before
16:55:41 <edwardk> no, i'd say its the other way around actually
16:56:22 <johan_> how does that mapM work really?
16:56:32 <chessguy> i guess i don't really see the difference
16:56:38 <SamB> it's only a lower level if it's the ST or IO monad ;-)
16:57:07 <lispy> johan_: in this case, mapM is using the list monad so that might explain why it seems a bit tricky
16:57:12 <edwardk> being outside looking in at the stackset makes sense when you are defining it as a library and its your most comfortable perspective. i.e. if i'm going to build something that manipulates lists and maps and other data structures and i need to manipulate lots of different things. putting something into your state gives you a strong sense of 'when' you are in the data i guess.
16:57:32 <lispy> > do { x <- [1,2,3]; y <- "abc"; return (x,y) }
16:57:34 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
16:57:37 <lispy> that also uses the list monad
16:57:40 <Alleria_2> Can someone tell me what the idiomatic Haskell for reversing a list might be?
16:57:48 <chessguy> @src reverse
16:57:48 <lambdabot> reverse = foldl (flip (:)) []
16:57:49 <edwardk> > reverse [1,2,3]
16:57:51 <lambdabot>  [3,2,1]
16:57:56 <Alleria_2> ahh, thanks
16:57:57 <Lemmih> dons: Reducing the buffer size to 1k reduces my GC time from 9.8% to 0.7%. I'll mail my findings tomorrow.
16:57:59 <SamB> Alleria_2: it would be "reverse list"
16:58:01 <glguy> > let go f (x:xs) = do x' <- [x, f x]; xs' <- go f xs; return (x':xs')
16:58:02 <lambdabot>  Parse error
16:58:11 <edwardk> @quote stereo
16:58:11 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
16:58:16 <dons> Lemmih: hmm, that's interesting. so its currently cache-sized
16:58:17 <glguy> > let go f (x:xs) = do x' <- [x, f x]; xs' <- go f xs; return (x':xs') in go succ [1..3]
16:58:19 <lambdabot>   Non-exhaustive patterns in function go
16:58:22 <Alleria_2> I guess I should go read the prelude tour some more.
16:58:23 <dons> but Lemmih , we waste a lot, i guess?
16:58:28 <glguy> > let go _ [] = [] ; go f (x:xs) = do x' <- [x, f x]; xs' <- go f xs; return (x':xs') in go succ [1..3]
16:58:30 <lambdabot>  []
16:58:34 <glguy> oh
16:58:36 <edwardk> Alleria_2: no problem, as you can see, we like to answer questions
16:58:39 <glguy> > let go _ [[]] = [] ; go f (x:xs) = do x' <- [x, f x]; xs' <- go f xs; return (x':xs') in go succ [1..3]
16:58:41 <lambdabot>   add an instance declaration for (Num [t])
16:58:41 <lambdabot>     In the expression: 3
16:58:43 <glguy> :)
16:58:43 <SamB> edwardk: please avoid that unless there were two exactly identical responses very close together
16:58:43 <chessguy> edwardk, ok, thanks. i'll ponder that some more
16:58:46 <glguy> I'll play in /q
16:59:08 <SamB> edwardk: that itself happens often enough as it is
16:59:14 <edwardk> fair enough
16:59:22 <dons> Lemmih: the issue being small strings causing lots of chunks to be broken off in the bytestring output?
16:59:42 <dons> sorear++ much better! :-)
16:59:49 * sorear faints
17:00:01 <dons> i'll see if ChilliX is up yet.
17:00:04 <SamB> dons: did he stop whining and code?
17:00:09 <SamB> @vixen hi
17:00:09 <lambdabot> <undefined>
17:00:25 <edwardk> is vixen still busted?
17:00:27 <dons> not up yet, i'll drop the bug id by him when he gets in
17:00:30 <Cale> Alleria_2: be careful with reverse though, since it takes O(n) time even before it gives you the first element of the result, so sometimes it's best to leave lists in a reversed form until the last moment.
17:00:32 <dons> ?quit
17:00:33 <dons> let's try!
17:00:38 * dons is full of caffeine
17:00:45 <dons> come on ms. bot..
17:00:58 <Alleria_2> Cale: thanks for the tip.
17:00:59 <SamB> @vixen hi
17:01:05 <lambdabot> <undefined>
17:01:08 <SamB> what!
17:01:11 <edwardk> if so, i'll happily supply you with the chat code from bottom, but i think changing her to a gay male surfer would be a bit weird ;)
17:01:15 <dons> nope. weird. let's double check
17:01:39 <dons> You have conflicting local changes to:
17:01:39 <dons> ./State/vixen
17:01:39 <dons> ah
17:01:48 * lispy wants to ask edwardk, "wth?" but changes his mind...
17:02:01 <lispy> ah, conflicts!
17:02:03 <edwardk> lispy: it fit the name better
17:02:04 <dons> ?quit try again
17:02:09 <SamB> dons: you might want to roll back the vixen state and use my code to convert on your own?
17:02:13 <dons> yup
17:02:18 <dons> well, there's no state as such, iirc
17:02:23 <dons> its ro.
17:02:23 <Lemmih> dons: The minimum output from 'encode' is 32k. That add quite a bit of overhead when encoding small pieces of data.
17:02:25 <SamB> well, something must have changed
17:02:40 <dons> Lemmih: right, but shouldn't multiple small strings really be backed end to end in a 32k buffer?
17:02:46 <SamB> really I have no idea why vixen doesn't use gzipped text...
17:03:06 <dons> is the issue that there's wasted space, in each chunk, that gets GCd, or ?
17:03:11 <sorear> Lemmih: maybe binary should be changed to call 'copy' ?
17:03:12 <Saizan> http://paste.lisp.org/display/43942 <-- is there a way to avoid reverse in this function?
17:03:19 <dons> ?vixen hey
17:03:20 <lambdabot> hello
17:03:26 <dons> ?vixen do you like haskell?
17:03:27 <lambdabot> Ooh, functional programmers are so hot!
17:03:30 <dons> that's so true!
17:03:33 <dons> welcome back
17:03:43 <dons> SamB: note dlist 0.3 is on hackage.
17:03:49 <ihope_> Saizan: what's it do?
17:03:52 <SamB> dons: 0.*3*?
17:03:54 <edwardk> @where dlist
17:03:54 <lambdabot> http://www.cse.unsw.edu.au/~dons/dlist.html
17:04:02 <glguy> > let go f x = liftM2 (:) [x, f x] in foldr (go succ) [[]] [1,2]
17:04:05 <lambdabot>  [[1,2],[1,3],[2,2],[2,3]]
17:04:07 <dons> SamB: the version after 0.2
17:04:16 <dons> ?hackage dlist
17:04:16 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist
17:04:31 <Saizan> ihope_: it eliminates well, prune even [
17:04:35 <Lemmih> dons: Only one piece of information is available at a time.
17:05:03 <dons> Lemmih: oh, hmm. can you summarise the issue and mail out an example
17:05:19 <dons> depending on what you're doing, i can think of 2 ways to solve it
17:05:22 <ihope_> Saizan: ...does what?
17:05:43 <Saizan> ihope_: an example: prune (==) [1,2,2,1,3,4] == [3,4]
17:05:56 <edwardk> ah
17:06:10 <Lemmih> dons: Yep, will do that after a bit of sleep.
17:07:12 <SamB> dons: what's new in 0.3?
17:07:30 <dons> your patch, more tests. some optimisations. nothing much else
17:07:46 <SamB> okay.
17:07:49 <Saizan> ihope_: it eliminates adiacent elements for which p is true, and surrounding ones too
17:08:01 <SamB> so did you get rid of the download for 0.1 on your dlist page?
17:08:08 <Cale> Saizan: an element x is removed if there is any other element y in the list such that f x y ?
17:08:11 <Saizan> ihope_: if p is true for them as well
17:08:11 <monochrom> Talk about collateral damage :)
17:08:17 <dons> yup
17:08:22 <dons> it just points to hackage now
17:08:24 <Cale> er, hmm
17:08:47 <ihope_> Saizan: remove adjacent elements repeatedly?
17:08:50 * SamB wonders if he can do releases too now
17:08:50 <Saizan> Cale: no, they have to be adiacent, prune [1,2,2,3,1] = [1,3,1]
17:09:23 <Cale> okay
17:09:24 <Saizan> ihope_: yeah, those for which p is true
17:09:35 <ihope_> Hmm...
17:09:54 <SamB> dons: so do you think that it is a good idea to put vixen's data in a text format?
17:10:12 * glguy thinks the prune function would make for a good use of Cont :)
17:11:07 <Saizan> glguy: can you elaborate?:)
17:11:23 <glguy> Saizan: I'm making an example
17:11:40 <Saizan> k
17:12:19 <SamB> actually, even non-gzipped text would save *space*
17:12:35 <oerjan> what about pruning with an Either?
17:12:52 <SamB> as well as being nicer looking
17:13:00 <SamB> and easier to edit
17:13:01 <Saizan> oerjan: whet do you mean?
17:13:07 <oerjan> no wait
17:13:14 <SamB> and not needing much in the way of migration
17:14:41 <oerjan> returning Left or Right according to whether something was removed from the beginning
17:14:46 <SamB> (though perhaps with pretty-printing it wouldn't actually save space...)
17:14:47 <Saizan> my implementation is inspired by the list zipper, the problem is that at the end i find myself  with everything reversed on the "left"
17:15:10 <SamB> (but it would be much more darcs friendly ;-)
17:16:25 <oerjan> hm the problem is there is no way to return anything until you have reached the end of the list
17:16:39 <dons> SamB: probably just leave as is now.
17:16:45 <Toxaris> oerjan: yes prune is inherently strict
17:16:54 <SamB> dons: it's not very edit-friendly though ;-)
17:17:21 <oerjan> so there may not be any point in avoiding the reverse anyhow
17:18:04 <oerjan> since you would just end up keeping the same information on the stack
17:18:08 <Cale> You could express it as a fixed point, testing for equality of results after each pass, though that might be a bit less efficient.
17:18:10 <oerjan> i think
17:18:19 <Cale> (It would be clearer though)
17:20:08 <Saizan> Cale: yes, that'll repeat some useless comparisons
17:20:23 <Toxaris> but oerjan's idea seem better
17:20:50 <Toxaris> by returning at every step if something changed or not, the fixpoint should be reached efficiently
17:21:01 <Toxaris> like term normalization by rewriting rules
17:21:33 <oerjan> except reducing from the end may not give the same result?
17:21:50 <Saizan> but i don't know if an elemnt has to be eliminated in the same order that it appears in the list
17:21:53 <oerjan> or will it?
17:22:26 <oerjan> well, it won't unless p is an equivalence relation, at least
17:22:49 <ricky_clarkson> Does QuickCheck use random values?  If so, can you make it repeat the same ones?
17:23:21 <Toxaris> consider prune (\x y -> True) [1, 2, 3]
17:23:44 <Toxaris> should it return [1] or [3]?
17:23:47 <Toxaris> or even []?
17:23:47 <dibblego> as random as the Arbitrary instance for the type, but why would you repeat the same values?
17:23:58 <dibblego> ?src Arbitrary
17:23:58 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
17:24:42 <ricky_clarkson> Suppose QC found a problem, you might fix it and then want to rerun with the same values to see whether you fixed it at least for those values.
17:24:56 <dibblego> a second run might give the same values again
17:25:10 <dibblego> you can alter how exhaustive QC is in its test application
17:25:12 <dibblego> per run
17:25:21 <oerjan> ricky_clarkson: if you select the same seed for the random number generator
17:25:28 <Saizan> btw: prune = fix pr where pr f p = concat . filter (not . even . length) . groupBy p
17:26:47 <dons> ricky_clarkson: yep, yep.
17:26:55 <dons> give it the same seed
17:28:05 <Saizan> err no, it isn't
17:29:22 <oerjan> prune is very sensitive to the order in which you prune
17:29:34 <oerjan> always taking the first possible pair
17:29:43 <monochrom> Eh?! "pr f p = concat . filter (not . even . length) . groupBy p"  doesn't seem to use f at all.
17:30:21 <Saizan> monochrom: exactly :D
17:31:32 <oerjan> i'm starting to think the pasted source is pretty optimal...
17:32:17 <oerjan> oh except:
17:32:29 <Saizan> uhm, you can code this with the same strategy of bubble sort: make only local changes and if you have changed something, recurse
17:32:36 <oerjan> i don't see why prune' needs to return its second part
17:33:04 <oerjan> it's always [] anyhow
17:33:14 <Saizan> oerjan: only at the end
17:33:44 <Saizan> that's the part of the list prune' has not yet traversed
17:33:52 <oerjan> i mean, prune' never returns anything but (_, [])
17:34:19 <oerjan> the interesting uses of yss are only passed as arguments
17:35:45 <Saizan> oerjan: ooh, you're right, it's tail recursive
17:37:10 <oerjan> in fact you could probably easily remove the prune vs. prune' distinction
17:37:35 <oerjan> by moving the last case first, and putting the reverse into the remaining
17:38:25 <Toxaris> about prune's strictness: prune (==) [1, 2, _] = 1 : _
17:38:36 <Toxaris> but this is most likely not helpfull
17:39:12 <oerjan> i don't see that. i think it is _, or have you tested?
17:39:37 <Toxaris> i mean: it could be
17:40:14 <Saizan> nah, it can't, because you could have [1,2,2,1]
17:40:21 <oerjan> hm you may be right, if it checks length...
17:40:35 <Toxaris> Saizan: [1, 2, _] is not 1:2:_
17:41:12 <Saizan> Toxaris: ah, i didn't thought of checking the length
17:41:59 <SamB> @tell JohnMeacham that JHC seems to forget to keep "foreign export"s around
17:41:59 <lambdabot> Consider it noted.
17:44:53 <dons> yow, http://research.microsoft.com/%7Esimonpj/papers/list%2Dcomp/
17:44:54 <lambdabot> Title: Comprehensive Comprehensions
17:45:01 <dons> http://programming.reddit.com/info/23ktw/comments
17:45:02 <lambdabot> Title: Comprehensive comprehensions: Haskell list comprehensions for SQL queries (reddi ...
17:46:08 <SamB> did I hear someone say LINQ?
17:46:10 <Cale> uh, that's odd
17:46:14 <dons> maybe we can get monad comprehensions back in this mix somewhere
17:46:18 <Cale> Module `Data.Sequence' does not export `:>'
17:46:23 <Cale> what?
17:46:30 <sorear> Cale: |> ITYM
17:46:41 <dons> yeah, |> and <| iirc.
17:46:42 <Cale> It's a constructor of ViewR
17:46:55 <dons> yeah
17:47:06 <sorear> Oh
17:47:11 <sorear> Syntax.
17:47:14 <dons> Seq is exported abstractly, it seems
17:47:17 <Cale> oh, I see
17:47:24 <sorear> import Data.Sequence(  ViewR((:>)) )
17:47:26 <Cale> Just messed up my import decl
17:47:28 <sorear> Cale: ^^
17:47:30 <Cale> yes
17:47:30 <sorear> ah.
17:47:36 <dons> ah yes.
17:48:36 <dons> Cale: why not put a 'please bring back monad comprehensions' on the paper talk page..
17:49:28 <Cale> !paste
17:49:35 <SamB> @tell JohnMeacham either that, or FromHs just doesn't generate the entry functions...
17:49:35 <lambdabot> Consider it noted.
17:50:19 <Cale> http://paste.lisp.org/display/43945
17:50:21 <sorear> @seen shapr
17:50:21 <lambdabot> shapr is in #xmonad, #haskell-blah, #haskell and #scannedinavian. I don't know when shapr last spoke.
17:50:31 <Cale> There's a hack at prune using Data.Sequence
17:50:58 <sorear> Anyone else want to host hpaste until shapr returns?
17:51:15 <Cale> dons: paper talk page?
17:51:24 <dons> http://haskell.org/haskellwiki/Simonpj/Talk:ListComp
17:51:25 <lambdabot> Title: Simonpj/Talk:ListComp - HaskellWiki
17:51:41 <sorear> @users
17:51:41 <lambdabot> Maximum users seen in #haskell: 354, currently: 304 (85.9%), active: 13 (4.3%)
17:51:56 <Cale> dons: btw, if anyone implements them, Simon says he'll accept the patch to GHC.
17:52:16 <dons> i know :)
17:52:17 * sorear wishes he understood ghc well enough
17:52:19 <Cale> But of course, there's that little problem with MonadZero :)
17:52:42 <Cale> I wonder if we could get MonadZero back by holding him to that :)
17:52:52 <sorear> Maybe!
17:53:12 <Cale> Maybe indeed!
17:53:59 <SamB> is it that hard to get MonadZero back?
17:54:25 <Cale> SamB: Well, it requires messing with the base libraries in H98-breaking ways.
17:54:54 <Cale> Then again, it's not like they conform to H98 *exactly* as it is.
17:55:11 <SamB> http://repetae.net/john/recent/out/classalias.html
17:55:12 <lambdabot> Title: Class Alias Proposal for Haskell
17:55:23 <sorear> Cale: gcc/glibc have some ... interesting interactions such that when you pass -ansi, the prototypes for non-ANSI library functions vanish.
17:55:29 <Cale> Yes, life would be better with class aliases.
17:55:36 <sorear> Cale: maybe a similar hack could be implemented for ghc +98
17:55:41 <OceanSpray> It's nice knowing that everything I say in this channel is being meticulously recorded.
17:55:50 <sorear> Indeed.
17:56:18 <SamB> well, with ghc it's actually easier.
17:56:33 <SamB> see, the modules have *different names* from in Haskell 98
17:56:38 <Cale> I suppose we could keep two copies of the base package :)
17:56:54 <dolio> Prelude doesn't, though.
17:57:01 <sorear> Cale: cpp! :)
17:57:05 <SamB> what does Prelude do that isn't Haskell 98?
17:57:22 <Cale> Oh, also, doing it right involves making an incompatible change to do-desugaring.
17:57:28 <dolio> I don't know, but if you removed 'fail' from Monad, that'd be a break.
17:57:40 <Cale> and that.
17:57:44 <SamB> anyway, you'd need Class Aliases to be compatible with existing code...
17:58:06 <Cale> How much code actually uses fail directly?
17:58:14 <sorear> dolio: so we provide base98, with the old Monad; when you pass +98 to ghc, the old do-desugaring is used and the base98 versions of modules are used
17:58:14 <SamB> in future, I hope GHC *does* essentially ship with two base packages
17:58:31 <Cale> sorear: yes!
17:58:41 <SamB> you people may be overcomplicating this
17:58:44 <dolio> Yeah. I'm sure it's workable.
17:58:54 <Cale> That would be great. Then we wouldn't have to worry about making 98-breaking changes to the language.
17:59:00 <SamB> if we got class aliases, we wouldn't need to worry about that little desugaring issue
17:59:08 <Cale> In fact, I'd also like it if they did the same for H'
17:59:08 <mgsloan> how is the darcs code, messiness wise?
17:59:10 <dons> dcoutts_: we should resolve the mmapFile issue too
17:59:19 <dons> mgsloan: darcs itself?
17:59:26 <mgsloan> yep
17:59:31 <mgsloan> just curious
17:59:34 <dons> a tad messy, imo.
17:59:37 <mgsloan> ah
17:59:45 <dons> s/tad/ridiculously/ ?
17:59:48 <mgsloan> I was thinking Fuse + darcs might be fun
17:59:59 <sorear> dons: I agree.
18:00:04 <dons> i think they've looked at that in the past, too, mgsloan ?
18:00:09 * sorear has completely failed to understand darcs
18:00:12 <dons> since droundy's behind fuse.
18:00:13 <mgsloan> really? cool!
18:00:14 <dons> hfuse.
18:00:18 <mgsloan> right
18:00:28 <Cale> SamB: We want pattern match failure in do-blocks to use mzero though.
18:00:34 <dons> back when git was pimping the repo-as-filesystem idea
18:00:39 <SamB> Cale: I want them to use fail
18:00:48 <Cale> SamB: then set +98 ;)
18:00:50 <SamB> which would also be in the MonadZero package
18:01:05 <dons> someone could implement the rcs system in swiert et al's paper :)
18:01:05 <SamB> and would have a default implementation fail _ = mzero
18:01:12 <dons> i wonder how much work that would be.
18:01:18 <Cale> Oh, if fail was moved into MonadZero, that would be something else
18:01:25 <Cale> but you couldn't do that with class aliases.
18:01:28 <SamB> oh.
18:01:41 <dons> probably we missed the window for a darcs reimplementation though.
18:01:42 <mgsloan> dons - is that that one database thing.. ?
18:02:08 <dons> hmm?
18:02:27 <mgsloan> "swiert et al's paper"
18:02:43 <dons> that's the patch theory paper, which might make a clean slate model for a new darcs
18:02:44 <Cale> Saizan: did you see my Data.Sequence version of prune?
18:02:48 <mgsloan> ohh
18:04:51 <dons> dcoutts: how do c2hs binding interact with cabal/
18:05:19 <dons> is cabal *.chs aware, or do .chs files get pregenerated, say, for hackage hosting?
18:06:24 <dcoutts> dons: since .chs files are (at least potentially) platform dependent, cabal cannot include .hs files into source tarballs
18:06:24 <SamB> anyway, I think +98 is a bit course of an option...
18:06:41 <mgsloan> dons - where might i find this paper
18:06:43 <dcoutts> dons: unlike say for alex & happy where it can and does
18:07:06 <dons> isn't it like the issue with .hsc files?
18:07:20 <dcoutts> dons: what issue with hsc files ?
18:07:21 <dons> .hsc requires hsc2hs, which cabal knows how to run. we'd need the same with *.chs files?
18:07:30 <dcoutts> it should be the same
18:07:37 <dcoutts> cabal is .chs aware in as much as it calls c2hs with the right args
18:07:39 <dons> does cabal know about .chs files?
18:07:40 <dons> ah ok.
18:07:42 <dcoutts> yes
18:07:55 <dcoutts> it passes the .h files along etc
18:08:01 <dons> yes, so if i build repos of .chs files, that's fine for hackage, and only requires that users have c2hs already
18:08:06 <dcoutts> right
18:08:10 <dons> meaning we need c2hs in debian , and on hackage
18:08:15 <dcoutts> yes
18:08:27 <dcoutts> which means we need a release :-)
18:08:38 <blakkino> does someone know why when compiling gtk2hs i get errors (from gcc, it seem) like "multiple definition of `funcname`..." ?
18:08:39 <dcoutts> which means making the testsuite run
18:08:51 <dcoutts> blakkino: got more detailed info ?
18:09:08 <blakkino> dcoutts, i just get many of these errors
18:09:12 <dons> dcoutts: i get the following running c2hs on its tests examples:
18:09:13 <dons> $ c2hs Calls.chs
18:09:13 <dons> ("Calls","","Calls.chs.h","Calls.chs.h","Calls.i")
18:09:13 <dons> cc1: stdout: Resource temporarily unavailable
18:09:15 <blakkino> all version of gtk2hs i could try
18:09:19 <dons> c2hs: Error during preprocessing custom header file
18:09:24 <blakkino> ghc 6.6
18:09:29 <dcoutts> blakkino: is it an error or a warning ?
18:09:45 <blakkino> this is an error
18:09:46 <dcoutts> is hpaste back up?
18:09:52 <dcoutts> @paste
18:09:52 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:10:00 <dcoutts> ah, not yet
18:10:02 <blakkino> dcoutts, it is the same error you meet when you compile two .c files with the same function
18:10:06 <blakkino> you get an error from the linker
18:10:18 <dcoutts> blakkino: I'm looking for somewhere you can paste the error for me
18:10:20 <blakkino> there are many (> than 1000) of these..
18:10:21 <sorear> blakkino: what is `funcname` ?
18:10:40 <blakkino> http://rafb.net/p/VkougA22.html
18:10:41 <sorear> examples please!
18:10:41 <lambdabot> Title: Nopaste - No description
18:10:48 <dcoutts> dons: hmm, looks like some stray debug output?
18:11:22 <sorear> blakkino: mmh, what GHC version are you using?
18:11:28 <blakkino> http://rafb.net/p/FnsdOp99.html
18:11:29 <lambdabot> Title: Nopaste - No description
18:11:32 <sorear> blakkino: looks like a fairly old one from the name mangling
18:11:34 <blakkino> many of these
18:11:57 <blakkino> # ghc --version
18:11:58 <blakkino> The Glorious Glasgow Haskell Compilation System, version 6.6
18:12:10 <blakkino> will try to get the exact version
18:12:11 <dcoutts> blakkino: what platform are you on?
18:12:17 <blakkino> linux, x86_64
18:12:22 <blakkino> archlinux
18:12:53 <dcoutts> blakkino: so it's failing linking c2hs. Here's one thing you can try, ./configure --disable-split-objs
18:12:54 <blakkino> gtk2hs-0.9.11.tar.gz and the version from darcs
18:13:23 <blakkino> ok
18:13:42 <dcoutts> blakkino: what version of gcc and binutils have you got on archlinux ?
18:14:08 <blakkino> gcc 4.2.0, binutils 2.17
18:15:08 <dcoutts> dons: so cc1 is having trouble writing to its stdout, that's a little unfortunate. That can happen when a haskell prog launches gcc since ghc sets its stdout into non-blocking mode which confuses many progs.
18:15:18 <dcoutts> dons: but I've never seen c2hs cause that
18:15:42 <dcoutts> dons: could be that gcc is producing a high rate of error/warning output
18:15:52 <dons> hmm. ok.
18:16:40 <sorear> dcoutts: that's actually been "fixed" in GHC 6.7, ghc now uses a different mechanism (pthreads I think) to avoid blocking on fds 0-2
18:17:38 <dcoutts> dons: I can't find that debug output you've got there, you're using the latest darcs version right?
18:17:44 <dons> yep
18:17:52 <dons> i'll double check
18:18:01 <blakkino> dcoutts, it is going well for now..
18:18:03 <dons> http://darcs.haskell.org/c2hs ?
18:18:06 <lambdabot> Title: Index of /c2hs
18:18:19 <dons> built with cabal, dcoutts ?
18:18:26 <dcoutts> dons: yes, and yes
18:18:36 <blakkino> ops.. error
18:18:38 <blakkino> cairo/Graphics/Rendering/Cairo.hs.pp:240:0:
18:18:38 <blakkino>     Failed to load interface for `Graphics.Rendering.Cairo.Types':
18:18:38 <blakkino>       Use -v to see a list of the files searched for.
18:18:39 <dcoutts> dons: I've clearly left in some debug output related to deciding what the output filenames should be
18:19:04 <dcoutts> blakkino: that looks like a symptom of an earlier error, look back up through the log
18:20:40 <blakkino> <no location info>:
18:20:40 <blakkino>     can't find file: cairo/Graphics/Rendering/Cairo/Internal/Surfaces/SVG.hs
18:20:44 <blakkino> there are some of these
18:21:36 <blakkino> make[1]: *** No rule to make target `cairo/Graphics/Rendering/Cairo/Internal/Surfaces/SVG.hs'.  Stop.
18:21:37 <blakkino> make[1]: Leaving directory `/root/gtk2hs'
18:21:49 <dcoutts> blakkino: doh! I've left out a file from the darcs repo.
18:22:00 <dcoutts> blakkino: but that's not related to the linker errors.
18:22:14 <blakkino> you working on gtk2hs? nice :)
18:22:14 <dcoutts> blakkino: lemme add it, I'll tell you when to darcs pull
18:22:35 <dcoutts> blakkino: I'm one of the maintainers, hence why I'm concerned with it not building :-)
18:24:37 <blakkino> maybe you left out some cairo files?
18:24:44 <dcoutts> yes SVG.chs.pp
18:26:50 <glen_quagmire> is there something that creates thread instead of iterating through list when I use map?
18:27:07 <glen_quagmire> if list l has n elements, map will call the function n times
18:27:22 <glen_quagmire> but instead, create n threads and call f once per thread
18:27:58 <dons> parMap ?
18:28:02 <Cale> parMap
18:28:06 <dons> in Control.Parallel.Strategies
18:28:35 <dons> ah, another paper i'd not seen,
18:28:36 <dons> http://programming.reddit.com/info/23l1n/comments
18:28:36 <dcoutts> blakkino: ok, darcs pull and make
18:28:37 <lambdabot> Title: Feedback directed implicit parallelism in Haskell: squeezing more out of your co ...
18:28:44 <blakkino> ok
18:28:45 <glen_quagmire> oh
18:28:54 <glen_quagmire> I was just wondering if that kind of compiler is already there
18:29:09 <dons> glen_quagmire: to automatically find the parallelism?
18:29:21 <dons> for some types (distributed arrays), yes. otherwise you can put in hints, like parMap
18:29:22 <glen_quagmire> yes and automatically use threads
18:29:40 <dons> or at the lowest level, you can use forkIO and threads manually -- but that's like using malloc manually :)
18:29:42 <dcoutts> dons: can you send/post me your example file
18:29:53 <dons> dcoutts: oh, that was just from the c2hs tests file
18:29:59 <dcoutts> oh ok
18:30:01 <blakkino> dcoutts, will go with ./configure --disable-split-objs --with-hcflags=-O0, ok?
18:30:16 <dcoutts> blakkino: ok
18:30:27 <dons> glen_quagmire: so you can view it a bit like memory management in the 80s
18:30:41 <dons> you can do your own, (malloc/free), which corresponds to using forkIO and MVars
18:31:01 <dons> or you can get hinted memory allocation:  Control.Parallel.parMap
18:31:07 <Cale> dons: No, writing your own scheduler like that recent paper would let you do is like using malloc directly :)
18:31:22 <dons> or you can get fully automatic, but only for some restricted types currently: using distributed arrays
18:31:33 <dcoutts> Cale: surely that's like writing your own malloc :-)
18:31:34 <dons> yeah, and writing your own scheduler is like really really writing your own malloc :)
18:31:40 <dcoutts> ;-)
18:31:41 <ihope_> Okay, this: http://okmij.org/ftp/Haskell/Zipper1.lhs
18:31:49 <dons> so the big question is: can we do for threads, what GC does for memory management?
18:32:01 <glen_quagmire> yes that's the question
18:32:04 <ihope_> Are promptP and shiftP the same as reset and shift, respectively?
18:32:15 <dons> dcoutts: and the other question: can we tear out gang threads from ndp, and add Data.ByteString.Parallel on the cheap? :)
18:32:19 <Cale> mm, I was likening using malloc directly to writing your own garbage collector to writing your own scheduler
18:32:21 <glen_quagmire> so thi is a hot topic
18:32:41 <dons> glen_quagmire: yep. since 64 cores won't be usable *unless* we can abstract out all the threading
18:32:52 <dcoutts> dons: hmm, that's how we did the first paper, steal an idea from ndp, and then do it quicker in a simple case :-)
18:32:58 <dons> exactly!
18:33:06 <dons> we don't need to worry about flattening
18:33:17 <dons> or special array syntax
18:33:21 <dcoutts> or closure conversion or ... etc etc
18:33:35 <dons> we just provide the combinators, but if you've imported Data.ByteString.Parallel, you've got a 16-way parallel map/fold/etc.
18:33:42 <dcoutts> heh
18:33:51 <dons> seems like a pretty cheap paper ..
18:33:58 <dcoutts> we'd need a fold for associative operators
18:34:01 <Saizan> Cale: re Seq prune: seen it now, very nice, fromList is O(n)?
18:34:08 <Saizan> ?docs Data.Sequence
18:34:09 <lambdabot> Data.Sequence not available
18:34:10 <dcoutts> to be able to do the parallel log n reduce
18:34:18 <dons> dcoutts: we really could do this, you know. Parallel bytestrings.
18:34:29 <dons> we've got the machine, the people, the know how. just implement, benchmark, make haskell a lot faster.
18:34:38 <Cale> Saizan: yeah, it does cost quite a bit to do that conversions unfortunately
18:34:45 <Cale> the*
18:35:06 <dons> dcoutts: it would benefit a lot of people too. and give erlang a kick.
18:35:17 <dcoutts> dons: mm, I'm not sure, much of the stuff we do with bytestrings looks serial to me
18:35:41 <dcoutts> dons: do we have any examples that would benefit?
18:35:43 <dons> map/filter is pretty common. fuse, then parallelise, then reduce.
18:36:04 <dons> print . sum . lines
18:36:27 <dcoutts> lines parallelises a bit I suppose
18:36:34 <dons> just having basics like map, filter, fold would be worth it though.
18:36:47 <dons> so you could parallelise bits of your bytestring processing
18:37:22 <dcoutts> dons: do we have any time for the next paper? I feel like we're both snowed under with work.
18:38:19 <dons> yeah. we need to set up a shared calendar, put in some gaps for the binary paper, and then another one (like parallel bytestrings).
18:38:32 <dons> nothing'll happen in the next 8 weeks though
18:38:51 <dcoutts> dons: when do you expect to finish writing up?
18:39:00 <dcoutts> dons: oh and the corrections to the current paper
18:39:14 <dons> so we need to do that next week.
18:39:18 <dcoutts> yes
18:39:21 <dons> i'll be mostly done by Aug 31, i think.
18:39:25 <dcoutts> cool
18:39:33 <dcoutts> when do you start the new job?
18:39:38 <dons> so we could do the binary paper in Sept for hmm when's the PADL deadline... ? August ?
18:39:44 <dons> Sep 5 or so.
18:39:58 <dcoutts> right, erm padl deadline...
18:40:02 <dons> maybe we could hack the parallel bytestrings at ICFP.
18:40:07 <dcoutts> sounds fun
18:40:27 <dcoutts> I also want to do unicode, fusible all three encodings
18:40:37 <dons> i'll see if i can whip up some conference details/project ideas, so we can sync our schedules
18:40:56 <dcoutts> I want to show that it's easy, since we can do it all at the stream level and just define three to/fromStream functions for the three encodings
18:41:01 <dons> yeah, i really want to take on the bit syntax/network stuff from erlang too
18:41:06 <dons> yeah
18:41:37 <dons> ok. we'll just have to coordinate a bit, and plan ahead. works for spj, so i guess we can do it too :)
18:41:46 <dcoutts> @arr!
18:41:46 <lambdabot> Aye Aye Cap'n
18:41:50 <dons> @yarr!
18:41:50 <lambdabot> Aye Aye Cap'n
18:41:54 <dons> oi!
18:41:56 <dcoutts> heh :-)
18:41:58 <SamB> somebody implemented something called bitsyntax already
18:42:07 <dons> yup. TH though
18:42:38 <SamB> @google bitsyntax
18:42:40 <lambdabot> http://www.imperialviolet.org/binary/bitsyntax/
18:43:27 <SamB> though to find the actual source you probably want hit #5
18:43:47 <dufflebunk> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/BitSyntax-0.3  that?
18:43:49 <lambdabot> http://tinyurl.com/2m67ne
18:44:08 <SamB> yeah, that
18:44:44 <sorear> 18:40 < ghcbot> Build x86 Windows head #158 finished: Failure (failed pushchanges)
18:44:47 <sorear> YEAH!
18:44:56 <sorear> buildbot irc notification!
18:45:25 <dcoutts> sorear: I'm glad you're that pleased :-)
18:45:49 <dons> nice idea
18:45:50 <Igloo> dons: Is there any chance lambdabot could ignore URLs starting http://darcs.haskell.org/buildbot/ please?
18:45:51 <lambdabot> Title: GHC BuildBot
18:45:59 <sorear> Igloo: Why?
18:46:03 <sorear> @ignore + ghcbot
18:46:13 <sorear> Now everything ghcbot says is ignored.
18:46:33 <dons> you mean, not tinyurl-ing them?
18:46:38 <Igloo> Yup
18:46:39 <dons> or titleing them?
18:46:46 <LoganCapaldo> Hi everybody
18:47:03 <sorear> Igloo: why do you want those urls ignored?
18:47:07 <Igloo> Ignoring ghcbot will probably do, but it's really just noise whoever says it
18:48:40 <shachaf> Is there a version of takeWhile that keeps the first element that the function returns False for?
18:49:42 <oerjan> shachaf: span could be used
18:51:13 <blakkino> dcoutts, thanks you.. it seem working (with -O0 and split)
18:51:33 <blakkino> now i'm trying without -O0 and withot the split to test
18:51:47 <dcoutts> blakkino: ok, so I suspect some issue with ghc's splitobjs feature and your toolchain
18:52:46 <blakkino> yea.. without split i still get multiple definition of various stuff
18:52:48 <dcoutts> blakkino: I wonder if there's already a bug out on ghc and gcc-4.2.0 ...
18:53:22 <dcoutts> blakkino: try --with-hcflags="-O0 -fvia-C"
18:53:37 <oerjan> @pl \p -> (\(t,r) -> t ++ take 1 r) . span p
18:53:37 <lambdabot> (uncurry ((. take 1) . (++)) .) . span
18:53:43 <blakkino> now i'm trying without any specified --with-hcflags
18:53:56 <blakkino> (it is -O2 which imply -fvia-C, correct?)
18:53:57 <Igloo> dcoutts: There is
18:54:13 <dcoutts> Igloo: ah, I'll take a look
18:54:37 <ttmrichter> Where are common mathematical constants like pi and e defined in Haskell (if they are)?
18:54:45 <chessguy> @hoogle pi
18:54:46 <lambdabot> Prelude.pi :: Floating a => a
18:54:46 <lambdabot> Language.Haskell.TH.ClassOpI :: Name -> Type -> Name -> Fixity -> Info
18:54:46 <lambdabot> Data.Map.lookupIndex :: (Monad m, Ord k) => k -> Map k a -> m Int
18:54:53 <oerjan> > (pi, exp(1))
18:54:57 <lambdabot>  (3.141592653589793,2.718281828459045)
18:55:07 <ttmrichter> So "exp" is "e" then?
18:55:16 <chessguy> @src exp
18:55:17 <lambdabot> Source not found. It can only be attributed to human error.
18:55:24 <dcoutts> blakkino: http://hackage.haskell.org/trac/ghc/ticket/1427
18:55:25 <oerjan> exp n = e^n
18:55:25 <lambdabot> Title: #1427 (GHC fails to compile with gcc 4.2.0) - GHC - Trac
18:55:30 <Igloo> dcoutts: I don't think there's any useful info in it
18:55:37 <dcoutts> oh ok :-)
18:55:45 <ttmrichter> Thanks, oerjan, chessguy
18:55:50 <dons> i just updated the page on parallelism in haskell. if anyone can think of libraries or tools i missed, please add them: http://haskell.org/haskellwiki/Applications_and_libraries/Concurrency_and_parallelism
18:55:52 <lambdabot> Title: Applications and libraries/Concurrency and parallelism - HaskellWiki, http://tinyurl.com/2u95za
18:55:59 <Igloo> Other than that we know it's broken
18:56:09 <dcoutts> Igloo: do we know why exactly?
18:56:48 <dcoutts> ah, there's more detail in the debian bug
18:56:48 <blakkino> it is just a gcc 4.2 problem with ghc then
18:56:48 <Igloo> The object splitting markers aren't ending up in quite the same place
18:56:57 <dcoutts> blakkino: yes
18:57:21 <Igloo> I think the right thing to do is to use section attributes (IIRC), but it wasn't immediately obvious to me which things to decorate with them
18:57:24 <blakkino> your "split" has any drawback? :)
18:57:35 <dcoutts> blakkino: so sounds like it should work with -O1 but not the splitting
18:58:10 <dcoutts> blakkino: using splitobjs gives much smaller binaries, eg 300k vs >1Mb for any binary using Gtk2Hs
18:58:28 <dcoutts> blakkino: similarly if the standard base lib is built that way or not
18:59:17 <blakkino> ah.. ok..
18:59:22 <cdsmith> @paste
18:59:22 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:00:09 <cdsmith> Hmm.  hpaste says service is unavailable.  Is there another paste program around?
19:00:32 <dons> ?where lisppaste
19:00:32 <lambdabot> I know nothing about lisppaste.
19:00:38 <dons> ?google lisppaste
19:00:40 <lambdabot> http://paste.lisp.org/
19:01:11 <sorear> @seen shapr
19:01:11 <lambdabot> shapr is in #xmonad, #haskell-blah, #haskell and #scannedinavian. I don't know when shapr last spoke.
19:04:04 <ttmrichter> Type Float is an IEEE floating-point, so what is type Floating?
19:04:06 <cdsmith> Okay, so take a look at http://paste.lisp.org/display/43948.  Two options: (a) I'm going insane, or (b) there's a serious bug in GHC.
19:05:58 <oerjan> Floating is a class, not a type
19:06:10 <oerjan> Float and Double are instances of it
19:06:34 <oerjan> as is Complex Float and Complex Double
19:06:50 <oerjan> @src Floating
19:06:50 <lambdabot> class  (Fractional a) => Floating a  where
19:06:50 <lambdabot>     pi                                                      :: a
19:06:50 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
19:06:50 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
19:06:50 <lambdabot>     (**), logBase                                           :: a -> a -> a
19:07:07 <ttmrichter> OK, so Floating is the interface, Float/Double/et al are actual data types.  Got it.  Thanks again.
19:08:23 <Saizan> cdsmith: [a..b] == [] if a < b
19:08:42 <Saizan> > [5..2]
19:08:44 <lambdabot>  []
19:08:47 <Saizan> > [5,4..2]
19:08:50 <lambdabot>  [5,4,3,2]
19:09:12 <cdsmith> Saizan: okay... where does that fit into the puzzle?
19:09:28 <Saizan> comb n r   = product [n-r+1 .. n] `div` product [1..r]
19:10:08 <cdsmith> > product []
19:10:10 <lambdabot>  1
19:10:23 <Saizan> > let comb n r   = product [n-r+1 .. n] `div` product [1..r]; x = 23 in map (comb x) [0..x]
19:10:25 <lambdabot>  [1,23,253,1771,8855,33649,100947,245157,490314,817190,1144066,1352078,135207...
19:10:46 <cdsmith> I think that's what I want.
19:11:35 <cdsmith> In any case, the first two functions are only there because that's what's causing the failure... you can see that something's wrong regardless of the definition of comb and small
19:14:04 <oerjan> well, small 23 and smallrow 23 seem inconsistent
19:14:32 <cdsmith> oerjan: Yes, that's what I'm thinking as well.  I just want a sanity check before I report the bug.
19:14:55 <oerjan> > comb
19:14:57 <lambdabot>   Not in scope: `comb'
19:15:10 <oerjan> @let comb n r   = product [n-r+1 .. n] `div` product [1..r]
19:15:11 <cdsmith> oerjan: comb is defined in the first line of the pasted code
19:15:15 <lambdabot> Defined.
19:15:31 <oerjan> @let small n    = length (takeWhile (<= 1000000) (map (comb n) [0..n]))
19:15:33 <lambdabot> Defined.
19:15:42 <oerjan> @let smallrow n = let q = small n in if q == (n + 1) then q else 2 * q
19:15:47 <lambdabot> Defined.
19:15:49 <oerjan> > small 23
19:15:51 <lambdabot>  10
19:15:59 <oerjan> > smallrow 23
19:16:01 <lambdabot>  24
19:16:05 <oerjan> :t small 23
19:16:07 <lambdabot> Not in scope: `small'
19:16:29 <cdsmith> Hmm.  let doesn't get along with :t, I guess.
19:16:41 <oerjan> > take 10 (map (comb n) [0..n])
19:16:42 <lambdabot>   Not in scope: `n'
19:16:43 <lispy> oh, comb reminds me of something i love about haskell syntax, you can now do: n `comb` k
19:16:47 <cdsmith> *Main> :t small 23
19:16:47 <cdsmith> small 23 :: Int
19:16:47 <cdsmith> *Main>
19:16:49 <lispy> > 5 `comb` 2
19:16:52 <lambdabot>  10
19:17:03 <lispy> although, i usually name it choose
19:17:09 <oerjan> what about smallrow?
19:17:13 <lispy> because then it matches how you say it
19:17:24 <cdsmith> oerjan: Int, as well
19:17:34 <lispy> :t div
19:17:37 <lambdabot> forall a. (Integral a) => a -> a -> a
19:17:41 <oerjan> > take 10 (map (comb 23) [0..23])
19:17:43 <lambdabot>  [1,23,253,1771,8855,33649,100947,245157,490314,817190]
19:18:05 <oerjan> > take 11 (map (comb 23) [0..23])
19:18:05 * SamB_XP_ really likes todays xkcd
19:18:06 <lambdabot>  [1,23,253,1771,8855,33649,100947,245157,490314,817190,1144066]
19:18:20 <cdsmith> @google xkcd
19:18:21 <lambdabot> http://xkcd.com/
19:18:21 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
19:18:36 <cdsmith> SamB: yeah, it's good
19:19:15 <cdsmith> If no one's got an explanation, I'll go write a bug report.
19:19:31 <oerjan> > let n = 23; q = small n in if q == (n + 1) then q else 2 * q
19:19:33 <lambdabot>  24
19:19:47 <SamB_XP_> cdsmith: you mean for :t not working with @let?
19:20:03 <cdsmith> No, I mean for the problem I pasted, that oerjan's looking at
19:20:06 <oerjan> > let n = 23; q = 10 in if q == (n + 1) then q else 2 * q
19:20:09 <lambdabot>  20
19:20:12 <SamB_XP_> oh
19:20:43 <oerjan> > print $ let n = 23; q = 10 in if q == (n + 1) then q else 2 * q
19:20:45 <lambdabot>  <IO ()>
19:20:49 <Saizan>  > let n = 23; q = small n in (small n,if q == (n + 1) then q else 2 * q)
19:20:52 <Saizan> > let n = 23; q = small n in (small n,if q == (n + 1) then q else 2 * q)
19:20:54 <lambdabot>  (24,24)
19:21:04 <oerjan> > print () >> let n = 23; q = 10 in if q == (n + 1) then q else 2 * q
19:21:06 <lambdabot>   add an instance declaration for (Num (IO b))
19:21:17 <Saizan> > small 23
19:21:19 <lambdabot>  10
19:21:28 <Saizan> > let n = 23 in small 23
19:21:30 <oerjan> > print () >> (return $ let n = 23; q = 10 in if q == (n + 1) then q else 2 * q)
19:21:30 <lambdabot>  10
19:21:31 <Saizan> > let n = 23 in small n
19:21:32 <lambdabot>  <IO Integer>
19:21:33 <lambdabot>  10
19:21:52 <oerjan> > print () >> (return (small 23))
19:21:54 <lambdabot>  <IO Int>
19:21:59 <oerjan> > print () >> (return (smallrow 23))
19:22:03 <lambdabot>  <IO Int>
19:22:25 <cdsmith> aha! Not that this explains anything, but adding fromIntegral to the beginning of small fixes it.
19:22:33 <cdsmith> Maybe an overflow of some kind?
19:23:11 <oerjan> > let n = 23 :: Int; q = 10 in if q == (n + 1) then q else 2 * q
19:23:13 <cdsmith> But we're nowhere near overflowing a 30-bit int
19:23:14 <lambdabot>  20
19:23:50 <cdsmith> Unless comb is overflowing!
19:23:58 <oerjan> > fromIntegral (small 23)
19:24:00 <lambdabot>  10
19:24:06 <oerjan> > fromIntegral (smallrow 23)
19:24:08 <lambdabot>  24
19:24:17 <sioraiocht> any UKers around?
19:24:18 <cdsmith> > comb 23 10 :: Int
19:24:19 <lambdabot>  -454
19:24:23 <LoganCapaldo> > fromIntegral (fromIntegral (fromIntegeral 3))
19:24:24 <cdsmith> Aha!
19:24:25 <lambdabot>   Not in scope: `fromIntegeral'
19:24:34 <LoganCapaldo> > fromIntegral (fromIntegral (fromIntegral 3))
19:24:36 <lambdabot>  3
19:24:43 <oerjan> oh right
19:24:54 <oerjan> those products are far too huge for Ints
19:24:58 <cdsmith> But why would it overflow in one case, but not the other?
19:25:00 <lispy> yeah, you can't just increase the precision by making the return value an Integer :)
19:25:23 <dcoutts> dons: I've removed that stray debug output, but the error with cc1 is still a bit odd
19:25:34 <oerjan> > map (comb 23) [0..23] :: Int
19:25:35 <lambdabot>  Couldn't match expected type `Int' against inferred type `[t]'
19:25:40 <oerjan> > map (comb 23) [0..23] :: [Int]
19:25:41 <dcoutts> dons: I certainly don't get it here, but your using openbsd there right?
19:25:42 <lambdabot>  [1,23,253,1771,8855,33649,100947,245157,-42297,521,-454,1,1,0,-1,0,0,4,-2,1,...
19:26:43 <oerjan> except it _should_ be Integer in comb
19:26:52 <oerjan> even inside small
19:27:06 <cdsmith> Oh, it overflows in smallrow because q is an Int, so the "q == (n + 1)"  forces n to be an int, which then forces the argument to small to be an Int as well.
19:27:07 <oerjan> unless... aha!
19:27:09 <dcoutts> dons: if you turn tracing on I expect you'll find it's the call to cpp/gcc -E that's the issue, in fact, try redirecting the stdout output to a disk file, that might give some insight
19:27:14 <oerjan> exactly
19:27:28 <cdsmith> Okay, so I guess that's all expected behavior, but just very odd.
19:27:36 <cdsmith> oerjan++
19:27:44 <oerjan> use genericLength then
19:27:55 * SamB_XP_ looks forward to the day when "hugs" is well known to mean "haskell user groups", not a fiddly haskell interpreter written in C...
19:28:00 <dcoutts> dons: c2hs -d trace calls.h Calls.chs
19:28:09 <oerjan> eh wait, that won't help
19:28:29 <cdsmith> oerjan: Well, fromIntegral is working
19:28:34 * dcoutts :: Sleep
19:28:48 <oerjan> er yes, it will
19:31:43 <oerjan> @let tyCheat x = print () >> return x
19:31:45 <lambdabot> Defined.
19:31:57 <oerjan> > tyCheat small
19:31:59 <lambdabot>  <IO (Integer -> Int)>
19:32:39 <lispy> where is the source of small?
19:32:49 <oerjan> it's from a @let
19:33:03 <oerjan> also, http://paste.lisp.org/display/43948
19:33:36 <oerjan> > tyCheat map
19:33:37 <lambdabot>  Add a type signature
19:33:45 <oerjan> hm, won't work with polymorphism
19:33:54 <lispy> oh, right, you need genericLength
19:34:16 <lispy> :t product
19:34:18 <lambdabot> forall a. (Num a) => [a] -> a
19:34:25 <lispy> :t comb
19:34:27 <lambdabot> Not in scope: `comb'
19:34:45 <oerjan> > tyCheat comb
19:34:46 <lispy> :t \n r -> product [n-r+1 .. n] `div` product [1..r]
19:34:48 <lambdabot> forall a. (Integral a) => a -> a -> a
19:34:49 <lambdabot>  <IO (Integer -> Integer -> Integer)>
19:35:01 <lispy> :t \n -> length (takeWhile (<= 1000000) (map (comb n) [0..n]))
19:35:03 <lambdabot> Not in scope: `comb'
19:35:19 <lispy> :t \n -> length (takeWhile (<= 1000000) (map ((\n r -> product [n-r+1 .. n] `div` product [1..r]) n) [0..n]))
19:35:21 <lambdabot> forall a. (Integral a) => a -> Int
19:35:28 <lispy> :t \n -> genericLength (takeWhile (<= 1000000) (map ((\n r -> product [n-r+1 .. n] `div` product [1..r]) n) [0..n]))
19:35:32 <lambdabot> forall a i. (Integral a, Num i) => a -> i
19:36:37 <lispy> (\n -> genericLength (takeWhile (<= 1000000) (map ((\n r -> product [n-r+1 .. n] `div` product [1..r]) n) [0..n]))) 10
19:36:40 <lispy> > (\n -> genericLength (takeWhile (<= 1000000) (map ((\n r -> product [n-r+1 .. n] `div` product [1..r]) n) [0..n]))) 10
19:36:42 <lambdabot>  11
19:37:10 <oerjan> @list eval
19:37:10 <lambdabot> eval provides: run let undefine
19:37:30 <ttmrichter> Is it allowed to have more than one module per source file?  And if so, how does one accomplish this?
19:37:38 <oerjan> ttmrichter: not that i know
19:38:13 <dibblego> anyone here use CUDA on a 64-bit ubuntu machine?
19:38:58 <oerjan> basically, compilers use the filename to find the module, so you would not be able to use it from anywhere other than that file
19:41:37 <oerjan> usually you can put the Main module in any filename somehow, since it is not imported from anywhere else
19:42:04 <ttmrichter> OK, when I'm being told that it can't find a file for a given module and that -v will tell me which files it probed for, why is it not listing anything when I start GHCi with -v?
19:42:19 <SamB_XP_> I don't think the report actually says anything against putting multiple modules in a file... but I've never heard of any implementation that supported it either...
19:42:48 <SamB_XP_> ttmrichter: good question!
19:42:56 <SamB_XP_> report a bug?
19:42:58 <SamB_XP_> @bug
19:42:58 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
19:43:46 <ttmrichter> Weird.  I just shut down my shell, re-opened it, typed exactly the same command line and got the list of files this time.
19:43:49 <ttmrichter> That's just odd.
19:44:34 <SamB_XP_> okay, so don't report a bug unless you can reproduce it ...
19:45:02 <ttmrichter> Yeah.  Unreproducible bugs are not the kind of thing that makes developers happy to see you.
19:45:17 <ttmrichter> I wonder what went on, though.
19:45:32 <oerjan> ghci not reloading properly _does_ sound like something i vaguely recall someone else mentioned the other day
19:46:17 <SamB_XP_> well, it's not so much about them not being happy to see you
19:46:35 <SamB_XP_> it's just that there isn't much point in bothering them with something that they can't really do anything about ;-)
19:51:04 <glguy> a friend of mine was telling me how great "The Pragmatic Programmer" was, anyone here read it?
19:51:48 <lispy> yes, and it's good
19:52:25 <lispy> it works like this, if you're not comfortable with the majority of the material in that book, you're not likely to do well as an 'industry' programmer
19:52:48 <lispy> so, of course it's nothing ground breaking, but it's good to read it to make sure you're up to speed
19:53:34 <SamB_XP_> what about a "commerce" or "residence" programmer?
19:53:42 <glguy> is it "language agnostic"?
19:53:51 <glguy> is that the correct term? :)
19:54:32 <lispy> glguy: basically, yeah.  I think they give a tiny bit of language specific advice, and several language inspired examples, but mostly i'd say it's agnostic
19:55:46 <SamB_XP_> I'd distrust it if it never gave any "language-specific" advice
19:55:53 <lispy> glguy: they talk more about creating code generators and when it's a good idea/bad idea to use them
19:56:02 <SamB_XP_> (most such advice is reusable anyway ;-)
19:56:13 <lispy> er not talk more about it, but that's one of the topics
19:57:35 <lispy> glguy: i recommend that book to all the new hires where i work
20:03:09 <SamB_XP_> lispy: do you loan it to them too?
20:08:19 <lispy> SamB_XP_: yeah, we have a copy in the office
20:10:34 <blackdog> how do i get hold of C variables like stdin from haskell land?
20:10:47 <oerjan> > stdin
20:10:48 <blackdog> i know how to wrap function calls, but am unsure how to grab variables
20:10:48 <lambdabot>   Not in scope: `stdin'
20:10:59 <oerjan> sheesh
20:11:46 <oerjan> System.IO.stdin
20:11:49 <oerjan> > System.IO.stdin
20:11:50 <lambdabot>   Not in scope: `System.IO.stdin'
20:11:53 <LoganCapaldo> @index stdin
20:11:53 <lambdabot> System.IO
20:12:03 <SamB_XP_> perhaps 'foreign import "stdio.h &stdin" Ptr CFILE'
20:12:08 <SamB_XP_> er.
20:12:12 <oerjan> (yeah i know it's not really relevant)
20:12:21 <SamB_XP_> foreign import "stdio.h &stdin" cstdin :: Ptr CFILE
20:12:31 <LoganCapaldo> (yeah stdin is a bad example)
20:12:42 <SamB_XP_> where you have to make up CFILE yourself
20:12:45 <LoganCapaldo> (but speaking parenthetically is fun)
20:12:47 <SamB_XP_> (probably a newtype of ())
20:13:11 <SamB_XP_> or would that be Ptr (Ptr CFILE)
20:13:19 <SamB_XP_> I guess it would be...
20:13:25 <oerjan> (we could separate subtopics by bracket type!)
20:13:46 <SamB_XP_> [here we can talk about bringing back monad comprehensions!]
20:15:19 <oerjan> [the opponents would have to use do blocks instead]
20:15:19 <blackdog> samB_XP_: are you sure about that syntax? I'm getting an error
20:15:38 <SamB_XP_> blackdog: not really ;-)
20:16:08 <oerjan> @where ffi
20:16:08 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
20:19:55 <SamB_XP_> foreign import ccall "errno.h &errno" errno :: Ptr CInt
20:20:09 <SamB_XP_> there, that's an example straight from section four
20:21:17 <blackdog> ah, thanks
20:21:45 <SamB_XP_> hopefully the syntax is mnemonic enough for you ;-)
20:22:52 <SamB_XP_> though I think that's probably actually a bad example, since errno these days tends to be a macro that calls an impure function to find the address of errno for the current thread...
20:23:00 <blackdog> eesh
20:23:06 <blackdog> maybe i should just wrap this on the C side. :)
20:23:18 <SamB_XP_> what are you up to?
20:23:28 <blackdog> trying to get a minimal haskell interface to graphviz going
20:23:36 <blackdog> then connecting it to HAppS
20:23:40 <SamB_XP_> oh. it has a library?
20:23:49 <blackdog> step 3. Profit!
20:23:51 * SamB_XP_ would have just called dot or whatever!
20:23:52 <blackdog> yeah
20:24:11 <blackdog> i don't want to incur the cost of a subshell
20:24:24 <SamB_XP_> "subshell"?
20:24:31 <blackdog> partly because i'm hoping it'll be big, and partly because my host starts killing processes at >20
20:24:40 <SamB_XP_> ah.
20:24:48 <blackdog> well, if you call out to dot in a shell, that's an extra process
20:24:49 <SamB_XP_> that's kinda sad :-(
20:24:50 <LoganCapaldo> instead you're incurring the cost of writing FFI code
20:24:54 <blackdog> yep.
20:25:02 <blackdog> i'm counting it as educational. :)
20:25:04 <SamB_XP_> LoganCapaldo: well, 20 processes is not many
20:25:16 <blackdog> my interface is not very large - i really just need to pass in a string and get one back
20:25:25 <blackdog> so i'm hoping the FFI stuff will be not too painful
20:25:44 <SamB_XP_> seen c2hs?
20:25:54 <blackdog> hey, is there a better way of finding where a symbol is defined than running nm recursively?
20:25:59 <LoganCapaldo> SamB, true. I was just making a "there ain't no such thing as a free lunch" type comment
20:26:16 <blackdog> yeah, i had a quick look - it seems a bit more complicated than i'm willing to deal with right now
20:26:34 <blackdog> i only need to call three or so functions, so just the FFI should be enough for now
20:33:17 <blackdog> ha. got the little bastard. nothing like an ugly C hack to brighten your day. :)
20:44:27 <diegoeche> Im a haskell noob can anybody help me?
20:45:05 <scook0> what's your trouble?
20:45:06 <diegoeche> Im trying to implement some metaheuristical algorithms
20:45:36 <diegoeche> ive started with random search
20:46:19 <diegoeche> that is basically a number of a swap inside a loop
20:47:04 <diegoeche> but it eats all my stack :(
20:48:08 <scook0> blowing the stack typically means too much laziness somewhere
20:49:01 <dibblego> too much laziness means you need to get off yo fat butt!
20:49:28 <scook0> i.e. computations are being delayed, so the program is accumulating thunks instead of doing work
20:50:22 <scook0> the trick is to make appropriate parts of the program more strict
20:51:42 <diegoeche> do notation is implicitly lazy?
20:52:03 <ttmrichter> How do I raise numbers to fractional powers in Haskell?  As in, say, v ^ 0.16 instead of v ^ 2
20:52:26 <dibblego> diegoeche, all strictness is explicit in Haskell
20:52:36 <scook0> diegoeche: well, (practically) all of Haskell is non-strict, which in practice means lazy
20:52:53 <dibblego> diegoeche, look at the seq and $! functions and strictness annotations (some are compiler extensions)
20:53:04 <scook0> ttmrichter: there are a few different exponent operators
20:53:08 <dibblego> diegoeche, many functions are inherently strict
20:53:11 <scook0> :t (^)
20:53:14 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
20:53:18 <scook0> :t (^^)
20:53:20 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
20:53:21 <scook0> :t (**)
20:53:23 <lambdabot> forall a. (Floating a) => a -> a -> a
20:53:37 <ttmrichter> Ah!  I guess the one I need is ** since v can be fractional.
20:56:36 <diegoeche> thanks! :D
20:57:10 <mm_freak> diegoeche: `do' is actually just syntactic sugar
20:57:22 <diegoeche> yes i know
20:57:47 <diegoeche> but Im doing a bind of a IO
20:57:52 <mm_freak> it's a wrapper around the ">>" and ">>=" operators and saves you a lot of indentation
20:59:28 <diegoeche> and maybe the "x <- random" is the lazy thing
20:59:36 <mm_freak> it's all lazy
21:00:02 <diegoeche> haskell?? yes i know :P
21:01:55 <mm_freak> i meant, everything in a do construct is lazy =)
21:02:24 <mm_freak> it just happens that most of it needs to be evaluated right away, so it doesn't appear a lot lazy
21:03:47 <diegoeche> Im not very familiarised with this channel... can I put some code?
21:04:03 <diegoeche> are just 2 or three lines
21:04:19 <diegoeche> as usual :P
21:04:32 <shachaf> I understand that up to 3 lines is acceptable, though I'm not sure.
21:04:33 <mm_freak> then feel free =)
21:04:38 <shachaf> Given that hpaste is down...
21:05:14 <mm_freak> well, more than three lines get annoying, but IMO three lines are ok
21:05:46 * oerjan wonders how many lines we can use discussing how many lines we can use
21:06:23 <diegoeche> do newSol <- new
21:06:23 <diegoeche>      randomSearch problem (better (first(problem)) current newSol) (i-1)
21:06:45 <diegoeche> thats all
21:07:46 <diegoeche> thats the tricky part
21:08:03 <oerjan> no way to tell just from that how lazy it is
21:08:15 <diegoeche> is the do part that makes the recursion
21:09:13 <diegoeche> by calling randomSearch
21:09:29 <diegoeche> and better is a generalisation of max or min
21:09:39 <oerjan> try pastebin.ca
21:10:01 <oerjan> it all depends on how those functions are defined
21:10:52 <diegoeche> so... the problem could be anywhere?
21:10:56 <oerjan> yes
21:14:50 <diegoeche> i'll try to read a little bit more... I'll look the strctness annotations... thanks! :)
21:52:34 <mjk> ghc 6.6.1 how to support  utf-8
22:12:15 <Cale> Not *everything* in Haskell is lazy.
22:12:23 <Cale> Evaluating case is strict.
22:12:58 <Cale> It has to force evaluation of the value enough to determine which pattern matches, of course :)
22:13:20 <Cale> Hence, anything which does pattern matching is strict.
22:13:38 <desrt> head-strict
22:13:41 <Cale> You can write seq in terms of case, for specific types, and indeed, it used to be written that way.
22:13:52 <mm_freak> but case is almost equivalent to using guards
22:13:54 <Cale> (there was a typeclass)
22:14:12 <mm_freak> if one guard matches, the others don't need to be evaluated
22:14:37 <Cale> Yeah, and guards are forced too, good point :)
22:15:21 <Cale> At some level of desugaring, case is the only thing which causes evaluation (guards can be translated into a bunch of cases with matches on True and False)
22:17:32 <Cale> hmm, diegoche is gone.
22:17:42 <dons> re.
22:18:01 <dons> all the good stuff in haskell is either super-lazy, or partially strict
22:23:13 <dons> ok, some of the good things are fully strict too.
22:33:39 <mm_freak> well, lazy _should_ mean better performance, but unfortunately it usually means the opposite
22:33:53 <dons> it all depends.
22:34:12 <dons> you want to be a little strict -- the hardware likes cache-sized strictness
22:34:21 <dons> but not too strict, or your complexity goes out the door
22:36:27 <mm_freak> yeahâ¦  that's what i like about C:  even more control
22:37:13 <dons> laziness is a bit hard in C though. in most languages, actually.
22:37:27 <dons> whereas adding strictness in lazy languages seems to be relatively easy by comparison
22:37:58 <dibblego> yep, adding laziness is a PITA (I had this discussion earlier in the week with a colleague)
22:38:44 <mm_freak> dons: but in imperative languages, you just don't need laziness
22:39:30 <dibblego> yes you certainly do
22:39:38 <scook0> personally, adding strictness seems more like voodoo than adding laziness
22:40:03 <dibblego> adding laziness is soemthing I do all day long, in a language that even tries to be nice about it
22:40:29 <dons> mm_freak: sure you do! how do you think 'cat' runs in constant space? :)
22:40:49 <dons> or unix pipes, for example.
22:41:08 <mm_freak> dons: not a language issue =)
22:41:14 <dons> any sufficiently large data processing program contains an ad hoc implementation of lazy streams.
22:41:36 <scook0> it would be nice to see a strict language that was allowed to "cheat" to get some of the benefits of nonstrictness
22:41:38 <dons> mm_freak: sure it is: there's no support, so you have to roll your own 'laziness' pattern whenever you need O(1) space consumption
22:41:44 <johnnowak> scook0: define "cheat"?
22:41:59 <scook0> like non-strict "where" clauses and such
22:42:00 <dibblego> given a function with inherent strictness that is not decomposable, I must rewrite that function if I want laziness - the inverse is not true
22:42:11 <dons> or when its too hard -- e.g. lazy trees -- the C guy just gives up and lives with O(n) space
22:42:12 <dibblego> mm_freak, yes, you do, think iterators
22:42:26 <scook0> i.e. the compiler is allowed to not execute the where clause if it's not needed, but thunks aren't allowed to escape the function
22:42:51 <mm_freak> well, "laziness" in imperative languages doesn't make a lot sense
22:43:03 <dibblego> yes it does - it is emulated all the time, even by mediocre programmers
22:43:07 <mm_freak> it's subjective laziness
22:43:07 <dons> sure it does. perl just got lazy lists.
22:43:16 <dibblego> Java has imperative lazy lists
22:43:17 <dons> python's fakes them with hmm, yields and friends
22:43:25 <dibblego> http://java.sun.com/javase/6/docs/api/java/util/Iterator.html
22:43:25 <lambdabot> Title: Iterator (Java Platform SE 6)
22:43:28 <scook0> so you get the syntactic benefits of nonstrictness, but without the danger of leaking thunks
22:43:30 <dolio> C has lazy boolean operators.
22:43:42 <dons> laziness is just a very useful programming technique, in general.
22:43:48 <dolio> And you can declare lazy functions in D.
22:43:51 <johnnowak> mm_freak: pervasive laziness doesn't make sense due to side-effects, but some laziness used carefully can be very useful
22:44:12 <dons> yeah, pervasive laziness would be scary once you've got side effects roaming free
22:44:32 <johnnowak> scook0: in some sense, many strict languages "cheat" for things like short-circuit operators already
22:44:35 <dons> but, purely functional bits (like list generators) can happily be lazy
22:44:42 <dibblego> I have never seen even the dumbest Java programmer find the nth element of an Iterator in O(length(Iterator)) time, always in O(n) time
22:44:52 <dons> yeah, if-then-else is lazy, and magic. as are a lot of boolean ops.
22:45:07 <dons> you just, as a programmer, don't have access to that -- so you can't roll your own very easily
22:45:15 <johnnowak> well, magic in most imperative languages anyway. there are exceptions.
22:45:15 <scook0> johnnowak: sure -- I guess what I'm saying is that I'd like to see more of it :)
22:45:20 <dibblego> if-then-else is ? : in C and derivatives (and the same applies re lazy)
22:45:21 <johnnowak> scook0: aye. :)
22:45:52 <dibblego> > if True then 7 else error "foo"
22:45:54 <lambdabot>  7
22:46:04 <mm_freak> dons: it doesn't make sense in C
22:46:10 <mm_freak> where everything is by definition strict
22:46:13 <dibblego> mm_freak, yes it does
22:46:20 <dibblego> no everything is not
22:46:25 <dibblego> we just gave many examples
22:46:35 <mm_freak> whatever is lazy is just subjectively lazy
22:46:38 <dibblego> what does this do: 1 ? 7 : blowUp();
22:46:40 <johnnowak> mm_freak: operators like &&, ||, etc are not strict
22:46:46 <dibblego> does it blowUp?
22:46:53 <mgsloan> yes
22:46:55 <mm_freak> dibblego: it's still not lazyâ¦  it's a branch
22:47:01 <dibblego> mm_freak, yes, it is lazy
22:47:08 <mm_freak> just syntactic sugar for an `if'
22:47:13 <dibblego> if is lazy too
22:47:19 <dibblego> as three people said earlier
22:47:42 <dibblego> (but it's not exactly the same by the way)
22:47:59 <johnnowak> mm_freak: if is lazy in almost all imperative languages. those with things like fexprs or things like smalltalk that require manual thunkification are exceptions.
22:48:05 <mm_freak> but that's subjective lazinessâ¦  it just happens that it gets translated into a branch
22:48:12 <dibblego> scala> if(true) 7 else error("foo")
22:48:12 <dibblego> unnamed1: Int = 7
22:48:16 <mm_freak> if that is lazy, then C is a lazy language
22:48:19 <glguy> foldr (\x xs -> case xs of [] -> [x]; (y:ys) | x == y -> ys | otherwise -> x:xs) [] [1,2,2,1,3,4,4]
22:48:22 <glguy> foldr (\x xs -> case xs of [] -> [x]; (y:ys) | x == y -> ys | otherwise -> x:xs) [] [1,2,2,1,3,4,4]
22:48:25 <glguy> uhg :)
22:48:27 <glguy> > foldr (\x xs -> case xs of [] -> [x]; (y:ys) | x == y -> ys | otherwise -> x:xs) [] [1,2,2,1,3,4,4]
22:48:29 <lambdabot>  [3]
22:48:29 <mgsloan> so now 'lazy' means that something isn't evaluated?
22:48:31 <dibblego> there is nothing subjective about it - the bottom value there was not evaluated (otherwise, the whole function dies)
22:48:47 <dibblego> yes, C is a lazy language (at least, it is not entirely strict)
22:48:52 <dibblego> neither is Java
22:48:55 <dibblego> neither are many languages
22:48:56 <mgsloan> so my program is lazy, if some random code isn't executed?
22:49:30 <mgsloan> what if I put code in comments, or #ifdef SOMETHINGTHATDOESNTEXIST, is that lazy?
22:49:32 <johnnowak> mgsloan: not necessarily. dead code elimination might allow some code not to be run, programs might terminate early, etc
22:49:52 <mm_freak> dibblego: in other words, asm is the only strict language
22:49:59 <mm_freak> and brainfuck =)
22:50:02 <scook0> dibblego: on the other hand, all C functions are strict in their arguments
22:50:05 <mgsloan> even in asm you've got branches
22:50:18 <mm_freak> mgsloan: yes, but those are strict
22:50:23 <dibblego> mm_freak, no, ASM is (partially) lazy
22:50:29 <scook0> so there's a limit to what the programmer can do with nonstrictness
22:50:44 <mgsloan> what's the point of having the term 'lazy' if it applies to every language now, eh, diblle?
22:50:55 <glguy> Haskell isn't as lazy as it is non-strict. Being non-strict just means that some programs that would not have terminated will
22:50:56 <dibblego> scook0, in Scala, all arguments are strict, unless explicitly annotated with =>
22:50:58 <johnnowak> mgsloan: it only seems to in this discussion. :)
22:51:04 <mm_freak> well, then we could just say that there is nothing special about haskell's laziness ;)
22:51:08 <mm_freak> you get the point
22:51:32 <dibblego> mgsloan, I agree, abandon the terminology, it confuses people (evidence right here)
22:52:00 <dibblego> mm_freak, haskell is only partially lazy too, but that part is "a lot" to most people
22:52:05 <mgsloan> it only confuses when you stretch its meaning to crazy lengths
22:52:25 <dibblego> no, it confuses when people go around saying "C is not lazy"
22:52:27 <johnnowak> lazy and strictness are very much on a continuum, the sam way imperative and functional are
22:52:29 <dibblego> because this is a false statement
22:52:44 <mgsloan> that's only when you stretch it to crazy lengths >_<
22:52:45 <dibblego> it is, to a degree, lazy
22:52:48 <glguy> > foldr (\x xs -> case xs of (y:ys) | x == y -> ys; _ -> x:xs) [] [1,2,2,1,3,4]
22:52:48 <dibblego> absolutely not
22:52:50 <lambdabot>  [3,4]
22:52:57 <dibblego> if/else is not a "crazy length"
22:53:00 <dibblego> neither is && ||
22:53:01 <mgsloan> it is a true statement, for normal amounts of lazy
22:53:05 <johnnowak> dibblego: i've never seen anyone lapse into confusion when being told C is strict
22:53:07 <dibblego> there is no "normal amounts"
22:53:17 <mgsloan> haskell amounts
22:53:20 <dibblego> johnnowak, I hadn't either, until someone in #haskell said it a few minutes ago :)
22:53:40 <johnnowak> function evaluation in C /is/ strict. special forms are something else.
22:53:42 <mm_freak> dibblego: the problem is, if C is lazy, then every language is lazy
22:53:43 <Cale> Strict means innermost-first evaluation, lazy means outermost-first with sharing, and there are lots of things in between :)
22:53:52 <dibblego> I only propose we qualify with "C is mostly strict" to prevent the confusion that it has caused just now
22:53:55 <mm_freak> because you can translate any program into a C program
22:53:56 <dons> well put, Cale
22:54:06 <Cale> C is most certainly not lazily evaluated.
22:54:08 <dibblego> mm_freak, I am not suggesting it is lazy, it is not entirely strict
22:54:32 <mgsloan> so? nothing is, then
22:54:33 <dons> it has funny lazy operators, like :?. but you can't roll your own without implementing laziness.
22:54:37 <mgsloan> it's a useless distinction
22:54:50 <mm_freak> dibblego: but you almost can't write a strict C program that's any useful
22:55:11 <mm_freak> even "a || b" is lazy
22:55:20 <dibblego> mgsloan, it is useful if there is a higher-order level of communication, which you and I could perhaps use - but this has caused confusion (see earlier)
22:55:23 <Cale> The only places in C where you don't have innermost-first evaluation are in :?, if, and shortcutting boolean operators.
22:55:23 <mgsloan> strict in its normal sense is qualitative, and I think some of its qualitativeness applies in this scenario
22:55:31 <dibblego> mm_freak, you are agreeing now?
22:55:48 <Cale> Though, if is more of a control structure in C
22:55:56 <Cale> So I'm not sure if it even counts.
22:56:28 <mm_freak> dibblego: it is lazyâ¦  but IMO there is a difference between "lazy" and "subjectively lazy"
22:56:47 <mm_freak> just like there is a difference between "random" and "subjectively random"
22:56:48 <dibblego> so, Cale just enumerated what is lazy in C in one sentence, try doing that for Haskell - it is longer, therefore we might say "Haskell is more lazy", but for brevity, we might say "Haskell is lazy and C is not"
22:56:51 <Cale> A function is strict if when applied to an undefined value, it yields undefined.
22:56:57 <johnnowak> Cale: I think it only makes sense to talk about function evaluation. Any language that has a way to define a function would be lazy otherwise.
22:57:14 <dibblego> mm_freak, Cale gave a definition for lazy and strict earlier - would you mind adding with "subjectively lazy"?
22:57:22 <Cale> (In the sense of a nonterminating computation)
22:57:40 <dibblego> Cale, I gave that example earlier
22:57:53 <glguy> What specifically is being debated?
22:58:11 <dibblego> glguy, I am not clear now; there is a new notion of "subjective laziness", which I have never heard of
22:58:15 <johnnowak> glguy: nothing worth debating
22:58:18 <mm_freak> dibblego: it would take months to make a good definition of that
22:58:24 <Cale> I don't really know, I just see lots of very vague statements, and am randomly listing facts in order to calm things down :)
22:58:30 <mgsloan> glguy - dibblego thinks C, and every other language is lazy
22:58:38 <dibblego> no, dibblego doesn't think that
22:58:45 <mgsloan> :)
22:58:47 <dibblego> please do not misrepresent me with delusions
22:58:48 <glguy> dibblego: he said it yourself, you do
22:58:50 <mm_freak> hmm
22:58:57 <Cale> heh
22:59:01 <dibblego> C is not completely strict
22:59:03 <dibblego> Cale said it too
22:59:04 <mm_freak> in that sense, switch() is lazy, too, if it contains breaks
22:59:05 <johnnowak> "dibblego: yes, C is a lazy language"
22:59:07 <dibblego> everyone said it
22:59:18 <dibblego> johnnowak, I apologise and I qualified immediately after (mostly lazy)
22:59:24 <dibblego> er
22:59:28 <dibblego> (not entirely)
22:59:28 <glguy> dragging switch and if into a discussion on laziness doesn't make any sense
22:59:34 <Cale> dibblego: Only in the sense that there are a few special forms which are specially evaluated.
22:59:43 <glguy> that you can not define switch or if using C is what is important
22:59:52 <Cale> glguy: :? and ||, etc are more the issue
22:59:55 <mm_freak> i'd define it roughly like this:  subjective laziness is laziness, which comes from how things are interpreted
23:00:03 <dibblego> scala> if(true) 7 else error("bottom, non-terminating") // here is a C based language
23:00:03 <dibblego> unnamed1: Int = 7
23:00:09 <Cale> I don't think switch and if count, since they're control structures, and blocks aren't first class.
23:00:14 <dibblego> notice that function returned 7 and terminated
23:00:18 <mm_freak> while in haskell, laziness is something you work with directly all the time
23:00:23 <glguy> Cale: that you can't write a function that behaves like || is what counts then
23:00:33 <Cale> glguy: right
23:00:53 <dibblego> glguy, I will accept that
23:01:20 <glguy> so it's settled then? moving on... who else hates ruby?
23:01:30 <dibblego> perhaps you just did months of work :) (subjective laziness?)
23:01:36 <Cale> hates is a pretty strong word
23:01:55 <glguy> I hate what it does to my friends :)
23:02:05 <mm_freak> hehe
23:02:09 <dolio> Dude, everyone's doing it.
23:02:15 <dolio> Just try it.
23:02:18 <dibblego> what does it do?
23:02:19 <glguy> yeah, I don't like what pot does to friends either
23:02:23 <mm_freak> now in C every `lazy' construct can be simplified to a branch
23:02:26 <glguy> rots their minds
23:02:26 <Cale> Regarding C programs, if you want to talk about *simulating* the effects of laziness, there's quite a lot of that, and in order to do it, you basically have to turn your entire program inside out.
23:02:32 <mm_freak> in haskell laziness works differently
23:02:43 <dibblego> glguy, any specifics?
23:02:50 <mm_freak> expressions are only evaluated where needed
23:02:52 <glguy> they start spouting TLAs like TDD
23:02:56 <sorear> re.
23:02:58 <mgsloan> I know the argument has ended, but really, I think applying functional perspective to a language like C is pretty pointless.  code blocks aren't values to be evaluated.
23:03:03 <glguy> thinking that adding methods to Nil is a good thing
23:03:07 <mm_freak> take this example:  foldl (+) [] [1,2,3,4,5]
23:03:14 <Cale> mm_freak: a simpler way to put it is that expressions are evaluated outermost-first.
23:03:15 <dibblego> glguy, Nil is [] ?
23:03:21 <mm_freak> this gets simplified to: (1 + 2 + 3 + 4 + 5)
23:03:21 <glguy> telling me that their functions are an API because they left off the ()s
23:03:28 <glguy> dibblego: it's like null
23:03:30 <mm_freak> and then the result is calculated
23:03:38 <mm_freak> in C you wouldn't write it that way
23:03:42 <dibblego> mm_freak, not always :)
23:03:56 <dibblego> mm_freak, there are cases where you would indeed write it that way
23:04:04 <glguy> dibblego: suppose your program crashes because you called a method on Nil (null reference exception in other languages)
23:04:04 <dibblego> just that few people do
23:04:13 <glguy> why, you could just add a method to Nil so that doesn't happen
23:04:14 <dibblego> glguy, ew ew ew *shuts eyes*
23:04:14 <mm_freak> you wouldn't create an array which holds the individual summands (if you don't use them), would you? ;)
23:04:25 <glguy> dibblego: and this is a GOOD THING and we are GLAD TO HAVE IT
23:04:48 <mm_freak> there is almost no situation where you need to create that array
23:04:50 <dibblego> mm_freak, I think we should be finished, glguy's story is more interesting
23:05:00 <dibblego> what array?
23:05:02 <dolio> glguy: I don't think most ruby programmers would advocate that, would they?
23:05:11 <dibblego> it is a list (an iterator or whatever in C)
23:05:17 <dolio> glguy: Although I do remember a reddit story to that effect.
23:05:21 <glguy> dolio: a surprising number do
23:05:28 <dibblego> in fact, the canonical way of writing it, is ust like foldl'
23:05:34 <dibblego> with an in-place update and a loop
23:05:41 <mm_freak> hehe
23:05:45 <glguy> last tiem someone asked how to drop the first 3 characters from a string, the channel came up with using a regex
23:05:48 <dolio> glguy: In which the guy implemented #method_missing for nil, so that *any* function called on nil works, and return nil.
23:05:49 <glguy> /.{3}//
23:05:50 <Cale> Under lazy evaluation, foldl (+) 0 [1,2,3,4,5] will certainly reduce to ((((0 + 1) + 2) + 3) + 4) + 5, however, that's not necessarily what a Haskell implementation will do.
23:06:07 <Cale> Haskell's not required to be lazily evaluated, it's required to have non-strict semantics.
23:06:13 <dibblego> Cale, I think it depends on the type, e.g. sum is written in terms of foldl in constant stack
23:06:14 <glguy> dolio: yeah, the crap that they do with missing_method in the name of making the code read like english is crap
23:06:14 <mm_freak> dibblego: we could discuss that forever i guessâ¦  you're right, let's just skrew it =)
23:06:30 <Cale> It's not dependent on the type, it's dependent on the implementation.
23:07:35 <Cale> A compiler might do analysis and discover that the evaluation of that foldl will always need to be completely carried out in the program, and so it can rewrite the code to do strict evaluation.
23:07:44 <Cale> and that's okay, so long as you preserve semantics.
23:08:02 <mgsloan> or the compiler might decide it equals 15
23:08:05 <dibblego> Jun 22 10:56:01 <dons>  sum on Int, for example, does produce a tail call, due to strictness analysis
23:08:08 <dibblego> now I remember :)
23:08:40 <Cale> I suppose the type is moderately important to that analysis, but it's that the analysis is carried out at all that's the important point.
23:08:59 <dibblego> right
23:09:03 <dolio> glguy: And dropping the first three characters would be string[3,-1]
23:09:07 <Cale> If we're talking about lazy evaluation though, that's a very-well-defined thing, and it always proceeds in the same way.
23:09:15 <dolio> I think, that is.
23:09:21 <dibblego> no, we dropped that in favour of talking about Ruby :)
23:09:27 <dolio> Using a regex is crazy.
23:09:51 <glguy> dolio: yup, that's what  Itold them
23:09:59 <Cale> It simply reduces the outermost-leftmost reducible expression, and it shares the computation of values which came from the same function parameter.
23:10:20 <mgsloan> man, your mom's so lazy, I'm bouts to put strictness annotations on her ass
23:10:56 <dibblego> I think my days on reddit are over "Java EE 6 Gets it Right"
23:12:01 <glguy> dons: portland is pretty funny... the temperature got up to 90 today
23:12:14 <glguy> so they are having heat warnings on the news
23:12:19 <glguy> stories about how to stay cool
23:12:24 * mgsloan totally killed the laziness conversation :)
23:12:29 <glguy> reminding people that their pets aren't immortal
23:12:49 <dibblego> that is pretty funny
23:12:59 * glguy is used to St. Louis where is this the normal temp and the humidity is twice this
23:13:01 <dons> glguy: hah :)
23:13:12 <glguy> and they don't bitch about it every ay on the news ;)
23:13:25 <dibblego> yesterday was 78F and it's the middle of winter
23:13:29 <johnnowak> in all fairness, 90 is hot if one is not used to it. adaption to heat is physiological.
23:13:39 <glguy> I suppose...
23:14:07 <johnnowak> not to kill a good rant
23:15:28 <dolio> dibblego: It isn't that bad, is it? I enjoyed the 'Template Method' article.
23:15:28 <glguy> naw, I'm just being grumpy
23:15:40 <dolio> dibblego: It sounded like the 'I wish we had higher order functions' pattern.
23:15:53 <dibblego> dolio, that's what makes it bad, why not just say that?
23:16:01 <dolio> :)
23:16:37 <johnnowak> reddit reached eternal october awhile ago
23:16:50 <glguy> eternal october?
23:16:59 <opqdonut> reddit has never mattered
23:17:14 <dibblego> eternela September
23:17:30 <johnnowak> http://en.wikipedia.org/wiki/Eternal_September
23:17:31 <lambdabot> Title: Eternal September - Wikipedia, the free encyclopedia
23:17:39 <johnnowak> not sure how i managed to get the month wrong.
23:18:06 <dolio> Well, obviously October is even worse than September. :)
23:19:23 <dons> i think it happened back in Jan, when they added a link from the front page to the programming subreddit
23:19:35 <dibblego> is *that* what happened?
23:19:36 <dons> that killed .pdf, and the vaguely LtU thing we had going on
23:19:53 <dons> you don't have big discussions anymore
23:20:09 <dons> whereas it was an LtU-ish message board in some ways, before then
23:20:21 <dons> when everyone rushes in, the community is killed off
23:20:23 <dons> oh well
23:20:38 <glguy> PDF WARNING
23:20:59 <Cale> We need a new programming reddit.
23:21:00 <glguy> er even better: ZOMG I GOT HIT BY A PDF THNX FOR NO WARNING UGH
23:21:30 <dons> i mean, you can still find the odd language article on the programming reddit -- mostly from our community now. but the discussions have just evaporated
23:22:18 <glguy> now at least we have bash.org links
23:24:57 <jewel> what is/was .pdf?
23:25:24 <glguy> the ability to submit links to pdfs on programming.r.o
23:25:31 <glguy> portable document format
23:25:42 <xpika> ive compiled yi but when i try and execute yi.exe it says \driver\package.conf.inplaceas C:\ghc\ghc-6.6
23:26:42 <_mjk_> how to support utf-8 in ghc 6.6.1
23:26:49 <_mjk_> can anyone help me?
23:26:52 <_mjk_> thx
23:27:09 <glguy> You just need a function to encode / decode UTF and then you can use the normal System.IO
23:27:33 <glguy> There is a UTF.hs floating around somewhere
23:27:40 <glguy> (and it isn't hard to implement)
23:27:48 <mm_freak> direct support is only necessary to find character lengths and to do case conversion
23:28:03 <glguy> ghc-6.6.1 does support unicode though
23:28:05 <mm_freak> the former to count characters or to truncate strings
23:28:17 <glguy> it just doesn't support it in the functions like putStrLn and getLine
23:28:31 <xpika> glguy: is that a .1 feature?
23:28:35 <mm_freak> glguy: mostly it doesn't need to, actually
23:28:53 <glguy> Char is designe to hold a UTF-32 codepoint
23:28:56 <glguy> designed
23:29:04 <glguy> with a maxBound of 0x10ffff
23:29:29 <sorear> xpika: no, it's a .0 feature
23:29:53 <dibblego> @djinn (b -> c) -> (a -> b) -> a -> c
23:29:53 <lambdabot> f a b c = a (b c)
23:29:55 <xpika> isnt the issue with UTF that you cant print it because theres no guarentee the terminal will support the character?
23:30:09 <sorear> no.
23:30:28 <_mjk_> i use a chinese string and show it on display, but it show \123\178......,
23:30:38 <sorear> the issue with utf is mostly that peopl are too lazy to implement it
23:30:46 <glguy> _mjk_: that's because you used print instead of putStrln
23:31:27 <_mjk_> o
23:31:35 <_mjk_> like this
23:32:00 <_mjk_> data People = Person Name Age deriving Show
23:32:14 <_mjk_> type Name = String
23:32:14 <_mjk_> type Age = String
23:32:24 <_mjk_> name :: People -> Name
23:32:32 <_mjk_> name (Person a b) = a
23:32:36 <_mjk_> my func is
23:32:59 <_mjk_> f = name $ Person "Ð¡Íõ" 50
23:34:16 <_mjk_> when compile the file include the above codes, ghc will show "lexical error in string/character literal (UTF-8 decoding error )
23:35:37 <glguy> _mjk_: are you sure you are saving the .hs file with UTF-8 encoding?
23:36:11 <_mjk_> no, normal save it on a .hs file
23:36:32 <glguy> _mjk_: you just need to make sure you editor is saving the file correctly
23:36:45 <_mjk_> glguy: my computer instal WinXP chinese version
23:37:08 <glguy> _mjk_: ok, but the important thing is that your *text editor* is saving the file correctly
23:37:42 <_mjk_> i use editplus, it display chinese character is ok
23:37:53 <glguy> that doesn't matter
23:37:59 <glguy> what matters is that it saves it as UTF-8
23:38:12 <_mjk_> i try it
23:42:53 <_mjk_> glguy: save it to UTF-8, but it is still not to compiled
23:52:50 <vincenz> moin
23:55:20 <arcatan> plus
