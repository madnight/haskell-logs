00:00:30 <Arnia> Korollary: Ok, to use an example from the paper I'm writing, I want to be able to replace all paths of edges labelled ancestor -> sibling -> descendent with the edge cousin
00:01:16 <Arnia> So it is, effectively, a path to path function
00:01:20 <wli> psykotic: I'm not sure. My copy of Lang grew legs when I roomed with 4 Chinese math grad students my senior year.
00:02:17 <Arnia> Data.Graph includes lots of functions, but I'd like to know if there is an efficient function which allows me to generate all paths between two nodes
00:05:46 <mm_freak> arnia: what kind of graph?
00:06:20 <Arnia> mm_freak: a fully labelled, directed pseudograph
00:07:03 <opqdonut> Arnia: well, you really can't be very efficient in that, you'll have to do a full bfs
00:08:30 <Arnia> opqdonut: I know... but I was at least hoping for an as-optimised-as-possible library. I have a pathological fear of reinventing the wheel caused by terrible experiences as an undergrad ;)
00:09:29 <opqdonut> :)
00:10:19 <mm_freak> arnia: well, programming in haskell means lots of wheels =)
00:10:29 <mm_freak> at least in the first few months
00:10:30 <dons> fgl is the main graph library people use
00:10:39 <dons> Data.Graph.Inductive
00:10:41 <SamB> Arnia: don't fear the wheel!
00:10:55 <dons> but binding to one of the big C or C++ graph libraries could be very profitable
00:11:13 <SamB> it's actually a Haskell best practice to reinvent the wheel... and then learn about the old wheel and use that instead
00:11:24 <dons> its a good approach
00:11:51 <Arnia> mm_freak: yeah, I know. Been programming haskell for a while.
00:12:15 <dons> mm_freak: so have you settled on a good haskell project to hack on?
00:12:24 * Arnia steps back for a second to see how to implement this cleanly
00:13:09 <Pseudonym> There you go, proof that Arnia knows about Haskell.
00:13:14 <Pseudonym> Stepping back and thinking is a virtue.
00:13:19 <Pseudonym> And a necessity, sometimes.
00:13:42 <dons> Arnia++ natural born haskeller :)
00:13:48 <Arnia> Pseudonym: I've never really been able to do so-called 'agile' development. Random hacking makes me feel queasy
00:14:08 <Boney> Agreed.  I often find I've written too much code.  A definite sign that I need to step back as there should have been an easier way.
00:14:12 <Arnia> Makes it interesting when I'm teaching though ;)
00:15:00 <mm_freak> dons: i'm still learningâ€¦  there are quite a few things i still don't understand
00:15:42 <dons> what kind of software do you usually work on?
00:16:17 <mm_freak> mostly number theoretic stuff
00:16:27 <Pseudonym> What sort of thing?
00:16:36 <dons> oh, that's cute, http://therning.org/magnus/archives/311, slightly better error message by default using ~ ptterns
00:16:37 <mm_freak> i love integers =)
00:16:46 <Pseudonym> Integers are nice.
00:16:46 <SamB> you know I wonder if I'm not more productive in Haskell when mowing the lawn than when sitting at my computer
00:16:48 <Pseudonym> Anything specific?
00:17:28 <mm_freak> dons: currently i'm trying to understand those "implicit configurations" for a GF arithmetic type
00:17:36 <mm_freak> pseudonym: cryptography
00:17:42 <Pseudonym> Nice.
00:17:51 <SamB> "implicit configurations"?
00:18:19 <Pseudonym> ?google oleg implicit configuration
00:18:23 <mm_freak> samb: http://okmij.org/ftp/Haskell/types.html#Prepose
00:18:23 <lambdabot> Title: Haskell Programming: Types
00:18:24 <lambdabot> http://portal.acm.org/citation.cfm?id=1017481&dl=&coll=&CFID=15151515&CFTOKEN=6184618
00:18:24 <lambdabot> Title: Functional pearl
00:18:25 <dons> mm_freak: you know about galois, and cryptol?
00:18:38 <mm_freak> dons: yes
00:18:40 <dons> specifying crypto stuff is one of the niches haskell techniques get applied to
00:19:00 <araujo> i know , i know ... this is not a Haskell question, but it looks like #python isn't of  much help atm, does python have lexical closure right?
00:19:13 <SamB> araujo: yes
00:19:13 <araujo> i know some of you python too
00:19:19 <mm_freak> yeah, but there is no general purpose library for modular arithmetic
00:19:30 <SamB> it used to have only two scopes, but now it has fully nested scopes
00:19:39 <araujo> SamB, ok, that explains this behaviour in my program
00:19:42 <araujo> Thanks SamB
00:19:58 <SamB> however it's terribly confusing when combined with mutable variables
00:20:08 <araujo> SamB, yeah , a LOT confusing
00:20:13 <SamB> what do you suppose this does?
00:20:14 <araujo> SamB, i am missing purity today
00:20:32 <SamB> [lambda: x for x in range(10)]
00:20:49 <SamB> or rather, what do you suppose those functions will do if you call them?
00:21:15 <SamB> this is considered massively confusing in Python circles, even
00:21:25 <SamB> this is a place where Haskell wins out big
00:21:32 <SamB> I wonder how LINQ fares?
00:22:42 <wolverian> I'm annoyed by python's _eager_ list comprehensions. now that is confusing. :)
00:22:49 <araujo> SamB, what i wanted to ask you, does this apply for object attributes too?
00:23:33 <araujo> SamB, for example .... def func(a,b): ..... self.var = val ; object.func1(self.var) .....
00:24:10 <mm_freak> what's the difference between (a -> a) and (forall a. a -> a) ?
00:24:17 <araujo> SamB, object.func1 will *always* keep the value referenced by val, even if this attribute changes in other object?
00:24:21 <araujo> that's my confusion
00:24:42 <SamB> araujo: what?
00:26:19 * SamB goes to bed
00:27:09 <Arnia> mm_freak: http://hackage.haskell.org/trac/haskell-prime/wiki/ExistentialQuantification
00:27:13 <lambdabot> Title: ExistentialQuantification - Haskell Prime - Trac, http://tinyurl.com/y6bk55
00:27:14 <araujo> SamB, if the self.var change , the object.func1 argument changes too ... probably is a bit confusing the question, the thing is that i am working with signal here
00:27:18 <araujo> hell, i hate side-effects
00:27:49 <mm_freak> thanks
00:40:10 <mgsloan> with newtype is it possible to derive any class?
00:40:26 <mgsloan> (that applied to the original)
00:42:32 <mgsloan> if not, then it should :P
00:42:42 <Pseudonym> Not every class, no.
00:42:53 <Pseudonym> Multi-parameter typeclasses are a problem.
00:43:11 <mgsloan> ahh, but the others?
00:43:36 <dons> you can derive multi-parameter typeclasses though
00:43:51 <dons> newtype X a = X (ReaderT XConf (StateT XState IO) a)
00:43:51 <dons>     deriving (Functor, Monad, MonadIO, MonadState XState, MonadReader XConf)
00:44:17 <mgsloan> cool!
00:44:36 <dons> there are some limitations, and you'll hit those if you get a 'cunning newtype deriving' error
00:44:43 <mgsloan> hah!
00:46:30 <mgsloan> one funkiness of multiparameter typeclasses is that often times classes have a sort of 'principal type'.  I take it from this that the standard is to have the principal type be last?
00:47:12 <dons> hmm, usually the `element type' is last, and the container types are progressively further to the `front' or left.
00:47:28 <mgsloan> (funkiness in that it's not particularly obvious which thing _is_ the instance of the class - reasoning which sometimes doesn't apply, I know)
00:47:40 <mgsloan> ah
00:47:43 <Pseudonym> Nytol.
00:48:08 <Syzygy-> > [3 | x <- [1..10]]
00:48:09 <lambdabot>  [3,3,3,3,3,3,3,3,3,3]
00:48:13 <Syzygy-> Thought so.
00:48:48 <mm_freak> i don't really understand the purpose of the quantifiers
00:49:20 <mgsloan> basically they introduce type vars
00:49:31 <mgsloan> well, in the case of haskell's forall
00:49:48 <mgsloan> and sometimes used for kinds, in some ghc outputs
00:50:06 <mgsloan> :t >>=
00:50:08 <lambdabot> parse error on input `>>='
00:50:14 <mgsloan> :t (>>=)
00:50:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
00:50:19 <dons> mm_freak: for programming with type variables, you sometimes want to state the scope of a type explicitly, with a quantifier
00:50:33 <dons> :t Control.Monad.ST.runST
00:50:35 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
00:50:54 <dons> 's' has inner scope only. it can't escape. the binder shows that in the syntax
00:51:14 <mm_freak> ah
00:51:56 <mgsloan> tis a way of introducing a type var without using it in the parameter list
00:51:58 <dons> similarly for proper existential types, data E = forall t. API t => E t, here some concrete type is enitrely hidden inside an existential wrapper. the type system enforces you can never see what 't' is, but only access it through its API
00:52:03 <mgsloan> at least in data type decls
00:52:04 <mgsloan> yeah
00:54:50 <mm_freak> tst :: forall s. (forall s. s) -> s
00:54:57 <mm_freak> so that outer `s' is something different?
00:55:42 <sieni> hmph... gotta move
00:55:43 <dons> two different 's' there.
00:55:46 <mgsloan> that'd be pretty confusing, but if that's allowed, yes
00:55:55 <mm_freak> yes, it's allowed
00:55:57 <sieni> I want to ride my bicycle!
00:56:00 <mm_freak> ok then
00:56:27 <dons> Prelude> :set -fglasgow-exts
00:56:27 <dons> Prelude> let tst :: forall s. (forall s. s) -> s  ; tst = undefined
00:56:27 <dons> Prelude> :t tst
00:56:28 <dons> tst :: forall s. (forall s1. s1) -> s
00:56:35 <dons> ^^ note the compiler renamed it anyway
00:56:55 <mm_freak> tst :: Integer -> (forall s. SomeType s -> a) -> a
00:57:03 <mm_freak> what's the purpose of `forall s' here?
00:57:57 <mm_freak> whatever s is, is only visible to the function given by the second argument?
00:58:05 <dons> yep
00:58:07 <mgsloan> hey, cool, you can actually use kinds in syntax
00:58:49 <olsner> mgsloan: what does that even mean? :P
00:59:11 <mgsloan> let tst :: forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b; tst = >>=
00:59:12 <mm_freak> if that function calls `tst' again, then that s is something different?  i.e. referring to the `outer' s is an error?
00:59:28 <mgsloan> err. except for that last bit where I try to define it, that's legal haskell
00:59:45 <mgsloan> with glasgow-exts i'd imagine
01:00:25 <mgsloan> (the speshul part is the (m :: * -> *))
01:00:35 <mm_freak> like:
01:00:48 <mm_freak> tst n f = f (SomeType n)
01:01:22 <mm_freak> tst 3 (\x -> tst 4 (\y -> SomeType (x + y)))  -- this is an error?
01:01:46 <mm_freak> because the inner function refers to the outer y, i'd think
01:02:17 <mm_freak> uhm
01:02:24 <mm_freak> leave the SomeType away =)
01:03:11 <mgsloan> I think it just scopes it in the type sig, but i can always be wrong
01:03:49 <mm_freak> mgsloan: i'm getting an error telling me that some type is less polymorphic than expected, but iff i use forall
01:04:25 <mm_freak> and that error makes no sense to me
01:04:59 <roconnor> that usually happens to me when I require a function argument to be a polymorphic function.
01:06:23 <mgsloan> yeah, tst looks like a fairly improbable function
01:06:42 <mgsloan> maybe SomeType needs restrictions on it
01:07:22 <mgsloan> well, shouldn't you could always pass in something worthless like (const "hey!")
01:07:30 <mm_freak> that error is actually intentional
01:07:42 <mm_freak> i'm trying to understand the concept of implicit configurations
01:19:32 <roconnor> overloadin string literals?
01:25:18 <mgsloan> > "Goobar!" :: Data.ByteString.ByteString
01:25:19 <lambdabot>      Not in scope:
01:25:19 <lambdabot>       type constructor or class `Data.ByteString.ByteString'
01:26:44 <dons> i think they're only available in ghc head branch
01:27:01 <mgsloan> they sound fun, though
01:27:33 <roconnor> dons: how can that work? Is there a FromString class?
01:28:21 <Nopik> hi all
01:28:25 <psykotic> dons: was that augustss's code?
01:28:26 <dons> yeah, an IsString class
01:28:28 <dons> yep
01:28:32 <psykotic> i remember when he wrote that
01:28:36 <psykotic> nice to see it get accepted
01:28:45 <dons> class IsString a where
01:28:45 <dons>     fromString :: String -> a
01:28:45 <dons> instance IsString [Char] where
01:28:45 <dons>     fromString xs = xs
01:28:51 <mgsloan> http://thread.gmane.org/gmane.comp.lang.haskell.prime/1882/focus=1882
01:28:54 <lambdabot> Title: Gmane Loom, http://tinyurl.com/2srzey
01:29:01 <dons> now the fun will be packing other string-like data into strings..
01:29:03 <olsner> @pl \x -> liftM2 (,) (f x) (g x)
01:29:03 <lambdabot> ap (liftM2 (,) . f) g
01:29:16 <roconnor> dons: what are the odds that the compiler can optimize constant bytestrings?
01:29:23 <psykotic> dons: now we just a type class for [] literals :P
01:29:25 <dons> optimise them in what way?
01:29:27 <psykotic> then i will be happy
01:29:47 <dons> psykotic: heh but that's not syntax, that's a constructor :)
01:29:51 <mgsloan> dons - yeah,  I was thinking "hi = printLn \"hello world!\"" :: HaskellCode
01:29:58 <roconnor> dons: make "Goobar!" :: Data.ByteString.ByteString a string in the .TXT part of the executable.
01:29:59 <dons> roconnor: P.pack "foo" -- will turn into a C string
01:30:11 <psykotic> dons: doesn't it have syntactic support?
01:30:12 <mgsloan> err, not printLn - /me is extremely sleepy
01:30:34 <psykotic> dons: oh, you mean a plain []
01:30:38 <dons> roconnor: right, string literals with 'pack' should be placed in the text segment. they require a strlen at runtime to construct
01:30:49 <psykotic> dons: i meant that [a1, a2, ..., an] should be the same as msum . [a1, a2, ..., an] under the current scheme
01:30:55 <psykotic> msum without the .
01:31:08 <dons> roconnor: you can use unsafePackAddress to construct them in O(1) though, with both length and string content in the text segment
01:31:11 <psykotic> and hopefully list comprehensions would become monadic too :)
01:31:18 <dons> yeah, that'd be nice.
01:31:32 <roconnor> dons: wow, the text segement is constructed at compile time!
01:31:38 <roconnor> dons: that's pretty impressive.
01:31:47 <dons> it needs rewrite rules, but yeah, its nie
01:31:49 <roconnor> well, for haskell at least.
01:32:01 <dons> :t Data.ByteString.Base.packAddress
01:32:03 <roconnor> not so impressive when C does it.
01:32:03 <lambdabot> GHC.Prim.Addr# -> Data.ByteString.Base.ByteString
01:32:04 <sphynx> hello guys!
01:32:17 <dons> :t Data.ByteString.Base.packAddress "foo"#
01:32:19 <lambdabot> Data.ByteString.Base.ByteString
01:32:23 <dons> is what pack "foo" is turned into
01:32:52 <dons> roconnor: you can confirm its done at compile time by using -ddump-simpl to check for the 'packAddress' rewrite rule to fire
01:33:02 <dons> this can be a big win for many many small string literals
01:33:05 <dons> happs does it, for example
01:33:18 <dons> ensuring that its constructed, and its length computed, at compile time
01:33:52 <dons> i'd like TH to support "foo"# literals though. then I could really play some games with static data
01:34:14 <sphynx> I'm trying to play with ICFP'07 task and now I've started with simple task - writing pattern() function. I'm using many cases now and Data.ByteString for DNA type. And I pass all intermediate results in parameters, code is not so beautiful... Maybe it would be nicer to use State monad here, what do you think?
01:34:39 <dons> you'll need Data.ByteString.Lazy I think, to get sub-linear append
01:35:14 <roconnor> or my untested Data.ByteString.Rope...
01:35:16 <psykotic> i think you'll want to use a monad, yes. like a writer monad for the RNA and a state monad of some kind for the dna.
01:35:37 <dons> you can use Builder for the writing of the RNA (i think desp at least did that)
01:35:46 <psykotic> and you might want to mix an error handling monad in there too
01:35:50 <sphynx> psykotic: So I need to use some monad transformer to combine these two monads
01:35:54 <desp> I did use the Builder for the rewriting of the DNA
01:36:01 <desp> RNA I output directly to stdout
01:36:12 <psykotic> sphynx, you could use IO :)
01:36:34 <desp> sphynx: I didn't use a monad, but I'm going to, in my rewrite
01:36:44 <sphynx> psykotic: ah, just write RNA to stdout, I understand
01:36:49 <psykotic> sphynx, but yes you should probably use a custom monad composed via monad transformers
01:37:04 <psykotic> but honestly i would be tempted to just use IO :)
01:37:44 <sphynx> dons: I have take a look at asymptotic properties of appending lines in Lazy BS and strict BS and they were O(n) in both cases, if I remeber correct..
01:37:48 <desp> outputting the RNA immediately has its pluses
01:37:55 <desp> i.e. if your dna2rna converter sucks
01:38:04 <psykotic> desp: for pipelining into the renderer?
01:38:14 <desp> no, for getting results before your converter crashes
01:38:15 <dons> sphynx: no, lazy bytestrings append is O(c), the length of the spine
01:38:42 <dons> which is n/32k typically. (i know , i know, but 1/32k is significant :)
01:39:53 <sphynx> and what is Builder, BTW? :) Another kind of monad?
01:40:21 <mgsloan> yeh, big-O notation is kinda annoying like that.  Everyone assumes an O(n) algorithm is better than an O(n^2) algorithm
01:40:30 <desp> Data.Binary.Builder, allows you to construct lazy BS efficiently, but you usually just use Data.Binary.Put
01:40:51 <dons> yeah, just a nice monadic wrapper over the Builder monoid
01:40:59 <dons> so a Writer specialised for bytestrings
01:41:00 * desp has just succesfully built Haskell stuff under Gentoo/Prefix over Mac OS X
01:41:06 * desp woops
01:41:15 <wli> mgsloan: That's why f(n) \in g(n) + O(h(n)) is much better; you have to smoke out all the constants.
01:43:49 <Nopik> @src list
01:43:50 <lambdabot> Source not found. My mind is going. I can feel it.
01:43:57 <Nopik> @src lift
01:43:57 <lambdabot> Source not found. Do you think like you type?
01:44:07 <mgsloan> wli - ah, cool, I've never seen that before :P
01:45:46 <wli> mgsloan: It's the more common form of splitting off error terms in mathematics.
01:46:08 <wli> mgsloan: Knuth et al do a bit of this sort of asymptotics in Concrete Mathematics
01:46:17 <mgsloan> ah, cool
01:54:20 * bartw_ cleans the ##javascript gunk from his hair
01:57:10 <Nopik> if I have 2 monadic computations, one of type a and second of type b, then have function foo :: a -> b -> c and i would like to run foo over my monads, i would have to run both computations and then pass both results through foo, but this is what lifting is for - it allows me to construct new function which will run my monads when compuation will start and then compute the result?
01:57:15 <Nopik> is my understanding correct?
01:57:40 <roconnor> @type liftM2
01:57:49 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
01:58:01 <Cale> Nopik: basically I think you get the picture :)
01:58:17 <Nopik> Cale: thanks, i just wanted to verify ;)
01:58:30 * roconnor hates it when liftM2 runs the computations in the wrong order.
01:58:50 <roconnor> everyonce in a while I want to run the second computations first
01:59:48 <Syzygy-> roconnor: let liftM2' f a a' = do x <- a'; y <- a; return $ f x y
01:59:50 <Syzygy-> Done.
01:59:52 <Syzygy-> :)
02:00:00 <dons> roconnor: mm, interesting
02:01:32 <dons> :t \f -> flip (liftM2 f) -- ?
02:01:34 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a2 -> m a1 -> m r
02:01:44 <dons> ?pl \f -> flip (liftM2 f)
02:01:44 <lambdabot> flip . liftM2
02:03:45 <roconnor> Syzygy-: yeah, but then I won't have a really really short program to solve the xkcd menu problem. ;)
02:04:31 <roconnor> actually as I reacall I wanted to do foo `ap` bar and run bar first.
02:04:33 <Syzygy-> roconnor: So you want the libraries to be expanded so that your golfing gets improved? ;)
02:04:48 <Syzygy-> roconnor: How about foo `flip ap` bar
02:05:18 <roconnor> Syzygy-: doesn't have the same type
02:05:22 <roconnor> @type ap
02:05:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
02:05:27 <Syzygy-> Right.
02:05:28 <roconnor> @type (flip ap)
02:05:30 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m (a -> b) -> m b
02:05:43 <bartw_> ?
02:05:52 <bartw_> smells like same type ?
02:05:57 <roconnor> @type (flip (liftM2 (flip $)))
02:05:59 <lambdabot> forall a b c (m :: * -> *). (Monad m) => m b -> m (a -> b -> c) -> m (a -> c)
02:06:08 <Syzygy-> Then I really don't see a good way for you to do it without hacking your own.
02:06:12 <roconnor> ugh
02:06:13 <roconnor> yep
02:07:30 <roconnor> oh wait, it wasn't the xkcd problem it was the rationals problem.
02:08:14 <roconnor> I wanted rationals = 1:[(+1),recip] `myAp` rationals
02:08:26 <roconnor> I wanted rationals = 1:([(+1),recip] `myAp` rationals)
02:08:36 <roconnor> it was going to be really sweet.
02:08:46 <roconnor> alas ap doesn't work were myAp goes.
02:09:42 <roconnor> er
02:09:56 <roconnor> I wanted rationals = 1:([(+1),recip . (+1)] `myAp` rationals)
02:12:36 <bartw_> i still can't really read that :(
02:13:10 <roconnor> > [(+5),(*5)] `ap` [1,2,3]
02:13:12 <lambdabot>  [6,7,8,5,10,15]
02:13:26 <bartw_> ah, right
02:13:53 <roconnor> but I want [6,5,7,10,8,15]
02:14:03 <bartw_> hehe
02:14:11 <roconnor> because instead of [1,2,3] I have an infinite list.
02:14:19 <bartw_> and using zip ?
02:14:28 <roconnor> oh sure, it can be done
02:14:40 <Syzygy-> roconnor: How about some sort of concatmap?
02:14:49 <bartw_> and the other way around ?
02:14:56 <Syzygy-> Take n -> [f n, g n], and concatmap that over the infinite list?
02:15:08 <bartw_> > [1,2,3] `ap` [(+5),(*5)]
02:15:09 <lambdabot>   add an instance declaration for (Num ((a -> a) -> b))
02:15:09 <lambdabot>     In the expression: 3
02:15:36 <bartw_> ehmz, meh
02:15:45 <Syzygy-> > concatMap (([(+5),(*5)] `ap`) . return) [1,2,3]
02:15:46 <lambdabot>  [6,5,7,10,8,15]
02:15:50 <Syzygy-> Like that?
02:16:21 <roconnor> map (flip $) [1,2,3] `ap` [(+5),(*5)]
02:16:26 <roconnor> > map (flip $) [1,2,3] `ap` [(+5),(*5)]
02:16:27 <lambdabot>        add an instance declaration for (Num (a -> (a1 -> a1) -> c))
02:16:27 <lambdabot>     In th...
02:17:18 <roconnor> > [$ 1,$ 2,$ 3] `ap` [(+5),(*5)]
02:17:19 <lambdabot>  Parse error
02:17:22 <Syzygy-> > let rationals = 1:[(+1),recip] `myAp` rationals where myAp x y = concatMap ((x `ap`) . return) y
02:17:23 <lambdabot>  Parse error
02:17:32 <roconnor> > [($ 1),($ 2),($ 3)] `ap` [(+5),(*5)]
02:17:33 <lambdabot>  [6,5,7,10,8,15]
02:17:48 <roconnor> heh, that will confuse non haskell programmers
02:18:02 <Syzygy-> > let rationals = 1:[(+1),recip.(+1)] `myAp` rationals where myAp x y = concatMap ((x `ap`) . return) y
02:18:02 <lambdabot>  Parse error
02:18:10 <Syzygy-> Wtf? Where is my parse error there?
02:18:23 <roconnor> > map (flip ($)) [1,2,3] `ap` [(+5),(*5)]
02:18:24 <lambdabot>  [6,5,7,10,8,15]
02:18:41 <bartw_> thats actually pretty contrived
02:20:59 <bartw_> > map (`ap` [(+5),(*5)]) [1,2,3]
02:20:59 <lambdabot>   add an instance declaration for (Num [(a -> a) -> b])
02:21:00 <lambdabot>     In the expression: 3
02:21:14 <bartw_> obivously i know no haskell ;p
02:21:59 <Syzygy-> bartw_: Making a section doesn't change the order of operands, and that error is about operands not being good enough.
02:24:38 <Igel> good morning
02:24:59 <bartw_> i was thinking about making somethign like [[6,5],[7,10],[8,15]] and then flattening it
02:25:20 <xpika> how can i parse "<unknowntag> xyz </unknowntag>" to HaXml content
02:25:23 <Igel> a couple of days ago, someone told me, there is/was a website listing successfully projects in functional programming languages
02:25:37 <Igel> unfortunately he didn't know the url
02:25:44 <Igel> has someone heard of it?
02:27:02 <qwr> > zipWith (==) "a" "ab"
02:27:04 <lambdabot>  [True]
02:29:57 <Igel> ooops
02:30:04 <Igel> successfully listing projects i mean^^
02:34:28 <HairyDude> hoogle seems to be being very slow
02:35:04 <Nopik> main = putStrLn $ fn ; fn :: String; fn = "a\nb";       - i would like to get newline instead of \n printed literally.. how to do that?
02:36:52 <crazy_coder> hi
02:38:46 <Syzygy-> Nopik: GOA> let fn :: String; fn = "a\nb" in putStrLn $ fn
02:38:46 <Syzygy-> a
02:38:46 <Syzygy-> b
02:38:50 <Syzygy-> Works for me.
02:39:08 <opqdonut> yeah, strings are printed literally as long as there's no show in between
02:39:09 <Nopik> hm
02:39:30 <opqdonut> > let fn :: String; fn = "a\nb" in putStrLn $ show fn
02:39:32 <lambdabot>  <IO ()>
02:39:37 <opqdonut> GOA> let fn :: String; fn = "a\nb" in putStrLn $ show fn
02:39:44 <Nopik> opqdonut: ah, so show interprets \n? thanks
02:39:51 <opqdonut> yeah
02:39:54 <opqdonut> ?src print
02:39:54 <lambdabot> print x = putStrLn (show x)
02:40:02 <HairyDude> in fact, haskell.org seems to be being very slow
02:40:14 <opqdonut> > show "a\nb"
02:40:15 <lambdabot>  "\"a\\nb\""
02:40:19 <opqdonut> heh
02:40:26 <opqdonut> double show
02:41:02 <Nopik> opqdonut: works, thanks
02:48:27 <Nopik> @src liftM
02:48:27 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
02:48:32 <Nopik> @src liftM2
02:48:33 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
02:50:35 <opqdonut> @. undo src liftM2
02:50:36 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
02:51:06 <opqdonut> @undo do { x1 <- m1; x2 <- m2; return (f x1 x2) }
02:51:06 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
02:52:28 <Nopik> ok, /me ready to write own monad transformer :)
02:52:49 <opqdonut> :)
02:53:28 <ski> Nopik : did you get 'MyMonad' an instance of 'MonadReader' ?
02:53:44 <Nopik> ski: no, why?
02:53:59 <Nopik> ski: basically all of my code is more or less duplication of some code from mtl
02:54:14 <Nopik> ski: it is not meant to be useful, but i am learning how those things are working internally
02:54:30 <HairyDude> hmm... it's not the monad I wanted, but I'm still surprised that I'm getting "no instance for Monad ((->) [a])" when I've imported Control.Monad, since there is one for ((->) a)
02:54:42 <Nopik> ski: when i write it once myself, i will be able to use Control.Monad.* safely later
02:55:14 <ski> import MonadReader
02:55:26 <ski> to get the 'Monad (r ->)' instance
02:55:44 <ski> s/MonadReader/Control.Monad.Reader/
02:56:42 <ski> Nopik : i was suggesting you write 'ask' and 'local' yourself .. but tie it into 'MonadReader' by making it an instance of that class
02:57:12 <Nopik> ski: actually i have written them already.. just there is no instance block in my program
02:57:30 <ski> do you know how to make that instance ?
02:57:43 <Nopik> ski: did not tried yet ;)
02:57:53 <Nopik> though I have instance of Monad
02:58:01 <Nopik> so, it must be similar
02:59:49 <hpaste>  ski annotated "(no title)" with "instance MonadReader" at http://hpaste.org/1876#a1
03:00:50 <gour> how is haskell supported under ubuntu?
03:03:25 <Nopik> ski: yeah, exactly
03:03:28 <Nopik> ski: thanks
03:03:50 <Cale> gour: fairly well.
03:04:32 <gour> Cale: thanks. i+m fed up with gentoo...
03:04:41 <Cale> gour: Though the release cycles don't tend to match up too well. At least 6.6 made it into Feisty.
03:05:03 <gour> Cale: and what about building from source?
03:05:36 <Cale> Of course you could do that if you wanted to. It's easier just to install the binary release of 6.6.1 if you want that.
03:05:48 <Cale> (the generic linux one)
03:06:28 <gour> that's good to hear
03:14:17 <roconnor> does GHC run on UMIX?
03:14:43 <olsner> what's UMIX?
03:14:49 <roconnor> @what UMIX
03:14:50 <lambdabot> I know nothing about umix.
03:14:53 <roconnor> :/
03:14:58 <roconnor> @go UMIX
03:15:01 <lambdabot> http://www.umix.net/
03:15:01 <lambdabot> Title: UMIX.net > :: Home
03:15:09 <dons> heh. wasn't that last year's icfp OS?
03:15:13 <roconnor> that doesn't look right
03:15:41 <fasta> Is there a library distributed with GHC that can give me the home dir?
03:15:52 <dons> System.Directory
03:16:00 <dons> getEnv "HOME" also
03:16:21 <fasta> dons: getHomeDirectory, thanks
03:16:23 <roconnor> olsner: http://www.boundvariable.org/task.shtml
03:16:24 <lambdabot> Title: ICFP Programming Contest, 2006 : Contest Materials and Task
03:16:44 <olsner> found http://en.wikipedia.org/wiki/UMIX too
03:16:45 <lambdabot> Title: UMIX - Wikipedia, the free encyclopedia
03:17:00 <fasta> @localtime Igel
03:17:01 <lambdabot> Local time for Igel is Thu Jul 26 12:15:55
03:17:01 <fasta> @localtime Igloo
03:17:02 <lambdabot> Local time for Igloo is Thu Jul 26 11:15:56 2007
03:17:39 <fasta> Igloo: This webpage contaings links to c:/ http://www.haskell.org/ghc/dist/current/docs/directory/System-Directory.html
03:17:41 <lambdabot> http://tinyurl.com/36j3o3
03:17:57 <fasta> Igloo: it doesn't use relative addresses, which was probably intended.
03:18:13 <fasta> contains*
03:20:29 <dons> on unix, getHomeDirectory uses getEnv
03:20:58 <dons> you could also use the `unix' package, but it probably doesn't matter:
03:21:06 <dons> -- | Find a user's home in a canonical sort of way
03:21:06 <dons> getHome :: IO String
03:21:06 <dons> getHome = Control.Exception.catch
03:21:06 <dons>     (getRealUserID >>= getUserEntryForID >>= (return . homeDirectory))
03:21:06 <dons>     (\_ -> getEnv "HOME")
03:21:40 <fasta> dons: yes, it's a very easy problem, but anything I don't need to write, is a win.
03:21:41 <HairyDude> ?hoogle maximumBy
03:21:41 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
03:21:42 <lambdabot> Data.List.maximumBy :: (a -> a -> Ordering) -> [a] -> a
03:21:56 <HairyDude> so List and Data.List have two incompatible functions with the same name?
03:22:04 <HairyDude> wonderful
03:22:27 <opqdonut> that first type sig looks weird
03:22:37 <ski> 'List' is the old library, 'Data.List' is the new hierarchical one
03:23:00 <dons> List is really a synonym for most of Data.List. that's a hoogle bug
03:23:04 <ski> opqdonut : it is the type of '(<=)' iirc
03:23:14 <Nopik> ok, I have MyMonad a b c d, I can run it and extract the result.. now, how to apply ReaderT on it and use it inside of my monad?
03:23:33 <dons> the List module is literally:
03:23:36 <dons> module List (
03:23:36 <dons>     sort, sortBy, insert, insertBy, maximumBy, minimumBy,
03:23:36 <dons>     ...
03:23:36 <dons>   ) where
03:23:36 <dons> import Data.List hiding (foldl')
03:23:47 <opqdonut> ski: yeah i meant the first one, with the a->a->a
03:23:59 <ski> Nopik : you want to compibe 'MyMonad' with 'ReaderT' ?
03:24:19 <dons> $ ghci
03:24:19 <dons> Prelude> :t List.maximumBy
03:24:22 <Nopik> ski: yes, to get more complex monad, with Reader on top and MyMonad inside
03:24:22 <dons> List.maximumBy :: (a -> a -> Ordering) -> [a] -> a
03:24:49 <Nopik> ski: as far as I understand, this should allow me to read Reader environment from my monad
03:24:54 <ski> ReaderT r (MyMonad a b c) d
03:25:24 <ski> i'm not quite sure whay you want that, though ?
03:25:25 <opqdonut> ?src genericIndex
03:25:26 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
03:25:33 <opqdonut> :/
03:26:05 <HairyDude> dons: ah, you're right, the List version is really the same
03:26:25 <Nopik> ski: let me paste my current code ;)
03:26:47 <ski> Nopik : annotate the old paste ?
03:26:49 <HairyDude> :t (<=)
03:26:51 <lambdabot> forall a. (Ord a) => a -> a -> Bool
03:26:51 <dons> http://monad.ca, by the way, for those not around earlier :) for your industrial contructors
03:26:51 <projectxz> anyone able to offer me some help installing xmonad?
03:26:53 <lambdabot> Title: Monad Industrial Constructors Inc. - Home
03:27:02 <ski> er ..
03:27:02 <HairyDude> :t max
03:27:03 <projectxz>  i think it's a simple issue with x11 really
03:27:03 <Nopik> hm, ok
03:27:04 <dons> projectxz: sure :)
03:27:04 <lambdabot> forall a. (Ord a) => a -> a -> a
03:27:14 <projectxz> basically the problem is that to build xmonad i need a version of x11 >1.2.1
03:27:19 <projectxz> thanks man
03:27:19 <ski> HairyDude : yes, 'max' it must be, not '(<=)', of course
03:27:28 <dons> yep. you need the version on hackage.haskell.org
03:27:29 <projectxz> can i get this from portage?
03:27:40 <dons> from hackage, you'll need to build it yourself
03:27:41 <projectxz> i've already emerged xorg-x11
03:27:54 <projectxz> yeah i was afraid of that... :(
03:28:01 <dons> its easy.
03:28:01 <projectxz> does it take forever?
03:28:05 <dons> all haskel projects build the same way
03:28:08 <dons> no, maybe 60 seconds
03:28:19 <projectxz> do i have to unemerge xorg-11 then?
03:28:26 <projectxz> i'm using gentoo
03:28:49 <projectxz> xorg-x11 rather.
03:28:56 <dons> you should be fine just building it  -- ghc will use your last installed version.
03:29:21 <hpaste>  Nopik annotated "Simple monad with local defined" with "Monad got more complex, trying to couple with ReaderT" at http://hpaste.org/1881#a1
03:29:34 <projectxz> thanks dons!
03:29:43 <dons> there are instructions on xmonad.org i think.
03:29:46 <Nopik> ski: look at the end of code for marked section.. the beginning should have no problems
03:31:14 <ski> Nopik : hrm .. your 'local' at the top looks quite strange
03:32:05 <ski> it certainly doesn't do the same as the standard 'local'
03:32:40 <Nopik> ski: thats possible, though i'm fine with it ;)
03:32:57 <Nopik> ski: it seems to be less generic
03:32:59 <Nopik> @src local
03:33:00 <lambdabot> Source not found. stty: unknown mode: doofus
03:33:10 <ski> 'withMyMonad' looks like the standard 'local', in fact
03:33:11 <Nopik> @src Control.Monad.local
03:33:11 <lambdabot> Source not found. Take a stress pill and think things over.
03:33:28 <ski> local :: MonadReader r m => (r -> r) -> m a -> m a
03:33:53 <ski> Nopik.local :: (d -> (a,b,c)) -> MyMonad a b c d -> MyMonad a b c d
03:33:57 <ski> those doesn't match
03:33:58 <Nopik> ski: runMyMonad seem to be runned twice
03:34:11 <ski> indeed .. which is strange
03:34:40 <Nopik> hm, no, it works and runs monad once
03:34:44 <ski> Nopik.withMyMonad :: ((a,b,c) -> (a,b,c)) -> MyMonad a b c d -> MyMonad a b c d
03:34:46 <Nopik> i have verified this afair
03:35:34 <ski> nope, sorry
03:35:57 <Nopik> ski: isnt runMyMonad  m . f equal to \x -> runMyMonad m (f x ) ?
03:36:11 <ski> it is
03:36:25 <Nopik> ski: so, withMyMonad is equal to local in my implementation
03:36:32 <ski> yes
03:36:40 <Nopik> ski: and both share the same type signature :)
03:36:57 <Nopik> nevermind
03:37:06 <Nopik> any ideas on that transformer?
03:37:11 <ski> i.e .'withMyMonad' in your implementation is equal to the standard 'local' .. not to the 'local' in your implementation, though
03:37:58 <Nopik> due to type restriction? d-> (a,b,c) should be there?
03:38:33 <ski> both due to incompatible type, and due to code doing differing things
03:39:16 <ski> your 'local f m' runs 'm', then transforms the result by 'f', and passes that as environment when *running*'m'*again*
03:39:49 <Nopik> no way
03:39:59 <ski> the standard 'local f m' just grabs the current environment, transforms it by 'f', and shows this transformed environment when running 'm' (once)
03:40:00 <Nopik> f x is being calculated before running
03:40:19 <ski> local f m = do
03:40:19 <ski>  a <- m
03:40:19 <ski>  return $ runMyMonad m $ f a
03:41:16 <ski> see how 'm' is run twice, there ?
03:42:00 <Nopik> ski: ah, we are talking about different code
03:42:12 <Nopik> ski: i have fixed that problem already, just take a look at annotation
03:42:26 <Nopik> ski: so, both of us are right :)
03:42:38 <ski> ah, indeed you are correct :)
03:42:45 <Nopik> ;)
03:42:55 <ski> (i should have been more clear about which code i was commenting on)
03:43:10 <Nopik> indeed, yesterday evening, my computation were running twice, so i fixed it and i was sure that i have verified that now they are runned once
03:44:48 <ski> ok .. so now you are working with a state monad, instead of the environment monad you had before ..
03:45:39 <ski> btw, you may like
03:45:44 <ski>   " {ask3 " ++ show a ++ "," ++ show b ++ "," ++ show c ++ "} "
03:45:47 <ski> better as
03:46:08 <ski>   concat [" {ask3 ",show a,",",show b,",",show c,"} "]
03:46:10 <Nopik> ski: yes, i've advanced :D
03:46:29 <ski> (just an idea .. not clear-cut better)
03:46:38 <Nopik> ski: yeah, whole suma/sumuj thing could be written much shorter, i know ;)
03:47:04 <fasta> Does it matter where I put the -O flag?
03:47:12 <fasta> I.e. can I put it after the file list?
03:47:19 <fasta> (for GHC)
03:48:16 <ski> Nopik : i'm not convinced having 'ask' (instead of 'get'), and especially 'local' is useful for a state monad .. and if it is, one might want to change it ..
03:48:47 <ski> @type Control.Monad.State.get
03:48:48 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
03:49:02 <fasta> dons: what's the incantatation to have GHC get the most performance out of my code? I don't care if I need to wait 5 minutes per module.
03:49:02 <Nopik> ski: well, i just want to communicate with surrounding monad, if it should be done via get, its fine
03:49:06 <Nopik> ski: i just have no idea how it should work
03:49:10 <ski> get :: MyMonad a b c (a,b,c)  -- in your case, of course
03:49:38 <fasta> dons: I want aggresive inlining for all my generalized functions, cross-module inlining, everything.
03:49:41 <ski> the thing is that one expects an environment to behave differently from a state
03:49:47 <dons> fasta, ghc 6.6.1 or ghc head. crank up -O2
03:49:54 <dons> try both.
03:50:11 <dons> we used the head branch for the fusion work
03:50:31 <ski> a state is down-and-up threaded through the computation, linearly .. an environment is down-only, distributed across all branches "in parallel"
03:50:44 <dons> you might want to look at the streams package for examples of how to program for the SpecConstr optimisation with your loops, and how to get inlining kicking along
03:51:14 <dons> the head branch also has an improved native code gen
03:51:21 <kolmodin> ghc 6.6.1 is in gentoo portage... feel free to try it and report any bugs you find :D
03:51:35 <dons> kolmodin: hey :)
03:51:50 <dons> so what are we going to hack on in freiburg?
03:51:51 <ski> Nopik : e.g., one might asusme that 'do x <- ask; y <- local f m; return (x,y)' is the same as 'do y <- local f m; x <- ask; return (x,y)' (assuming termination)
03:52:04 <kolmodin> dons: so much I have to narrow it down a bit :)
03:52:15 <dons> yeah! lots of fun projects
03:52:19 <kolmodin> yeah :)
03:52:21 <dons> i've got my eye on this ghc ropes thing
03:52:25 <dons> bytestring ropes, i mean
03:52:31 <ski> Nopik : one way to ensure this is to restore the state after 'm' has run, in 'local f m'
03:52:32 <dons> bit parsing.. tha'd be good
03:52:48 <kolmodin> dons: I'd like cabal to do preprocessing correctly. preprocessing chains
03:52:57 <ski> Nopik : does any of this make sense ? :)
03:52:59 <dons> yeah, that would be good
03:53:03 <kolmodin> which involves dep analysis
03:53:04 <Nopik> ski: yes, i know that i did not care about state modifications
03:53:07 <Nopik> ski: more or less ;)
03:53:10 <dons> esp. the various FFI preprocessors
03:53:20 <kolmodin> and then it might not be very difficutlt to make cabal support -jN
03:53:23 <dons> you could put some notes about projects on the hack page.
03:53:25 <dons> oh ,that'd be good
03:53:28 <Nopik> ski: but, as i've said, it is not important to me, as i wanted to understand how things are working
03:53:32 <dons> yes. that's really something we'd like.
03:53:38 <Nopik> ski: now i want to understand how transformers are working ;)
03:53:40 <dons> kolmodin: you could almost do that now with ghc -M
03:53:42 <kolmodin> yeah, so tons of fun things to hack on :)
03:53:53 <ski> Nopik : working my way downwards :)
03:53:54 <dons> but yes, dependency analysis. hmm. that /would/ be good
03:54:07 <ski> Nopik : your 'setEnv' is basically 'set'
03:54:33 <Nopik> yes ;)
03:55:06 <dons> kolmodin: we have the room confirmed for the hackathon now too
03:55:07 <kolmodin> dons: yes, if we run ghc -M and then read the info it writes... because natuarlly I want it portable and independent of make
03:55:10 <ski> (and 'lift2' is 'liftM2')
03:55:13 <dons> right.
03:55:21 <Nopik> ski: indeed
03:55:36 <dons> kolmodin: also, is the hackathon weekend during octoberfest? :} someone mentioned something about that
03:55:48 <kolmodin> dons: it is? hahaha, cool :D
03:55:53 <kolmodin> I have to check
03:56:51 <ski> (btw, i'd call 'mymonad' 'myaction' .. since the *type* (together with 'return','(>>=)',three laws) is the monad .. something of type 'MyMonad a b c d' is a monadic action returning value of type 'd', in the 'MyMonad a b c' monad)
03:57:35 <kolmodin> dons: yeah, seems that way :)
03:57:38 <fasta> dons: does -O2 imply that assertions are off?
03:57:55 <dons> fasta, assertions are off with -O
03:57:57 <dons> and higher
03:58:01 <Nopik> ski: ok.. though when I was choosing this name i had no idea how this works and so on :)
03:58:04 <dons> kolmodin: hehe. should be fun then
03:58:07 <kolmodin> guess the biggest fest is in Munchen, but surely there is parties everywhere :)
03:58:21 <Nopik> ski: as this piece of code taught me much more about monads than all tutorials i've read before ;)
03:58:42 <dons> yeah. its also sommercampus at the Uni Freiburg, so that means student facilities are open. which is good
03:58:52 <kolmodin> I hear they serve the beer in one-liter glasses :)
03:59:03 <dons> yeah, so i hear!
03:59:09 <Nopik> boss calling, brb
03:59:15 <kolmodin> have you seen Beerfest?
03:59:30 <dons> no?
03:59:32 <kolmodin> by the broken lizards
03:59:42 <kolmodin> american movie about oktoberfest
03:59:47 <ski> Nopik : i assume 'ff3 :: ReaderT String (MyMonad Int Int Int) String' ?
03:59:48 <kolmodin> quite funny
04:00:41 <Nopik> ski: thats possible.. without ask it was just MyMonad, but now i didnt tried to figure it out yet
04:00:56 <Nopik> ski: but indeed, this must be the type
04:00:57 <ski> Nopik : in 'ff3', you want 'a <- lift ask3' since 'ask3' works in the 'MyMonad Int Int Int' monad, you need to lift it to work in the 'ReaderT String (MyMonad Int Int Int)' monad
04:01:07 <kolmodin> dons: http://www.imdb.com/title/tt0486551
04:01:09 <lambdabot> Title: Beerfest (2006)
04:01:29 <kolmodin> especially funny if you have seen (and liked) their previous movies
04:01:49 <ski> Nopik : alternatively, you need to wrap with 'lift' to get down from the top monad into the inner monad, 'MyMonad Int Int Int'
04:02:07 <ski> @type Control.Monad.Reader.lift
04:02:09 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
04:02:34 <ski> lift :: MyMonad a b c d -> ReaderT r (MyMonad a b c) d  -- in your case
04:02:57 <ski> (where 'ReaderT r' could be any monad transformer)
04:04:05 * mux finds implicit maybes in the view patterns proposal nasty, and the implicit tupling even more so
04:05:32 <ski> Nopik : i'm not sure what you want to do in 'trans1' .. mayhaps you want 'trans1 = lift myaction' ? .. the '"environment"' there is possibly misplaced though, since an environment isn't provided/specified by an action, it is given to it from the outside (the environment :)
04:05:44 <ski> mux : where ?
04:06:08 <mux> ski: http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
04:06:58 <Nopik> ski: i just want to use ff3 and ask/get inside ;)
04:07:07 <Nopik> to read from "environment" string
04:07:11 <Nopik> brb
04:08:34 * robyonrails qualche erlenger?
04:08:41 * robyonrails qualche erlanger?
04:10:58 <ski> mux : the first variant seems to be just transformational patterns ..
04:11:09 <dons> augustss: so you think this qwe1234  thing is going to work? :)
04:12:07 <dons> ?users #xmonad
04:12:07 <lambdabot> Maximum users seen in #xmonad: 55, currently: 50 (90.9%), active: 3 (6.0%)
04:17:41 * ski agrees with mux regarding implicit maybes and tupling
04:21:40 <fasta> Is combining two Doc values a constant time operation?
04:21:56 <fasta> I.e. is it not implemented with ++ under the hood?
04:23:16 <HairyDude> is there a standard function iterateM :: Monad m => (a -> m a) -> a -> m [a] ?
04:23:24 <EvilTerran> ?type iterateM
04:23:32 <lambdabot> Not in scope: `iterateM'
04:23:46 <HairyDude> it seems an obvious candidate
04:23:47 <EvilTerran> @docs Control.Monad
04:23:47 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
04:24:03 <dons> fasta, yeah, it uses diff lists
04:24:19 <dons> see the classic pretty printing combinators paper
04:24:41 * EvilTerran wants takeWhileM and suchlike, too
04:32:09 <ski> HairyDude : which 'm' had you in mind ?
04:32:27 <HairyDude> ski: in this case, State [Integer]
04:33:12 <ski> i don't think that will work
04:33:25 <HairyDude> I've implemented it, it works fine
04:33:47 <ski> what is the state after executing 'iterateM' ?
04:34:25 <hpaste>  HairyDude pasted "iterateM in action" at http://hpaste.org/1884
04:36:54 <fasta> dons: I have that $f5 (whatever that is) takes 35.3   72.8 (time and alloc). How do I find what that is?
04:37:17 <dons> $f5?
04:37:26 <dons> you profiling with -prof -auto-all ?
04:37:44 <vincenz> moion
04:37:53 <dons> you know about {-# SCC "foo" #-} pragmas to insert cost centres on subexpressions?
04:38:34 <fasta> dons: I am profiling with -prof -auto-all, yes.
04:39:00 <fasta> dons: yes, I know about that pragma, but I have no idea where to put it.
04:39:02 <HairyDude> ski: the state is _|_
04:39:08 <matt__r> was anyone else fooled by johan's little alien images?
04:41:13 <ski> HairyDude : yes, i stand corrected
04:41:51 <dons> matt__r: that was very well constructed, wasn't it. lots of little teasers :)
04:41:52 * ski wonders on the exact definition of "strict" monad
04:42:24 <matt__r> dons:and it wasn't until the very last one that I realised it was for ICFP
04:42:27 <ski> Nopik : it works now ?
04:42:37 <dons> matt__r: hah
04:42:41 <EvilTerran> ski, there was a massive conversation about that on here a few days ago
04:42:51 <dons> matt__r: you just thought he was starting a new career?
04:43:07 <EvilTerran> iirc, i started it with some off-the-cuff remark...
04:43:10 <matt__r> dons: I thought someone was playing a game with his email inbox
04:43:45 <matt__r> dons: I guess I am easily fooled :)
04:43:51 <HairyDude> ski: I suppose iterateM would be of marginal use in the IO monad unless you use unsafeInterleaveIO
04:44:20 <matt__r> dons: did I hear that you are headed state-side?
04:44:40 <dons> matt__r: yeah, that's right.
04:44:44 <EvilTerran> ...with unsafeInterleaveIO, would it make writing getContents-esque functions easier?
04:44:56 <matt__r> dons:  good for you, bad for us I guess :(
04:45:09 <dons> :| yeah, its a bit sad to leave
04:48:39 <matt__r> dons: where exactly are you headed?
04:49:06 <ski> HairyDude : *nod*
04:49:15 <dons> oh, off to work at Galois, in Portland. More Haskell hacking :)
04:50:32 <matt__r> dons: well, it is certainly a nice part of the world oar-e-gen :)
04:50:55 <dons> heh. yeah. nice and clean, good public transport. cold though :}
04:52:28 <matt__r> dons: SNOW!!!!!!!!!!'
04:53:02 <HairyDude> EvilTerran: surely getContents just uses replicateM
04:53:34 <EvilTerran> @src replicateM
04:53:35 <lambdabot> replicateM n x = sequence (replicate n x)
04:53:52 <EvilTerran> getContents is lazy, tho...
04:53:56 <HairyDude> EvilTerran: you can use iterateM, but you have to wrap the thing in const and add a dummy argument
04:54:57 <EvilTerran> @src getContents
04:54:57 <lambdabot> getContents = hGetContents stdin
04:55:04 <EvilTerran> @src hGetContent
04:55:04 <lambdabot> Source not found. Just what do you think you're doing Dave?
04:55:05 <EvilTerran> @src hGetContents
04:55:05 <lambdabot> Source not found. Are you on drugs?
04:55:10 <EvilTerran> ... i give up.
04:56:28 <HairyDude> @src GHC.IO.hGetContents
04:56:28 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
04:58:57 <HairyDude> looks like GHC's hGetContents uses a function called lazyRead, which uses explicit recursion
05:01:13 <fasta> dons: Any idea how I can optimize this? http://paste.debian.net/33453 My program spends 50% of time in here.
05:04:27 <chessguy> @type put
05:04:29 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
05:04:35 <dons> oh crikey. write it a bit lower level?
05:04:49 <dons> use unsafeRead/Write, since you already know the bounds
05:05:02 <chessguy> @type get
05:05:04 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
05:05:07 <dons> use strict updates, and strict fields in the record types?
05:05:17 <dons> look at the core for the loop
05:05:51 <fasta> dons: also, I implented a doubly linked list on top of DiffArray
05:06:09 <fasta> dons: that was probably the dumbest idea of the century?
05:06:11 <dons> i'm not sure DiffArrays are the most performant types
05:06:23 <dons> probably Data.Sequence would be better
05:06:49 <fasta> dons: I used DiffArrays, because theoretically it is a constant time operation.
05:07:10 <fasta> dons: but it appears the constant factors are now a bit too high :(
05:07:17 <dons> theoretically. practically i've need seen them used for high performance code
05:07:40 <vincenz> MArray
05:07:47 <dons> they were written before the days when performance expectations were a bit lower, so i'd be suspicious of diffArrays
05:07:55 <fasta> dons: On top of this doubly linked list, I implemented a graph, which is on what my algorithms run,
05:07:57 <dons> s/before/in /
05:08:07 <fasta> dons: so, you can imagine the constant factors involved.
05:08:09 <dons> oh man. why not use Data.Graph.Inductive or something? :)
05:08:32 <fasta> dons: I need to have the abstractions as available in a good C implementation.
05:08:56 <fasta> dons: Would you suggest me to implement the doubly linked list and graph in the ST monad?
05:09:21 <fasta> dons: I think that time is better spend than trying to save the DiffArray based approach.
05:09:22 <dons> If you're planning to write from scratch, then yeah, I'd just implement it as you would in C
05:09:52 <dons> I couldn't really say more without grokking all the data structures
05:10:02 <dons> you can start by SCC annotating that code to see where the costly bits are
05:10:08 <fasta> dons: If the DiffArray stuff magically becomes 100 times faster, it would be practical.
05:10:35 <fasta> dons: Computing the connected components of a graph with 30 nodes and 150 edges takes 0.8 seconds now.
05:10:48 <fasta> dons: that should take something like 0.01 second, I guess.
05:10:57 <fasta> seconds*
05:10:58 <dons> Try not using DiffArray :)
05:11:15 <dons> they shouldn't even be in base.
05:11:33 <fasta> dons: right, if onlly the compiler would automatically transform is to super dupee fast ST code...
05:11:36 <fasta> only*
05:12:02 <fasta> dons: linear types should be able to do that, right?
05:14:21 <fasta> dons: is there anything in those 300 libraries that implements a doubly linked list in ST?
05:17:18 <fasta> Heh, I wonder whether implementing a doubly linked list with harpy will be faster :D
05:17:49 <vincenz> fasta: why are you doing this
05:17:55 <vincenz> fasta: there's a graph lib that does this for you
05:17:58 <vincenz> o.O
05:18:06 <vincenz> sccComponents = connected componetns
05:18:21 <vincenz> Data.Graph
05:18:25 <fasta> vincenz: I implemented an asymptotically optimal algorithm
05:18:53 <fasta> vincenz: if I then test that with an asymptotically slow graph library, it's pointless.
05:18:54 <vincenz> Ok
05:19:05 <profmakx> fasta: will your code be publically available?
05:19:41 <fasta> profmakx: The top of the chain with a completely deciphered vague algorithm will probably be available
05:20:09 <fasta> profmakx: the algorithms I implemented are described sometimes incorrectly, sometimes very vague in the literature.
05:20:24 <fasta> profmakx: my description will hopefully be next to perfect.
05:21:42 <profmakx> hopefully I will be looking into some graph-algorithms during the weekend
05:28:31 <ejt__> hi, does anyone know what the fastest Haskell implementation of ICFP2007 dna -> rna is ?  I'm just wondering how far off my 4000 iterations per second is
05:29:12 <Cale> ejt__: My not-terribly optimised implementation is 10k/s, and I know there's one that's 4 times that.
05:29:37 <Cale> It's really really important to get the right datastructures.
05:29:58 <dons> desp had 45k or something, yeah. we could do better though, with fingertree chunks, I suspect.
05:30:02 <Cale> (and strictness/laziness)
05:30:18 <ejt__> 45k is very impressive
05:30:22 <desp> no, I think slower than 45k
05:30:23 * ejt__ goes back to the drawing board
05:30:27 <desp> but it depends on the cpu
05:30:45 <ejt__> I'm running in vmware on a laptop, so not quick
05:30:47 <desp> ejt__: you can darcs get http://varsztat.com/clfp/dna2rna-src/
05:30:50 <lambdabot> Title: Index of /clfp/dna2rna-src
05:30:57 <ejt__> desp: great, thx
05:30:57 <desp> and see for yourself
05:31:11 <desp> magnus had a 1/3 faster C version
05:31:21 <dons> someone should set up a shootout for this , on one machine
05:31:30 <dons> someone not writing up a thesis..
05:31:34 <desp> and some guys on the mailing list were bragging about their ultra-fast C impls
05:32:29 <dons> one guy on reddit sounded like he had a nice stl/ropes impl
05:32:39 <projectxz> hey dons, me again. just wondering: when i do ghc-pkg list (Cabal-1.1.6), Cabal-1.1.6.2 comes up (with a few other packages)... is there any significance in the parentheses around the first cabal?
05:32:47 <ndm> dons: the nobench site seems to have flipped to list fusion benchmarking, is it still being run regularly?
05:32:56 <dons> projectxz: it means its installed, and not visible.
05:33:09 <dons> ndm, not being run regularly. check the x86-64 results though
05:33:25 <ndm> dons: chances of it running on Windows?
05:33:27 <dons> yeah, oops, during the icfp paper deadline somehow i overwrote that file with my benchmarks
05:33:35 <dons> ndm, don't see why not. with gnu make installed
05:33:36 <ndm> yeah, i guessed :)
05:33:38 <projectxz> k thanks dons
05:35:26 <fasta> It is quite disappointing that one needs to use the ST monad to get efficient code.
05:35:39 <fasta> It kinds of defeats the whole functional programming idea
05:35:47 <dons> it depends on the data type, fasta.
05:35:51 <dons> graphs are hard.
05:35:56 <projectxz> k thanks again D
05:36:07 <fasta> dons: graphs based on DiffArray have a fantastic API
05:36:19 <fasta> dons: and in theory, they should be fast.
05:36:22 <dons> you could try reimplementing the DiffArray type to be a bit faster
05:36:29 <dons> that would be something i'd probably attempt
05:36:43 <dons> profile your own DiffArray implementation.
05:36:56 <ejt__> desp: about 20k/second on my machine so ~5 * faster than mine :)
05:37:04 <fasta> dons: how could it be made faster then?
05:37:07 <desp> ah
05:37:18 <desp> my version still can be made faster
05:37:25 <dons> fasta, i've not looked at the implementation, but its rather old. it probably doesn't take advantage of the modern ghc tricks
05:37:28 <desp> I'm working on it, slowly... :)
05:37:52 <fasta> dons: I think that would never make a >10 times difference.
05:38:02 <dons> sure it could.
05:38:18 <fasta> ?
05:38:28 <dons> if its very bad, it could easily be 10x too slow
05:38:49 <dons> anyway, you best decide how you want to attack it.
05:39:08 <fasta> I just wished someone had written some actual useful code
05:39:25 <fasta> I had to implement everything from scratch.
05:39:28 <dons> yes, the graph libs are a bit of a gap in the libraries at the moment
05:39:39 <dons> we've been waiting for someone who cares about graphs to fix that
05:39:46 <dons> maybe *you* can be that person!
05:40:00 <dons> or why not just binding to some standard C graph library?
05:40:26 <fasta> dons: like what "standard C graph library"?
05:40:28 <ndm> has anyone figured out what a Graph should look like in Haskell
05:40:40 <fasta> ndm: in theory, I have.
05:40:46 <fasta> ndm: in practice, you need ST
05:40:46 <ndm> i know some people have had thoughts, but i haven't seen the answer yet
05:40:47 <dons> ndm, fgl is one.
05:40:56 <ndm> dons: i remain to be convinced
05:40:57 <fasta> fgl is a mistake
05:40:57 <dons> fasta, have you looked at Data.Graph.Inductive at all?
05:41:03 <ndm> fasta: yes, i think you are probably right
05:41:03 <fasta> dons: yes, in depth
05:41:09 <dons> i used it in the ICFP contest and it was fine
05:41:23 <ndm> some graph programs can probably be done functionaly, but some just don't suit it with the current abstraction
05:41:27 <fasta> dons: ok, to how many vertices does it scale?
05:41:33 <dons> about 1000 :)
05:41:36 <ndm> i wonder if a zipper like structure for a graph might work to keep it pure and mutable
05:41:39 <fasta> dons: 1000 is a joke
05:41:48 * Nopik is back
05:41:59 <dons> fasta, then you'll just need to write your own, or bind to boost/graphs or something
05:42:06 <dons> you're looking to get famous, right?
05:42:15 <Cale> I'd really like to see a good relation data structure get added to the GHC distribution.
05:42:17 <dons> solving the graph library problem for the haskell community would help
05:42:40 <dons> someone's got to do it. someone who uses graphs and cares about performance
05:42:43 <roconnor> @tell cjeris Coq accpeted the proof about limits of sequences of compositions of functions.
05:42:43 <lambdabot> Consider it noted.
05:42:52 <Cale> Wolfram Kahl apparently has one which is an extension of the UMinho Data.Rel, but I'm not sure if he's released it in any way.
05:43:00 <ndm> the problem is graphs aren't that useful in most problems
05:43:11 <ndm> i.e. little motivation in general
05:43:19 <dons> ndm, right, but then in some problems, they're critical, so you need to find someone who knows the area
05:43:24 <ndm> indeed
05:43:28 <dons> a bit like guis or databases or networ stuff
05:43:43 <ndm> we have a graph programming research team in York
05:43:59 <Cale> If we had a really good relation data structure, graphs are just another way of looking at that.
05:44:02 <quicksilver> I strongly suspect that graphs are useful in more problems than many programmers realise
05:44:03 <ndm> exactly like that, although less common, as you can always get around the lack of a graph while, gui/network is essential
05:44:06 <fasta> dons: I have no idea how to bind generic C++ code to Haskell
05:44:16 <doserj> are you speaking about general graphs, or DAGs?
05:44:24 <ndm> i have written some programs in GP, which is a non-deterministic graph programming language, its quite neat
05:44:40 <fasta> doserj: (non-simple) graphs
05:44:42 <ndm> mainly finite state machine stuff
05:45:10 <fasta> dons: and AFAIK, that's another area where the Haskell community has no clue of how to do it.
05:45:11 <Cale> Has anyone tried UMinho's Data.Rel?
05:45:31 <fasta> Cale: not asymptotically efficient
05:45:46 <fasta> Cale: for graph applications, that is.
05:47:02 <Cale> Really? What assumptions allow for better asymptotic efficiency in graphs than is possible using general relation algorithms? I wouldn't have thought that the assumption that the domain and codomain were the same to be all that important. Perhaps that's naive :)
05:47:53 <fasta> Cale: I am talking about the implementation
05:47:59 <Cale> ah, okay
05:49:08 <fasta> Really, imho, either there is no good software, or everything is proprietary.
05:49:28 <Nopik> ski: ok, i've managed to get something that compiles, runs and uses ReaderT.. though without ask yet ;)
05:49:42 <Nopik> ski: just some lifting over existing monads.. now i have to add ask
05:49:59 <roconnor> Ugh, ``although continuous functions [on a compact interval] have a supremum, they do not necessarily obtain it'' ... Stupid constructive analysis.
05:49:59 <ski> ok
05:50:17 <ski> obtain ?
05:50:49 <quicksilver> 'attain' surely
05:50:55 <ski> roconnor : where's that from ?
05:51:05 <vincenz> augustss: qwe1234 is amusing :)
05:51:07 <steven-ashley> is it just me or is haskell.org incredibly slow atm?
05:51:23 <fasta> steven-ashley: not just you
05:51:24 <Cale> steven-ashley: not just you
05:51:34 <roconnor> ski: Luis Cruz-Filipe's thesis
05:51:35 <dmwit> Huh, seems like a compact interval should ensure that the function attains its supremum.
05:51:44 <Nopik> ski: ok, got it.. thanks a lot ;)
05:51:48 <steven-ashley> :( ok
05:51:55 <roconnor> dmwit: not in constructive mathematics :(
05:52:11 <vincenz> @quote stereo
05:52:12 <lambdabot> stereo says: Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
05:52:14 <Nopik> though this lifting is not 100% clear to me.. it is intuitive in use but i am not sure yet why it is necessary here ;p
05:52:22 * ski looks around, but can't see augustss active
05:52:33 <Cale> So, UMinho's libraries use primarily a Data.Set of pairs for representing a relation. Is there something fundamentally wrong with that?
05:52:59 <Nopik> @type lift
05:53:08 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
05:53:09 <Cale> Is it the extra log factors people are worried about?
05:53:47 <ski> Nopik : 'ask3' is an action in the 'MyMonad Int Int Int String' monad .. you want to use it as an 'ReaderT r (MyMonad Int Int Int String)'-action, hence you need to lift to bridge the gap
05:54:28 <Nopik> ski: yeah, it seems so.. but i need to decypher exact meaning of a<- lift ask3 first ;)
05:54:44 <roconnor> @type lift
05:54:46 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
05:54:56 <Nopik> @undo do a <- lift ask3 ; b <- ask; return $ a+b
05:54:56 <lambdabot> lift ask3 >>= \ a -> ask >>= \ b -> return $ a + b
05:55:18 <Cale> fasta: Can you give me some important target asymptotic complexities?
05:55:18 <Nopik> @undo do a <- ask ; b <- lift ask3; return $ a+b
05:55:19 <lambdabot> ask >>= \ a -> lift ask3 >>= \ b -> return $ a + b
05:55:47 <fasta> Cale: try a more specific question
05:55:54 <Nopik> lift ask3 has stronger binding than >>= and \ ?
05:55:55 <Cale> I don't know a whole lot about graph representations beyond the obvious ones.
05:56:14 <dons> fasta just wants it fast? but you want to avoid using ST for the obvious text book implementations?
05:56:18 <Botje> sum `liftM` sequence [ask, ask3] -- /me hides
05:56:31 <Cale> fasta: Well, where in particular does UMinho's implementation have worse asymptotic complexity than could be expected?
05:56:41 <Nopik> Botje: ;)
05:56:43 <ski> roconnor : "Constructive Real Analysis: a Type-Theoretical Formalization and Applications" <http://slc.math.ist.utl.pt/lcf/pubs/phd.(ps.gz|pdf)> ?
05:56:44 <Cale> (I'm just curious)
05:57:02 <Nopik> @type sequence
05:57:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:57:06 <Nopik> @src sequence
05:57:06 <lambdabot> sequence ms = foldr k (return []) ms
05:57:07 <lambdabot>     where
05:57:07 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
05:57:10 <fasta> Cale: I cannot get the package now
05:57:15 <fasta> Cale: haskell.org is too slow
05:57:20 <Cale> ah, okay
05:57:37 <vincenz> Cale: que pasa
05:57:41 <Cale> Nopik: that's an awful implementation of sequence to read, here's a better one
05:57:44 <ski> Nopik : 'lift' is just a function
05:57:50 <Cale> sequence [] = return []
05:58:07 <Cale> sequence (x:xs) = do { v <- x; vs <- sequence xs; return (v:vs) }
05:58:09 <Nopik> @src lift
05:58:09 <lambdabot> Source not found. It can only be attributed to human error.
05:58:11 <ski> sequence = foldr (liftM2 (:)) (return [])
05:58:13 <dons> anyone want to sit back and enjoy augustss and qwe1234 discuss type systems? :) http://programming.reddit.com/info/29icg/comments/c29jm5
05:58:14 <lambdabot> Title: Types don&#39;t just contain data, types explain data (reddit.com)
05:58:21 <Nopik> Cale: nice, thanks
05:58:24 <fasta> dons: Can I bind to http://developer.gnome.org/doc/API/glib/glib-doubly-linked-lists.html and then turn those IO operations into ST operations?
05:58:24 <vincenz> dons: yeah, that was what my earlier omment was about
05:58:26 <lambdabot> http://tinyurl.com/39kou4
05:58:30 <Cale> Yes, or what ski wrote, if you're familiar with liftM2 :)
05:58:56 <fasta> dons: I would be happy to reduce the amount of code I need to maintain, you see. :)
05:59:04 <Cale> The version that ski gave is actually particularly beautiful in that it emphasizes the idea that list structure is being replaced with program structure.
05:59:20 <Nopik> the version that ski wrote was 'improved' by my irc client and i see a lot of smileys inside :D
05:59:26 <Botje> ski: might as well foldr ap (return []) then :)
05:59:26 <Cale> oh
05:59:26 <dons> fasta, mmm. that looks doable
05:59:31 <vincenz> dons: I wonder if he's truly that ignorant
05:59:44 <Nopik> i dare to say that it was lifted..
05:59:46 <ski> @type foldr ap (retunr [])
05:59:47 <lambdabot> Not in scope: `retunr'
05:59:48 <dons> just give it an IO (or wrapper monad) implementation
05:59:52 <ski> @type foldr ap (return [])
05:59:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m ([a] -> [a])] -> m [a]
06:00:05 <Cale> Nopik: Does:  sequence = foldr (liftM2 ( : )) (return []) -- show up fine?
06:00:11 <Botje> hmmm
06:00:11 <Botje> wait
06:00:15 <Botje> ap is defined as liftM2 id
06:00:16 <Nopik> Cale: yes, thanks
06:00:17 <Botje> ignore me :)
06:00:28 <fasta> dons: can I then get type signatures for those operations that are generic?
06:00:57 <fasta> dons: that is that I build a GList with e.g. (Int, String, [Bar])?
06:01:06 <fasta>  can build*
06:01:58 <dons> fasta, yeah, they'd be Storables , so you'd use those to pack the data into structures the foreign library manipulates
06:03:00 <fasta> dons: I am completely ignorant in this area, although I would like to learn how to do so.
06:03:17 <quicksilver> I think it depends ifyou want them to be 'haskell linked'
06:03:32 <quicksilver> if you want the garbage collector to be able to collect ends of the list independently
06:03:42 <quicksilver> then maybe you want them as haskell objects
06:03:49 <dons> fasta, you could look at c2hs or hsc2hs, to do the foreign binding
06:04:43 <fasta> A manual for doing a binding would be nice.
06:04:54 <tcr> I tried to load QuickCheck.hs from within ghci, but I get QuickCheck.hs:147:52: Not in scope: `chr'  (similiar messages for `ord' and `fromInteger').
06:04:56 <quicksilver> I *think* if you import the glib ones you'll end up having to worry about memory deallocation
06:05:11 <quicksilver> tcr: that sounds like the old quickcheck
06:05:19 <quicksilver> tcr: the new one probalby came with your ghci
06:05:23 <dons> yeah, you'll likely want to use ForeignPtrs to attach glib finalisers to be called whn the Haskell GC decides its time to go
06:05:28 <quicksilver> tcr: try just doing :m +Test.Quickcheck
06:06:06 <tcr> quicksilver: Indeed.
06:06:09 <tcr> Thanks.
06:06:46 <fasta> Is there any document describing a complete procedure that I need to follow to do a binding?
06:08:06 <fasta> I thought augustss had something better to do.
06:08:29 <vincenz> fasta: everyone needs some entertainment :)
06:10:12 <ndm> can anyone explain paramorhpisms?
06:10:19 <ndm> paramorphisms
06:10:24 <ndm> to get the spelling right
06:10:41 <vincenz> @remember qwe1234 i agree. haskell, as a language, would only win if it was cleansed of the gibberish. unfortunately, that isn't realistic as it would put those lazy grant seeking academics out of a job. (once everyone would realize that they aren't producing anything of value, merely rehashing the same decades-old ideas.)
06:10:41 <lambdabot> Done.
06:12:43 <dcoutts> fasta: you may want to look at the glib package in gtk2hs
06:13:29 <Lemmih> vincenz: Who does he agree with?
06:13:33 <Nopik> is it possible to transform this: m >>= k = ReaderT $ \r -> do a <- runReaderT m r; runReaderT (k a) r   into something with let but without do?
06:13:41 <vincenz> Lemmih: himself :)
06:13:44 <Nopik> is it possible t@undo ReaderT $ \r -> do a <- runReaderT m r; runReaderT (k a) r
06:13:49 <Nopik> @undo ReaderT $ \r -> do a <- runReaderT m r; runReaderT (k a) r
06:13:50 <lambdabot> ReaderT $ \ r -> runReaderT m r >>= \ a -> runReaderT (k a) r
06:13:53 <fasta> dcoutts: as an example or because you already have bound GList?
06:14:02 <dcoutts> fasta: right
06:14:11 <dcoutts> fasta: and GObject finalisers
06:14:21 <Nopik> too many runReaderT to me ;p
06:14:29 <fasta> dcoutts: uh, so which one is it? An example?
06:15:05 <dcoutts> fasta: http://darcs.haskell.org/gtk2hs/glib/System/Glib/GList.chs
06:16:07 <fasta> dcoutts: ah, you only implemented the interoperability code.
06:16:21 <johanj> ndm: a paramorphism is a fold, where you can also use the recursive argument (and not just the result of folding the recursive argument) in the recursive step
06:16:35 <dcoutts> fasta: that's what we needed for the higher level Gtk+ stuff
06:16:45 <fasta> {# context lib="glib" prefix="g" #}
06:16:45 <fasta> {#pointer * GList#}
06:16:45 <fasta> {#pointer * GSList#}
06:16:51 <fasta> dcoutts: what is that?
06:16:53 <dcoutts> fasta: c2hs
06:16:58 <fasta> dcoutts: ok
06:17:09 <dcoutts> note the .chs file extension
06:17:35 <fasta> Ok, I will see whether I can do anything with the tools dons mentioned.
06:17:37 <fasta> dcoutts: thanks
06:18:02 <dcoutts> fasta: he mentioned c2hs and hsc2hs, we use both in gtk2hs
06:18:11 <dcoutts> http://darcs.haskell.org/gtk2hs/glib/System/Glib/
06:18:11 <lambdabot> Title: Index of /gtk2hs/glib/System/Glib
06:18:17 <dcoutts> see the .chs and .hsc files
06:19:04 <ndm> johanj: thanks
06:37:43 <Nopik> @undo do return 42
06:37:43 <lambdabot> return 42
06:37:55 <Nopik> @undo do a <- ask; return a
06:37:55 <lambdabot> ask >>= \ a -> return a
06:38:43 <norpan> undo indeed
06:38:59 <norpan> i like monad comprehensions
06:39:03 <Nopik> undeed indo
06:45:31 <Nopik> is there any haskell compiler/interpreter for pda? :p
06:45:43 <Nopik> with it you do not need any sudoku in flight ;)
06:46:10 <Lemmih> Nopik: hugs perhaps?
06:46:29 <Nopik> Lemmih: do you happen to know any links?
06:46:55 <Lemmih> @where hugs
06:46:55 <lambdabot> http://haskell.org/hugs
06:48:32 <Nopik> hm, i dont see any wince port ;p
06:50:12 <ndm> i don't think there is one anymore
06:50:22 <ndm> there was at some point, but its gone ages ago
06:50:35 <ndm> it may still compile, if you have some hacking time/experience to spare
06:50:52 <ndm> I think Yhc/nhc both run on PDA's, several people have tried, some have succeeded, but i've never actually seen the goods
06:52:00 <Nopik> hm
07:00:52 <dons> ?users
07:00:52 <lambdabot> Maximum users seen in #haskell: 367, currently: 350 (95.4%), active: 6 (1.7%)
07:00:58 <Nopik> @undo do a <- runReaderT m r; runReaderT (k a) r
07:00:59 <lambdabot> runReaderT m r >>= \ a -> runReaderT (k a) r
07:01:14 <dons> @. pl undo do a <- runReaderT m r; runReaderT (k a) r
07:01:14 <lambdabot> flip runReaderT r . k =<< runReaderT m r
07:01:19 <dons> mm. cryptic
07:01:47 <opqdonut> lambdabot has this thing for =<< one has to admit :)
07:02:05 <Nopik> ;)
07:02:19 <opqdonut> @pl (>>=)
07:02:19 <lambdabot> (>>=)
07:02:27 <opqdonut> @pl flip (>>=)
07:02:28 <lambdabot> (=<<)
07:02:31 <opqdonut> ^_^
07:03:01 <dons> yeah, that's TheHunter's (original author of @pl's) doing
07:03:07 <opqdonut> of course, only a human could see any benefit in using >>=
07:03:32 <opqdonut> =<< is somehow much more "consistent"
07:03:53 <dons> it fits nicely with pure pipelines
07:04:06 <dons> print . sum  . map read  . lines =<< getContents <--
07:04:19 <SamB_XP_> I do it too
07:04:31 <vincenz> getContents >>= lines ... map read ... sum ... print
07:04:37 <vincenz> let a ... b = b .a
07:04:44 <ski> >.>
07:04:46 <dons> >.> is what Thompson uses, iirc
07:04:47 <SamB_XP_> >>> already does that ;-)
07:04:53 <vincenz> ok ok :)
07:05:12 <vincenz> getContents >>= lines >>> map read >>> sum >>> print
07:05:15 <dons> :t getContents >>= lines >>> map read >>> sum >>> print
07:05:23 <lambdabot>     precedence parsing error
07:05:23 <lambdabot>         cannot mix `(>>=)' [infixl 1] and `(>>>)' [infixr 1] in the same infix expression
07:05:29 <dons> doh
07:05:31 <SamB_XP_> hmm.
07:05:39 <SamB_XP_> I never actually *tried* it
07:05:39 <dons> :t getContents >>= ( lines >>> map read >>> sum >>> print )
07:05:41 <lambdabot> IO ()
07:05:46 <SamB_XP_> I'm happy with the other way ;-)
07:05:54 <dons> it should work though. the fixity should be changed
07:06:02 <vincenz> we need 1.5 fixity
07:06:14 <dons> `(>>=)' [infixl 1] and `(>>>)' [infixr 1]
07:06:16 <SamB_XP_> yay for Rational fixities!
07:06:26 <Lemmih> Should (>>>) be infixl?
07:06:29 <dons> should they fixify in different directions? seems unusual
07:06:57 <ski> is any direction preferred ?
07:07:05 <SamB_XP_> what fixity is >>?
07:07:22 <ski> 'infixr', iirc
07:07:23 <Botje> whicherver scores lowest golf scores :)
07:07:53 <SamB_XP_> Botje: there's more to it than that
07:07:57 <magnus> @src >>>
07:07:57 <lambdabot> Source not found. Just what do you think you're doing Dave?
07:08:00 <SamB_XP_> what about opimizations?
07:08:07 <SamB_XP_> will it confuse any of them?
07:08:12 <dons> yeah, maybe there's some efficiency in there
07:08:37 <SamB_XP_> dons: I don't know if one or the other is inherently more efficient
07:09:00 <SamB_XP_> and if one is, who knows if it's the one we have now?
07:09:26 <SamB_XP_> but the authors of arrow-based libraries may have biased their opimizations to the present fixity, may they not have?
07:09:44 <SamB_XP_> so they at least need to be consulted on this issue
07:09:51 <dons> it just seems they all Arrowed to infixr
07:10:02 <dons> i just posted a mail to -cafe@ about it
07:10:07 <vincenz> dons: can't find the report button
07:10:09 <dons> see if Ross or someone has something to say
07:10:20 <dons> vincenz: you don't see 'report' under every qwe1234 post?
07:10:25 <vincenz> oh
07:10:47 <SamB_XP_> anyway, does >>= require it's present fixity?
07:10:58 * SamB_XP_ suspects yes, but wants to see why
07:11:07 <vincenz> dons: there should be a 'report' button on profiles
07:12:01 <dons> i think you have to hit a certain number of 'reports' for a single post
07:12:17 <dons> but i'm not sure if it even does anything -- though spammers seem to get removed
07:12:41 <SamB_XP_> vincenz: what? is it an inappropriate profile?
07:13:19 <vincenz> SamB_XP_: have you ever read any of his comments?
07:14:01 * vincenz is going to report any comment from qwe1234 from now on that insults the person he's talking to literally
07:14:18 <dons> i've been doing that for a while now
07:14:23 <dons> it seems a reasonable course to take
07:14:33 <dons> but we tried to train him oh, 10 months ago :(
07:14:44 <dons> so i think he just likes making thiings unpleasant
07:14:48 <dolio> He was gone for a while. What happened?
07:15:01 <dons> yeah, that was nice. he came back about a week ago i think
07:15:12 <vincenz> dons: we could start an "Ask Reddit: Should qwe1234 be removed from reddit"
07:15:21 <dons> its sad, it really makes me not want to write comments :(
07:15:23 <opqdonut> qwe1234?
07:15:39 <dons> vincenz: yes. i think that would be the next step. cite 4 or 5 recent threads
07:15:44 <vincenz> Will do
07:16:05 <dolio> ayrnieu seems to be gone.
07:16:10 <dons> point it out to everyone in here, I think we'd all be happy to see him gone.
07:16:17 <dons> yes, he's been quiet for a couple of weeks
07:17:06 <dolio> Perhaps it dawned on him that when everyone tells you you're being adversarial, it might not be everyone who has the problem. :)
07:17:44 <dons> i'm pretty sure he doesn't care. either that, or he's really insane.
07:17:59 <dons> you'd probably have to be , to put that kind of effort into such a pointless exercise
07:18:00 <dolio> Or he just got tired of the cabal of Haskell zealots down-modding all this posts.
07:18:05 <dolio> And all the OCaml stories, too. :)
07:18:08 <vincenz> http://programming.reddit.com/info/29m6w/comments/c29m7x?context=5
07:18:10 <lambdabot> Title: Ask reddit: Should qwe1234 be removed from reddit. (reddit.com), http://tinyurl.com/2ah5f9
07:18:25 <dons> http://programming.reddit.com/info/29m6w/comments
07:18:26 <lambdabot> Title: Ask reddit: Should qwe1234 be removed from reddit. (reddit.com)
07:18:27 <dons> cool
07:19:10 <dolio> Heh.
07:19:18 <dolio> @remember qwe1234 what's the last book you've read that doesn't have 'harry potter' in the title?
07:19:18 <lambdabot> Done.
07:20:08 <dolio> Ah, yeah, that argument with augustss was pretty amusing, too.
07:20:18 <vincenz> 2 downmods so far
07:21:07 <dons> poor audreyt
07:21:11 <dons> augustss.
07:21:37 <dolio> He seems mostly amused by qwe1234 and ayrnieu, though.
07:22:36 <dons> So really, anyone here who is sick of stupid noise, which kills off reddit as a place for PL discussion, click on 'report here, http://programming.reddit.com/info/29m6w/comments
07:22:38 <lambdabot> Title: Ask reddit: Should qwe1234 be removed from reddit. (reddit.com)
07:23:03 <dons> i wish you could trade karma for delete privledges
07:23:12 <vincenz> :)
07:23:21 <vincenz> well you're getting all the karma from my blog articles :P
07:23:29 <dons> :D
07:23:46 <dons> i'm in ur blogs stealin' ur karmas
07:24:03 <moonlite_> jkust
07:25:11 <moonlite_> just read the qwe1234 comments above. I haven't witnessed a troll like that before
07:25:13 <vincenz> "IM IN YR LOOP"
07:25:41 <dons> we need more upmmods, http://programming.reddit.com/info/29m6w/details
07:25:41 <lambdabot> Title: Ask reddit: Should qwe1234 be removed from reddit. (reddit.com)
07:25:52 <dons> maybe people really don't care :(
07:26:00 <dons> the subreddit isn't unified enough anymore
07:26:04 <vincenz> down to 0
07:26:07 <dons> gone are the long discussions
07:26:24 <dons> we used to conduct conversations in essay form :(
07:26:59 <dolio> Oh, so, I've been gradually writing up an article on delimited continuations on the wiki, but I'm kind of worried that it's not terribly lucid.
07:27:10 <dons> ah good!
07:27:13 <dolio> http://haskell.org/haskellwiki/Library/CC-delcont if anyone wants to tell me what they think.
07:27:14 <lambdabot> Title: Library/CC-delcont - HaskellWiki
07:27:15 <dons> yes, some examples should help motivate
07:27:28 <dons> it did take oh, what, 2 years for applicative functors to get used.
07:27:52 <ski> z'16
07:28:24 <ski> ESCREEN
07:28:50 <ndm> http://programming.reddit.com/info/29icg/comments/c29ln5
07:28:51 <lambdabot> Title: Types don&#39;t just contain data, types explain data (reddit.com)
07:28:54 <ndm> that's great!
07:29:10 <ndm> @remember qwe1234 what's the last book you've read that doesn't have 'harry potter' in the title?
07:29:10 <lambdabot> Done.
07:29:21 <vincenz> yeah
07:29:23 <vincenz> :)
07:29:27 <vincenz> erm
07:29:31 <vincenz> I only read harry potter
07:29:32 * vincenz cries
07:29:50 <dolio> Heh, that one's in there twice, now. It's a good'n', though.
07:29:56 <shapr> I wish reddit would give me the shapr login :-(
07:30:05 <vincenz> dons: it's going up
07:30:11 <psykotic> Round he throws his baleful eyes that witnessed huge affliction and dismay.
07:30:11 <ndm> dons: click report, on any comment or somewhere on the whole person?
07:30:21 <ndm> vincenz: i voted it :)
07:30:21 <dons> ndm, a bunch of comments
07:30:23 <psykotic> A dungeon horrible on all sides round, as one great furnace flamed.
07:30:37 <shapr> shaper isn't available either!
07:30:42 <psykotic> vincenz, there are great truths of programming hidden in those immortal lines :)
07:30:56 <vincenz> unityping?
07:32:08 <ndm> the last book i read was harry potter :) - i'm trying to get from 1 to 7 quick enough not to have it spoiled
07:32:50 * psykotic is on his second attempt at finishing Paradise Lost, hence the above
07:33:40 <psykotic> now i know why "Miltonian inversion" has entered the language as describing a particular tortuous rearrangement of syntax
07:34:03 <psykotic> ndm: do they get better after the first one?
07:34:16 <ski> psykotic : such as ?
07:34:17 <fasta> I have glib.h in /usr/include/glib-2.0, with this line #include <glib.h>, gcc claims it cannot find it. I tried gcc -lglib-2.0 <file>, but that didn't help either. Surely, I don't need to give the complete path. What is the right way to do it?
07:34:19 <ndm> psykotic: i've only read the first one, but i only started on my potter quest yesterday
07:34:28 <psykotic> ski: ?
07:34:36 <ski> re syntax
07:34:39 <jfredett> Look! Godwins law! *points*
07:34:39 <jfredett> "qwe1234: the only 'nonsensical' remark in this thread (so far) is yours.  fucking nazi."
07:34:41 <psykotic> ski: let me find an example.
07:34:45 <ndm> my new housemate travelled light, taking all 7 volumes of harry potter with her, and 7 seasons of buffy, so i'm quite busy at the moment
07:35:09 <doserj> fasta: -I/usr/inclde/glip-2.0
07:35:22 <doserj> erm, -I/usr/include/glib-2.0
07:36:05 <fasta> doserj: ok, I thought there was a more high-tech solution
07:36:20 <psykotic> ski: even the first sentence is a little tortuous.
07:36:38 <ski> of what ?
07:36:39 <psykotic> ski: http://www.gutenberg.org/files/26/26.txt, search for "Book I"
07:36:54 <doserj> fasta: you are using C, not high-tech
07:37:00 <psykotic> ski: it's probably not the kind of syntax you had in mind :)
07:37:23 <psykotic> i was talking about torturing english syntax in the service of poetry, particularly for euphony and meter
07:37:28 <fasta> doserj: but when I just do #include <glib.h>, I get lots of unresolved symbols.
07:37:38 <psykotic> i think milton can claim the prize there
07:37:49 <fasta> (I am trying to make something very simply work first in C and then do the binding)
07:38:33 <dolio> psykotik: You mean, how the actual sentence is "Sing, Heavenly Muse" in line 6? :)
07:38:40 <psykotic> dolio, yes :)
07:39:00 <shapr> ndm: But you've already read everything by Pratchett, right?
07:39:02 <psykotic> dolio, and it's a little challenging to figure out which objects the various adjectival phrases attach themselves to
07:39:15 <dolio> Yeah.
07:39:26 <doserj> fasta: the high-tech way probably is "
07:39:26 <doserj> pkg-config glib-2.0 --cflags"
07:39:46 <doserj> and use the ouput of that command
07:40:45 <fasta> doserj: right, that works perfectly.
07:40:45 <psykotic> dolio, i've seen an original folio edition, and it had almost no punctuation, adding to the fun
07:40:57 <shapr> Wow, qwe1234 is a real crackpot.
07:41:07 <dolio> Ah, indeed.
07:41:35 <vincenz> someone remind me
07:41:42 <vincenz> is it possible to have where clauses attached to one specific case clause?
07:41:45 <vincenz> case foo of
07:41:49 <vincenz>   x -> blabla
07:41:54 <vincenz>   (y,z) -> mimi
07:41:59 <psykotic> i thought where clauses were only top level?
07:42:00 <vincenz>       where mimi = somefunc y z
07:42:10 <vincenz> psykotic: you can have nested where's
07:42:31 <vincenz> psykotic: any definitional statement can have where's, just not sure how case-clauses enter that formula
07:42:36 <psykotic> ah
07:42:44 <ski> case-clauses can have 'where', too
07:42:44 <SamB_XP_> vincenz: yes, they are attached to a single case in either a case expression or a function definition
07:42:51 <vincenz> SamB_XP_: thx
07:43:00 <vincenz> ski idem
07:43:16 <ndm> shapr: one or two, but didn't really like them /me ducks
07:43:17 <ski> 'foo () = .. where ..' => 'foo = \x -> case x of () -> .. where ..'
07:43:33 <chessguy> @seen syzgy
07:43:34 <lambdabot> I haven't seen syzgy.
07:43:37 <SamB_XP_> they scope over all guarded RHSs of that case
07:43:42 * ski wonders what 'idem' might mean .. 'idempotent' maychance ?
07:43:51 <SamB_XP_> ski: that's the only thing I can think of
07:43:54 <ski> @seen Syzygy-
07:43:54 <lambdabot> Syzygy- is in #oasis, #haskell and #ghc. I last heard Syzygy- speak 5h 5m 3s ago.
07:44:01 <chessguy> ah
07:44:15 <SamB_XP_> chessguy: did those images finish?
07:44:17 <dolio> > case 5 of { 5 -> foo where { foo = 6 } ; _ -> 9 } -- wouldn't have guessed.
07:44:18 <lambdabot>  6
07:44:29 <chessguy> SamB_XP_, yes
07:44:39 <chessguy> SamB_XP_, and it didn't take all that long either
07:44:48 <SamB_XP_> chessguy: I found the key for page 84, I believe
07:44:59 <SamB_XP_> that took 3 hours of CPU time, 4 of real time!
07:45:00 <chessguy> @tell Syzygy didn't you port monads to some other languages? i'm curious about the possibility of porting them to javascript
07:45:01 <lambdabot> Consider it noted.
07:45:20 <chessguy> SamB_XP_, am i supposed to remember which one that is off the top of my head?
07:45:23 <pejo> chessguy, you want the - in his nick, I bet.
07:45:33 <SamB_XP_> chessguy: no ;-)
07:45:34 <dons> psykotic: you're reading paradise lost?
07:45:35 <chessguy> @tell Syzygy- didn't you port monads to some other languages? i'm curious about the possibility of porting them to javascript
07:45:35 <lambdabot> Consider it noted.
07:45:42 <shapr> chessguy: http://lambda-the-ultimate.org/node/1136
07:45:43 <lambdabot> Title: Collection of links to monad implementations in various languages. | Lambda the  ...
07:45:52 <dons> its wonderful, its one of the most satisfying things i've read.
07:45:55 <psykotic> dons: yes, for the second time. it's my favorite "book" of all time, though it took me a month and a half of daily reading to get through it the first time.
07:46:00 <SamB_XP_> you are supposed to use a nice image browser to scroll down to "page-1337.png"
07:46:01 <chessguy> ah, nice. thanks shapr
07:46:39 <chessguy> SamB_XP_, i'm at work
07:47:00 <SamB> chessguy: ah.
07:47:08 <SamB> well, okay, it's about error correcting codes
07:48:06 <chessguy> oh ok
07:48:59 <psykotic> dons: clearly someone needs to write an epic poem on haskell. that'll popularize it if anything will!
07:49:10 <psykotic> dons: that's what the kids want!
07:49:30 <SamB> now I just have to use it to decrypt the topic before display...
07:49:39 <Cale> dons: ahahaha, this greasemonkey script to block reddit comments and articles by user has a comment in it that says "my defaults: users: dons, martinbishop..."
07:49:49 <vincenz> lawl
07:49:51 <psykotic> hahaha
07:49:56 <SamB> heh
07:50:05 <sjanssen> :)
07:50:11 <psykotic> someone doesn't like don's haskell love
07:50:23 <dolio> Yeah. That martinbishop is no good. :)
07:50:46 <dons> Cale: hah!
07:51:23 <vincenz> well at least he's honest
07:51:28 <vincenz> maybe he just doesn't care about advanced languages
07:51:29 <Cale> It's funny, those two contribute probably 90% of the articles I actually mod up.
07:51:29 <dons> # // my defaults:
07:51:30 <vincenz> it's fair enough
07:51:30 <dons> # // users: dons, martinbishop
07:51:30 <dons> # // titles: erlang, ocaml, haskell, twitter, emacs
07:51:32 <vincenz> look at his other filter
07:51:34 <vincenz> ocaml, haskell
07:51:35 <vincenz> etc
07:51:53 <dons> yeah. its a reasonable filter for haskell, 'cept for that damn vincenz, Cale, alphecar and bos
07:52:14 <psykotic> i'm tuning up the haskell love for my part, maybe i can one day hope to enter his list
07:52:27 <fasta> Is there something like Haddock for C?
07:52:28 <sjanssen> dons: good news on the HW demo
07:52:37 <Cale> I'm not altogether entirely sure why I use programming.reddit, given that I consider the signal to noise ratio to be well under 1/10.
07:52:44 <fasta> I just want to know given a value of a certain type what I can do with it.
07:53:00 <dons> Cale, yeah , its a bit of a mystery. but LtU is too cold and unfriendly
07:53:08 <Cale> Oh, that's true too.
07:53:31 <dolio> Oh, one reason...
07:53:36 <Botje> you guys should submit a patch to his script
07:53:43 <dolio> dons: The 'From walking to zipping' blog doesn't seem to be on planet haskell.
07:53:53 <dolio> Unless I'm missing something.
07:53:55 <dons> dolio: oh, we should tell ibid
07:53:56 <fasta> E.g. I don't like Googling for any trivial function I am interested in like e.g. how to convert from an int to a string.
07:54:01 <Cale> HPaste looks like it could be adapted into a redditalike :)
07:54:06 <psykotic> fasta: i think doxygen is popular.
07:54:07 <dons> sjanssen: yeah. do you want to be an author for the demo? :)
07:54:25 <fasta> psykotic: I meant for the base functions.
07:54:35 <fasta> psykotic: e.g. math.h stdlib.h etc.
07:54:36 <sjanssen> dons: sure
07:54:40 <psykotic> fasta: ah
07:54:49 <vincenz> the greasemonkey script doesnt allow me to change the list
07:54:51 <fasta> psykotic: since I am not interested in writing massive amounts of code.
07:54:55 <fasta> psykotic: (in C)
07:55:28 <fasta> psykotic: GList in GLib for example is documented very clearly
07:56:08 <fasta> Everytime I ask this question, the answer is to use a book.
07:56:50 <psykotic> fasta: man pages? :)
07:57:19 <roconnor> ski: yes, page 21, just before lems 2.4.8
07:57:20 <fasta> psykotic: ok, how to find in the manpages how to get a string (char *) from an int
07:57:36 <roconnor> before lemma 2.4.8
07:57:37 <psykotic> fasta: oh, i see, that kind of thing
07:57:39 <ski> roconnor : ok, ty
07:57:46 <psykotic> fasta: can't think of anything
07:58:04 <psykotic> fasta: usually i use my IDE's builtin facilities for that.
07:58:12 <fasta> psykotic: on Windows?
07:58:18 <psykotic> yeah, like visual assist x
07:58:34 <psykotic> actually i guess it doesn't actually do hoogle-style searching
07:58:40 <moonlite_> fasta: i've learned, during the time i worked on my master thesis, that documentation is frowned upon in C-land.
07:58:42 <dons> vincenz: so i think we failed to build community support. we don't have a majority of upvotes.
07:58:56 <dons> but at least awareness is raised, so he'll likely be more aggresively down modded for crap now
07:58:58 <moonlite_> "what docs? Don't you have the.h-files?"
07:58:59 <vincenz> dons: yep
07:59:00 <psykotic> dons: i dislike the 'lord of the flies' approach.
07:59:07 <vincenz> dons: good thing I'm not so conscious about my karma :)
07:59:08 <psykotic> dons: even if i kinda agree with the sentiment.
07:59:55 <moonlite_> perhaps it might be more of an issue with the linux interfaces we used rather than C in general though...
08:00:03 <ivanm> dons: *gasp* you actually had to ask a question on haskell-cafe?
08:00:12 <dons> yeah, i think perhaps its not really for reddit. just reminding people about trolls and how to deal with them is a good idea though
08:00:13 * ivanm thought dons new everything about haskell...;)
08:00:23 <psykotic> ivanm, it's a trick, it must be an impersonator.
08:00:41 <ivanm> lol
08:00:52 <dons> psykotic: too many anarchists on reddit to get anyone organised :)
08:01:08 <dolio> ivanm: That's an illusion. It's really a bug report in disguise. :)
08:01:13 <ivanm> lol
08:01:25 <dcoutts> anyone here use Mac OS X and wants to test the final version of Gtk2Hs 0.9.12 for me ?
08:01:37 <dons> its a polite bug report :)
08:02:01 <ivanm> heh
08:02:02 <mux> 0.9.12 is out?
08:02:10 <mux> damn, I need to update the FreeBSD port again
08:02:26 <dcoutts> mux: it will be after a bit of final testing
08:02:32 <mux> oh, okay
08:02:40 <dcoutts> I'm testing on a dozen boxes right now, but I don't have access to OSX
08:02:41 <mux> if you need unix testing, don't hesitate to tell me
08:02:48 <mux> I mean FreeBSD
08:02:52 <dcoutts> sure, try it on FreeBSD
08:02:57 <dons> vincenz: you never know, he hasn't commented for an hour: maybe he is blocked... :}
08:02:58 <mux> okay, will do tonight after work
08:03:02 <dcoutts> url comming right up...
08:03:02 <sioraiocht> dcoutts: I'll test it for you
08:03:03 <Nafai> dcoutts: I'm impressed with how clean writing Gtk code is in Haskell
08:03:12 <mux> Nafai: yeah, it's impressive
08:03:24 <mux> Nafai: I'm particularly fond of the Render monad of the cairo bindings
08:03:27 <mux> :-)
08:03:38 <sioraiocht> dcoutts: I'm a lil busy, so you'd have to give me a test app as well as the lib source, but if you can do  that i'll let you know how things go
08:03:39 <dons> sjanssen: re. the hw demo, we need to submit 1 page (i.e. another 5 paragraphs or so) by oh, 2 days time.
08:03:39 <gkr> Where can I learn about kinds and *s?
08:03:48 <dons> so i'll finish a draft tomorrow, and you can read over it
08:03:52 <sioraiocht> gkr: what do you want to know?
08:03:56 <dons> then near october, we can work out the demo
08:03:56 <qwr> fasta: doxygen
08:03:58 <sioraiocht> gkr: there's not a lot to it
08:04:16 <fasta> qwr: try to follow the discussion
08:04:33 <gkr> I don't know, theory, stuff. An indroduction to the subject.
08:04:46 <dcoutts> sioraiocht, mux: http://haskell.org/~duncan/gtk2hs/gtk2hs-0.9.12.tar.gz
08:04:59 <dcoutts> sioraiocht: make installcheck builds all the bundled demos
08:05:04 <vincenz> btw
08:05:11 <vincenz> has unsafeRead dissapeared from MArray?
08:05:14 <quicksilver> mux, Nafai: someone should write up some really pretty demos of stuff like the render monad
08:05:15 * vincenz couldn't find it in the dox
08:05:16 <sioraiocht> kinds are just a way to describe types and how many arguments they take
08:05:21 <quicksilver> and put them on the wiki
08:05:25 <sioraiocht> MyType a has kind * -> *
08:05:35 <sioraiocht> MyType a b has kind * -> * -> *
08:06:20 <sjanssen> vincenz: it's in Data.Array.Base
08:06:24 <vincenz> sjanssen: ah, thank you
08:06:38 <Nafai> Now I just need to figure out how to rewrite the app I had without d-bus :(
08:06:41 <sjanssen> vincenz: which is not mentioned in the docs intentionally
08:06:54 * vincenz nods
08:07:08 <gkr> MyType a b a has kind * -> * -> * -> *?
08:07:22 <vincenz> MyType does
08:07:35 <vincenz> not sure you can have two ty-vars have the same name, however
08:08:44 <SamB> you mean MyType where MyType is defined as (data or newtype) MyType a b c = ... has kind * -> * -> * -> *
08:08:56 <SamB> MyType a b a would have kind *, then ;-)
08:10:22 <gkr> Ahh, oka.
08:11:09 <DukeDave> Guys can someone run the channel stats command?
08:11:12 <DukeDave> I forgot what it is
08:11:19 <mux> @users
08:11:19 <lambdabot> Maximum users seen in #haskell: 367, currently: 351 (95.6%), active: 27 (7.7%)
08:11:21 <roconnor> @losers
08:11:22 <lambdabot> Maximum users seen in #haskell: 367, currently: 351 (95.6%), active: 27 (7.7%)
08:11:24 <mux> this one?
08:11:25 <mux> heh
08:11:27 <DukeDave> Lol
08:11:28 <mux> @quote stereo
08:11:29 <lambdabot> stereo says: Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
08:11:42 <Cale> stereo says?
08:11:49 <vincenz> hehe
08:11:56 <DukeDave> That's the one
08:11:57 <vincenz> bug!
08:12:15 <SamB> @quote OlegFacts
08:12:15 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
08:12:21 <roconnor> Cale: just get dons to add a @stereo command that outputs: ``Welcome to #haskell where your questions are answered in majestic stereo!''
08:12:24 <SamB> hmm. that doesn't look so stupid
08:12:30 <Cale> You know, I'd really appreciate it if my name in that quote was replaced with stars.
08:12:34 <roconnor> Cale: then you can get your name out of the loop
08:12:53 <Cale> yeah, that seems appropriate :)
08:13:21 <roconnor> @. rot13 quote stereo
08:13:21 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "rot13"
08:13:32 <DukeDave> I was writing a lambdabot plug in to auto call the stereo quote, must finish it :)
08:14:12 * DukeDave just noticed that 'lambdabot' seems to be in the gnome dictionary :)
08:15:32 <fasta> /tmp/ccYOCmGy.o: In function `main':
08:15:33 <fasta> glinkedlist.c:(.text+0x2f): undefined reference to `g_list_append'
08:15:57 <fasta> gcc `pkg-config glib-2.0 --cflags` glinkedlist.c -o LinkedList
08:16:02 <fasta> What is wrong this time?
08:17:25 <mux> you want --libs
08:17:38 <mux> since you're doing building & linking at the same time here
08:17:53 <ClaudiusMaximus> fasta: append `pkg-config glib-2.0 --libs`
08:17:59 <mux> so, gcc `pkg-config glib-2.0 --cflags --libs` glinkedlist.c -o LinkedList should work
08:18:06 <mux> ClaudiusMaximus: you can pass several flags to pkg-config
08:18:42 <ClaudiusMaximus> mux: i didn't know that, and i thought order of -L and -l mattered too
08:18:58 <mux> right, but -L and -l are all generated by --libs
08:19:38 <fasta> Ok, it works. That does it. I am switching to C! ;)
08:19:54 <mux> and pkg-config also takes care of puttings cflags first; but anyways, those steps should ideally be odne separately
08:20:04 <fasta> ignoring return value of â€˜g_list_appendâ€™, declared with attribute warn_unused_result
08:20:11 <fasta> That is a pretty cool feature
08:20:18 <mux> gcc has many stuff like this
08:20:19 <fasta> Oh, wait, we have that too
08:20:19 <ClaudiusMaximus> mux: i thought symbols were looked up from left to right, so gcc foo.o -lblah -lbingo would look up unknown symbols from foo in blah, and unknown symbols in foo+blah in bingo
08:20:40 <Nafai> How do I call an external program from Haskell?
08:20:46 <mux> fasta: one of the most useful one is __printfformat or something, that understands the printf format strings and warn accordingly
08:21:17 <fasta> mux: how to convert an int to char *?
08:21:29 <kolmodin> Nafai: http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Cmd.html
08:21:30 <mux> ClaudiusMaximus: that sounds quite likely but I don't understand the connexion with what we're talking about;
08:21:31 <lambdabot> http://tinyurl.com/2k2wt5
08:21:38 <Nafai> kolmodin: Thanks.
08:21:42 <mux> fasta: well, with printf?
08:21:56 <Nafai> Trying to figure out how to get around not having a full d-bus :)
08:22:03 <fasta> mux: ah, ok.
08:22:06 <mux> ClaudiusMaximus: the various -l flags are *all* generated by --libs, so you have no control over it, and it's pkg-config's job to output those in the correct order
08:22:14 <kolmodin> Nafai: which dbus-lib are you using? :)
08:22:17 <mux> fasta: sprintf() actually; or snprintf()
08:22:30 <ClaudiusMaximus> mux: sure, but they're before foo.c in the command line...
08:22:43 <kolmodin> it's on my TODO list to finish the dbus client lib
08:22:44 <mux> ClaudiusMaximus: that's perfectly fine
08:22:45 <ClaudiusMaximus> mux: gcc is probably clever enough; anyway, bbl
08:22:56 <fasta> glib is documented great, though
08:23:24 <Nafai> kolmodin: Well, rather, having *no* Haskell d-bus :)
08:23:28 <mux> the various glib/gtk/cairo/pango/etc libs are well documented, they all have a coherent naming scheme, etc
08:23:46 <Nafai> Though I'm not sure what to do about not having the server, I wonder what to replace it with
08:23:47 <kolmodin> Nafai: right. my lib is hardly production quality just yet..
08:25:39 <Nafai> Basically I'm replacing an app that accepts commands over dbus to alert me when I have new messages on IRC
08:26:23 <kolmodin> ah
08:26:49 <dons> psykotic: still around?
08:27:06 <Nafai> I have some ERC code that opens a process of a quick Python script that sends d-bus commands to the server process
08:27:35 <Nafai> So if I can do something *other* than d-bus just as easily, I don't mind
08:30:18 <roconnor> Developing proofs in Coq is a big pain, but editing proofs is kinda nice.
08:30:41 <roconnor> I just took someone else's proof, and removed a hypothesis, fixed things a bit, and it still goes through.
08:30:47 <roconnor> I don't even know how the proof works.
08:30:56 <roconnor> But I know that the result is correct.
08:31:05 <Nafai> kolmodin: Any suggestions?
08:32:28 <kolmodin> ERC code?
08:33:24 <Nafai> kolmodin: I mean, what should I use for communicating with my gtk app from outside?
08:33:37 <Nafai> Listen on a named pipe or something?
08:33:44 <kolmodin> yeah, or a socket?
08:33:53 <kolmodin> dbus would be best, of course... hmm
08:35:19 <fasta> printf("%d", 1); <- what is invalid about this?
08:35:44 <ski> @hoogle printf
08:35:45 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
08:35:45 <lambdabot> Text.Printf :: module
08:35:45 <lambdabot> Text.Printf.hPrintf :: HPrintfType r => Handle -> String -> r
08:36:09 <ski> @type Text.Printf.printf("%d",1)
08:36:11 <lambdabot>     Couldn't match expected type `String'
08:36:11 <lambdabot>            against inferred type `(a, b)'
08:36:27 <fasta> ski: this should be C
08:36:29 <ski> @type Text.Printf.printf "%d" 1
08:36:30 <lambdabot> forall t t1. (Num t, PrintfType (t -> t1)) => t1
08:36:32 <ski> > Text.Printf.printf "%d" 1
08:36:33 <lambdabot>  Add a type signature
08:36:41 <ski> fasta : .. ooh !
08:37:00 <doserj> fasta: nothing wrong with it as fas a I can see
08:37:07 <ski> > Text.Printf.printf "%d" 1 :: String
08:37:08 <lambdabot>  "1"
08:37:16 <fasta> doserj: I get a segmentation fault when I run it
08:37:18 * ski neither
08:37:26 <Nafai> Well, I should write my system tray portion first since I'm learning Haskell :)
08:38:01 <hpaste>  fasta pasted "C hack" at http://hpaste.org/1886
08:38:18 <fasta> doserj: ^^ is the code
08:39:08 <fasta> Hmm, maybe I already know the problem
08:39:50 <fasta> No, I don't.
08:42:15 <doserj> fasta: you assign to *intp without allocating room
08:42:37 <doserj> there is no automatic memory management in C
08:44:50 <Syzygy-> ski?
08:44:50 <lambdabot> Syzygy-: You have 1 new message. '/msg lambdabot @messages' to read it.
08:45:10 <fasta> doserj: int * intp = (int * )malloc (sizeof int); <- that is wrong too apparently
08:45:24 <Syzygy-> ?msg chessguy Nope - that wasn't me.
08:45:24 <lambdabot> Not enough privileges
08:45:33 <Syzygy-> ?tell chessguy Nope - that wasn't me.
08:45:34 <lambdabot> Consider it noted.
08:45:37 <Syzygy-> There we go.
08:45:44 <Syzygy-> ski: You looked for me?
08:45:46 <fasta> doserj: error: expected expression before â€˜intâ€™
08:45:46 <vincenz> dons: edit your last comment
08:45:54 <vincenz> "conidered" should be "considered"
08:46:14 <fasta> Hmm, it appears intp is not a valid name
08:46:22 <fasta> (in gcc)
08:46:35 <Xgc> fasta: That's not the problem.
08:46:42 <doserj> int * intp = (int * )malloc(sizeof(int)); works for me
08:46:49 <Xgc> fasta: Look at the line prior to this one.
08:46:52 <fasta> Xgc: I changed the name from intp to foop and then it worked
08:47:14 <Xgc> fasta: Then that's a separate issue based on your local identifiers/tokens.
08:47:26 <fasta> Xgc: What's wrong with it then?
08:47:27 <Xgc> fasta: intp is otherwise valid.
08:47:34 <Xgc> fasta: Nothing.
08:47:47 <Xgc> fasta: You didn't provide enough context to determine the specific problem.
08:48:00 <fasta> Xgc: You said  "Look at the line prior to this one."
08:48:10 <fasta> Xgc: GList * empty =  NULL;
08:48:19 <fasta> Xgc: it's that line (as I posted)
08:48:21 <Xgc> fasta: That was a guess since the compiler was whining about int.
08:48:28 <fasta> Xgc: ok
08:48:40 <thorkilnaur> fasta, try sizeof( int ) with ()s
08:49:10 <fasta> thorkilnaur: that works
08:49:52 <thorkilnaur> fasta, yes, sizeof without ()s is only for expressions, not types, so sizeof 7 is ok, sizeof int is not
08:50:16 * Xgc nods.
08:50:35 <fasta> thorkilnaur: ah, ok. Thanks
08:50:48 <Xgc> I don't use the form without ()'s.  There's no need.
08:51:03 <doserj> actually, the compiler said exactly that :)
08:51:16 <ski> Syzygy- : sorry .. chessguy did, not me
08:51:35 <Syzygy-> Ah.
08:51:35 <fasta> doserj: heh, in the same way GHC says some type errors that are impossible for newbies to understand :)
08:51:42 <Syzygy-> Yeah, I got his @tell, and answered it.
08:52:00 * Syzygy- only went back far enough to see anyone mention me...
08:53:09 <ski> <chessguy> @seen syzgy
08:53:37 <ski> <ski> @seen Syzygy-
08:54:41 <Syzygy-> Ah.
08:54:48 <Syzygy-> Only the <ski> got highlighted...
08:56:36 <dcoutts> g'morning SyntaxNinja
08:57:27 <dcoutts> SyntaxNinja: we should probably think about when we want to do a new cabal release, we could wait for ghc-6.8 or do one earlier than that.
09:00:53 <fasta> Whoohoo, I put an element in, retrieved it and printed it :)
09:01:22 <SyntaxNinja> y0
09:01:53 <SyntaxNinja> dcoutts: yeah. any chance nominolo will have configurations ready by 6.8?
09:01:55 <SyntaxNinja> hi CosmicRay
09:02:14 <CosmicRay> morning syntaxninja
09:02:21 <bos> hi SyntaxNinja, thanks for the tour of the pearl district last night
09:02:27 <dcoutts> SyntaxNinja: I'm not sure actually. nominolo? any guesses?
09:02:39 <DukeDave> @hoogle Vector3
09:02:40 <lambdabot> No matches found
09:02:52 <dcoutts> DukeDave: that's in OpenGL iirc
09:03:12 <DukeDave> dcoutts: Correct, why doesn't hoogle see it?
09:03:13 <SyntaxNinja> bos: my pleasure.
09:03:31 <SyntaxNinja> I think I sense Simon PJ in the air...
09:03:32 <dcoutts> DukeDave: it doesn't index all those packages
09:04:01 <SyntaxNinja> actually, it turned out he was on the same train as me this morning, but a different car.  saw him crossing the tracks as I was heading the other way to the coffee shop.
09:04:28 <DukeDave> That's a shame :(
09:05:21 * oerjan wonders if SPJ has some kind of Pauli effect
09:05:33 <diakopter> sorry to be nosy/ignorant - are you guys at Galois?
09:05:54 <diakopter> you folks, I mean.
09:06:08 <qwr> @hoogle [a] -> (a -> Maybe b) -> Maybe b
09:06:09 <lambdabot> No matches, try a more general search
09:06:36 * SyntaxNinja is at Galois. 
09:06:39 <oerjan> :t Just . head
09:06:42 <lambdabot> forall a. [a] -> Maybe a
09:07:08 <oerjan> :t (. head)
09:07:10 <lambdabot> forall c a. (a -> c) -> [a] -> c
09:07:18 <CosmicRay> SyntaxNinja: what is simon talking about at galois today?
09:07:40 <SyntaxNinja> I think he's talking about STM if I remember correctly.
09:07:42 <oerjan> :t flip (. head)
09:07:44 <lambdabot> forall c a. [a] -> (a -> c) -> c
09:07:55 <SyntaxNinja> CosmicRay: you coming out?
09:08:24 <qwr> :t \f find isJust . map f
09:08:26 <lambdabot> parse error on input `.'
09:08:39 <CosmicRay> SyntaxNinja: I suspect probably not; I heard him talk about STM yesterday and it would take out a large chunk of the morning to get there, listen, and get back, unfortunately
09:09:08 * glguy wishes that he'd be talking about "Lightweight concurrency primatives in GHC"
09:09:11 <SyntaxNinja> glguy is also at galois.
09:09:12 <ski> :t \f -> find isJust . map f
09:09:14 <lambdabot> forall a a1. (a1 -> Maybe a) -> [a1] -> Maybe (Maybe a)
09:09:15 <wli> SyntaxNinja: When is it?
09:09:47 <qwr> :t \f -> concat . find isJust . map f
09:09:47 <glguy> 10:30 to noon
09:09:49 <lambdabot>     Couldn't match expected type `[[a]]'
09:09:49 <lambdabot>            against inferred type `Maybe (Maybe a1)'
09:09:50 <SyntaxNinja> glguy says it's 10:30-noon
09:09:50 <SyntaxNinja> bah
09:09:54 <qwr> :t \f -> join . find isJust . map f
09:09:56 <lambdabot> forall a a1. (a1 -> Maybe a) -> [a1] -> Maybe a
09:09:57 <oerjan> @djinn [a] -> (a -> Maybe b) -> Maybe b
09:09:57 <lambdabot> f _ _ = Nothing
09:10:05 <glguy> we are tag teaming the internet... defeated !
09:10:21 <SyntaxNinja> the internet stands no chance against me and glguy
09:10:23 <wli> SyntaxNinja: No way I can make it. I basically did a half-day yesterday for appointments plus transit time to dinner.
09:10:34 <SyntaxNinja> wli: too bad.
09:10:38 <Botje> qwr: perhaps you want catMaybes instead
09:10:41 <Botje> :t catMaybes
09:10:43 <lambdabot> forall a. [Maybe a] -> [a]
09:10:50 <oerjan> qwr: i think that is the same as catToMaybe . catMaybes . map f
09:10:56 <wli> SyntaxNinja: I may not be productive, but I'm at least diligent enough to be present.
09:11:05 <Botje> > catMaybes [ Just 1, Just 2, Just 3, Nothing, Nothing, Just 42, Nothing]
09:11:06 <lambdabot>  [1,2,3,42]
09:11:15 <SyntaxNinja> wli: 99.9% of success is just showing up ;)
09:11:30 <wli> I so wish that were true.
09:11:45 <gkr> Where is Reader monad defined?
09:11:47 <sjanssen> glguy: yeah, that concurrency primitives paper is very interesting
09:11:49 <vincenz> (100 - 10*(100 - SyntaxNinja))
09:11:51 <glguy> Control.Monad.Reader
09:11:54 <sjanssen> I wonder when that stuff will be in GHC?
09:12:29 <gkr> ERROR file:{Hugs}\packages\mtl\Control\Monad\Reader.hs:47 - Haskell 98 does not support dependent parameters
09:12:37 <CosmicRay> 10:30 till noon.
09:12:45 <CosmicRay> urg, 1.5 hours on stm sounds fascinating...
09:12:53 <oerjan> gkr: start hugs with -98
09:13:02 <ski> @type flip (\f -> listToMaybe . (maybeToList . f =<<))  -- qwr
09:13:02 <glguy> gkr: 1) why are you using hugs, 2) enable extensions
09:13:03 <lambdabot> forall a a1. [a1] -> (a1 -> Maybe a) -> Maybe a
09:13:25 <oerjan> (or change it from the options menu, if you are using WinHugs)
09:14:31 <qwr> Botje: hmm. its same as \f -> listToMaybe . catMaybes . map f
09:15:05 <oerjan> qwr: er, that was what i meant to say above.
09:15:10 <vincenz> > listToMaybe []
09:15:12 <vincenz> > listToMaybe [1]
09:15:12 <lambdabot>  Nothing
09:15:13 <lambdabot>  Just 1
09:15:13 <oerjan> (got the first wrong)
09:15:14 <vincenz> > listToMaybe [1,2]
09:15:16 <lambdabot>  Just 1
09:15:19 <vincenz> erm
09:15:33 <vincenz> > concatMap (take 1 . f)
09:15:33 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Maybe a1'
09:15:36 <vincenz> :t concatMap (take 1 . f)
09:15:38 <lambdabot> Not in scope: `f'
09:15:42 <vincenz> :t \f -> concatMap (take 1 . f)
09:15:44 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
09:15:46 <vincenz> o.O
09:15:55 <vincenz> oh, other way around :)
09:16:09 <oerjan> > f
09:16:10 <lambdabot>  Add a type signature
09:16:13 <glguy> ?type mapMaybe
09:16:16 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
09:16:29 <oerjan> someone has @let again
09:16:35 <glguy> ?undefine
09:16:37 <lambdabot> Undefined.
09:17:13 <diakopter> sjanssen: which paper, lz07pldi.pdf or ltmpj07submitted.pdf
09:17:16 <fasta> dcoutts: What are .pp files?
09:18:00 <sjanssen> diakopter: I read http://research.microsoft.com/~simonpj/papers/lw-conc/index.htm
09:18:01 <lambdabot> Title: Lightweight concurrency primitives for GHC
09:18:02 <dcoutts> fasta: to be pre-processed with cpp
09:18:20 <diakopter> oh, is that the same one as http://www.seas.upenn.edu/~lipeng/homepage/papers/ltmpj07submitted.pdf
09:18:22 <lambdabot> http://tinyurl.com/ystukq
09:18:26 <DukeDave> Can anyone suggest why this:
09:18:29 <DukeDave> > getVectors = zipWith3 Vector3
09:18:29 <lambdabot>  Parse error
09:18:35 <fasta> dcoutts: you have some custom build system for that?
09:19:01 <DukeDave> Is dying on "getVectors [1..3] [1..3] [1..3]"
09:19:05 <dcoutts> fasta: autoconf automake with lots of custom GNU make rules
09:19:15 <sjanssen> diakopter: yeah, I think they're the same
09:19:17 <DukeDave> Giving ERROR - Unresolved overloading
09:19:17 <DukeDave> *** Type       : (Enum a, Num a, VertexComponent a) => [Vector3 a]
09:20:41 <sjanssen> DukeDave: looks like the MR
09:20:49 <sjanssen> DukeDave: give it a type signature
09:21:08 <ski> getVectors [1..3] [1..3] [1..3] :: [Vector3 MyNumericType]  -- ?
09:21:10 <sjanssen> or 'getVectors x y z = zipWith3 Vector3 x y z' should work too
09:21:41 <sjanssen> oh, it's complaining at the site of use, not the definition
09:22:52 <oerjan> perhaps the MR causes getVectors to default to something missing Num
09:23:05 <oerjan> and then you get that message at the use site
09:23:32 <oerjan> or missing Enum
09:23:59 <Nopik> re
09:24:07 <DukeDave> @help MR
09:24:07 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:24:34 <oerjan> Dreaded Monomorphism Restriction
09:25:05 <chrismbrown> beelsebob_: ping
09:25:16 <beelsebob_> pong
09:25:28 <chrismbrown> dude, I'll be back in about 30 minutes...
09:25:59 <DukeDave> Wow, I haven't come across this before, but any wiki page starting "The monomorphism restriction is probably the most annoying and controversial feature of Haskell's type system. All seem to agree that it is evil, but whether or not it is considered a necessary evil depends on who you ask."  worries me :)
09:27:22 <DukeDave> Hum, I've added     getVectors :: (VertexComponent a) => [a] -> [a] -> [a] -> [Vector3 a]
09:28:13 <DukeDave> Although interestingly without that type sig it's fine & just delivers [Vector3 Integer]
09:28:48 <oerjan> DukeDave: that's strange, why did you get an error then?  Integer is both Num and Enum.
09:29:02 <fasta> dcoutts: How can I pass the output of pkg-config to c2hs? c2hs -cppopts=`pkg-config glib-2.0 --cflags` GList.chs
09:29:59 <DukeDave> oerjan: There is no error without a type sig
09:30:07 <dcoutts> fasta: we prefix all the output of pkg-config with -C
09:30:34 <dcoutts> fasta: $(addprefix -C,$(CFLAGS))
09:30:43 <villageidiot> is haskell for programmers?
09:30:56 <wolverian> no, it's for woodsmen.
09:31:06 <villageidiot> @yarr
09:31:06 <lambdabot> Yo ho ho, and a bottle of rum!
09:31:18 <vincenz> villageidiot: why do you ask?
09:31:20 <oerjan> DukeDave: what was your original problem then, if there was no error?
09:31:27 <fasta> dcoutts: That says me little, since I am not a autoconf user.
09:31:40 <villageidiot> I saw that irrefutable patterns were for the ignorant on reddit
09:31:43 <fasta> dcoutts:  c2hs -C `pkg-config glib-2.0 --cflags` GList.chs
09:31:47 <villageidiot> and wondered if the rest was for programmers
09:31:50 <fasta> dcoutts: I would expected that to work then.
09:31:58 <fasta> have expected*
09:31:59 <vincenz> villageidiot: irrefutable patterns have their place of use.
09:32:06 <dcoutts> fasta: no, because each C flag needs to be prefixed with -C
09:32:34 <wolverian> what's shell for zip? :)
09:32:40 <dcoutts> fasta: if you use cabal it works, though you need the latest darcs versions of cabal and c2hs for them to cooperate nicely
09:32:53 <DukeDave> oerjan: I'm just having trouble with types, I'll paste up what I've got..
09:33:02 <vincenz> Heh, he was somone from galois.com
09:33:48 <fasta> dcoutts: so, I assume it's not documented how that should work?
09:34:12 <fasta> If I don't have an interface to use something, it's called reverse engineering.
09:34:23 <dcoutts> fasta: which do you mean? how to use the c2hs -C flag, or how to use cabal with c2hs ?
09:34:28 * DukeDave shivers
09:34:34 <fasta> dcoutts: the latter
09:34:45 <DukeDave> Okay ignore me oerjan, I'll get back to you
09:35:12 <dcoutts> fasta: it's not documented very much, all the docs say is that cabal knows about .chs files
09:35:23 <fasta> dcoutts: also c2hs says: -C CPPOPTS   --cppopts=CPPOPTS    pass CPPOPTS to the C preprocessor
09:35:33 <dcoutts> fasta: and that it will use the 'cc-options:' field in the .cabal file
09:35:42 <fasta> dcoutts: it doesn't say that I need to do that for every CPPOPT
09:35:49 <fasta> dcoutts: which is what you are saying
09:36:14 <dcoutts> fasta: well ok, that's not very clear, but it's exactly the same as all the other tools, like ghc, gcc etc
09:36:35 <dcoutts> fasta: ghc has an -optc thing, gcc has similar things for passing flags through to it's sub-tools
09:36:55 <fasta> dcoutts: yes, I know ghc has optc. I just didn't make the connection.
09:37:27 <doserj> fasta: maybe some quoting works, like: -cppopts="`pkg-config glib-2.0 --cflags`"
09:37:28 <DukeDave> This is just cracktastic, so does anyone know the difference between Vertex and Vector in the HOpenGL stuff?
09:37:37 <dcoutts> fasta: cabal doesn't yet know very much about pkg-config, I'd like to teach it more. So you currently have to copy the output of pkg-config into the cc-options and extra-libs fields in the .cabal file.
09:38:06 <fasta> dcoutts: and if I would like to use the same approach as you are using now?
09:38:16 <dcoutts> fasta: I'd like to teach cabal about pkg-config more natively, so you could just list pkg-config names and have cabal pass the right flags to tools etc.
09:38:28 <dcoutts> fasta: don't use autoconf & automake, it's not a good idea.
09:38:41 <dcoutts> gtk2hs will eventually move to using cabal
09:38:44 <fasta> dcoutts: then why are you doing it?
09:38:49 <fasta> dcoutts: ok
09:38:59 <dcoutts> gtk2hs predates cabal by about 5 years
09:39:08 <fasta> dcoutts: you anticipated my question. How smart
09:39:14 <dcoutts> @arr
09:39:15 <lambdabot> Keelhaul the swabs!
09:39:19 <dcoutts> :-)
09:40:56 <SyntaxNinja> have you guys seen this kind of error while building a cabal setup.lhs? /usr/lib/gcc/i486-linux-gnu/4.1.2/libgcc_s.so: could not read symbols: Memory exhausted
09:41:04 <SyntaxNinja> I find it hard to believe that I'm actually out of memory, but it could happen.
09:41:24 <dcoutts> SyntaxNinja: never seen anything like that
09:41:45 <dcoutts> is it reproducible?
09:42:25 <SyntaxNinja> for me, yeah.
09:42:31 <SyntaxNinja> don't know how to make it so for you.
09:42:35 <dcoutts> weird
09:44:17 <fasta> dcoutts: With that change I still get: Cannot find a definition for `GList' in the header file.
09:44:21 <glguy> i486?
09:44:28 <glguy> SyntaxNinja: maybe your computer is too old
09:44:49 <dcoutts> fasta: you're using the right .h file ?
09:45:12 <SyntaxNinja> glguy: it's a virtual machine
09:45:19 <diakopter> are there any hackage packages that could be seen as adding (or building toward) dynamic language features to GHC?
09:45:23 <fasta> dcoutts: I just put #include <glib.h> at the top of the chs file
09:45:23 <dcoutts> fasta: and it didn't complain about not finding files or directories or anything?
09:45:36 <fasta> dcoutts: no, it didn't complain about anything like that
09:45:44 <dcoutts> fasta: you want <glib/glib.h>
09:46:02 <fasta> dcoutts: in C it did work like this
09:46:08 <fasta> dcoutts: why is this different?
09:46:24 <dcoutts> fasta: you must have been using the wrong include path with C
09:46:45 <fasta> dcoutts: ? I used pkg-config output
09:46:53 <fasta> dcoutts: and the code worked
09:47:29 <dcoutts> fasta: it's certainly supposed to be glib/glib.h, the include is usually -I/usr/include/glib-2.0
09:47:40 <fasta> dcoutts: with your include it still doesn't work
09:48:03 <fasta> c2hs -C -I/usr/include/glib-2.0 -C -I/usr/lib/glib-2.0/include GList.chs
09:48:12 <dcoutts> fasta: @paste the output of pkg-config and the invocation of c2hs you're using, I don't have enough info.
09:48:20 <fasta> That command gives: Cannot find a definition for `GList' in the header file.
09:48:38 <dcoutts> that's probably because you have a local glib.h file
09:48:52 <dcoutts> the real glib.h lives in /usr/include/glib-2.0/glib/glib.h
09:49:00 <dcoutts> hence #incldue <glib/glib.h>
09:49:04 <hpaste>  fasta pasted "here" at http://hpaste.org/1887
09:49:06 <dcoutts> you'll see all the C progs do that
09:49:33 <vincenz> in clue
09:49:40 <vincenz> or include due?
09:49:57 <vincenz> dcoutts: i was using gtk2hs for the contest, it was great
09:50:02 <fasta> A "local" glib.h file?
09:50:21 <dcoutts> fasta: that's my guess, find . -name 'glib.h'
09:50:32 <vincenz> dcoutts++
09:50:35 <dcoutts> vincenz: oh yes? what for exactly? and can we get screenshots ? :-)
09:50:47 <vincenz> sure
09:50:58 <vincenz> dcoutts: the DNA->RNA compiler, with prefix generation for page numbers, and then visualization
09:51:03 <fasta> dcoutts: /usr/include/glib-2.0/glib.h <- you mean that one?
09:51:11 <vincenz> dcoutts: that being said, I had to struggle a bit.
09:51:29 <elliottt> is it possible to trap the exception that read generates when it fails?
09:51:46 <doserj> on my machine, glib/glib.h does not exist, but glib.h does
09:51:57 <dcoutts> fasta: hmm, ok I'm wrong. I thought it was glib/glib.h but clearly not. It's that way for most of the other similar things like gtk.
09:52:27 <dcoutts> fasta: ok, can you add your GList.chs to that last paste
09:52:46 <dcoutts> elliottt: use reads instead and pattern match on the result
09:52:55 <elliottt> thanks!
09:53:10 <DukeDave> Is there such a thing as 'casting' in Haskell?
09:53:26 <dcoutts> DukeDave: nope, just using functions that convert
09:53:28 <kpreid> DukeDave: some vague resemblances
09:53:32 <kpreid> e.g. fromIntegral
09:53:39 <mehrheit> ?hoogle unsafeCoerce
09:53:43 <lambdabot> No matches found
09:53:48 <mehrheit> ?hoogle unsafeTypeCoerce
09:53:48 <DukeDave> E.g. all my maths code produces Num a but now I want to use HopenGL to do some graphing
09:53:48 <lambdabot> No matches found
09:54:35 <DukeDave> In hugs this: plotLine [1,2,3] [1,2,3] 0
09:54:45 <DukeDave> Throws ERROR - Unresolved overloading
09:54:46 <DukeDave> *** Type       : (Num a, VertexComponent a) => IO ()
09:54:56 <DukeDave> But this:  plotLine [1,2]::[GLint] [1,2]::[GLint] 0::GLint
09:55:07 <DukeDave> works fine..
09:55:15 <kpreid> DukeDave: you need to add a type signature to pick one
09:55:18 <kpreid> well, you must be using more parens than that...
09:55:31 <kpreid> you can also write [1, 2::GLint]
09:55:43 <DukeDave> kpreid: Yes sorry I copied the wrong line from my hugs session ;)
09:56:10 <dcoutts> fasta: how's it going, did you want to add the content of GList.chs to your last paste?
09:56:12 <kpreid> another way to do it is define f :: GLint -> GLint; f = id; then write "plotLine [f 1, 2] [f 1,2] (f 0)
09:56:36 <kpreid> or write a function that's plotLine with a more restricted type
09:56:40 <DukeDave> I have the signature   plotLine :: VertexComponent a => [a] -> [a] -> a -> IO ()
09:57:04 <DukeDave> kpreid: Thanks, seems a bit of a kludge thought, no?
09:57:08 <kpreid> e.g. plotLineI a b c = plotLine a b (c::GLInt) -- that'll be sufficient to restrict all the parameters
09:57:46 <DukeDave> Ho hum, okay, I'll just have to restrict myself then
09:58:27 <kpreid> myself I used the restricted-version-of-id solution since it only needs one definition and isn't much clutter
09:58:48 <oerjan> DukeDave: when you actually use it from the repl, hugs must pick types, and it uses fairly standard defaulting rules which only handle standard classes (so no VertexComponent)
09:59:50 <DukeDave> I see
09:59:51 <oerjan> i think ghci is more lenient about defaulting, not sure how much
10:00:06 <vincenz> yes
10:00:28 <doserj> ghci wouldn't help
10:00:32 <doserj> here
10:01:21 <doserj> Integer is not an instance of VertexComponent
10:04:25 <dcoutts> mux: ping me if/when you get gtk2hs-0.9.12 built or if you have problems.
10:08:13 <diakopter> are there any hackage packages that could be seen as adding (or building toward) dynamic language features to GHC?
10:09:51 * diakopter goes ahead and starts the eventual exhaustive survey anyway.
10:10:25 <oerjan> DukeDave: the ghci extended defaulting rules seem almost enough, _except_ that ghci has a bug that disregards default declarations interactively so you cannot get GLInt added to the list...
10:12:10 <vincenz> dcoutts: you use *bsd or linu?
10:14:33 <dcoutts> vincenz: linux
10:14:51 <dcoutts> vincenz: gentoo linux on x86, amd64 and sparc
10:15:17 <vincenz> hmm
10:15:21 <vincenz> Who was the *BSDer then?
10:15:30 <dcoutts> vincenz: mux, dons perhaps
10:16:16 <dcoutts> vincenz: mux does FreeBSD, dons does OpenBSD
10:16:29 <vincenz> dcoutts: Ah, thanks for the info.
10:16:40 <vincenz> oh yes, screenshot
10:16:49 <vincenz> sorry, started compiling, forgot all about it
10:16:52 <dcoutts> :-)
10:18:11 * vincenz didn't make it multithreaded due to timepressure, but it could definitely benefit from that
10:18:18 <vincenz> I might when I find some free timie
10:18:37 <|Steve|> You know, I wrote a working version of fmtcheck(3) and submitted it to one of the BSDs. I wonder if it ever got put in.
10:22:34 <vincenz> dcoutts: http://homes.esat.kuleuven.be/~cpoucet/RNAGUI.png
10:23:02 <dcoutts> vincenz: looks funky :-)
10:23:15 <vincenz> the File menu has lots of save/load options
10:23:18 * dcoutts wonders what it does exactly
10:23:26 <dcoutts> vincenz: is the source available anywhere?
10:23:29 <vincenz> hmm
10:23:34 <vincenz> well not yet
10:23:42 <vincenz> we're still deciding on how to publicize our code
10:23:48 <dcoutts> ok, np
10:23:56 <vincenz> but at some point, definitely
10:24:34 <dcoutts> vincenz: well if you want a blurb on the gtk2hs website then send me a couple slightly smaller screenshots and a blurb and I'll stick it up :-)
10:25:10 <vincenz> sure thing
10:26:19 <opqdonut> how do i represent a link in Text.Html?
10:28:05 <oerjan> presumably with anchor
10:29:16 <opqdonut> ah, was looking for "a"
10:29:38 <oerjan> thought so :)
10:35:35 <mux> |Steve|: if you submitted that to FreeBSD, give me the PR number and I'll see about getting it committed
10:47:43 <roconnor> help:
10:47:43 <roconnor> Data/ByteString/Rope.hs:59:0:
10:47:43 <roconnor>     Misplaced SPECIALISE instance pragma:
10:47:43 <roconnor>     {-# SPECIALIZE instance {Eq ByteString} #-}
10:48:20 <hpaste>  roconnor pasted "SPECIALIZE instance not working." at http://hpaste.org/1888
10:49:22 <Saizan> you've to put it right under the instance head, iirc
10:50:11 <Saizan> no, i'm wrong
10:50:15 <roconnor> that is contary to my reading of the documenation, but I'll give it a try.
10:50:55 <roconnor> no go
10:50:57 <roconnor> :(
10:51:16 <monstre> hello
10:52:20 <Saizan> have you tried replacing the type synonim with the actual type?
10:52:53 <monstre> I have a beginner type question regarding indentation in Haskell, is it okay to ask such questions in here?
10:53:02 <shapr> Who wrote Rope?
10:53:05 <shapr> monstre: It is encouraged!
10:53:14 <monstre> thanks
10:53:15 <roconnor> shapr: I'm writing a Rope.
10:53:26 <shapr> roconnor: In the original SGI library style?
10:53:36 <Nafai> shapr!
10:53:51 <shapr> Nafai!
10:53:58 <roconnor> shapr: nope.
10:54:02 <Nafai> How was/is time with your girlfriend?
10:54:05 <monstre> Basically, I'd like to know why I'm not allowed to write this: http://hpaste.org/1889
10:54:18 <roconnor> Saizan: Adding a space before the pragma makes it work.
10:54:27 <roconnor> Saizan: the docs are wrong :(
10:54:47 <SamB> monstre: you don't want to indent your guards at all?
10:54:54 <roconnor> shapr:
10:54:54 <roconnor> newtype RopeWith a = Rope
10:54:54 <roconnor>                    { chunks :: F.FingerTree (Sum Int64) Chunk }
10:55:03 <monstre> SamB: Ideally, no
10:55:08 <roconnor> newtype Chunk = Chunk { unChunk :: B.ByteString}
10:55:20 <SamB> monstre: take it to the haskell prime list?
10:55:23 <shapr> Nafai: She's leaving tomorrow :-(
10:55:42 <SamB> you, too, can influence the next Haskell standard
10:55:58 <SamB> possibly
10:56:03 <SamB> maybe the one after that
10:56:28 <shapr> Nafai: But I've had a good six weeks.
10:56:32 <monstre> Well, does it seem like a reasonable idea to anyone else or is it just me?
10:56:44 <SamB> monstre: it is worth discussing on a mailing list
10:56:48 <monstre> Maybe there's a good reason why it isn't allowed...
10:57:09 <Nafai> shapr: :( on the leaving, but :) on the six weeks
10:57:24 <SamB> monstre: it can't hurt to find out!
10:57:34 <shapr> Nafai: I'll see her again in three months... in the meantime, I'll drown myself in code.
10:57:34 <SamB> maybe there's a mediocre reason why it isn't allowed
10:57:42 <Nafai> shapr: :D
10:58:04 <SamB> monstre: anyway, that kind of question is encouraged
10:58:24 <shapr> Hm, I thought you could do something like that sort of guards?
10:58:25 <SamB> "is there a very good reason why this isn't allowed? what nasty things would happen if it were?
10:58:28 <Nafai> shapr: So now that Gtk StatusIcon is wrapped in the Gtk2hs that is in darcs, I'm going to attempt to convert one of my little Python apps to Haskell
10:58:37 <monstre> I guess I could try the mailing list
10:58:41 <monstre> thanks SamB
10:58:52 <roconnor> @hoogle ErrorT
10:58:53 <lambdabot> Control.Monad.Error.ErrorT :: m (Either e a) -> ErrorT e m a
10:58:53 <lambdabot> Control.Monad.Error.ErrorT :: newtype ErrorT e m a
10:58:53 <lambdabot> Control.Monad.Error.mapErrorT :: (m (Either e a) -> n (Either e' b)) -> ErrorT e m a -> ErrorT e' n b
10:59:24 <SamB> monstre: thank you for questioning the status quo
10:59:44 <roconnor> @docs ErrorT
10:59:44 <lambdabot> ErrorT not available
10:59:52 <roconnor> @docs Control.Monad.Error.ErrorT
10:59:52 <lambdabot> Control.Monad.Error.ErrorT not available
10:59:59 <roconnor> @docs Control.Monad.Error
10:59:59 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Error.html
11:00:38 <roconnor> @instances Error
11:00:39 <lambdabot> IOError, [Char]
11:03:36 <DukeDave> This just makes me mad:
11:03:37 <DukeDave> *** Type           : [(Int32,Int32)] -> GLint -> IO ()
11:03:37 <DukeDave> *** Does not match : [(Int,Int)] -> Int32 -> IO ()
11:04:04 * DukeDave really fancies duck right now :)
11:04:12 <mrd> fromIntegral ;)
11:06:06 <olsner> :t \f -> fromIntegral . f . map (fromIntegral &&& fromIntegral)
11:06:08 <lambdabot> forall b c a b1 b2. (Num b, Integral c, Num b1, Num b2, Integral a) => ([(b1, b2)] -> c) -> [a] -> b
11:06:26 <olsner> or something
11:06:53 <mrd> > ((+1) &&& (*2)) (4,5)
11:06:54 <lambdabot>   add an instance declaration for (Num (t, t1))
11:07:12 <olsner> :t \f -> fromIntegral . f . map (fromIntegral *** fromIntegral)
11:07:13 <lambdabot> forall b c b1 b2 b' b3. (Num b, Integral c, Num b2, Integral b1, Num b3, Integral b') => ([(b2, b3)] -> c) -> [(b1, b')] -> b
11:07:15 <mrd> > ((+1) &&& (*2)) (4)
11:07:16 <lambdabot>  (5,8)
11:07:40 <roconnor> @hoogle m Bool
11:07:41 <lambdabot> Data.Graph.Inductive.Monad.isEmptyM :: GraphM m gr => m (gr a b) -> m Bool
11:07:41 <lambdabot> Prelude.undefined :: a
11:07:41 <lambdabot> Test.QuickCheck.Batch.bottom :: a
11:07:49 <roconnor> @hoogle m Bool -> a
11:07:49 <lambdabot> Prelude.id :: a -> a
11:07:49 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
11:07:49 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
11:08:23 <DukeDave> Lol, you guys :)
11:09:29 <DukeDave> #haskell: The channel for people who don't consider "RTFM you n00b" a real answer :)
11:09:58 <roconnor> http://xkcd.com/293/
11:09:59 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
11:11:25 <roconnor> ``Hello, 911?  I just tried to toast some bread, and the toaster grew and arm and stabbed me in the face!''
11:12:10 <DukeDave> Lmao, I read that one the other day.. So many poster opportunities :)
11:13:50 <roconnor> augustss_: will you be releasing your DNA source code?  I changed my code to run with Seq Word8, and it is still pretty slow.
11:15:15 <roconnor> @hoogle fromRight
11:15:18 <lambdabot> No matches found
11:15:23 <roconnor> ugh
11:19:21 <olsner> :t either (const Nothing) Just
11:19:23 <lambdabot> forall a b. Either a b -> Maybe b
11:19:59 <roconnor> :t either error
11:20:01 <lambdabot> forall c b. (b -> c) -> Either [Char] b -> c
11:20:16 <roconnor> :t either error id
11:20:18 <lambdabot> forall b. Either [Char] b -> b
11:20:54 <olsner> :t \(Right x) -> x
11:20:56 <lambdabot> forall t t1. Either t t1 -> t1
11:21:58 <roconnor> :)
11:22:28 <roconnor> @pl  \(Right x) -> x
11:22:28 <lambdabot> (line 1, column 9):
11:22:28 <lambdabot> unexpected "x"
11:22:28 <lambdabot> expecting operator or ")"
11:26:46 <DukeDave> Does anyone know why when I close a HopenGL window it kills hugs?
11:27:00 <Lemmih> DukeDave: Using GLUT?
11:29:18 <roconnor> @type runErrorT
11:29:26 <lambdabot> forall e (m :: * -> *) a. ErrorT e m a -> m (Either e a)
11:30:23 <roconnor> @type runRWS . runErrorT
11:30:25 <lambdabot> forall r w s e a. ErrorT e (RWS r w s) a -> r -> s -> (Either e a, s, w)
11:32:58 <DukeDave> Lemmih: Yeah
11:33:11 <DukeDave> Following this: http://blog.mikael.johanssons.org/archive/2006/09/opengl-programming-in-haskell-a-tutorial-part-1/
11:33:14 <lambdabot> Title: Michi&#8217;s blog » Blog Archive » OpenGL programming in Haskell - a tutorial ( ..., http://tinyurl.com/ea6tc
11:34:27 <EvilTerran> hm... there's gotta be some functional programming / folding@home joke...
11:35:19 <roconnor> @type runError . runRWST
11:35:21 <lambdabot> Not in scope: `runError'
11:36:08 <roconnor> @type runRWST
11:36:10 <lambdabot> forall r w s (m :: * -> *) a. RWST r w s m a -> r -> s -> m (a, s, w)
11:36:50 <EvilTerran> foldr distribute Nothing :: [Computer] -> Maybe Protein --?
11:39:18 <dufflebunk> This is a dumb question, but is there a modulus function?
11:39:52 <dufflebunk> Ah, found it, mod.
11:39:54 <kaol> > 15 `mod` 4
11:39:55 <Toxaris> > 12 `mod` 3
11:39:55 <lambdabot>  3
11:39:56 <lambdabot>  0
11:39:59 <EvilTerran> @quote stereo
11:40:00 <lambdabot> stereo says: Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
11:40:21 <dufflebunk> Thanks kaol and Toxaris
11:41:14 <EvilTerran> (whups, sorry Ñale. keep forgetting that beeps...)
11:41:25 <roconnor> @src Control.Monad.Error
11:41:25 <lambdabot> Source not found. I've seen penguins that can type better than that.
11:41:40 <roconnor> @src Control.Monad.Error.Error
11:41:40 <lambdabot> Source not found. It can only be attributed to human error.
11:41:55 <mux> hmm, if we had "real" views in Haskell, would it still allow having several view per-type, as with the current view patterns proposal for GHC?
11:41:55 <roconnor> come on, work with me here lambdabot
11:42:38 <roconnor> @src Control.Monad
11:42:39 <lambdabot> Source not found. The more you drive -- the dumber you get.
11:42:39 <monochrom> http://darcs.haskell.org/packages/mtl/Control/Monad/Error.hs
11:43:00 <Saizan> @source Control.Monad.Error
11:43:00 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Error.hs
11:47:38 <mux> @seen dcoutts
11:47:39 <lambdabot> dcoutts is in #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 1h 23m 4s ago.
11:47:48 <dcoutts> hia mux
11:48:07 <mux> hi! gtk2hs 0.9.12 is building, no problems for now
11:48:13 <dcoutts> cool
11:48:17 <mux> any new dependencies and/or new installed files I should be aware of?
11:48:43 <dcoutts> I think it's the same as 0.9.11
11:48:51 <mux> cool, less work :-)
11:48:52 * dcoutts consults his release notes
11:49:39 <roconnor> > splitAt (-1) [1,2,3]
11:49:46 <HairyDude> hmm. foo ++ bar $ baz looks sensible, but really isn't :)
11:49:47 <lambdabot>  ([],[1,2,3])
11:50:03 <dcoutts> mux: only change I think is in the order of preference of gtkmozembed provider, if you enable more than one provider
11:50:17 <olsner> @pl (\x -> Is it can be x tiem plees)
11:50:17 <lambdabot> flip (flip (Is it can be) tiem) plees
11:50:40 <mux> dcoutts: heh, the hs-gtk2hs FreeBSD port is broken wrt this since ages anyways, yet another thing I "should" fix
11:50:49 <dcoutts> mux: ok :-)
11:51:21 <dcoutts> mux: apparently xulrunner is back in vogue, that's the preferred gtkmozembed provider
11:51:43 * mux frowns
11:52:07 <mux> well I guess it's at least better than having N copies of gecko embedded into various browsers and things
11:52:40 <SamB> mux: I think the idea is to have things not break when the browser gets upgraded
11:53:15 <mux> SamB: still, having only one copy of gecko in RAM is appreciated :D
11:53:28 <SamB> well I bet the browser still has its own copy
11:54:05 <mux> dcoutts: hmm, does this ring a bell:
11:54:07 <mux> cairo/Graphics/Rendering/Cairo.hs.pp:240:0:
11:54:07 <mux>     Failed to load interface for `Graphics.Rendering.Cairo.Types':
11:54:07 <mux>       Use -v to see a list of the files searched for.
11:54:13 <Saizan> dcoutts: is there anything in gtk to catch a keypress even when your app is not focused?
11:56:28 <dcoutts> Saizan: hmm, not sure. Take a look at the Gdk api docs.
11:57:15 <dcoutts> mux: that's usually a sign of something failing earlier, take a look earlier in the build log.
11:57:15 <Saizan> dcoutts: k, thanks
11:57:52 <SamB> dcoutts: isn't make supposed to stop then?
11:58:16 <dcoutts> SamB: one might hope so
11:58:27 <mux> dcoutts: right; -> #haskell-overflow
11:58:34 <dcoutts> @arr
11:58:34 <lambdabot> Avast!
11:59:14 <sioraiocht> dcoutts: do you do any work with JunGL?
12:00:49 <dcoutts> sioraiocht: no but other people in my research group do
12:01:07 <sioraiocht> are there any good intro's to it? papers or something/
12:01:35 <sioraiocht> nevermind, found it...
12:01:56 <sioraiocht> it was only right in front me, I dunno how it took me so long
12:11:42 <swiert> @seen Igloo
12:11:42 <lambdabot> Igloo is in #darcs, #ghc and #haskell. I last heard Igloo speak 52m 33s ago.
12:11:56 <Igloo> Hello
12:12:27 <swiert> Hi Igloo, I have a haddock question.
12:12:55 <swiert> I pulled the latest version, and spotted a patch that said it should support infix type constructors.
12:13:08 <swiert> But I still get a parse error...
12:13:29 <swiert> Do you have any idea what the status of this is at the moment?
12:14:13 <Igloo> swiert: I have no idea, and I don't see such a patch in the original haddock repo. Do you mean the haddock-ghc branch?
12:14:46 <swiert> Igloo: I pulled from: http://darcs.haskell.org/haddock/
12:14:48 <lambdabot> Title: Index of /haddock
12:15:26 <Igloo> swiert: Hmm, what patch description?
12:15:35 <swiert> Igloo: darcs changes | grep 'infix'
12:15:45 <swiert> "added infix type constructors"
12:15:55 <swiert> *operators even.
12:16:12 <Igloo> Ah, OK, I thought you meant a more recent patch
12:16:47 <Igloo> No, I have no idea, sorry
12:17:09 <swiert> Ok. Thanks anyhow.
12:18:54 <swiert> Igloo: Do you know the status on the haddock using ghc's parser (is that called haddock-ghc?)
12:20:30 <Igloo> swiert: I don't, and its' something like that. Might be haddock.ghc
12:20:59 <SamB> I tihnk it's either haddock-ghc or ghc-haddock
12:21:15 <SamB> probably the former
12:22:30 <swiert> Ah. It's haddock-ghc.
12:23:02 <dcoutts> in theory it's going to become just haddock 2.x
12:27:31 * HairyDude finds himself using "zipWith zip"
12:27:38 <aulou05> Anybody talking haskell during lunch at oscon?
12:28:30 <oerjan> :t zipWith zip
12:28:32 <lambdabot> forall a b. [[a]] -> [[b]] -> [[(a, b)]]
12:29:38 <mrd> :t zipWith $ zipWith zip
12:29:40 <lambdabot> forall a b. [[[a]]] -> [[[b]]] -> [[[(a, b)]]]
12:29:49 <oerjan> > zipWith (zipWith (+)) [[1,2],[3,4]] [[10,20],[30,40]]
12:29:50 <lambdabot>  [[11,22],[33,44]]
12:30:11 <blsecres> I'm trying to model some SI units > data (Floating a, Integral b) => UnitValue a b = Kilogram a b | Meter a b | Second a b....  and I'd like to derive Num so I could add and multiply units.  Is there a way to write > (+) (t1 v1 e1) (t2 v2 e2) = ... instead of writing out each constructor?
12:30:34 <nominolo> anyone know if Jean Philippe Bernardy (the Yi maintainer) is on this channel?
12:31:28 <dolio> blsecres: Records would work, if you give all fields the same name.
12:31:40 <sjanssen> nominolo: as jyp, occasionally
12:31:55 <oerjan> blsecres: if all are of the form Constructor a b, maybe you could use (Constructor, a, b) instead?
12:32:16 <nominolo> sjanssen: thanks
12:32:46 <dolio> data UnitValue a b = Kilogram { v :: a, e :: b } | Meter { v :: a, e :: b} | ...
12:33:14 <oerjan> or what dolio wrote :)
12:33:24 <dolio> t1 + t2 = ... a t1 ... a t2 ...
12:33:32 <Toxaris> What would be the result of (3kg * 3m)?
12:34:05 <dolio> Or, v t1, not a t1.
12:34:57 <nominolo> there was a blog-post on united values in haskell
12:35:06 <nominolo> it used hlists
12:35:19 <nominolo> and had dimension checking
12:36:22 <blsecres> for things like (+) if the constructors and the exponents are the same, add the values and reconstruct, different constructors is a error...not sure if Num is the best way to model that
12:36:49 <hpaste>  fasta annotated "here" with "GList" at http://hpaste.org/1887#a1
12:37:04 <fasta> dcoutts: I was away. There is the code.
12:38:12 <roconnor> @go 3 kg * 3 m
12:38:13 <lambdabot> (3 kilograms) * 3 meters = 9 m kg
12:40:51 <fasta> @localtime dcoutts
12:40:52 <lambdabot> Local time for dcoutts is Thu Jul 26 20:40:20
12:41:08 <earthy> http://www.xs4all.nl/~arthurvl/ukkepuk/medium/img0025.html *whistle*
12:41:09 <lambdabot> Title: Ukkepuk bij 31 weken en 5 dagen... in 3D
12:41:56 <hpaste>  fasta annotated "here" with "Forgot a line" at http://hpaste.org/1887#a2
12:45:33 <doserj> fasta: I thought it was glib.h, not glib/glib.h?
12:45:53 <fasta> doserj: I tried both
12:46:06 <fasta> doserj: but maybe the universe changed.
12:46:43 <laz0r> hi, #haskell
12:47:14 <laz0r> i nees an int as a float, google said there exists a function fromInt
12:47:25 <mauke> there isn't
12:47:33 <mauke> you probably want fromIntegral
12:48:10 <fasta> @where+ convert Look up fromIntegral
12:48:10 <lambdabot> Done.
12:48:19 <newsham> holy super nifty keen:  fib = fix (memoize fib_)
12:48:33 <newsham> (I guess in haskell that would have to be a monadic fix, but still really nifty keen)
12:49:01 <laz0r> ah, thanks
12:49:09 <laz0r> i figuered it out...
12:49:13 <fasta> doserj: I keep getting: Cannot find a definition for `GList' in the header file.
12:49:39 <doserj> fasta: did you try "c2h --cpp... glib.h GList.chs"?
12:49:41 <laz0r> i had already found fromIntegral, but i wondered how to actually convert to something
12:49:49 <laz0r> hbad to supply the :: Float thing
12:50:02 <doserj> i.e., mention glib.h on the command line?
12:50:07 <fasta> doserj: no
12:50:21 <fasta> doserj: I see that glib.h has an #include <glib/glist.h> in it
12:50:32 <fasta> doserj: so, AFAIK, glist should be defined.
12:50:35 <int-e> newsham: you can memoize as a pure function if you accept that the cache will never be freed.
12:51:15 <int-e> newsham: Data.Array will do the trick, together with lazy evaluation.
12:52:28 <fasta> doserj: on the command line it works
12:52:35 <newsham> inte: but how would memoize be defined in that case? since fix needs same args/returns
12:52:41 <fasta> doserj: how annoying
12:53:58 <int-e> newsham: memoize f = let results = listArray 0 max [f n | n <- [0..max]] in \n -> results ! n
12:54:49 <doserj> fasta: it shouldn't make a difference
12:55:09 <fasta> doserj: heh, tell that to the maintainer.
12:55:42 <int-e> newsham: you can even use a more elaborate scheme that builds an infinite list of ever larger arrays, to avoid the arbitrary maximum bound; you'll get O(log n) lookup time.
12:55:49 <doserj> I don't know what is going wrong
12:57:08 <newsham> > let memoize f = (let results = listArray 0 max [f n | n <- [0..max]] in \n -> results ! n); fact_ f n = (if n == 0 then 1 else n * f (n - 1))) in (fix (memoize fact_)) 5
12:57:09 <lambdabot>  Parse error
12:57:40 <mauke> too many )'s?
12:58:09 <newsham> > let memoize f = (let results = listArray 0 max [f n | n <- [0..max]] in \n -> results ! n); fact_ f n = (if n == 0 then 1 else n * f (n - 1)) in (fix (memoize fact_)) 5
12:58:10 <lambdabot>  Couldn't match expected type `[e]'
12:59:23 <fasta> doserj: does it work for you?
12:59:28 <int-e> missing ]
12:59:44 <int-e> huh
13:00:25 <newsham> also that would give a new memoization for each invocation :\
13:00:26 <int-e> ah, listArray wants its bounds as a pair, duh
13:00:34 <dolio> http://www.haskell.org/pipermail/haskell-cafe/2007-July/029572.html < newsham
13:00:36 <lambdabot> Title: [Haskell-cafe] advantages of using fix to define rcursive functions, http://tinyurl.com/2xywhz
13:00:43 <newsham> (wouldnt it?)
13:01:45 <laz0r> mmh, another question: how can i pattern match against something like 'data Foo = Foo { bar :: String, ... }' ?
13:02:11 <int-e> > let memoize max f = (let results = listArray (0, max) [f n | n <- [0..max]] in (\n -> results ! n)); fact_ f n = (if n == 0 then 1 else n * f (n - 1)) in (fix (memoize 32 . fact_)) 5
13:02:12 <lambdabot>  120
13:02:23 <Saizan> laz0r: Foo{bar=b}
13:02:33 <laz0r> 'function (Foo { "", ... }) = ...' came into my mind, but didnt work
13:02:35 <newsham> ?let  memoize max f = (let results = listArray (0, max) [f n | n <- [0..max]] in (\n -> results ! n))
13:02:36 <roconnor> Ugh, my ropes are slow
13:02:36 <lambdabot> Defined.
13:02:37 <laz0r> Saizan, thanks
13:02:51 <mauke> laz0r: function (Foo "" _ _ _)
13:03:09 <newsham> ?let fib_ f n = if n <= 1 then 1 else f (n-1) + f (n-2)
13:03:11 <lambdabot> Defined.
13:03:26 <newsham> > fix (memoize fib_) 8
13:03:26 <lambdabot>        add an instance declaration for (Num ((a -> a1) -> a -> a1))
13:03:48 <int-e> > fix (memoize 8 . fib_) 8
13:03:49 <lambdabot>  34
13:04:20 <newsham> > fix (memoize 100 . fib) 100
13:04:21 <lambdabot>   Not in scope: `fib'
13:04:24 <newsham> > fix (memoize 100 . fib_) 100
13:04:26 <lambdabot>  573147844013817084101
13:04:30 <newsham> sweet
13:04:43 <dolio> > fix fib_ 100
13:04:47 <laz0r> mauke, thank you too, i think i like that one more
13:04:47 <lambdabot> Terminated
13:05:18 <mauke> @let (<<) x = liftM2 const x
13:05:20 <lambdabot> Defined.
13:05:37 <newsham> now if I did let m = memoize 100; fib = fix (m.fib_) in (fib 1, fib 2, fib 100)     it would share the same memoization?
13:07:03 <int-e> ?let memoize_seq f = let lookup (x:xs) b i | i < b = x ! i | otherwise = lookup xs (2*b) i; memo a b = listArray (a,b-1) [f x | x <- [a..b-1]] : memo b (2*b) in lookup (memo 0 16) 16
13:07:05 <lambdabot> Defined.
13:07:19 <int-e> > fix (memoize_seq . fib_) 10
13:07:20 <lambdabot>  89
13:07:23 <int-e> > fix (memoize_seq . fib_) 100
13:07:24 <lambdabot>  573147844013817084101
13:07:59 <newsham> now do min edit distance using recursion! :)
13:08:23 <Saizan> it's easy
13:08:29 <Saizan> just a nested fold
13:08:39 <newsham> dont need nested fold when you have memoization
13:09:18 <Saizan> well i don't need memoization when i have nested folds :)
13:09:39 <int-e> newsham: why use an O(n*m) memory algorithm if you can get away with O(n+m) and the same running time?
13:09:46 <newsham> yah, but recursive definition is easier to read
13:15:42 <fasta> Anyone who knows how darcs cabal + c2hs work together?
13:16:06 <fasta> I don't know how to convince c2hs to do the right thing
13:19:40 <dcoutts> fasta: you need darcs c2hs too
13:20:31 <fasta> dcoutts: I don't like to be in a state where I need to ask questions to do basic tasks, but thanks for the help.
13:21:03 <roconnor> mainLoop = do
13:21:03 <roconnor>   b <- (step >> return True) `catchError`
13:21:03 <roconnor>        (\Done -> return False)
13:21:03 <roconnor>   when b mainLoop
13:21:09 <roconnor> is there a nicer way to write that?
13:21:14 <dcoutts> fasta: sorry, we really need to do a c2hs release, and Cabal for that matter
13:21:51 <dcoutts> fasta: btw, I get the same problem, ie not finding GList in the header
13:22:12 <mauke> mainLoop = forever step `catchError` return ()
13:22:19 <roconnor> mauke: does that work?
13:22:24 <mauke> why not?
13:22:45 <roconnor> because the error will get propogated through the entire monad, which is forever.
13:22:59 <roconnor> worth a shot
13:23:41 <fasta> dcoutts: The better the tool chains work, the more libraries on Hackage.
13:24:06 <roconnor> @src Control.Monad.forever
13:24:06 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
13:25:01 <mauke> forever m = fix (m >>)
13:25:47 <dcoutts> fasta: for some reason #include doesn't seem to be working for me, I'm looking into it... but in the mean time you can pass glib.h on the command line and that works.
13:26:00 <fasta> dcoutts: yes, I already was passing it on the command line
13:26:13 <dcoutts> fasta: so it's working for you now then?
13:26:17 <fasta> dcoutts: no
13:26:28 <fasta> dcoutts: I am doing the cabal thing also at the same time
13:26:47 <roconnor> @type (\m -> fix (m >>))
13:26:49 <fasta> dcoutts: but I am now installing the latest c2hs
13:26:50 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
13:27:00 <fasta> dcoutts: Could not find module `System.Cmd'
13:27:06 <fasta> dcoutts: c2hs does not build...
13:27:35 <dcoutts> fasta: that's current darcs c2hs right? what ghc version are you using?
13:27:35 <fasta> dcoutts: it is a member of package process-1.0, which is hidden
13:27:46 <dcoutts> fasta: are you using ghc head or something?
13:27:50 <fasta> dcoutts: I am using 6.7.20070712
13:27:57 <dcoutts> could you try 6.6.x ?
13:28:01 <fasta> dcoutts: no
13:28:06 <dcoutts> 6.7 is splitting up all the base packages
13:28:17 <dcoutts> ok, in that case modify the c2hs.cabal file and add process
13:28:22 <fasta> dcoutts: 6.6.1 contains way too many type inference bugs
13:28:26 <dcoutts> and possibly the other packages that base got split into
13:30:35 <roconnor> mauke: I'm pretty sure this isn't working.
13:31:10 <roconnor> > fix (throw "Ack!" >>)
13:31:11 <lambdabot>   Not in scope: `throw'
13:31:27 <roconnor> > fix (Control.Monad.Error.throw "Ack!" >>)
13:31:28 <lambdabot>   Not in scope: `Control.Monad.Error.throw'
13:31:29 <fasta> dcoutts: ok, we are getting somewhere.
13:31:38 <roconnor> @imports
13:31:38 <lambdabot> Unknown command, try @list
13:31:39 <fasta> dcoutts: should I darcs send this path?
13:31:43 <fasta> dcoutts: patch*
13:31:45 <roconnor> @list-imports
13:31:45 <lambdabot> Unknown command, try @list
13:32:00 <dcoutts> fasta: not if it's for base split-up as then it would not build with ghc-6.6.x
13:32:00 <mauke> > fix (Control.Monad.Error.throwError noMsg >>)
13:32:01 <lambdabot>   add an instance declaration for (Show (m b))
13:32:14 <mauke> > fix (Control.Monad.Error.throwError noMsg >>) :: Maybe Int
13:32:15 <lambdabot>   add an instance declaration for (MonadError a Maybe)
13:32:24 <mauke> what
13:32:26 <roconnor> Either String Int
13:32:32 <mauke> > fix (Control.Monad.Error.throwError noMsg >>) :: Either String Int
13:32:34 <lambdabot>  Left ""
13:32:41 <mauke> GREAT SUCCESS
13:32:44 <roconnor> crap!
13:32:51 <roconnor> I mean, yay
13:33:25 <roconnor> > fix (throwError "Ack!" >>) :: Either String Int
13:33:26 <lambdabot>  Left "Ack!"
13:33:49 <roconnor> > runErrorT $ fix (throwError "Ack!" >>) :: Maybe Int
13:33:50 <lambdabot>  Couldn't match expected type `Int'
13:34:06 <monochrom> You are perverse.
13:34:09 <roconnor> @tpe runErrorT
13:34:11 <lambdabot> forall e (m :: * -> *) a. ErrorT e m a -> m (Either e a)
13:34:25 <fasta> dcoutts: Linking dist/build/c2hs/c2hs ...
13:34:26 <fasta> gcc: dist/build/c2hs/c2hs-tmp/c2hs/toplevel/c2hs_config.o:
13:34:35 <fasta> dcoutts: file or directory does not exists
13:34:36 <roconnor> > fix (throwError "Ack!" >>) :: Maybe (Either String Int)
13:34:37 <lambdabot>        add an instance declaration for (MonadError [Char] Maybe)
13:34:52 <roconnor> > runErrorT $ fix (throwError "Ack!" >>) :: Maybe (Either String Int)
13:34:53 <lambdabot>  Just (Left "Ack!")
13:35:02 <dcoutts> fasta: hmm, I'm building it now with darcs version of Cabal...
13:35:34 <fasta> dcoutts: hmm, maybe wrong version of Cabal I am using. (the system version vs mine)
13:35:35 <roconnor> > runRWS $ runErrorT $ fix (throwError "Ack!" >>) () () :: (Either String (),(),())
13:35:35 <lambdabot>  Couldn't match expected type `(Either String (), (), ())'
13:35:53 <roconnor> > runRWS $ runErrorT $ fix (throwError "Ack!" >>) () () :: (Either String (),(),[()])
13:35:54 <lambdabot>  Couldn't match expected type `(Either String (), (), [()])'
13:36:07 <roconnor> @type runRWS $ runErrorT $ fix (throwError "Ack!" >>) () ()
13:36:08 <lambdabot>     No instance for (MonadError [Char] ((->) ()))
13:36:08 <dcoutts> fasta: it's just as likely to be my fault in testing c2hs with the wrong version of cabal :-)
13:36:08 <lambdabot>       arising from use of `throwError' at <interactive>:1:26-42
13:36:24 <roconnor> @type runRWS (runErrorT $ fix (throwError "Ack!" >>)) () ()
13:36:26 <lambdabot> forall b w. (MonadError [Char] (ErrorT [Char] (RWS () w ()))) => (Either [Char] b, (), w)
13:36:44 <Vulpyne> That makes my brain hurt.
13:36:49 <roconnor> > runRWS (runErrorT $ fix (throwError "Ack!" >>)) () () :: (Either String (), (), ())
13:36:51 <lambdabot>  (Left "Ack!",(),())
13:36:52 <fasta> dcoutts: At this rate implementing every C library from scratch is going to be faster.
13:37:02 <fasta> dcoutts: Yes, I like whining :)
13:37:10 <fasta> dcoutts: Give me a pony
13:37:20 <roconnor> mauke: I can't believe this works!
13:37:32 <dcoutts> fasta: I know it's a bit annoying, like I said we really need to do a c2hs & cabal release so we don't have so much versionitis
13:37:32 <fasta> dcoutts: also, cabal-setup doesn't have a --version command
13:37:49 <fasta> dcoutts: how should I know what I am using?
13:37:54 <fasta> dcoutts: I am using the one in local
13:38:01 <fasta> dcoutts: so, I guess that is the newest one
13:38:06 <fasta> dcoutts: I installed 1.17
13:38:11 <dcoutts> right
13:38:11 <roconnor> mauke: so when an error is throw, the entire rest of the computation is tossed away?
13:38:29 <dcoutts> fasta: sorry, dinner, I'll get back to you.
13:38:33 <mauke> roconnor: yes, that's what exceptions do :-)
13:38:44 <mauke> roconnor: the secret is in the definition of (>>)
13:38:53 <mauke> or rather >>=
13:39:08 <mauke> Left e >>= f  = Left e
13:39:22 <mauke> i.e. the (infinite) rest of the computation f is simply ignored
13:39:32 <roconnor> @source (Monad Either e)
13:39:32 <lambdabot> (Monad Either e) not available
13:39:46 <mauke> @src Either (>>=)
13:39:46 <lambdabot> Left  l >>= _ = Left l
13:39:46 <lambdabot> Right r >>= k = k r
13:39:57 <roconnor> perfect!
13:40:13 <roconnor> this is the most wonderful thing ever
13:40:33 <roconnor> @source (Monad ErrorT e m)
13:40:33 <lambdabot> (Monad ErrorT e m) not available
13:40:43 <roconnor> @src (Monad ErrorT e m)
13:40:44 <lambdabot> Source not found. Do you think like you type?
13:40:52 <roconnor> er
13:41:03 <kpreid> @src Monad ErrorT
13:41:04 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:41:05 <roconnor> @src ErrorT (>>=)
13:41:05 <lambdabot> m >>= k  = ErrorT $ do
13:41:05 <lambdabot>     a <- runErrorT m
13:41:05 <lambdabot>     case a of Left  l -> return (Left l)
13:41:05 <lambdabot>               Right r -> runErrorT (k r)
13:41:42 <roconnor> mauke: that is less obviously nice.
13:42:20 <mauke> the important point is that k is not evaluated
13:42:27 <roconnor> ah right
13:43:00 <augustss_> yo
13:43:19 <roconnor> awsome
13:43:29 <roconnor> now my DNA program is:
13:43:34 <roconnor>   let (Right Done,_,r) = runDNA (forever mainLoop) dna
13:43:39 <roconnor> er
13:43:49 <roconnor> that should be Left Done
13:44:14 <roconnor> actually that was totally wrong
13:44:38 <roconnor>   let (Left Done,_,r) = runDNA (forever step) dna
13:44:41 <roconnor> perfect
13:45:00 <Lemmih> r == rna?
13:45:05 <roconnor> yep
13:45:15 <roconnor> _ == dna
13:45:51 <roconnor> and my halt command is just throwError Done
13:46:00 <roconnor> pffft, who need continuations.
13:47:18 <roconnor> main = do
13:47:22 <roconnor>   [fn] <- getArgs
13:47:22 <roconnor>   prefix <- loadDNA fn
13:47:22 <roconnor>   postfix <- loadDNA "endo.dna"
13:47:22 <roconnor>   let dna = prefix `joinDNA` postfix
13:47:22 <roconnor>   let (Left Done,_,rna) = runDNA (forever step) dna
13:47:22 <roconnor>   printRNA rna
13:48:25 <roconnor> I'm starting to think that I need to implement KMP to get a fast DNA machine.
13:49:57 <monochrom> KMP is a minimum requirement :)
13:50:11 <Lemmih> KMP?
13:50:30 <roconnor> monochrom: not really.  I did not so bad without it.
13:50:44 <augustss_> KMP did help
13:50:47 <monochrom> The Knuth-Morris-Pratt algorithm for substring search.
13:51:03 <augustss_> I stole the code from a blog :)
13:51:08 <monochrom> Haha
13:51:10 <roconnor> ah
13:51:15 <roconnor> so that's the way to do it.
13:51:26 <augustss_> of course
13:51:32 <roconnor> sigh, my rope code is still dog slow.
13:51:36 <monochrom> "Blogs are the tools of discriminating hackers"? :)
13:51:42 <Botje> python has cheeseshop, perl has CPAN, haskell has blogs?
13:52:01 <augustss_> google can find it
13:53:45 <sjanssen> Botje: well, we have hackage too
13:54:00 <waern> join #haskell.se
13:54:17 <waern> oops :)
13:54:27 <Botje> sjanssen: i know. i'm still waiting for cabal-install though.
13:54:45 <ivant> @src forever
13:54:46 <lambdabot> Source not found. The more you drive -- the dumber you get.
13:55:17 <roconnor> forever m = fix (m >>)
13:56:02 <ivant> roconnor, :t runDNA?
13:56:04 <ivant> :-)
13:56:50 <roconnor> um, should be DNAMonad a ->  (Either DNAExcpetion a,DNA,RNA)
13:57:57 <ivant> @ty (>>)
13:58:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
13:58:15 <mauke> runDMC
13:58:17 <roconnor> @src (>>)
13:58:17 <lambdabot> m >> k      = m >>= \_ -> k
13:58:19 <monochrom> MaDonad? MacDonald?
13:58:36 <roconnor> @pl (>>)
13:58:36 <lambdabot> (>>)
13:58:46 <monochrom> "Old MaDonad used Haskell, e i e i o!"
13:58:54 <sjanssen> Botje: you can install it now
13:59:02 <sjanssen> Botje: it works pretty well
13:59:26 <Botje> it didn't like my environment for some reason
13:59:31 <byorgey> @pl \e i o -> e i e i o
13:59:32 <lambdabot> join . join flip
13:59:34 <Botje> i'll try again after I get Xen up and running
14:00:08 <monochrom> "Old MaDonad used Haskell, join dot join flip eio!"
14:00:11 <mauke> @pl \m k -> m >>= \_ -> k
14:00:11 <lambdabot> (. const) . (>>=)
14:00:52 <dcoutts> fasta: looks like a Cabal bug to me, I'll try and fix it
14:01:01 <byorgey> "And in Haskell he had a [Cow]..."
14:03:06 <Olathe> With a map moo cows here and a map moo cows there.
14:07:40 <roconnor> > 104982843*2
14:07:45 <lambdabot>  209965686
14:34:39 <dcoutts> fasta: fixed Cabal to build C sources that are part of an executable correctly
14:34:59 <dcoutts> fasta: darcs pull Cabal again and try building c2hs with that latest Cabal version
14:35:03 <fasta> dcoutts: ok
14:35:20 <dcoutts> fasta: actually, hold a sec, darcs push is being slow...
14:35:51 <fasta> dcoutts: heh, No remote changes to pull in!
14:35:54 <dcoutts> fasta: ok, done. pull now.
14:38:25 <dcoutts> fasta: doh! found the c2hs bug. It doesn't lex cpp directives on the very first line of the file correctly.
14:38:37 <dcoutts> so if you put the #include on the second line it works
14:39:03 <fasta> dcoutts: ok, (I do hope you intend to fix it anyway)
14:39:13 <dcoutts> yeah, will at least add it to the TODO
14:40:06 <glguy_> is libcurl Network or Web?
14:42:19 * Lemmih votes for Network.
14:42:34 <monochrom> On Ubuntu (and I guess Debian too) libcurl is under "libs / main"
14:42:54 <glguy> Gentoo is: net-misc/curl
14:43:04 <fasta> dcoutts: everytime I do a cabal command, the su command doesn't work anymore (!)
14:43:15 <monochrom> curl itself is "web / main"
14:43:18 <dcoutts> fasta: huh?
14:43:55 <fasta> dcoutts: i.e. I do su then I press a letter, and then a newline is created and then it says the password is wrong
14:44:11 <dcoutts> reset the terminal
14:44:22 <monochrom> If you are classifying it afresh, I also vote for Network. You know, http is a generic network protocol not confined to the web...
14:44:49 <dcoutts> fasta: so from a fresh terminal, running a cabal command puts the terminal into a state where su behaves that way?
14:44:55 <fasta> dcoutts: yes, that works (I already knew that), but it shouldn't happen in the first way.
14:44:56 <glguy> I'm classifying it so when I dump to hackage it is in the correct category
14:44:59 <fasta> place*
14:45:04 <fasta> dcoutts: yes
14:45:12 <fasta> dcoutts: I will reproduce it.
14:45:18 <dcoutts> fasta: you can make that happen reliably from a fresh terminal?
14:45:28 <fasta> dcoutts: I already did two times.
14:45:35 <fasta> dcoutts: I will now record the exact steps
14:45:39 <dcoutts> that's really really weird
14:45:47 <fasta> dcoutts: I know
14:46:01 <monochrom> I configure my router through http. It is definitely not Webby. :)
14:46:11 <dcoutts> fasta: if you can reproduce it reliably, try it again but redirect 2> /dev/null > /dev/null
14:46:34 <dcoutts> fasta: just in case it's some output from cabal that's getting interpreted as a terminal command
14:47:04 <dcoutts> fasta: or I suppose it could be some change in the terminal buffering or something
14:47:18 <fasta> dcoutts: same problem
14:47:22 <fasta> dcoutts: this is what I do:
14:47:45 <fasta> dcoutts: well, this is the problem: copyFile: permission denied (Permission denied)
14:47:53 <fasta> dcoutts: I think something goes wrong because of that
14:47:58 <fasta> dcoutts: ok, the commands.
14:48:27 <fasta> dcoutts: I first run bh, which is:
14:48:28 <fasta> runghc Setup.*s configure --enable-library-profiling --with-compiler=$HOME/bin/ghc --with-hc-pkg=$HOME/bin/ghc-pkg --user --prefix=$HOME
14:48:32 <fasta> runghc Setup.*s build
14:48:37 <fasta> dcoutts: then everything is still ok
14:48:46 <Pupeno> I want a function that having a monad of Int and a monad of [Int] will put the first int in front of the list and return a list. Which function am I looking for?
14:48:59 <fasta> dcoutts: and then runghc  Setup.*s install
14:49:02 <Pupeno> This is to mix some QuickCheck generators.
14:49:20 <mauke> Pupeno: liftM2 (:)
14:49:24 <fasta> dcoutts: then doing su gets me in the state as described
14:50:48 <fasta> dcoutts: with the new tools, I still get: cabal-setup: got error code while preprocessing: GList
14:51:08 <fasta> dcoutts: Cannot find a definition for `GList' in the header file.
14:53:16 <int-e> hmm. do you have the glib header files? (here, /usr/include/glib-2.0/*)?
14:53:33 <dcoutts> fasta: about the second issue, you're putting "includes: glib.h" in your .cabal file right?
14:53:45 <fasta> dcoutts: AFAIK, yes.
14:54:16 <fasta> dcoutts: yes
14:54:24 <dcoutts> and the right dirs for the include-dirs:
14:54:39 <fasta> dcoutts: I have "Includes", instead of "includes", though.
14:54:45 <dcoutts> doesn't matter
14:54:53 <dcoutts> fasta: use build -v to see how c2hs is getting called
14:55:05 <dcoutts> check if it looks sensible
14:55:11 <Pupeno> mauke: thanks.
14:55:29 <fasta> c2hs -C -D__GLASGOW_HASKELL__=607 -C -I/usr/include/glib-2.0 -C -I/usr/lib/glib-2.0/include -o GList.hs GList.chs
14:55:36 <fasta> dcoutts: it gets called incorrectly
14:55:52 <dcoutts> fasta: you're sure you're using the darcs version of Cabal ?
14:56:10 <dcoutts> fasta: ghc -package Cabal-1.1.7 --make Setup.hs -o setup
14:58:05 <fasta> dcoutts: that does work
14:58:13 <dcoutts> yay
14:58:18 <dcoutts> ok, for the su problem...
14:58:39 <fasta> dcoutts: so, how do I know what is the wrong cabal-setup binary?
14:59:04 <dcoutts> fasta: I'm not awfully familiar with cabal-setup, I don't use it
14:59:34 <fasta> dcoutts: you always use the command as above?
14:59:57 <dcoutts> fasta: I usually use runghc Setup.hs
15:00:17 <dcoutts> runghc always picks the latest Cabal package that's installed
15:00:30 <roconnor> @src WriterT poass
15:00:30 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
15:00:31 <kalven> I have an [Int] that I want to sum, the result however is too big for an Int so I guess I want to convert the list to [Integer] or something? How do I go about that?
15:00:34 <roconnor> @src WriterT pass
15:00:34 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
15:00:52 <roconnor> @src ErrorT (>>=)
15:00:52 <lambdabot> m >>= k  = ErrorT $ do
15:00:52 <lambdabot>     a <- runErrorT m
15:00:52 <lambdabot>     case a of Left  l -> return (Left l)
15:00:52 <lambdabot>               Right r -> runErrorT (k r)
15:01:00 <roconnor> @src Control.Monad.Writer.WriterT pass
15:01:00 <lambdabot> Source not found. It can only be attributed to human error.
15:01:16 <roconnor> @src Control.Monad.Writer.WriterT Control.Monad.Writer.pass
15:01:16 <lambdabot> Source not found. stty: unknown mode: doofus
15:01:20 <roconnor> @src Control.Monad.Writer.WriterT Control.Monad.Writer.Class.pass
15:01:20 <lambdabot> Source not found. I feel much better now.
15:01:47 <int-e> kalven: sum (map fromIntegral list)
15:01:49 * fasta deleted cabal-setup
15:02:07 <kalven> int-e: cool, thanks.
15:02:50 <dcoutts> fasta: for that su thing, try runghc  Setup.*s install --user
15:03:18 <dcoutts> fasta: that should avoid the permission error, see if the su weirdness really is related to the permission problem
15:03:38 <etnt> hm...how do I compile my Haskell code with ghc?
15:03:53 <etnt> seem to be a gazillion switches...
15:04:04 <dcoutts> etnt: generally just ghc --make Foo.hs
15:04:05 <fasta> dcoutts: /share/c2hs-0.14.6/C2HS.hs: copyFile: permission denied (Permission denied)
15:04:37 <fasta> dcoutts: but that might be my mistake, hold on
15:04:39 <dcoutts> fasta: assuming you configured with --prefix=$HOME so you want to install with --user so registers with the user package db
15:04:47 <etnt> dcoutts: nice, that was simple :-)
15:05:03 <olsner> @hoogle Ord a => [a] -> a
15:05:04 <lambdabot> Prelude.maximum :: Ord a => [a] -> a
15:05:04 <lambdabot> Prelude.minimum :: Ord a => [a] -> a
15:05:04 <lambdabot> Prelude.head :: [a] -> a
15:05:12 <dcoutts> etnt: for anything more complex or if you want to distribute code then use the Cabal build system
15:05:15 <ihope> Do byte strings come with GHC?
15:05:25 <oerjan> ihope: certainly
15:05:47 <dcoutts> ihope: currently yes, in future they'll be a separate package but will usually sill come with ghc
15:05:48 <etnt> dcoutts: ok, will look into it
15:06:04 <ihope> ...I guess I could have found that out myself easily enough. :-)
15:07:02 <fasta> dcoutts: without that permission problem, the error does not occur
15:08:35 <dcoutts> fasta: that really is very odd, but I've said that already :-)
15:08:39 <dcoutts> fasta: ok next experiment...
15:09:11 <ihope> Does Data.ByteString work nicely for "zipping" along multiple files to produce multiple other files, then?
15:09:36 <ihope> Or should I use Data.ByteString.Lazy or something?
15:11:27 <dcoutts> fasta: starting with a clean terminal again, ghc-pkg --global update dist/installed-pkg-config
15:11:48 <dcoutts> fasta: that should make ghc-pkg cause a permission error as it tries to write to the global package db
15:12:10 <dcoutts> fasta: is that still causes it, well at least we've eliminated cabal from the question
15:12:22 <dcoutts> is/if
15:12:30 <thorat> ihope: check out http://haskell.org/haskellwiki/Wc
15:12:31 <lambdabot> Title: Wc - HaskellWiki
15:12:42 <fasta> dcoutts: that does not cause it
15:12:55 <fasta> dcoutts: it did cause  openFile: does not exist (No such file or directory)
15:13:12 <roconnor> > sequence $ cycle (throwError "ack!") :: Either String [()]
15:13:16 <dcoutts> ihope: if they're large files and you're processing them from to back then .Lazy is probably better since it will not cause the whole thing to be brought into memory at once
15:13:16 <fasta> dcoutts: never mind, I will retry again
15:13:16 <lambdabot>        add an instance declaration for (MonadError [Char] [])
15:13:22 <fasta> dcoutts: I assumed you had a complete command
15:13:39 <roconnor> @type  sequence $ cycle (throwError "ack!")
15:13:40 <dcoutts> fasta: oh, I thought I did have a complete command there
15:13:41 <lambdabot>     No instance for (MonadError [Char] [])
15:13:41 <lambdabot>       arising from use of `throwError' at <interactive>:1:18-34
15:13:41 <fasta> dcoutts: or was that the intention that it generated that error message?
15:13:56 <roconnor> > sequence $ repeat $ throwError "ack!" :: Either String [()]
15:13:57 <lambdabot>  Left "ack!"
15:14:01 <ihope> dcoutts: yup. Few large files, one byte at a time.
15:14:01 <dcoutts> fasta: I think we were looking for the permission denied error that you found previously
15:14:22 <fasta> dcoutts: right, me too, so since the file didn't exist, it was an unsuccessful command.
15:14:23 <dcoutts> ihope: strict bytestrings require the whole file to be in memory at once
15:14:28 * ihope nods
15:14:32 <dcoutts> fasta: oh, hmm
15:14:58 <dcoutts> fasta: if you were using the darcs version of cabal then it creates dist/installed-pkg-config
15:15:14 <dcoutts> fasta: if you're using an older version it creates .installed-pkg-config iirc
15:15:18 <roconnor> > sequence $ return () : (repeat $ throwError "ack!") :: Either String [()]
15:15:19 <lambdabot>  Left "ack!"
15:15:33 <fasta> dcoutts: I executed the command in the wrong dir.
15:15:39 <dcoutts> ah ok :-)
15:16:22 <fasta> dcoutts: in ~/src/c2hs, I get the same result
15:16:54 <dcoutts> fasta: do either file exist? dist/installed-pkg-config .installed-pkg-config
15:17:09 <fasta> dcoutts: no
15:17:25 <fasta> dcoutts: just these: build  setup-config
15:17:40 <dcoutts> fasta: ok, run register --user --inplace
15:17:49 <dcoutts> that should create dist/installed-pkg-config
15:17:58 <fasta> dcoutts: what's the inplace?
15:18:04 <dcoutts> or perhaps that creates dist/inplace-pkg-config
15:18:11 <dcoutts> fasta: it registers it inplace
15:18:20 <dcoutts> ie in the build tree
15:18:37 <dcoutts> rather than installing it and registering it in it's installed location
15:19:12 <fasta> dcoutts: the install command does register too, right?
15:19:16 <dcoutts> yes
15:19:46 <fasta> dcoutts: Package contains no library to register: c2hs-0.14.6...
15:20:17 <fasta> dcoutts: I didn't get any new files
15:20:20 <dcoutts> fasta: oh, hmm, of course, nothing to register
15:20:31 <fasta> dcoutts: unregister...
15:20:43 <dcoutts> fasta: ok, so I don't understand why the install failed with a permission error
15:20:51 <dcoutts> given that you set the prefix to be $HOME
15:21:01 <fasta> dcoutts: I do understand part of it.
15:21:09 <fasta> dcoutts: the permission error isn't the problem
15:21:17 <fasta> dcoutts: the problem is that the shell gets f*cked up
15:21:20 <dcoutts> there was nothing to register and you have perms to your home dir
15:21:38 <dcoutts> fasta: right but you thought it might be related to the permission problem
15:21:47 <dcoutts> but now I don't understand the permission problem
15:21:48 <fasta> dcoutts: and probably it is.
15:22:04 <dcoutts> I don't understand why it happens, do you?
15:22:11 <fasta> dcoutts: the permission problem gets generated if you install something as root in my home dir
15:22:23 <fasta> dcoutts: and then try to install something over it as user
15:22:28 <dcoutts> ah ok
15:22:47 <fasta> dcoutts: not every sequence of actions goes over a sane state :)
15:23:04 <dcoutts> so does the same su-weirdness problem happen when the permission problem does not happen?
15:23:14 <fasta> dcoutts: no
15:23:20 <fasta> dcoutts: I said that before
15:23:27 <dcoutts> ok
15:24:33 <dcoutts> fasta: and you already said that redirecting output made no difference didn't you? (redirecting stdout and stderr)
15:24:48 <fasta> dcoutts: yes
15:25:19 <dcoutts> fasta: I suppose the next thing to do would be to make a small test prog that tries to overwrite one of these root-owned files to generate the permission problem
15:25:47 <dcoutts> fasta: when you run install with -v what is the last message before the permission error is reported?
15:26:09 <dcoutts> it's presumably one of the file copies
15:27:55 <fasta> Setup.hs: /home/fasta/bin/c2hs: copyFile: permission denied (Permission denied)
15:27:59 <fasta> dcoutts: ^^
15:28:02 <dcoutts> aye
15:28:52 <fasta> dcoutts: doing su in this state puts the shell in an invalid state.
15:30:41 <fasta> dcoutts: I made a test program
15:30:47 <fasta> dcoutts: it's trivial
15:30:56 <dcoutts> fasta: using what function?
15:30:59 <fasta> dcoutts: main = writeFile "/usr/bin/kpdf" ""
15:31:15 <dcoutts> fasta: ok, and does that elicit the problem?
15:31:18 <fasta> dcoutts: yes
15:31:37 <fasta> dcoutts: I meant no
15:31:42 <fasta> dcoutts: didn't reset terminal...
15:31:47 <fasta> dcoutts: sorry
15:32:02 <dcoutts> ok, let me make a slighlty more accurate test prog...
15:32:41 <fasta> dcoutts: partial evaluation would come in handy now
15:34:18 <roconnor>   let (_,_,rna) = runDNA (forever step) dna; printRNA rna
15:34:18 <roconnor> works about a million times better than
15:34:18 <roconnor>   let (Left Done,_,rna) = runDNA (forever step) dna; printRNA rna
15:35:02 <roconnor> that pattern match for Left Done is a killer
15:35:38 <mnislaih_> edw
15:35:41 <mnislaih_> oops
15:37:08 <dcoutts> fasta: create 'foo' in your home dir and try:
15:37:09 <dcoutts> ghc -e 'Distribution.Simple.Utils.copyFileVerbose Distribution.Verbosity.verbose "/home/fasta/foo" "/home/fasta/bin/c2hs"'
15:38:39 <fasta> dcoutts: command works, but problem does not get generated.
15:39:26 <dcoutts> fasta: you mean the command gives the permission denied exception as we expected?
15:39:37 <fasta> dcoutts: yes
15:40:37 <dcoutts> fasta: sigh, I'm mostly out of good ideas, one could just try narrowing down the cabal code to a minimum that still produces the problem
15:40:43 <dcoutts> but that'll take a while
15:41:37 <fasta> dcoutts: can you reproduce the problem I have on your machine?
15:44:40 <dcoutts> fasta: no, just tried. I can't.
15:45:05 <dcoutts> fasta: I installed c2hs as root and then as myself, so second time I was trying to overwrite $HOME/bin/c2hs
15:45:17 <dcoutts> got the permission error, but su works ok
15:45:17 <fasta> dcoutts: what terminal?
15:45:24 <dcoutts> gnome-terminal
15:45:32 <fasta> dcoutts: Hmm, I use gnome-terminal too
15:45:36 <dcoutts> but I have have that su wierdness problem before
15:45:37 <fasta> dcoutts: what ghc?
15:45:43 <dcoutts> can't remember what caused it though
15:45:46 <dcoutts> ghc 6.6.1
15:46:36 <fasta> dcoutts: is there anything else I need to know to be able to write the GList binding?
15:47:15 <fasta> dcoutts: someone talked about having Haskell GC control the objects or not etc
15:47:23 <dcoutts> fasta: you've looked at the gtk2hs code
15:47:40 <dcoutts> fasta: what are they glists of ?
15:48:06 <dcoutts> fasta: I wouldn't bother doing complex schemes for the glist elements, just create/destroy them when marshaling
15:48:11 <fasta> dcoutts: they will containg edges
15:48:22 <fasta> contain*
15:48:24 <dcoutts> we use finalisers for GObjects but they are passed around by reference
15:48:37 <dcoutts> and live a long time, so quite different
15:49:01 <fasta> dcoutts: I just want that they live as long as normal lists would
15:49:10 <fasta> dcoutts: (and not longer)
15:50:22 <dcoutts> fasta: you'll presumably just be converting to/from Haskell lists
15:50:41 <dcoutts> so if you owned the GList then you should destroy it after you marshal
15:51:14 <fasta> dcoutts: I don't think I will convert to Haskell lists a lot.
15:51:27 <fasta> dcoutts: from Haskell lists, yes, but not the other way around
15:51:44 <dcoutts> ah, so you will be holding onto largish GLists and passing them around ?
15:52:04 <fasta> dcoutts: it will be a standard adjacency list graph.
15:52:30 <fasta> dcoutts: and I am passing around one such graph in my graph state monad, yes.
15:52:56 <dcoutts> fasta: if you know the lifetime precisely then you can free it exactly, otherwise a finaliser might be handy
15:53:27 <fasta> dcoutts: for most of the stuff I know it exactly.
15:53:47 <fasta> dcoutts: the concept of a finalizer is "some code that gets run < at which time>"?
15:54:14 <dcoutts> fasta: it gets run some time after the GC notices that the thing is not reachable
15:54:26 <glguy> ?where curl
15:54:26 <lambdabot> I know nothing about curl.
15:54:35 <glguy> ?where+ curl http://code.haskell.org/curl/
15:54:35 <lambdabot> Done.
15:54:43 <dcoutts> if you occasionally don't know, you can use a finaliser and normally explicitly invoke the finaliser and let the GC invoke it if you don't.
15:55:11 <fasta> dcoutts: I am assuming that I will be able to use this GList to put arbitrary stuff in.
15:55:28 <fasta> dcoutts: that is, I would like to be able to put function types in it too, etc.
15:55:47 <dcoutts> fasta: you can use StablePtrs
15:55:59 <dcoutts> fasta: on the glib side it's typeless, just a void *
15:56:19 <fasta> dcoutts: what problem do StablePtrs solve?
15:56:41 <dcoutts> fasta: putting arbitrary Haskell values into foreign data structures
15:56:48 <dcoutts> and then getting them back again later
15:56:54 <fasta> dcoutts: and normal Ptr's don't have that property?
15:57:12 <fasta> dcoutts: can c2hs make such pointers too?
15:57:39 <dcoutts> normal Ptrs are for things that really are pointers
15:57:51 <dcoutts> a StablePtr can be constructed from an arbitrary Haskell value
15:58:04 <dcoutts> you said you wanted to store Haskell functions in the GList ?
15:58:12 <fasta> Yes, as an example
15:58:14 <SamB> ForeignPtrs are just foreign values that refer opaquely to Haskell values
15:58:19 <SamB> er.
15:58:20 <SamB> Stable.
15:58:22 * SamB silly
15:58:35 <SamB> There's too many damn kinds of Ptrs
15:58:37 <dcoutts> fasta: or do you mean you want to store C function pointers of expored Haskell functions?
15:58:46 <dcoutts> expored/exported
15:59:05 <fasta> dcoutts: I only want to do stuff from the Haskell side.
15:59:15 <fasta> dcoutts: i.e. putting stuff in and out.
15:59:48 <dcoutts> then you probably want StablePtrs for things like Haskell functions
16:00:09 <fasta> But... why is that separation there in the first place?
16:00:35 <fasta> Can't GHC decide for itself how things are used and based on that figure out what kind of Ptr to use?
16:00:43 <fasta> Is that an incomputable function?
16:01:01 <fasta> Or was someone just being lazy?
16:01:51 <dcoutts> fasta: they're totally different things
16:02:00 <SamB> yeah.
16:02:07 <SamB> StablePtr is probably a bad name
16:02:17 <SimonRC> hmm
16:02:22 <SamB> StableRefThatLooksLikeAPtr would be better
16:02:59 <SimonRC> co-routines can be implemented on top of continuations but not vice-versa, right?
16:03:07 <SimonRC> CBA to join #scheme
16:18:51 <vyqpc8p6V> hey
16:19:03 <vyqpc8p6V> if I want to write a  GUI application, do I use FS ?
16:19:34 <Lemmih> vyqpc8p6V: What's FS?
16:19:50 <vyqpc8p6V> Fruit something
16:20:22 <dolio> gtkhs seems to be the go-to answer.
16:20:36 <oerjan> gtk2hs
16:21:23 <dolio> I don't think Fruit and such got terribly far out of the research paper area.
16:21:43 <vyqpc8p6V> http://kevin.atkinson.dhs.org/fg/doc/FG.html  i meant this
16:21:50 <vyqpc8p6V> it's on top of gtk2hs
16:21:57 <vyqpc8p6V> well i think i need to try out
16:22:20 <vyqpc8p6V> basically, i want to code once and compile for Windows Linux Mac
16:22:24 <vyqpc8p6V> with no change
16:23:10 <vyqpc8p6V> oh crap i need to go. later
16:25:00 <desp> what version of fps is included with ghc?
16:27:46 <dcoutts> desp: roughly 0.8
16:28:19 <desp> ah
16:39:26 <shapr> shazam!
16:41:18 <chessguy> howdy
16:41:18 <lambdabot> chessguy: You have 1 new message. '/msg lambdabot @messages' to read it.
16:41:59 <ddarius> howdy howdy howdy
16:43:54 <ariks> howdy howdy howdy howdy howdy
16:44:16 <jsnx> howdy
16:46:38 <elliottt> repeat "howdy"
16:47:01 <ddarius> repeat "howdy "
16:47:22 <elliottt> doh!
16:47:22 <glguy> > unwords $ repeat "howdy"
16:47:24 <lambdabot>  "howdy howdy howdy howdy howdy howdy howdy howdy howdy howdy howdy howdy how...
16:47:46 <EvilTerran> > tail . concat . join (iterate . const) " howdy"
16:47:46 <kolmodin> ?localtime
16:47:46 <lambdabot>  Couldn't match expected type `a -> [[a1]]'
16:47:47 <oerjan> > fix ("howdy "++)
16:47:47 <jsnx> has anybody used wxHaskell? i'm told (gtk2hs site) that it has memory leaks
16:47:48 <lambdabot>  "howdy howdy howdy howdy howdy howdy howdy howdy howdy howdy howdy howdy how...
16:47:50 <lambdabot> Local time for kolmodin is Fri Jul 27 01:39:02 2007
16:47:50 <EvilTerran> bah
16:47:51 <kolmodin> good night!
16:48:01 <ddarius> Oops, I was wrong too, cycle "howdy "
16:48:03 <EvilTerran> > tail . concat . join (iterate . const) $ " howdy"
16:48:04 <lambdabot>  "howdy howdy howdy howdy howdy howdy howdy howdy howdy howdy howdy howdy how...
16:48:16 <chessguy> wow
16:48:21 <elliottt> that's awesome
16:48:22 <chessguy> you guys need lives :)
16:48:24 <EvilTerran> jsnx, i think, as a project, it's a bit dead, so the memory leaks might be moot
16:48:25 <elliottt> haha
16:48:32 * jsnx bows to EvilTerran 
16:48:44 <jsnx> EvilTerran: okay, good to know
16:49:01 <EvilTerran> ty, ty. i could've just done concat . join (iterate . const) $ "howdy ", but i figured the extra space at the end would be wrong. ;]
16:49:09 <chessguy> > (iterate . const) $ " howdy
16:49:10 <lambdabot>  Improperly terminated string
16:49:13 <chessguy> > (iterate . const) $ " howdy"
16:49:14 <lambdabot>  <[Char] -> [[Char]]>
16:49:31 <jsnx> i would like to build GUI apps for windows users and linux users
16:49:34 <chessguy> > join (iterate . const) $ " howdy"
16:49:35 <lambdabot>  [" howdy"," howdy"," howdy"," howdy"," howdy"," howdy"," howdy"," howdy"," h...
16:49:44 <chessguy> nice
16:49:53 <jsnx> is gtk2hs my only hope?
16:49:58 <EvilTerran> join (iterate . const) x = (iterate . const) x x = iterate (const x) x
16:50:07 <mux> jsnx: gtk2hs rocks! ;-)
16:50:09 <elliottt> jsnx: i've only ever gotten gtk2hs to work
16:50:15 <elliottt> plus, gtk2hs is awesome :)
16:50:32 <dcoutts> jsnx: and hopefully you'll be just in time for a new release tomorrow :-)
16:50:32 <jsnx> so, i have to install gtk on all the windows users' machines?
16:50:35 <chessguy> @pl f x = interate (const x) x
16:50:35 <lambdabot> f = interate =<< const
16:50:39 * EvilTerran is currently working on a Tk binding. i'll make a note to give you a shout if i get anywhere with that.
16:50:48 <glguy> prod
16:50:49 <glguy> ?users
16:50:49 <lambdabot> Maximum users seen in #haskell: 367, currently: 334 (91.0%), active: 20 (6.0%)
16:50:53 <dcoutts> jsnx: there's an integrated gtk2hs installer that includes gtk
16:51:08 <chessguy> who was it that ported monads to a bunch of other languages?
16:51:30 <jsnx> dcoutts: well, yeah, it's just i was hoping that i wouldn't have to install anything at all...
16:51:31 <elliottt> not that i know of
16:51:32 <dcoutts> jsnx: and if you want to make distributable binaries of gtk2hs progs, that's quite possible, I have a demo of that.
16:51:42 <elliottt> i was lucky on windows, because i already had pidgin installed :)
16:51:46 <jsnx> dcoutts: really? cool
16:51:53 <jsnx> where?
16:52:01 <dcoutts> jsnx: http://haskell.org/~duncan/gtk2hs/LSystemSetup.exe
16:52:22 <EvilTerran> (Tcl is a monstrosity of lovecraftian proportions, but Tk is so much simpler than most widget systems, it makes up for the flaws, IMO)#
16:52:22 <dcoutts> jsnx: 3.5M installer, it includes all the Gtk+ runtime dlls
16:52:51 <EvilTerran> Tk might not be suitable for big projects, but i rarely do big projects, so that's okay ;]
16:52:59 <elliottt> dcoutts: does it take into account an existing gtk install?
16:53:07 <jsnx> dcoutts: how so i do it?
16:53:16 <jsnx> s/so/do/
16:53:25 <dcoutts> elliottt: no
16:53:47 <dcoutts> jsnx: you mean make an installer for a prog that uses gtk2hs?
16:53:53 <elliottt> are you using the nsis to do the install?
16:53:56 <jsnx> dcoutts: yes, how do i make one?
16:54:09 <jsnx> elliottt: nsis?
16:54:14 <elliottt> nullsoft installer system
16:54:34 <dcoutts> jsnx: I'm going to get round to making a blog post on it, but basically use any installer technology (eg InnoSetup) and install all the gtk+ dlls in the bin subdir
16:54:41 <elliottt> there's a version of the gtk+ runtime that gets installed with pidgin that uses it.  i was thinking you might be able to coexist with other installs if you used that :)
16:54:55 <dcoutts> jsnx: I've got .zip bundles of all the files you need to install
16:55:13 <dcoutts> elliottt: we used to do that, it was too much bother
16:55:22 <jsnx> dcoutts: why is that?
16:55:59 <dcoutts> jsnx: versions, compatibility, it was a massive pain, this is much much simpler, many fewer bug reports
16:56:06 <jsnx> dcoutts: oh
16:56:08 <dcoutts> jsnx: http://haskell.org/gtk2hs/win32/ has the binary bundles
16:56:09 <lambdabot> Title: Index of /gtk2hs/win32
16:56:12 <elliottt> ah, good point.
16:56:35 <jsnx> dcoutts: win32-buildscripts.zip?
16:56:36 <elliottt> i know that pidgin upgrades the gtk runtime with updates, quite frequently
16:57:18 <dcoutts> jsnx: hmm? what build scripts are you after?
16:58:10 <jsnx> the ones in http://haskell.org/~duncan/gtk2hs/
16:58:11 <lambdabot> Title: Index of /~duncan/gtk2hs
16:58:20 <dcoutts> jsnx: oh, ignore that
16:58:38 <dcoutts> jsnx: there are scripts for building gtk2hs from source on win32 but you don't want those I expect
16:58:45 <jsnx> dcoutts: so, you mentioned a zip file that explains what to do...
16:59:08 <jsnx> dcoutts: no, i don't need those
16:59:30 <dcoutts> jsnx: see that demo, see the dir layout is uses, that's all you need to do. and the gtk+-2.10.9-win32.zip has exactly the files you need.
17:00:02 <dcoutts> jsnx: or if you wait a couple days, there will be a new gtk2hs-0.9.12 that works with ghc-6.6.1 and has an updated gtk+ bundle
17:00:45 <jsnx> when you say see that demo, do you mean [ http://haskell.org/~duncan/gtk2hs/LSystemSetup.exe ]
17:00:48 <jsnx> ?
17:00:49 <dcoutts> yes
17:01:03 <jsnx> well, I'm a little lost now
17:01:09 <dcoutts> that's an installer for a demo app that uses gtk2hs
17:01:31 <jsnx> dcoutts: so, i need to install it on a windows machine, in order to see how it works
17:01:35 <jsnx> got it
17:01:38 <dcoutts> right
17:01:51 <dcoutts> that's the best I can do 'til I finish writing more detailed instructions
17:02:04 <jsnx> okay, thank you.
17:02:13 <dcoutts> jsnx: you're welcome
17:02:16 <dcoutts> g'night folks
17:15:08 <Olathe> So monads are a way of composing functions, but they let you do something between each function application ?
17:15:59 <dmwit> That's a reasonable way to think of them.
17:16:20 <dmwit> Have you seen dons' "programmable semicolon" paper?  (Is that where this came from?)
17:16:29 <Olathe> Nope.
17:16:53 <Olathe> I was just reading http://www.haskell.org/all_about_monads/html/introduction.html
17:16:55 <lambdabot> Title: Introduction
17:17:35 <dmwit> ok
17:23:29 <dmwit> errr... not so much a paper as a blog entry.
17:23:45 <dmwit> Olathe: So, have you understood the list monad yet?
17:31:51 <desp> what would you recommend for processing xml in haskell? haxml? hxt?
17:34:01 <dpiponi> ?
17:34:53 <dpiponi> Is there a prelude function to print an integer in a given base?
17:35:20 <dpiponi> Or at least return the string representing it in that base?
17:35:22 <oerjan> @index showIntAtBase
17:35:22 <lambdabot> Numeric
17:36:24 <dpiponi> showIntAtBase has a weird signature!
17:36:47 <oerjan> it takes functions to check bounds and convert to characters
17:36:59 <oerjan> :t showIntAtBase
17:37:01 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
17:37:28 <Lemmih> > showIntAtBase 2 intToDigit 0xdeadbeef ""
17:37:30 <lambdabot>  "11011110101011011011111011101111"
17:37:31 <oerjan> actually, not bounds, confusing with the corresponding read function
17:38:30 <oerjan> (readInt)
17:39:20 <lispy> > showIntAtBase 2 intToDigit 0xdeadbeef "frogs"
17:39:22 <lambdabot>  "11011110101011011011111011101111frogs"
17:39:24 <desp> I asked this a moment ago, but it probably got lost in split hell
17:39:27 <desp> what would you recommend for processing xml in haskell? haxml? hxt?
17:39:50 <lispy> desp: i used haxml, even made it support bytestrings in some cases
17:40:11 <lispy> desp: i was reasonably happy...but i was going from a DTD and then generating xml for that DTD
17:40:18 <desp> did you send patches upstream?
17:40:21 <lispy> yup
17:40:23 <dolio> > showIntAtBase 16 ("fedcba9876543210"!!) 0xdeadbeef ""
17:40:25 <lambdabot>  "21524110"
17:40:27 <desp> cool.
17:40:30 <dpiponi> oerjan: Thanks.
17:40:31 <lispy> desp: they should be in the mainstream by now
17:40:51 <lispy> desp: there was a tiny bit of discussion about it on one of the haskell mailing lists (probably cafe)
17:41:27 <lispy> i think the upstream author changed my patches a bit, and i haven't benchmarked the result, but the other person is more experiencd so hopefully it was all improvements
17:41:50 <lispy> desp: do y ou use arrows?
17:41:56 <lispy> it seems like that was the selling point of hxt
17:45:07 <desp> I only know they're supposed to be a generalization of monads :)
17:45:14 <desp> @whatis arrow
17:45:14 <lambdabot> I know nothing about arrow.
17:45:21 <desp> @whatis arrows
17:45:21 <lambdabot> http://www.haskell.org/arrows/
17:45:50 <oklopol> i thought lambdabot had fuzzy matching
17:46:08 <lispy> it has spell correction
17:46:14 <lispy> ?lusers
17:46:14 <lambdabot> Maximum users seen in #haskell: 367, currently: 325 (88.6%), active: 11 (3.4%)
17:46:41 <desp> possibly for commands only
17:46:46 <desp> ?l00sers
17:46:46 <lambdabot> Unknown command, try @list
17:46:53 <desp> ha! got you there.
17:46:56 <oerjan> oklopol: yeah, but arrow is handled by the @whatis plugin, not lambdabot itself
17:47:11 <oklopol> ah, of course
17:48:00 <oerjan> ?supers
17:48:00 <lambdabot> Maximum users seen in #haskell: 367, currently: 326 (88.8%), active: 10 (3.1%)
17:48:05 <oklopol> what's the distance algorithm?
17:48:17 <lispy> ?losers
17:48:18 <lambdabot> Maximum users seen in #haskell: 367, currently: 326 (88.8%), active: 10 (3.1%)
17:48:24 <lispy> hmm...
17:48:26 <desp> ?loosers
17:48:26 <lambdabot> Unknown command, try @list
17:48:29 <lispy> many things match users
17:48:32 <dibblego> oklopol, edit distance algorithm?
17:48:47 <oerjan> ?lasers
17:48:48 <lambdabot> Maximum users seen in #haskell: 367, currently: 326 (88.8%), active: 10 (3.1%)
17:48:49 <lispy> oklopol: you chould check :)
17:48:51 <lispy> ?version
17:48:52 <lambdabot> lambdabot 4p534, GHC 6.6 (Linux i686 2.66GHz)
17:48:52 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:49:01 <Pseudonym> ?masers
17:49:01 <lambdabot> Maximum users seen in #haskell: 367, currently: 326 (88.8%), active: 11 (3.4%)
17:49:07 <Pseudonym> ?vaders
17:49:07 <lambdabot> Unknown command, try @list
17:49:16 <Pseudonym> ?vases
17:49:16 <lambdabot> Unknown command, try @list
17:49:23 <Pseudonym> ?uses
17:49:23 <lambdabot> Maximum users seen in #haskell: 367, currently: 326 (88.8%), active: 11 (3.4%)
17:49:29 <Pseudonym> ?fuses
17:49:29 <lambdabot> Maximum users seen in #haskell: 367, currently: 326 (88.8%), active: 11 (3.4%)
17:49:31 <Pseudonym> Cool.
17:49:31 <lispy> it would be nice if lambdabot told you what she was correcting to
17:49:45 <lambdabot> Whatever I want to, sucker.
17:49:52 <oerjan> @usurps
17:49:52 <lambdabot> Maximum users seen in #haskell: 367, currently: 326 (88.8%), active: 11 (3.4%)
17:49:55 <lispy> ?suckers
17:49:56 <lambdabot> Unknown command, try @list
17:50:09 <jargonjustin> So, all of the ICFP activity got me interested, but this years challenge didn't look all that interesting so I'm playing with last years.
17:50:31 <SamB> jargonjustin: probably a wise choice
17:50:32 <lispy> i only participated in the 'ants' year
17:50:49 <lispy> i bet it's really hard to find a topic
17:50:50 <jargonjustin> However, I'm not sure what sort of data-structure would be setup to implement the UM, I assume something with a mutable Array for registers, and a map to other mutable arrays either inside an IO, State, or ST monad.
17:51:03 <SamB> I'm going to go back and finish last years once I'm thouroughly frustrated and/or spoilered with this year's
17:51:07 <SamB> jargonjustin: use C
17:51:09 <lispy> jargonjustin: yeah, mutable arrays were popular
17:51:14 <SamB> don't use Haskell for the UM
17:51:23 <SamB> GHC is probably still not ready for that
17:51:24 * Pseudonym hasn't even seen the ICFP challenge
17:51:27 <Pseudonym> Is it online?
17:51:28 <Cale> jargonjustin: It is actually pretty interesting (this year's competition) -- It's quite possibly one of the most interesting 7MB files I've ever come across.
17:51:32 <SamB> Pseudonym: yes!
17:51:33 <lispy> ?where icfp
17:51:33 <lambdabot> I know nothing about icfp.
17:51:33 <jargonjustin> SamB: I wrote it in C already :-) I'm just curious as to how Haskell could handle it
17:51:38 <lispy> ?where icfp-contest
17:51:38 <lambdabot> I know nothing about icfp-contest.
17:51:42 <SamB> jargonjustin: a lot less quickly
17:52:00 <Cale> jargonjustin: hmm, there were quite a few Haskell UMs
17:52:14 <desp> ?where+ icfp http://www.icfpcontest.org/
17:52:15 <lambdabot> Done.
17:52:22 <Pseudonym> Thanks.
17:52:27 <Cale> jargonjustin: At the time, I think lots of people struggled with performance. It would be interesting to see if that situation has improved.
17:52:47 <desp> SamB: not even with lazy bytestrings? hmm
17:52:50 <Cale> Certainly GHC's code generation has improved quite a bit in the last year.
17:52:59 <desp> Cale: I am going to try it
17:53:00 <jargonjustin> Cale: The C implementation (simple dispatch table with some optimization for common operations) runs quiet fast.
17:53:01 <dolio> @where um
17:53:01 <lambdabot> http://www.cse.unsw.edu.au/~dons/um.html
17:53:10 <newsham> mmm C
17:53:15 <jargonjustin> dolio: thanks
17:53:24 <desp> but yeah, the UM is quite simple
17:53:32 <desp> so C is a good fit
17:53:41 <gkr> What's the name of the identity monad in Haskell?
17:53:49 <Cale> gkr: Identity
17:53:54 <mauke> @index Identity
17:53:55 <lambdabot> Control.Monad.Identity, Control.Monad.Identity
17:53:55 <Cale> gkr: In Control.Monad.Identity
17:54:00 <gkr> Thanks.
17:54:07 <lispy> you could write the UM in postscript
17:54:10 <newsham> > return 0 :: Identity Int
17:54:11 <lambdabot>   add an instance declaration for (Show (Identity Int))
17:54:16 <lispy> but, input is a bit tricky i've heard
17:54:22 * Pseudonym doesn't see the actual spec here on the ICFP contest page
17:54:25 <SamB> desp: the issue is the shifting!
17:54:32 <Pseudonym> Maybe I need to wait until the caffeine kicks in.
17:54:34 <lispy> Pseudonym: it's one of the links in the blob of text
17:54:34 <SamB> desp: we are talking about the ICFP 2006 contest
17:54:37 <SamB> not 2007
17:54:41 <Pseudonym> Ah, OK.
17:54:43 <lispy> Pseudonym: its a pdf, pretty long
17:54:50 <desp> SamB: I know
17:54:51 <Pseudonym> FSM forbid they actually draw attention to it.
17:55:01 <chessguy> Pseudonym,  http://www.icfpcontest.org/Endo.pdf
17:55:02 <Cale> jargonjustin: This year's ICFP is actually surprisingly similar to last. The string rewriting system is used to do arbitrary computation.
17:55:05 <SamB> desp: lazy bytestrings aren't even slightly helpful
17:55:25 <SamB> Cale: but last year's had a better setup I think...
17:55:27 <desp> SamB: hm
17:55:37 <SamB> Cale: in terms of the reward structure
17:55:43 <Cale> oh, for sure
17:55:51 <desp> yeah
17:55:58 <newsham> can i get a lazy string of bitpairs please?
17:56:02 <Cale> This year's contest would have made a much better week-long or month-long competition
17:56:10 <SamB> Cale: indeed!
17:56:19 <SamB> probably week-long
17:56:25 <newsham> doyou know how many dead prorammres there would be if it was month-long?
17:56:36 <desp> hehe
17:56:36 <newsham> (not to mention how much work I wold miss)
17:56:36 <chessguy> i'm surprised that didn't come out in the testing process of preparing the contest
17:56:49 <desp> well, i fit was a week-long, I could sleep more than 3h per night
17:56:51 <SamB> newsham: I was thinking more in terms of "do you know how many teams would have gotten to 100%"?
17:56:55 <desp> s/i fit/if it/
17:57:04 <SamB> s/"\?/?"/
17:57:05 <newsham> maybe all the test crew were familiar with efficient string representations
17:57:10 <lispy> chessguy: well last year the contestants far exceeded what the judges expected...so i bet they planned for that this year
17:57:30 * wli materializes.
17:57:54 <SamB> lispy: the way to plan for that isn't to set up the rewards structure this badly :-(
17:57:59 <wli> Weren't there 700-800 teams this year?
17:58:19 <newsham> so many complaints.  endo still ruled.
17:58:19 <wli> What's going on with the rewards structure again?
17:58:24 <newsham> even though he's dead now :(
17:58:25 <SamB> wli: are you counting only those teams that at least passed 0%?
17:58:39 <wli> SamB: No.
17:58:41 <SamB> newsham: did they announce his death?
17:58:51 <Pseudonym> Ah, so that's what the DNA for a superintelligent shade of blue looks like.
17:58:52 <SamB> wli: well, probably best to do so
17:58:59 <newsham> no, i'm just assuming.
17:59:03 <newsham> know how frail his type usually is
17:59:20 <wli> SamB: What was that number? Are there announcements for all this?
17:59:24 <newsham> probably floating belly up in that stream right now
17:59:35 <SamB> wli: the scoreboard isn't accesible anymore?
18:00:06 * ddarius needs to read the logs...
18:01:17 <SamB> according to my open scoreboard (which was updated automagically with AJAX code), 172 teams actually exceeded 0.0000%
18:02:30 <desp> oh, btw -- anyone knows if there's a haskell organization cloak available here on freenode?
18:02:45 <SamB> desp: why?
18:02:50 <SamB> do you have a lot of people that hate you?
18:03:05 <desp> no, I just think it would be cool to represent ;p
18:03:09 <desp> fly my colors!
18:03:42 <SamB> desp: it's annoying!
18:03:50 <desp> why?
18:03:51 <bitwiseshiftleft> question: how expensive are finalizers?
18:04:05 <SamB> desp: we can't look at your domain name if you are cloaked, duh
18:04:15 <bitwiseshiftleft> (and how evil?)
18:04:16 <SamB> that's why it's called a cloak
18:04:28 <desp> SamB: well...um. isn't that the whole point?
18:04:40 <desp> SamB: I'm not sure why's that annoying, though
18:05:31 <SamB> can't look at your domain name to try to figure out where you live?
18:06:14 <desp> how about asking?
18:06:29 <monochrom> Where do you live? :)
18:06:40 <desp> Poland
18:06:52 <monochrom> Thanks :)
18:07:02 <desp> you're welcome :)
18:07:16 <SamB> that only works when you are actually sitting at your keyboard
18:07:42 <monochrom> You can enlist the help of @tell :)
18:07:47 <hpaste>  jleedev pasted "mergesort" at http://hpaste.org/1891
18:09:24 <chessguy> heh. someone who's not in the channel hpasted his first function for us :)
18:09:59 <hpaste>  monochrom annotated "mergesort" with "type sig" at http://hpaste.org/1891#a1
18:10:41 <kpreid> monochrom: that looks like a pattern case, not a type signature
18:11:04 <monochrom> OH!
18:11:14 <kpreid> needs a [] case, though
18:11:15 <kpreid> and here's jleedev
18:11:24 <jleedev> oh it does need the empty base case
18:11:29 <chessguy> kpreid, it might be ok
18:11:33 <jleedev> yay attention
18:11:38 <Cale> :)
18:11:40 <chessguy> doesn't the empty case just get handled in merge?
18:11:49 <Cale> That is a pretty good first function :)
18:11:51 <kpreid> it would recurse on two empty sublists
18:12:03 <chessguy> > split 0 []
18:12:10 <jleedev> mergesort [] gives a stack overflow
18:12:10 <lambdabot>  Couldn't match expected type `[a] -> t'
18:12:11 <chessguy> > splitAt 0 []
18:12:12 <lambdabot>  ([],[])
18:12:15 <monochrom> mergesort [] = merge (mergesort []) (mergesort [])
18:12:21 <chessguy> lambdabot mooned me!
18:12:37 <monochrom> Perhaps I should use ~> instead of =
18:12:38 <kpreid> jleedev: you need "mergesort [] = []", otherwise what happens is what monochrom said
18:12:43 <chessguy> kpreid, ah, you're right
18:12:48 <jleedev> kpreid: two base cases, then?
18:12:58 <chessguy> you don't need the [a] case
18:13:16 <kpreid> jleedev: yes, or what chessguy said, or "mergesort a | length a <= 1 = a"
18:13:24 <monochrom> > splitAt (1 `div` 2) [True]
18:13:25 <lambdabot>  ([],[True])
18:13:46 <jleedev> mergesort [a] = merge (mergesort []) (mergesort [a]), which doesn't terminate
18:13:56 <monochrom> I don't like "length a"
18:14:00 <Cale> Except that computing the length of the list is needlessly expensive just to tell if it's empty or length 1 :)
18:14:17 <kpreid> whoops
18:14:23 <monochrom> what Cale says. It has been a hard-learned lesson.
18:14:25 <kpreid> where's that lengthBelow function?!
18:14:36 <kpreid> @hoogle [a] -> Int -> Bool
18:14:37 <lambdabot> No matches, try a more general search
18:14:49 <Cale> Hey, that's actually a decent idea :)
18:14:57 <Cale> Sort of a generalisation of null :)
18:15:00 <jleedev> monochrom: mergesort runs best when you split the list in half. doesn't that need length?
18:15:15 <Cale> lengthBelow n = null . drop n
18:15:18 <monochrom> Oops. You're right.
18:15:23 <oerjan> i think it should be lengthCompare, and return an Ordering
18:15:48 <monochrom> I guess for halving the list we need length a anyway.
18:16:22 <kpreid> lengthCompare [] 0 = EQ; lengthCompare [] -1 = GT; lengthCompare (_:xs) n = lengthCompare xs (pred n)
18:17:15 <oerjan> missing an _ 0 case
18:17:26 <oerjan> and -1 needs a parenthesis
18:17:41 <Cale> Oh, the implementation in Data.List is kind of interesting. It just starts out with map (:[]) and then merges the list of lists.
18:17:44 <dolio> Missing more than that, really.
18:17:44 <oerjan> or wait
18:18:30 <Cale> (by essentially right folding merge, with the two appropriate base cases added)
18:18:34 <oerjan> it misses [] _
18:18:40 <kpreid> working on it...
18:18:41 <dolio> lengthCompare [] n = compare 0 n ; lengthCompare (_:xs) n = lengthCompare xs (pred n)
18:19:07 <kpreid> lengthCompare [] n = compare 0 n; lengthCompare (_:xs) n = lengthCompare xs (pred n)
18:19:08 <Olathe> dmwit: Yep (on the List monad).
18:19:28 <dolio> Great minds think alike. :)
18:19:31 <oerjan> now we could make it a method so the arguments could be either lists or numbers >:)
18:19:39 <kpreid> @check let lengthCompare [] n = compare 0 n; lengthCompare (_:xs) n = lengthCompare xs (pred n) in \l n -> (lengthCompare l n) == (length l `compare` n)
18:19:41 <lambdabot>  Add a type signature
18:19:56 <kpreid> @check let lengthCompare [] n = compare 0 n; lengthCompare (_:xs) n = lengthCompare xs (pred n) in \l n -> (lengthCompare (l::[()]) (n::Int)) == (length l `compare` n)
18:19:57 <lambdabot>  OK, passed 500 tests.
18:20:08 <dons> ?users
18:20:08 <lambdabot> Maximum users seen in #haskell: 367, currently: 332 (90.5%), active: 24 (7.2%)
18:21:32 <jleedev> > zipWith (==) "Bookkeeper" (tail "Bookkeeper")
18:21:33 <lambdabot>  [False,True,False,True,False,True,False,False,False]
18:21:34 <kpreid> @check let lengthCompare = foldr (pred .) (compare 0) in \l n -> (lengthCompare (l::[()]) (n::Int)) == (length l `compare` n)
18:21:34 <lambdabot>  Couldn't match expected type `(t -> Ordering) -> t -> Ordering'
18:21:56 <kpreid> @check let lengthCompare = foldr (. pred) (compare 0) in \l n -> (lengthCompare (l::[()]) (n::Int)) == (length l `compare` n)
18:21:57 <lambdabot>  Couldn't match expected type `(t -> Ordering) -> t -> Ordering'
18:22:18 <kpreid> @check let lengthCompare = foldr (compare 0) (. pred) in \l n -> (lengthCompare (l::[()]) (n::Int)) == (length l `compare` n)
18:22:19 <lambdabot>  Couldn't match expected type `b -> b'
18:22:37 <Cale> mergesort = foldr merge [] . map (:[])
18:22:40 <hpaste>  asl pasted "I want an instance I can't have" at http://hpaste.org/1892
18:22:52 <asl> Hey there!
18:23:07 <asl> I'm having small troubles :-)
18:23:07 <Cale> asl: -fglasgow-exts
18:23:10 <kpreid> @check let lengthCompare = foldr (const (. pred)) (compare 0) in \l n -> (lengthCompare (l::[()]) (n::Int)) == (length l `compare` n)
18:23:10 <asl> ah!
18:23:11 <lambdabot>  OK, passed 500 tests.
18:23:14 <kpreid> ding!
18:23:22 <kpreid> lengthCompare = foldr (const (. pred)) (compare 0)
18:23:58 <dolio> Cale: That's insertion sort, isn't it?
18:24:39 <oerjan> kpreid: i am not sure that is lazy
18:24:43 <Cale> dolio: oh, right, foldr is the wrong thing
18:25:04 <Cale> dolio: Really, you need to combine adjacent pairs
18:25:09 <Olathe> How can it be wrong when it folds so right ?
18:25:10 <kpreid> oerjan: ...doh; that's also true of the previous version
18:26:34 <asl> ah, there's no unit in my instance for Monoid, anyway
18:26:36 <kpreid> @check let lengthCompare [] 0 = EQ; lengthCompare [] n | n < 0 = LT; lengthCompare (_:xs) 0 = GT; lengthCompare (_:xs) n = lengthCompare xs (pred n) in \l n -> (lengthCompare (l::[()]) (n::Int)) == (length l `compare` n)
18:26:37 <lambdabot>  Falsifiable, after 0 tests: [], -1
18:27:04 <kpreid> @check let lengthCompare [] 0 = EQ; lengthCompare [] n | n < 0 = GT; lengthCompare (_:xs) 0 = GT; lengthCompare (_:xs) n = lengthCompare xs (pred n) in \l n -> (lengthCompare (l::[()]) (n::Int)) == (length l `compare` n)
18:27:05 <lambdabot>   Non-exhaustive patterns in function lengthCompare
18:27:34 <oerjan> you have nothing that gives LT
18:27:39 <kpreid> @check let lengthCompare [] n = compare 0 n; lengthCompare (_:xs) 0 = GT; lengthCompare (_:xs) n = lengthCompare xs (pred n) in \l n -> (lengthCompare (l::[()]) (n::Int)) == (length l `compare` n)
18:27:41 <lambdabot>  OK, passed 500 tests.
18:27:47 <kpreid> there
18:28:34 <oerjan> also, you probably want strictness annotation on n
18:28:56 <kpreid> why?
18:29:24 <oerjan> well, maybe not that important but you are building a pred (...) thunk
18:29:31 <oerjan> er, wait
18:29:38 <oerjan> that 0 does it
18:30:46 <kpreid> can't build a chain of thunks. proof: in the first two cases, there is no recursion; in the third case, both arguments have been evaluated for patterns
18:31:14 <kpreid> am I right?
18:31:16 <oerjan> yeah, i noticed
18:31:26 <oerjan> (that's what "that 0 does it" meant)
18:31:41 * kpreid nods
18:36:01 <oerjan> btw we can use drop for the recursion.
18:38:13 <blackdog> seafoodX: begone, ML infidel
18:38:28 <monochrom> ML is fine.
18:39:17 <oerjan> hm, maybe too complicated to bother.
18:39:20 <dons> blackdog: he's so impure now!
18:39:36 <blackdog> monochrom: jeez, you guys are hard to rile into a flamewar.
18:39:45 <blackdog> dons: yep. he used to be such a good boy.
18:39:52 <blackdog> now he's a little bit street.
18:40:11 <hpaste>  Cale pasted "funny combinator version of mergesort" at http://hpaste.org/1893
18:42:05 <monochrom> Interesting.
18:42:09 <seafoodX> blackdog: At least it's still statically typed.
18:42:37 <blackdog> don't come in here with your weak excuses :)
18:42:43 <Cale> It seems to be pretty much equivalent to the version in the libraries.
18:42:48 <blackdog> or was that a jab at my RoR stuff?
18:42:52 <seafoodX> Yup
18:42:58 <Cale> (the version I just pasted)
18:44:04 <blackdog> 'spose everyone needs a day job
18:49:48 <dons> blackdog: did you see that nice web dev job on reddit?
18:49:59 <dons> http://ajaxian.com/archives/ajax-web-developer-240k-per-year-with-only-one-catch
18:50:02 <lambdabot> Title: Ajaxian » Ajax Web Developer: $240k per year&#8230; with only one catch, http://tinyurl.com/yoehcm
18:51:55 <SamB_XP_> dons: is it the catch that ndm wrote?
18:52:16 <dolio> No, it's that you're programming in Iraq.
18:52:39 <monochrom> And under US DoD too.
18:54:04 * ddarius wouldn't mind programming in Iraq.
18:54:24 <dons> but AJAX - that's one step too far!!
18:54:41 <monochrom> Do you mind being marked as an employee of the US DoD?
18:54:44 <ddarius> Actually we are doing AJAX web development right here.
18:54:53 <ddarius> monochrom: I am an employee of the US DoD.
18:55:10 <monochrom> But bearing that identity in Iraq, of all places...
18:55:13 <blackdog> dons: yep. Hell, i'd do that. I have middle east experience already :)
18:55:24 <SamB_XP_> so why do they want an AJAX developer in Iraq?
18:55:28 <ddarius> monochrom: I'll have a fairly large rifle if it's too too bad.
18:55:34 <monochrom> OK :)
18:55:47 <ddarius> SamB_XP_: Why not?
18:56:06 <dons> blackdog: yes, suitably qualified!
18:56:08 <SamB_XP_> they want someone to crash their weopon-firing websites?
18:56:11 <blackdog> it used to be a good thing to be australian rather than american in the middle east, i think, but i suspect the steelies at the doha games may have ruined that  :)
18:56:28 <monochrom> haha
18:56:38 <dons> SamB_XP_: everyone needs web 2.0 sites.
18:56:53 <dibblego> web 2.0 will liberate Iraq
18:58:13 <monochrom> I heard that field soldiers actually use laptops to browse military-run web pages to read and write updates.
19:00:18 <dibblego> they should use darcs instead
19:00:38 <dibblego> Haskell will liberate Iraq!
19:02:16 <blackdog> it's not uncommon for middle east jobs to pay ridiculously well, though. i was getting paid well over the odds for a pretty basic soldering/lighting tech position.
19:02:45 <blackdog> my gf was getting 60k for a position answering phones
19:04:54 <Saulzar> I saw a position advertised in Afghanistan
19:04:58 <desp> dons: hah
19:05:06 <desp> dons; can I submit my C UM to your UM page?
19:05:18 <Saulzar> With another identical position below in Sydney - someone forgot to enter the "Country" field the first time :)
19:05:52 <SamB_XP_> dons: can you recompile and sandmark all of the UMs with the same version of GCC or GHC (as appropriate)?
19:05:52 <desp> time ./desp-um sandmark.umz -> real    2m49.058s
19:05:53 <desp> time ./edwardk-um sandmark.umz -> real    3m22.837s
19:06:16 <desp> color me surprised
19:06:46 <SamB_XP_> desp: of course, you'd need to do it on 32-bit to compare all of 'em
19:06:48 <SamB_XP_> er.
19:06:49 <SamB_XP_> dons.
19:07:03 <desp> edwardk-um crashes on 64-bit
19:07:13 <desp> and mine doesn't run
19:08:06 <desp> dons: http://varsztat.com/um.c
19:08:56 <SamB_XP_> mine also crashes on 64-bit
19:09:02 <SamB_XP_> at least I sure hope it does
19:09:18 <SamB_XP_> if it were to work it'd be funny!
19:10:22 <chessguy> hm, i would expect that, if anything, a program would work on 64-bit, but not on 32-bit
19:10:40 <desp> no.
19:10:48 <chessguy> what can you do on a 32-bit architecture that crashes on 64?
19:10:50 <desp> not if you expect your pointers to be 32-bit values.
19:11:38 <SamB_XP_> chessguy: I take it you didn't try ICFP 2006?
19:12:06 <chessguy> i barely knew haskell or any functional languages existed at this time last year :)
19:12:17 <SamB_XP_> oh really?
19:12:21 <SamB_XP_> huh.
19:13:08 <SamB_XP_> well, you know, lots of dysfunctional programmers do attempt the ICFP problems...
19:13:33 <monochrom> I guess chessguy didn't want to be dysfunctional :)
19:13:41 <chessguy> yeah, silly me
19:14:01 <desp> :D
19:14:47 <monochrom> If chessguy did icfp 2006 with his superior assembly skills, history would be rewritten: we would have to concede "assembly is the preferred tool for the discriminating hacker!"
19:15:06 <desp> @tell dons Could you add my C UM to your UM benchmark page?  http://varsztat.com/um.c  It appears to be faster than edwardk's.  Thanks. :)
19:15:07 <lambdabot> Consider it noted.
19:15:23 <SamB_XP_> dysfunctional programming was kind of mandatory ;-)
19:15:25 <blackdog> dons: do you use cabal-install on openbsd? i'm having some problems with tar, i think
19:15:43 <SamB_XP_> chessguy: you should totally go grab the codex and play with that!
19:15:51 <chessguy> monochrom, huh? i certainly never claimed to have superior skills at anything
19:16:05 <chessguy> SamB_XP_, i heard haskell didn't do very well with it
19:16:06 <dons> haven't tried it recently
19:16:06 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
19:16:09 <SamB_XP_> but don't grab the sources until you've played for a while
19:16:15 <dons> it might want gnu tar :/
19:16:18 <SamB_XP_> chessguy: Haskell is cool
19:16:21 <monochrom> I'm just hallucinating.
19:16:22 <SamB_XP_> once you start
19:16:26 <blackdog> yeah, i tried setting the path to gtar instead
19:16:28 <blackdog> no joy
19:16:29 <SamB_XP_> and have a program you want to write
19:16:29 <blackdog> oh well
19:16:40 <SamB_XP_> to help you with the puzzles
19:16:46 <chessguy> SamB_XP_, i never said haskell wasn't cool...
19:17:10 <SamB_XP_> chessguy: I meant, you can use it on that contest problem
19:17:33 <SamB_XP_> just don't use it for your UM if you value the computational resources available to you
19:17:55 <chessguy> oh, so there's subtasks to it?
19:17:58 <dolio> It does fine if you're an FFI hacker like dons. :)
19:18:17 <SamB_XP_> dolio: dons figured out how to get bitshifts to go fast enough ?
19:18:28 <SamB_XP_> without making it easier to just write in C???
19:19:02 <monochrom> dons hacked FFI to do bitshifts? :)
19:19:04 <dolio> I don't know. His machine on that page is only 4x as slow as the fastest C one.
19:19:16 <dons> monochrom: hmm? no. just use Data.Bits
19:19:17 <monochrom> Oh, FFI, not FFT. Now I see. :)
19:19:20 <dolio> Although desp just beat that C.
19:19:30 * monochrom goes hack FFT to do bitshifts...
19:19:40 <SamB_XP_> monochrom: um.
19:19:56 <SamB_XP_> the appalling stupidity of such a course of action amazes me!
19:19:57 <chessguy> @what fft
19:19:57 <lambdabot> I know nothing about fft.
19:20:01 <chessguy> @where fft
19:20:01 <lambdabot> I know nothing about fft.
19:20:08 <SamB_XP_> @go fast fourier transform
19:20:13 <lambdabot> http://en.wikipedia.org/wiki/Fast_Fourier_transform
19:20:13 <lambdabot> Title: Fast Fourier transform - Wikipedia, the free encyclopedia
19:20:16 <chessguy> oh THAT fft
19:20:25 <SamB_XP_> what fft did you think?
19:20:37 <SamB_XP_> fast function transputation?
19:20:38 <chessguy> dunno, thought it was some haskell library i didn't know about
19:20:42 <monochrom> You know, shifting is just convolving with some funny step function...
19:22:46 <chessguy> @go icfp 2006
19:22:48 <lambdabot> http://icfp06.cs.uchicago.edu/
19:22:48 <lambdabot> Title: 11th ACM SIGPLAN International Conference on Functional Programming (ICFP 2006)
19:23:00 <SamB_XP_> @go cult of the bound variable
19:23:04 <lambdabot> http://www.boundvariable.org/task.shtml
19:23:05 <lambdabot> Title: ICFP Programming Contest, 2006 : Contest Materials and Task
19:23:14 <SamB_XP_> chessguy: better?
19:23:20 <chessguy> ya
19:23:24 <SamB_XP_> zarvok says they've made a new codex release
19:23:30 <SamB_XP_> with sources available this time
19:23:35 <SamB_XP_> at long last
19:23:50 <glguy> new codex? like the old one with bug fixes?
19:24:04 <SamB_XP_> glguy: I imagine it is something of that nature
19:24:31 <desp> yeah
19:24:38 <desp> and more easter eggs
19:24:50 <SamB_XP_> oooh
19:26:17 <chessguy> SamB_XP_, you're saying i should download someone else's UM and run the codex on that?
19:26:32 <glguy> has anyone used darcs and git enough to relate to me what I gain/lose using one over the other?
19:26:36 <SamB_XP_> chessguy: what?
19:26:41 <SamB_XP_> chessguy: no. write one in C!
19:26:49 <chessguy> eww
19:26:51 <chessguy> c--
19:27:03 <glguy> c-- is a language to itself
19:27:12 <SamB_XP_> well, in that case, go ahead and download one of ours ;-)
19:27:14 <monochrom> Yeah, write one in c-- instead. At least ghc understands it too :)
19:27:15 <chessguy> i wonder how slow javascript is
19:27:21 <SamB_XP_> mine is decently fast
19:28:09 <chessguy> ?version SamB_XP_
19:28:10 <lambdabot> lambdabot 4p534, GHC 6.6 (Linux i686 2.66GHz)
19:28:10 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:28:22 <chessguy> oops
19:28:22 <SamB_XP_> what?
19:28:55 <glguy> I wrote mine in C# to make it easier to work on at work
19:29:03 <glguy> (I was in a job doing C# work)
19:29:15 <dons> monochrom: that's an interesting idea
19:29:21 <monochrom> haha
19:29:27 <dons> i wonder if anyone's tried writing C-- for ghc, other than SimonM in the runtime
19:29:32 <monochrom> I come up with all the crazy ideas.
19:29:35 <dons> you get access to all the yummy internals
19:29:42 <glguy> dons:
19:29:43 <glguy> ?where curl
19:29:43 <lambdabot> http://code.haskell.org/curl/
19:29:48 <SamB_XP_> chessguy: you still haven't given me a CTCP VERSION response
19:29:57 <dons> $ ls *.cmm
19:29:57 <dons> Apply.cmm           HeapStackCheck.cmm  StgMiscClosures.cmm StgStdThunks.cmm
19:29:57 <dons> Exception.cmm       PrimOps.cmm         StgStartup.cmm      Updates.cmm
19:30:02 <chessguy> SamB_XP_, try again
19:30:02 <dons> glguy: woot!!1
19:30:21 <SamB_XP_> your CPU is faster than mine
19:30:32 <SamB_XP_> but what version of windows are YOU running?
19:30:41 <chessguy> xp
19:30:49 <dons> looks good glguy. great work
19:30:59 <dons> glguy: be sure to make a big announce
19:31:09 <glguy> i will when I package it up
19:31:21 <glguy> I think that I need to get some examples written first
19:31:26 <glguy> it isn't necessarily obvious how to use it
19:31:31 <glguy> unless you know libcurl already
19:31:37 <chessguy> ?where um
19:31:37 <lambdabot> http://www.cse.unsw.edu.au/~dons/um.html
19:31:45 <SamB_XP_> glguy: what is git?
19:32:10 <dons> glguy: yeah. good idea. take some examples from the curl site (surely they have some)
19:32:26 <chessguy> wow, edwardk's UM is really short
19:34:04 <dibblego> ?type deleteFindMin
19:34:12 <lambdabot> Not in scope: `deleteFindMin'
19:34:24 <chessguy> only 100 lines of code
19:34:28 <glguy> SamB_XP_: a dvcs tool
19:34:37 <glguy> SamB_XP_: used on linux kernel
19:34:43 * SamB_XP_ was being slightly facetious
19:35:02 <SamB_XP_> glguy: does that answer your question at all?
19:35:10 <desp> glguy: ;_;
19:35:46 <dons> glguy: we could port urlcheck to the curl package
19:35:55 <dons> (currently it uses its own TinyHTTP.hs)
19:36:05 <chessguy> hmm, gcc doesn't seem to be able to build edwardk's UM though
19:36:25 <glguy> dons: what is urlcheck?
19:36:45 <glguy> ?where urlcheck
19:36:45 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/urlcheck
19:36:55 <dons> its a parallel link checker I wrote for a blog post
19:37:02 <dons> checks urls in the HWN for 404s
19:37:07 <dons> lots of threads
19:37:13 <glguy> I'll investigate
19:37:22 <glguy> each thread will need a separate libcurl handle
19:37:32 <dons> right, so i guess that works?
19:37:38 <glguy> yeah, we do that already
19:38:19 <desp> glguy: http://varsztat.com/projects/curl/darcs/Network/CURL/Multi.hsc
19:38:21 <bitwiseshiftleft> question: how much overhead is there from C FFI calls, and how much overhead is there from finalizers?
19:38:40 <dons> interesting, http://luqui.org/blog/archives/2007/07/26/making-haskell-nicer-for-game-programming/
19:38:43 <lambdabot> Title: The dreams that stuff is made of » Making Haskell nicer for game programming, http://tinyurl.com/yto4ko
19:38:44 <desp> using the multi interface requires only one bound thread
19:38:52 <dons> bitwiseshiftleft: FFI calls are hmm, 1000 cycles?
19:39:09 <bitwiseshiftleft> even if they're marked unsafe?
19:39:17 <chessguy> hm, dons' haskell UM doesn't build here either
19:39:22 <dons> yeah, its worse if they have to be safe.
19:39:28 <bitwiseshiftleft> hm, ok
19:39:32 <ddarius> I like that title.
19:39:37 <dons> some registers get saved, and you make a C call
19:39:44 <glguy> desp: cool, I think we use the Easy interface at this point
19:39:45 <Olathe> chessguy: What options are you using ?
19:39:53 <chessguy> Olathe, none
19:39:53 <dons> finalisers are fairly small, a dozen words or so
19:39:54 <glguy> desp: that's something to investigate
19:40:04 <Olathe> chessguy: What errors are you getting ?
19:40:17 <chessguy> Fast.hs:102:46: Not in scope: `bounds'
19:40:28 <Olathe> Oh, Haskell.
19:40:32 <desp> glguy: and you aren't supposed to call the curl functions operating on a given handle from different OS threads
19:41:00 <bitwiseshiftleft> dons: thanks.  trying to figure out tradeoffs of a certain algorithm; it's somewhat harder than in c
19:41:31 <dons> calling into C is harder than in C? :)
19:41:56 <ddarius> Sweet!  FFI success!
19:41:58 <chessguy> dons, any idea why your haskell UM doesn't work in 6.6.1?
19:42:18 <dons> bounds got moved into the array class
19:42:45 <SamB_XP_> dons: where was it before?
19:42:57 <chessguy> so i have to change this?
19:42:57 <chessguy> type Heap    = IOUArray Word32 Platter
19:43:07 <dons> sorry, it was moved into IO.
19:43:21 <dons> SamB_XP_: it was on the moon
19:43:23 <Olathe> desp: What compiler settings did you use for your C UM ?
19:43:29 <desp> -O2
19:43:48 <dons> chessguy: you use getBounds, instead of bounds
19:43:55 <dons> :t Data.Array.getBounds
19:43:57 <lambdabot> Not in scope: `Data.Array.getBounds'
19:44:01 <dons> or whatever :)
19:44:15 <dons> :t Data.Array.Base.getBounds
19:44:17 <lambdabot> forall (a :: * -> * -> *) i e (m :: * -> *). (Data.Array.Base.MArray a e m, Ix i) => a i e -> m (i, i)
19:44:48 <dons> GOt TYPES?
19:45:01 <lispy> nope
19:45:05 <lispy> i left them at home
19:45:08 <SamB_XP_> we should put that on billboards
19:45:20 <SamB_XP_> with a lambda in the corner
19:45:22 <dons> would make a good tshirt
19:45:24 <SamB_XP_> a blue one
19:45:56 <lispy> why blue?
19:45:56 <glguy> my puppy tried to jump unto my couch... but headbutted my laptop lid instead X-|
19:46:11 <desp> glguy: I mean, the problems start when the RTS is multi-threaded. then, you can't guarantee that libcurl will be called from the same OS thread every time.
19:46:36 --- mode: ChanServ set +o dons
19:46:39 <chessguy> wow
19:46:40 --- topic: set to '["The Haskell programming language: got types?","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","The language of ICFP winners 3 years running"]' by dons
19:46:44 --- mode: ChanServ set -o dons
19:46:53 <glguy> desp: that's an interesting issue, I'll need to check how that is handled if it is handled
19:46:58 <glguy> desp: I didn't write most of this
19:47:02 <chessguy> changing bounds to getBounds gets rid of that error, but replaces it with a 5-page essay on a new error
19:47:11 <dons> chessguy: it got lifted into IOOo
19:47:22 <desp> glguy: I'm glad you got the options handled, though
19:47:23 <dons> IOOooo...--
19:47:31 <desp> glguy: I'll see if I can steal that code, perhaps :)
19:47:39 <chessguy> Fast.hs:102:40:
19:47:39 <chessguy>     Couldn't match expected type `Word32'
19:47:39 <chessguy>            against inferred type `(Word32, Word32)'
19:47:39 <chessguy>     In the expression: snd $ (getBounds heap)
19:47:44 <lispy> IOOooo...__
19:47:46 <desp> glguy: I was taking a more mind-numbing approach
19:47:54 <SamB_XP_> chessguy: WTH!
19:48:00 <glguy> desp: which was that?
19:48:15 <desp> glguy: the multitude of parameters to be passed to setopt
19:48:21 <dons> chessguy: liftM snd (getBounds heap)
19:48:34 <dons> or (_,v) <- getBounds heap
19:48:43 <desp> glguy: as for handling the thread issue, the multi interface makes it simple -- you need just one OS thread for any number of transfers, and the performance is better too
19:48:51 <glguy> ah, one thing I ended up reworking was how we track all of the deallocations that need to be done
19:49:05 <glguy> since you can dup a handle
19:49:12 <desp> glguy: so how do you keep track of it?
19:49:23 <dons> glguy: how was SPJs talk?
19:49:29 <glguy> we keep a map of option numbers to IO actions
19:49:40 <glguy> so that we can free the CStrings
19:49:44 <glguy> when an option is changed
19:49:51 <glguy> and when we dup a handle
19:50:11 <glguy> we have to create new IO actions for clean up so that the deallocation doesn't happen until both users are done
19:50:20 <chessguy> dons, err, you know v isn't used elsewhere in the code?
19:50:26 <glguy> that gets rather ugly I think, so I
19:50:31 <glguy> would be interested in other approaches
19:50:37 <glguy> dons the talk was pretty fun
19:50:55 <glguy> and I got a chance to talk to SPJ afterwards with some potentially interesting uses of orElse
19:50:59 <desp> glguy: I'm keeping the libcurl handles wrapped in my own datatype, along with all the stuff that needs to be freed
19:51:05 <glguy> lots of good questions
19:51:10 <glguy> desp: we do that too
19:51:12 <glguy> desp: but
19:51:22 <glguy> desp: we have a couple long lived handles
19:51:26 <glguy> so we can't wait until the end to cleanup
19:51:36 <desp> er?
19:51:42 <dons> did you hear anything about videos of the oscon talks?
19:51:53 <glguy> andy gill took one of the tutorial
19:51:55 <desp> but the stuff that you alloc and pass to libcurl needs to live as long as the handle lives -- or until you replace it by another setopt call
19:51:58 <glguy> i don't know about the rest
19:52:10 <glguy> desp: right, so we handle the times when you change the option
19:52:41 <glguy> desp: but sometimes, you change an option, but that CString is still being used by a dupped handle
19:52:51 <glguy> so that added a little complexity
19:52:53 <chessguy> dons, liftM snd (getBounds heap) almost works
19:52:54 <chessguy>     Couldn't match expected type `Word32'
19:52:55 <chessguy>            against inferred type `m Word32'
19:52:58 <desp> ok, I've checked out your rep and will read the code looking for insights
19:53:11 <desp> glguy: I'd just dup the CString.
19:53:24 <glguy> desp: and then reset all of those options?
19:53:40 <desp> there's not that many things, I think
19:53:50 <dons> andyjgill: you know something about video of SPJs talks this week? :)
19:54:06 <desp> also, I don't think dupping handles is something that is done often -- or is it?
19:54:08 <andyjgill> Yes, I was handling this.
19:54:15 <dons> we may have to talk to SPJ directly about the OSCON `taste of haskell' talk though?
19:54:18 <ddarius> You have videoz?
19:54:21 <dons> you just recorded the galois talk?
19:54:29 <glguy> desp: I'm sure the amount of time that it is done is application dependent
19:54:34 <falconair> i need to write a client using a binary protocol (need to convert bytes to haskell data-types, protocol not text based).  can someone recommend some piece of code I can study to learn how best to parse binary data off the network, convert it to haskell types, etc.?
19:54:38 <andyjgill> We've got about 3 hours of the OSCON Taste of Haskell
19:54:40 <desp> glguy: sure
19:54:40 <glguy> desp: but the alternative was to not support that function
19:54:45 <dons> andyjgill: oh, great!
19:54:48 <monochrom> @djinn Not (Either a b) -> (a,b)
19:54:48 <lambdabot> -- f cannot be realized.
19:54:49 <glguy> desp: or redo the way we handled it
19:54:52 <andyjgill> Best quote:
19:54:53 <glguy> desp: which isn't out of the question
19:54:55 <monochrom> @djinn-env
19:54:55 <lambdabot> data () = ()
19:54:55 <lambdabot> data Either a b = Left a | Right b
19:54:55 <lambdabot> data Maybe a = Nothing | Just a
19:54:55 <lambdabot> data Bool = False | True
19:54:55 <lambdabot> data Void
19:54:57 <lambdabot> type Not x = x -> Void
19:54:59 <lambdabot> class Eq a where (==) :: a -> a -> Bool
19:55:15 <desp> glguy: when was the binding project started?
19:55:26 <glguy> desp: before I started working at Galois
19:55:40 <desp> sorry, I have no idea when that was
19:55:41 <desp> :)
19:55:43 <andyjgill> SPJ: Any more questions? *: what is a monad? SPJ: "But its 10 past 5!"
19:55:49 <glguy> desp: that's a long way of saying "i don't know"
19:55:49 <dons> heh
19:55:55 <desp> heh
19:56:23 <andyjgill> (He had dinner the the guy to give a more compete answer)
19:56:42 <dons> so you'll let us know when the videos are online?
19:58:01 <monochrom> hahahaha
19:59:12 <monochrom> I'm more interested in the dinner.
20:00:10 <ddarius> @djinn Not (Either a b) -> (Not a, Not b)
20:00:10 <lambdabot> f a = (\ b -> a (Left b), \ c -> a (Right c))
20:00:40 <Cale> andyjgill: hehe
20:01:01 <Cale> andyjgill: I'm actually curious about how he'd answer that question. :)
20:01:05 <monochrom> I'm a moron.
20:01:11 <monochrom> Thanks ddarius.
20:01:16 <glguy>  ?remember monochrom I'm a moron.
20:01:28 <monochrom> Damn you. :)
20:01:34 <|Steve|> Added space.
20:01:35 <glguy> I left a space in front ;)
20:01:37 <kfish> falconair, http://www.cse.unsw.edu.au/~dons/binary.html
20:01:38 <lambdabot> Title: Data.Binary - efficient, pure binary serialisation for Haskell
20:01:38 <ddarius> ?quote monochrom
20:01:38 <lambdabot> monochrom says: recursive directory search is an alpha-beta with boring values of alpha and beta.
20:01:43 <monochrom> haha :)
20:01:46 <|Steve|> Heh
20:01:55 <falconair> kfish, thanks, I just opened that page :)
20:02:03 <lispy> monochrom: nice
20:02:40 <kfish> falconair, though, i think data.binary is more aimed at serializing existing haskell structures, not for interpreting existing binary formats
20:02:45 <lispy> monochrom: the normal use of alpha-beta being finding the next move in chess, right?
20:02:54 * Cale looks around to see if any OSCON 2007 videos are around yet.
20:03:03 <monochrom> Yeah.
20:03:08 <Cale> Anyone know where they're due to show up?
20:03:27 <diakopter> I don't know.  Not that I would.
20:03:32 <glguy> Cale: andyjgill just mentioned that he's working on it, and dons asked him to let us know when its ready
20:03:39 <Cale> ah, okay
20:03:55 <glguy> I sit close enough to him that if he mentions anything, I'll try to beat him to announcing it here ;)
20:04:28 <diakopter> does frown provide anything that happy can't provide?
20:05:09 <andyjgill> No, but I'll an-ounce it on the this group when we've transfered it. Its on digital video format right now.
20:06:13 <lispy> andyjgill: cool
20:06:19 <Cale> :)
20:08:46 <glguy> I'll make sure to announce the videos in /topic when they are ready
20:08:52 <glguy> and andy knows to nudge me
20:10:05 <Cale> diakopter: I think Frown is supposed to generate faster parsers than Happy.
20:10:18 <Cale> (apparently)
20:10:25 <ddarius> I think it's designed to be a drop-in replacement.
20:11:13 <Cale> I'm not sure if frown does GLR parsing though.
20:12:00 <Cale> Heh, "Tour de Frown"
20:15:38 <Olathe> desp: Are you on x86 ?
20:15:45 <desp> ppc
20:15:53 <desp> Olathe: can't replicate my results?
20:16:28 <Olathe> No, I got 3m30 or so for yours and 4m10 or something for edwardk.
20:16:48 <Olathe> I just had an old sort-of-JIT UM for x86.
20:16:59 <desp> ah
20:17:14 <desp> I wished to write something like that
20:17:18 <desp> but I'm lazy
20:20:54 <luqui> I've been playing with @djinn...
20:21:04 <luqui> what role does Maybe play in the curry-howard correspondence?
20:21:15 <luqui> I've got all the others figured out... :-/
20:21:51 <oerjan> @src Maybe
20:21:51 <lambdabot> data Maybe a = Nothing | Just a
20:22:14 <luqui> so it seems like it's just a "true" that takes an argument
20:23:07 <oerjan> (true) or (a)
20:23:14 <luqui> which is just true
20:23:26 <jfredett> is it possible to redefine how a constructor- constructs? eg
20:23:26 <jfredett> data Foo = Bar Foo | Baz Foo | Nil
20:23:26 <jfredett> Bar (Baz x) = x
20:23:29 <oerjan> logically, yes
20:23:34 <ddarius> Yep.  You can always prove Maybe a, Nothing.
20:23:39 <jfredett> err, with Bar (Baz x) = x
20:23:52 <ddarius> jfredett: No.
20:24:01 <jfredett> damn, hmm
20:24:07 <luqui> jfredett: what are you trying to do?
20:24:29 <jfredett> well, I guess I should have just used the integers, lol, dunno why I changed all the names...
20:24:39 <jfredett> I have a type: ZZ = S ZZ | Z | P ZZ
20:24:41 <oerjan> jfredett: i think that was a feature of Haskell's predecessor Miranda
20:24:59 <jfredett> oerjan: i see.
20:25:13 <oerjan> must have been semantically dubious, i guess
20:25:27 <jfredett> anyway- this type represents the integers, but its not canonical, that is P S P Z == P Z
20:25:43 <ddarius> oerjan: It was?
20:25:44 <oerjan> @wiki smart constructors
20:25:45 <lambdabot> http://www.haskell.org/haskellwiki/smart_constructors
20:25:47 <jfredett> can't have that- S and P are inverses,
20:25:56 <oerjan> @wiki smart goblins
20:25:56 <lambdabot> http://www.haskell.org/haskellwiki/smart_goblins
20:26:14 <jfredett> ... there are no smart goblins, sadly.
20:26:26 <ddarius> oerjan: There was definitely something about those on the old wiki (not under that name I don't think though)
20:26:30 <oerjan> ddarius: i recall seeing something with algebraic equations
20:26:34 <kpreid> jfredett: how about ZZ = S [()] | Z | P [()]?
20:26:50 <oerjan> @go site:haskell.org smart constructors
20:26:52 <lambdabot> http://www.haskell.org/haskellwiki/Smart_constructor
20:26:53 <lambdabot> Title: Smart constructors - HaskellWiki
20:27:21 <jfredett> kpreid: well, I'm aiming to have it look as much like the other data type I have, the Naturals(this is a post for my blog).
20:29:49 <andyjgill> Does any know how to add conditional code to haddock?
20:30:06 <luqui> jfredett: don't you need to do fancy fundep stuff in order to do that kind of arithmetic at compile time?
20:31:01 <dons> andyjgill: #if defined() ?
20:31:15 <dons> to rule out code from haddock's eyes?
20:31:18 <jfredett> luqui? for the naturals? not really- I haven't tried the integers yet
20:31:26 <oerjan> it may be it wasn't Miranda but one of the other ancestors.
20:31:27 <luqui> I mean for integers
20:31:45 <jfredett> luqui, I don't know- I guess I'll find out
20:31:46 <jfredett> :)
20:31:50 <luqui> :-p
20:31:53 <jfredett> my intuition says no
20:32:02 <jfredett> I will probably need smart constructors
20:32:10 <wli> Is there a way to get a primality constraint on type-level numerals?
20:32:12 <jfredett> but otherwise, I think it'll work
20:32:12 <luqui> you're getting awfully close to being turing complete with this stuff
20:32:21 <luqui> and IIRC base haskell w/o extensions is decidable
20:32:22 * desp <3 portage
20:32:23 <andyjgill> What is the #def for HADDOCK?
20:32:24 <luqui> so you won't get there...
20:32:25 <jfredett> luqui: the Type system is turing complete
20:32:33 <jfredett> last I looked
20:32:36 <luqui> it is?
20:32:48 <desp> scary
20:32:50 <jfredett> I think there was an implementation of SKI in the type system
20:33:00 <jfredett> @wiki SKI in the type system
20:33:01 <lambdabot> http://www.haskell.org/haskellwiki/SKI_in_the_type_system
20:33:10 <luqui> darn
20:33:10 <jfredett> that didn't do what I wanted
20:33:10 <wli> jfredett: An Oleg special IIRC.
20:33:11 <jfredett> :/
20:34:25 <wli> Okay, I guess given SKI et al it's of course possible to have primality constraints. I suppose what I need is a working example of such.
20:34:35 <ddarius> kpreid: ZZ = S (NonEmptyList ()) | Z | P (NonEmptyList ())
20:34:56 <kpreid> I was thinking of S [] == 1, actually
20:35:12 <ddarius> liqui: It is decidable without extensions.
20:35:12 * wli just hammered out a buttload of nonempty list code. I wonder if this has all been done before.
20:35:27 <oerjan> it was Miranda: "It is also possible to associate "laws"  with  the  constructors  of  an
20:35:30 <oerjan> algebraic  type,  which  are  applied  whenever an object of the type is
20:35:34 <oerjan> built."
20:35:38 <ddarius> wli: It definitely is possible.
20:35:58 <wli> ddarius: I have a sort of vague need for it.
20:36:10 <wli> Not a terribly strong one, mind you.
20:36:17 <dons> andyjgill: #ifndef __HADDOCK__
20:36:31 <jfredett> http://www.haskell.org/haskellwiki/Type_SK
20:36:32 <lambdabot> Title: Type SK - HaskellWiki
20:36:40 <ddarius> wli: It probably isn't worthwhile.  Perhaps you should pull out a dependently typed language?  The costs would be much lower then.
20:36:45 <jfredett> I think thats w/ extensions though
20:37:08 <oerjan> jfredett: i thought you would get the point after i did @wiki smart goblins :)
20:37:14 <ddarius> oerjan: I think I remember that too, now.  Where are you reading that by the way?
20:37:25 <jfredett> oerjan: I didn't, what was the point?
20:37:29 <jfredett> I'm confused
20:37:45 <oerjan> http://www.engin.umd.umich.edu/CIS/course.des/cis400/miranda/Overview.htm
20:37:47 <lambdabot> Title: An Overview of Miranda, http://tinyurl.com/25lhur
20:37:48 <wli> ddarius: I was vaguely hoping it might be possible without too extreme of pain atop Oleg's code, but I guess not.
20:38:20 <wli> (I was only really wanting to represent Z/pZ as types.)
20:38:22 <andyjgill> Thanks Dons.  This requires you to use ghc to call cpp, and I am using cabal
20:38:24 <ddarius> wli: It's not too bad, but there are "issues".
20:38:37 <oerjan> jfredett: that @wiki doesn't actually check the existence of any URL
20:38:39 <wli> ddarius: Oh dear. Dare I ask what sort?
20:38:44 <ddarius> Anyway, it would be much nicer in a dependently typed language.
20:38:58 <jfredett> yeh- I knew, somewhere, in my brain, that that was the case
20:39:04 <jfredett> it just didn't register.
20:39:26 <ddarius> wli: You have to reify and reflect the numbers between the type and term level which is not all that pretty and not good for performance.
20:39:52 <ddarius> And anyways, you have to implement numbers which is horrid for performance even if you don't just use Peano arithmetic.
20:40:15 <wli> ddarius: The plot was to use Oleg's decimal code.
20:40:16 <ddarius> (Admittedly, that's more a compile-time issue...)
20:40:43 <luqui> 30 minute compile times are worse than bad runtimes, imo
20:40:56 <luqui> that whole "optimize for developer efficiency" thing :-)
20:40:58 * wli doesn't mind compile time per se.
20:41:20 <ddarius> wli: Give it a go on something simpler and see how you like it and how it does you.  If it's okay, go for it.
20:42:16 <dons> andyjgill: yeah, you'd need to define extensions:      CPP
20:42:21 <wli> Well, it was going to be linear algebra over finite fields anyway, so...
20:43:48 <andyjgill> That works! Thanks. haddock was getting confused by template Haskell.
20:44:58 <wli> ddarius: I'm actually not entirely sure what you're on about because I don't notice what I've got thus far compiling slow at all.
20:46:23 <ddarius> wli: What magnitude numbers are you dealing with?  It shouldn't be a problem for small numbers.
20:46:35 <ddarius> (Also, space is probably a more significant issue.)
20:47:14 <wli> ddarius: Small ones in general. Single-digit primes for the most part.
20:49:30 <wli> (For the most part the interest is in GF(2^n), of course, though I'd sort of like it to work on GF(p^n) for other primes.)
21:04:45 <chessguy> i don't get this UM spec
21:05:06 <rt> which um spec?
21:05:12 <Olathe> chessguy: It takes a bit of deciphering.
21:05:16 <chessguy> http://www.boundvariable.org/um-spec.txt
21:05:32 * rt implemented that one last year.  I might be able to recall how it works.
21:05:32 <chessguy> i don't get how it interprets a string as a series of operators
21:05:44 <rt> uh... in what sense?
21:06:00 <Olathe> Each 32-bit segment is an operation.
21:06:26 <chessguy> but how does it map characters to bits?
21:06:56 <Olathe> Oh, the first character has the first eight bits, the second has the second eight bits, ...
21:06:57 <rt> you mean endian-wise?
21:07:10 <rt> if you get it wrong, you'll know. :-)
21:07:23 <chessguy> yeah, like what integer does 'a' represent?
21:07:34 <Olathe> 97.
21:07:57 <chessguy> why 97?
21:08:08 <oerjan> > ord 'a'
21:08:10 <lambdabot>  97
21:08:20 <Olathe> Well, if the 'a' is ASCII, it is 97.
21:08:24 <rt> that's just how ascii defines it.
21:08:36 <Olathe> The UM whatsit doesn't care about encoding, though.
21:08:53 <chessguy> Olathe, it has to, to interpret the characters as bit-strings
21:09:05 <Olathe> No, it just reads bytes directly from disk.
21:09:12 <chessguy> huh?
21:09:26 <Olathe> There will be a program file on disk.
21:09:34 <Olathe> It never gets interpreted as characters.
21:09:43 <Olathe> Just as a bitstring.
21:10:04 <Olathe> (unless you want to do it that way for some reason)
21:10:04 <chessguy> oh, the codex is in binary form already
21:10:07 <Olathe> Yep.
21:10:11 <rt> A 1x1 character resolution console capable of displaying glyphs
21:10:11 <rt>       from the "ASCII character set" (see patent #127) and performing
21:10:11 <rt>       input and output of "unsigned 8-bit characters" (see patent
21:10:11 <rt>       #255).
21:10:12 <rt> A 1x1 character resolution console capable of displaying glyphs
21:10:12 <rt>       from the "ASCII character set" (see patent #127) and performing
21:10:13 <chessguy> ohh
21:10:14 <rt>       input and output of "unsigned 8-bit characters" (see patent
21:10:16 <rt>       #255).
21:10:31 <rt> oops.  sorry.  cut and pasted.
21:10:36 <chessguy> rt, that's different
21:11:01 <rt> well, you seem to be confused, so it was hard to tell what your issue is.
21:11:24 <chessguy> i did say at the outset that i didn't get it :)
21:11:36 <chessguy> i didn't realize the codex was in binary already
21:11:46 <rt> the um file is already in a binary format, so no interpretation is necessary to use it.
21:11:52 <chessguy> i assumed it was a massive string
21:11:54 <chessguy> like endo
21:12:05 <rt> now ENDO is a weird machine.
21:12:27 <rt> took me only an hour to write my first um.  Still don't have a good vm for endo.
21:12:29 <desp> the Fuun.
21:13:08 <Olathe> rt: What did you write it in ?
21:13:15 <rt> i think this years programming contest is actually too much of a puzzle, and not enough programming.
21:13:29 <rt> C of course.  The proper choice for all discerning hackers!
21:13:37 <Olathe> Ahh.
21:13:45 <rt> :-)
21:13:51 * rt is still struggling with haskell.
21:14:03 <rt> Although the vm i'm actually using to play with endo is in Haskell.
21:14:45 <rt> i think now that I understand the whole red/green/blue zone thing a little better, i could make another stab at the vm for fuun.
21:15:20 <desp> rt: not enough programming? disassembler, debugger, assembler
21:15:31 <desp> rt: at least that's the way I see a "proper" solution
21:15:36 <rt> you have to do too much spelunking before you even get to that point.
21:15:43 <desp> that's what I'd do if I had a week ;p
21:15:45 <rt> it's more about decoding stuff without a spec than actually programming.
21:15:59 <desp> there's a name for that, reverse-engineering
21:16:00 <desp> :)
21:16:00 <wli> What's the line limit on hpaste.org?
21:16:32 <rt> reverse engineering and puzzle solving are useful skills, and probably part of any good programmer's toolkit, but they aren't always the most important skills.
21:16:45 <desp> sure
21:17:00 <desp> it sure does make for a fascinating puzzle, though
21:17:16 <rt> i'll agree.  It's a better puzzle, but a weaker contest.
21:17:43 <rt> like right now, I have no idea what I should acutally do to progress.
21:17:52 <desp> I definitely missed getting scored for progress last year
21:17:58 <desp> I mean, like last year
21:18:16 <desp> each hash discovered in the um was like a little nugget of joy ;p
21:18:19 <rt> last year, the problems were difficult, but defined.
21:18:38 <rt> hmm.
21:18:57 * rt realizes he hasn't analyzed the steganography page much.
21:19:43 <chessguy> what's the difference between a um and a umz file?
21:19:48 <Olathe> Nothing.
21:20:19 <Olathe> Actually...
21:20:22 <hpaste>  wli pasted "nonempty lists: done where before?" at http://hpaste.org/1894
21:20:39 <desp> actually, the umz is um-compressed?
21:20:42 <desp> don't remember
21:20:49 <Olathe> Concatenate a umz file to um.um to use it.
21:21:02 <Olathe> um.um is a UM interpreter written in UM.
21:21:05 <desp> er...
21:21:31 <chessguy> i think it's working to just run the umz file directly on the um
21:21:36 * rt wonders what utility he possesses that can scramble a color mapped png.
21:21:43 <Olathe> It does, it's just a little fun thing.
21:21:47 <chessguy> though this perl implementation is slow :)
21:22:06 <Olathe> Some people were running sandmark under several layers of um.um.
21:22:27 <desp> Olathe: oh yeah, did you read those postings on the ML about some law of interpreters?
21:22:31 <desp> very trippy
21:22:33 <Olathe> Heheh
21:22:41 <Olathe> Yeah.
21:22:44 <wli> What law of interpreters?
21:23:11 <Olathe> It was just some observation about the multiple of time it takes for each new layer of um.um.
21:23:14 <desp> "The "Eigenratio" of Self-Interpreters"
21:23:15 <Olathe> I don't think it was very general.
21:24:21 * chessguy begins to wonder if this decryption process is doing anything but burning RAM
21:24:24 <desp> http://lists.andrew.cmu.edu/pipermail/icfpcontest-discuss/Week-of-Mon-20060807/000730.html
21:24:27 <lambdabot> Title: [icfp-discuss] The "Eigenratio" of Self-Interpreters, http://tinyurl.com/229pxx
21:25:02 * wli actually knows enough in the way of numerical methods for special functions to hammer out code for things like the gamma function, zeta function, et al.
21:25:04 <desp> http://lists.andrew.cmu.edu/pipermail/icfpcontest-discuss/Week-of-Mon-20060814/000736.html
21:25:07 <lambdabot> Title: [icfp-discuss] The "Eigenratio" of Self-Interpreters, http://tinyurl.com/yrpoh8
21:26:35 <desp> funny stuff
21:27:15 <chessguy> how long should it take to decrypt the codex?
21:27:26 <Olathe> If anyone is implementing the UM on x86 linux and wants a challenge, beat the speed of http://olathe.tv/c/umj.c
21:27:29 <wli> I actually don't know/understand how to construct abstract machines for languages. For instance, how anyone arrived at the various ones for lazy functional languages is a total mystery to me.
21:27:34 <Olathe> chessguy: Less than a second.
21:27:47 <desp> Olathe: how long for sandmark?
21:27:56 <chessguy> oh there we go
21:27:59 <chessguy> it finally finished
21:28:03 <rt> hmmm.
21:28:04 <Olathe> desp: Not sure. I only have an x86 Windows and PPC linux machine.
21:28:07 * rt wonders how his compares.
21:28:13 <chessguy> i got a "LOADING:"
21:28:14 <desp> Olathe: heh
21:28:30 <desp> chessguy: use another implementation already ;p
21:28:35 <Olathe> It was faster than a standard C one I made, which gets the pretty close to the same speed as yours on ppc linux.
21:28:41 <pingu> ohgod. manually unrolled loops.
21:28:43 <Olathe> Not too much faster, though.
21:28:44 <chessguy> desp, i haven't gotten any others to work
21:28:55 <pingu> compilers people, they know how to do this shit!
21:29:05 <desp> chessguy: http://varsztat.com/um.c  gcc -O2 um.c -o um
21:30:34 <Olathe> I might have access to an x86 linux machine.
21:30:40 <chessguy> desp, ok, that's much better :)
21:31:02 <chessguy> now i got an "ok" prompt
21:32:15 <rt>  umj.c:811: warning: cast from pointer to integer of different size
21:32:40 <rt> ./umj sandmark.umz
21:32:45 <rt> Segmentation fault (core dumped)
21:32:50 <rt> I'd say mine is faster!
21:32:57 <rt> :-)
21:33:23 <Olathe> ;)
21:33:39 <Olathe> What processor do you have ?
21:33:42 <SamB_XP_> rt: um. you are clearly using the wrong architecture!
21:33:45 <rt> amd64
21:33:46 <chessguy> desp, whee, crash and burn!
21:33:50 <Olathe> It has to be IA32.
21:33:54 <desp> chessguy: ?
21:33:54 <SamB_XP_> try it on a proper 32-bit CPU
21:33:57 <rt> well, what good is that!
21:34:00 <rt> :-)
21:34:02 <hpaste>  wli annotated "primes - slow" with "faster primes" at http://hpaste.org/1885#a1
21:34:13 <Olathe> OK, I'm on an IA32 linux machine.
21:34:20 <chessguy> !paste
21:34:21 <hpaste> Haskell paste bin: http://hpaste.org/
21:34:33 <SamB_XP_> Olathe: mine (probably) works on 68k, ARM, PowerPC etc. too ;-)
21:34:41 <hpaste>  chessguy pasted "UM sesson" at http://hpaste.org/1895
21:34:54 <desp> chessguy: sigh
21:34:59 <SamB_XP_> rt: or should I say... compile it as 32-bit and grab the 32-bit libraries
21:35:00 <Olathe> I have one that works everywhere and one that's faster on IA32.
21:35:06 <rt> SANDmark complete.
21:35:06 <rt> 1261034283 cycles executed.
21:35:06 <rt> HALTED.
21:35:06 <rt> 98.374u 0.108s 1:41.25 97.2%    0+0k 0+0io 0pf+0w
21:35:12 <rt> that's mine.
21:35:18 <desp> chessguy: the p command dumps a binary file
21:35:28 <rt> it was fast enough, and had lots of nifty debugging stuff in it.
21:35:52 <rt> (I could break in, save the core file in a given state, and restart again later).
21:35:55 <chessguy> desp, but my only options were dump or exit...
21:36:17 <desp> chessguy: the p command, which you used, dumps a binary file
21:36:33 <Olathe> Here's my everywhere one: http://olathe.tv/c/icfp.c
21:36:58 <chessguy> desp, so i'm supposed to feed that binary file back to the UM?
21:37:24 <desp> chessguy: I suppose that's what "UM program" means
21:37:50 <rt> icfp.c:80: warning: cast to pointer from integer of different size
21:37:57 <rt> more of those pesky warnings!
21:38:03 <desp> rt: not in my code!
21:38:05 <desp> ;)
21:38:24 <rt> and it segfaults again.
21:38:31 * rt sighs.
21:38:39 <desp> rt: but you won't run my um on 64-bit
21:38:51 <chessguy> how the heck am i supposed to capture all this and save it?
21:38:53 <desp> rt: because of an optimization I used
21:39:10 <desp> chessguy: you know, solving puzzles?
21:39:14 <Olathe> Ahh, I think none of mine work on 64-bit.
21:39:22 * rt sighs.
21:39:40 <desp> chessguy: um.exe codex.umz > umix.umz
21:39:45 <chessguy> desp, oh, that's part of the puzzle?
21:39:49 <rt> I spent a few months porting half a million lines of code from a 32 bit machine to a 64 bit one, and that cured me of many bad habits.
21:40:40 <desp> rt: the reason my code is fast is that I'm using the actual pointer returned by malloc() as the platter identifier, which is defined in the spec to be 32-bit
21:40:48 <pingu> That would cure you of your sanity pretty quickly too.
21:41:13 <Olathe> rt: What does it say when you run after compiling with -DSAFE ?
21:41:47 * rt was going to do that, but it would make it difficult (well, more difficult) to dump and restore program states, so I actually have an extra indirection for each platter lookup.
21:41:53 <desp> rt: although that doesn't allow saving the UM state, which would come in handy
21:41:57 <desp> hah, exactly.
21:42:21 <desp> well, yeah, it would be possible
21:42:23 <rt> heh.  even more errors, and a coredump again.
21:42:25 <desp> just very annoying
21:42:28 <Olathe> Heheh
21:42:43 <chessguy> desp, woot!
21:42:44 <Olathe> I guess I should try porting it.
21:42:46 <chessguy> that worked
21:42:47 <rt> my stupid cat is making it difficult to type.
21:43:00 <chessguy> Welcome to Universal Machine IX (UMIX).
21:43:07 <desp> chessguy: woop
21:43:14 <desp> now the hard part
21:43:15 <rt> now the real work begins!
21:43:20 <chessguy> it won't let me log in as root :)
21:43:27 <desp> @stereo
21:43:27 <lambdabot> Unknown command, try @list
21:43:36 <desp> @botsmack
21:43:36 <lambdabot> :)
21:45:04 <chessguy> no way
21:45:12 <chessguy> i haven't seen BAS files in....15 years?
21:45:28 <Olathe> Heh
21:45:48 <SamB_XP_> chessguy: there's a twist
21:46:00 <chessguy> SamB_XP_, ?
21:46:03 <desp> heheh
21:46:06 <rt> FOR I = I TO X
21:46:06 <desp> that was evil
21:46:06 <SamB_XP_> chessguy: and of course you can't log in as root -- you haven't won yet, you doofus!
21:46:30 <SamB_XP_> why did the roman empire fall?
21:46:56 <chessguy> because it had a terrible numbering system?
21:47:09 * SamB_XP_ waits for the real punchline...
21:47:26 <desp> @google "why did the roman empire fall"
21:47:30 <lambdabot> http://www.fsmitha.com/com/Rome.htm
21:47:30 <lambdabot> Title: Why did the Roman Empire Fall?
21:47:47 <Pseudonym> Because they couldn't signal successful termination of Unix programs.
21:47:50 <Pseudonym> Not having a zero.
21:48:03 <desp> -.-'
21:48:04 <SamB_XP_> Pseudonym: it's supposed to go "C programs"
21:48:09 <SamB_XP_> not "unix programs"
21:48:11 <desp> N
21:48:27 <Pseudonym> Right.
21:48:30 <chessguy> are you guys still speaking english?
21:48:34 <Pseudonym> Was that an Alan Perlis quote?
21:48:41 <SamB_XP_> I don't know!
21:48:57 <wli> desp: That article is terrible.
21:48:57 <Pseudonym> Robert Firth
21:49:09 <desp> wli: and not funny in the least!
21:49:18 <desp> I am gravely disappointed
21:49:34 <Pseudonym> ?google "Robert Firth" roman zero
21:49:35 <lambdabot> http://thinkexist.com/quotes/robert_firth/
21:49:35 <lambdabot> Title: Robert Firth quotes
21:50:01 <desp> they had a zero
21:50:13 <desp> they just didn't feel like using it all the time
21:51:06 <SamB_XP_> desp: so... what's the qvickbasic for "mapM_ f [0..9]"?
21:51:19 <chessguy> qbasic: SYNTAX ERROR: EXPECTED  LINENVM STATEMENT
21:51:28 * chessguy giggles
21:51:47 <chessguy> qbasic never required line numbers though
21:51:53 <chessguy> AFAIR
21:52:18 <SamB_XP_> chessguy: yeah. but this isn't really qbasic
21:52:27 <chessguy> no, really?
21:52:32 <Olathe> I can't find the compiler options I used for umj.
21:52:36 <Olathe> Let me see.
21:52:36 <SamB_XP_> also isn't qbasic different from quickbasic
21:52:55 <chessguy> subtly
21:52:58 <Nafai> SamB_XP_: Yes.  quickbasic was their compiler
21:53:03 <SamB_XP_> see!
21:53:33 <SamB_XP_> the difference is that with qbasic you can *change* a program that has "return with gosub" errors
21:53:40 <SamB_XP_> s/with/without/
21:55:31 <chessguy> yeah, this could keep me busy for a while :)
21:55:31 <wli> jleedev: It's probably faster to split up the original list into even and odd halves.
21:55:37 <hpaste>  Olathe pasted "timings" at http://hpaste.org/1896
21:55:52 <desp> SamB_XP_: :D
21:56:02 <Olathe> It looks like the JIT thing is now slower.
21:56:28 <chessguy> this doesn't really seem like a real programming problem though
21:56:31 <SamB_XP_> chessguy: you will notice that there are two ways to do it
21:56:39 <SamB_XP_> the quick way and the long way
21:57:01 <desp> Olathe: what's the "icfp"?
21:57:05 <chessguy> so which should i choose? :)
21:57:08 <desp> oh, you did paste it
21:57:10 <Olathe> My platform independent one.
21:57:17 <SamB_XP_> well, you could go for the quick way for now at least
21:57:20 <Olathe> (except for IA64, it appears)
21:57:29 <chessguy> and what would that be?
21:57:33 <desp> damn, you beat ma :C
21:57:36 <desp> s/ma/me/
21:57:38 <hpaste>  tjm1983 annotated "mergesort" with "(no title)" at http://hpaste.org/1891#a2
21:57:49 <Olathe> On my PPC machine, yours and mine are neck and neck, though.
21:58:20 <SamB_XP_> chessguy: just get rid of the part that is supposed to check for passwords with digits after them
21:58:46 <chessguy> SamB_XP_, assuming i even know how to edit this thing :)
21:58:48 <hpaste>  Olathe annotated "timings" with "On ppc linux" at http://hpaste.org/1896#a1
21:58:54 <chessguy> anyway, i'll play with it this weekend
21:58:58 <chessguy> i'm going to be
21:58:58 <chessguy> d
21:59:12 <SamB_XP_> chessguy: you copy and paste it into emacs, duh
21:59:18 <chessguy> lol
21:59:27 <desp> interesting.
21:59:36 <chessguy> maybe umix has a built-in vimix :)
21:59:43 <Olathe> chessguy: Heheh
21:59:52 <SamB_XP_> you have to use that *modem program
22:00:02 <Olathe> Yeah, that thing is annoying.
22:00:13 <chessguy> does it make annoying screeching noises?
22:00:17 <SamB_XP_> no ;-)
22:00:19 <Olathe> Heheh, no.
22:00:26 <SamB_XP_> it's like xmodem and so on
22:00:32 <chessguy> well then how bad can it be?
22:00:50 <SamB_XP_> I just put the command at the beginning of my file, and the marker at the end
22:01:08 <chessguy> hmm?
22:01:09 <Olathe> It's a good idea to create the file in a normal editor, then paste it into the um.
22:01:32 <chessguy> wow, you actually have to paste the program to the command line?
22:01:39 <SamB_XP_> YES!
22:01:46 <SamB_XP_> unless you want to type it?
22:01:50 <chessguy> lol
22:02:17 <chessguy> well, this is going to make for a fun weekend
22:02:20 <chessguy> 'night
22:02:56 <SamB_XP_> 40. There are two ways to write error-free programs; only the third one works.
22:03:09 * SamB_XP_ found that on http://en.wikiquote.org/wiki/Alan_Perlis
22:03:11 <lambdabot> Title: Alan Perlis - Wikiquote
22:05:16 <hpaste>  tjm1983 annotated "I want an instance I can't have" with "(no title)" at http://hpaste.org/1892#a1
22:06:39 <Binkley> tjm1983: you can't declare that a type synonym is an instance of a class
22:06:47 <Binkley> you have to declare it using newtype instead
22:07:03 <doublef> :t (>>>)
22:07:05 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
22:07:22 <desp> got types?
22:07:50 <glguy> yarg
22:07:53 <glguy> @yarr
22:07:53 <lambdabot> Well me 'earties, let's see what crawled out of the bung hole...
22:09:39 <blackdog> dons: around? am having trouble building X11 on openBSD - configure keeps wanting to chuck in an -R flag in X_LIBS... any ideas?
22:10:28 <SamB_XP_> heh
22:10:33 <SamB_XP_> 100. We will never run out of things to program as long as there is a single program around.
22:11:41 <wli> Hmm, is there a nicer way to do splitParity [] = ([],[]) ; splitParity (x:xs) = let (us, vs) = splitParity' xs in (x:us, vs) ; splitParity' [] = ([],[]) ; splitParity' (y:ys) = let (us, vs) = splitParity ys in (us, y:vs) ?
22:12:47 <dons> blackdog: yeah, check the xmonad.org faq page. you hvae to add a path to /usr/X11R6/ . or you can edit the .bulidinfo file manually
22:13:01 <rt> huh.
22:13:08 <rt> 9546 isn't a page?
22:13:52 <desp> "checking stack growing direction... -1"
22:13:55 <desp> cute
22:14:08 <SamB_XP_> rt: indeed. it isn't.
22:14:13 <SamB_XP_> I have no idea what it is !
22:14:31 <SamB_XP_> did you find it or did you overhear me talking about it?
22:14:39 <desp> looks like a number to me
22:14:43 <desp> ;)
22:14:54 <rt> I found it.
22:14:56 <SamB_XP_> yes but what for
22:15:00 <desp> why do you suppose it should be a page?
22:15:10 <rt> because all other numbers are!
22:15:24 <desp> I mean, is it on the page list?
22:15:52 <desp> where did you get it from?
22:16:09 <rt> hmmm.
22:17:15 <Nafai> Any gtk2hs users/devs around?
22:18:11 <Nafai> What does this mean?
22:18:20 <Nafai>    Warning: Deprecated use of `I.onActivate'
22:18:21 <Nafai>              (imported from Graphics.UI.Gtk.Display.StatusIcon):
22:18:21 <Nafai>              instead of 'onActivate obj' use 'on obj activate'
22:18:31 <blackdog> dons: i don't think that's the problem. it's not that it can't find a library, it's that -R/usr/X11R6/lib is being passed to ghc, which doesn't understand it. could it be an autoconf problem?
22:21:19 <wli> cycle (first . (:)) (second . (:)) is involved somehow.
22:21:46 <wli> urgh
22:21:56 <wli> cycle [first . (:), second . (:)] is involved somehow.
22:25:00 <blackdog> ah, there we go. brute force, bloody ignorance and configure script hacking :) never fails.
22:28:11 <wli> \xs -> foldr (.) id (zipWith ($) (cycle [first . (:), second . (:)]) xs) ([], [])
22:31:27 <Nafai> Bleh
22:34:19 <Nafai> I have no idea what that means :(
22:34:42 * wli settles on splitParity = flip (foldr (.) id) ([], []) . zipWith ($) (cycle [first . (:), second . (:)])
22:34:57 <desp> Nafai: it means you're using an outdated method of doing something
22:35:13 <desp> it's okay for now, but it may be removed in the future
22:35:38 <hpaste>  wli annotated "mergesort" with "maybe nicer version" at http://hpaste.org/1891#a3
22:35:50 <Nafai> desp: Obviously, but I'm trying to figure out what the new way is
22:36:12 <desp> Nafai: 'on obj activate'?
22:37:39 <Nafai> When I try that GHC says on is not in scope; sorry, learning Haskell here too
22:57:14 <Cale> Nafai: Gtk2Hs documentation says that 'on' is defined in System.Glib.Signale
22:57:20 <Cale> System.Glib.Signals
22:57:48 <Cale> However, strangely the Haddock for that module doesn't list it.
22:59:17 <Cale> (So try importing it anyway)
22:59:39 <Nafai> Yay, that did it
23:04:05 <hpaste>  tjm1983 annotated "mergesort" with "(no title)" at http://hpaste.org/1891#a4
23:04:28 <Nafai> Sadly, I don't understand the code I got working :(
23:05:26 <Binkley> tjm1983: heh, I ran into a bug almost exactly like that in work code once
23:05:30 <Binkley> took days to track down
23:06:13 <Nafai> I'm trying to understand these two lines, forgive my newness to this:
23:06:21 <Nafai>   on icon activate $ do
23:06:23 <Nafai>                putStrLn "Icon Clicked!"
23:06:39 <Nafai> The 3rd thing on takes is a callback
23:06:58 <Nafai> Does $ and the do create one?
23:07:38 <lucca> a $ b c is something like a (b c), but with less parens
23:13:21 <Nafai> How would you re-write that with parens then?
23:14:16 <Binkley> Nafai: on icon activate (putStrLn "Icon Clicked!")
23:14:20 <Binkley> btw, the "do" is unnecessary there
23:14:25 <Binkley> since you only have a single statement inside it
23:15:58 * Nafai nods
23:17:43 <desp> has anyone used the Haskell OpenGL package on Mac OS X?
23:19:27 <vincenz> Hello Binkley, been a while, how's life.
23:21:39 <Binkley> vincenz: it's ok. today I spent a lot of time thinking up to this haskell-cafe reply I posted that I'm sure no one read :-)
23:21:44 <Binkley> because it was more fun than research
23:23:29 <vincenz> What are you researching?
23:23:50 <Binkley> I'm trying to do performance benchmarking for House
23:24:01 <Binkley> which is cool in principle, it's just that omfg I'm so not a systems programmer
23:24:46 * vincenz nods
23:26:01 <vincenz> whom did you participate with for the competition?
23:26:17 <Binkley> some other people from PSU
23:26:28 <Binkley> One of whom is on IRC sometimes, I guess, but I don't know under what username
23:26:44 <vincenz> Spiffy, I guess being colo'd makes life much easier.
23:26:53 <Binkley> yeah, much easier
23:38:47 <desp> why one would use arrows?
23:38:47 <Pupeno> I have a QuickCheck generator that return Gen [Char], and I want to make a function that using the original function, also gives back Gen ByteString by processing the [Char]. Any tips on how to do it?
23:39:10 <Binkley> desp: this tutorial has some examples: http://www.cs.chalmers.se/~rjmh/afp-arrows.pdf
23:39:16 <Binkley> not that I grok arrows
23:39:33 <Cale> desp: Well, one problem with monads is that because functions in Haskell are completely opaque, >>= can do nothing with its right parameter to optimise or control the computation being performed.
23:40:02 <Cale> With arrows, you use >>> for a similar kind of control, and its type is a b c -> a c d -> a b d
23:40:43 <Cale> So both its parameters are data and can potentially be further inspected.
23:40:55 <desp> hmm.
23:42:57 * desp is reading the tutorial
23:43:11 <Cale> Also, sometimes arrows just fit better with the kinds of computation you're likely to be doing with the library
23:43:33 <Cale> HXT is like that -- it's an arrow library which could be a monad, but arrows usually look nicer for the sorts of things you write.
23:44:54 <desp> "instance Arrow (->) where ..." !?
23:45:08 <desp> (->) is the function type?
23:45:38 <Cale> yeah
23:46:39 <desp> good to know
23:46:41 <Cale> In general, arrows are things which are "kind of like functions".
23:58:32 <hpaste>  wli annotated "mergesort" with "sorry about that" at http://hpaste.org/1891#a5
