00:02:26 <opqdonut> wli: are you sure that that splitParity is necessary?
00:04:45 <wli> opqdonut: Oh, it's just nicer than splitAt (length xs `div` 2)
00:05:19 <opqdonut> yeah and more efficient
00:05:26 <opqdonut> but it seems awfully ugly
00:05:38 <wli> Well, I found it nicer.
00:05:55 <opqdonut> yeah it's definitely better than splitAt
00:05:58 <wli> (Otherwise I'd not have bothered.)
00:06:10 <opqdonut> i was just thinking about an even nicer solution :)
00:06:19 <wli> opqdonut: Do tell.
00:06:29 <opqdonut> still thinking :)
00:06:59 <wli> opqdonut: Anything like (left, right) = flip (foldr (.) id) ([], []) . zipWith ($) (cycle [first . (:), second . (:)]) $ xs?
00:07:39 <opqdonut> hehe
00:07:42 <kfish> w00t, my lab presentation just turned into a Haskell evangelism fest
00:07:44 <wli> Because I've already been there and decided in favor of clarity.
00:07:56 <opqdonut> more like \a:b:xs -> ....
00:08:07 <opqdonut> but yeah, it is an interesting problem
00:09:07 <wli> I'm wondering if anyone's bothered cooking up anything like a nonempty list library.
00:10:16 <wli> Basically because hammering out one by hand is tedious.
00:10:29 <Binkley> wli: well, there's Data.Straem
00:10:31 <Binkley> Stream, even
00:10:53 <opqdonut> > partition fst $ zip (cycle [False,True]) [1,2,3,4,5,6]
00:10:55 <lambdabot>  ([(True,2),(True,4),(True,6)],[(False,1),(False,3),(False,5)])
00:11:04 <opqdonut> that starts to get ugly too...
00:13:14 <wli> opqdonut: (map snd *** map snd) . partition fst . zip (cycle [False, True])
00:13:47 <opqdonut> yeah
00:14:05 <opqdonut> but i'm still feeling that isn't the best solution
00:14:12 <opqdonut> but it's nice and point-free anyways
00:14:41 <wli> opqdonut: join (***) (map snd) . partition fst . zip (cycle [False, True]) ?
00:14:42 <hpaste>  tjm1983 annotated "mergesort" with "(no title)" at http://hpaste.org/1891#a6
00:15:09 <opqdonut> ugh, join on (->)
00:15:25 <opqdonut> but yeah, starting to go too deep into aesthetics :)
00:15:31 <opqdonut> wli: do you prefer that one?
00:15:48 <wli> opqdonut: writing map snd twice looks stupid so yeah
00:16:32 <opqdonut> yeah i meant the prefer the pointfree version to the splitParity one?
00:16:52 <wli> opqdonut: partition is kind of un-lazy, so I'm not entirely sure
00:17:05 <opqdonut> is it?
00:17:09 <Binkley> by "un-lazy" do you mean "strict"? :-)
00:17:21 <opqdonut> it's a shame the prelude doesn't include asymptotic time constraints
00:17:33 <wli> What I came up with for pointfree was:
00:17:35 <wli> flip (foldr (.) id) ([], []) . zipWith ($) (cycle [first . (:), second . (:)])
00:17:47 <opqdonut> well i guess that's worse
00:20:27 <wli> join (***) (take 5) $ join (***) (map snd) . partition fst . zip (cycle [True, False]) $ [1..] Actually terminates.
00:20:53 <wli> (If you can't tell, join (***) is my new best friend.)
00:21:59 <opqdonut> :)
00:25:41 <norpan> wli: you should get out more :)
00:26:02 <wli> You're telling me.
00:26:42 <mornfall> wli: he is...
00:27:06 <Binkley> you got told!
00:30:00 <wli> Trite.
01:05:51 * wli starts to get the hang of monadic interpreters.
01:08:03 <wli> They're all basically the same monad.
01:22:56 <roconnor> ``And since our DNA-to-RNA translator was still so slow, they needed to set up as many machines as possible to do it during the party. So jes5199 rented about 20 more Amazon "supercomputers" and set them all to running Endo's functions.
01:22:57 <roconnor> *L*
01:23:10 <opqdonut> :D
01:23:23 <vincenz> roconnor: where is that from?
01:25:50 <roconnor> http://stereotype441.livejournal.com/45150.html
01:25:51 <pierre-> :-)
01:27:25 <kosmikus> :)
01:28:21 <bartw_> thats pretty fun
01:28:27 <bartw_> but was it usefull ?
01:28:50 <roconnor> what do you mean?
01:29:09 <bartw_> well did they actually make use of this extra computing ?
01:29:16 <roconnor> yes
01:29:19 <roconnor> oh
01:29:21 <roconnor> I think so
01:29:25 <bartw_> they also hint that these machines weren't exactly fast
01:29:37 <roconnor> I got the impression that they didn't find the entire gene list
01:29:45 <roconnor> so they wouldn't have found the pear tree otherwise.
01:32:16 * roconnor didn't notice the apple tree and pear tree had the same code size :(
01:32:50 <bartw_> i never got that far
01:33:18 <bartw_> by the time i got the 1337 page it was monday night ;)
01:33:47 <bartw_> got i nice case of rsi now because of icfp :(
01:35:35 <dons> there'll be no lambdabot for a couple of days
01:35:41 <dons> do we have a replacement ready?
01:35:42 <vincenz> want oasisbot?
01:35:48 <vincenz> @join #oasis
01:36:04 <bartw_> whats up with lambdabot ?
01:36:08 <dons> yeah. the full power out, substation repair, at unsw. so no email for me for a couple of days either.
01:36:10 <bartw_> time for its vacation ? :)
01:36:13 <dons> yep
01:37:22 <roconnor> dons: my current ropes implemenation is 1.5x to 2x slower that just Seq Word8, ... but it consumes less than one tenth of the memory.
01:37:24 <earthy> whoa. full power out?
01:37:40 <bartw_> hmz, no redundancy in their power suppliers ?
01:37:43 <roconnor> (preforming on the endo benchmark)
01:37:56 <dons> earthy: just for the department. there was a power failure last weekend, and this weekend they're fixing it
01:38:01 <earthy> ah
01:38:01 <blackdog> dons: that's what nicta's for, right? hidden underground bunkers, secret nuclear reactors, that sort of thing?
01:38:12 <dons> yeah. i should get a nicta machine. but then they'd own me
01:38:18 <dons> and my first born for 7 generations
01:38:24 <earthy> ofcourse, I was used to the powersituation at Nijmegen University
01:38:26 <blackdog> yeah.
01:38:32 <blackdog> i guess sean figures he's not having kids :)
01:38:38 <dons> see seafood for example. sold to the devil
01:38:46 <blackdog> oh, don't say his handle
01:38:51 <bartw_> roconnor : could you make a write up of how your rope would work ? i'm thinking about writing an collections class with a rope backing for c#, would help for some array datastructures with random inserts
01:38:55 <earthy> they are very well connected to the grid, given that they can suck the Nijmegen powerstation empty with their magnets
01:38:58 <blackdog> growl will notice it and he'll come give me crap about paying him out :)
01:39:00 <seafoodX> NICTA is the devil?
01:39:04 <blackdog> crap
01:39:29 <dons> heh
01:39:32 <roconnor> bartw_:
01:39:32 <roconnor> newtype Chunk = Chunk { unChunk :: B.ByteString}
01:39:32 <roconnor> newtype RopeWith a = Rope
01:39:32 <roconnor>                    { chunks :: F.FingerTree (Sum Int64) Chunk }
01:39:42 <dons> hmm. how big are the chunks?
01:39:51 <dons> how large is the data you're testing on?
01:40:00 <earthy> dons: 7MB, he just said
01:40:05 <roconnor> instance ChunkSize DefaultSize where
01:40:05 <roconnor>  chunkSize _ = 1024
01:40:05 <roconnor> type ByteString = RopeWith DefaultSize
01:40:07 <dons> it should start to win wrt. Word8 pretty early. seems surprising
01:40:40 <roconnor> I think my code just needs a bit of optimizing.
01:40:42 <dons> 1024 seems a bit small.
01:40:59 <roconnor> dons: I sort of agree
01:41:03 <dons> we usually use 32k, but between half and 95% of your L2 cache is best
01:41:14 <dons> yeah, probably just needs some optimising
01:41:27 <roconnor> roconnor: there is currently a bit of a problem consing single words
01:41:29 <roconnor> er
01:41:37 * roconnor is talking to himself
01:41:39 <dons> you'd need to coalesce anyway, i guess
01:41:59 <blackdog> dons: if i have a StackSet, how do i extract the currently visible workspace out of it?
01:42:09 <roconnor> each time do you a cons, you do a memcopy  if the first chunk has size less than 1024
01:42:12 <dons> use 'current' iirc
01:42:26 <dons> you haxoring xmonad now?
01:42:33 <blackdog> sorta
01:42:33 <roconnor> so basically that's a mem copy 1023 out of every 1024 cons's
01:42:41 <blackdog> i just wanted a "next workspace" command
01:43:01 <dons> roconnor: right. so there's some heuristic there
01:43:10 <dons> we coalesced under 16 chars, iirc, in lazy bytestrings
01:43:16 <dons> not sure how we arrived at that figure though
01:43:23 <dons> blackdog: oh, someone wrote one of those
01:43:26 <dons> in the contrib repo
01:43:29 <dons> droundy, iirc
01:43:35 <roconnor> dons: so in that case 16 would be the analogous number I should use.
01:43:44 <blackdog> oh, ok.
01:43:58 <dons> roconnor: i think you'l need some experimental data on the various magic values
01:44:04 <roconnor> Ropes aren't lazy so chunks means something a bit different
01:44:10 <dons> yeah
01:44:12 <roconnor> perhaps chunks is a bad word.
01:44:21 <roconnor> I'll change it if I think of something better.
01:45:54 <dons> ?users
01:45:54 <oasisbot> Maximum users seen in #haskell: 413, currently: 413 (100.0%), active: 7 (1.7%)
01:46:00 <dons> hmm? oasisbot ?
01:46:01 <roconnor> ideally I'd create a 1024K buffer
01:46:11 <roconnor> and then fill it up when consing.
01:46:17 <roconnor> er
01:46:20 <roconnor> 1K buffer
01:46:37 <dons> oh hmm. so yes, a Builder (what Data.Binary does for this)
01:46:50 <dons> that's a bit more complicated hmm.
01:47:03 <roconnor> quite a bit more complicated.
01:47:32 <roconnor> Of course I could leave it upto the user to buffer the consing
01:47:35 <dons> there'd be a paper in a good purely functional data structure for this :)
01:47:53 <seafoodX> dons: Agreed!
01:47:59 <seafoodX> dons: I was meaning to talk to you about it actually.
01:48:05 <seafoodX> But looks like roconner is working on it.
01:48:16 <dons> oh, yes? how'd you get by in ocaml for icfp?
01:48:46 <dons> did you use ropes or lists of chunks or something?
01:48:48 <seafoodX> Not so well. It's only partially a problem with OCaml though.
01:49:11 <seafoodX> OCaml's libraries aren't *that* extensive and they have all sorts of annoying restrictions.
01:49:12 <roconnor> seafoodX: don't let the fact that I'm working on it stop you. ... I don't really know what I'm doing.
01:49:36 <dons> yeah, if i get time during the hackathon, i wouldn't mind rolling one of these.
01:49:41 <seafoodX> roconnor: Well, I was hoping that some of the work dons did on Data.Bytestring could be reused.
01:49:44 <dons> we should have one standard, fast ropes type though
01:50:06 <dons> a Data.ByteString.Rope makes sense for seekable strings, as dcoutts has pointed out
01:50:19 <roconnor> dons: of course.  We should all make ropes implemenations, and merge all the best ideas into one super implemenation.
01:50:38 <seafoodX> roconnor: Are you using that paper that was referenced on the icfp discuss list?
01:50:50 <seafoodX> Also, it's going to be a while until I have enough time....
01:50:56 <roconnor> seafoodX: I'm not using anypaper
01:51:16 <roconnor> FingerTree of ByteStrings ... how hard can it be :)
01:52:00 <roconnor> I looked at the paper (from Sun or wherever), to get an idea of what ropes were.
01:52:22 <roconnor> but all I got out of it was that it was a balanced tree of strings with fast access to the front.
01:52:22 <seafoodX> Cool.
01:52:25 <vincenz> ropes are more suited for eager languags
01:52:34 <vincenz> fingertrees for lazy ones
01:52:37 <vincenz> s/eager/non-pure
01:52:50 <roconnor> FingerTrees give me fast access to the front and back.
01:53:04 <dcoutts> Cale: ah yes, on/after are not yet documented
01:57:45 <masak> where's lambdabot?
01:58:35 <|Steve|> @seen lambdabot
01:58:35 <oasisbot> lambdabot is in #oasis and #haskell. I last heard lambdabot speak 3d 22h 1m 51s ago.
01:58:47 <dcoutts> Nafai: we're kind of in a transitional stage with respect to the signals api, so don't worry about those deprecation messages just yet.
01:59:09 <masak> |Steve|: how do I invite lambdabot to a channel?
01:59:21 <|Steve|> I haven't the slightest clue.
01:59:47 <dons> masak: you ask me :) but lambdabot at the moment is down, due to power shutdowns
01:59:57 <masak> dons: oh
01:59:59 <dons> on sunday, remind me which channel, and i'll have it join
02:00:20 <masak> dons: great. I will
02:02:46 <glguy> lambdabot isn't maxed out at 21 channels?
02:06:38 <blackdog> dons: was it an executive decision to hardcode the number of workspaces?
02:06:41 <blackdog> or am i missing something?
02:08:48 <dons> hard to index above 9
02:08:58 <dons> its not hardcoded though, tweak Config.hs
02:09:10 <dons> --
02:09:10 <dons> -- The number of workspaces (virtual screens, or window groups)
02:09:10 <dons> --
02:09:10 <dons> workspaces :: Int
02:09:10 <dons> workspaces = 9
02:09:33 <dons> edit that, hit mod-q, happy happy
02:10:55 <glguy> its a shame that you have to recompile to reload the settings
02:11:00 <glguy> seems like you could hs-plugins it
02:11:10 <glguy> (even though that would introduce another unnecessary dependency)
02:11:36 <dons> unec. dependency, yep.
02:11:45 <dons> we want to stay light and agile and extreme
02:12:04 <dons> with our scrum methodologies and slippery dip iterations
02:12:07 <blackdog> dons: yeah, i saw that
02:12:25 <blackdog> but it'd be nice to be able to create and destroy workspaces on the fly
02:12:58 <dons> they sort of are though: an empty workspace is a Nothing
02:13:01 <blackdog> i tend to visualise my workspaces spatially
02:13:18 <blackdog> so i think about it as moving left and right through them
02:13:21 <dons> you might want to use the dzen status bar trick that shows workspaces?
02:13:43 <dons> have you seen that ? I use it all the time. it draws in the status bar:   1 [2] 3
02:13:45 <blackdog> i guess i could change my switch left/right code to ignore empty workspaces
02:13:52 <dons> showing which workspace is current, and which have clients
02:14:02 <dons> its enough to make it feel like workspaces are `created' dynamically
02:14:21 <kosmikus> dons: now that the contest is over, I decided that it's finally a good time to switch to xmonad. should I use the released 0.2 or current darcs?
02:14:32 <dons> i'd go with the darcs version, kosmikus
02:14:38 <dons> its a bit more stable, and supports the floating layer
02:14:45 <dons> its unlikely to change significatnly before 0.3 is tagged
02:14:49 <kosmikus> ok
02:15:03 <blackdog> is it building at the moment?
02:15:13 <blackdog> i got "No instance for (Read Rectangle)"
02:15:24 <glguy> blackdog: your x11-extras was out of date
02:15:24 <dons> you'll need to update your X11-extras repo
02:15:56 <glguy> seems like that change should have bumped the version of x11-extras
02:16:03 <dons> blackdog: here's an extension for how to display visiable workspaces in the status bar, http://darcs.haskell.org/~sjanssen/XMonadContrib/DynamicLog.hs
02:16:05 <glguy> and that should be reflected in the cabal file
02:16:14 <dons> just stick that in your Config.hs logHook, and pipe xmonad into dzen
02:16:22 <dons> glguy: hmm yes.
02:16:33 <dons> we didn't stick hard to bumping versions when the api changes, but we should
02:16:52 <dons> libc.so.34.1 :)
02:18:23 <blackdog> dons: you need the darcs version of x11-extras?
02:18:27 <dons> yep.
02:18:30 <dons> ?where x11-extras
02:18:31 <oasisbot> I know nothing about x11-extras.
02:18:39 <dons> darcs.haskell.org/~sjanssen/
02:18:44 <dons> ?users
02:18:44 <oasisbot> Maximum users seen in #haskell: 416, currently: 413 (99.3%), active: 8 (1.9%)
02:18:51 <dons> i wonder why its screwed up. hmm
02:19:01 <dons> vincenz: what have you done to the poor bot? :)
02:19:02 <|Steve|> Heh.
02:19:14 <|Steve|> Maybe 332 = 413 now.
02:19:28 <dons> the normal lambdabot gets the number right.
02:19:56 <|Steve|> Actually, if 332 = 413, then we're in a lot of trouble since 0 = 1.
02:21:46 <vincenz> dons: hmm?
02:22:43 <dons> vincenz: the user count is wildly wrong. are you running a modified @seen ? or anything unusual?
02:23:27 <vincenz> no
02:23:30 <vincenz> nothing unusal
02:23:51 <dons> @seen oasisbot
02:23:51 <oasisbot> Yes, I'm here. I'm in #oasis, #haskell, #haskell_ru, #lazybottoms-dev and #lazybottoms
02:24:01 <dons> weird
02:27:18 <dons> @join #xmonad
02:27:18 <oasisbot> Not enough privileges
02:27:32 <dons> after all i've done for you!
02:29:18 <EvilTerran> ... **eastenders theme**
02:33:10 <vincenz> @join xmonad
02:33:19 <vincenz> @join #xmonad
02:33:40 <roconnor> so much for my stock market gains this year...
02:34:01 <blackdog> hey, dmenu is pretty cool. like a tiny quicksilver :)
02:34:55 <blackdog> hey, dmenu is pretty cool. like a tiny quicksilver :)
02:35:24 <blackdog> *sigh* like i just said. sorry. dumbass.
02:36:26 <EvilTerran> @bot
02:36:27 <oasisbot> :)
02:37:31 <vincenz> dons: I almost went the wrong waay, I could've been a lisp-weenie
02:38:12 <vincenz> dons: http://groups.google.com/group/comp.lang.lisp/msg/a919d512761b21de
02:38:13 <oasisbot> Title: Wanted! - comp.lang.lisp | Google Groups, http://tinyurl.com/2hez25
02:39:20 <EvilTerran> can other people view pages on http://www.cse.unsw.edu.au ?
02:39:46 <vincenz> EvilTerran: no, dons said their site's down, power-issues
02:39:52 <EvilTerran> ah. okay.
02:43:58 <roconnor> @go KMP Haskell
02:43:59 <oasisbot> http://twan.home.fmf.nl/blog/haskell
02:43:59 <oasisbot> Title: 21 thoughts
02:47:32 <roconnor> this doesn't look like how I remember the KMP algorithm working.
02:47:35 * roconnor reads on
02:48:18 <dons> vincenz: hah
02:48:31 <roconnor> I thought KMP was supposed to check the last character in the needle first.
02:57:58 <roconnor> I'm not quite convinced that this KMP algorithm in the blog post really works in O(n+m) time.
02:58:13 <roconnor> but then again, tying the knot is pretty confusing to reason about.
02:58:51 <roconnor> and it's totally not how I remember how KMP works.
02:59:22 <olsner> isn't that KMP type also a Stream type?
03:00:11 <roconnor> OMG, the KMP algorithm isn't what I remember. :(
03:00:39 <roconnor> olsner: looks like lists to me
03:00:51 <roconnor> oh wait
03:00:54 <roconnor> there is a bool at the end.
03:01:20 <roconnor> and it is a product
03:01:30 <roconnor> okay, I'm dumb.
03:02:01 <roconnor> ... But wouldn't it be faster to check the back of the string first?
03:02:02 <Saizan> as i see it KMP is like building a DFA that matches .*needle.* on the fly
03:02:27 <olsner> the KMP is simply a state in a DFA, with a next function and a boolean for indicating a final state
03:03:45 <swiert> @seen kosmikus
03:03:45 <oasisbot> kosmikus is in #xmonad, #oasis and #haskell. I last heard kosmikus speak 48m 56s ago.
03:04:21 <olsner> so the magic in KMP is to produce a DFA that's special somehow... but shouldn't all DFA's for the .*needle.* be equivalent such that in the end, all substring matching algorithms reduce to optimizing the same automaton?
03:06:42 <kosmikus> swiert: I'm here
03:07:11 <Saizan> the magic is that it's a DFA i think so it's linear in the input string
03:07:58 <roconnor> Ah, I was thinking of the Boyer-Moore algorithm
03:08:14 <roconnor> I should implement that.
03:08:22 <roconnor> http://en.wikipedia.org/wiki/Boyer-Moore_string_search_algorithm
03:08:23 <oasisbot> Title: Boyer–Moore string search algorithm - Wikipedia, the free encyclopedia
03:09:55 <quicksilver> @type (>>>)
03:09:56 <oasisbot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
03:16:16 <mattam> What's a "print name" ? Is it just a full name ?
03:17:39 <nominolo> a name in capital letters i think
03:33:30 <desp> arg
03:33:46 <desp> I can't get darcs send to work
03:34:04 <desp> it tries to use sendmail, which I don't use
03:34:36 <xerox> I usually do darcs send -o /tmp foo.patch and mail it.
03:34:41 <opqdonut> sendmail is a command practically all MTAs offer for queing sent mail
03:34:43 <desp> ahh, -o.
03:41:03 <xpika> how can i dump an xml document to a tree of strings?
03:41:17 <xerox> xpika: check out HXT
03:41:43 <|Steve|> You mean parse an xml document?
03:42:18 <xpika> |Steve|: a generic one
03:42:54 <|Steve|> Generally one dumps to a flat file, not a data structure.
03:43:23 <|Steve|> I'm not sure how "a generic one" was supposed to answer my question to you though.
03:43:31 <xpika> |Steve|: would parse be better terminology?
03:43:41 <|Steve|> If that's what you're trying to do.
03:43:48 <|Steve|> Which is what I was attempting to ascertain.
03:44:30 <|Steve|> *shrug* xerox gave you a pointer anyway, so I guess it's moot.
03:45:20 <xpika> lol
03:48:39 <xpika> which library does http-any refer to/
03:49:47 <xerox> xpika: http://haskell.org/http or check out hackage
03:49:48 <oasisbot> Title: Haskell HTTP package
03:49:56 <dcoutts> @seen done
03:49:56 <oasisbot> I haven't seen done.
03:49:57 <dcoutts> @seen dons
03:49:57 <oasisbot> I saw dons leaving #xmonad and #haskell 51m 7s ago, and .
03:49:59 <dcoutts> doh
03:50:27 <|Steve|> Is there a plan to provide a more comprehensive set of libraries with Haskell'?
03:51:15 <|Steve|> Say what you want about java (and I frequently do), but it has a nice standard library.
03:53:44 <wli> |Steve|: What do you think is missing?
03:54:25 <|Steve|> Well, the answers about xml and url access made it sound like you had to get a separate package for that.
03:55:03 * wli knows nothing of such things.
03:57:27 <xpika> hxt is big -.-
03:57:40 <xpika> Compiling [10 of 119]
03:58:02 <opqdonut> ^_^
03:58:09 <xpika> there should be a yum like package repo for hackage-db
03:58:54 <JKnecht> yum doesn't go that deep into hs
03:59:04 <xpika> JKnecht: indeed
03:59:31 <|Steve|> What is the difference between List.hi, GHC/List.hi and Data/List.hi?
04:00:10 <dcoutts> |Steve|: they're for different modules
04:00:26 <|Steve|> Also languages with their own package management systems like perl's don't seem to work well with distros' package management systems.
04:00:33 <dcoutts> List is the H98 list module, Data.List has a bit more than that and the ghc one is an internal thing
04:01:09 <|Steve|> Iirc, qualified names like Data.List aren't H98, right?
04:01:28 <|Steve|> Like hugs doesn't support it.
04:02:17 <ndm> |Steve|: they aren't H98, but you can assume they are, they are supported by everything
04:02:27 <ndm> they should have been in H98 all along
04:02:47 <|Steve|> Hugs.Base> :m Data.List
04:02:47 <|Steve|> ERROR - Cannot find module "Data.List"
04:02:49 <ndm> that and the FFI are the only "blessed" H98 extensions, which you are free to use
04:02:58 <|Steve|> Oh, it's :l.
04:03:00 <ndm> |Steve|: :l
04:03:03 <|Steve|> Silly me.
04:03:13 <ndm> no, silly Hugs vs GHCi for having a different UI for the same thing
04:03:59 <|Steve|> Fair enough.
04:04:08 <|Steve|> Did haskell win ICFP again?
04:04:59 <ndm> no idea
04:05:15 <ndm> you may have to wait for ICFP
04:05:21 <wolverian> did _anyone_ win it? :)
04:05:29 <|Steve|> Okay. I just saw the topic just now.
04:05:49 <wolverian> it doesn't say which years. ;)
04:06:11 <|Steve|> True, but the "3 years running" bit made me think these last 3.
04:07:55 <matthew-_> nah, it's just any 3 consequtive years since the competition began
04:17:02 <|Steve|> I just read the contest pdf, or skimmed it at least. It's absurdly complicated.
04:18:03 <matthew-_> s/ly complicated.// ;-)
04:18:26 <|Steve|> Heh.
04:18:41 <|Steve|> I'd leave in the period though.
04:19:12 <vincenz> s/ly complicated\(.\)/\1/
04:19:18 <vincenz> . matches any char :)
04:19:39 <|Steve|> How about just s/ly complicated// ?
04:20:00 <opqdonut> How about just 1,$d
04:20:09 <matthew-_> vincenz: given the rest of the match, escaping the . was unnecessary - it did not make it ambiguous
04:20:11 <vincenz> ggvGdd
04:20:13 <|Steve|> And escaping the () would make them literals for most regex.
04:20:17 <vincenz> matthew-_: I didn't escape it
04:20:23 <vincenz> matthew-_: I grouped it and quoted it with \1
04:20:36 <EvilTerran> ...
04:20:40 <vincenz> Just like DNA pattern templates :)
04:20:42 <matthew-_> ahh.
04:20:45 <EvilTerran> \.\.\., i mean.
04:20:54 <|Steve|> Heh.
04:21:00 <vincenz> nerds
04:21:20 <|Steve|> s/er/o/
04:21:34 <EvilTerran> I could shave off a character by saying "\Q..." instead
04:21:46 <matthew-_> ewww. That's grim though
04:22:10 <matthew-_> wouldn't you need \E aswell? Or doesn't it mind?
04:22:44 <EvilTerran> well, perl doesn't. don't know about other RE engines.
04:22:56 <|Steve|> I'm not sure why your ... would be a pattern match though.
04:23:05 <EvilTerran> /\Q$foo/ is a fairly common idiom, iirc.
04:23:45 <matthew-_> z /$foo/ must be more common in inexperienced programmers ;)
04:23:48 <matthew-_> agh.
04:23:51 <matthew-_> /$foo/ must be more common in inexperienced programmers ;)
04:24:22 <EvilTerran> well, yes. actually, i found one of those in the bundled perl CGI module.
04:25:06 <EvilTerran> (got a strange error trying to have *s in my querystring, looked at the source... "hang on a minute!")
04:25:15 <matthew-_> oh my
04:25:29 <EvilTerran> it's only the most commonly used perl module EVARR
04:25:38 <|Steve|> \Q isn't working for me.
04:25:44 <EvilTerran> (well, after Exporter, maybe)
04:25:48 <matthew-_> mmm. it's only slightly worse than using concatenation to build SQL queries
04:26:11 <EvilTerran> actually, it's better, i think, 'cos you can't use it to trash data.
04:26:28 <matthew-_> depends if /e is on
04:26:54 <|Steve|> $ perl -ne 'BEGIN{$foo="bar"}print if /\Q$foo\E/' <<< \$foo
04:27:06 <|Steve|> That prints nothing, but if I change \$foo to bar, it prints bar.
04:27:13 <EvilTerran> $foo = '(?{`rm -rf /`})'; /$foo/; never works, for instance.
04:27:35 <EvilTerran> steve, variable substitution still happens after a \Q, just nothing else does.
04:27:53 <EvilTerran> the point of it is so you can safely variable-substitute inside a regex.
04:27:55 <|Steve|> Oh, okay. I thought it was for quoting the $. I understand now.
04:27:59 <|Steve|> Right.
04:28:02 <|Steve|> Makes sense.
04:28:17 <|Steve|> Who'd have thought I'd learn something about perl in #haskell?
04:28:38 <mornfall> ...
04:28:57 <EvilTerran> 12:26>perl -e "$foo = '.*'; print qr/$foo/, qr/\Q$foo/"
04:28:57 <EvilTerran> (?-xism:.*)(?-xism:\.\*)
04:29:28 <matthew-_> just... use... parsec...
04:30:13 <|Steve|> Okay, nerd time in just a few hours (comic con), so I must be getting to sleep.
04:31:48 <EvilTerran> for me, it's always nerd time. why else would i be discussing obscure aspects of one programming language in another's channel?
04:32:24 <matthew-_> that was an xslt match wasn't it?
04:33:58 <EvilTerran> what was?
04:35:13 <matthew-_> oh, no, ignore me
04:35:47 <mornfall> ...
04:56:18 <kalven> is there a function in the standard library that converts an Int to [Char] in binary? like: 5 => "101" ?
04:56:58 <vincenz> show
04:57:02 <vincenz> oh, in binary
04:57:12 * vincenz read too fast.... "No, I don't think so"
04:57:33 <quicksilver> :t showIntAtbase
04:57:34 <opqdonut> should be quite easy with scanl
04:57:34 <oasisbot> Not in scope: `showIntAtbase'
04:57:38 <quicksilver> :t showIntAtBase
04:57:39 <oasisbot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
04:58:17 <quicksilver> > showIntAtBase 2 (chr.(+48)) 5
04:58:18 <oasisbot>  <[Char] -> [Char]>
04:58:20 <vincenz> @source showIntAtBase
04:58:20 <oasisbot> showIntAtBase not available
04:58:27 <quicksilver> > showIntAtBase 2 (chr.(+48)) 5 ""
04:58:28 <oasisbot>  "101"
04:58:31 <quicksilver> there you go
04:58:32 <vincenz> quicksilver++
04:58:34 <kalven> thanks
04:58:40 <vincenz> @src showIntAtBase
04:58:40 <oasisbot> Plugin `source' failed with: IRCRaised getRandItem: empty list
04:58:44 <vincenz> @index showIntAtBase
04:58:44 <oasisbot> Numeric
04:58:47 <quicksilver> 48 is really ord '0'
04:58:49 <vincenz> @hoogle showIntAtBase
04:58:49 <oasisbot> Numeric.showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
04:58:55 <quicksilver> mabye that would be a better way to write it
04:59:09 <quicksilver> > showIntAtBase 2 (chr.(+(ord '0'))) 55 ""
04:59:10 <oasisbot>  "110111"
05:00:08 <vincenz> > showIntAtBase 2 (chr.(+(ord 'A'))) 55 ""
05:00:09 <oasisbot>  "BBABBB"
05:01:34 <opqdonut> > showIntAtBase 256 (chr) 48 ""
05:01:35 <oasisbot>  "0"
05:01:39 <opqdonut> ^_^
05:01:42 <olsner> wonderfully general, but isn't it a bit too general? I'd be quite content to have the default 0-9, A-Z for bases 2-36, and a showIntAtBaseGeneric for the special cases
05:01:50 <opqdonut> alternate implementation of ord
05:02:20 <vincenz> opqdonut: you forgot 'head'
05:02:50 <opqdonut> well yeah
05:03:39 <olsner> or have placeValueList :: Integral a => a -> a -> [a]
05:04:18 <olsner> showIntAtBase b f = map f . placeValueList b
05:04:53 <opqdonut> > showIntAtBase 256 (chr) 1818576896 ""
05:04:54 <oasisbot>  "leH\NUL"
05:04:59 <opqdonut> not quite
05:05:10 <opqdonut> > showIntAtBase 256 (chr) 1819043144 ""
05:05:11 <oasisbot>  "lleH"
05:05:54 <quicksilver> olsner: I agree it's a bit odd
05:05:58 <olsner> showIntAtBase b f = (++ :: String -> String -> String) . map f . placeValueList b, I mean
05:06:07 <quicksilver> olsner: but *shrug* you can always write your own version
05:06:10 <quicksilver> olsner: not exactly hard :)
05:06:28 <olsner> nope :)
05:08:05 <opqdonut> ah!
05:08:07 <opqdonut> > showIntAtBase 256 (chr) 22405534230753928650781647905 ""
05:08:08 <oasisbot>  "Hello World!"
05:08:29 <EvilTerran> heh
05:09:14 <opqdonut> wow, what happened to lambdabot btw?
05:09:27 <olsner> from "lleH" to "Hello World!" in only 3 minutes! :P
05:09:27 <vincenz> opqdonut: dons' uni is down
05:09:47 <opqdonut> ahh
05:09:54 <opqdonut> olsner: yeah ;)
05:10:10 <opqdonut> Int-defaulting bit me
05:10:22 <olsner> > readIntAtBase 256 (ord) "Hello World!"
05:10:23 <oasisbot>   Not in scope: `readIntAtBase'
05:10:38 <opqdonut> too easy
05:10:49 <opqdonut> sum $ zipWith (*) (reverse a) $ map ((256::Integer)^) [0..] -- :)
05:11:00 <opqdonut> where a =  map (fromIntegral.Char.ord) "Hello World!"
05:11:27 <vincenz> @type toInteger
05:11:29 <oasisbot> forall a. (Integral a) => a -> Integer
05:12:11 <opqdonut> that'd work to
05:12:21 <olsner> > readInt 256 (const True) ord "Hello World!"
05:12:22 <oasisbot>  [(22405534230753928650781647905,"")]
05:12:35 <opqdonut> ah
05:13:00 <olsner> took me only 2 minutes :P
05:13:32 <vincenz> > showIntAtBase 256 chr 179075938678837711017699755408681345623631591664835672563871077 ""
05:13:33 <oasisbot>  "opqdonut has too much time"
05:13:38 <opqdonut> is that readInt base isDigitp charToDigit string ?
05:14:18 <olsner> yeah, but strictly that string is applied to the result of (readInt base isDigitP charToDigit) :: ReadS a
05:14:42 <wolverian> any possibility of oasisbot joining #perl6 for the while that lambdabot is gone?
05:14:48 <olsner> and what ReadS is, I have no idea, but presumably String -> [(a,String)] is an instance of ReadS a
05:15:36 <olsner> s/is an instance of/is/ ;-) type ReadS a = String -> [(a, String)]
05:16:49 <opqdonut> wonder it isn't charToDigit :: Char -> Maybe Int
05:16:53 <opqdonut> +why
05:17:06 <olsner> you already have isDigitP
05:17:23 <opqdonut> yeah that'd replace isDigitP and charToDigit
05:17:50 <opqdonut> but i guess the present on is nicer for the typical use case
05:18:11 <opqdonut> tho having charToDigit = flip lookup digits might be nice too
05:18:15 <opqdonut> yah, whatever
05:18:55 <olsner> it's not terribly hard to roll your own though
05:22:38 <vincenz> > fromJust . listToMaybe . reads . take 1 . "1"
05:22:38 <olsner> but it is easier to take (isDigitP,charToDigit) and make Char -> Maybe Int, than the other way around (or rather, mapping Char -> Maybe Int to the other two will have to call the function twice)
05:22:39 <oasisbot>  Couldn't match expected type `a -> [a1]'
05:22:47 <vincenz> > fromJust . listToMaybe . reads . (:[]) $ '1'
05:22:48 <oasisbot>  (1,"")
05:22:58 <vincenz> > liftM fst . fromJust . listToMaybe . reads . (:[]) $ '1'
05:22:59 <oasisbot>  Couldn't match expected type `(a, b)'
05:23:13 <vincenz> > liftM fst . listToMaybe . reads . (:[]) $ '1'
05:23:14 <oasisbot>  Just 1
05:23:19 <vincenz> > liftM fst . listToMaybe . reads . (:[]) $ 'x'
05:23:20 <oasisbot>  Nothing
05:23:29 <opqdonut> olsner: true
05:27:00 <gkr> @type Map.lookup
05:27:01 <oasisbot> Couldn't find qualified module.
05:27:55 <opqdonut> ?hoogle lookup
05:27:56 <oasisbot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
05:27:56 <oasisbot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
05:27:56 <oasisbot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
05:29:45 <olsner> @type Data.Map.lookup
05:29:46 <oasisbot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
05:33:18 <jsnx> wow, haskell has HashTables?
05:33:21 <jsnx> cool!
05:34:00 <vincenz> no
05:34:02 <vincenz> maps
05:34:09 <vincenz> oh!
05:34:10 * vincenz misread
05:34:15 <vincenz> Yes, those too :)
05:55:07 <EvilTerran> gesundheit
05:57:59 <opqdonut> :)
05:58:44 <opqdonut> wonder what's wrong with the internet, lots of splits (on most networks i'm on) in the past couple of days
05:59:03 <opqdonut> also, my shell server becomes unresponsive now and then
05:59:17 <necroforest> must be a new world of warcraft patch
05:59:18 <necroforest> :-P
06:00:03 <opqdonut> ;)
06:01:44 <gkr> Where is lambdabot?
06:01:49 <opqdonut> gone
06:01:53 <gkr> :-(
06:02:06 <opqdonut> with the wind
06:02:09 <opqdonut> as we all must
06:02:13 <opqdonut> one day fade away
06:02:14 <EvilTerran> @bot
06:02:14 <oasisbot> :)
06:02:26 <opqdonut> oasisbot: YOU'LL NEVER REPLACE HER!!
06:02:27 <opqdonut> *sniff*
06:02:59 <oasisbot> :(
06:03:14 * oasisbot leaves depressed
06:03:27 <roconnor> opqdonut: way to go
06:03:28 <opqdonut> :(
06:03:30 <gkr> :-(
06:04:01 <roconnor> @bot-snack
06:04:01 <oasisbot> :)
06:04:10 <roconnor> oasisbot++
06:04:31 <vincenz> I wonder what would happen if lambdabot and oasisbot had children
06:04:38 <vincenz> all these little mubots
06:05:40 <opqdonut> oasisbot: no hard feelings, eh?
06:13:03 <dcoutts> sioraiocht, thorkilnaur: did either of you get a chance to try gtk2hs-0.9.12 on OSX?
06:13:20 * dcoutts is itching to do a release but would prefer that it works on OS X of course
06:14:46 <thorkilnaur> dcoutts, Right on time, just finished, wouldn't build, details are here: http://thorkilnaur.dk/~tn/Gtk2Hs/buildlogs/configure_20070727_about_1400_recorded_20070727_1508.out and here: http://thorkilnaur.dk/~tn/Gtk2Hs/buildlogs/make_20070727_141137.out
06:14:47 <oasisbot> http://tinyurl.com/2pbguz
06:15:07 <dcoutts> thorkilnaur: cheers, I'll take a look...
06:16:42 <dcoutts> thorkilnaur: ok, that looks like the same thing mux ran into on FreeBSD, I'll upload a new tarball is just a sec...
06:19:58 <gkr> @src get
06:19:58 <oasisbot> Plugin `source' failed with: IRCRaised getRandItem: empty list
06:20:01 <dcoutts> thorkilnaur: we discovered it was a case of a header file getting found first on the wrong path, so we've just renamed our local header so it doesn't clash
06:21:06 <dcoutts> thorkilnaur: and that fixed things for mux, so I expect it'll fix it for you too
06:21:27 <dcoutts> mux, thorkilnaur: here's the new tarball http://haskell.org/~duncan/gtk2hs/gtk2hs-0.9.12.tar.gz
06:22:05 <swiert> Is there some way to import only a few parts of a module as qualified?
06:22:36 <mux> dcoutts: cheers, will build-test it right away
06:23:09 <dcoutts> swiert: you can use multiple import lines
06:23:18 <dcoutts> import qualified Data.Map as Map
06:23:22 <dcoutts> import Data.Map (Map)
06:23:36 <swiert> dcoutts: Brilliant. Ta.
06:26:05 <mux> oh, nice, I didn't know one could do that
06:28:33 <ndm> vincenz: confirmed
06:29:21 <swiert> Ok. Another module system question:
06:29:29 <vincenz> :)
06:29:45 <swiert> Suppose I "import qualified Data.Map(empty) as Map"
06:29:56 <swiert> and I define something called "empty" in my module.
06:30:17 <swiert> Why do I still get complaints that it can't resolve the name "empty"?
06:31:02 <dcoutts> swiert: are you importing Map from another import line, or is that the only one?
06:31:12 <ndm> import Data.Map hiding (empty) the other time
06:31:22 <dcoutts> swiert: the error message should say where the two imports are coming from
06:31:47 <swiert> ndm: Thanks. That's it.
06:32:13 <swiert> (dcoutts: thanks again)
06:33:32 <fasta> Is there a destructor like maybe for lists?
06:33:42 <vincenz> foldr?
06:33:57 <opqdonut> no, not really
06:34:01 <vincenz> foldr (case for list) (case for empty)
06:34:29 <ndm> but foldr is recursive, i guess fasta wants a non-recursive variant
06:34:34 <vincenz> that's not possible
06:34:37 <vincenz> the data type is recursive
06:34:38 <ndm> yes, it is
06:34:47 <opqdonut> well one could use the list monad's bind i guess
06:34:55 <ndm> list :: b -> (a -> [a] -> b) -> [a] -> b
06:34:56 <ski> [a] -> Maybe (a,[a])
06:35:17 <ndm> then list nil cons [] = nil, list nil cons (a:as) = cons a as
06:35:17 <mux> @djinn b -> (a -> [a] -> b) -> [a] -> b
06:35:18 <oasisbot> f a _ _ = a
06:35:19 <vincenz> > foldr (const . const $ "full") "null" [1..10]
06:35:21 <oasisbot>  "full"
06:35:26 <vincenz> like that?
06:37:56 <ndm> > foldr (\a as -> toUpper a : as) "empty" "lowercase"
06:37:57 <oasisbot>  "LOWERCASEempty"
06:38:09 <ndm> whereas list would have given "Lowercase"
06:38:13 <fasta> ndm: yes, I already wrote what you did, now.
06:38:15 <vincenz> ndm: it makes no real sense cause List is an inductive data type
06:38:16 <vincenz> maybe isn't
06:38:26 <vincenz> hence you need an inductive 'maybe' function
06:38:29 <vincenz> aka, fold
06:38:45 <ndm> vincenz: you may want a one level traversal, or you may want a recursive traversal, for maybe a recursive one makes no sense
06:38:57 <ndm> for lists, both make sense, but only one is in the library (foldr)
06:39:00 <vincenz> for non recursive
06:39:01 <vincenz> you const const
06:39:18 <ndm> thats not just non recursive, thats just if null
06:39:32 <ndm> you can't write the titlecase function in terms of foldr
06:39:37 <ndm> or easily, at least
06:39:48 <ndm> whereas its trivial with a "maybe" equivalent
06:39:58 <vincenz> but I think it's badly defined
06:40:02 <vincenz> that's where I'm arguing from
06:40:09 <ndm> its sometimes useful
06:40:14 <ndm> to fasta, for example :)
06:40:18 <vincenz> many dirty hacks are :)
06:40:29 <ndm> its simply a list continuation
06:40:41 <earthy> what is dirty about a 1 level traversal of a datastructure?
06:40:52 <vincenz> it doesn't map to the definition of the data type
06:40:56 <ndm> list is just a case that has been church encoded
06:41:04 <ndm> it does, perfectly, its church encoding
06:41:48 <fasta> Is using runListT slower than doing the same thing in a less abstract way?
06:42:24 <ski> @type foldr (\a b -> Just (a,maybe [] (uncurry (:)) b)) Nothing
06:42:25 <ndm> fasta: have you profiled your application and found this particular instance is slowing something down, or are you doing evil performance hacks in advance?
06:42:25 <oasisbot> forall a. [a] -> Maybe (a, [a])
06:42:40 <earthy> vincenz: why not? (and before you argue, look at SYB and its gmap)
06:42:52 <dylan> hmm, where's lambdabot?
06:42:53 <fasta> ndm: well, I first did a theoretical implementation and I now found out it needs to go about 1000 times faster.
06:42:57 <dylan> /* lambdabot */
06:43:01 <dylan> err.
06:43:08 * dylan slaps /l for not being /ll
06:43:13 <fasta> ndm: so, I figured not to do unnecessary slow downs now.
06:43:18 <ndm> fasta: profile first, then see where the time is going, i would have thought it was constant time slower, and 1000 is likely to be too big a slow down
06:43:18 <vincenz> earthy: I guess I'll have to mull on it a bit.
06:43:40 <ndm> vincenz: plus look at Uniplate
06:44:56 <ndm> plus you can probably define foldr in terms of list
06:45:48 <earthy> actually, 'The Essence of Strategic Programming' by Ralf Lämmel, Eelco Visser and Joost Visser tells you how, ndm. :)
06:46:55 <vincenz> ndm: perhaps, I always had the impression that there needed to be a direct correspondence between data-types and destructors
06:47:14 <earthy> (well, actually, list is not more than a resugaring of case analysis specialised to the list type)
06:47:33 <earthy> vincenz: case is the ultimate destructor then, is it not?
06:47:48 <vincenz> earthy: I mean
06:47:49 <vincenz> assume you have
06:47:59 <vincenz> data Foo a = Bar a a | Bing a (Foo a)
06:48:03 <vincenz> then you have
06:48:20 <vincenz> defoo (a -> a -> c) (a -> b -> c) b
06:48:27 <vincenz> notice the recursion in b
06:48:31 <vincenz> -> c of course :)
06:48:47 * vincenz thinks
06:48:52 <vincenz> wait,
06:48:56 <vincenz> s/b/c in the second function
06:49:01 <earthy> what recursion?
06:49:25 <vincenz> defoo :: (a -> a -> c) -> (a -> c -> c) -> b -> c
06:49:39 <vincenz> is the fold for that structure, which I always thought was the generic destructor function
06:49:50 <vincenz> the recursion is in (a -> c -> c)
06:49:54 <doserj> you can see from the type of a function that it is recursive? :)
06:49:56 <vincenz> (it takes a finalized c)
06:49:58 <vincenz> yes :)
06:50:06 <vincenz> it takes a final product, instead of just the input 'b'
06:50:11 <vincenz> so it must recurse downwards first
06:50:33 <vincenz> let's go to a list
06:50:50 <vincenz> data List a = Nil | Cons a (List a)
06:51:04 <vincenz> deList    c  (a -> c -> c)  -> (List a) -> c
06:51:06 <vincenz> you're asking for
06:51:18 <vincenz> deList c (a-> (List a) -> c) -> (List a) -> c
06:51:26 <chrismbrown> beelsebob: ping
06:51:32 <earthy> delist :: c -> (a -> List a -> c) -> List a -> c
06:51:33 <beelsebob> pong
06:51:38 <xerox> (what's 'b' ?)
06:51:44 <chrismbrown> beelsebob: did I leave my coat in the back of your car?
06:51:47 <vincenz> xerox: b should've been Foo a
06:51:55 <beelsebob> errr... pass
06:51:58 <beelsebob> mayb
06:52:12 <chrismbrown> beelsebob: it has my train tickets in :)
06:52:31 <vincenz> earthy: right, but afaik, the way to do it is to replace the recursive data structure by the output in folds, which I always thought was the generic way of destructuring (cause you're guaranteed proper traversal)
06:52:56 <earthy> let foldr nil acc list = delist nil (acc a (foldr nil acc)) list
06:53:06 <beelsebob> erq
06:53:13 <vincenz> earthy: hence why acc takes 'c' not (List a)
06:53:46 <earthy> waitseq, that's wrong
06:54:09 <vincenz> yes, you should destrucutre and pass 'rest' to the inner fold
06:54:13 <vincenz> destructure even
06:54:16 <earthy> uhuh
06:55:00 <chrismbrown> beelsebob: could you please just check? If so, I'll come down
06:55:23 <ski> @type let deList :: c -> (a -> List a -> c) -> List a -> c; deList = undefined in \nil cons -> fix $ \loop as -> deList nil (\a as -> cons a (loop as)) as
06:55:25 <oasisbot> Not in scope: type constructor or class `List'
06:55:25 <oasisbot>  
06:55:25 <oasisbot> <interactive>:1:41: Not in scope: type constructor or class `List'
06:55:32 <vincenz> s/List a/[a]
06:55:36 <ski> @type let deList :: c -> (a -> [a] -> c) -> [a] -> c; deList = undefined in \nil cons -> fix $ \loop as -> deList nil (\a as -> cons a (loop as)) as
06:55:37 <oasisbot> c -> (a -> [a] -> c) -> [a] -> c; deList = undefined in \nil cons -> fix $ \loop as -> deList nil (\a as -> cons a (loop as)) as :: forall c a. c -> (a -> c -> c) -> [a] -> c
06:55:42 <beelsebob> chrismbrown: it's not there
06:56:06 <vincenz> (a -> c -> c)
06:56:55 <ski> > let deList nil cons [] = nil; deList nil cons (a:as) = cons a as in (\nil cons -> fix $ \loop as -> deList nil (\a as -> cons a (loop as)) as) (\a s -> concat ["(",show a ," + ",s,")"]) "42" [0,1,2]
06:56:55 <oasisbot>  Couldn't match expected type `t
06:57:18 <ski> > let deList nil cons [] = nil; deList nil cons (a:as) = cons a as in (\nil cons -> fix $ \loop as -> deList nil (\a as -> cons a (loop as)) as) "42" (\a s -> concat ["(",show a ," + ",s,")"]) [0,1,2]
06:57:19 <oasisbot>  "(0 + (1 + (2 + 42)))"
06:57:34 <ski> seems to work ok
06:59:11 <doserj> ski: of course you can implement foldr with case analysis
06:59:30 <chrismbrown> beelsebob: phew got it
06:59:35 <chrismbrown> beelsebob: was in thegulb
06:59:37 <beelsebob> :)
07:00:18 <doserj> the question is only, do you consider 'maybe' to be case analysis for the Maybe type, or fold for the Maybe type
07:00:37 <doserj> which is the same thing for Maybe :)
07:00:50 <ski> yes
07:02:35 <ski> writing list functions in terms of 'foldr' only for list destructuring&recursion can be fun
07:03:56 <roconnor> http://ecommerce.cit.gu.edu.au/ict/events/seminars/Final_Seminars_2002.html
07:03:58 <oasisbot> Title: Final Seminars for 2002, http://tinyurl.com/2qbzmn
07:04:08 <roconnor> Abstract: Five different exact pattern matching algorithms were implemented in Haskell, all designed to be able to search a potentially infinite source. Under these conditions standard brute force techniques proved fairly effective, only clearly losing out as searches passed about 100,000 characters. For these searches a Boyer-Moore algorithm using an array was found to perform the best, particularly as the pattern string got larger.
07:04:32 <earthy> uhm, so how does unfoldr get written as a foldr?
07:05:08 <earthy> owh, wait, you don't destructure lists in unfoldr. :)
07:06:31 <Saizan> you cans till use foldr for the recursion if you want :)
07:14:38 <mux> dcoutts: build completed fine
07:14:49 <dcoutts> mux: great
07:15:40 <mux> roconnor: I like this URL a lot: http://www-igm.univ-mlv.fr/~lecroq/string/
07:15:40 <oasisbot> Title: ESMAJ
07:16:01 <mux> roconnor: it's more or less a repository of exact string matching algorithms
07:18:54 <roconnor> even if BM is O(mn), I bet it will still be faster in the DNA machine than KMP
07:20:43 <dcoutts> roconnor, mux: someone needs to implement one (or more) of those string searches and I'll help them include it into the new bytestring package
07:21:13 <dcoutts> and if we can adapt them to work on the .Lazy chunked representation then even better
07:21:22 <mux> at least BM and KMP would be good
07:21:24 <dcoutts> since we currently have no string search for .Lazy
07:21:29 <dcoutts> yes
07:21:43 <dcoutts> I don't recall, does BM ever need backtracking?
07:22:14 <dcoutts> arbitrary backtracking is a bit of a pain for the chunked representation of .Lazy
07:22:16 <roconnor> dcoutts: I thought you guys already had a KMP algorithm.
07:22:19 <mux> roconnor: KMP skip search should be best for DNA matches
07:22:25 <dcoutts> roconnor: it's a very slow impl
07:22:34 * roconnor looks up skip search
07:22:47 <mux> roconnor: http://www-igm.univ-mlv.fr/~lecroq/string/node32.html#SECTION00320
07:22:47 <oasisbot> Title: KMP Skip Search algorithm, http://tinyurl.com/23xhmq
07:23:13 <mux> "CHARRAS C., LECROQ T., PEHOUSHEK J.D., 1998, A very fast string matching algorithm for small alphabets and long patterns"
07:23:21 <mux> the title of the paper tells a lot:)
07:24:22 <mux> or maybe the alpha skip search
07:25:07 <roconnor> :)
07:25:40 <roconnor> well, our patterns aren't that long
07:26:53 <mux> heh, can't tell, I've not been bored enough yet to start working on the ICP'07c
07:26:57 <mux> ICFP, rather
07:27:43 <mux> but I suppose scientific apps that deal with DNA matches have huge patterns, and as we know, a very small alphabet
07:28:11 * earthy nods
07:28:12 <nominolo_> hm, is there a standard ideom for abortable folds?
07:28:31 <thorkilnaur> dcoutts, (compiler still running) BM (Boyer-Moore, I assume) backtracks up to the length of the string searched for, but it never positions the string backwards
07:28:44 <roconnor> nominolo_: continuations perhaps.
07:28:48 <nominolo_> maybe some applicative functor + traverse?
07:29:20 <nominolo_> hm, yeah, continuations don't sound bad, yep
07:29:29 <dcoutts> thorkilnaur: right, where as KMP never looks 'behind' it advances char by char iirc.
07:29:41 <dcoutts> thorkilnaur: and thanks for re-running the build
07:31:08 <thorkilnaur> dcoutts, Exactly. The M (Morris) of KMP invented (some of?) KMP, precisely because he had a situation where he wouldn't backtrack over the searched string
07:31:12 <dcoutts> I wonder how one would do BM on the chunked representation efficiently, given that the string being searched for might cover several chunk boundaries
07:31:29 <dcoutts> thorkilnaur: oh, interesting
07:31:52 <dcoutts> it can be done for the chunked rep of course, but the question is how easily/effeciently
07:31:55 <ndm> are you trying to make bytestring super efficient at searching?
07:32:00 <dcoutts> ndm: yep
07:32:06 <ndm> cool :)
07:32:11 <earthy> BM doesn't really backtrack either, does it?
07:32:14 <thorkilnaur> I have no idea, bu maintaining a hold of the position in the searched string where the pattern string is currently positi0oned would be the first idea,
07:32:34 <earthy> so the trick is getting a fast 'skip by n characters' for the chunked rep
07:32:38 <dcoutts> ndm: well, I'm not, I appreciate that it's important and am telling everyone else to implement something :-)
07:32:54 <SamB_XP_> earthy: that doesn't sound like much of a trick
07:32:58 <dcoutts> earthy: it's the other way around as I understand it
07:33:08 <thorkilnaur> earthy, BM positions pattern against string and then starts to compare from the end of the pattern, backwards
07:33:18 <ndm> dcoutts, the best kind of cool, the no work cool
07:33:43 <dcoutts> earthy: that we've looked forward to 'current+length' and now need to abandon that and look back to 'current'
07:34:02 <dcoutts> or maybe I misunderstand too :-)
07:34:36 * earthy ponders again
07:34:44 <dcoutts> earthy: my impression is that it needs semi-random access within the current length of the pattern
07:34:55 <dcoutts> which is tricky if it spans one or more chunks
07:34:55 <earthy> is 11 years ago since I've really really looked deeply into BM
07:35:07 <earthy> nope, it doesn't need semi-random access
07:35:18 <dcoutts> I only vaguely remember it from undergrad stuff
07:35:19 <thorkilnaur> B&M implemented their seach on a PDP-10 so that less than one machine instruction were executed per character searched.
07:35:19 <projectxz> hi dcoutts. i've just tried out xmonad for the first time finally got going, but can't seem to find the mod1 modifier key? it's not alt...i'm using an ibook G4 laptop still
07:35:30 <thorkilnaur> They called it "sub-linear" for this reason
07:35:33 <SamB_XP_> dcoutts: what are you talking about anyway?
07:35:37 <dcoutts> thorkilnaur: yeah, that's pretty good :-)
07:35:37 <ndm> thorkilnaur: thanks for the Catch and pretty printer comments, they're very interesting, and Catch should be able to do what you want. I'm still working through all the points
07:35:41 <earthy> it needs to have lookback of the length of the pattern searched for
07:35:46 <earthy> (at most)
07:35:56 <SamB_XP_> projectxz: play with xmodmap a bit?
07:35:58 <dcoutts> projectxz: try asking in #xmonad I don't use it so can't help.
07:36:10 <thorkilnaur> ndm, Thanks, but don't you get side-tracked now, from more important things
07:36:14 <dcoutts> SamB_XP_: fast string search for bytestrings
07:36:14 <projectxz> ok thanks anyway
07:36:17 <projectxz> to both of ya
07:36:37 <earthy> but that lookback is always walked through in the same direction
07:36:38 <SamB_XP_> dcoutts: what was that about semi-random access to a pattern?
07:36:50 <earthy> so you can determine how many chunks to keep in memory in advance
07:37:03 <dcoutts> SamB_XP_: the Boyer Moore string search algorithm
07:37:09 <earthy> oh, wait, the chunks can be arbitrarily sized. hm.
07:37:12 <ndm> thorkilnaur: i had actually just put catch away for a few months when you came up with that :)
07:37:12 <SamB_XP_> dcoutts: ah.
07:37:21 <SamB_XP_> so... strictify the pattern?
07:37:32 <earthy> still, you only need two pointers to determine which chunks to keep in mem
07:37:50 <dcoutts> earthy: yes, so we do at least know the list of chunks that cover the current location of pattern
07:37:55 <thorkilnaur> ndm, I thought Catch was the subject of your PhD? Or maybe just a sub-subject?
07:37:58 <dcoutts> earthy: and could reverse traverse that
07:38:14 <earthy> a pointer to the possible beginning of the pattern and a pointer to the current matching point (which is the end of the pattern)
07:38:26 <dcoutts> SamB_XP_: that's no problem, we can certainly make the pattern strict, its the text we're searching in that's the issue
07:38:33 <earthy> dcoutts: exactly.
07:38:34 <SamB_XP_> dcoutts: oh.
07:38:51 <ndm> thorkilnaur: its 1 chapter of 3, i've also got uniplate (revised paper due in next Friday) and Supero (paper due in end of next month)
07:39:20 <ndm> Catch is the bit that keeps getting rejected from conferences, hence putting it to the back while i work on the other two
07:39:24 <dcoutts> earthy: in practise with a shortish pattern the pattern will fit into the current chunk almost all the time
07:39:46 <dcoutts> earthy: so the complex case of one or more boundaries doesn't need to be that fast, just correct.
07:39:50 <SamB_XP_> ndm: why don't they like catch?
07:40:02 <thorkilnaur> Chunked BM search idea: Search the chunks separately (possibly in parallel, wow!), then do something special with the ends of each chunk.
07:40:24 <thorkilnaur> If the chunks ar large compared to the pattern, that would seem potentially fast ...
07:40:27 <dcoutts> thorkilnaur: aye, dons keeps saying we should try some bytestring stuff in parallel :-)
07:40:41 <dcoutts> thorkilnaur: when reading from disk for example we use 32k chunks
07:40:42 <ndm> SamB_XP_: Catch is quite complex, which makes it quite hard to explain in a paper, where you are tied for space
07:40:42 <SamB_XP_> huh.
07:40:52 <SamB_XP_> ndm: ah.
07:41:07 <SamB_XP_> ndm: the solution seems obvious ;-P
07:41:51 <vincenz> Have one very big font line
07:41:58 <vincenz> "The details can be found in the online appendix
07:42:05 <vincenz> then put it in 100 pages online :)
07:42:20 <vincenz> That or write a journal
07:42:35 <thorkilnaur> I did a parallel string search project in, well, end of the 1970'ties. My teacher took it and pulished it. But with random access to the string to be searched for, this was actually quite simple.
07:42:57 <thorkilnaur> s/pulished/published/
07:43:27 <SamB_XP_> thorkilnaur: apparantly they have random access to the searched-for string here too though
07:43:48 <SamB_XP_> it's the searched-in string that they don't have random access to
07:44:15 <thorkilnaur> s/searched for/searched in/, sorry
07:44:29 <thorkilnaur> SamB, thanks
07:46:18 <thorkilnaur> dcoutts, Both KMP and BM use a DFA-like thing to guide the seach. Probably, such a thing could be adjusted to take care of the chunk endings.
07:47:07 <Syzygy-> thorkilnaur: Did you at least get co-author credits?
07:47:14 <dcoutts> thorkilnaur: hmm? I'm not sure I understand? I assumed it'd be transparent to the DFA, when we get to the end of a chunk we just keep going in the next
07:47:26 <thorkilnaur> dcoutts, The idea would be to find, for each chunk, first the places at the very end (i.e. where at least one character (or what they are) hang out over the end) where a match could be ...
07:47:39 <dcoutts> thorkilnaur: for KMP that's easy because of the access pattern, for BM as we've been noting it's harder.
07:47:57 <dcoutts> thorkilnaur: ah, hmm, interesting
07:47:59 <thorkilnaur> dcoutts, Then look, for each of these, a few characters into the next chunk to verify/throw away the match.
07:48:39 <dcoutts> thorkilnaur: I wonder if anyone has done that before for fast string search in rope data structures
07:48:51 <thorkilnaur> Syzygy-, I think I was mentioned, but given the triviality of this, I was kind of embarassed that anyone would even think of pubshing it.
07:49:01 <dcoutts> which are essentially the same from a string search pov, chunked
07:49:09 <Syzygy-> thorkilnaur: heh
07:49:46 <Syzygy-> thorkilnaur: At least one of my current papers is along the lines of "Well, it's bloody trivial now that I think of it ... but nobody's done it, and people are interested when I tell them about it, so it's worthy of publishing..."
07:49:50 <Syzygy-> However, I'm in Algebra.
07:50:20 <thorkilnaur> s/pubshing/publishing/ (again, this word haunts me)
07:51:15 <thorkilnaur> Syzygy-, It was a bit like that with parallelism, anything you could think of, then parallelise, then publish
07:51:21 <byorgey> morning everyone!
07:51:39 <thorkilnaur> dcoutts, rope data structures?
07:51:52 <Syzygy-> thorkilnaur: Isn't it great to tread on new ground instead of tarring old gravel roads?
07:52:31 <thorkilnaur> Syzygy-, What are you thinking of?
07:52:45 <dcoutts> thorkilnaur: have you seen the data structure called Rope before? it's basically a balanced tree of chunks, used to represent strings with cheap concatenation and log access to chunks
07:52:50 <dcoutts> used in some text editors
07:53:08 <Syzygy-> Syzygy-: I'm working on Aoo-algebra structures in group cohomology, and more specifically the Aoo-algebra structure on the cohomology of finite abelian groups
07:53:08 <dcoutts> the api hides the tree/chunk structure
07:53:11 <Syzygy-> Hrm.
07:53:26 <Syzygy-> s/Syzygy-/thorkilnaur/
07:53:30 <dcoutts> thorkilnaur: so like a lazy bytestring, but a balanced tree rather than a list
07:53:35 <thorkilnaur> dcoutts, I haven't seen any detailed descriptions of such a thing, but I can imagine ...
07:53:40 <Syzygy-> Or did you mean the metaphor?
07:54:09 <dcoutts> thorkilnaur: well they've been around for quite some time, so I expect someone has implemented a fast string search for them
07:54:10 <thorkilnaur> Syzygy-, Yes, that's news to me, I must admit, shamefully
07:54:29 <Syzygy-> thorkilnaur: It is also specialized to the point of almost being embarrassing. ;)
07:56:39 <thorkilnaur> dcoutts, With these ropes, it seems that the advantage of using a thing like BM or KMP depends a lot on how large the chunks typically are
07:57:18 <thorkilnaur> dcoutts, Every performance gain by using KMP or BM easily drowns if getting the next character is even slightly cumbersome, I would guess.
07:58:30 <thorkilnaur> dcoutts, I mean, running down a list of characters looking for a match of one single character is something that, under reasonable circumstances, can be implemented quite efficiently.
07:58:46 <dcoutts> thorkilnaur: right, the rebalancing will combine small chunks to try and keep the chunk size reasonable
08:02:25 <hpaste>  fxr pasted "State problem" at http://hpaste.org/1897
08:05:27 <Lemmih> fxr: Use 'noState'.
08:05:43 <gkr> @hoogle [m a] -> m [a]
08:05:44 <oasisbot> Prelude.head :: [a] -> a
08:05:44 <oasisbot> Prelude.last :: [a] -> a
08:05:44 <oasisbot> List.maximumBy :: (a -> a -> a) -> [a] -> a
08:05:59 <gkr> Nevermind...
08:06:01 <fxr> Lemmih: thanks
08:06:23 <Lemmih> fxr: It is used just like 'debugFilter'.
08:07:31 <byorgey> @type sequence
08:07:33 <oasisbot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:07:59 <fxr> Lemmih: thanks I just learned that this happens when I don't use the state in my handlers
08:08:00 <dozer> I have a function "interpret::typeDescr -> [dataT]" and typeDescr has an integer arity, and the length of the resulting list should match this arity.
08:08:10 <dozer> I'm guessing I need to re-do this to use GADTs?
08:08:51 <olsner> hmm, how does maximumBy :: (a -> a -> a) -> [a] -> a match [m a] -> m [a]?
08:09:43 <SamB_XP_> dcoutts: I have a feeling that ddarius would prefer to use your lazy bytestring search in his ropes ;-)
08:10:32 <kpreid> olsner: flip the arguments, discard the [] in one case and the m in the other... hoogle is deliberately fuzzy
08:11:03 <kpreid> why it didn't find sequence I can't say
08:11:11 <dcoutts> SamB_XP_: it should be pretty easy to convert one to the other, the hard bit is the fact that it is chunked, not the mechanism for finding the next/previous chunk
08:11:21 <SamB_XP_> dcoutts: yeah.
08:12:02 <SamB_XP_> hmm.
08:12:46 <SamB_XP_> hmm.
08:13:15 <necroforest> Hi, I have the following function defined:
08:13:27 <necroforest> iterate :: Complex -> Complex -> Complex ; iterate z c = z*z + c
08:13:50 <necroforest> I get the following error in ghci:  Kind error: `Complex' is not applied to enough type arguments
08:14:14 <SamB_XP_> I think that you just need to check, when you do a skip, that the character you are skipping to is still in the current segment
08:15:04 <kpreid> necroforest: Complex is a type constructor, not a type
08:15:06 <kpreid> necroforest: you need to specify the type of the elements
08:15:11 <kpreid> e.g. Complex Double
08:15:22 <necroforest> OH, ok
08:15:49 <kpreid> er
08:15:51 <SamB_XP_> and if not, you need to build a segment with the last (length needle-1) characters of the current segment and the first (length needle-1) characters of the next segment
08:15:56 <kpreid> actually, just make it a variable:
08:16:04 <kpreid> iterate :: Complex a -> Complex a -> Complex a
08:16:22 <SamB_XP_> and use that until it runs out, then use the next segment
08:17:10 <SamB_XP_> (of course, you'd need to make sure that you had segments at least as long as needle)
08:17:20 <SamB_XP_> dcoutts: does that make any sense?
08:17:59 <dcoutts> SamB_XP_: I guess so
08:18:28 <SamB_XP_> and, for efficiency, of course you'd want segments a good bit longer than needle
08:18:29 <necroforest> I had to use iterate :: (RealFloat a) => Complex a -> Complex a -> Complex a, but it worked
08:18:30 <necroforest> thansk
08:20:43 <thorkilnaur> ndm, (delayed) thanks for the information about your PhD ...
08:23:48 <Nafai> dcoutts: Around?
08:23:57 <dcoutts> hia Nafai
08:24:13 <Nafai> Hey
08:25:04 <Nopik> hi
08:25:27 <Nopik> byorgey: ;)
08:25:31 <Nafai> What do I do if I want to get the location of my status icon so I can pass the x and y coordinates on to the notification system?
08:25:45 <byorgey> hey there Nopik =)
08:25:46 <ndm> @src iterate
08:25:46 <oasisbot> iterate f x =  x : iterate f (f x)
08:26:10 <Nopik> byorgey: my monad got more complex.. changed to stateful version, then tried to combine it with monad transformer, finally ;)
08:27:26 <byorgey> Nopik: yikes, sounds like fun
08:27:27 <vincenz> augustss: ping
08:31:45 <Nafai> Hrm
08:34:02 <Nafai> I haven't felt this clueless in a long time :)
08:38:16 <Nopik> @undo do a<-m1;b<-m2;return $ f a b
08:38:16 <oasisbot> m1 >>= \ a -> m2 >>= \ b -> return $ f a b
08:39:30 <ndm> @type liftM2
08:39:31 <oasisbot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
08:39:41 <ndm> liftM2 f m1 m2
08:39:58 <ndm> that is equivalent
08:40:08 <nominolo_> > "\xe28692"
08:40:08 <oasisbot>  Character constant out of range
08:40:18 <nominolo_> > "\x21"
08:40:19 <oasisbot>  "!"
08:41:04 <nominolo_> > ord (head "?")
08:41:04 <oasisbot>  63
08:41:18 <Nafai> @hpaste
08:41:18 <oasisbot> Haskell pastebin: http://hpaste.org/new
08:41:24 <oasisbot> 64
08:41:38 <nominolo_> > "\u2192"
08:41:38 <oasisbot>  Illegal escape sequence
08:41:52 <hpaste>  Nafai pasted "Trying to figure out Haskell AND Gtk2HS" at http://hpaste.org/1899
08:41:54 <oasisbot> 65
08:42:45 <hpaste>  Nafai annotated "Trying to figure out Haskell AND Gtk2HS" with "Getting this error" at http://hpaste.org/1899#a1
08:42:59 <Nafai> Can someone help me, I don't understand that error message
08:43:04 <Nafai> I'm admit I'm still clueless with Haskell
08:43:25 <dcoutts> Nafai: it says that statusIconIsEmbedded expects a single parameter, the icon
08:43:26 <nominolo_> Nafai: you'r missing an arg
08:43:36 <Nafai> WHOOPS
08:43:38 <Nafai> D'oh
08:43:38 <nominolo_> to statusIconIsEmbedded
08:43:49 <Nafai> wee
08:43:59 <nominolo_> and, btw  punStrLn (show x) == print x
08:44:05 <nominolo_> *put
08:44:06 <Nafai> Thanks!
08:44:14 <dcoutts> Nafai: see how the error message corresponds to that problem?
08:44:53 <dcoutts> Nafai: in that context we expect something of type IO t, but as you've written it, it's something of type self -> IO Bool
08:45:02 <Nafai> Where self is the argument
08:45:04 <dcoutts> ie you've given a function rather than a value
08:45:13 <Nafai> Makes sense
08:45:56 <fxr> :t (>>)
08:45:57 <oasisbot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
08:46:06 <nominolo_> dcoutts: do you happen to know if and how it is possible to draw unicode characters in gtk2hs?
08:46:16 <dcoutts> nominolo_: yep, it just works.
08:46:19 <fxr> :t return
08:46:20 <oasisbot> forall a (m :: * -> *). (Monad m) => a -> m a
08:46:25 <dcoutts> nominolo_: assuming you have the fonts installed
08:46:39 <dcoutts> nominolo_: String is Unicode and Gtk2Hs treats it as such.
08:46:41 <Nafai> Okay...how do I handle statusIconGetGeometry?  It returns IO (Maybe (Rectangle, Orientation))
08:46:48 <nominolo_> dcoutts: i should, i just don't know what the string should look like
08:47:05 <nominolo_> e.g. for this character http://www.fileformat.info/info/unicode/char/2192/index.htm
08:47:06 <oasisbot> Title: Unicode Character 'RIGHTWARDS ARROW' (U+2192)
08:47:17 <dcoutts> nominolo_: copy & paste something from your character map program
08:47:46 <dcoutts> > Char.chr 2129
08:47:47 <oasisbot>  '\2129'
08:48:34 <nominolo_> who, nice
08:48:48 <nominolo_> thanks, that was easy :)
08:48:51 <dcoutts> :-)
08:49:18 <dcoutts> nominolo_: with ghc-6.6 you can put unicode chars into string literals
08:49:32 <dcoutts> rather than saying "foo \2129 bar"
08:49:59 <nominolo_> i see.  emacs handles them well, too.
08:51:17 <vincenz> λσ → κ ρ σ
08:51:39 <dolio> @remember JonHarrop As Haskell has shown, laziness cannot be implemented efficient at all.
08:51:40 <oasisbot> Not enough privileges
08:52:11 <sjanssen> dolio: was that on the mailing list recently?
08:52:13 <Nafai> dcoutts: Any hints?
08:52:28 <dolio> sjanssen: No, from an arduous thread in c.l.functional.
08:52:44 <sjanssen> fun
08:53:08 <dcoutts> Nafai: geom <- statusIconGetGeometry icon; case geom of Nothing -> ...; Just (rect, oreint) -> ...
08:53:23 <dcoutts> Nafai: but don't use ';' use new lines
08:53:26 <dolio> Mainly lisp advocates yelling at him, so I wouldn't recommend reading it. But I'm a masochist in that regard. :)
08:53:43 <Nafai> dolio: I gather Jon Harrop gets yelled at a lot
08:54:11 <dolio> By lisp people, at least. But he has a much longer history with them than with anyone else, I think.
08:54:39 <dolio> From what I gather, he's quite vocal in c.l.lisp about promoting OCaml as a much better alternative to lisp.
08:54:40 <nominolo_> he seems rather all-talk
08:55:29 <sjanssen> he seems unable to RTFM
08:56:06 <vincenz> dolio: link?
08:56:10 <dolio> Although, if the performance in c.l.f is any indication, he has rather more convincing arguments.
08:56:28 <vincenz> The reason he's so vocal about O'Caml is because he wrote a book about it, he's trying to leverage his business.
08:56:51 <roconnor> I thought Haskell's selling point was purity rather than laziness.
08:57:13 <vincenz> roconnor: not to mention type classes, they were the main reason I left O'Caml.
08:57:26 <chessguy> i thought haskell had lots of selling points
08:57:29 <dolio> vincenz: http://groups.google.com/group/comp.lang.functional/browse_thread/thread/7b1ab36f5d5cce0a/899b2291d7779632#899b2291d7779632
08:57:30 <oasisbot> Title: shootout: implementing an interpreter for a simple procedural language Minim - c ..., http://tinyurl.com/2yonaa
08:57:38 <dolio> There's a link into the middle of the thread, if you really want to read it.
08:57:44 <roconnor> chessguy: yep, but random memory usage isn't one of them ;)
08:58:15 <dolio> Anyhow, I often find myself agreeing with him, as his points often apply to Haskell being more enjoyable than Lisp, for me at least.
08:58:20 <chessguy> roconnor,  but both purity and laziness certainly are
08:58:25 <dolio> In addition to OCaml, that is.
08:58:52 <roconnor> I like laziness too, but if the cost is unknown memory usage, then I can understand why some people might balk.
08:59:20 <sorear> laziness prevents premature optimization, not optimization.
09:00:03 <dolio> He seems to have the impression that the solution to any performance problem in Haskell is to make things more strict, though.
09:00:06 <sorear> look at the nhc project; niklaus rojemo was able to make a haskell compiler run in 3MB heap on a 4MB computer (~ 5% of ghc)
09:00:09 <dolio> Which isn't necessarily the case.
09:01:13 <roconnor> sorear: Oh I agree it can be done, but it can be quite difficult. Yesterday I had the following:
09:01:37 <roconnor>   let (Left Done,_,rna) = runDNA (forever step) dna
09:01:37 <roconnor>   printRNA rna
09:01:39 <roconnor> vs
09:01:49 <roconnor>   let (_,_,rna) = runDNA (forever step) dna
09:01:49 <roconnor>   printRNA rna
09:02:24 <roconnor> The first is terrible because the Left Done pattern match forces the loop to run entirely and hold the thunks for the list of RNA in memory
09:02:28 <roconnor> really bad.
09:02:37 <roconnor> but drop that nice sanity check
09:02:41 <roconnor> and presto!
09:02:47 <pejo> sorear, was there any guarantees on memory usage in it?
09:02:51 <roconnor> rna is only demanded by printRNA
09:02:59 <roconnor> and print is a nice consumer.
09:03:10 <dcoutts> thorkilnaur: did that gtk2hs build finish?
09:03:13 <sorear> pejo: No, Haskell is not a proof assistant. :)
09:03:20 <vincenz> roconnor: yes, Haskell can be somewhat fickle like that.
09:03:29 <dolio> roconnor: Well, case in point. Making things less strict saved the day. :)
09:03:41 <sorear> pejo: Besides, Haskell typechecking is in general exponential space.
09:03:43 <vincenz> roconnor: It's a very delicate game between "too strict" and "too lazy".  Sometimes making things too lazy leads to buildups of intermediates that will be required anyways.
09:03:47 <roconnor> dolio: Ha, maybe you are right.
09:04:05 <sorear> :t let{ a = a; b = (a,a); c = (b,b); d = (c,c) } in d
09:04:05 <vincenz> dolio: not always, often you want modifyIORef to be strict,, yet it's lazy in it's value.
09:04:06 <oasisbot> forall t t1 t2 t3 t4 t5 t6 t7. (((t, t1), (t2, t3)), ((t4, t5), (t6, t7)))
09:04:17 <sorear> :t let{ a = a; b = (a,a); c = (b,b); d = (c,c); e = (d,d); f = (e,e) } in f
09:04:18 <oasisbot> forall t t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 t21 t22 t23 t24 t25 t26 t27 t28 t29 t30 t31. (((((t, t1), (t2, t3)), ((t4, t5), (t6, t7))), (((t8, t9), (t10, t11)), ((
09:04:18 <oasisbot> t12, t13), (t14, t15)))), ((((t16, t17), (t18, t19)), ((t20, t21), (t22, t23))), (((t24, t25), (t26, t27)), ((t28, t29), (t30, t31)))))
09:04:35 <oasisbot> Why are you spamming me? Please stop the pain!
09:04:44 <roconnor> but my point is that in a strict langauge, memory useage would be easier to understand (although not necessarily that good).
09:04:45 * nominolo_ just discored an LtU post when he started learning haskell
09:04:52 <dolio> vincenz: Yeah. I just mean it's not an either-or.
09:05:12 <roconnor> heh, oasisbot is a bit more personable.
09:05:30 <vincenz> dolio: That is correct.  I am not arguing against laziness and purity, it enables more optimizations.  But sometimes, the trade-off is rather fickle :)
09:05:36 <pejo> sorear, um, yeah, I think we all agree that space usage depends on input.
09:05:44 <sorear> roconnor: Due strict languages have heap profilers? :D
09:05:48 <dolio> vincenz: Agreed.
09:06:00 <nominolo_> "discored" .. lol
09:06:55 <roconnor> btw, proof assistants don't reason about memory use in general either.
09:06:55 <sorear> pejo: You asked if nhc had space bound guarantees.  I interpreted guarantees as "proof".  Which seems kinda strange to ask of a 10kloc program... :)
09:07:19 <pejo> sorear, proof is always nice. :-)
09:07:24 <roconnor> they allow for both strict and lazy evaluation due to them being strongly normalizing.
09:07:42 <sorear> roconnor: Not in the meta language, but if you define an object language with an operational semantics you can prove all you want about space and time.
09:07:53 <roconnor> sorear: this is true.
09:08:26 <mm_freak> what happened to lambdabot ?!
09:08:47 <sorear> mm_freak: Power outage.
09:08:51 <sorear> @botsnack
09:08:52 <oasisbot> :)
09:09:10 <sorear> vincenz is filling in until dons gets his electricity back.
09:09:22 <mm_freak> well…  `lambdabot' is better =)
09:09:41 <mm_freak> are they the same?
09:10:01 <dolio> They have different state.
09:10:04 <dolio> @quote
09:10:04 <oasisbot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
09:10:18 <Vulpyne> Or lack thereof.
09:10:24 <roconnor> oasisbot is more moody.
09:10:38 <mm_freak> @pl fun x = (fun x)^2
09:10:38 <oasisbot> fun = fix (flip flip 2 . ((^) .))
09:11:10 <mm_freak> @pl fun x = 2^(fun x)
09:11:11 <oasisbot> fun = fix ((2 ^) .)
09:11:48 * oasisbot hugs roconnor
09:11:51 <mm_freak> @pl x a b = x^2 + a*x + b
09:11:52 <oasisbot> x = fix (((+) .) . ap ((.) . (+) . (^ 2)) (*))
09:12:12 <vincenz> sorear: it's actually Lemmih's box.
09:12:24 * roconnor pats oasisbot
09:12:24 <mm_freak> :t x a b = x^2 + a*x + b
09:12:25 <oasisbot> parse error on input `='
09:12:32 <mm_freak> :t x^2 + a*x + b
09:12:33 <oasisbot> Not in scope: `x'
09:12:33 <oasisbot>  
09:12:33 <oasisbot> <interactive>:1:6: Not in scope: `a'
09:12:36 <thorkilnaur> dcoutts, Bad news, helloworld says "Bus error". configure+make+install+installcheck logs coming up ...
09:13:43 <vincenz> :t \a b b-> x^2 +a*x + b
09:13:44 <oasisbot>     Conflicting definitions for `b'
09:13:44 <oasisbot>     In a lambda abstraction
09:13:47 <vincenz> :t \a b -> x^2 +a*x + b
09:13:48 <oasisbot> Not in scope: `x'
09:13:48 <oasisbot>  
09:13:48 <oasisbot> <interactive>:1:15: Not in scope: `x'
09:13:52 <vincenz> :t \x a b -> x^2 +a*x + b
09:13:53 <oasisbot> forall a. (Num a) => a -> a -> a -> a
09:14:28 <jyp> @bot
09:14:28 <oasisbot> :)
09:14:36 <mm_freak> @botblah
09:14:36 <oasisbot> Unknown command, try @list
09:14:52 <mm_freak> @botsnack
09:14:52 <oasisbot> :)
09:14:54 <roconnor> time for dinner.
09:16:51 <Nafai> Is there an example somewhere of System.Cmd.system that I can look at?
09:18:44 <sorear> :t System.system
09:18:45 <oasisbot> String -> IO GHC.IOBase.ExitCode
09:18:54 <sorear> :t System.system "ls"
09:18:55 <oasisbot> IO GHC.IOBase.ExitCode
09:19:31 <Nafai> sorear: I'm trying to use it in a do loop and "Couldn't match expected type `()'
09:19:31 <Nafai>            against inferred type `GHC.IOBase.ExitCode'"
09:19:50 <Nafai> do loop probably isn't the write term for it
09:19:57 <Nafai> Within a "do" or..
09:19:59 <sorear> Nafai: Add a return () then.
09:20:01 <Nafai> How do I say that?
09:20:06 <sorear> do block?
09:20:16 <Nafai> Yes, that's what I meant
09:20:32 <Nafai> Yay!
09:20:53 <Nafai> My code works
09:21:49 <hpaste>  Nafai annotated "Trying to figure out Haskell AND Gtk2HS" with "Working" at http://hpaste.org/1899#a2
09:22:11 <Nafai> dcoutts: Got a minute?
09:22:14 <fasta> Does the Identity monad exist at run-time?
09:23:34 <sorear> fasta: The Identity constructor is erased because it's a newtype.
09:23:57 <thorkilnaur> dcoutts, Logs: http://thorkilnaur.dk/~tn/Gtk2Hs/buildlogs/Gtk2Hs_20070727_1817.tar.gz
09:23:58 <oasisbot> http://tinyurl.com/2vk368
09:24:53 <dcoutts> thorkilnaur: oh dear :-)
09:27:16 <dcoutts> thorkilnaur: the logs look perfect, no clue there
09:27:59 <dcoutts> Nafai: what's the issue?
09:28:12 <Nafai> dcoutts: It works, but not I want to make it useful :)
09:29:07 <Nafai> Since I can't listen using d-bus (at the moment) like my old Python script did, how would you suggest I go about having this listen on a named pipe for commands?
09:29:07 <dcoutts> thorkilnaur: would you mind running helloworld under gdb and seeing if the backtrace indicates if we're in C code or Haskell code at the time?
09:30:38 <dcoutts> Nafai: you might want to look at some irc clients written in Haskell, and change the network socket for a unix domain socket
09:30:41 <thorkilnaur_> dcoutts: I have some gdb output, can you set up a separate channel for thorkilnaur_  ?
09:31:31 <Nafai> dcoutts: Would I have to do the listening in another thread?
09:31:41 <dcoutts> Nafai: that's a common strategy
09:31:57 <dcoutts> thorkilnaur: oops :-)
09:32:38 <dcoutts> Nafai: though you can of course multiplex all the requests into a single channel/thread
09:33:28 <Nafai> Is there an example somewhere I can look at? (Not necessarily of the network stuff)
09:34:48 <Vulpyne> http://sequence.complete.org/node/258
09:34:50 <oasisbot> Title: A simple TCP server | The Haskell Sequence
09:35:05 <dcoutts> Nafai: http://haskell.org/haskellwiki/Roll_your_own_IRC_bot
09:35:06 <oasisbot> Title: Roll your own IRC bot - HaskellWiki
09:35:13 <Vulpyne> http://sequence.complete.org/node/257
09:35:14 <oasisbot> Title: A simple TCP client | The Haskell Sequence
09:35:27 <thorkilnaur_> dcoutts: Could you reconnect, please?
09:36:10 <dcoutts> thorkilnaur_: do you get my privmessages?
09:36:26 <thorkilnaur_> Yes
09:36:28 <dcoutts> ok
09:36:41 <dcoutts> or you could use @paste
09:36:45 <dcoutts> @paste
09:36:45 <oasisbot> Haskell pastebin: http://hpaste.org/new
09:37:05 <thorkilnaur_> dcoutts: Do you get mine?
09:37:15 <dcoutts> thorkilnaur_: no
09:37:33 <dcoutts> thorkilnaur_: it'll be because you're using an unregistered nick
09:37:57 <hpaste>  fxr pasted "state problem" at http://hpaste.org/1900
09:38:06 <Vulpyne> Hmm. That simple bot source doesn't have any concurrency, does it?
09:39:40 <thorkilnaur> dcoutts: Try again without the _
09:41:37 <sjanssen> Vulpyne: no, it doesn't
09:42:07 <Vulpyne> I guess it works well enough for IRC that way.
09:42:19 <dcoutts> thorkilnaur__: try http://hpaste.org/new instead
09:42:24 <dcoutts> thorkilnaur: try http://hpaste.org/new instead
09:42:50 <Nafai> dcoutts: Thanks
09:42:53 <thorkilnaur> dcoutts: Sorry, should have long ago ...
09:44:42 <hpaste>  thorkilnaur pasted "gdb output for Gtk2Hs demo helloworld" at http://hpaste.org/1901
09:45:20 <thorkilnaur> dcoutts: I ran the GTK+ tutorial base and helloworld programs OK
09:45:36 <dcoutts> thorkilnaur: I've seen things like this before
09:45:58 <dcoutts> thorkilnaur: the pango/fc stuff seems to be the most sensitive to memory corruption
09:46:53 <dcoutts> thorkilnaur: so the C hello world was fine you say?
09:47:19 <dcoutts> thorkilnaur: btw, where did you get your Gtk+ from ?
09:48:01 <thorkilnaur> dcoutts: I installed gtk+-2.10.14 from gtk.org, but dependent packages (like pango and others) were on my machine already, origin probably mac/darwin ports or the Apple X-tools installation CD
09:48:51 <nominolo_> i had this kind of problem
09:49:04 <dcoutts> nominolo_: did we ever figure it out?
09:49:17 <nominolo_> not why, but i found a fix
09:49:30 <nominolo_> i had to specify -L/opt/local/lib
09:49:44 <dcoutts> ah, you had multiple versions of the libs installed
09:49:44 <thorkilnaur> dcoutts: Yes, I ran the first couple of C programs from the GTK+ tutorial (http://www.gtk.org/tutorial/) and they seemed to work fine.
09:49:52 <nominolo_> but i still have no idea why it picked up the wrong deps
09:50:01 <nominolo_> yes, i did
09:50:10 <dcoutts> thorkilnaur: you don't have multiple gtk/pango installations by any chance?
09:50:47 <thorkilnaur> dcoutts: Good question, I'll check something, in the meantime, tell me how to check ...
09:51:35 <mm_freak> @src filter
09:51:35 <oasisbot> filter _ []     = []
09:51:36 <oasisbot> filter p (x:xs)
09:51:36 <oasisbot>     | p x       = x : filter p xs
09:51:36 <oasisbot>     | otherwise = filter p xs
09:51:36 <nominolo_> do you have apt-get _and_ port ?
09:52:03 <dcoutts> thorkilnaur: I'm not sure really, try locate libgtk-x11-2.0.so
09:52:22 <dcoutts> erm it wouldn't be .so, drop the suffix
09:52:31 <mm_freak> isn't the definition "filter p xs = [x | x <- xs, p x]" faster?
09:52:48 <dcoutts> mm_freak: what do you think [x | x <- xs, p x] translates into?
09:53:13 <nominolo_> better try just: locate libgtk
09:53:20 <mm_freak> a list of all elements from xs, for which (p x) is true
09:53:34 <mm_freak> but i think, it's translated into monadic operations
09:53:55 <nominolo_> mm_freak: no, only in wadler's paper ;)
09:54:21 <nominolo_> mm_freak: monad comprehensions didn't make it into the standard
09:54:39 <mm_freak> well, it looks fairly monadic =)
09:54:47 <dcoutts> mm_freak: so it desugars into a local recursive function, much like your definition of filter
09:55:16 <mm_freak> dcoutts: i just thought that my definition is a lot simpler, hence easier to optimize
09:55:19 <byorgey> mm_freak: it is, just not officially =)
09:55:22 <thorkilnaur> Thorkil-Naurs-Computer:/ thorkilnaur$ locate libgtk
09:55:23 <thorkilnaur> Thorkil-Naurs-Computer:/ thorkilnaur$
09:55:31 <dcoutts> mm_freak: btw, @src give spec-style code, not optimial code, you can make filter inline better by hoisting the p out of the loop
09:55:59 <mm_freak> lambdabot gave GHC-specific code
09:56:02 <dcoutts> thorkilnaur: osx must do it differently. what does your gtk thingie .dynlib look like?
09:56:10 <nominolo_> thorkilnaur: weird
09:56:27 <thorkilnaur> Oh, something's missing, I'll use hpaste. Or rather, I'll just tell you: Only something matching darwinports database files were mentioned.
09:56:30 <nominolo_> on my computer it spits out lots of lines
09:57:03 <dcoutts> mm_freak: perhaps, but it certainly doesn't give the actual code that ghc uses
09:57:06 <dcoutts> @src foldr
09:57:06 <oasisbot> foldr k z xs = go xs
09:57:06 <oasisbot>     where go []     = z
09:57:06 <oasisbot>           go (y:ys) = y `k` go ys
09:57:27 <dcoutts> hmm, not a good example
09:57:39 <thorkilnaur> nominolo_:  I installed gtk in my $HOME/tn/install directory using the Unix (I guess)-convention
09:58:03 <thorkilnaur> So MacPorts doesn't know about it.
09:58:51 <mm_freak> dcoutts: however, can i safely assume that the list comprehension-based definition is equivalent to the fastest general purpose definition?
09:59:03 <dcoutts> mm_freak: no
09:59:13 <dcoutts> mm_freak: it's probably pretty close
09:59:19 <mm_freak> the fastest general purpose definition using lists =)
09:59:26 <dcoutts> still no
09:59:39 <mm_freak> hmm…  i can't imagine any faster method
10:00:11 <nominolo_> stream fusion
10:00:19 <dcoutts> mm_freak: these definitions are all equivalent to a first approximation, the difference are to do with static optimisations like inlining and fusion
10:00:19 <mm_freak> the fastest general purpose definition using lists, where no further information than the list to be filtered is available
10:00:20 <nominolo_> @go stream fusion
10:00:21 <oasisbot> http://eprints.pascal-network.org/archive/00000759/
10:00:24 <thorkilnaur> dcoutts: Again, I'll have to run and do more tomorrow. But I'll look into differences in the link processes as the first possibility of a problem.
10:00:52 <dcoutts> thorkilnaur: ok, I'm going to release the current code as 0.9.12, if we find any fixes we can make a point release
10:01:03 <dcoutts> thorkilnaur: thanks for giving it a spin
10:01:10 <mm_freak> dcoutts: besides how it is translated into actual code
10:01:19 <sjanssen> filter p ys = build (\c n -> foldr (\x xs -> if p x then x `c` xs else xs) n ys) -- the fastest definition in GHC today
10:01:41 <nominolo_> @go stream fusion haskell
10:01:42 <oasisbot> Plugin `search' failed with: IRCRaised <socket: 13>: hLookAhead: resource vanished (Connection reset by peer)
10:01:46 <mm_freak> hmm
10:02:03 <nominolo_> no power in australia
10:02:12 <dcoutts> mm_freak: ok, so it depends on your definition of fast, wall clock with ghc, or some more abstract definition
10:03:01 <nominolo_> mm_freak: http://lambda-the-ultimate.org/node/2192
10:03:02 <oasisbot> Title: Stream Fusion | Lambda the Ultimate
10:03:14 <vincenz> What do you people think of jon harrop?
10:03:44 <mm_freak> dcoutts: more abstract…  i want to filter a list and search for elements is O(n)
10:03:57 <dcoutts> mm_freak: ok, then they're all equivalent
10:04:02 <sjanssen> mm_freak: all of the improvements we're talking about are merely constant factors
10:04:03 <nominolo_> vincenz: see logs
10:04:12 <mm_freak> k, thanks
10:04:38 <sjanssen> mm_freak: note that it's a bit tricky to assign O values to lazy producer/consumers like filter
10:05:00 <mm_freak> are there any probabilistic sorting algorithms, which are unlikely to produce wrong results, and are much faster than quicksort/merge sort?
10:05:07 <mm_freak> for random unsorted lists that is
10:05:08 <vincenz> nominolo_: today?
10:05:12 <vincenz> nominolo_: not much was mentioneed
10:06:12 <sjanssen> grep -i harrop 07.07.*
10:06:50 <nominolo_> vincenz: yes not much.  but then again, we're no tabloid journalist cafe, are we? ;)
10:07:57 <mm_freak> sjanssen: i'd say that searching for an element in a random finite list with n elements is O(n)…  where would that statement fail?
10:08:41 <nominolo_> what is n for an infinite list?
10:08:43 <vincenz> nominolo_: Let me rephrase, only one comment, afaics, was mentioned.  Just curious what people's views are.  But very well.
10:08:47 <sjanssen> mm_freak: actually, filter is mostly safe
10:08:59 <mm_freak> considering that one `step' is a comparison, of course, i.e. ignoring the fact that _calculating_ the list may be more complex
10:09:09 <sjanssen> because we must assume that anything like 'head . filter p' is O(n)
10:09:16 <mm_freak> nominolo_: infinity
10:09:23 <sjanssen> mm_freak: map is a better example
10:13:32 <Nafai> If I want look at a type of a function from the Prelude in ghci, how do I do that?  I can't do an "import System.IO"
10:13:58 <dylan> :m + System.IO
10:14:32 <Nafai> dylan: Thanks!
10:16:03 <Nafai> I'm looking at this: http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/IO ... what is "bracket" that's being used in the examples?
10:16:49 <allbery_b> @index bracket
10:16:49 <oasisbot> Control.Exception, Distribution.Compat.Exception, Graphics.HGL.Draw.Monad, Graphics.HGL.Draw, Graphics.HGL.Core, Graphics.HGL
10:16:58 <allbery_b> it's the first one
10:17:33 <Nafai> allbery_b: Is it implicitly imported or something?
10:17:56 <Nafai> Oh duh
10:18:50 <pjd> people have no taste! (http://programming.reddit.com/info/29w90/comments)
10:18:51 <oasisbot> Title: Mob Software: The Erotic Life of Code (by Richard P. Gabriel & Ron Goldman) (red ...
10:23:02 <hpaste>  aaim pasted "Haskelly enough??" at http://hpaste.org/1905
10:23:47 <dolio> That's a lot of errors. :)
10:25:32 <hpaste>  dolio annotated "Haskelly enough??" with "small change" at http://hpaste.org/1905#a1
10:32:38 <dino-> Does this load for anyone: http://www.cse.unsw.edu.au/~dons/data/Prelude.html
10:33:10 <dolio> dons doesn't have any power, reportedly.
10:33:12 <sorear> dino-: unsw has no power currently
10:33:15 <dolio> Hence the absense of lambdabot.
10:33:58 <byorgey> hm, unsw.edu.au works
10:34:17 <byorgey> maybe that's served from a different place
10:36:18 <dino-> bah
10:36:21 <dino-> thank you
10:36:51 <nominolo_> > Just 3 `mappend` Just 2
10:36:53 <oasisbot>   add an instance declaration for (Monoid (Maybe t))
10:36:53 <oasisbot>     In the expression: (...
10:36:59 <dino-> I'm about to give a simple Haskell intro talk at my job.
10:37:56 <nominolo_> @check \x y z -> x `mplus` (y `mplus` z) == (x `mplus` y) `mplus` z
10:37:57 <oasisbot>        add an instance declaration for (Arbitrary (m a), Show (m a))     In t...
10:38:09 <nominolo_> @check \x y z -> (x :: Maybe Int) `mplus` (y `mplus` z) == (x `mplus` y) `mplus` z
10:38:11 <oasisbot>  OK, passed 500 tests.
10:39:41 <byorgey> dino-: neat.
10:43:27 <ndm> dino-: put the slides online :)
10:51:34 <dino-> ndm: I don't have slides, but a simple web page to rough follow and elaborate on: http://ui3.info/d/haskell-intro.html
10:51:35 <oasisbot> Title: Haskell introduction
10:52:40 <dino-> It's supposed to be about an hour, less or more is ok. Not very formal. And the audience here I believe has no experience with anything functional at all.
10:53:11 <dino-> They've already looked pretty horrified at the hallway Haskell talking I've done over the past few months.
10:53:24 <dino-> But some interested parties also.
10:54:12 <dino-> The really interesting thing is that they're letting a co-worker and I experiment with building a service with happs.
10:56:02 <sjanssen> neat
10:56:55 <sjanssen> dino-: by the way, xmonad is a bit larger that 10% of dwm
10:57:12 <sjanssen> dwm is something like 1700, xmonad is about 700 lines of code
10:57:34 <dino-> sjanssen: wow, I was under the impression it was ~ 4000 -> < 500
10:57:48 <dino-> sjanssen: Thank you. I'll change that to something less explicit.
10:59:12 <sjanssen> dino-: remember that dwm is incredibly tiny for a C WM
10:59:32 <sjanssen> wmii, for example, is almost 9000 lines
11:00:49 <ddarius> sjanssen: What would the stats be if you did not count the quick check code?
11:01:06 <ddarius> @botsnack
11:01:07 <oasisbot> :)
11:01:12 <ddarius> @src Num
11:01:12 <oasisbot> class  (Eq a, Show a) => Num a  where
11:01:12 <oasisbot>     (+), (-), (*)           :: a -> a -> a
11:01:12 <oasisbot>     negate, abs, signum     :: a -> a
11:01:12 <oasisbot>     fromInteger             :: Integer -> a
11:01:20 <sjanssen> ddarius: I'm not counting the QCs
11:01:33 <sorear> ddarius: We already don't count QC, blank lines, and comments.
11:01:38 <ddarius> Ah.
11:01:43 <sjanssen> ddarius: we have 419 lines of testing code
11:01:48 <sorear> ddarius: xmonad is over 50% blank and comments.  dwm is <10% :)
11:01:51 <ddarius> @src Fractional
11:01:52 <oasisbot> class  (Num a) => Fractional a  where
11:01:52 <oasisbot>     (/)             :: a -> a -> a
11:01:52 <oasisbot>     recip           :: a -> a
11:01:52 <oasisbot>     fromRational    :: Rational -> a
11:03:04 <dino-> Ok, I just vagued it up to say "dramatically less source code"
11:03:18 <dino-> sjanssen: thanks again, no idea why I was so sure of that number.
11:04:00 * ddarius finds these instance declarations cute.
11:04:06 <ddarius> (*) = Z 0 0 0 1 1 0 0 0
11:06:17 <edwardk> ddarius: ?
11:06:18 <dino-> I've wondered about that, when we count loc in general, is it by discarding blanks? comments?
11:06:43 <dino-> there's probably no answer to that, merely that you do similar things when comparing two things
11:07:27 <sorear> usually you ignore both, to avoid penalizing literate programmers :)
11:08:12 <dino-> And just ignore stuff like curlies on thier own lines.
11:09:31 <ddarius> edwardk: z(x,y) = (a + bx + cy + dxy)/(e + fx + gy + hxy)
11:09:44 <sorear> you might want to look at 'sloccount', which has become something of a defacto standard
11:10:30 <SamB> sloccount?
11:10:37 <ddarius> @google sloccount
11:10:39 <oasisbot> http://www.dwheeler.com/sloccount/
11:10:39 <oasisbot> Title: SLOCCount
11:10:41 <SamB> that is the number of lines of silly code?
11:10:51 <ddarius> "source" I believe
11:11:11 <SamB> who says what's source and what isn't?
11:11:19 <ddarius> SamB: The compiler.
11:11:27 <SamB> what is a compiler?
11:11:36 <SamB> and what if you are writing in Python?
11:12:19 <ddarius> Okay let me try a different tack, David Wheeler.
11:12:19 <dino-> sorear: cool, thanks
11:12:27 <SamB> I'm serious
11:12:32 <SamB> what counts as a compiler?
11:12:46 <dolio> If you're writing Python, you replace "compiler" with "interpreter".
11:12:56 <ddarius> SamB: Okay, "implementation"
11:13:00 <SamB> dolio: yeah, I was a bit less serious about that part
11:13:37 <SamB> but if you have a tool that you use, that happens to generate code, how do you tell if it counts as a compiler or not?
11:13:49 <sorear> SamB: @poll-add
11:14:07 <SamB> I don't know what the choices should be for such a poll
11:14:19 <sorear> Yes, No
11:14:27 <ddarius> SamB: There are some things that definitely fall into compiler, and somethings that definitely don't, and somethings that are in a fuzzy area in between.
11:14:50 <SamB> ddarius: hmm. seems reasonable.
11:15:11 <SamB> so does that mean your sloc has an upper bound, a lower bound, and a gray area in between?
11:15:48 <sorear> Is GHC a compiler?  It represents expressions at run time, so in my view it's a generator of specialized interpreters. :)
11:15:51 <ddarius> Do interpreters and compilers for the same language accept different languages?
11:16:10 <augustss> by definition, no :)
11:16:12 <SamB> okay, forget I mentioned python or interpreters
11:18:13 <ddarius> Anyway, I need to return to work.
11:19:03 * dolio doesn't see the point of contention.
11:19:11 <SamB> but still. if I have a file which lists patterns for matching various machine instructions, along with some other info which can be used to figure out what C functions should be used to implement them and generate the switch statement for an emulation core...
11:19:17 <dolio> Are we wondering whether comments count as source because, say, haddock makes use of them?
11:19:18 <SamB> does that count as a compiler?
11:20:05 <SamB> dolio: that is another issue ;-)
11:20:23 <dino-> I want to say that's pedantic except that deprecation information goes into the comments. Which is used by the compiler, no?
11:20:41 <SamB> dino-: isn't that pragmas?
11:20:54 <dino-> Ah, I didn't know. Have not done any deprecation myself.
11:20:59 <dolio> Does GHC warn about deprecated functions?
11:21:08 <dolio> Or are we talking Java?
11:21:11 <SamB> dolio: if you mark them with the appropriate pragma
11:21:12 <dino-> Perhaps I inappropriately confuse this with Java, which does deprecate through comment notation.
11:21:34 <dino-> No, I'm perilously close to getting myself banished for confusing this with Java.
11:21:38 <SamB> dino-: pragmas *do* happen to look an awful lot like comments in Haskell
11:21:45 <sorear> SamB: is http://research.microsoft.com/~simonpj/papers/slpj-book-1987/slpj-book-1987.djvu a compiler?
11:21:46 <oasisbot> http://tinyurl.com/2sbcqn
11:22:00 <SamB> sorear: I don't think so
11:22:20 <SamB> I can't run djvu to create programs from source code can I?
11:22:30 <sorear> it describes in near-formal detail how to translate Miranda into VAX machine code.
11:22:30 <dino-> For some reason they were historically hostile to the whole idea of preprocessor-ish anything in Java until that annotation business came along.
11:22:46 <SamB> sorear: perhaps if you pointed to the source tarball I would say something different ;-)
11:24:07 <SamB> maybe that thing has OCR info, though, in which case I suppose you could use it to reconstruct the Miranda code at least...
11:24:39 <SamB> unforunately the thing isn't bootstrapped
11:28:31 * Nafai looks at SPJ's OSCON slides
11:38:26 <dino-> I would like to have gone to OSCON and attended these SPJ things.
11:38:29 <dino-> liked
11:44:30 <sorear> @go spj oscon slides
11:44:32 <oasisbot> http://use.perl.org/journal.pl?op=display&uid=1505&start=20
11:44:32 <oasisbot> Title: Journal of autrijus (1505)
11:54:13 <ddarius> Did andyjgill get the SPJ video(s) up yet?
11:54:48 <mrd> @logs
11:54:49 <oasisbot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
11:58:03 <elliottt> @ty PortID
11:58:05 <oasisbot> Not in scope: data constructor `PortID'
11:59:06 <monochrom> @type Network.Socket.PortID
11:59:07 <oasisbot>     Not in scope: data constructor `Network.Socket.PortID'
11:59:26 <elliottt> @ty PortNumber
11:59:27 <oasisbot> Not in scope: data constructor `PortNumber'
11:59:39 <elliottt> @ty Network.PortNumber
11:59:40 <oasisbot> Network.Socket.PortNumber -> Network.PortID
11:59:44 <elliottt> ah, there we go :)
12:01:14 <andyjgill> No SPJ video yet .. sorry. Its in the hands of someone converting from tape to digital media.
12:04:12 <ddarius> andyjgill: Just making sure in case I had missed the announcement, though I imagine you'll announce on one of the mailinglists as well.
12:08:10 <shapr> Yay OSCON!
12:08:20 <icarroll> @seen lambdabot
12:08:20 <oasisbot> lambdabot is in #oasis. I last heard lambdabot speak 4d 8h 11m 29s ago.
12:09:20 <sorear> vincenz: @seen is broken
12:11:29 --- mode: ChanServ set +o glguy
12:12:34 --- topic: set to '["OSCON Video announcement _placeholder_","The Haskell programming language: got types?","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","The language of ICFP winners 3 years running"]' by glguy
12:12:47 --- mode: glguy set -o glguy
12:13:33 <shapr> Oh, who won?
12:14:21 <dolio> Won what?
12:14:36 * sjanssen won
12:15:23 <sjanssen> oh, if you're talking about ICFP, I didn't win that
12:15:25 <shapr> Who won ICFPc?
12:15:38 <dolio> Oh. "3 years running" is from last year.
12:15:38 <shapr> I just noticed that glguy put "language of ICFP winners three years running"
12:15:42 <shapr> oh
12:15:52 <dolio> I don't think they've annouced this year yet.
12:16:01 <sjanssen> glguy: where are the OSCON videos!?!?!
12:16:13 <sjanssen> > cycle "!?"
12:16:15 <oasisbot>  "!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!...
12:16:42 <shapr> Has anyone seen a DNS server in Haskell?
12:17:05 <ddarius> I think someone did make one at one point.  It wouldn't be hard at any rate.
12:17:20 <shapr> I have this idea for an email replacement...
12:17:29 <roconnor> yay!
12:17:36 * roconnor hates email
12:17:38 <bartw> through dns ? :)
12:17:42 <shapr> bartw: exactly!
12:17:52 <bartw> thats.... evil, probably
12:17:55 <shapr> bartw: SPF is the right idea, but it doesn't go far enough!
12:17:57 <roconnor> you guys saw TCP over DNS?
12:18:06 <shapr> Yeah, TCP over DNS looks way cool.
12:18:27 <bartw> i prefer ip over ip over ip over ip over ip over ip
12:18:56 * roconnor perfers UM over UM over UM over UM.
12:18:58 <bartw> for that high reliability connection stuff
12:19:32 <sjanssen> fix (over ip)
12:19:49 <roconnor> fix (`over` ip)
12:20:17 <shapr> asonetuh: Greetings Dvorak user!
12:20:22 <asonetuh> :)
12:20:25 * monochrom contemplates java over linux over vmware over windows over vmware over macosx over vmware over ibm s/390
12:20:27 <asonetuh> Woah. Someone actually knows.
12:20:43 <monochrom> haha
12:20:43 <bartw> is that like qwerty then ?
12:20:55 <asonetuh> I am kinda lost here, looking for help in starting Haskell.
12:21:01 <bartw> Yuiop
12:21:05 <asonetuh> I am only experienced with Python...
12:21:12 <asonetuh> And would like something different.
12:21:15 <shapr> asonetuh: You found the right place!
12:21:16 <glguy> asonetuh: ask away :)
12:21:20 <Magotari> OK...
12:21:21 <roconnor> good choice
12:21:22 <monochrom> I know how to convert Python list comprehension to Haskell.
12:21:24 <icarroll> shapr: indeed :)
12:21:41 <Magotari> So... any tutorials you can recommend?
12:21:46 * glguy preempts
12:21:52 <glguy> ?quote stereo
12:21:52 <oasisbot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
12:21:52 <shapr> What about Yet Another Haskell Tutorial ?
12:21:56 <glguy> :(
12:22:02 <Magotari> Requires pdf.
12:22:03 <shapr> What's down with lambdabot?
12:22:08 <Magotari> I have a very bare gentoo installation here.
12:22:09 * dolio is tired of 'quote stereo'
12:22:15 <monochrom> The Haskell wikibook. http://en.wikibooks.org/wiki/Haskell
12:22:16 <oasisbot> Title: Haskell - Wikibooks, collection of open-content textbooks
12:22:16 <sjanssen> shapr: power outage at UNSW
12:22:20 <roconnor> ah Cale must be happy now that his quote is gone.
12:22:21 <glguy> shapr: lambdabot is suffering from scheduled power outage
12:22:26 * roconnor ob beep Cale.
12:22:29 <shapr> Magotari: http://en.wikibooks.org/wiki/Haskell/YAHT/Preamble
12:22:30 <oasisbot> Title: Haskell/YAHT/Preamble - Wikibooks, collection of open-content textbooks
12:22:32 <Nafai> shapr!
12:22:33 <Magotari> Aha. Thanks for that one. I will look at it.
12:22:35 <shapr> Nafai!
12:22:58 <Magotari> I find the idea of fuctional languages very strange, but... Want to try them.
12:23:07 <shapr> Python can be functional.
12:23:08 <Nafai> I started my first Haskell program!
12:23:18 <shapr> Nafai: Cool! What is it? The port of that python utility?
12:23:19 <Magotari> I cannot talk right now, but I am glad I found a right place. I will come back here.
12:23:27 <Magotari> Thank you, #haskell
12:24:04 <Nafai> shapr: Yeah.  First version: http://hpaste.org/1899#a2
12:24:18 <Nafai> shapr: Obviously, not useful just yet :)
12:24:34 * roconnor wonders if Magotari was just doing quality assurance for #haskell
12:24:40 <shapr> Nafai: cute!
12:24:43 <shapr> roconnor: If so, we passed.
12:25:18 <Nafai> shapr: Now to get ERC to talk to it and trigger the event, instead of a mouse click
12:25:33 <shapr> Could you use dbus?
12:25:41 <shapr> I think there's a Haskell-dbus binding.
12:25:49 <glguy> roconnor: maybe dons hired a secret shopper
12:27:01 <roconnor> glguy: exactly what I was thinking
12:27:11 <roconnor> I didn't know if shopper was a well known term.
12:27:13 <Nafai> shapr: Unfortunately the d-bus bindings are not mature enough
12:27:24 <roconnor> I would have said ``maybe we've been shopped''
12:27:24 <Botje> roconnor: #haskell got the Magotari (r)(c)(tm) seal of approval!
12:27:33 <shapr> Nafai: You could fix 'em?
12:27:56 <sjanssen> Nafai: adding support for a named pipe should be pretty easy
12:27:59 <shapr> Ya know, scratch your own itch and all that.
12:28:26 <Nafai> shapr: In my Python version that's what I do.  Tray Icon listens via d-bus.  I have another utility that listens on std-in and interprets commands given and the talks to the tray icon via d-bus
12:28:39 <Nafai> In ERC, I open up a process to the std-in listener and write appropriate commands
12:28:45 <Nafai> sjanssen: Yeah, that's what I was thinking
12:29:20 <ddarius> I guess it was a good thing I wasn't looking when Magotari was around.
12:30:19 <Nafai> sjanssen: Would I just open it as a normal file or do I have to do something special?
12:30:31 <sjanssen> Nafai: just a normal file
12:30:48 <Nafai> sjanssen: I'm guessing I'd do a mkfifo(1) before launching my app and then open that
12:30:58 <Nafai> And then have ERC open that file for writing
12:32:04 <njd> @users
12:32:04 <oasisbot> Maximum users seen in #haskell: 422, currently: 351 (83.2%), active: 13 (3.7%)
12:32:38 <sjanssen> whoa, when did 422 happen?
12:32:43 <sjanssen> that must not be right
12:32:51 * ddarius forgot to put his hat in the washer.
12:33:02 <njd> /priv oasisbot
12:33:02 <ddarius> Oh well.  I needed to buy a new one anyways.
12:33:36 <dcoutts> @yarr!
12:33:36 <oasisbot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
12:33:42 <dcoutts> nooes!
12:34:10 <Igloo> heh
12:34:12 <sjanssen> Something about Jenny's tea cup.  Arr.
12:34:17 <dcoutts> Gtk2Hs-0.9.12 is out! http://haskell.org/gtk2hs/download/
12:34:17 <oasisbot> Title: Gtk2Hs  Download
12:34:23 <Nafai> dcoutts: Congrats!
12:34:31 <dcoutts> sjanssen: thanks :-) makes me feel much better
12:35:10 <njd> @where lambdabot
12:35:11 <oasisbot> Right here! Seriously, though: http://www.cse.unsw.edu.au/~dons/lambdabot.html
12:35:27 <ddarius> oasisbot: You lie!
12:35:48 <dcoutts> @seen nometa
12:35:49 <oasisbot> I haven't seen nometa.
12:35:53 <njd> @help
12:35:53 <oasisbot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:35:56 <njd> @list
12:35:57 <oasisbot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
12:38:25 <njd> > pt liftIO $ hPrintf stderr
12:38:26 <oasisbot>   Not in scope: `stderr'
12:38:42 <njd> > pt liftIO $ hprintf
12:38:42 <oasisbot>   Not in scope: `hprintf'
12:38:55 <njd> > pt liftIO $ hPrintf
12:38:55 <oasisbot>   Not in scope: `pt'
12:39:08 <sjanssen> njd: IO is not allowed
12:39:14 <mathewm> anyone have a mirror of fps 0.7?
12:39:46 <sjanssen> mathewm: no, but I have various copies of the darcs repo
12:40:07 <sjanssen> including a fairly up-to-date version of the new 'bytestring' repo
12:40:36 <njd> just wanted to see if there was a point form  of something that I'm working on - trying to use hPrintf inside a monad (which is instance of MonadIO) and having some trouble
12:40:47 <njd> @help point
12:40:47 <oasisbot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:40:58 <njd> :help .
12:41:13 <sorear> @pr
12:41:13 <oasisbot> Maybe you meant: pretty print-notices protontorpedo pl
12:41:15 <sjanssen> njd: do you mean '@pl'?
12:41:16 <mathewm> sjanssen: have a URL I can hit?
12:41:16 <sorear> @pl
12:41:16 <oasisbot> (line 1, column 1):
12:41:16 <oasisbot> unexpected end of input
12:41:16 <oasisbot> expecting white space, natural, identifier, lambda abstraction or expression
12:41:24 <sorear> @pl liftIO hPrintf
12:41:24 <oasisbot> liftIO hPrintf
12:41:29 <sorear> @unpl liftIO hPrintf
12:41:29 <oasisbot> liftIO hPrintf
12:41:53 <sorear> @pl \fmt a b c -> liftIO (hPrintf a b c)
12:41:54 <oasisbot> const (((liftIO .) .) . hPrintf)
12:42:03 <sorear> @pl \fmt a b c -> liftIO (hPrintf fmt a b c)
12:42:04 <oasisbot> (((liftIO .) .) .) . hPrintf
12:42:57 <monochrom> @type hPrintf
12:42:58 <oasisbot> forall r. (HPrintfType r) => GHC.IOBase.Handle -> String -> r
12:43:26 <monochrom> OK, liftIO (hPrintf myhandle "%d %s" 5 "hello") is an example.
12:43:45 <sjanssen> mathewm: I'll have a link in a few minutes
12:44:52 <dcoutts> liyang: ping
12:45:48 <sjanssen> mathewm: http://darcs.haskell.org/~sjanssen/bytestring/
12:45:52 <oasisbot> Title: Index of /~sjanssen/bytestring
12:46:01 <dcoutts> sjanssen: what's that?
12:46:02 <Randroid> Does anyone think that those who grok Haskell are better programmers overall than those who do not? Not only because they've learned Haskell, but because they *can* learn Haskell.
12:46:31 <sjanssen> dcoutts: a mirror of dons' bytestring repo
12:46:33 <dcoutts> Randroid: bear in mind you're asking a crowd of Haskell coders :-)
12:46:46 <Randroid> dcoutts: Oh, I understand. :)
12:46:46 <sjanssen> dcoutts: mathewm wanted a copy, because UNSW is down
12:46:55 <dcoutts> sjanssen: do we need that given we have the official http://darcs.haskell.org/bytestring/
12:46:56 <oasisbot> Title: Index of /bytestring
12:47:03 <sjanssen> oh!  Didn't know about that
12:47:07 <dcoutts> :-)
12:47:18 <Nafai> Randroid: Heh.  I'm still hoping I'm one of those who *can* learn Haskell and not just a Java weenie
12:47:22 <sjanssen> mathewm: listen to dcoutts
12:47:27 <Randroid> dcoutts: The problem is, when you start talking about Haskell among anyone but Haskell programmers, they've either never heard of it or their eyes glaze over.
12:47:28 <mathewm> h
12:47:35 <mathewm> shame google doesn't surface that
12:47:46 <dcoutts> sjanssen: that's currently got bytestring-0.9, which will become 1.0 and will be targeting ghc-6.8 with the split up base libs
12:47:52 <monochrom> No one is just a Java weenie. But some people have low aspirations.
12:47:54 <ddarius> Randroid: I don't.
12:47:57 <njd> @type (liftIO . hPrintf)
12:47:58 <oasisbot>     Couldn't match expected type `IO a'
12:47:58 <oasisbot>            against inferred type `String -> r'
12:48:24 <Randroid> I've tried to explain Haskell to some of my more corporate compadres, and they just don't get it. They *like* side effects. They don't understand single assignment, etc.
12:48:27 <njd> @type liftIO $ hprintF
12:48:28 <oasisbot> Not in scope: `hprintF'
12:48:53 <njd> @type liftIO $ hPrintf
12:48:55 <oasisbot>     Couldn't match expected type `IO a'
12:48:55 <oasisbot>            against inferred type `GHC.IOBase.Handle -> String -> r'
12:49:17 <monochrom> njd: hPrintf has "varying number of arguments". So the compiler still needs to know how many arguments you want, and the best way is to actually give them. So using it pointfree is futile.
12:50:01 <monochrom> At best you can do something like \x -> liftIO (hPrintf myhandle "%d" x)
12:50:37 <ddarius> :t liftIO
12:50:39 <oasisbot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
12:50:40 <monochrom> You cannot eta-eliminate that x. The compiler needs that x to know how many parameters you want.
12:52:58 <njd> monochrom: I can define a function, say trace fmt = hPrintf stderr fmt - I can use trace like printf every where (in the IO monad)
12:54:46 <njd> monochrom:  - so that doesn't need to know the number of arguments - but as soon as I try to use it within my own monad (an instance of MonadIO) I must break the trick that printf/hPrintf uses - was just seeing if there was a way round it
12:56:38 <sjanssen> njd: this must be possible, somehow
12:58:33 <monochrom> If you know the type class hackery behind hPrintf, you can duplicate it and insert liftIO.
12:59:32 <monochrom> It has to be "duplicate". The type classes involved are left abstract; you aren't allowed to write your own instances. But you can mirror those type classes and do lots of forwarding, I guess.
13:00:35 <ddarius> Shouldn't you just be able to add an instance for MyMonad?
13:01:29 <monochrom> instance HPrintfType (MyMonad a) ?  No. Class methods not exported.
13:03:03 <fasta> Is there someway I convince GHC that it should auto-convert foo::m a to foo::a (since m can be the Identity monad)?
13:03:19 <fasta> can convince*
13:03:20 <roconnor> Time to implement some Boyer-Moore searching!
13:03:29 <ddarius> fasta: No.
13:03:48 <ddarius> Time to implement some Eilenberg-Moore algebras!
13:03:58 <monochrom> Converting from Identity to pure functions has to be done manually.
13:04:27 <monochrom> I think Boyer-Moore was about automatic induction proofs.
13:04:42 <monochrom> s/think/thought/
13:05:19 <fasta> I wonder whether anything spectacular could be found when Google would use all its machines to do proof search.
13:05:36 <sjanssen> fasta: unsafeCoerce#
13:06:01 <fasta> @type unsafeCoerce#
13:06:02 <oasisbot> Not in scope: `unsafeCoerce#'
13:06:03 <monochrom> The Google collective would gain intelligence. :)
13:06:10 <sjanssen> fasta: a -> b
13:06:16 <sjanssen> fasta: I was not being serious :)
13:06:24 <fasta> monochrom: I think they could
13:06:25 <roconnor> fasta: Back in december, a bug was found in Coq that allowed it to prove false.
13:06:46 <fasta> roconnor: ok, so all the proofs had to be redone?
13:06:48 <sjanssen> bah, why doesn't Text.Printf export hspr?
13:07:03 <fasta> roconnor: (that was a joke)
13:07:08 <sjanssen> that would make liftIO hPrintf possible
13:07:15 <roconnor> this was the problematic proof:
13:07:18 <roconnor> fix magic (x : True) : False := magic match magic x with end
13:07:18 <roconnor>  : True -> False
13:07:20 <monochrom> Because one is justly paranoid about user smuggling in bad code.
13:07:23 <tim> Can anyone point me towards a Haskell parser for Java? I've been having a terrible time finding anything.
13:07:35 <roconnor> Now if I were to search though all Coq proofs for a proof of False.
13:07:43 <fasta> tim: you should not only look for Haskell tools
13:07:45 <roconnor> This would be in the top 100 first terms I would check I think.
13:07:47 <fasta> tim: it's pointless
13:08:02 <roconnor> certainly within the top 1000.
13:08:02 <fasta> tim: there are great tools in Stratego/XT
13:08:59 <sjanssen> tim: you want to parse Haskell, or Java?
13:09:05 <ddarius> roconnor: I agree...
13:09:09 <tim> Want to parse Java from Haskell
13:09:46 <sjanssen> tim: it shouldn't be too hard to port a grammar for a parser generator to Happy's syntax
13:10:07 <dcoutts> tim: that's what I did for C, I ported an existing yacc grammar
13:10:23 <njd> sjanseen:  thanks - I thought that the lack of the export of hspr was strange as well - looks like there is no simple way round it - even defining the instance doesn't help
13:10:28 <tim> sjanssen: yah, I was hoping something as already there, but I can do this if necesssary
13:10:39 <dcoutts> tim: I found parsers in Haskell to be a bit thin on the ground too
13:11:18 <ddarius> Parsers for languages other than the language they're implemented in/associated with are rare in most languages.
13:11:57 <roconnor> @type nubBy
13:11:58 <oasisbot> forall a. (a -> a -> Bool) -> [a] -> [a]
13:12:58 <dcoutts> tim: you might find some code in my C parser useful, eg the lexer monad that maintains sets of type identifiers
13:13:19 <dcoutts> I assume Java has the same problem as C in that respect
13:13:20 <roconnor> @pl (\x y -> eq (fst x) (fst y))
13:13:20 <oasisbot> (. fst) . eq . fst
13:13:26 <roconnor> ugh
13:14:29 <fasta> Do we have: foo :: (Monad m, Sequence a) => Sequence a -> (a -> m b) -> m () Traversable maybe?
13:14:58 <fasta> Writing good Java tools took other people years
13:15:07 <dolio> Foldable has sequence_
13:15:08 <fasta> It's completely insane to redo the work.
13:15:15 <dolio> Traversable has sequence, I think.
13:15:20 <DRMacIver> fasta: Maybe that's because they were writing them in java? ;)
13:15:22 <roconnor> @what Sequence
13:15:22 <oasisbot> http://sequence.complete.org
13:15:23 <ddarius> uncurry eq . fst***fst
13:15:28 <ddarius> :t uncurry eq . fst***fst
13:15:29 <oasisbot> Not in scope: `eq'
13:15:31 <dcoutts> fasta: unless it means you have to write your whole code base in Java
13:15:36 <ddarius> :t uncurry ?eq . fst***fst
13:15:37 <oasisbot> forall a b c b1 a1 b2. (?eq::a -> b -> c) => (((a, b), b1), (a1, b2)) -> (c, a1)
13:15:47 <ddarius> :t uncurry ?eq . (fst***fst)
13:15:48 <oasisbot> forall c a b a1 b1. (?eq::a -> a1 -> c) => ((a, b), (a1, b1)) -> c
13:15:48 <fasta> DRMacIver: I am talking about Stratego/XT
13:16:04 <fasta> DRMacIver: (which was made for that purpose)
13:16:12 <roconnor> :t ?eq . (fst***fst)
13:16:13 <oasisbot> forall c a b a1 b1. (?eq::(a, a1) -> c) => ((a, b), (a1, b1)) -> c
13:16:13 <qwr> @pl \k -> Just k `mplus` Just k
13:16:14 <oasisbot> liftM2 mplus Just Just
13:16:30 <roconnor> why is that the same?
13:16:36 <tim> dcoutts: thanks for the offer I think I will be okay with the lexer though
13:16:43 <ddarius> roconnor: What the same?
13:17:19 <dcoutts> tim: well if you want to borrow anything, it's all in the darcs version of c2hs.
13:17:20 <DRMacIver> fasta: Ah. I was specifically responding to "Writing good Java tools took other people years".
13:17:24 * DRMacIver isn't familiar with Stratego
13:17:37 <roconnor>  :t uncuury foo and  :t foo
13:17:46 <tim> dcoutts: thanks, I will keep that in mind and maybe check it out
13:17:51 <ddarius> roconnor: They aren't.  ?eq has a different type in each.
13:18:02 <fasta> The strategy of commercial language developers seems to put as much features in as possible
13:18:10 <fasta> To make sure others cannot create the same tools
13:18:24 <fasta> Making the world depending on their tool chain in the process
13:18:34 <hpaste>  Nafai pasted "Why isn't while in scope?" at http://hpaste.org/1906
13:18:47 <Nafai> Sorry for the basic questions today
13:19:01 <tim> fasta: yah I sometimes get this feeling too
13:19:06 <ddarius> @index while
13:19:08 <oasisbot> bzzt
13:19:21 <ddarius> Nafai: Because there is no while.
13:19:28 <qwr> :t liftM2 mplus Just Just
13:19:29 <oasisbot> forall a. a -> Maybe a
13:19:41 <fasta> Only the compiler writers are relatively independent in this sense.
13:19:45 <Nafai> Bleh, that's what I get for copying an example out of a book :(
13:20:16 <qwr> > (liftM2 mplus Just Just) 2
13:20:18 <oasisbot>  Just 2
13:20:22 <roconnor> ddarius: ah okay.
13:20:37 <roconnor> I was looking for curry in the wrong place
13:21:07 <Nafai> What's the appropriate way to express this idiom then?
13:21:14 <ddarius> :t join (liftM2 ?eq) fst
13:21:15 <oasisbot> forall a2 r b. (?eq::a2 -> a2 -> r) => (a2, b) -> r
13:21:26 <fasta> dolio: mapM in Foldable
13:21:33 <fasta> dolio: mapM_
13:21:42 <ddarius> :t liftM2 ?eq fst fst
13:21:43 <oasisbot> forall r a b. (?eq::a -> a -> r) => (a, b) -> r
13:22:00 <dolio> Yeah.
13:22:22 <roconnor> @type maybe
13:22:23 <oasisbot> forall b a. b -> (a -> b) -> Maybe a -> b
13:22:37 <roconnor> @type fromMaybe
13:22:38 <oasisbot> forall a. a -> Maybe a -> a
13:22:48 <dolio> fasta: I'm not sure why I said sequence, although those should be in corresponding places, I think.
13:23:05 <ddarius> :t flip maybe id
13:23:06 <oasisbot> forall a. a -> Maybe a -> a
13:23:19 <fasta> dolio: you said dolio, because that was the only step the universe could make.
13:23:27 <roconnor> @type lookup
13:23:28 <oasisbot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
13:23:37 <fasta> dolio: said, dolio*
13:24:07 <roconnor> @type lookupWith
13:24:08 <oasisbot> Not in scope: `lookupWith'
13:24:13 <roconnor> @type lookupBy
13:24:14 <oasisbot> Not in scope: `lookupBy'
13:24:17 <roconnor> @type lookupUsing
13:24:18 <oasisbot> Not in scope: `lookupUsing'
13:24:21 <roconnor> :(
13:24:22 <ddarius> @hoogle lookup
13:24:22 <oasisbot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
13:24:22 <oasisbot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
13:24:22 <oasisbot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
13:25:31 <ddarius> :t find
13:25:32 <oasisbot> forall a. (a -> Bool) -> [a] -> Maybe a
13:25:33 <Nafai> :(
13:26:07 <ddarius> :t fmap snd . find
13:26:08 <oasisbot>     Couldn't match expected type `(a, b)'
13:26:08 <oasisbot>            against inferred type `Maybe a1'
13:26:20 <ddarius> :t (fmap snd .) . find
13:26:21 <oasisbot> forall a b. ((a, b) -> Bool) -> [(a, b)] -> Maybe b
13:26:41 <ddarius> :t (fmap snd .) . find . (. fst)
13:26:43 <oasisbot> forall a b. (a -> Bool) -> [(a, b)] -> Maybe b
13:27:17 <ddarius> @free find
13:27:18 <oasisbot> $map_Maybe f . find (g . f) = find g . $map f
13:27:56 <ddarius> That's pretty interesting actually.
13:29:02 <gkr> @src sequence
13:29:02 <oasisbot> sequence ms = foldr k (return []) ms
13:29:02 <oasisbot>     where
13:29:02 <oasisbot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
13:29:28 <ddarius> sequence = foldr (liftM2 (:)) (return [])
13:31:07 <qwr> @pl \x -> (+ 1) x * (+ 2) x
13:31:07 <oasisbot> liftM2 (*) (1 +) (2 +)
13:31:34 <qwr> how the fck it works?
13:31:51 <ddarius> qwr: ?  @pl is an "optimizing" compiler.
13:32:08 <qwr> no, why liftM2 does this?
13:32:13 <dolio> Well, it doesn't do that much optimizing.
13:32:42 <ddarius> qwr: Oh. It uses the (r->) instance of Monad.
13:32:46 <ddarius> dolio: It does do some.
13:32:51 <Nafai> Man I'm feeling slow today :/
13:32:59 <Nafai> I'm just trying to figure out how to iterate over the lines of a file
13:33:17 <dolio> I suppose that's true. It could just do more. :)
13:33:25 <ddarius> getContents >>= mapM myFunc . lines
13:33:28 <dolio> @pl \f (x,y) -> f x y
13:33:28 <oasisbot> (`ap` snd) . (. fst)
13:34:05 <ddarius> curry and uncurry aren't in the "language" it compiles to.
13:34:20 <dolio> Yeah, yeah. :)
13:34:30 <Nafai> ddarius: I need to process things line by line, each line is a separate command
13:35:01 <ddarius> Nafai: What I wrote would do exactly that.
13:35:25 * Nafai tries
13:35:27 <ddarius> (Albeit using stdin and mapM_ is probably more appropriate.)
13:37:56 <Nafai> Yay, thanks!
13:38:56 <fasta> What's better: const foo or \_ -> foo?
13:39:44 <Eelis> fasta: i'd say it's a matter of personal preference
13:39:52 <Eelis> i'm sure both sides have their zealots
13:40:09 * dolio prefers const.
13:40:09 <sjanssen> fasta: const
13:40:22 <dolio> \_-> is good for golfing, though. :)
13:40:30 <fasta> My style changed to use const.
13:41:24 <monochrom> const foo is better
13:41:41 <monochrom> In the same way that "map f xs" is better than writing your own recursion.
13:41:49 <sjanssen> right
13:41:52 <Eelis> haha, yeah that's a sane comparison ;)
13:41:57 <Eelis> (*NOT*)
13:42:00 <sjanssen> 'const' gives a name to the pattern
13:42:06 <monochrom> A learned reader looks at "const" or "map" and immediately sees what you're up to.
13:42:10 <fasta> Right, naming semantic concepts is nice.
13:42:16 <fasta> That's my motivation anyway.
13:43:11 <ddarius> const
13:43:14 <monochrom> A learned reader can also see through \_ -> foo of course. This case is so small it probably doesn't matter. But in general you don't want to make your reader reverse-engineer your code.
13:43:19 <fasta> @pl lift_a (\b -> flip boo a =<< Gen.zork b)
13:43:20 <oasisbot> lift_a ((flip boo a =<<) . (Gen .) . zork)
13:43:51 <fasta> Ugh, well, lets write that one with points :)
13:44:38 <sjanssen> @pl lift_a (\b -> flip boo a =<< Gen_zork b)
13:44:38 <oasisbot> lift_a ((flip boo a =<<) . Gen_zork)
13:44:54 <sjanssen> fasta: module qualifications confuse @pl
13:45:22 <fasta> Why are all these tool writers so lazy? How hard is it to write something correctly?
13:46:21 <Cale> fasta: @pl doesn't use GHC at all
13:46:23 <ddarius> I don't think the author of @pl really thought of it as much of a "tool"...
13:46:41 <ddarius> Technically @pl is right on this one...
13:46:54 <fasta> Haskell 98...
13:46:56 <sjanssen> fasta: @pl's code is pretty arcane
13:47:08 <fasta> ddarius: that's what you meant, right?
13:47:16 <sjanssen> I've considered making it use Language.Haskell before
13:51:28 * Botje procrastinates writing his paper.
13:53:14 <ddarius> fasta: Yes.
13:53:17 <igli> sorear: ping
13:53:25 <sorear> igli: pong
13:53:54 <sorear> igli: if it's about lambdabot - she has no electricity
13:53:55 <igli> hi man! can we get lb back in #friendly-coders? i need to add ignores tho
13:53:59 <igli> hehe
13:54:02 <igli> aww nm
14:02:51 * mathewm sighs
14:03:06 <mathewm> ok, where might I find lambdabot ?
14:03:34 <ddarius> @version
14:03:35 <oasisbot> lambdabot 4p537, GHC 6.6.1 (Linux i686 3.00GHz)
14:03:35 <oasisbot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
14:03:37 <mathewm> ~dons is AWOL - is there a mirror?
14:03:39 <sjanssen> lambdabot had a power outage
14:03:50 <lament> mathewm: ~dons is affected by the same outage
14:03:59 <mathewm> ok, I will wait, then
14:04:15 <sorear> mathewm: got a question
14:04:17 <sorear> aww
14:06:00 <igli> can oasisbot join then sorear?
14:06:11 <sorear> igli: Ask vincenz.
14:06:12 <ddarius> It's vincenz's
14:06:15 <igli> hehe
14:08:29 <glguy> ?bot
14:08:30 <oasisbot> :)
14:08:38 <glguy> lambdabot's role is being filled atm
14:08:50 * glguy bothers to read the whole screen
14:08:55 <igli> heh nm man
14:09:25 <ddarius> glguy: Perhaps in general you should start at the bottom and read up?
14:09:34 <qwr> > ((+ 1) >>= (+)) 2
14:09:36 <oasisbot>  5
14:09:42 <glguy> ddarius: that *seems* logical
14:10:07 <glguy> but reading conversations backwards can be weird too
14:10:41 <sorear> I use a bidirectional algorithm.
14:11:34 <igli> wow non-linear time flow man.. ;)
14:12:03 <ddarius> igli: Find someone who has a linear time flow.
14:13:05 <bos> @seen dcoutts
14:13:05 <oasisbot> dcoutts is in #haskell. I last heard dcoutts speak 55m 45s ago.
14:13:18 <dcoutts> hia bos
14:13:29 <dcoutts> yep, new gtk2hs :-)
14:13:32 <bos> hey! does the gtk2hs build cope okay with "make -j X"?
14:13:53 <bos> i'm building 0.9.12 for fedora right now, but it's using only a single CPU
14:13:53 <dcoutts> bos: it does, by setting a cheating flag in the Makefile... .NOPARALLEL :-)
14:14:04 <bos> ach so
14:14:09 <dcoutts> the makefile is otherwise borken for parallel builds
14:14:14 <bos> ok
14:14:18 <dcoutts> sadly, to much automake hackery
14:14:30 <dcoutts> bos: we should make cabal do parallel builds
14:14:51 <dcoutts> gtk2hs will be moving to cabal for its build system at some point
14:14:53 <bos> dcoutts: it already can, kind of
14:15:10 <bos> the head of cabal can spit out a makefile that can be run in parallel
14:15:23 <dcoutts> I guess
14:15:34 <dcoutts> only ghc's build system uses that though
14:15:46 <bos> well, it's the only thing that can
14:15:58 <bos> but it works for libraries in general, in my experience
14:15:58 <dcoutts> we just need to make cabal do proper dep analysis....
14:16:13 <roconnor> @type findIndex
14:16:14 <oasisbot> forall a. (a -> Bool) -> [a] -> Maybe Int
14:16:43 <sorear> dcoutts: For a small program, setting up cabal is "too much work"
14:16:46 <sorear> ,
14:16:56 <dcoutts> sorear: true, though see mkcabal
14:17:01 <sorear> so compilers continue to have dep analysis.... --make
14:17:02 <bos> meh, setting up cabal takes just a few minutes
14:17:13 * sorear muses
14:17:25 <bos> ok, gtk2hs builds cleanly
14:17:39 <dcoutts> sorear: I think it's the other way around, ghc had --make before cabal appeared, so cabal used it to save time implementing dep analysis
14:17:42 <sorear> What if hmake was integrated with cabal.  To build a small program, just run hmake.
14:17:47 <dcoutts> bos: good good
14:18:05 <sorear> Move all dep analyis logic into cabal.
14:18:12 <dcoutts> sorear: I've heard that hmake code is incomprehensible
14:18:28 <dcoutts> Soliah: but yes, we certainly should move all dep analyis logic into cabal
14:18:31 <sorear> Remove ghc --make, yhc -make, and all similar flags in hbc, jhc.
14:18:32 <dcoutts> oops
14:18:41 <dcoutts> Soliah/sorear
14:19:05 <njd> @users
14:19:05 <oasisbot> Maximum users seen in #haskell: 422, currently: 354 (83.9%), active: 16 (4.5%)
14:27:30 <sjanssen> alternatively, add parallel support to ghc
14:27:36 <sjanssen> this existed at one point in time
14:27:55 <bos> dcoutts: i've kicked off official 0.9.12 builds for fc6, f7 and fedora rawhide
14:28:12 <dcoutts> bos: cool
14:28:42 <dcoutts> sjanssen: the infrastructure would be generally useful in Cabal, not just for doing parallel builds
14:42:19 <roconnor> @type isNothing
14:42:21 <oasisbot> forall a. Maybe a -> Bool
14:46:38 <roconnor> @hoogle Int -> [a] -> Maybe a
14:46:39 <oasisbot> No matches, try a more general search
14:47:58 <Botje> what should that do? :)
14:48:23 <roconnor> :t (!!)
14:48:24 <oasisbot> forall a. [a] -> Int -> a
14:51:21 <sjanssen> @keal
14:51:21 <oasisbot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
14:51:24 <sjanssen> bah
14:53:51 * shapr mourns for lambdabot
14:54:38 <shapr> dcoutts: What about Maak, the make clone written in Haskell? The author offered to clean it up for Cabal a year or two ago.
14:55:01 <dcoutts> shapr: that'd be nice
14:55:07 <dcoutts> who wrote Maak ?
14:55:35 <dcoutts> shapr: our main issue is a lack of someone to do the work, there's code we can borrow from all over the place
14:55:52 <dcoutts> from ghc, hmake, yhc, Maak
14:56:10 <shapr> http://www.scannedinavian.com/hope/entry/66
14:56:22 <shapr> Eelco Dolstra
14:56:28 <shapr> I always get Dolstra and Visser confused.
14:56:36 <Maddas> Randroid: Isn't it always better if someone *can* understand something? :_)
14:56:56 <shapr> Maddas: I think you've scrolled back a bit.
14:57:14 <dcoutts> shapr: interesting
14:57:56 <shapr> I wonder if I could use Maak for the HAppS EC2 deployment tool, it's an unholy mix of layers of shell scripts and Haskell snippets right now.
14:58:12 <shapr> And the unholiness regularly causes me problems, of course.
14:58:25 <Maddas> shapr: Indeed I have.
14:59:10 <Lemmih> shapr: We have more than one script?
14:59:29 <shapr> Hm, I thought so...
14:59:31 <davidL> ?bot
14:59:31 <oasisbot> :)
14:59:38 <shapr> Though now I guess it's only build.sh
15:00:06 <shapr> Lemmih gets the credit for the working parts of the HAppS EC2 deployment tool. I get credit for the broken parts ;-)
15:00:12 <davidL> ?seen lambdabot
15:00:12 <oasisbot> lambdabot is in #oasis. I last heard lambdabot speak 4d 11h 3m 19s ago.
15:09:01 <sorear> dcoutts: ndm is currently writing a stand-alone make library, and plans to port yhc to use it.
15:09:13 <dcoutts> sounds good
15:17:09 <magnus> is (map (\x -> x*x)) a CAF (Constant Applicative Function)?
15:17:32 <Heffalump> it depends where you put it
15:17:51 <Heffalump> CAFs are top level definitions without parameters (including type-class dictionary parameters)
15:18:07 <magnus> squareThem = map (\x -> x*x)    at toplevel
15:18:24 <Heffalump> not without a type signature
15:18:32 <magnus> ah, so you need to specialize which Num instance
15:18:38 <Heffalump> well, without a type signature you'll run into the monomorphism restriction
15:18:45 <Heffalump> I forget whether it'll default it or forbid it
15:19:03 <Heffalump> with a Num a => [a] -> [a] signature it's not a CAF
15:19:06 <magnus> I think I understand what CAFs are now, thanks
15:19:19 <Heffalump> operationally, it just means "will only ever get evaluated once"
15:19:20 <magnus> right
15:19:38 <magnus> that's a simpler definition. I like it :)
15:20:19 <Heffalump> of course, CSE and inlining can play merry hell with that definition
15:20:35 <Heffalump> but I think compilers are quite careful
15:20:55 <magnus> what is the significance of CAFs?
15:20:56 <glguy> w
15:21:17 <magnus> why is the classification useful?
15:21:20 <beelsebob> the significance is... they only get evaluated once
15:21:24 <beelsebob> they're constant
15:21:59 <Heffalump> the most likely time you will come across them is in profiling
15:22:10 <Heffalump> where by default, they are all charged to the same cost centre (or one per module, I forget)
15:22:13 <dibblego> how can you make a CAF only evaluate once?
15:22:25 <dibblego> is this default compiler behaviour?
15:22:28 <beelsebob> yes
15:22:31 <magnus> aha
15:22:34 <beelsebob> it's part of lazy evaluation
15:22:37 <sorear> dibblego: Don't tell ghci ':set +r'
15:22:38 <sorear>  :)
15:22:39 <Heffalump> I think you need {-# NOINLINE #-} pragmas
15:22:40 <beelsebob> it's a constant
15:22:55 <Heffalump> people use those on unsafePerformIO'd global variables
15:23:12 <sorear> Heffalump: No.  GHCi avoids gratously inlining CAFs because it would break sharing.
15:24:33 <Heffalump> well, I thought that was the recommended way to do them, even if the compiler doesn't currently mess with them
15:25:10 <sorear> well, the compiler might still mess with them if it thinks there's something to be gained.
15:26:27 <Philippa> one big significance is that CAFs are a great source of space leaks
15:27:12 <shapr> yay, new gtk2hs!
15:27:18 <dcoutts> @arr!
15:27:19 <oasisbot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
15:27:36 <dcoutts> oasisbot: if you can't say anything nice, don't say anything at all.
15:31:01 <Heffalump> sorear: well, precisely
15:36:53 <bos> dcoutts: gtk2hs 0.9.12 will show up in updates-testing for FC6 and F7 this weekend, and promoted to normal updates in a week or so
15:37:15 <dcoutts> bos: cool, thanks v. much
15:37:52 <bos> np
15:37:58 <bos> it took like 10 minutes of work
15:38:10 <bos> thank YOU for updating it :-)
15:38:20 <dcoutts> but it's really great to get it into widely used distros :-)
15:38:41 <dcoutts> I don't have quite the same effect by making a Gentoo ebuild :-)
15:40:14 <fasta> sorear: that doesn't work in ghci currently.
15:40:22 <fasta> sorear: (+r)
15:41:02 <sorear> fasta: Report a bug. it *is* documented!
15:41:09 <fasta> sorear: already did months ago
15:41:12 <sorear>  Options for ':set' and ':unset':
15:41:12 <sorear>     +r            revert top-level expressions after each evaluation
15:41:22 <fasta> sorear: I know what it should do
15:41:31 <dibblego> speaking of bugs, I saw GHCI 6.6.1 crash yesterday on Mac OS
15:41:48 <dibblego> not sure how often this occurs though
15:42:25 <dibblego> bos, do you use mercurial for your Haskell work?
15:43:31 <vagif> Hello, just installed latest gtk2hs. with ghc 6.1.1 on windows. Examples compile and work ok. But when trying from ghci getting this error message:
15:43:31 <vagif> HSgtk.o: unknown symbol `_pango_layout_get_lines_readonly'
15:44:00 <dons> ?users
15:44:00 <oasisbot> Maximum users seen in #haskell: 422, currently: 339 (80.3%), active: 14 (4.1%)
15:44:05 <dons> wacky oasisbot
15:44:29 <vagif> previous version of gtk2hs on ghc 6.6 was working fine in ghci
15:44:37 <dcoutts> vagif: hmm
15:45:05 <dozer> is there something you can put in a haskell src file to stop parsing from that line to the end of the file?
15:45:12 <bos> dibblego: no, darcs
15:45:31 <dcoutts> vagif: it doesn't do that for me
15:46:35 <dcoutts> vagif: you don't have any other versions of gtk+ installed anywhere do you, on your path?
15:46:55 <vagif> let me check GTK...
15:47:20 <ndm> @karma+ dcoutts Gtk2hs release
15:47:20 <oasisbot> dcoutts's karma raised to 42.
15:47:25 <ndm> although, in future, i would love if Gtk2hs came out the same day as GHC...
15:47:43 <dcoutts> ndm: how do you do automated builds on windows without using ssh?
15:48:01 <vagif> i do not think i have any other gtks installed. I only have one at C:\GTK
15:48:13 <vagif> maybe specific version of it ?
15:48:19 <dcoutts> vagif: what is your %PATH% ?
15:48:41 <ndm> dcoutts, i have a .bat in my startup folder
15:48:42 <dcoutts> ndm: the admin folk say I can't use ssh to connect to our windows server I use to build gtk2hs, they say that'd violate our license
15:48:54 <ndm> dcoutts, do it and don't tell them?
15:49:00 <ndm> thats usually the best strategy
15:49:18 <vagif> C:\GHC\Gtk2Hs\bin;C:\Program Files\Haskell\bin;C:\ghc\ghc-6.6.1\bin;C:\Java\apache-ant-1.7.0\bin;C:\Java\sisc-1.16.6;C:\Java\jdk1.5.0_09\bin
15:49:33 <dcoutts> heh, true, though I'm finding it hard finding a version of ssh that doesn't need cygwin, or need installing as a service (which needs admin)
15:49:53 <dcoutts> vagif: hmm, that is odd, C:\GHC\Gtk2Hs\bin is there first
15:50:01 <vagif> so ?
15:50:12 <dcoutts> so it should be getting the right dlls
15:50:29 <vagif> and it compiles
15:50:32 <sorear> ndm:
15:50:46 <vagif> and exe runs fine. only from ghci it gives error
15:50:49 <ndm> dcoutts, putty?
15:50:53 <ndm> sorear:
15:51:34 <dcoutts> ndm: I need the ssh server
15:51:36 <sorear> 14:53 < shapr> dcoutts: What about Maak, the make clone written in Haskell? The author offered to clean it up for Cabal a year or two ago.
15:51:39 <sorear> 14:54 < dcoutts> shapr: our main issue is a lack of someone to do the work, there's code we can borrow from all over the place
15:51:41 <dons> OSCON Video announcement _placeholder_ eh?
15:51:43 <sorear> 15:07 < sorear> dcoutts: ndm is currently writing a stand-alone make library, and plans to port yhc to use it.
15:51:59 <dcoutts> dons: you're back from the powercut eh?
15:52:19 <ndm> dcoutts, i am, and its perfectly designed for Cabal/Yhc, NOT a Make clone, exactly what you'd want to build an automatic making tool on
15:53:39 <dons> dcoutts: not yet. at home on irc :)
15:53:54 <dcoutts> dons: what happened at unsw then?
15:54:16 <dons> oh, CSE had a power failure last weekend, and this weekend they're upgrading the subsystem
15:54:27 <dons> unsw.edu.au should be up, just not cse.*
15:54:38 <dcoutts> ah
15:55:29 <dcoutts> vagif: so it does that when you run ghci -package gtk-0.9.12 ?
15:55:46 <dcoutts> vagif: from a fresh command line shell
15:55:54 <vagif> let me try that...
15:56:37 <vagif> yes
15:56:48 <vagif> i get  that error
15:57:05 <dcoutts> wierd
15:57:34 <dcoutts> vagif: it makes me suspect that it's somehow using an older version of the Gtk+ dlls that's missing those new functions
15:58:36 <dcoutts> vagif: what does the file explorer say is the version number of libgtk-win32-2.0-0.dll ?
15:58:45 <hpaste>  fxr annotated "state problem" with "(no title)" at http://hpaste.org/1900#a2
15:58:48 <hpaste>  dibblego pasted "Why isn't this O'Caml code possible in Haskell?" at http://hpaste.org/1908
15:59:45 <dcoutts> vagif: actually how about the version number of libpango-1.0-0.dll
16:02:38 <dibblego> looks to me like it could be achieved with a type class, but I'm not clear on the purpose of that O'Caml code
16:03:10 <vagif> let me check...
16:03:39 <glguy> dibblego: you want to not have to declare data Expr a = Add a a | Int a | Mul a a
16:03:42 <glguy> ?
16:03:57 <vagif> libpango-1.0-0.dll version: 1.14.7.0
16:04:13 <dibblego> glguy, I don't know what that O'Caml code is doing; the claim is that Haskell's type system cannot achieve whatever it is, so that's why I want to know what it is doing
16:04:50 <glguy> dibblego: who is they?
16:05:07 <dons> http://programming.reddit.com/info/2a3dc/comments !!
16:05:08 <oasisbot> Title: A Taste of Haskell : Simon Peyton-Jones OSCON tutorial (pdf) (reddit.com)
16:05:12 <dibblego> glguy, a guy called Jon Harrop on the F# list; I asked him to help me understand, but that was nearly 2 weeks ago
16:05:15 <viat-on> i think i saw somethign very similar done in haskell
16:05:22 <vagif> ups
16:05:28 <dcoutts> vagif: ok, that's wrong, I don't know why it's wrong, but it is. It should be 1.16.4.0
16:05:29 <dons> dibblego: oh, not Jon Harrop :/
16:05:32 <gwillen> Oh god, Harrop?
16:05:38 <vagif> i have 2 libpango files
16:05:48 <gwillen> I have Harrop killfiled on comp.lang.lisp
16:05:51 <gwillen> he's a fucking troll.
16:05:52 <dons> dibblego: his entire goal is to sell his ocaml book.
16:05:54 <dibblego> I've heard things about him too :) but I want to know if his claim isa furfy, or there's something I need to understand
16:06:09 <viat-on> ended with "the type of foo is inferred correctly as haskell is great" or something .. a moment i'll check
16:06:10 <vagif> one in c:\ghc\gtk2hs\bin and on in c:\gtk\bin
16:06:15 <lament> somebody wanted to sell an ocaml book on comp.lang.lisp?
16:06:17 <dibblego> yeah I figured that, but is this a furfy?
16:06:23 <vagif> so looks like i have an old version of 
16:06:23 <gwillen> On cll he mostly talks about F#...
16:06:36 <vagif> thx, i'll try to update my gtk
16:06:42 <dibblego> I've read some of his threads on usenet lisp
16:06:42 <dcoutts> vagif: right, I'm interested in the one in c:\ghc\gtk2hs\bin
16:06:45 <viat-on> http://cdsmith.wordpress.com/tag/haskell/
16:06:47 <oasisbot> Title: Haskell  Sententia cdsmithus
16:06:49 <gwillen> I didn't realize he was trying to sell a book, I thought he was just a random troll
16:07:07 <vagif> that one has version 1.16.4.0
16:07:09 <viat-on> "It correctly inferred that the result type of expr must be Fractional. .. "
16:07:09 <dcoutts> vagif: gtk2hs should totally ignore your other gtk+ install
16:07:12 <viat-on> i don
16:07:16 <dons> dibblego: oh, he's pointing to variant types, which was pointed out on -cafe@ is perfectly doable in haskell
16:07:19 <dibblego> I refuse to use ad hominem conclusions - "because Jon Harrop talks nonsense, then his point is nonsense" :)
16:07:27 <viat-on> 't understand haskell well yet or ocaml at all, but they sure seem similar
16:07:33 <dibblego> dons, pointed out to him, or just in another discussion?
16:07:42 <dcoutts> vagif: ok, so the one in the gtk dir is correct then? and the other one is older, but we shouldn't be using it anyway I'd hope.
16:07:46 <dons> dibblego: in fact, he asked about this 2 days ago, was given an answer of at least one way to do it
16:07:48 <gwillen> Meh, you can't read Usenet without using ad hominem once in awhile -- he mostly talks nonsense, therefore I killfile him (assuming he will only talk nonsense). :-)
16:07:58 <dibblego> dons, what's the thread title?
16:08:04 <dons> let me find it.
16:08:09 <dibblego> thanks
16:08:22 <dcoutts> vagif: but the symptoms look like we are using the old version for some reason which I do not understand, since you say you don't have c:\gtk\bin on your %PATH% right ?
16:08:28 <dibblego> I exercise too much cognitive dissonance in Haskell-Cafe
16:08:45 <vagif> i do not have it in the path, right
16:08:54 <dons> i'm not even really sure what the issue is here, in haskell you'd use a GADT anyway, and have a much richer embedding in the type system
16:09:23 <dibblego> dons, I've found that when someone says "X is not possible in Haskell", it is often the case that not only is it possible, but it is better
16:09:27 <dibblego> for many values of X
16:10:26 <dons> dibblego: http://thread.gmane.org/gmane.comp.lang.haskell.cafe/26567
16:10:27 <oasisbot> Title: Gmane Loom
16:10:31 <dibblego> thanks dogmaT
16:10:33 <dibblego> er, dons
16:10:44 <dcoutts> vagif: so it's pretty odd, the symptoms look exactly like we're picking up the pango 1.14 version, those two functions were new in version 1.16
16:10:49 <dons> "> Does Haskell have anything similar to OCaml's polymorphic variants?
16:10:50 <dons> >
16:10:50 <dons> No as such, but it's possible to simulate them. As always Oleg was the
16:10:50 <dons> one to demonstrate how:
16:10:50 <dons> http://okmij.org/ftp/Haskell/generics.html"
16:10:50 <oasisbot> Title: Generic functions and Open data types
16:11:24 <vagif> i'm uninstalling old gtk. let me see if it helps
16:11:45 <dons> dibblego: likely he has been hunting hard for something to justify his continued ocaml trolling, here there and everywhere
16:11:58 <vagif> YES!!
16:12:03 <vagif> it solved the problem
16:12:12 <dibblego> dons, I'm tossing up if I should make it clear on the F# list :)
16:12:32 <dcoutts> vagif: that's really weird, I don't understand why that should happen given the %PATH%
16:12:38 <vagif> dcoutts: Thank you very much!
16:12:44 <dibblego> dons, for the information of others
16:12:50 <dons> dibblego: perhaps point out that Jon already asked and given a solution on the haskell list.
16:13:17 <dibblego> dons, yeah, but that was after he claimed it is not possible (I assume this is why he asked on Haskell-Cafe, to be sure)
16:13:33 <dibblego> dons, the discussion was nearly 2 weeks ago, which is why I was hoping for an answer from him
16:13:40 <dons> i wonder if he found out it was possible, then decided to contine stating it wasn't .. ?
16:13:43 <dons> ah ok
16:13:44 <dibblego> dons, it seems I won't get one, given that he has been refuted :)
16:13:54 <dibblego> dons, no, I don't think he did that
16:14:05 <dibblego> found that it was possible, then ignored my follow up question (which was simply, why?)
16:14:09 <dons> right.
16:14:28 <dons> he doesn't really know haskell, or do type system stuff -- seems primarly to be a low level hacker (all his perf benchmarks)
16:14:45 <dibblego> ok, well that clears that up, thanks
16:14:53 <dibblego> I'll have to read up more on this topic
16:15:18 <elliottt> ?bot
16:15:18 <oasisbot> :)
16:15:41 <dons> yep, polymorphic variants are interesting. there's probably some nicer ways to emulate them, but i'm not sure their power/weight ratio is enough -- no one seems to be asking for them
16:15:44 <mm_freak> :bot
16:16:20 <mm_freak> i'm still not sure how to implement my modular arithmetic type
16:17:07 <mm_freak> implicit configuration makes sense, but i still don't fully understand it…  encoding the modulus as a constructor parameter makes sense too, but isn't particularly nice
16:17:50 <cdsmith> dons: I can't get to your web page.  What's up?  Something with me, or the server?
16:17:57 <dons> no power.
16:18:04 <dons> back up in 8 hours or so
16:18:06 <cdsmith> Ooh, that sucks.
16:18:16 <dons> yep, they're upgrading some power substation
16:18:28 <dons> lambdabot was drawing too much power
16:18:37 <cdsmith> Really?  Or just a joke?
16:18:41 <dons> heh
16:18:51 <mm_freak> lol
16:18:59 <cdsmith> Ok :)
16:19:00 <mm_freak> needs an own nuclear reactor
16:19:04 <kpreid> If you have to ask...
16:19:12 <dons> the CSE dept is a large building *full* of servers :)
16:19:26 <dons> for some reason, they have the largest electricity demand of any faculty
16:19:27 <dcoutts> like serenity
16:19:29 <dons> strange :)
16:19:34 <mm_freak> and lambdabot uses all those servers as a cluster
16:19:51 <dons> like serenity, our nice environmentally frie^h^h^h large lambdabot box
16:19:53 <mrd> hi dons
16:20:03 <dons> hey mrd
16:20:04 <astrolabe> From the international space station, you can see all the lights in australia dim when someone types > foldl whatever
16:20:06 <mrd> mm_freak: how do you think @pl and @djinn operate?
16:20:10 <dons> heh
16:20:20 <mm_freak> mrd: that's my point
16:20:40 <mrd> massively parallel point-less-ness
16:20:43 <dons> the @vixen command is a large neural network trawling myspace, using 512 commodity pentium4 nodes
16:20:50 <dons> so for example, that uses a bit of power
16:20:55 <dons> @vixen i love you
16:20:55 <oasisbot> Plugin `vixen' failed with: IRCRaised getRandItem: empty list
16:21:01 <astrolabe> heh
16:21:04 <dons> oasisbot doesn't have the computational resources
16:21:06 <mm_freak> yeah…  lambdabot makes things completely pointless
16:21:20 <mm_freak> for that it uses half the energy in the world
16:21:51 <mrd> dons: when building ndp, do you use non-default ghc build options?
16:22:11 <shapr> ndm: Well, Maak isn't really a make clone...
16:22:11 <dons> mrd, hmm possibly..
16:22:14 <dons> you need ghc head anyway
16:22:25 <dons> hey shapr !
16:22:27 <dons> ?yow!
16:22:27 <oasisbot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
16:22:30 <dons> boo
16:22:36 * dons wants lambdabot back
16:22:42 <mrd> i just did a  fresh get of ghc head compiled it default settings, added ndp and tried to build
16:23:04 <mrd> "ghc-6.7.20070727: combination not supported: Threaded/Profiling"
16:23:58 <dons> oh, that's not an ndp issue
16:24:01 <cdsmith> Okay fine; modified my build-all script to not do darcs pull for anything unsw in the darcs repo.  Thanks for the info.
16:24:07 <dons> so you tried to build something the threaded/profiling way
16:24:16 <dons> hmm.
16:24:23 <dons> there was a thread about this just a couple of days ago
16:24:38 <mrd> on ghc dev?
16:24:42 <dons> check the mailing list, mrd. i think you can't build profiled threaded libs?
16:24:43 <dons> yeah
16:25:10 <mm_freak> @help @djinn
16:25:10 <oasisbot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:25:20 <mm_freak> @help djinn
16:25:20 <oasisbot> djinn <type>.
16:25:20 <oasisbot> Generates Haskell code from a type.
16:25:20 <oasisbot> http://darcs.augustsson.net/Darcs/Djinn
16:25:29 <ndm> shapr: i more meant that mine isn't a make clone, i know nothing about the other one at all
16:25:52 <dons> ndm, could we do a cheap embedding of catch in lambdabot: given a function, it determines if it is partial?
16:25:54 <ndm> i guess Cabal won't move over to it though, since a lack of cabal hacking time
16:25:59 <viat-on> "Just name the backup "Britney.Spears.Nude!!Great!!<date>.zip" and spread it via edonkey. Unless the whole internet breaks down, you will always have access to your backups! " .. best idea ever
16:26:16 <ndm> dons: do you have Yhc on that machine? thats the hardest dependency
16:26:37 <ndm> the rest is relatively easy
16:26:59 <ddarius> @google "The eternity machine"
16:27:00 <oasisbot> http://cgi.ebay.com/FANTASTIC-FOUR-135-The-Eternity-Machine-1973_W0QQitemZ160140824019QQihZ006QQcategoryZ32731QQcmdZViewItem
16:27:01 <oasisbot> Title: FANTASTIC FOUR #135 "The Eternity Machine!" 1973 - (item 160140824019 end time J ...
16:27:04 <ddarius> Damn.
16:27:53 <sorear> @google simon tatham infinite machine
16:27:55 <oasisbot> http://www.cyberknights.com.au/doc/PuTTY-tunnelling-HOWTO.html
16:27:55 <oasisbot> Title: CyberKnights instant PuTTY tunnels
16:28:01 <sorear> ^^ that?
16:28:04 <sorear> uh
16:28:26 <sorear> http://www.chiark.greenend.org.uk/~sgtatham/infinity.html
16:28:27 <oasisbot> Title: The Infinity Machine
16:28:29 <sorear> ?
16:30:25 <ndm> dons: we have Template Haskell on this machine, don't we?
16:30:59 <ndm> i think by canabalising bits of HERA i might be able to knock up a Catch demo which didn't depend on Yhc...
16:32:05 <pjd> Simon Tatham++
16:32:17 <mrd> dons: i changed to a build which appeared to not have profiling in it, and it compiled successfully now.  dunno whats up with default.
16:33:01 <dons> mrd, right. ndp requires a threaded runtime (of course), which i think only works with profiling recently (?). that was the subject of the mailing list, iirc
16:33:06 <ddarius> sorear: Nope.
16:33:28 <sorear> @karma Tatham
16:33:28 <oasisbot> Tatham has a karma of 1
16:37:30 <augustss> yo
16:39:33 <dons> hey hey augustss
16:40:57 <augustss> how's that thesis doing?
16:41:12 <dons> good!
16:41:21 <dons> making some progress now. so, yay!
16:42:00 <augustss> great!
16:42:20 <dons> they're not so hard to write after all
16:42:22 <augustss> i'm looking at Simon's xmonad slides
16:42:40 <dons> yeah, we should have video soon too
16:42:50 <dons> andy gill recorded the 3 hr tut, i hear.
16:43:06 <Excedrin> does the new version of gtk2hs support multiple windows?
16:43:13 <augustss> oh, i hope he's putting it up on the web
16:43:18 <dons> yep.
16:43:35 <dons> not sure about the other talks, the ndp and stm ones.
16:43:38 <dcoutts> Excedrin: it's always supported multiple windows, or perhaps you mean something else?
16:43:48 <bos> i didn't see any camera people in the ndp talk
16:43:56 <bos> didn't go to the stm talk
16:44:19 <dons> bos, was the ndp talk similar to the one already one video (from the London hUGS meeting)?
16:44:27 <dcoutts> Excedrin: what did you mean exactly?
16:44:30 <Excedrin> dcoutts: hi, I thought there were problems with it
16:44:47 <dcoutts> Excedrin: not so far as I know of
16:44:51 <bos> dons: identical slides, slower and less technical presentation
16:45:07 <Excedrin> cool, then ignore my question :)
16:45:15 <dcoutts> Excedrin: np :-)
16:47:01 <CosmicRay_> woohoo!  http://blip.tv/file/get/OSCON-OSCON2007SimonPeytonJones914.mov
16:47:28 <dons> woot!
16:47:55 <dons> should it go up to youtube?
16:48:06 <CosmicRay_> I don't know
16:48:15 <bos> youtube won't take videos that lon
16:48:17 <bos> long
16:48:24 <bos> you'd need to use google video instead
16:48:28 <CosmicRay_> gnat said that everything would be posted there or google video
16:48:35 <CosmicRay_> but haven't seen anything either place
16:48:53 <augustss> i've clicked on it.  now i'm waiting
16:49:13 <augustss> google video does, i think
16:51:16 <CosmicRay_> I couldn't find em
17:08:31 <dons> can anyone play the oscon video in mplayer?
17:09:14 <Lemmih> Yes.
17:09:25 <dons> ok, probably i need to upgrade
17:10:24 <bos> i can play it, too
17:10:28 <bos> it's his radar keynote
17:11:12 <dons> oh, ok. not the `taste' tutorial?
17:11:16 <bos> no
17:11:32 <augustss> it's good, though
17:11:33 <ddarius> How big is the video (in MB?)
17:11:36 <elliottt> do they have video of the tutorial up?
17:11:45 <augustss> well, it's simon, so that's no surprise
17:11:47 <bos> 45MB
17:11:58 <ddarius> Oh, okay. How long is it?
17:12:04 <dons> elliottt: not yet, on its way though
17:12:08 <elliottt> very cool :)
17:12:58 <ptolomy> Anyone ever tried to make a non-monadic NFA-runner in haskell?
17:13:31 * wli has only done non-monadic DFA runners.
17:13:53 <ptolomy> heh. probably equivalent. :-P
17:16:22 <ptolomy> (I threw together a ~200 line NFA 'regex engine' in ruby to amuse myself at work, but I kept finding myself missing quality types, so I thought I'd port it, but the combination of me wanting to encoding relationships structurally, using updates of existing states, and not wanting to do it in ST/State makes me think I've requiremented myself into a corner)
17:16:39 <ddarius> I'm sure there are plenty of CPS ones.  I also wrote a regex runner not too long ago.  I don't remember if it was monadic or not.  I don't think it was.
17:19:11 <dons> ah weird, now mplayer is happy, once i got the whole file
17:19:11 <dons> so where's the video from, can we get it on google video? :)
17:19:11 <dons> hmm. we should have a video section on the haskell wiki now, too
17:19:22 <ddarius> 140 lines for a regex parser, a compiler to NFA and executor, and a NFA-to-dot function, and an implementation of observable sharing.
17:19:33 <wli> Grammar-building parser combinators and parsing engines that build the DPDA's/NPDA's on the fly are more interesting to me (largely due to the left recursion -related violence they eliminate; chart parsers are fine, too, as it's largely left recursion -related violence bothering me).
17:19:50 <wli> (vs. performance)
17:20:27 <ptolomy> ddarius: Public? :-)
17:20:43 * ptolomy needs to acquaint himself more with CPS-style coding.
17:21:02 * wli is almost totally ignorant of CPS.
17:21:55 <ddarius> ptolomy: Just sitting around on my hard drive. The parser is not tail recursive.  It's a pretty straight transcription of the algorithm described at http://swtch.com/~rsc/regexp/regexp1.html
17:21:55 <jfredett> CPS, IMO, isn't that great
17:21:55 <oasisbot> Title: Regular Expression Matching Can Be Simple And Fast
17:22:07 <ptolomy> Ah yes, that one.
17:22:13 <ptolomy> Thompson NFA
17:22:16 * ptolomy re-reads.
17:23:04 <ddarius> ptolomy: You might also be interested in the papers on differentiating regular expressions.  That easily leads to a slick and compact algorithm.
17:23:59 <ddarius> ptolomy: http://lambda-the-ultimate.org/node/2293#comment-34221
17:23:59 <oasisbot> Title: Derivatives of Regular Expressions | Lambda the Ultimate
17:24:11 <ddarius> And more generally, http://lambda-the-ultimate.org/node/2293#comment-35057
17:24:12 <oasisbot> Title: Derivatives of Regular Expressions | Lambda the Ultimate
17:24:24 <jfredett> derivatives as in calculus derivative?
17:24:32 <jfredett> or as in something derived from?
17:24:40 <ddarius> jfredett: Yes as in calculusish.
17:24:47 <jfredett> and who the heck is oasisbot, and what did it do with lambda?
17:25:06 <jfredett> ddarius: cool
17:25:37 <ddarius> jfredett: You would probably find the "Behavioural Derivative" paper interesting.
17:25:45 <ddarius> (Perhaps with some work/background research.)
17:25:47 <jfredett> link?
17:26:05 <ddarius> It's linked from the second like I postede.
17:26:12 <jfredett> I like the idea of pushing calculus into areas it doesn't seemingly belong, like datatypes and such
17:26:26 <ddarius> Then you'll definitely like that paper.
17:26:35 <pjd> general generalization
17:27:02 <wli> jfredett: You'll probably like differential Galois theory, too.
17:27:17 <jfredett> wli: I know-
17:27:55 <jfredett> i like all that stuff, rings, fields, the like
17:27:59 <jfredett> abstract algebra rocks.
17:28:00 <jfredett> :)
17:28:16 <Nafai> So...close...
17:28:27 <jfredett> Nafai: ?
17:29:17 <dons> http://programming.reddit.com/info/2a3ws/details :)
17:29:18 <oasisbot> Title: Concurrent Programming and Transactional Memory : Simon Peyton-Jones @ OSCON [vi ...
17:29:25 <Nafai> Sorry...just trying to figure some things out but not quite there :)
17:29:55 <jfredett> I just watched the Useless/Safe Useful/Unsafe talk a minute ago
17:30:06 <jfredett> I want to program in nirvana, :/
17:30:31 <ddarius> Nirvana would be a nice but boring language.
17:30:40 <jfredett> ddarius: probably, but I like boring
17:30:45 <jfredett> boring is fun
17:30:55 <jfredett> it makes me feel smart
17:31:00 <jfredett> when I'm bored with a subject
17:31:44 <ddarius> And then you go and find a new subject.
17:32:16 <jfredett> yeh
17:32:26 <jfredett> i dunno
17:32:37 * ptolomy finds himself wishing on a weekly basis that people would not create their reference implementations in C..
17:32:56 <jfredett> Nirvana is only reachable asymptoticly anyway
17:32:57 <ddarius> Go to the ECMAScript page and relax for a while.
17:33:40 <hpaste>  dozer pasted "GADT" at http://hpaste.org/1909
17:33:58 <dozer> is this how you're meant to use GADTs?
17:34:00 <jfredett> eeGADTs! dozer!
17:34:13 <ptolomy> ooh, SML/NJ.
17:34:15 <ptolomy> Good for hem.
17:34:20 <ptolomy> s/hem/them/
17:34:40 <dozer> and in particular, is there a way to collapse the NNFNegation_* constructors down to one while keeping the same restrictions?
17:37:41 <hpaste>  Nafai pasted "What am I doing wrong?" at http://hpaste.org/1910
17:37:48 <Nafai> I'm sure being annoying today :)
17:39:25 <jfredett> dozer, I honestly have no idea
17:39:29 <jfredett> :/
17:39:31 <jfredett> sorry
17:39:52 <dozer> jfredett: don't worry - it's my first attempt at using GADTs
17:40:22 <jfredett> yah- I've only used them in a few trivial cases,
17:40:50 <jfredett> Nafai, well, theres the "mport" at the very begining, but I'll assume thats a copy/paste error
17:42:08 <Nafai> jfredett: Yeah
17:43:57 <jfredett> what is the (hGetContents h) >>= (... trying to do?
17:44:08 <jfredett> that is- what is it supposed to be doing
17:44:25 <jfredett> you're obviously getting a type error, it want's (), you're giving it [()]
17:45:16 <kpreid> that should fix it
17:45:21 <kpreid> mapM_ notify
17:45:23 <jfredett> could it be that you meant (mapM notify) $ lines? instead of (.) ? I'm just trying to see a way to get it through the type checker
17:45:41 <jfredett> oh- kpreid gets it
17:45:44 <jfredett> cool
17:47:24 <Nafai> Yeah, that's it
17:48:30 <Nafai> It compiles but doesn't work
17:48:34 <jfredett> hmm
17:48:38 <Nafai> Probably not working with gtk right
17:52:26 <Nafai> But I have no clue of how to track down exactly what the problem is
17:52:46 <ptolomy> .. Are SPJ's slides from the OSCON talk available?
17:53:35 <Nafai> Yes
17:54:42 <Nafai>  http://conferences.oreillynet.com/presentations/os2007/os_peytonjones.pdf
17:54:43 <oasisbot> http://tinyurl.com/ysvquz
17:54:55 <Nafai> Or are you talking about the other one?
17:55:42 <Nafai> slides for all OSCON stuff is here: http://conferences.oreillynet.com/pub/w/58/presentations.html
17:55:43 <oasisbot> Title: O'Reilly Open Source Convention 2007 &#8226; July 23-27, 2007 &#8226; Portland,  ...
18:14:08 <mrd> ok, i just spawned 100 threads each modelling a bouncing ball and communicating via STM to a rendering thread in gtkGLext
18:14:53 <Nafai> mrd: Awesome
18:16:02 <ddarius> mrd: Do the balls against each other?
18:16:56 <Cale> I just had an idea for the people working on ICFP 2006 -- has anyone considered using Harpy?
18:17:01 <mrd> no, i haven't been that adventurous yet =)
18:17:23 <wli> What's Harpy?
18:17:36 <mrd> now i'm going to just try it with 1 thread operating on array, which is probably much saner
18:17:38 <Cale> x86 code generation
18:17:39 <sorear> Cale: uhm, why?
18:17:40 <mrd> er, 2 threads
18:17:45 <wli> Cale: Very interesting.
18:17:45 <Botje> heh
18:17:53 <wli> Cale: JIT -related?
18:17:55 <Botje> SPJ stole a graph from the perl6 crew :)
18:18:13 <sorear> Botje: Yup, he's used it many times.
18:18:17 <Botje> oh
18:18:32 <Botje> first time I see it
18:18:37 <sorear> could have been the other way around I suppose?
18:18:52 <Botje> is there an archive of his talks somewhere? (besides his homepage)
18:18:59 <Botje> probably
18:19:20 <Botje> anyway, i'll continue the slideshow and then go to bed
18:19:23 <Botje> 03:18 :(
18:19:41 <Cale> I'm not actually that familiar with the UM code, but presumably if you could compile it into x86 ops, you could get fairly decent performance.
18:21:18 <Pupeno> I remember reading that HaPp
18:21:47 <Pupeno> I remember reading that HAppS uses parallel haskell, but I can't find it anymore; did I dream it?
18:21:52 <desp> are the videos of SPJ et al out yet?
18:21:58 <sorear> Yes.
18:22:12 <sorear> 16:45 < CosmicRay_> woohoo!  http://blip.tv/file/get/OSCON-OSCON2007SimonPeytonJones914.mov
18:22:28 <desp> ah, so one video.
18:22:31 <desp> thanks
18:22:53 <Cale> dons has already rebothddited
18:22:56 <Cale> whoops
18:23:05 <Cale> reddited both
18:23:09 <augustss> Botje: I'm pretty sure the Perl6 guys stole it from Simon
18:23:26 <Cale> http://www.blip.tv/file/317758/
18:23:27 <oasisbot> Title: OSCON 2007 - Simon Peyton-Jones
18:24:03 <sorear> I know it was in the HoH paper.
18:24:27 <Cale> I find it especially funny that one of the best talks at the open source convention is being given by a microsoft guy :)
18:25:09 <Binkley> well, a guy who Microsoft pays to write open-source :-)
18:25:21 <mrd> ok, single-array version much smoother =)
18:25:41 <desp> Binkley: a subversive!
18:25:48 <Binkley> In ways!
18:26:15 <desp> Cale: both? what's the other one?
18:26:19 <sorear> Botje: I have a SPJ 2003 reference.  when did P6 start>
18:26:21 <dons> we're still waiting for the full 'taste of haskell' talk
18:26:27 <dons> sorear: 05?
18:26:37 <dons> iirc, Jan/Feb 05.
18:26:42 <dons> Pugs, that is
18:27:15 <sorear> http://research.microsoft.com/~simonpj/Papers/haskell-retrospective/HaskellRetrospective.pdf <- page 46
18:27:43 <mauke> Botje: what graph do you mean?
18:28:16 <desp> dons: can you hook me up with a link to the other video? I don't see anything on reddit under oscon or haskel
18:28:18 <desp> l
18:28:46 <dons> desp, programming.reddit.com
18:28:47 <dons> http://programming.reddit.com/info/2a3ws/comments
18:28:48 <oasisbot> Title: Concurrent Programming and Transactional Memory : Simon Peyton-Jones @ OSCON [vi ...
18:28:58 <desp> oh
18:29:02 <dons> the STM talk is very nice.
18:29:12 <Botje> mauke: http://utsl.gen.nz/talks/perl6.does-ML/images/timeline.png
18:29:12 <desp> so it's just *one* link, not two
18:29:17 <Excedrin> I'd like a transactional wrapper around posix
18:29:18 * desp glares at Cale
18:29:20 <dons> the NDP one wasn't recorded, but its similar to the already recorded one.
18:29:26 <mauke> ah, I see
18:29:32 <dons> leaving the taste of haskell, and the FP keynote
18:29:59 <desp> ahh, a presentation
18:30:12 <|Steve|> STM = software transactional memory?
18:30:17 <mauke> yes
18:31:16 <dons> i think we need a proper video tutorials section
18:31:18 <dons> on the wiki.
18:31:35 <dankna> okay, so I've got a queston on the most Haskelly way to do something, if I'm not interrupting anything.
18:31:49 <dons> please, proceed dankna !
18:31:55 <dankna> I've got these data forms.  I have one piece of code which takes an abstract description of what fields the form has, puts together a dialog box, and handles user interaction.
18:31:57 <dankna> thanks. :)
18:31:58 <dons> we use continuations, so interruptions are fine.
18:32:02 <dankna> hah!
18:32:04 <dankna> indeed.
18:32:23 <dankna> I have another piece of code which serializes and deserializes a filled-out form to xml, for sending over the network
18:32:55 <dankna> what I'm concerned with is how to store the values for the filled-out form
18:33:03 <dankna> I could just use a Data.Map and use string keys for everything
18:33:24 <dankna> that would work fine, because the dialog and UI code could just take a description of what keys the form has
18:33:37 <dankna> (er, s/UI/XML/, but whatever)
18:33:52 <dankna> but then it's, uh, not statically typed in the important way :)
18:34:21 <dons> so you want to embed the keys with structured types, into haskell?
18:34:27 <dons> so perhaps a GADT for the keys?
18:34:31 <dankna> hmm
18:34:41 <dons> there's some other typed/deep embeddings of xml into haskell
18:34:56 <dankna> yeah, I've looked at those, a little
18:34:57 <dons> ?go oleg xml typed
18:34:58 <oasisbot> http://okmij.org/ftp/Scheme/xml.html
18:34:58 <oasisbot> Title: XML and Scheme
18:35:09 <dankna> hm, I'll read through that in a minute
18:36:03 <dankna> well yeah, I guess that is what I want.  I'm actually fine, more or less, with just having the types be flat...
18:36:15 <dankna> like, some small vocabulary of permitted ones, integer/string/whatever
18:36:37 <dons> yea, you might just introduce a light weight GADT for a few basic types
18:36:45 <dons> to catch those a simple set of type errors
18:37:08 <dankna> the way I was originally imagining things is that there would be a record type corresponding to each form type, and I could treat it as a normal record type in the code that cares about its semantics, and in some more generic way in the code that deals with the rest of the world
18:37:12 <dankna> hm
18:37:42 <dons> do you know about using GADTs to embed small languages?
18:37:59 <dankna> but for that to work I couldn't really pass keys, I would have to pass a pair of set/get accessors for each field, and that seems too elaborate
18:38:02 <dankna> only in general, not in Haskell
18:38:05 <wli> dons: I'd like to hear about it.
18:38:38 * Botje wanders off to bed
18:38:41 <Botje> >>= sleep
18:39:14 <dons> dankna: yeah, i'm not sure what the best approach is, without more info. perhaps ask on the mailing list
18:39:18 <dons> someone will have thought about this problem
18:39:24 <dankna> hmm, let me read through http://www.haskell.org/haskellwiki/Generalised_algebraic_datatype and get back to you
18:39:25 <oasisbot> Title: Generalised algebraic datatype - HaskellWiki
18:39:34 <dankna> nod.
18:40:04 <dankna> well, there's many approaches that will work.  as you say, I'm just trying to think ahead a bit and figure out the best.
18:40:14 <dankna> I may do that
18:40:14 <monochrom> wli: Example. data Expr a where { Numeral :: Int -> Expr Int; Equal :: Expr Int -> Expr Int -> Expr Bool; IfThenElse :: Expr Bool -> Expr a -> Expr a -> Expr a }
18:40:57 <monochrom> Hmm, the inside "a" is distinct from the outside "a".
18:41:10 <wli> That could be convenient.
18:41:12 <Cale> desp: what?
18:41:19 <monochrom> So, perhaps the example rewritten: data Expr a where { Numeral :: Int -> Expr Int; Equal :: Expr Int -> Expr Int -> Expr Bool; IfThenElse :: Expr Bool -> Expr b -> Expr b -> Expr b }
18:41:20 <desp> nothing ;)
18:41:31 <monochrom> Yes, wli, it's very very convenient. :)
18:41:38 <Cale> desp: I pasted a link to the other
18:41:49 <Cale> err...
18:41:53 <desp> Cale: no ;)
18:41:54 <Cale> maybe not :)
18:41:56 <Cale> hehe
18:42:01 <desp> I got it now ;)
18:42:07 <Cale> ah, this one's a pdf
18:42:15 <monochrom> Much better than the monotonic "data Expr = Numeral Int | Equal Expr Expr | ... "
18:42:24 <Cale> I'd figured that the pasted link was to the Taste of Haskell tutorial
18:42:45 <Cale> How about the OSCON data parallelism? Is that in the pipeline?
18:43:04 <wli> Basically a kind and a bunch of qualifiers, and maybe a quantifier.
18:43:35 <dons> Cale, the ndp talk wasn't recorded, but it is the same as the one given to the HUGS group
18:43:42 <Cale> dons: ah, okay
18:44:35 <Cale> That was a pretty nice STM talk :) I think he probably got all the really important points across there.
18:44:42 <dons> yeah
18:44:56 <Cale> and it seemed like the audience was enjoying what he had to say :)
18:45:19 <sorear> Cale: that's very good :)
18:45:38 <monochrom> If you ask him "what is a monad" you can get to dine with him. :)
18:45:45 <Cale> hehehe
18:45:53 * sorear would like to know more about these people's attitudes toward haskell and haskellers...
18:46:11 <Cale> I'd actually be rather curious as to how he thinks of them at this time. I know that my answer to the question has changed quite a lot over time.
18:46:22 <monochrom> We the haskell community should henceforth use "what is a monad" as our secret code for "dinner time!"
18:46:30 <Cale> hahaha
18:46:32 <sorear> Cale: who's "he"?
18:46:36 <sorear> still spj?
18:46:41 <Cale> @remember monochrom We the haskell community should henceforth use "what is a monad" as our secret code for "dinner time!"
18:46:41 <oasisbot> Done.
18:46:50 <Cale> sorear: yes
18:47:36 <Cale> The funny thing is that it's almost a philosophical question. Sort of like asking a mathematician "what is a tensor"?
18:47:50 <monochrom> I liken it to "what is a number".
18:47:51 * sorear can't imagine the answer to that being anything but "A standard type class" or "A monoid object in a category of endofunctors"
18:48:01 <Cale> Or indeed, "what is a number"?
18:48:38 <dankna> I have nothing to contribute to this, but am highly amused by it.
18:48:44 <Cale> sorear: My present answer for beginners is to explain the notion of a combinator library briefly and then explain how it's a particular sort of combinator library.
18:49:10 <Cale> This is, I think, the useful answer for programmers.
18:49:23 <monochrom> I begin with a lot of motivating examples. (For both monads and numbers.)
18:49:25 <dons> http://channel9.msdn.com/Showpost.aspx?postid=231495 btw.
18:49:28 <oasisbot> Title: Programming in the Age of Concurrency: Software Transactional Memory
18:49:30 <Binkley> what's wrong with saying it's a way of making the idea of a "computation" first-class
18:49:39 <sorear> Cale: Depends on what kind of mathematician.  Some of them will tell you it's a set well ordered by inclusion and containing only subsets; some will tell you it's a membere of the least fixed point of N = Z | S N :)
18:49:44 <Binkley> well, I guess maybe for some people that would be no more enlightening than the "endofunctor" answer
18:50:13 <monochrom> "computation" is either meaningless or bears too many meanings you never intended.
18:50:24 <lament> what is a number?
18:50:30 <Cale> Binkley: that's also a reasonable thing, except that lots of people still seem baffled when you tell them that, because almost nobody who is doing imperative programming has much familiarity with that
18:50:47 <Cale> (I know that I was confused by that explanation when I started out)
18:50:52 <Binkley> Or maybe, "it's a way to let programmers redefine what the semicolon means"
18:51:05 <Cale> sorear: Some of them will tell you that it's a ring element.
18:51:40 <monochrom> To formal methods people, for example, "computation" means a sequence of states.
18:52:24 <dankna> Redefining the semicolon seems to be on the right track.  I had my little moment of revelation when I read that >>= was the important thing for a monad to define...
18:52:28 <monochrom> "redefine semicolon" works.
18:53:12 <wli> The only way I can understand (>>=) is as x >>= f = join (fmap f x)
18:54:51 <dons> dankna: you find that easier to understand? the 'programmable semicolon' metaphor?
18:55:12 <dankna> well, it would raise a lot of questions that would then immediately need to be answered...
18:55:14 * gwillen is listening intently, as he has always been sort of curious what a monad is. ;-)
18:55:15 <dankna> but yes.
18:55:35 <dankna> it sort of gives the big idea of why it's interesting/useful
18:55:43 <mauke> gwillen: a monad is a container type that supports return and >>=
18:55:43 <dons> yeah. that's what I think
18:55:49 <dons> it doesn't explain how it works, but more what the point is
18:55:53 <dankna> right
18:55:55 <dankna> which is hard to do
18:56:18 <gwillen> mauke: I don't actually know Haskell, I was drawn in here by ICFP discussion. So ">>=" doesn't mean anything to me...
18:56:38 <mauke> gwillen: it's just a function
18:57:15 <pjd> a monad is a slightly fancier functor
18:57:26 <gwillen> I see. So I hear a lot about the "I/O monad" -- is it briefly explicable how it defines ">>=" and "return"?
18:57:45 <sorear> gwillen: it's a type of "actions".
18:57:48 <mauke> well, first you need to understand a bit about IO itself
18:57:52 <dons> http://haskell.org/haskellwiki/Video_presentations
18:57:53 <oasisbot> Title: Video presentations - HaskellWiki
18:57:56 <sorear> gwillen: return :: a -> IO a
18:57:58 <dons> is a new page for haskell videos online
18:57:59 <dankna> no no :) the way you say it is, if you have a sequence of statements in a "do" expression, the statements are implicitly joined by >>= or >>
18:58:10 <dons> Cale, sorear , everyone: any other videos we remember , that could be added?
18:58:12 <pjd> and a functor is essentially "map", for structures in general
18:58:15 <sorear> gwillen: (>>=) :: IO a -> (a -> IO b) -> IO b
18:58:19 <mauke> gwillen: a value of type IO x represents an action that - when executed - returns a value of type x
18:58:23 <sorear> gwillen: the latter one is important.
18:58:49 <mauke> "return" just wraps a value in IO; it's kind of a generic constructor
18:58:59 <sorear> gwillen: so if you have a "action", and a "next thing to do after we know the answer", we can make a combined action.
18:59:14 <sorear> gwillen: and that notion of combination creates the entire system
18:59:19 <gwillen> hmm, okay. The stuff I learned about monads in a class a couple years ago is coming back I think :-)
18:59:22 <mauke> return 42  -- an action, that when executed returns 42
18:59:30 <Cale> dons: There was another one on STM somewhere (not by SPJ), but I think it was more confusing and didn't cover any extra ground apart from the two already listed.
19:00:06 <Cale> gwillen: the important thing to keep in mind is that evaluation never causes IO actions to execute.
19:00:18 <gwillen> So in terms of the IO monad, ">>=" basically means "and then do"?
19:00:22 <mauke> (>>=) takes an existing action m and a callback f, and returns an action that when executed first executes m, then invokes f with the result of m, then executes f's result
19:00:24 <gwillen> Is that what it always means?
19:00:34 <sorear> gwillen: yes.
19:00:36 <mauke> more or less, yes
19:00:53 <Cale> gwillen: yes, basically, though in some monads, the actual order of evaluation is different from that order.
19:01:00 <sorear> gwillen: usually, the second argument will be an anonymous function
19:01:00 <pjd> gwillen: >> is closer to "then"
19:01:16 <DRMacIver> gwillen: It's closer to 'and then make a decision about what to do based on the result of the left hand side'
19:01:20 <pjd> >>= is like "into"
19:01:23 <gwillen> I'm going to assume that ">>", which has been mentioned twice now, is defined in terms of >>= and possibly return?
19:01:25 <monochrom> A group of blind friends encounter an elephant for the first time. One of them says, "oh, so an elephant is like a thick tube." He's with the elephant's nose. Another says, "No, it's like a large flap." He's with an ear. Yet another says, "No way, it's like a rope." He's with the tail. Yet another says, "screw all that, it's like a wide pillar." He's with a leg.  That is our current state of the art to "what is a monad".
19:01:30 <sorear> gwillen: eg, getLine >>= \x -> putStrLn x   is an action that reads a line, calls it x, and p[rints it.
19:01:31 <dons> Cale, who's the speaker in `Advanced Topics in Programming Languages'
19:01:33 <dons> it won't play for me.
19:01:37 <Cale> gwillen: x >> y = x >>= const y
19:01:40 <dons> http://video.google.com/videoplay?docid=-4851250372422374791
19:01:40 <oasisbot> Title: Advanced Topics in Programming Languages Series: Parametric Polymorphism
19:01:41 <sorear> @src >>
19:01:41 <oasisbot> m >> k      = m >>= \_ -> k
19:01:54 <mauke> >> is an >>= that ignores the return value
19:01:56 <ddarius> monochrom: For some values of "our".
19:01:56 <pjd> gwillen: >>= feeds the left's result into the right, >> throws it away
19:02:04 <Cale> dons: Phil Gossett
19:02:05 <gwillen> Ahh, okay.
19:02:18 <dons> Cale, is it about Haskell -- I was just guessing
19:02:27 <gwillen> \_ -> k would be like SML's fn _ -> k?
19:02:33 <sorear> exactly.
19:02:42 <sorear> Oh, you know SML.
19:02:50 <sorear> This makes things *much* easier.
19:02:52 <gwillen> Heh, yes. I maybe should have mentioned :-)
19:02:54 <Cale> dons: The proper name of the talk is Parametric Polymorphism and the Girard-Reynolds Isomorphism, and yeah, I'd say it's a Haskell talk :)
19:02:56 <pjd> gwillen: you could write that simply as getLine >>= putStrLn
19:03:06 <dons> ok :)
19:03:09 <pjd> ("getLine into putStrLn")
19:03:13 <nornagon> @hoogle (:+)
19:03:13 <oasisbot> Did you mean: (:+)
19:03:13 <oasisbot> Prelude.undefined :: a
19:03:13 <oasisbot> Control.Monad.Reader.ask :: MonadReader r m => m r
19:03:16 <Cale> dons: Not *really* Haskell-specific, but close enough. :)
19:03:23 <nornagon> uh.
19:03:49 <ddarius> nornagon: Did you mean "uh."
19:03:57 <dons> ah yes, the ghc hackathon presentatoins.
19:04:05 <Cale> nornagon: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Complex.html
19:04:06 <oasisbot> http://tinyurl.com/yoxgys
19:04:08 <nornagon> oh, Data.Complex.
19:04:14 <nornagon> thanks :)
19:04:18 <ddarius> @index (:+)
19:04:18 <oasisbot> Data.Complex
19:04:27 <Cale> heh, that's a cute smiley
19:04:37 <ddarius> hoogle is usually a better index, but not always
19:04:38 <dons> thanks Binkley
19:04:44 <monochrom> Don't you know that Haskell is the smiley language? :)
19:04:51 <Binkley> (:[])
19:05:41 <ddarius> :t (.).(.)
19:05:43 <oasisbot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
19:05:55 <gwillen> Ok, so now I think I understand the IO monad, although not exactly when/why one would use it. (Or how it differs from just making a function from unit to whatever it was you were going to do.)
19:06:08 <gwillen> Do I dare ask what else one does with monads? :-)
19:06:25 <sorear> gwillen: Haskell is SML, but  1. it's pure  2. order of evaluation is such as to never perform an infinite computation if it can be avoided (in the jargon, non-strict)   3. your entire program is in a giant let rec  5. types are curried  4. Constraints are implicitly propagated on types, the type scheme Monad m => a -> m a does NOT work for all m but, when instantiated, creates a Monad constraint for the new m; constraints are collected durin
19:06:31 <mauke> gwillen: you use IO to do I/O :-)
19:06:33 <sorear> and that's pretty much it.
19:06:36 <ddarius> You can't do anything with a value of IO a but combine it into a bigger value of IO a and bind it to main.
19:06:40 <pjd> the "main thing" behind the IO monad is composition
19:06:48 <dankna> there's the Maybe and List monads...
19:07:02 <pjd> when you combine any two IO actions with >> or >>=, you get a new first-class action
19:07:15 <mauke> gwillen: functions from unit are useless because you can always remove the parameter
19:07:22 <mauke> *always* :-)
19:07:23 <ddarius> gwillen: And the numbers go 1,2,3,5,4
19:07:26 <pjd> which can be further combined with other actions in arbitrary ways
19:07:48 <pjd> (all while remaining referentially transparent)
19:07:50 <gwillen> mauke: I'm not sure I understand -- in SML at least, I'm accustomed to using a function-from-unit to suspend a computation.
19:07:53 <sorear> gwillen: in many ways, monadic IO gives us the benefits of ALGOL-style callbyname without the nasty suprises.
19:07:53 <ddarius> gwillen: Nothing never gets executed when you play around with IO a values.
19:08:00 <sorear> @src replicateM_
19:08:01 <oasisbot> replicateM_ n x = sequence_ (replicate n x)
19:08:13 <sorear> @src sequence_
19:08:14 <oasisbot> sequence_ ms = foldr (>>) (return ()) ms
19:08:15 <Cale> sorear: the end of your message was cut off by the length restriction at "constraints are collected duri"
19:08:20 <sorear> bah, HOFS.
19:08:31 <mauke> gwillen: in haskell, all computations are suspended
19:08:36 <monochrom> "what one does to monads" is a nice question to answer, since it's much more to the point. I use a monad to pass around states without syntactic clutter. I also use another monad to write code that looks and works like depth-first search (of a game tree, say) and backtracking.
19:08:39 <gwillen> sorear: foldr is your friend :-)
19:08:40 <sorear> gwillen: 4. Constraints are implicitly propagated on types, Monad m => a -> m a
19:08:46 <ddarius> gwillen: Oh, I misread a bit what you said.  Then another important thing is that IO is an abstract type.
19:08:57 <sorear>                 in a giant let rec  5. types are curried  4. Constraints are implicitly propagated on types, the type scheme Monad m => a -> m a does NOT work for all m but, when instantiated, creates a Monad
19:09:01 <sorear>                 constraint for the new m; constraints are collected during generalization  6. layout matters   7. there are local syntactic differences   8. the module system is very different
19:09:01 <Cale> gwillen: Do you know what a combinator library is?
19:09:11 <ddarius> sorear: Maybe you should just hpaste it?
19:09:13 <mauke> gwillen: you can actually define "if" in userspace in Haskell
19:09:19 <gwillen> Cale: ... not really?
19:09:24 <Cale> sorear: It's kind of like the list of differences between cricket and baseball :)
19:09:51 <monochrom> It is also possible and popular to write recursive-descent parsers in another monad.
19:10:04 <Cale> gwillen: Okay, a combinator library is basically a library with a sufficiently expressive API that using it is like programming in a small language embedded inside your existing one.
19:10:11 <ddarius> gwillen: You could implement an IO monad in ML as an abstract type wrapping a () -> 'a
19:10:28 <ddarius> unit -> 'a that is
19:10:42 <Cale> gwillen: Monads are essentially a specific sort of combinator library, that supports a few basic means of combination.
19:10:51 <hpaste>  sorear pasted "essentially complete list of differences between Haskell and SML" at http://hpaste.org/1911
19:11:30 <mauke> typeclasses?
19:11:32 <gwillen> ddarius, okay. That makes sense.
19:11:33 <sorear> let return a = fun () => a ;;
19:11:33 <Cale> Like, you might have a combinator library which handles parsing, and it would have parsers as values, and would provide you with some basic primitive parsers for parsing things like single characters
19:11:45 <Cale> and then some way to combine parsers into more complicated ones
19:11:52 <sorear> let >>= a b = fun () => b (a ()) () ;;
19:12:19 <Cale> Saying that the library is monadic just means that there are specific operations defined in it, so that you get a bunch of general control structures for free.
19:12:31 <sorear> hah, I just managed to use the Coq syntax for abstractions.
19:12:34 <Cale> (There's a library called Control.Monad which defines many of these)
19:12:36 <sorear> brains!
19:12:38 <gwillen> Cale: That sentence sounds interesting but doesn't mean a whole lot to me?
19:12:47 <sorear> gwillen: look at eg. when
19:12:48 <gwillen> The one about defining what it means for a library to be monadic.
19:12:50 <sorear> @src when
19:12:50 <Cale> Okay, so let's do an example
19:12:50 <oasisbot> when p s = if p then s else return ()
19:12:55 <Cale> ah, okay
19:13:05 <sorear> gwillen: so when encapsulates an effectful if.
19:13:20 <sorear> when (i > 10) (putStrLn "I is greater than ten")
19:13:38 <sorear> @src mapM_
19:13:38 <oasisbot> mapM_ f as = sequence_ (map f as)
19:13:50 <Cale> Or how about just plain sequence?
19:13:51 <sorear> mapM_ is foreach
19:13:56 <sorear> @src sequence_
19:13:56 <oasisbot> sequence_ ms = foldr (>>) (return ()) ms
19:13:58 <Cale> @src forM_
19:13:58 <oasisbot> forM_ = flip mapM_
19:13:59 <sorear> @src sequence
19:13:59 <oasisbot> sequence ms = foldr k (return []) ms
19:14:00 <oasisbot>     where
19:14:00 <oasisbot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
19:14:02 <Cale> heh
19:14:14 <Cale> The @src for lots of things kind of sucks, and sequence is one of them
19:14:20 <sorear> gwillen: Do you understand foldr?
19:14:28 <ddarius> Indeed, sequence = foldr (liftM2 (:)) (return [])
19:14:39 <gwillen> sorear, yeah
19:14:42 <Cale> What sequence does is to turn a list of actions, into an action which performs each in turn, returning a list of their results.
19:14:52 <Cale> sequence [] = return []
19:15:08 <Cale> sequence (x:xs) = do { v <- x; vs <- sequence xs; return (v:vs) }
19:15:25 <Cale> So for instance,
19:15:33 <gwillen> so does sequence work with any monad? or just the IO monad?
19:15:37 <sorear> Any.
19:15:38 <Cale> any monad
19:15:39 <ddarius> :t sequence
19:15:41 <oasisbot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
19:15:43 <gwillen> Ahh, okay.
19:15:48 <sorear> We have qualified type inference.
19:15:49 <Cale> In the IO monad, it just runs things in turn
19:16:06 <Cale> In a parsing monad, it takes a list of parsers, and gives one which parses each of those things in turn
19:16:08 <mrd> > sequence [[1,2],[3,4]]
19:16:10 <oasisbot>  [[1,3],[1,4],[2,3],[2,4]]
19:16:12 <monochrom> ain't it nice. code reuse at its finest. ok, you have seen that with c++ stl :)
19:16:21 <Cale> In the list monad, it's a sort of Cartesian product.
19:16:23 <sorear> gwillen: In the SML community, how much talk is there of qualified types?
19:16:42 <gwillen> sorear: I'm not exactly an active member of the SML community... and I also don't know what that is.
19:16:50 <sorear> Okay, nm then :)
19:16:54 <mauke> :t (<)
19:16:54 <Cale> In the reader monad, it's a kind of flipped around 'map' which applies a list of functions to a single value.
19:16:55 <oasisbot> forall a. (Ord a) => a -> a -> Bool
19:17:14 <Cale> > sequence [(+2), (*2), (^2), (2^)] 5
19:17:15 <oasisbot>  [7,10,25,32]
19:17:17 <gwillen> Cale: what is the reader monad?
19:17:20 <sorear> In the Maybe (uninformative failure) monad, it turns a list of things that might fail into a list that itself might fail.
19:17:32 <sorear> > sequence [ Just 1, Just 2, Just 3 ]
19:17:33 <oasisbot>  Just [1,2,3]
19:17:36 <pjd> gwillen: shared environment
19:17:37 <sorear> > sequence [ Just 1, Nothing, Just 3 ]
19:17:38 <oasisbot>  Nothing
19:17:39 <Cale> Well, really, I'm talking about the monad ((->) e), which is the monad of functions from a fixed type.
19:17:45 <mauke> gwillen: a monad that carries a local environment
19:17:46 <sorear> gwillen: and yes, Maybe is option
19:17:50 <dankna> "uninformative failure" is an amusing way to put it
19:17:50 <Cale> So, ((->) e) a = (a -> e)
19:17:53 <Cale> er
19:17:54 <Cale> no
19:17:55 <gwillen> sorear, heh -- I was going to ask :-)
19:17:57 <Cale> (e -> a)
19:17:58 <Cale> blah
19:18:02 <mrd> failure is not an option!
19:18:09 <chrisamaphone> haha
19:18:11 <ddarius> Yeah, undefined would be uninformative.
19:18:55 <lament> so, monads are really simple things, aren't they? :)
19:18:57 <gwillen> Interesting... so sequence represents, in some sense, the operation of pushing a list into a monad.
19:19:02 <sorear> yeah
19:19:04 <ddarius> lament: Yes.
19:19:06 <Cale> lament: yes, the idea is terribly simple
19:19:20 <lament> well, then why all the confusion? :)
19:19:24 <sorear> gwillen: Are you familiar with the SML pattern of using modules to express eg ordering relations on a type?
19:19:25 <Cale> lament: It's too simple to be understood properly just by looking at it. You have to see examples :)
19:19:34 <ddarius> lament: People like to add complexity to things.
19:19:44 <lament> yeah, especially relationships
19:19:49 <gwillen> sorear, yeah.
19:19:54 <monochrom> lament: see my elephant story.
19:19:55 <Cale> lament: also, we're getting pretty good at making the explanation look easy
19:20:03 <sorear> gwillen: Type classes are the same, but less powerful because they can't contain types and they must be uniquely determined by the type
19:20:11 <Cale> lament: A few years ago, we had a much worse idea of what they were.
19:20:28 <gwillen> sorear, that would have gone right over my head if someone hadn't already told me what type classes were :-)
19:20:36 <sorear> gwillen: but conversely, type class abstraction can be inferred - SML won't automatically turn a function in a functor.
19:20:40 <sorear> gwillen: oh. :)
19:20:46 * ddarius has been happy with his "idea" of what monads are (in Haskell and generally) for many years now.
19:21:16 <gwillen> also sorear -- I missed the link between type classes and monads?
19:21:16 <Cale> sorear: Uh, can't they now? :)
19:21:20 <chrisamaphone> it may say something that the category theoretic definition of a monad is still the only one that makes any sense to me :/
19:21:22 <Cale> sorear: (contain types)
19:21:26 <dons> are we still talking about monads here? geez. last time i was here in 2002, people were taking about monads. what's with you haskellers?
19:21:32 <Cale> At least, that's coming up soon :)
19:21:38 <sorear> gwillen: monad is an ordinary type class.
19:21:40 <sorear> @src Monad
19:21:40 <oasisbot> class  Monad m  where
19:21:40 <oasisbot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
19:21:40 <oasisbot>     (>>)        :: forall a b. m a -> m b -> m b
19:21:40 <oasisbot>     return      :: a -> m a
19:21:40 <oasisbot>     fail        :: String -> m a
19:21:43 <Cale> dons: hahaha
19:21:57 <sorear> Cale: well, it's pretty new.
19:21:58 <monochrom> @remember dons are we still talking about monads here? geez. last time i was here in 2002, people were taking about monads. what's with you haskellers?
19:21:59 <oasisbot> Not enough privileges
19:22:01 <wli> Shall we speak of arrows instead?
19:22:05 <monochrom> Darn :)
19:22:05 <Cale> chrisamaphone: Were you listening to the combinator library approach?
19:22:15 <sorear> @google type classes and monads a constructive comparison manuel chakravarty
19:22:17 <oasisbot> http://www.haskell.org/haskellwiki/Research_papers/Type_systems
19:22:17 <oasisbot> Title: Research papers/Type systems - HaskellWiki
19:22:23 <Nafai> SPJ is remarkably eloquent
19:22:24 <ddarius> chisamaphone: Well Haskell monads are more than just CT monads.  Moggi's notions of computation were strong monads with mono units.
19:22:25 <monochrom> What is a functional language?
19:22:36 <dons> monochrom: oh, that's weird. vincenz must have put @remember into the privledged set
19:22:41 <chrisamaphone> Cale: i saw it, but wasn't paying too much attention
19:22:42 <monochrom> It's ok
19:23:06 <dons> Nafai: yeah, we're spoiled :)
19:23:07 <sorear> dons: No, you did.  About a week ago you pushed a patch removing it from the default Config.hs
19:23:40 <monochrom> Ha I have a better one. What is a community?
19:23:42 <dons> sorear: i thought i just removed all but state from the privledged set
19:23:42 <Cale> chrisamaphone: Okay, here's some translation help:  fmap = T (as applied to functions), join = mu, return = eta,  x >>= f = join (fmap f x)
19:23:58 <lament> what's a function? :)
19:24:03 <dons> sorear:         disabledCommands = ["listchans", "slap", "echo", "remember", "state"]
19:24:08 <dons> is now ["state"]
19:24:11 <sorear> yeah.
19:24:14 <lament> (what's a function is a good question to ask half an hour into an explanation of what's a monda)
19:24:17 <lament> *monad
19:24:18 <sorear> dons that list contains remember
19:24:31 <monochrom> half an hour is very long...
19:24:36 <dons> ah, vincenz has an old bot
19:24:49 <lament> "I seem to be getting the hang of this monad stuff... Just one thing.. what are these "functions" you keep talking about?"
19:24:53 <dons> ?version
19:24:53 <oasisbot> lambdabot 4p537, GHC 6.6.1 (Linux i686 3.00GHz)
19:24:53 <oasisbot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:24:54 <Cale> chrisamaphone: If T is a monad, we think of elements of the type T A as representing computations which if run would produce a value of type A.
19:25:01 <monochrom> lament: hehehe
19:25:16 <sorear> lament: A function is a set of ordered pairs (x,y) satisfying forall x y, (x,y) `elem` f => y = y
19:25:42 <ddarius> So is just the Transactional Memory video available?  I thought there was another one (not just andyjgill's).
19:25:44 <monochrom> Ah! What is a set?
19:26:10 <Cale> chrisamaphone: join = mu :: T (T A) -> T A then can be viewed as turning a computation that computes a computation into a plain computation by simply running the result afterward.
19:26:13 <mauke> sorear: aren't all y = y?
19:26:18 <sorear> A set is an object of discourse.
19:26:29 <sorear> mauke: uhm...
19:26:32 <DRMacIver> monochrom: A function from the universe to { true, false } ;)
19:26:33 <chessguy> a series of tennis matches
19:26:42 <monochrom> hahahaha I like that one
19:26:51 <monochrom> I like both :)
19:27:01 <lament> chessguy: ahh, and what is love?
19:27:02 <Cale> chrisamaphone: and return = eta :: A -> T A  will take a value of type A and give the no-op computation which always returns that value
19:27:12 <Cale> chrisamaphone: Does that help at all?
19:27:13 <ddarius> (x,y) \in f => forall z.(x,z) \in f. y=z
19:27:17 <dankna> a function from pairs of people onto a boolean?
19:27:19 <sorear> Unfortunately, that definition violates the axiom of well foundation.
19:27:20 <chrisamaphone> Cale: yeah, that actually makes a lot of sense.
19:27:20 <chessguy> lament, just another word for nothing :)
19:27:27 <lament> hehehe
19:27:33 <DRMacIver> Recursion: See recursion.
19:27:56 <DRMacIver> (I know, old)
19:28:21 * chessguy hopes his fiancee didn't hear him say that
19:28:40 <monochrom> What is a programmer who can write such a complex program he cannot prove correct?
19:28:53 <ddarius> monochrom: A programmer.
19:28:53 <Cale> chrisamaphone: And  fmap :: (a -> b) -> T a -> T b will do the obvious thing and produce the computation which applies the given function to the result of the given computation
19:29:26 <dons> ddarius: seems to be the only one at the moment.
19:29:35 <ddarius> dons: Okay.
19:29:48 <Cale> chrisamaphone: So, putting join and fmap together,  x >>= f = join (fmap f x) can be viewed as the computation which performs x, applies f to the result, and then performs the result of that.
19:29:49 <ddarius> I misunderstood something.
19:30:18 <Cale> (>>=) :: T a -> (a -> T b) -> T b
19:30:25 <chrisamaphone> Cale: ahh, right -- someone was explaining this same thing to me once, but seeing it written out makes it much clearer.
19:30:25 <ddarius> Now chrisamaphone, turn this back and apply Eilenberg-Moore algebras to Haskel.
19:30:35 <Cale> hehe
19:30:43 <monochrom> What is Eilenberg-Moore algebra?
19:31:05 <chrisamaphone> ddarius: i was about to ask the same thing as monochrom :)
19:32:52 <ddarius> It is a pair of an object, c, in a category C, and an arrow e : T c -> c where T : C -> C is (the functor part of) a monad on C.
19:33:02 <monochrom> I feel like I have been crying wolf. After all those "what is ___" jokes, now no one takes my Eilenberg-Moore question seriously. :)
19:33:20 <davidL> anyone here have an erdos number <=2? :)
19:33:29 <ddarius> e must satisfy some laws, e.g. eta ; e = id.
19:33:42 <Cale> Suppose that (T,return,join) is a monad on the category of Haskell types. Then a T-algebra (A,h) is a type A, together with an arrow h: T A -> A (called the structure map of the algebra) such that h . fmap h = h . join, and h . return = id
19:33:48 <ddarius> davidL: For a second there I thought you wrote <2
19:34:27 <Erdos> My erdos number is 0.
19:34:36 <ddarius> You need the umlaut thingy.
19:34:41 <Erdos> I tried!
19:34:48 <Erdos> That was why I came out as "Erd".
19:34:56 <ddarius> gwillen: I know.
19:35:03 <gwillen> Heh.
19:35:36 <Cale> I'm really not certain about the utility of that notion yet, but it looks an awful lot like a "run function", though usually those are, I suppose, natural transformations where the component at each object gives a T-algebra.
19:36:18 <ddarius> It's not as clear what it's utility _for Haskell programming_
19:36:26 <monochrom> ddarius: would (c, flip evalState 0 :: State Int c -> c) be an Eilenberg-Moore algebra?
19:36:44 <Cale> So whenever you call  runWriter, you'll have to remember that you're really using the structure map for some T-algebra picked from a natural transformation built from them.
19:37:03 <Cale> ddarius: yeah, that's what I mean :)
19:37:55 <ddarius> monochrom: Does it satisfy the law that Cale mentioned, flip evalState 0 . fmap (flip evalState 0) = flip evalState 0 . join ?
19:38:12 <monochrom> Darn, now I have to do the work...
19:38:29 <ddarius> Actually the fact that it is natural in c may provide a lot of the answer...
19:39:12 <mauke> yay, pyramidal error messages
19:40:07 <Cale> monochrom: I suspect so, but I haven't checked :)
19:40:09 <mauke> template<typename T> struct foo { foo<T *> x; };
19:40:15 <mauke> foo<int> v;
19:40:16 <ddarius> monochrom: I think the answer is no though, since the former runs the subcomputation with state 0 while the latter runs it with the state returned by the "join"ed action.
19:40:20 <gwillen> mauke, gah!
19:40:23 <ddarius> s/action/computation
19:40:25 <gwillen> Don't bring those in here! :-P
19:40:52 <mauke> gwillen: the weird thing is that it compiles if you make x a pointer
19:41:01 <ddarius> E.g. evaluated with do put 3; return get
19:41:13 <Cale> oh, right
19:41:19 <Cale> I suppose it doesn't work for State
19:42:23 <ddarius> Cale: I'm sure there are (non-trivial... kinda) Eilenberg-Moore algebras using the State monad.
19:42:37 <gwillen> mauke, meaning if you do { foo<T *> * x; } ?
19:42:42 <mauke> gwillen: yeah
19:42:56 <gwillen> That's because foo is a struct, and struct pointers don't actually need to know anything about the struct type itself
19:42:58 <Cale> ddarius: It wouldn't surprise me :)
19:42:59 <ddarius> What would tripleability look like in this context.
19:43:01 <gwillen> so it actually makes perfect sense
19:43:08 <Cale> ddarius: Perhaps just not natural transformations of them
19:43:26 <gwillen> Or so is my guess -- it's the same reason you can make forward references to structs when defining, eg, other structs, as long as it's a pointer.
19:44:04 <mauke> ah, it's just laziness in the type system
19:44:21 <gwillen> Actually, the more I think about it the more sense it makes. For example you might legitimately want template<typename T> struct node { node<T> * next; T data; }
19:44:40 <mauke> well, that's no problem
19:44:45 <gwillen> mauke, yeah -- it's the only way you can get self- or mutually-referential structs to work.
19:44:52 <monochrom> Now I'm thinking whether the ST monad and runST works.
19:44:52 <glguy> http://www.blip.tv/file/317758/
19:44:53 <oasisbot> Title: OSCON 2007 - Simon Peyton-Jones
19:44:54 <gwillen> mauke, the other is no more of a problem...
19:45:03 <mauke> we'll see
19:45:28 <gwillen> mauke, a struct is not a let rec -- the type is not in scope within its own definition. So the fact that it's the same type is of no help at all.
19:45:48 <ddarius> monochrom: I'm not even sure that that would type check.
19:45:49 <mauke> gwillen: yeah, what helps is that it doesn't actually try to instantiate foo<T>
19:45:51 <gwillen> If I'm making any sense. :-)
19:46:00 <gwillen> mauke, yeah.
19:46:14 <Cale> glguy: which one is that?
19:46:19 <glguy> Cale: not sure yet
19:46:22 <glguy> Cale: just saw it on reddit
19:46:24 <gwillen> And now that I think about it, the struct-ness shouldn't really matter -- it will never instantiate a type just to make a pointer to it.
19:46:25 <glguy> it's not andy's
19:46:35 <ddarius> Then it should be the Transactional Memory one.
19:46:36 <wli> struct s { int x; struct s *p; }; is legal; you have letrec, only enforced to go through a pointer indirection.
19:46:36 <gwillen> Because it knows everything it needs to know about the type just from the fact that it's a pointer.
19:46:42 <mauke> gwillen: no, it doesn't
19:46:52 <mauke> wli: no, struct s is just not in scope there
19:47:08 <mauke> gwillen: different pointer types can have different representations
19:47:20 <Cale> glguy: Oh, that's the one we all already know about :)
19:47:29 <glguy> Cale: is the video any good?
19:47:35 <gwillen> wli: As I was clarifying earlier, it doesn't matter what the type is, as long as it's a pointer C will not question you -- it can be a forward reference and it will work equally well. So there's no let-rec ness going on.
19:47:37 <glguy> in terms of the video itself
19:47:39 <Cale> glguy: Yes, but it won't tell you anything new.
19:47:40 <glguy> not the talk
19:47:43 <jfredett> hey- augustss was mentioned in this google talk, nifty. :)
19:47:44 <Cale> Oh, it's good.
19:47:53 <Cale> The talk was good though
19:48:00 <glguy> so I should replace the placeholder in the topic with that link?
19:48:07 <gwillen> mauke: In theory, yes. In practice I don't know how much the compiler counts on the fact that that is always false...
19:48:21 <Cale> glguy: hm?
19:48:33 <Cale> glguy: ah
19:48:33 <gwillen> I suppose if it only allows this sort of nonsense with struct *s, you only have to restrict all struct pointers to be the same representation.
19:48:37 <ddarius> jfredett: Why wouldn't he be?
19:48:37 <Cale> glguy: perhaps :)
19:48:50 <mauke> gwillen: that's exactly what the C standard does
19:48:59 <gwillen> mauke: Oh, cute. That makes sense.
19:49:09 <jfredett> ddarius: i dunno, i guess it makes sense, the talk i'm watching is about parametric polymorphism
19:49:12 --- mode: ChanServ set +o glguy
19:49:14 --- topic: set to '["OSCON Videos http://www.blip.tv/file/317758/","The Haskell programming language: got types?","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","The language of ICFP winners 3 years running"]' by glguy
19:49:16 <jfredett> and the speaker mentions Djinn
19:49:26 <gwillen> Although the only pointer-type-differences I'm aware of would be near versus far -- and you could definitely have near and far structs.
19:49:30 <monochrom> ddarius: Oh right, runST's "region type variable" will prevent "runST . fmap runST".
19:49:34 <gwillen> So I don't see how that really matches reality.
19:50:22 <monochrom> Now I understand the doubt that this algebra may have little import to haskell programming.
19:50:51 <Cale> glguy: there will be another one
19:50:58 <mauke> gwillen: it's not supposed to :-)
19:51:15 <gwillen> mauke, hah. The C standard comes through, helpful as always. ;-)
19:51:18 <glguy> Cale: you mean the one that andy is working on?
19:51:21 <Cale> glguy: actually, that link kinda sucks because it uses an embed
19:51:32 <Cale> er, odd
19:51:39 <glguy> oh
19:51:42 <gwillen> But that does leave open the question of what it does in practice if you forward-declare a struct pointer on a machine with near and far pointers -- what does it leave room for? Now I'm very curious.
19:51:42 <Cale> It wasn't using an embed only a few mins ago.
19:52:08 <mauke> gwillen: near/far aren't standard C compatible
19:52:23 <Cale> http://blip.tv/file/get/OSCON-OSCON2007SimonPeytonJones914.mov?source=1
19:52:24 <oasisbot> http://tinyurl.com/22avoy
19:52:28 <gwillen> mauke: But for example Turbo C definitely knows how to deal with them.
19:52:32 <Cale> there we go, take the tinyurl :)
19:52:36 <gwillen> So it must have _some_ actual behavior in their presence.
19:52:39 <mauke> then it's a non-standard extension
19:52:43 <gwillen> Well, sure.
19:52:45 --- topic: set to '["OSCON Videos http://tinyurl.com/22avoy","The Haskell programming language: got types?","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","The language of ICFP winners 3 years running"]' by glguy
19:53:10 <gwillen> Although honestly, if the C standard doesn't admit near and far pointers, I wonder what exactly the utility is of admitting different pointer representations at all -- when else does that actually _happen_?
19:53:22 <Cale> now, if only I could get XChat to be smarter about which characters terminate links :)
19:53:30 <mauke> gwillen: when a machine has different word/byte pointers
19:53:31 <ddarius> Cale, yeah...
19:53:31 --- topic: set to '["OSCON Videos http://tinyurl.com/22avoy ","The Haskell programming language: got types?","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","The language of ICFP winners 3 years running"]' by glguy
19:53:41 <gwillen> mauke, Ahh! Okay.
19:53:43 <mauke> gwillen: or very weird function pointers
19:53:53 <gwillen> Oh -- you could maybe use that to allow for closures.
19:53:56 <wli> Yeah, word, byte, and function pointers are the big ones.
19:53:57 <gwillen> That would be cute.
19:54:02 <gwillen> In practice it would break everything, of course.
19:54:07 <mauke> gwillen: http://rafb.net/p/z7GCZx37.html :-)
19:54:08 <oasisbot> Title: Nopaste - No description
19:54:21 <mauke> guess what that does
19:54:22 <wli> The function pointer oddities are there to allow for closures, though the particular representations are awkward.
19:54:31 <Cale> gwillen/mauke/wli: what's this conversation about?
19:54:44 <mauke> Cale: pointers in C
19:54:45 <gwillen> Cale: C. ;-)
19:54:49 <Cale> ah
19:54:55 <wli> ia64 and ppc64 have environment affairs in function descriptors, for instance.
19:55:00 <mauke> triggered by my attempts to translate polymorphic type recursion into C++ templates
19:55:21 <gwillen> wli: That's interesting, considering that gcc allows for psuedoclosures, but doesn't use that mechanism -- they do them using trampolines.
19:56:16 <monochrom> I remember gloriously that the dos world had four memory models: tiny, small, large, huge. (that is, all four combinations of far/near code pointer and far/near data pointer). (I mean I feel glorious that I remember all this. :) )
19:56:36 <ddarius> mauke: Wouldn't that be an... issue for "some" implementations of template expansion?
19:56:48 <gwillen> monochrom: I remember gloriously hearing about those but never understanding them. :-D
19:56:50 <mauke>   where some = all
19:57:06 <ddarius> mauke: Yeah... that was my intent...
19:57:12 <mauke> ddarius: it goes into an infinite loop at compile time
19:57:14 <monochrom> As usual, it was explained as a big fuss, clouding the real issue. :)
19:57:14 <Cale> Yeah, I heard about those as well, but didn't really understand them at the time.
19:57:16 <gwillen> I never successfully used a lot of memory in a C program until the protected-mode days began.
19:57:25 <mauke> where infinite = maximum recursion depth
19:57:39 <mauke> here, about 100 or so
19:58:01 <gwillen> Heh! I hear some implementations set it to about 19, being what the STL experimentally appears to require.
19:58:45 <monochrom> At a programming contest aimed at highschool students (but they invited some of us in universities to play), we had to use Turbo C/Pascal in DOS, and we recursed, and we did hit the 64K stack limit. :)
19:58:58 <gwillen> Heheh.
19:59:09 <glen_quagmire> programming contest lol
19:59:10 <mauke> just use your own stack
19:59:12 <gwillen> I ran into problems trying to make a game and load screen-sized PCX files.
19:59:17 <mauke> made of temporary files
19:59:22 <gwillen> I ran out of heap, as near I could tell at the time.
19:59:30 <mauke> (BTDT)
19:59:41 <monochrom> At that time we were already spoiled by 32bit pointers on Solaris and Linux and even Windows 2000. :)
19:59:59 <gwillen> Hahaha. I was doing this in TC 4.5 for DOS back in about 1996.
20:00:03 <glen_quagmire> my first operating system was Windows95
20:00:12 <Nafai> gwillen: I loved TC 4.5! :)
20:00:13 <gwillen> I had never used Linux, or Solaris, and Win2k didn't exist :-P
20:00:14 <mauke> 98 here
20:00:18 <Cale> Language implementations which don't do tail-recursion implementation should be considered toys and not used in a serious manner. ;)
20:00:18 <monochrom> But understandably, highschools would still use old compilers just because no money or manpower to upgrade.
20:00:25 <gwillen> Nafai: It was the first compiler I ever used.
20:00:30 <Nafai> gwillen: Me too
20:00:30 <gwillen> I have a soft spot for it still. :-D
20:00:35 <Cale> er, tail-recursion optimisation :)
20:00:39 <mauke> Cale: well, what if they allow manual tail recursion?
20:00:47 <gwillen> I remember it had a keyword 'interrupt' to let you do crazy things without inline ASM
20:00:55 <gwillen> That was awesomely useful.
20:00:56 <Nafai> gwillen: My old box with the disks and manuals is still in a closet at my Mom's
20:00:57 <Cale> mauke: like explicit marking of the recursive call as a tail?
20:00:57 <mauke> i.e. an annotation that says "I'd like this to be tail-call optimized"
20:01:00 <mauke> yes
20:01:05 <Cale> mauke: that's still stupid
20:01:11 <ddarius> gwillen: Yep.  I never used it though.
20:01:12 <gwillen> Nafai, I have a tarball of it _somewhere_ in my electronic domain.
20:01:13 <Cale> Since it should be easy to detect them.
20:01:15 <gwillen> Fuck if I know where, though.
20:01:28 <mauke> Cale: but it breaks caller() :-)
20:01:29 <gwillen> I never had a legit copy, my computercamp teacher gave me a bootletg.
20:02:19 <desp> http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WalkZip1/
20:02:20 <oasisbot> Title: From walking to zipping, Part 1: Moving right
20:02:32 <desp> is it bad that this post goes completely over my head?
20:02:34 <Cale> mauke: Isn't that horribly rare?
20:02:46 <Cale> mauke: (if it's what I think you mean...)
20:02:56 <mauke> oh, it's also very slow
20:03:01 <dons_> ccshan's stuff should be on planet haskell
20:03:02 <monochrom> desp: well, it's in Chinese... :)
20:03:13 <ddarius> mauke: http://lambda-the-ultimate.org/node/472#comment-3545
20:03:14 <oasisbot> Title: Ian Bicking: The challenge of metaprogramming | Lambda the Ultimate
20:03:29 <desp> monochrom :)
20:04:16 <Cale> mauke: by 'caller', do you mean essentially a reference to the calling function? That seems like it would be hard to use.
20:04:39 <Cale> Like, if your function is called from more than one place, the calling function would have more than one type.
20:04:39 <mauke> Cale: no, caller() returns information about the caller
20:04:50 <mauke> like filename, package, line number
20:04:53 <Cale> ah
20:05:06 <ddarius> mauke: You're talking about python or some such now?
20:05:13 <mauke> also, function name, context, whether we're in an eval, etc
20:05:16 <mauke> perl :-)
20:05:36 <Cale> That seems like a horrible abstraction-breaker.
20:05:44 <ddarius> Cale: It's Perl!
20:05:47 <Cale> Kind of like dynamic scope.
20:05:57 <mauke> yeah, we have that
20:06:01 <Cale> hehe
20:06:09 * shachaf is back.
20:06:18 <mauke> btw, this is an optimized tail call:  goto &foo;
20:06:19 <monochrom> desp: It is not too bad if the article goes over your head. I find that it takes a lot of time to digest too. Basically both this article and Oleg's related articles plunge into the matter too quickly.
20:07:20 <monochrom> Generic zipper will be the next "what is _____?" wave. :)
20:07:32 <desp> monochrom: it seems to me that it's so far removed from my way of programming that I have no idea even how to think about utilizing this knowledge
20:07:53 <desp> monochrom: abstract examples with tourists really don't seem to help
20:08:05 <monochrom> Expect a hundred blog posts from everyone on "what is a generic zipper" and "what is delimited continuation" in the next three years. :)
20:08:22 <desp> monochrom: and when I see "A (L "x" (A (V "x") (V "x"))) (L "x" (A (V "x") (V "x")))" I get a kernel panic
20:09:00 <monochrom> It would help to do this on a more ordinary binary tree first. Just up, left, right.
20:09:21 <mauke> desp: oh, that's just lambda calculus
20:09:33 <mauke> is that an infinite loop?
20:09:42 <desp> mauke: sure, it is.
20:10:07 <monochrom> After that it would make sense to give a second example on some graph, i.e., sharing nodes can also be handled.
20:10:24 <gwillen> Er, delimited continuation?
20:10:28 <gwillen> What is delimited continuation?
20:10:31 <gwillen> ;-)
20:10:40 <monochrom> You are making history. :)
20:11:01 <monochrom> I bet you're the first one to ask in this channel, ever. :)
20:11:06 <Olathe> I think I read something about a zipper a while back. It was a list of nodes from the head to where you are, I think.
20:11:17 <Olathe> So, what is a delimited continuation ?
20:11:41 <dolio> Ooo, I can pimp my guide, and people can tell me how confusing it is...
20:11:42 <gwillen> does it have anything to do with "continuation marks"?
20:12:00 <dolio> http://haskell.org/haskellwiki/Library/CC-delcont
20:12:01 <oasisbot> Title: Library/CC-delcont - HaskellWiki
20:12:02 <monochrom> Olathe: well, to make things complicated, Oleg and Shan's "generic zipper" is yet different from Huet's original zipper.
20:12:08 <SamB_XP_> monochrom: you are being sarcastic I hope?
20:12:16 <Olathe> Oh.
20:12:24 <monochrom> No, in the past five minutes I was serious.
20:12:39 <Cale> A zipper for a type constructor is just the type which allows for a single "hole" in one of the places where you would have stuck a value of the parameter type.
20:12:49 <SamB_XP_> monochrom: you mean he's the first to ask in the past five minutes?
20:13:12 <monochrom> I *bet* he's the first to ask ever.
20:13:18 <monochrom> My bet may lose.
20:13:20 <Cale> So it's a bit like T' a = T (Maybe a), except with the restriction that there can be only one "Nothing" in the whole structure.
20:13:34 <SamB_XP_> didn't I ask once?
20:13:45 <SamB_XP_> I should have
20:14:02 <monochrom> Alright, I lost the bet, sorry.
20:14:16 <dolio> quicksilver asked a while ago.
20:14:34 <Cale> You can imagine from that how to construct the zipper for a type, by simply breaking up the constructors into cases based on which bit has the hole in it.
20:14:35 <monochrom> Next year it will be asked every hour. :)
20:14:47 <SamB_XP_> oh no
20:14:58 <SamB_XP_> I sense that #haskell1/#haskell2 nonsense coming on!
20:15:19 <gwillen> SamB_XP_: Do I want to know? :-P
20:15:21 <Cale> what?
20:15:33 <Cale> #haskell1/#haskell2?
20:15:45 <monochrom> What happens to #haskell0 ?
20:15:52 <Cale> Do either of these channels exist?
20:15:52 <SamB_XP_> those of you who used to frequent #python may remember a time when it was redirecting at random to one of two channels
20:15:58 <desp> you do not divide by #haskell0
20:16:05 <monochrom> hahahah
20:16:15 <Cale> ahahaha
20:16:23 <Cale> That's awesomely infuriating
20:16:30 <gwillen> Ooh, I kind of like the idea of delimited continuations.
20:16:47 <monochrom> I'm learning delimited continuations too.
20:16:55 <Cale> If you know what continuations are, delimited continuations are exactly what they sound like ;)
20:17:07 <Olathe> What is delimited in them ?
20:17:29 <Cale> Olathe: the rest of the computation is cut off by a marker placed in it
20:17:50 <Olathe> So, you can pause it or something ?
20:18:07 <pjd> ~ eric, the half-a-continuation ~
20:18:08 <monochrom> Very handwavingly: At some point you set a prompt. At a later point you capture the continuation back to that prompt.
20:18:09 <wli> Deferring pieces of the comptation?
20:18:30 <Cale> So the continuation you get when you ask for it is just part of the continuation of the computation, up to that marker.
20:18:34 <monochrom> You can defer. You can invoke. You can throw away. You can invoke several times.
20:18:50 <wli> Ah, invoking several times is different.
20:18:59 <wli> Deferral I know all about.
20:19:06 <pjd> Olathe: it's like a slice of a "full" continuation
20:19:08 <Cale> Remember, the stack is not where you've been, it's where you're going.
20:19:10 <monochrom> You can invoke several times, each time with a different parameter.
20:19:16 <Cale> So it's really forward to that prompt :)
20:19:41 <wli> Deferral I've done in C several times over.
20:20:03 <Olathe> Oh, OK.
20:20:18 <pjd> in other words, a full continuation is one that's delimited indefinitely into the future
20:20:22 <Cale> right
20:20:27 <monochrom> To make things complicated, there are several variations of delimited continuations.
20:20:46 <gwillen> monochrom, oh? (The thing that was linked is only talking about one, it appears...)
20:21:08 <monochrom> Yes, each author is likely to only talk about one - his own. :)
20:21:18 <Cale> So delimited continuations just let you capture the computation from the current context out to the nearest enclosing prompt.
20:21:23 <dolio> gwillen: People have come up with lots of operators, but many of them can be expressed in terms of one another.
20:21:46 <gwillen> Ah, so the idea is the same, it's just the formulation that differs.
20:21:47 <monochrom> Actually, Shan is involved in several. But, each blog article can only afford to talk about one, to be unconfusing. :)
20:21:49 <Cale> And that 'nearest enclosing' business is where I think the variation comes in.
20:21:55 <gwillen> That's fine, my eyes glaze over on the examples anyway. ;-)
20:22:40 <monochrom> That is why I said "very handwavingly". You can alter the details and get various variations.
20:23:03 <gwillen> *nod*
20:23:05 <Cale> The translations between the different types is often not-terribly-obvious.
20:23:07 <gwillen> Actually I'm a systems guy
20:23:20 <gwillen> so reading the delimited continuations in OS paper is making it clear to me immediately :-D
20:23:38 <gwillen> Especially as I have already contemplated the links between scheduling and continuations at length.
20:23:39 <monochrom> One detail you can vary: does the captured continuation include that prompt or no?
20:24:24 <Cale> Heh, I can imagine a variation where you capture the enclosing continuation out to the second prompt you encounter.
20:24:46 <Cale> That ought to be hard enough to reason about ;)
20:25:17 <dolio> That shouldn't be that hard...
20:26:13 <Cale> By doubling up all your prompts, it's clearly at least as expressive.
20:27:00 <monochrom> I have learned the shift/reset version. I am now learning Oleg's version. That is the same (or equivalent in expressive power) as the OS paper and all "generic zipper" articles.
20:27:53 <Cale> I'm not sure I fully comprehend the connection between zippers and delimited computations, but I can imagine what it might be.
20:28:28 <dolio> Well, the idea is that you write a traversal that accepts a 'next direction'...
20:28:51 <dolio> And then you use delimited continuations to pause in the middle of said traversal.
20:28:54 <ddarius> If you foldr a list, but slice up the continuation at each step, what do you get.
20:29:29 <dolio> And at each step you get a view of the sub-term you're at currently.
20:29:34 <gwillen> Julienne continuations!
20:29:41 <Cale> ddarius: strictly?
20:30:00 <dolio> So you can see more than just the element in the hole, strictly speaking.
20:30:35 <Cale> Oh, when you people say 'zipper', are you generally thinking of the type with a plugged hole, or with an open hole?
20:30:53 <ddarius> Cale: For a foldr, that would probably be prudent.  I guess you'd want a monadic one for Haskell.
20:31:08 <ddarius> I want more SPJ video.
20:31:14 <Cale> Hehe, me too
20:31:31 <Cale> Apparently there's hours of it which are coming :)
20:31:34 <dolio> Isn't the derivative the one with the open hole, and then the zipper is a * dt/da?
20:31:53 <Cale> dolio: I usually associate the zipper directly with the derivative
20:32:02 <Cale> But perhaps that's not how people are using the terminology
20:32:13 <Cale> I'm used to the derivative from algebraic combinatorics.
20:32:24 <gwillen> Oh god, type derivatives. I heard someone talking about those once.
20:32:27 <Cale> These ideas are probably at least 50 years old too :)
20:32:29 <gwillen> Then I nearly went insane.
20:32:47 <Cale> CS seems to be rediscovering lots of mathematics these days :)
20:33:19 <ddarius> gwillen: Then you probably wouldn't like the paper I pointed jfredett to involving derivatives of coalgebraic data types.
20:33:25 <SamB_XP_> Cale: mathematics that we've found a use for at long last
20:33:44 <Cale> SamB_XP_: Well, algebraic combinatorics has always been at least somewhat useful :)
20:33:57 <Cale> But the category theory stuff... that's impressive :)
20:34:35 <gwillen> ddarius, it would melt my brain.
20:34:36 <ddarius> Hey, the DSP people did a good job, but they just took it from the analog SP people and they got it because the people who did the math were the people who did the physics too.
20:34:46 <gwillen> I wish I could understand it, but I dropped category theory after like 3 weeks because it cooked my brain.
20:35:26 <dolio> Cale: Anyhow, I think the main motivation for the generic zipper stuf is O(1) access to an arbitrary point in the datastructure. Not the one-hole context idea.
20:36:00 <ddarius> In PL semantics, it's nice to get one-hole contexts "for free".
20:36:26 <dolio> It doesn't seem to stick to the latter. Unless I'm just missing it.
20:36:58 <Cale> Except the fact that you can then plug the hole with more than a single value is also important -- I suppose that also comes from the O(1) access to an arbitrary point thing, but it's not entirely obvious that it's the same :)
20:37:01 <sorear> ..back.
20:37:47 * ddarius thinks he'll read Mac Lane and sleep.
20:39:38 <Cale> mm... I see that Simon made explicit the point that evaluating an IO action has no effect in his recent talk -- that's good. :)
20:39:56 <monochrom> I have a crazy idea. Perhaps Duff's device can be explained by delimited continuations.
20:39:57 <Cale> For some reason a lot of the early tutorials on IO left that point out.
20:40:20 <Cale> (it's obvious once you understand what's being talked about, but not before :)
20:40:30 <SamB_XP_> monochrom: you mean the one where you abuse the fallthroughs in a switch in C?
20:40:42 <SamB_XP_> ... I really don't see how that makes sense...
20:41:14 <gwillen> monochrom, Duff's device cannot be explained. Period. ;-)
20:41:18 <SamB_XP_> also isn't duff's device slower nowadays than it used to be?
20:42:37 <mauke> it's not about speed, it's about readability!
20:42:37 <monochrom> Yes, I mean that.
20:42:53 <desp> haha
20:43:03 <monochrom> I'm thinking how to motivate delimited continuations, not Duff's device.
20:43:27 <SamB_XP_> mauke: if it was about readability you'd just use a simple for loop and skip the device entirely
20:43:37 <mauke> but that's too slow
20:43:48 <SamB_XP_> but you said it's not about speed
20:43:51 <mauke> you need to manually unroll the loop a few times!
20:44:30 <SamB_XP_> I think you should have at least a couple of different copies of the unrolled loop...
20:44:49 <SamB_XP_> one for odd numbers of iterations and one for even numbers, say
20:44:59 <mauke> huh?
20:45:11 <SamB_XP_> and then another one for going around and around...
20:45:25 <SamB_XP_> with no jumps into the middle
20:45:49 * Cale suddenly starts wondering if SPJ is really hiding out in this channel and listening to the tutorials we give to beginners :)
20:45:51 <SamB_XP_> or, maybe you could just have one to start off and one to loop around in
20:46:03 <SamB_XP_> Cale: why?
20:46:10 <mauke> "When you do that, you wind up with a leftover partial loop.  I usually handle this in C with a switch that indexes a list of copies of the original loop body."
20:46:29 <mauke> "Of course, if I were writing assembly language code, I'd just jump into the middle of the unwound loop to deal with the leftovers."
20:46:36 <Cale> SamB_XP_: Just that a number of the improvements we've been making in explaining things like IO, and so on to beginners are showing up in his talk.
20:47:05 <mauke> so the Device decreases code redundancy, which increases understandability/maintainability
20:47:15 <SamB_XP_> Cale: are people blogging them? posting them to mailing lists?
20:47:28 <Cale> SamB_XP_: That's actually likely how it's happening :)
20:47:56 <SamB_XP_> see, that's why we've signed up for
20:48:09 <SamB_XP_> @google haskellwiki haskell-cafe migration
20:48:11 <oasisbot> http://www.haskell.org/haskellwiki/Haskell_Cafe_migration
20:48:11 <oasisbot> Title: Haskell Cafe migration - HaskellWiki
20:50:46 <monochrom> Darn, at the moment, my "Albert Lai" would land at the top of the roster. :)
20:51:09 <Cale> heh, he used my isSubStringOf example of laziness!
20:51:24 <glguy> :t isInfixOf
20:51:27 <oasisbot> forall a. (Eq a) => [a] -> [a] -> Bool
20:51:30 --- mode: glguy set -o glguy
20:51:50 <glguy> is that new to 6.6?
20:51:55 <Cale> yeah
20:52:40 <glguy> I don't really like that they picked infix, something can be "a prefix", I've never heard of something being "an infix"
20:52:58 <Cale> It's really good to hear SPJ talking about why laziness is important. He kind of downplayed it in the hair-shirt article.
20:53:19 <Cale> glguy: I think it's okay. Substring would have been better.
20:53:33 <Cale> After all, there are new uses of language already in the libraries.
20:54:02 <Cale> 'nub', 'intercalate'
20:54:08 <Cale> hmm...
20:54:11 <Cale> :t intercalate
20:54:12 <oasisbot> Not in scope: `intercalate'
20:54:17 <Cale> not yet for that one :)
20:54:57 <SamB_XP_> I thought nub was an old one
20:55:12 <SamB_XP_> doesn't it mean "essence" or "crux"?
20:55:15 <Cale> yes
20:55:25 <Cale> but in the list context, that could mean any number of things
20:55:32 <andyjgill> Who uploaded the video?
20:55:51 <Cale> andyjgill: I'm not sure
20:56:00 <tjm1983> Linguists talk about some languages having infixes (or even circumfixes) but English tends to stick to prefixes and suffixes.
20:56:02 <Cale> andyjgill: You're talking about the STM video?
20:56:10 <andyjgill> Yes.
20:56:15 <andyjgill> The 15 min one
20:56:23 <Cale> andyjgill: I was kind of assuming that you had. :)
20:56:28 <SamB_XP_> personally I would have gone with
20:56:32 <SamB_XP_> isSublistOf
20:56:33 <brad> motd
20:56:38 <SamB_XP_> instead of isInfixOf
20:56:49 <brad> anyone use yi here?
20:56:51 <SamB_XP_> tjm1983: hmm.
20:56:54 <andyjgill> That is what I would have assumed also, but I've got the 3 hour one.
20:56:59 <brad> as in yi the editor?
20:57:03 <Cale> brad: For yi, you'll likely want to talk to dons
20:57:04 <SamB_XP_> tjm1983: and here were are calling those "outfixes" ;-)
20:57:11 <brad> thanks cale
20:57:18 <Cale> dons: are you around?
20:57:30 <enolan> Is video of SPJ's tutorial available on the web?
20:57:37 <brad> dons: "yi: panic! (the 'impossible' happened)"
20:57:40 <Cale> enolan: Not yet, but it's coming.
20:57:40 <SamB_XP_> (basically, the [ ] and [: :] type constructors are what we call outfix)
20:57:46 <brad> not impossible!
20:57:51 <glguy> enolan: it will be in the topic when it is
20:57:57 <andyjgill> No,  but the video will be on the web real soon.
20:58:01 <brad> i was going to watch the video but it requires flash
20:58:05 <enolan> Yay
20:58:06 <Cale> brad: this is during compilation, or execution?
20:58:23 <glguy> andyjgill: where did you plan to host it?
20:58:23 <brad> cale: after the cabal file built, i tried running it
20:58:27 <SamB_XP_> brad: you would prefer silverlight?
20:58:36 <brad> "Could not compile Yi.main!"
20:58:37 <Cale> brad: it doesn't, it's actually an embed -- doesn't work on my machine either, but I got the direct link from firefox's page info
20:58:46 <brad> no SamB - people should export ogg
20:58:46 <Cale> http://tinyurl.com/22avoy
20:58:54 <SamB_XP_> brad: hahaha ogg!
20:58:58 <Cale> (That's a direct link to the video file)
20:59:06 <Cale> I like ogg too.
20:59:06 <andyjgill> What I'm going to do (I expect) is burn a DVD, but put a lower res one on google video, and perhaps have one to download
20:59:09 <brad> i *can* play flash (even youtube) on freebsd with swfdec, but its flaky
20:59:15 <tjm1983> SamB_XP_: Yes; I think I'd prefer isSubListOf, on the grounds that a linguistic infix has a meaning associated, rather than just being a substring; you wouldn't say "ough" is a suffix of "through".
20:59:16 <brad> and i won't use closed source
20:59:26 <Cale> The linux flash player is getting really good.
20:59:31 <brad> whats wrong with ogg sam?
20:59:40 <Cale> They actually seem to have started caring about linux users.
20:59:42 <SamB_XP_> brad: so you *would* prefer silverlight?
20:59:54 <brad> cale - the bug reports for even the latest version of linux flash are a mile long
20:59:57 <Cale> brad: But this isn't flash at all, it's an embedded .mov
21:00:11 <brad> ohhh, then i can use mplayer on it
21:00:14 <Cale> right
21:00:21 <brad> well thats not too bad
21:00:23 <SamB_XP_> brad: it's not a particularly well supported video format
21:00:36 <andyjgill> What would be good for our linux freinds?
21:00:43 <brad> i will wait till i get to work to download it, better throughput
21:00:51 <SamB_XP_> there are even two competing ways of embedding video in Ogg streams, aren't there?
21:00:55 <andyjgill> friends, i should say.
21:00:57 <brad> samb - it will be well supported if people use it!
21:01:13 <SamB_XP_> brad: anyway, MOV is an MPEG standard now!
21:01:27 <Cale> andyjgill: Just a direct link to the video file.
21:01:47 <Cale> andyjgill: Flash also works, but not everyone likes flash.
21:01:56 <andyjgill> what format is good?
21:02:02 <brad> ogg
21:02:09 <Cale> The current .mov isn't ad.
21:02:10 <Cale> bad*
21:02:34 <Cale> mpeg-something?
21:03:17 <Cale> I'm pretty clueless when it comes to video encoding, really.
21:03:40 <Cale> MPlayer will play most anything you throw at it. It's just the browser support for embedded video seems to suck.
21:04:03 <Cale> (As will Totem/Xine/VLC/etc.)
21:04:28 <brad> it will improve if people use open formats
21:07:55 <andyjgill> I'll support what ever format I can. I just don't know which one to choose
21:08:32 <brad> for encoding?
21:08:42 <kaol> what's that talk "later this afternoon" that SPJ referred to?
21:09:39 <Cale> kaol: One on data parallelism - it wasn't recorded, but it's apparently the same he gave to the Hugs group.
21:10:10 <Cale> (though I'm not sure it's exactly the same, since the talk he gave to the Hugs group was pretty interactive)
21:10:56 <Cale> If you'd like, I can give links to Nested Data Parallelism information.
21:10:59 <brad> cale - are there slides for the data parallelism talk? on reddit i only see the video
21:11:13 <Cale> brad: The STM talk you mean?
21:11:22 <Cale> I don't know. It would be nice to have them.
21:11:27 <brad> whoops, yes
21:11:28 <Cale> oh
21:11:43 <Cale> Er, no, I was thinking of the NDP talk, there are slides for that :)
21:11:59 <Cale> The STM talk I don't know.
21:11:59 <brad> actually i bought "beautiful code" to subsidize SPJs work so i bet the bulk of the talk is in his part of the book
21:12:05 <brad> his chapter is on STM
21:12:15 <brad> i haven't read it yet
21:12:17 <Cale> oh, yes, I saw that
21:12:26 <brad> too many good haskell things online
21:12:32 <brad> actually just to much
21:12:40 <brad> sorry "too" much
21:12:46 <Cale> The book chapter is perhaps a bit more in-depth
21:12:47 <brad> me kan dew grmer
21:12:50 <wli> I could use an intermediate-level monad affair.
21:13:13 <Cale> But the talk maybe does a better job of getting the big picture across, because it's so brief.
21:13:48 <wli> Basically monad programming problems with enough structure surrounding them to be meaningful, like chapter 9 of YAHT a dozen times over for different sorts of monadic programming tasks.
21:13:49 <Cale> (I'm really happy about it, getting the word out about STM is rather important, what with all these shared-nothing people :)
21:14:18 <Cale> I really hate the term 'shared-nothing', by the way, did I mention that? :)
21:14:26 <brad> was YAHT ever finished?
21:14:34 <wli> Not that I'm aware of.
21:14:36 <Cale> No, but it's a wikibook now.
21:14:39 <brad> i also hate some things - apple products and all their users
21:14:56 <brad> that was offtopic
21:15:01 <Cale> So we could hypothetically finish YAHT.
21:15:23 <Cale> I also really want to rewrite the wikibook section on monads, but keep forgetting to do it.
21:15:28 <wli> Well, YAHT's value for me was essentially limited to chapter 9, though there were a few odd points here and there.
21:15:45 <brad> please edit the wikibook! its becoming *the* resource
21:15:54 <Cale> When I learned Haskell, I didn't have a hard time just running around the web piecing together bits of tutorials.
21:15:55 <brad> its just awesome
21:16:07 <Cale> But there really should be a few monolithic points.
21:16:22 <Cale> Yeah, the wikibook is mostly quite good.
21:16:54 <brad> its one reason why i donate to wikifoundation
21:17:18 <Cale> There are a few things in it which I remember making me cringe though, and yet were big enough that I didn't want to immediately correct them.
21:17:21 <wli> The wikibook is a little short on exercises.
21:17:25 <dons> Cale?
21:17:40 <dons> btw, cse seems to be (partially?) back up
21:17:48 <dons> for those looking for .au haskell warez
21:18:10 <Cale> dons: I don't remember exactly, but the chapter on monads was the biggest one.
21:18:26 <dons> Cale, no, you pinged earlier?
21:18:27 <brad> dons - yi blew up on me "yi: panic! (the 'impossible' happened):Could not compile Yi.main"
21:18:30 <Cale> dons: oh
21:18:34 <Cale> yes that ^^
21:18:35 <dons> brad: using the darcs versoin?
21:18:39 <dons> brad: better check with jyp.
21:18:42 <dons> he's the boss now
21:18:48 <dons> oasisbot: @part #haskell
21:18:49 <oasisbot> Not enough privileges
21:18:49 <sorear> HURRAY!
21:18:50 <Cale> oh, I didn't know that :)
21:18:51 <brad> no, 0.2 from hackage, but it *did* build without complaint
21:18:52 <dons> vincenz: grr
21:18:58 <sorear> @part #haskell
21:18:59 <oasisbot> Not enough privileges
21:19:18 <sorear> (oops)
21:19:19 <wli> One thing I run into when trying to devise exercises for myself is (a) the things are either too trivial or too huge (b) I lack some way of gauging correctness (c) I just don't have the ideas of what to do without already knowing all about the subject.
21:19:30 <Cale> oasisbot: @part #haskell
21:19:33 <Cale> hehe
21:19:41 <brad> wli - there is the "99 haskell questions"
21:19:47 <brad> worked for me!
21:19:53 <brad> pretty basic though
21:19:54 <Cale> apparently I'm in the ops list for oasisbot :)
21:20:02 <wli> brad: What I run into there is that I end up doing them without using monads.
21:20:18 <brad> yes wli, they are pretty basic
21:20:32 <Cale> wli: I find that combinatorial algorithms are rather nice moderate exercises.
21:21:02 <Cale> Things like finding the permutations of a list of a specific length, or partitions of an integer.
21:21:04 <dons> ?users
21:21:04 <lambdabot> Maximum users seen in #haskell: 326, currently: 325 (99.7%), active: 5 (1.5%)
21:21:09 <wli> Well, not just that, the formulation of a "monadic programming problem" involves specifying the implementation to a degree I can't really do without knowing what it's supposed to look like in the end.
21:21:25 <Cale> wli: oh
21:21:56 <Cale> wli: The best way to think of it is just to think of monads as small embedded programming languages.
21:22:52 <Cale> In other words, combinator libraries
21:22:54 <wli> Cale: I sadly tend not to get much from analogies. I do better with dredging up the internals of how monads operate, like lists doing concatMap etc.
21:23:26 <Cale> Yeah, but how monads operate is somewhat independent of how they're used.
21:23:55 <Cale> For example, the list monad is suited to searching through trees of possibilities nondeterministically.
21:24:43 <wli> Well, that's the one use I really hate them for, and I've gone off and implemented a nondeterminism monad in terms of decision trees to deal with it.
21:24:56 <Cale> Hm? Why?
21:25:03 <wli> But that's neither here nor there.
21:25:33 <Cale> Laziness ensures that the list monad operates in a proper depth-first fashion.
21:25:37 <wli> Cale: Depth-first search vs. breadth-first search vs. infinite decision spaces.
21:25:59 <Cale> Ah, yeah, if you need more control operators in your nondeterminism language, then they're insufficient.
21:26:23 <wli> Cale: I typically need nothing more than breadth-first search.
21:26:34 <Cale> Oh, then it's exactly what you don't need.
21:27:21 <Cale> Usually I'd just write a breadth-first search with no additional abstractions, because it's so easy to do.
21:27:27 <wli> Moving on, it's more of the inductive method. Go around doing things, see the pattern, pick up the generalization.
21:27:40 <Cale> Yeah
21:28:06 <wli> Monad analogies don't fit into that.
21:28:14 <Cale> Eventually you get a sense for the sorts of languages which are 'monadic' and which one might require another kind of abstraction.
21:28:28 <Cale> Oh, they do very much.
21:28:38 <Cale> Monads are just a kind of combinator library.
21:28:54 <wli> Well, it's a style of learning sort of affair.
21:29:34 <Cale> If you set out to write combinator libraries rather than setting out to write monads, then you'll be better off, I think.
21:29:36 <wli> So the notion is to go around building up the repertoire of monadic programming methods by drilling on numerous different sorts of problems.
21:30:10 <wli> Cale: What sorts of combinator libraries?
21:30:39 <Cale> Like, think about how you can represent your problem/solution space by starting with primitive "computations" of some sort, and then a means of "combination" to put those computations together.
21:30:55 <locomalo> ?users
21:30:55 <lambdabot> Maximum users seen in #haskell: 326, currently: 322 (98.8%), active: 5 (1.6%)
21:31:14 <Cale> For example, in a drawing library, you might have computations which are drawings, and various ways to combine smaller drawings into a larger one.
21:31:20 <SamB_XP_> Cale: how do you figure out what sort of generalization it might fit in?
21:31:30 <SamB_XP_> not that it needs to fit in one
21:31:35 <Cale> By the sorts of combination that are available
21:32:00 <wli> Cale: An algebra of the data types being manipulated.
21:32:00 <Cale> Monads are things with a return and a bind -- you have to think a bit about whether your particular library has a sensible notion of those.
21:32:07 <SamB_XP_> I suppose pretty printers are a good example of something that isn't a good fit for monads or an arrows
21:32:15 <SamB_XP_> s/an //
21:32:26 <Cale> Right.
21:32:58 <Cale> But sometimes you do have a monad, and when you do, you make it an instance of monad, and that gives you a bunch of control structures for free.
21:33:16 <wli> Are people going around collecting examples of things that don't fit well into monads, arrows, etc., and trying to develop abstractions like monads, arrows, etc. that deal with them?
21:33:21 <Cale> So at that level, it's a time-saving abstraction :)
21:33:32 <SamB_XP_> wli: probably not exactly
21:33:36 <Cale> wli: sort of :)
21:33:48 <Cale> There's applicative functors, and arrows
21:33:57 <Cale> comonads
21:34:11 <Cale> Then I suppose really basic things like monoids.
21:34:23 <SamB_XP_> pretty printers can be monoids
21:34:23 <Cale> (pretty printers fit in well there)
21:34:25 <Cale> yes
21:34:43 <SamB_XP_> I guess on the "above" combinator
21:35:14 <wli> So the way you go about it is to describe things with some combinatory algebra, and then see if the algebra has some structure to it like monads, arrows, etc.
21:35:17 <Cale> Or concatenation, if you have the right library :)
21:35:18 <SamB_XP_> I wonder if that's the only possible one, or just the only useful opne?
21:35:44 <Cale> See Wadler's "Prettier Printer"
21:35:51 <Cale> http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf
21:35:53 <SamB_XP_> Cale: what is this "concatenation" you speak of?
21:36:30 <Cale> <> in Wadler's sense
21:36:56 <Cale> with nil, the empty document as the unit
21:36:57 <SamB_XP_> I thought <> was horizontal!
21:37:03 <Cale> yes, it is.
21:37:10 <SamB_XP_> that's not a very nice monoid
21:37:16 <Cale> It's acceptable.
21:37:17 <Cale> :)
21:37:36 <Cale> You could also do vertical composition, I suppose, which would make it a monoid in two ways. :)
21:37:37 <SamB_XP_> it may be algebraicly valid, but it leads to ugly text!
21:37:58 <sorear> People don't really try to invent ultra-abstractions.  For the most part they are already well known.
21:38:01 <wli> There's a failure to capture the columnar structure or otherwise 2D structure involved with pretty-printing. In fact, 3D if you consider pagination.
21:38:15 <sorear> Strong lax monoidal functors, for instance.
21:38:16 <wli> sorear: I don't know them. :(
21:38:39 <SamB_XP_> wli: I don't want to consider pagination seperately
21:38:40 <SamB_XP_> er.
21:38:43 <SamB_XP_> I do.
21:38:49 <Cale> wli: What sorear is saying is that they steal them from Category theorists.
21:38:51 <SamB_XP_> yes I want to consider pagination seperately
21:39:06 <SamB_XP_> especially because 99% of pretty printed output is in compiler output
21:39:13 <SamB_XP_> NOT on paper
21:39:20 <Cale> Though I think the category theoretic formulation of Hughes' Arrows is somewhat contrived.
21:39:34 <sorear> well Paterson & McBride think slmf's are well known :)
21:39:40 <Cale> heh
21:39:46 <|Steve|> slmfs?
21:39:48 <Cale> I can guess what that means.
21:39:49 <sorear> I for one have no clue what they are.
21:39:58 <Cale> |Steve|: Strong lax monoidal functors
21:39:59 <sorear> Other than Applicative, of course. :)
21:40:14 <|Steve|> Oh. I'm I'd have to say I'm not familiar with them.
21:40:20 <sorear> Cale: what does strong, lax, monoidal mean?
21:40:22 <|Steve|> er...good luck parsing that.
21:40:39 <wli> Cale: The category theoretic repertoire is what you try to match the common problems that don't fit into e.g. stock categories like monads, comonads, etc. against.
21:40:40 * sorear checks WP
21:41:12 <|Steve|> monads and comonads never came up during my study of CT.
21:41:18 <dons> http://programming.reddit.com/info/2a58z/comments :)
21:41:35 <dons> ?bot what's up?
21:41:35 <lambdabot> :)
21:41:47 <SamB_XP_> Cale: they have a lot of muscle but they don't enforce rules well
21:41:56 <dons> oh, some network stuff still down, it seems
21:42:04 <sorear> oh, that was easy.
21:42:12 <dons> ?google haskell
21:42:15 <lambdabot> http://www.haskell.org/
21:42:15 <lambdabot> Title: Haskell - HaskellWiki
21:42:17 <sorear> monoidal categories are just monads in Cat.
21:42:21 <dons> http://programming.reddit.com/info/2a58z/comments
21:42:24 <Cale> sorear: Well, a monoidal functor is one which splits over some given monoidal structure on the category. For example, (,) gives a monoidal structure of sorts on the category of Haskell types, so a monoidal endofunctor might be one for which there is a natural map: (F a, F b) -> F (a,b)
21:42:32 <dons> weird. " Pointer tagging: Haskell just got 10-15% faster "
21:42:50 <SamB_XP_> dons: you didn't read the paper already?
21:42:52 <sorear> now why does the WP page wait until the third to last sentance to say that?
21:43:03 <SamB_XP_> @google semitagging
21:43:05 <wli> I don't think it's quite meaningful to say that the fact they're sitting around in the category-theoretic repertoire is all that meaningful since you only care about the things there that actually occur.
21:43:06 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/SemiTagging
21:43:06 <lambdabot> Title: SemiTagging - GHC - Trac
21:43:13 <SamB_XP_> @google semitagging simonpj
21:43:15 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/SemiTagging?action=history
21:43:15 <lambdabot> Title: SemiTagging (history) - GHC - Trac
21:43:17 <Cale> er, and a morphism  I -> F I, where I is the unit of the "monoid"
21:43:21 <Cale> In Haskell, that would be ()
21:43:23 <SamB_XP_> @google semitagging simonpj paper
21:43:25 <lambdabot> http://research.microsoft.com/Users/simonpj/Papers/optimistic/icfp2003.pdf
21:43:29 <sorear> @google faster laziness dynamic pointer tagging
21:43:30 <lambdabot> http://research.microsoft.com/research/pubs/view.aspx?0rc=p&type=inproceedings&id=2056
21:43:30 <lambdabot> Title: Faster laziness using dynamic pointer tagging
21:43:39 <dons> SamB_XP_: it got committed
21:43:59 <SamB_XP_> dons: what was the wierd part?
21:44:06 <dons> that lambdabot wasn't working
21:44:10 <SamB_XP_> OH!
21:44:22 <SamB_XP_> I thought you were somehow not expecting GHC to get faster ;-)
21:44:26 <Cale> I can't recall exactly how "lax" modifies "monoidal" here
21:44:38 <sorear> the "STG" machine has had a spine for years, and now it's getting tags.
21:44:44 <dons> no, i do expect it to get as fast as Clean, given a little bit more work
21:44:47 <sorear> soon they'll have to rename it :)
21:44:52 <dons> heh
21:44:58 <SamB_XP_> what are we going to call it now ?
21:44:59 <wli> How do strong lax monoidal functors fit into programming?
21:45:05 <SamB_XP_> the not-actualy-G machine?
21:45:20 <wli> The Spined Tagged G-machine?
21:45:21 <sorear> wli: Control.Applicative
21:45:28 <Cale> But a strong functor is just a monoidal functor T with a map  A (x) T B -> T (A (x) B)
21:45:29 <dolio> They're going to remove the graphs, too? :)
21:45:34 <wli> sorear: Well, that's easy enough.
21:45:36 <SamB_XP_> wli: nice choice
21:45:38 <Cale> So in the case of using (,) for that
21:45:47 <SamB_XP_> since that means we don't have to change much of anything
21:45:48 <Cale> (a,F b) -> F (a,b)
21:45:49 <Adamant> is there any chance Haskell will become as fast as C for large programs in the general case?
21:46:02 <dons> for large programs it probably already is.
21:46:04 <SamB_XP_> Adamant: faster
21:46:11 <dons> since you typically get to do optimisations not available to C.
21:46:16 <dons> its the small benchmarks we care about :)
21:46:19 <SamB_XP_> also you can CHANGE your program
21:46:24 <SamB_XP_> that's an important feature
21:46:36 <Adamant> by "large programs" I mean things that usually get suggested to have a GC. :)
21:46:37 <sorear> Contrarily, C encourages people to fret about the performance of every single line.
21:46:49 <sorear> Haskell makes people wait until the end before optimizing.
21:46:55 <SamB_XP_> Adamant: Haskell is already faster for the unlambda interpreter ;-)
21:47:00 <Adamant> lol
21:47:05 <Cale> haha
21:47:18 <SamB_XP_> probably because it's GC is better
21:47:26 <Adamant> Unlambda - the language of the future
21:47:27 <sorear> The C unlambda interpreter is, um, quite bad in many ways...
21:47:27 <wli> I have things like data NonEmptyList t = Singleton t | NonEmptyCons t (NonEmptyList t) and AtLeastOneof t t' = JustLeft t | JustRight t' | Both t t'
21:47:30 <dons> they say xmonad is pretty fast.
21:47:33 <dons> makes ion look laggy
21:47:39 <SamB_XP_> (than boehm's or reference counting)
21:47:44 <sorear> Boehm GC_malloc for EVERY SINGLE HEAP NODE!
21:47:51 <Cale> The fact that GHC lets you do domain-specific optimisations seems like it would be of ever increasing benefit :)
21:47:55 <SamB_XP_> sorear: yeah
21:48:00 <Cale> (as your application gets larger)
21:48:06 <SamB_XP_> that's why I said "it's probably because it's GC is better"
21:48:18 <dons> and ghc gets to do massive cross-module optimisations
21:48:23 <sorear> I wrote a naive unlambda interpreter with a generational GC.
21:48:24 <dolio> @remember JonHarrop As Haskell has shown, laziness cannot be implemented efficient at all.
21:48:25 <lambdabot> Done.
21:48:25 <SamB_XP_> GHC's GC is *okay* with being used for every single heap node
21:48:32 <dons> dolio: oh, where's that? :)
21:48:39 <dons> man, he's such a troll
21:48:41 <SamB_XP_> sorear: I did too
21:48:43 <dolio> dons: comp.lang.functional
21:48:47 <SamB_XP_> sorear: I bet mine was a lot shorter
21:48:52 <dons> its sad, for someone who's written a book, in the FP community, to be so ridiculous
21:48:52 <SamB_XP_> since I didn't write the collector
21:49:07 <SamB_XP_> (that comes with GHC ;-)
21:49:09 <sorear> it was 50% faster than the Mandelson interpreter, which had a highly optimized engine ... and a simple reference counting allocator
21:49:33 <SamB_XP_> huh.
21:49:36 * sorear notes that his Unlambda compiler is faster still.
21:49:47 <SamB_XP_> you've got me there
21:49:55 <SamB_XP_> I was only a small amount faster than the C one ;-)
21:50:00 <dons> http://google.com test
21:50:01 <lambdabot> Title: Google
21:50:03 <dolio> dons: I actually agree with him sometimes when he argues with lisp guys (which he does a lot).
21:50:07 <dons> http://programming.reddit.com/info/2a58z/details
21:50:14 <SamB_XP_> but the one I was competing against was a slightly less readable program
21:50:15 <dons> yeah, the lisp guys get the brunt of it.
21:50:26 <dons> hmm. reddit being weird.
21:50:35 <wli> I run into things like MonadPlus wanting mzero and Monoid wanting mempty vs. NonEmptyList, and ArrowChoice wanting Either and hating AtLeastOneOf
21:50:45 <sorear> Interestingly, on the (extremely atypical) output of uch, ocamlopt and ghc -O2 perform equally well.
21:50:54 <dons> but the laziness thing is just stupid. look at the say, lazy binary trees benchmarks which wipe ocaml off the map.
21:51:12 <dons> he does troll pretty much every community that could possibly buy his book
21:51:43 <dolio> dons: Yeah, I think he saw too many people adding strictness annotations to attempt to optimize on the mailing list, and made a hasty generalization.
21:51:53 <Cale> Laziness is so important that I think I wouldn't care even if it did make programming a good deal slower. Fortunately, the overhead is minimal.
21:51:55 * sorear thinks adding a strictness analyser to uch would make it vastly faster than every concievable competitor.
21:52:16 <araujo> dons, who?
21:52:21 <wli> sorear: uch being your unlambda compiler?
21:52:31 <sorear> currently it's about as fast as int-e's *interpreter*, and ~2x faster than mandelson-unlambda.
21:52:35 <sorear> yeah.
21:52:37 <bos> araujo: jon harrop
21:52:38 <Cale> People are also too quick to add strictness annotations in an attempt to optimise, though I think people are starting to wise up now :)
21:52:43 <dolio> But he missed, say, the spell checker, where people replaced stict-ish sets with lazy lists and got big wins.
21:52:43 <dons> dolio: hasty over-generalisations is his game
21:52:53 <bos> but those ! are so narrow and easy to add!
21:52:55 <Cale> Sometimes you can improve performance significantly by making things laxier.
21:52:58 <Cale> lazier*
21:53:04 <Adamant> if you were designing a language for ultra-reliability, would you make it lazy?
21:53:09 <dons> Cale, yes, the binary trees benchmark is my favourite example of that.
21:53:13 <araujo> bos, thanks
21:53:14 <dons> though also, the sum-file benchmark is nice
21:53:23 <Cale> Adamant: yes, I would.
21:53:24 <dons> you get best performance from lazy IO summing files
21:53:34 <SamB_XP_> Adamant: if I were designing a language for that, I think I'd make it Epigram
21:53:47 <bos> i'd take an ill-informed enthusiastic newb over a moderately informed troll any day
21:53:58 <Cale> Adamant: Laziness isn't really for or against reliability though, it's more of a composability thing.
21:54:05 <sorear> Epigram isn't strict or lazy! :)
21:54:11 <SamB_XP_> the ill-informed newb knows his limits
21:54:16 <SamB_XP_> sorear: what is it?
21:54:19 <dons> bos, me too. luckily Harrop has zero credibility
21:54:29 <sorear> SamB_XP_: Strongly normalising.
21:54:33 <wli> Cale: So anyway, your point is to look for patterns in combinator libraries, but this is a bit odd for cases like e.g. the graph traversal example in section 9 of YAHT.
21:54:34 <SamB_XP_> anyway, it's very strongly typed
21:54:41 <Cale> Laziness allows you to compose correct algorithms in a performance-maintaining fashion, without hacking them apart and splicing them together.
21:55:05 <SamB_XP_> Cale: and RULES allow you to hack them apart and slice them together after all
21:55:13 <Adamant> ah.
21:55:16 <SamB_XP_> s/slice/splice/
21:55:16 <Cale> wli: yeah, sometimes you have a problem, not a language to solve it in yet :)
21:55:25 <Cale> SamB_XP_: hehe
21:55:49 <SamB_XP_> Cale: because it turns out that O(1) can be really slow sometimes
21:55:59 <Adamant> I just remember people talking about space leaks
21:56:21 <SamB_XP_> Adamant: oh, I'd also run the code on a machine with unbounded memory
21:56:22 <Adamant> wrt Haskell, and wondering if they could be intentionally called
21:56:22 <SamB_XP_> duh
21:56:30 <dons> the issue with strictness and microbenchmarks is interesting
21:56:33 <Adamant> *caused
21:56:50 <dons> since its often profitable to hand optimise the order of evaluation, micro benchmarks tend to avoid laziness more than the average program
21:56:52 <Cale> Adamant: for example... suppose you have the following components: (1) a function which determines if one string is a prefix of another, (2) a function which computes a list of the tails of a string, (3) a function which determines if any of a list of conditions is true
21:56:54 <Adamant> SamB, 4GB should be enough for anyone ;)
21:57:05 <dons> so those who make language conclusions based on micro benchmarks get a weird view of what typical code is like
21:57:09 <wli> The generalization of AtLeastOneOf is basically a coproduct over all nonempty subsets of the type variables, so 2^n-1 cases for n type variables.
21:57:14 <Cale> Adamant: In a strict language, you can't sensibly put those together into a substring-search algorithm
21:57:15 <SamB_XP_> Adamant: that's what bill gates said, and look where he is now
21:57:16 <dons> typically, you don't set about choosing a particular evaluation strategy
21:57:23 <Cale> Adamant: in a lazy language, it's reasonable to do so.
21:57:34 <SamB_XP_> ... probably sitting at his laptop writing Python
21:57:35 <jfredett> SamB_XP_: thats not very dissuading,
21:57:44 <jfredett> and he said 512k, as i remember
21:57:48 <sorear> SamB_XP_: I've heard that's just an urban legend... *looks for cite*
21:57:51 <SamB_XP_> I heard 640k
21:58:00 <jfredett> maybe that was it
21:58:02 <jfredett> it was around there
21:58:05 <Adamant> thanks guys
21:58:11 <SamB_XP_> and it could be an urban legend I guess
21:58:27 <SamB_XP_> but I don't see why he wouldn't think that, after writing all those 8-bit BASIC implementations
21:58:36 <wli> And the way to "smash" it is to have an alternative for each of the possible types, and whenever an element of a type is available in an alternative, to apply the corresponding function to it.
21:58:38 <Adamant> when I get done with work for the summer, I am going to look into Haskell more.
21:58:45 <Cale> x `isSubstringOf` y = or [x `isPrefixOf` z | z <- tails y]
21:58:49 <Cale> or:
21:59:10 <Cale> isSubstringOf x y = any (isPrefixOf x) (tails y)
21:59:27 <SamB_XP_> (granted, sitting at his laptop writing Python is not what I would have expected if I hadn't heard it from an MSR Canada guy...)
21:59:34 <bos> that's how isInfixOf is implemented, in fact
22:00:00 <Cale> Adamant: In Haskell, that's equivalent to the nested-loops solution with early breakouts.
22:00:15 <Cale> bos: I'm surprised they didn't use KMP, it's not much harder.
22:00:29 <Cale> !paste
22:00:30 <hpaste> Haskell paste bin: http://hpaste.org/
22:00:31 <bos> Cale: takes more fingertyping
22:00:32 <SamB_XP_> Cale: so how much faster do you suppose my search will be when zip gets fused?
22:00:42 <Cale> bos: Oh sure, but for a library.
22:00:50 <sorear> A constant factor at best. :)
22:01:22 <SamB_XP_> sorear: buy look at the code
22:01:26 <bos> isInfixOf only got added in the past year, so a faster implementation probably snuck under a reviewer's radar
22:02:05 <SamB_XP_> searchFrom n needle haystack =
22:02:05 <SamB_XP_>      msum $ map (return . fst) $ filter ((needle `LB.isPrefixOf`) . snd) $
22:02:05 <SamB_XP_>      zip [n..] (LB.tails (LB.drop n haystack))
22:02:34 <SamB_XP_> s/buy/but/
22:02:40 * sorear wonders what Bill Gates is doing programming.  he's obviously a much better buisnessman than coder
22:02:58 <wli> sorear: AIUI he never did much programming; that was Paul Allen.
22:03:16 <SamB_XP_> sorear: hobby?
22:03:26 <Adamant> fsck. Epigram has already implimented the ideas I had for a new programming language
22:03:34 <SamB_XP_> Adamant: hahahaha
22:03:40 <dolio> Are you sure it wasn't Reed Robinson?
22:03:45 <hpaste>  Cale pasted "KMP in Haskell." at http://hpaste.org/1912
22:03:59 <Adamant> SamB, I don't mean I understand Epigram
22:04:15 <Adamant> I just had an idea for a language with scalable proofs
22:04:23 <SamB_XP_> Adamant: it would be awful soon for you to understand it
22:04:48 <wli> Cale: Slick.
22:05:27 <Cale> wli: I thought so too :)
22:05:39 <wli> Cale: I wonder if there's something vastly smaller than what I've previously written for building LR(1) DPDA's.
22:05:57 <Adamant> SamB_XP_, that's cold
22:06:24 <SamB_XP_> Adamant: well I just mentioned it a little while ago!
22:07:12 <Adamant> SamB_XP_, ah, I was trying to say I didn't mean I understood all the implimentation, etc.
22:07:30 <dolio> Insinuating that someone can't learn all about dependent typing in 14 minutes is pretty insulting. :)
22:08:48 <Adamant> yeah. I just had an strategy for a language in my head - start with very strong static typing, and allow increasing amounts of proofs to be done on the code in the future.
22:08:55 <SamB_XP_> dolio: I'm merely assuming that he isn't smarter than Oleg
22:09:04 <dolio> Heh.
22:09:05 <SamB_XP_> I assume it took Oleg more than 15 minutes
22:09:13 <Adamant> SamB_XP_, I'm definitely not as smart as Oleg. :)
22:09:59 <glguy> heh, that's an awful lot of assumption
22:10:21 <glguy> I assume that it took Oleg longer than 15 minutes and I assume you aren't as smart as Oleg
22:10:25 <Korollary> It depends on how much time one spends on these things.
22:10:28 <glguy> therefore I can assume you don't understand it
22:10:48 <Korollary> If you've been studying this kind of stuff for years, you have a different learning curve.
22:12:13 <SamB_XP_> glguy: well the other assumption was that his expletive-ridden exclamation that Epigram had already implemented his ideas meant he hadn't looked at epigram before
22:12:26 <glguy> heh, more assumptions ;)
22:12:30 <SamB_XP_> glguy: yeah.
22:12:32 <SamB_XP_> that's 3
22:12:35 <SamB_XP_> one shaky one
22:13:12 <Adamant> I don't know if the ideas are all that original, they're just ideas I've had floating around my head.
22:13:13 <SamB_XP_> I would be willing to buy Oleg a drink if it hadn't taken him at least 15 minutes to understand dependant typing ;-)
22:13:29 <SamB_XP_> except that I'm not old enough until next month
22:13:47 <SamB_XP_> then there's the trifling issue of being probably on the exact opposite side of the world or something
22:13:49 <dolio> Oleg was born understanding dependent typing. He just had to wait for other people to invent it so it had a name.
22:13:53 <Cale> SamB_XP_: What's the age limit where you live?
22:14:00 <SamB_XP_> Cale: 21
22:14:02 <Cale> ah
22:14:52 <Cale> That's rather high, isn't it?
22:15:04 <SamB_XP_> I guess so
22:15:12 <dolio> What is it in most places? 18?
22:15:14 <Adamant> if he's .us, it used to be 18
22:15:28 <SamB_XP_> it seems like a fair number of places have no limits?
22:15:30 <Adamant> well, went from 21 to 18 to 21 again.
22:16:41 <Cale> In Canada it's 18 or 19 (depending on province), with no restriction when you're at home in most places.
22:24:20 <tjm1983> So I posted a response on http://hpaste.org/1892 a day or two ago, and I've really started wondering: are these instances that just aren't possible with Haskell?
22:27:03 <sorear> tjm1983: What you are trying to do is in fact impossible.
22:27:16 <sorear> The closest you can get is a new-type wrapper.
22:27:45 <tjm1983> sorear: Yes; I was trying to avoid wrappign. Is there a good reason it's impossible?
22:27:53 <tjm1983> *wrapping
22:27:59 <xpika> does anyone know of a webhost that supports haskell?
22:28:04 <mrd> i think Half Life is secretly written in Haskell
22:28:26 <dolio> Wait, what's wrong with 'instance Monoid (Array Int a)'?
22:28:35 <dolio> It's 'Int' isn't it?
22:28:42 <sorear> xpika: cox.net doesn't seem to mind serving up .hs text files :)
22:28:42 <mauke> yes
22:29:27 <sorear> tjm1983: Maybe.  The general case of higher order unification (that is, with lambdas or partially applied synonyms) is undecidable.
22:29:38 <tjm1983> dolio: I'm not sure I fully understand asl's one, but my problem seemed similar, so I posted there.
22:30:07 <dolio> tjm1983: Try it with -fglasgow-exts. It should work.
22:30:10 <sorear> tjm1983: it's not at all clear however that you need the full power of HOU to handle instance heads with lambdas.
22:30:19 <dolio> The collection stuff below is impossible, however.
22:31:06 <dolio> Oh, wait, I'm reading the wrong one.
22:31:15 <tjm1983> sorear: What does HOU stand for?
22:31:25 <dons> sorear: you might be interested, rl is attempting to implement some reasonable HOL in ghc + type families. seems to be making some good progress
22:31:43 <tjm1983> Sorry, got it: "higher order unification".
22:32:15 <dons> so a general approach to intuitionistic logic in the type system, without needing 1M olegs, just 1k leshchinskiys
22:33:04 <dons> hmm. russians and type system haxoring. a genetic component?
22:35:41 <tjm1983> Thanks for the confirmation; I thought it might be impossible, but I'm a bit disappointed.
22:37:20 <sorear> dons: I think more of them are in France :)
22:41:52 <Cale> tjm1983: What does the message change to when you add -fglasgow-exts
22:41:53 <Cale> ?
22:42:44 <dons> sorear: true!
22:43:17 <tjm1983> Cale: I'm using hugs; maybe I'll install ghc another day, but today, I'm trying to diagnose a dying disk.
22:43:24 <Cale> tjm1983: ah
22:43:42 <Cale> -98 then, perhaps
22:43:57 <Cale> (to stop using Haskell 98 compatibility)
22:45:13 <tjm1983> Cale: "Not enough arguments for type synonym "ListCollection2"
22:45:27 <Cale> oh
22:45:43 <Cale> You're trying to use type synonyms to define instances, yeah, you can't do that.
22:46:28 <Cale> (I was thinking more about the top post, but I hadn't noticed the names :)
22:46:50 <tjm1983> My problem there is that I have no other way of refering to the type that I'd like to call [(,)]
22:47:03 <Cale> You could newtype it
22:47:21 <sorear> 22:26 < tjm1983> sorear: Yes; I was trying to avoid wrappign. Is there a good reason it's impossible?
22:47:27 <Cale> ah, right
22:47:55 <motion`ib> lambdabot
22:47:59 <motion`ib> lambdabot hello
22:48:04 <tjm1983> I wanted something analogous to a simpler Collection class, which I had no trouble declaring [] to be an instance of.
22:48:06 <motion`ib> lambdabot  hepl
22:48:09 <motion`ib> lambdabot  help
22:48:13 <hpaste>  glguy annotated "I want an instance I can't have" with "instance you can't have?" at http://hpaste.org/1892#a2
22:48:22 <glguy> is that related?
22:48:22 <Cale> motion`ib: if you want to talk to lambdabot, it takes commands in the form @commandname
22:48:26 <glguy> tjm1983: ?
22:48:38 <Cale> motion`ib: what are you interested in doing with lambdabot?
22:48:48 <Cale> @listcommands
22:48:48 <lambdabot> Unknown command, try @list
22:48:50 <Cale> @list
22:48:50 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
22:49:10 <motion`ib> Cale  cool
22:49:24 <motion`ib> i just found out about haskell and im wondering what it can do
22:49:28 <lambdabot> hello, motion`ib! how may I be of assistance?
22:49:32 <Cale> hehe
22:49:43 <tjm1983> glguy: I see only the letter V in your annotation on hpaste.
22:49:51 <glguy> ugh
22:49:52 <motion`ib> @help
22:49:52 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:50:03 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
22:50:09 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
22:50:17 <hpaste>  glguy annotated "I want an instance I can't have" with "corrected" at http://hpaste.org/1892#a3
22:50:22 <mauke> > repeat "butter"
22:50:23 <motion`ib> @help hoogle
22:50:24 <lambdabot>  ["butter","butter","butter","butter","butter","butter","butter","butter","bu...
22:50:24 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
22:50:30 <mauke> oh man, I love butter
22:50:30 <dons> ?hoogle mapM
22:50:31 <lambdabot> Prelude.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
22:50:31 <lambdabot> Maybe.mapMaybe :: (a -> Maybe b) -> [a] -> [b]
22:50:31 <lambdabot> Prelude.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
22:50:46 <dons> mauke: bad for your cholesterol though!
22:50:47 <motion`ib> @hoogle test
22:50:48 <lambdabot> Test.QuickCheck.test :: Testable a => a -> IO ()
22:50:48 <lambdabot> Test.HUnit.Base.test :: Testable t => t -> Test
22:50:48 <lambdabot> Test.HUnit.Base.Test :: data Test
22:50:50 <shachaf> Cale: Is the first Fibonacci number 0? I'm actually not sure of the official definition, I've seen it both as 0 and as 1.
22:51:01 <dons> motion`ib: you can also interact with lambdabot in a privmsg
22:51:04 <mauke> 0 is the zero'th fibonacci number
22:51:06 <Cale> shachaf: It doesn't really matter very much :)
22:51:44 <dons> has anyone ever been injured over the first fibonacci ? I wonder.
22:51:45 <Cale> I usually like the version with 0 a little better
22:52:20 <tjm1983> glguy: Your class declaration uses notation I either never learnt or have since forgotten.
22:52:27 <SamB_XP_> dons: I may possibly have gotten a divide by zero over it...
22:52:33 <mauke> doesn't that break the invariant that fib 12 = 12 ^ 2?
22:52:42 <Cale> dons: Off-by-one error in a fibonacci-growth allocation algorithm for use in an aeronautical control system... :)
22:53:26 <shachaf> Cale: I know. :-) I've heard it with 1 first, though.
22:53:53 <dons> heh. Cale, you know we use a classic fib defn in real world code, in xmonad?
22:53:57 <tjm1983> mauke: fib 0 = 0, fib 1 = 1, ..., fib 12 = 12 ^ 2
22:53:57 <Cale> shachaf: I think that historically they started with 1,1,...
22:54:09 <dons> literally, we rely on:
22:54:10 <dons> fibs :: [Integer]
22:54:10 <dons> fibs = 1 : 1 : (zipWith (+) fibs (tail fibs))
22:54:13 <Cale> dons: I can imagine why.
22:54:16 <dons> which is just so satisfying
22:54:25 <dons> ah, but we don't start at 0!
22:54:28 <Cale> Is it for the spiral mode?
22:54:32 <dons> yep
22:54:35 <Cale> yeah :)
22:54:45 <glguy> tjm1983: class Collection2 c a b | c -> a b where
22:54:54 <dons> its cool that finally there was a use for a lazy fib :)
22:54:55 <glguy> tjm1983: that is a functional dependency
22:55:38 * dolio compiles GHC for free 10% more speed. :)
22:55:39 <tjm1983> Is that in H98, or is it an extension? Even if it's in H98, I may well have never let it sink in.
22:55:48 <tjm1983> glguy:?
22:55:49 <glguy> tjm1983: extension
22:55:54 <dons> we should rerun nobench now
22:55:57 <dons> hmm
22:55:57 <glguy> impatient much?
22:56:01 <wli> > let s = let s' = [1] : zipWith3 (\xs ys n -> zipWith (+) (0:xs) (map (*n) ys ++ [0])) s' s' [1..] in [1] : map (0:) s' in take 5 s
22:56:03 <lambdabot>  [[1],[0,1],[0,1,1],[0,2,3,1],[0,6,11,6,1]]
22:56:08 <Cale> tjm1983: In fact, H98 doesn't even have multiparameter typeclasses
22:56:09 <wli> > let s = let s' = [1] : zipWith (\xs ys -> zipWith (+) (0:xs) (zipWith (*) ys [1..] ++ [0])) s' s' in [1] : map (0:) s' in take 5 s
22:56:10 <lambdabot>  [[1],[0,1],[0,1,1],[0,1,3,1],[0,1,7,6,1]]
22:56:24 <glguy> or just drawing attention? (reread that)
22:56:37 <glguy> I*
22:56:42 <tjm1983> glguy: I don't feel so bad about not knowing about it, if it's an extension.
22:56:53 <sorear> dons: I'd like a few more compilers in the x86 nobench. :)
22:56:55 <glguy> tjm1983: I'm glad your ego is intact ;)
22:57:08 <dons> sorear: oh yes, that too
22:57:23 <dons> i wonder if we'll notice this ptr tagging stuff in any shootout code
22:57:33 <dons> hmm. probably a couple will benefit
22:57:40 <tjm1983> glguy: Do you know if it's only in GHC, or is it in hugs, too?
22:57:41 <Cale> > iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1]
22:57:42 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],...
22:57:48 <glguy> tjm1983: both, mtl uses it
22:58:05 <tjm1983> glguy: What's mtl?
22:58:10 <sorear> @hackage mtl
22:58:10 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mtl
22:58:14 <glguy> monad transformer library
22:58:21 <glguy> State, Reader, Writer
22:58:29 <Cale> tjm1983: The stuff strictly underneath Control.Monad
22:58:34 <tjm1983> Thanks.
22:59:16 <glguy> tjm1983: are you one year older than me? or did you start using Haskell before I was born? :)
22:59:51 <sorear> glguy: the haskell committee was founded in 1987
22:59:58 <tjm1983> glguy: Probably the former, since you ask; almost certainly not the latter.
23:00:48 <glguy> sorear: that would eliminate the second possiblity then , wouldn't it!
23:01:20 * sorear is secure enough in his age that he doesn't feel the need to announce it in his nick.
23:01:34 <glguy> :-/
23:01:49 <glguy> you announce being in highschool all the time in channel though ;)
23:02:38 * tjm1983 chose his nick because he has such a common name that everything else sensible was already taken
23:02:48 <glguy> theodore?
23:02:49 <glguy> ;)
23:02:57 <motion`ib> can haskell replace PHP?
23:02:58 <tjm1983> Tim
23:03:15 <sorear> @quote protontorpedo
23:03:15 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
23:03:16 <araujo> Haskell can replace anything
23:03:19 <sorear> @protontorpedo
23:03:19 <lambdabot> lazy makes macro not needed?
23:03:21 <sorear> @protontorpedo
23:03:21 <glguy> motion`ib: 6 times
23:03:21 <lambdabot> help please
23:03:23 <sorear> @protontorpedo
23:03:23 <lambdabot> I hear from an essay by E raymod that perl is shitty for large projects
23:03:26 <sorear> @protontorpedo
23:03:26 <lambdabot> or does it become a mishmash of code?
23:03:30 <motion`ib> glguy is it alot faster and can do more?
23:03:39 <sorear> motion`ib: Yes, and no.
23:03:41 <glguy> its 2.55x after
23:03:49 <glguy> but does less than php
23:03:54 <dolio> That E raymod is a smart guy.
23:03:55 <glguy> faster*
23:03:56 <motion`ib> less in what terms
23:04:03 <glguy> pounds
23:04:03 <motion`ib> cant connect to a DB?
23:04:06 <dons> motion`ib: we're joking. its a silly question.
23:04:13 <dons> you related to gschuett?
23:04:28 <sorear> haskell can do anything PHP can, and conversely.
23:04:30 <motion`ib> i have no idea what haskell can do, i just discovered it
23:04:38 <motion`ib> and im contemplating if i should learn it
23:04:39 <sorear> the embeddings are trivial in both directions.
23:04:41 <glguy> haskell is a general purpose programming language
23:04:41 <dons> motion`ib: best to start on haskell.org then
23:04:47 <motion`ib> and if i should implement it
23:05:01 <motion`ib> dons  i read the introduction
23:05:16 <Korollary> ever implemented a language before?
23:05:17 <dons> perhaps install ghc, and write a few small programs next, then?
23:05:37 <motion`ib> how would you read webpages in haskell? it converts the code into html?
23:05:42 <motion`ib> err
23:05:44 <motion`ib> write*
23:05:49 <dons> right.
23:06:11 <motion`ib> i want to try to write a webpage using haskell
23:06:17 <dons> look around haskell.org, there are examples for those things.
23:06:21 <motion`ib> is there a compiler for macs?
23:06:31 <motion`ib> will do
23:06:39 <glguy> motion`ib: yes, GHC is highly portable
23:06:49 <motion`ib> thanks\
23:07:07 <motion`ib> im not much of a programmer i mainly do flash and php i hope this wont mess me up in the long run because i want to learn c and all that
23:07:12 <sorear> modern macs will run just about anything.  they can emulate every platform I know of
23:07:29 <sorear> motion`ib: Why do you *want* to learn C?
23:07:56 <dons> as part of a general course in computer science, you should really learn both haskell and C.
23:08:34 <sorear> I think C should be moved to the "computer architecture" section.
23:08:44 <Korollary> It can't be
23:08:52 <sorear> low level stuff is good to know, but C isn't really a general purpose language anymore
23:09:04 <Korollary> It still is.
23:09:08 <motion`ib> dons if i learn haskell before i learn other languages, (silly question maybe) will i be a better programmer in the long run?
23:09:26 <wli> C is actually not all that great at what it's supposed to do.
23:09:33 <motion`ib> i dont really care for c that was just an example, im a web developer though
23:09:33 <dons> quite possibly. many universities (good ones, like oxford) teach haskell as a first language
23:09:37 <araujo> motion`ib, be careful
23:09:54 <motion`ib> araujo  why
23:09:57 <araujo> motion`ib, Haskell is a bad language. It makes you hating other langs.
23:10:03 <dons> if you're only interested in web development, not computer science in general, you could probably just stick to ruby, python, stuff like that
23:10:16 <motion`ib> dons haskell wouldnt be of use then?
23:10:38 <motion`ib> well for one of my projects i need to scrape data off travelocity
23:10:44 <sorear> 21:17 < brad> dons - yi blew up on me "yi: panic! (the 'impossible' happened):Could not compile Yi.main"
23:10:45 <dons> sure, but if you're really just looking to improve web dev skills, beyond php, haskell will be less obviously useful
23:10:49 <sorear> jyp: ^^^
23:11:03 * sorear hates web fuss.
23:11:12 <dons> but then again, so would C. so I guess you're trying to fill in some gaps in your comp. sci knowledge?
23:11:22 * glguy lols
23:11:36 <motion`ib> dons im just openminded and want to learn stuff that may be useful down the road
23:11:44 <bitwiseshiftleft> i'd say haskell is a better language for understanding languages, and c is a better language for understanding systems
23:11:50 <jyp> hey sorear
23:11:58 <dons> yeah. well, haskell certainly won't hurt. you may even learn how to program multicore systems -- that's a useful skill
23:12:08 <dons> so i think, go for it, if you're open minded.
23:12:17 <glguy> dons: how might Haskell help for programming multicore systems?
23:12:19 <dons> start on haskell.org, install ghc, and work through the YAHT tutorial
23:12:22 <dons> ?where yaht
23:12:23 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
23:12:23 <Adamant> might be interested in Erlang as well.
23:12:31 <dons> glguy: oh, you might write a paper about a new concurrency abstraction
23:12:33 <dons> you never know.
23:12:39 <motion`ib> is yaht for web dev stuff?
23:12:46 <bitwiseshiftleft> haskell has stm, which is pretty close to cutting edge
23:12:55 <dons> no. so you want to specifically stick to web development topics?
23:13:19 <motion`ib> dons for now yes
23:13:31 <bitwiseshiftleft> motion`ib: i hear HAppS is pretty nice for web dev
23:13:46 <motion`ib> yea i noticed happs on the apps page
23:13:48 <glguy> however, HAppS might not be the right place to start *learning* haskell
23:14:00 <dons> yaht is a tutorial for learning basic haskell, btw.
23:14:01 <bitwiseshiftleft> yeah, ACID as a monad is kind of deep
23:14:06 <glguy> motion`ib: If you are interested in Haskell, you are going to have to put in some effort to learn to program first
23:14:17 <sorear> jyp: hi.
23:14:20 <glguy> and then worry about using advanced-ish libraries like HAppS
23:14:22 <dons> glguy: oh? we don't have the direct oleg injections ready yet?
23:14:32 <dons> i though they were due this summer?
23:14:38 <glguy> dons: limited supply
23:14:42 <dons> ah. i see.
23:14:49 <glguy> we can't just squander them away
23:15:15 <dons> right. so they're in beta. hopefully they'll be ready soon though, it will save a lot of time!
23:15:51 <dons> then we need to work out how to deliver them using some Oleg-over-IRC protocol
23:16:22 <glguy> some kind of Matrix inspired learning software... "I know Kung Fu"
23:16:39 <dons> yeah, i think that is critical to improving the signal on -cafe@
23:17:00 <glguy> using human bodies as batteries?
23:17:05 <glguy> and hooking them into a power grid?
23:17:07 <dons> key piece of community infrastructure. first hackage, cabal, some libraries, then oleg implants.
23:17:14 <jcreigh> If the matrix had been written in Haskell, people wouldn't have been able to get out.
23:17:14 <dons> i think we can use the php guys for that
23:17:25 <dons> jcreigh: hehe. yes, clearly buggy!
23:17:31 <dons> the aliens should have used a type system
23:17:47 <jcreigh> I thought they were just clever robots.
23:17:52 * jcreigh didn't see the last two movies
23:17:55 * dons forgets how it ends.
23:18:03 <Adamant> dons, you're thinking Independence Day
23:18:06 <dons> me neither. just the first one.
23:18:22 <dons> ah right, Adamant, they had string injection vulnerabilities, iirc?
23:18:24 <Adamant> those aliens could have used a type system
23:18:36 <glguy> in ID4, they used that dude's mac to load a virus into the alien computer
23:18:38 <dons> yeah, they should have read tmoertel's post on handling that.
23:18:40 <bitwiseshiftleft> dons: but what good is a type system if you unsafeperformio?
23:18:41 <dolio> And not used Windows 95.
23:18:47 <glguy> if you watch TV you know that Macs can talk to any device
23:18:55 <glguy> so this is all quite believable
23:18:57 <dons> macs are super l33t like that, glguy
23:19:06 <dons> they use bsd after all.
23:19:11 <glguy> hell, my mac even understand women
23:19:16 <dons> wow.
23:19:23 * dolio needs a 3D Unix system like in Jurassic Park.
23:19:28 <bitwiseshiftleft> glguy: wait, that might be going a bit too far
23:19:28 <glguy> that actually existed
23:19:32 <dons> i thinkthat's freely available, dolio
23:19:34 <glguy> dolio: I was surprised to learn
23:19:35 <bitwiseshiftleft> it's like, can God create a rock he can't lift, kind of hing
23:19:50 <dolio> glguy: I've heard that before, but I can't remember what it is.
23:20:09 <glguy> dolio: when I saw that movie, I was like "oh yeah right, this is such bullshit"
23:20:19 <glguy> and then I found out tha tthe program was real and existed for that os
23:20:44 <dons> it would be fun to analyse movie hacker exploits, and point out how a type system could have prevented them :)
23:21:02 <glguy> dons: can type systems prevent the ultimate hack
23:21:05 <glguy> typing "override"
23:21:09 <dons> heh
23:21:15 <glguy> or writing out a list of passwords on paper
23:21:17 <glguy> and brute forcing?
23:21:29 <glguy> pop the firewall and drop in a backdoor!
23:21:56 <glguy> on 24, they said that CTU had a proprietary algorithm for cracking Blowfish
23:22:01 <glguy> (it was to guess the password)
23:22:12 <dolio> I need more sockets!
23:22:50 <jcreigh> glguy: did they really mention blowfish by name?
23:22:54 <glguy> jcreigh: yeah
23:22:55 <Adamant> dons, does a type system cover problems related to lack of bounds checking?
23:22:56 <dons> heh
23:23:02 <dons> Adamant: it can, yes.
23:23:09 <dons> though that's surprisingly hard
23:23:10 <Adamant> or is that not considered part of the type system
23:23:24 <dons> no no, bounds checking is a classic type system problem
23:23:54 <dons> pretty much every dependently typed language begins by proving indexing is safe
23:23:57 <dolio> Evidently the 3D gui is "fsn" from IRIX.
23:24:10 <glguy> Adamant: sure it does: arrayindex :: array a -> Int -> Maybe a
23:24:30 <glguy> I know that isn't exactly what you meant
23:24:41 <glguy> but that's type systems eliminating bounds errors
23:24:45 <glguy> at a certain level
23:24:53 <Adamant> dons, security bugs are mostly a subset of software bugs. what bugs do current type systems not fix?
23:25:40 <Adamant> (programming logic bugs can't be fixed by a type system, I think)
23:25:48 <Adamant> *programmer
23:26:01 <dons> the stronger the type system, the more logic bugs get caught in the type system
23:26:16 <dons> something like epigram starts by establishing a sorting algorithm actually sorts its data
23:26:30 <dons> which seemingly we can establish in ghc + type families, btw
23:26:46 <wli> Type families?
23:26:56 <dons> the generalised associated types stuff
23:27:48 <bitwiseshiftleft> ghc has type families?
23:27:56 <Cale> bitwiseshiftleft: It does in HEAD.
23:28:02 <bitwiseshiftleft> oooh...
23:28:14 <dolio> Oh, did they commit it?
23:28:30 <Cale> Oh, I'm uncertain actually.
23:28:45 <dolio> Oh, wait, it's AT synonyms that they just got done recently.
23:28:48 <bitwiseshiftleft> does that mean they'll be in 6.8?
23:28:53 <sorear> yeah.
23:28:53 <dolio> Families have worked for a little while now, I guess.
23:28:54 <Cale> yeah, I think so
23:28:54 <dons> type families are in ghc, but type synonyms are in a non-committed patch
23:29:33 <dons> yeah, what fun is a new ghc, without a new type system?
23:29:38 <dons> it just wouldn't be worth releasing
23:30:01 <bitwiseshiftleft> haha, too true
23:30:06 <sorear> what about the great rts rewrite of 4.00?
23:30:10 <dons> its traditional to release a significant extension to the type system, and significant improvement in concurrency support, with each major release
23:30:23 <motion`ib> dons how old is haskell?
23:30:30 <dons> 17 years old
23:30:41 <dons> and 4 months
23:31:01 <dons> people just wrote papers for the first 10 years though
23:31:24 <Cale> Yeah, as a practical language, it's very young.
23:31:29 <Cale> Maybe only a few years.
23:31:46 <Cale> Depending on what you call "practical"
23:31:48 <scook0> when was the monadic revolution?
23:32:09 <dons> first you had to get the monads, then you get the power, then you get the women.
23:32:17 <Cale> haha
23:32:18 <dons> we're somewhere between power and women now
23:32:35 <Cale> @remember dons First you had to get the monads, then you get the power, then you get the women.
23:32:35 <lambdabot> Done.
23:32:52 <jcreigh> I suspect this scale is not linear, and we may have some distance to go. :)
23:32:59 <dons> heh
23:33:12 <bitwiseshiftleft> yeah, but they're on the way... i know at least ... a woman who's programmed in haskell
23:33:17 <dons> he, how many people got married this year! maybe we''re closer than we thought
23:33:53 <Cale> hmm, 1.1 still had the old IO system
23:34:19 <Cale> so did 1.2
23:34:38 <Cale> 1.3 has monadic I/O
23:34:43 <Cale> So that's 1996.
23:34:44 <dons> i think it really began with the FFI revolution
23:34:52 <dons> which gave us the tools to do anything
23:34:53 <wli> I started with either 1.3 or 1.4
23:34:56 <dons> not just ST
23:35:04 <wli> There were still monad comprehensions when I started.
23:35:22 <Cale> I'd really like to bring back lots of things from the 1.4 report.
23:35:38 <Cale> The 1.4 report was so much more beautiful than the '98 report.
23:36:54 <wli> I liked n+k patterns and was literally hoping for an extension to m*n+k patterns.
23:37:08 <Cale> m*n+k patterns were in something
23:37:12 <Cale> Maybe gofer.
23:37:43 <wli> I really missed the boat. ;)
23:38:08 <Cale> So did I, but I read lots of really old mailing list posts.
23:38:23 <mauke> k++l patterns is where it's at
23:38:44 <Cale> Including all the '98 committee mailing list posts, at some point.
23:38:46 <sorear> gallina and epigram get views for free!
23:39:03 <bitwiseshiftleft> heck, why not make a pattern for any injection?
23:39:24 <sorear> gallina and epigram can do that! :)
23:39:30 <Cale> Some injections are tricky to invert :)
23:39:42 <sorear> and still express primitive recursion.
23:39:46 <bitwiseshiftleft> hehe.  well, maybe not quite any injection.
23:39:48 <Cale> RSA patterns!
23:40:29 <bitwiseshiftleft> yeah, for instance
23:40:39 <sorear>       Theorem rev_ind :
23:40:44 <sorear>          forall P:list A -> Prop,
23:40:48 <sorear>            P nil ->
23:40:52 <sorear>            (forall (x:A) (l:list A), P l -> P (l ++ x :: nil)) -> forall l:list A, P l.
23:41:20 <sorear> that definition lets you perform induction on any list using n++[x] patterns
23:43:57 <wli> k ++ l patterns sound good to me, too. Frankly I'd love for patterns to be much closer to logic language sorts of affairs with lots of implicit =='s etc.
23:44:33 <Cale> Man, I wish I could record the animal sounds going on outside my window right now. Must be squirrels fighting or something ridiculous.
23:46:03 <araujo> haha
23:46:09 <araujo> Cale, get a camera!
23:48:31 <bitwiseshiftleft> since when do cameras record sound?
23:49:28 <dibblego> since they had microphones in them
23:49:31 <bitwiseshiftleft> oh
23:49:54 <araujo> haha
23:49:58 <araujo> :-P
23:51:02 <sorear> dibblego: Point a laser pointer at the window, then point the camera at the reflected dot on the wall.
23:51:25 <Cale> sorear: hahaha
23:51:32 <bitwiseshiftleft> ... works perfectly if your camera can take pictures at 40kfps
23:51:33 <sorear> Really.
23:51:41 <sorear> @go Cavendish experiment
23:51:44 <lambdabot> http://en.wikipedia.org/wiki/Cavendish_experiment
23:51:44 <lambdabot> Title: Cavendish experiment - Wikipedia, the free encyclopedia
23:52:12 <Cale> Probably works better if there's a small mirror involved
23:53:07 <dibblego> I can't even get up at the moment; I just got back from the hospital
23:53:13 <dibblego> so no pointing anything for me
23:53:25 <Cale> dibblego: operation?
23:53:34 <dibblego> I tore a ligament this morning in my ankle
23:53:34 <sorear> Anyone who can measure the strength of gravity in the 1700 gets my vote for experimenter of the millenium. :)
23:53:42 <Cale> dibblego: ouch
23:53:49 <dibblego> Cale, fifth time *sigh*
23:53:57 <dons> interesting post on dealing iwith a growing community, on LtU, http://lambda-the-ultimate.org/node/2368
23:53:59 <lambdabot> Title: LtU turns 7: The year of spam | Lambda the Ultimate
23:54:38 * wli wonders why on earth this Bernoulli number memo table is taking up 1.8GB.
23:55:16 <dolio> Wow, 1.4 had 'Functor f => map ...' and 'MoandPlus m => (++) ...'
23:56:06 <dons> so enlightened
23:56:07 <wli> Idempotent semirings are involved in some sorts of graph algorithms IIRC.
23:56:22 <wli> Cormen, Leiserson, and Rivest has a section on it.
23:57:15 <wli> (Additional motivation for breaking up the algebraic structures in the Prelude/etc.).
23:57:26 <Cale> dolio: yeah, there were lots of really terrible decisions made in the H98 process
23:57:41 <sorear> wli: How high does it go, and is it correctly lazy?
23:57:51 <Cale> (with apologies to those who participated :)
23:58:10 <opqdonut> absolutely
23:58:16 <wli> sorear: Well, I'm not sure what you mean. It's fully dynamic. As far as correctly lazy goes, I have no idea.
23:58:41 <dolio> Cale: I do wonder whether I'd put (++) in MonadPlus or Monoid.
23:58:46 <sorear> wli: What's the largest b-num you compute?
23:58:54 <wli> sorear: It depends on user input.
23:59:13 <wli> sorear: http://holomorpy.com/~wli/haskell/bernoulli/
23:59:21 <wli> sorear: http://holomorphy.com/~wli/haskell/bernoulli/
23:59:22 <lambdabot> Title: Index of /~wli/haskell/bernoulli
23:59:24 <sorear> and what does the heap profiler say?
