00:05:55 <_roconnor> @seen dons
00:05:55 <lambdabot> dons is in #haskell-icfp07, #xmonad, #haskell-soc and #haskell. I last heard dons speak 1h 10m 52s ago.
00:06:19 <roconnor> dons: do you have a machine for benchmarking dna2rna?
00:10:01 * wli tries to remember how to commute monads.
00:13:53 <wli> The closest thing I see is sequence
00:14:00 <dons> roconnor: maybe you can use a machine you have access to, or perhaps code.haskell.org ?
00:14:31 <Saizan> wli: you want to go from m (m' a) to m' (m a) ?
00:14:41 <wli> Saizan: Yeah.
00:15:46 <Saizan> wli: mmh i'll be surprised if that's possible in general
00:16:24 <wli> Saizan: I don't think it is possible in general.
00:16:36 <Saizan> ah ok
00:16:54 <JohGro> @src maximumBy
00:16:55 <lambdabot> Source not found. Do you think like you type?
00:17:05 <wli> Saizan: Some sort of regularity condition on either the inner or outer monad is required.
00:17:32 <Saizan> wli: you've to be albe to run m, no?
00:17:35 <roconnor> dons: hmmm
00:18:51 <wli> Saizan: I think it's more of a way to cope with when it produces no result than requiring a result exist.
00:21:56 <wli> Saizan: I think MonadPlus and Monoid or some such.
00:22:42 <glguy> JohGro: do you need to see the source for that?
00:22:47 <glguy> JohGro: do you have a question about it?
00:23:04 <JohGro> I have a question...
00:25:45 <glguy> :t let maximumBy comp = foldl1 (\m x -> case comp m x of LT -> x; _ -> m) in maximumBy
00:25:47 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
00:26:28 <JohGro> "maximumBy (comparing  nInitialPrimes)  coeffs" computes a maximum in 708 seconds, whereas
00:26:29 <JohGro> "*Main> foldl (\(max, ps) n -> if nInitialPrimes n > ps then (n, nInitialPrimes n) else (max, ps)) ((0,0),0) coeffs" seems to me to compute the same maximum (same result) in 8.09 seconds. (Before runnign these I did a "map nInitialPrimes coeffs" so that memoization should not influence the result.
00:27:09 <glguy> JohGro: I don't think that memoization exists like you are worried about
00:27:44 <glguy> JohGro: are you asking why it is slower?
00:27:54 <JohGro> Yes
00:28:01 <glguy> the first one has to compuate nIntialPrimes many more times, for one
00:28:12 <JohGro> Why?
00:28:24 <glguy> because each time it compares two elements
00:28:31 <glguy> it has to recompute the number of initial primes
00:28:47 <JohGro> But I do not think it should have to compare all pairs of element.
00:28:56 <JohGro> Yes, I could understand a factor of 2, or so
00:29:24 <opqdonut> ?src maximumBy
00:29:24 <lambdabot> Source not found. The more you drive -- the dumber you get.
00:29:31 <JohGro> I would be interested to see the source to see how it works, and how many times it recomputes
00:30:24 <glguy> maximumBy		:: (a -> a -> Ordering) -> [a] -> a
00:30:24 <glguy> maximumBy _ []		=  error "List.maximumBy: empty list"
00:30:24 <glguy> maximumBy cmp xs	=  foldl1 max xs
00:30:24 <glguy> 			where
00:30:24 <glguy> 			   max x y = case cmp x y of
00:30:26 <glguy> 					GT -> x
00:30:28 <glguy> 					_  -> y
00:31:19 <glguy> how big is coefs?
00:31:49 <dolio> wli: Traversable has a generalized sequence.
00:31:53 <JohGro> around 40000 elements of [(Integer, Integer)]
00:32:02 <glguy> even if your pasted code you recalculate the number of primes
00:32:13 <glguy> so ... weird :)
00:32:26 <wli> doli: I see it.
00:32:51 <dolio> But, of course, that's only applicable if your outer monad is traversable.
00:33:33 <wli> No problem.
00:33:40 <JohGro> Yes, thanks for the source. I will try this some more.
01:24:45 <Nopik> hi
01:25:10 <Nopik> its whole new day to waste on trials to understand monads, doomed to fail ;p
01:25:34 <dons> hah
01:25:43 <dons> maybe today is the day of enlightenment!
01:25:47 <dons> ?users
01:25:47 <lambdabot> Maximum users seen in #haskell: 363, currently: 329 (90.6%), active: 4 (1.2%)
01:26:23 <Nopik> i wish
01:26:25 <Saizan> we should have a poll on how many tutorials have you read before grokking monads
01:26:38 * Nopik has already read about 4-5
01:26:49 <Nopik> after some of them you lost the count
01:27:03 <Saizan> heh
01:27:22 <Saizan> was sigfpe's one of them?
01:27:28 <pejo> Take a vacation after that. Takes a while to get used to them. :-)
01:27:31 <Nopik> hm, i dont think so
01:27:42 <wli> YAHT seems to have helped here but only a little.
01:27:43 <nopcode> why are monads so important?
01:27:43 <Nopik> yeah ;)
01:27:55 <Saizan> ?google you could have invented monads
01:27:57 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
01:27:57 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
01:28:04 <Nopik> nopcode: it seems that everything in haskell is somehow related to a monad.. or two
01:28:10 <nopcode> Nopik: uh
01:28:14 <Nopik> ah, this one.. i read it
01:28:16 <Nopik> quite nice
01:28:16 <nopcode> i thought they were a fix to describe I/O
01:28:23 <Nopik> i almost believed that i understand monads
01:28:42 <Nopik> nopcode: not only, they are used to encapsulate much more than io
01:29:02 <pejo> nopcode, well, whether we like it or not almost all programs need some kind of interaction with the real world.
01:29:02 <nopcode> Nopik: what for?
01:29:04 <Nopik> nopcode: just read the tutorial from sigfpe mentioned above
01:29:09 <jargonjustin> nopcode: Monads provide a way to abstract containers (lists, Maybe, the Real World :-) and computations from the rest of your code
01:29:23 <Saizan> monads are a great interface for writing libraries as smal embedded domain specific languages
01:29:24 <nopcode> pejo: yeah but if you're concerned about I/O that much maybe you should be using another language
01:29:49 <psykotic> Nopik, have you read any of wadler's papers?
01:30:16 <Nopik> psykotic: i dont recall any ;)
01:30:18 <Nopik> psykotic: any url?
01:30:35 <Saizan> well maybe at this point Nopik needs only some practice :)
01:30:46 <psykotic> yeah
01:31:18 <Nopik> Saizan: yes, i need.. but there are still few concepts which are magic to me - right now i am puzzled by concept of monad transformers
01:31:28 <dons> glguy: you might want to comment on SimonM's utf8 thread on -cafe2 ?
01:31:32 <pejo> nopcode, hm? I think people in here has proved that Haskell can be used for real world programs quite successfully.
01:31:42 <Nopik> Saizan: today i would like to fully understand reader monad, and its runReader, runReaderT and difference between them
01:31:43 <dons> psykotic: are the lazy bottoms going to link their src repo to the wiki table?
01:31:54 <dons> or write up their experiences :)
01:31:56 <Nopik> Saizan: as an introduction to understand xmonad ;)
01:31:57 <psykotic> dons: we have some stuff on the repo we don't want to release, but i think that'll happen eventually
01:31:58 <roconnor> This weekend I was thing that Monads allow you to use different models of computation without them interfering with each other.
01:32:04 <roconnor> thinking
01:32:10 <dons> oh, secret code, psykotic ?
01:32:25 <dons> or ugly code :)
01:32:34 <psykotic> dons: actually nothing we _used_ for the contest. but some stuff we had in there, with the anticipation of using it :)
01:32:44 <psykotic> but it has to be extirpated from the repo before we can release it.
01:33:01 <psykotic> i think the code is okay-ish :)
01:33:03 <dons> fair enough. pre-implemented A* search strategies? ;)
01:33:10 <psykotic> no, vincenz's compiler framework
01:33:13 <roconnor> presumably we can get rid of sections 2 and 3 on the ICFP contest wiki page.
01:33:19 <dons> nice idea.
01:33:26 <dons> i usually just set up QuickCheck before hand
01:33:31 <dons> and the build system
01:33:40 <dons> roconnor: yes, dive in an summarise the results
01:34:02 <dons> roconnor: if you need a benchmarking machine, we can use code.haskell.org (you can get an account). i just don't have time to do the benchmarking
01:34:18 <psykotic> btw, regarding monads, the most useful thing i ever read was one of moggi's original papers.
01:34:36 <psykotic> i think i'm the exception, but when you make an explicit distinction between object and meta language, many things are clearer.
01:35:22 <dons> roconnor: interesting to see the C++ and ocaml guys complaining about speed :)
01:35:25 <dons> http://programming.reddit.com/info/28xdp/comments
01:35:26 <lambdabot> Title: cashto does the ICFP contest (a post-mortem) (reddit.com)
01:35:33 <dons> and http://programming.reddit.com/info/28xgc/comments
01:35:34 <lambdabot> Title: Why Oâ€™Caml is not my favorite programming language (reddit.com)
01:35:47 <dons> fatal flaws in ocaml arrays? sounds very odd
01:35:49 <psykotic> dons: after the contest i wrote a c++ dna->rna compiler.
01:35:57 <dons> how'd it go, what structures?
01:35:59 <psykotic> it's extremely fast. but it has little to do with c++ as such.
01:36:02 <psykotic> i used ext/rope :)
01:36:08 <dons> yeah, sounds like a good idea
01:36:10 <psykotic> it's in the SGI implementation of the STL
01:36:29 <dons> i'd imgine the issue in the contest would be people trying to do their own memcpying of data, rather than picking a proper data structure
01:36:43 <psykotic> right, it's about the data structure, not the language.
01:36:53 <mr_tenor> hey, is there a nice way to drop n elements from either end of a list? :(
01:36:55 <psykotic> for example, i think you could easily have gotten much of the effect of lazy bytestrings in other languages.
01:36:58 <dons> yep. lucky we had Data.Sequence and Data.ByteString.Lazy ready to go this time
01:37:04 <dons> definitely
01:37:05 <psykotic> basically keep a list of strings that are lazily concatenated on demand
01:37:09 <psykotic> something like that
01:37:25 <dons> mr_tenor: let f = drop n . reverse in f  . f
01:37:40 <dons> psykotic: yeah, i think the main issue is having the libraries for such a structure ready to go
01:37:46 <psykotic> then you can do constant time appends and prepends and log n concats, with some amortization
01:37:48 <dons> you don't want to have to implement it during the contest
01:37:58 <dons> yeah
01:38:06 <psykotic> sure
01:38:07 <dons> maybe you should have a go at a bytestring rope :)
01:38:11 <mr_tenor> dons: yeah, that's what i'm doing now, but i don't think the compiler's optimising it out. could do it in 1 pass in C :/
01:38:21 <psykotic> although i think given how much people even using haskell spent on dna->rna, implementing this thing wouldn't be a big worry
01:38:26 <dons> mr_tenor: you're using a different data structure though, mr_tenor ?
01:38:30 <dons> or are you using bytestrings?
01:38:39 <mr_tenor> just a regular list
01:38:55 <dons> mr_tenor: if its lists, you'll need to compute the length, then do one more traversal
01:39:02 <dons> if its bytestring, you can do it in O(1)
01:39:35 <dons> if your program depends on efficient access to the tail, consider bytestrings, or Data.Sequence, rather than lists
01:40:07 <mr_tenor> if it's a singly linked list, you could keep a pointer to the nth element behind your position as you traverse it so when you reach the end you know where "middle bit" ends
01:41:08 <dons> sure. hang onto the start of the list in your accumulator
01:41:40 <mr_tenor> hmm
01:42:05 <Saizan> > let dropEnd n xs = snd $ foldr (\x (n,xs) -> if n > 0 then (n-1,xs) else (0,x:xs)) (n,[]) xs in dropEnd 5 [1..10]
01:42:07 <lambdabot>  [1,2,3,4,5]
01:42:26 <dons> very nice Saizan
01:42:37 <roconnor> dons: oh good, I imagined this would be just as hard in C/C++
01:42:56 <roconnor> It all comes down to library support I think
01:42:59 <dons> yeah
01:43:10 <dons> so *good thing* we got Data.Sequence and Data.ByteString in ghc 6.6 :)
01:43:17 <mr_tenor> yeah, that's pretty much what a library would be doing i reckon
01:43:22 <mr_tenor> thanks :)
01:43:40 <roconnor> dons: I don't know how this C++ ropes things works, but maybe ByteString.Lazy can be made to work like it.
01:44:11 <dons> bytestring chunks + finger trees sounds good to me, too
01:44:55 <roconnor> yeah, I don't know much about finger trees either.
01:45:18 <roconnor> But some process to merge chunks was need for this contest
01:45:38 <dons> yes, we plan to add a rebalancing function now
01:46:00 <dons> and better findsubstring, and strict binary Builder
01:46:38 <mux> does someone know of an online System-F checker/interpreter?
01:46:55 <dons> Twelf? :)
01:47:09 <dons> (there's System F embeddings in twelf)
01:47:17 <mux> ?where twelf
01:47:17 <lambdabot> http://www.cs.cmu.edu/~twelf/
01:47:36 <dons> for research?
01:49:08 <mux> dons: to see if I could write the filter function right
01:49:15 <matthew-_> ahhh, the first brew from a new bag of coffee. Always a tender moment. Morning #haskell.
01:49:16 <mux> on list, using syntax & conventions from TAPL
01:49:42 <dons> morning matthew-_ :)
01:49:57 <mux> dons: but maybe you feel like checking it for me? ;-)
01:50:40 <pejo> mux, if it's an exercise in TAPL there's an answer in the back iirc.
01:50:55 <mux> it's not an exercise in TAPL, I know that
01:51:08 <mux> the exercise I did was asking for reverse, and that's done
01:51:13 <mux> I only wrote filter for personal pleasure :-)
01:51:13 <wli> Which is TAPL again?
01:51:17 <hpaste>  mux pasted "filter in System-F" at http://hpaste.org/1859
01:51:40 <pejo> wli, types and programming languages, by Pierce
01:55:38 <Saizan> > let dropEndThatDontOverflow n xs = zipWith const (drop n xs) xs in dropEndThatDontOverflow 5 [1..10]
01:55:39 <lambdabot>  [6,7,8,9,10]
01:55:50 <Saizan> ops
01:57:13 <Saizan> > let dropEndThatDontOverflow n xs = zipWith const xs (drop n xs) in dropEndThatDontOverflow 5 [1..10]
01:57:14 <lambdabot>  [1,2,3,4,5]
02:02:55 <joelr1> morning
02:03:03 <Nopik> is State monad in prelude or some external package?
02:03:37 <mux> it's in the mtl package
02:03:42 <joelr1> what do you guys think of "pet brain" as a name for a "chatter bot"? a program you can talk to over IM or on facebook that can keep up some form of a dialog, remember facts and do things for you like reminders, searches, etc.
02:03:45 <mux> Control.Monad.State and the MonadState type-class
02:03:52 <Nopik> yeah, just found it, thanks
02:05:59 <kalven> joelr1: sounds great, go for it.
02:06:12 <joelr1> :-)
02:07:00 <mgsloan> haha, in C++ you can have infix words like haskell's ops like `elem`
02:07:15 <mgsloan> except not specially delimited
02:08:08 <|Steve|> Only the predefined binary operators.
02:12:10 <roconnor> dons: need map : (a -> Word8) -> [a] -> ByteStirng
02:12:30 <psykotic> roconnor, pack . map
02:12:43 <psykotic> you mean an efficient version of that?
02:12:57 <roconnor> psykotic: hmm, maybe that deforests..
02:13:00 <genneth> hehe: http://schani.wordpress.com/2007/07/23/why-ocaml-is-not-my-favorite-programming-language/
02:13:03 <lambdabot> Title: Why O&#8217;Caml is not my favorite programming language « Juggling, Photography ..., http://tinyurl.com/2uehbg
02:13:21 <mgsloan> |Steve|: no. lookit this: http://www.codeproject.com/cpp/log_xor.asp
02:13:23 <lambdabot> Title: Logical XOR operator - The Code Project - C++ / MFC
02:13:43 <psykotic> dons, btw i noticed Data.Traversable doesn't have mapM_.
02:13:54 <psykotic> dons: is that an oversight?
02:14:41 <|Steve|> mgsloan: Oh that's horrible.
02:15:16 <mgsloan> |Steve|: Indeed :)
02:15:40 <|Steve|> And likely not safe.
02:15:46 <mgsloan> probably not
02:16:02 <matthew-_> oh yeah, of two professors, one reader and about 6 PhD students all at Computing at Imperial College, only one knew that xor on booleans is (/=)
02:16:15 <matthew-_> yay for academia
02:16:43 <mgsloan> I bet stuff like this drives the people who try to grammericize C++ totally nuts
02:16:54 <mgsloan> matthew-_: is it now! cool
02:17:05 <mux> bah, I need to install ocaml to compile the fullomega program for TAPL it seems
02:17:09 <mgsloan> err hmm
02:17:12 <mux> I couldn't find any online System-F interpreter
02:19:20 <mgsloan> matthew-_: ah, I thought you were referring to C++
02:21:28 <Nopik> hm, it seems that value of type m a (where m is a monad) is always a simpler type like [a] or \x -> (a, x)... so everywhere where monad is used e.g. IO Int, it means, that there is underlying 'simple' Haskell object hidden?
02:21:38 <Nopik> is that right?
02:21:49 <matthew-_> mgsloan: no sorry, haskell
02:22:14 <mgsloan> yep, I realized that after about 30 seconds of wondering how that could ever work :P
02:22:50 <mgsloan> (in C++ that's the assign+division compound)
02:23:15 <mgsloan> Nopik - I'm afraid not
02:23:34 <matthew-_> Nopik: that's seems plausible. I tend to think of Monads as hiding all sorts of underlying plumbing. There may well be exceptions though, for example IO decomposes to RealWorld and a few other things which are deeply magical
02:23:53 <matthew-_> mgsloan: well, I suppose in C++, xor on booleans would still be != wouldn't it?
02:24:08 <mgsloan> well, IO is a rather special case.  GHC's implementation uses RealWorld, it's true
02:24:09 <|Steve|> Yes.
02:24:37 <|Steve|> Er, that was for matthew-_.
02:24:39 <mgsloan> actually not
02:24:52 <mgsloan> in C++ booleans are one byte
02:24:59 <|Steve|> That's not true.
02:25:05 <mgsloan> 0 represents false, anything else represents true
02:25:13 <|Steve|> The standard just says that it has to be large enough to represent 2 values.
02:25:20 <|Steve|> On my computer, bool is 4 bytes.
02:25:27 <mgsloan> or int, then
02:25:42 <wli> Addressibility when stored in memory.
02:26:03 <wli> In packed structures it will be taken down to 1 byte.
02:26:04 <mgsloan> impl dependant.  The point is that there are cases where true != true == true
02:26:48 <Nopik> mattam: how come? it seems, that monads are just using 'already existing' haskell syntax, so in order to create monad you can use existing syntax
02:26:52 <matthew-_> mgsloan: good. well you've just ensured I don't touch C++ for another 24 years. This is a good thing!
02:26:56 <mgsloan> :)
02:27:08 <mgsloan> yeah, I would of course rather use haskell at
02:27:10 <mgsloan> atm
02:27:20 <|Steve|> mgsloan: What are you talking about?
02:27:56 <mgsloan> oh, I was just justifying my current use of C++ rather than haskell
02:28:03 <matthew-_> Nopik: indeed. Ok, I'm rapidly reading the end of my knowledge here. I think you're right, but I think that there are cases (eg IO) where GHC and the other compilers/interpreters really do do stuff under the bonnet that can't be expressed in "pure" haskell.
02:28:14 <|Steve|> There are not cases where comparing two bools that are true for equality return false.
02:28:51 <mgsloan> man, lambdabot really needs to have a c++ interpreter ;)
02:28:53 <matthew-_> agh, there's quite a big spider on my monitor
02:29:16 <psykotic> genneth, i just read that what he refers to--the ocaml array size thing--is a 4 meg limit. holy cow.
02:29:43 <genneth> i'm starting to think that Haskell is overtaking OCaml as the practical choice...
02:29:45 <psykotic> how can anyone hold up ocaml as the exemplar of practical functional language implementations with a freaking 4 meg array size limit.
02:29:47 <psykotic> ytes.
02:30:23 <psykotic> and i like the implementors' advice--upgrade to a 64 bit platform. to have 4 meg arrays. right.
02:30:28 <|Steve|> Wow, seriously?
02:30:31 <mgsloan> Nopik - yeah, you're correct that there is a data type behind every monad, I think.  IO is an exception sometimes.
02:30:34 <psykotic> yes, seriously.
02:30:44 <|Steve|> I've only used ocaml once and didn't run into that issue.
02:30:58 <mgsloan> probably meant gigs
02:31:05 <matthew-_> psykotic: wow. Didn't know that one. That would be a problem for me - in a game I'm writing atm, I move 8 MB arrays of floats to the graphics card all the time. It's quite pleasant in haskell...
02:31:39 <psykotic> mgsloan, no, megs.
02:31:44 <mgsloan> 0_o
02:31:57 <psykotic> mgsloan, it's because the size of an array is encoded as a "pointer tag" directly in the value word.
02:32:27 <mgsloan> hah
02:32:28 <psykotic> basically to save a dereference for bounds checking.
02:32:37 <psykotic> (and possible cache miss)
02:32:54 <wli> It wouldn't hurt so badly on 64-bit.
02:32:55 <psykotic> http://lists.idyll.org/pipermail/caml-news-weekly/2006-May/000069.html
02:32:57 <lambdabot> Title: [cwn] Attn: Development Editor, Latest Caml Weekly News, http://tinyurl.com/2kh6yc
02:33:02 <psykotic> wli: right, but that is ridiculous. come on.
02:33:13 <psykotic> wli: i can see upgrading to 64 bit to allow you to have 4 _gig_ arrays, but 4 meg? :)
02:33:29 <psykotic> in that post, search for "4 mb size limit"
02:33:45 <psykotic> they have a bigarray type but it isn't interoperable with arrays
02:33:56 <|Steve|> What? That doesn't make any sense.
02:33:57 <psykotic> so all the code written with the array type in mind won't work
02:34:16 <|Steve|> What is a pointer tag?
02:34:34 <phoniq> oh dear
02:34:41 <phoniq> 4 mb size limit isn't in the FAQ
02:34:42 <|Steve|> If they just used another word for the size of the array, then the array could be 4 GB.
02:35:37 <dons> so that's a case of premature optimisation, eh? :)
02:36:11 <mgsloan> more like immature optimization :P
02:36:17 <psykotic> |Steve|, that extra word couldn't be stored "with" the tag word without inflicting it on all other types. so, you'd need to dereference a pointer to get the size.
02:36:42 <pejo> Is the size of an array know statically?
02:36:43 <psykotic> |Steve|, the tag word(s) needs to be the same same size for everything, since it's a "universal pointer" for boxed values.
02:37:02 <matthew-_> pejo: not normally.
02:37:38 <|Steve|> psykotic: I'd be okay with needing to dereference a pointer if it meant I didn't have a 4 MB array limit.
02:37:45 <mattam> it probably made sense in earlier revisions
02:37:46 <mgsloan> it can be with dependent type magic
02:37:48 <psykotic> |Steve|, yes :)
02:38:00 <psykotic> mgsloan, dependent type magic is one of those magical wands :)
02:38:07 <psykotic> the compiler technology for using that effectively isn't there yet
02:38:23 <mgsloan> yeah :)
02:38:36 <psykotic> for example, i don't know of any compilers for dependently typed languages that can compete effectively with specialized range analysis.
02:38:39 <psykotic> (or even close)
02:38:57 <psykotic> maybe with detailed annotations it could be done
02:39:00 <matthew-_> mgsloan: meh, I really really like doing lists that know their own length.
02:39:23 <psykotic> matthew-_, btw do you know about Data.Sequence?
02:39:28 <mattam> There's not really any compiler for dep. languages AFAIK.
02:39:47 <psykotic> mattam, doesn't epigram compile down to something else? but it isn't an optimizing compiler.
02:39:50 <mgsloan> mattam: sure, there's a few. cayenne, epigram,  a few others
02:40:02 <mattam> These are not proper compilers.
02:40:03 <matthew-_> psykotic: I know of Data.Sequence.
02:40:22 <beelsebob> mattam: what about hume?
02:40:24 <matthew-_> mgsloan, psykotic: oh sure, you could use one of those. But it's pretty easy to do in Haskell too
02:40:39 <matthew-_> hume?
02:40:42 <psykotic> matthew-_, the viewl/viewr stuff in Data.Seq is very nice.
02:40:53 <psykotic> mattam, means that you can work with them a lot like lists.
02:41:00 <psykotic> err, matthew
02:41:01 <mgsloan> yeah, though haskell dep type emulation can get pretty ugly pretty fast
02:41:05 <beelsebob> mattam: the real time dependantly typed functional langugae being developed at st andrews
02:41:05 <matthew-_> psykotic: ok, I'll take a look.
02:41:28 <matthew-_> mgsloan: well, depends on your definition of ugly! I quite like type level computation.
02:41:39 <matthew-_> beelsebob: is that edwin's work?
02:41:45 <mattam> Anyway, edwin brady is the one who explored that the most but his results are not implemented yet.
02:41:48 <beelsebob> matthew-_: yep
02:42:06 <matthew-_> yep.
02:42:21 <mgsloan> matthew-_: yeah, type level computation is fun, but haskell wasn't made for it, imho
02:42:42 <psykotic> matthew-_, anyway, data.seqs have a constant time length operation and a lot of other efficient operations, AND you can treat them as lists efficiently in many cases, due to viewl/viewr.
02:43:00 <psykotic> dons, you around?
02:43:05 <dons> yeah
02:43:16 <psykotic> dons: i'm curious if you know any prior art for something... you know the finger tree paper?
02:43:17 <mattam> beelsebob: Do you have a link ?
02:43:22 <dons> psykotic: yeah
02:43:32 <psykotic> one of the really nice tricks is that they express a lot of things via caching the results of "crushing" a tree with a monoid.
02:43:33 <beelsebob> mattam: http://www-fp.cs.st-andrews.ac.uk/hume/index.shtml
02:43:37 <lambdabot> Title: The Hume Programming Language
02:43:50 <dons> psykotic: right, yes.
02:43:54 <psykotic> since a monoid's op is associative, you can cache the intermediate results at interior nodes, etc
02:44:19 <psykotic> so you get a very general framework for annotating (and maintaining annotations) trees with various results computed bottom-up by a monooid
02:44:26 <dons> hmm, yes.
02:44:30 <matthew-_> psykotic: thanks for the info, I'll take a look at that.
02:44:30 <psykotic> they don't list any prior work for that, so i'm curious if you know of anything in that vein?
02:45:18 <psykotic> of course the idea of annotating trees and maintaining invariants is a standard topic in introductory algorithms classes, but i haven't seen it expressed this way (which is IMO vastly superior in in both simplicity and rigor).
02:45:28 <matthew-_> mgsloan: sure, it wasn't built for it, but as a reviewer recently wrote: "Overall, I am impressed by how much juice the authors have squeezed out of Haskell's type system."
02:45:29 <dons> hmm. yes, i can't think of anything obvious
02:45:45 <psykotic> dons, k, just curious.
02:45:52 <dons> psykotic: i think it would be well worth asking on -cafe@, see what Ross and Oleg et al have to say
02:45:58 <psykotic> i will, thanks
02:46:44 <psykotic> dons, btw i wish the underlying finger tree implementation of Data.Sequence was exposed, with this Annotation stuff extensible, as it's described in the original paper. any idea why this isn't done?
02:46:57 <mattam> efficiency
02:47:04 <dons> isn't it exposed in the 'fingertree' package?
02:47:09 <dons> i think that's why that package exists, actually
02:47:19 <mgsloan> matthew-_: certainly, haskell's type system is among the most powerful (especially wielded by a skilled wizard such as oleg), but still, that you had to squeeze at all isn't good
02:47:20 <psykotic> oh
02:47:24 <psykotic> i didn't know that was a standard package
02:47:35 <psykotic> oh right, they even have the Monoid and Measured stuff in there. cheers.
02:47:35 <dons> oh, just one on hackage, after someone complained
02:48:20 <matthew-_> mgsloan: mmm. I guess I just find it fun to try and push it as hard as I can. It's always fun to see just where it can't cope. Whilst things like Epigram are certainly better at this stuff, they're no where near as mature.
02:48:30 <mgsloan> oh, yeah, certainly fun
02:48:52 <mgsloan> and I'd be a hypocrite to advocate Epigram :)
02:49:13 <mattam> psykotic: it seems to me that it is the most important contribution of their paper actually. For a wicked use of this information look at this: http://www.lri.fr/~sozeau/research/russell/fingertrees.en.html (link down but not for long)
02:49:29 <mux> Epigram completely annihilated the little sanity that was left in me
02:49:32 <psykotic> mattam, the measured/monoid stuff?
02:49:36 <doserj> hm. just looking at the interface for Data.Sequence
02:49:38 <mattam> yes
02:49:42 <psykotic> mattam, if so, i agree, that's really what stuck with me.
02:49:53 <psykotic> and i was surprised they didn't discuss the ancestry of the idea.
02:49:56 <doserj> the operations seem to be symmetric regarding left/right
02:49:58 <mgsloan> mux: hah! good thing all I did was skim through the paper
02:50:01 <mattam> I use it to _prove_ instantiations are correct
02:50:16 <doserj> any reason why reverse than has to be O(n)?
02:50:39 <mgsloan> I'd imagine its like an array
02:50:46 <mgsloan> so reverse would be O(n)
02:50:58 <psykotic> doserj, because it has to prove a new version of the data. the _view_ corresponding to reverse can be produced efficiently.
02:51:09 <psykotic> and that's what viewr does
02:51:13 <psykotic> err, produce, not prove
02:51:21 <wli> doserj: Probably to save direction flag checks in the more common functions.
02:51:43 <psykotic> yeah it's not worth it to have that part of the basic data structure.
02:51:47 <mattam> psykotic: beware though, I do this in a dependently typed programming language.
02:51:49 <psykotic> then you could start going crazy.
02:52:04 <psykotic> like exposing a view of the concatenation of two things. which is actually useful in some cases, but i wouldn't masquerade it as the data structure itself.
02:52:21 <doserj> but I am right that there could be a constant time reverse, with the downside that every other function would have an additional constant overhead?
02:52:34 <mattam> Yes.
02:52:36 <mgsloan> yeah, and _code_ overhead
02:52:40 <mgsloan> and mem overhead
02:52:48 <psykotic> the problem is that the overhead would be exposed to all users
02:53:03 <psykotic> so even someone who doesn't care about reverse would have that cost imposed
02:53:11 <mgsloan> you could probably do something clever typesystem wise
02:53:23 <psykotic> mgsloan, there's that dependent type wand again :)
02:53:42 <doserj> ok, thx
02:53:45 <mgsloan> yeah, I whip it out every chance i get
02:53:51 <mux> yay, fullomega accepted my System-F code once I replaced \'s with lambda :-)
02:54:05 <psykotic> mgsloan, you could do something like a phantom type for "Forward" and "Backward"
02:55:14 <mux> filter : All X. (X->Bool) -> List X -> List X
02:55:14 <mux> map : All X. All Y. (X->Y) -> List X -> List Y
02:55:23 <mgsloan> something like that might work, yeah
02:55:35 <mattam> psykotic: but then you'd have to call different functions depending on the type... you can't get around having a constant in the datatype
02:55:42 <psykotic> right, i agree
02:55:57 <Cale> Q: How many Prolog programmers does it take to change a lightbulb?  A: no.
02:56:05 <psykotic> basically in the cases when the type parameter is parametric/variable you would have to dispatch through a type class dictionary
02:56:14 <psykotic> but in the cases where it is inferrable it could be eliminated at compile time.
02:56:28 <matthew-_> mattam: well, the might be some cases where the compiler can prove the type param and thus not have to do a dynamic dispatch
02:56:39 <matthew-_> gah, what psykotic said
02:56:56 <mgsloan> Cale - yeah, first time I saw that I giggled maniacally
02:57:06 <mattam> Yes, some but not in general.
02:57:10 * matthew-_ where's that stereo quote when you need it?!
02:57:24 <psykotic> mattam: in fact, though , i can't imagine many cases where it could be eliminated.
02:57:33 <mgsloan> ?quote #haskell in stereo
02:57:34 <lambdabot> No quotes for this person. It can only be attributed to human error.
02:57:42 <mgsloan> ah, no search then eh
02:57:43 <|Steve|> @quote stereo
02:57:43 <lambdabot> No quotes match. It can only be attributed to human error.
02:57:43 <psykotic> mattam: it would have to be a case where you first construct a new tree, say with Forward direction. and then reverse it in the same function, and do something with it.
02:57:48 <matthew-_> mgsloan: Î»b got rebooted!
02:57:55 <mgsloan> argh!
02:58:10 <dons> oh, hmm
02:58:16 <dons> there was a blackout. hmm.
02:58:18 <dons> ?quote
02:58:19 <lambdabot> metaperl says: I never thought anyone could be on IRC as much as you and look that good
02:58:23 <dons> ?quote Cale
02:58:23 <lambdabot> Cale says: [dmead] yo yo yo yo what it is mother fuckers [Cale] dmead: this isn't #scheme
02:58:27 <mattam> In other words, as long as it is not abstracted.
02:58:33 <dons> ?quote Stereo
02:58:33 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
02:58:35 <dons> hmm
02:58:40 <psykotic> mattam: right. btw i can't connect to your homepage for some reason.
02:58:47 <|Steve|>  Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
02:58:51 <Cale> somehow my stereo quote got deleted :)
02:58:56 <Cale> nooooooooo...
02:59:03 <|Steve|> @remember stereo Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
02:59:03 <lambdabot> Done.
02:59:15 <mattam> Yes, there's an electric downtime toda, but it should come back at 12
02:59:24 <|Steve|> I had asked lambdabot for the quote a while ago and it was still in my /query window.
02:59:53 <matthew-_> Cale: I think you are forever doomed
03:00:37 * |Steve| just tries to never say anything quote-worthy.
03:00:46 <dons> yes, i recall now, due to the blackout, the file got corrupted
03:00:51 <dons> so i darcs reverted
03:00:58 <dons> which gave us whatever the last recorded quotes file was
03:01:09 <dons> now, i've got backups all over, so we can probably recover these :)
03:01:11 <matthew-_> dons: cron job to ci the quotes file daily?
03:01:27 <dons> yeah, i should do that. already do that for the log files
03:02:28 <dons> so what's the top iterations/sec achieved for a haskell program during the contest
03:02:31 <mattam> I wonder if anyone tried to use Sequence for the ICFP contest this year ?
03:02:35 <dons> Cale: http://wiki.freaks-unidos.net/icfp/2007/ interesting
03:02:36 <lambdabot> Title: icfp/2007/index
03:02:43 <dons> matthew-_: yeah, Cale did/lazy Bottoms
03:03:17 <|Steve|> Lazy bottoms, sounds uncomfortable.
03:03:50 <matthew-_> dons: you meant that for mattam, not matthew-_
03:04:50 <Cale> dons: My current implementation is doing around 10k/sec, but I haven't tried too hard to optimise it.
03:05:05 <roconnor> dons: hah, they are geniuses
03:05:14 <roconnor> they deserve to beat me.
03:05:41 <Cale> mattam: I used Data.Sequence quite a bit on the input side.
03:06:34 <mux> Cale: is the speed of our RNA builder decent with haskell?
03:06:39 <mux> s/our/your/
03:06:50 <Cale> reasonably so, I'd say
03:07:26 <Cale> The RNA output in my implementation is a lazy list of typically small Seq's (the results of each iteration).
03:08:31 <Cale> (and the DNA input is a Seq)
03:08:33 <mattam> 1k/sec is what
03:08:46 <Cale> mattam: I'm counting iterations
03:08:46 <mattam> I get with an ocaml bigarray impl
03:08:50 <Cale> oh
03:10:16 <dons> matthew-_: oh, good to know. i'm very happy about desp's 40k/sec bytestrings then
03:10:23 <dons> mattam: grr :) tabs!
03:10:38 <matthew-_> dons: I'll pop down and change my name!
03:11:01 <_star_> hi
03:11:06 <mattam> Well, the story is a bit funny. There was a bug in this implementation that appeared Friday night and which we finally traced back sunday night. Obviously it was a side-effect...
03:11:08 <_star_> i'd like to learn haskell
03:11:12 <_star_> http://www.haskell.org/tutorial/haskell-98-tutorial.pdf
03:11:16 <Cale> _star_: welcome :)
03:11:20 <_star_> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
03:11:26 <_star_> which is best? :)
03:11:41 <Cale> yaht is good, you could also try the wikibook
03:11:45 <mattam> This prevented us to see any image before sunday at 11pm :)
03:11:57 <_star_> cale: wikibook, nice idea
03:12:20 <mattam> I kind of teached me a lesson :) _never_ try to be smart with effects
03:12:28 <Cale> If you already have a background in functional programming, the "Gentle Introduction" is okay, but if not, the name seems inappropriate :)
03:12:45 <Cale> Still, it's worth reading alongside other things.
03:12:50 <mattam> roconnor: how fast was you impl ?
03:12:57 <Cale> Also, stick around here and ask lots of questions
03:13:10 <|Steve|> Because they'll be answered in stereo.
03:13:16 <roconnor> matthew: 15min for endo.dna
03:13:22 <_star_> cale: ok thanks
03:13:28 <roconnor> er
03:13:31 * beelsebob notes that YAHT still preaches an old mantra that Haskell is slow
03:13:35 <roconnor> mattam: 15 min for endo
03:13:35 <beelsebob> that really needs changed
03:13:40 <_star_> i don't have any functional programming background
03:13:40 <Cale> Yeah :)
03:14:13 <Cale> Haskell (GHC) can no longer really be considered slow :)
03:14:15 <zmike> How much FP code do you have to write before it starts making sense?
03:14:16 <|Steve|> As does chapter 9.
03:14:28 <|Steve|> (need to be changed, that is)
03:14:31 <beelsebob> Cale: the debian shootout shows it being faster that C# and less memory intensive
03:14:31 <matthew-_> _star_: you're mostly used to imperative and object oriented programming?
03:15:04 <pejo> zmike, people get quite far in 5 weeks, even when without background in programming.
03:15:30 <Cale> zmike: hmm... 500 lines of Haskell?
03:15:37 <zmike> I started working through SICP, and it all seems very strange still
03:16:00 <zmike> 500 lines of Haskell is a lot, that's like 50000 lines of C or something :)
03:16:04 <Cale> yes
03:16:08 <Cale> something like that :)
03:16:17 <_star_> matthew: yes
03:16:19 <|Steve|> I don't think that SICP is very good.
03:16:22 <matthew-_> _star_: then you may find the initial hurdle quite hard. As Cale says, stick around here and ask lots of questions
03:16:22 <pejo> zmike, did C make sense to you when you started with that?
03:16:29 <Cale> If you've written a 500 line program, you can probably consider yourself an expert :)
03:16:49 <beelsebob> heh
03:16:50 <|Steve|> Pft. I think I've written a 500 line haskell program and I'm about as far from expert as you can get.
03:16:51 <zmike> Well, I learned imperative programming over the course of about 15 years so it's hard to remember exactly how it went
03:17:13 <matthew-_> but a 500 line haskell program will contain orders of magnitudes fewer bugs than 50000 lines of C ;)
03:17:24 <beelsebob> Cale: maybe that should be "if you've ever written a 500 line program that needed to be 500 lines long, you can probably consider yourself an expert"
03:17:25 <mattam> Cale: even with a fat impl you didn't get any clue ?
03:17:32 <zmike> |Steve| You don't think SICP is good in general, or you don't think it is a good introduction to FP ideas?
03:17:35 <mattam> s/fat/fast/
03:17:35 <|Steve|> beelsebob: Heh, there you go.
03:17:52 <|Steve|> zmike: I don't think it's very good in general. It's too wordy for one.
03:17:52 <Cale> mattam: We got lots of clues, just not so many usable clues.
03:18:14 <Cale> mattam: We had lots of guide pages, and the gene index.
03:18:15 <zmike> Is it a good or a bad idea to attempt to do the kind of I/O heavy things I would usually write in C in Haskell?
03:18:23 <zmike> as an exercise
03:18:39 <|Steve|> zmike: It's probably a good exercise.
03:18:50 <Cale> zmike: IO heavy things might not give you the full experience though.
03:18:55 <|Steve|> It seems nontrivial like in, oh, every other language I've used.
03:19:02 <mattam> And that didn't help find a good prefix at all ?
03:19:12 <Cale> mattam: Well, if we'd had another day...
03:19:45 <Cale> mattam: It took us quite a while to get the full DNA -> GUI process up and running.
03:19:54 <beelsebob> zmike: depends on the IO heavy thing -- what is it?
03:20:02 <mattam> what kind of info did you get from the guide pages ?
03:20:07 <zmike> beelsebob: network programming, for example
03:20:13 <Saizan> ?hoogle Maybe (IO a) -> IO (Maybe a)
03:20:14 <lambdabot> No matches, try a more general search
03:20:20 <Cale> mattam: http://cale.yi.org/guide/
03:20:21 <mattam> Cale: interesting, what prevented it to be quick ?
03:20:26 <lambdabot> Title: Index of /guide
03:20:28 <Cale> mattam: er, that's a subset...
03:20:32 <beelsebob> zmike: could be... could be not... depends on the task
03:20:55 <matthew-_> zmike: I/O heavy doesn't tend to be very idiomatic. Nor does it tend to allow you to use really neat features of Haskell
03:21:01 <Saizan> ?hoogle IO (Maybe (IO a)) -> IO (Maybe a) -- is there a nice way to write this?
03:21:01 <lambdabot> Hoogle Error: Parse Error: Unexpected character '-- is ther'
03:21:12 <zmike> That's kind of what I figured, but I don't know what else I could write
03:21:22 <zmike> exercises from the books and tutorials I guess
03:21:26 <matthew-_> zmike: you could just read the code for DisTract (distract.wellquite.org). It's I/O heavy, there's quite a lot of it there, but it's really not very complex
03:21:29 <dons> matthew-_: oh, you get to use monad transformers, for heavy io tuff
03:21:32 <dons> stuff (like xmonad)
03:21:33 <|Steve|> zmike: YAHT has good exercises.
03:21:33 <Cale> mattam: the first implementation of the DNA compiler was a loss, eventually vincenz and I started over. There were lots of subtleties to the spec that we ignored for a long time and they bit us.
03:21:48 <matthew-_> zmike, dons: that's a good point - read XMonad.
03:21:54 <zmike> I started YAHT, but the early exercises are pretty trivial
03:22:03 <mattam> Like what ?
03:22:09 <zmike> do they get harder?  take more than 2 minutes?
03:22:15 <|Steve|> zmike: True. Not that I've noticed.
03:22:44 <|Steve|> Actually, the point-free stuff was very hard at first.
03:23:12 <|Steve|> Much harder than anything else up to that point. But once I understood it, it was pretty fun, actually.
03:23:35 <_star1> everyone here did ICFP with haskell?
03:23:44 <Cale> Pretty much :)
03:23:52 <mattam> OCaml here
03:23:53 <mgsloan> well, everyone here that did ICFP
03:24:04 <zmike> I'll keep ploughing through YAHT.  That's probably my best bet for now
03:24:15 <zmike> It seems to be the right pace for me
03:24:26 <_star1> cale: which position are you?
03:24:30 <|Steve|> Well good luck to you. I'm off to bed.
03:24:59 <zmike> I tried to start the 'scheme in 48 hours' one, but it's not good for somebody with 0 exposure to haskell
03:25:07 <Cale> _star1: 56th
03:25:50 <Cale> _star1: Got the main toolchain up and running, found lots of guide pages, and the gene table, but didn't have enough time after that to solve anything else.
03:26:04 <Cale> _star1: we did have a GUI though.
03:26:18 <_star1> well, nice job
03:26:33 <mattam> What did you do with your GUI ?
03:26:34 <_star1> this means that haskell it's better than C+Python ;)
03:27:28 <Cale> mattam: Stepped through RNA, watched the drawing process, tried prefixes, and so on.
03:27:39 <dons> we have 2 haskell teams in the top 15 though, so we're still hoping ... :)
03:27:50 <dons> Cale, you should blog about the gui, finger trees and so on, while the topic is hot
03:27:55 <dons> and the screenshot are nice
03:28:42 <Cale> mattam: oh yeah, that link I gave doesn't have all the pages we found
03:29:27 <Cale> http://cale.yi.org/guide/ -- there, now it does :)
03:29:32 <lambdabot> Title: Index of /guide
03:29:56 <Cale> There's a heck of a lot more than that in there though :)
03:30:49 <dcoutts> Cale: how did you do your gui?
03:31:06 <Cale> dcoutts: Gtk2Hs of course :)
03:31:18 <Cale> With glade
03:31:34 <dcoutts> cool :-)
03:31:55 <dcoutts> Cale: any chance for some screenshots & a blurb for the gtk2hs site? :-)
03:32:14 <mattam> Seems like there was still a lot to be found after the guide :)
03:32:31 <dons> yeah, Cale, i think it would be a good bit of advertising :) gui blogs!
03:32:38 <Cale> hehehe
03:32:57 <Cale> Perhaps we can put something together. :)
03:33:29 <Cale> One thing I noticed though is that it seems there's room for a Data.ByteStrings of graphics manipulation.
03:33:47 <dons> hmm. that's an interesting idea.
03:33:48 <Cale> I had to do a lot of the graphics with unsafeWrites
03:33:58 <Cale> and no getPixel/setPixel type abstractions.
03:36:20 <Cale> It would have been nice to have more time to do an approximate renderer
03:36:40 <Cale> In fact, if we'd only done an approximate renderer, we'd probably have gotten more done :)
03:45:40 <Cale> That was a pretty nasty brownout/surge. Hope it didn't damage anything :)
03:45:59 <dons> scary
03:46:57 <fasta> Wouldn't it be possible to build a more generic mechanism s.t. Data.ByteStrings is an instance of the result of applying that mechanism?
03:47:18 <Cale> Heh, does anyone remember the blackout in 2003 when the entire eastern seabord of the US and southern Ontario blacked out?
03:47:28 <fasta> I do
03:47:51 <Cale> I was on IRC at the time and just managed to get out "ooh... brownouts"
03:47:58 <Cale> before all the lights went off :)
03:49:54 <matthew-_> I haven't had a brownout or blackout since the early 1990s. OTOH, quite a lot of England is distinctly soggy right now.
03:50:58 <Cale> This city sucks for power reliability. If I had some money to spare, I'd probably get a UPS.
03:51:45 <matthew-_> aren't UPSs stunningly inefficient?
03:52:01 <dons> my laptop battery works well for brownouts
03:52:04 <matthew-_> don't they go AC -> DC -> AC ?
03:52:17 <dons> we had a short blackout on sunday, when lambdabot went down, but my phd thesis was fine on laptop backup :)
03:52:49 <dozer> is there a nicer way to write this:
03:52:49 <dozer> findAll (_::uri) = faDefault `extQ` atOWLClass
03:52:49 <dozer>   where
03:52:49 <dozer>     atOWLClass (oc :: OWLClass uri) = [oc]
03:52:49 <dozer>     faDefault = concat . gmapQ (findAll (undefined::uri))
03:52:53 * fasta has no basic infrastructure horrors to share.
03:53:00 <Cale> Heh, and then every once in a while you get some drunk teenagers taking out the bottom half of the telephone pole across the street with their car, causing the power transformer at the top to explode in a rain of white sparks, then skidding across two lawns before getting out and stumbling away.
03:53:03 * fasta is happy with that situation
03:53:13 <dons> Cale: oh, i remember when you told us about that!1
03:53:25 <dons> you were here on irc, and then there was a kaboom
03:53:30 <Cale> yep
03:55:32 <matthew-_> Cale: didn't you also tell us about a grand piano sailing down the street whilst being played?
03:55:43 <Cale> uh, wasn't me
03:55:56 <matthew-_> oh ok.
03:57:26 <Saizan> http://cale.yi.org/guide/hidden.png <-- this is what you get with the prefix provided in the spec?
03:57:48 <Cale> Saizan: No.
03:58:22 <Cale> I'm pretty sure that's what you get when you use the prefix that is the first thing that gets drawn when rendering with no prefix.
03:58:34 <Cale> (and then everything else is drawn on top of it)
03:58:59 <Cale> The prefix given in the spec will give you the self-test image.
04:00:19 <phoniq> so with ghc 6.6.1, what's the best way to attack a program that doesn't terminate?
04:00:43 <Cale> phoniq: Debug.Trace.trace is often effective
04:00:43 <dons> with an axe :)
04:00:44 <EvilTerran> interactive, or compiled?
04:00:53 <phoniq> could do either
04:00:57 <phoniq> it's just one file
04:01:15 <Cale> phoniq: or break it down into parts so you can see what's happening better
04:01:19 <dons> you can also compile it with profiling enabled, and get a stack trace in the .prof file
04:01:24 <dons> if you've no idea where the loop is
04:01:30 <Cale> oh yeah
04:01:44 <Cale> the .prof will list the number of entries of each cost centre
04:01:54 <Cale> you can just look for the ridiculously large number :)
04:02:01 <dons> and the last executed cost centre should be on top
04:02:04 <dons> iirc
04:02:19 <phoniq> i assume it'll spit out a .prof even if i ^C it, it doesn't wait for normal termination
04:02:25 <Cale> yes
04:02:29 <phoniq> cool
04:02:38 <phoniq> thanks
04:02:48 <dons> yeah, ghc -prof -auto-all
04:02:52 <Cale> To do that, you pass -prof -auto-all to the compiler, and run the program with +RTS -p on the commandline
04:03:06 <phoniq> so Hat got absorbed into ghc?
04:03:15 <phoniq> (just curious)
04:03:19 <Cale> not as far as I know
04:03:30 <Cale> Though there is a new debugger due in 6.8
04:03:36 <Cale> It's not like hat though
04:03:48 <phoniq> oh, duh.  different things, hat and -prof.
04:04:08 <phoniq> lemme start with -prof...
04:04:10 <fasta> You can also use the debugger to find infinite loops
04:04:48 <fasta> When you are in an infinite loop you do C-c and the exception gets catched and you can debug back in time.
04:05:01 <Cale> fasta: cool
04:05:09 <fasta> Cale: that is the theory
04:05:24 <phoniq> tons of great stuff going on in haskelland these days
04:05:25 <fasta> Cale: in practice for my loops it didn't work, because of <weirdness>
04:06:03 <dons> hpc got moved in to ghc
04:06:07 <fasta> Does Haskell have critical mass already?
04:06:10 <dons> and the ghci debugger
04:06:20 <Cale> It's a problem when you're hitting black-holes that are not really black holes :)
04:06:28 <dons> fasta, i think it does, due to its research base, to be /sustainable/, but maybe the way lisp was
04:06:57 <Cale> I don't want the number of users to explode just yet :)
04:06:59 <dons> the library situation is very encouraging, imo.
04:07:13 <Cale> Slow steady growth is good :)
04:07:19 <phoniq> i can vouch for one guy (me)
04:07:33 <matthew-_> dons: mmm. I think the api changes to the core libraries needs to basically stop before Haskell can explode
04:07:35 <dons> 300 libs on hackage in 4 months. that + multicore means the future looks good
04:07:46 <fasta> dons: numbers don't say everything
04:07:51 <phoniq> who wanted to do some FP mostly as a mental exercise, but didn't want to learn lisp
04:07:52 <fasta> dons: actual experience does
04:07:54 <dons> matthew-_: yeah. breaking out the base libs is helping with that.
04:07:58 <matthew-_> and we need a proper solution to the b0rken Num classes
04:07:59 <Cale> dons: 300 libs that will need maintenance if the Prelude changes :)
04:08:05 <fasta> dons: there are few _good_ libraries.
04:08:07 <dons> right, big project experience needs to increase
04:08:37 <phoniq> landed on haskell after a few days of playing with ocaml.  i figure i'm not the only one.
04:08:43 <dons> matthew-_: oh, i don't think that's a show stopper though
04:08:52 <dons> plenty of languages are broken deeply, and it doesn't stop them
04:09:06 <matthew-_> dons: Hmmm. But Haskell is better than that ;)
04:09:07 <dons> phoniq: yeah, welcome. our arrays don't have 4M limits :) and we like threads :)
04:09:32 <matthew-_> dons: spoken like a true Erlanger :-P
04:09:34 <Cale> dons: But what makes/made Haskell different is that it didn't stabilise on bad solutions so quickly.
04:09:38 <fasta> I would like Haskell to move more to Coq.
04:09:59 <EvilTerran> matthew, iirc, there's some project that replaces the numeric heirarchy with one with a better foundation in mathsa
04:10:18 <doserj> the problem is, there are several
04:10:44 * dons `parMaps` matthew-_ ;)
04:10:47 <pejo> There's probably a fair share of lurkers that use the language without mkaing much of a fuss too. Those shouldn't be forgotten when talking about "critical mass" imho.
04:11:11 <dons> pejo, yes! there's nearly always /twice/ as many icfp teams using haskell, as those who we know. i'm always surprised by that
04:11:22 <Cale> For the type system and all the truly fundamental stuff, I actually rather like the way Haskell is moving at the time being. But for actual "user interface" things which are still at the language-definition level, like the Prelude, it seems that we've gotten kinda stuck.
04:11:52 <Cale> For example, it sounds a little bit crazy for me to propose that we flip the associativity of ($), but it really shouldn't be :)
04:12:11 <dons> the core is moving slowly, all the activity is around libs (and parallelism/data structures/type system stuff). the prelude will likely not change i suspect
04:12:18 <pejo> Cale, the current 'movement' is mainly due to a few research groups though?
04:12:18 <Cale> hmm
04:12:28 <phoniq> i decided to get into haskell when i read that 80% of perl6 had been prototyped in haskell in 2 weeks.
04:12:40 * matthew-_ deploys dons on a telco box with 9 9s uptime
04:12:46 <Cale> phoniq: it's a wonderful language :)
04:12:48 <dons> what i'd like to see is more commercially produced libs.
04:13:11 <Cale> dons: commercially-produced open-source libs?
04:13:12 <dons> we have galois making some libs available, but none from CS or Deustsche bank et al.
04:13:34 <matthew-_> surely the prelude has to change. I will be very sad if numbers don't get sorted
04:13:43 <pejo> Does CS do anything suitable to bundle in a library at all?
04:13:48 <ndm> if some of the bigger projects (darcs/ghc) focused more on libraries, which they then used, there would be a lot more quality libraries
04:13:54 <dons> Cale, the commercial haskell companies feeding big key libs back in, with the deep development they can afford
04:14:02 <dons> things you see in the erlang world..
04:14:22 <matthew-_> well actually, funding in the Erlang world is kinda iffy
04:14:24 <dons> ndm, yeah, darcs appeared /just/ before the lib explosion
04:14:43 <dons> matthew-_: right, so little research funding, but more commercial work ?
04:14:44 <matthew-_> Erricson (sp) doesn't /really/ want to be spending money developing and maintaining a language
04:15:09 <matthew-_> but they've learnt that if they tolerate it, people won't resign
04:15:17 <dons> heh
04:15:41 <matthew-_> http://www.erlang.org/ml-archive/erlang-questions/200607/msg00098.html
04:15:43 <pejo> matthew, it wasn't that successful last time they threw it out
04:15:44 <lambdabot> Title: RE: question about Erlang's future, http://tinyurl.com/2qtxgh
04:15:54 <dons> i wonder if galois could run a summer internship, like Jane St. did for ocaml this summer..
04:16:01 <Cale> The Prelude is really a beautiful piece of code, but it really has to be perfect because what's in the Prelude and how those things work affects everything.
04:16:26 <Cale> I wouldn't mind seeing at least one more big breaking Prelude shift.
04:16:30 <pejo> dons, doesn't Galois already sponsor a summer visit for an academic to do crazy stuff (Runciman last year, Hutton this?)?
04:16:36 <dozer> it's worth learning from the history Java core libs - old vs new collections, awt vs swing
04:16:42 <ndm> no, they don't pay for the academic
04:16:47 <Cale> Who wants to fork fptools? :)
04:16:52 <ndm> it was Runciman's sabatical
04:16:54 <matthew-_> dozer: that's a good point.
04:16:59 <pejo> ndm, ah, they just host them?
04:17:35 <ndm> pejo: yes, i don't know the exact arrangement, but they are visiting researchers, not salaried by galois
04:19:23 <dons> pejo, yeah. Hutton's there now. and they've had interns as well.
04:19:32 <dons> or 1 intern.
04:20:12 <Cale> how is it that HWN was at 0 score on reddit?
04:20:17 <Cale> http://programming.reddit.com/info/28qc9/comments
04:20:18 <lambdabot> Title: Haskell Weekly News: July 23, 2007 (reddit.com)
04:20:31 <Cale> needs more upvotes :)
04:20:31 <dons> Cale, not sure. bad title? when i put them up, i usually include a list of the key libs that appeared
04:20:37 <dons> so the title was likely not very motivating
04:20:44 <dons> also, there are 2 people who mod down all haskell articles
04:20:54 <dons> (they at least claim that)
04:21:03 <dons> so then you get a quick +1 -2, and its a bit iffy after that
04:21:03 <matthew-_> Gilad Bracha, and who's the other?
04:21:06 <matthew-_> ;-P
04:21:28 <dons> not like the old days, last Novemeber, when we could count on +6 from this channel ;)
04:21:46 <dons> everyone just expects haskell articles now
04:21:51 <Cale> hehehe
04:21:58 <dons> we've been spoilt.
04:21:59 <Cale> I'm still modding them all up
04:22:06 <Cale> and modding nearly everything else down
04:22:11 <dons> i bet the erlang, ocaml, lisp guys wish they had a sigfpe or lennart blogging.
04:22:23 <dons> somehow we got one of the most interesting blog communities buitl up, really quickly. its cool
04:22:40 <dcoutts> @arr!
04:22:40 <lambdabot> Smartly me lass
04:23:01 <dons> Jon Harrop isn't a suitable substitute for a sigfpe, for the ocaml crowd ;)
04:23:31 * dcoutts pushes more cabal patches
04:23:51 <dons> dcoutts: which versions of cabal ensure -O2 (or -O) by default for ghc builds?
04:23:58 <dons> only darcs? or one of the released versions?
04:24:02 <dcoutts> 1.1.6 and above iirc
04:24:13 <dons> and dcoutts, did we ever decide to work out why mtl doesn't inline/unfold very well?
04:24:18 <dcoutts> --enable-optimizations is on by default
04:24:23 <dcoutts> and implies -O for ghc
04:24:33 <dons> a few people complained they had to implement StateT locally during ICFP, because it wasn't inlining properly from mtl. :/
04:24:40 <dons> as we did for binary.
04:24:51 <dons> should it be -O2, given SpecConstr?
04:24:53 <dcoutts> dons: we didn't, my suspicion was data representation rather than lack of inlining
04:25:15 <hpaste>  phoniq pasted "bad debian packages?" at http://hpaste.org/1860
04:25:17 <dons> oh, ok. mnislaih i think mentioned a 3x speed up moving waway from mtl
04:25:27 <dcoutts> dons: I think ghc team should decide if they want SpecConstr to move to -O, rather than us deciding to force everyone to -O2
04:25:41 <dons> hmm. yes. good pint
04:25:56 <mnislaih> dons: but we had a stack of up t 4 monad transformers
04:26:07 <mnislaih> that's probably an extreme case
04:26:10 <dons> hmm. still. did you unroll them by hand?
04:26:14 <mnislaih> yes
04:26:16 <dcoutts> dons: in gentoo ebuilds we routinely patch packages that specify -O2 to -O since it take much longer to build and usually for little benefit
04:26:18 <dons> ah ok.
04:26:52 <wolverian> what does runghc actually do?
04:26:54 <dcoutts> I think doing representation optimisations for newtyped stacked monad transformers would be an interesting project
04:27:03 <dons> oh, that's interesting. i just noticed that 4/4 shootout programs i looked out got better with -O2
04:27:08 <dons> but all < 10% better
04:27:11 <wolverian> it's not using ghci, is it? it's compiling in /tmp or what?
04:27:17 <dons> and the 10% case was a bytestring benchmark
04:27:22 <dcoutts> the newtype wrapper gives an opportunity to transparently optimise the representation underneath
04:27:31 <mnislaih> wolverian: it is a wrapper around ghc -e, which is the same as ghci
04:27:33 <ndm> dcoutts, my optimise may well do that already
04:27:51 <wolverian> mnislaih, oh. thanks. it does work with -threaded, though, whereas using ghci itself doesn't.
04:27:54 <wolverian> that confused me.
04:28:00 <dcoutts> ndm: as ever, we eagerly (or lazily?) await your results :-)
04:28:02 <dons> ndm, you'll have to hook it into ghc to get anyone using it , right? (as a practical matter)
04:28:10 <mnislaih> ndm that would be a good test case for your optimization. Can it optiimize mtl code ?
04:28:31 <ndm> dons: its hooked into Yhc.Core, once GHC has a Core language, it will be hooked into GHC as well
04:28:35 <dons> dcoutts: did you get a final version of the fusion paper, btw?
04:28:39 <dons> the final pdfs are in the repo
04:28:43 <dcoutts> dons: yep
04:28:49 <ndm> dcoutts, i'm going to give a talk on it at anglohaskell
04:29:01 <ndm> mnislaih: it can optimise anything, that Yhc can compile...
04:29:14 <dcoutts> dons: shootout programs are not representative of the packages we're building, things like wash and http don't benefit from -O2 in the way that shootout progs do
04:29:17 <ndm> mnislaih: and i'll get a response to your email in a few hours, just have to track down my supervisor first :)
04:29:24 <dons> dc	yeah
04:29:29 <dons> 1 instruction less can matter in the shootout
04:29:31 <mnislaih> ah, ok. But I thought you could use Binkley's Core patches for ghc HEAD already
04:29:51 <dons> dcoutts: so its more like monad, where we got with -O -fasm
04:30:00 <dcoutts> dons: you'll have to try those again with the new HEAD NCG register allocator
04:30:11 <mnislaih> ndm: great, but too late. I am already sharing the room with Igloo and Lemmih
04:30:17 <dons> ndm, you'll need to work out how to transparently and simply use these things with ghc, for the work to get any traction in the community
04:30:28 <ndm> mnislaih: we can, but they are incomplete, they don't have things like data types in them, and are a moving target - i have a prototype convertor
04:30:34 <ndm> mnislaih: fair enough
04:30:35 <dons> even things like hacle are too hard, to be used practically, unfortunately
04:30:59 <mnislaih> :(
04:31:08 <dons> though i'd love to tear out the clean code generator one day ...
04:31:11 <ndm> dons: i know, think of my optimiser as a testbed, if people wanted it practically it would have to be reimplemented in GHC
04:31:18 <dons> yeah
04:31:43 <dons> so you could sit down with SPJ, one day, and sort out a simple-to-describe optimisation that could happily go into ghc
04:32:06 <dons> though ghc probably needs more backend work now
04:32:14 <dons> the front end optimises most things i need just fine
04:32:23 <mattam> psykotic: it's up again
04:32:36 <dons> down to core, then i get frustrated at the 5% slow down wrt. clean, in the native code gen bottleneck
04:32:54 <benny99> hi
04:33:14 <dons> oh, oscon day 1 is over. do we have SPJ videos yet?
04:33:25 <dons> xmonad videos!
04:33:41 <benny99> http://en.wikibooks.org/wiki/Haskell/Understanding_monads - "State and the bind robot" --- What is the first function there meant to be?
04:33:43 <benny99> oscon day ?
04:33:43 <lambdabot> Title: Haskell/Understanding monads - Wikibooks, collection of open-content textbooks
04:34:25 <benny99> I don't want a full explainment (since there's a text), but why is it "container <<= fn = ..." ?
04:34:27 <dons> bizarre, http://e-scribe.com/news/images/lolschwartz.jpg
04:34:29 <dons>  :)
04:34:30 <dcoutts> dons: yeah, backend things. Keep an eye on the new register allocator
04:34:46 <dons> yeah
04:35:02 <wolverian> hm. I'm calling out to mplayer in a forkIO with runInteractiveProcess, get some information from its stdout, write it to mvar, then wait for mplayer to exit in the forkIO, while the main thread processes the information and then forkIOs on the next input file, loop. I see a lot of <defunct> mplayers in top (~300 in five seconds). is that a problem?
04:35:19 <dons> sounds like you got some zombies, wolverian
04:35:23 <benny99> dons: I give it a lol
04:35:34 <dons> you'll need to wait() on them, wolverian
04:35:43 <wolverian> dons, I thought waitForProcess does that.
04:35:54 <wolverian> sorry, I wasn't clear I'm using that
04:35:54 <benny99> is anybody there for my problem :'( ?
04:36:24 <dons> yep. wolverian this is what I use, http://www.cse.unsw.edu.au/~dons/code/newpopen/System/Process/Run.hs
04:36:25 <lambdabot> http://tinyurl.com/2f7j8l
04:36:36 <dons> wolverian: there's also code in hmp3 for forking mpg321
04:36:43 <dons> but its low level fd dup stuff
04:36:58 <wolverian> dons, oo, that's cute
04:37:17 * roconnor looks at state and the bind robot
04:37:54 <roconnor> benny99, you mean container >>= fn =   ?
04:38:15 <benny99> roconnor: yeah, exactly :-[
04:38:19 <wolverian> dons, I open the process in the forked thread, and waitForProcess in there too. I see you do those in the main thread. could that be the problem?
04:38:24 <roconnor> This is how haskell defines infix operators
04:38:34 <roconnor> The operator being defined is >>=
04:38:40 <benny99> roconnor: I thought functions are supposed to be declared like "container x y = *do something with x y*"
04:38:42 <roconnor> even though it isn't the first symbol.
04:38:53 <roconnor> for example
04:38:55 <benny99> ah :O)
04:38:59 <benny99> got it I guess :)
04:39:10 <benny99> a + b = <-- ?
04:39:15 <benny99> something like that?
04:39:16 <roconnor> > let x <+> y =  (x+y)/2 in 4 <+> 6
04:39:17 <dons> wolverian: hmm.
04:39:17 <lambdabot>  5.0
04:39:28 <dons> wolverian: you using -threaded?
04:39:31 <benny99> roconnor: ok, thanks :)
04:39:34 <hpaste>  phoniq annotated "bad debian packages?" with "isolated Text.Regex.Posix link error" at http://hpaste.org/1860#a1
04:39:48 <wolverian> dons, yes.
04:39:53 <dons> wolverian: since waitForProcess blocks all threaded, without -threaded, iirc
04:40:09 <dons> wolverian: could it be returning early, from the forkIO'd thread?
04:40:18 <dons> maybe you're not reading all input?
04:40:19 <roconnor> benny99:  see the section on euro for another example
04:40:32 <dons> you'll need to strictly consume input, for there not to be weird blocking
04:40:40 <dons> hence the forkio'd length thingy
04:40:44 <benny99> roconnor: yeah, heard about it, but am new to haskell and didn't see it at first sight :/
04:40:48 <wolverian> dons, oh. right. I'm not doing that.
04:41:01 <dons>     forkIO $ C.evaluate (length output) >> putMVar outMVar ()
04:41:14 * benny99 is away for some minutes
04:42:22 <wolverian> argh, laziness is really weird. :)
04:42:30 <chris2> is there something like slime/distel/... for haskell? like, "find this definition" etc.
04:43:00 <dons> wolverian: yeah, we need more obvious support for strict IO
04:43:11 <dons> System.IO.String would be very useful
04:43:27 <wolverian> yup
04:43:35 <dons> System.IO.Strict, grr
04:43:51 <dons> also, StrictList a, dcoutts :)
04:44:22 <dcoutts> hmm
04:44:34 <dons> not strict in the spine, just in the elements
04:44:43 <dons> and stream fusible.
04:44:49 <dons> easy peasy, and fast
04:45:05 <dcoutts> it's not obviously that fast since it's not unboxable
04:45:23 <dcoutts> you're only saving checking if it's evaluated, not saving an indirection
04:45:36 <dcoutts> and ghc's new semi-tagging saves much the same stuff
04:45:39 <dons> why can't you unpack the element field?
04:45:47 <dcoutts> if it's polymorphic?
04:45:48 <dons> for say, Int?
04:45:52 <dcoutts> StrictList a ?
04:46:03 <roconnor> @go Ropes: An Alternative to Strings
04:46:04 <lambdabot> http://www.cs.ubc.ca/local/reading/proceedings/spe91-95/spe/./vol25/issue12/spe986.pdf
04:46:07 <dons> oh, ghc won't take StricTList a and doing anything for us?
04:46:15 <dcoutts> no
04:46:28 <dcoutts> because you can still pass them to functions that take StrictList a
04:46:33 <dons> oh, that's tedious. we'd need ATs to pick better representations then
04:46:36 <dons> yeha.
04:46:54 <dcoutts> that's what I meant about newtypes giving you an opportunity to optimise internal representations
04:47:11 <dcoutts> since there are clearly defined wrapping/unwrapping points
04:47:15 <dons> type family StrictList Int = UnpackedStrictList Int#
04:47:37 <roconnor> dons: ah, now I see what you mean by fingetrees of strictByteStrings
04:47:44 <roconnor> sounds wonderful
04:47:52 <dcoutts> roconnor: aye, would be very similar to ropes
04:47:59 <dons> roconnor: yes, how close to ropes would they be?
04:48:01 <dcoutts> plus lazy IO
04:48:08 <dons> dcoutts: you know the proper fingertree type is in hackage?
04:48:12 <dcoutts> yep
04:48:19 <dons> so i wonder if anyone's tried FingerTree Int ByteString
04:48:28 <dcoutts> I think sjanssen has
04:48:35 <dcoutts> @seen sjanssen
04:48:35 <lambdabot> I haven't seen sjanssen.
04:48:39 <dcoutts> sp?
04:48:43 <dons> oh, yes, that rings a bell
04:49:39 <dons> oh, the logs would have been wiped in the blackout
04:49:48 <dons> all the servers crashed
04:49:48 <dcoutts> ah
04:49:52 <dons> and there was some .. unpleasantness
04:49:56 <dcoutts> oh dear
04:49:57 <dons> which required darcs revert
04:50:12 <roconnor> dons: any reason not to replace Lazy ByteStrings with trees instead of lists?
04:50:36 <dons> roconnor: we'd need to experiment with it for a while, anyway. so best to do it as a separate package
04:50:43 <roconnor> sure, of course
04:50:54 <roconnor> by replace I mean replace in practice rather than take the namespace
04:50:56 <dons> perhaps keep the list-like lazy bytestrings (with the planned optimisations we have for that)
04:51:01 <dcoutts> roconnor: yes, finger trees cannot be lazy, you need to know their length to keep them balanced
04:51:12 <roconnor> dcoutts: good point
04:51:16 <roconnor> both structures are usefull.
04:51:21 <dons> yeah, so not suitable for the non-rebalanced, non-coalescing streaming we aimed lazy bytestrings for
04:51:27 <dons> (unix pipe-like programs)
04:51:34 <wolverian> dons, hm. using readProcess I get back Left on the second file. the first file is processed correctly.
04:51:51 <dons> whereas the multiple traversal, splicing stuff used in the icfp contest /would/ have been better with bytestrings+finger trees
04:51:52 <dcoutts> in unixy terms, lazy lists of chunks represent infinite streams, finger trees of chunks represent seekable files
04:52:06 <dons> yeah
04:52:21 <wolverian> dons, here's the code: http://cs.helsinki.fi/u/ivacklin/videolengths-threaded.html
04:52:23 <lambdabot> Title: ~/bin/videolengths-threaded.hs.html
04:52:26 <dons> so that is the thing we're missing, lib wise. ropes-alike, or fingertree bytestrings
04:52:32 <dons> sounds like a good hackathon job, dcoutts
04:52:35 <dcoutts> @arr
04:52:36 <lambdabot> Yo ho ho, and a bottle of rum!
04:52:43 <wolverian> (readProcess is called in videoLengths)
04:52:44 <roconnor> ``It is useful to introduce additional kinds of tree nodes. At a minimum, we allow
04:52:44 <roconnor> a second kind of leaf node containing at least a length and a user-deï¬ned function
04:52:44 <roconnor> for computing the ith character in the string.''
04:52:48 <wolverian> er, videoFrames..
04:52:49 <dons> take the finger tree lib, specialise it on bytestrings, crank up ghc
04:52:51 <dcoutts> dons: it could reasonable live in the bytestring package
04:53:02 <dons> yeah
04:53:07 <dons> Data.ByteString.Seq
04:53:11 <dcoutts> along with builder monoids for strict and lazy bytestrings
04:53:27 <roconnor> oh wait, haskell doesn't need that
04:53:28 <dons> right. they were getting used just for bytestring stuff, in Data.Binary
04:53:31 <dons> which is a bit weird
04:53:43 <wolverian> dons, perhaps on error readProcess should return Left (output, err)?
04:53:50 <dons> you shouldn't need Data.Binary to get efficient bytestring builders
04:53:54 <ADEpt> roconnor: why not?
04:53:58 <dcoutts> dons: indeed
04:54:01 <wolverian> that might help in debugging, if I see what it managed to read
04:54:04 <dons> wolverian: oh, that'd be reasonable
04:54:55 <dcoutts> hia ChilliX
04:55:15 <TSC> Anybody have a clever way to compute neigbouring differences?  E.g. diffs [1,8,27,58] = [7,19,31]
04:55:22 <roconnor> ADEpt: Well, I was thinking that lazy evaluation and meomoization could be used instead.
04:55:26 <TSC> Duh, zipWith + tail
04:55:29 <roconnor> but perhaps I'm wrong.
04:55:29 <TSC> Never mind... (:
04:55:35 <ADEpt> TSC: zipWith (-) lst (drop 1 lst) :)
04:56:04 <TSC> > let lst = [1,8,27,58] in zipWith (-) lst (drop 1 lst)
04:56:05 <lambdabot>  [-7,-19,-31]
04:56:09 <TSC> Close enough (:
04:56:14 <TSC> Thanks
04:56:24 <wolverian> dons, not sure what the outer handler should return then, though..
04:58:19 <wolverian> dons, anyway, I get the mplayer header in the output, and that's all. possibly it's just being slow and readProcess is hitting EOF? I'm not sure.
04:58:38 <roconnor> [13:47] <dons> so i wonder if anyone's tried FingerTree Int ByteString
04:58:45 <phoniq> HAH.  -prof + Debug.Trace.trace == profit.   thanks #haskell.
04:58:53 <roconnor> Where is FingerTree?
04:59:01 <dcoutts> roconnor: on hackage
04:59:03 <dons> ?hackage fingertree
04:59:03 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fingertree
05:01:52 <wolverian> dons, maybe it's closing the socket too early, causing mplayer to exit with an error? hrm. I really have no clue. :)
05:01:53 <roconnor> who is responsable for hackage webpages?  It's totally awsome
05:03:17 <dcoutts> roconnor: several people but mostly Ross Patterson
05:04:05 <roconnor> all we need now is a program to render haskell source with hyperlinks.
05:04:37 <roconnor> where is ndm
05:04:54 <roconnor> I have more thesis distraction for him. :)
05:10:17 <dcoutts> roconnor: hscolour does half that job, it adds anchors for top level definitions
05:10:28 <dcoutts> but it doesn't add hyperlinks
05:10:55 <dcoutts> roconnor: but cabal's haddock --hyperlink-source can now make haddock link to hscolour'ed sources
05:11:43 <roconnor> dcoutts: wow
05:11:59 <roconnor> yeah, adding hyperlinks requires much more knowledge.
05:12:35 <roconnor> ... knowledge that a haskell compiler like yhc has ;)
05:15:00 <psykotic> dcoutts, is there something like gems/apt-get/etc for hackage?
05:15:43 <mux> cabal-get is supposed to happen at some point
05:16:01 <doserj> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
05:16:03 <lambdabot> Title: CabalInstall - Hackage - Trac
05:16:04 <dons> psykotic: cabal-install will grab and build cabal tarballs
05:16:19 <psykotic> oh, nice!
05:16:36 <mux> oh, cabal-get is defunct
05:17:13 <psykotic> dons: it doesn't ship with ghc yet, right?
05:17:39 <dons> its in darcs cabal, so no.
05:17:42 <dons> next ghc, iirc
05:17:57 <psykotic> that's pretty great
05:18:25 <psykotic> does it deal with automatically installing dependencies as well, etc?
05:18:36 <psykotic> or is it just a glorified wget? :)
05:18:56 <dons> it chases dependencies :)
05:19:04 <dons> so its a recursive wget , glorified
05:19:14 <mux> does it use fgl for the topological sorting of dependencies?
05:19:24 <dons> heh. don't think so.
05:19:34 <dons> i note openbsd's package system uses tsort though
05:19:51 <mux> well you always need a topological sort to handle dependencies
05:20:05 <dons> maybe it does locally, use a tsort, but it doesn't use fgl
05:20:25 <mux> oki
05:20:33 <dons> fgl is impossible to use :)
05:20:53 <mux> it has a nice and simple topsort function :-P
05:21:03 <psykotic> mux: isn't it like 5 lines of code? 1) invert graph edges, so that from each node you can access incoming edges. 2) repeat until empty: find node without incoming edge. put in list; remove from graph.
05:21:20 <psykotic> i don't think you need the utmost efficiency for something like this :)
05:21:25 <mux> it's a DFS search in post-order with the resulting nodes reversed
05:21:32 <mux> or something
05:21:35 <mux> my memory may be flakey
05:21:43 <dons> psykotic: but you have to plan for the 10k dependent package haskell project! :)
05:21:59 <psykotic> haha
05:22:12 <mux> I wasn't really thinking about performance :)
05:22:22 <psykotic> mux: it's a bit easier than DFS because you don't have to deal with marking visited nodes.
05:22:27 <dons> http://darcs.haskell.org/packages/cabal-install/src/Network/Hackage/CabalInstall/Dependency.hs
05:22:30 <lambdabot> http://tinyurl.com/2roeup
05:22:39 <psykotic> mux: as soon as you find a node without an incoming edge, you can bail out, and restart the search.
05:22:57 <mux> psykotic: well the canonical algorithm is what I've said
05:23:34 <psykotic> repeatedly removing nodes without incoming edges is usually algorithm #1 that's described. the DFS one is #2. :)
05:24:13 <mux> well, I've always read the #2 one, but I fully believe you :-)
05:24:20 <psykotic> hehe
05:24:41 <psykotic> the #1 one is immediate from the spec. if a graph has a tsort then there must be at least one node without a predecessor.
05:24:58 <Philippa> it's not implausible that something big'd end up with 100-odd dependencies given how we tend to factor code as a community
05:25:00 <psykotic> so that node goes first. repeat on the remaining graph.
05:25:10 <Philippa> 10K's a little harder to picture though!
05:25:55 <dons> we do have 10+ deps already
05:26:07 <benny99> http://en.wikibooks.org/wiki/Haskell/Understanding_monads - "State and the bind root" - the first function --- could I make sure that I understood it using this channel :-[ ?
05:26:09 <lambdabot> Title: Haskell/Understanding monads - Wikibooks, collection of open-content textbooks
05:26:10 <psykotic> does anyone know if it's possible to integrate with/use apt-get?
05:26:12 <dons> lambdabot has 14
05:26:25 <psykotic> of course that wouldn't be as platform independent as one could like.
05:26:37 <dons> should be very possible, to just transate cabal to deb, and apt-get for free
05:26:39 <phoniq> somebody is making debian packages, i'm using them...
05:26:46 <psykotic> dons: i mean in terms of dependencies of a non-haskell kind.
05:27:04 <Philippa> benny99: ask away
05:27:10 <benny99> ok :-[
05:27:24 <nominolo> with configurations, dependency chasing gets a little more complicated
05:29:33 <benny99> The bind function takes a container and a function. The container itself is also a function and thous bind returns a function, taking a state. <-- is that right ?
05:30:04 <nominolo> yep
05:30:24 <benny99> =) Ok, it goes on
05:33:04 <DukeDave> Hey all, what's the name of the concept which allows you to give the different components of an ADT names? Such that access function are auto generated.
05:33:25 <Philippa> records
05:33:38 <DukeDave> It's something like    data Person = name :: String; age :: Int
05:33:53 <benny99> let (a, st2) = container st --- by applying the state to the container, it returns a (value, state) tuple.
05:33:53 <benny99> container2 = fn a -- the new container functions i generated by applying the old value to a new function, which is returning a function which takes a ticket and generates a function that returns a (value, state) tuple
05:33:53 <benny99> container 2 st2 -- the state is applied to that function
05:33:54 <DukeDave> Aha, cheers Philippa,
05:34:04 <mux> DukeDave: records
05:34:13 <opqdonut> ?stereo
05:34:13 <lambdabot> Unknown command, try @list
05:34:16 <opqdonut> :(
05:34:19 <opqdonut> ?quote stereo
05:34:20 <lambdabot> stereo says: Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
05:35:21 <benny99> there's something wrong I guess :(
05:35:27 <ndm> dons: i'll talk my optimisation over with SPJ at anglohaskell, hopefully
05:35:34 <ndm> roconnor: you called (with evil purposes)
05:35:44 <nominolo> benny99: you can directly return the result of calling f
05:36:16 <benny99> nominolo: ? I refer to the first function in http://en.wikibooks.org/wiki/Haskell/Understanding_monads "State and the bind robot" :-[
05:36:18 <lambdabot> Title: Haskell/Understanding monads - Wikibooks, collection of open-content textbooks
05:37:15 <benny99> that example is weird :(
05:37:32 <nominolo> ah, ok.  yeah, the overall result should be a function that returns a value and a state
05:37:54 <nominolo> so we have to return a value and a state
05:38:17 <benny99> nominolo: <_< hm.... I still not really got that I guess
05:38:23 <roconnor> ndm: yeah, I want you to modify hscolour to add hyperlinks to the source code.
05:38:24 <nominolo> and we get this by calling the function that was returned from fn to get this
05:38:30 <roconnor> ndm: across modules too.
05:38:30 <benny99> nominolo: could you give me a simple example?
05:38:41 <roconnor> ndm: I can only pay you in karma
05:39:14 <nominolo> benny99: try thinking what types you want
05:39:31 <benny99> nominolo: hm :|, I dunno...
05:39:40 <benny99> nominolo: that's the main-problem I guess :-[
05:39:44 <nominolo> the result type of >>= should be (\s -> (a,s))
05:39:55 <nominolo> er, without "\"
05:39:56 <benny99> yeah
05:40:03 <benny99> without ?
05:40:25 <nominolo> so you have two arguments, one af the some type
05:40:52 <benny99> nominolo: hm, I guess I don't really know where to use that stuff :(
05:40:54 <nominolo> and one,that, given an a returns an (s -> (b,s))
05:41:05 <nominolo> benny99: what stuff?
05:41:12 <nominolo> monads?
05:41:14 <benny99> nominolo: it's used for IO and stuff... that's all I know
05:41:14 <Cale> What's up?
05:41:15 <benny99> nominolo: yeah
05:41:32 <nominolo> benny99: it's a way to structure your program
05:41:35 <Cale> benny99: learning about monads?
05:41:40 <mux> @src concat
05:41:40 <lambdabot> concat = foldr (++) []
05:41:40 <benny99> Cale: yeah :'(
05:42:00 <nominolo> benny99: by doing so you can use lots of library functions that work on any kind of monad
05:42:10 <Cale> benny99: If you'd like I can give a bit of a tutorial. Are you having trouble with anything in particular?
05:42:30 <benny99> Cale: na, I guess I just don't really know what's supposed to look like in a program
05:42:31 <nominolo> benny99: i strongly recommend the "you could have invented them yourself" tutorial
05:42:47 <benny99> nominolo: :D I'll search for it
05:42:51 <nominolo> that doesn't need containers or garbage
05:42:56 <benny99> nominolo: thanks first :)
05:43:08 <Cale> benny99: Okay, for a long time, much longer than people have been using monads to program, functional programmers have been writing "combinator libraries"
05:43:27 <nominolo> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
05:43:29 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
05:43:35 * mux lights the fire and sits nearby to listen to Cale
05:43:47 <benny99> nominolo: thanks !
05:44:06 <Cale> Combinator libraries are just libraries of code with an API that's sufficiently expressive that using the API is like programming in a small programming language sitting inside the one you're using.
05:44:17 <benny99> this is one of the two friendlist channels I know :) *listens to Cale now*
05:44:31 <Cale> These are also called embedded domain-specific languages
05:45:15 <Cale> Generally, in such a language/library, you have a bunch of primitive computations, and then some way of combining those computations into more complex ones.
05:46:12 <Cale> For example, a drawing language might provide drawings like simple lines, and then means of combining drawings "on top", "beside" and so on.
05:46:52 <nominolo> benny99: once you've read the tutorial you can read on.  the thing is that although monads were introduced to only solve one problem it turned out to be a useful concept for many problems
05:46:55 <Cale> Or a language for parsing strings might provide some basic parsers for parsing single characters, and then ways to combine parsers together
05:47:33 <Cale> Like the concatenation of two parsers (one after their other), or their conjunction (try one if the other fails)
05:47:38 <Cale> the*
05:48:18 <Cale> Monads are just a specific kind of combinator library -- that is, one which supports a few basic kinds of combination
05:48:31 <benny99> nominolo: I will :)
05:49:00 <Cale> The advantage of the abstraction is that you get a library of code which works in all monads... control structures you get for free for making your library into a monad.
05:49:23 <Cale> For example, the Control.Monad library includes things like forM which is like a for-each loop.
05:50:14 <benny99> guess I understood that part,  but how do I actually use Monads in programs now?
05:50:30 <Cale> forM someList (\x -> doSomethingWith x), will loop over the elements of someList, applying the function doSomethingWith to each one in order to get an 'action' to be performed, and performing that action, collecting a list of results.
05:51:08 <benny99> printSomething >>= getInput --- or something like that should work somehow I guess
05:51:20 <phoniq> @src forM
05:51:20 <lambdabot> forM = flip mapM
05:51:30 <benny99> @src mapM
05:51:30 <lambdabot> mapM f as = sequence (map f as)
05:51:41 <Cale> Well, in Haskell, doing I/O involves one particular monad, the IO monad.
05:52:00 <benny99> Cale: sorry, didn't want to interrupt you :-[
05:52:01 <nominolo> > mapM (+4) [Just 3, Nothing, Just 42]
05:52:04 <lambdabot>   add an instance declaration for (Num (Maybe b))
05:52:09 <Cale> benny99: no, that's cool :)
05:52:21 <nominolo> > fmap (+4) [Just 3, Nothing, Just 42]
05:52:21 <lambdabot>   add an instance declaration for (Num (Maybe t))
05:52:51 <nominolo> > map (liftM (+4)) [Just 3, Nothing, Just 42]
05:52:52 <Cale> > fmap (+4) (Just 5)
05:52:54 <lambdabot>  [Just 7,Nothing,Just 46]
05:52:54 <lambdabot>  Just 9
05:53:08 <benny99> Cale: yeah, I guess forM involves the fabulous "augment" part, I really didn't get it :(
05:53:20 <Cale> benny99: So, let's focus on the IO monad a bit.
05:53:20 <phoniq> ah two monads, the [] and the Maybe  ?
05:53:44 <phoniq> nm
05:53:52 <Cale> benny99: There's not so much to it in the end, but it's really abstract and I think you need a bunch of examples before it makes any sense.
05:54:02 <Cale> phoniq: those are both monads, yeah
05:54:08 <benny99> Cale: yeah, that is what I was looking for :)
05:54:40 <benny99> Cale: the wikibook called it "Rube Goldberg contraption" and it really appears to be :-[
05:55:00 <Cale> benny99: that's actually not one of the tutorials I usually recommend
05:55:08 <Cale> (for monads)
05:55:25 <benny99> YAHT became weird, so I tried that one
05:55:40 <Cale> Okay.
05:55:43 <benny99> maybe I should try the turoial nominolo sent me
05:55:56 <Cale> http://haskell.org/haskellwiki/Introduction_to_IO -- read this
05:55:57 <lambdabot> Title: Introduction to IO - HaskellWiki
05:56:08 <Cale> it'll only take a couple minutes, then we can talk about it some more :)
05:57:20 <benny99> *reads*
05:58:16 <Cale> feel free to ask questions if you're unfamiliar with any of the syntax
05:58:25 <Cale> (I'm not sure how new you are)
05:58:35 <phoniq> in this kind of thing:   contents <- mapM readFile filenames
05:58:51 <phoniq> how would you shoehorn catch and const (return []) in there
05:58:58 <benny99> (hm, read the first 125pages or something of the YAHT book)
05:59:14 <phoniq> so that where the readFiles failed
05:59:16 <benny99> (am away reading now ;) )
05:59:22 <phoniq> you got [] in your contents list?
05:59:31 <phoniq> I've got one of these:
05:59:38 <phoniq>   contents <- getDirectoryContents path `catch` const (return [])
05:59:42 <phoniq> i pretty much see how that works
06:00:11 <dons> > 0 : ([1..] >>= \n -> [n,-n]) -- cute
06:00:12 <lambdabot>  [0,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13,...
06:00:17 <Saizan> to get hyperlinks for named functions in docs with haddock you have to import the module where they are?
06:00:53 <moonlite_> dons: :)
06:00:56 <Cale> phoniq: contents <- mapM (\f -> catch (readFile f) (const (return []))) filenames
06:01:52 * phoniq gratefully analyzes...
06:02:36 <Saizan> mmh, would readFile f `mplus` return [] work?
06:02:50 <Cale> it might :)
06:02:55 <Saizan> ?src IO mplus
06:02:55 <lambdabot> m `mplus` n = m `catch` \_ -> n
06:03:08 <Cale> The MonadPlus instance for IO is kinda evil, but it works :)
06:03:28 <ndm> roconnor: hscolour does no name resolution, it would be a major piece of work to add it
06:03:33 <Cale> In this case it's rather pretty, even
06:03:49 <ndm> roconnor: i beleive something from the utretch people does what you want, but have no idea how well used it is
06:04:03 <dons> oh, the module browser, ndm?
06:04:12 <Saizan> it depends on which catch is used there, btw i can never remeber the difference between Prelude's and C.E's
06:04:13 <dons> yeah, i remember that. html highlighted everything
06:04:14 <ndm> dons: they have a source code browser as well
06:04:20 <dons> that's the one. yep.
06:04:23 <dons> from 04 HW
06:04:45 <ndm> it had some requirements on it, like you must have the entire program available, and documentation for all the prelude etc
06:04:55 <dons> things from before cabal existed feel lost in the darcs ages of the internets
06:06:38 <benny99> Cale: read your tutorial ;) , guess I understood it :)
06:06:45 <Cale> benny99: cool
06:07:14 <Cale> So we have these basic means of putting together computations with return and bind.
06:07:20 <benny99> yep :)
06:07:23 <benny99> guess so
06:07:48 <Cale> In fact, this is all we need. All the other fancy control structures you're used to can become library functions.
06:07:54 <Cale> (Loops, and so on)
06:08:07 <Cale> sequence is a particularly nice one
06:08:30 <Cale> In the IO monad, sequence has type [IO a] -> IO [a]
06:08:37 <benny99> eh, sorry, except for "x >> y = x >>= const y" , what is const?
06:08:44 <Cale> const x y = x
06:08:53 <Cale> or, const x = (\y -> x)
06:08:57 <Cale> if you want
06:09:01 <benny99> ah :o)
06:09:10 <benny99> so whatever I apply there, it simply returns x
06:09:19 <benny99> ie discards the result here
06:09:19 <nominolo> x >> y = x >>= \_ -> y
06:09:21 <benny99> ok, fine :)
06:09:26 <benny99> nominolo: thanks again :)
06:09:29 <Cale> Right, so it'll just ignore the result of the first computation
06:09:41 <Cale> and perform y no matter what
06:10:39 <vz> benny99: const is the "K" combinator, btw, I'm also learning haskell, and I find that I can't read a great deal of papers without knowing some of the combinators theory
06:10:40 <Cale> So, sequence takes a list of actions to be performed, and produces an action which performs each of them in order, producing a list of their results.
06:11:09 <Cale> So it's a very simple kind of loop.
06:11:22 <benny99> vz: I need some practice to understand theory :P
06:11:26 <Cale> I'll write it:
06:11:34 <Cale> sequence [] = return []
06:11:54 <Cale> sequence (x:xs) = do { v <- x; vs <- sequence xs; return (v:vs) }
06:12:02 <Cale> Or, to desugar that:
06:12:20 <Cale> sequence (x:xs) = x >>= \v -> sequence xs >>= \vs -> return (v:vs)
06:12:30 <benny99> vz: thanks for your info anyway :)
06:13:24 <vz> benny99: ok, let's just follow Cale's great examples :)
06:13:25 <benny99> guess I got it, lemme mess around a bit with that :)
06:13:35 <benny99> vz: :]
06:13:49 <Cale> (I think the do-notation is clearer here)
06:14:06 <benny99> there are both pretty similar to me now =)
06:14:11 <benny99> they're
06:14:44 <Cale> So when sequence is given the list whose first element is x and whose tail is xs, it runs x, capturing the result in v, then it sequences the rest of xs, capturing the results in vs, and then returns the list (v:vs)
06:15:06 <Cale> More precisely, it gives the action which does that when run.
06:15:10 <benny99> yeah :)
06:15:44 <vz> Cale: can we say that sequence is analogues to foldr1 (>>=) list ?
06:15:54 <Cale> sort of
06:15:54 <benny99> sequence [putStrLn "Hello", putStrLn "World"] <-- gives [IO (), IO ()] ?
06:15:56 <ndm> @src sequence
06:15:56 <lambdabot> sequence ms = foldr k (return []) ms
06:15:56 <lambdabot>     where
06:15:56 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
06:16:05 <Cale> it's  foldr (liftM2 (:)) (return [])
06:16:30 <Cale> The @src command has lots of suboptimally-readable code in it.
06:16:36 <vz> Cale: ok :)
06:17:05 <Cale> (in particular, lots of the source that @src will give you contains performance hacks to get GHC to compile the code a bit better)
06:17:12 <Cale> (I really wish it didn't)
06:17:22 <ndm> Cale: src isn't compiled by GHC, is it?
06:17:34 <benny99> but the src is generated by GHC I guess
06:17:48 <Cale> I don't know how it was constructed. It seems to have the GHC implementations of lots of stuff.
06:17:49 <ndm> i was under the impression it was custom-written, since it doesn't look GHC-like in many cases
06:17:54 <Cale> ah, okay
06:17:57 <Saizan> benny99: [putStrLn "Hello", putStrLn "World"] :: [IO ()], sequence [putStrLn "Hello", putStrLn "World"] :: IO [()]
06:18:04 <benny99> doesn't GHC create .c files?
06:18:22 <Saizan> benny99: instead of a list of actions you get an action that returns a list
06:18:33 <Cale> benny99: If you're compiling with -fvia-C
06:18:45 <Cale> benny99: But it normally does native code generation.
06:18:53 <Cale> (I think?)
06:18:54 <benny99> Cale: cool, is that native one faster?
06:19:05 <Saizan> (yes, from 6.6.1)
06:19:22 <benny99> Saizan: an action, that returns a list?
06:19:36 <Cale> benny99: yeah, in that case, the list is kinda silly
06:19:43 <Cale> because it'll just be [(),()]
06:19:53 <Cale> but, say, if we had
06:20:01 <benny99> Cale: yeah, that's what I meant
06:20:03 <Cale> sequence [getLine, readFile "foo"]
06:20:21 <Cale> that'd return a list of strings, after getting a line from the user and reading the file "foo"
06:20:36 <MyCatVerbs> Hallo #haskell.
06:20:40 <Cale> hello
06:20:42 <benny99> hi
06:20:57 <Cale> benny99: You're comfortable with map?
06:21:08 <Cale> > map (+1) [1..5]
06:21:10 <lambdabot>  [2,3,4,5,6]
06:21:17 <benny99> Cale: hm, if I do "let x = sequence[putStrLn "Hello", putStrLn "World"]", x are two strings too ._.
06:21:19 <benny99> Cale: yeah, am
06:21:38 <Cale> If you do  let x = sequence[putStrLn "Hello", putStrLn "World"], then x is an action.
06:21:39 <benny99> ah, wait no !
06:21:42 <benny99> yeah
06:21:44 <Cale> You haven't run x yet.
06:21:45 <benny99> exactly, sorry
06:22:31 <DukeDave> In record syntax is there a way to *not* name a part, e.g:
06:22:32 <DukeDave> "Alternatively, it's far simpler for us to plant the seed that all beancounters are secretly perverts with a fetish for donkeys."
06:22:37 <DukeDave> Whoops :)
06:22:38 <benny99> Cale: ok, perfect :)
06:22:48 <DukeDave> data Tasty = Cake {name :: String, Int} | Pie {name :: String}
06:22:53 <Cale> benny99: I take it you learned about the 'map' function already?
06:23:05 <benny99> Cale: yeah, did
06:23:08 <Cale> okay
06:23:17 <benny99> Cale: and fold etc., I should be familiar with them
06:23:17 <Cale> so with map and sequence, we can write a loop
06:23:27 <benny99> Cale: wait
06:23:33 <benny99> Cale: is that a neat exercise?
06:23:39 <Cale> sure, you can try it :)
06:24:51 <benny99> Cale: if you tell me what kind of loop :-[
06:24:55 <Cale> okay
06:25:38 <Cale> It's a foreach loop. It takes a list, and a loop body. A loop body is a function which takes an element and gives an action to be performed based on it.
06:26:06 <benny99> Cale: foreach list fn = ... ?
06:26:09 <Cale> yep
06:26:21 <fasta> DukeDave: yes
06:26:25 <benny99> Cale: and it returns ?
06:26:35 <Cale> an action which performs the loop
06:26:39 <benny99> Cale: a new list ?
06:26:56 <benny99> ok, but the action
06:26:56 <dons> http://programming.reddit.com/info/28xdp/comments/c28zc7 is an interesting discussion from the #22 icfp team
06:26:57 <Cale> returning a list of the results of each loop body execution
06:26:57 <lambdabot> Title: cashto does the ICFP contest (a post-mortem) (reddit.com)
06:27:06 <benny99> Cale: ok :), thanks
06:28:03 <Cale> benny99: want the type?
06:28:18 <benny99> :t foreach
06:28:20 <lambdabot> Not in scope: `foreach'
06:28:24 <benny99> Cale: yeah :)
06:28:50 <Cale> foreach :: [a] -> (a -> IO b) -> IO [b]
06:29:03 <benny99> ok :)
06:29:29 <Cale> :t forM
06:29:31 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
06:29:42 <benny99> later :-[
06:29:53 <benny99> I'll do that foreach first
06:30:00 <Cale> hehe, I wish I could give a parameter to :t to tell it to tone down the verbosity :)
06:30:18 <benny99> Cale: lambdabot is opensource I guess ;P
06:30:25 <Cale> the "forall a (m :: * -> *) b." is ignorable
06:30:44 <nopcode> Cale: i actually just pasted that reply line to another channel to scare people away from haskell
06:30:46 <benny99> Cale: sorry, I'll take a look at that later, I want to solve that exercise first now ;)
06:30:47 <nopcode> ;)
06:30:56 <Cale> nopcode: hehe
06:30:58 <SamB> you want something like -fno-glasgow-exts ?
06:31:09 <SamB> there is no such flag, afaik
06:31:32 <Cale> SamB: well, you could presumably avoid passing it to ghci if you wanted :)
06:31:40 <Cale> (-fglasgow-exts)
06:31:55 <SamB> yeah
06:32:06 <Cale> Also, you could just parse the forall and chop it off.
06:32:08 <SamB> I said that badly
06:32:34 <SamB> I should have said (there really isn't any such flag, afaik, but it expresses the intent well enough ;-)
06:34:52 <benny99> Cale: don't expect me to answer fast, I'm very slow at parsing problems...
06:35:17 <benny99> Cale: I still try to understand what it's supposed to do -- get a coffee or something ;)
06:36:02 <fasta> Cale: there is such an option now.
06:36:07 <fasta> Cale: but not in lambdabot
06:36:14 <fasta> Cale: I asked for it in ghc and they implemented it
06:36:27 <SamB> fasta: does -fglasgow-exts reverse it?
06:36:28 <fasta> SamB: you are wrong.
06:36:32 <fasta> SamB: no
06:36:46 <SamB> then it isn't the -fno-glasgow-exts I meant!
06:37:18 <Cale> benny99: that's cool :)
06:37:18 <fasta> SamB: Did I say it was?
06:37:36 <Cale> benny99: I hadn't originally intended it as an exercise, but it does make a pretty good one :)
06:37:49 <fasta> If you want to scare people, it's better to paste 4 pages of error output.
06:38:13 <fasta> Throw in ContT, some missing instances, MonadFix and you are all set.
06:38:15 <SamB> it's not actually called -fno-glasgow-exts is it?
06:38:16 <benny99> Cale: how is that function different from the map ?
06:38:30 <Cale> benny99: The map will produce a list
06:38:31 <fasta> SamB: no
06:38:39 <SamB> because, if it is, I'm going to petition to have it renamed and proper -fno- options be implemented ... oh good
06:38:47 <fasta> SamB: -fnoprint-explicit-foralls
06:38:55 <SamB> fasta: ahh
06:38:57 <Cale> benny99: this will produce an action (which when run will produce a list)
06:38:57 <fasta> SamB: cannot be more explicit (pun intended)
06:38:57 <benny99> Cale: and this is meant to create an action ?
06:39:07 <Cale> yep
06:39:11 <benny99> Cale: ._. ook...
06:39:12 <SamB> fasta: that only removes the redundant ones I hope?
06:39:27 <benny99> Cale: sorry, solving that is probably easy, but understanding what to solve is always hard :<
06:39:29 <fasta> SamB: I don't know what you mean by "redundant"
06:39:35 <SamB> fasta: the ones at the left
06:39:37 <Cale> benny99: remember that sequence turns a list of actions into an action of lists
06:39:52 <fasta> SamB: do you thing m:: * -> * is redundant?
06:39:56 <fasta> SamB: think*
06:40:05 <fasta> SamB: otherwise the answer is yes
06:40:18 <benny99> Cale: yeah, that's not the problem
06:40:22 <SamB> hmm, I don't know if m :: * -> * is redundant
06:40:27 <fasta> SamB: I don't know whether it does any extensive analysis.
06:40:37 <SamB> I expect it is
06:40:43 <fasta> SamB: I don't care, since I am not a heavy user of that.
06:40:46 <Cale> benny99: okay, so what would you get if you applied the supplied function to every element of the supplied list?
06:41:00 <fasta> SamB: The kinds were messing up my screen and they annoyed me.
06:41:06 <fasta> SamB: so, I am happy :)
06:41:24 <benny99> Cale: a list like [fn first, fn second, fn third...]
06:41:25 <fasta> SamB: it's a UI improvement.
06:41:43 <Cale> benny99: right, and what type of thing is (fn first) ?
06:42:03 <benny99> IO *
06:42:07 <Cale> right
06:42:21 <Cale> so you'd have a list of actions
06:42:41 <benny99> Cale: so fn is supposed to be an action, too ?
06:42:58 <Cale> fn takes a value and produces an action
06:43:03 <benny99> ok
06:43:19 <Cale> For example, (\x -> print x)
06:43:20 <benny99> I'm really bad at theory :(, sorry, I'll try
06:43:48 <Cale> or putStrLn, for that matter
06:44:06 <Cale> It takes a string, and produces an action for printing that string on the screen
06:44:20 <benny99> Cale: yeah, understood that part already :p
06:44:52 <Cale> So it could act as our "loop body"
06:45:14 <Cale> foreach ["Hello", "World"] putStrLn
06:45:28 <Cale> would print "Hello" and "World" on separate lines :)
06:45:44 <MyCatVerbs> :t foreach
06:45:52 <lambdabot> Not in scope: `foreach'
06:46:03 <Cale> MyCatVerbs: It's an exercise
06:46:13 <benny99> Cale: and foreach must use map and sequence ?
06:46:17 <Saizan> if i'm binding to a C function that takes Foo **var as a parameter i should pass it a (Ptr (Ptr Foo))?
06:46:22 <Cale> MyCatVerbs: The one in the libraries is called forM and it's in Control.Monad
06:46:28 <Cale> benny99: yep
06:46:37 <benny99> Cale: ok... lemme try again
06:47:30 <Cale> benny99: If you want, I can just show you -- it's one of those things which is easy once you know it, but maybe tricky beforehand :)
06:48:45 <benny99> Cale: no, please don't show me
06:49:04 <benny99> Cale: it's not hard for sure
06:49:29 <benny99> Cale: got it
06:49:33 <Cale> :)
06:50:03 <benny99> Cale: sorry, am just bad at getting what those functions are supposed to do :-[
06:50:23 <benny99> Cale: foreach l fn = sequence (map fn l)
06:50:23 <Cale> benny99: Well, you've just never used anything like them before
06:50:27 <Cale> exactly
06:50:39 <benny99> Cale: I guess so, "action" is a new term :/
06:50:55 <benny99> Cale: I used map often before
06:51:17 <benny99> Cale: and Haskell is not my first programming language btw.
06:51:22 <Cale> Most other languages don't have actions as first class values, so you wouldn't be used to passing them around.
06:51:32 <benny99> Cale: I'm not
06:52:04 <Cale> It's really satisfying to be able to invent the control structures you want on the spot though.
06:52:12 <benny99> Cale: (hm, is it possible to make that point-free?)
06:52:30 <benny99> guess so, one of the things why I learn haskell I guess :)
06:52:33 <fasta> Cale: I don't think Haskell has this feature.
06:52:37 <Cale> Well, yes, but it's easier with "mapM", which is just that with the parameters flipped
06:52:41 <Cale> (so the list is second)
06:52:50 <Cale> mapM f = sequence . map f
06:52:55 <Cale> or
06:52:59 <fasta> Cale: Show how to implement break, without using a runCont
06:53:01 <Cale> mapM = (sequence .) . map
06:53:01 <benny99> (list second appears more natural, since map is)
06:53:04 <benny99> Cale: no :'(
06:53:10 <benny99> Cale: you destroyed that exercise ;)
06:53:23 <Cale> hehe
06:54:38 <Cale> fasta: could you show what you mean?
06:55:00 <Cale> (not sure exactly what you're referring to)
06:55:20 * SamB likes being able to use datastructures instead of control structures
06:55:30 <Cale> SamB: that's awfully nice too :)
06:55:51 <fasta> Cale: I mean: do  a <- b ; break (aka abortive continuation); <never reach this>
06:55:53 <benny99> yeah, that data thingies are cute =)
06:56:05 <Cale> fasta: You could write the thing in CPS.
06:56:19 <benny99> Cale: is there no way to exclued the f also ?
06:56:28 <benny99> Cale: so you get "forach = ..."
06:56:43 <fasta> Cale: that's not a practical answer.
06:56:45 <Cale> foreach = flip ((sequence .) . map)
06:56:55 <fasta> Cale: I just run with_escape_continuation
06:57:44 <Cale> fasta: Oh, you mean something like storing a continuation in an IORef?
06:57:46 <fasta> Cale: I am not sure whether it is possible to do what I want with TH
06:58:08 <dons> @seen benl
06:58:09 <lambdabot> I haven't seen benl.
06:58:14 <Cale> er, that wouldn't be terribly useful, since you'd still have to pass it around :)
06:58:19 <fasta> Cale: no, I mean a transparant way to do what breaks do in imperative languages.
06:58:21 <benny99> Cale: ui ._.
06:58:44 <Cale> fasta: imperative languages stick callCC's around every function body and loop body.
06:58:50 <fasta> Cale: I know
06:58:57 <Cale> So you need Cont.
06:59:10 <fasta> Cale: Maybe Template Haskell can do it.
06:59:10 <Cale> or else just pass continuations around explicitly
06:59:16 <Cale> Oh, maybe
06:59:24 <Cale> benny99: sorry about that :)
06:59:27 <fasta> Cale: That would be an interesting blog post
06:59:40 <benny99> Cale: ._. sorry?
06:59:49 <fasta> benny99: for talking about continuations
06:59:54 <Cale> yeah :)
07:00:01 <fasta> benny99: and ignoring you for a few seconds
07:00:16 <benny99> Cale: yeah! I didn't allow you to! -- no, no problem :p
07:00:41 * benny99 turns of neon-sign
07:00:55 <Cale> hehe
07:01:15 <Cale> I'm just aware that beginners will tend to be afraid of continuation discussions :)
07:01:37 <fasta> Quite odd, since "return " is in every major programming language
07:02:11 <benny99> Cale: I didn't quite read what you wrote with fasta :-[
07:02:17 <benny99> to
07:02:18 <Cale> fasta: yeah, but those languages don't typically show you the continuation, they hide it on you.
07:02:28 <fasta> benny99: you can read it in a few years from now :)
07:02:33 <Cale> and just make 'return' and 'break' refer to the right one :)
07:02:34 <benny99> fasta: :'(
07:03:00 <fasta> benny99: Have you read SICP?
07:03:13 <benny99> Cale: flip ((sequence .) . map) kills me :(
07:03:17 <Cale> fasta: In fact, I was thinking about this just yesterday -- how strange it is that all these languages have call/cc essentially spliced in everywhere and nobody notices.
07:03:20 <benny99> fasta: SICP? no
07:03:31 <fasta> benny99: it's Scheme, but is a very nice way to be introduced to Haskell
07:03:34 <Cale> benny99: ah, it is quite awkward :)
07:03:40 <fasta> benny99: er to functional programming
07:03:44 <Cale> hehe
07:03:55 <Cale> Knowing Haskell and watching the SICP lectures is fun
07:03:59 <benny99> fasta: I don't want yet another language :-[, want to learn Haskell first now
07:04:11 <fasta> benny99: Scheme is far easier than Haskell
07:04:24 <benny99> fasta: yeah, but I want Haskell
07:04:25 <Cale> You see all the half-open problems from 20 years ago get turned into language features in Haskell.
07:04:36 <Cale> fasta: really?
07:04:43 <Cale> I'd say they're about the same.
07:04:50 <fasta> Cale: by easy, I mean less syntax.
07:05:02 <Cale> Haskell has easier to read syntax :)
07:05:10 <fasta> And arguably continuations in Scheme are easier than in Haskell
07:05:20 <benny99> Cale: flip ((sequence .) . map) <-- what the heck ? (.) combines two functions... that makes this... hm....
07:05:42 <fasta> benny99: that's a bit showing off
07:05:42 <Cale> benny99: well, flip f x y = f y x
07:05:52 <benny99> yep, know flip and .
07:05:58 <Cale> yes, I only write it because you asked for it :)
07:06:02 <Cale> wrote*
07:06:07 <benny99> they were in the "make fucntions point-free"-chapter in YAHT
07:06:18 <benny99> Cale: :-[ could you explain that to me?
07:06:27 <Cale> So after the flip, the function is first and the list second
07:06:35 <Cale> so...
07:06:48 <dolio> @remember qwe1234 ocaml really needs to do something about that garbage collector. the world doesn't need another java, especially one as complicated as ocaml is.
07:06:48 <lambdabot> Done.
07:06:56 <benny99> Cale: ah :O
07:07:02 <Cale> foreach list fn
07:07:04 <Cale> = flip ((sequence .) . map) list fn
07:07:04 <benny99> Cale: thought that was assumed anyway
07:07:13 <Cale> = ((sequence .) . map) fn list
07:07:38 <Cale> = (sequence .) (map fn) list
07:07:46 <Cale> = (sequence . map fn) list
07:07:55 <Cale> = sequence (map fn list)
07:08:05 <benny99> Cale: ok :-[
07:08:13 <Cale> In time, this sort of thing becomes more natural.
07:08:31 <benny99> (sequence .) is weird :(
07:08:31 <Cale> I wouldn't worry too much if it's not very clear.
07:08:34 <Cale> yeah
07:08:40 <Cale> oh
07:08:43 <Nopik> byorgey: hello ;)
07:08:45 <Cale> It's an operator section
07:08:45 <edwardk> benny: its an acquired taste
07:08:48 <Cale> like (5+)
07:08:53 <byorgey> hey there Nopik =)
07:08:57 <Nopik> byorgey: how was the dinner yesterday? :)
07:08:57 <Cale> > map (5+) [10,20,30]
07:09:05 <lambdabot>  [15,25,35]
07:09:05 <byorgey> Nopik: ah, it was excellent, thanks =)
07:09:07 <benny99> ok :]
07:09:09 <Cale> lambdabot here?
07:09:14 <Cale> ah
07:09:14 <Nopik> byorgey: good for you :)
07:09:27 <edwardk> @type (.)
07:09:28 <Cale> so (sequence .) f = (sequence . f)
07:09:28 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
07:09:31 <edwardk> @type (id .)
07:09:33 <lambdabot> forall b a. (a -> b) -> a -> b
07:09:46 <edwardk> @type (. id)
07:09:48 <lambdabot> forall c a. (a -> c) -> a -> c
07:09:56 <edwardk> @type (id . id)
07:09:57 <lambdabot> forall a. a -> a
07:10:02 <edwardk> see, just a section =)
07:10:08 <Cale> edwardk: that's got to be the least revealing example of the use of (.) :)
07:10:12 <edwardk> heh
07:10:25 <benny99> Cale: ah, got used to (. sequence) then I guess
07:10:39 <benny99> Cale: or is that different?
07:10:41 <byorgey> hm, less revealing would be to use ($) instead of id =)
07:10:46 <Cale> that's different,
07:10:47 <benny99> in this case
07:10:54 <Cale> (. sequence) f = (f . sequence)
07:10:55 <edwardk> byorgey: too many parens =)
07:11:11 <byorgey> edwardk: exactly!
07:11:18 <Cale> With (+) and (*), it doesn't matter, because they're commutative operators
07:11:20 <benny99> ah :)
07:11:23 <Cale> x + y = y + x
07:11:24 <benny99> ok, sorry
07:11:32 <Cale> but with (.), you have to be careful
07:12:12 <benny99> like with / and -
07:12:50 <Cale> yeah
07:12:54 <Nopik> byorgey: i think that i am getting some grasp on monads.. again ;)
07:13:04 <byorgey> Nopik: excellent!
07:13:10 <Cale> (.) is associative though, (f . g) . h = f . (g . h)
07:13:39 <benny99> ok :)
07:13:49 <Nopik> byorgey: though still i have about 5 documents to read.. when i read something, other document gets into queue ;p
07:13:55 <edwardk> Cale: toying with my prelude for a moment, wondering if Kleisli composition makes a better primitive than (>>=) (with (>>=) defined in terms of it by default like >> is defined now)
07:13:59 <byorgey> Nopik: story of my life =P
07:14:12 <Nopik> byorgey: hehe ;)
07:14:32 <benny99> Cale: ok, guess I bothered you enough for today ?
07:14:41 <Cale> benny99: It's fine :)
07:15:38 <benny99> Cale: I should read nominolo's tutorial page then I guess?
07:15:41 <Cale> edwardk: I suspect that for many monads, it's more complicated to define than (>>=) or join.
07:15:43 <benny99> Cale: or what is next :-[ ?
07:15:52 <Cale> benny99: Well, let's see...
07:15:53 <edwardk> cale: fair nuff
07:15:59 <Nopik> Nopik: test
07:16:12 <Cale> edwardk: but definitely include it -- you can provide mutual definitions
07:16:24 <dons> interesting comments at the end of the ocaml-icfp-contest blog, "Maybe Haskell is a better overall choice than ocaml indeed. Thanks to the negative experiences of this weekend, I am now seriously considering moving to Haskell, too."
07:16:27 <edwardk> cale: then i guess what i'll do is add it to the autodefine set, so you can define either one to get a sufficient definition
07:16:37 <Cale> edwardk: yeah
07:16:37 <edwardk> yep
07:16:45 <benny99> dons: wow ._.
07:16:49 <Cale> benny99: I should say something more about the bigger picture
07:17:06 <EvilTerran> how do nested unboxed pairs perform compared to one unboxed n-tuple?
07:17:35 <Nopik> Nopik: test
07:17:52 <Cale> benny99: IO is possibly the hardest monad to really understand well, because it has all sorts of stuff in it which many of the common monads don't. It's also primitive in the language, so you can't really see how >>= and return are implemented.
07:17:53 <Nopik> can someone tell something starting from Nopik: ?
07:17:58 <Nopik> please?
07:18:01 <byorgey> Nopik: like this?
07:18:05 <Cale> benny99: Most monads are just ordinary data structures.
07:18:06 <Nopik> byorgey: yes, thanks
07:18:13 <Nopik> test halfway passed
07:18:16 <benny99> Cale: like Maybe and [] ?
07:18:17 <Cale> and >>= and return are then just plain old functions
07:18:19 <edwardk> ok, next, a generic newtype for Functor composition like newtype O f g a = Comp { runComp :: f (g a) }     so you can say instance ... => Functor (f `O` g)      ? or is the O in that too kitchy and I should go with something boring like Comp or something =)
07:18:21 <Cale> benny99: exactly
07:18:54 <benny99> Cale: yep, that is what the wikibook also told me I guess
07:18:59 <Cale> benny99: If you want, you can imagine an (IO a) as being a sort of data structure holding a script of what that IO action will do.
07:19:05 <Cale> Like a block of code.
07:19:45 <Saizan> edwardk: can you really make a type constructor infix like that?
07:19:46 <Cale> But there's no way to take that block of code apart or inspect it in the case of IO.
07:20:06 <edwardk> saizan: yeah, it works
07:20:22 <EvilTerran> zh, never mind me, i'm talking nonsense...
07:20:24 <edwardk> or it did when i last tried around 6.4 or so
07:20:28 <Cale> benny99: If you'd like, we could take a closer look at, say, the list monad.
07:20:38 <Cale> benny99: I think it's a pretty nice example of a monad.
07:20:50 <benny99> Cale: ok :)
07:20:53 <Cale> In the list monad,  return x = [x]
07:20:54 <dolio> edwardk: I think Conal Eliot uses O in his type compose papers. I can't recall what it is in the library, though.
07:21:04 <Cale> and  x >>= f = concat (map f x)
07:21:21 <Cale> So, for example...
07:21:22 <edwardk> debating between O or some :. or :.: -like thing to indicate composition or something boring and prefix like Comp
07:21:35 <benny99> Cale: yeah, read that in the wikibook, too
07:21:36 <Cale> > [1,2,3] >>= \x -> [x,10*x]
07:21:38 <lambdabot>  [1,10,2,20,3,30]
07:21:53 <benny99> that is what I needed :)
07:21:59 <Cale> The list monad is really good for searching for things.
07:22:08 <Cale> We can define a function guard
07:22:26 <Cale> guard p = if p then return () else []
07:22:45 <Cale> guard just returns a list that looks like [()] when p is true
07:22:53 <Cale> and an empty list when p is false
07:23:26 <Cale> This has the effect of killing off branches of the computation when the condition fails... let me show what I mean
07:23:41 <Cale> > do { x <- [1,2,3]; y <- [1,2,3]; return (x,y) }
07:23:42 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
07:23:55 <Cale> > do { x <- [1,2,3]; y <- [1,2,3]; guard (x < y); return (x,y) }
07:23:56 <lambdabot>  [(1,2),(1,3),(2,3)]
07:24:23 <EvilTerran> > do { x <- [1,2,3]; guard (odd x); y <- [1,2,3]; return (x,y) }
07:24:25 <lambdabot>  [(1,1),(1,2),(1,3),(3,1),(3,2),(3,3)]
07:24:48 <Cale> Remember, in the list monad, "actions" are lists.
07:25:12 <Cale> and "running" a list is effectively selecting an element of it in all possible ways
07:25:22 <Cale> (one way at a time)
07:25:23 <magnus> > [1,2,3] >>= (\ x -> [1,2,3] >>= (\y -> guard (x < y) >>= (\ _ -> return (x,y))))
07:25:25 <lambdabot>  [(1,2),(1,3),(2,3)]
07:25:56 <Cale> If you know about list comprehensions, this is essentially the same thing
07:26:13 <benny99> return (x,y) is weird :-[
07:26:16 <Cale> > [(x,y) | x <- [1,2,3], y <- [1,2,3], x < y]
07:26:17 <lambdabot>  [(1,2),(1,3),(2,3)]
07:26:28 <benny99> yeah, know about them
07:26:32 <Cale> return (x,y) just means to put (x,y) in a singleton list
07:26:41 <Cale> that is, it's the same thing as [(x,y)]
07:26:44 <benny99> but is x not [1,2,3] ?
07:26:45 <magnus> do { x <- [1,2,3]; return (x,x) }
07:26:52 <magnus> > do { x <- [1,2,3]; return (x,x) }
07:26:54 <lambdabot>  [(1,1),(2,2),(3,3)]
07:27:02 <Cale> benny99: it acts like a bunch of nested loops
07:27:17 <magnus> > do { x <- [1,2,3]; [(x,x)] }
07:27:19 <lambdabot>  [(1,1),(2,2),(3,3)]
07:27:23 <Cale> benny99: when you do x <- [1,2,3], x is first bound to 1, and the computation continues
07:27:33 <|Jedai|> @pl \l -> flip map l . flip ($)
07:27:33 <lambdabot> (. flip id) . flip map
07:28:13 <Cale> and then it's bound to 2 and 3
07:28:22 <benny99> ._.
07:28:32 <Cale> and in each branch, some list elements might be built
07:28:49 <Cale> > do { x <- [1,2,3]; [x, 10*x] }
07:28:50 <lambdabot>  [1,10,2,20,3,30]
07:29:03 <benny99> yeah, that was perfectly clear
07:29:03 <Cale> > [1,2,3] >>= \x -> [x, 10*x]
07:29:04 <lambdabot>  [1,10,2,20,3,30]
07:29:09 <benny99> that too
07:29:27 <benny99> wait, no
07:29:30 <benny99> it was not :-|
07:29:46 <Cale> xs >>= f = concat (map f xs)
07:29:54 <|Jedai|> The results of the different runs are concatened
07:30:02 <benny99> now it is again
07:30:06 <Cale> :)
07:30:14 <benny99> somewhat :-[
07:30:18 <Cale> clear <- [False, True]
07:30:18 <jedai> return x = [x]
07:30:36 <mux> @src [] (>>=)
07:30:37 <lambdabot> m >>= k     = foldr ((++) . k) [] m
07:30:56 <benny99> guess I got it :-[
07:30:57 * EvilTerran ponders recursive types with flat runtime representations
07:31:18 <jedai> @src concatMap
07:31:18 <lambdabot> concatMap f = foldr ((++) . f) []
07:31:31 <Cale> benny99: Perhaps it's worth going through an example carefully
07:31:44 <Cale> [1,2,3] >>= (\x -> [x, x*10])
07:31:47 <benny99> but it gives me serious headache
07:31:57 <Cale> = concat (map (\x -> [x, x*10]) [1,2,3])
07:32:16 <Cale> = concat [[1,10],[2,20],[3,30]]
07:32:27 <Cale> = concat [1,10,2,20,3,30]
07:33:04 <Cale> But this isn't really how you think about it -- you just think of it as picking an element of the list
07:33:15 <jedai> Cale: = [1,10,2,20,3,30] without the concat rather (a typo)
07:33:15 <Cale> and binding it to x
07:33:17 <benny99> the last one is "= [...]" I guess ?
07:33:23 <Cale> er, yeah
07:33:24 <Cale> sorry
07:33:34 <Cale> forgot to erase the concat :)
07:33:34 <benny99> Cale: no problem, got it now, sorry for being that dumb :-[
07:33:55 <Cale> It's okay. This is pretty subtle
07:34:24 <benny99> whatever, you are explaining well :)
07:34:27 <Cale> > do { x <- [1,2,3]; y <- [4,5,6]; return (x,y) }
07:34:29 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
07:34:45 <Cale> So that's the list of all possible selections of x and y.
07:34:51 <benny99> got that now :)
07:35:06 <Cale> > do { x <- [1,2,3]; y <- [4,5,6]; guard (odd y); return (x,y) }
07:35:07 <lambdabot>  [(1,5),(2,5),(3,5)]
07:35:27 <benny99> though the do is confusing
07:35:35 <Cale> You can think of guard as causing backtracking to occur when the condition fails.
07:36:17 <Cale> benny99: It can get really confusing if you try to translate it all down rather than trying to see what the overall effect is.
07:36:32 <magnus> > [1,2,3] >>= (\x -> guard (odd x) >>= (\_ -> return x))
07:36:33 <lambdabot>  [1,3]
07:36:37 <benny99> Cale: without translating it all down I can't understand it :(
07:36:42 <Cale> The best approach is to understand small examples translated down
07:36:49 <Cale> and the bigger ones in abstract
07:36:58 <Syzygy-> [1,2,3] >>= (\x -> [4,5,6] >>= (\y -> guard (odd y) >>= (return (x,y))))
07:37:00 <Syzygy-> > [1,2,3] >>= (\x -> [4,5,6] >>= (\y -> guard (odd y) >>= (return (x,y))))
07:37:01 <lambdabot>  Couldn't match expected type `[b]' against inferred type `(a, b1)'
07:37:12 <Cale> Every time you have a >>=
07:37:14 <benny99> got it I guess :)
07:37:18 <benny99> yeah
07:37:20 <Cale> you have a map over possibilities
07:37:26 <Cale> and then a concat of the results
07:37:35 <benny99> yep
07:37:50 <Cale> So each line in the do block is introducing possibilities and combining the results.
07:37:57 <benny99> and this time it is [[1],[],[3]] etc.
07:38:04 <benny99> [1,3] then
07:38:09 <Cale> yeah
07:38:13 <magnus> > guard False
07:38:13 <lambdabot>   add an instance declaration for (Show (m ()))
07:38:33 <magnus> > (guard False) :: [Int]
07:38:34 <lambdabot>  Couldn't match expected type `Int' against inferred type `()'
07:38:35 <Cale> if an empty list gets returned, that branch doesn't continue on, because the concat kills empty lists off
07:38:43 <magnus> > (guard False) :: [()]
07:38:44 <lambdabot>  []
07:38:50 <magnus> > (guard True) :: [()]
07:38:52 <lambdabot>  [()]
07:39:12 <benny99> ok :)
07:39:25 <Cale> > do { x <- [1,2,3]; [(),()]; return x }
07:39:27 <lambdabot>  [1,1,2,2,3,3]
07:39:45 <psykotic> :t guard
07:39:47 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
07:39:57 <psykotic> whew, for a second i thought it used fail
07:40:04 <Cale> :)
07:40:05 <magnus> psykotic: me too
07:40:21 <Cale> thankfully we still have some standards :)
07:40:35 <psykotic> cale: there are still a lot of standard functions contaminated with fail though.
07:40:40 <psykotic> cale: like Map.lookup, iirc
07:40:47 <Cale> psykotic: yeah. It's awful :(
07:40:54 <psykotic> :t lookup
07:40:55 <fasta> Cale: ?
07:40:56 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
07:41:04 <fasta> Cale: why is that awfull?
07:41:08 <psykotic> well, not that one. must have had something else in mind.
07:41:08 <magnus> :t Map.lookup
07:41:10 <lambdabot> Couldn't find qualified module.
07:41:16 <magnus> :t Data.Map.lookup
07:41:18 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
07:41:23 <psykotic> magnus, ah yes.
07:41:27 <psykotic> it's an abomination.
07:41:27 <fasta> awful*
07:41:30 <magnus> Let's not interrupt benny99's class now :)
07:41:33 <Cale> fasta: fail is an abomination. It confuses the idea of a monad, giving people the impression that there has to be a way to fail.
07:41:34 <fasta> psykotic: and why is that?
07:41:35 <psykotic> sorry.
07:41:35 <benny99> :-[
07:41:55 <psykotic> fasta: fail has a standard implementation in most monads that just bombs out at runtime.
07:42:01 <Cale> Also, it's usually implemented by crashing the program.
07:42:05 <Cale> yeah
07:42:09 <psykotic> fasta: in cases like Map.lookup, it should be MonadPlus, not Monad, for that reason.
07:42:10 <Cale> hehe, stereo
07:42:30 <mux> that's haskell' material
07:42:37 <psykotic> anyway, sorry, carry on the lesson. :)
07:42:47 <benny99> magnus: if you don't want to interrupt my class you would have to wait about 3 hours :P
07:43:03 <benny99> :-[
07:43:15 <magnus> benny99: I'm learning from it too
07:43:16 <fasta> psykotic: Ok, I didn't thought about that, that much, but I use fail in my code too in combination with runMaybeT to get rid of nested code.
07:43:19 <benny99> Thanks for the lesson btw. to all of yours :)
07:43:30 <Cale> benny99: You're quite welcome
07:43:44 <psykotic> fasta: you can just lift mzero?
07:43:48 <mux> Haskell, spread the love
07:43:57 <Cale> The hope is that by teaching people lots, we eventually end up with lots of teachers :)
07:44:00 <fasta> psykotic: I can write do x <- find_some_element_that_might_not_exist; do_something_with_x x
07:44:01 <psykotic> fasta: you can even have an automatic lifting of mzero whenever the "inner" monad is an MonadPlus.
07:44:19 <benny99> Cale: that last one still kills me...
07:44:32 <Cale> > do { x <- [1,2,3]; [(),()]; return x }
07:44:33 <lambdabot>  [1,1,2,2,3,3]
07:44:36 <Cale> this one?
07:44:37 <psykotic> fasta: i don't see why you need fail there.
07:44:47 <dons> yeah, cheers for Cale and his tutoring :D thanks Cale.
07:44:47 <fasta> psykotic: ok, so you say I should replace fail with lift mzero everywhere?
07:44:49 <benny99> Cale: yeah :(
07:44:59 <Cale> benny99: okay, so let's pick it apart
07:45:02 <magnus> > do { x <- [1,2,3]; _ <- [(),(),()]; return x }
07:45:03 <lambdabot>  [1,1,1,2,2,2,3,3,3]
07:45:13 <fasta> psykotic: ok, that doesn't sound like a bad idea.
07:45:26 <Cale> benny99: if you stick a y <- ... before, does it make more sense?
07:45:35 <psykotic> fasta: you should be able to just use mzero, i think, if there's an appropriate conditional MonadPlus implementation. something like... instance MaybeT (MonadPlus a) => MonadPlus (MaybeT ...) whatever
07:45:41 <Cale> (kinda like magnus did)
07:45:44 <benny99> Cale: no :(
07:45:46 <Cale> okay
07:45:50 <psykotic> fasta: i messed up the ordering of params to the MaybeT but you can do automatic lifting like that.
07:45:55 <EvilTerran> > > do { x <- [1,2,3]; y <- [(),(),()]; return (x,y) }
07:45:55 <lambdabot>  Parse error
07:46:00 <EvilTerran> > do { x <- [1,2,3]; y <- [(),(),()]; return (x,y) }
07:46:01 <lambdabot>  [(1,()),(1,()),(1,()),(2,()),(2,()),(2,()),(3,()),(3,()),(3,())]
07:46:09 <EvilTerran> > do { x <- [1,2,3]; y <- [ 1, 2, 3]; return (x,y) }
07:46:11 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
07:46:12 <psykotic> fasta: it breaks down when you have a stack containing multiple versions of the same monad, but that rarely happens.
07:46:19 <benny99> ._. I feel so damn dumb now :-[
07:46:27 <mauke> > do { x <- [1,2,3]; y <- "abc"; return (x,y) }
07:46:28 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
07:46:32 <mauke> it's just a nested for loop
07:47:14 <fasta> psykotic: I haven't seen that particular instance in MaybeT anywhere.
07:47:19 <Cale> Should I break it down in terms of bind?
07:47:26 <EvilTerran> for (x in [1,2,3]) { for (y in [(),(),()]) { yield x } }
07:47:28 <benny99> Cale: yeah :-[
07:47:31 <Cale> okay
07:47:32 <magnus> for each x in [1,2,3] { for each y in [(),()] { yield x } }
07:47:37 <benny99> Cale: but I guess it would not help that much :(
07:47:39 <magnus> haha EvilTerran :)
07:47:42 <mauke> getAll hdl = unsafeInterLeaveIO $ liftM2 (liftM2 (:)) getOne getAll hdl  -- does this make sense?
07:47:46 <psykotic> fasta: you can define it yourself. there should be some examples to go by for other monad transformers, i think. cale?
07:47:52 <EvilTerran> heh. great minds etc. even both used yield :D
07:48:01 <psykotic> cale: what are some good examples to look at for auto-lifting of operations in monad transformers?
07:48:05 <Cale> benny99: have you been looking at the examples that EvilTerran and magnus have been doing?
07:48:13 <benny99> yeah
07:48:24 <Cale> psykotic: I suppose look at the source for Control.Monad.State ?
07:48:38 <psykotic> fasta: there you go. and you should be able to do something similar for MaybeT if you want.
07:48:38 <benny99> [(),()] is no function or whatever  :(
07:48:40 <fasta> psykotic: didn't you mean instance Monad m => MonadPlus (MaybeT m)?
07:48:44 <mauke> (not sure if my use of unsafeInterleaveIO is ok)
07:48:55 <psykotic> fasta: MonadPlus m, but yes
07:48:57 <mauke> benny99: no, <- is
07:49:04 <fasta> psykotic: ?
07:49:08 <mauke> benny99: well, and ; is
07:49:09 <benny99> I really don't get that one :(
07:49:12 <fasta> psykotic: The monadplus is not necessary, AFAIK.
07:49:15 <Cale> psykotic: http://darcs.haskell.org/packages/mtl/Control/Monad/State/Lazy.hs -- near the bottom
07:49:25 <Cale> benny99: it's a list
07:49:25 <EvilTerran> mauke, well, >>= is, but <- desugars to >>=
07:49:33 * SamB wishes Haskell had slightly better defaulting
07:49:33 <mauke> benny99: the magic is in the ;'s
07:49:36 <psykotic> fasta: maybe i don't understand what it is your trying, then.
07:49:37 <Cale> benny99: remember our 'actions' are lists
07:49:47 <benny99> Cale: yeah ._.
07:49:58 <Cale> benny99: and 'running an action' is 'picking an element of the list'
07:50:05 <SamB> (sufficient to allow printf to return IO () when returning an IO action)
07:50:18 <Cale> But when you just have an action on its own in a do-block, the result is thrown away
07:50:29 <benny99> gnah :|
07:50:30 <psykotic> cale:ì´ã„·ã„±ã„´
07:50:37 <psykotic> cale: cheers, even
07:50:43 <Cale> psykotic: I can't read korean :)
07:50:44 <SamB> > do "hi!"
07:50:45 <lambdabot>  "hi!"
07:50:48 <Cale> psykotic: hehe
07:50:54 <SamB> Cale: o rly?
07:50:55 <psykotic> cale: modal keymaps = the suckage
07:51:02 <EvilTerran> > do "hi"; "there"
07:51:03 <lambdabot>  "therethere"
07:51:05 <Cale> So the effect is that we pick an element of [(),()] in all possible ways, we're taking two branches
07:51:11 <SamB> psykotic: really?
07:51:18 <benny99> EvilTerran: now I'm dead :(
07:51:24 <SamB> I can see that this is true in certain cases...
07:51:27 <fasta> I need (MonadPlus (ST s)) when I do that.
07:51:39 <Cale> benny99: maybe this will make sense....
07:51:45 <EvilTerran> > do x <- "hi"; y <- "there"; (x,y)
07:51:46 <lambdabot>  Couldn't match expected type `[t]' against inferred type `(a, b)'
07:51:46 <magnus> > "hi" >>= (\_ -> "there")
07:51:48 <lambdabot>  "therethere"
07:51:51 <EvilTerran> > do x <- "hi"; y <- "there"; return (x,y)
07:51:52 <psykotic> samb: well, it's probably needed, but it's annoying when you accidentally turn it on :)
07:51:52 <lambdabot>  [('h','t'),('h','h'),('h','e'),('h','r'),('h','e'),('i','t'),('i','h'),('i',...
07:51:55 <Cale> eek
07:52:01 <SamB> oh, btw, does anyone know how to infringe on the one-hand patent using X?
07:52:04 <SamB> I want to try that
07:52:12 <psykotic> SamB, wtf?
07:52:16 <Cale> > do { x <- [1,2,3]; y <- [4,5,6]; return (x,y) } -- benny99 did you get this one?
07:52:17 <mauke> > do tmp <- ['h', 'i'];  x <- ['t', 'h', 'e', 'r', 'e']; return x
07:52:18 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
07:52:19 <lambdabot>  "therethere"
07:52:33 <benny99> Cale: guess not
07:52:34 <Cale> benny99: perhaps we should go to #haskell-overflow :)
07:52:37 <benny99> Cale: thought I did
07:52:39 <SamB> JohnMeacham has a one-hand typing patch for the Linux kernel, but apparantly it infringes on a patent
07:52:45 <benny99> Cale: :P
07:52:48 <SamB> so he had to rot13 it
07:52:51 <fasta> Uhm, why is there no MonadPlus (ST s)?
07:53:01 <Cale> benny99: just because the channel is getting hard to follow
07:53:06 <SamB> I'm wondering how you'd infringe on the patent using X instead of the console
07:53:14 <matthew-_> SamB: rot13 is an adequate solution?
07:53:17 <psykotic> fasta: there's a MonadPlus implementation for ErrorT
07:53:28 <SamB> matthew-_: to what?
07:53:29 <psykotic> fasta: doesn't ST provide ErrorT?
07:53:39 <SamB> to annoying companies bugging you about patents?
07:53:42 <SamB> perhaps!
07:53:45 <matthew-_> SamB: not in fringing the patent
07:53:52 <SamB> of course not
07:53:58 <EvilTerran> matthew-_, yes, but it puts rot13.com et al in the firing line of the DCMA ;]
07:53:59 <matthew-_> oh good
07:54:02 <fasta> psykotic: not AFAICS
07:54:02 <EvilTerran> (i kid)
07:54:22 <matthew-_> I'm glad the USPO isn't quite that stupid
07:54:22 <EvilTerran> (also s/DCMA/DMCA/, of course)
07:54:24 <matthew-_> oh wait...
07:54:36 <SamB> http://repetae.net/john/computer/hk/
07:54:44 * matthew-_ sends his next cheque to the EFF
07:55:05 <psykotic> fasta: oh, you mean an instance for MonadPlus ala the one for StateT in that code cale just posted?
07:55:09 <SamB> it doesn't circumvent any copyprotection mechanisms
07:55:19 <fasta> psykotic: I didn't see Cale's code
07:55:23 <SamB> you could violate their patent from just reading their website
07:55:34 <fasta> psykotic: I just say that I don't have an instance MonadPlus (ST s)
07:55:37 <psykotic> fasta: http://darcs.haskell.org/packages/mtl/Control/Monad/State/Lazy.hs
07:55:45 <SamB> (and coding up something that implements what they describe on it)
07:55:49 <psykotic> fasta: search for "Instances for other mtl transformers"
07:56:19 <matthew-_> "its very impressive to outsiders when your touch typing away and suddenly you take one hand off the keyboard to take a sip of coke and you don't even miss a beat!"
07:56:20 <matthew-_> neat
07:56:46 <cperfumo> does anyone know one channel where I can ask about itanium assembly?
07:56:49 <matthew-_> I like the implicit elitism in there - the "outsiders"
07:57:20 <SamB> well, presumably it means people who don't actually know him
07:57:45 <SamB> because those that do might be somewhat less impressed, knowing how it works
07:58:00 <fasta> psykotic: I implemented instances for my own monad transformers already. I am not sure why you sent that link.
07:58:13 <MyCatVerbs> matthew-_: I don't see it.
07:58:16 <fasta> psykotic: I just don't understand why there is no MonadPlus (ST s) instance already.
07:58:30 <MyCatVerbs> matthew-_: "Think more, write less." Why're you constantly typing in the first place?
07:58:38 <psykotic> fasta: okay.
07:58:43 <SamB> fasta: why would there be?
07:58:52 <MyCatVerbs> matthew-_: really, you want to be spending about five minutes meditating and thirty seconds screaming at your keyboard instead.
07:58:52 <SamB> how do you implement them?
07:58:59 <dolio> ST isn't a transformer.
07:59:01 <SamB> er. it.
07:59:12 <psykotic> dolio: it is, just not a monadic one :)
07:59:26 <matthew-_> MyCatVerbs: right, it might be more useful when writing in "noisier" language - Java eg
07:59:32 <dolio> Well, yeah.
07:59:35 <SamB> > fail "ack!" `mplus` putStrLn "hi!"
07:59:36 <matthew-_> for Haskell, most "coding" time tends to be thinking
07:59:37 <lambdabot>  <IO ()>
07:59:45 <SamB> for some reason IO has one
08:00:10 <MyCatVerbs> matthew-_: also, much as I'd love to try that, they ban food+drink in the labs here to stop people making the computers fucking filthy. :)
08:00:21 <matthew-_> heh
08:00:35 <matthew-_> MyCatVerbs: yeah, same at Imperial. Didn't stop us though
08:00:58 <SamB> but I don't think ST supporst exceptions
08:01:09 <fasta> psykotic: you claiming "fail is bad", implies MonadPlus (ST s) should exist.
08:01:39 <fasta> psykotic: since when I replace fail "foobar" with lift mzero as you said, I need that instance in my code.
08:01:48 <magnus> > do 1
08:01:49 <lambdabot>   add an instance declaration for (Num (t t1))
08:01:50 <lambdabot>     In the expression: 1
08:01:50 <lambdabot>     I...
08:02:20 <magnus> > do Nothing
08:02:21 <lambdabot>  Nothing
08:02:21 <psykotic> fasta: you can't use lift mzero in that case.
08:02:26 <MyCatVerbs> matthew-_: Imperial? That in London?
08:02:32 <matthew-_> MyCatVerbs: yep
08:02:34 <psykotic> fasta: earlier you didn't say you were talking about ST. in that case, i think using fail is indeed very bad.
08:02:42 <matthew-_> MyCatVerbs: Imperial College, London
08:02:44 <MyCatVerbs> Holy fuck. Gahhh.
08:02:46 <SamB> magnus: though the report doesn't say you can't do that, most implementations seem to require do blocks to be of monadic type
08:03:06 <psykotic> fasta: don't work with ST directly if you need error handling, wrap an error monad around it and report errors using that.
08:03:10 <MyCatVerbs> Annoying how you can get used to having a half a second's worth of sleep while waiting for your program to compile on a secondhand P2.
08:03:16 <fasta> psykotic: you think using fail is very bad?
08:03:24 <fasta> psykotic: I am using runMaybeT
08:03:27 <MyCatVerbs> And then move the code to a P4 box and all of a sudden your micro-naps disappear. :(
08:03:30 <fasta> psykotic: to, that's your error monad
08:03:34 <fasta> psykotic: so*
08:03:39 <magnus> SamB: I see
08:03:49 <SamB> MyCatVerbs: you can alter /usr/bin/ghc-x.y
08:03:50 <fasta> psykotic: so, AFAIK, what I do is perfectly sane.
08:03:54 <SamB> insert a sleep call
08:03:55 <psykotic> fasta: so why can't you just lift mzero for code in your MaybeT (ST a) thing?
08:04:00 <SamB> ;-P
08:04:04 <psykotic> fasta: obviously you can't in code written only for ST a.
08:04:48 <fasta> psykotic: hmm, maybe some of it is already executed in ST. (I do agree that's a bad idea)
08:05:04 <psykotic> so. if you have code that can't fail, you can write it in ST a, and lift it when needed.
08:05:12 <psykotic> for code that needs to handle errors, use MaybeT (ST a).
08:05:15 <cperfumo> does anyone know one channel where I can ask about itanium assembly?
08:05:22 <nopcode> cperfumo: rotfl
08:05:35 <SamB> tried ##asm?
08:05:42 <MyCatVerbs> SamB: heh. ^_^
08:05:56 <MyCatVerbs> SamB: I doubt I have room in my account to keep my own installed copy of ghc, though.
08:06:07 <SamB> MyCatVerbs: I'm pretty sure that file is a shell script
08:06:24 <MyCatVerbs> Oooh, there's a thought.
08:07:05 <MyCatVerbs> #!/bin/sh \n sleep 1 \n exec /usr/bin/gcc "$@"
08:07:11 <fasta> cperfumo: found NSA instructions ;)
08:07:13 <MyCatVerbs> Write that into ~/bin, and another copy for ghc
08:10:11 <AStorm> Hmm, is there some "text buffer" monad, that can be used as a replacement of Handle in file operations?
08:10:25 <AStorm> Or do I have to write one?
08:11:00 <AStorm> s/monad//
08:11:09 <AStorm> Just a text buffer, that has a Handle
08:12:10 <psykotic> like an mmapped file?
08:12:41 <fasta> What happens when you mmap a 100GB file?
08:12:48 <earthy> nothing much
08:12:52 <fasta> And read it sequentially
08:12:54 <AStorm> psykotic, much like it, but I can't mmap stdin ;P
08:13:07 <psykotic> fasta: it has to reserve virtual address space up front; it doesn't matter how you read it, it's going to bomb out at mmap() time.
08:13:08 <AStorm> I just want to grab a part of it into the buffer, and then operate on that
08:13:20 <earthy> exactly what psykotic says
08:13:40 <fasta> psykotic: ok, so it only works for < size memory files.
08:13:49 <psykotic> probably substantially < memory, yes
08:13:56 <fasta> How limited...
08:14:00 <fasta> And very C like...
08:14:00 <earthy>      [ENOMEM]           MAP_FIXED was specified and the addr parameter wasn't
08:14:00 <earthy>                         available.  MAP_ANON was specified and insufficient
08:14:00 <earthy>                         memory was available.
08:14:01 <psykotic> you could run on 64 bit :)
08:14:09 <nopcode> uhm
08:14:13 <nopcode> i just wanted to say that
08:14:17 <nopcode> who runs 32 bit anyways?
08:14:18 <pejo> fasta, < adress space rather, not size of memory.
08:14:20 <AStorm> So, any file-like memory buffer like it?
08:14:41 <AStorm> Though I can avoid it, probably
08:14:45 <earthy> mmap really is a way to have the pager read file contents for you
08:14:46 <psykotic> AStorm, unfortunately Handle isn't a type class, i think.
08:14:47 <AStorm> Just have to rethink the parser
08:14:52 <fasta> pejo: yes, but with 100GB and 8GB of memory it still crawls, AFAIU.
08:14:56 <psykotic> AStorm, i see what you're saying. if Handle were a type class, it would be easy.
08:15:04 <dylan_> AStorm: use a lazy String?
08:15:09 <earthy> so it is limited by memory and the pager's functioning
08:15:19 <AStorm> dylan_, almost, but that can't be read using normal IO
08:15:30 <pejo> fasta, it doesn't matter how you load data if it's larger than your primary memory. Do you relly need random access to all of the file?
08:15:33 <dylan_> normal IO is a lazy string. :)
08:15:46 <AStorm> dylan_, that's why it might work
08:15:51 <fasta> pejo: I was just wondering, I am not having an application right now.
08:15:58 <psykotic> AStorm, anyway, the short answer is: no.
08:16:01 <pejo> fasta, earthy explains it very well.
08:16:01 <AStorm> I have to rethink the parser a bit, so that it works line-wise
08:16:16 <psykotic> AStorm, Handle is an abstract data type, not a type class. if it were a type class (with exposed seekTo, read, write, etc functions) you could do this; but no.
08:16:36 <AStorm> Unfortunate
08:16:42 <AStorm> But then, I can do w/o that
08:17:05 <AStorm> just need to append to a ByteString
08:18:29 <AStorm> hmm, there's no chunked IO on handles, that makes my plan a bit harder to implement
08:20:09 <mauke> what's chunked IO?
08:20:15 <AStorm> mauke, e.g.
08:20:30 <AStorm> hGetBytes handl 1024
08:20:49 <mauke> @type hGetBuf
08:20:50 <AStorm> hGetBytes :: Handle -> Integer -> IO String
08:20:51 <lambdabot> Not in scope: `hGetBuf'
08:20:59 <AStorm> mauke, it uses some pointers, which is fugly :>
08:21:26 <mauke> no, pointers are good
08:21:49 <roconnor> free is bad?
08:22:31 <AStorm> mauke, I tell it that I want up to x data
08:22:40 <AStorm> I'd expect it to allocate enough space
08:22:45 <AStorm> (for slow, but easy, IO)
08:22:51 <mauke> hGetBytes hdl n = allocaBytes n >>= \ptr $ do g <- hGetBuf hdl ptr n; peekCStringLen (ptr, g)
08:22:59 <AStorm> hGetBuf is for harder, faster IO
08:23:07 <nopcode> lol
08:23:22 <nopcode> IO sure is an experience in haskell ^^
08:23:24 <AStorm> -> IO (String, Integer) should be
08:23:33 <psykotic> :t hGetNonBlocking
08:23:35 <lambdabot> Not in scope: `hGetNonBlocking'
08:23:44 <AStorm> hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
08:23:47 <psykotic> :t Data.ByteString.hGetNonBlocking
08:23:48 <lambdabot> GHC.IOBase.Handle -> Int -> IO Data.ByteString.Base.ByteString
08:23:56 <roconnor> @stereo
08:23:56 <lambdabot> Unknown command, try @list
08:24:08 <psykotic> AStorm, that's what you want.
08:24:21 <psykotic> AStorm, it's a lot like posix read(), in that it reads up to n characters (possibly less, if less are available).
08:24:46 <psykotic> i should say, nonblocking posix read()
08:24:55 <AStorm> psykotic, I know :-)
08:25:01 <AStorm> Should be enough for my needs then
08:25:18 <AStorm> Didn't think about looking into Data.ByteString for IO ops :P
08:27:11 <sjanssen> @quote zombie.*
08:27:11 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
08:27:20 <AStorm> hmm, will hGet block on EOF?
08:27:31 <AStorm> or just throw an exception?
08:29:41 <sjanssen> @hoogle hGet
08:29:41 <lambdabot> IO.hGetBuffering :: Handle -> IO BufferMode
08:29:42 <lambdabot> IO.hGetChar :: Handle -> IO Char
08:29:42 <lambdabot> IO.hGetContents :: Handle -> IO String
08:29:56 <sjanssen> AStorm: do you mean hGet from Data.ByteString?
08:30:47 <AStorm> sjanssen, yes
08:32:07 <sjanssen> AStorm: it returns as much data available before EOF
08:32:13 <sjanssen> no exceptions
08:32:39 <AStorm> mhm
08:32:44 <sjanssen> so, much like hGetBuf, you can check the length of the returned string to see whether you've hit EOF
08:33:09 <AStorm> I see, no problem with that (as it's blocking)
08:33:38 <sjanssen> it will still block if there is no data available, but EOF hasn't been reached
08:34:21 <AStorm> sjanssen, exactly what I want (stdin read)
08:35:01 <AStorm> but then, I still have a problem with some parsing - I have to grab a MessageID from an email (from stdin)
08:35:12 <AStorm> fetch the message from DB
08:35:23 <AStorm> pipe it through some command
08:35:33 <AStorm> grab the output of it
08:35:55 <AStorm> push x kB of the message through another command
08:36:07 <AStorm> grab the output
08:36:21 <AStorm> push the cached headers to stdout
08:36:28 <AStorm> add some more headers
08:36:40 <AStorm> push the data sent to the command
08:36:43 <AStorm> push the rest
08:37:43 <AStorm> the problem is that I have to hold the data in memory
08:38:02 <AStorm> though it should be possible to do with ByteStrings, why not
08:38:37 <AStorm> some proper do functions
08:45:18 <Nopik> bye all
08:51:23 <roconnor> Is there no function from Seq a -> [a]?
08:51:28 <roconnor> @hoogle Seq a -> [a]
08:51:29 <lambdabot> No matches, try a more general search
08:52:04 <earthy> Seq being Data.Sequence?
08:52:09 <roconnor> maybe I'm supposed to use traverse
08:53:02 <mauke> roconnor: toList
08:53:07 <mauke> it's in Data.Foldable
08:53:13 <roconnor> @type toList
08:53:15 <lambdabot> Not in scope: `toList'
08:53:19 <roconnor> @hoogle toList
08:53:20 <lambdabot> Data.HashTable.toList :: HashTable key val -> IO [(key, val)]
08:53:20 <lambdabot> Data.IntMap.toList :: IntMap a -> [(Key, a)]
08:53:20 <lambdabot> Data.IntSet.toList :: IntSet -> [Int]
08:53:27 <mauke> @type Data.Foldable.toList
08:53:29 <lambdabot> forall (t :: * -> *) a. (Data.Foldable.Foldable t) => t a -> [a]
08:53:37 <earthy> well, Data.Foldable.toList works indeed.
08:54:20 <earthy> Data.Foldable is cool
08:57:37 <wolverian> dons, hey, I have a minimal sample demonstrating System.Process.Run returning too early. want it?
08:58:06 <wolverian> dons, unfortunately it depends on you having mplayer, currently, so I guess it's not _quite_ minimal
09:02:09 <roconnor> is every Num a Monoid?
09:03:44 <dcoutts_> roconnor: nope
09:03:55 <dcoutts_> roconnor: just ask ghci, :info Num
09:04:11 <dcoutts_> its prerequisites are Show, Ord and Eq
09:04:29 <dcoutts_> erm, actually only Show and Eq
09:05:37 <roconnor> but we could have class (Num a) => Monoid a
09:07:01 <mauke> @instances Monoid
09:07:02 <roconnor> @pl (\a b -> (length a) + b)
09:07:02 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
09:07:02 <lambdabot> (+) . length
09:07:16 <roconnor> oh Sum
09:07:18 <byorgey> roconnor: you wouldn't want class (Num a) => Monoid a, that would require every Monoid to be a Num
09:07:29 <roconnor> er
09:07:35 <roconnor> instance (Num a) => Monoid a
09:07:41 <roconnor> but I guess we can't do that?
09:07:51 <byorgey> roconnor: you could
09:07:52 <mauke> not in H98
09:08:12 <byorgey> roconnor: but there are several possible ways to do it
09:08:15 <roconnor> Num a => Monoid (Sum a)
09:08:30 * shapr warbles
09:09:23 <byorgey> > mconcat . map Sum $ [1..10]
09:09:25 <lambdabot>  Sum {getSum = 55}
09:09:46 <roconnor> > getSum $ mconcat . map Sum $ [1..10]
09:09:48 <lambdabot>  55
09:11:59 <roconnor> :(
09:12:05 <roconnor>     No instance for (Num (Sum Int64))
09:12:20 <sjanssen> hmm
09:12:50 <roconnor> I need some flag at the to of my file?
09:13:22 <roconnor> top
09:13:55 <nominolo> :t Sum
09:13:57 <lambdabot> forall a. a -> Sum a
09:14:08 <nominolo> @index Sum
09:14:08 <lambdabot> bzzt
09:14:16 <doserj> yout want Num Int64, not Num (Sum Int64) probably?
09:14:18 <Saizan> ?docs Data.Monoid
09:14:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html
09:14:58 <roconnor> doserj: you are right
09:15:03 <roconnor> I must have a type error
09:15:39 <roconnor> fixed
09:20:51 <byorgey> @pl \x -> [x]
09:20:52 <lambdabot> return
09:21:08 <roconnor> Module `Data.Sequence' does not export `:<'
09:21:17 <roconnor> import Data.Sequence (ViewL, (:<))
09:21:24 <roconnor> :(
09:21:27 <roconnor> :<
09:23:35 <Cale> roconnor: import Data.Sequence (ViewL(..))
09:25:22 <roconnor> :>
09:32:35 <wolverian> dons, I modified the outer handler to print the error; it's "thread blocked indefinitely".
09:34:16 <wolverian> dons, er, sorry. the error is from the inner catch.
09:34:28 <wolverian> er
09:34:33 <wolverian> okay, I'm confused :)
09:38:21 <roconnor> short = (<1024)
09:38:21 <roconnor> long = not . short
09:38:47 <wolverian> dons, anyway, and easier program to test it with is e.g. 'tcprobe'. readProcess "tcprobe" ["-i", file] "" returns Left (ExitFailure 13), whereas running it from the commandline works fine.
09:41:05 <roconnor> I wish Seq and Bytestrings had a consistent interface ... maybe
09:41:50 <AStorm> Hmm, I wonder how to simulate a global variable in Haskell...
09:42:01 <AStorm> (yeah, I know it's sinful)
09:42:03 <wolverian> dons, mind you, I get similar behaviour with perl's IPC::Open2, so it's definitely something with the external process. hrm.
09:42:45 <roconnor> AStorm: it's easy
09:42:48 <roconnor> global = 12
09:42:59 <AStorm> roconnor, VARIABLE
09:43:04 <AStorm> not a constant :-)
09:43:12 <roconnor> Variables don't vary.
09:43:16 <AStorm> ...
09:43:22 <roconnor> ;)
09:43:30 <roconnor> @go Variables don't vary
09:43:32 <lambdabot> http://montague.stanford.edu/~dib/Publications/salt4.pdf
09:43:40 <roconnor> yesh
09:43:46 <roconnor> oh
09:43:49 <roconnor> @go Variables don't
09:43:50 <lambdabot> http://montague.stanford.edu/~dib/Publications/salt4.pdf
09:43:55 <roconnor> bah
09:44:02 <AStorm> this one does vary
09:44:16 <AStorm> it's an option flag
09:45:01 <roconnor> ah
09:45:05 <AStorm> I don't want to give each and every function using these an arg, because I'm lazy
09:45:11 <roconnor> There should be a wiki page on that
09:45:17 <byorgey> AStorm: use a State monad
09:45:25 <roconnor> use unsafePerformIO
09:45:33 <byorgey> roconnor: gah
09:45:39 <AStorm> roconnor, rotfl
09:45:51 <roconnor> @type unsafePerformIO
09:45:53 <AStorm> byorgey, hmm, much closer... let's see if it fits
09:45:54 <lambdabot> Not in scope: `unsafePerformIO'
09:45:56 <mauke> AStorm: you could use a Reader monad
09:45:59 <roconnor> @hoogle unsafePerformIO
09:45:59 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
09:46:16 <mauke> or the oleg trick of passing values through typeclasses
09:46:19 <roconnor> that's how I understand to do that
09:46:26 <mauke> where's that paper?
09:47:06 <AStorm> roconnor, not really
09:47:44 <AStorm> actually, the data is only modified once
09:47:54 <AStorm> could be recreated - I just need to bind to a global name
09:48:38 <byorgey> AStorm: sounds like you could also use a Reader monad
09:48:45 <AStorm> I just can't wrap my head around it it seems
09:49:13 <byorgey> AStorm: what is this data that needs to be modified?
09:49:31 <AStorm> it's a command-line flag, and I hate passing flag list around
09:49:51 <byorgey> AStorm: why does it need to change?
09:50:38 <AStorm> byorgey, it doesn't, though I have to access the value contained in the flag
09:50:47 <AStorm> so, it would be some kind of State
09:50:51 <wolverian> dons, actually, no, I don't get that behaviour from perl after all, so it is something to do with readProcess after all.
09:50:54 <mauke> Reader!
09:51:43 <AStorm> mauke, how do I unbox the value from it?
09:51:55 <mauke> x <- ask;
09:52:27 <twobitsp1ite> what's this I keep hearing about functional languages being easier to optimize?
09:52:33 <twobitsp1ite> I see it glossed over on LTU, but never in much depth
09:52:41 <AStorm> mauke, just that, hehe, hmm, should work
09:52:56 <AStorm> :t (<-)
09:52:56 <mauke> http://okmij.org/ftp/Haskell/types.html#Prepose
09:52:58 <lambdabot> Title: Haskell Programming: Types
09:52:58 <lambdabot> parse error on input `<-'
09:53:04 <AStorm> not an operator?
09:53:20 <mauke> AStorm: um, you should know the basics of monads if you want to use Reader
09:53:25 <AStorm> I know that
09:53:32 <AStorm> I didn't know it works on _all_ monads
09:53:37 <AStorm> hm.
09:54:06 <edwardk> twobitsp1ite: well, not necessarily functional languages as a whole, but ones that track side effects can be really useful for optimization because you can then reason about the absence of certain side effects while compiling
09:54:37 <twobitsp1ite> edwardk: I'm not sure I understand
09:55:25 <edwardk> if you want to get a good example, "deforestation" is a powerful rewriting technique that works in a setting where you can show the functions being passed in have no visible side effects.
09:55:43 <edwardk> how comfortable are you with the notion of mapping a function over a list?
09:55:44 <edwardk> i.e.
09:55:49 <edwardk> > map (+1) [1,2,3]
09:55:50 <lambdabot>  [2,3,4]
09:55:56 <twobitsp1ite> edwardk: very
09:56:30 <edwardk> well, if you were going to loop over it twice with two different functions you'd do something like map f (map g [...]) right?
09:56:50 <ddarius> @pl \xs -> map f (map g xs)
09:56:51 <lambdabot> map (f . g)
09:56:51 <twobitsp1ite> ahhhhh
09:56:59 <twobitsp1ite> I think I see where you are going with this..
09:57:00 <edwardk> well, if the functions f and g have no side effects, then it is always safe to change that pair of loops into a single loop map (f . g) [...]
09:58:42 <twobitsp1ite> so... assuming functional languages like haskell are easier to optimize than, i.e. C, why don't we see haskell out performing C in general?
09:58:57 <twobitsp1ite> just lack of aggressively optimizing compilers?
09:59:01 <edwardk> twobitsp1ite: because haskell pays a penalty for being lazy by default.
09:59:08 <twobitsp1ite> ahh
09:59:21 <dcoutts_> twobitsp1ite: because it's always possible to go as fast in a sufficiently low level language
09:59:37 <dcoutts_> so assuming a C coder with infinite patience, they can go at least as fast
09:59:39 <twobitsp1ite> dcoutts_: that makes a lot of sense
09:59:46 <andyjgill> Because we dont know where to optimize, and it is too expensive to (super)optimize everywhere
09:59:47 <edwardk> and you can always write c code that does what the haskell version did, it'll just have all of your concerns munged together in one loop
09:59:48 <dcoutts_> where we win is against average lazy C coders
09:59:50 <AStorm> mauke, I actually have the data in a monad - a list
09:59:56 <puusorsa> c is just assembler with nicer syntax
09:59:58 <twobitsp1ite> dcoutts_: I guess the real question is how much work does it take to do so..., right?
10:00:05 <AStorm> but I want to unpack this into some global names
10:00:17 <dcoutts_> twobitsp1ite: well I've been doing my PhD on that as have many people before me :-)
10:00:18 <andyjgill> With a bit of rewriting, Haskell can typically be about as fast at C
10:00:44 <dcoutts_> we can certainly kick Python and Java
10:00:51 <andyjgill> Nothing wrong with a PhD in Haskell optimizations
10:01:05 <dcoutts_> andyjgill: indeed :-)
10:01:21 <twobitsp1ite> andyjgill: you mean, strictness annotations, etc?
10:01:45 <dcoutts_> twobitsp1ite: and just thinking a bit about the lower level concerns
10:01:46 <andyjgill> Yes, and perhaps reworking inner loops, changing data structures.
10:02:01 <AStorm> mauke, notice word "global", as in "of module locality"
10:02:15 <twobitsp1ite> andyjgill: so, your typical optimizations, just as you would in the C world...
10:02:18 <edwardk> twobitsp1ite: http://neilmitchell.blogspot.com/search/label/supero is an example of a decent optimization technique that may work well in practice
10:02:19 <andyjgill> There was one system where a byte copy of bit data was using oveloading, and I changed it to use a ccall to memcpy.
10:02:20 <lambdabot> Title: Neil Mitchell's Haskell Blog: supero
10:04:02 <wolverian> dons, I found the problem. readProcess closes stderr early; if the program tries to write to it, it gets a bad file descriptor.
10:04:55 <edwardk> To me, the main benefit, speaking as someone who spent a lot of time staring at code for compilers for imperative languages, its a LOT more fun writing functional language compilers. =)
10:06:43 <edwardk> and having rock-solid control over side effects makes all of those 'ooh wouldn't it be nice if i could prove this property always held, then i could do that' passes downright easy
10:08:04 <magnus> how to convert from Int to Int64?
10:08:09 <mauke> fromIntegral
10:08:16 <edwardk> @type fromIntegral
10:08:18 <lambdabot> forall a b. (Num b, Integral a) => a -> b
10:08:33 <magnus> I'm already using it. I guess there's something else wrong in my program.
10:09:16 <magnus> found the problem..
10:09:49 <byorgey> AStorm: have you got it to work?  The stupid servers @ my workplace took a lunch break, so the network went down for a half hour.
10:10:06 <AStorm> byorgey, well, did it another way
10:10:12 <magnus> aah, my question is: how to convert from Int64 to Int
10:10:23 <byorgey> AStorm: how's that?
10:10:52 <byorgey> magnus: fromIntegral?
10:10:55 <AStorm> byorgey, I already have  a list, so just added some functions on it
10:11:12 <AStorm> one that will fetch the size from it, one that will fetch database name
10:11:19 <edwardk> I just found Dylan Thurston and CC Shan's infix expression trick. neat!
10:11:33 <AStorm> still, I'm probably dropping the whole program. Why use 2 programming langs when you can use one?
10:11:39 <AStorm> (CRM114 is quite fun)
10:12:02 <byorgey> AStorm: ok, then if you want, you could thread that list through everywhere you need it implicitly, using a Reader monad
10:12:13 <byorgey> AStorm: but maybe you already figured that out
10:12:48 <byorgey> edwardk: link?
10:12:49 <edwardk> infixr 0 -:, :-; data Infix f y = f :- y; x -: f :- y = x `f` y -- et voila, the language feature i've wanted just magically appears.
10:13:00 <edwardk> byorgey: lost the link, kept the code =)
10:13:23 <edwardk> use -: :-  like ` `'s around infixed code.
10:13:44 <byorgey> edwardk: ah, nifty.  so that lets you use arbitrary expressions as infix?
10:13:53 <edwardk> [1,2,3] -: zipWith (+) :- [4,5,6]
10:13:55 <edwardk> yeah
10:14:04 <byorgey> nice =)
10:14:05 <mauke> does it nest?
10:14:12 <opqdonut> it nests
10:14:27 <edwardk> they are infixr'd i don't see why not
10:14:51 <dolio> Ooo.
10:15:23 <edwardk> adding that to my toy prelude i think
10:15:40 <opqdonut> iirc that's possible even withot data Infix f y
10:16:31 <edwardk> probably, but that is still pretty clean
10:16:42 <opqdonut> yeah it is
10:17:12 <ddarius> edwardk: Yep it was on the old wiki.
10:17:20 <edwardk> ah
10:17:26 <ddarius> edwardk: Also you can do it easily without a data type.
10:17:51 <edwardk> i'll take an alternative implementation if you've got it
10:18:47 <ddarius> > let x -| f = f x; (|-) = id in [1,2,3] -| zipWith (+) |- [4,5,6]
10:18:55 <lambdabot>  [5,7,9]
10:19:06 <ddarius> Add some fixity declarations and you are set.
10:19:21 <edwardk> ah but there you lose the type safety of knowing you have matched -: :- pairs
10:19:51 <edwardk> hrmm, could newtype the result of -| i guess
10:20:00 <edwardk> or the other
10:20:18 <edwardk> then there would be no cost associated
10:21:41 <wli> I suspect wrapfix/outfix operators are more difficult.
10:21:56 <opqdonut> than what?
10:22:17 <wli> Not sure. I've never seen a trick for them.
10:23:08 <edwardk> i think the issue is they include symbols so they need to go into a section, which precludes most of the natural uses for them
10:23:25 <edwardk> and ( [ and { all have meanings already
10:23:35 <edwardk> so you have to outfix something that doesn't include those
10:23:53 <opqdonut> yeah -| |- and -: :- are quite clumsy
10:23:59 <opqdonut> just ` would be nicer
10:24:10 <ddarius> ` wouldn't allow nesting.
10:24:11 <opqdonut> is it planned for haskell prime btw?
10:24:22 <opqdonut> ddarius: hmm, true
10:24:30 <edwardk> those suck less than any others i've seen proposed in the quotation operator setting
10:25:58 <dolio> edwardk: Are you going to have idiom brackets, too? :)
10:26:17 <edwardk> eval <| some expression |> env    could be perfectly valid using that trick though, but you'd have to have 'env' =)
10:28:21 <roconnor> @hoogle join
10:28:24 <edwardk> and i guess there is no real benefit to that other than replacing ()'s
10:28:25 <lambdabot> Monad.join :: Monad a => a (a b) -> a b
10:28:25 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
10:28:25 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
10:28:25 <edwardk> bah
10:30:41 <hpaste>  mauke pasted "html-style circumfix" at http://hpaste.org/1861
10:30:47 <edwardk> dolio: not exactly something the prelude itself can provide. =/ as for my toy compiler, probably not. to me it seems more interesting to see if we can play with allowing rebindable application than idiom brackets
10:31:18 <edwardk> mauke: hahaha
10:31:31 <dolio> edwardk: Actually, Conor McBride showed how to write them in Haskell, similar to the -: :- trick you just showed. Let me find it...
10:32:24 <edwardk> ah found them
10:32:38 <edwardk> iI f x y Ii = f <$> x <*> y, etc.
10:32:43 <dolio> Right.
10:32:52 <dolio> A bit cryptic, perhaps.
10:33:06 <edwardk> yeah not so keen on the all alphanumeric brackets there
10:33:14 <edwardk> but i can see how there isn't an alternative
10:33:43 <opqdonut> yeah from the applicative paper
10:33:49 <dolio> Yeah, since they don't always go in the middle of larger expressions.
10:34:00 <opqdonut> iI Ii is supposed to look like [[ ]] i guess
10:34:31 <opqdonut> ?where applicative
10:34:31 <lambdabot> http://darcs.haskell.org/packages/base/Control/Applicative.hs
10:36:59 <TuringTest> If you have unicode you might use â… â† as brackets...
10:37:17 <TuringTest> Left / Right "SQUARE BRACKET WITH QUILL"
10:37:48 <mauke> not in my font :(
10:38:08 <olsner> pardon the language, but lol@unicode
10:39:27 <mauke> I ï¿½ Unicode!
10:39:46 * TuringTest does not have that character in font...
10:39:57 <mauke> I bet you do
10:40:26 <sjanssen> mauke: it should be a box with a question mark shaped hole in it?
10:40:28 <TuringTest> A solid diamond with a question mark cut out?
10:40:33 <mauke> yes
10:40:43 <mauke> it's U+FFFD (0xef 0xbf 0xbd): REPLACEMENT CHARACTER
10:40:58 <TuringTest> very sneaky....I ike that
10:42:40 <matthew-_> did you just specify an unbound variable as a unicode charactery?
10:42:48 <matthew-_> err, -y and + ;)
10:45:51 <magnus> I know what caused my fromIntegral problems now! I had defined   fi = fromIntegral
10:46:10 <mauke> huhu, the MR
10:46:11 <magnus> and fi was specialized to do only Int64->Int
10:46:20 <magnus> that's nasty
10:46:22 <matthew-_> magnus: yep, that's bitten me before too.
10:46:27 <mauke> fi eta = fromIntegral eta  -- fixed
10:47:24 <matthew-_> mauke: ahh! why is that? I was going to suggest (fi :: (Num b, Integral a) => a -> b) = fromIntegral
10:47:52 <sjanssen> MR--
10:48:16 <olsner> does the monomorphism restriction only apply to definitions without type annotations?
10:48:22 <mauke> olsner: yes
10:48:43 <mauke> matthew-_: that also works ... I think. I'd use a separate line for type annotations
10:48:47 <edwardk> wonder if maybe idiom brackets would suck less if we could find better ascii delimiters. __I f x y I__ ? __l f x y l__ ? (idiom <| f x y |> idiom) ? =)
10:49:14 <olsner> idiom brackets?
10:49:34 <edwardk> olsner: http://www.haskell.org/haskellwiki/Idiom_brackets
10:49:35 <lambdabot> Title: Idiom brackets - HaskellWiki
10:50:12 <dcoutts_> edwardk: unicode!
10:50:14 <sjanssen> edwardk: the first two suggestion don't look better than iI Ii, IMO
10:50:35 <sjanssen> edwardk: the third one is nice.  Is it too verbose?
10:51:02 <edwardk> well, the question is how does GHC handle unicode then? does it treat things from the Symbol space as part of the infix symbol character set or as valid identifier characters?
10:51:15 <sjanssen> can we find a Unicode character that looks like a bracket, but is classified as an alphabetic character?
10:51:36 <dcoutts_> edwardk: it uses the unicode property database to decide what are operators
10:51:45 <edwardk> thats what i was afraid of =)
10:51:58 <dcoutts_> but dunno about brackets
10:52:15 <dcoutts_> I expect they're currently not legal in identifiers or operators
10:52:48 <dcoutts_> what you really want is for properly matched pairs of brackets to de-sugar into application of a specific function
10:53:04 <edwardk> yeah
10:53:22 <mauke> but how do you sect it?
10:53:26 <sjanssen> if we can extend the Haskell grammar, wouldn't [{ }] work?
10:53:31 <edwardk> ideally i'd just say outfix {|  |} somewhere, then go ahead and use {| foo |} in my code =)
10:53:34 <dcoutts_> mixfix [] foo
10:53:41 <olsner> perhaps haskell should differentiate brackets, and allow for circumfix operators
10:53:46 <mauke> guys, get it right. it's "circumfix"
10:53:57 <mauke> perl says so!
10:54:00 <dcoutts_> heh
10:54:06 <mattam> is that an argument ?
10:54:13 <ddarius> edwardk: Have you looked at OBJ?
10:54:15 <Vulpyne> It's a trap!
10:54:20 <edwardk> OBJ?
10:54:27 <ddarius> @google OBJ3 language
10:54:28 <lambdabot> http://www.cs.ucsd.edu/users/goguen/sys/obj.html
10:54:28 <lambdabot> Title: OBJ Family: OBJ3 CafeOBJ Maude Kumo FOOPS Eqlog
10:54:29 <Maddas> mattam: It's a reason, not an argument!
10:54:36 <mattam> http://en.wikipedia.org/wiki/Circumfix
10:54:37 <olsner> an argument it is, the question is what it's an argument for :P
10:54:38 <lambdabot> Title: Circumfix - Wikipedia, the free encyclopedia
10:54:40 <mattam> indeed
10:54:55 <dcoutts_> sjanssen: single char brackets are probably easier to specify lexically
10:54:57 <edwardk> added to the reading list
10:55:20 <ddarius> OBJ allows the definition of things in all kinds of crazy fixities.
10:55:25 <dcoutts_> sjanssen: but I suppose you could allow any sequence of bracket chars, other than ()'s
10:55:55 <dcoutts_> sjanssen: hmm, but it's a non-backwards compatible lexer change
10:56:32 <dcoutts_> sjanssen: since [{( all mean something already, it's easier for new unicode bracket chars
10:56:36 <edwardk> well, actually you should be able to allow an arbitrary sequence, of them mixed in with operator characters as well, then just parse them with significant space, but thats not very haskell-like =)
10:57:00 <sjanssen> dcoutts_: sure, that's probably easier.  I'm skeptical of any character that isn't on my keyboard, though :)
10:57:13 <dcoutts_> exactly, {[(+) is already a legal lexically
10:57:28 <opqdonut> if we do that we should get a real lambda too, finally :)
10:58:02 <dcoutts_> opqdonut: the only difficulty with that is the greeks :-) unicode should have a lambda symbol as well as the lower case greek letter
10:58:08 <sjanssen> opqdonut: the problem with lambda is that it's also a lower cased Greek character
10:58:35 <edwardk> bah, the greeks can be second class citizens, we just raid their alphabet for operators. mmm Pi.
10:58:38 <dcoutts_> we should lobby for a mathmatical lambda symbol in the next unicode revision :-)
10:58:40 <edwardk> =)
10:59:04 <opqdonut> sjanssen: why couldn't lambda just be a reserved word?
10:59:13 <opqdonut> like "lambda" is in some langs
10:59:27 <sjanssen> opqdonut: we could do that, but you can argue that it isn't very fair to Greek speakers
10:59:30 <edwardk> coz we have already sacrificed \ to it
10:59:34 <opqdonut> and isn't "o" the function composition operator in some lang
10:59:59 <olsner> you should be able to keep the greek letters for identifiers, ideally... \ lambda phi psi -> lambda (psi * phi)
11:00:00 <sjanssen> opqdonut: how would you feel if the Haskell committee stole 'x'?
11:00:01 <dcoutts_> edwardk: there are dozens of pi symbols in unicode
11:00:09 <dcoutts_> mathematical ones
11:00:40 <olsner> otoh, mixing mathematical lambda and greek letter lambda is a recipe for trouble
11:01:35 <edwardk> well, there is an Nary prduct, which is presumed to render large in common usage, and the greek one, not sure i remember any others
11:01:52 <edwardk> er Pi's that is, as for lowercase pi, thats another story
11:02:59 <mauke> just require $ on user-defined identifiers
11:03:06 <mauke> then you can have $x and an operator x
11:03:11 <opqdonut> :D
11:03:36 <edwardk> lukas: =) and you can extend your keyword set at will without worrying about breaking existing code. yes yes =)
11:03:53 <byorgey> good idea!  x can be, let's see... the string repetition operator!
11:04:15 * cjeris votes for x being cartesian product of lists
11:04:17 <profmakx> ouch
11:04:24 <mauke> > "foo" Ã— 3
11:04:24 <lambdabot>  Illegal character ''\151''
11:05:07 <edwardk> hrmm, but with all this ducktyping we might need separate operators for numeric and lexicographic string comparisons, so maybe == and eq, <= and le....
11:05:36 <edwardk> I'm sure audreyt has some ideas in this direction =)
11:06:04 <dcoutts_> has perl gone unicode?
11:06:21 <mauke> perl6 will have gone unicode
11:06:29 <dcoutts_> (read that as "has perl gone crazy?")
11:06:32 <roconnor> > splitAt 3 "abcd"
11:06:32 <edwardk> they have pretty decent utf8 support but you have to import it at last check
11:06:34 <lambdabot>  ("abc","d")
11:07:06 <dcoutts_> I'm beginning to think the Haskell String IO functions should just default to using UTF8
11:07:10 <edwardk> and pugs has a lot of unicode manipulation stuff in its bowels as i recall
11:07:18 <edwardk> yes!
11:07:19 <mauke> edwardk: you don't have to import anything
11:07:56 <edwardk> i thought if you didn't 'use utf8' or whatever you had the efficient byte-based regexps, etc.
11:08:05 <dcoutts_> edwardk: see really it should have some way to set the encoding or we should get rid of the String versions and do it all as Word8
11:08:22 <mauke> open my $fh, '<:utf8', $filename and reading from $fh automatically decodes utf8
11:08:32 <dcoutts_> but it seems like most people want utf8 by default, possibly even windows users
11:08:39 <mauke> core ops transparently deal with unicode
11:08:48 <mauke> 'use utf8' just means your program is written in utf-8
11:08:55 <edwardk> newtype ISO8859_1 = ISO8859_1 [Word8] deriving (...) ?
11:09:32 <sjanssen> dcoutts_ has seen the light!
11:09:37 <sjanssen> hallelujah!
11:09:39 <dcoutts_> heh
11:09:59 <dcoutts_> and at least it'd be a consistent story
11:09:59 <olsner> data Encoding = ISO8859_1 | UTF8; data Encoded = Encoded Encoding [Word8]
11:10:10 <edwardk> mauke: i must be a few versions behind in my thinking
11:10:34 <mauke> olsner: that looks wrong
11:10:34 <dcoutts_> .hs files are utf8, standard String IO is utf8, and use openBinaryFile if you want to do the encoding yourself
11:10:50 <edwardk> dcoutts: that i'd buy into
11:11:01 <olsner> mauke: in what way?
11:11:07 <Philippa> if you do that then you need a good way of telling how your system likes its lines
11:11:13 <mauke> olsner: raw byte data shouldn't have an attached encoding
11:11:14 <dcoutts_> except that then openBinaryFile still gives you a Handle
11:11:24 <dcoutts_> which gives you ops for getting Strings grr
11:11:32 <mauke> olsner: I'd attach the encoding to the Handle
11:11:44 <dcoutts_> Philippa: use the default for the platform, so windows would do crlf translation as ususal
11:11:52 <sjanssen> dcoutts_: well, if we're ready to break compatibility, make them separate types
11:12:00 <edwardk> so, in a language building for that from the ground up, you'd have to start with binary files then build up a notion of a character stream? whee hello java ;)
11:12:06 <Philippa> have a default encoding (settable) and readFileWithEncoding?
11:12:25 <Philippa> dcoutts: not on a binary file it wouldn't. What if I want to read a non-UTF8 text file?
11:12:26 <dcoutts_> sjanssen: I think separate types is a great idea, I think the bytestring lib will do that when it gets unicode support
11:12:30 <olsner> I think Java does it pretty well actually... InputStreams always do byte IO, Readers do unicode IO, InputStreamReaders do the conversion
11:12:41 <mauke> encode :: Encoding -> String -> [Word8]
11:12:48 <mauke> decode :: Encoding -> [Word8] -> String
11:12:52 <sjanssen> or: class IOHandle h a | h -> a where get :: h -> IO [a]; ...
11:12:55 <mauke> oh, and something for failure
11:13:04 <dcoutts_> Philippa: then you're on your own, do the crlf translation yourself
11:13:37 <Philippa> sure, but how do I know which translation's appropriate?
11:13:39 <dcoutts_> that's not much harder than doing the decoding of your non-utf8 format anyway
11:14:09 <dcoutts_> you always have to know what the format of the file is, though it might say so in the first few lines (eg xml)
11:14:22 <sjanssen> Philippa: I agree that UTF-8 and handling CRLF should be orthogonal
11:14:40 <mauke> dcoutts_: which doesn't help if you have to decode the first lines to find out what encoding they're in :-)
11:14:49 <dcoutts_> for the simple case, it seems to me there are utc8 text files and everything else
11:14:50 <Philippa> yes, but often what I "know" is "some fixed charset and encoding, OS default for lines"
11:14:56 <Philippa> how do I find out what the OS default is?
11:15:10 <Philippa> or to put it another way, it's necessary to have a way to find out what it is
11:15:19 <dcoutts_> is it?
11:15:27 <dcoutts_> decoding all three conventions is easy
11:15:35 <dcoutts_> without knowing which convention is being used
11:15:39 <dcoutts_> or even if it's mixed
11:16:00 <Philippa> and it's potentially the wrong thing to do
11:16:07 <sjanssen> dcoutts_: I can't remember, is ByteString being split out of base with ghc 6.8?
11:16:12 <dcoutts_> sjanssen: yes
11:16:22 <opqdonut> why?
11:16:28 <dcoutts_> sjanssen: darcs get http://darcs.haskell.org/bytestring/
11:16:30 <lambdabot> Title: Index of /bytestring
11:16:51 <dcoutts_> opqdonut: the base package is being split into many packages
11:16:58 <Philippa> really, what's so nasty about having a linesLookLike string in scope?
11:17:14 <opqdonut> dcoutts_: ahh, will they all be shipped with ghc?
11:17:14 <dcoutts_> Philippa: nothing, stick it in System.Info
11:17:25 <dcoutts_> opqdonut: yep
11:17:30 <Philippa> right, that's all I'm asking for
11:17:40 <opqdonut> okays :)
11:18:04 <Philippa> oh, and possibly OSDefault, LF, CR and CRLF variants for each encoding once that comes into play - but that's on a different layer, so fair enough
11:18:18 <dcoutts_> Philippa: propose it
11:18:58 <dcoutts_> sjanssen: probably the right thing really is just to have a setEncoding :: Handle -> Encoding -> IO ()
11:19:08 <dcoutts_> and let the default be UTF8 :: Encoding
11:19:24 <mauke> there should be a way to specify the encoding in open
11:19:28 <dcoutts_> or for backwards compat let it be ASCII or whatever
11:19:36 <mauke> but you still need setEncoding for std*
11:19:45 <dcoutts_> mauke: in open?
11:19:47 <Philippa> I doubt anyone's going to complain at openWithEncoding, mauke
11:19:50 <dcoutts_> oh I see, readFile
11:20:03 <Philippa> or readWithEncoding, for that matter
11:20:10 <mauke> there should be no openWithoutEncoding
11:20:14 <sjanssen> dcoutts_: you might want Encoding to be some sort of open data type
11:20:29 <Philippa> mauke: yes there should, and it should yield bytes
11:20:43 <magnus> Hmm, why is Test.QuickCheck missing in my GHC?
11:20:44 <mauke> Philippa: ok, but then it shouldn't give you a Handle
11:20:48 <Philippa> it might be that a separate BinaryHandle's an idea though
11:20:54 <dcoutts_> for that kind of thing it seems to me easier to say: decodeUTF8 <$> readFile
11:21:07 <mauke> then readFile needs to return [Word8]
11:21:11 <dcoutts_> yes
11:21:13 <sjanssen> magnus: just grab http://hackage.haskell.org/cgi-bin/hackage-scripts/package/QuickCheck-1.0
11:21:18 <lambdabot> http://tinyurl.com/225ea7
11:21:25 <dcoutts_> mauke: that's how ByteString does it
11:21:32 <magnus> sjanssen: it is not distributed with ghc?
11:21:36 <edwardk> well, i suppose you `should` look at LC_CTYPE/LC_ALL, etc. in a posix setting to figure out the right behavior for the default cause no?
11:21:49 <sjanssen> magnus: it's an "extralib" now, which means that your distro might not package it with ghc
11:21:54 <Philippa> dcoutts: you can generally expect me not to find the time and energy to make formal proposals btw
11:21:58 <dcoutts_> magnus: don't get hung up on what is and is not distributed with ghc
11:22:03 <dcoutts_> Philippa: sure
11:22:07 <magnus> okay
11:22:10 <edwardk> which is somewhat inimical to the idea of not passing around hidden globals
11:22:27 <Philippa> further details on quite why that's the case at AngloHaskell if you show up, I'm only giving a talk on it :-)
11:22:45 <mauke> edwardk: you could do that for std{in,out,err}
11:22:56 <edwardk> afk
11:23:02 <edwardk> mauke: good point
11:24:06 <sjanssen> dcoutts_: do you know if there's a trac ticket related to the UTF-8/encoding issue?
11:24:25 <dcoutts_> sjanssen: of the standard IO functions? there isn't one as far as I know.
11:24:26 <sjanssen> dcoutts_: I note that this comes up at least twice a week in #haskell
11:24:31 <mauke> getAll hdl = unsafeInterleaveIO $ liftM2 (liftM2 (:)) getOne getAll hdl  -- does this use of unsafeInterleaveIO look right?
11:24:44 <dcoutts_> sjanssen: yeah, I know, that's partly what makes me reconsider
11:25:16 <dcoutts_> sjanssen: or start a big long thread on the libraries list
11:25:18 <dcoutts_> :-)
11:25:43 <dcoutts_> sjanssen: or I can ;-)
11:25:57 * dcoutts_ looks again at what H98 specifies
11:26:00 <sjanssen> mauke: yeah, that looks fine
11:26:31 <Philippa> sjanssen: one of the reasons it keeps coming up is it's taken so long to be in a position to really look at doing the right thing
11:27:20 <Philippa> it's aggravating knowing that stdin/out/err and the existing lib functions may end up being kludgy special cases
11:27:20 <sjanssen> Philippa: true.  GHC was 'newtype Char = Char Word8' until relatively recently
11:27:33 <sjanssen> 6.4 was the first with true Unicode Chars IIRC
11:28:05 <diakopter> hi; sorry to bug with a n00b question... in the pugs repository, there are some cabal packages that I'd like to "make install".  Can anyone help me learn how to do that?
11:28:38 <mauke> $ perl -le 'print ord chr -1'
11:28:38 <mauke> 18446744073709551615
11:28:42 <mauke> perl++
11:28:56 <sjanssen> diakopter: the usual incantation is 'runhaskell Setup.hs $x', where $x is configure, build, install
11:29:28 <diakopter> sjanssen: thanks :) I'll try it.
11:31:17 <diakopter> sjanssen: okay, it installed, but didn't tell me to what location (and the .cabal file doesn't specify).  Do you know the default destination?
11:31:32 <mauke> probably /usr/local
11:31:36 <sjanssen> diakopter: /usr/local/, probably
11:31:59 <sjanssen> diakopter: you can also use --prefix=... on the configure stage
11:32:25 <sjanssen> and --user on the install stage, if you want to make the package available to the current user only
11:32:47 <dcoutts_> sjanssen: as far as I can see, the H98 report does not say anything about encoding for IO functions (except mentioning that it will do funny things with line endings and it cannot be used for portable binary IO)
11:33:42 <sjanssen> dcoutts_: yeah.  IMO, the language in the report implies that we *should* be using UTF-8 or an encoding based on the locale
11:34:08 <dcoutts_> sjanssen: which bit? I'm looking for something to quote.
11:34:23 <sjanssen> dcoutts_: just reading between the lines
11:34:35 <dcoutts_> certainly Char is specified as a Unicode code point
11:34:54 <sjanssen> the fact that Char is Unicode, the report specifically says the IO functions shouldn't be used for binary IO, etc.
11:35:11 <dcoutts_> and that Haskell scripts are supposed to be Unicode
11:35:17 <Philippa> yeah, the existing binary IO system in GHC is a hack
11:35:17 <dcoutts_> though again, no encoding specified
11:36:00 <diakopter> another question: perl -V will tell me all the paths in which the current invocation will search for libraries (including Config.pm-specified locations and $PERL5LIB).  Does ghc have an analogue?
11:36:19 <dcoutts_> diakopter: ghc-pkg will tell you lots of things
11:36:29 <opqdonut> a cryptic answer :)
11:37:02 <diakopter> dcoutts_: thanks :) I'll take a look.  I appreciate your patience!
11:37:12 <Philippa> I think it's fair to say that the default needs to be either locale or something with some extremely strong arguments for it. Tbh, I think UTF-8 fares better than latin-1 there
11:41:29 <dcoutts_> sjanssen: probably the thing to do is to create an alternative implementation and experiment with flexibility, portability and performance
11:42:14 <dcoutts_> and use that to inform the debate for Haskell'
11:42:39 <Philippa> odds are we can start with just one that has tolerable performance and enough flexibility to build whatever interface we like over the top
11:43:12 <dcoutts_> the hardest point is probably getting consensus on an api
11:43:40 <dcoutts_> so long as the api doesn't make performance impossible, performance should not be a problem
11:44:17 <dcoutts_> eg if we required charset encoding functions to take lists of word8, that'd make performance impossible
11:44:36 <olsner> Stream?
11:44:48 <hpaste>  roconnor pasted "dons: Ropes version 0.01" at http://hpaste.org/1862
11:44:50 <mauke> I want something that can read from a Fd into Ptr Word8
11:45:20 <sjanssen> dcoutts_: yeah, you practically have to specify a chunk of the ByteString API to express an encoding API
11:45:22 <dcoutts_> yes, the lowest level should deal with IO in chunks of bytes, not lists of them
11:45:36 <sjanssen> you could maybe do it terms of Ptr Word8
11:45:51 <dcoutts_> I think a simple ByteArray type should be specified
11:46:01 <sjanssen> yeah, that's another option
11:46:15 <sjanssen> just a wrapper around ByteArray#, or whatever it's called
11:46:17 <dcoutts_> it'd be simpler than ByteString (ie no offsets)
11:46:44 <dcoutts_> it'd be something like GHC's ByteArr#, and similar things in NHC and Hugs
11:47:32 <dcoutts_> simple heap allocated (not pinned) byte array with operations for getting various primitive types at arbitrary (aligned?) offsets
11:47:48 <Philippa> this is starting to smell a little like issues xerox and I're having to play with though
11:47:56 <dcoutts_> oh yes?
11:48:15 <Philippa> I mean... it'd be /nice/ to have totally generic decoding functions, and it wouldn't necessarily be that painful given that you can specialise them to the actual implementation being used
11:49:51 <magnus> roconnor: That looks good but it can't support fast index
11:50:00 <magnus> roconnor: or splitAt
11:50:10 <sjanssen> roconnor: you should check out Data.FingerTree
11:50:13 <sjanssen> @hackage fingertree
11:50:13 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fingertree
11:50:25 <roconnor> oh
11:50:50 <roconnor> good thing I got feedback now
11:51:14 <sjanssen> roconnor: also, a very rough start at http://darcs.haskell.org/SoC/fps-soc/Data/Rope.hs
11:51:18 <newsham_> anyone make a fingertree dna processor?
11:51:28 <mattam> Cale did
11:51:32 <newsham_> speed?
11:51:46 <mattam> 10k/sec without optim apparently
11:51:52 <newsham_> decent
11:51:55 <mattam> indeed
11:52:14 <magnus> roconnor: You probably need something like data Rope = BS ByteString | Append { length::Int64, left::Rope, right::Rope }
11:52:20 <magnus> roconnor: and make sure it's balanced
11:52:37 <roconnor> why, aren't finger trees balanced?
11:52:42 <sjanssen> magnus: have you see FingerTree before?
11:52:45 <dcoutts_> magnus: I'd really just use a finger tree
11:52:48 <magnus> sjanssen: no
11:53:06 <dcoutts_> check out the paper, it's nice stuff
11:53:19 <sjanssen> magnus: I suggest you check it out -- it's got a really general interface that lets write all sorts of data structures without
11:53:21 <dcoutts_> @google ross ralf finger tree
11:53:25 <sjanssen> s/without/with it
11:53:26 <lambdabot> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
11:53:26 <lambdabot> Title: Finger Trees: A Simple General-purpose Data Structure
11:53:39 <magnus> sjanssen: I wish I knew about them before the compo :)
11:53:48 <roconnor> sjanssen: if I move to the FingerTree level, do I get fast indexing?
11:53:57 <magnus> I though it was the same as Data.Sequence
11:53:57 <sjanssen> roconnor: yes, you can get fast indexing
11:53:59 <dcoutts_> log(n)
11:53:59 <roconnor> sjanssen: oh, and do I get length memoized for free?
11:53:59 <newsham_> i wish i knew about a lot of stuff before the contest
11:54:07 <dcoutts_> roconnor: yes
11:54:09 <sjanssen> roconnor: for free-ish
11:54:20 <roconnor> I don't understand this measure yet
11:54:32 <roconnor> I'm glancing through the paper now.
11:54:43 <sjanssen> roconnor: give it a thorough read, it's pure gold
11:55:08 <roconnor> but I have less than negative 24 hours to implement this!
11:55:14 <roconnor> ;)
11:55:23 <magnus> wow, finger trees look awesome!
11:55:24 <newsham_> at least tomorow you'll have negative 48hrs
11:55:32 <magnus> with them we'll have a Rope in no time :)
11:55:47 <newsham_> enough to hang ourselves with at least!
11:55:54 <sjanssen> :)
11:55:56 <roconnor> *l*
11:56:14 <magnus> Hmm, but can it join short Bytestrings into one bytestring?
11:56:21 <magnus> can it join elements together?
11:56:27 <sjanssen> magnus: no, it's not smart enough to do that
11:56:36 <magnus> then it's not good enough for ropes after all
11:56:37 <sjanssen> that's the sort of thing you'll have to do manually
11:56:44 <dcoutts_> but a specialised implementation could do that...
11:56:59 <dcoutts_> I think someone should make one and include it in the bytestring package
11:57:07 <sjanssen> yeah, you just have to write a specialized version of append that checks the two ends
11:57:42 <roconnor> magnus: if one side is a short bytestring I do I bytestring concat
11:58:03 <dcoutts_> roconnor: if both are short presumably?
11:58:13 <dcoutts_> roconnor: otherwise you might end up copying a very long string
11:58:17 <roconnor> If both are short, then one is short. :)
11:58:20 <magnus> or the resulting lenght is short?
11:58:23 <sjanssen> l >< r = if rightmost of l is small && leftmost of l is small then merge those small things ;)
11:58:26 <newsham_> dcoutts: shouldnt it be in the ropes/fingers package?
11:58:27 <sjanssen> all done
11:58:42 <roconnor> see my definition of append
11:58:43 <sjanssen> s/leftmost of/leftmost of r
11:58:50 <dcoutts_> magnus: if the resulting length is short I'd say, that bounds the amount of work copying
11:59:05 <roconnor> append r0 r1 | length r0 == 0 = r1
11:59:05 <roconnor>              | S.length (chunks r0) == 1 &&
11:59:05 <roconnor>                short (leftSize r1) = joinLeft lft r1
11:59:05 <roconnor>              | S.length (chunks r1) == 1 &&
11:59:05 <roconnor>                short (rightSize r0) = joinRight r0 rht
11:59:06 <roconnor>              | otherwise = fastAppend r0 r1
11:59:36 <dcoutts_> newsham_: I'd say in the bytestring one, since it could/should have the same api as Data.ByteString and .Lazy, but with different time complexities
11:59:43 <roconnor> dcoutts_: ah that is a good oint
11:59:44 <roconnor> point
12:00:36 <dcoutts_> newsham_: and if it were in the fingertree package then that package would have to depend on bytestring
12:01:08 <magnus> can fingertree be generalized to support merging small items?
12:01:15 <magnus> without tying it to bytestring
12:01:20 <dcoutts_> possibly
12:01:32 <newsham_> dcoutts: and if it were in the bytestring library then the bytestring would have to depend on fingers :)
12:01:39 <mattam> Nope, only the measure can be parameterized
12:01:42 <dcoutts_> but there's more cool stuff we can do by tying it to bytestring
12:01:48 <newsham_> and bytestring's already in the libs
12:01:49 <mattam> (and the monoid)
12:02:17 <dcoutts_> newsham_: I'm suggesting a specialised implementation that doesn't depend on the generic impl in the fingertree package
12:02:55 <dcoutts_> and it would present an api that makes it look like a sequnce of bytes rather than a sequence of chunks
12:03:16 <newsham_> aha
12:03:30 <kilimanjaro> is it ever worth it in functional language compilation to convert higher-order programs to first-order (defunctionalization) and then just do simpler control and data flow analyses rather than do a higher order analysis on the original program?
12:03:32 <dcoutts_> in the same way ByteString.Lazy presents an api that looks like a continuous stream of bytes, rather than a sequence of chunks
12:04:03 <dcoutts_> kilimanjaro: it's open for debate, ask ndm
12:04:08 <newsham_> how hard would it be to have a unified sequence class?
12:04:23 <newsham_> of which list, bytestring (lazy and otherwise) and ropes could all implement?
12:04:47 <kilimanjaro> dcoutts_, who is ndm? is that his alias in his channel?
12:04:52 <kilimanjaro> this*
12:04:54 <dcoutts_> newsham_: it needs the question of MPTC, fundeps and/or ATs to be decided
12:05:06 <dcoutts_> kilimanjaro: oh, he's not about at the moment
12:05:08 <dcoutts_> @seen ndm
12:05:08 <lambdabot> I saw ndm leaving #haskell-icfp07, #xmonad, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 4h 47m 47s ago, and .
12:05:19 <kilimanjaro> ok i'll ask him next time I see him
12:05:36 <newsham_> #haskell-icfp07?
12:06:36 <nomeata> Hi. Iâ€™m trying to better understand the Curry-Howard isomorphism as explained in http://en.wikibooks.org/wiki/Haskell/The_Curry-Howard_isomorphism
12:06:38 <lambdabot> Title: Haskell/The Curry-Howard isomorphism - Wikibooks, collection of open-content tex ...
12:07:16 <nomeata> There we have â€œdata Voidâ€ for an uninhabited type, and â€œtype Not a = a -> Voidâ€ for negation
12:07:16 <Philippa> kilimanjaro: It's open to debate, the GRIN framework does exactly that though
12:07:55 <nomeata> I know that the proposition () is true (the type is inhabited, the value () is in there)
12:08:02 <roconnor> I wonder though, will Ropes have the same problems as lazy bytestrings?
12:08:08 <doserj> kilimanjaro, mlton, a sml compiler does it also
12:08:11 <nomeata> so Not () should be false (makes sense, as there is no function () -> Void)
12:08:19 <roconnor> eventually becoming single cells unless interupted by flattening?
12:08:26 <nomeata> now my question is: how do I proof the statement â€œFalse -> aâ€ for any statement a?
12:08:29 <kilimanjaro> doserj, ahh, I might check out their stuff
12:08:51 <kilimanjaro> Philippa, GRIN? what is that?
12:08:52 <swiert> nomeata: by case analysis on False.
12:08:53 <nomeata> because I can not find a function of type (() -> Void) -> a
12:09:14 <roconnor> nomeata: by case analysis
12:09:28 <Philippa> kilimanjaro: read Urban Boquist's thesis
12:09:32 <kilimanjaro> ok
12:09:34 <nomeata> what are the cases here?
12:09:39 <mattam> none
12:09:41 <EvilTerran> it's a âˆ€ thing, isn't it...
12:09:44 <roconnor> nomeata: there are node!
12:09:48 <roconnor> none
12:10:02 <roconnor> case void of {} : a
12:10:04 <norpan> there is no such function, and you can't prove False -> a in constructive logic
12:10:19 <roconnor> case void of {} :: a
12:10:34 <roconnor> in a case anaysis all branches must return the same type
12:10:37 <mattam> roconnor: Isn't your implementation based on the one by Cale which is already running ?
12:10:42 <dozer> dang - backticked infixes have presidence 9?
12:10:44 <roconnor> this is true of my above case statement
12:10:59 <roconnor> mattam: Nope.  I just started writing.
12:11:02 <nomeata> roconnor: ok, thanks for the hint
12:11:03 <tcr> I don't think there is way to say "Continue to match with the patterns that come beneath me", is there?
12:11:09 <mattam> You're quick :)
12:11:28 <roconnor> I was compiling a large coq library
12:11:41 <swiert> @users
12:11:42 <mattam> and had some time to waste ?
12:11:42 <lambdabot> Maximum users seen in #haskell: 363, currently: 356 (98.1%), active: 25 (7.0%)
12:11:47 <nomeata> /tmp/curry-howard.hs:7:22: parse error on input `}'
12:11:47 <magnus> roconnor: That is why you need to merge adjacent small chunks, to avoid fragmentation
12:12:07 <EvilTerran> dozer, you can say "infix 5 `foo`"
12:12:11 <roconnor> yeah :(
12:12:27 <roconnor> but how do the C++ people do it?
12:12:29 <EvilTerran> tcr, how do you mean?
12:12:45 <sjanssen> is merging small chunks truly necessary?
12:12:47 <dozer> EvilTerran: that would probably fix it for me :) I've a clash between `isSubsetOf` and my definition of .^
12:12:52 <nomeata> @type (case () of {}) :: Int
12:12:54 <lambdabot> parse error on input `}'
12:12:55 <magnus> sjanssen: for memory usage yes
12:13:05 <EvilTerran> dozer, you can infixr and infixl them as well, if you want associativity
12:13:06 <magnus> sjanssen: the overhead of one node is enormous compared to a byte
12:13:33 <sjanssen> magnus: do you know what sort of system is usually used?
12:13:38 <roconnor> do ropes in C++ merge adjacent small chunks?
12:13:44 <tcr> EvilTerran: case foo of { p1 -> if not bar then "continue with patterns beneath p1" else ... ; p2 -> ... ; p3 -> ... }
12:13:47 <sjanssen> what do you with (tinychunk ++ hugechunk)?
12:13:50 <magnus> roconnor: Yes, I beleive I read they do
12:13:53 <edwardk> @type (case () of _ | False = undefined) :: Int
12:13:55 <roconnor> hey wait, this would be easy to do!
12:13:55 <lambdabot> parse error on input `='
12:13:58 <edwardk> er
12:14:06 <edwardk> @type (case () of _ | False -> undefined) :: Int
12:14:08 <lambdabot> Int :: Int
12:14:13 <EvilTerran> tcr, case foo of { p1 | bar -> ...; p2 -> ... }
12:14:21 <int-e> sjanssen: sigh and move on, I guess
12:14:25 <roconnor> magnus: they weren't in the paper I was reading.
12:14:37 <magnus> roconnor: oh, that's interesting
12:14:37 <sjanssen> in (tiny ++ tiny), it's clearly best to combine them into one medium chunk
12:14:39 <roconnor> but it should be easy come to think of it.
12:14:40 <EvilTerran> tcr, you can use guards in case expressions just like you can in function definitions
12:14:43 <nomeata> edwardk: well, using undefined is probably not allowed when doing proofs with haskall programs
12:15:00 <tcr> EvilTerran: My example is not so trivial.
12:15:02 <magnus> if we don't merge small nodes we may as well be using Data.Sequence
12:15:03 <roconnor> magnus: ... however I only read the first 6 pages ...
12:15:07 <EvilTerran> in fact, function definitions desugar to case expressions anyway, iirc
12:15:15 <tcr> EvilTerran: I mean my case is not as trivial as the example.
12:15:17 <dozer> EvilTerran: dho! that gives me a parse error
12:15:34 <edwardk> nomeata: well, in your case you have a partial function defined because of missing cases anyways, so you get the same set of bottoms
12:15:40 <EvilTerran> tcr, could you paste something, writing "FALLTHROUGH" or something where you want to do so?
12:16:06 <nomeata> edwardk: just in the pasted code. here I case on a value of type Void, which is defined as â€œdata Voidâ€, so the empty case statement is complete
12:16:16 <magnus> http://www.sgi.com/tech/stl/ropeimpl.html
12:16:17 <lambdabot> Title: Rope Implementation Overview
12:16:24 <nomeata> I just canâ€™t do type definitions in lambdabot afaik
12:16:34 <dcoutts_> sjanssen: the combining thing is not nearly so obvious when you consider substring sharing
12:16:46 <sjanssen> dcoutts_: yep
12:16:47 <edwardk> nomeata: i missed whatever discussion occurred before i saw that snippet, was off channel.
12:17:05 <sjanssen> dcoutts_: it's even more hairy if you consider that substring sharing can increase memory use :)
12:17:11 <dcoutts_> exactly
12:17:18 <nomeata> edwardk: Iâ€™m trying to prove â€œFalse -> aâ€ using the Curry-Howard-Isomorphism
12:17:24 <dcoutts_> as can unsharing of course
12:17:27 <EvilTerran> dozer, see http://www.haskell.org/onlinereport/decls.html#sect4.4.2 -- does what you're doing match the syntax down a bit from there?
12:17:27 <lambdabot> Title: The Haskell 98 Report: Declarations
12:17:36 <dcoutts_> sjanssen: needs a specialised GC ;-)
12:17:40 <edwardk> ah
12:17:43 <magnus> roconnor: that webpage has a very accessible overview
12:17:43 <nomeata> edwardk: using â€œdata Voidâ€ to represent a false proposition
12:17:50 <edwardk> @djinn-env
12:17:51 <lambdabot> data () = ()
12:17:51 <lambdabot> data Either a b = Left a | Right b
12:17:51 <lambdabot> data Maybe a = Nothing | Just a
12:17:51 <lambdabot> data Bool = False | True
12:17:51 <lambdabot> data Void
12:17:53 <lambdabot> type Not x = x -> Void
12:17:55 <lambdabot> class Eq a where (==) :: a -> a -> Bool
12:18:03 <EvilTerran> nomeata, i thought curry-howard only provides an isomorphism to constructive logic...
12:18:06 <nomeata> oh, already there
12:18:11 <edwardk> @djinn Void -> a
12:18:11 <lambdabot> f = void
12:18:13 <nomeata> EvilTerran: dunno, but roconnor just suggested something
12:18:20 <dozer> EvilTeran: the problem was that I was doing `S.isSubsetOf` and it didn't like the S. on the front
12:18:43 <nomeata> @type void
12:18:45 <lambdabot> Not in scope: `void'
12:18:48 <dcoutts_> dozer: hmm, that should be ok
12:19:11 <dcoutts_> > 3 `Data.Set.elem` empty
12:19:12 <lambdabot> Terminated
12:19:19 <nomeata> @type let f v = (case v of {}) :: a in f
12:19:20 <lambdabot> parse error on input `}'
12:19:34 <EvilTerran> > [1..] `List.zip` "qwertyuiop"
12:19:35 <lambdabot>  [(1,'q'),(2,'w'),(3,'e'),(4,'r'),(5,'t'),(6,'y'),(7,'u'),(8,'i'),(9,'o'),(10...
12:19:51 <dozer> dcoots_: no - with ghc 6.6 it accepts infixl 8 `isSubsetOf` but rejects infixl 8 `S.isSubsetOf`
12:19:59 <roconnor> nomeata: Haskell '98 doesn't support the Void datatype.
12:20:01 <edwardk> Void has no data constructors so the only member of void is bottom, so if i have a Void, I have a bottom, given a bottom I can generate a bottom of any type.
12:20:05 <sjanssen> dcoutts_: it might be best to use your DiffArray-like trick for ropes
12:20:19 <edwardk> so i can generate a bottom of type a
12:20:27 <EvilTerran> > const undefined :: Void -> a
12:20:28 <dcoutts_> sjanssen: hmm?
12:20:28 <lambdabot>   Not in scope: type constructor or class `Void'
12:20:38 <EvilTerran> > const undefined :: a -> b
12:20:39 <lambdabot>  Add a type signature
12:20:40 <mattam> There certainly is some way to parameterize Finger Trees to get this optimization going though.
12:20:45 <timthelion> http://rafb.net/p/zPR1ye53.html
12:20:47 <lambdabot> Title: Nopaste - Inverse of single param functions?
12:21:24 <timthelion> I want to pass Genisis and get "gen"
12:21:28 <nomeata> edwardk: right, but how do i actually write a function of type Void -> a?
12:21:31 <mauke> why not Genesis?
12:21:33 <sjanssen> dcoutts_: this is from a discussion that might have happened a year ago :).  The idea was buffer things that appear immutable, but their tails can be update in place in certain situations
12:21:38 <roconnor> mattam: ``The case in which a short rope consisting of a single leaf is concatenated onto the right of a rope which is either a leaf, or a concatenation node whose right child is a leaf, is handled specially.
12:21:54 <roconnor> it really looks like they don't merge adjacent small nodes.
12:21:56 <timthelion> mauke: huh?
12:21:56 <dcoutts_> sjanssen: ah yes, how would that help us with ropes?
12:21:57 <opqdonut> timthelion: well you could just have a list of [(name,constructor)] and do lookups
12:22:17 <mauke> I mean, is it just a typo or does it have a special meaning?
12:22:28 <edwardk> well, the cheaty way would be to seq it =)
12:22:32 <sjanssen> dcoutts_: well, you can put these buffer things on either end of the trees, making concatentation of short things nearly free
12:22:38 <magnus> roconnor: I read that as that they DO merge them
12:22:46 <timthelion> opqdonut: OK, so there isn't a way to do that with the nice paternmatching
12:22:50 <timthelion> mauke: oh, typo
12:23:04 <mattam> roconnor: you mean in the original paper by boehm et al ?
12:23:08 <dcoutts_> sjanssen: or repeated inserts into the middle too, like a text editor buffer
12:23:08 <magnus> roconnor: oh wait, the rebalancing happens when a concat detects that the depth vs length is bad
12:23:26 <roconnor> magnus: oh, does rebalencing merge nodes?
12:23:29 <dcoutts_> sjanssen: yes, that'd be pretty cool.
12:23:31 <timthelion> mauke: it has special meaning, it's the original version of a file... but it should be Genesis...
12:23:39 <magnus> roconnor: don't know. I can't imagine that it doesn't
12:23:45 <sjanssen> dcoutts_: I'd imagine a text editor would be a zipper, data Edit = Edit {left, right :: Rope}
12:24:04 <sjanssen> dcoutts_: then a text editor can automatically take advantage of the buffer on the right rope
12:24:18 <nomeata> it seems that djinn just know about void, but doesnâ€™t actually define it within haskell
12:24:27 <hpaste>  tcr pasted "Falling through pattern matchings" at http://hpaste.org/1863
12:24:27 <magnus> with a rope you wouldn't need a zipper
12:24:27 <dcoutts_> sjanssen: that's a pretty single threaded view, imagine multiple readers and possibly multiple writers
12:24:34 <nomeata> @djinn (a -> b) -> Either (Not a) b
12:24:34 <lambdabot> -- f cannot be realized.
12:24:39 <magnus> sjanssen: with a rope you wouldn't need a zipper
12:24:42 <tcr> EvilTerran: See there, please. :)
12:24:45 <doserj> nomeata: there is no need to define it on any value
12:24:49 <nomeata> @djinn Either (Not a) b -> (a -> b)
12:24:49 <lambdabot> f a b =
12:24:50 <lambdabot>     case a of
12:24:50 <lambdabot>     Left c -> void (c b)
12:24:50 <lambdabot>     Right d -> d
12:25:09 <sjanssen> magnus: I'd still use both -- a zipper is nicer than keeping an index, IMO
12:25:25 <magnus> sjanssen: ah, I have little experience with zippers
12:25:29 <edwardk> nomeata: http://www.haskell.org/pipermail/libraries/2006-October/005958.html
12:25:29 <sjanssen> magnus: because the cursor is explicit in the data structure
12:25:30 <lambdabot> Title: A Pointless Library Proposal, http://tinyurl.com/3cstnr
12:25:39 <dcoutts_> sjanssen: but yes, that'd give one cursor with possibly O(1 ish) insert for small strings
12:25:51 <sjanssen> dcoutts_: true, that doesn't really work with multiple writing cursors
12:26:35 <dcoutts_> sjanssen: a zipper with finger trees might be a good way of generating a list of buffer changes from a sequence of ops
12:26:36 <roconnor> magnus: I don't see any evidence that rebalencing concatinates buffers.
12:26:51 <dcoutts_> sjanssen: imagine updating a remote viewer of changes in a buffer
12:26:52 <nomeata> djinn can prove (a â‡’ b) â‡’ (Â¬a âˆ¨ b), but not (Â¬a âˆ¨ b) â‡’ (a â‡’ b). Why?
12:27:25 <tcr> EvilTerran: Please refresh, if you looked at the hpaste already.
12:27:25 <opqdonut> nomeata: what is that symbol after ¬a?
12:27:27 <dcoutts_> sjanssen: like a gui or synchronising a remote buffer in a collaborative editor
12:27:31 <edwardk> nomeata: double negation
12:27:31 <monochrom> The latter requires classical logic.
12:27:33 <nomeata> opqdonut: or
12:27:44 <newsham_> http://arstechnica.com/news.ars/post/20070724-intel-open-sources-multicore-programming-tool.html
12:27:46 <lambdabot> http://tinyurl.com/yowqbs
12:27:53 <edwardk> nomeata: in intuitionistic logic ~~a => a does not hold.
12:27:55 <hpaste>  EvilTerran annotated "Falling through pattern matchings" with "(no title)" at http://hpaste.org/1863#a2
12:27:59 <nomeata> @djinn (Not (Not a)) -> a
12:28:00 <lambdabot> -- f cannot be realized.
12:28:12 <nomeata> ok, I think Iâ€™m getting it slowly :-)
12:28:15 <edwardk> @djinn a -> Not (Not a)
12:28:15 <lambdabot> f a b = b a
12:28:29 <sjanssen> dcoutts_: I'm especially interested in the ease of providing 'undo' with a representation like that
12:28:31 <monochrom> intuitionistic logic has fewer axioms than classical logic.
12:28:36 <dcoutts_> sjanssen: ah yes
12:28:38 <sjanssen> dcoutts_: it's practically free!
12:28:48 <EvilTerran> tcr, there's what you want. it's an extension, but a particularly useful one.
12:28:49 <nomeata> and can I use haskell to do classical logic as well?
12:28:58 <dcoutts_> sjanssen: yes with persistence it is nearly free
12:29:00 <magnus> roconnor: Okay, you can try without rebalancing
12:29:06 <EvilTerran> and pretty widely supported across compilers, iirc.
12:29:09 <monochrom> If you use the Control.Monad.Cont monad.
12:29:10 <magnus> roconnor: I'm guessing it'll take too much memory after a while
12:29:12 <nomeata> (ok, that question sounds strange out of context)
12:29:14 <qazwsx> which haskell implementation should I use? I'm writing a MMORPG
12:29:26 <sjanssen> data Editor = Editor { left, right :: Rope, undo, redo :: Maybe Editor }
12:29:29 <dcoutts_> qazwsx: ghc unless there's a good reason to use any other
12:29:31 <matthew-_> qazwsx: err. GHC.
12:29:38 <timthelion> wait, is there a lookup function that takes b and returns maybe a?
12:29:38 <edwardk> i can prove something exists sometimes but not construct one to hand to you. classical logic allows the former cases, the intuitionistic logic requires the latter.
12:29:39 <edwardk> the proof that something cannot not exist, doesn't necessarily provide you with a mechanism to generate it, intuitionistic logic is strictly weaker than classical
12:29:42 <magnus> roconnor: for example if you build a sequence by appending one element at a time you will not do any better than Data.Sequence
12:29:49 <tcr> EvilTerran: Indeed, very nice. Thank you!
12:29:57 <EvilTerran> no prob =]
12:29:59 <mauke> timthelion: http://rafb.net/p/lXmQ4878.html
12:30:00 <lambdabot> Title: Nopaste - No description
12:30:07 <qazwsx> dcoutts_ , matthew-_ : thanks
12:30:15 <edwardk> nomeata: afraid not, haskell is limited to the intuitionistic fragment of logic via curry howard.
12:30:30 <monochrom> There is a TMR article on how to use the Cont monad to do classical logic. As well as a crash course on how to do intuitionistic logic with pure functions.
12:30:44 <matthew-_> qazwsx: how much of your MMORPG are you planning on writing in Haskell?
12:30:58 <dcoutts_> sjanssen: right, the Maybe Editor give you a chain, but perhaps you want a tree? :-) I often get annoyed at undoing, making a change and then having lost the earlier changes I made but undid
12:31:01 <nomeata> edwardk: not even when I add an exiom such as â€œnotnot :: Not (Not a) -> a; notnot = undefinedâ€
12:31:15 <edwardk> nomeata: that you can do
12:31:28 <nomeata> afterall, thatâ€™s how I get my â€œvoidâ€ as well.
12:31:33 <sjanssen> dcoutts_: data Editor = Editor { left, right :: Rope, undo, redo :: [Editor] } -- done ;)
12:31:35 <dcoutts_> sjanssen: really an editor with undo (especially a collaborative one) should be based on the darcs model of patches
12:31:42 <doserj> but void is never executed
12:31:47 <doserj> notnot is
12:31:49 <timthelion> mauke: oo, much thanks
12:32:13 <nomeata> doserj: but for typechecking == proving, it doesnâ€™t matter, does it?
12:32:24 <magnus> sjanssen: nice data structure :)
12:32:25 <nomeata> (asuming notnot is considerd to be true)
12:32:27 <edwardk> nomeata: haskell itself is degenerate as logics go anyways, it has 'fix' so you can assume the hypothesis
12:32:28 <dcoutts_> sjanssen: ie lightweight mostly anonymous patches with a bit of merging of ajdacent changes (eg a sequence of inserts)
12:32:48 <sjanssen> dcoutts_: that's an interesting idea
12:32:50 <edwardk> fix and general recursion ensure all types are inhabited
12:32:57 <monochrom> http://www.haskell.org/sitewiki/images/1/14/TMR-Issue6.pdf  look for Dan Piponi's "Adventures in Classical-Land".
12:33:03 <EvilTerran> :t undefined :: a -> b
12:33:05 <lambdabot> a -> b :: forall a b. a -> b
12:33:08 <edwardk> @type fix
12:33:09 <lambdabot> forall a. (a -> a) -> a
12:33:21 <doserj> haskell is simply unsound as a theorem prover :)
12:33:29 <edwardk> 'if a implies itself, then a holds'.. obviously a fallacious argument =)
12:33:30 <sjanssen> dcoutts_: you might even use the monoid/measurement ideas from FingerTree to automatically generate the text of the document from the sequence of patches
12:33:38 <mauke> > fix id
12:33:40 <lambdabot>  Exception: <<loop>>
12:33:43 <nomeata> that would be my next question....
12:33:50 <roconnor> magnus: no, I totally agree that it will not work without merging small adjacent nodes during concatination
12:33:56 <dcoutts_> sjanssen: eek, sounds interesting :-)
12:34:02 <roconnor> magnus: and doing the merge will be easy
12:34:17 <roconnor> magnus: but I'm wondering, if C++ doesn' t do it
12:34:26 <roconnor> How did the C++ people get their preformance?
12:34:49 <qazwsx> C++ is high level assembly
12:34:52 <edwardk> nomeata: that said if you stick to the fragment without pattern match failures and with productive corecursion/well-founded recursion, haskell makes a good arena to think about these things.
12:35:03 <magnus> maybe it's time to look at the C++ source code *gulp*
12:35:12 <mattam> roconnor: apparently they did in the original impl.
12:35:15 <sjanssen> roconnor: the description seems to say that the C++ implementation *does* do it
12:35:33 <roconnor> sjanssen: how do you read that?
12:35:41 <edwardk> though, i'm sure mattam will probably tell you coq is better for that ;)
12:35:47 <mattam> At least in the Boehm paper.
12:36:07 <sjanssen> roconnor: "if the leaves in question are sufficiently short, we may either allocate a new leaf holding the combined contents of the two leaves or, under the right circumstances, even update the left operand in place"
12:36:35 <roconnor> sjanssen: ya, but look at the leaves in question.
12:37:27 <roconnor> sjanssen: it only works when the first argument is a leaf
12:37:31 <sjanssen> roconnor: yeah, "single leaf is concatenated onto the right of a rope which is either a leaf, or a concatenation node whose right child is a leaf, is handled specially"
12:37:44 <sjanssen> roconnor: but, because we're using FingerTree, we can do better :)
12:37:53 <nomeata> Iâ€™m still having problems to define proof3 :: (a -> b) -> Either (Not a) b, even with notnot. Or is notnot the wrong axiom to allow me to do classical proofs?
12:37:57 <roconnor> oh yes, we will do much better
12:38:01 <sjanssen> roconnor: it automatically gives us O(1) access to the leaves at each end
12:38:09 <roconnor> but what I remain confused about, is how the C++ people did their work?
12:38:22 <dcoutts_> for ropes, did they use cheap substring stuff? so that they can split a node without copying it?
12:38:28 <monochrom> Coq requires all recursions to terminate. You have to provide proof of termination.
12:38:35 <mattam> roconnor: apparently doing so repeateadly ensures that you have enough merging
12:38:49 <sjanssen> dcoutts_: yes, there's an explicit 'slice' node type
12:39:00 <monochrom> You don't need notnot.
12:39:12 <roconnor> mattam: repeatedly doing what?
12:39:16 <doserj> nomeata: can you do it with Either a (Not a) as an axiom?
12:39:21 <dcoutts_> sjanssen: ah yes I recall them having lots of node types, they've got one for lazy IO iirc :-)
12:39:24 <EvilTerran> dozer, dcoutts, thinking about it, don't infix declerations have to be in the same module as the decleration of the thing being infixed, as it's considered part of the decleration?
12:39:29 <edwardk> dcoutts: the original rope stuff had an indexing node that could slice an existing rope
12:39:32 <roconnor> monochrom: more specifically Coq requires all recursion to be structural.
12:39:33 <mattam> What sjanssen quoted
12:39:35 <newsham_> hmm, is it just coincidence that the fingertree paper uses similar notation as the endo spec?
12:39:42 <EvilTerran> might explain why infix _ `Foo.bar` doesn't work
12:39:46 <sjanssen> "(_Rope_RopeFunction) Function nodes. These contain a pointer to a function object that can be used to compute sections of the string."
12:40:04 <dcoutts_> sjanssen: ok, even more general than lazy IO
12:40:22 <dcoutts_> in fact it's just lazyness in general which we get for free
12:40:25 <roconnor> mattam: what sjanssen quoted only apply when the left argument is a single node.
12:40:55 <roconnor> newsham_: that notation is moderately standard.
12:40:59 <monochrom> Hold on. Intuitionistic logic can prove (Â¬a âˆ¨ b) â‡’ (a â‡’ b) but not (a â‡’ b) â‡’ (Â¬a âˆ¨ b) .
12:41:09 <mattam> I suppose concat uses addition of single nodes (like Finger Trees) too.
12:41:26 <nomeata> doserj: thx, that did it
12:41:31 <EvilTerran> monochrom, one more time in ascii?
12:41:49 <nomeata> proof3 :: (a -> b) -> Either (Not a) b
12:41:49 <nomeata> proof3 f = case eith of
12:41:49 <nomeata> 		Left a -> Right (f a)
12:41:49 <nomeata> 		Right na -> Left na
12:41:50 <mattam> I think adding the right code to add_left / add_right in the finger tree impl should do it.
12:41:54 <mauke> EvilTerran: (~a v b) => (a => b) but not (a => b) => (~a v b)
12:41:59 <roconnor> monochrom: sound about right.
12:42:08 <EvilTerran> ahh. ta, mauke.
12:42:11 <roconnor> mattam: :)
12:42:29 <Olathe> How do they prove the first ?
12:42:34 <mattam> Maybe also to the smart constructors for nodes but that may be tricky.
12:42:47 <nomeata> @djinn Either (Not a) b -> (a -> b)
12:42:49 <mattam> For add_
12:42:50 <lambdabot> f a b =
12:42:50 <lambdabot>     case a of
12:42:50 <lambdabot>     Left c -> void (c b)
12:42:50 <lambdabot>     Right d -> d
12:43:00 <mattam> * its pretty clear.
12:43:07 <nomeata> (that was for Olathe :-) )
12:43:10 <roconnor> mattam: where is the source that you are looking at?
12:43:20 <mattam> For Finger Trees ?
12:44:05 <roconnor> yes
12:44:09 <mattam> Mine :) Or the one from Ross's website
12:44:15 <monochrom> Here is one way of looking at intuitionistic logic. http://www.cs.utexas.edu/users/EWD/transcriptions/EWD12xx/EWD1219.html or http://www.cs.utexas.edu/users/EWD/ewd12xx/EWD1219.PDF
12:44:17 <lambdabot> Title: E.W. Dijkstra Archive: "I have a proof that...." (EWD 1219), http://tinyurl.com/3xmqy6
12:44:21 <roconnor> I was lookin on ross's website
12:44:24 <Olathe> I don't know how to read that as a proof.
12:44:25 <roconnor> I didn't see add_left
12:44:33 <doserj> nomeata: "eith" in your proof3 would typically be called "lem" (law of excluded middle)
12:44:38 <mattam> Hmm...
12:44:46 <nomeata> doserj: thx
12:45:06 * nomeata tries to prove (Not (Not a) -> a) given Either a (Not a) now.
12:45:09 <tcr> Why is it `([]) :: forall a. [a]' and not `([]) :: forall a. a -> [a]'?
12:45:31 <monochrom> Because ([]) is not a function.
12:45:40 <magnus> roconnor: looking at the C++ source code, push_front char seq = append (singleton char) seq
12:45:40 <sjanssen> I think the only thing you need to compact rope nodes is to wrap concatenation (><)
12:45:47 <mattam> roconnor: <| if you prefer
12:45:48 <monochrom> [] is the empty list. ([]) is [].
12:45:50 <nomeata> @djinn a -> Not (Not a)
12:45:50 <lambdabot> f a b = b a
12:45:59 <edwardk> @djinn (Either a (Not a)) -> (Not (Not a)) -> a
12:45:59 <lambdabot> f a b =
12:45:59 <lambdabot>     case a of
12:45:59 <lambdabot>     Left c -> c
12:45:59 <lambdabot>     Right d -> void (b d)
12:46:02 <edwardk> done =)
12:46:12 <Olathe> @help djinn
12:46:12 <lambdabot> djinn <type>.
12:46:13 <lambdabot> Generates Haskell code from a type.
12:46:13 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
12:46:17 <roconnor> magnus: (singleton char) is a leaf node, I agree that case is optimized
12:46:40 <monochrom> Which type constructor does @djinn know?
12:46:48 <edwardk> @djinn-env
12:46:48 <lambdabot> data () = ()
12:46:48 <lambdabot> data Either a b = Left a | Right b
12:46:48 <lambdabot> data Maybe a = Nothing | Just a
12:46:48 <lambdabot> data Bool = False | True
12:46:48 <lambdabot> data Void
12:46:50 <lambdabot> type Not x = x -> Void
12:46:50 <edwardk> just those
12:46:51 <tcr> monochrom: Alright makes sense. It's a "nullary" constructor so to speak, isn't it?
12:46:52 <lambdabot> class Eq a where (==) :: a -> a -> Bool
12:46:59 <roconnor> monochrom: I find it helpful to think in terms of a topological mode of intuistionistic logic: <http://r6.ca/blog/20060315T094400Z.html>
12:47:02 <monochrom> Yes tcr
12:47:28 <monochrom> Saidly I don't know topology.
12:47:43 <roconnor> monochrom: oh ... nevermind then.
12:48:11 <monochrom> But I know lattice theory, which is the next best thing.
12:48:30 <hpaste>  nomeata pasted "some classical proofs" at http://hpaste.org/1864
12:48:48 <nomeata> Just pasted those proves we have atm. thanks for all your input!
12:49:30 <roconnor> mattam: are you sure append doesn't need to be modifed?
12:49:31 <monochrom> The LEM is very powerful.
12:49:55 <roconnor> monochrom: not really.
12:49:59 <EvilTerran> remind me... i seem to recall putting class contexts on data declerations is usually not what one wants. why?
12:50:00 <sjanssen> mattam: it's probably better to handle (><) only, and express (<|) and (|>) in terms of singleton and (><)
12:50:09 <doserj> monochrom: it only looks powerful
12:50:21 <monochrom> haha ok
12:50:48 <mattam> append uses <| and |> at its base cases.
12:50:52 <EvilTerran> you can deduce LEM from RAA, ||intro, and some other stuff...
12:51:08 * monochrom conjures "The Axiom of Choice monad"...
12:51:12 * EvilTerran likes that proof
12:51:30 <mattam> Alternatively, you could modify append but that's the ugliest part of the implementation
12:51:37 <sjanssen> mattam: right.  I'm saying that the rope code should never call <| or |> directly
12:52:33 * dozer wonders how much green tea is too much
12:52:33 <sjanssen> mattam: I'm arguing that it's best to create a specialized append, that's used as a smart constructor
12:52:51 <sjanssen> of course it will have to hand off to the base append
12:53:02 <mattam> Ok. Well sharing may have to happen a little deeper inside the tree...
12:53:16 <mattam> I'm not sure which is best.
12:54:32 <sjanssen> can't you do all compression during append or left/right insertion?
12:55:04 <roconnor> mattam: intresting, you seem to be right.
12:55:14 <monochrom> @djinn (Not (Not a) -> a) -> Either a (Not a)
12:55:15 <sjanssen> you might also avoid fmap-like operations
12:55:19 <lambdabot> -- f cannot be realized.
12:55:44 <monochrom> Ah! I have to introduce some creativity.
12:56:03 <monochrom> @djinn (Not (Not b) -> b) -> Either a (Not a)
12:56:03 <lambdabot> -- f cannot be realized.
12:56:29 <mattam> sjanssen: indeed, but append is not implemented just that easily that you can get most sharing by just wrapping it.
12:57:11 <sjanssen> mattam: I don't see how
12:58:30 <mattam> Well, have a look at the implementation. It does a lot of rebalancing.
12:58:30 <roconnor> what wait is the sharing issue?
12:58:40 <jethr0> hello #haskell
12:58:56 <mattam> s/sharing/merging/
12:59:14 <sjanssen> mattam: why is rebalancing important wrt. merging small strings?
12:59:51 <mattam> "Rebalancing" could help merge more.
13:00:17 <roconnor> mattam: if append always merges, then there will never be small internal nodes
13:00:35 <koala_man> how can I parse a date like "Tue Jul 24 19:58:30 UTC 2007"? I looked at System.Time which had things for formatting, but for some reason I can't find parsing
13:01:02 <sjanssen> mattam: I don't think rebalancing can help merge more, as long as we ensure that adjacent strings are maximally merged
13:01:14 <mattam> Then there's splitting.
13:01:31 <sjanssen> mattam: we can ensure that by making append merge the shared fringe, when possible/desirable
13:02:04 <roconnor> @docs Data.Time
13:02:05 <lambdabot> Data.Time not available
13:02:25 <mattam> Indeed.
13:02:37 <roconnor> http://www.haskell.org/ghc/docs/latest/html/libraries/time/Data-Time-Format.html
13:02:39 <lambdabot> http://tinyurl.com/35mu4q
13:03:12 <roconnor> mattam: what's wrong with splitting?
13:03:38 <koala_man> thanks
13:03:42 <mattam> It also constructs, by calling deep, a smart constructor
13:04:06 <mattam> So you may whish to merge there too.
13:04:33 <roconnor> mattam: splitting will never lead to wanting to merge small nodes
13:05:09 <roconnor> mattam: all operations will maintain the invarient that only the left most and right most nodes can be small.
13:05:16 <sjanssen> mattam: I can't imagine a time we'll need to merge individual chunks during 'deep', if shared fringes have already been merged during append
13:05:35 <sjanssen> roconnor: that invariant may be a bit too strong
13:05:35 <mattam> Ok, you got me convinced :)
13:05:49 <roconnor> sjanssen: how so?
13:05:55 <sjanssen> roconnor: consider fromChunks [huge, tiny, huge]
13:06:07 <sjanssen> roconnor: where 'huge' is 1GB
13:06:12 <roconnor> crap!
13:06:22 <mattam> I just need a formal proof now :)
13:06:35 <mauke> wtf
13:06:38 * mattam goes to eat
13:06:44 <mauke> my haskell program sometimes is killed by SIGFPE
13:06:52 <mauke> how the hell do I debug that?
13:07:09 * roconnor rewrite rope
13:07:09 <sjanssen> roconnor: I think the better invariant is: length x + length y >= chunkSize, where x and y are adjacent
13:07:12 <monochrom> It is very hard to get a SIGFPE
13:07:14 <edwardk> mauke: by telling Dan to stop? ;)
13:07:31 <roconnor> sjanssen: sounds good
13:07:38 <roconnor> sjanssen: boy, you're smart
13:07:51 <sjanssen> roconnor: I've thought about these issues before ;)
13:08:04 <roconnor> sjanssen: you write fromList then :P
13:08:20 <sjanssen> fromList = foldr append empty
13:08:24 <mauke> curse you, dpiponi
13:08:27 <sjanssen> the trickiness is all in append
13:09:08 <roconnor> oh yeah
13:09:11 <roconnor> ha ha
13:09:12 <roconnor> I get it
13:10:37 <mauke> monochrom: I don't even use `div` or `mod`
13:11:14 <monochrom> div and mod won't cause SIGFPE.
13:11:39 <monochrom> err I don't know.
13:11:43 <edwardk> sjanssen: Am I overhearing a sort of revival of your earlier goal of getting a generic rope data structure for haskell?
13:11:57 <roconnor> revival?
13:12:14 <edwardk> i could have sworn he was obsessed about it a year ago
13:12:46 <roconnor> last year!!!!
13:12:55 <roconnor> god damn it
13:12:56 <sjanssen> well, it was part of my SoC last year, but it wasn't finished
13:13:17 <sjanssen> roconnor: it's okay, I didn't get very far at all
13:13:22 <edwardk> heh
13:13:24 <roconnor> we could have won the contest :'(
13:13:36 <edwardk> the ropes in question are intended to be lazy?
13:14:49 <edwardk> i wonder if an abuse of phantom types could carry around the 'resize here' 'merge these there' constraints without runtime overhead for some cases.
13:15:00 <edwardk> for known length fragments
13:15:22 <edwardk> where you know the length allocate arrays, etc.
13:16:40 <hpaste>  sjanssen pasted "beginnings of a chunk compressing rope" at http://hpaste.org/1865
13:16:53 <sjanssen> edwardk: I don't see a good way to do lazy ropes
13:17:08 <sjanssen> edwardk: because length is required for proper indexing
13:17:19 <sjanssen> and balancing, I suppose
13:18:05 <hpaste>  sjanssen annotated "beginnings of a chunk compressing rope" with "extra line" at http://hpaste.org/1865#a1
13:18:08 <edwardk> for efficient indexing and balancing anyways. wondering if they can be 'kitchen-sinked' together, then have just the parts that have nice properties satisfy those goals.
13:18:41 <bos> wow, i just received my first piece of haskell employment spam.
13:19:08 <roconnor> Are instances always exported?
13:19:11 <sjanssen> edwardk: well, if you don't care about balancing: data Rope = Append Rope Rope | Leaf ByteString
13:19:13 <sjanssen> roconnor: yes
13:19:16 <roconnor> fuck
13:19:23 <edwardk> roconnor: yep, can't avoid it
13:19:37 <roconnor> instance Measure (Sum Int64) B.ByteString is presumably unacceptable.
13:19:54 <roconnor> I'll have to make my own Monoid.
13:20:10 <EvilTerran> newtype?
13:20:11 <sjanssen> roconnor: you should probably use a newtype around ByteString
13:20:27 <edwardk> sjanssen: that kind of defeats the purpose. i was thinking about measured and unmeasured fragments. where measured fragments balance, and unmeasured fragments only balance if they acquire a measure by having their length walked
13:20:41 <edwardk> if you never look at it you never balance it
13:20:44 <roconnor> sjanssen: oh right, it has to go that way
13:20:50 <dcoutts_> edwardk: mm, interesting, so we could have unevaluated tails?
13:20:51 <roconnor> then I don't need my own monoid.
13:21:07 <sjanssen> edwardk: so you'd have to use mutability, probably
13:21:17 <dcoutts_> edwardk: if we can do that efficiently then we may not need a separate ByteString.Lazy
13:21:22 <roconnor> newtype Chunk = Chunk B.ByteString
13:21:49 <roconnor> newtype Chunk = Chunk { unChunk :: B.ByteString}
13:24:23 <roconnor> Illegal instance declaration for `F.Measured (Sum Int64) Chunk'
13:24:31 <roconnor> should I used GHC extensions?
13:24:37 <sjanssen> roconnor: yes
13:24:38 <roconnor> ... sure why not.
13:24:45 <roconnor> It won't be exported anyways
13:24:57 <sjanssen> roconnor: Measured is a MPTC
13:25:24 <roconnor> good point
13:25:27 <roconnor> oh
13:31:11 <edwardk> dcoutts, sjanssen: yeah
13:33:00 <edwardk> I'd be perfectly happy with it dangling an extra phantom type parameter off the end of it that indicates if it has a known measure at the type level, or the term level
13:36:26 <newsham_> this fingertree paper is deep.  my mind is expanding.
13:37:29 <dozer> how do I go about getting rid of an "Inferred type is less polymorphic than expected" error?
13:38:05 <mauke> depends on your code
13:38:09 <monochrom> erase the whole source code file?
13:38:30 <roconnor> monochrom: ?
13:38:39 <EvilTerran> dozer, could you paste something?
13:38:46 <monochrom> to get rid of all the world's errors :)
13:38:49 <roconnor> newsham_: hmm, maybe I should really read it.
13:39:05 <roconnor> monochrom: not so helpful.
13:39:37 <dozer> EvilTerran: ok, but it's ugly as sin :)
13:39:55 <edwardk> newsham: finger trees are just 2-3 trees where you grab the nodes at the ends and 'lift them up' using the zipper trick to get a data structure that vaguely resembles a bat.
13:40:02 <EvilTerran> it's haskell, how bad could it be, right?
13:40:26 <hpaste>  dozer pasted "polymorphic problem" at http://hpaste.org/1866
13:40:58 <newsham_> edwardk: its really their elegant notation (defining measures arbitrarily, defining split primitive, then applying that to sequences and priority queues) that I find really interesting
13:41:07 <newsham_> they did an excellent job of making this elegant
13:41:08 <monochrom> I'm probably the only one in the whole Haskell community to believe that helpfulness of responses should be proportional to completeness of questions.
13:41:10 <edwardk> yeah
13:41:16 <EvilTerran> O.O
13:41:31 <dozer> :$
13:41:49 <newsham_> mono: my question is NP complete.  I expect a recursively enumerable answer.
13:41:53 <augustss> monochrom: you're so cruel :)
13:42:14 <edwardk> sjanssen: looking at your code, i do note there is a certain simplicity to working with just a fingertree of bytestrings though =)
13:42:22 <EvilTerran> dozer, has that been truncated?
13:42:24 <monochrom> Well, questions aren't static. The questioner can incrementally add stuff after the first round.
13:42:49 <dozer> EvilTerran: looks like it has been
13:42:58 <EvilTerran> paste the rest in an annotation?
13:43:19 <Heffalump> monochrom: I agree with that
13:43:34 <roconnor> I beat augustss at the ICFP: This either means I should take his job at Credit Suisse, or I have far too much free time on my hands :P
13:43:56 <hpaste>  dozer annotated "polymorphic problem" with "and the rest" at http://hpaste.org/1866#a1
13:44:13 <Heffalump> roconnor: we are still hiring, there's room for both of you :-)
13:44:14 <newsham_> hows your econometrics, roconnor?
13:44:27 <edwardk> roconnor: which of course in the latter case having his job at credit suisse would probably immediately rectify.
13:44:47 * wli is not very far along in his study of Malliavin calculus.
13:45:25 <roconnor> newsham_: Actually, I've been getting interested in it recently.
13:45:37 <roconnor> ever since I discovered Kelly's criterion.
13:45:37 * wli is not ready for econometrics.
13:45:53 <roconnor> Heffalump: you work there too?
13:46:29 <Heffalump> yes
13:46:31 * wli is not really even ready for Haskell given his ignorance/incompetence/etc. at using Haskell's unique features.
13:46:37 <roconnor> newsham_: unless econometrics is actually a techinical term, in which case, I have no idea what you are talking about.
13:46:39 <Heffalump> you didn't beat me in the contest, but only cos I didn't enter :-)
13:47:11 <roconnor> Heffalump: Sadly I need to finish my thesis first.
13:47:12 <augustss> roconnor: where you in the 27 crowd, or did you do better?
13:47:22 <roconnor> ... which makes me wonder why I have so much free time...
13:47:30 <roconnor> augustss: ended up 32nd
13:47:59 <augustss> cool.  did you use Haskell?
13:48:36 <EvilTerran> dozer, well, that's a monstrosity of an error, but from what i can tell, the problem is that something is typed "forall individualI", but the actual type represented by individualI is deducible
13:49:28 <hpaste>  roconnor pasted "Rope append" at http://hpaste.org/1867
13:49:38 <roconnor> augustss: of course.
13:49:40 <roconnor> :)
13:50:13 <augustss> I wonder if they constructed the problem so we could use Data.Sequence? :)
13:50:15 <dozer> EvilTerran: ok - so individualI is free to range in one place, but pinned in another?
13:50:33 <newsham_> roconnor: econometrics is the branch of economics having to do with statistics
13:50:46 <newsham_> http://en.wikipedia.org/wiki/Econometrics
13:50:46 <roconnor> augustss: I thought they constructed the problem so we could use ByteString.Lazy.
13:50:48 <lambdabot> Title: Econometrics - Wikipedia, the free encyclopedia
13:51:18 <dozer> EvilTeran: that usually happens to me when I've miss-typed something somewhere ...
13:51:28 <augustss> but Data.Sequence has all the operations of their sequences
13:51:30 <roconnor> sjanssen: Rope append pasted.
13:51:51 <dcoutts_> roconnor: I think augustss is closer, kosmikus suggested as much
13:51:52 <monochrom> EvilTerran, dozer: one possibility I see is that there is "S.Set individualI" which may constrain individualI to a certain class. Is S.Set the same as Data.Set.Set?
13:51:54 <roconnor> augustss: what sort of object did you put in your sequences?
13:52:40 <EvilTerran> dozer, yeah. also monochrom probably knows what he's talking about more than I.
13:52:41 <dozer> monochrom: yeah, I'm importing Data.Set as S
13:52:54 <monochrom> I am particularly concerned with: Quantified type variable `individualI' is mentioned in the environment: isSubsetOf :: S.Set individualI -> S.Set individualI -> Bool
13:53:20 <augustss> roconnor: bases, rna, patterns, templates
13:53:21 <mauke> augustss: did you get my mail re: Text.Printf?
13:53:32 <augustss> mauke: recent?
13:53:37 <dozer> monochrom: I think that's being induced by a call to `isSubsetOf`
13:53:53 <mauke> 2007-07-03
13:53:56 <monochrom> Yes. Its presence may narrow things down.
13:54:43 <roconnor> augustss: doesn't Seq Base consume a lot of memory for 74K of Base pairs.
13:54:45 <monochrom> Maybe adding "Ord individualI" helps. If not, I don't know.
13:55:20 <augustss> roconnor: not really a problem.  i always try the simplest way first, if that doesn't work i optimize
13:55:20 <dozer> no joy on that one
13:56:09 <augustss> mauke:  hmmm, can you resend it?  maybe it got caught in the spam filter.  i have fixed many bugs in printf, but it doesn't seem to have made it into the library yet
13:56:28 <roconnor> augustss: are you saying that Seq Base works!?
13:56:32 <mauke> augustss: see http://hackage.haskell.org/trac/ghc/ticket/1548 then
13:56:33 <lambdabot> Title: #1548 (printf bugs) - GHC - Trac
13:56:51 <augustss> roconnor: of course
13:57:28 <roconnor> I don't get it. When my lazy bytestrings were chopped into bits, my memory use skyrocketed.
13:57:31 <augustss> roconnor: it takes a few seconds to slurp in the file, but then it's fast
13:57:42 <roconnor> ... how much RAM do you have?
13:58:01 <augustss> 1G
13:58:14 <roconnor> I don't belive it.
13:58:18 <roconnor> how could this be?
14:00:56 <dozer> monochrom: narrowed it down a bit - it's not unifying the individualI at the end of the Extension type expression with that arrising from the use of .^ (an operator defined in the Extension class)
14:02:25 <bobo> anyone ever tried this script?  http://www.pressurespot.com/
14:02:26 * roconnor modifies his code to use Seq Base
14:02:26 <lambdabot> Title: PressureSpot.com - We bring a whole new meaning to the phrase "getting head"!
14:03:00 <therp> spam?
14:03:11 <sjanssen> roconnor: Seq isn't flexible enough to support efficient indexing
14:03:26 <oerjan> @botsnack
14:03:26 <lambdabot> :)
14:03:31 <EvilTerran> therp, indeed.
14:03:32 <oerjan> lambdabot++
14:03:42 <benny99> mauke: do you have an idea where to continue now?
14:03:55 <EvilTerran> any ops about?
14:03:59 <monochrom> That probably escalates the problem to the level of MPTC inference. I'm particularly weak at that.
14:03:59 --- mode: ChanServ set +o sjanssen
14:04:20 <sjanssen> aww, bobo already left
14:04:25 <roconnor> sjanssen: that seems like a failure
14:04:27 <EvilTerran> can still +b the IO...
14:04:29 <EvilTerran> *IP
14:04:31 <oerjan> smot guy
14:04:31 <augustss> roconnor: max memory use is 500M, and it takes 180s to run on the original DNA
14:04:39 <mauke> benny99: continue what?
14:04:40 <roconnor> :'(
14:04:46 <roconnor> It took me 15 min
14:04:55 <roconnor> But I use much less memory
14:04:57 <benny99> mauke: continue to learn Haskell and about Monads
14:05:08 <augustss> memory is cheap
14:05:13 <roconnor> I don't get why Lazy Bytestrings were so bad then?
14:05:26 <roconnor> they shouln't have worse memory use than Seq should they?
14:05:30 <mauke> benny99: well, you could try to figure out what sequence ["abc", "DEF"] does and why
14:05:44 <benny99> mauke: ok :)
14:05:45 <mauke> benny99: or have a look at the Reader monad
14:05:48 --- mode: ChanServ set -o sjanssen
14:05:49 <Philippa> depends how much thunking's going on, no?
14:06:08 <benny99> mauke: if you feel like in a personal trainer role, I'm sorry, just tell me :-[
14:06:09 <augustss> roconnor: but you're giving them a hopeless task.  to have all those operation execute with low complexity you need a fancy data structure
14:06:20 <benny99> mauke: ok, I will
14:07:37 <SamB> roconnor: lazy bytestrings were so bad because you didn't start with one chunk probably
14:07:43 <SamB> they're only fairy bad for me ;-)
14:08:00 <roconnor> oh
14:08:13 <SamB> 80% of time in my dna2rna is spent in the search function, but probably because it is totally naive...
14:08:36 <SamB> anyway, my dna2rna typically uses 22MB
14:08:39 <roconnor> My Lazy Bytestring implemnation causes my computer to thrash.
14:09:01 <SamB> I fixed that by reading a strict bytestring and making a lazy one with that as the sole chunk
14:09:10 <dcoutts_> SamB: the normal ByteString substring search is extremely slow
14:09:18 <SamB> dcoutts: it has one?
14:09:21 <dcoutts_> SamB: and there is no .Lazy substring search
14:09:24 <SamB> ah.
14:09:30 <SamB> well, see, this is what I did:
14:09:44 <SamB> searchFrom n needle haystack =
14:09:44 <SamB>     msum $ map (return . fst) $ filter ((needle `LB.isPrefixOf`) . snd) $
14:09:44 <SamB>     zip [n..] (LB.tails (LB.drop n haystack))
14:10:06 <dcoutts_> looks slow :-)
14:10:10 <SamB> indeed it is
14:10:24 <SamB> that's why I'm using desp's dna2rna right now
14:10:47 <desp> my dna2rna has one problem; the search is naive
14:10:57 <magnus> my haskell dna2rna Segfaults
14:11:00 <desp> :)
14:11:04 <SamB> apparantly your naive search is less naive than mine?
14:11:09 <dcoutts_> magnus: wow
14:11:21 <desp> well, the TNT search is KMP
14:11:25 <desp> I'm replacing mine with it
14:11:51 <SamB> yes but I'm using your code from, almost 24 hours ago I think
14:12:00 <desp> yeah
14:12:10 <desp> I'm just surprised my search is faster than yours
14:12:12 <SamB> there was supposed to be an "oh, " in there
14:12:19 <dozer> monochrom: I think I need a dummy argument of type individualI to make things work out :(
14:12:42 <desp> findSubEnd :: ByteString -> ByteString -> Maybe Int
14:12:44 <desp> findSubEnd (BS !p l) (BS !q _) =
14:12:45 <desp>   let loop !s !n | L.isPrefixOf p s = Just $! (fromIntegral (n + l))
14:12:47 <desp>                  | L.null s         = Nothing
14:12:49 <desp>                  | otherwise        = loop (L.tail s) (n + 1)
14:12:51 <desp>   in loop q 0
14:12:57 <SamB> desp: you do have strictness annotations and so on
14:13:10 <SamB> perhaps mine will catch yours up when GHC gets stream lists
14:13:21 <SamB> list streams?
14:13:31 <SamB> whatever. the new fusion.
14:13:35 <monochrom> intriguing
14:13:39 <desp> oh, and I'm caching lengths
14:14:05 <SamB> ah.
14:14:59 <SamB> roconnor: oh, actually I also have a function that bunches up tiny chunks into bigger ones
14:15:11 <SamB> which I use on the template expansions
14:15:41 <SamB> it's probably a very good idea to have one
14:17:47 <roconnor> SamB: Ah ha!
14:18:07 <SamB> desp also has a function that does something like that afaict
14:18:14 <desp> yep
14:18:55 <desp> although I've found that using a simple function that bunches up the whole LPS into one chunk works better than attempting to chain the contents into a series of 32K chunks
14:19:03 <SamB> desp: hmm.
14:19:19 <desp> compare compact vs glob
14:19:22 <desp> in wrapper.hs
14:19:33 <desp> actually
14:19:39 <desp> just look at glob
14:19:44 <magnus> I'm getting sick of trying to implement dna2rna in haskell :( I keep getting lousy performance and now it segfaults
14:19:51 <desp> line 153
14:20:06 <benny99> magnus: that is programming :D
14:20:06 <mauke> magnus: heh, that's what happened to me when I tried to rewrite the haskell version in C
14:20:24 <desp> my best attempt at globbing is commented out, and replaced by [S.concat xs]
14:20:36 <monochrom> ghc also tries to rewrite your haskell version in C :)
14:20:43 <SamB> desp: I was considering doing that as well every so often
14:21:22 * desp pasted http://pastie.textmate.org/81860
14:21:25 <nopcode> what is dna2rna?
14:21:26 <magnus> how can haskell code segfault?
14:21:29 <SamB> I so happen to have a profile from my last run of my dna2rna (or so)
14:21:31 <magnus> well typed programs don't go wrong?
14:21:38 <Heffalump> were you doing something dodgy with Integers?
14:21:41 <Igloo> magnus: Do you use pointers or unsafe indexing or anything?
14:21:43 <Heffalump> gmp can segfault
14:21:44 <magnus> nopcode: an icfp2007 thing
14:21:49 <SamB> COST CENTRE                    MODULE               %time %alloc
14:21:49 <SamB> searchFrom                     DnaToRna              87.8   92.0
14:21:49 <SamB> string                         DnaToRna               6.6    4.6
14:21:49 <SamB> rnaHelper                      DnaToRna               1.4    0.8
14:21:49 <SamB> patternItem                    DnaToRna               1.2    0.8
14:21:50 <SamB> <|>                            DnaToRna               1.1    0.7
14:21:54 <magnus> Igloo: only lazy byte strings
14:22:19 <magnus> no bigints
14:22:58 <Igloo> If you put the code in a bug report then we can try to take a look some time. Try to make it as small as possible first, though
14:23:23 <magnus> it's kinda hard to narrow down
14:23:36 <magnus> it crashes at iteration 133 of dna2rna on endo.dna
14:23:37 <SamB> I'm guessing one of my biggest problems is that zip is not fused at the moment
14:23:43 <Heffalump> magnus: see if any external library is mentioned in the backtrace from gdb (if you're on Linux etc)
14:23:56 <magnus> Heffalump: oh, neat idea
14:24:09 <magnus> Heffalump: do I need some flag to add debug info?
14:24:36 <SamB> magnus: also see if you can replicate it after building with -prof -auto-all, running with +RTS -xc
14:24:38 <Heffalump> ghc won't produce anything useful, but you'll be able to tell if the segfault is in an external library cos it'll be mentioned by name
14:25:01 <SamB> hmm wait
14:25:03 <SamB> does that even work?
14:25:18 * SamB thinks it would be cool if it did
14:25:44 <Heffalump> does what work?
14:26:40 <SamB> nevermind, that won't work for a segfault...
14:26:59 <magnus> (gdb) bt
14:26:59 <magnus> #0  0x08066d90 in s3dn_info ()
14:26:59 <magnus> #1  0x080ab828 in MainCapability ()
14:27:39 <magnus> disassembly:
14:27:40 <magnus> 0x08066da8 <s3dn_info+40>:      movl   $0x8,0x70(%ebx)
14:27:40 <magnus> 0x08066daf <s3dn_info+47>:      mov    0xfffffff8(%ebx),%eax
14:27:40 <magnus> 0x08066db2 <s3dn_info+50>:      jmp    0x8066da6 <s3dn_info+38>
14:28:22 <magnus> the disassembly is not very useful
14:28:31 <SamB> indeed it is not
14:28:36 * magnus looks up what s3dn is
14:29:59 <Heffalump> ok, so it's in GHC generated code.
14:30:31 <magnus> could it be a bug in the bytestring lib?
14:31:15 <SamB> that disassembly doesn't seem to include the complained-of address
14:31:29 <magnus> it's only a small portion of the disassembly
14:31:41 <magnus> the wrong portion actually
14:32:02 <SamB> yeah
14:32:11 <Heffalump> you could look at the C--
14:32:13 <SamB> that would be my point ;-)
14:32:25 <Heffalump> but it's rarely illuminating
14:32:40 * Heffalump suggests cutting down the test case and sending it in
14:32:52 <Heffalump> assuming there's no unsafe stuff involved
14:33:15 <Heffalump> oh, which you said there wasn't
14:33:20 <SamB> Heffalump: there is ;-)
14:33:31 <SamB> but it isn't magnus' proof obligation
14:33:40 <Heffalump> ah, yes
14:33:45 <Heffalump> is this 6.6.1?
14:34:15 <hpaste>  magnus pasted "segfault" at http://hpaste.org/1868
14:34:44 <magnus> Heffalump: yes
14:35:49 <magnus> the assembly is an instruction that loads a char into an int32/
14:35:56 <magnus> zero-extending it
14:36:07 <magnus> looks like it's got something to do with bytestrings then
14:39:11 <magnus> eax is NULL
14:39:49 <magnus> and so is edx
14:40:58 <dozer> monochrom: it compiles now - thanks for your help
14:41:36 <dozer> monochrom: class SatisfiesS individualI interpretation s | interpretation -> individualI where (|-) :: interpretation -> s -> Bool
14:42:18 <dozer> monochrom: the trick was that interpretation will be parameterised with individualI later on, so it needs to be able to bind the *same* individualI as the other typeclasses
14:44:34 <dozer> monochrom: then I can capture the type individualI in the arguments, and coerce `isSubsetOf` to use this rather than 'a'
14:51:16 <mauke> writing an interpreter : writing a compiler  ::  I/O in other languages : I/O in Haskell
14:52:43 <basti_> .o° ( ? )
14:52:57 <SamB> but I thought writing an interpreter was *easier* than writing a compiler?
14:53:17 <mauke> they're the same thing
14:54:39 <wli> esp. w/JIT
14:55:39 <SamB> who ever heard of a compiler with JIT?
14:56:45 <Olathe> Any JIT is a compiler with JIT.
14:57:06 <ddarius> JIT isn't anything.  You have Just-In-Time -compilers-.
14:57:42 <mauke> whee, mouse controlled workspace switching
14:58:04 <magnus> where is newPinnedByteArray defined?
14:58:09 <dozer> no isDisjoint predicate on Data.Set?
14:58:31 <ddarius> You could intersect and check for an empty set.
14:59:09 * SamB writes a DNA compiler
14:59:25 <magnus> SamB: are you serious?
14:59:36 * ddarius helps conceive a DNA compiler.
14:59:40 <SamB> magnus: a tiny one!
14:59:42 <hpaste>  roconnor pasted "Ropes version 0.02" at http://hpaste.org/1869
14:59:48 <magnus> SamB: turning DNA into what?
14:59:54 <SamB> other way round
14:59:58 <magnus> phew
15:00:32 <SamB> maybe I'll try to do a partial decompiler too though
15:00:37 <magnus> Igloo: where is newPinnedByteArray defined? I think I may have narrowed the bug thence
15:00:48 <roconnor> sjanssen: Ropes version 0.02 pasted
15:01:38 <SamB> actually it's more of an assembler
15:02:40 <Botje> roconnor: sjanssen: sorry for bringing this up, but have you looked at the pugs project? ISTR they implement Ropes
15:02:59 <Botje> or at least audreyt talked about them
15:03:37 <Igloo> magnus: Without a #?
15:04:33 <roconnor> Firefox can't find the server at pugs.blogs.com.
15:06:17 <ddarius> Botje: I ran across that googling ropes.
15:07:12 <magnus> Igloo: yes
15:07:26 <Botje> http://darcs.pugscode.org/ # darcs repo
15:07:28 <lambdabot> Title: Index of /
15:07:35 <Botje> i'll darcs get it now and look for evidence of ropes
15:07:53 <ddarius> Botje: There is something in there at least claiming to be ropes related.
15:07:59 <magnus> @src newPinnedByteArray
15:07:59 <lambdabot> Source not found. Just what do you think you're doing Dave?
15:08:54 <magnus> Igloo: oh wait, it's with a #
15:08:57 <Botje> yeah.
15:09:07 <Botje> all it seems to have is "* Data.ByteString.Seq: first cut at a "Rope" data type."
15:09:09 <Igloo> magnus: In rts/PrimOps.cmm
15:09:12 <Igloo> magnus: newPinnedByteArrayzh_fast
15:09:16 <Botje> and that's from feb 2007
15:09:16 <magnus> Igloo: thanks
15:09:32 <roconnor> Botje: So I guess they don't have it?
15:10:03 <Botje> i'm guessing they have a crude implementation at best, but you should ask audreyt just to be sure :)
15:10:55 <roconnor> @seen audreyt
15:10:55 <lambdabot> audreyt is in #perl6, #haskell and #ghc. I don't know when audreyt last spoke.
15:11:13 <ddarius> @google site:pugscode.org rope
15:11:15 <Botje> (she's idle for 9 days now, probably on vacation)
15:11:16 <lambdabot> http://dev.pugscode.org/log/src/Data?rev=15366
15:11:16 <lambdabot> Title: /src/Data (log) - Pugs - Trac
15:11:37 <roconnor> heh, we can have a rope implemenation done before she gets back
15:11:42 <Botje> :)
15:11:50 <Botje> "here's a welcome back presen"
15:11:50 <benny99> mauke: now I cannot stop looking at that...
15:11:54 <diakopter> roconnor: she is convalescing, perhaps for a long time.  quite serious health issues.
15:12:37 <ddarius> Data.ByteString.Seq
15:12:42 <roconnor> diakopter: oh
15:12:52 <roconnor> I would have called it Data.ByteString.Rope
15:12:58 <roconnor> :)
15:13:35 <ddarius> roconnor: I'm calling mine simply Data.Rope
15:13:46 <diakopter> what is an english definition of a Rope?
15:14:15 <roconnor> how many people here are implementing Rope
15:14:19 <roconnor> raise your hands
15:14:22 <roconnor> o/
15:14:26 <benny99> \o
15:14:30 <ddarius> I started this before ICFP.
15:14:30 <Maddas> can't type with my hands up
15:14:30 <mauke>  a large stout cord of strands of fibers or wire twisted or braided together
15:14:32 <benny99> oh, wait, no
15:14:38 <benny99> just read to raise my hand :-[
15:14:45 <ddarius> @wn rope
15:14:47 <lambdabot> *** "rope" wn "WordNet (r) 2.0"
15:14:47 <lambdabot> rope
15:14:47 <lambdabot>      n 1: a strong line
15:14:47 <lambdabot>      2: street names for flunitrazepan [syn: {R-2}, {Mexican valium},
15:14:47 <lambdabot>          {rophy}, {roofy}, {roach}, {forget me drug}, {circle}]
15:14:49 <lambdabot>      v 1: catch with a lasso; "rope cows" [syn: {lasso}]
15:14:51 <lambdabot>      2: fasten with a rope; "rope the bag securely" [syn: {leash}]
15:14:55 <Botje> benny99: so what *DID* you raise? O_O
15:15:06 <benny99> Botje: I raised my hand
15:15:14 <benny99> Botje: :-[ because I didn't read the line above
15:15:16 <Botje> :)
15:15:17 <mauke> I see your hand and raise you an eyebrow
15:15:22 <diakopter> ddarius: hrm.
15:15:23 <roconnor> damn it, how many people started this BEFORE the ICPF?
15:15:32 <ddarius> Me.
15:15:40 <roconnor> couldn't one have finished :'(
15:15:50 <benny99> mauke: gnaaah, I already wrote, that I didn't read the line above, thought that was just a fun-action...
15:16:08 <benny99> mauke: and your "sequence ["abc", "DEF"]" makes me crazy
15:16:08 <ddarius> Except for rebalancing it is not all that incomplete.  Further, I started like a day or two before ICFP.
15:16:11 <shapr> gnaaah!
15:16:22 <mauke> a functional action?! isn't that an oxymoron?
15:16:24 <roconnor> ddarius: oh, not using fingertrees?
15:16:36 <ddarius> roconnor: A custom type.
15:16:51 <mauke> benny99: did you look at the source of sequence?
15:16:52 <Maddas> Yow, shapr!
15:16:57 <benny99> mauke: yeah
15:17:04 <mauke> @src sequence
15:17:04 <lambdabot> sequence ms = foldr k (return []) ms
15:17:04 <lambdabot>     where
15:17:04 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
15:17:05 <benny99> mauke: am trying to convert it
15:17:08 <mauke> eww
15:17:15 <benny99> mauke: and I just don't get it....
15:17:18 <ddarius> @src sequence_
15:17:18 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
15:17:58 <roconnor> past my bedtime
15:18:08 <EvilTerran> where's that PDF about type derivatives?
15:18:17 <EvilTerran> s/PDF/paper/
15:18:29 <roconnor> @go derivitives as a one hole context
15:18:30 <benny99> mauke: whatever, save your time, I'm going to sleep
15:18:31 <lambdabot> http://www.cs.nott.ac.uk/~ctm/diff.pdf
15:18:36 <EvilTerran> ta
15:18:41 <benny99> mauke: bye \o
15:18:46 <mauke> g'night
15:18:58 <chessguy> @type sequence_
15:19:00 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
15:19:20 <ddarius> Of course, sequence = foldr (liftM2 (:)) (return [])
15:20:51 <chessguy> @type liftM
15:20:53 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
15:23:53 <mauke> can we rename liftM to liftM1 and return to liftM0, please?
15:26:42 <oerjan> also, rename zipWith to zipWith2 and map to zipWith1.
15:27:24 <Botje> while we're at it: rename negate to -0 and - to -1
15:28:00 <EvilTerran> er...
15:28:20 <oerjan> not to forget zip -> zip2 and unzip -> unzip2
15:28:39 <mauke> and transpose to zip
15:28:54 <EvilTerran> zipN?
15:29:00 <oerjan> mauke: WHAT? THAT'S INSANE
15:29:04 <mauke> EvilTerran: or that
15:30:50 <EvilTerran> also, id should be (let f s = f s ++ f s in f "id")
15:31:23 <EvilTerran> > let f s = f s ++ f s in f "id"
15:31:31 <lambdabot>  Exception: <<loop>>
15:31:35 <EvilTerran> hurrah.
15:31:48 <EvilTerran> renaming id to <<loop>> it is, then.
15:33:06 <mauke> id = fmap fix return
15:33:11 <SamB> shouldn't negate be -1 and - be -2?
15:33:23 <mauke> > (fmap fix return) 42
15:33:24 <lambdabot>  42
15:33:28 <Botje> that'd be too logical.
15:33:33 <EvilTerran> what'd -0 be, then?
15:33:39 <SamB> 0
15:34:02 <EvilTerran> ... damnit, even in this weird thing we've got going here, that makes sense. touchÃ©.
15:34:40 <Botje> SamB: but people using one's complement will cry!
15:34:54 <dozer> what's a nice way to take a list like [a, b, c, d] and produce a list like [(a, b), (a, c), (a, d), (b, c), (b, d), (c, d)] that's the upper-right bit of zip (,) xs xs?
15:35:34 <SamB> Botje: they already do that ;-)
15:35:53 <SamB> hmm
15:36:09 <SamB> filter (uncurry (/=)) applied to the cross product?
15:36:09 <EvilTerran> dozer, do you mean liftM2 (,) xs xs?
15:36:16 <EvilTerran> > liftM2 (,) [1,2,3] [1,2,3]
15:36:17 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
15:36:20 <matthew-_> > let xs = [1,2,3,4] in do { x <- xs; y <- ys; return (x,y) }
15:36:21 <lambdabot>   Not in scope: `ys'
15:36:23 <EvilTerran> > zipWith (,) [1,2,3] [1,2,3]
15:36:24 <lambdabot>  [(1,1),(2,2),(3,3)]
15:36:25 <matthew-_> > let xs = [1,2,3,4] in do { x <- xs; y <- xs; return (x,y) }
15:36:27 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4),(3,1),(3,2),(3,3),(3,4),(4,...
15:36:42 <matthew-_> I win
15:36:45 <SamB> > filter (uncurry (/=)) $ liftM2 (,) [1,2,3] [1,2,3]
15:36:46 <lambdabot>  [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
15:36:52 <SamB> no, I win
15:37:02 <matthew-_> yeah, I'm wrong!
15:37:06 <augustss> > [(x,y) | x:xs <- inits [1,2,3,4], y<- xs]
15:37:08 <lambdabot>  [(1,2),(1,2),(1,3),(1,2),(1,3),(1,4)]
15:37:10 * matthew-_ eats humble pie
15:37:32 <EvilTerran> ack! i was just about to type that, augustss.
15:37:32 <augustss> bah
15:37:34 <SamB> ah!
15:37:50 <EvilTerran> ...it doesn't seem to be right, tho
15:37:51 * SamB loses after all
15:37:53 <augustss> > [(x,y) | x:xs <- tails [1,2,3,4], y<- xs]
15:37:54 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
15:37:58 <matthew-_> mine used the list monad. I should get points for that.
15:38:10 <kjdf> hi
15:38:15 <mauke> matthew-_ earns 5 silver points.
15:38:16 <SamB> mathrick: so did the one I stole
15:38:26 <SamB> hmm.
15:38:30 <EvilTerran> > do x:xs <- tails [1..4]; y <- xs; return (x,y)
15:38:31 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
15:38:34 <augustss> there are no bonus points for using monads in the channel
15:38:36 <kjdf> I am reading xmonad source, and I don't understand one bit of syntax
15:38:41 <SamB> mauke: wouldn't it be easier to just beat up gato?
15:38:42 <kjdf> what does this mean:
15:38:47 <dozer> augustss: that looks right
15:38:47 <EvilTerran> @undo do x:xs <- tails [1..4]; y <- xs; return (x,y)
15:38:47 * matthew-_ passes the silver points on to SamB
15:38:48 <lambdabot> tails [1 .. 4] >>= \ a -> case a of { x : xs -> xs >>= \ y -> return (x, y); _ -> fail ""}
15:38:50 <kjdf> let winset | ("--resume" : s : _) <- args
15:38:50 <kjdf>                , [(x, "")]            <- reads s = x
15:38:50 <kjdf>                | otherwise = ...
15:38:58 * SamB hands them to augustss 
15:39:01 <mauke> SamB: probably, but using monads would be a totally awesome way to level up
15:39:16 <mauke> kjdf: pattern guards
15:39:16 <SamB> mauke: you don't level up from silver points
15:39:20 <SamB> you level up from XP
15:39:21 <Botje> kjdf: could you use the pastebot please? that way we don't have to keep scrolling back and forth
15:39:21 <mauke> I know
15:39:39 <matthew-_> SamB: I hope augustss is going to invest them wisely and return them with great growth shortly
15:39:52 <EvilTerran> dozer, see what augustss wrote the second time. i think that does what you want.
15:39:55 <mauke> SamB: once I did level up by fighting gato
15:39:56 <augustss> i'm gonna exchange them for beer
15:40:01 <SamB> mauke: well yes
15:40:02 <mauke> I was too scared to leave the fair
15:40:12 <SamB> but you get XP from fighting gato too ;-)
15:40:19 <SamB> precious little XP, but still
15:40:30 <SamB> it's the damn beginning of the game!
15:40:32 <matthew-_> augustss: that sounds familiar! ;)
15:40:34 <hpaste>  (anonymous) annotated "-hc output" with "(no title)" at http://hpaste.org/1857#a1
15:40:54 <kjdf> uh
15:40:56 <kjdf> sorry.
15:40:58 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1870
15:41:23 <kjdf> specifically, what does '<-' mean in pattern guard
15:41:30 <mauke> kjdf: binding
15:41:35 <kjdf> and the comma lined up with '|'
15:41:42 <mauke> that
15:41:47 <mauke> that's pattern guard syntax
15:41:58 <mauke> kjdf: http://haskell.org/haskellwiki/Pattern_guard
15:42:00 <lambdabot> Title: Pattern guard - HaskellWiki
15:43:12 <SamB> what's a good name for f :: Monad m => m a -> m b -> m a; f p q = do x <- p; q; return x
15:43:13 <SamB> ?
15:43:40 <sjanssen> SamB: that's almost like finally
15:43:44 <sjanssen> @hoogle finally
15:43:45 <lambdabot> Control.Exception.finally :: IO a -> IO b -> IO a
15:44:06 <SamB> sjanssen: hmm.
15:44:12 <mauke> SamB: <<
15:44:17 <SamB> mauke: hmm.
15:44:18 <shapr> Maddas: YOW!
15:44:24 <sjanssen> mauke's is better
15:44:38 <SamB> but that clashes with =<<
15:44:46 <SamB> which is just flip (>>=)
15:44:47 <mauke> value = token '(' >> expr << token ')'
15:44:55 <mauke> I don't use =<<
15:45:05 <mauke> and << looks totally sweet in monadic parsers
15:45:16 <SamB> very well
15:45:16 <sjanssen> ah, that's true -- the execution order makes (<<) the wrong choice
15:45:25 <SamB> sjanssen: have any better ideas?
15:45:28 <SamB> <<= ?
15:45:42 <ddarius> liftM2 const
15:45:54 <SamB> ddarius: that isn't infix ;-)
15:46:02 <sjanssen> @. pl undo \p q = do x <- p; q; return x
15:46:02 <lambdabot> (line 1, column 21):
15:46:02 <lambdabot> unexpected "{"
15:46:02 <lambdabot> expecting variable, "(", operator or ")"
15:46:20 <mauke> @. pl undo \p q -> do x <- p; q; return x
15:46:20 <lambdabot> (. ((. return) . (>>))) . (>>=)
15:46:22 <sjanssen> @. pl undo \p q -> do x <- p; q; return x
15:46:22 <lambdabot> (. ((. return) . (>>))) . (>>=)
15:46:53 <thoughtpolice> anybody know why lambdabot would fail in the context of just doing something like:
15:46:55 <sjanssen> SamB: before?
15:46:56 <thoughtpolice> > 1 + 1
15:46:57 <lambdabot>  2
15:46:59 <thoughtpolice> ?
15:47:02 <sjanssen> x `before` q
15:47:20 <SamB> sjanssen: I guess so
15:47:35 <thoughtpolice> in the case of just doing something like '1+1' lambdabot reports: eval module failed in contextual handler: IRCRaised Data.ByteString.last: empty ByteString
15:47:52 <sjanssen> x `followedByForgettingTheResultOf` q?
15:48:04 <kjdf> aah, ok. *pattern* guards, not your regular guards :)
15:48:06 <kjdf> thanks
15:48:10 <mauke> you must accept <<
15:48:16 <SamB> sjanssen: I might as well just use do bindings!
15:48:28 <mauke> it is the one true name
15:48:37 <SamB> fine, I'll use <<=
15:48:42 <sjanssen> mauke: but it isn't flip (>>)
15:48:49 <mauke> sjanssen: exactly
15:48:53 <sjanssen> mauke: which could surprise readers
15:48:53 <mauke> it shouldn't be flip (>>)
15:49:04 <sjanssen> mauke: see (=<<)
15:49:10 <matthew-_> <=< ?
15:49:12 <mauke> =<< is misnamed, then
15:49:13 <SamB> sjanssen: he's in the (=<<)-haters camp
15:49:26 <sjanssen> how could you hate =<<?
15:49:33 <ddarius> I never use =<<
15:49:44 <matthew-_> but it fits better with composition
15:49:50 <matthew-_> you can just read the line right to left
15:49:56 <mauke> f =<< m = mdo y <- f x; x <- m; return y
15:50:08 <ddarius> I don't speak Hebrew
15:50:21 <ddarius> (or I guess reading is the relevant thing here)
15:50:23 <matthew-_> then you don't use (.) ?
15:50:43 <SamB> so what if you don't read hebrew
15:50:58 <SamB> why do you want to read from beginning to end anyway?
15:51:14 <matthew-_> and this is why people top post!
15:51:17 <sjanssen> that is the English convention
15:51:23 <sfultong> yeah, why can't we do function application the opposite way, left to right?
15:51:29 <EvilTerran> i don't read hebrew? don't ×‘ on it!
15:51:29 <sfultong> by default, that is
15:51:39 <EvilTerran> :D
15:51:46 * matthew-_ lights match and runs off. Dance my pretties, dance!
15:52:06 <mauke> sfultong: that leads to heresy and forth
15:52:25 <matthew-_> forth ? as in the programming language?
15:52:28 <sfultong> forth, eh?
15:52:42 * sfultong goes to get blasphemous
15:52:44 <chessguy> what, there's a canadian version of forth?
15:52:50 <ddarius> Or joy
15:52:59 <sfultong> yeah, we should talk about joy more
15:53:05 <sfultong> it seems neat
15:53:17 <matthew-_> sfultong: I hear it's overrated
15:53:19 <chessguy> joy, peace and harmony!
15:53:23 * chessguy lights some candles
15:53:35 <sfultong> matthew: overrated, or underlibraried?
15:54:09 <matthew-_> sfultong: http://hackage.haskell.org/packages/archive/joy seems to give 404
15:54:11 <magnus> a concatenative language without state is hard for me to imagine using
15:54:54 <magnus> perhaps if you build something like monads in it it'll be nice
16:22:33 <desp> say I have a type that's an instance of Show
16:22:45 <desp> and I want to overload its show function
16:22:51 <desp> what's the best way to do so?
16:23:19 <mauke> what do you mean by "overload"?
16:23:27 <desp> replace it with my own
16:23:29 <Igloo> If the actual type already has a Show instance then all you can do is newtype it
16:23:33 <sjanssen> desp: you can't override an instance directly
16:23:39 <desp> yeah
16:23:42 <desp> so I'm doing
16:23:49 <desp> newtype Foo2 = F2 !Foo1
16:23:54 <desp> and -funbox-strict-fields
16:24:01 <mauke> is that ! legal there?
16:24:07 <sjanssen> desp: I don't think ! is legal there
16:24:11 <Igloo> That ! and -funbox-strict-fields are pointless
16:24:13 <sjanssen> desp: and it's certainly meaningless
16:24:30 <sjanssen> desp: 'newtype' adds zero overhead by design
16:24:32 <desp> okay, actually I was doing that in a data type, not a newtype
16:24:36 <Igloo> GHC had a bug where it allowed it; I don't remember if it was in a released compiler or not
16:24:39 <desp> ahha
16:24:41 <sjanssen> newtype is probably better
16:24:56 <desp> but in a data type, those two are a good idea?
16:25:03 <mauke> instance Show Foo2 where show (F2 x) = ...
16:25:11 <sjanssen> desp: yes, but newtype is better
16:25:17 <desp> mauke: yes, yes :)
16:25:25 <desp> sjansen: yes, but I need to add another field in another case
16:25:32 <sjanssen> desp: because GHC can't unpack data types with multiple constructors
16:25:35 <desp> okay, thans.
16:26:00 <desp> s/ns/nks/
16:26:15 <wli> It'd obviously have to infer which constructor to do so.
16:26:42 <lpz> [1..3]
16:26:53 <mauke>  [1,2,3]
16:27:04 <lpz> is that the bot?
16:27:16 <sjanssen> mauke: @botsnack
16:27:19 <mauke>  :)
16:27:23 <desp> > [1..3]
16:27:24 <lambdabot>  [1,2,3]
16:27:36 <sjanssen> lpz: no, mauke is being tricky ;)
16:27:39 <lpz> i'm trying to join two lists
16:27:50 <mauke> > [1..3] ++ [1..3]
16:27:51 <lambdabot>  [1,2,3,1,2,3]
16:27:54 <lpz> something like [1..3]:[3..1] if that makes any sense
16:28:06 <lpz> where 3 should be a variable
16:28:09 <mauke> > [1..3] ++ reverse [1..3]
16:28:10 <lambdabot>  [1,2,3,3,2,1]
16:28:19 <lpz> cool
16:28:20 <lpz> thanks
16:28:33 <dibblego> > let f = \n -> [1..n] ++ [n..1] in f 3
16:28:34 <lambdabot>  [1,2,3]
16:28:37 <lpz> so what i typed was wrong.. but why?
16:28:49 <mauke> lpz: because (:) takes an element and a list, not two lists
16:28:50 <dibblego> > let f = \n -> [1..n] ++ [n, n-1..1] in f 3
16:28:52 <lambdabot>  [1,2,3,3,2,1]
16:28:56 <lpz> ooo ur right
16:28:59 <lpz> thanks again
16:29:31 <sjanssen> @type (:)
16:29:33 <lambdabot> forall a. a -> [a] -> [a]
16:29:36 <sjanssen> @type (++)
16:29:38 <lambdabot> forall a. [a] -> [a] -> [a]
16:29:48 <desp> > [3..1]
16:29:49 <lambdabot>  []
16:30:00 <mauke> this is for compatibility with Perl
16:30:32 <sjanssen> I think it makes for fewer corner cases
16:30:34 <lpz> [3..1]
16:30:42 <lpz> > [3..1]
16:30:43 <lambdabot>  []
16:31:07 <sjanssen> lpz: you need to do [n, n - 1 .. m] to step downwards
16:31:37 <sjanssen> > [5, 4 .. 1]
16:31:38 <lambdabot>  [5,4,3,2,1]
16:31:54 <lpz> > [10,9..1]
16:31:56 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
16:32:15 <mauke> > [10, 8 .. 1]
16:32:16 <lambdabot>  [10,8,6,4,2]
16:32:31 <lpz> this wouldn't be useful if i wanted to do the list i typed at first
16:35:23 <desp> I've been using {-# INLINE foo #-} all over the place, without really knowing its effects
16:35:44 <desp> actually, I've been putting those inline pragmas everywhere I'd use inline in C++
16:36:18 <desp> but does inlining actually happen across module boundaries?
16:36:35 <mauke> sometimes
16:36:36 <ChilliX> desp: with -O, it does
16:36:53 <sjanssen> desp: yes
16:36:59 <ChilliX> (unless you try to inline something recursively)
16:37:16 <mauke> isn't GHC smart enough to inline small functions automatically?
16:37:28 <ChilliX> mauke: small ones, yes
16:37:29 <sjanssen> oftentimes
16:37:33 <desp> yeah, I was going to ask this -- how small a function has to be?
16:38:02 <desp> to be automatically inlined, that is
16:38:09 <sjanssen> 6
16:38:44 <mauke> 6 decapixel?!
16:38:45 <desp> pardon me, six what?
16:38:47 <desp> :)
16:39:28 <sjanssen> desp: I have no idea, just pulling your chain :)
16:39:34 <ChilliX> well, there is a value, called the unfolding creation threshold, which determines the size
16:39:36 <desp> :D
16:40:11 <ChilliX> it actually looks at a couple of things, not just the pure size
16:40:22 <desp> I'm thinking mainly about simple silly functions such as
16:40:23 <ChilliX> there is a paper by SPJ about the ghc inliner
16:40:27 <desp> singleton = R L.singleton
16:40:41 <desp> or  singleton = R L.singleton 0
16:40:45 <desp> make that 1
16:40:47 <desp> :)
16:40:53 <ChilliX> http://research.microsoft.com/~simonpj/Papers/inlining/index.htm
16:40:53 <lambdabot> Title: Simon Peyton Jones: papers
16:41:02 <desp> thanks
16:41:10 <sjanssen> desp: you can generally trust GHC to do the right thing
16:41:13 <ChilliX> It explains the details.
16:41:24 <desp> ?where inlining
16:41:24 <lambdabot> I know nothing about inlining.
16:41:29 <wli> Yeah, if you can fold constants so massively it crushes it down to something tiny you might want to inline it anyway even though it's apparently huge.
16:41:33 <desp> ?where+ inlining http://research.microsoft.com/~simonpj/Papers/inlining/index.htm
16:41:34 <lambdabot> Done.
16:42:00 <desp> wli: I have no idea what you mean :)
16:42:04 <wli> Where constants include constructors.
16:42:37 <wli> desp: Huge case statement in function. Callsite passes in a constant constructor application.
16:42:57 <wli> desp: ghc will want to inline the huge case statement anyway.
16:43:26 <desp> oh
16:43:49 <wli> desp: Because it'll obviously collapse down to just one branch (and each branch will often be tiny in such cases).
16:46:24 <diakopter> roconnor: btw, pugs.blogs.com is only down b/c SixApart is entirely down.  seems it'll be back up shortly.
16:53:34 <ihope> Can I do import qualifieds in GHCi?
16:54:05 <mauke> I don't think you have to
17:06:55 <desp> is it possible to safely catch an exception in pure code?
17:07:31 <roconnor> @hoogle catch
17:07:32 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
17:07:32 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
17:07:32 <lambdabot> GHC.ConsoleHandler.Catch :: (ConsoleEvent -> IO ()) -> Handler
17:07:46 <roconnor> hmm
17:07:48 <EvilTerran> no - you can't know when the "throw" will be evaluated, so you can't be sure that you'll still be inside the "try" at that time
17:07:51 <roconnor> @src Error
17:07:51 <lambdabot> class Error a where
17:07:51 <lambdabot>     noMsg  :: a
17:07:51 <lambdabot>     strMsg :: String -> a
17:07:52 <mauke> desp: not really
17:08:17 <desp> the ByteString index function throws an exception for out-of-bounds accesses.  I need to wrap it in a function that returns Maybe Char
17:08:19 <roconnor> @hoogle catchError
17:08:20 <lambdabot> Control.Monad.Error.catchError :: MonadError e m => m a -> (e -> m a) -> m a
17:08:32 <dolio> unsafePerformIO (C.E.catch (evaluate (pure code)) (\ex -> ...))
17:08:37 <EvilTerran> but, dependingon what you need, the Maybe or (Either e) monads may do what you want
17:08:47 <desp> so I thought maybe instead of checking the length I could catch the exception somehow
17:08:58 <desp> oh, hm.  catchError in the Maybe monad?
17:09:04 <mauke> desp: that's evil
17:09:43 <desp> mauke: why is it evil?
17:09:51 <mauke> it's like trying to defeat a C assert() by catching SIGABRT and longjmp()ing out of the signal handler
17:10:08 <desp> haha!
17:10:21 <desp> dolio: I thought about that, but is it *safe*?
17:10:49 <dolio> Heh. It's evil.
17:11:02 <desp> right
17:11:08 <dolio> But you can use it to build, for example, safeHead.
17:11:17 <dolio> So it might be safe enough.
17:11:21 * desp winks
17:11:36 <desp> would you do that over just checking the length, though?
17:11:45 <desp> safeHead is simpler, just check null
17:12:14 <desp> but calling length on a LPS is O(n/c)
17:12:21 <dolio> I'd probably avoid unsafePerformIO.
17:12:40 <desp> hmm. actually, index is listed as O(1)
17:12:57 <desp> but I don't see how it can be O(1) *and* do oob checks if length is O(n/)
17:13:00 <desp> O(n/c)
17:13:34 <desp> it couldn't be O(1), since a LPS is a list of chunks
17:13:36 <desp> r?
17:13:40 <desp> right?
17:13:47 <chessguy> @bot
17:13:47 <lambdabot> :)
17:14:05 * desp pokes dons
17:14:07 <lpz> @bot
17:14:07 <lambdabot> :)
17:15:30 <EvilTerran> desp, it could be an amortisation thing
17:16:19 <robin_bb> @version
17:16:19 <lambdabot> lambdabot 4p534, GHC 6.6 (Linux i686 2.66GHz)
17:16:19 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:19:37 <desp> @hoogle evaluate
17:19:37 <lambdabot> Control.Exception.evaluate :: a -> IO a
17:19:37 <lambdabot> Test.QuickCheck.evaluate :: Testable a => a -> Gen Result
17:38:02 <desp> when is it beneficial to use seq?
17:38:39 <dibblego> when you want to be strict
17:40:02 <dibblego> take a look at the difference between foldl and foldl'
17:40:06 <dibblego> that is a good example
17:40:12 <Botje> a quote mark!
17:40:15 <dibblego> foldl' executes in constant stack space
17:40:20 <dibblego> because it uses seq
17:40:41 <desp> @src foldl
17:40:41 <lambdabot> foldl f z xs = lgo z xs
17:40:41 <lambdabot>     where lgo z []     =  z
17:40:41 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
17:40:53 <desp> @src foldl'
17:40:53 <lambdabot> foldl' f a []     = a
17:40:53 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
17:50:56 <desp> @src ($!)
17:50:56 <lambdabot> Source not found. I feel much better now.
17:51:14 <desp> @type ($!)
17:51:22 <lambdabot> forall a b. (a -> b) -> a -> b
17:51:53 <desp> f $! a = a `seq` f a
17:51:56 <desp> ?
17:52:03 <mauke> yes
18:00:57 <sfultong> damn wikipedia... from forth to cannon cat to jef raskin to archy ... now I'm gonna have to download archy
18:06:41 <desp> sfultong: there was a xcdk comic about this phenomenon
18:06:50 <desp> xkcd*
18:07:08 <desp> http://xkcd.com/214/
18:07:09 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
18:13:49 <shapr> SHAZAM!
18:15:19 <desp> so, marking a data type constructor's fields as strict will cause them to evaluate on construction?
18:17:20 <ddarius> desp: It makes the constructor strict in those arguments.  A constructor is just a normal function.
18:17:38 <desp> ah.
18:27:53 <newsham_> its hardly fair to blame wikipedia
18:28:31 <ddarius> Wikipedia doesn't go to the depth that I care for, so I rarely use it and thus rarely end up wandering around it.
18:29:06 <DukeDave> Gah, I'm confusing myself again:
18:29:10 <DukeDave> > let foo [x] = []; foo (x:y:zs) = [x,y] : (foo y:zs) in foo [1..4]
18:29:14 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
18:29:14 <lambdabot>       Expected...
18:29:33 <Saizan> you want ++
18:29:37 <DukeDave> Target answer:  [[1,2],[2,3],[4,5]]
18:29:54 <Saizan> ah, no
18:29:58 <dibblego> x:y:(foo y:zs)
18:30:01 <shapr> My bank tried to tell me that my girlfriend is unable to open an account or be added to my account becuase she does not have a local ID card. A Swedish passport is not enough.
18:30:03 <shapr> Stupid bank.
18:30:06 <Cale> foo y:zs = (foo y):zs
18:30:19 <Saizan>  > let foo [x] = []; foo (x:y:zs) = [x,y] : (foo (y:zs)) in foo [1..4]
18:30:22 <Saizan> > let foo [x] = []; foo (x:y:zs) = [x,y] : (foo (y:zs)) in foo [1..4]
18:30:23 <lambdabot>  [[1,2],[2,3],[3,4]]
18:30:25 <Cale> You probably wany foo (y:zs)
18:30:25 <dibblego> > let foo [x] = []; foo (x:y:zs) = x : y : (foo (y:zs)) in foo [1..4]
18:30:26 <lambdabot>  [1,2,2,3,3,4]
18:30:28 <Cale> want*
18:30:33 <newsham_> > let f x = zipWith (,) x (drop 1 x) in f [1,2,3,4,5]
18:30:35 <lambdabot>  [(1,2),(2,3),(3,4),(4,5)]
18:30:35 <ddarius> shapr: Use a international bank.
18:30:45 <shapr> ddarius: You know of one?
18:30:55 <mauke> > let foo [x] = []; foo (x:ys@(y:_)) = [x,y] : foo ys in foo [1..4]
18:30:56 <lambdabot>  [[1,2],[2,3],[3,4]]
18:31:03 <newsham_> > let f x = zipWith (\a b -> [a,b]) x (drop 1 x) in f [1,2,3,4,5]
18:31:05 <lambdabot>  [[1,2],[2,3],[3,4],[4,5]]
18:31:48 <DukeDave> Ah newsham_ I like yours, I've seen that pattern elsewhere?
18:32:00 <newsham_> zip is your friend
18:32:06 <DukeDave> I remember, Fibonacci sequence
18:32:35 <newsham_> > let fib = 1 : 1 : zipWith (+) fib (drop 1 fib) in take 10 fib
18:32:36 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
18:32:48 <DukeDave> Lol, just beat me :)
18:32:58 <DukeDave> I always enjoy explaining that to people
18:33:16 <mauke> drop 1 better written as tail
18:33:25 <newsham_> zip is great for iterating over several things at once
18:33:31 <ddarius> The bank I use has has some international aspects, though I'm not sure how they would handle that situation?
18:33:35 <newsham_> yes, mauke++
18:33:40 <newsham_> <- rusty w/ the haskell
18:35:01 <Saizan> i wonder if we can count on zipWith being less strict on the second list
18:35:45 <dons> ?src zipWith
18:35:45 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
18:35:46 <lambdabot> zipWith _ _      _      = []
18:35:48 <DukeDave> Shame there's no way(?) to reduce (\a b -> [a,b])
18:35:57 * DukeDave just doesn't like lambdas
18:36:12 <mauke> @pl  (\a b -> [a,b])
18:36:12 <lambdabot> (. return) . (:)
18:36:18 <mauke> say hello to @pl
18:36:27 <DukeDave> Damnit I knew there would be something like that!
18:36:32 <DukeDave> I was just playing in hugs,
18:36:49 <ddarius> DukeDave: You could finagle it with monadic operations I'm fairly sure.
18:36:53 <oerjan> > (\(_:_) (_:_) -> True) [] undefined
18:36:54 <lambdabot>   Non-exhaustive patterns in lambda
18:37:00 <newsham_> duke: why do you want lists of size two (rther than tuples?)
18:37:08 <newsham_> you can zipWith (,) for tuples
18:37:16 <ddarius> zip = zipWith (,)
18:37:23 <newsham_> or yah :)
18:37:25 <newsham_> heh duh
18:37:55 <oerjan> > let f (_:_) (_:_) = True; f _ _ = False in f [] undefined
18:37:57 <lambdabot>  False
18:38:26 <ddarius> oerjan: The standard specifies left to right evaluation I believe.
18:39:18 <dylan_> So many bottoms...
18:40:11 <pjd> > zipWith (,) `ap` tail $ [1,2,3,4,5]
18:40:12 <lambdabot>  [(1,2),(2,3),(3,4),(4,5)]
18:42:23 <pjd> or, yeah, zip `ap` tail
18:42:49 <oerjan> hm...
18:43:58 <oerjan> > fix (([1,1]++).(zipWith (+) `ap` tail))
18:43:59 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
18:44:49 <MP0> > fix [1, 2, 3]
18:44:50 <lambdabot>  Couldn't match expected type `a -> a' against inferred type `[a1]'
18:45:00 <MP0> > fix 1
18:45:01 <lambdabot>   add an instance declaration for (Num (a -> a))
18:45:06 <Saizan> ?type fix
18:45:08 <lambdabot> forall a. (a -> a) -> a
18:45:13 <MP0> ah
18:45:23 <Saizan> ?src fix
18:45:24 <lambdabot> fix f = let x = f x in x
18:46:50 <MP0> > fix \x->x+x 3
18:46:51 <lambdabot>  Parse error
18:47:01 <MP0> fix \x<-x+x 3
18:47:12 <MP0> > fix \x<-x+x 3
18:47:12 <lambdabot>  Parse error
18:47:15 <Saizan> > fix (\x -> x + x) 3
18:47:16 <lambdabot>   add an instance declaration for (Num (t -> a))
18:47:16 <lambdabot>     In the expression: x + x...
18:47:24 <mauke> > fix (\x -> 'z' : x)
18:47:26 <lambdabot>  "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz...
18:47:34 <ddarius> > fix ('z':)
18:47:35 <lambdabot>  "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz...
18:48:10 <MP0> 'z':
18:48:16 <MP0> > 'z':
18:48:16 <lambdabot>  Parse error
18:48:19 <mauke> > (fmap fix return) 42
18:48:20 <lambdabot>  42
18:48:21 <MP0> ?type 'z':
18:48:22 <lambdabot> parse error (possibly incorrect indentation)
18:48:35 <MP0> ?src (:)
18:48:35 <lambdabot> Source not found. It can only be attributed to human error.
18:48:40 <oerjan> ?type ('z':)
18:48:42 <lambdabot> [Char] -> [Char]
18:48:46 <mauke> ?src []
18:48:46 <lambdabot> data [] a = [] | a : [a]
18:49:02 <MP0> 'x': 'x'
18:49:07 <MP0> >'x': 'x'
18:49:13 <MP0> > 'x': 'x'
18:49:14 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
18:49:19 <mauke> ?type (:)
18:49:20 <lambdabot> forall a. a -> [a] -> [a]
18:49:26 <MP0> > 'x': ['x']
18:49:27 <lambdabot>  "xx"
18:49:31 <MP0> sweet
18:49:36 <MP0> consing
18:49:41 <mauke> yep
18:49:42 <ddarius> > 'x':"x"
18:49:44 <lambdabot>  "xx"
18:49:52 <mauke> > 1 : 2 : 3 : []
18:49:54 <lambdabot>  [1,2,3]
18:50:13 <ddarius> :t "xx"
18:50:15 <lambdabot> [Char]
18:50:31 <MP0> :t lambdabot
18:50:33 <lambdabot> Not in scope: `lambdabot'
18:50:42 <lpz> :t 1
18:50:44 <lambdabot> forall t. (Num t) => t
18:50:49 <pjd> oerjan: that is very cool
18:50:52 <MP0> well.. get GCed already, lambdabot!
18:51:21 <mauke> > 1%2 + 1%3
18:51:22 <lambdabot>  5%6
18:52:42 <banbh> When using GHC API, is there way to load a file (or module) into the *current* session?
18:53:02 <MP0> :m module
18:54:09 <banbh> I think this is easy with hs-plugins -- it's what dons does in one example in the docs
18:54:59 <banbh> But there seems to be very little documentation for GHC API. http://www.haskell.org/haskellwiki/GHC/As_a_library is about it
18:55:00 <lambdabot> Title: GHC/As a library - HaskellWiki
19:00:02 <hpaste>  Pharm77 annotated "ideal-hyip.admin" with "Cheap viagra" at http://hpaste.org/1741#a1
19:00:02 <hpaste>  Pharm77 annotated "ideal-hyip.admin" with "Cheap viagra" at http://hpaste.org/1741#a2
19:00:02 <hpaste>  Pharm77 annotated "ideal-hyip.admin" with "Cheap viagra" at http://hpaste.org/1741#a3
19:00:02 <hpaste>  Pharm77 annotated "ideal-hyip.admin" with "Cheap viagra" at http://hpaste.org/1741#a4
19:00:03 <hpaste>  Pharm77 annotated "ideal-hyip.admin" with "Cheap viagra" at http://hpaste.org/1741#a5
19:00:22 <slava> dons: some viagra for your monads?
19:01:07 <desp> so, if I have a  data Foo = F !Bar,  then the ! in  quux (F !b) = b  is redundant, right?
19:01:16 <ddarius> desp: Yes.
19:01:20 <desp> slava: rotfl
19:02:49 <DukeDave> @pl (Integer,a) -> (Integer,b) -> Ordering
19:02:50 <lambdabot> (line 1, column 13):
19:02:50 <lambdabot> unexpected ">" or "-"
19:02:50 <lambdabot> expecting variable, "(", operator or end of input
19:02:59 <cpfr> hello
19:03:06 <pjd> > fix $ ([1,1]++) <$> (zipWith (+) <*> tail)
19:03:07 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
19:03:25 <cpfr> what is a good choice for a haskell library to do database things, that is well documented
19:06:43 <robin_bb> Hello, everyone.  Does anyone know what the status of the Network.HTTP library is?  Is anyone working on it, currently?
19:07:20 <Pseudonym> It's perfect, so nobody needs to maintain it.
19:08:04 <Pseudonym> Seriously, I believe there's a SoC student working on it.
19:08:13 <Pseudonym> maybe./
19:09:03 <Pseudonym> and cfpr: Look up HaskellDB on hackage.
19:09:12 <DukeDave> @pl (\(a, b) -> (a, b) -> (a -> a -> c) -> c
19:09:13 <lambdabot> (line 1, column 20):
19:09:13 <lambdabot> unexpected ">"
19:09:13 <lambdabot> expecting variable, "(", operator or ")"
19:09:30 <desp> robin_bb: yes, I'm working on a libcurl-based alternative
19:09:41 <ddarius> DukeDave: @pl doesn't take types
19:09:52 <glguy> we use libcurl at work because Net.HTTP doesn't do ssl
19:09:58 <Pseudonym> DukeDave: I think you want one of the freetheorem plugins.
19:10:06 <Pseudonym> Or Djinn.
19:10:07 <DukeDave> @pl (\f (a, b) (c, d) -> f a c
19:10:07 <lambdabot> (line 1, column 27):
19:10:07 <lambdabot> unexpected end of input
19:10:07 <lambdabot> expecting variable, "(", operator or ")"
19:10:10 <robin_bb> desp: yes, I think I've seen mention of your work, before.  What about the current Network.HTTP, though?
19:10:17 <DukeDave> @pl (\f (a, b) (c, d) -> f a c)
19:10:17 <Pseudonym> ?djinn (a,b) -> (a,b) -> (a -> a -> c) -> c
19:10:18 <lambdabot> (`ap` snd) . (. fst) . (const .) . flip flip snd . (ap .) . flip flip fst . (((.) . (const .)) .)
19:10:21 <lambdabot> f (a, _) (b, _) c = c b a
19:10:36 <Pseudonym> ?free f :: (a,b) -> (a,b) -> (a -> a -> c) -> c
19:10:37 <lambdabot> (forall z. k . p z = q (g z) . g) => k (f x y p) = f ($map_Pair g h x) ($map_Pair g h y) q
19:10:51 <Pseudonym> Woah.
19:10:53 <Pseudonym> Nice theorem.
19:10:59 <desp> robin_bb: well, I'm not touching it ;)
19:11:04 <dons> ?users
19:11:04 <lambdabot> Maximum users seen in #haskell: 365, currently: 335 (91.8%), active: 22 (6.6%)
19:11:06 <DukeDave> I'm thinking there isn't a nice way to do it? :|
19:11:12 <robin_bb> Pseudonym: Ha, yeah, right.  HTTP is perfect.  :)  How can I find out which SoC student is working on it, do you know?
19:11:16 <mm_freak_> what is @pl ?  does it convert to point-free?
19:11:30 <desp> robin_bb: the SoC student is me.
19:11:38 <mauke> @help pl
19:11:38 <lambdabot> pointless <expr>. Play with pointfree code.
19:11:39 <robin_bb> desp: Okay, thanks.  I'll watch for your libcurl alternative.
19:11:47 <mm_freak_> ah
19:11:53 <robin_bb> desp: Ah, okay.
19:11:58 <desp> robin_bb: http://varsztat.com/
19:12:00 <Pseudonym> Mieczyslaw Bak, IIRC
19:12:01 <lambdabot> Title: Varsztat
19:12:03 <DukeDave> @pl (\f (a, b) (c, d) -> f a c)
19:12:04 <lambdabot> (`ap` snd) . (. fst) . (const .) . flip flip snd . (ap .) . flip flip fst . (((.) . (const .)) .)
19:12:11 <mm_freak_> @pl blah x y z = blah (x+y) (y+z) (z+x)
19:12:12 <lambdabot> blah = fix ((`ap` (+)) . ((flip . (ap .)) .) . flip flip (+) . (liftM2 (.) .) . (. (+)) . (.))
19:12:17 <DukeDave> Hm, what is that ap function?
19:12:29 <ddarius> @src ap
19:12:29 <lambdabot> ap = liftM2 id
19:12:31 <magnus> @pl produces very clear code
19:12:31 <lambdabot> produces very clear code
19:12:41 <desp> robin_bb: got a little delay because of ICFP, but I'll have a ByteString-using version up soon
19:12:44 <magnus> @pl lambdabot is stupid
19:12:44 <lambdabot> lambdabot is stupid
19:12:50 <mm_freak_> @pl blah x y z = x + (blah (x+y) (y+z) (z+x))^(y + blah z y x)
19:12:53 <magnus> @botsnack
19:12:54 <lambdabot> blah = fix (ap ((.) . (.) . (+)) . ap (ap . ((ap . ((ap . ((^) .)) .)) .) . flip ap (+) . ((flip . (ap .)) .) . flip flip (+) . ((ap . ((.) .)) .) . (. (+)) . (.)) ((ap ((.) . (+)) .) . flip . (flip
19:12:54 <lambdabot> .) . flip))
19:12:54 <lambdabot> optimization suspended, use @pl-resume to continue.
19:12:54 <lambdabot> :)
19:13:06 <lambdabot>  @pl magnus is stupid
19:13:23 <robin_bb> desp: Thanks.  I'll watch your progress, and read your Web site.  Meanwhile, I might hack on Network.HTTP a little bit.
19:14:09 <magnus> ap (stupid.) (. magnus (. (.ap))) . (.) .
19:15:51 <pjd> DukeDave: that code i just pasted is ap in disguise
19:16:02 <pjd> > fix $ ([1,1]++) `fmap` (zipWith (+) `ap` tail)
19:16:04 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
19:16:57 <pjd> err, that oerjan originally pasted with `ap`, nevermind :)
19:17:28 <cpfr> pjd, would you know of libraries
19:17:44 <ddarius> @where libraries
19:17:45 <lambdabot> I know nothing about libraries.
19:18:28 <newsham_> @where women
19:18:29 <lambdabot> I know nothing about women.
19:18:34 <newsham_> huh, me either
19:18:45 <lambdabot> I know nothing about humans.
19:18:52 <cpfr> @where monkeys
19:18:53 <lambdabot> I know nothing about monkeys.
19:19:00 <mgsloan> something interesting about liskell is that it's really not different at all from haskell
19:19:04 <cpfr> @where lambda
19:19:04 <lambdabot> I know nothing about lambda.
19:19:16 <newsham_> @where two words
19:19:16 <mgsloan> eg, when I look at it, I practically just see haskell
19:19:16 <lambdabot> I know nothing about two.
19:19:16 <lambdabot> I know nothing about where this conversation is going.
19:19:43 <pjd> cpfr: http://haskell.org/haskellwiki/Applications_and_libraries/Database_interfaces
19:19:45 <lambdabot> Title: Applications and libraries/Database interfaces - HaskellWiki, http://tinyurl.com/32a6lg
19:19:57 <cpfr> yeah pjd but there are so many choices
19:20:13 <pjd> i haven't used any of them, i'm afraid
19:21:55 <Cale> !paste
19:21:56 <hpaste> Haskell paste bin: http://hpaste.org/
19:22:16 <ddarius> It's... awkward to play guitar with a flag cut into your thumb.
19:22:22 <ddarius> s/flag/flap
19:22:33 <jfredett> ddarius: no, really?
19:23:29 <desp> a flag would be even more awkward
19:24:05 <jfredett> desp: tru.dat
19:25:00 <magnus> @where I
19:25:01 <lambdabot> I know nothing about i.
19:25:09 <jfredett> @where myself
19:25:09 <magnus> @where magnus
19:25:10 <lambdabot> I know nothing about myself.
19:25:10 <lambdabot> I know nothing about magnus.
19:25:17 <jfredett> aww, poor lambdy
19:25:28 <jfredett> @bot
19:25:28 <lambdabot> :)
19:25:31 <magnus> @seen magnus
19:25:31 <lambdabot> You are in #haskell-overflow and #haskell. I last heard you speak just now.
19:26:06 <mm_freak_> @seen _|_
19:26:07 <lambdabot> I haven't seen _|_.
19:26:25 <newsham_> deseperately seeking bottom
19:26:59 <newsham_> @seen shrek
19:26:59 <lambdabot> I haven't seen shrek.
19:27:10 <mm_freak_> @seen lambdabot
19:27:10 <lambdabot> Yes, I'm here. I'm in #haskell-icfp07, ##logic, #xmonad, #unicycling, #perl6, #parrot, #oasis, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #haskell, #ghc, #darcs and #scannedinavian
19:27:21 <newsham_> @seen thx1138
19:27:21 <lambdabot> I haven't seen thx1138.
19:27:28 <newsham_> @seen apocalypse_now
19:27:28 <lambdabot> I haven't seen apocalypse_now.
19:27:28 <Cale> http://hpaste.org/1871 -- new string searching algorithm for DNA->RNA :)
19:27:31 <cpfr> @seen dons
19:27:32 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 14m 43s ago.
19:27:55 <mm_freak_> THX 1138 is one of my fav movies
19:28:08 <newsham_> thx 1138 is one of my favorite phone numbers
19:28:35 <Cale> kthxbye
19:29:17 <mdmkolbe|ubuntu> Is there an integer log function?  (I just need to calculate (ceil (logBase 2)), but that causes ambiguity)
19:29:45 <mm_freak_> mdmkolbe|ubuntu: bitSize from Data.Bits, if you just want to count bits
19:30:20 <Cale> hmm, I wonder if [Base] -> [Base] might actually be faster for RNA output in each iteration than using a Data.Seq for that, I should try it :)
19:30:30 <mdmkolbe|ubuntu> @doc Data.Bits
19:30:30 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
19:30:36 <oerjan> mm_freak_: no, that does not look at the value, i think
19:30:55 <oerjan> > bitSize (1::Word)
19:31:00 <lambdabot>  32
19:31:00 <mdmkolbe|ubuntu> mm_freak_: it doesn't look at the value
19:31:05 <mm_freak_> oh
19:31:13 <mm_freak_> good to know
19:31:26 <mm_freak_> well, define oneâ€¦  should be difficult
19:32:00 <mm_freak_> let bits 0 = 0; bits n = 1 + bits (shiftR n 1) in bits 3
19:32:03 <mm_freak_> > let bits 0 = 0; bits n = 1 + bits (shiftR n 1) in bits 3
19:32:04 <lambdabot>  Add a type signature
19:32:44 <mm_freak_> > let bits 0 = 0; bits n = 1 + bits (div n 2) in bits 3
19:32:45 <oerjan> mm_freak_: it's been discussed here recently, don't know what the best method was
19:32:45 <lambdabot>  2
19:32:56 <mm_freak_> > let bits 0 = 0; bits n = 1 + bits (div n 2) in bits 65535
19:32:58 <lambdabot>  16
19:33:26 <mm_freak_> oerjan: the best method would be a C function i guess
19:33:58 <oerjan> mm_freak_: well, best portable method
19:34:06 <mm_freak_> > bitSize (2::Integer)
19:34:07 <lambdabot>  Exception: Data.Bits.bitSize(Integer)
19:34:13 <mm_freak_> hmm
19:34:43 <dino-> Anyone attending OSCON? How have the SPJ talks been going, I wonder.
19:35:09 <mm_freak_> oerjan: i couldn't imagine any better method, that is portable than the `bits' function above
19:35:47 <desp> whew, I'm finally getting a good feel for this laziness stuff
19:35:48 <mm_freak_> just make it tail-recursive
19:36:36 <Cale> dino-: apparently videotaping is going to occur :)
19:36:41 <base_16> sweet... ghc-6.6: panic! (the 'impossible' happened)
19:36:48 <dino-> Cale: ooo, I was hoping
19:37:02 <mm_freak_> > let bits' !n 0 = n; bits' !n !x = bits' (div x 2) (n+1); bits = bits' 0 in bits 65535
19:37:03 <lambdabot>  Parse error in pattern
19:37:08 <desp> Cale: so you're using Seq, not LPS?
19:37:13 <Cale> desp: yeah.
19:37:15 <mdmkolbe|ubuntu> > until ((==0).fst) (first (`div`2) . second (+1)) (9,0)
19:37:17 <lambdabot>  (0,4)
19:37:23 <mm_freak_> > let bits' n 0 = n; bits' n x = bits' $! div x 2 $! n+1; bits = bits' 0 in bits 65535
19:37:24 <lambdabot>      Occurs check: cannot construct the infinite type: b = (b -> b) -> b
19:37:24 <lambdabot>     ...
19:37:35 <mm_freak_> > let bits' n 0 = n; bits' n x = (bits' $! div x 2) $! n+1; bits = bits' 0 in bits 65535
19:37:38 <desp> how's that turning out or you, speed-wis? is your code available?
19:37:39 <lambdabot> Terminated
19:37:58 <mm_freak_> aaaah
19:38:11 <desp> Cale: s/wis/wise/; I'm doing endo.rna in 1.5 minutes on a 2 GHz Core Duo
19:38:14 <Cale> It's not bad, but could be better. I just did a full run with no prefix in 8m27s user time.
19:38:14 <mm_freak_> > let bits' n 0 = n; bits' n x = (bits' $! n+1) $! div x 2; bits = bits' 0 in bits 65535
19:38:16 <lambdabot>  16
19:38:29 <desp> Cale: what CPU/
19:38:35 <Cale> desp: 2.4 GHz P4.
19:38:49 <desp> I'll say LPS >> Seq, then.
19:39:15 <Cale> Well, I haven't tried too hard at optimising this at all.
19:39:26 <desp> I'm still using a naive search, too.
19:39:29 <desp> :)
19:39:46 <Cale> I just replaced with KMP and seeing what effect it had.
19:39:56 <Cale> There are some things I'd like to try with respect to how the RNA is handled within each iteration.
19:39:57 <newsham_> is search really that much of a limiting factor?
19:40:10 <Cale> newsham_: I don't think so, really.
19:40:22 <Cale> But KMP is easy to implement, so I did it. :)
19:40:27 <dons> is anyone using a ropes impl?
19:40:43 <dons> or fingertrees of bytestrings, yet?
19:41:04 <ddarius> I'm not implementing my ropes with fingertrees.
19:41:10 <Cale> Heh, naive search actually managed to come out marginally faster.
19:41:13 <ddarius> I think roconnor did do that though.
19:41:16 <desp> dons: hi there; how come LPS.index is listed as O(1) in the docs?
19:41:17 <Cale> (probably not significant)
19:41:23 <desp> Cale: !
19:41:30 <ddarius> And isn't Data.Sequence a finger tree?
19:41:39 <Cale> Yes, Data.Sequence is a finger tree
19:41:41 <newsham_> are your sources online, desp/cale?
19:41:45 <Cale> no
19:41:46 <mdmkolbe|ubuntu> @where LPS
19:41:47 <lambdabot> I know nothing about lps.
19:41:49 <oerjan> mm_freak_: i recall someone dividing by larger powers of 2
19:41:52 <mdmkolbe|ubuntu> What is LPS?
19:42:05 <oerjan> to reduce the number of divisions, i assume
19:42:09 <Cale> Data.ByteString.Lazy, I think
19:42:16 <newsham_> lazy packed strings?
19:42:20 <desp> newsham_: yes, the contest sources -- a bit messy -- http://varsztat.com/clfp/dna2rna-src/
19:42:21 <lambdabot> Title: Index of /clfp/dna2rna-src
19:42:27 <mm_freak_> oerjan: those divisions are bit-shiftsâ€¦  they're efficient enough
19:42:39 <desp> Cale, newsham_: yes
19:43:12 <oerjan> mm_freak_: except you may do a lot of copying
19:43:14 <mm_freak_> oerjan: but you could achieve O(log n) instead of O(n) by adapting the number of bits
19:43:15 <newsham_> this is the 90sec one?
19:43:16 <Cale> I'm going to compile with profiling and see where the bottlenecks are
19:43:50 <mm_freak_> like:  shifting by one bit did not yield 0, so try two bits the next time, and so on
19:43:57 <ddarius> You linearly grow the shift amount (exponentially grow the divide by amount) until you get zero, then you divide the number before and repeat on the remainder.
19:44:03 <mm_freak_> once you get 0, revert back and shift by less bits
19:44:34 <oerjan> mm_freak_: i assume that was somewhat like the method they used
19:44:36 <newsham_> desp: btw, you can simplify parsing of pattern/template/etc. by parsing prefixes of a given length (ie 3 for pattern or templates) until you get enough characters or you get a non "I"
19:44:49 <newsham_> then then whole pattern/template functions collapse to a single case statement
19:44:56 <mm_freak_> oerjan: yeah, at least it would make senseâ€¦  and by the strictness you prevent the copying
19:45:06 <desp> newsham_: you're of team TNT?
19:45:13 <mm_freak_> GHC unboxes it
19:45:27 <newsham_> desp: no, i was registerd as "newsham" and worked mostly on my own (a few friends helped a little)
19:45:35 <desp> ah
19:45:54 <desp> well, hm.
19:46:17 <oerjan> mm_freak_: for an entire Integer? it would have to know that the result becomes smaller, at least.  but i wouldn't know.
19:46:43 <newsham_> desp: see the definition of pattern() and getTopDna() to see what I mean: http://www.thenewsh.com/%7Enewsham/icfp/notrev4.c
19:47:02 <desp> I know what you mean; TNT does something like that :)
19:47:14 <dons> desp, sounds like a bug
19:47:17 <mdmkolbe|ubuntu>  oerjan, mm_freak_: are you still talking about counting the number of bits in a number?
19:47:26 <desp> dons: that's what I though
19:47:32 <desp> t
19:47:32 <newsham_> i thought of this on monday of course after doing it the nested case way in like 5 implementations :)
19:47:32 <dons> its fixed in darcs though
19:47:34 <oerjan> mdmkolbe|ubuntu: yeah
19:47:37 <dons> -- | /O(c)/ 'ByteString' index (subscript) operator, starting from 0.
19:47:37 <dons> index :: ByteString -> Int64 -> Word8
19:47:46 <Cale> heh, that's funny, 'pattern', 'template', and 'nat' all show up as having 0 entries in the profile, but are taking up 55% of the time :) (of course they're being entered constantly)
19:47:47 <mm_freak_> oerjan: that's no problem, but i could think of the following optimization:
19:48:07 <mdmkolbe|ubuntu>  oerjan, mm_freak_: I found a good solution that works for any Integral type (not just ints).
19:48:13 <desp> dons: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-ByteString-Lazy-Char8.html#v%3Aindex
19:48:15 <lambdabot> http://tinyurl.com/2ajqmb
19:48:25 <mdmkolbe|ubuntu> @type \x -> fst (until ((==0).fst) (first (`div`2) . second (+1)) (x, 0)
19:48:27 <lambdabot> parse error (possibly incorrect indentation)
19:48:30 <mm_freak_> oerjan: use (.&.) with growing values
19:48:43 <mdmkolbe|ubuntu> @type \x -> fst (until ((==0).fst) (first (`div`2) . second (+1)) (x, 0))
19:48:45 <lambdabot> forall a. (Integral a) => a -> a
19:49:08 <mdmkolbe|ubuntu> @type \x -> snd (until ((==0).fst) (first (`div`2) . second (+1)) (x, 0))
19:49:10 <lambdabot> forall a b. (Integral a, Num b) => a -> b
19:49:16 <mdmkolbe|ubuntu> There, that's the right one
19:49:39 <Cale> huh. Compiling with -caf-all gives assembler errors
19:49:54 <Cale> /tmp/ghc9577_0/ghc9577_0.s:71042:0:     Error: symbol `Mainsat_CAF_cc_ccs' is already defined
19:51:08 <mm_freak_> oerjan: or even better:  the inequality operators are implemented efficientlyâ€¦  use a growing auxiliary value and compare
19:52:07 <ddarius> :t snd . until ((==0).fst) (first (`div`2) . second (1+)) . flip (,)
19:52:09 <lambdabot>     Couldn't match expected type `(a, b)'
19:52:09 <lambdabot>            against inferred type `a1 -> (a1, a2)'
19:52:10 <ddarius> :t snd . until ((==0).fst) (first (`div`2) . second (1+)) . flip (,) 0
19:52:12 <lambdabot> forall a b. (Integral a, Num b) => a -> b
19:52:50 <mdmkolbe|ubuntu> :t snd . until ((==0).fst) (first (`div`2) . second (1+)) . (,0)
19:52:51 <lambdabot> parse error on input `0'
19:53:22 <mm_freak_> > let bitLen x a i = if a > n then i-1 else bitLen x (setBit a i) (i+1) in bitLen 65535 0 0
19:53:23 <lambdabot>   Not in scope: `n'
19:53:23 <mdmkolbe|ubuntu> hmm, I guess we don't have tuple slicing
19:53:28 <newsham_> desp: i like the code.  shorter than I expected.
19:53:33 <mm_freak_> > let bitLen x a i = if a > x then i-1 else bitLen x (setBit a i) (i+1) in bitLen 65535 0 0
19:53:34 <lambdabot>  16
19:53:39 <newsham_> I tried using the StateT IO for some reason, i don tthink that was a wise choice
19:54:07 <mm_freak_> adding strictness this should be a very efficient method
19:54:14 <Cale> State transforming IO is usually at least a little silly.
19:54:15 <ddarius> :t fst . until ((==0).snd) ((1+)***(`div`2)) . (,) 0
19:54:17 <lambdabot> forall a a1. (Integral a1, Num a) => a1 -> a
19:54:30 <ddarius> ReaderT IORef IO !
19:54:46 <newsham_> i write a lot of imperative code.  I get easily sucked into StateT :)
19:55:37 <desp> newsham_: I'm actually rewriting it hoping to use some sort of monad
19:56:01 * mdmkolbe|ubuntu uses the improvements from ddarius
19:57:12 <mdmkolbe|ubuntu> @hoogle (b -> c) -> (a, b) -> c
19:57:13 <lambdabot> No matches, try a more general search
19:57:16 <newsham_> sweet, please make case statements simpler :)
19:57:21 <mdmkolbe|ubuntu> @pl (b -> c) -> (a, b) -> c
19:57:22 <lambdabot> (line 1, column 4):
19:57:22 <lambdabot> unexpected ">"
19:57:22 <lambdabot> expecting variable, "(", operator or ")"
19:57:30 <mdmkolbe|ubuntu> @djinn (b -> c) -> (a, b) -> c
19:57:30 <lambdabot> f a (_, b) = a b
19:57:51 <desp> is pattern-matching strings as fast as matching chars?
19:57:56 <mdmkolbe|ubuntu> @pl (f . snd)
19:57:56 <ddarius> @. pl djinn (b -> c) -> (a,b) -> c
19:57:56 <lambdabot> f . snd
19:57:56 <lambdabot> f = (`ap` snd) . (. fst) . const
19:58:00 <dons> desp, yep, its fixed in the darcs repo for bytestrings
19:58:20 <desp> dons: ack
19:58:58 <Cale> :t fromJust . elemIndex 0 . iterate (`div` 2)
19:59:00 <lambdabot> forall a. (Integral a) => a -> Int
19:59:15 <Cale> heh, silly Int functions.
19:59:31 <ddarius> Cale, in this case, I think it's a safe bet.
19:59:37 <Cale> Pretty much :)
19:59:54 <desp> dons: I think I may have figured iit out why my glob function was slower than just doing a concat on all the chunks in a LPS -- laziness
20:00:19 <desp> dons: going to rewrite it in foldl' style and check
20:00:19 <newsham_> haskell or yours?  ;-)
20:00:20 * mdmkolbe|ubuntu give his wireless VPN connection a whack
20:00:29 <newsham_> *ducks*
20:00:53 * desp throws a duck at newsham_
20:00:59 <Cale> yeah, search seems to be taking ~1% of the profile time and allocation, so improving it is hardly worthwhile
20:01:51 <newsham_> yes, a game where people throw ducks at balloons, and nothing is what it seems
20:02:21 <Cale> Maybe viewl kinda sucks...
20:02:34 <dons> desp, check the core to see if its space leaky.
20:02:49 <desp> I'm afraid I don't know how to do that
20:03:27 <dons> ghc foo.hs -O -ddump-simpl | less   then look for your function, to see if its unboxed, or how else it is compiled
20:03:38 <desp> thanks
20:03:48 <newsham> did anyone write a performant rna renderer in haskell?
20:04:00 <desp> no, we did in C++
20:04:09 <newsham> seems like the ideal C program.
20:04:12 <desp> but I'll try doing it in Haskell later on
20:04:37 <newsham> (I did mine in C after the initial python impl)
20:05:16 <heatsink> Hope you don't mind a math question.  If  f x (f y z) == f y (f x z), is that commutativity?  Does it have a special name?
20:05:43 <lpz> associativity
20:05:47 <newsham> x `f` (y `f` z) == y `f` (x `f` z)
20:06:18 <newsham> isnt that two properties combined?
20:06:21 <mdmkolbe|ubuntu> that is not associativity
20:06:39 <newsham> x + (y + z) -> (x + y) + z -> (y + x) + z -> y + (x + z)
20:06:45 <heatsink> Yeah, the parameters are reordered compared to associativity
20:06:51 <mdmkolbe|ubuntu> associativity is: x `f` (y `f` z) == (x `f` y) `f` z
20:07:15 <newsham> associative + commutative
20:07:32 <heatsink> In my case, f :: a -> b -> b so I didn't think associativity would apply
20:08:09 <ddarius> forall x y. f x . f y == f y . f x
20:08:11 <mdmkolbe|ubuntu> heatsink: #math will know the answer for sure (but if you go there be prepaired for a bruised ego; they're nice, but most of them must have PhDs in Math or something b/c I can't understand half of what they are saying and I'm no math slouch)
20:08:41 <oerjan> it is commutativity of (f x .) with (f y .), essentially
20:09:41 <heatsink> Hmm... so maybe I can say f applied to one parameter commutes under composition.
20:09:56 <newsham> ((f x) (f y)) z == ((f y) (f x)) z ?
20:10:28 <newsham> err with dots :)
20:10:34 <oerjan> newsham: you need some dots in there
20:10:40 <newsham> yup. my bad
20:10:56 <oerjan> (f x .) . (f y .) = (f y .) . (f x .)
20:11:16 <newsham> (f x) . (f y) == (f y) . (f x)     no?
20:11:19 <oerjan> er, wait
20:11:30 <oerjan> yeah, you're right
20:11:30 <heatsink> yea, I think that last one is right.
20:11:46 <newsham> <- super smart today!
20:11:56 <heatsink> Okay, maybe I don't have to go to #math ... this time
20:12:11 <ddarius> f sends a into a commutative endofunction monoid!
20:12:31 <oerjan> ddarius: ssh :D
20:12:31 <ddarius> Maybe a commutative monoid action?
20:12:46 <newsham> hot three way commutative action?
20:12:47 <heatsink> yay, hot commutative monoid action!
20:13:18 <newsham> <- not into monoid pr0n
20:13:18 <oerjan> i do _not_ think "hot" is a technical term in that theory...
20:13:48 <heatsink> these monoids go both ways :)
20:14:27 * phoniq 's drink just came out his nose
20:14:40 <ddarius> Whenever you have a group, some are going to have to go both ways.
20:14:54 <phoniq> after all, that's why they're there
20:18:37 <newsham> you're not familiar with riemann's work on hotness or the follow up work by cauchy?
20:19:23 <oerjan> newsham: indeed not.
20:20:54 <dons> hmm, should we host lambdabot on the community servers?
20:21:35 <glguy> to what goal? uptime? freeing up your cpu ?
20:21:36 <Cale> continuous group action
20:22:04 <dons> glguy: two things, one, my dept is having a power outage this weekend, and two, we need a solution for once i've moved from sydney
20:22:16 <glguy> ah
20:22:35 <Cale> Heh, 'faithful group action', I'm not sure if that's a contradiction in terms :)
20:22:39 <dons> so i'm wondering if maybe lambdabot should /run/ on the community server
20:23:04 <brad_> is there a way to mandate a minimal ghc version in a cabal file?
20:23:09 <oerjan> Cale: there may be some _strange_ religions out there.
20:23:16 <dons> brad_: no, i don't think so. but base versions are tied to ghc
20:23:29 <dons> so state base>=2.0, to pick ghc 6.6.
20:23:43 <brad_> AH, i see.
20:23:44 <dons> brad_: do you need specific type system features?
20:23:47 <dons> or libraries?
20:24:04 <brad_> well i have a ghc-6.6.1 dependency - the Time.Format module being broken out on its own (?)
20:24:14 <Cale> Heh, A smooth operator inducing a continuous group action.
20:24:17 <dons> right, so you depend on time 1.0 or something
20:24:26 <dons> don't worry about whta ghc version, just state the library version
20:24:26 <brad_> exactly
20:24:32 <dons> since then you get hugs support for free as wel
20:25:14 <heatsink> Cale: that would be a great T-shirt.
20:25:24 <brad_> oh by the way dons, a few days ago i asked you about a library that ghc was complaining about "not being exposed" even though i thought it was - that was cabal complaining that i had not listed it as a dependency. maybe the reporting there could be a bit more precise
20:25:29 <newsham> cale: is that like polygamous marriage?
20:25:50 <Cale> newsham: hehe
20:26:02 <dons> brad_: ah right. yes.
20:26:03 <glguy> dons: running lambdabot on the community server seems reasonable to me
20:26:25 <dons> glguy: ok. it fits with running things like hpaste on the server too, i think
20:26:34 <DukeDave> Ah this could be a well timed question: I'm just trying run this: http://www.haskell.org/HOpenGL/examples/Planet.hs   in hugs and I'm dying on "[snip] Extensions.so: cannot open shared object file: No such file or directory"
20:26:42 <heatsink> thanks news, oerj, darius.
20:26:46 <Cale> Okay, so using [Base] -> [Base] for the RNA generated by each iteration is a bit slower than building up a Data.Sequence for each iteration's RNA
20:27:00 <mdmkolbe|ubuntu> :type (+1)
20:27:03 <mdmkolbe|ubuntu> :type (-1)
20:27:06 <brad_> before i go i wanted to note how excellent the wikibook is coming along! its really growing. maybe the first useful explanation of getting started with HXT among other things
20:27:09 <mdmkolbe|ubuntu> @type (+1)
20:27:11 <lambdabot> forall a. (Num a) => a -> a
20:27:14 <mdmkolbe|ubuntu> @type (-1)
20:27:16 <lambdabot> forall a. (Num a) => a
20:27:16 <DukeDave> I can see Extensions.hs in the directory though but not the .so
20:27:23 <mauke> @type (subtract 1)
20:27:25 <lambdabot> forall t. (Num t) => t -> t
20:27:28 <mdmkolbe|ubuntu> mauke: thx
20:27:41 <dons> brad_: yeah, i agree. i think we could really do with more content being merged /into/ the wikibook, where it is all categorised nicely
20:27:51 <dons> and maybe exporting the category structure back to haskell.org's wiki
20:28:06 <brad_> i notice all hawiki links in google are dead. why?
20:28:22 <brad_> seemed like some good stuff in there!
20:28:22 <dons> oh? the old hawiki?
20:28:23 <ddarius> HaWiki was taken down
20:28:31 <mauke> hawiki has been locked away
20:28:32 <ddarius> There is good stuff there!
20:28:39 <SamB> I agree
20:28:43 <brad_> why was hawiki locked up?
20:28:53 <brad_> it isn't anyway, i still have google caches
20:28:53 <SamB> but Igloo said that it had confused two n00bs in one day
20:29:06 <SamB> brad_: those don't last forever
20:29:15 <dons> we should export the pages into a separate license section of the haskell wiki
20:29:22 <dons> ah well
20:29:31 <mgsloan> hehe, lambda is spelled wrong in the unicode spec
20:30:25 <brad_> are there license issues with hawiki content?
20:30:33 <SamB> brad_: there are some
20:30:51 <brad_> uh, lets upload it to bayimg!
20:31:09 <SamB> brad_: if you've contributed anything go to the haskell-cafe migration page on the new wiki
20:31:13 <SamB> and sign your name
20:31:36 <brad_> sadly all i have contributed is misery at seeing this content vanish
20:31:49 <SamB> ah
20:32:09 <SamB> you *could* sign anyway if you've contributed anything to the Haskell community at all
20:32:16 <brad_> well then i will!
20:32:18 <SamB> such as emails or talking on IRC
20:32:27 <brad_> i have a module out there
20:32:29 <brad_> or two
20:32:42 <brad_> one about to get updated tonight maye
20:33:11 <brad_> so to be clear - hawiki was not deleted - just taken offline? so there is hope it could return?
20:33:23 <brad_> assuming IP issues vanish/
20:33:43 <SamB> brad_: indeed
20:33:51 <SamB> it was not deleted when I heard about it
20:33:57 <brad_> good. well one day it will return
20:34:08 <brad_> does lambdabot know where the sign-off list is?
20:34:14 <brad_> i don't know how to ask
20:34:14 <SamB> I'm not sure it was intentionally made inaccesible exactly...
20:34:22 <SamB> @goolge haskellwiki haskell cafe migration
20:34:24 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_Cafe_migration
20:34:24 <lambdabot> Title: Haskell Cafe migration - HaskellWiki
20:34:33 <brad_> well thats easy!!
20:34:37 * SamB notes that he misspelled google and it still worked
20:35:45 <sfultong> what's a good non-manual way of lifting a function with multiple arguments, when one happens to return a monad?
20:36:03 <mauke> what?
20:36:16 <dons> Igloo: maybe the hawiki urls can be redirected to a page pointing to the new wiki?
20:36:32 <dons> sfultong: what type?
20:36:38 <Cale> sfultong: I'm not completely sure what you're asking, but perhaps liftM2, liftM3 and so on?
20:36:41 <dons> non-manual?
20:36:57 <sfultong> heh, alright... yeah, that was very poorly phrased
20:37:02 <dons> you mean a combinator to wrap the function, rathe rthan manualy reimplementing it?
20:37:12 <dons> :t liftM ord
20:37:14 <lambdabot> forall (m :: * -> *). (Monad m) => m Char -> m Int
20:37:17 <cpfr> dons what would you recommend for db hsql, hdbc, or haskelldb
20:37:30 <dons> cpfr: i've not used any, but i think hdbc gets a lot of use?
20:38:00 <dons> cpfr: the deuschte bank guys use takusen, fwiw (I think)
20:38:02 <sfultong> I have a function that takes 3 arguments, and I just changed the code so that one of the arguments is now a maybe...
20:38:29 <sfultong> the second one, to be specific
20:39:10 <chessguy> @seen Cale
20:39:10 <lambdabot> Cale is in #oasis, #ghc, #haskell-overflow and #haskell. I last heard Cale speak 2m 31s ago.
20:39:16 <steven-ashley> sfultong: For example something like this?
20:39:16 <steven-ashley> f :: String -> Maybe String -> String -> String
20:39:16 <ddarius> sfultong: I'd just use do notation for the general problem.
20:39:32 <Cale> hi
20:39:35 <sfultong> ddarius: that's what I was gonna probably end up doing
20:39:53 <chessguy> heya Cale, how's Lazy Bottoms doing on The Problem
20:39:59 <cpfr> ok thanks :)
20:40:03 <sfultong> steven-ashley: yes
20:40:21 <SamB> chessguy: they're, um, sitting on it very very hard
20:40:30 <SamB> while watching TV
20:40:31 <oerjan> sfultong: you can add a return to each non-monadic argument, then use liftMn
20:40:43 <sfultong> well, actually, I was going to probably make it more like String -> Maybe String -> String -> Maybe String
20:40:47 <chessguy> lol
20:40:47 <Cale> chessguy: At the moment I'm just messing around with my DNA->RNA converter
20:41:03 <sfultong> oerjan: cool! that makes sense, thanks
20:41:19 * mgsloan never looked at the problem, but this isn't real DNA/RNA is it? because that's plain simple!
20:42:05 <chessguy> Cale, how far along have you guys gotten?
20:42:15 <ddarius> mgsloan: No.
20:42:25 <SamB> mgsloan: which is?
20:42:27 <Cale> chessguy: gene tables, a bunch of guide pages
20:42:30 <ddarius> Something with DNA/RNA would have been far more interesting.
20:42:31 <mgsloan> shouldn't call it that, then
20:42:36 <SamB> oh, the transcription ;-)
20:42:41 <TSC> mgsloan: It's alien DNA
20:42:46 <chessguy> Cale, pretty much just the ones listed on 1337?
20:42:58 <mgsloan> ah, haha
20:43:01 <Cale> chessguy: Several more
20:43:15 <chessguy> oh cool
20:43:18 <SamB> chessguy: I've found a few that aren't listed, too
20:43:24 <SamB> should I tell you what they are?
20:43:35 <Cale> It's been sort of quiet since the contest ended though
20:43:36 <chessguy> SamB, you could give me some hints
20:43:38 <SamB> ... first of all, have you tried everything from 1 to 9?
20:43:44 <chessguy> nah
20:44:15 <chessguy> maybe i should try that with this fancy new compiler ;)
20:44:23 <Cale> I haven't really been looking at the actual problem. Now that I have unbounded time, I'm just playing around with various aspects of the DNA compiler and seeing how they affect performance.
20:44:48 <SamB> Cale: hmm.
20:44:54 <SamB> I got sick of my compiler...
20:45:04 <Cale> SamB: I've written a few now :)
20:45:15 <Cale> Getting pretty good at avoiding the common bugs :)
20:45:20 <SamB> nice
20:45:37 <SamB> do any of yours look like a Parsec parser?
20:45:56 <Cale> SamB: Not really. It's monadic though.
20:46:15 <Cale> newtype DNAMonad a = DNAM (StateT DNA (ErrorT () (SWriter RNAChunk)) a)
20:46:15 <Cale>   deriving (Functor, Monad, MonadState DNA)
20:46:43 <SamB> Cale: you could make it look like a Parsec parser then
20:46:47 <Cale> SWriter is just a strictified writer
20:46:49 <SamB> why an SWriter?
20:46:57 <dons> Cale, would be interesting to look at mtl, versus unrolled, monad statkcs
20:47:11 <dons> i'd like some concrete numbers on what mtl stacks/module inlining is costing
20:47:21 <SamB> I specifically put my Writer at the bottom of my stack to *avoid* strictness ;-)
20:47:55 <Cale> Because within each iteration, if I build up the RNA lazily, I found it cost a lot more.
20:48:24 <SamB> hmm.
20:48:25 <Cale> At the end of each iteration, I take the RNA chunk I got and make it the head of the returned list, and recurse on the tail.
20:48:53 <SamB> oh.
20:48:59 <Cale> (that's where the lazy part comes in)
20:49:48 <SamB> do you think that might explain why my heap profile goes crazy at the beginning of running with the "advice" prefix?
20:50:05 <Cale> advice prefix?
20:50:13 <SamB> Cale: the one that runs tests
20:50:17 <Cale> ah
20:50:22 <Cale> um, could be
20:50:32 <Cale> My implementation does consume tons of memory
20:50:36 <mdmkolbe|ubuntu> I've discovered a new monad and wondered if anyone has seen it before.  It's like an error monad, but it requires a cumulative effect before the computation throws an error.  (e.g. the computation stops only if 3 errors are flagged or if 1 baz and 1 bar error are flagged)
20:50:46 <SamB> that is *exactly* why I use a lazy Writer
20:50:56 <SamB> I don't have a ton of memory for my programs to eat
20:51:12 <Cale> I think most of my memory usage is just in the initial read though
20:51:18 <SamB> btw, when I say "goes crazy", I mean "bounces up and down a lot"
20:51:21 <Cale> because Seq's are spine strict.
20:51:36 * SamB reads in a strict bytestring
20:52:04 <oerjan> mdmkolbe|ubuntu: isn't that sort of a resource restriction monad?
20:52:05 <SamB> Cale: you mean they have !(Seq a) in the constructor definitions?
20:52:16 <Cale> SamB: something like that
20:52:22 <Cale> SamB: length is O(1)
20:52:24 <SamB> Cale: or they just need to read the whole thing?
20:52:53 <Cale> If you create a Seq, you create the whole thing, but it's still lazy in the elements.
20:52:56 <SamB> because if it's the latter I think it ought to be possible to lazilly convert a strict bytestring
20:52:59 <mdmkolbe|ubuntu> oerjan: I suppose it could be considered that.  Is the a like for that monad?
20:53:19 <oerjan> mdmkolbe|ubuntu: huh?
20:53:28 <oerjan> i don't know the name though
20:53:36 <mdmkolbe|ubuntu> s/like/link/
20:53:56 <oerjan> but there are some that count number of evaluation steps, and the like
20:54:03 <Cale> wow, heap profiling makes this slow :)
20:54:32 <SamB> Cale: that might be why my interpreter was going so slow
20:55:15 <SamB> although I'll wager that a Seq uses a lot more heap than a lazy bytestring
20:55:19 <Cale> Like, more than 10 times slower. I started this run about half a munute ago now and it hasn't made it to 10k iterations (with -hb)
20:55:46 <Cale> er, no, heh, it was actually running for 3 minutes without making it to 10k iters.
20:57:00 <Cale> There's still quite a lot of lag here.
20:59:05 <DukeDave> Hey gang I still can't get this: http://www.haskell.org/HOpenGL/examples/Planet.hs to compile :|
21:00:06 <Cale> DukeDave: It looks like it's referring to the old locations of the GL libraries?
21:01:31 <DukeDave> Cale: Yeah I got that down, now at: Graphics.Rendering.OpenGL.GL ?
21:01:52 <Cale> yeah
21:02:01 <DukeDave> But am getting ~15 out of scope errors :|
21:02:17 <DukeDave> Not sure if it's just deprecated functions
21:03:03 <DukeDave> Looks like some pretty 'need to have' ones though, e.g. setInitialWindowPosition
21:03:15 <DukeDave> setDisplayCallback
21:04:35 <Cale> ah, getters and setters
21:04:41 <Cale> they've been abstracted
21:05:26 <DukeDave> I've hunted them down here: http://haskell.org/HOpenGL/documentation/GLUT/Graphics.UI.GLUT.Initialization.html
21:05:28 <Cale> mm, this is pretty outdated code
21:05:29 <lambdabot> http://tinyurl.com/37kro9
21:06:08 <DukeDave> Not an idea basis for learning then :)
21:07:50 <dons> interesting, http://lstephen.wordpress.com/2007/07/23/completing-the-spike/
21:07:53 <dons> smalltalk in haskell?
21:07:57 <lambdabot> Title: Completing the Spike « lstephen
21:08:11 <araujo> dons, yay!!!!!
21:08:43 <sfultong> what is (->)? is that the identity monad?
21:08:50 <Cale> sfultong: no
21:09:00 <Cale> ((->) e) is the reader monad
21:09:06 <sfultong> oh... interesting
21:10:02 <sfultong> it's kinda odd that I can crop up monad types in my code that I don't intend
21:10:53 <chessguy> @hoogle ord
21:10:54 <lambdabot> Char.ord :: Char -> Int
21:10:54 <lambdabot> Prelude.Ord :: class Eq a => Ord a
21:10:54 <lambdabot> Text.Html.ordList :: HTML a => [a] -> Html
21:11:06 <gchpaco> That's what "selecting the monad type according to the return value gets you"
21:11:40 <chessguy> > ord '\\'
21:11:42 <lambdabot>  92
21:11:53 <chessguy> > chr 92
21:11:54 <lambdabot>  '\\'
21:11:56 <sfultong> gchpaco: I don't quite understand
21:12:40 <gchpaco> There are situations where the monad you are using for some code is actually selected based on the return type you're expecting.  It comes up a lot when people try to write monadic toolkits for Scheme.
21:13:01 <gchpaco> For the most part in Haskell it just works.
21:13:46 <chessguy> @hoogle chr
21:13:46 <lambdabot> Char.chr :: Int -> Char
21:13:46 <lambdabot> Text.PrettyPrint.HughesPJ.Chr :: Char -> TextDetails
21:13:46 <lambdabot> Text.Regex.matchRegex :: Regex -> String -> Maybe [String]
21:17:15 <dibblego> hey dons, how are you going with keeping Haskell-Cafe in order?
21:17:49 <Pseudonym> Actually, glasgow-haskell-bugs has more traffic latelt.
21:18:00 <Pseudonym> lately
21:18:27 <dibblego> Haskell-Cafe is becoming too low signal:noise
21:18:41 <dibblego> hoping it can be restored
21:22:03 <dons> it could hvae been just a local peek last week, with a couple of noisy people joining
21:22:15 <dons> its been quiet since then, and its easy not to reply, which kills threads pretty well
21:22:26 <dons> peak. oh dear
21:22:55 <dons> dibblego: but -cafe@ will always be the noisiest place. not sure there is much else we can do
21:23:10 <dibblego> yeah I know; it's just usually a higher signal
21:23:43 <dibblego> I think discussions about analogies to cars might be better in Haskell-Cafe-who-cares-mate?
21:24:01 <dibblego> if you know what I mean :)
21:24:49 <dons> 'd' is just one key, and pretty easy to hit. :)
21:24:55 <dibblego> I know
21:25:21 <dibblego> well, first one must assess potential for signal
21:26:18 <desp> dons: is ghc-6.6.1 okay to use on ppc?
21:26:55 <dons> afaik, yes.
21:26:59 <desp> oops, actually I meant to ask dcoutts
21:27:32 <wli> HaskellDB looks pretty good here.
21:34:57 <dibblego> what was the paper titled that had something to do with reasoning about imperative programs as if all functions were referentially transparent?
21:34:58 <psykotic> anyone know if someone managed to get SPJ's oscon talks filmed?
21:39:46 <SamB> @go simon peyton jones oscon video
21:39:48 <lambdabot> http://programming.reddit.com/info/1tflc/comments
21:39:48 <lambdabot> Title: Haskell - Simon Peyton Jones video about Nested Data Parallelism (reddit.com)
21:40:15 <dons> that would be the video from london hugs, i think
21:40:34 <SamB> yes.
21:40:45 <SamB> but someone linked to http://conferences.oreillynet.com/cs/os2007/view/e_spkr/3429
21:40:46 <lambdabot> Title: O'Reilly Open Source Convention 2007 &#8226; July 23-27, 2007 &#8226; Portland,  ...
21:40:53 <SamB> which is about SPJ
21:41:00 <SamB> despite not having him in the page title
21:45:12 <SamB> hmm, that NDP talk sounds really fun
21:45:26 <sfultong> how do I convert a -> Maybe a to Maybe (a -> a) ?
21:45:45 <SamB> sfultong: why would you be able to do that?
21:46:02 <sfultong> oh dear
21:46:13 <SamB> @djinn (a -> Maybe a) -> Maybe (a -> a)
21:46:14 <lambdabot> f a =
21:46:14 <lambdabot>     Just (\ b ->
21:46:14 <lambdabot>           case a b of
21:46:14 <lambdabot>           Nothing -> b
21:46:14 <lambdabot>           Just c -> c)
21:46:16 <SamB> hmm.
21:47:01 <SamB> @type \a -> Just (\ b -> case a b of Nothing -> b; Just c -> c)
21:47:03 <lambdabot> forall t. (t -> Maybe t) -> Maybe (t -> t)
21:47:16 <sfultong> cool
21:47:22 <sfultong> and you learned something, too :->
21:47:39 <SamB> > (\a -> Just (\ b -> case a b of Nothing -> b; Just c -> c)) Just
21:47:40 <lambdabot>  Add a type signature
21:47:55 <SamB> > (\a -> Just (\ b -> case a b of Nothing -> b; Just c -> c)) Just :: Maybe (Int -> Int)
21:47:57 <lambdabot>  Just <Int -> Int>
21:48:14 <SamB> okay my head done got broke
21:48:21 <SamB> someone please explain what is going on
21:48:46 <sfultong> djinn is a  neat function
21:49:17 <sfultong> that's why I like haskell... it's still a mystery to those who are much better at it than me
21:49:33 <SamB> dons: do you know what is going on?
21:50:23 <oerjan> SamB: essentially the function is cheating, like the simpler const (Just id)
21:50:40 <oerjan> just in a slightly less obvious way
21:50:46 <SamB> ah.
21:50:57 <SamB> sfultong: I knew there must be a copout somewhere
21:51:32 <sfultong> @type const (Just id)
21:51:34 <lambdabot> forall a b. b -> Maybe (a -> a)
21:52:29 <sfultong> what does "cheating" mean?
21:52:49 <SamB> sfultong: not doing what you want!
21:53:03 <sfultong> oh, foo... somehow I suspected that
21:53:36 <SamB> @djinn (a -> Maybe b) -> Maybe (a -> b)
21:53:37 <lambdabot> f _ = Nothing
21:53:43 <SamB> ah. much much better.
21:54:26 <sfultong> oh... yeah, that's not quite what I wanted
21:54:29 <oerjan> yeah, that rules out the cheat of returning the argument, which both the others used
22:07:13 <SamB> "but we don't like aspirins, we like compilers" -- what a great line
22:10:32 <pjd> dibblego: Fast and Loose Reasoning is Morally Correct?
22:10:49 <pjd> (i haven't read it yet, but the title rang a bell)
22:11:05 <psykotic> that actually deals with haskell-like languages without side effects
22:11:20 <psykotic> it has to do with treating partial functions as if they were total for the sake of program calculation
22:11:23 <dibblego> pjd, lemme see
22:11:26 <pjd> yeah, i just checked
22:12:28 <pjd> "Apparently it's only morally correct if you don't look at bottoms. (ba-doom tish!)"
22:12:34 * pjd chuckles
22:14:10 <dibblego> I swear someone has referenced it in this channel before
22:14:21 <dibblego> I'll have to grep http:// one day and spend hours finding it
22:15:32 <pjd> Google finds a "Toward Flexible Equational Reasoning for a Purely Imperative Calculus"
22:17:39 <dibblego> that might be it!
22:19:02 <dibblego> thanks
22:19:02 * SamB didn't know dcoutts name was pronounced "coots"
22:22:50 <pjd> dibblego: it sounds pretty low-level, though
22:23:20 <dibblego> I always thought "Referentially Transparent" was in the title
22:30:00 <SamB> whoah. the concept of a parallel machine slower than a z80 is ... a bit odd in my 20-year-old's brain...
22:37:06 <TSC> @seen glguy
22:37:06 <lambdabot> glguy is in #haskell. I last heard glguy speak 2h 11m 3s ago.
22:38:08 <wli> SamB: Reading about the BBN Butterfly?
22:38:43 <SamB> wli: watching SPJ's NDP talk
22:38:49 <SamB> http://video.google.co.uk/videoplay?docid=370317485066035666&hl=en-GB
22:38:51 <lambdabot> Title: Nested Data Parallelism in Haskell, http://tinyurl.com/2e7u76
22:38:54 <Korollary> Ah, excellent
22:41:10 * SamB laughs aloud at SPJ saying he'll have to wave his arms...
22:41:34 <ddarius> OSCON?
22:41:43 <SamB> ddarius: london hug
22:48:40 * SamB wonders how peculiar it is to heat oneself a mug of tea... and then put ice cubes in it
22:49:05 <jfredett> well- it gets too hot
22:49:18 <jfredett> but it has to boil, for it to steep right
22:49:33 <jfredett> so its not really peculiar, just good sense, methinks
22:50:16 <SamB> basically the problem is that we are out of milk ;-)
22:50:59 * wli tries to figure out how to build up a grammar in parser combinators before going to bed.
22:54:41 <SamB> step 1:
22:54:52 <SamB> build grammar in parser combinators
22:54:58 <SamB> step 2:
22:55:04 <SamB> groan
22:55:15 <SamB> step 3:
22:55:21 <SamB> profit!
22:55:35 <jfredett> lol, what we need is a BNF => Parser Combinator, Parser
22:56:09 <jfredett> that is, it Parses BNF, using Parser combinators, and then turns the result into equivalent parser combinators
22:56:21 <wli> SamB: The issues revolve largely around semantic values.
22:56:41 <jfredett> but i suck at parser/compiler stuff
22:56:55 <SamB> jfredett: man, what do you use Haskell for then?
22:57:11 <wli> jfredett: The combinators are nicer than BNF.
22:57:12 <jfredett> math
22:57:40 <wli> jfredett: What kind of math?
22:57:53 <jfredett> SamB: mostly, I like to play with these things, I'm not good at computer science, its just a glorified hobby
22:58:19 <wli> SamB: step 1: build grammar in parser combinators
22:58:27 <jfredett> wli: any kind i can find, I like logic and computer algebra, that kind of thing
22:58:31 <wli> SamB: step 2: build state machine for bottom-up parser
22:58:45 <SamB> wli: step 3: go to bed?
22:58:52 <jfredett> I like fiddling with data structures, algorithms, whatever.
22:58:58 <wli> SamB: step 3: parse without restrictions on left recursion
22:59:03 <jfredett> I've been learning about quantum computers and stuff too
22:59:09 <SamB> step 9: go to bed?
22:59:17 <Korollary> sigfpe has a quantum computing monad iirc
22:59:34 <Korollary> sigfpe probably has a monad for everything anyway
22:59:44 <jfredett> nifty- I'm not quite to the level where I could understand whats going on in a quantum program
22:59:58 <olsner> Yow! I've just lost the SOURCE CODE for all my QUINE PROGRAMS! What will I DO NOW with just the BINARIES?
22:59:58 <jfredett> but I'm beginning to come to terms with superposition and stuff
23:00:13 <jfredett> olsner: doh!
23:00:23 <Korollary> olsner: Organize an ICFP and have the buggers re-create the sources.
23:00:34 <jfredett> Korollary: Brilliant!
23:00:56 <wli> jfredett: Got any fast methods of determining the order of a group generated bya given set of permutations?
23:01:07 <SamB> olsner: did you lose the computer too?
23:01:11 <jfredett> wli not on me
23:01:30 <jfredett> i seem to remember a theorem for that, though
23:01:34 <wli> jfredett: That's problem #1 for my alternative shootout.
23:02:02 <jfredett> alternative shootout? are you trying to fix the other one? if so, good.
23:02:55 <jfredett> what the... Gentoo install just failed, miserably
23:02:56 <wli> jfredett: Problem #2 is classifying a finite magma described by a table as a group, monoid, semigroup, loop, quasigroup, or otherwise un-classifiable magma.
23:02:58 <jfredett> damnit!
23:03:20 <jfredett> meh, I'll start it again in the morning.
23:03:23 <mgsloan> this might interest some of you ICFPers: http://marco-za.blogspot.com/2007/07/icfp-how-we-reached-top-15.html
23:03:25 <lambdabot> Title: Marco's Blog: ICFP: How We Reached the Top 15, http://tinyurl.com/33o75g
23:05:35 <wli> jfredett: If I can get far enough to cook up a reference implementation, computing cos(2*pi/p) in terms of radicals and rational operations for p of the form 2^i*3^j+1 will be #3.
23:05:56 <jfredett> ...
23:06:02 <jfredett> craziness
23:06:17 <jfredett> strikes me that this is more like the normal shootout on steroids
23:06:35 <jfredett> those normal shootout problems are far less fancy looking
23:06:46 * jfredett 's undergraduateness is showing
23:07:10 <psykotic> speaking of math, i noticed dave bayer posts to haskell-cafe
23:08:02 <psykotic> i'm pretty sure he's the only mathematician who's acted in an academy award winning movie
23:08:06 <wli> jfredett: Well, the normal shootout asks for problems for a single input; these are all free input.
23:08:29 <psykotic> (he was the math advisor for A Beautiful Mind, and had a cameo in a scene or two)
23:08:32 <wli> jfredett: They're also the microbenchmark portions; I have macrobenchmark portions.
23:08:43 <jfredett> ahh, i see.
23:08:50 <dons> psykotic: huh
23:08:54 <psykotic> dons: look it up :)
23:09:13 <jfredett> see, it always struck me that benchmarks tend to force a particular style on a program
23:09:25 <mgsloan> http://en.wikipedia.org/wiki/Erd%C5%91s-Bacon_number#Table_of_persons_with_defined_Erd.C5.91s.E2.80.93Bacon_numbers <- mathematicians also in movies
23:09:27 <lambdabot> http://tinyurl.com/ylqt2h
23:09:37 <psykotic> dons, http://en.wikipedia.org/wiki/Dave_Bayer
23:09:44 <jfredett> like with the normal shootout, from what I can tell, they don't allow the lazy capabilities in haskell to show forth
23:10:06 <slava> do the lazy capabilities of forth play a factor?
23:10:16 <wli> jfredett: Not these. Just so long as the input and output are correct, the implementation is completely unspecified.
23:10:20 <mgsloan> well, some are mathematicians... sometimes the erdos numbers seem a bit stretched
23:10:24 <jfredett> which kindof defeats the purpose, haskell _is_ fast, but it benches slow because they force it that way
23:10:48 <jfredett> same thing with Lisp and other languages
23:11:00 <psykotic> SBCL benches pretty well
23:11:39 <jfredett> yah- but i've written code in scheme that runs comparably with C code I've written
23:11:59 <psykotic> i still don't know of a scheme compiler that doesn't suck
23:12:22 <psykotic> in one way or another. PLT's native code compiler is still pretty pathetic compared to SBCL, for example.
23:12:28 <gchpaco> I've seen the same complaints about it from the C side, that it forces all these parsing problems that don't, somehow, exist in the real world.
23:13:05 <gchpaco> stalin had a good reputation, I don't know if it was undeserved.
23:13:10 <wli> gchpaco: What forces parsing problems? The shootout?
23:13:22 <jfredett> i dunno, i just think that the only thing that should matter is that given any input, the output should be the same as the reference implementation.
23:13:36 <gchpaco> wli: Yeah.  Now, mind, this is on /., not exactly the source of the world's brightest minds.
23:13:48 <jfredett> First Post!
23:13:51 <jfredett> Yah!
23:14:17 <gchpaco> jfredett: If memory serves, the last couple ICFPs were big into optimization problems, which are hard to write good reference implementations for..
23:14:27 <gchpaco> If only because somebody out there might be brighter than you.
23:14:32 <wli> C's string processing is very double-edged. For any sort of practical software engineering very slow constructs are used for.
23:14:55 <wli> OTOH since you can go very low-level it has the potential to go very fast.
23:14:56 <SamB> gchpaco: what do you mean?
23:14:57 <jfredett> i dunno
23:15:01 <psykotic> wli: part of the problem is that many C coders are very library-phobic.
23:15:15 <psykotic> wli: they want to stick to the standard library if at all possible, or roll their own.
23:15:20 <SamB> psykotic: *look* at their libraries some time before you say that
23:15:23 <jfredett> anyway, time for sleep
23:15:28 <jfredett> gnite folks
23:15:34 <psykotic> SamB, huh?
23:15:37 <psykotic> SamB, what's your point?
23:15:54 <SamB> with libraries like that, its no *wonder* they're afraid...
23:15:56 <wli> psykotic: There tends to be suckage.
23:15:59 <gchpaco> SamB: Consider the problem of writing an optimizer for C, say.  Clearly it's hard to say "this here should compile to this"; maybe someone unrolled the loop.
23:16:15 <psykotic> what i mean is that a c programmer is much more likely to roll his own broken hash table for a particular occasion than to download an existing library or even use the one in glibc.
23:16:35 <psykotic> SamB, i don't think that's the only reason. and it's partly because the language has terrible abstraction facilities of course.
23:16:41 <wli> Much of that has to dowith lack of genericity.
23:16:47 <SamB> psykotic: a direct result of not having constrained parametric polymorphism
23:17:08 <wli> Well, C isn't made for that.
23:17:08 <psykotic> i have a friend who's extremely fast in C...
23:17:14 <psykotic> like, pretty much faster than anyone i know in any language.
23:17:26 <wli> It's made for portable assembly.
23:17:30 <psykotic> but he has a very nice standard library, including generic containers (which are parameterized by using #defines)
23:17:38 <psykotic> (i made fast in terms of productivity)
23:17:41 <psykotic> *mean
23:18:23 <wli> That only helps in userspace.
23:18:33 <psykotic> yep
23:18:34 <psykotic> poor you :)
23:18:39 <wli> In-kernel people won't let you use things like that.
23:19:00 <psykotic> http://www.nothings.org/stb.h, fwiw
23:19:01 <glguy> I saw wli mentioned in the interview with the maintainer of the -ck branch
23:19:05 <glguy> ex-maintainer rather
23:19:21 <wli> That would be me, yes.
23:19:24 <glguy> regarding your enhancements to the cpu scheudler
23:19:48 <wli> I've gone to extreme lengths to act exclusively by proxy there.
23:23:03 <wli> glguy: I've not read it. I've no idea what was said about me.
23:24:00 <glguy> mostly that your work helped
23:24:06 <glguy> he only briefly touched on it
23:24:39 <wli> I'm surprised to hear that. I've barely done anything personally.
23:44:32 * desp pokes dcoutts 
23:44:41 <desp> @memo
23:44:41 <lambdabot> Maybe you meant: redo temp
23:45:01 <desp> @note
23:45:01 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
23:45:12 <glguy> ?help tell
23:45:13 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
23:45:19 <desp> glguy++
23:45:21 <newsham> i've been pleasantly suprised at how much theory goodness is in this book: http://www.usingz.com/text/zedbook.pdf
23:45:53 <desp> tell dcoutts Could you add ppc-macos to the Gentoo GHC ebuild? Thanks!
23:45:53 <newsham> supposedly about z-notation, it goes into lots of detail on logic, predicate calculus, functions, algebraic types, etc..
23:46:01 <desp> ugh
23:46:03 <glguy> If that's what I think it is, we have that book at owrk
23:46:05 <desp> @tell dcoutts Could you add ppc-macos to the Gentoo GHC ebuild? Thanks!
23:46:06 <lambdabot> Consider it noted.
23:46:09 <opqdonut> newsham: z-notation?
23:46:11 <glguy> I paged through a bit
23:46:13 <newsham> yah
23:46:32 <newsham> ?google wikipedia z notation
23:46:33 <lambdabot> http://en.wikipedia.org/wiki/Z_notation
23:46:33 <lambdabot> Title: Z notation - Wikipedia, the free encyclopedia
23:46:53 <opqdonut> ah
23:48:02 <newsham> so znotation is kinda off topic for this channel, but this book is a lot more relevant to haskell that I would have thought
23:48:29 <Korollary> It's not that off-topic
23:49:19 * glguy signals all clear
23:49:38 <newsham> glguy: where is work?
23:49:46 <glguy> portland
23:50:10 <newsham> can you be less geographical?
23:50:27 <glguy> Galois
23:50:58 <newsham> ahh, cool.  i'm very interested in that kind of stuff, and I guess that explains why you have znotation there
23:51:08 <newsham> what kind of stuff do you typically do there and how do you like it?
23:53:01 <glguy> I don't Haskell programming on one of their projects (just started working there recently)
23:53:15 <glguy> (Haskell programming rather than model checking, etc0
23:53:17 <glguy> and I love it
23:53:23 <newsham> you "dont" haskell?
23:53:28 <glguy> oh
23:53:29 <glguy> typo
23:54:00 <newsham> what kind of project?  anything you're free to talk about?
23:54:09 <newsham> what kind of clients?
23:54:39 <glguy> The project is called DocServer, its designed to help organizations collaborate better
23:54:46 <dons> everyone works at galois these days. :) well, all the cool kids anyway mwhaha
23:55:13 <newsham> dons: where are you moving to?  cool work?
23:55:27 <dons> i'm moving to portland, to do cool work with glguy :)
23:55:33 <newsham> neat
23:55:34 <glguy> word!
23:55:49 <newsham> whats your thesis on?
23:56:03 <dons>     {\Huge {\bf Dynamic Extension of Typed Functional Languages\\}}
23:56:08 <Pseudonym> Woo!
23:56:20 <newsham> yi/lambdabot stuff?
23:56:36 <Pseudonym> Oh, if only you could get paid to hack lambdabot/.
23:56:41 <dons> yep, and the rest of it, h4sh, polymer simulators, code reloading. that kind of thing
23:56:50 <newsham> cool.
23:57:05 <Pseudonym> glguy, so this DocServer thing.
23:57:08 <Pseudonym> Can you elaborate?
23:58:07 <newsham> http://www.galois.com/xdomain_projects.php
23:58:08 <lambdabot> Title: Cross Domain Technology Services
23:58:14 <glguy> I'm not totally sure actually... that's why I'm seeming so vague
23:58:23 <Pseudonym> Right.
23:58:31 <glguy> its syntaxninja's (isaac) project
23:58:51 <newsham> eww.. MLS :)
23:59:10 <glguy> mls?
23:59:17 <newsham> multi-level security.
23:59:23 <glguy> oh :)
23:59:48 <Pseudonym> I ask because DocServer sounds like information retrieval.
