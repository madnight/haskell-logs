00:00:03 <Cale> quicksilver: I doubt it, but it might take me a minute to come up with an example :)
00:00:13 <Figs> except that left recursion tends to produce associations to the left
00:00:23 <Figs> which causes other issues if it's expected...
00:00:23 <edwardk> check the original applicative paper it makes the case for why you might want different applicative and monad behavior
00:00:39 <Figs> I can't just translate left-recursion into right recursion automatically (even if I knew how)
00:00:43 <quicksilver> edwardk: that wasn't quite my conjecture, though
00:00:53 <Cale> edwardk: Yeah, but only one of those is induced by a monad
00:00:57 <edwardk> hrmm
00:00:59 <quicksilver> edwardk: my conjecture was once you have fixed the appliciative..
00:01:05 <quicksilver> edwardk: there is (at most) one monad
00:01:19 <edwardk> @type ap
00:01:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
00:01:22 <edwardk> hrmm
00:01:30 <shachaf> @src Applicative
00:01:30 <lambdabot> class Functor f => Applicative f where
00:01:30 <lambdabot>     pure  :: a -> f a
00:01:30 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
00:01:54 <edwardk> thanks for reminding me that i'd forgotten ap =)
00:02:02 <quicksilver> it seems to me (arguing purely intruitively) that for a generic 'container' structure, working how to define <*> is much like working out how to make it a monad
00:02:05 <Figs> even though xpressive doesn't really do what I want... maybe the boost people will have an answer...
00:02:47 <shachaf> Figs: I wonder where you got the idea that I can help you. :-)
00:02:56 * shachaf is no expert on this.
00:03:01 <Figs> you responded to me :)
00:03:10 <Figs> 10[23:48:58] shachaf: 01Figs: When will you rewrite all this in Haskell? :-)
00:03:10 <shachaf> Figs: Oh.
00:03:20 <quicksilver> it's equivalent to saying that a monad is defined by its liftMn, for all n
00:03:24 <shachaf> Does someone else feel like responding?
00:03:31 <shachaf> quicksilver: And its return.
00:03:34 <Figs> lol, it's ok... 
00:03:35 <edwardk> so, each bind gives rise to a natural notion of ap, but you want to know does the converse hold when the notion of bind exists?
00:03:42 <Figs> although, if anyone knows... :)
00:03:58 <quicksilver> shachaf: yes, indeed
00:04:06 <Cale> Figs: I don't actually have any idea what you're doing, but from the bits that were happening in between the other conversations I was having, it has something to do with left-recursive grammars?
00:04:21 <Figs> sort of 
00:04:30 <Figs> I'm writing a C++ regex library
00:04:55 <Cale> okay
00:04:59 <Figs> I came here earlier and someone (I think it was ddarius) pointed out that my system had a flaw where left-recursion would screw it up since I was doing recursive descent
00:05:25 <Figs> simply finding infinite loops in my code isn't too hard, I think
00:05:34 <Figs> except in a few cases
00:05:44 <Cale> how do you write a recursive regex?
00:05:54 <Figs> some thing like...
00:06:12 <Cale> (hint: it should be impossible)
00:06:14 <Figs> foo = term( "(" ) >> by_ref(foo)|middle >> term( ")");
00:06:34 <Cale> that's not a regular language
00:06:41 <Figs> it's at least context free, probably context sensitive
00:06:56 <Figs> but if I said cfxp
00:06:59 <Figs> of csxp
00:07:06 <Figs> no one would have a clue wtf I was talking about
00:07:12 <Cale> Yeah, it looks more like a PEG
00:07:17 <Figs> PEG?
00:07:26 <Cale> parsing expression grammar
00:07:31 <mm_freak> where's the (^) operator?
00:07:32 <edwardk> @src ap
00:07:32 <lambdabot> ap = liftM2 id
00:07:33 <Figs> that might be a better term, yes
00:07:50 <Figs> I haven't heard that one
00:08:04 <Figs> anyway, right now, it does recursive descent
00:08:25 <edwardk> well, if ap and return would uniquely define a monad, thats a much stronger statement than the earlier one about LiftMn and return, no?
00:08:45 <edwardk> since then effectively LiftM2 and return would define the monad
00:08:46 <mm_freak> @src (^)
00:08:47 <lambdabot> Source not found. I've seen penguins that can type better than that.
00:08:56 <mm_freak> @help
00:08:56 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:08:57 <Figs> I can do a lot of unusual things with the system so far, for example...
00:09:01 <Cale> Figs: I think that's fine, so long as you provide some other mechanism to handle those cases where you seem to need left-recursion.
00:09:02 <mm_freak> @help list
00:09:03 <lambdabot> list [module|command]
00:09:03 <lambdabot> show all commands or command for [module]. http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
00:09:04 <shachaf> @src liftA2
00:09:04 <lambdabot> liftA2 f a b = f <$> a <*> b
00:09:21 <edwardk> (^) : (MulMonoid a, EuclideanNearRig b, Eq b) -> a -> b -> a; a ^ b = expT (b .* (Log a))
00:09:21 <Figs> foo = (S[0] << +A) >> replace(S[0],A,B);
00:09:24 <shachaf> That's the same as liftM2, isn't it?
00:09:27 <edwardk> woops, wrong Prelude =)
00:09:32 <opqdonut> liftA?
00:09:32 <Figs> or
00:09:54 <mm_freak> does anyone know, in which class (^) is defined?
00:09:58 <edwardk> er s/expT/exp/
00:10:01 <Cale> Figs: oh, it has mutation? :)
00:10:07 <shachaf> @info (^)
00:10:07 <lambdabot> (^)
00:10:12 <opqdonut> Prelude.(^):: (Num a, Integral b) => a -> b -> a
00:10:13 <edwardk> its Num
00:10:15 <Figs> basically it's extensible
00:10:18 <edwardk> and Integral
00:10:29 <Figs> you can write new pattern matches pretty easily
00:10:32 <Figs> or, that's the hope
00:10:45 <mm_freak> edwardk: nope, it's neither Num, nor Integral
00:10:50 <Figs> the regular operators will serve for most purposes, but if you wanted say to do 
00:10:55 <Cale> mm_freak: it's not a class member
00:10:58 <Figs> A^n B^n C^n D^n ...
00:11:00 <mm_freak> seems to be a classless function
00:11:03 <mm_freak> yeah
00:11:03 <Figs> it would be easy
00:11:13 <mm_freak> that sucks
00:11:15 <edwardk> well, it uses them, but doesn't get defined in either yeah
00:11:20 <edwardk> same as in my version =)
00:11:25 <Figs> just take s[0] by reference and write a function to generate the part to match against
00:11:36 <shachaf> @help info
00:11:37 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:11:49 <Cale> mm_freak: What, were you going to define it somehow differently than the Num and Integral instances would make it?
00:11:50 <opqdonut> :i (^)
00:11:59 <opqdonut> ?i (^)
00:11:59 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . v
00:12:07 <opqdonut> ?info (^)
00:12:07 <lambdabot> (^)
00:12:09 <edwardk> btw, speaking of which
00:12:10 <opqdonut> yep, broken :)
00:12:10 <edwardk> @hpaste
00:12:11 <Cale> (**) is a class member
00:12:11 <lambdabot> Haskell pastebin: http://hpaste.org/new
00:12:30 <mm_freak> cale: i'm writing a Mod type for modular arithmetic…  the basics are done, now i just need modular exponentiation
00:12:36 <Figs> if I wanted to reverse something, I could write a reverse function that took the S object by reference and returned a parser for the reverse pattern
00:12:41 <Figs> and do
00:12:46 <Cale> mm_freak: oh, so you wanted to write a more efficient version
00:12:53 <Figs> foo = (S[0] << A) >> reverse(S[0]);
00:12:54 <mm_freak> cale: yes
00:13:03 <Figs> Hello!!olleH
00:13:11 <mm_freak> but i guess, i'll drop it all and implement it as a monad
00:13:14 <Figs> >>><<< etc
00:13:17 <opqdonut> ?src (^)
00:13:18 <lambdabot> Source not found. Maybe if you used more than just two fingers...
00:13:35 <mm_freak> looks like that's going to be the easiest
00:13:47 <Figs> if you wanted to write a module to search a dictionary, you could do
00:13:56 <Cale> mm_freak: er, you could just give your new operator the same name and not import the prelude one, if you wanted
00:14:02 <hpaste>  edwardk pasted "are these too strange?" at http://hpaste.org/1708
00:14:10 <mm_freak> cale: IMO that's bad style
00:14:11 <Cale> Or else you could give it a completely new name :)
00:14:12 <opqdonut> mm_freak: huh? monad? modular arithmetic?
00:14:25 <edwardk> using those as a way to convert between multiplicative and additive monoids, etc.
00:14:27 <Figs> foo = (S[0] << A) >> dictionary_begins_with(S[0]);
00:14:29 <opqdonut> can't see how that'd work
00:14:37 <mm_freak> opqdonut: yes…  the monad could just apply the modulo after each computation
00:14:43 <ski> edwardk : EuclideanNearRig ?
00:15:00 <opqdonut> mm_freak: but that'd place restraints on the type parameter?
00:15:02 <edwardk> mm_freak: have you seen Oleg's modular arithmetic typeclass styff?
00:15:03 <edwardk> er stuff
00:15:07 <mm_freak> such that the type does not hold any ring member anymore, but solely the modulus
00:15:17 <mm_freak> edwardk: nope
00:15:18 <edwardk> stefan: eucliean algorithm works, but almost everything else isn't guaranteed basically
00:15:29 <mm_freak> opqdonut: the type parameter has to be Integral anyway
00:15:45 <ski> (edwardk : was that to me ?)
00:15:45 <Figs> what you can't do though is something like ...
00:15:45 <mm_freak> and since i'm not gonna work with small numbers, i've even speciailized it to Integer
00:15:48 <Cale> mm_freak: how would it do that? The value being operated on is a state parameter?
00:16:03 <Figs> (S[0] << A) >> lookup(S[1]) >> (S[1] << B);
00:16:08 <mm_freak> cale: the modulus being the state 
00:16:14 <edwardk> ski: an example would be the Naturals. i lack additive inverses, but i can divmod in it.
00:16:17 <Figs> because it's recursive descent
00:16:22 <Figs> left to right
00:16:25 <edwardk> ski: er yeah
00:16:51 <Figs> well meh
00:16:54 <Figs> I need to go
00:16:58 <Figs> I'll bb tomorrow though ;)
00:17:03 <Figs> g'night
00:17:11 <Cale> Figs: at some point, I'll show you how this sort of thing might be done in Haskell
00:17:17 <Figs> cool
00:17:18 <Figs> :)
00:17:28 <Figs> I'll hold you to it ;)
00:17:34 <Figs> cya
00:17:37 <Cale> later
00:17:50 <edwardk> ski: the typeclasses underlying are a little more general than normal, but the ideas there can be applied to Num with some hackery.
00:18:09 <mm_freak> cale: like: (>>=) (Mod a n) f = f (mod a n)
00:18:27 * ski just doen't have a good picture of how all variants of ring, etc fits together
00:18:43 <Cale> mm_freak: I don't see how that works type-wise.
00:19:00 <opqdonut> yeah, me neither
00:19:20 <Cale> Remember that n could be of any type at all.
00:19:22 <mm_freak> dunno…  hold on, i'll try it out
00:19:28 <Cale> n could be a String
00:19:30 <Cale> or ()
00:19:33 <Cale> or an IO action
00:19:36 <Cale> or a function :)
00:19:44 <opqdonut> or ur mom, even
00:19:52 <opqdonut> :)
00:19:54 <Cale> yep, even your mom
00:19:57 <ski> or 'RealWorld'
00:19:57 <edwardk> ski: basically its an euclidean domain, with the guarantee of the lack of zero divisors removed (so you can use it over Ints rather than Integers, and the guarantee of additive inverses removed
00:20:01 <mm_freak> cale: well, i'll need to restrict that somehow
00:20:12 <mm_freak> unfortunately Monad needs * -> *
00:20:15 <Cale> right
00:20:16 <opqdonut> restricted monads don't work
00:20:17 <opqdonut> yep
00:20:37 <mm_freak> hmm
00:20:42 <ski> edwardk : euclidean domain ? :)
00:21:08 <mm_freak> cale: but the idea could actually work
00:21:30 <edwardk> mm_freak: http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf is the paper I was mentioning about how Oleg and CC Shan encoded moduli in types, very nice trick
00:21:41 <edwardk> ski: a euclidean domain is basically something with 'divMod' =)
00:21:55 <ski> a ring with some extra things ?
00:22:16 <dolio> Using type-level naturals is the way to go for modular arithmetic, if you ask me.
00:22:27 <mm_freak> edwardk: thanks
00:22:41 <dolio> (^) will automatically be the standard good algorithm, that way.
00:22:59 <edwardk> divMod :: { x : a } -> { y : non-zero a } -> { (q,r) : x = y*q + r && valuation r < valuation y || valuation y == 0 } 
00:23:12 <edwardk> where valuation maps from your domain into the naturals
00:23:18 <edwardk> and acts as sort of a measure
00:23:34 <edwardk> quotRem and divMod are artifacts of different valuations over the integers.
00:24:20 <mm_freak> dolio: you're right…  it performs pretty well
00:24:31 <Cale> If you really want a fast powerMod operation, you probably want to work with the binary representation of the exponent directly.
00:24:31 <mm_freak> ok, no need to write an own function =)
00:24:44 <mm_freak> cale: that's what i'm doing
00:24:54 <mm_freak> modexp (!b) !e !p !n | (e == 0)  = p | (even e)  = modexp (mod (b*b) n) (shiftR e 1) p n | otherwise = modexp b (e-1) (mod (p*b) n) n
00:24:59 <mm_freak> aaaaaah
00:25:00 <mm_freak> damned
00:25:15 <mm_freak> but you get the point =)
00:25:22 <ski> edwardk : hm, shouldn't 'r' be an element of a quotient type ?
00:25:27 <Cale> That's fine.
00:25:37 <edwardk> er { (q,r) : (a,a) | x = ...   }
00:25:43 <Cale> mm_freak: That should all parse as one line, I think.
00:25:46 <mm_freak> cale: (^) seems to work the same way
00:25:55 <edwardk> would be the concrete syntax
00:25:57 <Cale> Oh, interesting.
00:26:06 <Cale> I suppose that's why it needs an Integral :)
00:26:10 <mm_freak> cale: it's actually multiple lines, but i've configured my client to join indented lines
00:26:30 <mm_freak> cale: yeah…  Floating provides a separate function, which doesn't use Integrals
00:27:13 <Cale> mm_freak: right, because it provides a completely different kind of exponentiation :)
00:27:38 <mm_freak> not different, but generalized =)
00:27:49 <edwardk> ski: the (q,r) pair is in a subset type, not a quotient type as you can check correctness of subsets and i'm not sure what the quotient would be in this case, grouping them by valuation isn't the right answer because divmod gives back a particular r not the equivalence class =)
00:28:08 <Cale> mm_freak: Also, de-generalised
00:28:08 <mm_freak> actually both generalized (to arbitrary exponents) and specialized (to numbers)
00:28:15 <Cale> right
00:28:20 <ski> edwardk : i wanted 'r' to be in a quotient
00:28:35 <edwardk> the problem is if you take a quotient over it, you can't compute with it concretely
00:28:40 <ski> (and then '(q,r)' could be in a subtype, as well)
00:28:58 <mm_freak> now my Mod type is an instance of (Eq, Show, Num, Fractional)
00:29:31 <edwardk> so i'm not sure how a quotient over a of all values with the same valuation (which i presume is the quotient you mean) helps
00:29:38 <ski> edwardk : hm .. why do you express this property in the result type of the function at all ?  to be able to take inverse of the function ?
00:29:49 <mm_freak> is there a predefined extended GCD function?  i've written it myself, but probably someone has already written a more optimized version
00:30:22 <ski> edwardk : an example quotient would be Z/5Z
00:30:33 <ski> (for division by '5')
00:31:00 <ski> Z  ~=  Z * Z/5Z
00:31:29 <edwardk> well, in this case, the definition that says how a euclidean domain extends a ring is it adds a valuation and divMod function where the divMod function satisfies that law. if it doesn't, then it isn't a euclidean domain. that gives the compiler the ability to try to prove the correctness of your instance
00:32:31 <edwardk> ski: the problem i have with that is if i'm using divMod its not because i want to change rings, its because i want to know the remainder in the ring i have. [4]_Z/5Z means a very different thing when projected back into Z.
00:32:40 <ski> ok .. so you just wanted to shorten and make it neater, by folding the function and the property into the same "thing"
00:32:44 <ski> ?
00:32:57 <edwardk> yeah more or less
00:33:11 <ski> (i don't complain about that :)
00:33:38 <Cale> edwardk: [4]_Z ?
00:33:38 <edwardk> and it keeps you from implementing a fake version of the class that doesn't satisfy the laws without the compiler complaining at you =)
00:33:48 <ski> '[4]_Z/5Z' ?
00:34:01 <edwardk> 4 in Z/5Z i should have said
00:34:23 <ski> edwardk : but you could have made a separate property member in the class, yes ?
00:34:37 <Cale> 4 + 5Z :)
00:34:37 <edwardk> the law?
00:34:40 <edwardk> yeah
00:34:44 <edwardk> er
00:34:50 <edwardk> the yeah was to Cale =)
00:35:16 <ski> "means a very different thing when projected back into Z" ?
00:35:28 <edwardk> the 'separate property in the class' is awkward because its best for me to check laws about results in the subset type system because then they are flow directed. 
00:36:04 <ski> ah .. the run-time checking
00:36:09 <edwardk> 9 `divMod` 5 = (1,4) the 4 is intended as an actual member of the euclidean domain D, not of some equivalence class formed over it.
00:36:33 <ski> do you need that ?
00:36:33 <edwardk> well, actually its compile time checked by default, the flow in question is the abstract interpretation =)
00:36:46 <edwardk> http://en.wikipedia.org/wiki/Euclidean_domain read the definition =)
00:36:47 <lambdabot> Title: Euclidean domain - Wikipedia, the free encyclopedia
00:36:53 <ski> (ok, compile-time run-time :)
00:38:14 <edwardk> we are interested in 4 not all the other things that happen to have the same remainder modulo our particular divisor. your version would cost us trivial invertability and require an explicit projection back into the original ring in order to continue to use it for GCDs, etc.
00:38:32 <edwardk> so the utility of the notion of divMod would be compromised
00:39:55 <edwardk> i'm perfectly ok with another mod operator that does something like that, but I don't think they are the same
00:40:31 <iakovz> hello
00:41:43 <shachaf> iakovz: Hello.
00:44:15 <ski> edwardk : does 'valuation' only map '0' to '0' ?
00:44:26 <ski> s/only map/map only/
00:44:46 <moritz> hi
00:44:51 <ski> hello there
00:44:59 <moritz> I have some problems with installing ghc 6.6.1 on debian...
00:45:28 <moritz> I have debian etch (aka stable), and recompiled 6.6.1 from the testing sources
00:45:43 <Cale> That would have taken a while :)
00:45:52 <moritz> and these are the problems I get when installing ghc6-doc: http://sial.org/pbot/26329
00:45:53 <lambdabot> Title: Paste #26329 from "moritz" at 84.148.35.162
00:45:59 <Cale> I'd have probably just installed the generic binary
00:46:15 <edwardk> ski: not sure about that, some euclideandomains could be a little weird. the practical ones i can think of do
00:46:28 <Cale> moritz: Which version of haddock do you have installed?
00:46:32 <moritz> Cale: but can I get that as a debian packages?
00:46:43 <moritz> Cale: 0.8-2
00:46:52 <moritz> Cale: recompiled from testing sources as well
00:47:01 <Cale> oh, hmm
00:47:34 <moritz> and I had some problems deisntalling two of the libghc6-*-dev packages due to broken prerm-packages ;)
00:47:50 <ski> edwardk : i parse 'a = bq + r and either r = 0 or v(r) < v(b)' as 'a = b*q + r /\ (r = 0 \/ v r < v b)'  .. how do 'x = y*q + r && valuation r < valuation y || valuation y == 0' parse ?
00:48:19 <edwardk> hrmm, i wonder if it could actually be beneficial to define some form of template haskell type hackery that understood how to unravel a bunch of [d|     |] blocks into their appropriate typeclasses and built the right instances when you said 'Field' and gave the definitions for the operators
00:48:57 <Cale> I don't think I've ever successfully recompiled a package from a newer version of debian, but that could just be bad luck on my part.
00:49:01 <edwardk> that was just rattled off my cuff, you got the right interpretation =)
00:49:14 <Cale> The generic linux binary would work, but it wouldn't be a debian package.
00:49:24 <quicksilver> edwardk: no, I don't think it's any stronger
00:49:45 <shachaf> moritz: Can't you use the generic binary with checkinstall or similar?
00:49:49 <quicksilver> edwardk: return is liftM0, fmap is liftM1, and ap is (definable using) liftM2
00:49:49 <Cale> You could also possibly just move to testing.
00:49:57 <moritz> Cale: normally it works... I'd install the binaries from testing, but that is compiled against a newer libc6 :(
00:50:08 <quicksilver> edwardk: so the liftMi claim is the same as the 'ap' claim
00:50:10 <edwardk> quicksilver: then doesn't your question devolve to if liftM2 and return can uniquely define the bind operation?
00:50:23 <edwardk> since you can define ap in terms of liftM2?
00:50:24 <quicksilver> edwardk: yes
00:50:34 <ski> edwardk : actually, i'm wondering why the domain of 'v' is restricted to not include '0' (e.g. in that WP article)
00:50:40 <edwardk> thats all i was saying, the other claim was that if you knew liftMn for all n, no?
00:50:47 <quicksilver> yes
00:50:51 <mm_freak> edwardk: that paper is very interesting, thank you
00:50:57 <quicksilver> that was just a more elegant way of expressing it
00:50:57 <moritz> shachaf: I'll try that
00:51:01 <quicksilver> I agree it's no more minimal
00:51:34 <edwardk> mm_freak: no problem. i found it to be a really neat trick myself =)
00:51:35 <moritz> Cale: moving to testing is not an option... I have to keep my system as close as possible to an existing server (that runs stable)
00:51:45 <Cale> moritz: ah
00:52:02 <shachaf> moritz: I know someone who used the generic binary on Ubuntu before they had 6.6, and it worked.
00:52:13 <shachaf> moritz: I'd guess this would be similar.
00:52:14 <mm_freak> edwardk: yeah…  i don't understand it fully from the first example, but i guess, it'll clarify things later =)
00:52:17 <Cale> I've used the generic binary on Ubuntu.
00:53:31 <shachaf> mm_freak: "yeahâ¦  " -- is this on my side or on yours?
00:53:43 <edwardk> mm_freak: the basic trick is you abuse polymorphism to carry around a term value reified into a type, then they show you can encode anything in haskell into a type that way, to get a form of implicit parameter passing with a way to enforce the same terms are being used in different locations. i.e. that you are always computing w.r.t the same modulus
00:53:53 <ski> quicksilver : are you arguing that '(>>=)' is definable by the 'liftM' functions ?
00:54:04 <shachaf> mm_freak: I've been wondering, this isn't my regular terminal.
00:54:12 <quicksilver> ski: I was speculating, yes
00:54:21 <moritz> if I do a "runghc Setup.hs install" of a cabal package, can I do an unistall in the same way?
00:54:35 <mm_freak> shachaf: on your side…  i'm using UTF-8
00:54:38 <shachaf> quicksilver: Are you saying every Applicative is a Monad?
00:54:39 <quicksilver> ski: more precisely, my conjecture was that any Applicative instance is compatible with at most one Monad instance
00:54:48 <mm_freak> those weird characters should actually be an ellipse ("...")
00:54:51 <quicksilver> shachaf: no no. 'at most one'.
00:54:56 <shachaf> quicksilver: Yes, that's what I understood before.
00:55:02 <shachaf> mm_freak: Oh.
00:55:02 <edwardk> ski: the speculation in question as i understand it is if given a definition for ap and return, if there is only one definition of bind that is compatible. i.e. one way to transform an applicative into a monad.
00:55:17 <edwardk> er at most one
00:55:28 * shachaf wishes his computer worked, so he could use urxvt again.
00:55:38 <Cale> I really really doubt that, but I don't have a counterexample on hand :)
00:55:40 <mm_freak> edwardk: i've understood the semantics, but i couldn't do it myself yet
00:56:26 <Cale> At least, it would be extremely surprising to me if there weren't some applicative functor that was a monad in two different ways.
00:56:41 <edwardk> mm_freak: i toyed with using that to pass around command-line flags in my compiler
00:58:07 * edwardk is striding down a slippery slope very fast
00:58:36 <shachaf> moritz: I don't think so.
00:59:09 <shachaf> moritz: There's unregister, but I've always deleted the files manually when necessary (probably a bad idea).
00:59:40 <moritz> shachaf: I noticed it installs to /usr/local/*, so I don't mind ;)
00:59:40 <mm_freak> edwardk: yeah, command line flags are my current problem
00:59:41 <edwardk> ok, so i accepted that if 'a' is a monoid/magma/etc it should also be the case that (b -> a) is a monoid/magma. similarly if (==) :: a -> a -> b    for some a and b, then (==) :: (c -> a) -> (c -> a) -> (c -> b) should also be allowed
00:59:55 <mm_freak> it already starts with a simple "verbosity" value, which i really need to pass almost everywhere
00:59:56 <edwardk> similarly for (&&), (||), etc.
01:00:12 <ski> edwardk : environment ?
01:00:19 <edwardk> yeah
01:00:26 <edwardk> trivially lifting them into the reader monad basically
01:00:36 <ski> hm, that latter '(==)' looks a bit strange :)
01:00:38 <edwardk> since it is unambiguous
01:00:54 <edwardk> it does give some nice things like
01:01:01 <edwardk> filter (isAlpha || isDigit)
01:01:50 <ski> possibly one can think of it as a construct where objects are carriers^c
01:01:59 <edwardk> and I went and said that my main goal is to preserve type inference, so i'll allow class ExpOp a b | a -> b, b -> a where exp :: a -> b   sort of things, so i can use Log and Exp type classes to map additive foo to multiplicative foo
01:03:17 <edwardk> which i thought was particularly clean, and can similarly handle the environment. but then when you get to things like fst and snd, they start to call out to lift as well ;)
01:04:59 <edwardk> (f `divMod` g) given f :: b -> a, g :: b -> a, EuclideanNearRig a returns a pair of functions to be consistent with the rest of the numerical hierarchy, which then says i should allow myself to apply fst and snd to functions ;)
01:05:15 <edwardk> just not quite sure where this ends =)
01:05:29 <ski> what if 'b' is 'Bool' ?
01:05:47 <ski> do you get point-wise application over tuples ?
01:06:03 <moritz> Cale, shachaf: thanks for your help
01:06:11 <shachaf> moritz: It works?
01:06:18 <edwardk> (f + g) True = f True + g True   right now
01:06:35 <edwardk> divMod is the one i'm not sure of the right semantics for
01:06:37 <ski> fst (f + g) = fst f + fst g
01:07:01 <ski> (a,b) + (c,d) = (a + c,b+d)  -- i.e.
01:07:01 <moritz> shachaf: sadly not. the generic binary needs readline 4, which I can't find
01:07:17 <moritz> shachaf: I decided to live without ghc6-doc for the moment
01:07:22 <shachaf> moritz: Oh, I remember reading about people who had that problem.
01:07:27 <edwardk> i have lifting of magmas etc over tuples already
01:07:29 <edwardk> so the latter works
01:07:40 <edwardk> the fst case i haven't got implemented yet
01:08:10 <shachaf> moritz: Does Debian not have a readline4 package?
01:08:16 <edwardk> fst f = fst . f  ?
01:08:23 <mm_freak> what confuses me all the time…  what is a "first-class object"?
01:08:25 <ski> no
01:08:35 <ski> edwardk : 'f' was a pair there .. i.e. a function from 'Bool'
01:08:43 <moritz> shachaf: not in stable. I haven't looked at oldstable
01:08:46 <quicksilver> mm_freak: something which can be passed around the language as a 'normal value'
01:09:03 <mm_freak> quicksilver: an example of a non-first-class object?
01:09:07 <edwardk> where in that the assumption is i'm using f to refer to a function
01:09:08 <ski> f : (b : Bool) -> if b then a1 else a0
01:09:20 <quicksilver> mm_freak: in C or Java, functions are not first-class
01:09:29 <mm_freak> ah k
01:09:30 <quicksilver> mm_freak: in haskell, patterns are not first class
01:09:37 <quicksilver> or modules
01:09:38 <edwardk> not sure where you are going with the bool thing
01:09:40 <mm_freak> thank you
01:09:47 <shachaf> moritz: Yes, it's in oldstable.
01:09:54 <shachaf> (According to debian.org.)
01:10:01 <mm_freak> what is a higher-order function?  a function, that returns another function?
01:10:03 <edwardk> you want (a,a) to be sort of indexed by True,False?
01:10:06 <ski> in C "functions" are first-class
01:10:17 <mm_freak> ski: function pointers are, not functions themselves
01:10:33 <ski> edwardk : as an example .. needn't be exactly 'Bool', though
01:10:38 <quicksilver> mm_freak: typically a higher order function is a function that takes a function as a parameter
01:10:50 <edwardk> doesn't fit really well with the rest of my system i think
01:10:58 <ski> mm_freak : just terminology :)
01:10:58 <edwardk> this is actually haskell code right now =)
01:11:29 <mm_freak> ski: nope, there is a technical difference between the two =)
01:11:32 <ski> edwardk : the exponential above, too ?
01:11:44 <edwardk> the ExpOp case?
01:11:59 <edwardk> yeah using a toy prelude i've been porting over from my compiler and working on as i go
01:12:09 <mm_freak> calls via function pointers are translated to indirect calls in opcode
01:12:19 <ski> (mm_freak : yeah .. which was why i said "\"functions\"" ..)
01:12:38 <ski> (mm_freak : and how does 'map' call its argument ?)
01:12:39 <edwardk> i just break out each operator separately into a typeclass
01:12:43 <edwardk> its making for instance hell
01:12:46 <edwardk> but its not all that bad
01:13:19 <edwardk> i'm kind of tempted right now to put together some template haskell magic for stringing together the right instances given the definitions of all the functions that go into them
01:13:22 <ski> istr Clean had more separated numeric classes
01:13:26 <mm_freak> ski: let's call them procedures =)
01:13:29 <ski> s/had/has/
01:14:14 <ski> mm_freak : (i can't recall the term rn, but) let's call them first-order procedures, then
01:14:43 <mm_freak> ski: most likely via indirect calls, but that's not so easy to predict
01:14:45 <edwardk> @hpaste
01:14:46 <lambdabot> Haskell pastebin: http://hpaste.org/new
01:15:21 <mm_freak> now what is a first-order function?  a function that takes only values?
01:15:53 <JKnecht> same as 1st order formula I would guess
01:16:15 <ski> what i wanted to express, but can't recall term for was : not being able to use local variables defined outside a function .. i.e. no closures
01:16:16 <hpaste>  edwardk pasted "misc. algebraic classes" at http://hpaste.org/1709
01:16:53 <ski> the type being '[](a -> b)' with '[]' being a "neccisity" modal operator
01:17:03 <quicksilver> mm_freak: yes, first order means it takes only values as parameters
01:17:45 <mm_freak> quicksilver: what's the difference between second-order and third-order?
01:18:05 <edwardk> as you can see to define a Num takes like 7 typeclasses now, hence why i'm thinking the TH wizardry might not be a bad idea
01:18:16 <dolio> secondOrder :: (a -> b) -> c, thirdOrder :: ((a -> b) -> c) -> d
01:18:27 <ski> (n+1)th-order things can take nth-order things as arguments
01:18:46 <ski> (0-order things doesn't take arguments)
01:19:03 <mm_freak> ok, thanks
01:19:42 <edwardk> $(additiveGroup [ [d|zero = ...|], [d|(+) = ... |], [d|negate = ...|] ])   
01:19:49 * ski had some omega-order functions in a project
01:22:46 <edwardk> at present i'm using a lot of CPP stuff to prepopulate those from the traditional prelude
01:22:49 <edwardk> which isn't ideal
01:23:20 <edwardk> though it does have the advantage that things can be defined and used in the same file
01:25:53 <edwardk> so, next question
01:26:17 <edwardk> I implicitly lift (+) , etc into the reader monad. these also make sense lifted into other monads. would that be too weird?
01:26:34 <edwardk> @hpaste
01:26:34 <lambdabot> Haskell pastebin: http://hpaste.org/new
01:29:12 <dolio> I've seen it suggested before.
01:30:05 <hpaste>  edwardk pasted "monadic math" at http://hpaste.org/1710
01:30:28 <edwardk> in my case its a little easier coz i don't have spurious Show and Eq requirements everywhere
01:30:45 <dolio> Indeed.
01:31:57 <hpaste>  edwardk annotated "monadic math" with "fixed typos" at http://hpaste.org/1710#a1
01:32:12 <shachaf> Hmm. Would something similar to "instance Monad a where x >>= f = f x; return = id" be possible/a good idea?
01:32:34 <ski> (edwardk : hm .. you don't have loops or moups ?)
01:32:46 <edwardk> shachaf: it doesn't work at last check
01:32:52 <quicksilver> shachaf: http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Identity.html ?
01:32:54 <lambdabot> http://tinyurl.com/ydy84p
01:33:00 <dolio> 'a' isn't a type constructor there.
01:33:11 <shachaf> quicksilver: Yes, except without thee Identity part.
01:33:15 <shachaf> dolio: Hmm.
01:33:18 <edwardk> ski: i stuck to defining the points in the hierarchy that have operational meaning to haskell. where a new operator was introduced basically.
01:33:33 <ski> instance Monad (\a -> a)  -- not allowed by haskell
01:33:43 <quicksilver> shachaf: without the identity part it isn't a type constructor any more, so it can't be a monad?
01:33:45 <shachaf> Well, you know what I mean, anyway. Is something similar possible, at all?
01:33:55 <ski> edwardk : ok
01:34:04 <shachaf> quicksilver: I guess.
01:34:06 <edwardk> shachaf: you need the Identity constructor in there
01:34:31 * shachaf wonders what he means, exactly. :-)
01:34:41 * shachaf should go to sleep.
01:35:12 <edwardk> shachaf: Monad m expects m :: * -> *  your a has kind *
01:35:52 <shachaf> edwardk: Yes, I know.
01:35:56 <edwardk> to get something of kind * -> * you'd need a type, newtype or data declaration that took an argument, the type thing would appear to work at first glance, except you can't use 'type's as arguments to typeclasses.
01:36:26 <shachaf> edwardk: Why not, by the way?
01:36:37 <edwardk> because they reduce themselves to normal form silently on you, so they aren't there for the typeclass or instance to look at
01:37:03 <edwardk> type Foo a b  = a -> b    when used as Foo a b is indistinguishable from a -> b
01:37:32 <edwardk> so type MyIdentity a = a   seems at first like it might work, but when the compiler gets around to looking at it its already an a, no longer a 'MyIdentity a'
01:37:56 <shachaf> OK, that makes sense.
01:38:19 <edwardk> I have kind of wondered if a much much lazier compiler could keep those around longer =)
01:38:48 <edwardk> but i don't think its practical and it would rely on letting the compiler redo a lot of work to get consistent semantics, etc.
01:38:59 <quicksilver> edwardk: but it might be a bit surprising, you could accidently 'erase' a type by passing through 'id'
01:39:03 <edwardk> yep
01:39:16 <quicksilver> id :: [Char] -> [Char] would 'anonymise' a String
01:39:19 <quicksilver> e.g.
01:40:21 <edwardk> yeah, i played with it, but couldn't come up with any sort of consistent semantics
01:41:26 <edwardk> hrmm, wondering what weird effects you get from the monadic math stuff now that i'm looking at now just readers and writers, etc.
01:41:27 <dolio> You could do some crazy stuff that way.
01:41:55 <dolio> type ComposeT f g m a = f (g m) a
01:42:29 <dolio> instance (MonadTrans f, MonadTrans g) => MonadTrans (ComposeT f g) where lift = lift . lift
01:42:51 <ski> edwardk : istr ghc allows type-synonyms in instance heads .. not partially applied, though
01:43:26 <ski> s/not partially/only fully/
01:43:34 <kolmodin> @yarr! -- morning
01:43:34 <lambdabot> Swab the deck!
01:43:43 <ski> indeed!
01:44:09 <edwardk> ski: sure, because then they know they can reduce them fully, and won't wind up with any weird 'holes' in the middle of the type
01:44:23 <ski> right. no lambda types
01:44:29 <edwardk> > liftM2 (*) [1,2,3] [4,5,6]
01:44:31 <lambdabot>  [4,5,6,8,10,12,12,15,18]
01:44:33 <edwardk> hrmm
01:44:46 <edwardk> is that the semantics we'd want a [1,2,3] * [4,5,6] to have?
01:45:07 <ski> > liftM2 (+) [100,200,300] [4,5,6]
01:45:08 <lambdabot>  [104,105,106,204,205,206,304,305,306]
01:45:23 <ski> if we want left-to-right evaluation of the effects, yes
01:45:39 <quicksilver> > zipWith (*) [1,2,3] [4,5,6]
01:45:40 <lambdabot>  [4,10,18]
01:45:43 <dolio> You could define it for arbitrary Applicatives.
01:45:51 <ski> (in the list monad, i forgot to say :)
01:45:53 <quicksilver> anand then again, maybe I'd ratehr have that one :)
01:45:54 <edwardk> i'd kind of hoped to use + for the natural list append monoid. that hope appears to be gone =)
01:45:55 <dolio> Then you could choose between [] and ZipList.
01:46:01 <edwardk> but this is more consistent
01:46:04 <quicksilver> as dolio says
01:47:26 <edwardk> well, the reader monad is natural, writer, state, and blech even IO works, its just list that sticks in my craw a bit
01:48:23 <edwardk> and of course that becomes rather funny when mixed with the parameterized monad stuff from the other day =)
01:48:33 <edwardk> Just 2 * [1,2,3]    etc =)
01:49:16 <edwardk> though that doesn't work =(
01:49:22 <edwardk> it would cost us type inference for *
01:51:02 <edwardk> it does work nicely for the set and bag restricted monads though, giving a proper everything-to-everything operation
01:51:59 <ClaudiusMaximus> @hoogle finalizer
01:51:59 <lambdabot> Foreign.Marshal.Alloc.finalizerFree :: FinalizerPtr a
01:51:59 <lambdabot> Foreign.ForeignPtr.FinalizerPtr :: type FinalizerPtr a
01:51:59 <lambdabot> Foreign.Concurrent.addForeignPtrFinalizer :: ForeignPtr a -> IO () -> IO ()
01:52:21 <edwardk> but it changes the meaning of (==) in a weird way, (==) for the reader monad lacks an alternative interpretation, but when you talk about lists or sets or bags it has a clear interpretation
01:52:29 <edwardk> =(
01:52:49 <quicksilver> yes
01:53:05 <quicksilver> that's why we (sometimes) want to distinguish between foo and liftM2 foo :)
01:53:21 <edwardk> heh
01:53:37 <quicksilver> distinguishing between ++ and liftM2 ++, too....
01:53:44 <edwardk> i realize, but until i moved from Reader to a general monad i didn't have a good counter example =)
01:54:03 <quicksilver> you're doing some really cool magic, but sometimes cool magic can become confusin
01:54:48 <edwardk> so, one answer might be to define a class Monad m => MonadMath m
01:54:53 <edwardk> then use the magic math stuff that way
01:55:29 <edwardk> i.e. iff there is no reasonable interpretation of the mathematical operators in another way lift them 
01:55:46 <edwardk> but if you have something like lists etc, don't lift them by default
01:55:52 <wli> edwardk: sounds interesting; what's going on here?
01:56:04 <edwardk> playing with the stuff from my toy prelude some more
01:56:18 <quicksilver> edwardk is pushing back the boundaries of sugar
01:56:25 <edwardk> wli: the current question has to do with automatic lifting of mathematical operations into various monads.
01:56:32 <wli> edwardk: Seen Oleg's BinaryNumber.hs?
01:56:57 <edwardk> i already accepted the notion that given say a Monoid instance for 'a' then you should get a Monoid for b -> a,   which is the reader monad
01:57:17 <edwardk> so the question arose if it just make sense to define (+) = LiftM2 (+) for all monads
01:57:34 <edwardk> similarly (==), (&&), (||), etc lift nicely
01:57:47 <edwardk> but then it compromises the notion of equality comparison directly on lists
01:57:53 <wli> edwardk: Built-in syntactic sugar or Oleg's BinaryNumber.hs would be very spiffy.
01:57:54 <edwardk> even though it works nicely in the reader monad
01:58:01 <edwardk> which one is that?
01:58:06 <wli> s/sugar or/sugar for/
01:58:24 <edwardk> wli: heh, have you seen my version of that sort of thing?
01:58:33 <wli> edwardk: no
01:58:58 <quicksilver> edwardk: your pain would be allayed, somewhat, by syntax for choosing among alternative instances
01:59:05 <edwardk> http://comonad.com/haskell/type-int/src/Data/Type/
01:59:07 <lambdabot> Title: Index of /haskell/type-int/src/Data/Type
01:59:26 <quicksilver> edwardk: then it wouldn't matter that there were two instances for Eq [a], etc
01:59:26 <edwardk> the Binary/ directory is the one of interest in the current discussion
01:59:30 <edwardk> yeah
02:00:08 <edwardk> in my toy compiler i allow dictionary passing by name, which plays some weird games with the semantics for dictionaries and typeclass inference i'm not QUITE sure i like yet
02:00:38 <edwardk> sort .by anotherordinstance ...
02:01:10 * wli sees
02:01:22 <wli> good stuff in the numbers
02:01:23 <quicksilver> edwardk: yes. Have you seen the paper on that?
02:01:27 <edwardk> sort :: (.by : Ord a) => [a] -> (result : [a] | sorted result)
02:01:29 <edwardk> yeah
02:01:31 <quicksilver> edwardk: they used the syntax '#' for application
02:01:34 <edwardk> wli: thanks
02:01:42 <edwardk> wli: the hex one is the scary part
02:01:46 <wli> Totally reasonable.
02:01:53 <edwardk> derives about 5 megs of haskell =)
02:02:04 <quicksilver> although I favour some kind of lexical approach myself
02:02:30 <wli> edwardk: Does it boil down to decently small programs despite 5M of source?
02:02:54 <edwardk> quicksilver: yeah, what i'm using is .foo for named field dereference, and i've conflated the notion of functions and records so that accessing a named argument is looking up a named field in the function, which returns a new function pushing that argument to the front
02:03:17 <edwardk> wli: they don't seem to be any worse than normal haskell programs
02:03:25 <edwardk> wli: its just a huge library in the middle
02:04:34 <edwardk> quicksilver: then i just allow the implicit dictionaries to be made explicit by passing them by name, requires a few more type annotations to be able to pass one in by name, which i'm not happy with but i think it may be the way i have to go
02:04:47 * quicksilver nods
02:05:01 <quicksilver> edwardk: I like the idea of a language construct
02:05:18 <quicksilver> using MonoidFromMonadPlus { ... expr ... }
02:05:33 <quicksilver> edwardk: then, inside that scope, the notion of 'default' dictionary is changed
02:05:40 <edwardk> thought about it, but the syntax is horrible =)
02:05:58 <edwardk> and what is inside the scope, everything written in the scope or everything called by anything written in the scope
02:06:10 <edwardk> what if i call into that scope is it dynamically of lexically bound, etc.
02:06:43 <edwardk> to steal a quote from dan friedman 'scope is everything' =)
02:07:04 <quicksilver> edwardk: lexical, not dynamic, obviously
02:07:11 <quicksilver> edwardk: dynamic scopes are the work of the devil
02:08:22 <edwardk> well, thats somewhat problematic still, because what if the compiler elides the dictionary for a few calls of depth knowing it can rederive it later? so now this interferes with optimizations? =) this is actually a spurious argument becausse i currently require myself to compile two versions, one optimized one for explicit calls ;)
02:09:15 <edwardk> dynamic scopes have their place. i never thought i'd say it but i think oleg won me over with some of the dynamic binding + delimited control use cases.
02:09:17 <quicksilver> edwardk: well obviously it can't elide dictionaries if they have been explicitly chosen as a non-default
02:09:34 <quicksilver> edwardk: at least, it can't do that upfront
02:09:35 <dolio> Yeah, I thought that was an interesting paper, too.
02:09:53 <quicksilver> edwardk: after it's parsed + type checked everthing, then it can elide all kinds of dictionaries, cos they're mostly compile-time-constant
02:09:56 <dolio> I hadn't thought of Reader as dynamic scoping before, but I suppose you can look at it like that.
02:10:08 <edwardk> yeah
02:10:13 <quicksilver> dolio: I would look at it as 'dynamic scoping done right', though
02:10:22 <vincenz> moin
02:10:27 <wli> I'm much stodgier about these things.
02:10:29 <dolio> His dynamically scoped variables are different than you see in, say, old lisps, though.
02:10:29 <quicksilver> dolio: dynamic scoping but 'explicit' in the types so you can see what's happening
02:11:06 <dolio> Since you need to get a name for the scoped variable from someone. You can't just use an arbitrary name that happens to change depending on where you're called.
02:11:07 <edwardk> wli: anyways the type integers there are largely inspired by oleg tricks, i just needed some that actually were fully fleshed out
02:11:35 <wli> edwardk: I presume they're sugared in the source language?
02:11:53 <edwardk> because while Oleg is brilliant, the man doesn't exactly spend his time polishing his ideas beyond a point before he goes off to do something else =)
02:12:06 <dolio> Heh.
02:12:42 <edwardk> wli: there are sugared witnesses for them, tAdd foo bar.  and $(hexE 123) gives you a compile time generated numeric term.
02:13:48 <edwardk> show (tAdd $(hexE 123) $(hexE (-123)))   should output "$(hexE 0)"
02:14:19 <edwardk> and the witnesses type infer values in all possible directions
02:15:23 <edwardk> i mostly did it because i wanted to think through infinite precision 2s complement arithmetic
02:15:38 <edwardk> i find the adder becomes amazingly symmetrical in that setting, etc.
02:16:05 <wli> witnesses?
02:16:55 <edwardk> well, the idea of type level arithmetic is you usually don't have members of your types, right? other than undefined that is. so you supply term-level functions for passing around those differently typed undefineds to perform calculations at the type level
02:17:33 <edwardk> those term-level functions that reify the type-level calculations down from typeclasses to the term syntax are what I was calling witnesses.
02:18:00 <wli> You could have a single member for each.
02:19:49 <edwardk> result = tAdd $(hexE 3) $(hexE 64)      is a fancy way of saying the constraint result :: TAdd (X3 F) (X4 (XF F)) z => z; result = undefined
02:20:31 <edwardk> wli: you COULD, but then the compiler can't fully erase the types and then you have to deal with the implicit bottom member as opposed to the explicit member etc.
02:20:48 <edwardk> its generally better form to not allow a singleton member in a witness if you can get away with it
02:21:00 <edwardk> empty data declarations state intent to erase quite nicely =)
02:21:45 <wli> edwardk: What's a witness?
02:21:51 <roconnor> @where monad laws
02:21:51 <lambdabot> I know nothing about monad.
02:22:11 <edwardk> a witness is just a term level function like  tOdd :: TOdd a b => a -> b; tOdd = undefined
02:22:31 <edwardk> for a type level relation like:  class TOdd a b | a -> b;  instance (LSB a b c, TNot b b') => TOdd a b' 
02:23:38 <edwardk> tOdd takes one argument and returns its answer, its argument's value is never looked at just its type, and it generates an answer whose type is purely dependent on the type of the argument through the functional dependency in TOdd's definition
02:24:17 <edwardk> tOdd 'witnesses' the relationship that TOdd creates between a number and a boolean value, by allowing you to write it at the term level rather than the type level.
02:24:33 <wli> okay
02:24:50 <edwardk> they are the sugar you mentioned =)
02:24:52 <wli> I didn't know there was a name for that.
02:25:18 <edwardk> the only problem is that you can't overload the normal (+) to manipulate the type level terms or you lose type inference for the normal use cases =(
02:25:53 <edwardk> ideally i'd go back and make a consistent convention, like (+:) or something
02:25:56 <wli> edwardk: I was thinking more of the compiler/interpreter translating type names written with decimal digits to the binary/whatever strings.
02:26:30 <edwardk> wli: thats what the template haskell $(hexE 123891) expressions are for
02:27:17 <dblhelix> are there any standard arrows implemented in the hierarchical libraries? reader arrows, writer arrows, state arrows, etc.?
02:27:37 <wli> dblhelix: I wish. I've not seen anything of the sort.
02:27:38 <edwardk> $(hexE 255) returns the equivalent of having written (undefined :: XF (XF F))
02:28:02 <edwardk> and $(hexT 255) returns the type itself XF (XF F)  for use in type-level expressions
02:28:03 <dblhelix> we need an arrow template library!
02:28:14 <wli> edwardk: Some sort of lexical construct that expands to that would be nice.
02:28:54 <wli> TypeNat123 etc.
02:29:03 <edwardk> wli: $(hexE 123) _is_ that lexical construct =) thats the only escape we can get right now.
02:29:21 <dblhelix> wli: what about http://hackage.haskell.org/cgi-bin/hackage-scripts/package/arrows-0.2
02:29:24 <lambdabot> http://tinyurl.com/2z6ftm
02:29:57 <wli> dblhelix: Looks interesting.
02:31:15 <wli> edwardk: Punching a hole in the type namespace for it and generating that from the name string shouldn't be hard.
02:31:44 <edwardk> robert dockins also has a typenat library, though his has fewer directions of inference (because his is naturals, not integers, not so many things are closed) in his case the naming sugar is the kind of scary 'two `hundred` sixty four'
02:32:21 <opqdonut> :D
02:32:24 <opqdonut> nice
02:33:11 <edwardk> wli: an interesting problem, GHC doesn't offer that sort of user directed name management at the moment. i've thought about something in the same general sphere to allow for user-managed int syntax, etc for my own use but i haven't found a good way to let the library hook into the parser
02:33:20 <wli> edwardk: Naturals and integers are easy. Primes, polynomials (esp. irreducible ones), etc.
02:34:00 <edwardk> heh, i just needed them to check array bounds at compile time, etc.
02:34:53 <edwardk> ints and nats are more than sufficient for those needs. =) i'm actually in the process of defining arbitrary type-level meet-semilattices, and their products, sums, disjoint unions, etc. for another project though. so maybe i'll drift back towards that =)
02:34:54 <wli> GF(p^n), Q_p, Z[a] for algebraic integers a, etc.
02:36:09 <wli> I'm not sure how to do primes yet. Irreducible polynomials look even hairier.
02:36:58 <edwardk> anyways i can catch about an hour and a half nap before work, so i'm going to wander off.
02:37:08 <quicksilver> @localtime edwardk 
02:37:17 <wli> If you can get a large enough fragment of logic going within your types to check those sorts of things I think you can still be decidable.
02:38:15 <edwardk> wli: right now i just need a logical ^ meet operator for security levels, not in a hurry to do RSA at the type level =)
02:47:12 <oerjan> @bot
02:47:12 <lambdabot> :)
02:53:49 <Nopik> damn.. ghc was compiling for 2 hours and it failed due to lack of disk space ;(
02:54:20 <dons> oops
02:54:23 <dons> can you just use a binary?
02:55:59 <Nopik> yeah, i would like to.. though my distro somehow refuses to notice the fact that ghc-bin 6.6 exists and forces 6.4.2..
03:14:37 <mm_freak> nopik: gentoo?
03:39:28 <dons> ?users
03:39:28 <lambdabot> Maximum users seen in #haskell: 355, currently: 319 (89.9%), active: 5 (1.6%)
03:40:18 <quicksilver> ooh :(
03:40:23 <quicksilver> dropping 
03:41:31 <dozer> is there a cleaner way to write this: flip (foldl (flip $ uncurry M.insert)) assocList
03:41:49 <dozer> where assocList is [(k, v)]
03:42:45 <Nopik> mm_freak: yeah
03:42:52 <quicksilver> fromList?
03:43:02 <mm_freak> nopik: GHC 6.6 is masked in gentoo…  you need to unmask it
03:43:03 <quicksilver> dozer: is that M.fromList?
03:43:15 <Nopik> mm_freak: i've unmasked 6.6.1 sources and remerging them once again (after freeing 500mb of disk space ;d)
03:43:30 <dozer> well, it is a functio that adds all the things in assocList to its argument
03:43:31 <Nopik> mm_freak: yes, but there is no ebuild for ghc-bin 6.6.x
03:44:06 <mm_freak> oh, i see
03:44:07 <dozer> quicksilver: it's still waiting for a map to add all those things to
03:44:27 <quicksilver> dozer: M.union (M.fromList assocList)
03:44:55 <mm_freak> ok, then you'll need to merge ghc-bin-6.4.2, then ghc-6.6.1, then unmerge ghc-6.4.2 and finally remerge ghc-6.6.1 =)
03:45:20 <mm_freak> the point is compiler performance…  compiling GHC using GHC 6.6.1 makes it run a lot faster
03:45:30 <quicksilver> dozer: and isn't flip ( foldl ( flip just foldr?
03:46:07 <dozer> quicksilver: that union/fromlist thing is probably what I was after
03:46:26 <wli> flip . foldr . flip == foldl?
03:47:45 <DRMacIver> Wrong type signature isn't it?
03:47:53 <DRMacIver> @type flip . foldr . flip
03:47:55 <lambdabot> forall b c. (c -> b -> c) -> [b] -> c -> c
03:47:56 <DRMacIver> @type foldl
03:47:58 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
03:48:11 <quicksilver> well you don't necessarily need that last flip
03:48:19 <DRMacIver> @type foldr . flip
03:48:20 <quicksilver> it does all depend what you're trying to acheive, exactly
03:48:21 <lambdabot> forall b c. (c -> b -> c) -> c -> [b] -> c
03:48:33 <DRMacIver> Hm. I guess not.
03:48:41 <quicksilver> of course, they're not the same, in the sense that they do the calculation in a different order
03:49:03 <quicksilver> you need to add a 'reverse' in to get the same ordering
03:49:04 <quicksilver> if that matters
03:49:16 <wli> looks like it yeah
03:49:28 <quicksilver> the guideline is to use foldr if in doubt, though
03:52:41 <DRMacIver> I'm never entirely clear how lazy Data.Map manages to be.
03:53:04 <wli> Me neither.
03:53:38 <wli> Maybe there should be a Data.RadixTree as they're obvious to make fully lazy.
03:53:40 <DRMacIver> I mean, I can see the potential for some opportunities for laziness, but most of them look like "Only if you're lucky in the data you try to use".
03:53:44 <oerjan> DRMacIver: someone said it is strict in the spine of the map
03:54:24 <DRMacIver> Hm. I'm not totally sure what that means. :)
03:54:31 <DRMacIver> What's the spine of the map?
03:54:43 <oerjan> the shape of the tree
03:55:22 <DRMacIver> Ah
03:56:47 <quicksilver> DRMacIver: totally lazy in values, I'm sure
03:56:52 <quicksilver> DRMacIver: it would be daft to be any other way
03:57:05 <wli> How would it do comparisons if so?
03:57:09 <quicksilver> DRMacIver: most Ord instances you can imagine would make it strict in the keys
03:57:27 <quicksilver> DRMacIver: although you can imagine an Ord instance which falls short of completely strict
03:57:40 <quicksilver> > 'a' : undefined < 'b' : undefined
03:57:46 <oerjan> quicksilver: keys that are lists
03:57:48 <lambdabot>  True
03:57:50 <wli> Ord on a record only comparing some fields.
03:57:53 <quicksilver> including that one :)
03:57:54 <quicksilver> right
03:58:07 <quicksilver> however it's always going to be 'somewhat' strict in the keys
03:58:24 <oerjan> (but then you probably want a trie)
03:58:25 <DRMacIver> quicksilver: Yeah, I realised it was always lazy in the values. I was wondering about key strictness.
03:58:36 <kolmodin> dons: you've got mail
03:59:23 <DRMacIver> But you're right that some strictness is obviously neccessary. I was just curious how much. :) 
03:59:24 * wli ponders composition/chaining of Mealy machines.
04:00:05 <quicksilver> DRMacIver: I believe it is maximally lazy, in practice
04:00:10 <DRMacIver> What on earth is a Mealy machine?
04:00:21 <quicksilver> DRMacIver: the only strictness is that which is implied by your choice of Ord instance
04:00:31 <DRMacIver> ok
04:00:33 <dozer> DRMaclvier: it's an inside-out more machine
04:00:57 <DRMacIver> What on earth is a more machine? :)
04:01:10 <quicksilver> DRMacIver: an inside-out mealy machine
04:01:10 <wli> DRMacIver: A Mealy machine is a finite automaton that produces output during state transitions.
04:01:11 <blackdog_> it's an outside-in mealy machine...
04:01:16 <oerjan> quicksilver: that is not what i heard.  i heard it computed the entire shape of the tree (and was translated from Ocaml)
04:01:23 <quicksilver> oerjan: that's true too
04:01:24 <DRMacIver> quicksilver: I new you would say that. :)
04:01:30 <quicksilver> DRMacIver: sorry :P
04:01:33 <DRMacIver> knew
04:01:40 <wli> DRMacIver: A Moore machine is a finite automaton that produces output on entering states.
04:01:45 <quicksilver> oerjan: well, 'insert' doesn't force the spine AFAIk
04:01:46 <DRMacIver> ok
04:01:49 <quicksilver> oerjan: but accessing an element does
04:02:44 <quicksilver> oerjan: so in practice the spine gets forced fairly 'soon'
04:03:03 <quicksilver> I don't know for sure if it forces the whole spine, though
04:03:14 <wli> It shouldn't.
04:03:17 <quicksilver> if you head down the left branch, the other thunks might just get pushed right
04:03:24 <wli> Just what's required in the lookup path.
04:03:26 <quicksilver> and not evaluated further than needed to push them right
04:03:53 <DRMacIver> Hm. Any good functional programming related podcasts?
04:03:59 <oerjan> forcing the whole spine may help against space leaks, i suspect
04:04:06 <DRMacIver> (Otherwise good podcasts are also welcome :) )
04:04:25 <quicksilver> oerjan: I could imagine that, but I don't see any explicit forcing in the code
04:04:39 <quicksilver> oerjan: so I think it's just demand-driven
04:04:42 <ekidd> Good morning.
04:06:08 <oerjan> oh, it's actually obvious: there are strictness tags on the Map data definition
04:07:39 <quicksilver> oerjan: oh. stupid me :)
04:08:05 <quicksilver> oerjan: didn't think to look there :)
04:08:14 <oerjan> easy to do :)
04:08:30 <quicksilver> I searched the file for 'seq' and  Iread the source for insert and balance
04:09:50 <kjdf> could someone give me some pointers on how to do dynamic programming in haskell?
04:09:58 <kjdf> (and/or memoization)
04:10:06 <quicksilver> oerjan: I don't understand the algorithm in detail, but I *think* that the !Size annotation is enough to strictify the whole spine
04:10:14 <|Steve|> I just wrote a macro in scheme that will memoize any function.
04:10:19 <quicksilver> oerjan: since that forces all the sizes everywhere and that forces the whole shape?
04:22:27 <malcolmw> dcoutts, dcoutts_: ping?
04:23:02 <fasta> Is there free software which implements a propositional logic simplifier? 
04:23:40 <oerjan> quicksilver: i think rebalancing can be lazy in some of the shape even while calculating the total sizes.
04:24:45 <oerjan> (in principle)
04:25:09 <malcolmw> fasta: clausify?  (in the nofib suite)
04:25:37 <malcolmw> fasta: I think ndm has a propositional simplifier as well
04:25:39 <fasta> malcolmw: I prefer something which is an actual apt-gettable program. 
04:27:01 <wli> fasta: You want something like a command interpreter that accepts propositional logic expressions as input and produces simplified expressions as replies?
04:27:09 <fasta> wli: right
04:27:22 <fasta> Probably coq does that
04:27:26 <wli> Sounds like a fun project.
04:27:34 <wli> coq probably does everything.
04:28:12 <fasta> wli: It's just that it's easy to let the machine do the simplifications then to do by hand, although I rarely write redundant logic. 
04:29:22 <wli> Sort of like a reducer for Prolog.
04:31:17 <quicksilver> or, sort of like prolog itself :)
04:31:22 <quicksilver> sort of like a prolog engine
04:31:38 <quicksilver> I'm not aware of an out-of-the-box solution myself
04:31:46 <quicksilver> although surely all the decent CA packages can do it
04:31:55 <quicksilver> and ndm did write something like that you're right
04:33:47 <malcolmw> http://www-users.cs.york.ac.uk/~ndm/proposition/
04:33:50 <lambdabot> Title: Neil Mitchell - Proposition
04:39:20 <fasta> Another program I would love to see is a compiler from Haskell to a boolean circuit. 
04:39:51 <fasta> Or rather a boolean formula. 
04:40:02 <fasta> (to be more precise)
04:44:47 <profmakx> hmm
04:46:59 <dons> would an FPGA compiler do?
04:47:21 <profmakx> i thought of something like that too, fasta :)
04:49:20 <Nopik> i have a question about monad types.. i am a beginner haskeller, so most likely i confuse some ideas here.. but, on a tutorials about a monads, they says that monad typing convention is seamlessly using existing haskell syntax, so things like "IO String" are already in the language.. but how to understand the "IO String" or "MyType OtherType" syntax?
04:50:01 <quicksilver> "IO String" means : computation, which probably involves some I/O or other interaction with the outside world, and finally produces a result of type String
04:50:03 <Nopik> I can write data Point a b = Point Double Double for example (or something like this :D).. which seems the same syntax to me
04:50:14 <earthy> nopik: exactly so.
04:50:14 <mauke> Nopik: it is
04:50:15 <quicksilver> it is the same syntax
04:50:25 <quicksilver> there is nothing spcial about them, in that sense
04:50:29 <quicksilver> they're just another data type
04:50:35 <quicksilver> their meaning is the interesting part
04:50:37 <Nopik> ok, then, I cannot write method of type IO String -> String, right?
04:50:45 <quicksilver> you can, in fact
04:50:52 <quicksilver> but you can't write the method you wanted to write :)
04:50:53 <mauke> right, because you don't know how IO looks internally
04:50:55 <earthy> but we like to hide that fact. :)
04:50:56 <Nopik> but I can write method Point Double Double -> (Double, Double)
04:51:02 <quicksilver> correct
04:51:14 <quicksilver> because 'IO String' doesn't actually *include* that value of type String
04:51:21 <quicksilver> rather, it contains the instructions on how to calculate it
04:51:30 <quicksilver> until that calculation/computation is carried out
04:51:34 <quicksilver> the String result doesn't exist
04:51:43 <Nopik> ok, but if IO internals were exposed to me, I would be able to extract String from IO String and export it without IO monad.. is that right?
04:51:50 <mauke> not really
04:51:50 <quicksilver> and you can't know in advance what the answer is going to be 
04:51:57 <mauke> you'd still have to actually do the I/O somehow
04:52:02 <quicksilver> well computing the answer might involve connecting to another computer over the internet
04:52:07 <quicksilver> or asking for user input
04:52:10 <quicksilver> or various other things
04:52:10 <Nopik> yeah
04:52:32 <roconnor> or formating your hard drive
04:52:43 <Nopik> but once one function returns something of type IO String to me, I should be able to extract plain String from it?
04:53:07 <mauke> there is no plain string there
04:53:15 <mauke> consider data Spork a b = Spork (a -> b -> Ordering)
04:53:23 <mauke> then I hand you Spork Double Double
04:53:31 <mauke> can you extract (Double, Double) from that?
04:53:40 <Nopik> hm, ok
04:53:42 <Nopik> good point
04:54:17 <Nopik> so it is more like c++ template argument
04:54:29 <roconnor> indeed.
04:54:29 <mauke> right
04:54:51 <Nopik> ok, thanks for explaination
04:54:59 <mauke> in fact, there is no requirement that a data type actually uses the type parameters it gets
04:55:10 <mauke> data Wtf a = Wtf String -- valid
04:55:17 <Nopik> yeah, i know
04:56:17 <quicksilver> even if the type is there in the type, it may not be there in every value, too
04:56:25 <quicksilver> 'Nothing' is a valid value of type 'Maybe Int'
04:56:32 <quicksilver> but there really isn't an integer in there, to get out :)
04:56:33 <fasta> A program-simplifier could also have some value. 
04:56:43 <Nopik> ;)
04:56:47 <quicksilver> Nopik: this is actually a good example, since Maybe is also a monad
04:56:48 <fasta> E.g. if a < b then a else b should be min a b
04:56:56 <Nopik> quicksilver: indeed
04:57:15 <quicksilver> Nopik: the analogy with IO is that an action of type IO String might actually throw an exception
04:57:21 <quicksilver> Nopik: so it might never return a string after all
04:57:35 * Nopik did not read about exceptions yet ;p
04:58:06 <mauke> fail "zomg" :: IO String
04:58:21 <fasta> dons: I just want an AST consisting of NOT, AND and OR gates taking respectively 1, 2 and 2 arguments.
04:58:33 <Nopik> yeah, i have seen 'fail' usage few times, but no comprehensive text about them
04:58:38 <fasta> dons: if an FPGA can do that, I would be most happy. 
04:58:44 <quicksilver> malcolmw: interesting. ndm's Data.Proposition abuses Show.
04:58:54 <quicksilver> malcolmw: I wonder if this is still considered abuse, or if it's become acceptable
04:58:58 <fasta> dons: FPGA compiler*
04:59:04 <mauke> Nopik: that's probably because 'fail' is a hack :-)
04:59:12 <Nopik> mauke: :)
04:59:21 <kjdf> RWS monad is just a combined reader, writer and state?
04:59:28 <mauke> yes
04:59:41 <quicksilver> kjdf: yes. I believe it's intended more as an instructive example than a useful thing in itself
04:59:42 <Nopik> i'll write my first 'real' program first, then i'll know what i need to read about  on the next stage ;p
05:00:12 <mauke> maybe it predates monad transformers
05:00:18 <roconnor> quicksilver: I used the RWS monad.
05:00:23 <dons> quicksilver: how is it abused, the Show instance?
05:00:30 <dons> to wrap IO and render it harmless?
05:00:35 <roconnor> Monad tranformers confuse me a bit.
05:00:37 <scook0> RWST is a great way to accidentally introduce space leaks :/
05:00:56 <quicksilver> dons: No. It's just he makes an instance for a 'convenient human readble display'
05:01:02 <quicksilver> dons: but it doesn't produce parseable haskell
05:01:08 <roconnor> I never know if i want ListT State or StateT List.
05:01:12 <quicksilver> dons: which is the unofficial Show invariant :)
05:01:17 <dons> oh, i guess its ok outside of the base lib
05:01:43 <quicksilver> dons: I find that very annoying, during debugging
05:01:46 <dons> yeah, read . show is supposed to work. as is pasting code into src
05:01:58 <quicksilver> dons: I often generate counter-examples in ghci
05:02:04 <roconnor> scook0: how  does RWST introduce space leaks?
05:02:06 <quicksilver> dons: and copy them into code from my terminal, to make a test
05:02:16 <dons> yeah
05:02:33 <quicksilver> dons: show the Show -> copy/paste -> .hs file loop is very important to me
05:02:39 <dons> tell him to use a Pretty class for that, not Show :)
05:02:40 <quicksilver> s/show the/so the/
05:02:41 * quicksilver nods
05:02:46 <scook0> roconnor: a lazy writer part accumulates thunks like mad
05:02:53 <quicksilver> I've tried to bring this up with him once
05:02:56 <scook0> even if you aren't using it
05:02:59 <quicksilver> he didn't understand my point, I don't think
05:03:06 <quicksilver> I probably didn't explain it well
05:03:25 <quicksilver> dons: but I wonder if this invariant should be better documented or discussed
05:03:41 <earthy> really the point is that there's 'moderately readable serialisation, acceptable to the GHC parser' and 'pretty printing'
05:04:08 <roconnor> scook0: does that apply equally to the WriterT?
05:04:18 <earthy> where the latter may degenerate into calls to the former
05:04:21 <quicksilver> earthy: absolutely
05:04:22 <earthy> but not the other way 'round
05:04:24 <scook0> roconnor: if it's lazy, I presume so
05:04:29 <quicksilver> earthy: well said
05:04:50 <roconnor> @type runWriter
05:04:52 <lambdabot> forall w a. Writer w a -> (a, w)
05:04:53 <earthy> unfortunately, the distinction isn't available in the prelude
05:05:01 <scook0> actually, I have no idea whether either is *guaranteed* to leak space
05:05:23 <roconnor> scook0: If uses the list Monoid, then the size of the thunks is about the size of the resulting list?
05:05:25 <earthy> which makes the new prelude goals laudable. :)
05:06:33 <scook0> after upgrading to ghc 6.6 I spent ages tracking down a space leak caused by a lazy RWST making heaps of 'mappend' thunks on ()
05:06:36 <quicksilver> @src Writer (>>=)
05:06:36 <lambdabot> Source not found. My mind is going. I can feel it.
05:06:49 <quicksilver> the problem, as I see it, is there in Writer
05:07:00 <quicksilver> @src (Writer w) (>>=)
05:07:00 <lambdabot> Source not found. Just what do you think you're doing Dave?
05:07:09 <quicksilver>     m >>= k  = Writer $ let
05:07:09 <quicksilver>         (a, w)  = runWriter m
05:07:09 <quicksilver>         (b, w') = runWriter (k a)
05:07:09 <quicksilver>         in (b, w `mappend` w')
05:07:24 <quicksilver> note the `mappend` is "always" called
05:07:33 <quicksilver> even if the action 'm' generated no output
05:07:51 <quicksilver> so for a long writer action, which generates no output at all
05:08:11 <quicksilver> you get this silly thunk mempty `mappend` mempty `mappend` mempty `mappend` ....
05:08:31 <quicksilver> scook0: is that your understanding of the problem?
05:08:36 <scook0> quicksilver: pretty much
05:09:00 <scook0> the worst thing was that my space profiling gave totally misleading results
05:09:06 <scook0> since the leak was in the monad itself
05:09:31 <quicksilver> seems to be true even of Writer.Strict
05:09:35 <quicksilver> unless I'm misreading the code
05:10:07 <chessguy> so who's got the cryptic messages about ICFP07 figured out?
05:10:08 <scook0> well, in my case I just ditched the writer, since I wasn't using it
05:10:53 <mauke> @source Control.Monad.Writer
05:10:53 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Writer.hs
05:11:40 <quicksilver> seems that let w'' = w `mappend` w' in w'' `seq` (b,w'') might be better
05:11:43 <quicksilver> but I'm not sure
05:11:59 <mauke> wtf
05:12:00 <quicksilver> given a monad instance which has a fairly simple instance for 'mempty'
05:12:10 <mauke> is Writer.Strict identical to Writer.Lazy?
05:12:28 <quicksilver> mauke: no, it's strict in the typle
05:12:31 <quicksilver> mauke: tuple
05:12:50 <mauke> meh
05:13:04 <wli> I've not gotten the hang of what writers are used for.
05:13:10 <quicksilver> wli: logging
05:13:19 <mauke> table building
05:13:22 <wli> Examples?
05:13:25 <quicksilver> wli: like sprinkling 'putStrLns' through your code
05:13:32 <quicksilver> only they aren't actually putStrLns really
05:13:37 <quicksilver> just log messages collected in a big list
05:13:38 <mauke> I've used it in an interpreter
05:13:54 <wli> mauke: How did you use it there?
05:14:07 <mauke> I wanted to transform a parse tree into an easier interpretable form
05:14:14 <wli> quicksilver: I'm looking for things more like mauke is talking about.
05:14:25 <roconnor> quicksilver: ugh, that's terrible.
05:14:25 * quicksilver nods
05:14:26 <mauke> specifically, I wanted to resolve function calls
05:14:26 <wli> mauke: What sort of form was that?
05:15:08 <wli> Well, I already have an example where I output the various row operations used in Gaussian elimination.
05:15:44 <wli> It seems vastly more general than outputting mere sequences so I've something of a failure of imagination as to how it's used more generally.
05:16:13 <quicksilver> wli: well, think of more exciting monoids, then
05:16:14 <mauke> the original version used runtime table lookups because all function calls were done on strings
05:16:25 <quicksilver> wli: 'accumulating summary data'
05:16:46 <mauke> the improved "compiler" had to immediately resolve symbols while compiling them
05:16:59 <roconnor> maybe my RWS monad code worked well because I demaned the results of my writer monad in the middle of using it.
05:17:05 <mauke> i.e. it had to resolve symbols that weren't even compiled yet
05:17:08 <quicksilver> roconnor: that will stop the leak,  yes
05:17:14 <wli> quicksilver: So it could, in principle, be used to sum numbers.
05:17:21 <quicksilver> roconnor: just keep demanding the write from time to time
05:17:36 <quicksilver> @instances Monoid
05:17:40 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
05:17:46 <wli> mauke: IOW single-pass compilation?
05:17:58 <mauke> right
05:18:24 <roconnor> Ordering is a Monoid?
05:18:33 <wli> mauke: So you built up a forward reference table of symbols to be resolved once encountered?
05:18:37 <roconnor> > Lt `mappend` Gt
05:18:38 <lambdabot>   Not in scope: data constructor `Gt'
05:18:42 <roconnor> > LT `mappend` GT
05:18:43 <lambdabot>  LT
05:18:49 <roconnor> ?
05:19:29 <mauke> everytime it encountered a function, it would compile it and 'write' it (the name and compiled code) to the log
05:19:51 <Botje> @pl \v m -> M.insert k v m
05:19:52 <lambdabot> ((M .) .) . insert k
05:19:56 <mauke> hmm
05:19:58 <Botje> @pl \v m -> insert k v m
05:19:59 <lambdabot> insert k
05:20:05 <Botje> doh
05:20:06 <Nopik> yeah... ghc 6.6.1 finally compiled, after 2h20m and 1GB of disk space ;p
05:20:08 <Botje> that was silly.
05:20:28 <mauke> am I misreading this code?
05:20:46 <quicksilver> > runWriter . sequence_ . map (tell . Sum) $ [1..5]
05:20:47 <lambdabot>  ((),Sum {getSum = 15})
05:20:49 <chessguy> -- lexicographical ordering
05:20:49 <chessguy> instance Monoid Ordering where
05:20:49 <chessguy> 	mempty         = EQ
05:20:49 <chessguy> 	LT `mappend` _ = LT
05:20:49 <chessguy> 	EQ `mappend` y = y
05:20:50 <chessguy> 	GT `mappend` _ = GT
05:20:52 <quicksilver> wli: like that ^^
05:20:54 <chessguy> roconnor, ^^
05:21:36 <quicksilver> wli: or, if you prefer to multiply the numbers, take a different Monoid instance
05:21:42 <quicksilver> > runWriter . sequence_ . map (tell . Prouct) $ [1..5]
05:21:43 <lambdabot>   Not in scope: data constructor `Prouct'
05:21:46 <quicksilver> > runWriter . sequence_ . map (tell . Product) $ [1..5]
05:21:48 <lambdabot>  ((),Product {getProduct = 120})
05:22:21 <Nopik> do anyone here happen to have simple/small examples of using gd library?
05:22:29 <chessguy> gd?
05:22:57 <wli> Not sure what lambdabot command to look up Sum
05:23:05 <quicksilver> it's just a newtype over numbers
05:23:08 <Nopik> chessguy: this is library for manipulating images
05:23:16 <fasta> gd is an image library, popular with PHP programmers.
05:23:18 <quicksilver> to give it the obvious Monoid instance using (+)
05:23:27 <wli> quicksilver: Where is it?
05:23:35 <quicksilver> not sure
05:23:48 <fasta> Nopik: what makes you think this library has Haskell bindings?
05:23:54 <quicksilver> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html
05:23:56 <lambdabot> http://tinyurl.com/y5qk9n
05:24:00 <quicksilver> wli: there ^^
05:24:21 <quicksilver> 'IntSet' is another interesting Monoid instance
05:24:26 <quicksilver> you can accumulate sets of stuff
05:24:34 <wli> Endo hmm.
05:24:36 <quicksilver> this has obvious applications for things like 'privileges'
05:24:40 <Nopik> fasta: because i have downloaded the bindings from haskell.org and runghc Setup.hs configure/build/install worked?
05:24:44 <mauke> wli: apparently I misremembered my own code. the "log" is just a set of strings (symbol names)
05:24:56 <fasta> Nopik: URL?
05:25:04 <fasta> And define:
05:25:07 <fasta> @where gd
05:25:07 <lambdabot> I know nothing about gd.
05:25:45 <Nopik> fasta: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/gd-3000.3.0
05:25:47 <lambdabot> http://tinyurl.com/2wuz44
05:26:09 <fasta> @where+ gd http://hackage.haskell.org/cgi-bin/hackage-scripts/package/gd-3000.3.0
05:26:09 <lambdabot> Done.
05:26:20 <mauke> wli: the magic is in the compiler functions that use this set to build a symbol map that is then returned and so it can be passed in as a reader environment for the compiler functions
05:26:38 <Nopik> though bindings are quite badly documented :(
05:26:53 <fasta> Nopik: if you just look at the module interface, it's quite clear.
05:27:03 <fasta>                loadJpegFile, loadJpegData, loadJpegByteString,
05:27:03 <fasta>                     -- ** PNG
05:27:03 <fasta>                     loadPngFile, loadPngData, loadPngByteString,
05:27:03 <fasta>                     -- ** GIF
05:27:05 <fasta>                     loadGifFile, loadGifData, loadGifByteString,
05:27:08 <fasta> Etc
05:27:17 <fasta> That seem pretty sane names. 
05:27:40 <dons> looks nice. what lib is that?
05:27:49 <dons> gd-3000 ?
05:27:50 <fasta> @where gd
05:27:50 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/gd-3000.3.0
05:27:53 <fasta> dons: yes
05:28:03 <dons> cool, must recommend that when people come looking for .png loading libs
05:28:04 <Nopik> fasta: yeah.. though i am extremely new at haskell, so even such things leave a little puzzlement for me :) but well, lets get some experience ;)
05:28:09 <fasta> I wasn't aware of its existence. 
05:28:28 <fasta> Nopik: I only touched really simple libraries written by other people. 
05:28:42 <Nopik> i was looking for image manipulation library, this is the only library listed on haskell.org to claim to be able to do such thing ;p
05:28:43 <fasta> Nopik: partly, because everything I need doesn't exist yet.
05:29:11 <Nopik> fasta: yeah, tell me about it ;p
05:29:14 <wli> Sum/Product are really just biendomorphism instances.
05:29:26 <fasta> Nopik: GTK2HS also contains an image manupulation monad.
05:29:42 <kjdf> and what do you need, fasta?
05:29:51 <fasta> manipulation*
05:29:56 <quicksilver> dons: is it possible for hacakge to automatically put the haddock online?
05:30:08 <fasta> kjdf: are you asking for suggestions?
05:30:09 <quicksilver> dons: that's what CPAN does, and I suspect that's one of the most important features
05:30:20 * Botje is writing a small webserver in haskell
05:30:22 <Botje> it's nice :)
05:30:26 <wli> You probably need instances on higher kinds.
05:30:36 <HairyDude> is it intentional in GHC that Ord defaults to ()?
05:30:43 <kjdf> fasta: yes
05:30:54 <quicksilver> > () < ()
05:30:56 <lambdabot>  False
05:31:07 <HairyDude> > () <= ()
05:31:09 <lambdabot>  True
05:31:16 <fasta> kjdf: I am interested in a program that given a program written in Haskell transforms that to an abstract syntax tree consisting of boolean nodes(NOT, AND, OR). 
05:31:36 <wli> A biendomorphism is a function f : X x X -> X
05:31:38 <Nopik> heh.. it seems that gd have load image, save image, set pixel, but no get pixel function ;p
05:31:39 <fasta> kjdf: it should of course be easy to extend to other programming languages.
05:32:02 <quicksilver> wli: I'm not sure that your observation is all that interesting
05:32:03 <HairyDude> it seems useless and counterintuitive
05:32:18 <quicksilver> wli: isn't monoid multiplication always a bi-endomorphism
05:32:26 <HairyDude> this is ghc 6.7 btw
05:32:28 <roconnor> @check (<=)
05:32:29 <lambdabot>  Add a type signature
05:32:36 <mauke> HairyDude: what do you mean?
05:32:37 <roconnor> @check (<=)::(() -> () -> Bool)
05:32:39 <lambdabot>  OK, passed 500 tests.
05:32:44 <fasta> kjdf: does that keep you busy for the next month?
05:32:44 <roconnor> @scheck (<=)::(() -> () -> Bool)
05:32:46 <lambdabot>   Completed 1 test(s) without failure.
05:32:57 <wli> quicksilver: The thought was to be able to somehow parametrize over the biendomorphism.
05:33:17 <kjdf> I don't think so. It's not my league yet :)
05:33:18 <fasta> Is there also a triendomorphism?
05:33:36 <wli> fasta: n-endomorphisms even, of course.
05:33:50 <scsibug> Nopik: it should be fairly straightforward to add getPixel to GD (I added setPixel awhile back when the wrapper didn't even have that..)
05:33:51 <fasta> Those words are great with Scrabble!
05:34:16 <quicksilver> wli: I just don't really think the jargon adds much
05:34:19 <fasta> morph -> morphism -> endomorphism -> nendomorphism
05:34:25 <quicksilver> wli: normally we call these binary operations
05:34:35 <quicksilver> wli: and all you've done is re-stated what Monoid is
05:34:47 <hpaste>  HairyDude pasted "Ord defaults to () in ghc 6.7" at http://hpaste.org/1711
05:34:48 <quicksilver> (Monoid is a class with an identity and a binary operation, such that...)
05:34:59 <mauke> @seen augustss
05:35:00 <lambdabot> I saw augustss leaving #haskell 2d 1h 45m 17s ago, and .
05:35:17 <wli> quikcksilver: The thought was to cast it in a more general context.
05:35:35 <HairyDude> oddly 'insert' is fully polymorphic but 'isort' isn't
05:35:46 <wli> quicksilver: So the restatement is deliberate.
05:36:59 <oerjan> HairyDude: perhaps () is just the first default for anything it fits
05:37:15 <oerjan> it _does_ seem intuitive for that
05:38:15 <HairyDude> well I believe it goes against the Report, since that says defaulting only happens for numeric types
05:38:24 <oerjan> > let isort = foldr insert [] in isort
05:38:26 <lambdabot>  <[Integer] -> [Integer]>
05:38:39 <HairyDude> yes, in ghc 6 it default to Integer
05:38:40 <kilimanjaro> A Java programmer and a Haskell programmer are handed the same project. The Java programmer spends 5 days working on the project, and is at least successful in getting it handed off to somebody else. The Haskell programmer finishes up a prototype in 30 minutes, argues with his boss over a bit of vocabulary, and then listens to Mozart while surfing IRC
05:38:51 <oerjan> HairyDude: ghc has an "extended defaulting" mechanism?
05:39:12 <HairyDude> I'd only expect that to be turned on with -fglasgow-exts
05:39:19 <wli> kilimanjaro: You don't even want to think about what the C programmer goes through.
05:39:20 <HairyDude> or some other switch
05:39:28 <mauke> maybe it's a bug
05:39:33 <oerjan> HairyDude: report a bug then
05:41:41 <ddarius> magma
05:42:27 <HairyDude> ah, it seems the defaulting is turned on in GHCi for convenience... but I would expect it to default to something numeric instead of ()
05:43:00 <ddarius> Anyone do Claus' Mux exercise from the list?
05:45:07 <|Steve|> kilimanjaro: Funny. I've been a TA for classes that taught Java for the first time and I've been a TA for classes that taught Haskell and now Scheme for the first time. By the end of the quarter, the Java students could write little programs. By the end of the quarter, the functional programming students could do small math calculations and _maybe_, just maybe map a function over a list.
05:45:34 <|Steve|> Well, I'm not at the end of the Scheme quarter yet, so I'll let you know in 3 weeks.
05:45:43 <quicksilver> that sounds a bit odd?
05:45:50 <integral> Are the classes teaching as fast as possible?
05:45:54 <quicksilver> surely you can do small math calculations at the end of your first 10 minutes?
05:45:58 <quicksilver> how does that take a quarter?
05:45:58 <scook0> hmm, if I have [a->b] and [a], and I want a list of all the possible results,
05:46:05 <scook0> that's just "ap" in [], right?
05:46:06 <quicksilver> > 1 + 2 * 5
05:46:08 <quicksilver> scook0: right
05:46:14 <|Steve|> quicksilver: Yeah, but there isn't a whole lot of progression after that.
05:46:14 <lambdabot>  11
05:46:15 <integral> sturgeon's law applies to students I guess
05:46:40 <kilimanjaro> |Steve|, so they are no longer a risk to the health of themselves and others around them. Really I'd say that's a success
05:47:13 <|Steve|> Writing a tail-recursive version of log-time exponentiation was more than many of them could handle. It's less than 10 lines of scheme.
05:47:30 <kilimanjaro> You go from sticking forks into outlets all the way to sitting down, dressed, typing math calculations. That's like a complete transformation
05:48:27 <|Steve|> And this scheme class is supposedly upper division. The java class was the slow java class for freshman who've never programmed anything before.
05:48:42 <Saizan> is haskell the first programming course? or they have to unlearn all that OO and imperativeness?
05:49:03 <Nopik> scsibug: yeah, i was looking at the source code and indeed it is mostly a wrapper to foreign call
05:49:03 <|Steve|> Haskell was actually a bit of an experiment (a failed one, I might add) to combine haskell and discrete math.
05:49:07 <matt__r> steve: I have to say my experience is the opposite
05:49:15 <Nopik> scsibug: do you happen to have any small program using gd in haskell?
05:49:26 <quicksilver> certainly |Steve|'s experience doesn't conform with my knowledge of the Imperial first term Miranda course
05:49:31 <|Steve|> I was hoping to hear about matt's experience...
05:49:32 <earthy> nopik: doesn't the gd lib binding have examples?
05:49:39 <Nopik> earthy: unfortunately, not ;(
05:49:46 <kilimanjaro> |Steve|, haha yea, that sounds like something a professor would find cool. Take two classes that, on their own, most students would have trouble with, and blend them into one orgy of confusion
05:49:47 <quicksilver> admittedly I didn't teach or take that course, but I spoke to people who did
05:50:03 <earthy> hm.
05:50:14 <earthy> the exif lib also suffers that fate.
05:50:16 <scsibug> there should be a few example programs included with GD, if that is what you mean
05:50:31 <quicksilver> kilimanjaro: I could see an argument for teaching haskell in your first term, then discrete math in your second. And using haskell for the discrete maths labs.
05:50:41 <scsibug> nopik: http://scsibug.com/2007/04/21/mandelbrot-hs/
05:50:42 <lambdabot> Title: scsibug.com  Fractal-hs
05:50:47 <kilimanjaro> What's a math lab?
05:50:55 <quicksilver> kilimanjaro: if you did that right then (a) the haskell would make the abstract stuff in discrete math seem more concrete
05:51:07 <quicksilver> and (b) it would be an example of 'stuff you can do' with haskell
05:51:12 <quicksilver> which might stop them forgetting it all :)
05:51:17 <scsibug> http://www.scsibug.com/haskell-gd/examples/
05:51:18 <lambdabot> Title: Index of /haskell-gd/examples
05:51:19 <quicksilver> kilimanjaro: exercise classes or whatever secondary tuition there is
05:51:27 <quicksilver> kilimanjaro: to back up the lectures
05:51:31 <Philippa_> kilimanjaro: and no doubt in half the time...
05:51:41 <|Steve|> I can't see any argument for using haskell to teach math.
05:51:48 <kilimanjaro> I personally think Scheme is a better first language than Haskell, there are less things to think about
05:51:51 <earthy> quicksilver: you mean much like http://homepages.cwi.nl/~jve/HR/
05:51:52 <lambdabot> Title: The Haskell Road
05:51:58 <mauke> I can
05:52:19 <|Steve|> I could see teaching people to program in a functional language for their first language. I'd like to give that a shot like Berkeley or MIT do.
05:52:24 <kilimanjaro> Like half of an intro to programming class is getting students to understand syntax
05:52:32 <|Steve|> Right.
05:52:32 <quicksilver> earthy: probably, yes
05:52:37 <quicksilver> earthy: along those lines, at least
05:52:42 <ddarius> kilimanjaro: I agree but not for that reason.
05:53:01 <kilimanjaro> ddarius, for what reason then?
05:53:10 <quicksilver> I think haskell is a better language than scheme for a first language, because I think type inference is very valuable pedagogically
05:53:11 <matt__r> steve: http://journals.cambridge.org/action/displayAbstract;jsessionid=D9E3845B38ED3F5E88511B049D7314E3.tomcat1?fromPage=online&aid=192401
05:53:14 <lambdabot> Title: CJO - Abstract - The risks and benefits of teaching purely functional programmin ..., http://tinyurl.com/33fnmo
05:53:32 <ddarius> It has much more and better introductory material.  Learning to deal with unbounded side-effects is also important.
05:53:33 <quicksilver> having a good instinct for typing is really important in becoming a good programmer
05:53:44 <mauke> one of our assignments was about deciding whether various symbolic statements were true or not
05:53:45 <earthy> uhuh
05:53:45 <kilimanjaro> If it's your first time programming, type inference is 100% magic and it will probably cause you strife
05:53:53 <mauke> like ø \elem N
05:54:04 <mauke> about 80% of them were "type errors" :-)
05:54:27 <quicksilver> anyhow, speculating about teaching styles is terribly easy. Actually designing a good course and giving it is not ;(
05:54:31 <Philippa_> type inference is magic anyway unless you've already met unification
05:55:00 <ddarius> So teach Prolog as an introduction to Haskell.
05:55:00 <quicksilver> to be clear, what i mean really is that strong typing is valuable pedagogically
05:55:08 <HairyDude> http://hackage.haskell.org/trac/ghc/ticket/1539
05:55:09 <MyCatSchemes> Philippa_: whut? How so?
05:55:10 <lambdabot> Title: #1539 (Ord should not default to ()) - GHC - Trac
05:55:10 <|Steve|> matt__r: Looks interesting, but I'm not paying $20 for it.
05:55:14 <quicksilver> but type inference is a very helpful tool for coping with strong typing
05:55:32 <|Steve|> But you can write the Z combinator in scheme!
05:55:35 <matt__r> steve: there should be copies all over the joint and most unis will have access to the journal
05:55:40 <Philippa_> MyCatSchemes: because unless you've already met at least an instance of unification, you're being handed something you've no idea how it works. You don't know how to follow the inference process
05:55:44 <ddarius> Z, not Y.
05:55:52 <|Steve|> matt__r: Okay, I'll grab it in my office tomorrow.
05:56:00 <matt__r> I think it is about the only work on teaching functional programming to anyone, let alone first years
05:56:02 <quicksilver> |Steve|: there's a preprint at http://www.cse.unsw.edu.au/~chak/papers/CK02a.html
05:56:02 <lambdabot> Title: Research Papers of Manuel Chakravarty
05:56:15 <kilimanjaro> The ones who want to learn will learn, the ones who don't care will end up writing Java code anyways
05:56:20 <matt__r> dons: I don't suppose you were ever one of those first years were you?
05:56:21 <MyCatSchemes> Philippa_: the basic idea would seem simple enough even without knowing Prolog. Students can quite happily imagine the compiler walking the parse tree of a piece of code and assigning tags to everything unlabelled.
05:56:33 <Philippa_> MyCatSchemes: I didn't mention Prolog
05:56:48 <|Steve|> matt__r: I'd be surprised if it were the only one. I've spoken to other people about this and they said that it's been studied before.
05:56:50 <Philippa_> and "walking the parse tree" is definitely not a good concept for someone who's only just started programming
05:57:12 <MyCatSchemes> Philippa_: oh, my bad. But still, anyway. Haskell's type inference was my first introduction to unification and I don't think I've ever had any problem with it, is all.
05:57:13 <matt__r> |Steve|: yeah - I could be wrong.
05:57:35 <|Steve|> quicksilver: Oh, thanks.
05:57:50 <matt__r> |Steve|: I have been interested in it though - why did it click so well with me, but is such an uphill struggle with many otherwise wonderful computing students/practitioners?
05:58:04 <quicksilver> googling for 'teaching functional programming' shows quite a lot of study og it
05:58:07 <MyCatSchemes> Philippa_: true, but it's just chasing pointers recursively. That should be, like, practically instinctive by the time you're halfway through a CS introductory unit.
05:58:16 <matt__r> |Steve|: I think the bottom line is the person teaching you :)
05:58:37 <matt__r> |Steve|: I was rather lucky in that regard
05:58:42 <|Steve|> matt__r: Could be. But I've learned every language I know (except for Java I suppose...) on my own.
05:59:00 <MyCatSchemes> matt__r: your theory breaks down when applied to autodictats. ;)
05:59:14 <Philippa_> MyCatSchemes: Hahahaha. No.
05:59:22 <|Steve|> I was introduced to scheme and haskell during my ugrad PL class, but what I know now, I know from my own study of the language.
05:59:31 <quicksilver> |Steve|: that unfortunately disqualifies you as a useful example, I fear :)
05:59:40 <Philippa_> I mean yeah, it should in a magic world where everyone clicks with the concepts first time and doesn't need any time to internalise...
05:59:43 <Syzygy-> quicksilver: Example of what, exactly?
05:59:52 <quicksilver> |Steve|: you're in the "would have learnt it anyway" category
05:59:58 <matt__r> MyCatSchemes:  then you are your own teacher - or the text writer is your teacher
06:00:04 <|Steve|> Oh, I lied. I learned MIPS entirely in school.
06:00:06 <MyCatSchemes> Philippa_: ah, I see what you mean there.
06:00:18 <ddarius> Perhaps I'm a good teacher for myself...
06:00:19 <|Steve|> (But I don't think assembly counts since I don't program in it, ever.)
06:00:25 <quicksilver> Syzygy-: example of what programming languages are good or bad as first languages.
06:00:28 <kilimanjaro> I figure your education is too important to be left entirely in the hands of others
06:00:28 <Syzygy-> Ah.
06:00:29 <MyCatSchemes> matt__r: hence the need for damn good text books. (Three, nay, four cheers for Sussman.)
06:00:34 <Syzygy-> I started with GWBasic - does that count?
06:00:52 <MyCatSchemes> kilimanjaro: that's an interesting way of putting it. :)
06:00:56 <Syzygy-> I also started with 11, so I may be an exception as well.
06:01:07 <Philippa_> I learned Java in a few hours when it was going to be the first module at UoN
06:01:10 <ddarius> Philippa_: Pictures!
06:01:11 <wli> I started with C.
06:01:12 <MyCatSchemes> Syzygy-: BASIC does teach a few useful things.
06:01:18 <matt__r> MyCatSchemes:  I am with you on that one
06:01:29 <ddarius> MyCatSchemes: Like what spaghetti code looks like.
06:01:37 <Philippa_> ddarius: *cough*
06:01:39 <|Steve|> Philippa_: Java was my fourth language and after C, C++, and Objective-C, it was pretty easy to pick up.
06:01:40 <matt__r> I started with Pascal :)
06:01:46 <MyCatSchemes> Syzygy-: like, when you start using C later, it'll let you realise *immediately* how painful memory management by hand is, instead of a few years down the line when you later start trying better programming languages.
06:02:02 <Philippa_> yeah, I already knew C and was making my way through C++
06:02:17 <quicksilver> Syzygy-: yes, you're an exception too. I imagine most people in the channel are, really
06:02:22 <kilimanjaro> The nice thing about BASIC is that you don't have to do things the right way, you just get started and through trial and error you can do fun stuff (that's where I got my start as a kid)
06:02:23 <MyCatSchemes> |Steve|: I'm curious as to whether you've ever tried Smalltalk?
06:02:27 <quicksilver> Syzygy-: the question was about 'typical' first year undergrads
06:02:29 <|Steve|> You know, everyone bitches about memory management in C, but it's really not that hard. And in C++, it's even easier.
06:02:35 <wli> I didn't find the language to be particularly interesting. I wrote programs to do parallel Runge-Kutta diffeq solving my first week in college.
06:02:42 <ddarius> MyCatSchemes: I started on QBASIC and went to a Cish C++ and eventually C++.
06:02:42 <|Steve|> MyCatSchemes: You know, I never have. I know it was a precursor to objective-c.
06:02:58 <quicksilver> Syzygy-: I.e. you've done no programming before, you turn up at university. What do they teach you in your firs tterm?
06:03:13 <MyCatSchemes> |Steve|: it's not impossible, no, but it's still work that isn't actually neccessary for you to tackle by hand outside of a few well defined domains.
06:03:14 <quicksilver> |Steve|: I think that just says something about the kinds of programs you have written in C and C++
06:03:21 <Philippa_> of course, I'm talking about Java back in 2000, and minimal library knowledge (I kept bashing out singly-linked list classes in exams too, although at least one was for a module where we were using Java only because not enough people knew C)
06:03:37 <quicksilver> |Steve|: memory management is a real pain for a large class of problems.
06:03:38 <Syzygy-> quicksilver: Have you ever seen a typical first year undergrad?
06:03:41 <Syzygy-> o.O
06:03:46 <quicksilver> Syzygy-: yes, a very large number of them.
06:03:53 <Philippa_> Smalltalk is well worth some exposure to
06:03:53 <quicksilver> Syzygy-: I've both been one, and taught some :)
06:03:59 <MyCatSchemes> ddarius: spaghetti code... if you want to see spaghetti code, you need to start looking at peoples' PIC programs. ;)
06:04:00 <Syzygy-> Oh dear. ;)
06:04:01 <quicksilver> Syzygy-: I even married one...
06:04:19 <|Steve|> quicksilver: I've worked as a programmer on an arcade game in C++.
06:04:21 <ddarius> quicksilver: A "typical" one?
06:04:24 <quicksilver> |Steve|: *ALL* commercially deployed C and C++ programs contain memory leaks.
06:04:25 <MyCatSchemes> Then I guess you've probably seen more of them that most. ;_
06:04:32 <|Steve|> It's not like I've been confined to small programs.
06:04:33 <MyCatSchemes> ;)
06:04:34 <quicksilver> |Steve|: now tell me memory management is easy :)
06:04:52 <quicksilver> ddarius: no, I suppose she wasn't very typical ;)
06:05:08 <|Steve|> You have memory leaks in Java too. I suspect you get them in Haskell as well.
06:05:13 <quicksilver> of course
06:05:21 <ddarius> Even computers find it hard.
06:05:23 <MyCatSchemes> |Steve|: except that we call 'em "space leaks" instead. ;)
06:05:23 <quicksilver> for different kinds of reasons, though :)
06:05:30 <Nopik> scsibug: thanks
06:05:31 <matt__r> |Steve|: damn right you can (in Haskell and they are probably more insidious that in C++
06:05:44 <|Steve|> Fine, relabel it all you want.
06:05:55 <matt__r> perhaps I can ask the wisdom of the list
06:05:57 <MyCatSchemes> And yes, but references that're being held on to unneccessarily can be tracked down more easily than memory that's not referred to but still left un-freed.
06:05:59 <wli> quicksilver: They also contain buffer overflow exploits, NULL and wild pointer dereferences, and more.
06:06:06 <|Steve|> When my c++ program is leaking, I run leaks on it and track'em down.
06:06:10 <ddarius> Actually in the nexus of a Haskell program space itself starts growing.
06:06:19 <Philippa_> you can get memory leaks in any GCed language if you're careless about references. Haskell has a further bunch of problems due to laziness though - it's not as well understood how to handle that
06:06:26 <matt__r> are haskellers ignoring the "space leak" elephant in the room when we evangelise our language.
06:06:29 <matt__r> ?
06:06:50 <|Steve|> I don't think it matters, you're not really getting the word out about haskell.
06:06:59 <wli> You have to program in something without dynamic memory allocation for the space problem to be solvable.
06:07:06 <|Steve|> Every time I say I've written something in haskell, or I like haskell, people think I'm saying pascal.
06:07:21 <kilimanjaro> Haha
06:07:26 <Philippa_> if haskell suddenly gained perl-level "success" we'd rapidly lose what makes the community (and to a large extent the language) worthwhile under a flood of crap libs though
06:07:33 <ddarius> matt__r: Programming in a lazy language is more different than programming in an eager language than most people are aware of.
06:07:35 <wli> Fortran comes to mind.
06:07:46 <|Steve|> Philippa_: That's an...interesting POV.
06:07:54 <quicksilver> wli: yeah, they're probably more important
06:08:04 <MyCatSchemes> matt__r: no, 'cuz a) the Java crowd have it too and b) space leaks are rather less nasty to track down.
06:08:08 <matt__r> ddarius: agreed
06:08:09 <Philippa_> |Steve|: it's not commonly stated as directly, but there's a reason "avoid success at all costs" became a catchphrase
06:08:15 <|Steve|> I kind of liked programming in ocaml. I only did a tiny bit for my grad pl class.
06:08:26 <Philippa_> haskell is what it is partly because we're all picky
06:08:28 <|Steve|> Funny, I've never heard that catchphrase...
06:08:35 <MyCatSchemes> It's a good one, though.
06:08:38 <|Steve|> And I can't wait for Haskell'.
06:08:39 <kilimanjaro> |Steve|, sure, just don't tell anyone in #haskell that you like... ohh wait
06:08:44 <Philippa_> sure. How long have you been around here?
06:08:48 <matt__r> MyCatSchemes: how does the java version manifest itself?
06:09:02 <|Steve|> Philippa_: Me?
06:09:05 <ddarius> @google "Haskell retrospective"
06:09:07 <wli> I'm not remotely interested in language evangelism. Haskell is merely useful to me.
06:09:07 <lambdabot> http://research.microsoft.com/~simonpj/papers/haskell-retrospective/index.htm
06:09:07 <lambdabot> Title: Wearing the hair shirt: a retrospective on Haskell
06:09:07 <Philippa_> (it comes from a retrospective written by Simon Peyton-Jones, btw)
06:09:17 <ddarius> |Steve|: Read that, it's entertaining.
06:09:24 <MyCatSchemes> matt__r: exactly the same way. Data structures containing references to other data structures and people forgetting to clean up references to them.
06:09:28 <|Steve|> ddarius: Will do.
06:10:01 <MyCatSchemes> matt__r: apparently a common one is hash tables used for memoization whose references are kept in scope for the whole length of the program when they're only actually used for part of it.
06:10:11 <|Steve|> Alas, it's 6 am and I need some sleep. This is by far the best programming language channel I've even been in, so I can't argue with the community aspect.
06:10:24 <Philippa_> |Steve|: there isn't a perl-sized user base currently that's picky enough about correctness, good factoring and type-safety. So if we suddenly gained that many users, the haskell community would undergo a radical shift in values
06:10:45 <matt__r> MyCatSchemes:  aha
06:10:50 <|Steve|> I like perl. It's fun.
06:10:55 <MyCatSchemes> |Steve|: I concur. Only channels I've tried that hold a candle to this are #scheme and, uh, possibly #nethack.
06:11:15 <|Steve|> I haven't tried #scheme. ##c and ##c++ were terrible for the week I spent in them.
06:11:25 <quicksilver> Philippa_: which makes me worry, sometimes, about how easy it is to write type-unsafe and/or semantic destroying GHC libraries
06:11:26 <MyCatSchemes> |Steve|: though the latter will occasionally merrily tell me to eat Medusa's corpse in order to point and laugh at my YASD message.
06:11:26 <ddarius> I've never been to #scheme, thought about it now and again.
06:11:32 <quicksilver> Philippa_: using unsafeFOO or RULES
06:11:47 <quicksilver> MyCatSchemes: that's part of the charm, though
06:11:49 <MyCatSchemes> ddarius: I just tried it once offhand to see what it was like. I got the impression it was pretty similar to here.
06:11:57 <Philippa_> quicksilver: yup, and that you won't get /any/ warning that they're being used. A warning flag for 'em would be nice
06:12:21 <ddarius> Philippa_: We could easily make "safe" modules and such.
06:12:23 <MyCatSchemes> quicksilver: oh yes, of the game, too. It wouldn't be NetHack if my characters ever survived for more than five consecutive minutes.
06:13:32 <MyCatSchemes> matt__r: but of course, the thing about space leaks is... those unneccessary references are still hanging around. You can run a debugger over and manually audit all the references in your program, if neccessary. ;)
06:13:58 <quicksilver> we may trust dons and dcoutts to write such dangerous code (do we?) but can we trust Random.Hackage.uploader?
06:14:38 <|Steve|> Wait, there's a Haskell debugger?
06:14:41 <ddarius> quicksilver: No we don't (re dons and dcoutts).  We bash their libraries and see what bugs pop out.
06:14:46 <matt__r> quicksilver: you always have to trust your lib writer
06:14:55 <fasta> |Steve|: there is a broken debugger in 6.7
06:14:56 <Philippa_> matt__r: no, no you don't
06:14:57 <ddarius> |Steve|: For several values of "debugger", there're many.
06:15:06 <wli> page 54, type classes as logic programs
06:15:12 <fasta> ddarius: many? Name 2
06:15:29 <quicksilver> matt__r: in an ideal world you wouldn't, no
06:15:30 <|Steve|> And you can't even add print statements. I've never figured out how to debug a haskell program.
06:15:30 <ddarius> Buddha, Freya, Hat, HOOD, the GHCi debugger
06:15:42 <|Steve|> basically, I just assume that if I can sneak it past the type system, I'm right.
06:15:42 <matt__r> Philippa_: so what are the practical techniques for using safe but untrustworty code
06:15:42 <quicksilver> |Steve|: by using the REPL
06:15:55 <quicksilver> |Steve|: and trying out your component functions one by one
06:15:57 <|Steve|> REPL = read eval print loop?
06:16:00 <matt__r> ddaruis: is hat working on the latest GHC?
06:16:01 <quicksilver> |Steve|: understading hte errors
06:16:02 <quicksilver> yeah
06:16:04 <fasta> ddarius: ok, two that work for Haskell + all common libraries
06:16:05 <Philippa_> matt__r: sufficiently strong typing, sandboxing
06:16:15 <quicksilver> I don't find "imperative-style" debuggers a good match fo haskell debugging problems
06:16:20 <|Steve|> One cannot always write such modules.
06:16:22 <ddarius> matt__r: I don't think Hat ever worked for GHC.  It was an NHC thing.
06:16:23 <quicksilver> I much rather derive Show instances for my data types
06:16:29 <quicksilver> Hat does work for GHC
06:16:37 <matt__r> Philippa_: yeah - but you need to bypass the safe typing for just about any working program
06:16:38 <quicksilver> malcolmw demonstrated it recently to me
06:16:38 <fasta> ddarius: Hat did work at some point
06:16:43 <quicksilver> I've not used that
06:16:53 <Philippa_> matt__r: no, no you don't
06:16:53 <wli> Nice, talking about ML functors vs. Haskell modules, too.
06:16:54 <malcolmw> there's an SoC project to rehabilitate Hat with modern ghc + libraries + etc
06:16:56 <ddarius> fasta: I was out of the community for a good while.
06:16:56 <quicksilver> matt__r: I've written many haskell programs and not once bypassed any of the safety
06:16:57 <matt__r> Philippa_: unless you rewrite all hte c librarries we rely on
06:17:00 <fasta> ddarius: severly limited to H98, though. 
06:17:11 <wli> Philippa: This retrospective is awesome. It talks about a bunch of things I think about all the time.
06:17:25 <quicksilver> matt__r: well that last is a fair point
06:17:28 <Philippa_> that depends how you define "trust". You can ensure that the C libraries are the source of any untrustworthiness, for example
06:17:32 <quicksilver> matt__r: but as long as the C libraries don't actually segfault
06:17:36 <|Steve|> Okay, I said I was going to sleep and this time I mean it. Goodnight. (I'll read those papers/links when I wake up.)
06:17:40 <quicksilver> matt__r: they don't upset the semantics of the haskell code
06:17:42 <malcolmw> fasta: Hat is not limited to haskell'98
06:17:53 <quicksilver> (unless someone made a pure binding for a function which isn't really pure)
06:17:54 <Philippa_> quicksilver: strictly speaking, even if they do so long as they're in the IO monad
06:18:01 <matt__r> just think how to write a safe HDBC, or readline or networking, etc
06:18:02 <fasta> malcolmw: or it didn't include all libraries? 
06:18:02 <quicksilver> but that's the binding author's fault not the libraries
06:18:11 <quicksilver> Philippa_: good point
06:18:20 <fasta> malcolmw: or I am confusing two tools
06:18:28 <malcolmw> fasta: yup, the hierarchical libraries all arrived after the Hat implementation was finished
06:18:31 <matt__r> when you are part of a larger stack and you don't know how the code is working, you have to "trust" the library writer
06:18:38 <ddarius> Auf wiedersehen.
06:18:49 <Philippa_> matt__r: yes. That's a notably weaker statement than your original one though
06:19:12 <quicksilver> matt__r: in a strongly typed system, you can be precise about how much trust that is
06:19:12 <Philippa_> "you have to trust the substrate system" just isn't the same as "you have to trust libs in your own language"
06:19:25 <quicksilver> certainly you have to trust him to write code which terminates
06:19:34 <quicksilver> but often it's not much more than that
06:19:41 <Philippa_> actually, that can be eliminated with the right type system too
06:19:46 * quicksilver nods
06:20:08 <matt__r> Philippa_: well yeah - so we need to have unsafeperformIO propagate up from where it is used
06:20:24 <matt__r> then we can always know when code calls out to something unsafe
06:20:42 <Philippa_> matt__r: funny, that's already been proposed in here today
06:21:11 <matt__r> Philippa_: I just means losing one or two functions that go IO a -> a right?
06:21:46 <Philippa_> it just means knowing when they're called. Whether you then trust them's up to you
06:22:09 <Philippa_> I can certainly build useful systems that don't need unsafePerformIO, YMMV
06:23:27 <tanuk> Hello, I'm having problems. Stdin seems to be buffered even though I set it to NoBuffering in the start of the program.
06:23:28 <matt__r> Philippa_: I am with you on that, but I find myself constantly using code (libs) that does use unsafePerformIO
06:23:58 <matt__r> tanuk: hpaste your code
06:24:24 <Philippa_> sure. There're some classic uses that can be avoided with a more powerful language though...
06:24:45 <wli> Philippa: Which uses and what sort of power?
06:25:01 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1712
06:25:21 <tanuk> Uh, I should have given my nick to that...
06:25:24 <Philippa_> wli: faking global mutable variables is one that comes to mind - a more powerful module system can handle it
06:25:49 <hkBst> does the Haskell code in http://blogs.nubgames.com/code/?p=15 get displayed correctly for anyone? Both in konqueror and firefox it is too wide for the box it is in and not displayed fully.
06:25:51 <lambdabot> Title: Nub Games  Haskell &#8212; First Impressions
06:26:07 <Philippa_> a number of other uses involve mutability too, and could be dealt with via linear types. Yet more could be dealt with if we took a different approach to monadic programming...
06:26:11 <tanuk> The program removes parts from the input that comes in stdin and prints it to stdout.
06:26:59 <nopcode> how do remove duplicate elements from a list?
06:27:02 <fasta> hkBst: drop the italics 
06:27:15 <opqdonut> nopcode: nub
06:27:37 <hkBst> fasta: how can I do that?
06:27:41 <nopcode> is that an insult or the name of a function? ;P
06:27:52 <fasta> hkBst: is it your webpage?
06:27:54 <opqdonut> > nub . take 1000 $  cycle [1,2,3]
06:27:54 <tanuk> Every line is examined and if it fulfills the requirement (contains "System exclusive") a part of it is printed. Otherwise it is ignored.
06:27:56 <lambdabot>  [1,2,3]
06:27:57 <hkBst> fasta: no
06:28:12 <opqdonut> nopcode: name of the function as you can see :)
06:28:16 <fasta> hkBst: oh, it is displayed here fully
06:28:28 <fasta> hkBst: the italics are very ugly however(Firefox)
06:28:31 <Lemmih> hkBst: It looks fine to me.
06:28:33 <fasta> hkBst: Iceweasel*
06:28:41 <matt__r> tanuk: sorry - it must be too late for me, I can't get my head around it well enough to give you useful advice.
06:28:57 <nopcode> opqdonut: ok thx *G*
06:29:18 <hkBst> fasta: histories  = takeWhile ((> 0) . length) . unfoldr history . li <rest cutoff>
06:29:26 <tanuk> matt__r: Thanks for trying anyway.
06:29:33 <hkBst> Lemmih: what browser?
06:29:36 <tuukkah> tanuk, did you try with a simple cat?
06:29:40 <Lemmih> hkBst: Firefox.
06:29:49 <fasta> hkBst: I see lines are last word
06:29:50 <matt__r> tanuk: hFlush might helo :0
06:29:53 <matt__r> :)
06:29:56 <fasta> hkBst: as*
06:30:26 <tanuk> matt__r: I tried to insert hFlush after every putStrLn, but it didn't help.
06:30:57 <tanuk> tuukkah: What do you mean.
06:30:59 <tanuk> ?
06:31:03 <hkBst> fasta: it only gets worse as I increase font size and I seem to be at the minimum :(
06:31:32 <quicksilver> tanuk: what OK, and which makes you think the turning off the buffering isn't working?
06:31:34 <fasta> hkBst: use no page style or complain to author
06:31:36 <tuukkah> tanuk, you can try to make the program as simple as possible and see whether it still has the problem
06:31:53 <quicksilver> tanuk: don't you want to turn buffering off on stdout
06:31:59 <hkBst> fasta: I would if I could find his email...
06:32:51 <tanuk> quicksilver: Yes I want... Thanks for pointing out.
06:32:53 <tuukkah> tanuk, besides, please don't make Ctrl-C not exit the program :-)
06:33:00 <fasta> hkBst: leave a comment in his commenting system
06:33:29 <tuukkah> Ctrl-D doesn't work either but that's a problem in ghc i suppose
06:34:10 <tanuk> tuukkah: It still exits, without the handler the buffered part would be discarded, this way at least on exit everything gets written.
06:34:48 <tuukkah> doesn't exit here using runghc version 6.6
06:36:33 <Lemmih> tanuk: It seems to do exactly what it's supposed to.
06:37:15 <Lemmih> Entering "        System exclusive          This is a test"  gives  "This is a test".
06:37:50 <bringert> dcoutts: you here?
06:38:47 <liber> what exactly do I get if I use "return True" in an application? It isnt a Bool, at least
06:38:54 <liber> I get a type error
06:39:11 <tuukkah> @ type return True
06:39:12 <tanuk> Lemmih: Yeah, it seems to print it fine when getting input from keyboard...
06:39:14 <tuukkah> @type return True
06:39:23 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool
06:39:24 <liber> return True :: (Monad m) => m Bool
06:39:47 <liber> Is there a way to typeset that?
06:40:06 <tuukkah> you get a Bool in a monad
06:40:23 <liber> And I have not gotten to the chapter about Monads yet :)
06:40:32 <mauke> liber: then why are you using return?
06:40:49 <Igloo> tanuk: What's the problem?
06:40:50 <quicksilver> liber: think of it just as a 'structure'
06:40:55 <quicksilver> liber: in quite an abstract sense
06:41:04 <quicksilver> liber: "return True" returns true embedded in some kind of structure
06:41:05 <Lemmih> tanuk: Piping the text with 'echo' gives exactly the same response.
06:41:24 <EvilTerran> > (return :: a -> Maybe a) True
06:41:25 <lambdabot>  Just True
06:41:31 <EvilTerran> > (return :: a -> [a]) True
06:41:32 <lambdabot>  [True]
06:41:44 <Lemmih> tanuk: Same with piping it from a file.
06:41:58 <liber> mauke: because I want to return a bool from a function
06:42:02 <tanuk> Lemmih: The program that the data runs continuously, so EOF doesn't come before ctrl-c.
06:42:05 <mauke> liber: that has nothing to do with 'return'
06:42:09 <opqdonut> ?src (\\)
06:42:10 <lambdabot> (\\) = foldl (flip delete)
06:42:22 <tanuk> "the data runs" -> "the data comes from runs"
06:42:25 <EvilTerran> liber, ah. you've got completely the wrong end of the stick, i'm afraid.
06:42:25 <mauke> liber: think of return x as new Monad(x)
06:42:36 <liber> alright
06:42:38 <vincenz> mauke++ for proper color usage
06:42:41 <mauke> i.e. a constructor call
06:42:47 <scook0> liber: to return a value, just write the value ... 'return' is used for something different in Haskell
06:42:59 <liber> I havent gotten to that part of the tutorial yet. Just experimenting a bit on my own :
06:43:00 <liber> )
06:43:10 <quicksilver> liber: just thiis, is all it takes:
06:43:10 <dozer> how do I do this: data Baz (bar foo) foo = ...
06:43:13 <quicksilver> my_fun = True
06:43:21 <quicksilver> liber: no special keyword for return, in that sense
06:43:32 <SamB_XP> dozer: you can't do *that*
06:43:33 <dozer> I want Baz parameterised over two types, but the first type must be itself parameterised over the seccond type
06:43:34 <EvilTerran> liber, think of the body of a function as an expression, rather than a code block
06:43:48 <dozer> SamB_XP: can I get close?
06:43:53 <liber> quicksilver: but if I have alot more things, like in a "do"-"block"
06:43:58 <ski> dozer : maybe 'data Baz bar foo = ...' is what you want ?
06:44:06 <SamB_XP> you could do data Baz bar foo = ...
06:44:07 <liber> Do i stull just end the "block" with "True"
06:44:09 <liber> ?
06:44:17 <SamB_XP> and, in ..., write (bar foo)
06:44:18 <tuukkah> or "data (Baz (Bar foo)) = ..."
06:44:26 <EvilTerran> "foo x = <expression involving x>" means "whenever you see 'foo <something>', replace that with <expression involving x> except with <something> in place of x"
06:44:29 <edwardk> hrmm. so if i have * as multiplication, .* as left scalar multiplication, *. as right scalar multiplication with generalized signatures a -> a -> a, a -> b -> b and b -> a -> b, respectively does having .*. with a -> b -> c | a b -> c seem too specific? with the idea being that the . tells you where type inference will break over the general signature.
06:44:31 <tanuk> Lemmih: Do you think if it is possible that the input program checks if the output goes to a terminal, and in that case uses less buffering?
06:44:43 <scook0> liber: if you aren't up to monads, you probably shouldn't be using do
06:44:46 <ski> liber : if you're in a do-block, then if you just want to return a value at the end, you use 'return'
06:44:48 <quicksilver> liber: you need to be a bit more precise about 'other things'
06:44:55 <dozer> ah, so in each place I currently use bar in the declaration, actually write (bar foo) instead
06:44:57 <quicksilver> liber: you don't want to use 'do' unless you're using monads
06:45:02 <MyCatSchemes> scook0: hhgh?
06:45:16 <dozer> like: data Baz bar foo = BZ (bar foo) foo
06:45:16 <liber> quicksilver: aigtt :) Ill just keep reading the tutorial. Thx guys
06:45:22 <EvilTerran> liber, what i just said there is a good way of thinking about things, even tho it's not quite a perfect description of how it really works ;]
06:45:27 <scook0> MyCatSchemes: unless you're cargo-culting monadic IO or something
06:45:34 <quicksilver> liber: and, from what you're saying, you don't waht to use monads :)
06:45:45 <quicksilver> SamB_XP: that' won't work
06:45:45 <liber> :D
06:45:45 <MyCatSchemes> scook0: jah, precisely. ^^
06:45:53 <SamB_XP> edwardk: that does seem a bit more specifc than needed...
06:45:54 <quicksilver> SamB_XP: data types can't have higher-kinded fields
06:45:59 <quicksilver> SamB_XP: 'bar' is a type constructor
06:46:06 <quicksilver> SamB_XP: if I'm following dozer corectly
06:46:12 <SamB_XP> quicksilver: what the heck are you talking about?
06:46:18 <SamB_XP> @src StateT
06:46:19 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
06:46:22 <SamB_XP> arg.
06:46:28 <quicksilver> data Bar (bar foo) foo
06:46:33 <quicksilver> bar is a type constructor, I presume
06:46:37 <quicksilver> erm
06:46:40 <SamB_XP> quasisane: so?
06:46:41 <SamB_XP> er.
06:46:41 <dozer> quicksilver: yes it is
06:46:42 <quicksilver> data Baz (bar foo) foo
06:46:44 <SamB_XP> quicksilver: so?
06:46:52 <quicksilver> well you can't say 'data Baz bar foo' then
06:46:57 <quicksilver> because then bar is a type constructor
06:47:00 <SamB_XP> yeah you can...
06:47:14 <quicksilver> you can't have higher kinded fields...
06:47:26 <SamB_XP> haven't you heard of kinds like (* -> *) -> * -> * before?
06:47:36 <edwardk> samb: well, the .* for scalar multiplication gives you things like multiplication by the naturals for peasant multiplication over any semigroup. .*. gives a limited form of type inference to the result, and lets you use that same type to  witness type level multiplication
06:47:39 <quicksilver> oh hang on
06:47:45 <quicksilver> on the left of the = not the right of the =?
06:48:02 <edwardk> samb: then typeints, could offer up witnesses in the form (.+.)   (.*.), etc.
06:48:03 <quicksilver> I thought we were on the right of =
06:48:04 <quicksilver> sorry :)
06:48:20 <SamB_XP> quicksilver: oh ;-)
06:48:30 <sieni> '
06:48:58 <SamB_XP> quicksilver: it's very true that you can't have data of types whose kinds have arrows in them ;-)
06:49:56 <SamB_XP> edwardk: well, will it hurt anything for you to add it?
06:50:00 <edwardk> samb: though in the case of (.+.) i'd really like to make the inference tridirectional a b -> c, a c -> b, b c -> a, but perhaps thats a bit overzealous, or rather maybe thats best used as the type for (+) with most instances setting them to the same
06:50:53 <edwardk> (+) : a -> b -> c | a b -> c, b c -> a, a c -> b     (.*) : a -> b -> b      (*.) : b -> a -> a      (.*.) : a -> b -> c | a b -> c
06:51:08 <edwardk> er (*)
06:51:33 <SamB_XP> edwardk: hmm, I'm a bit curious. do you use a dictionary-passing or a typecase implementation?
06:51:56 <edwardk> then we have the case where type inference always works, probably fails on the left, probably fails on the right, and where it probably fails on both arguments.
06:52:17 <edwardk> ironically a bit of both, i have the worst case issues of each =)
06:52:48 <edwardk> typecase determines which dictionary to pass around in the event the dictionary wasn't explicitly passed
06:52:50 <SamB_XP> what, it's as slow as dictionary passing but has the whole-program-compilation of typecases?
06:53:09 <edwardk> and i'm already whole program compiling anyways
06:53:10 <tanuk> tuukkah: You asked to try with plain cat, I think I now understood that. I replaced my program with cat and that too doesn't print everything immediately. Is there anything that can be done, or is this completely the source program writer's fault?
06:53:29 <SamB_XP> do you do existentials?
06:53:45 <edwardk> not yet, they are on the 'would-be-cool' feature list
06:53:58 <SamB_XP> hmm. I guess my next question is inapplicable then ;-)
06:54:11 <edwardk> i had a version back when it was a simple PTS
06:54:16 <quicksilver> SamB_XP: sensible dictionary passing manages to optimise out the dictionary in most cases, though
06:54:18 <edwardk> but they got dropped when things got more complicated
06:54:26 <quicksilver> SamB_XP: so practical dictionary passing isn't that slow, is it?
06:54:47 <SamB_XP> quicksilver: you'd be surprised
06:55:15 <quicksilver> SamB_XP: what makes it slow, then?
06:55:19 <SamB_XP> sure, when you use >>= and >> and return at statically known types
06:55:22 <SamB_XP> that's fine
06:56:00 <SamB_XP> quicksilver: as far as I know, GHC doesn't know that there is only one dictionary for each type
06:56:10 <quicksilver> I believe it does
06:56:14 <SamB_XP> (for a given dictionary constructor)
06:56:30 <edwardk> ok, i'll go with the 4 signatures above i think and see if i can use them uniformly used across all binary operators in the prelude (modulo the ==, &&, etc) ones that go a -> a -> b, 
06:56:57 <SamB_XP> I mean, afaik, it doesn't optimize Core based on that assumption
06:57:06 <fasta> A 140 line function, what will the fanboys say to that!
06:57:09 <quicksilver> well most methods are inlineable
06:57:23 <quicksilver> which means the optimiser can remove the case on the dictionary
06:57:24 <ski> fasta : fie on you :)
06:57:26 <edwardk> and in my case i can have a lot of dictionaries for a given type =/
06:57:54 <edwardk> since you can pass them by name
06:57:56 <SamB_XP> quicksilver: if it knows which dictionary to use, sure
06:58:05 <dozer> ok - what about if I wanted to instead say something like: data Baz foo bar | foo -> bar = ...
06:58:28 <quicksilver> that's what associated types are for, I believe?
06:58:56 <SamB_XP> dozer: hmm.
06:59:00 <fasta> I find the associated types less natural to read than fundeps
06:59:21 <quicksilver> fasta: this isn't a class, thouh
06:59:28 <quicksilver> fasta: it's a data declaration
06:59:35 <SamB_XP> dozer: data BazClass foo bar => Baz foo bar = ... ?
07:00:21 <quicksilver> SamB_XP: I think you may be underestimating the dictionary passing approach, in the presence of a good optimiser
07:00:31 <SamB_XP> fasta: associated type synonyms are nice when you truly just want an associated type...
07:00:32 <quicksilver> SamB_XP: have a look at the core generated by -O2 
07:00:33 <fasta> quicksilver: oh, I wasn't paying attention and I guess I wanted to say that regardless of it ;)
07:01:08 <SamB_XP> fasta: especially if you have already written some code using a class before you added one
07:01:42 <SamB_XP> quicksilver: have they recently improved it?
07:02:36 <hpaste>  tuukkah annotated "(no title)" with "Still buffered..." at http://hpaste.org/1712#a1
07:03:07 <tuukkah> tanuk, could be a problem with getLine
07:03:57 <tuukkah> tanuk, if i change that paste to use getChar and putChar, it isn't line-buffered anymore
07:04:22 <MyCatSchemes> Philippa: eh, I thought the underscore kinda suited you. ;)
07:04:24 <SamB> quicksilver: does it now realize that the Fractional a field in a RealFrac a has the same value as the one in a Floating a?
07:04:30 -ChanServ(ChanServ@services.)- shapr!n=user@cs6625119-253.bham.res.rr.com ACCESS [#haskell] ADD Philippa 39
07:04:48 <shapr> Good morning #haskell!
07:05:02 <SamB> what does 39 do?
07:05:03 <blackdog_> shapr: only by seven minutes
07:05:10 <tuukkah> shapr, good evening shapr :-)
07:05:24 <shapr> heippa hei tuukkah 
07:05:25 <tanuk> tuukkah: Maybe I'll try with getChar. It's just that line buffering would be good enough, but the input seems to be buffered more than that.
07:05:27 <shapr> g'day blackdog_ 
07:05:33 <Igloo> tanuk: getLine doesn't return anything until it finds a newline
07:05:49 <SamB> quicksilver: well? does it?
07:05:53 <MyCatSchemes> shapr: cannot construct contradictory type (EarlyInDay, Doesn'tSuck) at line 1, arising from expression "good morning"
07:06:11 <blackdog_> shapr: am writing stupid postgres db code. the filthy, disgusting things i do for money... tell me you're doing something more interesting
07:06:16 <quicksilver> SamB: I don't know. I thought it did.
07:06:31 <tanuk> Igloo: Sorry for giving code that doesn't accurately tell my intentions. I tried with NoBuffering after LineBuffering didn't work (it should work).
07:06:51 <Igloo> tanuk: What should work?
07:06:56 <tanuk> Line buffering.
07:07:15 <shapr> MyCatSchemes: Try going to sleep earlier ;-)
07:07:18 <Philippa> SamB: 39 is basically full ophood
07:07:28 * Igloo can't work out exactly what program doesn't do what
07:07:32 <shapr> blackdog_: Yeah, about to do some HAppS hacking.
07:07:33 <tuukkah> tanuk, so can you see the line buffering not working with the simpler program i pasted?
07:07:37 <MyCatSchemes> shapr: I do go to sleep early. Early in the morning.
07:07:47 <shapr> heh
07:08:02 <tanuk> tuukkah: I missed your paste, I'll look it up, one moment.
07:08:31 <SamB> wow, standard Haskell has so few types...
07:09:15 <ski> SamB : countably infinite isn't enough for you ?
07:09:28 <SamB> ski: I meant in the library
07:09:44 <SamB> or at least so few class instances for those types
07:09:54 <mauke> there's [()], [[()]], [[[()]]], ...
07:10:09 <SamB> type constructors, if you will...
07:10:10 <ski> mayhaps you mean s/type/type constructor/ ?
07:10:12 <ski> (:
07:12:10 <tanuk> tuukkah: That's block buffered too.
07:12:48 <tuukkah> tanuk, and did you try with both getLine and getChar?
07:13:14 <tanuk> tuukkah: No... I'll try.
07:13:18 <blackdog_> aurynn: you wouldn't stripe the data?
07:13:31 <blackdog_> oops, sorry
07:15:14 <tanuk> tuukkah: Output comes still in blocks when piping aseqdump's output to Test. Typing the input from keyboard works.
07:15:37 <quicksilver> tanuk: oh, well that's the output sides fault then
07:16:03 <quicksilver> tanuk: if aseqdump is block buffering then there is nothing you can do at your end
07:17:33 <tanuk> quicksilver: If I don't pipe aseqdump's output, so that it is printed in the terminal, output comes immediately.
07:17:43 <quicksilver> again, that's aseqdump's fault
07:17:56 <quicksilver> programs which use the stdio C bindings
07:18:04 <quicksilver> will exhibit line buffering if stdout is a TTY
07:18:19 <quicksilver> but block buffering  otherwise
07:18:31 <quicksilver> (unless they explicitly choose a different buffering style)
07:18:32 <tanuk> quicksilver: Ok, the cause is now clear, thank you.
07:19:18 <quicksilver> this is, essentially, an optimisation
07:19:25 <quicksilver> it's notably confusing until you understand it though :)
07:19:35 <tanuk> quicksilver: Can this be altered externally, or do I have to modify aseqdump's source?
07:19:43 <SamB> it can be really annoying at times
07:19:58 <quicksilver> if you're really lucky, aseqdump has an option to control it
07:20:07 <tanuk> I'm not lucky.
07:20:25 <SamB> I wish GHC's RTS would flush it's output buffers at the end of a heap sample...
07:20:42 <quicksilver> you could foold aseqdump into thinking it's talking to a tty
07:20:56 <quicksilver> by using ioctls possibly?
07:21:01 <tuukkah> tanuk, there are gdb scripts for changing the stdout of a running program. you can probably make one that changes the buffering mode too
07:21:03 <zbrown> Has anyone had trouble with ghci on Debian etch? Its telling me ghci wasn't built with interactive use?
07:21:08 <SamB> quicksilver: or actually hook it up to a TTY
07:21:14 <quicksilver> SamB: yes, or that :)
07:21:26 <SamB> I don't know if ioctls would work or not
07:21:37 <SamB> I don't know much about them
07:22:23 <tanuk> With open source there is always the patching way, which seems to be the easiest way this time.
07:23:02 <Igloo> zbrown: ghci isn't enabled for arches other than x86 and amd64
07:23:19 <benny99> |Steve|: hey, just found this one here http://en.wikibooks.org/wiki/Haskell/Understanding_monads, maybe you want to try that
07:23:21 <lambdabot> Title: Haskell/Understanding monads - Wikibooks, collection of open-content textbooks
07:23:28 <zbrown> Igloo: oh. I didn't know that.
07:24:00 <benny99> bye again
07:24:02 <Philippa> Igloo: could I crib some stuff to try porting to a non-debian linux on arm at some point, btw?
07:24:14 <Philippa> still want to get a proper native build on my zaurus sometime
07:25:19 <crazy_coder> Hello everyone
07:25:37 <crazy_coder> Is it possible to produce multiple side effects in  a function ?
07:26:05 <quicksilver> yes
07:26:12 <Lemmih> crazy_coder: Multiple side-effects?
07:26:21 <Igloo> Philippa: How do you mean, "crib some stuff"?
07:26:22 <quicksilver> twosideffects = putStrLn "hello" >> putStrLn "world"
07:26:28 <quicksilver> that has two side effects
07:26:30 <crazy_coder> Like I take in a list and produce another list (by manipulating the given list) and also actually return something
07:26:34 <quicksilver> first it prints hello, then it prints world
07:26:57 <crazy_coder> What I return is permanent, but the list I modified isn't
07:27:06 <quicksilver> crazy_coder: why not just return two things?
07:27:12 <quicksilver> crazy_coder: that's the simplest way to do that
07:27:13 <crazy_coder> Can we do that ?
07:27:15 <quicksilver> sure
07:27:18 <Philippa> Igloo: take a poke at the debian arm build, I guess
07:27:21 <crazy_coder> How to do it ?
07:27:21 <SamB> > (1, 2)
07:27:23 <lambdabot>  (1,2)
07:27:29 <SamB> that's two things
07:27:31 <mauke> crazy_coder: return a value composed of two other values
07:27:32 <crazy_coder> returning as a tuple ?
07:27:36 <quicksilver> yup
07:27:37 <mauke> for example
07:27:41 <crazy_coder> Oh Ok
07:27:43 <earthy> mumblegrumble hat grumble
07:27:50 <crazy_coder> But it complicated the code , isn;t it? 
07:27:54 <crazy_coder> *complicates
07:27:56 <quicksilver> I don't think so
07:28:06 <quicksilver> just a question of what you're used to, perhaps
07:28:07 <crazy_coder> You then have to apply fst, etc
07:28:09 <malcolmw> earthy? tell me your Hat woes
07:28:12 <quicksilver> no you don't
07:28:16 <crazy_coder> To get back the stuff you put in
07:28:19 <quicksilver> nope
07:28:23 <quicksilver> you pattern match
07:28:24 <crazy_coder> How not ?
07:28:32 <mauke> > let (x, y) = (1, 2) in x * 10 + y
07:28:34 <lambdabot>  12
07:28:34 <quicksilver> let (x,l) = my_cool_fun m
07:29:33 <earthy> malcolmw: it won't accept existential types
07:29:42 <crazy_coder> Ok , I'll try, but if i use let as above, the x and y are local and not useful outside hte function
07:29:43 <crazy_coder> *the
07:29:44 <earthy> not even if I want to compile the module containing them as trusted
07:29:45 <Igloo> Philippa: I'm still not sure exactly what you want from me. If you mean "what goes in mk/build.mk", then http://hpaste.org/1713
07:30:00 <earthy> (as in: the code I want to trace doesn't contain the existentials explicitly)
07:30:12 <mauke> crazy_coder: yes, like all return values
07:30:14 <crazy_coder> Oh ok
07:30:17 <crazy_coder> I got it
07:30:18 <malcolmw> earthy: I'm pretty sure it should accept tham
07:30:38 <crazy_coder> something like (x,y) <- Some_function_which_returns_tuples
07:30:44 <wli> Are there anything like higher-order classes?
07:30:46 <crazy_coder> and then use x and y right ?
07:30:50 <quicksilver> crazy_coder: not <-, no
07:30:52 <malcolmw> earthy: the Hat parser is ripped from nhc98, which supported existentials since 1996
07:30:56 <quicksilver> crazy_coder: just let (x,y) = 
07:31:00 <crazy_coder> quicksilver: Its a monad 
07:31:07 <quicksilver> crazy_coder: ah, well then yes :)
07:31:08 <crazy_coder> IO (Int,Int) say
07:31:14 <earthy> class Applicable rule term where
07:31:14 <earthy>     apply :: rule -> term -> term
07:31:14 <earthy>     -- apply' :: forall m . (Monad m) => rule -> term -> m term
07:31:14 <earthy>     applicable :: rule -> term -> Bool
07:31:15 <quicksilver> exactly
07:31:20 <earthy> the commented line wasn't accepted
07:31:21 <crazy_coder> Thanks
07:31:45 <malcolmw> earthy: that's not an existential in the classic sense
07:31:48 <Philippa> Igloo: I wasn't actually asking anything right this moment, but yeah, that's a good start
07:31:50 <crazy_coder> actually i am trying to write a stack class 
07:31:58 <earthy> nope, true.
07:32:05 <crazy_coder> which has pop and push functions
07:32:15 <mauke> crazy_coder: that's just a linked list
07:32:22 <mauke> push is (:), pop is tail
07:32:30 <Philippa> but basically, give you a yell when I know what I'm after?
07:32:31 <crazy_coder> So in pop I have to return an element as well as modify the lsit
07:32:38 <malcolmw> earthy: and I'll bet that ghc has only supported that since GADTs were added
07:32:43 <quicksilver> mauke: but maybe it's interesting for crazy_coder to write it his way? :)
07:32:55 <crazy_coder> Thanks quicksilver
07:32:55 <quicksilver> crazy_coder: yes, returning a tuple of the two would be a common idiom
07:33:20 <crazy_coder> Also one thing more
07:33:30 <crazy_coder> When I write class Stack a where ....
07:33:32 <mauke> if you're doing it in IO, you can use data Stack a = Stack (IORef [a])
07:33:47 <crazy_coder> Then I have to define all instances of Class manually
07:33:54 <earthy> malcolmw: I could do without that btw.
07:33:58 <earthy> what I can't do without is
07:33:58 <earthy> newtype RealParser    state        s p a = P(forall r' r'' . (a -> r'' -> r') ->
07:34:01 <earthy>                                                         (state -> Steps r'' s p) ->  state -> Steps r'           s p)
07:34:03 <crazy_coder> Is there something like derive which will do it automatically ?
07:34:06 <mauke> crazy_coder: whoa. how many instances do you need?
07:34:24 <crazy_coder> Char,String, anything should go it
07:34:26 <earthy> it doesn't grok the ( before the forall somehow
07:34:27 <crazy_coder> *in it
07:34:38 <mauke> crazy_coder: that has nothing to do with classes
07:34:43 <mauke> just make a parametrized type
07:34:44 <earthy> and that, IIRC, is existential in the classic sense.
07:34:56 * shapr boings cheerfully
07:35:14 <malcolmw> earthy: not an existential, that is rank-2 polymorphism
07:35:23 <crazy_coder> mauke: you mean when I declare it like class Stack a where....... , I don't have to define all instances for it ?
07:35:37 <earthy> uhm. yah. 
07:35:42 <mauke> no, you shouldn't make it a class at all
07:35:50 * earthy is not awake *at*all* either
07:36:02 <earthy> which makes me even more grumbly. sorry for that.
07:36:14 <earthy> but the unfortunate issue is I can't use hat
07:36:15 <crazy_coder> mauke: why not ?
07:36:30 <earthy> even though I think I should be able to when I want to trust this code
07:36:35 <malcolmw> earthy: so, if you move the forall outside the constructor, does it still mean the same thing?  `cos then you could get it through Hat
07:36:53 <mauke> crazy_coder: what's the point?
07:37:40 <crazy_coder> mauke: I can store it in a module called Stack and use it whenever I want to use a stack
07:37:41 <earthy> you mean RealParser state s p a = forall r' r'' . P ((a -> r'' -> r') -> (state -> Steps r'' s p) -> state -> Steps r' s p)  ?
07:37:47 <mauke> crazy_coder: no, you can't
07:37:52 <mauke> crazy_coder: a class is just an interface
07:37:52 <earthy> lemme think about that one for a bit
07:38:00 <malcolmw> earthy: yep
07:38:00 <mauke> crazy_coder: you'd still have to write a concrete stack
07:38:34 <quicksilver> crazy_coder: yeah, this doesn't need to be a class
07:38:36 <tuukkah> crazy_coder, you know tail? it works for any type of list since its type is [a] -> [a]
07:38:44 <quicksilver> crazy_coder: a class is for when the instances are different, for different a
07:38:51 <quicksilver> crazy_coder: you can use the same code for any a
07:39:02 <quicksilver> crazy_coder: so this is just a plain old polymorphic function
07:39:16 <quicksilver> crazy_coder: from what you've told me so far, your stack doesn't need to be in IO, either
07:39:20 <quicksilver> crazy_coder: sounds like it is pure code
07:39:38 <crazy_coder> When do we use a class ?
07:39:53 <quicksilver> when you need to write different code for different types
07:39:54 <crazy_coder> To put all methods together
07:40:15 <mauke> crazy_coder: when you need a common interface to different types
07:40:22 <quicksilver> you'd use a class if you had a completely different way to implement a stack of ints, from a stack of strings
07:40:36 <quicksilver> but for this case, the same implementation works for all, and that's nice
07:40:42 <crazy_coder> How would push and pop be associated with stack
07:40:48 <pharm> I've always seens classes in Haskell as more like Java interfaces.
07:40:49 <crazy_coder> If i use just functions
07:40:57 <mauke> crazy_coder: they wouldn't
07:41:02 <quicksilver> by their types perhaps
07:41:03 <mauke> what do you mean by "associated"?
07:41:07 <quicksilver> or by the module they were in
07:41:11 <quicksilver> or by their documentation
07:41:13 <quicksilver> (or all three)\
07:42:06 <crazy_coder> I mean when I should be able to use pop and push only on certain lists(which are actually stacks) and not all
07:42:25 <mauke> but all lists are stacks
07:42:30 <tuukkah> in object-oriented programming data and methods are contained in object. but haskell isn't object-oriented and haskell doesn't have objects
07:42:54 <quicksilver> crazy_coder: if you want to do that, you'd make a 'newtype' for Stack
07:42:55 <mauke> you could make a new Stack type that doesn't support list operations
07:43:07 <quicksilver> crazy_coder: underneath it would actually be a list
07:43:08 <Toxaris> crazy_coder: you could use data Stack a = Stack [a], but why should you?
07:43:16 <quicksilver> crazy_coder: but the newtype would tag it as a stack
07:43:27 <quicksilver> so that you can only pass it to functions that want stacks
07:43:41 <crazy_coder> Oh I see, Now I get some important stuff
07:43:44 <quicksilver> but, as mauke and Toxaris say, why would you do that? all lists are stacks.
07:43:59 <quicksilver> seems unnecessary to restrict your instance
07:44:02 <quicksilver> erm
07:44:03 <crazy_coder> I really was confused with when to use what.. 
07:44:06 <quicksilver> restrict your types
07:44:06 <quicksilver> :)
07:44:07 <crazy_coder> hmm
07:44:13 <crazy_coder> I see the point
07:44:24 <mauke> class Stack s where {empty :: s a; push :: a -> s a -> s a; nstruct :: b -> (a -> s a -> b) -> s a -> b}  -- just because I can
07:45:00 <jedai> quicksilver: He could want to be really sure his 'stack' is never used as a list as it would invalidate some invariant he would like to have in his application
07:45:08 <crazy_coder> Ok one more thing, If I want to produce a side effect, I suppose one doesn;t have to return IO type right ?
07:45:19 <mauke> yes, you do
07:45:28 <quicksilver> well that depends what kind of side-effect
07:45:35 <mauke> (ignoring ST)
07:45:45 <jedai> crazy_coder: You don't want to produce a side effect
07:45:55 <quicksilver> there are other monads which are designed to encapsulate particular styles of effectful programming
07:46:02 <crazy_coder> If I just want to modify a list permanently , how to do it without IO ?
07:46:03 <Toxaris> jedai: but a stack is isomorphic to a list?
07:46:07 <jedai> crazy_coder: If you really want to though you need to return a IO or cheat
07:46:24 <quicksilver> crazy_coder: it is totally impossible to modify a list permanently. You never want to do that :)
07:46:34 <mauke> crazy_coder: you can't modify lists anyway
07:47:24 <crazy_coder> like thats my side effect .. change the list (function takes in a list and gives another) . But I want to actually call the function in a do block
07:47:42 <mauke> that doesn't change the list, it just returns a different list
07:47:50 <mauke> and you can call anything from a do block
07:48:04 <quicksilver> crazy_coder: call it in a do block or not, you still can't (and don't want to) modify the list
07:48:18 <Toxaris> crazy_coder: do {x; y; let newlist = fun oldlist; z }
07:48:19 <jedai> Toxaris: Yes it is, but his functions could add an invariant, for example never get over a certain length (well it isn't a canonical stack anymore but you get my point)
07:48:36 <crazy_coder> Ok
07:49:27 <crazy_coder> Sometimes its a bit complicated. Do requires you to have return type IO x  of every statement, if the last expression is IO () say Right ?
07:49:35 <Toxaris> jedai: ok, if he want an ADT, he could use newtype or data :)
07:49:46 <quicksilver> crazy_coder: do requires every statement to be in the same monad yes
07:49:47 <mauke> crazy_coder: yes
07:50:01 <quicksilver> crazy_coder: I don't think you want 'do' at all, though, for the program you're describing
07:50:05 <mauke> crazy_coder: except not :-)
07:50:18 <mauke> crazy_coder: you can use let statements of any type
07:50:28 <jedai> Toxaris: That was my point, but I think we agree anyway, it was just to say "restricting a type" is a valid need.
07:50:40 <crazy_coder> Then in this case if I have my function x :: [Int]->[Int] and if I call it in a do block without let, I am going to get some errors Right ?
07:51:13 <quicksilver> nope
07:51:15 <quicksilver> yes
07:51:16 <mauke> if that is the whole statement, yes
07:51:17 <quicksilver> sorry that's right
07:51:27 <crazy_coder> No these are the general conceptual problems I face :)
07:51:39 <crazy_coder> Nothing to do with my stack program
07:51:49 <mauke> crazy_coder: it might be easier to learn >>, return and >>= first, just for IO
07:51:53 <jedai> crazy_coder: Yes, but why would you call it without let ? If it hasn't side-effects then without a let or a return it won't serve any purpose anyway ?
07:51:53 <earthy> right. drat.
07:51:57 <quicksilver> each 'statement' in a do block must be in the same monad
07:52:10 <quicksilver> however each 'statement' is, actually, just a haskell expression
07:52:10 <mauke> then 'do' can be explained in terms of >>=
07:52:21 <quicksilver> as such it can contain all kinds of components (sub expressions)
07:52:27 <quicksilver> and there is no such constraint on their type
07:52:31 <crazy_coder> Was not really understanding it, sometimes one has to change the return type of a function to make it fit in the whole scheme of things
07:52:45 <quicksilver> they, simply, must be the right type for the function they're being used in
07:52:46 <mauke> crazy_coder: really?
07:53:32 <crazy_coder> like to incorporate a function , i had to change a functions return type and then that caused errors somewhere else, then i had to fix that too !
07:53:33 <earthy> malcolmw: any chance that simply adding support for the syntax of rank-n polymorphism would allow generation of 'trusted' trace library code?
07:53:53 <mauke> crazy_coder: how did you change the return type?
07:54:02 <earthy> or is there a fundamental problem that makes that A Hard Thing?
07:54:03 <malcolmw> earthy: yes, I think that would be quite a reasonable expectation
07:54:06 <crazy_coder> using return  ;)
07:54:21 <mauke> crazy_coder: no point in changing the original function, then
07:54:23 <crazy_coder> maybe I am doing it wrong
07:54:28 <earthy> magic words, malcolm, magic words. /me dives into hat's sources
07:54:44 <mauke> crazy_coder: you could always say return (f x) when calling it
07:54:48 <Toxaris> jedai: all needs are valid. "If any one of you is without needs, let him be the first to say 'you don't want that'"
07:54:49 <tuxplore1> is there any CMS written in HAppS?
07:54:51 <malcolmw> earthy: most of the type system extensions are purely a matter of leaving them to the underlying compiler, since Hat does not do much with types itself
07:54:53 <mauke> and that shouldn't be very common
07:55:00 * earthy nods
07:55:01 <tuxplore1> or using any other haskell technology?
07:55:01 <Toxaris> jedai: but yes, we agree
07:55:08 <earthy> harlan:/usr/local/src/hat-2.05/src/compiler98 arthurvl$ pwd
07:55:09 <crazy_coder> mauke: ok Thanks
07:55:18 <crazy_coder> mauke: where do you learn all that ?
07:55:32 <malcolmw> earthy: src/compiler98/Syntax.hs
07:55:35 <mauke> crazy_coder: remember, "return" doesn't actually return from a function or anything. it's just a constructor call
07:55:38 <vincenz> dons: ping
07:55:43 <vincenz> @localtime dons 
07:55:44 <lambdabot> Local time for dons is Tue Jul 17 00:54:58 2007
07:55:46 <malcolmw> earthy: and src/compiler98/Parse.hs 
07:55:52 <mauke> crazy_coder: I don't remember. tutorials, trying stuff?
07:56:00 <fberthold> Hi I have libraries question, is anyone aware of a lightweight time library, or a constructor for teh standard CallendarTime type that does not require advanced knowledge of things like "day of week"?
07:56:05 <crazy_coder> mauke: how much time ;)
07:56:08 <earthy> thanks, hacking
07:56:18 <crazy_coder> @localtime crazy_coder
07:56:53 <thoughtpolice> tuxplore1: http://hope.bringert.net/about
07:56:58 <malcolmw> earthy: plus, there will be some plumbing needed to ensure that any new syntax gets all the way through and back out the other side
07:57:21 <malcolmw> earthy: src/compiler98/Pretty.hs is the "other side"
07:57:31 <crazy_coder> @localtime mauke
07:57:32 <jedai> crazy_coder: a week ? a month ? several years ? it depends on what you want to know...
07:57:33 <lambdabot> Local time for mauke is Mon Jul 16 16:56:48 2007
07:58:20 <jedai> crazy_coder: To learn the base of haskell and most of its syntax I didn't need more than a few days, but I had prior experiences
07:58:44 <quicksilver> crazy_coder: would it be helpful to you if I told you that the special function 'return' has nothing at all to do with return types?
07:58:47 <jedai> crazy_coder: and I'm far from mastering Haskell (very very far...)
07:58:48 <tuxplore1> thoughtpolice: Thanks. would check it out
07:58:57 <quicksilver> the two are quite independent
07:59:18 <quicksilver> crazy_coder: I haven't actually seen your code but I have a feeling you're using monads in most of your functions when actually only a very small number really need them
07:59:45 <crazy_coder> jedai: 'and I'm far from mastering Haskell (very very far...)' I don't believe it ;)
08:00:43 <crazy_coder> quicksilver: whenever I start a do block , i convert all functions to monads ;) Not all, some, many ? dont know
08:00:45 <jedai> crazy_coder: You better believe it since I began a few months ago and there's still concept I didn't explore
08:01:05 <crazy_coder> :)
08:01:16 <shapr> jedai: I'm still there after six years.
08:01:27 <quicksilver> crazy_coder: (a) only start a do block because you have genuinely monadic stuff to do
08:01:33 <quicksilver> (b) don't convert any functions
08:01:37 <crazy_coder> Its going to take me years when i'll start helping people on IRC
08:01:37 <edwardk> haskell is crazy huge =)
08:01:41 <shapr> Truly
08:01:47 <quicksilver> just inline the expressions straight into the statements
08:01:49 <quicksilver> or use a let
08:01:55 <shapr> Haskell is the most nifty language I've ever seen!
08:02:04 <quicksilver> crazy_coder: it would be easier to explain if you gave me an example of the kind of conversion you have done
08:02:21 <shapr> crazy_coder: Nah, you'll be able to start helping others very soon, but there's still lots of cool stuff to learn!
08:02:45 <Nafai> Morning!
08:02:50 <jedai> shapr: Yeah, and I expect I'll still be there in a few years too, but I don't even know now the existence of what I'll be trying to understand then (or so I hope)
08:03:27 <crazy_coder> quicksilver: i will show you my code, when i get it working ;)
08:04:22 <shapr> Good morning Nafai!
08:04:27 <Nafai> How are you?
08:04:29 <shapr> jedai: Yeah, there's lots of cool stuff.
08:04:40 <shapr> Nafai: I'm getting paid to code, life is good! What about you?
08:04:42 <quicksilver> the nice thing about shapr is how positive he always is
08:04:46 <quicksilver> shapr++
08:04:49 <quicksilver> (even more so now, I guess)
08:05:04 <Nafai> Getting paid to code, possibly not as fun as yours, but still life is good!
08:05:36 <shapr> quicksilver: I have perspective, I've worked at Subway and various other places.
08:06:31 <Nafai> shapr: I got lambdabot running on my local system this weekend!
08:06:33 <jedai> crazy_coder: Did you read http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html , it's pretty good to understand why monads are simple things after all
08:06:35 <lambdabot> Title: Online Tutorial: What the hell are Monads?, http://tinyurl.com/n8bqd
08:06:52 <crazy_coder> no 
08:06:56 <crazy_coder> let me check
08:07:01 <crazy_coder> jedai: Thanks
08:07:02 <crazy_coder> :)
08:07:34 <crazy_coder> I read many different tutorials, But I hardly read other peoples code
08:07:37 <shapr> Nafai: Cool, any ideas how it could be easier?
08:07:41 <crazy_coder> I think it is cheating :p
08:07:50 <crazy_coder> But I should learn to do it
08:08:13 <sjanssen> @yow!
08:08:13 <lambdabot> UH-OH!!  I think KEN is OVER-DUE on his R.V. PAYMENTS and HE'S having a
08:08:13 <lambdabot> NERVOUS BREAKDOWN too!!  Ha ha.
08:08:31 <mauke> @quote
08:08:31 <lambdabot> AdamPeacock says: Once I looked at the source code, 25000 lines of ASP, I reckoned it would be easier to rewrite it in a real language.
08:09:09 <crazy_coder> I actually find it boring too , to read other peoples code....
08:09:10 <sjanssen> that'd a good one
08:09:18 <crazy_coder> Maybe I am talking bullshit
08:09:28 <crazy_coder> I need some coffee
08:10:37 <dozer> Ive gone 3 weeks now without drinking coke while coding!!!
08:11:00 <mauke> dude, you should go to sleep immediately!!
08:11:33 <crazy_coder> mauke: me ?
08:11:47 <mauke> no, dozer
08:12:03 <_Nucleo> @src fromJust
08:12:03 <lambdabot> fromJust Nothing  = undefined
08:12:03 <lambdabot> fromJust (Just x) = x
08:12:06 <crazy_coder> heh :) Same for me 
08:13:46 <crazy_coder> btw, is the tuple idea to return for than two things, actually a concept of state transformation ?
08:14:10 <dozer> mauke: It hurt for the first week - I had no idea a litre of sugar, phosphoric acid and caffeene could have hooked my body like that
08:14:19 <crazy_coder> *return two or more things
08:14:39 <mauke> @src State
08:14:40 <lambdabot> Source not found. stty: unknown mode: doofus
08:14:59 <mauke> blargh
08:15:17 <mauke> transform :: state -> (x, state)
08:16:20 <vincenz> mauke: stateT
08:17:51 <crazy_coder> Anyways, thanks everyone mauke, quicksilver, jedai, shapr
08:19:09 * earthy has obviously gotten spoiled by parser combinator libraries
08:19:36 <earthy> damn. that parser in hat is not easy to read. :)
08:20:05 <malcolmw> earthy: it _is_ written using combinators :-)
08:20:13 <earthy> malcolmw: I know. :)
08:20:20 <wli> I wonder if there are parser combinator libraries that build up state machines from combinatory expressions.
08:20:22 <earthy> but the combinators are not the combinators I'm used to. :)
08:20:34 <earthy> so I've gotten spoiled by the libraries I'm used to :)
08:20:57 <earthy> at least it's a reasonably clear continuation-base combinator lib :)
08:21:00 <earthy> +d
08:21:05 * malcolmw wants to rewrite the parser using polyparse combinators at some point
08:21:19 <wli> malcomw: What are polyparse combinators?
08:21:45 <malcolmw> earthy: the Hat parser combinators are acutally monadic, believe it or not
08:22:11 <malcolmw> wli:  http://www.cs.york.ac.uk/cs/fp/polyparse
08:22:27 <shapr> malcolmw: Ever tried the http://www.cs.helsinki.fi/u/ekarttun/PArrows/ ?
08:22:29 <lambdabot> Title: PArrows
08:22:37 <wli> malcomw: 404
08:22:41 <quicksilver> the thing about combinator libraries is that they are, of course, new languages
08:22:51 <malcolmw> wli: correction, http://www.cs.york.ac.uk/fp/polyparse
08:22:52 <lambdabot> Title: polyparse: alternative parser combinator libraries
08:22:53 <quicksilver> OK, they're quite small languages in the grand scheme of things
08:23:04 <quicksilver> but still, they need 'learning'
08:23:14 <earthy> malcolmw: I'd already gathered that much
08:23:19 <earthy> with `into` being >>=
08:23:24 <quicksilver> until you learn them, they look a bit mystifying, especially if you're used to a similar one which uses a different form
08:23:49 <quicksilver> c.f. the difference between Parsec/ReadP/polyparse
08:24:22 <wli> malcolmw: The haddock is a bit sparse.
08:24:49 <earthy> but hell, learning a new parser combinator lib in what, 25 minutes, with no docs but source is not trivial
08:25:03 <quicksilver> earthy: agreed
08:25:16 <quicksilver> earthy: although plenty of examples would help
08:25:27 <earthy> well, the only example is a parser for haskell. :P
08:25:37 <earthy> at least I've got a clear view by now :)
08:25:50 <sjanssen> the combinator is monadic but not 'instance Monad'?
08:25:58 <earthy> parseAp =~= <$>
08:26:05 <sjanssen> s/combinator/combinator library
08:26:08 <malcolmw> wli: polyparse kind of assumes you are familiar with hutton-meijer-style combinators I'm afriad
08:26:09 <earthy> parseChk =~= $>
08:26:10 <wli> type Parser = String -> [(Tree, String)] hmm. Shouldn't that be a DAG vs. a tree?
08:26:15 <earthy> oh, no, <$
08:26:18 <earthy> and so on and so forth
08:26:25 <SamB> malcolmw: a strange assumption indeed
08:26:56 <SamB> why, dons isn't even familiar with Parsec!
08:27:16 <malcolmw> SamB: I don't see the point in replicating the best monadic parsing tutorial in the world...
08:27:42 <SamB> malcolmw: maybe you should instead link to it?
08:27:47 <malcolmw> but I do agree more documentation is needed.
08:28:17 <malcolmw> SamB: there is a link to it?
08:28:19 <SamB> with a more attractive link text
08:28:21 <SamB> perhaps
08:28:31 <SamB> NOTTCS-TR-96-4 isn't very attractive ;-)
08:29:55 <earthy> gotcha.!
08:30:00 * wli barfs on left factoring.
08:30:10 <earthy> the forall parser needs to move to the parseContext rule
08:30:50 <earthy> but that's for tomorrow
08:30:59 <earthy> now to make dinner for the girl
08:34:12 <SamB> malcolmw: btw, have you seen my parsely library?
08:34:32 <wli> SamB: I want to see it.
08:34:39 <SamB> @hackage parsely
08:34:40 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parsely
08:34:51 * earthy wonders why chk is not implemented as   chk x = parse const `ap` x `ap`
08:35:06 * earthy wonders why chk is not implemented as   chk x y = parse const `ap` x `ap` y
08:35:10 <earthy> that is
08:36:11 <malcolmw> earthy: probably something to do with precedence of operators
08:36:15 <earthy> interesting.
08:36:36 <earthy> parsers do seem to suffer from NIH-syndrome a bit in haskell. :)
08:36:51 <cedricshock> Can libraries provide Deriving things for Classes?
08:37:17 <SamB> cedricshock: no. maybe ten or twenty years from now they will be able to...
08:37:53 <cedricshock> SamB: Aww. I hate when the language gets to do something I don't.
08:38:41 <SamB> cedricshock: also, probably if that ever happens the "deriving" syntax will work a bit differently -- i.e. there will most likely be a way to say which of several derivings you want to use.
08:39:39 <SamB> cedricshock: I don't think there is anyone who specifically doesn't want something like what you describe
08:40:37 * wli wonders if it'd be possible to shoehorn the happy-GLR back-end behind Hutton-Meijer combinators.
08:40:50 <SamB> wli: what the heck?
08:41:07 <mrd> what about Drift and Data.Derive?
08:41:45 <wli> SamB: Have the parsers build up a GLR state machine etc. instead of whatever LL(1) stuff they now use.
08:42:47 <SamB> hey, malcolmw, HuttonMeijerWallace doesn't seem to have a State Transformer in it... besides which, oughtn't that to be an implementation detail?
08:43:15 <malcolmw> SamB: HMW predates monad transformers
08:43:37 <cedricshock> SamB: That'd be nice to. The derivations I want are pretty much just functions from types to code for functions...
08:44:02 <SamB> malcolmw: oh, you mean that meant something else back then?
08:44:52 <malcolmw> SamB: a state transformer is a function (s->s) for some state s, that is all
08:44:56 <wli> I think it should be possible to do something on the order of building up a grammar from combinators and then doing all the standard parser generator state machine crud "on the fly" (more likely via partial evaluation).
08:44:59 <SamB> malcolmw: oh.
08:45:20 <malcolmw> then there is the State Transformer monad (the ST monad)
08:45:36 <malcolmw> and finally, the StateT monad transformer
08:45:46 <malcolmw> which is different again :-)
08:45:57 <SamB> malcolmw: perhaps you should change the module description to be less confusing?
08:47:10 <malcolmw> SamB: perhaps I cold
08:47:21 <malcolmw> s/cold/could
08:47:36 <SamB> malcolmw: are you sure HuttonMeijerWallace predates monad transformers?
08:47:46 <wli> malcolmw: I get the impression that what the parser combinator libraries end up constructing is typically recursive descent.
08:48:10 <SamB> because I see something suspiciously like StateT and ReaderT here...
08:48:15 <malcolmw> wli: exactly so
08:48:34 <SamB> though for some reason they're called StateM and ReaderM...
08:49:25 <wli> malcolmw: Does it make sense to think about building up a grammar and doing the sort of state machine machinations that parser generators like happy/etc. more typically do?
08:49:27 <malcolmw> SamB: when did the mtl first appear?
08:50:02 <malcolmw> wli: I believe that's what the Utrecht parser combinators do
08:50:15 <wli> malcolmw: Very interesting. Googling.
08:50:30 <quicksilver> wli: I did on-the-fly-parser generation, almost combinator like, in lua
08:50:54 <quicksilver> wli: I used an array of arrays to model the grammar (inner level - concatenation, outer-level alternation)
08:51:10 <quicksilver> wli: and then did factoring and left-recursion elimination
08:51:18 <quicksilver> and, I think, first-token shortcut table generation
08:52:30 <SamB> malcolmw: well, the paper it was inspired by is from 1995
08:52:47 <wli> "The basic parsing technique used follows closely the conventional recursive descent, top-down parsing method."
08:53:19 <wli> "Caveat: All parsers must correspond to non-left recursive grammars."
08:53:32 <malcolmw> SamB: and the Hutton Meijer combinators date from 1994, but that tells us nothing.
08:53:50 <wli> malcolmw: Are you sure it was the Utrecht parser combinators?
08:53:55 <SamB> malcolmw: this paper you linked too is for 1996
08:54:07 <SamB> and I see in it what look like monad transformers to me
08:54:20 <malcolmw> SamB: it took them a while to get it published
08:54:20 <cedricshock> I'm interested in making a derived or template library that does something like darcs on many haskell data types. Anyone know of existing things I should look at, other than darcs itself?
08:54:22 <SamB> er. s/too/to/.
08:54:26 <wli> That was from http://www.cs.uu.nl/groups/ST/Software/UU_Parsing/Run-OnlyPC.pdf
08:54:50 <quicksilver> cedricshock: calculation of 'diffs' and the ability to mix and match versions?
08:54:53 <malcolmw> wli: no, I'm not certain. just a vague recollection
08:54:56 <quicksilver> cedricshock: that is very interesting
08:55:02 <quicksilver> cedricshock: I'm not aware of anything personally
08:55:23 <wli> malcolmw: Okay, so it makes sense and has been done before, we're just not entirely sure when.
08:55:30 <wli> Or by whom.
08:55:35 <malcolmw> wli: in the same way that I recall manuel chakravarty having self-optimising lexer combinators, in the same vein
08:56:04 <quicksilver> many people end up not using their parsers in speed-critical situations
08:56:13 <quicksilver> especially with the speed of today's machines
08:56:32 <malcolmw> wli: table-driven parsing is not necessarily faster than other techniques anyway
08:56:33 <quicksilver> so parser performance isn't a priority (for many people)
08:56:44 <quicksilver> of course, when it is, it is
08:56:47 <quicksilver> to state the obvious
08:56:49 <cedricshock> quicksilver: I'd love to be able to do it on types or tuples by field, union types (full replacement), and some of the Data library type things, like lists and sets. This would be the basis for a user interface paradigm.
08:56:52 <malcolmw> SamB:
08:56:59 <wli> malcolmw: Oh, I'm not interested in performance, but expressiveness. I don't really want to left factor grammars.
08:57:01 <quicksilver> cedricshock: yes, that would be lovely
08:57:04 <quicksilver> cedricshock: I'm not aware of that
08:57:15 <quicksilver> cedricshock: I wrote something recently for a perl application, along those lines
08:57:20 <wli> malcolmw: I'd be just as happy with Earley or CYK as GLR.
08:57:21 <quicksilver> cedricshock: diff for nested maps, basically
08:57:28 <quicksilver> cedricshock: turns out to be quite subtle :)
08:57:35 <SamB> malcolmw: how very interesting
08:58:00 <wli> er, s/malcolmw/quicksilver/
08:58:10 <quicksilver> :)
08:58:20 <quicksilver> SamB: what bit was interesting?
08:58:36 <SamB> quicksilver: the part where he said my name with nothing after it ;-)
08:58:49 <wli> quicksilver: As table-driven parsers go, things like Earley, CYK, and GLR are dogslow vs. LALR(1) etc.
08:58:51 <quicksilver> SamB: ah ;)
08:58:54 <malcolmw> SamB: oops, mistyped
08:59:25 <wli> quicksilver: We're talking asymptotically inequivalent even, O(n^3) worst-case.
08:59:38 <malcolmw> SamB: in any case, the concept of monad transformers has only really gained traction in the last two years, AFAICT
08:59:44 <cedricshock> quicksilver: I'm perfectly willing to write it... I think many of the simpler patch types can achieve orthogonality over nested structures, but some of the more interesting operations (like updating everything element in a set) could be a mess.
09:00:14 <quicksilver> wli: yes, yes
09:00:21 <quicksilver> wli: I had actual, real performance issues
09:00:25 <quicksilver> wli: that's what drove me to do it
09:00:32 <quicksilver> wli: I didn't do it for the kicks :)
09:00:41 <quicksilver> wli: I was doing incremental parsing after every keypress, in a LUA shell
09:00:50 <quicksilver> in order to do syntax colouring and auto-complete
09:00:57 <quicksilver> (context-sensitive auto-complete)
09:01:03 <malcolmw> SamB: and I extended HM to HMW back in 1999, in the days when everyone rolled their own monad, rather than composing them from smaller monads
09:01:15 <quicksilver> the table-factoring made it feasible, with naive rec descent it was not viable
09:02:18 <wli> quicksilver: I don't have any essential use for Haskell. It could be exchanged for any of a number of scripting languages where I use it for any essential task.
09:02:45 <SamB> malcolmw: apparantly Hutton and Meijer were not aware of this back in 1996
09:03:52 <malcolmw> SamB: back then, it was widely recognised that monads were not composable, and that this was a problem yet to be solved adequately
09:04:03 <wli> quicksilver: The hope for GLR/etc. is that I can use them on super dirty nasty ultra-ambiguous languages where I throw out possibilities via higher-level semantics.
09:04:08 <SamB> malcolmw: that doesn't seem to have stopped them...
09:04:17 <SamB> perhaps they were not well-enough read to know that ;-)
09:06:02 <quicksilver> It's still not clear to me that monad transformers are very magical
09:06:15 <SamB> quicksilver: they aren't magical
09:06:19 <SamB> they're merely convenient
09:06:19 <quicksilver> well I know
09:06:22 <quicksilver> poor choice of words
09:06:25 <wli> I'm starting to get the idea behind monads.
09:06:32 <quicksilver> it's not even clear to me that they are all *that* convenient
09:06:39 <quicksilver> the best part is the MonadFoo instances
09:06:42 <quicksilver> now *those* are useful
09:06:48 <SamB> yeah.
09:06:50 <quicksilver> dispensed with all that nasty lifting crap
09:06:54 <SamB> that's the convenient part...
09:07:06 <wli> How about arrows?
09:07:14 <SamB> wli: how about them/
09:07:23 <SamB> s|/|?|
09:07:46 <shapr> Arrows are more general than monads, but lots more trouble to use.
09:07:57 <SamB> that pretty much sums it up ;-)
09:08:53 <wli> shapr: The automaton arrows look very interesting to me.
09:08:54 <shapr> Arrow advantages can be powerful, but you lose those advantages when you need to lift normal functions into an arrow. Arrows only stay powerful when you use them only with other arrows.
09:09:00 * SamB wants a ProtoArrow class, with no arr/pure method...
09:09:46 <tuukkah> tanuk, in case you still need to set line buffering, here's a script using gdb: http://tuukka.iki.fi/tmp/linebuf
09:10:13 <shapr> wli: It's worth learning.
09:10:13 <wli> shapr: Well, suppose one has parsing automata and wants to compose them...
09:10:39 <quicksilver> SamB: that's interesting
09:10:45 <quicksilver> SamB: I *think* that's what I want, too
09:11:08 <quicksilver> SamB: were you around the other day when I was musing about eDSLs for code generation?
09:11:11 <shapr> wli: Parsing was the original motivation for arrows. Arrow-style parsers can short-circuit, monads must either succeed or fail.
09:11:14 <SamB> I'm not sure what would happen if you tried to use it for anything useful though
09:11:16 <Philippa> SamB: YA me a few years ago AICM5UKP
09:11:19 <jfincher> I've got a non-haskell-related question that I can't think of a better place to ask, where more knowledgeable language-oriented people hang out and discuss things :)
09:11:28 <SamB> quicksilver: probably not
09:11:42 <SamB> Philippa: huh?
09:11:44 <int-e> SamB: hmm. but then you'll need extra functions for all the useful isomorphisms between objects (like (A + B) x C = A x C + B x C)
09:11:59 <wli> shapr: Interesting. What were the Arrow-based parsersdoing?
09:12:03 <SamB> Philippa: is that a game genie code?
09:12:14 <quicksilver> SamB: I want an 'm' such that 'm a' means "generate bytecode which calculates a result of type a'
09:12:28 <int-e> SamB: in particular desugaring arrow notation will be much harder.
09:12:43 <SamB> int-e: so?
09:12:44 <quicksilver> SamB: but that definitely isn't an arrow, because I can't turn an arbitrary haskell function (a->b) into one of these
09:12:48 <Philippa> SamB: "You Are ... And I Claim My Five Pounds"
09:13:07 <SamB> Philippa: I haven't got any pounds
09:13:09 <quicksilver> SamB: but that implies I can 'unpick' my haskell function and turn it into bytecode
09:13:15 <quicksilver> SamB: which I certainly can't do
09:13:28 <jfincher> It seems self-evident to me that given a string of symbols connected according to some grammar, that more than one semantics for the language consisting of that sentence can be defined.  Does anyone know of any papers/etc. that might relate to that idea?
09:13:36 <SyntaxNinja> y0
09:13:47 <SamB> quicksilver: simililarly, you can't reverse the direction of a function, which a biarrow would need to be able to do...
09:13:58 <quicksilver> SamB: yes, agreed
09:14:06 <Philippa> jfincher: lisp?
09:14:08 <int-e> SamB: it'd be nice to have an ArrowProto class but it wouldn't make arrows easier to use; it'd make it harder.
09:14:14 <jfincher> Philippa: any language
09:14:15 <Philippa> as in, the entire community?
09:14:36 <SamB> int-e: it ought to make them useful for more things though...
09:14:36 <quicksilver> SamB: I think I want: Code a b meaning a recipe for generating Code which expects values of type a {on the stack/in predetermined registers}
09:14:38 <Philippa> basically, it's trivial - any interpretation is a valid one
09:14:49 <Philippa> you might find reading up on abstract interpretation interesting though
09:14:52 <quicksilver> SamB: and then you can obviously write compose :: Code a b -> Code b c -> Code a c
09:15:19 <shapr> wli: The only way to see if a monadic parser will succeed or fail is to execute it. Arrow-style parsers can hold static properties, so you can factor out common traversals, and/or short circuit around things that will not be parsed.
09:15:22 <quicksilver> SamB: and, furthermore, you might hope to be able to write an 'optimising' version of the compose function
09:15:29 <quicksilver> SamB: which can eliminate unused registers,e tc
09:15:48 <int-e> SamB: yes, I'd have an application for that actually: invertible computations. (they come with an operation invert :: (b ~> c) -> (c ~> b) and have pure :: (b -> c) -> (c -> b) -> (b ~> c)
09:16:03 <SamB> int-e: yeah, that's what I meant by "biarrows"
09:16:07 <int-e> ah
09:16:18 <quicksilver> int-e: my version would come with some 'axioms' :: b ~> c
09:16:25 <quicksilver> int-e: but nothing like 'pure' at all
09:16:43 <quicksilver> perhaps you'd have 'CodePlus' :: Int ~> Int
09:16:44 <int-e> quicksilver: I used pure mostly to define the axioms (as helper functions)
09:16:47 * quicksilver nods
09:16:50 <shapr> wli: In monadic form string "one" <|> string "two" <|> string "three" must go through every alternative before it can fail, and it checks twice whether the string starts with (char 't').
09:17:06 <quicksilver> or mayb you wouldn't use Int, maybe you'd use QSInt
09:17:13 <quicksilver> I'm not sure if I want different types or not
09:17:32 <wli> sapr: Yeah, that doesn't sound so good.
09:17:38 <SamB> quicksilver: perhaps CInt ;-)
09:17:44 <quicksilver> SamB: well yes, perhaps
09:17:52 <wli> shapr: Sounds awesome. Where do I pick up these arrow parsers?
09:18:14 <shapr> wli: http://www.cs.helsinki.fi/u/ekarttun/PArrows/
09:18:16 <lambdabot> Title: PArrows
09:18:19 <SyntaxNinja> I uploaded darcs to debian yesterday. folks should try it out and let me know of any problems.
09:18:34 <wli> shapr: Ultraspiffitude.
09:21:20 <olsner> it'd be awesome to make a [GS]?(LA)?LR(\([0-9]+\))? parser generator working with parser combinators
09:21:44 <malcolmw> SyntaxNinja: the wanderer returns!
09:21:46 <wli> olsner: GLR interests me most.
09:22:07 <wli> olsner: There's a GLR variant of happy.
09:22:26 <vincenz> GLR is the only way forward
09:22:29 <shapr> y0 SyntaxNinja!
09:22:32 <olsner> if the framework is there, it should be easy to generate all kinds of parser from a single specification
09:22:35 <vincenz> though I admit I haven't played with GLR of happy yet
09:22:37 <psykotic> wli: the original paper on arrows basically just computes FIRST sets and combines them, in parallel to the usual composition of parsing functions.
09:22:42 <ski> wli : istr an hughes arrow paper mentioned an arrow(izable ?) parser library .. someone and duponschel or something
09:22:46 <wli> olsner: So basically get parser combinators to build up enough crap to feed to whatever the engine behind that is and blow the doors off them.
09:22:54 <psykotic> wli: so the FIRST sets function as a static approximation to the dynamic behavior of the parsing functions.
09:23:01 <wli> ski: shapr pointed me at it.
09:23:03 <SyntaxNinja> heya malcolmw, sha
09:23:05 <SyntaxNinja> shapr: 
09:23:12 <ski> wli : no, not that one
09:23:13 <SyntaxNinja> I climbed a mountain the other day. it was high.
09:23:20 <SyntaxNinja> but not that high for a mountain
09:23:20 <shapr> ski: Swierstra & Duponcheel
09:23:22 <wli> ski: Oh, interesting then.
09:23:26 <ski> shapr : ty
09:23:30 * SyntaxNinja will climb St. Helens next week.
09:23:36 <wli> psykotic: I think nondeterminism + LR(1) suffices.
09:23:36 <malcolmw> SyntaxNinja: got my PM?
09:23:42 <wli> psykotic: I think nondeterminism + LR(1) == GLR.
09:23:59 <ski> SyntaxNinja : into the caldera ?
09:23:59 <psykotic> wli: you don't even need LR(1). i think you can do LR(0).
09:24:18 <psykotic> wli: since the nondeterminism makes lookahead needless (efficiency aside).
09:24:26 <wli> psykotic: I'm not sure. I think you need LR(1) so the deterministic cases work.
09:24:48 <SyntaxNinja> ski: to the edge.
09:24:52 <wli> psykotic: Never mind. You're right, though I suspect LR(1) is used anyway.
09:25:03 <psykotic> right, it would be silly not to.
09:25:20 * ski has no idea if there's still any activity there ..
09:25:38 <psykotic> last time i implemented GLR i used LR(0) though, since it's a good deal simpler conceptually and in implementation.
09:25:41 <wli> psykotic: The tricky part of GLR is of course the resulting expression DAG.
09:25:52 <ski> SyntaxNinja : bring back pics ! :)
09:26:13 <psykotic> wli: i don't think it's very tricky, is it? it's just dynamic programming/memoization.
09:26:21 <wli> psykotic: I don't think the LR(1) vs. LR(0) bits are where one feels the pain in GLR, but anyway.
09:26:25 <ski> 'GLR' ?
09:26:29 <psykotic> generalized LR
09:26:42 <wli> psykotic: Maybe you're right.
09:26:58 <psykotic> it essentially just covers the technique of "resolving" conflicts in the LR tables by exploring alternatives in parallel, and sharing structure and parse results using dynamic programming.
09:27:26 <wli> psykotic: The same principle as CYK and Earley, except applied to LR parsers instead of chart parsers.
09:27:42 * ski recalls a breadth-first parse monad claessen showed
09:27:45 <olsner> the devil's in the details as usual... I think the trouble with GLR parsers in practice is the number of potential parses you may have to keep track of
09:27:52 <psykotic> well, in that those things are dynamic programming, but it's bottom up rather than top down (unlike CYK and earley).
09:28:17 <wli> olsner: That's where the dynamic programming and representing the result as a multirooted DAG comes in.
09:28:30 <wli> olsner: Common sub-parses are all shared in the DAG.
09:28:43 <psykotic> a simple implementation isn't very tricky at all. it really is a textbook application of DP.
09:28:44 <tanuk> tuukkah: Thanks. Unfortunately I'm having problems with using the script. Could you provide a quick how-to?
09:29:07 <edwardk> @seen mnislaih
09:29:07 <lambdabot> mnislaih is in #haskell and #ghc. I last heard mnislaih speak 33m 12s ago.
09:29:10 <wli> psykotic: Where does it get complicated?
09:29:22 <psykotic> it doesn't, in a simple implementation.
09:29:37 <wli> psykotic: Where do implementations get un-simple?
09:29:44 <vincenz> why do you need dynamic programming?
09:29:53 <vincenz> you just (lazily) duplicate your stack
09:29:54 <psykotic> vincenz, to prevent exponential explosion.
09:30:08 <psykotic> basically the divergent parses can reconverge
09:30:14 <mnislaih> hi edwardk 
09:30:15 <psykotic> and you don't want them to duplicate work from that point on
09:30:19 <vincenz> ah
09:30:23 <wli> vincenz: The parser's results can be huge. You have to share ultra-aggressively between different possible parse trees.
09:30:26 <edwardk> heya mnislaih. neat stuff
09:30:26 <vincenz> yeah, that's when you re-unify your stacks
09:30:36 <vincenz> psykotic: looked at elkhound?
09:30:37 <psykotic> well, that's what DP is here.
09:30:52 <vincenz> they do it both in O'Caml and C++
09:31:04 <vincenz> (they have a c++ parser using the c++ code generated from the GLR-framework elkhound)
09:31:14 <wli> vincenz: This would be constructed on the fly by parser combinators, not a parser generator.
09:31:34 <vincenz> wli: oic
09:31:36 <vincenz> wli: why?
09:31:42 <psykotic> wli: as for complexities, i haven't looked at "serious implementations" like elkhound in detail, but i imagine it's the same thing that afflits all "serious implementations": they want to squeeze out as much performance as possible, so they apply every trick in the book.
09:31:50 <vincenz> "on the fly" and "parser-generator" barely differ
09:31:50 <tuukkah> tanuk, for example: linebuf sed "s/foo/bar/g" | linebuf sed "s/baz/blum/g"
09:31:51 <wli> vincenz: Since no one gives a damn how fast their parsers run it would make more sense to be as general as possible.
09:32:10 <vincenz> the only difference is that one has a 'language' while the other has a set of 'combinators', again the distinction is subtl
09:33:10 <wli> vincenz: Yeah, that's why ripping the front and back ends off happy-GLR (http://www.dur.ac.uk/p.c.callaghan/happy-glr/) and shoving it under the hood of some parsing combinators sounds good to me.
09:33:12 <lambdabot> Title: GLR parsing with Happy
09:33:22 <vincenz> wli: sounds like a good idea :)
09:33:27 <vincenz> wli: though I admit I rather like happy
09:33:38 <wli> vincenz: As general as possible wrt. grammars handled, that is.
09:33:40 <vincenz> wli: (especially cause it does -not- deal with lexers)
09:34:19 <vincenz> wli: btw, if you plan on doing that, something that would be useful is a combinator-generator
09:34:31 <vincenz> wli: that would take the input that the frontend of happy takes and produces the code that uses the combinato
09:35:25 <psi> i'm getting: 'Symbol's function definition is void: inferior-haskell-load-file' when i go C-c C-l in a haskell-mode buffer.
09:35:50 <psi> any clues? i'm using carbon emacs.
09:35:59 <wli> vincenz: I'm not sure what you mean there.
09:36:01 <quicksilver> psi: you haven't got inf-haskell loaded
09:36:18 <wli> vincenz: Anyway I think I found a "project" to learn stuff.
09:36:39 <vincenz> wli: well currently happy is a parser-generator, so it takes some nput file (which is close to std yacc stuff).  It'd be good that if you moved to combinator to have something that generates the combinator code from the nput that would be used by the parser-generator
09:36:45 <psi> quicksilver: woops, I forgot to add the load to my .emacs.
09:36:53 <quicksilver> I use this: (autoload 'run-haskell "inf-haskell" "Run interactive haskell interpreter." t)
09:37:06 <quicksilver> I think I still have to remmber to do a run-haskell myself, thouh
09:39:31 <wli> vincenz: I'll see what I can do about generating parsers on the fly using it.
09:40:44 <psi> quicksilver: thanks
09:42:58 <tanuk> tuukkah: The problem is that the data source doesn't use line buffering. I tried to change CMDPID=$$ to CMDPID=`pidof aseqdump`, and then running in one terminal "aseqdump -p 20:0 | Sysextract" and in another "./linebuf", that didn't work. aseqdump exits without a message.
09:43:06 <psi> quicksilver: here's what i came up with: (add-hook 'haskell-mode-hook (lambda () (load "inf-haskell")))
09:43:06 <wli> vincenz: I've got a bad feeling it just slings around Haskell code as strings.
09:43:15 <psi> quicksilver: you don't have to do it manually then.
09:45:39 <quicksilver> psi: yeah, that works too
09:46:38 <tuukkah> tanuk, if Sysextract is your unbuffered haskell application, this could work: ./linebuf aseqdump -p 20:0 | Sysextract
09:48:47 <tanuk> tuukkah: It doesn't work, because CMDPID doesn't get any value.
09:51:59 <tuukkah> in bash, $$ should be the pid of the current shell
09:53:59 <tanuk> tuukkah: Yeah, but it's aseqdump's pid that we're interested in, if I understand correctly. The script could maybe work this way: first it starts the program (aseqdump) in a separate thread, takes it's pid, then does the gdb magic and then attaches to the program's thread. I don't know how to do this.
09:54:42 <tuukkah> tanuk, as aseqdump is started using exec, it gets the same pid as the shell had
09:55:20 <tuukkah> on your machine, doesn't it work even with my sed example?
09:56:06 <tanuk> tuukkah: The sed example works, but I think that's because the input comes from the shell, therefore CMDPID is assigned the right pid.
09:57:19 <tuukkah> if you think that, you can test by adding a third sed in the middle which doesn't receive input from nor produce output for a shell
09:58:38 <tuukkah> but anyway, if it doesn't work then it doesn't work and you need some other hack :-( 
10:00:28 <tanuk> tuukkah: The ./linebuf aseqdump -p 20:0  | Sysextract
10:00:47 <tanuk> line exits after a couple of seconds.
10:01:38 <tanuk> I'll modify aseqdump.
10:02:45 <SimonRC> why aren't fudgets based on arrows?
10:02:49 <tanuk> tuukkah: Thanks for your efforts anyway.
10:02:56 <ddarius> SimonRC: Because it was made way way before arrows.
10:02:56 * EvilTerran notes that "let ... = ... in ..." is slightly longer than "| ... <- ... ="
10:03:13 <tuukkah> tanuk, nevermind, the gdb script was something i wanted to test some time :-)
10:03:26 <EvilTerran> (terseness FTW!)
10:03:38 <monochrom> EvilTerran: they also behave different.
10:03:47 <ski> SimonRC : probably because the former were invented before the latter
10:03:59 <SimonRC> ddarius: I can see that arrows my help; the fudget law feels "wrong" to me
10:04:28 <EvilTerran> monochrom, i know pattern guards cause fallthough on pattern match failure, but is there any difference in the case when the thing you're matching against only has one constructor?
10:04:59 <EvilTerran> ("foo x = let (y,z) = bar x in ..." versus "foo x | (y,z) <- bar x = ...")
10:05:29 <monochrom> > let (y,z) = undefined in "hey"
10:05:31 <lambdabot>  "hey"
10:05:40 <monochrom> That shows the difference.
10:06:10 <ddarius> ~(y,z)
10:06:12 <EvilTerran> ah. let doesn't HNF the things being bound
10:06:29 <quicksilver> WHNF
10:06:34 <EvilTerran> yes, that one.
10:06:37 <quicksilver> but it's a bit more than that
10:06:39 <EvilTerran> @where WHNF
10:06:40 <lambdabot> I know nothing about whnf.
10:06:44 <quicksilver> a let binding doesn't just WHNF
10:06:52 <quicksilver> a let binding reduces it 'as much as it needed to bind'
10:06:58 <quicksilver> so let ((x,y),z) = ...
10:06:59 <monochrom> Somehow WHNF feels like a swear word to me, up there with WTF and RTFM :)
10:07:12 <quicksilver> is going a bit beyond WHNF, because it forces the constructor inside the left side
10:07:17 <quicksilver> erm sorry
10:07:20 <EvilTerran> yes, i thought of that just after i said it.
10:07:22 <quicksilver> pattern binding I meant of course
10:07:30 <EvilTerran> but let _doesn't_, pattern binding _does_
10:07:33 <quicksilver> right :)
10:07:46 <EvilTerran> because control flow doesn't depend on a let binding successfully, it doesn't try
10:07:54 <therp> isn't let lazy per default?
10:08:06 <quicksilver> therp: yes
10:08:09 <ddarius> therp: It's an irrefutable binding, yes.
10:08:10 <quicksilver> therp: what I said was wrong
10:08:11 <EvilTerran> therp, that's what we just concluded
10:08:18 <monochrom> Control.Monad.State.Lazy and Control.Monad.State.Strict exploit the difference. The former uses let, the later uses case.
10:08:28 <therp> ah sorry /me should read the whole discussion before dropping comments
10:08:35 <EvilTerran> so "foo x = let (y,z) = bar x in ..." is like "foo x | ~(y,z) <- bar x = ..."?
10:08:44 <monochrom> Yeah.
10:08:53 <quicksilver> modulo the difference about falling through
10:09:03 <quicksilver> ah, no, I'm wrong again
10:09:05 <quicksilver> damn I'm on form
10:09:09 <monochrom> Hehehehe
10:09:12 <quicksilver> a ~ <- binding can't fall through :)
10:09:14 <quicksilver> it's irrefutable
10:09:23 <EvilTerran> but if the expression is strict in y or z, there's no difference anyway, right?
10:09:42 <monochrom> I agree with that one.
10:09:47 <EvilTerran> with or without twiddles
10:10:06 <ddarius> tilde takes less typing
10:10:21 <EvilTerran> "foo (x,y) = x+y" is effectively indistinguishable from "foo ~(x,y) = x+y", i mean
10:10:48 <Igloo> For Int etc, yes, but not necessarily for types you define yourself
10:10:51 <monochrom> Heh pattern guard still more compact :)
10:11:12 <ddarius> Hmm... is foo !(~(Just x)) = 5 valid?
10:11:22 <Igloo> Yes
10:11:28 <ddarius> What happens?
10:11:30 <mauke> does it semant?
10:11:31 <Igloo> There was a discussion on the mailing list about what it means recently
10:11:48 * Igloo can't remember the answer OTTOMH
10:12:47 <ddarius> GHC must have fun with things like ~(x,!y)
10:14:03 <monochrom> > let ~(x,!y) = (5, undefined) in x
10:14:03 <lambdabot>  Parse error
10:14:36 <monochrom> > let f ~(x,!y) = x in f (5, undefined)
10:14:36 <lambdabot>  Parse error
10:14:45 <monochrom> It not know bangs?
10:14:54 <sjanssen> monochrom: correct
10:15:11 <monochrom> Anyway, that example shows what happens.
10:15:33 <ddarius> There is a fairly "obvious" thing that should happen in all of these cases.
10:15:42 <quicksilver> I would expect the semantics to be 'whenever the tuple gets forced at all, y gets forced'
10:15:43 <ddarius> I'm not sure if there are "unobvious" cases.
10:15:56 <quicksilver> but the tuple itself doesn't get forced immediately cos its irrefutable
10:15:59 <quicksilver> is that right?
10:16:10 <mauke> seems like it
10:16:48 <edwardk> gah, i wish there was a way to say that Foo m is a class iff Bar m a is defined forall a. class Bar m a => Foo m complains about the absence of a in the type, and I can't make instance Foo m => Bar m a without tagging m with a way to keep me from being able to implement Bar m a in other ways.
10:17:12 <quicksilver> I would expect (a,(b,!c)) to mean that c gets forced (only) when the inner tuple which directly contains c gets forced
10:17:20 <edwardk> er s/keep me from/keep me so I can/
10:17:36 <ddarius> Use those type level predicates?
10:17:56 <edwardk> ddarius: the Fc things?
10:19:43 <_Nucleo> @src elem
10:19:43 <lambdabot> elem x    =  any (== x)
10:19:51 <_Nucleo> @src any
10:19:51 <lambdabot> any p =  or . map p
10:20:24 <wli> vincenz: Hmm. Looks like Alex is nasty enough I'm better off rolling my own.
10:20:37 <wli> vincez: s/alex/happy/
10:20:50 <wli> It's Monday. I'm jacking around.
10:21:07 <SamB_XP> wli: you don't like the way you have to specify grammars?
10:21:07 <wli> Rolling my own would be better exercise anyway.
10:21:22 <wli> SamB_XP: No idea what you mean.
10:21:26 <ski> edwardk : you want 'instance (forall a. Bar m a) => Foo m' .. (not supported)
10:21:39 <SamB_XP> wli: what about happy do you not like?
10:22:09 <edwardk> yeah
10:22:37 <wli> SamB_XP: I like it well enough. It's that the state machine code is all done up as Haskell code it writes out to a file, which makes it rather tough to interpret some representation of a state machine in-core using any of its code.
10:22:59 <SamB_XP> wli: hmm?
10:23:02 <edwardk> it'd make it possible to define convenience classes for Monad m, despite implementing monads with a set of restricted monad classes, like Oleg's version.
10:23:11 <SamB_XP> oh, you mean you were trying to adapt it's code to do something else?
10:23:17 <wli> SamB_XP: Yes.
10:23:25 <wli> SamB_XP: Or looking at doing so.
10:23:26 <edwardk> I can build monad convenience classes over the parameterized monad stuff, but not over the restricted monads
10:23:34 <ski> edwardk : 'instance (forall a. Show a => Show (f a)) => Show (Foo f)' would be handy sometimes, too
10:24:05 <ski> (though in that case there is a workaround)
10:24:12 <SamB_XP> ski: something's not being supported probably doesn't bother edwardk so much 
10:24:33 <edwardk> which means that i may have to drop restricted monads from the toy prelude, since they prevent me from having usable mapMs, sequences, etc. 
10:24:44 <edwardk> they obviously weren't tested beyond the basic idea
10:24:58 <edwardk> samb: =)
10:25:24 <ski> SamB_XP : well .. it would be interesting if one could get a usable ssystem supporting these things
10:26:34 <edwardk> and i don't want to do anything of this sort with explicit rank-n polymorphism because then i have to plumb around a bunch of dictionary-like objects and its not pretty
10:27:11 <ski> edwardk : mayhaps you could do an 'class BarForall m','instance BarForall m => Bar m a',etc ..
10:27:58 <edwardk> ski: thought about it, but then I can't do instance SomethingElse m => Bar m a kind of things without ghc complaining about the conflict
10:28:11 <edwardk> the moment there is a diamond in the inheritance hierarchy all is lost
10:28:22 <ski> instance SomethingElse m => BarForall m  -- then ?
10:28:36 <edwardk> you get one the moment you allow Monad, ParameterizedMonad, RestrictedMonad and ParameterizedRestrictedMonad
10:28:54 <ski> ok :/
10:28:55 <SamB_XP> edwardk: I thought you had a toy language ?
10:29:36 <edwardk> samb: i do, i started porting a good portion of the standard library over to haskell to get more eyes, and to work out the issues i was running into in my compiler to see if it was the language or the library at fault.
10:29:47 <SamB_XP> ah
10:30:38 <edwardk> my current goal is a painfully abstract prelude that unifies as many things as possible. backwards compatibility is not a priority, learnability is not a priority. useful or educational unification of ideas is
10:30:49 * shapr cheers
10:31:14 <wli> Equivalence for DPDA's is decidable if and only if it's decidable for "monadic recursion schemes." (Friedman 1977, as cited by Hopcroft and Ullman).
10:31:21 <SamB_XP> edwardk: obviously when you make a new Prelude you have to throw most compatibility out the window...
10:31:38 <edwardk> minimizing typeclasses is not a priority, current thought is to $(mkMonad "MyMonad" [d| return = ...; m >>= k = ... |]) to recover usable syntax for definitions
10:31:43 <wli> What are the odds that this is somehow connected to monadic parsing?
10:32:02 <wli> edwardk: Is this a new Prelude or a new language you're working on?
10:32:07 <edwardk> wli: yes =)
10:32:11 <SamB_XP> wli: both apparantly
10:32:29 <edwardk> wli: the prelude is a projection of features for the one i want for my language into haskell.
10:32:31 <ski> wli : DPDA ?
10:32:40 <edwardk> wli: the language is the things i'd never get haskell to adopt
10:32:48 <wli> edwardk: Could you extend the module system so that modules can be parametrized by other modules?
10:33:03 <wli> ski: Deterministic Push Down Automaton
10:33:26 <edwardk> wli: well, in haskell the idea is that a ML module maps onto a typeclass
10:33:41 <ski> not quite
10:33:47 * shapr makes a t-shirt "DPDAs against Oppression"
10:33:49 <wli> edwardk: Doesn't really work out.
10:33:59 <edwardk> well, based on the manuel chakravarty paper on modular type classes
10:34:03 <shapr> For too long have we been pushed down!
10:34:14 <wli> edwardk: Mostly because you want to switch out implementations behind things.
10:34:33 <ski> should we push up instead ?
10:34:37 <edwardk> anyways, in my setting they are stagedly dependently typed records, but the inference for them is a nightmare because i don't explicitly annotate what is a type and what is a term.
10:34:54 <edwardk> wli: i understand =)
10:34:57 <wli> ski: It just means that the finite control manipulates a stack.
10:35:13 <ski> wli : i know
10:36:01 * ski implemented function calls on a DPDA sometime ago
10:36:14 <laz0r> hi there, its me again... whenever i use 'do x <- something; ...' the something must be of type (a -> b), right?
10:36:50 <ski> laz0r : 'something' must be of type 'm a' for any type 'a', and any type 'm' in the class 'Monad'
10:36:54 <shachaf> laz0r: The something must be of type (Monad m) => m a
10:36:57 <edwardk> laz0r: something can be of type (m a) for any monad type m
10:37:03 <ski> @stereo
10:37:03 <lambdabot> Unknown command, try @list
10:37:07 <ski> @quote stereo
10:37:07 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
10:37:35 <glguy> @quote stereo
10:37:35 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
10:37:37 <glguy> :)
10:37:56 <SamB_XP> edwardk: couldn't you just use -fno-implicit-prelude?
10:38:04 <SamB_XP> rather than bothering with TH?
10:38:08 <edwardk> wli: at present my module system just hands you back a record with some types embedded in it, using the same mechanism i use for objects
10:38:14 <ski> dons : we need '@stereo' .. and possibly whatever the corresponding term is for three !
10:38:15 <edwardk> samb: the problem is sheer number of instances
10:38:16 <kpreid> laz0r: and note that m can be (b ->), in which case m a *is* b -> a
10:38:32 <SamB_XP> edwardk: for do-notation
10:38:33 <shachaf> ski: Yes, and one that doesn't beep Cale's IRC client.
10:38:39 <ski> indeed
10:38:52 <glguy> @quote
10:38:52 <lambdabot> joelr says: the learning curve is far steeper with Haskell but it is far more elegant and readable
10:38:53 <edwardk> samb: ideally to express things right a Field would take 30-40 =)
10:38:55 <shachaf> kpreid: But it's not likely to be.
10:39:10 <shachaf> kpreid: In this case.
10:39:52 <shachaf> Is there any reason to use Reader instead of the (e ->) monad?
10:40:04 <ski> > (do {x <- (*200); y <- (+8); return (x+y)}) 10
10:40:06 <lambdabot>  2018
10:40:36 <kpreid> when you've got a lot of function arrows and the newtype helps make your type errors less baffling?
10:40:40 <ski> shachaf : more explicit distictions between working abstractly in the monad, and concretely applying and abstracting actions
10:40:43 <olsner> springerlink wants $32 for the paper on monadic recursion schemes though
10:40:46 <edwardk> the current thought is to go through and define a redundant set of operators for the more restricted class of actions, and to build a manual set of instance of the more restricted type, but i still can't say that having something implies the existence of the more specific version
10:40:49 <edwardk> in general mixing restricted and unrestricted monads seems to force one to become a really bad second class citizen
10:40:52 <shachaf> > liftM2 (+) (*200) (+8) 10
10:40:54 <lambdabot>  2018
10:41:09 <SamB_XP> shachaf: ... it's easier to say and harder to mess up the typing?
10:41:39 <ski> and also more tedious to type 'Reader' and 'runReader' all the time :)
10:41:51 <edwardk> heh i like the Abstract version ((*200) + (+8)) 10
10:42:26 <shachaf> > do { x <- ask; return (x+1) } $ 5
10:42:27 <lambdabot>  6
10:42:30 <glguy> where a -> a is an instance of Num?
10:42:54 <ski> `(,(*200) + ,(+8)) 10
10:42:55 <edwardk> glguy: where b -> a is an instance of AddMagma and MulMagma if a is
10:43:35 <edwardk> er AddOp and MulOp now, since Magma is scary and would otherwise be all over the place inconsistently
10:43:42 <SamB_XP> heh
10:43:49 <ski> scary ?
10:44:17 <edwardk> well, the problem is this, do I call every binary operator's overarching class a FooMagma?
10:44:36 <ski> not if it isn't associative
10:44:49 <edwardk> MeetMagma, JoinMagma, etc.
10:44:59 <ski> take octonion multiplication, e.g.
10:45:00 <edwardk> SemiGroup is associative =)
10:45:06 <edwardk> Magma implies no such thing ;)
10:45:21 <edwardk> the free magma is a binary tree with labeled leaves
10:45:23 <ski> oh, sorry .. i can never remember what magma is :)
10:46:24 <oerjan> edwardk: i recall that in Clean, the class corresponding to an operator has the same name as it
10:46:28 <edwardk> thats one reason for the explosion of typeclasses to define it right, it'd be nice to be able to say that hey for this op to work the underlying operation you are using it over has to be associative and to give a SemiGroup constraint
10:46:48 <edwardk> oerjan: i started there, but Add seemed like a weird typeclass. i may go back to it though
10:47:25 <edwardk> especially now that i'm thinking that class Add a b c | a b -> c, b c -> a, a c -> b where (+) :: a -> b -> c
10:47:34 <edwardk> which works for type level and term level math
10:47:46 <edwardk> er
10:47:53 <oerjan> edwardk: i mean the class of (+) is (+)
10:47:55 <edwardk> yeah thats right
10:47:59 <edwardk> ah
10:48:04 <edwardk> can't do that in haskell =)
10:48:10 <SamB_XP> yeah.
10:48:19 <SamB_XP> you can't use variable names for classes in Haskell
10:48:48 <edwardk> and there is no ability to use :+ either since that is only type and data constructors no?
10:48:56 <wli> Higher-order classes would be nice.
10:49:09 <SamB_XP> edwardk: what?
10:49:11 <edwardk> wli: in a haskell setting the problem is type inference
10:49:16 * roconnor has a Mult class defining a mult operator like that
10:49:19 <wli> edwardk: Point.
10:49:19 <SamB_XP> I'm fairly certain that :+ is fair game in Haskell
10:49:30 <SamB_XP> if it isn't, report a bug!
10:49:31 <edwardk> samb: not for a class or instance name though
10:49:33 <oerjan> edwardk: i thought you had already abolished the capitalization rules?
10:49:47 <SamB_XP> oerjan: not in Haskell
10:49:51 <edwardk> oerjan: two distinct settings, my language vs. this current prelude =)
10:49:55 <edwardk> the prelude is haskell
10:49:57 <edwardk> the language is not
10:50:07 <oerjan> oh
10:50:12 <edwardk> its a context thing =)
10:50:22 <edwardk> you missed the context
10:50:44 <SamB_XP> edwardk: yeah, you'd already established the my-new-language context ;-)
10:50:48 <wli> edwardk: I really like the idea of formally including laws for classes in the language.
10:51:16 <edwardk> samb: anyways even if :+ was legal for a type class name it'd be useless since you want a typeclass for that to be ternary anyways
10:51:43 <EvilTerran> "(a :+ b) c" would be clear enough for me
10:51:46 <olsner> heh, someone should write a device driver in VB - just for the evil of it!
10:51:49 <oerjan> edwardk: i am reminded of Smalltalk syntax...
10:51:50 <SamB_XP> I'm fairly certain (:+) supports >=2 args at least
10:52:00 <edwardk> samb: can it be used as a typeclass name?
10:52:13 <SamB_XP> edwardk: if it can't...
10:52:14 <olsner> @quote evil
10:52:14 <SamB_XP> @bug
10:52:15 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
10:52:15 <lambdabot> Philippa says: <TomMD> Cale: I was wondering if something was wrong with the constructor "Red" :-) <Philippa> TomMD: it's supposed to be written EvilCommieBastard, duh
10:53:01 <oerjan> allowing operators to be split into several words
10:53:03 <EvilTerran> much like writing "container `get` key" leads naturally, imo, to writing "container `put` key $ value"
10:53:10 <wli> Ternary operators are usually of the form "x & y @ z" etc.
10:53:12 <psykotic> edwardk, i recall that fortress has support for specifying such laws as parts of interfaces/traits. it leaves unspecified how (or if) they are checked--a naive implementation could use some kind of randomized testing, a more sophisticated one could use theorem proving. but even having it there as a purely unchecked form of documentation/heads up would be nice.
10:53:20 <edwardk> oerjan: yeah like (a + b = c) ?
10:53:25 <wli> Or "(x, y, z)"
10:53:30 <SamB_XP> olsner: can VB export functions with sufficiently arbitrary calling conventions and argument types?
10:53:41 <edwardk> psykotic: thats actually what I do now more or less
10:53:42 <wli> I suppose you could call that an outfix ternary operator.
10:54:11 <oerjan> edwardk: words starting with : are continuations of the previous message
10:54:14 <edwardk> psykotic: sort :: [a] -> { xs : [a] | sorted xs }   the latter subset type is a proof obligation
10:54:18 <wli> kind of like "(x, y)" is an outfix binary operator.
10:54:30 <opqdonut> hehe outfix
10:54:30 <olsner> not sure actually... but I guess you could make some glue code in a C/C++ dll (although that's cheating)
10:54:32 <SamB_XP> wli: or you could call it special syntax
10:54:51 <olsner> wli: circumfix
10:55:04 <wli> SamB_XP: Then the problem of classifying special syntax arises.
10:55:15 <olsner> the Vulcan language has circumfix verb conjugations
10:55:24 <SamB_XP> olsner: also, I don't think the kernel has the vbvm dlls
10:55:24 <edwardk> psykotic: or semigroup+ a = magma+ a with (+) :: a -> a -> a | associative (+)
10:55:57 <EvilTerran> class l := r; data l :+ r; instance (a :+ b) := c where ... --?
10:56:22 <wli> olsner: Russian has something of that sort, except the prefix is related to something called the "aspect," which is perfective vs. imperfective as opposed to being related to the actor.
10:56:28 <SamB_XP> EvilTerran: hahaha
10:56:39 <EvilTerran> >:]
10:56:48 <edwardk> where associative f = forall a b c. (a + b) + c <%> a + (b + c)   (forgive the horrible <%> syntax, but its what i currently have), the associative law can only really be checked randomly right now, but the <%> says this is a rewrite rule that the compiler can use
10:57:04 <edwardk> er s/f/(+)/
10:57:06 <wli> olsner: And it is more of a change to the verb's word stem as opposed to a prefix per se.
10:57:16 <olsner> SamB_XP: it'll certainly be a challenge ;-)
10:57:22 <SamB_XP> edwardk: was <=> taken?
10:57:27 <edwardk> evilterran: hrmm, that works
10:57:50 <edwardk> samb: yeah ternary comparison in a total order witnessing trichotomy ala perl. =)
10:57:51 <EvilTerran> edwardk, aside from that extraneous "where" and probably needing some fundeps, yeah, i think so
10:58:02 <SamB_XP> edwardk: what was wrong with `compare`
10:58:14 <edwardk> the perl version is clearer =)
10:58:26 <SamB_XP> how about <==>
10:58:31 <EvilTerran> the intuitive definition of "greater than, equal to, or less than" is amusing ;]
10:58:53 <SamB_XP> EvilTerran: you mean x <=> y = True ?
10:58:53 <edwardk> and in my case there are two notions of rewrite permissability <%> allows interconversion for unification purposes and %> is a GHC-like one way confluent rewrite rule.
10:59:07 <SamB_XP> edwardk: you could use ==> for the other one
10:59:16 <edwardk> ==> is implication =)
10:59:32 <SamB_XP> --> and <--> ?
10:59:36 <edwardk> like i said forgive the horrible notation, it just got crowded into an ugly corner =)
10:59:45 <edwardk> that might wind up being the one i use
11:00:07 <edwardk> i like those
11:00:08 <EvilTerran> SamB, well, x <=> y IFF x < y | x = y | x > y, so it's not always true if the ordering isn't total
11:00:53 <EvilTerran> apparently the unicode consortium considered this a sufficiently likely occurance to include "≶" in the maths bit
11:01:28 <EvilTerran> I'm not sure how it differs from "≷", tho.
11:01:45 <Cale> ⋚
11:02:00 <EvilTerran> sorry, yes, those two omitted equality. I wanted ⋚ and ⋛.
11:02:15 <opqdonut> ahh
11:02:21 <opqdonut> unicode :)
11:02:29 <opqdonut> i just saw question marks and got flummoxed
11:02:36 <edwardk> right now i have preorders  with <~ >~ and ~, /~, partial orders with <= >= = /=with induced strict orders < and >, and an as yet unsymbolicized incomparable notion, so that pcompare returns something like Maybe Ordering, and total orders which give a trichotomy law <=> where it just returns Ordering
11:02:50 <EvilTerran> there's some really funny operators in there... "⋇" aka "divison times" anyone?
11:03:16 <Cale> I can't say I've ever needed that one.
11:03:29 <edwardk> heh, i could just revert to the unicode operators but reading code with &ltgt; or whatever the long form is would get weird.
11:04:12 <EvilTerran> ...can you use unicode symbols as haskell operators?
11:04:26 <edwardk> i believe ghc allows it now
11:04:26 <edwardk> hrmm
11:04:34 <edwardk> hey i have a new toy for my prelude =)
11:04:38 <puusorsa> hooray! 
11:04:53 <edwardk> not sure its a GOOD idea, but hey
11:04:55 <Cale> ∔ -- this one is actually useful occasionally (when you want to talk about both plus and times at the same time)
11:05:14 <edwardk> fmap = &cdot; =)
11:05:18 * EvilTerran wouldn't mind (≤) = (<=), (≠) = (/=), (×) = (*), etc
11:05:28 * EvilTerran wanders off for a bit
11:05:29 <Cale> f∘g
11:05:31 <edwardk> yeah
11:05:51 <Cale> ∘
11:05:54 <Cale> \circ
11:06:05 <edwardk> would finally get me out of using vim over the network to edit source files
11:06:23 <EvilTerran> (i'd have to train my editor with the appropriate keyboard shortcuts, mind)
11:06:32 <Cale> edwardk: why's that?
11:06:51 <Cale> I just install SCIM.
11:06:52 <EvilTerran> edwardk, with a suitably modern terminal, it should work fine. or with gvim.
11:07:00 <EvilTerran> anyway. away!
11:07:05 <Cale> (and the latex table)
11:07:13 <edwardk> evilterran: yeah, my terminal is just not suitably modern for some reason =)
11:07:19 <EvilTerran> heh.
11:07:45 <Cale> However, I think composition is common enough to warrant having something that's one keypress to type.
11:07:59 <edwardk> so in the interest of full obfuscation should i just start throwing unicode operators at problems then? =)
11:08:32 <shapr> sure!
11:08:59 <shapr> edwardk: But, doesn't ghc explode on unicode?
11:09:15 <glguy> ghc 6.6 handles unicode in .hs files
11:09:43 <edwardk> one thing i do find missing in haskell is the ability to define an overloaded application when the lhs isn't a function type. i still can't define that [1,2,3] 0 = 1 thats one piece of my prelude i can't port over
11:10:04 <edwardk> or similarly for indexing arrays, etc.
11:10:25 <opqdonut> yeah overloaded application would be cool
11:10:32 <opqdonut> though i guess it could be horribly misused
11:10:37 <edwardk> sure
11:10:46 <edwardk> and its a pain to figure out how to type infer i'll confess =)
11:10:56 <glguy> m
11:12:32 <edwardk> i think i tried at one point changing $ for it, but ran afoul of type inference problems
11:13:16 <edwardk> oh yeah way back when on ##logic with cale and dons when we came up with the (.) trick
11:13:31 <wli> edwardk: Which (.) trick is this?
11:13:48 <edwardk> class Functor f where (.) :: (a -> b) -> f a -> f b
11:14:47 <edwardk> it started with me trying to come up with really really general signatures for ($) and (.) before i realized my stupidly general signatures weren't inferrable.
11:14:59 <edwardk> at the time i was mixing in arbitrary arrows as well.
11:15:10 <mnislaih> fwiw, <$> works wonders 
11:15:20 <glguy> ?where shootout
11:15:20 <lambdabot> http://shootout.alioth.debian.org/
11:16:06 <glguy> :-( dylan isn't on the shootout
11:16:42 <edwardk> because looking at (.) above one wonders why its a -> on the outside and not an Arrow c a b => c a b -> c (f a) (f b) since functors map arrows after all, then of course they map arrows to arrows so the truly general signature is worse, etc. =)
11:17:15 <edwardk> its a very slippery slope that leads to madness
11:17:48 <_Nucleo> @src genericTake
11:17:48 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
11:18:49 <oerjan> genericTake 0 _         =  []
11:18:49 <oerjan> genericTake _ []        =  []
11:18:49 <oerjan> genericTake n (x:xs) | n > 0  =  x : genericTake (n-1) xs
11:18:49 <oerjan> genericTake _  _        =  error "List.genericTake: negative argument"
11:19:16 <Botje> :t genericTake
11:19:19 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
11:19:38 <edwardk> at the time i was new to haskell and was still kind of obsessed with removing the injective nature of a lot of things. the abuse of type constructors as tags in haskell still bugs me, but i have to admit that the inference it gives rocks.
11:20:10 <ski> injective ?
11:20:15 <_Nucleo> oerjan: thanks
11:21:05 <edwardk> the fact that functors in haskell aren't truly all endofunctors on the category of types, they only act as endofunctors from the 'larger' category of all types into a smaller subset delimited by the typeconstructor of the functor.
11:21:12 <oerjan> edwardk: i think of type constructors as all being in essence newtypes, with the main purpose of creating a new type
11:21:39 <oerjan> everything else can be desugared to functions :)
11:21:56 <edwardk> so in addition to fmap :: (a -> b) -> f a -> f b      one would like (g a -> g b) -> a -> b      and (f a -> f b) -> g a -> g b at least, or to move to the painfully general arrow notations above that are even less productive
11:22:54 <opqdonut> well you could just have some sort of "switch functor" function
11:22:57 <edwardk> in the end i came around to the haskell way of thinking but it was a long road =)
11:23:14 <opqdonut> those are all it's specializations
11:23:25 <shapr> edwardk: Sounds like a good blog post to me.
11:23:25 <opqdonut> *specialisations
11:23:32 <edwardk> opqdonut: the issue i had at the time is that a functor isn't a fully general functor =)
11:23:58 <oerjan> edwardk: missing a lot of categories too...
11:23:59 <edwardk> its just the Hom map of an endofunctor into a subset of the category of all types.
11:24:23 <edwardk> the Ob map is entirely missing as return isn't part of functor
11:25:08 <edwardk> i got used to it though
11:25:40 <edwardk> the asymmetry led me to drive cale to distraction I think for a while though when i first showed up here though =)
11:26:28 <Cale> edwardk: the Object map isn't missing at all
11:26:35 <edwardk> ?
11:26:35 <Cale> It's the type constructor.
11:26:51 <Cale> That is, the thing which you're making an instance of Functor :)
11:28:47 <edwardk> i think calling it the type constructor is conflating two notions though. return seems to me to be really an object map. mapping objects into the same place as you map arrows, you can't move objects with just the type constructor like you can move arrows with map, you can just name what they should move to
11:29:22 <Cale> return is a natural transformation from the identity functor to your functor
11:29:59 <Cale> Objects are types, the object map of a functor sends types to other types
11:30:44 <Cale> Of course, in Haskell, you don't have complete control over what the object map is -- you have to pick something which is in some sense natural.
11:30:59 <edwardk> my main issue is ideally i'd like to be able to define a real 'identity functor' and the forced existence of a tag kind of keeps that from happening, but thats the whole haskell mindset of using tags to break apart cases so it can't really be worked around in the context of the system. I agree that in haskell the answer that haskell uses is the right one. in the presence of the ability to pass an explicit dictionary and use type level functi
11:31:01 <ski> a functor 'F' from 'C' to 'D' consists of a map 'F.mapObj : C.Obj -> D.Obj' and a map 'F.mapMor : forall A,B :: C.Obj . C.Mor (A,B) -> D.Mor (F.mapObj A,F.mapObj B)' (together with the requirement that those respects identities and composition)
11:31:51 <Cale> Hehe, OO syntax :)
11:32:04 <ski> just record syntax, yes
11:32:41 <edwardk> thats what i use in my toy compiler more or less for them, or rather whats lurking in the prelude waiting for the compiler to successfully parse it ;)
11:35:49 * ski has been pondering a way to think of morphisms as effectful things (and objects being effectless) ..
11:36:17 <edwardk> ski: a tofte and talpin style type and effect system basically?
11:37:05 <ski> hm .. maybe a little bit like that .. more related to my ideas about quotation
11:38:27 <edwardk> i've been trying to figure out the right way to reflect an effect into a monad and reify the monad back out into an effect, so you can treat the monad as a value, and run the monad to get the effect as an effectful computation, but i haven't come up with anything clean
11:39:02 <edwardk> http://www.comp.mq.edu.au/~asloane/pmwiki.php/SAPLING/SAPLING071?action=download&upname=lippmeier-slides071.pdf was a good paper and i'm amused he takes the same kitchen sink approach to features i do (largely the same features even)
11:39:03 <lambdabot> http://tinyurl.com/3y7tb7
11:39:04 <ski> e.g. if 'F,G : C -> D', 'eta : F -> G', 'A,B : C' and 'f : A -> B', then '`(,eta ,f) : F A -> G B' which strikes me as a nice way of denoting that diagonal morphism
11:39:31 <edwardk> er not paper, presentation i guess
11:39:44 <ski> ty for link
11:40:43 <edwardk> in that setting note the -(effects)> on the arrows. what i'd like to do is be able to reflect those into a monad parameterized by the effects in question so that the monad when later invoked causes those effects to happen.
11:40:53 <edwardk> rather than have the effects happen when crossing the arrow
11:41:04 <ski> (more common ways of denoting that diagonal is as 'eta_B . F f' or alternatively (and symmetrically) as 'G f . eta_A')
11:42:05 <ski> edwardk : hehe .. that is what i'm doing in my (not completed) monad effect system :)
11:43:52 <ski> (if you want elaboration on the diagonal above, just ask)
11:45:56 <edwardk> ski: so what i want is something like reify :: m effects a -(effects)> a, and a metalinguistic form of reflect that can capture actions leading to effects, then you can get haskell like separation of evaluation and execution
11:47:03 * ski gets separation of evaluation and execution in his system .. that being one of the design goals
11:47:41 <edwardk> because it seems that ben's system above has the problem that a lot of those sorts of systems have, that they conflate reduction to normal form with running the effects involved.
11:47:58 * ski nods
11:48:00 <edwardk> its one of the more elegant points in haskell's and forsythe's design that people often over look =)
11:48:39 <ski> i'd say its one of the main point of bothering with monads
11:49:09 <edwardk> i find it funny that you were talking about this a few months ago, and I largely ignored you because I couldn't figure out what you were rambling on about until I encountered the same problem and puzzled it out for myself =P
11:49:22 * ski smiles
11:51:24 <edwardk> btw- i still want to find a practical way to exploit some of the ideas of the hoare type theory separation logic monad in a practical language though.
11:51:53 * ski attempts to recall what that was .. again
11:51:54 <edwardk> seems like a lot of the 'is this monad commutative' questions can be answered by an approach like that
11:52:05 <shapr> Is it better than nanevski's stuff?
11:52:08 <edwardk> { P } t { Q} 
11:52:16 <edwardk> it kind of half-is nanevski's stuff =)
11:52:32 <edwardk> since at last check he was doing a post-doc or something working with greg morrisett at harvard on it
11:52:41 <ski> (>>=) :: m o p a -> (a -> m p q b) -> M o q b  -- ?
11:52:46 <mattam> what would be the other half ?
11:53:07 <shapr> salut mattam
11:53:10 <edwardk> well, iirc amal ahmed, and greg morrisett were working on it, not sure who else
11:53:19 <ski> shapr : good evening
11:53:26 <shapr> tjenare ski!
11:53:43 <mattam> yep the Y_0 team
11:53:50 <shapr> ski: Hej Herr Stefan!
11:53:57 <edwardk> heh, i moved out here to within about 3 miles of harvard and I've yet to actually have an excuse to set foot on the campus.
11:54:08 * ski feels a bit too excited .. even though he ought to go to sleep
11:55:08 <edwardk> hrmm actually closer to a mile
11:55:10 <mattam> Hmm, it seems there's a good team of plt people there, aren't you acquainted with anyone there ?
11:55:48 <edwardk> I met Fluet, Ahmed and Nanevski briefly at the ICFP last year, but I doubt they remember be beyond me being the 'crazy comonad guy' =)
11:55:56 <edwardk> er remember me
11:56:14 <mattam> hehe
11:56:20 <edwardk> and at last check all but nanevski had fled the area to go to TTI in chicago
11:56:41 <chrisamaphone> anyone here know anything about type theory/logic schools that aren't in the u.s.?
11:56:52 <ski> (oh, right .. i think my system can be applied to comonads, maybe arrows, .. and also in a way to equality proofs :)
11:57:33 <chrisamaphone> (i'm currently an undergrad in cs at cmu.)
11:57:38 <ski> chrisamaphone : Chalmers/Gothenburg University has Haskell research
11:58:09 <chrisamaphone> ski: ok, i've been meaning to look into chalmers.
11:58:18 * ski is currently an undergrad at chalmers/GU
11:58:30 <mattam> chrisamaphone: There's a good master program in Paris
11:58:41 <chrisamaphone> inria?
11:58:55 <edwardk> ski: anyways the pre and post conditions in those hoare type theory monads just specify the pre and post conditions for the heap in which they can run, so you get sort of runs of things that can happen in parallel rather than a purely sequential composition.
11:58:58 <chrisamaphone> i've actually found a bunch of interesting stuff in sweden.
11:59:04 <shapr> Me too!
11:59:04 <mattam> http://mpri.master.univ-paris7.fr/english/index.html
11:59:16 <chrisamaphone> i just don't know anyone with firsthand experience with any of it.
11:59:22 <mattam> They even have an english translation :)
11:59:27 <shapr> Chalmers is awesome, if you can get in.
11:59:29 <ski> edwardk : was my '(>>=)' type signature related to that or not ?
12:00:07 <quicksilver> edwardk: I have some vague ideas about using seperation logic to optimise query languages
12:00:13 <chrisamaphone> mattam: i'd ideally go into a phd program, but this does look interesting.
12:00:24 <edwardk> ski: close, but think of two actions {P} x : t {Q}   and {P'} y : t2 {Q'} as being able to operate in parallel as long as their conditions don't conflict.
12:00:39 <edwardk> i.e. if they mention different portions of the heap
12:00:42 <quicksilver> edwardk: help you find out how to divide a query between threads or indeed machine, safely
12:00:42 <mattam> There are links to most doctoral studies schools around
12:01:12 <ski> edwardk : ok .. more arrowic, then ?
12:02:00 <mattam> well, the separation logic stuff can be separated from the Hoare type theory somehow.
12:02:41 <edwardk> well, if two actions are disjoint they can be run in parallel. that reminds me I need to slap together that Par monad.
12:03:36 <ski> ?
12:03:40 <ski> resumptions ?
12:04:05 <jameysharp> sjanssen: ping?
12:04:37 <ski> data Resumption a = Return a | Yield (Resumption a)
12:04:42 <edwardk> given something :: { P } x : t { Q}; somethingelse :: { P' } y : t' { Q'}, something >> somethingelse can just both be executed in parallel if the operation { P } x : t {Q} doesn't mention the same stuff in the heap as { P'} y : t' {Q'}
12:05:32 <edwardk> resumptions being the Par monad thing?
12:05:34 <glguy> STRef IORef MVar TVar TMVar, am I missing any?
12:05:49 <ski> edwardk : that was supposed to be my query, yes
12:06:02 <edwardk> the Par monad was just a stupid newtype Par a = Par { runPar :: a }; with Par m >>= k = m `par` k m
12:06:17 <ski> glguy : 'SampleVar' ?
12:06:20 <edwardk> an identity monad that sparks speculation
12:06:21 <glguy> oh yeah
12:06:44 <edwardk> glguy: building a MonadRef kind of library?
12:06:48 <oerjan> @index SampleVar
12:06:49 <lambdabot> Control.Concurrent.SampleVar, Control.Concurrent
12:06:54 * glguy is tired of not having a modifyRef
12:06:59 <edwardk> heh
12:06:59 <glguy> swapRef
12:07:30 <ski> should there be any fundeps in it, if so, which direction ?
12:07:46 <edwardk> yeah, though i admit the big three of IO/IORef, ST/STRef STM/TVar would be good enough for me, and it gives fundeps
12:08:04 <edwardk> and  fundeps are problem.
12:08:12 <glguy> fundeps wouldn't be needed if you use newIORef
12:08:16 <glguy> and then switch to the generic functiosn
12:08:40 <edwardk> yeah but then i can't parameterize my hash table off of the type of monad its designed for =)
12:08:41 <ski> 'newRef' !
12:08:49 <edwardk> not so easily
12:09:02 * SamB just joined facebook for some reason
12:09:12 <glguy> myspacebook?
12:09:19 <SamB> facebook!
12:09:28 * ski built a 'LogVar' parameterized over an arbitrary 'ref' in 'MonadRef'
12:09:40 <glguy> previous attempts at a Data.Ref were killed because people couldn't agree on how to do it
12:09:50 <glguy> so I'm thinking that I'd rather have it than not
12:10:53 <SamB> how can it work if you don't parameterize the datastructure
12:10:57 <edwardk> so would the right answer on a fresh slate be to newtype IO, etc. so that under the correct newtype you got the MVar version of things for instance?
12:11:25 <edwardk> samb: type family, one parameter of the monad thats it
12:11:54 <edwardk> or a fundepped MonadRef kind of class
12:12:34 <ski> exists :: (Quantifiable ref a,MonadRef ref m) => (a -> Logic m b) -> Logic m b
12:12:35 <edwardk> withMVarRefs $ do ... 
12:13:05 <ski> bound :: MonadRef ref m => a -> Logic m (LogVar ref a)
12:13:07 <ski> (etc)
12:13:26 <quicksilver> edwardk: if you newtype IO aren't you in lifting hell every time you try to do any other IO operation?
12:13:44 <quicksilver> edwardk: (until the *entire* standard library is rewritten with MonadIO primitives instead of IO ones)
12:13:56 <edwardk> quicksilver: the setting being a new prelude in which IO is modular and all methods in it lift somehow
12:14:05 <quicksilver> oh, I see
12:14:19 <quicksilver> right, sounds plausible to me :)
12:14:24 <ski> it'd be nice to have someting a bit like hugs restricted type synonyms .. but openable at will later
12:15:05 <edwardk> quicksilver: well, i';m thinking a huge chunk of template haskell =)
12:15:21 <ski> ('newtype f Foo = MkF (f Bar)' could be nice, as well)
12:15:24 <edwardk> and a preprocessing job to pull in a good chunk of the library
12:15:50 <edwardk> right now i do something like that to steal numeric types
12:17:45 <edwardk> foreign imports would be second class citizens without some form of template magic as well though =(
12:18:36 <edwardk> gah the IO monad is really cemented into Haskell's worldview isn't it
12:19:05 <ski> the sin-bin
12:19:09 <edwardk> yeah
12:19:38 <edwardk> its just bolted in there good though
12:19:44 <Cale> I don't see it as a sin-bin, personally.
12:20:00 <Cale> Of course, perhaps at present, it might have a few things in it which it shouldn't.
12:20:47 <Cale> But generally, I think using some form of combinator library to deal with IO is the right way to go, and if that combinator library happens to be a monad, there's no reason not to make it one.
12:20:55 <shapr> SamB: What's your facebook email?
12:21:08 <edwardk> so the trick would have to be something like $(importForeign ...) where that automatically made the wrapper that took an arbitrary MonadIO instance and made it able to run this
12:21:10 <ski> what is "IO" ?
12:22:01 <edwardk> and that would leave the ugly side effect that you couldn't use the action you just imported in the same module you just imported it into unless you dealt with lift hell.
12:26:53 <Nopik> hi again
12:27:35 <Nopik> heh, the topic should say: "The Haskell programming language: fit infinite lists into few bytes" :D
12:27:55 <Nopik> .. just as linux is doing infinite loops in 5 seconds :D
12:28:08 <shapr> BogoLists?
12:30:36 <glguy> there really can't be a functional dependency in "MonadRef" since things like TVar can be created in multiple monads (IO and STM) and muliple Ref Types can be created in a single monad (MVar IORef) so that makes it easy to decide
12:33:53 <ihope> Nopik: Haskell can do that too!
12:33:57 <ihope> > last (repeat ())
12:34:01 <lambdabot> Terminated
12:34:06 <ihope> Okay, maybe it can't.
12:34:08 <ihope> > let x = x in x
12:34:10 <Nopik> hehe :)
12:34:10 <lambdabot>  Exception: <<loop>>
12:35:28 <_Nucleo> @src LiftM2
12:35:28 <lambdabot> Source not found. It can only be attributed to human error.
12:35:31 <quicksilver> > concat . repeat $ []
12:35:32 <lambdabot>  Exception: <<loop>>
12:35:32 <_Nucleo> @src liftM2
12:35:33 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
12:36:00 <glguy> liftM2 f x y = return f `ap` x `ap` y
12:36:13 <_Nucleo> @src ap
12:36:13 <lambdabot> ap = liftM2 id
12:36:18 <_Nucleo> heh
12:36:29 <Nopik> damn.. i have installed gd library, but when I try to import Graphics.GD in my code, runghc says: can't load .so/.DLL for: pthread (/usr/lib64/libpthread.so: invalid ELF header)
12:37:54 <Nopik> i tried to run plain ghc, but it throws bunch of undefined references.. any ideas what option i should add to ghc to add proper library to link with?
12:37:59 <EvilTerran> have you got the pthreads dynamic library files (in a place GHC can find 'em)?
12:38:50 <EvilTerran> s/can/should be able to/
12:39:43 <_Nucleo> @undo do { x1 <- m1; x2 <- m2; return (f x1 x2) }
12:39:43 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
12:40:24 <Nopik> well, my system uses pthread all the time, and i did not moved them at all :)
12:40:45 <oerjan> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
12:41:32 <quicksilver> EvilTerran: that wasn't file not found
12:41:36 <quicksilver> EvilTerran: it was invalid ELF header
12:41:51 <quicksilver> Nopik: I think you have a mixed 64bit/32bit system and something has gone awry?
12:41:53 <oerjan> @pl m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
12:41:54 <lambdabot> (`fmap` m2) . f =<< m1
12:42:23 <Nopik> quicksilver: well, i am working on amd64, everything should be 64bit
12:42:27 <Nopik> unless something is not :D
12:42:27 <oerjan> @pl \m1 m2 -> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
12:42:28 <lambdabot> liftM2 f
12:42:29 <EvilTerran> huh. well, it was just a thought. i don't know what an ELF header
12:42:32 <EvilTerran> is
12:42:38 <quicksilver> could be the GD library wasn't 64 bit clean
12:42:47 <Nopik> linux executables are in ELF format
12:42:54 <quicksilver> or the FFI bindings used by the haskel-gd binding aren't 64 bit clean
12:42:56 <Nopik> quicksilver: maybe.. though i just compiled it minute ago
12:43:08 <ski> @redo m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
12:43:09 <lambdabot> do { x1 <- m1; x2 <- m2; return (f x1 x2)}
12:43:40 <msouth> but isn't it saying that the .so has something it isn't expecting?  like it's for wrong architecture?
12:44:30 <Nopik> heh, but when i run ghc -v option, it displays gcc command.. if i copy/paste, add proper -L -l, it works
12:45:02 <Nopik> but manually running gcc is not what user is meant to do, i bet ;p
12:47:06 <Nopik> ok, managed to run via ghc using the same -L -l options
12:47:18 <Nopik> now, the question is how to run the same thing using runghc ;p
12:57:20 <Nopik> ok, next bit in this pthread puzzle: /usr/lib64/libpthread.so is a ld script on my system.. strace shows that runghc looks at /usr/local/lib/gd-3000.3.0/ghc-6.6.1/libpthread.so before going into /usr/lib*, so i copied /lib64/libpthread.so.0 (which is proper ELF file) into /usr/local/lib/gd-3000.3.0/ghc-6.6.1/libpthread.so and it works
12:57:45 <SamB> Nopik: what? no symlinks?
12:58:00 <Nopik> SamB: yeah ;P
12:58:29 * EvilTerran meditates on unsafeCoerce#
12:58:52 <Nopik> http://hpaste.org/1717
12:59:37 <fasta> It seems the popularity of unsafe operations is on the rise...
13:00:08 <EvilTerran> wow. nice name there -- GHC.Prim.reallyUnsafePtrEquality#
13:00:46 <Cale> EvilTerran: Yeah, just 'unsafe' wasn't discouraging enough, I suppose.
13:00:48 <EvilTerran> fasta, i'm merely thinking about it, not seriously intending to use it. i'm sure i'm missing something, and that probably wouldn't fix it
13:01:31 <fasta> EvilTerran: I do unsafe things all the time, and my machine didn't explode :)
13:01:48 <fasta> EvilTerran: although, some stuff did break between 6.6 and 6.7
13:02:08 <fasta> I don't recommend unsafe for nuclear reactors, though. 
13:02:17 <EvilTerran> okay. well, as i said, i don't intend to really use it. best stay safe if at all possible, eh.
13:03:31 <glguy> is the next adjective: dangerous, as in dangerousPtrEquality#
13:03:38 <glguy> or maybe disasterous
13:03:58 <glguy> unwise?
13:04:32 <EvilTerran> hazardous?
13:04:37 <oerjan> wmd
13:04:41 <EvilTerran> omg?
13:04:42 <SamB> dasasterous probably
13:04:52 <SamB> for that particular one
13:04:53 <fasta> How about "tryme"?
13:05:08 <SamB> probablyWrongPtrEquality#?
13:05:18 <EvilTerran> bigRedButtonPtrEquality#
13:05:24 <fasta> Nice and short, just like people who like shooting themselves in the foot like.
13:05:31 <glguy> notReallyPtrEquality
13:05:33 <ski> willMakeYouInsanePointerEquality#
13:05:37 <SamB> seqFirstIfYouWantInterestingResultsPtrEquality#?
13:05:46 <EvilTerran> iahIahCthulhuPtrEquality#
13:05:51 <ski> ;)
13:06:00 <wli> Try pointer inequalities.
13:06:02 <fasta> "used_as_source_of_randomness_by_some"
13:06:25 <wli> p - q <= 2*(p' - q') etc.
13:06:31 <EvilTerran> schrödingerPtrEquality#, complete with umlaut to really be difficult.
13:06:35 <SamB> wli: those are positively wrong
13:06:54 <wli> Don't forget screwed up pointer differencing semantics.
13:06:54 <newsham> so icfp contest is run by a bunch of haskell zealots this year?
13:06:56 <SamB> wrongPtrGTE
13:06:57 <newsham> that should bode well
13:07:14 <fasta> newsham: nice troll
13:07:20 <newsham> no troll intended.
13:07:34 <ski> haskell libs should have more really long identifiers
13:07:38 <newsham> I'm not a haskell zealot, but i'm 50% of the way there.
13:07:47 <ski> (like 'call-with-current-continuation' in scheme)
13:07:50 <wli> I have no idea how people can get so worked up about languages as to be zealots about them, but I've seen it happen.
13:08:09 <fasta> newsham: I think it were run by Scheme "zealots" last year. 
13:08:24 <SamB> fasta: hah
13:08:28 <newsham> wli: some people are prone to zealotry, in other situations its a reflection of the competition more than the language itself ;-)
13:08:34 <Cale> 'CentralizerInAssociativeGaussianMatrixAlgebra'
13:08:36 <SamB> then why did they use an ML variant to write the codex?
13:08:46 <newsham> fasta: it was a good set of problems, though.
13:08:54 <fasta> SamB: that's a diversion
13:08:58 <Cale> 'AbelianNumberFieldByReducedGaloisStabilizerInfo'
13:09:08 <ski> Cale : ty
13:09:13 <Cale> I love GAPs long identifiers :)
13:09:15 <SamB> fasta: do you think this because they never parodied scheme?
13:09:20 <wli> That hair shirt retrospective thing said the next version of ML was going to adopt typeclasses.
13:09:31 <wli> Or was it monadic IO?
13:09:42 <SamB> wli: how do you take one without the other?
13:09:57 <SamB> where "one" is monadic IO
13:10:02 <wli> SamB: I'm not sure. It only said one and I'm inferring the other.
13:10:27 <fasta> Type classes... is that like Jaaavaaa?
13:10:53 <SamB> fasta: stop it before I call you a 2d lover!
13:10:55 <opqdonut> no, that's like haskell :)
13:11:10 <wli> fasta: I wish they'd have been called something else like "qualified types" or "type qualifiers" or "modal types" or something.
13:11:16 <SamB> or... worse... an o'cult lover!
13:11:39 <newsham> a rose by any other name would smell as sweet
13:12:01 <SamB> wli: but then what would we call "methods"?
13:12:40 <wli> SamB: Something else. Domain-restricted polymorphic functions?
13:13:07 <SamB> wli: and *that* is as good a reason as any to call typeclasses that ;-)
13:13:18 <ski> SamB : "qualified-type-properties" ?
13:13:30 <opqdonut> interfaces?
13:13:32 <opqdonut> ;)
13:13:40 <SamB> also it doesn't distinguish methods from functions that *use* methods
13:13:46 <EvilTerran> i've got it! interestingPtrEquality# !
13:13:58 <SamB> EvilTerran: how about boringPtrEquality#
13:13:58 <EvilTerran> oh, wait... the conversation's moved on. ignore me. ;]
13:14:09 <SamB> since it usually returns False
13:14:21 <glguy> it usually returns an Int#
13:14:24 <opqdonut> how about totallySafeAndEntirelyHarmleePtrRquality#
13:14:26 <SamB> glguy: oh.
13:14:30 <opqdonut> *Harmless
13:14:57 <EvilTerran> samb, it's a reference (to PTerry, iirc); allegedly a traditional curse is "may you live in interesting times!"
13:15:13 <ski> safePtrEquality :: Execution a -> Execution b -> Possibly (Equal a b)
13:15:38 <ski> ('Possibly' being a monad a bit like 'Maybe')
13:15:59 <opqdonut> Remotely (Possibly (Equal a b))
13:16:29 <newsham> data PLZ a = AWSUM_THX a | O_NOES String
13:16:31 <dozer> EvilTerran: usually people under that curse say something like: "It was never booring" after their third wisky
13:16:45 <EvilTerran> hehe
13:16:46 <ski> runPossibly :: Possibly a -> Nondet (Maybe a)
13:16:54 <newsham> http://www.haskell.org/pipermail/haskell-cafe/2007-May/026142.html
13:16:56 <lambdabot> Title: [Haskell-cafe] data PLZ a, http://tinyurl.com/2my4vu
13:17:43 <ski> runNondet :: Nondet a -> IO a
13:18:02 <ski> unsafePeekExecution# :: a -> Execution a
13:18:22 <newsham> unsafeGuessAtAnswer
13:18:37 <Nopik> ok, there is:  mapM_ (\x -> setPixel (x, 10) red pic) [0..w]  how to make it work over 2 dimensional array (like [0..w] [0..h])?
13:18:41 <opqdonut> unsafeOptimize
13:18:42 <newsham> stand back, I'm going to try SCIENCE
13:18:46 <Nopik> should i make mapM_ nested?
13:18:54 <Nopik> or, there is simpler way?
13:18:58 <ski> (where 'Execution a' is a representation of a thunk, or something like that .. so you can check if it's been forced yet, e.g.)
13:19:04 * SamB tries to figure out how JHC treats Bool as being "data Bool = Bool# Bool__" (or something like that) when it is declared "data Bool = False | True"
13:19:08 <opqdonut> Nopik: well, nested mapM_ would work
13:19:28 <mattam> newsham: you're not too far from being a geek if not a zealot anyway :)
13:19:35 <ski> @index forM_
13:19:35 <lambdabot> bzzt
13:19:41 <newsham> mapM_ func [(w,h) | w<-[0..w], h<-[0..h]]
13:19:43 <Nopik> i just want nested for loop :P
13:20:01 <ski> forM_ = flip mapM_
13:20:06 <ski> do ...
13:20:06 <newsham> yes, forM_ superior
13:20:21 <Nopik> why superior?
13:20:26 <ski>    forM [0..w] $ \w ->
13:20:26 <newsham> why nest loops when you can cross-product
13:20:32 <ski>      forM [0..h] $ \h -> do
13:20:45 <Nopik> hm, let me try
13:20:45 <newsham> nopik: because I program in #python, and forM is like my imperative friend
13:20:45 <ski>        func (w,h)
13:21:27 <ski> (s/forM /forM_ /)
13:21:52 <EvilTerran> Nopik, if mapM_ does what i think it does, i'd be tempted to do a list comprehension over the two lists, and then sequence_ it
13:21:55 <Nopik> not in scope forM_ ?
13:22:10 <Nopik> EvilTerran: yeah, i'm trying to do so
13:22:14 <newsham> import Control.Monad
13:22:17 <EvilTerran> ?type sequence [setPixel (x, y) red pic | x <- [0..w], y <- [0..h]]
13:22:19 <lambdabot> Not in scope: `setPixel'
13:22:20 <lambdabot>  
13:22:20 <lambdabot> <interactive>:1:26: Not in scope: `red'
13:22:31 <EvilTerran> hm
13:22:33 * ski once made a monad so he could say 'do {w <- for_list [0..w]; h <- for_list [0..h]; func (w,h)}' :)
13:22:42 <Cale> ?type sequence [?setPixel (x, y) ?red ?pic | x <- [0..w], y <- [0..h]]
13:22:44 <lambdabot> Not in scope: `w'
13:22:44 <lambdabot>  
13:22:44 <lambdabot> <interactive>:1:61: Not in scope: `h'
13:22:49 <Cale> ?type sequence [?setPixel (x, y) ?red ?pic | x <- [0..?w], y <- [0..?h]]
13:22:51 <lambdabot> Not in scope: `..?'
13:22:51 <lambdabot>  
13:22:51 <lambdabot> <interactive>:1:49: Not in scope: `w'
13:22:55 <Cale> er, right
13:22:58 <Cale> ?type sequence [?setPixel (x, y) ?red ?pic | x <- [0.. ?w], y <- [0.. ?h]]
13:23:00 <lambdabot> forall t t1 (m :: * -> *) a t2 t3. (Num t2, ?w::t2, Enum t2, Num t3, ?h::t3, Enum t3, ?setPixel::(t2, t3) -> t -> t1 -> m a, ?red::t, ?pic::t1, Monad m) => m [a]
13:23:02 <Cale> hehe
13:23:18 <ski> (but for some strange reason the laboration examiner thought it was overkill for solving sudoku ...)
13:23:19 <EvilTerran> the significant component of that being the thoroughly uninteresting "m [a]"
13:23:28 <Nopik> hm, now i have forM_, list comprehension etc. it compiles, but i see no result ;p
13:23:34 <Nopik> just like iterating over empty list
13:23:35 <newsham> > do { w <- [0..2]; h <- [0..2]; return (show w ++ " " ++ show h) }
13:23:36 <EvilTerran> ski, does that differ from the list monad?
13:23:37 <lambdabot>  ["0 0","0 1","0 2","1 0","1 1","1 2","2 0","2 1","2 2"]
13:23:40 <ski> I HAD so much FUN !
13:24:00 <ski> EvilTerran : it was based on a continuation monad (transformer) with shift/reset
13:24:04 <Nopik> ok, my mystake ;p
13:24:23 <EvilTerran> Nopik, the _ indicates it shouldn't return a result
13:24:25 <ski> Nopik : now do IO in the body
13:24:46 <Nopik> EvilTerran: no, i had \x -> setPixel (w,h) while i should have \(w,h) -> ...
13:24:48 <glguy> > sequence ["012"," ","012"]
13:24:50 <lambdabot>  ["0 0","0 1","0 2","1 0","1 1","1 2","2 0","2 1","2 2"]
13:24:51 <EvilTerran> ahh
13:24:57 <Nopik> works now
13:25:07 <Nopik> my first nested for in haskell :)
13:25:28 <oerjan> :t forM
13:25:30 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
13:25:34 <Nopik> though it iterates 500x500 for 1.5 sec ;p
13:25:58 <ski> actually .. to say the truth i couldn't use the 'do' syntax but instead 'bindC' and 'returnC', since i had more general types ..
13:27:11 <SamB> ski: -fno-implicit-prelude
13:27:13 <SamB> ;-P
13:27:57 <Nopik> ok, how to write thing like [0..(w/2)] ?
13:28:17 <SamB> > 25 `div` 2
13:28:18 <Nopik> div w 2 ;)
13:28:19 <lambdabot>  12
13:28:22 <newsham> "my first nested for in haskell" is amusing cause most idiomatic haskell coders dont use nested fors
13:28:33 <hpaste>  (anonymous) pasted "Imperative Hoare" at http://hpaste.org/1718
13:28:42 <Nopik> newsham: my first nested for equivalent? :)
13:29:06 <newsham> what i mean is -- you're probably doing things "the imperative way" when you could do it nicer "the haskell way"
13:29:11 <newsham> (I do that all the time myself)
13:29:24 <Nopik> newsham: maybe
13:29:34 <SamB> newsham: what's a nicer way to do a cross product?
13:29:35 <ski> loopCT :: (QuantifiableCollection f,Monad m) => f a -> Cont2T (f b) b m a   -- this appears to have been my general looping construct
13:30:00 <Nopik> newsham: so, how to iterate function over 2 dimensional array in 'haskel way'?
13:30:20 <SamB> Nopik: the other way is list comprehensions, I guess...
13:30:27 <quicksilver> Nopik: 2 dimensional array or 2d list?
13:30:28 <ski> Haskell is the worlds finest imperative language !
13:30:28 <newsham> you could use sequence, as above
13:30:31 <Nopik> SamB: i am using list comprehension now
13:30:32 <quicksilver> Nopik: 2d list is just map.map
13:30:38 <quicksilver> :t map.map
13:30:40 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
13:30:46 <newsham> ski: so how come you have to manually select monads?
13:30:54 <newsham> my other imperative languages pick my monads for me
13:31:09 <quicksilver> no, your other imperative languages only have 1 monad
13:31:09 <Nopik> yeah, i was considering map.map, though this way felt better for me ;p
13:31:10 <newsham> no lifting
13:31:12 <SamB> newsham: most languages have at most one usable monad
13:31:16 <quicksilver> and they use that for everything
13:31:24 <ski> newsham : yes, you can't decide yourself which monad you want .. e.g. a parsing monad
13:31:24 <quicksilver> haskell lets you give more precise types to your functions/actions
13:31:30 <bulio|> would haskell be advisable for a new programmer to learn?
13:31:44 <quicksilver> so you can understand what kinds of computational effect they have
13:31:45 <ski> bulio| : i believe so
13:31:58 <quicksilver> bulio|: it's a controversial point, but I also think it is, like ski
13:32:07 <xsdnyd> hi, how can i compute the number: 2^(1/3) in haskell? the ^ operator only allows integers as second parameter... :-\
13:32:18 <quicksilver> > 2 ** (1/3)
13:32:20 <lambdabot>  1.2599210498948732
13:32:24 <quicksilver> xsdnyd: comme ca
13:32:37 <SamB> bulio|: some are of the opinion that it might discourage further study (they say something like "who would want to learn another language after haskell?"). I don't see how it could work that way though ;-)
13:32:45 <newsham> right, which is why when I want to add debugging printfs into my program in most imperative languages I don thave to reengineer my code.
13:32:50 <glguy> xsdnyd: actually, the ^ operator only allows non-negative integrals :)
13:32:51 <xsdnyd> quicksilver, i need the number as Rational
13:32:54 <newsham> I love haskell, but I strongly disagree with "best imperative language"
13:33:11 <quicksilver> xsdnyd: well, in the first place, cube roots aren't normally rational :)
13:33:11 <SamB> newsham: Debug.Trace is your friend
13:33:16 <glguy> xsdnyd: fractional exponents don't generate rationals :)
13:33:16 <Nopik> bulio|: haskell is quite hard, and not directed toward newbie programmers
13:33:18 <newsham> i know debug trace.
13:33:23 <newsham> that was just one of many examples
13:33:26 <ihope> Is sum strict?
13:33:27 <caust1c> hi
13:33:27 <newsham> debug.trace does not generalize
13:33:31 <ski> (newsham : note btw that that above was a quote :)
13:33:35 <SamB> newsham: so?
13:33:39 <xsdnyd> glguy, yeah, i only want the third root of 2... 
13:33:41 <EvilTerran> ihope, could it not be strict?
13:33:44 <newsham> what if I want to keep statistics in my code that wasnt designed to keep state?
13:33:48 <caust1c> does ghc always produce C code from haskell code and compiles it?
13:33:55 <EvilTerran> @src sum
13:33:55 <lambdabot> sum = foldl (+) 0
13:33:56 <newsham> there's no "debug.trace" like thing for that
13:33:58 <SamB> newsham: you should have newtyped your monad
13:33:58 <quicksilver> xs	xs
13:34:04 <opqdonut> yep
13:34:05 <ihope> foldl isn't strict, is it?
13:34:08 <glguy> xsdnyd: that isn't a rational
13:34:08 <oerjan> ihope: no
13:34:16 <ihope> Why isn't it strict?
13:34:16 <opqdonut> ihope: foldl' is 
13:34:20 <newsham> samb: i'm aware of how to do this.  its just not a trivial modification.
13:34:23 <ihope> sum, I mean.
13:34:24 <xsdnyd> quicksilver, how do i calculate a cube root, even as float or double?
13:34:26 <quicksilver> xsdnyd: syou can get an approximate answer, of course
13:34:32 <quicksilver> xsdnyd: I just showed you
13:34:34 <quicksilver> > 2 ** (1/3)
13:34:35 <lambdabot>  1.2599210498948732
13:34:36 <newsham> where as coding imperative style in other languages makes this a trivial operation
13:34:41 <sjanssen> ihope: I call it an oversight
13:34:44 <quicksilver> if you want that as an approximation Rational, then:
13:34:46 <SamB> newsham: or at least made a type synonym for it...
13:34:47 <newsham> coding in an imperative style in haskell leaves something to be desired
13:34:50 <quicksilver> > toRational (2 ** (1/3))
13:34:51 <lambdabot>  5674179970822795%4503599627370496
13:34:54 <SamB> hmm.
13:34:56 <SamB> this is true.
13:35:00 <EvilTerran> ihope, the foldl forces it to be a non-bottom list, and then the (+) forces each element to be a non-bottom number
13:35:02 <newsham> (but it has other strengths that more than compensate)
13:35:04 <quicksilver> but that's not very pretty
13:35:17 <SamB> it does, indeed, leave something to be desired
13:35:21 <ski> newsham : yes .. i agree some things could be better on that front
13:35:33 <SamB> however I must point out that this does not mean that it is not the world's finest imperative language
13:35:37 <xsdnyd> quicksilver, thanks that fit my needs :)
13:35:41 <MarcWeber> Do you think the haskell community is interested in links such as www.noooxml.org ( open standards etc ) ?
13:35:50 <SamB> ... it just means that there is probably room for improvement
13:35:55 <ihope> Noooooxml?
13:35:56 <EvilTerran> i imagine it's possible to write a Num instance in which (+) is non-strict in one argument, but it would not follow the laws of most numbers
13:35:59 <wli> You can always represent elements of algebraic number fields by indices into roots of their minimal polynomials and linear combinations with rational coefficients thereof.
13:36:18 <ihope> EvilTerran: easier to write one in which (*) is non-strict in one argument :-)
13:36:29 <ski> > "N" ++ repeat 'o' ++ "xml"  -- ?
13:36:30 <lambdabot>  "Noooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo...
13:36:30 <EvilTerran> 0 * _ = 0
13:36:48 <SamB> EvilTerran: how about signed magnitude based on Nats?
13:36:52 <EvilTerran> (Inf + _) = Inf ? =P
13:37:17 <wli> Significant nonstrictness can occur in the case of multiplying sparse elements of GL_n(R) for various rings R.
13:37:21 <EvilTerran> SamB, i don't know what you mean
13:37:40 <Nopik> ok, next question.. i have setPixel :: Point -> Color -> Image -> IO()   and getPixel :: Point -> Image -> IO Color   now i want to copy pixel: setPixel (10,10) (getPixel (20, 20) image) image and it says that IO Color do not match Color... how to fix that?
13:37:41 <SamB> data Nat = Zero | Succ Nat
13:37:42 <newsham> sequence (do {x <- [0..w]; y <- [0..h]; setPixel x y red pic})
13:38:19 <newsham> sequence [setPixel x y red pic| x <- [0..w], y <- [0..h]]
13:38:20 <SamB> data NatAndSign = Negative Nat | Positive Nat
13:38:31 <SamB> well, obviously that leaves you with tow kinds of zero...
13:38:37 <Nopik> @src sequence
13:38:37 <lambdabot> sequence ms = foldr k (return []) ms
13:38:37 <lambdabot>     where
13:38:37 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
13:38:38 <quicksilver> Nopik: setPixel (10,10) =<< getPixel (20,20) image
13:38:52 <SamB> but if you don't make that observable you're fine
13:38:54 <ski> Nopik : do color <- getPixel (20, 20) image; setPixel (10,10) color image
13:38:58 <opqdonut> Nopik: getPixel (20,20) image >>= \x -> setPixel (10,10) x image
13:38:59 <quicksilver> Nopik: because getPixel is monadic you have to 'bind' the value in place
13:39:07 <Nopik> ok, thanks
13:39:16 * quicksilver thinks his answer is the prettiest
13:39:21 <quicksilver> although perhaps the least easily generalised
13:39:40 <oerjan> quicksilver: it is also wrong, alas
13:39:41 <Nopik> quicksilver: i was just going to ask about >>= version :)
13:39:49 <quicksilver> oerjan: is it?
13:39:57 <MarcWeber> ihope, ski: This page reveals some bad things about the office open XML format which Microsoft wants to make an ISO standard.
13:39:59 <quicksilver> :t (=<<)
13:39:59 <ski> quicksilver : missing 'image'
13:40:01 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
13:40:11 <quicksilver> ski: ah. good point
13:40:12 * quicksilver cries
13:40:20 <quicksilver> beauty does not always prevail, alas :(
13:40:21 <EvilTerran> SamB, data Nat = One | Succ Nat; data Int' = Negative Nat | Zero | Positive Nat --?
13:40:49 <ihope> MarcWeber: well, if it's not Haskell-related...
13:40:53 <ski> MarcWeber : ok (hm, i didn't know *Microsoft* wanted to make OpenOffice things standard ..)
13:41:04 <ihope> Not to say that people who are interested in Haskell are interested only in Haskell.
13:41:10 <ski> quicksilver : maybe with 'ReaderT' ?
13:41:27 <EvilTerran> still, even with that aside, addition must surely be strict in both arguments for it to continue to be "addition" in any intuitive sense?
13:41:35 <wli> EvilTerran: data PositiveNat = One } TwoN PositiveNat | TwoNPlusOne PositiveNat please.
13:41:45 <ski> EvilTerran : why ?
13:41:58 <quicksilver> ski: yeah, although I find readerT is only worth the effort in rather special circumstances
13:42:05 <EvilTerran> well... because addition depends on both arguments... =/
13:42:18 <ski> quicksilver : .. yes
13:42:18 <quicksilver> ski: because lifting all the non-readerT-parts is annoying...
13:42:23 <ski> (indeed)
13:42:25 <SamB> wli: isn't that significantly less lazy?
13:42:28 <MarcWeber> ihope, ski You are propably right
13:42:29 <newsham> zero not natural?
13:42:46 <EvilTerran> addition on any field or vector space does, anyway, if i'm not completely confused.
13:42:54 <wli> SamB: Not sure how so.
13:42:54 <SamB> EvilTerran: but if you had fix (Succ) for the first argument...
13:42:56 <Nopik> heh, the only good thing from exposing newbie programmer to haskell is that he will find all other languages very easy ;)
13:43:05 <Nopik> very limited, too, perhaps ;p
13:43:23 <EvilTerran> SamB, then how would you tell that this were the case without running forever?
13:43:26 <SamB> but he will have a toolkit with which to design his own language...
13:43:34 <newsham> nopik: depends.  if you show newbie pure functional stuff (ie. two dozen short lessons in haskell), its all quite easy and makes more sense than most programming languages
13:43:36 <xsdnyd> i get an "No instance for (Floating Rational)" error, when using this code: "target   :: Rational -> Rational" and "target x = toRational (x ** (1/3))"... i don't know how to fix this :-\ may someone give me a hint? ;)
13:43:39 <SamB> EvilTerran: you wouldn't.
13:43:43 <newsham> its just all this wacky real-world stuff like doing IO :)
13:43:45 <ski> Zero + y = y; Succ x + y = Succ (y + x)
13:43:47 <EvilTerran> i mentioned Inf + _ = Inf earlier, anyway.
13:43:50 <quicksilver> ski: I often think about the kind of implicit lifting you'd need to make ReaderT reduce noise rather than adding it
13:43:52 <SamB> but you also would never notice if you tried to add it to _|_
13:44:02 <quicksilver> ski: but I can't think of anything sane
13:44:05 <EvilTerran> ...because the answer would be _|_
13:44:12 <SamB> uh, no
13:44:13 <Nopik> SamB: btw. any good example (tutorial-like) about writing own languages like this? i have seen few tutorials describe that this is possible, but none of them explained how ;P
13:44:21 <EvilTerran> "const undefined" is strict, etc
13:44:23 <SamB> because you'd never get to the _|_
13:44:24 <wli> EvilTerran: Direct sums of various sorts are partially lazy depending on how you represent them.
13:44:32 <newsham> ?google two dozen haskell
13:44:34 <Nopik> SamB: i suppose that monads do offer easy way to construct your own dsl..
13:44:35 <lambdabot> http://www.cs.ou.edu/cs1323h/textbook/haskell.shtml
13:44:36 <lambdabot> Title: Two Dozen Short Lessons in Haskell
13:44:52 <ski> @type (**)
13:44:54 <lambdabot> forall a. (Floating a) => a -> a -> a
13:44:59 <SamB> Nopik: we have parsers. we have algebraic datatypes. we have numerous language implementations to look at...
13:45:03 <EvilTerran> ohhh, i see. (fix Succ) + undefined could still be (fix Succ), if addition were appropriately defined.
13:45:05 <EvilTerran> i get it now.
13:45:05 <Heffalump> does hsql have a darcs repo?
13:45:08 <wli> EvilTerran: Sparse vectors, for instance, don't need to examine anything more than indices except where they collide in the elements being summed.
13:45:12 <newsham> nopik: there's "build scheme in 48 hrs"
13:45:13 <EvilTerran> **facepalm**
13:45:28 <Nopik> yeah, but this is just a parser
13:45:31 * EvilTerran hides.
13:45:31 <Heffalump> ah, google finds it, ask a silly question..
13:45:39 <Nopik> c++ also have parsers ;)
13:45:46 <SamB> we have *nice* parsers
13:45:56 <SamB> and algebraic datatypes to use for the results
13:45:56 <Nopik> ;)
13:46:01 <ski> xsdnyd : maybe .. s/x **/fromRational x **/
13:46:09 <Nopik> SamB: what is algebraic datatype?
13:46:12 <wli> EvilTerran: Addition of things like power series is also necessarily lazy.
13:46:16 <ski> @src Bool
13:46:17 <lambdabot> data Bool = False | True deriving (Eq, Ord)
13:46:21 <ski> @src Maybe
13:46:21 <lambdabot> data Maybe a = Nothing | Just a
13:46:23 <ski> @src []
13:46:24 <lambdabot> data [] a = [] | a : [a]
13:46:31 <SamB> @src HsExpr
13:46:31 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
13:46:32 <newsham> you can make nice ASTs with "data"
13:46:37 <SamB> @hoogle HsExpr
13:46:38 <lambdabot> No matches found
13:46:39 <Nopik> newsham: ok
13:46:41 <SamB> @hoogle Expr
13:46:41 <lambdabot> Text.ParserCombinators.Parsec.Expr :: module
13:46:41 <lambdabot> Text.ParserCombinators.Parsec.Expr.buildExpressionParser :: OperatorTable tok st a -> GenParser tok st a -> GenParser tok st a
13:46:44 <SamB> aww.
13:46:52 <newsham> blah, use a real parser generator.
13:47:02 <newsham> ?where happy
13:47:02 <lambdabot> http://www.haskell.org/happy/
13:47:06 <EvilTerran> wli, i have already acknowledged that i was talking rubbish. jeez. ;]
13:47:13 <SamB> newsham: I was looking for an example of an AST :-(
13:47:19 <oerjan> xsdnyd: http://en.wikipedia.org/wiki/Gelfond-Schneider_theorem
13:47:21 <_Nucleo> > Nothing >>= (\ x -> if (x == 0) then fail "zero" else Just (x + 1) )
13:47:22 <lambdabot> Title: Gelfond–Schneider theorem - Wikipedia, the free encyclopedia
13:47:23 <lambdabot>  Nothing
13:47:26 <oerjan> ;)
13:47:43 <oerjan> (in other words, 2^(1/3) is _not_ rational)
13:47:47 <Nopik> newsham: ok
13:48:07 <newsham> data If = If Expr Stmt Stmt
13:48:11 <oerjan> oh wait
13:49:05 <newsham> data Expr = Plus Expr Expr | ... | Var String | Val Integer
13:49:10 <oerjan> :t fromRational
13:49:12 <lambdabot> forall a. (Fractional a) => Rational -> a
13:49:16 <ski> data Expr = Var String | Lam String Expr | App Expr Expr
13:49:30 <oerjan> xsdnyd: you need to use fromRational x
13:50:15 <xsdnyd> oerjan, thanks that solved it!!
13:50:32 <wli> data RadicalNumber = Sum [(Rational {- linear coefficient -}, Rational {- exponent it's raised to -}, RadicalNumber)] | JustRational Rational ?
13:50:56 <newsham> stmt = If (Gte (Var "x") (Val 5)) (Print (Var x)) (Print (Val 2))
13:51:26 <newsham> (assuming Print is a Stmt)
13:53:19 <psi> anyone got this on os x? /usr/bin/ld: can't locate framework for: -framework GMP
13:53:29 <psi> i have it in ~/Library/Frameworks
13:53:42 <psi> oh, when using ghc.
13:55:32 <Nopik> newsham: nice
13:55:45 <psi> ok, /Library/Frameworks worked. although the installation instruction said both would be ok...
13:58:26 <newsham> nopik: as you can imagine, its really easy to build those up during parsing.
13:58:48 <newsham> and with pattern matching, really easy to deconstruct and walk over the results
13:59:14 <newsham> eval (Plus e1 e2) = eval e1 + eval e2
13:59:19 <newsham> eval (Val x) = x
13:59:20 <newsham> etc..
13:59:55 <_Sketch_> Any recommended projects to learn haskell with?
14:00:07 <wli> _Sketch: Write an interpreter.
14:00:14 <newsham> sketch: the problems in two dozen short lessons?
14:00:38 <Nopik> newsham: yeah, quite powerfull
14:01:20 <ski> http://www.haskell.org/~pairwise/intro/intro.html    -- might be useful if you know C
14:01:21 <lambdabot> Title: Haskell for C Programmers
14:01:32 <shapr> SamB: Want to be my facebook friend? What address are you using?
14:01:33 <Nopik> _Sketch_: i have just gone through 2-3 tutorials, found them quite handy
14:01:37 <ski> @where yaht
14:01:37 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
14:01:42 <kaol> how do I output arbitrary debug output in the middle of code? (ie. I want to do some printf debugging)
14:01:48 <_Sketch_> Wow, so much attention! :) Thank you all.
14:01:53 <Nopik> _Sketch_: yaht and 'gentle introduction to haskell' (in that order)
14:02:02 <SamB> shapr: naesten at gmail dot com
14:02:04 <ski> _Sketch_ : yaht above people say is quite good
14:02:21 <_Sketch_> ski: is there a non-PDF..?
14:02:37 <Nopik> _Sketch_: and when you will stuck at monads, try reading 'you could have invented monads' tutorial ;)
14:02:37 <ski> _Sketch_ : i'm not sure .. :/
14:02:52 <ski> @google you could have invented monads
14:02:52 <newsham> kaol: Debug.Trace
14:02:54 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
14:02:54 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
14:03:21 * ski thinks http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html is not so bad for monads, either
14:03:23 <lambdabot> Title: Online Tutorial: What the hell are Monads?, http://tinyurl.com/n8bqd
14:03:51 <ski> _Sketch_ : but one thing at a time ! monads *after* handling the basics
14:04:44 <shapr> Binkley: That was fast
14:04:55 <Binkley> heh
14:05:04 <ski> kaol : 'Debug.Trace.trace' ?
14:07:37 <wli> pdx.edu? I live in pdx.
14:07:41 <jedai> Could we use a "data" definition in GHCi
14:07:54 <jedai> ??
14:07:57 <shapr> jedai: hs-plugins?
14:07:59 <Binkley> wli: are you looking for an ICFP contest team, by chance? :-)
14:08:27 <jedai> shapr: You mean there's no way actually but it could be added ?
14:08:55 <newsham> jedai: :load ? :)
14:08:57 <wli> Binkley: No, I'm not likely to participate. I'm also not all that good a programmer.
14:09:03 <shapr> wli: I disagree.
14:09:21 <newsham> shapr: what's your team?
14:09:22 <SamB> wli: do you by any chance mean that *fast* a programmer?
14:09:33 <glguy> is a + in a URI always a space? or only after the '?' ?
14:09:38 <shapr> ICFP is next weekend, right?
14:09:44 <SamB> shapr: indeed
14:09:48 <jedai> newsham: Of course, but I'm searching for a way to define it directly in GHCi
14:09:52 <newsham> http://www.kingsrook.com/icfp/countdown.html
14:10:22 * Heffalump has no time for the contest :-(
14:10:41 <wli> SamB: No. As in capable of putting together larger programs, working with other people's code, code review, finding bugs, etc. Just shitting out code is not very meaningful.
14:10:44 <shapr> I've sacrificed my ICFP weekend to spend time with my Swedish girlfriend. I won't get to spend more than a few days with her for the next six months.
14:10:50 <jedai> newsham: It's not really a preoccupation for me (I use haskell-mode in emacs), but some have others idea
14:10:55 <SamB> wli: ah.
14:11:09 <SamB> wli: how do you even know this is going to be a "larger programs" contest"
14:11:13 <SamB> s/"//
14:11:17 <SamB> last one wasn't really
14:11:33 <shapr> wli: If I were part of a team, I'd gladly invite you :-)
14:11:40 <shapr> newsham: What team are you on?
14:11:44 <wli> SamB: That aspect of being a good programmer isn't necessarily pertinent to ICFP. The others are more so.
14:11:50 <Nafai> When is the ICFP contest?
14:11:55 <shapr> Nafai: Upcoming weekend.
14:11:59 <Nafai> Ah
14:12:36 <SamB> wli: perhaps you should join my team?
14:12:53 * SamB is thinking of trying to attack the contest problem after the contest is ofver
14:12:54 <newsham> shapr: flying solo (unless some of my friends decide to help out)
14:12:55 <wli> SamB: I don't think it's a good idea.
14:13:04 <newsham> also gotta help someone move half of saturday,s o i my not complete
14:13:15 <Nopik> lets assume that there is image, and you have getPixel :: Point -> Image -> IO Color is it possible to write findPixel :: Color -> Point without any IO infection?
14:13:19 <wli> newsham: Is what you're doing an interpreter assignment somewhere?
14:13:38 <newsham> wli: no, talking with nopik about ASTs in haskell
14:13:46 <scsibug> Nopik: did you ever implement getPixel for GD?
14:13:49 <Nafai> wli: Why isn't it a good idea to try it later?
14:13:55 <Nopik> scsibug: yeah, it was straightforward
14:14:06 <SamB> wli: with what I just /me'd in mind, do you still think it sounds like a bad idea?
14:14:23 <Nopik> scsibug: just copy/paste from setPixel and slightly modify argument list
14:14:30 <scsibug> Nopik: make sure you darcs send your changes to bringert
14:14:46 <wli> SamB: My day job is demanding enough I can't really focus on anything, though right now I'm just letting compiles spin.
14:14:51 <Nopik> scsibug: i would need to setup darcs first ;p
14:15:10 <wli> SamB: (and, of course, partially blowing things off)
14:15:14 <SamB> last contest I think I had my UM working maybe an hour after the contest was over (I started beforre it was ove ;-)
14:15:23 <scsibug> Nopik: just sending a simple patch would probably be fine
14:15:30 <Nopik> scsibug: yeah, i think so
14:15:51 <Nopik> scsibug: going back to my problem.. do i need to infect all my functions with IO?
14:16:17 <scsibug> Nopik: not sure what your problem was (just got back from work), but if you are talking about GD, then yes, most likely
14:16:22 <ski> Nopik : what should 'findPixel :: Color -> Point' do ?
14:16:30 <scsibug> anything that directly messes with images
14:17:04 <SamB> scsibug: so why would anyone want ot use GD then??
14:17:13 <Nopik> ski: just find any pixel with given color and return its position (ok, Maybe Point as return could do)
14:17:37 <ski> Nopik : any pixel in which image ?
14:17:41 <Nopik> ski: actually it doesnt matter, i was just asking if i can get rid of IO in function
14:17:51 <Nopik> ski: of given color, if such exists
14:18:07 <ski> (sorry .. in *which*image* ?)
14:18:25 <Nopik> ah, findPixel :: Color -> Image -> Maybe Point
14:18:41 <Nopik> ski: though it is not related to my question :D
14:18:46 <SamB> Nopik: wouldn't it be far cleaner to just return an Image Bool?
14:18:56 <scsibug> SamB: I'm not sure what you mean...
14:18:58 <Nopik> Image Bool ?
14:18:59 <ski> Nopik : ok .. well, in case the underlying image referred to by 'Image' is immutable, then yes, otherwise no. i think
14:18:59 <msouth> _Sketch_: didn't see if anyone got you this: http://en.wikibooks.org/wiki/Haskell/YAHT
14:19:01 <lambdabot> Title: Haskell/YAHT - Wikibooks, collection of open-content textbooks
14:19:32 <Nopik> ski: i just want to read image, do not need to mutate it
14:19:51 <ski> Nopik : ok, if you never mutate the image, then it should be ok
14:20:18 * SamB is making things up
14:21:06 * scsibug is a bit lost too... Nopik, is there a specific question you had that you could repeat?
14:21:38 <Nopik> scsibug: yeah.. i was just asking if i can write functions operating on plain Color instead of IO Color
14:21:49 <Nopik> which probably is true as i can always lift those
14:21:54 <scsibug> indeed
14:22:09 <scsibug> I've got functions in my fractal program which work on Color types
14:22:25 <Nopik> hm, let me see
14:22:51 <scsibug> http://scsibug.com/fractal-hs/burning_ship.hs
14:23:05 <scsibug> there are a couple pure functions in there involving color
14:25:04 <Nopik> scsibug: though most probably drawPlot accepts plain Color and draws it
14:25:41 <scsibug> drawPlot takes a function mapping coordinates to colors (which is pure)
14:26:03 <Nopik> scsibug: yeah, though this is simpler case than mine
14:26:04 <scsibug> so drawPlot does handle all the nasty IO interaction with GD
14:26:33 <Nopik> anyway i'll try do my way, at the worst i will have just more questions :)
14:26:49 <Nopik> though most likely i will do it tomorrow - as it is time to sleep for me ;p
14:26:56 <scsibug> ok, take care, and good luck
14:27:17 <Souwh> Hello
14:27:26 <scsibug> howdy
14:27:27 <shapr> hi Souwh
14:29:22 <hpaste>  ski pasted "not safe for program" at http://hpaste.org/1719
14:29:39 <ski> Nopik : ^
14:32:05 <shapr> Souwh: Written any Haskell code lately?
14:33:33 <scsibug> has anyone successfully gotten wxWidgets/wxHaskell working on OS X lately?
14:34:29 <scsibug> I can get everything to compile, but I get unresolved symbols when I actually try to run a program :(
14:40:00 <_Nucleo> did the old wiki just disappear?
14:43:22 <monochrom> The old wiki cannot disappear yet. But it's no longer updated.
14:43:40 <Figs> hi
14:43:57 <_Nucleo> for some reason I get 404s, e.g. here: http://haskell.org/hawiki/TailRecursive
14:44:31 <SamB> if i has disappered, some mainmiogns are in order
14:44:35 <SamB> s/i/it/
14:44:46 <Figs> does anyone understand left-recursion well?
14:45:47 <shapr> Looks like someone got rid of the old hawiki entirely.
14:45:54 <shapr> "The requested URL /hawiki/ was not found on this server."
14:45:58 <_Nucleo> yeah, that's not good.
14:46:02 <SamB> maimings!
14:46:29 <shapr> kolmodin: I'm confused about this whole "you have been a member of haskell since year X" bit on Facebook.
14:46:32 <monochrom> Hrm! All of hawiki has 404ed!
14:46:32 <SamB> unless it was an accident
14:46:36 <Igloo> We had 2 people getting confused by old, incorrect info on old pages in 2 days, so I removed the alias
14:46:42 * Figs takes that as a 'not at the moment.'
14:46:47 <SamB> Igloo: "alias"?
14:46:49 <Figs> ok, bbl
14:46:59 <Vulpyne> figs: I'd go ahead and ask the question if I were you.
14:47:05 <Igloo> Alias /hawiki /mumble/moinmoin.cgi
14:47:06 <Figs> it's kind of OT
14:47:07 <_Nucleo> mm, sure hope it's coming back
14:47:18 <Vulpyne> Ah.
14:47:19 <Figs> or I should say "really" OT :)
14:47:50 <monochrom> http://www.haskell.org/mumble/moinmoin.cgi still doesn't work
14:48:01 <SamB> Igloo: so we can find it at www.haskell.org/mumble/moinmoin.cgi?TailRecursive ?
14:48:23 <Figs> basically, I'm working on a C++ parser library, and when I came to get feedback from people here yesterday (since you guys usually have a different perspective on things) ddarius, I think it was, pointed out that since I'm using recursive descent, left-recursion will fail.
14:48:42 <Igloo> No, "mumble" just means I can't remember what it was. But the old wiki was dead anyway. It was announced that it would be removed ages ago
14:48:42 <SamB> Igloo: I think you should place a script there that will redirect people after subjecting them to a blinking disclaimer
14:49:03 <SamB> Igloo: and we still haven't managed to copy much over...
14:49:18 <SamB> largely because of license issues, afaik
14:49:22 <Igloo> http://groups.google.com/group/fa.haskell/browse_thread/thread/94212312bd35555d
14:49:24 <lambdabot> Title: HaWiki closing in one month; migrate content to HaskellWiki now! - fa.haskell |  ..., http://tinyurl.com/2nx5sw
14:49:33 <CosmicRay> gtk2hs is so awesome.  this is the first time I've ever enjoyed gui programming.
14:49:36 <Igloo> If you haven't managed by now, you probably never would have done
14:49:37 <Vulpyne> Figs: I'm not smart enough to help you, unfortunately.
14:49:45 <Figs> Ah :(
14:49:58 <CosmicRay> http://hg.complete.org/gtkrsync/raw-file/44d245cdab4d/screenshot2.png
14:49:58 <_Nucleo> So that content is gone, then.
14:50:00 <lambdabot> http://tinyurl.com/35y6rg
14:50:04 <Cale> http://en.wikipedia.org/wiki/Left_recursion
14:50:05 <lambdabot> Title: Left recursion - Wikipedia, the free encyclopedia
14:50:11 <Figs> I've read it cale :)
14:50:22 <kolmodin> shapr: in the haskell group?
14:50:29 <kolmodin> or what I said?
14:50:57 <Figs> but it doesn't help me much thinking about Z = A >> ( opt(by_ref(Z)) >> B) >> C unfortunately
14:51:13 <Figs> or I should say opt(by_ref(Z)) << B
14:51:26 <shapr> kolmodin: Your response said "member of haskell community since 2005" and I can't tell whether that applies to me, you, or both.
14:51:46 <Figs> Z = A >> (opt(by_ref(Z)) << B) >> C
14:51:48 <Figs> that's what I meant
14:52:01 <monochrom> Eh? What's wrong with Z = A >> ( opt(by_ref(Z)) >> B) >> C?
14:52:14 <Figs> I'm talking about left recursion
14:52:17 <SamB> I found some interesting informmation on the old wiki just the other day...
14:52:23 <monochrom> That is not left recursion.
14:52:27 <kolmodin> it's where we met. or at least that's how I interpret how it works
14:52:32 <Figs> A (Z b) c
14:52:36 <shapr> kolmodin: Ok, works for me.
14:52:39 <Cale> Could be if A is nullable
14:52:40 <_Nucleo> SamB: I'll mostly miss the quotes page ;)
14:52:42 <Figs> a (a Z b c) b c
14:52:51 <kolmodin> shapr: it was actually you who introduced me to this channel :D
14:52:58 <Figs> aa(a Z bc)bc
14:53:08 <kolmodin> shapr: a little more than two years ago...
14:53:23 <Cale> Figs: that's okay, so long as A doesn't match the empty string
14:53:35 <kolmodin> when waern and me and others where working on haste
14:53:42 <kolmodin> hi waern :D
14:53:49 <Figs> well, even supposing that A did match it, 
14:53:58 <Figs> the opt() would ensure it terminates
14:54:04 <monochrom> The input string to parse cannot contain infinitely many 'a's
14:54:06 <shapr> kolmodin: Wow, cool!
14:54:16 <waern> kolmodin: hi there
14:54:20 <Figs> exactly
14:54:27 <Figs> so as long as it has
14:54:41 <Figs> bcbcbcbcbc... for a finite number
14:54:43 <monochrom> The recursion is no deeper than the number of 'a's present at the beginning of the input string.
14:54:53 <Figs> it should still match regardless of whether A is "" or not
14:54:56 <kolmodin> shapr: you asked what I was doing, more or less. I told you guys about haste and there was great excitement :D
14:55:28 <Cale> Figs: I generally think it's okay to make people rewrite grammars so they're not left-recursive.
14:55:44 <Cale> Though you can provide tools to help with that.
14:55:52 <Figs> how to deal with the left-associativity issue?
14:56:31 <waern> kolmodin: how's code?
14:56:56 <SamB> Igloo: a lot of good it does to declare our posts to the old wiki SPL'd if you take it down days later :-(
14:57:17 <kolmodin> waern: not much haskell the past months I'm afraid :(
14:57:51 <kolmodin> waern: much more gentoo work. we have made yet a turn to get ghc 6.6 and 6.6.1 into the tree, yet a new master plan :D
14:58:08 <Cale> For example, in parsec, there's a combinator called chainl such that (chainl p op x) parses zero or more occurrences of p, separated by op, returning a left associative application of all functions returned by op to the values returned by p (using x when there are zero occurrences of p)
14:58:36 <Cale> (p and op are parsers)
14:59:22 <Cale> So that helps eliminate left recursion whenever it would have come up.
14:59:24 <kolmodin> shapr: hit the Friends link at the top. under details you will see: You have been members of Haskell Community since 2005.
14:59:47 <Cale> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#chainl -- see the example here
15:00:17 <kolmodin> waern: how about you?
15:00:27 <kolmodin> code progressing? :)
15:00:28 <waern> kolmodin: heh... will 6.8 take less time to package? :)
15:00:36 <kolmodin> haha :D yes
15:00:45 <waern> kolmodin: mostly exjobb
15:00:46 <kolmodin> we will have fought the major fight by then :D
15:00:56 <Figs> ok
15:01:15 <Figs> it might just make more sense for me to write a special left parser
15:01:21 <kolmodin> the "trouble" has been that ghc split out many libs into separate packages
15:01:35 <kolmodin> and that we then decided to do a few more changes we have been thinking of
15:01:47 <kolmodin> neither of us are working full time on this :)
15:02:35 <Cale> Figs: Automatically rewriting parsers so that they avoid left-recursion takes quite a bit of introspection, and so it's only typically done by tools which generate parsers statically, if at all.
15:03:00 <Figs> Cale, I can just do something like this:
15:03:01 <waern> kolmodin: ok
15:03:11 <Figs> foo >> left(A << B << C) >> X;
15:03:34 <kolmodin> waern: so how is the exjobb progressing? haskell?
15:03:54 <waern> kolmodin: ok I guess. haskell :)
15:04:07 <kolmodin> aw maaaj gaaad! I wish I could have used haskell too :D
15:04:29 <Cale> exjobb?
15:04:32 <waern> well.. it's pretty boring anyway
15:04:37 <kolmodin> exjobb = master thesis
15:04:46 <Cale> ah
15:04:51 <Figs> I think the left recursion object would be very slow though in my parser
15:05:06 <kolmodin> waern: imagine boring master thesis + java. compare that to boring master thesis + haskell. make your choice!
15:05:17 <waern> hehe
15:05:24 <kolmodin> see? you have to put things in perspective :D
15:08:28 <Figs> ok, well thanks
15:08:37 <Figs> I'm going to go play with it for a while
15:08:38 <Figs> bbl
15:10:30 * ddarius owns "Categories for the Working Mathematician" now.
15:16:53 <astrolabe> I've got one too.  I just need to read it.
15:21:06 <ddarius> Oh, I'll read it.
15:24:22 <Binkley> ?quote
15:24:22 <lambdabot> ihope says: Laziness is free, but it doesn't always pay off.
15:25:01 <ihope> Whoa, it's my quote!
15:25:04 <ihope> :-P
15:28:42 <kjdf> how does "newtype" differ from "data" declaration?
15:31:57 <EvilTerran> kjdf, given "newtype Foo a = Foo a; data Bar a = Bar a", Foo undefined is indistinguishable from undefined, but Bar undefined can still match a pattern of the form "Bar x"
15:32:18 <EvilTerran> you can only have one constructor of one argument on a newtype
15:33:18 <EvilTerran> (these are both caused by "Foo a" being effectively just "a" at runtime)
15:33:53 <kjdf> and Bar is wrapped around?
15:34:01 <Saizan> also case undefined of Foo _ -> 0 == 0, case undefined of Bar _ -> 0 == undefined
15:34:05 <EvilTerran> and GHC can derive anything for a newtype that's instantiated by the argument
15:34:42 <kjdf> hm
15:34:50 <EvilTerran> kjdf, yes, at runtime, "Bar x" would be stored differently from just "x"
15:35:01 <kjdf> and what do you mean by derive?
15:35:28 <EvilTerran> newtype MyInt = MyInt Int deriving (Eq, Ord, Integral, Num, Ix...)
15:35:44 <kjdf> and with data it is not possible?
15:36:10 <EvilTerran> you can't normally say "deriving Num" (for example), but GHC lets you in the case of a newtype
15:36:21 <EvilTerran> you may need -fglasgow-exts for this, i forget.
15:36:50 <kjdf> ok
15:36:52 <kjdf> thanks
15:36:59 <EvilTerran> np =)
15:38:10 <EvilTerran> BTW, another way of thinking about my first point (and Saizan's point) is that a newtype constructor is strict in its argument
15:38:15 <EvilTerran> i think
15:43:08 <sioraiocht> is parsec a recursive descent parser?
15:44:06 <oerjan> it can be used that way.
15:44:52 <oerjan> but it can also do arbitrary backtracking
15:46:32 * SamB wonders about the utility of this "Poke her" link on his sister's facebook page.
15:46:41 <oerjan> er, i'm not sure whether recursive descent includes that. but parsec parsers are generally written recursively.
15:46:47 * SamB thinks if he wanted to poke her... he would just poke her...
15:48:04 <oerjan> SamB: one day, you will be on a different continent than her, and then that link will be very useful.
15:48:08 <monochrom> More generally, you should wonder the utility of facebook altogether. But I digress.
15:48:37 <SamB> monochrom: well you can get away with writing on the walls without getting in any trouble or having to clean it up
15:48:41 <Philippa> oerjan: "recursive descent with backtracking" is sometimes considered to come under the general heading of "recursive descent" anyway
15:49:02 <oerjan> Philippa: that was what i was wondering, thanks
15:52:53 <newsham> poke her?  sister?  ewww.
15:53:28 <EvilTerran> what's the matter, newsham? it's not your business if he happens to like nuns...
15:53:46 <newsham> blue nuns of the revolution?
15:55:25 * EvilTerran tries to envisage "nun of revolution" as in "surface of revolution"
16:03:33 <SamB> so... it looks like JHC is adopting PNG format for it's object files ;-)
16:04:10 <oerjan> creative.
16:04:32 <SamB> well, actually, *adapting*
16:06:36 <monochrom> @quote undefined
16:06:37 <lambdabot> No quotes match. It can only be attributed to human error.
16:10:13 <oerjan> @quote undefined
16:10:14 <lambdabot> No quotes match. I've seen penguins that can type better than that.
16:11:00 <oerjan> @quote quotes.match
16:11:00 <lambdabot> No quotes match. My pet ferret can type better than you!
16:11:09 <oerjan> @quote quotes.match
16:11:10 <lambdabot> No quotes match. That's something I cannot allow to happen.
16:12:18 <SamB> apparantly John believes that such a format will lazy reading?
16:12:21 <SamB> er.
16:12:26 <SamB> insert "enable"
16:15:13 <oerjan> persistent laziness?
16:17:02 <chessguy> @undo do { b <- o; if b then (e x) else (e y) }
16:17:02 <lambdabot> o >>= \ b -> if b then (e x) else (e y)
16:17:30 <chessguy> @pl e x y =  o >>= \ b -> if b then (e x) else (e y)
16:17:30 <lambdabot> e = fix ((((o >>=) .) .) . (flip =<< (((.) . flip . flip if') .)))
16:19:54 <chessguy> @pl f x n xs = take (n-1) xs ++ x ++ drop n xs
16:19:55 <lambdabot> f = ap (ap . ((++) .) . take . subtract 1) . (. drop) . (.) . (++)
16:30:13 <msouth> read "5" gives me an error in ghci
16:30:24 <msouth> but read "5" + 3 works
16:30:35 <oerjan> > read "5"
16:30:37 <lambdabot>  5
16:30:37 <msouth> and lambdabot is happy with read "5"
16:30:51 <newsham> > read "5" :: Int
16:30:52 <lambdabot>  5
16:31:01 <newsham> try giving it a hint about what you want
16:31:03 <msouth> that works
16:31:03 <Excedrin> msouth: what error? (it's obv because you need to add a type annotation)
16:31:08 <oerjan> msouth: there was someone today complaining that 6.7 defaults to ()
16:31:27 <newsham> ?type read
16:31:29 <lambdabot> forall a. (Read a) => String -> a
16:31:55 <msouth> so the + 3 hints that I want some kind of number
16:31:57 <newsham> ?type read "5"
16:31:59 <lambdabot> forall a. (Read a) => a
16:32:20 <newsham> ?type read "5" + 3
16:32:22 <lambdabot> forall a. (Read a, Num a) => a
16:32:24 <Excedrin> + 3 causes type inference to constrain the result of read to (Num a)
16:32:54 <oerjan> which removes the possible () default option
16:32:54 <newsham> > read "5" :: Char
16:32:56 <lambdabot>  Exception: Prelude.read: no parse
16:33:40 <oerjan> msouth: try let x = read "5" and then :t x
16:33:46 <Excedrin> > read "'5'" :: Char
16:33:47 <lambdabot>  '5'
16:33:53 <oerjan> then you can see what type it defaults to
16:34:17 <msouth> ambiguous
16:34:21 <msouth> type variable
16:34:22 <msouth> it says
16:34:34 <msouth> at least it's consistent
16:34:54 <oerjan> oh, so you are not getting a "no parse" error?
16:35:30 <msouth> @paste Prelude> let x=read "5"
16:35:30 <msouth> <interactive>:1:6:
16:35:30 <msouth>     Ambiguous type variable `a' in the constraint:
16:35:30 <msouth>       `Read a' arising from use of `read' at <interactive>:1:6-13
16:35:30 <msouth>     Probable fix: add a type signature that fixes these type variable(s)
16:35:30 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:35:32 <msouth> sorry
16:36:19 <hpaste>  msouth pasted "read "5" question" at http://hpaste.org/1720
16:36:20 <Excedrin> I'm not sure why you'd use let and then check the type..
16:36:24 <oerjan> sounds like you have _no_ defaulting
16:36:30 <Excedrin> you can definitely use :t read "5"
16:36:37 <Excedrin> or just :t read
16:36:43 <msouth> yes
16:37:00 <oerjan> Excedrin: i thought that would not give the defaulting result
16:38:05 <msouth> is it better for me to run with -fglasgow-exts
16:38:06 <msouth> ?
16:38:26 <oerjan> msouth: what ghci version?
16:38:48 <msouth> GHC Interactive, version 6.6, for Haskell 98.
16:38:59 <msouth> I'm on os x if that matters
16:39:00 <Excedrin> if you need exts :)
16:39:26 <oerjan> i'm not knowledgable enough for that :|
16:39:35 <msouth> well, I'm just wondering because the type stuff comes out differently
16:39:45 <msouth> like is it better for me to be used to that forall a. stuff.
16:40:03 <msouth> my understanding is still pretty limited as I just started this a couple of days ago.
16:40:03 <oerjan> the type stuff might be without applying the monomorphism restriction and defaults
16:40:38 <oerjan> however, it _should_ default to Integer, and work, as far as i know
16:41:23 <Excedrin> hmm, in what context does read default to Integer?
16:42:03 <Excedrin> (or is that not what you meant...)
16:42:10 <oerjan> Excedrin: when bound by a simple pattern binding, you get the m.r. and (Integer,Double) is the default defaulting
16:43:12 <shapr> SamB: I wonder if facebook needs a #haskell group
16:43:18 <Binkley> good idea
16:44:47 <Nafai> I joined a Haskell group earlier
16:44:57 <Nafai> But I would join a #haskell group
16:45:13 <Excedrin> oerjan: I see, but that's for the default type of numbers, not related to read's type
16:45:14 <SamB> ditto
16:45:23 <SamB> where by "earlier", I mean "earlier today"
16:45:23 <oerjan> oh right.
16:45:38 <oerjan> ah, i forgot that.
16:46:01 <oerjan> msouth: what you got is actually the "correct" behavior!
16:46:05 <SamB> oerjan: however lambdabot uses stronger defaulting, I think it's the same rules as GHCi
16:46:12 <Nafai> SamB: yes :)  
16:46:16 <Binkley> I created a #haskell group
16:46:16 <Excedrin> and yes, "let x = 4" followed by ":t x" results in x::Integer
16:46:19 <Binkley> join away :-)
16:46:39 <oerjan> you may want to start with an option -fextended-defaulting-rules or something like that
16:46:51 <SamB> man that was easy
16:46:51 <Excedrin> can you change the default types in ghci interactively?
16:46:56 <SamB> I didn't even have to search for it
16:47:18 <SamB> *Science*?
16:47:53 <SamB> wait, shapr just made one...
16:47:56 <oerjan> i think there is a command to set flags. :f maybe?
16:48:00 <shapr> SamB: And you already joined!
16:48:41 <SamB> yes. but where is binkley's?
16:48:47 <shapr> I dunno
16:48:52 <Excedrin> there's -<flags> but I'm not sure if there's a way to do: "default (Int,Float)" via a flag
16:49:03 <shapr> Already joined
16:49:09 <Binkley> I'll put a link to the other one in mine
16:49:11 <Binkley> we don't need two :-)
16:49:32 <oerjan> Excedrin: msouth's problem is not about that setting though
16:49:40 <SamB> whoo
16:49:43 <SamB> I'm an admin
16:49:45 <Excedrin> I know, just curious about defaults in general
16:50:16 <Nafai> Yay!
16:51:12 <oerjan> i recall i saw just today something when browsing the manual about ghci not using the defaults from the module.
16:51:13 <SamB> @tell sjanssen we just formed a #haskell group on facebook
16:51:14 <lambdabot> Consider it noted.
16:51:49 <Binkley> haha, I hadn't seen the photo of SPJ on a unicycle
16:52:15 * shapr grins
16:52:20 <shapr> On *my* unicycle even!
16:52:54 <SamB> who's that on the right?
16:53:10 <shapr> dcoutts
16:53:20 <shapr> The photo should have names.
16:53:30 <SamB> yes! who will caption it?
16:53:58 <shapr> Hm, I added names of the people, dunno why it doesn't show up.
16:54:43 <msouth> so :t - read "5" has type (Num a, Read a) => a, that means....here's my guess--the thing in quotes must be something in the Num family of types and also in the Read family of types, and it's going to give me back one of those?
16:55:03 <msouth> and it was because of the - that it added the Num on there?
16:55:20 <msouth> you guys will kickban me if I ask too many annoying newbie questions, right?
16:55:49 <SamB> oops.
16:55:57 <SamB> now we have two sets of captions...
16:56:03 <Binkley> silly facebook
16:56:04 <SamB> but I put in the IRC nicks
16:56:13 <shapr> msouth: Nah, we'll just promote you.
16:56:14 <Botje> msouth: you are correct, and no, you won't get kicked. ask away :)
16:56:36 <shapr> msouth: Once we've answered enough of your questions, you get promoted to "able to answer questions for others."
16:57:00 <Binkley> is that John Hughes in the other photo?
16:57:06 <monochrom> read "5" alone has type (Read a) => a. If you also have Num it is due to other context.
16:57:09 <msouth> first I'll be promoted to "thinks he knows the answers and gets them almost right then has to be corrected"
16:57:15 <shapr> Binkley: Yup
16:57:42 <monochrom> @type read
16:57:44 <lambdabot> forall a. (Read a) => String -> a
16:59:54 <shapr> edwinb: Mind if I steal and republish some of your photos?
17:00:10 * edwinb spots photos of unicyclists
17:00:20 <edwinb> shapr: no problem, I was just digging out some to uplaod ;)
17:01:05 <shapr> You can do it if you'd prefer :-)
17:01:13 <edwinb> doesn't really matter ;)
17:02:40 <newsham> ?src read Int
17:02:40 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
17:02:42 * SamB made shapr an officer
17:02:45 <shapr> yay!
17:02:46 <Cale> msouth: We like beginners here. Often they get answered in stereo.
17:03:15 * edwinb wonders what happened to the one he just uploaded
17:03:18 <SamB> shapr: the only thing I could think of that (a) I could spell and (b) didn't sound to ridiculous was "Founder"
17:03:31 <Cale> msouth: It means that the whole expression has to be both a type which is numeric and readable.
17:03:33 <newsham> flounder and ceo
17:03:38 <msouth> The meaning of forall a. (Read a) => String -> a is "if I have a thing whose type is an instance of the Read class, then ... I'll take a string and give you a thing of that type"
17:03:46 <shapr> SamB: Works for me.
17:03:50 <Cale> absolutely, right
17:04:12 <Cale> But you have to pick a type first, before it will know what code to use to parse it.
17:04:13 <newsham> one thing about "read" is that "read x :: Int" is a different function than "read x :: String"
17:04:19 <monochrom> No. "if I have a thing" is wrong.
17:04:24 <newsham> so if the compiler cant figure out what type you want, it doenst know what function to use
17:04:46 <newsham> > read "5" :: Int
17:04:48 <lambdabot>  5
17:04:48 <Cale> Oh, monochrom is right, that's a bit awkwardly worded.
17:04:55 <newsham> >read "5" :: Char
17:05:12 <monochrom> "if I have a type" is right. "if I have a thing of a type" is wrong.
17:05:29 <Cale> If 'a' is a type in the class Read, then read will take a String and give a value of type a
17:05:45 <newsham> forall a. (Read a) => String -> a   means "I'm a function that takes a string and returns something that must be a kind of "Read"
17:05:55 <Cale> > read "[1,2,3]" :: [Integer]
17:05:57 <lambdabot>  [1,2,3]
17:06:01 <Cale> > read "[1,2,3]" :: Integer
17:06:02 <lambdabot>  Exception: Prelude.read: no parse
17:06:13 <Cale> > read "[1,2,3]" :: [Float]
17:06:14 <lambdabot>  [1.0,2.0,3.0]
17:06:35 <newsham> Integer is a kind of Read.
17:06:37 <Cale> Which code is used to parse the thing is dependent on which type of value is ultimately demanded.
17:07:06 <msouth> ok, this tells us that Integer defines something to do when you call read on something having that type
17:07:09 <Cale> > read "[1,2,3]" :: Int -> Int
17:07:10 <lambdabot>   add an instance declaration for (Read (Int -> Int))
17:07:10 <lambdabot>     In the expression: ...
17:07:14 <monochrom> Although read "[1,2,3]" :: Integer is a parse error, the type is valid. It's only the code being run that says it doesn't like the string.
17:07:34 <Cale> msouth: You call read on a String, always, but you can *ask* read to give you various types.
17:08:03 <Cale> msouth: and whether parsing succeeds on not, then depends on the content of the string, at runtime
17:08:12 <newsham> insteace Read Integer where read x = convertStringToInt x
17:09:50 <Cale> msouth: The funny thing is that polymorphism in the result type is sort of strange, because the function application itself doesn't provide enough information on its own to say what the value will be.
17:10:10 <Cale> You need context from the surrounding program about what type is being asked for there.
17:10:24 <monochrom> That is not the way to write Read instances, newsham.
17:10:31 <msouth> so those :: foo are applied like ( read "5" ) :: Int
17:10:51 <newsham> mono: do you want to describe readsPrec to msouth?
17:11:01 <Cale> msouth: In one liners, yeah. Usually in a real program, you'll have enough context for it to work out what types you want.
17:11:22 <monochrom> No. But I don't want to lie either.
17:11:37 <newsham> the ":: Int" tells haskell the type of the previous expression.  often haskell can figure it out on its own.
17:11:43 <newsham> sometimes what it figures out is not precise.
17:12:02 <newsham> > 5 :: Int
17:12:03 <lambdabot>  5
17:12:06 <newsham> > 5 :: Float
17:12:09 <lambdabot>  5.0
17:12:13 <newsham> ?type 5
17:12:14 <Cale> > let x = 5 :: Int in read "10" + x
17:12:15 <lambdabot> forall t. (Num t) => t
17:12:16 <lambdabot>  15
17:12:20 <newsham> ?type (5 :: Int)
17:12:22 <lambdabot> Int
17:13:19 <msouth> ok, now I'm trying to wrap my head around what it means to ask for the type of read "5"
17:13:37 <Cale> msouth: See, in that little program, I added the result of (read "10") to x which it was told was an Int
17:13:52 <monochrom> The programmer has to set its type up.
17:13:58 <msouth> Cale: yes, that made sense to me
17:13:58 <Cale> So it inferred that what I wanted it to read also must be an Int, and applied a parser for Ints.
17:14:07 <Cale> Okay
17:14:34 <newsham> maybe it would be easier to start off descibing something like "show" before describing "read"
17:14:44 <monochrom> Here is a counterexample.  show (read "5")  computer cannot infer its types unless the human really helps.
17:15:01 <Cale> So when you ask for the type of (read "5"), it can't actually completely determine the type, but it will tell you a property the type must have, namely, an instance of the Read class.
17:15:21 <Cale> :t read "5"
17:15:27 <lambdabot> forall a. (Read a) => a
17:16:07 <Cale> It says: this could be anything for which there is an instance of Read.
17:16:17 <msouth> and that is talking about what read "5" is going to give me back
17:16:19 <msouth> ah
17:16:21 <msouth> ok
17:16:28 <Cale> when you did:
17:16:32 <Cale> :t - (read "5")
17:16:39 <lambdabot> forall a. (Num a, Read a) => a
17:16:44 <Cale> ... lambdabot is slow tonight...
17:16:59 <Cale> It knows, because of the - sign, that it also has to be a kind of number.
17:16:59 <msouth> it inferred from that - that I was going to need it to be numeric
17:17:02 <Cale> right
17:17:21 <newsham> :t (5 :: int) - (read "5")
17:17:23 <lambdabot>     No instance for (Num int)
17:17:23 <lambdabot>       arising from the literal `5' at <interactive>:1:1
17:17:27 <Cale> Int
17:17:29 <newsham> :t (5 :: Int) - (read "5")
17:17:34 <lambdabot> Int
17:17:41 <Cale> > (5 :: Int) - (read "5")
17:17:43 <lambdabot>  0
17:18:03 <Cale> :t (-)
17:18:05 <lambdabot> forall a. (Num a) => a -> a -> a
17:18:13 <newsham> now it knows 5 is an int, minus takes two numbers of the same type, so (read "5") must also be an Int
17:18:18 <EvilTerran> is it possible to express "make this (undefined) the same type as the return value of the function i'm in the process of defining"?
17:18:22 <Cale> The types of things being subtracted have to match, so if it knows one, it knows the other.
17:18:22 <msouth> how do you ask for the type of unary minus?
17:18:29 <EvilTerran> (i'm doing something hairy with typeclasses)
17:18:33 <Cale> :t (\x -> -x)
17:18:35 <lambdabot> forall a. (Num a) => a -> a
17:18:38 <newsham> if - is an infix funciton, then (-) is its (prefix) name
17:18:41 <oerjan> EvilTerran: asTypeOf
17:18:45 <newsham> > (+) 3 5
17:18:47 <lambdabot>  8
17:18:57 <newsham> :t (+)
17:18:58 <Cale> (unary minus is kind of a special case)
17:18:59 <lambdabot> forall a. (Num a) => a -> a -> a
17:19:23 <Cale> :t negate
17:19:25 <lambdabot> forall a. (Num a) => a -> a
17:19:30 <EvilTerran> @src negate
17:19:30 <lambdabot> negate x = 0 - x
17:19:33 <Cale> It's actually translated into a call to negate.
17:19:58 <Cale> That @src is the default implementation of negate, if an instance of Num fails to provide one.
17:24:20 <msouth> ok, all much, much clearer now.  thanks!
17:27:07 <msouth> Can you make an Int into a Double?
17:27:20 * msouth cringes lest that's a mortal sin
17:27:22 <Binkley> @type fromIntegral
17:27:31 <lambdabot> forall a b. (Num b, Integral a) => a -> b
17:27:53 <monochrom> > fromIntegral (0 :: Int) + (0.5 :: Double)
17:27:54 <lambdabot>  0.5
17:28:27 <msouth> ok, so I can fromIntegral (5::Int) :: Double
17:29:03 <msouth> and the :: Double is a hint to tell what I want out of fromIntegral, because it can make things into any Num type
17:30:14 <monochrom> Ya.
17:34:32 <msouth> and what is the "forall" about, in the glasgow-exts version?  or is that too much to go into at this level of newbieness?
17:34:35 <ekidd> Peer review is actually pretty cool, at least after the initial "Ouch!" :-)
17:35:18 <monochrom> I'll say that's too much for now.
17:41:47 <msouth> head.tail doesn't work because tail might return an empty list, which head couldn't handle?
17:42:19 <EvilTerran> head.tail is fine if you know your list has at least 2 items
17:42:32 <EvilTerran> much like head alone is only fine if you know your list is non-empty
17:43:46 <hpaste>  msouth pasted "head.tail" at http://hpaste.org/1721
17:44:36 <EvilTerran> > head . tail $ "abc"
17:44:38 <lambdabot>  'b'
17:44:50 <msouth> what's the $ ?
17:45:00 <EvilTerran> @src ($)
17:45:00 <lambdabot> f $ x = f x
17:45:08 <mauke> > (head . tail) [1,2,3]
17:45:10 <lambdabot>  2
17:45:17 <EvilTerran> it's really low precedence, so it can be used to save brackets
17:45:21 <mauke> > head . (tail [1,2,3])
17:45:22 <lambdabot>  Couldn't match expected type `a -> [a1]'
17:45:33 <EvilTerran> in general, f $ ... = f (...)
17:47:01 <EvilTerran> msouth, ah, i see what the problem is. function application always binds tighter than infix operators.
17:47:06 <EvilTerran> always always always
17:47:30 <msouth> tail was applied to [1,2,3] first
17:47:39 <msouth> oh, and it wanted a function
17:47:42 <msouth> to compose with
17:47:46 <msouth> is that it?
17:47:55 <msouth> and it said, dude, you gave me a list
17:47:57 <msouth> wtf
17:48:08 <msouth> by it I mean "."
17:48:12 <mauke> yeah
17:48:33 <msouth> wow.  write less, think _much_ more
17:48:34 <msouth> :)
17:48:59 * edwinb makes a note to use the word "dude" in error messages more often
17:49:03 <edwinb> much friendlier that way
17:49:06 <EvilTerran> (think of function application as the very-tightly-binding infix operator " " between two values, if that helps)
17:49:19 <EvilTerran> (or don't, if it doesn't. i have odd ways of thinking about these things)
17:49:23 <msouth> >let f = head.tail in f [1,2,3]
17:49:36 <mauke> src.hs:10: error: wait, what?
17:49:41 <EvilTerran> > let f = head.tail in f [1,2,3]
17:49:43 <lambdabot>  2
17:50:01 <EvilTerran> test.hs:13: error: OH GOD WHAT THE F***
17:50:07 <msouth> lol
17:50:08 <mauke> @ghc
17:50:08 <lambdabot> ghc says: Can't mix generic and non-generic equations for class method
17:50:41 <mauke> @quote brain
17:50:41 <lambdabot> adept says: I think I need cobrain to understand coeffects
17:50:47 <mauke> hmm, no
17:51:02 <Binkley> ?quote explode
17:51:02 <lambdabot> ghc says: My brain just exploded.
17:51:02 <Excedrin> @quote keal
17:51:03 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
17:51:27 <Excedrin> @keal
17:51:27 <lambdabot> there is no way to prove the failsafe exists
17:51:33 <Binkley> ?quote qwe1234
17:51:33 <lambdabot> qwe1234 says: you cannot write a lisp compiler that is as good as a C compiler
17:53:24 <dons> ?yow
17:53:24 <lambdabot> Well, O.K.  I'll compromise with my principles because of EXISTENTIAL DESPAIR!
17:53:35 <EvilTerran> @bot
17:53:35 <lambdabot> :)
17:53:58 <Binkley> ?quote
17:53:58 <lambdabot> audreyt says: assembly would require metaolegs (or megaolegs)
17:54:08 <matt__r> ?quote
17:54:09 <lambdabot> emu says: oh no, the catamorphism is out of the bag!
17:54:12 <dibblego> hey dons, do you know much about ARC grants?
17:54:17 <matt__r> ?quote
17:54:17 <lambdabot> darius says: I imagine XSLT programmers say "It's a one pager" the way most other programmers say "It's a one liner".
17:54:23 <dons> a little, they're tedious, dibblego 
17:54:23 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
17:54:37 <dibblego> tedious; the application you mean?
17:54:40 <matt__r> dibblego: and tough to get
17:54:56 <dons> dibblego: yeah. and tough
17:55:10 <dons> dibblego: perhaps talk to ChilliX, he writes a couple a year
17:55:20 <dibblego> ok thanks
17:55:41 <dibblego> I wonder if I can do something remotely with UNSW
17:55:58 <dibblego> because of its interest areas
17:56:04 <matt__r> dibblego: what are you thinking of applying for?
17:56:48 <dibblego> matt__r, a joint funding by ARC and my current employer, is about as far as we have got in discussion
17:57:20 <dibblego> many ideas for research topics
17:57:23 <matt__r> dibblego: I am at macquarie and we have a few pl academics who would get involved with a good proposal
17:57:54 <dibblego> matt__r, thanks, I live in Brisbane/Gold Coast
17:58:04 <Saizan> wc
17:58:31 <matt__r> dibblego: so you are not freezing to death like the rest of the east coast :)
17:58:44 <dibblego> matt__r, precisely why I'd opt for the remote option :)
17:58:59 <matt__r> dibblego: smart :)
17:59:39 <dibblego> I can't stand the cold; I've been sick for nearly 2 weeks trying to shake it, but I get bored resting all the time (went dirt-bike riding on the weekend and am now paying)
18:02:12 <matt__r> dibblego: I am the opposite, summer up north would kill me I think.  But at times like this (<0 when I woke up) I do wonder.......
18:02:38 <dibblego> gimme 40 degrees all year round! :)
18:12:49 <mauke> @type Data.Map.singleton
18:12:51 <lambdabot> forall k a. k -> a -> Data.Map.Map k a
18:25:34 <chessguy> what would happen if we had a >>= :: Monad m1,m2 => m1 a -> (a -> m2 b) -> m2 b
18:25:37 <Nucleo_> @unpl filterM (const [True, False])
18:25:37 <lambdabot> filterM (\ _ -> [True, False])
18:26:13 <Nucleo_> @src const
18:26:13 <lambdabot> const x _ = x
18:26:17 <edwardk> chessguy: thats (.>>=) in my toy prelude =)
18:26:32 <chessguy> edwardk, what's it useful for?
18:26:46 <mauke> it allows IO a -> Identity a
18:27:18 <chessguy> and thus impurity?
18:27:30 <edwardk> right now? it apears to be somewhat useful when one monad subsumes another in practice. i.e. BindOpL Maybe List     would say that you can promote a Maybe to a List and still retain type inference for the rhs of the bind.
18:27:57 <edwardk> its a slightly less general version of the full parameterized bind in my blog post
18:28:22 <chessguy> hmm, link?
18:28:51 <edwardk> example: comonad.com/reader
18:29:16 <edwardk> as for example Just 2 >>= somethinghugeandcomplicatedreturningalist
18:29:19 <edwardk> er >>=.
18:29:25 <edwardk> er .>>= =)
18:30:08 <edwardk> mauke: not if you don't have an instance for all pairs of monads.
18:32:46 <edwardk> if we construct a 'meet' operation over some of the monads .>>= and >>=. are useful when you know that one dominates the other to give better type inference. since x && y = y if x <= y, where && is the meet operation is a meet semilattice law.
18:34:11 <Binkley> ?yow
18:34:11 <lambdabot> ... My pants just went on a wild rampage through a Long Island Bowling Alley!!
18:35:10 <Saizan> this could perhaps be handy to alleviate the clumsiness of dealing with multiple types of error reporting like Maybe, Either e, empty lists..
18:35:58 <edwardk> saizan: yeah mnislaih is working something up using this for exceptions right now. its very cool, not to steal his thunder =)
18:37:03 <laz0r> if i try to catch exceptions, for example when opening a file, then i get problems with the type; i wrote a function with the signature ':: FilePath -> IOMode-> IO Handle', but the problem here is that i can't be sure that the file exist, so maybe i dont' get a handle...
18:37:12 <laz0r> which brought me to the Maybe Monad
18:37:15 <laz0r> but
18:37:25 <laz0r> i somehow still dont get it to work
18:37:28 <hpaste>  laz0r pasted "request for comment" at http://hpaste.org/1722
18:37:46 <laz0r> i would be glad if someone could point out how to do this
18:38:21 <kpreid> laz0r: when pasting code, always include the error message
18:38:22 <Saizan> ?type catch
18:38:24 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
18:38:36 <kpreid> ?type openFile
18:38:38 <lambdabot> Not in scope: `openFile'
18:38:42 <kpreid> ?type IO.openFile
18:38:44 <lambdabot> FilePath -> GHC.IOBase.IOMode -> IO GHC.IOBase.Handle
18:39:06 <kpreid> laz0r: the third attempt looks correct to me. show us the error you get from it.
18:39:17 <Saizan> openFile' f m = catch (Just `liftM` openFile f m) (\_ -> do pustStrLn "error"; return Nothing)
18:39:23 <edwardk> yeah the third attempt is pretty much what i'd write
18:39:39 <edwardk> ah
18:39:42 <Saizan> the two branches of catch must have the same type
18:39:50 <edwardk> its returning Nothing, whereas openFile returns something not in Maybe
18:39:51 <hpaste>  laz0r pasted "the error" at http://hpaste.org/1723
18:40:00 <kpreid> aa
18:40:03 <laz0r> erm, that should be the error from the third attempt
18:40:16 <kpreid> laz0r: move the return (Just a) into the first argument of catch
18:41:21 <Saizan> laz0r: if in the handler you return a Maybe Handle, you have to do so even in the block you are catching
18:41:54 <Saizan> laz0r: instead openFile returns only Handle, so you have to attach Just on it
18:41:58 <laz0r> yea, the two branches of catch must have the same type, thats what i thought too, and then tried with Maybe
18:42:33 <hpaste>  edward annotated "request for comment" with "tweak" at http://hpaste.org/1722#a1
18:42:52 <Saizan> laz0r: but you have to do it inside the action that you pass to catch, not outside
18:42:57 <chessguy> let f [] = 0; f (0:xs) = 1 + f xs; f (x:xs) = f xs in f [1,2,0,3,2,0,0,3]
18:43:04 <chessguy> > let f [] = 0; f (0:xs) = 1 + f xs; f (x:xs) = f xs in f [1,2,0,3,2,0,0,3]
18:43:06 <lambdabot>  3
18:43:08 <laz0r> ah, im looking at the tweak...
18:43:24 <msouth> what does the single quote at the end of the function name mean?
18:43:41 <dibblego> msouth, nothing; it's just part of the identifier
18:43:49 <edwardk> saizan's version above is the same thing, Just `liftM` openFile f m is equivalent to that first do-block
18:43:54 <chessguy> > let f [] = 0; f (0:xs) = f xs; f (x:xs) = 1 + f xs in f [1,2,0,3,2,0,0,3] -- is there a better way to do this?
18:43:55 <lambdabot>  5
18:43:59 <laz0r> msouth, i just used that to distinguish it from the openFile in Prelude
18:44:17 <laz0r> or, wherever openFile comes from....
18:44:31 <kpreid> chessguy: length . filter (/= 0)
18:44:37 <edwardk> msouth: haskell allows ' in identifiers so people tend to use them to say foo<prime> when they mean a slightly modified version in haskell 
18:44:45 <chessguy> well ok
18:45:29 <ari> msouth: For public functions (i.e. ones in module interfaces) it seems to often mean that the function is strict, for instance in foldl'
18:45:37 <kpreid> chessguy: something bothers you?
18:45:44 <chessguy> hmm, does that go through the list once or twice?
18:46:22 <kpreid> does it matter?
18:46:28 <edwardk> it should go once, by the time the pattern is desugared
18:46:29 <chessguy> no, i'm just curious
18:46:40 <Igloo> It's allowed to go through it 8 times if it wants
18:46:50 <kpreid> it could fuse them!
18:46:52 <edwardk> touche igloo =)
18:47:02 <chessguy> i didn't ask what it's allowed to do
18:47:34 <Igloo> I think with GHC today it would go through it twice - there's a bug open about length not being a good consumer
18:47:35 <msouth> apparently the answer depends on whether Igloo wrote the compiler chessguy 
18:47:57 <edwardk> shouldn't it should de-sugar the pattern down to a check of the constructor, then a branch on the first argument of the constructor if its a cons cell, making it a single traversal?
18:48:16 <edwardk> regardless of any fusion things?
18:48:36 <edwardk> oh you mean the length . filter version
18:48:43 <chessguy> yes
18:49:34 <Igloo> Once lists use stream fusion it should only go through the list once, though
18:50:12 <chessguy> but under current implementations it generally does it twice?
18:50:16 <dons> if its time critical, you could grab the stream fusion list lib now and try it
18:50:19 <dons> ?where streams
18:50:20 <lambdabot> I know nothing about streams.
18:50:23 <chessguy> dons, it's not
18:50:32 <chessguy> it was sheer morbid curiosity
18:50:53 <Igloo> I'm not sure what you mean by "generally"
18:51:08 <Igloo> I think, without looking at the compiler output, that that particular example would go through it twice
18:51:33 <Igloo> Other examples, e.g. map f . map g, certainly only go through it once
18:51:41 <chessguy> ok, fair enough
18:51:42 <dons> length is an explicit loop, so it won't fuse with filter
18:51:46 <chessguy> that's all i was looking for
18:52:07 <dons> you can get a fusible list lib here, http://www.cse.unsw.edu.au/~dons/streams.html
18:52:08 <lambdabot> Title: Data.List.Stream
18:52:33 <chessguy> @where+ streams http://www.cse.unsw.edu.au/~dons/streams.html
18:52:33 <lambdabot> Done.
18:52:47 <dons> the standalone lib doesn't include fusible comprehensions or enumerations though, which need a patch to baes
18:52:53 <dons> and ghc.
18:53:50 <laz0r> edwardk, i tried using your tweaked version of my function, but it doesnt work
18:53:52 <hpaste>  laz0r pasted "another error" at http://hpaste.org/1724
18:54:03 <laz0r> the solution with liftM works though
18:54:06 <Igloo> dons: To GHC? Don't they just desugar away to base functions?
18:54:36 <Saizan> so foldr (const (+1)) 0 . filter (/=0) would fuse, instead?
18:54:56 <chessguy> @src nubby
18:54:56 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
18:55:01 <chessguy> @src nub
18:55:02 <lambdabot> nub = nubBy (==)
18:55:04 <kpreid> @src nubBy
18:55:04 <lambdabot> nubBy eq []             =  []
18:55:04 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
18:55:06 <dons> Igloo: you need to change the list comprehension desugaring to produce streams, instead of build/foldrs
18:55:23 <chessguy> hm, i didn't think src was case-sensitive
18:55:34 <edwardk> laz0r: i probably typoed. one sec.
18:55:34 <dons> so a different implementation of comprehension desugaring
18:55:53 <dons> because build/foldr is actually wired in to the desugaring
18:55:55 <Saizan> edwardk: you forgot to ignore the exception in the handler
18:56:02 <edwardk> oh yeah
18:56:12 <Igloo> dons: Hmm, I don't see why it isn't just desugaring to standard functions, which are themselves streams
18:56:19 <chessguy> > nub [1..9] [9,8..1]
18:56:20 <lambdabot>  Couldn't match expected type `[t1] -> t'
18:56:29 <laz0r> oh
18:56:30 <hpaste>  edwardk annotated "request for comment" with "doh" at http://hpaste.org/1722#a2
18:56:36 <chessguy> > nub $ [1..9] ++ [9,8..1]
18:56:37 <laz0r> the (\_ -> thing is missing?
18:56:37 <lambdabot>  [1,2,3,4,5,6,7,8,9]
18:56:41 <edwardk> yep
18:56:54 <dons> Igloo: right, it does. that's the change
18:57:04 <dons> currently ghc desugars to standard functions: build and foldr
18:57:39 <edwardk> @type mapM
18:57:41 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
18:57:47 <edwardk> @type sequence
18:57:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
18:57:50 <Igloo> Ah, excellent
18:59:54 <chessguy> @hoogle nub
18:59:55 <lambdabot> List.nub :: Eq a => [a] -> [a]
18:59:55 <lambdabot> List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
19:01:03 <edwardk> in template haskell there is no way to define the fixity of the operators you define, is there?
19:01:28 <edwardk> i can find them in the TH 'Info' stuff but not in the decQ stuff to make new declarations
19:02:05 <Igloo> Hmm, looks like you're right, edwardk
19:02:36 <dolio> @yow!
19:02:36 <lambdabot> ... I want FORTY-TWO TRYNEL FLOATATION SYSTEMS installed within
19:02:36 <edwardk> so i can make the classes for all those weird numeric types, but i still have to manually punch in the fixities
19:02:36 <lambdabot> SIX AND A HALF HOURS!!!
19:02:50 <edwardk> igloo: shall i bug report it?
19:03:04 <Igloo> edwardk: Please do
19:03:05 <edwardk> @bug
19:03:05 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
19:07:18 <chessguy> @help bug
19:07:18 <lambdabot> bug. Submit a bug to GHC's trac
19:12:24 <chessguy> @pl \p -> ex (ev p) s
19:12:24 <lambdabot> flip ex s . ev
19:15:56 <edwardk> igloo: though since i can't appear to modify the export list for the module, i guess i need some boilerplate anyways =/
19:17:51 <chessguy> !paste
19:17:52 <hpaste> Haskell paste bin: http://hpaste.org/
19:18:58 <hpaste>  chessguy pasted "fun with evolving an algorithm for the classic N-Queens problem" at http://hpaste.org/1725
19:19:04 <chessguy> this is a fun little problem
19:19:50 <chessguy> i'm not there yet, but should be able to get it in a couple days, i think
19:25:25 <edwardk> @type (~)
19:25:27 <lambdabot> parse error on input `)'
19:25:33 <edwardk> oh duh, lazy
19:25:37 <edwardk> nevermind
19:27:13 <Binkley> ?yow
19:27:13 <lambdabot> Yow!  I'm imagining a surfer van filled with soy sauce!
19:27:19 <chessguy> @quote
19:27:19 <lambdabot> DukeDave says: what, if your kids start doing drugs? or worse, business school
19:27:47 <dons> ?users
19:27:47 <lambdabot> Maximum users seen in #haskell: 355, currently: 319 (89.9%), active: 9 (2.8%)
19:27:57 <chessguy> @losers
19:27:57 <lambdabot> Maximum users seen in #haskell: 355, currently: 319 (89.9%), active: 9 (2.8%)
19:28:07 <chessguy> proof that we're all losers :)
19:28:30 <dons> interesting, http://theschemeway.blogspot.com/2007/07/recruiting-secret-weapon.html
19:28:32 <lambdabot> Title: (The Scheme Way): The recruiting secret weapon, http://tinyurl.com/2fuevu
19:28:42 <dons> idea that it is _easier_ to recruit FP programmers
19:28:53 <dons> because they'll jump jobs to use Haskell/ Erlang/...
19:29:23 <dons> start your new project in Haskell tomorrow, and you'll get a bunch of phds banging the door for the job
19:29:28 <chessguy> hmm, he makes a good point
19:29:40 <chessguy> it's an untapped market
19:29:41 <dons> I wonder if Credit Suisse thinks all haskell programmers are like Lennart? :)
19:29:45 <dons> (for example)
19:29:51 <edwardk> dons: heh
19:30:13 <Binkley> On the other hand, I've heard someone who will remain anonymous complaining about how all the Haskell programmers really want to do research
19:30:22 <Binkley> and thus aren't good candidates for programming jobs
19:30:25 <dons> yeah, that's the other side
19:30:34 <dons> too researchy, hard to tie down
19:30:43 <dons> we are building up a good hacker culture though, I think
19:30:51 <shapr> yeah!
19:31:03 <Binkley> which frustrated me because when I was looking for jobs, I think people were reacting to me that way...
19:31:06 <Binkley> but on the other hand, I wasn't getting offered any research jobs
19:31:09 <chessguy> i'd give up an important digit for a haskell job, if it didn't defeat the purpose so much
19:31:09 <dons> along side the researcher/theory guys
19:31:11 <Binkley> So I went back to grad school :P
19:31:31 <Binkley> chessguy: did you hear back from the people at my ex-company?
19:31:35 <dons> got to write a half dozen visible open source projects in haskell
19:31:55 <chessguy> Binkley, i did, but i had already been offered another position, and i wasn't going to turn down a definite for a maybe
19:32:00 <Binkley> Yeah
19:32:01 <dons> then you'll fit in to the hacker camp easily. hell you own hacker camp :)
19:32:02 <Binkley> probably a wise choice
19:32:22 <chessguy> you're not there any more?
19:32:32 <Binkley> chessguy: nope, I fled to Portland State :-)
19:32:39 <chessguy> PSU?
19:32:42 <Binkley> yeah
19:33:10 <chessguy> cool. their projects for SoC always look interesting
19:33:13 <Binkley> dons: some of us are not as superhuman as you, and can't find time to write cool open-source stuff while also working or going to school :-)
19:33:42 <dons> you just need to turn the open source stuff into school projects somehow
19:33:45 <Nafai> Binkley: amen
19:33:51 <Binkley> true
19:33:56 <Binkley> I'm still working on that
19:33:57 <chessguy> and planning a wedding, and a cross-country move and.....
19:34:14 <dons> hah
19:34:16 <Binkley> Weddings are easy. Moving is hard, though
19:34:29 <dons> yeah, its a pain. 
19:34:39 <dons> anyone in sydney what a mac68k running netbsd with ghc on it? :)
19:34:46 <dons> with .au power / 240 volt
19:34:58 <dons> maybe seafoodX does
19:34:59 * glguy just read the Help Vamires: A Spotter's Guide posting on reddit
19:35:05 <chessguy> i'm ready to rent one of those $2000 POD things just to not have to deal with it
19:35:36 * dolio just clicked 'hide' without reading it.
19:35:41 <dons> Binkley: so you know what projects you're working on at uni?
19:35:49 <Binkley> dons: so far I'm working on House
19:35:55 <Binkley> specifically, on performance profiling for it
19:36:03 <Binkley> so I can find out just how much worse it is than a real OS :-)
19:36:15 <dons> great!
19:36:26 <dons> will there be a new release? :)
19:36:34 <Binkley> Maybe
19:36:39 <Binkley> At this precise moment, I'm shaving yaks
19:36:39 <dons> maybe you should start a 'House' blog
19:36:44 <glguy> dons: is hide like a down-mod without the points penalty?
19:36:47 <Binkley> heh
19:36:56 <dons> keep us updated on p.h.o with what House is doing..
19:36:57 <Binkley> interesting idea
19:36:59 <jfredett> House, OS...
19:37:03 <jfredett> instead of House, Md.
19:37:04 <jfredett> :)
19:37:12 <Binkley> Maybe once I feel slightly less clueless
19:37:18 <glguy> dolio: that was meant for you ^^
19:37:22 <dolio> glguy: Yeah. I actually have it set to not hide things I vote down.
19:37:22 <edwardk> chessguy: they don't suck actually (the pods)
19:38:03 <chessguy> edwardk, unless you 1.) live out in the middle of nowhere that they don't deliver to, and 2.) are trying to move on a budget
19:38:41 <edwardk> chessguy: fair enough
19:40:39 <Binkley> ?quote
19:40:39 <lambdabot> elpolilla says: que están, todos re duros? :@
19:42:01 <dons> all those #haskell.es guys filling the quote book
19:42:04 <chessguy> hmm
19:42:08 <chessguy> re duros?
19:42:49 <dibblego> is it possible to traverse a Set as a (a, Set a) similar to how you do with a list in O(n) time?
19:43:13 <dibblego> oh, just spotted deleteFindMin
19:43:14 <dibblego> :)
19:49:07 <Binkley> ?quote
19:49:08 <lambdabot> autrijus says: Parrot is fine except every time I build it, it fails
19:49:39 <dolio> @quote qwe1234
19:49:39 <lambdabot> qwe1234 says: the lisp folks have purposefully made lisp so that static analysis is impossible.
19:49:41 <glen_quagmire> ?rq
19:49:41 <lambdabot> Not enough privileges
19:49:52 <glen_quagmire> @rq
19:49:52 <lambdabot> Not enough privileges
19:50:10 <glen_quagmire> lambdabot: do you have a gmail?
19:50:14 <Toxaris> how to deal with #include-like stuff using parsec? parsec doc's tell me about setInput, but how to read the file inside the parsec monad?
19:50:45 <glen_quagmire> if you get "filename.h"  then you should open the file
19:51:17 <glen_quagmire> i think i misunderstood the question
19:51:37 <dolio> Well, the problem would be that you can't read files from inside the parse monad.
19:51:47 <dolio> And it's not a transformer, so you can't layer it over IO.
19:51:55 <dons> ah great, the Control.Parallel is much better documented now, http://www.haskell.org/ghc/dist/current/docs/parallel/Control-Parallel-Strategies.html
19:51:57 <lambdabot> http://tinyurl.com/2rcocd
19:52:16 <dons> we need more tutorials though on all the layers of concurrent and parallel programming in haskell though.
19:52:19 <dons> hmm
19:52:40 <glen_quagmire> we need diveintohaskell.com
19:53:04 <gravity> glen_quagmire: The wikibook is doing a pretty good job of that
19:53:23 <glen_quagmire> and how-to-make-a-desktop-application-in-haskell.com
19:53:56 <Binkley> people still write desktop applications? ;-)
19:54:25 <Toxaris> dolio: yes that's what I mean, but parsec docs say: "The getInput and setInput functions can for example be used to deal with #include files"
19:54:47 <Toxaris> so I wonder if there's same trick I missed
19:55:28 <dolio> Toxaris: Yeah. I don't know how that'd work in practice. You'd have to, essentially, suspend parsing and then read the file.
19:55:37 <dolio> I don't know enough about Parsec to know how to do that, though.
19:55:52 <dolio> Sounds like delimited continuations (since I have those on the brain). :)
19:56:07 <dons> always with the delimited continuations :)
19:56:20 <dons> dolio: maybe you should whip up a quick paper on the implementation, for IFL or PADL ?
19:57:08 <dolio> I got the implementation from a paper. I mainly added some stuff around it.
19:57:41 <dons> maybe write a tutorial on its use, to link to from the hackage page, based on the email you wrote two days ago
19:58:03 <glguy> has anyone here used git?
19:58:05 <dons> think about how the arrows guys told us how to use them for specific projects, as with comonds, i think its unclear yet exactly when i should be using a delimited continuation
19:58:21 <dolio> Yeah. Maybe I'll move that stuff to the wiki somewhere.
19:58:42 <Toxaris> since it's only a quick hack to ease testing of another part of the interpreter, i will implement some workaround like returning the list of files to include incl. their context
19:59:25 <dibblego> ?hoogle Set -> Bool
19:59:26 <lambdabot> No matches, try a more general search
19:59:32 <dibblego> ?hoogle Set a -> Bool
19:59:32 <lambdabot> Data.Set.isEmptySet :: Set a -> Bool
19:59:32 <lambdabot> Data.Set.null :: Set a -> Bool
19:59:32 <lambdabot> Data.Set.valid :: Ord a => Set a -> Bool
19:59:37 <Toxaris> would it be possible / reasonable easy to refactor parsec into a monad transformer?
19:59:41 <dolio> Toxaris: As a really easy solution, you could scan the file for 'include' lines, pre-read them, and then pass them in the state or something.
19:59:52 <dibblego> ?check \s -> isEmptySet s == null s
19:59:53 <lambdabot>   Not in scope: `isEmptySet'
20:00:01 <dibblego> ?check \s -> Data.Set.isEmptySet s == Data.Set.null s
20:00:02 <lambdabot>   Not in scope: `Data.Set.null'
20:00:10 <dibblego> get stuffed
20:00:25 <dons> dolio: maybe tell sigfpe to explore the maths of delimited continuatoins :)
20:01:03 <Toxaris> dolio: that's good, it saves me from reifing the context
20:01:26 <glguy> dibblego: I don't have a Data.Set.isEmptySet in my 6.6.1 install
20:01:33 <dibblego> glguy, me neither, odd
20:01:41 <glguy> :t Data.Set.isEmptySet
20:01:43 <lambdabot> Not in scope: `Data.Set.isEmptySet'
20:01:50 <glguy> doesn't seem that lambdabot does either?
20:01:54 <dolio> Toxaris: Yeah. It's two-pass, so it's probably not ideal, but it's simple at least. :)
20:02:03 <dibblego> what's the usual way of using Set.null and disambiguate it from List.null?
20:02:10 <dibblego> :t Data.Set.null
20:02:12 <lambdabot> forall a. Data.Set.Set a -> Bool
20:02:14 <glguy> import qualified Data.Set as Set
20:02:19 <dibblego> thanks
20:02:23 <glguy> import Data.Set (Set)
20:02:31 <glguy> that last one is for the datatype
20:03:10 <dibblego> import qualified Data.Set as Set -- doesn't this mean I can use Set everywhere instead of Data.Set?
20:04:05 <glen_quagmire> haskell will never be popular unless you NEED an IDE to program in haskell. just like java.
20:04:16 <Saizan> dibblego: yes but you need to write Set.Set in type signatures for example
20:04:35 <Toxaris> dolio: but if i think about it, i could as well write a real preprocessor wich splices included files right into a lazily read string
20:04:52 <dibblego> Saizan, instance Foo Set.Set where -- like this?
20:04:57 <Saizan> dibblego: but if also import Data.Set (Set) you have the type in scope as simply Set
20:05:05 <Saizan> dibblego: yup
20:05:07 <glguy> dibblego: if you use the second line I gave you, that is not necessary
20:05:07 <dibblego> glen_quagmire, you think Haskell should add some additional noise so that an IDE can write it?
20:05:32 <dolio> Toxaris: Sure, that'd work, too.
20:05:36 <glen_quagmire> no. consulting firms just love IDE and complicated XML configuration and stuff
20:06:06 <dibblego> glen_quagmire, so we should make it more complicated then?
20:06:26 <dibblego> glen_quagmire, I agree by the way, there should simply be a --not-complicated flag
20:06:33 <chessguy> woohoo
20:06:35 <chessguy> @quote melt
20:06:36 <lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
20:06:48 <dibblego> that way, the language becomes popular and we can use it "properly" if we want to, all at once
20:07:25 <chessguy> err
20:07:32 <chessguy> except that my code broke when it melted
20:07:50 <Saizan> we gone from "avoid success at all cost" to "attention whore"?
20:09:09 <dibblego> import Data.Set(Set, empty, null, insert, deleteFindMin) -- when I try to use null, I get an ambiguity error (Prelude and Data.Set)
20:10:12 <glguy> dibblego: import qualified Data.Set as S -- or Set
20:10:20 <dibblego> as well?
20:10:27 <Saizan> you should import qualified clashing names, and normally the others, do you know that you can import a module multiple times?
20:10:27 <Toxaris> dibblego: if you don't need Prelude.null, try import Prelude hiding (null)
20:10:36 <dibblego> Toxaris, yeah did that, and it worked
20:10:58 <dibblego> Saizan, I used to know all the module stuff, but I've been fiddling with Scala for too long
20:33:31 <dblhelix> morning #haskell
20:41:54 <edwardk> ugh, i appear to not be able to set fixities for things declared in template haskell.
20:42:03 <edwardk> can you set a fixity on something you import?
20:48:24 * SamB just invited dons to the #haskell group on facebook
20:49:05 <dblhelix> edwardk: you cannot, but, thinking of it, I can imagine that you want this from time to time
20:49:25 <SamB> apparantly dons looks just like me
20:49:59 <edwardk> crap
20:50:07 <edwardk> i just spent 2 hours building something i can't use =(
20:50:37 <Hirvinen> edwardk: Happens sometimes.
20:50:59 <edwardk> i can build all my operators in template haskell, but then i can't give them fixities in the same module or even in a different one =(
20:51:08 <dblhelix> that's a real bummer... I'd be better if TH let you add fixities though
20:51:18 <SamB> Prelude Language.Haskell.TH> runQ [d| infixl %%; x %% y = x / y |] >>= print
20:51:18 <SamB> [FunD %% [Clause [VarP x_2,VarP y_3] (NormalB (InfixE (Just (VarE x_2)) (VarE GHC.Real./) (Just (VarE y_3)))) []]]
20:51:23 <edwardk> @hpaste
20:51:23 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:51:24 <SamB> what do you mean, you can't?
20:51:49 <dblhelix> :-)
20:52:35 <dblhelix> edwardk: seems like you spent 2 hours builing something and then went looking in the wrong place for how to add fixity declarations
20:53:00 <dblhelix> edwardk, SamB: you guys use TH a lot?
20:53:23 <hpaste>  edwardk pasted "template haskell fixities" at http://hpaste.org/1726
20:53:56 <edwardk> dblhelix: well, i'd presumed there'd be a way to add them =/
20:54:21 <blackdog_> SamB: I just joined too :)
20:54:47 <hpaste>  edwardk annotated "template haskell fixities" with "the first pass is a nontrivial number of instances" at http://hpaste.org/1726#a1
20:55:35 <edwardk> dblhelix: yeah i do =)
20:55:59 <dblhelix> edwardk: h
20:56:07 <dblhelix> ow your overall impression?
20:56:19 <edwardk> most of the time its a pain in the ass =)
20:56:33 <dblhelix> yeah, I figured
20:56:41 <edwardk> but that one time in a hundred when you need to produce 2000 instances it can be a dream
20:56:50 <edwardk> this is the first time i ran into something it just flat out can't do though
20:57:03 <edwardk> @bug
20:57:03 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
20:59:17 * dblhelix goes for breakfast etc.
21:10:06 <wli> Is there something that already does:
21:10:34 <wli> data AtLeastOneOf t t' = Both t t' | OnlyFirst t | OnlySecond t' deriving (Eq, Ord, Read, Show)
21:18:29 <edwardk> crap. looks like i'll be abusing the c preprocessor to generate those classes then
21:18:53 <jcreigh> use of CPP is abuse almost by definition.
21:19:12 <edwardk> jcreigh: point out an alternative that won't lead to carpal tunnel and i'd gladly accept ;)
21:19:23 <jcreigh> oh, I didn't say there was anything better. :)
21:19:47 <jcreigh> I just like to throw stones.
21:19:51 <edwardk> heh
21:20:08 <edwardk> i was so proud of myself throwing away everything i'd done to do it the right way. =/
21:20:30 <edwardk> I guess I can still use TH to generate the instances
21:20:38 <edwardk> I hope =/
21:26:54 <edwardk> lol, and cpp can't do it because cpp can't glue + and . together =)
21:27:23 <edwardk> time to write a cheesy preprocessor? blech
21:27:39 <Cale> Why can't TH do it?
21:27:59 <edwardk> cale: there is apparently no way at all to assign a fixity to an infix operator declared in template haskell
21:28:14 <edwardk> it doesn't exist at the time infix{l,r} declarations are parsed in the file you are in
21:28:28 <edwardk> and it isn't in scope when you load it into another file to load them then
21:28:28 <timthelion> um, does TimeDiff's Day register contain the difference in days? or the days digit of the difference? like if the times where one year appart would it have 365 in Day or 0? 
21:28:29 <Cale> ah, heh, that should probably be considered a bug
21:28:45 <Cale> There's no way to use TH to generate fixity declarations?
21:28:50 <edwardk> yeah, submitted, but it doesn't help me now =)
21:28:53 <edwardk> correct
21:29:14 <edwardk> this is the first time the combination of cpp and template haskell have managed to together fail me =)
21:29:18 <ddarius> edwardk: Hack GHC.  That's what I did back in the beginning of TH when it didn't support record declarations.
21:29:57 <edwardk> ddarius: kind of hard to give a hackage module to someone that relies on a mashed up ghc though =/
21:30:07 <ddarius> Well you submit the patch.
21:30:29 <Cale> timthelion: I'd expect that if it was a full year, the tdYear would be 1 and the rest 0's
21:31:04 <edwardk> ddarius: at the moment i'm about 6 tangents away from my initial goal, so i need to start popping the stack =/
21:31:09 <timthelion> Cale: that's not what I wanted to hear,  I'm trying to figure out how many days old a file is :)
21:31:45 <edwardk> time for perl =)
21:32:30 <wli> What, we don't stat in our IO libraries?
21:33:57 <edwardk> @type System.Posix.Files.modificationTime
21:33:59 <lambdabot> System.Posix.Files.FileStatus -> System.Posix.Types.EpochTime
21:34:28 <edwardk> i guess stat is getFileStatus?
21:34:38 <edwardk> first time mucking around in this corner of the standard library
21:35:13 <edwardk> sometimes the needless haskellification of the standard library when it comes to OS interoperability bugs me
21:35:49 <edwardk> worked in dozens of languages where 'stat' is 'stat' =)
21:35:55 <timthelion> hmm, I imported system.Time to check it out in ghci, and http://rafb.net/p/3Ry14m98.html
21:35:56 <lambdabot> Title: Nopaste - No description
21:36:01 <Cale> timthelion: I think maybe the easiest thing would be to use the new Data.Time library
21:36:04 <wli> The burning question is really whether there are enough time/date manipulation affairs (there aren't even in C, so this is basically expected)
21:36:25 <Cale> timthelion: Unless you're really trying to maintain compatibility with Haskell 98 or some such.
21:37:02 <timthelion> Cale: I'm writting something to run on my computer, I really couldn't care less if it ran on someone elses.
21:37:37 <Cale> however... hmm :)
21:37:39 <timthelion> why isn't it in scope in ghci?
21:38:27 <Cale> What's not in scope?
21:38:29 <timthelion> Oh
21:38:30 <edwardk> timtheline :m + System.Time
21:38:31 <timthelion> hmm
21:39:06 <timthelion> ClockTime
21:39:32 <Cale> I don't know how to turn a ClockTime into a UTCTime
21:40:10 <timthelion> So with system.Time imported Clocktime is not in scope
21:40:20 <ddarius> @hoogle stat
21:40:20 <lambdabot> Text.ParserCombinators.Parsec.Prim.stateInput :: State tok st -> [tok]
21:40:20 <lambdabot> Text.ParserCombinators.Parsec.Prim.statePos :: State tok st -> SourcePos
21:40:20 <lambdabot> Text.ParserCombinators.Parsec.Prim.stateUser :: State tok st -> st
21:40:32 <edwardk> @hoogle getFileStatus
21:40:32 <lambdabot> No matches found
21:40:32 <Cale> ClockTime
21:40:46 <edwardk> @src System.Posix.Files.getFileStatus
21:40:46 <lambdabot> Source not found. My mind is going. I can feel it.
21:41:00 <edwardk> @src ClockTime
21:41:00 <lambdabot> Source not found. I've seen penguins that can type better than that.
21:41:18 <ddarius> edwardk: You've worked in -dozens- of languages... that all had stat... as stat?
21:41:38 <timthelion> I'm looking at ClockTime here: http://haskell.org/ghc/docs/latest/html/libraries/base/System-Time.html
21:41:40 <lambdabot> http://tinyurl.com/yrtcx7
21:41:50 <edwardk> its got to be approaching a couple dozen anyways
21:42:08 <ddarius> Really?
21:43:13 <Cale> timthelion: You're just trying to determine if a TimeDiff represents more than 7 days?
21:43:23 <Cale> er, no
21:43:34 <Cale> You wanted to know how many days old the file was
21:43:44 <timthelion> Cale: well n days. and I missthought it's actually diffClockTimes
21:43:50 <timthelion> Cale yes
21:44:09 <timthelion> Cale: However now I'm confused because http://rafb.net/p/4U6hmw52.html
21:44:10 <lambdabot> Title: Nopaste - not in scope
21:44:28 <edwardk> python has it as stat, ruby has stat, perl has stat, php has stat, c++ has stat, d has stat, c has stat, fortran has STAT, hell even ocaml has Unix.stat, ...
21:44:54 <timthelion> Clocktime doesn't seem to exist. eventhough getModificationTime returns IO ClockTime
21:45:05 <Cale> edwardk: the problem is not getting the age of the file, it's the fact that the result is returned in a data structure which is a pain in the ass :)
21:45:22 <Cale> timthelion: It's case-sensitive. ClockTime
21:45:30 <edwardk> cale: sure, that was for ddarius =)
21:46:13 <timthelion> Cale: do I have something inproperly capatalised?
21:46:22 <Cale> timthelion: the t in 'Time'
21:46:34 <Cale> should be capitalised
21:46:51 <timthelion> but it is
21:47:11 <Cale> "<timthelion> Clocktime doesn't seem to exist." -- this is what I was responding to
21:47:19 <timthelion> oh
21:47:43 <TSC> Shouldn't it be TOD?
21:47:58 <TSC> data ClockTime = TOD Integer Integer
21:48:17 <timthelion> TSC no, because getModificationTime returns a ClockTime
21:48:24 <TSC> That's the type
21:48:24 <Cale> You could do something like just get the two TOD's subtract the seconds parts, and then divide by (60*60*24)
21:48:26 <TSC> There's no data constructor called ClockTime
21:48:35 <TSC> The data constructor is called TOD
21:48:40 <timthelion> oh, ok
21:48:43 <edwardk> you want a UTCTime?
21:48:52 <edwardk> @src toUTCTime
21:48:52 <lambdabot> Source not found. My mind is going. I can feel it.
21:49:06 <Saizan> @type toUTCTime
21:49:08 <lambdabot> Not in scope: `toUTCTime'
21:49:11 <edwardk> http://www.zvon.org/other/haskell/Outputtime/toUTCTime_f.html
21:49:12 <lambdabot> Title: Haskell : toUTCTime
21:49:53 <timthelion> wtf! http://rafb.net/p/jSqjsH16.html
21:49:54 <lambdabot> Title: Nopaste - diffClockTimes is REALLY stupid
21:50:25 <edwardk> timthelion: heh
21:50:33 <timthelion> it's just doing a strait subtract, not even touching tdMin, or tdHour
21:50:39 <timthelion> or tdDay
21:51:27 <edwardk> is there some form of canonicalizeTimeDiff function or something?
21:52:07 <timthelion> well I guess that plays to my advantage, I can just div diff 86400
21:52:08 <edwardk> normalizeTimeDiff the result
21:52:16 <dibblego> ?hoogle (a -> Bool) -> Seq a -> Seq a
21:52:17 <lambdabot> No matches, try a more general search
21:52:41 <edwardk> @hoogle normalizeTimeDiff
21:52:41 <lambdabot> System.Time.normalizeTimeDiff :: TimeDiff -> TimeDiff
21:52:43 * SamB wants a t-shirt with System F on it
21:52:55 <timthelion> ok
21:52:56 <cdsmith> SamB: cafepress
21:53:00 <timthelion> that works
21:53:13 <edwardk> samb: bah, you should just get the axioms for Pure type systems, they are shorter and subsume system F ;)
21:53:28 <timthelion> I'm confused as to why tdDay is lower case, is it a function?
21:53:30 <SamB> edwardk: oh, are they shorter?
21:53:37 <edwardk> samb: yeah only like 7
21:53:43 <SamB> do they have so many pretty greek characters?
21:53:49 <edwardk> samb: because terms and types unify into one notion
21:54:04 <TSC> It's a field accessor (with is basically a function from the record's type to the field's type)
21:54:24 <edwardk> so you get a sort of set of meta-laws about how the sorts, axioms and rules work together
21:55:07 <SamB> edwardk: where can I find a paper that has it in a little box like this "Scrap your type applications" paper does for System F?
21:55:21 <edwardk> http://people.cs.uu.nl/johanj/MSc/jwroorda/ page 28
21:55:23 <lambdabot> Title: Pure Type Systems for Functional Programming
21:56:07 <SamB> I see no boxes...
21:56:25 <edwardk> top of page is the stuff you 'want in a box' =)
21:56:36 <timthelion> edwardk: haha, even normalizeTimeDiff is stupid, it just assumes the month has 30 days
21:56:43 <edwardk> wow thats bad
21:56:57 <edwardk> @src normalizeTimeDiff
21:56:57 <lambdabot> Source not found. It can only be attributed to human error.
21:57:20 <SamB> I really ought to read that paper
21:57:30 <ddarius> That thesis
21:58:06 <timthelion> edwardk: unless the 3 month period after the birth of unix had an avarage month length of 30?
21:58:14 <TSC> There's not much else it can do
21:58:22 <edwardk> timethelion: i guess it makes sense in one sense, there is no way to have a time diff that has months, etc. because months lack a standard unit
21:58:39 <edwardk> timediff really SHOULD just be in terms of the smallest time unit
21:58:54 <timthelion> edwardk: unless they where to have kept info about the month in the TimeDiff
21:59:26 <timthelion> edwardk: legaly a month is 30 days in terms of billing.  
21:59:45 <timthelion> but still, TimeDiff is a messed up structure 
21:59:57 <edwardk> timethelion: depends on your fiscal calendar etc =)
22:00:57 <ddarius> Yeah, the time stuff in Haskell is supposed to be not very good.
22:01:01 <edwardk> the main reason I could see for the existence of timediff is to describe modifications you want to make to times. which i guess in that context the current implementation would make sense. if you look at it, normalizeTimeDiff actualy breaks the model
22:02:02 <TSC> It seems like diffClockTimes only sets the seconds and picoseconds fields (and leaves the rest as zero), so you do get the difference in sensible units
22:02:03 <edwardk> so you could say you want to add a month to the current time, well, that is 'dependent' on the current time you are adding it to, since months change lengths, so you can't transform that into a difference in seconds. and timediff gives back seconds between two absolute times like it should
22:02:09 <SamB> it's probably impossible to get that right
22:02:12 <edwardk> its just the existence of normalize time diff thats kinda dumb
22:02:50 <SamB> I mean, time and date libraries...
22:02:50 <edwardk> or at least hard to understand how its going to work
22:04:06 <edwardk> since a /= addToClockTime b  $normalizeClockTime $ diffClockTime a b in general
22:04:30 <edwardk> er s/normalizeClockTime/normalizeTimeDiff
22:04:58 <ddarius> @google Haskell NewTime
22:05:00 <lambdabot> http://haskell.org/hawiki/TimeLibrary
22:05:07 <SamB> it's not there
22:05:11 <SamB> Igloo broke it
22:05:23 <timthelion> let td = diffClockTimes (TOD 8640100 0) (TOD 1 0) in div (tdSec td) 86400 
22:05:26 <timthelion> verse
22:05:33 <timthelion> let td = normalizeTimeDiff $ diffClockTimes (TOD 8640100 0) (TOD 1 0) in tdYear td * 365 + tdMonth td * 30 + tdDay td   
22:05:34 <SamB> he said something about the old wiki being misleading or something
22:05:39 <timthelion> they both do the same thing
22:05:50 <edwardk> yeah
22:06:26 <timthelion> edwardk: which one looks clearer to you?
22:06:34 <ddarius> There is a lot of good stuff on the old wiki!
22:06:37 <edwardk> timthelion: the former
22:06:54 <edwardk> timethelion: with an explanation of how diffClockTimes works it should be perfectly clear
22:07:13 <timthelion> ok
22:21:27 <timthelion> grr, I hate the error Not in scope, now Prelude System.IO> do exist <- doesFileExist "dvorakvimcheetsheet.pdf"; if exist then "hi" else "bye" is telling me doesFileExist isn't in scope. 
22:21:45 <timthelion> @src doesFileExist
22:21:46 <lambdabot> Source not found. My mind is going. I can feel it.
22:23:36 <timthelion> is there a data construct like Maybe which instead of having Just a and Nothing it has Just a and Error String? 
22:23:38 <ddarius> > doesDoesFileExist
22:23:39 <lambdabot>   Not in scope: `doesDoesFileExist'
22:23:49 <ddarius> Either String
22:24:26 <Cale> :t System.Directory.doesFileExist
22:24:28 <lambdabot> FilePath -> IO Bool
22:24:36 <timthelion> oh, 
22:24:36 <Cale> It's in System.Directory
22:24:51 <timthelion> how do I find out these things?  
22:25:06 <ddarius> Ah, I got the name wrong.
22:25:11 <ddarius> > doesDoesFileExistExist
22:25:12 <lambdabot>   Not in scope: `doesDoesFileExistExist'
22:25:40 <dibblego> doesDoesFileExistExist does not exist
22:25:52 <shapr> Probably not not!
22:26:19 <shapr> But I did do the same sort of naming errors today and cost myself half an hour of wonderment.
22:27:08 <timthelion> shapr: is wonderment a synonym for frustration or are you uberzen? 
22:30:48 <cdsmith> Hey everyone.  I need some really simple matrix operations for very small matrices (i.e., performance is irrelevant) over the ring Z `mod` 5.  Is there a better way than writing it myself?
22:31:36 <mm_freak> cdsmith: writing it yourself should be fairly easy
22:31:49 <timthelion> http://rafb.net/p/e6ZzwB57.html
22:31:50 <lambdabot> Title: Nopaste - do syntax?
22:31:53 <wli> cdsmith: The math libraries page linked from the applications and libraries page linked from the front page of haskell.org have things for that.
22:32:03 <cdsmith> mm_freak: Yeah, but I just don't want people to read the code and think "Why didn't he use..."
22:32:35 <mm_freak> cdsmith: you're using haskell, so there's no way around that =)
22:32:53 <cdsmith> :)
22:32:59 <mm_freak> there are always about a dozen completely different ways to express something
22:33:06 <timthelion> mm_freak: what do you mean that there's no way around that?
22:33:49 <mm_freak> timthelion: there's always someone gonna say "i'd have been using $SOME_OTHER_EXPRESSION"
22:34:07 <cdsmith> mm_freak: how would you do it yourself?  Data.Array?  Something else?
22:34:32 <ddarius> For very small matrices, you can probably get by with lists of lists.
22:34:40 <mm_freak> don't know…  i'd probably define a new type
22:34:56 <cdsmith> ddarius: right.  And the matrices are always 5x5, so that's probably fine.
22:35:00 <timthelion> mm_freak: if that's why you should write all 12 and upon the first 12 times that function is called, enumerate the 12 recording the times, and then stick with the function that ran the fastest. so you'd always get the best preformance for the system.
22:36:33 <mm_freak> timthelion: you can leave out some of them right away =)
22:36:42 <shachaf> timthelion: I may have missed the context, but are you asking about (IO "hi") there?
22:37:54 <timthelion> shachaf: look at the bottom one first I guess, but yes I'm asking why it says it's out of scope and why ghci is expecting IO t if IO is out of scope
22:38:13 <shachaf> timthelion: The *type* is IO t.
22:38:27 * cdsmith contemplates implementing determinant for [[Int]], looks for linear algebra book, and decides another library dependency isn't so bad after all. :)
22:38:27 <shachaf> timthelion: But that's not a type constructor.
22:38:37 <shachaf> timthelion: To wrap in IO, use return, like any other Monad.
22:38:38 <Cale> timthelion: perhaps you want  return "hi"  and  return "bye"
22:39:11 <timthelion> cale thanks
22:39:19 <nanothief> is it possible to use the haskell intepretor in a shell script, ie #!/bin/ghcii -someflags \n putStrLn "Hello"
22:39:33 <shachaf> nanothief: Use runghc.
22:39:41 <Cale> nanothief: yep, #!/usr/bin/env runhaskell
22:39:42 <cdsmith> nanthief: -e, IIRC
22:39:50 <shachaf> nanothief: (Or runhaskell, when you don't care which implementation.)
22:39:54 <mm_freak> cdsmith: are the matrices gonna be quadratic all the time?
22:40:03 <timthelion> @src Either
22:40:03 <lambdabot> Source not found. Maybe if you used more than just two fingers...
22:40:27 <cdsmith> mm_freak: they are 5x5, with elements in Z mod 5.  (Or I could generalize, but I don't see the need.)
22:40:28 <ddarius> data Either a b = Left a | Right b
22:41:05 <dfranke_> aargh.  Could S3's ACL documentation possibly be any more vague?
22:41:08 <ddarius> cdsmith: Apply the recursive definition of the discriminant.
22:41:26 <timthelion> dfranke_: it could not exist.
22:41:35 <cdsmith> ddarius: I'm afraid I may sound like I know more math than I do.  How's that again?
22:41:38 <ddarius> Or go the GA route and the discriminant is just the magnitude of the pseudoscalar!
22:41:41 <mm_freak> yes…  it's probably easier to generalize than not to do it
22:41:56 <RyanT5000> so i have a bunch of data that needs to be serialized
22:42:09 <mm_freak> cdsmith: just don't require the matrix to be 5x5
22:42:10 <RyanT5000> there may be various competing type systems operating on it
22:42:42 <cdsmith> mm_freak: okay, so n x n with elements in Z mod n.  I still don't know what discriminant means. :)
22:42:48 <timthelion> RyanT5000: wow, are you a salesman?
22:42:58 <RyanT5000> timthelion: huh?
22:43:24 <RyanT5000> anyway the question is, what's a good representation? String is probably bad; is dons' bytestring stuff right for this?
22:43:30 <timthelion> RyanT5000: well you just used 3 buzwords
22:43:48 <mm_freak> cdsmith: so the ring's cardinality is always the same as the vector size?
22:43:51 <RyanT5000> timthelion: which were the buzzwords? i can't think of a particularly less-buzzy way of phrasing it
22:44:06 <cdsmith> mm_freak: Yeah, that's a weird consequence of the problem.
22:44:15 <RyanT5000> timthelion: can you?
22:44:16 <timthelion> RyanT5000: well serialized and competing
22:44:21 <timthelion> I don't know. 
22:44:41 <timthelion> it just sounded like a pres release for some commercial sdk to me
22:44:50 <RyanT5000> sorry :P
22:44:58 <ddarius> Perhaps you're missing your calling.
22:45:30 <RyanT5000> it's the truth; i'm writing a distributed (buzz!) database, and i need to know that different clients will be able to interoperate (buzz!) properly
22:45:37 <cdsmith> RyanT5000: didn't sound sales-y to me.  No accounting for perceptions, I guess. :)
22:45:38 <shachaf> timthelion: How would you express that?
22:46:03 * shachaf things RyanT5000 was quite reasonable, and used the right words for the intended meaning.
22:46:05 <RyanT5000> they might not be written in haskell, so i can't use anything haskell too deeply in that part
22:46:13 <shachaf> (Which does not seem especially buzzy either.)
22:46:35 <timthelion> hrmph
22:46:47 <Cale> RyanT5000: yeah, ByteString would work -- this is textual data?
22:47:17 <Cale> (It'd also work for binary data, though there are some options like Data.Binary in that regard)
22:47:24 <shachaf> timthelion: How would you say "serialize" without saying "serialize"? :-)
22:47:24 <RyanT5000> Cale: it's unspecified; all i know i'll have is length and data
22:47:33 <ddarius> pickle!
22:47:34 <RyanT5000> shachaf: pickle :)
22:47:35 <RyanT5000> lol
22:47:45 <timthelion> shachaf: I don't know
22:48:02 <shachaf> RyanT5000: "Deflate", "marshall", according to Wikipedia.
22:48:07 <shachaf> Are those better?
22:48:36 <ddarius> Deflate doesn't make sense, marshall is on par with serialize.
22:49:05 <timthelion> nvm then
22:49:06 <wli> parse
22:49:11 <shachaf> ddarius: I also hadn't come across "deflate" before, actually.
22:49:20 <RyanT5000> Cale: basically, the data is not necessarily typed
22:49:35 <ddarius> wli: Well -serialization- is actually unparsing.
22:49:37 <timthelion> RyanT5000: then how do you hope to manipulate it?
22:49:56 <wli> ddarius: print, then
22:50:13 <RyanT5000> timthelion: applications built on this one will know the type, but i won't
22:50:42 <sjanssen> RyanT5000: have you seen Data.Binary?
22:50:49 <Cale> RyanT5000: so, something like raw binary data?
22:50:54 <timthelion> you writing mfc for webservers?
22:51:16 <RyanT5000> sjanssen: yeah, but i haven't looked at it thoroughly
22:51:19 <RyanT5000> Cale: yeah, pretty much
22:51:26 <mm_freak> cdsmith: then you can generalize most functions easily
22:51:42 <mm_freak> like addition:  matAdd = zipWith (zipWith (+))
22:51:50 <RyanT5000> timthelion: no, not quite; it's effectively a giant database table with no predefined columns
22:51:59 <sjanssen> RyanT5000: the 'Put' monad/monoid in that library is the handiest way to build ByteStrings efficiently
22:52:04 <wli> mm_freak: Using arrays isn't so bad.
22:52:13 <sjanssen> RyanT5000: and 'Get' provides LL(1) parsing on ByteStrings
22:52:20 <mm_freak> wli: of course, but he said that performance is really no matter
22:52:35 <cdsmith> mm_freak: I got lost, which probably has more to do with me than anything.  I'm just writing a naive determinant that expands cofactors along the first column.
22:52:43 <RyanT5000> sjanssen: sweet; that's the only kind of structure i expected to have imposed ever
22:53:13 <wli> mm_freak: Arrays are slightly more convenient in some respects. Certain indexing operations are uncomfortable in list representations.
22:53:35 <RyanT5000> timthelion: and, according to some heuristic(s), rows will be shipped around to people who the system thinks want them
22:53:55 <mm_freak> wli: true
22:55:33 <wli> mm_freak: The real killer is column operations, like column pivoting, forming the subdiagonal columns in LU decompositions, etc.
22:55:55 <mm_freak> yeah, that's very inconvenient and slow
22:56:18 <ddarius> Hmm...
22:56:42 * ddarius ponders hacking a very simple GA basis making this trivial.
22:56:51 <wli> ddarius: GA?
22:56:59 <ddarius> Geometric Algebra
22:59:56 <wli> ddarius: What sort of stuff are you thinking there?
22:59:58 <ddarius> Some cute GA (f is a linear transformation): det(f)I = f(I), f^-1(A) = f^T(AI)/f^T(I)
23:01:25 <wli> ddarius: I often have homogeneous equations to solve, and also linear systems over rings that are not division rings.
23:02:25 <dons> hackathon announcement is out: http://www.haskell.org/pipermail/libraries/2007-July/007778.html
23:02:26 <lambdabot> Title: ANNOUNCE: Haskell Hackathon 07 II: Freiburg: Oct 5-7
23:03:16 <wli> ddarius: Also singular equations where solutions are affine spaces.
23:03:31 <ddarius> wli: I've wondered about building a geometric algebra over a module.
23:03:58 <ddarius> Z/5 is actually a field, so things should work out.
23:05:02 <wli> ddarius: I'm usually more worried about the answers coming out wrong due to instability when dealing with real numbers. Dogslow SVD solving for the sake of robustness is of interest there.
23:05:43 <timthelion> ok, here's something very easy in a normal programming language that I don't know how to do well in haskell: foreach file in files if fileexists file then filesthatexist += file else message += file ++ " not found"
23:05:52 <cdsmith> Wow.  Six lines of code for determinant.  Not bad.
23:06:01 <dons> cdsmith, ddarius, dolio: so coming to the hackathon?
23:06:08 <dons> you guys like code, right?
23:06:28 <cdsmith> dons: nah, sorry.  I can't afford another cross-atlantic plane ticket so soon.
23:06:40 <timthelion> dons: I don't know that I can talk my dad into flying with me :(
23:06:41 <dons> ah well. gotta pester the euro guys then.
23:07:02 <TSC> timthelion: Looks like a job for partition
23:07:07 <RyanT5000> timthelion: i'm not sure what the "file exists" command in haskell is (it's in System.IO somewhere, i think)
23:07:08 <dons> timthelion: yeah :} same with sorear or sjanssen I'd imagine. we'll likely have the next one in the US though (or the one after that)
23:07:41 <timthelion> TSC: what is partition?
23:07:48 <wli> cdsmith: The Laplace expansion is super-slow. LU decomposition is the best way.
23:07:53 <timthelion> dons: are they kids too?
23:08:02 <RyanT5000> is there a partitionEither?
23:08:06 <dons> sorear is. sjanssen needs funding
23:08:15 <cdsmith> wli: Thanks, but again, with only 5x5 matrices, I'll take my chances.
23:08:16 <wli> Of course, most times if you're using determinants there's something wrong anyway.
23:08:20 <TSC> partition splits a list's elements into two classes, depending on whether each element satisfies some property
23:08:38 <wli> RyanT5000: ([x | Left x <- xs], [x | Right x <- xs])
23:08:53 <ddarius> dons: In Germany?!
23:08:57 <RyanT5000> wli: yes, i know how to write it; i was asking whether it was in the libraries :P
23:09:10 <wli> RyanT5000: No, not that I'm aware of.
23:09:45 <wli> My elementary issues are (a) nonempty lists (b) one of or both, but not neither.
23:10:51 <RyanT5000> timthelion: you're probably going to want to use mapM, since you want to do IO on a bunch of things
23:10:52 <dons> ddarius: yeah :)
23:11:01 <dons> ddarius: well, maybe you're an ICFP fan...
23:11:06 <mm_freak> dons: X is the hackathon?  where X ∈ { what, where }
23:11:16 <ddarius> dons: I'll need my leave for other things.  Knowing my luck, when you do have it in America, I'll be in some other country.
23:11:22 <dons> mm_freak: start here, http://www.haskell.org/pipermail/libraries/2007-July/007778.html
23:11:22 <lambdabot> Title: ANNOUNCE: Haskell Hackathon 07 II: Freiburg: Oct 5-7
23:11:32 <mm_freak> ah ok, that one
23:11:47 <dons> mm_freak: 3 days of serious Haskell library and tool work 
23:12:06 <dons> ddarius: hopefully we can keep up the 6-monthly routine with these hackathons
23:12:11 <dons> just following POPL and ICFP around
23:12:34 <timthelion> oscon is in portland, I might be able to drive to that, but I don't know if there would be a point in my going
23:13:15 <ddarius> timthelion: Four! talks by Simon Peyton Jones!
23:13:29 <timthelion> I'm flying to cali next week to compeat in a national track meat which makes it so I can't leverage my dad too much.
23:13:36 <mm_freak> dons: i guess i'm not skilled enough yet for doing serious haskell work
23:13:45 <timthelion> ddarius: but are they expensive to get into?
23:13:57 <ddarius> timthelion: Hell if I know.
23:15:22 <dons> i note the next POPL is in SF.
23:15:37 <ddarius> dons: When?
23:15:44 <dons> bos: interesting ^^ POPL on the west coast, might be a good chance for a US hackathon
23:15:49 <dons> January 10-12, 2008
23:16:08 <dons> we did the last hackathon just before POPL, in the UK, to catch those who'd flown in, along with the locals
23:16:30 <dons> so one in SF, or on the west coast, might fit well too, picking up guys like SPJ or Simon Marlow, who'd be at POPL anyway
23:17:05 <bos> ooh!
23:17:12 <ddarius> dons: That may be doable, but I'll probably burn my leave before then and/or want the leave I'll have for personal stuff.
23:17:28 <bos> yeah, hackathon at popl would be great.
23:17:43 <dons> so the last UK hackathon picked up hmm, 5 or so people who wouldn't be there 'cept for POPL (like me), and then 15 or so locals who could get to oxford
23:17:54 <dons> i'd imagine we'd get a similar spread if we held one around POPL. 
23:18:15 <dons> a few people who can make it, since they get a flight for POPL, and then a bunch of west coast people
23:18:36 <ddarius> Luckily, there are a bunch of West Coast Haskellers.
23:18:41 <dons> yeah
23:18:52 <bos> a small bunch, but yes.
23:18:56 * timthelion thinks about whether time spent hacking or time spent working for money to go to cons is more important... 
23:19:14 <dons> so that seems like a reasonably good idea, one somewhere on the west coast before or just after POPL
23:19:20 <bos> it would probably be easy to get space at google, but i could probably arrange something in SF, too.
23:19:27 <pejo> dons, for the record i'm cheering from the side here. :-)
23:19:33 <cdsmith> Any better way of writing this?  flip mapM [1..5] $ \_ -> flip mapM [1..5] $ \_ -> randomRIO (0,4)
23:19:42 <cdsmith> dons: I would love a US hackathon.
23:19:43 <dons> cdsmith: forM ?
23:19:52 <glguy> replicateM
23:20:06 <dons> glguy wins
23:20:09 <cdsmith> @ty forM
23:20:11 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
23:20:15 <cdsmith> ok then
23:20:17 <dons> ?src forM
23:20:17 <lambdabot> forM = flip mapM
23:20:20 <cdsmith> @ty replicate<
23:20:22 <lambdabot> parse error (possibly incorrect indentation)
23:20:25 <cdsmith> @ty replicateM
23:20:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
23:21:10 <glguy> replicateM 5 $ replicateM 5 $ randomRIO (0,4)
23:21:14 <ddarius> 4
23:21:20 <ddarius> er nm
23:21:25 <cdsmith> glguy: thanks
23:22:11 <ddarius> :t join (.) (replicateM 5) $ randomRIO (0,4)
23:22:13 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
23:22:13 <lambdabot>       Expected type: m a -> m a
23:22:29 <ddarius> Stupid HM not being able to generalize \f -> f . f
23:22:36 <glguy> ddarius: let f = replicateM 5 in f $ f $ randomIO (0,4) -- is shorter ;)
23:22:42 <Cale> > replicateM 5 . replicateM 5 $ randomRIO (0,4)
23:22:44 <lambdabot>  <IO [[Integer]]>
23:23:08 <RyanT5000> Data.Binary can't support recursive datastructures, can it?
23:23:15 <bos> sure it can.
23:23:23 <ddarius> A list is a recursive data structure.
23:23:28 <RyanT5000> sorry
23:23:29 <bos> not circular ones, though, without some work.
23:23:35 <RyanT5000> yeah, i meant circulare
23:23:38 <RyanT5000> *circular
23:23:51 <glguy> there is no way to know that it is circular
23:23:54 <RyanT5000> (isn't list a recursive data*type*?)
23:24:11 <dons> RyanT5000: you just have to break the loops yourself
23:24:22 <glguy> without some kind of low-level ghc specific magic
23:24:25 <RyanT5000> dons: yeah; i don't actually need to do it, i was just wondering
23:24:30 <ddarius> reallyUnsafePtrEq racing yay
23:24:33 <dons> SerTH does support them, through TH magic
23:24:51 <dons> but its unmaintained, so probably best used as a source of ideas.
23:25:11 <RyanT5000> dons: the magic is just in TH? there's no runtime nastiness?
23:25:28 * wli tries to figure out if there are any arrow instances for data AtLeastOneOf t t' = Both t t' | OnlyFirst t | OnlySecond t'
23:25:31 <dons> haven't looked. seems unlikely.... /me guesses
23:25:37 <glguy> my puppy loves me, I can't see how he's comfortable putting his head on my arm like this.... and it makes it really hard to type... but oh well ;)
23:26:05 <RyanT5000> glguy: i've seen dogs get in the most convoluted positions imaginable in order to "rest" their chins on someone
23:26:13 <ddarius> glguy: Dogs are often in positions that look uncomfortable.
23:26:18 <RyanT5000> sometimes the chin ends up pointing nearly straight in the air
23:26:22 <ddarius> glguy: You should know this.
23:26:29 <RyanT5000> to rest on a vertical arm, e.g.
23:26:40 * ddarius loves dogs.
23:28:05 <wli> If we can't have a type-level lambda, can we at least get a type-level flip?
23:28:43 <glguy> does : type Whatever a b = Youknow b a   work?
23:28:51 <Cale> wli: well, you can do newtype
23:28:58 <wli> glguy: Good point.
23:29:04 <wli> Cale: Not so good of a point.
23:29:13 <glguy> but type synonyms don't like to be partially applied?
23:29:25 <wli> Ugh.
23:29:27 <Cale> Partially applied 'type' certainly won't work in an instance head.
23:29:46 <ddarius> wli: Yes.  You can implement (and Oleg has implemented) the lambda calculus in the type system.
23:30:00 <bos> i look forward to having such a colourful obit: http://www.telegraph.co.uk/news/main.jhtml?xml=/news/2007/07/04/db0402.xml
23:30:01 <wli> ddarius: Oleg has the answers to all my questions. ;)
23:30:03 <lambdabot> http://tinyurl.com/2n8rgu
23:30:28 <pejo> ddarius, all of it?
23:30:56 <Cale> ddarius: but is that the same as having a type-lambda?
23:32:13 <ddarius> http://www.haskell.org/pipermail/haskell/2006-September/018486.html
23:32:14 <lambdabot> Title: [Haskell] On computable types. I. Typed lambda and type closures, http://tinyurl.com/2x8mvd
23:32:21 <wli> I don't want/need a type lambda, just to get instances on partially applied types with various permutations of their arguments (esp. flip on one of arity 2).
23:33:00 <ddarius> The next in the series specifically addresses flipping type constructors.
23:35:36 <RyanT5000> is there a way to get the spineless tagless g-machine paper without an ACM subscription?
23:35:43 <ddarius> I believe so.
23:35:50 <wli> Well, if type lambdas are defineable anyway, might as well include them.
23:35:52 <RyanT5000> i keep finding other things
23:35:53 <ddarius> You can certainly get -some- paper on it.
23:36:22 <pejo> RyanT5000, SPj has lots of papers on his homepage. Check scholar.google.com for a bunch of copies of it. 
23:36:32 <RyanT5000> pejo: thanks
23:36:39 <ddarius> wli: The issue is the -fallow-undecidable-instances at the top.
23:37:21 <ddarius> However, there was a paper proposing limited type level lambdas for handling things like flipping args or composing constructors.
23:48:10 <wli> If there's an arrow involved it's not on the thing directly.
23:49:08 <ddarius> What are you talking about?
23:49:28 <wli> ddarius: data AtLeastOneOf t t' = Both t t' | OnlyFirst t | OnlySecond t'
23:52:38 <ddarius> Indeed, what would arr f mean?
23:53:05 <ddarius> Also, you would think that it should be something that is contravariant in it's first argument.
23:53:23 <wli> ddarius: My assumption here is that there's some sort of derived instance with AtLeastOneOf involved, like ArrowChoice.
23:53:37 <mm_freak> lemmih: the link from hackage to your homepage is dead
23:53:57 <mm_freak> for the `classify' package
