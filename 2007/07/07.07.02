00:00:00 <sorear> 'night all.
00:00:10 <dons> glguy: nah, isaac set it up on another isp.
00:00:20 <glguy> when did that happen?
00:01:11 <dons> we're still setting it up. Igloo's the main guy, but hmm, 2 weeks ago?
00:01:17 <glguy> ah, ok
00:01:26 <dons> its not officially announced yet
00:01:31 <glguy> Isaac has been busy lately, he just got married too
00:01:39 <glguy> and we've had a lot going on at work
00:01:44 <glguy> I haven't had as much time to chat
00:02:16 <glguy> now that he's married, he said he'll start playing on the soccer team :)
00:02:24 <dons> heh
00:02:45 <dons> everyone's growing up :)
00:21:02 <hpaste>  mgsloan pasted "/me grins - gtk2hs menu 'DSL' but not really a DSL" at http://hpaste.org/1502
00:26:38 <hpaste>  katz60 pasted "katz60" at http://hpaste.org/1503
00:31:10 <glguy> ?get-shapr
00:31:10 <lambdabot> shapr!!
00:31:27 <opqdonut> :)
00:32:13 <glguy> they are random addresses :0/
00:32:51 <kral> ahoy
00:33:06 <mgsloan> I bet its just that hpaste got added to some auto program
00:33:46 <glguy> I'd block nick == title...
00:33:58 <glguy> but I can't get it to compile right now :)
00:34:04 <mgsloan> or start work on a Bayesian filter system :)
00:34:51 <dons> so they must have some big distributed spam ap, and added a rule for spamming hpaste, i guess
00:35:08 <mgsloan> probably
00:35:23 <dons> hence the initial Idiots/Idiots manual post. automated forever after
00:35:33 <kfish> i've seen similar intro text ("nice site! good work guys!" etc.) in trac spam
00:35:46 <glguy> I wouldn't mind putting HTTP authentication
00:35:51 <glguy> and then having the u/p in the channel :)
00:35:55 <glguy> but that kind of breaks linking
00:35:56 <mgsloan> heck could even be one of those bot farm things you hear about
00:35:57 <glguy> :(
00:36:19 <dons> mgsloan: right, its coming from a whole range of addreses, roughly one an hour for the last 3 days
00:37:03 <mgsloan> yeah, who would stay up for 3 days just to spam hpaste every hour? :)
00:37:09 <kfish> how about if you give it your nick, hpaste msg's you a one-time passwd on irc, and you have to submit that with your paste?
00:38:46 <dons> actually there was a gap of a day between the first, and then the automated
00:38:47 <dons> 07.06.27:20:35:14 <hpaste>  Idiots pasted "Idiots" at http://hpaste.org/428
00:38:47 <dons> 07.06.29:11:35:30 <hpaste>  jimitheking pasted "jimitheking" at http://hpaste.org/1437
00:39:13 <dons> then its every 3-4 hours after that
00:39:17 <mgsloan> ah, the idiots one was perhaps the test
00:39:20 <mgsloan> for the rule
00:39:44 <mgsloan> could even be the IP of the 'botmaster'
00:40:20 <mgsloan> what I've never understood, is if viagra funds all the internet crap or not
00:40:30 <dons> though there was a 13 hour gap between
00:40:31 <dons> 30 11
00:40:31 <dons>     -- 13 hour gap
00:40:31 <dons> 01 12
00:40:48 <dons> it was every 3 hours before then and roughly every 2 hours after
00:40:51 <mgsloan> well, I mean, that was a human
00:40:54 <dons> so must've optimised the script
00:40:59 <mgsloan> then they added the rule to the thingie
00:41:00 <Wild_Cat> well, Viagra is what all those backboners run on, isn't it?
00:41:08 <mgsloan> har har
00:41:16 * Wild_Cat ducks
00:41:18 <dons> mgsloan: yeah, that's what I think. originally manually worked how to paste, the Idiots post
00:41:26 <dons> then added that to the script, and it kicked in a day later
00:42:00 <mgsloan> yep
00:42:17 <dons> so it'll likely continue till we break the script
00:42:21 <glguy> anyone know what HAppS's "html" function turned into?
00:42:57 <mgsloan> let's find out the IP of the Idiots one, get the location, and then break his computer :)
00:43:19 <dons> yeah, would be intereesting to know the first IP.
00:43:23 <glguy> I think that just having a password in the channel topic
00:43:29 <glguy> and requiring that to post would be enough
00:43:48 <dons> more than enough, i suspect. that would probably work for all time. :)
00:44:14 <mgsloan> would be annoying, but I guess most browsers can automate it
00:44:15 <dons> so we don't want to use a captcha, or something else on the submit page?
00:44:34 <dons> it would be good to ensure text submission keeps working. so .png is out.
00:44:36 <earthy> I think the 'pick the odd one out' picture captcha's would be perfect
00:44:44 <mgsloan> might try changing the field names first
00:44:50 <dons> yeah, then my w3m submit script won't work
00:44:56 <mgsloan> oh
00:45:00 <dons> yeah, chaning the field names might be easiest
00:45:08 <dons> it'll break the emacs integration, but is easy to fix.
00:45:18 <dons> then its a matter of whether they care enough to come back and work it out
00:45:36 <mgsloan> same for the password
00:45:59 <mgsloan> unless it's changed periodically (LB/haste collaboration :) )
00:47:13 <johnnowak> you can generate a haskell expression trivial enough for a human to solve easily, or for a script to do if necessary, and require the answer to be entered
00:47:34 <johnnowak> might be.. er, fun
00:47:48 <kfish> johnnowak, yeah, but probably easier for bots than newbies ;-)
00:47:59 <johnnowak> could be 1 + 1 :)
00:48:32 <kfish> hey, at least if you have to evaluate a haskell expression, it'll encourage spammers to write their spam-bots in haskell
00:48:48 <johnnowak> aye
00:49:29 <glguy> they'll /msg lambdabot
00:50:06 <ttmrichter> If I'm encountering a line of code like this all the time "do { x <- operation; return (x) }" is there any way for me to combine the <- and the return operations into one?
00:50:56 <mgsloan> that's the same as "operation" :)
00:51:08 <ttmrichter> Oops.  Sorry.  Typo.
00:51:17 <ttmrichter> If I'm encountering a line of code like this all the time "do { x <- operation; return ([x]) }" is there any way for me to combine the <- and the return operations into one?
00:51:31 <ttmrichter> Forgot the squares around "x".  :)
00:52:28 <mgsloan> well, one, probably not the ideal way, is:
00:52:28 <mgsloan> sequence [operation]
00:53:09 <mgsloan> > [] 1
00:53:10 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `[a]'
00:53:10 <opqdonut> liftM (:[]) operation
00:53:11 <opqdonut> i guess
00:53:31 <opqdonut> liftM (:[]) (Just 1)
00:53:36 <opqdonut> > liftM (:[]) (Just 1)
00:53:37 <opqdonut> bah
00:53:38 <lambdabot>  Just [1]
00:53:55 <opqdonut> yeah, that should do it
00:54:03 <mgsloan> yeah, liftM is probably the best way
00:54:16 <opqdonut> it usually is ^_^
00:54:18 <ttmrichter> Hmm...  Let me try that.
00:55:14 <mgsloan> it even has a little Apocalypse head -> (:[])
00:55:35 * ttmrichter mutters something about finding which module has liftM in it now....  :D
00:55:52 <mgsloan> probably Control.Monad
00:55:55 <ttmrichter> Control.Monad?
00:55:58 <ttmrichter> Beat me to it.  :)
00:56:02 * mgsloan is surprised its not in prelude...
00:56:16 <ttmrichter> I was too.
00:56:44 <ttmrichter> liftM did it.  And I learned something new about Haskell idioms.  Thanks again.
00:57:09 <dons> ?index liftM
00:57:09 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
00:57:39 <mgsloan> ?src liftM
00:57:39 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
00:57:45 <mgsloan> heh, that's what i figured
00:57:56 <opqdonut> exactly :)
00:58:21 <mgsloan> looks nearly like the code ttmrichter posted
00:59:07 <mgsloan> wasn't there some sort of suggestor thing that analyzed code for substitution with functions?
00:59:12 <mgsloan> Dr.Haskell or somesuch
00:59:43 <ttmrichter> OK, next dumb question: typing "liftM (:[])" all the time is going to annoy me.  Is this a candidate for partial application?
01:00:41 <mgsloan> @let marr = liftM (:[])
01:00:46 <lambdabot> <local>:2:7:     Ambiguous type variable `m' in the constraint:       `Monad ...
01:01:04 <mgsloan> hmph
01:01:16 <opqdonut> :t let foo = liftM (:[]) in foo
01:01:20 <lambdabot> forall (m :: * -> *) a1. (Monad m) => m a1 -> m [a1]
01:01:30 <opqdonut> there ya go :)
01:01:32 <dons> liftAndBox :)
01:02:12 <mgsloan> heh, sounds like a manual labor job description
01:02:16 <ttmrichter> I just did it the experimental way.  It worked great.  I'm sometimes amazed at the tools Haskell gives for expressing thoughts.
01:02:37 <dons> that's the goal :)
01:02:56 <ttmrichter> Now if I have two operations....  :D
01:03:21 <mgsloan> then sequence is for you!
01:03:39 <opqdonut> ?src sequence
01:03:39 <lambdabot> sequence ms = foldr k (return []) ms
01:03:39 <lambdabot>     where
01:03:39 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
01:03:56 <mgsloan> sequence src always struck me as a bit ugly
01:04:01 <ttmrichter> As in something like: do { r1 <- op1; r2 <- op2; return (r1,r2) } becomes sequence....
01:04:04 <glguy> I want to meet some of these people that care that Paris Hilton went to jail or that she's alive and then him them on the nose with a rolled up newspaper
01:04:13 <opqdonut> ttmrichter: well, with [r1,r2] it does
01:04:24 <opqdonut> but not (r1,r2), that's a tuple
01:04:29 <ttmrichter> Dammit!  Again I forgot the [].
01:04:39 <ttmrichter> Make that return ([r1, r2])
01:04:45 <mgsloan> > sequence [Just 1, Just 2]
01:04:47 <lambdabot>  Just [1,2]
01:04:58 <opqdonut> yeah, that'll do what you want ttmrichter
01:05:05 <opqdonut> sequence [op1,op2]
01:05:10 <mgsloan> yep
01:05:11 <dons> glguy: cool, that sounds like fun. let's do it!
01:05:22 <glguy> or I could use my puppy's squirt bottle
01:05:27 <glguy> and spray them
01:05:30 <dons> nose whacking time!
01:05:34 <ttmrichter> Damn!  <rhetorical>Is there anything I can't express in Haskell?</rhetorical>
01:05:34 <glguy> and give a stern "NO"
01:05:59 <ttmrichter> I prefer the 9mm parabellum solution to the Hilton followers.  Without discharging firearms.  Insert the bullets manually.  :)
01:06:09 <mgsloan> then while collecting the people we can give the Idiots, Idiot's fellow's PC a visit
01:06:14 <dons> ttmrichter: you want to encode rhetoric in haskell?
01:06:18 <dons> ?const -- perhaps?
01:06:19 <lambdabot> Unknown command, try @list
01:06:24 <dons> :t const
01:06:27 <ttmrichter> If Haskell can do that, sure!  :O
01:06:27 <lambdabot> forall a b. a -> b -> a
01:06:58 <dons> > const "is this a rhetorical question?" "yes!"
01:07:00 <lambdabot>  "is this a rhetorical question?"
01:07:35 <opqdonut> :)
01:07:51 <mgsloan> haha
01:08:03 <ttmrichter> > sequence ["is this a rhetorical answer?", "yes!"]
01:08:03 <dons> i'm sure rhetorical questions form a monad.
01:08:04 <lambdabot>  ["iy","ie","is","i!","sy","se","ss","s!"," y"," e"," s"," !","ty","te","ts",...
01:08:19 * ttmrichter laughs.  "OK.  That was unexpected."
01:08:45 <dons> list monad is a monad of full and many surprises.
01:08:48 <glguy> ttmrichter: List Monad. List Monad: ttmrichter
01:08:49 <glguy> :)
01:10:21 <ttmrichter> Usually I hate terse coders.  The perl/C/whatever "cram it all into one line" ethos.
01:10:34 <ttmrichter> Yet here I'm making my code ever-more-terse and finding it more readable as a result.
01:10:37 <ttmrichter> Cool stuff.
01:10:42 <mgsloan> "is this a rhetorical answer?" >> "yes!"
01:10:43 <glguy> ?quote melt
01:10:44 <lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
01:10:50 <mgsloan> > "is this a rhetorical answer?" >> "yes!"
01:10:51 <lambdabot>  "yes!yes!yes!yes!yes!yes!yes!yes!yes!yes!yes!yes!yes!yes!yes!yes!yes!yes!yes...
01:10:55 <mgsloan> teehee
01:11:27 <mgsloan> so that might not exactly be readable, but noone would ever do that.. I hope
01:11:58 <glguy> mgsloan: unless that was exactly the behavior you needed for some reason :)
01:12:27 <mgsloan> which there are probably a few good ones
01:13:27 <kfish> it's all about taming the infinite
01:14:28 <mgsloan> ?src Monad List
01:14:29 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
01:14:35 <dons> ttmrichter: its all about embedding the domain you're working in, directly in your code. so you express the ideas exactly in the pseudo language for that domain
01:14:38 <mgsloan> ?src instance Monad List
01:14:38 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
01:14:52 <ttmrichter> dons: This is the part I'm finding so fascinating.
01:14:57 <dons> in the limit, a perfect mapping from domain concepts to implementation, meaning short code.
01:15:18 <mgsloan> dons - :) yeah, that's the approach I'm/we're taking
01:15:20 <quicksilver> dons: 'pseudo' ?
01:15:26 <ttmrichter> I'm currently writing the parser component of my YAML processor.  If you'd told me just two months ago that I'd be ENJOYING the act of writing a parser, I'd have scoffed at you and called you a damned liar.
01:15:42 <dons> quicksilver: i wanted to hint at embedded `notation' for the domain
01:15:48 * quicksilver nods
01:15:54 <mgsloan> though it seems often times you have to write one or two 'expanded' versions of the DSL, then write the DSL, and rewrite those bits
01:16:11 <dons> ttmrichter: and programming becomes more about finding the foundational concepts of the domain, and embedding them, rather than writing boilerplate
01:16:11 <ttmrichter> mgsloan: I think that's the process of discovering the core abstraction.
01:16:13 <scook0> > let x = (>>) . (flip replicate ()) in 10 `x` "hi!"
01:16:15 <lambdabot>  "hi!hi!hi!hi!hi!hi!hi!hi!hi!hi!"
01:16:19 <scook0> :)
01:16:35 <dons> yeah, the process of finding the core abstractions
01:16:42 <mgsloan> indeed
01:16:57 <ttmrichter> dons: This is why I've been so fascinated with Haskell, despite having rejected it for practical use six years ago.  The potential was there to be really good and now that I've found the time, I'm finding that potential and realizing it.  In dribs and drabs.
01:17:02 <dons> and suddenly coding is fun again
01:17:14 <ttmrichter> Nailed it, dons.
01:17:17 <ttmrichter> Coding is fun again.
01:17:19 <dons> things have come a long way in the last 4 years or so.
01:17:30 <ttmrichter> They have, yes.
01:17:59 <dons> yeah, there's something to embedded DSLs, producing them, and using them, that prevents coder boredom -- and bugs.
01:18:10 <ttmrichter> When I finish the rote translation from EBNF to Parsec, incidentally, I forsee lots of fun optimization of the grammar afterwards.
01:18:39 <mgsloan> ooh writing a language eh?
01:18:40 <dons> you get to think in the domain you care about, which is more fun than constantly translating between domain concepts and your impl. language.
01:19:01 <ttmrichter> Not writing a language, mgsloan.  Implementing a full, canonical YAML processor.
01:19:11 <mgsloan> ah, cool
01:19:23 <ttmrichter> Then I'll prod dons into replacing the cabal format with YAML.  :D
01:19:27 <dons> what's the existing hssyck/yaml thingy do, btw?
01:19:36 <ttmrichter> It's not very compliant with the spec.
01:19:51 <ttmrichter> It's barely compliant with 1.0 with a few oversights and holes.
01:19:51 <dons> ah ok. so more a pugs-specific thing?
01:20:03 <ttmrichter> No.  It's just out of date.
01:20:12 <wolverian> syck or the binding?
01:20:16 <ttmrichter> Syck.
01:20:21 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HsSyck-0.4
01:20:23 <lambdabot> http://tinyurl.com/yw5adl
01:20:26 <ttmrichter> Or at least all the Syck bindings I've seen.
01:20:31 <dons> oh, 'an interface to the syck C library for parsing and dumping YAML data'
01:20:34 <mgsloan> dons - one thing though, it'd be kinda neat to have syntactically original DSLs.  I suppose you could do this with strings, if haskell did it at compile time (unlikely)
01:20:52 <ttmrichter> YAML's model is more sophisticated than a parser and a dumper.
01:21:19 <ttmrichter> There are intermediate stages (serialization, representation, etc.) which can be hooked into for sophisticated applications like in-process marshalling, etc.
01:21:25 <mgsloan> though, keep in mind, with laziness parser/dumper often times becomes streamer, on its own
01:22:02 <mgsloan> oh, ok
01:22:08 <gene9> src snoc
01:22:09 <ttmrichter> The stages of YAML are application-native -> representation (node graph) -> serialization (event tree) -> presentation (character stream).
01:22:32 <mgsloan> ah, interesting
01:22:50 <ttmrichter> You could use a full YAML stack, for instance, for RPC calls optimizing by hooking at different levels for in-process communication, out-of-process communication and persistent communication.
01:23:19 <mgsloan> fun fun. I'll probably just use it for config, though :)
01:23:26 <ttmrichter> That's what most would do, yes.
01:23:40 <ttmrichter> But given a full YAML stack some may choose to use the whole thing.  :)
01:23:51 <ttmrichter> And it's a great exercise for me to learn various bits of Haskell.
01:24:07 <ttmrichter> For example I have to do a lot of work with type classes for the application->representation layer.
01:24:13 <dons> snoc xs x = xs ++ [x] -- usually, gene9
01:24:15 <ttmrichter> In effect providing a marshalling interface for application data types.
01:24:22 <dons> gene9: unless you're using bytestring or dlist.
01:24:39 <gene9> dons, thank you, bytestring
01:24:56 <dons> oh , you don't want to know ;)
01:24:57 <dons> snoc (PS x s l) c = unsafeCreate (l+1) $ \p -> withForeignPtr x $ \f -> do
01:24:57 <dons>         memcpy p (f `plusPtr` s) (fromIntegral l)
01:24:57 <dons>         poke (p `plusPtr` l) c
01:25:23 <dons> its cheaper for lazy bytestrings -- there is like the [a] version
01:25:29 <gene9> whoa... nice :)
01:25:30 <dons> but with better complexity
01:25:52 <mgsloan> ttmrichter: yep, sounds like a very good project
01:26:15 <dons> ttmrichter: re marshalling interfaces, and avoiding tons of type classes, you've looked at Data.Binary?
01:26:21 <ttmrichter> And it may actually be of some use to the community at large, which is a bonus in my mind.  As a "craftsman" by personality I hate make-work.
01:26:31 <ttmrichter> dons: Not yet.
01:26:39 <dons> fast, efficent serial/deserial of haskell values. might be a good interface to steal ideas from
01:26:48 <ttmrichter> I'm working at the presentation layer right now with tools closest to what I've already worked with before.
01:26:54 <dons> maybe even the Put/Get monads for filling lazy bytestrings. could be reused
01:27:15 <ttmrichter> I plan on stealing^Wreusing as much as I can, actually.  I'm as lazy as Haskell....  ;)
01:27:23 <dons> :)
01:27:28 <dons> that's what hackage is for.
01:28:07 <mgsloan> yeah, main reason I just made this gtk menu DSLish thingamambob.  Now I just have to figure out where to put it
01:29:16 <mgsloan> maybe start up a Graphics.UI.Gtk.Utils
01:30:09 <ttmrichter> dons: I've practically ripped everything from Hackage by now.  :)
01:30:41 <ttmrichter> And, BTW, I wasn't joking about replacing the cabal format with YAML.  IT's already a proper subset of YAML from what I've seen, but could be made a whole lot more expressive if turned into actual YAML.
01:31:02 <ttmrichter> Like the ability to specify sub-projects in a project.
01:31:09 <ttmrichter> That would be cool by my reckoning.
01:32:00 <dons> oh, that's interesting. you should talk to nominolo , he's working on cabal and extensions for the summer of code
01:32:09 <dons> maybe you could guide him towards a fairly standardised format
01:32:21 <ttmrichter> Does he hang out here?
01:32:26 <dons> ?seen nominolo
01:32:26 <lambdabot> nominolo is in #ghc, #haskell-soc and #haskell. I last heard nominolo speak 8h 24m 19s ago.
01:32:29 <dons> yep.
01:32:31 <dons> should be up soon
01:32:38 <ttmrichter> If so, I'll just point him to http://yaml.org
01:32:39 <lambdabot> Title: YAML Ain't Markup Language
01:32:46 <ttmrichter> Shut up, 'bot!  :)
01:33:23 <ttmrichter> Really, YAML is a superset of the key:value pairing that cabal currently uses.
01:33:25 <ski> mgsloan : sequence = foldr (liftM2 (:)) (return [])
01:33:37 <ttmrichter> It just adds sequence types and the ability to nest data.
01:33:54 <ttmrichter> And ways of addressing looped structures in graphs through aliasing.
01:33:59 <mgsloan> ski: nice :)
01:34:29 <ski> (note that 'return' could be called 'liftM0')
01:34:37 <mgsloan> indeed
01:34:40 <ttmrichter> OK....
01:34:43 <mgsloan> return is actually a rather bad name
01:34:51 <mgsloan> just liftM would be very good
01:34:55 <dons> lift, yeah.
01:34:55 <ttmrichter> Now I "get" both return and the lift* functions.
01:34:58 <dons> lift0..n
01:34:59 <mgsloan> or lift
01:35:11 <mgsloan> yeah, what's the M for anyway
01:35:13 <quicksilver> well, lift is traditional used for lifting arrows, not object
01:35:15 <dons> but we want to trick C programmers.
01:35:15 <ski> 'liftM*' implies a monad
01:35:29 <ski> 'return' makes sense for 'Applicative's, too  ('pure')
01:35:31 <ttmrichter> What was the reason for naming it "return" anyway?  It doesn't act in any way like what a return does in any other language.  :)
01:35:50 <ski> ttmrichter : fooling C programmers
01:35:51 <dons> well, it sort of does, depending on the monad ;)
01:36:10 <opqdonut> in do notation return is a good name imo
01:36:13 <ttmrichter> It just confused this old warhorse.  :(
01:36:24 <mgsloan> only really makes some since in IO, once again propagating the whole IO/statefullness == monads thing
01:37:04 <ski> makes sense in 'Maybe','[]','Either e' too ..
01:37:23 <ski> (in some sense :)
01:37:32 <mgsloan> heh, yeah, once you know what it means :)
01:38:07 <dons> its more that C got the meaning of 'return' wrong ;)
01:38:12 * mgsloan changes the other prelude return into lift
01:38:17 <ski> e.g. 'Either e' could be thought of as an exception monad, with exceptions of type 'e' .. so 'return foo' then means "*return* 'foo', instead of throwing an exception"
01:38:34 <ski> @type Control.Monad.Trans.lift
01:38:38 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
01:38:50 <dons> liftMN
01:38:58 <ski> ?
01:39:28 <dons> or maybe liftT would have been a better name
01:39:34 <mgsloan> is there _really_ something wrong with lift/lift1/lift2? TheOtherPrelude doesn't really care much about conflicts, afterall
01:39:43 <mgsloan> lifT
01:40:22 <ski> 'Control.Monad.Trans.lift' could be called 'returnT' .. (but that may be confusing to uninitiated)
01:40:45 <ttmrichter> OK, another pattern I'm seeing.  do { x <- op1 ; xs <- op2 ; return (x:xs) }
01:40:55 <ski> liftM2 (:) op1 op2
01:41:09 <ttmrichter> :type liftM2
01:41:18 <ski> @type liftM2
01:41:20 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
01:41:21 <ski> :t liftM2
01:41:23 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
01:41:26 <ttmrichter> Ah!  @type.
01:41:31 <mgsloan> or :t
01:41:42 <mgsloan> why not :type?
01:41:49 <ski> because
01:41:53 <ttmrichter> I still can't read "forall" statements.  I have no idea what they do.
01:42:12 <mgsloan> most of the time, not much
01:42:15 <ski> (mgsloan : i.e. ask the introducer of the ':t' and ':k' shortcuts)
01:42:24 <ski> @type length
01:42:27 <lambdabot> forall a. [a] -> Int
01:42:37 <ski> length :: forall a. [a] -> Int
01:42:38 <mgsloan> they basically introduce type variables
01:42:44 <ski> forall a. length :: [a] -> Int
01:42:49 <mgsloan> usually it's inferred by the compiler
01:42:50 <ttmrichter> So liftM2 takes two monadic functions and applies a third function to them?
01:43:09 <mgsloan> but lambdabot is kinda verbose, and gives you the full type annotation
01:43:10 <ski> for all types 'a', 'length' may take a list of values of type 'a', and return an 'Int'
01:43:23 <quicksilver> ttmrichter: liftM2 takes a non-monadic function of two parameters
01:43:29 <quicksilver> ttmrichter: and 'lifts it into the monad'
01:43:35 <quicksilver> ttmrichter: i.e. applies it to two monadic values
01:44:04 <ttmrichter> So in this case it's lifting ":" into parsec's monadic parsers' space.
01:44:18 <quicksilver> yup
01:44:24 <ski> ttmrichter : liftM2 takes two monadic actions and gives a monadic action that when executed/run will run the two actions (in order) and then combine their result with the given function, monadically returning the combined result
01:44:28 <quicksilver> ':' of course is a pure function
01:45:44 <ttmrichter> So, reversing the view: liftM2 is extracting the value part generated by the monad in op1, then extracting the value part in op2, applying : and then reassembling the monad with the result?
01:45:48 <mgsloan> liftM2 takes two monadic actions and monadically gives a monadic action that when monadically executed/run will run the two monadic actions (in order) and then monadically combine their monadic result with the given monadic function, monadically returning the combined monadic result
01:46:12 <mgsloan> and yes, I'm kidding with that last bit
01:46:12 <ttmrichter> ?src liftM2
01:46:12 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
01:46:23 <ttmrichter> Gah!
01:46:34 <ttmrichter> It's word for word *IDENTICAL* to my code!  Gah!
01:46:42 <mgsloan> that's haskell for yah
01:46:52 <ttmrichter> I'm doing a lot of wheel reinvention.  :D
01:47:11 <mgsloan> the good sort, though
01:47:23 <mgsloan> you understand things better if you invented them yourself
01:47:23 <quicksilver> sometimes you have to reinvent the wheel once, to understand it
01:47:28 <ttmrichter> Well on the heartening side, it means I'm switching ever-so-slowly into the Haskell mindset.
01:47:31 <hpaste>  babak pasted "babak" at http://hpaste.org/1504
01:47:39 * ski sighs
01:47:43 <quicksilver> liftM2 isn't a "complicated library function you use because it's too hard to write it yourself"
01:47:56 <quicksilver> it's simply "giving a name to an obviously commonly used thing"
01:48:11 <ttmrichter> I was about to write it myself, actually, because I didn't want to keep typing all those finger-breaking combos.  :)
01:48:12 <quicksilver> a surprising amount of the haskell library is in the second category ratehr than the first
01:48:44 <mgsloan> yeah, would be interesting to split the prelude by that metric
01:49:13 <mgsloan> many of the prelude functions are one-liners
01:49:14 <ski> @type GHC.Exts.split
01:49:16 <lambdabot> forall t. (GHC.Exts.Splittable t) => t -> (t, t)
01:49:30 <quicksilver> I think the prelude is almost all in the second category
01:49:38 <quicksilver> things like Data.Map are more in the first
01:49:43 <mgsloan> yeah
01:49:50 <quicksilver> (well Data.Map isn't exactly hard to write but it's a significant amount of work)
01:50:11 <quicksilver> (especially if you can't remember how to get your tree to self-balance, which I can never quite remember the details of without checking)
01:51:17 <ttmrichter> One silly question: given the fact that functional data types are so different from imperative, why has there not been a concerted effort to provide rich, functional data types in Haskell libraries?  Or is this an area of active research/work?
01:51:28 <quicksilver> Data.Edison?
01:51:39 <ttmrichter> I was surprised to find no priority queue in Haskell's libs, for example.
01:52:01 <quicksilver> @where edison
01:52:01 <lambdabot> http://www.eecs.tufts.edu/~rdocki01/edison.html
01:52:04 <ttmrichter> Hoogle doesn't know about it.
01:52:25 <quicksilver> that's true. hoogle only knows about the standard library.
01:52:52 <quicksilver> you'll find edison is a fairly complete piece of work
01:53:07 <quicksilver> it's based on okasaki's extensive studies of efficient functional structures
01:53:07 <mgsloan> hmm, why isn't it stuck in the std libs?
01:53:12 <quicksilver> I have no idea.
01:53:27 <mgsloan> dons?
01:53:37 <ttmrichter> Perhaps there's an opportunity for dons to bludgeon^Winvite another Hackage package?  :D
01:54:18 <quicksilver> edison uses ghc extensions quite a lot, I think
01:54:29 <ttmrichter> It could be tossed in with GHC then.  :)
01:54:33 <quicksilver> I'm not sure if that's the reason, though (plenty of the standard lib uses GHC extensions)
01:55:03 <quicksilver> it will need substantial reworking when the new typeclass GADT associated type stuff comes in, I guess
01:55:04 <ttmrichter> Edison is on my disk and queued for research later this week.
01:55:53 <mgsloan> oh, that's probably the reason
01:55:56 <ttmrichter> Hmm...  It is cabalized.
01:56:31 <mgsloan> in fact, I'm sure that indexed type stuff is inspired by the very issues
01:56:34 <ttmrichter> It's got PATRICIAs?!
01:57:33 <ttmrichter> OK, going over the code is making me drool.
01:57:45 <ttmrichter> This is the stuff I've been wanting to see for the past six weeks.  :D
01:59:03 <ttmrichter> Is the MIT license compatible with the Haskell community's ethos?
01:59:14 <ttmrichter> Because it may not be in Hackage for licensing reasons otherwise.
02:00:04 <quicksilver> I think MIT is fine
02:00:08 <quicksilver> it's a pretty plain license
02:01:08 <dons> why isn't edison in the standard libs?
02:01:11 <dons> or the Queue, in particular.
02:01:31 <dons> we could probably get Queue into base, and maybe break up edison a bit -- its rather monolithic currently :/
02:01:43 <mgsloan> yeah
02:01:46 <quicksilver> dons: that's what we were asking :)
02:01:53 <Cale> Doesn't it use a nonstandard Prelude?
02:02:04 <Cale> Or has that been changed?
02:02:40 <mgsloan> I don't think so, there's this: http://www.eecs.tufts.edu/~rdocki01/edison/edison-api/src/Data/Edison/Prelude.hs
02:02:42 <lambdabot> http://tinyurl.com/2hmp8w
02:03:19 <Cale> Perhaps it's undergone really significant changes
02:03:24 <dons> yeah
02:03:32 <ttmrichter> That looks more to me like it's extending some Prelude classes.
02:03:40 <ttmrichter> Of course that's with my inexperienced eye.
02:03:48 <mgsloan> err, well, it tends to use prelude names
02:03:50 <dons> what's the relationship between edison and 'collections' ?
02:03:51 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/collections-0.3
02:03:53 <lambdabot> http://tinyurl.com/yt7z4y
02:04:07 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/EdisonCore-1.2.1
02:04:08 <lambdabot> http://tinyurl.com/2y94qw
02:04:29 <mgsloan> concat,reverse,map,concatMap,foldr,foldl,foldr1,foldl1, filter,takeWhile,dropWhile,lookup,take,drop,splitAt, zip,zip3,zipWith,zipWith3,unzip,unzip3,null
02:04:34 <dons> these should be broken up into a queue, tree, heap, etc package.
02:04:38 <Cale> We really ought to do something to get some of this code included with GHC, in some form, lest people write it over and over again :)
02:04:50 <mgsloan> all of these are implemented on the sequence type
02:05:01 <ttmrichter> Is that a problem?
02:05:13 <ttmrichter> If the semantics are the same and the underlying data type is different, why is this a problem?
02:05:29 <mgsloan> I agree with you
02:05:46 <mgsloan> indeed, in my current designs for a language, that's how it works.  But not in haskell
02:06:17 <ttmrichter> Well, you'd get a name clash in Haskell, but as I found out last night, this is easily worked around with creative use of imports.  :)
02:06:34 <Cale> Yeah, look at Data.Map :)
02:06:43 <mgsloan> true, but it'd get kinda awkward if it applied to all of the data thingamabobs
02:06:59 <ttmrichter> I have a function called "parse" after all which clashes badly with Parsec.
02:07:05 <Cale> I actually really dislike Haskell's choice of module path seprator
02:07:17 <mgsloan> yeah, it's annoying
02:07:18 <ttmrichter> Until someone pointed out I could rename parsec's parse to P.parse.  :)
02:07:39 <Cale> . is only like, the most commonly used piece of punctuation in my programs
02:07:46 <mgsloan> is ~ being used for anything? we could have Data~Map
02:08:06 <ttmrichter> You're a fan of the pointless style, Cale?
02:08:10 * ttmrichter innocently whistles.
02:08:13 <Cale> I like |, since it's only used for guards, and there's already a tendency to put spaces around those.
02:08:16 <Cale> ttmrichter: yeah
02:08:17 <mgsloan> :)
02:08:29 <Cale> Data|Map|map
02:08:34 <Cale> looks rather nice to me :)
02:08:38 <ttmrichter> I'm getting there, but currently find points-free a real horror to read.
02:08:45 <mgsloan> yeah, | could work
02:08:55 <Cale> ttmrichter: Well, there's good points-free and bad points-free :)
02:08:57 <mgsloan> I like ~ better for its relative little use
02:09:09 <mgsloan> good points-free makes more sense
02:09:28 <Cale> I'll use a lambda where it's clearer to do so.
02:09:52 <Cale> But usually I think of things in such a way that they break up into compositional chunks.
02:10:13 <Cale> Data~Map~map -- yeah, that's not so bad.
02:10:28 <antonio-zen> ?src &&&
02:10:28 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
02:10:41 <Cale> @type (&&&)
02:10:45 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
02:11:14 <Cale> (b ~> c) -> (b ~> c') -> (b ~> (c,c'))
02:11:19 <ttmrichter> ?src Data.Map
02:11:19 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
02:11:19 <mgsloan> :)
02:11:28 <Cale> ?source Data.Map
02:11:28 <lambdabot> http://darcs.haskell.org/packages/base/Data/Map.hs
02:11:37 <Cale> heh, it's evil :)
02:11:52 <mgsloan> ~> should be used for arrows
02:11:58 <Cale> The shorthand doesn't mean the same as the longhand :)
02:12:20 <ttmrichter> Cale, I'm sure there is good and bad points-free.  It's just that at this stage I'm not able to distinguish between them.  I find it all a bit bewildering when I see it -- and tend to have to manually introduce the points to follow the code.
02:12:26 <antonio-zen> ?src ~>
02:12:26 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
02:12:39 <Cale> antonio-zen: I was just using ~> as a variable name.
02:12:58 <antonio-zen> Cale: eheh, I got that
02:13:48 * ttmrichter quickly shuts the browser window with Data.Map in it....
02:14:03 <mgsloan> ?let (~>) = (>>) in return "woohoo!" ~> print
02:14:03 <lambdabot>  Parse error
02:14:12 <Cale> > map length . group . sort $ [7,1,2,1,2,5,2,3,2,1,3,6,3,6,8,3]
02:14:13 <lambdabot>  [3,4,4,1,2,1,1]
02:14:46 <ttmrichter> Problem one: . and $ -- what's the difference beyond precedence?
02:14:52 <Cale> The type.
02:14:57 <ttmrichter> :t .
02:15:01 <lambdabot> parse error on input `.'
02:15:02 <Japsu> :t (.)
02:15:03 <Cale> :t (.)
02:15:06 <mgsloan> $ is application, . is composition
02:15:07 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
02:15:07 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
02:15:13 <Cale> :t ($)
02:15:14 <ttmrichter> :t (.)
02:15:16 <lambdabot> forall a b. (a -> b) -> a -> b
02:15:17 <ttmrichter> :t ($)
02:15:18 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
02:15:20 <lambdabot> forall a b. (a -> b) -> a -> b
02:15:36 <Cale> (.) takes two functions
02:15:42 <Cale> ($) takes a function and a value
02:15:57 <Cale> (f . g) x = f (g x)
02:15:57 <ttmrichter> Where the value can be the results of a function.  Which is what I was screwing up.
02:16:06 <ttmrichter> ?src (.)
02:16:06 <lambdabot> (.) f g x = f (g x)
02:16:10 <Cale> ttmrichter: right
02:16:11 <ttmrichter> ?src ($)
02:16:11 <lambdabot> f $ x = f x
02:16:20 <quicksilver> what is a bit confusing is that in some circumstances, $ and . are interchangeable
02:16:27 <quicksilver> but this is because one is left-assoc and aone is right-assoc
02:16:37 <Cale> They're only interchangeable because ($) has the wrong associativity.
02:16:37 <ttmrichter> Which is which?  . is right?
02:16:40 <Japsu> (.) f g x = f $ g x
02:16:41 <Japsu> :)
02:16:53 <ttmrichter> Japsu: I hate you.
02:16:54 <ttmrichter> :)
02:17:01 <quicksilver> so f . g . h $ x is the same as f $ g $ h $ x
02:17:16 <Cale> quicksilver: Right, but not if I had my way.
02:17:20 * quicksilver nods
02:17:23 <yakov> hello
02:17:38 <quicksilver> Cale: I tried to convince ndm to rewrite some $ to . in one of his papers
02:17:39 <ttmrichter> OK, so why would I use f.g.h$x instead of f$g$h$x?
02:17:45 <quicksilver> ttmrichter: because it's nicer
02:17:55 <mgsloan> nah
02:18:01 <ttmrichter> When does the difference between them make a difference in outcome?
02:18:03 <Cale> ttmrichter: Well, it doesn't abuse the associativity of $, first of all.
02:18:04 <mgsloan> in that case I'd go straight $ probably
02:18:07 <quicksilver> ttmrichter: because the transformation from f . g . h $ x to map (f . g . h) l
02:18:11 <quicksilver> ttmrichter: is a natural one
02:18:13 <Cale> ttmrichter: also, refactoring
02:18:23 <Cale> f . g . h means something on its own
02:18:29 <Cale> f $ g $ h doesn't
02:18:43 <ttmrichter> The outcome is the same but it means nothing?
02:18:44 <quicksilver> and the reduction fff x = f . g . h $ x  -----> fff = f . g . h
02:18:45 <mgsloan> i guess I should change my style then
02:18:45 <ttmrichter> I don't get it.
02:18:58 <quicksilver> mgsloan: f $ g $ h doesn't even type check
02:19:01 <quicksilver> (probably)
02:19:03 <quicksilver> ttmrichter: that was for you :)
02:19:19 <quicksilver> if the types are correct for f $ g $ h $ x, then f $ g $ h probably doesn't type check
02:19:23 <mgsloan> unless h is a constant function, which in the case of f $ g $ h $ x, it isn't
02:19:25 <mgsloan> right
02:19:30 <ttmrichter> quicksilver: I'm not sure that I understand your reduction thing.
02:19:34 <quicksilver> f $ g $ h is not a sub-term of f $ g $ h $ x
02:19:46 <Cale> quicksilver put it nicely
02:20:00 <quicksilver> because f$g$h$x is actually f$( g$( h$x) )
02:20:09 <Cale> f $ g $ h $ x means f $ (g $ (h $ x))
02:20:12 <Cale> yes
02:20:25 <quicksilver> so f $ g $ h isn't a subterm at all
02:20:35 <mgsloan> yeah, you can't break parenthesis
02:20:36 <ttmrichter> But f.g.h$x means f (g (h (x)))  Or am I wrong?
02:20:42 <Cale> right
02:20:57 <ttmrichter> OK, I'm back to being lost.
02:21:00 <Cale> However, f . g . h on its own means something
02:21:13 <ttmrichter> What's the difference between f(g(h(x))) and f$(g$(h$(x)))?
02:21:15 <Cale> but in this case, you won't be able to write f $ g $ h
02:21:19 <mgsloan> in math notation (wish i could do proper dots..) it means f o g o h (x)
02:21:23 <Cale> ttmrichter: there is none
02:21:23 <quicksilver> ttmrichter: nothign at all
02:21:31 <quicksilver> ttmrichter: that's exactly what $ means
02:21:33 <Cale> ttmrichter: It's all about what happens when you remove that x
02:21:40 <ttmrichter> And yet you insist that they're different somehow.
02:21:43 <ttmrichter> This is what baffles me.
02:21:56 <Cale> Let me give an example...
02:21:57 <quicksilver> no, I'm not insisting they are different :)
02:22:02 <mgsloan> the best way to think of $, in my opinion, is that they're just a different syntax for parenthesis
02:22:06 <quicksilver> I'm saying f . g . h $ x is preferable
02:22:13 <Cale> :t map length . group . sort $ [1,2,3]
02:22:15 <lambdabot> [Int]
02:22:17 <ttmrichter> f.g.h.x is f(g(h(x))) and f$g$h$x boils down to f(g(h(x))).  So what's the difference?
02:22:19 <Cale> :t map length . group . sort
02:22:22 <lambdabot> forall a. (Ord a) => [a] -> [Int]
02:22:29 <quicksilver> ttmrichter: wrong. f.g.h$x
02:22:30 <Cale> :t map length $ group $ sort $ [1,2,3]
02:22:32 <lambdabot> [Int]
02:22:36 <Cale> :t map length $ group $ sort
02:22:38 <lambdabot>     Couldn't match expected type `[a]'
02:22:38 <lambdabot>            against inferred type `[a1] -> [a1]'
02:22:43 <Cale> See?
02:22:55 <Cale> That's the difference right there.
02:23:08 <Cale> (map length . group . sort) is a function
02:23:10 <ttmrichter> :t (.)
02:23:12 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
02:23:12 <ttmrichter> :t ($)
02:23:15 <lambdabot> forall a b. (a -> b) -> a -> b
02:23:20 <Cale> (map length $ group $ sort) is a type error
02:23:20 <ttmrichter> Let me work through that example.
02:23:35 <mgsloan> f.g.h /= f(g(h))
02:23:43 <Cale> Right :)
02:23:52 <ttmrichter> ?src (.)
02:23:52 <lambdabot> (.) f g x = f (g x)
02:23:55 <ttmrichter> ?src ($)
02:23:56 <lambdabot> f $ x = f x
02:24:13 <Cale> (.) takes two functions and produces a function
02:24:34 <ttmrichter> Now I get it.
02:24:37 <Cale> ($) takes a function and a value which it can be applied to, and applies it to get a result (which may not be a function)
02:24:50 <ttmrichter> Thanks.  You're showing a lot of patience with this dullard.  :)
02:24:56 <Cale> That's okay :)
02:25:12 <mgsloan> #haskell is pretty patient with those willing to learn
02:25:13 <ttmrichter> (.) ALWAYS produces a function as a result.
02:25:20 <Cale> right
02:25:22 <ttmrichter> ($) MAY produce a function as a result.
02:25:27 <Cale> yes
02:25:34 <ttmrichter> So SOMETIMES the two can be interchanged, but you can't rely on it.
02:25:45 <ttmrichter> If I intend the result to always be a function, I should use (.).
02:25:56 <Cale> Also, the only reason that they can ever be interchanged is a purely syntactic one
02:25:57 <ttmrichter> If I intend to use a value, I should use ($).
02:26:09 <ttmrichter> Is that about right?
02:26:13 <Cale> yeah
02:26:39 <ttmrichter> OK.  Next up: let ... in ... vs ... where ...
02:26:41 <Cale> So it goes at the end of chains of compositions, or before long values that you don't want to put brackets around
02:26:41 <mgsloan> actually, I think the best way to think about it is that with . you can compose functions, and $ gives you a nice syntax for parenthesis in some circumstances
02:26:53 <mgsloan> yeah
02:26:58 <ttmrichter> I favour the where version, but I see on at least one site with coding guidelines that let is preferred.  Why?
02:27:09 <Cale> The difference between let and where is that "let ... in ..." is an expression, whereas "where ..." is part of the syntax of a declaration.
02:27:25 <mgsloan> I think where is usually preferred..
02:27:26 <opqdonut> and (f.g.h) x or f.g.h $ x should be preferred to f $ g $ h $ x
02:27:32 <Cale> Also, "where ..." scopes over all the guards in a declaration.
02:27:33 <mgsloan> I like it more, anyway
02:27:33 <quicksilver> the other difference is that let puts the local defintions first, and where puts them afterwards
02:27:48 <quicksilver> I have always preferred let :)
02:27:53 <opqdonut> i like let more but somebody told me to use where
02:27:55 <mgsloan> really? huh!
02:27:57 <ttmrichter> I'm not sure where I see that difference for "expression" vs. "syntax".  Can I bundle up that expression somehow and access it elsewhere?
02:28:04 <Cale> Where is translated into let by the compiler.
02:28:04 <quicksilver> but sometimes I use 'let' for things I want the reader to read, and where for things I don't particularly
02:28:15 <Cale> ttmrichter: expressions evaluate to values
02:28:32 <opqdonut> > (let f = (+1) in f) 1
02:28:34 <lambdabot>  2
02:28:34 <ttmrichter> I've always preferred seeing the "big picture" code before seeing the "little pieces" that it's composed of.  So where feels natural to me.
02:28:38 <ski> > (x*x where x = 5) + 1
02:28:39 <lambdabot>  Parse error
02:28:39 <opqdonut> can't do that with where
02:28:44 <Cale> ttmrichter: me too
02:28:59 <Cale> I do end up using let sometimes though.
02:29:26 <ttmrichter> I'd guess that if the little bits are important to understanding, let makes more sense.
02:29:41 <quicksilver> that's sort-of what I think, yes
02:29:48 <ski> sometimes it is easier to read top-down, sometimes bottom-up
02:29:53 <quicksilver> let is more natural, perhaps, for imperative programmers
02:29:58 <ttmrichter> Weird.
02:30:02 <quicksilver> who expect the subcalculation tobe 'done first'
02:30:17 <ttmrichter> I have the opposite.  I'm only just beginning to enter functional mindsets and I prefer where.
02:30:20 <Cale> Also, there's a variant of 'let' which is available inside do-blocks, and where the 'in' part is omitted, the declarations are scoped over the rest of the block and can depend on the variables bound earlier.
02:30:23 <quicksilver> in C you have to write 'a = (.. long expr ..); b = a*2;'
02:30:26 <dons> only those who think they have to tell the compiler the evaluation order, quicksilver ;)
02:30:33 <Cale> So sometimes such a let can't be translated into a where.
02:30:53 <quicksilver> dons: yes, but I'm just saying it's more natural if that's what you're used to
02:30:53 <Cale> (at least, not without defining a whole seprate function for the lower half of the block)
02:31:32 <ski> > case not True of False -> x where {x = ()}; True -> error "False"
02:31:34 <lambdabot>  ()
02:31:53 <ttmrichter> Interesting.  So the page that advocated let over where doesn't represent, necessarily, community practice.  That's heartening.  :)
02:32:06 <Cale> They're both there for a reason :)
02:32:30 <quicksilver> there are cases for each, in which the other would be an unpleasant syntactic overhead
02:32:38 <ttmrichter> Well, bottom-test loops are in imperative languages for a reason, but most programmers don't use them more than twice in a year.  :)
02:32:51 <Cale> I think as far as programming languages go, 'where' actually predates 'let', curiously enough.
02:33:14 <ttmrichter> I do like that top-down vibe of where, though.
02:33:25 <Cale> 'where' occured in ISWIM, which was the never-implemented progenitor of all modern functional programming languages.
02:33:26 <ski> isn't 'declare ... begin ... end' in Pascal sortof like a 'let ?
02:33:46 <ttmrichter> From the OOP world, it reminds me of "template functions" (as opposed to C++ templates) with the "hotspots" that you redefine to refine your subclasses.
02:34:20 <ttmrichter> The "template function" allowed you to see the logic at a glance.  The hotspots provided the detail.
02:34:40 <ttmrichter> That's what where syntax reminds me of.
02:34:52 <Cale> Yeah, and that's a good way to think of it.
02:35:18 * ttmrichter mutters "should have come here before I coded 200 lines of a language recognizer...."
02:36:58 <ttmrichter> I'm recoding about 3/4 of the recognizer work so far with liftM2, liftM and sequence.
02:37:14 <ttmrichter> I believe the appropriate phrase rhymes with "clucking bell".
02:37:23 <mgsloan> hah
02:38:39 <quicksilver> Cale: I thought algol had 'let' ?
02:39:11 <Cale> quicksilver: hmm, good question -- was it an expression form though?
02:40:59 <Cale> hmm, let doesn't appear in the list of reserved words in Algol 68.
02:41:12 <ttmrichter> I think I have a new policy: if I see myself using a pattern three times in my code, I dredge over the library to find the code that someone has already written.
02:42:07 <quicksilver> Cale: it's often used in papers which introduce it with words like "we illustrate with examples in an algol-like minilanguage, the semantics of which we hope are obvious"
02:42:15 <Cale> It's funny going and looking at code I wrote as a beginner. There are lots of places where I can turn whole recursive functions into short little half-line things.
02:42:28 <quicksilver> Cale: but then, maybe peopple just internalise a whole lot of 'obvious' programming constructs into such toy languages
02:42:32 <Cale> yeah
02:42:45 <Cale> Both are certainly used a lot in mathematics.
02:42:55 <ttmrichter> I think it's funny that people talk about "algol-like" languages these days given that most people alive have never seen an Algol compiler used in anger.
02:43:46 <quicksilver> Cale: I am proud to be able to say I was actually taught semantics of functional languages by Landin himself :)
02:43:54 <Cale> :)
02:44:07 <quicksilver> although he doesn't use ISWIM these days
02:44:33 <Cale> What's he using?
02:45:04 <quicksilver> something he makes up as he goes along
02:45:13 <quicksilver> giving semantics as he goes
02:45:14 <Cale> ah
02:45:17 <quicksilver> it's a lot like lisp in spirit
02:45:20 <quicksilver> but has more syntax
02:45:30 <quicksilver> (and fewer parentheses)
02:46:02 <ttmrichter> ?src liftM3
02:46:02 <lambdabot> liftM3 f m1 m2 m3 = do { x1 <- m1; x2 <- m2; x3 <- m3; return (f x1 x2 x3) }
02:46:07 <scook0> huzzah -- my learning program takes ages to run, and performs worse than one that picks actions at random
02:46:14 <scook0> I can safely say it needs some work :)
02:46:31 <ttmrichter> scook0:  Just a little.  :)
02:49:29 <Cale> That reminds me of a TED talk, where Hans Rosling talked about giving a pre-test to his students about the global situation, and getting responses which were statistically worse than monkeys would have gotten.
02:50:06 * quicksilver nods
02:50:19 <quicksilver> we used to have a multiple-chocie maths test every year at school
02:50:23 <Cale> http://www.ted.com/index.php/talks/view/id/92 -- this one :)
02:50:29 <quicksilver> and some people managed to get worse than random choice, every year
02:50:51 <opqdonut> quicksilver: _average_ random choice
02:50:59 <quicksilver> opqdonut: yes, indeed :)
02:51:05 <opqdonut> and with tricky options that can happen quite easily
02:51:17 <wolverian> they don't use multiple choice here at all. I'm happy about that.
02:51:19 <Cale> The mean+-CI of the class was 1.8+-0.4
02:51:24 <ttmrichter> OK, another pattern which the first glances aren't covering.  do { x1 <- op1 ; x2 <- op2 ; xs <- op3 ; return (op1:op2:op3) }  I can't figure out how to apply (:) to three arguments with any of the prelude stuff.
02:51:32 <Cale> and the mean of the chimps was 2.5, of course
02:51:46 <quicksilver> opqdonut: over 100 questions, the S.D. is quite tight, so actually the chances of being significantly below average random choice are low
02:51:49 <Cale> er, if you know there were 5 questions
02:51:56 <Cale> (on this one he focuses on)
02:52:00 <quicksilver> opqdonut: but you're right about the trick questiosn
02:52:22 <opqdonut> ttmrichter: observe
02:52:32 <opqdonut> @pl f x y z = x:y:z
02:52:33 <lambdabot> f = (. (:)) . (.) . (:)
02:52:42 <quicksilver> that's nasty though :P
02:52:46 <opqdonut> yeh it is
02:52:47 <Cale> ttmrichter: liftM3 (\x y z -> x:y:z) op1 op2 op3
02:52:59 <ttmrichter> OK, so I have to toss in a lambda there.
02:53:04 <opqdonut> Cale's idea is probably better
02:53:07 <quicksilver> you don't "have" to.
02:53:08 <Cale> You probably actually want (\x y z -> [x,y,z])
02:53:10 <ttmrichter> And what does @pl actually mean?
02:53:12 <quicksilver> but it's probably neater
02:53:12 <Cale> unless z really is a list
02:53:18 <ttmrichter> Z is really a list.
02:53:20 <quicksilver> z really is a list
02:53:21 <Cale> ttmrichter: pointless :)
02:53:23 <quicksilver> that's why he called it 'xs'
02:53:26 <quicksilver> :)
02:53:33 <Cale> ah, okay :)
02:53:54 <quicksilver> it's a bit of a shame that you can't infix arbitrary expresions
02:54:09 <Cale> You can define a new infix operator, however.
02:54:09 <quicksilver> and write op1 `liftM2 :` op2 `liftM2 :` op3
02:54:19 <ttmrichter> By "shame" you mean "thank God for small favours", right quicksilver?
02:54:25 <opqdonut> wouldn't let (:::) = liftM2 (:) in op1 ::: op2 ::: op3  work?
02:54:25 <quicksilver> well, not really
02:54:30 <quicksilver> opqdonut: yes
02:54:32 <Cale> opqdonut: absolutely
02:54:37 <opqdonut> yeah :)
02:54:43 <quicksilver> ttmrichter: ` ` annoys me because it's somehow 'not first class'
02:54:50 <mgsloan> sequence would work as well, sequence [op1, op2, op3]
02:55:00 <quicksilver> ttmrichter: you can ` ` a single identifier but not any expression
02:55:01 <Cale> mgsloan: not quite in this case
02:55:01 <ttmrichter> Sequence didn't work out.
02:55:06 <ttmrichter> op3 is a list.
02:55:09 <ttmrichter> op1 and op2 are scalars.
02:55:09 <quicksilver> actually 'not first class' isn't what I mean
02:55:10 <mgsloan> ohh
02:55:15 <quicksilver> what I meant is 'not compisitonal'
02:55:20 * mgsloan didn't look carefully enough
02:55:20 <quicksilver> 'compositional'
02:55:21 <quicksilver> :)
02:55:29 <ttmrichter> I like that let-expressed solution.
02:55:33 <opqdonut> ttmrichter: liftM2 (++) (sequence [op1,op2]) op3
02:55:43 <ttmrichter> It illustrated exactly how let expressions are useful.
02:56:01 <opqdonut> well thank you :)
02:56:45 <ttmrichter> Of course all of those are too verbose, so they get wrapped up in a partial application.  :)
02:57:22 <quicksilver> it's also a case where I'd sort-of-like outfix operators
02:57:33 <quicksilver> seems to me that << >> might be a nice outfix for lifting
02:57:41 <opqdonut> quicksilver: outfix?
02:57:41 <quicksilver> op1 << : >> op2 << : >> op3
02:57:43 <quicksilver> or somethign
02:57:43 <Cale> btw, if anyone hasn't seen Hans Rosling's talk, I highly recommend it :)
02:57:46 <opqdonut> oh, that
02:57:58 <Cale> (It is totally offtopic though :)
03:00:35 <wolverian> quicksilver, circumfix :)
03:12:59 <nominolo> mornin'
03:13:52 <nominolo> ttmrichter: what exactly were you proposing?
03:15:37 <ttmrichter> Using YAML as the file format for Cabal projects.
03:15:57 <ttmrichter> What you've got already is a subset of YAML, so it wouldn't be too much of a change (as in none) to existing Cabal projects.
03:16:33 <nominolo> is there alroady a yaml parser writen in haskell?
03:16:45 <ttmrichter> There are two.  I'm working on a third, full-tilt YAML processor.
03:17:11 <ttmrichter> (YAML is more than a parser, you see.)
03:17:12 <nominolo> i need one with as little dependencies as possible
03:17:26 <ttmrichter> That leaves out the syck binding.
03:17:33 <ttmrichter> But the other one is still usable.
03:17:40 <ttmrichter> It's up on Hackage.
03:17:44 <nominolo> which one
03:18:02 <dons> note how something gains first class status once its on hackage
03:18:02 <nominolo> (i'm browsing though the spec)
03:18:10 <ttmrichter> Text.Yaml.Reference
03:18:14 <dons> everyone is execpted to have seen it, if its on hackage.
03:18:49 <mgsloan> dons - by that data, looks like china is going to pwning pretty soon
03:19:11 <ttmrichter> Which dat?
03:19:18 <ttmrichter> Data, I meant.
03:19:36 <mgsloan> the Hans Rosling video.  indeed pretty interesting
03:19:36 * ttmrichter is living in China, so is interested.
03:19:57 <mgsloan> it's a presentation of world demographics, trends, etc
03:20:02 <nominolo> ttmrichter: what's interesting to me is: "YAML is easily readable by humans" and more importantly: "YAML is expressive and extensible."
03:20:10 <ttmrichter> Both are true.
03:20:12 <ttmrichter> Very true.
03:20:32 <ttmrichter> YAML *CAN* be made unreadable, of course, if you turn all the dials to 11, but any expressive language has this trait.
03:20:50 <ttmrichter> But YAML as it is used is very readable, even for complicated data structures.
03:20:59 <nominolo> since hacking in the parsing for the configurations felt kinda dirty
03:21:02 <ttmrichter> (Ruby on Rails, for example, is configured with YAML files.)
03:21:33 <ttmrichter> And the tagging mechanism makes it possible to easily insert custom structures that are easily transformed.
03:21:58 <ttmrichter> There could be a whole "cabal-project-document" tag, for example.
03:22:23 <ttmrichter> Cabal could support multiple projects in a single file with project dependencies highlighted in the syntax.
03:22:41 <ttmrichter> I could have a project that builds three executables, say, and eight support libraries.
03:22:52 <ttmrichter> Each of which is independently extractable should I so desire.
03:23:09 <ttmrichter> Either programmatically or just by text cut-and-paste.
03:24:18 <nominolo> well, the functionality of cabal is a bit trickier than finding the right syntax
03:24:27 <nominolo> but i take a look
03:24:28 <ttmrichter> Agreed.  :)
03:24:37 <ttmrichter> But what you've got is already a YAML subset.
03:24:56 <nominolo> maybe i make sure to have a subset, with extensions to full yaml in mind
03:24:56 <ttmrichter> And YAML can deal with far richer relationships than key:value pairs ever could.
03:25:08 <ttmrichter> That was to be my suggestion.
03:25:19 <nominolo> ttmrichter: we now have sections and ifs, too!
03:25:21 <ttmrichter> Keep YAML in mind as an "upgrade path" while you develop.
03:25:22 <nominolo> :)
03:25:37 <ttmrichter> Ah.  That's not in the Cabal I'm using obviously.  :)
03:25:44 <nominolo> http://hackage.haskell.org/trac/hackage/wiki/CabalConfigurations
03:25:45 <lambdabot> Title: CabalConfigurations - Hackage - Trac
03:25:54 <nominolo> no it's in my SoC repo
03:27:41 <gleb> @src nub
03:27:41 <lambdabot> nub = nubBy (==)
03:27:47 <gleb> @src nubBy
03:27:47 <lambdabot> nubBy eq []             =  []
03:27:47 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
03:31:57 <ttmrichter> And I've finally undone the damage I did by not coming here to ask questions first.
03:32:14 <ttmrichter> In the process I've learned a lot, been humbled and halved the number of lines of code.
03:32:19 <ttmrichter> Despite now adding a lot more whitespace.
03:36:02 <quicksilver> :)
03:36:08 <quicksilver> this is a familiar experience
03:36:16 <quicksilver> it's probably a good exercise too
03:36:25 <hpaste>  babajega pasted "babajega" at http://hpaste.org/1505
03:37:32 <dons> there we go.
03:37:43 <quicksilver> where do we go?
03:38:11 <dons> to spammer jail.
03:38:56 <quicksilver> ah, good stuff
03:39:13 <quicksilver> do we pass go and collect 200 on the way?
03:39:30 <dons> let's  hope so!
03:41:32 <osfameron> eeeek!  YAML!
03:41:40 <Syzygy-> YA?
03:41:42 <osfameron> I thought that was a perl-only aberration
03:41:43 <Syzygy-> Hrm.
03:41:46 <Syzygy-> YAML?
03:41:58 <osfameron> YAML Ain't a Markup Language
03:42:08 <Syzygy-> Huh?
03:42:18 <osfameron> http://www.yaml.org/
03:42:19 <lambdabot> Title: YAML Ain't Markup Language
03:42:39 <nominolo> readable xml!
03:47:42 <Svrog> http://en.wikipedia.org/wiki/S-expression <-- readable xml and easier to parse than any of the alternatives :)
03:47:43 <lambdabot> Title: S-expression - Wikipedia, the free encyclopedia
03:53:40 <dv>     Couldn't match expected type `Char'
03:53:41 <dv>            against inferred type `GHC.Word.Word8'
03:53:49 <dv> oops
04:07:22 <nominolo> Svrog: requires quoting
04:07:45 <nominolo> Svrog: s-expressions don't solve every problem ;)
04:08:39 <Svrog> never said they did
04:12:28 <Svrog> generally i still prefer s-expressions and variants to the alternatives - i think the postfix, joy-style quotations would probably be even nicer
04:18:03 <scook0> @src comparing
04:18:03 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
04:20:19 <oerjan> @source Data.Ord
04:20:19 <lambdabot> Data.Ord not available
04:25:34 <hpaste>  babau pasted "babau" at http://hpaste.org/1506
04:50:05 <vincenz> Lemmih: location?
04:50:07 <vincenz> ADEpt: location?
04:50:38 <Lemmih> <- here.
04:52:25 <ADEpt> vincenz: running out to catch delivery boy :) b.back in 20 minutes
04:52:37 <vincenz> ADEpt: ukr or russia?
05:09:20 <MarcWeber> Philippa: Hi. Have you been the guy mantaining yi?
05:11:15 <Saizan> MarcWeber: that's jyp, i think
05:11:33 <dons> jyp, Jean-Phillipe.
05:13:35 <vincenz> bernardy
05:16:37 <Wild_Cat> is yi usable (as in, useful) yet for editing code that's not Haskell, by the way?
05:16:50 <vincenz> @seen jethr0
05:16:50 <lambdabot> I saw jethr0 leaving #oasis 4d 15h 25m 11s ago, and .
05:17:51 <dcoutts> Wild_Cat: it's a general purpose text editor, with some optional Haskell code editing bits
05:24:57 <quicksilver> I *really* like that question on the -cafe about read-only functions within state
05:25:07 <quicksilver> because that really shows off the power of types + monads, to me
05:25:13 <quicksilver> the fact that it's so easy to do
05:25:29 <quicksilver> someone should work that up into a nice example and blog it :)
05:27:59 <osfameron> quicksilver: on blog note, I've just blogged my SOE Chapter 9 and namechecked you
05:28:17 <quicksilver> woo! my path to celebrity continues!
05:28:22 <osfameron> :D
05:28:32 * quicksilver confidently expects the invite to the next brangelina knees-up
05:29:16 <dons> we've got a read-only, and read-write partition in xmonad, fwiw.
05:29:26 <dons> newtype X a = X (ReaderT XConf (StateT XState IO) a)
05:29:27 <dons>     deriving (Functor, Monad, MonadIO, MonadState XState, MonadReader XConf)
05:29:38 <dons> for set-at-startup data, and true state.
05:30:28 * quicksilver nods
05:30:33 <quicksilver> that's also cool, but it's not what I meant
05:30:40 <quicksilver> the point is that you can have a R/W state monad
05:30:45 <quicksilver> but you can run R/O functions in them
05:30:49 <dons> ah yes.
05:30:50 <quicksilver> and have that reflected in their type
05:30:52 <dons> lifting ask, iirc?
05:31:05 <quicksilver> or writing a MonadReader instance for your state monad
05:31:20 <dons> yeah. quite nice and flexible
05:31:30 <kpreid> okay, that's peculiar-looking. I've never seen a type parameter in a deriving clause before
05:31:48 <quicksilver> kpreid: 'MonadState' isn't a type class
05:31:49 <dons> kpreid: true. neither had i ... till it worked.
05:31:53 <quicksilver> kpreid: it's a type class family
05:32:02 <kpreid> I know it's a MPTC
05:32:02 <quicksilver> kpreid: it doesn't mean anything until you give it a parameter
05:32:15 <quicksilver> 'deriving MonadState' would be meaningless
05:32:20 <kpreid> I know!!!
05:32:20 <quicksilver> ("what kind of state does it store?")
05:32:46 <dons> itss cool, since you can play tricks and derive MonadState for some different parts of your type...
05:35:08 <dons> at one point we tried: newtype X a = X (ReaderT XConf (StateT XState (UserT IO)) a)
05:35:17 <dons> where UserT was a user-supplied monad transformer.
05:35:28 <dons> so you could script the app with your own monad logic.
05:35:51 <dons> i suspect there's some really cool tricks you could do that way. like add your own wacky error handling, or hmm, ContT.
05:36:13 <quicksilver> intriguing
05:36:25 <quicksilver> USBNuclearMissileT
05:36:37 <dons> yeah, the user just writes type UserT = .... something amazing ...
05:36:46 <dons> and they get to hook their own logic into all the ';'' in xmonad.
05:37:09 <glen_quagmire> :t ;
05:37:12 <lambdabot> parse error on input `;'
05:37:16 <quicksilver> there's more to those ; than meets the eye
05:37:22 <quicksilver> it's all in microdots
05:37:27 <glen_quagmire> ;_;
05:37:33 <dons> (;) :: (Monad m) => m a -> m b -> m b
05:39:40 <dons> night all.
05:39:50 <opqdonut> nite
05:39:51 <glen_quagmire> ightys
05:45:20 <Philippa> MarcWebe1: I'm not, both on count of not maintaining yi and not being a guy
05:45:38 <glen_quagmire> your a girl
05:45:58 <quicksilver> good deduction skills
05:46:02 <quicksilver> although the name is a clue, too
05:47:40 <glen_quagmire> oh. not not being a guy => being a guy
05:48:53 <Wild_Cat> you never know, in these times of cheap surgery and so-called alternative lifestyles...
05:59:12 <MarcWebe1> Philippa: sry.. irc is lacking those nice blue and pink colored name lists ;)
06:05:36 <crazy_code2> hello everyone
06:07:09 <crazy_code2> dons: Is it ok If i private chat with you ?
06:07:23 <dmwit> ?quote
06:07:23 <lambdabot> JaffaCake says: I don't remember a recruitment process where the interviewees all talk to each other before, it's kind of scary :)
06:07:35 <dmwit> ?quote
06:07:35 <lambdabot> state says:  ?. ++ . read . show . state ?. ++ . read . show . state
06:12:14 <crazy_code2> I finally have decided to do bindings for libxml2
06:12:31 <crazy_code2> http://xmlsoft.org/html/index.html
06:12:32 <lambdabot> Title: Reference Manual for libxml2
06:12:54 <crazy_code2> I don't understand what all I should work on
06:13:04 <crazy_code2> There are a lot of things over there
06:13:56 <crazy_code2> Can anyone suggest me what all would be essential for doing an RSS reader using the bindings
06:14:58 <Lemmih> crazy_code2: I have a binding for libxml2. It's not very complete, though.
06:15:24 <crazy_code2> Lemmih: what all did you do ? How difficult is it ?
06:15:45 <Lemmih> crazy_code2: How about using HaXml if you're only interested in RSS?
06:16:23 <Lemmih> crazy_code2: The Haskell FFI is a joy to use.
06:16:51 <crazy_code2> Lemmih: actually, I am goin to do an intership. I have selected to do this. I am going ahead with it
06:16:53 <hkBst> a *> b = do { a ; x <- b ; return x }   a <* b = do { x <- a ; b ; return x }    is this the standard way of defining those?
06:18:10 <glen_quagmire> i wrote my haskell function: factorial n = product [1..n]
06:18:27 <quicksilver> hkBst: a *> b is just a >> b
06:18:41 <opqdonut> is it?
06:18:44 <Lemmih> hkBst: Standard way?
06:18:46 <opqdonut> oh, it is
06:18:46 <quicksilver> hkBst: a <* b doesn't have a standard name, but I agree it is occasionally useful
06:19:24 <quicksilver> hkBst: In particular, at the end of a do expression "x <- b; return x" is quite equivalent to simply "b"
06:20:34 <quicksilver> you can write a <* b as fst `liftM` liftM2 (,) a b, but I wouldn't seriously claim that's an improvment on what you have written :)
06:20:35 <Lemmih> crazy_code2: Extending my binding would probably be a good start.
06:20:55 <crazy_code2> Lemmih: Ok
06:20:58 <quicksilver> :t \a b -> fst `liftM` liftM2 (,) a b
06:21:01 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m a1
06:21:03 <crazy_code2> Lemmih: Can I see your work
06:21:51 <Lemmih> crazy_code2: darcs get http://darcs.haskell.org/~lemmih/haskell-xml/
06:21:53 <lambdabot> Title: Index of /~lemmih/haskell-xml
06:21:58 <crazy_code2> Lemmih: btw, what all should I know before I start doing anything in this direction
06:23:22 <fasta> Is there any way to get around this? Functional dependencies conflict between instance declarations:
06:24:22 <hkBst> quicksilver: okay. So is `a <* b' the most common abbreviation of `do { x <- a ; b ; return x }' or would you use another operator, maybe << ?
06:24:48 <quicksilver> I wouldn't use <<
06:24:50 <Lemmih> crazy_code2: Hm, I don't know. I'm not even sure what it it you're trying to achieve.
06:24:55 <quicksilver> << looks like flip (>>)
06:25:09 <quicksilver> Lemmih: I believe he wants to write a haskell RSS reader?
06:25:37 <quicksilver> hkBst: I think <* is a good name, but I could see argument for *> or |>
06:25:44 <quicksilver> hkBst: I'm not aware of an 'accepted name' for it
06:26:10 <Saizan> ?hoogle (<*)
06:26:11 <lambdabot> Did you mean: (<*)
06:26:11 <lambdabot> Prelude.undefined :: a
06:26:11 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
06:26:14 <malcolmw> in polyparse, it is called `discard`
06:26:22 <malcolmw> a `discard` b
06:26:23 <Lemmih> crazy_code2: You know that there are existing RSS parsers written in Haskell, right?
06:26:30 <crazy_code2> yes
06:26:46 <fasta> Here: http://pastebin.ca/599794
06:26:57 <fasta> Please, have a look.
06:27:38 <hkBst> quicksilver: ok, thank you
06:27:58 <quicksilver> fasta: I don't know how to do that, because 't' will always match anything 'm t' matches
06:28:04 <aperson> Can someone tell me what the $= operator is for?  I've seen it a lot in the HOpenGL examples.
06:28:16 <quicksilver> fasta: I'm not confident to say it's impossible though :)
06:28:26 <quicksilver> aperson: HOpenGL uses $= as an assignement operator
06:28:34 <quicksilver> aperson: it works on various kinds of GL state
06:28:39 <fasta> quicksilver: It seems a pretty severe limitation in the type system if it indeed is impossible.e
06:28:54 <quicksilver> aperson: but they overloaded it so it can also be used on standard IORefs
06:28:56 <quicksilver> aperson: IIRC
06:29:28 <quicksilver> fasta: yes, you sometimes want a way to "give priority" to one instance over another
06:29:40 <quicksilver> fasta: 'use this instance only if one of the more specific ones doesn't match"
06:29:47 <quicksilver> fasta: but I don't know the best way to do that
06:30:15 <SamB_XP> that's dangerous
06:31:51 <hkBst> @src (>>)
06:31:51 <lambdabot> m >> k      = m >>= \_ -> k
06:34:20 <hkBst> how would I combine a parser that skips whitespace with a parser that return some data token, when they don't have the same type?
06:34:49 <dcoutts> hkBst: what are their types ?
06:35:29 <hkBst> dcoutts: GenParser Char st Ign       GenParser Char st L
06:36:06 <fasta> quicksilver: do you know any way not necessarily the best?
06:36:22 <dcoutts> hkBst: remind me, what the third type arg of parsec's GenParser is for ?
06:36:40 <hkBst> dcoutts: I think it is for user-defined state
06:37:15 <hkBst> dcoutts: oh, the third, that's the type it returns
06:37:29 <dcoutts> hkBst: oh ok, then it's easy :-)
06:38:03 <dcoutts> hkBst: skipwhitespace >> gobbletoken
06:38:12 <dcoutts> @type (>>)
06:38:17 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
06:39:13 <quicksilver> fasta: -foverlapping-instances
06:39:16 <quicksilver> fasta: or something :)
06:39:20 <quicksilver> fasta: and get the order right
06:40:01 <dcoutts> hkBst: does that make any sense?
06:41:01 <fasta> quicksilver: I already tried that, are you sure that order in a source file matters?
06:41:47 <hkBst> dcoutts: I was trying to do that, but starting to doubt it was the right way. It is good to know that it should work.
06:46:38 <quicksilver> fasta: No :( it's not something I understand well. I think a post to the -cafe will get you the best answer
06:46:56 <quicksilver> Philippa: are you there?
06:47:17 <Saizan> order of instances matters only in hugs
06:48:54 <fasta> If there was some type classs "NotMonad", it would also be solved, but since there is none, it would only be moving the problem.
06:51:19 <Saizan> heh, negative contexts would be nice
06:51:38 <hkBst> dcoutts: what happens if skipwhitespace fails?
06:51:45 <Saizan> you can remove the fundep and give type annotations when necessary, though
06:51:50 <dcoutts> hkBst: then the whole thing fails
06:52:01 <hkBst> dcoutts: that's no good :(
06:52:05 <dcoutts> hkBst: but I don't think skipwhitespace can fail, can it?
06:52:23 <dcoutts> hkBst: if it gets no whitespace chars, that's not failure
06:52:37 <dcoutts> it succeeded in accepting 0 whitespace chars
06:52:41 <chessguy_> hmm, strange bootage
06:52:53 <dcoutts> hkBst: at least I'd assume that's how it's specified
06:53:07 <hkBst> dcoutts: yes, it can, because if it accepts the empty string then I can't have `many' of the combination...
06:53:08 <dcoutts> hkBst: try it, it's not hard to test parsers on sample inputs in ghci
06:53:30 <Saizan> hkBst: if skipwhitespace can fail you can write (skipwhitespace <|> return ()) >> gobbletoken
06:53:35 <hpaste>  c0pyuk pasted "c0pyuk" at http://hpaste.org/1507
06:53:51 <dcoutts> hkBst: does skipwhitespace skip a single or many whitespace chars ?
06:53:59 <kfish> fasta: you're just playing, right? like, any particular reason the condition has to be in the monad when the expressions are?
06:54:15 <dcoutts> hkBst: if single then you just use 'many' with it, otherwise it has the right behaviour already
06:54:37 <hkBst> dcoutts: I'm having it skip at least one
06:55:20 <Philippa> quicksilver: I'm here now, but only for a couple of minutes
06:55:59 <hkBst> dcoutts: the problem is that if I do that, then `many ( many skiponeWhite )' will cause a warning, of manying something which may parse the empty string...
06:56:15 <fasta> Saizan: cond (return True::[Bool]) (return 1::[Int]) (return 2::[Int])
06:56:34 <fasta> Saizan: that doesn't look to good, does it?
06:56:52 <fasta> kfish: just playing?
06:56:55 <Saizan> fasta: cond (return True::[Bool]) (return 1) (return 2) :: [Int], a little better :)
06:57:11 <fasta> kfish: this would make programs much more readable.
06:57:25 <hpaste>  hkBst pasted "parseL" at http://hpaste.org/1508
06:57:31 <dcoutts> hkBst: why do you need to (many (many ...)) ?
06:57:37 <quicksilver> Philippa: I was wondering if you could explain your comment in the parsers thread
06:57:48 <quicksilver> Philippa: "The big gain with arrows is those situations where higher-order
06:57:49 <quicksilver> computations can't be allowed"
06:58:02 <Philippa> arrows aren't all ArrowApply
06:58:18 <Philippa> sometimes that gains you analytical power, because it means you can do analyses without having to worry about the Halting Problem
06:58:32 <Philippa> right, gotta go
06:59:51 <kfish> fasta, eg "cond c e1 e2 = if c then e1 else e2" works fine for monadic e1, e2, and non-monadic c, if that's all you're after
07:00:29 <fasta> kfish: I am not after "only that".
07:00:45 <fasta> kfish: I expressed quite precisely what I was after
07:00:50 <hkBst> dcoutts: because if I define parsing one expression as `parseL1 = (many skiponeWhite) >> gobbletoken', then parsing many expressions becomes `parseL = many parseL1'
07:00:58 <fasta> kfish: suggesting I need less is inconsistent.
07:02:03 <kfish> fasta, no offense, i'm just asking about the use-case for the monadic boolean
07:03:09 <fasta> kfish: why ask when I clearly specified the "intention"?
07:04:43 <quicksilver> fasta: because people frequently ask questions which are based on implicit assumptions which, in fact, they didn't mean
07:04:46 <quicksilver> fasta: don't be so spiky
07:05:32 <hkBst> dcoutts: does the code I pasted make any sense?
07:08:40 <hpaste>  java522 pasted "java522" at http://hpaste.org/1509
07:09:21 <Cale> fasta: There's one problem. Instances in future modules can change whether a given type constructor is a monad.
07:10:07 <Cale> Hence, which instance of Cond is to be used can't be determined.
07:11:10 <Cale> As always, separate compilation ruins everything :)
07:11:16 <dcoutts> hkBst: one traditional way to deal with whitespace (apart from using a lexer) is to always gobble whitespace *after* a token rather than before, then just gobble whitespace once at the beginning in the top level parser
07:11:47 <Svrog> :q
07:11:51 <Svrog> oops
07:11:55 <Svrog> wrong window
07:12:06 <dcoutts> hkBst: ie parseL = ignore >> many parseL1; parseL1 = ( list <|> symbol ) >> ignore
07:12:12 <fasta> Cale: I don't see how that would be a problem.
07:12:55 <fasta> Cale: If it's a monad then it uses instance A, otherwise instance B, whether the programmer suddently decides something isn't a monad anymore shouldn't matter.
07:13:18 <Cale> No, the programmer can't decide that something isn't a monad anymore
07:13:33 <Cale> But the programmer can decide to make something into a monad later.
07:13:42 <Cale> Typeclasses are always open.
07:13:45 <fasta> Why can't the programmer decide that?
07:14:00 <Cale> Because instances can't be selectively imported.
07:14:16 <Cale> If you import a module, you import all of the instances defined in it.
07:14:27 <Cale> (this is a problem)
07:14:30 <fasta> Cale: If I define a type isomorhpic to Maybe and then write an instance.
07:14:37 <fasta> Cale: then it works.
07:14:46 <fasta> Cale: then I uncomment it and it still works.
07:14:52 <Cale> Suppose you define a type isomorphic to Maybe and *don't* write an instance of Monad for it
07:14:55 <fasta> Cale: I think you mean something else.
07:15:03 <Cale> Let me give a proper example
07:15:28 <hkBst> is it possible to have the parser `show' what has already been returned so far upon complete failure?
07:15:40 <fasta> Cale: does anyone care about that selectively importing instances that writes compilers?
07:15:51 <Cale> class C f where c :: f a -> Bool
07:15:52 <fasta> s/that/who
07:16:13 <Cale> instance Monad m => C m where c x = True
07:16:20 <Cale> instance C m where c x = False
07:17:02 <dukedave> Hey, has anyone worked through type theory & functional programming by Simon Thompson?
07:17:04 <Cale> data Foo a = Blargh | Foo a
07:17:15 <dukedave> I'm having so much difficulty with it >:(
07:17:21 <Cale> bar = c (Foo 5)
07:17:27 <Cale> Suppose we compile that module.
07:17:36 <Cale> Foo is not *yet* a monad
07:17:51 <Cale> but in some module which imports this one, we can turn it into a monad.
07:18:15 <Cale> and then  bar' = c (Foo 5)  will perhaps mean something completely different.
07:18:19 <fasta> So, the semantics of the original programmer change?
07:18:34 <kfish> dukedave, where are you at? and how many pages per day are you doing? ;-)
07:19:03 <dukedave> kfish: Absolutely crawling through it, still haven't even got out of the predicate logic section..
07:19:06 <Cale> Which code is selected can't really be decided based on the absence of an instance, because an instance might always show up later, and you never know.
07:19:10 <hkBst> just `parse error at (line 1, column 41):' is so unhelpful
07:19:26 <Cale> At least, if you want code to behave sanely when transplanted between modules.
07:19:32 <dukedave> I just refuse to move through books without understanding everything & this is just completely nonsensical at times
07:19:57 <fasta> Cale: does this imply that negative contexts are non-sensical to begin with?
07:20:33 <fasta> Cale: Under the condition "At least,... between modules".
07:21:42 <fasta> Cale: when one doesn't export Foo from the module, there is no problem.
07:22:22 <Cale> Basically.
07:22:25 <Cale> Just due to the fact that there's no way to close a class.
07:22:46 <Cale> Yeah, if Foo was unexported, probably not an issue.
07:22:57 <fasta> Cale: and do any of the compiler writers care about this issue?
07:23:25 <fasta> Cale: e.g. will it be addressed in H'?
07:23:30 <Cale> There's been discussion about it, but as far as I know, not so many real proposals about what to do.
07:23:41 <Cale> H' will mostly consist of things which are already in GHC.
07:23:42 <dukedave> Example of something I have difficulty with: "x >0 assumes the existence of an object greater than zero and to name it x", makes sense.. Next: "Suppose that on the basis of this we from some B which does not mention x", well how can it be 'on the basis of' something it doesn't mention? And then to make things worse: "if we also know that the existential assumption is indeed valid", well what does that mean?
07:23:48 <Cale> With some cleaning up and such.
07:23:58 <Cale> Major new unimplemented features probably not.
07:25:20 <fasta> Cale: It seems like it would be a sane idea to don't change what instance to call by outside influences.
07:25:20 <Cale> dukedave: Perhaps some logical rule eliminated x?
07:25:34 <Cale> fasta: That's the status quo.
07:26:47 <Cale> fasta: It's just that things have been devised such that while you can always add new instances, you just can't rely on their absence.
07:26:51 <fasta> Cale: but then negative contexts do make sense.
07:27:21 <Cale> fasta: You can add new instances, but they're for different types than the existing instances
07:27:52 <Cale> dukedave: Can I get a longer passage?
07:27:59 <Cale> dukedave: I can probably explain that.
07:28:09 <fasta> Cale: I would find it a lot more natural to be able to define the "Cond" type class.
07:29:27 <dukedave> Cale: I think I see now, it was just a sentence in passing before the formal definition of existential elim. is given..
07:29:40 <Cale> dukedave: okay
07:31:34 <dukedave> Think I'm going to have to abandon the book though which is a shame because I got in really well with Craft of FP (he wrote both)
07:31:37 <fasta> Cale: Cool, I made this to work: cond (return True) ([1]) (return 2)
07:31:50 <fasta> Cale: look no type annotations.
07:31:53 <Cale> fasta: is that functional dependency really right?
07:32:37 <fasta> Cale: It's not legal, but I think it should be, yes.
07:33:25 <Cale> Well, your first instance says that for any type t which is given for the second parameter, the first parameter is Bool.
07:33:47 <Cale> (Because knowing the second parameter apparently determines the first parameter uniquely)
07:34:09 <Cale> It would be impossible to define another instance after that without violating the functional dependency.
07:34:19 <fasta> Cale: it should be separated on things that are monads and those that are not.
07:34:36 <fasta> Cale: since (m t) is more specific than t, it should pick that one.
07:34:44 <fasta> Cale: of course, that aren't the rules now.
07:34:52 <fasta> Cale: but rules can be changed.
07:35:13 <Saizan> is it possible to build base without building ghc as well?
07:36:12 <Cale> fasta: except that the "more specific" thing doesn't apply at all to the meaning of functional dependencies
07:36:51 <Cale> Basically, you're trying to define a function on domains which overlap, but not defining it the same way on that overlap.
07:37:53 <Cale> If it wasn't invalid to do that, the functional dependency would be meaningless, because that's exactly what it expresses the prevention of.
07:38:33 <Cale> If you could express that something was not an instance of a class, then okay, you could do it.
07:39:01 <fasta> Cale: I think I already got it as good as one could hope for.
07:39:13 <Cale> cond (return False) (return 1) (return 2) is always going to be ambiguous
07:39:19 <fasta> Cale: I know
07:39:26 <fasta> Cale: that's why I put the [1] there.
07:39:32 <fasta> Cale: and then it even works
07:40:40 <Cale> Another option would be to just have the monadic version, but use the identity monad sometimes.
07:41:21 <fasta> That would be programming in *Haskell*, not *programming* in Haskell
07:41:32 <Cale> hm?
07:42:12 <fasta> Cale: that's a quote from the mailing lists that I like.
07:42:28 <fasta> Cale: it's about working around programming language issues vs getting things done
07:42:36 <Cale> I'm not completely sure I see the point of this overloading. Do you run into a lot of conditionals where you don't know whether the condition is monadic or not?
07:43:02 <fasta> Cale: I know whether the condition is monadic or not.
07:43:10 <nowhereman> hi, is it possible to use a where-clause in a list comprehension?
07:43:11 <fasta> Cale: it just _looks_ better
07:43:46 <fasta> Cale: I am currently using condF and condM to express this idea.
07:43:48 <Cale> Abusing the class system for syntax concerns seems a bit silly to me, I guess :)
07:44:03 <quicksilver> Cale: but that's exactly why the class system was invented?
07:44:08 <quicksilver> Cale: (+), (==)
07:44:23 <Cale> quicksilver: There are an unbounded number of cases there, at least.
07:44:28 <fasta> In C one can write:
07:44:48 <Cale> quicksilver: and the need to write functions which are polymorphic over all numeric types
07:44:58 <quicksilver> nowhereman: no, but you can put 'lets' in I think
07:45:01 <Cale> quicksilver: Here, it's known locally which variant is needed
07:45:06 <fasta> if true {} and if true {}{}
07:45:12 <Cale> The polymorphism doesn't need to be exported from the function.
07:45:25 <quicksilver> Cale: true
07:45:37 <fasta> In vanilla Haskell all we have is if then else
07:45:54 <fasta> and when for the specific case the condition is of type Bool
07:47:38 <Cale> Regarding the conditional with one branch, you've seen 'when' right?
07:47:54 <fasta> Cale: I just said that.
07:48:03 <Cale> oh, heh
07:48:14 <Cale> somehow I managed to parse that into your sentence
07:48:26 <Cale> Excuse me, I'm tired :)
07:50:17 <fasta> Cale: yes, it was a parsing challenge. I understand
07:50:32 <fasta> Cale: I should have used "when" or similar
07:51:09 <nowhereman> quicksilver: tnx, that works
08:41:11 <chessguy> @hogle when
08:41:11 <lambdabot> Monad.when :: Monad a => Bool -> a () -> a ()
08:41:11 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
08:42:17 <chessguy> heh. LB has me spoiled. i knew i mis-typed hoogle, and i almost backed up and fixed it, but then went "nah, it'll figure it out"...and it did!
08:47:06 <rretzbach> @typ mapM
08:47:09 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
08:47:13 <rretzbach> nice bot :>
08:47:47 <dylan> @tp forM
08:47:47 <lambdabot> Maybe you meant: . bf ft id map pl rc temp thx type v wn
08:47:57 <dylan> @ty forM
08:48:01 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
08:48:52 <rretzbach> This saves 2 letters every time!
08:49:11 <chessguy> @quote extra
08:49:12 <lambdabot> souwh says: <shapr> hm, I have extra spaces there. \n <souwh> oooh, those can be saved and reused later!
08:49:40 <chessguy> hmmm, bad Euler solution
08:49:41 <chessguy> Find the 10001st prime.
08:49:41 <chessguy> Solution:
08:49:41 <chessguy> problem_7 = head $ drop 10000 primes
08:49:41 <chessguy>   where primes = 2:3:..
08:49:55 <chessguy> > 2:3:..
08:49:55 <lambdabot>  Parse error
08:49:59 <chessguy> tut tut
08:52:04 <chessguy> @pl p = s (t (< 100) pr)
08:52:04 <lambdabot> p = s (t (< 100) pr)
08:55:08 <quicksilver> chessguy: lots of people don't "get" the euler problems
08:55:31 <quicksilver> chessguy: although, admittedly, most of the time if you don't "get" it it doesn't complete in less than a day on your hardware :)
09:07:33 <glen_quagmire> x : xs ++ ys      ===   x : (xs ++ ys)   or (x:xs) ++ ys ?
09:08:06 <sorear> Doesn't actually matter.
09:08:16 <sorear> > ('x' : "ab") ++ "cd"
09:08:19 <lambdabot>  "xabcd"
09:08:25 <sorear> > 'x' : ("ab" ++ "cd")
09:08:27 <lambdabot>  "xabcd"
09:08:49 <glen_quagmire> oh i see
09:08:50 <sorear> However, GHCi's :i command says that it IS the former
09:09:00 <sorear> infixr 5 both
09:09:17 <glen_quagmire> :t infixr
09:09:20 <lambdabot> parse error on input `infixr'
09:09:50 <glen_quagmire> infixr 5 ++    what does this mean?
09:10:07 <Saizan> that ++ is right associative with a precedency of 5
09:10:15 <quicksilver> sorear: interesting, if they're both infixr, it will still left-associate at the boundaries when there is a 'mixture of the two'?
09:10:29 <sorear> quicksilver: no
09:11:09 <quicksilver> sorear: ah, when you said "former" I thought you meant of your two tests with LB
09:11:16 <quicksilver> sorear: not former in glen_quagmire's orginal quesiton :)
09:11:19 <sorear> sorry
09:11:56 <quicksilver> If I was designing a precedence parser I would not actually be sure what to do with this case
09:12:12 <quicksilver> (two operators, equal precedence, four possibilities for fixity exist)
09:13:31 <glen_quagmire> i'm trying to write my own concatenation
09:14:06 <glen_quagmire> how do I terminate a statement so that i can post multiple statements in 1 line in IRC?
09:15:47 <byorgey> glen_quagmire:  you could use semicolons, but you should probably just use hpaste instead.
09:15:51 <byorgey> @paste
09:15:52 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:16:11 <LoganCapaldo> Can you always use ; ?
09:16:45 <byorgey> LoganCapaldo: well, if it only needs to be parsed by humans, probably
09:16:59 <sorear> quicksilver: that's what assocciativity is for
09:17:04 <sorear> quicksilver: infix*r*
09:17:51 <quicksilver> sorear: my understanding is that infix{r,l} is intended to guide the case "foo <*> bar <*> baz"
09:18:01 <sorear> right.
09:18:05 <quicksilver> sorear: it's not clear what you do in the case "foo <*> bar <+> baz"
09:18:10 * LoganCapaldo is wondering if top level decls can be seperated by ;.
09:18:11 <glen_quagmire> > a = 1; a
09:18:11 <lambdabot>  Parse error
09:18:19 <LoganCapaldo> it's easy enough to tes tof course
09:18:26 <quicksilver> *,+ could have four pairwise combinations of right/leftedness
09:18:44 <sorear> quicksilver: if <+> is higher prececence, it gets first; if lower, it gets last; if equal, associativity decides.
09:19:01 <quicksilver> what if + is left and * is right?
09:19:05 <fasta> sorear: could you elaborate on your comment here? : http://augustss.blogspot.com/2007/06/massive-overload-in-my-last-post-i-had.html
09:19:07 <lambdabot> Title: Things that amuse me, http://tinyurl.com/35o73x
09:19:13 <quicksilver> what if + is righ tand * is left?
09:19:15 <quicksilver> :)
09:19:24 <sorear> quicksilver: watch
09:19:29 <sorear> > 2 `fmap` 3 . 4
09:19:37 <lambdabot>      precedence parsing error
09:19:37 <lambdabot>         cannot mix `fmap' [infixl 9] and `(.)' ...
09:19:59 <opqdonut> infixl and infixr of same prec?
09:20:16 <opqdonut> yup
09:20:30 <quicksilver> sorear: ah, right
09:20:35 <glen_quagmire> a xs [] = xs;  a xs (y:ys) = (a xs y) : ys
09:20:37 <quicksilver> sorear: ok, that's a good way to settle it :)
09:20:47 <glen_quagmire> i can't do that coz it is infinite
09:20:49 <quicksilver> sorear: so a : c ++ b is only valid because they are both right
09:20:54 <quicksilver> sorear: makes sense now
09:20:59 <sorear> right! :)
09:21:21 <byorgey> glen_quagmire: you probably want to recurse on the left argument rather than the right.
09:21:26 <glen_quagmire> b [] ys = ys;   b (x:xs) ys = x : (b xs ys) is ok
09:21:34 <byorgey> glen_quagmire: exactly.
09:22:33 <byorgey> glen_quagmire: having (a xs y) in your first example means that y has to have the same type as ys, which is impossible since y is an element of ys.
09:22:35 <chessguy> quicksilver, i don't "get" your point about the euler problems
09:22:35 <fasta> @pl f a = g (r l) (z x) a
09:22:36 <lambdabot> f = g (r l) (z x)
09:22:53 <fasta> @pl f a = g (r l) (z x) (p a)
09:22:53 <lambdabot> f = g (r l) (z x) . p
09:23:10 <glen_quagmire> byorgey: oh [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]
09:23:25 <chessguy> that person clearly understood the problem, but was too lazy to plug in an actual definition of primes
09:23:44 <byorgey> glen_quagmire: right.  it would require an "infinitely nested list" type
09:24:14 <LoganCapaldo> @type let a = [[[]]] in (a, head a)
09:24:17 <lambdabot> forall a a1. ([[[a]]], [[a1]])
09:24:32 <hkBst> how would I fixup      line = ( many $ noneOf "\n" ) *> ( char '\n' <|> eof )       and does Parsec have a primitive for this? NB    a *> b = do { x <- a ; b ; return x } )
09:25:13 <LoganCapaldo> @hoogle followedBy
09:25:13 <lambdabot> Text.ParserCombinators.Parsec.Combinator.notFollowedBy :: Show tok => GenParser tok st tok -> GenParser tok st ()
09:25:38 <LoganCapaldo> hmmph
09:26:10 <Saizan> hkBst: fixup?
09:26:46 <quicksilver> chessguy: my point is that, most of the euler problems are written so that the 'naive' solution is too slow
09:26:58 <byorgey> Saizan: I assume hkBst means "make more elegant"?
09:27:02 <quicksilver> chessguy: and you have to do some mathematical thinking to think of a good algorithm which works in reasonable time
09:27:10 <hkBst> Saizan:  ( char '\n' <|> eof )  isn't type cogruent
09:27:14 <quicksilver> chessguy: but, quite often you see naive algorithms as people didn't understand this point
09:27:22 <Saizan> ?type eof
09:27:25 <lambdabot> Not in scope: `eof'
09:27:31 <Saizan> ?hoogle eof
09:27:31 <lambdabot> Text.ParserCombinators.Parsec.Combinator.eof :: Show tok => GenParser tok st ()
09:27:32 <lambdabot> Text.Read.EOF :: Lexeme
09:27:32 <lambdabot> System.IO.Error.eofErrorType :: IOErrorType
09:27:36 <mauke> whatever :: (Monad m) => m (); whatever = return ()
09:27:38 <fasta> quicksilver: if the naive solution works, the problem is not well specified.
09:27:42 <mauke> (char '\n' >> whatever <|> eof)
09:28:02 <chessguy> oh, so your point was about the algorithm. my point was about the actual code
09:29:20 <Saizan> can you find the 10001 prime without the first 10000?
09:29:27 <glen_quagmire> lrep 0 a = []; lrep n a = a : lrep (n-1) a;  i'm not sure how it works without parens like :  lrep n a = a :(lrep (n-1) a)
09:30:02 <sorear> Saizan: Not sure, but you can get an asymptotically close approximation of it
09:30:04 <rretzbach> Saizan: Maybe, probably not.
09:30:10 <sorear> @google Prime number theorem
09:30:13 <lambdabot> http://en.wikipedia.org/wiki/Prime_number_theorem
09:30:13 <lambdabot> Title: Prime number theorem - Wikipedia, the free encyclopedia
09:31:29 <sorear> @users
09:31:30 <lambdabot> Maximum users seen in #haskell: 354, currently: 317 (89.5%), active: 18 (5.7%)
09:31:32 <LoganCapaldo> glen_quagmire: function application has the highest precedence other than ()
09:33:00 <rretzbach> Is MonadPlus a built-in? Can I use lambdabot to know what I have to import?
09:33:01 <LoganCapaldo> so y <op> f x1 x2 ... xN is always parsed as y <op> (f x1 x2 ... xN) regardless of op
09:33:10 <LoganCapaldo> @index MonadPlus
09:33:11 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
09:33:15 <glen_quagmire> oh (:) is not a function
09:33:24 <LoganCapaldo> (:) is a function
09:33:29 <chessguy> @type (:)
09:33:32 <lambdabot> forall a. a -> [a] -> [a]
09:33:43 <glen_quagmire> :t `:`
09:33:46 <lambdabot> parse error on input ``'
09:33:47 <opqdonut> well, it's a constructor :)
09:33:48 <rretzbach> Thanks logan.
09:33:54 <quicksilver> opqdonut: and a function
09:33:57 <chessguy> data constructors are functions
09:34:04 <opqdonut> of course
09:34:11 <quicksilver> data constructors give rise to functions of the same name, to be pedantic
09:34:14 <Saizan> for precedence purpouses it's an operator!
09:34:20 <LoganCapaldo> but syntactically in the expression a : as it's an operator
09:34:50 <sieni> Saizan: what do you mean by that? for example it is easy to know how many prime numbers there are below n, since you don't have to compute the number of prime numbers below n, because you can compute the number of composite numbers below n
09:36:53 <opqdonut> well, counting the composite numbers is essentially the same problem
09:37:09 <opqdonut> oh well, composite numbers under n === prime numbers under sqrt n
09:39:34 <glen_quagmire> hah i wrote my own zip function : lzip (a:[]) (b:bs) = [(a, b)]; lzip (a:as) (b:[]) = [(a, b)];   lzip (a:as) (b:bs) = (a,b) : lzip as bs ;   I don't like 2 base cases that return same thing
09:39:54 <mauke> glen_quagmire: fails for lzip [] []
09:40:10 <glen_quagmire> w00t
09:40:15 <chessguy> @src zip
09:40:16 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
09:40:16 <lambdabot> zip _      _      = []
09:40:17 <sorear> glen_quagmire: just use zip
09:40:37 * glen_quagmire adds lzip [] [] = []
09:40:46 <chessguy> zip is way cleaner
09:40:54 <mauke> glen_quagmire: fails for lzip [] [1]
09:41:17 <tuukkah> mauke aka quickcheck =)
09:41:18 <glen_quagmire> crap
09:41:28 <glen_quagmire> i'm just practicing
09:41:35 <glen_quagmire> i will use zip
09:41:46 <mauke> if you want to do the base cases first, lzip [] _ = []; lzip _ [] = []
09:41:48 <glen_quagmire> how do I get @src from ghci ?
09:42:00 <chessguy> tuukkah, he didn't mention how many cases he tried before finding a failure :0
09:42:06 <chessguy> glen_quagmire, you don't
09:42:07 <fasta> glen_quagmire: you program the command yourself, I guess
09:42:15 <glen_quagmire> :t (_)
09:42:15 <fasta> chessguy: not entirely trye
09:42:18 <fasta> true*
09:42:21 <lambdabot> Pattern syntax in expression context: _
09:42:26 * mehrheit wonders why haskell-mode for emacs indents 'then' after 'if ...\n' to the same level as 'if'
09:42:32 <fasta> One could rip of the code from lambdabot
09:42:48 <chessguy> uh
09:42:48 <fasta> and combine it with ghci with a locally installed source tree
09:43:03 <chessguy> then it's not ghc any more
09:43:13 <chessguy> it's a hacked version of ghc
09:43:17 <Vulpyne> mehrheit: You have to put the then/else at the end of the line or it fights you. :(
09:43:24 <chessguy> chomp!
09:43:26 <glen_quagmire> _ this anything
09:43:56 <sorear> mehrheit: or you could use emu's hacked version of haskell-mode which does indentation right
09:44:15 <opqdonut> sorear: what are the differences?
09:44:25 <sorear> opqdonut: I forgot.  I don't use emacs anymore
09:44:44 <fasta> sorear: What do you use now?
09:44:48 <sorear> vim
09:45:04 <fasta> sorear: only for Haskell or for everything?
09:45:16 <sorear> everything...
09:45:24 <mehrheit> @google emu's hacked version of haskell-mode
09:45:28 <lambdabot> http://calypso.tux.org/pipermail/xemacs-beta/2007-February/010703.html
09:45:28 <lambdabot> Title: FW: [Bug: 21.5-b27] configure errors on Solaris
09:45:28 <opqdonut> :D
09:45:38 <quicksilver> glen_quagmire: there is actually a way to intall lambdabot on ghci
09:45:44 <chessguy> @google emu haskell mode emacs
09:45:46 <mauke> @where goa
09:45:47 <lambdabot> http://sequence.complete.org/hwn/20070305
09:45:47 <lambdabot> Title: Haskell Weekly News: March 05, 2007 | The Haskell Sequence
09:45:47 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
09:45:50 <quicksilver> it's called 'GoA' aka 'ghci on Acid'
09:45:57 <quicksilver> I'm not sure how easy it is, though
09:46:14 <Vulpyne> I got it working.
09:46:18 <Vulpyne> But it was a pain.
09:46:28 <Vulpyne> Most of the pain came from getting lambdabot itself working.
09:46:31 <chessguy> Vulpyne, what version of LB/GHC?
09:46:52 <glen_quagmire> no setup.exe
09:46:54 <sorear> mehrheit: he's called mrd everywhere else
09:47:26 <chessguy> @google mrd haskell mode emacs
09:47:29 <lambdabot> http://haskell.org/haskellwiki/Haskell_mode_for_Emacs
09:47:29 <lambdabot> Title: Haskell mode for Emacs - HaskellWiki
09:47:29 <Vulpyne> chessguy: 6.6 ghc, and it was about a week ago so whateverLB version was current then. :)
09:47:44 <glen_quagmire> GoA is short except fcgi part
09:48:02 <sorear> quicksilver: I do not encourage people to try to build lambdabot.  It's almost too painful even for the devs.
09:48:36 <quicksilver> sorear: fair enough :)
09:48:52 <glen_quagmire> lambdabot builds itself
09:49:04 <matthew-_> surely it must be self aware by now
09:49:09 <matthew-_> it's had long enough
09:49:13 <matthew-_> and plenty of input
09:49:24 <matthew-_> and lightening strikes
09:49:48 <sorear> glen_quagmire: If you use the :i command, GHCI will tell you the module of definition of a function.
09:50:09 <glen_quagmire> yeup
09:50:23 <chessguy> that's closer to hoogle than @src
09:50:27 <glen_quagmire> then do I load the module?
09:50:27 <quicksilver> and all the source is available at http://haskell.org/ghc/docs/latest/html/libraries/
09:50:34 <quicksilver> which you should visit often :)
09:50:51 * chessguy has that on his bookmark toolbar for one-click access
09:51:04 <quicksilver> bookmarks, schmookmarks
09:51:12 <quicksilver> I just type 'ha' and firefox knows the rest of the URL :)
09:51:25 <chessguy> too many key-presses :)
09:51:29 <glen_quagmire> hrm i don't have source code of ghc installed
09:51:30 <matthew-_> quicksilver: yes - I have that on "haskell".
09:51:46 <quicksilver> glen_quagmire: you don't need it
09:51:52 <quicksilver> glen_quagmire: it's all available on that URL
09:51:56 <glen_quagmire> oh i see
09:52:04 <quicksilver> glen_quagmire: (unless you often program without an internet connection)
09:52:33 <matthew-_> quicksilver: it's interesting how people shorten it - on one machine I have google as "g" - but I've not yet shortened "haskell": are the extra key presses more or less annoying than dealing with firefox's bookmark system?
09:53:08 <quicksilver> matthew-_: I'm not talking about any kind of shorterning that's explicity
09:53:27 <hpaste>  eDs Babu pasted "eDs Babu" at http://hpaste.org/1510
09:53:53 <quicksilver> matthew-_: I'm just referrin to the way that firefox autocompletes URLs as you type
09:54:02 <quicksilver> matthew-_: (based on the ones you visit most often)
09:54:14 <quicksilver> matthew-_: for me, 'ha' is enough for the autocompleter to get the libraries home page
09:54:35 <fasta> @pl f a = zip a a
09:54:35 <lambdabot> f = join zip
09:54:45 <fasta> @pl f a = g a a
09:54:45 <lambdabot> f = join g
09:55:09 <matthew-_> quicksilver: oh sorry - I thought you were meaning the keywords stuff in the bookmarks configs
09:57:08 <mdmkolbe|work> @djinn a -> MyType
09:57:08 <lambdabot> -- f cannot be realized.
09:57:23 <mdmkolbe|work> @djinn a -> Int
09:57:23 <lambdabot> -- f cannot be realized.
09:58:18 <Toxaris> is lb actually proving that a -> Int has an empty extension (wich should not be too hard, for this case)?
10:00:22 <mdmkolbe|work> @type (flip seq 1)
10:00:26 <lambdabot> forall a b. (Num b) => a -> b
10:00:33 <mdmkolbe|work> @type (flip seq (1::Int))
10:00:36 <lambdabot> forall a. a -> Int
10:00:49 <sorear> Toxaris: As opposed to?
10:01:11 <sorear> Toxaris: Djinn always produces either a term or a proof of nonexistance.
10:01:15 <Toxaris> sorear: failing to instanciate it
10:01:33 <sorear> Toxaris: The inhabitation problem for the simply typed lambda calculus is decidable.
10:02:15 <sorear> Toxaris: Also, Djinn doesn't know about many types.
10:02:21 <sorear> @djinn a -> a
10:02:22 <lambdabot> f a = a
10:02:27 <sorear> @djinn Int -> Int
10:02:27 <lambdabot> f a = a
10:02:33 <sorear> @djinn Int
10:02:33 <lambdabot> -- f cannot be realized.
10:02:37 <sorear> @djinn-env
10:02:37 <lambdabot> data () = ()
10:02:37 <lambdabot> data Either a b = Left a | Right b
10:02:37 <lambdabot> data Maybe a = Nothing | Just a
10:02:37 <lambdabot> data Bool = False | True
10:02:37 <lambdabot> data Void
10:02:39 <lambdabot> type Not x = x -> Void
10:02:41 <lambdabot> class Eq a where (==) :: a -> a -> Bool
10:02:43 <lambdabot> data Endo a = Endo (a -> a)
10:03:01 <sorear> @djinn a -> Bool
10:03:01 <lambdabot> f _ = False
10:03:02 <mdmkolbe|work> @djinn a -> Bool
10:03:02 <lambdabot> f _ = False
10:03:19 <sorear> @djinn Void -> Int
10:03:19 <lambdabot> f = void
10:03:19 <mauke> @djinn (Eq a) => a -> a -> Bool
10:03:20 <lambdabot> f = (==)
10:03:35 <byorgey> @djinn x -> Not x
10:03:35 <lambdabot> -- f cannot be realized.
10:03:47 <sorear> @djinn x -> Not (Not x)
10:03:47 <lambdabot> f a b = b a
10:04:41 <mdmkolbe|work> [work duplication check] Has anyone already performed an exhaustive search of the possible monad schema's?  (e.g. state, list, etc.)
10:04:44 <mrd> hmm, they can expire old nicks
10:05:09 <mrd> anyhow, i have modified hskell-mode indentation but my copy's a mess so who knows what else it will do to you :P
10:06:23 <mdmkolbe|work> I thought LB had it's insults turned off
10:06:26 <mdmkolbe|work> @src seq
10:06:26 <lambdabot> Source not found. My mind is going. I can feel it.
10:06:39 <mdmkolbe|work> s/it's/its/
10:06:58 <SamB> @vixen hi
10:06:58 <lambdabot> <undefined>
10:07:12 <SamB> mdmkolbe|work: why did  you think that?
10:08:25 <mdmkolbe|work> SamB: well, it handn't insulted me in a while *sheepish grin*
10:09:10 <mauke> @quote
10:09:10 <lambdabot> stepcut says: I wrote 1 + 1 in php once, and got 11 -- wasn't quite what I was hoping for
10:09:35 <mrd> 1 + 1 = 10
10:11:02 <mauke> is the haskell printf extensible?
10:11:34 <mdmkolbe|work> @type printf
10:11:38 <lambdabot> forall r. (PrintfType r) => String -> r
10:11:45 <mdmkolbe|work> @src PrintfType
10:11:45 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
10:11:56 <mdmkolbe|work> @doc PrintfType
10:11:56 <lambdabot> PrintfType not available
10:12:00 <mdmkolbe|work> @index PrintfType
10:12:01 <lambdabot> Text.Printf
10:12:06 <mdmkolbe|work> @doc Text.Printf
10:12:06 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Printf.html
10:12:56 <Toxaris> sorear: cool. so "void" corresponds to ex falso quodlibet? Why is Eq and Endo included?
10:12:58 <mauke> @source Text.Printf
10:12:59 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
10:13:14 <mrd> what Haskell needs is Text.Format =)
10:13:35 <sorear> Toxaris: just random added stuff I think.
10:13:39 <mdmkolbe|work> "The PrintfType ... .  Its implementation is intentionally not visible from  this module."  So the answer is probably no
10:13:57 <hpaste>  ooragan pasted "ooragan" at http://hpaste.org/1511
10:14:04 <sorear> Toxaris: augustss knows for more about the impl than I
10:15:01 <mdmkolbe|work> whoah, that paste was deleted fast
10:15:32 <sorear> :)
10:15:33 * mdmkolbe|work wonders if Endo is short of endomorphism
10:15:38 <sorear> it is.
10:16:30 <Toxaris> it's needed to have some nice Monoid instances or something like this, i think
10:16:43 <mdmkolbe|work> @djinn a -> Endo a
10:16:43 <lambdabot> f _ = Endo (\ a -> a)
10:17:32 <Saizan> @djinn Endo a -> Endo a -> Endo a
10:17:32 <lambdabot> f a b =
10:17:32 <lambdabot>     case a of
10:17:32 <lambdabot>     Endo _ -> case b of
10:17:32 <lambdabot>               Endo c -> Endo c
10:18:28 <mdmkolbe|work> @djinn a -> a -> a
10:18:28 <lambdabot> f _ a = a
10:18:35 <vincenz> dons: you calleD?
10:19:01 <mauke> @djinn (a -> a -> a) -> a -> a -> a
10:19:01 <lambdabot> f a = a
10:19:02 <mdmkolbe|work> @djinn Maybe a -> Maybe a -> Maybe a
10:19:02 <lambdabot> f a b =
10:19:02 <lambdabot>     case a of
10:19:02 <lambdabot>     Nothing -> b
10:19:02 <lambdabot>     Just c -> Just c
10:19:24 <mauke> @djinn (a -> b -> a) -> b -> a -> a
10:19:24 <lambdabot> f a b c = a c b
10:20:33 <vincenz> @localtime dons
10:20:34 <lambdabot> Local time for dons is Tue Jul  3 03:19:07 2007
10:23:00 <Toxaris> complicated result if f _ _ = Nothing would be enough
10:23:23 <Toxaris> @djinn Maybe Void
10:23:24 <lambdabot> f = Nothing
10:24:34 <Toxaris> @djinn Maybe Int -> Maybe Void
10:24:35 <lambdabot> f _ = Nothing
10:24:38 <SamB> man, JHC takes forever to read its .hl files...
10:24:45 <mauke> @djinn Bool -> a -> a -> a
10:24:45 <lambdabot> f a b c =
10:24:45 <lambdabot>     case a of
10:24:45 <lambdabot>     False -> c
10:24:45 <lambdabot>     True -> b
10:25:54 <mdmkolbe|work> @djinn Maybe Void -> Void
10:25:54 <lambdabot> -- f cannot be realized.
10:26:09 <mdmkolbe|work> @djinn Maybe Void -> Bool
10:26:09 <lambdabot> f a =
10:26:09 <lambdabot>     case a of
10:26:09 <lambdabot>     Nothing -> False
10:26:09 <lambdabot>     Just b -> void b
10:26:31 <mdmkolbe|work> @type void
10:26:33 <lambdabot> Not in scope: `void'
10:26:50 <mdmkolbe|work> @djinn Void -> Int
10:26:50 <lambdabot> f = void
10:27:03 <sorear> SamB: forall a. JHC takes forever to a
10:27:39 <Saizan> Toxaris: it tries to give an useful proof
10:27:49 <SamB> sorear: I found a counterexample
10:28:01 <SamB> it doesn't take forever to complain about missing .hl files...
10:29:03 <Toxaris> Saizan: useful in what sense? Useful as a proof of some theorem, or useful as a function of some type
10:30:22 <mauke> same thing :-)
10:31:09 <sorear> @where djinn
10:31:09 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
10:31:43 <Saizan> Toxaris: i meant as a function
10:31:59 <SamB> sorear: I don't suppose you understand E's Pi nodes?
10:32:09 <mdmkolbe|work> Toxaris: is '' beta or German double 's'?
10:32:15 <sorear> SamB: Actually I do.
10:32:26 <sorear> SamB: they are pi-abstractions
10:32:46 <sorear> SamB: a -> b  is  |~| _ : a -> b
10:32:54 <sorear> SamB: in general, you can bind a variable ther
10:33:02 <mauke> U+03B2 (0xce 0xb2): GREEK SMALL LETTER BETA []; U+00DF (0xc3 0x9f): LATIN SMALL LETTER SHARP S []
10:33:07 <Toxaris> mdmkolbe|work: it's an german double 's', but should have been a question mark, wich is located on the same key on my german keyboard
10:33:08 <sorear> SamB: E has dependant types, so you need the full generality of pi
10:33:25 <Toxaris> so it's the absence of the shift modifier
10:33:28 <SamB> sorear: oh, is it like /\ in F_C?
10:33:56 <sorear> SamB: No, it's like \/ and -> generalized and rolled into one.
10:34:07 <sorear> SamB: /\ in FC corresponds to plain lambda in E
10:34:12 <SamB> oh
10:34:25 <SamB> right, that is in code, not types...
10:34:52 <sorear> Types and values are on equal footing
10:35:00 <SamB> hooray
10:35:15 <SamB> I've gotten the error I was hoping for from JHC ;-)
10:35:48 <SamB> not some big scary one
10:37:02 * SamB is trying to implement foreign import "dynamic"
10:37:56 * sorear tries to read the lwb.p file in Djinn's source
10:43:35 <Toxaris> I'll go for now, it's dinner time over here, will think about intuitionistic theorem proving later...
10:43:51 <dcoutts> @tell ndm you'll be glad to know that gedit/gtksourceview does actually follow the sensible block tab/indent behaviour (must have changed in a recentish version)
10:43:51 <lambdabot> Consider it noted.
10:44:34 <SamB> sorear: I almost had to make a new primitive to do this ;-)
10:45:36 <SamB> but I managed to find a poor, abandoned one I could use instead
10:46:26 * SamB wonders how JohnMeacham plans to cut down on .hl load times
10:46:43 <mauke> Text/Printf.hs--  # mixed tabs/spaces
10:46:46 * SamB wonders if he's going to use something like deferbinary or whatever it's called
11:04:27 <sorear> SamB: I hope he does *something*
11:04:40 <sorear> SamB: I gave jhc four hours to load base-1.0.hl
11:04:41 <JohnMeacham> SamB: yeah. it is my current branch.
11:04:42 <lambdabot> JohnMeacham: You have 1 new message. '/msg lambdabot @messages' to read it.
11:04:47 <sorear> (it didn't succeed)
11:04:57 <JohnMeacham> sorear: !! It should take about a minute.
11:05:19 <sorear> JohnMeacham: It uses 200% of my memory, which slows things down significantly.
11:05:37 <SamB> sorear: well, my machine is apparantly very nice
11:05:46 <SamB> JohnMeacham: branch?
11:06:13 <JohnMeacham> sorear: if it takes that long, it probably means you are using a mismatched version of the hl file with the binary. the problem is if Data.Binary gets off even a little, then it ends up reading junk as a list length and spends eternity trying to read in a half billion entries.
11:06:22 * SamB tries to figure out the syntax to cast to a C function pointer type
11:06:40 <vincenz> sorear: that does put a hair in the ointment
11:06:41 <JohnMeacham> SamB: internal. my current project.
11:07:09 <SamB> JohnMeacham: that isn't likely to conflict with the changes I'm making I guess ;-)
11:07:19 <sorear> JohnMeacham: Won
11:07:26 <sorear> 't binary just reach EOF?
11:07:49 <SamB> oh, what is the point of the first field in the Func constructor from C.Prims?
11:08:00 <sorear> oh wait, no, memory error, it was type checking the prelude that takes forever.
11:08:15 <SamB> sorear: ... why are you compiling Prelude?
11:08:28 <SamB> you should do make fetch-libs
11:08:36 <sorear> SamB: Because the hl files don't have trustworthy version stamps
11:09:14 <sorear> and finding out how much to unpull is so very fun
11:09:29 <SamB> point
11:09:39 <SamB> but I seem to be doing okay atm
11:09:58 <JohnMeacham> SamB: what changes are you working on?
11:10:36 <JohnMeacham> sorear: : eventually, sometimes, the failure mode changes.
11:11:08 <SamB> JohnMeacham: I'm implementing foreign import "dynamic"
11:11:18 <sorear> JohnMeacham: re what?
11:12:07 <JohnMeacham> SamB: ah, cool. the first field is whether it has a world argument that needs to be discarded on conversion to Grin.
11:12:18 <SamB> JohnMeacham: ah.
11:12:30 <SamB> anyway, I added one to IFunc as well
11:12:35 <JohnMeacham> So, just whether the return is IO something (or a newtype thereof).
11:12:58 <JohnMeacham> ah, okay. cool.
11:13:46 <JohnMeacham> the primitive situation got a lot nicer since I rewrote everything in terms of c-- primitives. especially numerics.
11:14:20 * sorear tries jhc again
11:14:25 <SamB> yeah
11:14:51 <SamB> I was thinking the other day that GHC should unify Char# and Word# in Core
11:14:57 <SamB> er.
11:15:02 <SamB> Int# and Word#
11:15:05 * SamB is distracted
11:15:14 <sorear> JohnMeacham: Are there any plans to make jhc build with 6.7?
11:15:27 <sorear> JohnMeacham: my `which ghc` doesn't have FiniteMaps
11:17:36 <JohnMeacham> sorear: I usually stick with the most recent released ghc, jhc is hard enough to build as is without requiring a development ghc :)
11:17:47 <JohnMeacham> sorear: hmm.. I thought I got rid of all uses of finitemaps... perhaps not.
11:18:20 <sorear> JohnMeacham: Oh, I just think it should be *possible* to build it with 6.7
11:18:32 <sorear> ah, FunctorM not FiniteMap
11:19:18 <JohnMeacham> oh yeah. that applicative stuff. that needs some work in the base libraries... there are some flaws that need to be addressed.
11:19:41 <JohnMeacham> not that that is the reason jhc doesn't use it. but it is the reason frisby can't easily.
11:20:36 <sorear> why can't you use it?
11:21:01 <SamB> heh
11:21:17 * sorear notes having never seen a complaint about applicative on libraries@ or trac
11:21:34 <SamB> JohnMeacham: make your grievences known
11:23:28 <JohnMeacham> SamB: is the libraries list appropriate for it? mainly, the 'many' and 'optional' included are only valid for monadic applicative instances, which sort of defeats the purpose and makes them unusable. and a lot more things need to be included in the class because the self-optimizing nature of frisby needs more info than opaque function applications.
11:23:46 <SamB> JohnMeacham: if you don't like libraries, you complain to libraries@
11:24:12 <dolio> @src Control.Applicative.many
11:24:12 <lambdabot> Source not found. Just what do you think you're doing Dave?
11:24:13 <SamB> as long as they're part of the pseudo-official library
11:24:45 <SamB> (this is a sufficient, not a necessary, condition)
11:24:48 <JohnMeacham> also 'some'
11:25:20 <sorear> I don't like maintaining local Makefile mods
11:25:34 <SamB> if frisby is so picky, maybe it needs its own typeclass...
11:26:03 <SamB> or maybe you could use RULES?
11:26:40 <sorear>     Warning: Defined but not used: data constructor `LazyWHNF'
11:26:51 <sorear> Somehow that warning just seems... appropriate
11:26:52 <sorear> :)
11:27:46 <dolio> Is Alternative just MonadPlus is disguise?
11:28:13 <sorear> naw, it's strictly less powerful
11:28:39 <fasta> How do I print a UTF-8 value with a program compiled with GHC?
11:28:58 <sorear> fasta: man 7 utf8
11:29:20 <JohnMeacham> SamB: not at all, frisby is a self-optimizing parser, which is exactly the motivating example of applicative.
11:29:42 <JohnMeacham> SamB: pretty much anything that is applicative but not a monad will have the same issues.
11:29:48 <fasta> sorear: so there isn't a showUtf8String function anywhere?
11:30:09 <sorear> fasta: Not in the standard libraries.
11:30:20 <sorear> @google darcs UTF8.lhs
11:30:22 <lambdabot> http://lists.osuosl.org/pipermail/darcs-users/2004-February/001180.html
11:30:22 <lambdabot> Title: [darcs-users] PATCH: add DarcsURL.lhs to GNUMakefile
11:30:24 <shapr> Good morning #haskell!
11:30:33 <sorear> Good morning shapr!
11:30:39 <Lemmih> fasta: You can steal UTF8.hs from jhc.
11:30:51 <fasta> And how does one print "raw bytes"?
11:30:53 <shapr> Has c2hs changed recently to disallow minus chars in lots of places?
11:31:05 <sorear> fasta: Data.ByteString
11:31:12 <fasta> Lemmih: what license does it have?
11:31:23 <fasta> I am trying to fix an annoyance in darcs.
11:31:34 <sorear> fasta: just use the darcs UTF8.lhs!
11:31:39 <sorear> +then
11:31:51 <fasta> Heh, I was assuming they didn
11:31:55 <fasta> 't have one
11:33:13 <SamB> JohnMeacham: oh, well, then by all means complain as loudly as possible
11:33:45 <shapr> hiya sorear!
11:33:57 <CosmicRay> hey shapr
11:34:05 <shapr> hiya CosmicRay! How's code?
11:34:14 <CosmicRay> flowing slowly, alas.  you?
11:34:26 <shapr> I'm in the code rapids.. many rocks, but much flow.
11:34:39 <CosmicRay> heh, nice analogy
11:35:03 <shapr> There's something wrong with our EC2 interface, and we can't figure out what exactly :-(
11:35:54 <CosmicRay> ec2?
11:36:04 <shapr> Amazon's Elastic Compute Cloud
11:36:10 <CosmicRay> ah
11:36:20 * sorear wonders why jhc has so many incomplete patterns
11:36:49 <shapr> CosmicRay: I'm looking forward to RWH chapters!
11:37:40 <bos> shapr: are you planning to release the new multi-master stuff as open source? alex seemed a bit on the fence over the idea, last i talked to him.
11:38:24 <shapr> bos: Alex plans, we implement :-)
11:38:34 <bos> heh
11:38:35 <sorear> this in happs?
11:38:38 <bos> yeah.
11:38:48 <fasta> Secret internal talk should be secret.
11:39:05 <fasta> Or is this a commercial? ;)
11:39:08 <shapr> fasta: If we ever have any secret internal talk, I would not even admit that such a thing existed!
11:39:41 <bos> i wouldn't blab secrets about on irc. that kind of stuff is for twitter.
11:39:46 <shapr> exactly!
11:42:03 <dylan> hmm, I can't install haxml on gentoo, using the overlap. ghc-6.6 blocks dev-haskell/haxml
11:42:28 <dylan> overlay, rather, not overlap. heh
11:42:29 <crazy_code2> dylan: me too having some problems on FC6
11:42:44 <crazy_code2> get an error when I try to build it
11:42:45 <dylan> ... I highly doubt it's the same problem.
11:42:48 <crazy_code2> :(
11:44:01 <dylan> ah, there we go.
11:44:08 <fasta> 99.2  1.1   5:15.15 darcs
11:44:14 <dylan> have to unmask haxml-1.17
11:44:19 <fasta> How am I not surprised
11:47:14 <CosmicRay> shapr: did ya see the blog post?
11:47:15 <bos> crazy_code2: what goes wrong for you? i've had no problems building haxml on fedora.
11:47:32 <int-e> fasta: what are you doing?
11:47:43 <crazy_code2> bos: I get some kind of error, after I run make
11:47:46 <fasta> int-e: I only updated darcs
11:48:06 <crazy_code2> bos: Is there any parameter to be specified in ./configure ?
11:48:06 <fasta> int-e: but now I am trying to find the "main" function of darcs
11:48:30 <fasta> int-e: which doesn't want to be found by rgrep -i main *
11:48:59 <bos> crazy_code2: you should be building it using runghc Setup
11:49:40 <sorear> runghc Setup configure
11:49:43 <crazy_code2> bos: are you taking about rpms ?
11:49:44 <sorear> runghc Setup build
11:49:46 <sorear> runghc Setup install
11:49:49 <crazy_code2> Oh ok
11:49:59 <sorear> crazy_code2: no, we're (I'm) talking about the source code
11:50:07 <crazy_code2> Is this applicable for all .tar.gz files ?
11:50:22 <crazy_code2> or all libraries ?
11:50:25 <bos> if they have a Setup.hs or Setup.lhs file, generally yes.
11:50:36 <bos> the build system in question is called Cabal.
11:50:37 <sorear> No, only Haskell/Cabal .tar.gz's.
11:50:40 <crazy_code2> Ok
11:50:43 <crazy_code2> Thanks
11:50:45 <crazy_code2> Great
11:51:05 <bos> and the configure script in there is run by runghc Setup for you, so you don't need to run it yourself.
11:51:31 <sorear> What effect does -O normally have on memory usage?
11:51:53 * sorear suspect jhc might run *faster* with -Onot
11:52:19 <SamB> sorear: I bet it's not quite that simple
11:52:45 <sorear> @users
11:52:45 <lambdabot> Maximum users seen in #haskell: 354, currently: 307 (86.7%), active: 17 (5.5%)
11:54:07 * sorear runs jhc
11:55:00 <sorear>  5634 stefan    18   0  411m 309m  368 D  5.6 81.9   0:17.77 jhc
11:55:10 <sorear> 507m
11:55:22 <int-e> can jhc compile itself? *g*
11:55:33 <sorear> int-e: this is hello world.
11:55:35 <fasta> How do you find your way in a new Haskell code base? I can't find the main of darcs.
11:55:45 <int-e> sorear: I know, I've tried jhc
11:55:49 <sorear> fasta: grep -r '^'main .
11:56:15 <int-e> darcs.net is down?
11:56:23 <fasta> int-e: only port 80
11:57:07 <Saizan> to avoid zombies after many calls to runInteractiveCommand i should use waitForProcess on the ProcessHandle?
11:57:12 <sorear> yes
11:58:55 <Saizan> does this interact well with hGetContents on the out handle?
11:59:33 <fasta> I suppose loading darcs in ghci is out of the question?
12:01:42 <rretzbach> Do you Have any hints for me to learn to think functional?
12:01:56 <fasta> rretzbach: stop thinking in boxes
12:02:00 <fasta> :)
12:02:06 <rretzbach> I think in ellipsoids.
12:02:20 <byorgey> rretzbach: eat chocolate chip cookies
12:02:22 <rretzbach> Or moebius shapes, I don't know exactly.
12:02:44 <arcatan> ah, chocolate chip cookies
12:02:49 <byorgey> rretzbach: also, practice, practice, practice!
12:02:56 <sorear> stefan@stefans:/usr/local/src/jhc/test$ ./hs.out
12:02:56 <sorear> Hello, World!
12:03:02 <rretzbach> I like my cookies in my hagen dasz.
12:03:06 <sorear> Amazingly, jhc took less than a minute.
12:03:11 <byorgey> rretzbach: that works too
12:03:20 <rretzbach> :>
12:04:19 <sorear> rretzbach: normally I (english speaker, beware) don't see both accents and dipthongs; I see one or the other interchangably like Go:del and Goedel.  So Ha:agen dasz is correct?
12:04:40 <arcatan> it's a trademark
12:04:43 * sorear learns something
12:04:59 <rretzbach> sorear: I think so.
12:05:02 <arcatan> some kind of ice cream
12:05:14 <rretzbach> It's what's on the cup.
12:05:33 <rretzbach> I have a german keyboad and layout, so it's easy to type.
12:06:00 <rretzbach> But I see my typography skills aren't as flawless as I thought.
12:06:04 <rretzbach> I missed the hyphen :\
12:06:12 <rretzbach> Hagen-Dazs
12:06:26 <arcatan> hyphen sounds like a german swearword
12:06:30 <rretzbach> That's what the german(lol) website says.
12:07:02 <rretzbach> arcatan: Shall I teach you a swear?
12:07:52 <sorear> Wow! JHC is at 8% CPU!
12:08:33 <arcatan> they once thought me in #lighttpd
12:08:39 <arcatan> to say something like orange-cheesecake-face :)
12:08:45 <SamB> what's the other 92%?
12:08:48 <SamB> swap?
12:08:54 <sorear> yeah :)
12:08:57 <rretzbach> arcatan: in which language?
12:09:01 <arcatan> german
12:09:03 <sorear> WOW!
12:09:10 <rretzbach> Hehe, they pulled your leg.
12:09:12 <sorear> JHC can compile main = print 2 !
12:09:14 <SamB> sorear: so have you decided that -Onot wasn't such a good idea
12:09:25 <SamB> or is that better than before?
12:09:41 <sorear> SamB: I haven't tried it yet.
12:09:46 <SamB> ah.
12:11:41 <rretzbach> http://www.haagen-dazs.com/products/product.aspx?id=116 -- I guess this is one of the best ice cream I can buy in a store here.
12:11:42 <lambdabot> Title: Hagen-Dazs | Products | H&#228;agen-Dazs Ice Cream | Details: Macadamia Brit ...
12:11:56 <shapr> CosmicRay: I saw bos' blog post.
12:12:17 * SamB wonders how JohnMeacham plans to implement foreign export, including foreign export "wrapper" -- sees some signs of it in C.FromGin2
12:12:44 <int-e> ghc-6.6.1: maybe_relink.o: unknown symbol `stat' ... that's a libc symbol I thought, shouldn't the rts linker find that? hmm. *wonders*
12:13:23 <JohnMeacham> SamB: musasabi did some work on foreign export. I am not sure if it still works properly.
12:13:30 <rretzbach> So is there a tutorial which shows how to solve basic problems in functional languages?
12:14:34 <SamB> JohnMeacham: ah.
12:14:39 <sorear> int-e: no, it's not a libc symbol
12:15:47 <sorear> int-e: it's a #define
12:15:49 <sorear> http://hackage.haskell.org/trac/ghc/ticket/1086
12:15:52 <lambdabot> Title: #1086 (unix package cannot be compiled with -fasm, due to lstat()) - GHC - Trac
12:16:37 <byorgey> sorear: "Hagen-Dazs" was made up by an American entrepreneur to SOUND like some sort of European language =)
12:17:07 <byorgey> sorear: it's actually meaningless of course
12:17:50 * LoganCapaldo eats Hagen-Dazs and listens to Motley Cre
12:20:58 <int-e> sorear: it's not a #define here. it's a weak symbol though and the rts linker has some trouble with those if I remember correctly
12:22:41 <SamB> JohnMeacham: so, what kind of sanity checking is done on the output of E.FromHs?
12:22:55 <SamB> such as, oh, typechecking?
12:23:13 <SamB> especially with respect to primitives...
12:23:27 <sorear> SamB: E.Lint?
12:23:43 <JohnMeacham> SamB: lots of typechecking.
12:23:52 <JohnMeacham> SamB: E.TypeCheck
12:24:06 <sorear> does jhc ever run -fno-core-lint?
12:24:27 <SamB> JohnMeacham: so... how come it doesn't complain that it doesn't know how to typecheck IFunc ?
12:25:35 <sorear> JohnMeacham: You've really succeeded in bringing jhc's working set down.  It still uses 507M of memory, but it can compile 'main = print 2' in <5 minutes
12:26:38 <wolverian> haha, nice one... wait.. that wasn't a joke? (;
12:27:19 <sorear> wolverian: 650M and 4h-then-I-gave-up before :)
12:27:45 <JohnMeacham> SamB: it does, IFunc is inside the primitive wrapper, the typechecking happens at the EPrim level. IFunc doesn't have any type information in it to check.
12:28:48 <JohnMeacham> SamB: you can probably ignore it right up until Grin.FromE, where you can just copy the Func code, then you won't have to worry about it until code generation.
12:29:40 <JohnMeacham> sorear: yeah. I picked some low hanging fruits recently in that dept. once I get the separate compilation going, it should be quite usable.
12:29:54 <SamB> JohnMeacham: well, yes, but it seems like it'd be nice to have some way to have the compiler notice if something is horribly wrong... like it got applied it to the wrong number of arguments or something...
12:31:05 <JohnMeacham> SamB: it will, the types won't match. the E stuff is specifically disjoint from the primitive representation. they change independently of each other regularly.
12:31:45 <JohnMeacham> SamB: as in, there are concrete types associated with it. just not at the C.Prim level, because those types take different forms during different phases of compilation.
12:34:08 <hpaste>  edumember pasted "edumember" at http://hpaste.org/1513
12:35:06 <SamB> I suppose the C compiler or C.FromGrin2 would catch it, if nothing else did...
12:35:18 <SamB> I hope :-|
12:35:30 <sorear> 1513
12:37:52 <SamB> JohnMeacham: how do C.Generate/C.FromGrin2 deal with precedence?
12:38:47 <sorear> http://hackage.haskell.org/trac/ghc/ticket/1151 <- C compiler catches serious GHC bug ... one version late!
12:38:49 <lambdabot> Title: #1151 (small program misbehaves with -fvia-C) - GHC - Trac
12:39:11 <fasta> Hmm, first actual use for -fallow-undecidable-instances
12:39:19 <sorear> Case-of-case was implemented wrong, causing GHC to miscompile itself successfully.
12:39:39 <LoganCapaldo> oh noes!
12:39:47 <sorear> Miscompiled GHC successfully generates syntactically valid but bogus C.
12:40:12 <sorear> It's frightening how close GHC has come to *accidentally* creating a trusting-trust parasite.
12:40:46 <SamB> heh
12:40:48 <roconnor> GHC now automatically puts back doors into all login code.
12:41:03 <roconnor> and automatically puts in automatic back doors into all compiler code
12:41:31 <roconnor> the offending code was removed and GHC has been recompiled
12:41:32 <SamB> sorear: except that miscompiling code crazilly is much different from creating a backdoor in the login program...
12:41:35 <Heffalump> this seems quite a long way from that, given that the recompiled compiler didn't work
12:41:59 <roconnor> awww
12:42:50 <SamB> roconnor: ... has anyone even written such a program?
12:42:57 <roconnor> not to my knowledge
12:43:05 <Excedrin> what's a trusting-trust parasite?
12:43:25 <SamB> also, you'd have to work at it to get such a parasite to spread properly
12:43:29 <Heffalump> google for "reflections on trusting trust"
12:43:38 <SamB> you'd need to leave it in the GHC source for several releases!
12:43:53 <Heffalump> SamB: I reckon getting it into the 6.8 release would do
12:44:58 <SamB> or are we too lazy to build the source, or do we always use the most recent previous release to do it?
12:46:12 <Heffalump> I'd have thought most people that do rebuild the source would still restart from a binary at release time.
12:51:54 <rretzbach> I want a function to be called length mylist times with the elements of my list as one of many parameters.
12:52:07 <rretzbach> myfunc :: a -> b -> c
12:52:17 <rretzbach> mylist :: [b]
12:52:52 <rretzbach> let result = myfunc "hello" (allelementsof mylist)
12:53:02 <rretzbach> Is that possible?
12:53:03 <sorear> map (myfunc hello) mylist
12:53:08 <Vulpyne> map (myfunc 1 2 3) list
12:53:20 <Vulpyne> Will call myfunc with args 1 2 3 list_element
12:53:22 <Vulpyne> Once per element.
12:53:38 <rretzbach> The elements of mylist should be the first parameter of that function.
12:53:52 <sorear> map (flip myfunc hello) mylist
12:53:54 <rretzbach> I wrote it the wrong wy.
12:54:06 <rretzbach> flip is new to me.
12:54:12 <Vulpyne> Yeah, flip returns the function with the args reversed.
12:54:14 <rretzbach> But it "sounds" right :>
12:54:19 <Excedrin> > map (flip (+) 1) [1..3]
12:54:23 <lambdabot>  [2,3,4]
12:54:32 <rretzbach> That is hot stuff!
12:54:35 <JohnMeacham> SamB: hrm? what do you mean by precedence?
12:54:46 <Vulpyne> You can do some funky stuff with functions in Haskell.
12:55:17 <Vulpyne> Or perhaps I should have said "funcy stuff".
12:55:53 <fasta> GHC needs a type signatures for one of my functions, since otherwise it derives a wrong type (too general). Is this because I am using undecidable instances?
12:56:12 <LoganCapaldo> rretzbach: incidently, even if you didn't know about flip, you could have done map (\elem -> myfunc elem hello) list
12:56:25 <Excedrin> I guess "we put the funk in function" isn't in the topic anymore
12:56:34 <fasta> It suggests using -fno-monomorphism, but I am already using that.
12:57:01 <rretzbach> LoganCapaldo: Yeah, that I understand very well. Thank you, you three :)
12:57:09 <rretzbach> hexChar s = foldr1 mplus (map (flip char s) (['0'..'9'] ++ ['a'..'f']))
12:57:10 <SamB> JohnMeacham: I gather that means "lots of parentheses"
12:57:13 <rretzbach> looks good to me
12:58:06 <JohnMeacham> SamB: don't dis jhc's generated C code til you look at ghc's :)
12:58:46 <SamB> JohnMeacham: notice I did not say "lots of silly parentheses"
12:58:56 <Excedrin> rretzbach: what's "char" ?
12:59:06 <SamB> or "lots of parentheses and horrible indentation"
12:59:20 <rretzbach> http://pastie.caboo.se/75484 @ Excedrin
12:59:22 <lambdabot> Title: #75484 - Pastie
13:00:02 <SamB> ++" and tons of horrid macros and abuse of the C compiler to do something other than compile C"
13:00:03 <rretzbach> It's an exercise of one of the beginner haskell wikibooks
13:00:51 <LoganCapaldo> @index mplus
13:00:51 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
13:01:23 <LoganCapaldo> is / was Monad the old-fashioned way of saying Control.Monad?
13:01:37 <mauke> yes
13:01:42 <rretzbach> Hmm. This exercise has no solution.
13:01:47 <rretzbach> Should I add mine? :>
13:01:57 * LoganCapaldo wonders if the wikibook should be updated
13:02:45 <rretzbach> LoganCapaldo: Why not?
13:03:01 <LoganCapaldo> I dunno
13:03:13 <LoganCapaldo> At least I asusmed it was where you got the import Monad line
13:03:13 <Excedrin> hexChar breaks for some input
13:07:06 <rretzbach> hexChar [] = Nothing
13:07:25 <Excedrin> I annotated your paste, but I'm not sure if my solution is solved in the way the wikibook asks
13:08:10 <LoganCapaldo> rretzbach: or you could drop the 1, and do foldr mplus (map  ...) Nothing (digits ++ letters)
13:08:42 <rretzbach> I see, that's the tradeoff for the one less parameter :>
13:09:15 <rretzbach> Excedrin: Thanks for your effort, can I see it?
13:09:22 <Excedrin> yea, it's at the same url
13:09:33 <Excedrin> oh, sorry
13:09:37 <Excedrin> it changed and I didn't notice
13:09:45 <Excedrin> http://pastie.caboo.se/75487
13:09:45 <LoganCapaldo> pastie is not hpaste :(
13:09:47 <lambdabot> Title: #75487 - Pastie
13:09:54 <rretzbach> pastie has not such a feature.
13:10:19 <rretzbach> I only use it, cause i can paste directly from emacs :\
13:11:07 <sorear> fasta:
13:11:09 <LoganCapaldo> that should be just as achievable with hpaste.
13:11:13 <sorear> 12:54 < fasta> GHC needs a type signatures for one of my functions, since otherwise it derives a wrong type (too general). Is this because I am using undecidable instances?
13:11:29 <sorear> fasta: monomorphism only makes types too specific.
13:11:44 <rretzbach> Excedrin: I guess your solution is faster, but not as flexible as mine :>
13:11:48 <sorear> fasta: infact, it is considered a *feature* that very general types are produced
13:11:50 <dukedave> Hey guys, what is the #haskell 'chat' channel called?
13:11:56 <sorear> #haskell
13:12:06 <Saizan> i think dmhouse has written something to use hpaste from emacs
13:12:12 <rretzbach> LoganCapaldo: My lispfoo is not great enough :(
13:12:41 <dukedave> sorear: Isn't there one for off topic chat?
13:12:48 <sorear> #haskell-blah
13:12:51 <dukedave> Or does that not get used any more?
13:12:53 <LoganCapaldo> http://haskell.org/haskellwiki/Hpaste.el
13:13:01 <sorear> it's very used.
13:13:05 <sorear> @users #haskell-blah
13:13:06 <lambdabot> Maximum users seen in #haskell-blah: 44, currently: 34 (77.3%), active: 6 (17.6%)
13:13:20 <rretzbach> I remember I looked for hpaste in emacswiki...
13:13:34 <Excedrin> rretzbach: I don't disagree, but can you explain how yours is more flexible?
13:13:36 <rretzbach> Thanks anyway, I will install it right away. Kschh!!! @ pastie
13:14:08 <rretzbach> Excedrin: What will you do if hexchars will be defined to not have 'd' in their character set anymore?
13:14:31 <LoganCapaldo> heh
13:14:39 <rretzbach> yeah, that sounds a bit odd :D
13:15:31 <Excedrin> I'd add another guard for the 'd' special case
13:16:20 <rretzbach> How would you change foo to let it accept different chars at runtime?
13:18:36 <LoganCapaldo> well first he'd install hs-plugins and then ... :)
13:18:47 <rretzbach> In fact I should have made a parseChar function and hexChar s = parseChar s (digits ++ letters)
13:19:31 <LoganCapaldo> well I would have long since typed import Text.ParserCombinators.Parsec :)
13:19:35 <rretzbach> Cause the hexchars aren't going to change until the year 2030.
13:20:03 <rretzbach> Maybe they change never.
13:20:10 <rretzbach> But who really knows?
13:20:43 <Excedrin> well, it's interesting from a general point of view, not for the specific problem of hex chars
13:20:58 <rretzbach> I totally agree.
13:21:46 <Excedrin> I supppose I'd use a list or Data.Map or something
13:28:28 <LoganCapaldo> > let oneOf cs (c:s) = Prelude.lookup c $ zip cs $ repeat (c, s) ; hexChar = oneOf (['0'..'9'] ++ ['a'..'f']) in (hexChar "aze", hexChar "0", hexChar "the world is flat")
13:28:29 <lambdabot>  (Just ('a',"ze"),Just ('0',""),Nothing)
13:28:31 <sorear> Who's responsible for the haskell.org mailing lists?
13:29:07 <sorear> fasta: The correct way to say you care seems to be adding yourself to the bug's CC: list  (cf: the list archives have gone missing but I can upload the message)
13:29:27 <LoganCapaldo> @type let oneOf cs (c:s) = Prelude.lookup c $ zip cs $ repeat (c, s) ; hexChar = oneOf (['0'..'9'] ++ ['a'..'f']) in hexChar
13:29:29 <lambdabot> [Char] -> Maybe (Char, [Char])
13:29:51 <fasta> sorear: ?
13:29:56 <mauke> @seen augustss_
13:29:57 <lambdabot> augustss_ is in #haskell. I don't know when augustss_ last spoke.
13:30:08 <sorear> fasta: http://members.cox.net/stefanor/msg
13:31:20 <fasta> sorear: ok
13:31:26 <olsner> is there any model of computation that goes beyond turing machines (or other things of TM-equal power)?
13:31:32 <sorear> Yes,
13:31:58 <sorear> If you augment a turing machine with an oracle for the halting problem, you get a new machine of strictly greater power.
13:32:26 <sorear> This process can be repeated indefinitely, producing an abstract machine for every ordinal number.
13:32:46 * shapr cries on Network.URI
13:33:04 <olsner> ah, yes, oracles.. but there are no implementations of those machines, are there?
13:33:35 <dolio> Heh.
13:33:38 <shapr> DO NOT USE THIS: escapeURIString isAllowedInURI
13:33:40 <sorear> For all we know, the universe is in a TM
13:33:43 <Saizan> well you don't even have an implementation of a turing machine, no infinite tape
13:33:52 <byorgey> @pl \x -> (x,1)
13:33:52 <lambdabot> flip (,) 1
13:33:55 <olsner> I'm thinking, is the universe "merely" turing complete, or does it conform to some super-turing model
13:34:43 <shapr> Always use "escapeURIString (not.isReserved)" instead of "escapeURIString isAllowedInURI" ! Otherwise heisenbugs show up in your code!
13:35:14 <wolverian> it's a pushdown automaton, always pushing us down!
13:35:24 <olsner> shapr: then why is it possible to do it?
13:35:27 <sorear> everything about network.uri is terrible!
13:35:28 <hpaste>  gbirdie pasted "gbirdie" at http://hpaste.org/1514
13:35:30 <shapr> Lemmih and I just spent hours trying to figure out this intermittent failure :-(
13:35:41 <Heffalump> why was it intermittent?
13:35:50 <roconnor> sorear: there are even oracals who's power lies strictly between solving the halting problem and doing nothing.
13:35:53 <shapr> olsner: Because we were submitting hashes, and those hashes didn't always have characters like '+' in them.
13:36:26 <sorear> roconnor: I never said the correspondence was one-to-one :)
13:36:50 <shapr> Heffalump: Hi Heffalump! EVIL GHOST MOUSE!
13:36:54 <shapr> er, sorry...
13:37:01 * shapr closes VNC
13:37:22 <olsner> roconnor: oh, interesting.. what can those kinds of oracles predict?
13:37:36 <olsner> are those things like NP-complete problem oracles or?
13:37:54 <Heffalump> shapr: ??
13:37:58 <roconnor> olsner: pffft mathematictions don't care about that. ;)
13:38:00 <Heffalump> ah, I see.
13:38:03 <roconnor> er
13:38:06 * shapr grins
13:38:08 <roconnor> mathematicans
13:39:06 <|Steve|> Huh? The question of resolving the relationship between P and NP was once called the most important question in mathematics.
13:39:22 <roconnor> the oracals I've seen are specifically crafted to NOT solve the halting problem.
13:39:27 <roconnor> It's really hard to do.
13:40:07 <mehrheit> how many haskellers are needed to screw in a lightbulb?
13:40:21 <olsner> how humorous.. *not* solving the problem is the hard part, heh
13:40:59 <rretzbach> gn1000, thanks for your support, rest well.
13:41:05 * Ulfalizer reduces olsner :(
13:41:29 <olsner> Ulfalizer: since when are you here!?
13:41:35 <byorgey> mathematictions == people who study made-up mathematics?
13:41:41 <roconnor> There is a whole theory about the structure of these oracals. ... I'm not sure of what the point is.
13:41:45 <Ulfalizer> olsner: since 2 hours..
13:41:47 <timlarson_> haskellers use pop-in high-efficiency LED lights instead
13:41:49 <rretzbach> byorgey: lol
13:41:51 <Ulfalizer> but i'm here once in a while
13:41:57 <Ulfalizer> a long while..
13:42:26 * olsner is always lurking on #haskell when lurking
13:42:51 <Ulfalizer> so you're here all the time? :/
13:44:04 <sorear> roconnor: What's the difference between an oracal and an oracle?
13:44:25 <roconnor> sorear: I cannot spell
13:44:30 <roconnor> never have been able to
13:44:36 <roconnor> I'm really really bad on IRC.
13:44:49 <olsner> Ulfalizer: only when I'm on IRC
13:44:54 <byorgey> oracals give you the correct answer, but it might be spelled wrong
13:45:13 <byorgey> =)
13:45:25 <Ulfalizer> olsner: but you're always lurking :/
13:45:52 <olsner> Ulfalizer: am I? always?
13:46:05 <Ulfalizer> yes
13:56:55 <SamB> JohnMeacham: oh, how do I get the raw pointer from a FunPtr?
13:57:13 <SamB> I'm not even sure at what level that should happen...
13:58:10 <sorear> SamB: You can't get a void* from a FunPtr.
13:58:22 <SamB> sorear: well, true.
13:58:24 <sorear> SamB: ANSI C says the types are not necessarily the same size
13:58:41 <sorear> (void(*)()) ptr   re earlier
13:58:58 <SamB> sorear: that type would be one type the "raw pointer" could have, yes
13:59:25 <shapr> y0 tim
13:59:27 <SamB> struct sCFunAddr_h*, I'm fairly sure, is *not* ;-)
13:59:31 <Binkley> y0 shapr
14:00:35 <sorear> Binkley: the subject of things to tell SyntaxNinja came up two or three days ago, and I slipped in a mention of your h.h.o GECOS-field.  hope you don't mind.
14:00:48 <Binkley> sorear: not at all! thanks
14:02:16 <SamB> ah, it looks like I need to somehow get ahold of the Jhc.FunPtr data constructor and do a pattern match against it in my lambda...
14:02:44 <SamB> er.
14:02:49 <SamB> Jhc.Addr.FunPtr
14:02:57 <SamB> I just found the Jhc.Addr module
14:09:32 <mdmkolbe|home> Is there some kind of Trie data structure in the GHC libraries?  I didn't see one but I could have missed it.
14:10:38 <Vulpyne> You know you can put more than two things in a tuple?
14:10:52 <shapr> really?
14:10:54 <SamB> Vulpyne: who'd want to?
14:11:52 <Excedrin> mdmkolbe|home: there is a Trie.hs somewhere, but it's not in the GHC libs afaik
14:12:20 <Vulpyne> Maybe he meant something by "trie" than I thought.
14:12:23 <JohnMeacham> SamB: what do you mean?
14:13:07 <sorear> mdmkolbe|home: Data.IntSet/IntMap are tries
14:13:38 <SamB> JohnMeacham: well, I don't think that casting a (struct sCFunAddr_h*) to a function pointer and calling it is going to have good results
14:14:01 * SamB isn't really sure what to do about this, actually
14:15:17 <JohnMeacham> SamB: hrm? there shouldn't be a struct there. a FunPtr is just a wrapper around an Addr, which is a primitive type.
14:15:52 <oerjan> Vulpyne: a trie is a kind of tree
14:16:32 <SamB> JohnMeacham: well, maybe that's just the wrapper then?
14:17:16 <SamB> hmm, but why's it called sCFunAddr_h
14:17:49 <thoughtpolice> JohnMeacham: i seem to be getting a darcs err when pulling DrIFT's repo (i wanted to try jhc :) )
14:18:08 <thoughtpolice> it seems patch 41 of 46 is unapplicable for some reason
14:18:09 <mdmkolbe|home> hmm, well I was trying to descide how to compactly write a fairly efficient LZ77 algorithm (less than 5 lines is optimal, less than 10 acceptable and 15 marginal), I was just thinking that a Trie would be more efficient than re-searching the sliding window each time (caviat emptor about lengths greater than offset, etc.)
14:19:20 <mdmkolbe|home> Anyone know LZ77 well enough to recommend any faster/smaller way?
14:19:48 <JohnMeacham> thoughtpolice: yes. it got corrupt somehow. I need a darcs wizard to fix it.
14:19:56 <thoughtpolice> JohnMeacham: I suppose just try a tarball?
14:20:58 <SamB> JohnMeacham: "fix"?
14:21:45 <JohnMeacham> perform some repo surgery.
14:22:05 <SamB> I'm questioning whether such a thing is possible
14:22:14 <SamB> well, I suppose it might be...
14:22:27 <SamB> but I wouldn't hold your breath
14:23:28 <SamB> JohnMeacham: why don't you just get rid of those last six patches and run "darcs repair"
14:25:15 <Heffalump> repo surgery is often possible
14:25:21 <Heffalump> I could have a look tomorrow night if you like
14:25:24 <SamB> where by "get rid of", I mean something involving the use of "rm" while loooking through/editing _darcss/inventory
14:25:59 * SamB wonders if there is something about running jhc that makes him speak snake
14:27:47 <sorear> speak snake?
14:28:33 <SamB> notice the extra s in _darcss
14:29:53 * Heffalump goes to bed. Grab me tomorrow evening if you want an attempt at surgery.
14:30:42 <Heffalump> or mail me (ganesh@earth.li) with a summary of the problem (symptoms, efforts so far, where the repo is)
14:39:26 <Binkley> ?yow
14:39:26 <lambdabot> You were s'posed to laugh!
14:40:26 <mehrheit> > question "O RLY?"
14:40:27 <lambdabot>   Not in scope: `question'
14:45:04 <mehrheit> @hoogle isPrefixOf
14:45:05 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
14:45:44 <mehrheit> @let let question q = let x = map toUpper q; val s = (length s)*20 + (sum $ map fromEnum s) in if (isPrefixOf "O RLY" x) then "YA RLY" else if (fst . (randomR (0, 100)) . mkStdGen . val $ x) < 50 then "No." else "Yes."
14:45:44 <lambdabot>  Parse error
14:45:58 <mehrheit> @let question q = let x = map toUpper q; val s = (length s)*20 + (sum $ map fromEnum s) in if (isPrefixOf "O RLY" x) then "YA RLY" else if (fst . (randomR (0, 100)) . mkStdGen . val $ x) < 50 then "No." else "Yes."
14:46:00 <lambdabot> Defined.
14:47:58 <SamB> JohnMeacham: so how would I extract the FunAddr field from the FunPtr?
14:47:59 <oerjan> i note that anagrams will nearly always have the same answer :)
14:48:25 <SamB> JohnMeacham: or does that happen automatically for primitive's arguments?
14:51:31 <oerjan> > random (mkStdGen 42) :: Bool
14:51:32 <lambdabot>  Couldn't match expected type `Bool'
14:51:44 <oerjan> :t random
14:51:46 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
14:52:24 <oerjan> > (fst $ random $ mkStdGen 42) :: Bool
14:52:26 <lambdabot>  True
14:59:24 <jberg> hi i have a function which returns an int, how can i use that in putStr?
14:59:41 <kaol> > show (42::Int)
14:59:42 <lambdabot>  "42"
14:59:47 <jberg> thanks
15:00:49 <jberg> uhm i want to do main = do show myFunc but that doesn't work
15:01:06 <Excedrin> show isn't an IO action
15:01:10 <Excedrin> :t show
15:01:11 <jberg> yeah
15:01:12 <lambdabot> forall a. (Show a) => a -> String
15:01:27 <Excedrin> :t print
15:01:27 <jberg> but how can i do it then?
15:01:30 <lambdabot> forall a. (Show a) => a -> IO ()
15:01:31 <Saizan> main = putStr (show myFunc)
15:01:36 <Saizan> or use print
15:01:39 <Saizan> ?src print
15:01:39 <lambdabot> print x = putStrLn (show x)
15:01:39 <jberg> oh ok
15:01:42 <jberg> thanks
15:01:55 <shapr> Yarr! Haskell is so much more fun than writing Python! I'm sooo happpy!
15:01:58 <Saizan> that only if myFunc is a 0 arguments functions
15:02:09 <Saizan> *function
15:02:11 <Binkley> shapr: you had to write Python?
15:02:12 <jberg> Saizan: its not
15:02:46 <shapr> Binkley: I was a Python webmonkey for years before this. I still have flashbacks.
15:02:54 <shapr> @quote Binkley
15:02:54 <lambdabot> Binkley says: vincenz: lots of practice
15:03:01 <shapr> @quote Binkley
15:03:01 <lambdabot> Binkley says: are there any Haskell users who haven't implemented a compiler?
15:03:03 <Saizan> jberg: so main = putStr (show (myFunc arg1 arg2 ...))
15:03:21 <jberg> yep that works
15:03:50 <Binkley> shapr: ah, so it's not *news* that Haskell is better than Python :-)
15:03:51 <Saizan> jberg: you can also write main = putStr . show $ myFunc a1 a2 .. , less parens
15:04:04 <Vulpyne> I love $.
15:04:08 <Vulpyne> I wish more languages had it.
15:04:20 <jberg> yep. btw, how can i time my haskell program on mac os x? i though i could do time myapp ?
15:04:39 <shapr> Binkley: I'm also a CUFP committee member, so I get regular perspective on other language viewpoints.
15:04:52 <Saizan> jberg: you can
15:05:10 <jberg> oh had to do time ./myapp :)
15:06:03 <shapr> Binkley: I'm sort of worried about Haskell's commercial uptake hitting a low point at the moment. At this point it's no longer a surprise that Haskell is good for production apps, but there aren't a lot of commercial users really using it yet.
15:07:41 <Excedrin> there won't be for 10 years, and by then there'll be some new cool language(s)
15:08:03 <shapr> Excedrin: Well, I'll just have to get all persuasive...
15:08:36 <Binkley> shapr: it's funny to be at that point, since less than a year ago it was always, "hey, people aer using Haskell!"
15:09:01 <shapr> Binkley: Yeah, but I don't want to lose momentum now!
15:10:14 <SyntaxNinja> @quote vulpyne  I love $.
15:10:14 <lambdabot> No quotes for this person. Listen, broccoli brains, I don't have time to listen to this trash.
15:11:32 <Binkley> shapr: of course, but maybe it'll take more time to get going :-)
15:12:48 <shapr> Binkley: Tried xmonad?
15:13:03 <Binkley> shapr: not yet... maybe when I get a new laptop I will
15:13:05 <Binkley> but it sounds exciting
15:14:24 <shapr> xmonad is exciting in the sense that it's stable, fast, easy to configure, and otherwise stays out of your way.
15:14:48 <Binkley> well, I think it would be inherently exciting to run a window manager written in Haskell
15:14:54 <Binkley> today the window manager, tomorrow the entire OS :-)
15:15:03 * shapr cheers!
15:15:12 <kaol> @where house
15:15:12 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
15:15:39 <shapr> Binkley: If you read the kernel page on lwn.net, you'll see regular discussions like "How can we safely separate these things?" and I keep thinking 'Use the H monad!'
15:15:41 <SamB> JohnMeacham: so how come it looks like Jhc.Addr.FunAddr is a wired-in *data* type, not a newtype or raw type?
15:16:01 <sieni> perhaps haskell is the prime mover in achieving the technological singularity
15:16:03 <shapr> kaol: Hey, I heard that the House project has been revived somewhat. There's a new graduate student working on it!
15:16:32 <shapr> kaol: In fact, that new graduate student is Binkley :-)
15:16:33 <kaol> when can we start a Debian GNU/House project?
15:16:37 <shapr> oooh!
15:17:00 <SamB> kaol: after you implement libc and get it self-hosting?
15:17:04 <SamB> also a filesystem ;-)
15:17:09 <shapr> I dunno if you'd need the GNU part.
15:17:17 <SamB> and you'd probably want to get it to build with recent GHC's...
15:17:36 <SamB> shapr: well what about that Debian part then
15:17:55 <sieni> cabal-get instead of apt-get !!!1!
15:18:09 <hpaste>  gbrasil pasted "gbrasil" at http://hpaste.org/1515
15:18:19 <Binkley> maybe i'll start with getting it to build with a recent GHC :-)
15:18:31 <Binkley> today GHC 6.6.1, tomorrow the world!
15:18:36 <shapr> The Hardware monad is the most exciting part of House for me. The Hardware monad means you could run everything 'in-kernel' and still have process safety.
15:18:47 <shapr> Wow, hpaste spam!
15:18:50 <shapr> Is this a new thing?
15:19:01 <SamB> well, doesn't it need a specially hacked GHC (included in its tree) right now?
15:19:31 <Binkley> shapr: we were just talking about that yesterday
15:19:46 <Binkley> SamB: right, the work that would be involved is hacking the newer version of GHC in the same way
15:19:56 <Binkley> of course the problem persists every time there's a new version of GHC released...
15:20:05 <Binkley> apparently the spam problem's been there for a while
15:20:06 <SamB> well it'd be cooler if you could get it to use an unhacked GHC
15:20:21 <Binkley> SamB: yeah, I don't know exactly in what ways it was hacked, I should find out
15:20:36 <shapr> Binkley: Type safety subsumes the whole idea of process safety.
15:20:39 <Binkley> well, I know that part of it is to remove some of the stuff from the RTS that we don't need for House
15:20:44 <shapr> I LIKE THAT!
15:20:48 * shapr boings furiously
15:20:59 <Binkley> shapr: yeah, it's cool
15:29:00 <sorear> shapr: treble says that the reason we have hpaste spam is that the version of happs on scannedinavian is too weird to allow for convienient hpaste hacking
15:30:01 <sorear> I suggested he should get an account on community.h.o and run hpaste from there.
15:30:41 <shapr> Or just clean it up so it is hackable?
15:30:41 <sorear> SyntaxNinja: poke, treble doubted you would like this, but I think you would - truth?
15:30:57 <sorear> shapr: clean what up?
15:31:07 <shapr> Unweird hpaste
15:31:20 <sorear> shapr: it's h*apps* that is weird
15:31:26 <shapr> Oh?
15:31:32 <shapr> how so?
15:31:51 <sorear> shapr: apparently the version on scannedinavain doesn't exist anywhere else, so the only way to hack it is in situ
15:32:03 <SyntaxNinja> who is trreble
15:32:09 <shapr> SyntaxNinja: monochrom
15:32:11 <sorear> SyntaxNinja: Eric Mertens
15:32:15 <SyntaxNinja> ok
15:32:18 <shapr> sorear: Nah, glguy is Eric Mertens
15:32:23 <SyntaxNinja> you guys are confusing me
15:32:29 <sorear> shapr: yeah, he's changed his nick several times
15:32:31 <SyntaxNinja> I told eric that I though ti was a good idea, actually today.
15:32:37 <sorear> shapr: monochrom is treblacy
15:32:40 <shapr> sorear: And monochrom is the guy in canada whose name I can't remember right now.
15:32:58 <sorear> Albert C. A. Yai or some permutation thereof.
15:33:04 <shapr> sorear: Yes! That's it!
15:33:07 <SyntaxNinja> but really talk to dons and Igloo also about what comm.h.o is for :)
15:35:06 <shapr> sorear: If hpaste doesn't run on the HAppS dev repo from right now, I'll fix it.
15:35:15 <shapr> Or try to bribe Saizan  ;-)
15:36:15 <sorear> I'm just repeating what treble/glguy/emertens said earlier :)
15:36:25 <shapr> @seen treble
15:36:25 <lambdabot> treble has changed nick to glguy.
15:36:25 <lambdabot> I saw glguy leaving #haskell 13h 47m 30s ago, and .
15:36:30 <sorear> when #4 comes I'm just gonna start calling him Eric
15:36:53 * shapr sets up a cron job to update HAppS on scannedinavain
15:36:57 <shapr> um, scannedinavian
15:37:28 <shapr> Dang hippie-expand
15:40:16 <sorear> JonCast++ I understand natural transformations now
15:41:10 <Saizan> sorear: link?
15:41:55 <lokik> how do I declare a set?
15:42:15 * lokik is assuming using Data.Set
15:42:35 <Saizan> > S.fromList $ [1..10] ++ [1..10]
15:42:36 <lambdabot>   Not in scope: `S.fromList'
15:42:43 <Saizan> > Data.Set.fromList $ [1..10] ++ [1..10]
15:42:45 <lambdabot>  fromList [1,2,3,4,5,6,7,8,9,10]
15:43:09 <lokik> .ua discovery
15:43:27 <Saizan> or you can start with an empty one and insert as you go
15:43:28 <sorear> http://haskell.org/pipermail/haskell-cafe/2007-July/027822.html
15:43:30 <lambdabot> Title: [Haskell-cafe] Before
15:43:35 <Saizan> ?type Data.Set.empty
15:43:37 <lambdabot> forall a. Data.Set.Set a
15:43:48 <lokik> so how would I declare an empty set?
15:44:08 <Saizan> > Data.Set.empty
15:44:10 <lambdabot>  fromList []
15:44:21 <lokik> .ua
15:44:30 <Saizan> lokik: there's this predefind value binded to the name "empty"
15:45:33 <lokik> i'll figure it out probably
15:45:48 <shapr> What's up with hs-plugins with ghc 6.6.1?
15:46:13 <Saizan> ?docs Data.Set -- have you seen this, lokik?
15:46:13 <lambdabot> Data.Set -- have you seen this, lokik? not available
15:46:19 <Saizan> ?docs Data.Set
15:46:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Set.html
15:47:21 <sorear> shapr: the tarball definitely won't work.  the darcs repo might
15:48:41 <mehrheit> ?docs I am
15:48:42 <lambdabot> I am not available
15:48:54 <shapr> Hm, march 22nd is the most recent patch in the hs-plugins repo
15:49:29 <lokik> Saizan: yep I was looking it at before I asked even
15:52:22 <shapr> @where haskell-src
15:52:22 <lambdabot> I know nothing about haskell-src.
15:56:35 <laz0r> hi everybody
15:56:44 <laz0r> i am playing around with haskell and monads
15:57:03 <laz0r> specifically i am trying to understand the so-called 'state monad'
15:57:17 <laz0r> andun, actually, the whole monad concept
15:58:06 <Saizan> have you seen how state is implemented?
15:58:21 <laz0r> i have the book 'the haskell school of expression' and there is an example of a state monad which i am trying to implement
15:58:57 <laz0r> but when i try to use it with hugs i get: ERROR "Test.hs":33 - Syntax error in expression (unexpected `=')
15:59:11 <laz0r> now, i am completly puzzled why hugs is complaining
15:59:24 <laz0r> the source i use is here -> http://pastebin.com/940940
16:00:01 <laz0r> this is more a less the exact same thing that is written in my book
16:00:52 <laz0r> first i thought my indentation was wrong
16:00:57 <laz0r> but it seems it isn'T
16:01:44 <Saizan> let's see
16:04:12 <Saizan> laz0r: the page doesn't load here, can you repaste on hpaste.org?
16:04:15 <Saizan> @paste
16:04:15 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:05:11 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1516
16:05:21 <laz0r> ^ there it is
16:05:29 <laz0r> i just had an idea and changed it
16:05:39 <laz0r> but the old code is commented
16:06:02 <oerjan> the return and Label lines need indentation
16:07:16 <Saizan> yes, because they are part of the instance declaration
16:07:17 <laz0r> mmh, it still complains
16:07:29 <laz0r> any more indentation errors?
16:07:30 <oerjan> ouch, the characters don't line up in hpaste?
16:07:55 <oerjan> remove the tab characters.
16:07:57 <Saizan> also, the lines from let to in needs to be at the same indentation level
16:08:14 <laz0r> it is the same level, but i'll try without tabs
16:08:30 <oerjan> indeed that _would_ give an unexpected = error, i think
16:08:56 <shapr> hi Souwh!
16:09:03 <Saizan> yeah, don't mix spaces and tabs
16:09:05 <oerjan> it seems like tabs don't work well in hpaste
16:09:11 <Cale> laz0r: Tabs count as 8 spaces to the compiler, so you should avoid having them in source files altogether.
16:09:24 <Souwh> Hi shapr
16:09:28 <Cale> Tabs work fine in hpaste
16:09:50 <Cale> er, sorry, tabs align to the nearest 8-space boundary rather
16:10:00 <Cale> which is what they generally mean in unix :)
16:10:06 <oerjan> Cale: but they correspond to a non-integer number of spaces in my browser
16:10:20 <Cale> they do?
16:10:24 <Cale> That's strange :)
16:10:39 <SamB> oerjan: what a lovely browser (note: I'm not kidding)
16:10:50 <Saizan> is the font a monospace?
16:10:53 <oerjan> about 6 1/2 i think
16:11:07 <oerjan> the characters are otherwise monospace
16:11:38 <mehrheit> it's actually 2pi
16:11:45 <mehrheit> the browser is written by math geeks
16:12:01 <oerjan> i must disappoint you that it is actually IE
16:12:26 <mehrheit> oh. i must go to sleep now
16:12:31 <laz0r> aheller, uh, ok, things are starting to work... slowly
16:12:41 <oerjan> although being able to detect tabs _would_ seem a feature in this case
16:12:50 <laz0r> autocompletion...
16:14:06 <laz0r> yay! it works!
16:14:39 <hpaste>  Cale pasted "tabs test" at http://hpaste.org/1517
16:14:48 <Cale> oops :)
16:14:55 <oerjan> laz0r: i guess you had tabs set to 4 spaces in your editor, which didn't work well with haskell
16:15:35 <Cale> You should basically set your editor to produce spaces whenever the tab key is pressed, and convert all tab characters to spaces when saving.
16:16:05 <Cale> (you can also usually set it to treat multiple spaces as if they were tabs)
16:16:24 <mm_freak> btw  is there any useful alternative to haskell-mode (emacs)?  it sucks at indentation
16:17:00 <Cale> mm_freak: I found that when I was using it, I liked the simple indent mode more than the "smart" one.
16:17:53 <Saizan> i just hit tab till i get the right one, but there are cases in do-notation where it doesn't get it
16:17:57 <Cale> The smart one always cycled through a bunch of indentations, none of which was the one I wanted, causing me to have to hold the space bar down a whole bunch.
16:18:05 <sorear> shapr: ping
16:18:40 <SamB> I'm about ready to try to hack in the Lisp indendation code
16:18:41 <Cale> It's just easier if hitting the tab key gives you 4 spaces, and you can adjust from there.
16:18:43 <laz0r> i'll just put sometinh in my .vimrc that will convert tabs to spaces
16:18:51 <mm_freak> cale: well, i like to always indent two spaces
16:19:07 <mm_freak> with some exceptions, but mostly i like two spaces
16:19:10 <Cale> mm_freak: or whatever :)
16:19:12 <notadev> meh i like tabs :)
16:19:37 <SamB> notadev: tabs don't really agree with Haskell very well
16:19:41 <mm_freak> cale: i don't like to adjust  cc-mode always gives me the indentation i like =)
16:19:43 <Cale> laz0r:  set smarttab and set expandtab
16:19:45 <notadev> ha
16:19:45 <mm_freak> i just hit the tab key
16:20:21 <mm_freak> i like tabs in layoutless languages like C
16:20:31 <SamB> yes, we were planning to get that to work in haskell-mode just a soon as we finished our mind-reading program
16:20:45 <oerjan> laz0r: i use set expandtab set tabstop=4 set shiftwidth=4 set ai
16:20:54 <Cale> I've basically completely given up on the whole idea of tab characters.
16:21:02 <notadev> hehe
16:21:29 <Cale> I think compilers should treat it as a lexical error for a tab character to occur in any source file.
16:21:40 <notadev> lol
16:21:45 <mm_freak> i'll try yaham
16:21:49 <Excedrin> that would really break my whitespace compiler
16:21:55 <mm_freak> yet another haskell mode =)
16:21:58 <SamB> Cale: I think they should only do that in places were it might make a difference
16:22:14 <notadev> meh nu-skool freeks ;P
16:22:21 <SamB> i.e. anywhere in Haskell or Python, or inside a string literal in any language
16:22:51 <Cale> lexical error: Tab character in file `hello.hs'. Fix your editor.
16:23:04 <notadev> bleh fix your lexer ;)
16:23:47 <Cale> The entire point being that while the lexer can interpret the tab somehow, there's no guarantee that its interpretation is the same as your editor's.
16:24:16 <Cale> While one can take SamB's view and only fail when there's a genuine ambiguity, I think it's easier just to force people never to use them.
16:24:30 <Cale> If you want a tab character inside a string, use \t
16:24:34 <Excedrin> what if editors treated tab characters as logical indentation, with a configurable number of spaces depending on what part of the syntax it occurs in (if..\telse = tab appears as one space)
16:24:38 <notadev> not my problem tbh, but then i don't really use haskell.
16:24:45 <SamB> Cale: my plan forces that too
16:24:55 <notadev> one token Excedrin, yeah
16:25:08 <mm_freak> excedrin: this is exactly how tabs are defined  but how would you go about telling the lexer what is _your_ view of a tab?
16:25:11 <SamB> Excedrin: waaaay too complicated
16:25:12 <Cale> SamB: Oh, sorry, I didn't read that completely
16:25:32 <mm_freak> if you never use spaces to indent, but only tabs, then that's ok, but you cannot intermix both unambiguously
16:25:39 <notadev> char=token in this case
16:25:40 <Excedrin> right, no spaces ever
16:25:46 <notadev> yeah so define as only tabs
16:25:52 <SamB> bascically my plan is based on the idea: "who cares if they use tabs in their C code?"
16:25:53 <notadev> exactly Excedrin :D
16:25:58 <Cale> But you already have to have tabs.
16:26:02 <Cale> er, spaces :)
16:26:05 <mm_freak> but it just appears easier to use spaces and be well =)
16:26:17 <notadev> not imo
16:26:28 <Cale> mm_freak: right.
16:26:49 <mm_freak> IMO tabs are too abstract for a layout-based language like haskell
16:26:55 <notadev> if indentation is significant, tabs are *much* easier
16:27:03 <Cale> Actually, if we wanted to do things the *right* way, editors would really edit syntax trees, and things would be stored to disk in an abstract structural format.
16:27:11 <notadev> yeuch
16:27:16 <Excedrin> that's subtext
16:27:24 <mm_freak> notadev: yes, but then the _language_ must define the meaning of a tab, and that collides with how editors view tabs
16:27:37 <oerjan> just tabs don't always work in Haskell because a block does not necessarily start at the beginning of a line
16:27:40 <Cale> Excedrin: well, with subtext, the editor edits the code graph :)
16:27:42 <notadev> so configure your editor properly mm_freak ;)
16:27:57 <mm_freak> my editor _is_ properly configured =)
16:27:58 <Cale> oerjan: good point
16:28:03 <notadev> hehe
16:28:10 <notadev> i love geek arguments ;D
16:28:21 <mm_freak> tabs are 2 spaces for me, and i never indent with spaces in other languages
16:28:30 <mm_freak> but in haskell i indent _solely_ with spaces
16:28:37 <SamB> mm_freak: that isn't proper
16:28:57 <mm_freak> because otherwise the code might appear messed up for other people  consider this code:
16:29:06 <SamB> a proper configuration would have tab insert two spaces, and never insert a tab
16:29:09 <mm_freak> data List t = Nil
16:29:21 <mm_freak> \t\tBranch (List t) (List t)
16:29:33 <SamB> you left out the |
16:29:38 <mm_freak> yes, sorry
16:29:41 <mm_freak> but you get the point
16:29:49 <notadev> i don't care i only use tabs at start of line in src
16:29:50 <SamB> quite
16:29:51 <mehrheit> branching lists
16:29:54 <mehrheit> interesting
16:30:09 <mm_freak> it _might_ look properly aligned with other people's tab preferences, but it may as well appear totally messed up
16:30:11 <Cale> hehe, with no entries :)
16:30:21 <mm_freak> mehrheit: lol, sorry, confused something =)
16:30:34 <mm_freak> \t\t| Cons t (List t)
16:30:44 <notadev> sorry i don't grok the code, so it's not a good example for me mm_freak; what's the point exactly?
16:31:03 <mm_freak> notadev: the vertical alignment
16:31:15 <mm_freak> ideally the | appears directly below the =
16:31:24 <notadev> lmao
16:31:47 <Cale> In this case, the precise vertical alignment isn't a semantics issue, but in many cases, it is.
16:31:52 <notadev> i only use indent to signify new block
16:32:12 <notadev> exactly like lispers, only no brackets
16:32:29 <mm_freak> notadev: yes, but the new block doesn't (or shouldn't) always start at a new line
16:32:30 <Cale> notadev: In Haskell, keywords like do will introduce a new block whose indentation level is the indentation level of the next non-whitespace character.
16:32:34 <Cale> So for example
16:32:38 * SamB suddenly realizes that the change he just made to jhc could not have helped because it only affects what goes into an ho file, and he  still had one lying around..
16:32:39 <Cale> do x <- getLine
16:32:43 <Cale>    putStrLn x
16:32:51 <mrd> Cale: "editors would really edit syntax trees," what like lisp?
16:33:06 <Cale> mrd: Yes, but with much more sugar.
16:33:35 <mrd> visual appearance is concrete syntax, but manipulation is based on ast?
16:33:45 <Cale> Yeah.
16:33:46 <notadev> ok cale, that's cool. personally i only like looking at next level how it's done in heredocs in bash
16:33:59 <notadev> if it's a new block, indent+1 is simple
16:34:22 <notadev> haskell operators are what i find interesting
16:34:41 <Cale> notadev: In my example there, if the putStrLn is indented any further, then it becomes part of the previous line of the do-block.
16:34:43 <notadev> $ is sweet compared to LISP
16:35:07 <mrd> in what way is $ related to lisp, except to FUNCALL?
16:35:18 <Cale> mrd: Elimination of parens :)
16:35:22 <notadev> Cale: excellent! i veer between indent+2 and _ for line continuation tbh
16:35:28 <mrd> except that parens in Lisp have a completely different meaning than Haskell
16:35:50 <notadev> well it was explained to me as like ( but with no ) req'd
16:36:05 <mrd> that explanation is oversimplified
16:36:10 <notadev> which seemed to work in lambdabot
16:36:15 <notadev> well i am a n00b ;)
16:36:38 <mrd> there is no such thing as an unneccessary parenthesis in Lisp
16:36:55 <mehrheit> notadev, _ for line continuation -- like visual basic?
16:37:00 <notadev> yup
16:37:43 <notadev> hehe well i saw a help note from some old LISP heads, who wrote something like "Real Lispers use indents and let the editor worry about the bracket matching"
16:38:02 <notadev> which just made me think: "why not just use the indents then?"
16:38:07 <mm_freak> btw  haskell appears to be the only purely functional langauge  are there any others?
16:38:22 <mrd> Clean
16:38:26 <mrd> Miranda
16:38:30 <mrd> Coq
16:38:56 <mrd> notadev: you're not the first person to think that
16:39:08 <notadev> i know look at py ;)
16:39:18 <mrd> notadev: someone actually wrote a frontend to some Scheme which would allow it to accept indentation-based replacement syntax.
16:39:27 <mrd> no, py is just retarded
16:39:28 <aeyakovenko> what are WordPtr and IntPtr used for?
16:40:05 <mrd> :i WordPtr
16:40:06 <Cale> aeyakovenko: what library is this from?
16:40:11 <mrd> @hoogle WordPtr
16:40:12 <lambdabot> No matches found
16:40:20 <Cale> aeyakovenko: Is there a  type WordPtr = Ptr Word ?
16:40:21 <aeyakovenko> foreign.ptr
16:40:26 <mrd> might be
16:40:34 <Cale> oh
16:40:50 <Cale> No, apparently they're isomorphic, but not the same type
16:41:09 <Cale> IntPtr and WordPtr are instances of Integral
16:41:20 <mrd> for manipulation of pts?
16:41:20 <aeyakovenko> i am just confused what the Num instance implies, does that mean i can do math on the data the pointer points to, or just the pointer itself?
16:41:25 <Cale> So you can do arbitrary arithmetic on them.
16:41:37 <Cale> On the pointer itself.
16:41:48 <mrd> aeyakovenko: (+) :: WordPtr -> WordPtr -> WordPtr
16:41:56 <Pseudonym> Anyone here used implicit parameters?
16:42:04 <sorear> Yes.
16:42:04 <aeyakovenko> is there any way to do the math on the data without marshalling?
16:42:14 <Pseudonym> sorear: Cool.  Question.
16:42:37 <mm_freak> is there any (purely functional) alternative to haskell, which is easier to tune for performance?
16:42:39 <Pseudonym> foo :: (Show m, ?something :: m) => String
16:42:47 <Pseudonym> That's incorrect, right?
16:42:50 <Cale> mm_freak: GHC :)
16:43:01 <notadev> ++
16:43:13 <sorear> Pseudonym: No.
16:43:18 <sorear> :t show ?something
16:43:20 <lambdabot> (?something::Integer) => String
16:43:23 <mm_freak> cale: well
16:43:27 <sorear> MR--
16:43:29 <Cale> mm_freak: Also, the Clean guys get decent performance from their IO system.
16:43:32 <Pseudonym> sorear: It's the polymorphism that breaks.
16:43:38 <Cale> MR--
16:43:42 <Cale> @karma MR
16:43:42 <lambdabot> MR has a karma of -4
16:43:43 <Pseudonym> Note that that type defaulted.
16:43:58 <sorear> :t (show ?something) :: (?something :: m, Show m) => String
16:44:01 <lambdabot>     Ambiguous constraint `Show m'
16:44:01 <lambdabot>         At least one of the forall'd type variables mentioned by the constraint
16:44:05 <mm_freak> fac 0 = 1 \n fac n = n * fac (n - 1) -- does GHC compile this into a iterative function?
16:44:19 <sorear> mm_freak: No, why?
16:44:28 <Pseudonym> sorear: And this doesn't work either.
16:44:29 <Excedrin> mm_freak: does "purely functional" mean that you'd like the language to enforce that? because you can code in a purely functional style in SML or OCaml and tune either for performance...
16:44:30 <notadev> hehe
16:44:39 <sorear> mm_freak: Caring about performence is *extremely* bad form
16:44:45 <notadev> lol
16:44:53 <Pseudonym> :t (show ?something) :: (?something :: (forall m. Show m => m) => String
16:44:54 <lambdabot> parse error on input `=>'
16:44:57 <mm_freak> i've read that erlang _does_ compile this into an iterative function
16:45:03 <Pseudonym> :t (show ?something) :: (?something :: (forall m. (Show m) => m) => String
16:45:05 <lambdabot> parse error on input `=>'
16:45:09 <Pseudonym> Erm.
16:45:19 <Pseudonym> :t (show ?something) :: (?something :: (forall m. (Show m) => m)) => String
16:45:22 <lambdabot>     Cannot match a monotype with `forall m. (Show m) => m'
16:45:22 <lambdabot>       Expected type: forall m. (Show m) => m
16:45:24 <Pseudonym> That's it.
16:45:32 <mm_freak> excedrin: e.g. it should not provide a random number `function'
16:45:36 <Pseudonym> I don't understand that error message.
16:45:41 <Pseudonym> As far as I can tell, that IS a monotype.
16:46:05 <Pseudonym> Isn't it?
16:47:16 <mm_freak> sorear: not always  i was trying to implement a factorization algorithm using the fact that (isqrt(n)! mod n) has a non-trivial factor in common with a composite n
16:47:41 <Pseudonym> sorear is being facetious.
16:47:46 <mm_freak> it was extremely slow and eventually caused a stack fault for larger numbers
16:48:04 <sorear> mm_freak: GHC uses GMP, which means that every other language is either slower or uses deep assembly hackage
16:48:08 <SamB> Excedrin: I think it means that the done thing is to code that way
16:48:17 <Pseudonym> Caring about performance is good so long as you know what kind of performance you care about.
16:48:25 <Cale> mm_freak: There are lots of good tools to determine where performance problems are located and sort out what's going wrong.
16:48:28 <sorear> mm_freak: isqrt(n)! is HUGE, it has O(sqrt(n)) digits
16:48:59 <Cale> sorear: but mod n, it won't.
16:48:59 <mm_freak> sorear: of course, but the factorization algorithm i mentioned is equivalent to trial division, just that the runtime solely depends on the size of n
16:49:04 <Excedrin> SamB: then OCaml or SML would fill the bill, right?
16:49:31 <mm_freak> and it was far slower than trial division in C, even without a wheel or other optimizations
16:49:51 <sorear> how big is n?
16:49:58 <Pseudonym> So this is exactly the kind of caring about performance you should do: Use a better algorithm.
16:50:01 <Cale> mm_freak: It takes a while to be able to look at code and "see" whether it is going to be fast or not.
16:50:15 <mm_freak> sorear: the haskell version was praktical for numbers of about 24 bits
16:50:22 <Pseudonym> Good heavens./
16:50:29 <Pseudonym> 24 bits?!
16:50:38 <mm_freak> i mean 48 bits (24 bits prime factors)
16:50:54 <hpaste>  opeth pasted "opeth" at http://hpaste.org/1518
16:50:57 <Pseudonym> And how many primes of 24 bits or smaller are there?
16:51:17 <mm_freak> where the C version is practical for numbers of up to 64 bits and more
16:51:25 <sorear> Pseudonym: 1077871
16:51:57 <Cale> I concur with that count :)
16:53:12 <mm_freak> pseudonym: if i implemented the quadratic sieve (the best known algorithm for numbers of less than 110 digits), it would still be _much_ slower than the C version
16:53:25 <sorear> mm_freak: You could just use C
16:53:50 <mm_freak> sorear: i know, but somehow haskell should be able to produce equally fast code (or even faster)
16:53:54 <Pseudonym> mm_freak: I agree.
16:54:10 <Pseudonym> mm_freak: You can try my Bernstein sieve if you like.
16:54:23 <SamB> now if only I could figure out JHC's primitive types
16:54:45 <Excedrin> Pseudonym: how fast is it relative to the C?
16:54:53 <Pseudonym> I didn't implement it in C.
16:55:00 <Excedrin> yes, but DJB did
16:55:07 <oerjan> > length (nubBy(((>1).).gcd)[2..2^24-1])
16:55:16 <Pseudonym> His number theory code is probably much better than mine. :-)
16:55:19 <lambdabot> Terminated
16:55:27 <Pseudonym> > log (2^24)
16:55:29 <lambdabot>  16.635532333438686
16:55:36 <Pseudonym> > 2^24 / log (2^24)
16:55:38 <lambdabot>  1008516.9301301239
16:55:42 <Pseudonym> Not bad.
16:55:42 <sorear> mm_freak: Haskell doesn't outperform C on computers designed to run C.  Maybe someday we'll have better computers.
16:55:44 <oerjan> bit optimistic there
16:56:11 <mm_freak> sorear: true  but probably such computers will never be built
16:56:13 <sorear> I had the answer in seconds using the power of unix pipelines
16:56:18 <sorear> stefan@stefans:/usr/local/src/jhc/test$ primes 1 16777216 | wc -l
16:56:18 <sorear> 1077871
16:56:39 <sorear> 'bsdgames' is such a misnamed package :)
16:56:49 <Pseudonym> Still, that's only 4Mb space.
16:56:51 <Cale> There are 4.2 * 10^17 +- 3 * 10^16 primes less than 2^64
16:56:52 <chessguy> @bot
16:56:52 <lambdabot> :)
16:57:18 <mm_freak> my only problem is recursion  it's just too difficult to express something recursively in a way that it gets translated into an iterative form
16:57:44 <Cale> mm_freak: Make it strict, and use tail recursion.
16:57:50 <notadev> yeah
16:58:09 <notadev> or help with the compiler :)
16:58:11 <Cale> (or foldl')
16:58:26 <SamB> Cale: that IS tail recursion
16:58:26 <notadev> hmm foldl and foldr look interesting
16:58:42 <Cale> SamB: yes, eventually.
16:58:47 <mm_freak> yes, i'm already doing this, and it just appears that the C version is even smaller and even easier to understand
16:58:54 <Cale> But only because foldl is implemented with tail recursion.
16:59:25 <mm_freak> (not using foldl' i mean)
17:00:08 <mm_freak> btw  is "fac n = product [1..n]" tail-recursive?
17:00:39 <Excedrin> that's not recursive
17:01:14 <mm_freak> excedrin: internally it is
17:01:15 <treble> mm_freak: Does your client automatically replace ... with an elipsis?
17:01:25 <mm_freak> treble: nope, i'm typing them manually
17:01:40 <Excedrin> @src product
17:01:40 <lambdabot> product = foldl (*) 1
17:01:44 <treble> mm_freak: ah, OK (I like it)
17:02:49 <mm_freak> treble: it's my  uhm  LaTeX-fetish =)
17:02:55 <notadev> @src foldl
17:02:55 <lambdabot> foldl f z xs = lgo z xs
17:02:55 <lambdabot>     where lgo z []     =  z
17:02:55 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
17:03:41 <Cale> foldl has a problem though, because it doesn't reduce the expression it builds up in that iterative loop
17:04:16 <mm_freak> yeah, foldl still needs recursion, AFAIK
17:04:16 <Excedrin> that's not the foldl from the report
17:04:19 <Cale> So you can easily end up consuming as much memory evaluating a foldl as it would have taken to completely evaluate the list.
17:04:36 <Cale> Yeah, that's the foldl from GHC.
17:04:52 <Cale> It has a hack in it which makes GHC compile it better.
17:05:25 <Cale> But for the basic idea, it's mostly equivalent to this:
17:05:29 <Cale> foldl f z [] = z
17:05:37 <Cale> foldl f z (x:xs) = foldl f (f z x) xs
17:06:04 <Cale> Let's just try evaluating a simple case of this:
17:06:05 <Excedrin> so, lambdabot's @src uses GHC's sources?
17:06:12 <Cale> Excedrin: sometimes
17:06:21 <Cale> foldl (+) 0 [1,2,3]
17:06:31 <Cale> = foldl (+) (0 + 1) [2,3]
17:06:38 <Cale> = foldl (+) ((0 + 1) + 2) [3]
17:06:44 <Cale> = foldl (+) (((0 + 1) + 2) + 3) []
17:06:50 <Cale> = ((0 + 1) + 2) + 3
17:06:55 <Cale> = (1 + 2) + 3
17:06:58 <Cale> = 3 + 3
17:07:00 <Cale> = 6
17:07:05 <Cale> That's how the evaluation goes.
17:07:08 <notadev> nice :)
17:07:15 <Cale> It's lazy, and so always reduces outermost first.
17:07:44 <Cale> Note that you can "easily" see here that it's going to consume O(n) memory.
17:07:58 <Cale> In that intermediate expression
17:08:02 <notadev> yeah
17:08:31 <Cale> So the variant foldl' is similar, but it forces the evaluation of the 'z' parameter before recursively calling itself.
17:08:36 <notadev> (+) 0 1 heh
17:08:40 <Excedrin> so, why doesn't product use foldl' ?
17:08:53 <Cale> Excedrin: historical reasons, mostly
17:09:31 <Cale> Also, there are cases where you can imagine wanting to be lazy in collapsing the expression.
17:09:44 <Cale> Though not for the predefined number types
17:10:29 <mm_freak> @src foldl'
17:10:30 <lambdabot> foldl' f a []     = a
17:10:30 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
17:10:39 * treble wonders if there aren't rewrite rules to use fold' for Ints
17:10:46 <mm_freak> is there any less esoteric syntax for this?
17:10:47 <notadev> what are backticks for?
17:10:53 <sorear> infix
17:10:57 <treble> turning a function into an operator
17:10:59 <Cale> notadev: turning any function into an infix operator
17:11:01 <sorear> > 12 `div` 3
17:11:03 <lambdabot>  4
17:11:04 <sorear> > div 12  3
17:11:06 <lambdabot>  4
17:11:07 <bos> shapr: your blog is borked
17:11:10 <sorear> @quote stereo
17:11:10 <notadev> ah ok thanks :)
17:11:10 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
17:11:16 <mm_freak> mod 5 3 = 5 `mod` 3
17:11:16 <notadev> hehe
17:11:27 <sorear> bos: 16:16 < sorear> shapr: ping
17:11:29 <Cale> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
17:11:31 <SamB> thhat actually wasn't stereo
17:11:43 <sorear> shapr: ping
17:11:49 <Cale> a' is defined as f a x, which is what the 'z' parameter is going to be for the next recursive call
17:12:01 <notadev> a prime
17:12:09 * dcoutts hacks on new Haskell syntax highlighting for gedit (gtksourceview-2.x)
17:12:18 <sorear> 15:30 < SyntaxNinja> who is trreble
17:12:18 <sorear> 15:30 < shapr> SyntaxNinja: monochrom
17:12:19 <dcoutts> now with haddock markup highlighting :-)
17:12:24 <sorear> treble: ^^
17:12:30 <Cale> x `seq` y, when evaluated, will evaluate x (to determining the top-level constructor), and then return the result y.
17:12:48 <Cale> So it forces the evaluation of a'
17:12:54 <dcoutts> Cale: there's no 'and then' seq does not imply sequencing :-)
17:13:01 <Cale> and then returns  foldl' f a' xs
17:13:21 <Cale> dcoutts: I did say "when evaluated"
17:13:36 <Excedrin> why is seq named seq instead of 'evalThunk' or something?
17:13:41 <Excedrin> force
17:13:43 <Excedrin> I guess
17:13:50 <notadev> hmm
17:14:00 <dcoutts> Cale: hmm, ok, subtle :-)
17:14:07 <notadev> computation order is defined tho?
17:14:08 <Cale> It does actually sort of imply a sequential constraint on the order of evaluation.
17:14:30 <dcoutts> but that's what I mean, it doesn't
17:14:31 <Cale> notadev: Well, by the standard, Haskell is just 'non-strict'
17:14:50 <Cale> dcoutts: You can't tell if x is bottom or not without doing at least a little evaluation.
17:14:54 <notadev> hmm what does that mean?
17:14:58 <mm_freak> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs   -- but that's actually not tail-recursive, or am i missing something?
17:15:09 <dcoutts> Cale: it doesn't require x is evaluated before y, that's all I mean
17:15:11 <Cale> notadev: It means, basically, anything but innermost-first evaluation.
17:15:21 <SyntaxNinja> treble: you confuse me ;)
17:15:29 <SyntaxNinja> treble: I know glguy, were you also monochrom??
17:15:30 <notadev> hehe ok ty Cale :)
17:15:32 <Cale> Or to be more careful, any evaluation which results in the same semantics as outermost-first evaluation.
17:15:45 <SyntaxNinja> he says no heh
17:15:55 <Cale> dcoutts: ah, okay
17:15:58 <dcoutts> seq x y can evaluate y then x
17:16:02 <notadev> but i thought you could force it to evaluate non-lazily?
17:16:05 <treble> I can see SyntaxNinja's face from where I sit over my monitor
17:16:09 <Cale> y `seq` x `seq` y  :)
17:16:14 <SyntaxNinja> he's staring at me?!
17:16:26 <treble> wait, was monochrom brilliant?
17:16:32 <treble> I might have been that user... :)
17:16:38 <SyntaxNinja> treble pretends to listen to music with headphones on.
17:16:57 <Cale> dcoutts: oh, it can, but it can't actually result in any value before x has been evaluated
17:17:04 * treble doesn't like to be snuck up upon
17:17:08 <dcoutts> Cale: right
17:18:02 <Cale> But in practice, all it means is basically the simple operational idea I gave.
17:18:13 <Pseudonym> To get back to my earlier question, can anyone tell why the monomorphism restriction applies to that definition?
17:18:19 <Cale> Even though strictly speaking it doesn't have to conform precisely to that.
17:18:21 <Pseudonym> :t (show ?something) :: (?something :: (forall m. (Show m) => m)) => String
17:18:30 <lambdabot>     Cannot match a monotype with `forall m. (Show m) => m'
17:18:30 <lambdabot>       Expected type: forall m. (Show m) => m
17:18:31 <Pseudonym> That one.
17:18:33 <mm_freak> cale: are you a GHC developer or something?
17:18:37 <Cale> mm_freak: nope
17:18:51 <Cale> mm_freak: I've been using Haskell for a few years though.
17:19:10 <Cale> mm_freak: Including for paid work :)
17:19:18 <mm_freak> k =)
17:20:17 <Cale> Should I evaluate an example with foldl' step-by-step?
17:20:23 <treble> straw poll: how many people here have used Haskell for paid work?
17:21:12 <Cale> There are quite a few people who visit this channel that have, and do.
17:22:09 <mm_freak> too new to haskell yet
17:22:13 <Cale> mm_freak: One thing you should find out about if you're concerned with performance is the GHC profiler, because it's quite good.
17:22:40 <mm_freak> cale: yes, i've read a lot about it, and i'll use it as soon as it comes to real applications
17:22:53 <Cale> Learning how to write reasonably efficient Haskell code is sort of like learning how to write reasonably efficient code in your first programming language was.
17:23:29 <Cale> Which is to say, it's completely new :)
17:23:37 <edwardk> treble: i have used it in testing the correctness of various process data flows in the real world
17:23:50 <Cale> The right model to adopt is often to think in terms of demand.
17:24:31 <oerjan> :t show ?question
17:24:34 <lambdabot> (?question::Integer) => String
17:24:35 <mm_freak> cale: yeah  and that's where haskell sucks IMO  if you write your code with performance in mind, then it gets pretty ugly pretty soon
17:24:40 <Cale> Somewhere in your program, some IO is going to cause demand for something to be printed, and that sets off a chain which heads down, looking for the top-level constructor of that thing, and then the next bit and the next bit and so on.
17:24:50 <Pseudonym> oerjan: As you can see, that defaults.
17:25:04 <oerjan> hm, Hugs gives show ?question :: (Show a, ?question :: a) => [Char]
17:25:08 <Cale> mm_freak: Not necessarily. It's just that your usual model for what looks "fast" no longer works at all.
17:25:14 <Pseudonym> Huh.
17:25:24 <Pseudonym> That sounds like it's worth filing a bug report.
17:25:32 <oerjan> :t map
17:25:34 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:25:37 <oerjan> :t show
17:25:39 <lambdabot> forall a. (Show a) => a -> String
17:25:43 <treble> ?question is a dynamically scoped variable
17:25:43 <lambdabot> Unknown command, try @list
17:25:46 <Pseudonym> You can do this:
17:26:04 <Cale> mm_freak: and so you can't trust that, you have to actually look at the profiler, or use Debug.Trace or do the calculations by hand for a while before you get any sense of how things are chugging along.
17:26:04 <edwardk> cale: well, a lot of the current hacks to get speed involve not using a lot of the nice abstractions haskel gives you and sprinkling seqs and !'s all over the place, you have to admit that that approach to optimization does leave something to be desired in terms of abstraction and cleanliness
17:26:08 <treble> ?type show ?question
17:26:10 <lambdabot> (?question::Integer) => String
17:26:14 <Pseudonym> :t (\_ -> show ?something) :: (Show m, ?something :: m) => m -> String
17:26:17 <lambdabot> (Show m, ?something :: m) => m -> String :: forall m. (?something::m, Show m) => m -> String
17:26:20 <Pseudonym> But not this:
17:26:21 <Cale> edwardk: Oh, in the contests, you mean :)
17:26:36 <Pseudonym> :t (show ?something) :: (Show m, ?something :: m) => String
17:26:38 <lambdabot>     Ambiguous constraint `Show m'
17:26:38 <lambdabot>         At least one of the forall'd type variables mentioned by the constraint
17:26:44 <Cale> edwardk: I'm not really talking about getting insane performance, but reasonable performance, which is usually far more attainable.
17:26:47 <Pseudonym> I suspect that's the real "bug" here.
17:27:08 <Pseudonym> That it's okay if the forall'd type variables are mentioned in implicit arguments.
17:27:28 <Cale> In the contests, people are generally willing to give up some more readability if it'll get things to run faster than C :)
17:27:35 <edwardk> cale: sure, it just troubles me that there is such a gap. I do like things like robert ennals' optimistic evaluator that try to close the gap for naive code
17:27:47 <Cale> Data.ByteString helps quite a lot.
17:27:49 * notadev votes for the walkthru of foldl' Cale :)
17:27:58 <greenrd> Why is fix thus called?
17:28:02 * sorear wishes people would learn to not care
17:28:11 <sorear> greenrd: it computes least fix points
17:28:16 <Cale> greenrd: it computes the "least fixed point" of the function it's given
17:28:22 <edwardk> robin: it computes the fixpoint of the function. a fixpoint is basically when x = f x
17:28:23 <Cale> "least" in the sense of "least-defined"
17:28:32 <Cale> foldl' (+) 0 [1,2,3]
17:28:33 <sorear> greenrd: fix f  returns the smallest value a such that f a = a
17:28:37 <greenrd> Can it be used to find the fix point of a rewriting system without using ==?
17:28:51 * notadev applauds ;)
17:28:53 <Cale> = let a = 0 + 1 in a `seq` foldl' (+) a [2,3]
17:29:04 <Cale> = foldl' (+) 1 [2,3]
17:29:17 <Cale> = let a = 1 + 2 in a `seq` foldl' (+) a [3]
17:29:25 <notadev> hmm
17:29:26 <Cale> = foldl' (+) 3 [3]
17:29:40 <Cale> = let a = 3 + 3 in a `seq` foldl' (+) a []
17:29:48 <Cale> = 6
17:29:57 <Cale> Perhaps I'm skipping too many steps?
17:30:01 <greenrd> because that's the kind of thing I think of when I hear "fixed point"
17:30:17 <edwardk> robin: you can probably abuse it to get there
17:30:35 <notadev> no that's cool Cale ty
17:30:36 <greenrd> to be more concrete: I want to repeatedly apply a substitution function to a list until the list stops changing
17:30:57 <notadev> it seems to be opposite eval order
17:31:06 <edwardk> @type iterate
17:31:09 <lambdabot> forall a. (a -> a) -> a -> [a]
17:31:12 <Cale> notadev: So the compiler turns this into a nice loop.
17:31:24 <notadev> hehe nice one! :D
17:31:36 <Cale> (with the expression evaluation *inside* the loop, rather than after)
17:31:42 <notadev> yeah
17:31:44 <greenrd> but I suppose I have to use (==) in this case
17:31:58 <greenrd> but how does fix do its job without using (==)?
17:32:02 <edwardk> then you can fold over there with == comparison of the last element to the next
17:32:14 <edwardk> @src fix
17:32:14 <lambdabot> fix f = let x = f x in x
17:32:28 <Saizan> or fix f = f (fix f)
17:32:35 <Cale> greenrd: by only working when the function is such that it produces some of the resulting structure on each iteration, never to be touched again
17:32:49 <edwardk> it feeds the answer of the function back to itself as its argument recursively and leans on laziness
17:33:10 <Cale> Note, the evaluation is outermost-first, which is why that definition is even meaningful.
17:33:24 <edwardk> > fix (1:)
17:33:26 <Cale> (or at least, not strict)
17:33:26 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:33:50 <edwardk> since that function defines the outermost constructor, the resulting fixed point is 'productive'
17:33:59 <edwardk> as opposed to say
17:34:00 <Cale> > fix (\f n -> if n == 0 then 1 else n * f (n-1)) 5
17:34:02 <lambdabot>  120
17:34:03 <edwardk> > fix (+1)
17:34:05 <lambdabot>  Exception: <<loop>>
17:34:08 <edwardk> which isn't productive
17:35:54 <edwardk> in general if you have a function that generates a constructor 'on the outside' in a bounded amount of time and then does something with its argument possibly involving itself to generate the parameters to that constructor, then the fixed point will be productive and you have a meaningful use of 'fix'
17:35:58 <Cale> > fix (\f n -> if even n then n : f (n+1) else f (n+1)) 0
17:36:00 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
17:37:02 <Cale> > fix ((0:) . scanl (+) 1)
17:37:04 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
17:37:45 * SamB stares at some ultra-pretty-printed E and wonders if he got the translation for foreign import "dynamic" right yet
17:39:38 <chessguy> man, i don't know why i can't come up with this. it's gotta be easy. suppose you number the squares of a {chess,checkers} board from 0 to 63 (0 in the bottom left corner, 7 in the bottom right, 63 in the top right, for example). how would you write a function to get all the numbers on a ray from a given square in a given direction
17:39:49 <chessguy> that stops at the edge of the board
17:40:39 <SamB> all the numbers?
17:41:23 <Cale> chessguy: first write down the function which takes a number and gives the (x,y) coordinates and vice versa
17:41:37 <chessguy> yes, so f 0 UP-RIGHT = [9,18,27,36,45,54,63]
17:41:50 <greenrd> Cale: What do you mean by least-defined?
17:41:52 <notadev> ew
17:42:00 <SamB> well, a direction would be one of [-9,-8,-7,-1,1,7,8,9]
17:42:11 <chessguy> SamB, right
17:42:13 <TSC> Do you want to handle directions that aren't 45 degrees angles?
17:42:20 <chessguy> TSC, no
17:42:25 <SamB> I'm not sure how you detect wraparound from left to right though :-(
17:42:25 <chessguy> err
17:42:32 <notadev> hehe
17:42:36 <chessguy> i want to handle all the cases SamB just gave
17:42:36 <edwardk> chessguy: then go and treat directions as ({+1,0,1},{+1,0,1}) \ (0,0), then just iterate adding the direction to the point until the point falls off the board, then map coordinates back to values
17:42:50 <notadev> yup
17:43:00 * SamB wonders if there's a faster way
17:43:15 <edwardk> samb: sure there is
17:43:22 <notadev> it's not exactly a lot of computations
17:43:52 <chessguy> edwardk, i don't get your notation
17:43:58 <chessguy> @hoogle \
17:43:58 <lambdabot> Hoogle Error: Parse Error: Unexpected character '\'
17:43:59 <SamB> maybe if you numbered squares from 0..119
17:44:05 <chessguy> @hoogle (\)
17:44:06 <lambdabot> Did you mean: (\)
17:44:06 <lambdabot> Prelude.undefined :: a
17:44:06 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
17:44:08 <SamB> well.
17:44:11 <SamB> take out the ...
17:44:36 <TSC> chessguy: Each direction is something like (1,0) or (-1,1)
17:44:37 <edwardk> you have 8 directions, they are the offsets in 2d coordinates +/- 1 or 0, but except when the pair is both 0
17:44:43 <chessguy> samB, you mean 127, not 119
17:44:56 <chessguy> oh
17:44:57 <Cale> greenrd: Well, Haskell values of any given type form what is called in mathematics a directed complete partial order. The relation is roughly that one value is less than another if it can be obtained from the other by replacing some parts of the structure with _|_ (bottom, the undefined value)
17:45:24 <SamB> -- it would be concat [[0+n..7+n] | [0,8..112]]
17:46:10 <Cale> You can imagine that what fix is doing is that it's starting out with _|_ and forming the infinite sequence of values { _|_, f _|_, f (f _|_), f (f (f _|_)), ... }
17:46:44 <SamB> probably it's better to do what edwardk said though at least for now...
17:46:58 <Cale> and taking the supremum of that sequence (which can be shown to exist for definable functions f)
17:47:20 <greenrd> I see
17:47:23 <greenrd> @type fix
17:47:25 <lambdabot> forall a. (a -> a) -> a
17:47:28 <Cale> As f is applied repeatedly, some parts of the structure might get set in stone.
17:47:54 <Cale> and fix is going to produce the thing which results from continuing that process forever
17:49:08 <chessguy> @pl \(v,w) (x,y) -> (v+x,w+y)
17:49:08 <Cale> Hehe, there's something deeply religious about least fixed points. I think it has something to do with that "(A implies A) implies A" form of reasoning :)
17:49:08 <SamB> ah, cool
17:49:09 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
17:49:26 <SamB> I did finally manage it
17:51:30 <Cale> Seems mysterious until you realise that you might just get an undefined value in the end.
17:52:11 <Cale> Er, oh, heh, I said something very untrue.
17:52:24 <SamB> sweet, I have hell.hs compiling with JHC ;-)
17:52:40 <Cale> ... and taking the supremum of that sequence, which can be shown to exist for *continuous* functions f
17:53:22 <dons> Cale: we really should move the comonad page from the old hawiki
17:53:25 <dons> 1http://programming.reddit.com/info/231c9/comments
17:53:27 <lambdabot> Title: Comonads in Haskell (reddit.com)
17:53:32 <greenrd> @type  (\f n -> if n == 0 then 1 else n * f (n-1))
17:53:34 <lambdabot> forall a. (Num a) => (a -> a) -> a -> a
17:54:00 <dons> and take the .ee comonad library, and stick it on hackage.
17:54:49 <dons> Cale: http://www.eyrie.org/~zednenem/2004/hsce/
17:55:22 <greenrd> > fix (\x -> if x == 0 then 0 else x - 1) 10
17:55:23 <lambdabot>   add an instance declaration for (Num (t -> a))
17:55:23 <lambdabot>     In the expression: if x ...
17:55:28 <dons>  i think there's another comonad lib out there somewhere too
17:55:36 <dons> sigfpe linked to it
17:55:44 <chessguy> @pl \x y -> (x + 1, y)
17:55:44 <lambdabot> (,) . (1 +)
17:55:49 <greenrd> @type  (\x -> if x == 0 then 0 else x - 1)
17:55:52 <lambdabot> forall a. (Num a) => a -> a
17:56:08 <chessguy> @pl \x y -> (x - 1, y)
17:56:08 <lambdabot> (,) . subtract 1
17:56:09 <dons> can anyone work out what's in this photo: http://dev.laptop.org/~cjb/xmonad.jpg  :)
17:56:27 <chessguy> @pl \x y -> (x , y+1)
17:56:27 <lambdabot> (. (1 +)) . (,)
17:56:54 <Pseudonym> dons: Woah.
17:57:03 <bos> nice!
17:57:06 <Pseudonym> GHC runs on the OLPC?
17:57:12 <bos> one ghc per child!
17:57:14 <chessguy> that is some ugly green
17:57:17 <greenrd> so, obviously I can't apply fix to *any* function to get its least fixed point
17:57:28 <Pseudonym> I really want me one of those OLPCs.
17:57:32 <Cale> hehe, nice
17:57:42 <dons> i'm not sure if ghc runs on OLPC, but xmonad/haskell progs certainly do
17:57:53 <Pseudonym> They look so practical.
17:58:04 <SamB> greenrd: sure you can
17:58:12 <SamB> greenrd: if it has one
17:58:29 <sorear> EVERY function has a least fixed point.
17:58:40 <greenrd> > fix (\x -> if x == 0 then 0 else x - 1)
17:58:41 <lambdabot>  Exception: <<loop>>
17:58:51 <SamB> sorear: every function
17:58:52 <SamB> ?
17:58:54 <sorear> It's a result in the elementary theory of continuous partial orders.
17:59:01 <sorear> SamB: Yup, every function.
17:59:02 <greenrd> I think the least and only fixed point of that function is 0
17:59:09 <sorear> greenrd: Nope, _|_ is smaller
17:59:15 <greenrd> ah ok
17:59:26 <SamB> sorear: so... what is the one for wordToInt# ?
17:59:37 <hpaste>  nader_ph pasted "nader_ph" at http://hpaste.org/1519
18:00:41 <SamB> > fix chr
18:00:42 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
18:00:51 <greenrd> > fix id
18:00:52 <lambdabot>  Exception: <<loop>>
18:01:08 <oerjan> @instances-importing Control.Applicative Applicative
18:01:09 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
18:01:17 <Pseudonym> More correctly, every endofunction has a fixed point.
18:01:39 <Pseudonym> > fix Data.Char.chr
18:01:40 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
18:01:42 <Pseudonym> See?
18:02:11 <SamB> Pseudonym: ah, yes, I think I meant "if it is an endofunction"
18:03:36 <SamB> now if only JHC would generate better code for hell.hs :-(
18:03:53 <sorear> What does Hell.hs do?
18:03:54 <Pseudonym> If only hell were more efficient!
18:04:02 <edwardk> @paste
18:04:02 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:04:19 <hpaste>  edwardk pasted "for chessguy" at http://hpaste.org/1520
18:04:37 <hpaste>  SamB pasted "hell.hs" at http://hpaste.org/1521
18:04:46 <Binkley> ?remember Pseudonym If only hell were more efficient!
18:04:47 <lambdabot> Done.
18:05:53 <dons> new alpheccar post  http://programming.reddit.com/info/231fb/comments
18:05:54 <lambdabot> Title: Category Theory and Haskell: Algebras and Monads (reddit.com)
18:05:57 <Pseudonym> I leave it as an exercise as to whether I was referring to Gehenna, Tartarus or Hades.
18:06:07 <greenrd> @type \f -> head . head . dropWhile ((h1:(h2:_)) -> h1 != h2) . tails . iterate f
18:06:09 <lambdabot> parse error on input `->'
18:06:19 <greenrd> @type \f -> head . head . dropWhile (\(h1:(h2:_)) -> h1 != h2) . tails . iterate f
18:06:21 <lambdabot> Not in scope: `!='
18:06:21 <edwardk> dons the link doesn't seem to work on that post, hrmm
18:06:26 <greenrd> @type \f -> head . head . dropWhile (\(h1:(h2:_)) -> h1 /= h2) . tails . iterate f
18:06:28 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> a
18:06:32 <edwardk> i put off the # and it worked for me though
18:06:39 <greenrd> I think that's what I was looking for
18:06:49 <dons> edwardk: just slow?
18:07:26 <edwardk> strange now it works, maybe something intermittent on his server
18:07:51 <Pseudonym> @quote hell
18:07:51 <lambdabot> Pseudonym says: If only hell were more efficient!
18:14:03 <Binkley> ?quote
18:14:04 <lambdabot> pzpz says:  i can't see how anyone can use a laptop without the nipple
18:17:22 <SamB> anyway, for some reason JHC's output for hell.hs contains a bunch of cons nodes :-(
18:17:39 * Sgeo wonders if his pun ever appeared on the humor page
18:17:47 <SamB> Sgeo: what was it?
18:18:13 <Sgeo> "What did Goldilocks say upon seeing 'Maybe (b -> Either a b)'?"
18:18:37 <TSC> Nothing?
18:18:55 <oerjan> "Just Right"
18:18:56 <Sgeo> It's Just Right!
18:19:04 <Botje> but Just Right *WHAT* !
18:19:08 <Binkley> lololol
18:19:25 <SamB> :t Just Right
18:19:27 <lambdabot> forall b a. Maybe (b -> Either a b)
18:19:43 <Pseudonym> @djinn Maybe (b -> Either a b)
18:19:44 <lambdabot> f = Nothing
18:19:49 <Sgeo> afk
18:19:50 <SamB> hah
18:20:03 * SamB wonders if djinn can be iterated
18:20:04 <Pseudonym> @djinn a -> Either a b
18:20:04 <lambdabot> f = Left
18:20:15 <Pseudonym> @djinn b -> Either a b
18:20:15 <lambdabot> f = Right
18:20:19 <Pseudonym> OK, that works.
18:20:34 <SamB> @djinn a -> Maybe a
18:20:35 <lambdabot> f = Just
18:20:37 <SamB> huh
18:20:39 <SamB> that works too
18:23:13 <TSC> @. pl djinn b -> Maybe (Either a b)
18:23:14 <lambdabot> f = Just . Right
18:25:03 <oerjan> In #haskell even the puns are higher order.
18:25:15 <Binkley> puns are always of a low order
18:25:40 <TSC> My puns are well-ordered
18:27:58 <dibblego> concatMap is to >>= as map is to fmap as filter, foldr and foldl' are to?
18:28:41 <dibblego> ?hoogle (a -> Bool) -> f a -> fb
18:28:41 <lambdabot> Did you mean: (a -> Bool) -> f a -> Fb
18:28:45 <dibblego> ?hoogle (a -> Bool) -> f a -> f b
18:28:46 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
18:29:06 <TSC> f a, not f b
18:29:20 <dibblego> of course :)
18:29:22 <dibblego> ?hoogle (a -> Bool) -> f a -> f a
18:29:23 <SamB> hmm. djinn isn't very good with typeclasses...
18:29:23 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
18:29:30 <Cale> dibblego: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Foldable.html
18:29:32 <lambdabot> http://tinyurl.com/2xwe3t
18:29:52 <dibblego> ah thanks
18:29:56 <dibblego> is there one for filter?
18:29:58 <dibblego> ?hoogle Filterable
18:29:59 <lambdabot> No matches found
18:30:17 <Binkley> well, you can define filter in terms of fold
18:30:33 <oerjan> :t \f l -> do x <- l; guard (f x); return x
18:30:38 <lambdabot> forall (t :: * -> *) t1. (MonadPlus t) => (t1 -> Bool) -> t t1 -> t t1
18:30:38 <Cale> and there's filterM, but that's not quite the same
18:30:39 <dibblego> yeah righto
18:30:45 <dibblego> ?type filterM
18:30:47 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
18:31:27 <dibblego> thanks again
18:32:07 <SamB> Djinn> :set +multi
18:32:07 <SamB> Djinn> f ? Maybe (b -> Either a b)
18:32:07 <SamB> f :: Maybe (b -> Either a b)
18:32:07 <SamB> f = Nothing
18:32:08 <SamB> -- or
18:32:10 <SamB> f = Just Right
18:32:59 <oerjan> @undo \f l -> do x <- l; guard (f x); return x
18:32:59 <lambdabot> \ f l -> l >>= \ x -> guard (f x) >> return x
18:33:21 <oerjan> @. pl undo \f l -> do x <- l; guard (f x); return x
18:33:22 <lambdabot> (=<<) . (`ap` return) . (((>>) . guard) .)
18:33:44 <oerjan> @. pl \f l -> do x <- l; guard (f x); return x
18:33:45 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "\\f"
18:33:51 <oerjan> @pl \f l -> do x <- l; guard (f x); return x
18:33:51 <lambdabot> (line 1, column 18):
18:33:51 <lambdabot> unexpected ";"
18:33:51 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
18:36:45 <shachaf> @. pl undo \f l -> do x <- l; guard (f x); return x
18:36:45 <lambdabot> (=<<) . (`ap` return) . (((>>) . guard) .)
18:41:34 <Binkley> ?quote
18:41:34 <lambdabot> JohnPeterson says: [1991] `Miranda' is a trademark of Research Software Ltd. `Haskell' is not a trademark of anyone.
18:42:53 <SamB_XP> I thought haskell was a trademark of Haskell.org or something ;-)
18:46:51 <dibblego> how do you write filter in terms of foldr?
18:48:30 <oerjan> \f l -> foldr (\x l -> if f x then x:l else l) [] l)
18:49:36 <oerjan> > (\f l -> foldr (\x l -> if f x then x:l else l) [] l)) even [1..10]
18:49:36 <lambdabot>  Parse error
18:49:49 <dibblego> > (\f l -> foldr (\x l -> if f x then x:l else l) [] l) even [1..10]
18:49:51 <lambdabot>  [2,4,6,8,10]
18:49:53 <oerjan> > (\f l -> foldr (\x l -> if f x then x:l else l) [] l) even [1..10]
18:49:54 <lambdabot>  [2,4,6,8,10]
18:50:20 <oerjan> @pl \f l -> foldr (\x l -> if f x then x:l else l) [] l
18:50:20 <lambdabot> flip foldr [] . flip flip id . (ap .) . (`ap` (:)) . (((.) . if') .)
18:51:09 <oerjan> > (\f l -> foldr (\x -> if f x then (x:) else id) [] l) even [1..10]
18:51:11 <lambdabot>  [2,4,6,8,10]
18:51:31 <oerjan> @pl (\f l -> foldr (\x -> if f x then (x:) else id) [] l)
18:51:31 <lambdabot> flip foldr [] . flip flip id . (`ap` (:)) . (if' .)
18:56:10 <Binkley> ?quote
18:56:10 <lambdabot> #perl says: <tech> who needs saneness
19:02:49 <dons> heya ekidd
19:03:00 <dons> ?users
19:03:00 <lambdabot> Maximum users seen in #haskell: 354, currently: 304 (85.9%), active: 7 (2.3%)
19:03:19 <ekidd> dons: Hello!
19:03:19 <MarcWeber> Which is the way to tell ghci/yi to find glib-2.0.so ? It's located in /usr/lib
19:03:49 <dons> MarcWeber: hmm, depends on which glib it was linked with , originally?
19:04:22 <dons> ekidd: so i had a weird dream last night that you and dpiponi had to write papers on comonads for the haskell workshop. and the bloggers took over. very strange.
19:04:45 <MarcWeber> dons: ./configure; make; sudo make install ;-) ..
19:04:46 <ekidd> Heh. :-)
19:05:10 <ekidd> I haven't written any comonad posts yet. Maybe I should. ;-)
19:05:14 <dons> hehe
19:05:32 <dons> i want Control.Comonad and Control.Delimited writte (if nec.) and on hackage
19:05:36 <dons> so i've got some new toys to play with
19:05:43 <dons> applicative functors are so '06.
19:05:59 <Binkley> ?remember dons applicative functors are so '06.
19:05:59 <lambdabot> Done.
19:06:37 <dons> this season its all delimited continuations, and khaki, i predict.
19:07:00 <ekidd> dons: I'm especially amused by Chun-chieh Shan's list of as-yet-unwritten papers: http://conway.rutgers.edu/~ccshan/wiki/blog/posts/Paper_titles/
19:07:01 <lambdabot> Title: Paper titles
19:07:08 <edwardk> I'd particularly like a Control.Comonad
19:07:14 <Pseudonym> I currently have a real problem that I suspect only implicit configuration would solve.
19:07:19 <Pseudonym> Or using Hugs in stead of GHC.
19:07:25 <Pseudonym> As the previous conversation noted. :-)
19:07:40 <Pseudonym> It's prolly a bug in GHC.
19:07:55 <ekidd> dons: The fact that I find that hilarious may have to do with blowing several mental fuses on that last paper.
19:08:11 <dons> ekidd: hehe.
19:08:20 <dons> `Intensions of murder' is a cool title
19:09:34 <Excedrin> why aren't things in Num also in Monad?
19:10:25 <Binkley> numbers are a monad?
19:10:28 <Binkley> childhood just ended for me
19:10:32 <dons> sounds scary, Excedrin
19:10:40 <dons> http://programming.reddit.com/info/231v0/comments
19:10:41 <lambdabot> Title: Scope herding with delimited continuations (reddit.com)
19:10:50 <dons> i really should go through the old tmoertel posts , from the pre-reddit days
19:10:57 <dons> i think they're not widely read.
19:11:32 <Excedrin> what's GIML?
19:11:34 <Pseudonym> The phrase "the pre-reddit days" disturbs me for some reason.
19:11:55 <Pseudonym> "I was into tmoertel BEFORE he sold out."
19:12:10 <Binkley> I like tmoertel's earlier stuff better
19:15:04 <dons> Pseudonym: well "before we blog aggregator for haskell stuff"
19:15:19 <SamB_XP> what?
19:15:24 <dons> when it was just oleg's do it yourself publishing :)
19:15:31 <SamB_XP> before http://sequence.complete.org ?
19:15:33 <lambdabot> Title: The Haskell Sequence | News about Haskell
19:15:49 <dons> SamB_XP: that's very new, my young friend :)
19:16:00 <dons> circa August 05.
19:16:27 <SamB_XP> I'm just struggling to see how it would reduce quality in any way...
19:16:31 <Pseudonym> As opposed to applicative functors?
19:16:52 <Pseudonym> Or are applicative functors merely passe, but The Haskell Sequence are kitschy retro?
19:16:54 <Binkley> applicative functors were there all along, they just hadn't been discovered
19:17:29 <Pseudonym> Yeah, they just needed a record deal.
19:17:30 <SamB_XP> oh, has everyone heard JohnMeacham's complaints?
19:17:33 <dons> you know you're working on haskell, when to categorise a blog post, you need to use the term "data and control structures"
19:17:40 <sorear> SamB_XP: No.
19:17:41 <SamB_XP> he is dissatisfied with FunctorM's replacement...
19:17:42 <Pseudonym> I've heard many of his complaints for many years no.
19:17:42 <Pseudonym> now
19:18:00 <Pseudonym> But we tolerate them because he writes good code.
19:18:13 <SamB_XP> (replacements?)
19:18:20 <sorear> SamB_XP: I'm subscribed to 3/4 or so of the haskell mailing lists, including ghu, ghb, libs, cafe, -ell, and jhc.
19:18:32 <SamB_XP> sorear: libraries@?
19:18:34 <sorear> SamB_XP: I haven't heard the full version of his complaint
19:18:38 <sorear> SamB_XP: yes
19:18:50 <chessguy> -ell?
19:18:57 <sorear> hask
19:19:09 <chessguy> strange abbreviation
19:19:22 <Binkley> it's like abbreviating pizza as 'za
19:19:48 <SamB_XP> @tell JohnMeacham to complain properly
19:19:48 <lambdabot> Consider it noted.
19:19:51 <Pseudonym> BBL
19:20:47 <SamB_XP> anyway, he says that the proposed replacements for FunctorM actually don't let Frisby do what it needs to do
19:21:43 <SamB_XP> he muttered something about not (a) having methods that really only make sense for Monads and (b) not having enough methods for things that make sense for non-monads
19:30:14 <MarcWeber> dons: Ah. I had to add /usr/lib to the library-dirs ;)
19:38:08 <dons> another good early tmoertel piece, http://programming.reddit.com/info/2321q/comments
19:38:10 <lambdabot> Title: Power parsing with Haskell and Parsec (reddit.com)
19:38:32 <dons> dons rule #7: everyone writes about parsec, in the limit.
19:42:26 <edwardk> the replacements being Foldable and Traversable?
19:43:10 <edwardk> @type fmapM
19:43:17 <edwardk> @type forM
19:43:19 <lambdabot> Not in scope: `fmapM'
19:43:21 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
19:43:34 <edwardk> @type Data.Traversable.forM
19:43:36 <lambdabot> forall (t :: * -> *) a (m :: * -> *) b. (Monad m, Data.Traversable.Traversable t) => t a -> (a -> m b) -> m (t b)
19:43:53 <edwardk> @type Data.FunctorM.fmapM
19:43:55 <lambdabot> forall a (m :: * -> *) b (f :: * -> *). (Data.FunctorM.FunctorM f, Monad m) => (a -> m b) -> f a -> m (f b)
19:44:07 <chessguy> edwardk++ nice code
19:44:14 <edwardk> chessguy thanks
19:46:05 <edwardk> i'd originally wanted to have the delta function return a pair of functions (Int -> Int, Int -> Int) but the syntax lost its symmetry because of the fact that (-1) is a special case, not a subtraction section =)
19:46:39 <chessguy> @type pos
19:46:43 <lambdabot> Not in scope: `pos'
19:46:49 <edwardk> chessguy 5th line =)
19:46:55 <chessguy> oh, right
19:47:04 <edwardk> pos (y,x) = if p >= 0 && p <= 63 then Just p else Nothing where p = y*8+x
19:47:24 <chessguy> @pl ray d p = map fromJust $ takeWhile isJust $ map pos $ iterate (move d) (coord p)
19:47:24 <lambdabot> ray = ((map fromJust . takeWhile isJust . map pos) .) . (. coord) . iterate . move
19:47:35 <edwardk> pointfree doesn't do much for that =)
19:47:37 <chessguy> lol
19:47:43 <dons> another good one, http://programming.reddit.com/info/2324s/comments
19:47:44 <lambdabot> Title: The supermarket pricing puzzle in Haskell (reddit.com)
19:49:07 <chessguy> edwardk, i totally don't get how haskell can evaluate that move function
19:49:52 <edwardk> move d (x,y) = (x + dx, y + dy) where (dx,dy) = delta d   ? or the ray function?
19:50:07 <edwardk> is it the translation of the 'where'?
19:50:38 <chessguy> edwardk, yes, that function. i understand what it means, but i don't know how haskell evaluates it
19:50:42 <edwardk> move d (x,y) = let (dx,dy) = delta d in (x + dx, y + dy)
19:51:04 <chessguy> oh
19:51:10 <chessguy> duh
19:51:23 <chessguy> ok, not so hard
19:51:25 <edwardk> where kind of shuffles everything around into a magical let block that is in scope early enough for guard evaluation
19:52:01 <edwardk> the pos stuff is probably wrong on reflection actually
19:52:07 <edwardk> i just realized i missed a case
19:52:42 <edwardk> pos (y,x) = if y >= 0 && y <= 7 && x >= 0 && x <= 7 then Just p else Nothing where p = y*8+x
19:52:59 <edwardk> and since i removed references to p you can just compute p in the Just
19:53:19 <edwardk> pos (y,x) = if y >= 0 && y <= 7 && x >= 0 && x <= 7 then Just (y*8+x) else Nothing
19:54:14 <edwardk> maybe its cleaner as: pos (y,x) = if inRange (0,7) x && inRange (0,7) y then Just (y*8+x) else Nothing
19:56:27 <chessguy> cool. thanks again, i'll have to play with that some
19:56:34 <chessguy> i'm off to bed for now
19:56:41 <edwardk> night man
19:58:12 <MarcWeber> Mmh I had to add freetype and cairo lib as well. Now I'm getting invalid elf header (zlib) .. ;(
19:59:11 <sorear> You have the devfiles installed?
20:00:06 <MarcWeber> Not sure what you mean. I'll reemerge zlib and see wether this helps.
20:01:08 <sjanssen> MarcWeber: on Gentoo?
20:01:09 <sorear> I mean if you don't already you'll need the 'zlib-dev' or whatever it's called.
20:05:28 <dcoutts> gentoo doesn't split out -dev packages
20:07:21 <MarcWeber> didn'nt resolve the issue
20:07:35 <dcoutts> MarcWeber: what is it you're having trouble building ?
20:07:41 <dcoutts> yi? or gtk2hs?
20:08:16 <hpaste>  jasonman74 pasted "jasonman74" at http://hpaste.org/1522
20:09:00 <dcoutts> hah, is that our first proper hpaste spam?
20:09:01 <MarcWeber> dcoutts: ghci -package cairo
20:09:14 <sorear> dcoutts: Look at it :)
20:09:17 <sjanssen> dcoutts: it's been happening quite a bit lately
20:09:41 <dcoutts> I wonder if the spammers have gone to the trouble of automating it
20:09:45 <sjanssen> sorear: did you manually delete that one? (ie. is a spam filter up yet)
20:09:52 <dcoutts> obviously hpaste has hit the big time :-)
20:09:52 <sorear> Yes.
20:10:01 <dcoutts> MarcWeber: ah, ok and ghci complains about zlib ?
20:10:08 <MarcWeber> Exactly
20:10:34 <dcoutts> MarcWeber: that it doesn't exist or is corrupt?
20:10:35 <sorear> sjanssen: look at the logs.  treble can't fix hpaste because scannedinavian's happs is Too Weird
20:10:44 <sjanssen> :(
20:11:21 <MarcWeber> http://www.mail-archive.com/haskell-cafe@haskell.org/msg13293.html This did help resolving the issue I had once installing haskelldb.
20:11:22 <sjanssen> he can't install an updated version?
20:11:23 <lambdabot> Title: Re: [Haskell-cafe] hs-plugins/ haskelldb/ ELF zlib incompatibility., http://tinyurl.com/ys5r76
20:11:27 <MarcWeber> ghci output: http://rafb.net/p/gHfyJJ76.html
20:11:28 <lambdabot> Title: Nopaste - No description
20:11:41 <sorear> dons: SyntaxNinja tells me you're one who knows what community.h.o is for
20:11:46 <MarcWeber> dcoutts How to check wether its' corrupt?
20:12:02 <sorear> sjanssen: shapr is a core happs dev.  scannedinavian is shapr's box.
20:12:13 <MarcWeber> It lives happily in /usr/lib/libz.so
20:12:59 <sjanssen> sorear: yeah, I know this.  Perhaps he needs to install an older version? :P
20:13:11 <Saizan> hpaste-devel builds fine with the latest public HAppS, btw
20:13:44 <dcoutts> MarcWeber: ok, so it really isn't a .so file, take a look
20:13:44 <dcoutts> $ file /usr/lib/libz.so
20:13:44 <dcoutts> /usr/lib/libz.so: ASCII C program text
20:14:12 <SamB_XP> crazy gentoo system!
20:14:17 <MarcWeber> dcoutts. You are right. I did notice it now as well (using readelf -a)
20:14:22 <dcoutts> MarcWeber: it's one of those GNU ld scripts, so ghci cannot dlopen it
20:15:06 <MarcWeber> So I have to fix the order if paths to make it use /lib
20:15:07 <dcoutts> it's set up as an alias for /lib/libz.so:
20:15:38 <dcoutts> MarcWeber: I think the solution is to remove 'z' from the ghc package config for the cairo package
20:16:10 <dcoutts> I don't think we ever need to explicitly link to it, since it gets pulled in automagically
20:16:27 <MarcWeber> I had to add it. ghci was complaining anyway. Lets see
20:16:30 <dcoutts> we have a similar hack for the pthread lib which is a gnu ld script on most linux systems
20:16:49 <MarcWeber> putting /lib before /usr/lib did work
20:16:59 <MarcWeber> Now I still have to add libfontconfig ..
20:17:04 <dcoutts> libz.so is already a runtime dep of cairo, so we don't need to link to z directly anyway
20:17:47 <dcoutts> MarcWeber: hmm? could you report all the problems you've had, I can try and fix them for the upcomming release
20:17:54 <dcoutts> which should be in just a couple days
20:18:30 <dcoutts> on my gentoo system ghci -package cairo works fine, so you'll have to give me details
20:19:07 <SamB_XP> haven't you people heard of symlinks?
20:19:38 <dcoutts> SamB_XP: http://bugs.gentoo.org/show_bug.cgi?id=4411
20:19:40 <lambdabot> Title: Gentoo Bug 4411 - gcc 3.1 uses static libs in /usr/lib before it will use a dyna ...
20:21:16 <dcoutts> MarcWeber: why is it looking in /usr/lib first anyway? it should always look in /lib first
20:21:26 <MarcWeber> dcoutts: I can give you ssh access ;) Now it's complaning about freetype again? wt. . I've added this already.
20:21:55 <MarcWeber> Because I had to add this directory so that libglib-2.0 was found (package glib)
20:22:31 <dcoutts> MarcWeber: sounds like you've got some strange setup, do you have non-standard locations for glib or something ?
20:22:36 <MarcWeber> I'm using gcc 4.1.1 btw
20:22:48 <SamB_XP> perhaps GHC's loader isn't tracking dlopen's behaviour well? does it use dlopen at all?
20:23:02 <dcoutts> SamB_XP: yes, ghci uses dlopen
20:23:12 <dcoutts> MarcWeber: I'm using gcc 4.1.2
20:23:19 <SamB_XP> only for C libraries though?
20:23:25 <dcoutts> SamB_XP: right
20:23:33 <MarcWeber> I've a nix setup as well. But I don't think that those libs are taken by accident.
20:23:34 <SamB_XP> I still don't understand why that is
20:23:55 <dcoutts> MarcWeber: normally gtk2hs just works 'out of the box' as it were
20:24:06 <SamB_XP> why can't it ldopen haskell code too?
20:24:08 <dcoutts> MarcWeber: have you tried the gtk2hs ebuild ?
20:24:08 <SamB_XP> er.
20:24:10 <SamB_XP> dlopen
20:24:24 <dcoutts> SamB_XP: because they're not built as .so libs
20:24:37 <SamB_XP> hmm.
20:24:58 * SamB_XP does seem to remember that being needful when he was abusing dlopen() to reboot his WM
20:25:11 <dcoutts> MarcWeber: what I'd really like to know is what is going on, that makes it not "just work" on your box
20:26:29 <MarcWeber> dcoutts: I'll remove the add nix stuff from my bashrc and see wether the ebuild works..
20:26:47 <dcoutts> MarcWeber: so what I'd really appreciate is an email, either to me or the gtk2hs-devel list saying what goes wrong when you follow the ordinary build instructions, plus version details and your best guess as what's going wrong.
20:26:57 <dcoutts> but right now I've got to sleep :-)
20:27:32 <MarcWeber> fine..
20:28:23 <MarcWeber> If I had any guess about what's going wrong I would try to fix it ;)
20:31:13 <desrt> i have a very silly question that has absolutely nothing to do with haskell.  therefore, this seems like a fantastic place to ask:
20:31:25 <desrt> what is a (preferably short) english word that means "non-concrete type signature"?
20:32:21 <desrt> the best word i have so far is "pattern" but it's not really specific to types....
20:32:41 <desrt> so i end up with the rather ridiculous SignaturePattern
20:34:49 <Pseudonym> "Schema", IIRC.
20:34:59 <Pseudonym> Or "type schema".
20:35:01 <sorear> yeah, schema.
20:35:23 <desrt> hmm
20:35:32 <desrt> interesting suggestion.
20:35:43 <MarcWeber> polymorphic ? ..
20:37:49 <Excedrin> what's a non-concrete type?
20:37:57 <desrt> Excedrin; a type with variables
20:38:05 <Excedrin> oh, that
20:38:12 <desrt> like [a] vs. [Int]
20:38:36 <dons> 'type schema' is used, yeah.
20:38:42 <Excedrin> oh, that
20:38:46 <Excedrin> is that different from a higher order type
20:38:51 <dons> particularly wrt. unification algorithms.
20:39:31 <Pseudonym> I might add, that with higher-ranked types, the distinction is a bit fuzzier.
20:39:46 <desrt> hrmph.
20:39:49 <SamB_XP> how higher-ranked?
20:39:54 * desrt suspects that he abuses the term "Signature"
20:40:05 <SamB_XP> how does, say, a general type work?
20:40:21 <Pseudonym> [a] is a type schema, but forall a. [a] isn't.
20:40:24 <Pseudonym> Kinda.
20:40:29 <desrt> i have 3 concepts that i need to name
20:40:46 <desrt> 1: concrete type signatures like [Int], Int, (Double, String)
20:40:51 <Pseudonym> The idea behind a type schema running through the old literature uses the fact that all of the foralls are at the top level.
20:40:59 <desrt> 2: "basic types" like Int, List, Tuple
20:41:15 <desrt> 3: non-concrete types like [*], (*, Int), etc
20:41:18 <dons> anyone thinking about the ICFP contest?
20:41:22 <dons> add details here, http://haskell.org/haskellwiki/ICFP_Programming_Contest/Teams_2007
20:41:24 <desrt> so far i call #1 Signature and #2 Type
20:41:24 <lambdabot> Title: ICFP Programming Contest/Teams 2007 - HaskellWiki, http://tinyurl.com/3dx5mv
20:41:27 <dons> i see we're getting a few people together.
20:43:09 <hpaste>  L3051P pasted "L3051P" at http://hpaste.org/1523
20:43:53 <dons> so what's the plan to stop our spammer?
20:44:15 <Pseudonym> Application of a big hammer to the cranium.
20:44:38 <sorear> dons: we need to arrange for treble and shapr to be in #haskell at the same time
20:44:46 <SamB_XP> we could disallow posts with the nick and title fields the same?
20:44:55 <dons> sorear: yes, i think that might be it.
20:45:38 <Pseudonym> That assumes it's not them doing it!
20:46:24 <SamB_XP> Pseudonym: ...
20:46:57 <SamB_XP> why the heck would shapr of all people spam #haskell?
20:47:15 <dons> yes, i think its probably shapr
20:47:47 <Pseudonym> To consolidate his power, clearly.
20:48:05 <SamB_XP> if he wanted to do that wouldn't he have just kept ops to himself?
20:48:38 <Pseudonym> See, that's what he wants you to think.
20:49:12 <dons> SamB_XP: you've been fooled again. shapr's already in your base.
20:49:38 <SamB_XP> and how exactly is spamming the channel with meaningless pastes that get immediately deleted going to "consolidate power"
20:49:51 <SamB_XP> next you'll be telling me he's behind the spamfloods in #perl6
20:49:58 * desrt wonders if somebody is missing something or just taking it too far
20:50:00 <dons> if you have to ask, you'll never know.
20:50:05 <Pseudonym> No, that's Abigail.
20:50:09 <dons> heh
20:50:13 <Pseudonym> But a good guess.
20:50:14 <Saizan> by keeping us in a state of war! see 1984
20:50:38 <desrt> if it worked for bush it'll work for shapr
20:50:39 <SamB_XP> Saizan: but we don't seem to think that ugly == beautiful
20:50:41 <Pseudonym> See, shapr is planning to use the pending Haskell world domination to further his own evil ends.
20:50:48 <dons> its wedge politics. shapr steals power while we're stuck working out a response to the spam
20:51:02 <Saizan> SamB_XP: well, give it time..
20:51:04 <SamB_XP> what exactly kind of power is shapr stealing?
20:51:08 <Pseudonym> To stop the spam, we give shapr more power over haskell.org.
20:51:12 <Pseudonym> See?
20:51:17 <Excedrin> power of the timecube
20:51:26 <SamB_XP> but hpaste doesn't *run* on haskell.org does it?
20:51:27 <Excedrin> 4 days
21:01:48 <jatqceer> Hi, I'm using gentoo linux.  There's only ghc-6.6.ebuild, but not for 6.6.1.  Is it safe to make a 6.6.1 ebuild just by changing 6.6 ebuild?  And How?
21:02:17 <dons> quite possibly. perhaps ask on #gentoo-haskell ?
21:02:24 <dons> (though the same people hang out here)
21:02:27 <dons> ?seen lambdabot
21:02:27 <lambdabot> Yes, I'm here. I'm in #haskell-icfp07, #friendly-coders, #dreamlinux-es, #xmonad, #unicycling, #parrot, #oasis, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #haskell, #ghc, #gentoo-uy, #
21:02:27 <lambdabot> gentoo-haskell, #darcs and #scannedinavian
21:02:37 <dons> yes, #gentoo-haskell
21:04:16 <jatqceer> yes, I'm also there.  but no one else appears to be there
21:04:30 <jatqceer> so I asked here, hope someone might tried
21:04:38 <dons> you probably want kolmodin or dcoutts , when they're awake
21:04:50 <dons> they'll be up in about 4 hours.
21:05:14 * geezusfreeek goes to bed
21:06:21 <jatqceer> Thanks, I'll come back tomorrow.
21:07:26 <dons> i suspect they pretty much build the same, you just change the url or path
21:09:01 <jatqceer> I'm trying.  getting some errors.  one failed patch
21:10:11 <dmwit> jatqceer: IIRC, sjanssen always says something along the lines of "6.6 is in a mask in gentoo" -- does that mean anything to you?
21:10:26 <sorear> close.  overlay
21:10:27 <dmwit> (That's all I can remember, so if not... =)
21:10:35 <sorear> not that I understand what that *means*
21:10:40 <jatqceer> yes, it's masked.
21:10:41 <sorear> haskell overlay
21:10:48 <dmwit> sorear: Ah, right, right.
21:11:34 <jatqceer> but the v6.6 is in the main portage, as well as in the overlay.  no 6.6.1 though
21:11:50 <dmwit> o
21:13:10 <jatqceer> is this mean anything to you?
21:13:10 <jatqceer> +ifneq "$(GhcNotThreaded)" "YES"
21:13:10 <jatqceer>  SRC_HC_OPTS += -threaded
21:13:10 <jatqceer> +endif
21:13:14 <jatqceer>  
21:14:11 <dmwit> Looks like it's telling the 6.6 compiler whether or not to use threading in the 6.6.1 compiler.
21:14:32 <dmwit> But that's not authoritative, just a guess based on variable names.
21:15:17 <jatqceer> presumably harmless
21:17:15 <jatqceer> Disable threaded runtime build to work around RTS bugs on sparc
21:21:20 <dons> Cale, seen this http://programming.reddit.com/info/232pb/comments ?
21:21:21 <lambdabot> Title: (Co)Monads for Dummies^h^h^h Grad Students (pdf) (reddit.com)
21:22:35 <Cale> dons: neat. :) It summarises results from papers that I've read.
21:22:43 <dons> ?where+ comonad http://www.eyrie.org/~zednenem/2004/hsce/Control.Comonad.html
21:22:43 <lambdabot> Done.
21:22:52 <dons> do we know zednenem?
21:23:35 <dons> David Menendez, ah maybe we do.
21:24:27 <dons> ah, and the code is in the public domain, http://www.eyrie.org/~zednenem/2004/hsce/catext.zip
21:24:51 <dons> Cale, remind me again why you don't write small, mathy packages like this, and put them on hackage?
21:25:00 <Cale> hehe
21:26:00 <Cale> I really should get into writing package code. I have lots of .hs files lying around with possibly useful things in them.
21:26:20 <dons> yes, and you can just use mkcabal to bundle them into a single package
21:26:27 <dons> and hackage.haskell.org will generate the docs
21:26:36 <dons> all you need to do is fill out the .cabal file, and give it a name
21:27:04 <|Steve|> Heh, hackage?
21:29:49 <bos> wow, ghc on a mac could really do with a friendly installer.
21:30:52 <dons> |Steve|: our cpan/haskell packages. hackage.haskell.org
21:31:10 <|Steve|> I see.
21:33:18 <jatqceer`> what are the most important bugs I should be aware of in ghc-6.6?
21:34:30 <bos> you're fairly unlikely to encounter any unless you're exercising GHC hard.
21:34:55 <sorear> jatqceer: you might try looking at the release notes for 6.6.1
21:37:42 <TSC> Is there a nicer way to trim space than this?
21:37:43 <TSC> trimSpace = reverse . dropWhile isSpace . reverse . dropWhile isSpace
21:37:56 <dons> trimeSpace = let f =reverse . dropWhile isSpace in f . f
21:38:08 <dons> is my version
21:38:28 <dons> dropSpace :: [Char] -> [Char]
21:38:28 <dons> dropSpace = let f = reverse . dropWhile isSpace in f . f
21:38:28 <dons> -- | Drop space from the end of the string
21:38:28 <dons> dropSpaceEnd :: [Char] -> [Char]
21:38:28 <dons> dropSpaceEnd = reverse . dropWhile isSpace . reverse
21:39:00 <TSC> I'm pleased that mine is basically the same as yours
21:40:00 <dons> equal, up to inlining :)
21:40:21 <glen_quagmire> pandoc is awesome!
21:40:30 <sorear> is that from D.L.Stream?
21:40:41 <dons> lambdabot.
21:40:55 <dons> D.L.Stream is just Data.List
21:41:01 <dons> but more fun
21:41:02 <dmwit> Depending on how pick you are about spacing in the middle of the line, you could also use (dropSpaces = unwords . words)
21:47:04 <Pseudonym> D.L. Stream is the lesser-known Great American Novelist.
21:47:49 <dmwit> ?quote Pseudonym
21:47:49 <lambdabot> Pseudonym says: I think principal types are overrated
21:47:55 <Binkley> Oh yeah, isn't that the one who wrote "Naked Came the Closure"?
21:49:22 <Pseudonym> Yes, and Child Nodes and Lovers.
21:50:11 <Binkley> not to mention The Stack Pointer Also Rises
21:51:38 <Korollary> I'll wait for the movie.
21:52:56 <Binkley> starring Bruce Willis as the monomorphism restriction
21:53:13 <Pseudonym> And Gillian Anderson as Barbara Liskov.
21:53:46 <Binkley> It's a good thing I wasn't drinking any liquids.
21:53:51 <Korollary> Man
21:54:10 <Korollary> Does he look that effeminate to you?
21:54:17 <Binkley> which one?
21:54:41 <Korollary> Oops
21:55:41 <Korollary> I had a total brain fart and thought of Cillian Murphy instead.
21:56:29 <Korollary> Yeah, Anderson would make a great Liskov
21:57:54 <Pseudonym> ?quote lesser
21:57:54 <lambdabot> Pseudonym says: "Run GHC", by the way, is a lesser-known 80s kip hop group.
21:57:57 <ont> She must be about 100 by now.
21:58:03 <Pseudonym> Who, Gillian?
21:58:16 <ont> Yes, I was being somewhat silly.
21:59:04 <Korollary> Date of Birth:
21:59:06 <Korollary> 9 August 1968, Chicago, Illinois, USA
21:59:39 <ont> She's not that old after all.
22:03:15 <Binkley> ?quote
22:03:15 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
22:03:32 <Japsu> :DD
22:03:41 <Pseudonym> The best part is who said it.
22:03:48 <Pseudonym> ?quote Oleg
22:03:48 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
22:03:50 <Pseudonym> ?quote Oleg
22:03:50 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
22:03:58 <Binkley> ?quote OlegFacts
22:03:58 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
22:04:09 <Pseudonym> ?quote OlegFacts
22:04:10 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
22:04:41 <sorear> ?quote . Oleg
22:04:41 <lambdabot> No quotes for this person. Have you considered trying to match wits with a rutabaga?
22:04:44 <sorear> ?quote .Oleg
22:04:44 <lambdabot> DRMacIver says: Doesn't all knowledge ultimately come from Oleg?
22:04:45 <sorear> ?quote .Oleg
22:04:45 <lambdabot> Korollary says: an olegweek is a complex entity with an imaginary part
22:04:48 <sorear> ?quote .Oleg
22:04:48 <lambdabot> audreyt says: assembly would require metaolegs (or megaolegs)
22:04:49 <sorear> ?quote .Oleg
22:04:49 <lambdabot> Korollary says: an olegweek is a complex entity with an imaginary part
22:04:51 <sorear> ?quote .Oleg
22:04:51 <lambdabot> Pseudonym says: "Assuming an advanced compiler, your code will be sent to Oleg who will implement it in the type system."
22:05:36 <Pseudonym> ?remember OlegFacts Hindley and Milner use only their surnames out of fear of Oleg.
22:05:36 <lambdabot> Done.
22:07:04 <dons> hah
22:07:38 <Pseudonym> Not an original joke.
22:07:53 <Pseudonym> It's a recycled Bruce Schneier fact, and it was said about Diffie and Hellman.
22:08:12 <dons> yes, i suspected as much
22:08:14 <Pseudonym> Hell, R, S and A use only letters.
22:08:51 <Binkley> ?remember OlegFacts Oleg can express any computable function using only the K combinator
22:08:51 <lambdabot> Done.
22:09:22 <Pseudonym> ?remember OlegFacts HList solves the halting problem.
22:09:22 <lambdabot> Done.
22:09:26 <dons> I suspect he just uses I.
22:10:39 <Binkley> ?remember OlegFacts When Oleg writes code, the typechecker asks *him* if it's correct.
22:10:40 <lambdabot> Done.
22:10:40 <ski> call/cc would be more likely
22:12:08 <dons> i'd imagine fixpoints are only found, when Oleg let's them be found.
22:12:37 <dibblego> what is Oleg's last name?
22:12:40 <ski> oleg fixes the points with his stare
22:12:44 <ski> kiselyov
22:13:33 <dons> dibblego: don't let him find out you asked that...
22:13:46 <dibblego> I was 99% sure anyway
22:14:00 <Binkley> Oleg is just Oleg
22:14:02 <Binkley> like Madonna
22:14:03 <Binkley> or Cher
22:14:10 <dons> exactly like Madonna.
22:14:17 <Pseudonym> Yeah, if he finds out, you'll find out just how delimited his control is.
22:14:18 <araujo> how do i check the last changes applied to a darc repo?
22:14:19 <Korollary> run ins with the pope as well?
22:14:41 <dons> darcs changes
22:14:43 <dibblego> /nickserv info oleg
22:14:46 <dibblego> Last Seen: 2 years 6 weeks 5 days (9h 2m 38s) ago
22:14:51 <dibblego> is he still alive?
22:14:53 <dons> he doesn't need to use irc.
22:15:02 <Korollary> "Oleg's data declarations stir up Vatican"
22:15:16 <araujo> dons, but i want to check the new code applied
22:15:33 <Heffalump> darcs unpull
22:15:41 <Heffalump> (and then don't actually unpull it, obviously)
22:16:01 <araujo> mmm...
22:16:21 <dons> darcs diff the remote repo?
22:16:32 <dons> not enough info to know exactly what you mean by "check the last changes applied"
22:16:53 <araujo> dons, i want to read all the code modified.
22:17:03 <araujo> all the code modifications.
22:17:03 <dons> darcs changes -v | less
22:17:16 <dons>  | HsColour -tty | less -r  :-)
22:17:53 <araujo> dons, but, that doesn't show me all the lines of the current code modified.
22:17:55 <araujo> ?
22:18:17 <sjanssen> araujo: try darcs changes --interactive
22:18:19 <Binkley> araujo: do you want to see changes that haven't been recorded yet?
22:19:47 <araujo> Binkley, i want to see the modified code after a pull operation
22:20:06 <araujo> but well, i think a diff will make it indeed.
22:20:07 <Binkley> hmm, does pull have a --dry-run flag?
22:20:50 <sorear> araujo: darcs send -o /dev/null
22:21:06 <sorear> araujo: that will prompt you for every patch in local but not remote
22:21:25 <araujo> ah cool, thanks sorear
22:21:30 <araujo> :-)
22:23:02 <sorear> @seen shapr
22:23:02 <lambdabot> shapr is in #xmonad, #scannedinavian, #haskell-blah and #haskell. I last heard shapr speak 6h 14m 5s ago.
22:23:11 <sorear> @localtime shapr
22:23:12 <lambdabot> Local time for shapr is Tue Jul  3 00:21:44 2007
22:23:15 <sorear> @localtime treble
22:23:16 <lambdabot> Local time for treble is Mon Jul  2 18:01:05 2007
22:26:25 <dons> after a pull, darcs changes -v will show you the top most complete diff
22:26:41 <dons> and all the others. so pipe into less, or some other interactive pager
22:28:21 <araujo> thanks dons
22:28:28 <araujo> indeed, it works too
22:30:41 <blackdog> afternoon all
22:31:29 <blackdog> i'm about to venture out into the scary world of integration with C - any tips for making FFI relatively painless? What's the current preferred method?
22:32:19 <scook0> what sort of "integration with C" are you doing?
22:32:47 <blackdog> pretty minimal - i just want to be able to sling a C string to a C function and get one back
22:33:29 <sorear> just use the FFI then
22:33:42 <sorear> foreign import ccall "myHeader.h myFunction
22:33:59 <sorear> foreign import ccall "myHeader.h myFunction" c_myFunction :: Ptr CChar -> IO (Ptr CChar)
22:34:07 <sorear> myFunction :: String -> IO String
22:34:52 <blackdog> thanks sorear. i guess the idea of things like c2hs etc is more for generating wrappers for whole libraries?
22:34:58 <sorear> myFunction str = withCString str $ \cs -> do { c_ret <- c_myFunction cs ; hs_ret <- peekCString c_ret ; free c_ret {- optional of course! -} return hs_ret }
22:35:01 <sorear> blackdog: yeah
22:35:07 <sorear> there's your ffi wrapper
22:35:18 <blackdog> (i really oughta know this stuff, my ex-supervisor wrote it.... :)
22:35:30 <sorear> be sure and use the correct memory management order for your code :)
22:35:49 <scook0> I just started doing some FFI recently -- I love the fact that simple things are really easy
22:37:43 <Cheetahfoot> anyone here?
22:37:50 <Binkley> just us chickens
22:37:51 <Pseudonym> No.
22:37:55 <dibblego> no, your IRC client lies
22:38:00 <Pseudonym> Well, tastes like chicken, anyway.
22:38:05 <Cheetahfoot> heh.
22:38:25 <Pseudonym> Anyway, glad to help answer your question!
22:38:30 <Cheetahfoot> trying to figure this out ... http://hpaste.org/1524
22:38:32 <Cheetahfoot> it compiles ...
22:38:37 <Cheetahfoot> but gives me a type error.
22:39:01 <sjanssen> Cheetahfoot: it doesn't compile if you get a type error :)
22:39:04 <Cheetahfoot> i'm sure volumes can be written on what i'm doing wrong.
22:39:07 <Pseudonym> Haskell is picky like that.
22:39:14 <sjanssen> Cheetahfoot: please paste the error message too
22:39:30 <Cheetahfoot> okay ...
22:39:46 <Cale> Cheetahfoot: you'll need at least one conversion between number types in here
22:39:59 <sorear> strong smell of numeric mixup
22:40:01 <Cale> and you may want integer division rather than /
22:40:07 <Binkley> Cheetahfoot: writing down type signatures for your "factors" and "facts" functions might help you figure out what's going wrong
22:40:10 <Cale> which is called `div`
22:40:11 <Cheetahfoot> http://hpaste.org/1525
22:40:12 <Binkley> or at least result in a better error message
22:40:36 <Cheetahfoot> well, writing down the type signatures certainly did result in a more voluminous error message
22:40:52 <sorear> Cheetahfoot: yeah, you probably should use `div`
22:41:02 <Cheetahfoot> i'll try it.
22:41:05 <sorear> Cheetahfoot: 1 / 2  gives 0.5,  1 `div` 2 gives 0
22:41:09 <sorear> Cheetahfoot: which did you want?
22:41:52 <Cheetahfoot> well i want the integer result. the only time that division gets called is when t == 0 ...
22:42:00 <Cheetahfoot> t itself is a mod result
22:42:14 <Cheetahfoot> so i'm trying to store the divisor and the result of the division
22:42:16 <Pseudonym> > 6 `div` 2
22:42:24 <Pseudonym> If it helps, there's also:
22:42:24 <lambdabot>  3
22:42:29 <Pseudonym> 101 `divMod` 3
22:42:34 <Pseudonym> > 101 `divMod` 3
22:42:35 <lambdabot>  (33,2)
22:42:40 <hpaste>  Cale annotated "factors" with "fixed." at http://hpaste.org/1524#a1
22:43:08 <Cale> (at least, it actually runs and seems to work now)
22:43:23 <Cheetahfoot> whoa ...
22:43:44 <Cheetahfoot> the (floor . sqrt . fromIntegral $ n) is, well, flooring me.
22:43:45 <Cale> sqrt only works on floating point types
22:44:16 <Cale> so you need a fromIntegral to convert to a floating point representation and then a floor to convert the result back
22:44:18 <Cheetahfoot> oh divMod gives me both
22:44:29 <Cale> yep
22:44:29 <Cheetahfoot> ahhh ...
22:46:37 <Pseudonym> There are also integer square root implementations floating around.
22:46:58 <Cheetahfoot> the strong typing keeps throwing me ...
22:47:33 <Cale> I know how the numeric typeclasses can be confusing at first :)
22:47:58 <scook0> Pseudonym: wait, was that a pun? ;)
22:48:00 <Cheetahfoot> what about the algorithm? is it haskellish?
22:48:07 <Pseudonym> No.
22:48:33 <Pseudonym> Anyway, here's mine:
22:48:34 <Pseudonym> http://andrew.bromage.org/darcs/numbertheory/Math/Util.hs
22:48:47 <Pseudonym> Possibly overkill for your application.
22:49:51 <Cheetahfoot> well, i'm just solving problems to learn it.
22:50:39 <Cheetahfoot> although i'll bookmark the code :)
22:51:53 <Cheetahfoot> ah, is this the Newtonian method?
22:52:06 <Pseudonym> Yeah.
22:52:24 <Pseudonym> But I go to a lot of trouble to get an accurate initial estimate.
22:53:14 <dons> Cale: around?
22:53:23 <Cale> yep
22:53:41 <dons> if you visit programming.reddit.com, without logging in (i.e. log out), do you see any haskell articles?
22:53:44 <Cheetahfoot> very cool, Pseudonym
22:53:51 <Cheetahfoot> and thank you, too, Cale
22:54:00 <blackdog> hm, where's Ptr defined?
22:54:22 <Cale> dons: only a few
22:54:43 <blackdog> in Ptr. duh mark.
22:54:49 <dons> you do see some though, Cale, with 'Haskell' in the title?
22:54:57 <Cale> yeah, one
22:55:06 <dons> only the one with lower case 'haskell-cafe' ?
22:55:11 <bos> i see about four when i'm logged in.
22:55:21 <dons> yes, now, if you log in, do you then see 4 or 5 ?
22:55:25 <Cale>  19. 	(haskell-cafe) Parsers are monadic? (nabble.com)
22:55:33 <dons> yeah, that's the only one i see. when not logged in.
22:56:05 <Cale> I see like 23 when logged in
22:56:07 <dons> do you see any posts submitted with my name, when not logged in? do they appear after you log in?
22:56:10 <Cale> (on 'hot')
22:56:18 <Cale> yes, lots
22:56:24 <dons> when not logged in?
22:56:39 <Cale> In fact, your posts are nearly the only things I don't mod down :)
22:57:05 <dons> right, but i'm wondering why i don't see any of my posts, from the `default' not-logged in reddit...
22:57:23 <Cale> I do.
22:57:23 <dons> not even in the 'new' list.
22:57:27 <dons> ah ok.
22:57:45 <dons> it might be some weird caching then , on my side.
22:57:56 <dons> but you did mention you only see 1 haskell article, when not logged in?
22:57:59 <Cale> on the second page of the 'hot' for the programming reddit, when not logged in
22:58:04 <Cale> I see one of yours
22:58:28 <Cale> On the first page is that link to haskell-cafe with the "Parsers are monadic?" question.
22:58:30 <dons> so when not logged in, e.g.  4.  	
22:58:31 <dons> 	The supermarket pricing puzzle in Haskell (blog.moertel.com)
22:58:33 <dons> is missing
22:58:50 <Cale> mm, yeah
22:58:59 <Cale> It's certainly not 4th anyway
22:59:10 <dons> oh, hang on, the points are also radically different
22:59:27 <dons> the 1. article has only 120 pts, when not logged in.
22:59:29 <dons> so maybe its just not regenerated very often
23:00:11 <dons> yeah, i think that's it.
23:00:41 <Cheetahfoot> so Cale, Pseudonym, when haskell encounters a magic number without a decimal does it just assume Float?
23:00:55 <dons> :t 1
23:00:58 <lambdabot> forall t. (Num t) => t
23:01:04 <Cale> Cheetahfoot: It look at what typeclasses it needs, and first tries Integer, then Double
23:01:05 <dons> it doesn't assume anything :)
23:01:11 <Cale> looks*
23:01:29 <Cale> (this is at the last possible moment, when it finally needs to pick one)
23:01:47 <dons> yeah, it picks the instance that fits, if one fits.
23:01:55 <dons> talks like a duck and all that ;)
23:02:13 <dons> > 1 / pi
23:02:14 <lambdabot>  0.3183098861837907
23:02:18 <dons> > 1.0 / pi
23:02:20 <lambdabot>  0.3183098861837907
23:02:21 <Cheetahfoot> okay. so i'm trying to understand why the fromIntegral was necessary then ...
23:02:24 <dons> > 1 `div` 2
23:02:26 <lambdabot>  0
23:02:32 <mauke> > 1 / 2 :: Rational
23:02:32 <Cheetahfoot> why not just (floor . sqrt $ n) ?
23:02:35 <lambdabot>  1%2
23:02:40 <mauke> :t sqrt
23:02:42 <lambdabot> forall a. (Floating a) => a -> a
23:02:57 <Pseudonym> floor . sqrt $ 2^200
23:02:59 <edwardk> n wasn't Floating
23:03:02 <Pseudonym> > floor . sqrt $ 2^200
23:03:03 <lambdabot>  1267650600228229401496703205376
23:03:07 <Pseudonym> > floor . sqrt $ 2^1000
23:03:09 <lambdabot>  3273390607896141870013189696827599152216642046043064789483291368096133796404...
23:03:22 <Pseudonym> Wow, didn't know ithat worked.
23:03:33 <Pseudonym> > (floor . sqrt $ 2^1000) == 2^500
23:03:35 <lambdabot>  True
23:03:51 <Cheetahfoot> dang
23:03:57 <hpaste>  Cale annotated "factors" with "refactor a bit" at http://hpaste.org/1524#a2
23:04:40 <Pseudonym> Oh, duh.
23:04:42 <Pseudonym> Of course.
23:04:45 <Cheetahfoot> ah, Cale, that's awesome.
23:04:47 <Pseudonym> Powers of two are representable exactly.
23:04:56 <Cale> and then you notice that t isn't actually being used...
23:05:06 <Pseudonym> > floor . sqrt $ 3^1000
23:05:06 <Cale> so we can get rid of that
23:05:08 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
23:05:13 <Pseudonym> > floor . sqrt $ 3^1000 == 3^500
23:05:14 <lambdabot>   add an instance declaration for (Floating Bool)
23:05:19 <Cale> er, I suppose it is
23:05:20 <Pseudonym> > (floor . sqrt $ 3^1000) == 3^500
23:05:22 <lambdabot>  False
23:05:24 <Pseudonym> Right.
23:05:28 <Pseudonym> That's the problem.
23:05:30 <Cale> but just barely
23:06:11 <ttmrichter> Another stupid Haskell question -- this time an implementation one.  If I have a function g that is defined as "g = f", will calling g incur any overhead over calling f?
23:06:12 <Cheetahfoot> yes
23:06:27 <ttmrichter> Wow, Cheetahfoot!  That was fast!  :)
23:06:32 <mauke> ttmrichter: I doubt it
23:06:33 <Cheetahfoot> i dont mean 'yes' to ttmrichter
23:06:45 <Pseudonym> But yeah, now that I think about it, using floating-point sqrt to get an estimate isn't so bad.
23:06:46 <Cheetahfoot> i was answering Cale, from earlier! sorry.
23:06:49 <ttmrichter> I didn't think you did, CF.  The timing was just awesome.  :)
23:06:57 <Cheetahfoot> lol
23:07:22 <ttmrichter> mauke: I'm glad to hear that.  I tend to like using aliases where they aid in semantic understanding.
23:07:29 <hpaste>  Cale annotated "factors" with "again" at http://hpaste.org/1524#a3
23:07:35 <edwardk> ttmrichter: in general no, but any residue will definitely vanish if you compile with optimizations =)
23:07:56 <Cale> oops!
23:08:21 <hpaste>  Cale annotated "factors" with "forgot to remove parameter" at http://hpaste.org/1524#a4
23:08:31 <edwardk> heh
23:08:38 <edwardk> was wondering how that last part was a function =)
23:09:42 <Cale> This is really nontrivial factors. To include all the factors, you'd start it off at 1.
23:10:17 <Cheetahfoot> aahhhh! i'm learning so much! this is awesome!
23:10:47 <mauke> .oO( aahhhh! I'm learning so much! it burns! it burnssssss )
23:10:55 <Cheetahfoot> it does burn.
23:14:14 <sorear> ttmrichter: Any reasonable optimizing compiler should make g inline-uncondiionally.  But even out-of-line, a non-permuting tail call like that will produce maybe 2 bytecodes in hugs/ghci and ~10 cycles of code in ghc w/o -O
23:23:24 <ttmrichter> Cheetahfoot: welcome to my world of last night.  I learned a whole bunch of stuff (mostly related to how dumb I am) last night here.
23:23:52 <Cheetahfoot> ttmrichter: well, that's my experience every time i come here. i don't seem to be getting any smarter ...
23:24:45 <dons> blame the state of the computer science undergraduate curriculum ;)
23:24:54 <dibblego> ?remember ttmrichter> Cheetahfoot: welcome to my world of last night.  I learned a whole bunch of stuff (mostly related to how dumb I am) last night here.
23:24:55 <lambdabot> Done.
23:25:05 <sorear> ?quote ttmrichter>
23:25:05 <lambdabot> ttmrichter> says: Cheetahfoot: welcome to my world of last night.  I learned a whole bunch of stuff (mostly related to how dumb I am) last night here.
23:25:15 <Binkley> Well, personally, my CS undergrad curriculum was fine. The problem was that I was a lazy slacker.
23:25:39 <dons> ok, we can make an exception for slackers.
23:26:43 <Cheetahfoot> i was an english major.
23:27:01 <Binkley> then blame the English department for not teaching you Haskell :-)
23:27:02 <hpaste>  jason_pulse pasted "jason_pulse" at http://hpaste.org/1526
23:27:06 <Cheetahfoot> i do blame them.
23:27:51 <sorear> There will be a hpaste client soon.
23:28:26 * ttmrichter facepalms.  "Like I need those words for posterity...."
23:29:05 <Pseudonym> OK, fixed up the isqrt.
23:29:12 <ttmrichter> In my defence, the only functional language I had access to in undergrad school was Lisp.  Which I hated on sight.
23:29:14 <Pseudonym> The initial guess is much simpler now.
23:29:37 <dons> sorear: you got that one?
23:29:45 <sorear> yup
23:30:00 <hpaste>  b3myfr3n pasted "b3myfr3n" at http://hpaste.org/1527
23:30:06 <dons> huh, 2.
23:30:17 <Cheetahfoot> Pseudonym: did you commit it?
23:30:17 * ttmrichter eyes dons suspiciously.  "What was sorear supposed to get?"
23:30:18 <dibblego> ttmrichter, you should learn not to hate languages on sight
23:30:19 <dons> we also need a) a fix, b) someone in europe with admin privs.
23:30:30 <shachaf> ttmrichter: Spam on hpaste.
23:30:30 <dons> yeah, sounds like Pseudonym ;)
23:30:46 <Pseudonym> Cheetahfoot: Yeah, though you don't use the word "commit" with darcs.
23:30:52 <Binkley> You don't?
23:30:53 <Binkley> Damn.
23:30:54 <Cheetahfoot> oh.
23:30:56 <sorear> dons: OR c) an acct on community.h.o for treble :)
23:31:00 <sorear> a sane machine
23:31:05 <Cheetahfoot> what's the term?
23:31:07 <ttmrichter> dibblego: I don't usually hate languages on sight.  I've made exceptions in my time for COBOL, Lisp, APL and K.
23:31:35 * sorear likes Lisp and APL (but hasn't seen K or COBOL)
23:32:24 <Syzygy-> Is K something like J?
23:32:27 <Cheetahfoot> COBOL makes me hyperventilate.
23:32:38 <ttmrichter> Syzygy-: Yes.
23:32:49 <hpaste>  sp4mM3R!!1! pasted "sp4mM3R!!1!" at http://hpaste.org/1528
23:32:51 <Syzygy-> ./~ And the chance that I'll write COBOL code's a SNOBOL's chance in hell ./~
23:33:20 <arcatan> hah
23:34:13 <sorear> dons: real spammers don't reflect ... I'm starting to beleive your shapr story
23:36:45 <ttmrichter> Shapr?  A haskeller is polluting hpaste?
23:37:19 <sorear> dons: is community.h.o suitable for community servers?
23:37:56 <Pseudonym> ttmrichter: That's what he wants you to think.
23:38:09 <dons> i'm not sure, sorear
23:38:10 <dons> possibly.
23:38:20 <dons> for community stuff like hpaste
23:38:33 <Pseudonym> Especially since hpaste is a piece of infrastructure.
23:39:08 <Pseudonym> It'd be nice if hpaste and lambdabot were combined into one bot, too.
23:39:21 <mauke> yay, "userspace" layout switching in xmonad
23:39:45 <dons> mauke: ?
23:39:48 <sorear> I think it would be nice if lambdabot were split into a dozen less featureful bots :)
23:40:08 <dons> one bot to rule them all, though.
23:40:19 <siti> :D
23:40:23 <mauke> dons: you don't need switchLayout at all. I've just written an extension that lets me toggle fullscreen mode anywhere.
23:40:39 <dons> oh, sounds fun. how'd you do that/
23:40:40 <Pseudonym> True, it might mean that the channel population decreases by one...
23:40:56 <Korollary> There is no bot but lambdabot and hpaste is its prophet.
23:41:17 <siti> lol
23:41:20 <hpaste>  mauke pasted "XMonadContrib/Toggle.hs" at http://hpaste.org/1529
23:41:31 <siti> Korollary: well I do agree lambda bot is the best bot ever :D
23:41:41 <siti> we just need a trivia extension for it ;)
23:41:53 * LeCamarade changes his lil' language to use Either for exceptions, rather than Maybe.
23:42:30 <mauke> and defaultLayouts = map (toggle $ noBorders full) [ ... ] in Config
23:42:35 <Pseudonym> What, like OlegFacts?
23:42:58 <Pseudonym> ?remember OlegFacts Oleg has a higher rank than you.
23:42:58 <lambdabot> Done.
23:44:46 <Binkley> ?remember OlegFacts Oleg wrote a function with type (a -> b) -> [a] -> [b] ...and it wasn't map
23:44:46 <lambdabot> Done.
23:45:11 <Pseudonym> I did too.
23:45:42 <sorear> ?type (reverse .) . map
23:45:45 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
23:45:45 * Binkley blushes
23:45:47 <Pseudonym> ?type \f xs -> f (head xs) `seq` []
23:45:48 <lambdabot> forall a a1 a2. (a -> a1) -> [a] -> [a2]
23:45:50 <Binkley> Bad example.
23:46:04 <Pseudonym> Even more general than map!
23:48:46 <opqdonut> :)
23:51:22 <dons> oleg knows two non-bottom functions of :: a -> a
23:51:45 <mauke> :t join seq
23:51:47 <lambdabot> forall a. a -> a
23:51:55 <opqdonut> :)
23:52:00 <opqdonut> :t seq
23:52:02 <lambdabot> forall a t. a -> t -> t
23:52:04 <Pseudonym> :t id . id
23:52:07 <lambdabot> forall a. a -> a
23:53:38 * sorear knows of three non-bottom functions of type a -> a
23:53:50 <opqdonut> fix?
23:54:15 <sorear> const undefined, id, and id again.
23:54:24 <opqdonut> :)
23:54:36 <opqdonut> well
23:54:39 <opqdonut> :t const undefined
23:54:42 <lambdabot> forall a b. b -> a
23:54:43 <opqdonut> that really doesn't count
23:54:44 <sorear> but the first two are very distinct frome ach other and underfined.
23:54:48 <sorear> why not?
23:54:52 <sorear> it's not bottom
23:54:58 <sorear> > const undefined `seq` 2
23:55:01 <lambdabot>  2
23:55:03 <sorear> > cundefined `seq` 2
23:55:04 <lambdabot>   Not in scope: `cundefined'
23:55:06 <sorear> > undefined `seq` 2
23:55:07 <lambdabot>  Undefined
23:55:25 <opqdonut> but it's most general type isn't a->a
23:55:58 <sorear> most general type is pretty meaningless
23:56:01 <shachaf> opqdonut: If that had to be true for it to qualify, you wouldn't have to say "non-bottom".
23:56:08 <sorear> :t (\x -> x)
23:56:11 <lambdabot> forall t. t -> t
23:56:23 <sorear> :t ((\x -> x) :: forall t. t -> t)
23:56:25 <lambdabot> forall t. t -> t
23:56:36 <sorear> :t ((\x -> x) :: forall t. t -> t) :: GHC.Exts.Int# -> GHC.Exts.Int#
23:56:39 <lambdabot>     Couldn't match kind `*' against `#'
23:56:39 <lambdabot>     When matching the kinds of `t :: *' and `GHC.Prim.Int# :: #'
23:56:44 <sorear> :t ((\x -> x)) :: GHC.Exts.Int# -> GHC.Exts.Int#
23:56:46 <lambdabot> GHC.Exts.Int# -> GHC.Exts.Int# :: GHC.Prim.Int# -> GHC.Prim.Int#
23:56:58 <sorear> Or, in English, :t isn't the most general type.
23:57:13 <opqdonut> okay
23:57:23 <sorear> GHC (indeed Haskell, but the examples are much much subtler there) lacks principle types.
23:58:15 <opqdonut> principle? as in fundamental?
23:58:31 <Binkley> as in principal :-)
23:58:37 <Pseudonym> Completely unprincipled.
