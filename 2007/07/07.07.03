00:00:31 <ski> "Far above all principality, and power, and might, and dominion, and every name that is named, not only in this world, but also in that which is to come"
00:50:55 <LeCamarade> Hoooooooooooo!
00:51:00 * LeCamarade hates silence
00:52:45 * osfameron blows a raspberry in LeCamarade's ear
00:54:51 * LeCamarade recovers from the voices saying `Return to Java, Return to Java ...' They are everywhere!
00:55:38 <osfameron> heh
01:03:10 <vincenz> dons: you called?
01:21:26 * shapr warbles quietly
01:23:14 <mgsloan> > let alarm = "BEEPBEEP BEEPBEEP  " in concat . repeat $ alarm
01:23:15 <lambdabot>  "BEEPBEEP BEEPBEEP  BEEPBEEP BEEPBEEP  BEEPBEEP BEEPBEEP  BEEPBEEP BEEPBEEP ...
01:23:51 <opqdonut> > let alarm = "BEEPBEEP BEEPBEEP  " in cycle alarm
01:23:55 <lambdabot>  "BEEPBEEP BEEPBEEP  BEEPBEEP BEEPBEEP  BEEPBEEP BEEPBEEP  BEEPBEEP BEEPBEEP ...
01:23:58 <opqdonut> :)
01:23:58 <mgsloan> or that
01:24:00 <mgsloan> :)
01:24:12 <DRMacIver> @src cycle
01:24:12 <lambdabot> cycle [] = undefined
01:24:13 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
01:24:15 <DRMacIver> Hm
01:24:30 <mgsloan> yeah, clearly they never heard of pointfree when they wrote cycle!
01:24:57 <DRMacIver> Indeed. :)
01:25:17 <quicksilver> some people prefer explicit recursion to use of fix, I think
01:25:24 <osfameron> yeah!
01:25:37 <quicksilver> hmm
01:25:39 <ibid> can you write it pointlessly while still creating an actual loop in the data structure under lazy eval?
01:25:44 * DRMacIver wasn't complaining.
01:26:03 <quicksilver> I'm not sure why they didn't write cycle xs = xs ++ cycle xs
01:26:10 <quicksilver> could be a silly GHC optimiser thing
01:26:18 <DRMacIver> Yeah.
01:26:26 <ibid> quicksilver: that would be broken
01:26:34 <ibid> nothing to do with optimizers
01:26:36 <quicksilver> ibid: ?
01:26:57 <quicksilver> > let c xs = xs ++ c xs in c [1,2,3]
01:26:58 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
01:27:02 <quicksilver> looks OK to me...
01:27:02 <ibid> the point is that under lazy evaluation strategy, cycle should create an actual loop in the data structure, which your def would not do
01:27:08 <opqdonut> yeah i think the prelude version forms a cyclic list while quicksilver's doesn't
01:27:16 <opqdonut> exactly
01:27:18 <mgsloan> oh, huh
01:27:19 <quicksilver> who carse?
01:27:30 <ibid> quicksilver: it's memory efficient
01:27:35 <quicksilver> my version has an extra thunk to unwrap each time you get to the end of the list
01:27:39 <quicksilver> but that's hardly a big problem
01:27:52 <quicksilver> it's a constant overhead, and a pretty small one
01:27:55 <ibid> quicksilver: your solution is not constant space
01:28:01 <quicksilver> it isn't?
01:28:02 <ibid> quicksilver: the prelude solution is
01:28:07 <mgsloan> I wonder if !! uses modulus for cycles
01:28:17 <quicksilver> mgsloan: no, it doesn't :)
01:28:25 <quicksilver> ibid: how is mine not constant space?
01:28:46 <mgsloan> > cycle [1,2,3] !! 2^20
01:28:49 <lambdabot>  3486784401
01:28:59 <mgsloan> uhh
01:29:13 <mgsloan> > cycle [1,2,3] !! (2^20)
01:29:16 <lambdabot>  2
01:29:18 <quicksilver> :)
01:29:32 <quicksilver> > let c xs = xs ++ c xs in c [1,2,3] !! (2^20)
01:29:32 <mgsloan> > cycle [1,2,3] !! (2^26)
01:29:35 <lambdabot>  2
01:29:35 <lambdabot>  2
01:29:39 <mgsloan> hmm
01:29:51 <quicksilver> ibid: if mine didn't run in constant space, wouldn't that have blown up?
01:29:51 <mgsloan> > cycle [1,2,3] !! (2^100)
01:29:53 <lambdabot>  1
01:29:55 <opqdonut> quicksilver: well yeah, in that case the elements get gc'd
01:30:00 <ibid> quicksilver: the xs list gets copied on each iteration, as far as i can see
01:30:03 <quicksilver> > let c xs = xs ++ c xs in c [1,2,3] !! (2^100)
01:30:04 <lambdabot>  1
01:30:15 <mgsloan> how could it do it 2^100 times? no way
01:30:33 <quicksilver> mgsloan: well it's not really 'donig' very much
01:30:34 <opqdonut> doesn't !! take an Int?
01:30:35 <opqdonut> :t !!
01:30:37 <lambdabot> parse error on input `!!'
01:30:38 <ibid> quicksilver: those versions probably throw the copies away as garbage as soon as they are created, as you don't keep the list around
01:30:39 <quicksilver> ah
01:30:39 <opqdonut> :t (!!)
01:30:41 <lambdabot> forall a. [a] -> Int -> a
01:30:53 <opqdonut> 2^100 is hardly int :)
01:31:01 <mgsloan> heh
01:31:04 <opqdonut> > 2^100 :: Int
01:31:06 <ibid> quicksilver: and it's remotely possible that the optimizer rewrites your version to the prelude version ;)
01:31:08 <lambdabot>  0
01:31:10 <opqdonut> :)
01:31:14 <quicksilver> funny :)
01:31:19 <quicksilver> > let c xs = xs ++ c xs in c [1,2,3] !! (2^30)
01:31:22 <mgsloan> > 2^20 :: Int
01:31:24 <lambdabot>  1048576
01:31:26 <lambdabot> Terminated
01:31:29 <mgsloan> ah
01:31:39 <quicksilver> > cycle [1,2,3] !! (2^30)
01:31:47 <lambdabot> Terminated
01:31:48 <mgsloan> :(
01:31:52 <quicksilver> no difference there then
01:32:00 <mgsloan> and here I thought ghc was a genius
01:32:08 <quicksilver> ibid: I don't really understand why my version would copy xs any more or less than the prelude version
01:32:21 <quicksilver> ibid: the actual work is done by ++ at the end of the day, in both cases
01:32:23 <mgsloan> > 2^31 :: Int + 1
01:32:24 <lambdabot>  Parse error
01:32:41 <mgsloan> > ((2^31) :: Int) + 1
01:32:43 <lambdabot>  -2147483647
01:32:51 <mgsloan> yay
01:33:15 <ibid> quicksilver: the prelude version copies only once, and after that the infinite structure contains no thunks, afaict
01:33:29 <quicksilver> @src cycle
01:33:29 <lambdabot> cycle [] = undefined
01:33:29 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
01:33:39 * quicksilver nod ponders
01:33:58 <quicksilver> oh, I see. The where clause "memoises" xs;
01:34:00 <quicksilver> xs'
01:34:03 <ibid> quicksilver: yep
01:34:27 <quicksilver> cycle xs = let c = cycle xs in xs ++ c
01:34:28 <quicksilver> :)
01:35:26 <ibid> quicksilver: the problem there is that you need to go through a function application to get the "xs'", and i've learned to consider that a warning sign. too lazy to work it out now if it matters or not :)
01:35:31 <mgsloan> > let cycle xs = (let c = cycle xs in xs ++ c) in cycle []
01:35:36 <lambdabot> Terminated
01:36:28 <ibid> quicksilver: of course, this all is assuming a straightforward lazy evaluation implementation, which ghc is
01:36:54 <quicksilver> the optimiser is certainly 'permitted' to memoise a CSE
01:36:56 <ibid> quicksilver: but i wonder why haskell makes a point of being nonstrict and not lazy, when many haskell idioms rely on lazy evaluation :)
01:37:05 <quicksilver> although in practice it doesn't, I don't think
01:37:13 <ibid> i should have said "which ghc is *not*"
01:38:00 * quicksilver nods
02:07:53 <pastorn> how good friends are PPC and hugs/ghci?
02:10:22 <hpaste>  dabauer pasted "dabauer" at http://hpaste.org/1530
02:10:23 <quicksilver> pastorn: works for me
02:10:58 <quicksilver> pastorn: that may not be a very detailed answer :)
02:11:09 <pastorn> ok, maybe it was sparc/solaris and haskell that had a beef then...
02:17:15 <earthy> pastorn: not really, also works
02:19:02 <pastorn> then someone tricked me!!
02:21:50 <lokik> :P
02:24:20 <nornagon> is there a better way to squish all the []s out of a [[a]] than filter (not.null)?
02:24:37 <quicksilver> what could possibly be better than that?
02:24:38 <quicksilver> :)
02:24:45 <DRMacIver> That looks pretty good to me. :)
02:25:02 <nornagon> just wondering if that was particularly slow or if there was a prelude/data.list function for the same
02:25:14 <quicksilver> I can't imagine anything faster
02:25:21 <nornagon> ace.
02:25:37 <nornagon> @src unwords
02:25:37 <lambdabot> unwords [] = ""
02:25:37 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
02:25:47 <quicksilver> [ (x:xs) | (x:xs) <- l] would win points for 'gratuitous list comprehension cuteness'\
02:26:01 <quicksilver> but I wouldn't expect it to be better or faster
02:26:45 <opqdonut> :)
02:27:01 <nornagon> i gues unwords === concat . intersperse " "
02:27:19 <quicksilver> nornagon: yes, I think it was written before intersperse existed
02:27:34 <malcolmw> [ xs | xs@(_:_) <- l ] would be a slight improvement
02:27:58 <quicksilver> malcolmw: hmm, that's a good point
02:28:05 <nornagon> i'm ... not sure how that list comprehension thing works >.>
02:28:06 <quicksilver> malcolmw: arguably the compiler should spot that, though
02:28:19 <DRMacIver> @type (@)
02:28:25 <nornagon> o.o
02:28:27 <lambdabot> parse error on input `@'
02:28:29 <DRMacIver> Hm
02:28:31 <quicksilver> malcolmw: "intact constructor re-application removal" :)
02:28:38 <nornagon> @ is special syntax in pattern matching :)
02:28:41 <DRMacIver> What does @ do?
02:28:44 <quicksilver> names
02:28:53 <nornagon> 'match xs as (_:_)'
02:28:55 <quicksilver> xs@(a:b) is (a:b) but let's also call it xs
02:29:04 <mux> it is to remember things when you deconstruct it
02:29:16 <quicksilver> malcolmw's contribution is to stop my version deconstructing and reconstructing needlessly
02:29:30 <quicksilver> although, as I said, really you might hope a compiler could spot that one
02:29:35 <DRMacIver> Ah
02:30:03 <nornagon> i imagine unwords is slightly faster than concat . intersperse ' '?
02:30:07 <LeCamarade> @let (_'_) undefined
02:30:07 <lambdabot>  Parse error
02:30:10 <nornagon> er, intersperse " "
02:30:11 <malcolmw> quicksilver: in general it is not possible, because the constructor re-aplication might be at a different type, so you can't just name the whole thing and reuse it
02:30:15 <LeCamarade> X^(
02:30:28 <nornagon> LeCamarade: missing an =?
02:30:41 <LeCamarade> @let (_'_) = undefined
02:30:41 <nornagon> because it works in ghci here.
02:30:44 <lambdabot> Defined.
02:30:51 <malcolmw> e.g. f :: Either a b -> Either c b;  f (Left x) = Left x
02:31:11 <malcolmw> oops, I meant f  (Right x) = Right x
02:31:14 <quicksilver> malcolmw: I just meant, if a compiler sees that a constructor is being used with exactly the same arguments as a pattern-binding, it could re-use the same in-memory copy
02:31:22 <LeCamarade> > let bottom = (_'_) in bottom
02:31:25 <lambdabot>  Undefined
02:31:34 <malcolmw> quicksilver: after type checking, yes I suppose it could
02:31:38 <LeCamarade> :^D
02:32:13 <quicksilver> malcolmw: yes, after type checking. good point.
02:38:38 <hpaste>  d0z0 pasted "d0z0" at http://hpaste.org/1532
02:40:05 <DRMacIver> Hm. I wonder if it's worth making hpaste require a nick that's currently in channel.
02:42:19 <quicksilver> it may suffice to make it require a cookie
02:42:28 <quicksilver> I think most of these spambots don't do cookies properly
02:42:31 <quicksilver> (I'm not sure though)
02:43:52 <LeCamarade> Is the spambot problem that big?
02:44:09 * LeCamarade is a Worse is Better believer ...
02:44:25 * DRMacIver is a Worse is Worse believer. It has the advantage of making sense. ;)
02:45:16 <quicksilver> LeCamarade: at the moment, it only seems to be once every few hours, so it's a minor inconvenience
02:45:33 <LeCamarade> That's big enough.
02:45:33 <quicksilver> LeCamarade: it's not very nice to have disgusting pornography in our clean channel, though
02:46:14 <LeCamarade> But I keep getting bounced off web services because of my cookie-intolerant browsers, sometimes.
02:46:25 <quicksilver> then, that might be the wrong solution
02:46:25 <LeCamarade> And cookie-intolerant proxies.
02:46:34 * DRMacIver 's solution is cookie independent.
02:46:44 <quicksilver> DRMacIver: quite true
02:46:56 <quicksilver> DRMacIver: I thought mine was lighter weight, if it had worked
02:46:58 <DRMacIver> It doesn't even have to refuse to paste if you don't provide a nick, just not post the link into the channel.
02:47:15 <DRMacIver> This keeps the IRC code nice and independent of the pasting.
02:47:31 <LeCamarade> Yeah, that thing of requiring a nick will work to block spammers well, even with a bit of inconvenience for the posters.
02:48:38 <quicksilver> DRMacIver: well we probably don't want spammers to use hpaste for their link farms, though
02:48:43 <quicksilver> DRMacIver: even if they aren't being announced
02:48:51 <DRMacIver> True
02:49:06 <quicksilver> DRMacIver: next thing you know people are being sent junk email which links to hpaste posts which have their links in, etc etc
02:49:51 <LeCamarade> The spammers are bots, not people, right?
02:49:55 <DRMacIver> Presumably
02:50:11 <DRMacIver> Are you about to suggest a captcha? :)
02:50:35 <LeCamarade> [Title] [Nick] [Channel] if channel /= "#haskell" then Nothing else Just post_the_bloody_thing
02:50:52 <LeCamarade> A simple 1 + 3 captcha can work.
02:51:23 <LeCamarade> I use a version like that for some (please, don't shoot) PHP stuff here. Works like magique.
02:52:53 <quicksilver> I hate captchas
02:53:00 <quicksilver> but, if you have complete anonyminity and no cookies
02:53:09 <quicksilver> then maybe they're one of the few options remaining
02:53:42 <LeCamarade> Or just checking for Haskell syntax in the post? Or is that too much work? Yeah. Too much work.
02:54:31 <mgsloan> well, it already has highlighting
02:56:33 <mgsloan> could check if its haskellesque, and if not, captharize
02:56:39 <mgsloan> *captcharize
02:57:14 <Philippa> {- Haskellesque viagra: http://...
02:57:15 <Philippa> -}
02:57:24 <mgsloan> hah
02:57:40 <LeCamarade> {-#IVORY-TOWER ...
02:58:17 <LeCamarade> But these Haskellers speak of the language in deeply-erotic words, sometimes. I know one Ph ... *ouch*.
02:59:04 <mgsloan> man, our ivory tower must be the plush edition, it's uber sweet
02:59:12 <LeCamarade> Anyway, we try them all. Those that work stay. Those that don't go. A simple x + y captcha can ... I mean, no Haskeller can't add two numbers under 10.
02:59:54 <earthy> > 3 + 4 :: Char
02:59:55 <lambdabot>   add an instance declaration for (Num Char)
02:59:55 <lambdabot>     In the expression: 3 + 4
02:59:55 <lambdabot>    ...
03:00:05 <mgsloan> still, one with no annoyance is best
03:00:07 <mgsloan> hah
03:00:22 <earthy> wasn't char a subtype of int? :P (yeah, that's C, I know :))
03:00:39 <quicksilver> you can do a javascript self-filling thing
03:00:39 <fasta> Is there anyone who already runs HEAD?
03:00:44 <quicksilver> most bots don't run javascript
03:00:49 <LeCamarade> mgsloan: Yes, but we've been attacked. Anarchy's first victim is anarchy.
03:01:03 <fasta> I have a piece of esoteric code, I would like you to run, which fails on 6.6.1
03:01:15 <osfameron> many people prefer not to use javascript either
03:01:29 <mgsloan> > (fromInteger 56) :: Char
03:01:30 <lambdabot>   add an instance declaration for (Num Char)
03:01:31 <lambdabot>     In the expression: (fromInte...
03:01:36 <LeCamarade> quicksilver: Aha! So those of us who don't have JS will fill the captcha - we expect a bit of scriptism, after all.
03:01:55 <opqdonut> mgsloan:
03:02:01 <opqdonut> > intToDigit 3
03:02:03 <lambdabot>  '3'
03:02:15 <fasta> Can anyone run this code on something newer than 6.6.1? http://hackage.haskell.org/trac/ghc/ticket/1485
03:02:15 <opqdonut> ?src intToDigit
03:02:16 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
03:02:18 <lambdabot> Title: #1485 (-fno-monomorphism-restriction -fallow-undecidable-instances do not play n ...
03:02:19 <opqdonut> :/
03:02:23 <mgsloan> yeah, I know :)
03:02:27 <quicksilver> LeCamarade: yup, that's right.
03:02:37 <mgsloan> we were just probing the Numness of Char, which is none
03:02:41 <mgsloan> thanks though
03:03:09 <mgsloan> (I thought I remember char being basically a short)..
03:03:17 <LeCamarade> fasta, I'm a little worried. You're hacking your heart out. :o) _I fear HEAD!_
03:03:33 <mgsloan> > digitToInt . intToDigit $ 1000
03:03:35 <lambdabot>  Exception: Char.intToDigit: not a digit 1000
03:03:50 <mgsloan> guess not
03:04:03 <opqdonut> it works for single digits
03:04:18 <quicksilver> mgsloan: it's basically a 32-bit Int, in a sense
03:04:22 <opqdonut> map (digitToInt . intToDigit) "123456789"
03:04:22 <mgsloan> right, byte range i suppose
03:04:24 <quicksilver> mgsloan: but it's not a Num
03:04:26 <opqdonut> > map (digitToInt . intToDigit) "123456789"
03:04:28 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
03:04:39 <opqdonut> > map (intToDigit.digitToInt) "123456789"
03:04:41 <mgsloan> 32-bit?!?! whatever for!
03:04:41 <lambdabot>  "123456789"
03:04:44 <opqdonut> bah :)
03:04:51 <quicksilver> > ( toEnum . (+4) . fromEnum $ 'a' ) :: Char
03:04:52 <lambdabot>  'e'
03:05:00 <quicksilver> mgsloan: unicode
03:05:04 <opqdonut> fromEnum, nice
03:05:15 <opqdonut> > fromEnum 'ä'
03:05:15 <lambdabot>      lexical error in string/character literal (UTF-8 decoding error)
03:05:26 <mgsloan> jeez, whatever happened to UTF8 :)
03:05:35 <quicksilver> mgsloan: UTF8 is a transport format
03:05:35 <opqdonut> > fromEnum 'Ão'
03:05:35 <lambdabot>  Improperly terminated character constant
03:05:45 <opqdonut> yah whatever :)
03:05:53 <quicksilver> mgsloan: it's not a sensible format for fast storing + manipulation
03:05:59 <mgsloan> oh, ok
03:06:12 <quicksilver> you output + input UTF8, but you store internall as 'wide-chars'
03:06:18 <mgsloan> i guess that makes sense, in the context of [Char]
03:06:22 <mgsloan> ah
03:06:28 <quicksilver> normally in 32 bits, mostly because 32bits is a fast data type
03:06:48 <quicksilver> having said that, haskell core has no UTF8 support :)
03:06:52 <quicksilver> but there are at least some libraries which do
03:07:38 <fasta> LeCamarade: I merely use the system as it is intended. I cannot help that it doesn't work.
03:07:50 <mgsloan> right.  that's actually something I've wondered - with 64 bit OS/arch, now is the ideal width 64, or is 32 still good?
03:08:13 <LeCamarade> fasta: I hug the center religiously. Even avoiding -fglasgow-exts. :o)
03:08:36 <quicksilver> mgsloan: the existing 64 bit arches, as far as I know, preserve good speed on 32 bit operations
03:08:49 <quicksilver> mgsloan: just because there is *so much* legacy code out there using 32 bit as a lingua franca
03:08:53 <fasta> LeCamarade: I am using Haskell as a kind of C++ templating mechanism on steroids.
03:09:01 <mgsloan> right
03:10:06 <fasta> So... nobody runs HEAD...
03:10:12 <LeCamarade> fasta: It is that, yeah. Then some. :o) In the C++ days, I wrote some parts to be generic. In the Haskell days, I write some things not to be generic. :o)
03:11:20 <fasta> Wow, the GHC build system has actually become friendly.
03:14:34 <matthew-_> fasta: I run HEAD. I have code that only works in HEAD too
03:17:13 <fasta> An invalid repository...
03:17:24 <fasta> Not good
03:18:35 <fasta> matthew-_: and does the code in that bug report run there?
03:19:09 * matthew-_ scrolls up
03:21:37 <matthew-_> fasta: nope
03:21:58 <matthew-_> fasta: with type sig, all is well, without, "Possible cause: the monomorphism restriction applied to the following..."
03:22:06 <matthew-_> The Glorious Glasgow Haskell Compilation System, version 6.7.20070618
03:24:17 <fasta> matthew-_: and when you add -fglasgox-exts
03:24:34 <fasta> matthew-_: glasgow*
03:24:34 <matthew-_> fasta: ohh sorry. It won't do anything without glasgow-exts
03:25:07 <matthew-_>     Too many parameters for class `Cond'
03:25:32 <matthew-_> which is true - MPTC needs glasgow-exts as do fun-deps
03:25:43 <fasta> matthew-_: but what do you get with that option?
03:26:07 <fasta> matthew-_: for sorear it worked, but for him it also worked in 6.6.1, which it doesn't for me.
03:26:28 <matthew-_> as I said: with glasgow-exts, and type sig on zork, all is well; without type sig it doesn't type check: "Possible cause: the monomorphism restriction applied to the following..."
03:27:26 <fasta> matthew-_: hmm, that is odd, maybe sorear had a newer HEAD.
03:27:40 <matthew-_> for me, with 6.6.1 and glasgow-exts and zork type sig, it all works
03:27:50 <fasta> matthew-_: yes, for me too.
03:28:04 <matthew-_> fasta: quite possibly. I'm not coding at the moment so haven't kept my HEAD up to dat
03:28:05 <fasta> matthew-_: but the point is that the type signature shouldn't be needed.
03:28:05 <matthew-_> e
03:28:18 <matthew-_> fasta: ok, in which case check HEAD!
03:28:28 <matthew-_> it's pretty easy to build these days
03:28:35 <fasta> matthew-_: yes, I am trying to do so now.
03:28:53 <fasta> matthew-_: thanks, anyway
03:28:57 <matthew-_> np
03:34:30 <Ian_P> I have a newbie question if i may ?
03:35:02 <Lemmih> Ian_P: You may.
03:35:57 <Ian_P> thanks: what do i import to use the stuff from Control.Monad.State.Strict
03:36:31 <fasta> :m + Control.Monad.State.Strict works here
03:36:33 <fasta> in ghci
03:36:37 <mauke> Control.Monad.State.Strict would be my guess
03:36:45 <fasta> In a file import Control.Monad.State.Strict
03:36:56 <Ian_P> ok, then i must have some other problem here, cause thats what ive been doing
03:37:04 <fasta> Most likely problem is that you haven't installed it
03:37:15 <fasta> You need the mtl library
03:37:46 <Ian_P> indeed. it doesnt come in the ghc 6.6.1 source tar ?
03:37:52 <fasta> Ian_P: no
03:38:08 <fasta> Ian_P: it's in the extra libs, I think, but I use a package manager
03:38:43 <Ian_P> ah ok thanks. package manage ?
03:38:47 <Lemmih> Ian_P: Are you using ghc or ghci?
03:38:56 <fasta> Ian_P: you use Windows?
03:40:23 <Ian_P> im on linux, ive been using hugs and ghci
03:40:40 <Svrog> dons: who did you say i should talk to about data.binary?
03:41:11 <quicksilver> if your linux is debian you can apt-get install libghc6.6-mtl-dfev
03:41:13 <ttmrichter> You know, I only just discovered how useful GHCi really is today.
03:41:17 <quicksilver> or some package with a very similar name
03:41:26 <ttmrichter> Some day I'll learn to read other people's suggestions.  :)
03:41:30 <quicksilver> if it's not debian, I'm not sure, but likely a similar incantation :)
03:41:34 <Ian_P> thanks ill look into it
03:42:03 <dons> Svrog: kolmodin or dcoutts
03:42:09 <Svrog> ah
03:42:30 <Svrog> thanks
03:43:50 <DRMacIver> I've decided that I'm going to start ignoring the "Don't prematurely optimise" advice.
03:44:21 <DRMacIver> On grounds that the world is full of people who have followed it.
03:44:33 <DRMacIver> Result: Every single application I use is too slow and uses too much memory.
03:45:05 <quicksilver> DRMacIver: (a) I doubt that's the reason (b) I suspect you misunderstand the advice
03:45:21 <fasta> By definition premature is bad.
03:45:58 <matthew-_> git is a classic example of an application that's been prematurely optimised
03:46:01 <fasta> But the idea is that for commercial software development at least there is some phase of optimization, AFAIK.
03:46:10 <dons> DRMacIver: you must use the wrong apps. 0.8% of apps aren't too slow, or use too much memory
03:46:12 <matthew-_> because the usability of git is consequently the worst aspect of it
03:46:24 <quicksilver> DRMacIver: it's a common feeling among (even quite good programmers) "oh, I can make this 10 times faster, I should do that"
03:46:38 <quicksilver> DRMacIver: what they don't realise, is that if the bit you're making 10 times faster is not actaully a bottleneck
03:46:42 <quicksilver> then it quite simply doesn't matter
03:46:43 <quicksilver> not a jot
03:46:47 <DRMacIver> quicksilver: I'm aware of the reasoning behind the advice when it's well applied.
03:47:00 <DRMacIver> quicksilver: But it's a statement which is used as a blanket justification for writing stupid code.
03:47:00 <quicksilver> and, furthermore, you're rather likely to add some bugs in the process
03:47:12 <dons> matthew-_: yeah, git is a great example
03:47:18 <dons> then hmm, contrast with darcs.
03:47:18 <quicksilver> I will not take responsibility for the actions of idiots who misunderstand the advice :)
03:47:27 <dons> not enough optimisation, but a great interface :)
03:47:34 <quicksilver> but I stand by my defence of the advice itself.
03:47:45 <matthew-_> dons: well, the first item in the git faq isn't "why does git hang when merging"
03:48:04 <dons> hah
03:48:17 <mgsloan> :)
03:48:28 <dons> maybe you're just not supposed to merge :-)
03:48:32 <matthew-_> dons: I rather prefer the monotone/mercurial/bazaar design to darcs. Databases are good.
03:48:33 <dons> discipline and bondage!
03:48:53 <dons> oh, darcs is fun.
03:49:05 <fasta> darcs seem to have some very long standing bugs, though.
03:49:11 <fasta> Like the "Illegal seek".
03:49:32 <fasta> Like the creation of "Invalid repositories" out of nothing.
03:49:40 <matthew-_> to be brutally frank, it should be dumped. It does not cut it in comparison to the other DSCMs out there
03:49:46 <fasta> Like no support for UTF-8
03:50:00 <fasta> (and these are only _my_ issues with it)
03:50:13 <dons> development has slowed a bit: http://www.cse.unsw.edu.au/~dons/images/commits/community/darcs-unstable-commits.png
03:50:15 <lambdabot> http://tinyurl.com/3by7lv
03:50:28 <mgsloan> part of my problem with overoptimizing is that I don't have a true grasp of the magnitude of the computational speed of modern computers
03:50:28 <fasta> matthew-_: what is "it"? darcs?
03:50:33 <matthew-_> fasta: yep
03:50:43 <DRMacIver> Premature microoptimations are of course bad. But bottlenecks are in many circumstances an illusion. If every piece of code you write is 100% slower then it might otherwise have been then your application is 100% slower than it might otherwise have been, regardless of where the bottlenecks lies.
03:50:47 <mgsloan> I think the problem is that I know it shouldn't take too much to do what we do...
03:50:55 <dons> well, its fine for small projects. and 90% of haskell projects are small.
03:50:57 <DRMacIver> And when you're going to have certain performance requirements this needs to be reflected at a high level in the architecture.
03:51:05 <dons> in the longer run though, there are issues to solve.
03:51:12 <mgsloan> it shouldn't take 1Ghz to do word processing...
03:51:17 <dons> also, the rest of the distributed rcs systems have caught up to darcs
03:51:25 <dons> so what was revolutionary in 02, is now expected
03:51:35 <dons> so darcs doesnt' seem as amazing as it was
03:51:37 <fasta> What was that argument about 1 zillion C programmers again?
03:51:40 <mgsloan> even if it's a large project, but merges often is it probably ok?
03:51:56 <dons> merges are usually fine.
03:52:00 <mgsloan> merges often = central repo
03:52:04 <matthew-_> mgsloan: indeed. One of the most interesting things is writing games as it starts to make you really understand how much a CPU + GPU can do in 3ms
03:52:05 <dons> for small projects, almost always fine.
03:52:25 <fasta> I don't mind hacking any project, as long as I can load it completely in ghci and run it.
03:52:30 <dons> fasta: what's the argument about 1 zillion C programmers?
03:52:41 <dons> that they can duplicate any haskell program in the end? :)
03:52:45 <fasta> dons: yes
03:52:54 <mgsloan> matthew-_: yeah, i've actually messed with making physics engines. pretty amazing, really
03:53:04 <Tychom> i'm looking at the Data.ByteString manual and all the examples show using Chars as Word8s, whenever i try to input them though ghc complains about incorrect type - is there some conversion i should be doing?
03:53:04 <fasta> Something that doesn't hold for darcs currently in darcs-unstable.
03:53:11 <dons> yeah, darcs had the early lead, at one point ('04?) it was a clear leader, functionally.
03:53:16 <dons> but the rest have caught up now
03:53:29 <dons> Tychom: you want Data.ByteString.Char8
03:53:31 <mgsloan> I like darcs' interactive stuff
03:53:34 <dons> same functions, different element type
03:53:50 <dons> yeah, i'd have a hard time ditching darcs at this point -- unless it was for a large project
03:54:00 <dons> xmonad, for example, has worked really well.
03:54:10 <matthew-_> I think mercurial currently has the edge right now.
03:54:13 <dons> lambdabot too, actually.
03:54:15 <Tychom> cool, that works now
03:54:17 <dons> yeah, that may be true.
03:54:41 <dons> ghc's dev has been growing, i note, http://www.cse.unsw.edu.au/~dons/images/commits/community/ghc-commits.png
03:54:43 <lambdabot> http://tinyurl.com/2yawtw
03:54:45 <matthew-_> only darcs seems to do anything beyond the obvious when it comes to automated merges
03:54:46 <mgsloan> oh, so the issue with darcs is literally that when it gets large, it gets slow?
03:54:52 <dons> i wonder if that's related to the switch to proper email/distributed rcs.
03:54:58 <fasta> dons: how do you make those images?
03:55:06 <dons> mgsloan: no, just the exponential merges seem to hit more often in ghc-sized projects
03:55:13 <dons> fasta: i use 'darcs-graph', a little haskell program
03:55:18 <dons> ?where darcs-graph
03:55:18 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/darcs-graph/
03:55:22 <fasta> dons: what is its input?
03:55:29 <dons> the url of a repo
03:55:30 <fasta> dons: a directory?
03:55:33 <dons> or a local directoy
03:55:37 <fasta> dons: ok
03:55:42 <matthew-_> dons: your challenge is to make that image an svg with nice vector graphics everywheer
03:55:46 <mgsloan> dons - ah. so if you don't do anything too fancy, you're fine?
03:55:51 <quicksilver> mgsloan: it's not that it gets slow, although that may be true
03:55:52 <dons> ?where+ darcs-graph http://www.cse.unsw.edu.au/~dons/darcs-graph.html
03:55:52 <lambdabot> Done.
03:56:04 <dons> mgsloan: yeah
03:56:06 <quicksilver> mgsloan: it's that sometimes it actually hangs (or gets runtimes so long that people won't wait, it's hard to be sure)
03:56:15 <dons> but, say, modifying a large chunk of ghc, and trying to merge the branch == pain
03:56:40 <quicksilver> darcs gets a lot of love from the haskell community, because it's written in haskell, and that's a nice thing
03:56:45 <quicksilver> we're a supportive bunch
03:56:52 <quicksilver> speaking for myself, and myself only, I'm too scared to use it :P
03:56:55 <dons> whereas for a 400-patch project like xmonad, i went away, hacked on my own branch for a week, merged it in with no trouble
03:57:11 <matthew-_> I have to agree with Linus wrt merging - it should not be automated beyond the bleeding obvious - it is without doubt a manual process that must be done by a human
03:57:13 <quicksilver> (I also don't really believe in the patchset model)
03:57:14 <dons> so, your typical open source, 1-5 man project, would have no issue with darcs.
03:57:30 <dons> quicksilver: first class patches change everything though!
03:57:48 <quicksilver> dons: it's a really cute idea, it makes a great topic for discussion
03:57:52 <dons> people send around logical units, that safely apply, instead of diffs to file. completely different abstraction level.
03:57:54 <quicksilver> dons: but I don't believe in it :)
03:58:07 <mgsloan> right, I suppose by the time we hit the 5 man mark darcs'll be fixed :)
03:58:13 <dons> do some projects, with random contributors coming from outside, and you'll love first class patches
03:58:30 <quicksilver> other dvcses have perfectly sane patch contribution too
03:58:35 <thoughtpolice> hopefully the soc will fix some of the more outstanding darcs bugs though.
03:58:37 <matthew-_> I think the problem is that it's trying to fix the wrong problem - the filesystem and files in general are "wrong"
03:58:45 <quicksilver> bzr calls them 'bundles' but I'm sure the others have similars
03:58:48 <thoughtpolice> i'm a fan of darcs but I've really come to like git personally. mercurial too.
03:59:06 <mgsloan> I think a truely good SCM needs to know the language too
03:59:09 <dons> quicksilver: but what's wrong with first class patches? isn't that how we think about the project?
03:59:17 <fasta> mgsloan: so you are in the Smalltalk camp.
03:59:23 <matthew-_> mgsloan: no, I think that's abstraction leakage
03:59:33 <quicksilver> dons: what's wrong, is the implication that the automatic patch dependency stuff is enough
03:59:35 <mgsloan> fasta: perhaps ;P
03:59:39 <fasta> matthew-_: what would be the right solution?
03:59:58 <quicksilver> dons: the darcs model, as I understand it, allows you to cherrypick patches quite arbitrarily if you satisfy their dependencies
04:00:02 <matthew-_> fasta: something involving a rounder wheel!
04:00:05 <quicksilver> dons: I don't believe that's semantically sound
04:00:23 <fasta> What I find completely insane regarding system administration on Debian is that a comment is regarded as a change.
04:00:24 <mgsloan> matthew-_: nah, versioning wasn't meant to be done on text that has semantics beyond natural language attached to it, imho
04:00:36 <fasta> I don't care about comments by the maintainer.
04:00:42 <dons> yes, you can do all sorts of interesting cherry picking
04:00:58 <mgsloan> quicksilver - it might allow you, but then it'd be your fault it doesn't work anymore :)
04:01:02 <dons> quicksilver: have you read swiert et al's patch theory paper/proofs?
04:01:08 <matthew-_> mgsloan: but very few SCMs actually do versioning - it's the hashcode of the file that counts, which is far more robust
04:01:14 <quicksilver> dons: I've skimmed them, not read properly.
04:01:29 <quicksilver> dons: and it was some time ago :)
04:01:56 <quicksilver> mgsloan: I prefer my VCS to work around explicit branches, which have been QAed by their maintainers
04:01:56 <dons> oh, that reminds me, while everyone is here: who's going to hack Control.Comonad into a usable package/
04:02:09 <dons> this src bundle, http://www.eyrie.org/~zednenem/2004/hsce/Control.Comonad.html
04:02:18 <quicksilver> mgsloan: then you have some assurance that the combination is a sensible one
04:02:21 <dons> we *really* should have a comonad lib on hackage.. its embarrassing!
04:02:21 <mgsloan> quicksilver: yeah, I agree that decentralized is unsettling
04:02:30 <quicksilver> mgsloan: I use decentralisation every day
04:02:32 <matthew-_> mgsloan: if you follow your path to its conclusion then you'd end up with "if two functions are computationally equivalent then the SCM should treat them as such"
04:02:34 <quicksilver> mgsloan: but it's controlled
04:03:07 <DRMacIver> matthew-_: I like that idea. Let's implement it. :)
04:03:09 <quicksilver> mgsloan: a branch belongs to a developer, and they are responsible for knowing which revisions (hopefully all!) actually work
04:03:38 <quicksilver> mgsloan: if you want to do something more exotic like a cherrypick from another branch, that is a very concious descision 'these changes may not work against what I have here'
04:03:51 <quicksilver> and, at least in our workflow, it turns out to be a very unsual case
04:03:54 <matthew-_> quicksilver: err you don't subscribe to "code ownership is a bad idea" then?
04:03:56 <mgsloan> matthew-_: well, perhaps semantics is the wrong word.  What I really mean is that your changes have an effect greater than the locale
04:04:15 <matthew-_> DRMacIver: I'll do it tonight.
04:04:22 <quicksilver> matthew-_: not really, in a commercial setting
04:04:48 <mgsloan> quicksilver: sounds good
04:05:12 <matthew-_> quicksilver: yeah, I agree wrt cherrypicking - monotone has only reasonably recently started supporting cherrypicking.
04:05:52 <hpaste>  clemens annotated "little build fix" with "second fix" at http://hpaste.org/1531#a1
04:06:07 <therp> huch, forget about the announcement ^^
04:06:10 <quicksilver> matthew-_: I mean, I do subscribe to some of the principles that code ownership is bad idea, but like most buzzwords it means many things to many people
04:06:31 <quicksilver> matthew-_: let's just say that the parts of it I do subscribe to, I dont' find to be in conflict with the approach I outlined :)
04:07:29 <matthew-_> quicksilver: indeed. I don't like the idea that the branch "owner" should have to remember which revisions work - it should be in tags/meta on each revision and thus distributed throughout - it shouldn't be a memory act
04:07:54 <quicksilver> matthew-_: "remember" may be a bad choice
04:08:01 <matthew-_> ok
04:08:06 <quicksilver> matthew-_: ideally they should only commit code which works
04:08:19 <quicksilver> matthew-_: sometimes, mistakes happen, and when they do they should make the other developers aware of that
04:08:21 <matthew-_> nope. I really disagree with that!
04:08:24 <quicksilver> matthew-_: that's what I was getting at
04:08:44 <matthew-_> I accept you may want integration branches that you only propogate working code to
04:09:04 <matthew-_> but other development branches should certainly not require only working code
04:09:26 <matthew-_> I'm almost in favour of cron jobs to commit on the hour, every hour
04:10:11 <fasta> If your own branch contains code that doesn't compile that's ok, when you find code that you didn't wrote that breaks, you have a nightmare.
04:10:12 <matthew-_> given how easy it is in any decent DSCM to propogate revisions between branches etc, it seems (at least to me) odd to refuse to accept non-working code
04:11:34 <quicksilver> matthew-_: I see zero value in committing every hour, to be honest
04:11:45 <quicksilver> matthew-_: if you want to backup every hour, get a backup program!
04:12:23 <quicksilver> the point of a commit is to mark a semantic point. A point you might want to revert to or compare to later; a point you can describe meaningfully and want to identify in future.
04:12:29 <mgsloan> I think it'd be fun to have micropatches managed by the IDE
04:12:34 <quicksilver> in small projects, I only commit if all tests pass.
04:12:42 <quicksilver> in large projects that doesn't scale, though
04:12:43 <mgsloan> thataway when the project is done you can watch all the changes sped up
04:13:16 <osfameron> with distributed commit, you commit every couple of minutes when things appear to work locally
04:13:29 <osfameron> and then you can merge in when all tests pass
04:13:49 <quicksilver> that's certainly a valid workflow, yes
04:14:01 <quicksilver> I don't think you can claim it's the only valid workflow :)
04:14:20 <fasta> Can I reply to a Trac mail and expect that it ends up in the right Trac ticket?
04:14:30 <quicksilver> I would have thought so
04:15:23 <matthew-_> quicksilver: ok, on the hour every hour is probably taking it too far.
04:16:12 <matthew-_> one of the issues is that a DSCM is a great way to transfer files. Thus if I'm going home from work or onto a laptop or something, I'll commit so that I can then sync and move to the other machine and keep working
04:16:18 <matthew-_> it may well be non-working code
04:16:30 <osfameron> quicksilver: it's a workflow that I would love to be working to right now :-)
04:18:33 <quicksilver> matthew-_: I just use 'cp' or 'rysnc' when I want to copy files
04:18:42 <quicksilver> (what's wrong with existing tools, when they do what you want?)
04:19:15 <quicksilver> I use 'branch' when I want to copy a different version from the one currently visible in the working tree
04:19:35 <matthew-_> err, well if you did that, and then committed on laptop, then when you get back to desktop you'd have to deal with merging
04:19:49 <quicksilver> only if someone else was also working on your desktop
04:20:02 <quicksilver> and, actually, even then it's not a problem
04:20:09 <quicksilver> bzr can quite happily merge into locally uncommitted changes
04:20:43 <matthew-_> yes, it's reasonably rare in that respect I think - iirc, it was one of the first to offer that
04:21:40 <matthew-_> but I would still argue that if a file's in a DSCM, then it's easiest to let the DSCM manage the distribution of said file.
04:21:52 <matthew-_> anyway, this is all slightly off topic for #haskell
04:22:26 <quicksilver> I would argue, that that is not easiest, if it causes you to make a commit which has no semantic significance :)
04:22:32 <quicksilver> I value my commits, they're supposed to mean something
04:22:56 <quicksilver> we're only slightly off-topic, #haskell is frequently prone to any kind of programming-related ramble
04:22:57 <matthew-_> mmm. whilst I would say commits are cheap, just tag meaningfully the ones you care about
04:23:04 <quicksilver> and it's not as if anyone is trying to talk
04:24:45 <matthew-_> also, it's pretty easy to get monotone to select revisions from the db that match a certain certificate
04:25:01 * quicksilver nods
04:25:08 <quicksilver> yes, I agree, it's another workflow choice
04:25:20 <quicksilver> it may be that I over-value commits and thus I hold myself up sometimes
04:26:05 <matthew-_> nah, I think your approach is valid too. I would perhaps wonder if it holds up development in a really rapidly changing project
04:26:34 <matthew-_> is it better to see a partial api that you can start working with even if it doesn't work rather than wait for the "perfect" api to appear?
04:27:02 <quicksilver> yes, definitely
04:27:09 <quicksilver> but that would still be a 'meaningful commit'
04:27:21 <quicksilver> "0.1 of Frooble API so matthew_ can start integration, more changes to come"
04:27:36 <quicksilver> that's more meaningful to me that "commit of broken code so I can sync my laptop"
04:28:38 <matthew-_> ok, the message wouldn't quite look like that, it would be more along the lines of "partial and broken implementation of x, y and z; more to come shortly"
04:29:00 <matthew-_> I suspect we may be violently agreeing with one another ;)
04:37:25 <quicksilver> matthew-_: always the best way
04:37:35 * quicksilver violently agrees with a sandwich
04:39:23 <yakov> hi
04:49:42 <hpaste>  m3hrad pasted "m3hrad" at http://hpaste.org/1533
05:15:35 <erider> good morning
05:24:11 <dcoutts> MarcWeber: good, glad it works ok, if you find out what's going on with nix and think there's anything the Gtk2Hs build system could do better, then send me a note
05:50:21 <Svrog> dcoutts: i woud like to contribute some code to Data.Binary - dons mentioned i should talk to you or kolmodin about it
05:50:29 <Svrog> would*
05:50:49 <dcoutts> Svrog: aye
05:50:57 <Svrog> cool :)
05:51:00 <hpaste>  oops7000 pasted "oops7000" at http://hpaste.org/1534
05:51:05 <dcoutts> Svrog: what is your change about, what is the use case?
05:51:37 <Svrog> i didn't actually change any of the existing code but added a few new modules for pattern matching of binary data
05:52:36 <MarcWebe1> Which event is rizen when a gtk image is resized?
05:53:38 <Svrog> i can send you the code if you're interested in having a look - it's just 4 modules - Data.Binary.Bits, Data.Binary.Bits.Base, Data.Binary.Bits.LittleEndian and Data.Binary.Bits.BigEndian
05:53:42 <dons> Svrog: contribute code too, Data.Binary, or use Data.Binary to add a binary layer
05:54:02 <dons> Svrog: you'd do it in a separate lib, i was suggesting, that would use Data.Binary.Put/Get
05:54:11 <Svrog> ah
05:54:21 <Svrog> fair enough
05:55:14 <dmwit> MarcWebe1: s/image/window/ ?
05:59:08 <MarcWebe1> dmwit: No. Eg there are panes. I want to use gnuplot to create a graphic which I want to show. I want to recreate it when the image widget is resized. (Either because the size of the window has changed or because of sizing the pane splitter etc)
06:10:53 <MarcWebe1> onSizeAllocate seems to work.
06:18:32 <vincenz> @seen jethr0
06:18:33 <lambdabot> I saw jethr0 leaving #oasis 5d 16h 26m 51s ago, and .
06:28:54 <SamB> hmm, you know what I'm wondering?
06:29:24 <SamB> I'm wondering how you can ever render foreign export "wrapper" into ANSI C...
06:29:52 <vincenz> dons: !
06:30:11 <SamB> am thinking it to be impossible
06:31:49 <eivuokko> SamB, Yea.
06:35:17 * SamB almost wonders if it should be stricken from the FFI addendum because of this
06:39:04 <eivuokko> Uhhuh
06:40:00 <eivuokko> That'd make it very annoying to make APIs that implement vtable-style objects.  Like COM.
07:05:54 <gwern> I have a question: in the IO monad, does =<< force stuff to be evaluated?
07:06:16 <matthew-_> @src (=<<)
07:06:16 <lambdabot> f =<< x = x >>= f
07:06:37 <matthew-_> so, it depends on how you think about it.
07:08:21 <quicksilver> gwern: in general, no
07:08:32 <quicksilver> gwern: the only thing that forces stuff to be evaluated is using it
07:08:53 <quicksilver> gwern: the IO monad is strict in side-effects, though, so >>= does force the side-effects to occur
07:08:58 <quicksilver> (unsafeInterleave aside)
07:09:04 <MarcWebe1> How can I get the message of this exception? ./statistik prints statistik: exception :: [Char]
07:09:32 <Saizan> ?docs Control.Exception
07:09:32 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
07:12:23 <MarcWebe1> Saizan: Sorry. I'm lacking understanding. fail "dummy" or something like this results in "user thrown exception ..."
07:12:27 <Saizan> ?type System.IO.Error.ioeGetErrorString <-- this, maybe
07:12:31 <lambdabot> parse error (possibly incorrect indentation)
07:12:42 <Saizan> ?type System.IO.Error.ioeGetErrorString
07:12:44 <lambdabot> IOError -> String
07:15:09 <oerjan> i would say exception :: [Char] implies we are _not_ dealing with an exception in the usual sense, but a String, which can be shown with putStrLn.
07:15:12 <gwern> quicksilver: so things with an IO in the type sig (which is everything with side-effects as I understand) will be forced, but other stuff will be (non)evaluated as usual?
07:15:35 <oerjan> gwern: running and evaluation are separate things
07:16:56 <oerjan> evaluating (x >>= f) may not do much (although I understand in some implementations it evaluates x)
07:17:29 <oerjan> however _running_ it will run x, then run f of the result.
07:17:58 <gwern> hmm. but >>= and =<< don't destroylazy behaivour as part of their normal operation, though, right?
07:18:34 <oerjan> x is only evaluated as much as necessary to perform the action, yes
07:18:50 <ToRA> gwern: compare (return [1..] >>= const (putStrLn "hi")) and (error "hi" >>= const (putStrLn "hi")) in a ghci prompt
07:19:17 <oerjan> so e.g. (return y) as an action does not evaluate y
07:20:32 <nornagon> monads (except for the IO monad) are not magic
07:20:48 <nornagon> they're just a useful set of functions that follow some rules
07:20:49 <pastorn> ?src const
07:20:49 <lambdabot> const x _ = x
07:20:53 <pastorn> whut?
07:21:05 <pastorn> @pl const
07:21:05 <lambdabot> const
07:21:11 <oerjan> nornagon: we _are_ talking about the IO monad here, however
07:21:20 <nornagon> oerjan: true
07:21:26 <nornagon> :t const
07:21:31 <lambdabot> forall a b. a -> b -> a
07:21:50 <nornagon> > const 1 $ undefined
07:21:53 <lambdabot>  1
07:21:55 <ToRA> the alternative was to use >>
07:22:07 <quicksilver> however, even the IO monad is not magic w.r.t. lazy behaviour
07:22:18 <fasta> Spam: Vote for http://hackage.haskell.org/trac/ghc/ticket/1456 by adding your e-mail address to CC
07:22:19 <lambdabot> Title: #1456 (Wrong type being derived) - GHC - Trac
07:22:26 <MarcWebe1> oerjan: Which catch function? Prelude ? Control.Exception ?
07:22:34 <quicksilver> the only magical thing about the IO monad is way it's run
07:22:57 <oerjan> MarcWebe1: i was referring to your original statement
07:23:12 <MarcWebe1> I'll run the code in ghci .. ;)
07:23:33 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1535
07:23:35 <oerjan> MarcWebe1: it had exception :: [Char] in it, which implies exception is a string
07:24:17 <dylan> monads are a path, not a thing.
07:26:17 <oerjan> MarcWebe1: otoh i think other kinds of exceptions are Show instances
07:26:38 <oerjan> @instances-importing Control.Error Show
07:26:39 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
07:27:00 <oerjan> er
07:27:05 <oerjan> @instances-importing Control.Exception Show
07:27:07 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, ArithException, ArrayException, AsyncException, Bool, Char, Double, Either a b, Exception, Float, IOException, Int, Integer, Maybe a, Ordering, Product
07:27:07 <lambdabot> a, ST s a, Sum a, [a]
07:27:34 <oerjan> @instances-importing System.IO Show
07:27:36 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, BufferMode, Char, Double, Either a b, Float, Handle, HandlePosn, IOMode, Int, Integer, Maybe a, Ordering, Product a, ST s a, SeekMode, Sum a, [a]
07:28:22 <oerjan> > undefined :: IOError
07:28:24 <lambdabot>  Undefined
07:28:37 <MarcWebe1> ghci exits as well ;(
07:28:42 <quicksilver> oerjan: maybe that erro means it was  DynamicException?
07:28:59 <quicksilver> oerjan: and the contents of the Dynamic was in fact [Char]
07:29:00 <quicksilver> oerjan: ?
07:29:07 <quicksilver> (I've never seen that error, so I'm guessing)
07:29:18 <pastorn> ?src curry
07:29:19 <lambdabot> curry f x y = f (x, y)
07:29:24 <pastorn> ?src uncurry
07:29:24 <lambdabot> uncurry f p = f (fst p) (snd p)
07:29:25 <MarcWebe1> quicksilver: I'm throwing a dynamic exception. But I've tried flip catchDyn fail $ do  <main> as well
07:29:27 <hkBst> ?src ($)
07:29:28 <lambdabot> f $ x = f x
07:29:36 <oerjan> MarcWebe1: Control.Exception subsumes ordinary IOError, doesn't it.
07:29:39 <MarcWebe1> Anyway: Why does ghci exit?
07:29:48 <sjanssen> @keal
07:29:48 <lambdabot> you need a Zh function in Haskell
07:29:51 <oerjan> so you should be able to use that catch
07:30:13 <pastorn> how do i write const with uncurry and fst? I can't seem to get it right...
07:30:53 <oerjan> :t uncurry fst
07:30:55 <sjanssen> @type uncurry fst
07:30:57 <lambdabot> forall b b1 c. ((b1 -> c, b), b1) -> c
07:30:58 <lambdabot> forall b b1 c. ((b1 -> c, b), b1) -> c
07:31:03 <oerjan> hm...
07:31:08 <oerjan> :t curry fst
07:31:11 <lambdabot> forall a b. a -> b -> a
07:31:14 <sjanssen> actually, we want curry
07:31:28 <ToRA> @pl curry fst
07:31:28 <lambdabot> const
07:31:56 <sjanssen> clever :)
07:32:18 <pastorn> yay
07:32:20 <pastorn> :D
07:32:25 <pastorn> thanks
07:32:34 <oerjan> @quote stereo
07:32:35 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
07:33:06 <hpaste>  dabajuy pasted "dabajuy" at http://hpaste.org/1536
07:33:18 <sjanssen> spam!
07:33:29 <oerjan> SPAM, SPAM, WONDERFUL SPAM!
07:33:41 <sjanssen> what stupid bots
07:34:06 <sjanssen> do they just go around submitting data to any form they can find?
07:35:03 <matthew-_> ahh, it was someone in here that mentioned that blog spam typically scrapes requirements of the form and puts on the entry to porn sites
07:35:40 * dcoutts recalls going shopping with xerox who found spam, bought it and took it home
07:35:45 <MarcWebe1> It's caused by my throwDyn "some string"
07:35:47 <pastorn> @type uncurry (.)
07:35:48 <oerjan> that _does_ mean that a form of the type "Don't submit this or you will be blocked from this site" should work well
07:35:49 <lambdabot> forall b c a. (b -> c, a -> b) -> a -> c
07:36:02 <matthew-_> A friend came up with the idea of including "Enter the URL of this webpage" on the form.
07:36:06 <pastorn> how do i read that? the comma confuses me...
07:36:11 <MarcWebe1> shouldn't  flip catchDyn fail be able to catch it?
07:36:15 <sioraiocht> where's a good arrow tutorial?
07:36:26 <matthew-_> pastorn: it's a tuple with two functions in it
07:36:36 <sioraiocht> for people that have a mere BSc and not a doctorate, pls ;)
07:36:54 <pastorn> matthew-_: oh, cool, didn't see that
07:37:04 <matthew-_> pastorn: so the function would look like \(f, g) -> f . g
07:37:09 <ToRA> > uncurry (.) ((+1), length) "hello"
07:37:11 <lambdabot>  6
07:37:22 <matthew-_> ToRA: do you PhD!
07:37:23 <oerjan> @type catchDyn
07:37:24 <lambdabot> Not in scope: `catchDyn'
07:37:39 <ToRA> matthew-_ :p do yours
07:37:42 * matthew-_ cracks the whip
07:37:43 <sioraiocht> hah is ToRA procrastinating?
07:37:55 <matthew-_> ToRA: I just sent an email. That's mine done for the day!
07:39:21 <oerjan> oh wait
07:40:04 <oerjan> MarcWebe1: each use of catchDyn is tied to a type, i think.  You need to ensure that it actually expects a String.
07:40:21 <vincenz> GTID
07:40:26 <vincenz> or is it GTD
07:41:06 <MarcWebe1> oerjan Exactly. That's why I've used fail :: String -> m ..
07:41:35 <oerjan> fail doesn't throw Dynamic exceptions.
07:42:00 <MarcWebe1> oerjan: No, but the executable will print <name>: user error ("string content")
07:43:39 <hpaste>  Marc Weber pasted "test vs real world - test works - real world not .. bug?" at http://hpaste.org/1537
07:44:15 <MarcWebe1> I can't get the myTrace value either ..
07:48:41 <oerjan> well, you might try throwDyn $! to ensure the myTrace is performed before the throw...
07:48:51 <Tanja> hello
07:49:09 <dcoutts> does anyone want to help me test the Haskell syntax highlighting for the next version of GEdit ?
07:49:25 <Tanja> no
07:49:58 <dcoutts> got any favourite Haskell syntax highlighting bugs that you want to make sure are not present in next version of GEdit ?
07:50:07 <Tanja> fuck me im famous
07:50:38 <MarcWebe1> Hi dcoutts Did you get my messag?
07:50:46 <dcoutts> MarcWebe1: yep, thanks
07:50:54 <gleb> @src inits
07:50:54 <lambdabot> inits []     =  [[]]
07:50:54 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
07:51:32 <dcoutts> MarcWebe1: so if you figure out how to build with nix and have any suggestions to improve the Gtk2Hs build system then just say so
07:51:50 <oerjan> MarcWebe1: ^^^
07:53:16 <MarcWebe1> dcoutts: I'll definitely do that. But I'm struggling with the nix language..
07:53:46 <MarcWebe1> dcoutts: It's my goal to use nix only for installing packages. Because it will work on Windows as well .. (hopefully)
07:54:10 <MarcWebe1> > printf "%s " "abc"
07:54:12 <lambdabot>  Add a type signature
07:54:19 <dcoutts> MarcWebe1: you might want to check it's default linker path, looks like it puts /usr/lib before /lib
07:54:33 <MarcWebe1> :)
07:54:39 <MarcWebe1> > printf "%s " "abc" ::String
07:54:40 <lambdabot>  "abc "
08:01:09 * LeCamarade needs to get a life
08:02:16 <sioraiocht> @src second
08:02:16 <lambdabot> Source not found. It can only be attributed to human error.
08:02:23 <sioraiocht> @src Control.Arrow.second
08:02:23 <lambdabot> Source not found. That's something I cannot allow to happen.
08:02:28 <sioraiocht> -_-
08:02:38 <sioraiocht> @type second
08:02:47 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
08:03:18 <MarcWebe1> When using printf, does the format string has to sepecified at compile time?
08:04:03 <scook0> :t printf
08:04:06 <lambdabot> forall r. (PrintfType r) => String -> r
08:04:09 <MarcWebe1> I'll use a proper parser.
08:04:41 <scook0> I don't think it would need to be
08:05:42 <MarcWebe1> scook0: But I have some trouble.
08:06:15 <scook0> MarcWebe1: what kind of trouble?
08:07:14 <edwardk> MarcWebe1: it doesn't have to be specified at compile time, but note since its use is strongly typed its hard to shuffle the arguments around that you are giving it, but you can swap "%s,%s" for "%s %s' and stuff like that
08:10:05 <MarcWebe1> I know: Trouble:  argument list ended prematurely
08:16:14 <MarcWebe1> But I've checked the list twice and ghci did make it right.. anyway. beeing able to insert the args at abitrary locations is better anyway.
08:22:44 <MarcWebe1> edwardk, scook0: My fault: I tried to use the filename instead of the file contents as format string.. (me feels like beeing a DAU)
08:29:34 <MarcWebe1> Strange. After forcing more strict evaluation by some print statements everything works (I get my exception and it is caught ...)
08:32:18 <pastorn> ?src curry
08:32:18 <lambdabot> curry f x y = f (x, y)
08:49:06 <roconnor> how do I make a sequence of all sequences  of a 4 letter alphabet?
08:49:58 <mrd> enumerate {a,b,c,d}^*
08:50:08 <ndm> roconnor: sequence?
08:50:17 <sjanssen> > sequence "abcd"
08:50:17 <roconnor> infinite list
08:50:18 <lambdabot>  Couldn't match expected type `m a' against inferred type `Char'
08:50:18 <ndm> > sequence ["ab","ab"]
08:50:20 <lambdabot>  ["aa","ab","ba","bb"]
08:50:35 <mrd> a sequence of all sequences of a 4 letter alphabet  would be infinite
08:50:44 <roconnor> I want [
08:50:51 <sjanssen> > mapM (\n -> replicateM n "abc") [0..]
08:50:57 <lambdabot> Terminated
08:51:05 <roconnor> I want ["","a","b","aa","ab","ba","bb","aaa",...]
08:51:10 <chessguy> > [a:b:c:d:[] | a <- "abcd", b <- "abcd" \\ a, c <- ("abcd" \\ a) \\ b, d <- (("abcd" \\ a) \\ b) \\ ]
08:51:10 <lambdabot>  Parse error
08:51:12 <sjanssen> > mapM (\n -> replicateM n "abc") [1..]
08:51:15 <chessguy> > [a:b:c:d:[] | a <- "abcd", b <- "abcd" \\ a, c <- ("abcd" \\ a) \\ b, d <- (("abcd" \\ a) \\ b) \\ c]
08:51:15 <mrd> in lexicographical order?
08:51:17 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
08:51:18 <lambdabot> Terminated
08:52:04 <chessguy> > [a:b:c:d:[] | a <- "abcd", b <- "abcd" \\ [a], c <- ("abcd" \\ [a]) \\ [b], d <- (("abcd" \\ [a]) \\ [b]) \\ [c]]
08:52:07 <lambdabot>  ["abcd","abdc","acbd","acdb","adbc","adcb","bacd","badc","bcad","bcda","bdac...
08:52:37 <chessguy> > length $ [a:b:c:d:[] | a <- "abcd", b <- "abcd" \\ [a], c <- ("abcd" \\ [a]) \\ [b], d <- (("abcd" \\ [a]) \\ [b]) \\ [c]]
08:52:39 <lambdabot>  24
08:52:43 <roconnor> I should get my question right.  I want a stream of all lists of four elements.
08:52:44 <mrd> > "abcd" \\ ['a',b']
08:52:45 <lambdabot>   Not in scope: `b''
08:52:47 <mrd> > "abcd" \\ ['a','b']
08:52:48 <lambdabot>  "cd"
08:53:00 <EvilTerran> roconnor, a finite list, then?
08:53:04 <vincenz> \\ = O(n^2)
08:53:11 <mrd> oh well
08:53:16 <Saizan> chessguy: not all 4-length sequences, but of any size
08:53:17 <mrd> vincenz: n is 4
08:53:25 <vincenz> mrd: for now
08:53:30 <EvilTerran> roconnor, the cartesian product "abcd"^4?
08:53:33 <mrd> roconnor: so you want to enumerate \Sigma^*
08:53:36 <sjanssen> > [0 ..] >>= flip replicateM "abcd"
08:53:37 <lambdabot>  ["","a","b","c","d","aa","ab","ac","ad","ba","bb","bc","bd","ca","cb","cc","...
08:53:44 <mrd> where \Sigma = {a,b,c,d}
08:53:45 <EvilTerran> roconnor, or "abcd"^*?
08:53:45 <roconnor> mrd: that's right
08:53:48 <sjanssen> roconnor: ^^^ is that what you want?
08:54:05 <roconnor> EvilTerran: yes "abcd"^*
08:54:21 <EvilTerran> sjanssen, that's... beautifully done. how does it work?
08:54:26 <roconnor> ... it's really hard to say in english
08:54:37 <roconnor> sjanssen: thanks
08:54:43 <mrd> it chooses from the list "abcd" repeatedly
08:54:53 <byorgey> roconnor: also check out http://www.cs.dartmouth.edu/~doug/nfa.ps.gz
08:55:03 <sjanssen> EvilTerran: 'replicateM n as' gives us all sequences built from 'as' of length 'n'
08:55:25 <EvilTerran> well, that somewhat renders it trivial, i guess
08:55:47 <sjanssen> EvilTerran: the '[0..] >>= ' part does the replicateM for every n >= 0
08:55:51 <EvilTerran> yeah.
08:55:58 <roconnor>  @hoogle replicateM
08:56:04 <vincenz> @type replicateM
08:56:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
08:56:10 <sjanssen> roconnor: Control.Monad
08:56:13 <roconnor> where is it located.
08:56:17 <roconnor> great
08:56:31 <EvilTerran> "replicateM n act performs the action n times, gathering the results."
08:56:55 <chessguy> we need a @quote similar to '@quote stereo', but for questions answered before being asked :)
08:57:01 <sjanssen> > filterM (const [True, False]) "abc" -- need every subsequence?
08:57:03 <lambdabot>  ["abc","ab","ac","a","bc","b","c",""]
08:57:54 <EvilTerran> I am going to have to look at this for a long time before i'll get why replicateM does that...
08:58:06 <Saizan> ?src replicateM
08:58:07 <lambdabot> replicateM n x = sequence (replicate n x)
08:58:08 <chessguy> @src replicateM
08:58:08 <lambdabot> replicateM n x = sequence (replicate n x)
08:58:21 <chessguy> @src replicate
08:58:21 <lambdabot> replicate n x = take n (repeat x)
08:58:26 <Saizan> sequence in the list monad is the cartesian product of the lists
08:58:40 <mrd> > replicateM 4 "abcd"
08:58:42 <lambdabot>  ["aaaa","aaab","aaac","aaad","aaba","aabb","aabc","aabd","aaca","aacb","aacc...
08:58:54 <EvilTerran> @src sequence
08:58:55 <lambdabot> sequence ms = foldr k (return []) ms
08:58:55 <lambdabot>     where
08:58:55 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
08:58:58 <mrd> now do that for every [0..] and concat them. that's what [0..] >>= does
08:59:16 <chessguy> yeah, i suspect sequence is the only complex part of that
08:59:37 <EvilTerran> it's "sequence = cartesian product" that makes me go O.o
08:59:52 <mrd> EvilTerran: list monad is non-determinism
09:00:04 <EvilTerran> yes, yes, i get that bit
09:01:04 <EvilTerran> i can see why it's the right behaviour, but I'm insufficiently familiar with sequence to see immediately why it's the _actual_ behaviour
09:01:33 <mrd> sequence [x1,x2] -- choose an elem non-deterministically from x1 and combine it with an element non-deterministically selected from x2
09:02:04 <Saizan> EvilTerran: sequence [] = return []; sequence (m:ms) = do x <- m; xs <- sequence ms; return (x:xs) -- so for every element x of the first list m, you cons it to all the lists of the recursive case
09:02:39 <ski> sequence [xs0,xs1] = [[x0,x1] | x0 <- xs0 , x1 <- xs1]  -- quite similar to the math definition of cartesian product, no ?
09:03:05 <EvilTerran> Saizan: or, equivalently, sequence (m:ms) = [x:xs | x <- m, xs <- sequence xs] -- in the list monad, anyway
09:03:11 <EvilTerran> I see.
09:05:01 <Saizan> > Prelude.sequence ["abcd"] -- a bit odd in this case
09:05:03 <lambdabot>  ["a","b","c","d"]
09:06:31 <hpaste>  katalove pasted "katalove" at http://hpaste.org/1538
09:08:11 <EvilTerran> ...is there a "report spam" button?
09:11:11 <EvilTerran> @tell glguy hpaste's getting spammed: see http://hpaste.org/1538 http://hpaste.org/1536 etc. maybe time for a CAPTCHA?
09:11:11 <lambdabot> Consider it noted.
09:11:19 <Saizan> he knows
09:11:34 <mdmkolbe|work> > Prelude.sequence ["abc", "def"]
09:11:37 <lambdabot>  ["ad","ae","af","bd","be","bf","cd","ce","cf"]
09:12:00 <EvilTerran> oh right. well, no harm in a little nagging...
09:12:20 * EvilTerran goes back to whatever he was doing
09:12:29 <ndm> its a bit depressing htat people are taking the time to spam hpaste...
09:12:59 <mdmkolbe|work> ndm: is it manual or just a bot that stumbled across the form?
09:13:05 <DRMacIver> It's probably an automated crawler.
09:13:18 <EvilTerran> afaict, it's an automated system that spiders the web, filling out every form it finds in case it's a blog comments system, forum, guestbook etc
09:13:26 <ndm> yay
09:13:32 <Wild_Cat> well, that means that either Haskell is gaining traction, or some spammer who finally figured out that pastebins were abuse-prone stumbled across this one.
09:13:35 <ndm> i'm sure you can work round that with a bit of javascript
09:13:56 <ndm> i.e. have the obsubmit action change the post URL
09:14:08 <EvilTerran> qdb.us gets one, too. although that one's so incompetently done that the messages are half completely meaningless and half meaningful but with the URLs missing
09:14:24 <mdmkolbe|work> second question, is it only one bot or multiple unrelated bots that keep hitting hpaste?
09:14:56 <EvilTerran> ''great site! please visit mine [url=][/url]<a href=""></a>''
09:14:58 <_frederik_> <interactive>: internal error: stg_ap_p_ret
09:15:00 <_frederik_>     (GHC version 6.6.1 for i386_unknown_linux)
09:15:15 <_frederik_> any idea what is wrong?
09:15:28 <EvilTerran> _frederik_, what are you trying to do?
09:15:32 <mdmkolbe|work> _frederik_: paste the source that causes this
09:15:35 <mdmkolbe|work> @hpaste
09:15:35 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:17:19 <hpaste>  _frederik_ pasted "(no title)" at http://hpaste.org/1539
09:18:01 <_frederik_> the problem came up when i added the line:
09:18:03 <_frederik_>     let m_text = (word +++ ((toFromDom >>> hexID) +++ (url +++ host))) >>> readShow
09:18:09 <_frederik_> and related variabels
09:18:13 <_frederik_> les*
09:19:13 <_frederik_> i was hoping someone would know what the problem is, i'm trying to prepare for a conference so i don't really have time to submit a bug
09:21:47 <EvilTerran> http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg09410.html ?
09:21:49 <lambdabot> Title: Re: Mixing registerised and unregisterised builds, http://tinyurl.com/2xvudu
09:22:34 <_frederik_> no i think that is not it
09:22:46 <mdmkolbe|work> _frederik_: did you build the GHC yourself or was it from the distro?
09:23:48 <_frederik_> from debian
09:24:06 <chessguy> hmm, who maintains The Haskell Sequence? it's getting pounded with spam
09:24:12 <mdmkolbe|work> _frederik_: yeah, then EvilTerran's link probably wouldn't apply
09:24:15 <bos> @seen dons
09:24:15 <lambdabot> dons is in #haskell-icfp07, #xmonad and #haskell. I last heard dons speak 3h 30m 12s ago.
09:24:39 <MarcWebe1> dcoutts: Which event can I use to get notified when an image is resized ?
09:25:35 <mdmkolbe|work> _frederik_: unless you're doing something weird that would stomp over memory (e.g. foreign calls, unchecked array accesses (that's maybe not possible anyway)), then this isn't your fault and fixing it would require you to update your compiler to the unstable HEAD or just work around it
09:28:16 <_frederik_> actually it seems that 'rm -f *.o *.hi' did the trick
09:30:34 <_frederik_> thanks for the help
09:33:07 <chessguy> @seen glguy
09:33:07 <lambdabot> I saw glguy leaving #haskell 1d 7h 44m 10s ago, and .
09:40:47 <dcoutts> MarcWebe1: I presume you mean some kind of widget, in which case it's onConfigure
09:49:53 <pitecus_> @hoogle (a -> Maybe b) -> [a] -> Maybe b
09:49:54 <lambdabot> No matches, try a more general search
09:51:34 <mdmkolbe|work> @type \(f :: a -> Maybe b) as -> sequence (map f as)
09:51:38 <lambdabot>     A pattern type signature cannot bind scoped type variables `a', `b'
09:51:38 <lambdabot>       unless the pattern has a rigid type context
09:52:07 <mdmkolbe|work> @type \f as -> sequence (map f as)
09:52:10 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a -> m a1) -> [a] -> m [a1]
09:52:34 <mdmkolbe|work> pitecus_: do you want the first non-Nothing or the last only if everything is Just?
09:53:03 <pitecus_> mdmkolbe|work, the first Just
09:54:25 <mdmkolbe|work> @hoogle Maybe a -> Maybe a -> Maybe a
09:54:26 <lambdabot> Data.Generics.Aliases.orElse :: Maybe a -> Maybe a -> Maybe a
09:54:36 <mdmkolbe|work> @index orElse
09:54:36 <lambdabot> Data.Generics.Aliases, Data.Generics, GHC.Conc, Control.Concurrent.STM
09:54:49 <mdmkolbe|work> @src Data.Generics.Aliases.orElse
09:54:49 <lambdabot> Source not found. Just what do you think you're doing Dave?
09:54:57 <pitecus_> mdmkolbe|work, just found it too :-)
09:55:51 <mdmkolbe|work> @type foldl orElse Nothing
09:55:54 <lambdabot> Not in scope: `orElse'
09:56:01 <mdmkolbe|work> @type foldl Data.Generics.orElse Nothing
09:56:04 <lambdabot> forall a. [Maybe a] -> Maybe a
09:56:29 <mdmkolbe|work> @src foldl
09:56:29 <lambdabot> foldl f z xs = lgo z xs
09:56:29 <lambdabot>     where lgo z []     =  z
09:56:29 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
09:58:49 <rretzbach> Couldn't you just use the MonadPlus and fold mplus?
09:59:34 <mdmkolbe|work> > msum [Nothing, Just 1, Nothing, Just 2, Nothing]
09:59:36 <lambdabot>  Just 1
09:59:41 <mdmkolbe|work> rretzbach: yep
09:59:55 <pitecus_> cool
10:00:11 <rretzbach> Ahh right msum :>
10:00:23 <ivant> does anyone know how to force QuickCheck 2 print the parameters it is passing to the property functions _before_ it actually calls them?
10:00:24 <rretzbach> can msum take a function?
10:01:01 <mehrheit> ?type msum
10:01:03 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
10:01:21 <MarcWebe1> dcoutts How much effort would it be to add GtkExtra widgets?
10:01:23 <sorear> (hello)
10:01:25 <ivant> I have a problem that my property function overflows the stack, thus all the computation stops and I never see the parameters which cause the problem
10:02:15 <mdmkolbe|work> @pl (\f as -> msum (map f as))
10:02:15 <lambdabot> (msum .) . map
10:03:09 <mdmkolbe|work> ivant: Debug.Trace perhaps.  (But only if there's no other way)
10:03:17 <mdmkolbe|work> @index trace
10:03:18 <lambdabot> Debug.Trace
10:04:24 <dcoutts> MarcWebe1: some, what are you after?
10:04:40 <MarcWebe1> At the moment GtkPlot.
10:05:05 <ivant> mdmkolbe|work, that's what I'm looking for: the other way, however Debug.Trace might work for me (I just forgot that it exists) :-)
10:05:08 <ivant> thanks
10:06:15 <dcoutts> MarcWebe1: have you seen http://dockerz.net/twd/HaskellCharts
10:06:17 <lambdabot> Title: HaskellCharts - twd
10:06:32 <MarcWebe1> No, thanks!
10:06:59 <dcoutts> oh?
10:09:47 <dcoutts> MarcWebe1: seems that nobody packages GtkExtra, I suspect it's not used much, especially since most of the widgets it has have better equivalents in Gtk+ itself (except the plot one)
10:10:08 <mdmkolbe|work> dcoutts: do you think that would be a reasonable replacement for gnuplot?
10:10:25 * mdmkolbe|work think's gnuplot's syntax chafes
10:10:27 <MarcWebe1> mdmkolbe|work: Which one? GtkPlot or Chart ?
10:10:48 <mdmkolbe|work> I was looking at Chart
10:10:54 <mdmkolbe|work> http://dockerz.net/twd/HaskellCharts
10:10:55 <lambdabot> Title: HaskellCharts - twd
10:11:07 <dcoutts> mdmkolbe|work: perhaps, it's not got the same feature set as gnuplot
10:11:29 <dcoutts> on the other hand it's probably much easier to extend, since it's Haskell and cairo vector graphics
10:11:52 <dcoutts> which now supports screen, pdf, ps, png and svg output
10:12:57 * mdmkolbe|work adds one more program to his list of things that should be rewritten in haskell b/c they're just a reified algorithm ... someday
10:14:45 <sorear> mdmkolbe|work: which?
10:14:52 <mdmkolbe|work> gnuplot
10:15:35 <mdmkolbe|work> and latex, xpdf, and dot just to name a few
10:15:51 <mehrheit> > show $ 1/0
10:15:53 <lambdabot>  "Infinity"
10:16:10 <mehrheit> > (read "Infinity") :: Double
10:16:12 <lambdabot>  Infinity
10:16:44 <sjanssen> how do I separate documents by blank lines with Text.PrettyPrint.HughesPJ?
10:17:18 <sorear> <$> iirs
10:18:22 <sjanssen> that isn't it
10:20:06 <hpaste>  m2m pasted "m2m" at http://hpaste.org/1541
10:20:59 <hpaste>  jasongold pasted "jasongold" at http://hpaste.org/1542
10:21:07 <EvilTerran> oh, for crying out loud
10:21:34 <EvilTerran> ...wait, is it deleting them itself?
10:21:44 <sorear> No, I'm doing it
10:21:49 <sorear> treble--
10:21:55 <rretzbach> :)
10:22:06 <rretzbach> The sheriff is in the city.
10:22:08 <EvilTerran> ah. you're very quick off the mark, there, sir
10:24:24 <shapr> SHAZAM!
10:24:50 <sorear> @seen treble
10:24:51 <lambdabot> I saw treble leaving #haskell 11h 14m 58s ago, and .
10:24:53 * shapr kills hpaste
10:25:05 <sorear> SO IT WAS YOU!
10:25:07 <sorear> :)
10:25:54 <shapr> bye bye spammers
10:26:04 <pastorn> @where Control.Monad.Cont
10:26:04 <lambdabot> I know nothing about control.monad.cont.
10:26:14 <pastorn> help?
10:26:18 <shapr> hpaste will return when someone has time to add anti-spam features.
10:26:30 <pastorn> i wanna look at the source file and the documentation =)
10:26:56 <shapr> @src Control.Monad.Cont
10:26:57 <lambdabot> Source not found. Do you think like you type?
10:26:58 <shapr> ?
10:26:58 <mrd> spam spam eggs spam
10:26:58 <sorear> pastorn: I sent glguy patches months ago and they still aren't applied.  good luck getting anything in
10:27:13 <sorear> s/applied/applied or rejected/
10:27:18 <shapr> sorear: The repository is on my box, ever heard of Imminent Domain?
10:27:24 <mdmkolbe|work> @doc Control.Monad.Cont
10:27:25 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Cont.html
10:27:49 <pastorn> sorear: ehm... i don't know anything about it... i just wanna see the inner workings and maybe understand 3% of what is in there
10:28:00 <shapr> sorear: You add anti-spam features that work with the most recent HAppS and the most recent hpaste, I'll apply the patches and build && run hpaste, ok?
10:29:36 <mightybyte> Can't you just put a CAPTCHA on hpaste?
10:29:39 <bos> pastorn: just download the ghc sources
10:29:48 <shapr> mightybyte: Good idea! Quick write it and send me patches!
10:29:57 <rretzbach> mightybyte: hpaste.el :'(
10:30:01 <sorear> shapr: http://happs.org/HAppS <- is this the latest?
10:30:19 <mightybyte> shapr: Touche
10:30:24 <shapr> sorear: I think so.
10:30:26 <sorear> mightybyte: If we could tolerate captchas, we'd still be using lisppaste.
10:30:41 <mightybyte> sorear: Ahhh, I'm not familiar with the history.
10:30:43 <sorear> mightybyte: lisppaste's captcha is the very reason hpaste was written
10:30:58 <pastorn> @where ghc
10:30:58 <lambdabot> http://haskell.org/ghc
10:31:48 <shapr> sorear: The simplest solution is a quick hack to remove the announce feature.
10:31:51 <sorear> src/Text/XML/HaXml.hs:30:7:
10:31:51 <sorear>     Could not find module `Text.PrettyPrint.HughesPJ':
10:31:51 <sorear>       it is a member of package pretty-1.0, which is hidden
10:31:52 <mightybyte> sorear: What's wrong with lisppaste's captcha?  Is it the existence or the implementation?
10:31:59 <sorear> mightybyte: Both.
10:32:09 <sorear> shapr: HaXml is broken on head fyi
10:32:13 * sorear uses 6.6.1
10:32:25 <EvilTerran> the quickest fix just for these spams would be to forbid posts with the same username and title
10:32:40 <sorear> EvilTerran: Which is what I'm working on.
10:32:44 <shapr> EvilTerran: Good idea, do it and send me the patch!
10:32:48 <sjanssen> sorear: you honestly expect that HaXml would work after the package split that happened only a couple weeks ago?
10:32:58 <pastorn> i can't seem to find a ghc darcs server...
10:33:02 <EvilTerran> shapr, see sorear. ;P  otherwise, i would.
10:34:32 <EvilTerran> I would investigate a more long-term approach involving an existant spam-filtering library or sth, but it seems you guys have it covered
10:35:29 <shapr> sorear: Is that error with HAppS dev repo?
10:35:45 <sorear> No, that error is with HaXml release 1.13.2
10:35:51 <mightybyte> sorear: Does a captcha make it too onerous to post on hpaste?
10:36:07 <sorear> mightybyte: Yes, especially when you can't read it.
10:36:50 <EvilTerran> unless the spammers are specifically targetting hpaste, it'd be enough to say "please type '23' into this box: [   ]" or something.
10:37:12 <mightybyte> sorear: Oh.  None of the ones at http://paste.lisp.org/ look too hard.
10:37:29 <sorear> mightybyte: Look at the html source
10:37:39 <EvilTerran> mightybyte, what if you're blind?
10:37:54 <sorear> mightybyte: sixty kilobytes of table cell backgrounds
10:38:16 <sorear> mightybyte: Typing "lisp" isn't very onerous, but having to start FF is DEFINITELY
10:38:26 <EvilTerran> sorear, god, that's an ugly implementation
10:39:16 <mightybyte> Wow, that is ugly.
10:40:24 <sjanssen> of course there's nothing stopping us from using a captcha that isn't idiotic
10:40:47 <mightybyte> Yes.  That was implied in my original thought.
10:40:52 <EvilTerran> "what is the value of this randomly-generated haskell expression?" :P
10:44:05 <byorgey> "please reexpress this function in a points-free style"
10:46:32 <mux> hah, I've got a phone call from someone looking web developers, and told him I wasn't interested in that much, and I got to mention that I'm mostly interested in Haskell these days
10:46:38 <mux> the person got it has haSQL
10:46:52 <mux> well, that made me laugh :)
10:48:12 <sorear> @where hslogger
10:48:12 <lambdabot> I know nothing about hslogger.
11:01:26 <rretzbach> http://pastie.caboo.se/75786 -- can someone please tell me how to print such a data structure?
11:01:27 <lambdabot> Title: #75786 - Pastie
11:03:39 <EvilTerran> ?type show
11:03:41 <lambdabot> forall a. (Show a) => a -> String
11:04:09 <EvilTerran> > show 3 ++ "-" ++ show 6
11:04:12 <lambdabot>  "3-6"
11:04:41 <rretzbach> I see, thanks, I'll try.
11:05:14 <EvilTerran> > last "abcd"
11:05:16 <lambdabot>  'd'
11:05:20 <EvilTerran> > init "abcd"
11:05:21 <rretzbach> ha!
11:05:22 <lambdabot>  "abc"
11:05:27 <rretzbach> double-ha!
11:05:31 <shapr> mux: the person asking for you to do web dev offered haSQL?
11:06:04 <mux> shapr: no, she asked me what I was interested into, I said haskell, and she got it has haSQL
11:06:08 <Saizan> > let foo x y | x == y = show x | otherwise = show x ++ "-" ++ show y in concat . intersperse ", " . map (uncurry foo) $ [(1,1),(3,6),(8,11)]
11:06:12 <lambdabot>  "1, 3-6, 8-11"
11:06:24 <EvilTerran> although, as a general rule, you should try to write your algorithms to add or remove items at the start of lists rather then the end
11:06:41 <shapr> mux: Oh, haskell == haSQL?
11:06:42 <sorear> so haSQL isn't a Haskell database interface...
11:06:49 <rretzbach> Saizan: uff
11:06:59 <mux> shapr: yeah
11:07:00 <EvilTerran> in which case, head and tail are the functions you want. or you can use patterns.
11:07:07 <mux> like ha-s-q-l
11:07:48 <EvilTerran> working with the start of a list takes constant time. working with the end of a list takes time proportional to the length of the list.
11:08:42 <rretzbach> I don't really get the curry uncurry stuff.
11:09:07 <EvilTerran> @src curry
11:09:07 <lambdabot> curry f x y = f (x, y)
11:09:10 <EvilTerran> @src uncurry
11:09:10 <lambdabot> uncurry f p = f (fst p) (snd p)
11:13:36 <chessguy> @seen ekidd
11:13:36 <lambdabot> I saw ekidd leaving #haskell 4h 42m 35s ago, and .
11:15:29 <chessguy> it's not possible to enforce things like haskell typeclasses from within a language like javascript, is it?
11:20:42 <int-e> write a haskell interpreter? *ducks*
11:21:08 <Philippa> chessguy: interfaces are related to single parm classes
11:21:30 <chessguy> ...
11:21:46 <Philippa> oh, wait, java/script/
11:21:49 <Philippa> sorry, brain not working
11:21:58 <edward2> =)
11:21:59 <Philippa> no, you can't do much short of requiring the dictionary be passed in
11:22:23 <edward2> you can fake interfaces by checking that all the names required resolve
11:22:34 <chessguy> hmm, you mean like take in a json and validate its fields?
11:24:07 <edwardk> well, like saying something is a monad if it has a return and bind operator, though usually you have to restrict your code to working over objects. I have some lying around for a wide assortment of monads and monad transformers somewhere.
11:26:51 <chessguy> so like validate(obj){ if (!(obj.bind && typeof obj.bind == "function")){ //throw an error } ...
11:26:56 <chessguy> }
11:27:32 <chessguy> and ditto for the other functions
11:28:13 <sorear> Or just let the calls do the checking.
11:28:19 <chessguy> calls?
11:28:37 <sorear> obj.bind(fun) // will throw an error if there is no bind
11:28:52 <chessguy> well, yeah
11:29:23 <chessguy> but then you never get a fundamental definition of a monad anywhere
11:29:51 <sorear> you're thinking too haskelly
11:30:43 <chessguy> true
11:33:18 <chessguy> it's just annoying not having haskell's abstraction abilities handy
11:34:59 <DRMacIver> Philippa: You can even sortof fake multiple parameter type classes in Java. It's just painful. :)
11:35:24 <DRMacIver> (Along with most of the rest of the language. :( )
11:36:58 <mehrheit> > let i = 0 :+ 1 in i**(-i)
11:37:00 <lambdabot>  4.810477380965351 :+ -0.0
11:37:52 <chessguy> @hoogle (:+)
11:37:54 <lambdabot> Did you mean: (:+)
11:37:54 <lambdabot> Prelude.undefined :: a
11:37:54 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
11:38:00 <chessguy> @hoogle :+
11:38:00 <lambdabot> Hoogle Error: Parse Error: Unexpected character ':+'
11:39:13 <dolio> > ask 5
11:39:15 <lambdabot>  5
11:39:27 <mehrheit> ?type ask
11:39:29 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
11:39:34 <rretzbach> Do you write the type of functions at the top of a file or always above the definitions?
11:39:51 * sorear doesn't usually write them anywhere
11:40:05 <sorear> (but when I do, it's right above the equations)
11:42:29 <mehrheit> > (map exp [2, 3, 4]) :: [Float]
11:42:30 <dolio> > (succ `local` succ `local` succ) 5
11:42:31 <lambdabot>  [7.389056,20.085537,54.59815]
11:42:33 <lambdabot>  8
11:43:30 <mehrheit> ?type local
11:43:32 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
11:43:58 <dolio> I'll have to add that to my list of names for composition.
11:44:00 <oerjan> @src local
11:44:00 <lambdabot> Source not found. Take a stress pill and think things over.
11:44:06 <oerjan> @src Reader local
11:44:06 <lambdabot> Source not found. That's something I cannot allow to happen.
11:44:19 <dolio> @src (->) local
11:44:20 <lambdabot> local f m = m . f
11:44:28 <oerjan> @src, my old nemesis, we meet again.
11:44:29 <lambdabot> Source not found. I feel much better now.
11:45:39 <mux> > (succ >>> succ >>> succ) 2
11:45:42 <lambdabot>  5
11:46:29 <dolio> I guess local has a restricted type, though.
11:46:49 <mehrheit> ?type zipWith
11:46:51 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
11:47:19 <mehrheit> > zipWith (:) "Spiel" "werk"
11:47:21 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
11:48:49 <hpaste>  sorear pasted "tst" at http://hpaste.org/0
11:49:02 <mehrheit> > concat $ zipWith (:) "Spiel" (map (:[]) "werk")
11:49:03 <lambdabot>  "Swpeirek"
11:49:53 <araujo> hello
11:50:06 <sorear> hello araujo!
11:50:10 <sioraiocht> hello araujo
11:50:28 <araujo> hi sorear !!!
11:50:32 <araujo> hello sioraiocht !!!
11:50:34 <araujo> :-)
11:50:43 <araujo> how things go on lambda land?
11:51:03 * sorear wonders what 1108 lines of code could be for in hpaste
11:51:19 <sioraiocht> dunno I just signed on, myself.  And have been living in C world for a while, with horrible segfaulting code
11:52:05 <Saizan> sorear: irc and html :)
11:52:07 <shachaf> @ty \f xs ys -> [f x y | x <- xs, y <- ys] -- This is liftM2. Is there a general version of zipWith (which has the same type as liftM2 on lists)?
11:52:10 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> [t] -> [t1] -> [t2]
11:52:23 <araujo> sioraiocht, well, welcome to our functional world!
11:52:27 <crazy_code2> hello everyone
11:52:30 <shapr> hiya
11:52:40 <araujo> hola shapr!
11:52:47 <sioraiocht> I miss last semester, when I was having to program in haskell daily
11:52:50 <sioraiocht> it was so much nicer
11:53:11 <crazy_code2> sioraiocht: where do you study ?
11:53:17 <araujo> sioraiocht, haskell.org is the main site, and feel free to ask questions here :-)
11:53:43 <sioraiocht> crazy_code2: I just graduate from Syracuse University in Syracuse, New York, am summer of coding until I start grad school
11:53:59 <sioraiocht> s/graduate/graduated
11:54:20 <crazy_code2> sioraiocht: great :)
11:54:43 <sioraiocht> crazy_code2: If I can do most of my master's dissertation and phd thesis using haskell, I'll be sooo happy
11:55:04 <crazy_code2> :)
11:56:33 <crazy_code2> actually I am stuck at a stage where I now need to learn monads and other advanced stuff to move aheaf
11:56:36 <crazy_code2> *ahed
11:56:39 <crazy_code2> *ahead
11:57:04 <crazy_code2> Can't find something good to read and understand
11:57:10 <sioraiocht> @where aam
11:57:10 <lambdabot> http://www.nomaware.com/monads/
11:57:11 <sorear> Monads aren't really that hard.  They're no easier or harder than abstract algebra.
11:57:12 <crazy_code2> these complex thingies
11:57:20 <sioraiocht> try that link, crazy_code2
11:57:27 <sioraiocht> I found it to be helpful
11:57:30 <crazy_code2> ok Thank
11:57:49 <sioraiocht> sorear: I know you're trying to be helpful, but some of us struggled through abstract algebra initially, teehee
11:58:59 <crazy_code2> But I have to admit one thing, when one goes through the pain of learning Haskell, everything else becomes very easy to learn
11:59:27 <sioraiocht> crazy_code2: I would agree, and but when one gets to programming in haskell, everything else seems like a huge pain in the ass in comparison
11:59:39 <oerjan> today Haskell, tomorrow cohomology!
11:59:50 <Baughn> crazy_code2: "Learn haskell! Everything else is simple in comparison!"
12:00:14 * sioraiocht doesn't even know what cohomology is.
12:00:21 <crazy_code2> same here
12:00:43 <sioraiocht> Maybe terms like that will seem less daunting by the time I finish my PhD =p
12:01:07 <oerjan> it's something that is even more abstract than monads and also heavily based on category theory
12:01:46 <Baughn> I know what abelian groups are, but cohomology still makes no sense
12:01:57 <oerjan> in fact it was more or less (co)homology that was the reason for inventing category theory in the first place.
12:04:37 <shapr> hola araujo
12:06:53 <sioraiocht> Oh man, wrapping my mind around the basics of category theory was hard enough, hehe
12:07:58 * byorgey needs to go get a decent category theory textbook
12:08:30 <oerjan> actually, i am not quite sure about "more abstract than monads".  i guess both subjects go from "fairly" concrete examples and off the deep end.
12:08:56 <sioraiocht> I was told ARROWS are "more abstract than monads" too
12:09:09 <shapr> More general at least.
12:09:29 <sioraiocht> I still don't quite understand arrows, but I'm getting there
12:09:59 <mux> I finally got monads and arrows the day I realized there wasn't anything left to figure out
12:10:19 <sioraiocht> hah I understand monads; I use them all the time
12:10:23 <Saizan> ?where report
12:10:23 <lambdabot> http://www.haskell.org/onlinereport/
12:10:43 <pastorn> sioraiocht: "Basic Category Theory for Computer Scientists" is good =)
12:13:54 <sioraiocht> it better be for $25 =p
12:14:26 <pastorn> seriously, it's good
12:14:36 <pastorn> it doesn't cover monads thoug
12:14:53 <pastorn> but it covers Functors and Monoids and some other stuff
12:14:54 <sioraiocht> I get monads, I had a series of lectures on them for a class
12:15:24 <pastorn> i lended my copy to a friend a few days ago, so i can't check what else it covers
12:15:27 <crazy_code2> are monads and category theory related ?
12:15:41 <byorgey> crazy_code2: yes.
12:15:52 <byorgey> crazy_code2: monads are actually a concept from category theory.
12:15:54 <kaol> I would think that anything and CT are related
12:15:57 <sioraiocht> crazy_code2: monads are an ordered triple in CT
12:16:29 <crazy_code2> while learning haskell , I didn't come across this term even once
12:17:01 <pastorn> crazy_code2: at chalmers you learn monads in Advanced Functional Programming
12:17:29 <byorgey> crazy_code2: in CT, a monad is usually defined as a functor along with two natural transformations (return and join in Haskell) which satisfy certain laws
12:17:42 <pastorn> in the course Advanced Advanced Functional Programming (AAFP) which is aimed at PhDs and other interested categories are covered
12:18:10 <sioraiocht> yeah, I learned monads in a senior elective on advanced functional programming
12:18:17 <sioraiocht> we didn't get to monoids and arrows, though
12:18:18 <byorgey> advanced advanced?  nice =)
12:18:52 <crazy_code2> good to hear this, is there an e-book available for 'Basic Category Theory for Computer Scientists' ? :p
12:19:06 <sorear> monoids are trivial compared to monads
12:19:14 <sorear> if you can add, you know monoids
12:19:26 <pastorn> crazy_code2: haven't stumbled upon it yet
12:20:30 <sioraiocht> sorear: are there uses of monoids on functional programming?
12:20:55 <shapr> Today's new error: apr_poll: The timeout specified has expired (70007)
12:21:26 <byorgey> sioraiocht: all the time =)
12:21:37 <sioraiocht> byorgey: can you give an example?
12:21:46 <oerjan> example monoid operations: ++, .
12:21:57 <byorgey> sioraiocht: a monoid is just an associative binary operator over some set along with an identity element
12:22:12 <byorgey> sioraiocht: e.g. (+,0) is a monoid over the integers
12:22:24 <sioraiocht> so (++,[]) is a monoid over lists?
12:22:28 <genneth> i think the question is whether there's a situation where identifying something as a monoid buys you anything
12:22:32 <oerjan> @instances-importing Data.Monoid Monoid
12:22:33 <byorgey> sioraiocht: yup =)
12:22:34 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
12:22:47 <sioraiocht> genneth: yes! there you go! WHY does it matter?
12:22:51 <byorgey> genneth: definitely.
12:23:03 <sioraiocht> byorgey: why?
12:23:08 <byorgey> for example, take a look at, um... hold on
12:23:11 <genneth> i'm sure there was a haskell-planet post on this recently
12:23:35 <oerjan> @src Writer
12:23:36 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
12:23:46 <edwardk> genneth: well, if Num didn't exist, then Monoid could have been defined so that 0 and + were monoid operators =) then you'd get to use + for list append, though 0 for [] would be weird =)
12:23:46 <oerjan> @src Control.Monad.Writer.Writer
12:23:47 <lambdabot> Source not found. That's something I cannot allow to happen.
12:24:22 <edwardk> genneth: it also lets you use the Writer monad
12:24:33 <byorgey> hm, I can't find the paper I'm looking for
12:24:56 <genneth> edwardk: elaborate on that point?
12:25:04 <byorgey> but e.g. Monoid is a useful class for specifying the general idea of generating a "summary" value
12:25:19 <edwardk> genneth: the (++,[]) is a monoid thing?
12:25:20 <sioraiocht> summary value/
12:25:36 <edwardk> @src Monoid
12:25:36 <lambdabot> class Monoid a where
12:25:36 <lambdabot>     mempty  :: a
12:25:36 <lambdabot>     mappend :: a -> a -> a
12:25:36 <lambdabot>     mconcat :: [a] -> a
12:25:55 <sorear> yes
12:25:57 <byorgey> for example, using (+,0) could give you the sum of a list; but using (max,-Infinity) gives you the maximum
12:26:10 <edwardk> ([],++,concat) clearly meets those requirements
12:26:40 <sioraiocht> mconcat [1..5]
12:26:47 <sioraiocht> > mconcat [1..5[
12:26:47 <lambdabot>  Parse error
12:26:49 <sioraiocht> > mconcat [1..5]
12:26:50 <lambdabot>  Add a type signature
12:26:57 <sioraiocht> > mconcat [1..5] :: Int
12:26:58 <lambdabot>   add an instance declaration for (Monoid Int)
12:26:58 <lambdabot>     In the expression: mconcat...
12:27:00 <genneth> edwardk: yes -- I know that the Writer satisfies the requirements... but I don't see what it buys me yet.
12:27:11 <edwardk> and if you think about it its notationally consistent to use + for list concatenation, javascript like languages have used it for years. well, the overloading confuses some people, but its still consistent.
12:27:26 <sioraiocht> > mconcat ([1..5] :: [Int])
12:27:27 <lambdabot>   add an instance declaration for (Monoid Int)
12:27:27 <lambdabot>     In the expression: mconcat...
12:27:28 <byorgey> sioraiocht: there's no instance for Monoid Int because there are lots of different possiblilities
12:27:45 <sioraiocht> byorgey: ah, okay, i was wondering how that was going to turn out ;)
12:28:09 <edwardk> genneth: well writer just requires that you have a monoid underneath, you can use any monoid in a writer. writing deltas into a addition monoid, concatenating endomorphisms into an Endo monoid, etc.
12:28:18 <edwardk> so writer is by construction very general
12:28:46 <genneth> i think that finally answers the original question; thank you!
12:29:11 <edwardk> ah sorry, wasn't aware of the full context of the original question
12:29:59 <genneth> edwardk: it's okay -- I was trying to expand sioraiocht's question to what I thought he was really trying to ask. incidentally something i also didn't know the answer to :D
12:30:07 <edwardk> ah
12:30:08 <byorgey> sioraiocht: generally you can declare your own instance (or better yet, create a newtype and make a Monoid instance of that)
12:30:26 <sioraiocht> @src mconcat
12:30:26 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
12:30:35 <sioraiocht> thanks by =)
12:30:52 <edwardk> > mconcat $ map Sum [1..4]
12:30:53 <lambdabot>  Sum {getSum = 10}
12:31:03 <sioraiocht> ah
12:31:11 <sioraiocht> @src Sum
12:31:11 <lambdabot> Source not found. Do you think like you type?
12:31:17 <edwardk> @src Data.Monoid.Sum
12:31:18 <lambdabot> Source not found. My mind is going. I can feel it.
12:31:22 <edwardk> hrmm
12:31:45 <edwardk> > mconcat $ map Product [1..10]
12:31:48 <lambdabot>  Product {getProduct = 3628800}
12:32:02 <edwardk> > mconcat $ map All [True,False,True]
12:32:05 <lambdabot>  All {getAll = False}
12:32:15 <edwardk> > mconcat $ map Any [True,False,True]
12:32:17 <lambdabot>  Any {getAny = True}
12:32:44 <sioraiocht> *sigh* my haskell-mode is being annoying
12:32:54 <byorgey> here's the paper I was looking for: http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
12:32:58 <lambdabot> Title: Finger Trees: A Simple General-purpose Data Structure
12:32:58 <genneth> woah; I wasn't aware that you can treat constructors as an argument
12:33:14 <byorgey> it's a bit dense I suppose but they use monoids in interesting ways
12:33:18 <edwardk> a constructor is just like a function
12:33:48 <edwardk> it just returns a value of the appropriate type when fully applied to all of its arguments
12:34:04 <edwardk> @type Just
12:34:07 <lambdabot> forall a. a -> Maybe a
12:34:35 <genneth> i guess it's obvious when considered... I've just never seen it used
12:34:40 <genneth> @type Sum
12:34:43 <lambdabot> forall a. a -> Sum a
12:35:04 <sorear> @type getSum
12:35:06 <lambdabot> forall a. Sum a -> a
12:35:19 <genneth> are those types, Sum, Product, All, etc. all there just so that they're instances of Monoid?
12:35:24 <edwardk> yeah
12:35:30 <edwardk> they 'tag' which monoid you are interested in
12:35:32 <genneth> cute
12:35:49 <edwardk> since (*,1) is a monoid (+,0) is a different monoid, etc.
12:35:58 <edwardk> and both of those are defined over all Nums
12:36:29 <edwardk> (++,[]) is a monoid, but if i append in the opposite order i get its dual (flip (++),[])
12:36:34 <edwardk> hence
12:36:39 <edwardk> @type Dual
12:36:41 <lambdabot> forall a. a -> Dual a
12:36:56 <edwardk> which tags to say i want to concatenate in reverse
12:37:15 <edwardk> @src Endo
12:37:15 <lambdabot> Source not found. My pet ferret can type better than you!
12:37:18 <edwardk> gah
12:37:25 <oerjan> @type Endo
12:37:27 <lambdabot> forall a. (a -> a) -> Endo a
12:37:44 <edwardk> newtype Endo a = Endo { appEndo :: a -> a }
12:38:11 <edwardk> is basically function composition and identity treated as a monoid.
12:38:34 <edwardk> Dual (Endo Int) is function composition reversed on functions over integers.
12:38:50 <edwardk> so on and so forth
12:39:24 <Saizan> we could just have instance Monoid ((->) a a) where .. no?
12:39:43 <genneth> I believe that's already covered by Endo?
12:39:55 <oerjan> > let Dual (Endo f) = (Dual (Endo (1:))) `mappend` (Dual (Endo (2:))) in f []
12:39:57 <lambdabot>  [2,1]
12:40:21 <edwardk> the 'use a constructor' as a tag thing in monoids is used in other parts of haskell when you could have lots of different choices for a given functor or monad, for example there is an Identity monad to tag when you mean to use it for monad operators
12:40:38 <oerjan> Saizan: no, because -> takes two type arguments
12:41:02 <Saizan> oerjan: uh? i'm giving it 2
12:41:24 <oerjan> a Monoid must have kind * -> *
12:41:34 <Saizan> a Monoid has kind *
12:41:34 <oerjan> er wait
12:42:00 <oerjan> ok, perhaps you could
12:42:02 <edwardk> Saizan: yeah that should work
12:42:06 <dolio> > (const "4" `mplus` const "5") "6"
12:42:07 <lambdabot>        add an instance declaration for (MonadPlus ((->) [Char]))
12:42:08 <lambdabot>     In the e...
12:42:13 <oerjan> but it is not Haskell 98
12:42:19 <dolio> > (const "4" `mappend` const "5") "6"
12:42:21 <lambdabot>  "45"
12:42:27 <oerjan> since you have two equal type variables
12:42:29 <Saizan> oerjan: why not?
12:42:40 <oerjan> i think
12:42:45 <edwardk> instance Monoid (a -> a) where mempty = id; mappend = (.)
12:42:57 <edwardk> mconcat gets defaulted to foldr with those
12:43:31 <dolio> The one that's defined is 'instance Monoid b => Monoid (a -> b) where ...' though, I believe.
12:44:00 <edwardk> dolio: ah now i see the conflict
12:45:05 <Saizan> oerjan: you're right, the variables have to be distinct
12:45:41 <oerjan> yeah, i just checked myself
12:45:50 <edwardk> instance Monoid b => Monoid (a -> b) where mempty _ = mempty; mappend f g x = f x `mappend` g x
12:46:05 <SamB> my favorite application of Monoid (a -> a) is supported by dlist 0.2 anyway
12:46:18 <edwardk> the problem with monoids is that there are so many of them
12:46:49 <SamB> now if only dons would *release* dlist 0.2 ;-)
12:47:57 <edwardk> @src MonadZero
12:47:57 <lambdabot> Source not found. Where did you learn to type?
12:48:14 <edwardk> @src MonadPlus
12:48:14 <lambdabot> Source not found. Just what do you think you're doing Dave?
12:48:28 <kaol> HDBC has no equivalent for $dbh->ping? that's worrisome.
12:48:59 <edwardk> i kind of wish that MonadPlus was just rolled into Monoid
12:49:18 <edwardk> then if you rolled Monoid into the definition for + and 0, then you could have some fun monadic code =)
12:49:46 <edwardk> of course try explaining (return 1 + 0) to someone after that =)
12:50:10 <edwardk> > return 1 `mplus` mzero :: [Int]
12:50:18 <lambdabot>  [1]
12:50:43 <edwardk> for all the wrong reasons =)
13:02:33 <sioraiocht> anyone here had their haskell mode try and use hugs when you only have ghci installed
13:03:50 <Lemmih> sioraiocht: Yes.
13:03:53 <sorear> you might want to select ghci mode
13:03:57 <sioraiocht> how do I do that?
13:04:02 <sorear> M-x customize
13:04:15 <sioraiocht> (i did this once, but I can't remember, and my .emacs file got fuct up)
13:04:51 <sioraiocht> oh dear, any idea what group its under?
13:05:06 <sorear> probably programming :)
13:05:22 <rretzbach> I am in love with haskell-ghci-load-file, so I don't know :\
13:05:32 <sorear> sioraiocht: you can also do M-x customize-group   and use tab completion to find it
13:05:40 <sioraiocht> thanks
13:07:25 <sioraiocht> hrm, it doesn't like using just the program name, do I have to ive the full path?
13:10:09 <rretzbach> How can I check the type of return for a specific Monad?
13:10:56 <kpreid> if you know the monad, you know the type
13:10:59 <kpreid> @type return
13:11:05 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
13:11:09 <kpreid> just substitute m
13:11:55 <rretzbach> That never changes?
13:12:14 <sioraiocht> @src print
13:12:14 <lambdabot> print x = putStrLn (show x)
13:12:22 <rretzbach> I was reading about Monad Transformers.
13:12:41 <rretzbach> And thought they might have a different return.
13:12:56 <oerjan> @type lift return
13:13:00 <lambdabot> forall a (m :: * -> *) (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => t ((->) a) (m a)
13:13:04 <kpreid> No.
13:13:13 <kpreid> When you apply a monad transformer, you get a monad.
13:13:26 <oerjan> er...
13:13:30 <oerjan> @type lift . return
13:13:33 <lambdabot> forall (m :: * -> *) (t :: (* -> *) -> * -> *) a. (MonadTrans t, Monad m) => a -> t m a
13:14:06 <kpreid> @src Monad
13:14:07 <lambdabot> class  Monad m  where
13:14:07 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
13:14:07 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
13:14:07 <lambdabot>     return      :: a -> m a
13:14:07 <lambdabot>     fail        :: String -> m a
13:14:27 <kpreid> That definition says that for any monad, and *only* monads, m, the type of return is a -> m a
13:14:53 <rretzbach> I see.
13:17:13 <Socrates> Hey, is there something in the prelude to convert from a char to an int?
13:17:19 <Socrates> '4' to 4
13:17:36 <kpreid> @type digitToInt
13:17:36 <oerjan> :t fromEnum
13:17:38 <lambdabot> forall a. (Enum a) => a -> Int
13:17:40 <lambdabot> Char -> Int
13:17:55 <Socrates> I tried that, says it's not in scope :(
13:17:55 <kpreid> but perhaps you'd like read instead
13:18:10 <kpreid> Socrates: digitToInt is in Char, not Prelude
13:18:15 <oerjan> it's in Data.Char
13:18:18 <Socrates> Ahh, thanks
13:18:19 <kpreid> but why do you have a Char and not a String?
13:18:55 <Socrates> Um, I have a 1000 digit number as a string as it goes
13:19:26 <kpreid> > read "1000000000000000000000000000000000000000000000000000000000000000000" :: Integer
13:19:27 <lambdabot>  1000000000000000000000000000000000000000000000000000000000000000000
13:19:41 <Socrates> Thanks =)
13:19:52 <kpreid> try read. is it too slow? if not, don't worry about it.
13:20:10 <oerjan> > read ('1':replicate 999 '0') :: Integer
13:20:12 <lambdabot>  1000000000000000000000000000000000000000000000000000000000000000000000000000...
13:20:25 <pastorn> i have an introductory logic book wich covers monadic logic, any relation?
13:21:40 <oerjan> monadic logic is about predicates having only one argument, i think?
13:21:45 <oerjan> so no relation.
13:21:55 <pastorn> ok
13:39:14 <SamB> sorear: I think you were wrong about E.
13:39:29 <sorear> Oh well.
13:39:32 <sorear> It happens.
13:41:39 <shapr> What about E?
13:41:44 <shapr> Did he show up here AGAIN?
13:41:57 <SamB> Main.hello :: âMain.v14.Î (Main.1_nâ·(Main.v14â·*)).Jhc.Prim.IO ()
13:41:57 <SamB> Main.hello = ÎMain.v14.Î»(Main.1_nâ·(Main.v14â·*)).â¦
13:43:04 <SamB> shapr: ... I was referring to the first of JHC's IRs...
13:43:39 <SamB> sorear: can you read that or do you need me to translate into ASCII?
13:44:01 <sorear> Nope, I can read it just fine.
13:44:43 <SamB> observe that E does *not* unify value lambdas and type lambdas
13:45:07 <SamB> at least not in this ultra-pretty syntax
13:45:09 <sorear> there's a very good chance that's just syntax sugar
13:45:25 * sorear reads the pretty printer
13:45:31 <SamB> it must be able to tell the difference *somehow*
13:45:37 <SamB> or else it couldn't *do* that
13:46:29 <sorear> in Henk, special cases are used.
13:46:46 <sorear> any pi-abstraction over a kind is ppr'd as a forall
13:47:07 <sorear> any pi-abstraction where the bound variable is not used is ppr'd as an arrow
13:47:14 <sorear> otherwise, a pi is used.
13:47:20 <sorear> not sure what the story is in E
13:47:28 * sorear is loooking at E/Show.hs
13:48:56 <SamB> sorear: is that where the technicolor-and-unicode pretty printer resides?
13:48:57 <sorear> yup, lots of guards for Pi and Lambda
13:49:08 <sorear> SamB: looks like it.
13:49:30 <sorear> SamB: was a wild guess earlier based on grepping for the name of John's pretty printer lib (DocLike)
13:50:10 <sorear> around line 164
13:59:51 <nowhereman> what a pity, no past thing available
14:00:35 <nowhereman> is it ok, if I write a short part of code here directly?
14:00:46 <sorear> <5 lines is good
14:01:01 <SamB> hpaste is down *again*?
14:01:15 <nowhereman> yeah, maintenance
14:01:27 <sorear> 10:23  * shapr kills hpaste
14:01:27 <sorear> 10:24 -!- hpaste [i=eric@65.254.53.221] has quit [Remote closed the connection]
14:01:27 <sorear> 10:24 < shapr> hpaste will return when someone has time to add anti-spam features.
14:02:23 <nowhereman> class ShowI a where showI :: a -> Int -> String
14:02:24 <nowhereman>  
14:02:24 <nowhereman> instance (ShowI a) => ShowI [a] where
14:02:24 <nowhereman>         showI [] _ = "{ }"
14:02:24 <nowhereman>         showI xs indent = "{\n" ++ (concat (map (flip showI (indent+2)) xs)) ++ "}\n"
14:02:24 <nowhereman>  
14:02:26 <nowhereman> instance (Show a) => ShowI a where showI x indent = (replicate indent ' ') ++ (show x) ++ "\n"
14:03:01 <nowhereman> I use the most brute force options for ghc
14:03:18 <nowhereman> -fallow-undecidable-instances -fallow-incoherent-instances
14:03:35 <nowhereman> but it still doesn't work
14:03:47 <oerjan> that's bound to be ambiguous for lists
14:03:59 <oerjan> where the elements have Show
14:04:00 <sjanssen> nowhereman: what is the error message
14:05:06 <nowhereman> Overlapping instances for ShowI [([(Int, Bool)],[(Int, Bool)],[(Int, Maybe Bool)])]
14:05:37 <nowhereman> but I thought the first one is more specific
14:06:53 <nowhereman> btw, the same error comes for any list
14:07:05 <SamB> yes I think we knew that ;-)
14:07:33 <oerjan> isn't there missing an -fallow-overlapping-instances option?
14:07:43 <SamB> oerjan: true
14:07:52 <SamB> but I don't see how that's going to make his life easier
14:08:12 <sjanssen> nowhereman: does it work with -allow-overlapping-instances ?
14:08:29 <SamB> sure, maybe it will "work"
14:08:32 <nowhereman> I tried that too, but it is actually already implicated by the incoherent-flag
14:09:20 <nowhereman> "The -fallow-incoherent-instances flag implies the -fallow-overlapping-instances flag, but not vice versa." (haskell.org)
14:10:04 <nowhereman> mmh, maybe my version is too old, do you know in which release the feature was introduced?
14:10:38 <nowhereman> mine is "Glasgow Haskell Compiler, Version 6.4.2, for Haskell 98, compiled by GHC version 6.4.2"
14:11:14 <oerjan> well, i guess the problem is that nothing helps if two ways of instancing a type work for the exact same set of types
14:11:35 <oerjan> because then neither is more specific
14:11:52 <Baughn> nowhereman: 6.6.1 is the current version, but there are quite a few API changes in that
14:11:52 <SamB> oerjan: ???
14:11:54 <oerjan> so there is no principled way to select
14:12:24 <SamB> Baughn: they really have to STOP that...
14:12:41 <oerjan> i mean, ShowI a => ShowI [a] and Show [a] => ShowI [a] both work
14:13:13 <oerjan> and then you recurse to select the instances before the =>'s
14:13:21 <nowhereman> it's the same in the example on http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html
14:13:23 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
14:13:25 <oerjan> (this is just my intuitive understanding)
14:13:41 <Baughn> SamB: That would get very messy after a few years, though. API versioning?
14:14:35 <SamB> Baughn: I meant, having x.y.1 have a library incompatible with that of x.y, and x.y.2 having a library that's incompatible with *that* one...
14:15:19 <int-e> eternal incompatibility in theory ...
14:15:42 <SamB> I suppose the logical solution is to eradicate the library
14:15:43 <nowhereman> mmh, so I just have to look for the feature introduction from (7.4.4.3. Overlapping instances)
14:15:44 <Baughn> SamB: It wouldn't be so bad if it were possible to #ifdef on point releases. Increment y
14:15:59 <SamB> Baughn: the trouble with that is that you can't do #ifdef in .cabal files
14:16:13 <oerjan> ending up with either Show a or ShowI a as eventual prerequisite, and there is no way to select one of them.
14:16:32 <SamB> I suppose if all the incompatible changes are *small*, #ifdef would work okay
14:16:58 <int-e> yes, until you have a dozen such libs and support 3 versions of each :)
14:16:59 <Baughn> ..I'm sure there's a good solution to all this, but ghc doesn't implement it
14:17:14 <int-e> then you're back in "portable" C #ifdef hell.
14:17:37 <SamB> but, either they should stand by the promise implied by not being able to tell the difference in an #ifdef, or drop the promise
14:17:47 <sorear> SamB: 6.6.0 is quite compatible with 6.6.1
14:17:59 <Baughn> sorear: lambdabot disagrees
14:18:01 <int-e> cabal configurations will help I hope
14:18:10 <SamB> lambdabot always runs into these problems
14:18:30 <sorear> Baughn: lambdabot imports modules that are for internal use only ;)
14:18:40 <SamB> I think that getting lambdabot to build with the next point release -- using the same cabal file -- should be a prerequisite for doing a release
14:22:09 <nowhereman> I only hat to replace "latest" in the url with the version number ;)
14:22:27 * mdmkolbe|work test his connection
14:22:54 <SamB> mdmkolbe|work: it's not working
14:23:01 <Baughn> SamB: Due to those incompatibilities, I now grok the term "patch space". See, it's good for something.
14:23:17 <SamB> "patch space"?
14:23:49 <Baughn> What you get when you branch lambdabot in incompatible manners
14:24:51 <sjanssen> @botsnack
14:24:51 <lambdabot> :)
14:25:01 <Syzygy-> @botsnack
14:25:01 <lambdabot> :)
14:25:14 <sjanssen> sorear: does lambdabot still have trouble with netsplits?
14:25:24 <sorear> sjanssen: Nope
14:25:41 <Baughn> sorear: Can I make it reconnect when the connection drops?
14:26:00 <sorear> sjanssen: Actually it never did.  But it did have a latent bug with netjoins that I eventually managed to expose
14:26:07 <sorear> Baughn: Yes, ask dons
14:26:18 <SamB> sorear: netsplits are heavily associated with netjoins...
14:26:32 <SamB> @seen SamB_XP
14:26:32 <lambdabot> I saw SamB_XP leaving #haskell-blah and #haskell 5m 13s ago, and .
14:26:43 <sjanssen> sorear: ah.  What do you suppose caused that very long delay?
14:26:45 <Baughn> @seen dons
14:26:45 <lambdabot> dons is in #haskell-icfp07, #xmonad and #haskell. I last heard dons speak 8h 32m 42s ago.
14:26:46 * SamB doesn't get that "and ."
14:27:08 <sjanssen> that bug has been around for ages and ages
14:27:08 <sorear> sjanssen: What delay?
14:27:24 <sjanssen> @botsnack
14:27:24 <lambdabot> :)
14:27:32 <sorear> seems fast to me
14:27:37 <sjanssen> sorear: I saw a 60s delay between @botsnack and response
14:27:42 <sjanssen> I suppose it might be me
14:27:45 <sorear> 14:23 < sjanssen> @botsnack
14:27:45 <sorear> 14:23 < lambdabot> :)
14:27:49 <SamB> sjanssen: I think so, yes
14:27:50 <sorear> same minute
14:28:54 <SamB> I saw it the same *second*
14:31:18 <mdmkolbe|wor1> curses, I knew it was going to drop
14:32:56 <nowhereman> ok, so after my solution doesn't work in 6.4.2 and all newer versions are not available (=hard masked) for gentoo, does anybody know a good-looking show function for lists, which gives you an better inside in longer and complexer data
14:33:27 <SamB> @vixen has dons rebooted you yet?
14:33:27 <lambdabot> <undefined>
14:33:49 <SamB> @version
14:33:49 <lambdabot> lambdabot 4p534, GHC 6.6 (Linux i686 2.66GHz)
14:33:49 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
14:33:57 <mdmkolbe|wor1> (This is more of a darcs question, but #darcs seems to be asleep) Is there a way to change a file after I've started a darcs record but before I finish?  (As I was reviewing the patches I found a minor tweak I want to make.)
14:34:18 <Heffalump> finish the record and then use amend-record
14:34:49 * Heffalump continues any further discussion on #darcs
14:34:58 <Baughn> mdmkolbe|wor1: Or abort the record and do it again later
14:36:04 <SamB> I'd do what Heffalump says personally
14:36:18 <Baughn> FWIW, so would I.
14:36:19 <SamB> unless it was really short
14:36:44 <Baughn> Even if it was really short. There's no downside to amend-record
14:37:03 <SamB> well, okay, in theory I would do that. in practice I might forget ;-)
14:44:26 <chessguy> @quote theory
14:44:27 <lambdabot> edwardk says: i love haskell, its the only language where a working knowledge of category theory is required to truly comprehend hello world.
14:51:20 <sieni> @quote chessguy
14:51:20 <lambdabot> chessguy says: heh. i think i'm officially addicted. i'm chatting in #haskell, helping hack on a haskellwiki page, browing a reddit thread about haskell, while playing a haskell video lecture in the
14:51:20 <lambdabot> background
14:54:29 <dibblego> if Haskell were to be rewritten, would if be replaced by if' ?
14:54:36 <dibblego> or is there some advantage to if?
14:54:59 <Cale> dibblego: "if ... then ... else ..." more clearly delimits the branches
14:54:59 <Baughn> dibblego: It looks better
14:55:03 <sjanssen> dibblego: fewer parens
14:55:15 <dibblego> I suppose
14:55:20 <Baughn> dibblego: I just wish iff was in the prelude
14:55:32 <mehrheit> :t iff
14:55:34 <lambdabot> Not in scope: `iff'
14:55:37 <Cale> if'
14:55:40 <Cale> :)
14:55:50 <dibblego> Baughn, if and only if?
14:56:00 <Cale> iff would be if and only if :)
14:56:08 <sjanssen> I think the Prelude should have 'bool' -- the catamorphism on Bool
14:56:27 <Cale> hehe, rename foldr to 'list'
14:56:32 <sjanssen> it is one of the few Prelude types missing a catamorphism
14:56:33 <Baughn> dibblego: It makes a better name than if'. Faster to type, too.
14:56:43 <dibblego> re fewer parens, Scala does not have then, but instead uses parentheses - there was a debate a few weeks ago about which is preferred
14:56:52 <mehrheit> isn't if already if and only if?
14:56:54 <dibblego> s/then/them
14:57:22 <Cale> mehrheit: if is if-then-else, which is quite different
14:57:26 <Baughn> mehrheit: Yes, but if is syntax; iff is a function
14:57:44 <Cale> iff is a logical operation in mathematics
14:58:00 <Cale> We already have == though
14:58:07 <Cale> so we don't need another name for it
14:58:23 <dibblego> that's what I was thinking
14:58:29 <mdmkolbe|wor1> "if'" === "\x y z -> if x then y else z" ??
14:58:38 <dibblego> iff is a biconditional, which is just equality afaik
14:59:19 <dibblego> mdmkolbe|wor1, I'd imagine it takes an additional Bool argument
14:59:46 <mdmkolbe|wor1> @type \x y z -> if x then y else z
14:59:48 <lambdabot> forall t. Bool -> t -> t -> t
15:00:12 <mdmkolbe|wor1> dibblego: what would the extra bool do?
15:00:15 <oerjan> @type maybe
15:00:17 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:00:19 <dibblego> @type \w x y z -> if w == x then y else z
15:00:21 <lambdabot> forall t a. (Eq a) => a -> a -> t -> t -> t
15:00:27 <dibblego> er
15:01:35 <Cale> @pl \x y b -> case b of False -> x; True -> y
15:01:35 <lambdabot> (line 1, column 27):
15:01:35 <lambdabot> unexpected ">" or "-"
15:01:35 <lambdabot> expecting variable, "(", operator or end of input
15:01:54 <Cale> @pl \x y b -> if b then y else x
15:01:54 <lambdabot> flip (flip . flip if')
15:02:01 <mdmkolbe|wor1> @pl \x y b -> case b of {False -> x; True -> y}
15:02:01 <lambdabot> (line 1, column 21):
15:02:01 <lambdabot> unexpected "{"
15:02:01 <lambdabot> expecting variable, "(", operator or end of input
15:02:13 <mdmkolbe|wor1> @type if'
15:02:15 <lambdabot> Not in scope: `if''
15:02:17 <Cale> It doesn't parse case
15:02:33 <Cale> if' is a folk-function :)
15:02:54 <Cale> if' b t e = if b then t else e
15:03:11 <fasta> How do you find out where a given constraint is coming from?
15:03:42 <oerjan> with the usual scheme around here, if' and bool would be in Data.Bool i guess
15:03:57 <fasta> I suppose this counts as editor support, but the compiler can help too.
15:04:09 <dibblego> oerjan, what is bool?
15:04:27 <oerjan> bool x y b = if b then y else x
15:05:24 <oerjan> hm, Data.Bool exists but those functions aren't there
15:05:43 <oerjan> only copies of Prelude functions.
15:05:58 * shapr strikes with great evil!
15:05:59 <dibblego> oerjan, have you read http://www.haskell.org/haskellwiki/If-then-else ?
15:06:00 <lambdabot> Title: If-then-else - HaskellWiki
15:06:28 <mdmkolbe|wor1> oerjan: why wouldn't that be "bool x y b = if b then x else y"?
15:07:12 <Cale> Some people just really hate syntax sugar. Those people should probably be using lisp. :)
15:07:42 <oerjan> mdmkolbe|wor1: because in a catamorphism, the options should be in the order of the datatype definition, and False is before True. or so i believe.
15:07:50 <oerjan> @src Bool
15:07:51 <lambdabot> data Bool = False | True deriving (Eq, Ord)
15:07:56 <mdmkolbe|wor1> Cale: heh, then they end up writting macros (i.e. syntactic sugger)
15:08:04 <shapr> So, Data.Typeable is essentially just a way to have types as values, yeah?
15:08:27 <mdmkolbe|wor1> shapr: that and a way to have type safe casts
15:08:38 <shapr> mdmkolbe|wor1: ok, thanks.
15:08:39 <mdmkolbe|wor1> @src Typeable
15:08:39 <lambdabot> Source not found. My pet ferret can type better than you!
15:09:01 <mdmkolbe|wor1> shapr: mostly it's the 'cast' part of the Scrap your boilerplate papers
15:09:17 <shapr> I am going through this for SYB background reading :-)
15:09:31 <shapr> I want to make sure I understand everything thoroughly.
15:09:38 <shapr> g'day seafoodX
15:09:52 <seafoodX> shapr: Hi there. It's been years!
15:09:56 <seafoodX> Since we spoke that is.
15:10:38 <oerjan> dibblego: did now
15:10:39 <pastorn> did you bang his wife or something?
15:10:48 <pastorn> :p
15:11:15 --- mode: ChanServ set +o shapr
15:11:21 * pastorn has always wanted to use that term...
15:11:37 <shapr> pastorn: hey be nice.. especially to ops.
15:11:43 <pastorn> hehe
15:11:45 <pastorn> sorry
15:11:50 <shapr> seafoodX: Yeah, how's code treating you?
15:11:51 <pastorn> oh, you are the ONLY op
15:11:59 <shapr> seafoodX: Are you professional Haskeller these days?
15:11:59 --- mode: ChanServ set +o Cale
15:12:05 <Cale> hehe
15:12:07 <shapr> pastorn: Look, there's more!
15:12:07 * pastorn hides in a corner
15:12:12 <matthew-_> and then there were two!
15:12:15 --- mode: Cale set -o Cale
15:12:23 <seafoodX> shapr: Sadly I'm only a profression OCamler these days.
15:12:38 <shapr> pastorn: I do have the distinction of being the guy who joined #haskell when it had zero users.
15:12:40 <seafoodX> Please don't kick me off the channel ;-)
15:12:45 --- mode: shapr set -o shapr
15:12:52 <shapr> seafoodX: Nah, professional FP is all good here.
15:12:55 <matthew-_> shapr: you must have a long uptime!
15:12:59 <shapr> seafoodX: Are you working for Jane's, or who?
15:13:36 <shapr> matthew-_: Er, something like that.
15:13:44 <seafoodX> shapr: Nah, on a static analysis  tool in Australia for NICTA.
15:13:44 <shapr> matthew-_: Insomnia will do that.
15:13:57 <shapr> seafoodX: Oooh, tell me more! (If it's not NDA'd)
15:14:02 <pastorn> seafoodX: NICTA?
15:14:39 <seafoodX> shapr: I will tell you more some time. But right now, gtg.
15:14:46 <shapr> seafoodX: nice to talk to you, bye!
15:14:51 <sorear> pastorn: /msg chanserv access #haskell list
15:15:26 --- mode: ChanServ set +o sm
15:16:17 <Cale> See, there are lots of ops in this channel, they just don't usually +o themselves :)
15:16:24 <pastorn> oh
15:16:27 <shapr> Stealth ops!
15:16:46 <sorear> sm isn't in the access list though :)
15:17:31 <shapr> But he is a cool guy.
15:18:24 * sorear notes that competence is generally inversely proportional to nickname length
15:19:02 <pastorn> z` must be awesome
15:19:52 <dmead> allo channel
15:19:57 <shapr> allo!
15:20:01 <dmead> alllllllloooo
15:20:22 <pastorn> anyone here studied model theory?
15:20:31 <pastorn> as in structures as in logic
15:20:36 <Cale> pastorn: I have, quite a while ago.
15:20:40 <sorear> no, but I think I've figured out what it is anyway
15:20:46 * dmead hasn't programmed at all in over a month
15:20:54 * dmead feels greeeeeeeeeeeeat
15:20:58 <Cale> (and it was just an elementary course on it)
15:21:09 <pastorn> Cale: I have a little too, but i was wondering, are there any real world applications of any results?
15:21:24 <pastorn> like categories and monads for example...
15:21:29 <Cale> pastorn: Well, you can easily show that there's a nonarchimedean field :)
15:21:37 <Cale> (ordered field)
15:22:01 <pastorn> hmmm... i don't remember the term "field", though i did my studies in swedish
15:22:15 <Cale> How about "ring"?
15:22:46 <SamB> Cale: maybe you should display the axioms?
15:23:07 <pastorn> isn't that a part of "modern algebra"?
15:23:10 <Cale> yes
15:23:56 <oerjan> pastorn: kropp?
15:23:58 <shapr> dmead: How can you survive a whole month without programming?
15:24:32 <Cale> Yes, kropp.
15:24:58 <pastorn> oerjan: don't remember, thoug i only took a VERY basic course
15:25:22 <Cale> In German, it's KÃ¶rper, and in French, it's Corps.
15:25:24 <oerjan> (that's the norwegian word anyhow)
15:25:46 <pastorn> Cale: you seem to have an unhealthy amount of knowledge
15:26:27 <Cale> I have a BMath.
15:26:38 <Cale> (in pure mathematics)
15:26:44 * sorear misread that badly :)
15:26:57 <pastorn> "BMath"?
15:27:02 <sorear> yeah
15:27:08 <Cale> Bachelor of Mathematics degree.
15:27:14 <desrt> Cale; word.
15:27:23 <pastorn> is that three years or...?
15:27:25 <Cale> desrt: emacs
15:27:29 <Cale> 4 years
15:27:31 <desrt> vim!!!!
15:27:31 <pastorn> oh
15:27:35 <Cale> desrt: hehe
15:27:45 <pastorn> VI VI VI - the editor of the beast
15:27:52 * desrt laughs
15:28:13 <pastorn> Cale: what do you mean by "pure mathematics"?
15:28:22 <Cale> pastorn: The opposite of applied mathematics
15:28:34 <Cale> i.e. you don't care at all about the real world
15:28:35 <pastorn> cool, exactly what i like too =)
15:28:37 <desrt> pastorn; for most purposes it means there is less than 0.1% impurities
15:28:42 <weitzman> Mathematics for people who don't want to have a job at a company, ever
15:28:53 <pastorn> like me :D
15:28:53 * qwr . o O ( emacs - ctrl-alt-shift-hell )
15:28:59 <desrt> weitzman; because the CIA/NSA snaps them up too fast :)
15:29:00 <Cale> weitzman: hehe, things seem to be working out that way for me :)
15:29:15 <pastorn> i was thinking of going abroad for a year studying only math
15:29:16 <desrt> qwr; emacs- escape meta alt control shift
15:29:28 <weitzman> Seems like the math/cs field that can get you a lot of work today would be machine learning
15:29:29 <Cale> I'm pretty much ready to give up on this real-world thing and start looking for graduate positions again.
15:29:49 <desrt> Cale; what happened with you and christopher?
15:30:01 <desrt> last i heard from you you were planning to join us
15:30:22 <pastorn> or maybe do another six months of logic =)
15:30:37 <Cale> desrt: Yeah, but I decided that I was pretty burnt out and wanted to get a job for a while and then go travelling, but there are no jobs in my area, so I'd have to move anyway.
15:30:48 <desrt> ah
15:30:54 <desrt> go work for maplesoft
15:30:58 <desrt> i'm sure you'd love that
15:31:19 <Cale> So I've been studying algebraic combinatorics with my friend from Australia (who incidentally came to visit a few weeks ago)
15:31:36 <Cale> and perhaps I'll find some grad student position working on that sort of thing
15:31:36 <weitzman> I once tried to take a course from the guy who wrote the mathematica integration algorithms, but I quickly dropped it
15:31:51 <Cale> hehe, symbolic integration is insane :)
15:31:52 <weitzman> So I can only assume working for Wolfram could satisfy a mathematician
15:32:23 <weitzman> I think the problem for me was that despite the lack of prereqs, the prof was assuming a certain mathematical background that I lacked
15:32:33 <Cale> There's a lot of pretty tricky mathematics involved.
15:32:50 <weitzman> Anyway, I still haven't got around to figuring out what a greobner basis is
15:32:53 <weitzman> But one day
15:32:55 <weitzman> One day I will know
15:33:02 <Cale> I think it largely goes by way of insanely general hypergeometric functions.
15:33:27 <Cale> http://en.wikipedia.org/wiki/Meijer_G-function
15:33:30 <weitzman> The course was actually extremely focused on only the problem of turning sums into closed forms
15:33:40 <Cale> ah, okay
15:33:44 <weitzman> Because apparently learning anything else would take too long
15:33:49 <Cale> For polynomials in the index, that's not so bad.
15:37:28 <shapr> desrt: Dude, I haven't seen you in months! What's up with your life?
15:37:51 <desrt> shapr; grad school now
15:38:02 <desrt> shapr; but the past little while i've been hacking like mad on some side projects
15:38:05 <shapr> Doing FP for grad stuff?
15:38:09 <desrt> nah :/
15:38:36 <desrt> right now i'm playing with some timing specification stuff for hard realtime systems
15:39:56 <desrt> what are you up to these days?
15:45:42 <shapr> desrt: Professional Haskeller, it's cool
15:46:21 <desrt> who do you work for?
15:46:41 <shapr> HAppS, aka alexj aka Alex Jacobson
15:46:58 <desrt> erm
15:47:05 <desrt> maybe it's better if i ask what company/what do you do?
15:47:31 <shapr> desrt: Are you using type safety to get hard realtime guarantees?
15:47:48 <shapr> desrt: HAppS LLC, and I hack on a web application framework.
15:47:50 <desrt> shapr; in the sense that in assembly everything is an integer: yes
15:47:54 <shapr> ouch
15:48:08 <desrt> :)
15:50:09 <treble> Does anyone know if Visual Haskell works with VS2005 Express?
15:50:51 <treble> nvm
15:50:56 <treble> I checked the manual
15:51:00 <dibblego> what's the answer?
15:51:26 <shapr> y0 treble, are you glguy 2.0 ?
15:51:55 <treble> and it said no
15:52:20 <treble> shapr: kind of? I use both still
15:53:25 <Socrates> If I had an Int, say 250 and I wanted to return the last 2 digits only as an Int (50), what would be the best method?
15:53:43 <dibblego> ?type mod
15:53:45 <lambdabot> forall a. (Integral a) => a -> a -> a
15:53:51 <dibblego> > 250 `mod` 100
15:53:53 <lambdabot>  50
15:53:58 <Socrates> Er, no, you misunderstand
15:54:05 <Socrates> For any Int
15:54:12 <Socrates> So, 435 would return 35
15:54:19 <sjanssen> > 435 `mod` 100
15:54:19 <dibblego> > 435 `mod` 100
15:54:21 <lambdabot>  35
15:54:22 <lambdabot>  35
15:54:24 <Socrates> Ahh
15:54:30 <Socrates> Silly me, thanks =)
15:54:31 <dibblego> @let anyInt = \x -> x `mod` 100
15:54:33 <lambdabot> Defined.
15:54:37 <dibblego> > L.anyInt 435
15:54:39 <lambdabot>  35
15:54:50 <dibblego> @pl \x -> x `mod` 100
15:54:50 <lambdabot> (`mod` 100)
15:55:03 <oerjan> actually...
15:55:11 <sjanssen> > (reverse . take 2 . reverse . show) 435
15:55:13 <oerjan> > (-435) `div` 100
15:55:13 <lambdabot>  "35"
15:55:15 <lambdabot>  -5
15:55:24 <oerjan> > (-435) `mod` 100
15:55:25 <lambdabot>  65
15:55:30 <oerjan> > (-435) `rem` 100
15:55:32 <lambdabot>  -35
15:55:44 <Socrates> Fortunately, it doesn't need to handle negatives ;o
15:55:53 <pastorn> my favourite:
15:55:55 <oerjan> good :)
15:56:27 <pastorn> @pl (\(a,b) (x,y) -> (a + x, b + y))
15:56:28 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
15:56:44 <Vulpyne> The goggles, they do nothing.
15:56:57 <shapr> treble: glguy = treble@work ?
15:57:04 <oerjan> i just keep thinking there _has_ to be a way to make that simpler using arrows or something.
15:57:04 <SamB_XP_> Vulpyne: switch them to ML mode
15:57:40 <Lemmih> glguy works at Galois?
15:58:00 <sjanssen> @type (+) *** (+)
15:58:02 <lambdabot> forall a a1. (Num a, Num a1) => (a, a1) -> (a -> a, a1 -> a1)
15:59:01 <Vulpyne> ML's too ugly for me.
15:59:48 <oerjan> hm...
15:59:57 <SamB_XP_> Vulpyne: but the lisp mode is buggy
16:00:36 <sorear> Lemmih: He can see SyntaxNinja at work.  (I think that answers your question but I'm not sure)
16:00:38 <Vulpyne> I'm allergic to parenthesis, anyway.
16:01:25 <SyntaxNinja> treble: yeah, so why all the different nicks
16:01:50 <SyntaxNinja> and how come no one hangs out on the work IRC server?
16:03:25 <shapr> SyntaxNinja: Get SPJ on the work IRC server, that should help :-)
16:03:54 <SyntaxNinja> hehe
16:04:50 <Socrates> :r
16:04:53 <Socrates> Whoops.
16:05:15 <sjanssen> #haskell is not ghci :)
16:05:32 <sorear> SPJ is at galois?
16:05:44 <Socrates> Yeah, alt+tabbed without paying any attention
16:06:25 <shapr> sorear: I hear rumors that Galois is buying out a chunk of Microsoft Research, since that's where the potential for World Domination really exists.
16:06:59 <sorear> Socrates: That's actually pretty safe, by #haskell standards.
16:07:32 <sorear> /var/cache/stefan-downloads/irclogs/www.cse.unsw.edu.au/03.05.19:19:30:39 * ozone ickserv identify zxcmn7
16:08:04 <Socrates> Heh
16:08:20 <sorear> /var/cache/stefan-downloads/irclogs/www.cse.unsw.edu.au/03.05.19-19:30:50 * Pseudonym knows ozone's password!
16:10:28 <dons> moin moin
16:11:38 <sorear> flippi
16:13:29 <sorear> dons: hpaste has more loc than xmonad
16:14:42 <monochrom> @type flip pi
16:14:45 <lambdabot> forall a b c. (Floating (a -> b -> c)) => b -> a -> c
16:21:48 <bos31337> @seen dons
16:21:48 <lambdabot> dons is in #haskell-icfp07, #xmonad and #haskell. I last heard dons speak 11m 20s ago.
16:30:30 <int80_h> crap
16:30:39 <int80_h> hpaste seems to be down
16:30:52 <int80_h> would anyone mind if I pasted a small amount of code to the channel?
16:31:10 <treble> !paste
16:31:21 <fatalis> I mind so much that I'll just leave now!
16:31:26 * int80_h cries
16:31:44 <oerjan> interesting - taking hpaste down may actually increase the amount of spam here :D
16:31:55 <treble> oh, that was intentional?
16:32:00 <int80_h> I won't spam :)
16:32:05 <oerjan> they said so
16:32:09 <treble> oh :(
16:32:14 <int80_h> I'll wait until someone gives me permission
16:32:43 <int80_h> hpaste is down for god?
16:32:50 <oerjan> there are other pastebins.  pastebin.ca for example.
16:32:51 <SamB_XP_> treble: weren't you suppoesd to talk to shapr or something?
16:32:52 <int80_h> erm good?
16:33:04 <oerjan> no, until someone manages to add anti-spam features
16:33:13 <SamB_XP_> int80_h: they mumbled something about "until someone comes up with a plan for spam"
16:33:28 <treble> who is this ambiguous they?
16:33:42 <oerjan> shapr i think
16:33:43 <SamB_XP_> I forgot ;-)
16:34:28 <int80_h> hmm I'll bet lisp has a nice pastebin
16:34:30 <int80_h> brb
16:35:13 <int80_h> #lisp has a spamming solution
16:35:25 <int80_h> how do I get mail to shapr?
16:35:43 <int80_h> they make you type in characters that appear on the page
16:35:59 * SamB_XP_ thought that was exactly why we switched to hpaste
16:36:17 <int80_h> I don're remember his being there last year
16:36:21 <oerjan> indeed that's what i heard too
16:36:31 <treble> I'd have made changes already if I could compile hpaste :)
16:36:38 <SamB_XP_> we used to use lisppaste here
16:38:13 <treble> hey... does anyone know if data types without data constructors are supported in ghc 6.2?
16:38:22 <treble> (using glasgow-exts)
16:38:22 <SamB_XP_> they are
16:38:24 <int80_h> okay well this problem is probably embarrasingly obvious but I will post anyway
16:38:29 <SamB_XP_> wait, 6.2?
16:38:31 * SamB_XP_ isn't sure
16:38:41 <SamB_XP_> reminds me what 6.2 is?
16:38:47 <treble> ghc
16:39:00 <SamB_XP_> you said that already
16:39:14 <treble> ah
16:39:24 <SamB_XP_> but... I don't remember 6.2 very well
16:40:09 <sorear> int80_h: We used lisppaste until they added the captcha.
16:40:44 <SamB_XP_> go to the GHC docs page and replace "latest" with "6.2" or something?
16:40:45 * sorear is cleaning up hpaste and learning how it works; he will have the cheap spam filter sent to shapr soon
16:41:28 <dons> great.
16:41:34 <treble> hurray!
16:41:43 <int80_h> http://pastebin.ca/602246
16:41:47 <treble> isaac said that we could run it on community.
16:41:49 <int80_h> that's my problem code
16:42:28 <treble> if then else
16:42:31 <treble> you forgot the else
16:42:41 <treble> there is also the "when" function
16:42:43 <treble> :t when
16:42:46 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
16:42:46 * int80_h kicks self
16:42:54 <dons> treble: ok, cool. running it on the community server sounds good
16:43:02 * dons has to get used to nick changes. very confusing!
16:43:11 <glguy> bad habit
16:43:11 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
16:43:16 <int80_h> oh I am following the structure from yet another haskell tutorial, so I don't officially know about when yet
16:43:24 <int80_h> I could use case, prolly
16:43:51 <oerjan> int80_h: you can't use when in that case anyhow since you are returning a list
16:43:53 <SamB_XP_> int80_h: did you used to be known as int128?
16:44:11 <dons> http://programming.reddit.com/info/23bpj/details
16:44:12 <lambdabot> Title: Implementing a type for partial values in Haskell (reddit.com)
16:46:01 <dons> oh nice, new ghc backend phase coming in.
16:46:04 <dons> == better code
16:46:23 <SamB_XP_> dons: what phase?
16:46:25 <sorear> CPS
16:46:28 <sorear> cleaner, too
16:46:35 <dons> above C--, iirc
16:46:40 <Cale> int80_h: you know there's hpaste, right? :)
16:46:54 <glguy> Cale: hpaste is down for spam proofing
16:46:56 <SamB_XP_> Cale: ... right!
16:47:01 <Cale> oh!
16:47:04 <Cale> @paste
16:47:05 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:47:11 <glguy> I didn't take it down
16:47:12 <Cale> hehe, right
16:47:20 <glguy> I think shapr did
16:47:43 <dons> http://article.gmane.org/gmane.comp.lang.haskell.cvs.ghc/21501
16:47:44 <lambdabot> Title: Gmane -- Mail To News And Back Again
16:49:09 <glguy> dons: is that the kind of thing we'll be using in 6.8?
16:49:26 <dons> looks like it.
16:49:55 <sorear> (note, I'm behind a NAT so don't bother testing hpaste)
16:50:32 <glguy> did you update it to use the new HaPPS API?
16:50:43 <glguy> or are you running on old HaPPS?
16:50:51 <sorear> neither.
16:50:57 <sorear> maybe shapr fixed it?
16:50:59 <SamB_XP_> whoah they can kill primopwrappers with this?
16:51:05 <alexj> what is it?
16:51:24 <sorear> alexj: Happs weirdness; what could cause a request to take a really long time?
16:51:36 <sorear> alexj: Shouldn't it close the connection quickly?
16:51:53 <alexj> lemmih just found a bug in the cookie code... same bug is in network.cgi.
16:52:16 <alexj> the connection can stay open if the request is a keep-alive.
16:52:20 <Saizan> glguy: i've sent a couple of patches against hpaste-devel last time scannedinavian broke
16:52:31 <glguy> OHHHHHH
16:52:35 <alexj> is this a keep-alive bug?
16:52:41 <glguy> i forgot about hpaste-devel
16:52:48 <sorear> alexj: Elinks still says "Request sent..."
16:52:53 * glguy doesn't know whether to sink or smile
16:53:05 <sorear> glguy: shapr's gonna delete hpaste
16:53:13 * int80_h cries
16:53:16 <sorear> alexj: And my paste has not yet been announced.
16:53:23 <glguy> and keep the new branch, right?
16:53:29 <sorear> alexj: Would the kept alive connection not be processed?
16:53:55 <hpaste>  jaom pasted "jaom" at http://hpaste.org/1
16:54:10 <sorear> haha
16:54:20 <sorear> i HATE getting tests backward
16:54:31 <dibblego> is there a performance penalty incurred by using CPS instead of pattern matching?
16:54:46 <sorear> alexj: But still - I should have gotten a responce at the browser.
16:55:04 <sorear> alexj: I presume it's sufficiently idiot-proof that this is a HAppS bug
16:55:25 <dons> that hpaste index doesn't look right.
16:55:30 <sorear> alexj: it would also be nice if the key commands were documented somewhere
16:55:41 <sorear> dons: why not?
16:55:46 <sorear> dons: it's only my second paste
16:56:02 <alexj> sorear: I don't know key commands.
16:56:03 <sorear> dons: this is not the scannedinavian hpaste, nor do I have its styate
16:56:07 <sorear> alexj: 'e'
16:56:18 <alexj> ah that is the only one I think.
16:56:44 <alexj> the connetion would not get processed if happs doesn't believe it has fully arrived.
16:56:55 <alexj> are you sending a content-length longer than the body?
16:57:15 <sorear> alexj: i'm using a web browser
16:57:29 <alexj> then I don't know.
16:57:33 <sorear> alexj: not one that *typically* gives problems...
16:57:38 <alexj> :-)
16:57:44 <alexj> ok that is weird.
16:57:47 <alexj> what is your code doing?
16:57:59 <sorear> alexj: i don't understand it, ask treble
16:58:18 <sorear> alexj: but it only happens on my system; kakapo is immune
16:58:30 <alexj> that is weird.
16:58:39 <alexj> are you relying on xslt?
16:58:48 <sorear> No.
16:58:48 <alexj> do you have xsltproc installed?
16:58:50 <glguy> hpaste doesn't use xslt
16:58:53 <alexj> ok.
16:58:58 <glguy> it uses the xhtml package
16:59:02 <sorear> Also, the happs xslt test is badly broken.
16:59:03 <alexj> happs has almost no system dependencies.
16:59:09 <alexj> sorear: yes.
16:59:11 <sorear> it thinks elinks is xslt-capable!
16:59:21 <glguy> it defaults to capable
16:59:29 <alexj> if you want to patch the browser regex, go ahead.
16:59:32 <glguy> and has certain browsers set to not-capable, I thought
16:59:42 <dons> i'd like to get the hpaste pastes exported in some nice text format
16:59:45 <dons> so we won't lose them
16:59:50 <dons> flush as mbox fmt or something :)
16:59:58 <dons> or to darcs
17:00:19 <alexj> I'm trying to think through how to make state versioning nice.
17:00:35 <dons> yeah, we were pondering this as well.
17:00:51 * glguy wonders if there is anything to be learned from RoR's migrations
17:01:00 <sorear> http://paste.lisp.org/display/43893
17:01:00 <alexj> there is also 2LT
17:01:03 <alexj> which is a more formal version of the same.
17:01:04 <sorear> alexj: look at that
17:01:34 <alexj> my gut is to go simpler.  I don't really believe in downmigrations.
17:01:53 <sorear> alexj: see the problem?
17:01:57 <glguy> sorear: that's nearly identical to what I wrote last night
17:02:00 <glguy> and tried compiling
17:02:13 <alexj> I think something like this: class Normalize a where normalize::a->a; instance Normalize a;
17:02:34 <sorear> that just cries for SYBWC
17:03:15 <SamB_XP_> sorear: WTH?
17:03:26 <alexj> sorear: yes.
17:03:38 <alexj> we are using sybwc in the new xml code and it is awesome!
17:03:38 <sorear> alexj: Why? :)
17:03:55 <sorear> alexj: Oh, I thought you were replying to 17:00 < sorear> alexj: see the problem?
17:04:11 <sorear> alexj: 16:59 < sorear> http://paste.lisp.org/display/43893 <- what's wrong?
17:04:18 <alexj> yeah, not sure.
17:05:01 <alexj> what happens if you get rid of the cookie stuff?
17:05:39 <alexj> does anyone know a quick way to apply normalize recursively?
17:05:58 <alexj> so every type gets normalized?
17:06:24 <mauke> hey guys!
17:06:25 <mauke> s,("(?:[^\\"]|\\.)*"|'(?:[^\\']|\\.)*'|[^\W\d][\w']*|(?!--+(?![!#\$%&*+./<=>?\@\\^|~:]))[!#\$%&*+./<=>?\@\\^|\-~:]+)|(?:--[^\n]*|()\{-(?>\{-.*?-\}|.)*?-\})(),$+ . (defined $2 ? ' ' : ''),gse
17:06:31 <sorear> alexj: SYBWC?
17:06:35 <sorear> :)
17:06:56 <sorear> mauke: there is a better way to write that.
17:07:07 <SamB_XP_> mauke: have you been devising new data for vixen?
17:07:12 <alexj> sorear: ok given sybwc, is this a one liner?
17:07:18 <mauke> sorear: show me
17:07:19 <oerjan> @help vixen
17:07:19 <lambdabot> vixen <phrase>. Sergeant Curry's lonely hearts club
17:07:34 <oerjan> @list vixen
17:07:34 <alexj> and do you like this idea for state versioning?
17:07:34 <lambdabot> vixen provides: vixen
17:07:40 <SamB_XP_> vixen doesn't work right now, because someone hasn't applied my patch and restarted lambdabot
17:07:52 <ihope> @vixen
17:07:52 <lambdabot> <undefined>
17:07:58 <ihope> I see.
17:08:28 <SamB_XP_> it doesn't even need a recompile
17:08:41 <SamB_XP_> though it would trigger one
17:11:06 <dons> SamB_XP_:well, i have applied it. so i'm part way through your condition
17:11:18 <dons> and [apply, compile, test, restart]
17:11:26 <SamB_XP_> sorear: quick! say @exit
17:11:29 <dons> no no.
17:11:34 <dons> its not compiled...
17:11:36 <SamB_XP_> dons: it would work...
17:11:45 <dons> not sure there's even a vixen state file.
17:11:46 <SamB_XP_> as long as there is still a lambdabot binary to run
17:11:56 <SamB_XP_> that's what my patch gave you...
17:12:05 <SamB_XP_> a vixen state file that works...
17:12:08 <dons> gimme a chance to test it. there's no rush
17:14:39 <sorear> alexj: You still need some method of injection.
17:15:37 <hpaste>  sorear pasted "testing !spammy" at http://hpaste.org/2
17:15:46 <SamB_XP_> really, all my patch does is add a whole bunch of zeros to State/vixen
17:16:07 <sorear> alexj: Still doesn't quite work.
17:16:17 <sorear> alexj: Loading the recent page stalls
17:16:18 <SamB_XP_> and a little bit of junk to the vixen module
17:17:01 <hpaste>  sorear pasted "la la" at http://hpaste.org/3
17:17:12 <sorear> Yup it "works" now.
17:18:48 <sorear> shapr!!
17:19:10 <oerjan> @shapr
17:19:11 * lambdabot smacks  about with a large trout
17:19:18 <oerjan> ?
17:19:23 <oerjan> @help shapr
17:19:23 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:19:29 <oerjan> oh dear
17:19:33 <sorear> ShAPr -> SlAP
17:19:43 <sorear> you wanted @get-shapr
17:19:47 <oerjan> ah!
17:19:51 <oerjan> @get-shapr
17:19:51 <lambdabot> shapr!!
17:20:07 <alexj> sorear: what do you mean by injection?
17:20:38 <sorear> alexj: The old data is not in the new format, and could fail read before normalize has a chance to run.
17:21:09 <sorear> alexj: Also, the hpaste recent-pastes page won't load and doesn't use cookied.
17:22:46 <Saizan> sorear: does the hpaste output says anything about that request?
17:22:54 <sorear> Saizan: No.
17:23:07 <alexj> I am assuming that you add a new constructor on each new state version
17:23:38 <sorear> alexj: When you pass 255 constructors, the Binary format incompatibly changes.
17:24:02 <alexj> once you have migrated, you don't need to handle old constructors
17:24:35 <alexj> supporting more than 255 versions of  state simultaneously seems extreme.
17:24:46 <alexj> rails just supports 2
17:25:08 <dons> yes, that's just silly sorear :)
17:25:16 <sorear> alexj: That would require you to delete old constructors.
17:25:20 <alexj> yes
17:25:27 <sorear> alexj: Which renumbers newer ones!
17:25:31 <alexj> it does?
17:25:50 <alexj> data Foo = Foo0 Bar Baz | Foo1 Bar Baz Bom | Foo2 BarBaz Bop
17:25:58 <sorear> yeah.  tags are assigned in numeric order.
17:26:03 <SamB_XP_> alexj: of course it does!
17:26:05 <oerjan> you could just reallocate the old constructor again on the next migration?
17:26:06 <sorear> Foo0 = 0, Foo1 = 1, Foo2 = 2
17:27:07 <alexj> if you reorder constructors will binary break?
17:27:15 <sorear> Yes.
17:27:18 <alexj> oy.
17:27:37 <sorear> We want compactness, so we use small integer tags!
17:27:55 <sorear> If you want, you can hack the derivation to use hashes:
17:27:58 <sorear> @where derive
17:27:58 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/derive
17:29:18 <ihope> Is there a delimited continuation tutorial?
17:30:12 <alexj> ok, then maybe it is worth biting the bullet and investing in 2LT
17:30:38 <alexj> binary seems really fragile.
17:31:02 <alexj> if binary is fragile we need hard core governance on type changes.
17:31:13 <alexj> or perhaps we don't want binary for state.
17:31:31 <alexj> how does binary compare with gzip?
17:31:49 <SamB_XP_> binary does not compare with gzip...
17:31:57 <dons> binary encodes, then gzip compresses
17:32:17 <dons> why is binary fragile, btw?
17:32:20 <SamB_XP_> perhaps you mean "how does gzipped binary compare with gzipped Show"
17:32:29 <alexj> samb_xp_: yes
17:32:39 <dons> sorear: anyway, isn't your 255 constructor limit just an artifact of one ofthe binary deriving mechanisms?
17:32:46 <dons> there's no reason to require that.
17:32:50 <alexj> dons: fragile because if you reorder the constructors in your type, it won't deseralize.
17:32:52 <SamB_XP_> i'd expect that gzipped show would be as good or better, sizewize
17:33:06 <dons> alexj: well, it depends on the instance of Binary you use.
17:33:17 <dons> which depends on which deriver, or whether your hand-write the instance
17:33:44 <alexj> I don't want users accidentally to modify state in a way that won't deserialize.
17:33:52 <dons> none of the existing instance in Data.Binary depend on the order of constructors
17:34:04 <SamB_XP_> alexj: they'll always be able to do that
17:34:07 <dons> so i can only asusme sorear is referring to his binary deriver, which used Enum?
17:34:29 <SamB_XP_> dons: all heavyweight users derive like that...
17:35:03 <dons> evidence please. you guys like asserting that the sky is falling too much.
17:35:20 <SamB_XP_> JHC, GHC...
17:35:54 <SamB_XP_> at least I think GHC does...
17:35:57 <dons> that's a list of compilers that use .hi files.
17:36:03 <SamB_XP_> yes!
17:36:09 <SamB_XP_> except JHC uses .ho files
17:37:06 <dons> its pretty easy to produce an instance that does not depend on the particular constructor order. so i don't see the problem.
17:37:30 <SamB_XP_> we could always do an CRC32 of the constructor name or something
17:37:52 <SamB_XP_> MD5, whatever
17:48:14 <jre2> any opinions on xml vs a haskell source file for storing configuration and program data?  It would seem hs is fine, but perhaps I'm missing something?
17:50:16 <dons> .hs would be fine for program data. and very simple
17:50:32 <dons> xml needs extra libs. i'd only use it if you had to operate with non-haskell, xml apps
17:51:42 <astrolabe> I like to use just plain text files.  I'm not sure why, it's probably bad, but it feels right to me.
17:53:06 <dons> OT, but I get to break a story :) http://reddit.com/info/23c4y/comments
17:53:08 <lambdabot> Title: *Breaking* BBC reporter Alan Johnston freed in Gaza! (reddit.com)
17:53:20 <astrolabe> Ah good
17:54:30 <jre2> alternatively (since I have a lot of data for this), are any of the haskell database libraries better than the others?  there's quite a few on the wiki
17:55:02 <dons> so one option is to use Data.Binary, to write out the haskell structures directly
17:55:10 <dons> which is a much tighter format than Read/Show
17:55:22 <dons> you can also then use the gzip or bzip lib to compress the data further
17:55:31 <dons> for databases, start on hackage.haskell.org's database category
18:00:45 <dons> bah, to get these stories to the front page, you've got to get 5 votes really quickly
18:06:48 <int80_h> http://pastebin.ca/602353
18:07:02 <int80_h> hi guys...here is my problem from 3.10 in YAHT
18:08:18 <oerjan> int80_h: i think doMath returns a list of lists, should it do that?
18:08:40 <int80_h> when I tested doMath it just returned a list of ints
18:09:24 <int80_h> doMath does what it should do, as far as I can tell
18:09:29 <oerjan> oh wait
18:09:59 <oerjan> that's not the problem, you are concatenating strings to Ints...
18:10:15 * int80_h goes "Doh!"
18:10:23 <oerjan> add show before mySum and myProd in your printing statements
18:10:30 <int80_h> gotcha
18:11:03 <sorear> re.
18:11:42 * int80_h would be in deep Doh without #haskell
18:12:08 <oerjan> doMath is actually polymorpic Num a => [a], I guess
18:12:46 <oerjan> er, or it would be, if not for the DMR :)
18:12:53 <int80_h> DMR?
18:12:53 <sorear> dons: I'm referring to all binary derivers that currently exist (mine and neil's)
18:13:14 <oerjan> Dreaded Monomorphism Restriction
18:13:25 <oerjan> *Num a => IO [a]
18:13:46 <sorear> dons: I beleive that it's impossible to make a fully order-robust deriver without storing the name as a string.  Feel free to prove me wrong.
18:14:11 <dons> you just have to fix a mapping of names to tags.
18:15:34 <sorear> "just" is a very strong word.
18:15:55 <sorear> passing any kind of extensive data into a deriver is Hard
18:16:45 <sorear> @seen shapr
18:16:45 <lambdabot> shapr is in #xmonad, #scannedinavian, #haskell-blah and #haskell. I last heard shapr speak 2h 10m 19s ago.
18:17:56 <oerjan> if by "fully" you mean robust to adding new constructors then it seems impossible simply because you cannot avoid collisions with anything not lossless?
18:18:12 <oerjan> *against
18:18:17 <sorear> yeah.
18:18:48 <sorear> I expect dons' reaction will be to use a 64 bit field, like everything else in binary is
18:19:01 <dons> you do, eh?
18:19:16 <dons> anyone who cares about their state being preserve doesn't rederive anyway.
18:19:17 <dmwit> Well now that he knows, it certain to at least double in size.
18:19:22 <dons> they add new constructors by hand.
18:19:48 <_magus_> is there a paste service that's usable at the moment?
18:20:14 <oerjan> _magus_: lots of them :)
18:20:27 <oerjan> e.g. pastebin.ca
18:20:28 <_magus_> oerjan: a pointer please :)
18:20:32 <_magus_> ah, thanks
18:21:02 <SamB_XP_> dmwit: I don't remember dons controlling the derivings anyway
18:21:15 <SamB_XP_> dmwit: so is dons to blame for breaking vixen, then?
18:21:52 * sorear finds useful ammunition in dons' statement, permuting it to <you have two choices - boilerplate or data loss>
18:22:14 <dons> sorear: i think you should write more code, and complain less about the sky falling.
18:22:32 <dons> rather than simulating ayrnieu in #haskell
18:23:01 <SamB_XP_> dons: but the sky falls on a regular basis around here
18:24:10 <dons> no, it doesn't. but SamB_XP_ and sorear like to act like it does. very tedious :/ any other storms in teacups we should be battling, while we're here? or perhaps its time to just write some code.
18:24:51 <_magus_> a question on continuations... I have the two function in http://pastebin.ca/602377, I can run the combination once using runContT
18:26:02 <SamB_XP_> dons: if you would people would just stop stomping on our skies...
18:26:03 <_magus_> I'd like to make them mutually recursive, was trying to use callCC, but can't seem to get the types right
18:26:51 <Cale> _magus_: er, mutually recursive?
18:27:14 <oerjan> you don't need ContT for tail recursion...
18:27:29 <dons> it bugs me when, e.g. sorear limits his deriver to Word8 tags, then tells alexj that he better not use binary, becaues deriving is restricted to 255 constructors :/ and otherwise makes noise about the end of the world. melodrama isn't compatible with engineering.
18:27:36 <Cale> You're not using any of the features of ContT as it stands
18:27:51 <SamB_XP_> dons: okay, that *is* silly
18:27:53 <sorear> dons: My deriver is *not* limited to Word8
18:28:00 <SamB_XP_> sorear: oh?
18:28:01 <sorear> dons: ndm's is
18:28:05 <SamB_XP_> ah.
18:28:10 <dons> `I'm referring to all binary derivers that currently exist (mine and neil's)'
18:28:21 <sorear> SamB_XP_: No, it auto-sizes.  isn't the whole point of binary compactness?
18:28:34 <Cale> _magus_: Could you explain a bit more about what the program you want to write does?
18:28:40 <sorear> so when you go 256 -> 257, your size field gets bigger.
18:28:42 <_magus_> Cale: yes, for lack of a better expression... I know I'm not, that'd be the next step (I think)
18:28:52 <SamB_XP_> sorear: so yours uses UTF-8?
18:29:00 <SamB_XP_> oh? no?
18:29:05 <SamB_XP_> it should ;-)
18:29:12 <sorear> ULEB128 is much nicer.
18:29:22 <SamB_XP_> whatever
18:29:23 <dons> and it breaks the whole point of having an pure compression algos.
18:29:25 <SamB_XP_> something like that
18:29:36 <sorear> dons: Huh??
18:29:40 <dons> use a single field width for constructors up to the size ghc can conceivably compile
18:29:41 <sorear> anyway, that doesn't fix the permutation issue
18:29:47 <dons> that's another issue.
18:30:06 <_magus_> Cale: I can run one iteration like this: 'runtContT (cpsGetChar >>= cpsProcessChar) print', and two iterations like 'runtContT (cpsGetChar >>= cpsProcessChar >> cpsGetChar >>= cpsProcessChar) print'
18:30:11 <SamB_XP_> sorear: I don't think that one's much of an issue
18:30:11 <dons> you're not supposed to prematurely optimise the binary formats. that's for bzip2 / gzip.
18:30:28 <dons> if you do that, and it leads to incompatibilities, that's the defn. of premature optimisation right there.
18:30:37 <sjanssen> dons: the compressors aren't perfect, though
18:30:39 <SamB_XP_> you just have to make sure everyone hacking on a codebase is warned about that....
18:31:03 <_magus_> Cale: I'd like to string the two functions together so that I get an infinite number of iterations
18:31:13 <Cale> _magus_: forever x = x >> forever x
18:31:39 <Cale> forever (cpsGetChar >>= cpsProcessChar)
18:31:49 <_magus_> Cale: but can I then, from within cpsProcessChar add code to end the processing?
18:31:53 * sjanssen scrolls back to see why the sky is falling
18:32:12 <Cale> _magus_: oh, for that, you'd probably want to call the continuation
18:32:22 <_magus_> Cale: using callCC?
18:32:31 <Cale> So you'll need to put the whole thing in a callCC and use that parameter.
18:32:41 * sorear watches all of binary's advantages erode
18:32:46 <_magus_> Cale: I thought so, but then I ran into type problems :(
18:32:52 <Cale> callCC (\k -> forever (cpsGetChar >>= cpsProcessChar k))
18:33:08 <SamB_XP_> sorear: so work on fixing Read to be fast
18:33:10 <Cale> where cpsProcessChar is now a two-parameter function
18:33:23 <Cale> whose first paramter is the continuation to run when finished
18:34:07 <_magus_> Cale: ah, I'll give that a go
18:34:14 * _magus_ off to play in ghci
18:35:30 <dons> we've actually looked at the compression that occurs when stripping leading 0s. gzip alone is very good.
18:36:15 <sjanssen> that's good
18:36:37 <sjanssen> dons: I tend to agree with sorear (I think?) binary formats are fragile
18:37:03 <sjanssen> there's a major versioning problem, and errors aren't human correctable
18:37:12 <dons> right.
18:37:20 <dons> well, they are, but they require code.
18:37:42 <_magus_> @type forever
18:37:44 <lambdabot> Not in scope: `forever'
18:37:53 <mgsloan> I think there may be good possibility in binary files which start off with a little section specifying the format of the rest of the file
18:37:58 <Cale> _magus_: forever x = x >> forever x
18:37:59 <sjanssen> and much squinting at hex
18:38:02 <SamB_XP_> dons: yeah. and it'd get pretty annoying for anything much bigger than that vixen thing...
18:38:06 <Cale> (I just defined it in place)
18:38:20 <sjanssen> mgsloan: that is an interesting idea
18:38:34 <Cale> btw, that really ought to go into Control.Monad
18:38:52 <Cale> Or we could call it repeatM
18:39:00 <sorear> Cale: it's already there
18:39:02 <mgsloan> sjanssen - yeah, i'd like to think so :)
18:39:03 <sorear> (6.7)
18:39:07 <Cale> Oh, okay
18:40:12 <SamB_XP_> mgsloan: can you figure out how to implement that easily?
18:41:09 <mgsloan> SamB_XP_ - perhaps I could.  really it'd require some standardization body, though
18:41:13 <sorear> (Big IIRC) that exists, is called ASN.1, and is universally loathed
18:41:21 <mgsloan> lol
18:42:03 <SamB_XP_> sorear: I meant a way to do it nicely *in Haskell*
18:42:07 <mgsloan> really what it requires is a reasonable subset of possible binary data formats
18:42:22 <mgsloan> it's probably quite possible, given Data.Binary
18:43:07 <SamB_XP_> the tricky part, as I see it, is figuring out how to generate the schema at the beginning of the file
18:44:49 <sorear> btw, the hpaste spam filter is working, and hpaste will be back shortly after kakapo itself is
18:44:53 <SamB_XP_> it seems like a wonderful idea
18:45:20 <alexj> what is the goal of Data.Binary?
18:45:42 <alexj> I was toying with using compressed xml as the state serialization format.
18:46:05 <alexj> the nice thing about xml is that it is readily manpulable with lots of transformation tools.
18:46:07 <dons> it provides two things
18:46:18 <dons> one, a very fast way to pack data to and from a lazy bytestring
18:46:29 <dons> then on top of that, a set of serialisers for haskell values
18:46:43 <dons> so, pure, fast, binary serialisation of haskell values
18:46:54 <dons> and a layer underneath for building your own fast packing into lazy binary streams
18:47:01 * dcoutts grumbles that it's still not fast enough
18:47:17 <dons> so, on top of Data.Binary, you can build other things. for example, bos wrote a Typeable-tagging serialiser
18:47:32 <dons> or you might use the underlying Get/Put monads to write other data structures efficiently
18:48:15 <_magus_> sorear: did you say 'forever' was in a standard module? which one?
18:48:18 <mgsloan> SamB_XP_: it'd probably associate string names to various data types in sequence.  there would be a few base data types, on which to construct custom data types
18:48:22 <dons> the end goal is parsec-like combinators for readig and writing network formats, bit packing, and other binary data -- very very fast
18:48:24 <sorear> _magus_: Control.Monad
18:48:41 <mgsloan> SamB_XP_ - might be a pretty fun project
18:48:52 <shachaf> _magus_: Only in 6.7.
18:48:57 <dons> so, you could for example, 'serialise' xml as byte strings efficiently into a lazy bytestring
18:49:08 <dons> not necessarily byte packing the data.
18:49:24 <dons> then run gzip.encode over the result, and send off your compressed xml over the network
18:49:39 <dons> dcoutts: and i think we need to give some examples of how to use Get/Put properly too
18:49:45 <dcoutts> aye
18:50:07 <_magus_> shachaf, sorear: ah, that explains it, I'm still on 6.6 (Debian Sid)
18:50:12 <dons> e.g. a Writer example, for bytestring lazy logging
18:50:33 <shachaf> _magus_: 6.7 is the development version.
18:50:42 <dcoutts> dons: mm, interesting example
18:50:51 <dons> or , say, a Typeable/Version tagged set of binary instances
18:51:10 <dons> xml serialisation seems another faq that should be looked at -- in the paper perhaps.
18:51:26 <shachaf> _magus_: But forever = sequence_ . repeat.
18:51:34 <dons> ?src forever
18:51:34 <lambdabot> Source not found. Do you think like you type?
18:53:01 <oerjan> :t sequence_ . repeat
18:53:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
18:53:08 <Socrates> I have a lil' algorithm conundrum
18:53:25 <Socrates> I have a list of numbers, and I want to check if the sum of two of those numbers is a given value
18:53:28 <sjanssen> sorear: how does Data.Derive represent data declarations internally?
18:53:36 <Socrates> My current solution is way, way too slow :(
18:53:37 <sorear> sjanssen: Dec
18:53:44 <oerjan> :t fix . flip (>>)
18:53:45 <sjanssen> sorear: and Dec is?
18:53:46 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> m b
18:53:54 <_magus_> Cale: alright, that trick with forever did seem to do the trick, now I'm stuck on the issue of terminating the whole thing
18:53:55 <sorear> @docs Language.Haskell.TH.Syntax
18:53:55 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/template-haskell/Language-Haskell-TH-Syntax.html
18:54:10 <Cale> _magus_: did you try the callCC thing?
18:54:11 <oerjan> oops
18:54:33 <_magus_> Cale: callCC on the "termination continuation"?
18:54:38 <shachaf> @pl forever x = x >> forever x
18:54:39 <lambdabot> forever = fix (ap (>>))
18:54:44 <sorear> Socrates: you can do it in O(n log n) time
18:54:50 <sorear> O(n) even
18:54:59 <Cale> callCC (\k -> ...)
18:55:12 <sjanssen> wow, TH's haddocks aren't very nice
18:55:15 <Cale> where inside ..., running k will cause execution to jump out of the callCC
18:55:27 <Socrates> sorear: Care to give me a hint on how to do it? To get me going : )
18:55:47 <sorear> Socrates: n1 + n2 = t  iff   n1 == t - n2
18:57:44 <Socrates> Hmm
18:57:58 <Socrates> I'm not sure how that helps me, tbh.
18:58:17 <oerjan> :t fix . (>>)
18:58:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
18:58:24 <sorear> http://members.cox.net/stefanor/FFrgFhz2.uf
18:58:42 <_magus_> Cale: http://pastebin.ca/602413 holds the updated version of cpsProcessChar
18:59:04 <_magus_> Cale: I can't seem to get my head around how to actually use 'fk'
18:59:17 <Cale> _magus_: you simply run it
18:59:26 <Cale> _magus_: the callCC can't go inside the loop
18:59:32 <Cale> It has to surround the loop
18:59:36 <oerjan> :t fix (ap (>>))
18:59:39 <sorear> Socrates: there's my solution.  it's a 2-liner not counting the import
18:59:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
18:59:55 <Cale> Remember, it hands you the current *continuation*, which is, everything that comes after the callCC.
19:00:39 <sorear> Socrates: I can run it on a 1,000,000 element list in ~7 seconds in GHCi
19:01:29 <_magus_> Cale: hmm, not sure I understand what you mean
19:01:31 <Socrates> sorear: Could you put that in .txt by any chance, or paste it somewhere else, doesn't seem to like .uf at this end
19:02:23 <sorear> Socrates: If by "not like" you mean that the text is unreadable, that's because I fed it (incl. the name) through rot13
19:02:43 <Cale> _magus_: okay, let me paste an example.
19:02:55 <sorear> http://members.cox.net/stefanor/SSetSum2.hs <- unobfuscated!
19:03:07 <Cale> http://pastebin.ca/602419
19:03:17 <Socrates> Thanks
19:04:09 <shachaf> Socrates: subsetSum2 10 [5,3] -- True, is that what you want?
19:04:35 <shachaf> Socrates: Since you said "two of those numbers".
19:04:41 <Socrates> Um
19:04:49 <Socrates> I've got a list of abundant numbers
19:05:20 <Socrates> I want to check if the sum of 2 of any of those numbers is a given value
19:05:27 <Cale> _magus_: of course, returning c when it's known that it's a space is rather silly, but you get the idea :)
19:06:12 <Socrates> For example, 10 [2,3,5,7] is True, since 3+7
19:06:30 <sjanssen> Socrates: can you use the same number twice?
19:06:34 <shachaf> Socrates: Yes, but sorear's solution counts the 5 twice.
19:06:43 <shachaf> Socrates: Do you want that?
19:06:46 <Socrates> Hmm
19:06:50 <Socrates> Let me check!
19:06:57 <dolio> Is that O(n)?
19:07:25 <dolio> Oh, I guess IntSet has a O(w) factor, and w is constant.
19:07:28 <Socrates> Yeah, the same number can be used twice
19:07:29 <dolio> Rathern than log n.
19:07:57 <Cale> > let xs = [2,3,5,7] in any (==10) [x + y | x <- xs, y <- xs]
19:08:00 <lambdabot>  True
19:08:20 <Cale> Or, if you don't want repeats...
19:08:38 <sjanssen> [ t - v | v <- lst, not (even t) || t `div` 2 /= v ] -- doesn't include repeats
19:08:49 <Cale> > let xs = [2,3,5,7] in any (==10) [x + y | (x, ys) <- zip xs (drop 1 (tails xs)), y <- ys]
19:08:51 <lambdabot>  True
19:09:30 <Socrates> Cale: Thanks, I'll see if that's any faster then my current attempt (looks verys similar tho')
19:09:36 <sjanssen> Cale: that's O(n^2), though
19:09:44 <sjanssen> sorear's solution is O(n log n)
19:09:47 <oerjan> sjanssen: t /= v + v is a bit more efficient, i think
19:09:52 <sorear> > M.fromListWith (\x y -> "<" ++ x ++ "," ++ y ++ ">") [(1,"a"), (1, "b"), (1,"c")]
19:09:54 <lambdabot>  fromList [(1,"<c,<b,a>>")]
19:10:03 <Cale> Yes, certainly :)
19:10:13 <sjanssen> oerjan: they should be about the same if (t `div` 2) is shared
19:10:24 <sjanssen> (ghc will most likely share it with -O2)
19:10:26 <oerjan> oh right
19:11:24 <oerjan> if the list already is sorted then you can make it O(n) i think
19:12:06 <Cale> _magus_: any luck comprehending that code?
19:12:10 <syntaxfree> http://syntaxfree.wordpress.com/2007/07/04/is-lastfm-leaking-information-to-google/
19:12:13 <lambdabot> Title: Is last.fm leaking information to Google? « Data.Syntaxfree, http://tinyurl.com/3dhcr2
19:12:17 <syntaxfree> new blog post / sinister conspiracy theory
19:12:44 <oerjan> just reverse the [t-v |...] list and compare recursively
19:13:50 <sorear> Socrates: I've a new version up that reports indices.
19:14:02 <sorear> Socrates: So you can filter on uncurry (/=)
19:14:15 <Socrates> sorear: Thanks
19:14:21 <alexj> dons: any reason not to do data.binary with a haskell representation of xml and use that xml to represent your actual data?
19:15:03 <dons> alexj: so a haskell type for xml, and Data.Binary to read and write it out?
19:15:16 <dons> and then map your data to xml, then to binary?
19:15:36 <sjanssen> alexj: you need to be sure your Haskell representation of XML is stable, or you'll run into the same versioning problems
19:16:06 <_magus_> Cale: yes, but it's not really what I was looking for
19:16:22 <Cale> _magus_: what was it that you were looking for?
19:17:06 <sorear> alexj: gzipped xml is more standard
19:17:10 <Socrates> Yeah, that's what I want
19:17:22 <Socrates> Thanks all
19:17:24 <_magus_> Cale: well, basically I was thinking that maybe continuation could be used for callbacks
19:17:53 <_magus_> Cale: that'd put cpsGetChar in a module, and cpsProcessChar is provided by the developer
19:18:00 <syntaxfree> sinister ... google .. conspiracy. more in #haskell-blah
19:18:31 <_magus_> Cale: I already have a solution where cpsGetChar takes cpsProcessChar as an argument
19:18:38 <int80_h> putStrLn (map (show) factList)
19:18:45 <int80_h> can I do something like that?
19:19:03 <Cale> int80_h: almost.
19:19:09 <oerjan> int80_h: mapM (putStrLn . show)
19:19:14 <Cale> int80_h: mapM_ print factList
19:19:36 <int80_h> hmm YAHT hasn't told me about mapM
19:19:39 <Cale> (print = putStrLn . show)
19:19:39 <oerjan> er right, those are equivalent
19:19:45 <_magus_> Cale: but then termination is, not really tricky, but... well, I wanted to see if it could be made more elegant using continuations
19:20:15 <int80_h> I think YAHT wants me to write some helper functions then
19:20:16 <Saizan> int80_h: putStrLn (concat (map show factList)), also
19:20:17 <Cale> int80_h: You can also do it manually.
19:20:19 <oerjan> _magus_: take a look at ErrorT, it may be simpler
19:20:37 <Cale> or yeah, do the right string processing ahead of tim
19:20:38 <Cale> e
19:20:58 <int80_h> is ++ shorthand for concat?
19:21:06 <oerjan> @src concat
19:21:06 <lambdabot> concat = foldr (++) []
19:21:06 <Cale> putStrLn (unlines . map show $ factList)
19:21:28 <_magus_> oerjan: yes, in this limited case you are right, ErrorT would probably be easier, but continuation offers a lot more control in "what to do next"
19:22:23 <oerjan> ok
19:22:56 <alexj> sjansseen: xml is a more stable format than the per application state types that evolve over the life of the app.
19:23:10 <sjanssen> alexj: very true
19:24:20 <alexj> sorear: would gzip of xml be about the same speed/size of binary?
19:24:50 <sjanssen> alexj: you might consider an even simpler format, like s-expressions
19:24:55 <alexj> dons: datatype -> haskell-xml-type -> data.binary
19:25:32 <alexj> dons: have you seen igloo's marshal-xml lib?  really really nice for conversion to/from xml.
19:26:04 <alexj> i wrote the first version using syb.  he made it sing using sybwc.
19:28:52 <dons> i suspect datatype -> haskell-xml -> binary would be the fastest way. marshal-xml probably isn't optimised much -- but hard to say.
19:29:07 <dons> and then you can gzip the result, which has been optimised
19:29:41 <alexj> datatype -> haskell-xml -> binary would solve the binary fragility problem.
19:29:45 <dons> we should have an 'official' way to serialise xml
19:29:51 <dons> quickly, i mean.
19:29:59 <dons> yeah, i think that sounds rather nice.
19:30:17 <dons> do the mapping to xml in a nice pure layer, than dump that into gzip . binary
19:30:18 <alexj> marshall-xml is that for happs.
19:30:22 <sjanssen> I think you can make this quite quick with some clever string pooling
19:30:35 <alexj> if you want to pull it into some other repo that is ok.
19:30:57 <sorear> I believe the output should be such that you can do:   <state-file | gunzip | xmltidy | less
19:31:09 <sorear> minus the first | of course
19:31:36 <dons> yeah, i'd imagine you'd serialies it to bytestring form. so gunzip | less works
19:31:51 <sorear> i'd do it without spaces
19:31:58 <dons> wish i had time to work on this infrastructure stuff
19:32:09 <sorear> xml has enough structure that it can be prettyprinted without type information
19:32:16 <sorear> (xmltidy does this iirc)
19:32:24 <dons> dcoutts: xml serialising might be a good job for a hackathon
19:32:44 <alexj> what exactly is xml serializing?
19:32:45 <dons> is there any bytestring xml processing available in haskell atm?
19:32:59 <sorear> alexj: Converting data into XML and writing it somewhere
19:33:05 <dons> alexj: just getting some xml data out from haskell to disk/network quickly.
19:33:06 <alexj> we have that.
19:33:30 <alexj> marshall-xml does automatic conversion of haskell types to and from xml.
19:33:48 <alexj> you can specialize the representation of types if you want to override the default representation.
19:34:21 <alexj> darcs get http://happs.org/HAppS/marshal-xml
19:34:22 <dons> cool.
19:34:41 <alexj> it is very very new code, but so far has been working for the limited stuff we've been hitting.
19:35:05 <alexj> it relies on haxml to do actual parsing and rendering of strings.
19:35:22 <alexj> but the haxml is hidden from the user.
19:35:34 <alexj> would love it if someone plugged in libxml instead.
19:35:53 <alexj> but haxml works fine so not an urgency for us.
19:36:30 <alexj> have not tested speed.
19:37:01 <dons> yeah, libxml + bytestrings.
19:37:01 <sorear> what does libxml give you over haxml?
19:37:14 <dons> potential bytestring support? external maintainers?
19:37:32 <_magus_> @type callCC
19:37:33 <dons> extended support for stuff missing in haxml, too, i think
19:37:35 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
19:38:06 * dcoutts is sceptical about binding libxml
19:38:24 <dons> i think there's already a binding somewhere.
19:38:31 <dcoutts> we don't need a dom tree, an expression tree is just fine
19:38:50 <dons> but yeah, we need more bytestring-based parsing, in general. haskell's really a more appropriate language for this kind of thing
19:38:58 <dcoutts> right
19:39:15 <dons> maybe we should start kicking around a bytestring parsec, dcoutts
19:39:18 <alexj> ok.  well haxml seems to work.
19:39:26 <kfish> dons: wasn't there a soc project for that or something?
19:39:29 <alexj> if you have a better solution, send a patch.
19:39:32 <kfish> (moin)
19:39:40 <dcoutts> dons: not yet, I've got too much else, bytestring-1.0, faster binary, unicode bytestring
19:39:44 <dcoutts> oh and my thesis :-)
19:40:12 <dcoutts> dons: xml parsing needs utf8 packedstring for one thing
19:40:17 <dons> mm.
19:40:17 <dcoutts> and iconv
19:40:28 <dcoutts> to deal with all the various manditory encodings
19:40:36 <chessguy> 'evening
19:40:37 <dons> kfish: oh, right!
19:40:39 <dons> http://code.google.com/soc/2007/haskell/about.html
19:40:40 <lambdabot> Title: Google Code - Summer of Code - Organization Information
19:40:47 <dons> where's paolo?
19:41:02 <dcoutts> dons: like utf8, utf16le, utf16be, utf16, utf32le ...
19:41:23 <dcoutts> @seen xerox
19:41:23 <lambdabot> xerox is in #haskell-overflow, #haskell-blah and #haskell. I don't know when xerox last spoke.
19:42:22 <ttmrichter> My tranformation is complete.  I used to shout endlessly at Haskell source code with names like "x" and "xs" and "mapM_".  Now I write this: http://haskell.org/haskellwiki/How_to_read_Haskell#Tip:_the_smaller_the_name.2C_the_smaller_the_scope
19:42:25 <lambdabot> Title: How to read Haskell - HaskellWiki, http://tinyurl.com/2wc4rr
19:42:35 <ttmrichter> Could someone vet that for accuracy, incidentally?
19:43:20 <gwern> dons: I've been trying to understand something. all of the bytestring libs say they 'truncate' to 8bits or whatever. does this mean it can't handle everything that can be written in UTF8?
19:43:55 <kfish> i'd be interested to help with whatever the next layer needed for bytestring/binary encodings/parsing etc. is, is there a roadmap or project plan somewhere?
19:44:35 <dcoutts> kfish: not written down really
19:44:39 <sjanssen> gwern: yeah, that's right
19:44:43 <omg911> what ide do you use to program in?
19:45:01 <dcoutts> omg911: your favourite text editor
19:45:08 <kfish> dcoutts, i'd like to play, but i don't really know where to start :-)
19:45:15 <Saizan> sjanssen: it can't?
19:45:27 <omg911> uh well i use vim, but something like plt-scheme would be nice too :p
19:45:47 <sjanssen> Saizan: well, a ByteString could hold some UTF-8 encoded data, but it doesn't support UTF-8 directly
19:45:58 <dcoutts> kfish: well, depends what you're interested in, there's iconv, binary, unicode fusible packedstring, parsing, take your pick
19:46:30 <dcoutts> kfish: whichever takes you fancy, ask round here for advice and what start other people have already made
19:46:33 <dibblego> @pl \x -> x * x
19:46:34 <lambdabot> join (*)
19:46:58 <gwern> sjanssen: so what happens when a string with the more exotic stuff is packed into a bytestring?
19:47:07 <kfish> dcoutts, all of the above (my projects lately involve either video editing, web/xml or japanese language)
19:47:08 <dcoutts> kfish: for most of those items, there's some existing code sitting around in various states of (in)completion
19:47:43 <Saizan> gwern: in practice you just get the raw data that you need to interpret according to the encoding
19:47:46 <kfish> dcoutts, ok, are there any dependencies between those things, eg. unicode fps depends on iconv or so?
19:47:59 <dibblego> @pl \x -> sum $ map (\x -> x * x) [1..n]
19:48:00 <lambdabot> const (sum (map (join (*)) [1..n]))
19:48:21 <dcoutts> kfish: I've got most of an iconv binding, at the moment it just converts between lazy bytestring
19:48:41 <dcoutts> ie it does not depend on any unicode packed string, because we don't have that yet
19:48:49 <sjanssen> gwern: try Data.ByteString.Char8.pack "\256" in ghci
19:49:20 <sjanssen> gwern: it takes the low 8 bits from each code point
19:49:43 <dolio> ttmrichter: You might want to note in the last section, if you're using ghci, ':i xyz' should tell you where it's defined.
19:50:54 <ttmrichter> I only did the part with the short names, dolio.  :)  But I will add that to the latter part.  That sounds like very useful information.
19:51:15 <dolio> Oh, okay. :)
19:51:56 <ttmrichter> I'm just wondering if I got the arguments for the use of short, "meaningless" names right.
19:53:06 <dolio> Seems about right.
19:54:00 <ttmrichter> The gonzo version of foldl, incidentally, is taken from what I actually did when I first picked up Haskell to look at about six years ago.  :)
19:54:19 <dolio> :)
19:54:29 <ttmrichter> I went through dozens of functions renaming variables to understand how they worked before the short names finally "clicked" for me.
19:54:30 <dolio> Were you previously using Java? :)
19:54:36 <ttmrichter> Worse.  C++.
19:54:50 <dolio> Ah, yeah, I guess Java doesn't like underscores.
19:54:51 <ttmrichter> I dodged the Java bullet.  Instead I got hit by the C++ artillery shell.
19:55:22 <kfish> dcoutts, is that iconv binding publicly available?
19:55:33 <ttmrichter> Java likes it fine, but the culture doesn't use underscores often.
19:55:37 <mm_freak> bbsGen :: (Integer, Integer) -> IO (Integer, Integer)
19:55:37 <mm_freak> bbsGen (x,n) = IO (mod (x^2) n, n)
19:55:42 <mm_freak> yields an error =/
19:55:43 <ttmrichter> Java culture seems to prefer camel-casing.
19:55:47 <dolio> Right, that's what I meant.
19:55:49 <dcoutts> kfish: I should upload it, I was working on it on my laptop
19:56:05 <mm_freak> test.hs:12:15: Not in scope: data constructor `IO'
19:56:11 <dcoutts> kfish: I'll ping you when it's up, probably tomorrow
19:56:46 <mm_freak> how could i implement this?
19:56:52 <kfish> dcoutts, ok, thanks
19:56:54 <chessguy> mm_freak, try this: bbsGen (x,n) = return (mod (x^2) n, n)
19:57:00 * kfish finds Bulat's proposal: http://www.haskell.org/haskellwiki/Library/IO
19:57:02 <lambdabot> Title: Library/IO - HaskellWiki
19:57:09 <ttmrichter> I'm not sure what the protocol is in the Haskell community: should I "be bold" (to rip off Wikipedia speech) and edit wiki pages where I see shortcomings?  Or should I check first if it's a good thing?
19:57:41 <dolio> mm_freak: return (mod (x^2) n, n)
19:57:42 <kfish> ttmrichter, if you're not bold, who will save us?
19:57:52 * ttmrichter laughs.
19:57:56 <ttmrichter> I guess that's an answer.
19:57:59 <chessguy> dolio, too slow :)
19:57:59 <mm_freak> ah, i understand
19:58:01 <mm_freak> thank you
19:58:09 <chessguy> @type return
19:58:15 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
19:58:16 <ttmrichter> My insecurity lies in the fact that I'm very much a Newb yet.  It's a bit arrogant to go in and change things.
19:58:18 <dolio> chessguy: Apparently I'm blind, as well. :)
19:58:34 <chessguy> hey, don't knock blind
19:58:36 <mm_freak> is it just because IO is somehow `private'?
19:58:52 <mm_freak> i thought, theoretically it _should_ work that way
19:59:13 <kfish> ttmrichter, here is probably a good place to discuss wiki edits
19:59:29 <Saizan> mm_freak: yes, IO is an abstract type, you don't have access to its contructor
19:59:29 <Botje> you can't directly create IOs because the constructor is private. You need to ask "return" to do it for you.
19:59:36 * kfish is about to go cut up the Binary_IO page
19:59:37 <chessguy> or on haskell-cafe
19:59:39 <mm_freak> k, that explains things, thanks
19:59:44 <glguy> http://paste.lisp.org/display/43898
20:00:05 <chessguy> glguy!
20:00:29 <sorear> shapr!!
20:01:16 <chessguy> glguy, i assume you've gotten the reports of spam on hpaste?
20:01:37 <sorear> chessguy: I have a fix.
20:01:46 <sorear> chessguy: Now if only shapr would show up.
20:01:52 <oerjan> @src IO
20:01:52 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
20:02:25 <ttmrichter> Oh, that reminds me.  What do the "#" characters by themselves mean?
20:02:34 <glguy> that paste was my version of a quicksort that avoids as many intermediate lists as I could and minimizes the number of passes at each recursion to 1 :)
20:02:35 <sorear> ttmrichter: Nothing.
20:02:36 <ttmrichter> I was just reading a blog about IO in Haskell and they glossed over that bit.
20:02:40 <glguy> now i'm off to walk to ice cream
20:02:52 <sorear> ttmrichter: # is just part of a name, like 'k' or 'q'
20:02:54 <chessguy> # is a ghc thing
20:03:02 <glguy> (oh, and it uses a randomized algorithm tha tstill allows for lazy access to the leading elemlents)
20:03:06 <ttmrichter> You can use # by itself as a name?
20:03:19 <sorear> > let a # b = a - b in 3 # 2
20:03:21 <lambdabot>  1
20:03:52 <oerjan> ttmrichter: it's not legal in Haskell, so ghc uses it for internal things
20:03:53 <mm_freak> i didn't know there really is a type RealWorld
20:04:10 <sorear> ttmrichter: GHC coding conventions uses # to signify that the value has an unboxed kind.  sorta like hungarian notation, but excusable because otherwise we'd have name clashes (+ vs +#)
20:04:12 <oerjan> mm_freak: in ghc there is
20:04:17 <ttmrichter> OK, that explains it.  It's a GHC thing which we're not meant to know.  :)
20:04:19 <dons> kfish: cut up http://haskell.org/haskellwiki/Binary_IO ?
20:04:20 <lambdabot> Title: Binary IO - HaskellWiki
20:04:27 <oerjan> other compilers may implement IO differently.
20:04:28 <dons> it could do with a good rewrite
20:04:41 <_magus_> Cale: thanks for your help, I've posted pretty much what I was looking for at http://pastebin.ca/602485
20:04:50 <ttmrichter> <lie type="bald>Hey!  I like Hungarian notation!</lie>
20:05:15 <mm_freak> is there an easy interface to /dev/u?random somewhere in GHC's libs?
20:05:44 <Botje> you can just open it with openFile
20:06:45 <mgsloan> System.Random
20:06:48 <mm_freak> botje: that's going to take a lot of code, if i include error handling (and since i'm a C-programmer, i'd never do I/O without proper error handling)
20:06:55 <chessguy> hmm, hungarian notation in HTML, now there's a concept
20:07:16 <mm_freak> mgsloan: i thought, that's a simple LCGâ¦  thank you, i'll look it up
20:07:28 <sorear> mgsloan: False.  that's a PRNG
20:07:31 <Saizan> _magus_: are you sure you need those callCC?
20:07:33 <dons> mm_freak: are you just looking for a source of randoms?
20:07:46 <mm_freak> dons: for a TRNG to initialize my PRNG
20:07:55 <Botje> mm_freak: error handling? :P
20:08:05 <dons> you can set a seed in System.Random
20:08:07 <mm_freak> botje: error handling ;)
20:08:21 <mm_freak> dons: i need a CSPRNG
20:08:33 <kfish> dons: s/cut up/update/ :-)
20:08:47 <dons> i've a binding to the mersenne twister, if that's useful to you
20:08:50 <dons> should hackage it.
20:08:57 <dons> its about a zillion times faster than System.Random
20:09:00 <mm_freak> the mersenne twister is not a CSPRNG
20:09:09 <chessguy> @type zillion
20:09:12 <lambdabot> Not in scope: `zillion'
20:09:25 <dons> not an overloaded literal, unfortunately
20:09:29 <mm_freak> i'd like to implement by own CSPRNG (the BBS generator)â¦  it's just an exercise
20:09:42 <dons> ok. should be good. please consider cabalising it.
20:09:53 <dons> randoms are a frequently requested topic here
20:10:13 <mm_freak> dons: that would be pointless, because the BBS generator is very slow and implemented in at most three lines of haskell code =)
20:10:16 <chessguy> yeah, they're not exactly something haskell does well
20:10:18 <kfish> dons, dcoutts: regarding http://www.haskell.org/haskellwiki/Binary_IO , would it be right to simply recommend Data.ByteString and Data.Binary at the top of that page?
20:10:19 <lambdabot> Title: Binary IO - HaskellWiki
20:10:31 <dons> kfish: i think so, yes.
20:10:55 <dcoutts> yeah
20:11:04 <dons> if its the first thing that would be recommended in here, then the wiki should reflect that
20:11:28 <kfish> what was the binary interface in missingh?
20:11:49 <dons> haven't seen it. something pythonic? :)
20:11:55 <kfish> hmm, Data.Bits.Utils, System.IO.BInary
20:11:56 <kfish> heh
20:12:14 <dons> Data.Bits, Data.Binary, Data.ByteString, probably best to link all 3.
20:12:25 <mm_freak> btw, is there any point in using FastString or similar for everyday tasks?
20:12:36 <dons> depends on the task.
20:12:47 <dons> but yes, i'd think there are some good cases.
20:13:10 <mm_freak> dons: not extremely speed critical, like CGI or just printing some results to stdout
20:13:34 <dcoutts> if it's not speed critical, do whatever is easiest
20:13:44 <hoelzro> does anyone know of a good algorithm to find the most central point in a set of points given only the distance between each point?
20:13:54 <dcoutts> but the ByteString api is not hard to use, it's more or less the same as String, but without the (:) [] constructors
20:14:17 <dibblego> what does it have in place of : and []?
20:14:30 <dibblego> is ByteString polymorphic like [a]?
20:14:34 <dcoutts> no
20:14:34 * dibblego should read
20:14:48 <dcoutts> it's a string of *bytes* :-)
20:14:58 <dons> polymorphic bytestring-like arrays are in the unlifted part of the ndp library
20:15:00 <dibblego> [Word8] ?
20:15:19 <dcoutts> right, but also with an api that provides an ascii interpretation
20:15:36 <dibblego> ah ok
20:15:44 <dcoutts> Data.ByteString and Data.ByteString.Char8
20:16:50 <chessguy> hoelzro, what do you mean the distance between each point?
20:16:58 <mm_freak> is there a fast string module, which handles multibyte charsets?
20:17:06 <dcoutts> mm_freak: not yet
20:17:17 <chessguy> hoelzro, you mean like for each point, you k now the distance to every other point?
20:17:30 <dons> ther'es some things that kzm did, for latin charsets
20:17:39 <dons> and there's Twan's unicode lib.
20:17:46 <dons> (not sure if that's on hackage..)
20:18:02 <mm_freak> hmmâ¦  it's not too important, but i don't like to truncate in the middle of a multibyte sequence =)
20:18:10 <dcoutts> oh, yeah, there is some utf8 thing, dunno how good it is
20:18:40 <dcoutts> there are vague plans for a packedstring module supporting a few standard utf encodings, then with iconv, that should cover most everything
20:19:00 <mm_freak> UTF-8 would suffice
20:19:44 <hoelzro> chessguy, yes
20:19:58 <chessguy> hmm, interesting
20:20:01 <hoelzro> all I know is the distances between the points
20:20:22 <chessguy> so then you've got an undirected graph
20:20:27 <hoelzro> kinda.
20:20:36 <chessguy> and you have to choose one of the actual points you have as the most central?
20:20:40 <hoelzro> yes
20:20:53 <mm_freak> i don't think that's easily possible
20:21:18 <mm_freak> sounds like an NP-complete problem =)
20:21:22 <hoelzro> dammit!
20:21:37 <chessguy> i would think you would need a vector between each pair of points, not just a distance
20:21:46 <oerjan> i guess it depends on your definition of central
20:21:54 <chessguy> consider if all the distances were the same
20:22:00 * SamB_XP_ thinks it's annoying that ByteString isn't polymorphic :-(
20:22:06 <oerjan> you can create a vector coordinate system just from the distances
20:22:10 <mm_freak> well, it might be possible with the distanceâ¦  there is one point which has, in average, the least distance to each other point
20:22:14 <chessguy> the points could all be in a straight line, or in some kind of star configuration
20:22:15 <igli> origin
20:22:22 <mm_freak> you could define this as the most central point
20:22:29 <dcoutts> SamB_XP_: try making a high perf impl that is also polymorphic, the ndp people have been working on it for years :-)
20:22:31 <mm_freak> but that's NP-complete, i.e. slow to compute
20:23:03 <chessguy> hmm, it's n^2, isn't it?
20:23:16 <igli> graph?
20:23:18 <SamB_XP_> dcoutts: yeah and JHC can't even avoid unpacking packed string literals before code generation, it seems...
20:23:34 <chessguy> i'm not sure how accurate that algorithm is though
20:23:35 <mm_freak> chessguy: nope, it something with exponential complexity
20:23:38 <oerjan> provided the distances are consistent with a euclidean space, i don't know on the spot if that is always the case
20:23:38 <igli> hehe that;s better imo tho
20:23:54 <igli> woah this channel is busy! i forgot :)
20:24:09 <igli> @bot
20:24:09 <lambdabot> :)
20:24:11 <chessguy> mm_freak, how do you figure?
20:24:17 <mm_freak> oerjan: whether the space is euklidean or not does not matter, if you only consider the distances
20:24:26 <mm_freak> chessguy: it's the path-finding problem
20:24:36 <SamB_XP_> dcoutts: also aren't the NDP people about to succeed?
20:24:42 <dcoutts> SamB_XP_: but even if we have a polymorphic one, there's some sense in which sequence of byte is special, it's often used like it were continuous, not a sequence of elements at all, but like a chunk or flow of data
20:24:43 <chessguy> hm, ok
20:24:47 <igli> you need two dimensions tho aiui (for 2d)
20:24:49 <chessguy> graph theory is not my strong point
20:24:52 <dcoutts> SamB_XP_: I'm sure they are, yes.
20:24:57 <oerjan> mm_freak: i suppose, if you only minimize distance
20:25:05 <mm_freak> for all points P1..Pn find the shortest path to all other points, and calculate the average of those distances
20:25:14 <SamB_XP_> dcoutts: seeing as associated types seem to be *exactly* what they need
20:25:16 <SamB_XP_> and all
20:25:16 <mm_freak> the one point Px with the least such average should be most central
20:25:24 <mm_freak> but that's a rather intuitive definition
20:25:24 <igli> hmm nice
20:25:31 <igli> tested?
20:25:36 <chessguy> oh
20:25:48 <dcoutts> SamB_XP_: when they manage to get the same performance we can then just define type ByteString = StrictSequence Word8
20:25:55 <chessguy> i thought you were calculating the average distance from each point to an arbitrary point
20:25:58 <oerjan> mm_freak: this is not a path finding problem, you already have the distance between each pair right?
20:26:05 <SamB_XP_> dcoutts: quite so
20:26:25 <SamB_XP_> then I will stop complaining about bytestring not being polymorphic
20:26:25 <dcoutts> SamB_XP_: on the other hand, because we know the type we're working with, we can use lots of shortcuts
20:26:31 <mm_freak> oerjan: between each pair, but you don't have the shortest path from a point to some arbitrary other point
20:26:33 <SamB_XP_> dcoutts: so?
20:26:38 <dcoutts> to improve performance
20:26:40 <SamB_XP_> I don't see how they can't do that too...
20:26:46 <chessguy> anyway, bedtime here. 'night all
20:27:04 <oerjan> mm_freak: i don't interpret this problem as a graph
20:27:08 <dcoutts> SamB_XP_: well, they still need all that code, so maybe it'd just merge
20:27:12 <oerjan> except as a complete one
20:27:18 <SamB_XP_> maybe
20:28:09 <mm_freak> oerjan: what you have is a set of points (vertices), connections between pairs of points (edges) and the distance of each connectionâ¦  sounds like a graph ;)
20:28:53 <dons> anyone got some suggestions of how to compile a list of popular C libraries?
20:29:01 <SamB_XP_> dcoutts: now, clearly, you've contributed wonderfully towards their cause ;-)
20:29:09 <oerjan> mm_freak: no, you have distances between _every_ pair of points, and it sounds like a metric... but then the problem was vaguely stated anyhow
20:29:13 <dons> i'd like a list of smallish C libs to write bytestring bindings to when i'm bored :-)
20:29:33 <dons> dcoutts: suggestions? hmm, the debian package tracker perhaps?
20:29:41 <mm_freak> oerjan: yeah, that's what i meantâ¦  now however you interpret it, the problem remains the same
20:30:02 <oerjan> mm_freak: no, because for a metric the direct distance is already the shortest
20:30:03 <SamB_XP_> emacs ListOfLibs.hs
20:30:12 <oerjan> so you don't need to calculate that
20:30:23 <mm_freak> ah, now i understand
20:30:26 <SamB_XP_> module ListOfLibs where list = [...]
20:30:31 <SamB_XP_> C-x C-c
20:30:33 <dcoutts> dons: take a look at the libs in a standard linux install
20:30:43 <igli> ++
20:30:45 <SamB_XP_> ghc --make ListOfLibs.hs
20:30:45 <mm_freak> that just find the point with the shortest average distance to each other point
20:30:45 <dcoutts> dons: I'll give you my nearly finished iconv binding :-)
20:30:52 <mm_freak> that=then
20:31:07 <SamB_XP_> dons: that's how you compile a list of libraries ;-)
20:31:22 <oerjan> indeed.  should be O(n^2), i think
20:31:38 <mm_freak> yeah, that's O(n^2)
20:31:55 <dcoutts> dons: and various bits of the C lib too I guess
20:32:09 <dons> dcoutts: http://popcon.debian.org/main/by_inst ?
20:32:24 <dons> yeah, a start might just be the string.h functions :)
20:32:36 <dons> a proper light, ncurses binding
20:33:05 <SamB_XP_> dons: .... EWWW
20:33:23 <dcoutts> dons: oh and if you're borred, you can do the fast substring search, Boyer-Moore or KMP (and for .Lazy)
20:33:24 <ont> ncurses is the ui toolkit of tomorrow
20:33:30 <oerjan> anyway, good night
20:33:31 <SamB_XP_> ont: no!
20:33:32 <dons> sorted by votes, http://popcon.debian.org/by_vote
20:33:35 <SamB_XP_> it has no toolkit!
20:33:50 <dons> libpam
20:33:59 <dons> liblocale-gettext-perl
20:34:02 <SamB_XP_> maybe it is the glib of tomorrow, if we can ever figure out how to standardize character widths
20:34:06 <dons> what's libwrap0 ?
20:34:22 <mm_freak> back
20:34:25 <dons> libio-multiplex sounds fun
20:34:38 <mm_freak> <mm_freak> yeah, that's O(n^2)
20:34:38 <dons> we should do a perlish thing here and jsut get people doing bindings.
20:34:40 <SamB_XP_> dons: ... you don't honestly think so?
20:34:46 <SamB_XP_> dons: that won't *WORK*
20:34:54 <SamB_XP_> libio-multiplex, I mean
20:35:03 <dcoutts> dons: oh and openssl and libpcre, but I don't like all those regexp libs, they don't have a sufficiently flexible interface to work with chunked data it'd seem
20:35:14 <dons> hmm. yes.
20:35:22 <dons> yes, a 'proper' regex lib, eh? :)
20:35:32 <dons> ok. wiki page
20:35:48 <SamB_XP_> dons: why would we want to write one in C just so we could write bindings to it, when we ALREADY HAVE ONE WRITTEN IN HASKELL?
20:36:18 <dons> please stop shouting at me SamB_XP_ . its rude.
20:36:24 <SamB_XP_> sorry.
20:36:31 <dcoutts> @ARR!
20:36:31 <lambdabot> Unknown command, try @list
20:36:33 <Botje> now kiss and make up!
20:36:35 <dcoutts> heh
20:36:36 <SamB_XP_> it just seemed like a really stupid, painful idea!
20:36:41 <dons> what?
20:36:50 <SamB_XP_> writing a proper regex lib
20:36:55 <SamB_XP_> in C
20:37:02 <dons> hmm? who had that idea?
20:37:12 <SamB_XP_> you seemed to ;-)
20:37:17 <dons> i think you misunderstand.
20:37:22 <SamB_XP_> oh?
20:37:25 <SamB_XP_> what did you mean?
20:37:30 <dons> scroll up, re-parse :)
20:37:38 <Korollary> he meant bindings I think
20:37:43 <SamB_XP_> <dons> yes, a 'proper' regex lib, eh? :)
20:37:59 <dcoutts> as opposed to the bindings
20:38:04 <SamB_XP_> Korollary: well where is he planning to find a 'proper' regex lib, if not planning to write one?
20:38:05 <dcoutts> as I'd been complaining about
20:38:41 <dcoutts> SamB_XP_: obviously anything 'proper' is written in Haskell, so his meaning is clear :-)
20:38:55 <SamB_XP_> oooh
20:39:01 <SamB_XP_> I thought someone had already written one?
20:39:07 <dcoutts> yeah, several
20:39:16 <SamB_XP_> so... what was the complaint then?
20:39:37 <dons> yeah, i was going to use harpy and an embedded regex lang to on the fly native compile DFAs, in pure haskell.
20:40:00 <dcoutts> heh, nifty
20:40:04 <dcoutts> though a lot of work
20:40:06 <SamB_XP_> oh, I suppose that has the potential to improve performance
20:40:08 <SamB_XP_> possibly
20:40:15 <SamB_XP_> (it's rather a long shot though)
20:40:22 <dcoutts> one needs a higher layer for that kind of stuff
20:40:38 <dcoutts> a virtual assembly language, with the illusion of a arbitrary number of registers
20:40:49 <dons> yeah, needs a bit of abstraction over harpy
20:41:10 <dcoutts> otherwise generating asm directly has to use simple minded register assignment
20:41:34 <igli> rtl
20:41:42 <SamB_XP_> dcoutts: is there a problem with that?
20:41:45 <dons> anyone know of other popularity contests of C libs, other than debians?
20:41:47 <igli> hehe
20:41:49 <dcoutts> SamB_XP_: it's pretty slow
20:41:57 <igli> gentoo ones dons
20:42:10 <igli> 1 sec
20:42:37 <dcoutts> SamB_XP_: see http://augustss.blogspot.com/2007/06/disassembly-harpy-package-also-contains.html
20:42:40 <lambdabot> Title: Things that amuse me, http://tinyurl.com/3c5uuq
20:43:45 <igli> libgpg-error.so is small
20:44:14 <SamB_XP_> so... can you write hell.hs with Harpy?
20:44:18 <sorear> Ideally with good documentation.
20:44:28 <dons> SamB_XP_: yeah, and it would be prettier.
20:44:41 <sorear> Byech, irssi's --more-- is so easy to miss
20:45:38 <dons> dcoutts: ideally i'd want to automate much of the binding
20:45:46 <dons> dcoutts: you reckon c2hs could do, say, string.h ?
20:45:59 <dcoutts> dons: absolutely, I've tested it
20:46:01 <SamB_XP_> dons: would it disassemble the same?
20:46:33 <dons> dcoutts: so you think that's the cheapest path to turn out lots of bindings? start with c2hs, then abstract anything obvious, package, upload?
20:46:37 <sorear> dons: augustss didn't fail to generate good code, he simply didn't try.
20:46:38 <dcoutts> dons: latest darcs version of c2hs parses everything, and if you find any counter examples I need to know :-)
20:46:44 <siti> has anyone compiled hjs (haskell java script inteprator) using (nhc?) in to javascript? ;)
20:46:47 <SamB_XP_> dons: don't be cheap!
20:47:02 <SamB_XP_> dcoutts: does it parse the Linux kernel?
20:47:07 <dons> it does.
20:47:09 <dcoutts> SamB_XP_: yes.
20:47:18 <SamB_XP_> that's impressive.
20:47:25 <sorear> Does it parse GCC?
20:47:25 <dons> we could make millions doing some basic type checking of that source..
20:47:27 <dcoutts> that was one of my main test cases
20:47:35 <SamB_XP_> sorear: that's basically what I just asked...
20:47:38 <SamB_XP_> mostly
20:47:48 <dcoutts> that and all the other core packages on a gentoo system
20:47:48 <SamB_XP_> dcoutts: does it parse nested functions?
20:47:48 <siti> maybe we can have decent autocompletion of c code in a haskell ide then :D
20:47:51 <sorear> SamB_XP_: No, GCC is a very different program from Linux.
20:47:54 <dcoutts> SamB_XP_: yes.
20:48:04 <SamB_XP_> sorear: oh, you meant GCC itself
20:48:05 <sorear> SamB_XP_: One is a compiler, the other is a kernel.
20:48:10 <sorear> yeah :)
20:48:11 <SamB_XP_> I thought you meant GCC syntax
20:48:17 <SamB_XP_> sorry
20:48:20 <dons> siti: did you have the link for the gentoo package popularity?
20:48:25 <dcoutts> SamB_XP_: it parses all of glibc, which includes one nested function.
20:48:32 <SamB_XP_> dcoutts: it does!
20:48:34 <siti> dons: wrong person :p
20:48:38 <SamB_XP_> I didn't know that
20:49:03 <SamB_XP_> does it parse ZSNES?
20:49:09 <SamB_XP_> ;-P?
20:49:10 <dons> igli: i mean :)
20:49:10 <dcoutts> try it
20:49:14 <sorear> SamB_XP_: ZSNES isn't C, is it?
20:49:18 <igli> hmm?
20:49:31 <igli> oh nfc
20:49:47 <dcoutts> SamB_XP_: if gcc can parse it, c2hs's parser should be able to too
20:49:50 <igli> packages.gentoo.org is the only link i use for packages
20:50:01 * SamB_XP_ is kidding -- zsnes is The Super Nintendo Emulator which is 69.9867% x86 assembly
20:50:19 <ont> You can't buy that kind of portability.
20:50:19 <sorear> Is that with comments?
20:50:23 <igli> http://forums.gentoo.org/viewtopic-t-547205.html is nice dons
20:50:28 <SamB_XP_> sorear: sadly few comments
20:50:29 <dcoutts> SamB_XP_: if it's inline assembly in .c files it'd work ok
20:50:36 <SamB_XP_> dcoutts: it's NASM assembly
20:50:56 <sorear> SamB_XP_: c2hs can parse NASM
20:50:56 <dcoutts> we don't parse the assembly, just record it as a string
20:51:01 <sorear> +probably
20:51:04 <sorear> :)
20:51:12 <SamB_XP_> ... and do what with it?
20:51:12 <dons> who's working on hackage, btw?
20:51:18 <dons> can we get online recategorisation working?
20:51:31 <sorear> dons: I think it says on the page?
20:51:34 <SamB_XP_> I had enough trouble porting some of it to *C*
20:51:50 <dcoutts> dons: mostly Ross isn't it?
20:52:19 <SamB_XP_> which has recently had to be essentially trashed
20:52:35 <SamB_XP_> though I'm hoping they find use in some of it's remains
20:52:42 <dons> no, the SoC student.
20:53:34 <sorear> Sacha Boehm
20:53:44 <sorear> *Boehme
20:53:49 <sorear> *Sascha
20:53:52 <mgsloan> aw, I was about to say
20:54:06 <mgsloan> mighta been related to the garbage collector person
20:54:11 <sorear> http://code.google.com/soc/2007/haskell/appinfo.html?csaid=D505A03B8B64C3BF
20:54:13 <lambdabot> Title: Google Code - Summer of Code - Application Information, http://tinyurl.com/32zvtn
20:54:24 <mgsloan> (Boehm C/C++ thingamambob)
20:54:36 <sorear> yeah
20:54:42 <dons> ?where c2hs
20:54:42 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
20:54:51 <dons> dcoutts: what's the current repo? d.h.o/c2hs?
20:54:57 <dcoutts> yep
20:55:29 <dons> i might get a chance to turn "use c2hs to do a quick binding" into a small tut by the weekend,
20:55:39 <dons> then we can get the lazy programmer army to do more bindings... :)
20:55:53 <igli> hehe
20:55:58 <igli> i mean yay! ;D
20:56:19 <dons> i'll go through the irc user's list, by most comments,
20:56:30 <dons> and if they're not meeting their librari quota, they can get a kick
20:56:37 <ont> "Motivationally challenged"
20:56:46 <dcoutts> dons: and make sure you've got the latest Cabal, and you can try the Cabal/c2hs integration work I did a while back
20:56:59 <dons> darcs c2hs and darcs cabal, eh?
20:57:08 <dcoutts> dons: yes
20:57:09 <dcoutts> dons: and you can tell me what needs further improvement
20:57:16 <dons> ok
20:57:26 <dcoutts> and yeah, we should do releases of both :-)
20:58:29 <dons> hmm, i wonder if i should be using the newer CString bindings
20:58:33 <dons> in Data.ByteString..
20:59:42 <dcoutts> probably
21:06:25 <dons> supposing we release 1.0 soon
21:16:17 <siti> hmm compact strings still has issues with ghc 6.6.1 :(
21:28:07 <Limbic_Region> hoelzro - you there?
21:30:40 <sorear> he talked quite recently
21:31:20 <sorear> where recently is over an hour ago... :(
21:46:15 <dons> cabal depends on a non-hackage package? http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pretty?
21:46:18 <lambdabot> http://tinyurl.com/2w83ys
21:48:04 <dons> dcoutts: c2hs/c/CParser.hs:24:7:
21:48:04 <dons>     Could not find module `Array':
21:48:04 <dons>       it is a member of package haskell98, which is hidden
21:50:36 <sjanssen> dons: pretty is a new package from the split in HEAD
21:51:01 <dons> hmm, not available anywhere yet, but its to hold Text.PrettyPrint.SPJ ?
21:51:32 <dons> 'sok though, my older cabal seems to build c2hs darcs happily
21:56:37 <tga> howdy folks
21:56:51 <araujo> what is a good synonym for 'information'?
21:57:05 <sjanssen> data?
21:57:05 <tga> data
21:57:06 <dons> 'data'?
21:57:09 <araujo> i am trying to use the word as a label for an option to show module information ....
21:57:13 <sjanssen> @quote stereo
21:57:13 <araujo> mmm...
21:57:13 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
21:57:14 <dons> majestic stereo streo
21:57:18 <araujo> haha
21:57:31 <dons> 'content'?
21:57:38 <araujo> mmm...
21:57:42 <araujo> that sounds good dons
21:57:44 <tga> knowledge :)
21:57:48 <scook0> 'properties'?
21:58:02 <araujo> yeah, good scook0
21:58:06 <dons> ok, what's a better name for:  :: MonadPlus m => Maybe a -> m a
21:58:12 <dons> maybeToMonadPlus -- :: MonadPlus m => Maybe a -> m a
21:58:13 <araujo> i think that could make it ....
21:58:15 <dons>  is not right.
21:58:29 <igli> hi araujo
21:58:34 <araujo> hello igli
21:58:37 <araujo> dons, why not?
21:58:41 <Heffalump> msum . catMaybes
21:58:42 <igli> yeah ++data :)
21:58:56 <dons> the function is:
21:58:56 <dons> maybeToMonadPlus :: MonadPlus m => Maybe a -> m a
21:58:57 <dons> maybeToMonadPlus = maybe mzero return
21:59:01 <dons> but the name is too verbose.
21:59:12 <dons> :t guard
21:59:14 <Heffalump> mFromJust ?
21:59:15 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
21:59:26 <igli> what does it do if you had to explain it to a 6 year old dons :)
21:59:32 <sjanssen> dons: I'd call it maybe mzero return :)
21:59:32 <araujo> Haskell , the programming language where the function names are bigger than their actual body
21:59:38 <igli> lol
21:59:46 <dons> and where the types are bigger than both!1
21:59:50 <araujo> haha
21:59:51 <igli> those 8 space indents tho man
21:59:53 <tga> so what's the recommended tutorial for starting out with Haskell and fp?
22:00:04 <igli> wiki?
22:00:06 <sjanssen> dons: maybeReturn?
22:00:14 <dons> igli: it lifts Maybe values into a MonadPlus type
22:00:20 <glguy> :t fromMaybe mzero return
22:00:22 <lambdabot>     Couldn't match expected type `Maybe (m a)'
22:00:22 <lambdabot>            against inferred type `a1 -> m1 a1'
22:00:36 <igli> http://haskell.org/haskellwiki/Blog_articles is good tga
22:00:37 <lambdabot> Title: Blog articles - HaskellWiki
22:00:53 <tga> thanks
22:01:16 <igli> dons: `definite' ;)
22:01:18 <glguy> :t maybe mzero return
22:01:20 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
22:01:24 <dons> maybeToList        -- :: Maybe a -> [a]
22:01:25 <dons> hmm
22:01:29 <igli> hmm
22:01:40 <igli> Lift Maybe to X
22:02:09 <dons> anyone know some category theory term for this lifting?
22:02:22 * igli hides
22:02:29 <dons> Cale: ?
22:02:37 <igli> ffs if you can have thingy.. ;)
22:02:49 <glguy> :t maybe (fail "mzero") return
22:02:52 <lambdabot> forall (m :: * -> *) a. (Monad m) => Maybe a -> m a
22:03:15 <sjanssen> glguy: if you make that suggestion everybody will whine about fail
22:03:27 * dons smacks glguy around with a MonadPlus
22:03:41 <sjanssen> personally, I see no problem with using fail
22:03:42 * igli gets out the way
22:03:43 <glguy> people will deal with it, they use head already
22:03:46 <Cale> dons: Not really a category theory term, but I'd probably call it something like "the natural embedding"
22:03:58 <igli> ew
22:04:02 <glguy> lol: the_natural_embedding (Just 1)
22:04:04 <dons> yes, I was pondering that.
22:04:18 <sjanssen> in an ideal world we would've had a MonadZero class the whole time -- but that isn't the case today
22:04:21 <igli> definite (maybe blah)
22:04:33 <dons> sjanssen: upload monadzero to hackage.haskell.org :)
22:04:38 <tga> what planet are you people from, I can't understand a thing
22:04:42 <igli> sure (maybe blah)
22:04:49 * tga heads off to read some intro blog posts
22:04:53 <dons> tga, planet haskell :)
22:04:57 <igli> hehe
22:05:01 <igli> it's a wonderful place
22:05:02 <sjanssen> dons: too late -- the monad desugaring already uses Monad's fail
22:05:07 <dons> boo
22:05:34 <dibblego> what are we generalising today?
22:05:36 <Cale> tga: YAHT is a good place to start, or the Wikibook, if nobody's suggested those yet.
22:05:42 <Cale> @where yaht
22:05:42 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
22:05:45 <Cale> @where wikibook
22:05:45 <lambdabot> http://en.wikibooks.org/wiki/Haskell
22:05:49 <dons> ok, so did we get any reasonable names?
22:05:54 <igli> yeah yaht is good
22:05:56 <dons> for maybeToMonadPlus :: MonadPlus m => Maybe a -> m a
22:06:01 <tga> I already got yaht in the queue
22:06:03 <tga> cool, thanks
22:06:05 <sjanssen> dons: is maybeReturn 'good'?
22:06:10 <dons> yeah
22:06:12 <tga> I think I got low-level formatted to procedural
22:06:14 <sjanssen> s/good/reasonable
22:06:24 <glguy> sjanssen: I like that, and was about to recommend it
22:06:25 <igli> dons: anything that's opposite to `Maybe' imo
22:06:51 <igli> just not surely, as that's far too academic ;)
22:07:31 <Cale> The MonadZero change can't really be in a separate package, can it?
22:08:06 <glguy> an antonym of maybe is definitely :)
22:08:12 <igli> hehe
22:08:21 <igli> shorter is better to type tho
22:08:24 <dons> the class at least, and some uses, surely?
22:08:24 <sjanssen> Cale: nah, it cuts clear down to the Prelude and do-desugaring
22:08:32 <Cale> sjanssen: I agree.
22:08:32 <dons> you'd be redoing base
22:08:40 <sjanssen> dons: and desugaring
22:08:52 <dons> yup
22:08:55 <Cale> Anyone here on the H' team?
22:08:56 <sjanssen> it'd take -fno-implicit-prelude to do it right
22:09:04 <sjanssen> Cale: dons is :)
22:09:10 <dons> Cale: yup?
22:09:22 <kfish> dons: http://artfulcode.nfshost.com/files/wrapping-a-c-library-in-lisp-part-1.html
22:09:22 <dons> want to ask for monad comprehensions and monad zero?
22:09:23 <Cale> Is MonadZero being considered for H'?
22:09:24 <lambdabot> Title: Wrapping a C Library in Lisp Part 1 | Lisp | Artful code, http://tinyurl.com/2tvrf2
22:09:27 <Cale> yes
22:09:30 <dons> kfish: oh, timely!
22:09:42 <dons> Cale: not sure. but you could make it so.
22:09:43 <sjanssen> Cale: I bet MonadZero would break tons of code
22:09:51 <dons> same wrt. monad comprehensions
22:09:59 <dons> at least have people thinking about it.
22:10:11 <Cale> Well, monad comprehensions can remain optional if people really want :)
22:10:30 <Cale> But I really strongly think do-notation should go back to the 1.4 definition.
22:11:41 <kfish> geez, i follow this interesting link about incremental parsing in ocaml and it turns out to be by oleg
22:11:50 <sorear> We broke tons of code 1.2 -> 1.3.  We broke tons of code 1.3 -> 1.4.  We broke tons of code 1.4 -> 98.
22:11:54 <sjanssen> @quote OlegFacts
22:11:54 <lambdabot> OlegFacts says: Oleg can express any computable function using only the K combinator
22:12:03 <kfish> http://caml.inria.fr/pub/ml-archives/caml-list/2007/07/7a34650001bf6876b71c7b1060ac501f.en.html
22:12:05 <lambdabot> Title: Archives of the Caml mailing list > Message from oleg@p..., http://tinyurl.com/38xr4w
22:12:08 <dons> hmm, is there a stream fusion embedding of dlists?
22:12:12 <sjanssen> sorear: Haskell' is intended to be more conservative, I think
22:12:17 <Heffalump> 98 has special status, though
22:12:18 <dons> kfish: yeah, is that the delimited continuations post?
22:12:20 <Heffalump> as does H'
22:12:33 <kfish> dons: yes
22:12:33 <sorear> Heffalump: Yes, and ghc +98 will continue to work. :)
22:12:35 <sjanssen> sorear: besides, was there really that much Haskell code in that time?
22:13:05 <Heffalump> I'm just saying that 98->H' isn't comparable to those other transitions
22:13:21 <Heffalump> I'd like to see a lot of stuff fixed at the cost of backwards compatibility, myself.
22:23:33 <Botje> @pl \l l1 -> zipWith max (map length l) l1
22:23:34 <lambdabot> zipWith max . map length
22:23:43 <Botje> aha.
22:23:57 <Botje> @pl \l1 l -> zipWith max (map length l) l1
22:23:57 <lambdabot> flip (zipWith max . map length)
22:24:18 <glguy> could someone recommend a link to a site or paper that explains more about what delimited continuations are and why they are useful?
22:24:50 <dons> they seem to be able to explain a lot of interesting control flow problems
22:24:58 <dons> transactions, zippers, file systems
22:25:10 <dons> one good reference is last year's icfp paper
22:25:24 <dons> ...
22:25:39 <dons> ah no, wrong one.
22:25:42 <dons> stuff by oleg.
22:25:48 <glguy> Delimited Dynamic Binding
22:25:48 <glguy> Oleg Kiselyov (FNMOC), Chung-chieh Shan (Rutgers University), Amr Sabry (Indiana University)
22:25:51 <glguy> that one?
22:25:56 <igli> what;s the diff between a delimited and a standard continuation?
22:26:02 <dons> that's it, but its not the paper. there's earlier ones.
22:26:14 <igli> hmm
22:29:09 <dolio> glguy: http://okmij.org/ftp/papers/context-OS.pdf
22:29:27 <dolio> glguy: I think that's the best paper I've read so far for explaining what you'd do with delimited continuations 'for real.'
22:30:12 <dolio> Or, how pervasive they are, perhaps.
22:30:27 * dons notes some domain specific optimisations in Data.DList, tosses in some rules to trigger them.
22:30:32 <dons> rules are cool. everyone should use them!
22:37:58 <dolio> igli: A normal continuation represents 'the rest of the execution of the program.' So when you capture one, and call it, it aborts whatever you were doing, and performs the rest of the computation with whatever value you called it with...
22:38:51 <igli> i know what a normal one is; what's a delimited one?
22:38:56 <dolio> igli: Delimited continuations let you place markers, so you can capture 'the rest of the execution until you hit a marker.'
22:39:03 <igli> heh ok
22:39:15 <dolio> Which will return when it's called, eventually, among other things.
22:40:16 <sorear> Perhaps the best way to grok delimited continuations is to study the delimited CPS transform.
22:41:12 <dfranke_> sjanssen/dons: I was just looking at the xmonad site and noticed vimperator recommended.  I use conkeror and like it; it seems sensible to mention that alongside it.
22:42:50 <dons> dfranke_: screenshot, perhaps?
22:43:13 <dons> vimperator's only mentioned because several people asked what it was in the screenshots
22:44:26 <sorear> Unfortunately, my only nice screenshot is hated by dons and sjanssen ;)
22:44:43 <igli> heh no dolio;s explanation sufficed, thanks sorear :-)
22:45:20 <rretzbach> Hi igli :)
22:45:29 <igli> hi rretzbach :)
22:45:44 <igli> thought you were a bash head?
22:46:12 <igli> heh haskell ;D
22:46:13 <rretzbach> I learn what I can :>
22:46:21 <igli> cool! 8D
22:46:30 <sorear> rretzbach's actually been here for a bit of a while.
22:46:32 <dons> SamB_XP_: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist-0.3
22:46:33 <igli> oops
22:46:35 <lambdabot> http://tinyurl.com/2uzn2v
22:46:37 <igli> hehe
22:46:48 <rretzbach> I have only 1w Haskell xp.
22:47:05 <glguy> and how much gold?
22:47:19 <igli> lol
22:47:27 <rretzbach> Enough for a spell which transforms you into a dwarf :\
22:47:33 <igli> lmao
22:47:40 <igli> too late sunshine ;D
22:47:44 <glguy> well, lets hope you don't have enough mana then!
22:47:48 <rretzbach> But I'm not really cool with using Monads.
22:48:10 <rretzbach> Understanding them and using them are two different things.
22:48:11 <igli> heh think of em as list comprehension + housekeeping aiui
22:48:20 <igli> hmm true
22:48:40 <dfranke_> dons: sure, I'll make one... but I'm not sure how :-).  I used to use ksnapshot but now I don't use KDE anymore.
22:48:41 <igli> and i think control flow?
22:49:03 <sorear> dfranke_: http://members.cox.net/stefanor/snap
22:49:44 <sorear> dfranke_: I wrote a script to automate the whole process (requires X11 and netpbm; my upload script, ftp, and my password are needed for the autoupload feature)
22:50:34 <ski> dons : 'injectMaybe' ?
22:50:50 <igli> rretzbach: do you get datatypes in haskell?
22:51:06 <ski> (i'd have said 'fromMaybe' if it wasn't taken)
22:51:22 <rretzbach> igli: Thanks for your help, but this is no time for learning, only chatting : >
22:51:29 <igli> heh np :D
22:51:36 <rretzbach> I have to go to work in a few minutes.
22:51:36 <igli> i don't personally yet
22:51:40 <igli> ah ok
22:52:03 <dons> ski: destoryMaybe ? :)
22:52:06 <igli> `surely' not :D
22:52:15 <dons> de-stroy- . i always mistype that.
22:52:16 <ski> s/destory/destroy/ ??
22:52:37 <ski> i think 'destroy' is the wrong connotation
22:52:52 <dons> its an elimination form for maybes though.
22:52:57 <dons> of some kind.
22:53:00 <igli> man it looks useful, so it should be short
22:53:02 <ski> the 'Maybe' is present, in a sense in the 'm' in question
22:53:16 <ski> hm
22:53:19 <ski> maybe
22:53:20 <dons> its a 'lift' if ever there was one. lifting to a more general set of types
22:53:30 <igli> heave -ho ;)
22:53:33 <ski> embedMaybe
22:53:42 <dons> natLift , liftmplus
22:54:03 <igli> ew horrid to type imo (/me stfu ;)
22:54:58 <Cale> liftMaybe
22:55:35 <ski> @type msum
22:55:38 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
22:55:44 <ski> hm
22:56:08 <ski> is there an 'forall a m. MonadPlus m => [a] -> m a' ?
22:56:25 <ski> would that be 'liftList', then ?
22:56:27 <sorear> yes
22:56:27 <sorear> msum . map return
22:56:41 <Cale> I like calling that one 'option'
22:56:57 <sorear> foldr (mplus . return) mzero
22:57:15 <dfranke_> dons: http://dfranke.us/xmonad-conkeror.jpg, you can crop the right half.
22:57:15 <ski> 'option' to me sounds like "optional", i.e. either one or none
22:57:33 <dfranke_> dons: (two monitors and that's my desktop background on the right one)
22:57:48 <Cale> Well, in context it makes sense, since it's always followed by a list of options
23:01:01 * ski nods ..
23:04:53 <narain> ?index callCC
23:04:54 <lambdabot> Control.Monad.Cont
23:05:13 <helikoptik> hello
23:05:18 <sorear> Hello.
23:06:32 <dfranke_> dons: by the way... for the past couple days I've come home and seen an xdm login prompt rather than my desktop, X having seemingly crashed... I'm not sure what's causing it and I haven't seen it happen yet, but have you perchance gotten any reports of xmonad randomly crashing?
23:06:41 <dfranke_> (another suspect is my cat)
23:07:12 <dons> no crashes reported for quite a while
23:07:26 <dons> check your .xsession-errors file before logging back in next time
23:08:49 <dfranke_> oh, I just figured it out...
23:09:18 <dfranke_> I have the X VNC module loaded, and I just tried telneting to port 5900 and then disconnecting, and X reset.
23:09:32 <dfranke_> so X is probably crashing when I get portscanned.
23:10:17 <dons> scary
23:10:28 <opqdonut> woah
23:11:21 <dfranke_> I think I'll maybe disable that...
23:23:56 <ski> "Haskellers are better at looking at things in funny ways and making sense of them, even if they don't really make sense..." :D
23:28:22 <dons> ski, where's that from?
23:28:38 <shachaf> dons: #scheme
23:53:34 <vincenz> Moin
23:54:01 <igli> m00
