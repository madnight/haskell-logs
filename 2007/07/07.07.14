00:00:12 <mm_freak> sjanssen: and there is no way to enforce such a strictness?
00:00:15 <sjanssen> mm_freak: it doesn't matter how strict (+) is if you never demand a result from it
00:00:21 <mm_freak> (not that i want to do it, just to understand)
00:00:32 <Cale> ojacobson: In a pattern, the thing on the right of the @ is matched, and might bind some variables, and the whole thing it matches is bound to the var on the left
00:01:04 <Cale> So there, n@(RawNat _) matches things of the form (RawNat _), binding the whole thing matched to n.
00:01:14 <ojacobson> Cale: ah, so a way to refer to both the individual args to a constructor as well as the constructed value, for example
00:01:16 <sjanssen> mm_freak: strictness is purely demand driven -- you can adjust strictness whenever you can stimulate demand (via seq or pattern matching)
00:01:18 <Cale> yeah
00:01:23 <Cale> exactly
00:01:28 <ojacobson> Cale: so that'd just be "case where n is a RawNat")
00:01:40 <Cale> ojacobson: yep
00:01:48 <ojacobson> Cale: thank you so much for helping me think through this
00:01:55 <ojacobson> Cale: teachers beat the hell out of self-education
00:01:59 <Cale> mm_freak: If it helps, writing x `seq` x is *always* pointless.
00:02:30 <mm_freak> cale: yeah, i noticed =)
00:02:32 <Cale> mm_freak: because if you're evaluating (x `seq` x), you would have been evaluating x
00:03:22 <shachaf> mm_freak: You can't escape the laziness!
00:03:30 <mm_freak> and (x `seq` (x+y)) will demand (calculate) x, and then create a thunk with (+y) x ?
00:03:32 <Cale> There's no way to define a function such that applications of that function are automatically reduced before their time.
00:03:44 <mm_freak> where the x in the thunk is already a value
00:03:48 <Cale> mm_freak: With (x+) y
00:03:57 <Cale> Or just (+) x y
00:03:57 <mm_freak> uhm yeah
00:04:00 <shachaf> mm_freak: No matter how strict your function is, if the parts just outside it are lazy it won't do any good (or bad, or anything).
00:04:16 <mm_freak> yeah
00:04:22 <Cale> mm_freak: But! Given that the whole expression has been demanded, evaluation must proceed
00:04:40 <Cale> So (+) x y will then be evaluated up to its top level constructor.
00:04:51 <Cale> (with x already having been evaluated)
00:05:13 <ojacobson> mm_freak: consider a `seq` y where a = x + y
00:05:35 <ojacobson> (or not, I might be talking through my hat)
00:05:47 <mm_freak> so (x+y) is translated into a thunk, where x and y are still to calculate before the addition, while (x `seq` y `seq` (x+y)) will generate thunk, where only the addition has still to be executed?
00:06:01 <shachaf> ojacobson: Why the where?
00:06:02 <Cale> That'll evaluate x + y, which will probably demand y and then return y
00:06:14 <shachaf> ojacobson: That's (x + y) `seq` y
00:06:20 <Cale> mm_freak: (x+y) is probably already a thunk.
00:06:22 <ojacobson> shachaf: assuming a = (x + y) is used elsewhere later in the function
00:06:50 <Cale> Well, you know the compiler might optimise :)
00:06:58 <shachaf> Cale: But not necessarily, if (+) is, say, flip const.
00:07:02 <Cale> But taking a naive view...
00:07:14 <mm_freak> cale: but it will enforce calculation of x and y right at that place, did i get it? =)
00:07:34 <Cale> When it itself is asked to evaluate
00:07:41 <Cale> (assuming it's the usual (+))
00:07:42 <mm_freak> yeah
00:08:02 <mm_freak> assuming that (+) itself is non-strict in its arguments
00:08:09 <Cale> Evaluation happens outermost-first leftmost-first.
00:08:18 <Cale> yeah
00:08:21 <Cale> er
00:08:25 <Cale> non-strict?
00:08:37 <Cale> Usually (+) is strict in both parameters.
00:08:49 <mm_freak> cale: yeah, but let's suppose it isn't
00:08:54 <Cale> okay
00:09:02 <Cale> let's use const as an example :)
00:09:07 <Cale> const x y = x
00:09:13 <mm_freak> then (x `seq` y `seq` (x+y)) will make it strict in both arguments…  i.e. it will demand x and y when it itself is demanded, right?
00:09:20 <Cale> oh, yes
00:09:24 <Cale> certainly
00:09:33 <mm_freak> k…  that was my question =)
00:09:35 <mm_freak> thank you al
00:09:35 <mm_freak> l
00:09:50 <Cale> did I go through the foldl/foldl' thing with you?
00:09:50 <ojacobson> which (+) would do anyways, but if it were `fooNonStrict` instead might not... I think?  (Sort of half-following and hoping it makes sense later)
00:10:07 <mm_freak> cale: you don't have to, but IIRC you did
00:10:10 <Cale> ojacobson: yeah
00:10:30 <Cale> If you want, I can do it again :)
00:10:41 <ojacobson> Cale: nah, I think I got as much as I'm likely to get
00:11:00 <mm_freak> foldl (+) will build up a lot of thunks
00:11:07 <ojacobson> Still working out how wli's polynomial stuff actually works.  The light in my head is already blinding from understanding more stuff.
00:11:28 <Cale> mm_freak: Well, I don't really tend to think of it on that level -- I usually say that it builds up unevaluated expressions.
00:11:35 <mm_freak> each thunk adding a number to an expression
00:11:38 <Cale> But you can use the word thunk anyway :)
00:11:41 <ojacobson> Cale: would foldl' (or foldr') on an infinite list be a bad, bad idea?
00:11:52 <Cale> foldr on an infinite list is a fine idea
00:11:57 <ojacobson> note 's
00:11:58 <Cale> foldr' doesn't exist
00:12:00 <mm_freak> cale: i like to understand things at the low level =)
00:12:03 <ojacobson> oopo
00:12:10 <Cale> either foldl or foldl' on an infinite list is a bad idea
00:12:11 <ojacobson> probably for that very reason
00:12:26 <ojacobson> @src (foldl)
00:12:26 <lambdabot> Source not found. Where did you learn to type?
00:12:29 <ojacobson> grr
00:12:32 <Cale> foldl f z [] = z
00:12:32 <ojacobson> is there a manual for that thing?
00:12:37 <shachaf> @src foldl
00:12:37 <lambdabot> foldl f z xs = lgo z xs
00:12:37 <lambdabot>     where lgo z []     =  z
00:12:37 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
00:12:44 <ojacobson> oh right
00:12:45 <|Steve|> You know, I can't for the life of me keep foldl and foldr straight. What are the left and right supposed to mean?
00:12:46 <Cale> don't bother with @src's version
00:12:48 <Cale> foldl f z [] = z
00:12:48 <ojacobson> ok, clue received
00:12:49 <shachaf> Doesn't work with the parentheses.
00:12:50 <mm_freak> ojacobson: foldl on an infinite list will blow your heap up, and foldl' will just not terminate
00:12:59 <shachaf> Cale: True, @src's version is odd.
00:13:00 <Cale> foldl f z (x:xs) = foldl f (f z x) xs
00:13:17 <Cale> See, the first thing which happens is it calls itself.
00:13:27 <Cale> (outermost-first evaluation, remember)
00:13:44 <ojacobson> @src's version looks like the logic has been put in a second, inner function?
00:13:44 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
00:13:45 <TSC> |Steve|: associativity of the operator
00:14:00 <Cale> So that foldl just immediately expands to another foldl and so on until the list runs out
00:14:10 <Cale> and then the accumulated expression starts to evaluate
00:14:22 <Cale> and if it's too large, you can easily blow up your stack :)
00:14:38 <ojacobson> Calc: hence foldr when you want to be lazier?
00:14:40 <ojacobson> @src foldr
00:14:40 <lambdabot> foldr k z xs = go xs
00:14:40 <lambdabot>     where go []     = z
00:14:40 <lambdabot>           go (y:ys) = y `k` go ys
00:14:44 <Cale> blah
00:14:56 <Cale> The @src's source code sucks for reading
00:15:00 <Cale> foldr f z [] = z
00:15:00 <shachaf> foldr f z [] = []
00:15:05 <mm_freak> |steve|: foldr will generate (a + (b + (c + d))), while foldl will generate (((a + b) + c) + d)
00:15:08 <shachaf> I mean z, sorry.
00:15:12 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
00:15:14 <shachaf> Never mind.
00:15:24 <|Steve|> mm_freak: Okay.
00:15:31 <mm_freak> |steve|: i.e. evaluation direction, or more precisely, as tsc named it, operator associativity
00:15:54 <ojacobson> Cale: right, got it (and compared with foldl for enlightenment)
00:16:02 <|Steve|> Seems like either would blow up your stack.
00:16:15 <Cale> So the first thing which happens when foldr f z (x:xs) is evaluated is it expands into f x (...), and if f doesn't need (...), there's no recursion.
00:16:16 <|Steve|> What'd you'd really like is some tail recursive call like scheme would give you.
00:16:18 <ojacobson> |Steve|: nah, there's at most one unevaluated foldr at a time
00:16:22 <ojacobson> looks like, anyways
00:16:33 <Cale> Because it's outermost-first
00:16:36 <shachaf> Can a function that works from [a] to [a] generally be expressed as either a foldr or an unfoldr?
00:16:52 <Cale> shachaf: not necessarily, unfortunately
00:16:58 <ojacobson> Cale's right, I'm still talking through my chapeau
00:17:18 <ojacobson> hmm
00:17:20 <ojacobson> @src map
00:17:20 <lambdabot> map _ []     = []
00:17:20 <lambdabot> map f (x:xs) = f x : map f xs
00:17:33 <Cale> map f = foldr ((:) . f) []
00:17:38 <shachaf> map f = foldr ((:).f) []
00:17:47 <Cale> stereo.
00:17:48 <ojacobson> heh
00:17:49 <Cale> hehe
00:17:54 <ojacobson> Clearly, my mind is easily-read
00:18:11 <shachaf> Cale doesn't like to @quote himself? :-)
00:18:11 <Cale> foldr is really the more natural foldr
00:18:14 <Cale> fold*
00:18:25 <Cale> I'm actually sick of that @quote
00:18:41 <Cale> It says my name which causes my irc client to beep.
00:18:54 <|Steve|> Which quote?
00:18:58 <shachaf> Cale: Can't you make it not beep?
00:19:00 <Cale> the stereo quote
00:19:11 <dons> hah
00:19:13 <roconnor> shachaf: does the function from [a] to [a] have to be polymorphic in a?
00:19:14 <Cale> shachaf: yes, but then people who actually need my attention won't get it
00:19:20 <ojacobson> So how often does this chain of thoughts come up in this channel, anyways, that you guys are answering this fast?
00:19:31 <Cale> ojacobson: every few days on average
00:19:32 <dons> fairly often
00:19:32 <shachaf> Cale: I mean, for that specific quote.
00:19:42 <ojacobson> Henh.  Sorry to be a bore, then :)
00:19:48 <ojacobson> And thanks for being tolerant.
00:19:48 <Cale> shachaf: Not without going in and modifying the source code
00:19:50 <|Steve|> ojacobson: I learned something too.
00:19:53 <Cale> ojacobson: It's not a prolem
00:19:55 <Cale> problem*
00:20:37 <Cale> foldr can be viewed as a direct structural transformation on the list datastructure
00:20:50 <dons> the stereo quote first appeared on 07.01.05 , iirc
00:20:59 <dons> since then it has been used 114 times
00:21:02 <|Steve|> I still have no idea what this quote is.
00:21:06 <shachaf> dons: That late?
00:21:08 <Cale> foldr f z replaces each (:) with f and each [] with z
00:21:10 <dons> ?quote stereo
00:21:11 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
00:21:13 <dons> that one.
00:21:19 * shachaf thought it'd always been around. :-)
00:21:30 <dons> `07.01.20:15:42:28 <Cale> Welcome to #haskell where your questions are answered in majestic stereo!'
00:21:35 <|Steve|> Oh.
00:21:51 <dons> now its become part of the culture, when ever we're too eager to answer
00:22:02 <dons> sometimes you might get 4 or 5 simultaneous replies, on a busy day
00:22:15 <ojacobson> Cale: stupid analogy time -- foldl replaces every element e with (e, every : with f, and stacks ) on the end to balance?
00:22:15 <|Steve|> Haha, I see.
00:22:16 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
00:22:19 <lambdabot> Title: Fold Diagrams - CaleWiki
00:22:23 <|Steve|> And I thought that #math was bad for that.
00:22:30 <Cale> look at the diagrams :)
00:22:46 <shachaf> dons: You could change it to be Cal_e or similar, so it won't beep.
00:22:52 <|Steve|> Funny thing is this is the second time that Cale has explained this to me.
00:23:04 <Cale> There are some possibly easier to interpret ones for the scanls at the bottom
00:24:00 <ojacobson> Cale: scan? is too much yet, I'll come back to it
00:24:24 <Cale> They give you a list where the nth element is sort of the nth subexpression in computing the corresponding fold.
00:24:29 <ojacobson> (which means now I'm punching scanr into hugs)
00:24:40 <Cale> > scanl (+) 1 [1..10]
00:24:41 <lambdabot>  [1,2,4,7,11,16,22,29,37,46,56]
00:24:43 <Cale> > scanl (+) 0 [1..10]
00:24:45 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55]
00:25:05 <Cale> That's [0, 0+1, (0+1)+2, ...]
00:25:16 <shachaf> Why do people use hugs, generally?
00:25:24 <|Steve|> Because of :e
00:25:33 * shachaf has never used it -- what advantages does it have over GHC(i)?
00:25:38 <Cale> On Windows, there's a GUI version.
00:25:41 <|Steve|> Or because it takes 1/30 the time to compile.
00:25:48 <ojacobson> shachaf: first thing someone mentioned
00:25:48 <Cale> You don't compile GHC.
00:25:59 <shachaf> |Steve|: What's :e?
00:26:03 <|Steve|> I have had to for 2 platforms now.
00:26:14 <|Steve|> shachaf: Let's you edit the current file.
00:26:18 <Cale> |Steve|: really? Which ones?
00:26:30 <|Steve|> I.e., it opens your editor.
00:26:31 <Cale> |Steve|: You should contribute binaries :)
00:26:37 <davidL> do I need to use lambdabot-dynamic in order for evaluations such as "> 1+1" to work?
00:26:50 <|Steve|> Cale: I had to do it for powerpc linux because the one for ubuntu didn't support ghci.
00:26:55 <shachaf> |Steve|: GHCi has that too, no?
00:26:57 <Cale> davidL: no, you just need runplugs, which comes with it
00:27:06 <ski> > foldr (\n s -> concat ["(",show n," + ",s,")"]) "42" [1,2,3,4]
00:27:07 <|Steve|> I also did it through macports for OS X.
00:27:07 <ski> > foldl (\s n -> concat ["(",s," + ",show n,")"]) "42" [1,2,3,4]
00:27:08 <lambdabot>  "(1 + (2 + (3 + (4 + 42))))"
00:27:09 <lambdabot>  "((((42 + 1) + 2) + 3) + 4)"
00:27:09 <davidL> Cale: do I have to manually start runplugs?
00:27:19 <Cale> davidL: It will run runplugs itself.
00:27:38 <davidL> I get an error whenever I do "> foo"
00:27:44 <Cale> which error?
00:27:47 <|Steve|> shachaf: Possibly. I haven't found it though.
00:27:59 <shachaf> |Steve|: :help ?
00:28:02 <davidL> cale: Failed to load interface for `ShowQ':
00:28:10 <Cale> davidL: oh
00:28:12 <shachaf> |Steve|: :edit                       edit last module
00:28:22 <|Steve|> Crazy, it worked.
00:28:31 <|Steve|> I swear I was trying it on my office computer and it didn't.
00:28:36 <Cale> davidL: I fixed that in my copy by removing ShowQ from the import list in RunPlugs.hs
00:28:41 <|Steve|> Lemme ssh in and give it a shot.
00:28:43 <Cale> (and maybe L.hs in State/)
00:28:51 <shachaf> I guess I heard Hugs has better Windows support.
00:29:10 <|Steve|> unknown command ':e'
00:29:10 <|Steve|> use :? for help.
00:29:11 <davidL> Cale: what does ShowQ do?
00:29:14 <shachaf> Though on the few cases I've used Haskell on Windows GHC seemed to work well.
00:29:19 <Cale> shachaf: The main problem I had with ghci under windows is that the windows console sucks.
00:29:38 <Cale> davidL: It contains an instance for showing quoted template haskell expressions.
00:29:44 <|Steve|> If you could recommend how to get it to work, I'd be quite happy.
00:29:44 <shachaf> Cale: Yes, it did use Windows's readline-ish thing.
00:29:58 <shachaf> Cale: Can't Cygwin or similar do it well, though?
00:30:21 <Cale> shachaf: Yeah, if you have cygwin, you can run an xterm.
00:30:25 <Cale> and bash
00:30:32 <shachaf> |Steve|: What version?
00:30:55 <|Steve|> 6.4.1
00:31:08 <shachaf> |Steve|: And locally?
00:31:13 <shachaf> |Steve|: 6.6?
00:31:19 <Cale> Last I checked, the default console didn't even have a scrollback buffer. I ended up using emacs for a "terminal emulator", which wasn't ideal, but it worked.
00:31:29 <|Steve|> 6.6.1
00:31:32 <shachaf> |Steve|: That might be the problem. :-)
00:31:56 <shachaf> Cale: I thought it did.
00:32:05 * shachaf isn't sure anymore.
00:32:19 <|Steve|> *sigh* I don't want to have to compile ghc on that computer again and I don't have privs to install to /usr. Suggestions?
00:32:31 <shachaf> I'll admit that under Windows, I use GUI versions of programs (e.g., gvim instead of console vim) more.
00:32:48 <shachaf> |Steve|: What's wrong with using a binary?
00:33:01 <|Steve|> Nothing, can I do so?
00:33:23 <|Steve|> Every rpm I've ever seen requires you to install it where it wants.
00:33:23 <Cale> shachaf: I can't recall what version of windows this was. Could have been 98.
00:33:37 <|Steve|> Then again, I don't use red hat unless I have no choice like in my office.
00:33:50 <shachaf> Cale: Ugh.
00:34:34 <shachaf> |Steve|: Don't use an RPM.
00:34:44 <shachaf> |Steve|: What's wrong with http://haskell.org/ghc/download_ghc_661.html ?
00:34:44 <Cale> > scanr (:) [] [1..5]
00:34:44 <lambdabot> Title: GHC: Download version 6.6.1
00:34:52 <lambdabot>  [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
00:35:01 <|Steve|> shachaf: No idea. I'll give it a shot.
00:35:23 <Cale> > concat . scanr (:) [] $ "echo"
00:35:24 <lambdabot>  "echochohoo"
00:36:02 <shachaf> > concat . tails $ "echo" -- ?
00:36:03 <lambdabot>  "echochohoo"
00:36:15 <Cale> yep
00:37:29 <Cale> > scanl (flip (:)) [] "echo"
00:37:30 <lambdabot>  ["","e","ce","hce","ohce"]
00:37:44 <davidL> Cale: did ShowFun fail for you as well?
00:38:27 <Cale> davidL: Possibly. I pared down RunPlugs considerably. You're probably intended to build and put those modules somewhere that it can get to them...
00:39:32 <davidL> where does it look for them? in $PATH?
00:39:43 <Cale> I'm not sure
00:39:50 <Cale> Probably not $PATH
00:40:04 <Cale> Does anyone know?
00:40:11 <Cale> Is dons around? He'd know.
00:40:57 <davidL> @seen dons
00:40:57 <lambdabot> dons is in #haskell-soc, #xmonad, #haskell and #ghc. I last heard dons speak 18m 54s ago.
00:42:41 <shachaf> GHCi says that it'll tell you if you use -v.
00:44:03 <davidL> hmm, I think I can just add those to lambdabot.cabal
00:44:32 <dons> davidL: ?
00:44:42 <dons> davidL: you're using the ./build script?
00:44:43 <dibblego> getting lambdabot to work is a friggin mission, good luck
00:44:54 <|Steve|> I got a bunch of errors installing it.
00:45:00 <davidL> dons: Setup.lhs build
00:45:03 <shachaf> dibblego: It was pretty easy for me.
00:45:08 <shachaf> davidL: Use ./build.
00:45:24 <shachaf> Why does nobody read the README?
00:45:39 <davidL> I read it a hundred times :(
00:45:53 <shachaf> davidL: What's wrong with ./build, then?
00:46:11 <|Steve|> Ah, you need -j1 with make. Someone should fix that.
00:46:13 <shachaf> davidL: (Fine, you DID read the README, sorry. :-) )
00:46:17 <quicksilver> Cale: Suppopse I have something a 'bit like' a monad, but bind doesn't have type m a -> (a -> m b) -> m b, but rather m a -> m(a -> b) -> m b
00:46:22 <quicksilver> Cale: is that in fact an arrow?
00:46:32 <shachaf> @ty  ap
00:46:33 <davidL> well it said "build with cabal" so I just assumed Setup.lhs build
00:46:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
00:46:46 <Cale> You have an applicative functor.
00:46:53 <shachaf> quicksilver: That's an applicative functor.
00:46:57 <quicksilver> ah
00:46:58 <quicksilver> thanks
00:47:01 <Cale> Not all applicative functors are monads, but many are.
00:47:11 <quicksilver> are some applicative functors arrows?
00:47:16 <dblhelix> morning #haskell!
00:47:21 <Cale> arrows have a whole different kind
00:47:44 <quicksilver> true, but I could write m a as m () a, or somethinig
00:47:45 <Cale> (they have two type parameters)
00:47:54 <quicksilver> and m (a -> b) as m a b
00:47:55 <dblhelix> quicksilver: but every monad can be wrapped in the kleisli arrow
00:48:22 <quicksilver> this particular example is where m means 'generate assembly code to calculate'
00:48:40 <quicksilver> it can't be a monad, because the assembly code to generate b can't depend on a. Only the value of b can depend on a
00:48:45 <quicksilver> if that makes sense
00:48:46 <Cale> Have you seen the x86 assembly generator?
00:48:57 <dolio> @type WrappedArrow
00:49:00 <lambdabot> Not in scope: data constructor `WrappedArrow'
00:49:03 <quicksilver> yes
00:49:12 <Cale> (Harpy)
00:49:13 <quicksilver> but it uses the 'return value' just to register addresses
00:49:17 <quicksilver> if I understood it right
00:49:22 <Cale> well, generally.
00:49:31 <quicksilver> I was imagining using the 'return value' to actually be the result of a computation
00:49:39 <Cale> hmmm...
00:49:56 <dolio> @kind Control.Applicative.WrappedArrow
00:49:58 <lambdabot> (* -> * -> *) -> * -> * -> *
00:50:03 <quicksilver> maybe I don't really mean m (a -> b)
00:50:16 <quicksilver> maybe that's embedding the haskell (->) in my DSL in a way I can't really do
00:50:21 <quicksilver> maybe I actually do mean m a b
00:50:48 <shachaf> quicksilver: The point of arrows is to abstract the (->). :-)
00:50:57 <Cale> WrappedArrow is a little dfferent from full arrows.
00:51:15 <Cale> It's like using the arrow to construct a "reader monad"
00:51:51 <Cale> The type of arrows from a fixed type b
00:51:56 <shachaf> @source Control.Applicative
00:51:56 <lambdabot> Control.Applicative not available
00:51:57 <quicksilver> shachaf: yeah
00:51:58 <dolio> Yeah.
00:52:03 <dons> davidL: you gotta use the ./build script now (with the darcs version)
00:52:06 <quicksilver> shachaf: so maybe it is an arrow that I mean
00:52:10 <dons> it builds the missing bits, like runplugs and so on
00:52:25 <mm_freak> what's the advantage of using arrows, anyway?
00:52:44 <Cale> mm_freak: Well, with a monad
00:53:01 <Cale> You have bind, and it takes a *function* as its right parameter
00:53:16 <Cale> Functions in Haskell are necessarily opaque
00:53:18 <dblhelix> dons: heh, I just saw that you and spj are to close the ball in Freiburg
00:53:24 <dblhelix> nice
00:53:35 <dons> to close the ball?
00:53:36 <Cale> That is, bind can't look at the representation of the future of the computation
00:53:44 <dons> oh, we have the last talks?
00:53:55 <dons> no, hmm, the hackathon?
00:53:56 <Cale> If it could, it might be able to do various kinds of optimisation to it
00:54:07 <Cale> and that's where the idea for arrows comes from
00:54:20 <mm_freak> ok
00:54:26 <dons> oh, they've put up the program
00:54:33 <dons> ah ha, we do close the ball
00:54:36 <dblhelix> http://www.informatik.uni-bonn.de/~ralf/schedule.html
00:54:37 <lambdabot> Title: ICFP 2007 Program
00:54:40 <Cale> Since your arrow is actually a datatype you have control over, you can include special forms which can be examined by (>>>) and optimised.
00:54:45 <mm_freak> for someone with almost no knowledge in category theory…  is there any gentle introduction into arrows?
00:54:48 <dons> interesting
00:55:22 <Cale> I don't know of an intro to arrows which *does* require category theory :)
00:55:28 <dblhelix> mm_freak: I think John Hughes' paper almost doesn't mention category theory
00:55:28 <Cale> http://haskell.org/arrows/
00:55:29 <lambdabot> Title: Arrows: A General Interface to Computation
00:55:32 <mm_freak> ok =)
00:55:42 <mm_freak> thanks
00:55:45 <Cale> that page, along with http://haskell.org/arrows/syntax.html
00:55:46 <lambdabot> Title: Arrow syntax
00:55:51 <Cale> There's almost nothing to arrows.
00:55:54 <dblhelix> dons: what are you working on now?
00:56:00 <Cale> It's the specific examples which get you.
00:56:09 <shachaf> Cale: Just like monads. :-)
00:56:18 <dons> finishing up my phd thesis, getting bytestring 1.0 released, starting a new job.
00:56:21 <Cale> So you'll want to look at, say, arrow-based parsing, or arrow-based XML transformation
00:56:32 <dons> i'd like to have a go at Data.ByteString.Parallel and stream fusion for Data.Array eventually
00:56:39 <Cale> Well, HXT is arrow-based, but only for the syntax :)
00:56:45 <dblhelix> dons: ah :-) when is your thesis due? what is your new job going to be?
00:56:52 <mm_freak> cale: so arrows are mainly special-purpose and only about optimization?
00:56:59 <collinge> mm_freak: have you looked at connor's idioms?
00:57:08 <dons> job : September | thesis : ~October :)
00:57:09 <Cale> mm_freak: Well, they characterise a wide class of combinator libraries
00:57:14 <mm_freak> collinge: nope
00:57:18 <mm_freak> let me read that intro first
00:57:33 <Cale> mm_freak: at the cost of having a weaker set of operations
00:57:40 <collinge> mm_freak: they're not the same as arrows
00:57:40 <dblhelix> dons: and your new job is going to be...?
00:57:50 <dons> oh, galois.com :) hacking haskell 
00:57:56 <collinge> mm_freak: but more accessible
00:57:57 <Cale> Idioms are the same thing as applicative functors.
00:58:11 <dblhelix> dons: great!
00:58:20 <shachaf> Is there a recommended general introduction to category theory (I'm sure that's been asked here many times before)?
00:58:21 <Cale> I don't think arrows are hard at all.
00:58:22 <collinge> and I was going to say more applicable
00:58:40 <mm_freak> shachaf: wikipedia is good at that
00:58:45 <dblhelix> dons: you didn't consider to stay in academia?
00:58:46 <Cale> It's just that the examples in research are rather hard. People use arrows for really complicated things :)
00:58:46 <mm_freak> there are links to easy papers
00:59:00 <Cale> But the idea is extremely simple.
00:59:08 <collinge> mm_freak: the best book I ever read was arbib & manes
00:59:26 <collinge> I think it's out of print now
00:59:29 <mm_freak> collinge: about category theory?
00:59:56 <ski> collinge : named ?
01:00:01 <collinge> mm_freak: yes hang on and I'll have a search for its name
01:00:04 <dons> dblhelix: maybe later, but galois is semi-academia anyway. still get to write papers
01:00:26 <dblhelix> dons: true. I think it's a very nice move
01:00:33 <quicksilver> shachaf: ah, it's not an arrow
01:00:36 * ski wonders why sometimes books are referred to solely by author name
01:00:38 <dons> hopefully. should be very exciting!
01:00:39 <quicksilver> shachaf: 'pure' doesn't make sense
01:00:50 <quicksilver> I don't think it's even an applicative functor, same reason
01:01:06 <quicksilver> bah
01:01:08 <shachaf> "Category theory applied to computation & control"?
01:01:14 <quicksilver> clearly I need to thinkg about it more
01:01:21 <ski> quicksilver : ?
01:01:21 <shachaf> quicksilver: What is it, again?
01:01:36 <dblhelix> dons: so you will be moving to oregon? that's a big step, isn't it?
01:01:52 <Cale> quicksilver: I think perhaps it's just a combinator library :)
01:02:03 <quicksilver> Cale: yeah ;)
01:02:08 <dons> dblhelix: yep, moving to Portland in September
01:02:10 <quicksilver> I'm looking for patterns which aren't there
01:02:16 <quicksilver> thanks all :)
01:02:19 <Cale> That is, no free control structures, but you can still write your own :)
01:02:32 <collinge> mm_freak: Arrows, structures, and functors : the categorical imperative
01:02:39 <quicksilver> shachaf: assembly language generation
01:03:02 <mm_freak> collinge: thanks
01:03:27 <mm_freak> but i'm also interested in category theory itself
01:03:45 <mm_freak> outside of its application in haskell
01:03:55 <therp> collinge: "categorical imperative" :) the reference to kant was intentional right? :)
01:03:58 <mm_freak> though it seems to be very difficult to teach category theory without examples
01:04:26 <quicksilver> well, it's very hard to make category theory interesting without examples
01:04:29 <quicksilver> quite possible to teach it
01:04:32 <shachaf> mm_freak: That book isn't about Haskell.
01:04:33 <quicksilver> but it's terribly dry, that what
01:04:40 <dblhelix> mm_freak: be careful :-) once you get lost in CT, you will never get out
01:04:48 <dblhelix> mm_freak: that is, it's quite addicting
01:04:53 <collinge> therp: yes the reference to Kant is intentional although I personally didn't understand the allusion
01:06:04 <dblhelix> I was in nottingham for MGS last spring, and neil ghani taught an excellent short CT class there... he made it all seem real easy and straigtforward
01:06:12 <mm_freak> quicksilver: i like it that way…  somehow i can't stand too fancy books, because i always get the feeling to have missed something
01:06:58 <mm_freak> dblhelix: yeah, i can imagine =)
01:07:18 <mm_freak> i love group theory, so i'm gonna love category theorie as well =)
01:07:52 <mm_freak> ie=y
01:07:55 <dblhelix> mm_freak: you'll never think about group theory again without generalizing to some class of categories
01:08:02 <dblhelix> :-)
01:08:07 <mm_freak> hehe
01:09:03 <ski> n-categories are interesting
01:10:09 <|Steve|> Even 2-categories are confusing.
01:10:21 <|Steve|> I'd hate to have to think about n-categories.
01:10:33 <mm_freak> is there anything available online?  i really would like to learn all that stuff
01:10:39 * ski has some loose ideas about thinking of morphisms in terms of side-effects
01:10:56 <mm_freak> category theory is often referred to as a theory for theories
01:11:39 <ski> mm_freak : if you haven't already found it, john baez' weekly finds in mathematical physics might be intersting .. also the n-category cafe
01:11:50 <Cale> I still think about group theory without generalisation quite often, though usually I'm doing something like applying group theory to something combinatorial, so generalising it would be distracting.
01:12:02 <therp> does anyone know what's the usual student registration fee for ICFP?
01:12:02 <dblhelix> not so long ago, my tongue slipped and I accidently said "category terrorists" instead of "category theorists"
01:12:23 <Cale> dblhelix: what a great Freudian slip!
01:12:28 <mm_freak> hehe
01:12:32 <|Steve|> heh
01:12:37 <dblhelix> Cale: so I thought
01:12:44 <mm_freak> ski: an introduction to category theory, not to n-categories
01:13:05 <ski> "Category theory is bunk" (Marshall Cohen)
01:13:35 <ski> mm_freak : oh .. well .. i'm not sure where i learned the basics, really
01:13:36 <|Steve|> It's abstract nonsense.
01:13:42 <ski> indeed
01:13:52 <dblhelix> Cale: I should write that down somewhere, perhaps I can confront someone with it, one day
01:14:49 <Cale> ski: wow, and he's a geometric topologist and combinatorial group theorist :)
01:14:59 <ski> Cale : who ?
01:15:09 <Cale> Marshall Cohen
01:15:10 <ski> oh
01:16:08 <mm_freak> i haven't heard of any other applications of CT other than haskell monads
01:16:24 <dblhelix> therp: don't now, registrations hasn't opened yet... but as I understood it, it is advisable to already look for accommodation as Freiburg can be crowdy in fall
01:16:25 <Cale> mm_freak: It's mostly applied to mathematics.
01:16:43 <Cale> mm_freak: It's a handy tool for figuring out what the right definitions ought to be.
01:16:44 <mm_freak> cale: i suspected so, but where?
01:16:55 <Cale> Algebraic topology and geometry
01:17:00 <mm_freak> k
01:17:03 <dblhelix> therp: will you also be attending the haskell workshop?
01:17:08 <collinge> mm_freak: applications include initial algebras, final co-algebras, folds, unfolds
01:17:34 <Cale> Well, and pure algebra, now that cohomology isn't strictly a topological notion
01:17:34 <therp> dblhelix: I have a good friend in basel, about ~50minutes
01:18:00 <Cale> Apart from that, it's influenced notation and structure throughout mathematics.
01:18:01 <sieni> doing homological algebra without category theory might turn out to be challenging
01:18:11 <dblhelix> therp: oh, that's great
01:18:26 <Cale> Everyone uses it to some extent in the baseline language of what they're talking about.
01:18:35 <dblhelix> we'll be going to freiburg with eight persons from utrect
01:18:37 <mm_freak> i always confuse freiburg and freiberg
01:18:38 <therp> dblhelix: maybe :) -- I haven't decided. as my accommodation is free anyway and I have to pay travel costs anyway and just once I'm inclined to attend the whole program
01:18:42 <mm_freak> freiburg is pretty near
01:18:47 <dblhelix> /s/utrect/utrecht
01:18:49 <Cale> Right down to the  f: X -> Y  notation. (Yes, that's only ~50 years old!)
01:18:53 <mm_freak> like ~30 km from here
01:19:06 <sieni> http://en.wikipedia.org/wiki/Abelian_category#History
01:19:09 <|Steve|> We were supposed to get to homological algebra in my last algebra class, but my prof disappeared for a month.
01:19:13 <dblhelix> for us, it's a six hour ride by train
01:20:09 <therp> for me it's about 10hr driving..
01:20:17 <Cale> sieni: heh, I think homology people would go nuts without any diagrams :)
01:21:48 <mm_freak> does it make computational difference to use point-free style?  i mostly prefer not to use it
01:21:56 <sieni> Cale: yeah :-)
01:22:10 <dblhelix> dons: will both duncan and you come to freiburg?
01:23:04 <dons> we will be there, yep.
01:23:12 <dons> we're helping organise the haskell hackathon!
01:23:26 <dons> http://haskell.org/haskellwiki/Hac_2007_II
01:23:27 <lambdabot> Title: Hac 2007 II - HaskellWiki
01:23:59 <dons> Can't miss out a chance to hack up some bytestringy code with Duncan.
01:24:24 <dblhelix> dons: :-( unfortunately, we'll be heading back to utrecht after cufp on thursday
01:24:24 <dons> ?babel de en sehr gute Kenntnisse in Haskell
01:24:25 <lambdabot>   very good knowledge in Haskell
01:24:36 <dons> dblhelix: oh, that's a pity!
01:24:50 <dons> we better announce the hackathon in the next few days then
01:24:53 <dons> since people are booking hotels
01:25:02 <dblhelix> dons: that'd be a good idea
01:25:19 <Cale> mm_freak: It's worth trying to get somewhat comfortable with it, as it's sometimes really the right way to think about things, but other than that, it doesn't matter.
01:25:42 <Cale> mm_freak: It comes from thinking of functions really as first class objects to be manipulated.
01:25:56 <dblhelix> dons: we'll be in freiburg Sep 26 already for we're attending IFL, so it's going to be a long week anyway
01:26:19 <dons> dblhelix: yeah! lots of things from IFL to CUFP 
01:26:31 <mm_freak> cale: sure…  there are cases where i like to use it, like my isqrt function from above
01:26:38 <Cale> mm_freak: For example, if I write:  uniq xs = map head (group (sort xs)), I'm expressing an idea in terms of a list which I'm successively manipulating.
01:27:11 <dblhelix> dons: I'll first go on vacation next week and then I'll start thinking about two talks to give in freiburg
01:27:13 <Cale> Whereas, if I write  uniq = map head . group . sort, the emphasis is on putting the functions together.
01:27:16 <mm_freak> cale: don't bother, i understand what you mean…  it's just that sometimes it would be overkill
01:27:46 <Cale> Well, you'll see @pl put out gibberish from time to time, and yes, sometimes a lambda is really a good thing.
01:28:34 <ski> the pointless notation corresponds more closely to the diagrams, also
01:28:38 <dblhelix> heh! what happened to haskell weekly news!?
01:28:49 <Cale> But it's worth getting more and more comfortable with things like the ((->) e) monad and so on anyway, since it really creates the right mindset for functional programming.
01:28:51 <dons> busy busy.
01:28:56 <dons> maybe i could do an issue now actually
01:28:57 <dons> hmm...
01:29:06 <dons> ok, make some hot chocolate, and fire up gmane.
01:29:11 <mm_freak> cale: i agree
01:30:10 <dblhelix> dons: you're forgiven
01:31:35 * dblhelix is going for a cup of coffee
01:46:23 <glguy> dons: don't worry about HWN yet... just finish up in .AU and head to Portland ! :-D
01:47:17 <pejo> dblhelix, that sounds very good. Hm. 
02:04:58 <ojacobson> Does lambdabot have a memo feature for leaving notes for other users?
02:05:14 <ojacobson> I'd like to thank wli for the code
02:05:18 <davidL> yeah
02:05:28 <davidL>  @tell foo thanks
02:06:28 <ojacobson> @tell wli Challenge.hs is brilliant and I think I understand it now.  Thank you.
02:06:28 <lambdabot> Consider it noted.
02:08:09 <Cale> > let mf 0 m = 1; mf n 0 = n; mf n m = mf (n-1) m * mf n (m-1) in mf 5 2
02:08:10 <lambdabot>  34560
02:08:14 <Cale> > let mf 0 m = 1; mf n 0 = n; mf n m = mf (n-1) m * mf n (m-1) in mf 5 3
02:08:16 <lambdabot>  238878720
02:08:32 <ojacobson> Cale: that looks familiar.  And evil.
02:09:04 <davidL> :( Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
02:09:05 <Cale> It's the mth level factorial, where the kth level factorial of n is the product of the (k-1)th level factorials of 1 up to n.
02:09:59 <Cale> It's also the number of n-tuples where the kth part is a function from the compositions of m-1 into n-k+1 parts to {1,...,k}
02:11:59 <mm_freak> > IO "test"
02:12:00 <lambdabot>   Not in scope: data constructor `IO'
02:12:19 <Cale> > putStrLn "test"
02:12:21 <lambdabot>  <IO ()>
02:12:22 <mm_freak> > return "test"
02:12:23 <lambdabot>   add an instance declaration for (Show (m [Char]))
02:12:39 <Cale> > getLine
02:12:40 <lambdabot>  <IO [Char]>
02:12:58 <mm_freak> return (1::Int)
02:13:02 <mm_freak> > return (1::Int)
02:13:03 <lambdabot>   add an instance declaration for (Show (m Int))
02:13:05 <Cale> > [getLine, return "Hello"]
02:13:06 <lambdabot>  [<IO [Char]>,<IO [Char]>]
02:13:13 <davidL> > unsafeEval_ "2+2"
02:13:14 <lambdabot>   Not in scope: `unsafeEval_'
02:13:25 <Cale> > return 1 :: [Int]
02:13:27 <lambdabot>  [1]
02:13:37 <Cale> > return 1 :: Maybe Int
02:13:38 <lambdabot>  Just 1
02:13:42 <Cale> > return 1 :: IO Int
02:13:43 <lambdabot>  <IO Int>
02:13:55 <davidL> > System.Eval.Haskell.unsafeEval_ "2+2"
02:13:55 <lambdabot>   Not in scope: `System.Eval.Haskell.unsafeEval_'
02:14:04 <mm_freak> > fail "blah" :: Maybe Int
02:14:05 <lambdabot>  Nothing
02:14:11 <mm_freak> > fail "blah" :: Failable Int
02:14:12 <lambdabot>   Not in scope: type constructor or class `Failable'
02:14:16 <mm_freak> oh
02:14:27 <mm_freak> is Either a monad?
02:14:31 <Cale> yeah
02:14:34 <glguy> not directly :)
02:14:41 <mm_freak> > return "blah" :: Either String
02:14:42 <lambdabot>      `Either String' is not applied to enough type arguments
02:14:42 <lambdabot>     Expected kin...
02:14:44 <mauke> > return 1 :: Either String Int
02:14:45 <lambdabot>  Right 1
02:14:47 <Cale> It ought to be defined as one in the Prelude, but it's not
02:14:48 <mm_freak> > return "blah" :: Either String String
02:14:49 <lambdabot>  Right "blah"
02:14:58 <mm_freak> > fail "blah" :: Either String String
02:15:00 <lambdabot>  Left "blah"
02:15:02 <glguy> Error e => Monad (Either e)
02:15:03 <mm_freak> ah k
02:15:15 <Cale> fail is an abomination
02:15:15 <glguy> where String is an instance of Error
02:15:24 <glguy> here we go again ;)
02:15:34 <Cale> It should be removed from the language, let's all hope for Haskell' :)
02:15:41 <glguy> Cale: that Haskell
02:15:47 <glguy> prime finishes?
02:15:50 <glguy> ;)
02:15:53 <glguy> or that it doesn't have fail
02:16:02 <Cale> that it doesn't have fail
02:16:02 <mm_freak> cale: why should it be removed?
02:16:12 <mm_freak> because it's redundant?
02:16:18 <Cale> mm_freak: Because it's in the monad class, and monads don't necessarily support failure.
02:16:23 <glguy> because its not part of what a Monad is
02:16:37 <Cale> So lots of monads have broken implementations of fail.
02:16:47 <Cale> Which just crash your program.
02:17:00 <mm_freak> yeah…  particularly the Either example makes no sense
02:17:01 <glguy> > runState (fail "oops") 3 :: Int
02:17:02 <lambdabot>  Couldn't match expected type `Int' against inferred type `(a, s)'
02:17:09 <glguy> > evalState (fail "oops") 3 :: Int
02:17:10 <lambdabot>  Exception: oops
02:17:12 <mm_freak> success is right and failure is left…  that's point-free
02:17:15 <Cale> Oh, that's one where the monad really *does* support failure.
02:17:35 <glguy> and that's why we have MonadPlus and had MonadZero
02:17:37 <mm_freak> yes it does…  but it doesn't make much sense
02:18:04 <Cale> mm_freak: Left throws an error, Right entails success
02:18:22 <Cale> It's the simplest possible implementation of exceptions :)
02:19:25 <mm_freak> cale: then i'd rather call it Failable
02:20:00 <Cale> It all depends on how you look at it.
02:20:47 <mm_freak> cale: Either should be used where the result can be of any of two types
02:20:47 <Cale> Left and Right certainly are useful mnemonics for sorting out which type parameters you're using, though they're not intuitive once the thing gets to the point of being used as a monad
02:20:51 <glguy> MonadLib provides a more generalized implementation of mtl's MonadError
02:21:05 <Cale> You just need to remember that a monad is always a type constructor of kind * -> *
02:21:17 <glguy> and a bind and return
02:21:17 <Cale> So the last parameter is always the type of "success"
02:21:34 <Cale> mm_freak: right, and here, that's what you have too :)
02:22:10 <mm_freak> cale: but a `failure' is not a `result'…  actually it is, but we call it an exception, because something went wrong =)
02:22:17 <Cale> The result can be Right x, where x is the type of thing you're probably really after, or Left e, where e is probably some sort of error
02:22:32 <Cale> But it might not really be an error.
02:22:52 <Cale> It could also just be something you managed to figure out early.
02:23:01 <glguy> then (at least in the sense of the mtl) it wouldn't be a monad :)
02:23:11 <glguy> s/sense/context
02:23:19 <Cale> Well, the mtl's instance is dumb.
02:24:17 <Cale> instance Monad (Either a) where { return x = Right x; e@(Left _) >>= f = e; Right x >>= f = f x }
02:24:32 <mauke> Cale: that shouldn't compile
02:24:39 <mauke> e has the wrong type
02:24:49 <Cale> Really?
02:24:59 <mauke> Left e >>= f = Left e
02:25:06 <mauke> I've been bitten by something like that before
02:25:07 <Cale> er, right, sorry
02:25:15 <Cale> yes, you definitely need to do that
02:25:28 <Cale> Those aren't the same Left e :)
02:25:55 <glguy> e@(Left _) >>= f = e   is not the same because?
02:26:16 * glguy would have written: Right x >>= f = f x ; e >>= _ = e
02:26:18 <mauke> because m a is not m b
02:26:30 <glguy> oh..
02:29:22 <glguy> if you are just using Either a  as a monad for early escaping with a result
02:29:27 <glguy> it would seem like Cont would be better suited
02:31:48 <glguy> ?djinn Either a b -> Either a c
02:31:52 <lambdabot> Cannot parse command
02:31:52 <lambdabot> -- f cannot be realized.
02:32:14 <mauke> ?djinn (b -> c) -> Either a b -> Either a c
02:32:14 <lambdabot> Cannot parse command
02:32:14 <lambdabot> f :: (b -> c) -> Either a b -> Either a c
02:32:14 <lambdabot> f a b =
02:32:14 <lambdabot>     case b of
02:32:14 <lambdabot>     Left c -> Left c
02:32:16 <lambdabot>     Right d -> Right (a d)
02:32:51 <glguy> Does ?djinn only produce total functions then?
02:32:59 <glguy> (I suppose that's the whole point)
02:33:00 <mauke> yes
02:33:09 <mauke> otherwise f = undefined
02:33:39 <alar> @more
02:33:56 <olsner> isn't Either a b -> Either a c basically the same as b -> c?
02:34:19 <glguy> its half id, half undefined
02:38:13 <mm_freak> does the OPTIONS_GHC pragma need to be at the beginning of the file?
02:38:31 <mauke> AFAIK yes
02:40:41 <mm_freak> ah, it doesn't, but it needs to precede any definitions
02:41:40 <davidL> what could explain why lambdabot throws "Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString" when ever I do '?run foo' ?
02:42:29 <olsner> @index Word64
02:42:30 <lambdabot> Data.Word, Foreign
02:43:22 <dons> davidL: old version of the regex libraries
02:43:45 <dons> you'll want regex-posix-0.92 and other regex-* libs of the latest flavour
02:44:23 <davidL> ah ok, I see those on hackage
02:44:25 <davidL> thanks dons
02:44:30 <mm_freak> dons: when using -fasm, it doesn't take the detour through C ?
02:46:31 <wli> dons: What's the "current code" bit on hpaste.org trying to do?
02:46:31 <lambdabot> wli: You have 1 new message. '/msg lambdabot @messages' to read it.
02:47:42 <dons> mm_freak: right, just uses ghc's native code generator
02:48:01 <dons> wli, oh, that's mm_freak's program from earlier today
02:48:19 <dons> factorisation
02:48:47 <wli> dons: That comes in handy for finding the group of units mod n.
02:49:16 <mm_freak> dons: genp?
02:49:39 <olsner> what's the best way to deal with same-named fields in different data types?
02:49:57 <wli> olsner: Presumably records?
02:50:11 <olsner> I have e.g. data Foo = Foo { name :: String } for Foo in {Foo, Bar, Baz}
02:50:21 <olsner> so end up with three definitions of name
02:50:25 <mauke> prefixes or modules
02:50:31 <wli> olsner: I think they're not possible to define in the same module and module qualifiers.
02:50:38 <wli> olsner: handle it rather
02:52:00 <olsner> I guess it'll work with fooName, barName, bazName etc... did play around with a HasName class though - it seems to work, but I wonder if I'm setting up for future problems with that approach
02:53:32 <wli> It wasn't, but anyway.
02:53:43 <DRMacIver> Hm. Looks like I won't be able to make it to anglohaskell.
02:53:53 <wli> I seem to have gotten a grip on dynamic programming.
02:54:37 <wli> What other sorts of monadic shenanigans should I investigate here? Hmm.
02:55:57 <|Steve|> Hmm, I couldn't even imagine trying to do dynamic programming in haskell.
02:56:59 <olsner> @hoogle String -> Maybe Int
02:57:02 <lambdabot> No matches, try a more general search
02:57:11 <olsner> @hoogle String -> Maybe a
02:57:11 <lambdabot> No matches, try a more general search
02:57:19 <wli> |Steve|: http://holomorphy.com/~wli/Bernoulli.hs
02:57:35 <DRMacIver> |Steve|: The impression I get is that Haskell is quite good for certain classes of dynamic programming.
02:58:28 <wli> It's not quite the Pontrjagin Principle at work here.
02:58:57 <|Steve|> wli: This is way over my head.
02:59:20 <wli> |Steve|: Sans monads, I have another example: http://hpaste.org/1652
03:00:10 <wli> |Steve|: Search the Haskell wiki for details on Happy Numbers.
03:00:38 <|Steve|> Oh, I think I see. You're using Maybe to see if it's been filled in yet.
03:01:05 <wli> |Steve|: The lookup function on maps returns Maybe already.
03:01:24 <|Steve|> Oh.
03:01:38 <mm_freak> > fromJust Nothing
03:01:39 <wli> |Steve|: In the Happy module, the Maybe is used to encode a result that can either be "unhappy" or "happy of order n."
03:01:42 <lambdabot>  Exception: Maybe.fromJust: Nothing
03:01:58 <mm_freak> fromNothing (Just 3)
03:02:01 <mm_freak> > fromNothing (Just 3)
03:02:02 <lambdabot>   Not in scope: `fromNothing'
03:02:27 <wli> |Steve|: We can do a lookup in the table and get Nothing or Just Nothing.
03:03:16 <Lemmih> mm_freak: I think God patented that function.
03:03:27 <wli> |Steve|: Nothing returned from lookup means there was no table entry. Just Nothing returned from lookup means there was a Nothing in the table, which means we know that the number is unhappy.
03:03:37 <|Steve|> I see.
03:03:49 <wli> Nothing == we know nothing
03:03:58 <wli> Just Nothing == we know the number is not a happy number
03:04:14 <mm_freak> lemmih: probably
03:04:20 <wli> Just (Just n) == we know the number is happy and it is in fact happy of order n
03:04:38 <olsner> > let fromNothing Nothing = undefined in fromNothing (Just 3)
03:04:40 <lambdabot>   Non-exhaustive patterns in function fromNothing
03:05:08 <|Steve|> Most DP algorithms I've seen are quadratic (since there are typically n^2 entries in the table to fill in, I've seen and done worse, n^4, etc). But you're having to do a map look up as well.
03:05:37 <|Steve|> Doesn't that give you something more like n^2 log n for such an algorithm?
03:05:47 <mm_freak> > let bottom = top; top = bottom in bottom
03:05:48 <lambdabot>  Exception: <<loop>>
03:06:06 <mm_freak> oh…  GHC 6.4 didn't detect that
03:06:10 <wli> |Steve|: Yes. I don't really care much about a factor of log(n), though I could eliminate it with address calculation-based methods.
03:06:35 <wli> |Steve|: Those would be as simple as using a radix tree, for instance.
03:07:13 <mm_freak> > let test 0 = 0; test n = test $! (n+1) in test 1
03:07:17 <lambdabot> Terminated
03:07:22 <mm_freak> k
03:07:50 <wli> |Steve|: Would you like me to write you a radix tree structure?
03:08:00 <|Steve|> That's alright. =)
03:08:40 <wli> |Steve|: The big issue has to do with the arbitrary-precision arithmetic. I'm expecting ginormous numbers.
03:09:24 <wli> |Steve|: It can generally be cut down with hash trie -related methods while still retaining address calculation -based asymptotics.
03:09:44 <|Steve|> It looked like you were doing more memoization than DP anyway.
03:10:27 <wli> |Steve|: GRRR, I guess I have to go look up the distinction (if there is one) now.
03:10:38 <|Steve|> Heh, there's isn't much of one.
03:11:12 <|Steve|> DP you typically fill out the whole table to get to the result you want. Memoization, you store (or memoize) the results of intermediate calculations to prevent doing them again.
03:12:06 <DRMacIver> So memoisation is lazy dynamic programming? :)
03:12:14 <|Steve|> In a sense.
03:12:23 <wli> DRMacIver: No, dynamic programming is broader.
03:14:08 <wli> DRMacIver: Well, in some senses, more specific.
03:14:32 * pjd attempts analogy: dynamic programming is like moonwalking
03:14:37 <wli> DRMacIver: It's related to optimization (the Pontrjagin sort of dynamic programming) in a very vague way by the "optimal substructure."
03:14:57 <|Steve|> Ugh. Totally worthless: DEBUG: No need to upgrade! ghc 6.6_3 >= ghc 6.6.1_0.
03:15:52 <wli> DRMacIver: When nothing is being optimized, such as in the case of just calculating something and memoizing, there's no "programming" (in the sense of "planning" as it's used in the optimization nomenclature) being done.
03:17:10 <wli> So the Bernoulli numbers and happy numbers have 2/3 components: overlapping subproblems and memoization. They lack optimal substructure because there's no optimization being done.
03:18:32 <mm_freak> why does GHC default to -fvia-C with -O, when -fasm is actually faster?
03:19:44 <|Steve|> ghc can produce better assembly than c compilers which have been doing it for 4 decades now?
03:20:06 <hpaste>  dolio pasted "parser inversion" at http://hpaste.org/1674
03:20:49 <mm_freak> |steve|: at least for my wheel factorization it's faster
03:20:55 <wli> ooh http://www.cs.uvic.ca/~nigelh/Publications/PracticalEarleyParsing.pdf
03:20:57 <lambdabot> http://tinyurl.com/3x36lp
03:21:43 <|Steve|> mm_freak: That's pretty impressive of ghc.
03:21:58 <wli> I don't suppose we need Earley parsers because things like Parsec et al are actually more powerful.
03:22:18 <mm_freak> yeah…  and surprisingly the binary is _much_ smaller
03:22:51 <mm_freak> oh well, that's not because of -fasm, it's because of GHC 6.6.1
03:22:57 <wli> So one shouldn't use -O or -O2 or otherwise if one does use them they should be combined with -fasm?
03:23:05 <mm_freak> i've been using GHC 6.4 before, which produced pretty large binaries
03:23:45 <mm_freak> wli: without -O, the code is much slower, but with -O or -O2 and -fasm it's faster than with -O or -O2 alone
03:24:00 <dons> wli, hmm, I always use -O2 -fasm these days
03:24:16 <|Steve|> What architectures does ghc support natively?
03:24:18 <wli> So noted.
03:24:25 <dons> x86, powerpc, sparc, amd64
03:24:29 <dons> sparc is a bit bitrotted, iirc
03:24:38 <dons> all the others are supported -fvia-C
03:24:40 <|Steve|> That's pretty impressive.
03:29:40 <mm_freak> dons: you were right…  the integer sqrt is faster
03:30:22 <mm_freak> probably turning this into a parameterized list may boost performance even further…  let me try
03:31:35 <dons> ah good. 
03:31:41 <dons> yes, i found a small speedup
03:34:37 <ejt> I'm writing a program that generates C code as output.  I was wondering if anyone knows of other haskell apps/libraries that do this sort of thing ?
03:34:48 <wli> ejt: ghc
03:35:02 <wli> I think there are libraries for this sort of thing.
03:35:21 <ejt> k
03:36:04 <|Steve|> Ugh, darwinports shouldn't get the bootstrap if ghc already exists on the system.
03:36:49 <dons> ejt, c2hs has a parser and internal type for gcc C
03:36:49 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
03:37:04 <mm_freak> dons: we could also just omit sqrt and search for prime factors up to 2^(lg n / 2)
03:37:17 <dons> ejt, and i was involved in a project recently doing high performance stuff this way, http://www.cse.unsw.edu.au/~dons/papers/SCKCB07.html
03:37:17 <lambdabot> Title: Generative Code Specialisation for High-Performance Monte-Carlo Simulations
03:37:36 <dons> ejt: might have some useful references. we just used an simple combinators set for generating C
03:37:52 <ejt> dons: that sounds exactly like what I've started writing :)
03:37:55 <ejt> will read paper, thx
03:37:56 <dons> ejt, on a related note is harpy, the x86 asm generator
03:38:05 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/harpy-0.2
03:38:08 <lambdabot> http://tinyurl.com/ynrb8k
03:38:09 <ejt> y, Harpy looks a lot of fun
03:38:17 <dons> (for generating and disassembling x86 directly in haskell)
03:38:18 <ejt> I'm not concerned with performance ATM
03:38:32 <dons> ok. so really you want something like a C pretty printer?
03:38:36 <ejt> I'm generating unit tests for C libraries
03:38:40 <dons> ah ok
03:38:50 <dons> oh, like the 'CUT' program
03:38:56 <wli> ejt: http://cvs.haskell.org/trac/ghc/wiki/Commentary/Compiler/CmmType
03:38:59 <lambdabot> Title: Commentary/Compiler/CmmType - GHC - Trac
03:39:03 <dons> that was a haskell project by another person here, that generated unit tests for C
03:39:13 <dons> used bytestrings for parsing, and its own pretty printer
03:39:18 <ejt> I want to generate test programs in a quickcheck style, then use combinators to turn them from Haskell data objects into C code
03:39:25 <dons> that would be really cool
03:39:27 <ejt> excellent
03:39:45 <wli> ejt: There's a wiki page on using ghc as a library.
03:39:55 <dons> yeah, a data type to represent the bits of C you need, then a pretty printer module to spit out real C
03:39:56 <wli> ejt: http://haskell.org/haskellwiki/GHC/As_a_library
03:39:57 <lambdabot> Title: GHC/As a library - HaskellWiki
03:40:08 <dons> wli, i'm not sure if ghc-as-alibrary is relevant here, is it?
03:40:24 <dons> oh, i suppose you could generate C--, and use ghc's pretty printer
03:40:28 <ejt> ok, I'm going to go away and read for the rest of the day ... thanks for the excellent pointers
03:40:41 <dons> sounds like a good project, ejt 
03:40:42 <wli> dons: I'm not sure. I was mostly chasing down the references vs. smoking out exactly what he wanted.
03:41:17 <dons> oh, there's C-all-in-one
03:41:31 <dons> a project from a couple of years ago which takes a bunch of C modules, and squooshes them into a single module
03:41:34 <dons> written in haskell
03:41:35 <dons> let me find that.
03:42:06 <ClaudiusMaximus> huh, ' isn't a valid character in module names..
03:42:37 <dons> http://www.cs.utah.edu/flux/knit/cmi.html
03:42:41 <lambdabot> Title: Alchemy: CMI
03:43:08 <dons> ejt, that might be quite relevant, a parser and pretty printer frontend for gcc
03:43:10 <dons> in haskell.
03:43:15 <dons> they use it for cross module inlining
03:44:19 <Syzygy-> Gah! Now I get sorely tempted to go to Anglohaskell!
03:44:53 <Syzygy-> But I don't know whether I'll get the trip funded, and my fiancee will kill me for leaving again three days after I get back.
03:46:03 <ClaudiusMaximus> is _ allowed in module names?
03:46:21 <ClaudiusMaximus> @where report
03:46:21 <lambdabot> http://www.haskell.org/onlinereport/
03:47:10 <jix> @pl (\a -> zip a $ sumUp a)
03:47:10 <lambdabot> ap zip sumUp
03:49:14 <|Steve|> @src ap
03:49:14 <lambdabot> ap = liftM2 id
03:49:22 <DRMacIver> @src sumUp
03:49:22 <lambdabot> Source not found. Wrong!  You cheating scum!
03:49:28 <jix> that's a function i wrote
03:49:32 <DRMacIver> Ah
03:49:34 <|Steve|> @src liftM2
03:49:34 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
03:49:40 <DRMacIver> How does it differ from sum?
03:49:56 <jix> sumUp = scanl1 (+)
03:50:06 <DRMacIver> Ah
03:50:20 <DRMacIver> Oh, of course. I should have read the code. :)
03:50:45 <wli> Would interruption be well-modelled by continuation monads?
03:51:00 <ClaudiusMaximus> hmm, section 2.4 of the report says ' is allowed in module names, but ghci doesn't like it...     conid  ->  large {small | large | digit | ' }
03:51:04 <|Steve|> @src id
03:51:04 <lambdabot> id x = x
03:51:25 <|Steve|> How does liftM2 id work then?
03:51:28 <jix> but somehow ap zip sumUp isn't (\a -> zip a $ sumUp a)
03:52:41 <|Steve|> Oh, it's returning x1 and then calling that with argument x2? But why doesn't it complain about the number of arguments?
03:53:01 <|Steve|> > id negate 5
03:53:03 <lambdabot>  -5
03:53:05 <wli> e.g. catching signals?
03:54:18 <jix> @pl \a -> zip a $ sumUp a
03:54:18 <lambdabot> ap zip sumUp
03:54:36 <DRMacIver> ClaudiusMaximus: It's not allowed at the beginning of names.
03:54:45 <DRMacIver> I think.
03:55:01 <DRMacIver> (I ran into this problem myself the other day)
03:55:17 <DRMacIver> Or similar
03:55:54 <alar> @seen adept
03:55:54 <lambdabot> I saw adept leaving #oasis 1d 13h 41m 53s ago, and .
03:56:03 <ClaudiusMaximus> DRMacIver: yeah, but is allowed at the end, if i'm reading the report correctly
03:56:18 <alar> what does mean ", and ." in lambdabot's answer? :)
03:57:15 <DRMacIver> > foldl' (+) 0 [1 , 2, 3]
03:57:17 <lambdabot>  6
03:58:07 <DRMacIver> ClaudiusMaximus: I presume it's the single ' it's objecting to.
03:59:36 <araujo> morning
04:03:11 <jix> @src minimum
04:03:11 <lambdabot> minimum [] = undefined
04:03:12 <lambdabot> minimum xs = foldl1 min xs
04:06:13 * wli dredges up code he wrote 6 years or so ago he can't figure out anymore.
04:06:57 <wli> http://holomorphy.com/~wli/GInterp.hs
04:08:56 <wli> From back when I was actively reading SPJ's old book.
04:09:59 <dons> [weird stuff] The Dodgy Diagonal -- scary
04:11:34 <fasta> What is the space-usage of using the snoc operation on difference lists?
04:12:20 <wli> dons: What's the Dodgy Diagonal?
04:12:43 <fasta> Or rather: is explicitly reversing a list instead of using snoc more efficient?
04:13:10 <dons> a scary post by conor mcbride on the mailing list :)
04:13:25 <dons> fasta: its O(1) on difference lists, iirc
04:13:33 <dons> the docs should say?
04:13:45 <dons> -- | /O(1)/, Append a single element at a difference list
04:13:45 <dons> infixl `snoc`
04:13:45 <dons> snoc        :: DList a -> a -> DList a
04:13:45 <dons> snoc xs x   = DL (unDL xs . (x:))
04:13:47 <dons> ?
04:14:14 <fasta> dons: but isn't a gigantic closure being build?
04:14:33 <fasta> dons: if I snoc a million elements, don't I get massive overhead?
04:16:50 <dons> quite possibly
04:16:52 <dons> as for lists
04:17:00 <dons> just that append and snoc won't copy the spine
04:17:18 <dons> until you demand the lot -- so you can get good speed ups in (++) and (:) heavy apps
04:17:23 <dons> they're quite a fun little structure
04:17:33 <fasta> dons: the spine are the boxes, right?
04:17:36 <dons> if you're doing this for strings, lazy bytestrings might be nicer
04:17:41 <dons> fasta, yeah
04:17:57 <dons> ?src (++)
04:17:57 <lambdabot> (++) []     ys = ys
04:17:58 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
04:18:00 <fasta> dons: I am now representing a sequence like structure in reverse
04:18:18 <dons> you've looked at finger trees?
04:18:20 <dons> Data.Sequence?
04:18:24 <fasta> dons: so, that should be fairly efficient (more efficient than Data.Sequence, I'd expect)
04:18:43 <dons> for snoc, i think so. O(1) v O(log n) (?)
04:18:50 <fasta> dons: no
04:18:52 <dons> best way to find out would be to do some benchmarks
04:18:59 <fasta> dons: it's both O(1)
04:19:18 <fasta> dons: inserting at any finger is O(1) in a finger tree. 
04:19:27 <dons> yes, right.
04:19:32 <dons> at either end its O(1)
04:19:33 <fasta> dons: you can only have a constant number of fingers, though.
04:19:56 <dons> anyway, should be cheap enough to try both, and see which one wins?
04:20:13 <dons> i'm really not sure which will be best. 
04:20:20 <fasta> Cheaper profiling would be nice too.
04:20:28 <Lemmih> Hi, my name is Lemmih and I'm an element addict. I starting snoc'ing back in '98. Soon I was snoc'ing about a million elements a day and the overhead was really killing my social life.
04:20:35 <dons> :)
04:20:38 <dons> hehe
04:20:45 * Lemmih sits down.
04:20:45 <dons> a snoc head, eh.
04:20:47 <dons> very sad
04:20:52 <dons> but we're here to support you, Lemmih!
04:21:00 <dons> step 1: put down that cons node!
04:25:36 <fasta> dons: uhm, what is a good way to compare them? Putting stuff in and printing the values might be slow, since it's limited by terminal speed. 
04:26:52 <fasta> dons: using let !_ = <expression> is not enough to force it, AFAIK.
04:29:19 * pesco sings "These closures! Filling my mind. When will I finally get to unwind?!"
04:29:40 * wli tries to think of some pedagogical task he can do to round out his monad-fu.
04:29:41 <dons> fasta, take the length?
04:29:47 <dons> i'd build them, print the length, time that
04:30:04 <fasta> dons: Doesn't Data.Sequence have a length field?
04:30:50 <fasta> dons: length is O(1)
04:31:03 <fasta> dons: for Data.Sequence(but maybe it's amortized)
04:31:28 <fasta> dons: right, probably it's amortized. 
04:32:08 <dons> you can certainly come up with a way to traverse all the elements though
04:32:36 <dons> also, http://haskell.org/haskellwiki/Timing_computations
04:32:37 <lambdabot> Title: Timing computations - HaskellWiki
04:33:14 <fasta> dons: but how does that interact with lazy IO? 
04:33:27 <fasta> dons: suppose I read a file before start <- getCPUTime
04:33:36 <fasta> dons: where will that time be used?
04:33:54 <fasta> dons: in an imperative language the full file will be read into memory first.
04:35:45 <LeCamarade> :t read
04:35:47 <lambdabot> forall a. (Read a) => String -> a
04:36:11 <LeCamarade> Oh.
04:36:23 <LeCamarade> Wrong term.
04:37:30 <dons> you've got to evaluate it strictly , yep
04:37:44 <dons> so using whatever traversal will force evaluation of the data type you're computing
04:38:19 <fasta> dons: but how can I "traverse" it without printing it? 
04:38:30 <fasta> dons: using "seq" is still too vague
04:38:31 * wli briefly tries to figure out Data.Progress.Meter
04:39:10 <dons> so, fasta, for input lists, you use seq $ length x to force it
04:39:20 <dons> for other types there are similar *deep* seq
04:39:34 <dons> i use a class, Forceable, in benchmarking for this stuff
04:39:43 <dons> also, you need to do strict IO, as you point out
04:39:49 <dons> which means forcing the input list before you start timing
04:39:52 <dons> http://code.haskell.org/utf8-string/tests/Bench.hs
04:39:56 <dons> is my usual benchmark script
04:40:08 <dons> instance Forceable [a] where
04:40:08 <dons>     force v = length v `seq` return T
04:40:18 <dons> main = do
04:40:19 <dons>     force (fps,chars,strs)
04:40:29 <dons> to tell the driver how to evaluate each type fully
04:40:40 <dons> and the 'force' on startup to get strict io on the input data
04:49:48 <fasta> dons: I believe we have a winner. 
04:50:00 <fasta> dons: lists are 14(!) times faster
04:50:05 <dons> dlists ?
04:50:12 <fasta> dons: no, normal lists. 
04:50:14 <dons> or reversed lists?
04:50:16 <fasta> dons: with reversing. 
04:50:19 <dons> very interesting!
04:50:34 <dons> compared with?
04:50:46 <fasta> I wrote tail-recursive code for both. 
04:50:53 <fasta> Data.Sequence and []
04:51:01 <dons> ok. so you didn't use Data.DList ?
04:51:15 <fasta> no
04:51:21 <dons> that's interesting though. hmm.
04:51:31 <dons> so you cons , then reverse at the end?
04:51:31 <fasta> I can do that too, but DList is not in base yet, right?
04:51:42 <dons> right, its in the dlist package on hackage
04:51:44 <fasta> Do we have a wiki page for this stuff?
04:51:46 <dons> ?hackage dlist
04:51:46 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist
04:51:55 <fasta> dons: I wrote my own version too, once. 
04:52:13 <dons> yeah, there's a couple. i'm trying to ensure the above is at least semi complete
04:52:42 <fasta> dons: do we have a wiki page for performance numbers?
04:53:03 <dons> there's a general performance tree of pages
04:53:09 <dons> with some for specific structures
04:53:12 <dons> ?wiki Performance
04:53:12 <lambdabot> http://www.haskell.org/haskellwiki/Performance
04:54:35 <fasta> dons: do you happen to remember how the Haskell wiki account mail looks like?
04:54:49 <fasta> dons: I cannot find it now
04:55:57 <fasta> dons: never mind
05:03:40 <fasta> dons: would it be possible to transform a program using Data.Sequence with only appends to the ends to automatically transform to using lists with RULES?  I know it's possible todo with other program transformation tools. 
05:03:54 <fasta> er to do
05:07:51 <wli> It looks like Knuth-Bendix is the way to approach generalized simplification rules.
05:08:33 <dons> yes, that would be possible.
05:09:35 <fasta> wli: but that algorithm doesn't get around non-confluent rules. 
05:10:02 <fasta> wli: at least not from a quick skim.
05:11:11 <matt__r> parsec is my new religion
05:11:22 <wli> fasta: Well, the thought was how to generalize the simplification rules for multivariate rational expressions.
05:11:24 <dons> you can write diverging rules, yep
05:11:58 <wli> Well, Knuth-Bendix takes as it inputs generators and relations.
05:12:25 <fasta> wli: what is a "rational expression"?
05:13:40 <wli> fasta: Addition, multiplication, division, raising to integer powers, forming linear combinations with integer coefficients.
05:14:04 <fasta> wli: oh, that. Oh, right.
05:15:42 <Philippa_> matt__r: I think that makes me your messiah or something :-)
05:16:11 <wli> fasta: Basically, the carriers are the types Rational, Integer, String, and there are function symbols (+), (*), (/), (^), constant symbols 0 and 1, and so on.
05:16:34 <matt__r> Philippa_: works for me :)
05:16:36 <wli> fasta: String being used for variablenames.
05:18:36 <|Steve|> If I have a list and I want to pass each of them to an IO action, is there a better way to do it than mapM? For example do mapM (putStrLn . show) [1..5]
05:18:56 <mauke> yes, mapM_
05:18:57 <|Steve|> That does the printing as expected but also returns a list of 5 ().
05:19:04 <mauke> also, putStrLn . show == print
05:19:20 <mauke> :t mapM_ print [1..5]
05:19:32 <lambdabot> IO ()
05:19:51 <|Steve|> Excellent, thank you.
05:20:34 <|Steve|> I'm reading through http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf and was doing exercise 3.10.
05:22:04 <mauke> :t sum
05:22:06 <lambdabot> forall a. (Num a) => [a] -> a
05:22:08 <mauke> :t product
05:22:10 <lambdabot> forall a. (Num a) => [a] -> a
05:23:15 <|Steve|> I think I have a decent grasp on functional programming, but haskell IO and monads in general have always eluded me. I figured I should learn.
05:24:03 <mauke> oh, you just need the right mental model :-)
05:24:22 <ejt> |Steve|: just write lots of trivial little IO programs, it'll suddenly get very easy
05:24:42 <mauke> haskell can't do any I/O because it's pure, so what it does instead is build a data structure that describes the I/O it wants to do
05:24:56 <|Steve|> I've only ever used haskell to do computation intensive things with little or no explicit io.
05:24:57 <int-e> |Steve|: well IO is not a nice example of a monad anyway. I'd start with the Maybe and List monads, and then maybe the Reader one, if you want to get a grasp on monads.
05:25:27 <mauke> (if you just want to understand IO, you can ignore monads for now)
05:25:33 <|Steve|> mauke: Part of what has always put me off is that haskell can't do I/O and yet, of course, it can.
05:25:44 <DRMacIver> I have no concrete evidence for this, but I conjecture that people who have repeatedly abused unix pipes probably grasp Haskell's IO system rather more easily than others. :)
05:26:05 <|Steve|> Heh, then I should pick it up in no time. I've just never really tried.
05:26:25 <mauke> |Steve|: well, you have a pure program that constructs/returns imperative code to be executed later :-)
05:26:27 <DRMacIver> Particularly the sort of IO you can do with lots of uses of 'interact' type methods. :)
05:26:28 <int-e> |Steve|: IO is really outside of the picture. Think of main as a function that returns a description of IO actions to make; the run time system will execute that then.
05:27:16 <dons> DRMacIver: apparently Doug McIlroy himself is a haskell fan these days, http://www.cs.dartmouth.edu/~doug/
05:27:17 <lambdabot> Title: Doug McIlroy
05:27:31 <mauke> next step: the >> operator
05:27:33 <dons> i wonder if he likes the io system
05:28:02 <roconnor> ?who Doug McIlroy
05:28:03 <lambdabot> Maybe you meant: echo ghc show thx what wn
05:28:10 <mauke> if you have two IO "actions" (= descriptions of how to do some IO), you can combine them into one big action by doing one first and then the second
05:28:16 <roconnor> ah there is only what and where
05:28:22 <mauke> and that's what >> does
05:28:22 <DRMacIver> dons: Cool.
05:28:23 <int-e> |Steve|: (it makes no real difference that in actual implementations like ghc a lot of the IO stuff is written in Haskell; the details are still tightly coupled with the RTS)
05:28:26 <dons> guy who wrote diff, sort, tr et al (and other unix pipes stuff)
05:28:50 <dons> functional programming at the heart of unix
05:28:54 <v0|d> are there any real-time haskell programs?
05:28:59 <DRMacIver> Note that I'm not soneone who has repeatedly abused unix pipes. I've only used them a bit, but I've noticed a very strong similarity between how I use them and how one does lazy IO.
05:29:29 <DRMacIver> I suspect this is why the "Rewrite your favourite unix utils in Haskell" tasks are so popular. :)
05:29:39 <dons> indeed!
05:29:43 <dons> and they form a monad (or two)
05:29:44 <|Steve|> DRMacIver: One of my new favorite things to do is: curl http://foo.com/bar.tar.gz | tar zxf -
05:29:55 <dons> that's cute |Steve| 
05:29:55 <LeCamarade> I introduced some people to the IO monad with the Unix shell.
05:29:59 <DRMacIver> |Steve|: Oh, neat. I'll remember that one.
05:30:04 <dons> i do tar czf - dons | ssh habanero-s "cat > backup/backup.tar.gz" 
05:30:18 <dons> which is rather nice for backing up things
05:30:22 <LeCamarade> And also, the unix tools that take from stdin when the file arg is not provided do something similar to currying.
05:30:34 <|Steve|> That's a good one.
05:30:37 <LeCamarade> Or Shernfinkelisaztion.
05:30:46 <wli> int-e: ooh
05:30:54 <dons> LeCamarade: indeed. partial application is how you do that in haskell, 
05:30:56 <dons> see h4sh
05:30:58 <dons> ?where h4sh
05:30:58 <lambdabot> http://www.cse.unsw.edu.au/~dons/h4sh.html
05:31:01 <mauke> return = echo
05:31:03 <dons> i should release a new version of that
05:31:15 <LeCamarade> dons: Yeah. :o)
05:31:21 <Heffalump> dons: I used to do that, but I find rsync much nicer these days
05:31:25 <wli> int-e: what's a good manageable-sized programming "assignment" for someone like me to learn monads?
05:31:27 <dieJana> wonder if I should interrupt or not; anyway did it already, so - any material you recommend as very good for someone who wants to start from scratch with haskell?
05:31:33 <DRMacIver> dons: That's really cool. :)
05:32:07 <|Steve|> dieJana: This document I'm reading seems pretty good.
05:32:29 <dons> dieJana: lots of good things on haskell.org
05:32:37 <dons> `yaht' and the haskell wikibook are recommended
05:32:38 <dieJana> which on is it, |Steve|?
05:32:39 <dons> ?where yaht
05:32:39 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
05:32:40 <|Steve|> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
05:32:52 * LeCamarade finds running Haskell CGI binaries may be cheaper than mod_php! :-o
05:33:04 <dons> LeCamarade: cheaper in what way?
05:33:07 <dieJana> ok, dons, |Steve|, thanks alot
05:33:09 <dons> less resource heavy?
05:33:23 <LeCamarade> dons: Resources, speed.
05:33:48 <dons> that's not terribly surprising :)
05:33:59 <dons> but good to know
05:34:02 <LeCamarade> Better startup for the binary, it seems. Cheap forks. All cheaper than recompiling ... I didn't expect it, frankly. I didn't.
05:34:17 <LeCamarade> By my benchmark is too raw - don't quote me.
05:34:21 <dons> optimised native code is good
05:34:43 <dons> the happs server out performs apache under load, last time it was tested
05:34:52 <LeCamarade> I think the price of fork(3) has gone down a lot, such that CGIs are not really bad anymore.
05:34:56 <dons> and I think HWS also was rather good 1000/requests sec
05:35:25 <|Steve|> fork() never be expensive on unix. It's the only way to get a new process.
05:35:34 <LeCamarade> I'm thinking of canibalising HAppS and using it to specialise my web site.
05:35:39 <dons> LeCamarade: so its an optimised ghc-compiled cgi program?
05:35:53 <LeCamarade> dons: Yes. -O
05:36:13 <int-e> wli: that's a tough question. the differences between the various monads are more important than what they have in common. but what they have in common makes them monads: the ability to arrange the monad actions in a sequence. So hmm. For the list monad, I'd suggest a simple backtracking search, say, solve Tic Tac Toe. Maybe (modeling computations that may fail) and reader (passing around immutable, common state) are almost trivial. Maybe the st
05:37:07 <wli> int-e: The line got cut off at "immutable, common state) are almost trivial. Maybe the st"
05:37:09 <int-e> Hmm not sure whether that got cut off. ... Maybe the state monad is more fun.
05:37:15 <LeCamarade> Oh, and I have mod_fastcgi installed, so ...
05:37:27 <wli> int-e: I seem to be having the most luck with the state monad out of all of them.
05:38:00 <Lemmih> HAppS is a very general system. You can use the built-in HTTP server or use CGI.
05:38:02 <LeCamarade> Anyway, if I'm doing a blog engine in Haskell, it is .cgi, for better or worse.
05:38:08 <wli> What's a good data structure for a FIFO queue? Hmm.
05:38:22 <|Steve|> wli: Two lists works reasonably well.
05:38:30 <LeCamarade> I'm not too keen on going the HAppS way, since I don't know what host I'll have.
05:38:33 <wli> |Steve|: How's that work?
05:38:39 <dons> wli, a Chan?
05:38:46 <dons> ?docs Control.Concurrent.Chan
05:38:46 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-Chan.html
05:39:03 <int-e> wli: Basically what I'm saying is that learning all about monads is the wrong approach. It's better to pick one of them, and learn more about it. Then pick another. At some point look at monad transformers which allow stacking monads on top of other monads. That's where it becomes really useful.
05:39:04 <|Steve|> You have a list for the front of the queue and a list in reversed order for the end of the queue.
05:39:25 <dons> data Chan a
05:39:25 <dons>  = Chan (MVar (Stream a))
05:39:25 <dons>         (MVar (Stream a))
05:39:30 <dons> type Stream a = MVar (ChItem a)
05:39:31 <dons> data ChItem a = ChItem a (Stream a)
05:39:37 <dons> (i.e. a two end list :)
05:39:39 <|Steve|> So you can pull elements off the front list in constant time (and return a new queue!) if the first list is nonempty.
05:40:09 <|Steve|> If the first list is empty, reverse the second list and grab the front element. Enqueuing is just adding an element to the head of the second list.
05:40:34 <wli> I'm thinking there should be order-preserving rotations/etc. of complete binary trees.
05:41:16 <wli> Kind of like rank-ordered binary search trees.
05:41:24 <int-e> wli: Another argument just to prove this point: Consider the definition  data Null a = Null; with an instance  instance Monad Null where return _ = Null; _ >>= _ = Null. This satisfies the monad laws, but obviously there's nothing interesting you can do with it. So it must be the particular instance of a monad that makes it interesting. You'll find that every monad comes with some additional operations to achieve that.
05:42:05 <wli> int-e: Yeah, the idea is to build up experience/repertoires/etc.
05:43:57 <int-e> > replicateM 5 [0,1] -- understanding this should give a good idea what the list monad does.
05:43:59 <lambdabot>  [[0,0,0,0,0],[0,0,0,0,1],[0,0,0,1,0],[0,0,0,1,1],[0,0,1,0,0],[0,0,1,0,1],[0,...
05:44:27 <v0|d> int-e: this is called permuting in abstract algebra afairemember.
05:44:44 <profmakx> O.o
05:44:49 <v0|d> to see how a domain can map onto itself.
05:45:17 <v0|d> ie let f:S->(S,S)
05:45:19 <wli> v0|d: No, it's called a powerset in set theory.
05:46:03 <v0|d> wli: isn't that a specialized case?
05:46:25 <wli> v0|d: No.
05:46:34 <wli> v0|d: n! vs. n^k
05:46:39 <v0|d> ah ok.
05:47:15 <wli> length $ replicateM k [1..n] should give n^k
05:47:52 <v0|d> what does permuting in haskell for a given set?
05:47:54 <|Steve|> What wli is alluding to is that there are n! permutations of a set of size n whereas there are n^k functions from a set of size k to a set of size n.
05:48:05 <wli> |Steve|: Yes.
05:48:38 <ejt> 6
05:48:41 <ejt> doh
05:49:46 <dons> v0|d: the list monad usually :) 
05:49:53 <dons> v0|d: google should find some hits though
05:50:25 <v0|d> dons: ok, i'm just trying to warm up haskell. any help would be nice:)
05:51:01 <dons> so you know about the haskell list type?
05:51:09 <v0|d> right.
05:51:14 <int-e> wli: another aspect of monads that I forgot is that you can define your own ones. Often you'll wrap an existing one in a newtype and provide your own operations.
05:51:45 <wli> Dsta.Sequence, aha.
05:52:09 * LeCamarade wishes that O'Reilly lecture of SPJ's with Xmonad will be published.
05:52:25 <wli> I wish I could afford to go.
05:52:25 <dons> v0|d: here's a thread about writing different permute functions, http://www.mail-archive.com/haskell@haskell.org/msg19025.html
05:52:26 <lambdabot> Title: [Haskell] String permutation
05:52:42 <int-e> wli: for example, say you have some game. you have a type Board that represents boards and a type Move that represents moves; you can define a monad, newtype Game = Game (State Board) with two operations: inspect : Game Board  and  move : Move -> Game Boolean; inspect would give you the current board, and move would attempt to execute a move.
05:53:46 <v0|d> dons: thnx.
05:53:56 <int-e> wli: The monad operations return and >>= will be the same as for the State monad. But get and put will not be available for the Game monad - the newtype adds a level of abstraction.
05:55:21 <HairyDude> how well do associated type synonyms work? they seem to compile ok, but not type check
05:56:04 <HairyDude> that is, certain instances don't type check
05:56:45 <dons> type synonyms aren't complete
05:56:52 <dons> data types and newtypes should work
05:57:02 <int-e> check http://hackage.haskell.org/trac/ghc/wiki/TypeFunctionsStatus
05:57:04 <lambdabot> Title: TypeFunctionsStatus - GHC - Trac
05:57:10 <dons> but type synonyms will have a few gaps. spj said yesterday they're about 2 weeks away
05:57:24 <HairyDude> ah, cool
06:00:57 <HairyDude> my one that doesn't type check is MemoTrie Unit b vs b, where we have type MemoTrie Unit b = b
06:02:12 <ski> int-e : itym 'newtype Game a = Game (State Board a)' ?
06:02:28 <int-e> ski: err right. sorry :)
06:02:54 <int-e> and with ghci I'd stick a 'deriving Monad' at the end.
06:02:55 <ski> no eta-contraction of 'newtype's :/
06:03:09 <int-e> the compiler would've noticed ;)
06:03:29 <HairyDude> a functor composition operator would be handy :)
06:03:47 <ski> newtype Game = Game . State Board
06:03:51 <ski> ? :)
06:03:52 <|Steve|> Okay, I know what alpha-renaming is, I'm familiar with beta-reduction, but what is eta-contraction?
06:03:56 <HairyDude> something like that :)
06:04:04 <int-e> |Steve|: \x -> f x = f
06:04:06 <Heffalump> \x -> f x == f, if x not free in f
06:04:27 <Heffalump> eta-contraction is the left-to-right direction of that equation, eta-expansion is the right-to-left direction
06:04:40 <wli> instance  Monad []  where
06:04:40 <wli>     m >>= k             = foldr ((++) . k) [] m
06:04:59 <int-e> @src concatMap
06:04:59 <lambdabot> concatMap f = foldr ((++) . f) []
06:05:00 <HairyDude> so foo y = bar y => foo = bar
06:05:01 <wli> Need I say "oh dear?"
06:05:01 <|Steve|> Okay, I see.
06:05:12 <wli> int-e: aha
06:05:48 <|Steve|> It took me a minute to see what you were getting at there. I blame the time and the fact that I don't study PL. =)
06:06:08 <HairyDude> functor composition would incidentally do away with the need for monad transformers, I think
06:06:35 <ski> HairyDude : (forall y. foo y = bar y) => foo = bar
06:07:12 <HairyDude> ski: I was thinking more in terms of haskell function defs, so the forall was implied
06:08:25 <ski> np
06:08:53 <wli> Seq appears to already be an instance of Monad.
06:09:15 <ski> @index Seq
06:09:15 <lambdabot> bzzt
06:09:36 <wli> instance Monad Seq where { return = singleton ; xs >>= f = foldl' add empty xs where { add ys x = ys >< f x } }
06:10:35 <wli> I can't quite tell what on earth that dos.
06:10:42 <ski> why foldl' ?
06:11:34 <int-e> wli: same thing, it's a concatMap. >< is append - concat and map are done together by the foldl' (but why foldl'? I don't know either.)
06:12:13 <int-e> maybe because Seq is strict (in the sense that you can't find its head before constructing the whole sequence) anyway.
06:12:33 <ski> could be
06:12:49 <|Steve|> >< is append?
06:12:58 <wli> int-e: Sounds rather plausible.
06:13:08 <wli> |Steve|: (++) for Seq
06:13:17 <ski> i presume '(><) :: forall a. Seq a -> Seq a -> Seq a'
06:13:32 <int-e> @type (Data.Seq.><)
06:13:34 <lambdabot> Couldn't find qualified module.
06:13:56 <int-e> @type (Data.Sequence.><)
06:13:58 <lambdabot> forall a. Data.Sequence.Seq a -> Data.Sequence.Seq a -> Data.Sequence.Seq a
06:14:37 <wli> int-e: It seems to behave identically to the list enumeration.
06:15:27 <wli> It's pretty obvious that the List Monad instance has LIFO semantics, so that won't do.
06:16:01 <ski> 'LIFO semantics' ?
06:16:21 <Igloo> last in first out
06:16:24 <int-e> > let xs = 1:(xs >>= \x -> [x+1, x]) in xs
06:16:26 <lambdabot>  [1,2,1,3,2,2,1,4,3,3,2,3,2,2,1,5,4,4,3,4,3,3,2,4,3,3,2,3,2,2,1,6,5,5,4,5,4,4...
06:16:44 <ski> int-e : ty
06:17:20 <int-e> I think of it as FIFO, but maybe from a different perspective.
06:17:36 <wli> int-e: That is one strange ordering.
06:17:59 <ski> a list seen as a stack is LIFO .. but i don't see how that corresponds to list as a monad
06:18:16 <wli> ski: Now that I look at it, I don't either.
06:18:26 <ski> wli : useful for traversing infinite trees
06:19:20 <int-e> > let xs = 1:(xs >>= \x -> [x, x+1]) in xs -- this is more meaningful: it counts the number of bits in n, for n = 1,2,...
06:19:22 <lambdabot>  [1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3,3...
06:20:30 <wli> xs = 1 : ( xs >>= \x -> [2*x, 2*x+1] ) may be more enlightening.
06:20:57 <ski> > fix $ \xs -> (do return 1) `mplus` (do x <- xs; return (x+1) `mplus` return (x/(x+1))) :: [Rational]
06:20:58 <lambdabot>  [1%1,2%1,1%2,3%1,2%3,3%2,1%3,4%1,3%4,5%3,2%5,5%2,3%5,4%3,1%4,5%1,4%5,7%4,3%7...
06:21:44 <wli> int-e: transpose is the missing piece.
06:21:45 <ski> > fix $ \xs -> (do return 1) `mplus` (do x <- xs; return (x+1)) `mplus` (do x <- xs; return (x/(x+1))) :: [Rational]
06:21:47 <lambdabot>  [1%1,2%1,3%1,4%1,5%1,6%1,7%1,8%1,9%1,10%1,11%1,12%1,13%1,14%1,15%1,16%1,17%1...
06:22:20 <dons> always enumerating the rationals.
06:22:24 <dons> that's all we ever do in here!
06:22:29 <dons> :)
06:22:29 <wli> int-e: concatMap is wrong; there needs to be a transpose.
06:22:37 <int-e> > fix ((1:) . (>>= \x -> [x+1, 1/(x+1)]) :: [Rational] -- my favorite so far.
06:22:37 <lambdabot>  Parse error
06:22:46 <int-e> > fix ((1:) . (>>= \x -> [x+1, 1/(x+1)])) :: [Rational]
06:22:48 <lambdabot>  [1%1,2%1,1%2,3%1,1%3,3%2,2%3,4%1,1%4,4%3,3%4,5%2,2%5,5%3,3%5,5%1,1%5,5%4,4%5...
06:22:52 <dons> oh, that's very nice
06:23:05 <dons> int-e: should stick that on the `blow your mind' wiki page
06:23:11 <int-e> wli: yes the arguments are swapped.
06:23:19 <dons> the prefix >>= is unusual
06:23:29 <wli> int-e: No, in the List monad instance.
06:23:41 <ski> @type \f -> (>>= f)
06:23:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
06:23:49 <dons> the list monad rocks
06:23:52 <ski> just the monadic "extension"
06:24:34 <int-e> wli: no why?
06:25:00 <wli> int-e: The inner lists generated by fmap f may be infinite.
06:25:16 <dons> > (id >>= (+) >>= (+) >>= (+)) 3
06:25:17 <lambdabot>  12
06:25:53 <int-e> wli: yes. but the original list may be infinite, too. and with concatMap it satisfies the monad laws while with the additional transpose I'd be very doubtful about that.
06:26:00 <dons> > ([True, False] >>=) . (return .) =<< [not, not]
06:26:01 <lambdabot>  [False,True,False,True]
06:26:36 <waern_> cdsmith: ping
06:27:20 <mauke> > (fix . return >>= (+) >>= (+) >>= (+)) 3
06:27:21 <lambdabot>  12
06:28:33 <int-e> wli: anyway, yes, you can write fairer monads for backtracking. but that doesn't make the list instance wrong.
06:28:38 <Syzygy-> ...
06:28:47 <LoganCapaldo> > (fix . return >>= (*) >>= (*) >>= (*)) 2
06:28:48 <lambdabot>  16
06:30:29 <v0|d> could somebody enlighten me if there is relation btw the ski machine and the usual opamp PID?
06:30:43 <wli> int-e: Okay, what's going on with backtracking and why does transpose break the List monad instance?
06:30:46 <psykotic> v0|d, that's rather out of leftfield.
06:31:06 <v0|d> psykotic: leftfield?
06:31:07 <psykotic> v0|d, you mean PID as in proportional-integral-derivative? i can't imagine a connection.
06:31:22 <v0|d> psykotic: right. i mean that PID.
06:31:31 <psykotic> what kind of connection could you possibly imagine?
06:32:23 <psykotic> it seems like a case of apples and sea cucumbers to me.
06:32:27 <mauke> @check fix . return >>= (==) :: Integer -> Bool
06:32:29 <lambdabot>  OK, passed 500 tests.
06:32:58 <dons> nice mauke 
06:33:01 <dons> very nice
06:33:09 <psykotic> dons: are there any gotchas with type inference in ghc for existentials?
06:33:22 <dons> you can't pattern match on them :)
06:33:27 <dons> otherwise, not really
06:33:29 <dons> they just work
06:33:38 <dons> oh, maybe there's an interaction with GADTs
06:34:00 <psykotic> they seem damn necessary for a lot of things.
06:34:22 <psykotic> like, i want to parse an object and return it, with the object having some "static capability" in the form of a type class.
06:34:23 <dons> they sure do. i love existentials
06:34:39 <dons> yeah, they fit really nicely with typeclasses encapsulating the existential api
06:34:54 <int-e> wli: I expect (but I didn't check) that (m >>= f) >>= g = m >>= (\x -> f x >>= g)  will break. also, how do you define transpose for lists of lists that don't have the same length? like [[1,2],[],[3,4,5]]?
06:35:39 <psykotic> dons: so if i use that approach i shouldn't run into issues?
06:36:14 <dons> existentials have worked for 10 years or more
06:36:24 <LoganCapaldo> :t fix .
06:36:26 <lambdabot> parse error (possibly incorrect indentation)
06:36:32 <int-e> > transpose [[1,2],[],[3,4,5]]
06:36:34 <lambdabot>  [[1,3],[2,4],[5]]
06:36:34 <LoganCapaldo> :t fix . return
06:36:38 <lambdabot> forall a. a -> a
06:36:51 <psykotic> dons: oh, i meant more in terms of practical design issues.
06:36:52 <wli> int-e: Carefully. ;) 
06:37:02 <LoganCapaldo> :t (fix . return >>=)
06:37:04 <lambdabot> forall a b. (a -> a -> b) -> a -> b
06:37:06 <psykotic> dons: it seems like if you abstract away everything except the type class (as static capability) it should be nice and problemfree.
06:37:16 <dons> yeah, it seems reasonable
06:37:20 <LoganCapaldo> there's the magic...
06:37:26 <dons> i'd need to see code to be able to say more though
06:37:54 <int-e> wli: you can get away with a weaker definition of equality in practice I suppose (say, two lists are considered to be equal if they contain the same arguments)
06:37:59 * wli reads Oleg's paper.
06:38:22 <LoganCapaldo> :t (fix . return >>=) (+)
06:38:24 <psykotic> i think the examples are fairly typical. imagine a graphics renderer of some sort, with various kinds of objects supporting a fixed interface in the form of a type class. you'd like to parse them from scene description files, keep them in lists (which are processed by the renderer), etc.
06:38:24 <lambdabot> forall a. (Num a) => a -> a
06:38:34 <LoganCapaldo> > (fix . return >>=) (+) 2
06:38:35 <lambdabot>  4
06:39:00 <int-e> if you replace  fix . return  by  id  then it becomes pretty clear I think
06:39:23 <LoganCapaldo> mmm
06:39:40 <int-e> @pl \x -> x + x + x + x
06:39:40 <lambdabot> (+) =<< (+) =<< join (+)
06:40:14 <LoganCapaldo> Sometimes I hate that instance
06:41:04 <wli> Well, now that I've got a newtype wrapper for the list...
06:43:22 <dons> psykotic: yep, sounds like a good case
06:43:34 <dons> lambdabot uses existentials to represent all the different plugins, and their state types
06:43:39 <wli> It won't quite backtrack properly as the backpropagation was implicit in LIFO semantics where in FIFO semantics backpropagating False into a conjunction or True into a disjunction are not automatic and/or so easy.
06:43:40 <psykotic> right
06:43:53 <dons> they have a fixed api, and a state, wrapped up in an existential, sitting in a list, in a dispatch loop
06:44:04 <dons> its OO programming :)
06:44:11 <psykotic> right, that's what i'm looking for :)
06:44:47 <|Steve|> Can I get ghci :reload the file that I just finished :editing? Also, if loading fails, can I get it to remember which file I had just been editing so that I don't have to :e <filename> every time?
06:44:52 <wli> So there's quite a bit more to this.
06:44:56 <psykotic> i considered an alternative, of using a record, with the state being closed over.
06:45:06 <ski> > transpose . transpose $ [[1,2],[],[3,4,5]]
06:45:07 <lambdabot>  [[1,2,5],[3,4]]
06:45:08 <dons> |Steve|: :reload should just work, should it?
06:45:20 <psykotic> the fields of the record would then constitute the interface, in a sense, and the state wouldn't be externally accessible, since it's all closed over.
06:45:37 <|Steve|> dons: Yes, but I want it to reload when I finish editing, just like hugs does.
06:45:38 <dons> existentials might be cleaner
06:45:39 <LoganCapaldo> dons: I think he wants to avoid haveing to type that
06:45:44 <psykotic> dons: yes, that was my conclusion.
06:45:54 <|Steve|> But even more than that, I want to be able to use :e after :r fails.
06:46:07 <dons> and hidden state you can hide with associated types or functional dependencies (so that the existentials might have different internal state)
06:46:09 <matthew-_> I have a finite static set of things which I need to extract from really fast. Should I use an array or a map ?
06:46:10 <LoganCapaldo> ie, :e foo.hs <edit the file, exit the editor, ghci reloads it>
06:46:18 <wli> newtype FIFO t = FIFO [t] deriving (Eq, Ord, Read, Show) ; instance Functor FIFO where fmap f (FIFO x) = FIFO (fmap f x) ; instance Monad FIFO where { return = FIFO . (:[]) ; (FIFO xs) >>= f = FIFO . concat $ transpose [ys | FIFO ys <- map f xs] }
06:46:22 <|Steve|> LoganCapaldo: Exactly.
06:46:25 <dons> matthew-_: lookup needs to be O(1) ?
06:46:33 <dons> or just fast? what are the keys?
06:46:44 <dons> and they're static? and finite? I'd go an array
06:46:54 <matthew-_> dons: keys are Ints and are known statically
06:47:03 <dons> elements are what type?
06:47:08 <matthew-_> custom
06:47:11 <matthew-_> ADT
06:47:15 <dons> Array Int a seems reasonable 
06:47:27 <dons> and O(1) lookup.
06:47:50 <matthew-_> super. Thank you.
06:48:22 <matthew-_> dons: I'm sure you should be in bed by now
06:48:40 <|Steve|> I should be in bed. It's 15 'til 7am.
06:48:44 <dons> yeah, almost
06:49:00 <wli> Another way to think of it is tree unfolding.
06:50:41 <puusorsa> huge chrome cylinder box unfolding
06:52:22 <|Steve|> ghc has been compiling for something like 3 hours now.
06:52:35 <|Steve|> I fail to see how anyone gets any work done on the compiler.
06:54:16 <wli> children keep backpointers to their parents for backpropagation, each node can take 1 of 3 actions: (1) generate another child node (2) return to its parent, killing its children or (3) wait for its children.
06:54:25 <ski> > [0,3,6,9] >>= \x -> [1,5,8] >>= \y -> guard (x < y) >>= \_ -> return (x,y)
06:54:26 <lambdabot>  [(0,1),(0,5),(0,8),(3,5),(3,8),(6,8)]
06:54:30 <ski> > ([0,3,6,9] >>= \x -> [1,5,8] >>= \y -> return (x,y)) >>= \(x,y) -> guard (x < y) >>= \_ -> return (x,y)
06:54:32 <lambdabot>  [(0,1),(0,5),(0,8),(3,5),(3,8),(6,8)]
06:54:36 <ski> > let xs >>= f = concat $ transpose (map f xs) in [0,3,6,9] >>= \x -> [1,5,8] >>= \y -> guard (x < y) >>= \_ -> return (x,y)
06:54:37 <lambdabot>  [(0,1),(3,5),(6,8),(0,5),(3,8),(0,8)]
06:54:40 <ski> > let xs >>= f = concat $ transpose (map f xs) in ([0,3,6,9] >>= \x -> [1,5,8] >>= \y -> return (x,y)) >>= \(x,y) -> guard (x < y) >>= \_ -> return (x,y)
06:54:41 <lambdabot>  [(0,1),(0,5),(3,5),(0,8),(3,8),(6,8)]
06:54:48 <ski> wli : ^
06:54:59 <wli> ski: What's that?
06:55:28 <ski> it appears your '(>>=)' doesn't satisfy the "associative" monad law
06:56:09 <wli> ski: Interpreted as sets vs. what (==) returns it's okay. They're the same membership-wise.
06:56:28 <ski> yes
06:59:01 <wli> ski: So it's really the Eq instance that's wrong.
07:13:07 <ski> > take 15 $ fix $ \xs -> (return 1) `mplus` (xs >>= \x -> return (x+1) `mplus` return (x/(x+1))) :: [Rational]
07:13:08 <lambdabot>  [1%1,2%1,1%2,3%1,2%3,3%2,1%3,4%1,3%4,5%3,2%5,5%2,3%5,4%3,1%4]
07:13:13 <ski> > take 15 $ fix $ \xs -> (return 1) `mplus` (xs >>= \x -> return (x+1)) `mplus` (xs >>= \x -> return (x/(x+1))) :: [Rational]
07:13:15 <lambdabot>  [1%1,2%1,3%1,4%1,5%1,6%1,7%1,8%1,9%1,10%1,11%1,12%1,13%1,14%1,15%1]
07:13:18 <ski> > take 15 $ let xs >>= f = concat $ transpose (map f xs) in fix $ \xs -> (return 1) `mplus` (xs >>= \x -> return (x+1) `mplus` return (x/(x+1))) :: [Rational]
07:13:20 <lambdabot>  [1%1,2%1,3%1,4%1,5%1,6%1,7%1,8%1,9%1,10%1,11%1,12%1,13%1,14%1,15%1]
07:13:25 <ski> > take 15 $ let xs >>= f = concat $ transpose (map f xs) in fix $ \xs -> (return 1) `mplus` (xs >>= \x -> return (x+1)) `mplus` (xs >>= \x -> return (x/(x+1))) :: [Rational]
07:13:26 <lambdabot>  [1%1,2%1,3%1,4%1,5%1,6%1,7%1,8%1,9%1,10%1,11%1,12%1,13%1,14%1,15%1]
07:13:39 <ski> > take 15 $ let xs >>= f = concat $ transpose (map f xs) in fix $ \xs -> (return 1) `mplus` (xs >>= \x -> [True,False] >>= \b -> return (if b then x+1 else x/(x+1))) :: [Rational]
07:13:40 <lambdabot>  [1%1,2%1,3%1,4%1,5%1,6%1,7%1,8%1,9%1,10%1,11%1,12%1,13%1,14%1,15%1]
07:13:54 <ski> > take 15 $ let xs >>= f = concat $ transpose (map f xs) in fix $ \xs -> (return 1) `mplus` ([True,False] >>= \b -> xs >>= \x -> return (if b then x+1 else x/(x+1))) :: [Rational]
07:13:55 <lambdabot>  [1%1,2%1,1%2,3%1,2%3,3%2,1%3,4%1,3%4,5%3,2%5,5%2,3%5,4%3,1%4]
07:23:16 <|Steve|> Wow, installing ghc really made my computer start swapping. I wouldn't think the installation process would require more than a gig and a half...
07:24:14 <dons> hmm, that seems excessive
07:24:28 <dons> installing? or building?
07:24:35 <dons> i suppose it could be `ld' going nuts
07:24:38 <|Steve|> Installing.
07:24:59 <jix> installing was very fast and not ram intensive here...
07:25:00 <dons> oh, its just thrashing your disks?
07:25:03 <|Steve|> Once it started installing, everything ground to a halt and /var/vm shows that I have 2GB of swap files.
07:25:18 <dons> seems odd. what processes are running?
07:25:29 <|Steve|> Maybe it was just disk thrashing and the swap files are from building.
07:26:05 <|Steve|> Nothing else memory intensive, a few browsers, iTunes, mail, some editors, video player. Nothing but iTunes is really doing anything though.
07:30:27 <ClaudiusMaximus> i hate braindead C API's that make me do:  r <- newIORef Nothing ; x <- apiFunc (f r) ; writeIORef r (Just x)    -- :(
07:30:44 <pjd> wow, ap (++) show "ap (++) show " is a nice quine
07:31:18 <|Steve|> > ap (++) show "ap (++) show "
07:31:19 <lambdabot>  "ap (++) show \"ap (++) show \""
07:31:29 <pjd> kpreid++
07:31:31 <|Steve|> Not quite a quine.
07:31:52 <pjd> you have to print it, of course
07:31:57 <pjd> > print $ ap (++) show "ap (++) show "
07:31:58 <lambdabot>  <IO ()>
07:32:00 <pjd> err
07:32:09 <pjd> > putStrLn $ ap (++) show "ap (++) show "
07:32:11 <lambdabot>  <IO ()>
07:32:16 <pjd> phooey
07:32:21 <kpreid> it's a quine in that eval :: String -> String returns it if given as input
07:32:28 <ski> @. read run ap (++) show "@. read run ap (++) show " 
07:32:30 <lambdabot>  @. read run ap (++) show "@. read run ap (++) show "
07:32:36 <SamB_XP> @hoogle eval
07:32:37 <lambdabot> Control.Exception.evaluate :: a -> IO a
07:32:37 <lambdabot> Test.QuickCheck.evaluate :: Testable a => a -> Gen Result
07:32:37 <lambdabot> Control.Monad.RWS.evalRWS :: RWS r w s a -> r -> s -> (a, w)
07:32:48 <kpreid> pjd: I explain this classification on the quine page
07:32:50 <SamB_XP> where is this "eval :: String -> String"
07:32:53 <pjd> kpreid: yeah
07:33:01 <kpreid> SamB: mostly conceptual
07:33:06 <pjd> evaluating to its own source is arguably superior to printing it out
07:33:11 <kpreid> I believe so
07:33:21 <kpreid> most of my quines these days are of that sort
07:33:33 <|Steve|> Bah, then 5 is a quine.
07:33:44 <SamB_XP> no...
07:33:55 <kpreid> it's a degenerate quine
07:34:03 <SamB_XP> 5 prints out its source ;-P
07:34:06 <|Steve|> > 5
07:34:07 <lambdabot>  5
07:34:10 <|Steve|> I rest my case.
07:34:15 <pjd> that's a number, not a string :)
07:34:20 <|Steve|> So?
07:34:25 <pjd> unlike the quine
07:34:34 <|Steve|> "5"
07:34:36 <|Steve|> > "5"
07:34:37 <kpreid> oh, right. okay, it isn't a quine in the same way
07:34:37 <lambdabot>  "5"
07:34:58 <psykotic> @src gcast
07:34:58 <lambdabot> Source not found. You speak an infinite deal of nothing
07:35:08 <kpreid> ...or not a quine at all, because everything in its class is trivial
07:35:32 <kpreid> I've got to go
07:35:45 <|Steve|> I'm still proud of last night's wasted time making a quine in C without a semicolon.
07:43:25 * wli fixes up his purely list-based cantor pairing function so it works properly on ragged, finite, etc. lists of lists.
07:49:57 <Baughn> |Steve|: Did you do it by replacing semicolons with commas?
07:50:56 <SamB_XP> Baughn: that's still pretty impressive
07:51:54 <Baughn> SamB_XP: Perhaps. Intuitively it isn't, but I could be missing something.
07:53:13 <SamB_XP> well, how do you make variables with only commas?
07:54:01 <Baughn> Point. Come to think of it, how do you do it with no statements in main?
07:55:17 <LoganCapaldo> For some reason, I think you can ellide the last semicolon in a function
07:55:30 <LoganCapaldo> I could be wrong
07:55:31 <hpaste>  wli pasted "Cantor pairing function for both finite and infinite cases" at http://hpaste.org/1675
07:55:55 <Baughn> LoganCapaldo: Pretty sure you can't, which makes me want to look at this code
07:56:46 <LoganCapaldo> I really need to setup my other computer with all my dev. stuff
07:57:04 <LoganCapaldo> moving has totaly ruined my "try out little bits of code"
07:58:27 <|Steve|> Baughn: Yeah, pretty much.
07:58:44 <|Steve|> http://pahtak.org/~steve/quine.c is how I did it.
07:59:34 <SamB_XP> |Steve|: could you copy that to .txt?
08:00:02 <Baughn> ..I really need to find the mime-type database for firefox
08:00:20 <SamB_XP> my browser doesn't seem to know that C source is just a kind of text...
08:00:36 <LoganCapaldo> perform. clever.
08:01:36 <Baughn> SamB_XP: Firefox?
08:01:40 <SamB_XP> Baughn: yeah
08:01:43 <Pupeno> I have this: newtype Label = Label String, and I am trying to make it an instance of Arbitrary with arbitrary = oneof ["test"], as it is specified in Quickcheck's manual, but I get this error: Couldn't match expected type `Gen Label' against inferred type `[Char]', what am I doing wrong?
08:01:44 <Baughn> SamB_XP: https://addons.mozilla.org/en-US/firefox/addon/4498
08:02:08 <ski> wli : "cantor pairing function" ?
08:02:37 <wli> ski: Yes. It's a function he used in one of his proofs that N x N and N are in bijective correspondence.
08:02:39 <Pupeno> I've tried [Label "text"] and I've got the same error, obviously, but for Gen Label vs Label.
08:02:52 <|Steve|> I just realized that I have a bug in the code that hasn't been triggered. Oh well.
08:03:07 <|Steve|> Okay, quine.txt is there as well.
08:03:09 <ski> wli : oh .. that
08:03:51 <Baughn> Sadly, it seems to lack "view this file in firefox"
08:05:13 <SamB_XP> yes it does
08:05:44 <wli> ski: It does no arithmetic. It merely rearranges lists of lists in like fashion.
08:06:04 * ski has written it before :)
08:06:28 <Baughn> Whatever you do, don't set it to open in firefox
08:06:30 <scook0> Pupeno: try oneof [return (Label "test")]
08:06:33 <Baughn> SamB_XP: that is
08:06:39 <ski> Baughn :)
08:07:11 <wli> ski: I originally wrote it in 2001. This is merely touching up the code to handle finite, irregular, etc. lists of lists.
08:07:16 <ski> SamB_XP : istr sometimes this kind of problem is because the web server is misconfigured
08:07:26 <basti_> :t oneof
08:07:28 <lambdabot> Not in scope: `oneof'
08:07:34 <basti_> hm
08:07:55 <ski> @index oneof
08:07:55 <lambdabot> Test.QuickCheck, Debug.QuickCheck
08:08:07 <SamB_XP> ski: it doesn't seem to be that
08:08:21 <scook0> Pupeno: or try elements instead of oneof
08:08:26 <SamB_XP> I think the webserver is correctly configured, and firefox only works if it is *not*
08:08:34 <Pupeno> :t Test.QuickCheck.oneof
08:08:35 <ski> could be
08:08:36 <lambdabot> forall a. [Test.QuickCheck.Gen a] -> Test.QuickCheck.Gen a
08:08:46 <HairyDude> ah, that's why :*: et al aren't in the haddock docs - they're wrapped in #ifndef __HADDOCK__ (and apparently marked as obsolete)
08:08:50 <scook0> :t Test.QuickCheck.elements
08:08:52 <lambdabot> forall a. [a] -> Test.QuickCheck.Gen a
08:08:53 <Pupeno> :t Test.QuickCheck.elements
08:08:55 <lambdabot> forall a. [a] -> Test.QuickCheck.Gen a
08:09:26 <ski> elements = oneof . map return  -- i presume
08:09:52 <HairyDude> how do you do generic type-indexed types these days then? do you have to resort to TH?
08:10:20 <SamB_XP> type-indexed?
08:10:33 <Heffalump> pre 6.7?
08:10:43 <Heffalump> you can play some games with fundeps
08:11:35 <HairyDude> what I mean is to generate a type based on the structure of another type, automatically
08:11:40 <SamB_XP> Heffalump: he seems to be using 6.7
08:11:40 <HairyDude> 6.7 is ok
08:12:36 <SamB_XP> but he's run into associated type synonyms not working yet
08:13:00 <HairyDude> I want to do more than that though
08:13:01 <SamB_XP> HairyDude: you could use associated datatypes instead
08:13:16 <SamB_XP> or, yeah, fundeps
08:14:00 <SamB_XP> you might also be interested in Data.Generics?
08:14:08 <HairyDude> you still have to do an instance for each individual type. I want some way of generating the instances automatically. I know I could use DrIFT, but I'm looking for another way
08:14:20 <SamB_XP> ah. Derive might be of interest.
08:14:34 <SamB_XP> ... and, yes, that does use TH.
08:14:39 <HairyDude> SamB_XP: yeah, not especially well documented it seems
08:14:47 <SamB_XP> hmm.
08:14:52 <HairyDude> Data.Generics I mean
08:14:55 <SamB_XP> oh.
08:15:06 <SamB_XP> what's wrong with it's documentation?
08:15:53 <SamB_XP> it might help if you would give some examples of what you want
08:17:06 <HairyDude> hmm... maybe it just takes a bit of thinking
08:18:09 <fasta> What are the run-time costs of using fail "We are now doing this step because of reason zork" as opposed to Nothing? 
08:18:10 <HairyDude> instance Data a => Memoizable a where data MemIso a v = ???
08:18:31 <SamB_XP> fasta: it doesn't really have any runtime costs if you are using the Maybe monad...
08:18:44 <SamB_XP> fasta: at least, not as long as the compiler *knows* you are
08:18:49 <HairyDude> I suppose the ??? would have to be a template
08:19:20 <fasta> SamB_XP: at compile time it will know, but it goes through a module boundary.
08:19:25 <SamB_XP> HairyDude: is that the only instance you want for Memoizable?
08:19:29 <fasta> SamB_XP: does that matter?
08:20:04 <SamB_XP> fasta: you mean that you export the function with a "Monad m" constraint?
08:20:05 <HairyDude> SamB_XP: the point is I want one instance that will work for _any_ algebraic datatype
08:20:18 <fasta> SamB_XP: right
08:20:34 <fasta> SamB_XP: just like lookup
08:20:36 <HairyDude> SamB_XP: so the user doesn't have to define instances manually
08:20:39 <fasta> SamB_XP: (for maps)
08:21:33 <HairyDude> basically what I want is a type-indexed instance :)
08:22:12 <SamB_XP> HairyDude: so what about drift don't you like? the fact that it's a preprocessor, or the fact that you need to write your prettyprinter using not much more than the standard combinators?
08:22:41 <HairyDude> SamB_XP: the fact that it's another language :)
08:23:05 <SamB_XP> HairyDude: what other language?
08:23:15 <SamB_XP> last I checked it was written in Haskell...
08:23:25 <HairyDude> SamB_XP: you do stuff using magic comments, right?
08:23:34 <SamB_XP> oh, a little yes
08:24:46 <SamB_XP> but most of my dislike for drift is founded on the fact that you've got to write a prettyprinter pretty much from scratch in order to implement a deriving...
08:26:21 <fasta> The existence of drift shows a need for a macro system like that of PLT. 
08:27:06 <mdmkolbe|ubuntu> @type merge
08:27:08 <lambdabot> Not in scope: `merge'
08:27:13 <SamB_XP> Why do I always want to think "Python Lettuce and Tomatos" when I see PLT?
08:27:15 <mdmkolbe|ubuntu> @index sort
08:27:15 <lambdabot> Data.List
08:27:40 <fasta> Why does a macro call in TH look not the same as a function call, btw?
08:28:05 <SamB_XP> fasta: it is a function call!
08:28:18 <SamB_XP> which is why it doesn't look like one
08:28:30 <HairyDude> PLT?
08:28:34 <mdmkolbe|ubuntu> @src sort
08:28:34 <lambdabot> sort = sortBy compare
08:28:40 <mdmkolbe|ubuntu> @src sortBy
08:28:40 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
08:28:50 <mdmkolbe|ubuntu> @type sort
08:28:51 <lambdabot> forall a. (Ord a) => [a] -> [a]
08:28:53 <fasta> SamB_XP: I think I have always seen $(macrocall args)
08:29:27 <fasta> SamB_XP: I didn't actually use TH for anything complicated.
08:29:38 <mdmkolbe|ubuntu> Is there a prebuilt merge operator? (i.e. take two sorted lists and make them one sorted list)
08:29:58 <fasta> SamB_XP: are you suggesting that the $ is not needed? 
08:29:59 <SamB_XP> fasta: well, see. the macro there is just a *function*
08:30:00 <HairyDude> merge xs ys = sort (xs ++ ys) ? :)
08:30:23 <kpreid> HairyDude: inefficient and unlazy
08:30:25 <SamB_XP> so, you *need* the $() to splice in the result
08:30:27 <Botje> mdmkolbe|ubuntu: you could use merge l1 l2 = foldr (insertBy cmp) l1 l2
08:30:28 <HairyDude> yes, I know
08:31:05 <Botje> don't know if that fits the laziness criterium though
08:31:07 <mdmkolbe|ubuntu> Well, the lists I'm working on are infinite, so I'm not sure insertBy will work ... on second thought I guess it would
08:31:20 <kpreid> wouldn't that traverse l1 repeatedly?
08:32:08 <SamB_XP> fasta: does that make sense?
08:32:15 <mdmkolbe|ubuntu> @type foldr (sortBy cmp)
08:32:17 <lambdabot> Not in scope: `cmp'
08:32:23 <mdmkolbe|ubuntu> @type foldr (sortBy compare)
08:32:25 <lambdabot>     Couldn't match expected type `b -> b' against inferred type `[a]'
08:32:25 <lambdabot>     In the first argument of `foldr', namely `(sortBy compare)'
08:33:04 <kpreid> > let merge (x:xs) (y:ys) | x > y = x:y:merge xs ys | otherwise = y:x:merge xs ys in merge [0,2..] [1,3..]
08:33:05 <lambdabot>  [1,0,3,2,5,4,7,6,9,8,11,10,13,12,15,14,17,16,19,18,21,20,23,22,25,24,27,26,2...
08:33:11 <kpreid> > let merge (x:xs) (y:ys) | x < y = x:y:merge xs ys | otherwise = y:x:merge xs ys in merge [0,2..] [1,3..]
08:33:13 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
08:34:19 <mdmkolbe|ubuntu> > let merge (x:xs) (y:ys) | x < y = x:y:merge xs ys | otherwise = y:x:merge xs ys in merge [0,2..] [1,5..]
08:34:21 <lambdabot>  [0,1,2,5,4,9,6,13,8,17,10,21,12,25,14,29,16,33,18,37,20,41,22,45,24,49,26,53...
08:34:39 <kpreid> um, whoops
08:34:57 * wli suggests Dirichlet convolutions.
08:35:04 <SamB_XP> wow that quine is crazy...
08:35:56 <kpreid> > let merge xs@(x:xt) ys@(y:yt) | x < y = x:merge xt ys | otherwise = y:merge xs yt in merge [0,2..] [1,5..]
08:35:57 <lambdabot>  [0,1,2,4,5,6,8,9,10,12,13,14,16,17,18,20,21,22,24,25,26,28,29,30,32,33,34,36...
08:36:01 <kpreid> there
08:36:31 <dblhelix> > let merge (x : xs) (y : ys) = if x < y then x : merge xs (y : ys) else y : merge (x : xs) ys in merge [0, 2, ...] [1, 5, ...]
08:36:32 <lambdabot>  Parse error
08:36:58 * SamB_XP bets it would have been simpler to just put the actual code in a subroutine with a pointer argument, which could at some point be used to point at a malloc'd region...
08:37:01 <dblhelix> > let merge (x : xs) (y : ys) = if x < y then x : merge xs (y : ys) else y : merge (x : xs) ys in merge [0, 2, ..] [1, 5, ..]
08:37:01 <lambdabot>  Parse error
08:37:09 <dblhelix> well, it's weekend
08:37:11 <SamB_XP> that would be more portable...
08:37:49 <dblhelix> >  let merge (x : xs) (y : ys) = if x < y then x : merge xs (y : ys) else y : merge (x : xs) ys in merge [0, 2 ..] [1, 5 ..]
08:37:51 <lambdabot>  [0,1,2,4,5,6,8,9,10,12,13,14,16,17,18,20,21,22,24,25,26,28,29,30,32,33,34,36...
08:37:57 * dblhelix sighs
08:40:32 <wli> The Dirichlet convolution of two functions defined on the positive integers, f(n) and g(n), is a function h(n) defined on n as sum f(d)*g(n `div` d) where the sum is over all positive integer divisors d of n.
08:43:53 <wli> for k functions it's the sum_i prod f_j(d_{i,j}) where the tuples of d_{i,j} ranges over all possible sets of divisors whose product is n.
08:44:16 <wli> including permutations
08:48:00 <mdmkolbe|ubuntu> I'm actualy supprized that merge isn't in the Data.List already
08:51:37 <psykotic> any haskell-mode (for emacs) users around? i'm curious if there's a nice way of having the inferior mode deal with multiple buffers. right now you have to explicitly reload when you switch files, or it'll get confused. e.g. the symbol -> type cache is global and not buffer specific.
08:52:09 <fasta> psykotic: I am interested in that too and I don't know
08:52:57 <psykotic> fasta: i'm thinking of some simple changes. 1. make the cache buffer-specific. that will be easy. 2. integrate auto-reloading when you switch buffers, only updating type cache, etc if it is successful.
08:53:12 <psykotic> also, auto-reloading after idle time
08:53:38 <fasta> psykotic: the maintainer might want to implement those, or you should do it yourself. 
08:53:55 <psykotic> i'll probably try it myself, i like elisp hacking.
08:56:36 <psykotic> related to that: is there a nice way of having multiple modules loaded at once in ghci?
08:57:02 <fasta> psykotic: :m + ?
08:58:07 <HWSOD> lambdbot is giving me "f = ap (+) negate" for "@pl f a = (+ a) $ (negate a)" 
08:58:08 <HWSOD> but when i give "let f = Monad.ap (+) negate" to GHCi, 
08:58:10 <HWSOD> it says  no instance for (Monad ((->) a))! is this just a bug in @pl or what?
08:58:21 <kpreid> HWSOD: import Control.Monad.Reader
08:58:42 <HWSOD> AAAh thanks!
09:01:25 <kpreid> psykotic: what are you doing that you find unnice?
09:01:42 <pjd> HWSOD: or Control.Monad.Instances
09:02:12 <psykotic> kpreid, basically when using C-c C-t, C-c C-i, it would be nice if it worked without having to constantly reload files using C-c C-l when you switch buffers.
09:02:35 <ski> @where shim
09:02:35 <lambdabot> http://shim.haskellco.de/trac/
09:02:45 <psykotic> kpreid, because it interacts with ghci using an inferior mode and , it can only have one source module loaded.
09:02:51 <psykotic> *inferior mode and :load
09:03:14 <kpreid> psykotic: I'm talking about module loading, not whatever haskell-mode does
09:03:24 <psykotic> well, that's what i'm talking about. :)
09:03:26 <kpreid> and I second fasta: use :m +
09:03:42 <psykotic> okay, i'll see about making the change in the elisp code
09:03:48 <kpreid> you can use uncompiled modules in the current directory with ghci, iirc
09:04:13 <kpreid> well, if it's from elisp you might or might not find :m easier than :m +
09:04:25 <kpreid> :m with no + replaces the entire set of modules in scope
09:07:00 <psykotic> does :reload deal with timestamps and dependencies correctly?
09:07:02 <psykotic> or does it bruteforce?
09:07:34 <mrd> the type cache is implemented using haskell-doc-mode's user-defined types feature.
09:07:36 <kpreid> no idea
09:08:40 <scook0> psykotic: GHCi docs say it's intelligent
09:08:53 <scook0> http://www.haskell.org/ghc/docs/6.6/html/users_guide/ghci-commands.html
09:08:55 <lambdabot> Title: 3.6. GHCi commands, http://tinyurl.com/36r6ks
09:16:03 <psykotic> okay, it seems possible to make this work without much work if i use :add rather than :load for newly loaded modules, :reload subsequently, and :m M every time you switch to a buffer corresponding to module M.
09:17:28 <psykotic> does that seem sane to anyone with more ghci-fu than i?
09:18:30 <kpreid> I bbelieve :m clears :add/:load but I could be wrong
09:19:01 <psykotic> it doesn't
09:19:05 <psykotic> :m just controls context
09:19:12 <psykotic> (i checked)
09:20:07 <DRMacIver> Hm. I wonder what first class pattern matching would look like.
09:20:23 <kpreid> first class in what way?
09:20:34 <psykotic> DRMacIver, first class patterns? well, it's trivial in lisp. typing it seems a little weird.
09:21:06 <kpreid> DRMacIver: do you mean defining patterns/pseudo-constructors, or passing around patterns, or what?
09:21:15 <Heffalump> DRMacIver: F# has recently acquired something like that.
09:21:26 <DRMacIver> kpreid: I'm not sure exactly what it would entail. That's why I'm wondering. :) But, for example, being able to define regular expression patterns as a library would be a good start.
09:21:45 <DRMacIver> Heffalump: Hm. Interesting. I'd always assumed F# was mostly an inferior OCaml. :)
09:21:52 <kpreid> DRMacIver: well, I use a (impure) language where such things are first class
09:22:12 <psykotic> drmaciver: F#'s active patterns are a less powerful version of scala's extractors (the unapply stuff)
09:22:34 <SamB> kpreid: it would be kind of cool if there was a way to pass around a pattern and have it used in both directions...
09:23:29 <kpreid> DRMacIver: a pattern extension has a type like a -> Either Error b, roughly
09:23:29 <psykotic> right, that's like scala too.
09:23:29 <kpreid> for example, the Haskell pattern [x, y] can be turned into the function [a] -> Either Error (a, b)
09:23:29 <kpreid> where the error is always "wrong number of list elements"
09:23:41 <DRMacIver> Ah, hm. I wasn't aware of Scala's extactors actually.
09:23:41 <DRMacIver> kpreid: Lisp again? :)
09:23:41 <mnislaih> :r
09:23:41 <mnislaih> oops :O
09:23:46 <DRMacIver> psykotic: hm. Intriguing. That's rather close to what I had in mind, yes.
09:23:57 <psykotic> and it's exatly what kpreid just described
09:24:14 <psykotic> anything with a method def unapply(x: A): Option[B] can work as a pattern clause
09:24:22 <kpreid> this language allows using such functions in patterns, but not turning patterns into such functions (directly) -- there's a difference in semantics, return value vs. variable bindings
09:24:51 <psykotic> so... class Twice { def unapply(n: Int) = if (n mod 2 == 0) Some(n / 2) else None }
09:25:10 <kpreid> also there's an experimental feature where any function/object can be used in a pattern (like n+k or a constructor) if it defines the matching method
09:25:12 <psykotic> 4 match { case Twice(n) => n - 1 } would give 1
09:25:31 <kpreid> like psykotic said, except not Scala :)
09:25:46 <DRMacIver> psykotic: Yeah, I've looked it up already. :)
09:26:10 <psykotic> isn't there a ghc extensions with something like this?
09:26:15 <psykotic> "Views" or something? or is that more limited?
09:26:20 <kpreid> anyway, turning a pattern into a function is not obviously-possible because variable bindings are unlike return values
09:26:59 <kpreid> I suppose you could automatically define a record type, or return a Map, or something funky like that
09:28:11 <psykotic> DRMacIver, http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
09:28:13 <lambdabot> Title: ViewPatterns - GHC - Trac
09:30:16 <psykotic> that page also mentions the F# active patterns and Scala extractors work
09:30:43 <wli> I wonder if there's a sort of analogue of a writer monad involving an input stream.
09:31:48 <DRMacIver> psykotic: Thanks
09:32:03 <xerox> wli, (e.:-_;ç°
09:32:03 <Heffalump> DRMacIver: also http://www-staff.it.uts.edu.au/~cbj/patterns/
09:32:04 <lambdabot> Title: Pattern-Matching
09:32:06 <xerox> oops, sorry.
09:32:08 <Heffalump> if you want more far-out stuff
09:35:33 <xerox> wli, there's the reader monad which gives you a constant environment
09:36:55 <scook0> I'm sure you could define your own stream-reader monad
09:37:07 <scook0> and I guess there's the stream comonad
09:38:22 <wli> I have the vague idea of a finite automaton that produces output on various state transitions here.
09:39:04 <ddarius> Coalegbra then.
09:43:24 <ski> could be implemented by a state monad where the state only decreases (i.e. chop off items)
09:44:10 <wli> ski: Well, presumably it'll be threadedthrough IO or some such.
09:44:29 <ski> or possibly with a nondeterministic splitting monad
09:45:04 <ski> (well, nondeterminism if the stream can be empty)
09:45:30 <nopcode> say, I/O seems to be horrible in functional languages
09:45:34 <nopcode> you keep talking about monads..
09:45:39 <nopcode> every day :)
09:46:16 <cdsmith> nopcode: not all monads have to do with I/O
09:46:21 <mauke> I/O seems to be horrible in Java; they keep talking about class libraries, etc
09:46:22 <wli> Well, the state expresses the finite control, the writer monad expresses the response to a stimulus, and whatever ends up getting used for inputs represents the actual stimuli.
09:46:39 <nopcode> mauke: fprintf is the shit ;)
09:46:49 <mauke> nopcode: we have that
09:47:18 <mauke> but it's called hPrintf
09:48:22 <ddarius> :t printf
09:48:25 <lambdabot> forall r. (PrintfType r) => String -> r
09:48:40 <oerjan> > concatMap (printf "%d bottles of beer on the wall") [99, 98 .. 0] :: String
09:48:42 <lambdabot>  "99 bottles of beer on the wall98 bottles of beer on the wall97 bottles of b...
09:48:58 <ddarius> We also have sprintf and it's also called printf
09:49:33 <mauke> > iterate (printf "%s") "what"
09:49:34 <lambdabot>  ["what","what","what","what","what","what","what","what","what","what","what...
09:50:00 <ddarius> > iterate id "what"
09:50:01 <lambdabot>  ["what","what","what","what","what","what","what","what","what","what","what...
09:50:13 <oerjan> > repeat "what"
09:50:15 <lambdabot>  ["what","what","what","what","what","what","what","what","what","what","what...
09:50:16 <ddarius> > iterate show "what"
09:50:17 <lambdabot>  ["what","\"what\"","\"\\\"what\\\"\"","\"\\\"\\\\\\\"what\\\\\\\"\\\"\"","\"...
09:50:28 <mauke> > fix show
09:50:29 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
09:50:55 <mauke> mmh, I want a show format for printf
09:51:13 <mauke> printf "%S" "foo" == "\"foo\""
09:51:28 <oerjan> mauke: very difficult
09:51:29 <mauke> printf "%S" [1, 2, 3] == "[1,2,3]"
09:51:33 <mauke> oerjan: existentials
09:51:44 <pjd> like %r in Python
09:51:48 <oerjan> mauke: the problem is that printf dispatches on its own typeclas
09:51:57 <mauke> except that doesn't quite work. hmm.
09:52:07 <oerjan> so you can only have one format per type
09:52:11 <oerjan> iiuc
09:52:42 <mauke> > ""++ printf "%d" (64 :: Int)
09:52:43 <lambdabot>  "64"
09:52:45 <mauke> > ""++ printf "%d" (64 :: Integer)
09:52:46 <oerjan> er, that may not be exactly it
09:52:53 <lambdabot>  "64"
09:52:54 <mauke> > ""++ printf "%d" '@'
09:52:55 <lambdabot>  "64"
09:53:30 <fasta> How to call the element before the last element in English? 
09:53:45 <oerjan> fasta: second to last?
09:53:48 <mauke> penultimate
09:53:54 <fasta> oerjan: right
09:54:00 <mauke> next to last
09:54:12 <fasta> mauke: that's better, I guess
09:54:13 <oerjan> (warning: i am not actually a native english speaker)
09:54:24 <fasta> oerjan: I already checked your whois :)
09:54:28 <shachaf> fasta: The one before that is "antepenultimate". :-)
09:54:47 <mauke> English is so verbose :-)
09:54:55 * wli wonders how he just beat the LogicT TicTacToe demo.
09:55:49 <fasta> mauke: according to the dictionaries I have penultimate is not correct in this meaning 
09:55:57 <mauke> :(
09:56:03 <mauke> why not?
09:56:04 <ddarius> fasta: ?
09:56:18 <fasta> mauke:  Last but one; as, the penultimate syllable, the last syllable
09:56:21 <fasta>      but one of a word.
09:56:21 <Igloo> I think it's fine, although it's not commonly used
09:56:43 <fasta> All entries in all entries seem to imply it has something to do with words
09:56:56 <nik7> [3^a * 5^b * 7^c | a <- [0..], b <- [0..], c <- [0..]]       that's the list I actually want...but how to sort it correct? the first element should be the smallest (1), then 3,5,7,9,15... (yes, the list should be infinite)
09:56:58 <oerjan> "last but one" could be generalized, i assume
09:57:16 <fasta> Hmm, Wordnet doesn't.
09:57:29 <fasta> [syn: {next-to-last}]
09:57:53 <fasta> penultimate is a cool word to obfuscate :)
09:57:56 <mauke> 1.  Next to last.
09:57:59 <ddarius> Yeah, "penultimate" has no particular object it's required to apply to.
09:58:02 <mauke> 2.  # Linguistics. Of or relating to the penult of a word: penultimate stress.
09:58:10 <oerjan> nik7: there is a well-known trick for that, i vaguely recall
09:58:39 <nik7> hmm, well-known? ;)
09:59:23 * wli backs off of LogicT and tries to understand FBackTrack.hs
10:00:19 <oerjan> ah, "Hamming number"
10:02:42 <wli> 7-smooth numbers; Hamming numbers are 5-smooth.
10:02:56 <oerjan> wli: yes, but the same trick ought to work
10:03:33 <wli> I don't remember the trick for Hamming numbers, actually.
10:03:47 <wli> nik7: Priority queue.
10:04:04 <pjd> sequence merging, innit?
10:04:38 <oerjan> http://en.wikipedia.org/wiki/Hamming_numbers#Computation_of_regular_numbers except it's just described in English
10:04:41 <lambdabot> http://tinyurl.com/yuzokt
10:06:00 <hpaste>  Jaffe annotated "(no title)" with "lisp version" at http://hpaste.org/1668#a1
10:06:44 <wli> nik7: Start with 1 in your queue. Iterate the following procedure: dequeue an element x, enqueue 3*x, 5*x, and 7*x, output/return/etc. the number. The queueing should respect ordering/etc.
10:08:52 <oerjan> > let s = 1:foldr1 merge [map (* n) s| n <- [3,5,7]]; merge (x:l1) (y:l2) | x <= y = x:merge l1 (y:l2) | otherwise = y:merge (x:l1) l2 in s
10:09:01 <lambdabot>  [1,3,5,7,9,15,15,21,21,25,27,35,35,45,45,45,49,63,63,63,75,75,75,81,105,105,...
10:09:11 <oerjan> eek
10:09:16 <ddarius> Not quite.
10:09:23 <SamB> heh
10:09:29 <wli> Yeah, there will be some trouble there.
10:09:39 <SamB> DrIFT used to be called Derive ;-)
10:10:16 <hpaste>  Jaffe annotated "(no title)" with "replicate, lisp version" at http://hpaste.org/1668#a2
10:11:03 <oerjan> > let s = 1:foldr1 merge [map (* n) s| n <- [3,5,7]]; merge (x:l1) (y:l2) | x < y = x:merge l1 (y:l2) | x > y = y:merge (x:l1) l2 | otherwise = x:merge l1 l2 in s
10:11:05 <lambdabot>  [1,3,5,7,9,15,21,25,27,35,45,49,63,75,81,105,125,135,147,175,189,225,243,245...
10:15:16 <fasta> @pl bar f g = fmap f .  g
10:15:17 <lambdabot> bar = (.) . fmap
10:15:36 <fasta> @pl  fmap f .  g
10:15:36 <lambdabot> fmap f . g
10:16:02 <fasta> Isn't there a combinator that captures that pattern?
10:16:03 <SamB> @hoogle Monad m => (a -> m b) -> (b -> m c) -> a -> m c
10:16:04 <lambdabot> Prelude.(.) :: (b -> c) -> (a -> b) -> a -> c
10:16:04 <lambdabot> Control.Parallel.Strategies.(-|) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
10:16:04 <lambdabot> Control.Parallel.Strategies.(-||) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
10:16:57 <SamB> @djinn Monad m => (a -> m b) -> (b -> m c) -> a -> m c
10:16:57 <lambdabot> Cannot parse command
10:16:57 <lambdabot> Cannot parse command
10:17:06 <SamB> @djinn f :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
10:17:06 <lambdabot> Cannot parse command
10:17:06 <lambdabot> Cannot parse command
10:17:12 <SamB> aww.
10:18:43 <oerjan> :t (>>>)
10:18:45 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
10:18:48 <wli> I think xs = [1,3,5,7] ++ merge3 (map (3*) xs) (map (5*) xs) (map (7*) xs) ; merge3 (x:xs) (y:ys) (z:zs) | x < y && x < z = x : merge3 xs (y:ys) (z:zs) | y < x && y < z = y : merge3 (x:xs) ys (z:zs) | otherwise = z : merge3 (x:xs) (y:ys) zs might do.
10:19:39 <oerjan> wli: you didn't see my correction?
10:19:57 <wli> oerjan: No, I was looking elsewhere.
10:20:22 <wli> oerjan: Plus someone used lambdabot to spam the channel.
10:22:01 <ddarius> (>>>) kind of does it via the Kleisli arrow.
10:22:23 <xerox> fasta, that's Kleisli composition, dons added it to control.monad I think under the name of (>=>)
10:22:41 <ddarius> :t (>=>)
10:22:44 <lambdabot> Not in scope: `>=>'
10:23:11 <xerox> http://osdir.com/ml/lang.haskell.cvs.libraries/2007-01/msg00102.html
10:23:14 <lambdabot> Title: patch applied (packages/base): Add Kleisli composition, http://tinyurl.com/2mkp8d
10:23:18 <fasta> xerox: that appears to be something else. 
10:23:38 <fasta> :t fmap f .  g
10:23:39 <lambdabot> Not in scope: `f'
10:23:39 <lambdabot>  
10:23:39 <lambdabot> <interactive>:1:10: Not in scope: `g'
10:23:49 <fasta> :t \f g -> fmap f .  g
10:23:51 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (a -> b) -> (a1 -> f a) -> a1 -> f b
10:26:20 <ddarius> :t fmap g $ fmap f
10:26:22 <lambdabot> Not in scope: `g'
10:26:22 <lambdabot>  
10:26:22 <lambdabot> <interactive>:1:14: Not in scope: `f'
10:26:28 <ddarius> :t \f g -> fmap g $ fmap f
10:26:30 <lambdabot> forall b a b1 (f :: * -> *). (Functor f) => (a -> b1) -> (f b1 -> b) -> f a -> b
10:27:21 <ddarius> Hmm, that seems backwards.
10:27:48 <ddarius> :t fmap . fmap
10:27:50 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
10:28:01 <wli> Duplicates.
10:28:13 <ddarius> There you go fasta
10:31:13 <wli> xs = [3,5,7] ++ merge3 (map (3*) xs) (map (5*) xs) (map (7*) xs) ; merge3 (x:xs) (y:ys) (z:zs) | x < y && x < z = x : merge3 xs (y:ys) (z:zs) | y < x && y < z = y : merge3 (x:xs) ys (z:zs) | z < x && z < y = z : merge3 (x:xs) (y:ys) zs | x == y && x < z = x : merge3 xs ys (z:zs) | x == z && x < y = x : merge3 xs (y:ys) zs | y == z && y < x = y : merge3 (x:xs) ys zs | x == y && y == z = merge3 xs ys zs
10:32:13 <wli> composing the binary merge was a better idea.
10:32:54 <fasta> ddarius: but lambdabot already came up with (.) . fmap
10:33:05 <fasta> ddarius: and I was asking for some name
10:33:25 <fasta> ddarius: but it has an importance of next to zero, so never mind.
10:33:41 <wli> There's probably a useful mergeN somewhere.
10:33:50 <ddarius> I don't believe there is a name for it anywhere.
10:34:03 <ddarius> I.e. I don't believe it is something that is usually named.
10:34:24 <ddarius> @hoogle mergeN
10:34:24 <lambdabot> No matches found
10:35:21 <eventualbuddha> how do i measure how long haskell takes to execute a statement?
10:36:49 <xerox> eventualbuddha, you can try :set +s in GHCi
10:36:59 <eventualbuddha> xerox: what does that do?
10:37:21 <xerox> eventualbuddha, it gives you statistics about expression evaluation
10:37:26 <eventualbuddha> ah, nifty
10:37:28 <eventualbuddha> thanks xerox 
10:37:37 <xerox> there's also http://www.haskell.org/haskellwiki/Timing_computations
10:37:38 <lambdabot> Title: Timing computations - HaskellWiki
10:37:40 <eventualbuddha> wow, so the ruby version was faster
10:37:41 <xerox> you're welcome
10:38:01 <fasta> eventualbuddha: that's unlikely
10:38:11 <eventualbuddha> fasta: well, neither are particularly optimized
10:38:24 <fasta> eventualbuddha: did you compile the Haskell code?
10:38:31 <fasta> eventualbuddha: or just interpreted it?
10:38:31 <eventualbuddha> fasta: no. ghci
10:38:39 <fasta> eventualbuddha: then you shouldn't claim that.
10:42:50 <eventualbuddha> fasta: alright, compiling it drops it from 1.49s to 0.159
10:42:58 <wli> mergeN xss = let (xs':xss') = sortBy ((. head) . compare . head) xss in head xs' : mergeN ((tail xs') : map (\ys -> if head ys == head xs' then tail ys else ys) xss') ; humble = 1 : mergeN (zipWith (map . (*)) [3,5,7] (repeat humble))
10:44:50 <nik7> thx
10:46:12 <xerox> (yuck 16297 patches in d.h.o/ghc! switching to --partial ...)
10:52:19 <jfredett> hmm... is there a way to have a constraint on the whether a given typeclass implementation is valid? eg
10:52:19 <jfredett> class (Ord a, HasZero a) => Foo a where
10:52:19 <jfredett>     fizzle :: a -> a -> a
10:52:19 <jfredett>     fuzz :: a -> a -> a -> a
10:52:19 <jfredett>     -- MRD = fizzle
10:52:19 <jfredett>     fuzz x y z = fizzle (fizzle x y) z
10:52:21 <jfredett>     -- Requirements
10:52:23 <jfredett>     fizzle _ _  >= zero
10:52:25 <jfredett> where HasZero implies that the type has a zero
10:52:27 <jfredett>     
10:52:29 <jfredett>      
10:52:31 <jfredett> ?
10:52:34 <jfredett> i probably should have just pasted that
10:52:50 * mrd = fizzle
10:53:19 <jfredett> lol, MRD = Minimume requisite definition, but okay fizzle, yah.
10:53:24 <kpreid> jfredett: no, nothing that the compiler will check for tu
10:53:27 <kpreid> s/tu/you/
10:53:32 <jfredett> damn
10:53:36 <jfredett> that would be nifty
10:53:41 <EvilTerran> jfredett, not really, afaik. i think the "done thing" is to express the conditions as a quickcheck doodad
10:53:45 <mrd> perhaps you want a dependent type system?
10:53:49 <kpreid> it'd be halting-equivalent too :)
10:53:55 <kpreid> (I think)
10:54:16 <jfredett> kpreid: ahh, your right
10:54:25 <jfredett> no guarentee fizzle would halt. hmm
10:54:27 <kpreid> well.
10:54:46 <kpreid> it *could* insert a postcondition check into every use of fizzle...
10:55:04 <oerjan> jfredett: sounds like you want the language edwardk is making :)
10:55:10 <jfredett> ?
10:55:12 <jfredett> wheres that?
10:55:30 <jfredett> I just thought it'd be handy, for instance, in defining the naturals
10:55:36 <oerjan> er, i don't remember
10:55:55 <jfredett> defining a kind of num typeclass that "knows" that its instances are > 0
10:56:28 <EvilTerran> to elaborate, i think one would add a fooProperty :: Foo a => a -> Bool, and trust people to check their Foo instances against it
10:57:00 <jfredett> yeh. EvilTerran, I suppose that would work
10:57:09 <wli> Well...
10:57:30 <wli> Generally these things are viewed as generators of an initial algebra.
10:57:54 <wli> These properties essentially explicitly inform things of relations.
10:58:19 <jfredett> wli: whoa... wtf is an initial algebra? *runs to wikipedia
10:58:35 <wli> jfredett: Remember the slogan "no junk, no confusion."
10:59:24 <wli> jfredett: The "initial" bit means that it has a minimality about it (no junk), but it also has some sufficiency (no confusion).
10:59:35 <jfredett> nifty.
11:00:11 <wli> jfredett: I don't understand these things well myself.
11:00:50 <jfredett> i all those category theory books I ordered came.
11:00:51 <jfredett> :/
11:01:07 * ddarius wishes the one category theory book he ordered had come.
11:01:08 <EvilTerran> data Digits = D0 | D1 | ... | D9; data Natural = Zero | Digit :. Natural -- :D
11:01:24 <EvilTerran> s/Digits/Digit/
11:01:28 <xerox> ddarius, which one?
11:01:30 <wli> EvilTerran: Looking at Oleg's page on type-level arithmetic?
11:01:33 <ddarius> type Natural = [Digits[
11:01:41 <jfredett> EvilTerran: data Nat = Z | S Nat
11:02:17 <ddarius> jfredett: But that's unary
11:02:20 <wli> jfredett: I usually use Z as a shorter synonym for Integer
11:02:29 <jfredett> I use ZZ
11:02:31 <oerjan> EvilTerran: that has several representations of 0
11:02:33 <ddarius> wli: Different namespace
11:02:45 <wli> data Nat = Zero | TwoNPlusOne Nat | TwoNPlusTwo Nat deriving (Eq, Ord, Read, Show)
11:02:58 <EvilTerran> ddarius, well, yes. wli, no, i wasn't quite thinking of type-level, but i guess it's drifting that way. jfredett, that's all well-and-good, but it makes toEnum and fromEnum linear instead of logarithmic time
11:03:16 <EvilTerran> oerjan, yeah, so does IEEE floating point
11:03:17 <jfredett> yeh. :/
11:03:40 <wli> EvilTerran: http://okmij.org/ftp/Haskell/number-parameterized-types.html
11:03:41 <lambdabot> Title: Haskell Programming: Types that depend on numbers
11:04:56 <wli> If you have types that depend on numbers, maybe you can have types that depend on polynomials with integer coefficients.
11:05:38 <wli> Burning question: where are all the priority queue data structure libs?
11:06:14 <Saizan> Data.Sequence can be used as one
11:06:32 <EvilTerran> wli, looks interesting, thanks.
11:06:47 <wli> EvilTerran: Also http://www.haskell.org/tmrwiki/NumberParamTypes
11:06:48 <lambdabot> Title: NumberParamTypes - TmrWiki
11:09:38 <mruna1> hello
11:10:33 <shapr> Complete lack of interest!
11:10:44 <oerjan> or patience
11:10:57 <sjanssen> Saizan: how can you use Data.Sequence as a PQ?
11:11:15 <wli> Saizan: I'm interested in hearing about it if so.
11:12:02 <sjanssen> wli: Data.Map or Data.Set can work as rudimentary PQs
11:12:47 <Saizan> ah, no, i was confusing it with a general finger tree
11:13:06 <sjanssen> wli: also see Edison
11:13:09 <sjanssen> @hackage edison
11:13:09 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/edison
11:13:20 <sjanssen> wha?  it isn't on Hackage?
11:13:36 <Saizan> @hackage Edison
11:13:36 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Edison
11:14:11 <sjanssen> oh, the package names are a bit different
11:14:17 <wli> 404
11:14:18 <sjanssen> @hackage EdisonAPI
11:14:18 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/EdisonAPI
11:14:22 <sjanssen> @hackage EdisonCore
11:14:22 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/EdisonCore
11:15:58 <fasta> Regarding priority queues: I think it would be a good thing to have a library that exports such a type and presents it as such.
11:18:22 * wli sees a Data.Relation library.
11:18:36 <wli> dogslow website, though
11:20:05 <wli> Edison appears to have what I'm looking for.
11:20:20 <EvilTerran> by the by, someone was asking about having a tree data structure with cycleless-ness enforced statically. i think the ideas in those Oleg articles wli linked a few minutes ago may lend themselves to that
11:20:33 <EvilTerran> (i think this was asked yesterday)
11:22:25 <ddarius> xerox: "Categories for the Working Mathematician" by the wa
11:23:51 <wli> Dead link. =(
11:25:23 <olsner> is there a standard function for reading integers in a specific base?
11:25:55 <ddarius> @hoogle readBase
11:25:55 <lambdabot> No matches found
11:25:59 <ddarius> @hoogle base
11:25:59 <lambdabot> Text.Html.base :: String -> HtmlAttr
11:25:59 <lambdabot> Test.HUnit.Base :: module
11:25:59 <lambdabot> Text.Html.basefont :: Html
11:26:04 <ddarius> @hoogle read
11:26:05 <lambdabot> Prelude.read :: Read a => String -> a
11:26:05 <lambdabot> Text.Read :: module
11:26:05 <lambdabot> Prelude.Read :: class Read a
11:26:08 <EvilTerran> @where coverage condition
11:26:09 <lambdabot> I know nothing about coverage.
11:26:17 <ddarius> olsner: Surely
11:26:34 <oerjan> :t readInt
11:26:36 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
11:26:39 <EvilTerran> > read "0xFF" :: Integer
11:26:40 <lambdabot>  255
11:26:55 <EvilTerran> > read "0b1111" :: Integer
11:26:56 <lambdabot>  Exception: Prelude.read: no parse
11:26:59 <EvilTerran> hm.
11:27:01 <olsner> @docs readInt
11:27:02 <lambdabot> readInt not available
11:27:12 <olsner> @info readInt
11:27:12 <lambdabot> readInt
11:27:22 <oerjan> @index readInt
11:27:22 <lambdabot> Numeric
11:28:02 <olsner> ah! found readHex in the Numeric module
11:28:14 <olsner> > readHex "100"
11:28:15 <ddarius> readInt is also in the Numeric module
11:28:16 <lambdabot>  [(256,"")]
11:28:23 <ddarius> And a few read<Base>
11:28:27 <ddarius> But readInt is the general one.
11:28:34 <shapr> > readBase  7 "123"
11:28:35 <lambdabot>   Not in scope: `readBase'
11:28:40 <ddarius> Overly general
11:28:48 <shapr> :t readInt
11:28:49 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
11:29:56 <olsner> then I'd have to write readInt 16 isHexDigit hexDigitToInt string, where isHexDigit and hexDigitToInt afaics are functions i'd have to write
11:30:24 <ddarius> olsner: Indeed, simple functions.  Obviously, for just Hex use readHex.
11:30:42 <oerjan> actually, Data.Char.digitToInt does hex as well
11:30:51 <olsner> readHex is more convenient in this particular case... I'm only trying to read hexadecimal, so my question was overly generic ;-)
11:31:41 <mauke> > readInt 16 isHexDigit digitToInt "ff"
11:31:43 <lambdabot>  [(255,"")]
11:31:44 <ddarius> readInt is an impressive little machination I wasn't aware of
11:32:21 <olsner> > readInt 10 isDigit digitToInt "ff"
11:32:22 <lambdabot>  []
11:32:34 <olsner> > readInt 10 isDigit digitToInt "ff 100 30"
11:32:36 <lambdabot>  []
11:32:55 <olsner> why is it returning a list?
11:33:01 <ddarius> That means no parse
11:33:10 <ddarius> :t reads
11:33:12 <lambdabot> forall a. (Read a) => String -> [(a, String)]
11:33:29 <ddarius> It returns a list of possible parses and the remaining input
11:33:38 <ddarius> :t readHex
11:33:40 <lambdabot> forall a. (Num a) => String -> [(a, String)]
11:34:48 <mauke> are there any Read instances that actually return more than one parse?
11:36:00 <wli> mauke: The bit that annoys me about read is that it's not monadic at all, so there's no obvious error checking apart from catch
11:36:15 <olsner> :t readM
11:36:17 <lambdabot> Not in scope: `readM'
11:36:43 <dynamix>  /msg NickServ IDENTIFY neelugr8
11:37:09 <mauke> readM :: (Read a, MonadPlus m) => String -> m (a, String)
11:37:22 <Olathe> dynamix: Ehh ?
11:37:23 <ddarius> mauke: I don't think there are complete instances, but you can use ++ to alternate
11:37:28 <wli> mauke: That looks new.
11:37:40 <mauke> ddarius: huh?
11:37:48 <ddarius> mauke: Ideally, you want the complete parse to be deterministic, but you may backtrack while parsing.
11:37:59 <mauke> ah
11:38:14 <mauke> @type msum . reads
11:38:16 <lambdabot> forall a. (MonadPlus ((,) a), Read a) => String -> (a, String)
11:38:41 <xerox> wli, http://cgi.cse.unsw.edu.au/~dons/blog/2007/03 here's a nifty readM
11:38:42 <lambdabot> Title: Haskell hacking
11:38:45 <mauke> @type msum . map return . reads
11:38:47 <lambdabot> forall (m :: * -> *) a. (MonadPlus m, Read a) => String -> m (a, String)
11:38:51 <dynamix> Olathe:  i need to get  used to irc..
11:39:25 <oerjan> dynamix: you also need to change your password
11:39:37 <dynamix>  just did
11:39:50 <dynamix> just need to remember
11:40:51 <dynamix> any way teh reason i came here now, is .. What is the colour of haskell ?
11:40:58 <ddarius> Blue
11:41:06 <dynamix> why ?
11:41:17 <ddarius> Because I just arbitrarily said that right now.
11:41:23 <dynamix> :) .
11:41:35 <dynamix> generally ruby red is associated with Ruby
11:41:41 <dynamix> Green with Python etc.
11:41:45 <dynamix> well not etc.
11:42:07 <ddarius> The color of C, C++, C#, Java, D, Scheme, CL, Smalltalk?
11:42:08 <bitwiseshiftleft> the haskell logo is purple and green
11:42:13 <bitwiseshiftleft> kind of barney-esque
11:42:18 <ddarius> It's kind of a teal
11:42:25 <eventualbuddha> ddarius: no, it's because you're a monty python fan (either that or i'm just projecting)
11:43:11 <SamB> blue does seem like a good color for Haskell for some reason...
11:43:12 <fasta> Is it just me or is Hoogle completely _inaccurate_?
11:43:17 <SamB> oh.
11:43:32 <SamB> haskell.org's icon is a navy blue lambda
11:43:45 <dynamix> yeah
11:43:55 <fasta> How does Hoogle work internally?
11:44:00 <dynamix> where is the haskell logo in purple and green?
11:44:02 <ddarius> Ask ndm
11:44:06 <ddarius> haskell.org
11:44:07 <oerjan> + much of the website is rather blue but that may just be Wikimedia defaults
11:44:14 <fasta> It seems that it's a bunch of heuristics that only work for newbie Haskell code. 
11:44:17 <SamB> dynamix: go to wiki
11:44:19 <ddarius> oerjan: The docs are rather blue to
11:44:21 <SamB> look in upper left
11:44:21 <cdsmith> fasta: I haven't found hoogle terribly useful either.
11:44:28 <cdsmith> fasta: Even as a newbie
11:44:35 <SamB> I believe we want a new logo?
11:44:36 <dynamix> the top left lambda on a green disck ?
11:44:37 <kpreid> fasta: it prefers to give irrelevant results than no results, but it prioritizes relevant ones
11:44:58 <oerjan> blue _is_ the color of cool logic, isn't it? :)
11:45:02 <ddarius> fasta: I think there's a better Hoogle made or almost done, but not hooked to lambdabot yet.
11:45:05 <kpreid> fasta: so, yes, the list is often full of irrelevant things
11:45:09 <fasta> E.g. do this query on hoogle:  f a -> f (m a)
11:45:19 <ddarius> @hoogle f a -> f (m a)
11:45:19 <dynamix> i was just setting up a blog and felt i want it to have the same color as haskell :) .. 
11:45:20 <lambdabot> Prelude.id :: a -> a
11:45:20 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
11:45:20 <lambdabot> Prelude.asTypeOf :: a -> a -> a
11:45:21 <SamB> I think hoogle might be better if you could say "don't look in package foo"
11:45:27 <fasta> ddarius: where? 
11:45:58 <SamB> but in any case the web interface is better than the lambdabot one...
11:45:59 * wli tries to remember how to do the analogue of Guassian elimination for integer equations.
11:46:04 <EvilTerran> did Curry have a professed faviourite colour?
11:46:21 <EvilTerran> (well, spelling "faviourite" correctly, of course =P) )
11:46:22 <Saizan> fasta: ndm is working on hoogle 4, with new and improved type unification
11:46:25 <ddarius> fasta: ndm was working on Hoogle 4, but he's likely distracted by other things currently.
11:46:35 <EvilTerran> @quote stereo
11:46:35 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
11:46:59 <fasta> Saizan: ok, well, I wouldn't even have dared to release Hoogle 3. 
11:47:30 <SamB> wli: hmm. Gaussian elimination doesn't work for you?
11:48:00 <HairyDude> ok... how do I figure out (in the context of Data.Generics) where a type constructor's arguments are used?
11:48:01 <Saizan> fasta: http://neilmitchell.blogspot.com/2007/04/hoogle-4-type-matching.html
11:48:01 <ddarius> fasta: It's good when you match the type exactly, but when there is no match it flails about wildly trying to figure out what you actually wanted.
11:48:03 <lambdabot> Title: Neil Mitchell's Haskell Blog: Hoogle 4 type matching, http://tinyurl.com/2ljml5
11:48:08 <SamB> wli: I tried to do that once
11:48:53 <SamB> I was trying to convert blacknot problems into a bunch of equations and inequalities
11:49:00 <SamB> and solve them...
11:49:09 <SamB> it didn't work out so well
11:51:01 <HairyDude> I can fetch the constructors out of a DataType, but can't see what their types are
11:51:09 <wli> The Geometric Algorithms link says it's got K-D trees.
11:51:09 <SamB> Tim Chevalier has an odd nickname...
11:53:09 <bos> @seen chessguy
11:53:09 <lambdabot> I saw chessguy leaving #haskell and #happs 1d 15h 7m 43s ago, and .
11:59:34 <bitwiseshiftleft> question: is there a way to have typed dictionaries in haskell?
11:59:37 <bitwiseshiftleft> by which i mean
11:59:48 <bitwiseshiftleft> have a type Dict, and a type Key a
12:00:07 <wli> bitwiseshiftleft: import Data.Map
12:00:10 <bitwiseshiftleft> with accessors like lookup :: Monad m => Key a -> Dict -> m a
12:00:42 <mauke> Key a? what's that supposed to do?
12:00:54 <bitwiseshiftleft> it's a unique key for looking up values of type a
12:00:58 <HairyDude> it'd have to be Dict a, surely
12:01:02 <bitwiseshiftleft> why?
12:01:11 <HairyDude> what is a?
12:01:15 <basti_> bitwiseshiftleft: i don't think your type is right, but just put an existential type inside a map, and you'll be able to put data of different types into that.
12:01:34 <basti_> i guess he wants to store data of different types in his map
12:01:38 <bitwiseshiftleft> basti_: ah.  yeah, i'll try something like that
12:01:50 <bitwiseshiftleft> yes, to store data of different type, and the type is determined by a key
12:02:12 <fasta> Why would you want that?
12:02:22 <basti_> (what you describe is actually a collection of maps of different types)
12:02:40 <bitwiseshiftleft> it's so that objects in a system can save per-transaction data, and the data will be put in the transaction object
12:02:52 <bitwiseshiftleft> and when the transaction is done, it will be GCed
12:02:53 <basti_> ?
12:02:59 <fasta> basti_: very clear
12:03:03 <fasta> bitwiseshiftleft: very clear
12:03:10 <basti_> lol
12:03:29 <fasta> bitwiseshiftleft: I so totally understand what you are talking about.
12:03:41 <SamB> does anyone know what the license was for Strafunski?
12:03:46 <mrd>  linux
12:03:47 <mrd> oops
12:03:48 <basti_> fasta: are you being ironic?
12:03:51 <ddarius> bitwiseshiftleft: Yes and no.
12:04:13 <fasta> basti_: I will use another style figure: what do you think?
12:04:47 <basti_> fasta: i think what bitwiseshiftleft has in mind is a valid request, yet the formulation gives room for fantasy
12:04:59 <bitwiseshiftleft> aight.  so to be clear, i'm working on a system which uses transactions, and much of the data is only valid within a transaction.  so when the transaction ends, it should be freed/garbage collected
12:05:04 <basti_> personally, i believe, bitwiseshiftleft wants to put different types in a single map
12:05:06 <bitwiseshiftleft> so it makes sense to store it in the transaction object
12:05:16 <purplepenguins> hmm
12:05:33 <basti_> bitwiseshiftleft: are those "transactions" unifiable as a single datatype?
12:05:34 <purplepenguins> so is a <- b equivalent to b -> a
12:05:37 <bitwiseshiftleft> basti_: exactly.  but with the (unique) key having the type associated
12:06:02 <bitwiseshiftleft> basti_: yes
12:06:14 <ddarius> purplepenguins: What are you talking about?  And the answer is almost certainly that that doesn't even make sense.
12:06:27 <basti_> bitwiseshiftleft: so what is the problem of putting all transactions into one map?
12:06:48 <basti_> (they're all one type)
12:06:52 <bitwiseshiftleft> oh, sorry
12:06:55 <bitwiseshiftleft> the transaction has one type
12:07:03 <purplepenguins> I mean, when you write, say, (a,b) <- somefunction, does that mean that (a,b) is taken from the output of somefunction
12:07:14 <bitwiseshiftleft> but each object's transaction-specific data may have a different type
12:07:19 <mauke> purplepenguins: you mean in a do block?
12:07:30 <purplepenguins> I suppose?
12:07:47 <mauke> then it's syntactic sugar for somefunction >>= \(a,b) -> ...
12:07:50 <purplepenguins> I'm reading an introduction to haskell and they threw that notation out there without explaining where it came from
12:07:51 <oerjan> purplepenguins: (a,b) <- somefunction is roughly the same as somefunction >>= \(a,b) ->
12:07:52 <bitwiseshiftleft> purplepenguins: in that case, no, a <- b is very different from b -> a
12:08:00 <basti_> bitwiseshiftleft: you mean, just like in IORefs, of which "transactions" are all of type IO ()?
12:08:37 <oerjan> (it gets more complicated if the pattern match can fail)
12:08:38 <bitwiseshiftleft> basti_: yes and no?
12:09:17 <basti_> bitwiseshiftleft: i'm trying to talk you out of the idea that an operation on data of type a needs to be of type a
12:09:32 <basti_> it might well be of type () or any other type, if you define it the right way.
12:09:42 <bitwiseshiftleft> oh, right
12:09:58 <bitwiseshiftleft> except that you have to get an a out at some point
12:09:59 <basti_> (i see transactions, loosely and without definition, as "operation on data of type a")
12:10:24 <basti_> this is true.
12:11:02 <basti_> you might define an operation that returns Either (Int,Char), depending on the arguments you give it
12:11:31 <bitwiseshiftleft> i guess the best way to say it is, i need to write something that's like an ioref a, except that it stores a different value for each transaction in progress, and doesn't leak memory from completed transactions
12:11:42 <basti_> extracting one of the stored variables in a process that is not understood by the haskell type system
12:11:50 <basti_> you could still use several maps
12:11:55 <basti_> trivially
12:12:02 <basti_> one for Char, one for Int etc.
12:12:08 <bitwiseshiftleft> uh.  this is in a library
12:12:16 <basti_> (s/Char/Yourcomplicatedtype)
12:12:31 <basti_> yes there is a hashtable library
12:12:57 <bitwiseshiftleft> not so much.  the user of the library can create values of type MyComplicatedType b for any b.  i can't have a separate hash table for each b
12:13:03 <bitwiseshiftleft> since you just can't do that in haskell
12:13:05 <kpreid> bitwiseshiftleft: if these types are all Typeable then you can use a (Map Data.Typeable.TypeRep Data.Dynamic.Dynamic)
12:13:16 <bitwiseshiftleft> they aren't.  for ANY b.
12:13:29 <kpreid> if you can constrain your problem you might be able to use an existential type
12:13:32 <bitwiseshiftleft> i'm thinking i'll have to use the evil unsafeCoerce
12:13:33 <basti_> there are dynamic types, yes.
12:13:48 <basti_> and also, there are existential types
12:14:06 <oerjan> bitwiseshiftleft: can you make it continuation-based?  Then you can pair each transaction with something of form b -> m () in an existential type
12:14:33 <bitwiseshiftleft> oerjan: i'm not sure how that helps?
12:14:53 <basti_> well, all m () are equal, i guess ^^
12:15:04 <oerjan> bitwiseshiftleft: that way b doesn't have to escape from the type
12:15:33 <mdmkolbe|ubuntu> @where flags
12:15:34 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html
12:15:37 <bitwiseshiftleft> it doesn't have to anyway, with existentials
12:15:41 <oerjan> the something is whatever takes control afterwards.
12:16:07 <oerjan> bitwiseshiftleft: the problem is getting it typesafe with existentials
12:16:48 <bitwiseshiftleft> i'm not convinced that it can be typesafe
12:16:53 <mdmkolbe|ubuntu> where do I find the RTS flag documentation?  It doesn't seem to be in the same place as the other flags.  (I'm looking for the switches that control stack size.)
12:16:59 <basti_> actually not, the compiler forces you to be typesafe.
12:17:08 <basti_> the problem is making it do what you want while being typesafe );
12:17:33 <bitwiseshiftleft> well, strictly speaking, there is this function unsafeCoerce#
12:17:44 <bitwiseshiftleft> which i don't want to use
12:17:45 <bitwiseshiftleft> but it exists
12:18:00 <bitwiseshiftleft> and has type (approximately) a -> b
12:18:12 <ddarius> Making such a thing was discussed years ago in a conversation on implementing ST purely.
12:18:23 <mdmkolbe|ubuntu> what are you trying to write with existentials?
12:18:25 <ddarius> The upshot is to have a fully polymorphic type, you'd have to use unsafeCoerce
12:18:38 <bitwiseshiftleft> yeah, it's a lot like ST.
12:18:40 <bitwiseshiftleft> hm
12:19:16 <ddarius> @google site:haskell.org "Tim Sweeney"
12:19:18 <lambdabot> http://www.haskell.org/pipermail/haskell/2003-June/011980.html
12:19:18 <lambdabot> Title: Safe and sound STRef [Was Implementing RefMonads in Haskell without ST,IO]
12:21:00 <bitwiseshiftleft> hm
12:21:03 <bitwiseshiftleft> oh well
12:21:52 <FalconNL> ewbie question: suppose I define "data Vector = Vector Float Float Float deriving (Eq, Show)" and a Vector "test = Vector 2.0 3.0 5.0". How would I then access the three values of that vector? (Or is this thinking too much like a normal OO language and should I just use a list?)
12:21:56 <SamB> here's a lame attempt to cabalize (and heirarchicalize) StrategyLib 4.0: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/StrategyLib-4.0.0.0
12:22:11 <mauke> FalconNL: pattern matching
12:22:22 <mauke> FalconNL: you could write helper functions, of course
12:22:54 <ddarius> Or use record notation 
12:23:09 <mauke> same thing :-)
12:23:32 <ddarius> Record notation writes the helper functions for you (and allows another style of pattern matching)
12:23:50 <hughperkins> Hi, how can I display the fractions of a second of a datediff?
12:23:51 <ddarius> And changes the Show instance\
12:24:08 <SamB> FalconNL: as a side note, usually when we define that datatype we put a ! before each Float
12:24:22 <ddarius> FalconNL: "Using lists (for everything)" is not an FP attribute
12:24:26 <hughperkins> I'm substracting two clockTimes to get a TimeDiff, but the picoseconds is negative???
12:24:35 <FalconNL> What's the ! for?
12:25:21 <bitwiseshiftleft> FalconNL: it makes the object strict
12:26:03 <bitwiseshiftleft> meaning that the underlying Floats have to be fully computed before the Vector can exist
12:26:15 <hpaste>  mauke pasted "Dict, Key a, etc" at http://hpaste.org/1676
12:26:28 <mauke> my first use of Typeable :-)
12:27:05 <bitwiseshiftleft> mauke: cool.  although i'm not looking for a to be typeable.  but i'm intending to do something like that
12:28:31 <SamB> bitwiseshiftleft: hmm. I'd like to see a partially computed Float...
12:29:13 <bitwiseshiftleft> SamB: i mean, like, a thunk of a float
12:29:47 <SamB> well, I'm just sitting here and thinking of *half* of the float being computed ;-)
12:31:36 <rindolf> Hi all.
12:31:42 <SamB> rindolf: hello
12:31:46 <rindolf> Hi SamB 
12:32:00 <rindolf> How do I calculate an integer power in Haskell? Like a**b.
12:32:11 <SamB> a^b
12:32:17 <kpreid> @type (^)
12:32:19 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
12:32:21 <kpreid> @type (^^)
12:32:23 <ddarius> SamB: I don't believe the Report requires Float to be IEEE 754.
12:32:23 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
12:32:24 <kpreid> @type (**)
12:32:26 <lambdabot> forall a. (Floating a) => a -> a -> a
12:32:29 <rindolf> Oh **
12:32:38 <kpreid> pick your exponentiator
12:32:44 <kpreid> ^ is probably what you want
12:32:45 <ddarius> ($)
12:33:00 <rindolf> kpreid: I want it to return an integer.
12:33:20 <FalconNL> Ok, I've converted the Vector declaration to record notation ("data Vector = Vector {x :: !Float, y :: !Float, z :: !Float}"), but I can't seem to find anywhere how to access the fields
12:33:42 <ddarius> let v = Vector 1 2 3 in x v
12:33:54 <tom_> FalconNL: x, y and z are now functions
12:33:59 <ddarius> @oldwiki UsingRecords
12:34:00 <lambdabot> http://www.haskell.org/hawiki/UsingRecords
12:34:03 <kpreid> rindolf: then ^ is your only choice
12:34:10 <tom_> so you can just say "x test" to access field x of the Vector test
12:35:20 <SamB> ddarius: it definately doesn't
12:35:34 <SamB> or almost definately
12:35:51 <SamB> but it does allow you to check...
12:36:27 <hughperkins> Hi
12:36:49 <SamB> hi
12:37:11 <ddarius> join . fmap join == join . join
12:37:33 <hughperkins> Does anyone happen to know how to display the fractions of a second of a datediff?  Presumably one uses tdPicosec, but sometimes the value is negative???
12:37:50 <SamB> hughperkins: wierd!
12:38:11 <oerjan> :t join . fmap join
12:38:13 <lambdabot> forall (m :: * -> *) a. (Monad m, Functor m) => m (m (m a)) -> m a
12:38:18 <oerjan> :t join . join
12:38:20 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m (m a)) -> m a
12:38:21 <hughperkins> Yeah :-)
12:38:34 <campusblo> hi folks im in hugs and getting errors when i try to run map (+) [1..10]
12:38:41 <campusblo> error is as follows ERROR - Cannot find "show" function for:
12:38:41 <campusblo> *** Expression : map (+) (enumFromTo 1 10)
12:38:41 <campusblo> *** Of type    : [Integer -> Integer]
12:38:41 <hughperkins> Ok, I guess that means no-one's tried this before ;-)
12:38:51 <hpaste>  bitwiseshiftlef pasted "Dict a, Key, etc" at http://hpaste.org/1677
12:38:52 <mauke> campusblo: that just means it doesn't know how to print functions
12:38:58 <shachaf> campusblo: Maybe you're looking for a fold?
12:39:05 <ddarius> map (+) [1,2,3] == [(1+),(2+),(3+)]
12:39:14 <shachaf> campusblo: You're making the list [(1+),(2+),...]
12:39:19 <campusblo> oh
12:39:20 <campusblo> ok
12:39:28 <campusblo> lol
12:39:35 <mauke> > map (+) [1,2,3]
12:39:35 <campusblo> well thats not what i wanted to do
12:39:36 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>]
12:39:49 <mauke> > map (+10) [1,2,3]
12:39:50 <lambdabot>  [11,12,13]
12:40:46 <oerjan> > foldl' (+) 0 [1,2,3]
12:40:48 <lambdabot>  6
12:40:56 <campusblo> ok thanks
12:41:24 <campusblo> fold (+) [1..5]
12:41:26 <Cale> > sum [1,2,3]
12:41:28 <lambdabot>  6
12:41:38 <Cale> > foldr (+) 0 [1..5]
12:41:39 <lambdabot>  15
12:41:43 <Cale> > foldr1 (+) [1..5]
12:41:44 <lambdabot>  15
12:41:47 <Cale> > foldl1 (+) [1..5]
12:41:49 <lambdabot>  15
12:41:52 <Cale> > foldl (+) 0 [1..5]
12:41:53 <lambdabot>  15
12:41:54 <campusblo> cale how come lamdabot does yours and not mine?
12:41:58 <mauke> campusblo: >
12:42:06 <campusblo> ok thanks
12:42:11 <Cale> campusblo: need "> " -- note the space, at the start of your line
12:42:47 <campusblo> foldr (+) [1..5]
12:43:00 * kpreid imagines lambdabot evaluating everything without prefix and only responding if the result wasn't an error
12:43:02 <campusblo> oh ok i se now
12:43:12 <campusblo> >foldr (+) [1..5]
12:43:21 <campusblo> > foldr (+) [1..5]
12:43:22 <lambdabot>   add an instance declaration for (Num [t])
12:43:57 <Cale> foldr takes three parameters: what to replace (:) with, what to replace [] with, and a list
12:44:11 <campusblo> yeh i realized that after i typed it. thanks
12:44:20 <campusblo> or i should say after i got the error i remembered
12:44:36 <campusblo>  > foldl (+) 0 [1..5]
12:44:52 <campusblo> > foldl (+) 0 [1..5]
12:44:53 <lambdabot>  15
12:44:54 <DRMacIver> Hm. The cafe really is chatty, isn't it?
12:45:05 <DRMacIver> (In the sense of volume rather than content)
12:45:19 <ddarius> The past few weeks or so, yes.
12:45:21 <shachaf> DRMacIver: I guess they want to keep the "wave" going up. :-)
12:46:40 <DRMacIver> ddarius: It was pretty chatty last time I subscribed as well, although I've no real sense of the relative volumes.
12:47:05 <fasta> If you don't have a client that has a concept of threads it's a nightmare.
12:47:16 <hughperkins> migrate to use phpbb???
12:47:28 <fasta> hughperkins: ....
12:47:30 <ddarius> DRMacIver: When was last time?
12:47:34 <Cale> I've gone from not looking at most of it to not looking at most of it. I suspect I reached the point where I couldn't bear to read it all long before everyone else :)
12:47:42 <fasta> hughperkins: if you had read that thread you wouldn't say that
12:47:45 <kaol> > map (\x -> x 1) $ map (+) [1,2,3]
12:47:47 <lambdabot>  [2,3,4]
12:47:57 <hughperkins> fasta, which thread?
12:48:02 <fasta> hughperkins: ....
12:48:23 <Cale> phpbb's developers are hilarious. They don't know about 'patch'
12:48:34 <fasta> PHP is hilarious too. 
12:48:38 <hughperkins> Ah yes
12:48:47 <hughperkins> beats gmane tho
12:48:49 <fasta> But that's something about everyone knows here, I guess.
12:49:07 <fasta> I think #haskell has a new troll :)
12:49:10 <Cale> So people contribute patches by making text files telling you what to change, in a standard format.
12:49:11 <hughperkins> I run phpbb for my boards, it works great
12:49:24 <fasta> Cale: :D
12:49:27 <mauke> Cale: wtf
12:49:37 <fasta> hughperkins: sure....
12:49:45 <hughperkins> "sure..."?
12:50:14 <fasta> hughperkins: Let me put it this way: I am sure your website isn't high-profile. 
12:50:36 <fasta> hughperkins: since if it would have been, you would have known why phpbb is another piece of shit. 
12:50:45 <fasta> (like all PHP "software")
12:50:52 <hughperkins> Well, what problems did you have specifically?
12:50:57 <Cale> They recently came up with the idea of making that standard format into an XML language, so they could get programs to carry out most of the steps for them.
12:50:59 <fasta> hughperkins: ....
12:51:09 <fasta> hughperkins: I have zero interest in that discussion
12:51:29 <Cale> http://www.phpbb.com/mods/documentation/?sid=a66c450014f3c835e0648ba65ef73eb3
12:51:31 <lambdabot> Title: phpBB &bull; phpBB Modifications Documentation, http://tinyurl.com/2rnlzv
12:51:32 <kaol> ah. (\x -> x 1) == ($ 1)
12:51:45 <fasta> Cale: That sounds like a April first joke. 
12:51:57 <Cale> fasta: It's not.
12:52:12 <ojacobson> fasta: he's right, I looked.  ewwww.
12:52:31 <Cale> http://www.phpbb.com/mods/documentation/appendix/text-template/index.php#id2831971
12:52:33 <lambdabot> Title: phpBB &bull; 7.2. The Modifications Text Template, http://tinyurl.com/ypc6vf
12:53:21 <DRMacIver> ddarius: I'm not sure exactly. Between 2 and 6 months I think.
12:54:25 <mauke> Cale: http://use.perl.org/~Aristotle/journal/33448
12:54:26 <lambdabot> Title: Journal of Aristotle (5147)
12:54:46 <DRMacIver> Cale: Ouch. :(
12:55:05 <Cale> Like, it started out as a bunch of people sending "how to add this functionality" in arbitrarily formatted text files, and they've gotten more and more sophisticated, but never quite picked up on the fact that diff/patch exists. They still create the patches by hand.
12:55:42 <hughperkins> So you're saying we're better off using gmane?
12:55:49 <Cale> and they call them MODs, for some reason, always in uppercase
12:55:59 <Cale> hughperkins: I just use my mail reader.
12:56:10 <Cale> (specifically gmail)
12:56:12 <hughperkins> very 2007 ;-)
12:56:28 <SamB> hmm. for some reason I was under the impression that MODs were somewhat more... musical
12:56:30 <mauke> hughperkins: btw, could you please stop top-posting?
12:57:21 <hughperkins> Your mail-reader doesnt handle top-posting for you?
12:57:37 <mauke> what do you mean?
12:57:46 <SamB> I almost want to hack PHP just so I can post a MOD that basically consists of a little blurb at the top saying how to run GNU patch on it...
12:57:47 <hughperkins> In gmail it removes all previous text
12:58:00 <SamB> and, of course, a diff-format patch
12:58:23 <mauke> well, it handles it in the sense that I killfile top posters
12:58:23 <ari> Oh, and since we're complaining about people's behaviour on haskell-cafe, could everyone please try to carefully snip away all the irrelevant parts from posts they quote? It really is rather annoying to read the digest when it sometimes consists of a couple of enormous messages... that I've already read
12:58:58 <hughperkins> mauke, ;-)
12:59:26 <basti_> mauke: are you aware that "mauke" means "badly smelling foot" in german?
12:59:26 <ojacobson> SamB, Cale: I wonder if the bulk of the phpbb devs run windows and are therefore unaware of diff/patch because for them it's an external tool...
12:59:30 <SamB> what is "top posting"?
12:59:45 <fasta> SamB: ask wikipedia
12:59:58 <Cale> ojacobson: possibly
12:59:59 <mauke> basti_: http://de.wikipedia.org/wiki/Mauke
13:00:07 <kpreid> SamB: "reply\n\n> entire\n> original\n> message"
13:00:12 <hughperkins> If you hate phpbb so much, why dont you write a new bb in Haskell???
13:00:22 <Cale> hughperkins: I don't like bb's ;)
13:00:30 <basti_> it's slang. i wouldn't expect it to turn up in wikipedia.
13:00:34 <SamB> kpreid: ah, that
13:00:39 <ojacobson> hughperkins: the impression I get is that they don't think the web is an appropriate place for discussion groups, since email and nntp work great already
13:00:51 <mauke> basti_: well, there are five other non-slang meanings :-)
13:00:58 <SamB> I might do that on occasion... though I'm honestly far more likely to do bottom-posting...
13:01:00 <fasta> hughperkins: ??????????????????????????????????????????????????????????????????????????
13:01:00 <hughperkins> Not a very lazy solution though ;-)
13:01:11 <fasta> hughperkins: hint: use one '?'
13:01:28 <basti_> mauke: yep.
13:01:36 <SamB> hughperkins: you don't like gmane?
13:01:43 <int-e> hughperkins: nobody wants to force a single UI on all users.
13:01:48 <hughperkins> You think threading on game works really well?
13:02:01 <hughperkins> s/game/gmane
13:02:06 <fasta> Cale: do you have other nice facts about other communities?
13:02:12 <Cale> hughperkins: You don't have to use gmane either. You can just subscribe.
13:02:12 <SamB> it works okay if people don't use broken mail clients...
13:02:38 <Cale> fasta: Not off hand, I just remember that one because it was so egregiously stupid.
13:02:39 <int-e> hughperkins: in any case nobody is stopping you from creating a bulletin board for haskell, but it won't replace the mailing list in the forseeable future I think
13:02:41 <hughperkins> Well I'm using gmail, youre saying gmail is broken?
13:03:09 <int-e> gmail supports email forwarding and pop3. it's ok.
13:03:11 <SamB> hughperkins: what? you are splitting threads by sending from gmail?
13:03:12 <Cale> gmail is fine
13:03:17 <SamB> I never had any problems with that
13:03:27 <int-e> there's little need to use their UI at all ;)
13:04:06 <SamB> hughperkins: why do you bring up gmail?
13:04:25 <hughperkins> Because its my mail client
13:04:27 <fasta> If someone would make an actual contribution to this discussion, one would make a wiki page with his/her configuration for his/her software
13:04:32 <SamB> well, there are other people
13:05:08 <hughperkins> basically the argument i'm hearing is "mailinglists are fine with an ok mailclient", to which I reply "so youre saying gmail is not an ok mail client?"
13:05:13 <SamB> the people who's mail clients would be imlicated by my statement are those who post the messages that appear at the top of "threads" that should have been subthreads of other threads...
13:05:21 <SamB> er. implicated
13:05:40 <int-e> hughperkins: maybe it's insufficient. it's still your choice to use it or not
13:05:53 <int-e> the mailing list will work for non-gmail users. that's the point
13:05:58 <hughperkins> so what do you recomend? I change t oyahoo jsut to read haskell-cafe?
13:06:09 <int-e> uhm mutt ;-)
13:06:15 <ddarius> I use gmail, but use an email client.
13:06:30 <SamB> hughperkins: I thought you were complaining about gmail breaking threading on gmane?
13:06:41 <hughperkins> Well that's good for you, i'm in a cybercafe, hard to use a mail client ;-)
13:06:47 <Cale> I use gmail directly, are any of my posts getting top-posted?
13:07:07 <hughperkins> No, gmane has no decent threading.  Compare reading a thread on phpbb or vbulletin, against trying to click through a thraed on gmane.
13:07:10 <hughperkins> Theres no comparison...
13:07:21 <int-e> hughperkins: phpbb has no threading
13:07:25 <SamB> hughperkins: oh, use the blog interface then
13:07:32 <int-e> phpbb has threads, and stops there.
13:07:42 <fasta> What a great misunderstanding is going on here.
13:07:51 <SamB> fasta: indeed
13:07:53 <mauke> Cale: huh?
13:08:01 <fasta> I understand the (intentional) misunderstanding.
13:08:05 <Cale> I've only been reading little bits of the conversation.
13:08:13 <Cale> So I'm kind of confused. :)
13:08:16 <SamB> Cale: me too
13:08:23 <hughperkins> SamB? the blog interface?
13:08:32 <SamB> hughperkins: gmane has a blog interface...
13:08:33 <hughperkins> s/?/:/
13:08:38 <fasta> Go to #haskell-overflow
13:08:40 <Cale> I thought the issue was that someone was getting top-posted articles on the haskell-MLs when using GMail?
13:08:49 <SamB> http://blog.gmane.org/gmane.comp.lang.haskell.cafe
13:08:52 <lambdabot> Title: gmane.comp.lang.haskell.cafe
13:09:01 <hughperkins> SamB, ok let me try that...
13:09:21 <mauke> Cale: what definition of "top-posted" are you using?
13:09:22 <SamB> Cale: no. that was a statement of what it sounded like he was trying to say ;-)
13:09:22 <hughperkins> Oh hey, not bad!
13:09:47 <hughperkins> ermmm.. except still no threading? checking...
13:09:51 <SamB> hughperkins: I have no idea why it's not easier to get to from the other interface
13:09:57 <SamB> hughperkins: click on "comments"
13:10:05 <Cale> mauke: An attempt to reply to an existing post results in a non-reply.
13:10:33 <mauke> whoa
13:10:55 <mauke> I've never seen that called top posting
13:11:05 <hughperkins> Well... is there some way to display just the title of each thread, then be able to open just the thread one is interested in?
13:11:48 <SamB> hughperkins: there's an RSS feed as well as some links down the left
13:12:14 <SamB> hughperkins: and you can always write an NNTP client if you still aren't happy
13:13:54 <hughperkins> cant seem to get it to only display thread titles...
13:14:11 <SamB> hughperkins: look at "recent entries" on the left
13:14:23 <_frederik_> what is pseq and why doesn't it seem to be documented?
13:14:40 <edwardk> @src pseq
13:14:41 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
13:14:43 <int-e> @index pseq
13:14:44 <lambdabot> GHC.Conc
13:14:57 <int-e> @type GHC.Conc.pseq
13:14:59 <lambdabot> forall a b. a -> b -> b
13:16:03 <edwardk> pseq x y = x `seq` lazy y, it seems to be seq
13:16:14 <SamB> hughperkins: if you don't like that, find or write an NNTP client that suits your purposes and run it against news.gmane.org
13:16:34 <edwardk>  -- 	Nota Bene: 'pseq' used to be 'seq' -- but 'seq' is now defined in PrelGHC
13:17:07 <_frederik_> edwardk: how do you know this? where is it written?
13:17:23 <ddarius> @source GHC.Conc
13:17:23 <lambdabot> http://darcs.haskell.org/packages/base/GHC/Conc.hs
13:17:25 <shachaf> @goo "Nota Bene: 'pseq' used to be 'seq' -- but 'seq' is now defined in PrelGHC"
13:17:26 <lambdabot> No Result Found.
13:17:43 <_frederik_> Object not found!
13:17:54 <edwardk> fred: its in the source code =)
13:17:59 <Cale> Ah, seq is strict in both its arguments, pseq is strict in only the first, as far as the strictness analyser is concerned.
13:18:06 <shachaf> It's .lhs.
13:18:08 <ddarius> God knows where they're putting that crap.
13:18:37 <Cale> So pseq apparently tricks the strictness analyser so that its first argument will certainly get evaluated first :)
13:18:44 <edwardk> cute
13:19:16 <_frederik_> what about par?
13:19:28 <edwardk> par  x y = case (par# x) of { _ -> lazy y }
13:19:38 <Cale> par x y will spark x to be computed in parallel before resulting in y.
13:20:46 <Cale> That is, it simply indicates to the runtime that it might be worthwhile parallelising the computation of x and y
13:20:52 <_frederik_> how? by forking a new thread? or using worker threads, or what?
13:21:06 <_frederik_> how does ghc do it?
13:21:09 <Cale> Whether they actually get put on separate processors is dependent on resource availability.
13:21:40 <ddarius> It'd be rather impressive if such a thing ran on another processor on my computer...
13:22:18 <Cale> It might not get run in parallel at all until it's needed, in which case, it'll just be computed as usual.
13:22:37 <hughperkins> How do I turn on full optimization in ghc?  -O2?
13:22:45 <Cale> yeah
13:22:48 <edwardk> frederick: it adds it to the list of 'parallel executable things' then when a HEC has nothing else to do it runs through that list. a HEC gets spawned for each CPU generally or when you have an incoming call from C.
13:23:04 <_frederik_> HEC?
13:23:12 <edwardk> haskell execution context in GHC parlance iirc
13:23:47 <edwardk> its an entity responsible for executing haskell code. its the thing with the stack that runs the spinless tagless g-machine rep in the background.
13:23:52 <edwardk> er spineless
13:24:04 <hughperkins> ghc -> "undefined reference to __stdginit_ZCMain".  Does that mean anything to anyone?
13:24:29 <edwardk> hughperkins: probably that you put your main in a module named something other than Main and didn't -main-is it
13:24:58 <hughperkins> edwardk, ah ok :-)
13:25:27 <_frederik_> ok
13:25:43 <_frederik_> do i need any special options to get 'par' to work that way?
13:26:59 <Cale> -threaded
13:27:20 <edwardk> -threaded and you might play with some of the RTS settings to tune it for multiple cores, etc.
13:27:27 <_frederik_> ok
13:27:38 <_frederik_> i guess i should submit a documentation bug for pseq and par?
13:29:19 <edwardk> probably, they are sort of leftovers from the old GPH stuff, aren't they?
13:29:31 <edwardk> would explain why they've lingered so long untouched
13:29:33 <_frederik_> is gph defunct?
13:29:37 <Cale> Does pseq still exist?
13:29:45 <Cale> par and seq exist of course
13:29:48 <edwardk> i think the current hope is that DPH is the way to go
13:30:25 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/lang-parallel.html#id3161325
13:30:27 <lambdabot> Title: 7.15. Concurrent and Parallel Haskell, http://tinyurl.com/25eyfl
13:30:39 <edwardk> hrmm a strictness monad fails the laws, but does a Par monad work? basically an identity that par's the function argument before calling the function with it?
13:31:24 <hughperkins> ghc -fglasgow-exts -o imanewbie.exe -main-is Imanewbie.main Imanewbie.hs   ?
13:31:39 <Cale> edwardk: I think that'd be fine
13:31:51 <Cale> edwardk: It would have the same semantics as the Identity monad
13:32:07 <edwardk> newtype Par m a = Par { runPar :: a }; instance Monad Par where return = Par; m >>= f = m' `par` f m' where m' = runPar m
13:32:14 <edwardk> yeah
13:32:37 <edwardk> i was thinking about this one the other night, but hadn't gotten around to writing it up
13:32:41 <hughperkins> hmmm, wierd, gives the same erorr :-/
13:32:43 <edwardk> er i guess i just did =)
13:32:48 <Cale> Or  (Par m) >>= f = m `par` f m
13:33:24 <Cale> hughperkins: I recommend just changing the module declaration inside the file to "module Main where ..."
13:33:24 <edwardk> that works, and keep runPar in the newtype
13:33:50 <hughperkins> Thanks, that works great :-)
13:36:16 <edwardk> i'll toss the Par monad into my little toy prelude
13:37:51 <Cale> Heh, I suppose you could also do a list monad which used parFlatMap for bind :)
13:38:29 <edwardk> the massively parallel search monad? =)
13:39:04 <Cale> yeah
13:39:41 <edwardk> any other lightweight parallel ones that make sense?
13:40:35 <hpaste>  _frederik_ pasted "long parallel sorting question" at http://hpaste.org/1678
13:41:00 <_frederik_> (the above question is not 100% haskell-related)
13:41:51 <hpaste>  int-e annotated "long parallel sorting question" with "same text with line breaks" at http://hpaste.org/1678#a1
13:42:35 <_frederik_> oh dear sorry. i actually removed the breaks because usually that works better on the web
13:43:04 <hpaste>  Marc Weber pasted "Can't I use forIO with mainGUI ? How would this be done then (just incrementing a value each X ms)" at http://hpaste.org/1679
13:45:58 <hughperkins> Hmmm, prime number in C# is faster than equivalent algorithm in Haskell :-O
13:46:05 <hughperkins> err missing number there
13:46:09 <hughperkins> 500 times faster
13:46:33 <edwardk> hughperkins: with liberal use of seq or ! annotations?
13:47:00 <hughperkins> Just copied and pasted some code from http://www.haskell.org/pipermail/haskell-cafe/2007-February/022699.html  Feel free to optimize it
13:47:30 <int-e> MarcWebe1: there's a special variant of mainGUI in the darcs head gtk2hs at least, but you'll have to be careful: it has to be run in a bound thread and all gtk calls will have to be done in that thread's context.
13:47:38 <hughperkins> Hold on I'll hpaste it...
13:47:55 <hpaste>  hughperkins pasted "prime.hs" at http://hpaste.org/1680
13:48:38 <hpaste>  hughperkins pasted "(C# version for reference)" at http://hpaste.org/1681
13:48:42 <EvilTerran> surely you should output _after_ stopping the stopwatch/
13:48:43 <EvilTerran> ?
13:48:57 <hughperkins> after 8 seconds, I dont think thats going to change a lot ;-)
13:49:01 <MarcWebe1> int-e: What is a bound thread in this context?
13:49:27 <MarcWebe1> http://haskell.org/gtk2hs/archives/2005/07/24/writing-multi-threaded-guis/#more-38 < I'll try investigating where the difference is ..
13:49:27 <ddarius> hughperkins: They aren't using the same algorithm.
13:49:29 <lambdabot> http://tinyurl.com/gt648
13:49:35 <int-e> MarcWebe1: one created by forkIO
13:49:40 <int-e> MarcWebe1: err. sorry
13:49:46 <MarcWebe1> forkOS ?
13:49:54 <int-e> MarcWebe1: one create by forkOS, the other threads are free to migrate between OS thread
13:50:02 <MarcWebe1> forkOnIO ( ? Don't know what this is. There is no documentation)
13:50:04 <edwardk> a bound thread says that all calls coming from haskell will keep coming from the same thread, GHC doesn't guarantee that subsequent instructions will continue to be run in the same thread unless you forkOS
13:50:09 <int-e> *threads, and that will confuse gtk.
13:50:10 <hughperkins> Can you improve the haskell one so it is the same as the C# version?
13:50:23 <hughperkins> (to ddarius I mean)
13:50:29 <int-e> MarcWebe1: the special version of mainGUI is called unsafeInitGUIForThreadedRTS btw.
13:50:32 <edwardk> er calls coming from haskell into FFI that is
13:50:40 <ddarius> hughperkins: There are already a whole bunch of prime sieves on the mailinglist and I'm pretty sure copied to the wiki too.
13:51:31 <hughperkins> Well, these are both sieves of arastophones, so they're pretty eqvuialent?
13:51:54 <hughperkins> I'm not a Haskell expert, so feel free to select a better sieve of arastophenes algo
13:51:55 <int-e> MarcWebe1: err it's initGUI that it replaces. (heh I've never actually used it, so please forgive me for mixing this up)
13:52:04 <MarcWebe1> int-e: Thanks. So as long as I'm not using forkOs there will be no problem..
13:52:45 <MarcWebe1> Thanks for your suggestion. I'll try. didn't know that you can block the other light weight threads somehow. 
13:53:25 <EvilTerran> I'm trying to run something from one of Oleg's papers. on the line "data Vecp tail a = a :+: tail a deriving Show", I'm getting "No instance for (Show (tail a)) arising from the 'deriving' clause of a data type declaration". adding "Show (tail a) => " in various places doesn't seem to help. halp?
13:55:06 <hughperkins> Going to grab an ice-cream, later all :-)
13:56:06 <MarcWebe1> EvilTerran: Can you paste some code?
13:56:48 <MarcWebe1> EvilTerran: It works if you define the instance (or import the module defining it). Don't know about data declarations and constraints..
13:57:59 <hpaste>  EvilTerran pasted "Oleg's number-paremeterized types" at http://hpaste.org/1682
13:58:11 <int-e> MarcWebe1: As far as I understand the issue, if you use the threaded RTS (note that the non-threaded RTS has support for forkIO though) you'll confuse gtk2hs already, no matter whether you use forkIO / forkOS or not. The way to work with the threaded RTS is to forkOS a thread that's responsible for all GTK+ stuff. All calls to gtk+ will have to come from that thread.
13:59:02 <EvilTerran> aha... ignore me, I'd forgotten to put the #s on {-# OPTIONS_GHC -fglasgow-exts #-}
13:59:17 <EvilTerran> that fixed it =/
13:59:32 <hpaste>  int-e pasted "gtk2hs wrapper for threaded RTS" at http://hpaste.org/1683
13:59:54 <int-e> MarcWebe1: that's what I've been using but it's not heavily tested.
14:00:58 <int-e> MarcWebe1: in any case the idea is to use gtkAction or gtkCall whenever you want to do something gtk2hs based. the single MVar (instead of a Chan) is a possible bottleneck.
14:02:03 <MarcWebe1> Hae you seen the link to the gtk2hs documentation? They've been using `onClicl` $ forkIO $ do .. I 'll need some time to understand your code.
14:02:03 <ddarius> @tell hughperkins http://www.haskell.org/pipermail/haskell-cafe/2007-February/022854.html
14:02:03 <lambdabot> Consider it noted.
14:02:27 <int-e> MarcWebe1: forkIO works and is safe in the non-threaded RTS.
14:02:58 <int-e> MarcWebe1: (quite confusingly. the threaded RTS is about using several OS threads (in the hope that they'll get mapped to different CPUs))
14:03:55 <MarcWeber> I'll move inside too much gnats
14:04:57 <ihope> Hey! Where's foldl1'?
14:05:08 <int-e> @index foldl1'
14:05:08 <lambdabot> Data.List
14:05:35 <ihope> Ah, yes, thanks :-)
14:05:45 * bos is beginning to wonder if andrew coppin is a troll.
14:06:24 <ihope> bos: Andrew Coppin?
14:06:35 <bos> a very prolific poster on haskell-cafe.
14:06:37 * EvilTerran is tempted to sign up to Haskell-Cafe out of curiosity, if nothing else
14:07:01 <EvilTerran> I'm sure i could learn a great deal just by lurking, be it about haskell or about our Mr Coppin.
14:07:27 <bos> he asks an awful lot of off-topic questions and intersperses otherwise somewhat interesting conversations with much inanity.
14:07:36 <Korollary> EvilTerran: use gmane to read
14:07:41 <ddarius> EvilTerran: Just look at the archives if you don't want to subscribe.
14:07:45 <ihope> bos: inanity?
14:07:54 <EvilTerran> ...incidentally, Andrew Coppin is a cameraman. http://www.imdb.com/name/nm0178823/
14:07:56 <lambdabot> Title: Andrew Coppin (I)
14:08:04 <bos> ihope: sentences without an awful lot of actual content.
14:08:08 <mauke> "LOL"
14:08:08 <EvilTerran> Korollary, ddarius, okay.
14:08:22 <ddarius> About half of my comments on the list are fairly inane, but I don't put many out there.
14:08:46 <bos> i think you do yourself an injustice.
14:09:12 <int-e> well when you contribute half of the mails to the list, people tend to notice :/
14:09:52 <ihope> ...hmm, what's that function that returns a number of copies of a value in a list?
14:10:01 <EvilTerran> > replicate 6 True
14:10:02 <int-e> replicate
14:10:04 <lambdabot>  [True,True,True,True,True,True]
14:10:11 <ihope> That's it!
14:10:31 * ihope finishes his simple tetration function
14:10:32 * ddarius thought you wanted something with the semantics length . all (==x)
14:10:46 <mauke> @hoogle Int -> a -> [a]
14:10:47 <lambdabot> Prelude.replicate :: Int -> a -> [a]
14:11:01 <SamB> ddarius: s/all/filter/, and count me in
14:11:05 <EvilTerran> good bot
14:11:05 <ihope> Articles are important :-)
14:11:08 <EvilTerran> @bot
14:11:09 <lambdabot> :)
14:11:34 <ddarius> SamB: It's nice to know that one of us knows what I mean.
14:12:15 <xerox> > map (head &&& length) . group . sort $ "I thought of something like this too" -- :)
14:12:16 <lambdabot>  [(' ',6),('I',1),('e',2),('f',1),('g',2),('h',4),('i',3),('k',1),('l',1),('m...
14:12:46 <int-e> . o O ( "But THAT is a whole OTHER topic - and very off-topic here. ;-)" ... then why did he post it? )
14:12:59 <ihope> Would you all call me silly for using foldl1' and flip'ing its first argument?
14:13:21 * ihope attempts to evaluate 4^^4
14:14:55 <oerjan> ihope: i assume you don't mean haskell's ^^ :)
14:15:00 <ihope> Indeed.
14:15:05 <ihope> > 4^^4
14:15:07 <lambdabot>  256.0
14:15:13 <ihope> That's a little bit easier to calculate.
14:15:27 <ihope> @index ^^
14:15:27 <lambdabot> Prelude
14:16:17 <int-e> @type ((^), (^^), (**))
14:16:19 <lambdabot> forall a b a1 b1 a2. (Integral b, Num a, Integral b1, Fractional a1, Floating a2) => (a -> b -> a, a1 -> b1 -> a1, a2 -> a2 -> a2)
14:16:41 <Olathe> lambdabot is so cheeky.
14:16:55 <Olathe> @src ^
14:16:55 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:17:12 <ddarius> @src (^)
14:17:13 <lambdabot> Source not found. stty: unknown mode: doofus
14:17:25 <oerjan> Olathe: not there, we have tried
14:17:49 <oerjan> @source Prelude
14:17:49 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
14:23:45 <MarcWeber> int-e: When does idleTask return False?
14:24:02 <int-e> MarcWeber: never.
14:26:04 <MarcWeber> :) Why not return () then?
14:26:40 <ptolomy> Does there exist a functional hashtable for when Data.Map is too slow and we don't feel like being in IO?
14:26:53 <int-e> MarcWeber: a timeout handler can return True if it wants to be called again, or false if it's a single shot timeout (or wants to stop)
14:27:09 <mauke> how can a functional hashtable be fast?
14:27:19 <DRMacIver> Hash tables are pretty poorly suited for functional datastructures aren't they?
14:27:40 <int-e> you can pull the diffarray trick I guess
14:27:43 <DRMacIver> mauke: By being a non-functional datastructure which is copy on write, sacrificing updates in a really major way? :)
14:28:24 <ddarius> DiffArray
14:28:27 <int-e> oh of course: a functional hash table is fast if there are no updates :)
14:28:35 * basti_ still dreams of a hashtable zipper.
14:29:41 <ddarius> basti_: It would be kind of boring.
14:29:59 <ptolomy> (I was playing with a simple lzw implementation in haskell, and since it uses a map it is at a real disadvantage compared to even my ruby version which uses a hashtable, since most of its time is spent looking up strings)
14:30:18 <basti_> zipper as in type derivative, not zipper as in compression
14:30:51 <basti_> still, it might be boring, that is true
14:30:58 <basti_> (i.e. storing only a list of updates)
14:31:00 <Heffalump> is there a simple explanation of what a type derivative is?
14:31:24 <pjd> "simple" or "explanation": choose any one
14:31:26 <basti_> the same thing as the derivative of a function, just with types.
14:31:30 <ddarius> Differentiation is an algebraic operation, apply to algebraic types.
14:31:32 <basti_> :D
14:31:41 <DRMacIver> Isn't it just symbolic partial differentiation with respect to type parameters?
14:31:50 <basti_> yep
14:32:12 <basti_> the question is, why do type derivatives turn out to be "the same structure minus one element"
14:32:28 <basti_> and what does that tell us about computation?
14:32:32 <Heffalump> I know how to differentiate continuous functions.
14:32:35 <ddarius> DX = 1 
14:32:39 <Heffalump> A type is neither a function nor continuous.
14:33:04 <Heffalump> DRMacIver: oh, with (+) and (x) treated as in algebra?
14:33:06 <ddarius> Heffalump: Take the algebraic properties of the derivative, the important ones being the chain rule, the product rule, and linearity:
14:33:15 <basti_> a tuple is like a product in types, no?
14:33:17 <Heffalump> ok. Now I get it. But what's the point?
14:33:20 <basti_> and "Either" is like a sum
14:33:31 <ddarius> Heffalump: That it works and means something!
14:33:34 <DRMacIver> Heffalump: It seems that derivatives correspond to zipper types. Or something like that.
14:33:46 <ddarius> In the coalgebraic world
14:33:55 <ddarius> @google "Behavioral Derivative"
14:34:00 <lambdabot> http://links.jstor.org/sici?sici=0012-9682(198611)54:6%3C1461:CEOSC%3E2.0.CO;2-3
14:34:00 <lambdabot> Title: JSTOR: Econometrica: Vol. 54, No. 6, p. 1461
14:34:02 <basti_> the point is, the derivative of a type appears to be the same type, with one element missing.
14:34:10 <ddarius> Hmm, that's looking like the wrong one.
14:34:14 <basti_> the derivative of a list is a list with a hole
14:34:27 <MarcWeber> int-e: Oh. I'll just can use timeoutAtFull and I'll be done. Thanks for your snippet.
14:34:52 <EvilTerran> basti_, "data Foo a b c = Bar a b | Baz a c" means Foo is like "a*b + a*c", fehrinstance
14:35:04 <ddarius> http://citeseer.ist.psu.edu/380519.html
14:35:06 <lambdabot> Title: Behavioural Differential Equations: A Coinductive Calculus of Streams, Automata, ...
14:35:14 <basti_> EvilTerran: yup
14:35:19 <Heffalump> and how does recursion work?
14:36:28 <basti_> you just recurse to the derviative itself
14:37:17 <basti_> for example, a list is: List a = a*(List a)
14:37:20 <ddarius> Heffalump: Chain rule
14:37:54 <basti_> differientate against dx -> d(List a) = d(a*(List a)) = da*List a + a*d(List a)
14:37:59 <basti_> urhm
14:38:00 <basti_> -x
14:38:02 <basti_> +a
14:38:54 <DRMacIver> basti_: You mean List a = 1 + a * List a, right?
14:39:22 <DRMacIver> (the 1 coming from []
14:39:22 <DRMacIver> )
14:39:24 <basti_> urhm.
14:39:27 <basti_> correct.
14:39:39 * basti_ was a little quick
14:40:06 <basti_> so, the derivative is 1 + List a + a * d(List a) in the end
14:40:21 <DRMacIver> No, you lose the 1 when you differentiate
14:40:22 <basti_> shouldnt it be 0?
14:40:26 <basti_> yep
14:40:28 <DRMacIver> d1/da = 0
14:40:43 * basti_ doesnt do this all to often
14:40:46 <basti_> too
14:41:01 <Heffalump> so now you need to solve for d(List a)?
14:41:19 <Heffalump> if so, what does - mean for an algebraic type?
14:41:20 <ddarius> Heffalump: No, you just have a new recursive type.
14:41:37 <basti_> 0 + a + a*d(List a) <- hah
14:41:43 <basti_> argh
14:41:50 <basti_> 1 + a*d(List a)
14:41:54 <basti_> its been some time
14:41:56 <basti_> there it is
14:42:19 <DRMacIver> I think you've got that wrong again. :-)
14:42:26 <Heffalump> oh, right, yes
14:42:29 <Pupeno> I have a function that with some parameters, it returns something, and with some others, it errors. Can I test it with Quickcheck? that is, have pairs of (value, status) where value is some test value and status is wether the function sholud fail or not?
14:42:30 * basti_ gives up
14:42:42 <basti_> i should do that stuff when i'm not drunk
14:42:51 <ddarius> DList a = List a + a*DList a
14:42:55 <DRMacIver> DiffList a = List a + a * DiffList a
14:42:58 <mauke> don't drink and derive!
14:43:07 <DRMacIver> Argh, ddarius beat me to it. :)
14:43:14 <DRMacIver> Heffalump: I don't think - has an analogue.
14:43:47 <Heffalump> so a DList is basically a list with a distinguished middle point.
14:44:11 * SamB wonders if he can use these two classes to implement "many" for monad transformed parsers...
14:44:19 <basti_> a list with a hole, or something
14:44:20 <SamB> class MonadUnTrans s t | t -> s where
14:44:20 <SamB>   unlift :: (Monad m) => s a b -> t m a -> m b
14:44:26 <SamB> class (MonadUnTrans s t) => MonadReTrans s t | t -> s where
14:44:27 <SamB>   relift :: (Monad m) => (forall b. s a b -> m b) -> t m a
14:45:02 <Pupeno> or, how do I write a function property using a custom test data generator?
14:45:03 <Heffalump> it doesn't feel very zipper like, though; you don't have easy access to the hole
14:45:20 <SamB> what is this strange DList you guys are talking about?
14:45:23 <Heffalump> but I'd have to differentiate a Tree to check how that works, I guess.
14:45:25 <DRMacIver> Yeah. I'm feeling a bit confused by that as well.
14:45:25 <SamB> my DList looks like...
14:45:32 <hpaste>  magnus pasted "Can this be made faster without changing algorithm?" at http://hpaste.org/1684
14:45:33 <DRMacIver> SamB: It's the derivative of a list, not a difference list.
14:45:39 <SamB> newtype Data.DList.DList a
14:45:39 <SamB>   = Data.DList.DL {Data.DList.unDL :: [a] -> [a]}
14:45:57 <magnus__> right now my paste is about four times slower than common lisp using the same algorithm
14:46:10 <SamB> should the derivative be DListDT?
14:46:25 <DRMacIver> We're too lazy to write that. ;)
14:46:33 <SamB> or List'?
14:46:42 <njbartlett> Heffalump: Many thanks for the mailing list setup!
14:46:52 <SamB> s/should/shouldn't/
14:46:55 <Heffalump> you're welcome
14:47:06 <Heffalump> I'm deeply unimpressed that mailman *still* doesn't have proper virtual domain support.
14:47:29 <Lemmih> magnus__: Updating an immutable array is rather expensive.
14:47:58 <SamB> magnus__: have you tried using ST yet?
14:48:04 <magnus__> Lemmih: Is there any other option that is not worse?
14:48:05 <basti_> as in, "undefined"? ;)
14:48:33 <SamB> basti_: as in having to copy the whole array...
14:48:39 <magnus__> SamB: No, I haven't. I was hoping to do it without state
14:48:53 <DRMacIver> magnus__: Try using an IntMap instead?
14:48:57 <Lemmih> magnus__: ST gives you in-place updates while keeping a pure interface.
14:49:09 <basti_> ;)
14:49:35 <SamB> unfortunately, with runSTUArray doesn't like you to be polymorphic...
14:49:48 <SamB> s/with //
14:50:10 <oerjan> :t runSTUArray
14:50:12 <lambdabot> Not in scope: `runSTUArray'
14:50:21 <SamB> @hoogle runSTUArray
14:50:22 <lambdabot> Data.Array.ST.runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i e
14:50:26 <ddarius> DList is equivalent to List a x List a
14:50:55 <magnus__> DRMacIver: Is IntMap really faster than copy-updating a 9x9 array?
14:51:28 <SamB> you mean "List a × List a"
14:51:28 <SamB> ?
14:51:42 <DRMacIver> magnus__: Not sure. Potentially. It's an O(log(n)) update, so there's probably room for improvement there.
14:51:43 <hpaste>  EvilTerran pasted "shape-parameterised trees" at http://hpaste.org/1685
14:51:50 <SamB> magnus__: oh, probably not ;-)
14:51:54 <DRMacIver> Constant factors might kill it at that size though.
14:52:05 <SamB> > 9*9
14:52:07 <lambdabot>  81
14:52:10 <DRMacIver> Yeah
14:52:11 <ddarius> However, intuitively using the DList type directly we have: either it's the rest of the elements or it's the first element and a DList
14:52:22 <EvilTerran> that thar paste -- is there something that can go in the (???) to make it work, or am I barking up the wrong tree?
14:52:33 <SamB> an 81 item array is not a big deal even if it is a UArray of Double
14:53:02 <DRMacIver> I know it's small, but log(81) is significantly smaller than 81. :) There's room for a constant factor improvement if the overhead of IntMap isn't too bad.
14:53:34 <DRMacIver> (If you assure me that it is too bad I'll believe you. I've not checked.)
14:53:37 <magnus__> EvilTerran: The ??? just means it should not be considered part of the board... it is not a performance thing I'm sure
14:53:50 <EvilTerran> magnus__, i meant my paste, not that one
14:53:51 <EvilTerran> :P
14:54:02 <magnus__> EvilTerran: That explains things :D
14:54:14 <ddarius> We can see that it's isomorphic to List a x List a by unrolling and getting List a x 1 + List a x a + List a x a^2 + ... factoring out the List a getting List a x (1 + a + a^2 ...) ~ List a x List a
14:54:31 <Pupeno> On http://www.md.chalmers.se/~koen/Papers/quick.ps  , the laws of reverse doesn't look right to me. reverse [x] == [x] ? and then reverse (xs++ys) == reverse xs ++ reverse ys? both seem false to me. Am I wrong?
14:54:31 <SamB> just because f(n) < g(n) doesn't mean a function drawn from O(f(n)) is less than a function drawn from O(g(n)) for a particular n
14:54:48 <DRMacIver> I know that.
14:54:53 <Heffalump> reverse [x] is obviously [x] ..
14:54:54 <EvilTerran> the closest thing i got to "something that might work" was the appalingly ugly "forall l r a. Branches (t a) (l a) (r a) => t a -> Maybe (l a, r a)"
14:54:55 <ddarius> Pupeno: Clearly reverse [x] == [x], the second one has a typo
14:54:57 <Pupeno> oh! I missread the second.
14:54:57 <Heffalump> the other one is clearly wrong.
14:55:05 <magnus__> could strictness annotations bring up performance?
14:55:08 <EvilTerran> (but that didn't work)
14:55:10 <ddarius> reverse (xs++ys) = reverse -ys- ++ reverse -xs-
14:55:45 <magnus__> or using UArray?
14:55:46 <mauke> reverse (xs++ys) = reverse ys ++ reverse xs  -- because I can
14:55:48 <Pupeno> ah! ok, got it. Thanks.
14:55:55 <SamB> magnus__: what are you storing in your array?
14:56:15 <Alleria> @unpl filterM (const [True, False])
14:56:15 <lambdabot> filterM (\ _ -> [True, False])
14:56:35 <Lemmih> magnus__: I'd go for a mutable array if I were you.
14:56:44 * SamB looks at paste
14:57:58 <oerjan> > filterM (const [True, False]) [1..10]
14:57:59 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,10],[1,2,3,4,5,...
15:00:54 <EvilTerran> @src filterM
15:00:54 <lambdabot> Source not found. I've seen penguins that can type better than that.
15:01:06 <EvilTerran> @source filterM
15:01:06 <lambdabot> filterM not available
15:01:15 <SamB> magnus__: I'd go for UArray, except that I'm not sure how you'd do that...
15:01:23 <int-e> @source Control.Monad
15:01:23 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
15:01:30 <SamB> given that you use an algebraic datatype
15:05:55 <magnus__> SamB: I'll try. UArray is only defined on Word8 and things like that though so I'll have to switch to Word8 instead of Cell I guess
15:13:38 <FalconNL> Newbie question: from what I've been able to find there are two methods of adding list elements together: ":", which is a -> [a] -> [a] and "++", which is [a] -> [a] -> [a]. Is there any function/operator that does [a] -> a -> [a] or is "list ++ [newElement]" the recommended way to do that?
15:14:07 <mauke> the latter
15:14:13 <Binkley> or you can define your own:
15:14:17 <mauke> except it's not really recommended because it's slow :-)
15:14:21 <Binkley> snoc xs x = xs ++ [x]
15:14:28 <Binkley> Right, try to avoid it
15:15:54 <ddarius> @tell hughperkins Also consider the very beginning of http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
15:15:54 <lambdabot> Consider it noted.
15:17:10 <FalconNL> I'm using it for the following: calculating the area of a polygon requires summing the cross product of the various vectors (points) in the polygon. My current line of thought was using sum (zip points ((tail points) ++ [head points])). Is there a more efficient way of doing this?
15:17:27 <ddarius> :t flip ((++) . (:[]))
15:17:29 <lambdabot> forall a. [a] -> a -> [a]
15:17:33 <oerjan> actually xs ++ [x] a single time is probably fine, it's when you tack things onto the end of a list several times it gets slow.
15:18:00 <kpreid> indeed
15:18:08 <ddarius> oerjan: If you're doing that at all you probably want a different data structure.
15:18:11 <kpreid> ++ [x] is merely O(n)
15:18:31 <kpreid> but if you, say, construct a list using it, you then have O(n^2)
15:19:13 <FalconNL> nah, it's just for moving the head to the end of the list for the zip operation
15:19:59 <kpreid> that seems fine
15:20:07 <FalconNL> ok, thanks
15:20:42 <kpreid> though I might define rotate (x:xs) = xs ++ [x]
15:22:22 <mauke> @type \x -> sum (zip x (tail x ++ [head x]))
15:22:24 <lambdabot> forall a. (Num (a, a)) => [a] -> (a, a)
15:22:33 <mauke> thought so
15:23:38 <glen_quagmire> i conquer
15:24:44 <ddarius> The new product of Apple aimed at Spanish Conquistadors
15:26:18 * SamB wonders if anyone can explain how this is an algebra:
15:26:21 <SamB> data MaybeAlg a b	= MaybeAlg { nothing :: b, just :: a -> b }
15:26:48 <EvilTerran> hm. what complexity is cycle?
15:26:59 <ddarius> I would say linear
15:27:02 <mauke> O(n), I think
15:27:03 <SamB> O(length xs)
15:27:06 <EvilTerran> @src cycle
15:27:07 <lambdabot> cycle [] = undefined
15:27:07 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
15:27:21 <mauke> ++ is linear in length xs
15:27:24 <EvilTerran> okay.
15:27:30 <ddarius> SamB: It isn't.
15:27:50 <SamB> ddarius: oh?
15:28:22 <EvilTerran> makes sense. it'd need to make a fresh copy of the list in order to change the tail of the last element.
15:28:23 <SamB> er. well, how a value of that might be an algebra?
15:29:45 <ddarius> Inductively on b it has no base case and is thus empty.
15:30:11 <magnus__> SamB: Somehow, UArray is slower than Array!
15:31:47 <ddarius> SamB: It can be made into a coalgebra, but it's not related to Maybe.
15:32:19 <SamB> hmm.
15:32:23 <ddarius> It would be the type of infinite trees with a-labelled transitions.
15:33:08 <ddarius> Well (1+a)-labelled
15:33:51 <ddarius> I guess that gives some vague connection to Maybe, it's isomorphic to nu b.Maybe a -> b
15:34:20 <ddarius> (Or rather fixing on b would be)
15:34:59 <ddarius> Actually, it is Maybe a -> b
15:35:59 <SamB> yeah...
15:37:08 <ddarius> Still.  It's not an algebra.
15:37:35 <ddarius> Ah, I see what it's getting at.
15:38:01 <ddarius> You have fold :: MaybeAlg a b -> Maybe a -> b
15:38:13 <SamB> yeah...
15:39:38 <ddarius> Okay, then I was wrong.  I was thinking a completely different direction.
15:42:27 <ddarius> It's an F-algebra where F x = Maybe a
15:43:01 <ddarius> Or slightly better, F b = Maybe a
15:47:20 <SamB> how about this one:
15:47:24 <SamB> data StateAlg s a b 	= StateAlg { first :: s,         -- ^ initial state
15:47:24 <SamB> 				     next :: (a,s) -> b  -- ^ state transformer
15:47:24 <SamB> 				   }
15:49:09 <ddarius> This isn't equivalent to a function ... -> b
15:49:43 <SamB> @src State
15:49:43 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
15:49:50 <ddarius> An F-algebra is just a function F b -> b for some functor F
15:50:35 <SamB> newtype State s a = State {runState :: s -> (a, s)}
15:51:40 <ddarius> You're viewing it as (s -> (a,s)) -> StateAlg s a b -> b ?
15:52:05 <fasta> Do we have this function? (Monad m) => (a1 -> a2 -> m r) -> m a1 -> m a2 -> m r
15:52:06 * SamB is trying to understand this part of StrategyLib
15:52:20 <ddarius> :t liftM2
15:52:22 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:52:23 <SamB> fasta: isn't that liftM2
15:52:28 <ddarius> Almost
15:52:34 <fasta> ddarius: no
15:52:48 <SamB> oh.
15:52:53 <ddarius> :t ap
15:52:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:52:55 <fasta> SamB: er no
15:53:01 <mauke> :t ((join .) .) . liftM2
15:53:03 <lambdabot> forall a a1 a2 (m :: * -> *). (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
15:53:48 <fasta> mapply2?
15:54:00 <SamB> @pl \f p q -> ((.) . (.)) return (liftM2 f p q)
15:54:01 <lambdabot> ((((return .) .) .) .) . liftM2
15:54:24 <SamB> :t (((return .) .) .) .) . liftM2
15:54:26 <lambdabot> parse error on input `)'
15:54:32 <SamB> :t ((((return .) .) .) .) . liftM2
15:54:34 <lambdabot> forall b (m :: * -> *) a a1 a11 a2. (Monad m) => (a11 -> a2 -> a -> b) -> (a1 -> a11) -> (a1 -> a2) -> a1 -> a -> m b
15:54:43 <mauke> @pl \f mx my -> mx >>= \x -> my >>= \y -> f x y
15:54:43 <lambdabot> flip ((.) . (>>=)) . flip ((.) . (>>=))
15:54:46 <SamB> hmm.
15:55:37 <fasta> I find it amazing you still like those dots. 
15:55:59 <SamB> anyway, I'm just trying to understand this stuff in StrategyLib...
15:56:43 <mauke> @. unpl pl \f mx my -> mx >>= \x -> my >>= \y -> f x y
15:56:44 <lambdabot> (\ o c f -> c >>= \ l -> f >>= (o l))
15:57:04 <mauke> lambdabot: you win this round!
15:58:17 <ddarius> @pl \f x y -> uncurry f =<< liftM2 (,) x y
15:58:17 <lambdabot> (. liftM2 (,)) . (.) . (=<<) . uncurry
15:58:55 <mauke> ( fmap fix return )
15:59:09 <ddarius> @pl \f x y -> liftM2 (,) x y >>= uncurry f
15:59:09 <lambdabot> flip (flip . ((>>=) .) . liftM2 (,)) . uncurry
16:02:08 <int80_h> nodeCount :: BinaryTree a -> [b]
16:02:08 <int80_h> nodeCount = map putStrLn a
16:02:20 <int80_h> nodeCount :: BinaryTree a -> [b]
16:02:20 <int80_h> nodeCount = map putStrLn a
16:02:24 <int80_h> oops
16:02:40 <int80_h> DT.hs:79:25: Not in scope: `a'
16:02:40 <int80_h> Failed, modules loaded: none.
16:02:52 <int80_h> so why is a not in scope?
16:03:08 <int80_h> am I allowed to use putStrLn this way?
16:03:24 <ddarius> int80_h: You have some massive confusion there.
16:03:51 <int80_h> I just want to map putStrLn to each node of a
16:03:57 <int80_h> and here is the data type
16:04:05 <Binkley> int80_h: to start with, what is the type of putStrLn?
16:04:33 <int80_h> ah type IO () I'll bet
16:04:39 * ddarius wonders, "Perhaps int80_h is used to programming in a dependently typed language."
16:04:40 <int80_h> so I need show
16:05:21 <int80_h> nodeCount = map putStrLn (show a)
16:05:27 <int80_h> it's still out of scope
16:05:45 <ddarius> int80_h: Types are not values
16:05:48 <kpreid> int80_h: type variables have no relation to value variables
16:13:44 <jethr0> @source $>>
16:13:45 <lambdabot> $>> not available
16:13:50 <jethr0> @source ($>>)
16:13:51 <lambdabot> ($>>) not available
16:14:45 <jethr0> hmm, the other day somebody used ($>>) or something similar for forward function concatenation (like: 4 $>> (+1)). anybody know where that is defined. it doesn't seem to be in Control.Arrow...
16:18:24 <ihope> Forward function concatenation... what would that do?
16:18:30 <ihope> @index $>>
16:18:31 <lambdabot> bzzt
16:18:35 <ihope> @index ($>>)
16:18:36 <lambdabot> bzzt
16:22:10 <hpaste>  int80_h pasted "Int80_h borks binary tree" at http://hpaste.org/1686
16:22:22 <kpreid> jethr0: for 4 $>> (+1) to work $>> would be flip ($), which is application and not composition. which did you mean?
16:23:18 <jethr0> kpreid: sorry, maybe i used the wrong word here. yes, it'd be (flip ($)) and i'm using that right now. i was just wondering where that arrow-ish function was coming from that i saw a few days back
16:28:12 <DRMacIver> Are you sure it wasn't >>> ?
16:28:28 <DRMacIver> @type (>>>)
16:28:30 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
16:28:36 <DRMacIver> @type (<<<)
16:28:38 <lambdabot> forall (a :: * -> * -> *) c d b. (Arrow a) => a c d -> a b c -> a b d
16:29:06 <DRMacIver> (+1) >>> (+2) $ 3
16:29:09 <DRMacIver> > (+1) >>> (+2) $ 3
16:29:10 <lambdabot>  6
16:29:13 <jethr0> pretty sure since he used it to introduce a value to the chain of arrows (functions)
16:29:47 <jethr0> it's not all that important. i'm just curious where that function might have come from or whether i dreamt it all ^_^
16:30:38 <DRMacIver> lambdabot and hoogle seem to think it's the latter. ;)
16:30:41 <DRMacIver> @hoogle $>>
16:30:41 <lambdabot> No matches found
16:31:02 <ihope> Do c a -> a and c a -> (c a -> b) -> c b work as comonad primitives?
16:31:16 <ddarius> I'm pretty sure I've seen it defined by people for their own use before.
16:32:02 <DRMacIver> ihope: I think so.
16:32:03 <jethr0> could have been a let in there somewhere. i can only remember it fuzzily, so i could just be raving...
16:32:47 <DRMacIver> My logs show no instances of it in channel prior to just now.
16:33:43 <ihope> Rather annoying how Google... doesn't search for some things: http://www.google.com/search?q=%24%3E%3E
16:33:44 <lambdabot> Title: $>> - Google Search
16:34:06 <DRMacIver> Yeah
16:34:25 <dons> http://programming.reddit.com/info/26fju/comments
16:34:26 <lambdabot> Title: Data and Codata (reddit.com)
16:48:05 <int80_h_> hey dons, you there?
16:48:31 <dons> bulat hehe. 
16:48:32 <dons> > Does this mean if I turn up, I can meet random Haskellers?
16:48:32 <dons> no, you will meet undefined Haskeller because randomness is impure
16:48:32 <dons> concept
16:48:32 <lambdabot>  Parse error
16:48:40 <dons> int80_h_: indeedy!
16:50:20 <int80_h_> thanks dons :)
16:50:31 <int80_h_> hold on I will post a url I would like you to look at
16:51:37 <int80_h_> 16:21 < hpaste>  int80_h pasted "Int80_h borks binary tree" at  http://hpaste.org/1686
16:51:51 <int80_h_> could you offer some insight into what I have done wrong?
16:52:16 <timthelion> um, how do I get the date a file was last modified from a FilePath?
16:53:00 <Lemmih> @hoogle getModificationTime
16:53:00 <lambdabot> Directory.getModificationTime :: FilePath -> IO ClockTime
16:53:31 <timthelion> thankyou
16:56:10 <bos> morning, dons.
16:56:43 <Nafai> Hrm.
16:56:51 <timthelion> when naming a datatype that represents a tree: "data DatedDirectoryOrFile :: Directory FilePath [DatedDirectoryOrFile] | File FilePath ClockTime" is it better to go for the longer name that is true both for the branches and the leaves, or for a shorter name that is true for just the branches?
16:56:58 <Botje> int80_h_: your function doesn't return a list, it _prints_ a list
16:57:13 <Botje> int80_h_: and you need to think about the two cases a tree can have
16:57:19 <LoganCapaldo> int80_h_, secondly the type of the function should be BinaryTree a -> [a]
16:57:49 <Botje> int80_h_: what do you return for a binary tree with a single element? (ie a Leaf x) ?
16:58:20 <Nafai> So it's a little big, but I just got an idea for a Haskell project
16:58:30 <int80_h_> I would return x, plus the rest of the list
16:58:34 <Nafai> I need a decent graphical diff tool
16:58:45 <int80_h_> hmm
16:59:00 <int80_h_> okay this is not a recursive function is it?
16:59:05 <Botje> yes, yes it is
16:59:19 <LoganCapaldo> It's most certainly recursive
16:59:23 <timthelion> Nafai: for doing bitmap diffs or do you actually want to map out and recognise objects?
16:59:30 <int80_h_> well the reason I was thinking it's not is because the input type is BinaryTree
16:59:37 <Botje> so?
16:59:48 <Nafai> timthelion: Sorry, I meant a GUI-based text diff tool 
16:59:49 <int80_h_> I was thinking that is it was recursive, I would be building a list
17:00:04 <int80_h_> which means I would need to pass this list to the function
17:00:08 <LoganCapaldo> well you are building a list
17:00:11 <Botje> not really
17:00:11 <int80_h_> but it doesn't take a list
17:00:16 <Botje> read the exercise again
17:00:22 <Botje> it tells you how to collect the results
17:00:33 <Nafai> timthelion: My coworkers really like Beyond Compare on Windows and I just haven't found one that's equal on Linux
17:01:27 <Botje> int80_h_: and you can use ++ to concatenate lists
17:01:36 <Botje> think about the base case (a single leaf) first
17:01:39 <timthelion> Nafai: hmm, never seen Beyond Compare. How is it better than say windiff or it's equivalent emacs dif mode?
17:01:45 <int80_h_> okay botje
17:01:56 <Botje> then think about a simple tree with only 3 elements
17:03:03 <LoganCapaldo> (fwiw if you were going to use a function like map or foldr, it would be unfoldr most likely)
17:03:34 <LoganCapaldo> (but that would probably be really icky)
17:04:53 <timthelion> Nafai: oh, I see, it finds differences within lines... that's cool.  Please make it unixy(with command line back end)
17:05:22 <Nafai> timthelion: As well as compares directories which now I can see ediff can do
17:05:37 <Heffalump> any decent diff can do that
17:05:53 <timthelion> Heffalump: which that?
17:06:09 <Heffalump> compare directories
17:06:11 <timthelion> oh
17:07:55 <timthelion> Nafai: you should start by re-writting diff in haskell, and then make it so that it can take a line number argument(index into the diff file) which prints out a collumn based diff on that line. then write a quick gui shell. That way, I could use thate same util for writting an emacs gui too.
17:09:08 <Nafai> Yeah
17:09:38 <Nafai> Another feature I need is to be able to merge specific lines
17:10:06 <Botje> int80_h_: also, the parameters go in the nodeCount = ... line
17:10:16 <timthelion>  could that be done with that same line number argument system?
17:10:51 <int80_h> I know that when a Leaf is encountered I return it's contents added
17:10:56 <int80_h> to the built list
17:11:25 <int80_h> but because I don' know what that looks like (the function doesn't take a list as an argument, how can I build it?)
17:11:37 <int80_h> I'm having difficulty expressing what I want.
17:11:38 <Botje> int80_h_: that's the beauty of a recursive function
17:11:42 <Nafai> timthelion: Probably
17:12:05 <Botje> imagine you have the top node of the tree
17:12:10 <Botje> and a function to flatten a tree into a list
17:12:19 <Nafai> Now to figure out how to do this in Haskell :)
17:12:29 <Botje> you take the node, flatten the left subtree into a list
17:12:33 <Botje> take the node itself
17:12:37 <timthelion> Nafai: thinking about it, you would actually want a separate utility that you piped the diff program to and which took the line number argument.  because then you wouldn't re-eval the diff for each line number.
17:12:41 <Botje> and then the right part of the list
17:12:44 <Botje> *tree
17:12:52 <Botje> and add all that into a list
17:14:48 <int80_h> Botje, so I already have a function to flatten a tree into a list? Or am I supposed to make one?
17:15:04 <int80_h> I should only use the parts of the language so far introduced in YAHT
17:15:12 <Botje> int80_h_: you're writing it right now )
17:16:00 <Botje> i'll get you started:
17:16:05 * int80_h is thinking
17:16:06 <Botje> nodeCount (Leaf a) = [a]
17:16:08 <int80_h> thanks :)
17:16:40 <Botje> so now, how would you write nodeCount (Branch left node right) ?
17:16:52 <Botje> you need to flatten left (which is either a Leaf or another Branch)
17:17:00 <Botje> append node to that list
17:17:10 <Botje> and then flatten right and append it to the list you're building
17:17:12 <Botje> and finally return it
17:17:16 <monochrom> Does the kind * -> * correspond to 1-parameter type constructor?  E.g. Monad :: * -> * ?
17:17:33 <int80_h> thanks Botje
17:18:20 <Botje> did you get it?
17:18:51 <LoganCapaldo> Monad isn't a tycon is it?
17:19:04 <LoganCapaldo> But yes I think so
17:19:09 <LoganCapaldo> @kind Maybe
17:19:11 <lambdabot> * -> *
17:19:20 <monochrom> OH! Thanks. IO :: * -> * is probably better.
17:20:43 <int80_h> Botje, what I recurse on is confusing me. When I recurse a list I pass xs. But I cannot use list notation here
17:21:02 <int80_h> so I do not know to express "pass the rest of the branch"
17:21:10 <LoganCapaldo> int80_h, right, so use BinaryTree notation
17:21:23 <LoganCapaldo> What can you pattern match against?
17:21:25 <timthelion> what is the difference between * -> * and a -> b?
17:21:40 <LoganCapaldo> Leaf s and Branch s right?
17:21:41 <Botje> timthelion: one's a kind, the other's a type? :)
17:21:58 <xpika> timthelion: * -> * = kind , a -> b = type
17:22:04 <int80_h> yes, Leafs and Branches
17:22:06 * timthelion googles kind type haskell
17:22:19 <Botje> timthelion: kinds are the "superclass" of types.
17:22:38 <ddarius> kinds are types for types
17:22:40 <LoganCapaldo> I was gonna say something else
17:22:46 <LoganCapaldo> You didn't have to leave :(
17:22:52 <int80_h> i am here :)
17:23:00 <int80_h> I don't know what that message was about
17:23:04 <ddarius> They keep you from writing Int Bool Maybe
17:23:05 <LoganCapaldo> gah underscores
17:23:09 <LoganCapaldo> anyway
17:23:13 <xpika> @kind IO
17:23:15 <lambdabot> * -> *
17:23:25 <LoganCapaldo> so trees are actually analogous to lists in this case
17:23:49 <xpika> @kind Map
17:23:50 <lambdabot> Not in scope: type constructor or class `Map'
17:23:56 <LoganCapaldo> when you write a function on lists you match against [] (~ like leaf) and (x:xs) (~ like Branch)
17:24:08 <xpika> Map :: * -> * -> *
17:24:20 <xpika> takes two types and returns another type
17:24:44 <LoganCapaldo> So to do something to "the rest of the tree" would look something like foo (Branch as b cs) = manip as bs etc.
17:24:55 <int80_h> LoganCapaldo: when I see x:xs I know that x means "first element" and xs means "the rest"
17:25:04 <LoganCapaldo> @kind Data.Map.Map
17:25:06 <lambdabot> * -> * -> *
17:25:06 <xpika> what is the difference between MonadPlus and Monoid?
17:25:06 <int80_h> oh there we go, that's what I was getting at
17:25:22 <ddarius> :t (mplus,mappend)
17:25:23 <LoganCapaldo> I think Monoid's don't have to be monads
17:25:23 <lambdabot> forall (m :: * -> *) a a1. (MonadPlus m, Monoid a1) => (m a -> m a -> m a, a1 -> a1 -> a1)
17:26:59 <monochrom> Hey, "hpaste is for small pastes and truncates after 5K" rhymes. :)
17:27:57 <LoganCapaldo> monochrom, how are you pronouncing K?
17:28:21 <MarcWeber> @seen dcoutts 
17:28:22 <lambdabot> dcoutts is in #haskell-overflow, #haskell, #ghc and #gentoo-haskell. I last heard dcoutts speak 1d 15h 31m 49s ago.
17:28:24 <monochrom> Kay
17:28:49 <LoganCapaldo> I don't think truncates and Kay rhymes...
17:28:58 <LoganCapaldo> Unless I'm missing some other rhyme
17:29:11 <int80_h> bye guys...I will ponder and try. BBL.
17:29:42 <xpika> is there a zip class
17:29:43 <monochrom> English is not my native language, so there may be subtle vowel differences I miss. I don't have trouble with consonants except s vs z.
17:29:56 <xpika> to say zip two trees
17:30:15 <xpika> or zip two maps
17:31:00 <LoganCapaldo> well it's that 't'
17:31:17 <LoganCapaldo> maybe truncaes and 5k
17:31:23 <ddarius> @src Traverse
17:31:24 <lambdabot> Source not found. You type like i drive.
17:31:33 <LoganCapaldo> @src Traversable
17:31:33 <lambdabot> class (Functor t, Foldable t) => Traversable t where
17:31:33 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
17:31:33 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
17:31:33 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
17:31:33 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
17:31:45 <ddarius> @hoogle zip
17:31:46 <monochrom> Ah ok, when I consider rhyming I ignore the t.
17:31:46 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
17:31:46 <lambdabot> List.zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]
17:31:46 <lambdabot> List.zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]
17:32:00 <LoganCapaldo> heh
17:32:17 <LoganCapaldo> So I'm just being too strict for the purposes of this observation :)
17:32:20 <monochrom> I have very relaxed rhyming axioms :)
17:32:25 <ddarius> xpika: The answer is yes I'm pretty sure, but I'm not exactly sure where the function is.
17:32:43 <ddarius> Check out Data.Traversable and co.
17:32:46 <xpika> ddarius: :(
17:32:58 <xpika> Data.Zippable
17:33:01 <hpaste>  monochrom pasted "fun with higher-kind GADT" at http://hpaste.org/1687
17:33:16 <monochrom> I like that example I've cooked up. :)
17:33:46 <LoganCapaldo> You making me dizzy
17:33:57 <xpika> lol monochrom that almost looks untyped
17:34:22 <monochrom> It made me dizzy for two minutes too. Then it sank in. :)
17:34:59 <LoganCapaldo> mmmm
17:35:19 <LoganCapaldo> You've reified the monad w/ funnyreturn
17:35:23 <LoganCapaldo> bizzare
17:35:39 <ddarius> xpika: ?
17:35:53 <monochrom> funnyreturn and Funny will not work for all monads, since I have limited them to either [] or Maybe.
17:36:04 <LoganCapaldo> no not all
17:36:07 <LoganCapaldo> ofc
17:36:11 <LoganCapaldo> but you could add more
17:36:31 <LoganCapaldo> which let's you pass the monad as a parameter
17:36:43 <monochrom> Yeah!
17:39:18 <LoganCapaldo> monochrom++
17:39:42 <monochrom> Danke
17:39:45 <dons> morning bos
17:41:03 <bos> passivetex is making me sad.
17:42:39 <LoganCapaldo> bos: maybe it's time to switch to aggressivetex
17:43:42 <Binkley> passive/aggressive tex: "Well, I'll let you underfill that hbox if that's what you really *want*..."
17:43:53 <xpika> dons: do you know of somthing lika a Data.zippable for zipping two trees or maps?
17:47:23 <dons> hmm i think Maps have a zip defined
17:47:37 <dons> but i don't know of one, along the lines of Foldable or Traversable
17:47:42 <dons> you can probably build it up though
17:48:30 <|Steve|> Do people write literate haskell very often?
17:48:42 <ddarius> |Steve|: Some do, some don't.
17:49:03 <dons> bos, i'm ok if you feel that tool chain is better
17:49:13 <hpaste>  monochrom pasted "unicode test" at http://hpaste.org/1688
17:49:29 <|Steve|> Hmm.
17:49:42 <bos> dons: ok, thanks
17:49:43 <dons> did the test wor, monochrom ?
17:49:50 <monochrom> It's weird.
17:50:51 <monochrom> "weird" means it partly works and partly fails. I still do not have a handle on it.
17:52:06 <dons> i think since glguy wrote both hpaste, and utf8-string, we shoudl convince him to combine the two :)
17:56:12 <monochrom> I think I see why it is funny. It does syntax highlighting. Thus it will pass some characters verbatim and process some other characters. The processed ones can go wrong.
17:56:53 <monochrom> In my test, β is untouched, but λ is changed to unknown.
17:57:56 <dons> yeah, i don't think it is using the utf8-aware string decoder
17:58:14 <hpaste>  monochrom annotated "unicode test" with "(no title)" at http://hpaste.org/1688#a1
17:58:35 <monochrom> Putting stuff inside comments helps. :)
17:59:47 <dons> so hiding it from the coloriser, so it doesn't get munged :)
18:06:28 <jix> @src (!!)
18:06:29 <lambdabot> xs     !! n | n < 0 = undefined
18:06:29 <lambdabot> []     !! _         = undefined
18:06:29 <lambdabot> (x:_)  !! 0         = x
18:06:29 <lambdabot> (_:xs) !! n         = xs !! (n-1)
18:13:02 <dons> ?users
18:13:02 <lambdabot> Maximum users seen in #haskell: 355, currently: 310 (87.3%), active: 9 (2.9%)
18:13:23 <|Steve|> How does map . (*) make any sense?
18:13:32 <|Steve|> Neither map nor (*) would seem to have the types required by
18:13:35 <|Steve|> @type (.)
18:13:37 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
18:14:23 <wli> (map . (*)) n == map (*n)
18:14:36 <dons> :t map . (*)
18:14:38 <lambdabot> forall a. (Num a) => a -> [a] -> [a]
18:14:40 <dons> ?unpl map . (*)
18:14:41 <lambdabot> (\ c -> map ((*) c))
18:14:46 <syntaxfree> @free map
18:14:48 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
18:14:53 <dons> makes perfect sense
18:15:21 <dons> ?src ()
18:15:21 <lambdabot> data () = ()
18:15:22 <dons> ?src (.)
18:15:22 <lambdabot> (.) f g x = f (g x)
18:15:33 <syntaxfree> > (map (.) (*)) 5
18:15:34 <lambdabot>  Couldn't match expected type `[b -> c]'
18:15:39 <syntaxfree> > (map (.) (*)) 5 7
18:15:40 <lambdabot>  Couldn't match expected type `[b -> c]'
18:15:44 <syntaxfree> > (map (.) (*)) [5]
18:15:45 <lambdabot>  Couldn't match expected type `[b -> c]'
18:15:52 <syntaxfree> > (map (.) (*)) 5 [7]
18:15:53 <lambdabot>  Couldn't match expected type `[b -> c]'
18:16:11 <wli> need a typeclass
18:16:26 <dons> map . (*) --> \x -> (.) map (*) x --> \x xs -> map ((*) x) xs  --> \x xs -> map (x *) xs
18:16:35 <|Steve|> > (map . (*)) 5 [1..5] -- Is that what you meant syntaxfree?
18:16:36 <lambdabot>  [5,10,15,20,25]
18:17:32 <|Steve|> I guess that I wasn't thinking. The type variable b in the type of (.) can easily be s -> t which is what is happening, huh?
18:19:30 <syntaxfree> @pl \n -> (map . (*)) n [1..n]
18:19:30 <lambdabot> liftM2 map (*) (enumFromTo 1)
18:19:52 * syntaxfree applauds the (->)e monad.
18:20:29 <syntaxfree> > liftm2 map (*) (enumFromTo 1) $ 10
18:20:30 <lambdabot>   Not in scope: `liftm2'
18:20:37 <syntaxfree> > liftM2 map (*) (enumFromTo 1) $ 10
18:20:39 <lambdabot>  [10,20,30,40,50,60,70,80,90,100]
18:20:48 <syntaxfree> > liftM2 map (*) (enumFromTo 1) $ 8
18:20:49 <lambdabot>  [8,16,24,32,40,48,56,64]
18:21:01 <dons> SamB: AllRightsReserved ?
18:21:07 <dons> does that mean we can use it?
18:21:20 <dons> SamB: did you contact the authors?
18:21:48 <wli> There seems to be a general trick for handling varargs -like affairs.
18:22:12 <dons> wli?
18:22:58 <Igloo> dons: What's the context for the AllRightsReserved?
18:23:17 <Igloo> wli: You mean like what Text.printf does?
18:23:23 <wli> Igloo: Yes.
18:23:53 <glguy> AllRightsReserved is the one that 'isn't a license' and 'is most restrictive'
18:23:55 <dons> Igloo: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/StrategyLib-4.0.0.0
18:24:01 <blackdog_> i want a comprehension for Map :( doing toList all the time just feels icky.
18:24:01 <lambdabot> http://tinyurl.com/397bry
18:24:21 <Igloo> Err, I thought hackage was supposed to reject AllRightsReserved packages
18:24:47 <dons> i suspect Sam has just grabbed the last public strafunksi tarball, after author timeout, and uploaded it
18:25:06 <glguy> blackdog_: Data.Map has the ability to map and filter directly, you might not need to toList it
18:25:29 <dons> and isn't it in Traversable and Foldable too?
18:25:29 <wli> blackdog: It should get partially evaluated and/or deforested in a number of instances anyway.
18:25:34 <blackdog_> glguy: yeah, i just want the ability to use the list comprehension syntax...
18:25:55 <wli> Monad comprehension?
18:26:00 <dons> blackdog_: so rebindable list comp syntax to whatever defn of concatMap and filter are in scope?
18:26:12 <SamB> dons: the COPYING file pointed to a stale url on sourceforge.net
18:26:12 <dons> Maps aren't in monad though
18:26:20 <dons> SamB: who's the original author?
18:26:38 <SamB> Ralf Lämmel and Joost Visser
18:26:44 <blackdog_> dons: something like that. i suppose putting it into monad syntax instead isn't too nasty
18:26:48 <dons> did you contact Ralf?
18:26:53 <wli> That will hurt. Perhaps monoid comprehensions. Algebraic data types are very often monoids.
18:27:10 <glguy> List comprehension could be limited to one a <- b   for Functor instances
18:27:15 <dons> yeah, its in monoid
18:27:33 <dons> and functor, and foldable and traversable
18:27:42 <glguy> and use some other bracketing...
18:27:44 <SamB> dons: I did email them, but apparantly the address for Joost was dead. I haven't gotten anything from Ralf yet...
18:27:52 <dons> someone want to roll up a mapping of list comprehensions to a Comprehension class?
18:27:55 <dons> so we can rebind them? :)
18:28:11 <wli> user-defined brackets sound like fun
18:28:11 <glguy> dons: I'd rather see Monad Comprehensions first
18:28:17 <dons> SamB: hmm. what was the original license?
18:28:24 <dons> such that you can redistribute it?
18:28:27 <emilliken> anyone working on bit packing for Data.Binary?  I'm trying to deserialize ethernet frames
18:28:31 <dons> can't be 'AllRightsReserved'
18:28:44 <dons> emilliken: we're *thinking* about it. 
18:28:54 <dons> emilliken: you can define types that use Data.Bits in their instances
18:29:08 <emilliken> ah that may be good enough for me
18:29:11 <dons> so you could grab a Frame type, in its instance use Data.Bits to pull out fields
18:29:25 <dons> perhaps read it on word sized boundaries, then shift and mask around
18:29:47 <dons> i'd be happy to review any code you write here: network protocols should be efficient and easy to write
18:30:00 <dons> that's one of the principle goals for Data.Binary 
18:31:05 <dons> glguy: might be cute to provide monad comprehensions, then see whta is necessary for rebindable list comprehensions
18:31:20 <dons> would make a good HW paper: rebindable list comprehensions for XML, SqL ...
18:31:31 <wli> I miss monad comprehensions.
18:31:51 <monochrom> Rebindable list comprehensions for IO and continuations.
18:31:53 <syntaxfree> I wasn't around for monad comprehensions and miss'em anyway.
18:32:25 <glguy> We drove out to the coast today to see how Sam (my puppy) would react to the water
18:32:31 <glguy> he doesn't seem to be a big fan
18:32:32 <emilliken> thats good to hear, i wasn't looking forward to using bitsyntax
18:32:41 <glguy> though he did enjoy finding bits of crab on the beach
18:32:52 <syntaxfree> glguy: here you can't take dogs to the beach.
18:32:54 <kilimanjaro> glguy, what sort of dog is it?
18:33:00 <glguy> miniature schnauzer
18:33:06 <kilimanjaro> Ahh
18:33:13 <glguy> syntaxfree: We went to Seaside, it was extremely dog friendly
18:33:41 <syntaxfree> what, you used Smalltalk?
18:33:48 <glguy> heh :)
18:34:09 <glguy> When we bought coffees, the shop owner gave Sam a bone :)
18:34:15 <glguy> we wouldn't take it from the owner though
18:34:26 <glguy> doesn't take food from strangers ;)
18:34:30 <|Steve|> I'm trying to do Exercise 7.1 in yaht and I cannot for the life of me get any of these. I've been able to do all previous exercises, but this is completely stumping me.
18:34:39 <wli> Induction on the structure of possible types for the function, which smells a lot like certain language extensions I've yet to touch.
18:35:10 <|Steve|> @pl func2 f = filter f $ map
18:35:10 <lambdabot> func2 = flip filter map
18:35:33 <|Steve|> *sigh* So easy.
18:36:03 <glguy> func2 f g l = filter f (map g l)
18:36:09 <glguy> was that the original you were working on?
18:36:11 <syntaxfree> glguy, kilimanjaro: this is better for #haskell-blah
18:36:21 <|Steve|> Yeah.
18:36:27 <glguy> syntaxfree: don't worry about me :)
18:36:48 * syntaxfree has a vested interest in #haskell-blah growing because it's been increasingly a social outlet while talking shop has been hard lately.
18:37:21 <glguy> "talking about shop has been hard lately"?
18:37:26 * glguy joins #haskell-blah to find out more
18:37:28 <|Steve|> @pl func2 f g l = filter f (map g l)
18:37:28 <lambdabot> func2 = (. map) . (.) . filter
18:37:46 <syntaxfree> the mood swings. too hard.
18:37:47 <glguy> |Steve|: so you understand why that works then?
18:37:52 <syntaxfree> I haven't programmed in weeks.
18:38:01 <|Steve|> Oh come on, you have to be joking. No I haven't the slightest clue. flip filter map doesn't work at all.
18:38:08 <|Steve|> :t flip filter map
18:38:10 <lambdabot>     Couldn't match expected type `[a]'
18:38:10 <lambdabot>            against inferred type `(a1 -> b) -> [a1] -> [b]'
18:38:11 <syntaxfree> except for the allnighter where I came out with somewhat of a theorem prover, I could say I haven't programmed for months.
18:38:22 <glguy> func2 f g l = filter f (map g l)
18:38:29 <glguy> func2 f g = filter f . (map g)
18:38:40 <glguy> func2 f g = (.) (filter f) (map g)
18:38:48 <glguy> func2 f = (.) (filter f) . map
18:38:56 <rashakil> is there a name for binary search trees of the form, data Tree a = Leaf a | Branch Int (Tree a) (Tree a)?
18:39:07 <glguy> func2 f = (.) ((.) (filter f)) map
18:39:14 <glguy> func2 f = flip (.) map ((.) (filter f))
18:39:39 <glguy> func2 = flip (.) map . ((.) . filter)
18:39:41 <glguy> I think :)
18:39:47 * glguy goes off to check now that he's shared
18:39:58 <|Steve|> And flip (.) map is (. map)
18:40:03 <glguy> right
18:40:36 <|Steve|> Which leaves (. map) . ((.) . filter)
18:40:54 <wli> rashakil: They're binary tree analogues of nonempty lists like data NEL t = NELInj t | NELCons t (NEL t)
18:40:55 <|Steve|> Or (. map) . (.) . filter. Ugh.
18:41:00 <glguy> yeah
18:41:07 <glguy> (.) is associative
18:41:08 <wli> rashakil: I don't think there's a special name.
18:43:20 <rashakil> ok wli, thanks for answering :)
18:45:23 <glguy> |Steve|: Did you solve the remaining exercises?
18:46:25 <|Steve|> The remaining pointfree ones?
18:46:28 <glguy> |Steve|: rather, feel free to ask if you had any other questions 
18:46:31 <glguy> :)
18:46:37 <|Steve|> I will.
18:46:49 <|Steve|> I'm still trying to understand your entire derivation of the previous one.
18:47:01 <|Steve|> <glguy> func2 f = flip (.) map ((.) (filter f))
18:47:01 <|Steve|> <glguy> func2 = flip (.) map . ((.) . filter)
18:47:19 <|Steve|> I'm not seeing why two new compositions came into that.
18:47:24 <glguy> ok
18:47:41 <glguy> because f was nested two levels
18:47:58 <glguy> stuff (morestuff (yetmorestuff f))
18:48:49 <glguy> the first (.) gets a variable x to (morestuff (yetmorestuff f)) x
18:48:58 <shapr> gwaahr!
18:49:01 <glguy> where we are trying to replace this fake x with f
18:49:04 <ddarius> @src (->) fmap
18:49:04 <lambdabot> fmap = (.)
18:49:41 <glguy> and the second (.) takes the 'x' one level deeper : morestuff (yetmorestuff x)
18:49:58 <glguy> I guess that isn't really a good way to explain it ... but its how I think of it when making things point-free
18:50:32 <|Steve|> So f x = stuff (morestuff (yetmorestuff x)) --> f = stuff . morestuff . yetmorestuff?
18:50:40 <glguy> yeah
18:50:49 <|Steve|> Okay, that makes sense.
18:51:03 <|Steve|> Having . (.) . is confusing.
18:51:21 <glguy> yeah, its not something that you really look and and understand,
18:51:32 <ddarius> a -> a -> b = Functor f => f (f b)
18:52:16 <|Steve|> I don't think that func3 can be done with what has been discussed so far because it duplicates the l.
18:52:30 <Baughn> @pl f (a,b,c) = Meep a b c
18:52:30 <lambdabot> (line 1, column 11):
18:52:30 <lambdabot> unexpected "="
18:52:30 <lambdabot> expecting variable, "(", operator or end of input
18:52:36 <shapr> @seen dons
18:52:36 <lambdabot> dons is in #haskell-soc, #xmonad, #haskell and #ghc. I last heard dons speak 21m 16s ago.
18:52:38 <glguy> |Steve|: you'll need the (->) monad for that
18:52:47 <|Steve|> Okay, we haven't gotten there so that's good.
18:52:54 <|Steve|> @pl func3 f l = l ++ map f l
18:52:54 <lambdabot> func3 = ap (++) . map
18:53:21 <|Steve|> Heh, I never would have guessed that.
18:53:26 <glguy> func3 f l = l ++ map f l ; func3 f l = (++) l (map f l)
18:53:31 <glguy> there are a couple of ways to get there
18:53:35 <Baughn> @hoogle (a,b,c) -> c
18:53:36 <lambdabot> No matches, try a more general search
18:54:04 <|Steve|> I guess this stuff is easier if you make all of the infix operators prefix.
18:54:12 <|Steve|> It's too hard to think about infix this way.
18:55:06 <dons> shapr: ?
18:55:29 <glguy> func3 f = liftM2 (++) id (map f) -- liftM2 a id f == ap a f
18:55:50 <|Steve|> Doesn't help since I don't know what liftM2 does. I'll get there though.
18:56:14 <glguy> in (->), liftM2 f a b c = f (a c) (b c)
18:56:48 <glguy> in (->), ap f b = f c (b c)
18:56:54 <glguy> oops
18:56:58 <glguy> in (->), ap f b c = f c (b c)
18:57:04 <|Steve|> Oh, cool.
18:57:28 <shapr> dons: nothing, just curious :-) 
18:57:33 <glguy> (->) makes more sense if you learn MonadReader first
18:57:45 <|Steve|> Excellent, I think I got 4 right.
18:57:46 <Saizan> or SKI calculus
18:57:51 <glguy> the difference is that the "asks" becomes implicit
18:58:10 <|Steve|> func4 = map (+2) . filter (flip elem [1..10]) . (5:)
18:58:38 <|Steve|> @pl func4 = map (\y -> y+2) (filter (\z -> z `elem` [1..10]) (5:l))
18:58:39 <lambdabot> func4 = map (2 +) (filter (`elem` [1..10]) (5 : l))
18:58:49 * glguy was about to tell |Steve| about (`f` x)
18:58:57 * |Steve| already knew it.
18:59:01 <glguy> well then :)
18:59:04 <|Steve|> =)
18:59:31 <|Steve|> But I never thought to use it like (`elem` [1..10]) to make a section.
18:59:47 <|Steve|> @pl func4 l = map (\y -> y+2) (filter (\z -> z `elem` [1..10]) (5:l))
18:59:47 <lambdabot> func4 = map (2 +) . filter (`elem` [1..10]) . (5 :)
18:59:51 <|Steve|> There we go.
19:00:40 <|Steve|> Why is lambdabot using (2 +) instead of (+2)? Does it know about the commutativity of (+)?
19:02:10 <dons> yeah, it knows (maybe) 
19:02:10 <EliasAmaral> @seen EliasAmaral 
19:02:10 <lambdabot> You are in #haskell. I last heard you speak just now.
19:02:42 <|Steve|> @pl (2+)
19:02:42 <lambdabot> (2 +)
19:02:49 <|Steve|> @pl (2-)
19:02:49 <lambdabot> (-) 2
19:02:58 <dons> @pl (-2)
19:02:58 <lambdabot> -2
19:02:59 <glguy> dons: are you saying that that wasn't by design? ;)
19:03:01 <dons> @pl (- 2)
19:03:01 <lambdabot> -2
19:03:07 <dons> @pl (subtract 2)
19:03:07 <lambdabot> subtract 2
19:03:07 <glguy> you are looking for:
19:03:08 <|Steve|> @pl ((-) 2)
19:03:08 <lambdabot> (-) 2
19:03:12 <dons> @pl (2 `subtract`)
19:03:12 <lambdabot> subtract 2
19:03:15 <glguy> @pl (- (+2))
19:03:15 <lambdabot> negate (2 +)
19:03:18 <dons> i didn't design it :)
19:03:21 <glguy> @pl (- (2))
19:03:21 <lambdabot> -2
19:03:23 <glguy> heh
19:03:35 <|Steve|> Heh. Who did?
19:03:36 <dons> its Thomas Yaeger's rules system
19:03:37 <glguy> @pl (\x -> x - 2)
19:03:37 <lambdabot> subtract 2
19:03:45 <dons> he's know a maths major in the US somewhere
19:04:11 <glguy> oh, I remember:
19:04:17 <ddarius> (+) is not commutative
19:04:18 <glguy> ?pl (+ (-2))
19:04:19 <lambdabot> (-2 +)
19:04:20 <dons> Thomas Jäger
19:04:52 <|Steve|> ddarius: Why do you say that?
19:05:04 <dons> ?check \x y -> x + y == y + x :: Double
19:05:06 <lambdabot>  Couldn't match expected type `Double' against inferred type `Bool'
19:05:11 <dons> ?check \x y -> x + y == y + (x :: Double)
19:05:12 <lambdabot>  OK, passed 500 tests.
19:05:19 <dons> ?check \x y -> x - y == y - (x :: Double)
19:05:20 <lambdabot>  Falsifiable, after 0 tests: -2.0, 0.5
19:05:25 <ddarius> It's an operation in a type class.
19:05:41 <dons> you can always write a wacky instances. that's the basic issue :)
19:06:03 <dons> so you can only ever talk about '+ is commutative at a given type', since you're talking about a particular instance
19:06:12 <|Steve|> I think Num expects to be elements of a commutative ring.
19:06:50 <dons> I don't think that's stated anywhere though
19:07:24 <|Steve|> Probably not. It looked like that was the intention though. I wonder how @pl would handle it if you gave it something where that wasn't the case.
19:08:11 <|Steve|> Too much work to test it out though.
19:08:24 <dons> ah Thomas Jäger  Mathematics, Ph.D. is at MSU. 
19:08:37 <Olathe> O-o
19:09:13 <Olathe> Oh.
19:09:30 <Olathe> Thomas Jager, Mathematics.
19:18:44 <erider> test
19:18:49 <glguy> test
19:19:25 <|Steve|> > putStrLn "test"
19:19:30 <jcreigh> You fools! WOPR will kill us all!
19:19:30 <lambdabot>  <IO ()>
19:19:31 <glguy> test
19:20:03 <glguy> ?read "test"
19:20:03 <lambdabot>  test
19:21:44 <timthelion> to return an error to the caller of a function that returns information about a directory, is using maybe like this correct? -> IO Maybe DatedDirectoryOrFile
19:22:06 <glguy> IO (Maybe Date....(
19:22:07 <monochrom> IO (Maybe DatedDirectoryOrFile)
19:22:10 <glguy> )*
19:22:34 <timthelion> ok 
19:23:30 <monochrom> "return ___ to the caller of a function" is like "my son's parent" :)
19:23:58 <Saizan> mmh, in python you just raise an exception, in haskell you tend to embed errors in values
19:23:59 <timthelion> lol.
19:24:26 <timthelion> Saizan: exceptions are necesarily unpure, evil, and wrong.
19:24:35 <monochrom> You can also raise exceptions in Haskell, especially IO.
19:25:29 * timthelion hates it when he's using some obscure feature of a java app, and gets IO exception and the whole thing goes away, because of one rot en function.
19:25:55 <Saizan> monochrom: yeah, but it's not a common idiom
19:27:18 <monochrom> getChar does not say "IO (Maybe Char)" :)
19:27:29 <Saizan> well, this reduces to "we don't have a standard error reporting mechanism"
19:29:37 <stev> hello
19:30:13 <stev> I've spent my weekend working on Haskell
19:30:35 <monochrom> well spent
19:30:56 <stev> I feel that I'm not progressing as fast as I hoped
19:31:32 <monochrom> This is normal.
19:31:42 <stev> I've read "a gentle introduction" but I still see my code and it's never clever
19:31:54 <stev> my code never looks like the one that I see in haskell-cafe
19:31:54 <monochrom> Don't worry.
19:32:21 <stev> I was about to give up, but then I thought I would join and ask for advice
19:32:33 <stev> can you recommend me a good book that I can purchase?
19:32:45 <stev> I'm experienced at programming in other languages
19:32:50 <monochrom> You will get there. It takes time. This language is almost a complete break from the mainstream. Imagine learning Chinese.
19:32:52 <Binkley> code posted in haskell-cafe isn't always a good example to aim for :-)
19:32:54 <stev> and I've a reasonable knowledge of mathematics
19:33:20 <stev> monochrom: I feel like learning Chinese.
19:33:38 <monochrom> Remember: Learning is unlearning. :)
19:33:48 <monochrom> @quote unlearning
19:33:49 <lambdabot> No quotes match. You type like i drive.
19:34:04 <monochrom> @search unlearning
19:34:04 <lambdabot> Unknown command, try @list
19:34:34 <Saizan> stev: find a package that does something you're interested in and start reading the source/hacking on it
19:34:36 <Binkley> ?quote learn
19:34:37 <lambdabot> edwardk says: notes that in haskell, it seems that you asymptotically approach writing no code over time as you learn your way around whats already there
19:34:41 <monochrom> Somehow I learned Haskell from the Gentle Introduction.
19:34:56 <dons> stev: do you have some particular code you're wondering about?
19:34:57 <|Steve|> It's not very gentle as I recall.
19:35:10 <monochrom> No, not gentle. I call it to the point.
19:35:20 <dons> YAHT is usualy recommended these days
19:35:28 <dons> rather than the (not so gentle) intor
19:35:34 <Saizan> i'd reccomend wikibook over yaht
19:35:34 <stev> dons: not a particular snippet of code.
19:35:44 <stev> dons: what about a printed book?
19:35:47 <|Steve|> I'm really liking yaht.
19:35:58 <Binkley> stev: dons is working on that :-)
19:36:07 <monochrom> I did not learn all of Haskell from the Gentle Introduction. After it, I read some academic papers too, e.g., Wadler's on monads.
19:36:11 <dons> there's a few good intro books, see haskell.org 
19:36:23 <dons> ?where yaht
19:36:23 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
19:36:30 <dons> is good
19:36:36 <|Steve|> The only problem with yaht is it has too many forward references and it forgets to explain a few things.
19:36:46 <Saizan> the latest is Hudak's "programming in haskell" iirc
19:36:49 <glen_quagmire> i find yaht to be hard
19:36:52 <ddarius> I liked the Gentle Introduction.
19:36:53 <glen_quagmire> i liked wikibooks
19:37:01 <dons> you have ghc installed, stev?
19:37:10 <dons> Saizan: its Hutton's book :)
19:37:11 <|Steve|> Also, it seems to forget what was covered previously and restates stuff. But that was more in the early chapters. The later are better in that respect.
19:37:18 <glen_quagmire> there is a .txt file somewhere
19:37:36 <Saizan> dons: all those Hs!
19:37:45 <glen_quagmire> http://neugierig.org/software/darcs/haskell-for-programmers/haskell-for-programmers
19:37:48 <lambdabot> http://tinyurl.com/2ezmcm
19:37:53 <glen_quagmire> it's good in the beginning
19:38:10 <glen_quagmire> but wikibooks is more complete at this point
19:38:24 <stev> dons: ghc yes
19:38:24 <monochrom> Anyway, books: the wikibook ( http://en.wikibooks.org/wiki/Haskell ), Hudak's "The Haskell School of Expression", and Bird's "Introduction to Functional Programming Using Haskell"
19:38:27 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
19:39:46 <stev> I've heard great things about Bird's book. Some people called it a "classic", but I'm afraid it will teach me funct programming but not really Haskell
19:40:14 <dons> its a bit older
19:40:24 <dons> so maybe not as relevant to learning present day haskell
19:40:34 <dons> nice paper, on an unrelated note, http://programming.reddit.com/info/26ggs/details
19:40:35 <lambdabot> Title: Functional Pearl: The Genuine Sieve of Eratosthenes (pdf) (reddit.com)
19:40:48 <stev> dons: present day Haskell is Haskell 98?
19:41:27 <dons> H98 and later (new libraries, for example)
19:41:44 <dons> stev, what kind of tasks are troubling you?
19:41:54 <dons> mm_freak: see the above paper, btw, its nice!
19:42:06 <glen_quagmire> i wonder what it would look like if haskell had xml syntax
19:42:29 <dons> there's an xml embedding, going the other way, which is a bit nicer :)
19:43:18 <dons> http://okmij.org/ftp/Scheme/xml.html#typed-SXML
19:43:19 <lambdabot> Title: XML and Scheme
19:43:20 <glen_quagmire> <x><cons>1 x</cons></x>
19:43:49 <dons> scary
19:43:51 <stev> dons: I tried to write a program that grabbed RSS feeds off the web, collected the titles and the links and produced a nice html page. I spent 5 hours on it and didn't progress much. Went off for an hour, and decided to implement it in python. I took me 30 minutes. that was depressing.
19:44:20 <dons> did you have a tutorial? and which library?
19:44:33 <stev> no tutorial
19:44:35 <dons> its ok -- the abstractions are a bit different, and I guess you know python already
19:44:42 <stev> and doing the work from scratch
19:44:58 <stev> dons: yeah, I know python well
19:45:21 <Binkley> stev: for rss parsing, http://cale.yi.org/index.php/HRSS could be a good starting point
19:45:24 <lambdabot> Title: HRSS - CaleWiki
19:45:25 <dons> HXT is nice for this kind of thing, see above ^^
19:45:44 <Binkley> I'm playing with it right now, coincidentally
19:45:47 <dons> yes, http://cale.yi.org/index.php/HRSS is nice
19:45:54 <lambdabot> Title: HRSS - CaleWiki
19:46:02 <dons> stev, where'd you get stuck?
19:46:24 <dons> some other examples here, for that kind of thing, http://haskell.org/haskellwiki/Blog_articles/Web
19:46:25 <lambdabot> Title: Blog articles/Web - HaskellWiki
19:46:25 <stev> dons: but it's not the program in itself. It's the feeling that I never know how to set the program up or what's the right way to code in Haskell. It is my inexperience with it, no doubt. but I've found it to be much more challenging than other languages that I picked up in the past.
19:46:45 <glen_quagmire> first, do everything in do block. /me hides
19:47:07 <glen_quagmire> i'm being a bad troll
19:47:10 <dons> so i'd probably split it off into an IO block that grabs some text off the web, dump that into one of the xml parsers, walk the xml, building a list of urls or something, then process that with xhtml
19:47:21 <stev> glen_quagmire: all right. giggity giggity goo
19:47:25 <Olathe> I like how the Wikibooks thing says "If this command does not work, you are probably using hugs instead of GHCi, which expects a slightly different syntax.", but it doesn't give the slight difference.
19:47:39 <dons> Olathe: not 'let' bindings in hugs
19:47:56 <dons> > let f x = x ^ x in f 10 -- is how you instead bind in hugs
19:47:58 <lambdabot>  10000000000
19:48:10 <ddarius> Olathe: It's subtle persuasion to do the right thing.
19:48:11 <Olathe> Ahh.
19:48:15 <Olathe> ddarius: Heheh
19:48:33 <stev> I think I need a book that gives me real world examples to learn how to use Haskell in an idiomatic way
19:49:10 <dons> we do need such a book. yep. currently blog articles and wiki pages are probably the best bet for that. 
19:49:15 <dons> find something here, http://haskell.org/haskellwiki/Blog_articles
19:49:17 <lambdabot> Title: Blog articles - HaskellWiki
19:49:28 <dons> (such a book is being written, btw :)
19:49:50 <dons> stev, one issue would be that xml/rss/network stuff aren't really core language features, so you don't get the basics covered by doing that
19:49:55 <dons> you would get an idea of how to use some libraries
19:50:03 <|Steve|> glguy: I got caught up in other stuff for a while, but I've done func5 = flip foldr 0 . flip . curry, I believe.
19:50:04 <dons> but to learn how to glue libs together, you need the base language down first
19:50:21 <|Steve|> @pl func5 f l = foldr (\x y -> f (y,x)) 0 l
19:50:21 <lambdabot> func5 = flip foldr 0 . (. flip (,)) . (.)
19:50:34 <dons> so hmm, perhaps do start with yaht, doing mathy/exercises first? then you've got the glue to stick together libs for doing things like rss munging and other real world tasks
19:50:45 <dons> or maybe follow Cale's RSS tut ?
19:51:06 <dons> unless you wrote, for example, an xml or rss parser
19:51:18 <dons> that would cover the basics of the language: data types, recursion, pattern matching and so on
19:51:19 <|Steve|> Ugh. I can't tell if those are the same or not.
19:51:23 <stev> fons: that's good advice, I'll try that. Is Haskell good for Web programming (for example, if I were to become very proficient and wanted to use if for my web startup?)
19:51:46 <dons> good for munging/ processing/ hacking data in different formats, like xml , html and the like
19:51:54 <dons> not a lot of web frameworks stuff has been done, but that's growing
19:51:57 <Baughn> stev: It does tend to make security flaws less likely
19:52:13 <dons> it really depends on what you're doing 
19:52:31 <stev> dons: a web application?
19:52:44 <glen_quagmire> for web stuff, i think python is current best choice
19:52:49 <stev> dons: say Google or Facebook
19:53:01 <dons> so generating javascript, html stuff, database glue, handling concurrent requests?
19:53:07 <dons> or something running behind apache?
19:53:46 <dons> if i was going to do Facebook, I'd do it in Haskell, yeah, since the web stuff is easy, and the underlying logic would be nice and robust in haskell. But you'd want to know the language first
19:53:57 <glen_quagmire> there is 1 website built in haskell. there are 100000 of them in other languages. I find that following the norm is usually a good start, in the beginning
19:54:04 <dons> also, distributing across a cluster is fairly well understood in haskell
19:54:18 * geezusfreeek is in the early stages of an experimental web application in haskell
19:54:31 <geezusfreeek> it'
19:54:33 <dons> it would be safe to say web apps aren't haskell's niche at the moment. though people are working on that, esp. now web apps are getting so complex
19:54:41 <dons> you really want to do them in a safe, reliable, scalable way
19:55:00 <geezusfreeek> it's fun so far, even though i'm doing too much (starting with my own http server for the exercise)
19:55:19 <wli> Okay, now I have a data structure to track row operations and even interpret them.
19:55:51 <|Steve|> yaht has a bug (apart from using ' in several places where ` is meant). On page 81, it says, "What is happening is this: we create a value, call it $x$, which has value Red. We then apply this to colorToRGB. We check to see if we can "match" $x$ against Red. This match fails because according to thet definition of Eq Color, Red is not equal to Yellow."
19:56:21 <stev> dons: but if I get my Haskell skills at a high level, I could even contribute on my own to the improvement of web frameworks for Haskell right? :)
19:56:25 <|Steve|> It should say that it's matching against Yellow, not Red. I dunno who maintains yaht, but maybe that could be forwarded along.
19:56:33 <dons> stev, indeed.
19:56:48 <|Steve|> Er no, looks like x is supposed to have value Yellow.
19:57:09 <dons> I see no problems doing large web-ish systems in Haskell, assuming you are fluent in Haskell. all the building blocks are there
19:57:17 <dons> and you get to play with concurrency :)
19:57:33 <stev> dons: and in the startup that we are planning to start there will be a web application that will do a lot math crunching. I think Haskell is ideal for math applications.
19:57:44 <dons> that does sound promising, yes.
19:57:59 <glguy> |Steve|: I'm back now, did you figure out what you were asking me?
19:58:02 <dons> if its less web /javascript stuff, and more logic that has to be correct, haskell becomes more realisitc
19:58:09 <geezusfreeek> yeah, that's why i am particularly look at haskell for my own purposes too
19:58:14 <geezusfreeek> lots of crunching
19:58:23 * wli tries to take the gcd of a row of numbers.
19:58:24 <MarcWeber> stev: You can start by reading Wash, webfunctions and HaPPS source code ;) I still haven't finished doing this 
19:58:30 <dons> you might even use some other language framework for the front end, and do the serious application logic in haskell, where you must be correct
19:58:40 <|Steve|> glguy: I didn't figure out if they were the same no. But I think mine is correct.
19:58:55 <stev> that's a good idea dons. Like Django frontend, Haskell backend
19:59:03 <glguy> |Steve|: do you want to paste the two again?
19:59:10 <dons> yeah, esp. if you just want some page up and running, and know python.
19:59:14 <stev> or heck even Rails as frontend 
19:59:18 <glguy> and we can show why they are [not] the same?
19:59:21 <dons> then have the fast, native code haskell logic backend
19:59:23 <|Steve|> My claim is func5 = flip foldr 0 . flip . curry
19:59:33 <dons> so you don't have some interpreted language slowing down your basic application logic
19:59:44 * glguy is loading YAHT again
19:59:46 <|Steve|> @pl func5 f l = foldr (\x y -> f (y,x)) 0 l
19:59:47 <lambdabot> func5 = flip foldr 0 . (. flip (,)) . (.)
19:59:59 <dons> glguy: mauke (i think) was wondering about utf8 in hpaste.org today
20:00:01 <stev> ok. I need to be serious about Haskell. It's worth my time. I go back to study. Thank you for the encouragement, I was going to give up.
20:00:31 <dons> stev, hehe. do join in the community, that does help prevent burn out, and help keep you going in the right direction
20:00:59 <dons> I think learning haskell will pay off, pretty much no matter what. Even if it is just to learn about side effects and type systems :)
20:00:59 <glguy> |Steve|: so specifically that   curry is (. flip (,)) ?
20:01:11 <stev> dons: I will. thanks a lot. you have been very helpful.
20:01:31 <dons> that's the kind of newbie we like to see!
20:01:42 <jfredett> stev++
20:01:45 <|Steve|> Well flip . curry being (. flip (,)) . (.)
20:01:46 <jfredett> go stev!
20:01:47 <glguy> curry f x y = f (x,y) = f ((,) x y)
20:02:04 <glguy> curry f x = f . ((,) x)
20:02:22 <glguy> curry f = (.) f . ((,))
20:02:42 <glguy> curry = (.) ((.) f) (,)
20:02:59 <glguy> curry = flip (.) (,) . (.)
20:03:10 <|Steve|> You dropped an f too early, I think.
20:03:23 <glguy> oh? very possibly
20:03:30 <geezusfreeek> yeah, there is a free f in the second up from the last
20:03:44 <glguy> ah, ok, but if you imagine that I didn't
20:03:47 <glguy> the logic still works :)
20:03:52 <|Steve|> Okay.
20:04:30 <glguy> curry = ((,) .) . (.)  -- to ``simplify'' some
20:04:49 <wli> rowGCD a i = foldM gcdStep 0 [j_min..j_max] where { ((_, j_min), (_, j_max)) = bounds a ; gcdStep d j = readArray a (i,j) >>= return . gcd d }
20:05:24 <glguy> |Steve|: so yeah, you were correct :)
20:05:32 <|Steve|> Cool. Thanks.
20:06:10 <ddarius> :t uncurry (flip (,))
20:06:13 <lambdabot> forall b a. (a, b) -> (b, a)
20:06:21 <glguy> dons: what about utf8 in hpaste?
20:06:31 <dons> can we paste unicode?
20:06:41 <glguy> I don't see why we couldn't...
20:06:47 <dons> i agree!
20:06:49 <ddarius> It's clearly the syntax hilighter that is borked.
20:06:54 <glguy> oh
20:07:03 <glguy> that makes more sense
20:07:27 <glguy> seems like HAppS should be doing the encoding and decoding
20:07:41 <dolio> dons: What guidelines do you usually go by for using code from papers and such? I've been aggregating various delimited continuations stuff into a library, updating Oleg's version with stuff from the latest version of the paper (some of which strikes me as nicer), along with changes of my own, etc....
20:07:41 <glguy> rather than depending on the application to manually do it
20:08:20 <dons> hmm. check what the author releases them as? (you're talking about copyright?)
20:08:36 <glguy> ?djinn ( (a,b) -> c ) -> a -> b -> c
20:08:37 <lambdabot> Cannot parse command
20:08:37 <gnuvince_> In GHCi, is it possible to perform imports?
20:08:37 <lambdabot> f :: ((a, b) -> c) -> a -> b -> c
20:08:37 <lambdabot> f a b c = a (b, c)
20:08:47 <glguy> dons: why does ?djinn report that error?
20:08:47 <jfredett> :m <module>
20:08:49 <dons> gnuvince_: yep, :m + Foo
20:08:50 <jcreigh> gnuvince_: :m + Some.Module.Name
20:08:56 <dons> glguy: hmm, not sure
20:08:59 <gnuvince_> Thank you very much
20:09:00 <dons> ?djinn a -> a
20:09:00 <lambdabot> Cannot parse command
20:09:00 <lambdabot> f :: a -> a
20:09:00 <lambdabot> f a = a
20:09:03 <dons> strange
20:09:27 <glguy> ?. vixen . vixen vixen
20:09:29 <lambdabot> let's don't talk about that
20:09:44 * glguy wonders how that conversation went
20:09:46 <jfredett> @quote stereo
20:09:46 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
20:09:55 <dolio> dons: Yeah. One author doesn't really talk about it on his website. Another seems to have a standard ACM disclaimer, but it appears to be mainly concerned with distribution of copies of the paper itself.
20:10:20 <ddarius> Email the authors.
20:10:36 <dons> yes, you should mail them, and just say "I'm writing this library based on your paper"
20:10:40 <ddarius> Speaking of which, is Hinze's backtracking monad transformer already in some library somewhere?
20:10:46 <dolio> Ah, all right.
20:10:51 <dons> if you're using code directly, just check its ok to use the license you want
20:11:02 <dons> if you're implementing based on the paper, you might not need to relicense
20:11:33 <dons> ddarius: is that LogicT, or something else? I think only CChan's and Oleg's backtracking transformer is currently packaged
20:11:48 <ddarius> Something else.
20:12:05 <wli> I totally don't understand LogicT or LogicM.
20:12:20 <ddarius> wli: What's to not understand?
20:12:42 <wli> ddarius: Basics underlying the whole affair.
20:21:33 <SamB> wli: ... are they illogical?
20:24:46 <dolio> Oh hell, I just noticed on page 2 of the paper that it says the code is available under the MIT license.
20:25:03 <dolio> Good thing it took me so long to find their e-mail addresses so I didn't bug them.
20:30:07 <chadz> anyone use wxwidgets on windows with ghc>=6.6 ? 
20:33:34 <|Steve|> Heh, section 7.8 More Lists of yaht is, "todo: put something here."
20:53:47 <dons> ?userrs
20:53:47 <lambdabot> Maximum users seen in #haskell: 355, currently: 304 (85.6%), active: 7 (2.3%)
20:54:49 <jcreigh> ?uuusers
20:54:49 <lambdabot> Maximum users seen in #haskell: 355, currently: 304 (85.6%), active: 7 (2.3%)
20:55:05 <dons> ?uuuusers -- should be too much?
20:55:05 <lambdabot> Unknown command, try @list
20:58:41 <msouth> Hi, total newbie here.  I'm working through the variables and functions page of the wikibook and wondering why :t 25 is Num and if you let r=25 then :t r is Integer
20:59:07 <glguy> given: class Adder a b c | a b -> c, b c -> a, a c -> b
20:59:19 <glguy> is there a way to write: instance Adder a b c => Adder (Succ a) b (Succ c)
20:59:26 <glguy> that doesn't need undecidable instances?
20:59:32 <Binkley> msouth: let bindings have to be monomorphic, that is, have a single type with no type variables in it
20:59:37 <Binkley> er
20:59:44 <Binkley> that is, values that are let-bound
20:59:46 <Binkley> as opposed to functions
21:01:10 <glguy> Unless you give an explicit type definition, which allows you to override this restriction
21:01:17 <msouth> not that I understand what that means, but given that requirement it by convention says "if you give me a bare number in a let I'll choose Integer for the monomorphic type, and if it's got a .0 I'll choose double"?
21:01:54 <dons> yeah, when a monomorphic type is chosen, it will default to Integer or Double
21:02:00 <dons> :t 1.0
21:02:01 <lambdabot> forall t. (Fractional t) => t
21:02:04 <dons> :t let x = 1.0 in x
21:02:06 <lambdabot> forall t. (Fractional t) => t
21:02:09 <glguy> :)
21:02:16 <dons> boo.
21:02:25 <Binkley> msouth: yes, there are two different things going on -- first, the compiler will always try to pick a monomorphic type
21:02:28 <dons> but note it picked the Fractional class
21:02:32 <glguy> maybe lambdabot has -fno-monomorphism-restriction?
21:02:33 <dons> ?instances Fractional
21:02:34 <lambdabot> Double, Float
21:02:36 <Binkley> and separately than that, there are rules that say what the defaults are for number literals
21:02:43 <dons> it has -fextended-defaulting and -fglasgow-exts anyway
21:03:02 <dons> so that probably messes things a bit.*and* its wrapped in a `show'
21:03:37 <dons> :t let x = 1 in x
21:03:39 <lambdabot> forall t. (Num t) => t
21:03:40 <msouth> that's what ghci gives too
21:03:41 <dons> ?instances Num
21:03:42 <lambdabot> Double, Float, Int, Integer
21:03:46 <msouth> :t 1.0
21:03:48 <lambdabot> forall t. (Fractional t) => t
21:03:53 <msouth> oh, sorry
21:03:58 <msouth> it's doesn't say forall on it
21:04:04 <msouth> i was just looking at the fractional
21:04:14 <dons> so its constrained to either Double or Float, when in the 1.0 form, and then it'll default to Double
21:04:18 <msouth> sorry, I'm probably too new to be even asking these questions :)
21:04:24 <dons> no, ask away!
21:04:38 <glguy> msouth: You should ask questions before you know the answers
21:04:47 <glguy> once you know them you answer them :)
21:07:03 <RyanT5000> glguy: that reminds me of the old-style main :: [Response] -> [Request]
21:07:08 <wli> Are there any essential dependencies on the commutativity of multiplication in Num? e.g. rewrite rules depending essentially on them?
21:07:15 <RyanT5000> oh wait, it reminds me of the *opposite* of that :P
21:07:16 <dons> no.
21:07:30 <dons> there are no rules that I know of that depend on uncheckable properties of instances
21:07:35 <|Steve|> glguy: How does this sounds for concatMap f: concatMap' f = foldr (\a b -> (f a) ++ b) [] --> concatMap' f = foldr ((++) . f) [] --> concatMap' f = flip foldr [] ((.) (++) f) --> concatMap' = flip foldr [] . ((++) .)
21:07:48 <dons> though you can happily write them, they're wrong, since they'd break on new user instances that didn't follow the rules
21:07:57 <dons> for specific primitive types, ghc does know about such things
21:08:06 <dons> and you could write instances for say, Int.
21:08:14 <dons> but not polymorphic in the instances rules
21:08:54 <glguy> |Steve|: looks reasonable
21:09:12 <|Steve|> I think I'm starting to get the hang of this.
21:09:49 <|Steve|> Thank you for all the help.
21:10:06 <glguy> :-D
21:12:54 * |Steve| wants a copy of the latex for yaht and fix up all the bugs.
21:13:05 <|Steve|> Including using _|_ instead of \bot!
21:13:13 <glguy> not as much fun, but: concatMap = (concat .) . map
21:13:49 <|Steve|> why wouldn't it just be concat . map?
21:14:00 <glguy> good question, figure out why that is wrong :)
21:14:21 <|Steve|> Okay, I'll think about it. The exercise was to use foldr though.
21:14:26 <glguy> string from: concatMap f xs = concat (map f xs)
21:14:30 <glguy> starting from*
21:14:42 <glguy> |Steve|: sure, I'm just continuing the process :)
21:15:54 <dons> hmm, john harrop as jdh30 on reddit, saying that 'ocaml for scientists' is a great book. hmm
21:16:19 * glguy remembers that name from the Qi posts
21:16:27 <dons> yeah, he's a weird guy
21:16:31 <|Steve|> --> concatMap f = concat . map f --> concatMap f = (.) concat (map f) --> concatMap = (.) concat . map --> concatMap = (concat .) . map
21:16:37 <glguy> or "case studies" as they are claimed to be
21:17:14 <glguy> |Steve|: yeah, you need to move on to using the reader monad
21:17:22 <glguy> |Steve|: time to go to the next level ;)
21:17:24 <|Steve|> We used ocaml in my grad PL class.
21:17:54 <|Steve|> I'm getting there. I'm in chapter 8 now. But first I'm going to eat some dinner and watch some Star Trek.
21:18:01 <dons> glguy: yeah, case studies, i.e. silly shootout programs to start discussion and advertise his book
21:19:32 * glguy doesn't understand the merit of seeing who can write that expression simplifier that produces output the fastest
21:19:43 <glguy> only that which is the most clear to implement
21:26:07 <glguy> dons: I've read some of his stuff but never knew he had a book
21:26:15 <glguy> dons: so it wasn't that effective :)
21:27:32 <hpaste>  wli pasted "quick and dirty quaternions" at http://hpaste.org/1689
21:31:20 <wli> If Z[i,j,k] is Euclidean I don't know how division works in it.
21:32:02 <jfredett> only on #haskell could any paste about quaternions be described as "quick and dirty"
21:37:52 <cdsmith> Okay, so I'm thinking of going to AngloHaskell.  Should I?
21:38:07 <jfredett> anglohaskell is in europe, right?
21:38:09 <dons> sounds like an idea, if you want to meet and hear haskell talks
21:38:11 <pejo> cdsmith, the more the merrier!
21:38:23 <cdsmith> jfredett: cambridge
21:38:23 <dons> http://haskell.org/haskellwiki/AngloHaskell
21:38:24 <lambdabot> Title: AngloHaskell - HaskellWiki
21:38:26 <dons> jfredett: right.
21:38:35 <jfredett> because i would totally go, but I live very far from Cambridge.
21:38:49 <cdsmith> I'm deciding whether spending $1K on a plane ticket is the best thing for me now, though. :)
21:38:52 <dons> for those into coding for 3 days straight, the hackathon in Freiburg is a couple of months later, http://www.haskell.org/haskellwiki/Hac_2007_II
21:38:53 <jfredett> Like, ~5000 miles kinda far.
21:38:53 <lambdabot> Title: Hac 2007 II - HaskellWiki
21:39:24 <cdsmith> What is AngloHaskell?  I mean, what happens there?
21:39:45 <kilimanjaro> Tea and biscuits
21:40:12 <Binkley> And unicycling, judging from the pictures from the last one
21:40:29 <jfredett> unicycling, awesome...
21:40:34 <jfredett> someday I'll go.
21:40:39 <jfredett> but i have no money
21:40:46 <cdsmith> I have family around Cambridge, so it's relatively easy to justify going, I guess.
21:41:58 <cdsmith> Okay, I guess I'll go.  I'm just convincing myself, and I know I'll decide to go eventually.  Best just skip that step.
21:42:28 <Binkley> :-)
21:42:41 <Binkley> #haskell: helping you decide on doing what you already knew you wanted to do since 2002
21:43:13 <jfredett> yep.
21:43:17 <cdsmith> Should I think about doing a talk.  Like "My experiences as a Haskell newcomer... what worked; what would have helped"?
21:43:18 <Cale> wli: 2 = (1+i)(1-i) = (1+j)(1-j)
21:43:34 <Cale> Doesn't have unique factorisation.
21:44:36 <jfredett> cdsmith: why not?
21:44:56 <cdsmith> Well, I'm wondering if people who've been there think that's the sort of thing that would fit in.
21:45:34 <jfredett> To hell with fitting in, do it! 
21:46:51 <cdsmith> jfredett: :)  Well, I am sorta torn between wanting to contribute rather than just take advantage of others; and not wanting to compete with more interesting talks.
21:47:54 <jfredett> cdsmith: Well, firstly, the point of these conferences is precisely for people to take advantage of the knowledge of other people
21:48:12 <cdsmith> dons: the Hackathon sounds cool; but the schedule doesn't work out so well for me.
21:48:19 <jfredett> further, often, the most interesting talks at conferences are not given by the people who know the most
21:48:50 <kilimanjaro> Plus it's more exciting than sitting on IRC
21:48:58 <jfredett> but rather by those who know the least, but have a lot of enthusiasm about the subject
21:49:24 <cdsmith> kilimanjaro: Actually, I rather like IRC. :)
21:49:33 <jfredett> I went to a Mathematics Conference, and a Undergrad Junior gave a talk about some neat propertys of the Fibonacci sequence
21:49:39 <cdsmith> (Though #haskell is the only experience I have with it)
21:49:50 <jfredett> was it mathematically deep and revealing of some great truth?
21:49:52 <jfredett> not really.
21:50:12 <Cale> wli: You might find http://www.ams.org/bull/2005-42-02/S0273-0979-05-01043-8/S0273-0979-05-01043-8.pdf interesting
21:50:14 <lambdabot> http://tinyurl.com/2lmv68
21:50:25 <jfredett> was it the best talk of the day (other than the guy who used 50s era comic book pictures in his slideshow)? 
21:50:28 <jfredett> damn right it was
21:50:49 <cdsmith> jfredett: Sounds cool.  Fibonacci numbers are fascinating, too.
21:51:24 <jfredett> they are, but compared to the talks _i thought_ would be interesting
21:51:25 <kilimanjaro> jfredett, what was it about, in more detail if you don't mind?
21:51:35 <jfredett> eg the Riemann Hypothesis for Graphs
21:52:09 <jfredett> kilimanjaro: it was actually about deriving a closed form finding a given term of the sequence
21:52:29 <jfredett> using only counting arguments
21:53:02 <jfredett> it was nothing deep, but the way the student presented it was excellent
21:53:34 <Cale> What was the Riemann Hypothesis for Graphs?
21:53:43 <jfredett> Cale: really confusing
21:53:54 <Cale> I can imagine :)
21:54:04 * dolio rimshots.
21:54:16 <jfredett> the Professor who gave the talk was relatively good- but the subject was really deep
21:54:22 <jfredett> effectively, 
21:54:34 <jfredett> she had to define a kind of zeta function over graphs
21:54:44 <jfredett> she used the euler-product form of zeta
21:54:56 <jfredett> and then she was left to define "prime" graphs
21:55:12 <jfredett> which involved cycles and p-connected graphs
21:55:50 <jfredett> she was then able to use those facts, along with normal cartesian-products of graphs, to define the zeta of a graph
21:56:11 <jfredett> which lead to a translation of the RH
21:56:15 <Cale> Are there infinite graphs involved, or are these somehow finite?
21:56:48 <Cale> I can sort of imagine what 1/(1-p^-s) translates into, depending on how + is interpreted.
21:57:18 <jfredett> well- the whole theory boiled down to some relatively contrived matrices
21:57:33 <jfredett> basicly, she went through this whole explaination of prime graphs
21:57:38 <jfredett> dropped all that
21:57:49 <jfredett> and translated it to a problem of matrix-rings
21:57:50 <cdsmith> Well, good night everyone.  Thanks for the decision-making help. :)
21:57:54 <Cale> ah, okay, cool
21:58:02 <jfredett> it was well over my head
21:58:05 <jfredett> to be honest
21:58:26 <Cale> I have a hard enough time dealing with the ordinary zeta function :)
21:58:43 <jfredett> me too
21:58:44 <jfredett> :/
21:59:17 <jfredett> the riemann hypothesis is what got me interested in Math, but for the love of god, I never want to see it again
21:59:28 <Cale> Though I did manage to come up with Euler's product formula independently. It's obvious once you're looking at things the right way.
21:59:50 <jfredett> Cale: everything is obvious, if your looking at it the right way
21:59:52 <Cale> It basically expresses unique factorisation in the integers.
21:59:58 <jfredett> yep
22:00:12 <jfredett> hence the ramifications of RH on Factorization
22:01:00 <Cale> zeta is to Dirichlet series what 1/(1-x) is to ordinary generating series, and e^x is for exponential generating series.
22:01:22 <jfredett> yep. I hate calculus
22:02:16 <Cale> I found it curious at first that they used 1/n^s as a basis instead of just n^s, but of course, it's much harder to get convergence with the latter basis :)
22:02:31 <Cale> Hello dynamix.
22:02:35 <dynamix> hi Cale
22:03:00 <dynamix> i gave the sudoku thing a thought,  and want to discuss a little with you, can you come to the overflow?
22:03:06 <Cale> yep
22:04:59 * wli mutters something about ramifications of primes in Z[sqrt(-d)].
22:05:58 <wli> Cale: Not so hard. s < -1
22:05:58 <Cale> Man, if this number theory talk continues, I'm going to start having flashbacks to computing ideal class groups.
22:06:08 <wli> Dirichlet series, anyone?
22:06:42 <|Steve|> For a minute, I thought this was #math.
22:06:43 <Cale> wli: oh, right
22:06:50 <Cale> wli: duh :)
22:07:02 <Cale> Yeah, so why *do* they use 1/n^s?
22:07:21 <wli> Given Dirichlet series of fs :: [[Integer]] compute the product of the Dirichlet series.
22:07:51 <wli> For the case of two you get sum f(d)*f(n/d) where d ranges over all divisors of n.
22:08:06 <wli> with obvious extensions to n variables
22:08:33 <wli> function series of such types have to do with the convolution identities
22:09:19 <kilimanjaro> There's a #math channel, it's pretty popular
22:09:49 <chadz> populated by odd nerds.
22:10:12 <|Steve|> I'd take offense...if it weren't true.
22:10:26 <chadz> who else goes to haskell highschool?
22:10:32 <Cale> It's true, I am odd, there is one of me.
22:10:45 <Cale> > odd 1
22:10:47 <lambdabot>  True
22:11:05 <SamB_XP> > odd [Cale]
22:11:06 <lambdabot>   Not in scope: data constructor `Cale'
22:11:31 <chadz> > odd . length $ ["Cale"]
22:11:33 <lambdabot>  True
22:12:37 <chadz> i need some ammunition. every time i pimp haskell at work, people just tell me haskell's dead. citing the recent growth of #haskell doesn't seem to prove anything.
22:13:26 <kilimanjaro> chadz, try #smith-and-wesson
22:13:29 <msouth> physical beating is an option to consider early
22:13:36 <jfredett> do what i do, outcode there asses. 
22:13:37 <chadz> kilimanjaro: keke
22:14:22 <chadz> i think work needs to be done on improving HXT's deserilization
22:14:39 <shachaf> chadz: How is Haskell dead?
22:14:51 <chadz> shachaf: how is it not?
22:14:52 <shachaf> chadz: Has it ever been more alive than it is now?
22:15:15 <jfredett> ... ooh, Zen.
22:15:21 <mrd> well, Haskell is dead...
22:15:30 * chadz kicks Haskell.
22:15:32 <mrd> happens to everyone
22:15:41 <jfredett> mrd, brilliant
22:15:42 <jcreigh> Poor Mr. Curry.
22:16:52 <jfredett> "And thusly he died, having finally reached the point where the lazy evaluator that is life decided to resolve his function."
22:16:55 <shachaf> chadz: Besides, it's only mostly dead, and mostly dead is slightly alive. :-)
22:17:26 <chadz> haskell only needs two things:
22:17:34 <mrd> it'll be stone dead in a moment
22:17:40 <chadz> more industrial libraries (that are well maintained)
22:18:06 <chadz> and documentation that is more than just type regurgitations (that alienates all beginners)
22:18:19 <dons> libraries and docs are both happening. see hackage.haskell.org 
22:18:22 <chadz> yah
22:18:24 <chadz> hackage is good.
22:18:27 <dons> so i think we're getting on top of that
22:18:30 <mrd> i've been knee deep in gtk2hs and gtkglext all day
22:18:36 <chadz> but we need more things akin to parsec
22:18:43 <dons> yep
22:18:43 <chadz> and more apps akin to darcs, happs, etc.
22:18:53 <dons> yep
22:19:01 <dons> you've seen the mailing list growth?
22:19:05 <chadz> kudos for xmonad :)
22:19:16 <dons> yeah, that's an example.
22:19:23 <dons> there's also 4 haskell tutorials at OSCON this year
22:19:25 <dons> only 1 last year
22:19:27 <dons> none before that
22:19:32 <chadz> i still have to get it on my work machine. i just _hate_ having ot manage 18 different deps
22:19:40 <dons> corresponding with the mailing list growth, http://www.cse.unsw.edu.au/~dons/tmp/cafe.png
22:19:42 <chadz> dons: how's the book coming?
22:19:50 <dons> the spike in hackage libs (like 3-4 new libs a day ..)
22:19:59 <bos> it's going well.
22:19:59 <shachaf> dons: By how many people?
22:19:59 <dons> going well, yes.
22:19:59 <chadz> :)
22:20:12 <dons> http://hackage.haskell.org/packages/archive/recent.html
22:20:18 <dons> is very encouraging. 
22:20:43 <dons> as is the list of people able to contribute libs, http://hackage.haskell.org/cgi-bin/hackage-scripts/list-users
22:20:44 <lambdabot> Title: HackageDB: registered users
22:21:05 <Binkley> dons: that resembles the list of all wiki users :-)
22:21:14 <dons> its people who've asked for accounts to upload stuff
22:21:18 <dons> its a separate list.
22:21:23 <Binkley> hmm
22:21:24 <chadz> dons: i heard a package system was being built for hackage, is that true?
22:21:31 <Binkley> I'm on it, and I don't think I ever registered to upload stuff
22:21:33 <Binkley> but I don't know
22:21:37 <dons> package system in what sense?
22:21:46 <dons> cabal2deb or something?
22:21:47 <chadz> like ruby's gem thing
22:21:57 <dons> yeah, cabal + cabal-install is basically that.
22:22:11 <dons> since there's a standard package format, the cabal tar.gz bundle
22:22:15 <chadz> oh, slick.
22:22:17 <dons> and an install/dep chaser, cabal-install
22:22:27 <chadz> is it somewhat-safe yet?
22:22:40 <dons> yeah, beta testing, cabal-install. cabal packages themselves are solid.
22:23:42 <chadz> this makes me excited!
22:23:52 <dons> good!
22:24:12 <dons> libs growing rapidly, shared format, old stuff being ported to the new package system, auto documentation. its all in place
22:24:22 <dons> and we've even got people writing the code. 
22:24:26 <dons> so ... what are we waiting for !
22:24:51 <chadz> i also reccommend that soemone assumes the roll of reddit quality control :)
22:25:05 <dons> hah
22:25:11 <glguy> lol, reddit is beyond help
22:25:11 <Binkley> as in quality control of users?
22:25:22 <jfredett> reddit? quality? control? what?
22:25:48 <dons> yes, that sentence doesn't type check
22:26:02 <dons> No instance Quality Reddit
22:26:05 <chadz> hmm, too many haskell events occur in europe :(
22:26:21 <dons> US slackers and their python/ruby fetish ;)
22:26:31 <dons> gotta get some types up there.
22:26:37 <Binkley> dons: watch out what you say, you'll be one of us soon :-)
22:26:42 <glguy> dons: don't lay ruby on the US
22:26:46 <glguy> that's all the japanese's fault
22:26:47 <chadz> there's so many functional users in SeattlE!
22:26:52 <chadz> i know 2, including myself!
22:27:03 <jfredett> true that, one of these days, I'll organize HAY (Haskell America, Yeehaw.)
22:27:16 <jfredett> it'll be good, but for now, I'll just hack. :)
22:27:42 <dons> Binkley: safely landing in Portland, FPLand. :)
22:27:50 <Binkley> dons: well yes :-)
22:28:22 <chadz> dons: you're making the jump to portland?
22:28:35 <dons> yup
22:28:43 <chadz> dons: nice, congrats :)
22:29:11 <chadz> portland == europe++ == seattle--
22:29:37 <glguy> portland == europe == seattle, and then increment europe and decrement seattle??
22:29:54 <chadz> everyone ALWAYS has to mention that.
22:30:11 <chadz> the syntax is already broken :)
22:30:14 <Binkley> you're in #haskell, we care about semantics :-)
22:30:45 <bockmabe> chadz, I'm in seattle. Add one.
22:32:12 <chadz> @karma bockmabe
22:32:13 <lambdabot> bockmabe has a karma of 0
22:32:18 <chadz> @karma bockmabe++
22:32:19 <lambdabot> bockmabe++ has a karma of 0
22:32:28 <chadz> oh well, i forget the syntax.
22:32:43 <bockmabe> hehe
22:32:43 <chadz> @karma bockmabe +1
22:32:43 <lambdabot> bockmabe has a karma of 0
22:32:55 <shachaf> chadz: Just plain ("bockmabe" ++ "++").
22:33:02 <shachaf> chadz: Or @karma+ bockmabe.
22:33:13 <chadz> @karma+ bockmabe
22:33:13 <lambdabot> bockmabe's karma raised to 1.
22:33:24 <bockmabe> thanks, chadz
22:33:24 <mrd> what is a bockmabe
22:33:33 <chadz> anyone goes to SeaFunc?
22:33:33 <mrd> ah
22:34:21 <mrd> ack, i just typed xmonad keybindings on another computer and now its freaking out at me
22:34:23 <bockmabe> mrd, I take it I don't have to explain?
22:34:26 <bockmabe> hehe
22:34:50 <shachaf> mrd: I do that too. :-)
22:35:48 <bockmabe> chadz, I've had a friend or too that went when it was at the Stumbling Monk.
22:36:02 <bockmabe> I went once, but noone showed up :-(.
22:36:10 <chadz> bockmabe: sad :(
22:36:16 <bockmabe> yeh
22:36:19 <shachaf> bockmabe: I was wondering if it was worth the trip from Port Townsend, which is a bit long.
22:36:40 <bockmabe> from what I've seen maybe not.
22:36:58 <shachaf> bockmabe: By the way, I understand it's no longer at the Stumbling Monk -- if it was, I probably wouldn't be able to go.
22:37:09 <chadz> heh, i hear it's a good bar :)
22:37:10 <bockmabe> Oh, <21.
22:37:13 <bockmabe> ?
22:37:26 <shachaf> bockmabe: Yes.
22:37:39 <bockmabe> chadz, yes I do like it myself.
22:38:12 <bockmabe> Many Belgium style beers.
22:38:36 <chadz> yah. my coworker's been propping it.
22:40:35 <dons> btw, i just updated the list of OSCON talks and times, on the haskell.org frontpage.
22:40:51 <dons> in case people are wondering what to do july 23-25
22:41:03 <chadz> why are htey all in portland? :(
22:41:13 <dons> they like types up there
22:42:05 <dons> note well: http://conferences.oreillynet.com/cs/os2007/view/e_sess/14016
22:42:06 <lambdabot> Title: O'Reilly Open Source Convention 2007 &#8226; July 23-27, 2007 &#8226; Portland,  ...
22:42:11 <shachaf> Wasn't the last ICFP in Portland too?
22:42:12 <dons> :) `I'm going to use xmonad (http://xmonad.org) as my running example'
22:42:13 <lambdabot> Title: xmonad : a tiling window manager
22:42:26 <dons> Based on xmonad I will show you how to
22:42:26 <dons>     * write functional programs
22:42:26 <dons>     * test them using QuickCheck
22:42:26 <dons>     * write imperative programs
22:42:26 <dons>     * call foreign functions
22:42:29 <dons>     * use Haskell for scripting applications 
22:42:31 <dons> sounds like fun!
22:42:46 <chadz> does look like fun :(
22:42:53 <chadz> need to broadcast, or youtube it.
22:43:18 <dons> yeah, i've asked SPJ about that
22:43:25 <dons> haven't heard yet what the arrangments will be
22:43:27 <chadz> i watched marlow's talk on NDP and it was really slick.
22:43:37 <chadz> or was it spj, not sure
22:43:41 <chadz> forget, heh.
22:44:11 <dons> http://programming.reddit.com/info/26h85/comments ;)
22:44:12 <lambdabot> Title: OSCON 07: Haskell Tutorial (reddit.com)
22:45:03 <kowey> hey #haskellers, is there a way to type the equivalent of the following into ghci?
22:45:04 <kowey> r :: Num a => a
22:45:04 <kowey> r = 25
22:45:21 <kowey> I can do stuff like let foo = 25 :: (Num a => a)
22:45:24 <kowey> but not quite the same :-)
22:45:35 <shachaf> kowey: let r :: Num a => a; r = 25
22:46:09 <shachaf> kowey: In general, you can use ; and {} instead of indentation/newlines.
22:46:09 <kowey> ah, brilliant! thanks
23:40:33 <Cale> Category terrorists fly planes (http://en.wikipedia.org/wiki/Plane_%28mathematics%29) into buildings (http://en.wikipedia.org/wiki/Building_%28mathematics%29)!
23:40:35 <lambdabot> Title: Plane (mathematics) - Wikipedia, the free encyclopedia
23:41:51 <jfredett> aahh!
23:42:05 <jfredett> don't give bush any more reasons to fight terr.
23:42:38 <jfredett> Buildings had something t o do with the RH for graphs, actually,
23:42:43 <jfredett> though i cannot remember what.
23:44:01 <jfredett> anyway, goodnight folks
