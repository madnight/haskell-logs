00:00:03 <antonio-zen> dons: :-D
00:00:05 <dons> ?proton
00:00:05 <lambdabot> how do we automate ftp file transfers with haskell?
00:00:08 <dons> ?proton
00:00:08 <lambdabot> am I cracked?
00:00:13 <Syzygy-> By the way - trying to find the docs for nubBy by just typing it into google has unexpected results.
00:00:15 <dons> ?keal was the best
00:00:15 <lambdabot> can you make a macro that builds the expression accoridng to a genetic algorithm where you decide what is good and what is bad?
00:00:21 <Saizan> oerjan: in ghc it gives source location of the pattern
00:00:22 <glguy> dons: can we try /mode -c for a while, see if it gets abused?
00:00:35 <glguy> dons: seems like we could use the same measures against spam
00:00:41 <glguy> we don't +m the channel
00:01:02 <glguy> if for no other reason than to support the underline and bold codes
00:01:15 <opqdonut> :)
00:01:30 <opqdonut> ?protontorpedo
00:01:31 <lambdabot> is haskell going to rewite linux and make it better?
00:01:31 <dons> we've had colour headaches before though..
00:01:49 <dons> glguy: at least get the support of say the top 5 contributors
00:01:51 <dons> ?where irc
00:01:51 <lambdabot> I know nothing about irc.
00:01:54 <dons> or a majority of them
00:01:56 <dons> ?where stats
00:01:56 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
00:02:03 <dons> sorear, quicksilver, et al
00:02:12 <dons> i'm hmm, `ok' with trying it.
00:02:14 <glguy> dons: so I should wait until I get back into top 5 first? :)
00:02:26 <dons> yes, do a bit of branch stacking
00:02:29 <dons> and swing the vote
00:02:41 <dons> hang on .. we have a poll mechanism
00:03:00 <glguy> dons: does lambdabot count?
00:03:07 <glguy> because lambdabot is #1, and I am #6
00:03:19 <glguy> and if you are "ok", that's 2 of 5 so far
00:03:52 <dons> lambdabot doesn't count :)
00:04:01 <glguy> OK, so I need Cale, sorear, or quicksilver
00:04:11 <RyanT5000> so i wrote a module System.Random.MersenneTwister.MT19937; how do i go about submittting it?
00:04:12 <dons> maybe it should be 2/3rds majority
00:04:13 <glguy> hey, I'll even kick the abusers for you :)
00:04:13 <dons> or the top 20
00:04:22 <RyanT5000> and where?
00:04:22 * vincenz wonders if anyone knows a good piece of software to draw diagrams in Linux
00:04:33 <Syzygy-> vincenz: What kind of diagrams?
00:04:34 <boegel> vincenz: use OSX :P
00:04:36 <dons> vincenz: inkscape?
00:04:40 <opqdonut> vincenz: dia if you want a gui
00:04:41 <glguy> dia?
00:04:42 * Syzygy- tends to use xypic
00:04:44 <vincenz> Syzygy-: For the trees to show DTree and DDTREE
00:04:44 <wli> Commutative diagrams?
00:04:48 <dons> that's the big new thing in vector graphics.
00:04:48 <Syzygy-> boegel: Unhelpful kind of answer.
00:04:53 <oerjan> RyanT5000: that class would be useless for the purpose of giving meaningful error messages in ordinary pattern matching code
00:04:58 <vincenz> dons: I know, but it's great for fancy stuff but not for diagrams
00:05:01 <vincenz> opqdonut: dia = ugly
00:05:10 <vincenz> I tend to use oodraw
00:05:18 <glguy> dons: you let vixen flood the channel :-p
00:05:19 <vincenz> but I was hoping for something more visio-like
00:05:21 <RyanT5000> oerjan: why? IO could implement it and it'd be just like the situation now, right?
00:05:23 <opqdonut> i just use the different tex packages
00:05:28 <oerjan> it needs to be in the class used by the actual syntactic sugar
00:05:36 <vincenz> Syzygy-: btw, I noticed an issue with DDTree
00:05:44 <Syzygy-> vincenz: Huh?
00:06:15 <RyanT5000> oerjan: the syntactic sugar of pattern matching can't use Monad either, or i wouldn't be able to pattern match in pure code
00:06:16 <oerjan> RyanT5000: it cannot implement it, because the pattern matching failure may come from something that is polymorphic over the monad
00:06:26 <edwardk> it appears that it would be a euclidean semiring. bah for complicated terms in the prelude =)
00:06:27 <Pseudonym> Damn, I don't even make the list for 2007.
00:06:33 <dancor> if Text.PrettyPrint.HughesPJ is in pretty-1.0 and base.. how does that work
00:06:53 <oerjan> RyanT5000: the syntactic sugar has different rules in monadic <-
00:06:54 <glguy> RyanT5000: only pattern matching failures in: pattern <- expression   are caught
00:07:04 <dancor> i guess i need to upgrade base?
00:07:12 <glguy> do let [] = [x] -- wouldn't cut it
00:07:22 <Saizan> oerjan: a refutable pattern match in a do block could introduce a DescriptiveFailureMonad constraint
00:07:52 <dons> glguy: yeah, i'd be up for disabling vixen
00:07:59 <dons> Pseudonym: you must have a job? :)
00:08:08 <Pseudonym> I must.
00:08:12 <RyanT5000> glguy: hm, i didn't realize people made use of failed pattern matches with <-
00:08:16 <Pseudonym> Or I must be working harder at this one than in previous years.
00:08:27 <vincenz> Pseudonym: which list?
00:09:02 <Pseudonym> http://www.cse.unsw.edu.au/~dons/irc/
00:09:02 <lambdabot> Title: Haskell IRC Activity
00:09:35 <glguy> RyanT5000: it can be really useful, especially in Maybe where the point is to propagate failure
00:09:54 <opqdonut> what would be the easiest way to read a tab-separated table into for example a list of tuples?
00:10:10 <RyanT5000> glguy: yeah, seems like it could be
00:10:50 <RyanT5000> i dunno, i just can't help hating String there
00:11:26 <RyanT5000> even if it were some kind of data MonadicPatternMatch i'd be happier
00:11:39 <RyanT5000> something that wasn't such a general and unrelated concept
00:12:00 <oerjan> Saizan: that would defeat the purpose of the class, because then you would have to define fail with String in Maybe etc.
00:12:06 <RyanT5000> also, is there some reason the syntactic sugar needs to use the Monad class itself?
00:12:27 <Pseudonym> Actually, making a PatternMatchFail data type isn't such a dumb idea.
00:12:30 <RyanT5000> class Monad m => MonadSugar m where ...
00:13:31 <glguy> any brief recommendations on a good window manager (non-tiling.. I already know plenty of good tiling managers)
00:13:46 <RyanT5000> glguy: what's your favorite tiling window manager?
00:13:50 <glguy> dwm
00:14:05 <glguy> I'll have to run xmonad at some point
00:14:14 <RyanT5000> hm; i used ion for a while but then i didn't want to deal with the annoyance of things not expecting it
00:14:18 <glguy> ion3 is nice too
00:14:26 <RyanT5000> i really liked it for some stuff
00:14:33 <opqdonut> ion3 is great
00:14:36 <glguy> I use: xterm, firefox, and that's about it :)
00:14:42 <RyanT5000> but, e.g. gimp runs like crap on it
00:14:46 <RyanT5000> (not that i use gimp much)
00:14:56 <glguy> RyanT5000: that isn't ion's fault though :)
00:15:03 <RyanT5000> glguy: i'm not assigning blame :P
00:15:17 <glguy> RyanT5000: I mean, not WM specific :)
00:15:18 <RyanT5000> are any of you familiar with Coase theorem?
00:15:18 <oerjan> RyanT5000: i believe it once used MonadZero, which was removed.
00:15:18 <opqdonut> glguy: for non-tiling, i'd suggest *box and evilwm
00:15:45 <engstad> Has anyone heard of the Haskell like language "hobbit"?
00:15:52 <glguy> my needs are quite small, I like a shortcut for "new xterm" and one for "run dialog"
00:16:02 <RyanT5000> it's a theorem of economics, which won the nobel prize
00:16:13 <wli> RyanT5000: Which is that?
00:16:17 <vincenz> damn, I've been bumped on the list
00:17:24 <dons> engstad: nope.
00:17:38 <engstad> I just made Haskell's layout logic in OCaml. :-)
00:18:03 <vincenz> engstad: using camlp4?
00:18:11 <RyanT5000> Coase theorem - it basically states that if person A is harming person B, then, assuming it costs nothing for them to negotiate a contract around it, it doesn't matter whether the law gives A the "right to harm" or gives B the "right to not be harmed"
00:18:13 <engstad> Nope.
00:19:03 <engstad> val layout : modified list -> context list -> Lexer.token list
00:19:39 <engstad> It's crazy stuff. :-)
00:19:55 <RyanT5000> if the harm gives A X dollars of benefit, and hurts B Y dollars, then if Y > X, B will be able to pay A to not do it (some amount between X and Y)
00:20:28 <RyanT5000> if X > Y, B would rather bear the harm than pay A to stop it
00:20:28 <Pseudonym> That sounds like the broken window fallacy to me.
00:20:31 <engstad> Now, I'm trying to understand the grammer. Trying to implement the Haskell grammer using Dypgen.
00:20:38 <RyanT5000> so, either way the most efficient result obtains
00:20:42 <wli> lhs2TeX --poly is broken here.
00:21:06 <oerjan> engstad: you are aware of the ParseError rule in haskell layout?
00:21:16 <engstad> Yes, but there's a work-around.
00:21:32 <wli> engstad: There is?
00:21:36 <Pseudonym> Ryan: This is also known as the "Fat Tony Employment Theorem", clearly.
00:21:49 <engstad> You can look one ahead (check for 'in' and 'let', and then you don't need to consult the parser.
00:22:11 <wli> engstad: Sounds like a different problem from lhs2TeX being nonfunctional.
00:22:32 <Pseudonym> Ryan: It also assumes that you can put a dollar amount on harm.  How much would you pay not to be killed?
00:22:40 <RyanT5000> Pseudonym: it's not the broken window fallacy, and, unless i'm explaining it incorrectly, i doubt it has *any* fallacy, since it won Coase the nobel prize
00:22:56 <goltrpoat> i'm not sure if ryan is explaining this properly.
00:23:03 <glguy> RyanT5000: maybe it did them less harm to give him the prize
00:23:05 <oerjan> engstad: i do recall someone trying to find a simple set of equivalent rules of that kind.  I didn't have the impression they succeeded completely.
00:23:07 <Pseudonym> Oh, I see.
00:23:10 <glguy> RyanT5000: than to not, and have him fight it
00:23:16 <RyanT5000> lol
00:23:28 <RyanT5000> Pseudonym: i'll see if i can explain more
00:23:29 <Pseudonym> What it _actually_ says is that in the absence of transaction costs, all government allocations of property rights are equally efficient.
00:23:50 <engstad> oerjan: They ran it through ghc's tests, and it worked fine except for some lexer errors, due to using Alex.
00:23:59 <glguy> Pseudonym: but does it typecheck?
00:24:01 <goltrpoat> the idea is that if i open a store down the street from you, then it ultimately doesn't matter if we're competing for the same market.
00:24:21 <engstad> oerjan: Besides, I don't need it to work 100% for my purposes - I'm not writing a Haskell compiler!
00:24:23 <RyanT5000> Pseudonym: how's that different from what i said?
00:24:32 <glguy> shorter for one :)
00:24:36 <RyanT5000> that's true
00:24:39 <Pseudonym> Because you stated it in terms of "harm".
00:24:40 <oerjan> engstad: indeed.
00:24:47 <Pseudonym> I thought like a mob extortion racket.
00:24:51 <engstad> oerjan: Actually, I'm writing a low-level assembler. :-)
00:25:04 <Pseudonym> You're actually talking about economic competition.
00:25:06 <RyanT5000> Pseudonym: it's equivalent; but your explanation is definitely more concise
00:25:44 <Pseudonym> The trouble is that there are many markets where margins are so thin that transaction costs dominate.
00:25:48 <RyanT5000> the first example Coase gives is a rancher who allows his livestock to graze on someone else's land
00:25:57 <Pseudonym> Internet radio being one obvious topic example.
00:26:03 <Pseudonym> topical
00:26:21 <RyanT5000> so i remember it based on harm :P
00:26:44 <RyanT5000> whether A is harming B or B is harming A is basically a question of perspective
00:27:11 <goltrpoat> modulo transaction costs.
00:27:16 <engstad> Hmm, how can I nicely define a "label" within the Haskell syntax?
00:27:28 <Pseudonym> The theory is specifically about a scarse resource that needs to be allocated.
00:27:34 <oerjan> engstad: my thoughts at the time is that if not doing it carefully, the resulting rules might actually be harder to understand for humans.
00:27:38 <oerjan> *was
00:27:40 <Pseudonym> By the look of it.
00:27:40 <edwardk> hrmm, for simple times through iterated addition, ala how ^ is iterated multiplication but for + not *, which seems better some sort of times :: a -> Natural -> a  or a (.*) :: Natural -> a -> a  ? the latter would enable you to capture the (5 .*) kind of thing and seems to better define the function, the former seems to avoid introducing a weird symbol
00:28:02 <glguy> Pseudonym: like CPU time?
00:28:08 <Pseudonym> Yeah.
00:28:11 <RyanT5000> Pseudonym: yeah
00:28:29 <engstad> oerjan: Seems to run through all of the code that I have available. I run it through my layout engine, and then pipe it into 'ghc', and it compiles fine.
00:28:30 <Pseudonym> OK, that makes sense.
00:28:32 <edwardk> it becomes more important in my case because having (+) doesn't automatically imply you have a fromInteger
00:28:44 <edwardk> (and a * for that matter)
00:28:47 <goltrpoat> edwardk:  what does * imply
00:29:09 * DRMacIver glares at dibblego
00:29:15 <RyanT5000> *anyway*, the window manager / gimp fight was reminding me of coase theorem
00:29:31 <edwardk> goltrpoat: basically been toying with a much-more-numerical prelude. at the moment (*) requires the presence of another typeclass that you can't guarantee is present given just an additive monoid
00:29:37 <RyanT5000> another thing equivalent to "allocation of property" is "allocation of liability"
00:29:53 <goltrpoat> edwardk:  yeah i figured you were talking about the much-more-numerical prelude bit :)  i think we've talked about that a while back
00:30:09 <edwardk> but if i know you have zero and (+) i can define a limited notion of multiplication by a Natural
00:30:16 <oerjan> engstad: what i mean is that if they are only _nearly_ equivalent, it might be hard for people to understand what happens when the equivalence breaks
00:30:24 <engstad> I suppose I can do:  do { label start; ld reg mem 0; j start }
00:30:40 <wli> I've narrowed it down to \<
00:30:52 <wli> Whatever \< is, texlive thinks it's undefined.
00:30:52 <engstad> oerjan: True.. I'll have to be aware of it.
00:30:59 <edwardk> presuming associativity on (+) so you can do it fast anyways
00:33:00 <Pseudonym> What I'd really like is a code generator framework.
00:33:05 <goltrpoat> edwardk:  is this just a syntactical thing?  a (.*) n = foldl1 (const . (+a)) [0..n] type deal?
00:33:15 <Pseudonym> So you could, for example, do peephole optimisations before compiling.
00:33:23 <goltrpoat> er.  a .* n rather
00:33:51 <edwardk> actually i go through and divmod the natural all, and use the faster form relying on associativity of the + operator
00:34:09 <edwardk> so its non-trivial enough to be a speed win in the general case
00:34:17 <engstad> Pseudonym: That's possible if the compiler give you access to it's code transformations. But... I don't think Haskell was designed that way.
00:34:52 <wli> Yeah, it's pretty hopeless.
00:34:59 <edwardk> 5 .* a = let aa = (a + a) in (aa + aa) + a
00:35:28 <edwardk> so on and so forth
00:35:40 <goltrpoat> well, whatever you call it, don't call it (*) :)
00:35:41 <edwardk> like (^)
00:35:48 <edwardk> not planning on it =)
00:35:53 <Pseudonym> engstad: I mean a high-level representation which you could then feed to Harpy.
00:36:02 <edwardk> just looking for what the additive equivalent of (^) and (^^) should be called
00:36:18 <Pseudonym> [ Label "foo", Push ECX, Jmp "foo" ] would be fine
00:36:33 <augusts> People have sometimes named scalar multiplication .* in Haskell
00:36:34 <edwardk> since they can be defined for an arbitrary additive monoid or additive group respectively
00:37:03 <edwardk> augusts: hrmm
00:37:21 <edwardk> ah yeah, it is just a form of scalar multiplication
00:37:21 <wli> Something you can prove more invariants about might help a little.
00:37:31 <augusts> it is scalar multiplication
00:37:39 <edwardk> yep
00:37:58 <edwardk> ok, hrmm then the equivalent form for (^^)
00:38:22 <edwardk> where it can be a negative multiple?
00:38:53 <edwardk> ..* would be getting kinda silly =/
00:39:07 <oerjan> edwardk: it seems to me you really would want some way to make the constraints of one type dependent on the value of the other, so that you could have just one operator
00:39:12 <wli> [Label "foo", PushInt 5, Unwind]
00:39:17 <engstad> Pseudonym: A list? Perhaps...
00:39:22 <edwardk> oerjan: i'd lose type inference in too many cases
00:39:29 <goltrpoat> it's not the same operator
00:39:32 <Pseudonym> The other thing that annoys me about Harpy is having to preallocate the buffer.
00:39:43 <edwardk> oerjan: i'd lose the ability to push types 'in' form the outside of a multiplication expression
00:40:01 <edwardk> see the earlier discussion/ramblings on parametric restricted monads =)
00:41:01 <wli> Debugging lhs2TeX sounds painful.
00:41:58 <edwardk> @src (^)
00:41:58 <lambdabot> Source not found. The more you drive -- the dumber you get.
00:42:03 <edwardk> @src Int (^)
00:42:03 <lambdabot> Source not found. My mind is going. I can feel it.
00:42:15 <edwardk> @src (^) Int
00:42:15 <lambdabot> Source not found. My mind is going. I can feel it.
00:42:18 <edwardk> bah
00:42:33 <kosmikus> wli: good morning. what's the problem with lhs2TeX ?
00:42:52 <goltrpoat> edwardk:  (^) or (^^) ?
00:42:58 <edwardk> @type (^)
00:43:01 <edwardk> @type (^^)
00:43:07 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
00:43:08 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
00:43:13 <goltrpoat> i don't know how much you want to emulate the latter
00:43:37 <edwardk> oh wait, the latter is just for fractional
00:43:47 <wli> kosmikus: Basically none of the options except --verb work. A bunch of macros/etc. come out undefined.
00:43:48 <goltrpoat> since Fractional is a division algebra, sort of, only not, wink wink nudge nudge.  and all you need is a multiplicative group.
00:43:53 <edwardk> i can live without negative multiplers, just negate after, duh
00:43:54 <edwardk> ok
00:43:54 <engstad> Well, the compiler's representation will be a list... but the _language_ isn't Haskell, it is a very advanced macro assembler (possibly with types and other goodies).
00:44:03 <oerjan> edwardk: i remember the other day (^) is not in @src because it's too long
00:44:14 <oerjan> *from
00:44:39 <kosmikus> wli: what do you %include ?
00:44:46 <wli> kosmikus: polycode.fmt
00:45:02 <kosmikus> wli: ok, and what's undefined in --poly ?
00:45:36 <wli> kosmiku: Either \< or \> I think \<
00:45:44 <oerjan> edwardk: perhaps some principled way of adding modifiers to operators, then, like *'monoid ? (probably replace monoid by something shorter)
00:45:53 <kosmikus> wli: oh. that's surprising.
00:46:41 <oerjan> ideally the modifiers would be first class context sets
00:46:45 <wli> kosmikus: I think it has something to do with the tetex -> texlive move in Debian.
00:46:47 <edwardk> oerjan: not sure. i think i've resolved the immediate crisis anyways =) just adding a notion of a vector space then using .* over the implied one
00:47:00 <kosmikus> wli: coud very well be.
00:47:32 <goltrpoat> edwardk:  you mean module, not vector space, no?
00:47:33 <wli> kosmikus: What are \< and \> ?
00:47:50 <edwardk> er yeah
00:48:05 <kosmikus> wli: that's why I said it's surprising. I wasn't aware of these being used by lhs2TeX.
00:48:13 <engstad> So, for instance, if you define: struct Vec4 of align 16 where { x :: Float32; y :: Float32; z :: Float32; w :: Float32 }, then would correspond to a 16-byte aligned 4-vector, amenable for simd instructions.
00:48:43 <wli> kosmikus: The first place I see it is in the inlinehscode definition, but it's used in hscode as well.
00:48:44 <kosmikus> wli: ah, no. forget what I said. this is really strange.
00:48:58 <kosmikus> wli: what does "kpsewhich polytable.sty" say?
00:49:04 <wli> kosmikus: Rather, it's used within an hscode block.
00:49:33 <wli> kosmikus: Aha, it turns up the wrong polytable.sty
00:50:03 <kosmikus> wli: ok, so that's probably the problem.
00:50:36 <kosmikus> or one of the problems
00:50:36 <wli> Now how do I update it...
00:50:53 <kosmikus> erm, so debian did deliberately install the wrong one?
00:51:20 <wli> kosmikus: No, it's from a time predating the Debian package in /usr/local/
00:51:33 <kosmikus> and you have the right one already installed?
00:51:47 <wli> kosmikus: yes, I just had to move the wrong one out of the way
00:51:56 <kosmikus> you delete the one in /usr/local and run "texhash"
00:52:16 <wli> kosmikus: yes
00:52:27 <kosmikus> does that work for you?
00:52:42 <wli> kosmikus: It's working now. Thanks a bunch!
00:52:48 <kosmikus> ok, great
00:52:57 <kosmikus> so not even debian to blame here ;)
00:53:14 <wli> Apparently merely my own stupidity.
00:53:40 <kosmikus> nah, /usr/local is tricky. I think everyone runs into that problem on a Linux distribution sooner or later.
00:53:40 <wli> Back to my Pade/Hermite garbage.
00:53:46 <edwardk> technically i think i need classes for left and right scalar multiplication, ala the Add (+) magma classes, then to build modules and vectorspaces off of those to keep from overconstraining the types
00:54:00 <glguy> kosmikus: which problem? (I missed the original question)
00:54:47 <kosmikus> glguy: you discover something's not packaged in your linux distro, install it to /usr/local. then you install it via your distro to /usr later, but stuff from /usr/local is still picked up by some parts of the program.
00:54:58 <engstad> My Debian has screwed up xemacs' haskell-mode... :-/
00:55:01 <glguy> kosmikus: ahh
00:55:11 * glguy had that with GHC
00:55:12 <kosmikus> glguy: because often, /usr/local comes after /usr in PATH and similar envvars
00:55:29 <kosmikus> wli: ^^ see? you're not the only one. me too, more than once.
00:55:29 <glguy> /usr/local is earlier in PATH than /usr on Gentoo by default
00:55:44 <kosmikus> eh, that's what I meant.
00:55:46 <wli> edwardk: Maybe universal algebra might be a better context in which to think of these things?
00:55:50 <kosmikus> s/after/earlier/
00:56:13 <glguy> does anyone here use mpd?
00:56:20 <goltrpoat> edwardk:  how's the language going btw?
00:56:20 <edwardk> maybe. my main issues have been wrapping haskell typeclasses around it and keeping it inferrable
00:56:57 <edwardk> goltrpoat: really quite well actually. this current effort just happens to be transcoding a good chunk of the standard library back to haskell to get a good feel for how sound parts of it are
00:57:22 <edwardk> because there are large parts i can't test in it yet, but otherwise its proving to be more inferable than i feared.
00:57:40 <goltrpoat> edwardk:  ah cool.
00:58:42 <goltrpoat> weren't you putting together a substructural type system?
00:59:03 <goltrpoat> or.. well.. linear, i think, is what we were talking about
00:59:29 <goltrpoat> i remember going back and reading a good ten papers in a row after that last conversation, so it's all a bit of a blur.
00:59:33 <edwardk> goltrpoat: yeah, vestiges of it are still there, but its proven to be less useful for the rest of the language features
00:59:49 <goltrpoat> ah
00:59:50 <edwardk> its generally substructural, not linear. relevant, affine, uniqueness, etc.
01:00:10 <goltrpoat> gotcha
01:00:59 <oerjan> edwardk: "basic" logic?
01:01:08 <edwardk> in general polymorphic substructural records are weird =) once you start labeling multiplicative and additive conjunctions and disjunctions and have different usage guarantees on different fields, etc.
01:01:15 <edwardk> oerjan: you mean linear?
01:01:49 <oerjan> edwardk: no a kind of lowest common denominator for linear and quantum logic
01:02:01 <edwardk> not sure i'm familiar
01:02:23 <wli> edwardk: Let's say you have a free algebra with various constant and operator symbols. From there you can just drop in proof burdens relating various of them.
01:02:56 <edwardk> right now i just track a sort of lattice of context reduction constraints of forward and backwards constraints on usage giving rise to relevant, affine, linear, unrestricted, uniqueness, uniqueness and relevant, etc.
01:03:12 <edwardk> wli: ah
01:03:21 <kolmodin> ?tell sjanssen sounds like a good idea. how would you propose to do it?
01:03:21 <lambdabot> Consider it noted.
01:03:31 <edwardk> i'm not quite so liberal =)
01:03:47 <oerjan> edwardk: google for basic-logic quantum
01:03:51 <edwardk> k
01:03:56 <wli> edwardk: I'm not sure it's so much a question of liberality as forward progress.
01:04:43 <edwardk> adding it to the reading list
01:04:48 * glguy determines that mpd is awesome
01:04:56 <wli> glguy: What's mpd?
01:05:00 <glguy> music player daemon
01:05:13 <glguy> it streams my internet radio (or any music file for that matter)
01:05:15 <edwardk> i spent a lot of time working under display logic through curry-howard to see if i could use it as the basis for a type system, kind of a step in that direction
01:05:22 <glguy> and doesn't go away when I log out, etc
01:05:28 <glguy> can be controlled remotely
01:05:28 <edwardk> but with one big gotcha on the structure of the constraints you can introduce
01:05:33 <glguy> manages playlists
01:05:37 <edwardk> well several actually
01:05:44 <glguy> has commandline and gui clients
01:09:10 <oerjan> glguy: and they pay you how much? :D
01:09:12 <dons> kolmodin: after that thread today about serialisation, we pushed a patch to avoid calling 'length' when serialising arrays
01:09:26 <wli> It seems like the way to interpret universal algebra is to have an n-parameter type class for each n-ary operation to generate the free algebra on those n-ary operations.
01:09:28 <glguy> oerjan: yeah, we never got to that part of the discussion...
01:09:36 <dons> sometime we should look again at how best to serialise arrays
01:09:37 <glguy> oerjan: you think maybe I got cheated?
01:10:02 <oerjan> glguy: quite possible.
01:10:31 <wli> Expressing invariants seems to require method-free instances but there's no obvious way to express the property unless you can somehow tag the things with a relation.
01:11:43 <wli> edwardk: Maybe if you're doing a language from scratch you could have those method-free instance declarations expressing relations/invariants called something else.
01:12:15 * glguy should have used screen... needs irssid
01:12:36 <wli> edwardk: And maybe have some way to express relations/invariants/etc.
01:13:21 <glguy> oerjan: have you heard of screen? ;)
01:13:24 <glguy> it slices and dices
01:13:25 <wli> edwardk: Maybe they could be interpretable as rewrite rules or things to dynamically check if debugging flags are turned on.
01:13:41 <glguy> I'd recommend it to anyone
01:13:50 <wli> screen is such foul code; there should be a from-scratch rewrite of it.
01:14:08 <oerjan> glguy: sure
01:14:09 * glguy waits to pounce on the first person to ask "anyone?"
01:15:23 <dons> anyone want to rewrite screen?
01:15:32 <dons> just port the xmonad tiling code over
01:15:39 <dons> and instead of calling X, call some gunk.
01:16:07 <kolmodin> dons: ah. I'm not yet up to date with what has happened lately
01:16:42 <dons> oh, we had a user!
01:16:47 <wli> ! TeX capacity exceeded, sorry [save size=5000].
01:16:48 <dons> and he was serialising UArray Int Int
01:16:58 <dons> which goes via a call to `elems` and the list instance
01:17:12 <kaol> how about putting the xmonad tiling code in a library? (/me not being entirely serious)
01:17:18 <dons> which means building an intermediate list strictly, so sjanssen wrote a patch to avoid the list instance when serialising arrays
01:17:43 <dons> kaol, it'd be easy, yeah. they're just [a] -> [(Rectangle,a)] functions
01:18:08 <kolmodin> ah. which ml was this?
01:18:28 <kaol> it'd be another excuse for reducing xmonad's LOC count too :-P
01:18:41 <dons> kolmodin: so i had an initial reply, http://haskell.org/haskellwiki/Serialisation_and_compression_with_Data_Binary
01:18:43 <oerjan> dons: why would that build the list strictly in the first place?
01:18:44 <lambdabot> Title: Serialisation and compression with Data Binary - HaskellWiki, http://tinyurl.com/36kj64
01:18:52 <dons> showing how to serialise Ptr a byte converting it to a bytestring
01:19:04 <dons> oerjan: it calls the list binary instance, which calculates the list length first
01:19:12 <dons> the new code just mapM_s put elems
01:19:31 <oerjan> dons: wouldn't the list instance be the real problem then?
01:19:40 <dons> lists have to write their length :)
01:19:48 <dons> unless we do something silly
01:20:10 <dons> anyway, that issue is all fixed.
01:21:28 <dons> kolmodin: this thread, http://thread.gmane.org/gmane.comp.lang.haskell.cafe/25199
01:21:30 <lambdabot> Title: Gmane Loom
01:21:34 <quicksilver> dons: well actually they could still write the data first (to a temporary buffer) and then come back for the length
01:21:35 <kolmodin> dons: ah, yes. I did read that on h-cafe
01:22:00 <oerjan> dons: that means you cannot serialize a really big list
01:22:11 <quicksilver> dons: I imagine that might quite often be preferable, on really big lists
01:22:24 <dons> he responded today saying he'd switched to Data.Binary and UArray, and memory was down to 400M (from a 30M input)
01:22:24 <kolmodin> dons: or your wiki reply at least
01:22:36 <dons> but he's still converting things back and forward from lists.
01:22:41 <dons> and the UArray instance wasn't efficient enough
01:22:47 <dons> so we'll see.
01:22:49 <kolmodin> ah, yes
01:23:01 <dons> oerjan: yeah, that's true. you'd wrap the list type with your own instance if you wanted to do that
01:23:24 <dcoutts> dons: we can do chunked on-disk representations
01:23:50 <kolmodin> I'm going back to Göteborg today
01:23:59 <dcoutts> kolmodin: good good :-)
01:24:19 <dcoutts> dons: so instead of a single length-prefixed chunk, we use multiple small ones, more tuned to the buffer size
01:24:26 <dons> dcoutts: so the issue i was having with writing this code very efficiently was how to do zero-copying seriliasation.  for absolute performance you want host order direct memory dumps of strict structures
01:24:29 <kolmodin> which will give me infinitly many more times of time to hack
01:24:35 <dcoutts> dons: that way we don't have to traverse twice
01:24:41 <kolmodin> and a ISP that works
01:24:42 <dons> which currently means coercing them to [Strict]
01:24:45 <kolmodin> :)
01:25:14 <dons> maybe we should better support strict host order zero-copy serialisation of Storables
01:25:54 <dons> dcoutts: see toByteString   :: Storable a => ForeignPtr a -> Int -> L.ByteString
01:25:59 <dcoutts> dons: I was hoping to avoid using Storable since the alignment is not really supportable
01:26:00 <dons> fromByteString :: Storable a => L.ByteString -> ForeignPtr a
01:26:24 <dons> maybe people don't care, i suppose.
01:26:28 <dcoutts> and in future we may want to move to using non-foreignPtr based memory chunks
01:26:48 <dons> at least its possible now, with the above code, if someone really cares
01:27:28 <dons> i'd like ghc to emit a warning if it detects you building a list larger than 10k in memory
01:27:41 <Syzygy-> dons: Yikes!
01:27:44 <dons> something like "GHC runtime sez: use a different structure"
01:27:47 <Syzygy-> dons: It'll yell at me constantly for that.
01:27:58 <dons> you build giant lists?
01:28:10 <dons> math guys are weird
01:28:17 <Syzygy-> 166,331,232 bytes maximum residency (35921 sample(s))
01:28:24 <Syzygy-> My latest run. This got cut off, but still.
01:28:27 <dons> in lists?
01:28:28 <goltrpoat> edwardk:  do you know what this guy is on about?  http://programming.reddit.com/info/24fmv/comments/c24jfz
01:28:29 <lambdabot> Title: Why is True Random Number generation still not a standard computer feature? (red ...
01:28:44 <dcoutts> dons: so for example, when serialising lists, how does one do it without traversing twice?
01:28:46 <Syzygy-> That's what happens when I do > length $ permutahedronDiagonal 9
01:28:49 <Syzygy-> and then wait a while
01:28:53 <Syzygy-> (as in 3-4 days)
01:29:21 <Syzygy-> goltrpoat: Physical randomness using bad transistors instead of pseudo-randomness
01:29:21 <RyanT5000> goltrpoat: it isn't? it's at least in intel and via chipsets/cpus - doesn't that make it a "standard feature"?
01:29:24 <dons> dcoutts: hmm? for Arrays we have the bounds in O(1), that's the issue
01:29:37 <dons> so avoiding an put (elems arr) is worthwhile
01:29:53 <dcoutts> dons: but that's easy, just use arr ! n
01:29:56 <goltrpoat> eh?  nah, i was linking to a thread in that post, where this guy is claiming to have discovered a way to generate "optimal" zobrist keys
01:30:04 <Syzygy-> Oh.
01:30:11 <Syzygy-> Ok, no then I have no idea.
01:30:13 <vincenz> dons: I will soon have a revamped version :)
01:30:16 <vincenz> dons: with figures et al
01:30:24 <quicksilver> dcoutts: if you are content with fixed-length headers, and random access output, you can do the length at the end
01:30:40 <vincenz> dons: and it seems I had made a calculation mistake in the final example (fortunately, as the data-type I got was less than obvious)
01:30:50 <oerjan> last i read a discussion about physical randomness, it was available, but there was just not a real market for it
01:31:02 <dcoutts> quicksilver: random access is a bit tricky for us actually
01:31:05 <quicksilver> dcoutts: or you can use a temporary buffer (which would be an order of magnitude smaller than a strick list)
01:31:18 <quicksilver> dcoutts: yarr, I know. Just commenting for completeness really
01:31:23 <dons> dcoutts: so what's the next big area we need to address performance-wise?
01:31:33 <quicksilver> oerjan: my mum worked long ago on a computer called ERNIE which had physical randomness
01:31:34 <dons> my suspicion is that its parsing/xml
01:31:40 <dcoutts> dons: unicode?
01:31:42 <quicksilver> oerjan: it was used for the UK premium bonds lottery
01:31:46 <dons> and arrays.
01:31:49 <Syzygy-> dons: One of the main reasons I'm doing it with lists is because this particular code is written with mindboggling clarity as primary goal.
01:31:49 <dons> but rl can do those.
01:32:02 <ttmrichter> One last question on primes: http://www.haskell.org/haskellwiki/Prime_numbers  Is the code on the wiki a "real Sieve of Eratosthenes" as per Melissa O'Neill's paper or is it another sieve entirely?
01:32:03 <lambdabot> Title: Prime numbers - HaskellWiki
01:32:08 <dcoutts> dons: though getting lists & arrays to play nicely (ie fuse) would be useful
01:32:25 <dons> dcoutts: oh, did you see wouter's stolen Data.Stream behind our backs? :-)
01:32:35 <dcoutts> dons: yep :-)
01:32:49 <dons> sneaky
01:32:53 <dcoutts> dons: and told us to go use colist
01:32:57 <dons> yeah
01:33:02 <dons> but its "stream fusion"!
01:33:16 <dons> where is that sneaky swiert...
01:33:22 <dcoutts> dons: buzzwords!
01:33:23 <dons> its all to do with his new paper,  I think
01:33:50 <quicksilver> ttmrichter: didn't look real to me but I'm no expert
01:33:56 <dons> http://www.cs.nott.ac.uk/~wss/Publications/BeautyInTheBeast.pdf
01:34:00 <dons> Beauty in the Beast: A Functional Semantics for the Awkward Squad [bib]
01:34:01 <dons>     Wouter Swierstra and Thorsten Altenkirch. Submitted to the Haskell Workshop 2007
01:34:35 <dons> dcoutts: ^^ testing IO code with QuickCheck. nice.
01:35:07 <ttmrichter> quicksilver: The reason I ask is when I tested its performance on getting the 10,000th prime on my machine, I saw a flabbergasting two orders of magnitude performance improvement.  I would have thought another folk-sieve wouldn't be quite so fast.  :)
01:35:14 <dons> dcoutts: oh, getting QC + Strictcheck to play together would be good for the hackathon
01:35:24 <dons> i don't trust ndm's crazy optimisations ;)
01:35:49 <dons> dcoutts, kolmodin , also Stefan replied about Freiburg. apparently there's beer.
01:36:12 <glguy> quicksilver: would you support trying out /mode -c ?
01:36:35 <glguy> quicksilver: dons says I needed a majority of the top 5 users on the irc stats to get approval
01:36:47 <xpika> is there a way to display your haskell program as a functional flowchart like UML but simply for functions instead of classes?
01:36:55 <dons> glguy: so what's the motivation again?
01:37:04 <dons> xpika: hmm, i think someone's done this with 'dotty'
01:37:19 <dons> perhaps google for 'graphing haskell' or something like that?
01:37:26 <quicksilver> glguy: damn, so by talking too much I suddenly become important?
01:37:34 <glguy> dons: pedagogical purposes, for one
01:37:35 <quicksilver> what is this, a loquacracy?
01:37:45 <glguy> dons: to support proper underline and bold
01:37:58 <RyanT5000> is there any function to interleave two lists?
01:38:00 <glguy> you could emphasis a variable easier in sample code
01:38:10 <mauke_> @hoogle [a] -> [a] -> [a]
01:38:10 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
01:38:10 <lambdabot> List.intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
01:38:10 <lambdabot> List.unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
01:38:14 <dons> quicksilver: that's right :)
01:38:29 <dons> RyanT5000: list comprehensions
01:38:36 <dons> or just zipWith
01:38:48 <dcoutts> dons: yes, mmm, German beer :-)
01:38:54 <glguy> dons: people that don't like any colors could probably turn them off in their clients? is that a major concern?
01:38:56 <mauke_> disambiguation when talking about code (especially "a")
01:39:03 <dons> > concat $ zipWith (\a b -> a : b : [] "haskell" "         "
01:39:03 <lambdabot>  Parse error
01:39:06 <dons> > concat $ zipWith (\a b -> a : b : []) "haskell" "         "
01:39:08 <lambdabot>  "h a s k e l l "
01:39:10 <quicksilver> glguy: Id' be happy to try -c experimentally. We could always turn it off if it was annoying/unpopular
01:39:16 <glguy> that's what I was thinking
01:39:26 <glguy> its not permanent
01:39:31 <RyanT5000> dons: thanks
01:39:38 <quicksilver> glguy: I probably wouldn't use it myself, since I have no idea how to make my client emit ascii escapes :)
01:39:38 * wli is doing his evil things with rational functions again.
01:39:58 <dons> ?pl \a b -> a : b : []
01:39:58 <lambdabot> (. return) . (:)
01:40:01 <quicksilver> glguy: if lambdabot hs-colour-ed its output that would actually be quite cute :)
01:40:10 <dons> oh, we could pipe it into hscolour
01:40:13 <dons> that'd be pretty
01:40:28 <mauke_> where pretty = angryFruitSalad
01:41:01 <Syzygy-> ...
01:41:16 --- mode: ChanServ set -c
01:41:26 <dons> a new age dawns.
01:41:31 <glguy> dons: i suggested that t o you already :0)
01:41:50 <dons> sorry, my memory is failing in old age
01:41:52 <goltrpoat> famous last words.
01:42:06 <quicksilver> dons: quick. Store your memory in lambdabot so it isn't lost to future generations.
01:42:19 <glguy> real underline and bold I think
01:42:24 <dons> yeah works here.
01:43:02 <quicksilver> worked for me
01:43:13 <quicksilver> although my terminal client renders bold as red. But that's my problem :P
01:43:18 <glguy> let f 5x = 5x
01:43:19 <dons> so how can i paste in coloured code from HsColour..
01:43:24 <dons> glguy: oh, how'd you do that?
01:43:31 <mauke_> what was the code for underline?
01:43:34 <glguy> ^C5x^0
01:43:40 <glguy> underline is ^_
01:43:44 <dons> is that an ansi escape, glguy ?
01:43:45 <glguy> bold is ^B
01:43:46 <mauke_> that sucks
01:43:50 <mauke_> dons: no
01:43:58 <mauke_> ^_ is my detach key
01:43:58 <hpaste>  gattocarlo annotated "changeWindowAttributes" with "changeWindowAttributes" at http://hpaste.org/1612#a1
01:43:59 <glguy> Oh, I don't know what the actual code is
01:44:00 <dons> boo, then hscolour -tty is no good to us.
01:44:11 <glguy> I just know the irssi command key
01:44:18 <dons> $ HsColour -tty /tmp/A.hs
01:44:19 <dons> main = print (1+2)
01:44:25 <dons> prints lovely coloured code to stdout in xterm
01:44:27 <glguy> heh
01:45:09 --- mode: ChanServ set +nt
01:45:20 * glguy set the wrong mode lock earlier
01:45:29 <quicksilver> dons: I bet there is an ANSI -> IRC escape filter
01:45:56 <glguy> this is 10 what we should avoid
01:45:57 <quicksilver> (or if not it's trivial to write|)
01:46:13 <glguy> but I think that it can be used tastefully
01:46:24 <mm_freak> most irc clients do recognize ANSI escapes
01:46:26 <glguy> mauke_: irssi uses ^7 for underline
01:46:26 <mauke_> this is a test.
01:46:31 <glguy> also
01:46:39 <glguy> mauke_: that worked
01:46:49 <mauke_> glguy: that still sends ^_, which detaches from my terminal
01:47:18 <glguy> Oh? how does that work?
01:47:25 <glguy> what program is doing the detaching
01:47:50 <mauke> dtach
01:48:06 <glguy> is that a lightweight version of screen?
01:48:10 <mauke> and I'm running it with -e ^_
01:48:28 <mauke> yeah, it doesn't do its own terminal emulation; just attaching/detaching
01:48:50 <dons> 0mmain[0m[0m [0m[31m=[0m[0m [0m[0mprint[0m[0m [0m[36m([0m[35m1[0m[36m+[0m[35m2[0m[36m)[0m[0m
01:48:53 <dons> [0m
01:48:53 <dons> ohh, almost
01:49:16 <glguy> when ?src is colorcoded , people are going to shit :)
01:49:36 <dons> 0mmain[0m[0m [0m[31m=[0m[0m [0m[0mprint[0m[0m [0m[36m([0m[35m1[0m[36m+[0m[35m2[0m[36m)[0m[0m
01:49:39 <dons> [0m
01:49:42 <quicksilver> actually the "IRC" escapes are really a mIRC feature aren't they?
01:49:42 <dons> nope, it misses the first escape. hmm
01:49:47 <oerjan> mauke: just use the /bind command to select your own underline key
01:49:56 <glguy> quicksilver: yeah, mIRC started it
01:50:05 <mauke> oerjan: which one? :-)
01:50:12 <dons> a test: [0mmain[0m[0m [0m[31m=[0m[0m [0m[0mprint[0m[0m [0m[36m([0m[35m1[0m[36m+[0m[35m2[0m[36m)[0m[0m
01:50:14 <mauke> ^U is both the best/worst choice
01:50:17 <dons> ah ha, victory!
01:50:25 <dons> did that display pretty stuff?
01:50:25 <glguy> hurray!
01:50:27 <glguy> yeah
01:50:32 <goltrpoat> glguy:  ircii had ^B and ^I years before mirc came out, if i recall
01:50:47 <glguy> goltrpoat: the irssi docs call them MIRC colors
01:50:56 <mm_freak> i'm using detach, too, though with the default detach key (which i don't use directly much often anyway)
01:50:57 <jethr0> i'm STILL struggling with monad transformers. so what happens when you have a "StateT ListMonad"? and how does backtracking work in that?
01:50:59 <jethr0> *argh*
01:50:59 <glguy> goltrpoat: maybe mirc added colors, but bold already existed?
01:51:04 <mm_freak> detach=dtach
01:51:06 <vincenz> dons: cute
01:51:09 <goltrpoat> mirc definitely added colors, yes
01:51:29 <glguy> jethr0: the state persists through backtracking
01:51:39 <goltrpoat> much to the dismay of most people on irc who were over the age of 12 at the time
01:51:43 <mauke> mm_freak: I do use ^\ sometimes
01:51:43 <dons>  [0m [0m[0mfoldr[0m[0m [0m[0mk[0m[0m [0m[0mz[0m[0m [0m[0mxs[0m[0m [0m[31m=[0m[0m [0m[0mgo[0m[0m [0m[0mxs[0m[0m
01:51:46 <dons> [0m[0m     [0m[4;32mwhere[0m[0m [0m[0mgo[0m[0m [0m[31m[[0m[31m][0m[0m     [0m[31m=[0m[0m [0m[0mz[0m[0m
01:51:49 <dons> [0m[0m           [0m[0mgo[0m[0m [0m[36m([0m[0my[0m[1;31m:[0m[0mys[0m[36m)[0m[0m [0m[31m=[0m[0m [0m[0my[0m[0m [0m[36m`k`[0m[0m [0m[0mgo[0m[0m [0m[0mys[0m[0m
01:51:53 <mm_freak> mauke: it's ^[\
01:51:53 <dons> [0m[0m
01:51:54 <dons> oh, that' didn't turn out quite right
01:52:00 <oerjan> glguy: what? no.
01:52:02 <quicksilver> glguy: are irssi's key bindings actually documented anywhere?
01:52:07 <mauke> mm_freak: ^[\ is not a key
01:52:12 <mm_freak> quicksilver: /help bind
01:52:20 <glguy> http://f0rked.com/public/irssi-docs/formats.txt
01:52:23 <glguy> I'm looking that that right now
01:52:31 <mm_freak> mauke: ^[\ = ESC-\
01:52:34 <oerjan> backtracking in StateT _ [] backtracks the state too
01:52:39 <mauke> mm_freak: yeah, that's not a key
01:52:49 <jethr0> glguy: and what if i want to backtrack over the state as well?
01:52:54 <jethr0> oerjan: ok
01:52:58 <mm_freak> mauke: technically it's considered a key
01:53:03 <mauke> no, it isn't
01:53:18 <sm> hi all.. what is the best way to avoid rounding errors when summing amounts of money ? some transactions that should balance to 0 didn't because I was using Double
01:53:26 <mm_freak> mauke: it is, for terminal applications
01:53:33 <dons> sm, hmm, that's a very good question
01:53:34 <mauke> mm_freak: no
01:53:37 <quicksilver> glguy: ah, thanks
01:53:43 <mauke> sm: use integer cents
01:53:45 <jethr0> oerjan: and "ListT (StateM _)" would then backtrack but with a persisting state?
01:53:49 <mm_freak> mauke: ok you're right -sigh-
01:54:08 <dons> surely we have a library for money and other typed dimensional stuff?
01:54:23 <sm> I thought one of the other number types would be exact.. but it sounds like the thing to do is multiply everything by 100 ?
01:54:39 <dons> Rational?
01:54:50 <quicksilver> sm: multiplying everything by 100 and using Integer is very logical
01:54:56 <sm> I tried Rational, it has the same issue
01:54:57 <quicksilver> sm: you can probably get away with Rational though
01:54:57 <mm_freak> sm: use a fixed-point typeâ€¦  maybe an Integer
01:55:08 <quicksilver> sm: depends what type of calculation you do
01:55:17 <dons> sm, how did Rational fail?
01:55:29 <mm_freak> don't use Rational for thatâ€¦  we've had that discussion alreadyâ€¦  you'll get huge memory use quickly
01:55:30 <quicksilver> sm: you can use Rational but "Explicitly round" after you do something odd like an exponentiation (interest)
01:55:36 <glguy> > runStateT (do { x <- lift [1..10]; modify (x:); guard (even x) }) [] -- proof of my mistake
01:55:38 <lambdabot>  [((),[2]),((),[4]),((),[6]),((),[8]),((),[10])]
01:55:41 <quicksilver> mm_freak: you can do it if you're careful
01:55:49 <dons> mm_freak: we suspect that, but have never seen it in the wild ;)
01:55:52 <quicksilver> mm_freak: but you do need to be aware of the issues
01:56:20 <sm> > toRational 1.85 + toRational 5.95 - toRational 7.80
01:56:21 <lambdabot>  1%2251799813685248
01:56:33 <quicksilver> sm: ah, you're using Double there
01:56:39 <quicksilver> sm: you've been bitten by defaulting
01:56:44 <mm_freak> quicksilver: yeah, but it's also a bit inappropriate, because certain functions will be imprecise anyway, like logarithms, which are used frequently with money
01:56:54 <jethr0> glguy: thx for the example. so would state be innermost or outermost in "StateT _ []"? it's on the "outside", right?
01:56:55 * sm becomes a lambdabot user, hurrah
01:56:58 <quicksilver> > (1.85 + 5.95 - 7.80) :: Rational
01:56:58 <dons> > 185 % 100 + 595%100 - 780%100
01:57:00 <lambdabot>  0%1
01:57:01 <lambdabot>  0%1
01:57:08 <dons> quicksilver wins
01:57:10 <glguy> jethr0: in that example, StateT was the outer most
01:57:14 * kolmodin is off to gbg
01:57:19 <kolmodin> bye :)
01:57:24 <jethr0> k
01:57:34 <quicksilver> mm_freak: you'd explicitly truncate after those operations the nearest penny, was my suggestion
01:57:44 <quicksilver> mm_freak: you can't ignore the problem but you can work with it
01:57:48 <oerjan> jethr0: i presume, although i've heard the standard ListT is somewhat buggy (not quite monadic)
01:58:06 <oerjan> there is a replacement for it
01:58:28 <mm_freak> quicksilver: the precision needs to be better in this case, at least if you work further with the results
01:58:33 <quicksilver> jethr0: confusingly the 'outermost' transformer ends up as the 'innermost data'
01:58:43 <quicksilver> mm_freak: right, you need to understand exactly what you're trying to do
01:58:56 <quicksilver> mm_freak: but that's obviously the case with money
01:58:57 <jethr0> quicksilver: yes, that's exactly what has been confusing me all this time
01:59:15 <quicksilver> jethr0: convention is to call that 'outermost'
01:59:18 <sm> hmm.. it's late here.. I wonder how those are different from my code
01:59:20 <quicksilver> jethr0: but I agree it's damn confusing
01:59:24 <mm_freak> quicksilver: i think it would be easiest to work with Integer and cast as appropriate
01:59:26 <jethr0> i think it's a result of IO always being innermost and being "evaluated" as the last
01:59:30 <quicksilver> sm: don't use toRational
01:59:42 <quicksilver> sm: that leaves the type of your literals undetermined
01:59:46 <quicksilver> sm: and they default to Double
01:59:50 <quicksilver> sm: and you lose precision
01:59:57 <sm> I see, interesting
02:00:12 <quicksilver> sm: just annotate your functoins with Rational and it will all work out
02:00:26 <dons> or default(Rational). but I think this is worth an email to haskell-cafe@
02:00:34 <dons> since someone would have written a module for this surely
02:00:35 <quicksilver> sm: modulo mm_freak's point about imprescise calculations like logarithms
02:00:51 <mauke> > log (1%2)
02:00:52 <lambdabot>   add an instance declaration for (Floating (Ratio t))
02:00:52 <lambdabot>     In the expression:...
02:01:10 <sm> in fact I have a "(toRational (read q'::Double)" here
02:01:15 <quicksilver> if you're just using +, -, * you are absolutely fine
02:01:21 <mm_freak> isn't there any predefined fixed precision fractional type?
02:01:34 <dons> > log (1%2) :: Rational
02:01:35 <lambdabot>        add an instance declaration for (Floating (Ratio Integer))
02:01:35 <lambdabot>     In the ...
02:01:42 <mm_freak> one which all those irrational functions work with
02:01:57 <quicksilver> if you use / yyou should make a decision about whether you need to round afterwards
02:02:00 <dons> mm_freak: pretty sure this is in one of the numerics libs
02:02:06 <quicksilver> if you use exp,log you need to think harder
02:02:29 <nomeata> Hi. A bit unrelated (although I want to implement it in haskell). How can i solve this problem: Given ordered list of objects, and a minimum distance between each pair, I want to place them on a line so that (a) the distance from first to last is minimal and (b) the smallest distance is maximal.
02:02:45 <quicksilver> even a properly implemented fixed point doesn't solve the problem
02:03:00 <quicksilver> mm_freak: you still typically end up needing two precisions in your code
02:03:01 <mm_freak> this `%' confuses me all the timeâ€¦  i always read it as modulo
02:03:27 <nomeata> Example: If I have three objects A,B,C, and minimal distances A-B 1, B-C 1, A-C 4, then Iâ€™d arrange them A=0, B=2, C=4
02:03:37 <quicksilver> mm_freak: one for calculation and one for final results
02:03:45 <nomeata> (while a simple fold would probably give A=0, B=1, C=4)
02:03:49 <nomeata> Any ideas or pointers?
02:03:51 <dons> :t (%)
02:03:52 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
02:03:59 <dons> ?src Rational
02:04:00 <lambdabot> type Rational = Ratio Integer
02:04:01 <dons> ?src Ratio
02:04:02 <lambdabot> data (Integral a) => Ratio a = !a :% !a
02:04:08 <goltrpoat> "the smallest distance is maximal" ?
02:04:09 <quicksilver> mm_freak: and there is often some requirement to round back to 'penny precision' at a certain point, and then perform subtraction/addition at penny precision
02:04:10 <dons> ?src (%)
02:04:10 <lambdabot> x % y = reduce (x * signum y) (abs y)
02:04:19 <sm> I see.. I guess I used ::Double because I am reading decimal numbers.. but I can make a rational instead
02:04:28 <quicksilver> sm: yes
02:04:28 <mm_freak> quicksilver: actually it shouldn't be too difficult to define a type which makes most exponential operations exact
02:04:30 <nomeata> goltrpoat: yes. basically, make it spread as evenly as possible
02:04:55 <quicksilver> mm_freak: things like annuitys will never be exact
02:05:02 <nomeata> goltrpoat: in my example, the smallest distance can be 2, but the simple algorithm gives 1 (between A and B)
02:05:09 <quicksilver> mm_freak: taking the 365th-root of a number doesn't often produce a rational :)
02:05:11 <dons> mm_freak: re. libs, there must be something here, http://haskell.org/haskellwiki/Applications_and_libraries/Mathematics
02:05:13 <lambdabot> Title: Applications and libraries/Mathematics - HaskellWiki, http://tinyurl.com/2rt3uv
02:05:24 <mm_freak> quicksilver: it doesn't _need_ to be rational
02:05:32 <quicksilver> > (read "12.01") :: Rational
02:05:33 <lambdabot>  Exception: Prelude.read: no parse
02:05:36 <mm_freak> an irrational type
02:05:41 <quicksilver> !!!
02:05:52 <quicksilver> that's got to be a bug?
02:06:02 <mauke> probably a feature
02:06:18 <mm_freak> > (read "1201%100") :: Rational
02:06:20 <lambdabot>  1201%100
02:06:57 <mm_freak> > (reads "12.01") :: [(Rational, String)]
02:06:58 <lambdabot>  []
02:07:13 <nomeata> I could try some iterative, numerical approach, but I was hoping for a constructive solution...
02:07:32 <quicksilver> mm_freak: it doesn'ty need to be rational but you were talking about 'most exponential operations exact'
02:08:19 <dons> > read (map (\c -> if c == '.' then '%' else c) "12.01") :: Rational
02:08:20 <lambdabot>  12%1
02:08:32 <mm_freak> quicksilver: yeah, just as Rational makes all linear operations exact, a type like Exponential could make all exponential operations ((^), log, etc.) exact
02:09:18 <quicksilver> mm_freak: oh, I see. A structured type.
02:09:29 <quicksilver> mm_freak: yes, that would be funky
02:09:42 <mauke> > read "42" :: Rational
02:09:44 <lambdabot>  Exception: Prelude.read: no parse
02:09:53 <oerjan> jethr0: one thing to remember about monad transformers is that an action in t m is simulated by an action in m
02:10:08 <mm_freak> yes, it might be defined like: ln (n/d)^e / ln b
02:10:37 <mm_freak> but i think, we'd need to do more science to define something like this
02:10:38 <vincenz> Hot off the press : new version of Higher-Order Zipper article, expanding a bit on generating more higher-order ones as well as cleaning up the math and fixing a problem in DDTree :)
02:11:01 <mauke> > (\s -> read (takeWhile ('.' /=) s) % 1 + let t = tail $ dropWhile ('.' /=) s in read t % 10 ^ length t) "12.01"
02:11:02 <lambdabot>  1201%100
02:11:04 * vincenz should clean this up more and submit it to a haskell workshop
02:11:18 <mauke> > (\s -> read (takeWhile ('.' /=) s) % 1 + let t = tail $ dropWhile ('.' /=) s in read t % 10 ^ length t) "3.14"
02:11:19 <lambdabot>  157%50
02:12:54 <mm_freak> quicksilver: we might be able to define an Algebraic type, where a number is defined by a polynomial's rootsâ€¦  i don't know, however, how you could calculate with something like this
02:13:16 <mm_freak> or even a Cauchy type
02:14:54 <jethr0> oerjan: uhu, what does that mean?
02:15:52 <oerjan> jethr0: say in StateT _ [], the backtracking is done by the base monad, which does not know about the state at all
02:16:40 <oerjan> the effects in the base monad cannot know about the transformer
02:17:25 <jethr0> yes, i see
02:17:45 <sm> well thanks a lot, all
02:18:29 <sm> to wrap this up for tonight, I would like to do some quick & dirty rounding.. I don't see how to do that in haskell though
02:19:19 <sean_____> Prelude.round?
02:19:48 <dons> round/truncate et al
02:19:50 <sm> "returns the nearest integer to x".. hmm
02:19:51 <oerjan> also, the transformer cannot use anything about the base monad other than the common monad operations.
02:20:13 <dons> sm, do ask via email on haskell-cafe@ about handling money
02:20:21 <dons> someone will have the perfect solution out there, i'm sure
02:20:23 <sm> there seems to be nothing ready to just round to N digits ?
02:20:31 <sm> will do dons
02:20:52 <jethr0> oerjan: hmm, i just find it exceedingly difficult to grasp. i have no problem to understand stacked monads, but thinking up a way to stack some monads is still hard for me at the moment
02:21:12 <dons> > printf "%0.2f pi :: String
02:21:12 <lambdabot>  Improperly terminated string
02:21:15 <dons> > printf "%0.2f" pi :: String
02:21:17 <lambdabot>  "3.14"
02:21:35 <sm> ah, that's a good way
02:21:35 <oerjan> yeah
02:21:37 <mauke> useless use of 0 :-)
02:21:54 <mauke> > showFFloat (Just 2) pi
02:21:56 <lambdabot>  <[Char] -> [Char]>
02:21:59 <mauke> > showFFloat (Just 2) pi ""
02:22:00 <lambdabot>  "3.14"
02:23:01 <notadev> has anyone seen: http://okmij.org/ftp/Scheme/monad-in-Scheme.html - i have some concerns about casting from constant to number which seems common to both haskell and scheme.
02:23:02 <lambdabot> Title: Monads in Scheme
02:23:50 <dons> what's your concern exactly?
02:25:28 <notadev> um why it's necessary really?
02:26:02 <dons> I think you'll need to clarify what `casting from constant to number' means here
02:26:37 <quicksilver> notadev: in haskell you don't really cast
02:26:40 <oerjan> i don't think scheme casts constants to numbers, it may cast numbers when different types are used together in operations.
02:26:48 <quicksilver> "cast" suggests a runtime operation
02:26:59 <quicksilver> a haskell type annotation is just a hint to the type checker to generate the right program
02:27:01 <notadev> hmm i may be a bit out of my depth; exactly my concern quicksilver
02:27:12 <quicksilver> > 0.15 :: Rational
02:27:14 <lambdabot>  3%20
02:27:23 <notadev> eh?
02:27:25 <quicksilver> ^^ that's not a cast. It's just telling the compiler what code to generate.
02:27:45 <quicksilver> it's not the case that 0.15 "existed first" and was then "casted to Rational"
02:28:06 <quicksilver> but maybe that's not what you're worried about
02:28:10 <quicksilver> in which case, please exlpain more :)
02:28:17 <notadev> i don't understand the response from lambdabot is all
02:28:35 <notadev> no you have the concern right, quicksilver
02:28:38 <notadev> return:: a -> NumberedM a
02:28:53 <notadev> aiui that makes a number type from a constant?
02:29:51 <quicksilver> not really
02:29:57 <jethr0> 3%20 is the notation for fractions, i.e. "three twentieths"
02:29:58 <quicksilver> that's a special numbering monad
02:30:04 <notadev> (define (return val) (lambda (curr_counter) (make-numbered-value curr_counter val)))
02:30:08 <quicksilver> which oleg is using as a motivating example
02:30:18 <quicksilver> that's not "normal haskell number types"
02:30:36 <notadev> oh ok
02:30:45 <notadev> (ty jethr0)
02:31:09 <quicksilver> he's using "numbering stuff" as an example of a monad
02:31:16 <notadev> why would: (make-numbered-value curr_counter val) ever be needed tho?
02:31:16 <quicksilver> so his calculations can number their results
02:31:18 <quicksilver> or count stuff
02:31:21 <notadev> oic thanks quicksilver :)
02:31:30 <quicksilver> it's the constructor
02:31:43 <notadev> hmm
02:31:49 <quicksilver> typically monad constructors are opaque
02:31:57 <notadev> it just seems odd to need a constr for an int
02:31:58 <quicksilver> they're only used in the defintion of '>>=' and 'return'
02:32:03 <quicksilver> but it isn't an int
02:32:11 <quicksilver> it's a function from ints to values :)
02:32:17 <notadev> hehe
02:32:20 <notadev> ok :D
02:32:40 <notadev> thanks quicksilver, you always seem to understand what i'm on about :-)
02:32:57 <quicksilver> his motivating example is constructing a tree with "unique IDs" at each node
02:33:09 <quicksilver> the numbering part is the monadic plumbing to pass around the next free ID
02:33:21 <quicksilver> it's really an example of a unique-supply monad
02:33:27 <notadev> hmm
02:33:41 <quicksilver> although the numbering monad is a bit more general than that
02:33:52 <quicksilver> in principle it has the power to reset the numbering at some point in the tree etc
02:33:59 <quicksilver> the monad he constructs is more general than that required by the problem
02:34:08 <notadev> it appeared to me to be saying that's all a monad was, tho i had previously envisioned it as data to process and decision making on processing
02:34:49 <notadev> s/data to process/spec of data to process/
02:35:12 <notadev> ok thanks quicksilver i'll think and read some more :-)
02:35:54 <sean_____> hello all
02:36:29 <notadev> sean_____: /msg NickServ Ghost <pwd>
02:37:17 <sean_____> ?
02:37:37 <notadev> your tail, man
02:37:51 <notadev> oic
02:37:52 <sean_____> yeah, it's a regular problem :)
02:37:58 <notadev> that's deliberate ;)
02:38:11 <sean_____> apparently everyone in the known world likes the name 'sean'
02:38:35 <notadev> hehe
02:38:41 <sean_____> anyway, I have a beginner's question about Parsec, and I was wondering if anyone lurking here could help
02:39:31 <sean_____> I'm trying to use HUnit to test whether parses fail correctly, and it seems much harder than it should be
02:40:19 <sean_____> so I'm wondering if I'm just missing something about Parsec or HUnit ...
02:41:09 <quicksilver> well ask away
02:41:13 <quicksilver> I must admit I don't use HUnit
02:41:18 <quicksilver> I tend to roll my own tests
02:41:31 <quicksilver> probably that's ill-advised lazyiiness though
02:41:38 <notadev> hehe
02:41:49 <notadev> sounds well-advised to me ;)
02:41:58 * notadev ducks
02:42:02 <sean_____> :)
02:42:50 <sean_____> I'm basically looking at Text.ParserCombinators.Parsec.Error
02:43:11 <sean_____> and wondering how I'm supposed to decode ParseErrors to make sure they're correct
02:43:25 <sean_____> There aren't instances of Eq for those types
02:44:07 <ClaudiusMaximus> where are the tools that convert Haskell source code to pretty LaTeX that i can paste into my document without much effort?  a tutorial would be helpful too...
02:44:15 <edwardk> hrmm, heh, a ^ b = expT (b .* (Log a)) given newtype Log a = Log { expT :: a } deriving (Eq,Ord,Show,Enum) and a bunch of instance MulMagma a => AddMagma (Log a) where (Log a) + (Log b) = Log (a * b) kind of things
02:44:25 <edwardk> there, then i don't have to write it twice =)
02:44:51 <xpika> is there any way to compile haskell to just C so that it can be sent to someone without a haskell compiler?
02:45:16 <MarcWeber> Which is the command to tell hackage that some html files are located in different directories? the interface dump file dose'nt save the html paths
02:45:18 <edwardk> xpika: you can tell ghc to stop at various stages of compilation
02:45:50 <edwardk> that said, i think there may be library linkage requirements so you may need to send a .a library or two
02:46:04 <jethr0> ClaudiusMaximus: http://www.haskell.org/onlinereport/literate.html
02:46:04 <lambdabot> Title: The Haskell 98 Report: Literate Comments
02:46:10 <quicksilver> sean_____: I'd just "show" them probably
02:46:20 <quicksilver> sean_____: (and then compare the shown versions)
02:46:38 <jethr0> ClaudiusMaximus: that's what literate haskell is for.
02:47:49 <goltrpoat> edwardk:  did you see my question from earlier
02:48:06 <sean_____> quicksilver: yeah, that's good advice.  the code seems pretty hairy in the Error module, and reading over the source, I just couldn't figure out why it was written that way
02:48:17 <jethr0> ClaudiusMaximus: and then you can use lhs2tex
02:48:26 <goltrpoat> i can't figure out if that guy is crazy, or if he's saying something profound that's just going over my head for some reason.
02:48:46 <ClaudiusMaximus> jethr0: ah ok, lhs2tex is probably what i want, just didn't know the name
02:49:15 <jethr0> np
02:49:26 <sean_____> quicksilver: thanks
02:51:13 <quicksilver> sean_____: np
02:52:13 <dons> xpika: nope, but you can pass a static binary over.
02:53:16 <edwardk> goltrpoat: nope
02:53:22 <edwardk> goltrpoat: what was the question?
02:53:27 <edwardk> was in another window =/
02:55:13 <edwardk> a found it
02:55:21 <xpika> haskell needs a parrot backend
02:56:07 <hpaste>  Nestor_the_Inve pasted "Nestor_the_Investor" at http://hpaste.org/1613
03:03:55 <glguy> looks like the spammer is back
03:03:56 <oerjan> SPAM, SPAM, WONDERFUL SPAM
03:04:02 <glguy> but I deleted it already
03:04:21 <glguy> I wonder if the nick /= title check is still being done after truncation
03:04:30 * oerjan barely resisted the urge to color the word "SPAM"
03:04:41 <mauke> dons: do you still need an ansi->irc filter?
03:04:42 <quicksilver> 1SPAM
03:04:48 <quicksilver> hmm intriguing
03:04:50 <quicksilver> 2SPAM
03:04:53 <glguy> ?ask sorear Nestor_the_Inve came back... did you set the code to test for spam before truncation?
03:04:54 <lambdabot> Consider it noted.
03:04:55 <quicksilver> sorry, I'll stop now
03:05:47 <oerjan> is it possible this is truncated by the form _before_ it is sent?
03:06:12 <wli> Is there a way to get lhs2TeX to not include code that's otherwise passed to the compiler?
03:06:31 <wli> Or, basically, to get lhs2TeX to skip over a code block.
03:06:32 <glguy> oerjan: that is possible but not the case here
03:07:42 <notadev> how on earth do you get bold and colours then?
03:07:51 <notadev> @google irc control char
03:07:53 <lambdabot> http://www.kvirc.de/docu/doc_functions.html
03:07:53 <lambdabot> Title: Function index
03:07:57 <notadev> yay!
03:08:01 <notadev> @bot
03:08:01 <lambdabot> :)
03:08:18 <notadev> boo ;)
03:09:56 <wli> It's kind of asinine to include the module declaration.
03:10:05 <wli> So I want to make it silent.
03:10:35 <dons> mauke: yeah?
03:10:47 <mauke> dons: I've just written a perl program for that
03:11:19 <mauke> http://rafb.net/p/TMkpvC66.html
03:11:21 <lambdabot> Title: Nopaste - No description
03:11:50 <mauke> I don't know if it gets all corner cases right :-)
03:11:54 <ricky_clarkson> DRMacIver: Nice flame. ;)
03:13:43 <DRMacIver> Dammit. It hasn't moved onto the front page has it?
03:13:47 * DRMacIver glares at dibblego some more.
03:13:52 <dons>  foldr k z xs 05= go xs
03:13:52 <dons>      03where go 05[05]     05= z
03:13:52 <dons>            go 10(y05:ys10) 05= y 10`k` go ys
03:14:01 <mauke> nooo
03:14:09 <ricky_clarkson> DRMacIver: He told me about it in #jtiger.
03:14:09 <DRMacIver> Phew. No.
03:14:10 <glguy_> dons: that's almost better than color coding :)
03:14:19 * ricky_clarkson upvotes.
03:14:23 <glguy_> or rather: that's almost better than...
03:14:29 <dons>  [0m [0m[0mfoldr[0m[0m [0m[0mk[0m[0m [0m[0mz[0m[0m [0m[0mxs[0m[0m [0m[31m=[0m[0m [0m[0mgo[0m[0m [0m[0mxs[0m[0m
03:14:29 <DRMacIver> ricky_clarkson: Noo, don't. :)
03:14:30 <glguy_> :)
03:14:32 <dons> [0m[0m     [0m[4;32mwhere[0m[0m [0m[0mgo[0m[0m [0m[31m[[0m[31m][0m[0m     [0m[31m=[0m[0m [0m[0mz[0m[0m
03:14:32 <psykotic> DRMacIver, it was there for a few minutes.
03:14:35 <dons> [0m[0m           [0m[0mgo[0m[0m [0m[36m([0m[0my[0m[1;31m:[0m[0mys[0m[36m)[0m[0m [0m[31m=[0m[0m [0m[0my[0m[0m [0m[36m`k`[0m[0m [0m[0mgo[0m[0m [0m[0mys[0m[0m
03:14:37 <notadev> glguy_: just tell us how you do it please
03:14:39 <dons> the last is ansi escapes
03:14:42 <notadev> wtf was that?
03:14:46 <glguy_> notadev: look at that magic!
03:14:50 <notadev> hehe
03:14:51 <dons> the former was my attempt to paste in the irc clients , but didn't work in my client
03:14:53 * DRMacIver hides his face in embarassment.
03:14:54 <glguy_> notadev: deep breaths
03:14:57 <notadev> lol
03:15:08 <dons> did the irc escapes work for anyone?
03:15:13 <notadev> nop
03:15:16 <mauke> you didn't send any
03:15:23 <glguy_> dons: color coding worked here
03:15:24 <notadev>  [0m[0m 
03:15:24 <mauke> no control characters in my rawlog
03:15:36 <dons> main 05= print 10(06110+06210)
03:15:41 <notadev> just the bold is all i need :-)
03:15:49 <dons> did that work for anyone?
03:15:53 <glguy> dons: nope
03:15:53 <notadev> *bold* doesn't cut it with newbs ;)
03:16:03 <mauke> PRIVMSG #haskell :     03where go 05[05]
03:16:05 <glguy> notadev: irssi does make *text* bold
03:16:07 <dons> mauke: how would i enter the output of the perl program?
03:16:09 <notadev> oh
03:16:16 <notadev> not here it doesn't glguy
03:16:25 <notadev> your other ones were bold tho
03:16:25 <mauke> PRIVMSG #haskell :^[[0m^[[0m     ^[[0m^[[4;32mwhere^[[0m^[[0m ^[[0m^[[0mgo^[[0m^[[0m ^[[0m^[[31m[^[[0m^[[31m]^[[0m^[[0m     ^[[0m
03:16:35 <glguy> notadev: its like magic?
03:16:38 <mauke> dons: depends on your irc client, probably
03:16:43 <notadev> glguy: exactly :D
03:16:47 <oerjan> wli: you might do it with LaTeX? See http://www.tex.ac.uk/cgi-bin/texfaq2html?label=conditional
03:16:49 <lambdabot> Title: TeX Frequently Asked Questions -- question label "conditional"
03:16:57 * glguy types more text to scroll that off the screen
03:17:04 <glguy> ?karma-all
03:17:04 <lambdabot>  "audreyt"             634
03:17:04 <lambdabot>  "fglock"              218
03:17:04 <lambdabot>  "dons"                144
03:17:04 <lambdabot>  "agentz"              105
03:17:04 <lambdabot>  "gaal"                 99
03:17:06 <lambdabot> [1174 @more lines]
03:18:17 <mauke> 02algo
03:18:18 <mauke> alien
03:18:22 <glguy> notadev: we have to be conservative with the colors though, or dons will hate me and turn them off
03:18:34 <mauke> ^ was "algo" colored?
03:18:36 <glguy> mauke: yes
03:18:50 <notadev> glguy: you're no fun! ;P
03:19:12 <mauke> dons: /exec -out someprogram | perl ansi2irc
03:19:25 <Syzygy-> @karma+ gaal -- Gotta make top 5 all 3-digit karma!
03:19:25 <lambdabot> gaal's karma raised to 100.
03:19:29 <Syzygy-> There we go!
03:24:20 <dons> /bin/sh: /tmp/test.pl: No such file or directory
03:24:20 <dons> HsColour: /tmp/A.hs: openFile: does not exist (No such file or directory)
03:24:27 <dons> oh, wrong machine :)
03:24:28 <kalven> gg
03:25:02 <malcolmw> dons: is that a bug report?
03:25:06 <dons>  foldr k z xs 05= go xs
03:25:07 <dons>      03where go 05[05]     05= z
03:25:07 <dons>            go 10(y05:ys10) 05= y 10`k` go ys
03:25:08 <kosmikus> wli: sure, %if False, %endif or %if style == newcode, %endif
03:25:09 <dons> ah ha!
03:25:12 <Syzygy-> Ooooho, pretty
03:25:15 <dons> mauke: yes, that's nice.
03:25:20 <malcolmw> hey!
03:25:26 <quicksilver> dons: pretty although why is the where underlined? or is my client being stupid?
03:25:38 <Syzygy-> quicksilver: I see where underlined too.
03:25:50 <dons> HsColour seems to underline where 
03:25:54 <malcolmw> dons: what colouring scheme does IRC use?  is it ANSI codes?
03:25:55 <kolmodin> lambdabot is not in #kedja on quakenet... :/
03:26:02 <kosmikus> wli: see Guide2.pdf, Sec. 10
03:26:03 <dons> no, though a lot of clients support ansi
03:26:19 <quicksilver> malcolmw: no, it's "mIRC codes"
03:26:26 <dons> malcolmw: mauke wrote a script to convert ansi to irc though, http://rafb.net/p/TMkpvC66.html
03:26:26 <lambdabot> Title: Nopaste - No description
03:26:35 <malcolmw> the underlined _where_ is the standard hscolour style
03:26:36 <dons> so that, in e.g. irssi, this works:   /exec -out HsColour /tmp/A.hs | /tmp/test.pl
03:26:45 <quicksilver> dons: although nasty mauke wrote the script in perl :P
03:26:52 <dons> bad mauke!
03:26:58 <malcolmw> I'll happily add a direct -mirc flag to hscolour
03:27:01 <mauke> you're free to port it to haskell :-)
03:27:04 <dons> let me try just ansi flags..
03:27:13 <dons> [0m [0m[0mfoldr[0m[0m [0m[0mk[0m[0m [0m[0mz[0m[0m [0m[0mxs[0m[0m [0m[31m=[0m[0m [0m[0mgo[0m[0m [0m[0mxs[0m[0m
03:27:16 <dons> [0m[0m     [0m[32;4mwhere[0m[0m [0m[0mgo[0m[0m [0m[31m[[0m[31m][0m[0m     [0m[31m=[0m[0m [0m[0mz[0m[0m
03:27:19 <dons> [0m[0m           [0m[0mgo[0m[0m [0m[36m([0m[0my[0m[31;1m:[0m[0mys[0m[36m)[0m[0m [0m[31m=[0m[0m [0m[0my[0m[0m [0m[36m`k`[0m[0m [0m[0mgo[0m[0m [0m[0mys[0m[0m
03:27:23 <dons> [0m
03:27:26 <dons> so a bit different
03:27:32 <dons> that's without the irc converter in front.
03:27:38 <quicksilver> that's a bit odd in my client. some things are bolded
03:27:44 <dons> mine too
03:27:48 <Syzygy-> Yeah.
03:27:50 <malcolmw> it just looks like [0m to me
03:27:51 <Syzygy-> sporadic bolds.
03:27:53 <masklinn> rcirc doesn't bold anything
03:27:58 <mauke> dons: that contained tons of redundant ^[[0m
03:28:06 <notadev> looked awful here
03:28:07 <dons>  foldr k z xs 05= go xs
03:28:07 <dons>      03where go 05[05]     05= z
03:28:07 <dons>            go 10(y05:ys10) 05= y 10`k` go ys
03:28:08 <mauke> my script should remove most of that :-)
03:28:12 <dons> that looks fine for everyone?
03:28:18 <malcolmw> looks good to me
03:28:21 <quicksilver> looks good to me
03:28:22 <notadev> looke good here
03:28:34 <dons> cool. so HsColour | ansi2irc
03:28:35 <kosmikus> except that I hate underlining
03:28:49 <notadev> hehe
03:28:54 <masklinn> dons, no, emacs' irc client clearly doesn't understand ascii color codes
03:29:06 <dons> masklinn: what about the above irc colour codes?
03:29:08 <masklinn> apart from the underline under where (is it supposed to be underlined?)
03:29:14 <dons> it is.
03:29:14 <kosmikus> oh, I see this has been discussed before
03:29:18 <Saul_> Does anyone know where I can find some info on HLists?
03:29:22 <masklinn> dons, no color either
03:29:30 <Saul_> All I can find is the source and news about updates
03:29:33 <masklinn> well it colorizes the color code themselves (in light blue)
03:30:00 <malcolmw> dons: that perl script looks like line noise to me
03:30:05 <glguy> dons: I don't think that the where should be underlined
03:30:08 <dons> me too. blame mauke 
03:30:14 <glguy> dons: but otherwise it looks good to me :)
03:30:14 <malcolmw> is there documentation of the mirc codes anywhere readable?
03:30:29 <notadev> it's green and underlined here if that helps :)
03:30:33 <mauke> I used http://irssi.org/documentation/formats
03:30:35 <lambdabot> Title: Irssi - The client of the future
03:31:03 <dons> yes, if we can get this working reliably, i wouldn't mind adding it to lambdabot
03:31:16 <dons> for @src and @type, for example.
03:31:26 <masklinn> http://www.emacswiki.org/cgi-bin/wiki/rcirc
03:31:28 <lambdabot> Title: EmacsWiki: rcirc
03:31:30 <oerjan> just as long as everyone sees it with either color or without extra characters
03:31:32 <masklinn> the client of the past :p
03:32:29 * oerjan wants the client of time travelers
03:32:36 <mauke> clients that don't render color codes should at least ignore them
03:32:51 <malcolmw> mauke: I don't think I understand the table given at that link either
03:32:51 <notadev> %9test%n
03:32:55 <notadev> ah well
03:33:02 <mauke> malcolmw: which one?
03:33:14 <malcolmw> mauke: irssi one
03:33:26 <mauke> malcolmw: that contains three tables
03:33:51 <malcolmw> mauke: first table: the 3 columns at the left are not labelled, and the next 2 columns have the same label
03:34:04 <mauke> ignore the first tables
03:34:08 <mauke> s/s$//
03:34:12 <dons> gunfold 05:: forall 10(c 05:: 10* 05-> 10*10) a10.  10(Data a10) 05=> 10(forall b r10. 10(Data b10) 05=> c 10(b 05-> r10) 05-> c r10) 05-> 10(forall r10. r 05-> c r10) 05-> Constr 05-> c a
03:34:17 <dons> pretty types
03:34:35 <mauke> you're probably not going to hack on irssi formats
03:34:38 <malcolmw> mauke: ah, right, thanks
03:34:43 <mauke> the useful stuff is at the end
03:35:02 <notadev> so how do i put text into bold then, mauke?
03:35:04 <masklinn> dons, rcirc hates you
03:35:11 <mauke>  <Ctrl>-b        set bold
03:35:15 <notadev> (not on irssi)
03:35:39 <malcolmw> FOO
03:35:41 <mauke> well, ^B works in irssi. no idea what other clients need to send a ^B
03:35:51 <notadev> ^Bbold^n
03:35:54 <notadev> hehe
03:35:59 <mauke> wtf
03:36:06 <notadev> i knoe
03:36:10 <mauke> control B
03:36:25 <notadev> point is it has to send a char seq, and i would like to know what that is
03:36:46 <quicksilver> the char sequence is ctrl-b, I believe?
03:36:48 <mauke> <Ctrl>-b, ^B, control B, C-b
03:36:50 <notadev> is it same as shell escape?
03:36:50 <quicksilver> ASCII 2
03:37:01 <notadev> ascii 2? thanks quicksilver :-)
03:37:09 <malcolmw> bold
03:37:09 <quicksilver> that's what ctrl-b means, notadev :P
03:37:19 <notadev> cool ;)
03:37:32 <malcolmw> on Colloquy, one needs to use the apple key rather than ctrl
03:38:12 <notadev> bold
03:38:15 <notadev> yay!
03:38:40 <Syzygy-> This is bold.
03:38:42 <Syzygy-> See.
03:38:45 <Syzygy-> I made it!
03:38:47 <notadev> 4Red
03:38:55 <malcolmw> 09green
03:39:04 <notadev> heh so which turns off?
03:39:07 <mauke> cirssi
03:39:08 <Syzygy-> ^N
03:39:09 <Syzygy-> normally
03:39:12 <mauke> ^O
03:39:15 <glguy> irssi uses ^O
03:39:16 <notadev> thanks mauke
03:39:18 <Syzygy-> Or .. at least the mIRC codes...
03:39:20 <Syzygy-> ah.
03:39:27 <Syzygy-> Bold and not bold
03:39:35 <Syzygy-> Ummmm. That didn't work as expected.
03:39:40 <notadev> bold
03:39:41 <Syzygy-> With ^O
03:39:42 <notadev> hmm
03:39:45 <Syzygy-> I get a lighter colour as without.
03:39:49 <notadev> not ascii 0 then
03:40:00 <Lamperi> :o
03:40:09 <quicksilver> no, ^O is ascii 15, because ) is the 15th letter of the alphabet
03:40:12 <notadev> Syzygy-: both looked same here
03:40:17 <notadev> quicksilver: ah ok :)
03:40:19 <notadev> thanks!
03:40:26 <quicksilver> ctrl just means 'mask off top 3 bits'
03:40:26 <glguy> does anyone know a good dark firefox theme?
03:40:27 <Lamperi> ygy-: both looked same here
03:40:40 <Syzygy-> notadev: I get a greyish kinda thing normally, and bright white with ^O
03:40:44 <glguy> I need something for when I'm staying up too late and the brightness hurts my eyes
03:40:57 <glguy> the rest of my desktop is xterm windows with black backgrounds :)
03:41:02 <notadev> bold test
03:41:08 <notadev> wtf?
03:41:09 <ricky_clarkson> A.. brightness control on your monitor?
03:41:12 <Syzygy-> BoldNormal?
03:41:13 <Syzygy-> Nope.
03:41:15 <notadev> oh reset colour here
03:41:15 <Syzygy-> That's not it.
03:41:25 <Syzygy-> We're having too much fun, are we?
03:41:28 <Syzygy-> ;)
03:41:34 <quicksilver> > (ord 'O' .&. 31)
03:41:35 <lambdabot>  15
03:41:43 <notadev> hehe
03:41:56 <mauke> > ord 'O' `xor` 64
03:41:57 <quicksilver> 'ctrl' means 'mask off top 3 bits'. 'alt' means 'set high bit'
03:41:58 <lambdabot>  15
03:42:01 <quicksilver> traditionally
03:42:03 <ricky_clarkson> > chr 15
03:42:04 <lambdabot>  '\SI'
03:42:07 <mauke> > ord '?' `xor` 64
03:42:08 <lambdabot>  127
03:42:12 <mauke> and thus, ^? is 127
03:42:27 <Syzygy-> > ord '?'
03:42:28 <lambdabot>  63
03:42:40 <notadev> i just want to know which one turns off bold, 15 reset colour, not impression here.
03:42:47 <glguy> > showBin 63 ""
03:42:47 <lambdabot>   Not in scope: `showBin'
03:42:54 <Syzygy-> Hmmm.
03:42:55 <glguy> > showBinary 63 "" -- ?
03:42:55 <quicksilver> bold again turns off bold
03:42:55 <mauke> notadev: ^B again
03:42:56 <lambdabot>   Not in scope: `showBinary'
03:42:58 <quicksilver> AFAIK
03:42:59 <Syzygy-> boldnotbold
03:43:01 <Syzygy-> There we go!
03:43:04 <notadev> mauke: thanka!
03:43:10 <notadev> s*
03:43:10 <Syzygy-> quicksilver++
03:43:11 <glguy> :t showBase
03:43:13 <lambdabot> Not in scope: `showBase'
03:43:14 <glguy> :t showAtBase
03:43:15 <lambdabot> Not in scope: `showAtBase'
03:43:26 <notadev> bold test
03:43:28 <notadev> yay!
03:43:35 <glguy> showIntAtBase 2 63 ""
03:43:38 <Syzygy-> 2Red5Blue
03:43:57 <Syzygy-> Ok. I'm happy. I'll stop spamming and colourizing now. Promise!
03:44:00 <oerjan> :t showIntAtBase
03:44:02 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
03:44:04 <mauke> atest
03:44:04 <glguy> > showIntAtBase 2 intToDigit 63 ""
03:44:06 <lambdabot>  "111111"
03:44:32 * glguy wonders if he can kick someone with a flashing kick reason
03:44:40 <mauke> this would be a lot easier if printf supported %b
03:44:45 <Syzygy-> glguy: Most probably, yeah.
03:44:54 <Syzygy-> But please don't test it on me.
03:44:54 <mauke> er, did my test above blink for anyone?
03:45:00 <glguy> mauke: um, yeha :)
03:45:05 <Syzygy-> mauke: Grey on grey. No blink.
03:45:11 <notadev> mauke: no
03:45:37 --- mode: ChanServ set +o glguy
03:45:46 <Syzygy-> mauke: The important question now is - how much do you -believe- CTCP VERSION.
03:45:56 <mauke> Syzygy-: not at all. I think you're running irssi
03:46:02 <Syzygy-> :P
03:46:06 <glguy> mauke: what color is that blinking text
03:46:22 <glguy> mauke: rather, what number color
03:46:28 <mauke> it's not a color per se, I used one of irssi's internal color formats
03:46:31 * Please_Kick_Me wants to see the shiny kick message.
03:46:45 --- kick: Please_Kick_Me was kicked by glguy (KICKED)
03:47:15 <glguy> was that KICKED reversed?
03:47:16 <Please_Kick_Me> That was sweet. Bright red on my screen, though not flashing. ^_^
03:47:23 <Olathe> glguy: Yes.
03:47:30 <mauke> glguy: "\x04\x61"
03:47:33 <glguy> cool, then the kick message supports it
03:47:37 <notadev> nah just bold here
03:47:40 <Please_Kick_Me> Oh no, wait, my bad, reversed, jah.
03:47:51 <glguy> I didn't know what hte flashing code would be
03:47:53 <Syzygy-> Oh yeah... I filter away kicks and suchlikes.... Ooops.
03:47:55 * Please_Kick_Me was looking at his running copy of Xchat.
03:48:04 <notadev> konversation here
03:48:26 --- mode: glguy set -o glguy
03:48:38 <glguy> now all we need is people to kick...
03:48:44 <notadev> lol
03:48:45 <glguy> that actually doesn't come up so much
03:48:49 <MyCatSchemes> Hmmm. Tried to send "QUIT :This clone's purpose has been served." there.
03:49:02 * Philippa points out that colours are a bad idea: amongst other things, you don't know what a user's background colour is
03:49:10 <notadev> true
03:49:14 <MyCatSchemes> And yet it didn't get displayed. I wonder if I just typo'd there.
03:49:28 <glguy> Philippa: you can set the background color too :)
03:49:33 <glguy> Philippa: then you'd know ;)
03:49:37 <mauke> MyCatSchemes: maybe the server ignored your quit message
03:49:40 <oerjan> MyCatSchemes: freenode has a minimum time before you are allowed to use QUIT messages
03:49:40 <Syzygy-> glguy: Which isn't necessarily a good idea either.
03:49:49 <Philippa> glguy: yeah, this is called 'rude'. That, and fugly
03:49:49 * glguy wasn't necessarily saying tha it was
03:49:52 <Syzygy-> Philippa: The original rationale for letting us loose was to enable bold and underlines.
03:49:54 <MyCatSchemes> Philippa: well jah, but reverse colour is almost always fine. Plus if you set the background colour too then you're fine, provided nobody has a b&w terminal. ;)
03:50:01 <MyCatSchemes> oerjan: ah, thank you.
03:50:07 <Syzygy-> MyCatSchemes: And how do you know -that-.
03:50:09 <mauke> everyone should just use white-on-black
03:50:23 <MyCatSchemes> Syzygy-: how do I know what?
03:50:31 <Philippa> mauke: actually that's an accessibility issue
03:50:32 <Syzygy-> MyCatSchemes: That everyone's on a decent enough terminal.
03:50:33 <notadev> 7,2shame that ;)
03:50:36 <Philippa> some people read much faster with a seemingl-yodd colour scheme
03:50:42 <glguy> if people don't like colors: /set colors off   works in irssi , for example
03:50:46 <glguy> if it doesn't get out of hand
03:50:48 <Syzygy-> MyCatSchemes: Note that dons sees all the formatting codes instead.
03:50:49 <ricky_clarkson> notadev: C64 style.
03:51:01 <notadev> hehe yeah couldn't find yellow :)
03:51:13 <notadev> funny thing is bg colour didn't show here :)
03:51:19 <MyCatSchemes> Syzygy-: it doesn't actually matter. Anyone comes into the channel with a black and white terminal, it *ought* to just ignore the colour codes from the IRC client, surely?
03:51:22 * Syzygy- points out that color number mapping tables are easily available after a quick google.
03:51:30 <Syzygy-> MyCatSchemes: Ought != does
03:51:33 <Philippa> MyCatSchemes: no. Colour codes aren't part of the RFC
03:51:55 <glguy> what modern irc clients don't know how to handle them?
03:52:01 <notadev> 8,2 hmmm ;)
03:52:05 <notadev> yeuch
03:52:08 <glguy> don't ruin it yo
03:52:11 <Philippa> glguy: never IRCed using telnet?
03:52:11 <mauke> +c isn't part of the RFC either
03:52:12 <notadev> i'll stop now
03:52:14 <MyCatSchemes> I mean in the terminal (emulator)? itself. Not the RFC.
03:52:22 <glguy> Philippa: that's not a modern irc client , but yes i have :)
03:52:24 <Philippa> mauke: sure, but it's a server-side feature
03:52:24 <MyCatSchemes> Philippa: telnet? Bah! Netcat. :)
03:52:47 * MyCatSchemes waves at Please_Kick_Me's ghost. Guess what client that was. :)
03:52:54 <ricky_clarkson> I rarely IRC without ssh.
03:52:55 <Philippa> incidentally at least one modern client doesn't strip BELs and /does/ play them
03:53:04 <glguy> > 1 -- I bet lambdabot doesn't know what to do with these
03:53:04 <lambdabot>  Illegal character ''\STX''
03:53:12 <MyCatSchemes> Philippa: ...oh, blimey.
03:53:13 <notadev> i agree colours are a bad idea ;)
03:53:29 <notadev> blimey
03:53:34 <Syzygy-> Though can be used for emphasis if necessary.
03:53:40 <Syzygy-> Doh. ^O didn't cancel itself.
03:54:23 <glguy> ugh, its later than I thought
03:54:27 * notadev stops playing about
03:54:29 <glguy> tty all l
03:54:32 <Philippa> heh, nearly noon here
03:54:39 <notadev> heh yeah
03:54:39 * glguy wonders what the channel flags will  be set at when he wakes up ;)
03:54:55 <notadev> heh no-colours for definite ;)
03:55:02 <ricky_clarkson> Nearly noon here too.  I suppose I ought to get up.
03:55:05 <glguy> yeah, if you have anything to say about it, right?
03:55:30 <notadev> well i guess the bot needs to put colours for some of that stuff
03:55:36 <ricky_clarkson> +c is no-colours, iirc.
03:55:46 <Syzygy-> ricky_clarkson: Yup
03:55:47 <glguy> yup, that's the flag that we just removed
03:55:57 <Syzygy-> The current mayhem started when glguy made a good case for the flag to be dropped.
03:56:12 <glguy> and everyone is getting adjusted
03:56:17 <glguy> i expect it to calm down
03:56:25 <glguy> someone is doing vixen now either
03:56:32 <DRMacIver> Ugh.
03:56:36 <glguy> err
03:56:37 <glguy> no one*
03:56:43 <glguy> but its late!
03:56:44 * glguy &
03:56:47 <notadev> nn
03:56:48 <MyCatSchemes> glguy: doing vixen? In which end?
03:56:48 <DRMacIver> This code is a nigh canonical example of why people should use parser generators instead of regexps.
03:57:08 <dons> gunfold 05:: forall 10(c 05:: 10* 05-> 10*10) a10.  10(Data a10) 05=> 10(forall b r10. 10(Data b10) 05=> c 10(b 05-> r10) 05-> c r10) 05-> 10(forall r10. r 05-> c r10) 05-> Constr 05-> c a
03:57:28 <Syzygy-> dons: The red ends up dark to the point of nigh unreadability to me.
03:57:30 <notadev> hmm not sure about those colours tbh
03:58:00 <notadev> i think you should just embolden operators and leave it at that
03:58:26 <wolverian> I prefer making the data names stand out instead of the operators
03:58:36 <MyCatSchemes> DRMacIver: ?
03:58:40 <notadev> good point
03:58:44 <quicksilver> it must depend on your colours, I guess
03:58:45 <Philippa> dons: it's a really bad idea in chan itself. Bold's not quite so horrible
03:58:53 <quicksilver> for me, that looked really nice
03:58:53 <notadev> quicksilver: exactly
03:58:57 <quicksilver> the data names did stand out
03:59:05 <wolverian> the red is too strong on my palette
03:59:09 <notadev> point is you can't mandate people's term settings
03:59:11 <Philippa> it looked readable but not great from here
03:59:29 <MyCatSchemes> wolverian: depends. If you use dark reds and blues for the operators, the symbols themselves do stand out for their lack of highlighting.
03:59:30 <wolverian> you can underline too, by the way.
03:59:35 <Syzygy-> Readable, but with readability issues from here.
03:59:44 <notadev> what's underline then wolverian?
03:59:47 <wolverian> MyCatSchemes, not really. the red is very strong here, it stands out, even though it is quite dark. 
03:59:49 <Philippa> MyCatSchemes: if you use dark blue, I can't read it. Guess my background colour?
03:59:54 <wolverian> notadev, it's a line under the text...
03:59:57 <Tychom> is it possible using Text.Regex to specify a non-greedy quantifier such as '*', e.g. something like "(.*?)[ ]*" which would (hopefully) not match any trailing whitespace in a given string
04:00:00 <MyCatSchemes> Philippa: hawt pink!
04:00:00 <notadev> lol
04:00:02 <Syzygy-> Philippa: Black or blue.
04:00:17 <MyCatSchemes> Wait, no, that's what it *should* be.
04:00:34 <MyCatSchemes> Speaking of which, anyone know offhand how to configure xchat to look like the inside of a whorehouse?
04:00:40 <notadev> wolverian: bold is ascii 2 for example ;)
04:00:59 <wolverian> notadev, oh, I dunno. ctrl+_ in irssi... :)
04:01:09 <oerjan> Tychom: isn't that backwards? * usually greedy and *? not
04:01:15 <Syzygy-> undeline
04:01:16 <quicksilver> > (ord '_' `xor` 64)
04:01:17 <lambdabot>  31
04:01:18 <MyCatSchemes> That or ctrl+7.
04:01:22 <notadev> bold _underline_ /italics/ are the only ones i think you should allow; colour is a no-no imo
04:01:28 <MyCatSchemes> Depending which is easier to reach.
04:01:40 <wolverian> agreeing with notadev 
04:01:47 <notadev> hmm CTRL-B is ascii 2, so CTRL-_ is wtf?!
04:01:49 <wolverian> colour is simply too variable between people
04:01:53 <DRMacIver> MyCatSchemes: Just reviewing some code at work. It's rather nasty.
04:01:53 <notadev> yeah
04:02:03 <MyCatSchemes> DRMacIver: bummer. Happens.
04:02:03 <Tychom> oerjan: i think what i wrote was a little vague, but basically thats what i had in mind - greedy = *, non-greedy = *?
04:02:06 <Syzygy-> notadev: I'm pretty certain I can't -get- italics. Though /this/ is probably enough.
04:02:11 <notadev> yeah
04:02:32 <DRMacIver> MyCatSchemes: Thing is, it's not badly written. It's just conceptually weak.
04:02:34 <matthew_-> DRMacIver: you at your new $work yet?
04:02:38 <notadev> i'm happy, i've found the one i wanted, ty all :-)
04:02:39 <wolverian> my font has italics, so I suppose the terminal could be hacked to support it..
04:02:53 <MyCatSchemes> DRMacIver: could be worse then, I guess.
04:02:58 <wolverian> it just tends to change the font outline 
04:03:08 <quicksilver> notadev: I just showed you what ctrl+'_' was
04:03:12 <wolverian> note that bold does this too, particularly with terminals that don't support real bolding (e.g. gnome-terminal)
04:03:20 <wolverian> that's why bold for me is just highlighted instead of actual bold
04:03:24 <notadev>  /this/ is ok by me but irritating at the start of a line ;)
04:03:28 <oerjan> Tychom: oh. well i don't know.
04:03:40 <wolverian> (gnome-terminal does stupid double-drawing instead of changing to the bold version of the font. it's an ages old bug.)
04:03:50 <notadev> quicksilver: o yeah, 3 bits masked off :-)
04:03:58 <matthew_-> gnome-terminal is worse than xterm
04:04:11 <wolverian> I prefer it over xterm, really, mostly because of the gui.
04:04:15 <wolverian> and tabs.
04:05:02 <MyCatSchemes> wolverian: I'd rather use GNU screen for that.
04:05:11 <DRMacIver> matthew_-: No, I start in August.
04:05:15 <wolverian> hm, rxvt-unicode-ml has perl interpreter in it ...
04:05:18 <oerjan> notadev: /this/ is not going to work for coloring haskell however.
04:05:25 <notadev> thanks quicksilver wfm :)
04:05:27 <wolverian> MyCatSchemes, yeah, it works too.
04:05:31 <ricky_clarkson> gnome-terminal has clickable URLs, iirc.
04:05:37 <notadev> oerjan: true
04:05:39 <mauke> so does urxvt
04:05:40 <wolverian> ricky_clarkson, yes, that's another nice feature.
04:05:57 <MyCatSchemes> wolverian: it's mainly that reaching over for the pageup/pagedn keys is a pain in the bum. Plus I'm a urxvt fanboy. ;)
04:06:21 <wolverian> MyCatSchemes, yar :)
04:06:47 <wolverian> now how do I tell urxvt what font to load? does -fn want an X fontstring?
04:06:55 <wolverian> (it's compiled with freetype)
04:06:59 <vincenz> how do you do colours in irssi
04:07:11 <wolverian> vincenz, ctrl+c 
04:07:35 <MyCatSchemes> wolverian: -fn takes an X fonstring, jah. It can also take xft fontstrings.
04:08:04 <wolverian> how do I tell it to take an xft fontstring?
04:08:04 <MyCatSchemes> Like, my .Xdefaults has: "URxvt*font: xft:Bitstream Vera Sans Mono:pixelsize=16"
04:08:08 <wolverian> ah, thanks.
04:08:19 <notadev> gunfold :: forall (c :: * -> *) a.  (Data a) => (forall b r. (Data b) => c (b -> r) -> c r) -> (forall r. r -> c r) -> Constr -> c a      
04:08:29 <MyCatSchemes> (Oh and reverseVideo: on, cursorBlink: off, scrollBar: off)
04:08:30 <notadev> hmm
04:08:52 <notadev> gunfold :: forall (c :: * -> *) a.  (Data a) => (forall b r. (Data b) => c (b -> r) -> c r) -> (forall r. r -> c r) -> Constr -> c a      
04:08:59 <notadev> meh w/e
04:09:00 <wolverian> aw, that's a bit of a mess
04:09:03 * MyCatSchemes doesn't entirely understand why people seem to have 9x15 so much.
04:09:21 <notadev> wolverian: sry was trying underline for data types
04:09:39 <wolverian> notadev, yeah, it just doesn't look very good. :\ 
04:09:47 <vincenz> rtest
04:09:49 <notadev> heh agreed :-)
04:09:50 <vincenz> 0test
04:09:54 <vincenz> wolverian: thx
04:11:29 <notadev> gunfold :: forall (c :: * -> *) a.  (Data a) => (forall b r. (Data b) => c (b -> r) -> c r) -> (forall r. r -> c r) -> Constr -> c a      
04:11:47 <notadev> not sure any of it's needed tbh
04:12:25 <ndm> @seen andyjgill 
04:12:25 <lambdabot> andyjgill is in #haskell and #ghc. I last heard andyjgill speak 2h 49m 23s ago.
04:12:47 <ndm> andyjgill: you did the Haskell Equational Reasoning Assistant, right?
04:13:05 <notadev> gunfold :: forall (c :: * -> *) a.  (Data a) => (forall b r. (Data b) => c (b -> r) -> c r) -> (forall r. r -> c r) -> Constr -> c a -- leaving out parens.
04:13:06 <ndm> andyjgill: is it publically available yet? or ready for beta testers? I'd love to use it to prove some stuff
04:14:40 <Syzygy-> Right.
04:14:48 <wolverian> it'd be nice if hovering over a variable name highlighted it elsewhere in the expression... 
04:14:55 <wolverian> ...I guess we need javascript for irc
04:14:55 <notadev> hehe
04:15:00 <notadev> that's for an ide
04:15:01 <Syzygy-> Having tested it, it really does turn out that for my larger jobs, I want to tune down the garbage collector in GHC.
04:16:06 <Syzygy-> After running it for 10ks, I get 4x as much done with GC heap of 256M than with the standard setup.
04:16:31 <Syzygy-> And the GC takes up 78% of these 10ks with standard settings, and 2% with the large heap.
04:16:52 <notadev> makes sense
04:17:01 <wolverian> what's the standard heap?
04:17:06 <dons> Philippa: talk to glguy, if the colourings no good
04:17:11 <vincenz> @localtime Philippa 
04:17:14 <lambdabot> Local time for Philippa is Wed Jul 11 12:16:43 2007
04:17:14 <vincenz> @localtime psykotic 
04:17:15 <lambdabot> Local time for psykotic is Wed Jul 11 20:17:37
04:17:19 <dons> i note it does make it hard to grep the logs 
04:17:30 <vincenz> dons: make the logs colourless :)
04:17:47 <Philippa> dons: my point's more that there are no good colourings
04:17:52 <notadev> yeah strip out any non-printable chars
04:17:56 <Philippa> not when you're talking to an entire chan
04:18:04 <notadev> i agree with Philippa about that tho
04:18:41 <notadev> bold and underline are ok tho
04:18:44 <Philippa> private's different, and if you're willing to maintain some per-user options that'd make sense. Likewise if you're doing something like GOA
04:19:07 <notadev> per-user would be excessive
04:19:24 <notadev> oh for pm
04:19:26 <notadev> sry
04:19:36 <mauke> what's wrong with client-side filtering?
04:19:46 <notadev> er
04:19:57 <notadev> irc is inherently monochrome tho
04:20:02 <wolverian> mauke, same thing as with spamfiltering.
04:20:06 <Philippa> what's wrong is that it shouldn't be necessary in the first place
04:20:13 <notadev> exactly.
04:20:24 <quicksilver> that is not a convincing argument, in isolation
04:20:37 <notadev> this is in-situ tho ;)
04:20:43 <ricky_clarkson> It's not part of the RFC.
04:20:51 <ricky_clarkson> But then, neither is UTF-8.
04:20:53 <quicksilver> you have to balance the views of those inconvenienced by the colours against those who find them useful
04:21:01 <notadev> hmm
04:21:08 <quicksilver> you can't just say "filtering shouldn't be necessary" as if that ends the discussion
04:21:20 <Philippa> quicksilver: there's been some discussion, so drop the patronising metacrap
04:21:39 <notadev> that;s like saying you shouldn't bother to do accessible web sites, since most people aren't affected.
04:21:46 <quicksilver> I apologise if you thought I was patronising
04:22:00 <quicksilver> just stating that I didn't find that particular argument convincing
04:22:02 <Philippa> sorry, that was excessive of me
04:22:04 <notadev> hmm not really
04:22:38 <notadev> the "in isolation" thing is a trait others display though, when they are being patronising ;)
04:22:43 <quicksilver> people who don't like colour could filter; of course the question is: how hard is it for them to filter? how many people would that annoy?
04:22:51 <quicksilver> I don't know the answers to either of those.
04:23:15 <Philippa> we've already established that when rendered as colour, it can leave text unreadable. When not rendered (and there's always a client that doesn't do it right - we've already seen logs as an example) it's not pretty at all
04:23:15 <notadev> well we're countering that the question should be: why inconvenience in the first place?
04:23:31 <quicksilver> notadev: because it enhances the discourse
04:23:34 <notadev> hmm
04:23:40 <Philippa> however, it doesn't enhance by that much
04:23:48 <quicksilver> notadev: it's useful to be able to communicate the difference between syntax and meta syntax, say
04:23:52 <notadev> colours are tricky, eg due to colour-blindness
04:23:56 <quicksilver> notadev: and you can do that with bold, or something
04:24:02 <notadev> :)
04:24:17 <Philippa> quicksilver: we're not having the general discussion, we're talking about lambdabot
04:24:22 <quicksilver> and indeed we did for a while have a completely blind channel-user
04:24:31 <notadev> ah ok
04:25:05 <notadev> it's like web design imo; you design so that the base can use it easily.
04:25:23 <quicksilver> Philippa: the main reason that glguy gave to me for removing the +c was for general discussion enhancment
04:25:39 <quicksilver> Philippa: the lambdabot thiing was just a natural cute hack
04:25:42 <quicksilver> now +c was off
04:25:46 <notadev> i can see the merits in bold and underline for lb
04:25:59 <ricky_clarkson> My client shows *this* in bold.
04:26:05 <notadev> mine doesn't
04:26:06 <oerjan> maybe there ought to be a graded +c option, that only allows bold and underline.
04:26:10 <ricky_clarkson> And _this_ underlined.
04:26:14 <notadev> nope
04:26:22 <quicksilver> oerjan: that needs server-side support which we presumably don't have
04:26:26 <Syzygy-> ricky_clarkson: sprinkling * * and _ _ into lambdabot output might be detrimental though.
04:26:29 <ricky_clarkson> I'll sell you a copy of mine.  It's called irssi.
04:26:32 <notadev> altho i do like that syntax personally, ricky_clarkson
04:26:41 <notadev> yeah i know, i used to use it ;)
04:26:41 <quicksilver> ricky_clarkson: mine too, but that's confusing since * and _ mean something in haskell programs
04:26:47 <ricky_clarkson> Right.
04:26:48 <oerjan> quicksilver: well not _yet_.
04:26:48 <notadev> as well as BitchX
04:26:49 <Philippa> ricky_clarkson: those're also non-standard
04:27:37 <Philippa> quicksilver: there's a difference between individuals doing it - where non-coded versions of text can be easily requested - and lambdabot doing it
04:27:46 <quicksilver> yes, that's true
04:28:11 <Philippa> ricky_clarkson: not only are they non-standard, but they're less widely-spread
04:28:26 <notadev> oerjan: bold and u/l work in -c
04:28:48 <ricky_clarkson> I noticed that Gmail's chat makes *this* bold, and gets rid of the stars.  Makes talking about global variables in Lisp annoying.
04:29:02 <notadev> hehe
04:29:04 <oerjan> notadev: i mean that there ought to be a way to permit them in channels where full colors would be problematic
04:29:15 <Philippa> yeah, same reason I hate automagic emoticons in IM clients - they screw up all my parentheticals
04:29:27 <quicksilver> ricky_clarkson: yes, also annoying when smileys form program syntax
04:29:29 <notadev> oerjan: sorry that's what i meant tho; when no colours is set, bold and u/l still work
04:30:14 <oerjan> notadev: er... i thought allowing them was the point of this.  let me check.
04:30:21 <Philippa> using *this* and _this_ in bot output's an even more broken idea. OTOH, they make a good human-readable encoding for ordinary text
04:30:28 <notadev> no it was colours in general aiui
04:30:51 <oerjan> notadev: you are right!
04:30:59 <notadev> :D
04:31:17 <notadev> i love it when someone tells me that ;-)
04:31:32 <mauke> This cmode activates the colour filter for the channel. This filters out bold, underline, reverse video, beeps, mIRC colour codes, and ANSI escapes. 
04:31:41 <mauke> freenode says you're wrong
04:31:51 <notadev> well not ime
04:31:59 <notadev> try it and see ;)
04:32:00 <oerjan> mauke: i just tested on another channel with +c
04:32:09 <mauke> oerjan: using two clients?
04:32:17 <oerjan> ooh...
04:32:25 <notadev> oic
04:33:01 <oerjan> notadev: i must regretfully retract my "you are right!"
04:33:06 <notadev> awww
04:33:10 <notadev> hehe
04:33:15 <quicksilver> notadev: you were wrong!
04:33:18 <notadev> nm i enjoyed the high
04:33:25 <notadev> and now teh low, ty quicksilver 
04:33:28 <notadev> ;)
04:33:47 <notadev> hehe
04:34:09 <notadev> well so you could allow colours, but not in lambdabot
04:34:46 <notadev> it's only ascii 2 and 15 that you need; any other below 32 is disallowed?
04:34:56 <Philippa> yeah, most of my objection to colours-in-general has more to do with the many obnoxious scripted uses of them
04:35:12 <Philippa> so mostly I'm happy to stick to social measures for such things
04:35:14 <notadev> heh like cia?
04:35:29 <notadev> i agree tho
04:36:18 <notadev> bold and u/l would help for syntax highlighting in pedagogical material in lb
04:36:25 * quicksilver nods
04:36:31 <quicksilver> we can do the LB colouring however we want
04:36:42 <notadev> cool! :)
04:36:52 <quicksilver> we can even have it work in glorious fruit salad mode unless Philippa has spoken in the last 15 minutes :)
04:37:03 <notadev> and then mauke can still use his script in here :)
04:37:05 <notadev> lol
04:37:19 <notadev> i think that's excessive ;)
04:37:33 <quicksilver> it's just possible I wasn't serious
04:37:37 <quicksilver> hard to tell, with me, though
04:37:51 <Philippa> I think in lambdabot's case we have a choice between a) transmitting fg but not bg b) transmitting both or c) dropping it
04:37:53 <notadev> hehe
04:38:07 <Philippa> option a has the problem that there's always someone who won't be able to read it without turning off colour codes entirely
04:38:09 <notadev> or d) only using bold and u/l
04:38:19 <Philippa> notadev: I'm talking colour
04:38:23 <notadev> ah ok
04:38:30 * notadev votes for no colour then
04:38:33 <Philippa> however, bold and u/l do have a further problem regarding logs
04:38:56 <dons> ok, the no colour people need to talk to glguy in the morning
04:38:58 <notadev> that's another prog tho, and as simple as stripping non-printable for all logging
04:39:15 <Philippa> dons: when's glguy's morning?
04:39:28 <dons> he's on PDT time, so 6 hours or so
04:39:49 <notadev> 7-8pm he'll be awake then
04:39:55 <Philippa> also: is this a polite oply "STFU"?
04:40:31 * notadev hides
04:40:52 <dons> no no, just that i don't care, and he's responsible for the whole thing.
04:41:03 <dons>  foldr k z xs 05= go xs
04:41:03 <dons>      03where go 05[05]     05= z
04:41:03 <dons>            go 10(y05:ys10) 05= y 10`k` go ys
04:41:07 <dons> i think that's nice though :)
04:41:09 <oerjan> yikes, this looks bad at ircbrowse
04:41:26 <Philippa> it's nice where it works, yeah. It'd certainly be worth hanging on to the code for it
04:41:29 <notadev> thing is allowing bold and u/l implies a change in channel policy as well, since colours have to be allowed in general
04:41:46 <Philippa> notadev: chan policy's already changed
04:41:50 <notadev> ah ok
04:41:51 <dons> Philippa: so year, i'm just suggesting how you can resolve the issue.
04:41:54 <dons> we had a policy?
04:41:58 <notadev> heh
04:41:59 <Philippa> we had +c set
04:42:08 <dons> yeah, but this is an experiment
04:42:11 * wli tries to figure out how to memoize this crap.
04:42:32 <notadev> strip chars below 32?
04:42:39 <dons> Philippa: you seem to think I'm far ruder than I think I am :) I must use more smilies
04:42:45 <notadev> haha
04:42:56 <Philippa> dons: you seem to forget how flippant I'm capable of being :-)
04:43:00 <dons> :)
04:43:05 <vincenz> flippa :)
04:43:25 <Philippa> that is, I'll often use "STFU" for "please stop talking about this now"
04:43:26 <vincenz> seems your nick just received another meaning ;)
04:43:39 <dons> so what's the policy? that colour be allowed, but not scripted?
04:43:46 <ClaudiusMaximus> what can i use to munge [0..n] into:  foo >>= blah 0 >>= blah 1 >>= blah 2 >>= ... >>= blah n >>= frob
04:43:48 --- mode: ChanServ set +o vincenz
04:43:48 <dons> and scripts could possibly use bold ?
04:43:51 <notadev> that's a semi-consensus so far
04:43:52 --- mode: vincenz set +c
04:43:55 --- mode: vincenz set -o vydd
04:43:56 <notadev> yeah and underline
04:43:57 --- mode: vincenz set -o vincenz
04:44:07 <Philippa> I can go with that
04:44:10 <vincenz> underline and bold are client-side rendering of *a* and _b_
04:44:12 <dons> vincenz: hmm i think we're supposed to leave it on till there's consensus..
04:44:17 <vincenz> dons: you meana off?
04:44:23 <dons> leave colours on :)
04:44:27 <vincenz> oh right :)
04:44:28 <Philippa> vincenz: actually that's not the only way to do them IIRC
04:44:29 --- mode: ChanServ set +o vincenz
04:44:31 <notadev> vincenz: no they're not.
04:44:33 --- mode: vincenz set -c
04:44:37 --- mode: vincenz set -o vincenz
04:44:38 <notadev> vincenz: no they're not.
04:44:38 <Philippa> this should also be bold
04:44:42 <notadev> indeed
04:44:49 <Philippa> (ctrl-B in mirc, and no * involved)
04:44:52 * vincenz likes wiki-syntax
04:44:56 <dons> ok, i can live with the 'no scripting' rules
04:45:04 <dons> we'll see if anyone uses colours then
04:45:04 * wli notes that he appears to have devised a useful method of enumerating indices in graded lexicographical order.
04:45:10 <notadev> ascii 2 for bold, ascii 31 for underline, same char turns off
04:45:16 <quicksilver> ClaudiusMaximus: foldr and map, probably
04:45:17 <dons> note we have a similar issue with unicode
04:45:23 <dons> i can't read any of the unicode people post 
04:45:27 <vincenz> I vote we only allow the characters [1,2]
04:45:28 <vincenz> erm
04:45:29 <dons> its just line noise
04:45:30 <vincenz> [0,1]
04:45:36 <notadev> Ã?
04:45:39 <vincenz> You may choose whatever binary decoding you want
04:45:40 <quicksilver> ClaudiusMaximus: foldr (>>=) . map blah . [0..n]
04:45:59 <dons> so its a social thing -- if someone cares they can ask for unicode or colour to be used, and it would only be introduced when it matters anyway
04:46:03 <ClaudiusMaximus> quicksilver: cool, thanks
04:46:05 <Philippa> yeah, I used to have that. I think it's fair to specify a preferred encoding (I vote UTF-8) though
04:46:19 <Philippa> there're two use cases - one's non-english text, the other's maths. The latter we want to support reasonably
04:46:19 <notadev> i vote utf-8 too as default
04:46:28 <notadev> it supports all
04:46:40 <dons> foldr 10(10>>=10) 10. map blah 10. 05[06005..n05]
04:46:52 <dons> cool, i've got this sorted
04:46:55 <quicksilver> non-english text is also useful insofar as people might as questions about UTF8 support in haskell
04:47:09 * profmakx likes the syntax coloring ;)
04:47:10 <dons> yeah, we want math.
04:47:14 <quicksilver> and we might want to show program fragments
04:47:19 <quicksilver> not that I can read them
04:47:24 <quicksilver> I don't have a UTF-8 clean toolchain :(
04:47:39 <dons> do the #math guys do anything special?
04:47:44 <notadev> foldr (>>=) . map blah . [0..n]
04:47:52 <wolverian> that is cute
04:48:11 <wolverian> except for the bold at the end.. why are the numbers bold?
04:48:11 * vincenz votes for full latex capabilities
04:48:20 <Philippa> dons: I don't know, but I doubt it. UTF-8 flies straight through the IRC protocol
04:48:32 <notadev> er cos dons' example had the list emphasized, wolverian
04:48:49 <wolverian> the n doesn't look emphasized to me on don's line
04:48:54 <notadev> yeah TeX ftw
04:49:04 <notadev> wolverian: picky, picky ;)
04:49:28 <notadev> heh sorry, i was just doing it quickly, i mean
04:49:57 <dons> f x 05| y 05<- x 05= x 10`k` y
04:50:23 <dons> so how many people *can't* see the colours?
04:50:30 <dons> is it scrambling lots of people's terminals?
04:50:38 <notadev> i can see em but they don't look too good
04:51:09 <dons> yeah, it would rely on reasonable xterm colours
04:51:12 <vincenz> yeah, I see them they're fugly
04:51:15 <notadev> f x | y <- x = x `k` y
04:51:43 <wli> Basically I have a recurrence where I have an upper index and a sequence of lower indices, and moving one up on the upper index is the sum of moves down on each possible lower index.
04:51:51 * pjd sees the pretty colors
04:51:53 <pjd> neat!
04:51:55 <Philippa> dons: it's generally a bad idea to assume you've thought of all reasonable possibilities, too :-)
04:52:03 <oerjan> i _think_ someone means foldl (>>=) . map blah [0 .. n]
04:52:04 <pjd> how does it work?
04:52:26 <dons> foldl 10(10>>=10) 10. map blah 05[060 05.. n05]
04:52:37 <dons> oh, its HsColour -tty | ansi2irc 
04:52:39 <notadev> reasonable? how dare anyone tell me what colours i should have on my display? /me huffs off ;P
04:52:46 <quicksilver> actually the second . should be a $
04:52:56 <pjd> dons: so you do it locally?
04:53:10 <dons> yeah
04:53:22 <dons> i 10(can10) colour my code from 061 to 063
04:53:28 <oerjan> quicksilver: and foldr should be foldl
04:53:44 <notadev> what about red-green colour blindness tho, dons?
04:53:48 <oerjan> er...
04:53:53 <oerjan> yes
04:54:13 <dons> notadev: i guess it depends on what colours you've set for color1..7 in your terminal
04:54:21 <notadev> hmm
04:54:22 <Philippa> notadev: it's only a really big problem if foreground and background are indistinguishable
04:54:45 <notadev> i was just trying to hint at the work that's already been done in HCI wrt colours
04:54:52 <Philippa> dons: not everyone's running in a terminal either. I don't think I can change mIRC's palette and it's the best-known windows-based client
04:55:54 <quicksilver> Philippa: http://leonardo.spidernet.net/Copernicus/831/mirc/tips5/color.html#config
04:55:57 <lambdabot> Title: Color Tips, http://tinyurl.com/3tw3u
04:56:11 <notadev> dons: in my case i'm not in a terminal tho; your colour codes are the same as you set, but my background could be anything. there's no way of knowing. and changing the bg colour as well, is simply ignored by my client.
04:56:39 <dons> yes, our standards suck
04:57:08 <notadev> so i have no prob with you using colours as an individual. i'd object if they were in lambdabot however
04:57:40 <dons> yep.
04:59:11 <notadev> hmm a semi-`colour' mode in freenode would be nice, just allowing bold and u/l
04:59:28 <Philippa> quicksilver: you've answered the wrong question. That lets me change my own background and foreground, sure
04:59:44 <Philippa> funnily enough I've already done that
04:59:58 <quicksilver> Philippa: yes, I was sort of agreeing with you
05:00:08 <quicksilver> Philippa: saying 'I think this is all the freedom it gives you'
05:00:47 <Philippa> leaving me to read the page myself to work that out is a bad idea, comment next time?
05:00:55 <notadev> hehe
05:01:00 * notadev hides again
05:14:07 <wli> ugh, how do I get lhs2TeX to treat ^ like exponentiation instead of it doing weird up arrows?
05:15:42 <quicksilver> andrew coppin sure has the knack for starting successful threads
05:16:18 <vincenz> wli: a hunch: tried \^ ?
05:16:30 <wli> vincenz: Looks like %format ^ = "^"
05:17:03 <dons> quicksilver: yeah, its a true talent
05:17:29 <vincenz> quicksilver: ?
05:17:33 <dons> "types systems! crazy LOL!? haskell can't do that?!!"
05:17:50 <kosmikus> wli: that's dangerous
05:18:08 * vincenz thinks comment moderation on blog = lame
05:18:18 * vincenz responded to the guy balking against type inference
05:18:24 <vincenz> pointing out you can use "undefined"
05:19:16 <wli> kosmikus: It did not have the intended effect.
05:19:27 <wli> kosmikus: Any tips on getting ^ to behave like ^ ?
05:19:36 <vincenz> wli: \6
05:19:38 <vincenz> \^
05:19:41 <earthy> quicksilver: yeah... a bit too good a knack
05:19:43 <kosmikus> wli: I don't think it's possible
05:19:49 * earthy is 420 postings behind already again
05:19:56 <oerjan> wli: behave as which ^? the haskell one or the TeX one?
05:20:04 <wli> vincenz: You must be on about something unrelated.
05:20:09 <wli> oerjan: The TeX one.
05:20:20 <kosmikus> wli: you can define a prefix operator
05:20:30 <oerjan> wli: in the Haskell part of the file?
05:20:43 <kosmikus> wli: %format power a (b) = a "^{" b "}"
05:20:44 <vincenz> wli: latex, right?
05:21:02 <kosmikus> wli: but I don't see how you could get the infix operator to behave right
05:21:32 <oerjan> yeah, how would it know where its second argument ends?
05:21:53 <wli> oerjan: Parentheses, tokens, etc.
05:22:18 <hpaste>  matt__r pasted "haddock troubles" at http://hpaste.org/1614
05:22:34 <oerjan> wli: it would require parsing Haskell.  does lhs2tex really do that?
05:22:46 * MyCatSchemes reccommends that matt__r might wish to try plaice, cod, or perhaps grouper.
05:23:07 <wolverian> I wish they released aldor already. it's dying in obscurity :/
05:23:36 <matt__r> or barra :)
05:23:49 <wli> oerjan: There is tokenization.
05:23:54 <wli> oerjan: Not full parsing.
05:24:02 <wli> oerjan: Parentheses are easy to match.
05:24:29 <oerjan> wli: it would have to do a half-assed job
05:25:10 <kosmikus> oerjan, wli: yes, that's exactly why I don't see how it'd work
05:25:34 <wli> Could I get it to act on (^) instead or does it insist on some sort of ordinary name?
05:26:05 <wli> I don't want to pollute it with something like where power = (^)
05:26:28 <vincenz> Which version of ghc is the earliest that supports bang patterns?  6.6, 6.6.1 or 6.7?
05:26:56 <mauke> not 6.7
05:28:53 <scook0> 6.6 has them
05:29:14 <vincenz> scook0: thanks
05:29:39 <wli> kosmikus: inline TeX makes it work
05:29:46 <matt__r> what is a bang pattern?
05:29:52 <oerjan> vincenz: http://www.haskell.org/ghc/docs/6.6/html/users_guide/release-6-6.html
05:29:54 <lambdabot> Title: 1.4. Release notes for version 6.6, http://tinyurl.com/jz9hw
05:29:55 <vincenz> foo !x = x
05:30:00 <wli> Problem solved.
05:30:15 <scook0> matt__r: forces the matching of a variable to be strict
05:30:26 <matt__r> ah - of course
05:31:14 <kosmikus> wli: is that better than the prefix solution?
05:31:58 <wli> kosmikus: Yes. No extraneous code appears.
05:32:11 <kosmikus> hmm. your call, of course.
05:32:13 <wli> kosmikus: BTW is there a way to say that you don't want a code block to show up?
05:32:22 <kosmikus> I've already answered that.
05:32:32 <wli> sorry
05:32:43 <kosmikus> 12:28 < kosmikus> wli: sure, %if False, %endif or %if style == newcode, %endif
05:32:56 <kosmikus> 12:29 < kosmikus> wli: see Guide2.pdf, Sec. 10
05:33:09 <matt__r> problem solved
05:33:33 <quicksilver> @localtime kosmikus 
05:33:34 <lambdabot> Local time for kosmikus is Wed Jul 11 14:36:52 2007
05:33:37 <matt__r> haddock is not very forgiving of normally-escaped characters in your comments
05:33:46 <wli> kosmikus: Wonderful, thanks.
05:34:12 <matt__r> I had to remove "
05:34:35 <quicksilver> kosmikus: your clock is a few minutes off :P
05:36:24 <dons> mm, idiom brackets.
05:37:25 <kosmikus> quicksilver: yes
05:40:39 <kosmikus> @localtime kosmikus
05:40:42 <kosmikus> hmm
05:40:59 <lambdabot> Local time for kosmikus is Wed Jul 11 14:40:05 2007
05:41:32 <kosmikus> yes, better :)
05:42:14 <Nucleo> @pl (\a b c d -> a+b+c+d)
05:42:15 <lambdabot> ((((+) .) . (+)) .) . (+)
05:42:36 <malcolmw> dons, mauke: patch pushed to hscolour, adding a new -mirc command-line option :-)
05:43:12 <quicksilver> Nucleo: I wouldn't necessarily recommend that, though :)
05:44:02 <Nucleo> quicksilver: haha :)
05:45:59 <dons> malcolmw: cool! :)
05:47:34 <ndm> dons: can you and the shootout authors write up "we stopped contributing to the shootout because..."
05:48:09 <opqdonut> @pl \a b -> a + b
05:48:09 <lambdabot> (+)
05:48:14 <opqdonut> @pl \a b c -> a + b + c
05:48:14 <ndm> the thread on reddit has the write title, but entirely the wrong content
05:48:14 <lambdabot> ((+) .) . (+)
05:48:24 <dons> oh, no. i don't like to pick on them -- they try hard, but its just a losing battle.
05:48:56 <dons> ndm, see the thread on the shootout itself, and igouy's comments
05:48:57 <ndm> it doesn't have to be harsh and critical, just overall defining why benchmarks between different languages are hard
05:49:10 <oerjan> @pl \a b c d e f g -> a+b+c+d+e+f+g
05:49:10 <lambdabot> ((((((((((+) .) . (+)) .) . (+)) .) . (+)) .) . (+)) .) . (+)
05:49:19 <wolverian> http://dresdencodak.com/cartoons/dc_031.htm I want to play an rpg like this
05:49:20 <lambdabot> Title: Dresden Codak casts Magic Missile
05:49:25 <dons> there's some good stuff here, http://programming.reddit.com/info/25aej/comments
05:49:27 <lambdabot> Title: Why the Great Language Shootout changed because Haskell was too fast (reddit.com ...
05:53:11 <quicksilver> dons: I like the python factorial code which unlinks /usr/bin/perl so it knows it will win
05:53:15 <quicksilver> dons: that's stylish :)
05:53:30 <opqdonut> link?
05:53:46 <quicksilver> opqdonut: pasted by don in the line before my comment :P
05:54:06 <opqdonut> oh in the reddit article?
05:54:25 <opqdonut> ah, there :)
05:57:38 <ClaudiusMaximus> i think i need a monad;  i have "foldr (>>=) (return (x::a)) (foos::[a -> IO a])", each foo is "\y -> foo1 y >>= (foo2 :: a -> IO b) >> return y", but i also want to collect all the b's in a list...
05:58:04 <wilx|wrk> @unpl ((((((((((+) .) . (+)) .) . (+)) .) . (+)) .) . (+)) .) . (+)
05:58:04 <lambdabot> (\ h w z ac af ai -> (+) (((((h + w) + z) + ac) + af) + ai))
05:58:53 <quicksilver> ClaudiusMaximus: well the foos are no good, then
05:59:05 <quicksilver> ClaudiusMaximus: because the foos are throwing away the bs, right?
05:59:22 <quicksilver> ClaudiusMaximus: the type you really want is a -> IO (a,b)
05:59:28 <quicksilver> ClaudiusMaximus: and collect the bs and throw the as?
05:59:31 <quicksilver> ClaudiusMaximus: am I correct?
06:00:02 <wli> dons: I still think statistical methods should be used to try to smoke out pretty much anything possible about all this.
06:01:35 <ClaudiusMaximus> quicksilver: mm, not sure, i need the final a, and a list of b's
06:02:14 <oerjan> ClaudiusMaximus: a StateT monad might be good then
06:02:16 <ClaudiusMaximus> quicksilver: just wondering if there was some monad out there that would do exactly what i wanted
06:02:28 <LeCamarade> @where happs
06:02:28 <lambdabot> http://happs.org
06:02:30 <quicksilver> ClaudiusMaximus: there is
06:02:34 <quicksilver> ClaudiusMaximus: I was just talking you through it
06:02:42 <LeCamarade> lambdabot: Thanks
06:02:43 <ClaudiusMaximus> quicksilver: ah ok :)
06:02:43 <quicksilver> ClaudiusMaximus: I'm saying, your current type of 'foos' is no good
06:02:48 <quicksilver> ClaudiusMaximus: it's throwing away the bs
06:02:57 <quicksilver> so really you want foos::[a -> IO (a,b)]
06:03:05 <quicksilver> and a -> IO (a,b) has a name!
06:03:07 <ClaudiusMaximus> yes, but if do that i can't fold with >>=, right?
06:03:16 <vincenz> quicksilver: StateT IO
06:03:16 <quicksilver> it's called StateT b IO a
06:03:25 <oerjan> WriterT might be an alternative
06:03:28 <quicksilver> and then your 'fold' becomes mapM
06:03:45 <quicksilver> erm
06:03:48 <oerjan> or perhaps even WriterT State
06:03:49 <quicksilver> or sequence, possibly
06:03:53 <vincenz> @unpl (.) . (.) . (.)
06:03:53 <lambdabot> (\ l b c f i -> l (b c f i))
06:04:48 <opqdonut> @unpl (.) . (.)
06:04:48 <lambdabot> (\ i b c f -> i (b c f))
06:04:49 <ClaudiusMaximus> mm, i've only used the List and IO monads so far, i guess i better start reading some more
06:04:52 <ddarius> @unpl (.) . (.) . (.) . (.) . (.)
06:04:52 <lambdabot> (\ r b c f i l o -> r (b c f i l o))
06:04:55 <opqdonut> @unpl (.) .
06:04:55 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}: Parse error
06:05:00 <oerjan> ClaudiusMaximus: i think the list collection of b's corresponds to a Writer monad while the a's fit a State.
06:05:08 <opqdonut> @unpl ((.) .)
06:05:09 <lambdabot> (\ d g b c -> d g (b c))
06:05:17 <quicksilver> oerjan: yes, but just state would be simpler
06:05:21 <ClaudiusMaximus> oerjan: that makes conceptual sense
06:05:35 <quicksilver> another way of looking at it is just to say the bs are the return values
06:05:44 <quicksilver> and the a is definitely the state
06:06:03 <quicksilver> so you write foos :: [StateT a IO b]
06:06:04 <ClaudiusMaximus> yes.
06:06:25 <quicksilver> then sequence foos :: StateT a IO [b]
06:06:28 <quicksilver> which is your list of bs
06:06:46 <quicksilver> (with the final state buried in there if you care about it)
06:07:46 <ClaudiusMaximus> sure.  i guess there is some runState to give me stuff :: a -> IO (a,[b]) ?
06:08:38 <oerjan> :t runState
06:08:40 <lambdabot> forall s a. State s a -> s -> (a, s)
06:08:54 <oerjan> :t runStateT
06:08:56 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
06:09:06 <quicksilver> ClaudiusMaximus: yes, you 'run' it with the initial state
06:09:15 <quicksilver> ClaudiusMaximus: and it chunters along and gives you the result, and the final state
06:09:41 <ClaudiusMaximus> perfect, thanks
06:11:00 <Saizan> foldr (\f m -> m >>= \(a,bs) -> f a >>= \(a',b) -> return (a',b:bs)) (return ((x::a),[])) (foos::[a -> IO (a,b)]) <-- or just inline/fuse StateT sequence :)
06:12:40 <ddarius> @pl \f m -> m >>= \(a,bs) -> f a >>= \(a',b) -> return (a',b:bs))
06:12:40 <lambdabot> (line 1, column 61):
06:12:40 <lambdabot> unexpected ")"
06:12:40 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<" or end of input
06:12:44 <ddarius> @pl \f m -> m >>= \(a,bs) -> f a >>= \(a',b) -> return (a',b:bs)
06:12:45 <lambdabot> (=<<) . (`ap` snd) . (. fst) . flip flip ((`ap` snd) . (. fst) . ((return .) .) . flip ((.) . (,)) . flip (:)) . (((.) . (>>=)) .)
06:13:17 <profmakx> sorry for the join spam today :/ my v6 provider has a few ddos-problems
06:14:41 <Syzygy-> Sorting in linear time with many-worlds quantum physics. Step 1: permute your array using quantum randomness. Step 2: Unless array sorted, destroy the universe.
06:15:40 <mauke> I see you're using quantum bogosort
06:16:33 <oerjan> Syzygy-: Step 3. Watch in surprise as a meteor destroys your universe-destroying apparatus once you try this with a large enough array.
06:17:03 <Syzygy-> oerjan: Hahahahaha!
06:17:13 <Syzygy-> mauke: Yeah?
06:17:27 <ClaudiusMaximus> @docs Control.Monad.State
06:17:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
06:17:40 <ddarius> @oldwiki MonadState
06:17:40 <lambdabot> http://www.haskell.org/hawiki/MonadState
06:21:19 <vincenz> oerjan: the problem is that you don't know when it's done... so if you observer too early you flatten the parallel space to the one you're looking at, which could not be sorted :D
06:21:30 <vincenz> erm
06:21:33 <vincenz> which could be not-sorted
06:23:49 <oerjan> vincenz: i think step 2 is intended to also remove those universes where you check too early.
06:24:50 <vincenz> oerjan: so basically... we kill ourself
06:25:04 <vincenz> we flatten prior to explosion to the wrong universe, check finishes...BOOM
06:25:14 <oerjan> vincenz: no, that's the point of my step 3.
06:26:16 <oerjan> if your chances of success are too small, the universes where _something_ prevents your explosion device from working become most probable.
06:26:43 <vincenz> oerjan: my point is that observing flattens, and if you flatten before the "is-ordered-check" finishes...
06:27:55 <oerjan> vincenz: this algorithm is based on the many-worlds interpretation. (not necessarily a realistic version of it though.)  observation does not flatten anything.
06:29:12 <vincenz> oerjan: Hmm, then it's a different one than I read about... where we have many worlds, but that moving through it flattens it, just like a wave is flattened when observed
06:32:01 <oerjan> vincenz: whatever.  i expect the _real_ universe doesn't work by either of those two methods. :)
06:32:27 <vincenz> oerjan: I don't know
06:32:34 <oerjan> vincenz: no one does.
06:32:41 <vincenz> as in
06:32:51 <vincenz> I don't know "whether it doesn't"
06:32:58 <vincenz> not "I don't know whether it does"
06:33:19 <vincenz> basically implying I foound your point a tad too strongly stated :)
06:44:26 <Nucleo> @pl (\x -> drop 2 $ show x)
06:44:26 <lambdabot> drop 2 . show
06:45:27 <opqdonut> :t ((id.).)
06:45:30 <lambdabot> forall b a a1. (a1 -> a -> b) -> a1 -> a -> b
06:45:58 <opqdonut> :t (((+).).)
06:46:00 <lambdabot> forall b a a1. (Num b) => (a1 -> a -> b) -> a1 -> a -> b -> b
06:46:32 <xpika> how do i get the date out of getCurrentTime
06:46:43 <Japsu> @index getCurrentTime
06:46:43 <lambdabot> bzzt
06:46:46 <Japsu> right.
06:47:25 <xpika> getCurrentTime :: IO UTCTime
06:47:35 <xpika> Data.Time.Clock
06:48:26 <xpika> docs show there is an instance of show for UTCTime
06:48:32 <opqdonut> :t toCalendarTime
06:48:34 <lambdabot> Not in scope: `toCalendarTime'
06:48:52 <xpika> @hoogle getCurrentTime
06:48:53 <lambdabot> No matches found
06:49:02 <Nucleo> @pl (\x -> (take 2 $ show x)==a)
06:49:02 <lambdabot> (a ==) . take 2 . show
06:50:03 <opqdonut> xpika: use utctDay to get the number of the day
06:50:15 <EvilTerran> xpika, what about System.Time.getClockTime instead?
06:50:41 <opqdonut> and then toGregorian
06:50:43 <Japsu> yeah, hoogle finds me System.Time but I see no record of Data.Time.Clock
06:50:52 <oerjan> xpika: i distinctly recall this being discussed yesterday.
06:50:56 <EvilTerran> > liftM (ctMonth . toCalendarTime) getClockTime
06:50:57 <lambdabot>   Not in scope: `getClockTime'
06:51:08 <EvilTerran> bah
06:51:12 <oerjan> and that the answer was that the Show instance is in a different module.
06:51:53 <oerjan> something with Format.
06:52:22 <xpika> getCurrentTime >>= return . toGregorian . utctDay
06:52:28 <quicksilver> xpika: http://haskell.org/ghc/docs/latest/html/libraries/time/Data-Time-Calendar-MonthDay.html
06:52:30 <lambdabot> http://tinyurl.com/2o62bd
06:52:33 <xpika> that works
06:52:39 <EvilTerran> redardless, mine should've been "liftM ctMonth (toCalendarTime =<< getClockTime)"
06:53:01 <EvilTerran> toCalendarTime is an action, not a function, for some reason.
06:54:52 <quicksilver> hmm for some reason I think System.Time was deprecated?
06:54:59 <quicksilver> and Data.Time was the new one?
06:55:02 <quicksilver> or did I get that backwards/
06:55:15 <SamB> @seen sorear
06:55:16 <lambdabot> I saw sorear leaving #happs, #ghc, #xmonad, #haskell-overflow, #haskell-blah and #haskell 19h 47m 48s ago, and .
06:55:25 <oerjan> EvilTerran: it uses local timezone
06:55:36 <EvilTerran> ahh. i see.
06:55:37 <quicksilver> EvilTerran: toCalendarTime is an action because it depends on the current local notion of 'local time'
06:56:02 <EvilTerran> i was thinking that getClockTime would deal with that.
06:56:14 <quicksilver> getClockTime returns a non-time-zone-polluted version
06:56:18 <quicksilver> i.e. UTC
06:56:19 <quicksilver> I think
06:56:43 <SamB> quicksilver: perhaps not on Windows ;-)
06:57:07 <quicksilver> SamB: maybe that's one reason why Data.Time is better?
06:57:10 * quicksilver can't remember
06:57:30 <quicksilver> nah, ClockTime must be UTC
06:57:42 <quicksilver> or, at worst "UTC + known offset"
06:57:49 <quicksilver> because toUTCTime doesn't have IO
06:59:29 <Nucleo> @pl (\x -> (take 2 $ show x, drop 2 $ show x) )
06:59:29 <lambdabot> ap ((,) . take 2 . show) (drop 2 . show)
06:59:54 <quicksilver> that's odd
06:59:57 <xpika> http://haskell.org/haskellwiki/Date
06:59:58 <lambdabot> Title: Date - HaskellWiki
07:00:01 <quicksilver> it didn't factor the 'show'
07:00:12 <Nucleo> yeah
07:00:25 <mauke> @pl (\x show -> (take 2 $ show x, drop 2 $ show x) )
07:00:25 <lambdabot> ap (ap . (((,) . take 2) .) . flip id) ((drop 2 .) . flip id)
07:00:38 <mauke> @pl (\show x -> (take 2 $ show x, drop 2 $ show x) )
07:00:38 <lambdabot> liftM2 ap (((,) . take 2) .) (drop 2 .)
07:00:39 <Nucleo> mauke: oh god!
07:00:58 * SamB can't spot where the difference between Î»2 (Church) and Î»2 (Curry) is given in Pure Type Systems for Functional Programming
07:00:59 <quicksilver> mauke: interesting trick
07:01:18 <mauke> @type liftM2 (,) (take 2) (drop 2) . show
07:01:20 <lambdabot> forall a. (Show a) => a -> ([Char], [Char])
07:01:39 <quicksilver> :t break
07:01:41 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
07:01:45 <quicksilver> :t breakAt
07:01:47 <lambdabot> Not in scope: `breakAt'
07:01:50 <quicksilver> hmph
07:01:55 <Saizan> splitAt
07:02:08 <quicksilver> :t splitAt
07:02:10 <lambdabot> forall a. Int -> [a] -> ([a], [a])
07:02:11 <mauke> @src splitAt
07:02:11 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
07:02:13 <quicksilver> ah, thanks :)\
07:02:35 <quicksilver> Nucleo: splitAt 2 . show
07:02:37 <quicksilver> Nucleo: then :)
07:02:44 <Nucleo> excellent. Thanks!
07:03:17 <Saizan> @quote haskell.form
07:03:17 <lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
07:03:22 <EvilTerran> ah, so it is. i misread the original, and was thinking "join (&&&) show . splitAt 2"...
07:03:45 <Nucleo> @type splitAt 2 . show
07:03:47 <lambdabot> forall a. (Show a) => a -> ([Char], [Char])
07:04:15 <EvilTerran> (***), rather
07:04:17 <quicksilver> > splitAt 2 . show $ "13.14"
07:04:18 <lambdabot>  ("\"1","3.14\"")
07:04:25 <quicksilver> > splitAt 2 . show $ 13.14
07:04:27 <lambdabot>  ("13",".14")
07:04:45 <Nucleo> >splitAt 2 . show $ 1314
07:04:56 <Nucleo> > splitAt 2 . show $ 1314
07:04:57 <lambdabot>  ("13","14")
07:05:09 <Nucleo> cool. Exactly what I wanted. :)
07:06:15 <bringert> shapr: I've switched to http://resources.neolao.com/flash/components/player_flv now
07:06:20 <shapr> cool
07:06:32 <SamB> oh, the Church/Curry difference is given earlier on, in the part about Î»â†’...
07:07:08 <SamB> now why is xdvi drawing a red border around the page :-(
07:07:31 <mauke> @type (&&&)
07:07:32 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
07:09:49 <EvilTerran> > ((++"foo") &&& ("bar"++)) "baz"
07:09:50 <lambdabot>  ("bazfoo","barbaz")
07:09:57 <SamB> oh, huh, tetex is no longer maintained...
07:10:09 <EvilTerran> > ((++"foo") *** ("bar"++)) ("baz","eek")
07:10:10 <lambdabot>  ("bazfoo","bareek")
07:11:28 <xpika> how do i convert an Int to an Integer
07:11:58 <scook0> :t fromIntegral
07:12:00 <lambdabot> forall a b. (Num b, Integral a) => a -> b
07:12:12 <scook0> xpika: ^^^
07:14:05 <xpika> formatDate (y,m,d) = concat . intersperse "." . map (show . fromIntegral) $ [d,m,y]
07:14:37 <xpika> @Let fD (y,m,d) = concat . intersperse "." . map (show . fromIntegral) $ [d,m,y]
07:14:40 <lambdabot> Defined.
07:14:51 <xpika> > L.fD (1,2,3)
07:14:52 <lambdabot>  "3.2.1"
07:15:05 <xpika> > L.fD (1::Int,2::Int,3::Int)
07:15:06 <lambdabot>  "3.2.1"
07:15:07 <xpika> > L.fD (1::Int,2::Int,3::Integer)
07:15:08 <lambdabot>  Couldn't match expected type `Int' against inferred type `Integer'
07:15:11 <xpika> :(
07:15:30 <pejo> SamB, tetex is no longer maintained?
07:16:16 <EvilTerran> ?type L.fD
07:16:18 <lambdabot> Couldn't find qualified module.
07:16:19 <SamB> pejo: that's what the tetex-bin package says -- it's now a transitional package
07:17:08 <oerjan> xpika: have you looked at Data.Time.Format?
07:17:18 <xpika> oerjan: i fixed it
07:17:26 <xpika> i forgot about haskell type classes
07:17:41 <pejo> SamB, oh, in a particular distribution?
07:18:00 <xpika> list :: [a]
07:18:06 <scook0> pejo: no, pretty sure the upstream maintainer has stopped
07:18:21 <oerjan> xpika: i mean the formatTime function there
07:18:29 <xpika> @Let fD (y,m,d) = concat . intersperse "." . map show $ [fromIntegral d,m,y]
07:18:31 <lambdabot> <local>:6:0:     Warning: Pattern match(es) are overlapped              In th...
07:18:31 <scook0> "I (Thomas Esser) have decided not to make new releases of teTeX any more (May 2006)."
07:18:42 <xpika> > L.fD (1::Int,2::Int,3::Integer)
07:18:43 <lambdabot>  Couldn't match expected type `Int' against inferred type `Integer'
07:18:49 <scook0> (from the teTeX site)
07:18:51 <xpika> @unlet
07:18:52 <lambdabot> Defined.
07:18:59 <xpika> @unlet fD
07:18:59 <lambdabot>  Parse error
07:20:13 <oerjan> @undefine
07:20:14 <lambdabot> Undefined.
07:23:55 <SamB> pejo: yes, it did say that it was no longer maintained upstream
07:25:21 <Rebooted> does anyone know anywhere where you can get Haskell hosting
07:25:32 <Rebooted> for WASH-based projects
07:26:34 <earthy> http://example.nfshost.com/versions.php
07:26:40 <lambdabot> Title: Versions of CGI Languages
07:27:02 <Cale> I'm fairly sure that any server that will let you run CGI programs would work.
07:27:04 <earthy> not expensive either
07:27:19 <Rebooted> earth: thanks
07:27:26 <earthy> cale: nearlyfreespeech.net is quite nice in that it already has a haskell environment installed ;)
07:27:26 <Rebooted> earthy: thanks*
07:27:38 <quicksilver> Cale: only if you have access to a compiler environment which matches their exact library versions
07:27:53 <quicksilver> Cale: or have the necessary fu to compile completely statically linked stuff and upload it
07:28:12 <quicksilver> (or they give you a compiler env and allow you to install haskell, but that's rather unusual)
07:33:02 <hpaste>  setuid_w00t pasted "Why is this algorithm to find primes so slow?" at http://hpaste.org/1615
07:33:05 <setuid_w00t> I'm working through the project euler problems using Haskell.  Currently, I am working on problem 10 which is "find the sum of all the primes under 1000000".
07:37:42 <ssfak> hi
07:38:29 <EvilTerran> iirc, the fastest algo for finding all primes <n should be n^(3/2)...
07:38:35 <EvilTerran> O(n^(3/2)), rather
07:39:07 <LeCamarade> Hails - A Haskell Web Framework for Web 2.0!
07:39:15 <LeCamarade> Kidding, kidding.
07:39:20 <LeCamarade> Just wanted to get kickbanned. :o)
07:40:13 <cjeris> LeCamarade: now with extra Praetorian guards?
07:41:58 <LeCamarade> cjeris: With hake(1)! Or heck(1). Definitely not rake.
07:43:55 <kmb> I'm trying to compile arrows-0.2, but I'm getting some errors from Automation.hs, e.g., "Illegal instance declaration for ArrowAddState r..."
07:44:41 <shapr> LeCamarade: What about maak?
07:45:54 <shapr> kmb: Maybe it needs -fglasgow-exts or something?
07:46:02 <EvilTerran> setuid_w00t, if a number divides by something > its sqrt, it will have to divide by something < its sqrt as well. should speed things up a bit if you take that into account.
07:46:18 <ssfak> @help
07:46:18 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:46:36 <shapr> @help PANIC!
07:46:36 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:46:37 <ssfak> @list
07:46:37 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
07:47:12 <EvilTerran> setuid_w00t, alternatively, instead of checking for divisibility by all (oddsFrom 3), could you check for divisibility by (prlt n)?
07:47:29 <ssfak> @pl map
07:47:30 <lambdabot> map
07:47:46 <ssfak> @pl foldr . sume
07:47:46 <lambdabot> foldr . sume
07:47:49 <ssfak> @pl foldr . sum
07:47:50 <lambdabot> foldr . sum
07:47:53 <setuid_w00t> EvilTerran: thanks for the ideas
07:47:54 <EvilTerran> (i may be misunderstanding your code; bear that in mind)
07:47:58 <shapr> ssfak: You can also do that in private messages.
07:48:26 <EvilTerran> setuid_w00t, actually, i think i have got a bit confused. but there's some ideas, anyway.
07:48:34 <shapr> ssfak: Are you working together with vincenz?
07:52:48 <desegnis> hi, I'm new to Haskell and have found out that I can use -v0 to make ghci less verbose. is there a way to specify -v0 in .ghci? (it's a static option, as it seems)
07:53:05 <shapr> What about :set -v0 
07:53:10 <kmb> shapr: using -fglasgow-exts doesn't help, same errors
07:53:28 <jethr0> @shapr
07:53:28 * lambdabot smacks  about with a large trout
07:53:30 <desegnis> shapr, that does not have any effect
07:53:34 <jethr0> ouch
07:53:44 <shapr> jethr0: I'm dangerous!
07:53:50 <jethr0> so i see
07:54:24 <desegnis> shapr, I suppose because it's static
07:54:29 <jethr0> wasn't that command supposed to get you into the channel right away instead of putting HER into a fish-beating frenzy?
07:54:30 <shapr> kmb: Are you using arrows-0.2 from Hackage with ghc 6.6.1?
07:54:41 <quicksilver> @get-shapr
07:54:41 <lambdabot> shapr!!
07:54:46 <shapr> quicksilver: You screamt?
07:54:48 <quicksilver> could be the one you're thinking of
07:54:59 <shapr> Ah, just a demonstration scream.
07:55:00 <quicksilver> no, just abusing you for jethr0's amusement
07:55:05 <vincenz> dons: ping
07:55:20 <shapr> desegnis: I thought every command line arg would work in ~/.ghci, I'm surprised that one doesn't.
07:55:22 <quicksilver> sjanssen: afternoon
07:55:31 <jethr0> ahh, wrong shapr-command then ^_^
07:55:33 <sjanssen> quicksilver: morning
07:55:37 <quicksilver> sjanssen: I got an embedding for ErrorT too, I thought that was quite cute
07:55:49 <quicksilver> sjanssen: it mediates with dynamic exceptions
07:56:09 <quicksilver> sjanssen: so your ErrorT code can throw errorT errors and get them to abort the IO code they're called by :)
07:56:16 <kmb> shapr: I'm using ghc 6.6, and arrows-0.2 I downloaded from http://www.haskell.org/arrows/download.html
07:56:17 <lambdabot> Title: Arrows: downloads
07:56:26 <desegnis> shapr, well, I'll use a shell alias then
07:56:38 <desegnis> saves even more typing :)
07:56:39 <shapr> desegnis: Yeah, my thoughts as well.
07:57:11 <vincenz> anyone ever install a lambdabot?
07:57:16 <vincenz> I keep getting errors on most plugins
07:58:05 <LeCamarade> @where mod_haskell
07:58:05 <lambdabot> I know nothing about mod_haskell.
07:58:09 <sjanssen> vincenz: compilation errors?
07:58:25 <shapr> kmb: If you're using cabal-install, you could do "cabal-install install arrows" that's how I got arrows-0.2 most recently. If you'd rather skip cabal-install, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/arrows-0.2 might be easier to deal with.
07:58:27 <lambdabot> http://tinyurl.com/2z6ftm
07:58:36 <vincenz> sjanssen: no, runtime errosr
07:58:49 <vincenz> sjanssen: basically I get erros in the console when in irc I do something like "> 1"
07:59:01 <LeCamarade> @where+ mod_haskell http://losser.st-lab.cs.uu.nl/mod_haskell/
07:59:01 <lambdabot> Done.
07:59:12 <LeCamarade> @where modhaskell
07:59:13 <lambdabot> I know nothing about modhaskell.
07:59:26 <sjanssen> vincenz: that doesn't work out of the box, you have to set up hs-plugins and runplugs
07:59:32 <LeCamarade> Hmm. No Levenshtein distance correction with @where?
07:59:33 <shapr> kmb: If you plan on installing a bunch of Haskell libraries that already show up in http://hackage.haskell.org/packages/archive/pkg-list.html then cabal-install is probably worth the effort.
07:59:35 <Lemmih> LeCamarade: That mod_haskell is horribly out dated.
07:59:51 <vincenz> sjanssen: that's in the repository... and runplugs is installed
07:59:59 <vincenz> sjanssen: apparently when I run in the console, I get an error about ShowQ.hs
08:01:18 <shapr> Sounds like a Template Haskell problem.
08:01:38 <vincenz> showQ.hs is in the lambdabot darcs repo
08:01:53 <shapr> I'm just guessing that because of the popularity of Q in TH.
08:02:28 <SamB> shapr: it's apparantly related to quickcheck
08:03:02 <SamB> I do see:
08:03:04 <SamB> -- import Language.Haskell.TH
08:03:05 <SamB> though
08:03:20 <vincenz> my guess
08:03:24 <vincenz> it's not installing everything properly
08:03:36 <SamB> ... "installing"?
08:03:38 <SamB> what is this?
08:04:42 <shapr> SamB: Copying files into the right place and stuff like that ;-)
08:04:55 <SamB> shapr: why would you want to copy them?
08:05:28 <LeCamarade> Lemmih: Yes, but ... it's there. :o)
08:05:31 <LeCamarade> @where hsp
08:05:32 <lambdabot> http://www.cs.chalmers.se/~d00nibro/hsp
08:05:44 <LeCamarade> :o)
08:05:49 <shapr> SamB: No idea, I assume there's some good reason.
08:06:45 <SamB> vincenz: last I knew, you just ran lambdabot in place.
08:07:06 <Lemmih> LeCamarade: http://darcs.haskell.org/~lemmih/modhaskell/ is newer.
08:07:06 <vincenz> SamB: hence why as last thing, the build script calls "copy" (or install)?
08:07:08 <lambdabot> Title: Index of /~lemmih/modhaskell
08:07:35 <Lemmih> LeCamarade: However, none of the modhaskells should be used.
08:07:48 <SamB> vincenz: I believe that copies it to a more convenient location in the source tree
08:08:18 <vincenz> right
08:08:26 <vincenz> and instead, I said --prefix=/home/oasis/usr
08:08:37 <SamB> that would be your mistake ;-P
08:08:47 <vincenz> SamB: you're very helpful
08:08:52 <vincenz> eval module failed in contextual handler: IRCRaised Data.ByteString.last: empty ByteString
08:08:52 <SamB> sorry
08:08:57 <vincenz> this is the message I get
08:09:06 <SamB> ... okay ...
08:09:07 <nowhere_man> I've got a question about interface documentation: is it possible to annotate the type of a function with argument names?
08:09:31 <nowhere_man> without names, it's a bit harder to clearly describe arguments
08:09:32 <SamB> vincenz: time to break out +RTS -xc ?
08:09:33 <shapr> nowhere_man: With Haddock?
08:10:03 <kmb> shapr: thanks, the hackage version is ever so slightly different, thus it works.
08:10:12 <LeCamarade> Lemmih: Should not be used? Um ... why?
08:10:13 <nowhere_man> shapr: for example
08:10:35 <shapr> kmb: Any other questions?
08:11:10 <vincenz> SamB: same issue with std install
08:11:11 <shapr> nowhere_man: I don't see a way to do that at first glance.
08:11:16 <Lemmih> LeCamarade: They're liquid evil. Fastcgi is much better.
08:11:30 <shapr> nowhere_man: But you could define type aliases or newtypes if you want more significant names in Haddocks.
08:12:19 <LeCamarade> Lemmih: Yeah, I am going to stick to CGI, I think. :o) Plain ol' make(1) babies.
08:12:30 <nowhere_man> so I cannot have something like:  make_range :: Int start -> Int end -> [Int]
08:12:54 <LeCamarade> But I am investigating ways to enjoy web development while enjoying Haskell - these two can't seem to stop fighting, far as I can see.
08:13:07 <LeCamarade> And no DSLs allowed. I want raw Haskell.
08:13:48 <shapr> nowhere_man: What about type Start = Int ; type End = Int ?
08:14:35 <SamB> vincenz: ...okay...
08:14:47 <quicksilver> nowhere_man: no, but then the haddock has a full description for each parameter
08:14:53 <quicksilver> nowhere_man: so that's not really something you need
08:14:57 * vincenz sighs
08:15:04 <quicksilver> nowhere_man: to pick an example at random, look at http://haskell.org/ghc/docs/latest/html/libraries/HGL/Graphics-HGL-Draw-Picture.html
08:15:06 <lambdabot> http://tinyurl.com/2pq7vv
08:15:22 <nowhere_man> quicksilver: I was about to ask for an example, thanks!
08:15:24 <quicksilver> nowhere_man: first proper function 'arc', each parameter (and the return type) are documented
08:16:10 <sioraiocht> Doubles are currently faster the floats for fp arithmetic, right?
08:16:19 <nowhere_man> It was in the context of an article about higher-order programming, and I wanted to comment functions
08:16:24 <quicksilver> sioraiocht: on normaly machines, yes
08:16:37 <sioraiocht> why?
08:16:46 <quicksilver> sioraiocht: because the hardware uses Doubles
08:16:53 <quicksilver> or, in many cases, a larger type than Double
08:17:01 <quicksilver> which you use -fexcess-precision to make sure you use natively
08:17:11 <quicksilver> x86 hardware has a 80-bit FPU, as I understand it
08:17:26 <sioraiocht> in C a float will be smaller than register size?
08:17:42 <sioraiocht> :t pi
08:17:44 <lambdabot> forall a. (Floating a) => a
08:17:49 <sioraiocht> pi :: Double
08:17:50 <bos> woo hoo! i just had a chat with oege de moor, and he and richard bird are going to make "algebra of programming" available on the web in a few weeks!
08:17:57 <vincenz> bos: woo
08:17:57 <sioraiocht> > pi :: Double
08:17:59 <lambdabot>  3.141592653589793
08:18:04 <vincenz> bos: keep me informed?
08:18:06 <nowhere_man> quicksilver: how do you typically express mathematical properties about arguments?
08:18:25 <sioraiocht> Bos that's funny, is dept is currently on the phone with my b/f in the other room...
08:18:28 <sioraiocht> > pi :: Float
08:18:29 <lambdabot>  3.1415927
08:18:45 <nowhere_man> like the fact that the resulting value of a function is no greater that (second_arg - 1)
08:18:56 <bos> vincenz: will do
08:19:01 <vincenz> thanks :)
08:19:02 <vincenz> bos++
08:20:18 <quicksilver> nowhere_man: I'd name the argument in the comment
08:20:25 <quicksilver> Int -- ^ x - a number
08:20:34 <vincenz> So, again, does anyone have any experience with getting lambdabot to work?
08:20:41 <quicksilver> Double -- ^ the result, always less than x*x
08:20:54 <therp> can someone point me to code about "tying the knot?" for instance the code that is supposed to single-pass over a tree and replace it's minimum
08:21:13 <sioraiocht> vincenz: yeah
08:21:14 <EvilTerran> nowhere_man, you could express it as a quickcheck property
08:21:20 <therp> s/replace it's minimum/replaces all nodes by its minimum/
08:21:28 <vincenz> sioraiocht: I'm having issues with it evaluating many of the commands.
08:21:37 <jethr0> therp: isn't that on the old wiki?
08:21:42 <sioraiocht> vincenz: hrm
08:21:43 <jethr0> @old-wiki tying the knot
08:21:43 <lambdabot> http://www.haskell.org/hawiki/tying the knot
08:21:48 <jethr0> *grr*
08:21:49 <sioraiocht> what's it doing? example? 
08:21:54 <sioraiocht> you can /msg me if you want
08:22:03 <jethr0> @old-wiki tyingtheknot
08:22:03 <lambdabot> http://www.haskell.org/hawiki/tyingtheknot
08:22:13 <quicksilver> therp: http://www.cse.ogi.edu/pacsoft/projects/rmb/repMin.html 
08:22:14 <lambdabot> Title: Recursive Monadic Bindings
08:22:16 <quicksilver> might be relevant
08:22:23 <jethr0> http://www.haskell.org/hawiki/TyingTheKnot
08:22:24 <lambdabot> Title: TyingTheKnot - The Haskell Wiki
08:22:39 <therp> I found the wiki page impossible to read
08:22:55 <jethr0> therp: in that assessment you're not alone ;(
08:22:56 <therp> thanks for the link quicksilver 
08:34:50 * shapr throws evil lambdas at the frustrating code!
08:35:08 <_roconnor> @google phi km in miles
08:35:09 <lambdabot> the golden ratio kilometers = 1.00539971 miles
08:35:20 <shapr> Yeah, I want my house to be that big.
08:35:24 <vincenz> google has rounding errors
08:36:49 * shapr throws a pawn at chessguy 
08:37:03 * chessguy eats it
08:37:35 * Nafai yawns
08:37:44 <chessguy> mmm, staunton
08:38:36 * shapr burbles frumiously
08:38:58 <eivuokko> On haskell-cafe, there was a mail about creating big arrays, and not getting error.  It seems that Ix in GHC.Arr doesn't rise error for invalid ranges, like report requires.  Do you think that's on purpose?
08:41:24 <SamB> eivuokko: I thought the trouble was that some calculations were allowed to overflow?
08:41:49 <eivuokko> SamB, That's only one problem.
08:42:03 <wli> That was the source of a bunch of remote browser exploits with hand-crafted image files.
08:42:06 <SamB> what was the otther problem?
08:43:48 <chylli> hi. a stupid question.
08:43:48 <chylli> main = do args <- getArgs
08:43:48 <chylli>           putStrLn ("Hello, " ++ args !! 0)
08:43:51 <chylli> got :
08:43:58 <chylli> The last statement in a 'do' construct must be an expression
08:44:00 <chylli> why ?
08:44:25 <mauke> probably misindentation
08:44:26 <int-e> chylli: that looks correct. check your editor's tab size? it should be 8
08:44:34 <mauke> start a new line after "do"
08:44:42 <chylli> k
08:44:45 <chylli> let me try
08:45:14 <edward1> gah, the normal ordering over the naturals has the wrong order for bitwise and and or to be treated as meet and join. looks like i need some sort of newtype hack
08:45:39 <eivuokko> SamB, Ehm, nvm, I think I read wrong on report.
08:45:45 <int-e> mauke: you don't have to do that.
08:45:58 <int-e> mauke: (although I guess it helps if tab size is the problem)
08:45:58 <mauke> int-e: I think I do
08:46:03 <mauke> yeah
08:46:05 <chylli> yes, that is indent problem
08:46:18 <chylli> I'm using emacs under mode haskell-mode
08:46:26 <mauke> for some reason haskell insists on treating tabs as 8 spaces wide when it should be 4 (obviously)
08:46:29 <eivuokko> SamB, He also falls on packed unboxed bool array, tho.  Normally he might have ran into 2Gb address problem, but can't have that with bools and Ix.
08:46:31 <chylli> seems indent not work?
08:46:49 <hpaste>  int-e pasted "indentation, working example" at http://hpaste.org/1616
08:47:07 <Cale> mauke: Nearest 8 space boundary is the way it's always been. The real solution is to just make tab characters result in a lexical error.
08:47:26 <vincenz> Cale: even better: remove the ascii-value for a tab character
08:47:28 <mauke> I disagree :-)
08:47:29 <int-e> (it looks exactly like what chylli pasted, and it works. so tab size would be my first guess)
08:48:10 <Cale> vincenz: yeah, there's no need for such a character
08:48:50 <Cale> It's not like we're so hard pressed for disk space that a few extra space characters are going to hurt.
08:48:58 <chylli> I got code from http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/firststeps.html . it use indent like what i pasted.
08:49:04 <mauke> int-e: I also don't like signifcant alignment in the middle of lines
08:49:09 <edward1> hrmm would something like if Bits a <= Bits b...  let Bits c = Bits a && Bits in .. be too onerous?
08:49:58 <Cale> edward1: hm?
08:50:01 <mauke> int-e: starting a new line after where/do moves the alignment issue to the start of a line
08:50:13 <int-e> mauke: well Haskell allows all sorts of styles. pick what you like best
08:50:20 <Cale> mauke: good luck getting people to do that :)
08:50:46 <mauke> I'm not trying to convince anyone to use my style :-)
08:51:14 <mauke> I just write code that works (and nicely avoids tabs/space problems)
08:51:17 <edwardk> cale: been toying with a way-general prelude. playing with preorders, posets, etc. worked up to heyting and boolean algebras, so now (&&) and (||) are defined over an arbitrary algebra rather than just Bool
08:51:46 <Cale> chylli: that page has spaces in it -- perhaps emacs managed to turn some spaces into a tab? If anything, it should do it the other way around (tabs -> spaces).
08:51:56 <edwardk> cale: consequently they should respect the bounded lattice laws relating (<=,&&,...) 
08:52:54 <Cale> (setq-default indent-tabs-mode nil)
08:53:14 <Cale> I think that's the required bit of configuration, but it's been a while since I last used emacs.
08:53:30 <edwardk> cale: there is a sensible interpretation of each of the builtin Int or Word-like types as B^n, with the standard <= subset of bits set inclusion ordering, but thats obviously not what people think when they say <= =)
08:54:09 <Cale> Yeah, a newtype for that seems reasonable.
08:54:32 <edwardk> cale: so it seems that newtyping to get the boolean semantics is about the only way to make it happen.
08:55:13 <wli> Aha, so to hide instance, make non-exported newtypes?
08:55:17 <edwardk> possibly with some Data.Bits like sugar
08:55:21 <vincenz> wli: yep
08:55:22 <vincenz> wli: you do
08:55:32 <vincenz> module foo(ConstructorName)
08:55:33 <vincenz> iso
08:55:38 <vincenz> module foo(ConstructorName(..)
09:02:07 <laz0r> mmmh, monads
09:02:37 <laz0r> as far as i understand, monads are the tool of choice if you need 'side effects'
09:02:46 <sioraiocht> laz0r: yes
09:03:00 <sioraiocht> I/O is monadic in haskell
09:03:31 <laz0r> so, if i am going to implement something 'process like', something that needs to 'carry on its own state', i would use some kind of a monad
09:03:37 <shapr> laz0r: Monads really just do sequencing in a language that doesn't have that, and you can exploit sequencing to get something that approximates side-effect, but that's probably more information than you really want :-)
09:03:37 <laz0r> e.g. the state monad
09:03:48 <laz0r> mmh
09:04:07 <wli> What's a good way to enumerate all combinations of n nonnegative integers summing to some fixed value d?
09:04:36 <shapr> wli: Did you see the solutions to the xkcd comic?
09:04:47 <wli> shapr: No.
09:05:13 <Syzygy-> wli: Generating functions!
09:05:18 * SamB wants a prettyprinter which can be more sensitive of which places are good to break lines and which places are bad to break lines, as well as a nice model for indentation that works for e.g. nested lambdas
09:05:30 <Cale> It's important not to take 'sequencing' the wrong way in what shapr said though.
09:05:30 <Syzygy-> You start by having a good package for computation with polynomials and power series in one variable, and then ...
09:05:48 <Cale> The evaluation order can be completely different from the order imposed by the monad operations.
09:06:02 <wli> I suspect there's a list monad trick for it.
09:06:19 <SamB> I'd also like it to look a wee bit farther ahead.
09:06:20 <Syzygy-> Oh wait. Enumerate, not count.... That's different.
09:06:34 <shapr> wli: http://forums.xkcd.com/viewtopic.php?t=7532
09:06:37 <Syzygy-> So make it a non-commutative multivariate polynomial multiplication package instead.
09:06:37 <Cale> I like to describe monads as one way to structure domain specific languages so that a bunch of common control structures come along for free.
09:06:50 <Syzygy-> Or something.
09:07:10 <shapr> Syzygy-: That's another one of those things that can only be said with a straight face on #haskell
09:07:22 <Syzygy-> shapr: Which of it?
09:07:25 <Cale> Syzygy-: still generating functions!
09:07:38 <shapr> @quote structural
09:07:38 <lambdabot> shapr says: I dare you to call a substructural type system obvious anywhere outside of #haskell.
09:07:42 <Syzygy-> Cale: Yeah! But inspecting the terms of a single degree gives you the actual ways you got there.
09:07:51 <Cale> Syzygy-: right
09:08:23 <Syzygy-> Oh yeah, I need to do this to Cale too - the rest I know on that team already got it...
09:08:25 <Cale> Syzygy-: or the coefficient of a particular variable will be some polynomial whose terms encode that information
09:08:38 * Syzygy- glares at Cale for being in a cool team that was already filled up when I started looking at the ICFP contest!
09:08:45 <Cale> hehe
09:08:53 <nopcode> hey
09:08:54 <Cale> By the way 'generating series' is a better term.
09:09:10 <Syzygy-> Cale: I thought something along the lines of a new variable for each way, with an inherent degree, and then just pick out the goal degree.
09:09:14 <Syzygy-> And yeah.
09:09:27 <Cale> Since usually you don't care at all about convergence of the series as a function.
09:09:27 <shapr> wli: Er, this one is better: http://programming.reddit.com/info/24p2c/comments
09:09:28 <lambdabot> Title: xkcd - Does anyone else feel compelled to solve this? (reddit.com)
09:09:29 <Syzygy-> I'm so used to generating function, since that was the term my lecturer (and IIRC Stanley) used for it.
09:09:55 <nopcode> is there a shorter way to write (\x -> foo a x b)?
09:10:11 <Syzygy-> @pl \x -> f a x b
09:10:12 <lambdabot> flip (f a) b
09:10:17 <Syzygy-> There ya go.
09:10:19 <nopcode> lol
09:10:21 <nopcode> no thanks
09:10:27 <nopcode> i meant shorter as in "still readable" :)
09:11:03 <shapr> #haskell standards for readable have changed greatly in the past few years.
09:11:13 <Syzygy-> shapr: Oh?
09:11:22 <int-e> all @pl's fault ;)
09:11:25 <nopcode> (concatMap (\x -> (krec items (x:taken) limit)) items)
09:11:25 <shapr> Yeah, it is.
09:11:28 <nopcode> this is the expression
09:11:33 <shapr> These days (->) is just a given.
09:11:39 <Cale> Basically lots of things using the ((->) e) monad are now considered quite readable
09:11:50 <nopcode> ok :)
09:11:54 <int-e> > sequence [(+1), (*2)] 3
09:11:57 <lambdabot>  [4,6]
09:12:35 <Cale> do {x <- items; krec items (x:taken) limit}
09:14:45 <quicksilver> nopcode: what you had originally is the best way to write it, IMO
09:14:52 <shapr> Cale: Have you submitted a patch to restore monad comprehensions?
09:15:12 <nopcode> ok :)
09:15:13 <Syzygy-> Or even [krec items (x:taken) limit : x <- items]
09:15:19 <Syzygy-> (or was it | ?)
09:15:28 <Syzygy-> > [x : x <- [1,2,3]]
09:15:28 <lambdabot>  Parse error
09:15:31 <Cale> shapr: I don't know enough about GHC to write it.
09:15:34 <Syzygy-> > [x | x <- [1,2,3]]
09:15:36 <lambdabot>  [1,2,3]
09:15:39 <Syzygy-> It was |
09:15:40 <nopcode> but i'd still have to concatenate the elements
09:15:52 <nopcode> that is folding with ++
09:16:05 <Cale> shapr: Also, really doing a good job of restoring monad comprehensions would involve making incompatible changes to the base libraries.
09:16:11 <Cale> (and Prelude)
09:16:31 <Cale> I think we need to do another big change.
09:16:40 <shapr> As in, other than monad comps?
09:16:58 <Cale> As in, get a whole bunch of incompatible changes out of the way at once.
09:17:09 <shapr> Sounds good to me...
09:17:47 <shapr> edwardk: Is your alternate Prelude in a repo somewhere?
09:17:55 <Cale> Haskell' seems aimed at mostly standardising existing practice, but that means it's probably unwilling to make many of the changes that I'd really like to see.
09:18:13 <Syzygy-> Cale: What are your main issues?
09:18:49 <ClaudiusMaximus> i have out::a->IO() and in::[b]->IO(), i want 'out' to call 'in' when given a list and 'error' otherwise. can i do that by adding Typeable constraints and appropriate checking inside 'in'?
09:18:52 <wli> f 0 _ = [] ; f 1 d = [[d]] ; f n 0 = [replicate n 0] ;  f n d = concat [map (k:) $ f (n - 1) (d - k) | k <- [0..d]]
09:18:58 <Cale> Well, the Functor hierarchy, getting rid of fail, fixing MonadZero/MonadPlus
09:18:59 <quicksilver> associativity of $ !
09:19:05 <Cale> Associativity of ($)
09:19:08 * quicksilver wins
09:19:27 <shapr> Cale: Anything more?
09:19:39 <quicksilver> ClaudiusMaximus: that would be a nasty thing to do. 
09:19:47 <Cale> Well, if you really want to be picky/damaging, the module path separator annoys me.
09:20:01 <Cale> Also, some changes to the numeric hierarchy would be nice.
09:20:19 <shapr> You mean you don't like Foo.Bar?
09:20:30 <quicksilver> Cale: and probably require one of the type class alias proposals, to be comfortable
09:20:34 <Syzygy-> Cale: I second the numerics loudly.
09:20:39 <Cale> Yeah, qualified names look like hell in the middle of chains of compositions.
09:21:01 <quicksilver> Data.List.filter p.Data.List.map f
09:21:02 <shapr> I want Read/Show to be for human consumption only, and Serialize for saving values.
09:21:03 <Syzygy-> foo . bar . baz . Map.map . bla . f . g . h
09:21:09 <Cale> Syzygy-: exactly.
09:21:21 <Cale> | would be a better character for that, I think
09:21:22 <shapr> Cale: What would look better?
09:21:31 <Cale> Map|map
09:21:51 <jethr0> or Map:map
09:22:01 <Cale> : is untouchable :)
09:22:03 <shapr> Too bad we can't easily type Â·
09:22:09 <quicksilver> Map'map
09:22:19 <quicksilver> char literals are way over-rated anyway
09:22:28 <Cale> Well, that still might work
09:22:44 <shapr> What about changing function composition from . to Â· ?
09:22:53 <jethr0> Map&map
09:22:59 <quicksilver> I like ' because it's "physically light"
09:23:07 <quicksilver> it fades into the background, mostly
09:23:20 <Cale> shapr: that would be significantly more annoying :)
09:23:25 <quicksilver> shapr: I don't think we should *require* extended charactersets
09:23:34 <quicksilver> shapr: it's one thing to support them in neat ways
09:23:38 <wli> They even come out grevlex. Awesome.
09:23:55 <quicksilver> Data-Map-map
09:24:00 <Cale> Even though I can type Â· it takes a few keystrokes.
09:24:01 <quicksilver> Data!Map!map
09:24:12 <shapr> I have to type C-= . 2
09:24:19 <quicksilver> Cale: I daresay you'd fix your editor to make it one keystroke if you really wanted to
09:24:24 <quicksilver> I know I would
09:24:32 <ClaudiusMaximus> quicksilver: i'm (trying) to embed Haskell into a C program, i expect nastiness - the C program has a "stateful object with message passing" paradigm, i want to be able to pass (polymorphic) data between those objects which are implemented in Haskell.  "no method for X" errors are inevitable
09:24:32 <dylan> Â· is compose-.-. here
09:24:37 <Cale> I type \ c d <space>
09:24:38 <shapr> I'd just get emacs to rewrite .. into Â· in a buffer.
09:25:01 <wli> Now how do I compute the index in the list of tuples summing to the same value...
09:25:15 <shapr> y0 Souwh 
09:25:24 <Cale> (which is short for \cdot)
09:25:32 <quicksilver> ClaudiusMaximus: yes, but hide those errors in your 'wrapping layer'
09:25:49 <wli> It's Cantor tupling number fodder.
09:25:50 <quicksilver> ClaudiusMaximus: dynamic could be the way to go
09:25:52 <Souwh> oY shapr
09:26:09 <ClaudiusMaximus> quicksilver: i tried Data.Dynamic, but it doesn't allow polymorphic values
09:26:20 <shapr> Cale: I like all of your changes except for the change from Module.function to something else.
09:26:56 <Cale> I'll admit that one is a little questionable :)
09:27:13 <quicksilver> ClaudiusMaximus: I don't think anything will allow you to pass around polymoprhic values. They're an illusion of the type-checker, in a sense.
09:27:23 <shapr> Other than monad comps, they're easily implemented with --no-prelude, yeah?
09:27:31 <Cale> shapr: What do you think about swapping the associativity of ($)?
09:27:45 <shapr> I don't get it.
09:27:50 <Cale> shapr: Only if you want to lose all the rest of your libraries
09:28:07 <Cale> This stuff really needs to be done at a grand scale.
09:28:08 <shapr> Why would you want to swap $?
09:28:24 <Cale> because you can always rewrite f $ g $ h $ x as f . g . h $ x
09:28:38 <wli> It may sound stupid, but the "mathiness" is really handy when it comes down to complex array indexing calculations.
09:28:49 <Cale> You could remove more parens from expressions with the opposite associativity
09:28:57 <Cale> For example...
09:29:08 <shapr> Well, #haskell holds sway over a large chunk of the Haskell community. If the changes become popular here, they'll probably become popular in the rest of the community.
09:29:10 <ClaudiusMaximus> quicksilver: hmm.  say i have one box with "reverse :: [a] -> [a]", is there any way i could feed xs::[Float] into it at runtime?  or does it need to be compiled to a specialized form statically?
09:29:42 <quicksilver> ClaudiusMaximus: I don't understand the details of GHC's runtime representation of these things
09:29:49 <Cale> f (g x) (h y) == f $ g x $ h y
09:29:59 <Cale> which isn't possible with the current $
09:30:08 <Botje> woah. that's sexy :)
09:30:12 <shapr> Yeah, that is cool.
09:30:17 <quicksilver> I'm with Cale on this one
09:30:19 <quicksilver> as previously noted
09:30:31 <quicksilver> in return, could one of you answer ClaudiusMaximus's question above, because I'm a bit lost :)
09:30:33 <shapr> Do any of the current uses of $ die with the change?
09:30:40 <wli> Cale: Better to use a ternary example; that's doable as g x `f` h y
09:30:55 <Cale> shapr: Just the long chains of $'s, which have to be replaced with compositions.
09:31:02 <quicksilver> shapr: yes, anyone who uses it more than once at the same level, like ndm
09:31:10 <shapr> That doesn't sound like a loss to me.
09:31:14 <quicksilver> although I tried to point out the error of his ways :)
09:31:30 <quicksilver> there is another reason to prefer the f . g . h $ x form
09:31:35 <quicksilver> which is you can abstract away the x
09:31:35 <shapr> ?
09:31:42 <shapr> Autopointless?
09:31:45 <Cale> Right, especially because rewriting those chains as compositions makes them more refactorable
09:31:58 <quicksilver> p x = f . g . h $ x ---~~--> p = f . g . h
09:32:07 <Cale> g . h is meaningful on its own in that expression, but g $ h probably won't be
09:32:16 <quicksilver> p x = f $ g $ h $ x -X-> p = f $ g $ h
09:32:19 <quicksilver> bang :)
09:32:32 <Cale> So you can more easily see things that can/should be factored out.
09:32:57 <cdsmith> I just got here.  Is this about a language change that would prevent f $ g $ h $ x?
09:33:21 <quicksilver> it would prevent that precise syntax, yes
09:33:27 <quicksilver> you'd have to write f . g . h $ x
09:33:32 <quicksilver> or f ( g ( h x) )
09:33:38 <cdsmith> Uh huh.  Why?
09:33:48 <quicksilver> because $ would be much more interesting left-associative
09:33:49 <Cale> cdsmith: but it would allow for more removal of parens
09:34:00 <quicksilver> you could then rewrite f (g x) (h y)
09:34:04 <quicksilver> as f $ g x $ h y
09:34:47 <cdsmith> I don't like this... but I'm trying to figure out why.
09:34:49 * ricky_clarkson idly wonders why removing parens is positive.
09:35:13 <jethr0> ricky_clarkson: only one char to change instead of two when you rearrange the expression
09:35:15 <Cale> ricky_clarkson: because it makes expressions easier to manipulate.
09:35:41 <ricky_clarkson> Does it make them easier to read too?
09:35:46 <Cale> yah
09:35:47 <Cale> yeah*
09:36:18 <cdsmith> I don't think so... but perhaps only because I'm not used to f $ g x $ h y
09:36:24 <quicksilver> any change makes it harder to read until you adjust
09:36:25 * jethr0 doesn't like a $ b $ c $ d. i much prefer to use "a . b . c $ d" since it makes more of a distiction between functions and values
09:36:29 <quicksilver> that's the nature of change
09:36:38 <quicksilver> jethr0++ # good point
09:36:46 <Cale> I'd much prefer to see f . g . h $ x than f (g (h x))
09:36:54 <cdsmith> jethr0: I fundamentally see distinctions between functions and values as meaningless.
09:36:55 <jethr0> ack
09:36:57 <edwardk> shae: i'll post it up soon.
09:37:01 <shapr> edwardk: spiffy
09:37:11 <ricky_clarkson> I'd rather see h(x).g.f
09:37:29 <jethr0> cdsmith: let met rephrase that: it makes distictions between functions that still need arguments and those that don't ;)
09:37:31 <Cale> ricky_clarkson: I hope that's a joke :)
09:37:32 <shapr> ricky_clarkson: try #smalltalk ;-)
09:37:49 <edwardk> i had to develop it locally because i've had so many connectivity problems to my web server lately
09:37:52 <jethr0> ricky_clarkson: that's EVIL. make it at least "x $ h . g . f"
09:37:58 <jethr0> ;)
09:38:06 <shapr> or x.h().g().f() with python, yeah?
09:38:11 <quicksilver> x $> h >>> g >>> f
09:38:32 <edwardk> shapr: be warned its kind of painful to actually code for right now. =) i'm probably going to have to work some sort of template haskell magic
09:38:43 <edwardk> there are just too many instances running about
09:38:44 <ricky_clarkson> I actually like | from bash, so I wouldn't mind . being like |..
09:38:53 <cdsmith> Well, as someone who uses '$' a lot, I'm really unsure about the benefit gained from breaking all that code.
09:39:10 <shapr> cdsmith: I enjoy your blog entries, keep it up!
09:39:11 <xerox> > ((*2) >>> (+10) $ 5, (*2) . (+10) $ 5)
09:39:13 <lambdabot>  (20,30)
09:39:22 <cdsmith> shapr: thanks
09:39:40 <quicksilver> xerox: yes, possibly I should have chosen <<<
09:39:47 <Cale> shapr: I thought smalltalk used spaces for message passing?
09:39:47 <shapr> cdsmith: btw, did you get answers to all of your remaining HAppS questions?
09:39:55 <quicksilver> xerox: there is a little ambiguity about the 'sensible direction' for that arrow
09:40:00 <cdsmith> shapr: I'm thinking of dropping the number theory bit, though.   Are you attached to it?
09:40:15 <cdsmith> shapr: no; I'm looking into it, though.  I just need to find time.
09:40:25 <shapr> cdsmith: Nah, number theory isn't my thing. But other people here on #haskell may like it.
09:40:26 <Cale> cdsmith: It's not so bad if you adapt to using function composition
09:40:48 <Cale> You just mindlessly replace all the $'s but the last with .'s
09:41:11 <cdsmith> Cale: Sure, it's easy to fix, I agree.
09:41:21 <ricky_clarkson> cdsmith: I enjoyed types.html
09:41:25 <ddarius> Mindlessly doing things, sounds like fun.
09:41:56 <shapr> Cale: I was thinking more that the result of a method in Smalltalk is (by default) the object itself, and that leads to easy composition. But I could be wrong about that, I never did much Smalltalk.
09:41:57 <cdsmith> ricky_clarkson: I'm glad.  I pretty much neglected my job for for two straight days writing it. ;)
09:43:04 <EvilTerran> ddarius, it would be fairly straightforward to write a source manipulator to do the least change necessary to fix all existing code
09:43:09 <cdsmith> Cale: I guess the deciding question for me is this: is it possible (or likely) that code with continue to work, but just mean the wrong thing.
09:43:25 <cdsmith> s/work/compile/
09:43:36 <EvilTerran> i think type/kind errors would be very likely
09:44:14 <Cale> cdsmith: It seems pretty unlikely that code will continue to function without extreme polymorphism being present.
09:44:30 <cdsmith> extreme polymorphism?
09:44:31 <EvilTerran> ?type ?f (?g ?x)
09:44:33 <lambdabot> forall t t1 t2. (?f::t -> t1, ?g::t2 -> t, ?x::t2) => t1
09:44:37 <EvilTerran> ?type (?f ?g) ?x
09:44:38 <lambdabot> forall t t1 t2. (?f::t -> t1 -> t2, ?g::t, ?x::t1) => t2
09:44:42 <quicksilver> cdsmith: yes, like 'id'
09:44:53 <quicksilver> cdsmith: id will still work since it doesn't care what type it gets :)
09:45:01 <quicksilver> cdsmith: but not many things are that polymorphic
09:45:05 <cdsmith> right.
09:45:24 <EvilTerran> ?type (id (id id), (id id) id)
09:45:25 <Cale> cdsmith: I mean, you might be able to come up with some contrived example with typeclasses, but typical code will fail to typecheck.
09:45:25 <lambdabot> forall a a1. (a -> a, a1 -> a1)
09:45:30 <quicksilver> in most cases, they'd need to be totally polymorphic in their 'first' argument
09:50:48 <cdsmith> I actually popped in to ask if anyone knows where I can find good examples of using hsc files.
09:55:12 <cdsmith> no?
09:55:16 <eivuokko> cdsmith, Win32 package has a lot of hsc.  But not all features are used in there.
09:55:43 <cdsmith> Cool.  I'll look there, then.
09:55:58 <eivuokko> Do you have something special you're trying to learn about hsc?
09:56:18 <cdsmith> If I just get a general idea of how they fit in, then I can probably pick up specifics from lots of places.
09:59:38 <Nafai> cdsmith: I'm guessing it was you that wrote this: http://cdsmith.twu.net/types.html -- Thanks for the good explanations!
09:59:39 <lambdabot> Title: What To Know Before Debating Type Systems
09:59:54 <cdsmith> Nafai: yep, that's me.  Thanks for the kind comment.
10:01:13 <Nafai> I'm still trying to understand types and Haskell and all that, so it's helpful.
10:02:50 <cdsmith> Nafai: I'm glad it did you some good.  Others here are more helpful than I am about learning Haskell though.  I have a strange way of understanding things, and it makes it hard to explain them to others. :)
10:03:46 <Nafai> Like you alluded to in the essay (if I may call it that), I think my notion of types has been warped by my use of languages like C++ and Java versus others like Python and Lisp.
10:04:05 <ddarius> Nafai: Not atypical.
10:04:44 <ddarius> If you tell most programmers that "type theory" is interesting, you'd get a wierd look.
10:04:48 <monochrom> There is a safe way to transit from mainstream types to Haskell types. They are not very different.
10:04:50 <Nafai> Heh
10:04:55 <ricky_clarkson> It's a good resource to point people at when they're talking nonsense.
10:05:24 <ddarius> cdsmith: Oh no! Buy more bandwidth for your server then.
10:05:26 <Nafai> I think where I'm at in my education of this is the type system vs testing issue
10:07:01 <ricky_clarkson> Testing has some positive effects on modularity, but negative effects in some 'weakly' statically typed languages.  E.g., in Java, testing almost necessitates dependency injection.
10:07:35 <cdsmith> ddarius: ?? I need more bandwidth?
10:07:52 <Nafai> cdsmith: Because of all of the people that need to read this page. :)
10:07:57 <ddarius> [12:04] <ricky_clarkson> It's a good resource to point people at when they're talking nonsense.
10:08:04 <cdsmith> Ah!  Gotcha.
10:08:17 <monochrom> Where can I find cdsmith's stuff referred to now?
10:08:32 <ricky_clarkson> My own intuition is that good code should look the same with testing applied to it, or with static types proving it.  Both techniques should not make good code hard to read.
10:08:52 <cdsmith> monochrom: They are talking about http://cdsmith.twu.net/types.html
10:08:52 <lambdabot> Title: What To Know Before Debating Type Systems
10:09:23 <ricky_clarkson> Otherwise known as "What You Should Have Known Before Writing That Blog Post". ;)
10:09:58 <cdsmith> It's actually a summary of my arguments from a gigantic internet flame war last summer... after having taken a year to calm down a bit. :)
10:10:23 <mrd> i like the characterization of 'weak' typing
10:10:43 <wli> In other news, I'm making steady progress on my Hermite interpolation for rational functions / multi-center Pade approximant problem.
10:10:53 <Nafai> I was trying to explain to a friend why less testing was necessary in languages like Haskell because of the type system
10:11:06 <Nafai> But I was unable to convey it because I think I only intuitively understand it
10:11:21 <mrd> because you don't have to test whether you try to add 2 and an apple?
10:11:31 <ddarius> wli: That reminds me that I should look at elliptic functions more.
10:11:46 <mrd> unless of course you instance Num Fruit
10:11:49 <kjdf> hi
10:12:06 <kjdf> I am writing a small program, a filter/transformer for keyboard events
10:12:06 <ricky_clarkson> I don't think many developers in dynamic languages actually test what happens when you make 'simple' type errors.
10:12:20 <kjdf> a simplified version of one aspect of it is here: http://hpaste.org/1617
10:12:40 <kjdf> basically it is a finite automaton that yields some output with each transition
10:12:40 <kjdf> my question is - does it look in any way familiar?
10:12:50 <flux> nafai, how about that with static types you have a lot less branches in the code (each function application is testing the suitability of the argument for the function), hence less branches to test?
10:12:56 <kjdf> maybe there is a pattern that captures this kind of thing
10:12:57 <kjdf> any suggestions on how to make it prettier, etc.
10:13:20 <kjdf> maybe a monadic interface of some kind to make it composable..
10:13:20 <kjdf> any suggestions/comments at all
10:13:20 <flux> (the stuff in parenthesis referring to dynamically typed code)
10:13:29 <mrd> unfoldr?
10:13:53 <mdmkolbe> Does any of GHC's array implementations allocate the array memory aligned?  (For high performance numberic computing it can matter.)
10:13:55 <ricky_clarkson> flux: Again, most of the time you assume it's of the right type.
10:14:08 <wli> ddarius: All extant rational spline affairs that I'm aware of use homogeneous coordinate cop-outs.
10:14:10 <ddarius> kjdf: What mrd said.
10:14:33 <ricky_clarkson> Testing and static typing both only have significant value for things more advanced than null checking.
10:14:34 <mrd> :t unfoldr
10:14:36 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
10:14:37 <ddarius> mdmkolbe: I'm pretty sure it allocates everything aligned.
10:14:39 <kjdf> yes, I am thinking..
10:15:00 <ddarius> kjdf: In general you may want to explore the unfold for your type.
10:15:18 <wli> ddarius: I've found what I believe is a collection of tricks that makes the straight-up, brute-force splines feasible.
10:15:21 <mdmkolbe> ddarius: I should qualify my question.  I meant page and cache line aligned, not just word aligned.
10:15:27 <flux> ricky_clarkson, well, how about passing nulls when you expect a value?
10:15:37 <flux> ricky_clarkson, I'm thinking that
10:15:42 <flux> that's one of the more common bugs
10:15:49 <flux> just a gut feeling, though :)
10:15:49 <ddarius> mdmkolbe: I don't know.  I think it is more than word aligned, but not page aligned, but I could be wrong.
10:16:02 <wli> ddarius: If I'm right about certain things, even fast.
10:16:03 <ricky_clarkson> It is, but it's something to prevent, not to test for, if that makes sense.
10:16:04 <SamB> mdmkolbe: it probably depends on the size of the array
10:16:30 <ricky_clarkson> flux: If f shouldn't accept null, there's no point testing what happens when f receives a null, in most cases.
10:16:47 * ddarius is out.
10:17:49 <flux> ricky_clarkson, yes, the point would be in testing that the code that calls the f never calls it with a null.. perhaps by writing a testing module providing the same interface and asserting on null calls, however usually modules just crash in those cases anyway
10:17:59 <flux> so they might be used as-is (if otherwise suitable)
10:18:15 <SamB> you could... um... run catch?
10:18:16 <basti_> how comes that with OpenGL i can't run my program twice in hugs? it always dies with "Unexpected Signal" on the second try
10:18:23 <mauke> after converting this code to haskell it is now shorter than the perl version ... but at what price?
10:18:38 <SamB> basti_: probably the same reason that used to happen with gtk2hs
10:18:39 <wli> I kind of wish Haskell had Standard ML-ish modules in addition to types. There's always Cayenne, I suppose, though NFI about maturity there.
10:18:46 <ricky_clarkson> flux: Sure, or a type system that doesn't include null.
10:18:48 <basti_> which would be?
10:19:04 <ricky_clarkson> flux: If we're talking about Java, as it seems, then Nice is one such beast.
10:19:10 <mauke>     netinfo <- liftM (M.filterWithKey (const . not . internal) . parseNet) $ readFile "/proc/net/dev"
10:19:18 <dcoutts_> basti_: some initialisation function that's only supposed to be run once
10:19:18 <mauke> let (down, up) = M.fold (\x -> liftM2 (***) ($ "Receive") ($ "Transmit") ((+) . (x ??)  . \d -> (d, "bytes"))) (0, 0) netinfo
10:19:22 <SamB> that the library is left in a bad state after a run...
10:19:30 <dcoutts_> or that
10:19:37 <basti_> so there's no way of fixing it easily?
10:19:45 * dcoutts_ fixed it for gtk2hs
10:19:54 <basti_> -.-
10:19:55 <basti_> ;)
10:20:02 <SamB> well, by "bad state" I mean "a state that will cause a crash if you try to use it again"
10:20:12 <wli> The error handling for readFile is terrible.
10:20:16 <SamB> which includes what dcoutts said ;-)
10:20:32 <mauke> wli: why?
10:20:41 <SamB> wli: it's a known issue
10:20:48 <dcoutts_> is it?
10:20:55 <SamB> dcoutts: what?
10:21:07 <dcoutts_> SamB: it's known by some, I'm not aware
10:21:22 <SamB> dcoutts: how could it not be terrible?
10:21:25 <wli> mauke: It doesn't really backpropagate errors to users like it should.
10:21:45 <SamB> by the time the error occurs, the function has returned!
10:21:52 <mauke> even open errors?
10:22:02 <SamB> oh, not those I hope ;-)
10:22:05 <dcoutts_> mauke: open errors are returned immediately
10:22:05 <wli> mauke: Of course not all errors.
10:22:20 <SamB> it would be a lot of work to make the handling of open errors terrible
10:22:22 <mauke> then it doesn't really matter. reading from /proc/net/dev shouldn't error, ever
10:22:27 <wli> There are also error statuses one must reap on close().
10:22:34 <dcoutts_> lazy IO errors are not so well done
10:22:38 <SamB> wli: what do you mean?
10:22:44 <dcoutts_> bytestring's readFile propogates the IO errors
10:23:00 <dcoutts_> though not so sure about close() actually
10:23:18 <SamB> dcoutts: but not the .Lazy, right?
10:23:26 <wli> SamB: Delayed writeback can incur errors after an IO routine has returned. Primarily an issue for NFS AIUI, though standardswise it's for all cases.
10:23:43 <dcoutts_> SamB: .Lazy too, it throws the error when it occurs
10:23:57 <SamB> dcoutts_: well. I mean, where does it throw the error *to*?
10:24:11 <dcoutts_> SamB: so that could be later, in pure code, but it just propagates to the nearest IO part of your program
10:24:16 <dcoutts_> SamB: like calling error
10:24:32 <dcoutts_> so it's quite possible to handle it nicely
10:24:37 <SamB> so am I to understand that Prelude.readFile is *worser* than that?
10:24:52 <dcoutts_> SamB: yes, it silently truncates
10:24:52 <mauke> the weird part is that this code just worked on the first try
10:25:03 <SamB> dcoutts: oh, that is a bit worser yes :-(
10:25:17 <SamB> is that slated for fixing in Haskell'?
10:25:33 <eivuokko> How can you fix it?
10:25:37 <wli> Most of it centers around -ENOSPC
10:25:42 <dcoutts_> wli: sometimes it's the finaliser that calls close() so there's nobody around to notice any errors. The finaliser is not associated with any thread of control.
10:25:45 <SamB> eivuokko: it could, uh, throw an error
10:25:47 <wli> Though there is some -EIO.
10:25:55 <wli> dcoutts: Yes, and that's a problem.
10:26:06 <mauke> just do what perl does!!
10:26:26 <mauke> (perl ignores exceptions thrown from object destructors)
10:26:36 <SamB> dcoutts: when the finalizer closes a file, isn't that because it was discarded before EOF anyway?
10:26:44 <dcoutts_> SamB: yes
10:27:00 <wli> An error handler to be invoked from the finalizer in the event of an error on close() would be helpful.
10:27:03 <mauke> I think close errors aren't an issue for reading
10:27:08 <dcoutts_> if you read the whole file, it get's close()d immediately
10:27:31 <SamB> so really there isn't anyone to whom to throw the error if you drop the file halfway through...
10:27:35 <campusblo> hello
10:27:45 <dcoutts_> SamB: right
10:27:46 <campusblo> can anybody tell me how to perform an operation on a list of tuples?
10:27:58 <SamB> campusblo: what kind of an operation?
10:28:06 <mauke> operation [(list, of), (some, tuples)]
10:28:07 <wilx> Gloves, scalpel...
10:28:08 <SamB> well, anyway, map
10:28:27 <eivuokko> SamB, imprecise exception stuff?
10:28:28 <mauke> > length [(undefined, undefined), (undefined, undefined)]
10:28:33 <lambdabot>  2
10:28:43 <campusblo> i want to check if a leter is equal to another and replace it with another
10:28:44 <wli> SamB: The easy way to resolve is to pass an error handler continuation/etc. for the finalizer to invoke.
10:28:45 <jethr0> > map (\(a,b) -> (a+1, b+1)) [(1,2), (3,4)]
10:28:47 <lambdabot>  [(2,3),(4,5)]
10:28:48 <campusblo> im doing a cipher
10:29:00 <SamB> eivuokko: how imprecise are you prepared to be?
10:29:13 <campusblo> replace x [(b,c)]
10:29:13 <campusblo>          a == b = c
10:29:38 <campusblo> so i want to test x with every tuple
10:29:47 <kjdf> ok, I will think about it (unfold) more
10:29:52 <campusblo> and if x = b then i want to give out c
10:30:01 <SamB> @type lookup
10:30:03 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
10:30:04 <mauke> sounds like you want a map
10:30:11 <kjdf> but maybe there is a completely different and better way to deal with DFAs in haskell?
10:30:26 <wli> kjdf: Easier than what?
10:30:28 <SamB> kjdf: what is the manner of the dealings you wish to have?
10:30:31 <eivuokko> SamB, Is there diffrent levels of impreciness in exceptions?
10:30:38 <mauke> M.findWithDefault x x (Map.fromList [(b,c)])
10:30:57 <wli> eivuokko: Yes.
10:31:36 <kjdf> SamB: I want to make a list transformer, producing output list by emitting small chunks on transitions
10:31:39 <dcoutts_> wli: unfortunately there are also theoretical problems with general purpose finalisers, one can't guarantee they will get called, or that the objects the finalisers reference still exist. There's a paper on it by Bohem.
10:31:46 <campusblo> ok thanks ill try to create a map for it
10:31:50 <kjdf> wli: easier/nicer than this: http://hpaste.org/1617
10:32:28 <wli> kjdf: What kind of DFA are you trying to build?
10:32:33 <kjdf> "wait 2 = [1, 1] -=> down; wait x = [x] -=> wait; down 2 = [4] -=> wait; down x = [x] -=> down"
10:32:52 <kjdf> this is the "user interface" so i want to make it as nice as possible
10:33:16 <kjdf> I don't know exactly what kind.. what are the options? :)
10:34:12 <kjdf> two thinks I don't like about the current version:
10:34:21 <eivuokko> wli, I can only find imprecise exceptions in haskell, and low-level hw stuff.
10:34:32 <eivuokko> wli, I don
10:34:37 <kjdf> 1) wait x = [x] -=> wait
10:34:44 <wli> kjdf: I'm not entirely sure what you're trying to do.
10:34:52 <edwardk> there isn't any sort of set of builtins to transform (a,b) -> (f a,f b)   (a,b,c) -> (f a, f b, f c), etc. is there for a given hrmm, i guess it would be monad because of the use of return, f, would there?
10:34:59 <edwardk> er is there
10:35:09 <kjdf> state transition should always produce input symbol if not stated otherwise
10:35:27 <kjdf> 2) it is not really composable, as for example regexps would be by concatenation
10:35:33 <wli> edwardk: That's why I made a Zippable class and made functions instances of it.
10:35:46 <kjdf> wli: I want to build a keyboard input filter/transformer
10:36:08 <kjdf> wli: that would translate some sequences of keystrokes to others
10:36:21 <wli> kjdf: So you basically want regex -like substitutions?
10:36:31 <kjdf> wli: and it would be configurable by the above
10:36:37 <jethr0> edwardk: afaik, you can't do anything generically with the elements of an n-tuple in pure haskell
10:36:54 <kjdf> wli: maybe, I am not 100% sure...
10:37:05 <jethr0> edwardk: if i remember correctly template haskell could do something with tuples
10:37:05 <edwardk> jethr0: i realize, but in general the different k-tuples wind up getting implemented the hard way up to a certain arity for a lot of builtins
10:37:06 <kjdf> wli: I think so.
10:37:24 <wli> kjdf: Well-explored algorithmic territory if so.
10:37:42 <edwardk> jethr0: yeah you can do pretty much anything you want in TH, i just try to avoid turning to it until i have no other options
10:37:59 <kjdf> wli: yes, but what I am after, is how to nicely express the 'regexp' building part in haskell
10:38:07 <wli> kjdf: I'm betting your concern is mostly with programming interface, where I don't have any good ideas.
10:38:20 <campusblo> ack
10:38:22 <jethr0> edwardk: maybe you can do something with the "scrap your boilerplate" stuff, but i'm not so sure with tuples
10:38:46 <edwardk> i think to use return polymorphically across the different types in the tuple i'd have to build a special class for it rather than use a generic Zippable.
10:38:48 <campusblo> for my function on tuples
10:38:53 <SamB> eivuokko: I'm not seeing any exceptions that imprecise in "A semantics for imprecise exceptions"
10:39:14 <campusblo> i have to check a list and replace a letter 
10:39:24 <campusblo> to create a code
10:39:34 <jethr0> edwardk: hmm
10:39:36 <wli> class Zippable f where fzip :: f a -> f b -> f (a,b)
10:40:39 <jethr0> campusblo: could you give an example?
10:41:47 <SamB> heh. they have a Nontermination constructor for the Exception datatype in this operational semantics!
10:41:55 <SamB> er. NonTermination
10:42:27 <eivuokko> SamB, Eh?  How can readFile throw on error on errors that happen in middle of file?
10:42:48 <eivuokko> Isn't that imprecise exception?
10:43:10 <shapr> Is that like Traversable?
10:43:38 <rpaulo> hi
10:43:44 <edwardk> i need given class Return m a where { return :: a -> m a }; something that will take (a,b) -> (m a, m b),     (a,b,c) -> (m a, m b, m c) , ah damn, can't do it in general because you'd have to pass it a variable number of dictionaries
10:43:45 <SamB> it would return an exceptional value instead of more data (that is, instead of a tail of the [Char])
10:44:10 <wli> instance Zippable ((->) a) where fzip f g = \x -> (f x, g x)
10:44:20 <rpaulo> I'm looking for an example on how to remove repetions on a ordered list
10:44:21 <sjanssen> SamB: yeah, catch x (\e -> case e of NonTerminationException -> ...) solves the halting problem
10:44:29 <edwardk> wli: different problem =/
10:44:40 <SamB> sjanssen: well, in this semantics it says...
10:44:56 <edwardk> if i just had to work with Monad it'd probably be solvable
10:45:15 <shapr> edwardk: Require SYB?
10:45:21 <SamB> getException (Bad s) -> getException (Bad s) if NonTermination âˆˆ s
10:45:22 <jethr0> rpaulo: "nub"
10:45:28 <edwardk> shae: blech
10:45:28 <jethr0> > nub [1,1,3,4,5,5]
10:45:29 <lambdabot>  [1,3,4,5]
10:46:11 <mauke> > map head . group $ [1,1,3,4,5,5]
10:46:12 <lambdabot>  [1,3,4,5]
10:46:45 <SamB> note that "Bad" was in italics
10:47:07 <mauke> where?
10:47:35 <SamB> in "A semantics for imprecise exceptions"
10:48:26 <rpaulo> jethr0: I think nub is not ok for ordered lists. I've been doing pattern matching like (x:y:xs) and then comparing x with y, but that doesn't work
10:48:43 <mauke> rpaulo: why is it not ok?
10:48:49 <edwardk> class Monad m => LiftM m a b | a -> b, b -> a where { mreturn :: a -> b }; instance Monad m => LiftM m (a,b) (m a, m b) where { mreturn (a,b) = (return a, return b); } ... works as long as i'm unrestricted.
10:49:31 <rpaulo> I'm looking at the Hugs source for nub and it calls the elem function and that traverses the list again
10:49:44 <rpaulo> if the list is ordered, you should be only need to traverse it once
10:49:49 <mauke> rpaulo: then use my solution
10:50:08 <sjanssen> rpaulo: "that doesn't work"?
10:50:30 <sjanssen> rpaulo: pattern matching two at a times sounds right, perhaps you missed some detail?
10:52:00 <jethr0> > let {f(x:y:xs) = if x==y then y:f xs else x:f (y:xs); f xs = xs} in f [1,1,3,4,5,5]
10:52:02 <lambdabot>  [1,3,4,5]
10:53:02 <mauke> > let {f(x:y:xs) = if x==y then y:f xs else x:f (y:xs); f xs = xs} in f [1,1,1,1,2,2,2,3,3,4]
10:53:04 <lambdabot>  [1,1,2,2,3,4]
10:53:09 <mauke> fail
10:53:18 <jethr0> i lost
10:53:34 <rpaulo> right
10:53:37 <rpaulo> that's the problem I'm having
10:53:41 <jethr0> ah, i see my error ;). should do some more testing
10:53:57 <jethr0> > let {f(x:y:xs) = if x==y then f (y:xs) else x:f (y:xs); f xs = xs} in f [1,1,1,1,3,4,5,5]
10:53:59 <lambdabot>  [1,3,4,5]
10:54:22 <mauke> > let f (x : xs@(y : _)) | x == y = f xs | otherwise = x : f xs; f xs = xs in f [1,1,1,1,2,2,2,3,3,4]
10:54:23 <lambdabot>  [1,2,3,4]
10:54:30 <jethr0> but the group version seems nice anyways
10:54:41 <jethr0> nicer
10:56:47 <rpaulo> hmmm thanks
10:57:26 <intergalacti> hi i haqve some code and i cant quite figure out what is wrong with it
10:57:37 <intergalacti> its about 5 lines
10:57:38 <jethr0> @paste
10:57:38 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:58:05 <intergalacti> @paste replace :: Char -> [(Char,Char)] -> Char
10:58:05 <intergalacti> replace x [y:ys ]
10:58:05 <intergalacti>         | x == b = c
10:58:05 <intergalacti>         | otherwise replace x ys
10:58:05 <intergalacti>         
10:58:05 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:58:06 <intergalacti>         where y = (b,c)
10:58:34 <Cale> er, he meant to use the url that the bot gave you, but that's okay
10:58:38 <jethr0> intergalacti: what should be the return type of the function?
10:58:54 <intergalacti> i realized that after i pasted
10:58:59 <Cale> probably the problem is that [y:ys] is a list consisting of a single element which is a list starting with y and the rest ys.
10:58:59 <jethr0> k, just saw the first line
10:59:03 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1618
10:59:57 <Cale> also, y = (b,c) won't work, because b and c are not in scope
11:00:03 <Cale> You probably meant (b,c) = y
11:00:15 <hpaste>  jethr0 annotated "(no title)" with "(no title)" at http://hpaste.org/1618#a1
11:00:20 <Nucleo_2> Can someone explain why fibs = 0 : 1 : zipWith (+) fibs (tail fibs)    is so much faster than fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2)  ?
11:00:30 <Cale> (bindings are still directed, even if the equations they specify are true either way)
11:00:43 <Nucleo_2> I thought both versions would have all previously computed n's memoized?
11:00:45 <jethr0> intergalacti: what should the function return if no replacement applies?
11:00:48 <Cale> Nucleo_: because the latter has to do exponentially many calls
11:00:50 <mauke> Nucleo_2: fib is a function. fibs is a list.
11:01:04 <shapr> Cale: Speaking of things to change in Haskell ... my girlfriend wants length to length :: [a] -> Integer and she wants an error on Int overflow :-)
11:01:05 <Nucleo_2> mauke: yeah, I left out the fib n = fibs !! n
11:01:09 <Cale> Nucleo_: Haskell doesn't memoise.
11:01:22 <Cale> shapr: yes, move Int into a library
11:01:31 <Nucleo_2> Cale: I thought given that functions had no side effects, f(n) gets evaled once for a given n, period?
11:01:32 <Cale> shapr: It doesn't need to be in the Prelude at all.
11:01:34 <intergalacti> jethr0 you understand what im trying to do?
11:01:34 <jethr0> Nucleo_2: the first one memoizes (because it's a list), and the second doesn't, IMO
11:01:43 <ndm> or remove Int in favour of Nat, where data Nat = Succ Nat | Zero
11:01:49 <mauke> Nucleo_2: well, that's not what happens
11:01:52 <Nucleo_2> Cale: or is a given value of n being repeatedly computed in the second version?
11:01:57 <Cale> We should have length :: (Num b) => [a] -> b
11:01:58 <SamB> hmm, what's a good name for a generalization of Parsec?
11:02:10 <Nucleo_2> mauke: can you elaborate?
11:02:12 <ndm> everyone wants peano numbers in the type system, and unboxed registers which overflow at the value level
11:02:14 <Cale> Nucleo_: no, that would cost too much memory in general
11:02:17 <ndm> i don't understand why...
11:02:18 <jethr0> intergalacti: kinda, but you need to define a "replace _ [] = ..." case
11:02:21 <mauke> Nucleo_2: functions aren't memoized
11:02:24 <Nucleo_2> I see.
11:02:25 <SamB> I've thought of "Parsecs"
11:02:26 <Cale> Nucleo_: as you'd never know when it was okay to throw something away
11:02:30 <Nucleo_2> Ah
11:02:39 <EvilTerran> nucleo_2, if you want that one memoized, you need "fib n = fibs!!(n-1) + fibs!!(n-2); fibs = 0 : 1 : map fib [2..]
11:02:41 <intergalacti> ok i will
11:02:44 <ndm> SamB, please, not that - the plural/not thing will get very confusing quickly
11:02:50 <roconnor_> @type genericLength
11:02:58 <lambdabot> forall b i. (Num i) => [b] -> i
11:02:59 <SamB> ndm: okay. so what should I call it?
11:03:01 <Nucleo_2> I keep writing similar functions in the second way, given that's how they're usually presented for things like this...
11:03:06 <EvilTerran> (or something similar)
11:03:10 <Cale> roconnor_: exactly
11:03:10 <Nucleo_2> and I need to learn how to write them when possible with lists, I guess.
11:03:18 <Nucleo_2> and the execution speed is just murder, currently.
11:03:47 <EvilTerran> > let fibs = 0:1:[fibs !! (n-1) + fibs !! (n-2) | n <- [2..]] in fibs
11:03:49 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
11:04:02 <ndm> SamB, kiloparsec, parmin
11:04:07 <Cale> EvilTerran: that's still going to be much slower than the zipWith version
11:04:23 <Cale> though possibly faster than the doubly recursive one
11:04:25 <cdsmith> SamB: Parmins?
11:04:28 <EvilTerran> nucleo_2, that's the functions version transliterated into lists. as cale says, it's still slower, but O(n^2) instead of O(e^n), i think
11:04:33 <cdsmith> oops, ndm beat me
11:04:39 <Nucleo_2> EvilTerran: ahh, thank you.
11:04:45 <ndm> cdsmith: was you benchmark blog post aimed at me?
11:04:46 <roconnor_> newtype Nat = Nat [()]
11:04:50 <intergalacti> jethro here is the error ERROR file:.\replace.hs:5 - Syntax error in declaration (unexpected `}', possibly due to bad layout)
11:04:58 <cdsmith> ndm: no, not at all!  Something unrelated at work
11:05:10 <Nucleo_2> forgive me for being dim: is there a general process I should be following for factoring functions defined via tail recursion (a la fibonacci, the triangle numbers, etc.) into something with lists and zipWith(2,3,4,5,whatever)?
11:05:15 <ndm> cdsmith: ok :) - just thought the timing was very quickly after ;)
11:05:15 <Cale> intergalacti: you're missing an = after otherwise, but that's not the only problem
11:05:26 <cdsmith> ndm == Neil D. Mitchell?
11:05:33 <EvilTerran> nucleo_2, that one is slower than the zipWith one, however, because it has to do a linear-time lookup on the list for what was previously a recursion
11:05:40 <ndm> cdsmith: yes
11:05:44 <cdsmith> Ah
11:05:44 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/1618#a2
11:06:33 <Cale> Nucleo_: It's actually a little finer than that -- many tail recursive things can be rewritten with foldl' (that is, a strict left fold).
11:06:53 <cdsmith> ndm: sorry if I offended you.  I had no problem with your benchmarks.
11:07:08 <hpaste>  intergalacit annotated "(no title)" with "(no title)" at http://hpaste.org/1618#a3
11:07:08 <Nucleo_2> Cale: and again, I'm slow -- this probably gets rid of some of the stack overflows I've been encountering?
11:07:11 <ndm> cdsmith: nah, no worries, i didn't take any offense - just wondered if you were commenting on mine
11:07:17 <Cale> Nucleo_2: yes
11:07:19 <jethr0> intergalacti: you need a "=" behind the "otherwise"
11:07:28 <Cale> Nucleo_2: Let me demonstrate...
11:07:34 <Cale> foldr (+) 0 [1,2,3]
11:07:36 <SamB> Nucleo_: yeah. be careful to remember the ' though
11:07:37 <ndm> cdsmith: where i wasn't saying "haskell > c", or the other way round, because i know that benchmarks are always arbitrary :)
11:07:44 <jethr0> Nucleo_2: how is fibonacci tail recursive?
11:07:47 <Cale> er, let's use foldl :)
11:07:52 <Cale> foldl (+) 0 [1,2,3]
11:08:00 <Cale> = foldl (+) (0 + 1) [2,3]
11:08:06 <Cale> = foldl (+) ((0 + 1) + 2) [3]
11:08:12 <Cale> = foldl (+) (((0 + 1) + 2) + 3) []
11:08:18 <Cale> = ((0 + 1) + 2) + 3
11:08:20 <SamB> hmm, I don't think many people will understand if I use Parmin...
11:08:24 <Cale> = (1 + 2) + 3
11:08:25 <jethr0> Nucleo_2: i rephrase: the "fib(n-1) + fib(n-2)" obviously isn't
11:08:27 <Cale> = 3 + 3
11:08:28 <intergalacti> thanks jethr0 no error now. now to see if it does what i want it to do
11:08:28 <cdsmith> It was actuall a MySQL/Postgres comparison done by a consultant for us at work that sparked the post.
11:08:29 <Cale> = 6
11:08:34 <jethr0> hehe
11:08:43 <Cale> Nucleo_2: That's how it normally gets evaluated.
11:09:01 <cdsmith> SamB: I think Parmin is cool.  We'll just have to explain it to them.
11:09:11 <Cale> So you can see that although foldl is tail recursive, since the parameter doesn't get evaluated, all it does in its tight loop is build up a big expression.
11:09:19 <Nucleo_2> jethr0: true
11:09:25 <cdsmith> (We == #haskell, of course)
11:09:35 <Cale> foldl' is a variant of foldl which forces the evaluation of the second parameter at each step.
11:09:40 <mauke> > let phi = 0.5 + sqrt 1.25; fib n a = if n <= 1 then a else fib (pred n) (round $ phi * fromIntegral a) in fib 12 1
11:09:42 <lambdabot>  233
11:09:47 <Nucleo_2> Cale: whereas with foldl', it goes foldl (+) 1 [2,3]...
11:09:54 <Cale> Nucleo_2: exactly
11:09:55 <SamB> I'm not even sure I like it, since that doesn't even sound very much like "parse"
11:09:55 <mauke> jethr0: ^
11:09:56 <Nucleo_2> so the 0+1 gets evaled...
11:09:59 <Nucleo_2> I see. Thank you.
11:10:22 <Cale> It only does one step's worth of evaluation though -- just enough to determine the top-level constructor.
11:10:41 <jethr0> k, that's why i rephrased ;)
11:10:59 <Cale> Usually what you really want for performance in Haskell is foldr though
11:11:03 <cdsmith> SamB: Clearly, then, the answer is to change what you're writing so as to keep the name.  Write a parallel implementation of the Prelude minimum function.
11:11:10 <Nucleo_2> methinks I'm going to have to learn some more about analyzing the running times and space requirements of all these different versions.
11:11:11 <Cale> At least, when you're not building some atomic value.
11:11:34 <Cale> I think the most important thing is learning how to evaluate code lazily by hand
11:12:24 <Cale> The basic rule is that code is evaluated outermost-first, (leftmost-first), and when two things come from the expansion of the same function parameter, their results are shared.
11:12:34 <Cale> On that sharing point, let's look at:
11:12:38 <Cale> double x = x + x
11:12:48 <Cale> and evaluate double (double 5)
11:12:53 <SamB> cdsmith: no, I don't really think that that is as interesting as a generalized parsec
11:12:59 <Cale> in a strict language, you do it innermost-first
11:13:06 <Nucleo_2> If the function is commutative, then foldr and foldl are the same? 
11:13:20 <Cale> so it would go  double (double 5) -> double (5+5) -> double 10 -> 10 + 10 -> 20
11:13:26 <Cale> Nucleo_2: associative
11:13:38 <Nucleo_2> Cale: errr, associative -- sorry.
11:13:44 <SamB> Nucleo_: assuming a non-bottom list and infinite resources...
11:13:53 <SamB> er.
11:13:56 <Cale> That is, if f (f x y) z = f x (f y z)
11:14:06 <SamB> also none of the tails should be bottom
11:14:13 <Cale> Under outermost-first evaluation, we'd get:
11:14:17 <Cale> double (double 5)
11:14:34 <Cale> -> (double 5) + (double 5)
11:14:48 <Cale> -> (5 + 5) + (double 5)
11:14:53 <Cale> -> 10 + (double 5)
11:14:58 <Cale> -> 10 + (5 + 5)
11:15:01 <Cale> -> 10 + 10
11:15:03 <Cale> -> 20
11:15:15 <Nucleo_2> So you actually do MORE work by being lazy, in that case?
11:15:18 <Cale> Looks inefficient, since we had to duplicate the work of computing double 5
11:15:22 <Cale> But lazy evaluation does more
11:15:46 <Cale> It shares computations which came from duplicating a function parameter
11:15:52 <Cale> So then:
11:15:55 <Cale> double (double 5)
11:16:13 <Cale> -> let x = double 5 in x + x
11:16:24 <Cale> -> let x = 5 + 5 in x + x
11:16:27 <cdsmith> SamB: Just brainstorming: parcel?
11:16:27 <Cale> -> let x = 10 in x + x
11:16:31 <Cale> -> 20
11:16:51 <ricky_clarkson> Shouldn't double 5 be 10? ;)
11:17:05 <Cale> it is
11:17:08 <Nucleo_2> Cale: to clarify -- do you actually have to code those lets to get that behavior, or are you showing me what the compiler does?
11:17:17 <SamB> cdsmith: I think that sounds like it has something to do with speed or cells
11:17:22 <mauke> Nucleo_2: the latter
11:17:22 <Cale> ricky_clarkson: I'm computing double (double 5)
11:17:32 <Nucleo_2> ahh, okay
11:17:40 <mauke> Nucleo_2: the sharing is actually done with pointers and stuff
11:17:46 <Cale> This is what the compiler and runtime system do, schematically
11:18:08 <Cale> Yeah, that 'let' is actually handled by the 'x's in the expression really being pointers to the same thing
11:18:20 <Nucleo_2> I see. So double(double 5) is optimized to compute 5+5 once, in Haskell.
11:18:25 <Cale> and when that thing gets reduced, they both benefit from the work
11:18:29 <Cale> right
11:18:45 <Cale> At least, in any lazy-evaluation implementation of Haskell.
11:18:47 <Nucleo_2> I have to confess that I'm going to have to think long and hard about what this means for running time and space.
11:18:52 <Cale> which is basically all of them :)
11:19:09 <Nucleo_2> But thank you for the explanation -- much appreciated.
11:19:13 <SamB> that's rather similar to how a paper I once read gave semantics for what would really be a rather low-level language
11:20:27 <Cale> The reason that foldr is so popular in Haskell is that it immediately returns the specified function applied to some parameters, and the recursion only continues if absolutely necessary.
11:20:35 <Cale> foldr f z [] = z
11:20:44 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
11:21:01 <Cale> In some sense, foldr 'finishes' in constant time.
11:21:15 <sioraiocht> @hoogle liftIO
11:21:16 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
11:21:17 <Cale> But might continue if f really needs its second parameter.
11:21:44 <sioraiocht> for real? I have to import if from THERE?
11:21:51 <Cale> > take 5 (foldr (:) [] [1..])
11:21:53 <lambdabot>  [1,2,3,4,5]
11:22:03 <monochrom> If f is non-strict in its second argument, foldr f is very nice.
11:22:17 <Cale> sioraiocht: If you import any of the mtl libraries, you're likely importing Trans already.
11:22:34 <sioraiocht> okies
11:22:41 <cdsmith> Sam: counterparse, megaparsec, parsables, parsabola, parley, parsimony, parsley; that's all I've got for "parse" puns, I'm afraid.
11:22:58 <SamB> oooh!
11:23:00 <SamB> I like parsely
11:23:08 <SamB> parse-ly
11:23:29 <pjd> parsely
11:23:30 <pjd> is gharsely
11:23:34 <pjd> </ogden>
11:25:06 <monochrom> Parsec is a parsely monad. :)
11:28:02 <Syzygy-> Now we need a paisley logotype for parsec
11:31:46 <SamB> now do I have to name my main typeclass Parsely instead of MonadParser?
11:32:45 <shapr> I want ParsecT !
11:33:05 <rpaulo> is there any way to do something like readLn::Int ?
11:33:17 <cdsmith> SamB: Err, I'd be in favor of just Parser, and let the import say which library is used.
11:33:18 <shapr> rpaulo: Yeah, mix readLn and read
11:33:26 <shapr> > read "5" :: Int
11:33:31 <cdsmith> rpaulo: (read . readLn) :: Int
11:33:34 <lambdabot>  5
11:33:35 <Syzygy-> :t readLn
11:33:37 <lambdabot> forall a. (Read a) => IO a
11:33:42 <SamB> cdsmith: I'm making *typeclasses* for parsing
11:33:44 <rpaulo> thanks1
11:33:51 <shapr> :!ls
11:33:59 <wli> SamB: Logic programming at the level of types?
11:34:01 <shapr> aww
11:34:10 <SamB> wli: not at the type level you smartass
11:34:21 <cdsmith> SamB: Oh!  Ignore me, then.
11:34:24 <wli> SamB: Why not?
11:34:24 <Syzygy-> What does readLn do anyway?
11:34:28 <shapr> SamB: Hasn't Oleg already done that?
11:34:32 <SamB> shapr: has he?
11:34:35 <shapr> I thought so...
11:34:46 <SamB> normal parsing?
11:34:46 <wli> PTTP semantics AIUI.
11:34:48 <SamB> with values?
11:34:53 <shapr> Yeah, with values.
11:35:05 <wli> I thought just a PTTP semantics logic monad.
11:35:37 <shapr> Of course, that's part of why Oleg gets the regular complaint "You solve problems with the type system by lifting them out to an untyped system of typeclasses."
11:35:52 <rpaulo> hmmm
11:35:57 <shapr> On the good side, when your program is done compiling, you have the solution =)
11:37:11 <rpaulo> that doesn't seam to work
11:37:14 <rpaulo> seem
11:37:35 <rpaulo> readNum :: Int
11:37:35 <cdsmith> rpaulo: I think we misunderstood your problem.   You can do readLn :: IO Int
11:37:36 <rpaulo> readNum = (read . readLn) :: Int
11:37:44 <cdsmith> or (unsafePerformIO readLn) :: Int
11:37:46 <Excedrin> do UArray accesses require bounds checking?
11:37:51 <fasta> Maybe I am using the module system wrongly, but I find it hugely annoying when I import Control.Monad.Trans and Control.Monad.State that I need to hide "when" multiple times, even though they all point to the same function.
11:37:57 <SamB> shapr: I see binary, ConfigFile, parsec, and polyparse
11:38:10 <mauke> fasta: hmm. you shouldn't have to
11:38:30 <fasta> mauke: I don't?
11:38:42 <mauke> :m + Control.Monad.State Control.Monad.Trans
11:38:58 <mauke> *Main Control.Monad.Trans Control.Monad.State> :t when
11:38:58 <mauke> when :: (Monad m) => Bool -> m () -> m ()
11:39:05 <mauke> works in ghci, at least
11:39:30 <fasta> mauke: ok, I was wrong, I meant Control.Monad.ST and Control.Monad.State
11:39:40 <fasta> mauke: I just assumed Trans also exported when.
11:39:45 <fasta> mauke: which was wrong
11:39:58 <mauke> still works in ghci
11:39:58 <cdsmith> fasta: still works for me
11:40:05 <fasta> mauke: the situation is that I wrote my own "when" function. 
11:40:10 <mauke> oh
11:40:15 <fasta> mauke: so, both need to be hidden. 
11:40:32 <mauke> why did you write your own "when"?
11:40:39 <fasta> mauke: but since they point to the same function I find that a premature optimization.
11:41:00 <fasta> mauke: because mine works for both "Bool" and "m Bool"
11:42:08 <mauke> whenM c x = c >>= flip when x
11:42:42 <fasta> mauke: The idea is to get rid of the M in whenM...
11:42:54 <mauke> how is that useful?
11:43:20 <fasta> mauke: suppose I decide to change the conditional from a monadic value of a non-monadic value.
11:43:35 <fasta> mauke: in your case I need to think about changing the name of when too.
11:43:45 <fasta> mauke: in my case, there is no such step necessary
11:43:45 <mauke> right
11:43:55 <mauke> I think that's a good thing :-)
11:44:13 <fasta> Oh, then we agree to disagree .
11:47:39 <SamB> fasta: I dunno. some of us can be awfully stubborn.
11:48:22 <fasta> SamB: you mauke doesn't agree with either side?
11:48:27 <fasta> mean*
11:48:59 <fasta> (I parsed it as a subtle joke)
11:49:01 <SamB> I meant maybe he won't agree to disagree!
11:49:08 <fasta> SamB: right
11:49:16 <fasta> SamB: then I understood correctly.
11:50:44 <SamB> hmm, what should I call the module in which my classes reside?
11:50:57 <SamB> Text.ParserCombinators.Parsely.Base?
11:51:00 <monochrom> X.Y.Class
11:51:10 <SamB> .Class, you say?
11:51:17 <monochrom> Example: Control.Monad.Cont.Class
11:53:46 <SamB> should I actually call the baseclass Parsely?
11:53:58 <monochrom> I don't know.
11:54:14 <SamB> my other idea was MonadParser
11:54:22 <fasta> SamB: NOO!!!!!                                        .. don't care ;)
11:54:27 <monochrom> I wonder if people will make jokes about parsley :)
11:54:40 <fasta> monochrom: does that matter?
11:54:49 <monochrom> I don't know.
11:54:50 <SamB> it would be a nice plus
11:54:57 <fasta> Free marketing
11:55:03 <fasta> er publicity*
11:56:12 <SamB> fasta: so what is this "noo" about?
11:56:20 <SamB> you think I should have
11:56:42 <fasta> SamB: ? Didn't you read what comes after it?
11:56:45 <SamB> class Monad m => Parsely m where ...
11:56:49 <SamB> fasta: well yes
11:56:54 <fasta> SamB: I don't even know what this Parsely is. 
11:57:11 <monochrom> MonadParsely
11:57:12 <fasta> SamB: other then it being a parser and one that happens to be a monad. 
11:57:37 <SamB> fasta: actually it isn't so much a parser as a parser framework
11:58:16 * shapr throws evil lambdas
11:58:21 <fasta> SamB: by frame work you mean concretely that it is a set of interfaces?
11:58:28 <SamB> fasta: yeah, that
11:58:38 <SamB> I'll probably throw in some parsers too though
11:59:50 <fasta> SamB: Parsely seems nice, but the name is less important than the actual bits :)
12:00:18 <fasta> SamB: "WTF" would be a nice name too :)
12:00:43 <monochrom> Warm Thing Fuzzy?
12:00:53 <SamB> actually that's a subclass of MonadPlus...
12:01:15 <fasta> What The F*ck, in that it provides structure to some input. 
12:01:58 <fasta> monochrom: but leaving it undefined like GAIM is an option too. 
12:02:19 <monochrom> Sadly GAIM is no more. Renamed Pidgin.
12:02:39 <fasta> monochrom: I know
12:03:06 <fasta> Did they officially trademark it now? 
12:03:15 <fasta> I mean "Pidgin".
12:04:04 <Nucleo_2> Is Yi the preferred editor under OS X?
12:04:14 <SamB> Nucleo: well, what do you prefer?
12:04:26 <Nucleo> SamB: well, it's currently nano, so anything is better.
12:04:37 <monochrom> fasta: dunno.
12:04:51 <SamB> I personally use emacs here under X
12:05:05 <SamB> X as in X11
12:05:23 <_Nucleo> SamB: and the syntax highlighting isn't broken?
12:05:36 <SamB> maybe a little bit!
12:05:46 <fasta> _Nucleo: Yi's user-base can probably be counted on one hand. 
12:05:47 <SamB> hmm. too much bang to it...
12:05:57 <_Nucleo> I wasn't sure if Yi was dominant to the extent that say, Eclipse is dominant for Java...
12:06:10 <_Nucleo> fasta: any recommendations? I'm willing to learn a new environment.
12:06:36 <SamB> _Nucleo: which environments do you know?
12:06:46 <fasta> _Nucleo: I use Emacs, but it's not perfect. 
12:06:56 <fasta> _Nucleo: It's the best I found, though. 
12:07:04 <fasta> _Nucleo: Some other people use VIM.
12:07:06 <_Nucleo> SamB: last time I did any serious coding was with Ultraedit under windows.
12:07:11 <fasta> _Nucleo: some use gedit
12:07:17 <_Nucleo> vim works for me.
12:07:22 <monochrom> Does MacOS come with a GUI editor?
12:07:33 <_Nucleo> I guess the main question is how good the syntax highlighting is for each of these
12:07:35 <SamB> do we have a page with a list of editors that have reasonable haskell syntax support?
12:07:58 <SamB> @wiki editor wars
12:07:59 <lambdabot> http://www.haskell.org/haskellwiki/editor_wars
12:10:05 <monochrom> http://www.haskell.org/haskellwiki/Editors
12:10:06 <lambdabot> Title: Editors - HaskellWiki
12:10:57 <monochrom> Generally http://www.haskell.org/haskellwiki/Category:Tools
12:10:58 <lambdabot> Title: Category:Tools - HaskellWiki
12:10:59 <fasta> _Nucleo: syntax high-lighting is not that important in Haskell
12:11:23 <fasta> _Nucleo: still, I think both Emacs and VIM are about the same in that area.
12:11:59 <fasta> I would like to search on the AST of source code.
12:12:10 <fasta> E.g. find <foo> in comments
12:12:16 <fasta> Or find <bar> not in comments
12:12:42 <mauke> comments? people still use those?
12:12:45 <fasta> A tiny bit of the AST, though, but there will probably be other uses. 
12:12:59 <_Nucleo> that would be really nice, come to think.
12:13:00 <fasta> mauke: people that open-source code, do not. 
12:13:12 <fasta> mauke: or they make wrong comments.
12:14:57 <shapr> Is there some way to get a make command to go up directories till it finds a Makefile to use?
12:15:51 <Heffalump> using shell around the make command is presumably not acceptable?
12:16:12 <shapr> Fine by me...
12:17:12 <mauke> ( while ! test -e Makefile; do cd ..; done; make )  # obviously buggy
12:21:19 <Heffalump> right, I was thinking that was so obvious you must have ruled it out by now :-)
12:24:20 <pitecus> Anyone know why this happens after I installed utf8-string:
12:24:23 <pitecus> Prelude> :m +System.IO.UTF8
12:24:23 <pitecus> module main:System.IO.UTF8 is not loaded
12:24:43 <monochrom> try it in another directory
12:24:50 <Saizan> have you restarted ghci?
12:26:29 <monochrom> No one is called Yes? :)
12:27:11 <mauke> in TimeLocale, what is intervals for?
12:27:15 <pitecus> Saizan, I have restarted it
12:27:50 <pitecus> monochrom, that worked
12:27:57 <pitecus> monochrom, but i dont get why?
12:28:02 <jethr0> @source forM
12:28:02 <lambdabot> forM not available
12:28:31 <monochrom> If both the package database and the current directory has module X, ghci gets confused.
12:28:44 <pitecus> silly
12:29:08 <monochrom> It's a funny corner case. :)
12:30:43 <jethr0> corner case? i'd call that a bug or an oversight in the specs
12:31:04 <wolverian> hardly a corner case. it's a regular situation in e.g. perl, that you want to override some modules with local ones 
12:31:13 <wolverian> well, okay, not _regular_, but it does happen.
12:32:05 <monochrom> echo "module Prelude where whee x = x" > Prelude.hs
12:32:10 <monochrom> ghc -c Prelude.hs
12:32:16 <monochrom> That is fun. :)
12:48:42 <hpaste>  Paczesiowa pasted "(no title)" at http://hpaste.org/1619
12:57:20 <etnt> gee...I think my brain is starting to melt...help!
12:58:01 <etnt> I have a Parsec lexer, :t lexer   gives me
12:58:13 <etnt> lexer :: GenParser Char st [Token]
12:58:22 <etnt> what does this mean really ?
12:58:44 <etnt> what is lexer ?
12:59:06 <shapr> etnt: http://en.wikipedia.org/wiki/Lexer
12:59:09 <lambdabot> Title: Lexical analysis - Wikipedia, the free encyclopedia
12:59:34 <etnt> I read lots and lots, still dont get it...
12:59:57 <Saizan> encryptio: GenParser Char st [Token]
13:00:21 <etnt> I know what a Lexer is btw, but what is this 'object' ?
13:00:39 <etnt> how do a 'drive' it
13:00:47 <shapr> etnt: It turns a string into a list of tokens.
13:00:52 <shapr> You drive it with a runParser command.
13:01:12 <etnt> how do you know it wants a string ?
13:01:27 <shapr> Because GenParser is a type synonym.
13:01:28 <Saizan> because the first parameter is Char
13:02:01 <Saizan> shapr: type Parser a = GenParser Char () a
13:02:04 <etnt> hm...but char is not a string , shuold be [Char] ?
13:02:12 <shapr> Saizan: oh, whoops
13:02:49 <Saizan> etnt: type String = [Char], but in the GenParser type only the type of the elements is shown
13:03:16 <etnt> hm...
13:03:34 <shapr> etnt: Chalmers?
13:03:45 <etnt> nope
13:03:46 <Saizan> runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a <-- see, it takes a GenParser on tok, but wants [tok] to run it
13:03:52 <shapr> etnt: synap.se?
13:04:33 <etnt> nope 
13:05:12 <shapr> etnt: gu.se?
13:06:35 <shapr> etnt: Ok, I give up, how'd you get into Haskell?
13:06:43 <etnt> shapr: heh I finished UU some 17 years ago,..
13:06:50 <shapr> uu.nl?
13:06:58 <etnt> Uppsala
13:06:59 <shapr> ah
13:07:16 <shapr> Ok, then I'm guessing you got into Haskell via The Pragmatic Programmer?
13:07:47 <etnt> been an Erlang programmer for too long I guess, decided it was time to freshen up ye'ol brain (too late it seems...)
13:08:22 <jethr0> can anybody help me with "StateT Int [] Int", i.e. StateT on List monad? i'm having trouble to even get a minimal example to run ;(
13:08:34 <david48> Good evening Haskellers.
13:08:42 <etnt> shapr: do you know anyone at synap.se ?
13:08:49 <david48> If there's anyone with experience in Gtk2Hs, I have a question to ask.
13:09:02 <dcoutts> david48: shoot
13:09:03 <cdsmith> david48: evening.  I have played with it a little
13:09:11 <shapr> etnt: I know Luke Gorrie.
13:09:41 <etnt> nice, I know him too (I sort of employed him once)
13:10:02 <shapr> sort of?
13:10:21 <mauke> > runStateT (return 42) ()
13:10:22 <lambdabot>   add an instance declaration for (Show (m (t, ())))
13:10:32 <shapr> Luke is a cool guy, och han Ã¤r ocksÃ¥ Svensk nu!
13:10:39 <etnt> well, I lived in Melbourne at the time, he applied for a jub in Stockholm, so we met for some screening
13:10:41 <mauke> > evalStateT (return 42) () :: [Int]
13:10:42 <lambdabot>  [42]
13:10:53 <etnt> he got the job :-)
13:11:00 <mauke> jethr0: ^ very minimal :-)
13:11:01 <david48> I made a little program, the beginning is at http://hpaste.org/1620. When I click on a button, it reads files, converts them and writes them. But during all the process, it's supposed to update a status bar as well as add lines in a textview. But all the updates happen at once, when all is done.
13:11:12 <shapr> Oh, that's how he got from .au to .se? I never did hear exactly how that happened.
13:11:33 <david48> dcoutt: it's the same program I asked you some questions about, the other day :)
13:11:48 <david48> by the way, sorry that the comments are in French
13:11:49 <etnt> yes, he started to get involved in Erlang and from there it went
13:11:53 <jethr0> mauke: i want to do StateT with backtracking in the list monad...
13:12:22 <david48> The function that shows the problem is called "traitement".
13:12:43 <ricky_clarkson> So Erlang makes your summers colder?
13:13:18 <mauke> > runStateT (do x <- [1,2,3]; update succ; return x) 100 :: [(Int,Int)]
13:13:19 <lambdabot>   Not in scope: `update'
13:13:30 <mauke> > runStateT (do x <- [1,2,3]; modify succ; return x) 100 :: [(Int,Int)]
13:13:30 <lambdabot>  Couldn't match expected type `StateT Int [] t'
13:13:48 <etnt> ricky_clarkson: thats why I started to play with Haskell, to get warm (burnt out I think...)
13:13:53 <david48> cdsmith: good evening :)
13:13:57 <ricky_clarkson> I see.
13:14:07 <ricky_clarkson> So what language is based in the Carribean?
13:14:30 <shapr> Jamaican?
13:15:12 <mauke> > runStateT (do x <- lift [1,2,3]; modify succ; guard (odd x); return x) 100 :: [(Int,Int)]
13:15:13 <lambdabot>  [(1,101),(3,101)]
13:15:16 <ricky_clarkson> Afaik, Jamaicans speak English, or a version thereof, mon.
13:15:54 <ricky_clarkson> shapr: Are you ever unicycling around Manchester?
13:16:04 <ricky_clarkson> Every time I see a unicyclist I wonder.
13:16:10 <mauke> jethr0: so each world has its own state
13:16:33 <shapr> ricky_clarkson: My only unicycling time in the UK was AngloHaskell 2006 in Cambridge.
13:16:49 <shapr> ricky_clarkson: But if you visit the other Birmingham, you can see me all the time.
13:16:54 <jethr0> mauke: so, the lift lifts the list into the state monad?
13:16:58 <ricky_clarkson> AL?
13:17:03 <shapr> ricky_clarkson: yeah, that one.
13:17:29 <mauke> jethr0: yes
13:17:42 <Toxaris> is it possible to invite lambdabot to join a temporary channel?
13:17:53 <jethr0> hmm, for some reason i'm having unreasonable difficulties with this. thx for the example though
13:18:15 <shapr> ricky_clarkson: But if all works as planned, I'll be unicycling (permanently) in Stockholm again in spring 2008.
13:18:27 <david48> dcoutts, cdsmith : the full source is about 8k, it was truncated by hpaste. Tell me if you need to see the rest.
13:18:40 <mnislaih> @time timbod
13:18:40 <lambdabot> Local time for timbod is 2007-07-12 06:18:05 +1000
13:19:30 <mnislaih> how can we invite lambdabot to our private party ?
13:19:31 <jethr0> mauke: what type does the "do ..." have in your example? "StateT Int [] Int"?
13:19:51 <mauke> yeah
13:19:57 <shapr> mnislaih: Where's the party?
13:20:29 <mnislaih> we're warming up for the ICFP contest shapr 
13:20:42 <mnislaih> Team Thunk @ #thunks
13:20:43 <mauke> the fully general type is probably something like (Enum a, Integral b) => StateT a [] b
13:20:47 <shapr> @join #thunks
13:21:17 <mnislaih> thx shapr !
13:21:20 <shapr> mnislaih: You may prefer to run your own lambdabot and point the darcs repo change announce plugin at your darcs repository.
13:21:33 <mnislaih> shapr: sounds cool, will do :)
13:24:42 <shapr> etnt: Har du mer frÃ¥gor?
13:25:21 <etnt> shapr: jag fÃ¶rsÃ¶ker koppla ihop en lexer med en parser
13:25:46 <olsner> hehe, fler svenskar!
13:25:52 <augusts> massor
13:26:00 <etnt> kul :-)
13:26:29 <shapr> And some utlÃ¤nningar who speak Swedish...
13:26:31 <david48> dcoutts: should I post it on the Gtk2Hs list ? I subscribed on your advice.
13:26:31 <etnt> darcs get http://www.tornkvist.org/etnt
13:26:43 <Syzygy-> Och mÃ¥nga svenskar!
13:26:58 <etnt> Parser.hs should use lexer in Lexer2.hs
13:27:02 * Syzygy- seriously wonders at times whether there are more swedes than non-swedes in here.
13:27:11 <olsner> @users
13:27:12 <lambdabot> Maximum users seen in #haskell: 355, currently: 340 (95.8%), active: 16 (4.7%)
13:27:17 <shapr> I think Swedes are just more flagrant...
13:27:34 * shapr has a Swede right here sitting on the couch with him...
13:27:35 <olsner> swedes account for almost half of the active users, apparently
13:27:40 <dcoutts> david48: so the problem is that when your traitement function is running, the GUI is not
13:28:15 <shapr> etnt: Will you be at Commercial Users of Functional Programming 2007 in Freiburg?
13:28:18 <david48> right. I tried to look for a funtion that's let the gui refresh, but I couldn't find ( am probably dumb Ã 
13:28:39 <david48> that lets even. My english sucks tonight :(
13:28:46 <etnt> shapr: not sure, perhaps, would be fun meeting some Haskell nerds
13:29:09 <shapr> Hey, I have a girlfriend, I'm not a nerd!
13:29:45 <etnt> shapr: so what are you doing on this channel at this time :-)
13:29:52 <Syzygy-> shapr: I take ofense with that. I am at the very least a geek, and I'm about to marry!
13:30:00 <Syzygy-> *offense
13:30:04 <Syzygy-> Gah!
13:30:12 <Syzygy-> I really need to poke my ISP about this.
13:30:29 <shapr> Well, geek is just another good name for hacker in my opinion, but nerd implies a lack of social skills.
13:30:32 <david48> dcoutts: a precision : I don't mind the GUI not being responsive ( that's normal since when traitement runs, the events aren't being processed) , but I'd like the display to update.
13:30:32 <Heffalump> shapr: is there a program yet?
13:30:44 <shapr> Heffalump: Nah, it's in progress.
13:31:09 <Syzygy-> I have several-seconds lag on an ssh-link outside the network. :-/
13:31:10 <Syzygy-> sha	Well, ok. So it boils down tho the precise definitions - fair cop.
13:31:15 <shapr> Heffalump: It's too bad it's only one day. There were so many *awesome* submissions!
13:31:32 <Heffalump> btw, the cufp.galois.com website has a link to an "FP consortium" page that is password-protected, but without any indiciation of this before you follow the link
13:31:32 <dcoutts> david48: so if it takes a long time to run then the GUI will appear to block, all the GUI updates happen when the GUI gets a chance to run, which is when your code finishes
13:31:56 * Syzygy- sulks. I would have wanted to go to Freiburg. :-(
13:32:00 <Heffalump> that's good, I was worried that all the commercial FP users would have given their talks by now.
13:32:24 <david48> dcoutts: yes. is there a way around it ? like calling a function that would let Gtk update ?
13:34:16 <shapr> Heffalump: I dunno about that.
13:34:21 <shapr> Syzygy-: I won't be there either :-(
13:34:49 <dcoutts> david48: right, that'd work (though beware that if you make the gui responsive again, the user could press the button again - while the earlier one is still running)
13:35:21 <wli> kaol: Debug space leaks.
13:35:29 <dcoutts> david48: or you can use threads, or you can break your long running bit of work up into smaller bits and let the gui run in-between
13:36:17 <dcoutts> david48: the easiest is to explicitly yield to the gui, or to do your long running task in a thread
13:36:47 <dcoutts> david48: but note the issues with using threads and GUIs: http://haskell.org/gtk2hs/archives/2005/07/24/writing-multi-threaded-guis/
13:36:50 <lambdabot> Title: Gtk2Hs » Blog Archive » Writing multi-threaded GUIs, http://tinyurl.com/gt648
13:37:11 <david48> dcoutts: yieling to the gui involves using mainIteration ?
13:37:52 <dcoutts> david48: right, or probably mainIterationDo in a loop, so it can process events until there are no more pending
13:38:09 <Pupeno> Do you think it would be possible to use Parsec to parse *binary* data?
13:38:53 <dcoutts> Pupeno: yeah, though it's not really designed for that
13:39:05 <david48> dcoutts: I'll try both approachs. thanks for the heads up. (again) !
13:39:30 <dcoutts> Pupeno: you could just use Word8 as your token type
13:39:34 <dcoutts> david48: np
13:41:07 <dcoutts> david48: the threads approach is definitely more modular in the end, but the yield is probably easier to get working quickly. Understanding GUIs and threads takes a little thinking.
13:41:40 <david48> dcoutts: .... and probably more questions :-p
13:42:11 <DRMacIver> Hm. I think I've got the bug. :)
13:42:38 <DRMacIver> I saw the "function unique" email on Haskell cafe and I'm resisting the urge to respond with an incomprehensibly elegant function written in point free style that does it in one line.
13:44:25 <waern> elegance == comprehsibility
13:44:37 <DRMacIver> Like I said. "incomprehensibly elegant".
13:44:50 <DRMacIver> ?type map head . filter ((<= 1) . length) . sort . group
13:44:52 <lambdabot> forall a. (Ord [a], Eq a) => [a] -> [a]
13:45:14 <waern> DRMacIver: blargh ;)
13:45:16 <Saizan> (<=1) . length is such a waste
13:45:28 <DRMacIver> Yeah. I didn't like that but couldn't come up with a better offhand.
13:45:56 <sfultong> I want a syntax where I can do...
13:46:00 <olsner> why sort . group and not group . sort?
13:46:13 <DRMacIver> Err. Because I screwed up. :)
13:46:18 <sfultong> data{a=,b=} newA newB
13:46:31 <olsner> group is somewhat like uniq -c, right?
13:46:47 <olsner> > group [1,1,2,2]
13:46:49 <lambdabot>  [[1,1],[2,2]]
13:47:08 <Saizan> > group [1,1,2,1,2]
13:47:09 <lambdabot>  [[1,1],[2],[1],[2]]
13:48:29 <glguy> -c : prefix lines by the number of occurrences
13:48:36 <byorgey> DRMacIver: you could replace filter (<=1) . length with filter singleton, where singleton [x] = True; singleton _ = False
13:48:51 <byorgey> DRMacIver: no longer a one-liner, but still elegant
13:49:21 <DRMacIver> Yeah, I know. 
13:49:23 <Saizan> ?type map head . filter (null . tail) . group . sort -- should do, since lists from group are never empty
13:49:25 <lambdabot> forall a. (Ord a) => [a] -> [a]
13:49:41 <DRMacIver> Ah, of course.
13:49:46 <byorgey> Saizan: nice.
13:49:51 <DRMacIver> I'd forgotten we could guarantee that the lists were non-empty.
13:50:18 <olsner> that's a nice one-liner - it's even readable!
13:50:29 <byorgey> of course, this solution re-orders the elements
13:50:32 <Saizan> DRMacIver: and you were going to map head on possibly empty lists!
13:50:40 <DRMacIver> Heh
13:50:41 <byorgey> it wasn't specified whether that was OK in the original problem
13:50:45 <glguy> > map (length &&& head) $ group [1,1,2,2,1,1,2,2,2]
13:50:46 <lambdabot>  [(2,1),(2,2),(2,1),(3,2)]
13:51:07 <DRMacIver> Saizan: I've been writing a lot of code like this for other stuff recently, so obviously I implicitly remembered. :) But I hadn't thought about it.
13:51:42 <DRMacIver> glguy: I think I have almost exactly that code in something I wrote recently for word counting. :)
13:52:45 <byorgey> DRMacIver: I think it's quite comprehensible, although of course that's a relative term... =)
13:53:15 <DRMacIver> byorgey: Yeah, I find it very readable too. I meant more that it was incomprehensible to a newbie. :)
13:53:43 <DRMacIver> (But I write more than 50% of my Haskell code in point-free style, so I'm probably officially deranged)
13:53:53 <Philippa> heh
13:53:54 <hpaste>  Pupeno pasted "What's wrong here? (parse error)" at http://hpaste.org/1621
13:54:01 <olsner> > (map snd . filter ((1 ==) . fst) , map (length &&& head) , group , sort) [1,1,2,2,3,4,5,3]
13:54:02 <lambdabot>  Couldn't match expected type `t1 -> t'
13:54:04 <Philippa> I'm starting to see more pointlessness crop up in my code now
13:54:06 <byorgey> DRMacIver: indeed.  probably shouldn't send your solution to the OP =)
13:54:21 <olsner> argh, ./,
13:54:45 <olsner> > (map snd . filter ((1 ==) . fst) . map (length &&& head) . group . sort) [1,1,2,2,3,4,5,3]
13:54:46 <Pupeno> In that paste I am getting "parse error (possibly incorrect indentation)" in the third line. What am I doing wrong?
13:54:47 <lambdabot>  [4,5]
13:55:12 <roconnor> yesterday I was using Prelude.. because I had imported the Prelude as qualified.
13:55:24 <DRMacIver> byorgey: I'm quite tempted. :) It would be mean though.
13:55:33 <roconnor> Prelude.. as an infix operator disturbs me.
13:55:36 <Saizan> Pupeno: you have to indent more "then" and "else"
13:55:56 <glguy> Saizan: this is not in a do block
13:56:05 <DRMacIver> roconnor: Ha
13:56:18 <shapr> I have a cute trick for *.cabal files:
13:56:19 <byorgey> roconnor: bizarre.
13:56:20 <DRMacIver> roconnor: It took me several seconds to parse what on earth Prelude.. meant
13:56:20 <shapr> -- Local Variables:\n-- eval: (set (make-local-variable 'compile-command) (concat "cabal-setup configure --prefix=/home/" (getenv "USER") "/usr && cabal-setup build && cabal-setup install --user"))\n-- End:
13:56:57 <olsner> but I suspect that the whole map snd . filter ((1 ==) . fst) . map (length &&& head) part could be done succinctly entirely with arrows
13:56:59 <Pupeno> Saizan: that indentation of then and else is ugly, but it's haskell-mode default and it never gave me a problem.
13:57:23 <shapr> Since I have (global-set-key [f12] 'compile) in my ~/.emacs I can now compile and install from a repo with a single button press!
13:57:24 <roconnor> DRMacIver: I honestly thought it wouldn't work when I typed it, but I didn't know what else it would be.
13:57:31 <roconnor> but it works fine.
13:57:36 <Pupeno> Saizan: I've tried indenting them more, but it didn't change anything, I still get the same error, which happens on the line previous to the if.
13:57:45 <shapr> That single button is also really handy for developing HAppS, since I can quickly install changes.
13:57:52 <glguy> Pupeno: he was thinking of do-notationi
13:58:23 <Saizan> Pupeno: yeah, i was wrong, sorry
13:58:29 <glguy> Pupeno: you might need the definition of parselabel to not be lined up in the outer let block
13:58:35 <Pupeno> Saizan: no problem.
13:59:09 <SamB> arg I wish Haskell had first-class typeclass instances...
13:59:18 <LPhas> hi guys, someone managed to run xmonad over ssh?
13:59:20 <Pupeno> glguy: yes, that was it. Thank you.
13:59:53 <Philippa> SamB: they're called records :-)
13:59:58 <SamB> LPhas: any particular reason you want to run your WM over SSH?
14:00:22 <SamB> Philippa: yes but I can't use those in "instance" declarations
14:00:34 <LPhas> SamB: well, just for try
14:00:47 <sjanssen> LPhas: it should work fine
14:01:12 <SamB> no... but I believe I have run *a* WM over SSH
14:01:13 <LPhas> sjanssen: it gives me xmonad: fatal error: request code=2, error code=10
14:01:13 <LPhas> Error: BadAccess (attempt to access private resource denied)
14:01:25 <sjanssen> LPhas: you're already running a WM
14:01:33 <LPhas> sjanssen: oh, right
14:01:38 <SamB> heh
14:01:44 <DRMacIver> SamB: Modular type classes + first class modules. It's the way forward. :)
14:01:50 <glguy> if you start the default TWM with startx
14:01:55 <glguy> you can then exit TWM
14:01:59 <SamB> DRMacIver: so what is the Cabal for that?
14:02:00 <glguy> and then start a new WM
14:02:02 <glguy> from the xterm window
14:02:07 * SamB teases DRMacIver 
14:02:15 <glguy> if you just want to play
14:02:21 <DRMacIver> SamB: There's a certain lack of implementation I will grant you. :)
14:02:56 <DRMacIver> 'though I seem to recall Cayenne bearing a certain resemblance to it.
14:03:46 <DRMacIver> (Certainly it has first class modules unified with records. I don't remember how these interact with its type classes, if it has such.)
14:04:17 <Syzygy-> Actually, you could just start X with a single xterm and ssh and start your WM from there.
14:05:48 <SamB> DRMacIver: I seem to remember Cayenne being rather bitrotted
14:06:01 <olsner> doesn't startx take an option for what to start after starting X?
14:06:20 <SamB> I think it doesn't quite have typeclasses but you are supposed to use those instead
14:06:37 <LPhas> glguy: client is on macosx, a little more complicate
14:06:41 <DRMacIver> SamB: Mm. I never got it to compile on my machine.
14:06:47 <SamB> perhaps it has some defaulting mechanism for something like typeclasses
14:07:01 <LPhas> glguy: maybe i can execute xmonad over ssh in .xinitrc
14:07:26 <glguy> LPhas: I don't know how OS X's X11 implementation handles that
14:07:32 <DRMacIver> SamB: Long before I joined #haskell, augusts and I had an email dialogue about the fact that Cayenne mysteriously fails to compile on my machine.
14:07:40 <DRMacIver> Yet exactly the same code works fine for him.
14:07:45 <DRMacIver> Never got to the bottom of it. :)
14:07:49 <SamB> DRMacIver: it was mysterious then?
14:07:50 <DRMacIver> But it's conceptually interesting.
14:07:53 <SamB> interesting!
14:08:02 <SamB> now it isn't very mysterious at all
14:08:07 <glguy> whoa ;)
14:08:07 <DRMacIver> Hm?
14:08:20 <DRMacIver> Sorry, I meant "Cayenne is conceptually interesting">
14:08:27 <DRMacIver> It failing to compile wasn't. :)
14:08:56 <SamB> I mean that it is interesting that you tried to compile it at a point when it would be at all mysterious why it wasn't compiling ;-)
14:09:29 <DRMacIver> In theory there's a working version available from its darcs repository.
14:09:37 <SamB> oh?
14:09:44 <SamB> it has a *darcs repository*?
14:10:03 <augusts> of course
14:10:14 <SamB> I guess it isn't bitrotted anymore then?
14:10:26 <augusts> it might have rotted again
14:10:34 <SamB> well, maybe a little bit rotted
14:11:06 <DRMacIver> augusts: Although the darcs repository takes quite some searching for. :)
14:11:33 <DRMacIver> (Well, I mean it's the top google hit for "Cayenne darcs". But it's not obvious from browsing the site)
14:11:34 <SamB> @google cayenne darcs
14:11:36 <lambdabot> http://www.augustsson.net/Darcs/Cayenne/
14:11:36 <lambdabot> Title: Index of /Darcs/Cayenne
14:11:45 <SamB> oh.
14:11:58 <SamB> so how does google know about it?
14:12:47 <augusts> google knows everything!
14:13:15 <SamB> whoohoo it built
14:13:24 <DRMacIver> Gah
14:13:31 <SamB> GHC 6.6
14:13:40 <DRMacIver> Likewise.
14:13:50 <augusts> DRMacIver: you must have bad vibes
14:14:04 <DRMacIver> augusts: I seem to recall you suggesting it was a cpp problem at the time.
14:14:05 <SamB> when did you try?
14:14:21 <david48> dcoutts: can I ask you a question about the article you linked  ?
14:14:33 <augusts> DRMacIver: hmmm, I think I might have gotten rid of cpp now
14:14:38 <SamB> Sun Nov  5 13:11:47 EST 2006  lennart@augustsson.net
14:14:38 <SamB>   * Get rid of cpp.
14:14:49 <DRMacIver> SamB: Originally? ~ a year ago. More recently, just now. :)
14:14:57 <SamB> drbean: how's it working now?
14:14:59 <Excedrin> what's the best example of fast array stuff in the shootout (or elsewhere, if there's a better example)?
14:15:09 <DRMacIver> I still get "List.cy", line 58, column 22, Cannot figure out hidden argument: (++) (s x) (" : " ++ show s xs)
14:15:18 <DRMacIver> Which is the same problem I got last time as I recall
14:15:27 <SamB> DRMacIver: oh. that's a compilation problem?
14:15:43 <LPhas> sjanssen: worked with ssh -Y phas@mihal xmonad in .xinitrc on macosx :P but seems that xmonad still crashes with X11 on macosx, even over ssh :/
14:15:49 <DRMacIver> SamB: Er, isn't it?
14:15:56 <sjanssen> LPhas: crashes?
14:16:01 <SamB> it looks more like a semantic error!
14:16:04 <sjanssen> LPhas: any useful error messages?
14:16:07 <DRMacIver> It says "Compilation errors" on the preceding line to me. :)
14:16:14 <dcoutts> david48: sure
14:16:19 <LPhas> sjanssen:well no :( simply X11 starts then die
14:16:24 <DRMacIver> SamB: List.cy is not my code!
14:16:25 <SamB> well, I mean, that isn't Cayenne failing to compile
14:16:39 <augusts> SamB: did you manage to make cayenne compile anything?
14:16:47 <SamB> augusts: hmm, not yet...
14:16:49 <DRMacIver> I get this just when running "make all" 
14:17:01 <SamB> make all isn't in the README
14:17:08 <DRMacIver> (Although I note that there does seem to be at least a semi-functional binary)
14:17:12 <david48> dcoutts: on the comments at the end, someone suggests "Gtk+2 makes it possible to â€œdeconstructâ€ its main loop and to drive it from outside of Gtk+"
14:17:14 <sjanssen> LPhas: there's an X11.app log IIRC
14:17:20 <david48> dcoutts: to which you reply "Thank you for the idea. Iâ€™ll certainly investigate it."
14:17:31 <sjanssen> LPhas: which version of xmonad?
14:17:35 <DRMacIver> SamB: Hm. True. :)
14:17:37 <LPhas> sjanssen: 0.2 stable
14:17:38 <david48> dcoutts: my question : that was in 2005. what gave the investigation ? :)
14:17:40 <SamB> make all does seem to work though
14:17:47 <LPhas> the darcs one don't compile on my machine
14:17:54 <DRMacIver> SamB: But "make install" calls it anyway I think.
14:18:04 <LPhas> sjanssen: an error like something is not an instance of Read
14:18:23 <sjanssen> LPhas: oh, compile error, not runtime error
14:18:32 <dcoutts> david48: I'm not sure I understand. what do you mean about investigation?
14:18:46 <LPhas> sjanssen: the darcs one, on a linux box
14:19:00 <sjanssen> LPhas: you need to use darcs X11-extras with darcs xmonad
14:19:12 <LPhas> sjanssen: ok
14:19:19 <david48> dcoutts: your reply was that you were going to investigate :)   I'm curious if you had any result or if the idea was abandonned
14:19:37 <sjanssen> LPhas: do you have X11.app set to run in fullscreen mode?
14:19:37 <DRMacIver> SamB: See? Like I said. Mysterious!
14:19:43 <augusts> It is!
14:19:45 <DRMacIver> augusts is probably right about my bad vibes. :)
14:19:50 <LPhas> sjanssen: well no
14:20:01 <monochrom> What is the mystery?
14:20:08 <dcoutts> david48: oh right. What we have now is some functions for working with the threaded rts.
14:20:12 <DRMacIver> monochrom: Cayenne mysteriously fails to compile in my presence.
14:20:22 <DRMacIver> Syzygy-: Ping?
14:20:27 <monochrom> It happens sometimes. Usually my presence helps.
14:20:35 <sjanssen> LPhas: that might be causing the problem
14:20:42 <LPhas> sjanssen: let's try
14:21:15 <dcoutts> david48: postGUISync and postGUIASync
14:21:32 <dcoutts> david48: see the concurrency demos in the gtk2hs demo collection
14:21:54 <david48> dcoutts: oh, ok ! ( by the way, is the method advocated in the article still up to date ? ( timeoutAdd (yield >> return True) 50 ) )
14:22:02 <SamB> DRMacIver: so what distro are you using?
14:22:19 <dcoutts> david48: that's the method for working with threads in the single-threaded rts
14:22:57 <dcoutts> david48: which is probably the safest, using the multi-threaded rts is trickier
14:23:45 <DRMacIver> SamB: I've tried this on both Ubuntu and Gentoo boxes. I think I might have tried it on Windows as well, but that was quite a while ago.
14:25:28 * shapr cheers about bugs fixed!
14:26:45 <Syzygy-> Pong
14:27:17 <DRMacIver> Syzygy-: In the interests of scientific endeavour, would you mind doing a darcs checkout of Cayenne on mneme and seeing if it compiles? :)
14:27:29 <Syzygy-> Why not do it yourself? 
14:27:34 <Syzygy-> Because you're biased, or?
14:27:36 <DRMacIver> Syzygy-: Because it breaks when I do it. :)
14:27:39 <DRMacIver> Syzygy-: I'd like to verify that this isn't just me being insane. :)
14:27:52 <Syzygy-> Where's the repo?
14:28:07 <DRMacIver> http://www.augustsson.net/Darcs/Cayenne/
14:28:07 <lambdabot> Title: Index of /Darcs/Cayenne
14:28:21 <Syzygy-> Depends on Haskell only? Or?
14:28:30 <DRMacIver> Should just depend on Haskell.
14:28:35 <LPhas> sjanssen: trying darcs version of X11-extras i get  error: X11_extras_config.h: No such file or directory
14:28:44 <sjanssen> LPhas: README
14:28:51 <LPhas> sjanssen: sorry :P
14:29:04 <DRMacIver> (So far I'm the only one who has this problem, and it happens on whichever computer I try it on. Hence I'd like a control group. :) )
14:29:27 <sjanssen> LPhas: you might try pinging #xmonad or the mailing list -- I know we've had users that run xmonad on OS X
14:29:38 <LPhas> sjanssen: thx
14:30:38 <Syzygy-> DRMacIver: It's just you.
14:30:56 <Syzygy-> DRMacIver: Copy it from ~mik/src/Cayenne. It's compiled and ready.
14:31:43 <DRMacIver> Did you just do "make" or "make all"?
14:31:53 <Syzygy-> Just make, admittedly.
14:32:03 <SamB> augusts: what distro do you use?
14:32:04 <DRMacIver> make works for me too. Try make all.
14:32:14 <SamB> Syzygy-: you too?
14:32:22 <DRMacIver> (It's some of the library functions rather than the compiler itself which don't compile)
14:32:24 <Syzygy-> DRMacIver: Dammit! Say so straight off then!
14:32:28 <DRMacIver> Sorry. :)
14:32:39 <Syzygy-> Yeah, Make all dies on List.cy
14:32:46 <augusts> SamB: 6.7, I guess
14:33:03 <SamB> augusts: that's your UNIX distribution is it?
14:33:24 <DRMacIver> Syzygy-: Thanks. Good to know that I'm not going mad.
14:33:29 <augusts> Oh, NetBSD, MacOS X, and Windows
14:33:34 <luqui> for that reason at least...
14:33:42 <SamB> oh, in that case it probably isn't related to that ;-)
14:33:46 <Syzygy-> DRMacIver: Oh, you are, rest assured. Just this isn't necessarily a symptom.
14:33:47 <DRMacIver> Let me rephrase. Good to know that I'm not hallucinating. :)
14:35:22 <SamB> so...
14:35:31 <pastorn> is there a webpage where you can talk to lambdabot somewhere?
14:35:48 * pastorn can't connect to IRC at work and is too lazy to compile
14:36:41 <shapr> When should %Z return UTC and when GMT?
14:36:49 <shapr> Shouldn't they be interchangeable?
14:37:07 <shapr> Er, in the context of strftime that is...
14:38:22 <SamB> augusts: what a peculiar heirarchical seperator you have here
14:38:42 <augusts> yeah
14:38:47 <monochrom> There is a web page where you can IRC...
14:38:58 <augusts> i could have picked something else
14:39:00 <SamB> @google lambdabot web
14:39:02 <lambdabot> http://lambdabot.codersbase.com/
14:39:02 <lambdabot> Title: Lambdabot Web Interface
14:39:13 <pastorn> yay!!
14:39:31 <monochrom> pastorn: I have a great project for you! Build a web site that let's you IRC...
14:39:35 <mnislaih> does lambdabot depend on a particular version of Happy? I'm getting compile errors on Lib.Parser, using happy v1.16 and ghc 6.6.1
14:39:57 <SamB> mnislaih: what compile errors?
14:40:13 <mnislaih> A few like this one: "Lib/Parser.hs:7920:4: Not in scope: `as_name'"
14:40:45 <mnislaih> (this is a darcs get of lambdabot)
14:40:57 <SamB> you maybe should try GHC 6.6?
14:41:04 <SamB> I also have that version of happy...
14:41:09 <olsner> shapr: I think GMT has daylight savings changes, while UTC is always just UTC.. (not sure which of them should be returned by %Z though)
14:41:34 <pastorn> monochrom: don't you think someone has already done that?
14:41:51 <glguy> how could GMT have daylight savings time?
14:41:58 <quicksilver> sjanssen: well, I wrote it
14:42:01 <quicksilver> sjanssen: bit of a monster email
14:42:06 <monochrom> Yes. But perhaps re-doing it in Haskell is worthwhile. Also, I don't know where it is.
14:42:09 <quicksilver> sjanssen: I wonder if anyone will have the patience to read it :)
14:42:14 <Heffalump> there's some silly technical difference between UTC and GMT, possibly connected with leap seconds.
14:42:17 <pastorn> SamB: i can't get that LB web-a-mo-bob to work
14:42:32 <Heffalump> or possibly just a pedantic definition difference that never makes any difference to the actual time
14:42:42 <SamB> pastorn: oh. well. I didn't say that it would work did I ?
14:44:23 <pastorn> even the example commands gives me Lambdabot No Process
14:44:27 <shapr> Heffalump: Ok, thanks.
14:44:29 <Baughn> Heffalump: It's the leap seconds, and IIRC it's up to 16 seconds now
14:44:40 <pastorn> or is that the LB program that has been killed on the server?
14:45:03 <Heffalump> really? I thought they did get resynchronised every so often. But I'm only vaguely aware of this whole subject.
14:45:34 <SamB> pastorn: I assume that it means that lambdabot died or something
14:46:31 <Baughn> Heffalump: I may be thinking of some other time standard
14:51:12 <RyanT5000> are there any papers on really powerful pattern matching?
14:51:49 <RyanT5000> (i.e. something more than just Haskell's constructor/deconstructor paradigm)
14:51:57 <SamB> what kind of "pattern matching"?
14:52:10 <RyanT5000> well, generic unpacking of datastructures
14:52:18 <RyanT5000> i don't have anything in particular in mind
14:52:18 <SamB> oh, you mean like views?
14:52:33 <RyanT5000> sure, i'll read about that :P
14:54:37 <Heffalump> ok, so GMT is defined by the earth's rotation, and UTC by atomic clocks
14:54:39 <Pastorn2> wohoo!!! it works!!!! web based chatting
14:55:00 <Heffalump> so the two get out of sync slowly, but since UTC has leap seconds, they are never very much out of sync
14:55:14 <SamB> so how do they know when to add leap seconds?
14:55:33 <Heffalump> by measuring the difference between the two
14:55:54 <SamB> ... that sounds kinda hard to predict :-(
14:56:05 <Heffalump> you just measure the earth's rotation
14:56:17 <Heffalump> I think it's well understood how to do that.
14:56:22 <SamB> so is GMT just the thing that the UTC is supposed to follow, and everything else is based on UTC?
14:56:31 <monochrom> It's decided by a committee.
14:56:39 <waern> RyanT5000: you can also look at first-class patterns
14:56:52 <SamB> also, leap seconds sound very crude
14:56:52 <Heffalump> I think most time sources are based on UTC, yes.
14:57:18 <Heffalump> well, you need some mechanism to sync up atomic clocks and the earth, if you don't want the day to precess
14:57:42 <shapr> Heffalump: My original frustration was caused by the fact that wget likes "%a, %d %b %Y %X GMT" but if %Z or UTC are in place of GMT, wget says the last-modified header is illegal.
14:57:51 <SamB> yeah. but think of what happens if you are playing a game when a leap second occurs!
14:58:10 <Heffalump> what would happen?
14:58:21 <Heffalump> you just have an extra second in the day (23:59:60)
14:58:21 <glguy> you'd lose points
14:58:23 <glguy> :(
14:58:34 <Heffalump> there's no interruption in the flow of time
14:58:35 <SamB> it would definately result in some kind of hiccup in the game
14:58:40 <shapr> I like libtai
14:58:40 <Heffalump> no, it wouldn't
14:58:40 <eivuokko> Huh
14:58:40 <RyanT5000> SamB: leap seconds are hard to predict; sometimes massive earthquakes and stuff mess with them
14:58:55 <monochrom> Some astronomers in the committee are now opposing more leap seconds, since leap seconds screw up their algorithms for tracking star movements.
14:59:01 <SamB> okay, well, depending on the way the game measures time
14:59:02 <Heffalump> unless the game was written to decode HHMMSS back into an absolute count of seconds, which would be just stupid
14:59:23 <SamB> so are you saying that it doesn't affect UNIX time?
14:59:34 <glguy> HAppS has mad-dependencies
14:59:41 <SamB> so... um... how does the computer know what leap seconds there have been?
14:59:59 <monochrom> An isolated computer doesn't.
15:00:07 <gerel> hey, anyone know a nice introduction to function composition with multiple arguments ? , I'm having a headache getting it
15:00:08 <Heffalump> hmm. Not sure. Once obvious way would be for NTP to use drift to correct things.
15:00:22 <SamB> Heffalump: oh, it does do it that way actually
15:00:25 <RyanT5000> It is the responsibility of the International Earth Rotation and Reference Systems Service (IERS) to measure the Earth's rotation and determine whether a leap second is necessary. Their determination is announced in IERS 'Bulletin C', typically published every six months.
15:00:35 <Heffalump> anyway, bed calls.
15:00:47 <monochrom> A computer on the internet can sync to a network of reference clocks that eventually traces to those that respect the UTC committee decisions.
15:01:14 <RyanT5000> you could keep your computer on UT1 or GPS time
15:01:17 <RyanT5000> they are leapsecond-free
15:01:37 <glguy> UT1 time while playing UT2k7?
15:01:37 <Heffalump> right, but the question is how the discrepancy between UNIX time and UTC is handled, since AFAIK UNIX time doesn't count leap seconds
15:01:44 <SamB> I'm just saying that I think that if the computer actually used UTC directly, it would result in wierd hiccups in gaming
15:01:49 <RyanT5000> glguy: yeah, might be a little slow
15:01:49 <Heffalump> And the answer is almost certainly that you use drift to fix it up slowly.
15:01:53 <monochrom> If you are on Windows or Ubuntu or Debian or... and enabled "sync clock with the internet", you are not isolated.
15:01:56 <RyanT5000> (or really really fast?)
15:02:07 <Heffalump> SamB: only if it made a stupid mapping to unix time
15:02:10 <quicksilver> Heffalump: modern unixes do understand leap seconds
15:02:25 <quicksilver> Heffalump: before that, I believe the epoch was moving
15:02:29 <quicksilver> Heffalump: (IYSWIM)
15:02:44 <Heffalump> really? That sounds broken.
15:02:45 <quicksilver> so each time there was a leap second, the epoch was effectively redefined
15:02:50 <quicksilver> so that it was right again
15:02:53 <monochrom> As a last resort you can always tell a program to just brutally set the clock.
15:03:01 <SamB> quicksilver: what do they do now?
15:03:03 <quicksilver> well there haven't been *that* many leap seconds since 1970
15:03:15 <quicksilver> SamB: modern machines know when the leap seconds were, I believe
15:03:24 <SamB> demand a copy of these "bulletin C"s?
15:03:31 <Heffalump> yes, but if the epoch is now 31/12/1969 23:59:37, that'd be rather confusing.
15:03:37 <quicksilver> SamB: they have a database of them, just like they have a database of when easter is
15:03:37 <Heffalump> anyway, reallybed
15:03:53 <quicksilver> SamB: when you upgrade your OS every year you get the new database
15:03:58 <quicksilver> SamB: (I think that's how it works)
15:04:00 <SamB> quicksilver: they have a database of when easter is ?
15:04:04 <quicksilver> indeed they do
15:04:13 <quicksilver> 'cal(1)' or whatever it was on unix machines
15:04:17 <quicksilver> knew when easter was
15:04:19 <quicksilver> and  passover
15:04:19 <SamB> I didn't know computers liked chocolate...
15:04:19 <quicksilver> etc
15:04:25 <SamB> drat my slow typing
15:04:41 <quicksilver> but the only way you can  know that is by being told, since it doesn't follow exact rules
15:04:53 <quicksilver> it follows approximate rules but it is ultimiately chosen by humans
15:04:59 <monochrom> Every year a committee makes new decisions.
15:05:04 * quicksilver nods
15:05:18 <quicksilver> so 'cal' had a database
15:05:22 <monochrom> Be very aware that it is a committee.
15:05:23 <quicksilver> /usr/share/holidays or something similar
15:05:29 <RyanT5000> international atomic time is always 19 seconds ahead of GPS time
15:05:38 <RyanT5000> that's messed up
15:05:42 <SamB> every year?
15:05:53 <SamB> how much before the year do they meet?
15:06:04 <SamB> is it a different comittee for each holiday?
15:06:33 <monochrom> The committee may meet more frequently.
15:06:40 <quicksilver> they decide around a year in advance I believe
15:06:45 <quicksilver> for easter + similar
15:07:04 <SamB> at least nobody has to decide when to have the 4th of July ;-)
15:07:05 <monochrom> But last time they decided to add a leap second, it was rather a rush actually.
15:07:41 <monochrom> The US Parliament meeting very frequently. Perhaps tomorrow they suddenly change that too.
15:07:57 <SamB> wtf parliament?
15:08:06 <monochrom> Err Congress. Pardon my French.
15:08:18 <SamB> heh
15:08:27 <RyanT5000> :P
15:09:05 <SamB> hmm, oh, back to first-class typeclass instances and Cayenne:
15:09:22 <RyanT5000> oooh, can we have those?
15:09:28 <RyanT5000> pretty please?
15:09:47 <SamB> it looks like they are just records
15:10:07 <monochrom> first-class modules!
15:10:13 <RyanT5000> :D
15:10:20 <SamB> there doesn't seem to be any defaulting???
15:11:15 <SamB> module concrete System$Monad = \ (m :: # -> #) -> sig
15:11:15 <SamB> (>>=) :: (a :: #) |-> (b :: #) |-> m a -> (a -> m b) -> m b
15:11:15 <SamB> (>>) :: (a :: #) |-> (b :: #) |-> m a -> m b -> m b
15:11:15 <SamB> return :: (a :: #) |-> a -> m a
15:12:35 <SamB> don't ask me what the "concrete" is for...
15:13:01 <DRMacIver> SamB: Well, that's what I said isn't it? Modules and records are unified in Cayenne. :)
15:13:15 <DRMacIver> (It's why it came up in the first place)
15:13:22 <SamB> yes
15:13:38 <SamB> DRMacIver: but you mentioned that you didn't know how it related to typeclasses
15:13:53 <DRMacIver> True. 
15:14:14 <DRMacIver> So what you're saying is that there's no way to do the equivalent of 'instance'?
15:14:38 <SamB> Monad_Maybe :: System$Monad Maybe = struct ...
15:15:06 <SamB> then afaict you'd have to pass that into any generic monad functions?
15:15:58 <DRMacIver> Well the complaint the compiler was giving me was "Cannot figure out hidden argument"
15:16:28 <DRMacIver> Which is suggestive that there's something along the lines of implicit parameters, which are possibly usable for htis?
15:17:00 <SamB> it looks like that is for types that get used for the types of later arguments?
15:17:11 <DRMacIver> Possibly. I'm just guessing at this point. :)
15:17:22 <DRMacIver> Never having got Cayenne to work, my exposure to it is limited.
15:17:25 <SamB> if :: (a :: #) |-> Bool -> a -> a -> a;
15:17:25 <SamB> if (True)  x y = x;
15:17:25 <SamB> if (False) x y = y;
15:17:48 <DRMacIver> Oh good. Haskell's 'if' annoys me. :)
15:17:56 <monochrom> Haha, why?
15:18:09 <DRMacIver> monochrom: It's not first class.
15:18:37 <DRMacIver> monochrom: In a Lazy language there's no reason 'if' shouldn't be the obvious function except that the committee thought that not having to write 'then' and 'else' might be confusing. :)
15:19:05 <monochrom> But it's easy to define myif.
15:19:19 <monochrom> At least it is not like Scheme where you have to learn macros.
15:19:21 <SamB> DRMacIver: and now we have even more confusing syntax errors when you use one obvious way of indenting them in "do" forms
15:19:33 <SamB> monochrom: yeah but you can't call it "if"
15:19:56 <monochrom> But then I can't call =<< "let" either.
15:20:11 <SamB> also scheme comes with a macro that does if's job already ;-)
15:20:16 <SamB> called if, for some reason
15:20:42 <monochrom> Perhaps Haskell keywords should be in Greek.
15:20:54 <DRMacIver> Keywors should be removed whenever possible. :)
15:20:57 <DRMacIver> Keywords
15:21:03 <monochrom> So that when you define functions doing the same thing you can use Chinese.
15:21:12 <SamB> oh, actually isn't it cooler to have if :: a -> a -> Bool -> a?
15:21:25 <DRMacIver> SamB: Hm, how so?
15:21:36 <Saizan> yeah, i always need that for pointfree
15:21:39 <SamB> it's more curryable
15:21:45 <DRMacIver> Hmm.
15:21:48 <DRMacIver> Yes, good point.
15:21:55 <DRMacIver> Maybe we should call that fi
15:22:00 <monochrom> Haha
15:22:18 <DRMacIver> (Go on, you know it's a good idea. ;) )
15:22:21 <SamB> but then people would want to put it on the right ;-)
15:22:36 <DRMacIver> I'm fine with that. :)
15:22:46 <SamB> yes but that doesn't work :-(
15:22:54 <DRMacIver> Give me proper postfix operators or give me... umm. cake!
15:23:03 <monochrom> I think I onced defined operators ? and : so that you could write b?p:q
15:23:08 <SamB> where exactly are you?
15:23:17 <SamB> monochrom: impossible
15:23:24 <SamB> : is a special name
15:23:26 <DRMacIver> Physically? London.
15:23:30 <monochrom> Not exactly using the : name, of course.
15:23:36 <SamB> ah ;-)
15:23:57 <DRMacIver> Why?
15:24:02 <SamB> I think I've seen it done
15:24:07 <monochrom> data Alt a b = a ::: b
15:24:20 <DRMacIver> Argh. :)
15:24:21 <monochrom> b ? (a ::: b) = if b then a else b
15:24:32 <monochrom> Then fix up some fixity.
15:24:32 <SamB> that's not a very nice name
15:24:40 <Saizan> you can use $ and b ? a = if b then const a else id
15:25:21 <cedricshock> Anyone know what this problem is called, so I can go find a faster solution to it:? Find the maximum number of nodes on a graph such that none of the nodes share an edge with any other node.
15:25:34 <DRMacIver> Hm.
15:25:49 <SamB> cedricshock: ... maximum number?
15:25:55 <DRMacIver> I've had an awful idea. :)
15:26:01 <SamB> does the graph have to be connected?
15:26:14 <cedricshock> SamB: Cardinality of the largest set of nodes
15:26:54 <SamB> is that â„µ?
15:26:57 <monochrom> "independent set" is the name.
15:27:00 <cedricshock> SamB: You can assume it's conencted, since it's easy enough to decompose it into multiple unconnected graphs.
15:27:09 <cedricshock> monochrom: thanks
15:27:24 <SamB> oh...
15:27:28 <SamB> I understand now
15:27:36 <DRMacIver> I think with appropriate type classes and modulo details of fixity and keywords (which can be solved by replacing 'else' with some silly infix operator) I can get both "if foo bar else baz" and "bar else baz foo" to be valid expressions of an if statement. :)
15:27:39 <monochrom> Four months of that dreadful "complexity" course pays off! :)
15:28:18 <DRMacIver> Which would solve both the if and fi problems. :)
15:28:19 <SamB> you have a graph, and you want to know the maximum size of a set of nonadjacent nodes?
15:28:29 <cedricshock> SamB: Exactly.
15:29:06 <SamB> well, it's probably less than the number of nodes in the graph
15:29:24 <SamB> certainly not more than ;-)
15:30:00 <monochrom> I know a school that names that complexity course "effective and efficient computing". It contains NPC and undecidability. Because of that, I like to call it "ineffective and inefficient computing".
15:31:05 <monochrom> independent set is NP-complete.
15:31:15 <cedricshock> Here is a /really/ bad algorithm for it: maximum of: take a node. Remove all the adjacent nodes. Return 1 + solving the problem with the remaining nodes
15:31:58 <cedricshock> monochrom: It has to be. It's the most obvious thing to connect to any optimization problem to make it magically faster.
15:32:00 <monochrom> I would transform it to SAT then call up a SAT solver written in Haskell...  (duck)
15:33:13 <monochrom> int80_h: have you seen http://hpaste.org/1611#a1 ?
15:36:28 <DRMacIver> Hm. I wonder if the urge to commit great evil against the type class system goes away after a while.
15:36:39 <DRMacIver> Or possibly it's just me. "Ooooh. Cool new feature. How can I abuse it!" :)
15:36:51 <SamB> DRMacIver: what are you trying to do?
15:37:12 <SamB> anyway Oleg never seems to tire of (ab)using typeclasses ;-)
15:37:13 <shapr> Is there some way to do either darcs get with overwriting, or darcs pull that does get if the repo doesn't exist? I'm trying to wrap some darcs commands into a shell script, and the repo may or may not already exist.
15:37:32 <DRMacIver> SamB: Nothing in particular. I just has the above else stuff in mind, and I've been toying with some ideas about tuple field literals that are moderately diabolical.
15:37:35 <hpaste>  monochrom annotated "Revege of Yaht Perplexity." with "correction" at http://hpaste.org/1611#a2
15:37:44 <DRMacIver> s/has/had/
15:38:25 * cedricshock actually once thought it'd be a good idea to solve the clique problem on things like myspace and facebook.
15:38:37 <chessguy> heh
15:38:50 <chessguy> hope you've got a spare supercomputer around
15:38:51 <DRMacIver> cedricshock: I thought things like myspace and facebook *were* the clique problem. ;)
15:42:52 <cedricshock> It seems like finding how N solution paths of length K intersect each other ought to be easier than finding them in the first place... But if solutions are easy to find...
15:50:15 * DRMacIver mutters
15:50:55 <DRMacIver> I hate the "Gee, what vaguely sensible looking random combination of letters might not have been taken" game. :)
15:50:56 * matthew-_ mumbles
15:51:04 <DRMacIver> s/letters/characters/
15:51:35 <basti_> i think we're lucky that utf-8 is not allowed for nicknames
15:51:43 <DRMacIver> Heh. I meant for Haskell operators.
15:51:48 <basti_> ah
15:52:18 <cedricshock> What operator do you need?
15:52:55 <basti_> we're also lucky that utf-8 isnt allowed for haskell operators
15:53:11 <matthew-_> how can this few people generate this many emails in 6 hours time?
15:53:15 <matthew-_> wtf are they playing at?
15:54:01 <DRMacIver> cedricshock: I just need some vaguely sensible operator for expressing alternatives.
15:54:01 <Saizan> is there a flag to tell Setup.hs build to relink? (i've reabuilt an imported package)
15:54:05 <cedricshock> Whoa! Fast solutions to the clique problem use about a billion heuristics. This is going to be worse than fast TSP.
15:54:29 <DRMacIver> cedricshock: But | is reserved, || is or and ||| is arrows. <|> is used by parsec. Anything starting with : is a constructor... 
15:54:30 <cedricshock> DRMacIver: |||||||||||| might not be taken yet.
15:54:41 <ddarius> <+>
15:54:52 <DRMacIver> Ah, the tie fighter operator.
15:55:07 <DRMacIver> @hoogle <+>
15:55:08 <lambdabot> Control.Arrow.(<+>) :: ArrowPlus a => a b c -> a b c -> a b c
15:55:08 <lambdabot> Text.PrettyPrint.HughesPJ.(<+>) :: Doc -> Doc -> Doc
15:55:18 <DRMacIver> See? :)
15:55:55 <cedricshock> DRMacIver: Do you have algebraic properties shared with something that already has alternatives?
15:56:12 <cedricshock> @hoogle ora
15:56:12 <lambdabot> Data.Array.Storable :: module
15:56:12 <lambdabot> Foreign.Storable :: module
15:56:12 <lambdabot> Prelude.forall :: keyword
15:56:19 <monochrom> You may be interested in |+| 
15:56:31 <DRMacIver> monochrom: Ah. The tie *defender* operator. ;)
15:56:35 <DRMacIver> @hoogle |+|
15:56:35 <lambdabot> No matches found
15:56:37 <DRMacIver> Gosh
15:56:47 <ddarius> <++> bomber
15:56:55 <cedricshock> @hoogle <++>
15:56:56 <lambdabot> No matches found
15:57:08 <DRMacIver> cedricshock: Probably not. It's just a simple class.
15:57:10 <ddarius> .+.
15:57:21 <monochrom> I like Unicode.
15:57:33 <ddarius> DRMacIver: It represents alternatives but is not an instance of one of these other things.
15:57:34 <ddarius> ?
15:57:45 <DRMacIver> ddarius: It's a class rather than a datatype.
15:58:02 <DRMacIver> (For reasons of abuse)
15:58:36 <monochrom> What would you like |+| to do?
15:59:12 <DRMacIver> x |+| y = either x or y
15:59:27 <DRMacIver> Or x `else` y one might say. :)
15:59:45 <DRMacIver> (I've changed my mind. It's the red cross operator.)
16:00:24 <SamB> DRMacIver: ooh, you know the lhs2TeX for that?
16:01:23 <DRMacIver> How do you mean? I don't do lhs. 
16:01:32 <DRMacIver> (More because I haven't gotten around to it than anything else)
16:02:32 <SamB> to make it actually look like a red cross ;-)
16:02:45 <DRMacIver> Oh, heh.
16:03:02 <DRMacIver> vim's syntax highlighting already highlights operators red. :)
16:03:11 <DRMacIver> Which is what made me think of it.
16:03:12 <pastorn_> why does my apt-get hang during building GHCi library /usr/lib/haskell-packages/ghc6/lib/gtk-0.9.10.5/HSgtk.o
16:04:07 <pastorn_> @paste
16:04:07 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:04:07 <SamB> pastorn: check your CPU/disk meters
16:04:14 <SamB> also RAM
16:04:18 <pastorn_> 128 MB ram
16:04:26 <SamB> I meant, how much is used
16:04:40 <pastorn_> that might be it, but still, on my new computer it takes like 10 seconds, tops
16:04:44 <monochrom> apt-get does building?
16:05:08 <pastorn_> it just starts using the disk A LOT and never ends
16:05:18 <pastorn_> i left it on for 6 hours, nothing happened
16:05:19 <SamB> monochrom: it is presumably just linking the libfoo.a into a .o file with ld
16:05:25 <shapr> monochrom: apt-build can
16:05:48 <shapr> pastorn_: Are you using debian/unstable?
16:05:56 <pastorn_> xubuntu
16:06:01 <pastorn_> 7.04
16:06:27 <hpaste>  pastorn pasted "nasty error" at http://hpaste.org/1622
16:07:56 <pastorn_> i used CTRL-C before all turned to shit and i was stuck with a frozen system
16:09:15 <DRMacIver> Eep
16:09:19 * DRMacIver sees what hour it is
16:09:29 <pastorn_> 1 AM?
16:09:55 <DRMacIver> 10 minutes past bed time.
16:09:56 <DRMacIver> night
16:18:15 <shapr> Has the Haskell Weekly News really been published lately?
16:19:12 <ddarius> No
16:19:32 <shapr> aww
16:20:05 <ddarius> shapr: I agree
16:20:30 <ddarius> dons will no doubt make up some sob story about how he is writing a book and all
16:20:38 <dons> i have a sob story
16:20:40 <gravity> and his thesis
16:20:49 <dons> but i'd like to get it published
16:21:00 * shapr grins
16:21:02 * shapr hugs dons
16:21:24 <dons> thanks shapr :)
16:22:05 <shapr> I just found an LJ post that calls me an illustrious Haskell hacker, and in the comments someone shows some Prolog code and says he doesn't see that could be coded more concisely in Haskell.
16:22:14 <shapr> http://lukego.livejournal.com/5292.html
16:22:20 * shapr feels cool!
16:22:21 <dibblego> challenge!
16:22:27 <SamB> which field is supposed to be longer -- synopsis or description?
16:22:34 <shapr> dibblego: Yeah, that's what I was thinking :-)
16:22:48 <shapr> "He did succeed in reminding me why Haskell matters: it's because Haskell people can rewrite any one of your programs in half as much code."
16:22:49 * shapr laughs
16:23:23 <shapr> But I have a beautiful woman visiting me from Sweden, so I'll pick up the challenge some other time.
16:24:06 <luqui> IMO, prolog is approximately equivalent to haskell in the list monad...
16:24:17 <luqui> as far as expressibility goes
16:24:30 <shapr> Yeah, seems that way to me too.
16:26:49 <tuukkah> is there a name for \p = head . dropWhile p
16:26:50 <augusts> pure prolog is like the list monad
16:27:00 <augusts> real prolog is like, list+state+io
16:27:55 <dibblego> tuukkah, I think you mean \p ->
16:28:01 <tuukkah> yeah
16:28:14 <dibblego> and possibly even \p -> (head . dropWhile) p
16:28:22 <dibblego> (which is just head . dropWhile)
16:28:35 <fax> hi
16:28:53 <dibblego> ?type \p -> head . dropWhile p
16:28:55 <lambdabot> forall a. (a -> Bool) -> [a] -> a
16:28:56 <chessguy> @pl \p lis -> head (dropwhile p list)
16:28:57 <lambdabot> const . head . flip dropwhile list
16:29:00 <dibblego> ?type \p -> (head . dropWhile) p
16:29:02 <lambdabot>     Couldn't match expected type `[a]'
16:29:02 <lambdabot>            against inferred type `[a1] -> [a1]'
16:29:07 <SamB> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parsely-0.0
16:29:10 <lambdabot> http://tinyurl.com/2qzygr
16:29:20 <chessguy> @pl \lis p -> head (dropwhile p list)
16:29:20 <lambdabot> const (head . flip dropwhile list)
16:29:29 <dibblego> ah
16:29:43 <dibblego> @pl \p -> head . dropWhile p
16:29:43 <lambdabot> (head .) . dropWhile
16:29:47 <augusts> (head .) . dropWhile
16:30:11 <chessguy> hey augusts don't look now, but....
16:30:22 * chessguy whispers (one of your s' fell off)
16:30:25 <augusts> yea yea, beaten by the bot again
16:30:35 <augusts> *gasp*
16:30:42 <SamB> when does the documentation for my package get generated...
16:30:44 * chessguy blushes
16:31:05 <tuukkah> well i'm doing this with a monadic p so i need to generalize myself anyway
16:31:14 <pastorn_> ?type (head .)
16:31:16 <lambdabot> forall a a1. (a1 -> [a]) -> a1 -> a
16:31:23 <pastorn_> ?type (head .) (.)
16:31:25 <lambdabot>     Couldn't match expected type `[a]'
16:31:25 <lambdabot>            against inferred type `(a1 -> b) -> a1 -> c'
16:31:30 <pastorn_> ?type ((head .) .)
16:31:33 <lambdabot> forall a a1 a2. (a2 -> a1 -> [a]) -> a2 -> a1 -> a
16:31:47 <augustss> another s
16:31:51 <pastorn_> ?type ((head .) . dropWhile)
16:31:53 <lambdabot> forall a. (a -> Bool) -> [a] -> a
16:32:02 <chessguy> much more appropriate, augustss 
16:32:03 <augustss> it has no name because it is evil
16:32:18 <dibblego> are a data type's constructors exported by default?
16:32:21 <chessguy> what's so evil about it?
16:32:22 <tuukkah> > find isDigit "asdf324sdf"
16:32:23 <lambdabot>  Just '3'
16:32:25 <SamB> so, um, would anyone like to download and look at my package and tell me what they think?
16:32:45 <pastorn_> :t find
16:32:47 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
16:32:48 <augustss> > head $ dropWhile (>1) [2]
16:32:49 <lambdabot>  Exception: Prelude.head: empty list
16:33:02 <pastorn_> fuck, that was pre-defined?
16:33:06 <chessguy> oh, that kind of evil
16:33:18 <fax> SamB: if you link it maybe :p
16:33:24 <SamB> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parsely-0.0
16:33:26 <lambdabot> http://tinyurl.com/2qzygr
16:33:29 <chessguy> > head $ dropWhile (>1) [2,3..]
16:33:33 <lambdabot> Terminated
16:33:36 <tuukkah> augustss, and my list is infinite so no chance for Nothing
16:34:03 <augustss> yeah, the bottom evil is hard to ward off in haskell
16:34:18 * chessguy can't bring himself to look at a package with such a punny name
16:34:53 <SamB> chessguy: is it worse than parsec, as names go?
16:35:11 <SamB> or more relevantly, parmin?
16:35:26 <pastorn_> @hoogle  (a -> Bool) -> [a] -> Maybe Int
16:35:26 <lambdabot> List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
16:35:32 <augustss> parmeggiano
16:36:13 <chessguy> parsec is worse than parmin, because it's a real word
16:36:26 <pastorn_> ?src List.findIndex
16:36:26 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
16:36:30 <SamB> @google 1 parsec in parmins
16:36:31 <pastorn_> ?src findIndex
16:36:34 <lambdabot> http://www.bautforum.com/archive/index.php/t-31480.html
16:36:34 <lambdabot> findIndex p     = listToMaybe . findIndices p
16:36:37 <SamB> aww
16:36:47 <mrd> darn now i'm hungry
16:36:57 <pastorn_> ?src findIndices
16:36:57 <lambdabot> findIndices p xs = [ i | (x,i) <- zip xs [0..], p x]
16:37:01 <SamB> chessguy: well, personally I think the real problem is that it is the name of a videogame
16:37:04 <SamB> not that it is a word
16:38:16 <pastorn_> @hoogle  (a -> Bool) -> [a] -> [[a]]
16:38:17 <lambdabot> No matches, try a more general search
16:38:37 <SamB> I found out just now that I already had a hackage account
16:39:02 <pastorn_> ?src words
16:39:02 <lambdabot> words s = case dropWhile isSpace s of
16:39:02 <lambdabot>     "" -> []
16:39:02 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
16:39:22 <dibblego> how does one @unlet with lambdabot? 
16:39:48 <pastorn_> @command
16:39:48 <lambdabot> Unknown command, try @list
16:39:52 <mrd> @clear
16:39:52 <lambdabot> Messages cleared.
16:39:52 <glguy> dibblego: @undefine
16:40:05 <glguy> @undefine flushes all of the @let s
16:40:06 <lambdabot> Undefined.
16:40:11 <glguy> like that
16:40:14 <SamB> chessguy: anyway, I'm particularly interested in freeing the .Char module from MonadParsec's clutches
16:40:17 <dibblego> thanks
16:40:46 <SamB> as well as eof and anyToken
16:45:28 <dons> ?users
16:45:29 <lambdabot> Maximum users seen in #haskell: 355, currently: 320 (90.1%), active: 17 (5.3%)
16:45:41 <dons> ?uptime
16:45:41 <lambdabot> uptime: 2d 16h 34m 17s, longest uptime: 1m 10d 23h 44m 29s
16:45:46 <dibblego> 355 is a pleasant number
16:46:05 <dibblego> reminds me of the small block chevy engine
16:46:27 <dibblego> (355 cu. in.)
16:46:32 <dons> heh
16:49:17 <tuukkah> ?type findM
16:49:19 <lambdabot> Not in scope: `findM'
16:49:30 <tuukkah> > let findM p = msum . map (\x -> p x >>= guard >> return x)
16:49:30 <lambdabot>  Parse error
16:49:59 <tuukkah> @let findM p = msum . map (\x -> p x >>= guard >> return x)
16:50:00 <lambdabot> Defined.
16:50:27 <tuukkah> > findM (return . Char.isDigit) "ab1234cd567" :: Maybe Char
16:50:28 <lambdabot>  Just '1'
16:50:36 <tuukkah> > findM (return . Char.isDigit) "ab1234cd567" :: [Char]
16:50:38 <lambdabot>  "1234567"
16:51:04 <pastorn_> ?type msum
16:51:06 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
16:51:59 <cedricshock> Is there a shortcut to rebuilding matched patterns (i.e. matching the whole pattern in one variable and smaller patterns in other variables)?
16:52:16 <ddarius> Yes
16:52:37 <ddarius> > let xs@(x:xt) = [1,2,4] in (xs,x,xt)
16:52:38 <lambdabot>  ([1,2,4],1,[2,4])
16:53:01 <cedricshock> Thanks
16:54:47 <tuukkah> now this was pretty useless as IO isn't in MonadPlus %-)
16:55:06 <ddarius> @instances MonadError
16:55:07 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
16:55:32 <Saizan> =instances MonadPlus
16:55:35 <Saizan> ?instances MonadPlus
16:55:36 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
16:55:46 <Saizan> IO is in MonadPlus
16:55:54 <ddarius> @src IO mplus
16:55:54 <lambdabot> m `mplus` n = m `catch` \_ -> n
16:56:08 <SamB> dons: hey, look at my package!
16:56:20 <SamB> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parsely-0.0
16:56:23 <lambdabot> http://tinyurl.com/2qzygr
16:56:44 <tuukkah> Saizan, oh, so i just need to import the instance
16:59:50 <tuukkah> instance MonadPlus IO -- Defined in Control.Monad.Error
17:01:21 <cedricshock> Yes, I got independent sets down to exponential time. That's good enough for my tiny graphs.
17:02:58 <dons> SamB: nice. what's it do? abstracts over something?
17:05:38 <SamB> dons: that is the idea but it doesn't do much of that yet ;-)
17:05:57 <SamB> hopefully I can implement it for monad transformers...
17:06:00 * SamB afk
17:17:10 <ddarius> Yay, good server again.
17:24:35 <SamB> dons: okay, so, I'm not sure that the things in .Char ought to be constrained to the MonadParsec class
17:26:59 <SamB> I don't much like having eof or anyToken in there, or satisfies, oneOf, and noneOf (and I don't see why these last three should be constrained to Char)
17:27:21 <SamB> but I'm not sure how they ought to work...
17:34:09 <glguy> in haddock, do I write @f@ to refer to another function in the file?
17:34:12 <glguy> in the comments?
17:34:31 <SamB> 'f' I believe
17:58:04 <ptolomy> Hm. I had code that went "if Map.member m x then <something> else <fromJust (Map.lookup m x) used> and I changed it to do a case Map.lookup of Nothing/Just, and now it is broken. Probably a typo somewhere, but I can't find it. 
17:59:25 <Saizan> ptolomy: uhm you've your if branches swapped, right?
17:59:52 <ptolomy> I don't think so.
18:00:09 * ptolomy struggles to put both versions on hpaste.
18:00:14 <dolio> @type findWithDefault
18:00:16 <lambdabot> Not in scope: `findWithDefault'
18:00:47 <Saizan> if Map.member m x then <here lookup succedes> else <here fails>
18:01:14 <chessguy> dolio, something with maybe?
18:01:28 <dolio> Could it be that you have your terms reversed? Map.lookup x m?
18:01:30 <chessguy> findWithDefault x = maybe x find ...
18:01:46 <dolio> chessguy: Well, findWithDefault exists, but lambdabot doesn't import it by default, I guess.
18:01:54 <Saizan> ?type Data.Map.member
18:01:55 <dolio> chessguy: Since it's in at least two modules.
18:01:55 <lambdabot> forall k a. (Ord k) => k -> Data.Map.Map k a -> Bool
18:02:03 <chessguy> oh
18:02:10 <chessguy> @hoogle finddwithdefault
18:02:10 <lambdabot> No matches found
18:02:13 <sjanssen> dolio, chessguy: lookupWithDefault IIRC
18:02:18 <sjanssen> @type lookupWithDefault
18:02:20 <lambdabot> Not in scope: `lookupWithDefault'
18:02:28 <sjanssen> @type Data.Map.lookupWithDefault
18:02:30 <lambdabot> Not in scope: `Data.Map.lookupWithDefault'
18:02:40 <sjanssen> @type Data.Map.findWithDefault
18:02:40 <dolio> @type Data.Map.findWithDefault
18:02:42 <lambdabot> forall a k. (Ord k) => a -> k -> Data.Map.Map k a -> a
18:02:43 <lambdabot> forall a k. (Ord k) => a -> k -> Data.Map.Map k a -> a
18:02:51 <sjanssen> huh, that's a bit inconsistent
18:02:57 <dolio> Yeah.
18:03:04 <hpaste>  ptolomy pasted "compress works, but compress2 is wrong. why?" at http://hpaste.org/1623
18:03:16 <ptolomy> paste'd.
18:03:38 <ptolomy> (Yeah, I'm a bad person for using fromJust)
18:04:09 <ptolomy> only the lines after let current =.. are changed.
18:05:02 <ptolomy> hmm.. think I figured it out. 
18:05:12 <Saizan> code = fromJust (tabFromStr tab str)
18:05:22 <Saizan> in compress you lookup str and not current
18:06:03 <ptolomy> ah. So right.
18:06:06 <ptolomy> Thanks.
18:06:12 * ptolomy forehead-smacks.
18:06:16 <Saizan> also because current is not inside tab in the else branch
18:06:59 <cpfr> odelay
18:07:30 <Saizan> hi
18:07:45 <cpfr> i am having troubles installing goa
18:07:55 <cpfr> how do i do it
18:08:24 <chessguy> hm, i keep hearing about goa lately
18:08:26 <chessguy> @where goa
18:08:26 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
18:08:33 <chessguy> is it new?
18:08:46 <cpfr> not sure
18:08:56 <Saizan> no, it was there when i first heard of lambdabot
18:08:56 <SamB> hmm.
18:09:09 * SamB wonders how to lift <?>
18:10:54 <chessguy> cpfr, seems to install ok for me, what seems to be the problem?
18:11:39 <cpfr> not having lambdabot i think
18:12:11 <Saizan> yeah, that surely is a problem
18:18:04 <ptolomy> hmm.. I'm surprised to find that it doesn't look like a Map of bytestrings is any faster than a Map of [Char].. in fact, seems a bit slower.
18:18:24 <sjanssen> ptolomy: there's a performance bug with Ord on ByteString
18:19:34 <ptolomy> sjanssen: Do you know what it is? I was looking at the code today, and it seems to use compareBytes, which does a memcmp... though it indicates that older code didn't bother checking lengths first.
18:21:27 <sjanssen> ptolomy: all FFI calls have a small overhead
18:21:44 <ptolomy> ah, that's right. I was wondering about that.
18:21:52 <sjanssen> the overhead turns out to be pretty significant compared to the cost of comparing lists
18:22:18 <sjanssen> small lists, that is
18:22:22 * ptolomy made that discovery when he learned that FFI round() is 10x slower than ghc internal double2int..
18:22:38 <sjanssen> if strings have small common prefixes, that is
18:24:32 <dons> more details for the Haskell Hackathon in Freiburg, http://haskell.org/haskellwiki/Hac_2007_II
18:24:33 <lambdabot> Title: Hac 2007 II - HaskellWiki
18:24:44 <dons> it will be run at Freibug uni, Fri-Sun after ICFP
18:30:45 <cpfr> Setup.hs: cannot satisfy dependency arrows-any
18:31:16 <SamB> where is Strafunski?
18:32:10 <SamB> er, in particular I want StrategyLib
18:32:34 <dons> cpfr, arrows is on hackage
18:32:36 <dons> ?hackage arrows
18:32:36 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/arrows
18:33:12 <cpfr> how do i get it
18:33:52 <SamB> I think I need it to implement Parsely for monad-transformed monads...
18:34:01 <SamB> cpfr: what distribution are you using?
18:34:13 <cpfr> freebsd
18:34:15 <dons> cpfr, just visit the site, and grab the tarball, then build it. otherwise, check your package system 
18:34:24 <dons> yeah, easier to just grab it from the above page.
18:34:33 <SamB> dons: it doesn't have a port?
18:39:10 <SamB> so, what the heck happened to StrategyLib? the zip seems missing...
18:41:46 <jgm> anyone here use the coq proof assistant?
18:41:53 <fax> ;_;
18:42:01 <fax> I tried but it was so hard.
18:42:10 <dons> alphecar does, jgm. but he's not around atm.
18:42:23 <fax> there is a dedicated channel on this network but I never dared venture to it
18:42:36 <jgm> I'm wondering why they use the fixpoint keyword for defining recursive functions, but nobody is home on #coq
18:43:06 <jgm> I'm aware of fixpoint combinators (e.g. y combinator), but I feel like I'm missing something
18:43:38 <dons> seems sensible that  you'd have to introduce it explicitly, does it?
18:43:55 <dons> doesn't it.
18:44:37 <jgm> well, haskel and lisp don't require different keywords for recursive functions. neither does acl2 for that matter.
18:45:09 <jgm> hence my confusion.
18:45:37 <sjanssen> jgm: it probably has something to do with ensuring termination
18:45:59 <edwinb> recursion in coq has to be well-founded
18:46:10 <edwinb> I think it's just so that it knows to check...
18:46:15 <cpfr> dons, where should i build arrows
18:46:39 <jgm> I understand the requirement for well-founded recursion. I guess I've just been spoiled by acl2 which is smart enough to handle that for me most of the time.
18:47:23 <edwinb> what's acl2?
18:47:31 <dons> cpfr: just in any directory -- /tmp for example -- follow the usual cabal configure/build/install steps 
18:47:46 <jgm> ACL2 == a computaional logic for applicative commmon lisp
18:48:03 <jgm> it's a programming language and logic built on a first order subset of common lisp
18:48:23 <xpika> why would filepath use the '\\' seperator when '/' works on windows?
18:50:05 <mm_freak> is there any utility like perldoc or pydoc for haskell?
18:50:14 <mm_freak> (for GHC specifically)
18:50:18 <sjanssen> haddock?
18:50:24 <jgm> mm_freak: have you tried haddock?
18:50:27 <sjanssen> I don't know exactly what perldock do
18:50:39 <mm_freak> perldoc is a `man'-like program
18:50:55 <mm_freak> "perldoc HTML::Template" shows the documentation page for the HTML::Template module
18:50:58 <jgm> are you trying to generate documentation or search for it?
18:51:09 <mm_freak> search for it
18:51:12 <xpika> hoogle
18:51:21 <mm_freak> isn'
18:51:24 <xpika> @where hoogle
18:51:25 <lambdabot> http://haskell.org/hoogle
18:51:28 <mm_freak> isn't hoogle an internet service?
18:51:34 <xpika> you can download it 
18:51:50 <mm_freak> % eix -sS hoogle
18:51:50 <mm_freak> Found 0 matches.
18:51:51 <mm_freak> =/
18:52:20 <mm_freak> well, is it man-like anyway?
18:52:26 <mm_freak> or would it start up a browser?
18:52:33 <mm_freak> (when installed locally)
18:52:39 <xpika> it has command line support
18:52:48 <mm_freak> interesting, thank you
18:53:31 <mm_freak> (almost everything about haskell seems to be below haskell.org, which is pretty pleasing)
18:54:10 <dons> mm_freak: yeah, we've put in a fair bit of effort to centralise everything
18:54:20 <dons> prior to 2003 or so, things were really spread all over
18:54:28 <mm_freak> well done
18:54:34 <dons> now you can get articles, papers, code, blogs all in one place
18:54:54 <dons> probably more centralised than any other language community?
18:55:11 <mm_freak> yeah, i don't know of any other such
18:55:30 <mm_freak> perl and tex are pretty centralized (CPAN and CTAN), but not as much as haskell
18:56:02 <dons> yeah, at least for centralised code. centralising blogs, wiki and research papers is the other big thing to do
18:56:20 <jgm> so, random question, what's the best way to get a patch into ghc's standard libraries? I've been mucking around with PF_PACKET sockets on linux and I've got some changes that could be useful to other people doing raw ethernet on linux systems.
18:56:46 <dons> if it would make a standalone library, best to do it that way, and upload it to hackage.haskell.org
18:56:51 <SamB> jgm: "darcs send"
18:56:57 <dons> if its a change to the base, it needs to be discussed via the libraries review process
18:57:24 * SamB sure hopes that's how you start the libraries review process ;-)
18:57:32 <dons> here's the guide to changing stuff in base, http://haskell.org/haskellwiki/Library_submissions
18:57:33 <jgm> actually, i've got a change to the standard socket's interface to add sockaddr_ll support (with marshaling/demarshaling)
18:57:33 <lambdabot> Title: Library submissions - HaskellWiki
18:57:38 <dons> SamB: not quite, but close.
18:57:49 <dons> jgm, right, so follow the above process.
18:57:58 <dons> basically, you submit a patch and start a feature ticket
18:58:04 <dons> which triggers discussion on the libraries@ list
18:58:05 <SamB> dons: I think someone should fix it so that that is how to do it
18:58:12 <jgm> dons: I'll do that
18:58:20 <dons> after 2 weeks or so, a decision is made
18:58:26 <dons> and the patch is applied , or not, or revised
18:58:38 <SamB> that is, you should be able to "darcs send" and it will make you a ticket ;-)
18:58:40 <dons> SamB, check the above process. unsolicited patches need other supporting documentation
18:58:44 <mm_freak> i'll need to get used to all those hterms thoughâ€¦  hackage, haddock, happy, â€¦
18:58:50 <mm_freak> cabal is probably the only exception
18:59:11 <SamB> mm_freak: what about alex
18:59:17 <emilliken> i've been using ffi for all my PF_PACKET needs 
18:59:17 <SamB> alex doesn't start with an h either
18:59:18 <dons> if you need to name a new haskell project, we have a tool for that:
18:59:20 <mm_freak> samb: ok, and WASH
18:59:21 <dons> ?freshname
18:59:21 <lambdabot> Hae
18:59:23 <dons> ?freshname
18:59:23 <lambdabot> Haf
18:59:28 <dons> that's a good project name
18:59:29 <dons> ?freshname
18:59:29 <lambdabot> Hag
18:59:31 <dons> ?freshname
18:59:31 <lambdabot> Hah
18:59:32 <mm_freak> lol
18:59:34 <dons> lots of great names
18:59:39 <SamB> mm_freak: wash has an h at the end
18:59:46 <jgm> ffi works for PF_PACKET, but integration with the standard sockets API is nice
18:59:52 <mm_freak> samb: true
19:00:08 <SamB> dons: does that check hackage for existing project names?
19:00:33 <SamB> I had to email asking for a library I want to use in mine
19:00:34 <mm_freak> btw, which web development package would you use?  WASH seems to be pretty popular, but aren't there any alternatives?
19:00:41 <dons> SamB, yes, actually, it submits a query to the patent office
19:00:41 <emilliken> jgm: true, but isn't PF_PACKET linux specific?
19:00:47 <dons> wash or happs, mm_freak 
19:00:48 <mm_freak> basically i just need templating
19:00:50 <emilliken> what about bpf for bsd
19:00:53 <dons> simple stuff i'd just use cgi/xhtml
19:01:06 <jgm> emilliken: yes, PF_PACKET is linux specific.
19:01:06 <dons> oh, then probably just the xhtml lib?
19:01:08 <mm_freak> and some fast interface like fastcgi, scgi or even an apache module
19:01:15 <SamB> oh, great, one of the individuals I had to email no longer exists... I mean, doesn't have that email address anymore...
19:01:17 <dons> yeah, fastcgi. see hackage for that.
19:01:24 <mm_freak> k
19:01:24 <dons> xhtml + fastcgi makes a pretty light web framework
19:01:36 <mm_freak> yeah, i'll try that out
19:01:49 <mm_freak> or maybe i write a module for SCGI, of there isn't any
19:01:53 <dons> possibly like this, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hxweb-0.1
19:01:55 <lambdabot> http://tinyurl.com/33x9ha
19:01:59 <dons> Fast template based web-framework using libxslt and fastcgi.
19:01:59 <dons> Dependencies  base, cgi, fastcgi, mtl, libxml, xslt
19:02:21 <dons> perhaps even just hack on that, rather than rolling a new one.
19:03:08 <jgm> libpcap is reasonably cross platform but I haven't played with that much. I'm doing more sending than receiving at the moment.
19:03:24 <dons> a pcap binding would be useful
19:03:32 <dons> (if we don't have one already)
19:03:33 <emilliken> maybe a libnet binding for sending..
19:04:03 <dons> http://www.haskell.org/networktools/src/pcap
19:04:05 <lambdabot> Title: Index of /networktools/src/pcap
19:04:23 <dons> we're in the state now you can almost *assume* the lib has at least been prototyped for whatever project you need :}
19:04:26 <dons> scary
19:04:27 <jgm> dons: I didn't see a pcap binding when I went looking. That didn't help the current project much as I've got to integrate with a proprietary RTOS anyway :(
19:04:36 <dons> http://hackage.haskell.org/packages/archive/pcap/0.2/doc/html/Network-Pcap.html
19:04:38 <lambdabot> http://tinyurl.com/2ntq9y
19:04:41 <dons> yeah, pcap seems to be on hackage
19:05:10 <jgm> dons: I should have looked harder
19:05:16 <dons> ?where+ pcap http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pcap-0.2
19:05:16 <lambdabot> Done.
19:05:41 <jgm> I just checked GHC standard libraries
19:05:52 <dons> that's cool. 'is there a library binding for X? hmm, maybe. you should write one. oh, hang on, yes, already done, and on hackage"
19:05:57 <mm_freak> dons: actually i don't like all-in-one frameworks or such
19:06:14 <mm_freak> they substitute freedom by comfort
19:06:18 <dons> jgm, extensions like that are going to be on hackage, rather than the standard libs
19:06:29 <mm_freak> and mostly they're more complex than necessary
19:06:33 <jgm> dons: cool, I'll keep that in mind
19:06:50 <SamB> mm_freak: well, some "all-in-one" frameworks may not be as "all-in-one" as others
19:07:21 <mm_freak> samb: still, i like to do it myself =)
19:08:11 <jgm> wow. Hackage is full of good stuff. I should have checked it out ages ago :)
19:08:22 <emilliken> there is Network.Socket.Raw, but I'm not sure how useful it is
19:08:54 <emilliken> It doesn't look like you can bind it to any interface
19:09:12 <jgm> Network.Socket.Raw is not as good as PF_PACKET (at least on linux). the sockaddr struct is not as good when doing recvfrom
19:15:50 * desp pokes Cale
19:15:56 <Cale> hello
19:16:07 <Cale> What's up?
19:16:08 <desp> Cale: do you have a webpage I could link to?
19:16:22 <desp> I'm writing a status update for my SoC project
19:16:29 <Cale> uh, I suppose cale.yi.org
19:16:31 <desp> and I'd like to mention the odd bug we found
19:16:43 <desp> crediting you for your help :)
19:17:12 <Cale> If you want, you can just use my full name, which is Cale Gibbard.
19:17:20 <desp> okay
19:17:39 <Cale> That is an odd bug, if you get a nice example, you should report it to the GHC list.
19:17:59 <Cale> Or, I think they have a trac database for them.
19:18:11 <mm_freak> is Char specifically an eight bit type?
19:18:11 <desp> I prepared a very simple example, but I should test it with more MVar-using functions
19:18:29 <desp> not sure if you got my message, http://varsztat.com/bug/
19:18:31 <lambdabot> Title: Index of /bug
19:18:31 <Cale> mm_freak: no, it's specifically large enough to hold any unicode character
19:18:37 <Saizan> > maxBound :: Char
19:18:38 <lambdabot>  '\1114111'
19:19:39 <desp> ugh.
19:19:49 <mm_freak> there he goesâ€¦  just wanted to answer him =)
19:21:38 <mm_freak> at least the services are on our side
19:22:39 <desp> we shall prevail.
19:24:02 <SamB_XP> so... where does it say that 1114111 is the largest unicode codepoint in decimal?
19:24:14 <SamB_XP> > printf "%x" 1114111
19:24:15 <lambdabot>  Add a type signature
19:24:18 <SamB_XP> > printf "%x" 1114111 :: String
19:24:20 <lambdabot>  "10ffff"
19:24:49 <sjanssen> SamB_XP: I'm sure you can find a source on unicode.org
19:24:53 <desp> that doesn't look like the largest unicode codepoint
19:25:11 <monochrom> I believe it.
19:25:29 <SamB_XP> I've also noticed that JHC seems to think wint_t goes from 0 to 0x10FFFF inclusive..., just like wchar_t
19:25:50 <SamB_XP> but I was pretty sure there was some WEOF or something that wasn't supposed to be a valid wchar_t
19:26:35 <desp> hm, so CJK takes less space than I thought
19:26:40 <monochrom> OK, but WEOF is not part of unicode, just part of some modern C convention.
19:26:52 <SamB_XP> yeah, I know ;-)
19:27:06 <SamB_XP> actually I'm pretty sure it is C standard
19:27:14 <SamB_XP> the convention is that wchar_t refers to unicode...
19:27:47 <lispy> unicode or just wide characters?
19:28:00 <mm_freak> no standard, but a convention
19:28:00 <desp> Error: No chart for code point U+110000 could be located. Most likely this is because no character is assigned to this code point yet.
19:28:04 <SamB_XP> lispy: standardly, they are wide characters
19:28:07 <mm_freak> you cannot enforce number bounds in C
19:28:08 <monochrom> Perhaps they really mean: wchar_t = Just Char | Nothing.
19:28:11 <Cale> whoops, sorry if people were talking to me at all
19:28:20 <SamB_XP> mm_freak: oh, sure the numbers are totally nonstandard there
19:28:25 <desp> Cale: did you get the link for my example this time? :)
19:28:29 <Cale> I got disconnected shortly after Saizan's "> maxBound :: Char"
19:28:30 <int80_h> grrr YAHT blows by binary trees
19:28:32 <Cale> desp: yes
19:28:43 <SamB_XP> but JHC only supports Unicode-based wchar_t anyway...
19:28:46 <Cale> desp: it's a nice example :)
19:28:56 <xpika> what does haskell RTS stand for
19:29:01 <Cale> runtime system
19:29:05 <xpika> ok
19:29:14 <monochrom> EOF and WEOF pollute programmer minds.
19:29:22 <lispy> oh, i though it meant: real-time strategy ;)
19:29:36 <desp> I keep mistaking it for RTC
19:29:38 <Cale> well, that's another possibility :)
19:29:45 <SamB_XP> lispy: well has anyone implemented a real time strategy in Haskell yet?
19:29:52 <SamB_XP> hmm.
19:29:58 <Cale> shapr was talking about it
19:29:59 <int80_h> Cale could you should me what sample output for treeSize from YAHT?
19:29:59 <monochrom> Control.Parallel.Strategy
19:30:01 <Cale> and I had some ideas
19:30:20 <SamB_XP> haskell being what it is, that sounds like it has more to do with scheduling tasks to meet hard time constraints rather than a game...
19:30:29 <Cale> int80_h: treeSize... what page? I can guess what it does.
19:30:29 <int80_h> data BinaryTree a = Leaf a | Branch (BinaryTree a) a (BinaryTree a)
19:30:48 <monochrom> treeSize (Leaf True) = 1 ?
19:30:51 <int80_h> I see hwt ait does, but can't figure out how to represent a tree
19:31:11 <int80_h> treeSize (Leaf x) = 1
19:31:12 <int80_h> treeSize (Branch left x right) = 1 + treeSize left + treeSize right
19:31:15 <lispy> Branch (Leaf True) False (Leaf True)
19:31:21 <Cale> right
19:31:36 <int80_h> cool
19:31:38 <mm_freak> cale: i'm asking because Network.Socket.send expects a Stringâ€¦  is every Char in the String a byte to send?
19:31:40 <monochrom> What happened to the empty tree?
19:32:03 <lispy> Leaf ()
19:32:12 <monochrom> I want no leaf.
19:32:37 <Cale> So, for instance,  treeSize (Branch (Branch (Leaf 1) 2 (Leaf 3)) 4 (Branch (Leaf 5) 6 (Leaf 7))) would be 7
19:32:49 <monochrom> I want to solve treeSize x = 0 for x.
19:33:26 <Cale> mm_freak: I believe so, unfortunately, I don't think it will do the right thing if the Char is too large.
19:33:36 <lispy> data Tree a = Monochrom | Leaf a | Branch (Tree a) a (Tree a)
19:33:44 <monochrom> I should stop making these demands and just go back to reading delimited continuations.
19:33:47 <Cale> monochrom: no solution :)
19:33:59 <mm_freak> cale: if it just truncates the Chars, then that's ok
19:34:06 <lispy> what do you call an empty tree?
19:34:10 <Cale> mm_freak: I suspect that's what it will do.
19:34:16 <Cale> lispy: Not a graph :)
19:34:39 <Cale> http://mathworld.wolfram.com/NullGraph.html
19:34:40 <lambdabot> Title: Null Graph -- from Wolfram MathWorld
19:34:42 <lispy> what happens if your binary tree is holding a binary tree?
19:34:54 <monochrom> Meta binary tree.
19:34:56 <lispy> Branch (Leaf 1) (Leaf 2) (Leaf 3)
19:34:58 <Cale> (I'm mostly kidding)
19:35:17 <monochrom> That is a type error.
19:35:29 <lispy> oh rigt
19:35:32 <lispy> duh :)
19:35:39 <lispy> Leaf 2 != Int
19:35:46 <Cale> Branch (Leaf (Leaf 1)) (Leaf 2) (Leaf (Leaf 3))
19:35:53 <lispy> there we go
19:36:10 <lispy> so, that's not really a binary tree
19:36:21 <lispy> it's a weird leafy thing
19:36:35 <Cale> I like how the null graph (with no vertices) has too many edges to be a tree.
19:36:50 <lispy> heh
19:36:51 <lispy> nice
19:38:51 <Cale> (Especially if you define a tree as a connected graph with n vertices and (n-1) edges.)
19:39:22 <monochrom> Oh, sorry, the empty tree has 1 node.
19:40:16 <Cale> As a datastructure though, you're probably right, it's a little unnatural not to include an empty tree.
19:40:22 <dolio> If I have an "Extensions:" list in cabal, should I remove the LANGUAGE pragmas from the .hs files?
19:41:58 <Cale> desp: for what you're doing, you shouldn't really need trace, you could use putTraceMsg or even probably just putStrLn.
19:42:15 <desp> right.
19:42:34 <desp> I've just grown accustomed to it :)
19:47:05 <monochrom> data BinaryTree a = Leaf a | Branch (BinaryTree a) a (BinaryTree a) deriving (Eq,Show)
19:47:12 <monochrom> newtype BT a = BT (BinaryTree (BT a)) deriving (Eq,Show)
19:47:17 <monochrom> -- heh heh heh!
19:47:23 <monochrom> x = Branch x (BT x) x
19:47:46 <jgm> monochrom: from what do you derive such glee?
19:47:51 <monochrom> Binary tree of binary tree of binary tree of ...
19:48:07 <jgm> (and don't say Eq, Show)
19:48:17 <monochrom> lispy mentioned "binary tree of binary tree" and that gave me ideas. :)
19:48:33 <jgm> :)
19:49:32 <cpfr> i am getting erros in goa
19:49:34 <cpfr> <interactive>:1:63:
19:49:34 <cpfr>     Not in scope: type constructor or class `String'
19:49:34 <cpfr> <interactive>:1:26: Not in scope: `lambdabot'
19:50:47 <desp> hm
19:51:00 <desp> > let foo = \ -> return ()
19:51:01 <lambdabot>  Parse error
19:51:13 <desp> is it possible to make a parameter-less lambda?
19:51:16 <Cale> Missing parameter for that lambda
19:51:17 <Cale> no
19:51:19 <nornagon> no
19:51:23 <nornagon> use const
19:51:24 <Cale> That's called a value :)
19:51:34 <Cale> > let foo = return ()
19:51:34 <lambdabot>  Parse error
19:51:39 <Cale> > let foo = return () in foo
19:51:40 <lambdabot>   add an instance declaration for (Show (m ()))
19:51:44 <desp> :)
19:51:49 <nornagon> or that :P
19:52:00 <desp> right... 5 am again
19:52:23 <ricky_clarkson> In a language without side-effects, what would a parameterless lambda do?
19:52:35 <desp> at least I'm not wrecking my darcs rep this time
19:53:16 <dibblego> > let f = \_ -> 5 in f 7
19:53:17 <lambdabot>  5
19:53:24 <mm_freak> isn't there any interface to select(), poll() or something similar?
19:53:29 <Cale> desp: _darcs looks so deliciously editable, doesn't it?
19:53:30 <nornagon> > let f = const 5 in f 7
19:53:31 <lambdabot>  5
19:53:48 <ricky_clarkson> Cale: My Java IDE certainly thinks so.
19:53:48 <desp> Cale: yes :/
19:54:09 <desp> Cale: I attempted to prettify my commit comments in _darcs/inventory
19:54:20 <desp> fortunately I was able to restore them later on
19:54:49 <desp> I think there really should be a way to edit those easily.
19:55:02 <desp> I know, unrecord, rerecord...
19:55:28 <desp> easily though.
19:55:32 <desp> or am I missing something?
19:55:58 <jgm> mm_freak: I don't know, I used async IO with posix realtime signals and used sigwaitinfo
19:56:35 <jgm> but that was with my own ffi calls, not standard libraries
19:56:47 <desp> mm_freak: select() is said not to play nicely with GHCs RTS
19:56:56 <desp> which is apparently build using select()
19:57:23 <mm_freak> hmmâ€¦  so what's the best way to handle multiple connections?  (besides multiple threads, of course)
19:57:26 <Cale> desp: maybe amend-record?
19:58:04 <mm_freak> (and without using FFI)
19:58:09 <desp> mm_freak: but it is also said that if you need to select() on fds that won't be accessed through other Haskell code, you can do that safely, writing your own FFI functions
19:58:09 <ricky_clarkson> If that comment about mysql appeared here, I haven't got a clue how.
19:58:27 <Cale> mm_freak: What's wrong with multiple threads?
19:58:38 <mm_freak> cale: they're overkill
19:58:42 <Cale> huh?
19:58:45 <jgm> mm_freak: don't fret the ffi. It's painless, really. Storable is your friend
19:58:48 <ricky_clarkson> irssi seems to be having 'issues' ignore that.
19:59:08 <mm_freak> cale: for my case, they would be overkill
19:59:10 <wli> 100,000 ciients aren't feasible to deal with using 1 thread per-client.
19:59:31 <mm_freak> many, possibly long-lived, but very idle connections
20:00:18 <jgm> mm_freak: which os are you using? have you considered /dev/epoll or the equivalent for your operating system?
20:00:19 <ricky_clarkson> I was wondering whether the old session-length problem could be solved with the evil Ajax.
20:00:21 <mm_freak> i can't imagine that System.IO forces me to use the FFI
20:00:34 <chessguy> ajax is not inherently evil
20:00:37 <chessguy> abused, yes
20:00:39 <ricky_clarkson> With Ajax you don't need a long session length, if you make the browser poll you.
20:00:47 <mm_freak> jgm: linux 2.6â€¦  i considered epoll, but never used it because it's not portable to linux 2.4
20:00:47 <chessguy> overly-obsessed-about, yes
20:00:54 <chessguy> but still useful
20:01:08 <ricky_clarkson> chessguy: Evil in the same way as chocolate, or possibly heroin.
20:01:28 <chessguy> ricky_clarkson, as in OD'ing?
20:01:29 <Cale> mm_freak: You can have threads block until there is data to read from an Fd.
20:01:33 <ricky_clarkson> Right.
20:01:44 <jgm> mme_freak: how portable do you want to be? any linux (2.4 or 2.6), any posix, or more broad?
20:01:45 <chessguy> sure
20:01:49 <desp> ricky_clarkson: I sure hope no Ajax-babies crawl on my ceiling
20:01:52 <Cale> (at least, in GHC)
20:01:53 <mm_freak> cale: threads use much more system resources than sockets
20:01:57 <chessguy> but you can do some pretty sexy-looking web apps with it
20:02:05 <chessguy> well, plus dojo
20:02:05 <Cale> mm_freak: Really?
20:02:15 <ricky_clarkson> desp: I've never made it past that point of Trainspotting.
20:02:17 <Cale> mm_freak: Threads are pretty lightweight.
20:02:28 <ricky_clarkson> I don't have kids but I find that hard to watch.
20:02:36 <Cale> mm_freak: They're handled internally by the GHC RTS.
20:02:39 <mm_freak> yesâ€¦  each one adds a kernel structure and increases scheduling load
20:02:44 <Cale> No
20:02:47 <Cale> They're in-process.
20:03:00 <Cale> unless you use forkOS
20:03:04 <mm_freak> they are separate process, just sharing the same address space
20:03:30 <desp> ricky_clarkson: Trainspotting is quite weak compared to, uh... this other film which I've completely forgotten the name of.
20:03:30 <ricky_clarkson> mm_freak: Don't limit your idea of threads to what OSs provide.
20:03:32 <Cale> forkIO doesn't rely on the operating system at all.
20:03:36 <wli> Cale: Green threads etc. aren't free, either. Context switches aren't cheap in userspace, either.
20:03:40 <mm_freak> they are more lightweight than separate processes, but still take more resources
20:03:47 <ricky_clarkson> mm_freak: Take a look at Erlang's threads, for example.
20:03:51 <mm_freak> and reallyâ€¦  for such an application it's just wasting resources
20:03:58 <Cale> You're using Haskell.
20:03:59 <desp> mm_freak: Haskell threads != OS threads
20:04:00 <jgm> GHC threads are more like coroutines in terms of cost than OS threads.
20:04:07 <mm_freak> oh
20:04:12 <Cale> Values are boxed :)
20:04:14 <wli> Cale: On x86(-64), for instance, anything that screws with the stack pointer in an unusual way is dogslow.
20:04:19 <Cale> That uses more resources too :)
20:04:40 <mm_freak> well, it's confusing to call them "threads"â€¦  that's why i never considered them =)
20:04:53 <mm_freak> wellâ€¦  does it use some polling scheme internally?
20:04:54 <monochrom> Ever heard of "green threads"?
20:05:00 <ricky_clarkson> I think programming languages were calling them threads before OSs were.
20:05:09 <mm_freak> ricky_clarkson: yeah, that might be
20:05:16 <wli> Cale: They also require their own stack buffers, albeit allocated in userspace.
20:05:22 <desp> ricky_clarkson: Requiem for a Dream.
20:05:24 <monochrom> Java had green threads long before anyone complained.
20:05:36 <desp> Erlang threads >> green threads.
20:05:38 <desp> ;)
20:06:07 <ricky_clarkson> desp: I think I watched that.  I seem to remember the music being amazing.
20:06:10 <desp> I wish Haskell had more Erlang inside.
20:06:15 <monochrom> I wonder if GHC threads switch the hardware stack pointer.
20:06:17 <Cale> In GHC, threads created by forkIO are lightweight threads, and are managed entirely by the GHC runtime. Typically Haskell threads are an order of magnitude or two more efficient (in terms of both time and space) than operating system threads.
20:06:24 <wli> Well, if you're doing it right, you have one OS thread per-cpu serving as engines to execute the user threads.
20:06:27 <Cale> (from the GHC documentation)
20:06:30 <mm_freak> so how do i launch a separate thread for each connection?  do i need to use `par' and compile with threading support?
20:06:32 <desp> ricky_clarkson: yup, that's probably it.
20:06:37 <mm_freak> or is there anything specific?
20:06:42 <Cale> no, you forkIO
20:06:51 <Cale> :t Control.Concurrent.forkIO
20:06:53 <lambdabot> IO () -> IO GHC.Conc.ThreadId
20:07:01 <mm_freak> a "haskell thread" that is, not an OS thread =)
20:07:19 <wli> mm_freak: User thread vs. kernel thread.
20:07:31 <Cale> You don't need to do anything special to get threading support.
20:08:05 <wli> ISTR ghc trying to do M:N threading, which is good, though relatively futile on Linux.
20:08:14 <wli> At least for systems tasks.
20:08:44 <mm_freak> cale: i would write an accept loopâ€¦  would this allow more than one client automagically?  or do i need to use forkIO specifically?
20:08:45 <SamB_XP> it's not so futile if you have a lot of threads waiting on MVars or what-have-you
20:09:07 <wli> SamB_XP: Yes, in that case it will blow the doors off 1:1 threading.
20:09:43 <wli> I've never really tried the concurrent or parallel stuff.
20:09:49 <Cale> mm_freak: Well, you need to use forkIO somewhere if you want the accept loop to continue while you handle that user. I can probably get you an example off the wiki somewhere.
20:10:17 <mapreduce> Goddam, freenode's nickserv is retarded.
20:10:36 <wli> There are all sorts of horrible system constraints on Linux because aio is so screwed up.
20:10:36 <SamB_XP> mapreduce: what exactly do you mean?
20:10:40 <sjanssen> mapreduce: your name is mapfoldr here
20:10:51 <mm_freak> cale: i don't need an example, just understand the semantics
20:10:54 <SamB_XP> sjanssen: no, I think it is mapfold
20:11:02 <mapreduce> I identify, change nick, now I'm unidentified.
20:11:20 <SamB_XP> because mapreduce is specifically supposed to use an associative, commutative binary operation
20:11:21 <mm_freak> haskell is `parallel by nature', so theoretically it would be possible to just use accept
20:11:38 <wli> mm_freak: Oh, nothing so easy is possible.
20:11:40 <monochrom> IO does not parallelize automatically
20:11:42 <SamB_XP> mm_freak: not at the IO level it isn't
20:11:43 <Cale> mm_freak: You use accept and then pass the result to a function which will forkIO
20:11:43 <desp> mapreduce: you're a whole new different person now! woop
20:11:54 <Cale> wli: It really is easy.
20:12:41 <lispy> mapreduce: it's probably that way for 'security' purposes
20:12:41 <wli> Cale: Not at all. Most essential calls for creating and destroying fd's have no async or nonblocking equivalents/extensions.
20:12:42 <mm_freak> wli: it would be possible, but it would also run against my view that accepting is a blocking operation
20:13:04 <lispy> mapreduce: are both your nicks associated with the same identity?
20:13:09 <mapreduce> lispy: Yes, we have a door like that at work.  I let anybody in through it.
20:13:42 <sjanssen> mapreduce: even people carrying baseball bats
20:13:47 <sjanssen> ?
20:13:48 <mapreduce> lispy: The problem is that IRC forces an arbitrary name, much as most if not all programming languages do.
20:13:52 <mm_freak> ah
20:13:59 <mm_freak> "Scheduling of Haskell threads is done internally in the Haskell runtime system, and doesn't make use of any operating system-supplied thread packages."  â‡ that explains everything
20:14:00 <mapreduce> sjanssen: As long as I'm on my way out, sure. ;)
20:14:22 <wli> Cale: If you try to spawn an OS thread for each possible blocking call, you threadbomb rather quickly under most circumstances.
20:14:32 <Cale> wli: Er, I'm not sure I see why that matters. You accept connections in your main thread, in a loop, and that might block until a connection is available, and when it is, you fork off another thread to handle it, and in the main thread, you go right back to accepting connections.
20:14:38 <Cale> These aren't OS threads.
20:14:47 <sjanssen> wli: the RTS is pretty smart about sharing OS threads
20:15:10 <sjanssen> wli: and only certain things (specifically FFI calls) need a dedicated OS thread
20:15:13 <wli> Cale: If you block, you're dead. All the clients stall while the OS thread is off in la-la land.
20:15:37 <Cale> Huh?
20:15:46 <Cale> I'm not talking about an OS thread.
20:16:05 <wli> Cale: Well, green threads only need one blocking call to stall the whole app.
20:16:05 <geezusfreeek> Cale: green threads don't offer any way to continue execution in other threads while one thread is blocked by the system
20:16:30 <sjanssen> wli: you should read the recent SMP GHC paper -- they've written a very clever implementation
20:16:31 <Cale> What, you mean if you're making foreign calls that block?
20:16:34 <wli> Cale: M:N threading just needs M simultaneous blocking calls.
20:16:47 <sjanssen> geezusfreeek: GHC's threading implementation is smart enough to do it
20:16:53 <monochrom> Too much talk. All of you.
20:16:56 <hpaste>  monochrom pasted "accept and forkIO example" at http://hpaste.org/1625
20:17:10 <geezusfreeek> sjanssen: then ghc's implementation must be sneaking some os threads in there, right?
20:17:13 <monochrom> Now why don't you play or benchmark that example and see for yourself?
20:17:24 <sjanssen> wli: GHC keeps M OS threads, where M should be equal to the number of cores you have
20:17:29 <geezusfreeek> at least for the blocking syscalls?
20:17:44 <SamB_XP> geezusfreeek: what blocking syscalls?
20:17:44 <Cale> Blocking of Haskell IO shouldn
20:17:50 <sjanssen> wli: things that block on IO are handled by GHC's scheduler, which select()s across file descriptors
20:17:53 <Cale> shouldn't occur at the OS thread level
20:17:54 <wli> sjanssen: Well , this is a general problem with Linux' IO subsystem, so there's no difference between e.g. Haskell programs and Oracle.
20:17:58 <SamB_XP> you mean read() on on-disk files?
20:18:34 <mm_freak> cale: will blocking IO operations automatically `yield'?
20:18:48 <sjanssen> wli: foreign calls that might block get their very own OS thread (allocated from a pool), so there might be M + ffi calls OS threads running
20:18:51 <Cale> mm_freak: yes.
20:18:58 <sjanssen> geezusfreeek: yeah, it's a hybrid system
20:19:28 <wli> sjanssen: Yes, that's the thread bomb scenario.
20:19:29 <mm_freak> cale: is this behaviour portable to non-GHC compilers?
20:19:32 <Cale> mm_freak: Well, native blocking IO operations.
20:19:32 <alvarezp> oin #postfix
20:19:35 <lispy> sjanssen: but doesn't that contradict the statement that ghc doesn't use any os threading packages?
20:19:50 <Cale> mm_freak: Not necessarily. Different implementations have slightly different blocking behaviour.
20:19:53 <sjanssen> lispy: who made that statement?  It is false
20:20:23 <mm_freak> k
20:20:28 <Cale> Using GHC without -threaded, foreign calls will block other Haskell threads, but IO operations won't.
20:20:33 <lispy> sjanssen: mm_freak
20:20:47 <Cale> With -threaded, only foreign calls with the unsafe attribute will block all other threads.
20:21:22 <Cale> Under Hugs, basically everything blocks all other threads ;)
20:21:33 <wli> How about ghci?
20:21:34 <mm_freak> sjanssen: which statement is false?  i've just read that haskell doesn't use OS threads, if you don't request them specifically
20:21:38 <Cale> ghci is GHC.
20:22:06 <sjanssen> mm_freak: GHC uses OS threads internally -- it's a hybrid approach
20:22:18 <sjanssen> it schedules N Haskell threads among M OS threads
20:22:33 <monochrom> Where M is very small.
20:22:40 <wli> I guess you actually have to spawn threads or use the Control.Parallel affair.
20:22:48 <sjanssen> mm_freak: so your statement that GHC does most of the scheduling is true
20:23:11 <mm_freak> sjanssen: actually i wasn't stating at all, i was asking
20:23:15 <monochrom> Clearly, any program has to occupy at least one OS thread. :)
20:23:46 <lispy> monochrom: ah and i guessed that M was like -1e19
20:23:49 <SamB_XP> monochrom: ... what if you don't *have* an OS?
20:23:50 <sjanssen> mm_freak: I suggest you read the GHC SMP paper
20:23:52 <Cale> wli: Control.Parallel is for pure computations.
20:23:53 <lispy> because that number is....very small :)
20:24:01 <wli> sjanssen: It's also the case that for this to really hurt you, you need to (a) be doing a lot of IO on a lot of CPU's and (b) heavily mixing numerous different sorts of IO.
20:24:09 <mm_freak> however, if forkIO uses IO threads, then that's fineâ€¦  it's ok if it does spawn a limited number of OS threads, where it sees necessity
20:24:09 <wli> Cale: That's mostly what I want it for, yeah.
20:24:16 <monochrom> SamB_XP: how do you run a haskell program without an OS?
20:24:31 <mm_freak> sjanssen: i will
20:24:31 <SamB_XP> lispy: um, M defaults to being in the naturals...
20:24:41 <Cale> monochrom: By converting the GHC runtime system into its own OS.
20:24:51 <Cale> ;)
20:24:54 <wli> sjanssen: From ghc's POV the sort of problems I'm on about are probably not terribly relevant.
20:24:56 <mm_freak> monochrom: see HOUSE
20:25:01 <mm_freak> an operating system written in haskell
20:25:35 <Cale> mm_freak: Yeah, it just spawns OS threads enough to get benefits of SMP
20:27:20 <wli> sjanssen: Also, on Solaris or FreeBSD, for example, this will all work beautifully, so it's all Linux' fault.
20:28:49 <sjanssen> mm_freak: http://research.microsoft.com/~simonpj/papers/parallel/index.htm  really fascinating paper
20:28:50 <lambdabot> Title: Haskell on a shared-memory multiprocessor
20:28:53 <dibblego> ?info seq
20:28:53 <lambdabot> seq
20:28:59 <dibblego> ?docs seq
20:28:59 <lambdabot> seq not available
20:29:39 <wli> sjanssen: One of my co-workers (Zach Brown) is doing a lot of work to fix the issues with Linux in this regard.
20:29:57 <sjanssen> wli: oh, neat.  Where do you work?
20:30:05 <wli> sjanssen: Oracle
20:30:24 <sjanssen> wli: I jumped in the middle of the conversation, so I didn't quite catch that you were talking about OS limitation
20:30:27 <mm_freak> sjanssen: thanks
20:30:39 <sjanssen> wli: ah, I suppose you guys care a lot about those issues ;)
20:31:27 <dibblego> ?type ($!)
20:31:36 <lambdabot> forall a b. (a -> b) -> a -> b
20:31:45 <dibblego> ?src ($!)
20:31:46 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
20:32:07 <wli> sjanssen: Yeah, it's also why I watch things like transient/etc. errors that are possible to come from the OS like a hawk. The database doesn't handle quite all of them like it should, and they complain when they happen in the OS. This is why I go on about error handling in the IO library routines etc.
20:33:24 <wli> sjanssen: Short reads and writes on disk IO are the nemesis here ("fractured blocks" is the database jargon for it).
20:34:24 <wli> sjanssen: But most transient errors come back as "OS bugs" and they crop up all over the place.
20:36:17 <wli> I've not seen an error monad that distinguishes between hard failures and failures necessitating retries or partial completion yet.
20:37:50 <wli> EINTR, EAGAIN, and short IO's vs. EIO, EBADF, EFAULT, EISDIR, EINVAL, and "others."
20:38:09 <mm_freak> cale: from the documentation it sounds like forkIO does not launch OS threads ever
20:38:20 <mm_freak> like i _need_ to use forkOS for that
20:38:32 <sjanssen> mm_freak: that's right
20:38:39 <sjanssen> mm_freak: why do you need to make an OS thread?
20:39:21 <Cale> sjanssen: even with SMP?
20:39:21 <mm_freak> sjanssen: because in the future i'll use haskell for expensive calculations on multicores
20:39:38 <mm_freak> cale: sounds likeâ€¦  i've just read the documentation for Control.Concurrent
20:39:59 <sjanssen> Cale: it never starts an OS thread -- but it might get started on an idle OS thread (launched via +RTS -N
20:40:11 <sjanssen> mm_freak: you don't have to worry about this, GHC handles it all transparently
20:40:11 <Cale> ah, right, okay
20:40:17 <monochrom> Yeah, look up +RTS -N too.
20:40:33 <sjanssen> mm_freak: just compile with -threaded and run your program with +RTS -Nnumberofcores
20:40:41 <wli> data Result t = Success t | PartialCompletion t Int | TransientError TransErrType | HardError HardErrType ?
20:40:43 <mm_freak> sjanssen: so the RTS _might_ decide to launch OS threads when using -M ?
20:40:44 <SamB> well, not *quite* transparently, but you don't need to do it in code ;-)
20:40:50 <mm_freak> uhm
20:40:51 <mm_freak> -N
20:40:58 <mm_freak> k
20:41:14 <SamB> it should have already launched them
20:41:15 <Cale> mm_freak: It will launch N OS threads, and then assign Haskell threads to them automatically.
20:41:16 <cpfr> is there anyway to make goa follow symlinks
20:41:16 <wli> No clue how to deal with that sort of thing in a monad.
20:41:25 <sjanssen> mm_freak: Haskell threads are scheduled fairly across all your cores
20:41:29 <Cale> My thinking about it was a little off :)
20:41:50 <sjanssen> mm_freak: read the paper -- we're just parroting the word of the Simons :)
20:41:53 <Cale> wli: That type looks like a monad to me.
20:41:59 <mm_freak> sjanssen: i'm reading it
20:42:40 <wli> Cale: Maybe monads can handle it.
20:43:08 <wli> Cale: I'm clueless as to what on earth the monad laws/operations for it would be, of course.
20:43:41 <Cale> wli: I'll think about it
20:43:48 <wli> Cale: Partial completions don't seem to compose well at all.
20:43:56 <Cale> well, yes
20:44:17 <Cale> the fact that that's a t and not some other type param is a little worrying
20:44:36 <wli> Cale: If you have an array fill broken down into a series of IO's filling pieces of the array and get partial completions you get a mess.
20:44:49 <wli> Cale: I'm not wedded to the type at all.
20:45:17 <Cale> If it was another type parameter, it would look almost exactly like the Error monad.
20:45:39 <Cale> (or Either, with a couple extra cases)
20:46:36 <wli> Only hard errors really compose. Transient errors and partial completions seem to behave more like a monoid.
20:46:43 <Cale> er, hmm, I suppose this is still somewhat composable, after all, you do have a value of type t when you get partial completion
20:47:09 <Cale> well, you'll just have the errors completely jump out of the computation
20:47:23 <Cale> except these partial completions, where you can just continue
20:47:49 <wli> Cale: Transient errors are also correctable, they just don't yield any sort of result at all.
20:48:10 <wli> Cale: Basically partial completion with zero data.
20:48:15 <Cale> The problem with partial completions is going to be that the information will be thrown away by bind.
20:49:14 <Cale> instance Monad Result where
20:49:14 <Cale>     return x = Success x
20:49:14 <Cale>     (Success x) >>= f             = f x
20:49:14 <Cale>     (PartialCompletion x n) >>= f = f x
20:49:14 <Cale>     e@(TransientError t) >>= f    = e
20:49:15 <Cale>     e@(HardError h) >>= f         = e
20:49:57 <Cale> hmm...
20:50:04 <wli> Cale: I'm not sure the transient error case is right, since those should lead to retries.
20:50:43 <Cale> Well, you can't really do anything about it at that point, because the part of the computation which lead to the transient error is gone.
20:50:45 <Cale> led8
20:50:47 <Cale> led*
20:50:52 <Cale> my typing sucks :)
20:50:57 <desp> Cale: http://varsztat.com/news/#loopy-loop :)
20:50:59 <lambdabot> Title: Varsztat
20:51:00 <wli> Cale: The partial completion case also needs the remainder of the IO to get retried at some point vs. just working with the part that succeeded.
20:52:04 <Cale> yeah, so you're not really looking at this being a monad in and of itself, but you need some structures over IO for dealing with these results of IO computations.
20:52:09 <wli> A computation is of the form "try to get n"
20:53:48 <wli> A result is of the form "you got all n" or "you actually got k for 0 < k < n" or "you got nothing, but you can try again" or "you got nothing, and it's useless to try again."
20:54:21 <Cale> What you could do is to write a function of some type like  IO (Result t) -> IO (Either HardError t)
20:54:26 <wli> Where the two "you got nothing" cases have reasons attached.
20:54:42 <Cale> Which would retry the computation as necessary.
20:55:05 <Cale> Though I'm not quite sure what it would do with the reasons...
20:55:20 <Cale> Oh, I suppose you could take an extra parameter for dealing with partial results.
20:55:51 <Cale> So that it would run the code for partial results and then try again until it got Success or a HardError.
20:55:51 <wli> The bigger gotcha is that errors for write() may not be visible until close().
20:56:30 <Cale> Basically, if you can decide on a pattern for dealing with failures, you can turn it into a control structure.
20:57:26 <wli> Worse yet the deferred errors are imprecise. They don't say what part of the IO failed nor do they give very specific causes.
20:58:45 <desp> 'nite
20:59:10 <Cale> ((t,Int) -> IO ()) -> (TransErrType -> IO ()) -> IO (Result t) -> IO (Either HardErrType t)
20:59:28 <wli> Looks plausible.
21:00:22 <wli> This seems to need some beating on by people remotely competent in monadic/etc. programming, so I can't really help much beyond adversary arguments.
21:00:40 <Cale> OTOH, if transient errors keep happening over and over, there might be a problem.
21:00:58 <Cale> I could write you a function of that type, very easily.
21:01:07 <wli> Yeah, that's why you don't implicitly do endless retries.
21:01:46 <wli> Cale: But can real IO be meaningfully plugged into it? I don't know.
21:03:11 <Cale> Well, depends on your application, but sort of, yes. The infinite loop on transient errors would be something to work on. Basically, if you can work out the kind of strategy you want to use for handling errors, you can encode it as a combinator.
21:03:31 <wli> There's another trick, which is that the IO boundaries may not respect data structure boundaries.
21:03:49 <Cale> One thing worth considering is looking at functions of type IO (Result t) -> IO (Result t), which would then be composable
21:04:13 <wli> So you might have a partial completion representing an IO that stopped in the middle of a list element.
21:04:14 <Cale> So you could write something which attaches a transient error handler for one kind of transient error
21:04:28 <Cale> Or a partial completion error, separately.
21:05:44 <Cale> It's also worth noting that the IO monad has exceptions in it.
21:05:49 <wli> Partial completions can basically stop on any byte boundary vs. composite data structures where you've got all of one or none of one.
21:09:48 <wli> About all I can say for sure right now is that the IO library seems to have issues.
21:12:56 <dons> re.
21:15:13 <wli> re dons
21:17:30 <Cale> dons: hey, did you see that lambda animator?
21:17:41 <Cale> dons: The examples for it cite you :)
21:18:37 <dons> oh?!
21:18:49 <dons> url please!
21:18:58 <Cale> "This example demonstrates stream fusion. The stream stepper technique used it taken from Coutts, Leshchinskiy and Stewart's ICFP 2007 paper: From Lists to Streams to Nothing at All, and used here in an untyped setting."
21:19:05 <Cale> http://thyer.name/lambda-animator/
21:19:07 <lambdabot> Title: Lambda Animator
21:19:15 <Cale> http://programming.reddit.com/info/25mfe/comments
21:19:16 <lambdabot> Title: Animate programs in the lambda calculus as they run (reddit.com)
21:19:21 <dons> wow
21:20:18 <dons> where's the "stepper" quote?
21:20:32 <Cale> On the "Examples" page in the applet
21:20:36 <sjanssen> bah, Java is broken on my machine
21:21:11 <Cale> It requires both java and a local installation of graphviz.
21:21:28 <Cale> sjanssen: What kind of machine?
21:21:49 <sjanssen> Cale: Linux.  It's the XCB based Xlib, Java brokenness trips over it
21:22:16 <dons> huh
21:22:48 <Cale> Hm, yeah, I don't know what to do about that. I used to hate installing Java, but Debian and Ubuntu have gotten quite good at it lately, at least under ordinary circumstances.
21:23:19 <dons> very cool. 
21:24:32 <dibblego> > System.Time.getClockTime
21:24:33 <lambdabot>   Not in scope: `System.Time.getClockTime'
21:25:30 <sjanssen> oh, neat.  There's a workaround
21:25:34 <sjanssen> sudo sed -i 's/XINERAMA/FAKEEXTN/g' /opt/sun-jdk-1.5.0.11/jre/lib/i386/xawt/libmawt.so :)
21:26:19 <Cale> The presentation is not quite as good as HOPS, but then Dr. Kahl doesn't seem to have released HOPS yet, after all this time. :)
21:27:08 <Cale> It doesn't preserve any of the names of things when it generates the code graphs.
21:27:35 <Cale> sjanssen: wow.
21:35:15 * shapr frizzles
21:35:54 <shapr> Cale: Yeah, whatever happened with HOPS? I was looking forward to the sequel BOINGS.
21:37:23 <Cale> shapr: You might send him an e-mail prodding him to do a release. He probably has forgotten about it. iirc, he's working on Data.Rel, but I'm not sure if any of that's been released either.
21:37:40 <Shimei2> So, for fun I decided to try to get the old TclHaskell 1.2 library (which I think is basically dead?) working. I got hello world running! :)
21:37:55 <dons> Shimei2: cool!
21:38:02 <dons> Shimei2++ great work. 
21:38:16 <dons> bring it back to life, zombie style
21:39:00 <Shimei2> I find it amusing because it died before darcs was even invented.
21:39:01 <Cale> There are so many Haskell libraries which are bitrotting away.
21:39:14 <SamB> dons: oh, can you run "make all" for chayenne?
21:39:56 <dons> lib from before darcs + cabal tend to suffer a bit
21:40:06 <dons> they need a lot of maintainance, in comparison to cabalised stuff
21:40:26 <SamB> StrategyLib seems to have rotted completely away
21:40:38 <SamB> I got a 404 when I tried to download it :-(
21:40:45 <dons> contact the authors
21:40:50 <dons> wasn't that from last year's ICFP?
21:40:52 <SamB> I sent an email
21:41:00 <dons> or did it end up in strafunksi or something?
21:41:07 <SamB> This is an automatically generated Delivery Status Notification
21:41:07 <SamB> Delivery to the following recipient failed permanently:
21:41:07 <SamB>     jvisser@cwi.nl
21:41:27 <SamB> dons: it is indeed offered for download on the strafunski page.
21:41:34 <SamB> however the webserver does not deliver :-(
21:41:44 <dons> google will be your friend.
21:41:56 <dons> but also check the generic haskell page on haskell.org
21:42:03 <dons> it might be able to dig up some dirt
21:42:47 <SamB> well, I think it's encouraging that I only got an error for one of the two authors
21:43:06 <Cale> SamB: maybe the Archive picked it up?
21:43:32 <dons> SamB: Joost is still around, google should find him
21:44:19 <SamB> I think they forgot to change his email at the bottom
21:44:26 <SamB> they changed the weblink above it
21:44:42 <SamB> hmm, but the site isn't there...
21:45:48 <SamB> Cale: oh, yes, it does seem to have...
21:45:58 <SamB> but it keeps restarting my download in the middle ???
21:46:05 <Cale> SamB: heh
21:46:49 <SamB> 49% [=================>                   ] 107,131       85.82K/s             
21:46:49 <SamB> 49% [=================>                   ] 107,131       82.97K/s             
21:46:49 <SamB> ...
21:48:12 <SamB> and of course the first half of any zip file is entirely useless without the directory at the end of the file...
21:52:04 <jcreigh> oh, the directory isn't at the beginning of a zip file? Makes sense, I suppose. Then zip programs can stream writes to the disk.
21:53:22 <scook0> jcreigh: helpful for disk spanning too, back in the day
21:53:33 <SamB> I'm not exactly sure how it works, but the most vital information is in the vicinity of the end of the file
21:53:46 <shapr> dons: Did you write a wget-style curses progress bar in Haskell?
21:53:50 <shapr> I wanted one recently...
21:53:57 <SamB> You can start a file with a GIF and end it with a ZIP, I'm pretty sure
21:54:18 <Cale> shapr: I recently wrote one in bash, hehe :)
21:54:37 <Cale> well, not curses, just tput commands
21:55:21 <Cale> Kind of silly, I'm sure it would be simpler in Haskell.
21:55:52 <shapr> I thought dons already wrote one for something, but I couldn't find it recently.
21:57:55 <SamB> shapr: hmp3?
21:58:01 <Cale> yeah, that seems likely
21:58:05 <Cale> http://cale.yi.org/index.php/Shell_Scripts#ruler :)
21:58:08 <lambdabot> Title: Shell Scripts - CaleWiki
21:58:11 <SamB> not that that's very wget-like
22:01:06 <dons> ok wow. i just saw ghc run zipWith (+) on the nvidia GPU 
22:01:14 <dons> Haskell on the GPU is here!
22:01:33 <jcreigh> My god...it's full of polygons!
22:01:57 <dons> so when you write: gpuZipWithPlus [1..10] [20..30], it actually dispatches to the gpu to do the op in parallel dedicated hardware
22:02:05 <Pseudonym> GPU, OLPC... what's next?  Haskell on the Furby?
22:02:25 <dons> and there's already map,filter,foldl/r,scanl/r, zip, sum, 
22:02:33 <dons> so bytestrings on the gpu are only maybe half a days work 
22:02:33 <mrd> cool, finally something to use on my geforce 8800
22:02:56 <dons> want to map toUpper over a bytestring -- do it with dedicated hardware!
22:03:01 <SamB> Pseudonym: yes, we've just about figured out how to get a haskell interpreter running on a 6502
22:03:24 <Pseudonym> Port it to the AVR and I'll be laughing.
22:03:26 <RyanT5000> is there any way to avoid writing the absolute name of a module inside it?
22:03:36 <mrd> dons: does it need working opengl video drivers
22:03:39 <SamB> dons: and this works on OpenBSD?
22:04:03 <RyanT5000> also, why is that the way we do things?
22:04:06 <scook0> RyanT5000: i.e. in "module Foo.Bar where", you want to omit the "Foo"?
22:04:11 <RyanT5000> yeah
22:04:24 <SamB> RyanT5000: don't even try it
22:04:32 <dons> SamB: only tried it on linux.
22:04:33 <mrd> no, and because hierarchical modules are a tagged on extra
22:04:36 <dons> needs CUDA 
22:04:40 <SamB> we like to remember where we are...
22:04:42 <dons> the nvidia GPU compiler
22:04:46 <dons> nvcc
22:04:51 <Pseudonym> This would be a very useful feature.
22:04:56 <mrd> isn't that for shaders?
22:04:57 <SamB> dons: to build or to run?
22:05:02 <dons> to build
22:05:02 <SamB> mrd: well yes ;-)
22:05:03 <RyanT5000> SamB: yes, but if i decide i want to move a module, why should i have to edit it?
22:05:05 <Pseudonym> It would mean you could import a project into a subdirectory of yours.
22:05:13 <Pseudonym> Local namespace and all that.
22:05:15 <dons> and you get a chunk of cpu code, linked against a bit of gpu code nvcc produces
22:05:18 <RyanT5000> yeah, which would be kind of handy
22:05:25 <SamB> the idea is to make shaders that do what you want!
22:05:37 <SamB> didn't you know that you could write a map toUpper shader?
22:05:39 <Pseudonym> I want a shader to make me some coffee.
22:05:44 <dons> nah, that's old school, SamB. these days you just write cuda code, and nvcc compiles it to a shader
22:05:58 <SamB> dons: doesn't that count as writing a shader?
22:06:17 <SamB> this whole idea of having shader assembly languages is kind of newfangled
22:06:30 <SamB> the real oldschool way is EXPRESSIONS
22:06:38 <dons> we're talking general purpose shader programs now though
22:07:00 <SamB> but can you run POV-Ray on the GPU yet?
22:07:15 <dons> when i'm sitting here running zipWith on the graphics card, who'd know it was anything other than a dedicated haskell combinator machine :-)
22:07:50 <SamB> now all we need is GPU monitoring for gkrellm and top(1)
22:08:06 <SamB> did I mention that I actually have an nvidia GPU now?
22:08:10 <wli> I thought the underlying execution models were stack machines.
22:08:40 <Pseudonym> These "general purpose shader programs" are really new.  Like, 1989 new!
22:08:53 <SamB> Pseudonym: what do you mean?
22:09:12 <Pseudonym> I have a book on my shelf called "The RenderMan Companion", circa 1989, which describes the direct ancestor of Cg.
22:09:21 <SamB> ah, yes, that.
22:09:36 <Pseudonym> And it's not a stack machine.  Well, kinda.
22:09:39 <SamB> that's the kinda thing I'm talking about when I say "expressions"
22:09:50 <SamB> it does have expressions right?
22:09:54 <Pseudonym> But the Renderman SL, even in 1989, was a full programming language.
22:09:56 <Pseudonym> Sure.
22:10:03 <SamB> see!
22:10:10 <SamB> old school!
22:10:13 <wli> Pseudonym: I meant for FP languages.
22:10:13 <Pseudonym> But before RSL, there were "shade trees", which were _only_ expressions.
22:10:41 <SamB> so, anyway, as I said, these shader assembly languages are a rather newfangled concept
22:10:55 <thedatabase> hey folks!  been a while.... I've a quickcheck question
22:11:04 <Pseudonym> If by "assembly language", you mean an actual assembly language, Chap even predates RSL.
22:11:10 <Pseudonym> IIRC, Bruce Perens worked in Chap,.
22:11:12 <Pseudonym> on
22:11:18 <SamB> what's "chap"?
22:11:25 <Pseudonym> One of the first GPUs.
22:11:34 <Pseudonym> It was a 1980s era Pixar experiment.
22:11:41 <SamB> oh.
22:11:54 <SamB> well, if it was just an experiment I'm not sure it counts.
22:12:01 * Pseudonym can dig out the paper if you like
22:12:18 <Pseudonym> Ah, proxy is dead.
22:12:21 <Pseudonym> Guess I can't.
22:12:25 <thedatabase> my question:  I can get a single double between 0 and 10 x::Double <- choose (0,10)
22:13:01 <thedatabase> what if I'd like a list of doubles between 0 and 10.  vector 10 gives me 10 doubles between 0 & 1...(using arbitrary)
22:13:53 <Pseudonym> And IIRC, there was a research project (and I think a product) before that which involved a processing element attached to each pixel.
22:14:04 <scook0> thedatabase: "sequence . replicate n" maybe?
22:14:20 <Pseudonym> To draw a line on that piece of hardware, you sent each pixel a program to compute how far it was from the line, and decide whether or not to set based on that.
22:14:24 <Pseudonym> "Pixel planes" rings a bell.
22:14:48 <thedatabase> scook0: thanks, i'll try that on the choose...
22:14:49 * wli is attempting to tabulate/memoize a hairy recurrence.
22:14:57 <SamB> polyray seems gone too
22:16:08 <scook0> heh, I don't even know the monad you're working in ... hooray for monadic combinators
22:16:49 <dolio> @src replicateM
22:16:49 <lambdabot> replicateM n x = sequence (replicate n x)
22:17:41 <scook0> ooh
22:19:19 <thedatabase> thanks guys: do { xs::[Double] <- replicateM n (choose (0,10)); return xs }
22:19:21 <thedatabase> works fine
22:20:29 <thedatabase> I was barking up the wrong tree trying to combine things with vector!
22:20:38 <SamB> hmm, apparantly this GPU doesn't do shading :-(
22:20:43 <Saizan> if you don't have anything else in that do-block you can ditch <- and return
22:21:31 <Saizan> do x <- m; return x === m
22:21:54 <scook0> and if you want to dump some parens, you can do "replicateM n $ choose (0,10)"
22:22:20 * scook0 loves ditching parens
22:22:40 <thedatabase> Saizan: cool thanks!  I'm still very conservative in my do blocks, they're like magic!
22:23:22 <Saizan> thedatabase: eheh, they will until you learn how to use >>= :)
22:24:28 <thedatabase> Saizan: guess you're right.. I've seen do expanded to >>= a lot, but I guess until I start >>=ing six times before breakfast...:)
22:25:01 <scook0> don't be afraid to write do-blocks first, and simplify later
22:25:12 <scook0> too much point-free cleverness at once will do your head in
22:25:26 <Saizan> aaah, the scent of lambdas in the morning..
22:26:54 <thedatabase> scook0:  yeah, I'm sure -- I just love it when the type system figures everything out for me!  Makes the "Adapter" pattern I applied at work today look like a positively ass-backwards way of doing things!
22:29:43 <Cale> thedatabase: Yeah, patterns were described to point out failures of existing programming languages, and then most people missed that point.
22:30:23 <mrd> more than missed
22:30:39 <Cale> Basically, if you have a pattern, and you can't turn that into a library or function or some kind of construct in your programming language, it's a problem with your language.
22:31:29 <wli> I guess I should use some sort of memoization, then.
22:31:47 <mrd> lazy eval is memoization
22:32:06 <Cale> We really ought to have a library of common memoisations.
22:32:39 <wli> mrd: Well I have a recurrence of the form beta r i js h sum [beta (r-1) i (adjust pred m js) h | m <- [0 .. n], js `index` m > 0]
22:32:46 <Cale> mrd: Well, sharing sort of handles it, but it requires a bit of work.
22:33:03 <dolio> @remember kefeer In Haskell via type system we have pattern matching, data representation and generalization. This reduce negative impact and provide pros. But i think there is room for improvement. It is still too verbose for my taste.
22:33:03 <lambdabot> Done.
22:33:07 <wli> mrd: So it's nto the most trivial meoization in the world.
22:33:17 <thedatabase> Cale: interesting way round of looking at things!  I guess some sales guy came along, polished the pattern cludge, and we're happily consuming them to this day..!
22:34:59 <wli> I guess I can have an array of Maybe Integer and update it when I find Nothing.
22:35:19 <mrd> why not just have an Array which you recursively lookup entries in?
22:35:33 <mrd> there's no cycles are there?
22:35:42 <wli> mrd: Well, I'm trying to write that and failing. There are no cycles, no.
22:36:24 <mrd> you have a 2d-array?
22:36:47 <wli> mrd: Yes, though I had to map the js to integers in a nontrivial fashion.
22:37:06 <wli> mrd: That's what the Cantor tupling functions were for.
22:37:38 <Cale> thedatabase: yeah, and they got away with it because even after 20-30 years, the first thing a programmer thinks when confronted with a new problem is not "what would be the ideal language to solve this in?", but "how do I contort the language I know to solving this problem?", and that's mostly because they're using languages where metaprogramming and embedding small languages to solve general classes of problems is b
22:37:38 <Cale> asically out of the question.
22:38:00 <mrd> table = array ... [ ... lookup ... x ... y | generate x and y coordinates ]; lookup x y = table ! (x,y)
22:38:30 <Cale> (I mean that people have been promoting this language-oriented way of looking at the world for 20-30 years, and it's basically what functional programming is all about)
22:39:06 <wli> mrd: deCantorTuple is = sum . zipWith simplexNumber [1..fromIntegral (List.length is)] . map sum . tail . inits . reverse . map fromIntegral $ is where simplexNumber d n = choose (n + d - 1) d
22:40:40 <wli> mrd: The inverse of this is somewhat more complex.
22:41:02 <mrd> wli: however you construct the indices, the trick here is to simply fill the array in naturally and use the array to lookup past values
22:41:22 <thedatabase> Cale: I agree there's a lot of contortion going on.  My day job is as a contortionist....:)
22:41:27 <mrd> it looks circular but it works
22:41:55 <wli> mrd: Mostly I'm having trouble with the index bound calculations on the arrays vs. that idiom per se.
22:42:17 <mrd> use an IntMap perhaps instead
22:43:19 <wli> Yeah, maxR*cantorUntupledNumber + r suffices.
22:43:31 <wli> Oh, yeah, they overflow integers.
22:43:52 <dolio> You might have a problem using IntMap due to non-laziness. You'd want a lazily-generated infinite bit trie.
22:44:07 <Shimei2> Ooh. The whole TclHaskell demo suite compiles. Fun.
22:44:41 <mrd> would Data.Maps be ok then?
22:44:43 <wli> dolio: Will Data.Map be sufficiently lazy?
22:45:01 <wli> mrd: Trying it.
22:45:04 <mrd> i'm pretty sure i've done this with Data.Maps
22:45:18 <dolio> I kind of doubt it.
22:45:21 <mrd> yea definitely. i did a whole circular graph impl with them
22:45:38 <wli> Well, this is noncircular, so even if it's strict I think it should work.
22:45:45 * Shimei2 is amused that there's a log interpreter demo bundled with a tcl binding for Haskell
22:45:50 <Shimei2> s/log/logo/
22:45:58 <dolio> Not if you're building an infinite map.
22:46:05 <wli> dolio: It's finite.
22:46:37 <dolio> http://haskell.org/haskellwiki/Haskell_Quiz/Happy_Numbers/Solution_Dolio
22:46:39 <lambdabot> Title: Haskell Quiz/Happy Numbers/Solution Dolio - HaskellWiki, http://tinyurl.com/yqwvr3
22:46:40 <dolio> Look at that.
22:46:42 <wli> Shimei2: I'd love to see a Datalog interpreter with PTTP (Prolog Technology Theorem Prover) semantics done up with Oleg's LogicT
22:47:43 <wli> mrd/dolio: I think the trouble I'm having here centers mostly around the details of the calculation vs. the idiom and/or high-level Haskell concerns.
22:47:49 * monochrom frowns at PTTP.
22:48:15 <wli> monochrom: Well, the DFS search semantics suck.
22:48:51 <dolio> Ah, okay. Well, the code at the bottom there should let you automatically memoize recursive functions of up to 4 arguments.
22:49:00 <dolio> Assuming I wrote it correctly.
22:49:21 <dolio> I can't remember if I fixed the bug with negative Integers in the code on that page.
22:50:07 <wli> dolio: Oh, yeah, one of the big nasties is threading this environment through the computation that only ends up getting used in the base cases.
22:52:13 <wli> dolio: It's kind of dumb; basically I should cut the environment down to the minimal information necessary, then use partial application.
22:53:03 <B4K4p4nTsU> hi
22:54:30 <wli> I guess another difference is that I want to save the memo table to do lookups in it instead of going back to the original function, which matters because otherwise it won't be saved due to the parametrization on that environment.
22:55:29 <B4K4p4nTsU> hi wli 
22:55:36 <dolio> Hmm. Wouldn't the results change with a different environment?
22:55:41 <B4K4p4nTsU> i'm "rep"
22:55:43 <dolio> Or are you saying that there's only ever one environment?
22:55:47 <B4K4p4nTsU> or i used to be
22:56:10 <B4K4p4nTsU> wli since when are you into haskell
22:58:35 <wli> doliO: The results change with a different environment.
22:59:00 <wli> B4K4p4nTsU: Eh?
22:59:11 <B4K4p4nTsU> nevermind
22:59:15 <wli> B4K4p4nTsU: Since before I graduated from college.
22:59:52 <wli> B4K4p4nTsU: "Into" is an interesting way to put it. I don't get "into" particular programming languages.
23:05:45 <wli> dolio: Your Trie seems to be useful.
23:06:08 <dolio> :) Good.
23:07:43 <dolio> Note: it looks like I didn't fix that for negative Integers. If you try to use one, it will blow up, because you'll never get to 0 by shifting.
23:08:05 <wli> Not a problem for me.
23:08:18 <dolio> So if you want to use negative numbers, you'd have to add a constructor that checks for a negative, and flips it.
23:22:03 <wli> For each sequence of xs you get a sort of infinite tree for (r, i, js) tuples where js is a finite sequence of factor degrees, i is an index into the sequence, and 0 <= r <= sum js. So I don't just have a finite sequence of naturals, I have a pointed sequence thereof, which can be un-tupled relatively easily (length of sequence * cantor number of sequence + point index), but it's not so obvious how to unravel the derivative's order.
23:23:24 <wli> This is the sort of problem I'm grappling vs. laziness/memoization idioms.
23:28:24 <wli> It looks like I have to go back to the Cantor tupling/detupling to inject a factor of sum js + 1 everywhere.
23:30:39 <wli> It's basically [0,n] x N^{n+2} where the vector in N^{n+2} has \sum_{i=0}^n j_i + 1 < j_{n+1}
23:31:22 <wli> So I want to enumerate that in some specific order.
23:32:37 <wli> I flipped the inequality but never mind that.
23:41:18 <wli> \sum_{i=0}^d j_i = n, -1 < j_{d+1} < n + 1 gives (n+1)\binom{n+d}{d} I think.
23:48:13 <RyanT5000> what's the deal with classes and constructors?
23:48:23 <RyanT5000> i find that whenever i make a class with a constructor, it's a bad idea
23:48:53 <RyanT5000> most of my classes end up being for stuff like alternative views of data
23:49:13 <RyanT5000> so let's say you had some stupid class like
23:49:46 <Cale> RyanT5000: you mean with type constructors for parameters?
23:49:47 <RyanT5000> class HasLeft a l where left :: a -> l ; setLeft :: l -> a -> a
23:49:54 <Cale> oh
23:50:08 <Cale> Those are useful for abstracting over data representation
23:50:08 <RyanT5000> no, i mean like array
23:50:22 <RyanT5000> i.e.: the function (array) can construct any IArray
23:50:35 <RyanT5000> but what if you want to make an IArray that has more functionality?
23:50:41 <Cale> So you can reimplement the low-level details of data structure maintenance without adjusting your higher-level algorithms.
23:50:53 <RyanT5000> right, i understand how it's useful
23:51:00 <RyanT5000> what i'm wondering is if, fundamentally, there should be separate hierarchies
23:51:06 <Cale> Then you need another class which is a subclass of IArray.
23:51:07 <RyanT5000> one which is "you can use this as an X"
23:51:19 <wli> Choose d numbers from [0,n-1] for the running sums, so \binom{n}{d}, with the last var, (n+1)\binom{n}{d} = (n+1)n!/(d!(n-d)!) = (n+1)!/(d!(n-d)! = (d+1)(n+1)!/((d+1)!(n-d)!) = (d+1)\binom{n+1}{d+1} which works out nicely.
23:51:20 <RyanT5000> the other is "you can build this like an X"
23:51:37 <Cale> RyanT5000: well, certainly you can do that.
23:52:04 <Cale> RyanT5000: currently fine hierarchies are mildly annoying due to the fact that you have to write all the instances separately
23:52:28 <Cale> (but they really are the right way to go, regardless)
23:52:44 <Cale> anyway, g'night
23:52:46 <RyanT5000> ok so let's say i want to make an instance of IArray that has, say, a totally unrelated thing attached to it, like a color
23:52:47 <RyanT5000> alright
23:53:08 <RyanT5000> anyway the case i just described makes sense in the "i'm going to access it like an IArray" case
23:53:16 <RyanT5000> but not the "i'm going to build it like an IArray"
23:53:18 <RyanT5000> goodnight
23:53:50 <B4K4p4nTsU> i see wli still likes to talk to himself
23:54:21 <RyanT5000> you can't make an existential as a newtype can you?
23:54:23 <wli> B4K4p4nTsU: I presume someone is following my memoization problem.
23:54:37 <RyanT5000> also, does anyone have a nice naming convention for existentials?
23:58:23 <Korollary> RyanT5000: It seems to me that you're trying to subclass IArray
23:59:44 <RyanT5000> Korollary: yeah, in theory
23:59:57 <RyanT5000> (it's mostly hypothetical, but similar things keep coming up)
