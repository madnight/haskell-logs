00:00:03 <wli> Well, I don't see offhand any use for things apart from dividing out gcd's of all the row elements.
00:00:51 <wli> Apart from that I think you just get Gaussian elimination.
00:20:49 <hpaste>  aaim annotated "solve needs some help" with "(no title)" at http://hpaste.org/1931#a4
00:42:03 <dons> did people see http://blog.tornkvist.org/?id=1185571582964040 ?
00:42:05 <lambdabot> Title: The Red Hot Erlang Blog
00:42:19 <dons> `Compiling Haskell to Erlang'
00:43:46 <Lycurgus> is that a good thing?
00:46:36 <dons> no idea. seems like its motivated to fix syntax ugliness in erlang
00:46:54 <dons> so its not really a benefit for haskell, to compilte to a slow VM.
00:47:52 <etnt> dons: well, it could be a way to integrate with Erlang
00:49:01 <Lycurgus> which if it worked might be good as a method of integration otherwise at first glance it seems ill-concieved.
00:50:10 <etnt> Lycurgus: yes. perhaps it isn't such a good idea, but fun to explore :-)
00:50:46 <Lycurgus> fun is good.
00:51:15 <Lycurgus> in its place
00:52:06 <etnt> it could also be seen as way to motivate Erlang people to get interested in Haskell
00:52:50 <dons> yes, that would be the main benefit
00:52:57 <dons> they'd get experience with the haskell toolchain/typesystem
00:53:12 <dons> since you have to write haskell, it just comes out for erlang.
00:54:43 <roconnor> I had this nightmare last night that all my installed Haskell libraries were not optimized.
00:54:49 <etnt> it would of course be nice with a more traditional interface between Haskell and Erlang
00:54:56 <roconnor> Now that I wake up, it is still true.
00:55:58 <dons> roconnor: oh, you mean not compiled with -O2 ?
00:56:18 <dons> because of cabal bizarrely not using -O* by default, till recently
00:56:57 <sorear> dons: the context is mtl
00:57:17 <roconnor> dons: I was using the MTL in my contest code
00:57:26 <roconnor> MTL code really needs to be inlined.
00:57:50 <etnt> f.g Erlang like concurrency in Haskell, like in: http://bc.tech.coop/blog/070719.html
00:57:52 <lambdabot> Title: Bill Clementson's Blog: Distel = Erlang-like Concurrency in Emacs
00:58:51 <dons> yeah, i'll look at that during the hackathon, roconnor
00:59:38 <roconnor> dons: look at what?  I figured all I need to do was to wait for ubuntu/debian to use the lastest cabal.
01:10:21 <RyanT5000> is there a good lightweight virtual machine that i could use, e.g. to run some untrusted code with the type (approximately) ByteString -> Maybe ByteString
01:10:34 <RyanT5000> (the point is it doesn't ever need to do IO, but it should be efficient with files)
01:14:59 <ari> RyanT5000: I don't see how requirement #1 connects with requirement #2
01:15:42 <RyanT5000> ari: those two don't connect so much; i should have said "and" instead of but
01:16:30 <RyanT5000> the point is i want to be able to run pure functions that have been sent to me in some form
01:16:42 <RyanT5000> and i want them to be "reasonably" efficient
01:17:47 <RyanT5000> also, it has to be lightweight in the sense that it can't require more than a couple hundred KB of installed libraries/etc.
01:17:51 <RyanT5000> (which rules out java)
01:21:05 <ari> RyanT5000: Lua, maybe? I don't actually know what kind of guarantees of safety you get, but at least it's small..
01:21:40 <RyanT5000> ari: hm
01:21:59 <dons> roconnor: `MTL code really needs to be inlined' ?
01:22:12 <dons> i was thinking of looking at how well it is being inlined, and tune it up a bit, if not
01:22:30 <psykotic> dons: is there a way to give hints to the compiler?
01:22:47 <RyanT5000> anyone have any ideas as to how i'd find such a thing?
01:22:59 <psykotic> {-# INLINE #-} or something
01:24:01 <RyanT5000> i mean i suppose if i just implement it in haskell, don't use anything unsafe, and have it typed right, i can't go *too* wrong
01:24:44 <ari> @go safely running untrusted haskell
01:24:47 <lambdabot> http://www.haskell.org/haskellwiki/Safely_running_untrusted_Haskell_code
01:24:47 <lambdabot> Title: Safely running untrusted Haskell code - HaskellWiki
01:25:34 <ari> RyanT5000: Don't forget that one, of course... I don't know what your allowed disk budget for a Haskell RTS is, of course
01:31:07 <RyanT5000> is YHC safe in any kind of serious way?
01:34:59 <igli> sorear: pingy; ty for lb2; who can set ignore? :-)
01:35:25 <sorear> igli: I didn't send lb2.
01:35:31 <igli> hmm
01:35:49 <sorear> must've been dons
01:35:56 <igli> quite happy for her to be there, just need her to ignore friendlyT
01:36:00 <igli> ah cool :)
01:36:40 <sorear> I just told lb2 to ignore fT, and I don't seem to be getting the not enough privledges...
01:37:05 <roconnor> dons: ah, that would be good to do too; however,
01:37:08 <shapr> friendlyT is a great name for a social monad transformer.
01:37:31 <roconnor> dons: as it stands in ubuntu, none of the functions appear in the .hi file for inlining.
01:37:43 <roconnor> dons: that was my main killer.
01:38:04 <sorear> RyanT5000: It's about as safe as GHC
01:38:32 <sorear> RyanT5000: ie, it supports unsafePerformIO and probably has it's own small assortment of exploitable rts bugs
01:38:39 <RyanT5000> hm
01:38:57 <RyanT5000> it feels wrong to write my own, though
01:39:05 <igli> ty sorear :)
01:39:06 <sorear> RyanT5000: contrarily, it's much much much smaller, and supports javascript output...
01:40:11 <sorear> probably the js backend could be modified to generate code for any higher-order impure object-oriented language without too much difficulty (Perl, Lua, etc)
01:40:54 <RyanT5000> no no that's exactly what i want to avoid
01:41:38 <RyanT5000> i'm writing a server that would like to be able to receive code from clients with a known type signature, run it, and send back the result
01:41:53 <RyanT5000> similar to lambdabot, only i don't care about supporting "all of" a language like haskell
01:42:28 <RyanT5000> brainfuck, e.g., would be good enough, except for all the ways that it's crappy
01:42:32 <ari> Is haskell.org down or?
01:42:48 <RyanT5000> (i'd like people to actually be able to *write* this code, lol)
01:43:24 <sorear> @where lambdaweb
01:43:24 <lambdabot> http://lambdabot.codersbase.com
01:43:35 <sorear> there.  CGI lambdabot.
01:44:09 <sorear> 'night.
01:44:18 <roconnor> night
02:07:35 <MarcWeber> Which is the pretty library used by cabal?
02:08:32 <masak> dons: you asked me to remind you today about adding lambdabot to a channel -- is now a good time?
02:11:47 <dons> masak: yes!
02:11:49 <dons> which channel?
02:12:19 <dons> MarcWeber: darcs.haskell.org/packages/pretty iirc
02:15:12 <MarcWeber> dons: Thanks. I haven't looket within packages :)
02:22:31 <dibblego> I wish those Haskell videos could be downloaded - I'd watch the ones I haven't seen already, on the train
02:23:22 <xerox> dibblego: which ones?
02:24:09 <dibblego> xerox, all those under 1, 2 and 3, but I've seen Faith, Evolution and Programming Languages, but I'd watch it again
02:24:32 <dibblego> I've seen SPJ  and Tim Harris on concurrency too
02:25:15 <xerox> Hmm, where are them?
02:25:54 <masak> dons: #bioclipse
02:26:06 <dibblego> xerox, http://haskell.org/haskellwiki/Video_presentations
02:26:08 <lambdabot> Title: Video presentations - HaskellWiki
02:26:09 <dibblego> ?where video
02:26:09 <lambdabot> I know nothing about video.
02:26:16 <dibblego> ?where+ video http://haskell.org/haskellwiki/Video_presentations
02:26:16 <lambdabot> Done.
02:26:19 <dibblego> ?where video
02:26:20 <lambdabot> http://haskell.org/haskellwiki/Video_presentations
02:26:52 <xerox> There's also the one in the topic, and those by the Simons explaining GHC on the GHC trac (which really are on video.google.com)
02:27:14 <dibblego> yeah, they are on the page
02:27:42 <xerox> You can download those in video.google com and the one on msdn channel9
02:27:52 <dibblego> you can?
02:27:54 <xerox> Select "iPod/PSP" and download
02:28:25 <dibblego> I don't see that link
02:28:40 <dibblego> oh wait, I do
02:36:18 <dons> masak: how's that?
02:37:04 <xerox> dons: how many channels is lambdabot covering nowadays? (:
02:38:21 <steven-ashley> > let arg = flip ($) in arg (++) (arg (arg (++) (arg "g" . arg "r")) . arg "a")
02:38:22 <lambdabot>  "arg"
02:42:57 <igli> lambdabot: :-)
02:43:00 <igli> @bot
02:43:00 <lambdabot> :)
03:02:07 <masak> dons: works well. thx!
03:05:14 <Planet_EN> Whats good with Haskell?
03:05:33 <dibblego> a glass of red
03:05:46 <masak> :)
03:07:01 <xerox> orange juice!
03:07:47 <steven-ashley> lambdabot ;)
03:08:28 <steven-ashley> is Text.Printf deprecated these days? ghci is dying over the examples it gives
03:09:11 <steven-ashley> it prints out the right thing then dies with *** Exception: Prelude.undefined
03:09:48 <xerox> No, it shouldn't be.
03:10:19 <Igloo> steven-ashley: You need to constraint the result type to IO () if using it with an IO type
03:10:54 <steven-ashley> ahh yes, cheers
03:14:45 <xerox> Why doesn't  |print 1 `seq` print 2|  actually print 1?
03:15:29 <Planet_EN> I'm using HUGS
03:15:30 <doublef> xerox: print 1 gets evaluated, but not called...
03:15:41 <Planet_EN> how to compile Helloworld to an exe?
03:17:13 <Planet_EN> .......?
03:17:16 <tjm1983> Planet_EN: HUGS is just an interpreter, but you can compile Haskell with GHC.
03:22:04 <scook0> @hoogle CInt
03:22:05 <lambdabot> Foreign.C.Types.CInt :: data CInt
03:22:59 <dons> Planet_EN: you should install ghc from haskell.org/ghc
03:23:11 <dons> to compile it to an executable, ghc helloworld.hs -o hello
03:23:34 <Planet_EN> but cant I compile it with HUGS full install
03:23:44 <Planet_EN> I currently have that minimalHuge
03:23:50 <Planet_EN> Hugs*
03:24:14 <dons> hugs is an interpreter. so you save your file to hello.hs, and run it with: runhugs hello.hs
03:24:20 <dons> like a python or perl interpreter
03:25:02 <dons> the basic use of hugs and ghc is explained here, http://haskell.org/haskellwiki/Haskell_in_5_steps
03:25:03 <lambdabot> Title: Haskell in 5 steps - HaskellWiki
03:28:05 <tjm1983> Is it too late for me to say what Haskell's good with?
03:28:07 <tjm1983> Curry.
03:29:29 <dibblego> too late, sorry
03:30:54 <tjm1983> I thought so.
03:31:51 <Botje> @quote curry
03:31:51 <lambdabot> sjanssen says: @djinn Haskell -> Curry
03:32:01 <Botje> @quote curry
03:32:01 <lambdabot> VirginiaCurry says: "You know, Haskell actually never liked the name Haskell." -- Virgina Curry (Haskell B. Curry's widow)
03:32:08 <Botje> @quote curry
03:32:08 <lambdabot> sjanssen says: @djinn Haskell -> Curry
03:32:12 <Botje> boo :[
03:38:46 <tennin0> hi.  I'm encountering a really frustrating problem that I'm sure (?) has a simple solution I'll hit myself for not seeing
03:39:08 <psykotic> go ahead with your question
03:39:10 <dons> tennin0: what's the issue?
03:39:19 <dons> and feel free to just ask :)
03:40:00 <tennin0> I've got a Data.Map that claims certain keys that the "keys" function claims exists, don't exist.
03:40:17 <Heffalump> in what way does it claim they don't exist?
03:40:31 <tennin0> i.e. "map (\x -> lookup x rec) (keys rec)" -> [Nothing, Nothing, Nothing...
03:42:05 <Igloo> Can you show us a complete example?
03:42:06 <jyp> tennin0: you have a funny comparison function somewhere?
03:42:26 <ari> tennin0: It's not a Map of Maybes, is it ;)? (actually, I'm serious - something like that happened to me once)
03:42:40 <psykotic> ari: then it would be Just Nothing, Just Nothing, ...
03:42:57 <ari> psykotic: Hm, you've a point
03:43:27 <tennin0> the map prints as fromList [(k0, v0), (k1, v1), (k2, v2)...
03:43:37 <matthew-_> I would guess that there's something wrong with the Ord instance.
03:43:43 <tennin0> it's only when I try to use lookup that it disavows all knowledge of some keys
03:43:46 <matthew-_> tennin0: what's the types of the keys and values?
03:43:52 <tennin0> String to String
03:43:55 <psykotic> yeah. the equality part is inconsistent with the ordering.
03:43:57 <dons> you're not flipping keys and values are you?
03:44:00 <psykotic> (maybe)
03:44:20 <Heffalump> tennin0: or your Show instance is wrong
03:44:25 <tennin0> hmm
03:44:30 <Heffalump> oh, but that wouldn't explain your map not working, never mind
03:44:43 <tennin0> could it have something to do with my creating it from fromAscList and not fromList ?
03:44:50 <matthew-_> Heffalump: may the strings are "Nothing" and the show instance isn't putting the quotes around?! ;)
03:44:53 <Heffalump> was it actually an ascending list?
03:45:00 <tennin0> what?
03:45:11 <steven-ashley> theres your problem ;)
03:45:16 <tennin0> "ascList" means "ascending list" and not "association list"?!
03:45:16 <Heffalump> matthew-_: that wouldn't explain directly mapping lookup over the keys not working
03:45:23 <Heffalump> I think so, yes
03:45:32 <tennin0> ahhhhh... that might explain some things
03:45:34 <Heffalump> it's supposed to be more efficient if you already have a sorted list, is the idea
03:45:46 <tennin0> so is that why certain ks
03:45:47 <matthew-_> tennin0: both fromList and fromAscList take association lists
03:46:01 <tennin0> keys don't work and others do?  the ones that don't are out of sequence or something?
03:46:30 <matthew-_> tennin0: Data.Map uses a binary tree
03:46:43 <matthew-_> so if you give it a presorted list then it has to do less work
03:47:02 <matthew-_> but if you claim it's presorted and it isn't then values will end up in the wrong part of the tree
03:47:16 <tennin0> ahhhhhh
03:47:41 <tennin0> so "keys" and "show" find them but "lookup" can't?
03:47:57 <matthew-_> yes, because keys and show will just walk over the whole tree
03:48:05 <matthew-_> but lookup will try to navigate the tree
03:48:11 <tennin0> ok
03:48:15 <tennin0> you people are awesome
03:48:35 <matthew-_> well, I find the whole haskell community really nice
03:48:39 <tennin0> i dunno why i didn't try this before though, just boneheadedness
03:49:14 <tennin0> I mean, I did notice there were two different fns fromAscList and fromList, and they were the same except for Ord vs Eq
03:49:45 <tennin0> but didn't really try to think about why that might be
03:50:39 <matthew-_> tennin0: I find that most "programming" time with Haskell is actually spent thinking. This is stark contrast to, eg Java, where you can spend days churning out code without thinking once
03:50:42 <Heffalump> did they have any description attached to them?
03:51:12 <matthew-_> "O(n). Build a map from an ascending list in linear time. The precondition (input list is ascending) is not checked."
03:51:22 <Heffalump> if you were looking at the API docs, the names should have been a link to a fuller description of the function
03:51:28 <matthew-_> fromList: "O(n*log n). Build a map from a list of key/value pairs. See also fromAscList."
03:51:33 <Heffalump> if you weren't looking at the API docs, you should, they're good :-)
03:51:44 <matthew-_> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html#v%3AfromList
03:51:46 <lambdabot> http://tinyurl.com/uywvm
03:51:55 <matthew-_> Heffalump: teamwork ;)
03:56:24 <Pupeno> Can HaskellDB genericConnect connect to a local postgresql without using password auth?
04:09:27 <earthy> pupeno: no clue.
04:09:56 <Pupeno> it seems that not even postgresqlConnect can use the fantastic ident authentication.
04:19:37 * Heffalump is currently being annoyed by HaskellDB's limitations
04:19:45 <matthew-_> Heffalump: like what?
04:19:55 <Heffalump> (no way to create indexes when making databases, no way to use last insert id)
04:20:42 <matthew-_> ahh. I've never tried to use HaskellDB to make databases/tables/indexes
04:20:53 <Heffalump> I'm beginning to regret I did
04:20:59 <matthew-_> can't you just, in a transaction, select out the last insert id and use it?
04:21:14 <Heffalump> yes, that's what I'm doing instead. Bit ugly, though.
04:21:52 <Heffalump> also, when I rewrote my old queries in HaskellDB, they're much less efficient. Prettier, though :-)
04:22:12 <matthew-_> Heffalump: pretty is more important wrt maintainability though, no?
04:22:47 <Heffalump> so is usability of the application ;-)
04:22:53 <mux> morning haskellers
04:23:00 <matthew-_> meh, that's just an optimisation :-P
04:23:03 <Heffalump> and it's not like the query is so complicated I couldn't understand the previous version.
04:23:29 <matthew-_> Heffalump: with the query logs turned on, is the generate SQL completely different then?
04:23:38 <matthew-_> err, generate*d*
04:24:27 <Pupeno> Heffalump: and what would be the alternative? using hsql directly?
04:24:45 <matthew-_> yeah, HSQL or HDBC
04:30:33 <Igel> @seen malcolmw
04:30:33 <lambdabot> I haven't seen malcolmw.
04:37:04 <Heffalump> matthew-_: I don't understand your question
04:37:16 <Heffalump> Pupeno: yes, that's what I migrated from in the first place.
04:40:21 <dons> Heffalump: oh, haskeldb? not takusan?
04:40:42 <dons> (did you see the thread from Jeff at Deutsche Bank about preferred db bindings?)
04:41:54 <dons> i wish for a db strike force, to sort out once and for all, all these db optoins
04:43:52 <Heffalump> when was it, what list?
04:44:07 <Heffalump> I vaguely remember hearing the name takusan, but only vaguely.
04:44:16 <dons> oh, just  the last few days
04:44:27 <dons> let me find the thread.
04:45:16 <mux> it's takusen, fwiw
04:45:33 <dons> http://thread.gmane.org/gmane.comp.lang.haskell.cafe/26550/focus=26576
04:45:35 <lambdabot> Title: Gmane Loom, http://tinyurl.com/2undw2
04:45:38 <dons> takusen, yeah
04:45:52 <dons> Heffalump: have you met Jeff?
04:46:14 <Heffalump> no
04:46:16 <dons> ah, he's in NY, iirc, so maybe not
04:46:31 <Heffalump> I think Howard has organised stuff with him
04:46:43 <dons> yeah
04:46:55 <dons> is good: http://thread.gmane.org/gmane.comp.lang.haskell.cafe/26550/focus=26576
04:46:57 <lambdabot> Title: Gmane Loom, http://tinyurl.com/2undw2
04:47:10 <dons> oh, hmm. 1http://article.gmane.org/gmane.comp.lang.haskell.cafe/26579
04:47:11 <lambdabot> Title: Gmane -- Mail To News And Back Again
04:47:12 <dons> i mean.
04:47:15 <mux> I've installed HDBC and HDBC-postgresql to see how a small perl DBD::Pg script would look like in haskell
04:47:41 <dons> oh yes?
04:47:42 <Pupeno> any recommended doc to start learning HAppS, the tutorial's example doesn't work, and half the examples don't work either... well, more than half of those I tried.
04:47:43 <mux> I have yet to try the higher-level abstractions like HaskellDB or Takusen
04:47:57 * Heffalump takes a look at Takusen
04:48:04 <dons> Pupeno: perhaps ask in #happs -- one of the happs employees should be able to answer
04:48:06 <mux> I'm a bit disappointed to see that HDBC does everythng in IO, and doesn't provide its own Monad
04:48:20 <Heffalump> I now remember Alistair mentioning it in the pub
04:48:27 <dons> `At this point in time, my advice to new Haskell programmers would be:
04:48:28 <dons> first try Takusen, as long as it can connect to the server you're
04:48:28 <dons> using (and don't hesitate to ask the maintainers and/or haskell-cafe
04:48:28 <dons> questions); then try HDBC, perhaps avoiding the lazy retrieval
04:48:28 <dons> function.'
04:48:42 <mux> like ReaderT Connection (ErrorT SQLError IO)
04:48:49 <mux> would be useful, I think
04:48:57 <dons> maybe for simplicity, mux?
04:49:09 <dons> keep it friendly for imperative db guys used to that?
04:49:22 <mux> maybe yeah, that makes some sense
04:49:31 <mux> though the imperative db guys wouldn't necessarily have to use it
04:49:40 <Heffalump> it looks rather complicated
04:49:54 <mux> what does?
04:50:07 <Heffalump> Takusen
04:50:11 <mux> ah
04:51:59 <Heffalump> I can't actually seen any simple examples of using it.
04:52:17 <dons> Heffalump: it would be interesting/useful to collect a list of libs that you'd like to see, that would be helpful for your work/commercial use of Haskell .
04:52:29 <dons> to see if we could tackle some of them at the hackathon
04:52:52 <mux> oh, how I wish Haskell had something allowing automatic lifting of IO actions
04:53:23 <paolino> ola, if I state [x,y] = [f1,f2]  and then x && y f2 gets evaluated  ?
04:53:41 <dons> yeah
04:53:47 <dons> since y = f2
04:53:54 <dons> so to get the value of y, you need to evaluate f2
04:53:55 <dcoutts> @where hackport
04:53:56 <lambdabot> I know nothing about hackport.
04:54:07 <dcoutts> ach
04:54:09 <paolino> if x is False ?
04:54:20 <dons> not if x is false :)
04:54:20 <dcoutts> lambdabot and lambdabot2 really are different :-(
04:54:26 <dons> dcoutts: yeah
04:54:31 <dcoutts> I somehow hoped they shared state
04:54:45 <dons> oh, hmm, i'm not sure that's possible
04:54:50 <paolino> so there is nothing special in the irrefutable pattern matching concerning evaluation
04:54:50 <dcoutts> and was just a workaround for the freenode channel limit
04:55:00 <dons> no, they're separate instances
04:55:09 <dcoutts> dons: I don't suppose we could get the 'real' lambdabot in #gentoo-haskell rather than lambdabot2 ?
04:55:19 <dons> i suppose that could be arranged :)
04:55:37 <dcoutts> we really do make full use of lambdabot's features over there
04:55:38 <mux> IIRC, irrefutable patterns are described using surprisingly simple denotational semantics, it's like just a transformation step
04:55:44 <dons> ?join #gentoo-haskell
04:55:50 <dons> dcoutts: did that work?
04:55:56 <dcoutts> dons: yep
04:56:03 <dons> ok, i'll fix the config files
04:56:07 <dcoutts> dons: how do we tell lambdabot2 to go away?
04:56:14 <paolino> > let [x,y] = [False,undefined] in x && y
04:56:16 <lambdabot>  False
04:56:19 <dons> did it part?
04:56:23 <paolino> :)
04:56:25 <dcoutts> dons: oh, yep, it's gone.
04:56:35 <dcoutts> dons: thanks :-)
04:56:45 <dcoutts> @where hackport
04:56:45 <lambdabot> http://haskell.org/~gentoo/gentoo-haskell/projects/HackPort/
04:56:47 <dcoutts> yay
04:56:55 <paolino> thanks
04:57:06 <dcoutts> ^^ tool for generating ebuilds for hackage packages
04:57:22 <dons> cool.
04:57:39 <mux> heh, I should write somethng similar for FreeBSD ports, it would be rather easy
04:57:53 <dcoutts> mux: you could do worse than starting with the above code
04:58:00 <mux> but, I'd better write a bsd.haskell.mk abstracting the common cabalities
04:58:04 <dcoutts> at the moment it's still a dev tool but it could be adapted to be an end user tool
04:58:23 <dcoutts> gentoo has a g-cpan tool that users can use for CPAN perl packages
04:58:43 <dcoutts> so that portage doesn't have to lug all the CPAN packages around
04:58:57 <mux> we have some specific cpan code so that we can use the cpan shell to install modules, and they'll get installed automagically as FreeBSD packages
04:59:09 <mux> bsdpan-Foo-Bar-X.Y
04:59:18 <dcoutts> right, that's more or less what g-cpan does
04:59:32 <dcoutts> and what hackport could become
04:59:45 <Heffalump> dons: my DB-related issues are all personal, not work-related
05:00:12 <dcoutts> Heffalump: a commercial perspective on libs would still be useful to us
05:00:22 <dons> Heffalump: oh, I just meant in general, what libs could we do to help with commercial use
05:00:35 * mux wants -fadd-liftIO-everywhere-I-want-it
05:00:48 <dons> Heffalump: and can we get tshirts if we write libs? :)
05:00:57 <dcoutts> heh
05:01:03 <Pupeno> is there a way to get a list of functions in a module on ghci?
05:01:04 <dcoutts> dons: what would go on the tshirt?
05:01:14 <mux> at least one lambda
05:01:26 <dcoutts> dons: "I'm an unpaid credit suisse lackey!" ? :-)
05:01:28 <dons> oh, hackathon logo or something "got types?"   sponsored by CS and Galois, would be nice :)
05:01:37 <dcoutts> heh, ok, that's nicer
05:01:51 <Igloo> dcoutts: "I sold my soul to investment banking and all I got was this lousy T-shirt"?  :-)
05:01:56 <dons> heh
05:02:05 <dcoutts> hah hah
05:02:25 <dons> I wonder how other communities got about getting commercial sponsors. Heffalump, know anythiing about the Jane St summer of ocaml stuff?
05:02:33 <mux> dons, dcoutts: btw, I've stumbed upon annoying behaviour of Cabal with HDBC
05:02:35 <dons> maybe the FP consortium should do more to help get libs written.
05:02:42 <dcoutts> Igloo: actually if you do sell your soul to investment banking, I think they pay well for it.
05:02:56 <dcoutts> dons: like making specs
05:02:57 <Igloo> The FP consortium isn't only Haskell, though
05:03:01 <mux> err, I meant HDBC-postgresql
05:03:08 <dcoutts> mux: yes?
05:03:38 <mux> by default it adds -I/usr/include/postgresql to get libpq headers, probably because it lives there on some Linux distros; so I added /usr/local/include for the BSD way of things
05:03:57 <mux> however, cabal later choked saying that -I/usr/include/postgresql doesn't exist
05:04:03 <dcoutts> mux: ah yes, that's a difficult issue, platform-specific include locations
05:04:08 <mux> so I add to remove the other -I thing, which is a bit annoying
05:04:16 <dcoutts> mux: if you have any good ideas for solving that...
05:04:18 <mux> different include locations are expected
05:04:29 <mux> but it becomes harder if you need to only list the good ones :-)
05:04:43 <dcoutts> mux: I'd like to add pkg-config support to cabal, that'd help for many packages
05:04:54 * mux nods
05:04:59 <mux> not in that case though
05:05:22 <dcoutts> no, postgres doesn't provide a pkg-config file, though sqlite does
05:05:36 <dcoutts> $ pkg-config --list-all | wc -l
05:05:36 <dcoutts> 334
05:05:45 <dcoutts> lots of other packages do too as you can see
05:05:50 <mux> yeah I know
05:06:12 <mux> pretty much all of Xorg since 7.2, all gnome and other gtk+ libs and friends
05:06:15 <dcoutts> it seems to becoming a de-facto standard for C packages
05:06:26 <mux> .pc everywhere
05:06:42 <dons> Heffalump: anyway, if there's stuff that you wish for (say, better X.Y for windows) or something, do let us know.
05:06:45 <dcoutts> it's great because it gives you a common name to refer to the package
05:06:50 <dons> hmm, maybe we should get votes on stuff to work on
05:06:55 <mux> in the case I'm talking about though, I just need Cabal to be a little more forgiving
05:07:05 <dcoutts> mux: how?
05:07:29 <dcoutts> dons: there's a massive pile of things for windows, but nobody wants to work on that
05:07:36 <mux> ok, just a second, let me refresh my memory from yesterday at 3am :-)
05:07:58 <Heffalump> I think the things we need most are good tools.
05:08:14 <Heffalump> Most valuable would be a proper .NET implementation.
05:08:35 <dons> hmm. ok, that's interesting. people use F# just for that reason, don't they
05:08:51 <dcoutts> it's a pretty big project though
05:08:59 <dons> we have our top honours student here workin on proper .NET ffi
05:09:05 <dcoutts> F# is designed specifically for .NET so it's trivial to interop
05:09:11 <Heffalump> the stuff in Howard's talk (http://cufp.galois.com/slides/2006/HowardMansell.pdf) is probably still about right
05:09:12 <dons> so probably there'll be a bridge for .net by the end of the year
05:09:15 <Heffalump> dons: indeed
05:09:23 <mux> dcoutts: here:
05:09:26 <mux> ghc-pkg: /usr/include/postgresql doesn't exist or isn't a directory (use --force to override)
05:09:33 <mux> that's suboptimal
05:09:45 <Heffalump> dons: a bridge would be better than nothing, but IIRC it was only one direction (Haskell calling .NET) and it ain't native IL
05:09:55 <dons> Heffalump: so probably more along the lines of 'bytestring xml parsing' or some such would be feasible for the hackathon
05:10:22 <dons> Heffalump: right, haskell could use .NET libs (and call back in)
05:10:39 <mux> dcoutts: typically, gcc doesn't complain about being passed non-existing -I directories, and it makes everyone's life easier
05:10:46 <Heffalump> I think the direction we'd find more useful is the opposite.
05:10:56 <mux> dcoutts: it would be just fine if Cabal didn't complain about it as well
05:11:02 <dons> right, so large .NET code base uses some new components in Haskell?
05:11:07 <Heffalump> indeed.
05:11:10 <dcoutts> mux: that's a ghc-pkg thing, or I suppose we could test if they exist and delete them if not (with a warning)
05:11:16 <mux> dcoutts: that allows to solve many "header location problems" by just adding more directories
05:11:21 <dcoutts> mux: mm, true
05:11:32 <dons> yes, as a whole people haven't looked enough into using haskell as the slave language
05:11:55 <dons> which really is a bit odd, as it would be a low-risk way to get haskell adoption
05:12:03 <mux> dcoutts: then we can work on more sophisiticated/proper ways of getting header locations, via pkg-config and what not :-)
05:13:02 <Heffalump> faster XML processing would definitely be valuable
05:13:42 <dcoutts> mux: we could make cabal test if the dirs exist, and remove them if not, so ghc-pkg does not complain
05:13:53 <dcoutts> mux: that doesn't seem like a very difficult patch
05:14:07 <mux> faster XML processing raise the everlasting question of Data.ByteString, that is how to make it so modules using Strings can be made to use Bytestrings automatically
05:14:14 <dcoutts> mux: though you'd probably want a warning or something.
05:14:24 <mux> dcoutts: okay, I'll look at the code then
05:14:47 <dcoutts> mux: yes, I think the right approach there is to have a class for string conversion
05:14:54 <dcoutts> rather than a class for all string ops
05:15:13 <dcoutts> so one could do it internally with whatever string type is appropriate and convert on the boundary
05:15:34 <dcoutts> so it should use the new IsString class, plus another one for converting the other way
05:16:09 <mux> dcoutts: I think we should use a full blown class with associated data types and default methods for all of the string operating using toString/fromString, so that we can still have optimized implementations of everything
05:16:22 <mux> s/operating/operations/
05:16:33 <dcoutts> I fear using a class for all ops will give us very slow overloaded code
05:17:09 <mux> if we can use any string type but waste time doing marshalling to/from this string type constantly, I'm not sure it's worth it
05:17:20 <dcoutts> eg for ivonv, or xml or something, it should internally use bytestring and do a conversion on the input/output so you can use it at whatever string type
05:17:28 <mux> I'm not sure either if that would really be a significant performance problem
05:17:54 <dcoutts> so if you use it at the same type as it's using internally then it's a noop
05:18:14 <dcoutts> but I fear that if you make it overloaded then it's going to be slow for bytestring too
05:18:21 <dcoutts> since all the ops will be picked at runtime
05:18:39 <mux> I like the just toString/fromString approach, because there's no problems of "forgetting" ops, or wanting to add more, and missing some for some types, etc etc
05:18:39 <dcoutts> or we're going to have to go around with {-# SPECIALISE #-} all over the place
05:19:10 <mux> but I don't know about the performance implications of doing so much marshalling
05:19:32 <dcoutts> it can hardly be much worse than using String internally
05:19:35 <mux> if things end up in such a way that using only the string type that the module is written with is efficient, it's not worth it
05:20:36 <dons> if its written for String, its not efficient.
05:20:56 <dons> so write if you care about efficiency, write it with bytestrings, and provide a String interface as extra
05:21:01 <mux> it seems drawing a line between what should be considered primitive string operations, and operations that can be reasonably written with those primitives is hard
05:21:14 <mux> because of performance implications
05:21:52 <ndm> isn't it likely that one day we'll be able to write things as String, and automatically infer a ByteString implementation if the performance suggests that is necessary
05:22:01 <ndm> i've been looking at that recently
05:22:01 <mux> so even defining what methods would be part of a "String" type class sounds non-trivial to me
05:22:26 <ndm> i know the practical use of such a thing is probably years off...
05:23:03 <dcoutts> ndm: I think it depends on a more sophisticated strictness analysis
05:23:42 <dcoutts> ndm: if one can infer that the operation is strict in the elements and spine then you could switch the representation to one that is strict in elements and spine
05:24:06 <ndm> dcoutts, i think you can actually do it without changing the strictness
05:24:23 <dcoutts> ndm: sure, you must not change the strictness
05:24:35 <ndm> i mean without additional strictness analysis
05:24:35 <dcoutts> you can only do it if the code was sufficiently strict to start with
05:24:39 <dcoutts> oh
05:24:40 <mux> we should type the strictness :)
05:24:58 <dons> that would help, yeah.
05:25:12 <ndm> eek, please, no! strictness! analysis! is! going! to! wear! out! some! keys!
05:25:22 <dons> if I could just write rules on ![!Int] ->
05:25:44 <dcoutts> dons: the problem is that strictness often doesn't correspond to the parameters of a type
05:25:48 <dons> check out some of the clean programs on the shootout for where this stuff ends up :)
05:25:58 <dons> [!*{#Int}]
05:25:59 * mux ponders System F omega + strictness typing
05:26:10 <mux> duh, sorry, System Fc
05:26:15 <ndm> just wait for Supero, that takes a lazy program and spits out one which is nearly always obviously strict
05:26:18 <mux> (+ strictness typing)
05:26:40 <ndm> and which the GHC strictness analyser still fails on sometimes, but could be trivially improved
05:26:50 <mux> ndm: man if it works that well, for all/most of the programs, I'm all for forgetting about strictness and evaluationg order of my programs :)
05:26:58 <dons> copy :: !Int !Int !*{#Char} !{#Char} -> *{#Char}
05:26:58 <dcoutts> ghc's strictness analysis isn't that sophisticated
05:27:03 <dons> the clean guys went nutes
05:27:57 <LoganCapaldo> that type doesn't look very clean
05:27:57 <dcoutts> dons: thing is, what if I have a type: data Foo a = Bar [a]
05:27:58 <Igloo> Heh
05:28:04 <ndm> mux, exactly, i think manual strictness annotations are a short-term performance hack, where short-term may be ~= 10 years
05:28:21 <mux> ndm: I'm very relieved to hear you saying that :-)
05:28:25 <pejo> ndm, wasn't Binkley working on strictness analysis in GHC, or was that some other project?
05:28:28 <dcoutts> dons: I can say !Foo a or Foo !a but that's not enough to specify spine strictness
05:28:37 <dons> yeah
05:28:42 <dcoutts> dons: because the type parameters I've chosen don't cover everything
05:28:48 <pejo> ndm, and what is your current idea for how to choose representation of Strings, and what isn't working?
05:28:51 <ndm> pejo, she was doing some type based strictness analysis, but thats not what they use, and i'm not sure her's ever got turned on
05:28:57 <dcoutts> dons: data Foo = Bar [Int]
05:29:07 <dcoutts> dons: no type vars to squeeze ! into
05:29:15 <dons> right.
05:29:17 <ndm> pejo, its still early, basically the answer is always use a slightly modified bytestring
05:29:31 <ndm> or entirely eliminate the list, in the vast majority of cases
05:30:04 <ndm> it relies on noticing what is a "buffer", everything else gets eliminated, whats left is usually an array, hiding inside a linked list
05:30:05 <pejo> ndm, so either you fuse away the list, or switch to a bytestring when it's safe?
05:30:23 <ndm> pejo, yes,  although i think i can tweak some things slightly so its always safe
05:31:16 <dons> anyone tried the pointer tagging runtime yet?
05:31:34 <pejo> ndm, a buffer as in a chunk of continuous space, or something else?
05:32:03 <dons> do we get all small constructors packed into bits in the closure pointer, btw?
05:32:31 <ndm> pejo, some chunk of memory used at runtime, so yes, usually continuous
05:32:43 <dons> dcoutts: hmm. I wonder, might help stream fusoin numbers, since the Skip/Yield/Tag bits end up in the pointer tag ?
05:32:56 <dons> oh silly me
05:33:29 <dons> should help Just/Nothing loops though
05:34:29 <dcoutts> dons: yes, JaffaCake wanted you to try re-running nobench with ghc head to check pointer tagging
05:34:48 <dcoutts> dons: yes, on 32bit we get up to 3 constructors in the pointer tag
05:34:54 <dcoutts> 7 on a 64bit box
05:35:36 <nopcode> hey hehe
05:35:38 <pejo> ndm, how do you detect buffers?
05:35:48 <nopcode> i was thinking that 64 bit might be useful for VHLL
05:35:51 <dcoutts> dons: and more importantly it tags if the thing is evaluated or not
05:35:58 <ndm> pejo, i'm still working on that
05:36:05 <dons> yeah, sounds like time to rerun nobech
05:38:40 <roconnor> does {#- INLINE foo -#} tell it to inline across modules?
05:39:23 <hpaste>  aaim pasted "something else" at http://hpaste.org/1935
05:40:04 <matthew-_> roconnor: IIRC, it massively lowers the "cost" of inlining it, making it much more likely to be inlined. And I think yes, it does inline across modules
05:40:18 <dcoutts> roconnor: ghc can always inline across modules
05:40:21 <LoganCapaldo> @ty fromEnum
05:40:27 <lambdabot> forall a. (Enum a) => a -> Int
05:40:28 <dons> and you'll want -O or -O2 to ensure unfolding into .hi files, of course
05:40:35 <pejo> ndm, any big outline of approach?
05:40:57 <LoganCapaldo> :t \d -> map (fromEnum . (d<))
05:40:59 <lambdabot> forall a. (Ord a) => a -> [a] -> [Int]
05:41:48 <roconnor> dcoutts: only if the function appears in the .hi file.
05:42:16 <dcoutts> roconnor: right, and ghc will do that automatically if it thinks it's profitable, or you can force it with the INLINE pragma
05:42:21 <ndm> pejo, are you coming to AngloHaskell?
05:42:39 <roconnor> dcoutts: so INLINE forces it into the .hi file (under -O). good.
05:43:07 <dcoutts> roconnor: and it makes ghc believe it's very cheap to inline in other modules
05:43:19 <dcoutts> which may or may not be a good thing
05:44:40 <ndm> if not, there will be slides up afterwards, hopefully detailing the approach
05:45:36 * DRMacIver is still trying to decide if he can take time off for anglohaskell.
05:45:48 <DRMacIver> Given that it's in my first week of my new job I feel it would be a bit cheeky. :)
05:46:34 <pejo> ndm, oh, bummer. No, can't make it. Looking forward to the slides though.
05:49:03 <ndm> DRMacIver: make sure you tell them its a learning experience
05:49:51 <Heffalump> have people started organising places to stay and stuff?
05:50:28 <matthew-_> DRMacIver: how goes the new job?
05:50:34 <ndm> i get the feeling that this year has less organisation than previous ones...
05:51:00 <Heffalump> ndm: aren't you (co-)organising it? :-)
05:51:09 <ndm> Heffalump: yes, this may be the reason
05:52:38 <Igloo> heh
05:53:12 <dons> `Exactly. I just gave my 3 year old kid "Haskell School of Expression". He's currently grounded for a week for messing up the comonads in his code. Gosh, my kid is so slow.'
05:53:49 <Igloo> Of course, the previous one was rather easier in that the date and 5 people's attendance were sorted before organisation had to start
06:01:50 <ndm> so really, its all your fault for the poor organisation, for keeping your job
06:02:56 <Heffalump> clearly he should have been made to reapply
06:03:22 <Igloo> :-)
06:04:43 <Philippa> until pretty recently we've been at least equivalently organised to last year. We've not had any offers of crashspace yet though, which we're pretty much dependant on
06:05:16 <Philippa> last year the bulk of the org work happened in the last two or three weeks beforehand
06:06:45 <Philippa> I'd been meaning to prod cam locals about crashspace...
06:15:47 <hpaste>  aaim annotated "stack overflow woes" with "increase stack size" at http://hpaste.org/1913#a1
06:17:36 <dcoutts> Igloo, dons: have we given a specific invitation to all the SoC students to come to AngloHaskell? I think we should, even if most of them can't make it, it's important to invite them.
06:17:59 <dcoutts> do we have a mailing list for them? or does some SoC organiser have a full list?
06:18:25 <Igloo> We haven't specifically invited them, and I don't know of a mailing list for them
06:19:02 <Heffalump> how many are in the UK?
06:19:46 <Philippa> I don't know many are in the UK, I know xerox's thinking of coming again
06:19:48 <Igloo> Oh, I didn't read what you wrote, and assumed you meant the Hackathon
06:20:13 <Heffalump> Hackathon sounds much more appropriate.
06:20:15 <Philippa> IIRC there're others in Europe who may well find it's doable
06:20:24 <Igloo> That's why I assumed it  :-)
06:20:37 <Philippa> Hackathon's post-SoC though
06:20:42 <araujo> morning
06:26:19 <dcoutts> Igloo: we should invite them to both, though says it's quite understandable if they don't want to travel all the way to the UK
06:26:44 <dcoutts> Igloo: I just think it's important for them to feel loved :-)
06:26:58 <Igloo> dcoutts: Yeah; worth mentioning the Haskell Workshop too, although it's a pity it's so far from the Hackathon
06:27:11 <dcoutts> aye, several days
06:27:19 <dcoutts> well we can tell them about all the upcomming events
06:27:30 <Igloo> dcoutts: Might be worth waiting until HW prices are known, but there's no particular indication that'll be any time soon
06:27:53 <dcoutts> Igloo: there are student discounts for HW right?
06:28:02 <Igloo> yup
06:28:12 <Igloo> But there might be a not-going-to-ICFP surcharge
06:28:40 <dcoutts> Igloo: I wonder if we could arrange a cheaper price for SoC students with the HW organisers
06:28:47 <dcoutts> it'd be nice to get them involved
06:29:03 <Igloo> Cheaper than the student price, you mean?
06:29:07 <dcoutts> possibly
06:29:17 <dcoutts> they're not PhD students with grants
06:29:23 <dcoutts> they're mostly undergrads
06:29:27 <Igloo> True
06:30:32 <dcoutts> we should ask dons to talk to Gabriel
06:30:51 <earthy> hm. annoying.
06:30:52 * dcoutts goes back to hacking on Cabal
06:30:58 <Igloo> Might also be worth asking about a reduction for Hackathon attendees, as they are mostly paying out of their own pocket too
06:31:18 <earthy> why the heck doesn't cd src/ && runhaskell Tests.hs  do what I want it to do?
06:31:55 <dcoutts> Igloo: this might also be something worth spending haskell.org SoC money on, expenses of getting SoC students to community events
06:31:59 <Igloo> dcoutts: Could also suggest people getting discounts won't get proceedings etc
06:32:12 <dcoutts> worth discussing on the SoC admin list
06:32:24 <dcoutts> Igloo: yes, they probably don't want/need them
06:32:51 <Igloo> dcoutts: It'll probably cost just as much to stay in Freiburg for the intervening few days, of course
06:33:07 <Igloo> Yeah, modern papers are generally on the web anyway
06:35:01 <viat-on> hooray for teh inter webs!
06:35:29 <masak> yes, the webbernet roxx
06:35:44 <masak> best series of tubes in the world
06:36:51 <koala_man> what's wrong if I get "Failed to load interface for `Control.Monad.State'" on "import Control.Monad.State"? I'm using ghc 6.6.1
06:37:17 <Igloo> You need to install the mtl package and use -package mtl or --make
06:37:25 <koala_man> ah, thanks
06:42:59 <matthew-_> mmm. errors in Haskell don't bubble up in the same way as in Java do they?
06:43:14 * earthy ponders the question
06:43:40 * earthy fails to make sense of it
06:43:57 <matthew-_> huh. Well I'm doing a catch
06:44:14 <matthew-_> but the error's still happening and it's not hitting the catch
06:44:22 <earthy> ah. yeah, that can be.
06:44:34 <matthew-_> the error's happening in ByteString and the code is moduleError fun msg = error ("Data.ByteString." ++ fun ++ ':':' ':msg)
06:44:57 <matthew-_> I'm using System.IO.Error.catch - maybe I should be using some other catch?
06:45:10 <dcoutts> mathrick: Control.Exception.catch
06:45:30 <mauke> catching error is evil :/
06:45:43 <matthew-_> mauke: not if it's a recoverable error it's not
06:46:00 <mauke> error is not supposed to be recoverable
06:46:15 <earthy> 'Non-I/O exceptions are not caught by this variant; to catch all exceptions, use catch from Control.Exception'
06:46:21 <matthew-_> thank you
06:46:31 <earthy> that is, System.IO.Error.catch only catches calls to ioError
06:46:39 <matthew-_> not enough effort goes into designing mechanisms to recover from exceptional situations
06:46:52 <earthy> also, 'Note that due to Haskell's unspecified evaluation order, an expression may return one of several possible exceptions: consider the expression error "urk" + 1 `div` 0. Does catch execute the handler passing ErrorCall "urk", or ArithError DivideByZero?
06:46:56 <earthy> '
06:47:11 <earthy> matthew-: that is one of the notable fallacies in the current standard libs indeed
06:47:24 <matthew-_> Erlang does it quite well. I actually quite like Java's caught/uncaught system, though it's normally abused
06:47:27 <earthy> 'no good standardised way of dealing with exceptional situations'
06:47:56 <matthew-_> yeah, well you'd have thought there could be some interesting design options in this space
06:48:04 <earthy> there are. :)
06:48:44 <earthy> which really is why there hasn't been a standard method chosen yet
06:49:19 <matthew-_> agh, brill, that works. Thanks
06:50:38 <mux> ?where ndp
06:50:38 <lambdabot> http://darcs.haskell.org/packages/ndp/Data/Array/Parallel/ http://www.cse.unsw.edu.au/~chak/project/dph
06:53:21 <pejo> earthy/matthew, wasn't there someone discussing/mailing about it earlier? In fact it was several different mechanisms that might be needed.
06:53:50 <desp> hmm
06:53:56 <desp> @where HOC
06:53:56 <lambdabot> I know nothing about hoc.
06:54:43 <desp> I just found http://hoc.sourceforge.net/
06:54:44 <lambdabot> Title: HOC: A Haskell to Objective-C Binding
06:54:53 <desp> but it appears to have been last modified on 2004
06:55:03 <fasta> @where + HOC http://hoc.sourceforge.net/
06:55:03 <lambdabot> I know nothing about +.
06:55:07 <fasta> @where+ HOC http://hoc.sourceforge.net/
06:55:07 <lambdabot> Done.
06:55:14 * desp glares at fasta
06:55:22 <desp> it's not in hackage, either
06:55:50 <desp> does anyone know if it's just pining for the fjords?
06:56:49 <EvilTerran> 2004? looks nailed to its perch to me.
06:57:44 <dmwit> So, I want to see if I understand this.  StateT Int [] is a monad that has one copy of the Int state, and multiple possible outcomes.  ListT (State Int) has multiple possible outcomes, each of which has its own (possibly different) Int state.
06:57:50 <dmwit> Is this correct?
06:59:29 <Heffalump> EvilTerran: are you coming to AngloHaskell?
06:59:36 <Cale> runStateT :: (StateT Int [] a) -> Int -> [(a,Int)]
07:00:11 <Cale> runListT :: ListT (State Int) a -> State Int [a]
07:00:22 <EvilTerran> I wasn't intending to, but now you mention it, it looks like i might be in that approximate area around then. i'll look into it.
07:00:37 <Cale> dmwit: So you have it backwards, I think.
07:01:06 <Heffalump> it's hard being near The Other Place, but one gets used to it ;-)
07:01:37 <dmwit> Cale: urgh
07:01:58 <roconnor> bytestring lengths are cached right?
07:02:22 <dcoutts> roconnor: strict ones, yes.
07:02:29 * roconnor wonder why 11% of my time is spent in bsLength bs = fromIntegral (B.length bs)
07:02:51 <Cale> dmwit: The effects of monad transformers sort of go in the opposite order to how you might expect at first, because they generally work by altering the parameter type of the monads they act on.
07:03:11 * roconnor gives it a specific type signature
07:03:29 <dcoutts> roconnor: why do you need it at any type other than Int ?
07:03:39 <dcoutts> roconnor: are you converting to Int64 ?
07:03:44 <Cale> StateT s m a = s -> m (a,s)
07:03:51 <roconnor> dcoutts: I was giving Rope sizes upto Int64, which might be a mistake.
07:03:56 * dcoutts notes that Int64 is quite slow on 32bit
07:04:09 <roconnor> dcoutts: I tried using Ints instead of Int64, but the code ran slower
07:04:17 <roconnor> which is really bizzare!
07:04:24 <dmwit> Cale: mmm.  I think I'm catching on, slowly.
07:04:37 <dcoutts> roconnor: it is bizarre
07:04:54 <roconnor> dcoutts: I should investigate more how that could happen.
07:05:21 <dcoutts> roconnor: each chunk can't be more than Int sized, but if you're allowing lazy IO then your rope could be bigger than Int
07:05:22 <roconnor> FYI, I'm on a 32 bit machine.
07:05:30 <Cale> dmwit: In general, the easiest way to figure it out is just to have a look at the composition of run functions which you'd need to use to unwind your transformer stack. The result type of that basically will tell you how the monad will work.
07:05:49 <roconnor> dcoutts: ropes are effectively strict, so I think Int would be better.
07:05:57 <roconnor> dcoutts: but Int64 is safer
07:06:26 <roconnor> dcoutts: I don't know if it is possible to have two strict bytestrings in memory whose total length exceeds 2^32
07:06:30 <dcoutts> roconnor: but are they really strict? couldn't you make a rope for a 50 GB file and use lazy io to bring chunks in as necessary ?
07:06:59 <dmwit> Cale: Okay, I'll use that until I'm strong enough to understand it without ghci's help. =)
07:07:01 <roconnor> dcoutts: inserting chunks strictly memoizes the lengths.
07:07:03 <dcoutts> roconnor: so long as you don't pull in more than about 2GB into virtual memory
07:07:11 <Philippa> Int != CInt, it could contain tags
07:07:58 <dcoutts> roconnor: sure, inserting does, but you could support lazy IO to a massive file of known length without pulling all the data in from disk on construction
07:08:09 * dmwit goes off to play with ReaderT String CGI
07:08:18 <roconnor> dcoutts: yes, I suppose that is possible.
07:08:33 <dcoutts> roconnor: consider reading little bits of a huge mpeg file, in a random access way
07:08:57 <roconnor> dcoutts: so prehaps Int64 isn't necessarily a bad idea after all.
07:09:02 <dcoutts> roconnor: we had someone who wanted to use lazy bytestrings for that, but they're not appropriate since they can't do random access
07:09:14 <dcoutts> but a rope with lazy IO would be ideal
07:09:49 <roconnor> dcoutts: untill you pull too much into memory at least ;)
07:09:57 <dcoutts> roconnor: of course :-)
07:12:46 <mux> ?where+ ndp http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
07:12:47 <lambdabot> Done.
07:12:51 <mux> ?where ndp
07:12:51 <lambdabot> http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
07:13:02 <mux> hm, it erased the other links :-/
07:13:13 <mux> how is this plugin supposed to work?
07:13:54 <roconnor> boy, Seq Word8 is so fast.
07:20:54 <Igloo> nominolo: If I have 2 build-depends sections, are they supposed to concatenate?
07:21:47 <nominolo> only if they are not on the same level
07:21:57 <nominolo> but that's rather inconsistent, yes
07:22:08 <dmwit> mux: ?where+ is really ?where=, but the programmer pressed the shift key at an inopportune time. ;-)
07:22:13 <Igloo> nominolo: It didn't seem to work
07:22:24 <nominolo> no it doesn't
07:22:36 <mux> dmwit: heh
07:22:49 <mux> dmwit: so can I just pass several parameters to where+ ?
07:22:50 <Igloo> nominolo: http://hpaste.org/1937 is what I wanted to do
07:23:02 <Igloo> Err, except with a !
07:23:13 <nominolo> Igloo: oh that should work
07:23:19 <mux> ?where+ ndp http://darcs.haskell.org/packages/ndp/Data/Array/Parallel/ http://www.cse.unsw.edu.au/~chak/project/dph http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
07:23:19 <lambdabot> Done.
07:23:26 <mux> ?where ndp
07:23:26 <lambdabot> http://darcs.haskell.org/packages/ndp/Data/Array/Parallel/ http://www.cse.unsw.edu.au/~chak/project/dph http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
07:23:29 <mux> fine
07:25:10 <viat-on> is there anything like distcc for ghc?
07:26:49 <nominolo> Igloo: what does System.Info.os return on windows?
07:28:38 <Igloo> nominolo: Hang on, I'll check I wasn't being stupid shortly
07:30:21 <Igloo> nominolo: Actually, I won't, as I've run into other problems
07:31:04 <nominolo> Igloo: i'll be around
07:35:59 <nominolo> Igloo: quick googling shows me it should be either win32 or mingw32
07:36:48 <mauke> all (`elem` os) "win32"
07:37:06 <Igloo> nominolo: That wasn't the problem, as it was checking that it wasn't Windows on a Linux machine
07:37:15 <matthew-_> if you have multiple threads (forkIO), and the "main" thread terminates, will the whole RTS terminate?
07:38:13 <nominolo> mauke: not quite useful, though ;)
07:38:26 <dcoutts> Igloo: if possible we should change ghc's windows System.Info.os to be win32 rather than mingw
07:38:29 <matthew-_> ahh, apparently so.
07:38:33 <dcoutts> Igloo: ndm is right on this issue :-)
07:39:30 <nominolo> dcoutts: the System.Info.os issue?
07:39:47 <dcoutts> nominolo: yes
07:40:20 <nominolo> mingw32 doesn't sound too useful, yep
07:40:40 <nominolo> then again, there might be cases where you want to test for that
07:40:48 <nominolo> which we currently don't have
07:41:41 <nominolo> or at least we would want to have os(mingw32) => os(win32)
07:49:09 <Igloo> dcoutts: Make a proposal  :-)
07:49:46 <dcoutts> Igloo: sigh, like a spec for all common platforms? so all the compilers use the same
07:57:07 <roconnor> > 127556880 / 29958133
07:57:12 <lambdabot>  4.257838096920125
07:58:42 <roconnor> > 160352894 / 58252268
07:58:44 <lambdabot>  2.7527322026328656
07:59:07 <Lemmih> roconnor: What are those numbers?
07:59:28 <roconnor> Lemmih: the number of calls to bsLength per number of calls to append.
07:59:41 <roconnor> I expect bsLength to be called twice per append
07:59:44 <roconnor> not 4 times!
08:00:53 <Lemmih> roconnor: I've found that a special version of 'viewl' for Chunks is quite a bit faster than using 'modifyl'.
08:01:10 * drrho is away: getting ice cream
08:01:33 <roconnor> Lemmih: oh?
08:02:03 <roconnor> > 127556880  - 2*29958133
08:02:05 <lambdabot>  67640614
08:02:23 <roconnor> > 160352894 - 2*58252268
08:02:24 <lambdabot>  43848358
08:03:00 <roconnor> Lemmih: but viewL is just uncons.
08:03:57 <Lemmih> roconnor: uncons is viewl+modifyl.
08:04:13 <profmakx> s there already useable code for finger trees available?
08:04:41 <Lemmih> @hackage fingertree
08:04:42 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fingertree
08:05:41 <hpaste>  Lemmih pasted "viewlRope" at http://hpaste.org/1938
08:07:32 <roconnor> Lemmih: so we should write a modifyWithResult function for finger trees?
08:08:47 <Lemmih> modifyLWithResult, yeah.
08:09:39 <roconnor> Lemmih: are Ropes still slower than Seq Word8?
08:09:45 <Lemmih> roconnor: Yes.
08:10:02 <roconnor> how much more do we need to gain?
08:10:22 <Lemmih> Quite a lot. It's several times slower on empty.dna.
08:23:39 <hpaste>  Rasser pasted "wanted :: Int -> Bool" at http://hpaste.org/1939
08:23:52 <desp> hm
08:23:55 <desp> is the hawiki gone?
08:27:22 <Lemmih> desp: Yes.
08:27:29 <desp> :C
08:29:48 <hpaste>  roconnor pasted "remove calls to null in Rope.append" at http://hpaste.org/1940
08:29:57 <Rasser> I found the types using :t and now it magically works
08:30:37 <hpaste>  kpreid annotated "wanted :: Int -> Bool" with "add fromIntegral" at http://hpaste.org/1939#a1
08:30:49 <Lemmih> roconnor: How much does that give you?
08:31:00 <roconnor> Lemmih: testing now
08:31:52 <Rasser> thanks kpreid
08:32:54 <roconnor> Lemmih: 4m40.731s => 3m29.820s
08:33:03 <roconnor> But I haven't implements your fast uncons yet
08:33:11 <roconnor> so my uncons is calling append.
08:33:28 <roconnor> and I'm running geneList1.dna
08:34:37 <desp> aren't LPS basically Ropes?
08:34:52 <roconnor> LPS?
08:34:58 <desp> lazy ByteStrings
08:35:03 <nominolo> desp: not really
08:35:14 <nominolo> ropes have trees
08:35:16 <nominolo> not lists
08:35:23 <desp> ah
08:35:48 <nominolo> i guess Seq ByteString is pretty much what a rope is about
08:36:19 <dcoutts> nominolo: yes, FingerTree Int ByteString
08:36:23 <nominolo> but you need a strategy to deal with short strings
08:36:23 <cmhh_> Rasser: I don't know if this helps you or not, but perfect squares only end in 0,1,4,5,6,9
08:36:40 <dcoutts> nominolo: indeed, roconnor and Lemmih have been looking at just that
08:36:40 <roconnor> specifically FingerTree (Sum Int) ByteString.
08:36:49 <nominolo> dcoutts: good to hear
08:37:09 <dcoutts> and if it turns out well I'm most inclined to put it into the bytestring package
08:37:36 <nominolo> dcoutts: that would certainly be a very useful data structure
08:37:52 <roconnor> dcoutts: so far it is slower than Seq Word8 on our test case.
08:38:02 <dcoutts> roconnor: I have faith :-)
08:38:08 <roconnor> (but consumes a lot less memory)
08:38:09 * nominolo too
08:38:47 <roconnor> My goal is to run endo.dna with a haskell program in less than 1 minute.
08:39:12 <desp> hmm.
08:39:37 <nominolo> i heard of C++ versions running in 18 sec
08:39:48 <nominolo> then again, no idea on which machine
08:41:30 <Lemmih> 18 seconds sounds extreme.
08:43:20 <desp> roconnor: 1m30s with LPS
08:43:53 <roconnor> :)
08:44:55 <roconnor> desp: presumably you do some flattening of LPS at some points?
08:45:07 <desp> yes
08:45:15 <desp> quite possibly, too much
08:45:36 <desp> a bit hard to determine exactly when to do it
08:45:52 <roconnor> I think I ought to be able to get these ropes to run faster than LPS, but I'm not sure I've been able to do that yet.
08:46:04 <wli> LPS?
08:46:09 <desp> wli: LBS
08:46:16 <desp> only with a less rude acronym
08:46:18 <desp> ;)
08:47:03 <Rasser> cmhh_: that also helped :>
08:47:06 <wli> LPS is the name of the Language Prototyping System, which does neat things from very abstract specifications of languages.
08:47:13 <desp> wli: lazy packed strings
08:51:44 <nominolo> ByteSeq
08:51:57 <nominolo> sounds most appropriate to me
08:52:55 <fasta> ByteSeq exposes implementation detail
08:53:24 <nominolo> no
08:53:56 <nominolo> it just shows that you have packed bytes with the big O's of a Seq
08:54:10 <nominolo> at least that's how i see it
08:54:27 <fasta> Never mind.
08:55:11 <desp> Thread!
08:55:12 <desp> ;)
08:55:19 <nominolo> or maybe PackedSeq
08:59:32 <desp> @type const
08:59:34 <lambdabot> forall a b. a -> b -> a
09:00:31 <desp> > const "foo" 1
09:00:32 <lambdabot>  "foo"
09:00:49 <mauke> @. djinn type const
09:00:51 <lambdabot> f a _ = a
09:01:06 <desp> let ignore = const
09:01:48 <nominolo> > foldl' (const . (1+)) 0 [1..10]
09:01:50 <lambdabot>  10
09:03:53 <nominolo> @. djinn type (const . (1+))
09:03:57 * drrho is back
09:04:06 <nominolo> @unpl (const . (1+))
09:04:07 <lambdabot> (\ e _ -> 1 + e)
09:05:04 * desp nods
09:09:52 <Cale> andyjgill: any word on the other SPJ video? :)
09:16:53 <roconnor> @src Data.ByteString.Base.PS
09:16:53 <lambdabot> Source not found. It can only be attributed to human error.
09:17:37 <dcoutts> roconnor:
09:17:38 <dcoutts> data ByteString = PS {-# UNPACK #-} !(ForeignPtr Word8)
09:17:38 <dcoutts>                      {-# UNPACK #-} !Int                -- offset
09:17:38 <dcoutts>                      {-# UNPACK #-} !Int                -- length
09:18:06 <roconnor> dcoutts: I was expect 4 items
09:18:11 <wli> Packed, but with unpacking directives to ghc?
09:18:21 <roconnor> case ds2_d2pn
09:18:21 <roconnor>             of wild2_a2u6 { Data.ByteString.Base.PS rb_a2u8 rb1_a2ua rb2_a2ub rb3_a2uc ->
09:19:04 <Cale> wli: It's a different sense of the word "pack" of course :)
09:19:07 <roconnor> rb3_a2uc is clearly the length field.
09:19:12 <dcoutts> roconnor: that's because the ForeignPtr is unpacked into two fields
09:19:23 <roconnor> ah okay.
09:19:23 <dcoutts> the Addr# and the ForeignPtrContents
09:20:07 <dcoutts> the UNPACK there is vital to get the right machine level data representation with minimum indirections
09:30:31 <desp> dcoutts: equivalent to -funbox-strict-fields, right?
09:30:45 <dcoutts> desp: that's a bigger hammer
09:31:07 <desp> in terms of scope, yes?
09:31:08 <roconnor> dcoutts: If I do length (bs1 `append` bs2), will the memory for the append actually be allocated?
09:31:38 <dcoutts> roconnor: it might fuse under the new system but not in the current system I think
09:31:44 <dcoutts> so yes, it would be allocated
09:31:53 <dcoutts> just use length bs1 + length bs1
09:32:22 <roconnor> dcoutts, okay, that's what I currently do.
09:32:51 <roconnor> but later I ask for the length of the composite bytestring (in some cases)
09:33:05 <roconnor> anyhow, just thinking.
09:33:18 <mauke> :t curry $ uncurry (+) . join (***) length
09:33:20 <lambdabot> forall a. [a] -> [a] -> Int
09:37:32 <dmwit> ?pl \x y -> length x + length y
09:37:32 <lambdabot> (. length) . (+) . length
09:38:30 <mauke> ?pl \length x y -> length x + length y
09:38:30 <lambdabot> flip =<< (((.) . (+)) .)
09:41:32 <desp> @type (||)
09:41:35 <lambdabot> Bool -> Bool -> Bool
09:41:50 <desp> @src (||)
09:41:50 <lambdabot> True  || _ =  True
09:41:50 <lambdabot> False || x =  x
09:44:38 <ari> @karma lambdabot
09:44:38 <lambdabot> lambdabot has a karma of 0
09:57:08 <roconnor> How do I add -O2 to a .cabal file?
09:57:27 <kaol> ghc-options:    -O2
10:02:42 <roconnor> what's the flag for viewing .hi files?
10:05:14 <roconnor> --show-iface
10:15:25 <roconnor> Ah, no fair. Seq's are using a fine-tuned FingerTree.
10:15:34 <roconnor> 	| Deep {-# UNPACK #-} !Int !(Digit a) (FingerTree (Node a)) !(Digit a)
10:15:40 <Cale> roconnor: Why's that not fair?
10:15:43 <mrd> so use Seqs =)
10:16:17 <roconnor> mrd: I need to use a different measure function.
10:16:27 <roconnor> Cale: they cut and paste the code :(
10:18:31 <Lemmih> roconnor: Is an unpacked int really that important?
10:19:18 <roconnor> Lemmih: maybe not.
10:19:40 <roconnor> Lemmih: they also specialize functions of finger trees for Nodes
10:19:58 <roconnor> Perhaps that needs to be added to fingertree.hs
10:22:45 <hpaste>  fxr annotated "state problem" with "state problem" at http://hpaste.org/1900#a3
10:23:46 <dolio> Huh. Apparently google thinks its own links in groups.google.com look like those made by viruses or spyware, and refuses to serve them.
10:24:40 <mrd> truth, in circuitous form
10:25:40 <dolio> I should really try to find a decent usenet server, but free ones are so hard to find.
10:28:11 <roconnor> Lemmih: I think the finger trees are spending a lot of time boxing up integers, looking up addition from a dictionary, and calling add on them which unboxes them again.
10:28:28 <roconnor> Sequences don't have this porblem.
10:29:32 <Lemmih> roconnor: Still using unoptimized libraries?
10:29:46 <roconnor> yeah... I just fixed that now.
10:30:02 <roconnor> Lemmih: but even still, how can fingertrees avoid doing what I said.
10:30:14 <Lemmih> All dictionaries are compiled away.
10:30:16 <roconnor> they don't know that the monoidal operation will be (+)
10:30:39 <roconnor> Lemmih: are all the fingertree functions inlined?
10:34:06 <Lemmih> Hm, they are not.
10:34:24 <roconnor> see Seq is cheating ;)
10:36:15 <roconnor> Lemmih: is it possible to specialize all fingertree functions on the (Sum Int) monoid without speciallising the element type?
10:36:46 <Lemmih> I'm trying that now.
10:36:50 <roconnor> :)
10:37:01 <roconnor> you do that, I'll vaccuum my place.
10:37:03 <Lemmih> Seems to compile. Checking simplified code.
10:42:08 <LoganCapaldo> http://xkcd.com/295/ I don't get it, can someone explain please? (I know DNE stands for does not exist)
10:42:09 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
10:42:18 <LoganCapaldo> </OT>
10:42:18 <BCoppens> LoganCapaldo: Do not erase
10:42:21 <Hirvinen> LoganCapaldo: Do Not Erase.
10:42:24 <LoganCapaldo> Aha
10:42:34 <Korollary> xkcd sucks as usual
10:42:38 <LoganCapaldo> So I _don't_ know what DNE stands for
10:43:11 <mauke> did you read the image title?
10:43:21 <Igloo> I didn't know before reading the comic and inferring it from context
10:43:22 <mauke> the popup thingy
10:43:44 <Igloo> (context including the popup)
10:44:12 <Korollary> If you're scared of erasing an ad URL, you deserve to stare at it for months.
10:44:36 <LoganCapaldo> No I didn't read the alt. (Until now). I actually had to open the image properties because FF decided to cut off the tooltip
10:45:05 <mauke> LoganCapaldo: you want the Long Titles extension
10:45:22 <mauke> it's essential for reading xkcd
10:45:33 <roconnor> If only I was using JHC instead of GHC.
10:45:36 <LoganCapaldo> mauke, I think what I really want is for people not have have paragraph long alt tags <g>
10:45:55 * LoganCapaldo is stunned there's actually an extension for it
10:46:01 <mauke> LoganCapaldo: it's not an alt
10:46:08 <mauke> or rather, the alt text is just "DNE"
10:46:24 <LoganCapaldo> ok :0
10:46:26 <LoganCapaldo> :)
10:46:42 <LoganCapaldo> s/alt/whatever makes tooltips/
10:46:51 <LoganCapaldo> didn't it used to be alt?
10:46:51 <mauke> title
10:47:08 <mauke> in Evil(tm) browsers, yes
10:47:09 <wli> Igloo: How much would it take to add deflate tto your compression lib?
10:47:32 <Igloo> wli: I have it lying around no my hard disk somewhere I think
10:47:55 <wli> Igloo: ooh I wouldn't even have to write it myself, then
10:49:09 * LoganCapaldo begins retroactively hoverring over xkcd images
10:49:21 <LoganCapaldo> I think it's making them less funny.
10:49:30 * LoganCapaldo stops being OT
10:49:34 * LoganCapaldo or tries anyway
10:49:49 <mauke> so apparently I'm an idiot
10:49:51 <Korollary> We have #haskell-blah. You are welcome.
10:49:59 <wli> Maybe the way to go for pivoting is to recurse on the pivoted matrix and then undo it on the spot.
10:50:01 <mauke> rm foo -r * is not a good idea
10:51:34 <roconnor> Lemmih: how'd it go?
10:53:09 <wli> It's Gauss-Jordan basically, so I should be able to get away with it.
11:04:08 <gwern> so I read in the latest Haskell community report: 'HAppS is a framework for developing Internet services quickly, deploying them easily, scaling them massively, and managing them ziplessly.' But, ah, what does 'managing them ziplessly' mean? I don't see why not using zip functions is bad, or actually what relation zip has to HAppS
11:05:11 <wli> There are a number.
11:05:26 <fnord123> Are the ICFP results going to be reported at the conference in oct or before? I would like to know who won now. :)
11:05:32 <glguy> gwern: ziplessly is supposed to mean easily I believe
11:06:05 <glguy> I asked Alex about that too
11:06:12 <glguy> He seems to think that its a common usage
11:06:15 <gwern> glguy: how does one go from ziplessly to easily? is it a bizaare typo or something?
11:06:27 <glguy> gwern: its called slang I think
11:06:37 <mrd> babelfish?
11:06:57 <Igloo> It's book publishing terminology or something IIRC
11:07:01 <ddarius> Which country's slang?
11:07:30 <Igloo> USA, I assume
11:07:51 <Lemmih> roconnor: It doesn't do much /-:
11:07:59 <roconnor> what!
11:08:10 <roconnor> :/
11:08:14 <glguy> if its US slang, its highly regional
11:08:26 <glguy> I've never heard it used before by anyone but Alex
11:08:32 <ddarius> I've never heard "ziplessly"... uh period.
11:08:35 <Heffalump> fnord123: it'll be at the competition
11:08:38 <Heffalump> IM conference
11:08:39 <allbery_b> I'm not familiar with it either
11:08:40 <gwern> yeah. I though I had a good handle on US slang, but even google only shows a few dubious examples
11:08:44 <mrd> ziplessly button up shirts
11:08:46 <Lemmih> roconnor: The dictionary is still passed around.
11:08:55 <roconnor> oh, that sucks.
11:08:59 <gwern> (the first couple of google hits for ziplessly are... the description of HAppS!)
11:10:00 <nominolo> @babel zipless
11:10:00 <lambdabot>   bzzt.
11:10:05 <mrd> clever advertising strategy
11:10:16 <nominolo> -`'-
11:10:18 <roconnor> Lemmih: I'm pretty surprised by that.
11:10:29 <Lemmih> roconnor: Oh?
11:11:19 <roconnor> because Seq specializes it's functions on Node a and Elem a
11:11:29 <roconnor> and those have type variables in them.
11:11:53 <roconnor> Lemmih: My code is faster with Int64 measures than with Int measures
11:12:03 <roconnor> It makes no sense!
11:12:03 <Korollary> ziplessly doesn't sound very american
11:12:33 <nominolo> bollocks
11:13:46 <Korollary> There have been some brits who got custom license plates that said "bollox" in the US.
11:15:02 <sorear> roconnor: Makes sense to me.  LazyByteStrings use Int64 natively, and unless you do something special, GHC's numeric conversions go via GMP
11:15:32 <Lemmih> sorear: We're using strict bytestrings.
11:15:41 <sorear> ah good :)
11:15:48 <hpaste>  jfredett pasted "Type Errors with two-parameter type." at http://hpaste.org/1941
11:16:13 <jfredett> this one is over my head, I've tried everything to figure it out. :(
11:16:15 <roconnor> sorear: I'm not using lazy bytestrings in my rope code.
11:16:33 <roconnor> sorear: ah sorry, Lemmih covered it.
11:17:13 <allbery_b> zipless (a) denoting a short, passionate sexual encounter (OED)
11:18:23 <mauke> jfredett: whoa, do you have a show instance for functions somewhere?
11:18:36 <jfredett> no- that was supposed to be removed-
11:18:39 <jfredett> could that be it?
11:18:47 <mauke> no
11:19:21 <jfredett> mauke: eventually, that will be a graphviz dump. :)
11:19:37 <jfredett> i had originally planned to use a typeclass for the delta function
11:19:47 <jfredett> but then I realized a record type would be better
11:19:47 <doserj> jfredett, traceNextStep _ [] curSt = curSt is the problem
11:19:57 <jfredett> ah- okay,
11:20:04 <jfredett> i didn't really look at that
11:20:23 <jfredett> so- where in there is the problem?
11:20:28 <jfredett> I'm not sure i see it
11:20:52 <doserj> curSt is of type State a
11:21:04 <jfredett> OH!
11:21:06 <jfredett> I'm a dipshit
11:21:08 <doserj> but the result should be of type [State b]
11:21:57 <jfredett> right, okay- I have my type sigs wrong. and my output wrong, :/
11:22:01 <jfredett> cool, thanks
11:22:51 <jfredett> that fixed it
11:22:53 <jfredett> awesome
11:24:41 <_roconnor> boy, I wish I had been using optimized libraries for the contest.
11:27:12 <obk> Question: What is the status of the stream (as in stream fusion) libraries?
11:27:40 <Saizan> _roconnor: optimized libraries as in?
11:28:28 <_roconnor> Saizan: as in libraries that are complied with -O2 instead of nothing.
11:29:06 <Saizan> ah, right
11:29:34 <gkr> _roconnor I've seen you somewhere else.
11:29:41 <gkr> Uhm.
11:29:49 <_roconnor> Lemmih: Oh I see now, the typeclass is (Measured v a)
11:29:59 <_roconnor> Lemmih: so specializing v doesn't help too much I guess.
11:30:07 <Lemmih> _roconnor: Exactly.
11:30:13 <_roconnor> crap!
11:30:50 <ndm> obk: you'd have to ask dons or dcoutts
11:31:22 <ndm> obk: i believe their ICFP results required some compiler hacks, so i guess the first task will be to get those tweaks in first
11:31:27 <dcoutts> obk: we have a standalone list package that implements stream fusion for lists
11:31:50 <dcoutts> the compiler hacks are only necessary to get fusible list comprehensions
11:32:10 <ndm> i thought you said you needed compiler hacks to remove some of the overhead?
11:32:14 <obk> dcoutts: Is this stable enough so I can use it for writing simple code (not worrying about fusion)?
11:32:32 <dcoutts> ndm: only in complex nested cases, like list comprehensions
11:32:37 <_roconnor> Lemmih: if we removed the Monoid requirement on Measured, and added it to every function instead, that would probably let us specalize.
11:32:53 <dcoutts> obk: there's no point in doing that as it presents the same api as the ordinary list library
11:33:11 <dcoutts> obk: the only advantage is to get more fusion and better performance
11:33:32 <obk> dcoutts: I meant the stream data type (with step/yield/etc.)
11:33:53 <dcoutts> obk: well you could do that, but again only do it if you care about fusion and performance
11:34:11 <dcoutts> streams are not more convenient to code with than lists
11:34:21 <ndm> fusion is only a constant time performance benefit, right? i doubt anyone really needs that kind of hyper-performance
11:34:42 <ndm> of course, if everyone has it, everyone is happy - i just mean that its not worth effort to get it, unless you are microbenchmarking
11:34:50 <dcoutts> ndm: right, but it can be a fairly large constant time improvement
11:34:51 <SamB> obk: you don't write stream code
11:35:22 <ndm> dcoutts, i could get a 6 fold improvement by spending 300 on a modern machine...
11:35:24 <SamB> well. not unless you have written a program, and find that it goes to slow because of something that won't fuse
11:35:33 <obk> The context is that I have this specialized streaming parser (YamlReference) and I'm looking into making it more "proper", factoring generic stuff out
11:35:42 <dcoutts> ndm: you can't beat C by buying a faster machine :-)
11:35:44 <obk> I was wondering whether it would make sense to make it streams-friendly
11:35:58 <ndm> dcoutts, depends how you do your flawed benchmarks :-)
11:36:02 <dcoutts> obk: there's probably no point in doing that
11:36:09 <ndm> all my benchmarks assume an instance of Pandora running in the background
11:36:13 <obk> Right now it is based on difference lists (DList)
11:36:43 <obk> ndm: You are working on a streaming parser too, right?
11:36:45 <ndm> obk: if DList is the right data structure, Streams will probably go slower, DList supports some operations more than constant faster than list
11:37:04 <ndm> obk: are you refering to BLG or TagSoup?
11:37:16 <SamB> obk: are you using the dlist package?
11:37:18 <ndm> i'm writing a parser generator (BLG), and have a streaming lazy parser (TagSoup)
11:37:19 <obk> ndm: I think I heard about TagSoup going this way
11:37:39 <ndm> yes, i have a lazy streaming parser, but i only use lists and the state monad
11:37:44 <SamB> ndm: what is Pandora?
11:37:50 <ndm> @google Pandora
11:37:52 <lambdabot> http://www.pandora.com/
11:37:52 <lambdabot> Title: Pandora Internet Radio - Find New Music, Listen to Free Web Radio
11:37:56 <ndm> SamB, free internet radio
11:38:03 <SamB> oh.
11:38:05 <obk> dcoutts: Ok, thanks. I'll stick with DLists. It shouldn't be a very difficult transition to streams... I think... if it makes sense down the road
11:38:27 <ndm> @karma+ pandora
11:38:27 <SamB> I run the streaming radio client on my WINDOWS machine ;-)
11:38:27 <lambdabot> pandora's karma raised to 1.
11:38:40 <ndm> i do too, the one i do my benchmarks on :)
11:38:46 <SamB> yes I know ;-P
11:38:47 <obk> ndm: How can you simply use lists in the state monads? Don't you get blocked when hitting a decision point?
11:39:04 <SamB> but if I did it on the machine I program on, it would skip more than it does now
11:39:06 <ndm> obk: you have to block when hitting a decision, the point is to continue as quickly as possible
11:39:27 <andyjgill> Does anyone know where the worker/wrapper idiom is written up (apart from the unboxed paper in 91)? We seems to be using it quite a bit in Haskell rewrites now.
11:39:33 <obk> ndm: I made it possible to "commit" to a parsing path before it is fully parsed, and I use that heavily. You?
11:39:35 <ndm> obk: i.e. consider <foo tag=value>, you can get the whole return and return the tag, or start returning the tag after "<"
11:39:51 <SamB> andyjgill: I thought worker/wrapper was a compiler pass
11:40:18 <ndm> obk: somewhat, its just a state monad and a couple of ~ patterns, very much by hand
11:40:24 <andyjgill> There is a pass that implements this, but it is a general technology, and extremely powerful.
11:40:38 <ndm> SpecConstr has some worker/wrapper stuff in it
11:40:41 <SamB> andyjgill: what do you mean by "haskell rewrites"?
11:40:57 <ndm> {-# RULES #-}, i guess
11:40:57 <obk> ndm: I made it a basic operation of the parsing framework. Took some work :-)
11:41:10 <ndm> obk: yeah, i just played with state monads directly
11:41:13 <andyjgill> For example, the stream based deforestation uses it.
11:41:22 <SamB> andyjgill: hmm.
11:41:25 <SamB> does it now?
11:41:35 <ndm> @google constructor specialisation simon peyton jones
11:41:37 <lambdabot> http://research.microsoft.com/~simonpj/
11:41:37 <lambdabot> Title: Simon Peyton Jones
11:41:39 <dcoutts> andyjgill: I'm not sure exactly what you mean
11:41:55 <SamB> andyjgill: maybe you are seeing something more general and calling it worker/wrapper
11:42:01 <ndm> andyjgill: http://research.microsoft.com/~simonpj/papers/spec-constr/index.htm
11:42:03 <lambdabot> Title: Constructor specialisation for Haskell programs, http://tinyurl.com/2qf2ur
11:42:12 <andyjgill> You split a function into a worker and wrapper. You inline the wrapper. You apply optimizations. You get a much better program.
11:42:24 <ndm> typically the worker is recursive
11:42:40 <ndm> so you do some "one time" overhead in the wrapper, then the worker avoids that afterwards
11:42:54 <andyjgill> If your worker and wrapper admit a fusion law when backwards, you can optimize recursive programs.
11:43:16 <dcoutts> andyjgill: ah ok, you mean the: unstream . f . stream  pattern
11:43:26 <SamB> andyjgill: but isn't it only worker/wrapper if it's based on the function's actual body?
11:43:33 <dcoutts> andyjgill: I'd not thought of that as being a worker/wrapper thing
11:43:49 <andyjgill> wrapper = F ( .... G ..), and if G . F == id, then inlining F  will give you fusion
11:44:21 <andyjgill> Yes, sort of. Its a very powerful, very general idea, and its folklore, and should be used wider.
11:44:21 * SamB wonders how much Core andyjgill has stared at
11:44:52 <dcoutts> andyjgill: I don't know of any reference for that apart from papers that use the idea like the bytestring/streams papers
11:44:58 <SamB> andyjgill: I don't really see how what you are talking about is worker/wrapper exactly
11:44:59 <andyjgill> The original reference is http://citeseer.ist.psu.edu/jones91unboxed.html
11:45:01 <lambdabot> Title: Unboxed Values as First Class Citizens in a Non-Strict Functional Language - Jon ...
11:45:25 <ndm> the stuff in that paper isn't about fusion though, is it?
11:45:34 <andyjgill> Yes, that is correct.
11:45:39 <SamB> ndm: indeed! it's about, uh, unboxed values
11:45:43 <dcoutts> andyjgill: I'd say that SpecConstr essentially generalises the worker/wrapper transform that has been in ghc for some time.
11:45:48 <ndm> thats about unboxing in a wrapper, then using unboxed values in a worker, which is recursive
11:45:56 <andyjgill> We have a general idiom (WorkerWrapper), which is applied to optimization of unboxing.
11:46:14 <dcoutts> right
11:46:17 <andyjgill> We also used it in foldr/build.
11:46:29 <SamB> andyjgill: okay so where does worker/wrapper come into this unstream . f . stream bit?
11:46:39 <andyjgill> I believe the streams fusion also uses it.
11:46:59 * andyjgill Looking up the streams paper...
11:47:03 <ndm> yes, i'm pretty sure from my understanding it does
11:47:04 <bct> is there an HTTP library that supports https?
11:47:05 <SamB> I suppose it's rather essential
11:47:30 <ndm> but the unboxed stuff and streams stuff use the same worker/wrapper split, but for entirely different purposes, i think
11:47:40 <SamB> ndm: hmm.
11:47:45 <SamB> you think so?
11:47:47 <ndm> in one the idea is that the worker is fast, in the other is that the wrappers can fuse
11:47:49 <dcoutts> andyjgill: I'm not sure where you'd draw the line, eg the binary lib has a wrapper like thing that performs allocation and the body does the work, we can combine adjacent allocating wrappers
11:47:49 <SamB> I don't think so.
11:48:12 <dcoutts> andyjgill: write n (...) >> write m (...) = write (n+m) (... >> ...)
11:48:54 <dcoutts> would you say thats an instance of the same idiom?
11:48:57 <SamB> I've seen a few manually specified worker/wrapper pairs...
11:49:01 <andyjgill> Ahh. The example at the end of the second page.
11:49:20 <fnord123> has anyone gotten SOEGraphics working on ghc on os x? http://www.haskell.org/soe says it's for hugs. http://haskell.cs.yale.edu/graphics/ says it works for ghc but windows and linux only (not osx --and it didnt build on os x)
11:49:20 <SamB> like say GHC's length
11:49:21 <lambdabot> Title: Home Page
11:49:34 <andyjgill> map f . map g => unstream . mapS f .  stream . unstream . mapS g . stream
11:49:47 <dcoutts> andyjgill: yep
11:50:07 <dcoutts> expand wrappers, eliminate adjacent bits
11:50:18 <andyjgill> The upstream and stream are wrapper(s), and you inline these at the call site to get fusion.
11:50:46 <dcoutts> andyjgill: well, we eliminate adjacent pairs with a rule
11:51:24 <dcoutts> andyjgill: then we inline the workers and rely on SpecConstr and case-of-case to get fusion
11:51:31 <andyjgill> This is all I am saying. But if never seen this inlining of wrappers used outside GHC hackers, and its great for paper and pencil proofs.
11:52:03 <obk> dcoutts: I just looked at http://www.cse.unsw.edu.au/~dons/code/streams/list/Data/Stream.hs and it seems that what i am doing is almost exactly "Step a s" (DLists are a different part). Maybe I should just duplicate that part of the API plus the stream/unstream functions?
11:52:09 <ndm> i'm not entirely sure how you can use it for proofs? any particular proofs in mind?
11:52:25 <dcoutts> ndm: proofs of the fusion rule? :-)
11:52:32 <dcoutts> we have one of those actually, sort-of
11:52:33 <andyjgill> The pattern is : <you function> ==>  wrapper (worker ) ==> inline wrapper ==> new opportunities for optimization.
11:52:34 <ndm> i can see how it allows optimisations, but not much other than proofs of that
11:52:42 <dcoutts> andyjgill: yes
11:53:01 <andyjgill> So take this example.
11:53:01 <SamB> I thought it was more like...
11:53:08 <ndm> dcoutts, a proof of something which isn't true?
11:53:15 <SamB> wrapper (I# x) (I# y) = worker x y
11:53:16 <Philippa> optimisation can be simplification, no?
11:53:27 <dcoutts> ndm: the proof assumes non _|_
11:53:36 <ndm> dcoutts, i know :)
11:53:42 <andyjgill> Rewrite: (xs :: [Int]) ==> h2c (c2h xs)
11:54:07 <dcoutts> ndm: all we need to make it fully true is a type system that allows us to define unpointed types
11:54:25 <ndm> dcoutts, or Catch + termination checker
11:54:32 <andyjgill> where h2c is of type :: Hughes Int -> [Int], and c2h is of type :: [Int] -> Hughes Int
11:54:46 <dcoutts> andyjgill: ok
11:54:58 <andyjgill> You can show this rewrite is correct by trivial application.
11:55:03 <dcoutts> ndm: that'd only help with specific examples
11:55:19 <andyjgill> Hughes a = [a] -> [a]
11:55:28 <jfredett> ... Kind error? *hides*
11:55:29 <dcoutts> ah ok
11:55:32 <ddarius> Unboxed types.
11:55:34 <jfredett> shit, I broke math, or something
11:55:38 <andyjgill> Now you have a fusion law. c2h . h2c ==> id
11:55:51 <dcoutts> yep
11:56:15 <dmwit> jfredett: do tell
11:56:32 <andyjgill> If you then take the inefficient reverse, and wrapper the first rewrite round it, you can split out the h2c as the wrapper.
11:57:10 <jfredett> hang on, dmwit, I'm pasting right now, :)
11:57:14 <andyjgill> Then (after much inlining and rewriting) you can fuse this h2c with the c2h from the other side.
11:57:32 <augustss> hi andy
11:57:49 <andyjgill> Hi augustss
11:58:02 <dcoutts> andyjgill: you mean to get the efficient accumulating reverse?
11:58:12 <andyjgill> dcoutts, yes
11:58:22 <hpaste>  jfredett pasted "Kind error while trying to instance a typeclass" at http://hpaste.org/1942
11:58:22 <andyjgill> Without induction.
11:58:27 <dcoutts> andyjgill: mm, cunning, lemme write it out
11:58:49 <jfredett> I'm sure it s a trivial error of the unwitting, but damn it feels good to cause a kind error
11:58:49 <dcoutts> andyjgill: though proving the fusion rule probably uses induction
11:58:56 <jfredett> makes me feel all mathematical and stuff.
11:59:03 <dmwit> =)
11:59:07 <dcoutts> andyjgill: but you get to re-use the fusion rule for many similar proofs
11:59:13 <andyjgill> Perhaps I need to write a short white paper, but this seems to obvious once you see it, and many hackers use it.
11:59:17 <ddarius> :t Int Maybe
11:59:19 <lambdabot> Not in scope: data constructor `Int'
11:59:19 <lambdabot>  
11:59:19 <lambdabot> <interactive>:1:4: Not in scope: data constructor `Maybe'
11:59:24 <dmwit> > [] Int Int
11:59:25 <lambdabot>   Not in scope: data constructor `Int'
11:59:35 <ddarius> > 3 :: Int Maybe
11:59:36 <lambdabot>      Kind error: `Int' is applied to too many type arguments
11:59:36 <lambdabot>     In the type ...
11:59:37 <jfredett> "> instance Automata GenDFA a b where" is line 103
11:59:48 <jfredett> you want Maybe Int, no?
11:59:58 <andyjgill> The fusion rule (in this case) falls out via simplifications. Even if not, you have a single proof rather than many.
12:00:03 <dmwit> He's showing how to get easy kind errors. ;-)
12:00:11 <jfredett> ddarius: :(
12:00:14 <augustss> :k Int Maybe
12:00:16 <lambdabot>     Kind error: `Int' is applied to too many type arguments
12:00:27 <mauke> jfredett: probably just missing parens
12:00:44 <jfredett> I've tried that, actually, > instance Automata (GenDFA a b) where gives the same error
12:00:52 <jfredett> at least- i think it was the same
12:00:55 <jfredett> let me try it again
12:01:26 <jfredett> oh, that ones different, ish
12:01:36 <jfredett> no, same thing
12:01:38 <jfredett> nevermind
12:01:41 <Heffalump> what are the definitions of h2c and c2h?
12:03:30 <jfredett> maybe the problem is in the declaration of the typeclass?
12:03:38 <Heffalump> h2c f = f [], c2h xs = (xs ++) or (++ xs) I guess.
12:04:10 <augustss> jfredett: if you show us the class and data declarations we could help you
12:04:17 <jfredett> it's been pasted
12:04:27 <jfredett> erm http://hpaste.org/1942
12:05:09 <hpaste>  jfredett annotated "Kind error while trying to instance a typeclass" with "just the class" at http://hpaste.org/1942#a1
12:05:20 <jfredett> thats just the class i'm trying to use
12:05:50 <dmwit> jfredett: Maybe something like:
12:05:54 <jfredett> I think- maybe  "Automata a b c", thats gotta be wrong
12:05:55 <jfredett> :/
12:05:57 <dmwit> instance Automata (GenDFA a b) a b where
12:06:02 <jfredett> hmm
12:06:04 <jfredett> worth a shot
12:06:35 <jfredett> hmm, it can't match the types now- but theres no kind error
12:06:40 <augustss> well Automata has three parameter, so you'd better give it that
12:06:48 <dmwit> Sorry, I meant (GenDFA b a) a b
12:06:55 <jfredett> augustss: makes sense,
12:07:04 <jfredett> dmwit: I was thinking the same thing.
12:07:56 <jfredett> close- it can't deduce some stuff, hmm oh! I know, i just have to add Eq constraints
12:07:57 <jfredett> there
12:08:02 <jfredett> works now, Thanks guys
12:08:29 * wli has GenGLRautomaton on the brain.
12:09:43 <wli> There is an inbounds check
12:09:59 <wli> What is its name...
12:10:11 <ddarius> inRange?
12:10:15 <sorear> Ooh!
12:10:18 <sorear> Sun Jul 29 06:21:57 PDT 2007  Ian Lynagh <igloo@earth.li> * Use cabal configurations rather than Setup hacks
12:10:25 <wli> Thanks.
12:10:48 <sorear> Finally, no more of those disgusting library setup files!
12:10:52 <sorear> nominolo++
12:11:15 <Igloo> They're not completely gone, but they're better
12:11:45 <nominolo> i'm prepared for many bug-reports, though ;)
12:12:45 <jfredett> hmm, that didn't do what I expected :/
12:18:38 <ndm> nominolo: whenever I try and install something with Cabal I open a bug report ready just in case :)
12:18:53 <Igloo> :-)
12:19:14 <nominolo> ndm: yep, and backup everything first
12:19:16 <Botje> it's easier to just hack bugreports into your cabal install then :P
12:19:47 <nominolo> after all Cabal lives completely in IO
12:20:24 <ndm> apart from the hooks that i wished lived in IO, they don't @_
12:20:26 <nominolo> would it be useful to have a CabalM, and optionally disallow IO?  for dry-runs
12:21:42 <hpaste>  jfredett annotated "Kind error while trying to instance a typeclass" with "Type Class not working the way I expected" at http://hpaste.org/1942#a2
12:21:45 <Igloo> You need to look at what files exist at least
12:21:47 <nominolo> yeah, there should be a cleaner way for hooks to add actions.  maybe they should return actions in CabalM?
12:21:54 <jfredett> :( last problem, I hope
12:22:24 <nominolo> Igloo: but i think we shouldn't have a pure IO there
12:22:58 <nominolo> "pure"
12:23:05 <ndm> not much additional security, unless you ban unsafePerformIO
12:23:23 <ndm> then you are giving the illusion of security, while configure can still launch nuclear missiles
12:23:28 <nominolo> ndm: yes. couldn't that be done?
12:23:54 <nominolo> ndm: yeah it could
12:24:07 <ndm> nominolo: no, then you just have to add template haskell in, its theoretically possible, but unlikely
12:24:23 <ndm> the only way to remove security problems is to not use a Setup.hs
12:24:47 <nominolo> yep
12:25:45 <ndm> that would be lovely, if the patch to cabal goes in which means you don't have to have Setup.hs
12:27:11 <nominolo> how would installing work then?  makefile?
12:27:25 <nominolo> shell script?
12:27:43 <jfredett> anyone care to help on http://hpaste.org/1942#a2 ? :)
12:28:24 <ndm> cabal-install file, you still have a .cabal, just not a Setup.hs, and assume the very simple Setup.hs
12:28:30 <ndm> i.e. some Cabal binary
12:29:36 <nominolo> ah, a cabal-setup
12:31:46 <ndm> exactly
12:32:32 * SamB has a cabal-setup binary that seems to work
12:33:35 <SamB> but... it's apparantly a bit old?
12:40:09 <wli> @djinn (a -> Maybe a) -> Maybe a -> Maybe a
12:40:10 <lambdabot> f a b =
12:40:10 <lambdabot>     case b of
12:40:10 <lambdabot>     Nothing -> Nothing
12:40:10 <lambdabot>     Just c -> a c
12:41:30 <wli> a.k.a. (=<<)
12:46:36 <kaol> can I use cabal to build .hs files in parallel? My CPU's second core yearns to get to compile haskell too.
12:47:14 <Igloo> Only with GHCMakefile, currently
12:47:48 <Igloo> Need http://hackage.haskell.org/trac/ghc/ticket/910 for Cabal proper to do it
12:47:49 <lambdabot> Title: #910 (--make should have a -j flag for parallel building) - GHC - Trac
12:48:00 <Igloo> Or Cabal to do dep anal
12:50:29 <sorear> According to the original paper on SMP GHC, GHC itself has already been parallelized.  Why wasn't it pushed?
12:52:22 <Igloo> It wasn't quite right
12:52:44 <Igloo> GHC's interface loading etc is lazy, and it wasn't playing right with -j IIRC
12:53:05 <Igloo> The patch is in the bug report
13:01:54 <jfredett> anyone care to help on http://hpaste.org/1942#a2 ? :) I'm really quite stuck.
13:03:06 <jfredett> its supposed to be evaluating
13:03:06 <jfredett> trace test :: (Automata (GenDFA Int Int) b c) => Symbols b -> States c
13:03:06 <jfredett> as trace test :: (Automata (GenDFA Int Int) Int Int) => Symbols Int -> States Int
13:03:15 <jfredett> but it doesn't seem to be capable
13:12:50 <jfredett> I figured it out, it was functional dependencies, whodathunk?
13:21:11 <andun> are there any good examples (or exercises) of usage of the State Monad?
13:22:54 <ddarius> andun: There are some examples in the State monad documentation.
13:24:06 <andun> oh, thanks
13:27:54 <mauke> @where monads
13:27:55 <lambdabot> http://www.nomaware.com/monads/html/index.html
13:28:56 <mauke> @where+ monads http://www.haskell.org/all_about_monads/html/
13:28:56 <lambdabot> Done.
13:28:58 <mauke> @flush
13:28:59 <lambdabot> Not enough privileges
13:29:42 <sorear> Someone should figure out what happened to break auto-save.
13:48:03 <wli> Well, I can triangularize and dump the pivot stack.
13:49:20 <roconnor> Lemmih: ugh, the dictionaries are reintroduce at the calls to foldMap
13:55:23 <jbalint> hi, i'm trying to do something like data A = B | C, data X = Y | A, but I want A to mean B|C, is this possible?
13:55:45 <mauke> no, only A A
13:56:00 <jbalint> is there a way to 'compose' data declarations?
13:56:34 <mauke> I don't think so
13:56:38 <basti_> yes, as parameter of the constructur, i'd say...
13:56:46 <basti_> data X = Y | Borc A
13:56:56 <jbalint> ah
13:57:07 <jbalint> i think thats what mauke said, but i didnt understand it right?
13:57:20 <basti_> i guess.
13:58:48 <jbalint> thanks
14:02:34 <jbalint> hrm, now i'm confused, becase A A works as I wanted :)
14:02:51 <Cale> jbalint: The first and second A are in separate namespaces :)
14:03:07 <Cale> jbalint: the first A is a data constructor, and the second is a type constructor
14:03:08 <jbalint> but wouldn't I have to do A B to get an X?
14:03:09 <Lemmih> roconnor: It might be interesting to benchmark with a specialized version of FingerTree.
14:03:12 <rehges> where do i find simple docs on how i should implement "show" for my own data?
14:03:28 <mauke> rehges: you add ... deriving (Show)
14:03:43 <Cale> jbalint: which definitions have you got now?
14:03:55 <jbalint> Cale: data X = A A | Y
14:04:07 <rehges> mauke: to the "data" thing?  don't i need to define _how_ it should do the show, too?
14:04:12 <Cale> data A = B | C ?
14:04:18 <jbalint> yes
14:04:24 <Cale> Then yeah, A B :: X
14:04:54 <Cale> The values of X are: {A B, A C, A undefined, Y, undefined}
14:05:01 <rehges> mauke: huh, it works just like i want automatically :-)
14:05:02 <mauke> rehges: no, it does that for you
14:05:06 <jbalint> Ok. thats what i thought. i must be confusing myself otherwise. thanks
14:05:31 <nominolo> Igloo: did you push the changed cabal?
14:05:35 <Igloo> nominolo: Yup
14:06:37 <jbalint> Cale: how can i specify a parameter of type X that must be A something ?
14:07:03 <jbalint> I had func :: X -> X, and func A x = A x, but it's " Constructor "A" must have exactly 1 argument in patter"
14:07:25 <mauke> func (A x)
14:07:41 <jbalint> oh, thanks
14:10:55 <nominolo> ok, then i'll start patching against that
14:11:46 <Cale> jbalint: yeah, sorry I'd gotten up for a sec :)
14:12:05 <wli> *** Exception: user error (mzero)
14:12:21 <wli> Now I need a consistent system of integer linear equations.
14:13:39 <Cale> jbalint: So suppose you had the Tree type:  data Tree a = Leaf a | Branch a (Tree a) (Tree a).  You could write a function which determined the size of the tree by:  size (Leaf x) = 1; size (Branch x l r) = 1 + size l + size r
14:14:24 <MisterN> hi
14:14:29 <Cale> MisterN: hello
14:14:49 <MisterN> is this the channel with the haskell-compiling bot?
14:14:55 <Cale> yes
14:15:12 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
14:15:14 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
14:15:14 <MisterN> "The language of ICFP winners 3 years running" <- 2006, C++ won
14:15:21 <MisterN> nice
14:15:47 <Heffalump> MisterN: AIUI the winners used Haskell amongst other languages
14:15:56 <Heffalump> they asked for 2D to be their language of choice, though
14:15:56 <sorear> And yes, we do mean haskell-compiling. :)
14:16:03 <Cale> MisterN: actually wasn't it a Haskell team, but they'd decided to name the language 2D?
14:16:04 <MisterN> Heffalump: isn't that 2007?
14:16:23 <MisterN> maybe i remember this wrong
14:16:26 <Heffalump> no, this is 2007.
14:16:26 <Cale> MisterN: the 2007 ICFP winner hasn't been declared yet?
14:16:42 <sorear> > let { nfib::Int -> Int; nfib n = if (n < 2) then 1 else nfib(n-1) + nfib(n-2) } in nfib 40  -- try this in GHCi!
14:16:46 <lambdabot>  165580141
14:17:30 <MisterN> Team Smartass	4	Mountain View, California, USA 	5428	C++, Haskell, Python, bash, 2D, secret Google [___REDACTED___]
14:17:45 <MisterN> i just remembered C++ because that was the first language in the list :)
14:18:13 <MisterN> whatever, this is not why i'm here
14:18:14 <Cale> Yeah, I think they likely used C++ for their UM
14:18:31 <pastorn> sorear: will that terminate?
14:18:41 <MisterN> <lambdabot>  165580141
14:18:45 <MisterN> pastorn: of course
14:18:47 <jbalint> Cale: yeah, that makes sense, i just wasnt thinking correctly when combining the data declarations. thanks again
14:18:52 <sorear> pastorn: Yes, afer a minute or two.
14:18:55 <nominolo> sorear: where did you see that commit message earlier? ghc?
14:18:57 <pastorn> MisterN: adh
14:18:58 <pastorn> ah
14:19:04 <sorear> nominolo: Darcs pull
14:19:09 <pastorn> i'm on a 500MHz machine :/
14:19:11 <MisterN> sorear: so lambdabot is so much faster than ghci?
14:19:30 <sorear> MisterN: yes.  lambdabot uses ghc -O2.  optimized native codes
14:19:42 <sorear> not the bytecode interpreter in ghci
14:19:45 <MisterN> > let x = readChar >>= putChar in x
14:19:46 <lambdabot>   Not in scope: `readChar'
14:19:53 <Cale> I think it's also to do with the machine lambdabot runs on being rather fast
14:20:04 <sorear> good old fashioned namespace control for security.
14:20:07 <nominolo> > 21234213412^123412412
14:20:11 <lambdabot> Terminated
14:20:12 <Cale> (though sometimes it gets swamped with GHC builds :)
14:20:24 <MisterN>  > let { nfib::Int -> Int; nfib n = if (n < 2) then 1 else nfib(n-1) + nfib(n-2) } in nfib 45
14:20:27 <MisterN> > let { nfib::Int -> Int; nfib n = if (n < 2) then 1 else nfib(n-1) + nfib(n-2) } in nfib 45
14:20:27 <nominolo> and a time limit as it seems
14:20:31 <lambdabot> Terminated
14:20:48 <sorear> Cale: it's not *that* fast.  the really fast box is reserved for benchmarks, which need 0 load for obvious reasons
14:20:53 <sorear> @version
14:20:54 <lambdabot> lambdabot 4p534, GHC 6.6 (Linux i686 2.66GHz)
14:20:54 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
14:21:03 <Cale> ah, okay
14:21:04 <wli> MisterN: Why on earth are you doing that?
14:21:12 <sorear> this is not serenity. ;)
14:21:21 <MisterN> wli: why not?
14:21:23 <nominolo> > let fib = 1:1:zipWith (+) fib (tail fib) in fib !! 45
14:21:25 <lambdabot>  1836311903
14:21:34 <Cale> > let fib = 1:1:zipWith (+) fib (tail fib) in fib !! 400
14:21:36 <lambdabot>  2848122981084896117579889376814609956153800887823048909864771956459692714040...
14:21:45 <nominolo> > let fib = 1:1:zipWith (+) fib (tail fib) in fib !! 42
14:21:46 <lambdabot>  433494437
14:21:56 <sorear> yes, there are faster algorithms.
14:22:01 <wli> The whole fastest Fibonacci in the West thing has been done before
14:22:07 <Olathe> Where ?
14:22:20 <wli> I had some pure integer algorithm for a few years before Andrew Bromage.
14:22:30 <wli> Olathe: haskell-cafe IIRC
14:22:33 <Cale> http://www.haskell.org/haskellwiki/The_Fibonacci_sequence
14:22:34 <lambdabot> Title: The Fibonacci sequence - HaskellWiki
14:22:58 <Olathe> Thanks.
14:22:58 <nominolo> > let fib = 1:1:zipWith (*) fib (tail fib) in fib !! 42
14:23:00 <lambdabot>  1
14:23:07 <nominolo> lol
14:23:07 <tuukkah> sorear, so how's lambdabot so fast in evaluating the exponentially defined factorial?
14:23:15 <sorear> > let { gsfib' :: Int -> (Integer,Integer) ; gsfib' n | n == 0 = (0,1)  | odd  n = case gsfib' (n-1)  of (a,b) -> (a+b, a) | even n = case gsfib' (n `div` 2) of (a,b) -> (a*(a+b+b), a*a + b*b) ; gsfib n = fst (gsfib' n) } in gsfib 10000000
14:23:15 <lambdabot>  Parse error in pattern
14:23:26 <nominolo> > let fib = 1:2:zipWith (*) fib (tail fib) in fib !! 42
14:23:29 <lambdabot> Terminated
14:23:31 <wli> Oh wow, I had no idea I was cited there.
14:23:33 <sorear> > let { gsfib' :: Int -> (Integer,Integer) ; gsfib' n | n == 0 = (0,1)  | odd  n = case gsfib' (n-1)  of { (a,b) -> (a+b, a) } | even n = case gsfib' (n `div` 2) of (a,b) -> (a*(a+b+b), a*a + b*b) ; gsfib n = fst (gsfib' n) } in gsfib 10000000
14:23:33 <lambdabot>  Parse error in pattern
14:23:46 <sorear> > let { gsfib' :: Int -> (Integer,Integer) ; gsfib' n | n == 0 = (0,1)  | odd  n = case gsfib' (n-1)  of { (a,b) -> (a+b, a) } | even n = case gsfib' (n `div` 2) of { (a,b) -> (a*(a+b+b), a*a + b*b) } ; gsfib n = fst (gsfib' n) } in gsfib 10000000
14:23:50 <lambdabot> Terminated
14:23:52 <sorear> > let { gsfib' :: Int -> (Integer,Integer) ; gsfib' n | n == 0 = (0,1)  | odd  n = case gsfib' (n-1)  of { (a,b) -> (a+b, a) } | even n = case gsfib' (n `div` 2) of { (a,b) -> (a*(a+b+b), a*a + b*b) } ; gsfib n = fst (gsfib' n) } in gsfib 1000000
14:23:53 <lambdabot>  1953282128707757731632014947596256332443542996591873396953405194571625257887...
14:24:10 <MisterN> gsfib' <- why the '?
14:24:13 <mauke> > let fib n = if n < 2 then 1 else round (t * fromIntegral (fib (n - 1))); t = 0.5 + sqrt 1.25 in fib 12
14:24:13 <Olathe> Did it just get the millionth in a fraction of a second ?
14:24:15 <lambdabot>  233
14:24:18 <sorear> Olathe: Yes.
14:24:28 <mauke> > let fib n = if n < 2 then 1 else round (t * fromIntegral (fib (n - 1))); t = 0.5 + sqrt 1.25 in fib 40
14:24:29 <lambdabot>  165580141
14:24:38 <sorear> Olathe: Gosper and Salamin are household names for a reason. :)
14:24:45 <wli> Floating point gives incorrect answers quite rapidly.
14:24:56 <Olathe> Who are they ?
14:25:22 <wli> You can compute in Z[5^(1/2)] if you want to use the powers, but it's not all that swift in comparison to pure integer algorithms.
14:25:52 <Olathe> http://gosper.org/
14:25:54 <lambdabot> Title: Twubblesome Twelve
14:26:09 <sorear> @go bill gosper
14:26:11 <lambdabot> http://en.wikipedia.org/wiki/Bill_Gosper
14:26:20 <MisterN> this is probably all to easy for you, but i'm currently trying to understand monads. how could one do that without fix? http://hpaste.org/1943
14:26:46 <Cale> MisterN: just refer to foo
14:27:07 <MisterN> Cale: sry?
14:27:16 <Cale> MisterN: you don't really need fix if it's the first thing in a binding, because all bindings in Haskell are recursive anyway.
14:27:19 <sorear> this also uses crucially the fact that * on Integer is very very fast.  O(n log n log log n)
14:27:34 <MisterN> Cale: well, i didn't write the code myself
14:27:47 <MisterN> Cale: i'm just trying to understand. fix makes that harder for me.
14:28:00 <Cale> Where is the code from?
14:28:11 <MisterN> Christoph-D wrote it for me :)
14:28:24 <sorear> -D?
14:28:27 <Christoph-D> hi
14:28:28 <Cale> okay, this code is slightly odd.
14:28:31 <Cale> :)
14:28:31 <MisterN> that's his nick :)
14:28:33 <sorear> oh. :)
14:28:49 <mauke> foo = do { finished <- isEOF; unless finished (getchar >>= putChar >> foo) }
14:28:51 <Christoph-D> (sorry, "Christoph" and "Christoph_" and even "Christoph__" are already taken)
14:28:59 <sorear> MisterN: I thought you were referring to Christiophe P. aka vincenz
14:29:05 <MisterN> Christoph-D: you could revert to cd2000 :P
14:29:18 <MisterN> sorear: no, but i know another vinzenz. :)
14:30:04 <Cale> foo = interact id
14:30:19 <MisterN> mauke: and without do? (i don't know "do" yet, sorry)
14:30:39 <mauke> foo = isEOF >>= \finished -> unless finished (getchar >>= putChar >> foo)
14:30:51 <Cale> foo = isEOF >>= \finished -> unless finished (getChar >>= putChar >> foo)
14:30:53 <Cale> yes :)
14:31:00 <mauke> foo = getContents >>= putStr
14:31:05 <MisterN> hey cool now i get it
14:31:52 <MisterN> mauke: you lost. i wanted to understand some non-linear monad construction
14:31:56 <wli> The millionth Fibonacci number takes 1.48s here, largely due to printing overhead.
14:32:14 <Cale> MisterN: hmm?
14:32:59 <MisterN> Cale: i'm no haskell expert, as i said
14:33:16 <Cale> MisterN: Just trying to understand what you mean by that
14:33:18 <MisterN> > foo = isEOF >>= \finished -> unless finished (getChar >>= putChar >> foo)
14:33:18 <lambdabot>  Parse error
14:33:26 <MisterN> > let foo = isEOF >>= \finished -> unless finished (getChar >>= putChar >> foo) in foo
14:33:33 <lambdabot>   Not in scope: `isEOF'
14:33:34 <Cale> wli: 0.1s in mathematica :)
14:33:50 <MisterN> lambdabot has no IO support?
14:33:52 <wli> Cale: It doubtless has faster printing than ghci.
14:34:01 <Christoph-D> MisterN: (getChar >>= putChar >> foo) should be ((getChar >>= putChar) >> foo) due to operator precedence
14:34:16 <Cale> MisterN: It will flatly refuse to do any IO you give it. It'll just evaluate the IO action, it won't execute it.
14:34:23 <Lemmih> roconnor: Hand specializing FingerTree makes the Ropes a tiny bit faster than Seq Word8.
14:34:31 <MisterN> Cale: why did it complain about isEOF then?
14:34:41 <Christoph-D> isEOF is from System.IO
14:34:43 <Cale> isEOF is in System.IO
14:34:53 <MisterN> and that's not imported?
14:34:55 <Cale> Which isn't imported by the bot
14:34:57 <Cale> yeah
14:35:03 <MisterN> getChar/putChar is where?
14:35:05 <Cale> because it would be pretty much useless :)
14:35:11 <Cale> Those are in the prelude
14:35:11 <mauke> @index getChar
14:35:11 <lambdabot> System.IO, Prelude
14:35:25 <MisterN> now why's getChar in Prelude but isEOF is not??
14:35:38 <shachaf> MisterN: If you're trying to learn about monads, IO is probably not the best one to start with.
14:35:50 <Cale> Nobody really uses getChar all that much anyway :)
14:35:53 <dolio> isEOF is too low level. :)
14:35:54 <MisterN> shachaf: you have to accept what you are given :D
14:36:04 <Cale> If you want to read from the user, you use getLine or getContents.
14:36:20 <Cale> and isEOF isn't really needed for either of those
14:36:48 <shachaf> MisterN: Given?
14:36:56 * shachaf gives MisterN a few monads.
14:37:01 <MisterN> thank you
14:37:02 <shachaf> @instances Monad
14:37:03 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
14:37:04 <Cale> hehe
14:37:13 <Cale> MisterN: Have you read my introduction to IO?
14:37:19 <MisterN> so which one is easier than IO?
14:37:21 <MisterN> Cale: hell no
14:37:25 <Cale> http://haskell.org/haskellwiki/Introduction_to_IO
14:37:26 <MisterN> i don't intend to learn haskell
14:37:27 <lambdabot> Title: Introduction to IO - HaskellWiki
14:37:27 <MisterN> :D
14:37:34 <Cale> check it out, it's only a couple minutes
14:37:44 <Cale> and should give you a good start
14:37:46 <MisterN> http://www.ideastorm.com/article/show/72348/Was_tun_mit_fremdsprachigen_Kommentaren
14:37:48 <lambdabot> Title: Was tun mit fremdsprachigen Kommentaren? - Dell IdeaStorm, http://tinyurl.com/2q3kul
14:37:53 <MisterN> (sorry for abusing lambdabot)
14:38:00 <sorear> MisterN: abusing?!
14:38:12 <ddarius> MisterN: You'll be yelled at if you abuse lambdabot.
14:38:20 <Saizan> @vixen
14:38:20 <MisterN> sorear: well writing a random URL could be considered abuse
14:38:20 <lambdabot> are you being sincere?
14:38:21 <sorear> MisterN: what makes you think there is such a thing?
14:39:08 <Adamant> @vixen abuse vixen
14:39:08 <lambdabot> i am a bit of a vixen :)
14:39:14 <MisterN> > 99 ** 99
14:39:16 <lambdabot>  3.697296376497268e197
14:39:20 <MisterN> heh
14:39:23 <Cale> > 99^99
14:39:24 <lambdabot>  3697296376497267726571879056288054405956687642817411024302599724235525704552...
14:39:40 <MisterN> evil. lambdabot cuts of the end of the line
14:39:58 <ddarius> > [1..]
14:39:59 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:40:01 <ddarius> It comes in handy.
14:40:08 <MisterN> lambdabot: where's your source?
14:40:15 <mauke> @source
14:40:15 <sorear> @version
14:40:15 <lambdabot>  not available
14:40:15 <lambdabot> lambdabot 4p534, GHC 6.6 (Linux i686 2.66GHz)
14:40:15 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
14:40:28 <fasta> MisterN: you can't really talk to it.
14:40:41 <MisterN> fasta: well that would be a feature wouldn't it?
14:40:50 <MisterN> where's your ...? => @...
14:40:54 <MisterN> or something like that
14:40:56 <fasta> MisterN: it's very low-tech (but the architecture is quite high-tech)
14:41:05 <pejo> MisterN, any particular reason for not learning Haskell?
14:41:12 <MisterN> i'm still impressed by it automatically creating tinyurls
14:41:28 <MisterN> pejo: i'm busy doing other stuff. like the exam on tuesday.
14:41:38 <MisterN> well ok, right now i'm wasting time here
14:41:40 <MisterN> but whatever
14:41:44 <Cale> We've probably singlehandedly polluted the tinyurl space beyond comprehension :)
14:42:11 <thermoplyae> Are there any even mildly featured sound / mixer libraries for Haskell?
14:42:15 <pejo> Cale, it's not like they will run out of combinations of letters though
14:42:22 <Cale> That's true
14:43:07 <ddarius> thermoplyae: I think there's a binding to some sound processing thing.  I'm not sure if there are mixer libraries.  I was thinking of making a binding to LADSPA.
14:44:39 <Cale> Christoph-D: actually, the operator precedence doesn't have an effect there.
14:45:15 <Cale> er, hmm, it does, but it's set up so that works :)
14:45:34 <thermoplyae> LADSPA is more for processing and less for actually output, right?
14:45:47 <thermoplyae> I'm looking specifically for a way to make noise; I suppose I could write the mixer myself on top of that
14:46:02 <Christoph-D> are >>= and >> right-associative? I thought they were the other way
14:46:20 <MisterN> http://english.aljazeera.net/News/Templates/Postings/DetailedPage.aspx?FRAMELESS=false&NRNODEGUID=%7b8486EC99-6C81-4C3C-9D21-3A8A5D96A328%7d&NRORIGINALURL=%2fNR%2fexeres%2f8486EC99-6C81-4C3C-9D21-3A8A5D96A328%2ehtm&NRCACHEHINT=NoModifyGuest
14:46:22 <lambdabot> Title: Al Jazeera English - News - Detained Indian Doctor Back Home, http://tinyurl.com/32zfn9
14:46:35 <MisterN> sry again couldn't resist
14:47:26 <Cale> MisterN: it replies to private messages
14:47:31 <dolio> "infixl 1 >>="
14:47:51 <MisterN> > (const const 4) 1 2
14:47:56 <lambdabot>  1
14:48:10 <MisterN> ?
14:48:17 <MisterN> i wanted it to print 4
14:48:21 <shachaf> MisterN: (const const 4) == const
14:48:24 <MisterN> Cale: good to know :)
14:48:33 <shachaf> MisterN: (const 1 2) == 1
14:48:48 <Cale> > const (const 4) 1 2
14:48:50 <lambdabot>  4
14:48:56 <ddarius> thermopylae: There are a few libraries on music composition, but they are at a higher-level than mixing.
14:49:23 <Cale> > (const . const) 4 1 2
14:49:25 <lambdabot>  4
14:49:37 <cr> thermoplyae: you can build a mixer in HSC
14:49:39 <roconnor> Lemmih: sigh, this foldable, traversable stuff is really ineffecently implemented isn't it?
14:49:41 <Cale> :t const . const
14:49:43 <lambdabot> forall b a b1. a -> b -> b1 -> a
14:50:05 <cr> thermoplyae: http://slavepianos.org/rd/f/409875/
14:50:05 <roconnor> Lemmih: a tiny bit faster is good enough for me.
14:50:06 <lambdabot> Title: rohan drape: hsc3* [409875]
14:50:16 <roconnor> Lemmih: the memory savings must be a lot.
14:50:26 <Lemmih> roconnor: It's just too general, I think.
14:50:34 <Olathe> Why is const named that ?
14:50:43 <Cale> Olathe: because it makes constant functions
14:50:55 <ddarius> http://www.haskell.org
14:50:57 <Cale> (const k) is the function which always gives k
14:50:57 <lambdabot> Title: Haskell - HaskellWiki
14:51:03 <Olathe> Oh.
14:51:25 <Olathe> Neat.
14:51:30 <MisterN> lambdabot must have pretty fast internet connection
14:51:54 <Cale> It's at a university
14:52:22 <roconnor> Lemmih: I expect that JHC would work well, doesn't it do whole program analysis?
14:52:46 <SamB> apprantly supero also supports termination
14:54:20 <Lemmih> roconnor: I'd have to duplicate the data structure and all the functions.
14:54:36 <wli> Mine's a bit fancier than Gosper-Salamin, even.
14:56:04 <pejo> SamB, we're all pro termination!
14:56:09 <pejo> SamB, how do you mean 'support'?
14:56:11 <wli> The bitreversal step seems to be crucial.
14:56:40 <SamB> pejo: well, JHC might or might not ever finish compiling your program ;-)
14:56:50 <thermoplyae> cr: Supercollider looks way overkill, but it'll work if I don't find anything else
14:56:51 <thermoplyae> Thanks
14:57:21 <wli> There's probably a faster way to deal with the bits of an arbitrary-precision integer in reverse.
14:57:23 <roconnor> Lemmih: you'd have to duplicate the data structures and all the functions to do what?
14:57:36 <wli> Any suggestions?
14:58:22 <Lemmih> roconnor: To keep things unboxed in the tree.
14:59:14 <roconnor> Lemmih: how did you get it to be specialized?  Didn't you duplicate everything already?
14:59:49 <Lemmih> roconnor: Yes. I made a copy and specialized it.
15:00:52 <roconnor> So what's the problem with keeping this unboxed?
15:03:24 <wli> crushDigits' n = let (q, r) = n `divMod` 10 in if q == 0 then r else crushDigits' $ r + crushDigits' q
15:03:29 <Lemmih> roconnor: Well, not completely. Unboxing is just one of the benefits. All dictionaries and polymorphism has been compiled out.
15:03:30 <wli> There seems to be a space leak in that.
15:03:38 <MisterN> another IO question: how to best read 10 lines from standard input?
15:03:51 <MisterN> now elegance is what i ask for :)
15:04:08 <Cale> MisterN: replicateM 10 getLine
15:04:21 <Cale> Something like:
15:04:30 <MisterN> Cale: thx. makes sense.
15:04:31 <Cale> do xs <- replicateM 10 getLine; print xs
15:04:49 <wli> ghci runs out of memory on me.
15:04:58 <MisterN> how about replicateM 10 getLine >>= print?
15:05:06 <Cale> sure, that works too
15:05:41 <ddarius> crushDigits' !n = ...
15:06:24 <ddarius> interact (take 10 . lines)
15:06:31 <wli> ddarious: ghci won't parse it
15:06:40 <ddarius> Yeah, it uses -fbang-patterns
15:07:38 <wli> Okay, now it works.
15:07:42 <ddarius> interact (unlines . take 10 . lines)
15:07:58 <ddarius> wli: It parses or it actually works?
15:08:24 <roconnor> Lemmih: what's the speed for empty.dna now?
15:08:58 <Lemmih> roconnor: Testing...
15:09:20 <wli> ddarius: Actually works.
15:10:47 <ddarius> wli: Cool.
15:11:42 <wli> mapM_ print [crushDigits' $ fib1 $ 10^k | k <- [1..6]]
15:12:09 <wli> (40.43 secs, 9764050532 bytes)
15:13:38 <wli> Any suggestions as to how to traverse the bits of an arbitrary-precision integer in reverse apart from unfolding them in a list (as I've already done, even going so far as to write my own unfoldl combinator to avoid having to reverse the list).
15:14:48 <ddarius> Not at all.
15:15:08 <sorear> wli: import GHC.Exts
15:15:17 <Lemmih> roconnor: 5m, down from 6m.
15:15:33 <wli> sorear: What am I looking for in there?
15:15:39 <sorear> J#
15:15:54 <roconnor> Lemmih: ah, and so Seq Word8 is still faster for that case?
15:15:59 <ddarius> sorear: And then what?
15:16:01 <Lemmih> roconnor: Yes.
15:16:21 <Lemmih> roconnor: Seq Word8 is at 2m.
15:16:24 <wli> sorear: Looks like I can get at an unboxed ByteArray
15:16:31 <roconnor> :/
15:16:40 <roconnor> so fast
15:17:01 <wli> That's getting into ugly territory fast.
15:17:03 <roconnor> okay, I'm off to bed.
15:18:21 <sorear> Prelude GHC.Exts> case 0x12345678900987654321234567 of J# ln# ba# -> I# (indexIntArray# ba# (ln# -# 1#))
15:18:24 <sorear> 18
15:18:31 <sorear> 18 being 0x12
15:20:28 <sorear> Prelude GHC.Exts Data.Array.Base Data.Word> case 0x12345678900987654321234567 of J# ln# ba# -> UArray 0 (I# ((ln# *# 32#) -# 1#)) ba# :: UArray Int Bool
15:20:32 <sorear> array (0,127) [(0,True),(1,True),(2,True),(3,False),(4,False),(5,True),(6,True),(7,False),(8,True),(9,False),(10,True),(11,False),(12,False),(13,False),(14,Tr
15:22:52 <ddarius> sorear: They're bitpacked?
15:23:19 <wli> sorear: Hmm, I can actually assume the argument is an Int.
15:23:35 <dolio> Unboxed arrays of Bools are.
15:23:42 <dolio> That's why they were kicked off the shootout. :)
15:23:54 <Olathe> What does it mean to be boxed ?
15:23:57 <sorear> ddarius: This is GMP we're dealing with. :)
15:24:50 <SamB> dolio: is there some kind of rule against that?
15:25:14 <wli> The Gosper-Salamin bits take more steps than mine, but avoid the list processing from my bitreversal.
15:25:39 <dolio> SamB: Most languages don't do that, so it gave haskell an unfair advantage.
15:25:43 <dolio> C++ too, apparently.
15:25:54 <Min46770> wow! Free calls -  http://callfree.point-serv.com/en
15:25:54 <SamB> dolio: why is that against the rules?
15:25:58 <lambdabot> Title: Free phone calls all around the world | Free Calls
15:26:07 <dolio> Don't ask me.
15:26:10 <wli> SamB: Because Haskell wins.
15:26:18 <SamB> I thought the shootout was all about unfair advantages
15:26:25 <SamB> isn't that kinda the point?
15:26:42 <sorear> wli: Why does the list processing matter?
15:26:45 <wli> SamB: Well, that's why I sort of want to start my own alternative shootout.
15:27:00 <sorear> wli: 2^32 has only 32 bits; fib(2^32) takes up ~1G
15:27:06 <wli> sorear: Basically I want my algorithm to be faster than Gosper-Salamin.
15:27:17 <sorear> wli: if the result fits in RAM, the list processing is inconsequential
15:27:59 <wli> sorear: Well, then I can't quite figure out why Gosper-Salamin outdoes it when I take an argument-halving step at every iteration.
15:28:06 <sorear> wli: the algorithm distributed with GMP is about 25% faster; I have a binding, but it's extremely unsafe (if a GC happens at the wrong time expect a segfault)
15:28:22 <wli> sorear: Which algorithm is this?
15:28:37 <ddarius> sorear: I didn't think UArray Int Bool would be bitpacked.
15:28:57 <Olathe> wli: http://gmplib.org/manual/Fibonacci-Numbers-Algorithm.html
15:28:59 <lambdabot> Title: Fibonacci Numbers Algorithm - GNU MP 4.2.1
15:29:18 <wli> sorear: Anyway, I do fib n = snd . foldl fib' (1, 0) . map (toEnum . fromIntegral) $ unfoldl divs n ; unfoldl f x = case f x of { Nothing -> [] ; Just (u, v) -> unfoldl f v ++ [u] } ; divs 0 = Nothing ; divs k = Just (uncurry (flip (,)) (k `divMod` 2)) ; fib' (f, g) p | p = (f*(f+2*g), f^2 + g^2) | otherwise = (f^2+g^2, g*(2*f-g))
15:31:29 <shachaf> Is there a class like Monoid that also has a function like (:[]) (singleton)?
15:32:26 <hpaste>  sorear pasted "for wli" at http://hpaste.org/1944
15:33:03 <sorear> shachaf: We have monadplus (which is slightly stronger, since it also has concat)
15:33:23 <sorear> hmm.  maybe it isn't stronger at all
15:33:29 <sorear> no, it is.
15:33:45 <wli> sorear: Fiddling with the list comprehension bounds should get the bits coming out in reverse no problem.
15:34:17 <sorear> wli: Oh, you wanted it little endian?  that actually makes it much easier :)
15:34:30 <wli> sorear: Not little-endian, but fully-reversed.
15:34:46 <sorear> fully reversed?
15:35:20 <wli> sorear: basically reverse . bitsify
15:36:14 <wli> sorear: If I can assume the argument is single-precision then it's probably simpler, and I think I can.
15:36:49 <pjd> shachaf: there is Alternative, from Control.Applicative
15:37:10 <ddarius> @src Alternative
15:37:10 <lambdabot> class Applicative f => Alternative f where
15:37:11 <lambdabot> 	empty :: f a
15:37:11 <lambdabot> 	(<|>) :: f a -> f a -> f a
15:37:31 <ddarius> @src Applicative
15:37:31 <lambdabot> class Functor f => Applicative f where
15:37:31 <lambdabot>     pure  :: a -> f a
15:37:31 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
15:37:38 <wli> sorear: I'm not entirely sure why the gmp recursion is using the unusual recurrence it is.
15:37:44 <pjd> informally, Monad + Monoid = MonadPlus, Applicative + Monoid = Alternative
15:38:13 <ddarius> And Monoid + Monoid = Ring
15:38:20 <ddarius> Er SemiRing
15:38:52 <pjd> the "lifting" operation is Applicative's pure
15:39:10 <jfredett> theres no way to have a class of classes, is there?
15:39:13 <pjd> (which corresponds directly to Monad's return)
15:40:33 <jfredett> wait- i can do class Foo a => Bar a where ... , right?
15:41:56 <CosmicRay> shapr!
15:42:13 <shapr> CosmicRay!
15:42:15 <shapr> How's code?
15:42:20 <ddarius> Poodle!
15:42:32 <CosmicRay> awesome!  heard simon PJ talk twice last week, and had coffee with him and bos
15:42:37 * CosmicRay is all excited about STM now
15:42:51 * ddarius wants more SPJ videos.
15:43:00 <CosmicRay> ddarius: did you see the one from his oscon keynote at least?
15:43:00 <shapr> Oh, the video is online!
15:43:06 <CosmicRay> unfortunately the video does not show his slides
15:43:07 <ddarius> CosmicRay: Hai
15:43:09 <shapr> And I have a dual-core now, I can do cool STM stuff!
15:43:11 <CosmicRay> but I think they are online somewhere
15:43:11 <pjd> jfredett: yeah
15:43:42 <pjd> jfredett: one sec, let me find the log URL
15:43:48 <dcoutts> CosmicRay: btw, are we going to see all your lovely packages on hackage any time soon? I've been packaging all the missingh bits and hdbc-* for gentoo recently, but it'd be more convenient if they were on hackage :-)
15:43:59 <CosmicRay> simon did an intro to haskell tutorial monday afternoon.  it was great talking to people that had attended.  I sorta wish that I had.  I kept hearing, "man, that guy totally blew my mind, it was awesome"
15:44:15 <CosmicRay> dcoutts: I am trying to get them all uploaded to hackage as they are uploaded to debian
15:44:20 * ddarius really wants to see the video for that one.
15:44:21 <CosmicRay> it should be a lot better now than it was, at least
15:44:24 <dcoutts> CosmicRay: we've got automated tools for dealing with hackage packages and finding out when new versions are out etc
15:44:30 <CosmicRay> ddarius: I don't think video exists for the tutorial
15:44:39 <dcoutts> CosmicRay: oh yes, it is much nicer than it used to be
15:44:39 <CosmicRay> dcoutts: I am also thinking of writing such a beast for debian
15:44:46 <dcoutts> @where hackport
15:44:47 <lambdabot> http://haskell.org/~gentoo/gentoo-haskell/projects/HackPort/
15:44:47 <ddarius> CosmicRay: I thought that's what Andy Gill got?
15:44:54 <CosmicRay> dcoutts: the real problem is that there isn't an automated way to upload to hackage
15:44:56 <dcoutts> CosmicRay: steal code from hackport
15:45:04 <dcoutts> CosmicRay: there is, cabal-upload
15:45:09 <CosmicRay> dcoutts: I have to schlep tarballs across vpns and crap
15:45:10 <CosmicRay> oh?
15:45:15 <dcoutts> yes! :-)
15:45:18 <CosmicRay> I thought the web form was the only working way
15:45:40 <sorear> CosmicRay: So have I (on writing aptage)
15:45:40 <dcoutts> cabal-upload uses the same internal interface that we web one uses
15:45:40 <CosmicRay> dcoutts: btw do you hand out hackage accounts?
15:45:48 <sorear> CosmicRay: no, rossp
15:45:50 * CosmicRay blinks.  aptage?
15:46:01 <dcoutts> CosmicRay: no, ross does, we should work out how to make that a bit more distributed
15:46:02 <sorear> CosmicRay: Apt-hackage gateway project.
15:46:11 <CosmicRay> sorear: ooo, cool.  do you have working code?
15:46:19 * CosmicRay always loves it when someone else has solved a problem first ;-)
15:46:20 <sorear> CosmicRay: no, just ideas. :(
15:46:23 <CosmicRay> oh, bummer
15:46:40 <dcoutts> CosmicRay: we've got hackport working fairly well, there's probably lots of reusable code there
15:46:55 <sorear> CosmicRay: automunge cabal tarballs into debian sourcebaslls... how easy is it to set up a local pbuilder?
15:46:58 <dcoutts> CosmicRay: the code for generating a distro package description is only one little module
15:47:00 <CosmicRay> sorear: I was thinking that we can basically take a cabal file and generate everything in debian/ automatically, and even refresh it from the cabal file.  if we provide a template mechanism, we can permit local overrides when needed.  after that, all that is needed is a mapping from cabal names to deb names
15:47:17 <CosmicRay> dcoutts: url for hackport?
15:47:19 <sorear> CosmicRay: that's trival.  libghc6-foo-dev.
15:47:24 <dcoutts> @where hackport
15:47:24 <lambdabot> http://haskell.org/~gentoo/gentoo-haskell/projects/HackPort/
15:47:27 <dcoutts> oops
15:47:35 <CosmicRay> sorear: what is the source package name is ldap-haskell and the debian binary package is libghc6-ldap-dev?
15:47:39 <dcoutts> @where+ hackport http://haskell.org/~gentoo/hackport/
15:47:39 <lambdabot> Done.
15:47:44 <dcoutts> CosmicRay: ^^
15:47:46 <MisterN> what do you guys think about fudgets? is it good?
15:47:49 * CosmicRay makes a note
15:47:54 <CosmicRay> is fudgets still maintained?
15:47:59 <sorear> CosmicRay: Why can
15:48:13 <sorear> 't the binary package just be libghc6-ldap-haskell-dev?
15:48:26 <MisterN> CosmicRay: i don't know
15:48:37 <sorear> CosmicRay: that has the advantage of making cabal->apt-get trivial for users with dependency problems, as well.
15:48:43 <pjd> jfredett: http://ircbrowse.com/channel/haskell/20070708
15:48:45 <lambdabot> Title: Meme haskell IRC Log 2007/07/08
15:48:59 <CosmicRay> sorear: I think your statement got cut off.  I saw only "why can"
15:49:00 <pjd> there are 3 equivalent definitions of filter' there
15:49:09 <sorear> CosmicRay: keep reading.
15:49:17 <sorear> CosmicRay: ' and <ENTER> are too close.
15:49:53 <CosmicRay> oh my nick highlighting confused me
15:50:02 <CosmicRay> sorear: well the cabal name is LDAP anyway
15:50:06 <CosmicRay> so I don't know that would help
15:50:18 <pjd> for (MonadPlus m), (Alternative m, Monad m), and (Applicative m, Monoid (m a), Monad m)
15:50:19 <sorear> CosmicRay: uhm... libghc6-LDAP-dev?
15:50:23 <CosmicRay> heh
15:50:41 <CosmicRay> hmm I guess that in this case we can just lowercase the cabal name
15:50:45 <CosmicRay> maybe that would work in all cases
15:51:57 <Igloo> It should say somewhere that Cabal package names are required to be unique case insensitively
15:52:12 <Igloo> I can't remember where, though, or if anything check
15:52:13 <Igloo> s
15:57:36 <Ben`> how can I output the numbers from 1 to 100?
15:58:30 <shachaf> mapM_ print [1..100]
15:59:19 <Ben`> shachaf: thanks
16:00:44 <Cale> Ben`: In general, mapM f xs will build an action that will apply f to each element of xs to get an action, and run those actions in a sequence, collecting a list of results. mapM_ is a variant which throws away the results of each iteration.
16:01:01 <Cale> Ben`: For convenience, there is also forM/forM_ with the parameters flipped
16:01:07 <sorear> Ben`: You can think of it as haskell's foreach loop.
16:01:23 <Ben`> ah, I see :)
16:01:25 * shachaf remembers first seeing mapM_.
16:01:44 <Cale> You'll often see something like:
16:01:47 <shachaf> I thought "there are so many variations of map that they ran out of letters and had to resort to _?".
16:01:53 <Cale> forM_ xs $ \x ->
16:01:55 <Cale>   do ...
16:02:33 <hpaste>  wli pasted "faster Fibonacci?" at http://hpaste.org/1945
16:02:40 <LoganCapaldo> I thought _ was supposed to look like a dropoff the the result was falling off
16:03:26 <shachaf> LoganCapaldo: I think of it as the same _ in (\_ -> ...).
16:05:19 <Cale> In general, I use mapM or forM at first and treat mapM_ and forM_ as optimisations.
16:05:36 <Cale> (unless the types make it more convenient)
16:06:33 <shachaf> Cale: You'd use mapM in Ben`'s case first? (mapM print [1..100])
16:06:39 <MisterN> mapM print [1..100] - why'd I want a list of 100 ()-tuples?
16:06:56 <shachaf> Cale: mapM_ is the first thing I think of, since I don't use the result.
16:07:04 <Cale> You wouldn't. But it's easier to type mapM
16:07:10 <shachaf> Cale: Not just as an optimization.
16:07:14 <Cale> and you're probably throwing away the tuples anyway
16:07:34 <MisterN> shouldn't mapM_ be called foreachM or so?
16:07:42 <Cale> MisterN: there's forM
16:07:54 <shachaf> mapM_ = sequence_ . map
16:07:54 <MisterN> Cale: it does the same thing as mapM_?
16:07:56 <Cale> Which is just mapM with the params flipped
16:08:00 <shachaf> @src mapM_
16:08:01 <lambdabot> mapM_ f as = sequence_ (map f as)
16:08:18 <MisterN> @src forM_
16:08:18 <lambdabot> forM_ = flip mapM_
16:08:23 <MisterN> @src forM
16:08:23 <lambdabot> forM = flip mapM
16:08:23 <shachaf> That's what I meant.
16:08:27 <MisterN> heh
16:09:07 <MisterN> "@src" is a nice command
16:09:22 <shachaf> @. pl src mapM_
16:09:22 <lambdabot> (line 1, column 1):
16:09:22 <lambdabot> unexpected end of input
16:09:22 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
16:09:35 <shachaf> @pl mapM_ f as = sequence_ (map f as)
16:09:35 <lambdabot> mapM_ = (sequence_ .) . map
16:10:26 <MisterN> what's @pl?
16:10:51 <ddarius> @help pl
16:10:51 <lambdabot> pointless <expr>. Play with pointfree code.
16:11:05 <sorear> It's a compiler.
16:11:24 <sorear> it converts a large subset of Haskell into combinators.
16:12:00 <MisterN> haskell could be renamed to omg-language. because that's what i think all the time.
16:12:05 <sorear> via the standard Schoenfinkel algorithm, followed by a rewrite system for optimization.
16:12:07 <ddarius> Like Turner's Miranda compiler, only without sensible names like S, K, B'
16:12:15 <shachaf> Is there a version of @pl that only uses const and ap?
16:12:30 <shachaf> For simple functions?
16:12:48 <sorear> shachaf: No, but it wouldn't be hard to hack in support for disabling the optimizer.
16:14:00 <wli> I use it to test equality kinda-sorta.
16:14:15 <wli> I sort of wish there were something explicitly for such.
16:14:44 <Saizan> equality of function definitions?
16:14:48 <wli> Yeah.
16:14:56 <wli> Obviously it's not entirely decidable.
16:15:17 <wli> But still, you get quite a bit of mileage out of normalizing things in various ways.
16:31:08 <wli> Well, I'll need backsubstitution shortly, followed by unraveling the pivoting.
16:31:23 <wli> I think that only column pivoting has any effect on the solutions.
16:31:45 <wli> s/backsubstitution/backward elimination/
16:41:21 <tessier_> How do macros in haskell compare to macros in lisp?
16:41:44 <wli> There aren't any macros in Haskell.
16:42:35 <sorear> For the most part you don't need them.  Laziness and HOAS can express any hygenic macro.
16:42:39 <Saizan> there's template haskell, but haskell has a more complex AST so it's not so pleasant to write a macro
16:42:44 <sorear> So scheme has nothing on Haskell.
16:43:13 <sorear> (Lisp macros are more general, but the flexibility is IIUC rarely used even by Lispers)
16:43:16 <wli> jfredett: HFA looks pretty interesting.
16:43:24 <jfredett> Thanks
16:43:50 <jfredett> I just finished DFA's
16:43:56 <MisterN> what's HOAS?
16:43:59 <jfredett> I'm just refactoring and adding some useful stuff
16:44:13 <shapr> higher order something?
16:44:17 <wli> jfredett: You might also want to try linear-bounded automata.
16:44:31 <jfredett> wli: my goal is to implement- well- everything, :)
16:44:37 <jfredett> I'll add LBA's to my list though
16:44:54 <Saizan> H?
16:45:12 <wli> jfredett: There are also the weird stack automata for indexed languages; they basically have a stack of stacks.
16:45:26 <shapr> sorear: What HOAS?
16:45:29 <jfredett> neat.
16:45:31 <shapr> Higher order abstract syntax?
16:45:38 <sorear> shapr: Yes.
16:45:51 <jfredett> wli I kinda got sidetracked with a Representation class I was trying to get working
16:46:00 <wli> jfredett: Also, note Moore machines and Mealy machines that produce output on entering states (Moore) and transitioning between states (Mealy).
16:46:03 <sorear> Basically, using lambdas to reflect binders.  Think mapM_
16:46:34 <jfredett> I had a class which was (supposed) to define a representation of one type as another and vice versa
16:46:37 <wli> jfredett: Without those about all you can do is halt in some state or other.
16:46:55 <jfredett> but I couldn't get the heirarchy to work
16:47:10 <shapr> sorear: I don't get it.
16:47:18 <wli> jfredett: There's also state machine composition, which is only meaningful for machines producing output.
16:47:34 <jfredett> wli: yah- I figure, once I get the main stuff done, I'll just recurse through Wikipedia and implement all the ones I can find
16:48:09 <sorear> shapr: You can encode (foreach name list body), where name is in scope in body, as (foreach list (lambda (name) body))
16:48:16 <wli> jfredett: Also DFA's can be minimized; I'm not sure about other things.
16:48:34 <jfredett> wli: thats gonna be one of the DFA functions
16:48:41 <jfredett> I'm mostly just organizing right now
16:48:45 <shapr> sorear: oh
16:49:01 <wli> jfredett: Got a source repo?
16:49:17 <jfredett> not yet
16:49:23 <tessier_> sorear: What is HOAS?
16:49:27 <jfredett> i only started today, :P
16:49:38 <wli> jfredett: Automata that produce output would be nice.
16:50:01 <jfredett> wli: well, next on my list is NFA's, I'm just kind of reworking through my Formal Languages book
16:50:15 <sorear> @google Higher order abstract syntax
16:50:17 <lambdabot> http://en.wikipedia.org/wiki/Higher-order_abstract_syntax
16:50:24 <jfredett> wli: my plan for evaluating NFA's is just to convert them to DFA's, and then run them that way, avoid backtracking and such.
16:50:25 <mrd> then you got PDAs to cover after
16:50:25 <tessier_> ah
16:50:44 <mrd> jfredett: conversion from NFA to DFA can be worst-case exponential
16:50:44 <sorear> tessier_: A very cool concept I learned about recently, which very naturally expresses the concept of using hof's to encode macros.
16:50:51 <jfredett> mrd: hmm
16:50:57 <jfredett> maybe I'll rethink that, then
16:50:58 <jfredett> :/
16:51:09 <mrd> it's possible to come up with a pretty decent algorithm avg-wise though
16:51:15 <mrd> which book are you working through?
16:51:16 <jfredett> I haven't read that far
16:51:23 <tessier_> sorear: How did you learn this concept?
16:51:26 <jfredett> let me see if i can find it
16:51:30 <mrd> Sipser?
16:51:34 <jfredett> it's by thompson, I think
16:51:36 <jfredett> something with a T
16:51:41 <jfredett> I don't have it handy
16:51:42 <dolio> tessier_: He's a boy-genius. :)
16:51:45 <sorear> tessier_: Buzz in the dependant typing community. :)
16:51:57 <wli> sorear: Which buzz is this?
16:51:58 <sorear> tessier_: Eventually I broke down and googled.
16:52:25 <mrd> jfredett: basically, you need a DFA state "possibly" for each member of the powerset of NFA states
16:52:26 <jfredett> Sudkamp
16:52:43 <mrd> jfredett: but a smart algorithm can potentially elide the vast majority
16:52:45 <jfredett> mrd: oh- well that makes sense, I knew it had something to do w/ subset reconstruction
16:52:55 <jfredett> I missed a good portion of my FL class last year
16:53:01 <jfredett> I got pneumonia
16:53:14 <jfredett> (can't reccomend pneumonia, its not fun)
16:53:45 <jfredett> this was the website for the class i took: http://web.cs.wpi.edu/~kal/courses/fcsf05/
16:53:48 <lambdabot> Title: foundations of computer science
16:54:31 <Saizan> mmh, NFA -> DFA should be pleasant to write in the Set monad
16:55:01 <mrd> heh
16:55:18 <mrd> you really really really do not want to generate the powerset of NFA states at any point
16:55:26 <mrd> that's what i did originally, and boy did it suck
16:55:29 <wli> I'm more curious as to how to do nondeterministic LBA's.
16:55:45 <mrd> i wrote a runNFA in the List monad for fun though. that was cool.
16:55:55 <tessier_> So it seems that macros and HOF's are two sides of the same coin?
16:56:12 <mrd> tessier_: no they just happen to coincide for some uses in different settings
16:56:15 <wli> I mean, naive algorithms are obvious, but the branching factor of the decision tree is a bit too large for that.
16:56:16 <Saizan> no, but you need to find the closure of the transition function from a set of states, and that's some combination of >>=
16:57:30 <mrd> tessier_: lisp macros are used in the places that haskell HoFs are used generally because Lisp is strict call-by-value
16:57:50 <mrd> however Lisp macros can also be used to generate compile-time constructs like datatype definitions
16:58:31 <mrd> (nevermind that in Lisp, compile-time can happen during run-time and vice versa)
16:59:17 <LoganCapaldo> there are lots of HoF you wouldn't want as macros as well
16:59:20 <LoganCapaldo> map comes to mind
16:59:42 <LoganCapaldo> well I guess you could do map as a macro
17:00:05 <mrd> it is a common style to provide both a HoF and a macro version of a control-structure-type construct in Lisp
17:00:19 <mrd> often the macro simply wraps lambdas and rewrites into the HoF
17:00:25 <pjd> speaking of HOAS, who's seen that HOAS-based metacircular Scheme interpreter?
17:01:15 <wli> LBA's have rules where the string length of the LHS is less than that of the RHS. The nondeterministic execution is essentially applying the rules at any point in the text, monotonically decreasing its length.
17:01:26 <RyanT5000> could someone give me advice as to where to start reading to write a language with the following constraints: (1) doesn't need to be human-readable (2) needs to be pure (no IO or monads or anything required) (3) can borrow a lot of semantics from haskell - need not have a well-defined standalone semantics
17:01:26 <pjd> truly nifty: http://scheme2006.cs.uchicago.edu/#aselfhostingevaluatorusinghoas
17:01:28 <lambdabot> Title: Scheme and Functional Programming Workshop 2006 - Report
17:01:53 <pjd> RyanT5000: monads are pure
17:01:53 <mrd> RyanT5000: lambda-calculus?
17:01:58 <mrd> and yes
17:02:03 <mrd> you could define monads within it
17:02:04 <sjanssen_> RyanT5000: why not just use Haskell?
17:02:11 <wli> So my question about LBA's is how to simulate the nondeterministic execution without maintaining vast amounts of state.
17:02:28 <ddarius> all (\n -> n > 2)
17:02:29 <RyanT5000> sjanssen_: i need better safety guarantees than hplugins gives me (i'm executing arbitrary remote code)
17:02:37 <mrd> wli: are NLBAs more powerful than LBAs?
17:02:51 <mrd> i've never considered non-deterministic versions
17:03:21 <sorear> what are LBAs?
17:03:27 <wli> mrd: I don't know, but converting from NLBA's to DLBA's involves the same exponential explosion as you get for DFA's, so the DLBA's may not be feasible to construct.
17:03:29 <RyanT5000> sjanssen_: so, the interpreter of this language will be a pure function in haskell (Program -> ByteString -> ByteString, or something like that)
17:03:29 <sorear> oh, linear bounded
17:03:38 <sjanssen_> RyanT5000: if you can control imports, hs-plugins can give you pretty strong guarantees, I'd say
17:03:38 <sjanssen_> RyanT5000: ie. the guarantees are just as strong as GHC's guarantees
17:04:19 <RyanT5000> sjanssen_: how big is the install footprint of hsplugins? i can't spare more than about 200 KB
17:04:31 <SamB> hahahaha
17:04:32 <sorear> RyanT5000: 20000KB or so :(
17:04:39 <sjanssen_> RyanT5000: it requires GHC ;)
17:04:41 <SamB> delete some anime or something
17:04:46 <MisterN> wow, i (think i) understand Monads, i (think i) understand STM. now the only problem is haskell's syntax :D
17:04:47 <RyanT5000> yeah; the total budget for this project is 10 MB, including the file cache
17:05:00 <RyanT5000> (it's a distributed file system for the one laptop per child project)
17:05:04 <sjanssen_> RyanT5000: embeded something or other?
17:05:05 <sjanssen_> ah
17:05:27 <sorear> augustss: How big is the install footprint for hbi?
17:05:53 <sorear> augustss: RyanT5000 wants to compile haskell with 200KB of disk
17:06:20 <augustss> ummmm, I can't say i remember.  a few megabytes, probably.
17:06:25 <SamB> RyanT5000: maybe you should use a smaller Haskell implementation?
17:06:35 <sjanssen_> RyanT5000: maybe you can use Hugs?
17:06:56 <sorear> RyanT5000: How about hugs/gofer?  It was designed to run on pre-EMS DOS, so 640KB ram and 1 floppy
17:07:14 <augustss> yes, that's probably the only option
17:07:25 <RyanT5000> is it extremely safe?
17:07:33 <RyanT5000> i *really* don't want to use chroot jails
17:07:37 <RyanT5000> or anything like that
17:08:02 <augustss> if you turn off I/O it's safe :)
17:08:08 <sorear> RyanT5000: It's written in C.  Need I say more :)
17:08:14 <mrd> its what lambdabot uses right
17:08:26 <sorear> mrd: lambdabot uses GHC -O2 and dlopen
17:08:31 <MisterN> lambdabot uses ghc -O2, they say
17:08:31 <shachaf> mrd: Lambdabot uses GHC.
17:08:41 <mrd> oh hugs
17:08:43 <MisterN> sorear: dlopen?
17:08:56 <sjanssen_> RyanT5000: it should be safe as long as you control imports carefully
17:08:57 <mrd> i thought lambdabot used hs plugins to run >
17:09:02 <sorear> MisterN: dynamic linker
17:09:11 <MisterN> sorear: i know dlopen
17:09:26 <shachaf> mrd: No, it uses RunPlugs, which is separate.
17:09:32 <wli> indexed language <-> nested stack automaton
17:09:38 <MisterN> sorear: but where does lambdabot use it?
17:09:43 <sorear> MisterN: it compiles your code to a .o file and dynamically links it.
17:09:47 <sjanssen_> RyanT5000: you've got to look out for unsafePerformIO, Data.Array.Base.unsafeWrite, all of Foreign.*, perhaps a few others
17:09:49 <sorear> > 2 + 2 -- here, MisterN
17:09:50 <lambdabot>  4
17:10:00 <sorear> notice that it takes nearly a second
17:10:10 <sorear> that's because it has to start GHC :)
17:10:23 <MisterN> sorear: i see. isn't that a vulnerability?
17:10:31 <sorear> MisterN: why?
17:10:32 <shachaf> MisterN: How?
17:10:58 <MisterN> well, like wasting huge amounts of memory
17:10:59 <sorear> sjanssen_: All array stuff.  http://hackage.haskell.org/trac/ghc/ticket/229
17:11:01 <lambdabot> Title: #229 (Integer overflow in array allocation) - GHC - Trac
17:11:08 <sjanssen_> sorear: yeah, that too
17:11:08 <RyanT5000> sjanssen_: that's kind of why i didn't want to bother
17:11:11 <SamB> MisterN: there are limits
17:11:15 <RyanT5000> sjanssen_: i'd much rather have a crappy language than one that's insecure
17:11:31 <MisterN> SamB: and if these limits are reached, lambdabot crashes and restarts?
17:11:38 <wli> To get the worst case for a gsfib | even n = ... gsfib (n `div` 2) | odd n = ... gsfib (n - 1) needs (\n -> 2*n+1) iterated
17:11:39 <RyanT5000> (crappy from a usability and efficiency standpoint)
17:11:45 <SamB> MisterN: no.
17:11:50 <sorear> MisterN: eh?
17:11:59 <MisterN> a dlopen is not isolated
17:12:03 <SamB> actually does lambdabot even use hs-plugins for that?
17:12:05 <sjanssen_> MisterN: lambdabot sets memory and CPU limits too
17:12:07 <MisterN> so the whole bot must die
17:12:10 <sorear> MisterN: Yes it is.  man 2 fork
17:12:12 <wli> r_{n+1} = 2*r_n+1 then r_n = 2^n-1
17:12:27 <MisterN> sorear: oh, so it does fork+dlopen.
17:12:51 <sorear> MisterN: fork+exec("runplugs"), where runplugs evaluates 1 expression.
17:13:15 <MisterN> that's safe of course.
17:13:22 <SamB> so what does lambdabot actually use hs-plugins for nowadays anyway?
17:13:32 <MarcWeber> Is there already a if .. then function somewhere ? I want to do readFile ... >>= ifelse a b . read
17:13:33 <int-e> runplugs :)
17:13:47 <SamB> int-e: where?
17:13:48 <SamB> how?
17:13:48 <LoganCapaldo> @type when
17:13:50 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
17:14:44 <dmwit> wli: Unless r_1 /= 1... ;-)
17:15:29 <wli> dmwit: Well, I don't care too much I'm just trying to trigger worst cases for certain recursions.
17:15:33 <sorear> SamB: runPLUGS uses hs-PLUGinS
17:15:40 <int-e> SamB: runplugs uses System.Eval.Haskell
17:16:58 <int-e> which basically writes a .hs file, compiles it and then loads it with hs-plugins to run.
17:17:01 <wli> Hopefully that isn't wrapped in an IO monad.
17:17:08 <wli> Ugh.
17:18:23 <hpaste>  wli annotated "faster Fibonacci?" with "more Fibonacci results" at http://hpaste.org/1945#a1
17:18:49 <qwr> @hoogle Bool -> m a -> m a -> m a
17:18:50 <lambdabot> No matches, try a more general search
17:18:55 <wli> int-e: One should be able to do all that by just calling ghc internals as libs.
17:19:15 <wli> int-e: No need for file IO garbage.
17:20:37 <sorear> qwr: if-then-else
17:20:43 <wli> BTW when using System.Console.Readline.readline, ^C behaves weirdly.
17:20:44 <sorear> qwr: it's not a function :(
17:21:00 <sorear> wli: How weirdly?
17:21:06 <LoganCapaldo> @djinn Bool -> a -> a -> a
17:21:06 <lambdabot> f a b c =
17:21:07 <lambdabot>     case a of
17:21:07 <lambdabot>     False -> c
17:21:07 <lambdabot>     True -> b
17:21:14 <wli> sorear: It doesn't register until a newline is entered.
17:21:15 * LoganCapaldo will never get tired of that
17:21:19 * qwr has actually sometimes wished for a cond in libs
17:21:38 <wli> sorear: So it'll exit with "foo: interrupted" but not until a newline is entered
17:21:55 <sorear> wli: with readline, ^C is usually ignored, period
17:22:01 <qwr> :t \a b c x -> if a x then b x else c x
17:22:03 <lambdabot> forall t t1. (t -> Bool) -> (t -> t1) -> (t -> t1) -> t -> t1
17:22:04 <MarcWeber> LoganCapaldo: Exactly. That's what I would implement ;)
17:22:25 <SamB> wli: probably that hasn't been noticed because, um, usually it does nothing anyway ;-)
17:22:29 <wli> sorear: Okay, so (a) can this be dealt with somehow for an immediate response? (b) if not what alternatives to readline are there?
17:22:42 * SamB wonders what zsh uses
17:23:04 <wli> SamB: Handwritten incremental parser of vast size.
17:23:30 <dolio> LoganCapaldo: That's nothing.
17:23:38 <SamB> readline isn't a parser is it?
17:23:40 <dolio> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
17:23:40 <lambdabot> f a b = a (\ c _ -> b c) b
17:23:50 <dolio> @src Cont callCC
17:23:51 <lambdabot> callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
17:24:08 <wli> SamB: The terminal handling is intimately tied into parsing.
17:24:35 <LoganCapaldo> dolio, I know, callCC is cooler :)
17:24:37 <wli> SamB: So, for instance, incomplete syntactic constructs will trigger dropping into multiline editing.
17:24:43 <dolio> :)
17:24:45 <jfredett> well thats odd...
17:24:58 <SamB> hmm.
17:25:00 <LoganCapaldo> I'll still never get tired of if though :)
17:25:06 <jfredett> a minute ago, i was instancing the class just fine
17:25:14 <jfredett> now I've got a silly error
17:25:15 <jfredett> hmm
17:25:19 <SamB> that's true, but I don't see why that actually requires incremental parsing...
17:25:23 <wli> SamB: Plus tab completion is extremely context-dependent.
17:25:28 <SamB> now that I'll grant
17:25:50 <wli> SamB: Plus there are stateful editing modes (vi-based with configurability).
17:26:07 <wli> SamB: Which furthermore allow multiline editing.
17:27:11 <wli> SamB: The main things are basically the context-dependent tab completions and the context-dependent multiline editing affairs. There is probably more.
17:27:37 <hpaste>  Mxwbipb annotated "My hands are shaking and my feet are numb," with "generic tramadol" at http://hpaste.org/1741#a1
17:28:10 <MisterN> yay i must get generic tramadol whatever that is
17:28:26 <wli> SamB: For instance, magic '=' tries to get tab completions from commands, but in various other contexts, user-defined completions exist, including completions for shell language constructs.
17:29:00 <SamB> how does it try to get tab completions from commands?
17:29:07 <qwr> > let cond pred a b = do { p <- pred; if p then a else b } in let abs = cond (< 0) (0 -) id in abs (-4)
17:29:09 <lambdabot>  4
17:29:45 <MisterN> @pl cond pred a b = do { p <- pred; if p then a else b }
17:29:45 <lambdabot> (line 1, column 20):
17:29:45 <lambdabot> unexpected "{"
17:29:45 <lambdabot> expecting variable, "(", operator or end of input
17:29:56 <wli> SamB: It'll notice that you've typed in some command name and then it will apply the user-defined tab completion rule to its arguments, with understanding that ; or other command separators end the context where that tab completion ruleset should apply.
17:30:09 <qwr> @pl \pred a b = do { p <- pred; if p then a else b }
17:30:09 <lambdabot> (line 1, column 11):
17:30:09 <lambdabot> unexpected "="
17:30:09 <lambdabot> expecting pattern or "->"
17:30:18 <qwr> @pl \pred a b -> do { p <- pred; if p then a else b }
17:30:19 <lambdabot> (line 1, column 17):
17:30:19 <lambdabot> unexpected "{"
17:30:19 <lambdabot> expecting variable, "(", operator or end of input
17:30:28 <wli> SamB: I'd love to hear fromparsing experts on how to carry out such a thing.
17:30:31 <qwr> @pl \pred a b -> (do { p <- pred; if p then a else b })
17:30:32 <lambdabot> (line 1, column 18):
17:30:32 <lambdabot> unexpected "{"
17:30:32 <lambdabot> expecting variable, "(", operator or ")"
17:30:33 <MisterN> pl doesn't support do?
17:30:35 <wli> qwr: Please stop.
17:30:38 <SamB> wli: oh, so it doesn't actually ask the program in question for completion info?
17:30:46 <wli> qwr: Or privately message the bot
17:30:57 <SamB> qwr: pl doesn't support monads
17:31:01 <shachaf> @. pl undo \pred a b -> do { p <- pred; if p then a else b }
17:31:02 <lambdabot> (. (flip . flip if')) . (.) . (>>=)
17:31:14 <SamB> er. do
17:31:16 <wli> SamB: Correct. It's defined in zsh configuration commands.
17:31:18 <SamB> sorry.
17:31:35 <shachaf> @pl \f m -> m >>= return . f -- it supports monads.
17:31:35 <lambdabot> fmap
17:31:54 <SamB> s/monads/do blocks/
17:32:32 <shachaf> That's what undo is for. :-)
17:32:36 <MisterN> @. pl cond pred a b = do { p <- pred; if p then a else b }
17:32:37 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "cond"
17:32:58 <augustss> yo
17:33:17 <wli> SamB: This is a much more interesting "parsing problem" than ones solved by parsec et al.
17:33:53 <Korollary> augustss: wassup
17:34:11 <augustss> nuthin
17:34:13 <wli> SamB: It makes essential use of the predictions in predictive parsing.
17:34:31 <Korollary> augustss: word.
17:34:31 <wli> SamB: I've never actually seen anything comparable to zsh's parsing and command-line editing features.
17:34:52 <wli> SamB: And I really wish there were things like parsec to construct such.
17:35:33 <augustss> word?  lines!
17:35:47 <wli> SamB: But the state of things as they now are is horrendous. Basically the only terminal-handling library in existence is ncurses and that sucks horribly in numerous ways, and the only canned support is readline, which is of similar quality.
17:35:58 <wli> augustss: Ever seen zsh's command-line editing features?
17:35:59 <qwr> wli: actually, it tells "03:34 -!- lamdabot: No such nick/channel" when privately asked for @pl
17:36:13 <qwr> (used to work though in past)
17:36:19 <shachaf> qwr: With the b. :-)
17:36:37 <wli> qwr: You typo'd the nick.
17:36:41 <augustss> hmmm, i tried zsh for a short while.  can't say i remember the editing features
17:36:47 <shachaf> qwr: Don't let Unicode confuse you!
17:36:56 <qwr> damn, i'm idiot :(
17:37:24 <wli> augustss: They're extremely sophisticated and circumvent most of the stock libraries for those sorts of things because they are too limited.
17:37:30 <sjanssen> wli: combinators for command completion sounds like a really fun project
17:37:49 <augustss> i just use emacs and M-/ and get consistent misspellings
17:38:17 <wli> sjanssen: It's a bit more than command completion; did you see the bit where the completions were context-sensitive, as well as dropping into multiline editing in a context-sensitive fashion?
17:38:37 <shachaf> augustss: M-/ is like ^p in vi?
17:38:44 <shachaf> s/vi/vim/, maybe.
17:38:55 <sjanssen> wli: yeah, I know about context-sensitive completion (I'm in love with zsh's darcs support, for example)
17:39:32 <wli> sjanssen: An example of context-sensitive multiline editing looks like:
17:39:32 <hpaste>  jfredett pasted "Weird type error, complaining about synonyms, but there aren't any." at http://hpaste.org/1948
17:39:33 <wli> $ for f in Arb* Fix* Un*
17:39:33 <wli> for> do
17:39:33 <wli> for> wc -l $f
17:39:33 <wli> for> done
17:39:34 <augustss> I don't know about ^p.  vi didn't have that
17:39:58 <wli> sjanssen: Also, when you move up the history to edit it, it reappears in multiline form as follows:
17:40:07 <wli> $ for f in Arb* Fix* Un*
17:40:07 <wli> do
17:40:07 <wli> wc -l $f
17:40:07 <wli> done
17:40:22 <augustss> M-/ searches for something with the same prefix as is before the cursor
17:40:33 <augustss> it's indispensable
17:40:35 <sjanssen> jfredett: you're using MPTCs, you need to tell GHC to allow them
17:40:36 <shachaf> augustss: Yes, same thing.
17:40:42 <jfredett> MPTC's?
17:40:51 <jfredett> oh! multi parameter
17:40:53 <jfredett> okay-
17:40:56 <wli> sjanssen: If you nest constructs things will show up interestingly as well
17:41:01 <jfredett> what is that, -fglasgow-exts?
17:41:10 <sjanssen> jfredett: yeah, that'll work
17:41:18 <sjanssen> there are finer-grained settings too
17:41:23 <LoganCapaldo> is there a {-# LANGUAGE for MPTCs?
17:41:42 <jfredett> sjanssen: I'll probably need other stuff out of glasgow-exts anyway
17:41:44 <sorear> MultiParamTypeClasses
17:42:27 <blackdog> augustss: it's one of those things you don't realise you need till you have it, then can't possibly live without :)
17:43:00 <shachaf> blackdog: Definitely.
17:44:37 <wli> sjanssen: More complex example:
17:44:38 <wli> $ for f in Arb* Fix* Un*
17:44:38 <wli> for> do
17:44:38 <wli> for> if [[ $(( `wc -l $f | cut -f1 -d' '` % 2 )) -eq 0 ]]
17:44:38 <wli> for if> then
17:44:38 <wli> for then> echo $f
17:44:39 <wli> for then> fi
17:44:41 <wli> for> done
17:45:18 <sjanssen> wli: okay, implement that in Haskell :)
17:45:44 <wli> sjanssen: Well, right now I'm stuck on not being able to find a specification for the binary terminfo format.
17:46:26 <sjanssen> wli: perhaps you can ask sorear if vty can help you?
17:46:43 <sorear> It can't.
17:46:49 <sorear> vty only does ANSI.
17:46:53 <wli> sjanssen: I'm aware of vty but it needs to be extended with support for more terminal types.
17:46:57 <sorear> you could use hscurses...
17:47:14 <sorear> really, the only thing vty has going for it is a nice API.
17:47:14 <wli> sjanssen: Which is what terminfo file format documentation searches are about.
17:47:37 <sorear> I keep meaning to turn vty into a wrapper over curses.
17:47:41 <wli> sorear: zsh circumvents (n)curses and does the terminal handling by hand.
17:47:51 <mauke> wli: I may have something
17:47:54 <sorear> wli: Really?  Not even tputs?
17:47:56 <wli> sorear: Please don't. (n)curses has horrible built-in limitations.
17:48:01 <mauke> wli: I have a simple terminfo interpreter written in perl
17:48:13 <sorear> wli: oh?
17:48:34 <sorear> wli: ncurses looks like a hugs amount of work to clone... magic cookies, etc...
17:48:35 <sjanssen> wli: will your library be tied to a terminal?
17:48:39 <wli> sorear: tputs might be okay.
17:48:44 * pjd thinks the world needs a sane terminal protocol
17:48:50 <sjanssen> wli: I might like to use something like this in a little X11 app launcher
17:48:53 <wli> sjanssen: A specific terminal type? No.
17:48:55 <sorear> wli: also, the algorithms.  vty doesn't use insert/delete codes, ever.
17:49:08 <augustss> the world already has too many sane terminal protocols
17:49:10 <sorear> wli: so when you scroll, vty redraws the entire screen.
17:49:23 <wli> sorear: That's not so difficult to remedy.
17:49:39 <sorear> wli: Why?  Simply that I couldn't invent a suitable algorithm and couldn't understand the ncurses HACKING.
17:49:49 <wli> sorear: What is difficult to remedy is ncurses' global state rendering it impossible to manipulate multiple terminals simultaneously.
17:50:04 <pjd> augustss: which ones are sane? :)
17:50:26 <SamB> wli: why is that difficult to remedy?
17:50:34 <SamB> just don't use curses
17:50:39 <sorear> wli: Thanks.  That would have been impossible to reconcile with vty's global-state-free API. :)
17:51:01 <wli> SamB: It's difficult to remedy in that the ncurses codebase is very difficult to work with.
17:51:17 <SamB> wli: well that's what rm is for ;-)
17:51:28 <shachaf> SamB: Read up.
17:51:56 <MisterN> wli: you could just use termios and do everything else yourself?
17:51:59 <SamB> hmm, and I thought curses supported multiple terminals anyway...
17:52:09 <shachaf> 20:46 < sorear> I keep meaning to turn vty into a wrapper over curses. 20:46 < wli> sorear: Please don't. (n)curses has horrible built-in limitations.
17:52:22 <sorear> SamB: it does, but you need to switch explicitly
17:52:32 <wli> Anyway, what the investigation that led to my observations on this front was about was actually some app or other that talked to multiple terminals.
17:52:42 <SamB> sorear: you can't just use different WINDOWs?
17:52:52 <wli> sorear: And there is zero concurrency.
17:53:16 <wli> sorear: You're stuck wrapping any and all calls to ncurses with a global lock.
17:54:58 <wli> sorear: Anyway I don't think the scrolling limitation is such a problem.
17:55:31 <sorear> wli: As in, it's fixable?  or it's irrelevant?
17:55:33 <wli> sorear: It's clean Haskell code so it can be dealt with vs. shag-nasty dirty C crap code like ncurses.
17:55:53 <sorear> I wouldn't be so sure about the clean part.
17:56:08 <SamB> sorear: it's in Haskell!
17:56:12 <wli> sorear: The same applies to terminfo and multiple terminal types.
17:56:29 <SamB> sorear: if it's not clean, you can enter the next IOHCC
17:56:54 <wli> sorear: The only messy parts I see are the static tables of escape codes.
17:56:57 <sorear> wli: Two years ago, I was writing a roguelike.  After struggling for weeks to get ncurses to stop flickering, I gave up and rewrote a minimal ncurses in ~200 lines of C.  Worked beautiffully.
17:57:54 <sorear> wli: One year ago, I decided to learn Haskell, and as my first big project wrote a Life IDE-like program.  I needed a terminal interface library, and (not finding hscurses for whatever reason) the obvious thing to do was port vty.
17:58:12 <sorear> newbie code.
17:58:35 <wli> Whoever mentioned termios, the termios affairs are actually inadequate for full-bore screen manipulation.
17:58:36 <SamB> sorear: so write it again?
17:58:42 <mauke> so, uh ... anyone looking for a terminfo parser?
17:58:51 <wli> mauke: Yeah.
17:58:55 <mauke> http://mauke.ath.cx/tmp/Term-Info/lib/Term/Info.pm
17:59:18 <mauke> you probably want to start near the bottom
17:59:44 <wli> Oh man, perl brings back bad memories.
17:59:50 <wli> Perl is truly a write-only language.
18:00:05 <mauke> I can read it :-)
18:00:39 <wli> mauke: Translating this into Haskell will be a long, slow process.
18:01:05 <wli> mauke: How complete is it?
18:01:06 <mauke> yep
18:01:18 <mauke> it should support all standard capabilities
18:01:20 <SamB> wli: have you ever tried to read unlambda?
18:01:43 <sfultong> sorear: hmm, I'm writing a roguelike right now to better my haskell
18:01:49 <wli> SamB: I don't usually go in for things that are completely obfuscated.
18:02:10 <wli> mauke: I'm not sure what that means.
18:02:11 <sorear> wli: If you decide to rewrite vty from scratch, I think you'll save yourself a lot of grief by adopting vty's resize model.  On the input side, SIGWINCH is just another key.  In the application, SIGWINCH is treated as ^L.  On the output side, vty notices that the application's image has changed size and redraws from scratch.
18:02:11 <SamB> unlambda was *designed* to be write-only
18:02:17 <SamB> I believe it was well-designed
18:02:33 <sorear> wli: That way, you effectively eliminate all coupling and races.
18:02:48 <wli> SamB: AIUI it's SKI combinators or some such.
18:02:55 * sorear does not like races.
18:03:05 <mauke> wli: there's a more or less standard terminfo file format, with platform specific extensions at the end
18:03:05 <sorear> wli: Worse, SKICD :)
18:03:08 <SamB> wli: with call/cc and impure IO and backticks for application
18:03:11 <wli> mauke: I think I'll be better off working from a proper spec.
18:03:16 <SamB> sorear: what's D?
18:03:34 <wli> Borrowed from SECD I think.
18:03:34 <sorear> SamB: Unlambda is lazy.  D is the only non-strict primitive
18:03:49 <mauke> anyway, sub from_str is the main "parser"
18:03:51 <SamB> oh, yes, D
18:04:00 <dons> ?users
18:04:01 <lambdabot> Maximum users seen in #haskell: 350, currently: 329 (94.0%), active: 21 (6.4%)
18:04:05 <sorear> it's actually pretty trivial to compile unlambda, once you recognize that fact.
18:04:19 <sorear> the creator thinks it's impossible.  I've done it.
18:04:22 <SamB> sorear: if you understand it's semantics properly
18:04:26 <SamB> I suppose
18:04:36 <SamB> perhaps the creator does not
18:05:10 <sorear> SamB: re semantics, that's why one of my current projects is to prove it correct. :)
18:05:45 <wli> mauke: I still think I'll be better off working from a proper spec... I'll be consulting perl books for weeks for this if I even get around to it. Where did you find docs?
18:05:55 <mauke> good question
18:06:03 <sorear> man 5 terminfo
18:06:07 <sorear> man tic
18:06:09 <sorear> man tac
18:06:15 <sorear> man toe (IIRC)
18:06:26 <wli> sorear: Pretty useless for writing a codec IIRC.
18:07:14 <sorear> man 5 term
18:07:32 <sorear> term (5)             - format of compiled term file.
18:08:05 <wli> That's not a terribly great description, but maybe that's all there is to go on.
18:08:18 <mauke> ah, yes. I think I used that
18:08:38 <sorear> man++
18:09:22 <dons> cdsmith++ nice blog article :)
18:09:34 <dons> i love these quick responses
18:09:36 <pjd> url?
18:09:48 <Nafai> Yes, I agree with dons
18:09:51 <Nafai> cdsmith++ :)
18:10:23 <pjd> OT: looks like hpaste is beginning to need a blacklist, and spam reporting
18:10:29 <wli> The description in the manpage is not very complete.
18:10:41 <mauke> what's missing?
18:11:40 <sorear> pjd: It already has a blacklist, which has cut down on spam dramatically.  Do you think it needs a new clause?
18:12:30 * sorear deletes #1927
18:12:35 <pjd> "tramadol", apparently: http://hpaste.org/1741#a1
18:14:14 <wli> So the first 12 bytes are the header.
18:14:31 <mauke> yes, 6 words
18:20:45 <mauke> hmm. I have a declarative/pure version of (a very limited subset of) IO. what's a good way to do IORefs?
18:21:38 <ddarius> mauke: What?
18:22:05 <mauke> *Main> unZ (zgetc >>= zputc) "butter"
18:22:05 <mauke> (Right (),"utter","b")
18:22:48 <ddarius> You could use STRefs depending on what you wanted to do.
18:22:53 <mauke> unZ takes a ZIO action and a string for stdin
18:23:09 <mauke> it returns the result of running the "IO" as well as the resulting stdin/stdout streams
18:23:22 <wli> Is there a showHex to go with readHex?
18:23:30 <ddarius> I believe so.
18:23:34 <ddarius> :t Numeric.showHex
18:23:37 <lambdabot> forall a. (Integral a) => a -> String -> String
18:23:53 <mauke> > showHex 255 ""
18:23:54 <lambdabot>  "ff"
18:27:45 <sfultong> > showHex 255 "_"
18:27:48 <lambdabot>  "ff_"
18:28:59 <sorear> cdsmith: new comment. :)
18:30:01 <cdsmith> sorear:  I saw, thanks,
18:30:57 <wli> do { h <- openBinaryFile "/usr/share/terminfo/a/adm3" ReadMode ; s <- hGetContents h ; print $ length s ; let { hdrBytes = take 12 s ; hdrWords = map (\xs -> ("0x"++) . flip showHex "" . sum $ zipWith (*) [256^k | k <- [0..]] (map (ord . snd) xs)) $ groupBy (\(x,_) (y,_) -> x == y) [(n `div` 2, b) | (n, b) <- zip [0..] hdrBytes] } in mapM_ putStrLn hdrWords ; hClose h }
18:32:05 <mauke> omgwtf
18:32:43 <sorear> is that perl? :P
18:32:46 <wli> mauke: Was that for me?
18:33:05 <mauke> wli: yeah. and you're complaining about perl?
18:33:29 <wli> mauke: This was done at the ghci prompt. I format things for readability in source.
18:33:58 <cdsmith> Yeah.  That wouldn't be so bad with some whitespace.
18:36:06 <cdsmith> sorear: what's with the "ghc is an interpreter" comment.  It sounds like you mean something other than GHCi.
18:37:06 <sorear> cdsmith: Yes, I mean GHC itself.  It takes a source program as input, and generates a specialized interpreter with specialized code fragments for each lambda in the Core text.
18:37:54 <dons> it generates a specialised, compiled graph reduction machine
18:38:09 <dons> so well, ghc isn't an interpreter
18:38:10 <cdsmith> Hmm.  I think you're treading on pushing the definition so far that it doesn't make sense to call it an interpreter any more
18:38:13 <dons> its a generator.
18:38:32 <dons> ghc doesn't have an `eval` loop :)
18:38:46 <blackdog> i think if the compilation process is fast enough to simulate a REPL you can call it an interpreter...
18:38:58 <mrd> @hoogle runStmt
18:38:59 <lambdabot> No matches found
18:39:03 <blackdog> it's only when you're doing whole program analysis that takes minutes at a time that you're reeally stretching it
18:39:12 <mrd> blackdog: that's what sbcl does, or did at one point.
18:39:49 <jfredett> yay, I found my abstract algebra book from group theory
18:40:04 <jfredett> which means I can learn field theory on my own, :)
18:40:05 <sorear> Every program compiled by GHC does have a eval function, but it's inlined everywhere it's used.
18:40:20 <cdsmith> sorear: so how do you know it exists?
18:40:27 <sorear> Other compilers like HBC have a more literal eval function, it's called UNWIND.
18:40:43 <ddarius> cdsmith: Incidentally, Haskell has beaten Perl at golfing a number of times (amazingly simultaneously in both clarity and code size).
18:41:41 <cdsmith> ddarius: I'm trying to find context for that, but failing.  Sorry?
18:42:19 <ddarius> cdsmith: #30
18:43:25 <cdsmith> Uhh.  Hmm.  That doesn't help. :)
18:43:40 <cdsmith> Oh!  In the list on my blog?
18:44:16 <cdsmith> ddarius: Got it.  Sorry for the confusion.
18:44:48 <dmwit> Is it possible to make a *link* (not a submit button) in WASH?
18:45:35 <stepcut> dmwit: last I checked, you can make a link, but there is no way to pass the state along via the link
18:45:54 <stepcut> dmwit: so, it is not very useful
18:46:09 <dmwit> How do I make a link?
18:46:21 <dmwit> (I figure I can use client-side state in cookies for the state bit.)
18:46:36 <dmwit> I tried makeRef, but the link it created didn't really go to anything.
18:48:56 <stepcut> dmwit: hlink :: Monad m => URL -> HTMLCons x y m () ?
18:49:41 <stepcut> dmwit: there is also makeA -- I am not really sure what you are planning to do with your link, so...
18:49:46 <dmwit> Sure, but how do I put something behind the URL?
18:49:55 <dmwit> I want the link to go to another part of the WASH program.
18:50:06 <dmwit> Say, have a welcome page that's showed to everybody, with a link to a sign-in page.
18:51:46 <stepcut> dmwit: i think you have to put some stuff in your url like, http://www.mysite.com/?goto=signin, and then write a handler at the top-level that looks at the url and calls the correct function
18:51:48 <lambdabot> Title: Website Hosting - Mysite.com
18:52:11 <kpreid> stepcut: may I recommend example.com?
18:52:40 <dmwit> kpreid: heh, neat
18:53:05 <stepcut> kpreid: yes, but I will probably forget again ;) I tend to remember in formal documents, but not in information conversation
18:54:28 <stepcut> dmwit: in other words, I believe you have to all the work -- wash does not do anything fancy to help you
18:54:59 <stepcut> dmwit: hrm, looks I like wrote something, hold on
18:55:06 <dmwit> stepcut: Okay, thanks.  Looking at the docs, I see that runWithHook may be what I need.
18:55:35 <stepcut> dmwit: yes
18:55:49 <sioraiocht> hellooooo
18:55:53 <sioraiocht> are there any good hashing libraries for haskell?
18:56:40 <sorear> Define hashing.
18:56:55 <sorear> We have both Data.HashTable and Codec.IForget.SHA1
18:57:15 <sioraiocht> hrm, I could do with SHA1...
18:58:10 <sorear> I recommend runInteractiveProcess "sha1sum", it's extremely well tested and faster than anything you can currently write in Haskell.
18:59:57 <LoganCapaldo> @type runInteractiveProcess
18:59:59 <lambdabot> Not in scope: `runInteractiveProcess'
19:00:05 <LoganCapaldo> drat
19:00:14 <LoganCapaldo> @hoogle runInteractiveProcess
19:00:14 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
19:00:23 <dcoutts> sioraiocht: or if you need pure haskell sha1 then check out the crypto package or the sha1 code in darcs
19:00:32 <sioraiocht> no, i don't, at all
19:00:37 <sioraiocht> anything fast is fine
19:00:40 <sioraiocht> even MD5 would do fine
19:03:05 <sioraiocht> how fast is Data.HashTable?
19:03:41 <Olathe> |---| <- that fast.
19:04:34 <SamB> Olathe: that's units of characters, not speed!
19:04:42 <Olathe> Oh.
19:07:07 <olsner> SamB: just divide by your baud rate :P
19:07:26 <Olathe> Heheh
19:08:01 <sioraiocht> lol
19:08:03 <wli> Reed-Solomon code would be handy.
19:08:07 <sioraiocht> you know what I mean
19:08:09 <SamB_XP_> olsner: baud rate has long since parted ways with bits/second
19:08:17 <sioraiocht> is it painfully slow for large data?
19:08:49 <SamB_XP_> sioraiocht: we mostly only know that the API is painfully tied to IO (or ST?)
19:09:41 <olsner> I guess it depends on where you measure the bauds... IIUC, baud = symbols/second, which could, for example, mean bytes of IRC data per second
19:09:45 <SamB_XP_> (anyway, it's a non-purely-functional datastructure for sure)
19:09:57 <sioraiocht> well, given that it's mutable i would think so..
19:10:07 <SamB_XP_> olsner: a long time ago, baud rate and bits/second were synonymous
19:10:07 <hpaste>  _dml pasted "instance syntax" at http://hpaste.org/1950
19:10:41 <sorear> sioraiocht: According to dons, Data.HashTable has a very slow implementation and you're better off using Map for performance.
19:10:41 <SamB_XP_> but then I believe the bitrate exceeded the baudrate as the modulations become more sophisticated
19:10:42 <_dml> newbie question: why is http://hpaste.org/1950#a0 rejected?
19:10:58 <sioraiocht> sorear: thanks
19:11:21 <sorear> _dml: Instance heads must be of the form T a b c ..  where T is a type constructor and a,b,c are 0 or more unique type variables.
19:11:46 <sioraiocht> hmm, we'll see how it does with 15k elements
19:11:53 <_dml> sorear: that's what ghc reports, i'm afraid i still don't understand
19:11:58 <dcoutts> sorear: I wonder if people have compared hashing with IntMap compared to ordinary Map
19:12:15 <_dml> what would a correct instance declaration look like?
19:12:18 <dcoutts> for things where one might be tempted to use HashMap
19:12:28 <sorear> _dml: it's an arbitrary restriction, some variant of which is required to keep the type checker from going into an infinite loop
19:12:51 <sorear> _dml: [a] would be a correct instance
19:13:29 <_dml> ah, so I can use [a] but not [Bool]... that's quite frustrating
19:13:40 <sorear> _dml: [Bool] works with GHC extensions (but be careful, having both [a] and [Bool] in scope will make things very hard to understand without a deep familiarity with type inference algorithms)
19:13:46 <sorear> -fglasgow-exts
19:14:00 <sorear> it's safe to have [Bool], [Char], [(Int,Int)] at the same time
19:14:09 <sorear> or hugs -98
19:14:41 <_dml> sorear: thanks! you've cleared things up immensely
19:15:40 <doctormach> Are JHC specific questions ok here?
19:16:19 <sorear> Absolutely.
19:17:18 <doctormach> I'm trying to get JHC to compile anything and I can't figure out how to specify the location of the libraries
19:17:31 <doctormach> It always says "Library base not found"
19:17:50 <dmwit> stepcut: Any idea why runWithHook's second parameter is a function on [String] and not String ?
19:18:04 <dmwit> runWithHook :: CGIOptions -> ([String] -> CGI ()) -> CGI () -> IO ()
19:20:25 <sorear> doctormach: make install works, or just copy the files into $(LIBRARYPATH) (see the makefile)
19:25:41 <doctormach> sorear: Thanks, I was specifying JHCPATH intead of JHCLIBRARYPATH
19:27:16 <wli> Crap, no wordsBy or similar combinator.
19:29:26 <blackdog> is jhc fast enough to worth using in development yet? last time i tried, it was too slow to use as anything but a batch compiler...
19:30:02 <SamB> blackdog: it's too slow to use at all ;-)
19:30:35 <dons> too unstable anyway
19:30:39 <dons> and slow :)
19:30:45 <blackdog> ah well :)
19:31:27 <sorear> blackdog: I gave jhc 6 hours to compile the standard prelude.  (it didn't make it)
19:32:00 <SamB> mine took ALL NIGHT, and more
19:32:29 <blackdog> i'm having flashbacks to the gentoo channel
19:32:34 <dons> blackdog: did you get your openbsd/haskell/xmonad framework all sorted out?
19:32:55 <blackdog> yep. i have a lovely little emulated openbsd box sitting next to me running xmonad
19:33:12 <blackdog> and i ended up doing my own switch left/switch right code, so i have a feeling of ownership now :)
19:33:18 <dons> ah nice.
19:33:25 <dons> you should put it back in as a contrib module!
19:33:38 <blackdog> it's a two-liner, and david roundy did one anyway, right?
19:33:38 <dons> just stick it in BlackdogSwitch.hs , and darcs  send
19:33:51 <dons> well, only if it isn't in the contrib module already
19:33:56 <dons> i thought it was, but maybe it wasn't
19:34:33 <dons> what do you think of xmonad? our first useful piece of haskell system software? :)
19:34:41 <blackdog> it's actually pretty sweet.
19:35:03 <blackdog> it does most of what i need
19:35:18 <dons> cool. what have you missed?
19:35:24 <blackdog> i'd still sort of like to be able to resize windows with the mouse.
19:35:35 <dons> other than ones in the floating layer?
19:35:36 <blackdog> i know it doesn't fit in with the automatic design pattern
19:35:38 <blackdog> yeah
19:35:51 <dons> yeah. that's an interesting one. it shoud be possible to resize the ratio with the mouse
19:35:53 <blackdog> i don't really use the floating layer.
19:35:59 <dons> instead of mod-h /mod-l
19:36:02 * ddarius thinks xmonad does too much.
19:36:13 <dons> ddarius: too much automatically?
19:36:18 <dons> or too many features?
19:36:23 <ddarius> The latter.
19:36:30 <dons> o rly?
19:36:39 <ddarius> I don't use the tiling hardly at all.
19:36:47 <dons> yeah, me neither
19:36:49 <dons> just fullscreen
19:36:54 <ddarius> I think I've disabled the mousing, if not I should.
19:36:59 <dons> i.e. what xmonad did when it was 90 lines of code
19:37:14 <blackdog> please don't take the tiling out :)
19:37:19 <dons> no no. :)
19:37:33 <dons> its the 5% use cases that you need these other things for, when using a laptop
19:37:51 <dons> i run my laptop in fullscreen, but sometimes need gimp, or firefox transients etc
19:37:59 <ddarius> blackdog: I'm probably still at the point where I would still want it for the occasional thing, though I haven't really used it since I set xmonad up the way I like.
19:38:00 <dons> and of course other people have big screens, and need tiles
19:38:06 <blackdog> dons: so you just have an xterm fullscreen?
19:38:09 <dons> yeah
19:38:12 <dons> urxvt actually
19:38:16 <ddarius> same here
19:38:18 <dons> since it resizes/scrolls nicer
19:38:21 <blackdog> your minimalism alarms me
19:38:23 <Nafai> I typically do everything full-screen
19:38:31 <dons> i have a status bar too
19:38:38 <dons> blackdog: 1024x768 laptop though
19:38:47 * ddarius doesn't have a status bar nor uses the window borders (set to 0)
19:38:58 * ddarius was watching a movie and the red border was highly distracting.
19:39:00 <sorear> 1280x1024 fullscreen here :)
19:39:00 <blackdog> right now i can see 10 terminals, if you count emacs windows too... then again, three monitors leads you to be a little profligate
19:39:07 <ddarius> Plus 2 more pixels in each direction!
19:39:15 <dons> blackdog: oh, you're using all 3 with xmonad?
19:39:24 <blackdog> no, no
19:39:30 <dons> you should :)
19:39:37 <blackdog> i have two on the mac, and one on the emulated openbsd box :)
19:39:41 <wli> http://holomorphy.com/~wli/Terminfo.lhs
19:40:05 <blackdog> it's funny, though - the way i have my mac set up, all the windows are painstakingly tiled, just like xmonad :)
19:40:22 <blackdog> it really irritates me to have layered windows. it feels untidy.
19:40:33 <dons> yeah, i have a theory that all window managers approach tiling in the limit
19:40:40 <dons> though usually you have to do it manually
19:40:51 <dons> so dirty, blackdog. unclean!
19:40:59 <ddarius> This is while dons uses only fullscreen...
19:41:08 <blackdog> when i switched to mac, that was the hardest thing to get used to - i'd been using ion, and the mac window manager isn't even close.
19:41:18 <dons> i'm hoping this new gimp ui should help xmonad users a lot, http://holomorphy.com/~wli/Terminfo.lhs
19:41:23 <ddarius> I liked ion.
19:41:27 <wli> dons: Hmm?
19:41:28 <dons> grr. not that link.
19:41:29 <ddarius> I used it on Windows
19:41:32 <dons> http://www.venturecake.com/gimps-major-ui-revamp/
19:41:36 <lambdabot> Title: VentureCake  Blog Archive  GIMP's major UI revamp
19:41:39 <dons> ` GIMP's New Single Window UI  '
19:41:45 <wli> mauke: Not quite perl.
19:41:58 <dons> ddarius: how'd you do that?
19:42:00 <gravity> dons: It's pure rumor. The gimp team isn't working on it, sadly.
19:42:00 <ddarius> A lot of paint programs like GIMP use a tiling setup.
19:42:17 <ddarius> dons: I ran an X server.  Unfortunately, it was only useful for Cygwin stuff.
19:42:34 <dons> gravity: :/ oh. that would really help tiled wms. gimp is badly behaved on small screens
19:42:45 <gravity> Yeah
19:44:18 <ddarius> If I could've gotten ion (or xmonad) or a similar wm working on Windows, I probably wouldn't have really bothered installing linux.
19:44:37 <ddarius> (i.e. working with native windows applications)
19:47:22 <dons> glguy: do we know anything about the oscon tutorial video yet?
19:48:10 <blackdog> ddarius: am doing something similar - cygwin/x connecting to an emulated openbsd box
19:49:13 <dons> what are you using the openbsd box for, btw?
19:50:03 <blackdog> s&g, mostly. i really wanted a unix box but needed windows for IE testing and the occasional shootemup
19:50:23 <blackdog> and openbsd seemed a nice minimal system that wouldn't overload the box
19:50:30 <blackdog> i'm pretty happy with it so far
19:50:35 <dons> cool
19:51:00 <dons> yeah, its good on minimal systems. my little 500Mhz fanless via box makes a nice firewall, for example
19:51:17 <dons> would be good for stereo-profile mp3 systems and the like too, i reckon
19:52:05 <dons> now, just to find a good phone that can run haskell usefully
19:52:10 <glguy> dons: it is being editing / processed
19:52:18 <glguy> dons: I'm going to update the /topic
19:52:23 <dons> ok. cool
19:52:23 <glguy> dons: andy knows to tell me
19:52:45 <dons> ah good. so all in hand
19:52:45 <glguy> since that seems to be a popular question
19:53:22 <blackdog> dons: oh hell yes.
19:53:27 <blackdog> i'm so sick of symbian
19:53:47 <Nafai> dons: Could the Open Moko phone run Haskell?
19:53:56 <ddarius> I guess I'll get to watch tomorrow afternoon.
19:58:14 <kfish> can ghc produce arm binaries?
19:58:30 <kfish> http://www.openmoko.com/products-neo-base-03-hardware.html
19:58:43 <lambdabot> Title: openmoko.com: Neo Base
19:59:14 <ddarius> \w -> focus w >> mouseMoveWindow w <=> liftM2 (>>) focus mouseMoveWindow
19:59:19 <ddarius> Yay obfuscation
20:00:30 <dons> kfish: yeah, i believe so. though nhc98 might be a safer bet
20:00:43 <dons> (its been used on the pleb, for example)
20:01:00 <kfish> cool
20:01:17 <LoganCapaldo> Can that thing make phone calls yet?
20:01:45 <dons> mm, this openmoko thing looks fun
20:02:10 <dons> `If you do not know how to program, please wait till October'
20:02:14 <dons> :)
20:03:51 <ddarius> I get a guitar pick?
20:04:10 <LoganCapaldo> Can it make phone calls if you do know how to program?
20:08:22 <enolan> LoganCapaldo: There's a video on the site in which one makes a call to another, so I think yes.
20:14:41 * wli wonders if there's some more intelligent way to do what he's doing at http://holomorphy.com/~wli/Terminfo.lhs
20:18:43 <ddarius> dons: It should say, "If you do not know how to program, you have less than three months to learn!"
20:20:29 <glguy> I downloaded Solaris 10 as a curiosity, I had the choice of downloading 4 or 5 500 meg dvd image segments (zip files) or 1 1000 meg .exe, which takes "90 minutes on a P4-3GHz system"
20:20:34 <glguy> to extract
20:20:39 <wli> \c -> unfoldr (\s -> let (x,xs) = break (==c) s in if s == "" then Nothing else if xs == "" then Just (x, xs) else Just (x, tail xs))
20:20:55 <glguy> talk about computationally intensive compression :)
20:21:39 <wli> I'm thinking about beating the Reed-Solomon drum wrt. compressed and image file formats at some point.
20:21:46 <SamB_XP_> don't they have a 50 meg image that does a netinstall?
20:21:50 <SamB_XP_> or something like that?
20:22:15 <glguy> SamB_XP_: They very well might...
20:22:29 <glguy> its a shame that they don't make use of my second core though
20:22:30 <wli> Checksums suck; Reed-Solomon (and more powerful things of the same nature) rule.
20:23:21 <wli> Is there some library function I'm failing to think of to accomplish the same as the above combinator I pasted?
20:23:44 <glguy> wli: there isn't
20:24:00 <wli> glguy: pain
20:24:11 <ddarius> It's oft requested.
20:24:18 <glguy> it gets reimplemented every time its needed :(
20:25:31 <RyanT5000> how usable is Cayenne?
20:26:23 <ddarius> I don't think it has been maintained in years...
20:26:31 <dons> yeah, pretty sure its abandoned
20:26:39 <SamB_XP_> it compiles again though!
20:26:49 <SamB_XP_> @go cayenne darcs
20:26:51 <lambdabot> http://objectstyle.org/cayenne/lists/cayenne-devel/2005/12/0026.html
20:26:51 <lambdabot> Title: <a href='http://objectstyle.org/cayenne/lists.html'>cayenne-dev
20:27:02 <SamB_XP_> @go cayenne darcs haskell
20:27:13 <SamB_XP_> arg.
20:27:18 <lambdabot> Plugin `search' failed with: IRCRaised thread killed
20:27:27 <dons> ?where+ cayenne http://www.dependent-types.org/
20:27:28 <lambdabot> Done.
20:27:31 <RyanT5000> how come it was abandoned?
20:27:38 <dons> it was a research project
20:27:40 <RyanT5000> augustss?
20:27:47 <ddarius> dons: Took exactly the words out of my mouth.
20:28:20 * glguy wonders if GHC run on Solaris 10
20:28:27 <SamB> @where+ cayenne http://www.augustsson.net/Darcs/Cayenne
20:28:28 <lambdabot> Done.
20:28:30 <dons> RyanT5000: maybe you want to look at epigram?
20:28:43 <RyanT5000> dons: yeah, i have; it doesn't seem particularly usable yet either
20:29:08 <dons> oh, I think epigrams definitely usable, for some things
20:29:30 <ddarius> It's usability velocity vector is at least pointing toward more usable.
20:29:35 <glguy> dons: for web development??
20:29:36 <glguy> ;)
20:29:39 <dons> of course!
20:29:46 <glguy> egg-celent
20:29:49 <SamB_XP_> some of us experience mysterious failures in running "make all" for cayenne, though...
20:30:06 <dons> ?where+ epigram http://e-pig.org/
20:30:06 <lambdabot> Done.
20:30:41 <RyanT5000> so, now for something completely different: is there a good clean implementation of typed lambda calculus with GADTs?
20:30:54 <SamB_XP_> we need to spread around the URL for the darcs repo for cayenne
20:31:12 <Nafai> What's cayenne?
20:31:22 <ddarius> Haskell?
20:31:35 <wli> Nafai: It's hotter than Haskell. ;)
20:32:21 <SamB_XP_> you say it has more higher-order types than Haskell?
20:33:04 <wli> mauke: Any comments yet on http://holomorphy.com/~wli/Terminfo.lhs
20:33:19 <wli> There must be a smarter way to do this...
20:33:40 <SamB_XP_> wli: you could bang your head repeatedly against the wall!
20:37:42 <wli> SamB_XP_: Well that's essentially what programming this at all consists of.
20:38:03 <SamB_XP_> I was afraid you'd say that
20:50:02 <wli> The really tedious part of all this appears to be assembling the attribute table from the positionally-specified values.
20:54:05 <sorear> ...
21:03:08 <dibblego> is it possible to generalise all tuples to a type-class that has a fst' function?
21:03:12 <jfredett> is there a pretty printer for Data.Map ?
21:03:31 <jfredett> i just need something to render as a table, and I don't want to do the leg-work
21:03:40 <dons> dibblego: there are tricks for that, yes. seems to be rarely useful though?
21:03:55 <sorear> dibblego: No.  There are an infinite number of them, and they are completely unconnected.
21:03:57 <dons> jfredett: map draw . fromList ?
21:03:58 <dibblego> dons, it's just a common argument from the lisp crowd
21:04:10 <jfredett> that'll do, methinks
21:04:11 <dons> they confuse tuples , trees and listts
21:04:16 <sorear> lisp doesn't have n-tuples, period
21:04:28 <sorear> haskell has them but they're horrible
21:04:28 <dibblego> lisp has cdr/car
21:04:38 <sorear> dibblego: those are 2-tuples, not n-tuples
21:04:47 <dons> right, head and tail of a list/ tree, 2-tuple
21:04:55 <sorear> sure, you can nest them, but you can do that in Haskell too
21:04:56 <dibblego> ah ok
21:04:57 <sfultong> does anyone use the curry function? I use uncurry frequently, but that's it
21:05:04 <dons> curry is less common
21:05:20 <Olathe> I have the restaurant down the street apply curry for me.
21:05:25 <dons> that's cool
21:05:31 <Olathe> It's quite a functional relationship
21:05:34 <dons> ?google how to make a fast curry
21:05:35 <lambdabot> http://research.microsoft.com/~simonpj/papers/eval-apply/
21:05:35 <lambdabot> Title: How to make a fast curry
21:05:38 <dons> :)
21:05:52 <Pseudonym> Mmmm... fast curry...
21:06:18 <jfredett> hrm, where is this magical "draw" function, dons?
21:06:38 <dolio> @type let car = fst ; cdr = snd ; cadadr = car . cdr . car . cdr in cadadr
21:06:40 <lambdabot> forall a a1 a2 b b1. (a, ((a1, (a2, b)), b1)) -> a2
21:07:34 <dons> jfredett: so you extract the map as a list of pairs, then map your custom row draw function over it
21:07:45 <dolio> Or should that be the other way around? I can never remember which order things like caddar go. :)
21:07:53 <dons> > show (M.fromList [('a',1), ('b',2)]
21:07:54 <lambdabot>  Parse error
21:07:54 <jfredett> yah- thats precisely what I'm trying to avoid
21:07:57 <dons> > show (M.fromList [('a',1), ('b',2)])
21:07:58 <jfredett> :P
21:07:58 <lambdabot>  "fromList [('a',1),('b',2)]"
21:08:06 <dons> > M.toList (M.fromList [('a',1), ('b',2)])
21:08:08 <lambdabot>  [('a',1),('b',2)]
21:08:09 <sorear> jfredett: Try using showTree
21:08:47 <sorear> > M.showTree (M.fromList [(1,2),(2,3),(3,4),(4,5),(5,6)]
21:08:47 <lambdabot>  Parse error
21:08:49 <sorear> > M.showTree (M.fromList [(1,2),(2,3),(3,4),(4,5),(5,6)](
21:08:49 <lambdabot>  Parse error
21:08:50 <sorear> > M.showTree (M.fromList [(1,2),(2,3),(3,4),(4,5),(5,6)])
21:08:52 <lambdabot>  "2:=3\n+--1:=2\n+--4:=5\n   +--3:=4\n   +--5:=6\n"
21:08:57 <dons> > concatMap (\(a,b) -> printf "<%c> --> {%d}" a (b :: Integer)) $ M.toList (M.fromList [('a',1), ('b',2)])
21:08:58 <lambdabot>  Add a type signature
21:09:03 <dons> > concatMap (\(a,b) -> printf "<%c> --> {%d}" a (b :: Integer)) $ M.toList (M.fromList [('a',1), ('b',2)]) :: String
21:09:04 <lambdabot>  "<a> --> {1}<b> --> {2}"
21:11:25 <jfredett> hmm, that didn't quite do what I was looking for. :/ oh well, I guess its custom printer for me
21:15:44 <dons> nice bos, http://programming.reddit.com/info/2al0d/details
21:15:45 <lambdabot> Title: On the value of strong static typing: "make illegal states unrepresentable" (red ...
21:16:11 <hpaste>  Phfyt annotated "My hands are shaking and my feet are numb," with "discount phentermine" at http://hpaste.org/1741#a3
21:16:20 <dons> sorear: ?
21:16:31 <dons> we need more aggresive blacklisting
21:17:01 <wli> dons: Examples of how to do this would help.
21:17:07 <Olathe> [url= is quite a nice bit of Haskell
21:17:12 <wli> dons: That is, to explain it to people.
21:18:09 <wli> One of the big nasties with this is that there are conventional idioms that don't follow this.
21:18:14 <wli> Like xs !! n
21:18:17 <jbauman> dons, haskell as Newspeak?
21:18:39 <wli> xs !! n has issues (1) negative numbers (2) empty lists
21:18:53 <dons> yes, its not typed richly enough
21:19:08 <Pseudonym> See also Phil Wadler's stuff on blame.
21:19:15 <dons> you want Nat -> List NonEmpty a -> a
21:19:19 <wli> head, tail, and so on are similarly against the grain of type safety etc.
21:19:20 <dons> which is perfectly doable
21:19:38 <sorear> dons: that's not good enough
21:19:58 <dons> well, length as well, getting harder :)
21:20:01 <wli> dons: Well, a critic would read the article, go look at the conventional idioms, point at (!!), and laugh.
21:20:13 <sorear> dons: I want to write forall (t:Type) (n:nat) (l:list t), length l > n -> t
21:20:19 <shapr> I know I've asked this before, but... does 6.6.1 or 6.7 use multiple CPUs when doing --make ?
21:20:21 <sorear> dons: which is perfectly legal in Coq
21:20:23 <dons> shrug. see the point about small systems versus big ones
21:20:31 <sorear> shapr: It doesn't
21:20:51 <wli> There are other things beyond just lists, like pattern match failures.
21:21:04 <dons> right, which is what we use Catch for, as extended static checking
21:21:18 <dons> but we also use the type system for that kind of thing. xmonad does this all over the place
21:21:39 <dons> combining type system, static checking and property testing, all depending on the cost/benefit ratio
21:22:16 <wli> A lot of this is standard prelude usage.
21:22:31 <wli> Or idiom.
21:22:36 <shapr> Yeah, dependent types give lots of checking, but much higher costs.
21:22:57 <wli> shapr: Where are those costs? It's a static type system so you must not be referring to runtime.
21:23:00 <dons> yep. not everything is fully specified on the type level
21:23:15 <dons> depending on your project, you might justify moving more things into the type system
21:23:43 <dons> by default haskell provides a pretty high level of safety, at little cost. you can pay some more overhead, for more safety, as you need
21:23:44 <shapr> wli: You have to skip one of terminating typechecking, or general recursion, or something else I've forgotten about..
21:24:10 <wli> shapr: I think most skip terminating typechecking and flag an error after the typechecker spins too long.
21:24:32 <shapr> Haskell hasa strongly normalizing typechecker (with extensions turned off) and I like that.
21:25:00 <shapr> Admittedly, it's turing complete with all extensions turned on. I've forgotten exactly which extensions kill termination.
21:25:25 <wli> shapr: -fallow-undecidable-instances looks like a good candidate.
21:25:32 <shapr> On the other hand, you can do something similar with Epigram. That is, you can develop without general recursion, and "just add fix" for production code.
21:26:04 <shapr> So maybe strong development, weak production is a good paradigm?
21:26:10 <shapr> Reminds me of type erasure ....
21:26:35 <wli> shapr: I go with the slogan of initial algebras: "No junk, no confusion."
21:26:45 <sorear> Coq doesn't have general recursion, period.  (You can write programs that take arbitrarily long, though.  like say Graham's Number of seconds...)
21:26:54 <shapr> wli: How do you apply that to this discussion?
21:27:30 <shapr> Do you mean there shouldn't be extensions, only a single unified system?
21:27:36 <wli> shapr: Illegal states are "junk," inadequate types to model have "confusion" where discriminating between several things in what you're modelling is not possible.
21:27:55 <shapr> Ah
21:28:11 <shapr> The only truly accurate simulation is the thing itself...
21:28:45 <wli> shapr: Well, it's not a simulation per se. It's more low-level and algebraic (in particular universal algebra).
21:29:58 <wli> In universal algebra "no junk, no confusion" describes an initial algebra. The notions of junk and confusion are much the same, but relate to the necessity and sufficiency of the sets chosen to model your signature vs. what the signature models.
21:30:39 <shapr> oh
21:30:40 <wli> So, for instance, if you had data Nat = Zero | Succ Nat, negative numbers would be "junk," and the integers mod 5 would have "confusion."
21:30:49 <shapr> Right, I see that.
21:31:36 <shapr> So you're saying that there are cases where Haskell's type system is not a sufficient signature for the model, and in those cases something better, maybe dependent types, is the best choice?
21:31:46 <shapr> well, better choice
21:32:05 <wli> Well, the type system would be rules for allowable signatures, not a signature in and of itself.
21:32:44 <wli> The data structures in the standard Prelude would be a signature and they're neutral in and of themselves.
21:32:50 <shapr> Oh, I remember the third thing, type inference!
21:33:47 <shapr> Haskell has a terminating typesystem, general recursion, and type inference. You can't do that with Epigram, though at some level you wouldn't want to either, when the types are the code.
21:33:58 <wli> I think of type inference as a convenience vs. a necessity. I'd be fine fully specifying types, though for polymorphic languages you need syntactic help, like scoped type variables you can refer to in type annotations for nested functions.
21:34:42 <shapr> I like experimental and random hacking, and I've had more than one job writing Java, so I dearly love type inference.
21:34:52 <wli> Sometimes I feel like the type inference allows too much and I annotate the living daylights out of things.
21:35:22 <shapr> Don't write much Python, I assume? ;-)
21:35:47 <wli> I don't like perl, python, ruby, etc. I actually use Haskell where most use those.
21:35:53 <shapr> Before I learned Haskell, I hated static type checking.
21:36:30 <wli> Before Haskell et al I would write in C for its static type system.
21:37:13 <shapr> From the LWN articles I've been reading lately, you still do write some C code :-)
21:37:24 <wli> Yeah, I do.
21:37:30 <mauke> perl has typesafety!
21:37:37 <wli> Not so much in userspace, though.
21:37:44 <mauke> http://search.cpan.org/~swalters/typesafety-0.05/typesafety.pm
21:37:46 <lambdabot> Title: typesafety.pm - compile-time object type usage static analysis - search.cpan.org
21:37:50 <shapr> Nah, I was reading about, um,  -ck ?
21:37:54 <wli> mauke: Any comments thus far on Terminfo.lhs?
21:38:07 <wli> shapr: I heard con mentioned me.
21:38:10 <shapr> Yeah he did.
21:38:15 <mauke> wli: yes, it has an annoying content type
21:38:40 <wli> mauke: What's that?
21:38:54 <shapr> I'm always amazed at the connectedness of the open source community.
21:39:05 <mauke> the thing the web server sends to the browser to tell it what file type to expect
21:39:21 <wli> mauke: http://holomorphy.com/~wli/Terminfo.lhs.txt
21:39:28 <wli> mauke: Yes, what content type is it giving you?
21:39:53 <mauke> firefox just says "LHS file"
21:40:06 <mauke> and offers me to download it or open it with less
21:40:15 <wli> I have no idea how to fix it in the apache config.
21:40:46 <wli> /etc/apache/mime.types:702:text/x-literate-haskell                             lhs
21:40:52 <wli> It should already know it.
21:41:28 <mauke> the problem is that firefox doesn't want to display text/* "inline"
21:41:49 <mauke> it only knows about text/html, text/plain, and a few others
21:41:52 <wli> mauke: Okay, does Terminfo.lhs.txt do any better?
21:42:00 <mauke> yes
21:43:15 <wli> Some of the offset recalculation crap will go away when I tie it all together with the decoding into terminal attributes.
21:47:54 <mauke> splitNames is unused
21:48:37 <wli> mauke: Nuked.
21:49:24 <wli> Warnings about unused code might be nice.
21:49:32 <mauke> I'd write parseBool as parseBool '\0' = return False; parseBool '\1' = return True; etc
21:51:12 <dolio> @remember JonHarrop So real users can exploit sophisticated statically-typed languages that ride on .NET to design spacecraft or cure cancer and the users who struggle with maths can lash together their shopping trolleys for porn sites using dynamically typed languages like IronPython.
21:51:12 <lambdabot> Done.
21:52:48 <mauke> wli: your string code looks wrong
21:53:11 <wli> mauke: Which part?
21:53:34 <mauke> the part where it doesn't index into the string table :-)
21:53:56 <wli> mauke: more specifically?
21:54:10 <mauke> the format of the string section is the same as the format of the number section
21:54:21 <mauke> i.e. a bunch of Int16s
21:54:58 <mauke> after the string section comes the string table. the numbers in the string section are offsets into the string table
21:55:13 <wli> mauke: Okay, that is wrong, I'm missing things.
21:55:50 <naggerbot> DCC SEND aiufbauibauiebifkbsifjbsefgijb 0 0 0
21:55:52 <Korollary> dolio: such a classy quote
21:55:58 <mauke> it probably won't help you, but here's how I do the last part: @proto{@STR_CAPAB} = map defined $_ ? substr($strtable, $_, index($strtable, "\0", $_) - $_) : undef, @offsets;
21:56:06 <dolio> Korollary: He's quite the charmer.
21:56:32 <dolio> Korollary: We'll have enough for @harrop if we want it in no time. :)
21:56:57 <wli> mauke: I don't really need the offsets given the way I'm doing the string processing, but I should probably do an integrity check.
21:57:03 <mauke> wli: I treat absent entries as -1, i.e. undefined
21:57:41 <mauke> huh? if you don't use the offsets, how do you know which string belongs to which capability?
21:57:44 <wli> mauke: Absence is when the table is too short?
21:57:48 <mauke> yes
21:58:07 <wli> mauke: Ah, the strings may appear out of order.
21:58:28 <mauke> I think so
21:58:42 <wli> mauke: Or otherwise have negative offsets (-1?) indicating their absence.
21:59:17 <mauke> yes
22:05:27 <wli> mauke: Thanks, the string table looks much better now.
22:09:59 <mgsloan> I just had a thought - perhaps in order to better facilitate DSLs, it might be valuable to have some sort of thingamabob which wraps code, and declares that the vars under certain qualified names are directly usable.  I suppose it would be rather inelegant for haskell, but it would be neat.
22:10:30 <sorear> ML has that
22:10:33 <mgsloan> I think in some languages this is a 'using', or 'with' declaration
22:10:42 <mgsloan> ah, cool
22:11:10 <wli> mauke: Thanks, the string table looks much better now.
22:11:23 <wli> ML calls it "open"
22:11:32 <mgsloan> eg, out of nowhere I could:
22:11:32 <mgsloan> foo x y= using Vector { x + y }
22:11:37 <wli> You can also do local opens.
22:12:05 <mgsloan> yeah, mine would be both decl and expression..
22:12:28 <wli> Which is basically importing a module only within the scope of a let
22:12:49 <mgsloan> ah, yep
22:12:56 <wli> It's very handy for controlling namespace clashes.
22:13:21 <Eelis> yes, i too miss that feature
22:13:46 <mgsloan> yeah, I can imagine.  I think it'd be very nice as dsl-ish things become more prevalent.  Maybe haskell++, eh?
22:13:56 <wli> There's obviously more you can do that ML doesn't, like qualifying modules imported from an outer scope or hiding symbols imported from an outer scope.
22:14:37 <mgsloan> well, my idea was to leave the imports at the beginning, yet reference qualified names in the using decls.  perhaps the distinction is pointless, though
22:14:38 <mauke> using (dynamicScope 2)
22:14:50 <Eelis> i don't like having to import parsec modules exposing dozens of short-named constants just to be able to write a convenient parser somewhere in my code
22:14:55 <mauke> gives you access to local variables two steps up the call chain
22:15:48 <wli> Well, if I were designing a language, I probably wouldn't design a functional language, because there are already a lot of good functional languages out there.
22:16:05 <mgsloan> Eelis - common practice of course would be to use qualified names, but yeah, using decls would be nice
22:16:23 <sorear> Eelis: You might want to look at Coq's notation scopes for inspiration
22:16:27 <Eelis> mgsloan: with qualified names the parser definitions get ugly
22:16:36 <mgsloan> true
22:16:37 <wli> I'd probably do something meant to be usable in many of the same roles as C, but using a lot of things like functional language type syntax and module systems.
22:16:37 <mauke> wli: that kind of reasoning leads to INTERCAL (and Tamerlane)
22:16:41 <Eelis> sorear: i'm thoroughly unimpressed with Coq's notations.
22:16:55 <wli> mauke: I've never heard of Tamerlane.
22:17:13 <wli> mauke: OTOH I'm obviously not talking about a joke like Intercal.
22:17:17 <mauke> http://catseye.tc/projects/tamerlane/doc/tamerlane.html
22:17:18 <lambdabot> Title: Cat's Eye Technologies: The Tamerlane Programming Language
22:17:33 <mgsloan> wli - howsabout a procedural language built on a functional language?
22:17:49 <Heffalump> the most important thing for DSLs is probably more overloading
22:17:59 <wli> mgsloan: I've no idea what you mean.
22:18:12 <mgsloan> yeah, overloading as well. thing is, haskell can't adopt open functions. it won't happen
22:18:22 <Heffalump> it seems to be getting quite close
22:18:25 <wli> mgsloan: What's an "open function" mean?
22:18:34 <Eelis> if i remember correctly, in Clean common operators like + and - have their own type classes. i liked that
22:18:43 <mgsloan> wli - write (or just use haskell, heh) a functional language, and a procedural layer on top
22:18:47 <mauke> "A Tamerlane program consists of a mutably weighted directed graph."
22:18:58 <mgsloan> Eelis - yeah, tis the way it probably should be
22:19:18 <Heffalump> wli: a function whose definition can be extended with more clauses at a later date
22:19:19 <mgsloan> wli - open function is basically unlimited overloading, but safer
22:19:21 <wli> mauke: I can't imagine that being intended to be useful.
22:19:38 <Heffalump> usually useful in conjunction with open data types
22:19:50 <mauke> wli: well, there are already a lot of good useful languages out there
22:19:53 <wli> Heffalump: I was referring to the Tamerlane programming language.
22:20:43 <wli> mauke: Cyclone is much more like what I had in mind than Intercal or Tamerlane.
22:20:45 <Heffalump> I didn't think you thought it was useless, I was just saying what they are good for anyway :-)
22:21:34 <wli> mauke: http://cyclone.thelanguage.org/
22:21:36 <lambdabot> Title: Cyclone
22:22:56 <mauke> "Cyclone versions up to 1.0 require version 3 of gcc; note that gcc version 4 will not work for 1.0."  :-|
22:23:49 <wli> mauke: In any event the state of the art in this area has advanced well beyond my capabilities.
22:24:26 <wli> mauke: I can no more do effective work at language design for unsafe imperative languages than I can for functional or logic languages.
22:24:52 <mgsloan> sorear - all implementations of haskell are interpreters?!?@
22:25:01 <SamB_XP_> what does any of that have to do with the state of the art?
22:25:31 <wli> SamB_XP_: It means the state of the art is beyond my capabilities.
22:25:39 <RyanT5000> is there a way to get a list on the type level?
22:25:51 <RyanT5000> (i.e.: something like a list of types)
22:25:57 <mauke> RyanT5000: yes :-D
22:25:59 <sorear> HList!
22:31:36 <sorear> mgsloan: A haskell interpreter consists of 1. search the current expression down the left spine for a function 2. instantiate it consuming the arguments 3. repeat
22:32:13 <sorear> mgsloan: The so-callect compilers work by generating a specialized version of step 2 for each source function, and representing functions by code pointers
22:32:42 <mgsloan> ah, hmm
22:32:51 <mgsloan> well, that's just the runtime
22:32:56 <mgsloan> it's not really an interpreter
22:33:06 <mgsloan> it doesn't read bytecode and do it
22:33:34 <SamB_XP_> mgsloan: I think sorear is saying that the compiled haskell code is half an interpreter in itself
22:34:00 <hpaste>  mauke pasted "simple type list example" at http://hpaste.org/1951
22:34:07 <mauke> RyanT5000: ^
22:34:18 <mgsloan> hmm, interesting
22:34:21 * SamB_XP_ goes to bed
22:34:38 <mgsloan> completely ignoring the right spine eh :D
22:36:45 <Heffalump> interpreters run code, compilers translate code from one language to another
22:36:53 <sorear> mgsloan: That's the essence of laziness :)  You don't evaluate something just because it's an argument.
22:36:59 <desp> hrm
22:37:08 <desp> can someone help me understand http://twan.home.fmf.nl/blog/haskell/Knuth-Morris-Pratt-in-Haskell.details ?
22:37:11 <lambdabot> Title: Knuth-Morris-Pratt in Haskell - 21 thoughts, http://tinyurl.com/23rvcf
22:37:12 <Heffalump> I would say GHC does a lot of translating.
22:37:26 <Heffalump> and that most of the code running is left to the target machine hardware, not to the runtime system
22:37:41 <desp> specifically, I don't get it why he's using const to make a "failure function"
22:38:28 <desp> btw, this is worthy of being integrated into the libraries, I think
22:38:46 <Heffalump> <gone>
22:38:50 <wli> mauke: IDGI
22:39:38 <mauke> wli: what do you mean?
22:39:59 <wli> mauke: The type list example
22:40:22 <mauke> load it into ghci, then try :t ex, :t tlength ex, toInt (tlength ex)
22:43:43 <wli> mauke: I think you need a typeclass constraint in Cons to prevent people from building binary trees.
22:43:56 <mauke> there's nothing wrong with binary trees
22:44:34 <wli> They're not the data structure you're trying to build.
22:44:51 <RyanT5000> wli: there's no difference
22:44:53 <mauke> doesn't really matter
22:45:06 <RyanT5000> HCons = (,)
22:45:06 <mauke> tlength (undefined :: Cons Int Int) doesn't typecheck
22:45:10 <RyanT5000> HNil = ()
22:45:47 <RyanT5000> the datastructure doesn't care what it's used for :P
22:45:52 * wli dredges up the old junk and confusion slogan.
22:48:09 <Cale> desp: because when everything fails, you want to go right back to the start of the table
22:48:45 <desp> Cale: no, I understand the KMP algorithm, I just find the usage of a const-based function extremely confusing
22:49:06 <desp> I'm trying to rewrite this a bit
22:49:09 <Cale> desp: well, (const table) is just the function which always returns table
22:49:19 <desp> yes, but why do it that way?
22:49:23 <Cale> It's the same as (\c -> table)
22:49:24 <desp> why not just pass in table?
22:50:03 <Cale> Because sometimes it's not just (const table)
22:50:12 <Cale> That's a function parameter
22:50:43 <Cale> In the case that it matches one character, the failure function becomes (next (failure x))
22:50:59 <jfredett> god damnit -- I want to sleep so bad, but I can't stop myself from hacking through this transition table printing code
22:51:06 * jfredett twitches
22:51:15 * desp hands jfredett a Dr Pepper
22:51:16 <jfredett> damn you haskell, for making everything so interesting!
22:51:27 <jfredett> I've got coffee
22:51:36 <jfredett> well- mud, i dont know if that counts
22:51:46 <sorear> I recommend staring at bright lights.
22:51:50 * jfredett has drank half a pot
22:51:54 <wli> This is one of the most idiotic file formats I've seen or heard of.
22:52:01 <sorear> Usually my vision comes back before the melatonin does. ;)
22:52:02 <jfredett> in the last hour... :/
22:52:04 * jfredett twitches
22:52:28 <jfredett> sorear: no- that hurts my eyes to much
22:52:32 <Cale> desp: Note that the failure function gets passed the current character when the current character isn't the expected character from the string being searched for.
22:52:56 <desp> *and* also when it is
22:53:23 <Cale> When the characters match, the failure function is just added to.
22:53:35 <desp> "success = makeTable' xs (next (failure x))"
22:53:54 <wli> It'd be slightly less offensive if they run-length encoded absent entries or something really stupid like that.
22:53:54 <desp> really, this doesn't strike me as particularly clear
22:53:55 <desp> ;)
22:53:57 <lindzeyn> Hello everyone.  I have a genetic algorithm that I am coding right now and I am using a ternary tree data structure to represent members within a population.  This population can range anywhere between 25 TTrees to 100 TTrees.  After I go through about 1200 generations of mutation and crossover, the heap gets filled to the brim and the program terminates.  I was under the impression that Haskell does garbage collectio
22:54:16 <Cale> desp: It's a little strange. You're kind of building a funny graph structure out of function calls.
22:54:35 <lindzeyn> Cale how is that strange
22:54:37 <dons> lindzeyn: yep, it does. do you have the source code available?
22:54:56 <lindzeyn> I cannot release it to the public yet
22:54:59 <dons> lindzeyn: quite possibly your algorithms are hanging onto nodes needlessly?
22:55:03 <jfredett> I wish haskell had a decent debugger.
22:55:21 <Cale> lindzeyn: Well, in this case, the graph structure isn't something entirely easy to visualise :) (It's an example of tying the knot)
22:55:22 <shachaf> How's 6.7's debugger, someone?
22:55:24 <lindzeyn> jfredett, I'm with you there
22:55:26 <jfredett> scratch that, even a crappy debugger would be nice,
22:55:51 <wli> Didn't someone just write a debugger and get it into ghci?
22:55:53 <lindzeyn> dons, I'll double check that
22:56:10 <RyanT5000> is there anything inefficient about using deeply-stacked pairs?
22:56:14 <dons> lindzeyn: have you profiled? and do you copmile with ghc, with -O2
22:56:36 <dblhelix> good morning, #haskell
22:56:43 <dons> lindzeyn: are the elements in each node strict (though 1000 nodes doesn't sound like a lot).
22:57:14 <dons> see for example the binary tree allocator benchmark, for efficient tree types in haskell, http://shootout.alioth.debian.org/gp4/benchmark.php?test=binarytrees&lang=all
22:57:17 <lambdabot> Title: binary-trees benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/zx84m
22:57:23 <lindzeyn> Is the optimization really all that beneficial?  In my experiences with other languages it hasnt been
22:57:38 <dons> lindzeyn: very very beneficial
22:57:47 <dons> 10x or more.
22:58:01 <dons> and you won't get any strictness analysis without -O or -O2
22:58:06 <wli> 497 terminal capability definitions
22:58:08 <dons> meaning you're likely to run into stack overflows
22:58:10 <dblhelix> RyanT5000: as opposed to what? balanced nested pairs? n-tuples?
22:58:29 <dons> lindzeyn: so I would recommend a element-strict tree type, compiled with ghc -O2 -funbox-strict-fields
22:58:32 <lindzeyn> Wow.  I looked at the intermediate C code and it was heavily reliant upon the stack
22:58:36 <lindzeyn> good call.
22:58:46 <dons> really? hmm? what compiler are you using, ghc?
22:58:50 <lindzeyn> yes
22:59:02 <RyanT5000> dblhelix: as in, i'm using them as a typed heterogeneous stack for a language i just wrote in a GADT
22:59:04 <wli> This appears to call for some kind of processing script.
22:59:08 <dons> it doesn't use the C stack though. I guess you know what you're doing though?
22:59:34 <lindzeyn> Right
22:59:41 <lindzeyn> Lets hope I do :)
22:59:46 <lindzeyn> I'll try those flags
22:59:49 <RyanT5000> dblhelix: not *the* stack, just the environment
22:59:49 <dblhelix> RyanT5000: have you read Pascalic and Linger's GPCE 2004 paper on typed meta-languages?
22:59:49 <lindzeyn> thanks
23:00:02 <dons> usually, the C code isn't terribly useful, unless optimising arithmetic code
23:00:02 <RyanT5000> dblhelix: nope
23:00:12 <dons> the intermediate core code though, is very useful for determining which optimisations fired
23:00:18 <dons> (-ddump-simpl)
23:00:36 <SamB_XP_> dons: say, where does GHC keep it's C stacks if not in the same place as it's Haskell stacks?
23:00:49 <jfredett> alright- I've gotta get some sleep, I'll debug this crap later. :/
23:00:49 <dons> also, do profile:   ghc -O2 -prof -auto-all, then run the program with +RTS -p
23:00:49 <sorear> dons: ESP
23:00:52 <dons> to get a log.
23:00:53 <sorear> SamB_XP_: ESP
23:00:55 <dblhelix> RyanT5000: they show how to get rid of imperative overhead and such... it's targeted at Omega, but you should be able to do fine with Haskell and GADTs
23:00:59 <sorear> SamB_XP_: the Haskell stask is in ESI
23:01:16 <lindzeyn> cool, thanks
23:01:22 <SamB_XP_> sorear: ... for a second there, I thought you meant Extra Sensory Perception
23:01:30 <SamB_XP_> sorear: and those are registers
23:01:38 <SamB_XP_> not memory regions
23:01:39 <sorear> SamB_XP_: it keeps them in memory
23:01:57 <RyanT5000> dblhelix: yeah; i have to say it was really easy to write this language; i have a GADT with 5 constructors, which took me about 10 minutes (first time ever using a GADT), and eval took me about 1 minute
23:02:09 <dblhelix> RyanT5000: anyway, if you use the environment just for typing your ast, there should be no runtime overhead (of course, I don't know the particularities of your code)
23:02:14 <sorear> the C stack is wherever Linux decided to put it.  the haskell stack is in a heap allocated TSO# object
23:02:23 <dons> blackdog: if you're interested in a fanless openbsd box, http://www.cse.unsw.edu.au/~dons/sale/
23:02:23 <lambdabot> Title: Don and Suzie go to the USA
23:02:34 <cdsmith> <evil grin>  our domination of reddit is nearly complete!
23:02:36 * desp pasted http://pastie.textmate.org/83359
23:02:38 <desp> Cale: ^
23:02:47 <SamB_XP_> hmm. I suppose that makes sense.
23:02:58 <SamB_XP_> C wouldn't be too happy if you moved it's stacks all about...
23:03:18 * SamB_XP_ really goes to bed this time
23:03:40 <dblhelix> RyanT5000: if you're using the same type to provide the values of your free variables, then variable lookup is just O(n)---not to bad, I guess
23:03:59 <jfredett> gnite folks.
23:03:59 <desp> trying again for better hiliting
23:04:01 <hpaste>  desp pasted "clearer KMP?" at http://hpaste.org/1952
23:04:27 <dblhelix> RyanT5000: Pascalic and Linger disucess some partial evaluation techniques to get it to constant time... but that's for fixed terms and variable environments, of course
23:04:57 <hpaste>  desp annotated "clearer KMP?" with "original version" at http://hpaste.org/1952#a1
23:05:03 <cdsmith> desp: wouldn't (Either x ()) be better understood as Maybe x?
23:05:22 <desp> cdsmith: yes, this is so that I can change isSubstring into findSubstring
23:05:23 <Cale> desp: are you sure that it's not recomputing nodes? Check with Debug.Trace
23:05:31 <cdsmith> Ah, right
23:05:33 <dons> http://programming.reddit.com/info/2alk3/details
23:05:35 <lambdabot> Title: Haskell: Parsec Parser Testing with QuickCheck (reddit.com)
23:05:49 <desp> Cale: hm.
23:05:49 <RyanT5000> dblhelix: it's a pure language; i'm immediately converting everything into haskell closures
23:06:07 <RyanT5000> dblhelix: so i don't think it should be any worse than ghc without -O
23:07:23 <dblhelix> RyanT5000: I see... well, don't expect runtime overhead from the nested pairs then... these types will be gone as soon as you run your code
23:08:03 <dblhelix> dons: how's writing?
23:08:23 <RyanT5000> dblhelix: that's what i expected; there's no overhead when, e.g. deserializing an expression at runtime; even GADTs are totally gone at runtime, right?
23:08:37 <desp> Cale: a trace on the newTable value, right?
23:08:43 <RyanT5000> (i guess that's what it means for a type system to be total, right?)
23:09:04 <dblhelix> RyanT5000: that's what it means to have type erasure
23:09:13 <RyanT5000> dblhelix: ah, ok
23:09:20 <RyanT5000> GADTs are pretty awesome :P
23:09:32 <Cale> desp: sure, that should work.
23:09:33 <dblhelix> RyanT5000: they are 8-)
23:09:39 <RyanT5000> what's an example of something that dependent typing can do that GADTs can't?
23:09:58 <RyanT5000> (i'll accept answers of the form "well, GADTs *can*, but it's a pain")
23:10:19 <RyanT5000> i've been a dependent typing evangelist since before i knew the term for it
23:10:29 <dblhelix> RyanT5000: beta reduction at type level?
23:10:57 <dblhelix> RyanT5000: well, GADTs can, but it's a pain ;-)
23:11:00 <RyanT5000> dblhelix: hm...
23:11:01 <RyanT5000> :P
23:11:13 <Cale> desp: looks okay
23:11:16 <hpaste>  desp annotated "clearer KMP?" with "trace" at http://hpaste.org/1952#a2
23:11:29 <Cale> er, hmm
23:11:30 <desp> yep
23:11:34 <desp> hm?
23:11:41 <lindzeyn> The code is faster now dons, but my heap is still filling up.  I have noticed that the amount of memory used by ghc increases by a factor of 1.75 each time.  Also, I am using lazy evaluated infinite lists of random numbers for the probabilities in my algorithm (maybe too much lazyness?)
23:11:49 <jfredett> HAH HAH!
23:11:54 <jfredett> I got it to work
23:12:10 <jfredett> okay- _now_ I'm going to sleep
23:12:46 * cdsmith looks back for what jfredett got to work
23:13:06 <jfredett> a pretty printer for my DFA
23:13:08 <jfredett> :)
23:13:14 <jfredett> and any other automata, for that matter
23:13:18 <jfredett> well, pretty much
23:13:21 <lindzeyn> I coded that too jred
23:13:22 <cdsmith> Cool.  Congrats.  Does it draw diagrams, or justr tables?
23:13:24 <lindzeyn> jfred
23:13:26 <desp> Turkish chessplayer automata?
23:13:32 <jfredett> the infrastructure, leastways
23:13:38 <lindzeyn> I've done DFA and NFA and a Turing machine
23:13:45 <Cale> desp: yeah, it's okay. I was a little confused at first about why there were 5 of them.
23:13:52 <lindzeyn> Fun isnt it? and elegant
23:13:54 <jfredett> just tables, diagrams will come from graphviz, when i get around to it
23:14:03 <cdsmith> Very neat
23:14:10 <jfredett> lindzeyn: I was amazed that my DFA evaluator took about 15 lines total
23:14:14 <desp> hm, I suppose I don't need the Either for findSubstring after all
23:14:16 <jfredett> to implement the whole thing
23:14:36 <jfredett> it took me an hour to write those 15 lines
23:14:41 <jfredett> but only 15 lines
23:14:45 <lindzeyn> recursion makes it a breeze
23:14:51 <jfredett> i looked at it and said, "shit, 15 lines?"
23:14:53 <lindzeyn> what's your alphabet
23:14:59 <jfredett> anything
23:15:03 <jfredett> its a generic DFA
23:15:07 <lindzeyn> cool
23:15:20 <jfredett> it takes and Orderable, Showable type
23:15:26 <jfredett> for States and Sigma
23:15:32 * int-e wonders why data KMP2 a = KMP2 { kmpDone :: Bool, kmpNext :: (a -> KMP2 a) } generates better code than the same thing done with data KMP3 a = Done | Next (a -> KMP3 a)
23:15:37 <lindzeyn> I added algebriac DFA operators to mine
23:15:44 <lindzeyn> thats maybe 30 lines
23:15:56 <lindzeyn> AND, OR, IMPLIES, NOT
23:15:57 <dons> int-e: hmm, interesting.
23:15:59 <lindzeyn> etc..
23:16:06 <blackdog> @hoogle hGetLines
23:16:06 <lambdabot> No matches found
23:16:13 <lindzeyn> takes two DFA as operands
23:16:14 <jfredett> cool, The core bit of mine is 15 lines, the rest of it, (minimizer, pretty printer, etc.) I expect to take another 40-50
23:16:15 <dons> int-e: shouldn't really be the case with -O2
23:16:36 <jfredett> lindzeyn: thats interesting, I've never read about that, I suppose it makes sense
23:16:56 <desp> int-e: how about the modifications to support the new type?
23:16:56 <int-e> dons: note, I didn't look at the code, I'm just timing the compiled code in ghci. I'll try and compare core.
23:17:05 <lindzeyn> Yep
23:17:08 <jfredett> I assume those things are just operations on accept states
23:17:17 <dons> yeah, int-e, sounds interesting
23:17:28 <jfredett> eg AND = DFA1 accepts & DFA2 accepts ?
23:17:37 <desp> int-e: btw, you only need  newtype Table a = T (Maybe (a -> Table a))
23:18:05 <lindzeyn> Yes I believe so
23:18:12 <jfredett> cool
23:18:29 <int-e> desp: same thing
23:19:10 <lindzeyn> the turing machine was a bitch
23:19:17 <jfredett> I'd imagine
23:19:21 <lindzeyn> a universal turing machine
23:19:35 <jfredett> I intend to use a zipper. :)
23:19:38 <lindzeyn> just a big disgusting automata
23:19:40 <jfredett> for the tape
23:20:00 <jfredett> well, sortof
23:20:16 <jfredett> the ideas up there, I'm just waiting for my brain to work out all the details
23:20:48 <lindzeyn> Yep, for the tape, I just make an infinite list w/ blanks ones and zeroes
23:20:53 <jfredett> I guess it'd be a Stream-Zipper,
23:21:45 <lindzeyn> I dont know much about zippers
23:21:55 <jfredett> they're only the coolest thing ever
23:22:01 <lindzeyn> haha
23:22:04 <jfredett> derivatives of datatypes == teh awesome
23:22:12 <jfredett> its a list with O(1) access to any element
23:22:18 <lindzeyn> well google here i come
23:22:24 <lindzeyn> woah, nice
23:22:48 <jfredett> lol, theres also a Zipper-Zipper, which was on reddit a while ago, it had O(1) slicing, :)
23:22:50 <lindzeyn> is it a wanna-be hash
23:23:22 <jfredett> lindzeyn: well, its significantly useful in its own right, vis a vis Xmonad
23:23:49 <jfredett> you use it to keep track of window focus (at least, thats what I think its used for)
23:23:57 <dons> jfredett: list with O(1) access to the cursor and its neighbours :)
23:24:08 <jfredett> or, in my case, keeping track of my position on the tape
23:24:09 <dons> and yeah, it tracks focus in the window stack
23:24:20 <dons> and gives O(1) access to the next and previous elements, in a list zipper
23:24:23 <lindzeyn> then a zipper would be awesome for a turing machine
23:24:35 <lindzeyn> since that is all you can do, ML MR or W1/0
23:24:43 <jfredett> yeh- a zipper practically _is_ a turing machine
23:24:43 <jfredett> :)
23:24:59 <Pseudonym> A zipper for a list is a TM tape.
23:25:00 <int-e> dons: well, the tuple becomes unboxed, compare (# GHC.Base.Bool, a_aj8 -> KMP.KMP2 a_aj8 #) to KMP.KMP3 a_a
23:25:05 <jfredett> vincenz did the article on second order Zippers, i forget the link
23:25:08 <jfredett> :/
23:25:17 <jfredett> @google higher order zippers
23:25:19 <lambdabot> http://notvincenz.blogspot.com/2007/07/higher-order-zippers.html
23:25:19 <lambdabot> Title: lambda.oasis: Higher Order Zippers
23:25:20 <dons> Pseudonym: hmm, "Derving Turing Machines" would be a nice paper
23:25:24 <jfredett> maybe that will get it
23:25:25 <jfredett> hah!
23:25:31 <dons> int-e: oh, crank up the strictness then.
23:25:48 <dons> the Bool must get some magicks in ghc
23:26:25 <dons> data Step a s = Yield a !s
23:26:25 <dons>               | Skip    !s
23:26:25 <dons>               | Done
23:26:28 <dons> for example
23:26:35 <dons> data Stream a = forall s. Unlifted s =>
23:26:36 <dons>                           Stream !(s -> Step a s)  -- ^ a stepper function
23:26:36 <dons>                                  !s                -- ^ an initial state
23:27:04 <jfredett> i don't know how reading/writing to the tape would work
23:27:19 <blackdog> dons: if i read a file with Data.ByteString.Char8.readFile then count the lines with Data.ByteString.Char8.lines, will that intermediate form get fused away?
23:27:21 <dons> you just modify the current node, don't you, in the TM?
23:27:25 <jfredett> it would have to be a mutable kind of zipper, wait, no- thats easy
23:27:28 <lindzeyn> ah, maybe I should use ! for my TTree alg type
23:27:29 <jfredett> dons: yah
23:27:34 <jfredett> I just wasn't thinking
23:27:57 <dons> blackdog: it will build a list. lines is best done with lazy bytestrings
23:28:06 <jfredett> (LeftBits, old, RightBits) -> (LeftBits, new, RightBits) more or less
23:28:11 <jfredett> easy as pi
23:28:14 <Pseudonym> dons: Actually, an even more interesting paper would be to do it for DFAs and PDAs too.
23:28:18 <jfredett> 3.14159...
23:28:23 <lindzeyn> ! forces evaluation, correct?  No lazyness.
23:28:23 <dons> modify f (Tape curr prev next) = Tape (f curr) prev next -- like that
23:28:33 <jfredett> $!, I thought
23:28:37 <Pseudonym> Synthesise the machine from the algebra.
23:28:47 <dons> lindzeyn: yeah, on patterns or data types
23:28:56 <diakopter> hi, can someone point me to something that explains "FC intermediate language changes" in 6.7
23:28:59 <dons> it provides strictness hints to the compiler
23:29:10 <dons> diakopter: the Fc paper on simonpj's page
23:29:19 <jfredett> meh- now I want to work on HFA some more, but I'm going to sleep
23:29:20 <blackdog> ok. but i want to sort them later, and there doesn't seem to be a sort in the lazy bytestrings - any particular reason for that?
23:29:24 <diakopter> dons: thanks
23:29:25 * jfredett yawns
23:29:29 <jfredett> gnite peoples
23:29:32 <dons> blackdog: hmm? sort the list
23:29:40 <blackdog> no, sort the individual strings
23:29:41 <RyanT5000> /w lambdabot
23:29:43 <RyanT5000> er
23:30:00 <int-e> dons: so basically by changing (Bool, a) to Maybe a I don't save any pattern matches (because ghc unpacks the tuple) and the pattern matches were originally on Bool which are likely somewhat magical as you said. the core is almost identical.
23:30:01 <dons> blackdog: oh, there is sort for strict pieces though. so you want to order the letters in each line?
23:30:09 <blackdog> dons: yep
23:30:21 <dons> right, so there's a bucket sort for strict bytestrings
23:30:26 <dons> not sure if we did anything for lazy ones
23:30:44 <blackdog> yeah, i saw that. so i'm best off reading the whole thing in as strict bytestrings in this case?
23:30:58 <dons> i guess  so, yeah
23:31:03 <dons> diakopter: http://www.cse.unsw.edu.au/~chak/papers/SCPD07.html
23:31:03 <lambdabot> Title: Research Papers of Manuel Chakravarty
23:31:21 <RyanT5000> why is this a stack overflow in ghci?: "sum [0..1000000]"
23:31:34 <dons> because sum is a foldl
23:31:46 <dons> and you don't have any strictness analysis in ghci
23:31:55 <dons> > sum [0..1000000]
23:31:56 <lambdabot>  500000500000
23:32:02 <RyanT5000> yeah, i know it works in ghc
23:32:13 <RyanT5000> can i turn strictness analysis on?
23:32:13 <dons> ?src sum
23:32:14 <lambdabot> sum = foldl (+) 0
23:32:27 <dons> > foldl (+) 0 [0..(1000000::Integer)]
23:32:29 <lambdabot>  500000500000
23:32:34 <dons> ghc is still too smart
23:33:09 <dons> RyanT5000: nope, you don't get any optimisations in ghci. if you're caring about performance, just compile the code for a 30x average speedup :)
23:33:15 <Pseudonym> > length (reverse [0..1000000])
23:33:17 <lambdabot>  1000001
23:33:27 <RyanT5000> dons: alright
23:34:18 <RyanT5000> dons: btw, i'm pissed off at your Data.Binary :P
23:34:22 <RyanT5000> (it is yours, right?)
23:34:49 <RyanT5000> i can't hand something "the rest of the bytestring"
23:34:54 <RyanT5000> in a get or a put
23:35:50 <dons> you do have access to the remainder of the input though
23:35:57 <RyanT5000> really?
23:36:14 <dons> yeah, i don't remember what the function is called, but its in the Get and Put modules
23:36:21 <RyanT5000> ah, thanks :)
23:36:35 <dons> basically for parsing, where you want to return the unparsed tail
23:36:39 <RyanT5000> i don't know that it meshes well with the (totally reasonable) mentality of those functions
23:36:42 <dons> for put, does it eve make sense?
23:36:51 <RyanT5000> yeah
23:36:57 <RyanT5000> i have recursive serialization
23:37:04 <RyanT5000> where something's already serialized
23:37:14 <RyanT5000> and i just want to tag it with something else
23:37:21 <dons> ok, that's weird
23:37:27 <dons> perhaps write a data type for that, and serialise that thing
23:37:30 <RyanT5000> then throw the whole thing in
23:37:30 <RyanT5000> yeah, i know
23:37:44 <dons> wrap your thing, tag it, serialise the result
23:37:55 <RyanT5000> no, i can't do that, because the whole point is that it's going to be someone else's code that does that serialization
23:38:03 <RyanT5000> basically, it's a politically-recursive algorithm :P
23:38:13 <RyanT5000> traversing a tree of real-world ownership
23:38:17 <RyanT5000> the bits are largely irrelelvant
23:38:24 <hpaste>  Cale annotated "example evaluation for makeTable'" with "continued (3)" at http://hpaste.org/1954#a3
23:38:32 <RyanT5000> it's similar to if you said "anything starting with http:// is getting fed to the browser"
23:38:45 <dons> i'd have to see the code.
23:38:46 <RyanT5000> "i don't care what the browser does with it"
23:38:47 <hpaste>  Cale annotated "example evaluation for makeTable'" with "done" at http://hpaste.org/1954#a4
23:38:54 <Cale> hehe
23:39:07 <RyanT5000> dons: really this boils down to whether the length of the tail gets serialized or not :P
23:39:14 <Cale> desp: ^^
23:39:49 <desp> Cale: um
23:39:50 <RyanT5000> the only reason it's relevant is that i have to use the same binary format for haskell as well as nonhaskell code, so i want it to be simple and not complicated for the benefit of haskell
23:40:04 <Cale> desp: (the interesting bit is really the end result)
23:40:47 <desp> Cale: can you tell me what am I supposed to see there? :)
23:40:54 <dataangel> Newb question: Why does lex return a singleton list with a pair of strings? Why not just return the pair of strings?
23:41:10 <Cale> desp: That's the result of table = makeTable' "ababc" (const table)
23:41:25 <dons> RyanT5000: I don't understand, if you want, you can serialise the length of the tail if you need to, or not. (encode it without the length)
23:42:00 <lindzeyn> When you wish for a data type to be strictly evaluated via !, is the correct sytnax " data !foo = bar "
23:42:06 <sorear> dataangel: Because it might be ambiguous. :(
23:42:11 <desp> Cale: indeed it is, but I don't see anything surprising
23:42:32 <Cale> desp: I was just thinking that this would clarify what was going on :)
23:42:32 <desp> so what am I missing?
23:42:37 <desp> ahh :)
23:42:38 <RyanT5000> dons: oh, you mean by wrapping ByteString and providing a different instance of Serialize? i suppose i could do that >.>
23:42:58 <desp> Cale: thanks, I understand what's going on, I just thought I could write simpler code
23:43:08 <desp> Cale: did you write that by hand?
23:43:21 <Cale> desp: yeah, just copy/paste/modify
23:43:23 <desp> ah
23:43:37 <dons> RyanT5000: right. you can serialise it anyway you want
23:43:44 <Cale> It's a handy way to sort out what Haskell code is doing :)
23:43:46 <slava32> hi glguy
23:44:32 <dons> heya slava32
23:44:38 <RyanT5000> dons: yeah, although i would worry about that interoperating with get; it seems to break the symmetry
23:45:11 <RyanT5000> someone could use this evil put and then serialize something after it
23:45:19 <RyanT5000> and when get got it, it would take the whole rest of the ByteString
23:45:32 <RyanT5000> so put >> put would no longer correspond to get >> get
23:45:45 <RyanT5000> "to the end of the string" really does need to be special somehow, in both put and get
23:46:02 <dons> um? your types still have to check though.
23:46:11 <dons> evil put has a different   type
23:46:49 <dons> sounds like you're doing it wrong though ;)
23:47:41 <RyanT5000> dons: i'm pretty sure it's reasonable for my application (especially since i'm counting bytes in a pretty serious way - 8 extra bytes might represent 30% overhead in this application)
23:48:10 * wli writes a function to generate the code for the termcaps from C headers.
23:48:36 <dons> but yeah, for special encodings, you should write your own serialising instances
23:48:50 <dons> the default ones are for show/read like serialisation
23:48:54 <dons> not general parsing of data
23:48:57 <RyanT5000> yeah
23:49:39 <RyanT5000> i'm not really comfortable with using Serializable at all for this, because i think i'd really be abusing it
23:49:52 <RyanT5000> i wouldn't want to make something that *looks* interoperable but isn't
23:54:21 <dataangel> sorear: In the ambiguous case, why can't it just return ("", "") ?
23:54:47 <sorear> dataangel: How could that be correct?
23:55:05 <sorear> dataangel: [] is used for backtracking
23:55:27 <sorear> (not that lex uses it, but it still helps for interop with the Haskell parser combinators)
