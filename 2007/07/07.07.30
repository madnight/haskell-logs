00:03:09 <jfredett> meh, so much for sleeping, is there a darcs hosting place around, for my code?
00:03:20 <jfredett> or am I stuck finding some other solution?
00:03:55 <dons> yeah, community.haskell.org
00:04:01 <jfredett> cool
00:04:16 <dons> let me find the log in page
00:04:33 <jfredett> ...
00:04:36 <jfredett> lol, "IT WORKS!"
00:04:50 <dons> see the repos on code.haskell.org
00:06:01 <dons> Igloo: where's the login /register page to point people to , who need darcs repo hosting?
00:06:14 <jfredett> heh, i dunno- I just don't want to have to hack through setting up a webserver on my desktop box, I'll be moving back to school in a couple weeks,
00:06:41 <jfredett> only 2 more years, I'm getting old.
00:06:49 <jfredett> I should start looking at grad schools, :/
00:08:38 <jfredett> its funny- I think that haskell has probably made me better at math, than it has at programming. :/
00:09:17 <jfredett> I've started to think about things on this "How is that datatype really some obscure bit of algebra" level, its enlightening
00:10:17 <jfredett> or "how can I use those functions to prove some type is an instance of foo?" Haskell is awesome like that
00:11:30 <ohub> jfredett: math and programming are closely related. Especially with Haskell.
00:11:47 <jfredett> ohub: yah, I know, and  I knew that before-
00:12:14 <glguy> attempting to install solaris has so far been fruitless :-(
00:12:18 <glguy> the install "worked
00:12:26 <ohub> Doing lambda calculus with pen&paper is cool "programming" :)
00:12:27 <jfredett> whats funny, is even before haskell, I was the one telling everyone "Proofs are Programs!" (I even remember making a comment like that when doing 11th grade geometry
00:12:30 <glguy>  but upon booting, it promptly reboots
00:12:44 <jfredett> I told my father that the two-column proof "felt" like writing lisp
00:12:51 <jfredett> ... how right I was. :) )
00:13:16 <slava32> yes, and a proof is valid iff the corresponding program type checks
00:13:31 <jfredett> its just before, I still, in some way, thought of programming as being programming, and as math as being math
00:13:42 <jfredett> and that they were related, even isomorphic
00:13:47 <jfredett> but not _quite_ the same
00:14:02 <dblhelix> anyone: if I enter "return 42" in ghci, which monad instance is used then?
00:14:07 <jfredett> Haskell has done one of those "holy crap, they really _ARE_ the same thing" things
00:14:10 <dblhelix> > return 42
00:14:17 <lambdabot>   add an instance declaration for (Show (m t))
00:14:20 <Syzygy-> jfredett: What kind of notion of "really the same" do you have is isomorphic isn't enough?
00:14:21 <jfredett> dblhelix: well obviously the hitchhiker monad
00:14:29 <sorear> dblhelix: IO, probably
00:14:29 <slava32> dblhelix, IO
00:14:34 <dblhelix> jfredett: :-)
00:14:46 <dblhelix> slava32: thnx
00:14:55 <jfredett> Syzygy-: well, every group is isomorphic to a group of permutations
00:15:05 <jfredett> that doesn't mean that every group _IS_ a group of permutations
00:15:11 <jfredett> it just means they have the same structure
00:15:15 <jfredett> the same quality
00:15:17 <jfredett> etc
00:15:25 <Syzygy-> jfredett: I do not understand your use of is.
00:15:49 <jfredett> Syzygy-: it means that a Matrix group is fundamentally a Matrix group
00:15:59 <jfredett> but it shares the same structure as a permutation group
00:16:06 <glguy> so apparently there is a game called "road ball" in Ireland?
00:16:14 <glguy> where you throw a steel ball down the road
00:16:19 <glguy> in the spirit of golf
00:16:41 <slava32> Syzygy-, because there's no such thing as "an isomorphism"
00:16:50 <slava32> you can only talk of isomorphisms in a given category
00:16:57 <jfredett> like a brick house and a wood house may share the same design, but that doesn't mean they're the same house
00:17:00 <desp> my function is wrong.
00:17:04 <slava32> for example, R^4 and End(R^2) are isomorphic as vector spaces
00:17:05 <Botje> isomorphisms! geeeeeeeeeeet your isomorphisms heeere!
00:17:17 <Syzygy-> jfredett: You still aren't making sense to me on a pretty darn deep level. I need you to tell me what you mean by is - preferably without resorting to analogies, since all the analogies you'll come up with will only point out to me yet again that the underlying terminology is still too fuzzy.
00:17:18 <jfredett> up until this may (when I started w/ this stuff) programming was a brick house, math was a wood house
00:17:19 <Botje> get them while they're hot 'n steamy!
00:17:23 <Syzygy-> slava32: Good point.
00:17:28 <slava32> bad example
00:17:33 <jfredett> Syzygy-: Mu.
00:17:33 <slava32> how about this
00:17:39 <Syzygy-> jfredett: Thank you.
00:17:45 * Pseudonym huffs and he puffs and he blows your house in
00:17:54 <jfredett> No, really, theres no good way to describe it
00:17:55 <slava32> R^2 with pointwise multiplication, and C viewed as R^2, are isomorphic as real vector spaces
00:17:58 <slava32> but are not isomorphic as rings
00:18:07 <jfredett> at least not that I can think of
00:18:28 <Syzygy-> jfredett: You hit on a pretty damn good point though. This is at the core of some of the more interesting mathematical philosophy I almost come close to looking at myself.
00:18:33 <Syzygy-> slava32: Right.
00:18:38 <jfredett> before, programming and math had a different- smell, almost.
00:18:47 <Syzygy-> slava32: But that only means that C and R^2 are different objects - as rings.
00:18:49 <slava32> R and R^2 are isomorphic as sets
00:19:01 <Syzygy-> And not with the "normal" vectorspace structure
00:19:02 <Syzygy-> Sure.
00:19:06 <slava32> but are not isomorphic as vector spaces, or topological spaces
00:19:32 <RyanT5000> dons: is there any good way to avoid having the tag bytes not duplicated between the get and the put of a Binary instance?
00:19:53 <slava32> Syzygy-, when you say two objects are equivalent up to isomorphism, its like beer goggles
00:20:03 <dons> RyanT5000: ?
00:20:29 <jfredett> dons: did we ever figure out the register site for community.haskell.org?
00:20:35 <jfredett> or should I check back tomorrow?
00:20:41 * glguy has thte link if it is need
00:20:43 <glguy> ed
00:20:49 <RyanT5000> dons: so i have a datastructure with a couple of constructors, and i output a different byte for each one, then proceed to (de)serializing their arguments
00:21:01 <jfredett> glguy: i think it is:/
00:21:03 <RyanT5000> dons: just like in all the examples
00:21:15 <dons> jfredett: yeah, its all set up and ready to go, i just don't have the link
00:21:24 <dons> imo, the c.h.o front page should have the register link
00:21:25 <Syzygy-> slava32: I'm inclined to want to state it the other way around: if you only care about isomorphisms as your best tool for equality (and I claim we can and should), then you have too narrow a concept of equality: more and more isomorphism ends up being WAY too strict, and equivalence is what you want.
00:21:34 <Syzygy-> Especially since Cat is such a nice category to discuss in.
00:21:36 <dons> glguy: link please
00:21:45 <mgsloan> RyanT5000: I believe there is a SYB script for generating Binary instances of that form
00:22:14 <dons> yeah, just use the script in util/* if you need to derive these guys
00:22:20 <RyanT5000> hm, alright
00:22:23 <RyanT5000> does it work with GADTs?
00:22:28 <dons> no idea.
00:22:32 <mgsloan> probably not
00:22:34 <slava32> Syzygy-, 'equality' doesn't really exist, though
00:22:41 * wli has now generated giant data declarations from grepped C headers.
00:22:43 <dons>  you need to derive Data for your type.
00:22:47 <Syzygy-> slava32: Explain.
00:22:49 <slava32> there's no category of all 'objects' with all possible structure
00:22:56 <RyanT5000> dons: i'll look into it
00:22:57 <Syzygy-> Ah.
00:23:15 <Syzygy-> slava32: Sure. You'll want to limit your field of study for basically any single statement you make.
00:23:32 <slava32> equality does make sense in one context
00:23:38 <slava32> suppose you have a group G, with subgroups H and K
00:23:43 <opqdonut> ?src liftM
00:23:44 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
00:23:45 <slava32> there is as huge difference in saying "H and K are equal"
00:23:49 <slava32> and saying "H and K are isomorphic"
00:24:01 * Syzygy- feels a more and more pressing need to push people towards what David Corfield writes - both on his own blog and on the n-category cafe
00:24:04 <Syzygy-> slava32: Sure, sure.
00:24:13 <RyanT5000> data Exp env a where
00:24:14 <RyanT5000>     Lit :: Binary a => a -> Exp env a
00:24:21 <wli> Syzygy: What's that?
00:24:22 <RyanT5000> is that constraint not effective?
00:24:26 <Syzygy-> slava32: However, selecting your category well makes the difference clear.
00:24:29 <psykotic> slava32, there isn't a huge difference as _groups_, but as _subgroups.
00:24:37 <slava32> indeed
00:24:39 <Syzygy-> slava32: In the po-set of subgroups, they are different. Not even isomorphic.
00:24:45 <RyanT5000> it's telling me (later) that it's unable to deduce Binary a
00:24:49 <slava32> once you start working with sub-anything, you have element-wise equality in the parent object
00:24:50 <Syzygy-> wli: The n-category cafe?
00:24:53 <slava32> which brings more structure
00:25:14 <Syzygy-> slava32: Actually, when you start working with sub-thingies, you end up working with morphisms, really.
00:25:15 <jfredett> thanks glguy, dons
00:25:19 <wli> Syzygy: yeah
00:25:20 <Syzygy-> So you change categories.
00:25:22 <slava32> Syzygy-, elements of po-sets have no 'isomorphic to' relation
00:25:25 <jfredett> I'm going to bed now, gnite again
00:25:39 <Syzygy-> wli: A group blog run by John Baez, David Corfield and Urs Schneider.
00:25:49 <Syzygy-> slava32: Of course they do. Po-sets are categories.
00:25:54 <Syzygy-> @go n-category cafe
00:25:56 <lambdabot> http://golem.ph.utexas.edu/category/
00:25:56 <lambdabot> Title: The n-Category Caf&#xE9;
00:26:00 <slava32> ah, ok
00:26:03 <seancorfield> David Corfield?
00:26:11 <slava32> i'm not a big fan of non-concrete categories
00:26:18 <seancorfield> we're a small family... i wonder if he's related?
00:26:22 <psykotic> slava32, isomorphic just means that there's a bijection which is monotone in both directions, i think
00:26:27 <Syzygy-> slava32: What's a concrete category, exactly?
00:26:44 <slava32> objects are sets
00:26:50 <Syzygy-> psykotic: I'm not talking about iso's of posets. I'm talking about iso's IN posets.
00:26:52 <slava32> and there's a forgetful functor from your category to the category of sets
00:26:55 <slava32> which obeys certain laws
00:27:01 <Syzygy-> slava32: Ah. Then you're ignoring Hask while you're at it.
00:27:13 <Syzygy-> (at least I think you do)
00:27:14 <slava32> i don't like it when people define groupoids, groups, posets and so on as 'categories'.
00:27:17 <psykotic> Syzygy-, isos in the poset cat, gotcha
00:27:27 <slava32> it just obfuscates the matter without adding any additional insight.
00:27:46 <psykotic> slava32, i think it's actually particularly illuminating as a way to contrast groups and groupoids.
00:27:51 <Syzygy-> slava32: My entire field of research builds on the recognition that a group can be viewed as a one-object category, and that therefore certain constructions work.
00:27:57 <psykotic> slava32, in the group case you just have one "kind" of object.
00:28:18 <slava32> psykotic, i think the fundamental groupoid -vs- fundamental group in algebraic topology illustrates the difference in a very intuitive way
00:28:43 <jfredett> oh, one more thing, Syzygy-: you'll have to tell me about that really deep concept sometime- I'm probably too tired to full comprehend it now, but you've piqued my interest
00:28:51 <Syzygy-> slava32: If you want to discuss groupoids without calling them categories, you make yourself reconstruct category theory just to build your terminology.
00:28:55 <Syzygy-> jfredett: Sure. :)
00:29:11 <jfredett> gnite!
00:29:16 <slava32> perhaps, but then i don't discuss groupoids, usually :)
00:29:47 <psykotic> blasphemy! aren't you a homotopy terrorist? :)
00:29:56 <Syzygy-> slava32: Which might explain your disdain for non-concrete categories. ;)
00:30:17 * Syzygy- taught alg.top. over the fundamental groupoid to a bunch of 9th graders this spring.
00:30:28 <Syzygy-> I like them thingies. :)
00:30:47 <wli> Syzygy: I haven't the first clue wrt. algebraic topology.
00:30:50 <psykotic> Syzygy-, that reminds me, have you seen that "children's book" on algebraic topology by a japanese gentlemen?
00:30:59 <psykotic> Syzygy-, galois's dream i think it's called.
00:31:19 <Syzygy-> wli: It's not THAT hard, and has awesomely weird applications
00:31:21 <Syzygy-> psykotic: Nope.
00:31:29 <wli> Syzygy: Frankly I've no idea how I ever graduated in pure math. I basically remember nothing except bonehead calc anymore.
00:31:48 <Syzygy-> wli: I don't remember bonehad calc. And I'm still working in mathematics. ;)
00:32:22 <psykotic> Syzygy-, it had a cute exposition of some basic results for middle schoolers.
00:32:29 <wli> Syzygy: I could write a CAS to completely replace myself wrt. mathematical ability/functionality.
00:32:34 <psykotic> Syzygy-, using an analogy of train tracks laid out on an island with various lakes, and so on
00:33:24 <psykotic> and as the name suggests, i think it eventually turned back to algebra and demonstrated the relationship to galois theory
00:33:43 <desp> Cale: so, I was wrong
00:34:14 <desp> note to self: QuickCheck works much better on [Bool] than on [Int]
00:35:08 <wli> Syzygy: I'm so lame I'm having trouble solving systems of integer linear equations (integer coefficients, integer unknowns).
00:35:11 <hpaste>  desp pasted "KMP isSubstringOf and findSubstringIn" at http://hpaste.org/1956
00:35:23 <mgsloan> wli - so this CAS would have the ability to write itself? :D
00:35:49 <psykotic> Syzygy-, by the way, have you tried to teach categorical thinking to people who already know haskell enough?
00:35:58 <wli> mgsloan: I suppose it could be quined.
00:36:36 <psykotic> Syzygy-, i was making the point the other way, by example, that experienced haskellers are probably better at thinking about naturality than a lot of non-specialist mathematicians :)
00:36:40 <psykotic> *the other day
00:36:55 <wli> I don't know Haskell very well. I'm a monad moron.
00:40:04 <dibblego> ?msg lambdabot Either a b -> a
00:40:04 <lambdabot> Not enough privileges
00:40:09 <dibblego> oops
00:40:15 <dibblego> .msg lambdabot ?hoogle Either a b -> a
00:40:18 <dibblego> cripes
00:40:27 * dibblego wipes brow
00:40:32 <psykotic> :t left
00:40:34 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
00:40:42 <sorear> dibblego: either id undefined
00:41:07 <dibblego> got it now, thanks :)
00:42:07 <dons> cute, psykotic
00:42:08 <oerjan> "either id undefined", sounds like Haskell poetry...
00:42:34 <psykotic> dons: what? where? :)
00:42:55 <dons> 'left' isn't seen here very often
00:43:15 <oerjan> :t left
00:43:17 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
00:43:22 <dons> :t right
00:43:24 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either d b) (Either d c)
00:43:27 <dons> @pl should support them
00:43:27 <lambdabot> should support them
00:43:55 <psykotic> @src ArrowChoice
00:43:55 <lambdabot> Source not found. The more you drive -- the dumber you get.
00:44:03 <oerjan> :t up
00:44:05 <lambdabot> Not in scope: `up'
00:44:09 <oerjan> :t down
00:44:10 <lambdabot> Not in scope: `down'
00:44:23 <dibblego> :t allaround
00:44:25 <lambdabot> Not in scope: `allaround'
00:44:39 <Syzygy-> Sorry, wli and psykotic - I was looking at another window for a few moments....
00:45:09 <Syzygy-> psykotic: Sounds like a book I'm going to want to read.
00:45:27 <Syzygy-> wli: diophantic systems are HARD though.
00:45:43 <psykotic> Syzygy-, it's actually fairly terrible due to the translation from japanese to english. but i thought the idea was nice. it's a very, very old fashioned exposition.
00:45:52 <Syzygy-> psykotic: I haven't done -that- much teaching, and haskellites are hard to come by around my parts.
00:45:53 <psykotic> Syzygy-, very riemann :)
00:45:56 <Syzygy-> I seem to be the only one. :P
00:46:00 <ejt> morning
00:46:25 <ejt> has anyone got any reccomendations for a balance tree like structure that has fast merges ?
00:46:43 <RyanT5000> sooo... uh... is it possible to serialize GADTs?
00:46:44 <psykotic> Syzygy-, if you're looking for interesting reads...
00:46:49 <vincenz> moin
00:46:51 <RyanT5000> i'm having a hell of a time figuring it out
00:46:54 <vincenz> dons: why the grrr?
00:47:03 <psykotic> Syzygy-, klein's on riemann's theory of algebraic functions and their integrals
00:47:06 <dons> vincenz: no ops on oasisbot :)
00:47:16 <vincenz> Oh
00:47:20 <Syzygy-> psykotic: Yech. Integrals!?
00:47:29 <psykotic> Syzygy-, cohomology! :)
00:47:34 <Syzygy-> Ah.
00:47:38 <Syzygy-> But still. Integrals!?
00:47:44 <psykotic> well, that's how cohomology was invented :)
00:47:52 <psykotic> if you integrate around a circle, etc
00:48:11 <psykotic> if you haven't seen a lot of that classical stuff, it's very nice
00:48:12 <Syzygy-> I know. However, I'm doing my work in the Noetherian tradition rather ;)
00:48:29 * Syzygy- managed to avoid anything remotely similar to calculus / analysis for his entire study.
00:48:31 <psykotic> right, it's not explained anymore, it's in the garbage bin of history.
00:48:32 * psykotic sobs
00:48:48 <psykotic> actually this stuff is still seen in algebraic geometry, kinda
00:49:07 <Syzygy-> psykotic: I know about the history of my field. I'm just not particularily interested in the bits and pieces that don't translate immediately to pretty-pretty algebraic structures.
00:49:34 <Syzygy-> And I know that the de Rham-, sheaf- and other geometric cohomology theories -- basically anywhere where cohomology is more natural than homology -- have their origin in this kind of ideas.
00:49:52 <psykotic> Syzygy-, have you read dieudonne's history of algebraic topology?
00:49:57 <Syzygy-> Nope.
00:50:01 <psykotic> oh man, you'd love that, i think
00:50:05 <Syzygy-> I haven't read very much of the Large Writers at all.
00:50:06 <Syzygy-> Alas.
00:50:31 <psykotic> you should check that one out. it also gets into fancy, recent developments
00:50:49 <Syzygy-> Yeah.
00:50:49 <psykotic> and it very directly relates classical ideas of riemann and poincare to their modern developments
00:50:59 <Syzygy-> Do you have a reference for me?
00:51:03 <psykotic> hang on
00:51:22 <psykotic> Dieudonné, Jean, "A history of algebraic and differential topology. 1900--1960", Birkhäuser Boston, Inc.
00:51:42 <Syzygy-> Thanks.
00:52:05 <psykotic> i also like his history of functional analysis, but given your preferences... :)
00:52:05 <Syzygy-> Oooooh. We have three copies here at the library.
00:52:26 <Syzygy-> psykotic: I actually Really Liked functional analysis. It was linear algebra on 'shrooms. :)
00:52:38 <Syzygy-> At least the way I learned it.
00:52:40 <psykotic> that's also where grothendieck got started.
00:52:44 <psykotic> nuclear spaces, etc
00:53:05 <Syzygy-> Differential geometry on the other hand was taught without mentioning manifolds, and while ignoring completely any algebra that might be available. I dropped that course twice.
00:53:42 <psykotic> it would be a shame to drag in too much algebraic machinery for a first course in that
00:53:46 <wli> Large coproducts seem to run slow in ghc.
00:54:06 <Syzygy-> psykotic: If it had used the algebraic machinery, I would have learned something from it.
00:54:10 <psykotic> although it seems silly to not use the notion of manifold unless you're trying to do an explicitly historical/classical exposition
00:54:11 <wli> 60.49user 0.99system 1:04.93elapsed 94%CPU (0avgtext+0avgdata 0maxresident)k
00:54:11 <wli> 0inputs+0outputs (60major+153001minor)pagefaults 0swaps
00:54:41 <psykotic> Syzygy-, there's a (terrible) book by do carmo, differential geometry of curves and surfaces, which not only doesn't mention manifolds, but screws up his definition of his sort of replacement.
00:54:48 <Syzygy-> Hehehe
00:54:51 <psykotic> Syzygy-, basically the maps go in the wrong direction, if i remember correctly, for the coordinate charts.
00:54:54 <psykotic> it's a mess.
00:54:55 <RyanT5000> if i have some Monad m, and i have m (Maybe a), is there a way to cleanly use that as if it were a single monad?
00:54:57 <Syzygy-> We did it from a horrible dover book by Kreyszig.
00:55:07 <RyanT5000> instead of having to manually deal with the nesting
00:55:13 <Syzygy-> Which is weird, since the functional analysis was lovely - and also based on a book by Kreyszig.
00:55:22 <RyanT5000> (does MTL do this?)
00:55:56 <masak> dons: I get an error message when doing @google on #bioclipse
00:56:16 <masak> "Plugin `search' failed with: IRCRaised thread killed"
00:56:24 <dons> ?google haskell
00:56:26 <lambdabot> http://www.haskell.org/
00:56:26 <lambdabot> Title: Haskell - HaskellWiki
00:56:30 <dons> can you try aggain?
00:56:34 <dons> maybe the network just timed out
00:56:47 <masak> trying again
00:57:04 <masak> now it worked :)
00:57:16 <dons> temporary network silliness :)
00:57:45 <mgsloan> this is perhaps on topic - I just wrote a thingamabob to figure out the winding number of a point in a piecewise path
00:57:50 <mgsloan> efficiently too
00:58:09 <mgsloan> though sadly C++, so it took ~100 lines
00:59:01 <psykotic> RyanT5000, if you had a monad transformer, you could do something like that. but not with just a monad (i think).
00:59:03 <mgsloan> I'd probably benefit from a background in topology in this
00:59:10 <Saizan> RyanT5000: that's like MaybeT m but without the newtype, but you can't define an instance Monad m => Monad (\a -> m (Maybe a))
00:59:19 <mgsloan> (working on booleans for two-dimensional regions)
00:59:38 <Saizan> uhm
01:00:05 <Saizan> is there an extension to use partially applyied type synonyms in an instance head?
01:00:21 <wli> mgsloan: I don't even know what a winding number of a point in a piecewise path is.
01:00:40 <psykotic> wli: you just count the number of net times the path winds around a point.
01:00:48 <sorear> Saizan: No, and it's probably not even possible.
01:00:55 <wli> psykotic: That sounds tricky.
01:01:02 <psykotic> wli: there's a nice theorem for it.
01:01:26 <sorear> Saizan: Higher order unification (with lambdas) is undecidable.
01:01:32 <mgsloan> yeah, basically you just cast a ray and sum the signs of the derivatives
01:01:32 <Syzygy-> You just integrate 1/(z-p) around the path, and looks at the result. :)
01:01:36 <mgsloan> or that :P
01:01:38 <psykotic> right
01:01:43 <psykotic> it'll be 2pi * the winding number
01:01:44 <Saizan> sorear: heh, supposed so
01:01:50 <sorear> We don't know if it applies in this case, though.
01:02:19 <psykotic> probably i forgot an i
01:02:29 <Syzygy-> psykotic: Yeah, I think you did.
01:02:32 <mgsloan> yyeah
01:02:42 <mgsloan> my uncle told me about that an hour or two ago
01:02:52 <mgsloan> well, 5 or 6 hours ago
01:02:54 <psykotic> for piecewise linear paths you don't need this, though
01:02:59 <mgsloan> not linear
01:03:00 <psykotic> you can just calculate the net angle directly
01:03:05 <mgsloan> piecewise bezier :P
01:03:07 <psykotic> ah
01:03:24 <mgsloan> well, actually it's something more exotic, but i won't go into that..
01:03:29 <blackdog> weird - i ported my app to ByteStrings and it actually got slower
01:03:38 <psykotic> in that case you could also just approximate it by a piecewise linear path between inflection points
01:03:42 <psykotic> which will give the same winding number
01:04:18 <mgsloan> hmm, I'm not sure if calculating inflection points is very fast or stable
01:04:32 <psykotic> true
01:04:36 <psykotic> a cubic bezier can actually have cusps
01:04:40 <mgsloan> yep
01:05:32 <mgsloan> my strategy is first to check the bounding box, and see if the point is behind it, or in it
01:05:52 <mgsloan> if it's behind, it checks the initial point, and final point, and if those are on opposite sides, we have a winding inc/dec
01:05:53 <psykotic> you could also use the theorem syzygy mentioned. you can calculate the integral in closed form, due to its being a polynomial curve.
01:06:15 <psykotic> basically 1/(z-p) will be integrable in closed form since it breaks up via partial fractions, which can then be integrated separately
01:06:23 <mgsloan> if it's inside it uses a previously created roots algorithm
01:07:03 <mgsloan> hmm
01:07:16 <Syzygy-> psykotic: See? There still is some intuition for analysis left. Deeep, deeeep inside.
01:07:17 <mgsloan> could be handy for the inside-bbox case
01:07:31 <Syzygy-> mgsloan: The theorem holds without case checking.
01:07:39 <Syzygy-> If the point isn't enclosed by the curve, the integral vanishes.
01:07:45 <mgsloan> of course, but i need efficiency :P
01:07:50 <Syzygy-> Bah!
01:07:59 <mgsloan> that's why this is C++!
01:08:10 <mgsloan> if I wanted theoretical sweetness I'd be writing it in haskell :)
01:08:18 <Syzygy-> Precalculate the closed form of the integral from your bezier coefficients. Then you just need to insert the point in the end.
01:08:22 <Syzygy-> :)
01:09:17 <Syzygy-> mgsloan: I was wondering about that, actually....
01:09:23 <mgsloan> hmm, that's a good idea.  Too bad I don't need a huge volume of winding checks.  I wonder if anyone's ever drawn pixels like that.
01:09:35 <|Steve|> 1/(z-p), integrated with respect to what?
01:09:42 <psykotic> steve: z is a function of t
01:09:47 <psykotic> it's a closed curve
01:09:56 <psykotic> it's sloppy notation :)
01:09:59 <|Steve|> Oh, I see. I didn't read far enough back. Doing a path integral?
01:10:07 <Syzygy-> |Steve|: Exactly.
01:10:11 <psykotic> yes. that is in the complex plane, by the way
01:10:20 <Syzygy-> \int_\gamma dt/(z-p) is what I was talking about.
01:10:38 <Syzygy-> Or ... at least I think it is.
01:10:59 <psykotic> you mean \int_\gamma dt/(\gamma(t) - p)
01:11:07 <psykotic> wait, heh
01:11:15 <psykotic> i guess you can just say z there since your domain of integration is \gamma
01:11:30 <psykotic> equivalently, \int_0^1 dt/(\gamma(t) - p)
01:12:31 <mgsloan> rest assured though, at some point I'd like to implement some geom stuff for haskell. maybe in half a year or so...
01:12:45 <Syzygy-> psykotic: Exactly.
01:12:51 <Syzygy-> mgsloan: Looking forward to that.
01:14:25 <mgsloan> yeah, me too :) though don't expect too much - I don't have much formal experience (haven't even applied to any colleges yet :P )
01:14:48 <mgsloan> It'll probably be more like a dedicated 2d lib
01:15:31 <RyanT5000> how does -fallow-undecidable-instances choose between instances? does it use a "more specific" kind of criterion?
01:15:35 <RyanT5000> or does it just kind of pick at random?
01:15:42 <wli> Okay, I'm further along on terminfo
01:16:09 <mgsloan> perhaps it's best that way, though, as I think haskell needs 2d prims that are used throughout
01:16:25 <mgsloan> (and for that, they must be simple)
01:16:27 <wli> mgsloan: What do you mean by "2D prims"?
01:16:42 <mgsloan> points, matrices, rectangles, that sort of thing
01:17:30 <mgsloan> a separate lib would implement more in depth geometric objects
01:17:30 <wli> mgsloan: Well, what would you do with them?
01:17:50 <mgsloan> well, use them!
01:19:13 <wli> FWIW solving integer linear equations is meaningful for constraints arising in various contexts (logic language interpreters if nothing else)... I don't know how 2D things fit into graphics/etc. unless they're very sophisticated.
01:19:13 <mgsloan> for example, xmonad could certainly find uses for them throughout
01:20:04 <mgsloan> yeah, I know some people who are very involved in constraints
01:20:06 <wli> I may be wrong about sophistication then.
01:21:02 <Saizan> RyanT5000: it just kills ghc if your instances are truly undecidable afaiu, -fallow-overlapping-instances chooses the more specific one
01:21:28 <RyanT5000> Saizan: thanks
01:21:42 <wli> (StringCapSetForeground,"\ESC[3%?%p1%{1}%=%t4%e%p1%{3}%=%t6%e%p1%{4}%=%t1%e%p1%{6}%=%t3%e%p1%d%;m")
01:21:47 <wli> wtf is that?
01:30:14 <wli> Okay, terminfo manpage says it's a fscking language.
01:30:53 <Igloo> dons: http://community.haskell.org/admin/project_request.html
01:30:54 <lambdabot> Title: Project Request
01:31:22 <wli> "It is possible to form else-if's a la Algol 68: %? c1 %t b1 %e c2 %t b2 %e c3 %t b3 %e c4 %t b4 %e %; where ci are conditions, bi are bodies."
01:32:49 <opqdonut> lookup True [(c,b),...] -- :)
01:32:54 * osfameron squees at zippers
01:33:40 <dons> Igloo: do you think it should be linked from the front page?
01:33:49 <dons> 'Need an account? Sign up here'
01:34:40 <Igloo> dons: We need to write a front page  :-)
01:34:45 <Igloo> And other doc
01:34:46 <Igloo> s
01:36:22 <wli> dons/Igloo: Is there something like a "we wish someone would do this" page?
01:36:56 <Igloo> wli: Do you mean "I wish someone would write this library"?
01:37:12 <wli> Igloo: Yes.
01:37:18 <Igloo> No
01:37:40 <doserj> http://www.haskell.org/haskellwiki/Wanted_libraries could use some work
01:37:41 <lambdabot> Title: Wanted libraries - HaskellWiki
01:38:12 * Igloo is dubious about the usefulness of such a page. People generally write libraries because they want to use them, not because someone else wanted to use them a year ago
01:38:22 <dons> yeah, doesn't seem to be working
01:38:32 <dons> individuals keeping a private list of ideas seems to be more useful
01:38:42 <dons> i had 'window manager' on my list for about 4 years
01:39:01 <dons> the main issue is that people propose infeasibly large tasks
01:39:05 <dons> when you need small ones.
01:39:09 <blackdog> Write me a pony.
01:39:23 <dons> see. like that.
01:39:32 <blackdog> no, seriously. I want a pony. :)
01:40:07 <dons> oh, ok then. put it on the hackathon todo list
01:40:21 <dons> given enough oktoberfest beer, we just might pull it off
01:40:22 <Igloo> And then come to the Hackathon and do it  :-)
01:40:49 * therp wonders how we should check in a pony into darcs?
01:41:33 <Igloo> Carefully.
01:41:49 * wli is getting closer to vaguely functional termcap.
01:42:01 <wli> Er, rather, terminfo.
01:43:08 <desp> "foldl is like foldl, but strict in the accumulator. Though actually foldl is also strict in the accumulator."
01:43:13 * desp groans
01:43:30 <wli> There's something a bit odd going on with these string capabilities. They're basically in an odd programming language that probably wants translation to something in terms of a Haskell data structure but maybe more functional in character.
01:44:00 <wli> It's basically a sort of imperative stack language.
01:44:18 <dons> desp hmm?
01:44:22 <dons> ?src foldl
01:44:22 <lambdabot> foldl f z xs = lgo z xs
01:44:22 <lambdabot>     where lgo z []     =  z
01:44:22 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
01:44:24 <dons> ?src foldl'
01:44:24 <lambdabot> foldl' f a []     = a
01:44:24 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
01:44:33 <dons> foldl' is only partially strict in its accumulator
01:44:38 <desp> ?src Data.ByteString.foldl'
01:44:39 <lambdabot> Source not found. Do you think like you type?
01:44:46 <blackdog> Igloo: Freiburg's a little far for me, alas.
01:44:56 <desp> dons: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-ByteString.html#v%3Afoldl%27
01:44:58 <lambdabot> http://tinyurl.com/wn5rt
01:45:05 <dons> desp, oh yes. for bytestrings :)
01:45:26 <desp> dons: that comment ought to be taken behind the bike shed and shot :)
01:45:41 <dons> its all strict baby
01:45:46 <dons> foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
01:45:46 <dons> foldl' = foldl
01:45:50 <desp> dons: especially since the missing ' makes it extra funny
01:46:03 <dons> ah yes, the typo
01:46:05 <dons> well spotted
01:46:20 <desp> dons: I'd just say that foldl' is an alias for foldl
01:46:27 <dons> fixed in darcs
01:46:34 <desp> ty :)
01:46:52 <dons> -- | 'foldl\'' is an alias for 'foldl', for strict ByteStrings.
01:46:52 <dons> foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
01:46:52 <dons> foldl' = foldl
01:47:01 <desp> yay
01:47:07 <dons> probably shouldn't bother providing it though.
01:47:34 <blackdog> ... why not?
01:47:38 * blackdog is using it right now
01:47:42 <desp> dons: how should I submit a patch providing KMP search to fps?
01:49:31 <dons> desp, oh. ok. so you know about the findSubstring function?
01:49:43 <dons> which already provides a poor KMP search for strict bytestrings
01:49:51 <desp> dons: yeah, you said it was quite poor
01:50:00 <dons> so what I suggest is to entirely reimplement it, benchmark that, and also do one for lazy bytestrings
01:50:07 <dons> then darcs send that, along with its QuickCheck properties
01:50:13 <desp> yes, I'm about to benchmark that. ok.
01:50:17 <dons> and patch against the 'bytestring' repo on darcs.haskell.org/bytestring
01:50:25 <desp> aha
01:50:27 <dons> yes, thanks for doing this.
01:50:36 <dons> you might even want to benchmark against kmp.c
01:50:39 <dons> ?go kmp.c
01:50:43 <lambdabot> http://barnyard.syr.edu/quickies/kmp.c
01:50:45 <dons> since we should be pretty damn close for a good impl
01:50:49 <blackdog> dons: fold on bytestrings is 97% of my runtime at the moment - any tips on speeding it up?
01:50:54 <desp> ok
01:50:57 <dons> write a manual recursion, blackdog ?
01:51:05 <dons> it could be hmm, not fusing
01:51:05 <blackdog> was hoping you wouldn't say that :)
01:51:08 <blackdog> oh well.
01:51:15 <dons> foldl f v (PS x s l) = inlinePerformIO $ withForeignPtr x $ \ptr ->
01:51:15 <dons>         lgo v (ptr `plusPtr` s) (ptr `plusPtr` (s+l))
01:51:15 <dons>     where
01:51:15 <dons>         STRICT3(lgo)
01:51:17 <dons>         lgo z p q | p == q    = return z
01:51:20 <dons>                   | otherwise = do c <- peek p
01:51:22 <dons>                                    lgo (f z c) (p `plusPtr` 1) q
01:51:25 <dons> try that, then specialise it for your use
01:51:33 <blackdog> ok, cheers
01:51:54 <dons> sounds like an interesting project, blackdog . i'd be happy to have a look
01:52:25 <dons> one issue in the current code is that we don't rewrite unfused foldls back to fast loops like the above
01:52:36 <dons> so its using array fusion loops, unfused, which would be a 2x hit
01:52:41 <blackdog> this is just me winding down at the moment - writing a fast target solver. it's pretty quick once it's read in the dictionary, but the thing's damn slow to build...
01:52:42 <dons> foldl f z = loopAcc . loopUp (foldEFL f) z
01:53:09 <blackdog> maybe it'd be faster to build it once then compress & serialise it.
01:53:09 <dons> is what you get, and if it doesn't fuse with anything, then it'll be slower than the low level loop above
01:53:13 <dons> yeah
01:53:17 <dons> that's a good idea
01:53:47 <blackdog> i'll hunt down that page you wrote on it
02:00:30 <wli> Okay, I've got the terminfo things assembled into a structure with discriminated unions and all that jazz.
02:00:52 <wli> http://holomorphy.com/~wli/Terminfo.lhs
02:01:05 <wli> http://holomorphy.com/~wli/TermCapDecls.hs
02:01:22 <wli> add .txt if the content type affair is bugging you
02:01:39 <wli> (http://holomorphy.com/~wli/Terminfo.lhs.txt and http://holomorphy.com/~wli/TermCapDecls.hs.txt)
02:02:56 <wli> The next step is to get the extended capability table parsed and dumped into there.
02:04:29 <wli> The step after that to get the string attributes parsed into something a mini-interpreter can handle.
02:13:57 <blackdog> you know you're doing something right (or very, very wrong) when you realise you need a list of prime numbers when doing a word puzzle
02:14:02 * blackdog hums happily
02:15:55 <wli> blackdog: What have you hit?
02:16:20 <blackdog> well, i want to represent strings more compactly
02:16:27 <blackdog> i don't care about ordering, so i was just sorting them
02:16:47 <blackdog> then it occurred to me that multiplication was commutative
02:17:15 <blackdog> so if i represent the letters from a to z by a prime, i can multiply them together and get a unique hash
02:17:16 <wli> blackdog: Are you referring to sets of strings?
02:17:30 <Syzygy-> blackdog: Did you ever look at Conway's FRACTRAN?
02:17:33 <blackdog> no, individual strings
02:17:44 <blackdog> No, I haven't heard of it.
02:17:57 <wli> blackdog: Yet it appears that you want to sort sets of strings, correct?
02:17:57 <Syzygy-> blackdog: He uses that primes trick to build a turing machine working with multiplying fractions onto an accumulator.
02:18:08 <blackdog> oh, that's cute
02:18:15 <Syzygy-> http://scienceblogs.com/goodmath/2006/10/prime_number_pathology_fractra.php
02:18:17 <lambdabot> Title: Good Math, Bad Math : Prime Number Pathology: Fractran, http://tinyurl.com/vxjge
02:18:19 <Syzygy-> That's a good overview
02:18:44 <blackdog> cheers, i'll check it out
02:18:56 <blackdog> wli: i may be missing something - where does sorting come into it?
02:19:15 <blackdog> i just want to make sure that strings that have the same letters (irrespective of order) hash to the same value
02:19:20 <wli> blackdog: Trie/Tree structures that achieve sorting.
02:20:06 <wli> blackdog: Irrespective of order of appearance in the string is different.
02:20:32 <blackdog> yeah. sorry, i may not have explained myself well earlier.
02:21:49 <mgsloan> sounds like compressing sets of chars
02:22:04 <wli> blackdog: My first thought is Data.Array.Array or Data.Map.Map of counts of individual characters if they're non-unicode.
02:22:45 <wli> blackdog: Data.Map would actually work for unicode.
02:23:17 <wli> blackdog: I'd be very hesitant to form giant arbitrary-precision numbers.
02:23:28 <blackdog> well, i had a Map of String -> [String]
02:23:56 <wli> I'd use Data.Map Char Int to represent the multiset.
02:24:21 <blackdog> oh, i see. one map for each string, then?
02:25:05 <blackdog> but then i need to index based on that - can i use a Map as a key into another Map?
02:25:24 <hpaste>  RyanT5000 pasted "Is there any way to serialize/deserialize this?" at http://hpaste.org/1957
02:25:48 <Syzygy-> blackdog: This represent-strings-as-HUGE-numbers scheme of yours is something that ends up being very pretty in theory and horrible in practice.
02:25:53 <wli> blackdog: I think so yes.
02:26:03 <blackdog> swanky. :)
02:26:06 <RyanT5000> in re that post, i suppose i'm trying to finesse haskell into doing a typecheck at runtime
02:26:09 <Saizan> ?instances Ord
02:26:10 <lambdabot> (), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
02:26:22 <RyanT5000> so it may not be possible; but i'd love it if someone could take a look
02:26:26 <Saizan> ?instances-importing Data.Map Ord
02:26:26 <mgsloan> would be fun to stash the whole state of some game or something in a single Integer :)
02:26:27 <lambdabot> (), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Map k v, Maybe a, Ordering, Product a, Sum a, [a]
02:26:36 <blackdog> ok, i'll try my insane prime number version first, and if it blows up in my face, i'll try that approach :)
02:26:45 <Syzygy-> blackdog: It will. But go ahead.
02:27:16 <Syzygy-> > 'z'-'a'
02:27:16 <lambdabot>   add an instance declaration for (Num Char)
02:27:17 <lambdabot>     In the expression: 'z' - 'a'...
02:27:24 <dons> blackdog: you want some prime number generators, btw?
02:27:27 <Syzygy-> > toInteger 'z'-toInteger 'a'
02:27:28 <lambdabot>   add an instance declaration for (Integral Char)
02:27:30 <dons> i got a sample bag of good ones
02:27:35 <blackdog> dons: it's ok, i'm using the sieve
02:27:38 <blackdog> i only need 26 :)
02:27:38 <Syzygy-> > (toInteger 'z')-(toInteger 'a')
02:27:39 <lambdabot>   add an instance declaration for (Integral Char)
02:27:41 <dons> ah ok
02:27:49 <dons> cause i got some fine prime warez..
02:27:54 <Syzygy-> > (fromEnum 'z')-( fromEnum 'a')
02:27:55 <lambdabot>  25
02:27:56 <wli> import Data.Map as Map ; Map.toList $ foldr (flip (Data.Map.insertWith' (+)) 1) Map.empty "blackdog: I'd be very hesitant to form giant arbitrary-precision numbers."
02:27:57 <blackdog> you can hook me up? :)
02:27:57 <Syzygy-> There we go.
02:28:04 <mgsloan> > (ord 'z') - (ord 'a')
02:28:06 <lambdabot>  25
02:28:20 <Syzygy-> > primes = nubBy (((>1).).gcd) [2..] in primes !! 26
02:28:20 <lambdabot>  Parse error
02:28:29 <Syzygy-> > let primes = nubBy (((>1).).gcd) [2..] in primes !! 26
02:28:30 <lambdabot>  103
02:28:58 <mgsloan> > nubBy (((>1).).gcd) [2..]
02:29:00 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
02:29:19 <wli> http://holomorphy.com/~wli/Runciman.lhs
02:30:02 <wli> That should be relatively swift.
02:30:36 <mgsloan> I must be getting tired.  That tinyurl link in the title is starting to look like "tinyurl.com/RRavoy" instead of "tinyurl.com/22avoy"
02:35:58 <RyanT5000> anyone have thoughts on serializing that GADT?
02:36:22 <RyanT5000> i can figure out how to serialize it in what i think is an unambiguous way, but i can't figure out how to deserialize it
02:36:53 <wli> RyanT5000: Looks to me like you've got to have an MVar outside it.
02:37:09 <RyanT5000> wli: an MVar? how would that help?
02:37:43 <wli> RyanT5000: I'm not sure why it'd be mutable, but they can basically act as locks.
02:38:03 <RyanT5000> wli: sorry, i'm totally confused; i'm not talking about anything mutable
02:38:19 <RyanT5000> i'm just talking about a GADT that i can't figure out how to serialize
02:38:24 <RyanT5000> (deserialize)
02:38:29 <RyanT5000> because of type errors
02:38:40 <wli> RyanT5000: If there's nothing mutable why would you have to serialize it
02:38:50 <RyanT5000> because i need to ship it across the network
02:40:01 <Saizan> the problem is with t, right?
02:40:18 <RyanT5000> well the problem is with the last 3 (out of 4) cases
02:41:27 <RyanT5000> let me paste up my serialization routine
02:41:35 <RyanT5000> so you can see what i'm trying to deserialize from
02:41:43 <Saizan> yeah
02:42:23 <hpaste>  RyanT5000 annotated "Is there any way to serialize/deserialize this?" with "serialization routine" at http://hpaste.org/1957#a1
02:43:08 <RyanT5000> BigInt is just a wrapped Integer that serializes differently
02:43:32 <Saizan> well, that serialization forgets about (t,env)
02:43:41 <Saizan> doesn't it?
02:43:48 <RyanT5000> well that's a phantom type anyway
02:44:09 <RyanT5000> so there's no real way it *can* serialize that, right?
02:44:10 <wli> blackdog: Are you looking for anagrams?
02:44:31 <xerox> Maybe you need Typeable and to serialize a TypeRep along with the data?
02:44:42 <desp> dons: poke
02:44:59 <Saizan> RyanT5000: you need a representation of it as well if you want to reconstruct the original phatom type deserializing
02:45:48 <Saizan> and to go from value to type you need a typeclass
02:46:02 <desp> dons: have you considered making both lazy and strict ByteStrings instances of some type class that'd offer the common operations?
02:46:05 <RyanT5000> Saizan: how would i do that?
02:46:11 <desp> dons: or is that a stupid idea?
02:46:18 <Saizan> ?go functional pearl implicit configurations
02:46:20 <lambdabot> http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
02:46:54 <Saizan> RyanT5000: i can find you a very related paper
02:47:05 <RyanT5000> Saizan: cool
02:47:11 <RyanT5000> i thought typeclasses would be involved somehow
02:47:15 <RyanT5000> but i couldn't figure out how to do it
02:47:44 <Saizan> http://www.cs.rutgers.edu/~ccshan/prepose/p1214-kiselyov.pdf
02:48:09 <RyanT5000> thanks
02:50:26 <Saizan> what do you actually use for t?
02:50:43 <RyanT5000> t is basically in there to typecheck the language
02:51:38 <Saizan> yes, but do you instance it with anything?
02:53:34 <RyanT5000> well, at some point i had a Literal in there as well (it will need to come back in some form), and i could do something like (Lambda (App (App (Lit (==)) Top) (Pop Top)))
02:53:51 <RyanT5000> which is a function that compares its first argument to the first thing in the environment outside the Lambda
02:53:54 <RyanT5000> so if you ran
02:54:07 <RyanT5000> eval (that) (5, ()) 5
02:54:10 <RyanT5000> you would get True
02:56:01 <dons> desp, the type class is too big
02:57:27 <hpaste>  RyanT5000 annotated "Is there any way to serialize/deserialize this?" with "all the interesting bits so far" at http://hpaste.org/1957#a2
02:58:14 <opqdonut> does ghc work on arm?
02:59:09 <Igloo> Debian has it unregisterised on Arm Linux
02:59:22 <Botje> we're working on leg, for now
02:59:30 <opqdonut> Igloo: ok
03:25:38 <dons> haskell quiz time!
03:25:45 <dons> who can name this function:
03:25:47 <dons>     (. (,)) . (.)
03:26:01 <nominolo> misaligned boobies!
03:26:13 <dons> no no. its a prelude function...
03:26:17 <matthew-_> curry
03:26:21 * matthew-_ claims the prize
03:26:23 <dons> matthew-_: wins.
03:26:23 <nominolo> @unpl (. (,)) . (.)
03:26:23 <lambdabot> (\ g j d -> g (((,)) j d))
03:26:34 <matthew-_> next!
03:26:50 <profmakx> we should collect these quiz-questions
03:26:52 <dons> ok, this one:
03:26:53 <dons>     (<*> snd) . (<$> fst)
03:26:54 * earthy always misremembers curry and uncurry
03:27:05 <|Steve|> What are <*> and <$>?
03:27:08 <matthew-_> quite
03:27:12 <dons> Control.Applicative
03:27:14 <nominolo> Applicative stuyy
03:27:19 <nominolo> *stuf
03:27:25 * matthew-_ guesses (&&&)
03:27:32 <dons> nope.
03:27:36 <Lemmih> uncurry?
03:27:41 <dons> yes!
03:27:43 <dons> Lemmih wins
03:27:49 <matthew-_> I'm going to have to read that library now
03:28:01 <nominolo> matthew-_: read the paper
03:28:09 <nominolo> it's very nice
03:28:21 <matthew-_> nominolo: well, given this is haskell, I'm sure the former will require the latter!
03:28:43 <nominolo> yes, but it's worth it
03:29:09 <earthy> hm. that's a nasty one
03:29:41 <earthy> \f -> f <$> fst <*> snd    is clearer, in my mind
03:29:55 <dons> yeah, leaving the 'f' is much clearer
03:30:00 <nominolo> earthy: it was a quiz!
03:30:03 <dons> uncurry f = f <$> fst <*> snd
03:30:06 <earthy> true :)
03:30:18 <profmakx> sort of obfuscating haskell
03:30:24 <earthy> IOHCC? :)
03:31:10 <earthy> what I've found lately is that programming Haskell *really* depends on finding the right datastructure to represent the stuff you want to deal with
03:31:18 <earthy> once you have that it's easy cakes
03:31:23 <earthy> but until that point... ouch. :)
03:31:31 <osfameron> sometimes pattern matching obfuscates
03:31:40 <osfameron> like in Okasaki's code for Red-Black tree rotations
03:31:50 <nominolo> earthy: a formal approach help a lot
03:31:51 <osfameron> there are 4 cases, done with very dense pattern matches
03:32:17 <earthy> nominolo: yeah, but even then.
03:32:21 <nominolo> earthy: see hughes' pretty printer paper for a (long) example
03:32:26 <osfameron> but really the intent would be more clearly expressed as Black->Red->Red down any combination of paths instead
03:32:27 * earthy knows
03:32:48 * earthy thought he'd type up a HTML gallery generator in a couple of hours
03:32:51 <nominolo> earthy: would it be easier in other languages?
03:33:12 <earthy> however, devising a good datastructure to capture all the detail that you *want* to capture... that's tricky. :)
03:33:45 <earthy> (Data.Tree helps, ofcourse, but what to put in it? :))
03:34:01 * earthy must've redesigned the node datatype at least 5 tiems already :)
03:34:27 <nominolo> earthy: start by trying to define some features, find primitives, and specify them
03:34:40 <nominolo> oh
03:35:04 <matthew-_> yeah, I find that data structures tend to grow over time
03:35:14 <quicksilver> like weeds
03:35:19 <matthew-_> which is fine, until you hit something that clearly needs to be "cross" structure
03:35:31 <matthew-_> a "creeper" !
03:36:21 <earthy> matthew-: exactly
03:36:37 <nominolo> well, in haskell you start redigning, in other languages you start to hack ..
03:36:47 <earthy> complicated data, the bane of neat code. :)
03:36:51 <|Steve|> How do you deal with the immutability of data structures? Do you just give up and use the IO monad?
03:37:09 <nominolo> |Steve|: depends
03:37:18 <nominolo> |Steve|: what's the problem?
03:37:18 <fnord123> s/redigning/redesigning/ ?
03:37:19 <matthew-_> |Steve|: nope. The only time when MVars come into it is when it's cross-threads
03:37:36 <nominolo> fnord123: uh, yeah
03:37:56 <matthew-_> if there's no inter-thread communication going on, there's normally not much need to use IO for data
03:37:57 <matthew-_> imho
03:38:03 <|Steve|> I don't have a problem in particular.
03:38:06 <earthy> Steve: usually you just generate a new datastructure from the old
03:38:25 <|Steve|> I just don't want my insert operation to take linear time.
03:38:41 <earthy> and trust the compiler to not keep old stuff around too long
03:38:46 <earthy> Steve: then use a zipper...
03:39:01 <earthy> or an array
03:39:25 <nominolo> |Steve|: Seq has O(1) access to both ends
03:39:28 <|Steve|> It's not an issue of keeping old stuff around, it's that you can't change the structure.
03:39:40 <|Steve|> What if I want to change the middle element?
03:39:43 <nominolo> |Steve|: and O(log n) concat
03:40:01 <earthy> steve: what would that cost in a linked list in C?
03:40:03 <nominolo> |Steve|: think differently ;)
03:40:14 <|Steve|> earthy: I don't use a linked list in C in most cases.
03:40:21 <nominolo> |Steve|: or, as suggested, use a zipper
03:40:32 <matthew-_> |Steve|: there are also arrays in haskell with O(1) lookups
03:40:37 <|Steve|> Who said I wanted it to be an array like structure though?
03:41:01 <nominolo> |Steve|: well, you didn't say anything.  so we have to assume
03:41:03 <|Steve|> What if I want to run Ford-Folkersen on a graph.
03:41:13 <hpaste>  wli pasted "anagrams for blackdog" at http://hpaste.org/1958
03:41:18 <earthy> Steve: if you have a complex structure you're doing to have to navigate to the point where you want to put the new element *anyway*
03:41:58 <earthy> with purity and laziness, the new structure can be generated during that navigation and the parts you haven't touched can be shared
03:41:58 <|Steve|> earthy: So?
03:42:16 <|Steve|> I see.
03:42:22 <|Steve|> But what if I don't have to?
03:42:36 <earthy> don't have to what?
03:42:47 <|Steve|> What if I don't have to navigate to where I want to change it.
03:42:52 <gour> @where hackport
03:42:52 <lambdabot> http://haskell.org/~gentoo/hackport/
03:43:09 <earthy> then you basically have a block of memory with pointers into it
03:43:15 <|Steve|> Right.
03:43:20 <earthy> or even a structure with pointers into it
03:43:26 <|Steve|> Right.
03:43:33 <matthew-_> |Steve|: this kind of thing is always much easier to discuss with a concrete example
03:43:35 <earthy> the first is available in haskell
03:43:39 <earthy> the second is just a zipper
03:44:00 <earthy> (each derivation adds another pointer)
03:44:09 <Adamant> does any Gentoo user know when 6.6.1 will make it into Portage? or is it already in some overlay?
03:44:10 <|Steve|> matthew-_: Fair enough, how about a DP algorithm?
03:44:56 <|Steve|> earthy: But doesn't that adding of layers destroy your access complexity completely?
03:45:45 <gour> Adamant: afaik, it's there (i moved to arch two days ago), but check on #gentoo-haskell
03:46:01 <earthy> steve: nope.
03:46:12 <|Steve|> Why not?
03:46:42 <Adamant> gour, thanks, I'll try syncing and reemerging
03:46:43 <dcoutts> Adamant: yes, it's in portage now with ~arch keyword
03:46:46 <earthy> because you have constant time access to the pointers and amortized identical access to the other parts
03:46:53 <Adamant> guh, fscking insomnia.
03:46:54 <earthy> +cost
03:47:08 <wli> Okay, De Bello Gallico these anagrams can handle in ghci; Don Quijote, OTOH...
03:47:29 <|Steve|> If I make n changes to my structure of size n and I have constant time lookup in nonpure languages. Then I have amortized O(n) lookup in my pure language.
03:47:55 <dcoutts> Adamant: but yes, there is a haskell overlay with 50 more haskell packages than the 50 in portage
03:48:06 <|Steve|> Worse, what if I make n^k changes to my structure? Now I have O(n^k) lookup instead of O(1).
03:48:13 <earthy> nope.
03:48:35 <earthy> because the internal links get updated as well
03:48:45 <earthy> you don't have to walk the changes
03:48:49 <RyanT5000> -fallow-overlapping-instances decides at compile-time, right?
03:49:02 <|Steve|> How do the internal links get changed? It's supposed to be a pure language.
03:49:12 <earthy> you make a new structure
03:49:20 <earthy> that contains the changed links
03:49:20 <|Steve|> So that takes linear time.
03:49:24 <earthy> no :)
03:49:43 <earthy> that takes as much time as needed to navigate to the changepoint
03:49:43 * |Steve| is clearly just not getting it.
03:49:59 <int-e> |Steve|: you can reuse large parts of a tree
03:50:01 <earthy> all the rest can be freely shared, so need not be looked at
03:50:11 <int-e> |Steve|: when inserting or deleting elements
03:50:21 <|Steve|> But that's just it, what if I don't have a tree or something of this structure?
03:50:37 <|Steve|> What if it's a hashtable?
03:50:43 <jbauman> earthy: that's much more challenging for an arbitrary graph
03:50:51 <int-e> the purely functional data structures tend to be trees.
03:51:04 <jbauman> that's no help, then
03:51:05 <earthy> jbauman: true enough
03:51:11 <int-e> a hashtable will not support efficient updates with a pure interface
03:51:15 <earthy> challenging, but not impossible
03:51:25 <|Steve|> int-e: That seems like a severe limitation.
03:51:55 <int-e> in place updates are overrated, but yes it is a limitation. you can get around that with the ST and IO monads.
03:51:58 <earthy> ah, but you can always make impure interfaces as well
03:52:00 <osfameron> gosh, the wikipedia page on Zippers is terrible
03:52:02 <|Steve|> My data structure students had a project due a few days ago where they had to read in something like 800,000 data points and build a database to support lookup etc.
03:52:12 <RyanT5000> i don't know if you're interested, |Steve|, but there is a related solution; look up DiffArray
03:52:13 <earthy> that's easy
03:52:17 <ndm> > log 800000
03:52:18 <RyanT5000> it's impure, but has a pure interface
03:52:19 <lambdabot>  13.592367006650065
03:52:26 <|Steve|> Those that used a tree took hours and I killed them before they finished. Those that used a hashtable took a few minutes.
03:52:45 <ndm> |Steve|: 14 isn't a massive constant, did they use a binary tree, or a red black tree?
03:53:25 <Adamant> |Steve|, the best bit of advice I have ever gotten on programming was "forget all the fancy trees, just use a hashtable"
03:53:28 <|Steve|> RyanT5000: That seems to imply that the answer to my original question is give up and use the IO monad.
03:53:45 <quicksilver> Adamant: allow me to reverse that: forget all the fancy hashtables, just use a decent tree :)
03:53:46 <ndm> |Steve|: i marked a very similar assignment, those that did unbalanced treees failed, as did those who used a hash table of size 100 (or 11, in one case), but a nice red-black tree was just fine
03:53:47 <|Steve|> ndm: It was in java so whatever the TreeMap uses. My guess is red-black trees.
03:54:03 <RyanT5000> |Steve|: not necessarily, but it is one case in which the implementer *did* end up giving up
03:54:14 <ndm> |Steve|: Haskell is designed for this kind of thing, so i suspect Haskell will outperform TreeMap
03:54:14 <RyanT5000> it's all impure if you dig deep enough :)
03:54:37 <ndm> Adamant: can i rephrase that, "forget all the fancy data types, just use whatever suits your language best"
03:54:53 <Adamant> ndm, that's pretty much what the guy was saying. :)
03:54:53 <ndm> in most scripting language, that is a hash table, but in Haskell its not
03:54:56 <earthy> Haskell's Data.Map actually is implemented as a tree
03:55:00 <|Steve|> And the constant is closer to 20 there.
03:55:00 <Adamant> I agree
03:55:23 <Adamant> for the language he was talking about, hash tables made sense.
03:56:00 <ndm> i use them all the time when doing javascript work, and have never used them once when doing Haskell
03:56:02 <|Steve|> RyanT5000: And that depresses me about pure languages. They aren't because they can't be.
03:56:48 <ejt> I bet a haskell tree would run faster than a Java hash table ;)
03:56:58 <RyanT5000> |Steve|: well, the universe is stateful; c'est la vie
03:57:00 <ndm> |Steve|: was the hash table keyed on String's by any chance? in which case a Trie would probably woop both the hash table and binary tree, and is entirely pure
03:57:00 <wli> Hashtables suck anyway.
03:57:34 <wli> ndm: At which point you get into hash tries etc.
03:57:52 <earthy> the beauty of Haskell is that it very clearly specifies where the impurities are
03:58:09 <earthy> and enforces strict hygiene around them
03:58:34 <|Steve|> ndm: Yes, it was, and you are, of course, correct about a Trie.
03:58:42 <RyanT5000> |Steve|: with languages like haskell we're just trying to carve out a little enclave of purity, because it's nicer to work with
03:58:53 <RyanT5000> (better for proving things, etc.)
03:59:01 <jbauman> RyanT5000, except when it isn't nicer to work with :)
03:59:12 <RyanT5000> jbauman: right :P
03:59:14 <ndm> i think that one day someone will figure out how to do a nice pure Hash table
03:59:18 <earthy> but then we drop down to stateful computation
03:59:25 <earthy> that Haskell also provides nice tools for
03:59:25 <ndm> its not been done yet, but it will be
03:59:41 <wli> I don't know. I'm finding that monads regiment statefulness in such a fashion that it's quite good for formal verification purposes.
03:59:45 <opqdonut> yeah, besides being a beautiful functional programming language, haskell is a darn goo imperative one
03:59:59 <opqdonut> *good
04:00:05 <wli> Pure hashtables aren't to be bothered with; use the MArray garbage etc.
04:00:07 <|Steve|> I find that everyone talks about wrapping up the stateful stuff in a monad, but that doesn't really happen given that main is in the IO monad so everything would seem to be.
04:00:36 <earthy> ah. ;)
04:00:39 <earthy> almost. :)
04:00:58 <quicksilver> |Steve|: not really sure what you mean about 'doesn't really happen'
04:01:03 <quicksilver> |Steve|: it does...
04:01:09 <opqdonut> |Steve|: the good thing about monads is that you can escape them with for example liftM
04:01:15 <opqdonut> pure operations on monadic values
04:01:26 <earthy> it's just that not all calculations need to be concerned with side-effects
04:01:47 <RyanT5000> |Steve|: a function isn't considered "in" IO if it doesn't take or return IO ;)
04:01:50 <earthy> and those that aren't are clearly marked, and are ensured not to suffer from them
04:02:08 <earthy> (barring other processes mucking around in the haskell program's memory space, ofcourse)
04:02:24 <|Steve|> quicksilver: Remind me where I said "doesn't really happen."
04:02:28 <wli> Well, the point isn't to "escape" monads, it's to work with them in an effective fashion.
04:02:37 <|Steve|> I scrolled up a bit, but I seem to have already forgotten what I said. =)
04:02:58 <opqdonut> wli: yes, of course
04:03:18 <Saizan> your previous sentence, |Steve!
04:03:28 <opqdonut> but escape in the sense that a haskell program have parts that are not operations in the IO Monad
04:03:33 <|Steve|> Haha, oh that one. =)
04:03:58 <quicksilver> :)
04:04:13 <|Steve|> Haskell's use of encapsulate doesn't coincide with my understanding of the word.
04:05:02 <wli> |Steve|: How good are you with monad transformers?
04:05:07 <|Steve|> Not at all.
04:05:11 <|Steve|> I know nothing about them.
04:05:27 <earthy> you need not
04:05:29 <wli> |Steve|: Okay, the "big deal" in this area appears to be them.
04:06:32 <pejo> Steve, what is your understanding of the word?
04:06:47 <|Steve|> To keep separate.
04:07:20 <pejo> Steve, and what is the Haskell use, from your point of view?
04:09:01 <|Steve|> In terms of other languages, such as OO languages, one would encapsulate some related operations into a class, for example. That class shouldn't be making calls back out or you have a layering violation (I'm generalizing here). So basically, the encapsulated part is self-contained. In Haskell, you start out in the IO monad with main and go from there. There is no encapsulation in that sense.
04:09:24 <opqdonut> yes, there is
04:09:27 <quicksilver> yes, there is
04:09:30 <|Steve|> Heh
04:09:31 <quicksilver> you don't make calls back out
04:09:32 <quicksilver> :)
04:09:38 <quicksilver> your intuition is quite right
04:09:46 <quicksilver> it's good style to have most of your program 'pure'
04:09:53 <quicksilver> and that part doesn't "make calls back out" to the IO monad
04:09:54 <|Steve|> Right, you're stuck in the IO monad for the duration.
04:09:58 <Saizan> it's IO code that calls pure code, not the other way around :)
04:10:00 <|Steve|> There's no encapsulation of IO.
04:10:08 <quicksilver> there is complete encapsulation of IO
04:10:19 <|Steve|> Fine, that I can accept, but that isn't how it's described in what I've read.
04:10:19 <opqdonut> yes there is, you can have pure operations
04:10:27 <osfameron> It is true of all languages/paradigms that it is a good idea to have the core logic "pure" (hence MVC etc. in OO style coding)
04:10:46 <quicksilver> main = let a = pure_fun 42 in do {putStrLn "Cool program starting"; putStrLn $ "Result was "++ show a }
04:10:57 <quicksilver> |Steve|: ^^ see? pure_fun contains no IO
04:11:04 <opqdonut> yep
04:11:08 <quicksilver> so the IO is completely encapsulatied
04:11:22 <quicksilver> the type system *guarantees* that pure_fun can't do any IO
04:11:34 <ejt> |Steve| think of your program as a snow capped mountain - the snow is IO, non-snowy is pure
04:11:38 <opqdonut> just look at the type sig, if there is no IO something, it can't have side-effects
04:11:42 <quicksilver> so not only do you have encapsulation, you have encapsulation statically guaranteed by the compiler
04:11:49 <opqdonut> yep
04:11:53 <quicksilver> this is a much stronger encapsulation than most languages can attain
04:12:06 <|Steve|> But it's reverse encapsulation.
04:12:16 <opqdonut> how so?
04:12:17 <quicksilver> it only looks that way to you because your brain is inside out
04:12:19 <|Steve|> The pure code is encapsulated.
04:12:30 <|Steve|> Heh, no one has ever made that claim before.
04:12:31 <opqdonut> no, side-effects are encapsulated
04:12:44 <RyanT5000> i'm not sure encapsulation is directional
04:12:48 <earthy> steve: the encapsulation defines a barrier, right?
04:12:49 <pejo> Heh. "The sentence isn't reversed, you're reading it backwards".
04:13:01 <|Steve|> I think of it as a container.
04:13:02 <RyanT5000> if the pure is encapsulated, doesn't that kind of mean the impure is also encapsulated?
04:13:10 <earthy> is it really necessary to determine which side of the barrier things are on?
04:13:31 <|Steve|> Maybe not, but you see now why it doesn't coincide with my understanding of the word, right?
04:14:08 <|Steve|> My complaint is that it seems like the pure code is encapsulated, it doesn't care about the IO at all. The reverse cannot be said.
04:14:36 <earthy> ah, but that's the thing, really
04:14:36 <opqdonut> well the point is that "caring about pure code" is not a problem
04:14:45 <earthy> the 'side effects' are encapsulated
04:14:48 <opqdonut> whereas "caring about IO code in non-IO code" is
04:14:50 <RyanT5000> |Steve|: that's like saying that "my graphics code isn't encapsulated from the sine function"
04:15:17 <RyanT5000> there's no layering violation; if the situation you described were reversed, *then* there would be a layering violation
04:15:22 <earthy> and only code that is explicitly in the IO monad is subject to the side effects
04:15:30 <earthy> all other code isn't
04:15:49 <earthy> (barring, once again, nastiness such as mucking about in memory spaces)
04:15:59 <RyanT5000> (and unsafePerformIO)
04:16:17 <opqdonut> (barring a high-energy cosmic ray hitting your processor)
04:16:43 <|Steve|> RyanT5000: I wouldn't say that it was. I'd say that the sine function is encapsulated from your graphics code though.
04:16:46 <|Steve|> I think you just made my point.
04:16:57 <RyanT5000> |Steve|: no, you just made my point
04:17:16 <opqdonut> |Steve|: well in the same way the pure code is encapsulated from the IO code!
04:17:18 <RyanT5000> |Steve|: that's the point: your whole program is a utility function (like sine) that main uses
04:17:42 <RyanT5000> ok maybe i understand you a little better now
04:17:47 <RyanT5000> why do you want IO to be encapsulated?
04:18:04 <|Steve|> I don't. But I also don't describe it that way.
04:18:19 <|Steve|> opqdonut: Yes, that was my point.
04:18:49 <opqdonut> wasn't your claim that pure code is _not_ sufficiently encapsulated
04:19:02 <|Steve|> Nope.
04:19:13 <RyanT5000> you're saying that *we* say that IO is encapsulated
04:19:18 <|Steve|> Yes.
04:19:45 <RyanT5000> so, here's what i'd say
04:19:48 <RyanT5000> in haskell
04:19:56 <RyanT5000> IO is encapsulated
04:19:58 <RyanT5000> main is not
04:20:08 <Stinger> buh?
04:20:17 <RyanT5000> so, the concepts that IO uses
04:20:27 <RyanT5000> or, the concept of Input/Output
04:20:30 <RyanT5000> is in System.IO
04:20:38 <RyanT5000> and doesn't depend on too much other stuff
04:20:49 <RyanT5000> i.e.: the *type* IO is fairly well encapsulated
04:20:56 <|Steve|> I agree with that.
04:21:08 <|Steve|> As was  pointed out, the compiler guarantees it.
04:21:10 <RyanT5000> the function main - or any other function - is only encapsulated with respect to the things you don't import
04:21:57 <RyanT5000> then again, in pretty much any language, pretty much anything you import can violate encapsulation
04:22:29 <RyanT5000> in fact, anything your main function is encapsulated from *doesn't exist* (for the purposes of the produced binary)
04:23:08 <RyanT5000> so i don't think anyone is trying to say that a particular IO function, or that IO functions in general, are generically "encapsulated"
04:23:20 <RyanT5000> just that the concept of Input/Output is encapsulated in the type IO
04:23:29 <wli> At some point I'll have to clean up the brutally hacked together terminfo parser.
04:23:31 <RyanT5000> and that we have all these guarantees that ensure it can't escape
04:24:24 <|Steve|> I don't disagree with you. I'm only objecting to the description I usually see.
04:24:44 <RyanT5000> URL?
04:25:13 * wli looks at Reed-Solomon coding for less crappy of file formats.
04:25:40 <RyanT5000> wli: those are pretty cool; i'm going to use them in a project i'm working on right now
04:25:55 <|Steve|> RyanT5000: If the request was to me, it's 4:30 and I don't have one now.
04:26:00 <RyanT5000> i *still* can't figure out how i'm supposed to deserialize this damn GADT
04:26:00 <|Steve|> In fact, I'm off to bed.
04:26:07 <wli> RyanT5000: Is the Reed-Solomon code going to be in Haskell?
04:26:09 <RyanT5000> |Steve|: alirght, cya
04:26:13 <|Steve|> Goodnight.
04:26:15 <RyanT5000> wli: certainly :)
04:26:25 <RyanT5000> and probably GPLv3
04:26:26 <wli> RyanT5000: unlock the MVar?
04:26:40 <RyanT5000> wli: i still don't understand what you mean about MVars
04:26:55 <RyanT5000> i need to extract my datatype from a ByteString (or equivalent)
04:26:58 <wli> RyanT5000: Well, whatever kind of lock you're using to serialize access to it.
04:27:03 <RyanT5000> no no
04:27:10 <RyanT5000> not *that* kind of serialize
04:27:24 <RyanT5000> the kind that means the same thing as "marshal" and "pickle"
04:27:42 <wli> Marshalling doesn't sound so involved.
04:27:45 <RyanT5000> sorry, i didn't even think of that meaning of the word
04:28:04 <RyanT5000> wli: maybe you could point me in the right direction? i'm getting ridiculous type errors
04:28:20 <RyanT5000> http://hpaste.org/1957#a2
04:28:22 <wli> RyanT5000: hpaste?
04:28:57 <RyanT5000> those three snippets of code aren't the most coherent
04:29:11 <RyanT5000> but i'll welcome any way of reading and writing this gadt
04:29:28 <wli> There's no attempt to parse values of your type. Why not derive Read?
04:29:40 <RyanT5000> you can't derive things on GADTs
04:29:52 <wli> Oh, that's irritating.
04:30:23 <wli> Well, what do your attempt at defining read instances look like thus far?
04:30:40 <RyanT5000> well, i haven't been attempting to define a read instance
04:30:40 <desp> @pl writeFile f r = L.writeFile f (fromRope r)
04:30:40 <lambdabot> writeFile = fix ((((L .) .) .) . flip flip fromRope . ((.) .))
04:30:46 <desp> writeFile f r = writeFile f (fromRope r)
04:30:50 <desp> @pl writeFile f r = writeFile f (fromRope r)
04:30:50 <lambdabot> writeFile = fix (flip flip fromRope . ((.) .))
04:30:53 <desp> hrm
04:30:54 <RyanT5000> the stuff i've been trying is pasted below
04:31:08 <desp> really no better way to pl that?
04:31:12 <roconnor> Does YHC have a GHC backend?
04:31:13 <RyanT5000> it's a binary serialization routine
04:31:26 <Saizan> RyanT5000: the problem i think is that you want to know your env type statically when in reality you reconstruct it from stack of constructors, right?
04:31:53 <RyanT5000> Saizan: yeah, that sounds like it could be it
04:32:07 <desp> @pl hPut h r = hPut h (fromRope r)
04:32:07 <lambdabot> hPut = fix (flip flip fromRope . ((.) .))
04:32:09 <desp> ugh
04:32:35 <Japsu> flip flip flip flip ...
04:33:04 <opqdonut> desp: why not just "hPut h = hPut h . fromRope"
04:33:15 <wli> RyanT5000: Binary?
04:33:18 <desp> opqdonut: indeed, why not
04:33:26 <RyanT5000> wli: yes, that's what i was attempting to use
04:33:32 <desp> ahh.
04:33:36 <RyanT5000> however, i realized that Binary can't actually be used
04:33:42 <desp> I am freaking lambdabot out with the recursion
04:33:46 <RyanT5000> because the get function can fail
04:33:50 <wli> RyanT5000: Well, it shouldn't matter so long as it's all there.
04:33:50 <Saizan> RyanT5000: when you deserialize it, do you know which is the env type in advance?
04:33:53 <desp> @pl newhPut h r = hPut h (fromRope r)
04:33:53 <lambdabot> newhPut = (. fromRope) . hPut
04:33:58 <RyanT5000> Saizan: yeah
04:34:00 <opqdonut> ahhh
04:34:14 <desp> @unpl newhPut h = hPut h . fromRope
04:34:14 <lambdabot> newhPut h c = hPut h (fromRope c)
04:34:23 <desp> opqdonut++
04:34:28 <wli> This looks so bizarre. All these people are saying stuff about locking when they mean parsing and printing etc.
04:34:35 <desp> lambdabot--
04:35:45 <RyanT5000> Saizan: maybe i should try factoring out the env thing?
04:35:49 <RyanT5000> i'm not sure if that could work
04:36:09 <RyanT5000> actually, no, it definitely couldn't
04:36:15 <RyanT5000> oh wait, maybe
04:36:17 <RyanT5000> i'll give it a shot
04:36:50 <wli> I'm not sure how you're supposed to capture typeclass constraints on some of these type variables not mentioned as parameters of the type.
04:36:59 <wli> Lambda :: Exp (t, env) a -> Exp env (t -> a)
04:37:05 <wli> What the heck is that?
04:37:13 <RyanT5000> wli: do you know what GADTs are?
04:37:20 <RyanT5000> it's a declaration of a GADT constructor
04:37:40 <wli> Only env and a are mentioned in the signature. There's no way to put a typeclass constraint on t.
04:37:54 <Stinger> gadts arent standard haskell
04:37:58 <RyanT5000> wli: why are typeclasses involved?
04:37:59 <wli> RyanT5000: "That" referred to the loose type parameter t
04:38:10 <Saizan> RyanT5000: no, but i think you need to have more than one Get instance, so you can have type-level recursion
04:38:11 <opqdonut> how is it loose?
04:38:16 <Stinger> as far as I know anyway :P
04:39:00 <wli> RyanT5000: Because you can't marshal the arguments to the data constructor unless the types of the arguments are all parameters of the type constructor or derived from them.
04:39:13 <Saizan> wli: t is not loose, and the top env and a are not tied to the others
04:39:42 <Saizan> wli: you could have written data Exp :: * -> * -> *  where ..
04:39:54 <wli> Saizan: There's no way to have an instance.
04:40:44 <opqdonut> wli: i still don't see what your problem is?
04:41:28 <wli> instance (Read env, Read a) => Read (Exp env a) where ...
04:42:34 <RyanT5000> wli: the env is never stored in the Exp
04:42:40 <wli> Ugh, no scope for the fscking type variables.
04:42:52 <Saizan> you can write that, but you probably need instance Read (Exp env a), Read a  => Read (Exp (t,env) a) ...
04:43:27 <RyanT5000> Saizan: the main problem, i think, is that i don't know how to make the instances not overlap
04:44:17 * wli is beginning to suspect he may not entirely understand GADT's.
04:44:40 <RyanT5000> so, the only point of env is to let me build up a heterogeneous list
04:44:41 <Saizan> you env looks like (Foo,(Bar,())) ?
04:44:45 <RyanT5000> yeah
04:45:10 <RyanT5000> so you can do something like set the environment as (5, ("Hello", ()))
04:45:24 <RyanT5000> then Top would evaluate to 5
04:45:31 <Stinger> tuples as lists?
04:45:40 <RyanT5000> (Pop Top) would evaluate to "Hello"
04:45:47 <RyanT5000> Stinger: yes
04:45:53 <RyanT5000> so that they can be heterogeneous
04:46:02 <RyanT5000> and so that it can all be done statically
04:46:22 <Saizan> so Get (Exp env a) => Get (Exp (t,env) a), and Get (Exp () a)?
04:46:54 <RyanT5000> Saizan: that's one route i haven't gone down yet; it looks like it might work
04:47:24 <Saizan> you'll need Get context on a also, for Lit
04:47:33 <RyanT5000> yeah
04:47:39 <Saizan> (is the class called Get? i vaguely remember)
04:47:40 <RyanT5000> right now i'm ignoring lit
04:47:58 <RyanT5000> well i can't use the classes from Data.Binary
04:48:01 <RyanT5000> well, the class
04:48:04 <RyanT5000> which is called Binary
04:48:15 <RyanT5000> because i want to return Nothing when it *isn't* a legitimate expression
04:48:48 <Saizan> right
04:50:14 * wli is clueless on the existential type front.
04:50:27 <Saizan> there's no existential here
04:50:53 <RyanT5000> yeah, also they seem to be broken
04:51:11 <RyanT5000> if i put an existential qualifier in Lit, e.g. Lit :: Show a => a -> Exp env a
04:51:18 <RyanT5000> i still can't unpack the lit and use show
04:51:26 <RyanT5000> i'm pretty sure that's wrong
04:51:36 <Saizan> that's fixed in 6.7
04:51:41 <RyanT5000> sweet
04:51:43 <wli> There appears to be some relation between existential types and GADT's that I'm unaware of, or so the GADT wiki page says in its parsing example (which is a naive example that doesn't compile, then they mention existential types and never show a working version).
04:51:45 <blackdog> bzlib won't build - any idea how you tell a cabalised program where to find extra headers?
04:51:48 <RyanT5000> i need to start using the "unstable" builds
04:52:14 <RyanT5000> i'm sure haskell's "unstable" will still be the most stable piece of software on my machine
04:52:18 <blackdog> -q
04:52:37 <RyanT5000> (special "thanks" to atheros' wireless driver >:-|)
04:52:43 <Saizan> RyanT5000: i'm not so sure :) it's not guaranteed to build
04:52:46 <wli> blackdog: http://hpaste.org/1958
04:53:02 <RyanT5000> Saizan: well, if i get one that builds, anyway
04:54:08 <Saizan> there are also nightly builds
04:54:13 <psykotic> any SIB fans? i wonder if it's possible to do something like mkQ :: r -> (b -> r) -> a -> r, but rather than having b be a particular type, have it be existentially quantified. mkQ :: r -> ((forall b. Num b => b) -> r) -> a -> r, for example.
04:54:28 <RyanT5000> also, it seems as though GHC's release cycle is picking up the pace?
04:54:32 <wli> I suspect I'm not really understanding GADT's at all.
04:54:46 <RyanT5000> wli: they're pretty tricky; this is my first time using one other than for fun
04:54:51 <matthew-_> wli: what's up with GADTs and existentials?
04:55:12 <wli> matthew-: I have no idea. I suspect I don't understand a bloody thing.
04:55:25 <RyanT5000> Saizan: i am pretty sure i have to use overlapping classes here
04:55:54 <Saizan> RyanT5000: instances you mean? well i use them quite liberally..
04:55:54 <RyanT5000> Saizan: if i instance Deserializable (Exp (t, env) a), then i can't deserialize Top, because it requires t == a
04:56:04 <RyanT5000> Saizan: yeah, that's what i mean
04:56:15 <matthew-_> wli: ok, so GADTs are really quite nice in that they allow you a lot of control over type parameters and so forth
04:57:22 <RyanT5000> Saizan: what's the class that determines the equality of two types usually called?
04:57:33 <RyanT5000> Saizan: i know i've seen it in papers a bunch
04:57:54 <matthew-_> wli: existentials allow you to "hide" type variables, which generally leads to extreme pain, but there are a few very useful cases
04:58:24 <psykotic> the main use case of existentials is to enable OO-style "programming against interfaces", via type classes
04:58:30 <Saizan> RyanT5000: something like Teq?
04:58:44 <RyanT5000> Saizan: yeah, although i thought i remembered seeing a catchier name :P
04:58:49 <RyanT5000> i'm just calling it SameType :P
04:58:52 <matthew-_> psykotic: I can see why you'd say that, but I don't think I've ever used them for that!
04:59:05 <psykotic> the "problem" with type classes is that the dictionaries that implement the class operations are packaged with the type, rather than with values of the type. you can fix that with existentials, since an existential value is essentially a "package", consisting of a type T and a value x :: T.
04:59:31 <psykotic> so a value of an existential type that's quantified over a type class carries the dictionary around with it
05:00:03 <RyanT5000> Saizan: actually, i can't think of a way to cleanly separate it; i'm going to have to use a special version of that
05:00:05 <psykotic> matthew-_, that's how i use them, and they're very useful that way.
05:00:16 <matthew-_> psykotic: yeah, I can see that
05:00:49 <matthew-_> psykotic: have you got a neat little example of that style in use that you can paste?
05:01:02 <paolino> ola folks, I have my daily doubt :)
05:01:03 <psykotic> matthew-_, http://programming.reddit.com/info/2aioh/comments/c2alre
05:01:04 <lambdabot> Title: 37 Reasons to Love Haskell (playing off the Ruby article) (reddit.com)
05:02:06 <paolino> dispositions k xs = [x:d | t@(x:_) <- tails xs , d <- dispositions (k-1) t] -- isn't equivalent to
05:02:07 <paolino> dispositions k xs = [head t:d | t <- tails xs , d <- dispositions (k-1) t] -- ?
05:02:16 <psykotic> matthew-_, clear enough?
05:02:25 <matthew-_> psykotic: indeed
05:03:08 <psykotic> matthew-_, you actually don't technically need type classes; you can existentially quantify over a record, and instead of having types implement type class, you can have a "constructor" that converts from a value of the type to that record type.
05:03:18 <psykotic> matthew_-, but i find this style cleaner and more convenient.
05:03:56 <matthew-_> psykotic: I find that when unpacking values like Intersectable, I always have to use case .. of in order to stop GHC exploding (either "My Brain Exploded" or "Existential type escapes"). Your snippet almosts suggest you can do it in the pattern match?
05:04:19 <Saizan> paolino: because the first filters out empty lists
05:04:45 <psykotic> matthew-_, in this example you don't have to do anything. the only thing you can do instances of Intersectable is to kill intersect on them, and that works easily.
05:04:56 <Saizan> paolino: when a pattern match fails in a list comprehension that element is ignored
05:05:05 <RyanT5000> Saizan: now it's asking me to turn on -fallow-incoherent-instances :(
05:05:07 <RyanT5000> that sounds bad
05:05:22 <Saizan> that's usually bad
05:05:35 <paolino> 0_O, Saizan thanks and nice to see you
05:05:37 <wli> http://holomorphy.com/~wli/GADT.hs is my first thought of how to use the things.
05:05:53 <RyanT5000> well right now i have instances for DeserializableTop (Exp (t, env) t)
05:05:54 <RyanT5000> and for
05:06:04 <matthew-_> psykotic: ahh, ok.
05:06:04 <RyanT5000> DeserializableTop (Exp (t, env) a)
05:06:15 <RyanT5000> because Top only makes sense if those types are the same
05:06:47 <RyanT5000> (top retrieves the top value from this heterogeneous stack)
05:08:00 <RyanT5000> Saizan: how bad is -fallow-undecidable-instances?
05:08:04 <RyanT5000> that one's ok, right?
05:08:09 <paolino> mmhh.. why tails return an empty list as last element ?
05:08:34 <Saizan> RyanT5000: yes
05:08:44 <rehges> paolino: if it wouldn't, you couldn't run it on an empty list
05:09:04 <matthew-_> RyanT5000: turning on incoherent instances is normally a step too far - you can get "the wrong answer" with that, whereas undecideable and overlapping are "safe" (other than potential non-termination of type checking)
05:09:33 <psykotic> wli: have you seen the classical use case of GADTs, like a LC interpreter?
05:09:33 <paolino> ok, I see it's a goat's wool question :)
05:09:36 <RyanT5000> matthew-_: is there any other way to return one value if the two types are the same and another value if they're different?
05:09:53 <psykotic> wli: oh wait, that's what your example is :)
05:09:55 <RyanT5000> i want different things for: (Exp (t, env') t) and (Exp (t, env') a)
05:10:25 <DRMacIver> matthew-_: To answer your question from 24 hours ago (I think. Crossing the pond screws up my sense of time), I start next week. :)
05:10:32 <dozer> RyanT5000 - create a class over a, b and give it a member function foo :: a -> b, then make those two things instances of the function
05:10:47 <psykotic> wli: you have to leave out the t parameter when using the data ... where ... definition style. basically instead of the parameter being "bound" at the top, it can vary on a per-constructor basis, and that's what gives GADTs additional power over plain old ADTs.
05:11:26 <wli> psykotic: Greek to me.
05:11:34 <psykotic> wli: okay, quick example then.
05:11:55 <RyanT5000> dozer: i'm not sure how i'm supposed to provide values, or even properly-typed bottoms for that parameter though
05:12:54 <psykotic> wli: a plain old ADT: data Triple a = T a a a. written in the data/when style: data Triple a where T :: a -> a -> a -> Triple a.
05:12:58 <RyanT5000> and i think the fact that it doesn't take an argument is what's giving me the incoherent-instances thing
05:13:07 <psykotic> wli: those are exactly the same.
05:13:38 <dozer> RyanT5000: can you paste some example code into patebin? Just so I can get a feel for what you're up to
05:13:47 <RyanT5000> dozer: yeah, just a sec
05:14:20 <blackdog> wli: it's an interesting implementation. given that the primes method uses your other one, and that (in my implementation at least) almost all of the time was spent in encoding, it's not terribly surprising that the primes method is slower...
05:14:21 <hpaste>  RyanT5000 pasted "The newest version" at http://hpaste.org/1959
05:14:22 <psykotic> wli: the additional power of GADTs comes from the fact that the return type of the constructors doesn't have to be Triple a. you could have a constructor Foo :: Int -> Triple Int.
05:14:40 <matthew-_> DRMacIver: eek, you're on the wrong side of the pond now?
05:14:56 <vincenz> psykotic: sucked into haskell? :)
05:15:22 <psykotic> wli: in that GADT.hs thing you posted, this is used in the LitChar, LitInt, LitFloat constructors.
05:15:27 <psykotic> vincenz, yeah :)
05:15:30 <vincenz> can I get a link?
05:15:44 <DRMacIver> matthew-_: Well, I'm on the right side of the pond now.
05:15:45 <wli> psykotic: I'm clueless as to what to do for the other cases.
05:15:50 <DRMacIver> matthew-_: But I was on the wrong side of the pond.
05:15:56 <vincenz> wli: link?
05:16:23 <RyanT5000> dozer: basically, Exp uses env to build up a list of types, which describes a heterogeneous list which is the environment
05:16:26 <RyanT5000> it's used as a stack
05:16:38 <dozer> right RyanT5000, I had the exact same problem with my negative-normal-form rewriter post to haskell-cafe
05:16:53 <RyanT5000> did you manage to solve it?
05:17:06 <vincenz> psykotic: there's fancier tricks than that
05:17:11 <vincenz> bsically
05:17:18 <vincenz> you an define a bunch of tags
05:17:18 <dozer> if you make eval something like:
05:17:18 <dozer> class a b | a -> b where eval :: Expr env a -> Expr env b
05:17:20 <vincenz> data Exp_
05:17:22 <vincenz> data Stm_
05:17:27 <vincenz> then you an have
05:17:39 <vincenz> IfThenElse :: Exp -> Stm -> Stm -> Stm
05:17:41 <vincenz> where
05:17:50 <vincenz> type Stm = AST Stm_
05:17:50 <RyanT5000> dozer: how can i get the result out, then?
05:17:54 <hpaste>  Saizan annotated "Is there any way to serialize/deserialize this?" with "this compiles, may it work?" at http://hpaste.org/1957#a3
05:18:04 * roconnor tries to install JHC.
05:18:08 <matthew-_> RyanT5000: basically, you need to have a class representing equality of type parameters. You can then use membership of that class in the context of your instances for the function you wish to override
05:18:25 <psykotic> vincenz, i was talking about his specific example.
05:18:39 <vincenz> psykotic: I don't have a link yet :
05:18:41 <vincenz> :|
05:18:48 <matthew-_> so the class acts as proof that the two type params are equal
05:18:48 <RyanT5000> Saizan: i'll try it
05:19:03 <dozer> RyanT5000: ah, so something more like class a b | a -> b where eval :: Expr env a -> env -> b
05:19:47 <RyanT5000> dozer: yeah
05:19:59 <RyanT5000> dozer: although a should always be equal to b
05:20:06 <RyanT5000> that's its purpose
05:20:13 <Syzygy-> @shapr
05:20:13 * lambdabot smacks  about with a large trout
05:20:18 <Syzygy-> No, that's not it.
05:20:22 <RyanT5000> it works really well for everything but deserialization
05:20:27 <Syzygy-> @call-sh
05:20:27 <lambdabot> Unknown command, try @list
05:20:29 <Syzygy-> @list
05:20:29 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
05:20:46 <Syzygy-> @get-shapr
05:20:47 <lambdabot> shapr!!
05:20:58 <RyanT5000> you can do, e.g.: (Lambda (App (App (Lit (==)) Top) (Pop Top)))
05:21:21 <RyanT5000> eval (that) ("Hello", ()) "Hello"
05:21:26 <RyanT5000> that returns true
05:21:34 <RyanT5000> etc.
05:21:36 <opqdonut> hmm, sounds prologish
05:23:58 <RyanT5000> opqdonut: not so much; it's not exploring trees or anything
05:24:04 <RyanT5000> it's just a language that isn't designed for humans at all :P
05:24:15 <RyanT5000> (does that make it prologish? :P)
05:24:57 <dozer> RyanT5000: just annotating that post a bit...
05:25:05 <RyanT5000> dozer: thanks
05:25:15 <hpaste>  psykotic pasted "gadts for theorem proving - for wli" at http://hpaste.org/1960
05:25:37 <roconnor> Hmmm JHC seems out of date.
05:25:39 <psykotic> wli: you might find that interesting if you like the curry-howard isomorphism.
05:26:21 <hpaste>  (anonymous) annotated "The newest version" with "(no title)" at http://hpaste.org/1959#a1
05:26:32 <psykotic> wli: you can read types as proof obligations and the GADT constructors as axioms/inference rules.
05:26:50 <wli> I can't make sense of any of it yet.
05:27:03 <dozer> not done a very good job - basically, you parameterise Exp over one type for each kind of expression, and you capture in that extra type the 'shape' of the expression tree
05:27:04 * roconnor gives up trying to build JHC.
05:28:39 <psykotic> @localtime dons
05:28:40 <lambdabot> Local time for dons is Mon Jul 30 22:27:26 2007
05:28:53 <hpaste>  tcr pasted "GHC: uninformative error message" at http://hpaste.org/1961
05:29:30 <RyanT5000> dozer: hm, ok
05:29:52 <tcr> GHC hackers around?
05:29:54 <Igloo> audreyt_: Thanks for the perl fix!
05:29:55 <Lemmih> tcr: I think that was fixed recently.
05:30:05 <hpaste>  wli pasted "Not understanding GADT's" at http://hpaste.org/1962
05:30:37 <tcr> Lemmih: Nice. That's the kind of information I wanted to hear before bothering complaining officially. :)
05:31:02 <wli> dozer: Not sure what you mean wrt. one type for each kind of expression.
05:31:58 <dozer> hum, one for each constructor (or group of constructors that behave the same in eval and friends)
05:32:30 <RyanT5000> let it be known that i think this is ridiculous
05:32:32 <wli> dozer: Constructors are just strings, as are primitives. I've no idea what arity they really are.
05:32:37 <RyanT5000> and that we should give up on having a "total" type system
05:32:42 <RyanT5000> and just let me program the damn thing
05:32:44 <RyanT5000> lol
05:32:48 <wli> dozer: Never mind the types of the arguments.
05:33:14 <Lemmih> wli: Drop the kind signatures.
05:33:28 <Lemmih> wli: And then fix 'Maybe Pattern t'.
05:34:00 <wli> Lemmih: That did it.
05:34:09 <Saizan> RyanT5000: i'll post this con haskell-cafe, maybe Oleg is around :)
05:34:15 <Saizan> *i'd
05:34:26 <RyanT5000> Saizan: thanks
05:34:48 <wli> dozer: Well, I could always do the Either and (,) anonymous coproduct and anonymous tupling -only semantics.
05:34:54 <Saizan> (i mean, if i were you ..)
05:35:11 <vincenz> wli:
05:35:12 <RyanT5000> Saizan: that sounds more reasonable :P
05:35:16 <vincenz> data Exp :: * -> * where
05:35:23 <RyanT5000> dozer: is this shape type going to lock me into a particular shape when i deserialize? because that would not really work so much
05:35:32 <wli> vincenz: Lemmih seems to have covered it.
05:35:38 <RyanT5000> the whole point is to let any program be provided
05:36:01 <vincenz> ok
05:36:09 * vincenz shrugs
05:36:09 <dozer> RyanT5000: it will capture only those shapes of program that are well-formed
05:36:12 <vincenz> I've done exactly something like this in the past
05:36:20 <RyanT5000> dozer: well, that's exactly what i want :P
05:36:35 <dozer> yea :)
05:37:09 <RyanT5000> dozer: what's the deal with the return value of Top? is that a mistake?
05:37:21 <RyanT5000> Exp (t, env) u -> Top_
05:37:29 <dozer> so, make a load of dummy data types like App_, one for each constructor, and give them a type parameter for each expr the constructor chews on
05:37:29 <RyanT5000> you mean Exp (t, env) u Top_, right?
05:37:32 <dozer> yup, my bad
05:37:42 <RyanT5000> dozer: alright
05:37:58 <dozer> so you capture the 'shape' of the expression in these data things
05:38:02 <RyanT5000> right, i get that
05:38:09 <dozer> and thread the state in the 'real' language constructors
05:38:19 <dozer> oops - thread the types
05:38:36 <wli> vincenz: How did you get it to do anything meaningful?
05:38:39 <RyanT5000> i just didn't know whether that could be built bottom-up or whether the shape had to be pre-known
05:38:50 <vincenz> wli: using ComposOp (bringert's paper)
05:38:59 <vincenz> I extended it to multi-parameters
05:41:28 <vincenz> (what that gets you isvery easy travelling to modify types inside your AST)
05:41:32 <vincenz> (but in a meeting..)
05:41:48 <wli> vincez: Okay, I'll check it out.
05:43:37 <ndm> vincenz: did you write a paper on that, in the end?
05:43:49 <vincenz> ndm: No, I did not
05:44:23 <vincenz> Haskell stuff is free time stuff, which is somewhat limited by my phd work :/
05:44:27 <dons> ?users
05:44:27 <lambdabot> Maximum users seen in #haskell: 353, currently: 353 (100.0%), active: 22 (6.2%)
05:46:06 <Adamant> if you wanted to do research on using languages like Haskell to increase safety and security of programs, where would you go?
05:46:17 <Adamant> (college-wise)
05:51:16 <ddarius> andyjgill's movie not up yet?
05:51:57 <vincenz> @seen bringert
05:51:57 <lambdabot> I haven't seen bringert.
05:52:00 <Syzygy-> lhs2TeX and arXiv submissions make for an amusing combination.
05:52:12 <vincenz> @tell bringert Regarding those extra instances I made about ComposOp, mind if I write a blog article about those?
05:52:12 <lambdabot> Consider it noted.
05:52:44 <wli> I sometimes wonder if I could publish random Haskell code I've written by just lhs2TeX'ing it.
05:53:54 <hpaste>  RyanT5000 annotated "The newest version" with "(no title)" at http://hpaste.org/1959#a2
05:54:10 <RyanT5000> dozer: so i made the changes, but it doesn't like my instance
05:54:15 <vincenz> wli: I use hscolour for my blog
05:54:31 <vincenz> ndm: why did you ask?
05:54:38 <RyanT5000> dozer: it complains that it can't deduce Deserializable (Exp shapeX env a1)
05:54:49 <hpaste>  wli pasted "GADT's take 2" at http://hpaste.org/1963
05:54:51 <RyanT5000> from
05:55:05 <RyanT5000> Deserializable (Exp shapeX env a)
05:55:21 <vincenz> wli: typically, if you use GADT, ,you stick all your stuff in one
05:55:22 <vincenz> GADT
05:55:28 <vincenz> including the pattern stuff
05:55:35 <vincenz> and then you type with a tag
05:55:51 <vincenz> type Exp t = AST Exp_ t
05:55:54 <wli> vincenz: Hmm. I'm not 100% sure how to deal with patterns there.
05:55:57 <vincenz> type Pattern t = AST Pattern_ t
05:56:21 <wli> vincenz: I'm missing too many pieces for that.
05:56:30 <ndm> vincenz: just to read, once its done
05:56:36 <vincenz> I'll take a look at it in a bit (post meeting)
05:56:42 <ndm> wli: what are you trying to do?
05:57:19 <wli> ndm: Work through a vanilla and/or canonical GADT example (lambda calculus stuff as a GADT).
05:58:02 <ndm> there was a paper at TFP 2007, by the Oxford people, that had some good stuff in it
05:58:18 <wli> I have to write to understand it.
05:59:41 <wli> vincenz: I could always shoehorn them in directly as Either constructors.
06:01:32 <wli> vincenz: Maybe not, actually. Patterns recurse.
06:01:36 <kpreid> Suppose I wanted to compile Haskell to an odd target (another high-level language). Is there a Haskell compiler with a useful-for-that pluggable backend?
06:03:01 <vincenz> wli: hmm..wow..
06:03:05 <vincenz> wli: I see the issue
06:03:32 <tcr> kpreid: I'm doing that by using Language.Haskell.Hsx as a parser and Text.PrettyPrint as output generator of my converted AST.
06:03:38 <vincenz> wli: your 't' is way off, you can not determine this until type-checking, so it's not something completely static, so it's really hard to encode this into your data-type as you do
06:03:49 <vincenz> wli: your 't' should stand for the syntactic type of the construct
06:03:53 <kpreid> tcr: I was hoping not to implement my own type inference & optimization
06:03:55 <vincenz> "is it an expression, a pattern,  ..."
06:04:01 <wli> vincenz: Hmm. Okay.
06:04:14 <wli> vincenz: Maybe something simpler at first.
06:04:38 <ndm> kpreid: Yhc is the answer
06:04:43 <tcr> kpreid: Ah yeah, I'd have liked to have type inference, too, but then cut that out and solely relied on the type system of my target language.
06:04:52 <ndm> kpreid: we have back ends for Java, Javascript, a Python interpetter
06:06:23 <quicksilver> kpreid: another approach might be to use ghc's C-- backend, and write a C-- frontend for your language
06:06:34 <quicksilver> kpreid: however, yhc is proabbly a better answer
06:06:37 * blackdog is too tired to debug stack overflows. nytol!
06:06:42 <vincenz> wli: modifying
06:06:55 <kpreid> ndm: is the output high-level enough that e.g. top-level decls (data, constructors, functions) could be exported (with translation of course) to users of a translated-module in the target language?
06:07:12 <ndm> kpreid: yes
06:07:27 <kpreid> nice
06:07:35 <ndm> kpreid: you can go in at the Core level, its pretty easy then
06:07:40 <quicksilver> I wouldn't call that property 'high-level', I'd call it 'structure preserving'
06:07:45 <quicksilver> but it's definitely nifty
06:08:04 <ndm> indeed, the output is pretty low-level, cases and lets, but has the high level entry points preserved
06:08:23 <quicksilver> ndm: I want an actionscript backend for writing flash applets in haskell :)
06:08:47 <vincenz> wli: explaiing assigmeent?
06:08:47 <ndm> quicksilver: we have a javascript back end, which is also actionscript
06:08:48 <kpreid> the motivation for this is that somebody posted to <language>'s list mentioning finger trees, and I was thinking of writing them in <language> but it would be much more fun to reuse the Haskell impl
06:08:53 <vincenz> wli: I'm rewriting your code
06:08:58 <desp> hrm
06:08:59 <quicksilver> ndm: right, that's why I thought it must be quite close
06:09:05 <desp> how do I install a cabal package as user?
06:09:05 <wli> vincenz: Basically it just encodes guards.
06:09:06 <quicksilver> ndm: since they're both ECMAscript I believe
06:09:09 <ndm> kpreid: for which <language>
06:09:14 <kpreid> ndm: E
06:09:16 <ndm> quicksilver: indeed, its just different API's
06:09:17 <desp> Setup --user --with-prefix=$HOME ?
06:09:23 <wli> vincenz: So an unguarded assignment is a plain =
06:09:25 <ndm> kpreid: is E functional/imperative, lazy/strict ?
06:09:33 <ndm> higher order/first order
06:09:35 <desp> make that Setup configure --user --with-prefix=$HOME
06:09:42 <wli> vincenz: So a guarded assignment is a | ... = ... | ... = ... etc.
06:09:46 <vincenz> wli: ok
06:10:08 <xerox> desp -  Setup.lhs --user --prefix=$HOME configure && Setup.lhs install
06:10:18 <desp> right.
06:10:24 <xerox> Build it too (:
06:10:25 <desp> thanks, thought I was missing a step
06:10:28 <desp> ;)
06:10:33 <kpreid> ndm: it is object-graph, with function-like objects, run-time typed, strict (but I'm going to add a transparent laziness primitive), optionally restricted side-effects
06:11:10 <wli> vincenz: Well, when I started hammering it out I wanted t to be the type of the variable/constructor ID's so I could tag them with the results of type inference etc.
06:11:33 <kpreid> ndm: (did that make sense?)
06:11:45 <wli> vincenz: I didn't give myself very long to sort that out, though.
06:12:02 <kosmikus> Syzygy-: is using lhs2TeX with arXiv a problem? can't you just submit the generated file, and add polytable.sty and lazylist.sty to the submitted file bundle?
06:12:09 <ndm> kpreid: kind of, you may have some reasonable success with the convertor - run-time typed and laziness transparently make it much easier
06:12:23 <Syzygy-> kosmikus: Yeah, sure. It took a while to figure out that polytable and lazylist were the ones to be added.
06:12:40 <Syzygy-> kosmikus: And right now I'm waiting for them to tell me why the resulting file gets truncated to a single page in both PS and PDF.
06:12:56 <Syzygy-> (i.e. with the .tex, the .sty's all submitted...)
06:13:04 <Syzygy-> It gets accepted so they won't show me a buildlog.
06:13:15 <Syzygy-> But the resulting preprint only has a single page.
06:13:21 <Syzygy-> Out of 16.
06:13:24 <kosmikus> can't you look at the log file output?
06:13:35 <Syzygy-> No, it doesn't show me a log file output.
06:13:43 <Syzygy-> And in all environ's I can access, it builds fine.
06:13:58 <kosmikus> my wife (she's a mathematician) sitting next to me tells me you usually do
06:14:18 <Syzygy-> Hmmmm. Does she know how I find that?
06:15:12 <kosmikus> Syzygy-: she says you usually can see the output during the submission process.
06:15:14 <vincenz> wli: it won't be clean
06:15:36 <Syzygy-> I could see output during submission as long as it went wrong. Once it went through cleanly, it stopped showing me output.
06:15:52 <kosmikus> hmmm
06:17:25 <wli> vincenz: Beggars can't be choosers.
06:17:38 <vincenz> wli: nearly done
06:17:54 <kosmikus> Syzygy-: do you get to see a partial PDF/PS when it goes wrong?
06:18:00 <vincenz> wli: explain pattern
06:18:06 <vincenz> the Either stuff
06:18:15 <kosmikus> Syzygy-: if you resubmit a file with a deliberate error, say, on page 10, would you get back more than 1 page?
06:18:19 <wli> vincenz: Either won't work for Pattern; it's recursive.
06:18:31 <vincenz> wli: so what does pattern need to look like?
06:18:38 <vincenz> wli: I'll just do it without records, if that's ok
06:18:50 <wli> vincenz: patternConstructor is the constructor head
06:19:28 <hpaste>  vincenz annotated "GADT's take 2" with "better" at http://hpaste.org/1963#a1
06:20:03 <vincenz> ack
06:20:03 <vincenz> mistake
06:20:54 <hpaste>  vincenz annotated "GADT's take 2" with "fixed a bug in Ta" at http://hpaste.org/1963#a2
06:21:11 <Syzygy-> kosmikus: Trying that now....
06:21:14 <vincenz> Ta..g
06:21:33 <vincenz> wli: use Tag to attach info to your AST tree
06:21:42 <vincenz> note that you can only have one type of Tag in your tree
06:21:49 <Syzygy-> Ok. Now it generates 9 pages before bombing.
06:21:57 <Syzygy-> (with the error some 9-odd pages in)
06:22:25 <Syzygy-> ... and on second run through it bombs on page 1 with "LaTeX Error: Environment code undefined" .... *hmmmmmmmm*
06:22:32 <Syzygy-> OOOOOOH!
06:22:42 <Syzygy-> How do I tell it not to try to generate things from my .lhs?
06:22:49 <wli> vincenz: So "Constr x y z" would get Pattern { patternConstructor"Constr", patternConstructorArgument=Left [(Just "x",Nothing),(Just "y",Nothing),(Just "z", Nothing)]
06:22:50 <Syzygy-> (which I want to distribute along with the rest.... but not compile)
06:23:13 <Syzygy-> Ah!
06:23:16 <Syzygy-> %auto-ignore
06:23:26 <wli> vincenz: What on earth are Exp_, Lit_ Const_, Guarded_ and Pattern_???
06:23:48 <vincenz> wli: tags
06:23:57 <wli> vincenz: What happened to as-patterns and record patterns?
06:23:57 <vincenz> to make ite cleaner
06:24:09 <vincenz> type Exp t = AST Exp_ t
06:24:15 <Syzygy-> kosmikus: Thanks!
06:24:39 <Syzygy-> And now the bloody thing complains about me timetraveling. :-/
06:25:41 <wli> vincenz: What's Tag?
06:25:42 <roconnor> Syzygy-: what are you doing!?
06:26:14 * roconnor thinks timetraveling should be left to the experts.
06:26:45 <pejo> Syzygy, causality is not to be messed around with!
06:27:17 * xerox still doesn't see time travellers around him.
06:27:32 <Syzygy-> roconnor: Submitting a preprint to arXiv.
06:29:38 <kosmikus> Syzygy-: so all fixed now?
06:29:57 <Syzygy-> WOOOOOOT!
06:29:59 <Syzygy-> It works!
06:31:47 <xerox> Does C-t work for anybody in Emacs' haskell-mode?
06:33:58 <wli> If you're supposed to represent the types of terms directly, how do you do that for lambdas?
06:34:32 <tcr> xerox: Yes, it does for me. Emacs22 w/ haskell-mode v2_1
06:37:04 <xerox> Err, I mean C-c C-t.
06:37:14 <vincenz> wli: to attach information
06:37:23 <vincenz> Tag "This is a note" (ExpLit (LitInt 1))
06:37:24 <vincenz> ::
06:37:28 <vincenz> AST Exp_ String
06:37:48 <wli> Okay.
06:38:08 <wli> I could fix up a few missing arguments to types.
06:38:09 <vincenz> you can use this to attach type-checking info
06:38:19 <vincenz> (or source-code location iinfo)
06:39:07 <wli> vincenz: Other examples seem to make it look like the type of the term in the represented language is supposed to be mirrored in the code somehow but I don't see how to do it for lambdas.
06:39:33 <vincenz> wli: I don't think this is feasible in any language excecpt ultra simple ones
06:49:05 <dozer> is Data.Graph.Inductive.DynGraph good?
06:49:29 <MyCatVerbs> I heard it once punched a baby.
06:49:51 <DRMacIver> That's a 'yes' then?
06:49:52 <dozer> did the baby punch back?
06:50:00 <SamB_XP_> it's better than Data.Graph, I'm sure
06:50:06 <MyCatVerbs> Plus there's that vaguely brimstone-ish smell. And weirdly placed bony spikes on its head. Might be evil.
06:50:11 <SamB_XP_> Data.Graph has punched many many babies
06:51:03 <dozer> I need to implement an alg that recursively expands and labels a graph, backtracking when it hits stopping rules
06:55:31 <SamB_XP_> @doc Data.Graph.Inductive.DynGraph
06:55:31 <lambdabot> Data.Graph.Inductive.DynGraph not available
06:55:47 <SamB_XP_> @google Data.Graph.Inductive.DynGraph
06:55:48 <lambdabot> No Result Found.
06:56:01 <jfredett> just hoogle it the old fashioned way
06:57:25 <SamB_XP_> heh @ crappy poetry: "Roses are red. Violets are blue. Google rocks. Homage to you."
06:57:45 <jfredett> :)
06:58:16 <jfredett> @remember Hoogle "Roses are Red, Violets are Blue, Hoogle rocks, Homage to you"
06:58:16 <lambdabot> Done.
06:58:20 <jfredett> :)
06:58:23 <jfredett> @botsnack
06:58:24 <lambdabot> :)
06:58:30 <SamB_XP_> @quote
06:58:31 <lambdabot> reddi says: and now i know: IT DOES NOT WORK ALWAYS ;-)
06:58:54 <SamB_XP_> okay, so DynGraph is a *class*, not a module?
06:58:54 <Syzygy-> Hahaha! I just got an email from the tunneling provider I use telling me why I lost connection previously!
06:59:00 <edwardk> Heh, google must like haskell, I just realized there was a 'work at google' link popping up in the ad sense stuff at comonad.com.
06:59:03 <SamB_XP_> no wonder @source didn't work
07:01:35 <SamB_XP_> is there a reader comonod?
07:02:47 <SamB_XP_> edwardk: well it says right here that "Google is hiring expert computer scientists"
07:02:55 <SamB_XP_> they know where to look, apparantly
07:03:08 <SamB_XP_> (as if that's at all surprising!)
07:03:17 <ndm> SamB_XP_: that was originally on the OS X google page, which Apple sued them over, and got taken down
07:03:58 <ndm> its a kind of interesting, "remember when you got sued over interface similarity? please don't sue me"
07:04:01 <edwardk> samb: yeah there is a reader comonad, its the (,)e comonad adjoint to the (->)e reader
07:04:21 <SamB_XP_> ndm: huh?
07:04:32 <SamB_XP_> what did it say on this "OS X google" page?
07:04:43 <edwardk> ask copies the value out of the pair, local generates a new pair.
07:05:13 <ndm> SamB_XP_: http://news.com.com/Googles+X+files+vanish/2100-1032_3-5621247.html
07:05:15 <lambdabot> Title: Google's X files vanish | CNET News.com, http://tinyurl.com/5wq26
07:05:25 <hpaste>  wli pasted "GADT's take 3: value types need help" at http://hpaste.org/1964
07:06:04 <edwardk> ask = fst; local = first
07:06:14 <edwardk> kinda clean like that
07:06:18 <Syzygy-> :t first
07:06:20 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
07:06:33 <Syzygy-> o.O
07:06:37 <Syzygy-> What does that mean?
07:06:46 <edwardk> first f (a,b) = (f a, b)
07:06:52 <Syzygy-> Ahhhh.
07:06:54 <edwardk> when used on the (->) arrow
07:06:59 <wli> I don't know about the rest of arrows, but first, second, and *** are bloody useful.
07:07:12 <Syzygy-> > first (+3) (2,4)
07:07:14 <lambdabot>  (5,4)
07:07:19 <ihope> @type (***)
07:07:21 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
07:07:22 <Syzygy-> > (-2) *** (+3) (2,4)
07:07:23 <lambdabot>   add an instance declaration for (Num (b', c'))
07:07:28 <edwardk> i like &&& as well
07:07:33 <ndm> i have to agree, i use arrows as useful tuple combinators, nothing more
07:07:35 <wli> > join (***) (+1) $ (2,3)
07:07:36 <lambdabot>  (3,4)
07:07:37 <Syzygy-> > (-2) *** (+3) $ (2,4)
07:07:37 <lambdabot>   add an instance declaration for (Num (b -> c))
07:07:38 <edwardk> its useful for pointfree work
07:07:58 <edwardk> > (id &&& (+1)) 2
07:07:59 <lambdabot>  (2,3)
07:08:03 <ihope> > (subtract 2) *** (+3) $ (2,4)
07:08:05 <lambdabot>  (0,7)
07:08:05 <Syzygy-> edwardk: Ahhh.
07:08:09 <ihope> Don't you love -?
07:08:11 <Syzygy-> ihope: RIGHT!
07:08:15 <Syzygy-> *grmbl*
07:08:32 <EvilTerran> id &&& f = second f, surely?
07:08:42 <RyanT5000> dozer: any idea why it claims it can't deduce Deserializable (Exp TLit env (a -> b)) from Deserializable (Exp shapeF env (a -> b)) ?
07:08:43 <Syzygy-> EvilTerran: No.
07:08:50 <Syzygy-> > second (+2) (2,3)
07:08:51 <lambdabot>  (2,5)
07:08:59 <EvilTerran> wait... sorry, that'd be id *** f.
07:09:00 <Syzygy-> > (id &&& (+3)) 2
07:09:01 <lambdabot>  (2,5)
07:09:03 <Syzygy-> Yeah.
07:09:09 <Syzygy-> For *** it holds.
07:09:22 <Syzygy-> To my knowledge at least. :PÅ
07:09:37 <wli> I've not quite smoked out what &&& does.
07:09:42 <SamB_XP_> ndm: google seems cooler about that kind of thing somehow. also there is the fact that you aren't a for-profit company and you don't *have* a brand ;-)
07:09:45 <EvilTerran> @src (->) (&&&)
07:09:46 <lambdabot> Source not found. I feel much better now.
07:09:50 <wli> (+1) &&& (*2) $ 3
07:09:50 <wli> (4,6)
07:09:55 <EvilTerran> @src (&&&) (->)
07:09:55 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
07:09:58 <RyanT5000> anyone? any idea why ghc is complaining that it can't deduce Deserializable (Exp TLit env (a -> b)) from Deserializable (Exp shapeF env (a -> b)) ? shapeF *only* appears there
07:09:58 <EvilTerran> bah.
07:10:18 <ndm> SamB_XP_: yeah, plus i no longer use their logo, following in the footsteps of booble
07:10:32 <SamB_XP_> ndm: so I noticed
07:10:46 <edwardk> there is a similar construction for a state comonad as well. instead of (s -> (a,s)) you need (s -> a,s), then you can define get, set and modify
07:10:48 <SamB_XP_> does OS X even have a logo?
07:11:12 <ndm> i figured with them dontating $50000 to Haskell, i should remove it
07:11:32 <wli> Ah, (&&&) is my old zipF
07:11:45 <edwardk> hey you're no longer the top link for hoogle.
07:12:10 <ndm> @google hoogle
07:12:11 <lambdabot> http://haskell.org/hoogle/
07:12:11 <lambdabot> Title: Hoogle
07:12:20 <ndm> its hard to tell, as i have personalised search, but it seems i am
07:12:23 <edwardk> i got http://www.cims.nyu.edu/~dhu/
07:12:24 <lambdabot> Title: Hoogle
07:12:26 <ndm> for a long time it was hoogle.net
07:12:31 <wli> quite handy indeed
07:12:44 <SamB_XP_> edwardk: me too
07:13:00 <SamB_XP_> maybe they're giving lambdabot doctored results?
07:13:04 <EvilTerran> hm... f &&& g = join $ curry $ f *** g --? (for Reader, anyway...)
07:13:09 <edwardk> but the haskell hoogle and info about it comes up for the next 5-6 links below that
07:13:52 <ndm> i can't even figure out what that other Hoogle is
07:13:57 <wli> EvilTerran: Yeah.
07:14:04 <SamB_XP_> hmm. ndm's page links to www.haskell.org/hoogle
07:14:33 <SamB_XP_> google returns haskell.org/hoogle sooner though
07:14:59 <SamB_XP_> and I don't believe goole knows that they are the same thing :-(
07:15:14 <SamB_XP_> I think someone who has access to the web root on haskell.org could rectify this, however
07:15:31 * wli has struggled with terminfo decoding and GADT's
07:15:44 <SamB_XP_> wli: seperately, I hope?
07:15:56 <wli> SamB_XP_: Fortunately yes.
07:16:14 <edwardk> hrmm, in the interest of providing a more general reader interface that can handle the reader comonad, would FunctorReader or ReaderFunctor be a better name for the class?
07:16:39 <edwardk> (to provide traditional ask and local functionality without biasing to Monad or Comonad)
07:16:48 <wli> MoreGeneralThanThouReader
07:16:52 <edwardk> wli: =)
07:17:25 <MyCatVerbs> edwardk: ReaderFunctor, assuming you mean Functor that Reads?
07:17:28 <_Nucleo> @pl \x -> (head x) /= '0'
07:17:29 <lambdabot> ('0' /=) . head
07:18:27 <edwardk> MyCatVerb: i mean class Functor f => ReaderFunctor f r where ask :: f a; local :: (r -> r) -> f a -> f a
07:19:06 <edwardk> basically MonadReader without the requirement that it be a monad.
07:19:07 <wli> Would that be ask :: f r?
07:19:14 <edwardk> er yeah
07:19:50 <edwardk> guess it should be FunctorReader unless I want to rename all of MonadFoo classes to FooMonad classes.
07:20:05 <edwardk> bit of a bikeshed i guess
07:20:26 <desp> huh
07:20:47 <SamB> we need those typeclass aliases
07:21:03 <edwardk> samb: yeah, my current approach is to hack it together with template haskell magic. =/
07:22:07 <desp> I am completely unable to write a globbing function faster than a simple concat
07:22:12 * desp pasted http://pastie.textmate.org/83464
07:22:13 <desp> any ideas?
07:22:29 <edwardk> The idea being that you'd just say something like $(mk "Foo" [''Monad] [d| return = ...; (>>=) = ... ]) instead of providing several instance declarations
07:22:57 <edwardk> and then I can take advantage of extensive defaulting for unspecified items in the Q [Dec] that is the last argument.
07:24:53 <wli> I don't know. I think avoiding unsafe idioms in the core libraries is a higher priority, though apart from changing the signature of things like (!!), head, tail, etc. to involve Maybe (or MonadPlus), I've NFI how that's done.
07:25:16 <kpreid> how do I build Yhc with additional include/library paths?
07:25:19 <edwardk> so with that basically you define the classes in one module along with all of the default methods with weights indicating implementation preference in a second, then you just instantiate them then define the instances for them in a second.
07:25:22 <wli> And maybe to ban inexhaustive pattern matches.
07:26:05 <dozer> wli: if you do that, we need a syntax for expressing a single match expression as a 1st class thing
07:26:21 <wli> dozer: Not sure what you mean by that.
07:26:54 <edwardk> wli: there are good efficiency arguments against removing the unsafe methods though. =/ though i'd like to see a more standardized set of phantom types to allow you to safely prove that your particular list isn't empty, etc.
07:26:55 <dozer> wli: if you ban inexhasutive matches, then we need so me way to symbolically pass arround one of the cases independently of others
07:27:55 <kpreid> ndm: how do I build Yhc with additional include/library paths?
07:28:20 <wli> edwardk: I'm not convinced. All the case analysis is still there, you just get a default "crap your pants and exit, side effects be damned" case alternative implicitly inserted.
07:28:51 <wli> dozer: Like variables that hold patterns?
07:29:18 <edwardk> wli: just a need for a way to name polymorphic variants
07:29:20 <dozer> wli: yeah
07:29:35 <swiert> sjanssen: Would you like to write something about XMonad for the Monad.Reader?
07:29:43 <SimonRC> Does Haskell have anything like Common Lisp's "condition" system?
07:29:47 <sjanssen> swiert: what is the due date?
07:29:59 <swiert> sjanssen: Last Friday ;)
07:29:59 <_Nucleo> @src inits
07:29:59 <lambdabot> inits []     =  [[]]
07:29:59 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
07:30:21 <swiert> sjanssen: I haven't had enough submissions, so I'm trying to get a few more in over the coming weeks.
07:30:30 <wli> edwardk: Polymorphic variants? Like the subtyping bits where you can make a subtype of a coproduct type by adding more alternatives?
07:30:36 <MyCatVerbs> > inits [1..4]
07:30:38 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4]]
07:30:39 <swiert> sjanssen: I'd like to set an extended deadline over a month or so.
07:30:45 <hpaste>  dozer pasted "problem with lists" at http://hpaste.org/1965
07:31:13 <sjanssen> swiert: yes, I think I can do that
07:31:30 <SamB> hmm, how come we don't have Word4 and Word2 types?
07:31:36 <sjanssen> swiert: I'll check with dons, see if he's available as well
07:31:51 <swiert> sjanssen: I reckon dons is busy writing up his thesis...
07:31:53 <dozer> any idea how in that paste I can get something functionally equivalent to the problem line working?
07:32:04 <swiert> sjanssen: But his blog entries would make a great starting point.
07:32:04 <sjanssen> swiert: oh, good point
07:32:10 <edwardk> wli: yeah some way to say <Just Int, Nothing> vs. <Just Int> vs. <Nothing> as the type of subtypes of Maybe Int, which plays havoc with typeclass system in Haskell.
07:32:20 <Philippa> @seen yaxu
07:32:20 <lambdabot> I saw yaxu leaving #haskell 22h 22m 16s ago, and .
07:33:29 <SimonRC> Probably not then.
07:33:31 <vincenz> re
07:33:35 <sjanssen> swiert: sure, put me down
07:33:36 <swiert> sjanssen: Thanks very much for the offer. I need to get in touch with a few other (potential) authors. I'll get back to you with a definitive deadline then.
07:33:42 <vincenz> wli: more or less clear?
07:34:31 <wli> vincenz: Not entirely. Did you see the GADT's take 3 (enough of a rearrangement that I've had to figure out something, though what I have no idea.)
07:35:52 <vincenz> wli: link?
07:36:01 * vincenz was afk
07:36:06 <edwardk> hrmm, ok, harder bullet to bite, in a more general monad setting, does it make sense to merge 'get' and 'ask'? and 'tell' and 'put'? pro: they have the same type signatures. con: it mucks up the existing RWS monad paradigm.
07:36:11 <wli> vincenz: http://hpaste.org/1964
07:36:55 <sjanssen> edwardk: and ReaderT r (StateT s)
07:36:58 <vincenz> wli: I doubt that syntactic level of typing will work well
07:36:59 <edwardk> yeah
07:37:06 <vincenz> wli: that only works for very primitive languages
07:37:11 <vincenz> wli: I noticed the same when I was working with IMP
07:37:26 <vincenz> as soon as your language becomes more complex, you can not statically type your language purely based on syntactical construction
07:37:43 <wli> vincenz: I'm almost completely clueless as to what to shove into the value types even for simpler examples.
07:37:45 <MyCatVerbs> edwardk: what's the distinction between the two in each pair, please?
07:38:21 <vincenz> wli: the 'value' type
07:38:23 <edwardk> mycatverb: well, 'get' reads state from a State monad, 'ask' reads the environment from a reader monad, which is kinda like a state monad without the ability to change it.
07:38:29 <vincenz> is typically used for the type of annotation your AST has
07:38:34 <vincenz> for insttance
07:38:35 <hpaste>  wli pasted "GADT for simply-typed lambda calculus" at http://hpaste.org/1966
07:38:35 <vincenz> it could be
07:38:42 <wli> vincenz: For instance, that.
07:38:46 <edwardk> 'tell' writes to a writer monad, while, 'put' changes the state in a state monad.
07:39:11 <vincenz> wli: you see how you basically force the encoding of your data constructors into your language?
07:39:13 <edwardk> you can view tell as changing a 'write-only' resource, and 'ask' as reading a 'read-only' resource, while get and put access a 'read-write' resource
07:39:18 <vincenz> wli: it does not scale to more complex langaues
07:39:30 <MyCatVerbs> edwardk: I'd keep 'em seperate, personally, then.
07:39:48 <wli> vincenz: Well, surely there is *something* it makes sense to keep there.
07:40:05 <edwardk> mycatverbs: in the process of debating about if merging them allows other things to generalize, but i'm kinda leaning that way myself
07:40:16 <vincenz> wli: yes
07:40:36 <vincenz> wli: you can put a tag 'type' in there
07:40:38 <vincenz> and then something like
07:40:47 <vincenz> data Type = Char | Int | Type :-> Type | ...
07:41:10 <vincenz> or more simply
07:41:19 <wli> vincenz: So basically instead of shoving values in there, shove representations of types in there.
07:41:30 <Syzygy->  ... | :[] Type | ... ;)
07:41:33 <vincenz> data Type = Basic PrimitiveType | Type :-> Type | TyConst Const [Type]
07:41:46 <MyCatVerbs> edwardk: I'm leaning that way because it's identical to the difference between different types of sockets.
07:41:51 <vincenz> I use :-> explicitly, even though it's just a tyconst
07:42:12 <vincenz> then
07:42:13 <vincenz> you can do
07:42:20 <SimonRC> edwardk: actully, MonadState takes anything but MonadWriter need a Moniod (i.e. something tht can be glues together, like a set or a list)
07:42:20 <MyCatVerbs> edwardk: put footnotes in the docs saying that tell x is equivalent to put x for certain types of x?
07:42:23 <vincenz> typeCheck :: AST t () -> AST t Type
07:42:24 <ndm> kpreid: how do you mean "additional include paths"?
07:42:32 <edwardk> sjannsen: am wondering if the StateT wrapped ReaderT should in the most general setting return the outermost shell, or rather an HList of values or something.
07:42:33 <ndm> kpreid: if you just type "scons" it should build it for you
07:42:34 <wli> vincenz: Primitives are supposed to be function symbols resolved to runtime system things like "+", "-", etc.
07:42:50 <vincenz> wli: I figured :)
07:42:56 <vincenz> wli: hence why you can not statically type the thing in haskell
07:43:02 <vincenz> wli: and why you must use "data Type = ..."
07:43:04 <kpreid> ndm: "scons" => "Error. libgmp must be installed and gmp.h made accessible before you can compile Yhc." -- how do I tell it where to look for gmp.h?
07:43:11 <vincenz> wli: it's in a sense "input" dependent
07:43:24 <vincenz> (namely your input AST and your input 'prelude' of primitiveS)
07:43:32 <edwardk> mycatverbs: well, right now they mean totally different things, if merged i'd prefer to keep only one name.
07:43:37 <ndm> kpreid: no idea, what platform?
07:43:44 <kpreid> ndm: Mac OS X + MacPorts
07:43:53 <wli> vincenz: Plus constructors defined in external type signatures.
07:43:59 <edwardk> simonrc: that i can reflect in the typeclass hackery behind all of this. in the emd MonadWriter would look pretty much the same
07:44:02 <kpreid> ndm: and a custom MP install prefix, so it's *not* going to work by defailt
07:44:04 <edwardk> er end
07:44:09 <vincenz> wli: I did exactly that when I wrote a miniML compiler
07:44:11 <ndm> kpreid: its been known to be hard to build Yhc on Mac, because of libgmp, perhaps email the mailing list yhc -at- haskell.org
07:44:28 <edwardk> except for the fact that it like everything else in my toy prelude would require a bunch of TH to instantiate without pain.
07:44:39 <kpreid> ndm: I have libgmp, that's not the problem; I just need to specify an include path
07:44:40 <MyCatVerbs> edwardk: this is rather outside the bounds of my experience, so... instinctively, don't merge.
07:44:58 <ndm> kpreid: i don't know how, does "scons help" tell you?
07:45:11 <MyCatVerbs> Otherwise you might end up with one function that's a (derogatory term for human genitalia) to write and use in place of two simple functions.
07:45:16 <wli> vincenz: So even the simply-typed lambda GADT is too complex to represent the values of? Are there conditions for representability here?
07:45:31 <kpreid> it mentions a variable for libraries, which I tried setting, but not one for includes
07:45:31 <ndm> kpreid: i can't see any options that would allow that
07:45:49 <vincenz> wli: no I think perhaps it can be done to simply-typed lambdacalclus
07:46:00 <edwardk> mycatverbs: am still toying with it. i do like the notion of being able to build up reader/writer/state towers, just curious what happens when you start to merge the ideas. i.e. anything written to accept a Reader can then accept a State monad, etc.
07:46:08 <vincenz> wli: but do you see how you can in general only find types after typecheck, so it's hard to define what to stick in those 't's prior to that?
07:46:26 <vincenz> (you can only do it if  you constructively build up your AST in haskell code)
07:46:41 <vincenz> (or if the type of an expression can be directly derived from the parsing of that syntactical piece)
07:46:46 <wli> vincenz: Well I noticed it was not tractable.
07:47:00 <vincenz> I used a non-GADT version for the miniml
07:47:04 <vincenz> but transforming that would be rather trivial
07:47:08 <vincenz> the only reason to use GADT encoding
07:47:15 <vincenz> is so you can reuse the ComposOp idea from bringert's paper
07:47:17 <MyCatVerbs> edwardk: well, I'm lazy, I would just steal the ideas from Unix - file descriptors being sockets, files, character devices or block devices.
07:47:26 <vincenz> so you can easily traverse through your AST, even though it's polytyped
07:47:31 <vincenz> (you have expressions, patterns, guards..)
07:47:53 <wli> vincenz: Shall I throw in modules?
07:47:56 <vincenz> here 'type' refers to the type of AST, not the type of what it represens
07:47:58 <MyCatVerbs> edwardk: then provide a central class analogous to an FD, plus specific implementations analogous to sockets, files, chardevs and blockdevs.
07:48:01 <vincenz> wli: I had modules
07:48:04 <edwardk> mycatverbs: well, in unix you have 'read' and 'write' it doesn't change based on the permissions you have. not a very good argument for separation =)
07:48:05 <vincenz> wli: it's more hassle, but sure
07:48:12 <wli> vincenz: heh, yes, MiniML indeed
07:48:13 <vincenz> wli: you need to then make sure there's no circular dependencies
07:48:25 <vincenz> wli: well.. miniml + modules + top-level lazy constructs :)
07:48:54 <wli> vincenz: Is it possible to avoid the type parameter altogether or are literals lost that way?
07:49:09 <vincenz> why are they lost?/
07:49:12 <vincenz> they're still encoded, no?
07:49:38 <vincenz> how I did my compilation: I compiled to ANF
07:49:56 <wli> vincenz: I guess LitChar :: Char -> Term is equivalent to LitChar { litChar :: Char } :: Term still.
07:50:02 <vincenz> yes
07:50:09 <MyCatVerbs> edwardk: you also have, "you can(not)? seek on this" and "any changes you make to this are (not)? guaranteed to exist if you write and then read the data back"
07:50:10 <vincenz> you just add a getter-function
07:50:20 <psykotic> it would be nice if QuickCheck had a === which defaults to =='s behavior but works on functions too
07:50:35 <wli> vincenz: So basically if I don't have a real use for it, the parameter beyond the subexpression type is not worth having.
07:50:36 <edwardk> mycatverbs: yes, but you go through the same api methods in each case ;)
07:50:44 <vincenz> psykotic: -fallow-overloaded-instances ;)
07:50:50 <vincenz> wli: no, it is
07:50:57 <vincenz> wli: you can use it to hang decorations on your AST
07:51:01 <psykotic> so prop_foo = out . in === id would work out for testing the same as prop_foo x = (out . in) x == x, etc
07:51:11 <psykotic> vincenz, what does that do?
07:51:15 <vincenz> wli: like information from the parser (source code loc)
07:51:22 <vincenz> wli: or information like the type after typechecking
07:51:26 <vincenz> where type != haskell type
07:51:28 <vincenz> but some data const from
07:51:30 <vincenz> data Type = ... blabla
07:51:34 <dozer> wli: you can get some fun inferences by defining classes that capture structural constraints, but they are exactly those things that can be read off from the nesting of the constructors
07:51:38 <vincenz> psykotic: get you what you want :)
07:51:45 <vincenz> instance Whatever a where a === b = a == b
07:51:52 <psykotic> vincenz, wow, also icecream? :)
07:51:54 <vincenz> instance Whatever (a -> b) where a === b = useFunctionlogic
07:52:10 <vincenz> they're overloaded instances
07:52:14 <vincenz> (a subsumes (a->b)
07:52:15 <vincenz> )
07:52:21 <psykotic> oh, overlapping?
07:52:24 <vincenz> right
07:52:26 <edwardk> i'm trying to figure out if doing it the alternative, unexplored way gives any benefits, like being able to spot commutable accesses to a state monad whereever you just require the MonadReader instance rather than a full MonadState.
07:52:28 <vincenz> sorry, forgot the name
07:52:43 <psykotic> vincenz, i was confused :)
07:52:52 <vincenz> psykotic: not as much as when you said "SIB" :)
07:52:55 <psykotic> haha
07:53:04 <wli> vincenz: I'll have to see if I can flesh it out with some module constructs. ;)
07:53:13 <vincenz> wli: adding modules just makes it nastier
07:53:26 <MyCatVerbs> edwardk: send(2), recv(2) being specialised for sockets, and seek(2) being supported on some objects but not others.
07:53:27 <edwardk> and that when you transform from an environment to a mutable state you don't have to rewrite all of the code that uses it
07:53:28 <vincenz> wli: a lot of of my glue code has to deal correctly with those, and it doesn't really add anything
07:53:42 <vincenz> I might refactor my miniml compiler to not use modules
07:53:46 <vincenz> then I can pour it into a blog article
07:54:07 <edwardk> mycatverb: send and recv are more of an accident of history than careful API design ;)
07:54:08 <wli> vincenz: Well, it's a toy, so I can cripple the module system as much as I want to make it doable.
07:54:18 <vincenz> it's not so nice, atm, I overgeneralize, which makes my code yucky :(
07:55:01 <wli> I wonder about these things people talk about with the relationship between records and first-class modules.
07:55:09 <vincenz> but no time atm to clean it up and poor into blog
07:55:15 <MyCatVerbs> edwardk: who cares? They work beautifully, don't they?
07:55:28 <edwardk> meh
07:56:19 <edwardk> Until you need to toss a LOT of data around and then the bottleneck of moving in and out of kernel-space gets excessive. ;)
07:58:31 <vincenz> Does anyone know if the new GHC will have lexically-scoped types?
07:58:44 <vincenz> foo :: a -> b
07:58:45 <vincenz> foo a =
07:58:49 <wli> vincenz: That's one huge thing I've wanted.
07:58:52 <vincenz> foo a = plunk a
07:58:55 <vincenz>   where plunk :: a -> b
07:58:59 <sjanssen> vincenz: it does now
07:59:00 <vincenz>    plunk a = bar b
07:59:03 <sjanssen> vincenz: use forall
07:59:06 <vincenz> I hate it when it complains plunk is too general
07:59:23 <vincenz> sjanssen: on the outer or the inner?
07:59:28 <sjanssen> vincenz: the outer
07:59:32 * vincenz nosd
07:59:37 <edwardk> vincenz: doesn't it keep them in scope with that weird type declarations only implicitly rebind type names that aren't in scope rule?
08:00:04 <vincenz> edwardk: can not parse
08:00:05 <quicksilver> GHC does have lexically scoped types
08:00:18 <quicksilver> they're introduced by the binder forall
08:00:20 <kpreid> ndm: I found options that worked, guessed at a bugfix in configure.py, and it's now doing darcs gets of various things
08:00:48 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#scoped-type-variables
08:00:51 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
08:00:54 <ndm> kpreid: neat, is it a change that can be merged in, to help everyone?
08:01:08 <vincenz> sjanssen: still not wokring
08:01:40 <hpaste>  vincenz pasted "scoped types" at http://hpaste.org/1967
08:01:52 <edwardk> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#scoped-type-variables
08:01:54 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
08:01:59 <kpreid> ndm: it's a "I know zilch about Yhc or SCons, but it dies here, and this is unlike the other things so I'll make it the same and, yes, it's making more progress now" thing
08:02:03 <edwardk> heh doh, just realized it was already pasted
08:02:28 <kpreid> ndm: I would think that it's a general bug, but I wonder why no one else has hit it
08:02:30 <ndm> kpreid: can you hpaste a darcs whatsnew
08:02:40 <ndm> kpreid: you'd be surprised how little we know about scons
08:02:41 <sjanssen> vincenz: which version of GHC?
08:02:42 <quicksilver> edwardk: I just posted that :)
08:02:50 <vincenz> sjanssen: ah was missing "-fglasgow-exts"
08:02:58 <edwardk> quicksilver: i was off in another window =)
08:03:09 <sjanssen> vincenz: it still parsed/compiled without -fglasgow-exts?
08:03:17 <hpaste>  kpreid pasted "yhc build patch" at http://hpaste.org/1968
08:03:23 <vincenz> sjanssen: no
08:03:25 <vincenz> sjanssen: oddly, if I put
08:03:28 <vincenz> {-# GHC_OPTIONS=-fglasgow-exts #-}
08:03:30 <vincenz> and then do
08:03:32 <vincenz> ghci Test.hs
08:03:36 <vincenz> it complains about with that error
08:03:43 <vincenz> I need to do "ghci -fglasgow-exts Test.hs"
08:03:53 <sjanssen> vincenz: drop the =
08:03:53 <vincenz> (GHC options are not passed to GHCI?)
08:04:01 <vincenz> sjanssen: idem
08:04:10 <kpreid> ndm: without it scons died with an error that I eventually found was "Only one SConf object may be active at one time"
08:04:11 <sjanssen> idem?
08:04:15 <vincenz> the same
08:04:27 <ndm> kpreid: with it, it gets further?
08:04:34 <vincenz> oh
08:04:36 <kpreid> ndm: yes
08:04:37 <vincenz> "OPTIONS_GHC"
08:04:57 <kpreid> ndm: at the moment it's building various Yhc/Core/*.hs
08:05:21 <vincenz> sjanssen: ok, thanks :)
08:05:28 <shapr> Syzygy-: You called?
08:05:36 <vincenz> sjanssen++
08:05:49 <kpreid> ndm: want a darcs send?
08:06:06 <ndm> kpreid: either than, or i'll push directly (giving you credit), what suits you?
08:06:15 <fasta> Anyone who understands openssl here? I want to use fetchmail to read email from as imaps server, but the only certificates I have are self-signed. I have no idea how to turn them into something that fetchmail accepts.
08:06:36 <ndm> kpreid: i wrote that code, on a win32 machine, never trying the large branch, which probably doesn't stress it too much
08:06:59 <kpreid> ndm: what suits you?
08:07:01 <dcoutts> fasta: add it to /etc/ssl/certs/ ?
08:07:11 <ndm> kpreid: small enough just to patch, no need to darcs send
08:07:15 <Syzygy-> shapr: Wanted to verify how you spell your name before I submitted my paper.
08:07:21 <Syzygy-> Is "Shae Erisson" correct?
08:07:23 <ndm> kpreid: btw, it appears people may have been hitting this for the last week!
08:07:29 <fasta> dcoutts: what do you mean by that? Just copy the file?
08:07:45 <ndm> definately looks like it "breaks the pattern" otherwise
08:07:52 <dcoutts> fasta: that's my guess, look about at the stuff in /ets/ssl/
08:07:54 <kpreid> ndm: ok. in case our line 108s are different: this is going in as the *last* line of def gmp_configure(
08:08:12 <ndm> kpreid: yeah, thats where i've put it
08:08:16 <fasta> dcoutts: AFAIK, doing openssl verify <the file.pem> gives OK (error 18 self-signed <bla bla>)
08:08:30 <kpreid> compile's still going; I'm off to do other things
08:08:49 <shapr> Syzygy-: Yes, it's correct... is my name going to show up in your paper??
08:08:53 <Syzygy-> Yes.
08:08:57 <Syzygy-> In the acknowledgments.
08:09:03 * shapr boings cheerfully
08:09:05 <shapr> Yay!
08:09:06 <Syzygy-> The Haskell section has enjoyed the benefits of several experienced
08:09:06 <Syzygy-> Haskell programmers, most notably Shae Erisson.
08:09:09 <Syzygy-> That's the quote.
08:09:11 <Syzygy-> :)
08:09:15 * shapr feels very cool
08:09:45 <Igloo> Syzygy-: What's the paper, OOI?
08:09:59 <Syzygy-> "Enumerating the Saneblidze-Umble diagonal terms"
08:10:04 <dcoutts> fasta: dunno then, google self-signed certs
08:10:08 <Syzygy-> http://mpc723.mati.uni-jena.de/~mik/SaneblidzeUmbleSigns.pdf
08:10:15 <DRMacIver> i.e. "Really scary computational algebra"? :)
08:10:19 <fasta> dcoutts: what do you think I did in the last hours?
08:10:24 <Syzygy-> Yeah, basically.
08:10:31 <DRMacIver> Cool.
08:10:45 <Syzygy-> DRMacIver: Today I submitted the second paper to JHRS this summer.
08:10:59 <fasta> dcoutts: It seems easier to implement a complete PKI tool chain myself then to figure out the crap that is openssl
08:11:00 <Syzygy-> Hope they'll both get published with reasonable lack of headaches...
08:11:21 <dcoutts> fasta: that seems unlikely :-) sorry I can't help.
08:11:37 <DRMacIver> Syzygy-: Describing Haskell as one of the stricter functional languages amuses me.
08:11:42 <Syzygy-> Oh?
08:11:42 <Igloo> Syzygy-: The GHCi banner on the last page is messed up
08:11:52 <Syzygy-> Igloo: It is? *grumble* Hang on...
08:11:58 <DRMacIver> Syzygy-: Given that the Haskell specification requires it to be non-strict. ;)
08:12:06 <DRMacIver> (Yes, I know that's not the sense in which you meant it)
08:12:19 <Syzygy-> DRMacIver: I'm talking to algebraists, mm'kay?
08:12:37 <DRMacIver> Mmhmm. :)
08:12:40 <Syzygy-> Igloo: Oh bugger, yeah it is.
08:12:53 <Syzygy-> Igloo: It was decent once
08:12:55 <Syzygy-> Hmmmm....
08:12:57 <DRMacIver> Syzygy-: I didn't say it was wrong. Just that it amused me. :)
08:13:24 <ndm> @karma+ kpreid -- patch submitted, thanks!
08:13:24 <lambdabot> kpreid's karma raised to 1.
08:13:44 <Syzygy-> Igloo: Reload now.
08:13:57 <Syzygy-> Igloo: Apparently using amsart instead of the journal style messed up my verbatims.
08:15:19 <fasta> I keep getting: error 18 at 0 depth lookup:self signed certificate Nobody who has done this before here?
08:15:52 <shapr> Syzygy-: Section 4 is suddenly after the GHCi page instead of before.
08:16:11 <kpreid> ndm: scons: done building targets.
08:16:12 <Syzygy-> shapr: Yup. I blame amsart.
08:16:25 <ndm> kpreid: that should be everyting done now
08:16:25 <Syzygy-> shapr: This is the way I did write it originally - the GHCi page belongs to section 3.
08:16:45 <Syzygy-> For the arXiv preprint, I did a minimal code change - and among the things that happened was a float-dance.
08:16:48 <ndm> kpreid: yhc --linkcore File.hs should generate a .ycr file, you probably want to read our Yhc.Core paper to get a flavour of Yhc.Core
08:16:58 <kpreid> ndm: oh, and what worked to build: CCFLAGS="-I/Stuff/dp/include" LIBPATH=/Stuff/dp/lib scons
08:18:08 <ndm> kpreid: that probably wants to go on the wiki, or a help page, somewhere
08:18:27 <ndm> http://haskell.org/haskellwiki/Yhc/Building - there looks like a good place
08:18:28 <lambdabot> Title: Yhc/Building - HaskellWiki
08:19:12 <kpreid> it wants me to create an account.
08:28:18 <kpreid> ndm: done. please polish!
08:29:19 <ndm> kpreid: thanks!
08:31:03 <kpreid> so the difference between -core and -linkcore is that -linkcore pulls in other modules?
08:31:51 <psykotic> what's the reason newtypes and existentials aren't allowed together?
08:32:01 <psykotic> because newtypes don't do any "wrapping"?
08:32:18 <kpreid> existentials carry a dictionary, so they have runtime cost, which newtype isn't allowed to have. or so I understand
08:32:38 <psykotic> the reason i ask--newtypes in ghc have a nice feature for auto-deriving certain type classes
08:32:39 <kpreid> i.e. an existential isn't pointer-sized
08:32:55 <psykotic> so you can do... newtype MyInt = MyInt Int deriving Num
08:33:40 <psykotic> and it would be mighty nice to do something like that when you have, say, data Intersectable = forall a. IsIntersectable a => Intersectable a. i always end up defining the instance manually, by forwarding.
08:33:44 <kpreid> psykotic: there's something in the area of deriving and existentials or so that will prompt GHC to tell you its brain exploded, anyway; I don't think it'd work if you could say it anyway
08:34:01 <kpreid> psykotic: I've wanted to do that too
08:34:21 <ndm> kpreid: exactly, -linkcore produces a .yca (core, all), -core produces a .ycr (core of that module only)
08:34:39 <kpreid> ok.
08:37:45 <kpreid> ndm: http://haskell.org/haskellwiki/Yhc/Options appears to be stale/wrong: it shows options like -foo but yhc only seems to accept --foo
08:37:46 <lambdabot> Title: Yhc/Options - HaskellWiki
08:38:01 <ndm> kpreid: oh yes, that changed, feel free to update
08:38:20 <kpreid> all the non-single-letter options?
08:38:28 <ndm> yes
08:38:37 <ndm> we now use the standard GNU style options
08:38:39 <kpreid> ok, mass edit coming up
08:38:47 <dozer> what package provides MonadPlus?
08:39:03 <sjanssen> dozer: mtl
08:39:18 <hpaste>  aaim pasted "easier without lambda ?" at http://hpaste.org/1969
08:40:09 <dozer> sjanssen: weird - I've got that in build-depends and I'm getting Could not find module `Control.Monad.MonadPlus'
08:40:54 <sjanssen> dozer: it's defined in Control.Monad
08:41:01 <kpreid> ndm: done
08:41:15 <dozer> sjanssen: dho!
08:42:43 <kpreid> ndm: I was going to ask, typeclasses get resolved in Core, right? then I saw Prelude.Prelude.Enum.Prelude.Char.fromEnum
08:43:06 <ndm> kpreid: they do, as tuples of higher order functions
08:43:22 <kpreid> I assume readable-Core is not an unambiguous format, then
08:43:50 <kpreid> (which is ok; I wouldn't want to parse it anyway!)
08:44:27 * kpreid is *really* off doing other things now
08:44:45 <ndm> no, its not, we have a binary Core format, which we can then render
09:00:38 <roconnor> ndm: hey, does YHC compile to GHC core?
09:06:23 <sjanssen> @pl \xs -> let (ys, zs) = splitAt 2 in reverse ys ++ zs
09:06:24 <lambdabot> (line 1, column 12):
09:06:24 <lambdabot> unexpected "("
09:06:24 <lambdabot> expecting natural, identifier or "in"
09:06:28 <sjanssen> bah
09:07:12 <mcnster> gm.  fgl newbie q.  when i make "gmap (\(ins, node, label, outs) -> ... )", outs does not contain all the edges leaving the node.  i'm not sure why?
09:08:13 <mcnster> !hoogle gmap
09:09:02 <mcnster> anyone?
09:32:28 <kpreid> ndm: http://haskell.org/haskellwiki/Yhc/API/Core links to http://www.cs.york.ac.uk/fp/yhc/snapshot/docs/Yhc-Core.html which is blank
09:32:29 <lambdabot> Title: Yhc/API/Core - HaskellWiki
09:33:08 <shapr> Is there a recent FGL tutorial?
09:43:52 <roconnor> Hmm, I added a bunch of specialization pragmas for handleing Int's, and it runs faster when using Int64s. WTF?
09:44:03 <roconnor> This optimization stuff is magical.
09:44:26 <roconnor> oh wait
09:44:36 <roconnor> I also separated out two dictionaries.
09:44:45 <roconnor> I suppose that could cause some effect.
09:45:13 <sjanssen> roconnor: still working on ropes?
09:45:22 <roconnor> sjanssen: more or less.
09:45:35 <roconnor> sjanssen: GHC sucks at using abstract code.
09:45:55 <roconnor> but I couldn't figure out how to install JHC.
09:46:05 <sjanssen> JHC is probably not the answer
09:46:20 <roconnor> oh, what is the answer?
09:46:20 <sjanssen> it's still pretty buggy/slow/memory hungry
09:46:28 <roconnor> :(
09:46:33 <ivant> guys, how do I output unicode string to the console (which is actually in utf8)?
09:46:55 <roconnor> @go UTF8.hs
09:46:57 <sjanssen> ivant: sadly, this ability isn't built in to the standard library
09:46:58 <lambdabot> http://ogi.altocumulus.org/~hallgren/Talks/LHiH/base/lib/UTF8.hs
09:46:58 <lambdabot> Title: UTF8.hs
09:47:09 <sjanssen> ivant: you might check out the UTF-8 library on hackage.haskell.org
09:47:11 <ndm> roconnor: it can, or rather to low-level Haskell which GHC can then compile
09:47:18 <ivant> sjanssen, thanks a lot
09:47:43 <ivant> oh, roconnor, thank you too :-)
09:47:46 <ndm> kpreid: thanks for spotting that, thats a Haddock bug, i'll fix our code to work around it
09:48:06 <roconnor> ndm: Will YHC specialize these totally abstract modules?
09:48:17 <ndm> roconnor: Supero will#]
09:48:24 <roconnor> Sold
09:48:28 <roconnor> where do I sign up?
09:49:05 <ndm> roconnor: are you coming to AngloHaskell?
09:49:25 <roconnor> I try to avoid travelling to England whenever possible.
09:49:35 <ndm> its not worth travelling from abroad for
09:49:53 <roconnor> Well, the netherlands isn't very far away.
09:50:05 <ndm> i hope to finish the code this week, i have a paper to submit in about 6 hours, then want to get the Haskell Workshop one submitted tomorrow, then i'll have time for Supero once more
09:50:19 <kpreid> ndm: is there a yhci?
09:50:29 <dozer> I'm on ubuntu, getting "Setup.lhs: cannot satisfy dependency network-any" and have installed libghc6-network-dev via apt  - any ideas?
09:50:41 <ndm> kpreid: there was, i don't think its built, or works, anymore
09:50:48 <vincenz> Existentials are fun: http://programming.reddit.com/info/2al0d/comments/c2aq8e
09:50:49 <lambdabot> Title: On the value of strong static typing: "make illegal states unrepresentable" (red ...
09:50:51 <kpreid> ndm: or, can I process Core from ghc(i)?
09:50:53 <sjanssen> dozer: does 'ghc-pkg list' show network?
09:50:53 <roconnor> If epigram is using all this foldable traversable stuff, it must be dog slow.
09:51:07 <ndm> kpreid: do yhc File.hs --linkcore, that generates File.yca
09:51:30 <sjanssen> roconnor: foldable and traversable are slow?
09:51:36 <ndm> kpreid: then use the Yhc.Core library, from Hugs, GHCi, GHC or Yhc (i use Hugs)
09:51:44 <ndm> roconnor: what are you doing with foldable/traversable?
09:51:49 <sjanssen> roconnor: there's no reason the stuff from foldable should be any slower than foldr and friends
09:51:58 <roconnor> sjanssen: because they have to lookup the monoid operation every friggin' time.
09:52:11 <roconnor> ndm: fingertrees use foldable.
09:52:12 <ndm> roconnor: thats just poor optimisation, Supero definately fixes that
09:52:21 <ndm> roconnor: is looking up a tuple that slow?
09:52:45 <roconnor> ndm: it's slower that Prim.Int.+, or whatever it is called.
09:52:50 <sjanssen> roconnor: are you sure that's the bottleneck?
09:52:53 <ndm> +#
09:53:20 <roconnor> instead I have to box up integers, look up the function call it, unbox the integers add them, box them up, only for them to be unboxed moments later.
09:53:21 <ndm> roconnor: these are constant overheads, are you sure they are worth bothering with? i would have thought it would only give you 25% speed up at most
09:53:45 <roconnor> sjanssen: I'm not certain these are the bottlenecks.
09:53:49 <ndm> possibly more in a dead tight loop, but those loops never occur in real life
09:54:17 <roconnor> ndm: 25% sounds like a lot to me.
09:54:29 <ndm> kpreid: i use the page at http://www.cs.york.ac.uk/fp/yhc/snapshot/docs/index.html, then browse under Yhc.Core, its all there
09:54:30 <dozer> sjanssen: no, it shows some stuff, but not network or gfl, both of which I've apt-get'ted
09:54:51 <kpreid> ndm: I had found that
09:55:04 <roconnor> Lemmih made a specialied version of Fingertrees working on Ints, and if I recall got a 20% speed boost or so.
09:55:09 <daniel_larsson> dozer: have more than one ghc installed?
09:55:28 <ndm> kpreid: i'm just reporting the haddock bug, then will check in a fix
09:55:31 <sjanssen> roconnor: most of that is probably from unpacking the length into the tree leaves
09:55:45 <sjanssen> roconnor: instead of boxing them, that is
09:56:13 <roconnor> yeah, but wouldn't the values have to be boxed in order to call the monoid function.
09:56:15 <dozer> daniel_larson: possible, as I built from trunk last week, but then switched back to the packaged version - do libs get registered to particular installations of ghc?
09:56:54 <sjanssen> ndm: can Supero specialize the representation of data types?
09:57:28 <sjanssen> roconnor: depends.  The Int specialization might have allowed more inlining
09:57:43 <ndm> sjanssen: no, not generally, although if you give me a more concrete example?
09:57:59 * dcoutts thinks specialising data type representations is an important optimisation
09:58:04 <daniel_larsson> dozer: I believe so yes. I had that problem, when I had a HEAD installed in /usr/local. Check which ghc-pkg you're running (which ghc-pkg)
09:58:18 <sjanssen> ndm: Data.FingerTree keeps a measurement of subtrees in each node
09:58:35 <dozer> daniel_larson: yup - ghc-pkg is pointing at 6.6.1 where as ghc is pointing at 6.6 - dang, now to fix all those sym-links
09:58:45 <sjanssen> ndm: this measurement is automatically obtained from the data (via a Measure class)
09:59:08 <ndm> sjanssen: thats cacheing extra information, which is pretty hard to do automatically, and can introduce space leaks
09:59:25 <sjanssen> ndm: ideally, when our measurement is something like Int, we want to unpack the Int into the tree constructors
09:59:46 <ndm> i don't deal with unboxed'ness
10:00:19 <sjanssen> dcoutts: I agree.  Any idea on how to get it in GHC? :)
10:00:34 <kpreid> ndm: yhc --viewcore seems to want two arguments; what's the second one mean?
10:00:46 <ndm> kpreid: yhc --viewcore file.yca
10:00:58 <dcoutts> sjanssen: newtype wrappers and pragmas
10:01:04 <ndm> kpreid: you can do the same in Hugs with: loadCore "file.yca" >>= print
10:01:13 <kpreid> ndm: that yields "yhc: Prelude.tail: empty list"
10:01:17 <dcoutts> sjanssen: using a newtype gives us a convenient point for doing representation changes
10:01:31 <kpreid> ndm: if I "yhc --viewcore HETest.yca foo" it works and ignores foo
10:01:38 <dcoutts> sjanssen: and then we want to specify what to change, but have it be done automatically, like UNPACK
10:01:41 <ndm> kpreid: try it in Hugs/GHCi, i'll just check the viewcore
10:01:41 <sjanssen> dcoutts: how could we apply this to the fingertree example above?
10:01:53 <ndm> kpreid: thats a bug then, must have been when the command line parsing changed
10:02:16 <dcoutts> sjanssen: so assuming the finger tree is strict in its measurements, there's no reason we could not specialise it to Int and then unbox those ints
10:02:54 <ndm> sjanssen: it would be very hard to tell automatically that a data structure is strict in one particular field
10:03:09 <sjanssen> ndm: we already have annotations for that
10:03:41 <roconnor> data FingerTree v a
10:03:41 <roconnor>         = Empty
10:03:41 <roconnor>         | Single a
10:03:41 <roconnor>         | Deep !v !(Digit a) (FingerTree v (Node v a)) !(Digit a)
10:03:45 <ndm> sjanssen: true, but they are annotations that change the semantics, its much more polite to infer that stuff
10:04:47 <sjanssen> ndm: sure, inference is good.  But I don't think adding ! to strict components is a major issue
10:04:54 <sjanssen> ndm: it's already established practice
10:05:03 <vincenz> roconnor: \o/
10:05:08 <vincenz> fingertrees
10:05:16 <roconnor> vincenz: ?
10:05:22 <roconnor> vincenz: I didn't write it.
10:05:24 <ndm> sjanssen: i honestly can't see why its even slightly hard to make that change automatically, if the user went as far as to annotate it for you
10:05:25 <vincenz> I know
10:05:27 <vincenz> Data.Sequence
10:05:56 <dcoutts> ndm: I disagree, I think it's much nicer to state it up front, that way I don't have to go hunting around my code to find out where I'm being slightly too lazy, so the analysis infers that it's lazy overall.
10:06:18 <dozer> thanks for the help - got everything going now
10:06:33 <sjanssen> ndm: how do you generate code for 'forall a b. FingerTree a b -> foo' if there is data specialization?
10:06:43 <sjanssen> ndm: the representations are fundamentally different
10:07:03 <ndm> sjanssen: in that case you no longer have forall, its different already
10:08:07 <kpreid> ndm: working in ghci
10:08:38 <sjanssen> ndm: you mean that I can't apply a 'FingerTree Int Int' to that polymorphic function?
10:08:57 <dcoutts> sjanssen: exactly, that's why I think the newtypes are important
10:09:32 <ndm> sjanssen: with my methods you can't do data specialisation at the moment, but i know how it would be possible, but requires type information (which mine doesn't have)
10:10:47 <sjanssen> this seems similar to parallel arrays, which use associated data types
10:11:28 <sjanssen> they use class overloading to handle representation overloading
10:11:40 <ndm> yeah, if there was a class constraint, mine would have a chance
10:13:42 <sjanssen> dcoutts: so you suggest something like 'newtype SpecialFT = SFT (FingerTree Int) {#- SPECIALIZE SpecialFT -#}'?
10:14:03 <dcoutts> sjanssen: something like that
10:14:25 <roconnor> FingerTree (Sum (Int))
10:14:47 <sjanssen> roconnor: or anything, really
10:14:51 <dcoutts> sjanssen: I'd particularly like to do things like that for heavily layered monad transformers
10:15:56 <sjanssen> dcoutts: what happens with 'case x of (SFT y) ->'?  Then you've got 'y :: FingerTree Int'
10:16:24 <sjanssen> dcoutts: that 'y' with a special representation can't be passed to polymorhpic functions, can it?
10:17:24 <dcoutts> sjanssen: right, one has to do conversions on newtype wrapping/unwrapping or something
10:17:49 <roconnor> sjanssen: as an aside, am I right in thinking this woudln't be a problem in JHC where he does case analysis on types?
10:18:05 <sjanssen> roconnor: I have no idea
10:22:19 <shapr> Is MissingH broken?
10:22:29 <Nafai> Hi shapr!
10:22:43 * shapr smacks himself for making silly mistakes.
10:22:46 <shapr> hiya Nafai!
10:24:46 <sjanssen> perhaps Data.FingerTree should ship as a TH function that generates the specialized code? :P
10:31:07 <ndm> sjanssen: are you reinventing C++ templates? and if so, do you need a lesson on how evil they are?
10:31:25 <vincenz> :D
10:31:39 <Philippa> ndm: be fair, ML modules are substantially nicer than C++ templates...
10:31:52 <vincenz> Philippa: Sure, until you use functors
10:31:58 <vincenz> Foo<a>.Bar<b>.blabla
10:32:02 <SamB> Philippa: but TH doesn't let you implement those does it?
10:32:30 <Philippa> vincenz: nah, even with functors
10:32:59 <Philippa> SamB: it's pretty damn close and you could get a fairly simple encoding
10:33:34 <SamB> Philippa: but doesn't TH give you the same "too-late typechecking" that C++ templates give you?
10:34:13 <Philippa> point
10:34:22 <SamB> I suppose it would be somewhat nicer too-late typechecking, though
10:34:35 <Philippa> though you could do more to typecheck an encoded functor than you can do to typecheck a C++ template
10:34:38 <ndm> it also gives you a turing complete compile time language (number 2, in haskell's case)
10:34:50 <Philippa> yes, but TH is /meant/ to do that
10:34:58 <ndm> true
10:35:17 <Philippa> nothing wrong with it per se, and you know when you're using it
10:35:30 <ndm> but if the only reason for permitting these "evil templates" is for performance, then the optimisers aren't good enough
10:35:35 <Philippa> hell, I always meant to play with loading TH code in hs-plugins
10:36:00 <ndm> if a mechanism gives you more power, good, if it gives you more speed, fix the optimiser
10:36:09 <Philippa> I suspect the optimisers can't be made good enough
10:36:10 <SamB> TH gives you both
10:36:24 <SamB> well.
10:36:27 <Philippa> if only because the TH gives you power equivalent to arbitrary annotations
10:36:31 <SamB> lets you have them.
10:36:39 <Philippa> but yes, it's more power too
10:37:13 <Philippa> for example, you could use TH to have a database table declared in code and build the thing in the database when you compile the module and provide a suite of admin functions straight from the definition
10:37:38 <Philippa> if you're running a sufficiently big and long-lived system, coupling that with dynamic code loading is a very nice thing indeed
10:37:45 <ndm> yeah, and i'd say that would be a good thing
10:37:46 <SamB> Philippa: that sounds like a bad idea
10:37:56 <ndm> but if you use it for performance, i'd say you are going down a slippery slope
10:37:58 <mrd> functors are a key feature of the module system
10:38:03 <SamB> maybe generate the SQL to make the table or something
10:38:22 <mrd> the functionality of type classes is wrought with functors and modules in ML instead
10:38:24 <SamB> ndm: or maybe you are prototyping
10:38:47 <wli> I loved ML's functors.
10:39:02 <mrd> i did too, my only problem was  the obscure syntax and special cases
10:39:25 <vincenz> I love functors too
10:39:32 <vincenz> especially when they provided infix ops :D
10:39:37 <vincenz> a Foo<A>.+ b
10:39:46 <Philippa> SamB: sure. OTOH, logging assorted aspects of the compilation process becomes a good thing when it's part of a larger system
10:39:52 <wli> The way I think of it is that Haskell's typeclasss plus ML's functors would be a fearsome combination.
10:39:53 <Philippa> the ability to do compile-time IO's useful
10:40:07 <Philippa> wli: you're not the first person to think that :-)
10:40:12 <Philippa> hell, there're papers on unifying them
10:40:14 <SamB> wli: fearsome to who?
10:40:21 <SamB> you? me?
10:40:25 <SamB> Oleg?
10:40:40 <SamB> the average Python programmer?
10:40:45 <wli> SamB: All programming problems that fear being solved.
10:40:49 <SamB> ah.
10:40:54 <vincenz> wli: afaik, they're not combinablea
10:40:59 <mrd> http://ttic.uchicago.edu/~dreyer/papers/mtc/main-short.pdf
10:41:05 <mrd> modular type classes
10:41:41 <Philippa> vincenz: uh, it didn't take me long to dream up one approach to it, and it turned out to be somewhat different to the approach being taken in research
10:41:44 <dmead> ?losers
10:41:44 <lambdabot> Maximum users seen in #haskell: 368, currently: 358 (97.3%), active: 14 (3.9%)
10:41:55 <Philippa> (it's also not particularly interesting as an alternative, it just goes the "obvious" PTS route)
10:42:16 <wli> PTS?
10:42:40 <vincenz> Philippa: I remember reading something in regards to that a while back, but yes, I've seen (at a glance) Harper's paper
10:44:00 <SamB> @. pl djinn f::(a,b) -> (b,a)
10:44:00 <lambdabot> Cannot parse command
10:44:11 <SamB> @. pl djinn (a,b) -> (b,a)
10:44:11 <lambdabot> f = uncurry (flip (,))
10:45:47 <vincenz> @type (snd *** fst)
10:45:50 <lambdabot> forall a b a1 b1. ((a, b), (a1, b1)) -> (b, a1)
10:45:54 <vincenz> @type (snd &&& fst)
10:45:56 <lambdabot> forall a b. (a, b) -> (b, a)
10:46:13 <mrd> nice
10:50:57 <SamB> okay, what was that function to generate ["","a","b","aa","ab","ba","bb"...] or whatever?
10:51:31 <vincenz> SamB: oh that one?
10:51:34 <vincenz> let me get it
10:52:20 <vincenz> > let makeSupply inits tails = let vars = inits ++ (map concat . sequence $ [vars, tails]) in vars in makeSupply [""] ["a", "b"]
10:52:22 <lambdabot>  ["","a","b","aa","ab","ba","bb","aaa","aab","aba","abb","baa","bab","bba","b...
10:53:07 <vincenz> you could simplify it if you know your elements are always single characters
10:55:16 <DRMacIver> You can probably do something cunning with [1..] and Data.Bits. But I can't figure it out at the moment. :)
11:01:50 <roconnor> when I -ddump-simp, what do all the @'s mean?
11:02:06 <roconnor>                 Data.FingerTree.appendTree01
11:02:06 <roconnor>                   @ Data.ByteString.Rope.Chunk Data.ByteString.length ds_d2s2 ds1_d2s3
11:02:15 <dcoutts> roconnor: type application
11:03:03 <roconnor> So Data.ByteString.Rope.Chunk is a type rather than a constructor?
11:03:17 <dcoutts> seems so
11:03:17 <mux> > map (\x -> showIntAtBase 2 (\x -> case x of; 0 -> '0'; 1 -> '1'; _ -> undefined) x "") [1..]
11:03:26 <lambdabot>  ["1","10","11","100","101","110","111","1000","1001","1010","1011","1100","1...
11:03:37 <roconnor> dcoutts: the have the same name, so I guess it is confusing :)
11:03:47 <dcoutts> roconnor: core is typed lambda calculus, so the type lambdas and applications are explicit
11:04:19 <dcoutts> roconnor: yeah, it is confusing, we need a better presentation of core
11:04:32 <roconnor> dcoutts: colours!!
11:04:45 <dcoutts> roconnor: yes, and hyperlinks :-)
11:04:53 <roconnor> perfect!
11:05:54 <shachaf> Is there any point in adding "_ -> undefined" in a case?
11:06:10 <roconnor> shachaf: warning suppression?
11:06:13 <mux> shachaf: avoiding warnings
11:06:28 <shachaf> In lambdabot?
11:06:35 <shachaf> > map (\x -> showIntAtBase 2 (\x -> case x of; 0 -> '0'; 1 -> '1') x "") [1..]
11:06:37 <lambdabot>  ["1","10","11","100","101","110","111","1000","1001","1010","1011","1100","1...
11:06:46 <mux> not in lambdabot obviously, but you get used to it
11:07:05 <shachaf> I guess.
11:10:08 <dV_> > map (\x -> showIntAtBase 2 (last.show) x "") [1..]
11:10:09 <lambdabot>  ["1","10","11","100","101","110","111","1000","1001","1010","1011","1100","1...
11:10:44 <mux> right
11:11:20 <mux> > map (\x -> showIntAtBase 2 intToDigit x "") [1..]
11:11:22 <lambdabot>  ["1","10","11","100","101","110","111","1000","1001","1010","1011","1100","1...
11:28:39 <dmead> > showIntAtBase 5 [1..]
11:28:40 <lambdabot>  Couldn't match expected type `Int -> Char'
11:28:53 <dozer> how do I go about implementing Eq for:
11:28:53 <dozer> data Any s where Any :: s t -> Any s
11:29:22 <dmead> you don't want to using derriving?
11:29:38 <dmead> :t  showIntAtBase
11:29:40 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
11:30:16 <dozer> dmead: love to, but ghc says: Can't make a derived instance of `Eq (Any s)' (`Any' has non-Haskell-98 constructor(s))
11:30:40 <dmead> ahh
11:31:02 <dmead> right so you have to declare an instance manually
11:31:32 <sjanssen> ndm: re. C++ templates: yes, I want C++ templates that don't suck :)
11:31:59 <dozer> yup - and I'm not sure how to go about it, since the type of t is hidden
11:34:12 <SamB> hey, rehges in #oasis says he learned more about monads by reading the Prelude than from tutorials ;-)
11:34:20 <dozer> this doesn't work: instance Eq (Any s) where  (Any a) == (Any b) = a == b
11:34:39 <SamB> or at least more about the connection between Haskell monads and actual monads
11:34:44 <rehges> samb: i said the four lines in the prelude made me understand what they are
11:34:57 <rehges> samb: not quite the same as what you say :-)
11:35:12 <SamB> hmm.
11:35:20 <SamB> well I thought you said that
11:35:36 <sjanssen> monads aren't that hard
11:35:44 <SamB> no, they aren't ;-)
11:35:48 <sjanssen> we need to stop saying they are!
11:36:22 <SamB> maybe people wouldn't be scared if there weren't so many different tutorials ;-)
11:36:25 <roconnor> dozer: don't you need s t to be an instance of Eq?
11:37:14 <dozer> roconnor: well, yes, but (s t) is hidden inside the Any constructor
11:37:45 <rehges> learning about monads by starting with IO is a really bad plan i think
11:38:21 <roconnor> dozer:  then maybe you want Any :: forall t. (Eq s t) => s t -> Any s ?
11:38:43 <sjanssen> rehges: which monad made you "get it"?
11:38:48 <roconnor> maybe withe more parenthesis.
11:38:58 <rehges> just the abstract definition
11:39:01 <sjanssen> I think Maybe might be a good one to start with
11:39:06 <dozer> roconnor: that's fine, but in the definition for Eq (Any s) it can't work out if the two Any instances are over the same t or a different t
11:39:13 <rehges> yeah, Maybe is nice
11:39:16 <SamB> you mean...
11:39:18 <SamB> @src Monad
11:39:19 <lambdabot> class  Monad m  where
11:39:19 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
11:39:19 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
11:39:19 <lambdabot>     return      :: a -> m a
11:39:19 <lambdabot>     fail        :: String -> m a
11:39:23 <rehges> yes
11:39:32 <SamB> hmm.
11:39:34 <rehges> without that forall nonsense
11:39:40 <SamB> rehges: hmm.
11:39:59 <SamB> @ask dons what is the point of the foralls in @src Monad
11:39:59 <lambdabot> Consider it noted.
11:40:23 <rehges> samb: that's just because the bot runs with extensions on
11:40:44 <shachaf> rehges: No, @src is differenet.
11:40:49 <SamB> rehges: I think it is actually a case of user error
11:40:50 <shachaf> rehges: (I think).
11:41:03 <SamB> where "user" probably means "dons"
11:41:07 <rehges> well ghci does the exact same thing with -fglasgow-extensions
11:41:10 <roconnor> dozer: oh, that's a bit of a problem.
11:41:19 <ihope> If I want small binaries, does that mean I should probably use jhc?
11:41:20 <SamB> rehges: notice that fail and return don't have that nonsense
11:41:32 <shachaf> @instances Monad
11:41:40 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
11:41:58 <lament> is there a tutorial somewhere on actually using haskell for writing programs?
11:42:17 <Philippa> it's a bit hard to do a single tutorial on that
11:42:23 <Philippa> it depends rather a lot on what you want to do
11:42:49 <shachaf> @wiki How to write a Haskell program
11:42:49 <lambdabot> http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
11:42:51 <ihope> lament: Write Yourself a Scheme in 48 Hours?
11:43:13 <Philippa> lament: what do you reckon you're missing how to do?
11:43:23 <lament> shachaf: thanks, looks interesting
11:44:19 <dozer> rconnor: yeah, it is
11:44:40 <dozer> rconnor: I keep hitting effectively this same problem
11:45:48 <roconnor> well, given that a and b might not have the same type, there is very little you can do with two of them.
11:46:13 <dozer> roconnor: well, they are clearly not equal if they are of different type, and if they are the same type then the normal Eq operator will work
11:46:38 <roconnor> dozer: maybe you want to use this typeable crazy stuff.
11:47:55 <dozer> roconnor: all I realy want is to be able to use GADTs and stuff the datastructures into homogeneous lists and maps and things, like I would normal data types
11:47:55 <roconnor> dozer: do undefined and 5 have the same type?
11:48:16 <dozer> roconnor: I'm guessing undefined::Int and 5::Int do
11:48:39 <roconnor> dozer: what about undefined :: forall a. a
11:50:13 <dozer> roconnor: good question - I'm guessing not
11:50:32 <roconnor> dozer: once you stuff random datastructures in to lists, what do you intend to do with them?
11:51:14 <dozer> roconnor: they are all productions in a logic language, and there are standard re-write rules that implement a decision procedure to see if the productions are mutually consistent
11:51:54 <ihope> Is this valid: class Foo a where foo :: Integer
11:52:02 <roconnor> So why don't you make a list of productions rather than a list of anys?
11:52:21 <roconnor> maybe I don't understand what you are trying to do.
11:52:24 <dozer> ihope: class (Integer a) => Foo a
11:53:13 <dozer> roconnor: I can't do a list of productions directly as they are in a GADT, so all have incompattible types :(
11:53:17 <sjanssen> ihope: no
11:53:38 <roconnor> dozer: what types do productions have?
11:53:48 <EvilTerran> ihope, i think any attempt to do that will result in a compiletime error, as the system can't tell which instance of Foo to use when the code says "foo 1"
11:54:08 * roconnor begins to understand.
11:54:55 <hpaste>  dozer pasted "logic concepts" at http://hpaste.org/1970
11:55:10 <dozer> so the GADT is Concept
11:56:41 <roconnor> dozer: and you want to take a list of things and decide if they are mutually consistent?
11:57:12 <EvilTerran> @where GADT
11:57:12 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/gadt.html
11:59:47 <roconnor> dozer: I'm not an expert, but I'm not convinced you should be using GADTs here like that.
11:59:53 <dozer> roconnor: so, a rewrite rule may spot (CConjunction a b) and add both a and b to the current set of working concepts
12:00:14 <roconnor> dozer: because all your constructors are polymorphic in their recursive argument.
12:00:37 <roconnor> dozer: the GADTs don't rule out illegal productions (which I would think of as the main use of GADTs).
12:01:09 <dozer> roconnor: doing that let me write ToNNF in a way that's checked as being sane by the compiler
12:01:24 <roconnor> dozer: okay, I see that now.
12:03:09 <roconnor> dozer: Concept t can be an instance of Eq right?
12:03:44 <dozer> roconnor: yeah, but then it would be Concept t that's the instance, so I can't get out neq for e.g. CNamed vs CEqual
12:03:57 <roconnor> dozer: isn't that good enough?
12:04:04 <matthew-_> st andrews are on university challenge tonight
12:04:31 <roconnor> dozer: I mean you'd take a concept out of a list
12:04:40 <roconnor> dozer: then do a case analysis on it.
12:04:55 <roconnor> and in each branch you would do something.
12:05:01 <dozer> back up a bit - how do I get a CNamed and a CEqual into the list in the first place?
12:05:28 <roconnor> dozer: existental types.  I think your Any t thing is pretty close.
12:05:42 <roconnor> [forall t. Concept t]
12:05:59 <roconnor> but you probably need to wrap that type up in a data constructor.
12:06:08 <roconnor> (the inner part)
12:06:29 <EvilTerran> surely you'd want [exists t. Concept t]
12:06:34 <EvilTerran> (this isn't really haskell)
12:06:45 <roconnor> EvilTerran: ah, right
12:07:00 <roconnor> so let's see
12:07:56 <roconnor> data AnyConcept where AnyConcept :: forall t. Concept t -> AnyConcept
12:08:10 <roconnor> which is pretty much the same as your Any type
12:08:16 <roconnor> except I threw in a forall t.
12:08:35 <roconnor> I'm not sure if that is necessary, it could be implied.
12:08:58 <nominolo> @seen jyp
12:08:59 <lambdabot> I saw jyp leaving #xmonad, #oasis and #haskell 1d 5h 57m 47s ago, and .
12:09:04 <roconnor> dozer: anyhow, let's assume your Any type works.
12:09:14 <roconnor> So now you can have your list [Any Concept]
12:10:17 <roconnor> Now, you probably cannot make Any t an instance of Eq
12:10:27 <roconnor> but it is easy to make Any Concept an instance of Eq.
12:10:41 <dcoutts> @seen Lemmih
12:10:42 <lambdabot> Lemmih is in #haskell. I last heard Lemmih speak 6h 37m 12s ago.
12:11:31 <dozer> data Any s where  Any :: s t -> Any sinstance Eq (Any Concept) where  (Any a) == (Any b) = a == b
12:11:37 <dozer> oops - try again...
12:12:16 <dozer> data Any s where  Any :: s t -> Any s
12:12:16 <dozer> instance Eq (Any Concept) where  (Any a) == (Any b) = a == b
12:12:16 <dozer> Couldn't match expected type `t' (a rigid variable)       against inferred type `t1' (a rigid variable)
12:12:25 <Lemmih> dcoutts: Yo.
12:12:32 <roconnor> dozer: you will have to do a case analysis on a and b.
12:12:50 <roconnor> dozer: What may be better is to just make AnyConcept directly.
12:12:51 <dcoutts> Lemmih: I'm having trouble building SDL-ttf, seems to be a missing .h file
12:13:01 <roconnor> dozer: because then maybe deriving Eq will work.
12:13:08 <Lemmih> dcoutts: Have you installed libsdl-ttf?
12:13:13 <dcoutts> Lemmih: the SDL-ttf.cabal file specifies Includes: Graphics/UI/SDL/TTF/Wrapper.h
12:13:32 <dcoutts> Lemmih: but that file does not seem to exist. Yes, I installed the C lib.
12:13:52 <dozer> roconnor: gotcha - plumbing that through now
12:14:46 <dcoutts> Lemmih: is that file supposed to be generated? The Wrapper.c file is in the tarball, but the Wrapper.h is not.
12:16:00 <Lemmih> dcoutts: Ah, I need to mention the .h file in the cabal file.
12:16:21 <dcoutts> Lemmih: it is mentioned in the .cabal file, but it doesn't exist.
12:16:35 <dcoutts> Lemmih: the file itself is missing, though it's referenced and needed.
12:17:06 <Lemmih> dcoutts: Right, 'cabal-setup sdist' needs to be aware of it.
12:17:18 <dcoutts> Lemmih: ah, I see what you mean.
12:17:27 <ihope> Is there a nice way to access the entire Win32 API from Haskell?
12:17:35 <dcoutts> ihope: the Win32 package
12:17:47 <ihope> That offers the whole thing?
12:18:00 <dcoutts> most of it
12:18:33 <sjanssen> ihope: you're planning on using the whole thing? :)
12:19:03 <ihope> Hmm... indeed, there might be a part or two I won't be using. :-)
12:19:47 <Lemmih> dcoutts: Fixed, pushed and uploaded.
12:20:13 <dcoutts> Lemmih: thanks! :-) it'll be appearing in a gentoo near you shortly...
12:22:05 <dcoutts> Lemmih: new version number? I wonder how long it takes for it to appear on hackage
12:22:53 * Lemmih was too lazy to bump the version number.
12:23:14 <dcoutts> Lemmih: it doesn't appear to have updated as far as I can see
12:23:28 * edwardk smacks himself upside the head as he realizes that the writer monad is just the reader comonad with a monoidal environment, to uniquely provide bind and return.
12:23:37 <Lemmih> dcoutts: First item on the What's New list.
12:23:51 <dcoutts> Lemmih: I know, but the tarball does not appear to have changed
12:24:17 <dcoutts> unless it's just some web cache in the way
12:24:28 <edwardk> noting that censor = local gave it away to me
12:24:39 <edwardk> :t censor
12:24:42 <lambdabot> forall w (m :: * -> *) a. (MonadWriter w m) => (w -> w) -> m a -> m a
12:24:44 <edwardk> :t local
12:24:45 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
12:25:01 <sorear> edwardk: yes, but ask /= tell...
12:25:28 <sorear> edwardk: Writer is like a co-Reader... how is it like a Reader?
12:25:37 <Lemmih> dcoutts: Must be a cache issue.
12:25:50 <edwardk> sorear: per the earlier discussion about conflating Reader/Writer/State, ask = get, tell = put
12:26:09 <roconnor> Lemmih: aaaaah, the fact that Int64 runs faster than Int is driving me insane!
12:26:26 <dcoutts> Lemmih: yep, seems so
12:26:32 <SamB> roconnor: what the heck?
12:26:32 <edwardk> sorear: the reader comonad is the (,)e comonad. where ask = fst, local = first
12:26:43 <Lemmih> roconnor: You're not on a 64bit box by any chance?
12:26:53 <SamB> Lemmih: I sure hope he is!
12:26:59 <nopcode> who isnt?
12:27:03 <SamB> me
12:27:04 <Olathe> Me.
12:27:09 <nopcode> ha-ha </nelson>
12:27:17 <SamB> but I'd be scared if Int64 was faster than Int on a 32-bit box
12:27:41 <roconnor> Lemmih: my laptop isn't 64 bit as far as I know.
12:27:58 <edwardk> if you look at writer its newtype Writer w a = Writer { runWriter :: (a,w) }  which is just a flipped (,)e comonad with constructor baggage
12:28:00 <roconnor> Lemmih: but now that you mention it, the other computer is 64 bit. ... It's just running in 32 bit mode.
12:28:10 <sorear> roconnor: WHen you switch to Int, how many fromIntegrals do you add?
12:28:12 <Lemmih> roconnor: Int64 should be hugely expensive in that case.
12:28:20 <roconnor> sorear: one.
12:28:40 <sorear> roconnor: fromIntegral is extremely slow normally, since in the absense of RULES it goes via Integer
12:28:41 <ihope> So one Win32 API call I'm after, SetConsoleCursorPosition, doesn't seem to be in System.Win32 or System.Win32.Console.
12:28:54 <sorear> roconnor: How many times do you call it?
12:28:57 <roconnor> sorear: It appears to be optimized away.
12:29:31 <sorear>     Could not deduce (Monoid (a, c))
12:29:31 <sorear>         from the context (Monoid a, Monoid c)
12:29:47 <sorear> but... there is only one law-satisfying instance!
12:29:58 <roconnor> sorear: more than 121462671 times
12:30:03 <Lemmih> roconnor: Are you on windows?
12:30:10 <roconnor> Lemmih: ubuntu
12:30:25 <sjanssen> sorear: two, the one you expect, and flip mappend
12:30:29 <Lemmih> roconnor: Why are you running in 32bit mode, then?
12:30:38 <roconnor> sorear: is my profiler misleading me?
12:30:59 <roconnor> sorear: does putting in a call center stop it from being optimized away?
12:31:04 <edwardk> even if the parameter isn't a monoid you can implement the comonad interface over 'Writer e' or equivalently (,)e. extract = snd; extend wa@(w,_) f = (w,f wa)
12:31:07 <dcoutts> roconnor: yes
12:31:10 <sorear> roconnor: Yes.
12:31:14 <sjanssen> sorear: of course I agree there should be an instance in Data.Monoid :)
12:31:28 <edwardk> but to derive return you need an identity for the the left side of the pair (mempty) and an operation to glue them together (mappend), you don't need those to build the comonad.
12:31:53 <edwardk> er you only need mappend to derive (>>=)
12:32:51 <roconnor> god damn profiler.
12:33:56 <roconnor> Lemmih: I don't know.  It's a university computer.
12:34:02 <dcoutts> CosmicRay: ping
12:34:07 <CosmicRay> pong
12:34:07 <roconnor> Lemmih: I suppose it is there for backwards compatability for somethng.
12:34:15 <roconnor> Lemmih: I could chroot to 64 bit mode.
12:34:23 <roconnor> Lemmih: I'd have to install new ghc I suppose.
12:34:23 <dcoutts> CosmicRay: the hpodder package you uploaded to hackage is missing all the other-modules: files
12:34:41 <CosmicRay> hrm.  why, I wonder?
12:34:46 <CosmicRay> cabal bug?
12:34:53 <CosmicRay> or am I misunderstanding something?
12:34:55 <dcoutts> CosmicRay: because they're not listed in other-modules: in the executable section cabal does not know about them, so does not include them into the sdist tarball.
12:35:28 <CosmicRay> ah.
12:35:31 <dcoutts> the solution is to list all the other module in the other-modules: field in the .cabal file
12:35:33 <_Nucleo> @src intersect
12:35:34 <lambdabot> intersect = intersectBy (==)
12:35:36 <CosmicRay> ugh, that's annoying.
12:35:39 <CosmicRay> but ok.
12:35:47 <edwardk> @paste
12:35:48 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:35:56 <dcoutts> CosmicRay: one day cabal will get dep chasing and be able to warn you about that problem.
12:36:00 <roconnor> There is a way to remove a call centre right?
12:36:40 <dozer> roconnor: I can't make the pattern-match approach work
12:36:41 <msouth> roconnor: with a well-placed laser and air support
12:37:02 <dozer> (Any e1@(CEqual (_::Concept a) (_::Concept b))) == (Any e2@(CEqual (_::Concept a) (_::Concept b))) = e1 == e2
12:37:16 <CosmicRay> dcoutts: is there a way in hackage to see all the packages that depend upon another package?
12:37:21 <CosmicRay> for instance, so I can see everything that uses hdbc?
12:37:29 <dozer> Expected type: Concept a1      Inferred type: Concept a
12:37:41 <dcoutts> CosmicRay: not yet, only direct deps, not reverse deps. But you're not the only one to ask for it.
12:38:30 <Lemmih> roconnor: Perhaps GHC is already in 64bit mode.
12:38:30 <hpaste>  edwardk pasted "implicit configurations for numerical type classes? worth implementing in general?" at http://hpaste.org/1971
12:38:46 <roconnor> dozer: that doesn't look right
12:39:54 <roconnor> (Any (CEqual x0 y0)) == (Any (CEqual x1 y1)) = (Any x0) == (Any x1) && (Any y0) == (Any y1)
12:40:24 <edwardk> toying with the idea pasted there to use the Oleg/Shan implicit configuration trick to transform a user supplied function as a magma or monoids, or pretty much any type class. the approach is formulaic enough i could add it to the template haskell generator for my painful typeclass structure.
12:40:53 <edwardk> link to trick: http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
12:41:30 <mnislaih> edwardk:  is this the lifting types to constraints idea we were commenting last week ?
12:42:36 <roconnor> Lemmih: but then wouldn't Int == Int64?
12:42:51 <edwardk> mnislaih: something a little different. its lifting terms into types through stable pointers, then using that fact and universal quantification to basically ensure that you use the same functions and notion of zero throughout the computation.
12:43:51 <edwardk> i.e. normally if you wanted to define a new Monoid you'd go through the trouble of defining a newtype for it and defining an instance of Monoid for it, right?
12:43:52 <Lemmih> roconnor: Yeah. Maybe the speed difference is random noice.
12:44:53 <mnislaih> edwardk: yep
12:45:01 <edwardk> but say you wanted one for modular arithmetic (to hit the example from Oleg's paper), then you don't want to carry around the modulus at the term level it has to be carried at the type level so you can ensure that you always use the same modulus across the computation. so it should be a phantom type argument.
12:45:29 <edwardk> so one way to handle that is to define type level integers or something and carry it that way
12:45:31 <shachaf> What happened to all the @karma?
12:45:46 <SamB> shachaf: I heard something about a power outage
12:45:53 <roconnor> Lemmih: it is both consistent and signifigant. 10% or 20%
12:45:54 <mnislaih> the funny thing is that here you are doing the same thing, but at the constraint level
12:46:06 <shachaf> The quotes seems to be there.
12:46:07 <shachaf> @quote
12:46:07 <lambdabot> gFunk says: [the main advantage of functional programs are that they're] incorrect the first 1000 times you try to compile it!
12:46:16 <roconnor> dozer: did my case work?
12:46:21 <shachaf> s/seems/seem/
12:47:09 <edwardk> another way is to come up with a way to reify terms into types using some typeclass hackery and rank-2 types, then rely on unification to ensure that you always use the same parameter for the thing you quantify over, like the ST monad.
12:47:43 <edwardk> then by abusing the notion of a stable pointer you can lift anything to the type level, functions, etc. not just integers.
12:47:48 <edwardk> and ensure that its used consistently
12:47:57 <dozer> roconnor: just a sec - having trouble with brackets or something...
12:48:18 <mnislaih> edwardk I dont' understand the role of stable pointers here. Are they used just to unsafeCoerce things ?
12:48:40 <edwardk> mnislaih: the idea is this, a stable pointer can be converted to an integer and back safely no?
12:48:50 <edwardk> even if its a stable pointer to a function or something scary.
12:49:02 <SamB> edwardk: I thought the idea was that it can be converted to a Ptr and back
12:49:12 <SamB> though the Ptr won't point at anything interesting
12:49:23 <SamB> (necessarily)
12:49:34 <edwardk> samb: well, to marshal it through the type system using the oleg trick.
12:49:43 <SamB> the oleg trick?
12:49:46 <dozer> roconnor: yup, that's behaving
12:49:57 <edwardk> samb: http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
12:51:06 <roconnor> dozer: \o/
12:51:28 <edwardk> so you take your term, transform it into a stable pointer, then reify that as an integer into a type-level integer, then you can reflect that integer down to the term level, and transform it back into a stable pointer, giving you a way to basically force 'term-level' unification in limited contexts.
12:52:21 <edwardk> add a little bit of magic so you don't leak memory each time you round-trip a term and you're done
12:53:02 <mnislaih> ouch, that's a lot of magic
12:53:48 <SamB> edwardk: I don't remember the FFI addendum saying you can cass them to integers safely
12:54:07 <SamB> er. cast.
12:54:24 <pjd> cuss them to integers? :)
12:54:41 <edwardk> anyways with it you can do something like define a withMonoid :: (a -> a -> a) -> a -> (forall s. ReflectMonoid s a => MkMonoid s w) -> w, where you provide the function and 'zero' and the forall ensures that the same function and zero are used throughout the computation.
12:55:36 <mauke> SamB: they don't cast, they go through Storable :-)
12:55:46 <mauke> which gives you a string, which is a list of integers
12:55:59 <SamB> um.
12:56:01 <SamB> okay.
12:56:06 <edwardk> samb: iirc Stable is Storable, so you can transform it into an array of characters, then reify that
12:56:20 <SamB> that sounds pretty damn sick!
12:56:24 <edwardk> @instances Storable
12:56:25 <lambdabot> Couldn't find class `Storable'. Try @instances-importing
12:56:26 <augustss> it is!
12:56:33 <SamB> how is that useful AT ALL?
12:56:49 <mauke> read the paper, it has examples and stuff
12:57:18 <edwardk> samb: because you can carry around arbitrary term level functions and things in the form of phantom type parameters.
12:57:37 <augustss> it's quite useful.  but I think it's also quite slow
12:58:06 <edwardk> it seems like it is only slow on the first round trip. after that the way its implemented in the paper the thunk is evaluated and its generally free.
12:58:08 <SamB> and it sounds leaky too
12:58:27 <SamB> or very very constraining
12:58:48 <augustss> but you can do some very cool stuff with it.
12:59:01 <edwardk> it leaks only if you don't subsequently reflect the type at least once.
12:59:17 <dozer> roconnor: thanks for your patience and help :) I think I can get my stuff coded up from here
13:00:04 <roconnor> dozer: I enjoyed the puzzle.
13:00:05 <dolio> Being able to do typed modular arithmetic where the modulus is only specified at runtime is neat, at the very least.
13:00:05 <reffie> how do you make circular lists in haskell?
13:00:19 <opqdonut> reffie: cycle
13:00:21 <edwardk> In my toy prelude I have to use template haskell hackery to generate almost all of my instances anyways, so i'm debating about while I'm at it automatically generating the machinery to reify and reflect term-level dictionaries into instances of the typeclass in question.
13:00:30 <opqdonut> > cycle [1,2,3]
13:00:32 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
13:00:38 <matthew-_> toy prelude?
13:00:40 <opqdonut> that makes an infinite list by tying the end to the start
13:00:44 <reffie> opqdonut but how is it implemented? :)
13:00:56 <opqdonut> ?src cycle
13:00:56 <lambdabot> cycle [] = undefined
13:00:56 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
13:01:03 <opqdonut> ?wiki tying the knot
13:01:03 <lambdabot> http://www.haskell.org/haskellwiki/tying_the_knot
13:01:27 <opqdonut> http://www.haskell.org/haskellwiki/Tying_the_Knot <-- this rather
13:01:28 <lambdabot> Title: Tying the Knot - HaskellWiki
13:01:34 <edwardk> matthew-_: basically going through kind of in the spirit of 'The Other Prelude' and making painful sweeping generalizations to the existing prelude that maybe aren't really practical in Haskel but let me explore language features i want to play with.
13:01:36 <opqdonut> laziness makes it happen as if by magic
13:01:36 <reffie> thanks
13:01:39 <opqdonut> nw
13:01:40 <sam__> quit
13:01:40 <augustss> there's no absolute guarantee it will be implemented as a circular list though.
13:02:03 <augustss> even if most implementations do
13:04:15 <ihope__> @kind []
13:04:16 <lambdabot> * -> *
13:04:20 <ihope__> @kind Prelude.[]
13:04:22 <lambdabot> parse error on input `.'
13:04:25 <ihope__> Bah.
13:04:34 <ihope__> @kind Prelude.Maybe
13:04:36 <lambdabot> * -> *
13:04:39 <ihope__> Yup...
13:04:57 <edwardk> matthew: so, breaking out mathematical operators into magmas, monoids, groups, etc. breaking up monad into parts and putting it back together to get functor and applicative in the chain with some TH machinery to glue in the default method declarations so I don't go insane, etc. (.) as fmap,
13:04:59 <edwardk> potentially conflating the APIs for reader/writer/state monads, possibly mnislaih's parameterized exception monad
13:05:00 <edwardk> etc
13:05:22 <nominolo> hm, anyone remember that paper where they used type classes to carry environmental information?  e.g. which modulus to use for some arithmetic operation?
13:05:33 <edwardk> nominolo: its that paper i linked to above
13:06:46 <sorear> The problem with this is the eg in Haskell it's impossible to distinguish between magmas and semilattices, since the laws are erased.
13:07:11 <ihope> Is class Foo a | -> a where . . . valid? :-)
13:07:22 <edwardk> ihope: yep
13:07:36 <edwardk> ihope: i've used it a few times to ensure that a typeclass isn't extended outside of the module it is defined in
13:07:45 <ihope> Does that only allow one instance?
13:07:52 <nominolo> edwardk: heh, thanks
13:08:00 <edwardk> yeah
13:08:49 <edwardk> http://comonad.com/haskell/type-int/src/Data/Type/Boolean.hs uses it to ensure that you don't extend the type level Booleans types to more than T and F.
13:11:35 <edwardk> data Closure; class Closed a | -> a; instance Closed Closure; .... then you can use that in the LHS of a class definition class (Closed c) => ClosedFoo c x | x -> c; ... and then derive from that to finish concealing it, class (ClosedFoo Closure x) => Foo x; ... to make a closed typeclass that can't be extended outside of the module where 'Closure' is defined unless you export Closure.
13:15:07 <edwardk> ihope: i use that trick a lot actually, any time I want to make sure that someone won't subvert the correctness of a closed set of instances by extending it on me.
13:15:24 <ihope> It's a little hackish, though, no?
13:15:39 <edwardk> ihope: well, there isn't a good alternative is there?
13:15:52 <ihope> Apart from extending the language, I don't see one.
13:16:00 <edwardk> yep =)
13:16:05 <dozer> I'm working in MonadPlus, and have a list of items in 'toAdd'. What do I do to toAdd to make it behave as if I've mplus-ed them all together (e.g. forked execution on each one)?
13:16:13 <ihope> Though extending the language is not an impossible thing to do.
13:16:40 <EvilTerran> ...does "|-> a" having those semantics fall out naturally, or is it a special case?
13:16:44 <Cale> dozer: apply msum to the list?
13:16:51 <edwardk> @type msum
13:16:53 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
13:16:55 <roconnor> @type msum
13:16:56 <edwardk> @src msum
13:16:57 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
13:16:57 <lambdabot> msum =  foldr mplus mzero
13:17:03 <dozer> ah, sweet
13:17:04 <ihope> EvilTerran: I think it pretty much does it all naturally.
13:17:36 <EvilTerran> seems to me that "<nothing> -> a" shouldn't do anything
13:17:40 <ihope> class Foo a b | a -> b requires that every a does with only one b.
13:17:53 <ihope> s/does/goes/
13:18:05 <mnislaih> *slightly offtopic* How do I ask lhs2Tex to use a tt font  in poly style ?
13:18:23 <ihope> That is, it doesn't allow b to be different if a is the same.
13:18:25 <EvilTerran> ah... "a b -> c" means c is unique, given any a and b
13:18:27 <edwardk> EvilTerran: it says that a can be uniquely determined with no additional information
13:18:30 <ihope> Yes.
13:18:44 <ihope> And -> a means that a is unique given nothing at all.
13:18:48 <EvilTerran> and "| -> a" means a is unique, always
13:19:05 <mnislaih> err... I wish the author (kosmikus) was around ...ahem..
13:19:18 <kosmikus> I am
13:19:35 * ihope nods
13:19:46 <mnislaih> :) So how do I replicate example 4.6  ?
13:20:03 <mnislaih> I can't find a directive to change the font used
13:20:23 <kosmikus> I think it requires to change a number of things
13:20:26 <edwardk> Cale: preference quiz, should I call it 'foldr' or 'cata'? =
13:20:28 <edwardk> er =)
13:20:43 <mnislaih> I don't want to change the keywords, only the font, and only if there is an easy way to do it
13:20:43 <Cale> I don't mind foldr
13:20:56 <EvilTerran> it's like a, er, whaddayacallit... \vdash with nothing on the left...
13:21:04 <Cale> cata should be more general than that
13:21:06 <kosmikus> mnislaih: what do you mean, not change the keywords?
13:21:07 <edwardk> yeah
13:21:12 <kosmikus> mnislaih: the keywords should not be in tt?
13:21:15 <edwardk> well, i'm thinking in the Data.Foldable sense
13:21:33 <mnislaih> kosmikus: I meant the symbols. I don't want to mimic tt style, I just want the typewriter font
13:21:35 <Cale> Even the foldr in Data.Foldable isn't what I'd usually call cata
13:21:43 <edwardk> cale: true
13:21:56 <edwardk> i guess i'll stick to the fixpoint signature for cata
13:22:05 <edwardk> then keep a separate Foldable around
13:22:06 <mnislaih> kosmikus: it is probably easier to use --tt and non parameterized directives instead of --poly, right ?
13:22:19 <Cale> Some futuristic Haskell ought to provide some automatic way to get at the type behind the fixed point :)
13:22:33 <Cale> (maybe)
13:23:16 <kosmikus> mnislaih: well, depends on how perfect you want to get it
13:23:35 <kosmikus> mnislaih: the documentation example is typeset using polytt.fmt from the doc/ subdirectory
13:23:56 <mnislaih> kosmikus: of course, as perfect as possible. I will take a look at that file
13:23:58 <kosmikus> mnislaih: you can try to %include polytt.fmt and see if it does what you want
13:24:09 <mnislaih> kosmikus: sounds like a great idea, thanks
13:24:09 <edwardk> cale: i kind of like dave menendez's version of cata in his little Control.Recursion module: http://www.eyrie.org/~zednenem/2004/hsce/Control/Recursion.hs. where you can use the fundep in his Fixpoint class to extract the underlying functor.
13:24:41 <kosmikus> mnislaih: but it might have some nasty side-effects; I've only ever tested it on the one example and whether it works for the docs
13:25:04 <mnislaih> kosmikus: I will let you know
13:25:20 <mnislaih> maybe not right now, but I'll send you an email
13:25:41 <edwardk> the only problem I have with it is, as implemented it can't be extended to handle exponential functors, ala meijer/hutton or fegaras/sheard.
13:25:42 <kosmikus> mnislaih: ok. if you really need it, I can also try to hack up a better .fmt file for you.
13:26:04 <kosmikus> mnislaih: I'll probably do some work on lhs2TeX during the next few days anyway; got a couple of bug reports recently
13:27:02 <mnislaih> kosmikus: do you receive privs ?
13:35:02 * dmhouse runs fetchmail after a month without reading his email
13:35:33 <dozer> in ghci, how do I import a module as if I'd done "import Foo.Bar"?
13:35:39 <mrd> :m +
13:37:12 <dozer> ah, thanks
13:38:33 <roconnor> even after removing fromIntegral I still get:
13:38:36 <roconnor> bsLength                       Data.ByteString.Rope  33.1   37.7
13:38:39 <roconnor> in my profile.
13:38:52 <roconnor> 37.7% of the allocations.
13:38:55 <roconnor> what is it doing?
13:39:04 <roconnor> the profiler must be lying to me.
13:39:11 <dcoutts> roconnor: forcing things into memory that were previously lazily suspended
13:39:37 <roconnor> dcoutts: the length of a bytestring?
13:39:38 <dcoutts> length itself allocates nothing, but if it's the thing that did the forcing...
13:40:52 <roconnor> how could calling the length of a bytestring force anything... well other than the bytestring itself.
13:41:00 <dcoutts> exactly
13:41:23 <roconnor> I thought the profiler was less confusing than that.
13:41:50 <roconnor> but that would explain things
13:42:48 <roconnor> making a bytestring probably does big memory allocations.
13:45:19 <Lemmih> roconnor: You're not using my updated uncons?
13:45:54 <roconnor> Lemmih: ah no, not yet.
13:45:59 <edwardk> @pl \m k c -> m c >>= k
13:45:59 <lambdabot> flip . ((>>=) .)
13:46:03 <edwardk> blech
13:46:16 <roconnor> Lemmih: I haven't decided if I want break the rule that there are no short bytestrings next to each other.
13:46:58 <dozer> dang - Data.Graph.Inductive.Graph doesn't let you alter the label for a node :(
13:48:23 <Lemmih> roconnor: Why would you break that rule?
13:48:52 <nominolo> edwardk: ok, i guess i just stick with my reader monad :)
13:49:41 <nominolo> edwardk: the code is monadic anyways.  but the paper is pretty readable
13:50:22 <roconnor> Lemmih: do you check during uncons how long the second element in the tree is?
13:51:23 <Lemmih> roconnor: Did the previous uncons check that?
13:51:38 <roconnor> Lemmih: it called append and then append did that check.
13:52:26 <dmead> map ("super " ++) ["Awesome]
13:52:32 <dmead> > map ("super " ++) ["Awesome]
13:52:32 <lambdabot>  Improperly terminated string
13:52:36 <dmead> oof
13:52:38 <dmead> > map ("super " ++) ["Awesome"]
13:52:41 <lambdabot>  ["super Awesome"]
13:52:42 <tcr> I'd like to include a library that contains a module Foo.Bar in my source base. I placed that library into a directory called Lib; unfortunately importing Lib.Foo.Bar doesn't work as the module is defined to have the name "Foo.Bar" and not "Lib.Foo.Bar." How can foreign source be included in one's project without having to change the foreign source?
13:52:49 <dmead> and there goes my haskell practice for the day
13:53:03 <sorear> tcr: Don't change the names.
13:53:43 <tcr> sorear: This would mean I have to splice the whole directory layout of the library into my source directory.
13:54:01 <sorear> tcr: -iLib then
13:55:20 <nominolo> tcr: and for Cabal "hs-source-dir: . Lib" (i think)
13:56:28 <nominolo> tcr: but why can't you install the extra lib outside of your source tree?
13:58:34 <edwardk> tcr: what you want to do is install the foreign sourced 'package' on your machine using cabal or something, then compile with an additional -package option on the command line naming it
13:58:44 <ihope> How would I go about using a Windows API call that doesn't seem to be in System.Win32?
13:58:58 <tcr> nominolo: Self-containness of the source package.
13:59:12 <edwardk> tcr: thats how Haskell is meant to be distributed these days. what chunk of source code do you want to import?
13:59:51 <sorear> ihope: Short term: foreign import stdacll   Long term: whine to eivuokko
13:59:57 <edwardk> tcr: and even if the original source isn't in a cabal package you can put one together around it pretty quickly.
14:00:02 <nominolo> tcr: but when that library is on hackage, then cabal-install takes care of the rest
14:01:53 <nominolo> oh
14:02:08 <nominolo> when i run cabal-install update i get:
14:02:28 <ihope> sorear: do you know what file to import from?
14:02:34 <tcr> It's not entirely my decision, and it's not decided as of yet; just wanted to test out how smoothlessly it could be done.
14:03:12 <sorear> ihope: Huh?  You just said it's not in System.Win32.*
14:03:19 <edwardk> tcr: if you need it all to be one package and not cabal-installed from fragments, then the hs-source-dirs: src other-lib-src approach is the cleanest
14:03:29 <hpaste>  nominolo pasted "cabal-install update error" at http://hpaste.org/1975
14:04:07 <tcr> edwardk: I'm not using Cabal as of now, but it certainly looks nifty. :)
14:04:08 <ihope> sorear: you said to use foreign import. Do I have to specify the file I'm importing from?
14:04:22 <bct> so if i want an HTTP library that supports SSL, am I out of luck?
14:04:40 <nominolo> anyone tried cabal-install update in the last couple weeks?
14:04:47 <sorear> ihope: Only at link time.
14:04:48 <dmhouse> bct: have you tried HaskellNet?
14:05:03 <dcoutts> nominolo: that's a very old version of cabal-install you're using
14:05:16 <dmhouse> bct: it comes with support for HsGnuTLS, which is a binding to gnutls, a library for TLS (previously known as SSL).
14:05:18 <edwardk> tcr: i converted fairly recently, makes life a LOT easier
14:05:19 <dcoutts> nominolo: hackage hasn't used xmlrpc for ages
14:05:21 <sorear> ihope: foreign import will get it directly from user32.dll or wherever.  I'm not very familiar with Windows linkeres, however
14:05:33 <bct> dmwit, no i have not. i'll take a look, thanks
14:05:57 <nominolo> dcoutts: interesting .. i wonder why i have it then
14:06:19 <nominolo> my oldest ghc is 6.5.xxxx
14:06:26 <sorear> ihope: Make very very sure to use the correct prototype, getting it wrong could produce segfault bugs that stay dormant for most of a decade (cf X11 on unix)
14:06:30 <nominolo> (one of the first mac builds)
14:07:00 <ihope> Yes, I'll see how far I can take this.
14:08:07 <dcoutts> nominolo: where did you get your cabal-install from? I'd suggest using the latest darcs version.
14:08:20 <nominolo> dcoutts: what is the cabal-install version from ghc-6.6.1?
14:09:30 <dcoutts> nominolo: cabal-install does not come with ghc. yet.
14:10:02 <nominolo> i think i isstalled the one from /Users/nominolo/sw/ghc-6.6.1/libraries/Cabal/cabal-install/
14:10:12 <nominolo> ie, my self-built ghc-6.6.1
14:11:21 <shapr> grussgott delYsid!
14:12:03 <dmhouse> Ooh the darcs.net website is working again.
14:12:36 <dcoutts> nominolo: ah ok. the source was included in Cabal at that time, but it was never built or installed by default.
14:12:49 <dcoutts> nominolo: it's changed significantly since that code
14:13:22 <dcoutts> the whole hackage client/server protocol is different
14:13:27 <dcoutts> it's now much simpler
14:13:31 <nominolo> so, do i have to darcs get http://darcs.haskell.org/cabal/cabal-install?
14:13:44 <nominolo> dcoutts: yeah, it needed lots of deps
14:14:17 <dcoutts> nominolo: yep, got to get it from darcs atm, I should upload a tarball to hackage
14:14:24 <nominolo> dcoutts: which is kind of ironic, since that's what cabal-install is supposed to sole
14:14:32 <dcoutts> I know :-)
14:14:38 <nominolo> dcoutts: yes please :)
14:14:43 <dcoutts> eventually it will be bundled with ghc to solve the bootstrapping
14:14:48 <shapr> nominolo: use --partial or you'll have to wait a long time
14:15:13 <dcoutts> nominolo: tell me how you get on, if there are any major issues you run into. if it's ok I'll upload a tarball
14:15:16 <nominolo> that'd be awesomnest
14:17:16 <nominolo> dcoutts: er .. where *is* the current version?
14:18:02 <nominolo> shapr: i am much for darcs (transparently) sending a tar-ball instead of lots of small changes
14:18:56 <dcoutts> nominolo: http://darcs.haskell.org/cabal-install/
14:18:58 <lambdabot> Title: Index of /cabal-install
14:19:16 <nominolo> ah, found it http://darcs.haskell.org/packages/cabal-install/
14:19:16 <lambdabot> Title: Index of /packages/cabal-install
14:19:37 <nominolo> oh, seems to be an alias
14:19:39 <dcoutts> nominolo: that's a symlink to the top level one
14:28:03 <DRMacIver> ~tell cheeser about evil
14:28:07 <DRMacIver> Oops
14:28:10 <DRMacIver> Wrong window
14:28:17 <shapr> hah
14:28:37 <dibblego> cheeser? Haskell?
14:28:50 <DRMacIver> Like I said. Wrong window.
14:29:02 <mrd> haskevil
14:29:26 <sorear> Looks like a bot-command.  Probably to a different server
14:29:39 <DRMacIver> It is a bot command. javabot factoid syntax.
14:29:48 <Maddas> DRMacIver was spying on us!
14:29:58 <dibblego> is using the word evil, evil?
14:30:20 <nominolo> dcoutts: ok, as of right now cabal-install is broken
14:30:23 <DRMacIver> I spy on everyone.
14:30:50 <nominolo> dcoutts: with the latest Cabal, that is
14:31:30 <Khoth> dibblego: Work out how evil your question was, and divide by two
14:32:06 <dibblego> Khoth, no Num instance for Question was found
14:32:14 <DRMacIver> dibblego: The relevant factoid is that using the word evil (for programming practices) is stupid. :)
14:32:37 <dibblego> DRMacIver, typical Java bible stuff
14:33:03 * DRMacIver disagrees.
14:33:09 * dibblego as always :)
14:33:24 <DRMacIver> Labelling something as evil is not a useful activity. Explaining the harm that it can cause is.
14:33:43 <dibblego> is labelling something a useful activity, useful?
14:33:52 <mrd> evil will always triumph because good is dumb
14:33:54 <dibblego> (or not)
14:33:55 <Maddas> yeah, labelling something as evil is itself an evil activity since it isn't useful
14:34:10 <dibblego> what if "evil" is a metaphor for "contradictory" or "not useful"/
14:34:11 <dibblego> ?
14:34:15 <mrd> evil considered harmful considered harmful
14:34:18 <SamB_XP_> murder is evil
14:34:19 * Maddas lurks harder :-)
14:34:31 <DRMacIver> dibblego: What if "evil" is a metaphor for "pink fluffy bunnies"? :)
14:34:32 <dibblego> SamB_XP_, many moral philosophers have derived that
14:35:03 <edwardk> Is there a short term for what MonadPlus is other than a Monad where m a is a Monoid forall a? A monoidal monad seems to be a beast of a different color.
14:35:03 <dibblego> DRMacIver, what if you remove all the religious connotation of the word, "evil"? it's not a metaphor anymore
14:35:56 <DRMacIver> But it's still a moral judgement. Judging programming on moral criteria is silly. :)
14:36:04 <dcoutts> nominolo: ok, I'm taking a look
14:36:04 <SamB_XP_> edwardk: well, for one thing, m a is usually not a Monaid
14:36:06 <SamB_XP_> er.
14:36:09 <SamB_XP_> Monoid
14:36:18 <nominolo> dcoutts: no, i'm on it
14:36:26 <dcoutts> nominolo: oh ok, thanks
14:36:28 <dibblego> I don't see it, or use it, as a moral criteria - I expect my audience not to as well (unless they are Java ninnies of course with religious convictions)
14:36:34 <mrd> class Evil a; instance Evil Java.  happy?
14:36:41 <Philippa> DRMacIver: not in safety-critical code
14:36:50 <Philippa> arguably, not in code that has any significant effect on people at all
14:36:51 <edwardk> samb: mzero and mplus, ignoring the vagaries of haskell's type system, I mean't Monoid in the mathematical sense =)
14:36:51 <dcoutts> nominolo: you can send patches directly to me if you like
14:36:56 <edwardk> er meant
14:37:11 <SamB_XP_> edwardk: your mistake was in capitalizing the word monoid
14:37:25 <nominolo> dcoutts: do you get them if i do darcs send?
14:37:48 <edwardk> samb: fair enough
14:37:48 <dcoutts> nominolo: I'm just checking that actually
14:38:09 <dcoutts> nominolo: it goes to cabal-devel@haskell.org
14:38:33 <edwardk> samb: just trying to figure out what the nice short name for that would be. MonadPlus always struck me as a bit hackish
14:38:37 <olsner> @quote evil
14:38:37 <lambdabot> Igloo says:  Did hugs' ./configure always end with "config.status: executing ultra-evil commands"?
14:38:38 <dcoutts> nominolo: so if you want quick fixes applied send them to me this evening, in general sending to cabal-devel is fine though
14:38:42 <SamB_XP_> oh, I see GHC has a bug in it's typechecking of "do"
14:38:57 <mauke> > do 'X'
14:39:04 <nominolo> dcoutts: i'll just try to make it work.  i'll add flag support later
14:39:05 <lambdabot>  Couldn't match expected type `t t1' against inferred type `Char'
14:39:10 <SamB_XP_> mauke: not that one
14:39:19 <edwardk> samb: what bug is that?
14:39:23 <dcoutts> nominolo: ok
14:39:31 <SamB_XP_> edwardk: you wrote about it in your blog ;-)
14:39:41 <edwardk> samb: ok, thought that was the one
14:39:47 <edwardk> samb: was curious if you found another
14:40:38 <DRMacIver> Philippa: I think I disagree. The quality of the code is still purely a question of utility. Providing code you know to be poor quality can usefully have moral judgements passed on it, but the code itself is not good or evil.
14:40:43 <SamB_XP_> edwardk: It is definately a bug. GHC is only supposed to be picky about the types of the arrow methods...
14:41:32 <edwardk> samb: well, the documentation does say the weakest type that monad can be presumed to have if i recall, and in that setting it has the same monad in each position.
14:41:41 <edwardk> samb: a shame, because i rather like my version =)
14:42:18 <diakopter> any tips for CLP with backtracking on ghc?
14:42:27 <sorear> CLP?
14:42:32 <sorear> @go CLP
14:42:33 <diakopter> constraint logic...
14:42:34 <lambdabot> http://www.clpgroup.com/
14:42:34 <lambdabot> Title: CLP Group - China Light and Power
14:42:58 <Heffalump> have you read Spivey+Seres' work?
14:43:15 <Heffalump> (it's about LP rather than CLP, but still of some relevance)
14:43:19 <matthew-_> um, an easy way to make [a..b] work where b < a ?
14:43:26 <edwardk> samb: plus it opens up type-indexed monads like type-changeable state monads (>>=) :: m i j a -> (a -> m j k b) -> m i k b
14:43:32 <Heffalump> matthew-_: what do you expect it to do?
14:43:51 <matthew-_> go downwards
14:43:56 <DRMacIver> matthew-_: reverse [b..a] ?
14:44:02 <dolio> > [9, 8 .. 1]
14:44:03 <edwardk> matthew: [a,pred a..b]
14:44:03 <matthew-_> DRMacIver++
14:44:07 <lambdabot>  [9,8,7,6,5,4,3,2,1]
14:44:28 <DRMacIver> Thanks. :)
14:44:39 <diakopter> Heffalump: no, but I just found http://www.cs.rutgers.edu/~ccshan/logicprog/LogicT-icfp2005.pdf   but I still thought I'd ask here for tips.
14:44:41 <dcoutts> nominolo: the current Cabal doesn't seem to be able to parse it's own Cabal.cabal file
14:44:43 <DRMacIver> > [9..1]
14:44:45 <lambdabot>  []
14:44:47 <DRMacIver> Hm
14:44:49 <dcoutts> nominolo: setup: Cabal.cabal:27: Invalid syntax (no colon after field name)
14:45:03 <SamB_XP_> edwardk: what is this about the monad types in the documentation? I don't see it in http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#rebindable-syntax
14:45:05 <lambdabot> Title: 7.3. Syntactic extensions, http://tinyurl.com/y6v6by
14:45:29 <nominolo> dcoutts: that's new
14:45:48 <EvilTerran> matthew, if you're dealing with Num types, [a, a + signum (b-a) .. b] works regardless of whether you want to go up or down
14:45:49 <dcoutts> nominolo: I'm not sure what you mean
14:46:01 <nominolo> dcoutts: that error
14:46:17 <edwardk> samb: old docs: http://haskell.org/ghc/docs/5.04.2/html/users_guide/syntax-extns.html#REBINDABLE-SYNTAX here mention it
14:46:18 <lambdabot> http://tinyurl.com/25jzfb
14:46:24 <edwardk> not sure where it is in the current ones
14:46:30 <SamB_XP_> edwardk: yes but those are old docs
14:46:34 <SamB_XP_> it's got to be a bug
14:46:37 <SamB_XP_> report it as such
14:46:49 <edwardk> mnislaih and i have an open bug report for it
14:46:55 <SamB_XP_> as a bug?
14:46:59 <edwardk> and i think someeone else spoke up on it
14:47:00 <edwardk> checking
14:47:02 <SamB_XP_> not as a missing feature?
14:47:07 <nominolo> dcoutts: can you paste your Cabal.cabal?
14:47:18 <nominolo> dcoutts: i can build HEAD cabal with itself
14:47:31 <dcoutts> nominolo: it's the current latest darcs version of Cabal with no local changes
14:47:40 <dcoutts> nominolo: I do: ghc --make Setup.lhs -o setup; ./setup clean
14:47:42 <nominolo> dcoutts: did you build using make?
14:47:49 <edwardk> samb: http://hackage.haskell.org/trac/ghc/ticket/1537
14:47:50 <lambdabot> Title: #1537 (do notation translation) - GHC - Trac
14:48:43 <nominolo> dcoutts: yes, that means your building it with your old version of cabal as includes
14:49:00 <nominolo> dcoutts: you need -i. or sth.
14:49:17 <dcoutts> nominolo: no, it's using the current source, current files are taken in preference to packages
14:49:20 <dcoutts> local files
14:49:46 <dcoutts> nominolo: I can see ghc --make compiling the correct files, ie all of them
14:50:10 <dcoutts> not just compiling Setup.lhs, but all the Cabal modules from the source tree
14:50:11 <nominolo> dcoutts: yes. but it uses the install cabal to resolve its deps
14:50:21 <nominolo> *installed
14:51:07 <nominolo> just try using make
14:53:34 <_Nucleo> @src (\x -> gcd x 10 == 1)
14:53:34 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:53:39 <_Nucleo> @pl (\x -> gcd x 10 == 1)
14:53:39 <lambdabot> (1 ==) . flip gcd 10
14:55:11 <dcoutts> nominolo: hmm, I'm surprised, I was sure local files were taken in preference to ones from packages, and they were all compiled, so I don't understand what the difference is.
14:55:52 <dcoutts> nominolo: so no parse error, just lots of warning about unknown fields, ghc-options, cc-options, and several others.
14:56:02 <nominolo> dcoutts: yes, actually it shouldn't if it didn't.
14:56:14 <nominolo> dcoutts: oh, is that new?
14:56:28 <dcoutts> nominolo: I've not seen that before certainly
14:57:01 <nominolo> dcoutts: hm.  maybe Igloo knows
14:58:20 <Igloo> nominolo: Knows what?
14:58:41 <nominolo> why we get lot's of unknown field warnings
14:58:45 <dcoutts> Igloo: I'm getting several warning about unknown fields in Cabal's own .cabal file when it's building itself
14:58:56 <dcoutts> setup: Warning: Unknown field 'extra-source-files'
14:58:56 <dcoutts> setup: Warning: Unknown field 'nhc98-options'
14:58:56 <dcoutts> setup: Warning: Unknown field 'nhc-options'
14:58:56 <dcoutts> setup: Warning: Unknown field 'cc-options'
14:58:56 <dcoutts> setup: Warning: Unknown field 'ghc-options'
14:59:04 <dcoutts> this is bad :-)
14:59:38 <Igloo> I get that too
14:59:55 <dcoutts> well I'm glad it's not just me this time :-)
15:00:13 <nominolo> me too
15:00:31 <dcoutts> have we broken the parser somehow?
15:00:32 <SamB_XP_> doesn't cabal work anymore?
15:00:43 <dcoutts> SamB_XP_: darcs version, fear not
15:00:59 <Igloo> You didn't make it case sensitive did you, nominolo?
15:01:09 <nominolo> ah i know
15:01:14 <Igloo> Oh, it's lower cased them in the warning, so that's unlikely
15:01:16 <nominolo> they are in the wrong section
15:01:27 <nominolo> they have to go into the library section
15:01:40 <Igloo> Oh, yes, and extra-source files has to go in the top section
15:01:48 <dcoutts> nominolo: ok glad you know :-) send me your patches when you're done
15:01:52 <Igloo> That makes sense; I was thrown by some being in library and some not
15:02:16 <nominolo> maybe we should have a better warning there
15:03:19 <dcoutts> Igloo: you know that we've got this situation where some progs are handled explicitly (happy, hsc2hs, and 4 others) and some are handled through the ProgramConfiguration mechanism.
15:03:39 <dcoutts> Igloo: I'm going to try and convert them all to go via ProgramConfiguration
15:03:47 <Igloo> dcoutts: Sounds good
15:04:06 <dcoutts> Igloo: just wondering if you knew of anything for those progs that needs to be handled separately
15:04:16 <Igloo> dcoutts: Wait, I shouldn't be encouraging you to hack on Cabal when I want bytestring fixed  :-)
15:04:24 <Igloo> I don't know of anything, no
15:04:25 <dcoutts> hah
15:04:27 <dcoutts> ok
15:06:25 <SamB_XP_> edwardk: I think your Blog instance needs work
15:07:16 <SamB_XP_> unless Reader is exported from Control.Comonad, anyway
15:07:36 <nominolo> dcoutts: Igloo: patch sent
15:08:14 <nominolo> Igloo: oh, and nothing is case sensitive in .cabal files
15:08:58 <SamB_XP_> what about module names?
15:08:59 <chessguy> 'evening ya'all
15:09:17 <nominolo> SamB_XP_: ok, all non-data
15:10:38 <nominolo> cabal field names and configuration flags are all not case-sensitive
15:20:43 <edwardk> samb: hrmm
15:20:47 <edwardk> samb: checking
15:21:35 <dcoutts> nominolo: I'm not sure I understand the change, what was wrong?
15:21:55 <edwardk> samb: well, since there isn't a Control.Comonad I can pretend it has whatever it needs ;)
15:22:07 <nominolo> dcoutts: the compiler related fields are not allowed in the top part
15:22:31 <nominolo> dcoutts: conversely, the extra-src-dirs have to be in that section
15:22:38 <dcoutts> nominolo: only in a library or executable stanza
15:22:56 <nominolo> dcoutts: i'm fixing to have a more helpful error message
15:23:01 <nominolo> dcoutts: right
15:23:03 <dcoutts> nominolo: ok
15:23:29 <nominolo> it'll show which fields are allowed in which section if an error occured
15:23:36 <nominolo> (or warning)
15:25:39 <pjd> edwardk: Monadoid? :)
15:25:46 <edwardk> Ok, I think MonadPlus is when the subcategory of types that the monad injects types into is a symmetric monoidal category built off of coproduct and the initial object. of course that doesn't shorten the way of saying what it is any more than saying every m a is a monoid =)
15:26:10 <mauke> class MandoDiao
15:26:34 <edwardk> pjd: =)
15:26:59 <monochrom> Monadois
15:28:21 <edwardk> pjd: right now I just gutted it and turned it into a set of classes for FAdd, FZero, FAddMonoid and added FMul, FOne, FMulMonoid for the terminal/product case, which i'm not sure is useful yet
15:28:41 <edwardk> (and built it over Functor rather than Monad)
15:28:45 <pjd> when would (MonadPlus m) and (Monad m, Monoid (m a)) differ?
15:29:09 <mauke> FZero? awesome!
15:29:24 <chessguy> hm, who is Sebastian Sylvan?
15:29:43 <pjd> edwardk: what are those classes in Control.Applicative-speak?
15:29:44 <edwardk> pjd, currently they don't, unfortunately, there is no way to roll Monad m, Monoid (m a) into a single typeclass other than to duplicate the functionality of Monoid
15:30:15 <pjd> how do you mean duplicate?
15:31:08 <edwardk> class Functor f => FAdd f where fadd :: f a -> f a -> f a; class Functor f => FZero f where fzero :: f a; class (FAdd f, FZero f) => FAddMonoid f; instance (FAdd f, FZero f) => FAddMonoid f
15:31:08 <gnuvince_> Anyone knows if the O'Reilly Haskell book is still being worked on?
15:31:35 <shachaf> gnuvince_: Real World Haskell?
15:31:50 <gnuvince_> shachaf: yes
15:31:51 <augustss> chessguy: Sebastian Sylvan is Sebastian Sylvan.  What kind of answer did you want?
15:31:57 <shachaf> gnuvince_: As far as I know.
15:32:09 <monochrom> There has been no bad news.
15:32:09 <chessguy> an IRC nickname
15:32:16 <augustss> ah!
15:33:25 <shachaf> gnuvince_: It might still be a while before anything is online, though.
15:33:30 <edwardk> fadd = <|> or mplus in applicative and monad terms. fzero = empty or mempty in applicative or monad terms., so FAddMonoid would be a 'weaker Alternative' that doesn't necessarily have return and ap.
15:33:34 <pjd> edwardk: so FAdd + FZero are basically Applicative?
15:33:44 <shachaf> gnuvince_: I'm not sure. Last I heard they had ~5 chapters, I think?
15:33:50 <edwardk> FAdd + FZero is almost alternative
15:34:13 <chessguy> @hoogle unfoldr
15:34:14 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
15:34:14 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
15:34:14 <gnuvince_> shachaf: they did mention they were gonna do like the Django book and put it online, didn't they?
15:34:29 <edwardk> add Return and Ap to flesh out the existing Alternative
15:34:34 <sorear> chessguy: He's a graphics maniac.  His master's thesis was on particle systems.
15:34:37 <shachaf> gnuvince_: Yes, it'll ne Creative Commons, I think.
15:34:45 <edwardk> pjd: i've piecemealed everything
15:34:48 <pjd> edwardk: oh, sorry, braino;  i read fzero as a -> f a
15:34:54 <chessguy> sorear, does he come on here?
15:34:55 <shachaf> gnuvince_: http://book.realworldhaskell.org/
15:34:57 <lambdabot> Title: Real-World Haskell
15:34:57 <pjd> i see, yeah
15:35:12 <sorear> chessguy: I don't know
15:35:14 <gnuvince_> shachaf: thanks.
15:35:25 * gnuvince_ should really start investing in learning Haskell.
15:35:35 <pjd> edwardk: so i'm guessing FOne has a -> f a ?
15:35:38 <edwardk> pjd: mainly so when its done you should be able to safely pass any monad to anything expecting an applicative, etc.
15:36:07 <sorear> chessguy: looks like a "yes"
15:36:13 <edwardk> pjd: haven't done FOne yet =)
15:36:17 <chessguy> @seen sylvan
15:36:18 <lambdabot> I haven't seen sylvan.
15:36:30 <pjd> edwardk: intended to be, i mean :)
15:36:36 <sorear> Most recent sighting Feb 17 2007
15:36:39 <pjd> s/be/have/
15:36:54 <shachaf> gnuvince_: Yes, you should. :-)
15:37:02 <shachaf> gnuvince_: I'm sure #haskell will be glad to help.
15:37:05 <edwardk> pjd: right now I have class Return m where return :: a -> m a with that signature
15:37:29 <gnuvince_> shachaf: I downloaded yaht.pdf at home and at work
15:37:38 <shachaf> @where wikibook
15:37:38 <lambdabot> http://en.wikibooks.org/wiki/Haskell
15:37:42 <shachaf> That might also help.
15:37:43 <gnuvince_> I just need to take the time to read it and play around
15:37:56 <pjd> edwardk: ah, ok
15:38:22 <gnuvince_> shachaf: thanks
15:38:24 <shachaf> gnuvince_: How far have you gotten in Haskell?
15:40:07 <thoughtpolice> gnuvince_: yaht is nice. i also found that dons little tutorials on his blog helped a lot: http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/16
15:40:07 <lambdabot> Title: Haskell hacking
15:40:41 <shachaf> Would the "A taste of Haskell" PDF be good to point people to?
15:40:48 <shachaf> Or does it not work well stand-alone?
15:42:17 <gnuvince_> shachaf: In Haskell, not much.  I'm familiar with functional programming, I did some O'Caml a few years ago, Scheme and Common Lisp and some Erlang recently.  For the "traditional" stuff (map, filter, recursion, lambda etc.) I'm okay.  The more modern features of Haskell such as monads, type classes (I'm a dynamic typing kind of guy) are the part I'm less comfortable with.  And there's the whole Haskell culture and some minor poin
15:42:20 <nominolo> dcoutts: patch is out
15:42:26 <dcoutts> ok
15:42:30 <gnuvince_> `prefix`, the $ operator, etc.)
15:42:36 <nominolo> dcoutts: it'll now list all allowed fields
15:42:50 <shachaf> gnuvince_: Cut off after "minor poin".
15:42:56 <dcoutts> nominolo: ok
15:43:24 <gnuvince_> shachaf: using the `function` syntax, the $ operator, etc.
15:43:31 <hpaste>  nominolo pasted "new cabal error message" at http://hpaste.org/1977
15:43:39 <thoughtpolice> for some reason i get an extreme sense of dislike when i look at ocaml.
15:43:47 <gnuvince_> shachaf: I'm also kind of uncomfortable with static typing
15:43:51 <shachaf> gnuvince_: $ is simple.
15:43:59 <shachaf> gnuvince_: f $ x = f x.
15:44:05 <dcoutts> thoughtpolice: it's the ';' and lack of layout
15:44:11 <dcoutts> it is for me
15:44:17 <gnuvince_> shachaf: I think I figured it out. f (g x) = f $ g x
15:44:18 <shachaf> gnuvince_: f $ g y === f (g y)
15:44:26 <shachaf> gnuvince_: Exactly.
15:44:27 <thoughtpolice> dcoutts: hm. might be. i think i'll just trust my feelings on this one though and stick with haskell :p
15:44:41 <shachaf> gnuvince_: It just lets you get rid of parentheses.
15:44:41 <nominolo> dcoutts: oh, maybe a line number would be even more helpful
15:44:44 <dcoutts> thoughtpolice: good choice
15:44:46 <thoughtpolice> :)
15:44:50 <dcoutts> nominolo: true
15:45:04 <shachaf> > let f x y = (x,y) in 1 `f` 2
15:45:09 <lambdabot>  (1,2)
15:45:10 <shachaf> > let f x y = (x,y) in f 1 2
15:45:11 <lambdabot>  (1,2)
15:45:22 <shachaf> That's all `infix` means.
15:45:59 <shachaf> Along with a few precedence and associativity rules that you can usually ignore.
15:46:00 <gnuvince_> shachaf: Another thing that might be difficult at first is the whole immutability thing.  I didn't think I had a problem with it, but since O'Caml and Scheme and all have assignments, I never thought about it too much.
15:46:03 <qwr> let subtract = (-) in 3 `subtract` 1
15:46:03 <chessguy> > let f = (,) in 1 `f` 2
15:46:04 <lambdabot>  (1,2)
15:46:14 * chessguy golfs schachaf
15:46:17 <shachaf> chessguy: I decided not to do that. :-)
15:46:19 <thoughtpolice> gnuvince_: you get around it pretty easily in principle
15:46:22 <shachaf> chessguy: Though I did think about it.
15:46:57 <thoughtpolice> gnuvince_: it seems like you could never write a program in such a way, if you play around a little you'll be writing the same stuff you were in say, scheme/lisp in no time with no destructive updates. :)
15:46:59 <shachaf> gnuvince_: Haskell is good in that respect -- you HAVE to think functionally, rather than cheating like Scheme lets you.
15:47:11 <mluffel> hi, is there a way (in ghci) to show all the typeclass instances that a data type has?
15:47:19 <shachaf> :i
15:47:25 <gnuvince_> thoughtpolice: I imagine.  I was thinking about updating a hash table (Data.Map in Haskell?): in most imperative languages, you modify the the hash table directly.  I imagine it's just a question of having the right frame of mind
15:47:51 <qwr> first, think about binary operator as a function with two arguments. `function` just lets you use any two-argument function as binary operator
15:47:52 <thoughtpolice> gnuvince_: with Data.Map you get returned an updated map, fyi :)
15:47:59 <mauke> gnuvince_: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-HashTable.html
15:48:01 <lambdabot> http://tinyurl.com/y47x6e
15:48:07 <gnuvince_> thoughtpolice: yeah, I saw
15:48:22 <mluffel> thanks shachaf
15:48:39 <gnuvince_> mauke: cute, thanks.
15:48:52 <thoughtpolice> gnuvince_: it may seem foreign at first (i know it did to me,) but I found you get around the 'no mutable state' thing with a lot less mental effort than you'd think at first.
15:50:03 <hpaste>  nominolo annotated "new cabal error message" with "now with line numbers" at http://hpaste.org/1977#a1
15:50:17 <qwr> gnuvince_: that's general pattern - instead of modifing in place, the modified value is returned
15:50:18 <gnuvince_> thoughtpolice: I'm sure with some practice I'll be all right.
15:50:32 <thoughtpolice> gnuvince_: spend a little time writing some basic stuff (I did the somewhat classic reimplementation of several unix utilities) and you'll be up on your feet in no time. :)
15:50:52 <gnuvince_> thoughtpolice: I rewrote a bunch of List functions
15:51:01 <shachaf> main = interact id -- simple implementation of cat. :-)
15:51:18 <gnuvince_> map, filter, zip, reverse, append, member, etc.
15:51:50 <shachaf> gnuvince_: That's probably pretty easy if you've used Scheme.
15:51:52 <thoughtpolice> main = interact $ unlines . reverse . lines -- tac ftw!
15:52:54 <shachaf> gnuvince_: Though you don't write some functions tail-recursively in Haskell.
15:55:09 <gnuvince_> shachaf: I imagine GHC optimizes tail recursion?
15:55:17 <SamB> gnuvince_: of course
15:55:50 <SamB> (what do you think this is ... C? though GCC does that anyway...)
15:56:00 <thorat> there's a Data.Array.IO.  Why is there no Data.Map.IO?
15:56:16 <qwr> (the lazyness means that non-tail-recursive functions don't have to grow stack always)
15:56:27 <gnuvince_> SamB: Lot of languages don't do it, just checking ;-)
15:56:28 <SamB> thorat: Data.Map is a purely functional datastructure
15:56:37 <thorat> ok
15:57:12 <LoganCapaldo> does ghc just optimize tail recursion or tail calls in general?
15:57:19 <SamB> gnuvince_: The report doesn't say anything about it, but the implementors aren't stupid ;-)
15:57:21 <sorear> LoganCapaldo: All tail calls.
15:57:27 <LoganCapaldo> neato
15:57:47 <LoganCapaldo> I guess the Cont monad would be kind of lame if it didn't
15:57:57 <SamB> LoganCapaldo: it would be too tricky to work out whether something was potentially recursive or not ;-)
15:58:03 <sorear> gnuvince_: Compare to scheme, which mandates general tail calls, and as a consequence most of the compilers aren't. :)
15:58:07 <Excedrin> sorear: is that because it does cps conversion? (and cps conversion implies "free" tail call optimization?)
15:58:19 <sorear> Excedrin: No.
15:58:33 <gnuvince_> SamB: can't imagine Haskell programmers in general being stupid. It'd probably be a fun thing to watch an ASP/VBScript programmer trying the language :)
15:58:42 <gnuvince_> (No offense to the ASP programmers in here)
15:59:03 <sorear> Excedrin: Haskell compilers use a jumping scheme for calls in tail position; our scoping rules make it safe.
15:59:09 <LoganCapaldo> SamB, wel I was thinking of the naive tail recursive optimization (mutate arguments go to top of function body) but I guess laziness kinda of kills that lame way of doing it
15:59:13 <sorear> Unlike C, which is tail-call-proof.
16:00:03 <SamB> sorear: um. only if you have a &d variable!
16:00:34 <sorear> SamB: Sure, only if you take the address of a local variable, yeah.
16:00:40 <sorear> But if you *do*...
16:00:45 <sorear> @go Cheney on the MTA
16:00:47 <lambdabot> http://home.pipeline.com/~hbaker1/CheneyMTA.html
16:00:47 <lambdabot> Title: Cheney on the M.T.A.
16:01:11 <sorear> one of the cleverest hacks I've seen.
16:01:33 <edwardk> is there any monad out there with sensible separate mplus and morelse implementations that differ?
16:01:51 <SamB> what the heck is morelse?
16:02:02 <edwardk> samb: http://haskell.org/haskellwiki/MonadPlus_reform_proposal
16:02:03 <lambdabot> Title: MonadPlus reform proposal - HaskellWiki
16:02:24 <edwardk> samb: its a cale thing iirc
16:02:48 <monochrom> Oh Gosh, garbage-collect the stack?! :)
16:02:56 <edwardk> monochrom: works well
16:03:19 <monochrom> It's clever and crazy. :)
16:03:27 <SamB> is that the one where you jump off of the empire state building every so often?
16:03:53 <edwardk> monochrom: you just accumulate all the temporaries on the stack, then when you run out of space you rely on the fact that you are CPS transformed so need never return to anything below you on the stack, walk it for stuff to promote to the heap and them longjmp to the bottom
16:03:55 <edwardk> samb: yeah
16:04:10 <edwardk> samb: i used it in my javascript recompiler =)
16:04:10 <SamB> yeah I always thought that was a neat hack
16:04:50 <edwardk> it of course has some terrible cache coherence issues, but its a very fast allocator
16:05:02 <SamB> what cache coherence issues?
16:05:25 <edwardk> well, you rarely access the same portion of the cache
16:05:38 <qwr> locality is killed... you always wonder to new places in the stack
16:05:40 <edwardk> coz you lack normal stack-head locality
16:05:46 <monochrom> well, when the stack grows very large, and useful stuff is scattered randomly.
16:05:49 <SamB> you mean the CPU is treating the stack specially?
16:06:07 <SamB> there should be a way to tell the CPU "empire state building ru
16:06:09 <edwardk> samb: no, but normally its around the same general place so its always in cache
16:06:11 <SamB> les are in play"
16:06:20 <monochrom> But, it is no worse than doing everything in the heap.
16:06:37 <SamB> ah.
16:07:18 <edwardk> so normally writing a temporary to the stack isn't much worse than register access, (er that got pretty bad with x86-64) in the cheney on the MTA approach it almost always is.
16:07:46 <edwardk> monochrom: yeah but you lost the use of the stack for temporary spills
16:07:59 <monochrom> True.
16:08:26 <mluffel> so, my ghci (with -fglasgow-exts) doesn't think there is a "Data Float" instance, but the docs claim there should be: http://www.haskell.org/ghc/docs/6.6/html/libraries/base/Prelude.html#i:Float
16:08:28 <lambdabot> http://tinyurl.com/2zqw9f
16:09:15 <mauke> did you import Data.Generics.Basics?
16:09:22 <mluffel> i did
16:09:27 <sorear> did you import Data.Generics?
16:09:49 <sorear> the main module imports everything, incl .Instances
16:10:23 <mauke> ah
16:11:07 <mluffel> ha, wow, thanks sorear
16:11:41 <mluffel> i was just importing data.Generics.Basics, lesson learned
16:12:45 <LoganCapaldo> @djinn (a -> Bool) -> [a] -> (a -> b) -> b -> b
16:12:48 <lambdabot> f _ _ _ a = a
16:12:52 <LoganCapaldo> heh
16:13:04 <mauke> OPTOMIZED
16:13:21 <sorear> mluffel: It's haddock's fault.  It really should tell you when you need to import additional modules.
16:14:50 <mluffel> sorear: is there a reason why someone would want to only import .Basics?
16:16:04 <sorear> mluffel: I don't think so, it's probably just for implementation splitting... but Haddock does have a way to mark internal modules, and it wasn't used
16:16:25 <LoganCapaldo> @type \p xs t d -> case filter p xs of { [] -> d ; (x:_) -> t x }
16:16:30 <lambdabot> forall t a. (a -> Bool) -> [a] -> (a -> t) -> t -> t
16:17:20 <LoganCapaldo> To be continued...
16:17:32 <chessguy> @bot
16:17:32 <lambdabot> :)
16:18:05 <mauke> @type \p xs t d -> maybe d t . listToMaybe $ filter p xs
16:18:07 <lambdabot> forall b a. (a -> Bool) -> [a] -> (a -> b) -> b -> b
16:18:20 <mauke> @pl \p xs t d -> maybe d t . listToMaybe $ filter p xs
16:18:21 <lambdabot> (flip (flip . flip flip listToMaybe . ((.) .) . flip maybe) .) . filter
16:18:44 <chessguy> so i'm wondering, what are string-rewriting systems (like endo's dna, but less obfuscated) good for?
16:19:29 <LoganCapaldo> @type \p xs t d -> maybe d t $ find p xs
16:19:31 <lambdabot> forall b a. (a -> Bool) -> [a] -> (a -> b) -> b -> b
16:19:58 <chessguy> (if anything)
16:22:11 <RyanT5000> @seen oleg
16:22:12 <lambdabot> I haven't seen oleg.
16:23:13 <RyanT5000> @seen oleg
16:23:13 <lambdabot> I haven't seen oleg.
16:23:53 <RyanT5000> what's oleg's nick?
16:24:01 <mauke> does he IRC?
16:24:14 <RyanT5000> i thought i had seen him in here before
16:24:16 <RyanT5000> but i'm not sure
16:28:32 <sorear> ccshan DOES come, however
16:28:57 <mauke> @seen ccshan
16:28:57 <lambdabot> I haven't seen ccshan.
16:44:35 <wli> The stack is magic on x86(-64). Pushing and popping variables on the stack is hardwired to L1 caching logic, doing arithmetic on it is weirdly slow, switching stacks likewise, and so on.
16:46:01 <wli> You're not really given a choice in the matter about temporary spilling etc.; if you don't make effective use of the stack you'll be dogslow.
16:46:41 <sorear> GHC doesn't use the stack at all, though.
16:47:00 <SamB_XP_> wli: it shouldn't be so hardwired
16:47:29 <sorear> SamB_XP_: x86 sucks
16:47:35 <wli> I've looked at the generated code. It's not doing all that much different from C programs wrt. pushing and popping on the stack.
16:47:50 <SamB_XP_> wli: doesn't it use a different register?
16:47:57 <chessguy> @paste
16:47:57 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:48:02 <sorear> wli: esi /= esp
16:48:16 <hpaste>  chessguy pasted "better way to do this?" at http://hpaste.org/1978
16:48:31 <chessguy> is it possible to declare an infix constructor, but still allow for field accessors?
16:48:37 <sorear> chessguy: Yes.
16:48:54 <SamB_XP_> anyway, it would be better if the CPU would let you say "okay, so I'm using ESI and ESP as stack pointers. please cache accordingly."
16:49:12 <hpaste>  sorear annotated "better way to do this?" with "with record syntax" at http://hpaste.org/1978#a1
16:49:44 <sorear> currently, ghc doesn't use esp at all, except for foreign calls.
16:50:03 <chessguy> ah, duh
16:50:11 <wli> sorear: Has this changed?
16:50:19 <sorear> the rationale is that setting up a signal stack would be too much work, and running signals on the Haskell stack would impose unreasonable free space requirements
16:50:36 <sorear> wli: ghc has used its own stack for a very long time
16:51:49 <wli> sorear: ca. 2000 timeframe?
16:52:56 <falconair> any one know if the main haskell tutorial video from OSCON (the one with xmonad) is available yet?
16:53:06 <sorear> wli: It's described in the paper I'm reading right now (Peyton Jones et al 1992, Implementing lazy functional languages on stock hardware: the spineless tagless G-machine)
16:53:11 <wli> What I'm looking at now is not remotely familiar.
16:53:27 <sorear> falconair: it is, I forget exactly where though
16:54:04 <SamB_XP_> (now with spines and tags!)
16:54:05 <sorear> 07.07.27:18:22:12 <sorear> 16:45 < CosmicRay_> woohoo!  http://blip.tv/file/get/OSCON-OSCON2007SimonPeytonJones914.mov
16:54:30 <wli> sorear: Yes, I remember it was described there.
16:54:47 <ddarius> sorear: That's the Transactional Memory one.
16:55:16 <sorear> oh.
16:55:22 <sorear> @wiki Video tutorials
16:55:22 <lambdabot> http://www.haskell.org/haskellwiki/Video_tutorials
16:55:28 <falconair> sorear, ddarius, yeah, i saw the TM one already
16:55:51 <SamB_XP_> what happened to the S?
16:56:04 <falconair> STM :)
16:56:09 <shachaf> SamB_XP_: I guess that one is implemented in the hardware. :-)
16:56:26 <ddarius> It doesn't specify how it's implemented.
16:56:36 <SamB_XP_> oh. I was thinking the S was for Simple for some reason
16:59:14 <wli> sorear: Actually it's not.
16:59:28 <wli> sorear: But it's described somewhere.
16:59:57 <chessguy> @hoogle delete
16:59:57 <lambdabot> List.delete :: Eq a => a -> [a] -> [a]
16:59:57 <lambdabot> Data.HashTable.delete :: HashTable key val -> key -> IO ()
16:59:57 <lambdabot> Data.IntMap.delete :: Key -> IntMap a -> IntMap a
17:00:48 <sorear> wli: It is too!  Second paragraph of page 42
17:02:23 <wli> sorear: That underspecifies it.
17:03:12 <Philippa> 'lo ChilliX
17:03:29 <ChilliX> Hi :)
17:03:49 <wli> sorear: I seem to remember disassembling Haskell programs with vastly different results from what I now see at some point in the past.
17:04:26 <sorear> maybe you were using -unreg back then?
17:04:33 * SamB_XP_ tried to say that
17:04:39 <wli> sorear: Very possible.
17:04:53 <SamB_XP_> but I couldn't decide on an s or a z in spelling unregisterized fast enough :-(
17:05:30 * wli wonders when 6.7 will hit the Debian package archives.
17:05:57 <shachaf> wli: Will it ever?
17:06:05 <shachaf> wli: I'd think they'd wait for 6.8.
17:06:22 <wli> 6.8 is good enough for me.
17:06:24 <SamB_XP_> they've had CVS builds with a different package name before, I think
17:06:40 <SamB_XP_> back before GHC moved to darcs, obviously
17:06:58 <wli> When did it move to darcs?
17:07:42 <sorear> ghc-cvs IIRC
17:07:49 <sorear> which is still there, just ancient :)
17:08:13 <wli> Yeah, ISTR ghc-cvs being less recent than plain old ghc6.
17:08:26 <SamB> of course it is
17:09:32 <SamB> ghc-cvs 20060905-1
17:11:20 <wli> I'd usually go bleeding edge but there was a reason I dumped it.
17:13:17 <chessguy> @type unfoldtree
17:13:18 <lambdabot> Not in scope: `unfoldtree'
17:13:45 <dons> ?users
17:13:45 <lambdabot> Maximum users seen in #haskell: 374, currently: 339 (90.6%), active: 17 (5.0%)
17:13:51 <dons> cool
17:13:51 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
17:14:07 <chessguy> @type unfoldTree
17:14:09 <lambdabot> forall b a. (b -> (a, [b])) -> b -> Tree a
17:16:55 <chessguy> @pl m a t = N a t
17:16:55 <lambdabot> m = N
17:17:13 <sorear> dons: we're up to #13
17:17:29 <sorear> just ~25 more people and we pass RoR
17:18:17 <SamB_XP_> ouch!
17:18:33 <sorear> ouch?
17:18:56 <SamB_XP_> we don't want their spot. it, um, has cooties.
17:19:09 <LoganCapaldo> and only 58 to pass #ruby-lang
17:20:10 <monochrom> Think of it this way. Get 13 people to leave RoR and join here, that will put us ahead of them. :)
17:20:50 <LoganCapaldo> @users
17:20:50 <lambdabot> Maximum users seen in #haskell: 374, currently: 340 (90.9%), active: 19 (5.6%)
17:21:17 * LoganCapaldo wonders what the stats would look like if you compared the "active" numbers
17:22:18 <nominolo> 374!?
17:24:15 <dons> cool stuff
17:25:28 <LoganCapaldo> @type foldr ((+) . const 1) 0
17:25:30 <lambdabot> forall b a. (Num b) => [a] -> b
17:26:16 <mauke> @type genericLength
17:26:18 <lambdabot> forall b i. (Num i) => [b] -> i
17:26:21 <LoganCapaldo> > foldr ((+) . const 1) 0 "abc"
17:26:22 <lambdabot>  3
17:26:44 * LoganCapaldo doubts the source to genericLength is written like that...
17:26:50 <LoganCapaldo> @src genericLength
17:26:50 <lambdabot> genericLength []    = 0
17:26:50 <lambdabot> genericLength (_:l) = 1 + genericLength l
17:29:12 <LoganCapaldo> @src length
17:29:13 <lambdabot> Source not found. My mind is going. I can feel it.
17:29:28 <shachaf> dons: What happened to lambdabot's @karma?
17:30:39 <ddarius> @seen lambdabot
17:30:39 <lambdabot> Yes, I'm here. I'm in #gentoo-haskell, #haskell, ##logic, #xmonad, #unicycling, #perl6, #parrot, #oasis, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #ghc, #darcs and #scannedinavian
17:31:00 <shachaf> @karma lambdabot
17:31:00 <lambdabot> lambdabot has a karma of -1
17:34:58 <chessguy> @hoogle OrderedSet
17:34:58 <lambdabot> No matches found
17:35:31 <bitwize> @hoogle readInt
17:35:31 <lambdabot> Numeric.readInt :: Integral a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
17:35:31 <lambdabot> Numeric.readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
17:35:31 <lambdabot> Text.Read.Lex.readIntP :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadP a
17:37:05 <ihope> Here, slight off-topic-ness: http://xkcd.com/156/
17:37:06 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
17:37:10 <ihope> How would that work for Haskell comics?
17:37:13 <ihope> Er, comments.
17:38:42 <chessguy> hmm, does haskell have an ADT like an OrderedSet?
17:39:54 <monochrom> Data.Set works as an ordered set.
17:41:08 <dcoutts> @seen dons
17:41:09 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 16m 53s ago.
17:41:31 <chessguy> monochrom, it's guaranteed to keep the members in order?
17:41:55 <dolio> That's why most of the operations have an Ord => context. :)
17:41:57 <dcoutts> dons: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/plugins-1.0 doesn't build, missing ../../../config.h when building src/Language/Hi/Parser.hs
17:42:00 <lambdabot> http://tinyurl.com/2mxmrt
17:42:41 <dcoutts> dons: and it looks like you're missing a .h file from the tarball which will be because you didn't tell cabal about the .h file so it did not include it in the sdist
17:44:17 <monochrom> It is an open secret that Data.Set is a balanced binary search tree. To answer your question, the members are not stored "in order" - it is a nonlinear tree, not a linear list - but it is not too much work for the computer to enumerate them in the < order.
17:46:29 <sorear>    The implementation of Set is based on size balanced binary trees (or trees of bounded balance) as described by:
17:46:33 <sorear>                                                                                                                                                                                                                     
17:46:37 <sorear>      * Stephen Adams, "Efficient sets: a balancing act", Journal of Functional Programming 3(4):553-562, October 1993, http://www.swiss.ai.mit.edu/~adams/BB.
17:46:39 <lambdabot> Title: Weight balanced binary trees
17:46:42 <sorear>      * J. Nievergelt and E.M. Reingold, "Binary search trees of bounded balance", SIAM journal of computing 2(1), March 1973.
17:46:45 <sorear> from @docs Data.Set
17:48:33 <dons> dcoutts: hmm. we should tag and upload the darcs version anyway
17:48:39 <dons> or take down the one on hackage.
17:48:59 <mrd> i use minView in Set sometimes
17:49:28 <dcoutts> dons: the former would be easier for us :-)
17:49:44 <dons> ok
17:49:46 <dcoutts> dons: today I decided hackage has come of age
17:49:53 <dons> yes, i saw the post. wonderful news!
17:50:04 <dcoutts> dons: I was able to merge ~60 packages into our overlay
17:50:08 <dons> you should write something about the gentoo merge process
17:50:13 <dcoutts> and all but 6 or 7 built first time
17:50:14 <dons> to inspire other distros
17:50:20 <dons> cool. that's good news
17:50:30 <dons> i'd imagine it was the old /demo packages, like plugins1.0 that failed?
17:50:43 <dons> and can we improve checks on hackage to prevent even those failing?
17:50:52 <dons> (from being uploaded)
17:50:58 <dcoutts> I didn't test absolutely every package
17:51:33 <dcoutts> I expected plugins to not work, but I tried it since I noticed it was 1.0 rather than 1.0_rc1
17:51:50 <dons> ok
17:51:57 <bitwize> I am starting to get totally hooked on this Haskell thing...
17:52:01 <dons> i think it was just put up there in the very early days to test packages
17:52:02 <dcoutts> dons: I just had a user bemoaning the lack of lambdabot in portage
17:52:08 <dons> heh
17:52:10 <ddarius> bitwize: Run, run while you have a chance!
17:52:14 <dons> bitwize: :)
17:52:27 <dcoutts> dons: and I said I'd love to, but it doesn't build with 6.6.x
17:52:33 <bitwize> ddarius: I wouldn't want my programming license revoked, would I?
17:52:56 <dons> dcoutts: ok. i'll note that. we might be able to upload it. and i can certainly tag/upload the darcs plugins package
17:53:07 <dcoutts> dons: or am I wrong? can you build with 6.6.x with suitable versions of hs-plugins?
17:53:19 <dons> you can build the darcs version
17:53:28 <dons> i doubt the 4.0 version would build though
17:53:32 <dons> its a few years old now
17:53:37 <dcoutts> dons: ah ok
17:53:52 <dcoutts> dons: we'll try anything on hackage :-) we've got the automation
17:54:01 <dcoutts> if it's not on hackage it doesn't exist
17:54:08 <bitwize> http://www.deviantart.com/deviation/60799166/ this came out of my recent hackery; I'm still a bit surprised I produced it
17:54:08 <lambdabot> Title: Beautiful Mandelbrot Set by ~bitwize on deviantART
17:54:36 <dcoutts> dons: that's what we've got to tell package authors, apply the pressure, if it's not on hackage it doesn't exist.
17:54:55 <dons> right!
17:55:00 <dcoutts> dons: although then we've got to make cabal-install work :-)
17:55:25 <dons> nice work bitwize
17:55:35 <jfredett> bitwize: cool!
17:55:41 <dons> dcoutts: yes, that's the next thing. packages like lambdabot have ~20 dependencies on hackage
17:55:43 <jfredett> *downloads source*
17:55:58 <dcoutts> dons: no probs
17:56:08 <dons> data Color = Color Word8 Word8 Word8 Word8
17:56:13 * monochrom contemplates a monster package that depends on all other packages.
17:56:16 <dons> bitwize: no need to add an extra tuple unnecessarily
17:56:20 <jfredett> its always good to see haskell art stuff
17:56:21 <jfredett> :)
17:56:21 <mauke> Acme::All
17:56:33 <ddarius> !!!!
17:56:42 <dcoutts> monochrom: you could call it 'testing' or 'unstable' :-)
17:57:05 <dons> ah that would be fun. cabal-install everything
17:57:18 <dcoutts> for QA purposes, we should do just that
17:57:21 <monochrom> No. I want the monster to do something useful. Maybe a web browser written in Haskell.
17:57:23 <dcoutts> regularly.
17:57:34 <dcoutts> monochrom: oh, heh
17:57:49 <jfredett> monochrom: I've actually been considering ways to do that
17:57:59 <ddarius> Yes!  A web browser with lambdabot built in!
17:58:01 <bitwize> "How about we tear the house down and grow root all over the backyard?"
17:58:02 <jfredett> just kind of passive back of the mind stuff
17:58:08 <jfredett> ddarius: thats not a bad idea
17:58:15 <jfredett> a webbrowser/irc client
17:58:17 <dcoutts> monochrom: jfredett: using cairo for the drawing and the layout done in pure Haskell :-)
17:58:41 <pjd> the crucial question is:  what will it be called?
17:58:43 <jfredett> dcoutts: I dunno, I figure after I'm done hacking around in my Finite Automata library
17:58:50 <bitwize> Havigator?
17:58:51 <jfredett> pjd: Horizon?
17:58:58 <pjd> jfredett: nice
17:59:00 <jfredett> as in, looking out on the?
17:59:08 <bitwize> jfredett: omg awesome.
17:59:12 <mrd> haszilla
17:59:16 <jfredett> heh, HaskTML?
17:59:36 <bitwize> jfredett: That's what we call the WYSIWYG editor.
17:59:37 * mrd ponders a gigantic monster in the form of a Lambda
17:59:46 <jfredett> lol
18:00:02 <jfredett> Horizon would be a good name for a browser
18:00:11 <pjd> a great name!
18:00:16 <mrd> probably taken
18:00:22 <bitwize> Horizon is a pert-near ideal name.
18:00:43 <pjd> doesn't look like it
18:00:47 <ddarius> Well now that we have a name for it, it must be implemented.
18:00:49 <jfredett> theres an image browser named horizon
18:00:53 <jfredett> ddarius: lol
18:01:00 <jfredett> someone set us up the Repo. :)
18:01:10 <jfredett> I'll hack at it when I have time
18:01:11 <jfredett> :)
18:01:30 <jfredett> mrd: besides, who cares if it's taken, we'll take it back
18:01:30 <wli> Name it after a species of spider with a nice-sounding name.
18:01:32 <pjd> s/us up/up us/
18:01:36 <monochrom> I am accountable for a few crazy ideas here.
18:01:45 <Alleria> A performance question -- given an infinite list, if I do sum $ take 100000 myList in GHCi...
18:01:51 <jfredett> pjd: righto, my bad
18:02:01 <dons> Alleria: yeah?
18:02:02 <pjd> :)
18:02:05 <Alleria> if I then re-run the same command, how come it's still taking a few seconds?
18:02:10 <mrd> > sum $ take 100000 [1..]
18:02:12 <lambdabot>  5000050000
18:02:17 <dons> because you've not memoised the result
18:02:31 <Alleria> dons: the list isn't persistent?
18:02:32 <jfredett> Alleria: I dont think GHCI memoizes automatically, like hugs seems to
18:02:37 <dons> not in this case
18:03:04 <mrd> Alleria: now, if it took a while to compute each list element in turn, then that would be memoized
18:03:08 <ddarius> Alleria: You won't have to reforce the evaluation of the first 100000 elements, but you will need to rebuild that list and sum it.
18:03:13 <mrd> because the list structure would be updated with the values
18:03:34 <Alleria> ddarius: so the first 100,000 elements *are* evaled for good, but it's the rebuilding of the list and summing it that's taking time?
18:04:05 <dons> do you see any difference if you let s = [1..] ; then sum (take n s) ?
18:04:21 <monochrom> lazy evaluation promises memoization, but only insofar as things bound to variable names and the variable names are still in scope.
18:04:25 <Alleria> ddarius: it's actually consistently taking 1.6 seconds or so to sum the first 10,000 elements on a MacBook pro, which seems awfully slow.
18:04:29 <dons> which will share the evaluated prefix of s, but given you're using ghci, it would be hard to notice any difference i think
18:04:37 <dons> Alleria: compile it!
18:05:12 <Alleria> dons: I'm loading the list definition in via :l, and then playing around with it. Is that good enough or no?
18:05:32 <dons> that's ok, but you're not allowed to complain about speed :)
18:05:37 <ddarius> let s = [trace "1" 1, trace "2" 2, trace "3" 3]; sum (take 2 s)
18:05:40 <ddarius> sum (take 2 s)
18:05:46 <dons> main = print . sum $ take 10000 [1..]
18:05:49 <dons> $ ghc -O2 A.hs
18:05:53 <dons> $ time ./a.out
18:05:53 <dons> 50005000
18:05:53 <dons> ./a.out  0.01s user 0.01s system 127% cpu 0.012 total
18:05:56 <SamB> Alleria: :!ghc -O2 --make foo.hs
18:05:59 <SamB> :l foo
18:06:08 <Alleria> Okay, I'll go compile it and then see. Thanks everyone. :)
18:06:17 <dons> :)
18:06:30 <dons> nice idea SamB !
18:06:36 <dons> that's a cute trick we can suggest to people
18:06:42 <SamB> you might need a "module Main where"
18:06:53 <dons> nah, you could add a -c though
18:06:57 <SamB> if you don't already export all the stuff
18:07:01 <dons> but that works fine as long as 'main' is defined
18:07:23 <SamB> dons: if you don't add "module Main where", nothing but "main" gets exported
18:07:29 <dons> yep
18:10:16 <Alleria> Hmm. Yep, compiling fixed it!
18:10:30 <Alleria> I wonder why GHCi was (I think) re-calculating the first 100,000 elements.
18:10:46 <Alleria> as opposed to just taking them from the infinite list, building a new one, and summing them.
18:13:08 <dons> ghci does'nt try very hard to be fast. it happens to do pretty well, (it wipes hugs off the map), but still, we just compile when speed is required
18:14:29 <Alleria> ahhh, I see.
18:14:53 <falconair> dons, any word on when the xmonad OSCON video will be available?
18:15:30 <dons> glguy is in charge of that. i hope soon
18:15:41 <falconair> ok, thanks
18:15:42 <dons> hmm, nice, http://blog.businessofsoftware.org/2007/07/the-curse-of-pl.html
18:15:43 <lambdabot> Title: Business of Software Blog: The curse of plenty: what El Mariachi tells us about  ...
18:16:13 <dons> small open source teams can produce good software, and they don't get sucked into writing bloat as easily :)
18:16:59 <SamB> or get prodded out of it ;-)
18:18:23 <Alleria> dons: Hmm, your nobench numbers really suggest that compiling is a massive win.
18:18:36 <ddarius> Alleria: Using Debug.Trace.trace you could verify whether or not the list was being reevaluated.
18:19:55 <Alleria> ddarius: thanks for pointing that out. I didn't realize such the module existed.
18:20:52 <psykotic> dons: hey
18:21:14 <psykotic> dons: did you see the thing i privmsged you last night while you were asleep? curious if you think something like that is feasible
18:21:31 <Cale> edwardk: It's not just a me-thing, actually I didn't come up with it, but I fully support it. There really should be a way to distinguish between the different behaviours. (and in many cases, both behaviours are reasonable to want in different situations)
18:22:27 <dgriffi3> does any one know if there is a normal way to include man pages with a cabalized program?
18:22:52 <dcoutts> dons: hey, darcs-graph is nice, fairly easy to use, though lacks a -o --output flag :-)
18:23:01 <dcoutts> dgriffi3: there is no standard way
18:23:42 <dcoutts> dgriffi3: cabal has no specific support for man pages, or indeed any non-haddock docs
18:24:18 <dgriffi3> dcoutts: thanks
18:24:46 <dons> dcoutts: oh, that's a good idea.
18:24:56 <dons> its more like `mktemp` currently
18:25:07 <dons> you're expected to run it from a shell script, and save the output result
18:25:23 <dcoutts> dgriffi3: if you're feeling energetic you could add man page building support to Cabal
18:25:42 <dcoutts> dgriffi3: we're always happy to review patches to Cabal
18:25:49 <dons> psykotic: ah, just waiting on my coffee to kick in first
18:25:49 <glguy> > length "internationalization"
18:25:51 <lambdabot>  20
18:26:11 <glguy> Did everyone else already know that i18n meant: i, 18 letters, n
18:26:11 <glguy> ?
18:26:14 <Cale> glguy: yep
18:26:18 <ddarius> yes
18:26:22 <psykotic> dons: don't feel obliged to answer.  :)
18:26:22 <glguy> man... I'm late to the party
18:26:31 <dons> Alleria: yeah, compiling is what, 30x better on average. and maybe a lot more for some particular data structures (such as bytestrings)
18:26:41 <SamB> I think I learned that in #twisted or something
18:26:47 <psykotic> cale: oh, so what i was asking dons about yesterday...
18:26:51 <dcoutts> dons: sure, I was just naively running it and got the slightly odd result of: Output written to: /tmp/.-commits.png
18:26:53 <dcoutts> :-)
18:27:06 <Nafai> psykotic: Hey, I remember reading a comment of yours on reddit that you worked for a company that developed a game engine...was it Garage Games?
18:27:38 <psykotic> cale: i'm tired of writing prop_Foo xs = out (in x) == x it'd be like to do prop_Foo = out . in === id instead. so i was thinking of having class EqProp a where (===) :: a -> a -> Property.
18:28:00 <psykotic> cale: then having a default instance for Eq-implementing types, and an implementation for a -> b that does pointwise testing using forAll or something.
18:28:38 <glguy> psykotic: why would that merit a new typeclass?
18:28:38 <psykotic> nafai:  no, epic gams.
18:28:46 <Nafai> psykotic: Ah, okay.
18:28:50 <glguy> psykotic: rather than a simple function definition?
18:29:14 <dons> dcoutts: ah ok. you were running it in `.' ? :)
18:29:22 <dcoutts> dons: right
18:29:24 <dons> yeah, it could be more unix-ish
18:29:54 <psykotic> glguy, i don't see how you can have it work otherwise. you need something like instance (Arbitrary a, Show a, EqProp b) => EqProp (a -> b) where f === g = forAll ... (\x -> f x === g x)
18:31:04 <ddarius> nice variation on variadic functions
18:31:06 <glguy> psykotic: I didn't see the "xs" vs "x" in the code above
18:31:11 <psykotic> glguy, sorry typo.
18:31:19 <psykotic> glguy, the point is that there's no == implementation for functions.
18:31:27 <psykotic> glguy, but you can implement one that returns Property instead of Bool, using forAll
18:31:28 <glguy> psykotic: I mean:
18:31:35 <falconair> glguy: i'm dying to see the haskell OSCON tutorial, any ETA on when it might be available?
18:31:48 <glguy> falconair: next week at minimum
18:32:07 <psykotic> glguy, i basically want to be able to "eta reduce" prop x = f x == g x to prop = f === g
18:32:11 <glguy> The person whose desk it is on at the video editing company is on vacation
18:32:37 <glguy> psykotic: I just didn't know why you couldn't write: (===) f g x = f (g x) == x
18:32:40 <falconair> glguy: oh...I'll be impatiently waiting ;)
18:33:10 <psykotic> glguy, i wanted === to subsume ==, first of all
18:33:40 <dcoutts> dons: my only problem with darcs-graph is that it gets in the way of bash tab-completion for darcs :-)
18:36:08 <dons> dcoutts: hah. graph-darcs eh/
18:36:28 <dcoutts> heh
18:40:40 <dgriffi3> dcoutts: you could set show-all-if-ambiguous
18:40:55 <dgriffi3> that should make it complete as much as it can
18:41:15 <dcoutts> dgriffi3: oh it does, but when it's unambiguous it adds a space after the command
18:41:28 <dgriffi3> ahh
18:41:48 <dcoutts> so I can type "dar\tre\t" and get "darcs record "
18:41:58 <dcoutts> saves me several keystrokes :-)
18:42:09 <dcoutts> darcs's bash-completion is excellent actually
18:42:25 <dcoutts> completes darcs command, flags and file arguments
18:42:45 <dcoutts> cabal needs bash completion imho
18:48:04 <dons> i have a 9G darcs repo
18:48:11 <ray> i found a haskell book in an actual bookstore :)
18:48:16 <dons> cool!
18:48:18 <dons> which book?
18:48:22 <ray> hudak
18:48:25 <ray> school of expression
18:48:46 <dons> nice. just in the usual computer languages section? or in philosophy and spirituality?
18:48:51 <ray> haha
18:49:10 <ray> under computer languages, but i actually hid it until i could come back with the coupon they email me
18:49:21 <dons> hehe good plan!
18:49:22 <psykotic> i've done that thing before too :)
18:49:24 <ray> under "music guides" (hey, it has multimedia in it)
18:50:20 <SamB> hahahaha
18:50:42 <dcoutts> dons: a 9G darcs repo? what is that?
18:50:42 <SamB> they won't let you use a coupon on books they order for you?
18:50:54 <ray> never tried, but somehow i think not
18:50:58 <sorear> .
18:51:05 <ray> lots of fine print
18:51:25 <ray> anyway, i suspect a haskell sympathiser was ordering books for them or something
18:51:27 <SamB> well, all you have to do is get them to accidentally shelve it ;-)
18:51:32 <ray> or maybe they just liked the pretty colours
18:52:11 <dons> dcoutts: darcs repo of irc logs. 256M of pristine, 9G of daily tags
18:52:14 <dons> :(
18:52:24 <sorear> dons, SamB: In recent versions of GHC you can just use -fobject-code
18:52:37 <psykotic> are there any gotchas with -funbox-strict-fields?
18:52:40 <dcoutts> dons: ahh, perhaps don't checkpoint those daily tags
18:52:53 <psykotic> aside from less potential for sharing i guess
18:52:55 <sorear> dons, SamB: that tells GHCi to generate native code and save it, and works with -O2
18:53:03 <SamB> sorear: huh
18:53:07 <dcoutts> dons: tags are cheap, so long as you don't make a checkpoint file
18:53:10 <SamB> interesting
18:53:23 <sorear> psykotic: No, but "less potential for sharing" can be important
18:53:33 <dcoutts> dons: you could probably get away with checkpointing only every couple weeks
18:53:35 <psykotic> sorear, clearly, i just wanted to make sure i had an idea of the range of gotchas
18:53:37 <SamB> dons: checkpoint monthly
18:54:03 <dons> yeah
18:54:09 <sorear> don't checkpoint.  backup!
18:54:18 <dons> i'm just not putting it in darcs currently
18:54:21 <sorear> or just use a more intelligent copy script
18:54:23 <dons> you can wget if you want the files
18:54:36 <dons> since its already on a backed up system
18:55:04 <hpaste>  sorear pasted "simple, fast, incremental.  beats darcs easily in the irc-logs nice." at http://hpaste.org/1979
18:55:29 <sorear> plain wget is nice, but it's not incremental
18:55:36 <sorear> s/nice/niche/
18:55:41 <SamB> dons: use fossil
18:55:41 <dons> yep
18:56:32 <dons> http://gnuvince.net/?p=405 :}
18:56:34 <lambdabot> Title: :gnuvince.net  Blog Archive  programming.reddit&#8217;s top 10 posters (karma- ...
18:57:05 <dons> all due to the rss feed I (and linuxer-script) use, ensuring nothing gets missed.
18:57:32 <Nafai> dons: http://programming.reddit.com/info/2au21/comments/c2aurs :)
18:57:33 <lambdabot> Title: :gnuvince.net » Blog Archive » programming.reddit’s top 10 posters (karma-wh ...
18:58:17 <dons> hhah
18:58:28 <dons> i just submit the links, I don't write all of them :)
18:58:59 <Cale> The linuxer script is also pushing down the signal to noise ratio heavily
18:59:13 <Nafai> I wonder who is in charge of that
18:59:23 <psykotic> cale: quit whining :)
18:59:26 <Cale> I wonder what would happen if I just started clicking the report button.
18:59:29 <psykotic> cale: enough people apparently like his submissions
18:59:52 <Cale> psykotic: its
19:00:01 <dons> yeah, i note linuxer submits maybe 20 a day, of which 2/20 get >0
19:00:02 <psykotic> i don't believe it's fully automated.
19:00:13 <dons> i think i've only had a handful of links ever score 0
19:00:24 <psykotic> right now he has three good links on the front page
19:00:29 <psykotic> the fact that cale doesn't like them has no bearing :)
19:00:34 <Cale> Most of its links score 0
19:00:34 <dons> heh
19:00:48 <psykotic> it's hit or miss, but i wouldn't call that spam
19:00:58 <dons> i've got 1/4 of linuxers karma, from 1/20th the submission. i rock :)
19:01:06 <dons> maybe a lot less than 1/20th
19:01:33 <dons> so now can we trade in karma for extra down mods?
19:01:47 <Cale> psykotic: I currently mod down 90% of everything which gets posted to programming.reddit.
19:02:02 <dons> currently? haven't you always done that? :)
19:02:13 <Cale> Well, I have been for the last few months.
19:02:24 <Excedrin> I mod everything up, so it balances out
19:02:26 <Cale> Before that, it was actually better :)
19:02:31 <dons> heh
19:02:47 <Cale> actually, let's look at my 'new'
19:02:59 <Cale> 1,9,43,92,101,105,117,...
19:03:09 <dons> hah
19:03:14 <Cale> (this is a list of not-modded-down articles)
19:03:17 <dons> yeah, martinbishop is back.
19:03:28 <dons> ` The Pict Programming Language (neat language based on pi-calculus) '
19:03:35 <dons> with his ML-ish flavour
19:04:10 <dons> linuxer-script just has rss feeds for keywords, i often see all the same links as he later submits.-- but he does no quality filtering
19:04:30 <dons> so often if you see a haskell link get submitted by linuxer, that was one i thought wasn't very interesting
19:04:56 <dons> he also doesn't follow threads, or find on-topic material :/
19:05:09 <Cale> It's just random crap.
19:05:12 <monochrom> So he finds off-topic material? :)
19:05:26 <dons> yeah, keywords for erlang,haskell,python,scala, ruby, revision control
19:05:48 <ray> darcs seems to have pretty good zsh completion too
19:06:05 <dons> monochrom: more that people submit articles providing background info about stuff discussed in comments
19:06:26 <dons> so you get a nice feedback, an enriching of the discourse :)
19:06:27 <psykotic> dons: you can't explain his submission patterns by that. counterexamples:
19:06:38 <dons> he does spot some themes, and adds new keywords
19:06:44 <dons> revision control was one that he suddnely picked up on
19:07:19 <dons> also, at about the same time everyday 30 links land by linuxer. so probably morning rss feeds (rather than a script running)
19:07:20 <psykotic> http://www.eurekalert.org/pub_releases/2007-07/uor-hgd072507.php, http://blogs.zdnet.com/emergingtech/?p=645, http://blogs.msdn.com/fontblog/archive/2005/11/08/490490.aspx, http://www.linuxjournal.com/article/8035
19:07:21 <lambdabot> Title: Hand gestures dramatically improve learning
19:07:26 <psykotic> just from the last 30 submissions
19:07:49 <dons> interesting. so what's the pattern there? you think he chases content manually as well?
19:07:54 <psykotic> yes
19:08:03 <Cale> But he clearly doesn't respond to comments
19:08:04 <dons> so there's feeds, and then tech news he reads
19:08:19 <psykotic> i'm sure he uses a blog reader with filtering and so on
19:08:25 <dons> yeah
19:08:32 <psykotic> i even do that, when there are blogs i don't care about 90% except for specific topics
19:09:00 <dons> I use the following feeds in snownews, a console rss reader:
19:09:01 <dons> http://www.google.com.au/blogsearch_feeds?hl=en&c2coff=1&lr=lang_en&safe=off&scoring=d&q=haskell+programming+OR+language&ie=utf-8&num=50&output=rss|||
19:09:01 <lambdabot> http://www.google.com.au/blogsearch_feeds?hl=en&c2coff=1&lr=lang_en&safe=off&scoring=d&q=haskell+programming+OR+language&ie=utf-8&num=50&output=rss|||
19:09:04 <dons> http://planet.haskell.org/rss20.xml|||
19:09:14 <dons> hah lambdabot.
19:09:39 <psykotic> "An Australian computer scientist says that the next generation of search engines will be able to retrieve music for you when you sing a song to your computer. She said that ‘in the next three or four years it should be on the computer of everyone who is a music fanatic."
19:09:43 <dons> but planet.haskell.org is becoming increasingly better, while the google rss feed is getting worse
19:09:44 <psykotic> this is high quality stuff
19:09:59 * psykotic laughs
19:10:19 <dons> yeah, googles rss is getting spammed more regularly now
19:11:08 <monochrom> And video search too? You pose some postures or actions in front of your webcam, and the search engine replies "that's in the Matrix movies"? :)
19:11:08 <dons> i should add feeds for ML programming and other PL theory
19:11:09 <Excedrin> The next generation of search engines will be able to clone beef muscle tissue when I search for cheeseburger.
19:11:23 <dons> no one submits Isabelle/ theorem proving blogs 'cept alphecar
19:11:48 * dons tries finding some other nice feeds
19:11:57 <dons> in the eternal battle against linuxer
19:12:33 <monochrom> You sound like someone playing poker against a computer. :)
19:12:36 <gravity> dons: I don't think there's enough haskell in the world to compete with that guy
19:12:47 * sorear should start blogging about theorem proving
19:12:58 <monochrom> that's why dons is adding ML and other PL stuff now :)
19:13:03 <dons> gravity: no no, just good prog. language theory feeds.
19:13:14 <gravity> ha!
19:13:15 <Excedrin> what does someone playing poker against a computer sound like?
19:13:17 <dons> there's enough haskell for 1/4 of linuxer's feeds, so we need to bring in the other stuff
19:13:53 <Cale> > 25/364
19:13:55 <lambdabot>  6.868131868131869e-2
19:14:31 <Cale> > (1 - 25/364) * 100
19:14:32 <lambdabot>  93.13186813186813
19:14:58 <Cale> 93% of recent articles have been modded down by me :)
19:16:22 <dons> heh
19:16:30 <dons> ruthless
19:18:18 <mrd> i've managed to go reddit-free since March
19:18:57 <Excedrin> > (1 - 0) * 100
19:18:58 <lambdabot>  100
19:19:51 <Cale> It's not hard with articles like "a collection of startup stories"
19:20:06 <Cale> I don't even have to look at that to mod it down
19:20:19 <dons> so i've got feeds for isabelle, theorem proving, epigram, SML and OCaml now :)
19:20:25 <dons> that should provide some material
19:20:47 <Cale> I wish there was a way to turn my current view of reddit into an RSS feed for others to use :)
19:21:04 <dons> hmm. nice idea
19:21:19 <dons> since you went to a bit of effort to post-process linuxer et al
19:21:21 <mrd> a cale-subscription
19:21:26 <Cale> Indeed.
19:21:39 <mrd> you should suggest it to the reddit ppl
19:21:40 <psykotic> the blog tsar
19:21:41 <psykotic> :)
19:21:41 <dons> you should ask reddit for rss access to your recommendations :)
19:22:07 <psykotic> it would be nice if you could subscribe to someone else's "filter" for sure
19:22:13 <psykotic> i wonder if that's part of the new features coming in the next release
19:22:20 <mrd> i wouldn't mind reading some of the articles i hear about, but i won't touch reddit
19:22:42 <dons> mrd, so you missed out on the SPJ videos over the weekend?
19:22:51 <mrd> sadly. but were they posted elsewhere?
19:22:58 <Cale> Maybe I should just learn HAppS or something and code up something similar to Reddit.
19:23:01 <dons> they often get posted here too
19:23:08 <dons> and eventually make the HWN
19:23:22 <mrd> i like the blog article list on hwn
19:23:28 * monochrom contemplates the notion of "Internet Users as Communicating RSS Processors (CRP)". Let's hope Hoare doesn't hear about it, lest he has a heart attack and then we will also need CPR.
19:23:31 <mrd> i usually open a bunch of tabs to read those
19:23:35 <dons> yeah, that's basically everything that was on reddit anyway
19:23:52 <dons> but you get it without qwe1234's comments :)
19:24:10 <mrd> or the temptation to blow the entire day surfing reddit
19:24:18 <dons> yeah
19:24:31 <dons> http://programming.reddit.com/info/2aw07/comments
19:24:32 <dons> :)
19:24:32 <lambdabot> Title: Choosing a Proof Assistant (reddit.com)
19:24:45 * mrd resists
19:25:18 * sorear reads, s/comments/article
19:25:54 <bitwize> dons: VALYOO SUMMANTIKS
19:26:14 <dons> :)
19:26:15 <mrd> did you get a chance to peek at my email yet?
19:26:17 * pjd falls over at CRP
19:26:35 <dons> mrd, i've peeked, not looked at the code yet
19:26:39 <bitwize> IN THE NAME OF STROUSTRUP I REVOAK YUOR PORGAMMING LISCENCE
19:26:39 <dons> sounds like the right approach
19:26:39 <monochrom> Haha, that guy is scared by using extensions written in Lisp, and not extensions written in Java? :)
19:27:32 <mrd> it's that PairLevel thing which feels awkward
19:28:02 <mrd> if only I had more oleg
19:28:07 <Nafai> monochrom: No kidding...has he read the code for most Java stuff?  *shudders*
19:28:35 <mrd> so those video presentations were linked on haskell.org
19:29:08 <dons> another nice one, http://programming.reddit.com/info/2aw1a/comments
19:29:09 <lambdabot> Title: Strong specifications in Coq: the type says everything (reddit.com)
19:30:41 <dons> argh!
19:30:43 <dons> " A case for proof assistants, and a comparison   (syntheticabstractions.blogspot.com)
19:30:46 <dons> 11 points posted 3 months ago by linuxer save hide
19:30:48 <dons> report "
19:30:50 <dibblego> hey I was about to paste that!
19:30:59 <dons> I was just reading it, and linuxer already has it hmm.
19:31:13 <dons> maybe he grabs blog feeds to a private aggregator?
19:31:21 <monochrom> I want to ask nicely if anyone is willing to answer. How configurable is reddit for a human reader such as me? For example can I tell it to "show only stuff posted by cale and dons"?
19:31:24 <dibblego> dunno, but he gets stuff from *everywhere*
19:31:26 <dons> dibblego: got your kid onto Isabelle or Coq yet?
19:31:31 <dons> :)
19:31:35 <Cale> bitwize: YUOR MOM USES HOARE SEMANTICS
19:31:37 <dibblego> dons, I think that'll be a while :)
19:31:40 <dons> monochrom: not yet
19:31:44 <dons> Cale: hah
19:32:02 <monochrom> @remember Cale YOUR MOM USES HOARE SEMANTICS
19:32:02 <lambdabot> Done.
19:32:07 <wchogg> A foolish question:  what kind of logic does something like Coq use?
19:32:15 <Cale> monochrom: YUOR
19:32:21 <monochrom> OK, sorry.
19:32:47 <monochrom> Coq uses a constructivist logic with stratified dependent type.
19:32:47 <dons> there's a lot less blogs comig up for theorem proving, epigram, isabelle than for haskell
19:32:59 <Cale> No point in writing all caps if you're not going to imitate B1FF/JeffK
19:33:04 <mrd> Coq uses the calculus of inductive constructions
19:33:10 <wchogg> Well when epigram 2 is done that may change
19:33:15 * sorear recently started learning Coq
19:33:21 <mrd> there's a great chart somewhere, can't recall now
19:33:29 * sorear is trying to prove his unlambda compiler correct
19:33:38 <dons> sorear: might be a job for twelf?
19:33:49 <wchogg> mrd:  Ah...I'll be honest that doesn't mean anything to me yet, is there a good place to start?
19:33:51 <psykotic> coq is nice, but is rather read-only
19:33:52 <dons> since you can just write down your implementation almost directly in twelf.
19:34:02 <psykotic> it has a nice declarative language, which should be nicer and closer to twelf in spirit
19:34:09 <sorear> Monadic IO is very, very useful.  I can't imagine doing it any other way within logical confines :)
19:34:11 <dons> (its tuned specifically for proving stuff about compilers and languages)
19:34:19 <psykotic> (i think that hasn't been released yet, it's in cvs head)
19:34:24 <dons> ok, the SML feed is useless too
19:34:26 <mrd> yea twelf is pretty good for PLs, but i miss the interactive prover
19:34:39 <mrd> wchogg: admittedly, i picked up the Coq'art book from the library
19:34:53 <monochrom> Coq implements the Curry-Howard isomorphism.
19:34:56 <mrd> @google berkeley coq course
19:34:57 <lambdabot> http://www.cs.berkeley.edu/~adamc/itp/
19:34:58 <lambdabot> Title: Interactive Computer Theorem Proving
19:35:08 <mrd> if you don't mind reading something Smerdy prepared =)
19:35:19 <wchogg> monochrom:  So it comes down to an intuitionist logic?
19:35:21 <psykotic> smerdy's lambdatamer code is also very nice
19:35:29 <psykotic> despite him being the biggest asshole on earth
19:35:32 <monochrom> Yes.
19:35:52 <psykotic> wchogg, you can do classical logic if you want.
19:36:06 <monochrom> Yes.
19:36:09 <SamB_XP_> he doesn't seem to know what an asshole is
19:37:09 <SamB_XP_> apparantly they don't teach that at University or something
19:37:20 <monochrom> The Coq manual or tutorial or something is worth a read. It shows you how to do stuff and what its type system feels like.
19:37:23 <wchogg> Now, this is something that I'm still fuzzy on:  the set of intuitionist logics include classical logic as a subset?  I read one thing that made the two sound incompatible.
19:37:39 <sorear> SamB_XP_: He's the most helpful person in #coq.  (Multiple meanings deliberate)
19:37:48 <|Steve|> heh
19:37:50 <Cale> wchogg: Classical logic embeds into intuitionist logic in a funny way
19:37:53 <mrd> wchogg: the difference really comes down to th elaw of excluded middle
19:37:56 <SamB_XP_> how many people are there in #coq?
19:37:59 <psykotic> sorear, he will answer your question, while insulting your intelligence. but yes, he knows Coq well.
19:38:14 <wchogg> Cale:  How funny?
19:38:19 <Cale> wchogg: (The classical proposition A can be represented by ~~A)
19:38:22 <monochrom> If you take intuitionistic logic and add a few more axioms, you get classical logic. That's their relation. Coq is natively intuitionistic, but you can also add your own axioms unquestioned.
19:38:25 <SamB_XP_> he doesn't seem to know how to not insult your intelligence
19:38:47 <sorear> psykotic: I didn't notice, unlike the time I tried to get help from #debian
19:38:57 <mrd> also: Require Import Classical or something if you don't want to do it yourself
19:38:59 <wchogg> Okay.  So it really just comes down to how ~~ works as an operator, and if you assume that it's the identity then it's classical logic?
19:39:05 <gravity> sorear: It's gotten better
19:39:11 <gravity> #debian that is
19:39:12 <Cale> Yeah, I think so.
19:39:17 <psykotic> wchogg, at the level of proof theory, there's a bigger difference, unless you choose your proof theory well.
19:39:24 <mrd> but constructive logic is where it's at -- extracting certified programs
19:39:42 <psykotic> wchogg, for example, one of the great benefits of gentzen's sequent calculus is that there really is just a difference between the proof system for classical and intuitionist logic.
19:39:55 <Cale> Yeah, I'm only giving consideration to entailment, not actually how you prove the things.
19:39:58 <psykotic> err, is just a difference -> is just a difference of a single inference rule
19:40:22 <psykotic> (i'm thinking of LK vs LJ)
19:40:27 <wchogg> psykotic:  Whoo boy...I'm not sure if I understand what you mean by proof theory here.  I'm a total newb when it comes to logic, just started getting interested because via topoi.
19:40:49 <psykotic> wchogg, it's the study of proofs as first class objects, essentially.
19:40:52 <monochrom> You know more topoi then I do. :)
19:41:09 <psykotic> wchogg, when you consider the curry-howard isomorphism, that shouldn't sound too outlandish.
19:42:02 <wchogg> psykotic:  No, it doesn't.  ...still trying to picture a categoric structure for it though.
19:42:14 <SamB_XP_> I will now prove that a thing implies itself!
19:42:24 <wchogg> Madness!
19:42:30 <SamB_XP_> @djinn a -> a
19:42:30 <lambdabot> f a = a
19:42:47 <mrd> proof by djinni!
19:42:55 <sorear> djinn only implements quantifier-free first order intuitionistic logic
19:42:59 <psykotic> wchogg, no need, it's very simple. the common conception is that a proof is a tree, with leaves labeled by assumptions and the root labeled by the conclusion.
19:43:15 <psykotic> wchogg, the edges are labeled by inference rules.
19:43:23 <SamB_XP_> sorear: it still demonstrates proofs as first class objects though ;-)
19:43:34 <psykotic> wchogg, trees as first class objects is a very CS idea :)
19:43:49 <mrd> @djinn a -> [(a,b)] -> Maybe b
19:43:49 <lambdabot> f _ _ = Nothing
19:43:56 <SamB_XP_> now, I'll prove that a implies a or b
19:43:57 <wchogg> So inference rules are constructors that take in propositions and spit out new propositions?
19:43:58 <mrd> mm proof irrelevance
19:44:06 <psykotic> wchogg, now, once you have this notion you can ask all sorts of natural questions. for example, we know that there are many proofs of the same proposition. there's a notion of "normalized" or "canonical" proof and that turns out to be interesting.
19:44:08 <SamB_XP_> @djinn a -> Either a b
19:44:08 <lambdabot> f = Left
19:44:22 <mrd> @djinn a -> [(a,b)] -> b -> b
19:44:23 <lambdabot> f _ _ a = a
19:44:39 <wchogg> psykotic:  Is it like an initial algebra in some way?  The "canonical" proof?
19:44:42 <sorear> http://members.cox.net/stefanor/hanoi.v <- have a tower of hanoi program of type  forall s1 s2, length s1 = length s2 -> reach s1 s2
19:44:46 <kpreid> mrd: djinn isn't clever about recursive types like lists
19:44:55 <mrd> well in any case, this is a good demonstration of why that fellow used the big old refine tactic in that blog article dons posted
19:45:16 <wchogg> Durr...my head a splode.
19:45:43 <Cale> I always find it funny when people try to apply proof assistants to classical mathematics :)
19:45:57 <psykotic> wchogg, well, there can be multiple unrelated normal proofs of a given prop. normality has to do with eliminating certain kinds of steps. for example, in haskell consider the equivalence between id :: (a,b) -> (a,b), id x = x and id' :: (a,b) -> (a,b), id' x= (fst x, snd x).
19:45:57 <SamB_XP_> Cale: hmm?
19:45:58 <sorear> Cale: ToH is classical?
19:45:59 <bitwize> oooooo. canonical proofs...
19:46:22 <psykotic> wchogg, you can see that the second in some sense normalizes to the first, since the (,) constructor and the fst and snd deconstructors "cancel out".
19:46:25 <Cale> For some reason it always ends up being ridiculously unconvincing.
19:46:39 <Cale> (Compared to the usual proof.)
19:46:39 <mrd> sorear: that coq code is remarkably clear.  most example code I see is a giant mess :/
19:46:50 <wchogg> psykotic:  Yeah, that does make sense.
19:47:10 <psykotic> wchogg, you have a similar cancellation going on with lambda abstraction followed immediately by lambda application.
19:47:14 <sorear> mrd: my hanoi.v is clear!?  it was the very first thing I did, as a learning exercise, without a book!
19:47:31 <SamB_XP_> sorear: maybe that's why it's clear
19:47:32 <mrd> sorear: yea, i think that helps -- the more things you know, the more fancy tricks you play =)
19:47:54 <wchogg> psykotic:  So do we get some notion of "length" by considering proofs by the depth of their tree, and the canonical is the least deep?
19:48:15 <psykotic> wchogg, it's not canonical in that sense.
19:48:18 <psykotic> wchogg, it's a more local property.
19:48:46 <sorear> psykotic: Are you talking about the CH counterpart to beta-normal forms?
19:48:55 <psykotic> wchogg, it has to do with being able to eliminate, for example, all lambda abstractions followed immediately by application. it might seem obvious that these can always be eliminated--just do the substitution corresponding to their "Fusion".
19:49:38 <psykotic> wchogg, but the problem is that application can cause certain terms to be multiplied in existence, so naively considered, the "complexity" of a term can actually increase.
19:50:14 <psykotic> wchogg, so the fact that you can eliminate all these pairings is actually the same as the result that all terms can be fully evaluated (i.e. "everything terminates").
19:50:19 <psykotic> sorear, yep
19:50:34 <dons> sorear: do you use any theorem proving for high school math problems?
19:50:36 <wchogg> So if not everything terminates...
19:50:43 <dons> (do you do proofs in high school maths in the US?)
19:50:52 <mrd> ha
19:50:53 <bitwize> of course dons.
19:50:59 <dons> ah ok :)
19:51:04 <wchogg> dons:  Err, usually only in freshman geometry from what I've seen.
19:51:05 <SamB_XP_> I did some in geometry
19:51:13 <SamB_XP_> but I was homeschooled, so...
19:51:16 <sorear> dons: I don't have high school math anymore, the headmaster has given up on finding a qualified teacher.
19:51:17 <psykotic> wchogg, then you don't have anything like this, right. so, the theorem that all terms in simply-typed lambda calculus "terminate" is equivalent to the theorem that all proofs in natural deduction are normalizable.
19:51:25 <mrd> sorear: how about you teach it? ;)
19:51:31 <mrd> make the kids learn coq
19:51:39 <sorear> mrd: That's actually been proposed. :/
19:51:48 <dons> :(
19:51:49 <SamB_XP_> actually I think I may have proved the extension of the pytagorean theorem to 3-space...
19:51:51 <psykotic> coq seems poor for that
19:51:59 <mrd> you can get yourself a pretty easy interactive natural deduction in coq actually
19:52:02 <bitwize> sorear: for me they brought an instructor in from the local community college.
19:52:07 <psykotic> it encourages random mucking about to an extent that i think would be damaging to someone first learning proofs
19:52:25 <SamB_XP_> (seperately. because I wanted it.)
19:52:30 <sorear> SamB_XP_: I've proved it for arbitrary n-space.  it's a pretty simple inductuion
19:52:40 <Cale> http://au.metamath.org/mpegif/blcntr.html -- here's a proof that a ball in a metric space contains its centre.
19:52:42 <lambdabot> Title: blcntr - Metamath Proof Explorer
19:52:44 <SamB_XP_> sorear: well I didn't even bother after 3-space
19:52:59 <dons> sorear: i did extended classes in the mornings and afternoons, before/after school. that was fun.
19:53:06 <dons> but you need a good teacher, who's motiivated
19:53:09 <psykotic> cale: god i hate linear hilbert-style proof systems. :)
19:53:12 <SamB_XP_> I think I saw how one would procede, and decided it wasn't worth the bother
19:53:46 <psykotic> btw i remember a niec paper by leslie lamport, he of distributed systems and late xfame
19:53:52 <wchogg> psykotic:  Okay, now do we get bitten by Goedel at some point and have proof systems where we can't always normalize the proof, i.e. correspond to termination?
19:53:59 <sorear> they were able to get someone for one year.  linear algebra and metric therory.
19:54:07 <psykotic> he basically proposes a less formal version of proof trees in the style of natural deduction for proofs in papers and such
19:54:10 <Cale> http://au.metamath.org/mpegif/cnpmet.html -- equivalence of two definitions of continuity :)
19:54:10 <psykotic> let me find it, it's really niec
19:54:11 <lambdabot> Title: cnpmet - Metamath Proof Explorer
19:54:18 <sorear> which probably helped a lot with my bootstrapping
19:54:20 <dons> sorear: aare you near any unis? you could just hang out in the uni library :)
19:54:45 <dons> or any chance to get into an accelerated program, to get to uni a year early?
19:54:47 <psykotic> http://research.microsoft.com/users/lamport/pubs/lamport-how-to-write.pdf
19:54:49 <lambdabot> http://tinyurl.com/3bwou2
19:55:05 <psykotic> (how to write a proof)
19:55:43 <bitwize> ooooo.
19:57:49 <dons> hi gnuvince_ :)
19:58:42 <Cale> http://au.metamath.org/mpegif/cmms.html -- Proof that a complete metric space is a metric space. (Sure, it's trivial, but it's still kind of silly that they had to generate it.)
19:58:44 <lambdabot> Title: cmms - Metamath Proof Explorer
19:59:56 <hpaste>  jfredett pasted "Type not carrying over" at http://hpaste.org/1980
20:00:00 <jfredett> :/
20:00:04 <wchogg> Cale:  Not entirely sure I understand what these links are of?
20:00:22 <psykotic> wchogg, proofs of results in ZF.
20:00:50 <Cale> Well, extra-formal versions of them
20:00:53 <psykotic> wchogg, that whole site is a like a database of theorems and proofs. the idea is that you can chase anything back to the ZF axioms + the theory-specific axioms.
20:00:56 <psykotic> right :)
20:01:09 <wchogg> Huh.
20:01:15 <ddarius> jfredett: ! doesn't operate on tuples.
20:01:16 <Cale> They're being uselessly formal.
20:01:24 <jfredett> ddarius: damn
20:01:26 <psykotic> cale: i assume they do machine checking
20:01:28 <sorear> but why ZF? :)
20:01:33 <mrd> perhaps one day they will show that all of mathematics is consistent!
20:01:35 <Cale> psykotic: I think they do.
20:01:36 <mrd> oh wait
20:01:42 <psykotic> sorear: because it's what mathematicians use?
20:01:44 <jfredett> is there any kind of map that will operate on a tuple like that?
20:01:50 <Cale> Actually, it's ZFC
20:01:54 <jfredett> its for a DFA delta function- :/
20:02:08 <psykotic> cale: what about CH? :)
20:02:08 <SamB_XP_> mrd: you think they are going to prove that math is incomplete sometime?
20:02:10 <SamB_XP_> go figure!
20:02:18 <mrd> SamB_XP_: perhaps in this century!
20:02:21 <jfredett> I'd really like to use a map, for speed, in big automata, that'll matter, Linear search is a pain. :/
20:02:46 <sorear> jfredett: flip the arguments to M.!
20:02:48 <Cale> psykotic: They have a little section where they assume GCH.
20:03:05 <mrd> jfredett: yea what sorear said
20:03:10 <monochrom> Cale: That is confusing. Call me "that's just semantics", but formal and detailed are still orthogonal. Metamath may be uselessly detailed. That does not imply uselessly formal.
20:03:15 <mrd> you were thinking of M.lookup
20:03:20 <jfredett> sorear, ? you mean make the map be Map State a (State a, Symbol a)
20:03:29 <jfredett> and then just use flip M.! ?
20:03:34 <jfredett> or do i even need to do that?
20:03:34 <sorear> jfredett: Don't change the types.
20:03:34 <mrd> mp M.! (st,sym)
20:03:44 <sorear> jfredett: the map is the first argument to M.!
20:03:48 <sorear> NOT the second
20:03:49 <jfredett> ?
20:03:53 <jfredett> i misread the type
20:03:55 <wchogg> Cale:  What area of math have you been doing, anyway?
20:04:03 <jfredett> damn, I'm dumb as hell
20:04:13 <Cale> wchogg: I'm mostly into algebraic combinatorics.
20:04:36 <mrd> jfredett: i never used M.! always lookup.  didn't realize it existed
20:04:45 <Cale> wchogg: I also like algebraic topology. Generally, things with algebra and something else.
20:05:01 <jfredett> well, mrd, I didn't want to deal with Maybe in the delta function
20:05:01 <wchogg> Cale:  I'll agree with you on algebraic topology, definitely.
20:05:02 <Cale> (I don't care *too* much for pure algebra though.)
20:05:22 <jfredett> I've just been using error, I prefer to fail loudly
20:05:25 <wchogg> I'm trying to get into some programs that do both diff geo and category theory, myself.
20:06:25 <Cale> When your proofs are so formal that it starts becoming unconvincing that they would work in any formalisation but yours, that's when I think you've gone too far.
20:06:59 <wchogg> What's algebraic combinatorics, anyway?  Don't think I ever dug enough into combinatorics to see it.
20:07:40 <Cale> wchogg: Basically, forming correspondences between sets of combinatorial objects and algebraic objects.
20:07:55 <Cale> Did you get as far as generating series?
20:08:09 <psykotic> i guess a good example is polya-burnside counting
20:08:11 <psykotic> ?
20:08:21 <monochrom> OK, that means Metamath is too tied up with ZFC. There are ways, even formal ways, of abstracting way from particular foundations.
20:08:29 <wchogg> Sounds familiar, but I don't really remember what it means.
20:09:00 <monochrom> As programmers we know how to play that game of being formal and still versatile.
20:09:41 <Cale> Okay, so if you have a set of combinatorial objects A, and a weight function: w:A -> N, then the (ordinary) generating series for A with respect to the weight w is:  sum over a in A of x^w(a)
20:09:54 <Cale> This is a sum in the ring of formal power series.
20:10:03 <Cale> (over some suitable field)
20:11:04 <Cale> So for example, if your set is binary strings of length 3 with respect to the number of 1's, that is {000,001,010,100,011,101,110,111}, its generating series is 1 + 3x + 3x^2 + x^3
20:11:14 <Cale> Note that this is (1 + x)^3
20:11:38 <Cale> and that (1+x) is the generating series for the set of binary strings of length 1 with respect to the number of 1's
20:11:50 <Cale> So it looks like there's something interesting going on there :)
20:12:45 <falconair> say i am reading raw bytes off a network using bytestrings, what is the best way for me to: convert the first 4 bytes to an integer 'x', convert another set of bytes to integer 'y', separate out 'x' number of bytes and convert them to a tuple (or record) of haskell primitive types (integer, char, double, etc.) according to some scheme defined in 'y' ?
20:13:15 <falconair> basically i am trying to access a real-world protocol using haskell
20:13:24 <Cale> Of course, there is: if f(x) is the g.s. for the set A with respect to the weight u, and g(x) is the g.s. for the set B with respect to the weight v, then f(x)g(x) is the g.s. for AxB with respect to the weight w((a,b)) = u(a) + v(b)
20:14:13 <falconair> according to Data.Binary docs, when dealing with complex protocols, it is better to work directly with Get/Put monads ... but while getWord8 is obvious, how can I 'getInt' or 'getChar' ?
20:14:17 <Cale> So there's a simple correspondence here between the combinatorial structure of forming pairs and the algebraic structure of multiplication in the ring of formal power series.
20:14:28 <wchogg> Huh, okay.
20:14:42 <monochrom> getWord8, then use "fromIntegral" to convert to Int.
20:15:24 <falconair> monochrom: how can I get chars, double, strings of specific length, etc.?
20:15:33 <wchogg> So forming strings can be considered quotient of the free monoid on the set, and then you have some kind of functor that maps that into a ring...
20:15:36 <Cale> Addition corresponds to disjoint union, multiplication to Cartesian product
20:16:18 <SamB_XP_> what a strange juxtaposition
20:16:25 <SamB_XP_> you never see that anywhere else
20:16:34 <SamB_XP_> do you?
20:16:45 <Cale> SamB_XP_: are you being sarcastic?
20:16:52 <SamB_XP_> Cale: no!
20:16:55 <ddarius> SamB_XP_: Which juxtaposition?
20:17:06 <psykotic> falconair, for floats, see encodeFloat, i think
20:17:20 <wchogg> I think he's talking about practical programming adjacent to geeking out about math.
20:17:24 <Cale> oh
20:17:34 <ddarius> wchogg: That's what I was thinking too.
20:17:40 <Cale> I thought he was talking about the particular juxtaposition that I was talking about :)
20:17:44 <SamB_XP_> Cale's talking about combinatorics and so on while falconair and monochrom discuss the nitty-gritty of implementing binary protocols
20:17:46 <ddarius> You definitely see it elsewhere.
20:17:46 <bitwize> @hoogle encodeFloat
20:17:46 <lambdabot> Prelude.encodeFloat :: RealFloat a => Integer -> Int -> a
20:18:24 <psykotic> bitwize, it takes an exponent and mantissa. so if have an IEEE float as a bunch of bits, you just extract the parts you need as integers and feed them to encodeFloat.
20:18:58 <bitwize> noice.
20:19:13 <monochrom> chr :: Int->Char.  getBytes :: Int -> Get ByteString  (then you convert ByteString to string, paying attention to encoding).  I have not known a real-world network protocol needing double.
20:19:54 <Cale> wchogg: There are more operations too... if f(x) is the g.s. for a set of objects having no objects with weight 0, then 1/(1-f(x)) is the g.s. for strings of those objects, with additive weight.
20:20:28 <psykotic> monochrom, encodeFloat/decodeFloat works with the RealFloat type class, so it works for both Floats and Doubles, IIRC
20:20:46 <Cale> This is a special case of a lemma that can be proved about composition, and the fact that 1/(1-x) is the g.s. for natural numbers with the identity function as weight.
20:20:53 <wchogg> OKay...although I assume there's some caveats about the ability to form 1/(1-f(x)) since we're just working over a ring?
20:21:00 <SamB_XP_> ddarius: okay, like where?
20:21:05 <falconair> this protocol is for subscribing to stock market data, so I expect all kinds of numbers
20:21:07 <Cale> Right, that's what the condition I stated was about.
20:21:18 <wchogg> Oh!  Right, got it now.
20:22:38 <Cale> You can actually do quite a lot just with this. You can also generalise to using multiple indeterminates in order to count with respect to multiple weights at the same time.
20:23:24 <monochrom> Financial world unlikely to use IEEE 754. More likely to use binary-coded decimal. Either way, read/write a fixed number of words and do your own bit fiddling.
20:23:30 <Cale> Sometimes, algebraic identities are simpler to prove by way of combinatorics than the other way around, as well.
20:23:53 <wchogg> Really?  Can you throw out an example of something algebraic that's easier in combinatorics?
20:23:58 <ddarius> SamB_XP_: LtU for one, and many places that discuss programming theory since theorist definitely deal with real code.
20:24:01 <psykotic> cale: in some sense "baby combinatorics" is the basis for most good proofs of simple group theory :)
20:24:12 <psykotic> cale: like, lagrange's theorem
20:24:44 <psykotic> you show that all cosets are isomorphic as sets, and that they partition the group, and presto
20:24:57 <Cale> product over k >= 1 of (1 + x^(2k-1)) = sum over m >= 0 of x^(m^2) / product over k = 1 to m of (1 - x^(2k))
20:25:10 <falconair> Data.Binary docs have an example with the following line: "do t <- get :: Get Word8" , since Binary is implemented by so many data types, couldn't I just do "do x <- get :: Get Char" , Get Double, etc.?
20:25:22 <Cale> This would be absolutely brutal to approach analytically :)
20:26:06 <Cale> But it turns into an almost obvious result when the two sides are interpreted as generating series for specific sets of partitions.
20:26:32 <falconair> http://hackage.haskell.org/packages/archive/binary/0.2/doc/html/Data-Binary.html
20:26:35 <lambdabot> http://tinyurl.com/38jl8b
20:26:35 <dons> falconair: yep
20:26:43 <dons> the type decides which parser is used by 'get'
20:26:47 <monochrom> I suppose you can.
20:26:54 <ddarius> Cale: Have you played with Dirichlet series?
20:26:55 <dons> if there is no other type information
20:26:58 <psykotic> although if you're expecting a wire protocol using specific encodings...
20:26:59 <monochrom> Do mind endian issues.
20:27:03 <Cale> ddarius: A little bit.
20:27:13 <psykotic> i don't know if it'll match up to how Data.Binary does its thing
20:27:22 <Cale> You use Dirichlet series when you want multiplication to result in a product of weights.
20:27:28 <dons> yes, the key thing is that you're reading some bits, and it will be interpreted according to the get instance you ask for.
20:27:33 <monochrom> I do wonder what the Char instance does. 8-bit? 16-bit? 32-bit? which encoding?
20:27:36 <dons> so you better ask for the right thing, if not to get garbage bits
20:27:37 <Cale> Extracting coefficients of Dirichlet series is ridiculously hard.
20:27:56 <dons> -- Char is serialised as UTF-8
20:27:56 <dons> instance Binary Char where
20:27:59 <Cale> (note that ordinary generating series resulted in a sum of weights)
20:28:03 <sorear> monochrom: UTF-8, but if you care you shouldn't be using the high-level iface
20:28:06 <ddarius> Cale: Yes, but you tend to play with them in a different way for different ends.
20:28:12 <Cale> ddarius: right.
20:28:35 <Cale> ddarius: Though, if it was easy to extract coefficients, number theory would be solved :)
20:29:03 <falconair> is there a way I can just get a list of Word8, and convert them to whatever type I want?  Is there a standard class for doing this? (the way Show converts types to a displayable string)?
20:29:33 <Cale> falconair: There's no standard class, but you can make one.
20:29:49 <Cale> falconair: I thought that Data.Binary was an attempt at that though.
20:30:00 <monochrom> whose standard?
20:30:14 <monochrom> little endian is standard? big endian is standard?
20:30:18 <falconair> eh...this is my first haskell project, i'm trying to do as little as possible, otherwise I'll just drown in haskell ;)
20:30:39 <dons> falconair: data.binary is a bytestring of Word8s, that you can pick or pack data to, anyway you want
20:31:11 <Cale> falconair: You just write an instance of Binary for your specific types, and then use encode and decode.
20:31:36 <falconair> dons: right, i saw the function which converts bytestrings to/from Word8, but I'm not sure if I can convert Word8 to haskell types (char, int, double...)
20:31:45 <monochrom> If you just write two Hasekll programs and have them talk to each other, you can be as naive as you like.
20:31:58 <psykotic> falconair, you can just stick pack them into a bytestring and call encode/decode
20:31:58 <int-e> falconair: Word8 is an instance of Integral, so fromIntegral works
20:32:11 <gnuvince_> Does Haskell support UTF-8?
20:32:24 <int-e> falconair: but that's not what you want.
20:32:26 <Cale> wchogg: There are a bunch of other kinds of series for dealing with other kinds of structures -- for example, objects where all the weight-generating subparts are labelled from 1 up to n in some way.
20:32:27 <ddarius> Magic word "converts", answer fromIntegral
20:32:27 <sorear> gnuvince_: Yes.  All programming language do.
20:32:40 <monochrom> If your Haskell program talks to some other program, using someone else's protocol, you cannot do as little as possible. Too many marshalling issues.
20:32:43 <dons> gnuvince_: yeah
20:32:55 <gnuvince_> Thank you.
20:33:01 <dons> > maxBound :: Char
20:33:02 <sorear> gnuvince_: If you meant IO, then you'll need the utf8-string package
20:33:03 <lambdabot>  '\1114111'
20:33:09 <gnuvince_> dons: hey, our favorite Haskell pimper over at programming.reddit :)
20:33:29 <dons> well, i just submit links. i'll try to find some more on theorem proving too
20:33:45 <Cale> wchogg: Those are counted using exponential generating series, whose definition is similar to ordinary generating series, but you have f(x) = sum over a in A of x^w(a) / w(a)!
20:34:13 <Cale> And it's the coefficient of x^n/n! which counts the number of objects of weight n.
20:34:24 <dons> gnuvince_: i think martinbiship was disappointed he didn't rank so highly :)
20:34:47 <falconair> I think I'll first attempt "x <- get :: Get Whatever" ... and hope it works ;) ... I looked at the source code for Get.hs, lots of it is way over my head
20:35:03 <wchogg> Cale:  I think I got lost on what other kinds of structures would use an exponential generating series.
20:35:13 <falconair> thanks all!
20:35:13 <Cale> Okay
20:36:01 <Cale> wchogg: Some simple examples are permutations, and specific kinds of permutations, such as derangements (those with no fixed points)
20:36:17 <Cale> Functions on finite sets of various types (injections, and so on)
20:36:18 <psykotic> dons: Data.ByteString isn't accessible with lambdabot? i can access it with @type but not > seemingly.
20:36:38 <psykotic> @type Data.ByteString.pack
20:36:40 <lambdabot> [Word8] -> Data.ByteString.Base.ByteString
20:36:44 <psykotic> > Data.ByteString.pack
20:36:45 <lambdabot>   Not in scope: `Data.ByteString.pack'
20:36:54 <int-e> @type Data.ByteString.Lazy.pack
20:36:56 <lambdabot> [Word8] -> Data.ByteString.Lazy.ByteString
20:36:57 <dons> psykotic: yeah,  i probably haven't exposed it yet
20:37:01 <dons> perhaps i should
20:37:09 <psykotic> dons: no big deal, i was too lazy to bring up ghci :)
20:37:35 <Cale> Also, things like binary matrices can be treated as labelled structures with row and column labellings, as well as labelling 1's.
20:38:25 <Cale> (with which you can solve the problem of how many {0,1} matrices are there with m rows, n columns, and e ones, with no row or column consisting entirely of 0's.
20:38:26 <falconair> a quick question: where can I find the implementation of "Binary Char" instance?  grep doesn't find it in Get.hs, Put.hs or Builder.hs!
20:38:28 <Cale> )
20:38:49 <wchogg> Cale:  But for all these things the generating sets are a way of mapping these to some ring of formal power series?  So for the permutations, we're mapping the action of a group on the set to a ring?
20:38:50 <dons> sorear: you should look into Haskell extraction from Coq
20:38:55 <dons> sorear: some tuts on that would be fun
20:39:08 <Cale> wchogg: Oh, not even that yet.
20:39:10 <dons> falconair: the implementation is in the file Binary.hs in the src
20:39:18 <Cale> wchogg: Just mapping sets of permutations... for example
20:39:26 <monochrom> Perhaps in Binary.hs
20:39:41 <Cale> The set of all permutations with respect to the number of things being permuted. There are n! of each weight.
20:40:06 <Cale> So the e.g.s is sum over k >= 0 of k! x^k / k! = sum over k >= 0 of x^k = 1/(1-x)
20:40:13 <falconair> dons: sorry, didn't realize there was an hs file in the Data directory...thanks
20:40:50 <Cale> The funny part that I haven't described is what happens when you multiply generating series of this type.
20:41:01 <wchogg> ...what does happen?
20:41:15 <monochrom> That is the fun part. :)
20:41:26 <dons> here's a nice course people might like to follow, https://cgi.cse.unsw.edu.au/~cs4181/07s2/cgi-bin/moin.cgi/Schedule
20:41:27 <lambdabot> http://tinyurl.com/2kt7qz
20:41:37 <dons> `Language-based Software Safety' (Haskell)
20:41:44 <Cale> Well, in ordinary generating series, we counted the Cartesian product... all pairs (a,b) for a in A and b in B
20:41:55 <ddarius> Cale: Do you have a reference to a good online source for algebraic combinatorics?
20:42:17 <jfredett> ... I want to have a module with lots and lots of quickCheck functions, and I want to be able to execute them on the fly (preferably by saying "runTests" and waiting) is there any good way to do this?
20:42:22 <Cale> But in this case, there's no natural way to treat such a pair (a,b) as being labelled from 1 up to n + m (where there are n labels on a and m labels on b)
20:42:37 <Cale> ddarius: Unfortunately not.
20:43:02 <Cale> ddarius: I've even gone so far as to ship course notes from Waterloo to Australia :)
20:43:18 <ddarius> I guess I should read generatingfunctionology through then at some time and just ignore the terminology.
20:43:33 <wchogg> Yeah, but since N x N still has cardinality Aleph_0 why is the product of two infinite series so different than just one?
20:43:37 <Cale> ddarius: The problem is that it does lots of things in totally brain-dead ways.
20:43:54 <nornagon> @index isPrefixOf
20:43:54 <lambdabot> Data.List
20:44:00 <ddarius> Cale: I can easily believe that.  There is a reason I never got much past the first chapter or so.
20:44:26 <Cale> wchogg: it's not?
20:44:43 <wchogg> Cale:  Oh, I thought you were trying to say it was...maybe I'm just tired.
20:44:46 <Cale> Okay, so I didn't finish explaining this labelling thing :)
20:45:16 <Cale> So we want to relabel the pair (a,b), where a has weight n and b has weight m
20:45:39 <nornagon> Hmm, why can't I define the operator (=>)?
20:45:50 <wchogg> nornagon:  It's part of the syntax?
20:45:55 <nornagon> Oh, right.
20:45:56 <Cale> There are n+m choose n ways to separate the labels from 1 up to n+m into two appropriately sized sets
20:45:59 <nornagon> Duh. :)
20:46:00 <ddarius> let (=>) a b = a+b
20:46:04 <dibblego> nornagon, use ==>
20:46:08 <ddarius> > let (=>) a b = a+b in 3 => 3
20:46:09 <lambdabot>  Parse error
20:46:09 <dibblego> ?type (==>)
20:46:09 <nornagon> dibblego: yeah, that's what I did
20:46:11 <lambdabot> Not in scope: `==>'
20:46:12 <nornagon> just wondering
20:46:19 <int-e> ⇒
20:46:22 <ddarius> Darn.  Is there any possible ambiguity?
20:46:23 <nornagon> :D
20:46:36 <Cale> Once we pick such a partition of the labels, we can just apply the ones in the first half to a (in order) and the ones in the second half to b.
20:46:48 <nornagon> > let (⇒) = (+) in 3 ⇒ 4
20:46:49 <lambdabot>  Illegal character ''\135''
20:46:52 <nornagon> boo, hiss.
20:47:11 <wchogg> ddarius:  Well since => is only used in type signatures, I imagine it *could* be used if anyone wanted to change it so.
20:47:14 <int-e> > undefined :: Num a => a -- is that ambiguous enough?
20:47:16 <lambdabot>  Undefined
20:47:49 <Cale> For example, to relabel the permutation 5 1 3 2 4 with the set of labels {6,12,13,24,37}, you'd end up with the permutation 37 6 13 12 24
20:47:52 <dons> ?let x => y = y
20:47:52 <lambdabot>  Parse error
20:47:59 <dons> ?let x ==> y = y
20:47:59 <ddarius> int-e: I don't think so.
20:48:02 <int-e> if => were a possible infix operator this might confuse humans at least.
20:48:03 <Cale> wchogg: make sense?
20:48:05 <lambdabot> Defined.
20:48:09 <dons> > 1 ==> 2
20:48:10 <lambdabot>  2
20:48:20 <int-e> (with lesser known type classes)
20:48:34 <monochrom> (=>) :: Num a => a -> a -> a.  This is going to be fun.
20:48:56 <wchogg> Cale:  Sure.
20:49:12 <Cale> wchogg: So what we do is to form the "star product" of the sets of labelled objects A and B, which is formed by taking the Cartesian product, and then for each pair, distributing the n+m labels between the factors in all possible ways.
20:49:25 <int-e> in any case with an infinity of infix operators available I'm not too unhappy about => being forbidden, although it's a pretty one.
20:49:25 <Cale> And this is what the product of exponential generating series counts.
20:50:45 <Cale> This seems like a rather baroque operation at first, but eventually it becomes quite natural.
20:50:54 <Cale> Let me give a small example
20:51:07 <ddarius> What is it categorically!
20:51:09 <wchogg> Cale:  Yeah, to be honest I'm not seeing the punchline, the point, very well.
20:51:55 <Cale> Suppose we're interested in obtaining the exponential generating series for derangements with respect to the number of things being permuted.
20:52:03 <Cale> That is, the set of permutations with no fixed points.
20:52:20 <wchogg> Thank you, I was just about to look it up on wikipedia.
20:52:46 <Cale> If we have a permutation, for example (in two-line form)
20:52:50 <Cale> 1 2 3 4 5 6 7
20:52:58 <Cale> 4 2 1 7 5 6 3
20:53:14 <Cale> We can separate it into an identity permutation and a derangement:
20:53:16 <Cale> 2 5 6
20:53:18 <Cale> 2 5 6
20:53:22 <Cale> 1 3 4 7
20:53:26 <Cale> 4 1 7 3
20:53:33 <jfredett> hey! disjoint cycle notation!
20:53:46 <jfredett> wheres my disjoint bits!
20:54:04 <Cale> I could have used disjoint cycle notation, but this is actually better at representing the identity portion clearly :)
20:54:09 <Cale> and the labelling :)
20:54:13 <jfredett> yeh
20:54:32 <Cale> So the identity portion there is just [1,2,3;1,2,3] relabelled with the set {2,5,6}
20:54:39 <wchogg> Right.
20:55:01 <Cale> and the derangement was [1,2,3,4;3,1,4,2] relabelled with {1,3,4,7}
20:55:18 <Cale> So this is an element of the star product of the set of identity permutations with the set of derangements.
20:55:48 <wchogg> Ah, okay.
20:55:50 <Cale> In fact, the set of all permutations is in natural bijection with the star product of identity permutations and derangements.
20:56:05 <Cale> The e.g.s. for all permutations, I mentioned before, was 1/(1-x)
20:56:19 <Cale> there's only one identity permutation of each weight, so its e.g.s. is exp(x)
20:56:37 <Cale> So whatever D(x), the e.g.s for derangements is, it satisfies:
20:56:46 <Cale> 1/(1-x) = exp(x) D(x)
20:57:06 <Cale> and so D(x) = exp(-x)/(1-x)
20:57:16 <diakopter> has there been much talk/work on making ghc's frontEnd->Core more [trivially] pluggable?
20:57:36 <Cale> and if we had a copy of mathematica handy, I could extract a list of coefficients of that rather easily (or I could do it on paper, but that's less fun)
20:58:00 <wchogg> Okay, that example helped a lot.
20:58:12 <wchogg> That's pretty slick, actually.
20:58:16 <ddarius> Z transform!
20:58:21 <Cale> actually, it's not that hard to pull out the coefficient
20:58:29 <ddarius> Actually, I guess Laplace would be better
20:59:17 <Cale> d_n = [x^n/n!] e^(-x)/(1-x) = n! sum over k = 0 to n of (-1)^k/k!
20:59:20 <jfredett> ... I want to have a module with lots and lots of quickCheck tests, and I want to be able to execute them on the fly (preferably by saying "runTests" and waiting) is there any good way to do this?
21:00:37 <ddarius> jfredett: The script designed to do this...
21:00:45 <Cale> Also, from that it follows immediately that the limit as n -> infinity of d_n/n! is e^(-1), which is the probability as the number of people at a party increases that they all get the wrong hats back from the blind cloakroom-attendant.
21:00:50 * wli points to Wilf's generatingfunctionology
21:00:54 <jfredett> theres a script for that?
21:01:09 <wchogg> Cale:  Hah, that's a cute way to describe it.
21:01:13 <jfredett> does it come w/ quickCheck, and if so, where can i find docs on how to use it?
21:01:41 <ivanm> With the concurrency stuff in Haskell, is there a good tutorial on how to use it (especially seeing as how I've never done any concurrency before) ?
21:02:04 <Cale> It's also possible to compose generating series meaningfully in all cases where the composition is algebraically defined.
21:02:49 <ddarius> jfredett: http://www.cs.chalmers.se/~rjmh/QuickCheck/
21:02:51 <lambdabot> Title: QuickCheck: An Automatic Testing Tool for Haskell
21:03:10 <Cale> http://www.haskell.org/haskellwiki/GHC/Concurrency
21:03:11 <lambdabot> Title: GHC/Concurrency - HaskellWiki
21:03:17 <jfredett> brilliant?
21:03:46 <ddarius> There's a "quickCheck" program described on that page.
21:04:05 <falconair> has any one ever thought of generating a giant (visual) chart of haskell data types and function to/from those types, allowing users to type in an expression such as "Word8->Double" and see if the Word8 and Double nodes are connected?
21:04:05 <Cale> wchogg: So basically, you build up a wide variety of objects with known generating series, and operations for acting on combinatorial structure and algebraic structure simultaneously.
21:04:13 <falconair> perhaps something nice looking like this: http://www.visualcomplexity.com/vc/project.cfm?id=442
21:04:15 <lambdabot> Title: visualcomplexity.com | Mammal Supertree
21:04:29 <falconair> (the picture is not exact, but you should get the idea)
21:04:31 <ivanm> @slap CGI IRC clients
21:04:31 <lambdabot> why on earth would I slap CGI IRC clients
21:04:44 <Cale> wchogg: The derivative also has meaning -- it typically turns into a kind of deletion of weight-associated subobjects in all possible ways.
21:04:48 <ivanm> Cale: missed that somehow... didn't think it had any tutorials or the like there :s
21:04:54 <sorear> falconair: you could use hoogle
21:05:01 <sorear> @hoogle Word8 -> Double
21:05:01 <lambdabot> No matches, try a more general search
21:05:12 <falconair> one obvious pain point for newbies is to find all the functions and types...it is true of any language but haskell should be able to solve it much more nicely
21:05:17 <sorear> well, fromIntegral works
21:05:29 <falconair> sorear: hoogle seems to do a simple text search!
21:05:39 <sorear> falconair: Not even close.
21:05:45 <wchogg> ivanm:  What parts of haskell's concurrency did you want to know about?
21:05:51 <ddarius> falconair: Hoogle has done all kinds of things.  Hoogle 4 will do all kinds of things.
21:05:52 <sorear> falconair: it's based on type refinement
21:05:55 <ddarius> @where hoogle
21:05:55 <lambdabot> http://haskell.org/hoogle
21:06:05 <ivanm> wchogg: how to use it? :p
21:06:09 <Cale> wchogg: as a cute example, x^3 = x*x*x -- there are three ways to delete an x and each way gives x^2, so the derivative is 3x^2 :)
21:06:29 <mauke> ivanm: with forkIO
21:06:36 <wchogg> ivanm:  Well, I meant like if you specifically wanted to know how to use STM or something else.
21:06:37 <Cale> :t forkIO
21:06:39 <lambdabot> Not in scope: `forkIO'
21:06:46 <dons> sorear: re. haskell-src, we could just use our own branch, since i needs the expression parser
21:06:47 <Cale> :t Control.Concurrent.forkIO
21:06:48 <lambdabot> IO () -> IO GHC.Conc.ThreadId
21:06:50 <falconair> I was using hoogle, that's what made me think of it, for example "Ord a => [a] -> [a]" shows List deleteBy	:: (a -> a -> Bool) -> a -> [a] -> [a]
21:07:09 <sorear> dons: I'm hacking up a much simpler solution.
21:07:27 <ivanm> wchogg: what's the difference? I'm wanting to learn how for a scientific computation project...
21:07:50 <wchogg> Cale:  I find it odd how many different structures seem to admit a formal derivative without any analysis in sight.  McBride's "clowns on the left, jokers on the right" paper blew my mind that way.
21:08:25 <ddarius> There are algebraic properties that the derivative has that can easily be applied elsewhere.
21:08:34 <Cale> ivanm: There's concurrency, and then there's parallelism -- with concurrency, you have many code pointers to keep track of (processes doing different things), with parallelism, you have one (but work is shared between processors).
21:09:01 <falconair> i didn't find anything useful regarding type refinement on google, is that what i need to read up on to build some sort of visualization tool for haskell? (something similar to what UML does for the OO world)
21:09:21 <wchogg> ddarius:  Exactly.  I just have never seen a real common thread between them though, and it's a product rule that looks strange enought it's just conceptually surprisng how common it is.
21:09:36 <Cale> wchogg: This view also helps to generalise the derivative to noncommutative power series rings.
21:09:51 <ivanm> Cale: no, I want concurrency... its going to be run on my single processor laptop! :p
21:10:19 <mauke> so, forkIO. everything else follows from that
21:10:21 <Cale> Noncommutative rings are generally used to maintain information about order as structures are built up.
21:10:38 <wchogg> Cale:  I guess I can see how you'd use that in combinatorics.
21:10:51 <ddarius> wchogg: Parts of the idea of the derivative (the change in something w.r.t. something) are held in those algebraic identities.
21:11:30 <ivanm> mauke: I was hoping for something along the lines of tutorials/simple examples of forkIO (still getting confused by some of the monadic/IO stuff)
21:11:33 <sorear> Is x = y a function binding or a pattern binding?
21:11:42 <Cale> wchogg: The trouble is that noncommutative rings are hairy, so you usually end up taking commutative images at some point. But at that point, you can also try to extract a little extra information, for instance, by adding a factor of q for each transposition made while normalising terms.
21:11:47 <wchogg> ddarius:  I suppose...but often the notion of "change" seems to be a white-lie, like in the case of derivatives of regular expressions that sigfpe wrote about.
21:12:12 <mauke> ivanm: there's not much to it. you give it an action, and it spawns a new thread and runs the action in it
21:12:24 <Cale> wchogg: Which gives you information akin to counting permutations with respect to inversion number.
21:12:35 <wchogg> ...inversion number?
21:12:55 <ddarius> wchogg: Lookup the behavioural derivative stuff I mentioned earlier (which includes derivates of a regular expression).
21:13:56 <Cale> wchogg: an inversion in a permutation sigma is a pair of indices (i,j) with i < j but sigma(i) > sigma(j)
21:14:01 <wchogg> ddarius:  Sure.  I can't tell if we're talking past each other or if I've just completely missed the point you were making.
21:14:14 <Cale> and the inversion number of a permutation is the number of inversions it has
21:14:51 <Cale> Even and odd permutations have even and odd numbers of inversions.
21:14:57 <Cale> (respectively)
21:15:04 <brad> cale - if i am correct, periodically here i will overhear you tell someone that monads are like "little languages", dsls if you will. the more i think about it the more interesting and correct this seems. do you have a blog post etc where you expand on this?
21:15:14 <Cale> brad: hmm...
21:15:27 <wchogg> Okay, I've got to go to bed now.  In any case, Cale, thanks for giving me a crash course in a bit of algebraic combinatorics.
21:15:35 <Cale> wchogg: no problem :)
21:15:39 <ddarius> wchogg: The behavioural differential equations do describe how the automaton changes as it processes input.
21:15:46 <Cale> brad: The closest thing I have is a little article I wrote about the correct way to use monad transformers.
21:15:54 <Cale> brad: And my sudoku solver :)
21:16:01 <mvanier> I'm trying to compile lambdabot with GHC 6.6.1 but it fails because Language.Haskell.Syntax doesn't export various names.
21:16:11 <Cale> @where sudoku
21:16:11 <lambdabot> http://www.haskell.org/haskellwiki/Sudoku
21:16:17 <brad> do you have a link for the transformers article?
21:16:35 <Cale> yep
21:16:37 <Cale> ...
21:16:41 <Cale> http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
21:16:42 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
21:16:45 <brad> thanks!
21:16:47 <ddarius> @google Wadler The essence of functional programming
21:16:49 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/topics/monads.html
21:16:49 <lambdabot> Title: Wadler: Monads
21:17:03 <Cale> It doesn't explain how monad transformers work -- it sort of assumes you already know the basics about them.
21:17:28 <Cale> Oh, I was thinking things which I wrote :)
21:17:42 <Cale> Yeah, there's papers which take that view all over the place :)
21:18:18 <brad> anyone have news on the SoC HTTP library project?
21:18:34 <brad> the curl bindings one?
21:19:32 <dons> there's a new curl library on code.haskell.org
21:19:37 <dons> provided , kindly, by galois.com
21:19:43 <brad> oh, i should check it out!
21:19:47 <Cale> haha, Hank Aaron is given an Erdös number of 1 because they both autographed the same baseball!
21:19:56 <dons> which was developed without knowledge of the soc project, unfortuately
21:20:21 <dons> ah, just the person i was looking for, glguy
21:20:29 <dons> glguy: is the 'curl' package ready to go? should i get on hackage?
21:20:39 <dons> brad here is looking for a curl binding.
21:21:02 <dons> mvanier: hey
21:21:08 <mvanier> hey
21:21:12 <dons> sorear is looking at a general solution to the import problem
21:21:18 <brad> yes, in code.haskell.org i see some files but no tarball
21:21:22 <mvanier> OK, I'm not in a huge rush ;-)
21:21:25 <brad> is this a "work in progress"??
21:21:27 <dons> right, brad, that's a darcs repo
21:21:35 <dons> i think its done, just not tarred up
21:21:38 <dons> glguy: ?
21:22:03 <sorear> mvanier: Yeah.  I'm making it more robust and deleting 4000 lines of code in the process :)
21:22:09 <dons> :)
21:22:26 <mvanier> Funny how often that's the case.
21:22:34 <dons> you could just expose the expression parser in the haskell-src package
21:22:35 <mrd> spj closes his eyes a lot while speaking
21:22:46 <ddarius> Less code, less chance for errors.
21:22:48 <mrd> or is it just the camera perspective
21:26:18 <blackdog> is there a way of getting a stack trace when you've blown the stack? i'm unsure which function's causing the space leak...
21:26:37 <mrd> try +RTS -xc
21:27:03 <ddarius> after compiling with profiling using --auto-all
21:28:17 <sorear> Linking dist/build/lambdabot/lambdabot ...
21:28:22 <blackdog> ok, cheers.
21:29:10 <blackdog> hm, the profiling report only includes heap allocated stuff, right? but -xc seems to give me what i want... thanks.
21:30:00 <ddarius> -xc uses the cost centres to construct the stack trace.
21:30:20 <sorear> mvanier: my local lambdabot just built successfully on 6.6.1, I'll test it minimally then darcs send --cc you the patch
21:30:36 <blackdog> oh, i see. so -xc doesn't make any sense unless profiling is enabled. thanks.
21:30:56 <mvanier> sorear: OK, I'll have to read up on darcs send though (sorry).
21:31:21 <hpaste>  psykotic pasted "=== for quickcheck properties" at http://hpaste.org/1981
21:31:26 <sorear> mvanier: no, you want darcs apply.  I'm sending *you* the patch. :)
21:31:35 <SamB_XP_> blackdog: +RTS --help will tell you what you can do with any given binary
21:31:36 <mvanier> sorear: OK, I think I've got it :-)
21:32:04 <sorear> actually, I think darcs send bundles a copy of the relevant section of the manual. compared to 40k patches, it's not that big :(
21:32:23 <SamB_XP_> sorear: it DOES?
21:32:24 <sorear> @version
21:32:24 <lambdabot> lambdabot 4p534, GHC 6.6 (Linux i686 2.66GHz)
21:32:24 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
21:32:32 <SamB_XP_> sorear: in what version of darcs does it do that?
21:32:33 <mvanier> This gives a whole new meaning to "bleeding edge".
21:32:36 <sorear> SamB_XP_: Emphasis on think.
21:32:51 <sorear> ARGH!
21:32:52 <blackdog> cheers SamB
21:32:59 <sorear> scripts/ShowQ.hs:46:0:
21:32:59 <sorear>     Duplicate instance declarations:
21:32:59 <sorear>       instance (Arbitrary a) => Arbitrary (Maybe a)
21:32:59 <sorear> 	-- Defined at scripts/ShowQ.hs:46:0
21:32:59 <sorear>       instance (Arbitrary a) => Arbitrary (Maybe a)
21:33:01 <sorear> 	-- Defined in Test.QuickCheck
21:33:09 <SamB_XP_> sorear: it *might* be possible but I've never seen it happen
21:33:12 <reffie> ?src lex
21:33:13 <lambdabot> Source not found. Wrong!  You cheating scum!
21:33:25 <reffie> ?src List.lex
21:33:25 <lambdabot> Source not found. stty: unknown mode: doofus
21:33:30 <reffie> what
21:33:32 <reffie> :(
21:33:48 <dolio> lex might be complex.
21:33:51 <SamB_XP_> @source GHC.Read
21:33:52 <lambdabot> GHC.Read not available
21:33:58 <reffie> what exactly does lex do?
21:34:00 <sorear> dons: What do you say about removing the Arbitrary (Maybe) instance?  I've never seen it used here and it breaks the 6.6.1 build
21:34:00 <SamB_XP_> @source Text.Read
21:34:01 <lambdabot> http://darcs.haskell.org/packages/base/Text/Read.hs
21:34:06 <sorear> reffie: Lexes haskell.
21:34:11 <reffie> doh
21:34:20 <SamB_XP_> (more or less)
21:34:34 <dons> sorear: hmm. ok.
21:34:44 <dons> yeap, that's fine
21:35:19 <SamB_XP_> reffie: http://darcs.haskell.org/packages/base/Text/Read/Lex.hs
21:35:24 <sorear> Installing: /usr/local/src/lambdabot/lib/lambdabot-4.0/ghc-6.6.1 & /usr/local/src/lambdabot lambdabot-4.0...
21:35:25 <reffie> thanks
21:35:27 <sorear> stefan@stefans:/usr/local/src/lambdabot$ echo $?
21:35:29 <sorear> 0
21:35:32 <sorear> Lambdabot builds on GHC 6.6.1
21:35:49 <dons> by default, btw?
21:35:54 <dons> with an unmodified cabal file?
21:36:04 <sorear> yes
21:36:08 <dons> cool
21:36:16 <sorear> lambdabot> > 2 + 2
21:36:16 <sorear>      Failed to load interface for `Control.Parallel':
21:36:16 <sorear>       Use -v to see a list of the files searched for.
21:36:25 <SamB_XP_> I guess that means it's okay to release 6.6.1 now ;-P
21:36:54 <sorear> otoh, hs-plugins doesn't work very nicely when you have multiple ghc's installed.
21:36:55 * SamB_XP_ thinks lambdabot building from unmodified sources should be part of the acceptance tests for GHC releases
21:37:26 <dons> yeah, hs-plugins needs to be built against 'ghc' , whatever that is
21:37:28 <sorear> SamB_XP_: No, it should be part of the tests for lambdabot releases.  We can't have Igloo suffering every time I break the build
21:37:42 <dons> sorear: if you've got time, can you port the hs-plugins api to ghc-api ?
21:37:45 <sorear> dons: 'ghc' changes every week around here :)
21:37:48 <dons> just 'eval' would do
21:37:58 <dons> but we'd need sandboxing too, which is a little harder
21:38:04 <SamB_XP_> sorear: but they have to stop changing API incompatibly on minor releases!
21:38:12 <SamB_XP_> it MUST END
21:38:18 <sorear> SamB_XP_: Excuse me?
21:38:19 <dons> yeah, internal stuffs shouldn't be exposed from cabal files.
21:38:30 <dons> since its too tempting to hack
21:38:39 <sorear> SamB_XP_: Are you honestly proposing a freeze on undocumented apis?
21:38:45 <dons> i've done that twice, in 2 years. so its not that scary, SamB_XP_. but you like yelling :)
21:38:47 <SamB_XP_> sorear: not those, no
21:39:22 <dons> only undocumented .Internal apis change on minor releases, and they'll be hidden in the cabal file in future
21:39:22 <hpaste>  blackdog pasted "stack go boom!" at http://hpaste.org/1982
21:39:30 <sorear> lambdabot> > )2 + 2 Unbalanced parenthesis
21:40:17 <blackdog> ... so, anyone wanna help me out with what egregious screwup I'm making here?
21:40:29 <SamB_XP_> sorear: I seem to remember many of these breakages being non-internal things...
21:40:53 <dons> that's probably because you're doing it wrong, sorear
21:40:55 <dons> SamB_XP_:
21:41:08 <dons> heh. tab completion breaks more often than it works
21:41:09 <sorear> blackdog: Define boom
21:41:20 <blackdog> stack space overflow
21:41:25 <SamB_XP_> dons: who was doing what wrong?
21:41:32 <dons> blackdog: hmm.
21:41:42 <dons> foldWithKey eh?
21:41:43 <blackdog> i'm sure it's hideously non-idiomatic
21:42:01 <blackdog> ... are you going to say manual recursion again?
21:42:26 <dons> nah, but that Map fold is probably terribly unstrict
21:42:33 <dons> and the append looks dicey, complexity wise
21:42:43 <dons> what's Lazy? D.B.Lazy.Char8 ?
21:42:51 <blackdog> yep
21:42:57 <blackdog> oops, sorry, should have mentioned that
21:43:07 <blackdog> and B is data.bytestring.char8
21:43:29 <dons> what' the Map doing here?
21:43:53 <blackdog> it's my map of all the words in the SOWPODS list
21:43:56 <dons> maybe you can use insertWith' somehow?
21:44:07 <reffie> ?src tails
21:44:08 <lambdabot> tails []         = [[]]
21:44:08 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
21:44:09 <dons> or insertWithKey'
21:44:15 <Saizan> isn't better to return a [String] from the fold and fromChunks later?
21:44:18 <blackdog> i'm using insertWith'' to create it...
21:44:40 <dons> do you have a complete program that illustrates the issue, that we could play with?
21:44:47 <dons> just wrap that in a readfile and main?
21:44:47 <blackdog> sure. hold on.
21:45:34 <sorear> mvanier: done.
21:45:43 <mvanier> Awesome!
21:46:40 <hpaste>  blackdog pasted "whole grungy target solver" at http://hpaste.org/1983
21:47:07 <blackdog> dons: sorry, wrap what in a readfile?
21:47:19 <dons> oh, whatever was necessary to run it locally
21:47:26 <blackdog> the dictionary gets built ok if i don't try to cache it in a simpler form
21:47:45 <blackdog> oh, it needs a file called "sowpods.txt" in the local directory
21:47:59 <blackdog> symlink words or something, it just expects one word each line
21:47:59 <dons> containing what?
21:48:01 <dons> ok
21:48:29 <blackdog> apologies for grunginess. it's not exactly a model of clarity.
21:49:07 <dons> my eyes are greatly offended
21:50:06 <dons> the gzip encode$ ./A
21:50:06 <dons> Reading textfile
21:50:07 <dons> A: Ix{Char}.index: Index ('A') out of range (('a','z'))
21:50:11 <dons> ?
21:50:38 <dons> with sowpods.txt just symlinked to /usr/share/dict/words
21:50:56 <blackdog> oops - that's right, i lowercased it
21:51:08 <blackdog> probably shoulda done that at runtime too
21:51:09 <dons> ah, ok.
21:52:46 <dons> looks like a bit of a spaace leak
21:53:06 <dons> ok, so it built, and runs: 26599 dons       2   10  147M  129M sleep    select   0:23 42.53% A
21:53:15 <dons> $ ./A
21:53:15 <dons> Reading textfile
21:53:15 <dons> Enter a target
21:53:19 <dons> is should enter a target?
21:53:27 <dons> i can has target, plz?
21:53:30 <blackdog> sure
21:53:36 <blackdog> type cheezburger
21:53:43 <dons> kthx
21:53:44 <blackdog> or, y'know
21:53:46 <blackdog> any word
21:53:49 <dons> cool
21:54:02 <dons> so i got a bunch of words. when does the stack oflow happen?
21:54:22 <blackdog> when i do dumpCache
21:54:23 <blackdog> hm
21:54:41 <blackdog> maybe i'm running it with different compile flags - -prof etc
21:54:57 <dons> I used -O2 --make
21:55:04 <dons> it builds a 140M dictionary, I think
21:55:09 <dons> but otherwise, hmm, no stack overflow
21:55:15 <brad> any hxt users here?
21:55:21 <dons> Cale is
21:55:23 <dons> Cale: around?
21:55:33 * Saizan is too
21:55:48 <blackdog> heh. maybe it's only crashing because i turned profiling on... is that an anti-heisenbug?
21:56:09 <SamB_XP_> blackdog: I suppose
21:56:10 <dons> blackdog: so you manually compress the Map first?
21:56:17 <brad> here is my question, succinctly - "xread" barfs on xml docs with a valid xml decl (<?xml version="1.0"?>)
21:56:19 <lament> i'm a QA, we have it fairly often that a bug appears only in the QA environment
21:56:20 <brad> anyone know why?
21:56:38 <blackdog> dons: um, no, i don't think so.
21:56:39 <dons> could you not just use the native instance Binary for Dict?
21:56:48 <blackdog> ... you can do that?
21:56:54 <dons> oh yes, my goodness
21:56:59 <dons> let me see..
21:57:04 <dons> type Dict = Map.Map Integer [B.ByteString]
21:57:07 <dons> already derives Binary
21:57:12 <blackdog> i'm thinking way too low-level, aren't I...
21:57:32 <wli> blackdog: http://hpaste.org/1958
21:57:34 <wli> blackdog: Are you trying to find anagrams within a dictionary?
21:57:56 <dons> :t Data.Binary.encodeFile
21:57:58 <lambdabot> forall a. (Data.Binary.Binary a) => FilePath -> a -> IO ()
21:58:01 <dons> that guy
21:58:02 <blackdog> wli: yeah.
21:58:04 <wli> I don't know anything about these binary instances. Interesting.
21:58:13 <dons> dumpCache :: Dict -> IO ()
21:58:13 <dons> dumpCache = encodeFile cacheFile
21:58:23 <SamB_XP_> wli: isn't an ordinary heisenbug one that goes away when you try to catch it?
21:58:41 <wli> SamB_XP: Oh, point.
21:59:08 <SamB_XP_> or at least doesn't happen when you want it to
21:59:16 <wli> Data.Binary sounds useful.
21:59:20 <brad> i will try my question on cafe, maybe someone will know. thanks anyway!
21:59:24 <blackdog> wli: had a look at your code - will chuck it in and benchmark it in a minute
21:59:28 <dons> blackdog: or to encode, then compress, then write:
21:59:29 <dons>   dumpCache = Lazy.writeFile cacheFile . BZ.compress . encode
21:59:48 <dons> encodes to a lazy bytestring, sets up a lazy compression, as the chunks are written to disk
22:00:40 <dons> runs in 80M, the above code
22:00:49 <dons> and seems to get to the "enter a target" prompt a bit faster
22:00:59 <blackdog> nice
22:00:59 <dons> $ du -hs sowpods.cache
22:01:00 <dons> 2.5M	sowpods.cache
22:01:16 <dons> you'll need to import Data.Binary for encodeFile and encode
22:01:56 <dons> then readCache also simplifies
22:02:04 <blackdog> yep
22:03:40 <blackdog> thanks don - always nice to see kilos dropping off your programs
22:04:15 <dons> yeah
22:04:35 <blackdog> btw, i'd also like to give some props to the cabal guys and cabal-install. so much smoother than it used to be.
22:05:28 <sorear> mvanier: any new problems yet, or does the patch work for you?
22:05:32 <dons> runs in 64M if you use GZip instead of BZzip
22:05:43 <dons> $ du -hs *.cache
22:05:43 <dons> 3.0M	sowpods.cache
22:05:45 <mvanier> sorear: Yes, it compiles and works fine -- thanks!
22:05:48 <dons> marginally larger, but much faster
22:06:00 <mvanier> sorear: I just need to learn how to use the thing.
22:06:05 <dons> and loads the cache faster
22:06:22 <dons> blackdog:
22:06:23 <dons> dumpCache :: Dict -> IO ()
22:06:23 <dons> dumpCache = Lazy.writeFile cacheFile . GZ.compress . encode
22:06:23 <dons> readCache :: IO Dict
22:06:23 <dons> readCache = return . decode . GZ.decompress =<< Lazy.readFile cacheFile
22:06:25 <mvanier> and to integrate it into ghci
22:06:35 <dons> using : import Codec.Compression.GZip as GZ
22:06:35 <dons> import Data.Binary
22:06:35 <dons> import Control.Monad
22:07:30 <blackdog> still haven't quite got used to the whole point-free thing.
22:08:06 <Saizan> ?unpl dumpCache = Lazy.writeFile cacheFile . GZ.compress . encode
22:08:06 <lambdabot> dumpCache c = Lazy.writeFile cacheFile (GZ.compress (encode c))
22:08:09 <dons> ah, so you still worship at the church of the bound variable
22:08:26 <blackdog> i'm decadent and luxurious. :)
22:08:44 <SamB_XP_> dons: I thought that ended millions of years ago or around there
22:08:53 * wli snarfs the libghc6-binary-dev deb
22:08:53 <SamB_XP_> at least 10s of thousands
22:08:56 <dons> that's the cult of the bound variable, an early sect.
22:09:01 <reffie> is there a way to write png images from haskell?
22:09:09 <sorear> reffie: Yes.
22:09:13 <wli> reffie: Yeah, there's a lib for it.
22:09:14 <dons> reffie: yeah, the gtk bindings can happily do it, there may be other libs
22:09:19 <sorear> reffie: I think the cairo binding will do it
22:09:26 * SamB_XP_ personally just uses PPM and pnmtopng
22:09:44 <sorear> reffie: I strongly recommend pnmtopng.
22:09:47 <blackdog> dons: surprising that gzip runs faster - i thought bzip was meant to be the bees knees...
22:10:11 <SamB_XP_> blackdog: in compression ratio, yes
22:10:12 <Saizan> is it easy to append two pngs?
22:10:15 <SamB_XP_> it is supposed to be
22:10:16 <reffie> hm, ppm seems simple
22:10:18 <sorear> blackdog: bzip2 is meant to be the best compression program that isnt' 100x slower than bzip.
22:10:20 <SamB_XP_> Saizan: what?
22:10:24 * reffie likes simple
22:10:29 <sorear> Saizan: Yes, but it won't do anything useful
22:10:33 <wli> If igloo gets his deflate encoding things out, it should be easy to write a png encoder in 100% Haskell.
22:10:35 <SamB_XP_> reffie: yes, that's the idea ;-)
22:11:19 <wli> Who was it that was working on Reed-Solomon coding?
22:12:12 <blackdog> dons: hey, you busy this afternoon? am having birthday drinks at the courthouse if you have time..
22:13:35 <dons> oh, too busy with the simultaneous move/phd write up. but we should catch up before i head off
22:13:59 * dons tries to juggle too many chainsaws 
22:15:00 <blackdog> no dramas. let me know when you're free, i wouldn't want to distract you from the chainsaws :)
22:17:28 <dons> blackdog: btw, I think
22:17:29 <dons> buildDict l = foldr
22:17:29 <dons>               (\str m ->
22:17:33 <blackdog> dammit, don, you've made me dissatisfied with the rest of my program now. :) Must be shorter!
22:17:35 <dons> uses a bit less space
22:17:51 <blackdog> cheers
22:17:52 <dons> yeah, you can probably golf it down to half the size
22:18:11 <dons> there's another lazy foldl in there that could stand to be a foldl' i suspect
22:18:14 <blackdog> i don't really want to golf it
22:18:20 <blackdog> i still want it to be readable
22:18:31 <blackdog> but that dumpCache/readCache is a big win
22:18:32 <dons> would make a nice blog post, btw :)
22:18:35 <SamB_XP_> you haven't played readable-golf before?
22:18:47 <dons> blackdog's a past master of golf
22:19:03 <blackdog> ... i think that was an anagram program too :)
22:19:05 <dons> it twas he, I and patrykz who came up with the nefarious pretty.hs originanlly, iirc
22:19:09 <dons> :)
22:19:31 <SamB_XP_> nefarious?
22:19:32 * blackdog is prodded by dons and goes off to writeup
22:19:37 <SamB_XP_> is it wanted in ten systems?
22:20:06 <blackdog> dons: there aren't any other foldls in there, are there?
22:20:24 <dons> you could probably profile now, and get finer info on the algo itself.
22:20:39 <blackdog> true. i'll hold off on the post
22:20:41 <dons> but otherwise, should be fairly clean, i think
22:20:42 <dons>  convertS xs = List.foldl' (\x y -> x * (plookup ! y))
22:20:56 <dons> for a post you could probably leave off most of the type signatures too
22:21:09 <blackdog> hm, that one's a foldr in mine. wonder when i changed that.
22:21:31 <dons> lenCompare a b = compare (length a) (length b)
22:21:40 <dons> ?pl lenCompare a b = compare (length a) (length b)
22:21:41 <lambdabot> lenCompare = (. length) . compare . length
22:21:43 <dons> heh
22:22:08 <sorear> lenCompare = on compare length
22:22:09 <blackdog> i'm tempted to rejig the subset stuff as well - it's not so easy to do with ByteStrings, so i kept it in String
22:22:31 <blackdog> i'd fix that to be less awful, but the loop is really quick anyway.
22:22:32 <dons> compare `on` length, yeah
22:22:57 <blackdog> oh, but length is O(1) in ByteStrings, right?
22:23:05 <shachaf> lenCompare = comparing length -- works without any extras on base <2.1
22:23:48 <dons> yeah
22:24:05 <blackdog> @hoogle on
22:24:09 <lambdabot> Test.QuickCheck.oneof :: [Gen a] -> Gen a
22:24:09 <lambdabot> System.Console.Readline.onNewLine :: IO ()
22:24:09 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
22:24:16 <shachaf> on f g x y = g x `f` g y
22:24:38 <blackdog> cheers. not in standard lib?
22:24:44 <dons> import Data.Ord, lenCompare = comparing length
22:24:45 <shachaf> @ty let on f g x y = g x `f` g y in on
22:24:50 <lambdabot> forall t t1 t2. (t -> t -> t1) -> (t2 -> t) -> t2 -> t2 -> t1
22:24:53 <dons> its in Data.Function, in ghc head
22:25:35 * wli briefly notes that he seems to be able to rapidly tabulate anagrams in Shakespeare's first folio, Don Quijote, Confessio Amantis, Vanity Fair, the complete plays of Gilbert and Sullivan, the Lives of the Noble Grecians and Romans, and de bello Gallico without resorting to too much optimization.
22:26:08 <blackdog> wli: about how big is your corpus?
22:26:36 <SamB_XP_> wli: I don't think it's faire to use shakesbeer
22:27:00 <wli> blackdog: Individually, Shakespeare's First Folio is the largest at 4.5MB.
22:27:26 <SamB_XP_> shakesbeer didn't even know how to spell his own name!
22:28:04 <mvanier> dons: I'm now trying to get GOA to work, but I can't load the module.
22:29:00 <wli> SamB_XP_: Spelling was not standardized then as it is today.
22:29:09 <mvanier> dons: I get "GOA is not loaded" when I do :m +GOA
22:29:14 <SamB_XP_> wli: yes, I know
22:29:18 <wli> $ /usr/bin/time ./blackdog ~/books/English/Shakespeare/First_Folio
22:29:18 <wli> (805,[("'ist",2),("'tis",692),("i'st",2),("is't",82),("it's",27)])
22:29:18 <wli> 105.62user 0.54system 1:46.17elapsed 99%CPU (0avgtext+0avgdata 0maxresident)k
22:29:18 <wli> 0inputs+0outputs (0major+68174minor)pagefaults 0swaps
22:29:23 <dons> i think goa is known to be broken, but i've not looked into how to fix it
22:29:33 <mvanier> Oh, OK then.  Too bad.
22:29:38 <wli> blackdog: My driver isn't equivalent, though.
22:29:43 <SamB_XP_> the point is that it's not fair to find anagrams in something written before the invention of spelling
22:30:19 <wli> SamB_XP_: The translation of Plutarch is modern.
22:31:07 <wli> SamB_XP_: (Don Quijote obviously has similar issues to Shakespeare if you're dealing with that.
22:32:30 <wli> 82.90user 0.42system 1:23.32elapsed 100%CPU (0avgtext+0avgdata 0maxresident)k
22:32:34 <wli> 0inputs+0outputs (0major+55226minor)pagefaults 0swaps
22:32:39 <wli> For Plutarch.
22:32:50 <wli> 742247 words.
22:33:11 <wli> 4.2MB text file.
22:33:20 <mvanier> sorear: lambdabot is working great.  Thanks!
22:33:37 <blackdog> mine was running in about 15 seconds over SOWPODS, or 6 seconds over the cache
22:33:53 <blackdog> on my emulated openBSD box. now it seems to be completely stuck. *sigh*
22:34:12 * blackdog promises himself he'll start using source control even on his little muckaround projects. real soon now
22:34:36 <wli> blackdog: What's SOWPODS?
22:35:11 <blackdog> wli: the official list of scrabble words
22:35:26 <Olathe> There's an official list ?
22:35:45 <wli> blackdog: Well, they're not really trying to do the same things. I'm not sure what your driver is doing.
22:37:08 <blackdog> wli: probably not. mine builds the dictionary then looks for all words that you can form from the substrings
22:37:29 <blackdog> i was more comparing my before-and-after times and wondering what i changed
22:38:01 <glguy> PBS is doing a show now on how great this artist that paints solid colored walls and single squares on canvas is great
22:38:19 <glguy> \_o-<
22:38:27 <wli> blackdog: it looks like you're querying the user and returning a number of anagrams or something on that order. I'm not sure what the wildcard business is, though.
22:38:27 <glguy> I call that "Man with a sword"
22:38:36 <glguy> and expect to be showered with gifts and praise
22:39:08 <blackdog> wli: oh, right. yeah, it's for scrabble - looking at how many words you can form if you have one wildcard that can be anything.
22:39:49 <wli> blackdog: So it's a set of letters and some specified number of unknown letters?
22:40:08 <wli> blackdog: And you want all possible words formable in a dictionary from that?
22:40:14 <blackdog> yep. although mine currently works only on one wildcard.
22:40:24 <gmw> morning
22:40:52 <wli> blackdog: Let me think about the algorithm a little bit.
22:41:09 <gmw> little question: does +++ have any meaning in haskell?
22:41:37 <sorear> Yes.  It's an operator symbol, like + or == or /
22:41:52 <sorear> remember that operator-symbols are just another kind of name
22:42:07 <sorear> there is no *predefined* function named +++, but you can define one yourself
22:42:33 <sorear> gmw: that was for you
22:42:38 <dons> ?hoogle (+++)
22:42:39 <lambdabot> Did you mean: (+++)
22:42:39 <lambdabot> Prelude.undefined :: a
22:42:39 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
22:42:40 <dons> ?hoogle +++
22:42:41 <lambdabot> Control.Arrow.(+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
22:42:41 <lambdabot> Text.Html.(+++) :: (HTML a, HTML b) => a -> b -> Html
22:42:41 <lambdabot> Text.ParserCombinators.ReadP.(+++) :: ReadP a -> ReadP a -> ReadP a
22:43:08 <gmw> thx guys! now i have something to think about :)
22:43:22 <shachaf> > (+1) +++ (*2) $ Left 3
22:43:24 <lambdabot>  Left 4
22:43:32 <shachaf> > (+1) +++ (*2) $ Right 3
22:43:34 <lambdabot>  Right 6
22:44:05 <gmw> ok this is very confusing^^
22:44:49 <gmw> i just read through most of the yet another haskell tutorial and understand it for the most part, but this is strange^^
22:44:52 <Stinger> > (+1) +++ (*2) $ (3,3)
22:44:53 <lambdabot>  Couldn't match expected type `Either b b''
22:44:53 <sorear> gmw: That's one of the stantdard +++'s, namely the one from Control.Arrow on functions
22:45:01 <sorear> @src (->) (+++)
22:45:01 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
22:45:04 <sorear> @src (->)(+++
22:45:04 <lambdabot> Source not found. Do you think like you type?
22:45:06 <sorear> @src (->) +++
22:45:07 <lambdabot> Source not found. That's something I cannot allow to happen.
22:45:18 <shachaf> @src (+++)
22:45:18 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
22:45:31 <shachaf> @source Control.Arrow
22:45:31 <lambdabot> http://darcs.haskell.org/packages/base/Control/Arrow.hs
22:46:11 <shachaf> f +++ g = left f >>> right g
22:46:35 <shachaf> @src (->) left
22:46:36 <lambdabot> Source not found. Maybe if you used more than just two fingers...
22:47:14 <shachaf> f +++ g = (Left . f) ||| (Right . g); (|||) = either
22:47:22 <shachaf> For (->).
22:48:48 <gmw> hmm well i'm not sure if the +++ i have here is related to control arrows, it wouldn't make sense^^
22:49:05 <shachaf> gmw: What +++ do you have?
22:49:30 <gmw> see, you probably are already annoyed, but yep, here is another mod-x player who quite can't figure out how to solve lvl 7^^ but i think i got the code right, except the +++ section
22:50:13 <Cale> ah, hehe
22:50:19 <gmw> erm, well and if you don't know what i'm talking about: that lvl is about having an obscurifcated haskell code which must be fixed in order to get the single correct code out of 3500
22:50:33 <Cale> gmw: You should learn Haskell :)
22:50:48 * shachaf has never heard of mod-x.
22:50:52 <Cale> gmw: The extra funny bit is that their Haskell code is rather broken :)
22:50:53 <gmw> cale as a matter of fact i'm really trying hard, i just don't get the +++ thingie^^
22:51:06 <Cale> gmw: But it's written in such a way to make sense to Haskell users :)
22:52:09 <gmw> well after intensive reading i think i figured out what it does, for the most part, but i won't get a single code out of it and it must be because i "fixed" the +++ part wrong
22:52:15 <Cale> gmw: It's choice between parsers
22:52:28 <Cale> If I recall correctlu
22:52:30 <Cale> y*
22:52:47 <gmw> yes i thought so that it was some kind of "OR" but i'm not sure how to implement that correctly
22:53:27 <wli> blackdog: Okay, there are two things happening here.
22:53:37 <gmw> but instead of parsing either of the code, atm it parses all of it
22:53:44 <Cale> That is, the parse succeeds if the left parser succeeds, or the second succeeds.
22:53:45 <gmw> which probalby leads to problem^^
22:54:01 <blackdog> its mildly annoying that you have to unregister a package just to install a version with profiling...
22:54:05 <blackdog> wli: hm?
22:54:05 <wli> blackdog: The first is that the length of your string is specified, so you basically want an array of string indices, one for each possible string length.
22:54:06 <Cale> Can you paste the code? I forget how it goes :)
22:54:20 <ivanm> trying to understand the basis of Haskell's concurrency: is it a bit like how darcs has patches, where the data being read by different threads have version numbers that can be rolled back if something occurs?
22:54:20 <wli> blackdog: The second is that you have a multidimensional range query.
22:54:25 <gmw> yeah i'll qry it in order to not annoy anyone, ok?
22:54:31 <Cale> !paste
22:54:31 <hpaste> Haskell paste bin: http://hpaste.org/
22:55:10 <wli> blackdog: You can view each string as a vector of natural numbers, one coordinate for each possible character.
22:55:16 <gmw> ok wait a sec, i'll make it extra nice to read and delete all my debugging tryout staff^
22:55:51 <Cale> Just the original code will do :)
22:55:54 <wli> blackdog: For each non-wildcard character in your string, you have a constraint that there must be at least that many instances of that character.
22:56:23 <sorear> ivanm: No, haskell's concurrency is thouroughly conventional.  You have a bunch of threads, connected via pipes.
22:56:27 <blackdog> wli: yes, that makes sense.
22:56:30 <wli> blackdog: So you get x_1 >= v_1, x_2 >= v_2, ..., x_n >= v_n, x_1 + x_2 + ... + x_n = c
22:57:04 <wli> blackdog: There are standard data structures to support this kind of search, things like R trees, X trees, and the like. They're multidimensional search structures.
22:57:18 <wli> blackdog: in particular ones optimized for high dimensionality.
22:57:40 <hpaste>  gmw pasted "original "broken" code" at http://hpaste.org/1984
22:58:19 <hpaste>  gmw pasted "my own "almost fixed" code" at http://hpaste.org/1985
22:58:38 <ivanm> sorear: OK, I must have completely misunderstood the article on wikipedia about STM
22:59:01 <gmw> as you can see i removed the +++ alltogether which must be clearly wrong, but i don't know how to do it properly
22:59:09 <gmw> the rest of the code should hopefully be correct :)
22:59:17 <Cale> gmw: yeah, you've interpreted +++ incorrectly -- it joins the top level do block of that definition with the following one.
22:59:22 <wli> blackdog: So the new algorithm is to construct one of those multidimensional search trees for each string length, then to consult the appropriate tree for a given string length to respond to a query.
22:59:23 <blackdog> wli: ok, that could be useful.
22:59:42 <Cale> and it forms the parser which parses either of the two
22:59:44 <sorear> ivanm: Oh, if you were talking about STM (ask opposed to plain haskell concurrency) you were much closer to the truth.
22:59:56 <Cale> So if you're interested in a string which satisfies the parser, just pick one :)
23:00:22 <ivanm> sorear: OK, I didn't realise there was a difference
23:00:38 <wli> blackdog: Basically you add up the number of characters (whether wildcard or no) to determine the string length and so which tree to query. Then the non-wildcard characters' instance counts serve as lower bounds in one-sided multidimensional range queries.
23:00:50 <ivanm> so what would be better/easier for a beginner to pick up and run with? standard concurrency or STM?
23:01:10 <sorear> ivanm: How familiar are you with conventional multiprocessor programming, and the use of atomic exchange instructions?
23:01:18 <Cale> gmw: Is this your first encounter with Haskell?
23:01:21 <gmw> well the funny thing is, as long as i comment - out the call for code 4, this code 3 will actually still be able to parse (so i didn't immediately found the error, i thought it was code 4, but the error obviously occors because of the repeadet call for the not correct code 3
23:01:21 <wli> blackdog: The big downside is that these data structures for multidimensional range queries are quite involved.
23:01:23 <gmw> cale yes
23:01:26 <sorear> ivanm: STM builds on conventional concurrency
23:01:49 <gmw> omg my typing, i've been up quite a while now^^
23:01:50 <Cale> > sum [product (1..4), product (2..4), 1]
23:01:50 <lambdabot>  Parse error
23:01:53 <ivanm> I haven't really done much concurrency before... :s
23:01:57 <Cale> > sum [product [1..4], product [2..4], 1]
23:01:59 <lambdabot>  49
23:02:10 <ivanm> did look at atomic stuff, etc a few years ago, but have mainly forgotten :s
23:02:11 <gmw> cale and my first encounter with functional programming^^
23:02:15 <Cale> So we're looking for a string of length 48
23:02:25 <Cale> which matches the parser given
23:02:33 <gmw> no, if the string has length 49 it will be immediately declared as "failed"
23:02:56 <kfish> sorear, ivanm, STM is probably a simpler abstraction to learn (?)
23:02:57 <Cale> Are you sure?
23:03:00 <gmw> yes
23:03:12 <gmw> after that, any of the remaing codes will be given as an argument to code 2
23:03:12 <blackdog> wli: pragmatically, once i've built the dictionary, even the primes-based one, it's quick as hell.
23:03:27 <Cale> (length (check (x ++ "p")) == (sum [product [1..4], product [2..4], 1])) == False -- it fails if this is true.
23:03:36 <gmw> which starts parsing (it works really well, i did it step-by-step by slowly putting comments away)
23:03:42 <Cale> So it fails if (length (check (x ++ "p")) == (sum [product [1..4], product [2..4], 1])) is false
23:03:56 <blackdog> wli: even if it's not optimal.
23:04:07 <gmw> the code is valid  if my source can parse the entire code string
23:04:21 <ivanm> kfish: OK
23:04:29 <Cale> (sum [product [1..4], product [2..4], 1]) is 49
23:04:38 <Cale> So it fails if (length (check (x ++ "p")) == 49) is false
23:05:01 <Cale> ah, check is init, which removes the last character from the string
23:05:04 <Cale> > init "Hello"
23:05:06 <lambdabot>  "Hell"
23:05:16 <Cale> So it fails if (length x == 49) is false
23:05:34 <gmw> no, it fails if length == 49
23:05:53 <Cale> So where did my logic break?
23:06:11 <gmw> its because of "then "Failed"
23:06:13 <Cale> Note that in the guard it's testing whether the condition is False.
23:06:19 <jfredett> ... sh ./ghci not found? the quickcheck script is all screwy
23:06:20 <jfredett> :/
23:06:29 <gmw> faied is a string given back to main to tell me that this is not the correct code
23:06:31 <gmw> *failed
23:06:35 <Cale> (though it mistakenly does so with = and not ==)
23:06:44 <Cale> gmw: I know.
23:06:46 <gmw> this string is given back if the length is 49
23:07:03 <Cale> gmw: So you have a running copy of the program?
23:07:22 <gmw> if the length is other than 49, then it gets passed to code 2
23:07:26 <gmw> this code is actually working
23:07:36 <gmw> it just results in an empty file foo
23:07:45 <Cale> oh, in your 'runIt' you made a mistake
23:07:58 <Cale> look at the original runIt
23:08:21 <Cale> In the first guard, it looks to see if the condition is actually False
23:08:45 <Cale> (or it would, if there were == instead of =, which is the obvious intent
23:08:47 <Cale> )
23:09:00 <gmw> oh, you're right
23:09:12 <wli> blackdog: I think natural languages are too small to really need it.
23:09:29 <gmw> if the length is 49 the code gets parsed, not vice versa
23:09:30 <gmw> hmm
23:09:31 <wli> blackdog: Too small an alphabet and too small a data set.
23:10:13 <Cale> gmw: You should just be able to roughly read the parser in the original code and figure out a string of length 49 which it will accept
23:10:22 <gmw> yes
23:10:26 <gmw> i actually tried that
23:10:31 <gmw> but with codes not of length 49 lol
23:10:33 <wli> blackdog: Is the text file available anywhere?
23:11:15 <gmw> i parsed the first and the last chars from code 2 and tried to figur it out with my brain, but none of the remaining codes seemed valid
23:11:25 <gmw> i feel stupid now -.-
23:14:24 <gmw> allright, with length 49 and parsing right before the +++ i have 4 codes left^^
23:15:39 <ivanm> hmmm..... someone thinks STM is bad... "Software Transactional Memory, or STM, is the last bastion of hope for people who, for whatever reason, must still use shared mutable state in concurrency."
23:15:48 <gmw> of which 2 are obviously wrong, but i'm not sure about the remaining 2 ones
23:16:10 * wli is not entirely clear on how to define new instances of Binary.
23:16:12 <Cale> gmw: There are a ridiculously large number of possible solutions
23:16:55 <gmw> yes
23:16:56 <dons> wli, there should be some good eample docs on the hackage page?
23:17:00 <reffie> am i understanding wrong that when ghc is building, it tries to link against the OLD RTS library?
23:17:06 <gmw> but out of 3500, only one is correct in this case :)
23:17:15 <dons> wli, and there's a util in binary/util that will derive them for you
23:17:22 <Cale> gmw: 3500?
23:17:25 <wli> dons: Sorry about that, I only found it just now.
23:17:33 <gmw> yes, i have a file here with 3500 codes
23:17:41 <gmw> and only one is correct
23:17:51 <Cale> gmw: Oh, hehe, there's way more than 3500 strings which that parser will accept
23:18:06 <dons> wli, http://hackage.haskell.org/packages/archive/binary/0.3/doc/html/Data-Binary.html
23:18:10 <lambdabot> http://tinyurl.com/3cx6qr
23:18:25 <reffie> i'm having a problem because the ghc used for bootstrapping was compiled using gcc 3.x while my system only has gcc 4.2.x whose libgcc doesnt' have the __eprintf symbol (which rts/Linker.c needs for some obscure reason)
23:18:47 <sorear> ivanm: sounds like something a Erlang advocate (in the Why I Hate Advocacy sense) would say
23:18:47 <gmw> yes, but from those 3500 codes in that file, that parser will only accept one :)
23:19:02 <reffie> h8 bootstrapping.
23:19:27 <ivanm> sorear: yeah, it is... so what is the default (i.e. non STM) concurrency in Haskell? is it possible to have an erlang-like concurrency in haskell (i.e. message passing only)?
23:19:46 <dons> yes, Control.Concurrent.Chan
23:20:24 <gmw> ok, i'm quite sure i picked the right one from the two, now trying to input into mod-x solution form (if that works, i owe you a beer) :)
23:20:28 <ivanm> thanks dons
23:20:34 <dons> ivanm, you've got the full list on that page, start at the bottom with forkIO :: IO () -> ThreadId , and work up through channels, mvars, tvars, stm, Control.Parallel and ndp arrays
23:21:14 <wli> Looks like I need to define Generics instances on it.
23:21:14 <dons> wli, if Data.Binary doesn't rock your world, do let me know. that would count as a bug report
23:21:27 <ivanm> dons: which page? the ghc/concurrency page?
23:21:29 <dons> wli, yeah , you need to derive Data to get the auto-deriving script
23:21:55 <dons> ivanm: http://haskell.org/haskellwiki/Applications_and_libraries/Concurrency_and_parallelism
23:21:56 <lambdabot> Title: Applications and libraries/Concurrency and parallelism - HaskellWiki, http://tinyurl.com/2u95za
23:23:16 <gmw> cale: you are my hero :)
23:23:23 <ivanm> thanks again dons... for some reason, when googling concurrency and haskell, the only page I got was concurrency demos :s
23:23:38 <dons> weird
23:23:45 <dons> oh, due to the wiki not being indexed prviously
23:24:12 <thoughtpolice> i've been trying to figure out exactly how phantom types are used and came across the wikibook entry; however, I don't quite get how for example if you go from 'data T = X Int | Y String' to 'data T a = X Int | Y String' ensures any more safety; the entry only shows that you can at that point define a function like, say, "addition :: T Int -> T Int -> T Int", but how does this ensure more 'safety' at the type level? 
23:24:21 <ohub> With NetBSD 3.0, GHC 6.6.1 and latest lambdabot from Darcs I get: ''Initialising plugins ................Memory fault (core dumped)''
23:24:31 <dons> wow
23:24:41 <dons> try removing State/seen
23:24:49 <Cale> gmw: Make sure you keep learning Haskell, it's a fun language :)
23:24:55 <dons> it could be bugs in the ghc port to netbsd, possibly, ohub
23:25:07 <dons> ohub: you're not using the `plugins' package are you?
23:25:18 <ohub> hmm
23:25:27 <sorear> ohub: I'd like to know how you managed to compile lambdabot on GHC 6.6.1
23:25:35 <dons> it hasn't been tested on netbsd, which would require some checking of the linker.
23:25:36 <gmw> cale: yes it really wasn't too hard.. at first i had no clue what that code was doing, but now, a night later after that tut i understood all of the code except the +++ thingie, and of course i had that conditional error ;)
23:25:43 <dons> sorear: patches already pushed.
23:26:07 <sorear> oh.  that was fast :)
23:26:13 <ohub> dons: How do I see if I'm using plugins or not?
23:26:28 <sorear> ohub: Did you use the lambdabot.cabal.plugins file?
23:26:36 <gmw> i especially like the concept that there are no destructive updates, and that the error msgs given by (hugs in my case) compiler are meaningful^^
23:26:39 <ohub> sorear: nope
23:26:41 <dons> what packages did you install before you built lambdabot?
23:27:00 <dons> ok, so maybe you're not using the plugins lib. hmm. try removing the state files, and try again
23:27:13 <dons> the files in State/*
23:27:26 <ohub> dons: Oh, that helped
23:27:31 <dons> ah interesting!
23:27:37 <ohub> lambdabot> version
23:27:37 <ohub> lambdabot 4p545, GHC 6.6.1 (NetBSD i386 (586-class))
23:27:41 <dons> cool
23:28:03 <dons> good work.
23:28:07 <sorear> but that really shouldn't cause a segfault.
23:28:33 <sorear> memory safety and all that
23:28:41 <wli> dons: Does the deriving stuff work for cases where there are multiple data structures defined in terms of each other?
23:28:49 <sorear> wli: Yes.
23:28:49 <dons> yeah, but its an unchecked parser. so if the data was mangled somehow wrt. the parser ohub is using (version changes or what have you..)
23:28:55 <reffie> lol
23:29:05 <wli> sorear: This being for the binary data encoding and decoding?
23:29:08 <ohub> dons: I ^D'ed out from lambdabot and got "Memory fault (core dumped)". Now State has two files: fact and seen and I get memory fault again while trying to start up.
23:29:10 <sorear> wli: yeah
23:29:20 <reffie> hex-editing the old, bootstrap library built with gcc 3.x to replace instances of "__eprintf" with "wcsrtombs" makes it link!!!
23:29:29 <sorear> dons: Erm, GHC.Base.error *really* shouldn't crash.
23:29:30 <dons> ohuh, ok, so its serialising the data in some broken way. or the ghc runtime doesn't like what Data.Binary is doing
23:29:34 <wli> sorear: So it'll parse and print unambiguously etc.?
23:29:34 <ivanm> dons: when you said to start at the bottom of that page with forkIO, etc... the only mentions of forkIO I find on that page are at the top...
23:29:46 <sorear> wli: yeah
23:30:00 <dons> ivanm: right, its the basic mecahnism in Control.Concurrent
23:30:05 <reffie> why the hell does rts/Linker.c claim to need __eprintf anyway? it doesn't use it afaics!
23:30:09 <dons> ohub: wht version of Data.Binary did you install?
23:30:12 <ohub> Removing 0 byte State/fact and lambdabot can run again
23:30:22 <sorear> reffie: GCC inlines code from header files
23:30:40 <reffie> doh
23:30:44 <ohub> dons: binary-0.3, from Darcs some weeks/months ago.
23:31:04 <reffie> i guess we'l lsee if the resulting binaries will work
23:31:06 <dons> ok hmm. you could try updating that (there were a couple of fixes recently), if it happens a gain
23:31:15 <ohub> dons: ok, trying that now.
23:31:25 <ohub> yep, my binary seems to be 3 patches old.
23:31:26 <ivanm> dons: OK, so you meant start at the top and work down then?
23:31:29 <reffie> sorear how does it work with newer gcc versions whose libgcc don't export that symbol?
23:31:38 <dons> ivanm, yes, it is in order of abstractoin level
23:31:42 <dons> least abstract at the top
23:32:30 <sorear> reffie: You're supposed to upgrade libgcc and gcc in lockstep, and always statically link libgcc.
23:32:44 <sorear> reffie: did you not make clean?
23:33:18 <jsnx> is   (liftM foo) args   just like   return (foo args)   ?
23:33:30 <reffie> sorear i'm trying to build ghc using ghc binaries that were built with an older gcc
23:33:31 <jsnx> :t return
23:33:33 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
23:33:37 <ivanm> dons: OK, I thought you meant work from the bottom of the page :p
23:33:41 <jsnx> :t liftM
23:33:42 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
23:34:04 <shachaf> liftM = fmap
23:34:04 <sorear> reffie: I think it would be easier just to use the binary distribution. :)
23:34:21 <shachaf> liftM f x = x >>= return . f
23:34:22 <reffie> sorear i tried, but ghc wouldn't be able to link
23:34:39 <reffie> sorear apparently libgcc doesn't get statically linked to libHSrts.a on freebsd
23:34:44 <reffie> or something
23:34:47 <shachaf> So args >>= (\x -> return (foo x))
23:34:48 <sorear> reffie: erm, you don't link a binary version of ghc
23:34:58 <sorear> reffie: you just run it
23:35:04 <reffie> sorear what do you mean?
23:35:09 <sorear> $ ghc
23:35:14 <sorear> don
23:35:20 <sorear> 't run ld on anything.
23:35:33 <reffie> ghc runs ld
23:35:53 <sorear> OH! you meant that ghc wouldn't be able to link YOUR PROGRAMS!
23:35:55 <reffie> yes!
23:35:56 <sorear> sorry
23:36:03 <sorear> I misunderstood.
23:36:05 <qwr> --make ?
23:36:21 <reffie> that's when i tried to use the prebuilt ghc for freebsd 6.0 on freebsd 7.0 (which has a different libgcc)
23:36:28 <sorear> reffie: -optl-lgcc ?
23:36:34 <qwr> hmm, ok, or you have something broken
23:36:48 <ohub> dons: No change with new Data.Binary
23:36:57 <reffie> i think the problem is that libgcc isn't being statically linked
23:37:33 <reffie> but i could be wrong
23:37:39 <dons> ohuh, so a crash when it tries to write the state out on exit?
23:37:41 <reffie> i don't really understand anything about this linking crap
23:38:07 <dons> ohub: so ^D should produce: lambdabot> Exception: all servers detached
23:38:43 <ivanm> reffie: AFAIK, you need to link the libraries into the main executable to make one big executable file (as opposed to a java-like layout where you need to tell it where to find the libraries at run-time)
23:38:45 <ohub> dons: yes. two lines: ''lambdabot: user error (<eof>)'' ''Exception: all servers detached'' and then memory fault
23:38:55 <ivanm> reffie: I could be wrong though :p
23:39:18 <dons> hmm
23:45:57 * ivanm heads off home
23:56:53 <zak_> how fast is GHC's compilation, compared to say OCaml's native compiler?
23:58:21 <dolio> Are you asking about how long it takes to compile code, or how fast the generated code is?
23:58:38 <zak_> compilation time
23:58:47 <sorear> zak_: Unbeleivably slow.
23:59:11 <osfameron> heh
23:59:18 <zak_> really? ugh.. that's something that always bugs me when i start using a new language/tools
