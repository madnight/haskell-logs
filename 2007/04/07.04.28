00:29:02 <mwc> Quick question
00:29:09 <mwc> how much of an atrocity is this?
00:29:10 <mwc> concatMapM :: Monad m => (a -> m [b]) -> [a] -> m [b]
00:29:11 <mwc> concatMapM f as = mapM f as >>= foldM (\a b -> return $ a ++ b) []
00:29:36 <mwc> the ++ is what makes me nervous
00:32:35 <Lemmih> ?type \f -> fmap concat . Prelude.mapM f
00:32:38 <lambdabot> forall a a1 (m :: * -> *). (Functor m, Monad m) => (a1 -> m [a]) -> [a1] -> m [a]
00:33:27 <sjanssen> Lemmih's should be more efficient -- because foldM is a left fold
00:34:01 <mwc> thanks
00:34:28 <mauke> :t span
00:34:30 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
00:34:31 <mwc> can concat xss = foldr (++) [] xss, using a right fold
00:34:34 <mwc> thanks Lemmih
00:35:07 <sjanssen> mwc: yes, that is generally how it is defined
00:42:37 <tuukkah> ?src concat
00:42:37 <lambdabot> concat = foldr (++) []
00:46:22 <Cheery> ?src perl6
00:46:23 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
00:46:27 <tuukkah> "concat" forall xs. concat xs = build (\c n -> foldr (\x y -> foldr c y x) n xs
01:43:37 <chrizel> hi, i'm a complete haskell newbie and i don't get it - what's wrong with that? http://chrizel.com/haskell/wrong1.txt
01:44:04 <mauke> missing argument to return in line 2
01:45:45 <Lemmih> chrizel: You want 'return ()'.
01:46:10 <Cale> chrizel: return is not a keyword, rather it's a function which makes an action from a value, which always returns that value. In this case, you probably want to return the empty tuple (), as there's nothing significant to report
01:46:17 <goban> http://scienceblogs.com/goodmath/2007/04/true_pathology_a_multilingual.php
01:46:19 <lambdabot> Title: Good Math, Bad Math : True Pathology: A Multilingual Quine, http://tinyurl.com/23ehx8
01:46:30 <mauke> printList [] = return ();  printList (hd : tl) = do putStrLn (show hd); printList tl
01:46:33 <Cale> goban: yeah, that's a nice quine. :)
01:46:46 <mauke> pattern matching!
01:47:04 <Cale> also, putStrLn . show = print
01:47:11 <mauke> then you notice that ... what Cale said
01:47:24 <mauke> then, mapM_
01:47:25 <goban> how the hell they come up with it
01:47:29 <Cale> mauke: right :)
01:47:32 <chrizel> whoo, thank you all! now it works... i'm still learning... :)
01:47:48 <Cale> chrizel: printList = mapM_ print
01:47:49 <Cale> :)
01:48:09 <Cale> (mapM_ is a function in the Control.Monad library)
01:48:40 <Cale> You can probably imagine how it might be written :)
01:49:33 <_roconnor> > let (*.) = "foo" in (*.)
01:49:35 <lambdabot>  "foo"
01:49:43 <mauke> (sequence_ .) . map
01:49:53 <chrizel> thanks, that works mapM_ print [1, 2, 3]
01:50:30 <mauke> putStr (unlines (map show [1, 2, 3]))
01:50:41 <Cale> :)
01:51:24 <Cale> mapM and mapM_ is how most loops are handled. There's also (in GHC6.6 and up) forM and forM_, which are the same thing, but with the list parameter first
01:52:09 <dolio> > 23 `mod` 9
01:52:11 <lambdabot>  5
01:53:39 <dolio> @check \i -> mod (i :: Integer) 9 == (sum . map digitToInt . show $ i)
01:53:41 <lambdabot>  Couldn't match expected type `Integer' against inferred type `Int'
01:53:49 <dolio> @check \i -> mod (i :: Int) 9 == (sum . map digitToInt . show $ i)
01:53:51 <lambdabot>  Exception: Char.digitToInt: not a digit '-'
01:54:07 <dolio> @check \i -> i > 0 ==> mod (i :: Int) 9 == (sum . map digitToInt . show $ i)
01:54:08 <lambdabot>  Falsifiable, after 20 tests: 9
01:55:18 <Cale> > sum . map digitToInt . show $ 9
01:55:19 <lambdabot>  9
01:55:28 <Cale> > mod 9 9
01:55:30 <lambdabot>  0
01:56:09 <LeCamarade> @src mapM_
01:56:10 <lambdabot> mapM_ f as = sequence_ (map f as)
01:56:16 <Cale> @check \i -> i > 0 ==> mod (i :: Int) 9 == mod (sum . map digitToInt . show $ i) 9
01:56:18 <lambdabot>  OK, passed 500 tests.
01:57:49 <[malte]> Is there a function f, where f = flip map, predefined in any stdlib? (And how could I find out myself?)
01:58:20 <mauke> @hoogle [a] -> (a -> b) -> [b]
01:58:20 <LeCamarade> @hoogle flip . map -- to find out
01:58:21 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
01:58:21 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
01:58:21 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
01:58:21 <lambdabot> Hoogle Error: Parse Error: Unexpected character '. map -- t'
01:58:32 <sorear> [malte]: I'd recommend askin on Haskell, for the latter question
01:58:34 <LeCamarade> @hoogle flip map -- to find out
01:58:35 <lambdabot> Hoogle Error: Parse Error: Unexpected character '-- to find'
01:58:43 <LeCamarade> @hoogle flip map
01:58:44 <lambdabot> Did you mean: Flip Map
01:58:45 <lambdabot> Prelude.undefined :: a
01:58:45 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
01:58:51 <sorear> LeCamarade: there is no such feature and never has been
01:59:00 <sorear> LeCamarade: hoogle needs *types* not *terms*
01:59:02 <LeCamarade> It is there. AS flip . map. :oD
01:59:11 <mauke> no, flip map
01:59:15 <LeCamarade> sorear: Yeah. Was trying out. Just ... :o(
01:59:45 <[malte]> alright :)
01:59:45 <sorear> This works:
01:59:45 <sorear> @type flip map
01:59:45 <lambdabot> forall a b. [a] -> (a -> b) -> [b]
01:59:50 <sorear> if it weren't for those forall's:
01:59:55 <sorear>  @. hoogle type flip map
01:59:58 <sorear> GHC--
02:06:30 <scodil> is there an easy to to get vim to understand ghc output? i tried google but all i got was mailing list noise
02:07:55 <scodil> oops nevermind. found it
02:08:01 <mauke> where?
02:08:04 <Cheery> I just came up with a thought, what about translating nehe -tutorials to HOpenGL?
02:08:21 <siti> Cheery: I think some have been done
02:08:24 <siti> about 17 iirc
02:08:35 <siti> I can't remember where they are though
02:09:34 <scodil> http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/  <-- does this still work?
02:09:36 <lambdabot> Title: Haskell mode for Vim
02:09:41 <Cheery> I'm thinking about implementing them so that you could build on earlier tutorials instead of writing everything again and again. :)
02:09:53 <siti> Cheery: that would be cool
02:12:42 <njbartlett> Hi... just in case anybody missed the other announcements, the London Haskell User Group will be having its first meeting on 23rd May
02:12:45 <Cheery> partially because I found out I do not remember so well all quirks in OpenGL anymore
02:13:02 <njbartlett> http://www.londonhug.net/2007/04/26/announcement-first-meeting-of-the-london-haskell-user-group/
02:13:05 <lambdabot> Title: Î»ondon HUG » Blog Archive » Announcement: first meeting of the London Haskell U ..., http://tinyurl.com/24v5yy
02:13:13 <yip> Cheery: a lot of the nehe tutorials have already been ported
02:13:47 <Cale> njbartlett: Will you be recording the talk?
02:13:57 <Cheery> yip, I know some of them are ported
02:14:19 <Cheery> thought I remember they use glut as their base
02:14:45 <yip> could be
02:15:11 <dons> njbartlett: i added the link to the front page of haskell.org too, btw :-)
02:15:12 <njbartlett> Cale> Hadn't thought of that, but now you mention, that's a great idea!
02:15:22 <njbartlett> Yes I noticed, thanks Don
02:15:27 <dons> jcreigh: yeah, recording would be *great*
02:15:34 <dons> njbartlett: ^^ oops
02:15:58 <yip> the other opengl toolkits i am aware of that exist for haskell are GTK+, SDL, wxWidgets, and i think GLX
02:18:06 <Cheery> yip: I wonder whether it'd be some abstract layout the opengl examples are built on then
02:18:23 <Cheery> ie. minimal possible amount of details of underlying system
02:18:32 <yip> that's what glut is :)
02:19:41 <Cheery> is it? :P
02:20:27 <yip> the way i see it: glut is for very simple or educational stuff. SDL is for games. gtk/wx is for scientific/advanced stuff
03:02:43 <ndm> hi everyone!
03:06:07 <Cheery> do you have some common format for configuration files?
03:08:11 <ndm> Cheery, deriving Read/Show, then use read/show
03:10:06 <Cheery> ?
03:10:16 <Cheery> I don't understand
03:11:17 <ndm> data Config = Config String Int deriving (Read, Show)
03:11:30 <ndm> readFile "config.txt" >>= return . read
03:16:57 <m4St3R_b41T3R> moin
03:17:09 <jyp> @moin
03:17:10 <lambdabot> Not enough privileges
03:17:21 <jyp> @moo
03:17:21 <lambdabot> Maybe you meant: map more msg todo yow
03:17:38 <jyp> @yow
03:17:39 <lambdabot> YOW!!  Up ahead!  It's a DONUT HUT!!
03:17:40 <yip> there is also ConfigFile: http://software.complete.org/configfile
03:17:43 <lambdabot> Title: ConfigFile
03:17:51 <m4St3R_b41T3R> @cow
03:17:52 <lambdabot> I want the presidency so bad I can already taste the hors d'oeuvres.
03:24:18 <Cheery> yip: Somehow ndm's configfile -thing seems darn much better than that ConfigFile -thing.
03:30:15 <ndm> Cheery, its not my idea - dons and malcolmw have been using it for years - I just copy :)
03:31:40 <Cheery> k.
03:32:50 <Cheery> a thing came to my mind, can you define yourself data classes which one can derive?
03:35:01 <Cheery> ?src Read
03:35:02 <lambdabot> class Read a where
03:35:02 <lambdabot>   readsPrec    :: Int -> ReadS a
03:35:02 <lambdabot>   readList     :: ReadS [a]
03:35:02 <lambdabot>   readPrec     :: ReadPrec a
03:35:02 <lambdabot>   readListPrec :: ReadPrec [a]
03:35:12 <dons> http://programming.reddit.com/info/1lnze/comments
03:35:13 <lambdabot> Title: Haskell idioms: plan ahead for currying (reddit.com)
03:35:23 <dons> Cheery: there's some support using external tools, or template haskell
03:35:32 <dons> if your type is a newtype, you can also derive things for it
03:41:42 <ndm> Cheery, look at derive
03:41:44 <ndm> @where derive
03:41:44 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/derive
03:42:16 <ndm> dons, that article is very true - one of the hardest things to learn i though
03:42:44 <dons> ndm, yeah, its good advice.
03:42:55 <mux> morning haskellers
03:45:07 <TSC> It seems like in some examples the low and high are backwards
03:45:25 <TSC> "5 0 10" doesn't seem to match with "val high low"
03:46:15 <dons> its interesting  finding these posts by people who apparently write a fair amount of haskell, but who i've never heard of. the community is growing!
03:46:30 <dons> i only know half the guys who've signed up for the london user's group. very exciting.
03:46:42 <Heffalump> I know hardly any of them
03:47:02 <dons> interesting, isn't it?
03:47:09 <mux> yeh
03:47:16 <mux> haskell is getting more and more exposure
03:47:25 <mux> I'm doing quite a lof of proselytism myself :-)
03:47:39 <dons> they're not from the 'group of 8' core haskell unis, which half the community seemed to be  a few years ago
03:47:50 <Heffalump> yeah
03:48:01 <dons> user groups on their own are a new development.
03:48:12 <dons> they weren't needed when you only had research groups doing haskell
03:48:32 <dons> oh no. we're losing control!!
03:49:12 <mux> I'd say this is also exciting :-)
03:49:16 <Muad_Dib> of course not. you still control what happens, just not what users play with :P
03:49:46 <dons> a lot of the new libraries on hackage are by non-uni people too.
03:49:50 <dons> things are going to plan .... ;-)
03:50:47 <mux> I wonder if I will get to read something along the lines of: "Perl hackers didn't know at that time that using Haskell to write a prototype of Perl6 would in the end doom their language" one day
03:50:51 <mux> :-)
03:50:58 <dons> mwhahaha
03:51:23 <dons> it was a very exciting HWN this week, with jobs and libraries galore. fun stuff.
03:52:33 <dons> the demand for haskellers is outrunning the supply a little.
03:53:18 <dons> i hope everyone is trying to improve their haskell skillz, so they can go work for CS and the other banks ;-)
03:54:39 <mux> I think I wouldn't mind doing some haskell dev some day
03:54:56 <ndm> i do like the list of jobs
03:55:01 <dons> you have any web experience?
03:55:08 <dons> happs hacking might be an optoin, mux...
03:55:13 <ndm> although would prefer a longer list of research positions
03:55:15 <mux> the odds that your boss can read your code will probably be very very lower than being to read Perl or C :-)
03:55:18 <mux> dons: I've seen it
03:55:24 <mux> but I don't want to change job for now
03:55:30 <dons> ndm, yeah, most of the research jobs don't get advertised widely.
03:55:40 <mux> and to answer your question, I do have web experience, only I hate it
03:55:41 <mux> :-)
03:55:41 <dons> maybe i need a little blurb seeking job ads
03:56:05 <ndm> dons, and most research jobs are pre-allocated...
03:56:27 <dons> ndm, do you think something like "If you wish to advertise a Haskell or FP job, please mail editor@hwn with details" in the jobs section?
03:56:52 <dons> to make it clear how the system works.
03:57:31 <dons> i wish authors would send me details of their papers too
03:57:48 <dons> the 'new papers' sectoin didn't really work, since there's no central point for new haskell papers.
03:58:40 <dons> oh, interesting (from #lisp):
03:58:41 <dons> 23:22 < Sukoshi> It bewilders me how Haskell came out of nowhere and became a hit, even though IMO
03:58:44 <dons> it's
03:58:46 <dons>                  200x harder to program in than Lisp. From what I can tell, people document code and
03:58:49 <dons> try to
03:58:52 <dons>                  make Haskell accessible to the general user.
03:58:55 <dons> 23:22 < Sukoshi> You have lots of articles explaining stuff. The closest thing you have in the Lisp
03:58:57 <dons> world
03:59:00 <dons>                  is PCL and SL.
03:59:10 <augustss> hello
03:59:11 <lambdabot> augustss: You have 1 new message. '/msg lambdabot @messages' to read it.
03:59:40 <dons> heya augustss
04:01:37 <Heffalump> A clear victory for static types ;-)
04:01:40 <augustss> 200x harder, eh?
04:02:06 <dons> mwhaha
04:02:10 <_roconnor> augustss: Do you do haskell programming for your job?
04:02:24 <augustss> _roconnor: yes
04:02:50 <dolio> I do remember haskell being way harder than scheme when I first started, but I don't know about 200 times.
04:03:10 <dons> what would 200x harder mean? 200x more thinking?
04:03:14 <dolio> I also tried using the Gentle Introduction as my first ever FP experience.
04:03:24 <dons> maybe 1-4x harder?
04:03:30 * roconnor wants augustss's job.
04:03:32 <dons> for 1/4 the bugs :-)
04:03:35 <augustss> roconnor: I've been doing mostly Haskell programming for work the last 12 years.
04:03:37 <pejo> dons, what counts as a haskell paper btw? THe constructor specialisation by SPJ for example?
04:03:41 <dolio> Which may not be the best way to start out.
04:03:44 <dons> pejo: certainly.
04:03:45 <roconnor> augustss: do you work in europe?
04:03:59 <dons> pejo: basically, i want authors to ping me (or planet haskell) when something is written
04:04:04 <augustss> roconnor: now, yes.  but i've worked in the US too
04:04:07 <dons> so we can track the 2 or 3 papers a week that come out
04:04:14 <pejo> dons, the higher order deforestation by Marlow or Hamilton?
04:04:21 <dons> sure.
04:04:32 <dons> fusion, man, that's the game!
04:04:40 <pejo> dons, hm, ok. I think that is a good idea, but mainly of interest to academics, or ex academics.
04:04:47 <pejo> dons, amen!
04:05:01 <dons> well, often it describes new language features, or new libraries
04:05:08 <dons> say, hmm, 'rewriting haskell strings' :-)
04:05:16 <dons> or the finger tree stuff
04:07:03 <xs> hi. i seem to recall there was something for automatically generating FFI bindings to libraries based on header files. can't find it though. was i hallucinating?
04:07:09 <dons> hsc2hs /
04:07:11 <dons> or c2hs?
04:07:13 <pejo> dons, I have to run - but hwn is a great thing!
04:07:43 <mux> maybe I should create the Paris Haskell User Group
04:07:52 <xs> dons: ah! great! thanks! wonder why that was so tricky to find.
04:07:54 <mux> but for that I'd need to find other haskellers in paris first :-)
04:08:28 <dons> mux, make an FP user group, and steal all the ocaml guys ;-)
04:08:38 <mux> heh, evil
04:08:45 <dons> a couple of talks about SMP multicore stuff, and you're home and free :-)
04:08:49 <ski> hm .. haskell user groups .. hugs
04:09:15 * roconnor wonders if programming in Coq is 200x harder than in Haskell.
04:09:19 <dons> hmm.
04:09:25 <mux> dons: yeah, a talk on par and parMap should be enough :-)
04:09:30 <dons> i'd say Twelf was, hmm 10x harder
04:09:44 <mux> add a pinch of Parsec and STM
04:09:44 <dons> so Coq would be similar.
04:09:59 <dons> 10x more code, 10x longer to get things done. 10x better specified
04:10:31 <erider> good morning
04:10:51 <roconnor> 10x more correct
04:11:21 <dons> hmm, http://haskell.org/haskellwiki/Grapefruit
04:11:22 <lambdabot> Title: Grapefruit - HaskellWiki
04:11:26 <dons> new gui libs on gtk!
04:11:43 * mux gets interested
04:11:52 <dons> ?where+ grapefruit http://haskell.org/haskellwiki/Grapefruit
04:11:52 <lambdabot> Done.
04:12:15 <mux> yet another declarative GUI API
04:13:36 <augustss> how is grapefruit related to fruit?
04:13:36 <dons> on top of gtk. that's promising.
04:14:12 <mux> dons: heh, I see you've taken dwm's description and ran s/C/Haskell/g on it to create a description text for XMonad :-)
04:14:29 <dons> heh
04:14:53 <mux> yay, I'm in the HWN!
04:17:14 <mux> for that unlikely to get accepted MonadState instance for Parsec proposal though
04:19:11 <Heffalump> what's wrong with the proposal?
04:19:57 <ndm> dons, Haskell requires 200 times more work to get going, monads/types etc, but lots less work debugging
04:20:18 <ndm> (which is good because our debugging sucks!)
04:20:45 <ndm> dons, i also would just say "email jobs to haskell@haskell.org", i'm sure you'll pick them all up that way
04:20:46 <mux> Heffalump: it adds dependencies on mtl and uses functionaldependencies in Parsec, making the code non-H98
04:21:11 <ndm> mux, can you not add it to a parsec-extra package?
04:21:19 <ndm> as is being done for mtl
04:21:26 <mux> I guess that's one possibility
04:21:46 <mux> I was hoping for suggestions of this kind on the libraries@ mailing list, but the matter doesn't seem to interest much people :-)
04:22:11 <Heffalump> ndm: what's being done for mtl?
04:22:30 <mux> I can whip up a parsec-extra package for just that instance but that won't look very nice, it would be find more things to stuff into :-)
04:22:52 <ndm> Heffalump, Ross is splitting it into mtl-base and mtl, mtl-base being 100% 98
04:23:02 <Heffalump> ah, right
04:23:11 <Heffalump> so just the types without the classes?
04:23:22 <ndm> pretty much, yes
04:23:22 <mux> s/find/nice to find/
04:23:29 * mux isn't fully awake yet
04:24:01 * mux is planning to write mtl-at as soon as GHC gets associated type synonyms
04:25:33 <dolio> Heh, that will make it even less portable.
04:25:58 <Heffalump> how do ATs help? (I can guess they might, but can't immediately think of the details)
04:26:54 <mux> the aim is not to have it more portable, obviously, it's just that if we are to move from FDs to ATs (and I can imagine ATs being in Haskell'' - probably too short for Haskell') then better have it sooner than later
04:27:00 <mux> and it'll be an interesting exercise for me
04:27:50 <Heffalump> ok, so you just move the state type into the type class
04:27:50 <Heffalump> ?
04:28:08 <mux> Heffalump: it helps because, taking the example of MonadState, you only need to have one type class parameter (the monad), and you have the state type being a type synonyms
04:28:12 <mux> yes, exactly
04:28:25 <mux> so you avoid the ambiguity of MPTCs without using FDs
04:29:39 <dolio> They end up looking nicer in type signatures, too.
04:29:40 <Heffalump> how about MonadTrans?
04:30:03 <Heffalump> ATs are a maybe for 6.8, right?
04:30:33 <mux> associated data types are already in 6.7, and associated type synyoms should be here in a few months
04:30:50 <Heffalump> ah, right
04:31:04 <Heffalump> do you know what the technical difference that makes them have to be separated is?
04:31:06 <dolio> MonadTrans is already H98, isn't it?
04:31:16 <mux> Heffalump: unfortunately this is way over my head :)
04:31:21 <Heffalump> dolio: oh, maybe
04:31:28 <Heffalump> I always think of it as complicated, but it's not really.
04:31:47 <Heffalump> it's just so _general_ :-)
04:31:49 <mux> I can't even begin to imagine how ATs can get desugared into play system Fc
04:31:51 <dolio> I think it's just 'class MonadTrans t where lift :: m a -> t m a'
04:31:58 <mux> s/play/plain/
04:31:58 <mux> damnit
04:32:20 <foxy-om> @google Chakravarty associated types
04:32:21 <lambdabot> http://www.cse.unsw.edu.au/~chak/papers/CKPM05.html
04:32:21 <lambdabot> Title: Research Papers of Manuel Chakravarty
04:32:25 <dolio> There may be a 'Monad m =>' in there, I can't recall.
04:32:37 <mux> @info MonadTrans
04:32:38 <lambdabot> MonadTrans
04:32:45 <mux> hm, not so useful
04:32:54 <dolio> @src MonadTrans
04:32:55 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
04:42:54 <ski> 'lift' has a 'Monad m' constraint, yes
04:45:48 <bauchus> hi. for the latest xhtml package + ghc 6.6.1: do I need an upgrade of Cabal?
04:46:25 <bauchus> I get this error msg in Setup.hs: Couldn't match expected type `UserHooks'  against inferred type `Maybe UserHooks'
04:46:25 <bauchus>  
04:50:55 <matthew-_> yes, that's been reported with other libraries too
04:51:10 <matthew-_> find the line, and take out the type signature, that tends to make it go away
04:51:21 <matthew-_> but I think the problem is that it wants cabal 1.1.7
04:54:25 <bauchus> matthew-_: thanks
05:00:28 <ndm> bauchus, and beat Igloo until he makes the change for you
05:35:53 <sphynx> hi, I have problems while compiling yi 0.1.0
05:36:35 <sphynx> I've downloaded sourceball 0.1.0, then run ./configure and make way=static
05:36:57 <sphynx> then I've got such error:
05:37:12 <sphynx>  Bad interface file: Yi/Undo.hi-boot
05:37:26 <sphynx> 	magic number mismatch: old/corrupt interface file?
05:39:27 <sphynx> so could you please help me?
05:47:55 <araujo> morning
05:49:29 <ehird10> jeez, loads of buzz about xmonad
05:57:26 <Maddas> 200x harder? 10x harder?
05:57:55 <Maddas> clearly my brain works differently, it never even numerically rates the difficulty of learning things :-)
06:24:35 <foxy-om> sphynx sounds like there's a problem with ghc version numbers, is there an hs-boot file in the same directory?
06:25:50 <sorear> @users
06:25:50 <lambdabot> Maximum users seen in #haskell: 335, currently: 303 (90.4%), active: 26 (8.6%)
06:26:06 <sphynx> hm, I've reinstalled my linux some days ago, so maybe now there are different versions of ghc, because I haven't removed my /home
06:26:43 <sphynx> sphynx@behexen:~/Desktop/yi-0.1.0$ ghc --version
06:26:45 <sphynx> The Glorious Glasgow Haskell Compilation System, version 6.6
06:27:16 <Saizan> i'll try a make clean
06:27:41 <foxy-om> is there an .hs-boot file in the same directory as the .hi-boot file?
06:29:13 <sphynx> Saizan, make clean didn't help
06:29:44 <sphynx> foxy-om, I can't find .hi-boot file.. where it is?
06:30:01 <foxy-om> is that after make clean?
06:30:36 <cdsmith> @pl \(x,y) -> (y,x)
06:30:37 <lambdabot> uncurry (flip (,))
06:31:06 <sphynx> foxy-om, yes
06:31:19 <foxy-om> does recompiling work now?
06:32:02 <sphynx> it compiles some files:
06:32:17 <sphynx> hsc2hs -Imk -Icbits  -DGLASGOW_HASKELL=606  Yi/Curses/CWString.hsc
06:32:33 <sphynx> and some other files, but then gives me the same error
06:33:31 <hpaste>  sphynx pasted "Yi build error" at http://hpaste.org/1605
06:33:31 <foxy-om> is there a file Yi/Undo.hs-boot ?
06:33:54 <sphynx> foxy-om, yes, it is, it contains only two lines
06:34:11 <foxy-om> what are they?
06:34:42 <sphynx> module Yi.Undo where
06:34:42 <sphynx> data URAction
06:35:19 <foxy-om> and when you "make clean" Yi/Undo.hi-boot gets deleted?
06:35:58 <sphynx> foxy-om, no..
06:36:08 <sphynx> foxy-om, should I remove it manually?
06:36:31 <foxy-om> the _*hi-boot*_ NOT the _*hs-boot*_
06:37:08 <sphynx> foxy-om, oops, yes, make clean removes 'HI-boot'
06:37:21 <sphynx> foxy-om, HS-boot remains
06:37:42 <foxy-om> hm.. then I don't know what's going wrong, sorry :(
06:38:22 <sphynx> foxy-om, well, I'll try to compile it in non-static way
06:38:42 <sphynx> foxy-om, with haskell-plugins. Maybe it will help
06:38:48 <foxy-om> sphynx, have you installed a new version of ghc recently?
06:39:17 <foxy-om> sphynx, hi files (the interfaces) can only be used with the version of ghc that generated them
06:40:39 <sphynx> foxy-om, some weeks ago I have ghc-6.4 installed from Ubuntu linux package, but I wanted 6.6, so I've recompiled ghc-6.6 from sources
06:40:49 <sphynx> foxy-om, All was ok
06:41:03 <Gwern> http://www.movethemarkets.com/richard/2007/04/28/functional-programming-idiom-plan-for-currying/ <-- is this the sort of thing 'flip' is good for?
06:41:07 <lambdabot> Title: Functional Programming Idiom: Plan for Currying -- I am Richard, http://tinyurl.com/235hqn
06:41:19 <foxy-om> sphynx: well, that's the only thing I can think of
06:41:24 <sphynx> foxy-om, But some days ago, I've upgraded my linux distribution and now I have ghc-6.6 package in repository, so I just installed 6.6 from package
06:43:25 <sphynx> foxy-om, can there be some libraries or other ghc-related things in my /home partition, which remains from old installation of 6.6? Cause while upgrading I had removed all my root partition with ghc-6.6 installed on it
06:43:48 <foxy-om> could be, dunno
06:57:56 <augustss> gwern: yes, that's what flip is good for
07:04:58 <roconnor> @type flip flip
07:05:01 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
07:05:33 <jyp> sphynx: you really want to install a more recent version of yi (ie. darcs repo)
07:05:54 <augustss> @type flip flip flip
07:05:57 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
07:09:13 <sphynx> jyp, But I've tried to install 0.1.0 version like more stable :)
07:10:07 <sphynx> jyp, should I try one from repo?
07:10:14 <jyp> sphynx: yup
07:10:39 <jyp> sphynx: please :) I'm actually planning to release a new version end of may
07:10:54 <jyp> so testing now is really welcome.
07:11:16 <sphynx> jyp, ok, I'll try
07:11:38 <jyp> cheers
07:12:25 <sphynx> jyp, Now I write haskell programs in vim+ghci, but I want to try something new
07:12:50 <sphynx> jyp, Also I've tried EclipseFP, but is's not good for me
07:12:56 <haskell> hi all
07:14:15 <sphynx> jyp, could yi make haskell programming easier? I want some basic integration with compiler. I can do it in vim too, but maybe it is already implemented in Yi?
07:14:37 <jyp> sphynx: Yi is still quite experimental...
07:14:41 <jyp> However...
07:14:55 <jyp> Yi is configured in haskell
07:15:03 <jyp> which means that it embeds GHCi
07:15:32 <jyp> so; you can actually program whatever you like and run it inside Yi
07:16:05 <jyp> (very much like emacs can be seen as a lisp development environment)
07:17:04 <sphynx> jyp, I'm a haskell newbie, so I don't require some cool features, just features for experimenting with language and solving some tasks from projecteuler.net and other programming contests :)
07:17:46 <jyp> Cool :)
07:18:17 <sphynx> jyp, now I'm trying to work with IO and interact, so ghci is not suitable, I need to compile programs and run from console
07:18:51 <jyp> I see.
07:18:55 <sphynx> jyp, so I type code in vim, then run ghc --make myCoolProgram.hs, and them ./CoolProgram :)
07:19:43 <jyp> Well, you can certainly do the same with Yi
07:19:50 <sorear> sphynx: better yet: ghci myCoolProgram.hs ; while :; do ":r" ; "main" ; done
07:20:34 <jyp> sphynx: you can also program any feature you need in Yi... in haskell :)
07:21:15 <sphynx> jyp, it's certainly cool, but I think I'm not at that level of haskell :)
07:21:46 <sphynx> sorear, OK, but what should this do? Could you please explain?
07:21:53 <jyp> The difficulty should not be overestimated either.
07:22:38 <sorear> sphynx: load your program in GHCi, then (1) change it (2) type ":r" in GHCi (3) test, by running "main"
07:24:21 <sphynx> sorear, hm, how ":" in "while :" will change the program, what does mean this colon there?
07:25:08 <sorear> sphynx: My brain was stuck in bash-mode.  : is a bashism for 'true', as in 'while true', as in 'forever'
07:25:18 <sorear> s/bash/sh/, even
07:25:54 <sphynx> sorear, oh ok, I know bash a little, but didn't know this before, thanks! :)
07:28:44 <sphynx> sorear, ah, I've understood, you mean that I just need to type ":r" and "main" in ghci shell after each modification, so I do that! :)
07:29:58 <sphynx> sorear, problem is when I'm working with IO like 'interact', 'getContents' etc. GHCi is not working well for me, because it reads line by line
07:30:50 <haskell> type "do {line1;line2;line3}" etc
07:30:52 <sorear> sphynx: ghci has different *default* behavor.  you can change it with IO.hSetBuffering IO.stdin IO.{NoBuffering,LineBuffering}
07:31:16 <sorear> haskell: eh?
07:32:02 <sorear> sphynx: btw, automatic import is ghci prompt only - you'll have to explicitly import IO to use that code in a file
07:32:55 <sphynx> sorear, with +m directive in GHCi, right
07:33:04 <sphynx> sorear, ?
07:33:28 <sorear> sphynx: with 'import IO'
07:33:54 <sorear> sphynx: you don't have to do anything special for 'IO.hSetBuffering IO.stdin IO.NoBuffering' to work at the prompt
07:34:08 <sorear> sphynx: but if you want it in a file, you will need to 'import IO'
07:34:19 <sphynx> sorear, ah, OK. I know about 'import IO' :)
07:36:37 <sphynx> sorear, hm, I've the following error after change buffering mode:
07:36:49 <sphynx> *Main> main
07:36:49 <sphynx> *** Exception: <stdin>: hGetContents: illegal operation (handle is closed)
07:37:15 <sphynx> my main is: main = interact (unlines . takeWhile (/="42") . lines)
07:41:51 <sphynx> after reloading ":r" all is OK, but it still duplicates every char I'm entering
07:46:11 <sphynx> sorear, hmm, now works fine, thank you!
07:50:14 <sorear> great!
07:57:22 * SamB_XP wonders why mozilla doesn't support ordinary print preview...
08:03:30 * Baughn wonders why you're using mozilla instead of phoenix
08:09:32 <haskell> is phoenix a web browser?
08:10:09 <ehird10> haskell: used to be
08:10:13 <ehird10> its now called firefox.
08:10:16 <ehird10> you may have heard of it
08:10:41 <ehird10> (allow me to offer the opinion that your nick is not very creative, haskell)
08:15:57 <Vq^> ehird10: nothing wrong with using your own name as a nick
08:17:16 <haskell> I like the word 'haskell'
08:17:19 <haskell> :)
08:18:56 <haskell> ehird10: I use firefox, but i didn't know that's phoenix.
08:19:11 <ehird10> It used to be.
08:19:21 <ehird10> Then they changed it to firebird because of copyright.
08:19:26 <ehird10> And then they changed it to firefox again. Same reason
08:20:44 <sorear> And then, in a supreme twist of irony, debian's firefox is called iceweasel because of restrictive Mozilla Foundation trademark rules.
08:23:56 <ehird10> sorear: Yeah, I've pretty much disowned mozilla
08:24:05 <ehird10> They've turned into a BigEvilCorp(TM)
08:24:37 <Saizan> ?pl (\x -> (hasName_ . ctorName $ x) :->: one x)
08:24:37 <lambdabot> ap ((:->:) . hasName_ . ctorName) one
08:24:41 <desp> does anyone know how darcs currently handles conflicting patches?
08:24:51 <sorear> I don't use mozillas at all.
08:24:54 <sorear> <- elinkser
08:24:58 <desp> the conflicts section of "Understanding darcs" is unfinished
08:25:16 <sorear> desp: the person most likely to know is lispy
08:25:21 <ehird10> sorear: i can't believe  anyone actually uses elinks
08:25:22 <ehird10> :P
08:25:29 <desp> lispy: poke
08:25:40 <Saizan> from my experience it marks the conflict in the file
08:25:41 * ehird10 uses safari, on linux /me uses firefox, but a custom build hacked to hell... and without any mozilla logos
08:25:55 * Vq^ mixes links2 and firefox
08:26:44 <sorear> desp: background: lispy is rewriting the darcs conflict algorithm as a SoC project, and presumably knows a great deal about the current one
08:26:45 * ehird10 uses lynx!
08:27:04 <Syzygy-> > log
08:27:06 <Syzygy-> > log 3
08:27:06 <lambdabot>  <Double -> Double>
08:27:07 <lambdabot>  1.0986122886681098
08:27:09 <desp> sorear: ah, cool
08:27:11 * haskell uses telnet
08:27:13 <haskell> :P
08:27:20 * ehird10 uses hget|htmlrender
08:27:20 * sorear uses NETCAT
08:27:35 <Syzygy-> sum $ map log [1..52]
08:27:43 <desp> meow
08:27:45 <Syzygy-> > sum $ map log [1..52]
08:27:47 <lambdabot>  156.3608363030788
08:27:54 <ehird10> > meow
08:27:55 <lambdabot>   Not in scope: `meow'
08:27:57 <ehird10> aw
08:28:06 <Syzygy-> > (sum $ map log [1..52])/log 10
08:28:08 <lambdabot>  67.90664839220477
08:28:13 <Syzygy-> > (sum $ map log [1..52])/log 2
08:28:15 <lambdabot>  225.5810031237028
08:35:15 <sorear> @users
08:35:16 <lambdabot> Maximum users seen in #haskell: 335, currently: 304 (90.7%), active: 25 (8.2%)
08:38:12 <haskell> > let it x f n = if (n >= 0) then f (it x f (n - 1)) else f x
08:38:13 <lambdabot>  Parse error
08:38:18 <haskell> hmm
08:38:50 <haskell> > it x f n = if (n >= 0) then f (it x f (n - 1)) else f x
08:38:51 <lambdabot>  Parse error
08:40:30 <sorear> haskell: lambadbot only does expressions, not definitions
08:40:32 <ehird10> > let it x f n = if (n >= 0) then f (it x f (n - 1)) else f x in it <stuff>
08:40:33 <lambdabot>  Parse error
08:40:42 <ehird10> where stuff is... well, you can guess
08:40:45 <sorear> <stuff> doesn't look valid :)
08:40:47 <ddarius> haskell: If you are going to call yourself haskell, you must use the combinator calculus.
08:43:18 <ddarius> @check \xs n -> let it x f n = if (n >= 0) then f (it x f (n - 1)) else f x in it 0 (+1) n == take n $ iterate 0 (+1)
08:43:19 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `Bool'
08:44:59 <ddarius> nm
08:46:58 <mux> > let fac = fix (\f x -> if x == 0 then 1 else x * f (x - 1)) in fac 5
08:46:59 <lambdabot>  120
08:47:18 <ehird10> that's a rather verbose factorial
08:47:34 <ehird10> > let fac = product (enumFromTo 1 .) in fac 5
08:47:35 <lambdabot>  Couldn't match expected type `[a]'
08:47:37 <ehird10> urgh
08:47:50 <mux> yes, the point is expressing it with fix
08:47:55 <ddarius> > let fac n = product [1..n] in fac 5
08:47:56 <lambdabot>  120
08:48:06 <ehird10> [1..n]? that didn't work a minute ago!
08:48:18 <ehird10> oh, wait
08:48:21 <ehird10> it was [1...] that didn't
08:48:24 <ehird10> @pl fac n = product [1..n]
08:48:25 <lambdabot> fac = product . enumFromTo 1
08:48:32 <ehird10> hmm
08:48:36 <ehird10> @unpl fac n = product [1..n]
08:48:37 <lambdabot> fac n = product [1 .. n]
08:48:52 <haskell> ehird10: http://www.willamette.edu/~fruehr/haskell/evolution.html
08:48:53 <lambdabot> Title: The Evolution of a Haskell Programmer
08:48:55 <haskell> that's work
08:48:58 <ehird10> haskell: read it
08:49:05 <gds> @help let
08:49:06 <lambdabot> let <x> = <e>. Add a binding
08:49:14 <ddarius> @let x = 3
08:49:16 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
08:49:23 <ehird10> i like the scheme one
08:49:33 <haskell> > let it x f n = if (n >= 0) then f (it x f (n - 1)) else f x in it 0.1 cos 500
08:49:35 <lambdabot>  0.7390851332151607
08:49:38 <haskell> > let it x f n = if (n >= 0) then f (it x f (n - 1)) else f x in it 0.1 cos 50000000000000000000000
08:49:41 <lambdabot>  Exception: stack overflow
08:49:46 <haskell> :D
08:49:59 <ehird10> ha ha ha stack overflows are so hilarious ha ha ha!
08:50:08 <ddarius> it == foldNat, cos is strict you want an iterateNat
08:50:59 <ehird10> fac n = snd (until ((>n) . fst) (\(i,m) -> (i+1, i*m)) (1,1))
08:51:00 <ehird10> yow! that is ugly
08:51:08 <ddarius> http://www-staff.it.uts.edu.au/~cbj/Publications/loops.html
08:51:08 <lambdabot> Title: Barry Jay's Research Interests: Loops
08:51:11 <int-e> > iterate cos 0.1 !! 500
08:51:12 <lambdabot>  0.7390851332151607
08:51:27 <desp> http://darcs.net/DarcsWiki
08:51:28 <desp> hmm
08:51:29 <lambdabot> Title: FrontPage - DarcsWiki
08:52:47 <int-e> @index iterate'
08:52:48 <lambdabot> bzzt
08:53:10 <desp> I don't see a way to revert that page
08:56:13 <gimboland> fiblist = 0 : 1 : (zipWith (+) fiblist (tail fiblist))
08:56:23 <ddarius> Looking at the history, clearly that page should be immutable to non-"registered" users.
08:56:50 <gimboland> there's the entire fibonacci series :)  (via GMBM, IIRC).
08:56:52 <ddarius> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
08:56:54 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
08:57:11 <gimboland> lush, isn't it?
08:57:26 * ddarius waits for sorear.
08:58:28 <mux> > nubBy(((>1) .) . gcd) [2..]
08:58:30 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
08:59:04 <gimboland> holy shit
08:59:34 * gimboland faints
09:01:49 <sphynx> mux, wow! :)
09:02:32 <mux> nice one-liner, isn't?
09:02:40 <mux> isn't it, even
09:03:01 <dons> its cute.
09:03:48 <dons> > fix ((1:) . scanl (+) 1) -- my favourite
09:03:52 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
09:04:20 <ddarius> Do we need a HOLSLOAN?
09:05:50 <ekidd> Trying to make a version of bowling in Haskell which is better than Ron Jeffries' C#, Smalltalk, etc., versions: http://www.randomhacks.net/articles/2007/04/28/bowling-in-haskell
09:05:50 <lambdabot> Title: Bowling in Haskell
09:07:26 <_roconnor> > takewhile(<99)$nubBy(((>1) .) . gcd) [2..]
09:07:28 <lambdabot>   Not in scope: `takewhile'
09:07:36 <_roconnor> > takeWhile(<99)$nubBy(((>1) .) . gcd) [2..]
09:07:38 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
09:07:50 <_roconnor> > takeWhile(<99)$nubBy(((>1).).gcd)[2..]
09:07:52 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
09:08:15 <_roconnor> > length "f n=takeWhile(<n)$nubBy(((>1).).gcd)[2..]"
09:08:17 <lambdabot>  41
09:08:30 <dons> ekidd: ah right, you want to improve dmead's versoin, http://www.xprogramming.com/xpmag/dbcHaskellBowling.htm ?
09:08:32 <lambdabot> Title: Haskell Bowling
09:08:35 <_roconnor> still too long
09:09:17 <_roconnor> > length "f n=nubBy(((>1).).gcd)[2..n]"
09:09:19 <lambdabot>  28
09:09:29 <_roconnor> > let f n=nubBy(((>1).).gcd)[2..n] in f 99
09:09:30 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
09:09:30 <dons> ekidd: ah yes, you saw that.
09:09:35 <_roconnor> does that work?
09:09:38 <ekidd> dons: Yeah, I link to that article. dmead's version, if I remember correctly, can be fooled by certain configurations in the 9th and 10th frame.
09:10:15 <_roconnor> @type nubBy
09:10:18 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
09:10:25 <dons> ekidd: any chance for QuickCheck too?
09:10:46 <dons> are there some nice general properties you could test in a line or two of QC?
09:11:07 <dons> reminds me I meant to write a small article on QuickChecking xmonad
09:11:21 <ekidd> dons: I couldn't think of any nice properties, at least not without without recreating the whole program in the test-case generator.
09:11:26 <dons> yeah
09:12:01 <dons> its nice you're revisiting this one. It was a bit annoying not to have a good response :-)
09:12:03 <ekidd> And I wish there were a way to mix zero-argument test cases (run only once, please!) and test cases with random arguments in QuickCheck.
09:12:38 <dons> yeah, a mixture of smallcheck and quickcheck
09:12:44 <dons> ?scheck True
09:12:45 <lambdabot>   Completed 1 test(s) without failure.
09:12:48 <dons> ?check True
09:12:49 <lambdabot>  OK, passed 500 tests.
09:13:22 <jcreigh> so that's the main difference between smallcheck and quickcheck?
09:13:39 <dons> right. breadth first generation, versus random walks
09:13:57 <dons> ?scheck \x -> not x
09:13:58 <lambdabot>   Failed test no. 1. Test values follow.: True
09:14:05 <dons> ?scheck \x -> not x || x
09:14:06 <lambdabot>   Completed 2 test(s) without failure.
09:14:09 <jcreigh> hmm. I meant to write "what's the main difference", but I guess I got the right answer anyway. :)
09:14:25 <jcreigh> but people seem to use QC more.
09:14:31 <ekidd> dons: The various versions of the bowling game on Jeffries' site were annoying me; I wanted to find a simpler solution.
09:14:38 <ddarius> _roconnor: The ((>1) .) . gcd sets up a congruence identifying all numbers not relatively prime to those that have come before, and thus removes them as "duplicates" modulo that congruence.
09:14:43 <dons> well, it generalises unit testing to arbitrary parameters to tests
09:14:45 <haskell> > fst$head$readFloat "2.4425sfgdfgsdfhdgh"
09:14:47 <lambdabot>  2.4425
09:14:51 <haskell> nice
09:15:23 <dons> ekidd: maybe have a full src listing for the final program linked?
09:15:40 <ekidd> dons: Yeah, I just need to push the Darcs repo up to my server.
09:15:58 <mux> @users
09:15:59 <lambdabot> Maximum users seen in #haskell: 335, currently: 304 (90.7%), active: 31 (10.2%)
09:16:37 <dons> ekidd: seen the new fusion paper?
09:16:46 <dons> it'd be interesting to do your tree fusion example with streams.
09:16:49 <_roconnor> wait, is nubBy in the prelude?
09:17:00 <dons> (there's a little bit at the end of the paper covering trees)
09:17:05 <dons> _roconnor: in List?
09:17:09 <_roconnor> Oh damn
09:17:24 <ekidd> dons: Got a link? I think I might have downloaded it, but I haven't read it yet.
09:17:50 <dons> http://www.cse.unsw.edu.au/~dons/papers/CLS07.html
09:17:50 <lambdabot> Title: Stream Fusion: From Lists to Streams to Nothing at All
09:18:03 <_roconnor> > length "import List"
09:18:05 <lambdabot>  11
09:18:45 <dons> ekidd: in particular, extended to concatMap and list comprehensions, and an account of how the fused code is optimised
09:18:58 <dons> (extended wrt. the bytestring fusion paper, i mean)
09:20:11 <ekidd> Hmm. That wasn't in my in basket after all. Thanks!
09:20:28 <hpaste>  lienmeister pasted "decode bitfields" at http://hpaste.org/1606
09:21:15 <dons> ?time
09:21:19 <lambdabot> Local time for dons is Sun Apr 29 02:19:35 2007
09:21:21 <dons> bed time night all!
09:21:43 <haskell> 18:19 here
09:22:32 <Heffalump> I didn't know dons slept.
09:24:50 <haskell> > [1..]
09:24:52 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
09:24:59 <haskell> hehe
09:25:13 <_roconnor> can I use List.nubBy without importing List?
09:25:26 <cjay> haskell: the sheepcount list?
09:25:40 <Heffalump> _roconnor: no
09:25:51 <Heffalump> that's the whole point of imports :-)
09:25:52 <_roconnor> oh okay
09:26:00 <Heffalump> (unless it turns out some other module reexports it or something)
09:26:01 * _roconnor wonders why ghci lets me get away with it
09:26:07 <Heffalump> oh, right, ghci is nice like that
09:26:12 <Heffalump> I find that really handy.
09:26:31 <Heffalump> what ghci does isn't so constrained by the language spec, since it doesn't talk about the REPL
09:27:38 <haskell> cjay: yeah :)
09:27:47 <cjay> :)
09:31:05 <haskellboy> hi guys , in LaTeX , would anybody know how to typographically output the word BibTeX ?  e.g. for LaTeX you just type "\LaTeX"
09:32:15 <_roconnor> (~RâRâ.ÃR)/Râ1âÎ¹R
09:33:15 <ddarius> APL?
09:33:27 <ekidd> dons: I added a link to the full source code.
09:33:33 <Heffalump> what's with all these people called haskellfoo?
09:33:35 <_roconnor> APL
09:33:43 <Heffalump> well, two. In one case where foo = "".
09:35:39 <haskellboy> would anybody know how to typographically output the word BibTeX ?  e.g. for LaTeX you just type "\LaTeX"
09:36:09 <Heffalump> you already asked that once
09:39:23 <desp> haskellboy: wouldn't the latex channel be a better forum for such questions?
09:39:47 <haskell> _roconnor: you dont need to import Data.List
09:40:02 <haskell> nubBy eq []             =  []
09:40:06 <haskell> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
09:40:19 <Heffalump> yeah, cos cut-n-paste coding is such a good idea :-)
09:40:27 <haskell> :P
09:44:18 <ddarius> haskell: And that that is less than the 16 characters "import Data.List" would take.
09:46:05 <Heffalump> > length "import Data.List (nubBy)\n"
09:46:07 <lambdabot>  25
09:47:03 <ddarius> > let nubBy eq = foldr (\x -> (x:) . filter (not . eq x)) [] in nubBy (((>1) .) . gcd) [2..]
09:47:04 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
09:47:13 <haskell> length "import Data.List as Dfghdfhdghgdhghfghfghfghfghfghfghfghfhgdghdghdghsfgh"
09:47:16 <haskell> > length "import Data.List as Dfghdfhdghgdhghfghfghfghfghfghfghfghfhgdghdghdghsfgh"
09:47:18 <lambdabot>  72
09:47:24 <haskell> too long
09:49:56 <ddarius_> > length "nubBy eq = foldr (\\x -> (x:) . filter (not . eq x)) []"
09:49:58 <lambdabot>  54
09:51:04 <haskell> nah I've to eat
09:51:07 <Heffalump> hi njbartlett. Are you the London Haskell User Group organiser?
09:58:18 <sorear> hello!
10:03:00 <njbartlett> Heffalump> Yes I am
10:06:25 <Heffalump> njbartlett: cool, thanks for organising it
10:07:16 <njbartlett> Heffalump: thanks - have you registered to come?
10:10:07 <Cheery_> Is there any way to 'quickfix' modules with no derived instance of Read?
10:10:30 <thetallguy> tessier:  Noted.
10:10:39 <sorear> Cheery_: use stand alone deriving (in GHC HEAD) or DrIFT
10:11:19 <Cheery_> sorear: care to explain more detailed?
10:11:32 <sorear> import System.Time ; derive instance Read ClockTime
10:11:56 <Saizan> :O
10:11:58 <thetallguy> Cheery: you could also write your own instance
10:12:02 <sorear> that works in 6.7.20070413 with -fglasgow-exts
10:12:20 <Saizan> or use Data.Derive ?
10:12:38 <sorear> with data.derive it would look like
10:13:02 <sorear> import System.Time ; import Data.DeriveTH ; import Data.Derive.Read ; $( derive makeRead ''ClockTime )
10:14:01 <Heffalump> njbartlett: yep (Ganesh Sittampalam)
10:14:28 <Heffalump> njbartlett: I work at Credit Suisse with Lennart Augustsson
10:16:22 * Philippa might make it
10:19:04 <OCCASVS> Hello
10:19:16 * sorear doesn't live in the right city
10:19:20 <sorear> OCCASVS: Hello!
10:19:41 <sorear> OCCASVS: And welcome to #haskell.  Are you new to the language as well?
10:19:56 <Philippa> I don't live in the right city, but my SO does
10:20:47 <OCCASVS> Sorry for this stupid question: why func1 (func2 x) isn't equal to func1 . func2 x...I read that it's concatenations...but with the ".", it doesn't work
10:21:13 <njbartlett> Heffalump: Well, looking forward to meeting you and Lennart on 23rd
10:21:13 <OCCASVS> I've cheated and read the solution on a blog...it's func1 $ func2 x :S
10:21:15 <OCCASVS> why?
10:21:17 <dmhouse> It's the same as (func1 . func2) x
10:21:22 <dmhouse> (.) just builds a function
10:21:35 <Baughn> OCCASVS: Function application binds more tightly than ., so you need parantheses
10:22:01 <dmhouse> So f . g is a function, which is the composition of the function f and the function g. f . g x means f . (g x), so that isn't going to work unless g x is a function.
10:22:09 <haskell> OCCASVS: func1 (func2 x) = func1 $ func2 x
10:22:18 <haskell> not func1 . func2 x
10:22:18 <OCCASVS> Thank you :)
10:22:29 <Saizan> OCCASVS: f . g x is parsed as f . (g x) when what you want is (f . g) x, and we usually write that f . g $ x
10:22:53 <Saizan> because $ is function application but with the lowest priority
10:22:53 <dmhouse> Saizan: or even f (g x) :)
10:23:29 <OCCASVS> dmhouse, too many parentheses :D
10:23:51 <Saizan> dmhouse: a . b . c . d $ x is way better than a (b (c (d x))) which is lisp :D
10:23:51 <dmhouse> Then f $ g x. But I think f (g x) looks nicer.
10:24:10 <dmhouse> Saizan: yes, of course, but one set of parentheses isn't too bad.
10:24:30 <Baughn> Saizan: I didn't realize I could use $ that way. Amazing language. :)
10:24:51 <OCCASVS> dmhouse, the problem is that I use too many parentheses in my first n00b scripts :(
10:24:59 * dmhouse happens to think that Lisp is a pretty language, actually
10:25:06 <dmhouse> It has a minimalistic charm to it.
10:25:10 <dmhouse> (The syntax, that is.)
10:25:13 <haskell> Lisp is unreadable
10:25:20 <Cheery_> lisp is nice
10:25:23 <sorear> OCCASVS: Go ahead, use parens.  They are certainly easier than remembering ALL the fixities!
10:25:23 <haskell> :D
10:25:32 * sorear likes lisp, but doesn't use it much
10:25:34 <dmhouse> haskell: I find quite the opposite. With proper indentation, Lisp is very readable.
10:25:50 <jcreigh> with proper indentation, almost anything is readable.
10:26:00 <dmhouse> OCCASVS: it's a common mistake. Just remember the golden rule: normal function application binds tighter than anything else.
10:26:07 <Saizan> haskell is way more clean, but it's probably a matter of habit
10:26:25 <dmhouse> So in (f x) `elem` xs, the parentheses aren't needed, f x `elem` xs will work. Same with (f x) == (g x).
10:26:39 <sorear> With sufficient whitespace, BF is readable!
10:26:48 <haskell> BF.. lol
10:27:15 <Philippa> sorear: I hope that wasn't a pun
10:27:33 <Philippa> given that one of the perpetrators of whitespace is sitting in this chan :-)
10:27:38 <Baughn> Lisp syntax would be redundant in haskell, seeing as all functions have one (or 0) parameters, but.. editor support is a lot harder.
10:27:39 <sorear> Philippa: It wasn't!
10:28:02 <OCCASVS> dmhouse, thank you
10:28:35 <osfameron> I like that with lisp you never have to remember when to use parens
10:28:39 <dmhouse> Baughn: someone's written a Lisp syntax front-end to GHC.
10:28:47 <Heffalump> dmhouse: Liskell?
10:28:49 <dmhouse> Heffalump: yes.
10:28:51 <osfameron> haskell surprises me otoh, depends on fixity etc.
10:29:02 <Heffalump> it's more a TH-alike but with Lisp as the metalanguage, right?
10:29:50 <jcreigh> all the simplicity of Haskell combined with the power of lisp! :)
10:29:52 <sorear> edwinb++
10:30:06 <jcreigh> (don't listen to me; I've never user Liskell)
10:30:09 <Saizan> you get (or have to) use the lispish syntax instead of the normal one
10:30:12 <jcreigh> *used
10:30:23 <haskell> liskell?:)
10:30:45 <jcreigh> @google liskell
10:30:54 <haskell> i do
10:30:56 <Heffalump> sorear: just get on a plane :-)
10:30:59 <OCCASVS> http://hpaste.org/1607
10:31:01 <lambdabot> Plugin `search' failed with: IRCRaised thread killed
10:31:18 <OCCASVS> Must I use func1 (func2 x y) in this case?
10:32:01 <OCCASVS> My code is so little elegant :(
10:32:02 <Saizan> or ((fst .) . maxOccurs)
10:32:16 <Heffalump> but don't do that, it's obscure
10:32:24 <Saizan> or just pattern match
10:32:27 <dmhouse> Yes, sections on composition are not very readable.
10:32:38 <Saizan> (m,n) = maxOccurs x y
10:32:40 <Heffalump> I suggest fst $ maxOccurs x y
10:32:49 <Heffalump> ah, yes, that's much nicer
10:33:40 <OCCASVS> Heffalump, I read fst $ maxOccurs x y in the solution found on a blog
10:34:08 <OCCASVS> But that student has cheated, because my book hasn't explained "$" yet :D
10:34:22 <Heffalump> :-)
10:34:34 <hpaste>  dmhouse annotated "(no title)" with "pattern matching makes things simpler" at http://hpaste.org/1607#a1
10:34:37 <Heffalump> I actually really hate the idea that you're not "supposed" to know things yet
10:34:45 <dmhouse> OCCASVS: ^^ see that paset.
10:34:46 * jcreigh nods
10:34:48 <dmhouse> *paste.
10:34:52 <Heffalump> it used to bite me all the time at school
10:34:53 <Baughn> That reminds me.. is there a book that explains Haskell well somewhere? Something I could read without a laptop?
10:35:07 <Heffalump> Baughn: there are plenty of introductory books
10:35:14 <jcreigh> "Well, we haven't covered X yet, so you can't use it."
10:35:15 <Heffalump> e.g. Graham Hutton's, Paul Hudak's
10:35:45 <dmhouse> Baughn: try looking at haskell.org, there are many.
10:36:00 <Baughn> dmhouse: Too many. My library has none, so if I can only buy one, which should it be?
10:36:07 <Baughn> Assume that I already know the basics
10:36:16 <desp> ouch
10:36:20 <haskell> may use Ã¢ÂÅ¹ yet
10:36:21 <dmhouse> Depends on how you learn.
10:36:28 <desp> haddock generates really ugly html
10:36:40 <dmhouse> desp: I know. I planned to fix that at one point, but never did get round to it.
10:36:40 <haskell> haddock is good
10:36:49 <Baughn> dmhouse: ..usually by reading anything and everything I can get my hands on, I'm afraid
10:36:54 <dmhouse> desp: I think it's because it uses Text.Html, instead of the newer Text.XHtml.
10:36:56 <OCCASVS> Heffalump, I'm trying to learn step by step, without rushing
10:36:57 <ski> @where+ liskell http://clemens.endorphin.org/liskell
10:36:57 <lambdabot> Done.
10:37:03 <ski> (seems to be down atm, though ..)
10:37:04 <desp> dmhouse: ah
10:37:07 <OCCASVS> It's the first language I'm seriously learning :D
10:37:26 <desp> dmhouse: still that's the best thing there is, as far as documenting haskell code goes?
10:37:30 <Heffalump> OCCASVS: sure, but deliberately refusing to learn about certain things just because they're not in a particular linear sequence seems a bit silly to me
10:37:48 <OCCASVS> No, now I've learnt the use of "$" in this case :D
10:37:55 <dmhouse> Baughn: the first three in http://haskell.org/haskellwiki/Books_and_tutorials#Textbooks are probably the most popular.
10:37:56 <Cheery_> Anyone here maintains HSDL library?
10:37:56 <OCCASVS> And I'll use it when needed :D
10:37:57 <lambdabot> Title: Books and tutorials - HaskellWiki
10:38:01 <haskell> OCCASVS: same to mi :)
10:38:07 <haskell> mi -> me
10:38:08 <dmhouse> desp: absolutely.
10:39:23 <dmhouse> Baughn: libraries never have any of the books you want :)
10:39:32 <Baughn> dmhouse: I'll try to fix that
10:40:56 <ddarius> dmhouse: That's why you go in looking for subjects.
10:41:13 * ddarius has particular Dewey decimal codes semi-memorized.
10:41:14 <OCCASVS> haskell, how long have you been learning Haskell?
10:42:04 <Baughn> dmhouse: Actually, the library does have the paul hudak book, but I overlooked it due to its title containing "multimedia"
10:44:15 <haskell> OCCASVS: since 1 year
10:44:41 <dmhouse> Anyone know of GHC 6.6.1 .debs?
10:45:02 <haskell> OCCASVS: and you?:)
10:45:36 <OCCASVS> haskell, ehm...less than a week :D
10:46:05 <OCCASVS> I've dabbled with PHP and C some months ago, though
10:46:43 <ddarius> How did you manage to have Haskell be the first language you are seriously learning?
10:47:27 <OCCASVS> I didn't like the way of thinking for imperative languages
10:48:08 <OCCASVS> The Haskell's approach to problems seems much more sensible and elegant
10:48:16 <ddarius> OCCASVS: How did you even know about Haskell or know that there were other ways of programming?
10:48:23 <ekidd> Baughn: The "Haskell School of Expression" is quite nice, if a little rough for novice functional programmers.
10:48:57 <OCCASVS> Before starting to try to learn C and PHP, I read a lot about programming in general
10:49:03 <OCCASVS> Wikipedia, articles...
10:49:53 <haskell> I did know the Haskell from 'fquery'
10:49:54 <Saizan> OCCASVS: if you speak italian there's also #haskell.it (even if we are still very few..)
10:50:02 <haskell> (fquery is a portage tool for gentoo linux)
10:50:09 <OCCASVS> I didn't know :)
10:50:19 <OCCASVS> I'll join it when I'm back
10:50:22 <OCCASVS> bbl
10:50:31 <Saizan> bye :)
11:00:10 <ddarius> @karma slipstream
11:00:10 <lambdabot> slipstream has a karma of 0
11:02:53 <shapr> yow
11:03:16 <Korollary> wassup
11:03:58 <shapr> Just got a copy of the new Language.ASN1 library from Dominic Steinitz, yay!
11:04:12 <sorear> yay!!
11:04:18 <sorear> is it public yet?
11:04:30 <shapr> I think so.
11:04:40 <ddarius> No, shapr deals in the black market of Haskell modules.
11:04:49 <shapr> I think he just uploaded it to Hackage.
11:04:54 <shapr> ddarius: Heh, if only I could deny that...
11:05:41 <monochrom> Hahaha, your NDA requires you to not even deny that.
11:06:09 <shapr> Yeah, pretty much.
11:06:50 <monochrom> NDAs cause a lot of modal logic problems.  Can you say (can you say (can you say ...)))
11:07:33 <OCCASVS> re
11:08:52 <ski> @yow
11:08:53 <lambdabot> I want to so HAPPY, the VEINS in my neck STAND OUT!!
11:10:15 <dmwit> f *** g = first f >>> second g -- VERY nice
11:11:20 <ddarius> f *** g = second g >>> first f !
11:11:32 <ski> > [(x,y) | x <- [0..9] | y <- [0..x]]
11:11:32 <lambdabot>  Parse error
11:11:50 <haskell> > [(x,y) | x <- [0..9], y <- [0..x]]
11:11:55 <lambdabot>  [(0,0),(1,0),(1,1),(2,0),(2,1),(2,2),(3,0),(3,1),(3,2),(3,3),(4,0),(4,1),(4,...
11:12:07 <ski> no .. i want my parallel list comprehension !
11:13:06 <ddarius> ski: Does it scope like that?
11:13:28 <ski> no .. but i have a plan .. an evil^H^H^H^Hcunning plan
11:13:51 <ddarius> The best interpretation I would have for that would result in [(0,0)]
11:17:01 * ski looks around for where's put the file
11:23:14 <dmwit> ddarius: Hmmm... really?
11:23:17 <ski> i get
11:23:18 <ski> [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9)]
11:25:25 <ddarius> What about [(x,y) | x <- [0..9] | y <- [1..x]]
11:25:57 <dmwit> ddarius: Why do you say that f *** g = second g >>> first f ?
11:26:01 <kolmodin> Igloo: is cabal 1.1.6.2 available as a tarball too, or just bundled in ghc 6.6.1 ?
11:26:08 <kolmodin> I can't find it
11:26:52 <ski> (but there's some subtletly involved that i don't understand fully, yet ..)
11:26:52 <ddarius> dmwit: I was just being contrary.  They -should- be equal, but it isn't enforced by Haskell, so technically they are different and each one is a reasonable implementation of (***)
11:27:20 <dmwit> Ah, okay, so the two are equivalent for sane definitions of the other arrow operations.
11:27:27 <ddarius> ski: The subtletly involved in a crack-headed idea that is an affront against rationality?
11:27:40 <nominolo> :t (1/0)
11:27:43 <lambdabot> forall t. (Fractional t) => t
11:27:48 * ski smiles
11:28:05 <nominolo> > (1/0) + 3
11:28:07 <lambdabot>  Infinity
11:28:13 <nominolo> :t (1/0) + 3
11:28:15 <lambdabot> forall t. (Fractional t) => t
11:28:20 <ski> ddarius : i guess the idea may me *slightly* insane, yes
11:28:27 <nominolo> @instances Fractional
11:28:29 <lambdabot> Double, Float
11:28:33 <haskell> > (length [1..]) - (1/0)
11:28:33 <ski> (but there's method in the madness !)
11:28:34 <lambdabot>   add an instance declaration for (Fractional Int)
11:28:46 <ddarius> ski: We'll see.
11:28:49 <haskell> > length [1..]
11:28:54 <lambdabot> Terminated
11:29:10 <nominolo> that list was a bit too long
11:29:37 <nominolo> at least for those with only finitely many resources
11:29:53 <norpan> that sounds like me
11:30:43 <ski> (usually one'd think two noninteracting, parallel parts of the comprehension to be commutative .. but it *seems* that's no longer the case ..)
11:31:05 <ski> (where 'noninteracting' means that they don't use variables from each other)
11:31:46 <nominolo> > [ (x,y) | x <- [1..10] | y <- [1..x] ]
11:31:47 <lambdabot>  Parse error
11:32:07 <ddarius> dmwit: If the two definitions of (***) differ, than you have (part of) a premonoidal category.
11:32:29 <ski> lambdabot doesn't even understand standard parallel list comprehensions .. let alone my lunatic extension
11:32:30 <ehird10> am i the only one that thinks [10..0] should = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]?
11:32:40 <nominolo> ski: what do you mean by parallel comprehensions?
11:32:55 <nominolo> ski: is it implemented somewhere?
11:33:06 <ski> extension in ghc (and hugs iirc)
11:33:08 <nominolo> ski: do you refer to data-parallel haskell?
11:33:12 <ski> no
11:33:51 <dmwit> ddarius: What is a premonoidal category?
11:33:54 <ski> Prelude> [(x,y) | x <- [0..9] | y <- "abc"]
11:33:54 <ski> [(0,'a'),(1,'b'),(2,'c')]
11:33:55 <nominolo> ehird10: that would require a check
11:34:09 <Igloo> kolmodin: I haven't tarred the libraries up yet, no
11:34:10 <lambdabot> Igloo: You have 1 new message. '/msg lambdabot @messages' to read it.
11:34:17 <Heffalump> dmwit: it's one that wants to be monoidal but hasn't quite managed it yet
11:34:24 <ski> dmwit : a category endowed with a premonoidal structure
11:34:37 <dmwit> hahaha
11:34:40 <nominolo> ehird10: you can always get by with [10,9..0]
11:34:45 <ehird10> nominolo: true
11:35:35 <dmwit> I don't know enough category theory yet. =(
11:35:46 <ski> .. which consists of a distinguished object 'T', and two families of endofunctors over the category .. a), for every object 'A', a functor '(A *)', and b) for every object 'B', a functor '(* B)'
11:36:01 <ski> these should also satisfy some equations
11:36:05 <kolmodin> Igloo: talked with dcoutts in #gentoo-haskell, he said he'd do it
11:36:40 <ddarius> It's like a monoidal category where (x) isn't a bifunctor!
11:36:58 <ski> but it's still associative, so to speak
11:43:34 <haskell> bye
11:44:03 <allbery_b> :t let f x = y x + 5; y a = a * 2 in y
11:44:05 <lambdabot> forall a. (Num a) => a -> a
11:47:39 <ehird10> lambdabot should have a @randomsrc
11:48:46 <ski> @ghc
11:48:46 <lambdabot> ghc says: parse error (possibly incorrect indentation)
11:48:54 <ski> @ghc
11:48:55 <lambdabot> ghc says: Exotic Stmt in meta brackets
11:49:47 <Heffalump> dons should set lambdabot up so it automatically reloads if trusted people push patches to it :-)
11:51:01 <dmwit> Sanity check: x <- return y === let x = y, right?
11:51:11 <ddarius> dmwit: Yes.
11:51:12 <Heffalump> dmwit: if y doesn't contain x
11:51:24 <Heffalump> (so if y really is a variable, then yes)
11:51:35 <dmwit> Heffalump: Ah, okay, good point.
11:51:48 * Heffalump got burned by that a couple of times
11:51:55 <dmwit> Wait, why should that matter?
11:52:05 <Heffalump> dmwit: because let is recursive and <- isn't
11:52:07 <monochrom> x <- return (x+1)
11:52:14 <Heffalump> so x <- ... x ... just overrides x
11:52:26 <Heffalump> but let x = ... x ... makes a recursive definition of x
11:52:27 <monochrom> mdo { x <- return (x+1) }
11:52:36 <Heffalump> ah, now mdo, that's different
11:52:54 <dmwit> > do { let x = 3; let x = x + 1; return x } :: [Int]
11:52:55 <lambdabot>  Parse error
11:52:59 <monochrom> I don't think dmwit is using mdo :)
11:53:20 * Heffalump fails to see the parse error in that
11:53:28 <dmwit> I do.
11:53:43 <dmwit> > do { let {x = 3}; let {x = x + 1}; return x } :: [Int]
11:53:49 <lambdabot>  Exception: <<loop>>
11:53:52 <dmwit> Okay.
11:53:55 <dmwit> Interesting.
11:54:10 <dmwit> So, tell me about mdo...
11:54:16 * Heffalump sometimes writes code tha overrides variables, so guarantee that I can't accidentally use the wrong one
11:54:19 <Heffalump> dmwit: it's a recursive do
11:54:26 <Heffalump> you can use variables bound later on in the mdo
11:54:34 <Heffalump> you have to be in MonadFix to actually use it
11:54:38 <dmwit> err...
11:54:40 <dmwit> magic?
11:54:47 <Heffalump> and the desugarer calls the mfix method to sort it out
11:55:15 <dmwit> I mean, monads are supposed to be side-effecty; how can it grab things from after a side effect before the side effect happens?
11:55:33 <Heffalump> it's not intended for things like IO
11:55:50 <DRMacIver> Unless you combine it with the time travel monad. :)
11:55:56 <dmwit> My question stands even for more mundane things like State or [].
11:56:00 <ddarius> dmwit: There is nothing "side-effecty" about monads.
11:56:09 <ddarius> @instances MonadFix
11:56:11 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
11:56:15 <Heffalump> but imagine a state monad, you could implement mfix simply by tying the knot
11:56:25 <ddarius> @src [] mfix
11:56:25 <lambdabot> mfix f = case fix (f . head) of
11:56:25 <lambdabot>            []    -> []
11:56:25 <lambdabot>            (x:_) -> x : mfix (tail . f)
11:57:17 <dmwit> > let f x = [x + 1] in mfix f [1]
11:57:19 <lambdabot>  Couldn't match expected type `[t1] -> t'
11:57:28 <ski> mdo {ref <- newIORef (Cons 1 ref); return ref}
11:58:03 <dmwit> huh
11:58:49 <ski> type IOStream a = IORef (IOCell a)
11:58:59 <ski> data IOCell a = Cons a (IOStream a)
11:59:22 <ski> you can create cyclic structures with references with 'mdo'
12:00:09 <ski> (without having to set dummy values initially at the "ends")
12:01:35 <Heffalump> @src IO mfix
12:01:36 <lambdabot> mfix = fixIO
12:01:40 <Heffalump> @src fixIO
12:01:41 <desp> can a haskell program access the haskell compiler?
12:01:41 <lambdabot> Source not found. Wrong!  You cheating scum!
12:01:53 <Heffalump> desp: there's a ghc package
12:02:13 <dmwit> desp: It can definitely call the compiler; have you seen hsplugins?
12:02:27 <desp> nope, I'm generally new
12:02:28 <desp> :)
12:02:35 <dmwit> ?where hsplugins
12:02:36 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
12:02:39 <ddarius> You can make cyclical structures with references without mdo.
12:02:44 <desp> thanks
12:02:52 <dmwit> That may only be tangentially related to what you're interested in, though.
12:03:15 <dmwit> :t lift
12:03:18 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
12:04:01 <ski> @hoogle (IORef a -> a) -> IO (IORef a)
12:04:02 <lambdabot> No matches, try a more general search
12:05:10 <dmwit> ?hoogle IORef a -> a
12:05:11 <lambdabot> No matches, try a more general search
12:05:33 <ski> (mercury has the former ..)
12:05:48 <dmwit> ski: Not IORef (a -> a) ?
12:05:57 <ski> no
12:06:18 <dmwit> hmmm
12:07:46 <ski> 'new_cyclic_mutvar' at <http://www.cs.mu.oz.au/research/mercury/information/doc-latest/mercury_library/store.html>
12:07:46 <lambdabot> http://www.cs.mu.oz.au/research/mercury/information/doc-latest/mercury_library/store.html>
12:08:59 <ski> ('generic_mutvar(T, S)' is roughly the same as 'STRef s t')
12:09:30 <dmwit> I don't understand how things can seem so daunting before you learn about them, then seem so trivial after you learn about them.
12:09:40 <dmwit> I mean, I know in retrospect that it can't be all that trivial, but...
12:10:37 <Heffalump> It took me quite some time to really understand monads.
12:10:53 <Heffalump> well, I hesitate to claim I do now, but I think I have a pretty good idea.
12:11:06 <ehird10> hmm
12:11:27 <dmwit> Yeah, it's happened to me with monads.
12:11:42 <dmwit> Now monad transformers are shrinking down to a manageable size.
12:12:08 <dmwit> Yet there's still so many things mentioned here that are just mind-blowingly confusing to me...
12:12:17 <Heffalump> I asked someone about monad transformers in an interview and realised I'd forgotten the precise details of the answer to my question :-)
12:15:38 <monochrom> You.... what?!
12:16:04 <monochrom> Do your interviewees know monad transformers?
12:16:26 <Heffalump> well, the interviewee in question did
12:16:47 <Heffalump> it's not necessarily a requirement for working for us :-)
12:16:47 <Cheery_> when does the getCPUTime flips over?
12:19:52 <Cheery_> and is there some way to get game controller input than SDL in haskell?
12:26:10 <DRMacIver> Heffalump: Oops. :)
12:26:20 <dcoutts> Heffalump, I think that's fine, asking interview questions you don't necessarily know the full answer to
12:26:44 <dcoutts> you can work through it with the candidate
12:26:45 <snappy> I know this iwll sound dumb, but does haskell actually get used outside of academia/research? The only references to it that I've seen is from the guys that develop lindows/linspire.
12:27:26 * jcreigh is running a window manager written in Haskell
12:27:35 <dcoutts> snappy, well there are a number of financial institutions advertising for Haskell hackers recently
12:27:37 <qwr> i write utilities in haskell ;)
12:27:49 <Cheery_> I curse in haskell
12:28:48 <magnus> Cheery: what does that sound/look like?
12:29:27 <Heffalump> dcoutts: yes, that's what I did
12:29:41 <Heffalump> but the candidate was at the other end of a video conference so it was a bit awkward
12:30:51 <Cheery_> @pl (\stupid sdl does lack features -> sdl stupid features) 20 (+) const id 50
12:30:52 <lambdabot> 70
12:31:17 <jcreigh> Cheery_: are you thinking of the Haskell SDL binding or SDL in general?
12:31:56 <Cheery_> SDL in general
12:32:25 <jcreigh> hmm. What's missing that you could add while retaining the "S"?
12:32:27 <lispy> i think SDL was intended to be minimal
12:32:39 <Cheery_> if you use it without one extra wrapper even in C, the resulting code is line-noise
12:33:19 <Cheery_> lispy: yes it was, minimal *in function*
12:33:43 * ddarius understands how things can seem very complex but turn out to be trivial (and yes, many things are actually pretty trivial)
12:35:23 <ddarius> snappy: galoisconnections.com aetion.com
12:36:29 <Heffalump> I think Haskell is actually quite complicated. It's just got quite good orthogonality.
12:36:42 <ddarius> I didn't say -Haskell- was trivial.
12:37:08 <ddarius> Though, a lot of the complications are at the outer edges of the languages.
12:37:14 <ddarius> s/languages/language
12:38:02 <snappy> ddarius: interesting, thanks.
12:38:08 <lispy> i think just about any useful programming language is quite complicated.  What matters is how it exposes and helps the programmer manage that complexity
12:38:28 <lispy> programming is not easy for humans
12:39:44 <snappy> I've never done anything indepth with haskell or functional programming. But I really like functional prorgamming. It seems centuries ahead of the game, yet underused.
12:40:12 <lispy> it certainly has it's merits, but also it has a time/place
12:40:17 <jcreigh> it's not quite "centuries" ahead of the game. Lambdas are starting to crop up all over.
12:41:27 <ddarius> It's decades before the "game".
12:41:28 <Cheery_> jcreigh: ok, half century then.
12:41:45 <snappy> haha
12:41:50 <pejo> @where cufp
12:41:51 <lambdabot> www.galois.com/cufp
12:42:42 <pejo> Quite a lot of interesting things there, if you want commercial users of fp.
12:43:36 <snappy> Yeah I think that's where I read about haskell & linspire.
12:43:56 <lispy> i was using haskell at my day job for a while
12:44:07 <lispy> i can only get away with it on prototypes though
12:44:28 <lispy> unfortunately the people that package our releases don't want to use anything that VS doesn't support out of the box
12:46:39 <Cheery_> I've used to use something like (GameState a) => StateT a
12:46:46 <m4St3R_b41T3R> hello
12:46:53 <sproingie> funny .. i prototyped in python and plan to port it to haskell
12:46:59 <shapr> heh
12:47:08 <shapr> I'd do it in the other direction if it were my choice.
12:47:08 * kc5tja has coded a few prototypes in Haskell and ported to Python.  :)
12:47:20 <Cheery_> what other ways would I have to keep handle from game states in fps-style -game?
12:47:33 <sproingie> Cheery_: you looked at frag?
12:47:40 <Cheery_> nop
12:47:45 * ddarius would prototype in Haskell and then write it in Haskell.
12:47:48 <Cheery_> how frag does it?
12:47:56 <sproingie> Cheery_: probably good to take a look anyway.
12:48:07 <sproingie> Cheery_: if you can understand frag's source, you're much smarter than I am
12:48:20 <Cheery_> I remember it was about functional reactive programming
12:48:35 <sproingie> yeah, it's kind of a demo of  yampa
12:48:45 <Cheery_> sproingie: I'm not much smarter than you, maybe a bit of more idiot than you
12:49:00 <sproingie> i dunno, i'm a tough act to follow
12:49:51 <Saizan> so frag is written with arrows?
12:50:16 <Cheery_> Saizan: I guess so.
12:50:28 <Saizan> nice
12:50:33 * Saizan likes arrows
12:50:42 <sproingie> yah the source is peppered with arrow syntax
12:51:12 <yip> i almost have a simple starcraft clone with yampa
12:51:22 <sproingie> i only recently learned what the operators do, tho i'm still stuck on the whole Kleisli thing
12:51:41 <sproingie> the arrow page on haskell.org is ... not good
12:52:10 <yip> i understood arrows and yampa before i understood monads
12:52:29 <Cheery_> yip: do you have time/talent to explain yampa?
12:52:35 <sproingie> well it seems simple enough for arrows as functions
12:52:35 <yip> well, actually i only understood yampa's usage of arrows. i still don't fully understand arrows in general
12:53:06 <sproingie> i'm still looking out for arrows that aren't just functions.  i guess yampa has such an example
12:53:46 <Cheery_> yip: do you have your starcraft -clone sources somewhere around?
12:54:17 <yip> Cheery_: no... by "almost" i mean just the bare beginnings :)
12:54:23 <sproingie> i guess in the end they're all "just functions".  the examples i've seen just use existing functions, but i can see how the concept maps to a general "thingie that can be applied"
12:54:28 <Saizan> sproingie: have you used HXT? (Haskell Xml ToolBox)
12:54:29 <swiert> Anyone here have experience with the FFI?
12:54:34 <yip> Cheery_: but read the paper "the yampa arcade"
12:54:34 <sproingie> i just haven't looked for any such thingies
12:54:38 <dcoutts> swiert, yup
12:54:56 <sproingie> Saizan: nope, only xml stuff i used with was playing with haxml many years ago
12:55:04 <swiert> I keep getting linker errors, involving undefined symbols.
12:55:23 <sproingie> i've just sort of come back to haskell after a long absence.  i'm both a newb *and* rusty
12:55:24 <swiert> But there's a .dylib in the same directory as the Haskell source...
12:55:26 <dcoutts> swiert, btw any eta on tmr?  (and could I have fitted any more three letter acronyms into that sentence?)
12:55:34 <Saizan> sproingie: well it has a nice arrow api both for parsing and creating documents
12:55:38 <swiert> First thing monday.
12:55:43 <swiert> I don't want to release over the weekend.
12:55:48 <dcoutts> swiert, ok
12:55:57 <sproingie> Saizan: cool, i'll take a look
12:56:20 <dcoutts> swiert, so you want to set the library search path, the current dir is not necessarily on it, in fact it's almost certainly not.
12:56:33 <dcoutts> swiert, I expect you just want to use -L.
12:56:41 <Cheery_> is yampa copyable or is it some kind of library?
12:56:42 <swiert> dcoutts: OK. Let me try.
12:57:17 <yip> Cheery_: it's a library
12:57:17 <yip> Cheery_: it is currently the state-of-the-art of functional reactive programming
12:57:39 <sproingie> monads i finally get, tho the syntax and usage of monad transformers still eludes me
12:57:39 <sproingie> i see a lift and i can't really tell what or why it's lifting
12:57:39 <sproingie> only that one may get bizarre errors otherwise
12:57:50 <swiert> dcoutts: Still doesn't work.
12:58:04 <Cheery_> sproingie: monad transformers are simple
12:58:15 <pejo> yip, there are other approaches "available" too.
12:58:29 <dcoutts> swiert, and you're linking with that lib? -lblah?
12:58:42 <Cheery_> sproingie: there's nice example of StateT in a 99beers
12:59:07 <sproingie> Cheery_: the idea is simple, sure, it's just putting them into use eludes me.  i just need practice i guess
12:59:19 <swiert> dcoutts: Ah. That'll be it.
12:59:26 <yip> pejo: well, there is the original haskell frp stuff, but i think that yampa is an improvement over it in all aspects. and then there is this javascript flapjax, but this doesn't seem to be real frp. there was also a paper about frp in lisp that i read a few weeks ago that seemed interesting
12:59:56 <Cheery_> > runStateT (put "x" >> lift (putStrLn "foobar") >> get)
12:59:58 <lambdabot>  <[Char] -> IO ([Char],[Char])>
13:00:04 <swiert> dcoutts: Now it can't locate file for -lRunScript
13:00:21 <Cheery_> > runStateT (put "x" >> lift (putStrLn "foobar") >> get) "y"
13:00:23 <lambdabot>  <IO ([Char],[Char])>
13:00:35 <dcoutts> swiert, that's what the -L. should be for, to tell the linker where to look for things you specify with -l
13:01:12 <swiert> dcoutts: that's what I thought... Let me mess around a bit.
13:01:14 <dcoutts> swiert, is this a framework or an ordinary lib?
13:01:32 <swiert> dcoutts: What's the difference?
13:01:39 <Cheery_> is it easy to use yampa in your software?
13:01:53 <swiert> dcoutts: Framework as in the Mac specific libs?
13:01:58 <dcoutts> swiert, dunno, frameworks are some macosx specific thing
13:02:02 <Cheery_> like, are you able to just blend it in somehow?
13:03:05 <pejo> yip, Nordlander's thesis, "Reactive Objects and Functional Programming".
13:03:15 <swiert> dcoutts: The C files I used needed to be compiled with -framework. Do you reckon I still need to call ghc with the same arguments?
13:03:26 <swiert> dcoutts: It shouldn't explain the problem.
13:03:59 <geezusfreeek> let me get this straight about yampa (first time really looking at it even though i've meant to for a while now)... the impression i'm getting of it so far is that it's a dataflow dsl. am i correct?
13:04:11 <yip> geezusfreeek: pretty much
13:04:20 <dcoutts> swiert, I don't know about frameworks, or if linking to them is much different but I know they're slightly different since ghc-pkg has a separate field for frameworks than ordinary libs
13:04:30 <geezusfreeek> okay good. then i won't get too confused :)
13:05:24 <dcoutts> swiert, check the ghc manual on frameworks
13:05:25 <swiert> dcoutts: Got it.
13:05:42 <swiert> swiert: It now links.
13:05:50 <dcoutts> oh good
13:05:51 <yip> pejo: is that the lisp paper?
13:05:59 <dcoutts> swiert, what was the trick then?
13:06:43 <swiert> I needed to rename the dynamic lib to libName.dylib as opposed to Name.dylib.
13:06:57 <ddarius> @google FatherTime FrTime
13:07:03 <swiert> It's something I'd compiled myself. I hadn't realised it needs the lib prefix.
13:07:03 <lambdabot> ftp://ftp.cs.brown.edu/pub/techreports/03/cs03-20.ps.Z
13:08:32 <pejo> yip, no, it's O'Haskell.
13:09:02 <yip> pejo: hm.... cool is it available for free online? can't seem to find it
13:09:22 <swiert> dcoutts: It works now. Thanks for all the pointers.
13:09:54 <dcoutts> swiert: np
13:10:25 <swiert> I can now execute AppleScript from Haskell, which is kind of cool.
13:11:15 <pejo> yip, discontinued since a bunch of years, but there's an interpreter based on Hugs available somewehre on www.cs.chalmers.se/~nordland
13:13:21 <Cheery_> @dice 1d6
13:13:21 <lambdabot> 1d6 => 4
13:13:24 <Cheery_> @dice 1d6
13:13:24 <lambdabot> 1d6 => 4
13:13:25 <Cheery_> @dice 1d6
13:13:26 <lambdabot> 1d6 => 3
13:13:27 <Cheery_> @dice 1d6
13:13:28 <lambdabot> 1d6 => 3
13:13:33 <Cheery_> >:G
13:13:35 <Cheery_> >:G
13:13:36 <Cheery_> @dice 1d6
13:13:37 <lambdabot> 1d6 => 1
13:13:47 <Cheery_> good
13:14:15 <kc5tja> @dice 1d6
13:14:16 <lambdabot> 1d6 => 1
13:14:18 <kc5tja> @dice 1d6
13:14:18 <lambdabot> 1d6 => 1
13:14:20 <kc5tja> @dice 1d6
13:14:21 <lambdabot> 1d6 => 1
13:14:27 <kc5tja> You know, technically, that IS random.
13:14:45 <Cheery_> @dice 1d6
13:14:45 <lambdabot> 1d6 => 4
13:14:49 <Cheery_> ...
13:14:51 <kc5tja> There is never any guarantee that any RNG would ever NOT return a sequence of numbers, so long as its distribution is even over a long enough period of time.  :)
13:15:13 * dmwit thinks of the Dilbert strip
13:15:36 <koala_man> 9.. 9.. 9..
13:15:48 <dmwit> That's the problem with randomness -- you can never tell. =P
13:15:54 <Cheery_> I guess I continue with patterns, drawing and nehe-tuts tomorrow
13:16:20 <osfameron> rosencntz and guildenstern are dead!
13:16:55 <dmwit> I'll bust a Capulet in yo' *** if you say that again!
13:17:56 <osfameron> even if i spell it correctly?
13:18:14 <osfameron> gorram stylus...
13:18:24 <shapr> golden
13:24:17 <lispy> actually, i think knuth has some methods in his TAoCP series about "detecting" randomness
13:24:49 <lispy> (but really, they're for determining the quality of a RNG)
13:25:56 <kc5tja> OK, chocolate chip cookies on an empty stomach is (a) giving me a caffeine headache (b) making me hungrier by the second (c) producing a sugar low from the last time I ate a small batch (d) all of the above.
13:26:55 <dmwit> :t ap
13:26:58 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:32:12 * ddarius considers buying ATTaPL.
13:34:09 <pejo> ddarius, it's well worth its money.
13:34:31 <lispy> what is the full title?
13:34:44 <_roconnor> instance RandomGen () where next () = (9,()); split () = ((),())
13:34:45 <ddarius> "Advanced Topics in Types and Programming Languages"
13:35:12 <lispy> ah hm, is it something to read after TaPL ?
13:35:36 <Heffalump> _roconnor: why 9
13:35:38 <Heffalump> ?
13:35:38 <ddarius> lispy: That's its intent.
13:36:03 <ddarius> @src () next
13:36:03 <lambdabot> Source not found. I feel much better now.
13:36:11 <dmwit> Heffalump: Why not?
13:36:13 <lispy> ddarius: cool, i should finish TaPL then :)
13:36:15 <Heffalump> fair point
13:36:28 <sorear> @src () succ
13:36:29 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
13:36:41 <sorear> oh, that next
13:37:11 <dmwit> ?instances ()
13:37:18 <Cheery> does BOB really say that?
13:37:19 <lambdabot> Couldn't find class `()'. Try @instances-importing
13:37:28 <dmwit> Oops, wrong direction.
13:37:39 <Cheery> (the old puny supermac)
13:37:52 <dmwit> Cheery: It may also be Microsoft BOB.
13:38:29 <Cheery> dmwit: I was referring to Microsoft BOB.
13:38:57 <geezusfreeek> is quickcheck just a brute force tester?
13:39:19 <Heffalump> geezusfreeek: yes
13:39:25 <Heffalump> albeit a cleverly designed one
13:39:30 <sorear> yes, but monte carlo (not exhaustive)
13:39:32 <ddarius> Their's another Bart Jacobs?
13:39:39 <sorear> @seen ndm
13:39:40 <lambdabot> I saw ndm leaving #haskell 8h 27m 10s ago, and .
13:39:50 <Cheery> you know, it'd be freaking fun if they'd get BOB back on the table in vienna.
13:40:06 <geezusfreeek> is there any automated way of proving that specifications are met in haskell programs?
13:40:21 <sorear> yes, FSVO automated
13:40:43 <sorear> Isabelle and two other systems whose names I forget support haskell
13:40:53 <Heffalump> Isabelle supports Haskell?
13:41:06 * sorear tries to find the logent
13:41:23 <Heffalump> google finds http://www4.in.tum.de/proj/theoremprov/stud/haskell_hol.html
13:41:25 <lambdabot> Title: Translating Haskell to Isabelle/HOL
13:41:32 <sorear> 07.04.23:20:15:21 <dons> Isabelle is pretty well established in haskell land though. as is twelf (to a lesser extent)
13:41:32 <sorear>  
13:41:38 <Heffalump> as well as some inconsiderate person named Isabelle Haskell.
13:42:32 <ddarius> Along that line, Yes, by construction.
13:42:55 * Saizan wants a meta-arbitrary, one that generates random data definitions..
13:43:38 <ddarius> Saizan: Easy, make a Arbitrary instance for (part of) TH.Syntax
13:43:47 <ddarius> Saizan: Why do you want that, though?
13:44:16 <Saizan> to test a typeclass derivation macro written in TH :)
13:45:00 <ddarius> Isn't this all just normal functions though?
13:45:37 <Saizan> ?
13:45:49 <Saizan> well in the end they are
13:45:59 <ddarius> TH only really comes in when you splice or quote.
13:46:16 <Saizan> yup, i'd like to test the spliced code
13:46:44 <sorear> Saizan: You could write a denotational-style interpreter!
13:46:58 <Saizan> denotational-style?
13:47:09 <UnusedNick> Hi, could someone tell me if theres a way to write a polymorphic type declaration?
13:47:14 <geezusfreeek> hmm... i think quickcheck looks a lot easier ;)
13:47:18 <sorear> UnusedNick: foobar :: a -> a
13:47:27 <sorear> any LOWERCASE symbol is a wildcard
13:47:39 <UnusedNick> Effectively I want to write        type Tab = Num a => Array (Int,Int) (a)
13:47:54 <sorear> Ick.
13:48:03 <UnusedNick> By type I meant type synonym
13:48:11 <sorear> type should not be used except in very simple cases
13:48:17 <sorear> it is extremely error prone
13:48:31 <UnusedNick> Its a bit late to go back now
13:48:43 <Saizan> that definition would mean something very different from what you need (probably)
13:48:47 <UnusedNick> I just want change this and hand the damn thing in
13:49:17 <Saizan> type Tab a = Array (Int,Int) a   and put the Num contraint on the functions
13:49:31 <Heffalump> UnusedNick: you can write that, but it probably won't do what you want
13:49:39 <Heffalump> you'll still need the Num constraint in the functions that uses it
13:49:39 <Saizan> foo :: Num a => Tab a -> etc..
13:49:42 <ddarius> "Error-prone"?
13:49:45 <UnusedNick> Ok, that looks right. Thanks
13:49:54 <sorear> ddarius: yeah
13:50:22 <sorear> ddarius: xmonad's internal state became corrupt when jcreigh mixed up type WorkspaceId = Int with type ScreenId = Int
13:50:37 <ddarius> Oh, you mean not as "type-safe".
13:50:37 <sorear> ddarius: they use newtypes now
13:50:43 <Heffalump> type leads to aliasing. Aliasing leads to suffering?
13:50:55 <ddarius> If we had type mutation!
13:51:01 <ddarius> mmm, type mutation...
13:51:07 <sorear> ddarius: type unsafety is a subtype of error proneness.  my statement stands?
13:52:14 <ddarius> sorear: That's not really "type unsafety", also it does not imply that the code is prone to errors, and finally it only applies when there are semantical reasons to differentiate two, otherwise undifferentiated, types.
13:53:16 <Saizan> i think it's beyond type-unsafety, with type Tab = Num a => Array (Int,Int) (a)  (and -fglasgow-exts)   IO Tab becomes something like IO (forall a. Num a => Array (Int,Int) a) right?
13:53:35 <ddarius> Saizan: In that particular case, it's mostly craziness.
13:53:47 <Cheery> hmm, I start slowly gaining conscious about arrows and yampa
13:54:30 <ddarius> Make sure arrows and yampa don't start slowly gaining conscious on you.
13:55:06 <Cheery> how?
13:55:21 <nominolo> hm, what is the preferred data structure for maps where any key
13:55:25 <nominolo> oops
13:55:52 <nominolo> (problem solved while typing, accidental RET)
13:56:08 <nominolo> :t flip Data.Map.lookup
13:56:17 <lambdabot> forall a a1 (m :: * -> *). (Ord a, Monad m) => M.Map a a1 -> a -> m a1
13:57:39 <ddarius> I usually beat things down when the start gaining consciousness.
13:58:22 <Cheery> I tend to let them loose
13:58:36 <Cheery> then they get out of control and out of ear
14:01:53 <dmwit> :t lift
14:01:57 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
14:02:16 <dmwit> ?src StateT lift
14:02:17 <lambdabot> Source not found. Wrong!  You cheating scum!
14:02:38 <dmwit> ?src Control.Monad.State.lift
14:02:39 <lambdabot> Source not found. The more you drive -- the dumber you get.
14:02:40 <tibbe> I think it would be cool if hackage showed download statistics
14:04:15 <sorear> Go ahead.  map succ "qnrr?rnh-bhsx-`b-tj"
14:04:47 <sorear> you have the power to suggest things!
14:08:16 <lispy> > map succ "qnrr?rnh-bhsx-`b-tj"
14:08:18 <lambdabot>  "ross@soi.city.ac.uk"
14:08:22 <lispy> oh sorry
14:08:32 <lispy> my bad
14:08:53 <lispy> sorear: i didn't realize you enciphered it for a reason like that...
14:09:04 <Maddas> now he'll have to change universities :-(
14:09:28 <Maddas> (Perhaps that should be ';-)')
14:09:32 <lispy> heh
14:09:40 <osfameron> succ?
14:09:46 <lispy> :t succ
14:09:48 <lambdabot> forall a. (Enum a) => a -> a
14:09:52 <lispy> > succ 1
14:09:54 <lambdabot>  2
14:09:59 <osfameron> ah
14:10:01 <lispy> successor
14:10:02 <Cheery> rot1
14:10:07 <dmwit> > map succ "this" -- suck that!
14:10:09 <lambdabot>  "uijt"
14:10:15 <lispy> > map pred "this"
14:10:17 <lambdabot>  "sghr"
14:10:42 <osfameron> and that works for enums!
14:11:08 <Cheery> > map (+30) "foo"
14:11:09 <lambdabot>   add an instance declaration for (Num Char)
14:11:10 <dmwit> > succ False
14:11:12 <lambdabot>  True
14:11:19 <Cheery> > pred True
14:11:21 <lambdabot>  False
14:11:30 <Cheery> > pref False
14:11:31 <lambdabot>   Not in scope: `pref'
14:11:34 <Cheery> > pred False
14:11:36 <lambdabot>  Exception: Prelude.Enum.Bool.pred: bad argument
14:11:47 <dmwit> > let add n = (!! n) . iterate succ in map (add 30) "foo"
14:11:48 <lambdabot>  "\132\141\141"
14:12:08 <Cheery> > (add 30) 'x'
14:12:09 <lambdabot>   Not in scope: `add'
14:12:20 <Cheery> uh ah
14:12:28 <osfameron> pesky scopes
14:12:59 <dmwit> > let add n = (!! n) . iterate succ in map (add 30) "FOO"
14:13:00 <Heffalump> FWIW, that email address appears on Ross's own webpage.
14:13:01 <lambdabot>  "dmm"
14:13:05 <sorear> too bad dons hasn't recompiled with the @let fix *rub rub taunt taunt*
14:13:10 <Heffalump> So I don't think leaking it onto the channel logs will matter much.
14:13:28 <lispy> oh, what explait did @let fix allow?
14:13:34 <lispy> exploit*
14:13:57 <sorear> lispy: no exploits, just b0rkenness
14:13:59 <sorear> @let x = 2
14:14:02 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
14:14:15 <sorear> the @let fix is the thing that makes @let work again ;)
14:14:19 <lispy> oh!
14:14:27 <lispy> i thought, you had something with @let fix = ...
14:14:33 <lispy> which caused some problems
14:17:39 <Cheery> wow, this yampa is nice thing
14:18:41 <Cheery> ?where yampa
14:18:42 <lambdabot> http://www.haskell.org/yampa/
14:20:01 <yip> yep. yampa is the functional programming answer to simulations. kind of like how parsec is the functional programming answer to parsers :)
14:20:34 <chessguy> hi haskellers
14:20:48 <Cheery> yip: and virtual worlds
14:21:04 <Cheery> I thought you can't generalize that deep.
14:21:26 <Cheery> ie. generalize all interactive stuff today represented into virtual worlds
14:21:50 <davidL> @where logs
14:21:50 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
14:22:03 <Cheery> gaung ta slooÃ¶
14:22:04 <yip> yampa still needs a lot more work though. FRAG is an awesome first person shooter game, but it's still not clear how one would add network play to it
14:22:37 <Cheery> yip: attracting
14:22:57 <Cheery> lets see how things would go. :)
14:23:12 <Cheery> (I have some ideas)
14:23:36 <Cheery> already now I have some ideas about how networking would go in such system
14:24:08 <Cheery> anyways, going to sleep
14:24:13 <yip> probably have an input and output signal for the network stream... but for some reason this doesn't feel good to me
14:24:20 <rmulliga> Cheery: Is there some explanation of yampa somewhere besides their main page?
14:24:35 <Cheery> this guy, yip gave one really good
14:24:51 <Cheery> or more like usage article
14:25:11 <rmulliga> link?
14:25:54 <Cheery> a mom
14:26:20 <Cheery> @google "yampa arcade"
14:26:23 <lambdabot> http://www.apocalypse.org/~antony/work/pubs/hw03.pdf
14:26:29 <Cheery> here you go.
14:27:23 <rmulliga> thank you
14:27:28 <Cheery> also found this, when looked further: http://www.thescripts.com/forum/thread135582.html
14:27:30 <lambdabot> Title: C++ sucks for games - C++
14:27:41 <Cheery> actually hilarious, I've known that for five years now.
14:29:11 <Cheery> gn
14:29:55 <sproingie> gawlly what possessed bjarne to join that thread?
14:30:50 <sproingie> i was hoping that was about how good FP is for games, but so far it's just mindless C++-bashing
14:35:31 <ddarius> I skipped to the middle randomly, and there is Kenny Tilton of c.l.l advocating FRP.
14:35:41 <yip> i don't like comparisons of OOP with FRP
14:35:47 <chessguy> hm, any reason to suspect that's the real Stroustrup?
14:36:09 <ddarius> That said, I stopped reading the page anyways.
14:37:22 <sproingie> it points to stroustrup's own page anyway
14:37:39 <sproingie> it's his typical sig
14:38:02 <chessguy> sounds pretty easy to fake
14:38:59 <sproingie> well that is comp.lang.c++
14:39:58 <chessguy> thanks for the clarification...
14:40:03 <sproingie> he's been known to post there, tho last i was there he wasn't much of a regular
14:42:36 <chessguy> uh-huh. and elvis has been sighted 14 times in the last month alone
15:03:40 <sorear> @botsnack
15:03:41 <lambdabot> :)
15:13:24 <Wallbraker> d
15:13:42 <shapr> f
15:14:18 <m4St3R_b41T3R> so long and thanks for all the fish
15:15:21 <sorear> Is GHC HEAD buildable again yet?
15:15:34 <dmwit> ?users
15:15:35 <lambdabot> Maximum users seen in #haskell: 335, currently: 300 (89.6%), active: 44 (14.7%)
15:16:45 --- mode: ChanServ set +o shapr
15:16:49 --- kick: m4St3R_b41T3R was kicked by shapr (Kicked by shapr)
15:16:50 * sorear would like to play with the cool new features but isn't keen on having $RANDOM_EXTRALIB fail due to -Wall -Werror idiocy
15:17:00 <sorear> shapr: why!?
15:17:18 <shapr> Because he's been told twice that nickname is inappropriate for #haskell.
15:17:20 <sorear> shapr: master_baiter, under various permutations, is a well behaved #haskell regular
15:17:35 <shapr> He's not actually a well behaved regular.
15:17:47 <shapr> He tends to post pictures from 4chan to the channel.
15:18:05 <sorear> I never noticed :(
15:18:05 <shapr> He's also known as reffie, reppie, Soulemain(?) Soulah(?), etc
15:18:06 <beelsebob_> yeh, that be not good
15:18:51 <der_eq> I have a C library that has a lot of pure functions in it, but they all require that a initializer function is called before using them. Is there an elegant solution for creating bindings for this?
15:19:00 --- kick: m4St3R_b41T3R was kicked by shapr (Kicked by shapr)
15:19:22 <lispy> shapr++
15:19:50 <shapr> sorear: He's never contributed positively to the discussion that I've seen.
15:19:53 <beelsebob_> let shapr = shapr + 1 in #haskell
15:20:00 <magnus> shapr: the examples folder in happs, are you planning to fix the examples? I fixed the hello world one I think but the others are still breaking
15:20:18 <magnus> breaking = not compiling
15:20:21 <shapr> magnus: Planning, yes :-)
15:20:53 <sorear> shapr: I seem to have missed all the instances where he contributed negatively. (this is not sarcasm; I am making escuses even though I trust you)
15:20:54 <magnus> that sounds very reassuring :)
15:21:05 <lispy> geez, the spammers are winning...i just had to visit a special website to be able to email this person...sigh
15:21:17 <shapr> sorear: Sure, I don't expect sarcasm. I often have to be told explicitly when something is sarcasm :-)
15:21:44 <sorear> hehe good :)
15:22:03 <beelsebob_> lispy: surely that's not winning?
15:22:08 <Maddas> lispy: How does this help the spammers?
15:22:12 <beelsebob_> Their aim is not to make email easy
15:22:20 <beelsebob_> s/easy/hard/
15:22:24 <lispy> it's proof that they are forcing US to change our behavior
15:22:24 <Maddas> right :-)
15:22:27 <lispy> to accomadate them
15:22:29 <midfield> hey any Data.Binary experts on?
15:22:34 <sorear> yeah
15:22:37 <Maddas> lispy: no, not to accomodate them :-)
15:22:39 <beelsebob_> lispy: not accommodate them
15:22:42 <beelsebob_> get rid of them
15:22:51 * Maddas will just let beelsebob_ do the talking from now on :-P
15:22:56 * sorear is a semi-expert, and dons/dcoutts (authors) will be waking up RST
15:22:58 <sorear> *RSN
15:23:04 <midfield> ok, this is a simple question
15:23:10 <beelsebob_> that would apply to terrorists because their aim is to make us change our behaviour
15:23:17 <beelsebob_> it does not apply to spammers though
15:23:25 <midfield> i want to create a giant list of random integers and spool it to disk
15:23:38 <midfield> so what's wrong with
15:23:46 <sorear> midfield: list serialization isn't lazy
15:23:52 <midfield> ah
15:23:58 <midfield> ok how do i make it fuse?
15:24:04 <sorear> midfield: since it uses length, and you can't know the length till you see the whole list
15:24:09 <midfield> what about deserialization?
15:24:22 <midfield> i guess the answer is the same
15:24:23 <sproingie> i don't bother obfuscating my email anymore.  it's out there, it's reasonably easy to get in a dictionary attack, it gets plenty of spam anyway
15:24:26 <midfield> drat!
15:24:30 <sorear> midfield: fusion has nothing to do with this - laziness makes operations run in lockstep
15:24:33 <sproingie> and i hardly see any of it because the spam filters are good
15:24:39 <sorear> midfield: no, deserialization should be lazy
15:24:56 <sorear> midfield: *but* you can always write your own lazy list serializer!
15:25:39 <midfield> sorear: seems rather difficult if the on disk format requires the length
15:26:06 <sorear> midfield: you can use a different format
15:27:11 <sorear> @pretty putListLazy [] = putWord8 0 ; putListLazy (x:xs)) = putWord8 1 >> put x >> putListLazy xs ; getListLazy = do { tag <- getWord8 ; case tag of { 0 -> return [] ; 1 -> liftM2 (:) get getListLazy } }
15:27:11 <lambdabot> "Parse error" at column 49
15:27:18 <sorear> @pretty putListLazy [] = putWord8 0 ; putListLazy (x:xs) = putWord8 1 >> put x >> putListLazy xs ; getListLazy = do { tag <- getWord8 ; case tag of { 0 -> return [] ; 1 -> liftM2 (:) get getListLazy } }
15:27:18 <lambdabot>  putListLazy [] = putWord8 0
15:27:19 <lambdabot>  putListLazy (x : xs) = putWord8 1 >> put x >> putListLazy xs
15:27:19 <lambdabot>  getListLazy = do tag <- getWord8
15:27:19 <lambdabot>                   case tag of
15:27:19 <lambdabot>                       0 -> return []
15:27:20 <lambdabot>                       1 -> liftM2 (:) get getListLazy
15:27:50 <sorear> you can also amortize the tag bits, a la LazyByteString
15:29:02 <midfield> i guess i can also create my own list type...
15:29:38 <midfield> i will look at lazybytestring, thanks
15:29:48 <araujo> Question here: Can i use a modified version of the Haskell Lambda logo for an application?
15:29:59 <jcreigh> sorear: geez, am I ever going to hear the last of that? :)
15:30:07 <araujo> shapr, there?
15:30:39 <sorear> jcreigh: No.  It makes a great example of what type synonyms can do even to masters.
15:30:53 <shapr> araujo: Yes!
15:31:03 <araujo> Hello shapr !
15:31:07 <shapr> hola araujo!
15:31:13 <araujo> shapr, any clue about my question?
15:31:14 <jcreigh> sorear: there were no type synonyms there...only Ints. But you are correct, "type" would not have helped us there.
15:31:22 <jcreigh> now we have newtypes, of course.
15:31:23 <sorear> wow, 4-way handshake!
15:31:29 <sorear> jcreigh: oops, sorry.
15:31:45 <shapr> araujo: http://www.scannedinavian.com/~shae/steve_atkins_monads/
15:31:47 <lambdabot> Title: Index of /~shae/steve_atkins_monads
15:31:56 <jcreigh> sorear: but it's still a good example of why newtype is a good idea.
15:32:21 <shapr> araujo: Long ago Steve Atkins wrote a step by step rewrite of manual parameter passing turned into monadic passing.
15:32:53 <shapr> araujo: One of his examples is something like a calculator that passes in the initial state and then passes it to each call after that.
15:33:02 <araujo> ooh
15:33:16 <araujo> shapr, hah, cool
15:34:22 <shapr> araujo: That sort of thing might be enough to show your readers how something can be pure but act just like it's not pure.
15:34:23 <sorear> araujo: kowey's new logo, or the nasty op-art old one?
15:34:48 <araujo> shapr, coold indeed
15:34:54 <araujo> sorear, the new one
15:35:17 <sorear> @seen kowey
15:35:18 <lambdabot> I saw kowey leaving #darcs and #haskell 2h 3m 54s ago, and .
15:35:28 * araujo now will think in a monad everytime he sees a calculator
15:36:10 <araujo> shapr, each of the file is an example?
15:36:51 <araujo> sorear, i will throw him a lambda when he is around then :-)
15:37:34 <sorear> araujo: * (del) (cur) 05:05, 20 April 2007 . . EricKow (2942 bytes) (A very simple logo emphasising functional (lambda) and typed (::). Public domain, do whatever you want. )
15:37:45 <araujo> oh, cool
15:37:50 <araujo> Thanks sorear
15:38:01 <shapr> araujo: each of the files is one step in a code-only monads tutorial.
15:38:16 <araujo> shapr, i see now
15:38:22 <midfield> sorear: if i create an end-terminate lazy list type like :   data LazyList a = Cons a (LazyList a) | Nil
15:38:29 <midfield> sorear: that should do me, right?
15:39:02 <sorear> midfield: you'd still have to write the equivalent of get/putListLazy, only in a type class
15:39:11 <sorear> but yes.
15:39:18 <midfield> sorear: right
15:39:45 <midfield> sorear: ok i'll try it out.  you gonna be on for a few minutes?  (btw thanks a bunch for helping me out here)
15:40:22 <sorear> midfield: people here often accuse me of being on 24/7. :)
15:40:38 <jcreigh> sorear is actually a very advanced AI.
15:40:45 <midfield> sorear: hah.  thanks
15:40:56 <sorear> er, well, except when the parents say "get your shoes on we're going to dinner."
15:40:58 <sorear> :(
15:41:02 <sorear> so, no.
15:45:15 <hpaste>  midfield pasted "lazylist" at http://hpaste.org/1608
15:45:34 <midfield> er whoops
15:45:47 <sorear>  data (Binary a) => LazyList a = Cons a (LazyList a) | Nil
15:45:52 <sorear> the context is a bad idea...
15:51:29 <midfield> soread: you mean just data LazyList a.... w/out the Binary a?
15:53:55 * monochrom drops a bomb to the glasgow-haskell-user mailing list.  Hahahahahaha....
15:56:17 <cdsmith> I'm trying to understand Pierce's book here.  Would you classify Haskell as having equ-recursive or iso-recursive types?
15:56:29 <cdsmith> s/equ/equi/ :)
15:57:52 <monochrom> @tell dcoutts I hope you enjoy my latest post that is beyond imagination (unthinkable) and beyond expression (wordless). :)
15:57:52 <lambdabot> Consider it noted.
15:57:57 <nominolo> > foldl mplus Nothing [Nothing, Just 1, Just 2, Nothing]
15:57:59 <lambdabot>  Just 1
15:58:38 <nominolo> > msum [Nothing, Just 1, Just 2, Nothing]
15:58:40 <lambdabot>  Just 1
15:58:58 <nominolo> > msum []
15:58:59 <lambdabot>   add an instance declaration for (Show (m a))
15:59:07 <nominolo> > msum [] :: Maybe Int
15:59:09 <lambdabot>  Nothing
16:01:17 <ddarius> cdsmith: iso
16:02:27 <cdsmith> ddarius: ah.  I would have guessed the opposite; in Pierce, iso-recursive types have fold/unfold operations that I don't see in Haskell.  What am I missing?
16:02:28 <nominolo> cdsmith: the fold/unfold is hidden in the case
16:02:47 <ddarius> What he said.  It's in the pattern matching.
16:02:52 <nominolo> cdsmith: it's stated a few pages later
16:03:38 <ekidd> Is it my imagination, or is programming.reddit.com starting to slip downhill a bit?
16:04:37 <monochrom> It's always up and down and up and down.
16:05:02 <cdsmith> So we're talking about something analogous to "In languages in the ML family, for example, every datatype definition implicitly introduces a recursive type." ?
16:05:51 <ekidd> monochrom: Heh. :-)
16:05:53 <dmwit> > msum [] :: Maybe a
16:05:55 <lambdabot>  Nothing
16:05:57 <cdsmith> I don't know ML at all -- which I realize is not good prep for reading this book -- but I can guess at what that means.
16:06:34 <ekidd> I've been noticing less really interesting content in the top 15 than there was a month or two ago, and a lot more aggressive down-voting in comment threads.
16:07:24 <monochrom> Watch for dons recommendations.  He picks good ones (and mentions them here) and he also posts some.
16:08:15 <ekidd> Oh, dons finds tons of cool stuff. It's just not scoring as high as it used to.
16:09:26 <cdsmith> nominolo and ddarius: Okay, I get it now!  It took a while to see that data is being treated as ALWAYS defining a recursive type.  Once that's clear, it makes sense that the data constructor is basically a fold.  Thanks a lot.
16:09:50 <midfield> sorear: if i have a lazylist of (normal) lists, can i get the first element of every list without fully deserializing every list?
16:10:06 <sproingie>  a data constructor is a fold?
16:10:14 * sproingie 's head asplodes
16:10:23 <cdsmith> sproingie: not in the sense of Haskell's fold function.
16:11:13 <cdsmith> sproingie: in the sense that it packs several values into a recursive type, and pattern matching unpacks them again.  It's just a different use for the same word.
16:13:29 <ddarius> English ambiguous?  Oh noes!
16:14:22 <cdsmith> So how do I get my head around ways that equi-recursive types would differ?
16:14:32 <midfield> drat.  anyone else up for Data.Binary questions?
16:16:41 <ddarius> cdsmith: As many of the following as you like: 1) use ocaml and it's -rec-types option 2) note that everytime you get a "unification makes an infinite type" (in GHC) error it would type check, and/or 3) note the occurs check in typical unification algorithms and/or play with cyclic data structures in Prolog
16:16:52 <ddarius> (No one ever implements the occurs check in Prolog)
16:18:36 <cdsmith> ddarius: interesting; I've never seen that error in GHC; I shall make it my mission to reproduce it, now.
16:18:37 <ddarius> cdsmith: While very occasionally handy, equi-recursive types are more a bad idea than a good idea, unless you control their use.
16:18:45 <ddarius> cdsmith: It's actually pretty common.
16:19:05 <cdsmith> ddarius: is it the same thing as "cannot construct infinite type ..."?
16:19:20 <ddarius> That's the one.
16:19:50 <cdsmith> ddarius: ah, so I have seen it; but always when I screwed up something else.  It will be interesting to try to produce it for its own sake.
16:20:02 <mauke> > join (:) 'x'
16:20:03 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
16:20:03 <lambdabot>       Expected...
16:20:47 <mauke> > join id
16:20:48 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a1
16:20:48 <lambdabot>     Probab...
16:20:57 <ddarius> cdsmith: Indeed. That's why uncontrolled inference of equi-recursive types is a bad idea.  Most of the time, infinite types are type errors.  Many things become type checkable in the presence of equi-recursive types.
16:22:08 <cdsmith> ddarius: thanks (and mauke, too).  I will play around with this, then, and try to understand better.
16:23:36 * qwr isn't very convinced... i've had occurs check errors quite rarely. mostly when i really wanted recursive type...
16:23:53 * ddarius brands qwr as weird.
16:24:24 <procyon112> What really is the difference between Parsec and ReadP?  I need to parse a little string, like "a->(Int->b)->Int->a->b" into Var 0 :> (Con "Int" :> Var 1) :> Con "Int" :> Var 0 :> Var 1 and I'm deciding which one to use.
16:24:33 <sproingie> while we're on types, anyone got a 50-words-or-less explanation of the monomorphism restriction?
16:24:46 <sproingie> the wiki page leaves me more confused than before
16:26:52 <ddarius> f = \x -> bigcomputation, obviously f 2 and f 3 can't share the result of bigcomputation, f :: B a is f = /\a. ... so the same problem comes up.  I.e. you lose sharing if you a polymorphic value.  This may be unexpected, so the Haskell committee decided to add the monomorphism restriction to avoid this.
16:27:22 <ddarius> Note, this explanation is only for why the monomorphism restriction is where it is not needed.  There are other places where it's there because it needs to be.
16:27:40 <sproingie> i ran into it in a haskell tutorial once, and i knew that it was the restriction, i just couldn't put my finger on what it was :)
16:28:08 <sproingie> aha, in here: http://sigfpe.blogspot.com/2006/05/grok-haskell-monad-transformers.html
16:28:11 <lambdabot> Title: A Neighborhood of Infinity: Grok Haskell Monad Transformers, http://tinyurl.com/y6w3jr
16:28:48 <sproingie> test3 and test7 are exactly the same.  but when i tried to have go7 use test3 instead, it errored.  unless i used -fno-monomorphism-restriction
16:29:14 <cdsmith> sproingie: e.g., "module TestMR where f = return 5" is invalid without a type signature, because it means different things depending on what monad you use.
16:30:19 <sproingie> so basically, if something gets an inferred type that's more specific than you intended and you try to call it with a different type than you did the first time ...
16:30:25 <sproingie> that's the monomorphism restriction?
16:30:55 <mauke> no, calling it doesn't matter
16:31:17 <mauke> it's that something that looks like a constant isn't
16:31:18 <cdsmith> sproingie: No; the type system (with normal Haskell 98 stuff anyway) always infers the most general possible type.  The MR is when the type is inferred, and the compiler makes a deliberate choice to give you an error instead of go on sing that type.
16:32:32 <sproingie> ok .. so are there negative implications to disabling the MR?
16:32:41 <sproingie> other than being nonstandard?
16:32:42 <ddarius> cdsmith: Actually, the compiler will try to give it some monomorphic type (usually depending on how it's used in the module).
16:33:00 <ddarius> sproingie: It's about as non-standard as the heirarchical modules extension.
16:33:14 <sproingie> standard enough then
16:33:18 <ddarius> sproingie: But I mentioned it above, you may "unexpectedly" lose sharing.
16:33:24 <mauke> sproingie: I never hit the MR because I always use explicit type annotations
16:33:52 <sproingie> mauke: yah, i'm learning it's easier yet to start with them before i even know how to write it
16:33:52 <cdsmith> sproingie: like in my example above... if you say "head f", then the type of f is coerced to [a].  If you say "fromJust f", its type will be (Maybe a).  These are completely different things, and someone felt that it's confusing if a simple name like "f" can mean both depending on context.
16:34:02 <procyon112> sproingie: the MR's on purpose, because it's difficult to spot the fact that something can't be shared.  This can have HUGE implications on speed, so the MR protects you by warning you that what your doing is possibly going to make you go real slow.
16:34:04 <ddarius> http://haskell.org/nhc98/bugs.html
16:34:05 <lambdabot> Title: Known bugs in nhc98
16:34:10 <sproingie> er start with annotations before i know how to write the function
16:35:25 <cdsmith> ddarius: thanks for the correction
16:36:27 <sproingie> cool, that definitely makes the MR clear now.  thanks all for the expanations :)
16:38:39 <ddarius> The feeling (as far as I can tell) is mostly that the monomorphism restriction is a problem for beginners more than it is a help to more experienced users.
16:39:40 <sproingie> perhaps it should be downgraded to a warning
16:40:54 <cdsmith> sproingie: some clarification on the web site you linked to above.  The reason that changing go7 to use test3 broke the code is just that test7 isn't used  any more; therefore the compiler doesn't know which type to give to test7.  None of the code you were still actually using is wrong at all.
16:42:28 <cdsmith> sproingie: no, I take that back.  I'm wrong
16:42:30 <sproingie> but it did work when i turned on -fno-monomorphism-restriction
16:42:42 <cdsmith> sproingie: yes, it's all about the MR
16:43:22 <procyon112> sproingie: It's not really just for beginners.  It really is hard to spot sometimes, and it can make your O(n) algorithm into an O(n^2) pretty easily.  But yeah, it might be better if it was a warning.
16:44:08 <sproingie> i was mystified for a couple minutes, then i remembered the MR from ocaml
16:44:26 <cdsmith> sproingie: at first, I thought both uses of test3 had the same type; but they don't.  so you'd still need to add a type annotation to test3, or use -fno-monomorphism-restriction to turn it off, even if test7 wasn't there.
16:44:32 <sproingie> i can see how a complete beginner would be baffled
16:46:51 <cdsmith> I agree that a warning would be good.  That seems to strike the right balance.  Very few people ignore warnings or leave them in production code anyway; but it's nice to know that at least the code works and can be improved; rather than just failing entirely.
16:47:37 <sproingie> and there's always -Werror for people who don't want to ignore them
16:47:50 <sproingie> i often turn that on in my projects
16:48:02 <sproingie> C anyway.  i can't avoid it in most C++ projects
16:48:48 <cdsmith> sproingie: Actually, I've never understood the point.  You can be obsessive about fixing warnings without telling the compiler to be mean about it.  To each their own, I guess.
16:49:28 <sproingie> well the reason being that if you let it go, you won't see it the second time you hit 'make'
16:50:24 <cdsmith> cdsmith: Okay, makes sense then.  I always get this icky feeling with warnings anyway that won't go away until I can doa  clean build from scratch... so there's very little danger I'll forget! :)
16:50:25 --- mode: ChanServ set +b m4St3R_b41T3R*!*@*
16:50:56 <sproingie> that was fast
16:51:05 <sorear> hello.
16:53:36 <cdsmith> is haskell.org not working for anyone else?
16:53:50 <midfield> ah sorear!
16:53:53 <mauke> Firefox can't establish a connection to the server at haskell.org.
16:54:05 <falconair> it comes up for me
16:54:11 <cdsmith> Okay, back now I guess
16:54:24 <procyon112> cdsmith: And it's generally ALWAYS a good idea to have warnings as error on in an official build server, to enforce a policy that you ship with no warnings.
16:54:25 <midfield> sorear: it looks like even with the lazylist i'm getting screwed.  true or false: data.binary never seeks?
16:54:29 <sproingie> yah it burped for me too
16:55:24 <davidL> where's a good place in the midwest area to escape to for studying for a final?
16:55:28 <SamB_XP> midfield: I was pretty sure the new Data.Binary worked on Data.ByteString.Lazy
16:55:59 <sorear> midfield: true.  data.binary never ever seeks.
16:55:59 <sorear> procyon112: ReadP doesn't do error messages.  At all.
16:55:59 <sorear> procyon112: if your input is coming from a falabble user, use Parsec!
16:56:08 <midfield> SamB_XP: yes, but my question is, can i read the second element of a list before deserializing the first.
16:56:39 <SamB_XP> midfield: it would deserialize both
16:56:42 <midfield> sorear: drat!
16:57:06 <SamB_XP> midfield: there is something that does seek if you want that
16:57:12 <SamB_XP> ndm wrote it
16:57:13 <procyon112> sorear: Thanks :)  The input is actually coming from a compiled module file, but I'll use parsec to make error reporting better anyway.
16:57:18 <midfield> Data.Binary.Defer?
16:57:19 <SamB_XP> it probably is not threadsafe though
16:57:24 <SamB_XP> midfield: yeah, that
16:58:07 <procyon112> sorear: It's not performance critical (It only needs to do the strings once), so Parsec it is.
16:58:14 <midfield> SamB_XP: yeah, it seeks, but i think it only seeks on lists with fixed-sized elements
16:58:27 <SamB_XP> midfield: no...
16:59:43 <midfield> SamB_XP: ah i see, the ListDefer works only with BinaryDeferStatic, but i could again use the LazyList thing i made.....
16:59:53 <midfield> SamB_XP: thanks.  i'll try that
17:01:03 <cdsmith> @pl \x -> (x,0)
17:01:03 <lambdabot> flip (,) 0
17:01:09 <cdsmith> Oh, duh!
17:01:16 * SamB_XP digs about
17:03:07 <mdmkolbe-home> @type ((,)0)
17:03:10 <lambdabot> forall t b. (Num t) => b -> (t, b)
17:03:24 <sorear> procyon112: [re warnings as error] -Wall -Werror is very bad - -Wmonomorphism-restriction was added several days ago and ghc *still* doesn't compile without errors.
17:03:42 <sorear> procyon112: ... because the MR didn't used to trigger a warning!
17:03:48 <SamB_XP> midfield: I think you want to use [Defer a]
17:03:55 <SamB_XP> where a is whatever you have in your list
17:06:26 <hpaste>  midfield pasted "BinaryDefer" at http://hpaste.org/1609
17:06:39 <procyon112> sorear: Every released product I've worked on had a policy of releasing with zero warnings.  Warnings were considered a severity 1 bug and hence a showstopper.  Personally, I think that's a good practice for released code.
17:07:13 <midfield> SamB_XP: i think this means that it is eager on serialization, and perhaps lazy on deserialization
17:07:29 <midfield> SamB_XP: like Data.Binary
17:07:53 <SamB_XP> Data.Binary is only lazy when you use the data in order, though
17:08:17 <midfield> SamB_XP: i need to be lazy on serialization too.  so off to make my on cons cells...
17:08:24 <procyon112> sorear: At Microsoft, we have an additional policy: The build server runs a linter on the code, and the build breaks if the linter emits a warning... I think that's a bit TOO hardcore, but it does catch some bugs.
17:08:24 <mdmkolbe-home> procyon112: that is genarally only true for warnings that appear due to public headers (i.e. one should never introduce warnings into the code of someone who uses your (pre-compiled) library simply by the fact that they must use your headers)
17:08:34 <SamB_XP> midfield: you *can't* be lazy on serialization!
17:08:53 <SamB_XP> or, well, not much.
17:09:03 <midfield> SamB_XP: why not?  i can spool to disk as the cells come to me.  i did it with Data.Binary....
17:09:14 <mdmkolbe-home> generally == on some open source projects they generally believe
17:09:22 <SamB_XP> oh, you mean that "length" call?
17:09:22 * mdmkolbe-home personal likes being warning pure
17:09:29 <SamB_XP> hmm, I see what you mean.
17:09:34 <mdmkolbe-home> s/personal/personally/
17:09:35 <midfield> SamB_XP: yeah, that's the problem
17:10:04 <sorear> SamB_XP: sure you can!
17:10:04 <sorear> SamB_XP: show [1..]
17:10:04 <sorear> SamB_XP: starts to produce bits before the list is done evaluating!
17:10:09 <sorear> procyon112: what do you do when Foosoft upgrades the linter?
17:10:13 <sorear> procyon112: scramble to fix all half-billion broken builds in the company?
17:10:29 <SamB_XP> sorear: I didn't get what he meant by "lazy on serialization"
17:10:34 <SamB_XP> now I do
17:10:35 <sorear> Grumble!
17:10:42 <SamB_XP> and I agree that he can do that easily
17:11:25 <SamB_XP> all *I* meant is that you can't put thunks in a file
17:12:12 <ddarius> Sure you could, but that would probably be less space efficient than actually storing the values in most cases.
17:12:28 <procyon112> sorear: It's really all about how hardcore your team is about them.  I like to develop code with warnings off, and then after it's working, go fix the warnings as part of my spit and polish phase, and finally, the build server enforces that I finished my spitting and polishing.
17:12:42 <SamB_XP> ddarius: not in standard Haskell you can't
17:13:01 <sorear> procyon112: I mean, doesn't it give you a major disruption when a new warning is added?
17:13:29 <procyon112> sorear: Yup.. when Foosoft upgrades the linter, we scramble... It's a pain.
17:13:35 <SamB_XP> sorear: well, probably you wan't to select some specific set of warnings...
17:13:54 <sorear> <sorear> procyon112: [re warnings as error] -Wall -Werror is very bad -
17:14:07 <sorear> my very first comment specified -Wall
17:14:16 <SamB_XP> hmm.
17:14:29 <SamB_XP> well, -Wall is actually not all of the warnings
17:15:47 <procyon112> sorear: The MS linter is very configurable though, and each warning can be turned on or off.  If a particular one is bothersome, we look for the justification behind it and if it's not a big deal we may shut off that 1 warning (it uses a rules file), but such a choice is not made lightly.
17:18:01 <mdmkolbe-home> procyon112: how many warnings is GHC generating with -Wall?
17:18:24 <procyon112> sorear: But we do our development in C++ (Bad, C-style C++ and we eschew exceptions and the standard library), so there is nothing buffering us from errors at all except warnings, and an ignored warning is often one more buffer overflow attack.
17:18:55 <procyon112> mdmkolbe-home: I have no idea.. Sorear says it's got a bunch.
17:19:14 <sorear> mdmkolbe-home: not that it has a lot, but that it changes.
17:19:33 <sorear> mdmkolbe-home: last week ghchq added a warning for the monomorphism restriction
17:19:46 <SamB_XP> sorear: to -Wall?
17:19:51 <sorear> mdmkolbe-home: so now half the libraries fail to build, because they use -Wall -Werror
17:19:59 <sorear> SamB_XP: by default even!
17:20:06 <SamB_XP> ... oh.
17:20:40 <SamB_XP> maybe they ought to make it a never-fatal warning?
17:20:48 <sorear> I'd like to be pinged when a fresh GHC tree next becomes buildable :(
17:21:47 * SamB_XP goes to play Dune II
17:22:41 <procyon112> SamB_XP: I hate never-fatal warnings.... That totally blows the point of -Werror.  You can choose to use -Werror or not, but you have no choice if you make it never-fatal.  Better solution might be to give warnings a priority and do a -We0, -We1, -We2, etc..
17:23:09 <SamB_XP> hmm.
17:25:07 <procyon112> sorear: I agree that forcing -Werror on the user is stupid... It should always be a build command line option, or environment variable. Particularly in Open source projects where everyone is compiling your code.
17:25:46 <mdmkolbe-home> procyon112: or maybe let each warning be set to one of three levels: off (e.g. -Wno-blah), on (-Wblah), error (-Werror-blah)?
17:25:56 <procyon112> sorear: everything I've said is my opinion fo Binary releases, just to qualify :)
17:27:13 <procyon112> mdmkolbe-home: Yeah, that would work too :)
17:31:06 <petekaz> Got a question again ... reading about monad transformers, before ReaderT existed, how would one manually use Reader and IO at the same time?  I'm trying to write a small example, but I am stuck.  Can one do this?
17:31:35 <hpaste>  petekaz pasted "can this be done without monad transformers?" at http://hpaste.org/1610
17:31:46 <ddarius> Um, you could explicitly use environment passing... or you could just implement ReaderT or a ReaderIO monad.
17:31:51 <ddarius> @src ReaderT
17:31:51 <lambdabot> Source not found. I feel much better now.
17:32:09 <ddarius> @src Control.Monad.Reader.ReaderT
17:32:09 <lambdabot> Source not found. My pet ferret can type better than you!
17:32:52 <ddarius> petekaz: You do realize that that code doesn't use monad transformers at all, right?
17:33:01 <petekaz> ReaderT is a monad transformer though.  I understand how it can be done using that.  I'm just trying to understand how it was done before transformers.
17:33:20 <petekaz> ddarius: yes, that is the point.
17:33:47 <ddarius> I'm not really clear on what you want to do.
17:34:21 <petekaz> I know how to use ReaderT, its in the tutorial I'm reading now.
17:34:23 <ddarius> Or why you want to do what you want to do they way you want to do it.
17:34:25 <mdmkolbe-home> @src Control.Monad.Reader.Lazy.ReaderT
17:34:25 <lambdabot> Source not found. You speak an infinite deal of nothing
17:34:47 <petekaz> I was under the impression there were alternatives to monad transformers based on someone's comments in here.
17:35:13 <ddarius> There are a variety of other things you could do, but when monad transformers fit...
17:35:36 <ddarius> @google "Composing Monads"
17:35:41 <lambdabot> http://citeseer.ist.psu.edu/jones93composing.html
17:35:41 <lambdabot> Title: Composing Monads - Mark, Duponcheel, December (ResearchIndex)
17:35:43 <sproingie> > repeat Nothing
17:35:45 <lambdabot>  [Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Not...
17:35:48 <ddarius> @google "Coproducts of Monads"
17:35:48 <petekaz> So I was curious what those other "manual" methods were?  I.e. so I can compare and contrast how useful monad transformers are.
17:35:50 <lambdabot> http://www.cs.nott.ac.uk/~nxg/papers/tia04.ps.gz
17:35:51 <sproingie> that's an infinite deal of nothing
17:36:00 <mdmkolbe-home> petekaz: the only alternative I know is to build a mega monad.  For example I could write a monad that is both a reader and a state at the same time, but it's a pain to do and takes a bit of artistry to do right
17:36:12 <ddarius> petekaz: The "manual" method for the reader monad is simply to pass the argument in itself.
17:36:32 <petekaz> ddarius: I'm only asking to educate myself, I understand that transformers fit most of the time.
17:36:43 <mdmkolbe-home> petekaz: if we take IO out of the picture it becomes much easier
17:36:44 <ddarius> I.e. processFile :: String -> Int -> IO [String]
17:37:02 * mdmkolbe-home writes a reader/state monad for petekaz
17:37:08 <ddarius> Which is exactly what processFile :: String -> ReaderT Int IO [String] would expand to modulo a newtype.
17:37:20 <petekaz> mdmkolbe-home: ok ... thanks.  I must have misinterpreted what I thought I heard someone here say a few days ago.
17:37:42 <hpaste>  mauke annotated "can this be done without monad transformers?" with "at least it typechecks" at http://hpaste.org/1610#a1
17:37:43 <sorear> petekaz: what people used to do is write combined monads, like RWS
17:37:57 <mauke> petekaz: ^
17:38:01 <sorear> petekaz: of course you can't do that with abstract monads like IO!
17:38:35 <ddarius> Mostly people write type MyMonad a = stack of monad transformers in those cases.
17:38:40 <mdmkolbe-home> petekaz: the type for a reader state monad would be something like this: data ReaderState s r a = ReaderState (s -> r -> (s, a))
17:39:23 <petekaz> mauke: interesting ... for some reason I thought I always had to have IO on the outside.
17:39:48 <petekaz> mauke: but that is exactly what I was trying to accomplish.
17:39:52 <ddarius> mauke: Actually, you always have IO on the "inside" (if at all).  There is no IOT
17:40:40 <ddarius> petekaz: "Bottom" is probably the better way to think about it rather than "inside"/"outside".  You always have to have IO on the bottom with other stuff stacked on top.
17:41:15 <mauke> petekaz: it becomes really obvious if you think of Reader a b as (a -> b)
17:41:32 <ddarius> @src Reader
17:41:32 <lambdabot> Source not found. Wrong!  You cheating scum!
17:41:52 <mauke> @source Control.Monad.Reader
17:41:52 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
17:41:53 <petekaz> mauke: with your example, I now have something to constrast to using ReaderT to do the same thing.
17:42:20 <petekaz> mauke: I don't understand what you mean by "if you think ..." comment.
17:42:42 <petekaz> oh nevermind.
17:42:53 <mauke> 'processFile :: String -> Reader Int (IO [String])' expands to 'processFile :: String -> Int -> IO [String]'
17:43:20 <petekaz> ahh.
17:43:34 <hpaste>  mdmkolbe annotated "can this be done without monad transformers?" with "Rough example showing Reader and State without transformers" at http://hpaste.org/1610#a2
17:43:43 <ddarius> Which happens to be exactly what processFile :: String -> ReaderT Int IO [String] expands to as well
17:44:11 <petekaz> presumably the ReaderT version would look nicer than the non ReaderT version?
17:44:42 <mdmkolbe-home> petekaz: the client code should be the same, only the top level call should be different
17:44:51 <mauke> what's the opposite of "behead"?
17:45:07 <petekaz> mdmkolbe-home: I understand your point, manually splicing the monads together, but in this case because of IO, this does not apply, correct?
17:45:10 <mdmkolbe-home> mauke: de-foot?
17:45:15 <mauke> heh
17:45:15 <ddarius> petekaz: With ReaderT, (>>=) works on "both" monads at the same time, with Reader (>>=) is only for the Reader and you are "returning" an IO action.
17:45:59 <petekaz> What does at the same time mean though?
17:46:00 <mauke> "enheaden"?
17:46:17 <mdmkolbe-home> petekaz: that is provided that you never reference the actual monad in the client code. (i.e. functions should have signatures like: foo :: (ReaderMonad r m, StateMonad s m) => Int -> m Int)
17:47:01 <mdmkolbe-home> mauke: "cons"?
17:47:18 <mdmkolbe-home> mauke: "rehead"?
17:47:44 <petekaz> So where does this 'lift' function come into play?
17:48:03 <ddarius> :t putStr
17:48:05 <lambdabot> String -> IO ()
17:48:24 <petekaz> And what would a ReaderT version of my code look like?
17:49:15 <mdmkolbe-home> petekaz: since a monad transformer could operate on *any* other monad, it needs a way for you to lift the operators that the contained monad uses to work after it has been transformed.  This is what lift does.
17:49:56 <mauke> petekaz: change 'runReader' to 'runReaderT' and 'return $ do' to 'lift $ do'
17:50:13 <petekaz> That was easy.
17:50:14 <mdmkolbe-home> petekaz: for example, with a ReaderT r (State s a), you couldn't use State's 'get' (*see note) so you would have to use 'lift get'.
17:50:33 <petekaz> So I guess I'm still missing the value of the transformer vs non-transformer method.
17:50:51 <petekaz> mdmkolbe-home: I see.
17:51:00 <hpaste>  ddarius annotated "can this be done without monad transformers?" with "ReaderT" at http://hpaste.org/1610#a3
17:51:09 <petekaz> mdmkolbe-home: that seems fragile if you change the order of the monads.
17:51:29 <ddarius> petekaz: It is.  Which is why we use MonadReader and such
17:51:34 <mdmkolbe-home> petekaz: *note: most of the monad transformers provide pre-lifted instanced for the standards classes.  So the ReaderT might have an 'instance (MonadState s m) => MonadState (ReaderT (m s)) where get = lift get ...'
17:51:40 <ddarius> Those will magically infer the correct amount of lifts.
17:51:46 <petekaz> ddarius: not familiar with MonadReader.
17:52:12 <petekaz> mdmkolbe-home: nice.
17:52:50 <petekaz> but if you have several monads nested, would that work?
17:52:57 <mdmkolbe-home> petekaz: yep
17:53:18 <petekaz> What if you have two ReaderTs?
17:53:24 <mdmkolbe-home> petekaz: e.g. the writerT gets the 'get' from readerT wich gets it from the state
17:53:27 <petekaz> what would happen then?
17:53:38 <mdmkolbe-home> petekaz: two readerT's will break
17:53:39 <petekaz> mdmkolbe-home: ah ... that makes sense.
17:54:15 <ddarius> It may still work if they have different environment types.
17:54:23 <mdmkolbe-home> petekaz: to do two readerT's you might be able to do explicit lifts, but I'm not sure
17:54:50 <ddarius> But it is very rare to need or want to have two of the same transformers in a stack.
17:55:34 <mdmkolbe-home> petekaz: like ddarius says, usually if you want two transformers in the same stack then you can just combine them and make them one
17:55:40 <petekaz> right.
17:55:52 <dolio> > runReaderT (runReader (do { a <- get ; b <- get ; return (b ++ show (a + 1 :: Int)) }) 1) "Foo:"
17:55:54 <lambdabot>  Couldn't match expected type `ReaderT r m a'
17:56:09 <petekaz> So what is the value of the transformer vs non-transformer method of this particular example?
17:56:17 <petekaz> can one be extended much easier than the other?
17:57:07 <ddarius> petekaz: In this particular example, I'd just pass in the argument as normal.
17:57:16 <petekaz> ddarius: of course.
17:57:18 <mdmkolbe-home> petekaz: in general it is a good idea for client monadic code to try to be as 'class'ic as possible otherwise these things get very fragile (i.e. make classes for getEnv, getCounter, setMode, etc.)
17:57:55 <ddarius> You almost always want monad transformers because you want all the "effects" occurring together.
17:57:57 <petekaz> mdmkolbe-home: not sure I understand.
17:58:05 <dolio> > runReader (runReaderT (do { a <- ask ; b <- lift ask ; return (b ++ show (a + 2 :: Int)) }) 1) "Foo:" -- There we are.
17:58:07 <lambdabot>  "Foo:3"
17:58:33 <petekaz> dolio: neat.
17:58:35 <dolio> mdmkolbe-home: Needs explicit lifting.
17:58:42 <ddarius> dolio: The question is is the lift necessary
17:58:50 <petekaz> dolio: so this would be considered very fragile though.
17:59:00 <petekaz> dolio: that was a question.
17:59:03 <dfranke> I'm trying to learn the Scrap Your Boilerplate extensions.  What should I start by reading?
17:59:13 <ddarius> > runReader (runReaderT (do a <- ask; b <- ask; return (b ++ show (a + 1 :: Int));) 1) "Bar"
17:59:14 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Int'
17:59:22 <ddarius> And, apparently, it is.
17:59:32 <mdmkolbe-home> dfranke: have you read the SYB papers yet?
17:59:44 <sproingie> @info syb
17:59:44 <lambdabot> syb
17:59:47 <dfranke> mdmkolbe-home, no, is that where I should start?
17:59:47 <ddarius> dfranke: ? It isn't an extension.  It is a library.  Or do you mean the extensions it uses?
17:59:51 <dolio> ddarius: It does, currently. I don't think there are appropriate instances for reader-wrapped-in-reader to automatically lift.
18:00:08 <sproingie> hm.  what's the bot incantation to get a factoid again?
18:00:15 <ddarius> @instance MonadReader
18:00:15 <lambdabot> Maybe you meant: instances instances-importing
18:00:21 <ddarius> @fact syb
18:00:21 <lambdabot> I know nothing about syb
18:00:23 <dolio> ddarius: Although it may be possible to write them.
18:00:24 <ddarius> @where syb
18:00:25 <lambdabot> I know nothing about syb.
18:00:34 <ddarius> @instances MonadReader
18:00:34 <mdmkolbe-home> dfranke: yes, but realize that most of the code has been completely refactored in the current GHC.  but the ideas transfer fairly well.  Plus the SYB papers are a good read
18:00:35 <lambdabot> r ((->) r), r (ErrorT e m), r (RWS r w s), r (RWST r w s m), r (Reader r), r (ReaderT r m), r (StateT s m), r (WriterT w m), r' (ContT r m)
18:00:46 <ddarius> dolio: It's there.
18:00:48 <dfranke> mdmkolbe-home, ok, thanks.
18:00:55 <mdmkolbe-home> grr ... anyone know if IO has a class for it?
18:01:05 <ddarius> @src MonadIO
18:01:05 <lambdabot> Source not found. My pet ferret can type better than you!
18:01:10 <ddarius> @index MonadIO
18:01:11 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
18:01:12 <Philippa> there's only one for liftIO
18:01:44 <ddarius> There isn't a class containing things like putStr and such in the "standard" libraries.
18:01:57 <ddarius> @info Control.Monad.Trans.MonadIO
18:01:57 <lambdabot> Control.Monad.Trans.MonadIO
18:02:02 <ddarius> Very helpful.
18:02:27 <ddarius> Freakin' "spell-checker".
18:03:02 <petekaz> ddarius: what is that?
18:03:11 <sproingie> @info seems to be an alias for "echo"
18:03:11 <lambdabot> seems to be an alias for "echo"
18:03:17 <sproingie> i rest my case
18:03:21 <dolio> ddarius: There's "MonadReader r (ReaderT r m)" but is there "MonadReader q m => MonadReader q (ReaderT r m)"?
18:03:29 <petekaz> I am looking at the GHC doc page, but I find all of the Control.Monad.* pages next to useless.
18:03:58 <ddarius> @oldwiki MonadTransformerLibrary
18:03:58 <lambdabot> http://www.haskell.org/hawiki/MonadTransformerLibrary
18:04:13 <mauke> @eval rm -rf /
18:04:15 <ddarius> http://www.haskell.org/hawiki/MonadTemplateLibrary
18:04:16 <lambdabot> Title: MonadTemplateLibrary - The Haskell Wiki
18:04:58 <dolio> ddarius: I don't think it's there, because it'd overlap in the case where q = r.
18:05:19 <sorear> mauke: eval is a noop command!
18:05:21 <mdmkolbe-home> petekaz: hmm, this doesn't work so well b/c IO dosn't have the kind of class I'd like it to have, but what I means was that something like your processFile shouldn't have the Reader monad explicitly in the signature b/c you might add another monad to the stack at a later time.  Instead use the ReaderMonad *class* to ensure that whatever monad is used, it simply must support the proper ReaderMonad operations.
18:07:19 <petekaz> mdmkolbe-home: hmm ... I see.
18:07:53 <petekaz> so no matter how many transformers I have stacked, it will always match the ReaderMonad class?
18:07:59 <mdmkolbe-home> petekaz: extending this idea, you might add more information to the reader part of the reader monad that you are using, so instead of using 'ask' and 'local' you may want to make versions like 'askScope = fst . ask' and 'askDir = snd . ask' so that if you ever add more to the reader, then you only have to change one place.  (Whether these extra asks are put in a class is up to you/debatable)
18:08:32 <mdmkolbe-home> petekaz: yes as long as they are standards monads that have done the pre-lifting for you and there is only one reader in it
18:08:52 <ddarius> And by fst . ask you probably mean asks fst
18:09:20 <mdmkolbe-home> ddarius: yeah, I guess that's the same thing
18:09:30 <ddarius> :t fst . ask
18:09:34 <ddarius> :t asks fst
18:09:38 <lambdabot> forall a b. (a, b) -> a
18:09:40 <lambdabot> forall a b (m :: * -> *). (MonadReader (a, b) m) => m a
18:10:00 * mdmkolbe-home slaps his head
18:10:18 <petekaz> maybe I am missing something, but why can I find nothing about 'ask' on the Control.Monad.Reader doc page?
18:10:19 <mdmkolbe-home> ddarius: yeah, I forgot about the monad itself
18:10:32 <bd_> petekaz: try Control.Monad.Reader.Class?
18:10:42 <bd_> @doc control.monad.reader.class
18:10:43 <lambdabot> control.monad.reader.class not available
18:10:48 <mdmkolbe-home> petekaz: it recently got factored out into Control.Monad.Reader.Class
18:10:48 <bd_> @doc Control.Monad.Reader.Class
18:10:49 <lambdabot> Control.Monad.Reader.Class not available
18:10:52 <bd_> heh
18:10:54 <petekaz> bd_: ahh thanks.
18:11:33 <petekaz> and C.M.ReaderT is an instance of the class.
18:11:53 <dolio> mdmkolbe-home: Cutely enough, '(MonadReader (a, b) m) => m a' is the same as '(a, b) -> a' in the ((->) e) case. :
18:12:05 <petekaz> my head hurts ... this type stuff is uber confusing.
18:12:28 <dolio> @src (->) ask
18:12:29 <lambdabot> ask = id
18:12:36 <Cale> petekaz: which type stuff?
18:13:06 <petekaz> Cale: all of haskell!
18:13:12 <Cale> hehe
18:13:14 <Cale> Most type stuff is just substituting things for other things like you do in elementary algebra.
18:14:05 <mdmkolbe-home> petekaz: as long as you avoid IO, most monad uses follow a very predictable pattern.  foo :: (MonadReader r m, MonadBlah m, etc) => m a -> m b; main = runReaderT (runStateT (runBlahT (foo argToFoo) argsToBlah) initialState) initial reader
18:14:07 <ddarius> dolio: Indeed.  ask = id
18:14:19 * ddarius should read everything before replying.
18:14:22 <petekaz> classes, instance, data, newtypes, etc ... Its just unfamiliarity with it all.  When I see any complicated type signature I freeze like a deer in headlights.
18:14:46 <mdmkolbe-home> petekaz: you forgot kinds!
18:14:53 <ddarius> Type signatures are your friends
18:15:30 <petekaz> mdmkolbe-home: Yes, I'm reading "Monad Transformers Step by Step" by Martin Grabmuller.  Its quite good and basic enough for me.
18:15:36 <ddarius> @kind (->)
18:15:38 <lambdabot> ?? -> ? -> *
18:16:00 <petekaz> mdmkolbe-home: that was in reference to the common pattern comment you made.
18:16:54 <mdmkolbe-home> classes == C++ ABC, data == C++ struct+enum, newtype == C++ typedef, instances and kinds == not in C++
18:18:10 <ddarius> type == typedef not newtype
18:18:22 <ddarius> newtype is like wrapping something in a single element struct.
18:18:28 <mdmkolbe-home> instance sort of equals C++ inheritance of a data (C++ struct) from a class (C++ ABC), but it's separate from the data and after the fact
18:19:14 <ddarius> All of these things are very roughly and/or in much weaker forms.
18:19:18 <petekaz> class Monad m => MonadReader r m | m -> r   -- what does the | mean here?
18:19:31 <petekaz> I've not seen this in tutorials yet.
18:19:43 <ddarius> It separates the variables from the functional depency m -> r which is an extension
18:19:48 <mdmkolbe-home> ddarius: right.  though a newtype could be done with just data, but with newtype the cost of wraping it is removed at compile time
18:19:52 <ddarius> Along with multiparameter typeclasses in general.
18:20:12 <ddarius> mdmkolbe-home: Semantics-wise, newtype cannot be replaced with data.
18:20:23 <petekaz> so in english words, what does that state?
18:20:29 <mdmkolbe-home> petekaz: for any particular monad, m, there is only one, r, that does with it
18:20:48 <ddarius> petekaz: What mdmkolbe-home said refers only to the m -> r part.
18:20:50 <mdmkolbe-home> petekaz: (Reader Int) is a monad, but it always uses r == Int
18:20:57 <ddarius> I read, m -> r as "m decide/determines r"
18:21:17 <ddarius> s/decide/decides/
18:21:40 <petekaz> thanks.
18:21:42 <mdmkolbe-home> ddarius: RE: newtype, what is the semantic problem?  is it lazyness?
18:22:55 <ddarius> That's the first one.  First, using data D = D Int and newtype N = N Int, N _|_ == _|_, D _|_ /= _|_
18:23:33 <ddarius> But even with D !Int, case D _|_ of D x -> 0 -> _|_ while case N _|_ of N x -> 0 reduces to 0.
18:23:39 <mdmkolbe-home> ddarius: ok, so then what about data D = D# Int?
18:24:03 <petekaz> Thanks for all of the help again.  I'm off to watch casino royale with the wife.  Thanks again.
18:24:14 <sorear> petekaz: | introduces functional dependencies, a semi-evil GHC extension that the author of your tutorial is trying to protect you from
18:24:21 <ddarius> Casino Royale is meh for a movie.  It's horrible as a Bond movie.
18:24:45 <sorear> @wiki Type_SK
18:24:45 <lambdabot> http://www.haskell.org/haskellwiki/Type_SK
18:24:47 <petekaz> ddarius: its either that or some chick flick.
18:25:11 <petekaz> and at least its in HD so it'll look good on the tv.
18:25:24 <ddarius> Which chick flick?
18:25:24 <sorear> petekaz: see that for an example of some of the horror FD's can give...
18:25:42 <mdmkolbe-home> ddarius: huh?  If N _|_ == _|_, how can case N _|_ of N x -> 0 == 0?
18:26:00 <sorear> mdmkolbe-home: x is bound to _|_, but 0 doesn't use x.
18:26:07 <ddarius> sorear: Undecidable instances is needed there.
18:26:20 <sorear> mdmkolbe-home: pattern matches on newtype constructors are irrefutable
18:27:26 <ddarius> http://www.haskell.org/hawiki/NewtypeVersusStrictData
18:27:27 <mdmkolbe-home> ok, I think I see.  It's b/c the constructor is effectively elided and thus the match on the constructor is irrelavent?
18:27:28 <lambdabot> Title: NewtypeVersusStrictData - The Haskell Wiki
18:27:40 <ddarius> mdmkolbe-home: Yes
18:27:50 <mdmkolbe-home> that is subtle
18:27:54 <ddarius> It doesn't even really "do" the case.
18:27:57 <ddarius> It is subtle.
18:28:25 <sorear> It is genius.
18:32:30 <mdmkolbe-home> @hoogle [a] -> m a
18:32:31 <lambdabot> Prelude.head :: [a] -> a
18:32:31 <lambdabot> Prelude.last :: [a] -> a
18:32:31 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
18:32:57 <mdmkolbe-home> @hoogle (MonadPlus m) => [a] -> m a
18:32:58 <lambdabot> Prelude.head :: [a] -> a
18:32:58 <lambdabot> Prelude.last :: [a] -> a
18:32:58 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
18:34:22 <mdmkolbe-home> @hoogle MonadPlus
18:34:22 <lambdabot> Control.Monad.MonadPlus :: class Monad m => MonadPlus m
18:35:31 <Saizan> msum?
18:35:36 <Saizan> ?type msum
18:35:38 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
18:38:00 <mdmkolbe-home> Saizan: (msum . map return)
18:39:01 <mdmkolbe-home> @type mplus
18:39:04 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
18:39:15 <Saizan> mmh, on which monad are you using this?
18:39:34 <mdmkolbe-home> ?
18:40:56 <Saizan> i'm just curios of a situation where (msum . map return) is useful :)
18:42:17 <mdmkolbe-home> well, I started with the [] monad and did 'c <- [1..len]', but now I need to support state in the monad so I'm doing 'c <- msum $ map return [ 1..len]'
18:42:28 <mdmkolbe-home> better ways of doing that are welcome
18:42:42 <mauke> :t foldr mplus mzero
18:42:45 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
18:43:04 <mdmkolbe-home> :t (msum . map return)
18:43:06 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [a] -> m a
18:43:26 <dolio> :t foldr (mplus . return) mzero
18:43:28 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [a] -> m a
18:43:53 <ddarius> yay fusion
18:44:30 <Saizan> ah ok, you are just lifting a the list in your transformed monad
18:44:49 <mdmkolbe-home> Saizan: yeah
18:46:02 <Saizan> ?type lift [1..]
18:46:04 <lambdabot> forall t (t1 :: (* -> *) -> * -> *). (Num t, Enum t, MonadTrans t1) => t1 [] t
18:46:44 <mdmkolbe-home> @eval (lift [1..5] :: StateT [] Int)
18:47:01 <Saizan> > (lift [1..5] :: StateT [] Int)
18:47:02 <lambdabot>      `[]' is not applied to enough type arguments
18:47:02 <lambdabot>     Expected kind `*', but ...
18:47:28 <mdmkolbe-home> > (lift [1..5] :: StateT () [] Int)
18:47:28 <lambdabot>        add an instance declaration for (Show (StateT () [] Int))
18:47:29 <Saizan> > runStateT (lift [1..5] :: StateT Int [] Int)  1
18:47:30 <lambdabot>  [(1,1),(2,1),(3,1),(4,1),(5,1)]
18:48:03 <mdmkolbe-home> thx, it looks like lift is what I want
18:48:27 <dolio> I guess there aren't enough non-deterministic monads floating around to warrant a type class for them.
18:48:41 <dolio> At least, not in the standard library.
18:49:02 <mdmkolbe-home> dolio: MonadPlus
18:49:56 <dolio> Or, yeah, of course. I suppose the real issue is that msum . map return isn't predefined.
18:50:44 <mdmkolbe-home> yeah, but as Saizan pointed out, lift will do the job for me
18:50:51 <dolio> Even though 'a <- pick [...]' would, presumably, be a common operation in those other monads.
18:51:10 <mdmkolbe-home> @type pick
18:51:13 <lambdabot> Not in scope: `pick'
18:51:27 <Saizan> whel pick is just >>=
18:51:32 <Saizan> *well
18:51:43 <dolio> mdmkolbe-home: Well, it will if you build on top of list, but it won't if you use, say, continuations as your basis for nondeterminism.
18:53:07 <mdmkolbe-home> night'
18:53:11 <mdmkolbe-home> 'night
18:54:46 <petekaz> movie night was cancelled, got one last question. how do I specify this type signature in a more "class"y manner?  processFile :: String -> ReaderT Int IO [String]
18:56:40 <Saizan> :: (MonadReader Int m,MonadIO m) => String -> m [String]
18:57:27 <petekaz> thanks.
18:57:36 <petekaz> and this is preferred over the version i had+
18:57:37 <petekaz> ?
18:58:11 <Saizan> it's more general, you can alter your stack of monad transformers later and still use this function
18:58:19 <petekaz> great ... thanks!
19:00:18 <petekaz> I get a weird compile error now.
19:00:19 <ddarius> petekaz: These things get ridiculously abstract and flexible.
19:00:29 <petekaz> m is  a rigid variable ...
19:00:54 <petekaz> matched against inferred type t IO
19:00:59 <Saizan> do you use liftIO?
19:01:00 <Cale> petekaz: usually means that you've given a polymorphic type signature, but the code you've written isn't that polymorphic
19:01:07 <petekaz> no, just lift.
19:01:12 <Cale> (if you have given a type sig)
19:01:30 <petekaz> oh, liftIO fixed it.
19:01:38 <Saizan> use liftIO for the IO actions :)
19:01:56 <Cale> liftIO is always nice for IO actions because you don't have to think about how many lifts are necessary.
19:01:57 <petekaz> Thanks!
19:02:04 <petekaz> I see.
19:03:05 <Saizan> just because there's no IOT!
19:03:37 <ddarius> @src MonadIO
19:03:37 <lambdabot> Source not found. Do you think like you type?
19:03:59 <ddarius> lambdabot: I think we've had this conversation.
19:04:19 <ddarius> @where stats
19:04:19 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
19:05:33 <ddarius> http://www.cse.unsw.edu.au/~dons/irc/haskell.html
19:05:33 <lambdabot> Title: #haskell @ freenode.org stats by dons
19:05:35 <sproingie> lambdabot's error messages remind me of the error presentation modes i built into a MOO command parser once
19:05:37 * ddarius is very unsurprised.
19:05:56 <sproingie> we had "friendly", "suggest", "none", "raw", and "insult"
19:07:11 <glen_quagmire> haskell doesnt' have function overloading?
19:07:26 <glen_quagmire> let func a b = a* b;   let func a = a;
19:08:14 <stepcut> glen_quagmire: thankfully, no, not like that :)
19:08:25 <glen_quagmire> ah
19:08:51 <stepcut> glen_quagmire: with type-classes, you can define a function with different implementations for different types
19:08:53 <ddarius> @google "How to make ad-hoc polymorphism less ad-hoc"
19:08:55 <lambdabot> http://citeseer.ist.psu.edu/wadler88how.html
19:08:55 <lambdabot> Title: How to Make Ad-Hoc Polymorphism Less Ad Hoc - Wadler, Blott (ResearchIndex)
19:09:07 <stepcut> for example, +  works on Int, Integer, Float, etc.
19:09:38 <glen_quagmire> 1 - (-2)
19:09:50 <stepcut> yes, many people think that is a mistake :O
19:10:17 <stepcut> ... a mistake that the language spec allows that
19:10:42 <glen_quagmire> why? do you want it to be 1 - -2?
19:10:59 <glen_quagmire> you mean, you want unary operator to be part of Int literal?
19:11:18 <stepcut> glen_quagmire: personally, I do not have an opinion
19:11:26 <stepcut> glen_quagmire: but some people would prefer, 1 - (negate 2)
19:11:39 <stepcut> or something similar, rather than using - to mean two different things
19:11:51 <glen_quagmire> ah i see
19:11:53 <ddarius> And those people should be shot.
19:11:58 <Cale> :)
19:12:05 <lispy> glen_quagmire: giggidity giggidity giggidity?
19:12:15 <dolio> > - 2 `mod` 3
19:12:17 <lambdabot>  -2
19:12:25 <dolio> > (-2) `mod` 3
19:12:26 <lambdabot>  1
19:12:38 <stepcut> The nice think about the overloading is haskell is that it is usually quite predictable. You can be relatively sure that + does what you think it does, and has the type signature you expect
19:12:43 <glen_quagmire> does haskell function have optional parametesr?
19:12:44 <stepcut> s/think/thing/
19:12:59 <lispy> glen_quagmire: not easily
19:13:09 <ddarius> glen_quagmire: If you do crazy type class hackery!
19:13:23 * ddarius loves crazy type class hackery.
19:13:33 <lispy> ddarius: why don't you marry it!
19:13:34 <Saizan> not so crazy, it's in the standard libs anyway
19:13:35 <dibblego> glen_quagmire, it has a better alternative called 'partial application'
19:13:36 <glen_quagmire> that means no default parameter
19:14:10 <glen_quagmire> ah. can I say haskell functions are all fixed arity?
19:14:21 <ddarius> lispy: 'cuz there's this girl I love more and I believe all states in the union have laws against bigamy nowadays.
19:14:30 <stepcut> glen_quagmire: I think ghc has (or had) operational parameters (called implicit parameters?), but they are not used very often in practice
19:15:02 <Saizan> that's more about dynamic scoping than optional parameters
19:15:29 <ddarius> Hmm... Are hermaphrodites banned against marrying anyone in states with laws against same-sex marriages?
19:15:30 <stepcut> ah, I have never even tried to use them or read about them ;)
19:15:49 <sproingie> optional args usually aren't as necessary when you can just create a new type with names for all your args
19:15:49 <ddarius> glen_quagmire: Yes.  They are all arity 1.
19:15:58 <sproingie> and a data constructor that omits the ones that are optional
19:16:21 <glen_quagmire> 1 + 1 //arity 2?
19:16:32 <lispy> > (1+) 1
19:16:34 <lambdabot>  2
19:16:47 <lispy> :t (+)
19:16:49 <sproingie> 'course that makes your types a lot less generic.  i prefer just using less args per function
19:16:50 <lambdabot> forall a. (Num a) => a -> a -> a
19:16:52 <lispy> :t (1+)
19:16:55 <lambdabot> forall t. (Num t) => t -> t
19:17:22 <Saizan> all functions are of type a -> b where b can be something long :)
19:17:25 <lispy> glen_quagmire: so, you could claim that (+) is a function of arity 1 which returns a function of arity 1
19:17:44 <hyrax42_> ?instances Monad
19:17:46 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
19:18:01 <glen_quagmire> > (+1) 1 1
19:18:02 <lambdabot>   add an instance declaration for (Num (t -> a))
19:21:09 <glen_quagmire> :t (1)
19:21:12 <lambdabot> forall t. (Num t) => t
19:21:25 <glen_quagmire> no singleton?
19:21:47 <Cale> nope, there are no 1-tuples
19:22:00 <sproingie> a 1-tuple is otherwise known as a value
19:22:14 <glen_quagmire> i see
19:22:54 <Cale> Well, strictly speaking it wouldn't be quite the same thing, and I think GHC might have them internally, but there's nothing directly in the language which provides them.
19:23:21 <Cale> You could invent your own 1-tuple type, but you can't make it use parens for syntax.
19:23:26 <sorear> Yhc uses them internally, with the name _E.
19:23:50 <sorear> GHC needs to return 1-tuples in several places, and only provides the unboxed form
19:24:51 <glen_quagmire> how come: read "5" + 1 works but not: read "5" ?
19:25:23 <dons> moin
19:25:38 <dmead> hey channel
19:25:41 <dons> http://programming.reddit.com/info/1lt9z/details
19:25:42 <lambdabot> Title: Understanding comonads (reddit.com)
19:25:43 <dons> glen_quagmire: missing type constraints
19:25:45 <Cale> glen_quagmire: defaulting, most likely
19:26:27 <glen_quagmire> is there more verbose help system in ghci than :t blah ?
19:26:38 <dons> oh, also, http://gelisam.blogspot.com/2006/10/monads-as-universe-helpers.html
19:26:39 <dons> glen_quagmire: yeah, :info
19:26:40 <lambdabot> Title: Bloggy Badger: Monads as Universe Helpers, http://tinyurl.com/28shh4
19:26:43 <sorear> hi dons!
19:26:52 <Cale> Neither one would normally work, but for numeric constants, if their types are unresolved, their types are defaulted (by default to Integer or Double, the first of those to make sense)
19:27:09 <glen_quagmire> nice thanks
19:27:29 <Cale> That's because normally, just (5) on its own would be an ambiguously-typed thing, which is annoying.
19:28:08 <dmead> i need advice on how to implement the state monad
19:28:17 <dmead> http://taz.cs.wcupa.edu/~dmead/code/PNF.hs
19:28:30 <dmead> in the function rva
19:28:34 <dmead> i seed the function with z
19:28:52 <dmead> and decrement it each time a new quantifier is found
19:28:53 <Cale> That looks like more of a place for Reader
19:29:10 <dmead> so each quantifier has a unqiue name
19:29:16 <glen_quagmire> Cale: i hope i'll understand that soon
19:29:19 <Cale> oh, you need unique names
19:29:22 <dmead> yea
19:29:37 <dmead> i need changes to the counter to update "globally"
19:29:39 <Cale> glen_quagmire: read "5" isn't explicitly numeric, so it doesn't get the benefit of defaulting
19:30:10 <Cale> glen_quagmire: but it can tell that read "5" + 1 must be a number, so it defaults it to Integer in the absence of more information
19:30:31 <Cale> dmead: I have a monad for that, as it turns out :)
19:30:38 <dmead> oh yea?
19:30:41 <glen_quagmire> > read "5" :: Int
19:30:49 <lambdabot>  5
19:30:50 <Cale> http://www.haskell.org/haskellwiki/NewMonads/MonadSupply
19:30:52 <lambdabot> Title: New monads/MonadSupply - HaskellWiki
19:31:04 <Cale> also see: http://www.haskell.org/haskellwiki/New_monads/MonadUnique
19:31:06 <lambdabot> Title: New monads/MonadUnique - HaskellWiki
19:31:13 <glen_quagmire> i see thanks
19:34:11 <dmead> hmm
19:34:14 <dmead> interesting
19:43:50 <dmead> Cale: will calls to your supply monad produce unique names for each call?
19:44:10 <Cale> dmead: if you pass in a list of unique names
19:44:24 <Cale> (which should be infinite)
19:46:27 <dmead> hmm
19:46:35 <dmead> i'm not seeing how that could be
19:46:53 <Cale> hm?
19:47:23 <dmead> don't it still give the same names in the same order?
19:47:29 <dmead> *won't
19:48:36 <Cale> hm?
19:48:43 <Cale> But it'll only give each one once.
19:48:51 <Cale> It throws that one away once it's used.
19:49:48 <dmead> oh
19:49:49 <dmead> ahh
19:49:55 <dmead> hmm
19:51:05 <dmead> i've just a tree, where nodes in the tree have to have a unique name...
19:51:27 <dmead> but how would supplyMonad know what names have been consumed from different branches in the tree?
19:52:13 <Cale> Because you're going to order that computation by making it monadic
19:52:33 <dmead> oh
19:52:34 <dmead> OH
19:52:36 <dmead> i see
19:52:57 * ddarius thought that this (http://koweycode.blogspot.com/2007/01/think-of-monad.html) was random craziness, not actually based on something.
19:52:59 <lambdabot> Title: koweycode: think of a monad...
19:53:02 <Cale> You'll go down the left branch and then the right branch, and after the recursive call returns from going down the left branch, the hidden supply state will have a bunch of labels removed
19:53:19 <dmead> oh!
19:53:21 <dmead> neat
19:53:37 <Cale> ddarius: hehe, nope :)
19:53:38 <ddarius> Alternatively, if you don't want to order so much, use names like [Int]
19:53:50 <Cale> ddarius: it's a combination of all the metaphors people have used
19:54:08 <dmead> Cale: how would i call the supply monad from ghci?
19:54:28 <ddarius> Cale: I knew that it was poking fun at the various "analogies", but I wasn't aware of the spacesuit/nuclear waste monad "tutorial"
19:54:44 <Cale> dmead: it's just a pure computation, so evalSupply (do ...) theSupply
19:55:00 <Cale> ddarius: yeah, I'm not sure how much I care for that analogy
19:56:29 <ddarius> @src Data.Tree.Tree
19:56:29 <lambdabot> Source not found. I feel much better now.
19:56:36 <dmead> so, the supply could be [a..]
19:56:37 <dmead> ?
19:56:42 <ddarius> @doc Data.Tree
19:56:42 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Tree.html
19:58:33 <Saizan> it's interesting that a monad can have "hidden" parallel behaviour but is surely sequence your actions
19:58:55 <Saizan> s/is/it/
19:59:38 <ddarius> Saizan: No it does not.
19:59:54 <Saizan> no?
20:00:04 <dmead> oh
20:00:04 <dmead> so
20:00:06 <dmead> cale
20:00:15 <Cale> yeah
20:00:22 <dmead> when i want a new variable from the supply, you just do x <-get ?
20:00:42 <Cale> Saizan: the reader monad, for instance, doesn't exactly sequence things
20:00:58 <Cale> x <- supply
20:01:01 <ddarius> > let labelTree name (Node x children) =  Node (x,name) (zipWith (labelTree . (:name)) [1..] children) in labelTree [] (Node 'a' (map (flip Node []) ['b'..'f']))
20:01:02 <lambdabot>  Node {rootLabel = ('a',[]), subForest = [Node {rootLabel = ('b',[1]), subFor...
20:01:03 <dmead> ah
20:01:42 <ddarius> Saizan: No.  Consider, for example, the Identity monad.
20:02:52 <Cale> Of course, it does force you to translate your code so that it's more "sequential", but lazy evaluation can still mean that some branches don't get executed.
20:03:24 <sorear> Saizan: Consider the inverse state monad.  that actively anti-sequences your code!
20:04:03 <ddarius> Monads require you to -express- your code sequentially.
20:04:38 <Saizan> uhm ok, i was assuming too much on >>= :)
20:04:50 <Cale> It's also not altogeter clear whether the Cont monad can really be said to be "sequencing" either, as it can introduce much more complicated control flows.
20:05:11 <Cale> (though it does sequence things to some degree)
20:05:17 <Saizan> and inverse state monad? does it change the state in the ivnerse order?
20:05:21 <Cale> yeah
20:05:42 <Cale> It's implemented in the exact same way as the state monad, but you just pass the states backwards.
20:05:51 <Cale> It's really easy to write infinite loops in that monad :)
20:06:03 <dolio> MonadRandomSplittable also allows you to write non-sequential code, no?
20:06:11 <Saizan> i'm not surprised :D
20:06:36 <sorear> @pretty newtype RState s a = RState (s -> (s, a)) ; instance Monad (RState s) where { return x = RState (\s -> (s, x)) ; RState ac >>= fn = RState (\st1 -> let { RState ac2 = fn v ; (st3, v) = ac st2 ; (st2, f) = ac2 st1 ; in (st3, v) }) } -- Saizan
20:06:37 <lambdabot> "Parse error" at column 216
20:06:42 <sorear> @pretty newtype RState s a = RState (s -> (s, a)) ; instance Monad (RState s) where { return x = RState (\s -> (s, x)) ; RState ac >>= fn = RState (\st1 -> let { RState ac2 = fn v ; (st3, v) = ac st2 ; (st2, f) = ac2 st1 ; in (st3, v) }) }
20:06:42 <lambdabot> "Parse error" at column 216
20:07:07 <sorear> @pretty newtype RState s a = RState (s -> (s, a)) ; instance Monad (RState s) where { return x = RState (\s -> (s, x)) ; RState ac >>= fn = RState (\st1 -> let { RState ac2 = fn v ; (st3, v) = ac st2 ; (st2, f) = ac2 st1 } in (st3, v)) }
20:07:08 <lambdabot>  newtype RState s a = RState (s -> (s, a))
20:07:08 <lambdabot>  instance Monad (RState s) where
20:07:08 <lambdabot>          return x = RState (\ s -> (s, x))
20:07:08 <lambdabot>          RState ac >>= fn
20:07:08 <lambdabot>              = RState
20:07:10 <lambdabot>                    (\ st1 ->
20:07:12 <lambdabot>                         let RState ac2 = fn v
20:07:14 <lambdabot>                             (st3, v) = ac st2
20:07:16 <lambdabot>                             (st2, f) = ac2 st1
20:07:18 <lambdabot>                             in (st3, v))
20:09:16 <Saizan> oh, does it "read from the future" ?
20:09:28 <sorear> yes ;)
20:09:29 <augustss> yep
20:09:40 <sorear> hello augustss!
20:09:47 <augustss> hello
20:10:30 <ddarius> Random Monad rant by me: http://lambda-the-ultimate.org/node/1183#comment-12838
20:10:32 <lambdabot> Title: The Haskell Programmer&#039;s Guide to the IO Monad --- Don&#039;t Panic | Lambd ...
20:11:01 * sorear conjectures that augustss ' lack of identification is related to his most recent blog post
20:13:02 <dons> yeah, scary.
20:14:26 <augustss> yeah, i'm using my "media pc", staring at my TV instead of an lcd screen :(
20:15:05 <sorear> :(
20:15:32 <sorear> for a while I had a massively corrupt fs on my desktop and was using my family dvr
20:15:40 <sorear> but at least I had working ssh!
20:15:56 <sorear> (IE, desktop's keyboard and monitor)
20:16:21 * sorear also notes that for a couple days lambdabot was running on a dvr
20:16:34 <augustss> cool!
20:19:44 <Saizan> anyone interested in classes and relative derivations for data <-> XmlTree (from HXT) conversion?
20:20:17 <sorear> So many ideas, so little time.
20:20:33 * sorear thinks he just figured out how to djinn rank-n type
20:20:35 <sorear> +s
20:20:56 * sorear is almost surely wrong, but it will be fun :)
20:21:23 <ddarius> Djinn is a theorem prover.
20:25:53 <augustss> I don't think djinn can be extended to rank-n types
20:26:20 <augustss> because it would invole instantiating quantifiers
20:26:47 <augustss> so it would have to do predicate logic instead of propositional logic
20:27:18 <sorear> I suspect the fact that I can't tell the difference will come back to haunt me.
20:30:03 <ddarius> Propositional logic is trivial.
20:30:41 <augustss> yes, that's why djinn uses it :)
20:31:50 <augustss> it's a little trickier for constructive logic
20:32:01 <ddarius> True.
20:32:03 <sorear> Is 'a -> b', '~a | b' or '~(a & ~b)' ?
20:32:22 <ddarius> Though, classical and intuitionistic propositional logic are equivalent.
20:32:22 <augustss> neither
20:32:56 <sorear> *gulp* what is it in terms of ~ and | and & ?
20:33:02 <augustss> ddarius: in some sense, yes
20:33:56 <augustss> sorear: -> is a primitive in djinn (if that's what you were talking about)
20:34:37 <sorear> No, I'm talking in intuitionistic logic.
20:34:44 <dmwit> sorear: All three of those are equivalent.
20:34:58 <augustss> there too, normally
20:35:07 <sorear> I'm not extending djinn - I'm trying to write a program with a superset of djinn's pure functionality.
20:35:20 <sorear> dmwit: Classically, yes.
20:35:30 <sorear> dmwit: I don't have ~~a -> a, though.
20:35:36 <dmwit> o
20:36:11 <augustss> how would you get a proof term of a->b from a proof term of any of the others?
20:36:17 <ddarius> sorear: Just have Djinn produce proofs in a language with call/cc.
20:37:03 <augustss> ddarius: that forces you to run everything iin the continuation monad
20:39:23 <ddarius> augustss: Huh?
20:39:45 <augustss> haskell doesn't have call/cc
20:39:58 <ddarius> Hence "a language with call/cc"
20:40:18 <augustss> but the whole point of djinn was to produce haskell code
20:40:45 <hyrax42_> ?instances functor
20:40:46 <lambdabot> Couldn't find class `functor'. Try @instances-importing
20:40:50 <hyrax42_> ?instances Functor
20:40:52 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
20:42:32 <dmwit> > (iterate tail [1,2,3]) !! 1
20:42:33 <lambdabot>  [2,3]
20:42:48 <dmwit> laziness++
20:43:49 <dfranke> what is the arrow analogue to `fail'?
20:44:05 <sorear> ArrowZero
20:44:15 <dmwit> dfranke: There isn't even a Monad equivalent to fail... ;-)
20:44:17 <sorear> the value's name is slipping my mind...
20:44:21 <sorear> @src ArrowZero
20:44:21 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
20:45:13 <dfranke> dmwit, what do you mean?  As in, no analogue in category theory?
20:45:21 <sorear> augustss: Ah good.  My algorithm can prove (a -> b) -> Void.  Now for more productive persuits (read: life search programs)
20:45:24 <dmwit> Yeah, basically.
20:48:08 <augustss> sorear: but can it prove a->a ? :)
20:48:55 <sorear> Nonconstructively! ;)
20:49:40 <sorear> Apparently tristate boolean algebra isn't a very good model for intuitionistic logic ;)
20:49:57 <ddarius> tristate boolean algebra is a contradiction in terms
20:50:08 <augustss> non-constructive proof are not that helpful if yiu want haskell code :)
20:50:16 <ddarius> And "many-valued" logics fit into Intuitionistic logic.
20:50:35 <ddarius> (and not classical, that's actually one way of seeing the big difference between them()
20:50:35 <sorear> Yes/No/NaN logic, then.
20:51:39 <dino-> sorear: I didn't say thanks yesterday, you and monochrom were helping with something. Turned out you guys were exactly right. I neglected to use System.Process.waitForProcess after my runInteractiveProcess
20:52:00 <jcreigh> dino-: oh, were you leaving zombies around?
20:52:28 <sorear> dino-++ more code!
20:52:44 <dino-> jcreigh: Weirder. Intermittant oddness with what I expected to both be captured in STDOUT and also this process was deleting a file.
20:52:47 <procyon112> sorear: True | False | FileNotFound
20:52:49 <sorear> dunno why tabcomplete only found dinounix earlier.  (ps: is he you?)
20:52:50 <jcreigh> @karma test--
20:52:51 <lambdabot> test-- has a karma of 0
20:52:54 <jcreigh> test--++
20:52:56 <dino-> so it was also interleaving crazily/like shit without the wait
20:52:57 <jcreigh> @karma test--
20:52:58 <lambdabot> test-- has a karma of 1
20:53:18 <sorear> jcreigh: we call it the Syzygy- patch, for obvious reasons
20:53:35 <jcreigh> dino-: strange. I only ask because I just noticed that I have some code were I've neglected to clean up the child processes.
20:54:16 <dino-> jcreigh: I'm sure that would have happened as well, but in this case the runInteractive* was being called on something that will finish on its own, eventually.
20:54:28 <jcreigh> sorear: it's not obvious to me.
20:54:53 <sorear> Syzygy- had to submit a patch before he could get karma
20:55:05 <jcreigh> oh! haha.
20:55:23 <jcreigh> Syzygy-++ good patch
20:55:45 <jcreigh> is haskell.org down?
20:55:58 <sorear> not that I could tell (recently)
20:56:08 <sorear> otoh my zlib pull is stalled
20:56:13 <ddarius> I can't reach it.
20:56:15 <reitblatt> jcreigh: seems to be
20:56:20 <sorear> nor can I.
20:56:29 <dino-> Me either. But sometimes it just gets sluggy for a few minutes.
20:56:50 <dmwit> procyon112: ha
20:56:51 <sorear> Sometimes my whole connection lags completely for like ten minutes.
20:57:04 <sorear> Makes it really fun catching up on IRC
20:57:21 <jcreigh> I suprised you TCP connections don't timeout
20:57:24 <jcreigh> *your
20:57:37 <sorear> jcreigh: sometimes (rarely) they do
20:58:17 <sorear> jcreigh: linux has an outragously large tcp timeout, and my chat.freenode.net connections *usually* survive
20:58:40 <sorear> jcreigh: Actually, I ping out before the connection is dropped.
21:04:47 <jcreigh> there we go. no more zombies.
21:06:02 <jcreigh> Is it safe to call hGetContents on a file handle and then hClose the file handle before forcing the string from hGetContents?
21:06:15 <mauke> no
21:06:32 <mauke> hGetContents pseudocloses files
21:06:56 <mauke> you're not supposed to use the filehandle after passing it to hGetContents
21:10:23 <jcreigh> hmm. So I'm either supposed to a) somehow know that I'm not going to need anymore of the file, and hClose it b) not care about leaking FDs. or c) not use hGetContents
21:12:28 <augustss> does ghc garbage collect FDs?
21:13:41 <jcreigh> hmm. I suppose it's possible. But if it did, why is there hClose?
21:14:30 <augustss> to not force an implementation to GC FDs
21:15:06 <augustss> I don't know what ghc does
21:16:04 <augustss> but i'm guessing yes.
21:16:24 <augustss> but running out of FDs might not trigger a GC
21:16:26 <dolio> Isn't hClose there for when you're doing IO manually, with hGet/hPut/etc.?
21:17:14 <bd_> hm, haskell.org seems down
21:17:17 <dolio> Although, I suppose it's not strictly necessary if it can be garbage collected.
21:17:28 <augustss> right
21:19:09 <Weedy> yeah so who ddos haskell.org and can you stop now
21:20:10 <dolio> Being able to explicitly close a handle would still probably be useful, even if they were garbage collected.
21:20:19 <dons> Weedy: hmm? is it down?
21:20:28 <mauke> haskell should also have a free() function
21:20:37 <jcreigh> yes, haskell.org is down ATM.
21:20:38 <dons> Weedy: ah interesting.
21:20:44 <dons> ok. i'll contact the admins
21:21:38 <augustss> closed handles is a nasty concept.  you can only do bad things with them
21:21:47 <augustss> just like freed memory
21:21:59 <dons> weird how haskell.org always seems to get hit on sundays (this has happened 4 times in the last year, always on a sunday)
21:22:12 <jcreigh> "hit"?
21:22:31 <jcreigh> is this malicious?
21:22:32 <dons> well, stop responding.
21:22:32 <dolio> I suppose that's true.
21:22:54 <dons> I can ping it though.
21:23:04 <dons> the web server's just not serving pages.
21:23:58 <dons> Weedy: was there some document you needed? We might know of a mirror.
21:24:03 <dons> Speaking of which, we should mirror h.o...
21:24:11 <jcreigh> docs: http://web.mit.edu/ghc/www/libraries/index.html
21:24:19 <Weedy> * Running command "cd "/usr/portage/local/layman/haskell" && /usr/bin/darcs pull --all "http://www.haskell.org/~gentoo/gentoo-haskell/""...
21:24:27 <jcreigh> (that's what I keep trying to hit Haskell.org for, anyway)
21:24:42 <Weedy> also whos the overlay maint?
21:24:51 <dons> check on #gentoo-haskell
21:25:02 <Weedy> point
21:25:17 <dons> they are probably also here :-) but that channel will be more focused.
21:26:34 <dons> dino-: around?
21:26:49 <dons> dino-: can we get photoname uploaded to hackage?
21:27:21 <Weedy> arg i hate bomb proofing my code
21:27:28 <dons> ?where+ photoname http://ui3.info/d/proj/photoname.html
21:27:28 <lambdabot> Done.
21:27:35 <dons> Weedy: bomb proofing haskell code?
21:27:56 <Weedy> its already triple in length
21:28:15 <Weedy> and im still thinking of ways some one can fuck with the input
21:28:22 <dons> you're not using an ErrorT or something like that to abstract over checks?
21:28:45 <dons> and you lift the input into a nice data type, to prevent certain injection issues?
21:28:50 * dons speculates about the code
21:29:06 <Weedy> this happens to be a more general rant
21:29:26 <dons> ok. so not haskell, and not asking for advice, eh?
21:29:28 <Weedy> im not coding in haskel ATM
21:29:41 <Weedy> noj, just venting
21:30:39 <Weedy> the script im writing calls many external programs and automates alot of actions
21:30:55 <Weedy> its mainly checking exit status
21:32:33 <dons> hmm. interesting. I wonder if there is a cute exit status ErrorT monad
21:33:00 <dons> have bind perform the $? check, and then scrap your exit status checking boiler plate
21:33:34 <jcreigh> Weedy: what do you do if there is an error?
21:33:57 <Weedy> as of right now exit the script and say where is failed
21:34:53 <dons> so print the line number of something?
21:34:58 <Weedy> no
21:35:36 <dons> Weedy: i'm thinking of coding up a little error monad to abstract over exit status checking. what kind of failure message do you print?
21:35:40 <Weedy> more like "svn failed to check out sources" "autoreconf failed" etc
21:35:49 <dons> ah ok
21:36:13 <Weedy> its not my script im worried about
21:36:27 <Weedy> its all the ways the ext programs can fail
21:36:37 <dons> right.
21:36:46 <dons> untyped, nasty shell programming with arbitrary argument and return conventions
21:36:52 <dons> doesn't make for robust programming
21:36:58 <Weedy> very yes
21:37:08 <Weedy> hate bash
21:37:35 <dons> the linspire guys wrap their unix package tools in haskell bindings, hiding all the different caling conventions under a uniform, typed haskell api
21:37:41 <dons> then they write haskell glue code instead of shell
21:37:58 <dons> meaning uniform , type checked script glue. its a great approach i think
21:38:09 <dons> if i had to write a lot of shell code, i'd probably take that approach instead
21:40:18 <Weedy> i had this done in 200 lines
21:40:20 <dons> jcreigh: what do we do with XFetchName?
21:40:28 <Weedy> i think im over 500 now
21:40:41 <dons> 200 lines is about 150 lines beyond where I'd stop and write it in a proper language :-)
21:41:10 <jcreigh> dons: Nothing, I just thought it would be a fun function to bind. :) (no, really, I have some window-picker code that uses dmenu to jump to an arbitrary window)
21:41:26 <dons> does it work yet?
21:41:27 <jcreigh> dons: but I'm not happy with it yet (mainly because of dmenu) so I haven't released it.
21:41:59 * dons looks around for a nice shell program to  rewrite as an ExitStatus monad
21:42:46 <jcreigh> long window names make it so that only a couple windows are visible in the menu because dmenu reserves at least enough space to type as the longest option.
21:43:05 <jcreigh> really, a window picker should be something like dmenu, but multi-line.
21:43:06 <dons> ah so you need to filter
21:43:13 <dons> jcreigh: hmm. like dzen then?
21:43:48 <jcreigh> dons: possibly. It didn't look like there was any way to get dzen to act that way. (select an option, then echo selection, like dmenu)
21:43:52 <dons> jcreigh: does "avoid grabbing all keys when a keysym is undefined" fix a bug?
21:44:05 <dons> (if so, can you describe what bug it fixes, when naming the pathch)
21:44:15 <dons> hmm. i should set up a Trac instance for us.
21:44:18 <jcreigh> dons: the bug gimboland was talking about.
21:44:28 <dons> right. can you mentoin that in the patch next time?
21:44:40 <jcreigh> who reported it?
21:44:48 <foxy-om> @dcoutts: ping -- any word on the file path separator issue in c2hs ?
21:44:49 <lambdabot> Unknown command, try @list
21:44:51 <dons> "Fixes  bug [#12|reported by gimboland]"
21:44:59 <dons> depending on whether its a trac bug, or just hearsay :-)
21:44:59 <foxy-om> dcoutts: ping -- any word on the file path separator issue in c2hs ?
21:45:24 <jcreigh> dons: okay
21:45:27 <dons> jcreigh: more just name the bug, so we can cross it off our mental list of bugs.
21:45:33 <dons> but yes, we need trac.
21:45:47 <dons> who was the distract author? matthew- ?
21:46:03 <dons> matthew-_: around?
21:46:42 <jcreigh> I didn't think distract actually worked yet. And the author could take some SEO advice from you. :)
21:46:58 <dons> needs a darcs backend.
21:47:04 <dons> then he'll get 100 happy users instantly
21:47:22 <dons> SEO?
21:47:34 <jcreigh> distract is not a google-able name. xmonad is.
21:47:46 <dons> ah hehe
21:47:58 <jcreigh> but for our purposes, what's wrong with trac?
21:48:01 <dons> got to carve out a memorable brand :-)
21:48:12 <dons> oh, i was thining maybe offline trac might be a bit easier to set up
21:48:13 <qubit_> Hi, i'm having trouble with serialization over sockets, i get a connection, i get a socket in/out stream fine, but then when i pass it to ObjectInputStream( sin ) it blocks and doesn't return! did i miss a step? do i have to convert the socket streams to something else, or does anyone know how i can make it work?
21:48:29 <dons> qubit_: not haskell?
21:48:44 <qubit_> wrong chan whoops
21:48:53 <dons> ObjectInputStream gave it away ;-)
21:49:07 <dons> I suggest using hGetContents
21:49:09 <dons> mwhaha
21:51:12 <dons> jcreigh: ok. i'll set up a trac
21:51:24 * jcreigh wishes there was a hGetContents'
21:51:39 <dons> System.Strict.IO ;-)
21:52:46 <jcreigh> well, I want to slurp in an entire handle and then close it.
21:53:19 <dons> right. strict IO. Data.ByteString can do this, but we should just provide strict IO in the System.IO lib, imo.
21:53:30 <dons> maybe strict-io would make a nice package, actually
21:53:51 <jcreigh> laziness and IO don't seem to mix.
21:54:09 <dons> well, they do sometimes, but othertimes you need more control
21:54:21 <dons> lazy bytestring io makes for great unix filters, for example
21:54:37 <dons> but at other times , say, when treating files as mutable variables, you need strict reads
21:55:20 <dons> oh man, trac has some ugly deps for a 'minimalist' system
21:55:42 <jcreigh> what? Python, sqlite, and...?
21:55:42 * dons looks for something simpler
21:55:57 <dons> and about 5 python libs , and subversoin
21:56:12 <jcreigh> dons: it doesn't actually need subversion.
21:56:26 <dfranke> eek.  Is haskell.org down?
21:56:30 <dons> "To install Trac, the following software packages must be installed" ?
21:56:33 <dons> dfranke: yeah :/
21:56:34 <jcreigh> dfranke: yes
21:56:42 <sproingie> i've used trac with a darcs backend
21:56:44 <jcreigh> dons: what are you reading?
21:56:48 <dons> the readme.
21:57:10 <sproingie> watch out for trac ticket spam, there's been a rash of that lately
21:57:49 <dons> yeah
21:57:56 <dons> jcreigh: i want the xmonad of bug trackers..
21:57:58 <jcreigh> dons: http://trac.edgewall.org/wiki/TracInstall (I see Optional Requirements > Version Control System > Subversion)
21:58:01 <lambdabot> Title: TracInstall - The Trac Project - Trac
21:58:28 <dons> you know, its a 10 line mod to hpaste.org's src to have a haskell trac system :-)
22:00:17 <SamB_XP> dons: what? you wrote one?
22:00:43 <SamB_XP> in 32 seconds flat?
22:00:48 <sorear> I think we should go debbugs style.
22:00:48 <sorear> Just a slightly tweaked list server.
22:00:54 <dons> hi SamB_XP
22:02:15 <dons> Igloo: how about bark, could we use that?
22:02:35 <SamB_XP> reduced to using treebark for computation?
22:06:02 <sorear> The great thing about brute force search programs - self fuzzing!
22:36:46 <alan__> is there any way to get tab completion in ghci on windows?
22:38:54 <jyp> alan__: completion depends on the readline library
22:39:01 <jyp> so I guess the answer is no.
22:39:26 <sorear> hello jyp
22:39:40 <jyp> hey sorear
22:39:47 <jyp> Hows
22:39:51 <jyp> How's code?
22:40:15 <sorear> I've actually got a project now, which is Good.
22:40:29 <jyp> @where Good
22:40:29 <lambdabot> I know nothing about good.
22:40:35 <sorear> <- trying to write a faster brute force life pattern search
22:40:41 <alan__> jyp: that answer makes me sad.
22:41:08 <sorear> I just can't believe how stupid the algorithms used by the batch search tools are...
23:16:52 <mwc> heya shapr
23:17:00 <mwc> @seen Cale
23:17:00 <lambdabot> Cale is in #oasis, #ghc, #haskell-overflow and #haskell. I last heard Cale speak 3h 11m 9s ago.
23:21:27 <alan__> does anyone know if ndm's GUIHaskell has support for completion?
23:21:50 <alan__> or if anyone has compiled ghci with the readline for windows
23:25:28 <vagif> what is the preferred way to work with databases in haskell ? I downloaded haskelldb. But it kinda old. Looks like no new development last 2 years. Is it abandoned ? Is there anything else ?
23:25:30 <dfranke> @#$%!  I really need to keep a local copy of haskell.org/docs for times like this.
23:25:30 <lambdabot> Unknown command, try @list
23:26:14 <mwc> dfranke, it would be great if there was an rsync repo for the haskell docs, eh?
23:26:29 <dfranke> mwc, that's a really good idea.
23:26:32 <dolio> Someone posted a mirror earlier...
23:26:37 <mwc> toss it in a cronjob, and you always have an up to date set of haskell docs.
23:27:12 <dolio> http://web.mit.edu/ghc/www/libraries/index.html
23:28:34 <dolio> That's slightly out of date, though.
23:29:03 <mwc> yeah, hence my RSYNC idea
23:29:25 <sorear> mwc: what distro are you running?
23:29:27 <mwc> and we might stand a chance of convincing the haskell.org guys because if it was done through rsync, the server load would be kept to a minimum
23:29:30 <mwc> sorear, archlinux
23:29:52 <mwc> sorear, unforts they strip all the docs except the man pages to save space in the packages
23:30:06 <Lemmih> vagif: Look at hdbc.
23:30:20 <mwc> and when I build my own, it's a righteous pain to get ghc's configure to find my docbook stuff to get the docs built
23:30:33 <vagif> Lemmih: What about it ? did you use it ?
23:30:35 <sorear> mwc: Debian strips docs too, but they have a 'ghc6-doc' package
23:30:40 <Lemmih> vagif: haskelldb is just neat way of generating SQL.
23:31:02 <vagif> i'm fine with raw sql
23:31:19 <Lemmih> vagif: hdbc is a database interface to PostgreSQL, MySql and ODBC.
23:31:33 <mwc> I read an article a while ago on Reddit that I agreed with. The thesis was that these database binding layers do more harm than good, especially the ones like ActiveRecord or the Java equivs that try to map classes to table schemas and serialize objects into an RDBMS.
23:33:09 <dons> hey Lemmih
23:34:25 <vagif> thx, installed ðâèñá gonna try it
23:34:30 <vagif> hdbc
23:34:39 <mwc> dfranke, fwiw, I almost always just consult ghci instead of the docs
23:34:43 <mwc> :browse is your friend
23:35:11 <sorear> just ask the bot ;)
23:35:17 <ddarius> Isn't that O-R mapping == bad?
23:35:21 <sorear> grep -r is also your friend.
23:35:30 <sproingie> the HELL.  ubuntu package for ghc6.6 completely broken or something?
23:35:34 <sorear> ddarius: replying to mwc?
23:35:37 <sorear> sproingie: ?
23:35:40 <ddarius> sorear: Hair.
23:35:48 <ddarius> s/Hair/Hai
23:36:02 <sorear> Hai?
23:36:05 <sproingie> the only subdir in /usr/lib/ghc-6.6/imports/Control/Monad is ST
23:36:16 <sorear> sproingie: as it should be!
23:36:17 <ddarius> Yes (... in Japanese.)
23:36:19 <mwc> ddarius, the argument was more along the lines that people targeting a database already know SQL, and the cruft isn't worth it
23:36:23 <sproingie> can't find Control.Monad.Reader, Control.Monad.List, nada
23:36:32 <mwc> sproingie, mtl
23:36:41 <sorear> sproingie: those aren't in ghc
23:36:49 <sproingie> ohhh
23:36:55 <sorear> sproingie: mtl is an extra library you need to install
23:37:27 <sproingie> aha, lookit all those libghc6-*-dev packages
23:38:48 <dfranke> mwc, unfortunately, I'm trying to look up syntax.  I'm using GADTs for the first time.
23:38:51 <sorear> How about adding a rule to GHC's Probable cause: mechanism  'cannot find Control.Monad.*' --> "System administrator did not install MTL package'?
23:40:38 <sproingie> sorear: thanks :)
23:41:15 <dfranke> What flags do I need in order to enable GADTs?  (I'd RTFM, but...)
23:41:33 <mwc> dfranke, -fglasgow-exts is all I remember
23:41:39 <mwc> that turns on all the special gooodies
23:41:39 <sorear> -fglasgow-exts, like the error message told you to!
23:41:53 <mwc> I'm sure there are more fine-grained options
23:42:05 <sorear>     Illegal generalised algebraic data declaration for `X'
23:42:05 <sorear>       (Use -fglasgow-exts to allow GADTs)
23:42:11 <dfranke> ok, I must be misremembering the syntax then, because I'm still getting parse errors.
23:42:21 <sorear> @paste
23:42:22 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:42:34 <sorear> we can help :)
23:42:41 <sorear> even if h.o can't
23:43:03 <hpaste>  dfranke pasted "GADT syntax error" at http://hpaste.org/1611
23:43:59 <hpaste>  sorear annotated "GADT syntax error" with "fixed" at http://hpaste.org/1611#a1
23:44:15 <dfranke> ah, thanks.
23:44:24 <sorear> I doubt words would have been faster :)
23:44:55 <vagif> is there a tutorial on hdbc or a sample ?
23:45:59 <sorear> OK, Bulat has resorted to personal attacks.  How many lines does 'you are lame.' cross?
23:47:19 <reitblatt> the 12 year old line?
23:48:33 <dfranke> ok, and it seems to work.  That's just unreasonably awesome.
23:49:31 <dfranke> (is it possible to maintain your sanity if you try to implement an arrow without using GADTs?)
23:49:55 <dolio> Heh, did he also call PhD work "pseud-scientific"? :)
23:50:08 <dolio> Or am I misreading that?
23:50:20 <dolio> Pseudo, even.
23:50:43 <sorear> And he misspelled libs.
23:53:02 <sorear> @botsnack
23:53:03 <lambdabot> :)
23:54:17 <dfranke> sorear, before what you gave me would work, I had to add two dummy variables after `data Transaction' or I got kind errors.  That seems weird to me.
23:54:51 <dfranke> can the variable you put there ever express any semantics other than how many of them there are?
23:54:51 <sorear> dfranke: no, it's perfectly reasonable.
23:54:58 <sorear>  data Transaction where
23:54:58 <sorear>    TPure :: LockSet -> (b -> c) -> Transaction b c
23:55:12 <sorear> dfranke: yes - the kind of the variables.
23:55:31 <sorear> dfranke: it can (almost) always be inferred, but you need to specify it anyway
23:55:37 <sorear> you could also do
23:55:45 <sorear>  data Transaction :: * -> * -> * where
23:55:45 <sorear>    TPure :: LockSet -> (b -> c) -> Transaction b c
23:55:55 <sorear> and not give names at all
23:56:02 <dfranke> ah, ok.  That form looks much more reasonable.
23:57:41 <sorear> dfranke: implementing your arrow using GADT trees is fine for now, but **if** performance ever becomes a problem, note that eliminating the trees can give a massive boost.
23:57:45 <sorear> (note the if)
