00:00:06 <AStorm> igli: unsafePerformIO you mean? don't use that, unless required
00:00:08 <igli> ic
00:00:20 <mauke> it's usually called runFoo where Foo is the monad name
00:00:21 <AStorm> Yes, some do.
00:00:29 <AStorm> e.g. runIO
00:00:29 <igli> AStorm: i am seriously just looking at the lang, not writing code yet
00:00:43 <Cale> unsafePerformIO isn't actually a function though
00:00:52 <AStorm> Cale: :-)
00:00:58 <Cale> It's a hook into the runtime system.
00:01:19 <Cale> (which just happens to look a whole lot like a function, but it isn't)
00:01:24 <mauke> > runReader (do { x <- ask; return (x * 2) }) 21
00:01:26 <lambdabot>  42
00:01:57 <igli> join is like foldr?
00:02:00 <mauke> > id (\x -> x * 2) 21
00:02:02 <lambdabot>  42
00:02:04 <Cale> join is like concat
00:02:23 <mauke> join gets rid of the inner box
00:02:29 <Cale> > join (Just (Just 5))
00:02:31 <lambdabot>  Just 5
00:02:40 <Cale> It combines the boxes in some sensible way
00:02:52 <igli> 0..9] >>= return . join (*) # >>= is bind, join is applying * ?
00:02:52 <mauke> box collapsing!
00:02:56 <igli> hmm
00:02:58 <Cale> > join [[1,2,3],[4,5],[6,7,8]]
00:03:00 <lambdabot>  [1,2,3,4,5,6,7,8]
00:03:05 <igli> ah
00:03:09 <mauke> join (*) is doing something evil :-)
00:03:13 <igli> hehe
00:03:17 <Cale> not so evil
00:03:21 <mauke> > join (*) 5
00:03:23 <lambdabot>  25
00:03:28 <Cale> That join is in the ((->) e) monad
00:03:46 <Cale> Which is the type of functions that demand a value of type e
00:03:58 <igli> i'm just trying to get the operators clear so i can understand the syntax
00:04:00 <Cale> You can think of such functions as boxes indexed by values of type e
00:04:02 <mauke> > join (++) "dub"
00:04:07 <lambdabot>  "dubdub"
00:04:18 <igli> type e = executable?
00:04:23 <Cale> environment
00:04:28 <dolio> > (do { x <- ask ; return (x * 2) }) 21
00:04:28 <igli> ty
00:04:30 <lambdabot>  42
00:04:31 <Cale> (it's a type parameter)
00:04:54 <Cale> > (do { x <- id; y <- (*10); return (x + y) }) 5
00:04:56 <mauke> functions are containers
00:04:57 <lambdabot>  55
00:05:22 <Cale> id is the function which at index x, has the value x
00:05:47 <igli> ok
00:05:58 <igli> <- is input?
00:06:07 <Cale> <- is again "run this"
00:06:12 <mauke> <- takes a value out of a box
00:06:31 <ddarius> <- corresponds to >>= which is called "bind" for a reason.
00:06:32 <mauke> (except not really)
00:06:38 <igli> not getting how id and ask are doing the same thing
00:06:41 <Cale> to run a computation in this monad, which is a function of a parameter of type e, the function is applied to the supplied environment value
00:06:52 <AStorm> mauke: these aren't functions
00:07:02 <mauke> AStorm: what is "these"?
00:07:02 <AStorm> these are monads :P
00:07:03 <igli> my head hurts
00:07:09 <igli> ;)
00:07:10 <AStorm> do { whatever; }
00:07:15 <Cale> Okay, perhaps I can help things
00:07:18 <Cale> In this monad
00:07:20 <Cale> x <- f
00:07:20 <mwc> We should schedule a monad power hour ;)
00:07:29 <AStorm> Oh yes, definitely.
00:07:29 <mauke> AStorm: what are you talking about?
00:07:34 <Cale> will apply f to the eventual value we apply the computation to
00:07:36 <merus> mwc, pish, it should be a comonad copower cohour
00:07:38 <Cale> in order to produce x
00:07:48 <igli> ok Cale.
00:07:50 <Cale> > (do { x <- id; y <- (*10); return (x + y) }) 5
00:07:52 <lambdabot>  55
00:07:57 <Cale> in this case, the "environment value" is 5
00:08:09 <Cale> so x is produced by applying 'id' to 5
00:08:12 <AStorm> It's implicit runMonad
00:08:20 <Cale> and y is produced by applying (*10) to 5
00:08:23 <mwc> merus, the cohour should be... 12 hours after the start of the hour?
00:08:28 <AStorm> you can move that do-code into some state
00:08:30 <Cale> then they're added, and that value is returned
00:08:30 * igli thinks
00:08:42 <Cale> (after you get this, we'll do join :)
00:08:43 <monochrom> do { whatever; get together }
00:09:00 <igli> thanks very much Cale :)
00:09:06 <AStorm> :t do { return 1; }
00:09:08 <lambdabot> forall t (t1 :: * -> *). (Num t, Monad t1) => t1 t
00:09:08 <Cale> Does that make sense?
00:09:15 <merus> mwc, nah, it's the same hour in backwards time
00:09:25 <igli> yes, it does
00:09:25 <AStorm> :>
00:09:37 <Cale> okay
00:09:41 <AStorm> See, it's a Monad.
00:09:41 <mauke> (so <- only pretends to get a value out of id; in reality it just shifts the "problem" (of getting an actual value) somewhere else)
00:09:59 <Cale> so:  join f = do { g <- f; x <- g; return x }
00:10:17 <Cale> Think about this in the context of join (*) 5
00:10:29 <igli> i c; it says "eventually you'll get a value, when you do apply this to it to get var"
00:10:41 <igli> ah
00:10:57 <Cale> join basically runs a computation, to get another computation, which it runs in order to get a value, which it returns
00:11:24 <Cale> Running (*) in this context, produces (5*), which is then run to get (5*5)
00:11:30 <Cale> > join (*) 5
00:11:32 <lambdabot>  25
00:11:52 <igli> so f is *
00:12:03 <mauke> or you could just memorize that join f x = f x x :-)
00:12:08 <AStorm> igli: yes, eventually - <- may not return
00:12:09 <igli> heh
00:12:36 <igli> g is f on value
00:12:36 <AStorm> @src join
00:12:37 <lambdabot> join x =  x >>= id
00:12:39 <AStorm> :>
00:12:49 <igli> heh
00:13:10 <Cale> Yeah, I gave a somewhat less concise definition which would be easier to understand in this particular context.
00:13:23 <igli> yeah that last one threw me
00:13:25 <mauke> g = (*) 5; x = (*) 5 5 = 25;
00:13:52 <igli> thanks got that now. :)
00:14:09 <mauke> Cale's definition could be shortened to join f = do { g <- f; g }, further confusing you
00:14:28 <igli> *5 5
00:14:58 <igli> so <- always takes env var as param?
00:15:12 <AStorm> some name, actually
00:15:18 <Syzygy-> mauke: Doesn't that lack a return?
00:15:27 <ddarius> <- is like let only it "executes" the computation to get the value
00:15:32 <mauke> Syzygy-: that's the trick
00:15:36 <AStorm> @src (<-)
00:15:36 <lambdabot> Source not found. Take a stress pill and think things over.
00:15:39 <AStorm> Hm?
00:15:39 <Syzygy-> Oooooooh, right.
00:15:43 <AStorm> @src <-
00:15:43 <lambdabot> Source not found. Where did you learn to type?
00:15:45 <Saizan> igli: in the (e (->)) monad yes
00:15:46 <AStorm> Blah.
00:15:50 <igli> join f = do { g <- f;return  g } ?
00:15:59 <Syzygy-> igli: No. Please ignore me!!
00:16:00 <mauke> no return
00:16:11 <igli> ok
00:16:18 <igli> ty Saizan
00:16:27 <mauke> igli: the env var thingy is a feature of the reader monad
00:16:49 <igli> ok i want to stick to operators for now ;)
00:17:13 <igli> i'll just get muddled.
00:17:26 <ddarius> Cale's defn: join f = do g <- f; x <- g; return x, monad law do x <- f; return x == f therefore do g <- f; g
00:17:46 <igli> cool
00:18:11 <mauke> > runState (do { x <- get; put (show x); return (x * 2) }) 21
00:18:12 <lambdabot>   add an instance declaration for (Num String)
00:18:19 <mauke> :(
00:18:20 <igli> in x <- f # f is a function?
00:18:42 <ddarius> mauke: You can't change the type of the state like that.
00:18:48 <mauke> igli: in the ((->) e) monad, yes
00:18:52 <igli> ok
00:19:05 <ddarius> @type (>>=)
00:19:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
00:19:15 <mauke> > runState (do { x <- get; put (x * 2); return (show x) }) 21
00:19:17 <lambdabot>  ("21",42)
00:19:38 <mauke> igli: do you know Maybe?
00:19:51 <igli> Nothing | Just x ?
00:20:02 <igli> read about it
00:20:14 <mauke> do you know that Maybe is a monad?
00:20:35 <igli> no i didn't
00:21:21 <igli> i thought of it as a function tbh
00:21:50 <mauke> > do { x <- lookup "x" [("x", 21)]; return (x * 2) }
00:21:52 <lambdabot>  Just 42
00:22:00 <mauke> > do { x <- lookup "m" [("x", 21)]; return (x * 2) }
00:22:02 <lambdabot>  Nothing
00:22:21 <igli> @type (lookup)
00:22:24 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
00:22:33 <mauke> the Maybe monad gives you a simple form of exceptions
00:22:43 <igli> oh nice :)
00:22:53 <mauke> in the code above you can think of lookup throwing an error if it can't find the specified key
00:23:06 <mauke> which causes the rest of the do block to be skipped
00:23:17 <igli> ah cool
00:23:32 <dmead> :t state Char
00:23:35 <lambdabot> Not in scope: `state'
00:23:35 <lambdabot>  
00:23:35 <lambdabot> <interactive>:1:6: Not in scope: data constructor `Char'
00:23:44 <dmead> :t State Char
00:23:47 <lambdabot> Not in scope: data constructor `Char'
00:23:53 <dmead> @flush
00:23:54 <lambdabot> Not enough privileges
00:23:57 <mauke> dmead: ?
00:23:58 <Saizan> :k State Char
00:24:00 <lambdabot> * -> *
00:24:01 <dmead> WELL THEN
00:24:41 <mauke> igli: you can also think of Maybe as a list with at most one element :-)
00:25:04 <igli> heh i was thinking of it a ptr ;)
00:25:12 <mauke> extending this to real lists gives you another monad, which not only supports failure but also multiple successes
00:25:30 <igli> ok
00:25:47 <mauke> > do { x <- [1,2]; y <- []; return (x, y) }
00:25:49 <lambdabot>  []
00:25:54 <mauke> > do { x <- [1,2]; y <- [3,4]; return (x, y) }
00:25:56 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
00:26:14 <mauke> this code implicitly iterates over all possible combinations
00:26:34 <Cale> > do { x <- [1,2,3]; y <- [1,2,3]; guard (x < y); return (x, y) }
00:26:36 <lambdabot>  [(1,2),(1,3),(2,3)]
00:26:45 <Cale> @src guard
00:26:46 <lambdabot> guard True  =  return ()
00:26:46 <lambdabot> guard False =  mzero
00:26:54 <Cale> hehe
00:26:57 <Cale> mzero = [] here
00:27:19 <dmead> http://en.wikibooks.org/wiki/Haskell
00:27:21 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
00:27:23 <dmead> i recommend the monad section
00:27:53 <mauke> sequence in [] is pretty awesome
00:28:07 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
00:28:17 <Cale> > Control.Monad.sequence [[1,2,3],[4,5],[6,7,8]]
00:28:19 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
00:28:28 <Cale> Bloody import conflicts.
00:29:15 <mauke> > Control.Monad.sequence ["abc","def"]
00:29:16 <lambdabot>  ["ad","ae","af","bd","be","bf","cd","ce","cf"]
00:30:04 <igli> nice :)
00:30:31 <mauke> > transpose ["abc","def"]
00:30:32 <lambdabot>  ["ad","be","cf"]
00:30:54 <igli> yeah i read on Monads, and the wrapper thing, but i found i don't know basic operators well enough. thank you all for your help :D
00:31:13 <igli> @src transpose
00:31:14 <lambdabot> transpose []             = []
00:31:14 <lambdabot> transpose ([]   : xss)   = transpose xss
00:31:14 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
00:31:25 <igli> heh
00:31:32 * merus just wrote the silliest coreader instance ever
00:31:48 <dolio> > let transpose = foldr (zipWith (:)) (repeat []) in transpose ["abc", "def"]
00:31:50 <lambdabot>  ["ad","be","cf"]
00:32:26 <mauke> wow, that src is spectacularly unreadable
00:32:27 <Syzygy-> > let transposeM = foldr (zipWith (mplus)) (repeat mzero) in transpose ["abc", "def"]
00:32:28 <lambdabot>  Add a type signature
00:32:43 <Syzygy-> > let transposeM = foldr (zipWith (mplus)) (repeat mzero) in transpose ["abc", "def"] :: [[Char]]
00:32:44 <lambdabot>  Add a type signature
00:33:05 <Syzygy-> grmbl
00:33:14 <Cale> There are a lot of @src results which are ugly as sin.
00:33:19 <Cale> @src foldr
00:33:20 <lambdabot> foldr k z xs = go xs
00:33:20 <lambdabot>     where go []     = z
00:33:20 <lambdabot>           go (y:ys) = y `k` go ys
00:33:51 <mauke> what's the point of that?
00:34:12 <Cale> It's a hack to get GHC to optimise the thing better.
00:34:26 <mauke> :/
00:35:11 <Cale> It doesn't belong in the @src results, as far as I'm concerned.
00:35:12 <dolio> Note that the src transpose and mine are different.
00:35:26 <dolio> > transpose ["abc", "de"]
00:35:28 <lambdabot>  ["ad","be","c"]
00:35:35 <dolio> > let transpose = foldr (zipWith (:)) (repeat []) in transpose ["abc", "de"]
00:35:37 <lambdabot>  ["ad","be"]
00:36:42 <dolio> > transpose ["abc", "de", "fgh"]
00:36:44 <lambdabot>  ["adf","beg","ch"]
00:38:36 <flux> > (transpose . transpose) ["abc", "de", "fgh"]
00:38:38 <lambdabot>  ["abc","deh","fg"]
00:44:29 <Saizan> is bad style tod efine functions just to use them as build blocks for a bigger one even if those functions have nearly no hope of being reusable?
00:44:48 <monochrom> Not bad style
00:44:56 * DRMacIver does it all the time.
00:45:08 <monochrom> Good style.
00:45:19 <monochrom> Think step-wise refinement.
00:45:34 <DRMacIver> Think lemmas. :)
00:45:52 <Saizan> :D
00:45:56 <DRMacIver> (Citrus oriented programming)
00:47:02 * monochrom writes "The Structure and Interpretation of Proofs"
00:47:37 <Saizan> i'm writing proof-writing functions btw
00:47:51 <monochrom> Oooohhhh, "The Structure and Interpretation of Mathematical Proofs".  Dijkstra would love that one!
00:50:44 <Cale> Saizan: maybe put them in the where clause
00:53:25 <Cale> I wonder what the well-ordering principle tastes like?
00:54:48 <monochrom> It has a rich taste and a rich after-taste and a rich after-after-taste and ...
00:55:06 <dolio> > let zipWith' _ [] bs = bs; zipWith' _ as [] = as; zipWith' f (a:as) (b:bs) = f a b : zipWith' f as bs; transpose = takeWhile (not . null) . foldr (zipWith' (++) . map return) (repeat []) in transpose ["abc", "de"]
00:55:07 <lambdabot>  ["ad","be","c"]
00:55:08 <Cale> hahaha
00:55:49 <dolio> That one's not as succinct.
00:58:53 <dolio> zipWith' has been requested before, no?
01:00:18 <Saizan> every arrow is a functor fmap f a = a >>> arr f, right?
01:01:13 <monochrom> doesn't type-check
01:01:53 <Saizan> ?type \f a -> a >>> arr f
01:01:56 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => (c -> d) -> a b c -> a b d
01:02:51 <quicksilver> that shows arrows are functorial on the right
01:03:00 <quicksilver> I'm sure they're functorial on the left, too
01:03:05 <monochrom> OK I see.
01:03:23 <quicksilver> As to whether they're actually 'bifunctors', I'm not sure
01:03:32 <quicksilver> my category theory gets confused at that point :)
01:03:50 <quicksilver> there is more than one way you can be a functor of two variables and there are some different commutative diagrams, IIRC
01:04:00 <Saizan> ?type \f a = arr f >>> a  -- ?
01:04:02 <lambdabot> parse error on input `='
01:04:08 <Saizan> ?type \f a -> arr f >>> a  -- ?
01:04:11 <lambdabot> forall b c (a :: * -> * -> *) d. (Arrow a) => (b -> c) -> a c d -> a b d
01:04:24 <monochrom> Is "functorial on the left" correct if a = -> ?
01:04:36 <quicksilver> well, contra-functorial
01:04:55 <quicksilver> can't remember the word, I'm afraid
01:05:19 <monochrom> it's ok
01:05:22 <quicksilver> contravariant functor, I think it's called
01:09:13 <monochrom> \f a -> arr f >>> a satisfies the requirements of fmap.
01:09:47 <Saizan> sure?
01:09:50 <Saizan> ?type fmap
01:09:53 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:10:08 <Saizan> types are inverted
01:10:30 <monochrom> The requirements are fmap id a = a, fmap (f.g) a = fmap f (fmap g a)
01:11:07 <quicksilver> it'll be g.f, in the contravariant case
01:11:19 <quicksilver> but yes, it will satisfy them
01:11:26 <quicksilver> we don't have a contravariant functor class though :)
01:11:53 <Saizan> ?type let fmap = \f a -> arr f >>> a in \f g -> (fmap (f.g) a, fmap f (fmap g a))
01:11:55 <lambdabot> Not in scope: `a'
01:11:55 <lambdabot>  
01:11:55 <lambdabot> <interactive>:1:72: Not in scope: `a'
01:12:03 <Saizan> ?type let fmap = \f a -> arr f >>> a in \f g a -> (fmap (f.g) a, fmap f (fmap g a))
01:12:06 <lambdabot> forall (a :: * -> * -> *) b d. (Arrow a) => (b -> b) -> (b -> b) -> a b d -> (a b d, a b d)
01:12:07 <DRMacIver> Mm. Too long doing Java. I read "contravariant functor" and thought "Huh? Haskell doesn't even *have* subtyping."
01:12:25 <monochrom> OH!  I meant \f a -> a >>> arr f
01:12:53 <DRMacIver> (Well, not that Java has covariant or contravariant anything. Too long doing languages with subtyping)
01:12:54 <Saizan> ?type let fmap = \f a -> arr f >>> a in \f g a -> (fmap (g.f) a, fmap f (fmap g a))
01:12:57 <lambdabot> forall (a :: * -> * -> *) b c b1 d. (Arrow a) => (b1 -> b) -> (b -> c) -> a c d -> (a b1 d, a b1 d)
01:13:01 <monochrom> Haskell has subtyping.  The flat subtyping.
01:13:16 <Saizan> ?type let fmap = \f a -> a >>> arr f in \f g a -> (fmap (g.f) a, fmap f (fmap g a))
01:13:19 <DRMacIver> Yes, and monochrom has solutions for everything. The trivial solution. :)
01:13:19 <lambdabot> forall (a :: * -> * -> *) c b. (Arrow a) => (c -> c) -> (c -> c) -> a b c -> (a b c, a b c)
01:13:22 <monochrom> Like Int# is a CPO too!
01:14:14 <Saizan> CPO?
01:14:23 <monochrom> The typeclass system has proper subclasses too, to confuse things further.
01:14:32 <monochrom> C3PO, R2D2
01:14:51 <DRMacIver> Int# sounds like it should be a .NET language.
01:14:56 <DRMacIver> "Peano arithmetic for the CLR!"
01:16:07 <Cale> haha
01:16:58 <DRMacIver> You don't need to humour me. I know my jokes aren't actually funny. ;)
01:17:09 <monochrom> haha
01:17:40 <monochrom> hahahahahaha now I get it!
01:18:07 <matthew-_> I guess the irony is that out of the 19 or so number classes in C#, IIRC, none of them are actually peono.
01:18:10 <monochrom> @botsnack
01:18:11 <lambdabot> :)
01:18:16 * DRMacIver forces monochrom to write websites in asp.
01:18:27 <monochrom> @remember DRMacIver Int# sounds like it should be a .NET language.
01:18:28 <lambdabot> Done.
01:18:42 <DRMacIver> matthew-_: I think they have an infinite precision integer class now.
01:18:59 <DRMacIver> Not quite peano arithmetic, but getting close.
01:19:08 <matthew-_> super.
01:19:41 <DRMacIver> Been a while since I've coded any C# though, and when I did it was not exactly for high precision mathematical applications, so I could be wrong. ;)
01:19:47 <monochrom> If you like Int# as a .NET language, you may be even more interested in RealWorld# ...
01:19:49 <Saizan> ?djinn (a -> b -> c -> d) -> ((a,(b,c)) -> d)
01:19:49 <lambdabot> f a (b, (c, d)) = a b c d
01:20:17 <matthew-_> monochrom: sorry, who's being funny now?! =)
01:20:35 <Saizan> ?pl f a (b, (c, d)) = a b c d
01:20:35 <lambdabot> f = (`ap` snd) . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .)
01:21:26 <Saizan> omg
01:21:42 <Saizan> sounds like a work for TH
01:22:40 <matthew-_> can't you rewrite it with a RULE pragma?
01:22:54 <Cale> :t (curry .) . curry
01:22:57 <lambdabot> forall a b a1 c. ((a1, (a, b)) -> c) -> a1 -> a -> b -> c
01:23:23 <monochrom> syntactic curry
01:23:51 <Cale> there's the opposite
01:23:56 <merus> syntactic curry sounds too spicy for me :/
01:24:22 <Saizan> yeah, but uncurry . uncurry doesn't do the right thing
01:24:30 <Saizan> ?type uncurry . uncurry
01:24:33 <lambdabot> forall b c a b1. (a -> b1 -> b -> c) -> ((a, b1), b) -> c
01:25:49 <Cale> @. pl djinn (a1 -> a -> b -> c) -> (a1 -> (a,b) -> c)
01:25:49 <lambdabot> f = flip flip snd . (ap .) . flip flip fst . ((.) .)
01:25:54 <Cale> ugh
01:26:08 <Saizan> uhm, i can change the nesting of my tuples
01:27:20 <Cale> :t uncurry . (uncurry .)
01:27:23 <lambdabot> forall a b c a1. (a1 -> a -> b -> c) -> (a1, (a, b)) -> c
01:27:37 <Saizan> :O
01:27:50 <Saizan> does it scale?
01:28:08 <Saizan> :t uncurry . (uncurry .) . (uncurry .)
01:28:09 <Cale> :t uncurry . (uncurry .) . ((uncurry .) .)
01:28:12 <lambdabot> forall b c a b1 a1. (a1 -> a -> b1 -> b -> c) -> (a1, ((a, b1), b)) -> c
01:28:13 <lambdabot> forall a b c a1 a2. (a2 -> a1 -> a -> b -> c) -> (a2, (a1, (a, b))) -> c
01:28:55 <Cale> :t uncurry . (uncurry .) . ((uncurry .) .) . (((uncurry .) .) .)
01:28:57 <lambdabot> forall a b c a1 a2 a3. (a3 -> a2 -> a1 -> a -> b -> c) -> (a3, (a2, (a1, (a, b)))) -> c
01:29:12 <quicksilver> but, honestly, don't do that :P
01:29:18 <Cale> hahaha
01:29:19 <quicksilver> tuples are fugly except when used very locally
01:29:23 <Saizan> :D
01:29:29 <Saizan> i'm desugaring arrow syntax
01:29:47 <Saizan> (TH doesn't support arrow syntax yet..)
01:30:13 <Cale> Goes to show that you can do better than @pl sometimes if you put some thought into it.
01:30:17 <Saizan> :t \a b c d -> a &&& b &&& c &&& d
01:30:19 <lambdabot> forall (a :: * -> * -> *) b c c1 c2 c'. (Arrow a) => a b c -> a b c1 -> a b c2 -> a b c' -> a b (c, (c1, (c2, c')))
01:30:46 <quicksilver> Cale: why isn't there a ContraFunctor class?
01:30:58 <monochrom> I was going to say, arrow notation is syntactic curry...
01:31:25 <Cale> No good reason.
01:31:42 <Cale> People haven't used such a class enough to warrant it being in the libraries.
01:32:03 <Cale> But likely it'd see at least a bit more use if it were in the libraries.
01:51:36 <scodil> whats a good haskell book to recommend to a friend? (he already knows fp)
01:54:36 * nattfodd_ is also interested by the answer to this question :)
01:54:50 <monochrom> "Gentle introduction"
01:54:55 <swiert> I quite like "Programming in Haskell".
01:54:58 <swiert> But I'm biased.
01:58:31 <ibid> there are many good books. which is the best for someone depends on the someone
02:07:17 <Saizan> ?type let prod [x] = x; prod (x:xs) = x *** prod xs in prod --- :(
02:07:22 <lambdabot>     Occurs check: cannot construct the infinite type: b = (b, b)
02:07:22 <lambdabot>       Expected type: a b c
02:09:52 <dolio> prod [1, 2, 3] would have a different type than prod [1, 2]
02:17:41 <mahogny> Cabal - is there some way of telling it to use some -I and -L flags?
02:18:01 <alan_> where can i obtain make for windows?
02:18:03 <mahogny> I'm using darwinports and it has some non-standard install locations
02:18:10 <mahogny> alan_, cygwin?
02:18:19 <alan_> cygwin
02:18:29 <alan_> i dont want to go that far
02:18:34 <mahogny> devcpp probably comes with it too
02:18:49 <mahogny> or DJGPP if you like ancient software. it might be out of date
02:19:10 <mahogny> hm. actually not that certain if djgpp had it
02:21:08 <arcatan> mingw
02:22:35 <arcatan> or google for make for windows
02:23:43 <mux> > let blank1of3 = snd . mapAccumL (\i x -> (i+1, if i `mod` 3 == 0 then ' ' else x)) 0 in blank1of3 "foobarbaz42"
02:23:45 <lambdabot>  " oo ar az 2"
02:24:13 <dons> http://programming.reddit.com/info/1l40z/comments
02:24:15 <lambdabot> Title: Comonads in Haskell: reading and coreading (reddit.com)
02:24:30 <mux> @pl \xs -> snd $  mapAccumL (\i x -> (i+1, if i `mod` 3 == 0  then ' ' else x)) 0
02:24:31 <lambdabot> const (snd (mapAccumL (ap ((.) . (,) . (1 +)) (flip if' ' ' . (0 ==) . (`mod` 3))) 0))
02:24:34 <mux> @pl \xs -> snd $  mapAccumL (\i x -> (i+1, if i `mod` 3 == 0  then ' ' else x)) 0 xs
02:24:34 <lambdabot> snd . mapAccumL (ap ((.) . (,) . (1 +)) (flip if' ' ' . (0 ==) . (`mod` 3))) 0
02:24:47 <mux> hmm, what's this if' that I see lambdabot using often?
02:24:51 <mux> @type if'
02:24:54 <lambdabot> forall a. Bool -> a -> a -> a
02:25:03 <mux> @src if'
02:25:03 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
02:25:12 <mux> > if' True 1 2
02:25:14 <lambdabot>   Not in scope: `if''
02:28:13 <quicksilver> if' is available to @pl but not to the evaluator :)
02:28:31 <quicksilver> :t let if' c t e = if c then t else e in if'
02:28:33 <mux> is it just if' b x y = if b then x else y ?
02:28:34 <lambdabot> forall t. Bool -> t -> t -> t
02:28:40 <quicksilver> yes
02:28:44 <mux> okay
02:30:15 <Saizan> alan: msys
02:45:49 <Carmethene> morning
02:45:49 <Carmethene> today's Haskell question: is it possible to define a circular datastructure?
02:45:52 <merus> Yeah.
02:45:57 <Carmethene> for example, a linked list whose tail points to the head
02:46:03 <merus> I've seen it done somewhere.
02:46:07 <Carmethene> any ideas how?
02:46:19 <merus> I think sigfpe wrote about it once... maybe?
02:46:20 <sjanssen> > let x = 1 : x in x
02:46:21 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
02:46:27 <mux> > cycle 2
02:46:28 <lambdabot>   add an instance declaration for (Num [a])
02:46:32 <mux> > cycle [2]
02:46:34 <lambdabot>  [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2...
02:46:35 <Carmethene> sjanssen :: ah, I meant like a container
02:46:41 <Carmethene> sorry
02:46:45 <mux> not quite the same thing actually :)
02:46:51 <Carmethene> those things aren't circular anyway
02:46:57 <Carmethene> they're just infinite
02:47:02 <mux> yes
02:47:14 <swiert> Carmethene: http://cs.ioc.ee/~tarmo/papers/tfp06.pdf
02:47:17 <mahogny> meaning of (-# where ( should be like for the comment?
02:47:17 <sjanssen> Carmethene: my example is circular, but you can't observe the cycles
02:47:19 <swiert> Might be interesting.
02:47:39 <Carmethene> sjanssen :: I guess you're right, but it's still not what I meant :)
02:47:50 <Carmethene> swiert :: that's perfect, thanks :)
02:48:02 <sjanssen> Carmethene: in general you can't observe cycles in Haskell, it can potentially break referential transparency
02:48:08 <swiert> No worries.
02:48:32 <Carmethene> sjanssen :: observing them isn't the issue
02:48:57 <Carmethene> it's the tail -> head behaviour as you iterate through
02:49:11 <Carmethene> for example, let's say you wanted to iterate through every element in a list from a random start position
02:49:26 <Carmethene> without a cyclic structure, you need all kinds of special case code for crossing the boundary
02:50:05 <merus> http://sigfpe.blogspot.com/2006/12/tying-knots-generically.html
02:50:06 <lambdabot> Title: A Neighborhood of Infinity: Tying Knots Generically
02:50:11 <merus> ^^ Carmethene
02:50:21 <_roconnor> Carmethene: let (a,b) = splitAt n in b++a
02:50:43 <_roconnor> Carmethene: let (a,b) = splitAt n l in b++a
02:51:47 <Carmethene> thanks again for the info everyone :)
02:51:59 <hpaste>  sjanssen pasted "real cyclic iteration code from xmonad" at http://hpaste.org/1581
02:53:53 <opqdonut> hmm nice
02:55:27 <sjanssen> I'm particularly proud of the ws ++ ws trick
02:55:35 <ski> loeb ftw
02:55:54 <merus> ski, yeha
02:56:39 <roconnor> sjanssen: cycle ws would work too?
02:56:56 <roconnor> oh
02:57:05 <roconnor> you could never return nothing if you use cycle
02:57:08 <roconnor> nevermmind
02:57:08 <sjanssen> roconnor: that fails in the elemAfter x [x] case
02:58:16 <dolio> It's also bad in the elemAfter 1 [2] case.
02:58:23 <ski> @type map (head .) $ iterate (tail .) id
02:58:25 <lambdabot> forall a. [[a] -> a]
02:58:40 <ski> @type let loeb fs = as where {as = fmap (\f -> f as) fs}; foo = map (head .) $ iterate (tail .) id in loeb foo
02:58:43 <lambdabot> forall a. [a]
03:01:47 <quicksilver> Carmethene's basic point is just a cycle which knows how long it is?
03:02:16 <quicksilver> so logically it's as simple as \l -> (length l , cycle l)
03:16:02 <araujo> morning
03:25:04 * vincenz groans
03:31:22 <Saizan> re: strange prelude design - Eq is superclass of Num to allow pattern matching
03:33:45 <vincenz> Saizan: for "fac 0"?
03:33:50 <vincenz> afaik that's not based on equality
03:34:12 <quicksilver> I believe it is
03:34:20 <ski> eqInteger :: Num a => Integer -> a -> Bool  -- hm, would this suffice ?
03:34:22 <Saizan> i don't see another way
03:34:34 <quicksilver> you can imagine an implementation which properly handles type-class constructors
03:34:38 <sjanssen> vincenz: yes, that desugars to ==
03:34:40 <quicksilver> (and infinite familes of them, indeed)
03:34:45 <quicksilver> but that's not the implementation we have
03:35:01 <vincenz> sjanssen: ah, augustss had said it wasn't, that's actually quite interesting, cause it means I -can- do somethingg
03:35:03 <sjanssen> but there is no reason that pattern matching against literals can't add an Eq constraint
03:35:21 <ski> fromInteger i == n  =  i `eqInteger` n
03:35:46 <quicksilver> or you could do the comparison in Integer
03:36:10 <quicksilver> eqInteger i n = (fromIntegral n) == i
03:36:29 <vincenz> quicksilver: that requires Integral TC
03:36:30 <ski> (that was just meant as a law)
03:36:52 <ski> (oh, and i've swapped the args to 'eqInteger')
03:37:16 <ski> (er, no, i didn't nvm)
03:37:58 <ski> so 'fac 0 = ...' could desugar to 'fac n | 0 `eqInteger` n = ...'
03:38:37 <sjanssen> ski: how is that better than an Eq constraint?
03:38:53 <quicksilver> :t let f 0 = True in f
03:38:56 <lambdabot> forall t. (Num t) => t -> Bool
03:39:16 <ski> sjanssen : well, it sill doesn't help for 'Num a => Num (x -> a)' ..
03:39:18 <quicksilver> vincenz: weird, I didn't know you were allowed to pattern match on non-Integrals
03:39:22 <quicksilver> vincenz: that seems quite odd
03:39:29 <quicksilver> who'd want to pattern-match a Double?
03:40:01 <vincenz> quicksilver: fac 0 = ...
03:40:05 <vincenz> is valid for Double
03:40:07 <ski> @type \0 -> ()
03:40:09 <lambdabot> forall t. (Num t) => t -> ()
03:40:09 <ski> @type \0.0. -> ()
03:40:12 <lambdabot> parse error on input `.'
03:40:12 <vincenz> but not if you'd require integrals
03:40:16 <ski> @type \0.0 -> ()
03:40:19 <lambdabot> forall t. (Fractional t) => t -> ()
03:40:26 <sjanssen> quicksilver: it's reasonable to match against Rationals
03:40:42 <vincenz> it's reasonable to match against many Num's that aren't Integrals
03:41:02 <quicksilver> ah, true
03:41:09 <sjanssen> equality matching on Doubles is a generally bad idea
03:41:36 <vincenz> > let {fac 0 = 1; fac x = x * fac (x-1)} in fac 10.0
03:41:37 <lambdabot>  3628800.0
03:42:18 <quicksilver> sjanssen: yeah
03:43:54 <sjanssen> what's the motivation behind Num's Show constraint?
03:45:36 <vincenz> besides "I want my repl to print my numbers"?
03:46:39 <quicksilver> that doesn't sound like a reason to add it to the class
03:46:52 <quicksilver> just write code; if it has a show constraint, it has one...
03:46:57 <quicksilver> if it doesn't, it doesn't...
03:47:00 <sjanssen> numeric defaulting should take care of that anyway
03:47:17 <vincenz> I heard that was the most probable reason
03:50:07 <Cale> What's with these people who think "lazy evaluation = lazy lists only"
03:50:10 <Cale> ?
03:50:15 <quicksilver> naievete?
03:51:12 <Cale> Also, "monads = IO"
03:51:33 <Cale> ayrnieu seems to have a terrible case of both those afflictions
03:52:37 <kaol> does ghc do static analysis to silently switch over to eager execution when it won't affect semantics?
03:52:47 <quicksilver> kaol: in some cases, yes
03:53:04 <Cale> and it gets better at it all the time
03:53:11 <quicksilver> kaol: it has a 'strictness analyzer' which can catch such things
03:56:51 <Laney> @src reverse
03:56:52 <lambdabot> reverse = foldl (flip (:)) []
03:57:18 <Laney> @src map
03:57:18 <lambdabot> map _ []     = []
03:57:19 <lambdabot> map f (x:xs) = f x : map f xs
04:00:58 <Saizan> Cale: where?
04:01:09 <Cale> where what?
04:02:01 <Cale> where's ayrnieu's post?
04:07:32 <nominolo> > foldl (:[]) [1..3]
04:07:33 <lambdabot>  Couldn't match expected type `b -> a' against inferred type `[a]'
04:07:46 <Cale> > foldl (flip (:)) [1..3]
04:07:48 <lambdabot>  <[Integer] -> [Integer]>
04:07:53 <Cale> > foldl (flip (:)) [] [1..3]
04:07:55 <lambdabot>  [3,2,1]
04:08:07 <Cale> > foldl (flip (:)) [4..6] [1..3]
04:08:09 <lambdabot>  [3,2,1,4,5,6]
04:08:14 <nominolo> :t (:[])
04:08:16 <lambdabot> forall a. a -> [a]
04:08:24 <Cale> > (:[]) 5
04:08:25 <lambdabot>  [5]
04:08:28 <nominolo> :t (flip (:)) []
04:08:31 <lambdabot> forall a. a -> [a]
04:08:49 <Cale> (flip (:)) is not being applied to [] in the above
04:08:55 <Cale> they're both parameters to foldl
04:08:59 <nominolo> ah, oh. right
04:09:00 <quicksilver> nominolo: "(flip (:)) []" is not a sub expression of " foldl (flip (:)) [1..3]"
04:09:07 <quicksilver> Cale was faster :)
04:09:17 <quicksilver> and I copied the wrong line anyway
04:09:17 <quicksilver> :)
04:09:36 <nominolo> i still have some problems with those kinds of definitions
04:09:37 <Cale> foldl (flip (:)) [] [1..3] = ((foldl (flip (:))) []) [1..3]
04:09:52 <Saizan> <Cale> where's ayrnieu's post?  <-- yes
04:10:31 <nominolo> like the definition of append in the HList paper
04:10:35 <Cale> Saizan: http://programming.reddit.com/info/1kkeg/comments/c1krkw
04:10:36 <lambdabot> Title: Ask Reddit: Is the future of programming Erlang, Haskell, or a language that bor ...
04:11:06 <Cale> er, and more recently, http://programming.reddit.com/info/1kkeg/comments/c1l40s in which he replies to me
04:11:08 <lambdabot> Title: Ask Reddit: Is the future of programming Erlang, Haskell, or a language that bor ...
04:13:45 <osfameron> "Laziness is pretty much a necessity for any pure functional language." ?
04:13:58 <Cale> Pretty close to it.
04:14:18 <Cale> (read whyfp :)
04:14:22 <osfameron> didn't spj write that the benefits of laziness in Haskell weren't as compelling as some of the other constraints they'd set
04:14:46 <osfameron> in the hair shirt slides
04:15:04 <Cale> Yeah he did. That's only because some of the other stuff is really compelling.
04:15:12 <osfameron> heh
04:15:48 <Cale> (Or else he underestimates the importance of laziness, but I doubt he'd do that :)
04:15:50 <osfameron> I may try to read whyfp again.  It's one of those that I read the first half of, and smile and nod, and it's all in my comfort level, just about.  Then I lose it and run screaming for an open window.
04:16:16 <osfameron> that's probably because it's quite dense and I'm reading too fast.  That or I'm just not very bright.
04:16:21 <Cale> whyfp does have some issues with presentation
04:16:25 <quicksilver> As I remember, SimonPJ says "Laziness is good because it keeps you honest"
04:16:43 <quicksilver> (I don't claim that he believes that to be the only advantage)
04:16:59 <Cale> I find that unless you're primed to get the message it's trying to convey, you can read the whole thing and go "yeah, that's kinda good", but miss the whole point.
04:17:17 <alan_> why is compiling haskell apps soo much slower on windows?
04:17:36 <alan_> im using the .msi ghc version off the haskell website
04:17:46 <Cale> Also, there's some mathematics in there which is a little unfair to those unfamiliar with numerical computation techniques.
04:17:48 <quicksilver> Cale: I'm surprised you even bothered to have that argument (on the reddit thread); ayrnieu's comment is only one tiny step away from a troll
04:17:57 <vincenz> as usual?
04:18:12 <quicksilver> Cale: you have more patience than me, especially at 6am :)
04:18:27 <dons> Cale: yeah, he's openly said he's going to troll^h^h attack haskell on reddit
04:18:28 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
04:18:42 <Cale> quicksilver: It's true, but he's actually moderately knowledgeable, and if I recall correctly, in the past, he was mostly pretty intelligent.
04:19:25 <dons> yeah, he uses Mercury and Erlang, I think he's employed to code erlang
04:19:27 <quicksilver> Cale: he's clearly intelligent, but not very interesting in hearing anyone else's opinions
04:19:34 <quicksilver> erm, interested
04:19:35 <Cale> Hehe, I'd forgottten to update the time. It was closer to 7 when I finished that.
04:19:40 <quicksilver> my fingers cannot type that word :)
04:20:23 <dons> Cale: I note he's been saying the same things for a few weeks now, about uniquness.
04:20:27 <Cale> The fact that his opinions seem to be based on misconceptions is especially irritating.
04:20:39 <dons> Cale: maybe he's just not very clueful about haskell? or its intentional
04:20:44 <Cale> I don't know.
04:20:47 <dons> i can't tell either way.. :/
04:21:33 <Cale> Yeah, I remember we pointed this out to him once before now, that monads and linear parameters are completely orthogonal solutions to entirely different problems
04:21:36 <dons> I don't think he's a language implementor-type person though
04:21:40 <Cale> But he seems to have ignored that.
04:21:41 <dons> which might explain some of the odd questoins.
04:22:48 <Cale> The "iterators > lazy evaluation" thing is just retarded. I had to take it apart.
04:23:11 <dons> the misconcepts are so profound I feel I can't address them in replies, unfortunately.
04:23:26 <dons> I sort of iterate between speechless and "surely you don't mean that"
04:23:46 <vincenz> good thng that the internet is not speech-based
04:23:54 <dons> hehe
04:24:16 <Cale> Especially as I know that beginners often equate laziness with lazy lists, but most of them figure out that's not the whole picture pretty quickly.
04:25:01 <Cale> (I certainly wouldn't want beginners reading ayrnieu's posts without seeing lots of criticism below them)
04:25:09 <quicksilver> well that's true
04:25:19 <quicksilver> but you can spend your life trying to clean up after trolls, you know :P
04:25:29 <dons> yes. i agree. he's trying to actively be a counter-haskell person. so that shouldn't go un-addressed.
04:25:34 <osfameron> anyway, a bit of healthy difference of opinion is useful
04:25:42 <quicksilver> which is not so say that I am not grateful for your efforts
04:25:50 <Cale> Most of these arguments are stock arguments for me by now though.
04:26:04 <dons> but its just annoying that the criticisms are often false, or misleading.
04:26:05 <quicksilver> what frustrates me is how intangible anti-haskell arguments are
04:26:11 <quicksilver> "it's too hard" "it hurts my mind"
04:26:18 <quicksilver> "well you're stupid then, go away"
04:26:19 <quicksilver> :P
04:26:21 <Cale> "grow a better one"
04:26:36 <dons> hmm . the "its too hard" is probably the most pervasive one, in fact.
04:26:37 <Cale> heh, we shouldn't be like that though.
04:26:44 <quicksilver> I vividly remember how absurdly hard C seemed when I first learnt it
04:26:50 <dons> the number of small blogs i say that just have haskell == too hard as a throw away line
04:26:56 <quicksilver> and I also remember how bloody hard OO seemed the first time I met it
04:26:56 <dons> i see.
04:27:02 <osfameron> haskell does seem to be quite hard, and quite different from everything else
04:27:08 <quicksilver> I don't think haskell was any harder than that...
04:27:11 <Cale> I usually prime people by explicitly telling them that it's going to be like learning their first programming language.
04:27:24 <Cale> That tends to do away with a lot of the pain.
04:27:27 <osfameron> some aspects of it are very easy, and just beautiful
04:27:28 <quicksilver> in fact I think it was much easier than both of those, but that's because I was a more experienced programmer when I first saw it
04:27:44 <vincenz> I think haskell is as hard to normal people as learning to count in base 60 is for normal people.  The thing is, we've been trained to count in base 10, but look at the mayans, they easily counted in base 60
04:27:59 <osfameron> Cale: yeah, when I'm going through SOE I'm (finally) doing all the exercises, even the ones that I'd probably normally skip, just because I know I have to slow down and really learn it
04:28:08 <osfameron> but it's a matter of having the time to do it
04:28:17 <osfameron> if I wanted to learn, say, Ruby, I could do that in an afternoon.
04:28:27 <Cale> Yeah
04:28:30 <dons> vincenz: that's a useful analogy, yes. i like it :-)
04:28:57 <Cale> I was at the point where learning a new imperative language to a satisfactory level was taking me about a week when I started to learn Haskell.
04:29:04 <quicksilver> osfameron: because you're already a perl expert
04:29:15 <quicksilver> osfameron: if your previous experience had only been BBC BASIC, ruby would be harder
04:29:19 <Cale> I didn't really mind that it took me a long time to figure things out and get comfortable with it somehow.
04:29:20 <quicksilver> (say)
04:29:38 <dons> vincenz: of course, imperative programming is like a mixture of base 12 and base 60, and haskell is base 10
04:29:41 <osfameron> quicksilver: exactly.  And I learnt perl by *reading* a perl tutorial (having learnt only dialects of basic and some dos scripting)
04:29:42 <Cale> I suppose that I was in a pure mathematics program, and grasping new hard concepts was just a matter of course.
04:30:19 <osfameron> I can't just *read* a haskell tutorial and start scripting.  (I'm not saying that this makes haskell bad, just that I really do get that "learning haskell is hard" has some truth as a statement)
04:30:22 <vincenz> dons: right
04:30:35 <vincenz> dons: well base 16, base 10  is actually not -that- great
04:30:54 <dons> yeah, i was going to go with base 2, but maybe that's lambda calc
04:30:56 <vincenz> the only reason we think it's so great is cause we're brought up with it, but there's nothing natural about 10
04:30:59 <vincenz> I mean if we had base 11
04:31:01 <vincenz> then 11 would be '10'
04:31:04 <dons> it helps having 10 fingers :-)
04:31:21 <vincenz> right, so if we had taught kids to count in binary, they could go up to 1024
04:31:23 <osfameron> don't the different bases have handy numerical properties?
04:31:38 <osfameron> there's probably some disadvantage or advantage to having a prime base like 11
04:31:43 <vincenz> or a hand has 12 segments (if you exclude thumbs...)
04:31:44 <Cale> base 30 would be kinda good
04:31:53 <vincenz> osfameron: not really
04:32:32 <vincenz> Cale: cause of all the prime factors?
04:32:34 <osfameron> oh, I thought there were - my dad's maths speciality was number theory, istr him telling me about some stuff, but I may be confusing it
04:32:34 <int-e> Cale: do you need 1/3 so often? :)
04:32:34 <quicksilver> osfameron: actually, I think the problem is that what you think of as 'scripting' is an easy task in perl and slightly harder in haskell
04:32:35 <Cale> yeah
04:32:53 <quicksilver> osfameron: on the other hand, after reading a haskell tutorial you could do interesting stuff at the repl with strings and map and lists
04:33:02 <quicksilver> osfameron: which IMO is a more comparable acheivement
04:33:14 <Cale> It's easy to pick out multiples of 2, 3, 5, 6, 10, and 15
04:33:16 <vincenz> my indian friend has a cool way of counting to 10 with just one hand, he circles around along the segments of his fingers, excluding the two middle ones of the two middle fingers
04:33:21 <osfameron> quicksilver: actually, I'm not really even trying to do scripting stuff in haskell, just get my head around various stuff.
04:33:21 <vincenz> so he can count to 100 with two hands
04:33:28 <vincenz> it's actually quite easy
04:33:28 <dons> osfameron: take heart though, after a year or so, you dream in haskell, and all the usual languages become obvious limited subsets of haskell :-)
04:33:36 <osfameron> quicksilver: yeah, I have an idea that creating a class to do Units conversion in haskell will be really easy
04:33:37 <quicksilver> osfameron: right, but I was referring specifically to your comments about what you can do after 'reading' a tutorial
04:33:42 <vincenz> haskell is isomorphic to denotational semantics!
04:33:52 <quicksilver> osfameron: you can't just 'read' a perl tutorial and write Catalyst, say
04:34:03 <osfameron> quicksilver: yeah, I think I just wrote "scripting" out of habit.  TBH, most of my perl code is quite structured OO these days, rather than scripts
04:34:05 <Lor> vincenz, no two programs have the same semantics?
04:34:16 <vincenz> Lor: ?
04:34:20 <osfameron> quicksilver: ok, true
04:34:36 * QtPlatypus finds the more he reads and works with haskell the more functional his perl is getting.
04:34:37 <quicksilver> osfameron: most people take quite a long time to grasp perl OO, though
04:34:41 <Lor> isomorphism is a bijection, that's all
04:34:43 <quicksilver> osfameron: maybe you learnt quicker than most :)
04:35:00 <osfameron> maybe the thing is that a lot of haskell tutorials try to teach things as complicated as Catalyst/Perl OO very quickly, without doing as many baby steps?
04:35:03 <dons> hey Lor
04:35:15 <Lor> Hey hey.
04:35:24 <vincenz> Lor: my point is that writing haskell code is vey much like writing denotational semantic rule,s they easily translate to and fro
04:35:28 <osfameron> and I *do* understand the idae that "haskell is easier" becuase you can do funky stuff with tree maniuplation, types etc. that you couldn't think about in other languages.
04:35:29 <dons> Lor, still in .fi?
04:35:40 <osfameron> just that you have to get over the baby steps first ;-)
04:35:58 <vincenz> osfameron: that's with any language, and the sad thing is, with C, those baby steps take years
04:36:29 <vincenz> you never scale to bigger steps cause the language forces baby steps
04:36:55 <vincenz> dons: ooh, my blog had > 1000 readers in 3 days
04:37:08 <osfameron> vincenz: heh, yeah.  I have C on my "to-grok" list too, but I just get frustrated with the "What?  you mean I hve to allocate space just to pass a sodding string?" thing
04:37:09 <dons> you need to write more code in the blog articles though ;-)
04:37:16 <vincenz> dons: meh
04:37:18 <dons> op-ed pieces aren't as fun as code blogs :)
04:37:20 <Lor> dons, yeah. (Soon going traveling to .ua, .ru, .mn, .cn and .np)
04:37:25 <vincenz> dons: I'll consider it
04:37:29 <dons> Lor: wow. fun!
04:37:33 <vincenz> dons: yass?
04:37:48 <vincenz> (yet another sudoku solver?)
04:37:51 <dons> vincenz: i just like reading cool programs.
04:37:55 <osfameron> slightly off topic - is anyone working on a haskell on parrot implementation ?
04:38:00 <dons> so more sigfpe articles please! :-)
04:38:01 <vincenz> dons: my programs tend to not fit on one page
04:38:25 <vincenz> I could possibly put the compos stuff online
04:38:26 <Lor> osfameron, just so you could run pugs on it?
04:38:35 <vincenz> though I'd have to check with bringert
04:38:43 <quicksilver> vincenz: put them in the margin then
04:39:10 <dons> Lor: seen xmonad?
04:39:19 <Lor> Haven't tried it out.
04:39:30 <vincenz> dons: I could put the mini-ml interpreter I wrote last year online :)
04:39:37 <Lor> Seems a bit too minimalistic to my taste.
04:39:41 <dons> vincenz: right! that's the right kind of thing.
04:39:50 <vincenz> type-inference et al.
04:40:06 <dons> Lor: yeah, its not for everyone.
04:40:19 <dons> vincenz: writing a small type checker would make a nice blog
04:40:34 <dons> or just say, a 4 part series implementing MiniML
04:40:45 <dons> teach the kiddies who to roll their own typed functional language
04:40:47 <vincenz> dons: heh, a type inference checker is easy as pie to write
04:40:54 <dons> right. makes a good blog article
04:40:59 <vincenz> it's probably 1/3 the size of my c++ typechecker
04:41:09 * vincenz shudders
04:41:22 <quicksilver> it would, although for community PR reasons I'd rather see people blogging the kind of programs that are 'more relevant' to the haskell-skeptics out there
04:41:25 <vincenz> dons: alright, I might do that this weekend, going home so I'll have some spare time.
04:41:47 <dons> quicksilver: yeah. that's true.
04:42:02 <vincenz> quicksilver: you mean a program with a lot of buttons?
04:42:07 <dons> vincenz: for ideas of the spcae people have covered recently, http://haskell.org/haskellwiki/Blog_articles
04:42:09 <lambdabot> Title: Blog articles - HaskellWiki
04:42:13 <quicksilver> vincenz: probably not, no
04:42:18 <quicksilver> vincenz: GUI design isn't programming
04:42:26 <dons> i'd do some elangish stuff.
04:42:28 <quicksilver> vincenz: but I'm not really sure what I do mean :)
04:42:34 <dons> concurrency is under-documented.
04:42:41 <dons> i don't think i've seen any `par` blogs yet
04:42:44 <quicksilver> One could blog a nice particle system in HOpenGL
04:42:52 <quicksilver> stuff like that is much neater in haskell than C(++)
04:42:53 <vincenz> dons: my 2005 icpfc solution had a gui with concurrency
04:43:23 <vincenz> s/pf/fp
04:43:57 <vincenz> (sort of required as the main thread was driven by the IO)
04:44:20 <kosmikus> ?seen ndm
04:44:21 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 18h 4m 30s ago, and .
05:02:36 <alan_> what is rank 2 polymorphism in c++ terms.
05:04:01 * earthy doesn't even understand where to begin explaining that
05:04:34 <earthy> maybe 'imagine passing a templated function as an argument to another function'
05:04:43 <earthy> but that doesn't nearly cover it
05:04:57 <quicksilver> alan_: typically rank 2 polymorphism is when you have a function with rank-1 polymorphic arguments
05:05:14 <quicksilver> alan_: do you think you understand 'normal' polymorphism ?
05:09:49 <ToRA> @djinn (a -> b) -> a -> b
05:09:50 <lambdabot> f a = a
05:10:00 <ToRA> @djinn (forall a . a -> b) -> c -> b
05:10:00 <lambdabot> Cannot parse command
05:10:30 <ToRA> can djinn handle r2 polymorphism? or are there theoretic reasons why it can't?
05:12:20 <Saizan> good question
05:13:04 <earthy> istr there are
05:13:29 <ski> @djinn (forall a. a -> Not a) -> a -> Not (Not a)
05:13:30 <lambdabot> f _ a b = b a
05:13:37 <ski> @djinn (forall a. a -> b) -> c -> b
05:13:38 <lambdabot> -- f cannot be realized.
05:14:18 <ToRA> ah, got my spacing wrong
05:14:20 <ski> hmm
05:14:32 <ToRA> erm...i'm sure that last one can be realised?
05:14:56 <ski> yes, i think it can parse it, but not handle it ..
05:14:57 <alan_> quicksilver: myclass instance function1 = 1; myclass instance2 function1 = 2 etc.
05:15:29 <quicksilver> alan_: that's different, really
05:15:41 <quicksilver> alan_: classes are not needed to talk about rank1 vs rankn
05:15:49 <ski> @tell augustss to what extent can djinn handle higher-rank types ?
05:15:50 <lambdabot> Consider it noted.
05:15:55 <alan_> quicksilver: ok then overloads
05:16:11 <quicksilver> right, overloading is ad-hoc polymorphism
05:16:17 * ekidd would love a :djinn plugin for GHCI, that ran in the current module
05:16:18 <quicksilver> and type classes are a way of making overloading a bit more precise
05:16:28 <ToRA> would rank 2 ability need djinn to have a decision theory for 2nd order logic?
05:16:30 <quicksilver> ekidd: you can get lambabot-in-ghci
05:16:42 <quicksilver> ekidd: and it can use all plugins, including djinn
05:16:56 <ski> ToRA : i doubt it .. since there's no dependent types
05:17:06 <quicksilver> alan_: again, neither of these is really relevant to the rank1 vs rank n issue
05:17:06 <earthy> ekidd: called goa i.e. ghci on acid
05:17:16 <quicksilver> alan_: consider 'id'
05:17:16 <alan_> quicksilver: :(
05:17:18 <quicksilver> alan_: id x = x
05:17:22 <ekidd> quicksilver: But does that run in the current module's environment, or just the Prelude (or whatever)?
05:17:23 <alan_> quicksilver: no
05:17:24 <ski> ToRA : value quantification and type quantification is quite different
05:17:28 <quicksilver> alan_: that's the simplest kind of polymorphism
05:17:30 <alan_> quicksilver: not the id example
05:17:41 <alan_> quicksilver: :(
05:18:01 <Saizan> ekidd: just some predefined types, also it cannot work when you have typeclass contraints
05:18:01 <quicksilver> alan_: I don't know how to explain, because I don't know which bits you understand and which bits you don't
05:18:13 <ToRA> ski: ah ok
05:18:18 <mux> λX. λx:X. x
05:18:20 <alan_> quicksilver: ok then the id example
05:18:25 <quicksilver> ekidd: I'm not sure djinn supports extra axioms
05:18:48 <Saizan> ?help djinn
05:18:49 <lambdabot> djinn <type>.
05:18:49 <lambdabot> Generates Haskell code from a type.
05:18:49 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
05:19:00 <quicksilver> :t id
05:19:03 <lambdabot> forall a. a -> a
05:19:05 <ekidd> Saizan, quicksilver: I'd just love to see a djinn which could be run on real code, from within the ghci command-line. But I guess there are some theoretical obstacles to getting there.
05:19:15 <alan_> quicksilver: yep
05:19:16 <ski> @djinn-add raa :: Not (Not a) -> a
05:19:26 <quicksilver> alan_: id is truly polymorphic, it works at any type
05:19:28 <ekidd> Still, it would be marvelous if djinn worked like ':type'
05:19:35 <ski> @djinn Not (a,b) -> Either (Not a) (Not b)
05:19:36 <lambdabot> -- f cannot be realized.
05:19:53 <quicksilver> alan_: that's rank-1
05:20:08 <alan_> quicksilver: ok then
05:20:12 <quicksilver> :t \(x,y) -> (y,x)
05:20:15 <lambdabot> forall t t1. (t, t1) -> (t1, t)
05:20:19 <quicksilver> alan_: that's still rank 1
05:20:29 <quicksilver> alan_: it's truly polymorphic over two types
05:20:59 <alan_> quicksilver: right
05:21:02 <quicksilver> alan_: but (and this is the important bit) whenever you actually *use* those functions, you use them at a specific type
05:21:27 <quicksilver> alan_: you can't pass id around and use it at two types
05:21:46 <quicksilver> :t let f g = (g 4, g "foo") in f id
05:21:49 <lambdabot>     No instance for (Num [Char])
05:21:49 <lambdabot>       arising from the literal `4' at <interactive>:1:13
05:21:57 <quicksilver> hmm, ugly error message
05:22:05 <quicksilver> let's try an exaple which doesn't bring 'num' into the mess
05:22:05 <alan_> quicksilver: i never realized that
05:22:12 <quicksilver> :t let f g = (g (), g "foo") in f id
05:22:12 <ski> :t let f g = (g 'a', g False) in f id
05:22:15 <lambdabot>     Couldn't match expected type `[Char]' against inferred type `()'
05:22:15 <lambdabot>       Expected type: [Char] -> t
05:22:16 <lambdabot>     Couldn't match expected type `Bool' against inferred type `Char'
05:22:16 <lambdabot>       Expected type: Bool -> t
05:22:28 <quicksilver> alan_: if you want to do that, you need rank-2 polymorphism
05:22:41 <quicksilver> alan_: you need to specify f as 'taking a function of type forall a. a -> a'
05:22:52 <ski> :t let f :: (forall a. a -> a) -> (Char,Bool); f g = (g 'a', g False) in f id
05:22:54 <lambdabot> (forall a. a -> a) -> (Char,Bool); f g = (g 'a', g False) in f id :: (Char, Bool)
05:23:03 <ski> er
05:23:08 <ski> :t (let f :: (forall a. a -> a) -> (Char,Bool); f g = (g 'a', g False) in f id)
05:23:10 <lambdabot> (Char, Bool)
05:23:17 <quicksilver> alan_: in some sense, rank 2 is when you have a 'forall inside the brackets'
05:23:32 <quicksilver> alan_: which GHC permits via an extension, but it isn't in the core h98 language
05:24:03 <quicksilver> as demonstrated there by my beautiful, bikini-clas assistant
05:24:18 <Saizan> (so in h98 there's no way to have a rank2 function?)
05:24:29 <alan_> Saizan: apparently not
05:24:53 <alan_> quicksilver: quicksilver?
05:24:59 <quicksilver> Saizan: in h98-without-typeclasses, no. in h98-with-typeclasses I suspect it can be encoded
05:25:17 <quicksilver> typeclasses add a *lot* of expressitivity
05:25:28 * Saizan turns on the Oleg-signal
05:25:35 <hpaste>  Bas van Dijk annotated "MultiLine String literals" with "(no title)" at http://hpaste.org/1582#a1
05:25:36 <quicksilver> I'm no expert, though
05:26:21 <Cheery> @dice 1d8
05:26:22 <lambdabot> 1d8 => 6
05:26:55 <Cheery> @dice 1d8
05:26:56 <lambdabot> 1d8 => 4
05:27:01 <Cheery> @dice 1d8
05:27:02 <lambdabot> 1d8 => 3
05:27:07 <_blondy_> the best Spanish vidente visits his blog are very interesting rituals of love and many things but visitalo http://eltarotdesalem.blogspot.com/
05:27:57 <ToRA> ski: if rank 2 = system f  then it's all = (via c/h) to 2nd order intuistic logic
05:28:15 <Cheery> so... next things I could do would include: patterns, forth -monad(toy), opengl vertex combinators
05:28:52 <quicksilver> ToRA: system F has unrestricted quantification doesn't it?
05:28:55 <quicksilver> ToRA: i.e. rank N
05:29:23 <vincenz> intuistic = normal - law of excluded middle?
05:29:27 <Saizan> however in classical logic a proposition with an internal quantifier can be transformed in one with only outer quantifiers (reduction to normal form and skolemization), so this is not true for intuitionistic logic?
05:29:30 <ToRA> quicksilver: ah ok
05:29:34 <ski> ToRA : (iirc System F allows any rank) .. and 2nd order int. logic usually contains quantification over individuals, no ?
05:30:07 <quicksilver> yes, 2nd order int logic allows quantification over prepositions
05:30:43 <ToRA> yeah, so what does rank 2 correspond to?
05:31:11 <Cheery> Thought, that restarts and conditions -thing is important, I guess I'll add it to the list
05:32:18 <Saizan> ToRA: propositions with nested quantifiers, i think
05:32:44 <Saizan> still on variables though
05:32:52 <alan_> quicksilver: so, in summary. you add parenthesis and your a->a now becomes quantified
05:33:15 <quicksilver> alan_: yes
05:33:41 <quicksilver> alan_: and you move outside the safe core of haskell 98, too
05:33:47 <ski> @type runST
05:33:49 <lambdabot> forall a. (forall s. ST s a) -> a
05:33:59 <quicksilver> alan_: as earthy originally said, it's something like passing a templated function as an argument
05:34:06 <quicksilver> alan_: but *without* resolving the template
05:34:16 <quicksilver> alan_: like a function which can accept 'any templated function'
05:34:24 <ski> (the callee gets to resolve)
05:35:50 <quicksilver> the major reason that ML and H98 don't have rank 2 polymorphism by default isn't that it's hard to implement
05:35:58 <quicksilver> it's that it's hard to *infer* correctly
05:36:10 <quicksilver> and type-inference is deemed to be a nice thing to have
05:36:49 <alan_> quicksilver: types without inference is no fun.
05:36:53 <quicksilver> (I think it might be fair to see that until relatively recently it wasn't clear that rank-2 allowed you to write 'interesting programs' which rank-1 didn't allow. But the ST monad is a convincing example, and so it build fusion)
05:37:22 <alan_> quicksilver: build fustion?
05:37:36 <quicksilver> alan_: it's how ghc manages to write fast programs using lists
05:37:55 <quicksilver> > map (*2) . map (+1) . map (*3) $ [1,2,3]
05:37:57 <lambdabot>  [8,14,20]
05:38:02 <ski> @type build
05:38:04 <lambdabot> Not in scope: `build'
05:38:14 <quicksilver> alan_: with a crude semantics, you'd imagine that creates 2 intermediate lists before the final one
05:38:18 <quicksilver> alan_: four lists in total
05:38:20 <ski> @type GHC.Exts.build
05:38:22 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
05:38:24 <quicksilver> alan_: actually, in optimised GHC, it doesn't
05:38:26 <alan_> quicksilver: im not too famliar how ghc compiles
05:38:35 <quicksilver> alan_: GHC is able to 'optimise away' the intermediate lists
05:38:50 <quicksilver> alan_: and create code that generates the final answer as directly as you would in, say, C
05:39:03 <quicksilver> alan_: that optimisation is called 'foldr/build' and it's pretty clever
05:39:03 <ski> (static unboxing of lists, yay !)
05:39:17 <quicksilver> alan_: and build has a rank-2 type
05:39:54 <quicksilver> our good friends dons and dcoutts have implemented something *even cleverer* called stream fusion, which is what makes ByteStrings so damned fast
05:40:03 <quicksilver> and that also involves rank-2 types internally
05:40:34 <quicksilver> Which makes the haskell version of 'wc -l' actually faster than the C version
05:40:35 <quicksilver> go haskell!
05:42:17 <alan_> yes go haskell
05:42:23 <swiert> Does anyone know when associated types will make it into ghc?
05:42:23 <lambdabot> swiert: You have 1 new message. '/msg lambdabot @messages' to read it.
05:43:29 <mux> swiert: they should be here for 6.8
05:43:58 <mux> swiert: the GHC from the darcs repo (6.7.something) already has associated data types, but lacks associated type synonyms
05:44:11 <alan_> quicksilver: thanks for the lesson.
05:44:14 <quicksilver> alan_: when you understand a bit better, you might consider the following puzzle:
05:44:23 <dons> Cale: re. ayrnieu, he wasn't aware of how laziness is used to implement control structures :/
05:44:27 <quicksilver> :t let build g = g (:) [] in build
05:44:30 <lambdabot> forall a a1 t. ((a -> [a] -> [a]) -> [a1] -> t) -> t
05:44:41 <quicksilver> :t GHC.Exts.build
05:44:43 <dons> so wve got a vigorous commentator who doesn't know what he's criticising.
05:44:44 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
05:44:47 <swiert> mux: Any idea what the timeline is on 6.8?
05:44:52 <quicksilver> alan_: in fact, those builds are "the same"
05:44:54 <ski> @src GHC.Exts.build
05:44:54 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
05:44:58 <quicksilver> alan_: but GHC infers the wrong type
05:45:02 <quicksilver> alan_: you might think about why :)
05:45:02 <swiert> There was  a thread somewhere recently, but I can't remember.
05:45:09 <mux> swiert: I don't know, the GHC wiki (trac) probably has some info on the subject
05:45:11 <mux> @where ghc
05:45:11 <lambdabot> http://haskell.org/ghc
05:45:35 <obsethryl> fello haskell users, are there any debian stable (etch 4.0) repositories especially for haskell - related software?
05:45:40 <mux> swiert: may I ask why you are interested in associated types?
05:45:41 <obsethryl> fellow*
05:46:32 <earthy> deb http://haskell-unsafe.alioth.debian.org/archive/i386 stable
05:46:34 <lambdabot> Title: Index of /archive/i386
05:46:52 <obsethryl> earthy: excellent, is that to consider always bleeding - edge?
05:47:05 <earthy> that's not the best one though, as it still has ghc 6.4
05:47:11 <obsethryl> ouch
05:47:17 <earthy> I still point to testing in that repo
05:47:19 <earthy> and it has ghc 6.6
05:47:24 <earthy> and works *splendidly* on etch
05:47:29 <obsethryl> i have ghc6.6 now through the regular apt ones
05:47:59 <merus> ghc6.6 is amazing :D
05:47:59 <obsethryl> earthy: yes i like debian a lot but it may be a problem if i have to compile packages all the time for stuff like haskell, so better ask first
05:49:46 <earthy> obsethryl: it is almost trivial to compile packages for haskell
05:50:03 <earthy> plus, ISTR there being a tool to go from cabalized to .deb
05:50:12 <obsethryl> so i noticed
05:50:14 <obsethryl> oh
05:50:29 <obsethryl> can you show me around that cabal - > deb thing?
05:51:43 <obsethryl> i am a bit new at this :)
05:52:34 <swiert> mux: I wrote some code recently that needs overlapping instances.
05:52:41 <swiert> I think I can avoid that with associated types.
05:53:04 <mux> okay
05:53:38 <earthy> obsethryl: google gives me http://www.n-heptane.com/nhlab/repos/cabalDebianTemplate/ but I don't know its current status
05:53:40 <lambdabot> Title: Index of /nhlab/repos/cabalDebianTemplate
05:54:30 <obsethryl> earthy: okie i will check that out, thnx
05:58:10 <tom_> I'm trying to make a 128mb DiffUArray of Word32s all initialized to 0 using "listArray (0, 33554431)  (repeat 0)" but it's quite slow, is there a better way of doing that?
05:59:39 <kalven> calloc(134217724,1);
06:00:07 <tom_> I can do that from within haskell?
06:00:21 <kalven> oh haskell. dunno
06:01:05 <AStorm> kalven: there is, maybe do some newArray instead :>
06:03:59 <norpan> yeah, there should really be some method to create a zeroed array
06:04:21 <norpan> for the normal datatypes
06:06:37 <matthew_-> obsethryl: also look at the debian package called haskell-devscripts
06:07:28 <tom_> I'm  finding DiffUArray a bit confusing, I keep getting slow downs when I don't expect them
06:09:00 <tom_> Say i have an array a, I call "a ! 0" to make sure it's actually allocated (unboxed arrays are strict on all there elements, right?) then i do "let b = a // [(0,1)] to update an element then I call "b ! 0"
06:09:21 <tom_> Now I'd expect that last b ! 0 to be very fast, but instead it pauses for a second or two
06:09:23 <obsethryl> matthew_-: thanks i will
06:10:42 <tom_> Anyone got any idea what's wrong? // and ! are supposed to be fast on a DiffUArray I thought
06:14:46 <chessguy> 'morning
06:17:39 <ndm> @seen MarcWeber
06:17:39 <lambdabot> MarcWeber is in #haskell and #darcs. I don't know when MarcWeber last spoke.
06:17:46 <ndm> hi MarcWeber
06:17:47 <lambdabot> ndm: You have 2 new messages. '/msg lambdabot @messages' to read them.
06:17:50 <ndm> @messages
06:17:51 <lambdabot> Cale said 19h 18m 49s ago: I just found this in a Google blog search http://forums.techguy.org/all-other-software/566277-winhugs-wont-uninstall.html#post4662133
06:17:51 <lambdabot> ski said 15h 44m 55s ago: maybe you could use 'All work and no play makes Jack a dull boy.' as some kind of slogan for 'Play' ?
06:18:26 <ndm> @tell ski I like it! Although my supervisor doesn't like the name Play, so thats still being decided upon...
06:18:26 <lambdabot> Consider it noted.
06:18:34 <ski> (:
06:18:35 <lambdabot> ski: You have 1 new message. '/msg lambdabot @messages' to read it.
06:18:43 <ski> @messages
06:18:43 <lambdabot> ndm said 17s ago: I like it! Although my supervisor doesn't like the name Play, so thats still being decided upon...
06:19:16 <Saizan> tom_: unboxed arrays are strict in their elements but not strict themselves, so let b = a // [(0,1)]  still means allocating a thunk that get's evaluated only when b is demanded
06:19:25 <ndm> @tell Cale a well known bug, alas I screwed up the naming and an .html file got renamed as the uninstaller.exe - i think Ross will be making a new release, and i'll make sure its fixed for then
06:19:26 <lambdabot> Consider it noted.
06:20:06 <tom_> thanks Saizan, but shouldn't (//) be a fast operation as well for a diff array?
06:21:19 <Saizan> tom_: are you judging time on ghci? arrays get fast with optimizations e.g. -O2
06:21:45 <tom_> ah, yes I am, I'll try compiling
06:22:58 <Saizan> and make sure you force qieried values before modifying the array again
06:23:04 <Saizan> *queried
06:23:32 <tom_> ah, I'm not doing that right now either
06:23:57 <quicksilver> ghci is a very poor judge of performance
06:24:00 <tom_> Do you know if it's ok to update multiple values with accum?
06:24:48 <Saizan> i think so
06:28:31 <dozer> when using something like "class Foo a b | a -> b" am I required to parameterise a over b?
06:28:55 <quicksilver> not exactly
06:29:07 <quicksilver> it has to be the case that the type of a determines the type of b
06:29:12 <quicksilver> so for any given a, there can only be one b
06:29:17 <quicksilver> that might be because one contains the other
06:29:29 <quicksilver> but it might just be because 'a' is a constant type, for example
06:34:09 <chessguy> are functional dependencies H98?
06:34:14 <ski> no
06:34:23 <Saizan> neither MTPC
06:34:26 <osfameron> what's a fundep ?
06:34:43 <Saizan> what dozer was aking about
06:34:53 <quicksilver> osfameron: a dependency between types to constrain a type class with multiple parameters
06:35:12 <quicksilver> osfameron: turns out that multiple paramter type classes aren't (very) useful without some way to limit the types
06:35:13 <osfameron> ah.  advanced stuff ;-)  thanks
06:35:32 <quicksilver> osfameron: but fundeps are the subject of some controversy and may never be standardised
06:36:06 <dozer> thanks quicksilver
06:37:05 <chessguy> what's the controversy?
06:37:33 <dozer> I have a Class that's effectively "class Foo a b c d | a -> c, b -> d" but where it doesn't make sense to expose that a it parameterised over c or b over d. Actually, it would be impossible to expose this without making a and c significantly less polymorphic.
06:37:56 <Saizan> (with depended types i could write something like apply f [a,b,c] = f a b c for lists of arbitrary length, right?)
06:38:09 <Saizan> s/depended/dependent/
06:38:41 <quicksilver> chessguy: that fundeps are ugly; and as a relational construct are out of theme in a functional language
06:39:17 <quicksilver> chessguy: that's pretty superficial but it's all I know; I don't have a deep insight into the issue
06:39:27 <chessguy> no problem
06:39:27 * ski thought fundeps make relations more functional ..
06:40:36 <magnus> xmonad jammed my keyboard again, but I can't reproduce it now. It seems to happen when I hit alt-p and type without waiting for dmenu to start up
06:40:42 <ski> Saizan : i believe so
06:41:09 <quicksilver> Saizan: given sufficient constructions in the type layer, yes
06:42:24 <quicksilver> Saizan: you can, in fact, encode that in haskell with type classes, too, if you're happy to get a runtime not compiletime error if the list is the wrong length
06:42:26 <Saizan> the length of the list should be known statically?
06:42:59 <Saizan> quicksilver: i'm emulating it with TH
06:43:13 <quicksilver> Saizan: you don't need TH; you can do it in pure haskell
06:43:24 <MarcWeber> @tell ndm I've sent you another patch
06:43:24 <lambdabot> Consider it noted.
06:43:25 <quicksilver> it's roughly similar to how printf works
06:43:38 <chessguy> ?seen ndm
06:43:38 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 14m 37s ago, and .
06:43:51 <chessguy> wtf
06:43:54 <Saizan> well i'm yet using TH here to write an automatic derivation so it's more natural
06:44:05 <matthew_-> I am always shocked by the number of papers that are concerned by the lack of a type safe printf
06:44:20 <matthew_-> just use a better way of outputting stuff people! ;)
06:44:23 <chessguy> <ndm> @tell Cale a well known bug, alas I screwed up the naming and an .html file got renamed as the uninstaller.exe - i think Ross will be making a new release, and i'll make sure its fixed for then
06:44:35 <chessguy> just about 20 minutes ago
06:44:35 <quicksilver> matthew_-: someone wrote a type-safe printf in this channel a few weeks back
06:44:49 <tom_> Is there a way to make a list strict? I want to be sure the whole thing has been evaluated before I use it
06:45:12 <chessguy> oh, he did leave after that, my bad
06:45:19 <matthew_-> TomMD: length list `seq` return ()
06:45:37 <MarcWeber> tom_: There are some examples how to do it. one is applying seq to each element.
06:45:39 <matthew_-> err, not sure what happenend then, sorry, wrong nick.
06:46:48 <tom_> thanks
06:47:03 <Saizan> > length (replicate 10 undefined) `seq` Just ()
06:47:05 <lambdabot>  Just ()
06:47:35 <quicksilver> foldr1 seq
06:48:03 <quicksilver> although maybe that stricts all but the last element, I'm slightly unsure
06:48:18 <Saizan> i don't think so
06:48:33 <Saizan> > foldr1 seq [1,undefined]
06:48:34 <lambdabot>  Undefined
06:48:49 <matthew_-> oh, eek. Sorry, I thought dons had told be that length is enough to force the evaluation of the whole list.
06:48:51 <Saizan> i fails on empty list instead
06:48:52 <quicksilver> > foldr1 seq [1,undefined] `seq` ()
06:48:52 <chessguy> heh. i've never seen 'strict' used as a verb before :)
06:48:54 <lambdabot>  Undefined
06:49:04 <quicksilver> matthew_-: length forces the whole spine
06:49:07 <quicksilver> matthew_-: but not the values
06:49:51 <matthew_-> quicksilver: ok, I the case I had (forcing the content from hGetContents), length would have been enough then?
06:49:59 <chessguy> so it might leave the list as [foo 2, bar 3, bah 4]
06:50:11 <quicksilver> matthew_-: yes, because of the way getcontents works
06:50:14 <chessguy> that's enough to get the length, but it's not fully evaluated
06:50:18 <quicksilver> matthew_-: forcing the length forces it to be read from the file
06:50:42 <matthew_-> gotch, whereas without the length, it would just be evaluated to (e1:restOfList)
06:50:43 <quicksilver> matthew_-: that's a strictness property of getcontents, rather than of lengthm, though
06:50:51 <matthew_-> ok.
06:51:12 <quicksilver> matthew_-: no, without the length it's evaluated to (some:amount:which:the:os:feels:like:returning:in:one:go:theRest)
06:51:25 <quicksilver> possibly a 'line' or a 'disk block' or suchlike
06:51:50 <matthew_-> right, sorry - I was meaning in general now, not specific to hGetContents.
06:51:55 * quicksilver nods
06:52:06 <quicksilver> a given function can have strictness properties all of its own
06:52:12 <quicksilver> externally, all we can do is 'force some bits'
06:52:20 <quicksilver> we can't tell if those bits might force other bits, or not
06:52:27 <quicksilver> so we have a lower bound on how much we forced
06:52:30 <quicksilver> but that's all
06:53:16 <ndm> @seen MarcWebber
06:53:17 <lambdabot> I haven't seen MarcWebber.
06:53:21 <ndm> @seen MarcWeber
06:53:22 <lambdabot> MarcWeber is in #haskell and #darcs. I last heard MarcWeber speak 7m 43s ago.
06:53:33 <chessguy> ndm: check @messages
06:53:43 <ndm> hi MarcWeber
06:53:43 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
06:53:45 <ndm> @messages
06:53:46 <lambdabot> MarcWeber said 10m 21s ago: I've sent you another patch
06:54:10 <ndm> MarcWeber: have you got time to go into haskell-overflow for a tagsoup design discussion?
06:54:35 <chessguy> ooooh
06:54:38 * chessguy listens in
06:56:01 <hpaste>  Tom pasted "Bloom filter" at http://hpaste.org/1583
06:56:41 <tom_> Anyone fancy having a look at the code I've been working on and letting me know what you think?
06:57:28 <desp> I like how Bloom.bloom sounds.
06:58:09 <tom_> yeah :)
06:58:11 <chessguy> what's a Bloom?
06:59:11 <tom_> It's a bloom filter, you add keys to it and then it can tell if you a key has been added before with a certain false positive rate
06:59:58 <tom_> It's quite size effcient for when you need to key track of whether you've seen a large number of things before and you don't mind the occasional false positive
07:00:20 <tom_> http://www.cs.wisc.edu/~cao/papers/summary-cache/node8.html
07:00:21 <lambdabot> Title: Bloom Filters - the math
07:00:51 <chessguy> mmm. why not just use a bayesian filter?
07:01:04 <chessguy> @go paul graham plan spam
07:01:06 <lambdabot> http://www.paulgraham.com/spam.html
07:01:06 <lambdabot> Title: A Plan for Spam
07:02:17 <tom_> Different kind of thing, a naive bayesian classifier (as used in a plan for spam) is for saying if something is more "like" a set of one things than another set of things
07:02:28 <tom_> a Bloom filter is more like a set
07:03:03 <chessguy> interesting
07:03:35 <tom_> Quite useful for web crawlers when you need to keep track of a quite massive amount of previously visited pages
07:05:08 <tom_> as you can see from the tables on that link you really can keep track of a quite huge amount of items with a very low error rate in quite a modest amount of memory
07:16:25 <szabi_> @seen LeCamarade
07:16:25 <lambdabot> I saw LeCamarade leaving #haskell 22h 28m 22s ago, and .
07:39:06 <sproingie> has anyone gotten wxhaskell to work on ghc6-6 + wx 2.6?  not sure which version of wx i should be using actually
07:39:29 <sproingie> doesn't even compile with wx 2.8
07:42:06 <earthy> sproingie: I have.
07:42:14 <earthy> on Mac OS X, no less
07:42:47 <earthy> but, see also http://www.haskell.org/haskellwiki/WxHaskell/Install
07:42:47 <sproingie> it compiles for me, but it has an unresolved symbol
07:42:48 <lambdabot> Title: WxHaskell/Install - HaskellWiki
07:43:06 <sproingie> chuck@doorstop:~/proj/wxhaskell/wxhaskell/samples/wx$ runhaskell BouncingBalls.hs
07:43:06 <sproingie> can't load .so/.DLL for: wxc-gtk2.6.3-0.10.1 (/usr/lib/libwxc-gtk2.6.3-0.10.1.so: undefined symbol: _ZN10wxGLCanvasC1EP8wxWindowiRK7wxPointRK6wxSizelRK8wxStringPiRK9wxPalette)
07:44:31 <sproingie> gotta love C++ mangled symbols
07:45:22 * earthy grins
07:45:25 <desp> hehe
07:45:47 <earthy> that looks as though your wxWidgets is slightly off.
07:46:26 <sproingie> i could try compiling wx myself
07:46:44 <sproingie> would rather use the one from apt tho
07:47:31 <earthy> ah, you're on linux
07:47:34 <vincenz> @join oasis
07:47:37 <vincenz> @join #oasis
07:47:47 * earthy knows that the windows thingy wants 2.4
07:47:52 <earthy> as 2.6 is troublesome
07:48:11 <earthy> but, I've succesfully built wxHaskell against 2.6 on redhat
07:48:16 <earthy> so that should be doable
07:48:35 <earthy> (don't currently have access to that machine though)
07:49:11 <sproingie> ubuntu here.  wx does work tho, this symbol is missing from wxhaskell's lib
07:49:21 * earthy nods
07:49:28 <earthy> have you compiled with --with-opengl ?
07:49:36 <sproingie> interestingly, configure said "with openGL: no"
07:49:52 <earthy> yeah, somehow that's necessary
07:49:57 <earthy> wait, lemme dig in my mail
07:50:10 <sproingie> ah ... nope, didn't use that
07:50:29 <sproingie> there's also an stc option ... what's stc?
07:51:33 <earthy> styled text control? :)
07:52:12 <chessguy> surreptitiously threaded cuneiforms
07:52:13 <earthy> ah yup. you need --with-opengl because if you don't wxHaskell won't get linked to all the wxWidgets libs
07:52:43 <chessguy> ?vera STC
07:52:46 <lambdabot> *** "stc" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
07:52:46 <lambdabot> STC
07:52:46 <lambdabot>      Science and Technology Center (NSF, USA)
07:52:46 <lambdabot>  
07:52:46 <lambdabot> *** "stc" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
07:52:48 <lambdabot> [15 @more lines]
07:52:55 <sproingie> indeed.  it didn't compile til i installed glu and such
07:53:03 <sproingie> i just didn't notice that configure never picked it up after
07:53:17 * earthy nods
07:53:33 <sproingie> hopefully i don't need stc too :)
07:54:28 <sproingie> chessguy: a cuneiform input method would be ... neat
07:55:00 <AStorm> yeah, I could count my cows :P
08:10:38 <hpaste>  dozer pasted "class operation composition problem" at http://hpaste.org/1585
08:11:03 <dozer> I've hit this problem - is there a way to work arround this?
08:12:08 <dozer> perhaps I can fix it by floating the type of 'b' in somehow?
08:13:08 <Saizan> ?type mappend
08:13:10 <int-e> doFooBar :: (Foo a b, Bar b c) => b -> a -> c; doFooBar _ = doBar . doFoo  might work for you. (using a phantom argument of the right type when calling)
08:13:14 <lambdabot> forall a. (Monoid a) => a -> a -> a
08:14:24 <quicksilver> dozer: somehow it needs to know which instance to use
08:14:33 <quicksilver> dozer: so you need to give it some information to deduce which 'b' to use
08:14:40 <quicksilver> dozer: a phantom argument would be one way
08:15:23 <dozer> ok, thanks
08:16:35 <int-e> dozer: functional dependencies may be an alternative. either a -> b in Foo, or c -> a in Bar, or maybe a  class (Foo a b, Bar b c) => FooBar a b c | a c -> b  with proper instances.
08:18:56 <dozer> this works: doFooBar (_::b) a = doBar b where (b::b) = doFoo a
08:19:44 <int-e> dozer: oh sorry. right.
08:21:22 <Saizan> `func` operators are left or right associative?
08:21:47 <quicksilver> left
08:21:53 <int-e> you can change that with an infix* declaration
08:22:20 <Saizan> int-e: even for normal function with `` syntax?
08:22:29 <int-e> infixr 5 `xxx`  works.
08:22:32 <int-e> Saizan: yes
08:22:40 <Saizan> :O
08:23:26 <Saizan> i'm trying to build a "reader" monoid
08:26:24 <roconnor> @instances Monoid
08:26:29 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
08:26:53 <roconnor> @src Dual
08:26:54 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
08:26:58 <roconnor> @hoogl Dual
08:26:59 <lambdabot> Maybe you meant: hoogle hoogle+
08:27:04 <roconnor> @hoogle Dual
08:27:05 <lambdabot> No matches found
08:30:21 <dmhouse> ?help hoogle+
08:30:22 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
08:30:44 <hpaste>  dozer pasted "with classes" at http://hpaste.org/1586
08:31:01 <dozer> can't make this work with a 'joiner' class though
08:32:16 <Carmethene> @type hoogle
08:32:18 <lambdabot> Not in scope: `hoogle'
08:32:22 <Carmethene> heh, shame ;)
08:32:23 <dozer> it accepts it if I explicitly say fooBar a = doBar (b::Float) where b = doFoo a
08:37:17 <dozer> ok, now that I want to invoke the function with the dummy argument, how do I do it? I need to find a /real/ value to put in there?
08:37:42 <int-e> dozer: well, with the joiner class, you can still define a dummy argument helper,  fooBarHelper :: FooBar a b c => b -> a -> c  (as before) and then use  fooBarHelper undefined
08:38:45 <int-e> dozer: you can use   (undefined :: <proper type>)
08:38:50 <dozer> ah, brill
08:39:32 <dozer> another day, another bit of haskell occultia :)
08:39:37 <AStorm> Or just use 0
08:39:38 <AStorm> :>
08:39:48 <AStorm> looks good too.
08:39:55 <AStorm> Or define DUMMY = 0
08:40:10 <AStorm> or even not define it :P
08:40:19 <AStorm> just make a proper dummy datatype
08:40:52 <dozer> @type O
08:40:58 <lambdabot> Not in scope: data constructor `O'
08:41:07 <dozer> @type 0
08:41:09 <lambdabot> forall t. (Num t) => t
08:41:25 <dozer> gotcha
08:42:48 <sproingie> YAY, wxhaskell works now.  thanks earthy!
08:43:02 * sproingie idles now to do that thing he gets paid for
08:48:31 <dozer> thanks guys, added dummy param in 2 places, and my code compiles happily :)
08:49:32 <quicksilver> dozer: :)
08:50:47 <dozer> ah, if Foo a b | a -> b, and also Bar b c | c -> b, it is happy
08:51:03 <dozer> pitty this isn't what I actually have :)
08:55:56 <int-e> hmm. why would it need both?
08:58:39 <pitecus> I have a function of the following type: (Int, String) -> State (Map.Map Int String) String . How do i get one of type Maybe (Int,String) -> State (Map.Map Int String) (Maybe String) from it?
08:59:09 <pitecus> liftM does the wrong thing...
08:59:30 <AStorm> use some flips
08:59:42 <pitecus> how?
08:59:43 <AStorm> then liftM will do the right thing
08:59:50 <pitecus> flip liftM?
08:59:55 <AStorm> Maybe.
09:00:00 <AStorm> :t flip liftM
09:00:03 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => m a1 -> (a1 -> r) -> m r
09:00:08 <AStorm> :t liftM
09:00:10 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
09:01:27 <pitecus> doesnt look right
09:03:58 * dmead is away: thinking about monads
09:04:28 <thetallguy> dmead: Still?  Weren't you doing that last night?
09:04:38 <thetallguy> dmead: Just kidding.
09:04:57 <sphynx> hi guys!
09:05:11 <int-e> @type \f -> maybe (return Nothing) (liftM Just . f)
09:05:14 <lambdabot> forall a1 (m :: * -> *) a. (Monad m) => (a -> m a1) -> Maybe a -> m (Maybe a1)
09:05:32 <AStorm> :type maybe
09:05:38 <AStorm> :t maybe
09:05:40 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
09:05:42 <ski> @hoogle fmapM
09:05:42 <lambdabot> Data.FunctorM.fmapM :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m (f b)
09:05:43 <lambdabot> Data.FunctorM.fmapM_ :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m ()
09:05:51 <AStorm> Yep, fmap is certainly that.
09:05:54 <ddarius> :t \f -> return . fmap f
09:05:56 <lambdabot> forall (m :: * -> *) a b (f :: * -> *). (Monad m, Functor f) => (a -> b) -> f a -> m (f b)
09:06:01 <int-e> ski: oh. is that new?
09:06:11 <AStorm> int-e: nope
09:06:38 <ddarius> Oh, it is an a -> m b
09:06:40 <int-e> fmapM it is then.
09:07:03 <ddarius> @src fmapM
09:07:04 <lambdabot> Source not found. Take a stress pill and think things over.
09:07:06 <int-e> @src Data.FunctorM.fmapM
09:07:07 <lambdabot> Source not found. Just what do you think you're doing Dave?
09:07:10 <quicksilver> pitecus: liftM.liftM, I suspect
09:07:22 <sphynx> I have a question about sorted list. I need to find a value in a sorted list, but because I use usual list, time of search is growing linearly. How should I show that this list is sorted, what data structure should I use? thanks!
09:07:25 <AStorm> @src fmap
09:07:26 <lambdabot> Source not found. stty: unknown mode: doofus
09:07:27 <quicksilver> pitecus: where one liftM is instantiated to 'State' and the other to 'Maybe'
09:07:29 <AStorm> Blah?
09:07:40 <int-e> NOTE: This module is DEPRECATED. The classes in Data.Foldable and Data.Traversable provide a more general interface. hmm.
09:07:42 <AStorm> @src Data.Functor.fmapM
09:07:43 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
09:07:51 <ski> @src Maybe Data.FunctorM.fmapM
09:07:51 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
09:07:52 <quicksilver> sphynx: probably Data.Set
09:07:59 <AStorm> @src Maybe
09:07:59 <lambdabot> data Maybe a = Nothing | Just a
09:08:03 <AStorm> :p
09:08:08 <pitecus> I get  this with liftM . liftM: (Monad m, Monad m1) =>m (m1 (Int, String)) -> m (m1 (State (Map.Map Int String) String))
09:08:16 <AStorm> :P
09:08:28 <sphynx> quicksilver, ok, I will try. thanks
09:08:50 <ddarius> pitecus: fmapM seems to be what you want.
09:09:22 <int-e> @type mapM
09:09:25 <lambdabot>     Ambiguous occurrence `mapM'
09:09:25 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
09:09:32 <pitecus> ok ddarius that looks ok
09:09:34 <int-e> @type Data.Traversable.mapM
09:09:37 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
09:10:44 <AStorm> fmapM is more generic version of that
09:10:54 <ddarius> @instances Traversable
09:10:56 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
09:11:06 <int-e> > Data.Traversable.mapM (\x -> [x,x]) (Just 3)
09:11:08 <lambdabot>  [Just 3,Just 3]
09:13:09 <pitecus> its deprecated tho....
09:13:19 <int-e> Data.Traversable isn't.
09:13:39 <Saizan> sphynx: to be able to exploit O(log n) search you'd need an array
09:13:45 <quicksilver> sphynx: not true
09:13:48 <quicksilver> Saizan: not true
09:13:51 <Saizan> or a tree
09:13:57 <quicksilver> Saizan: Data.Set uses a tree, which is O(log n)
09:14:02 <quicksilver> Saizan: which is why I referred him to that :)
09:14:11 <sphynx> @docs Data.Set
09:14:12 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Set.html
09:14:22 <Saizan> oh, missed your reply
09:14:38 <quicksilver> :)
09:15:59 <Saizan> do you think is bad to have a mappend that works only if the last appended element has a particular contructor?
09:17:07 <quicksilver> 'bad'? Well it's not a Monoid anymore, that's for sure...
09:17:24 <quicksilver> but why not make it a monoid in 'the thing under the constructor'
09:17:28 <quicksilver> or maybe I didn't understand you
09:19:03 <sphynx> Set isn't instance of Monad, am I right? So I can't use it like x <- Set.fromList [1..10] in list comprehensions
09:19:05 <Saizan> i have this: data Compose a = Empty | One a | Cmp (a -> a -> a) a | CmpEmpty (a -> a -> a), and mappend basically use the (a -> a -> a) to append the values, the identity is Empty
09:19:26 <Saizan> sphynx: no, it's not
09:19:55 <quicksilver> sphynx: no, you would use toList in the comprehensions
09:20:07 <ski_> no monad comprehensions :(
09:20:27 <Saizan> so mappend (One _) (One _) is undefined
09:21:28 <sphynx> cool, it works faster with data.Set!
09:21:49 <sphynx> 1.5 seconds vs ~30 seconds with List
09:22:08 <Saizan> maybe i need something like Wait (( a -> a -> a) -> a)   so that  mappend (One a) (One b) = Wait (\f -> f a b) :O
09:39:38 * kc5tja is trying to install generic binaries for GHC on my work workstation, which is x86_64, but for which various libraries it needs doesn't exist in the local apt-get mirror.  And, I have no particular intention to install new sources.  
09:40:00 <mdmkolbe-work> @djinn a->a
09:40:01 <lambdabot> f a = a
09:40:02 <kc5tja> So I'm trying to install the 32-bit version of GHC (I note also that GHC 6.4 is also 32-bit on this box), and I'm encountering to end of errors.
09:40:17 <mdmkolbe-work> @djinn [Maybe a] -> a
09:40:17 <lambdabot> -- f cannot be realized.
09:40:23 <kc5tja> Is there a way to _force_ the build at the ./configure stage, to use 32-bit architecture?
09:40:55 <mdmkolbe-work> @djinn (a -> Maybe b) -> [a] -> [b]
09:40:56 <lambdabot> -- f cannot be realized.
09:41:03 <mdmkolbe-work> @djinn [Maybe a] -> [a]
09:41:04 <lambdabot> -- f cannot be realized.
09:41:27 <mdmkolbe-work> @hoogle [Maybe a] -> [a]
09:41:28 <lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
09:41:32 <basti_> @djinn Int
09:41:33 <lambdabot> -- f cannot be realized.
09:41:36 <basti_> :D
09:41:43 <ski_> 'djinn' doesn't understand lists
09:42:02 <ski_> @djinn ()
09:42:03 <lambdabot> f = ()
09:42:11 <mdmkolbe-work> @hoogle (a -> Maybe b) -> [Maybe a] -> [b]
09:42:12 <lambdabot> No matches, try a more general search
09:42:15 <ddarius>  @djinn doesn't handle recursive types like []
09:42:33 <mdmkolbe-work> @hoogle [Maybe a] -> (a -> Maybe b) -> [b]
09:42:34 <lambdabot> No matches, try a more general search
09:42:57 <mdmkolbe-work> @src Maybe.catMaybes
09:42:58 <lambdabot> Source not found. The more you drive -- the dumber you get.
09:43:10 <mdmkolbe-work> @source Maybe.catMaybes
09:43:11 <lambdabot> Maybe.catMaybes not available
09:43:15 <fantasma> @botsnack
09:43:15 <lambdabot> :)
09:43:28 <ski_> @src catMaybes
09:43:29 <lambdabot> catMaybes ls = [x | Just x <- ls]
09:43:38 <fantasma> @seen
09:43:59 <mdmkolbe-work> does lambdabot have a wiki page?  It seems like it could use one as I always forget all the tricks to using it.
09:44:08 <ddarius> Anyone know of a good sizeable introduction to modal logic available online?
09:44:28 <mdmkolbe-work> @desuger f x = x
09:44:28 <lambdabot> Unknown command, try @list
09:45:21 <sioraiocht|sleep> @docs array
09:45:22 <lambdabot> array not available
09:45:28 <sioraiocht|sleep> @docs Data.Arary
09:45:29 <lambdabot> Data.Arary not available
09:45:32 <sioraiocht|sleep> @docs Data.Array
09:45:33 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
09:46:01 <sioraiocht|sleep> @docs Data.Sequence
09:46:02 <lambdabot> Data.Sequence not available
09:48:09 <ski_> @djinn a -> (a -> Either x b) -> (x -> o,b -> Either x o) -> o
09:48:10 <lambdabot> f a b (c, d) =
09:48:10 <lambdabot>     case b (raa (\ e -> e a)) of
09:48:10 <lambdabot>     Left f -> c f
09:48:10 <lambdabot>     Right g -> case d g of
09:48:10 <lambdabot>                Left h -> c h
09:48:12 <lambdabot>                Right i -> i
09:50:02 <ski_> err
09:50:25 <ski_> @djinn-clr
09:50:26 <lambdabot> Plugin `djinn' failed with: IRCRaised Data.ByteString.last: empty ByteString
09:50:49 <ski_> argh, begone 'raa' !
09:52:15 * ski_ shakes fist
09:54:18 <hpaste>  kc5tja pasted "On fresh download, GHC 6.6, X11 package refuses to configure, much less build." at http://hpaste.org/1587
09:54:56 <ski_> (hmpf .. 'raa (\e -> e a)' is actually same as just 'a', here ..)
09:55:25 <earthy> frigging heck
09:55:25 <kc5tja> If anyone has any experience with the X11 package on Cabal, I'm having major issues getting it to build.  I've tried it with GHC 6.4 and 6.6, and in both cases, it's failing to configure.  It looks like the X11 build on Cabal is broken.
09:55:30 <bos> kc5tja: what version of cabal do you have, and what version of X11 are you trying?
09:55:44 <bos> i built the latest X11 just yesterday, no problem.
09:55:44 <fantasma> everyone is having issues building X11 it seems
09:55:59 <earthy> not me
09:56:04 <earthy> but I don't care about X11. ;)
09:56:29 <fantasma> kc5tja: try upgrading to version 1.1.7 of cabal from darcs head
09:57:05 <bos> yeah, that's likely to be the problem.
09:58:53 <fantasma> and if upgrading doesn't work try using DefaultInstall.lhs from here: http://darcs.haskell.org/cabal/DefaultSetup.lhs
09:59:09 <kc5tja> bos: I grabbed the X11 package from here: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/X11-1.2
09:59:12 <lambdabot> http://tinyurl.com/26np6m
09:59:25 <kc5tja> Sorry, I didn't actually use "Cabal" as an executable.
09:59:27 <bos> kc5tja: i'm using cabal from darcs and ghc 6.6, and it works fine.
09:59:34 <kc5tja> I grabbed it directly from the site.
09:59:36 <bos> cabal isn't an executable.
09:59:56 <bos> you ought to try the darcs head of cabal.
10:00:07 <kc5tja> OK, well, like I said, I tried it with GHC 6.6, and it still produces the same error.
10:00:30 <kc5tja> @where cabal
10:00:30 <lambdabot> http://www.haskell.org/cabal
10:00:31 <fantasma> kc5tja: do the following ``darcs get http://darcs.haskell.org/cabal''
10:01:11 <kc5tja> Yes, I know how to use darcs.  :)
10:01:20 <kc5tja> Let me catch up with the conversation first.
10:01:20 <fantasma> i know ;)
10:02:07 <kc5tja> So, what exactly _is_ Cabal if not an executable or package manager?
10:02:19 <fantasma> it's a set of libraries
10:02:27 <fantasma> that build things for you
10:02:50 <kc5tja> OK, to me, that implies a binary executable of some kind, so I'll just agree to say binaries then.
10:03:16 <fantasma> hmm
10:03:28 <kc5tja> But, bos claims that GHC 6.6's cabal works for him, and for me, it's producing the errors given on the hpaste.
10:03:34 <kc5tja> So, I'm inclined to believe it's not cabal.
10:03:44 <fantasma> bos uses cabal from darcs head
10:03:49 <fantasma> which is version 1.1.7
10:03:56 <bos> right.
10:03:56 <fantasma> the cabal you have with default GHC is 1.1.6
10:04:29 <Philippa> kc5tja: apps come with a program that uses cabal, so there isn't a distributed binary
10:05:04 <fantasma> the only thing that you ever execute is a Setup.[l]hs file
10:05:44 <Philippa> which is normally interpreted
10:08:15 <kc5tja> cd cabal-install     && mkdir -p dist/tmp && ghc --make -cpp -Wall -i.. -odir dist/tmp -hidir dist/tmp Setup.lhs -o setup && ./setup configure --ghc --with-compiler=ghc --prefix=/usr/local && ./setup build
10:08:19 <kc5tja> /bin/sh: line 0: cd: cabal-install: No such file or directory
10:08:22 <kc5tja> make: *** [build-stamp] Error 1
10:08:24 <kc5tja> Cabal won't even build.  :(
10:08:26 <kc5tja> root@sfalvo:/usr/local/google/cabal#
10:08:38 <fantasma> cabal-install is not part of cabal
10:09:07 <fantasma> cabal-install unlike cabal, is an executable which functions as a sort of package manager for cabal
10:09:21 <kc5tja> Oh good grieff!!!
10:09:26 <kc5tja> This is becoming much too much a chore.
10:09:40 <kc5tja> So, why wouldn't cabal-install be part of cabal?
10:09:59 <fantasma> it's a seperate "frontend" to cabal
10:10:03 <Saizan> the repo has been extrapolated for management reasons
10:10:18 <fantasma> they should not include it in the cabal package, I'm not sure why they do
10:10:33 <kc5tja> So, I'm SOL at this point.
10:10:39 <Saizan> however if you just want to silence the type error that Setup.hs gives you delete the typesings inside it
10:10:52 <kc5tja> Read the error again.
10:11:02 <kc5tja> it's attempting to cd into cabal-install.
10:11:06 <kc5tja> And said directory does not exist.
10:11:15 <fantasma> kc5tja: did you build cabal (not cabal-install)?
10:11:19 <Saizan> http://hpaste.org/1587 <-- i was talking about this
10:11:28 <kc5tja> fantasma: That's what I get when I try to build cabal.
10:12:06 <sjanssen> kc5tja: are you on a 64-bit box?
10:12:38 <kc5tja> sjanssen: Yes.
10:12:41 <Saizan> kc5tja: you probably need  to darcs get cabal-install inside the cabal directory to make it build
10:12:59 <bos> no, you don't. cabal-install is unrelated to cabal now.
10:13:11 <sjanssen> kc5tja: try deleting all the type signatures in the Setup.hs
10:13:17 <bos> cabal and cabal-install have standalone repos.
10:13:42 <pitecus> how do i find which function is causing stack overflow in ghc?
10:14:00 <kc5tja> sjanssen: I build GHC as a 32-bit process.  Can I just use --build=i386-unknown-linux for cabal too?
10:15:31 <sjanssen> kc5tja: ah, your ghc is 32-bit?
10:15:45 <sjanssen> kc5tja: you can just use the released version of X11, then
10:15:48 <sjanssen> @hackage X11
10:15:48 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/X11
10:16:14 <fantasma> that should build w/o errors (from cabal at least)
10:16:38 <fantasma> sjanssen: I
10:17:33 <fantasma> sjanssen: I've got a question about your latest xmonad patch. By adding xmonad.1 to extra-source-files, what happens at build? Does the man page get installed?
10:17:37 <kc5tja> No, the makefile for cabal depends on cabal-install
10:17:58 <fantasma> kc5tja: just delete that line
10:18:22 <Saizan> have you tried building cabal with cabal only? runhaskell Setup.hs configure etc?
10:18:29 <sjanssen> fantasma: no, it just gets packaged in the .tar.gz made by Cabal sdist
10:18:52 <kc5tja> Heh, apparently cabal-setup is also a dependency.  Can I also safely delete that too?
10:19:11 <fantasma> sjanssen: ah I see, would we have to create a Makefile to get the manpage installed?
10:19:17 <kc5tja> Saizan: No, I read the README, which said, "The preferred way to do this is just type make install."
10:19:26 <sjanssen> fantasma: or something.  I'm not clear on the best way
10:19:57 <Saizan> "preferred" :)
10:20:13 <kc5tja> sjanssen: Yes, it's 32-bit because my local installation lacks 64-bit libraries for gmp and readline.so.4.  . o O ( Why are we still stuck on readline 4? )
10:20:16 <fantasma> alright. maybe the cabal people can be convinced to create support for manpages
10:20:24 * Saizan is trying to build and see what happens
10:20:36 <kc5tja> sjanssen: I was just following the instructions in the xmonad readme.
10:22:08 <Saizan> ?where xmonad
10:22:08 <lambdabot> http://www.xmonad.org/
10:22:13 <kc5tja> sjanssen: That's the URL I grabbed the stuff from.
10:23:17 <kc5tja> I dunno -- something is _seriously_ wonky with this installation, and I just don't know what it is.
10:23:34 <fantasma> what OS?
10:23:40 * kc5tja is probably going to have to uninstall Haskell now because it's likely in an inconsistent state.
10:23:47 <kc5tja> fantasma: a variation of Ubuntu.
10:24:30 <fantasma> your haskell should be fine if nothing was able to install
10:24:50 <fantasma> just try building X11 from hackage
10:25:21 <kc5tja> fantasma: That's where I got the X11 package from in the first place.
10:25:23 <sjanssen> kc5tja: the instructions only tell you to install darcs X11 if you're on a 64 bit box
10:25:40 <sjanssen> kc5tja: and what when wrong when you tried to build X11-1.2?
10:25:42 <Saizan> (i built and installed darcs version of Cabal without using the Makefile and it seems to work well)
10:26:10 <kc5tja> sjanssen: http://hpaste.org/1587
10:26:32 <fantasma> kc5tja: that's from darcs head
10:26:36 <sjanssen> kc5tja: that is the darcs version of X11, not the version from hackage
10:27:00 <sjanssen> kc5tja: http://hackage.haskell.org/packages/archive/X11/X11-1.2.tar.gz
10:30:40 <sioraiocht> why does do {inp <- getChar; inp2 <- getChar; print inp2} only actually take one character?
10:32:27 <sjanssen> sioraiocht: that program will take two characters
10:32:41 <Philippa> a newline might well be one of them if you type it, though
10:32:46 <sioraiocht> ah
10:33:00 <sioraiocht> so maybe using getLine and taking the head is better
10:33:51 <sioraiocht> who needs IO anyway...
10:34:30 <sjanssen> ooh, 6.6.1 is out
10:34:37 <sioraiocht> orly? what's new?
10:36:14 <sjanssen> not much, it's a bug fix release
10:38:11 <sjanssen> kc5tja: have you had better luck with the released version of X11?
10:43:26 <kc5tja> sjanssen: The link you provided is the link I grabbed the files from.
10:43:40 <kc5tja> Maybe I'm missing something, but it's already in my browser's address bar.
10:44:14 <sjanssen> kc5tja: the errors you pasted are from the darcs version, definitely not from the link I pasted
10:46:29 <kc5tja> sfalvo@sfalvo:~/tmp/xmonad/X11-1.2$ runghc Setup.hs build
10:46:29 <kc5tja> Setup.hs: Package X11-1.2 can't be built on this system.
10:46:59 <sjanssen> kc5tja: configure
10:47:04 <kc5tja> sjanssen: I did.
10:47:08 * kc5tja isn't that silly stupid.  ;D
10:47:20 <sjanssen> erm, I mean check the output of configure
10:47:33 <sjanssen> it probably complains like "package unix not found", or something
10:47:42 <kc5tja> Although I haven't spent full time on it, after 3 days of fighting with stuff, I'm inclined to believe that xmonad simply and utterly cannot be built on this workstation (it builds just fine on my box at home).
10:48:08 <kc5tja> No reported errors on the console from configure.
10:48:37 <kc5tja> Nothing in the log either.
10:48:43 <ortmage> i'm trying to build ghc 6.6 but it dies compiling MachCodeGen with nativeGen/MachCodeGen.hs:108:30: Not in scope: `assignReg_I64Code'
10:48:44 <kc5tja> brb -- meeting
10:50:37 <ortmage> should i try compiling the bleeding edge of ghc instead?
10:55:50 <ortmage> can i try to force ghc to build without 64-bit support? (to guess blindly at the cause of the error)
10:57:33 <sjanssen> ortmage: what's your platform?
10:57:58 <ortmage> Linux 2.6.18.5-gg4-mixed64-32 #1 SMP Mon Jan 8 20:27:43 GMT 2007 x86_64 GNU/Linux
10:58:20 <sjanssen> there should be a generic Linux binary for you
10:58:38 <sjanssen> of 6.6.1, even
10:59:32 * ortmage will try that
10:59:51 <kc5tja> back.
11:00:06 * kc5tja will just give up for today; I need to get actual work done.  ;)
11:01:00 * kc5tja really wishes our boxes didn't have such tweaked environments on it.  It took me a while to get xmonad running on my box at home, but was well worth it.  Here, after _3_ days, still no luck.  :(  Environment is the only thing I can think of that is of any significant difference.
11:02:45 <asbeta> hi guys. haskell-98 spec says about layout function "L", section 9.3. could you help me find it's reference implementation?
11:10:54 <Saizan> builing and installing a HEAD snapshot of ghc will just put the binaries in /usr/local/bin and the libs in /usr/local/lib/ghc-"version" ?
11:15:13 <fantasma> Saizan: that is the default PREFIX yes
11:19:24 <Cale> asbeta: Isn't it right there in section 9.3?
11:19:25 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
11:19:26 <allbery_b> stupid(?) gtk2hs question, yet again...
11:20:07 <asbeta> Cale: i mean i could copy-paste it into interpreter/compiler :)
11:20:12 <allbery_b> I want to display a menu of available columns when a column header in a treeview is right-clicked.  is this doable?
11:20:25 <Cale> ah
11:20:54 <Cale> Well, there are implementations in GHC, Hugs, etc.
11:21:57 <asbeta> i haven't found that function in GHC sources
11:22:34 <asbeta> i think it's scattered in lexer
11:25:04 <Cale> hmm
11:26:17 <asbeta> i would really like some magic function that will map String (that can be passed to ghc) to String (that can be passed to ghci)
11:28:25 <Cale> Oh, well that's not even completely possible -- you could do it specifically for function declarations
11:28:51 <Cale> but ghci won't handle data declarations, instances, etc.
11:29:08 <asbeta> yes, i think they can be thrown away
11:29:18 <Cale> There really ought to be a tool for desugaring modules though.
11:29:26 <asbeta> so main problem is that ghci doesn't understand multi-line declarations :)
11:29:54 <Cale> If you have lots of multiline declarations, I think the easiest thing is to stick them in a file.
11:30:22 <asbeta> user inputs those declarations
11:36:04 <Phas> anyone knows if there's a way to use darcs via ssh on a port different from 22?
11:36:48 <fantasma> I think the port has nothing to do with darcs
11:36:56 <fantasma> you can change the port of sshd
11:39:03 <ddarius> Hmm.  How did hbi handle it?
11:39:48 <Phas> fantasma: i have a sshd on a port that is not 22, and i want to use darcs with it
11:40:25 <Phas> fantasma: so i need something like darcs push -p=53567 phas@myhost:path
11:40:38 <ray> http://www.darcs.net/manual/node5.html#SECTION00520000000000000000
11:40:41 <lambdabot> Title: Configuring darcs, http://tinyurl.com/yubb8j
11:41:24 <fantasma> Phas: you can set the SSH_PORT enviromental variable
11:41:47 <fantasma> Phas: and that will let you use darcs with another port
11:41:59 <Phas> fantasma: thx
11:42:11 <fantasma> no problem
11:50:25 <Cheery> http://dev.codeflow.org/svn/cheery/small.programs/ForthMonad.hs
11:59:58 <ddarius> petekaz: The last branch of lookup can be written M.lookup k m >>= lookup ks
12:00:20 <ddarius> But I'm pretty sure your problem is in the last branch of insertWith
12:00:24 <mauke> push a = modify (a :)
12:03:25 <ddarius> petekaz: Or it's in the way you use insertWith now that I look a bit closer.  Also, just changing $ to $! will get the effect of your commented out code.
12:12:09 <sjanssen> asbeta: Language.Haskell can output correctly formatted Haskell code
12:16:26 <ddarius> petekaz: The stack overflow is coming from insertWith according to -xc if I'm reading it correctly.
12:16:42 <ddarius> (Well, in my somewhat modified version)
12:19:19 <sjanssen> I'm tempted to respond to the "help -- need a random number" post on the mailing list with a single random number
12:20:04 * desp cheers sjanssen on
12:20:30 <sjanssen> "HAppS LLC has part-time and full-time positions open for haskell programmers" I like the plural "positions" :)
12:20:35 <int-e> sjanssen: http://xkcd.com/c221.html
12:20:36 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
12:20:39 <shapr> sjanssen: Want a job?
12:21:09 <sjanssen> shapr: I think I'm booked already with SoC
12:21:23 <shapr> Ok, after SoC?
12:21:40 * dylan wonders if he counts as a haskell programer yet.
12:21:57 <eumenides> shapr: who made that haskell "nethack clone" on your site?
12:21:58 <sjanssen> shapr: yeah, I'd certainly consider a part time thing in the fall
12:22:08 <shapr> eumenides: Richard Braakman, aka dark
12:22:40 <vali> hello
12:22:50 <sjanssen> shapr: are you full time on happs now?
12:22:53 <shapr> Yup
12:22:58 <sjanssen> very cool
12:23:00 <shapr> Have been for some months.
12:23:03 <shapr> Yeah, it's exciting.
12:23:12 <eumenides> shapr: interesting. thanks
12:24:21 <shapr> sjanssen: Biggest thing I've noticed so far is that many haskell libs work, but aren't up to 'commercial standards'. And by that I specifically mean that they have lots of small bugs that lead me to believe they haven't been extensively used before.
12:24:48 <asbeta> sjanssen: many thanks for that!!
12:25:20 <sjanssen> shapr: yeah, I'd believe that -- especially after my experiences with the X11 package
12:25:21 <shapr> On the good side, writing commercial Haskell code is WAY nicer than writing commercial Python, Java, VB, etc.
12:26:11 <shapr> Unlike Java, where you're stuck with the library mistakes of the past, library authors are very receptive to bug reports, and Haskell lets us get around any problems we find.
12:26:13 <Philippa> shapr: could've told you that about the libs, I may've forgotten to post the bug I caught in the old Network.CGI to anywhere that mattered...
12:26:34 <Philippa> yeah, that's important
12:27:03 <shapr> One problem I run across sometimes is that a powerful code can be hard for me to understand.
12:27:10 <shapr> s/a//
12:27:31 <rahikkala> It was hard to write, of course it should be hard to understand
12:27:39 <shapr> A very small amount of code can do amazing things that time to understand.
12:27:45 <shapr> er "take time"
12:27:46 <Philippa> shapr: yeah. I guess I should apologise, having dropped that one on you myself before
12:28:22 <shapr> Lots of Haskellers do that though. Once they understand the code, and it works, documentation is rare.
12:28:48 <shapr> I have that problem myself.
12:29:01 <Philippa> I think the two of us probably have more excuse for it than most
12:29:31 <sjanssen> things are looking good for Haskellers: HAppS, Credit Suisse, Galois, all seem to be actively hiring
12:29:42 <astrolabe> What excuses?
12:30:23 * astrolabe deliberately forgets the lack of comments of his own code
12:30:36 <Philippa> astrolabe: well, in my case it's essentially the same pile of reasons that I'm out of work indefinitely
12:31:08 <astrolabe> Ah
12:31:51 <shapr> sjanssen: What about BlueSpec and Jane's Capitol?
12:33:58 <sjanssen> shapr: even better :)
12:37:27 <fantasma> what does GHC_CHECK_MODULE() do?
12:40:13 <ddarius> petekaz: Incidentally, the first two cases of lookup can just return the node value.
12:40:44 <petekaz> ddarius: I can rewrite that last branch of lookup because using the >>= operator because the Maybe monad fails with Nothing, correct?
12:41:32 <petekaz> ddarius: True ...  I overlooked that as well.
12:41:40 <ddarius> No, fail is not involved.  That case statement is just exactly what >>= does.
12:42:48 <petekaz> Right ... binding Nothing returns Nothing, correct?
12:43:06 <petekaz> Nothing >>= blah always gets you Nothing right?
12:44:10 <Philippa> yeah
12:44:10 <rahikkala> Indeed
12:44:10 <rahikkala> @src Maybe (>>=)
12:44:11 <lambdabot> (Just x) >>= k      = k x
12:44:11 <lambdabot> Nothing  >>= _      = Nothing
12:44:52 <petekaz> I need to remember that ...  as a newbie I always forget that.
12:45:20 <petekaz> ddarius: you've made my 'lookup' function much more concise now.  Thanks!
12:51:07 <shapr> Is there a function to touch a file?
12:51:37 <mauke> @hoogle utime
12:51:38 <lambdabot> CPUTime :: module
12:51:38 <lambdabot> CPUTime.getCPUTime :: IO Integer
12:51:38 <lambdabot> CPUTime.cpuTimePrecision :: Integer
12:52:07 <ADEpt> shapr: open in Append mode and close?
12:52:15 <Cale> shapr: hmm, flip appendFile "" ?
12:52:30 <shapr> Hm, ok
12:52:36 <mauke> :t touchFile
12:52:39 <lambdabot> Not in scope: `touchFile'
12:52:48 <shapr> I'll try that, thanks.
12:52:51 <mauke> :t System.Posix.Files.touchFile
12:52:51 <ddarius> @hoogle touch
12:52:52 <lambdabot> Foreign.ForeignPtr.touchForeignPtr :: ForeignPtr a -> IO ()
12:52:52 <lambdabot> Data.Array.Storable.touchStorableArray :: StorableArray i e -> IO ()
12:52:54 <Cale> @hoogle touch
12:52:54 <lambdabot> FilePath -> IO ()
12:52:54 <lambdabot> Foreign.ForeignPtr.touchForeignPtr :: ForeignPtr a -> IO ()
12:52:55 <lambdabot> Data.Array.Storable.touchStorableArray :: StorableArray i e -> IO ()
12:52:57 <Cale> oops :)
12:53:25 <Cale> Hmm, no System.Posix in hoogle?
12:53:54 <mauke> @hoogel touchFile
12:53:55 <lambdabot> Maybe you meant: hoogle hoogle+
12:54:00 <mauke> @hoogle touchFile
12:54:01 <lambdabot> No matches found
12:54:48 <shapr> Does System.Posix have a touch?
12:55:04 <shapr> Ah, so it does.
13:01:31 <fantasma> does darcs automatically install the mtl libraries?
13:02:13 <mauke> oh god building ghc takes forever
13:12:22 <magnus> compiling HAppS unstable stopped halfway with warnings
13:13:01 <shapr> What errors?
13:13:14 <Saizan> using ghc HEAD?
13:13:51 <pitecus> is they a faster way to (de)serialize data than show/read?
13:13:56 <shapr> Binary
13:14:12 <shapr> @where binary
13:14:13 <lambdabot> http://www.cse.unsw.edu.au/~dons/binary.html
13:15:34 <pitecus> that isnt included in ghc is it?
13:15:46 <Cale> Nope, but maybe at some point
13:15:56 <pitecus> ok
13:16:48 <Heffalump> I thought they wanted to get stuff out of ghc, not put stuff in.
13:17:41 <anders0> Hey, can someone help with a boring technical problem?
13:17:49 <Cale> I suppose that depends on what counts as GHC :)
13:17:50 <anders0> I cant import Control.Monad.Error
13:17:52 <magnus> shapr: No errors, just warnings. Just a min, I'll put it online
13:18:04 <ddarius> petekaz: Adding the !, to the second argument of T does seem to make it work.  (I also made some other changes, if that alone doesn't work)>
13:18:11 <Igloo> Heffalump: In general, yes, but GHC currently has its own binary library (for .hi files) that it would be good to replace with the standard one
13:18:25 <ddarius> @index ErrorT
13:18:26 <lambdabot> Control.Monad.Error, Control.Monad.Error
13:18:27 <dmwit> anders0: What's stopping you?
13:18:29 <Cale> Oh, that's true as well :)
13:18:52 <Cale> anders0: perhaps the mtl isn't installed?
13:18:55 <anders0> import Control.Monad.Error just results in Failed to load interface for `Control.Monad.Error':
13:19:04 <Cale> anders0: which platform?
13:19:13 <anders0> That might very well be, im just using the default ghc-6.6 on Ubuntu
13:19:25 <Cale> ah, libghc6-mtl, I think it was
13:19:39 <fantasma> speaking of mtl
13:19:43 <Cale> er, it was something like that
13:19:45 <Saizan> libghc6-mtl-dev
13:19:49 <Cale> right
13:19:49 <fantasma> does GHC install mtl on it's own
13:19:51 <Saizan> (on debian at least)
13:19:59 <Cale> (Yeah, that's it)
13:20:03 <anders0> Thanks, i'll try that
13:20:20 <Cale> In fact, it's probably good to install all the libghc6-*-dev packages, just to avoid annoyance.
13:20:21 <Saizan> fantasma: only if you are installing the extra-libs package too
13:20:42 <magnus> shapr: http://magnus.smartelectronix.com/temp/happs.txt
13:22:22 <anders0> It's working now (also had to add "-package mtl" to my build command)
13:22:26 <fantasma> Saizan: where is the extra-libs package?
13:24:26 <Saizan> http://www.haskell.org/ghc/dist/6.6.1/ghc-6.6.1-src-extralibs.tar.bz2 <-- here for example, but now that i think of it i don't know if the binary package has the included :\
13:24:29 <lambdabot> http://tinyurl.com/26opmt
13:25:02 <Saizan> anders0: using --make ghc resolves package dependencies on its own
13:25:28 <fantasma> thanks Saizan
13:26:16 <anders0> Thanks Saizan, im sure that will save me some trouble in the future :)
13:31:41 <boorly> how can i define a function more than once in ghci, with different patterns?
13:31:59 <boorly> func1 [] and func1 (x:xs), basically
13:32:26 <mauke> let foo [] = 1; foo (x : xs) = 2
13:32:33 <ddarius> > let len [] = 0; len (x:xs) = 1 + len xs
13:32:34 <lambdabot>  Parse error
13:32:42 <boorly> okay
13:32:44 <ddarius> > let len [] = 0; len (x:xs) = 1 + len xs in len [1,2,3]
13:32:46 <boorly> that looks about right
13:32:46 <lambdabot>  3
13:32:47 <boorly> thanks
13:40:27 <encryptio> are there any libraries like perl's Expect to interact with command line utilities?
13:42:47 <shapr> magnus: Thanks
13:44:31 <petekaz> ddarius: I don't really understand what the ! does in the constructor, and specifically how that applies to what is going on in this instance.
13:44:49 <sjanssen> petekaz: it means that field is strict
13:45:02 <alexj> anyone know how to pass command line arguments to a program run from runhaskell?
13:45:38 <Cale> Just include them on the commandline after the file
13:45:48 <alexj> isn't working for me.
13:45:51 <sjanssen> petekaz: so in "data D = D !X", "D x" desugars to "x `seq` D x"
13:46:17 <magnus> shapr: running "runghc Setup.hs build" again makes it continue though so it is not too serious
13:46:25 <dmwit> :t foldr
13:46:28 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
13:46:30 <Cale> cale@zaphod:~$ cat args.hs
13:46:30 <Cale> import System.Environment
13:46:30 <Cale> main = getArgs >>= print
13:46:30 <Cale> cale@zaphod:~$ runhaskell args.hs a b c d hello
13:46:30 <Cale> ["a","b","c","d","hello"]
13:46:59 <Cale> What does runhaskell --help give you?
13:47:18 <alexj> oh my bad.
13:47:19 <petekaz> sjanssen: It's the same as using a bang pattern on a regular function arg?
13:47:33 <alexj> was running it in wrapper that was reordering arguments.
13:47:38 <Cale> ah
13:47:40 <ddarius> Well, that use is an extension.
13:47:43 <sjanssen> petekaz: similar
13:48:05 <sjanssen> petekaz: the bang pattern syntax was inspired by data's ! syntax
13:48:11 <petekaz> I see.
13:48:33 <sjanssen> petekaz: the different is that the data ! happens on construction of a value, and bang patterns happen on deconstruction/matching
13:48:33 <Cale> Which also inspires the name of $!
13:49:09 <petekaz> So I'm trying to understand the consequence of my code not doing this.  Here is the line in question that would benefit from the ! in front of the 2nd arg to T: insertWith fn (k:ks) v (T mv        m) = T mv (M.insertWith const k newtrie m)
13:49:31 <petekaz> If I had used M.insertWith' (where M is Data.Map), would that have done the same?
13:49:42 <ddarius> petekaz: It leads to the complete evaluotion of that sub-Trie.
13:50:01 <sjanssen> petekaz: nah, insertWith' wouldn't do the same thing
13:50:19 <petekaz> ddarius: but seq as you pointed out to me is not deep, right?
13:50:45 <petekaz> sjanssen: I'm not sure I understand what the diff is then.
13:50:46 <Cale> When things are forced to evaluate, they're typically evaluated up to the top level constructor, since that's the minimum amount of work for a pattern match to potentially be able to succeed.
13:50:49 <sjanssen> petekaz: you should probably be using insertWith' in that first example in addition to the ! in the data decl.
13:51:14 <Cale> insertWith' will evaluate things to WHNF as it's inserting them, iirc
13:51:21 <Cale> (that is, to the top level constructor)
13:51:27 <ddarius> petekaz: Yes, but every T constructor forces the element, so everything gets evaluated.
13:51:34 <sjanssen> petekaz: insertWith' says "if the resulting Map is forced, then the result of combining the values is forced as well"
13:51:37 <Cale> In this case, that's just T. The mv and m won't get evaluated without extra stuff.
13:51:45 <sjanssen> (combining the values with the given insertion function)
13:52:35 <sjanssen> ddarius: that isn't quite correct, the elements in the Map aren't strict unless you make special arrangements
13:53:15 <Cale> If T has a bang in its declaration, then that parameter is strict, meaning that the application of a partially applied T to that parameter will, when evaluated, force that parameter into WHNF before returning anything (either a data value, or a function to take the rest of the parameters of the constructor)
13:53:46 <dmwit> ?where YAHT
13:53:47 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
13:53:58 <Cale> Normally, it just takes a reference to that value without doing any evaluation on it.
13:54:12 <petekaz> Ok ... so insertWith' means nothing until the map is evaluated.
13:54:20 <Cale> That's true as well.
13:54:20 * araujo just received 'Types and Programming Languages - B.C.P'
13:54:21 <sjanssen> Cale: that isn't exactly correct
13:54:21 <petekaz> and the ! forces the map to be evaluated.
13:54:21 <lambdabot> araujo: You have 1 new message. '/msg lambdabot @messages' to read it.
13:54:31 <Cale> sjanssen: er, did I miss something?
13:54:32 <ddarius> Nothing means anything until the expression containing it is evaluated.
13:54:35 <petekaz> so where is the stack overflow from?
13:54:39 <sjanssen> Cale: consider "data X = X !Int !Int; X undefined `seq` ()"
13:54:55 <sjanssen> Cale: the strictness happens after all parameters are accepted
13:55:01 <Cale> oh, that's interesting
13:55:17 <sjanssen> Cale: I had to double check that in ghci just to be sure :)
13:55:47 <Cale> I wouldn't expect that, though I can sort of understand why it might be desirable.
13:57:51 <Cale> ah, okay
13:58:05 <petekaz> This has been helpful, I need to re-read everything again, but where does the stack overflow come from?  This relates to my use of foldl' and insertWith?
13:58:20 <Cale> data cx => T u1 ... uk = ... | K s1 ... sn | ... will cause every occurrence of K in an expression by:
13:58:25 <Cale> (\ x1 ... xn -> ( ((K op1 x1) op2 x2) ... ) opn xn)
13:59:09 <sjanssen> Cale: where the 'op' corresponds to $! or $?
13:59:11 <Cale> where opi is ($) if si is of the form ti, and opi is ($!) if si is of the form ! ti
13:59:23 <Cale> That's what the report says.
13:59:56 <Saizan> strict fields are in the report?
14:00:00 <Cale> yes
14:00:22 <Cale> "cause every occurrence of K in an expression to be replaced by"
14:00:29 <Cale> (obviously:)
14:00:52 <mauke> haddock: unrecognized option `--source-module=http://darcs.haskell.org/packages/rts/%{FILE}'
14:01:08 <petekaz> The details of evaluation seem very complicated, lazy vs strict, ! and seq, etc ... is the report readable by non-academic folks?
14:01:09 <mauke> (from make install-docs in ghc-6.6.1)
14:01:11 <sjanssen> petekaz: basically you were building a giant thunk in the Map part of your data structure
14:01:27 <sjanssen> petekaz: the report is fairly approachable
14:01:43 <Cale> petekaz: It's readable, but it's easier to read if you already know the language
14:01:50 <ddarius> The Report is very readable as far as those things go.
14:02:10 <Cale> petekaz: Have I ever described exactly what laziness is while you were around?
14:02:29 <Cale> It's actually pretty simple.
14:02:37 <Cale> Simpler than you might imagine anyway
14:02:43 <petekaz> So my data structure had a thunk where the Map should have been, and even if I had used (and I did at one point), insertWith', the thunk was still unevaluated, and the insertWith' would noly have kicked in if I had evaluated the map.
14:03:11 <dmwit> Yay!  A friend just told me he was going to try to learn Haskell.
14:03:16 <Cale> Well, your map would be  (insertWith' foo...)
14:03:25 <Cale> Values are allowed to be code.
14:03:46 <petekaz> So doesn't this all apply to the first arg of T?  The Maybe value?  Aren't thunks lying around for that as well?
14:03:58 <petekaz> Shouldn't that be !'d as well?
14:04:00 <ddarius> Yes.
14:04:06 <ddarius> Yes.
14:04:23 <petekaz> So to avoid the stack overflow, I need !'s on both args to T correct?
14:04:36 <Cale> I haven't seen your complete code, but possibly.
14:04:38 <ddarius> Actually, you shouldn't need it.
14:05:05 <ddarius> But it's probably better to have it. (I.e. you don't -need- it)
14:05:24 <petekaz> ddarius: but why?  doesn't the same issue apply here?
14:05:25 <ddarius> You do need the $! in the one part of your code though, but only for pathological inputs.
14:06:25 <petekaz> but even if I use seq to apply the fn to the value which is stored in the Maybe, I thought I just learned that it is pointless unless the top-level Maybe is evaluated.
14:06:46 <Cale> Basically, imagine insertWith/insertWith' as inserting expressions into your Map, something like (f oldvalue newvalue). insertWith' goes the extra step of reducing that expression until it's of the form T x y, for some x and y which might be otherwise left unevaluated.
14:06:58 <ddarius> Sooner or later it will be.
14:07:51 <ddarius> But try your code on input of the form of 'replicate 1000000 "foo"'.
14:07:54 <Cale> If T is made strict, then regardless of how f does its work, x and y will be forced to evaluate until they start with some constructor (whose parameters might again be left unevaluated)
14:08:36 <Cheery_> How can I create a VertexArrayDescriptor? or vertexbufferobject in HOpenGL?
14:09:07 <Cale> If, say x is of type Maybe, that'll mean it'll get evaluated to the point where it can be decided whether it's Just z or Nothing
14:10:45 * petekaz scratches head
14:10:52 <Cale> @type Graphics.Rendering.OpenGL.GL.VertexArrays
14:10:58 <lambdabot>     Not in scope:
14:10:58 <lambdabot>       data constructor `Graphics.Rendering.OpenGL.GL.VertexArrays'
14:11:00 <Cale> @type Graphics.Rendering.OpenGL.GL.VertexArrays.VertexArrayDescriptor
14:11:02 <lambdabot> forall a. Graphics.Rendering.OpenGL.GL.VertexArrays.NumComponents -> Graphics.Rendering.OpenGL.GL.DataType.DataType -> Graphics.Rendering.OpenGL.GL.VertexArrays.Stride -> GHC.Ptr.Ptr a -> Graphics.
14:11:03 <lambdabot> Rendering.OpenGL.GL.VertexArrays.VertexArrayDescriptor a
14:11:07 <petekaz> Cale: here is the code in question: http://article.gmane.org/gmane.comp.lang.haskell.cafe/21952
14:11:09 <lambdabot> Title: Gmane -- Mail To News And Back Again
14:11:56 <magnus> shapr: I ran into another 'bug', if you are interested
14:12:14 <ddarius> petekaz: Replacing c <- readFile "big.txt" with let c = unwords $ replicate 1000000 "evening" will overflow.
14:12:27 <Cale> petekaz: stack overflows happen when you end up evaluating an expression that looks like f (f (f (f (...)))) (or obviously, with different functions, but the same function is common), and where each f immediately demands its parameter before returning anything.
14:12:41 <petekaz> ddarius: without using a ! in front of the Maybe?
14:16:03 <ddarius> petekaz: You need M.insertWith' to get it to work.
14:16:42 <ddarius> And the $! before fn v v'
14:17:13 * ddarius knew he needed the $!, but the insertWith' threw him for a loop for a second.
14:17:35 <Cheery_> Cale: I'd may be able to understand it somehow, but what and how should I turn to (Ptr a) ??
14:17:51 <ddarius> You don't need the ! before the Maybe but you might as well as there is little reason to have it be unevaluated.
14:18:25 <Cale> hmm
14:18:33 <Cale> @hoogle VertexArrayDescriptor
14:18:34 <lambdabot> No matches found
14:18:47 <petekaz> so it's not important on the Maybe because it does not contain a recursive tries is them?
14:18:51 <Cale> Cheery_: that's a good point, I have no idea what that Ptr is supposed to be a pointer to
14:19:39 <Cale> oh
14:19:45 <Cheery_> well, I've played around with opengl in C, in C vertexarray takes a buffer of items of certain type
14:19:56 <Cale> arrayPointer will give you a StateVar filled with a VertexArrayDescriptor
14:20:43 <Cheery_> Cale: I guess it's null, since arrayPointer is such thing you use to select vertex arrays
14:20:52 <petekaz> this is oh so complicated .... is there any tutorial out there for this sort of thing?
14:21:24 <petekaz> right now, it seems to be a guessing game for me.  try seq here, add ! there, hope that it works.
14:21:54 <Cheery_> thought, Cale, do you know how could I make a Ptr to a buffer of GLFloats or GLUints?
14:21:57 <ddarius> There are certain common scenarios that are easy to see.
14:22:57 <ddarius> Really it helps if you think about how you want the code to evaluate as you write it and design it to work that way, rather than just writing it and fixing things afterwards.
14:23:48 <ddarius> Also, by capturing things in HOFs and such, you can reason about coarse-grained chunks of code at a time with simpler rules, e.g. the rules for when to use fold' and foldr.
14:23:57 <Cale> Cheery_: Well, GLfloat = Float and GLuint = Word32, so you could use withStorableArray to get a pointer to an array of them. I'm not sure that you should be required to do something so horribly low-level.
14:25:19 <petekaz> Thanks for all the help.  I'm a little discouraged that I have so much to learn.
14:25:41 <petekaz> I guess I have to read the report to get a better understanding.
14:25:43 <Cale> Let's start with something simpler
14:25:55 <Cheery_> Cale: not only that it's horribly low level, it's also horribly unsafe!
14:25:57 <ddarius> There are only a couple of "patterns" to learn.
14:26:00 <Cale> do you understand why foldl (+) 0 [1..1000000] stack overflows?
14:26:07 <petekaz> definitely.
14:26:28 <petekaz> (I don't understand why haskell even has plain old foldl)
14:26:42 <Cale> It's because a giant expression is built up that looks like (((((((...((0 + 1) + 2) + ...)
14:26:45 <mahogny_> well. foldl is used at times
14:27:01 <petekaz> Cale: I meant vs foldl'
14:27:02 <qwr> @src reverse
14:27:03 <lambdabot> reverse = foldl (flip (:)) []
14:27:10 <ddarius> mahogny_: Not really.  Not any place that it couldn't be replaced with foldl'.
14:27:20 <mahogny_> aha. the '
14:27:30 <Cale> Well, there are some rather rare cases
14:27:43 <ddarius> The report writers just were aiming at things that were as lazy as possible.
14:27:51 <Cale> In particular, where the function you're working with might ignore its parameter.
14:28:13 <ddarius> Cale: I have not yet seen a good scenario.  It's possible, but I haven't seen any.
14:28:27 <dmwit> Or, as qwr points out, when using reverse on a list for which each element requires significant calculation.
14:28:28 <Cale> You'll still get a big expression, but you won't have to evaluate everything.
14:28:49 <Cale> For that to really be a win, f has to be expensive to compute.
14:28:59 <ddarius> dmwit: They have the exact same strictness (foldl v. foldl' reverse)
14:29:04 <Cale> and it has to be something which would not be better done with foldr
14:29:16 <dmwit> Oh, really?
14:29:18 <dmwit> Never mind, then.
14:29:34 <ddarius> Cale: I know it's possible, but I haven't seen any good examples.  I made the example up on StackOverflow.
14:29:49 <dolio> dmwit: foldl' (flip (:)) is only strict in the final list, I think. Not in the elements.
14:29:58 <Cale> Left folds are already pretty rare as it is.
14:30:13 <dolio> In the spine, that is.
14:30:14 <ddarius> Cale, no they are not.  I don't know why you keep saying they are.
14:30:35 <dmwit> dolio: Ah, okay.  That makes sense.
14:30:40 <ddarius> Anytime you want to accumulate a result and the combining operation is strict, you want foldl'.
14:30:43 <sjanssen> all left folds are actually right folds
14:30:45 <petekaz> I use reverse all the time, does that mean 'reverse "some large string"' will stack overflow?
14:31:14 <dolio> > reverse (repeat 100000 5)
14:31:18 <lambdabot>  Couldn't match expected type `t -> [a]'
14:31:19 <Cale> Well, the main reason you typically really want a left fold is because you want tail recursion and strictness.
14:31:30 <sjanssen> > reverse (replicate 100000 5)
14:31:50 <dolio> Oh, that's right. I always mix that up.
14:31:54 <Cale> Rather than that it's really important that it have that associativity. Reverse is the main case where the left-associativity is really important.
14:31:59 <andygill> Main> length $ Data.List.foldl' (flip (:)) [] $ take 30 $ repeat undefined       => 30
14:32:16 <andygill> So foldl' (flip (:)) [] is only strict in the spine.
14:32:24 <sjanssen> yeah
14:32:43 <sjanssen> the strictness might actually be redundant, because it's a direct constructor application
14:32:44 <Cheery_> Cale: well... maybe I'm forced to do the simplest thing and use those beginEnd -things.
14:32:54 <ddarius> @src foldl'
14:32:55 <lambdabot> foldl' f a []     = a
14:32:55 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
14:33:16 <petekaz> sjanssen: did that > reverse example end in a stack overflow?
14:33:18 <sjanssen> or maybe not.  Does (\x y -> y : x) a b count?
14:33:28 <Cheery_> if my stuff pays off, I guess I'll find somebody to make it use those vertexbufferobjects.
14:33:34 <Cheery_> gn
14:33:40 <ddarius> a' = x:a, seq a' y = y so foldl and foldl' reverse are exactly the same.
14:33:47 <emu> > head $ reverse [1..]
14:33:56 * emu cacklesa
14:34:02 <sjanssen> petekaz: I'm not sure.  The library implementation of reverse should be efficient (no stack overflows)
14:34:05 <Cale> Cheery_: I don't really know anything about OpenGL
14:34:10 <dmwit> emu: omega ;-)
14:34:16 <ddarius> sjanssen: It will force the flip, but whatever...
14:34:20 <andygill> length $ Data.List.foldl' (\ a b -> b : a) [] $ take 30 $ repeat undefined     => also evaluates straight to 30
14:34:30 <emu> @botsnack
14:34:30 <lambdabot> :)
14:34:32 <Cheery_> Cale: do you know somebody who knows?
14:34:34 <petekaz> sjanssen: oh, so its not defined as lambdabot indicated?
14:34:46 <Cheery_> ie, specifically who knows about HOpenGL
14:34:56 <ddarius> Cale: Often you want tail-recursion and strictness.
14:35:02 <Cheery_> I already know some basic stuff from Just OpenGL
14:35:13 <Cheery_> well, basic and basic...
14:35:15 <Cheery_> :P
14:35:19 <sjanssen> @src reverse
14:35:20 <lambdabot> reverse = foldl (flip (:)) []
14:35:22 <Cale> ddarius: Right, but in some sense, they're optimisations.
14:35:24 <Cheery_> darn! I'd know how to use vertexarrays in C.
14:35:40 <vali> does ghc come with opengl libraries?
14:35:52 <dolio> @src sum
14:35:52 <lambdabot> sum = foldl (+) 0
14:35:55 <ddarius> Cale: In some sense, not if your operations are already strict (e.g. (+) and (*))
14:36:13 <ddarius> > foldl (+) 0 $ replicate 1000000 1
14:36:22 <emu> vali: yes, in extras
14:36:25 <ddarius> > foldl' (+) 0 $ replicate 1000000 1
14:36:36 <vali> emu: that's great!
14:36:38 <Cale> ddarius: well, (+) is associative, so as long as there's enough stack space, foldl and foldr give the same thing
14:37:06 <ddarius> Cale: If only there was enough stack space.  When you find a Turing machine, I'd love to have it.
14:37:08 <sjanssen> petekaz: while testing in ghci I got a OOM error rather than a stack overflow
14:37:35 <dmead> ?seen dons
14:37:36 <lambdabot> dons is in #haskell, #xmonad and #haskell-soc. I last heard dons speak 8h 52m 51s ago.
14:37:37 <Cale> I'm saying foldl is rare because it's rare that you really *want* to make that structural transformation.
14:37:54 <dolio> Does ghci not set stack space limitations?
14:37:57 <petekaz> I guess I was just confused when you said library implementation, does that mean reverse is really implemented in C or something instead of the Haskell definition lambdabot shows?
14:38:07 <Cale> It's something which you do as a part of trying to optimise your code, rather than something essential to the semantics of your program, most of the time.
14:38:31 <Cale> No, it's really implemented like that
14:38:47 <sjanssen> petekaz: that may or may not be the definition -- my assertion "the library will be implemented well" was independent of the sample lambdabot has shown
14:38:48 <ddarius> Cale: Semantics-wise, no it doesn't make a difference, but pragmatics-wise it's extremely important.
14:39:02 <sjanssen> petekaz: reverse is so common that you can expect it to have a good implementatoin
14:39:12 <ddarius> Alternatively, we can start counting (asymptotic) space/time usage as part of the semantics and things will look different.
14:39:52 <monochrom> reverse cannot escaping using Theta(n) stack space, as nowhere else are "prev pointers" stored.
14:40:26 <monochrom> Even if you do it in C.
14:40:27 <sjanssen> monochrom: incorrect
14:40:55 <sjanssen> reverse = rev [] where rev xs [] = xs; rev xs (y:ys) = rev (y:xs) ys
14:41:01 <monochrom> Oh?  Pray tell.
14:41:07 <ddarius> monochrom: Sum definitely can though.
14:41:07 <ddarius> Also, you can store the back pointers in the list.
14:41:09 <vali> sjanssen: oom? out of mana?
14:41:27 <TSC> monochrom: In C, you can do it with a "previous" pointer that lags behind the "current" pointer
14:41:29 <sjanssen> monochrom: do you agree now?
14:41:30 <dmwit> ?hoogle Bool -> a -> Maybe a
14:41:31 <lambdabot> No matches, try a more general search
14:41:40 <monochrom> Yes! I forgot that one. I knew it.
14:41:44 <sjanssen> monochrom: that uses Theta(n) heap, and O(1) stack
14:41:45 <dmwit> ?hoogle (Monad m) => Bool -> a -> m a
14:41:46 <lambdabot> Control.Exception.assert :: Bool -> a -> a
14:42:03 <Cale> petekaz: basically, in your program, you have to use insertWith' so that demand will be propagated to the thing being inserted, which in this case, is another Map, and T needs to be strict, or else you need an extra $! in the expression where the insertWith' is done, so that demand will again be propagated down. Otherwise, the insertions build up expressions which aren't reduced until the very end when you go to look
14:42:03 <Cale> up the result.
14:42:40 <Cale> Really, it's just the second field of T which needs strictifying here
14:42:46 <dolio> > take 5 . foldl (flip (:)) undefined $ replicate 100 "Boom"
14:43:28 <petekaz> Cale: and that's because its not a recursive structure?
14:44:32 <Cale> er, sorry, the first field does have to be strict. I confused myself because I'd added an extra $! to the line above the insertWith'
14:44:41 <monochrom> TSC: by "even in C" I still mean reversing a Haskell list. So, initially the prev pointers are absent. A C routine's first job is to compute and store them. OK, not necessarily Theta(n) stack, but still Theta(n) space somewhere.
14:44:44 <Cale> (I'd replaced the $ with $!)
14:45:24 <Cale> If you don't evaluate that fn v v', that ends up happening over and over and the value looks like Just (fn v (fn v2 (fn ...)))
14:46:00 <Cale> with no reason to evaluate it until later
14:46:03 <monochrom> Still on http://hpaste.org/1557 ?
14:46:06 <petekaz> I replaced the $ with $!, but lets say I hadn't, would it be enough to add the ! to the first param of T?
14:46:16 <Cale> monochrom: something like that
14:46:18 <sjanssen> C can do reverse on a SLL in Theta(1) space
14:46:26 <Cale> monochrom: I used the code from the mailing list
14:46:48 <sjanssen> Theta(1) additional space that is, the actual list itself is Theta(n)
14:47:07 <Cale> petekaz: yeah
14:47:15 <Cale> er
14:47:26 <Cale> hmm, no
14:47:27 <Cale> hehe
14:47:32 <petekaz> But Would'nt that only do enough to figure out if it was Nothing?
14:47:42 <petekaz> and not actually calculate it?
14:47:44 <Cale> right, not enough here
14:47:56 <Cale> So you can completely avoid using strict fields
14:48:01 <Cale> you only need two $!'s
14:48:05 <Cale> > insertWith fn ([])   v (T (Just v') m) = T (Just $! fn v v') m
14:48:05 <Cale> > insertWith fn (k:ks) v (T mv        m) = T mv $! (M.insertWith' const k newtrie m)
14:48:06 <lambdabot>  Parse error
14:48:06 <lambdabot>  Parse error
14:48:13 <Cale> heh
14:48:22 <ddarius> petekaz: No.
14:48:25 <petekaz> Hmm ... let me try that.
14:48:35 <ddarius> (er to your earlier question)
14:48:49 <monochrom> OK I see. The hpaste version used M.insert.  Now it's changed to M.insertWith.  That certainly should first be changed to M.insertWith' before any further discussion. :)
14:48:57 <ddarius> Strictifying the first component of T will not evaluate the contents of Just ...
14:49:06 <Cale> right
14:49:10 <petekaz> monochrom: see http://article.gmane.org/gmane.comp.lang.haskell.cafe/21952
14:49:11 <lambdabot> Title: Gmane -- Mail To News And Back Again
14:49:42 <monochrom> Also I already added "seq newtrie ..." yesterday and I don't understand why it was not adopted.
14:50:02 <hpaste>  Cale annotated "how to make my trie strict?" with "strictification" at http://hpaste.org/1557#a3
14:50:09 <petekaz> monochrom: it was ... I left it out as my stack overflow still occurred and I didn't want to confuse the matter on the list.
14:50:47 <monochrom> Well changing from M.insert to M.insertWith certainly adds stack pressure.
14:51:07 <Cale> a little, perhaps
14:51:16 <Cale> M.insert = M.insertWith const
14:51:24 * ddarius tries to find that paper that does fold-like stuff in constant stack space.
14:51:28 <petekaz> monochrom: Apparently I discovered that I needed a 2nd strictness annotation ... use a ! on the Map param of T.
14:51:52 <petekaz> monochrom: we are now just discussing some leftover offshoots from the solution.
14:52:38 <petekaz> Cale: So I ran your version and it works, which makes sense as sjanssen said that ! in the data constructor is just like doing a seq in the actual construction of it.
14:52:44 <Cale> right
14:52:44 <hpaste>  ddarius annotated "how to make my trie strict?" with "my final version" at http://hpaste.org/1557#a4
14:52:50 <sjanssen> Cale: why not add a ! to the data declaration?  It gives the compiler more information
14:52:50 <dozer> ouch - just got "Constraint is no smaller than the instance head"
14:53:14 <Cale> sjanssen: That's true -- I wanted to sort out what the minimal amount of additional strictness was.
14:53:28 <dozer> instance (Ord (OL.Description c i op p d dr car)) => RL.DescriptionOpps (OL.Description c i op p d dr car) where  union d1 d2 = OL.SetOperation $ OL.ObjectUnionOf $ S.fromList [d1, d2]
14:53:38 <petekaz> I took Cale's suggestion to mean that as well.  Just for illustrative purposes.
14:53:41 <petekaz> I'll stick with the !.
14:54:02 <petekaz> Thanks for EVERYONEs help!
14:54:05 <petekaz> Much Appreciated.
14:54:13 <monochrom> T (Just $! fn v v') m is not strict enough.
14:54:21 <sjanssen> dozer: that instance could lead to an infinite loop in the type checker -- add -fundecidable-instances
14:54:43 <sjanssen> monochrom: nice catch
14:54:57 <dozer> oh? why is this? is it not reducable to Ord d => DescriptionOpps d?
14:55:31 <hpaste>  sjanssen annotated "how to make my trie strict?" with "enough strictness" at http://hpaste.org/1557#a5
14:55:32 <monochrom> My annotation last night was designed for precisely that.
14:55:36 <Cale> What case will cause that to produce a stack overflow?
14:55:57 <monochrom> Ha, nice trick you did there!
14:56:36 <monochrom> Alternatively, T (Just $! fn v v') m  would be strict enough if "data ... = T !(Maybe a) ..."
14:57:09 <sjanssen> dozer: if you wrote "instance RL.DescriptionOpps (OL.DescriptoinOpps ...) => Ord (OL.DescriptionOpps ...)", you'd have a loop on your hands
14:57:14 <ddarius> Besides readscheme, where else is a good repository for Scheme papers?
14:57:25 <sjanssen> dozer: if you can reduce that constraint it might work
14:57:48 <monochrom> In "T mv $! (M.insertWith' const k newtrie m)" is there any guarantee that newtrie is seqed?
14:58:07 <dozer> sjanssen: Ah, ok, so it's because things don't get smaller that possibly there could be a loop
14:58:15 <monochrom> Probably yes.
14:58:32 <dozer> sjanssen: and since I can't assert that I will never close the loop by having the desc => Ord desc form...
14:58:41 <sjanssen> dozer: correct on both counts
14:59:03 <dozer> OK. Pitty I can't make that negative assertion :(
14:59:05 <sjanssen> the class system is open -- any user could come by and break things
14:59:35 <dozer> understood
15:00:05 <dozer> yet another thing learned today - some sort of personal reccord I think
15:00:15 <sjanssen> monochrom: it shouldn't ever cause a stack overflow, anyway
15:00:44 * esap has attempted to understand Kan extensions. No luck.
15:07:34 <petekaz> monochrom: so T (Just $! fn v v') m is NOT the same as let x = fn v v' in seq x (T (Just x) m)?
15:07:57 <petekaz> yet this is? (T . Just $! fn v v') m
15:07:59 <monochrom> Not the same.  Depends on definition of Trie.
15:08:34 <petekaz> I seem to have missed the subtlety that every else has picked up on.
15:08:43 <monochrom> Yes (T . Just $! fn v v') m is more strict, guarantees evaluation of fn v v'
15:09:03 <ddarius> esap: Nat(-,Ran_J D) ~ Nat(-J,D) Nat(Lan_J D,-) ~ Nat(D,-J)
15:09:14 <ddarius> (not really for size reasons, but...)
15:09:20 <monochrom> I'll show you examples.
15:10:15 <ddarius> esap: Anyways, indexed/weighted (co)limits are more convenient (in my opinion)
15:10:30 <monochrom> > seq (Just (Just $! undefined )) 1
15:10:32 <dmwit> Haha, I just typed
15:10:36 <lambdabot>  1
15:10:37 <dmwit> return . return $ link s p d
15:10:39 <monochrom> @botsnack
15:10:40 <lambdabot> :)
15:10:45 <dmwit> <3 Haskell
15:10:57 <monochrom> seq ((Just . Just) $! undefined) 1
15:11:02 <monochrom> > seq ((Just . Just) $! undefined) 1
15:11:04 <lambdabot>  Undefined
15:12:19 <monochrom> When you see "X . Y $! blah" it's "(X . Y) $! blah".
15:12:26 <sorear> hello.
15:12:57 <monochrom> When you see "X (Y $! blah)" it's "X (no one cares what's here yet)".
15:13:18 <petekaz> Ah.
15:13:19 <petekaz> I see.
15:13:27 <monochrom> Here is another example.
15:13:35 <monochrom> > seq (Just undefined) 1
15:13:37 <lambdabot>  1
15:13:47 <monochrom> seq is very shallow.
15:13:59 <petekaz> If I  use ! in the data constructor for Maybe with (Just $! fn v v') it would be fine though?
15:14:19 <monochrom> Yes.
15:14:52 <petekaz> what about T $! (Just fn v v') $ m?
15:15:17 <petekaz> what about T $! (Just (fn v v')) $ m?
15:16:51 <monochrom> Enter "seq (T $! (Just undefined) $ M.empty)" at your prompt to see.  I can't ask lambdabot to try it.  It doesn't know T.
15:17:02 <monochrom> err "seq (T $! (Just undefined) $ M.empty) 1"
15:17:20 <ddarius> > seq (Just undefined) ()
15:17:22 <lambdabot>  ()
15:17:27 <petekaz> crap ... I need to run home, my wife is going to kill me.  monochrom, thanks for the help, I'll review your comments to make sure I understand.
15:17:50 <SamB_XP> petekaz: why do you want your wife to kill you?
15:18:03 <monochrom> the "," there is "or"
15:18:43 <SamB_XP> 'tis funnier my way!
15:18:46 <matthew-_> right, so I need multiple implementations of the same function.
15:18:48 <monochrom> some commas are "and", some are "or".  Consider "programmable commas!"
15:18:56 <SamB_XP> I smell a DWIM
15:18:56 <matthew-_> so I put the functions in a type class
15:19:05 <matthew-_> but that needs to take some parameter
15:19:15 <matthew-_> so I create an ADT Enum
15:19:22 <monochrom> Typeclass is our approximation to DWIM.
15:19:24 <matthew-_> but I don't want to use that
15:20:00 <matthew-_> ignore me, I'm being stupid
15:20:51 <monochrom> Generally, "," is the overloaded operator of Monoid...
15:21:59 <sorear> monochrom: I hate to break this to you, but , is a reservedop.  you can't even shadow it let alone instance it.
15:22:34 <sorear> heh, special even
15:23:03 <monochrom> I know.  I'm referring to the English programming language.
15:23:55 <sorear> @users
15:23:56 <lambdabot> Maximum users seen in #haskell: 329, currently: 305 (92.7%), active: 44 (14.4%)
15:27:02 <monochrom> ndm has a good question on where to put "instance X Y" if X and Y are to be fairly independent.
15:27:19 <monochrom> Sounds like a marriage problem!
15:27:37 <fantasma> would anything break if I changed the X11-extras dependency from X11-1.2 to X11-1.0
15:28:43 <liquidengineer> Hi
15:28:47 <SamB_XP> monochrom: also a leading cause of orphans!
15:28:52 <sorear> monochrom: And I have (the same question and) no good answer!
15:29:37 <ddarius> Argh, I give up.
15:30:00 <liquidengineer> Is anyone here familiar with working with graphs?
15:30:17 <liquidengineer> or rather, trees
15:30:23 <fantasma> you mean Data.Graphs?
15:30:41 <liquidengineer> no
15:30:54 <liquidengineer> it's a much more simple, homegrown implementation
15:31:10 <ddarius> liquidengineer: Isn't absolutely every mildly experienced programmer familiar with working with trees?
15:31:15 <monochrom> I am not familiar with homegrown graphs :)
15:31:37 <liquidengineer> I represent a spanning tree as a root node r (an Int) and a list of Edges (ordered pairs of Ints
15:32:06 <liquidengineer> I need to figure out a way to find the path from a node x to a node y in the spanning tree
15:32:09 * ddarius watches a movie.
15:32:57 <liquidengineer> Does anyone know a simple way to do this?
15:38:15 <fantasma> liquidengineer: DFS or BFS
15:38:40 <fantasma> Prim's algorithm does it too I believe.
15:38:47 <int-e> liquidengineer: find the way to the root from both; delete the common part
15:38:49 <liquidengineer> the spanning tree was created with a dfs algoritm
15:39:20 <liquidengineer> so, then I guess my question is, how do I find the path from the root to a vertex x?
15:39:23 <liquidengineer> is that prim's
15:39:43 <int-e> liquidengineer: either you have backlinks in your tree, or you do a depth first search to find it
15:39:43 <liquidengineer> I suppose I would get the path from root to x, and from root to y, and then combine and nub those
15:39:47 <fantasma> actually Prim's finds the minimum spanning tree
15:40:13 <liquidengineer> my depth first search algorithm just returns the spanning tree
15:40:32 <fantasma> can it be any path? or do you want the shortest?
15:41:18 <ddarius> 06:13:11 <shapr> I won't even dream of trying to catch up to Derek Elkins. Can you believe he actually plays music as his primary occupation, and CS theory is just his hobby?
15:41:18 <ddarius> 06:13:30 <Muad_Dibber> cool
15:41:18 <ddarius> 06:13:39 <shapr> He's also 19 last I checked.
15:41:18 <ddarius> 06:13:44 <tic> eek
15:41:18 <ddarius> 06:13:49 <tic> that can really put someone down. (What the hell?)
15:41:24 <ddarius> Oops, a bit much.
15:41:44 <Muad_Dibber> eh
15:42:05 <liquidengineer> fantasma: Any path is fine
15:42:15 <ddarius> Anyway, watch movie, stop trying to pump the Internet for information.
15:42:31 <sorear> And they apparently missed the fact he is a maths genius too.
15:42:32 <liquidengineer> ...
15:42:39 <liquidengineer> oh
15:42:46 <liquidengineer> you're *definitely* not talking about me.
15:42:48 <liquidengineer> :)
15:42:54 <fantasma> haha
15:43:02 <ddarius> I've never played music professionally.  Derek Elkins of derekelkins.com though does.
15:43:17 <sorear> liquidengineer: is your true name Derek Elkins too?
15:43:27 <liquidengineer> Only on Tuesdays
15:43:33 <sorear> ddarius: might wanna @tell shapr that
15:43:37 * kc5tja sighs -- it almost seems like anyone who is mathematically inclined also can qualify as a musician.  And, since I cannot play music to save my life, . . .
15:43:59 <ddarius> I can play guitar, but probably not professionally.
15:44:11 <kc5tja> I can _pretend_ to play the guitar....
15:44:21 * sorear can reliably drive entire crowds to the brink of insanity with his involuntary whistling
15:44:26 <liquidengineer> so, how *do* I fidn the path from the root to my target?
15:44:34 <kc5tja> My sense of rhythm extends past 0 on the number line -- towards negative infinity.
15:44:44 <liquidengineer> that's the part that confuses me
15:45:48 <monochrom> I can do some math and some music. But not excellent.
15:46:31 * kc5tja _enjoys_ math.  But it seems as if I have an inordinate amount of difficulty with it, considering how much I enjoy the sciences and software engineering.
15:48:00 <LordBrain> hmm well you know what einstein said
15:48:09 <DukeDave> kc5tja, I have the *exact* same feeling :)
15:48:14 <DukeDave> drives me mad,
15:48:42 <monochrom> I may be able to explain your case. There is more empirical stuff in the sciences and software engineering.  Or more concrete stuff.  Math is more abstract and more formal.
15:49:30 <monochrom> For example you probably wouldn't be good at the latest theoretical physics either.
15:49:31 <SamB_XP> but you get to make the same kind of stupid jokes, at least
15:50:28 <kc5tja> LordBrain: What, "Let my wife do all the computin'!"  :)
15:50:34 <monochrom> I am a bit more abstract and less empirical.  But still not ready for the latest theoretical physics!
15:50:38 <sorear> scsibug++ first mkcabal patch in months
15:50:50 <kc5tja> monochrom: But I can grok the very abstract too.
15:50:56 <LordBrain> he said however much difficulty you have had with math, he has had more, something like that
15:51:12 <kc5tja> It's the middle of the bell curve that I have the most difficulty with.  :)
15:51:31 <monochrom> "Don't worry about your difficulties in mathematics.  I assure you mine are still greater."
15:51:45 <DukeDave> Well, since we're talking Maths I don't feel *too* off topic posting my current problem, which also is up in #math (with no replies)
15:52:01 <matthew-_> ok, with the Read class, if I'm just reading in one of several possible constant string values (for an Enum ADT), should I ignore the precedence value on readsPrec ?
15:52:03 <DukeDave> I have the following trig problem, shown here: http://dukedave.com/store/trigProblem.jpg             I understand the upper (trivial) case, but I have been given the lower equation & I just can't see how it is derived, have been drawing different arrangements of triangles for over an hour (using z angles etc.) and just can't make it fit :(
15:52:17 <DukeDave> Incidentally I came across it whilst working through this site: http://www.netcomuk.co.uk/~jenolive/vect4b.html
15:52:20 <lambdabot> Title: Trying to pull a boulder up a hill
15:52:30 <sorear> Oh, that's absolutely trivial! (can't resist)
15:53:14 <DukeDave> :'(
15:53:48 <monochrom> matthew-_: Yes, most likely precedences can be ignored.
15:53:56 <sorear> DukeDave: a possible explanation for why you can't understand the equation - it is wrong.
15:54:13 <DukeDave> Magic :)
15:55:04 <DukeDave> I'm taking it from the second figure on http://www.netcomuk.co.uk/~jenolive/vect4b.html
15:55:05 <lambdabot> Title: Trying to pull a boulder up a hill
15:56:09 <DukeDave> Where they have obtained 'n sin A' as the i component of 'Normal reaction' in the first figure
15:56:34 <DukeDave> I just can't make it fit :(
15:57:17 <fantasma> liquidengineer: how complex is the tree? do you want to use heurisitics?
15:58:14 <liquidengineer> fantasma: It's not that complicated
15:58:21 <liquidengineer> literally just a root and a list of edges
15:58:31 <liquidengineer> very simple data
15:58:37 <fantasma> well then BFS should work fine
15:58:50 <fantasma> there might even be a BFS in Data.Graph
15:58:52 <vali> hmm, (a -> b) -> ([a] -> [b]) ... what does that mean? it takes a function that when given a will return b.. and then it returns a ... hmm
15:58:55 <kpreid> DukeDave: it looks to me like they have cos and sin swapped for those components of n
15:58:56 <fantasma> @hoogle BFS
15:58:58 <lambdabot> Data.Graph.Inductive.Query.BFS :: module
15:58:58 <lambdabot> Data.Graph.Inductive.Query.BFS.bfs :: Graph gr => Node -> gr a b -> [Node]
15:58:58 <lambdabot> Data.Graph.Inductive.Query.BFS.bfsWith :: Graph gr => (Context a b -> c) -> Node -> gr a b -> [c]
15:59:04 <sorear> vali: sounds like map
15:59:10 <vali> sorear: it is!
15:59:16 <sorear> vali: it applies a function to all elements of a list
15:59:26 <sorear> it takes a function (a -> b) and a list [b]
15:59:31 <sorear> er
15:59:33 <sorear> it takes a function (a -> b) and a list [a]
15:59:40 <sorear> and returns a new list [b]
15:59:57 <vali> sorear: hmm, but why are the two lists in parenthesis? that makes me think it does something weird
16:00:08 <kpreid> no
16:00:17 <kpreid> x -> (y -> z) is the same as x -> y -> z
16:00:21 <vali> sorear: oh wait. hoogle doesn't show it like that. it's just this tutorial that does it
16:00:24 <monochrom> You can write (a->b)->[a]->[b] just as well.
16:00:25 <liquidengineer> I can't use builtins, I'm afraid
16:00:35 <liquidengineer> I'm supposed to impleemnt this myself
16:00:39 <vali> kpreid: i see. thank you
16:00:45 <sorear> liquidengineer: myself /= #haskell
16:00:50 <sorear> ?
16:00:54 <liquidengineer> I don't want a solution
16:00:59 <liquidengineer> just a nudge in the right direction
16:01:00 <fantasma> liquidengineer: well BFS is a very simple algorithm to implement
16:01:14 <liquidengineer> fantasma: yeah.  I've done dfs
16:01:18 <liquidengineer> bfs shouldn't be that much harder
16:01:21 <monochrom> (a->b)->([a]->[b]) encourages a second perspective, e.g., "map f . blahblah" the list parameter is not mentioned.
16:01:22 <fantasma> yah
16:01:38 <liquidengineer> I sort of thought that's what I'd have to do, but I wanted to make sure there wasn't some uber-neat way I was overlooking
16:01:41 <fantasma> BFS returns paths faster than other algorithms, but the paths usually tend to suck
16:01:58 <liquidengineer> that involved a list comprension, a Monad, and bob dole :)
16:02:52 <liquidengineer> thanks for the advice
16:03:02 <liquidengineer> I've gotta go now. :)
16:03:07 <fantasma> good luck
16:03:50 <vali> hehe, "point-free programming (not to be confused with pointless programming)"
16:05:11 <monochrom> It is not funny.  http://www.vex.net/~trebla/weblog/pointfree.html   You wouldn't believe how much double-standard is built into our brainwashed minds.
16:05:13 <lambdabot> Title: The Point of Pointfree
16:05:27 <sorear> fantasma: huh?
16:05:43 <fantasma> sorear: what?
16:05:59 <sorear> fantasma: bfs is slow and memory-hungry, but gives shortest paths and is guaranteed to terminate if a solution exists
16:06:15 <fantasma> sorear: which BFS are you talking about?
16:06:23 <int-e> also this is a tree; dfs will find the same path as bfs
16:06:33 <sorear> fantasma: Breadth first search, of a state space
16:06:49 <fantasma> oh, well I was speaking of Best-First Search
16:06:50 <vali> monochrom: i thought it was very funny, but i'm a newbie
16:06:53 <int-e> (or at least that's what I thought.)
16:07:25 <dmwit> Uh, this may sound kind of dumb, but...
16:07:31 <dmwit> An Array is immutable, right?
16:07:47 <int-e> dmwit: yes
16:08:03 <DukeDave> kpreid, do you mean swapped.. as in "The wrong way round" ?
16:08:32 <fantasma> where can I go about getting Graphics.X11.Xinerama
16:08:55 <vali> i don't understand the difference between $ and .
16:09:01 <int-e> fantasma: in a general tree you have no indication of whether you're getting closer to the destination or not, until you've found it.
16:09:13 <int-e> fantasma: BFS doesn't apply then
16:09:15 <vali> $ and . do the same thing with different syntax?
16:09:19 <int-e> fantasma: that is, Best First.
16:09:24 <monochrom> No. They are just different.
16:09:29 <fantasma> int-e: well you would need a heuristic for Best FS
16:09:34 <sorear> @where x11-extras fantasma
16:09:35 <lambdabot> I know nothing about x11-extras.
16:09:37 <monochrom> "f $ x" is "f x".
16:09:46 <kpreid> DukeDave: yes
16:10:07 <sorear> fantasma: http://darcs.haskell.org/~sjanssen/X11-extras
16:10:09 <lambdabot> Title: Index of /~sjanssen/X11-extras
16:10:14 <fantasma> sorear: doesnt x11-extras depend on Xinerma? I'm trying to build x11-extras
16:10:16 <sorear> @where+ x11-extras http://darcs.haskell.org/~sjanssen/X11-extras
16:10:16 <lambdabot> Done.
16:10:20 <DukeDave> kpreid, Well that just makes me mad :)
16:10:35 <vali> monochrom: and "f . x" is "f x" too?
16:10:40 <monochrom> No.
16:10:46 <sorear> fantasma: Graphics.X11.Xinerama is IN x11-extras
16:10:50 <mauke> f . g = \x -> f (g x)
16:10:51 <Saizan> no, f . g = \x -> f (g x)
16:11:02 <sorear> fantasma: your compiler is to lame to chase intra-package dependencies?!
16:11:28 <fantasma> sorear: I'm using GHC :P
16:11:33 <int-e> vali: (.) is used to compose functions. ($) is used to apply a function to a value.
16:12:02 <sorear> fantasma: so what's the problem?
16:12:05 <vali> int-e: oh
16:12:08 <int-e> vali: the utility of ($) is mostly syntactical (it saves parentheses)
16:12:33 <vali> int-e: ooh, that's what i was hoping it was. thanks
16:12:49 <hpaste>  fantasma pasted "x11-extras (sorear)" at http://hpaste.org/1589
16:13:17 <sorear> fantasma: pull and recompile
16:13:24 <sorear> fantasma: remembering to reconfigure
16:13:27 <fantasma> hmm, alright
16:13:32 <fantasma> but I don't even use xinerama
16:13:34 <sorear> fantasma: modern x11-extras check for xinerama support
16:13:40 <int-e> > map ($ 2) [succ, pred] -- one case where $ actually saves a lambda
16:13:42 <lambdabot>  [3,1]
16:13:42 <fantasma> oh ok
16:13:44 <sorear> fantasma: your programs do
16:13:57 <fantasma> oh wait
16:14:03 <fantasma> I don't have X installed
16:14:07 <fantasma> lol
16:14:15 <sorear> > map (`id` 2) [succ, pred] -- eh?
16:14:17 <lambdabot>  [3,1]
16:14:21 <int-e> sorear: right
16:14:24 <sorear> fantasma: then you don't need xmonad!
16:14:26 <sorear> :)
16:14:44 <sorear> even I have X installed! :)
16:15:16 <mauke> > map (flip id) [succ,pred]
16:15:18 <lambdabot>  Add a type signature
16:15:23 <mauke> > map (flip id 2) [succ,pred]
16:15:23 * sorear is amazed that fantasma managed to not install X
16:15:25 <lambdabot>  [3,1]
16:15:33 <inverselimit> If you have a function that is some kind of homomorphism, eg f (x + y) = (f x)+(f y), is there a natural/useful way to express that?
16:15:35 <fantasma> haha
16:15:52 <fantasma> thank goodness for binaries
16:15:58 <sorear> fantasma: seriously.  just about everything depends on it now!
16:16:12 <thoughtpolice> i have x installed but i don't use it. does that count?
16:16:14 <fantasma> hmm
16:16:25 <fantasma> I can get by with ncurses and screen
16:16:29 <sorear> fantasma: what graphic environment do you use then?
16:16:33 <thoughtpolice> or a better question, where would that put me? 'the half way' mark?
16:16:50 <sorear> thoughtpolice: it puts you with me - installed.
16:17:09 <fantasma> sorear: well if you have a framebuffer driver, that's all you really need for graphics
16:17:15 <sorear> YAY!! I'M NOT ALONE!!
16:17:51 <dons> http://programming.reddit.com/info/1lax5/comments
16:17:52 <lambdabot> Title: London Haskell User Group Founded (reddit.com)
16:18:46 <sorear> hi dons
16:19:01 <sorear> dons: are there public #xmonad logs?
16:19:45 <fantasma> damnit I was op in #xmonad two days ago :P
16:24:58 <mdmkolbe-hom1> @type liftM
16:25:07 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
16:25:13 <mdmkolbe-hom1> @type liftM2
16:25:15 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
16:26:43 <mdmkolbe-hom1> :type (>>=)
16:26:51 <mdmkolbe-hom1> @type (>>=)
16:26:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:31:15 <mdmkolbe-hom1> @src liftM
16:31:15 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
16:32:52 <mdmkolbe-hom1> @djinn (a -> m a) -> a -> m a
16:32:52 <lambdabot> f a = a
16:33:56 <mdmkolbe-hom1> @djinn (a -> m a) -> ((a -> m b) -> m a -> m b) -> (a -> b -> m c) -> (m a -> m b -> m c)
16:33:57 <lambdabot> -- f cannot be realized.
16:34:33 <mdmkolbe-hom1> @djinn ((a -> b) -> (m a -> m b)) -> (a -> m a)
16:34:34 <lambdabot> -- f cannot be realized.
16:35:31 <mauke> yeah, you can't do that for arbitrary m
16:35:35 <stepcut> @djinn ((a -> b) -> (m a -> m b)) -> (a -> m b)
16:35:36 <lambdabot> -- f cannot be realized.
16:35:38 <stepcut> :(
16:36:23 <mdmkolbe-hom1> @djinn ((a -> m b) -> (m a -> m b)) -> (a -> m a) -> ((a -> b) -> (m a -> m b))
16:36:23 <lambdabot> -- f cannot be realized.
16:36:34 <Saizan> @djinn (r -> a) -> ( a -> r -> b) -> (r -> b) -- reader monad >>=
16:36:34 <lambdabot> Cannot parse command
16:36:43 <Saizan> @djinn (r -> a) -> (a -> r -> b) -> (r -> b)
16:36:44 <lambdabot> f a b c = b (a c) c
16:36:48 <mdmkolbe-hom1> @type liftM
16:36:50 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
16:37:18 <mdmkolbe-hom1> @djinn ((a -> m b) -> (m a -> m b)) -> (a -> m a) -> ((a -> b) -> (m a -> m b)) -- liftM from return and bind
16:37:19 <lambdabot> Cannot parse command
16:38:31 <dolio> @src liftM
16:38:31 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
16:39:04 * mdmkolbe-hom1 pokes ski (lambda bot's author?)
16:40:17 <mdmkolbe-hom1> @type liftM return bind f m = bind m (\x -> return (f x))
16:40:19 <lambdabot> parse error on input `='
16:40:37 <mdmkolbe-hom1> @type lifter return bind f m = bind m (\x -> return (f x))
16:40:39 <lambdabot> parse error on input `='
16:40:41 <dolio> @djinn ((a -> mb) -> ma -> mb) -> (a -> ma) -> (a -> b) -> ma -> mb
16:40:42 <sorear> mdmkolbe-hom1: no way.
16:40:42 <lambdabot> -- f cannot be realized.
16:40:51 <sorear> mdmkolbe-hom1: lambdabot isn't slow
16:40:59 <sorear> mdmkolbe-hom1: @type runs GHCi
16:41:20 <sorear> mdmkolbe-hom1: time ghci -e ''
16:41:41 <sorear> mdmkolbe-hom1: besides, Pseudonym wrote the bot.
16:41:48 <int-e> dolio: you need b -> mb, not a -> ma
16:41:50 <sorear> mdmkolbe-hom1: which doesn't matter - dons runs it
16:42:11 <dolio> @djinn ((a -> mb) -> ma -> mb) -> (b -> mb) -> (a -> b) -> ma -> mb
16:42:12 <lambdabot> f a b c d = a (\ e -> b (c e)) d
16:42:18 <dolio> Ah, quite right.
16:42:37 <mauke> @djinn ((a -> m b) -> m a -> m b) -> (b -> m b) -> (a -> b) -> m a -> m b
16:42:37 <lambdabot> f a b c d = a (\ e -> b (c e)) d
16:43:50 * mdmkolbe-hom1 appoligizes to ski for poking him
16:44:31 <shapr> ski: You must cut down the tallest arrow in the forest with.. A COMONAD!
16:45:06 <dolio> It can't be done!
16:45:22 <mdmkolbe-hom1> @djinn ((a -> m b) -> (m a -> m b)) -> (forall c. c -> m c) -> ((a -> b) -> (m a -> m b))
16:45:22 <lambdabot> -- f cannot be realized.
16:45:40 <dons> I hope everyone saw: http://article.gmane.org/gmane.comp.lang.haskell.cafe/21951
16:45:42 <lambdabot> Title: Gmane -- Mail To News And Back Again
16:45:49 <dons> Haskell Job Opportunity / HAppS
16:45:50 <sorear> $18 = "\002\004\0202\005\021"  -- I <3 maximal munch
16:46:26 <sorear> (gdb) :set obase=2
16:46:34 <sorear> wow I've been using ghci too long :)
16:48:53 <mdmkolbe-hom1> @djinn ((a -> m b) -> (m a -> m b)) -> (b -> m b) -> ((a -> b) -> (m a -> m b))
16:48:54 <lambdabot> f a b c d = a (\ e -> b (c e)) d
16:49:29 <mdmkolbe-hom1> @djinn ((a -> m b) -> (m a -> m b)) -> (a -> m a) -> (b -> m b) -> ((a -> m b))
16:49:29 <lambdabot> -- f cannot be realized.
16:49:56 <mdmkolbe-hom1> @djinn ((a -> m b) -> (m a -> m b)) -> (b -> m b) -> (a -> m a)
16:49:56 <lambdabot> -- f cannot be realized.
16:50:32 <mdmkolbe-hom1> @djinn ((a -> b) -> (m a -> m b)) -> (a -> m a)
16:50:33 <lambdabot> -- f cannot be realized.
16:50:54 <mdmkolbe-hom1> @djinn ((a -> b) -> (m a -> m b)) -> (b -> m b)
16:50:55 <lambdabot> -- f cannot be realized.
16:51:21 <mdmkolbe-hom1> @djinn ((a -> a) -> (m a -> m a)) -> a -> m a
16:51:22 <lambdabot> -- f cannot be realized.
16:51:25 <sorear> mdmkolbe-hom1: I recommend /msg for any sequence longer than 3 trials.
16:58:56 <dons> today's recommended reading, http://programming.reddit.com/info/1lax5/comments
16:58:57 <lambdabot> Title: London Haskell User Group Founded (reddit.com)
16:59:08 <dons> and http://programming.reddit.com/info/1lb5v/comments
16:59:09 <lambdabot> Title: Strongly Typed Memory Areas: Systems-Level Data Structures in a Purely Functiona ...
16:59:20 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1590
17:00:10 <dolio> Whoa.
17:00:38 <matthew-_> cool, a london Hug! More people to go drink with!
17:01:24 <dons> with the NYC group founded this week too
17:02:18 <Binkley> so who wants to join a California Central Coast Haskell group? :P
17:02:37 <SamB_XP> how about a Greater Philadelphia group?
17:03:07 <matthew-_> Binkley: there are some folk at Google who might, Adam Langley for one.
17:03:23 <Binkley> well, maybe I should start one, then!
17:03:47 <sorear> Samuel Falvo II, too
17:03:57 <dons> also, Clifford beshers, I think.
17:04:30 <stepcut> dons: might be too far north
17:04:31 <Binkley> not sure what the function of such a group would be
17:04:33 <Binkley> besides drinking
17:04:36 <Binkley> which would be fine with me
17:04:45 <stepcut> everytime ghc's brain explodes, take a drink :)
17:04:47 <Binkley> haha
17:04:53 <Binkley> I'd have died of alcohol poisoning by now
17:05:06 <stepcut> I think I have seen 4 people from San Diego on #haskell at once, though...
17:05:23 <sorear> who were the other two?
17:05:37 <stepcut> me, you, cliff, and some random guy last weekend
17:05:48 <stepcut> cliff==thetallguy
17:06:47 <kc5tja> matthew-_: I work at Google too.  :)
17:07:27 <sorear> kc5tja: I already mentioned you
17:07:30 <kc5tja> oops, didn't see sorear's response.
17:07:35 <kc5tja> And we cross-typed.
17:07:44 <kc5tja> I'm not doing too hot today.  :)
17:07:49 <sorear> cross-typed?
17:08:04 <kc5tja> You typed and I typed at the same time, and messages almost went out at the same time.
17:08:31 <kc5tja> Unless there's a more technical term for that, I just invented one on the spot.
17:08:38 <stepcut> looks like, tessier, gFunk, Mortoc, wkh, and user317, are all from San Diego, and have been in #haskell at least once
17:08:50 <sorear> nemequ too
17:08:53 <matthew-_> kc5tja: do you know agl? I think he was in Google Books or something. He gave a google tech talk about STM a week or so ago.
17:09:11 <mdmkolbe-hom1> kc5tja: keyboard race condition?
17:09:24 <stepcut> sorear: all those users I listed have the honor of being in regions of San Diego that are serviced by cox ;)
17:09:39 <sorear> stepcut: don't know how you are searching - but /who #haskell gives nemequ ... sd.sd.cox.net
17:09:40 <matthew-_> take-global-lock-on-keyboards >> type >> release-global-lock-on-keyboards
17:09:48 <sorear> ah oh
17:09:50 <sorear> *ok
17:10:05 <stepcut> sorear: I just googled site:http://tunes.org/~nef/logs/haskell/ sd.cox.net
17:10:07 <lambdabot> Title: Index of /~nef/logs/haskell
17:10:25 <sorear> anyone know what the dns suffix is for time warner/ att SD?
17:10:55 <cedricshock> Hi. Do any of you know of a sparse list implementation in Haskell?
17:11:08 <sorear> like Data.Map?
17:11:52 <stepcut> sorear: san.res.rr.com
17:11:54 <cedricshock> Yeah, Data.Map would be one.
17:12:43 <cedricshock> I'll think about this some more.
17:13:13 <mdmkolbe-hom1> cedricshock: Data.IntMap maybe?
17:14:56 <cedricshock> Data.IntMap is one too. These are probably a better way to go than the data structure I was just "inventing".
17:17:13 <cedricshock> I think I'll bang out my silly structure just for practice.
17:18:07 <mdmkolbe-hom1> cedricshock: which technique for sparcity would you use? (e.g. data SList a = SList [Int] [a])
17:19:17 <cedricshock> mdmkolbe-hom1: Almost that. data SList a = [(Int, a)]         (assuming I got my haskell syntax right)
17:20:03 <mdmkolbe-hom1> cedricshock: yeah, that is more correct than what I wrote
17:20:09 <dolio> There are functions in Data.List for various operations on such lists.
17:20:23 <cedricshock> mdmkolbe-hom1: Yours makes writing a lot of the interface almost trivial.
17:20:32 <sorear> cedricshock: what kind of sparsity do you want?  eg, do you want fast semi-random access?  do you want laziness? ...
17:21:11 <mdmkolbe-hom1> cedricshock: once we get dependant types into Haskell, then my version could work right ;-J
17:21:30 <cedricshock> sorear: laziness, fast access in order, fast transposition of nested lists. Gonna try to throw conjugate gradients on top of this thing.
17:21:31 <dolio> > lookup 5 [(1, 'a'), (3, 'b'), (5, 'x'), (7, 'g')]
17:21:33 <lambdabot>  Just 'x'
17:21:57 <kc5tja> matthew-_: No.  I have never heard of him actually.
17:21:58 <mdmkolbe-hom1> I imagine Data.IntMap does something like: data SList a = SList (Maybe (SList a)) Int a (Maybe (SList a))
17:22:29 <cedricshock> sorear: I'm really not sure about the transposition, something more sophisticated might win at that.
17:22:57 <sorear> mdmkolbe-hom1: pretty close, yeah
17:23:28 <dibblego> is there a dos2unix on mac?
17:23:53 <Binkley> Mac OS X, sure
17:23:59 <Binkley> anything you can run on Unix you can run on OS X
17:24:01 <Binkley> (mostly)
17:24:08 <dino-> I'm working with HUnit for the first time. Having trouble understanding a couple of things..
17:24:15 <dino-> What exactly is assertString for?
17:24:24 <dino-> It seems to fail if its string argument isn't null.
17:24:41 <EvilTerran> is there a constant-time-both-ends FIFO structure in the standard libraries? what about in pure Haskell?
17:24:43 <mdmkolbe-hom1> dibblego: perl -pe 's/\r\n/\n/g' (and maybe a -I (or is it -i) option)
17:24:53 <cedricshock> mmdkolbe-hom1: I understand you comment about dependent types now (length of lists must be the same). I'm at a loss on your gues ate Data.IntMap.
17:24:59 <dino-> mdmkolbe-hom1: perl -pi -e
17:25:14 <sorear> EvilTerran: yes.  Data.Sequence
17:25:19 <dibblego> ta
17:25:20 <mdmkolbe-hom1> cedricshock: it's a ballanced tree
17:25:29 <sorear> mdmkolbe-hom1: no, that's maps (on closer examination)
17:25:45 <mdmkolbe-hom1> sorear: Data.Map?
17:25:50 <sorear> yes.
17:25:53 <dolio> IntMap is a trie.
17:26:01 <cedricshock> mdmkolbe-hom1: I see it now. Yes, it's a tree.
17:26:06 <sorear> mdmkolbe-hom1: Data.IntMap is data SList a = Tip Int a | Split (SList a) (SList a)
17:27:19 <cedricshock> sorear: Ahhhh. No monads.
17:27:55 <EvilTerran> sorear++
17:27:56 <EvilTerran> thanks
17:28:06 * EvilTerran sets about trying to understand how it works
17:28:12 <mdmkolbe-hom1> dolio: I'm not sure it's techniqually a trie http://en.wikipedia.org/wiki/Trie
17:28:12 <lambdabot> Title: Trie - Wikipedia, the free encyclopedia
17:29:03 <sorear> Data.IntMap is a trie of the PATRICIA subfamily
17:29:22 <sorear> Data.Map is a plain old balanced tree
17:30:08 <sorear> (I'm not shouting - PATRICIA really is spelled with all caps)
17:31:15 <ortmage> so i got ghc-6.6.1 installed, but i had to use the i386 version because of link issues (it's a mixed 64/32 environment)
17:31:17 <mdmkolbe-hom1> @source Data.IntMap
17:31:17 <lambdabot> http://darcs.haskell.org/packages/base/Data/IntMap.hs
17:32:16 <ortmage> i'm trying to compile ghc-6.6.1 for x86_64 using it, and i still get nativeGen/MachCodeGen.hs:108:27: Not in scope: `assignReg_I64Code'
17:32:24 <SamB_XP> sorear: it is?
17:32:33 * SamB_XP thought it ought to be but wasn't
17:32:34 <sorear> SamB_XP: yes!
17:32:40 <mdmkolbe-hom1> sorear: I was under the impression that tries usually split more than binary ways
17:32:55 <ortmage> should i try darcs ghc, or am i missing something obvious?
17:33:01 <dolio> mdmkolbe-hom1: But it's a trie on the bits of the int, so there are only two ways to split.
17:33:11 <sorear> mdmkolbe-hom1: no, tries can split any fixed number of ways
17:33:24 <sorear> mdmkolbe-hom1: tries have constant depth and constant fanout
17:33:48 <sorear> optimizations like those of the PATRICIA family can reduce physical depth
17:35:01 * mdmkolbe-hom1 finally found a good definition of PATRICIA trees
17:40:12 * sorear points mdmkolbe-hom1 at wikipedia
17:40:23 <dino-> Also, what's the difference between a "user error" and a "failure" in hunit?
17:40:50 <sorear> what's the user error message?
17:40:51 <dino-> I seem to only be able to get user errors, as when intentionally setting up a test that will always fail.
17:41:08 <sorear> user error almost always means you called error
17:41:13 <sorear> perhaps fail?
17:41:23 <mdmkolbe-hom1> the wikipedia page burried the key point (that the edges of P-Trees are a string in stead of a single character)
17:41:38 <sorear> I think you're supposed to use the assert* functions
17:41:51 <Binkley> mdmkolbe: so edit it, then! :-)
17:42:15 <sorear> dino-: don't use fail
17:42:26 <sorear> hunit is io, io fail is throw-an-exception
17:42:37 <dino-> test4 = TestCase $ assertEqual "test4" 1 2
17:42:43 <dino-> That outputs a user error.
17:43:16 <dino-> ### Error in:   2:test4  user error (HUnit:test4  expected: 1   but got: 2)
17:44:07 <mdmkolbe-hom1> Binkley: I just did
17:45:02 <sorear> dino-: performTestCase is supposed to wrap it and rewrite the errors
17:45:38 <dino-> The 1.0 user guide showed examples using runTestTT, so I must called that from main in my code.
17:45:45 <dino-> s/must/just/
17:46:29 <sorear> hmm.
17:46:40 <sorear> runTestTT seems to use performTestCase?
17:48:02 <dino-> No, it uses runTestTest and putTextToHandle
17:48:10 <dino-> perhaps I didn't read far enough into the manual
17:48:23 <dino-> runTestText
17:49:25 <cedricshock> A sparse list seems to only mean something if there is a default value (0 in my case for linear algebra). For example, zipping two of them together is problematic. Is there a haskell data class for things with a default value?
17:51:12 <EvilTerran> could you use Maybe, and coerce when appropriate?
17:51:28 <EvilTerran> or Either, if the default is per-item?
17:51:36 <cedricshock> EvilTerran: Maybe ;)
17:53:12 <cedricshock> EvilTerran: The default could be per list, yes. It could even be per part of a list, but I think I want to be dealing with a stricter version of this all, and have one default globally for any type that's involved.
17:53:59 <dino-> sorear: Thanks, I think it has something to do with using that runTestTT.
17:54:01 <EvilTerran> get Nothing = default; get (Just x) = x
17:54:23 <cedricshock> Not having a global default turns this into run-length encoding instead of sparsity.
17:55:04 <EvilTerran> (get = fromMaybe default)
17:55:18 <sorear> is there anything 'wrong' with RLE?
17:55:25 <sorear> it seems more generally useful
17:56:41 <cedricshock> sorear: No, nothing wrong with it. Having finite lists is also more generally useful, but I'm not doing that either (for time's sake and because I want one, and only one, vector type).
17:59:03 <cedricshock> sorear: Actually there is something "wrong" with RLE; it doesn't provide a strict enough basis for being able to fold over lists quickly, without a new idea of the interface to fold. (It's fine for map). Also it'd probably be even worse for transposing, but I'm not sure.
18:00:44 <sorear> why would folding over a sparse list be any easier?
18:03:06 <cedricshock> sorear: What you assume about f  :: a -> b -> a that you fold with. Since folding f on the empty list yeilds the starting accumulator you can stretch that idea to f folded over the entire empty section is the starting accumulator, especially since in my model [] is infinitely many defaults (zeroes).
18:04:16 <ddarius> The whole point of a sparse data structure is that you know what the unrepresented elements are.
18:04:19 <sorear> But folding over default values is not the same as folding over no values!
18:04:20 <ddarius> (Usually 0)
18:04:26 <sorear> consider (*)
18:04:56 <sorear> folding over zeros turns the accumulator to zero, not folding at all leaves the accumulator unchanged.
18:04:57 <cedricshock> Though this could be a fun list: data RLEList a = Run Integer a | InfinitelyMany a | EndOfList
18:05:08 <sorear> Besides, you said you wanted laziness.
18:05:22 <sorear> a -> b -> a is used by foldl's, which are not laziness compatible.
18:06:34 <cedricshock> sorear: Yeah, * is exactly the kind of function that requires you to not take advantage of the sparsity. I want to be able to exclude things like * from the type of function that can be applied.
18:06:40 <dino-> Eh, still happening even when I use the other controller (runTestText). I think this is a bug still present in the Debian package I have.
18:06:59 <dino-> http://hackage.haskell.org/trac/ghc/ticket/476
18:07:01 <lambdabot> Title: #476 (HUnit treats failures as errors) - GHC - Trac
18:07:19 <ddarius> cedricshock: That's not a list, you may want recursive uses of RLEList
18:07:56 <cedricshock> sorear: Or rather assume that on any sparse list, the missing things /all/ make an identity out of the folded function. This is reasonable with one default and sparsity, but not with RLE:
18:08:41 <cedricshock> ddarius: Oops, yeah it goes only with the run. Also that integer should be from Z+ (no-zeros).
18:09:13 <ddarius> Also an Int should suffice.
18:09:27 <sorear> Aww, no runs of -1 zeroes?
18:09:28 <sorear> ;)
18:10:01 <cedricshock> ddarius: Which one's which again?
18:10:14 <hpaste>  sproingie pasted "conway's life" at http://hpaste.org/1591
18:10:37 <sproingie> that paste .. i can't figure out what part State plays in it.  i don't see any mutation going on.
18:10:38 <cedricshock> sorear: Yeah, those negative runs are hard to imagine. The zeros I guess are all right.
18:12:06 <sorear>  makeBoard w h = runState $ replicateM h $ replicateM w $ State random
18:12:12 <sorear> uses ... State!
18:12:20 <sorear> to thread randomness
18:13:11 <sproingie> i can see how the initial state of the board is nondeterministic ... it's random after all
18:13:16 <cedricshock> sorear: Yeah, folding isn't very lazy.
18:13:30 <sproingie> i'm still curious where the state comes in
18:13:47 <dmwit> sproingie: Have you played around with the random package?
18:13:52 <sorear> sproingie: you need the newseed from random n-1 to produce random n
18:14:03 <sorear> sproingie: threading that is what State is for
18:14:10 <dmwit> You have to constantly use/update a random-number generator (seed), and they use State to do that.
18:14:11 <sproingie> oh, i thought random kept it internally
18:14:33 <sorear> sproingie: no, that would violate referential transparency
18:14:38 <dmwit> Incidentally, since you're looking at Conway's Life, check out
18:14:40 <sorear> @type System.Random.random
18:14:42 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
18:14:45 <dmwit> ?go an algorithm for compressing space and time
18:14:49 <lambdabot> http://www.ddj.com/dept/ai/184406478
18:14:50 <lambdabot> Title: Dr. Dobb's | An Algorithm for Compressing Space and Time | March 1, 2006
18:15:02 <sorear> Muahaha.
18:15:09 <sorear> <- hashlife hacker
18:15:39 <dmwit> That algorithm ALWAYS makes me smile.  It's so *good*!
18:15:41 <sorear> I actually implemented a mode for hashlife on arbitrarily large non-quiescent backgrounds.
18:15:47 <sorear> Very very neat.
18:16:11 <sorear> Too bad the rest of golly wants a finite number of cells ON at a time ;)
18:16:33 * sorear doesn't suppose recieving mail from Gosper counts as much if the To: is a mailing list :)
18:19:53 <sorear> also read this: http://sourceforge.net/mailarchive/forum.php?thread_name=1884234.1152134672214.JavaMail.root%40fed1wml07.mgt.cox.net&forum_name=golly-test
18:19:56 <lambdabot> Title: SourceForge.net: golly-test, http://tinyurl.com/yql4uq
18:20:36 --- mode: ChanServ set +o dons
18:20:40 --- topic: set to '["The Haskell programming language: GHC 6.6.1 released!","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]' by dons
18:20:45 --- mode: ChanServ set -o dons
18:21:28 <dibblego> ?hoogle concatMaybes
18:21:28 <lambdabot> No matches found
18:21:38 <dibblego> ?hoogle [Maybe] -> Maybe
18:21:39 <lambdabot> No matches, try a more general search
18:21:46 <dibblego> ?hoogle [Maybe a] -> Maybe a
18:21:47 <lambdabot> No matches, try a more general search
18:22:03 <cedricshock> sorear: Actually, rle is a good idea. Then the speed gain comes from knowing something about functions (fast ways to repeat them) instead of knowing something about the data.
18:22:13 <sproingie> life and CA stuff isn't really my bag, but it's a nice place to start
18:22:29 <sproingie> more interesting than hello world anyway
18:22:34 <sorear> dibblego: catMaybes or msum
18:22:42 <dibblego> ah thanks
18:22:52 <sorear> dmwit: what do you think of my post?
18:23:11 <dmwit> sorear: I'll have a look.
18:27:16 <dmwit> Lots of neat ideas there.
18:47:58 * mgsloan knows this isn't an erlang channel, but... erlang doesn't have a type system!?!?
18:48:15 <cedricshock> mgsloan: Erlang is dynamically typed
18:48:25 <mgsloan> arg
18:48:37 <jcreigh> oh, really?
18:48:46 <jcreigh> for some reason I was thinking it was statically typed.
18:48:54 <mgsloan> yeah, one would think so
18:49:06 <jcreigh> it has pattern matching, doesn't it?
18:49:08 <mgsloan> I suppose there are some issues in regards to distributed computing.. sort of
18:49:10 <cedricshock> mgsloan: Yep
18:50:33 <cedricshock> jcreigh, mgsloan: Essentially you write every function for the type atom | list (of same) | tuple | function (from same to same)
18:50:49 <dons> also, the way erlang emerged (as an interpreter in a business environment) means they don't spend time designing a type system
18:51:24 <sorear> cedricshock: erlang doesn't have user defined types!?
18:51:37 <dons> I'm not aware of any fundamental reason why erlang wouldn't be statically typed. and given things like the dialyser, it would certainly make sense.
18:51:42 <mgsloan> cedrick - huh
18:51:46 <cedricshock> jcreigh, mgsloan: It's a bit easire and harder than that. Functions have arity (you can tell them apart by number of arguments) and you can make huge defaults to reject types
18:51:58 <dons> one of the problems in compiling erlang is emulating the original (dynamic) interpreter. means you can't optimise as you would wish, unfortunately
18:52:32 <cedricshock> sorear: Essentially, no. There are records, but those are pretty much tuple sugar...
18:52:36 <mgsloan> cedrik - right, the foo/x notation where x is arg count
18:52:49 <jcreigh> cedricshock: so if you pattern match against the wrong type, does it just not patch, or is that an error? (or an exception, or whatever)
18:52:56 <jcreigh> s/patch/match/
18:53:07 <mgsloan> cedrick - so if you pass in a tuple identical to a data type, it takes that?
18:53:09 <cedricshock> jcreight: Faisl to match. It's prefectly legal to do things liek this:
18:53:18 <cedricshock> fun {a, b, _} = 12
18:53:39 <cedricshock> fun 'imaspecificatom' = 'silly you'
18:53:52 <mgsloan> dons - well, I guess one could take erlang and modify as necessary to staticize, etc
18:53:55 <cedricshock> And have that be a legal function (pardon if my syntax is booched).
18:54:40 <cedricshock> And then if you called fun([a, b, c]) that would fail to match.
18:55:32 <jcreigh> [ ... ] = list and { ... } = tuple?
18:55:34 <sorear> so UDT's are basically (String,x,y,z)
18:55:37 <sorear> ?
18:56:13 <cedricshock> jcreigh: Yeah.
18:57:17 <cedricshock> mgsloan: Trying to call things with tuples can get ugly. I think the apply bifs take lists. Not sure; there's a way to do it but it's been a while since I erlanged up.
18:57:56 <sorear> bifs?
18:58:14 <cedricshock> sorear: built in functions.
18:58:36 <sorear> are builtins magic in erlang?!
18:59:47 <cedricshock> sorear: The atoms are not strings, thought they are uniquely identified in code by one (and I believe it can be backwards looked up so symantically they probably are). The bifs aren't magic, but that's where you need to look in the erlang docs for almost everything interesting.
19:00:47 <sorear> cedricshock: (guessing) strings with fast equality, like Lisp atoms?
19:01:06 <mgsloan> are there any agent-based static typed functional languages?
19:01:36 <mgsloan> not that there's much better than erlang - every language has it's downsides
19:01:47 <kpreid> jcreigh: pattern matching is not especially associated with static typing
19:01:49 <cedricshock> sorear: Yeah. I think theres a maximum of 2^32 atoms in an erlang cluster, so you can probably guess how they're implemented...
19:02:47 <Pseudonym> Using nanotech, obviously.
19:02:57 <jcreigh> kpreid: sure; I can see how it could work in a dynamically typed language. But in practice it seems to be used more by statically typed languages.
19:03:05 <cedricshock> mgsloan: If you just want the pattern matching benefits of static typing that's very easy to do in erlang; make tuples which have the first value be an atom of their type.
19:03:24 <sorear> what? not md5? ;)
19:03:29 <sorear> well sha1 now
19:03:34 <kpreid> jcreigh: I hadn't especially noticed... perhaps we've seen different languages
19:03:55 <mgsloan> right, it's actually more about the general benefits of static typing than anything else :)
19:04:03 <sorear> If you have an atom collision, you're screwed.  but you don't care because you have prize money!
19:04:12 <jcreigh> kpreid: probably. I'm thinking of Haskell and ocaml specifically.
19:04:56 <jcreigh> sorear: CRC-32, no doubt. :)
19:05:14 <kpreid> Static, no patterns: C, Java, C#, ...; Static, patterns: Haskell, ML. Dynamic, patterns: Prolog, Erlang, E. Dynamic, no patterns: Perl, Python, ...
19:05:33 <jcreigh> E?
19:05:46 <cedricshock> kpreid: What do you mean by patterns?
19:05:46 <kpreid> http://www.erights.org/
19:05:48 <lambdabot> Title: Welcome to ERights.Org
19:06:03 <kpreid> cedricshock: the sort which bind variables to parts of a data structure
19:06:19 <kpreid> and can fail
19:06:33 <cedricshock> kpreid: D'oh, what we were just talking about.
19:06:37 <mvanier> j xmonad
19:07:27 <cedricshock> Dynamic: ALL PATTERNS (only way to write): Q, stratego (might be static)
19:08:27 <cedricshock> mgsloan: You can get quite a few of the statically typed benefits, since erlang is statically typed, there's just exactly one type.
19:08:52 <cedricshock> mgsloan: But none of the interesting ones :(
19:11:36 * kpreid thinks pattern matching is a Very Good Thing because otherwise you get to write horrific nested conditionals to test and destructure
19:11:58 <kpreid> ...which probably means I've just gotten used to patterns and seek to emulate them when I don't have them
19:12:16 <kpreid> s/emulate/approximate/
19:12:42 <dibblego> pattern matching is "nested conditionals to test and destructure", only short and concise
19:12:49 <cedricshock> Hmm, I should make a compressor and decompressor for my run-length encoding lists.
19:12:55 <nohope> Hello :)
19:13:30 <sorear> hello!
19:13:41 <sorear> are you new to haskell or just #haskell?
19:13:56 <nohope> sorear: Both :)
19:14:07 <sorear> well, we hope you like it.
19:14:21 <sorear> remember we like answering questions :)
19:14:50 <nohope> sorear: Actualy, I'm very interested in learn Haskell from several months ago, but I hadn't have time yet :(
19:15:00 <nohope> sorear: Great! :) So... first question:
19:15:22 <sorear> I learned haskell because I had a lot of free time and no idea what to do with it!
19:15:29 <nohope> sorear: Is Haskell fine for concurrent programming? Using multiprocessors etc.
19:15:35 <nohope> sorear: hahaha :) great! :)
19:15:37 <kpreid> Yes!
19:16:04 <sorear> nohope: sure
19:16:06 <monochrom> I only use Haskell for concurrent programming.
19:16:16 <dons> nohope: yeah, multicore machines are supported out of the box, and a wide variety of concurrent and parallel abstractions are supported
19:16:26 <sorear> nohope: we have lightweight threads and parallelism in the standard library
19:16:34 <nohope> hmmm
19:16:41 <nohope> That's really so cool!
19:16:47 <kpreid> nohope: check out the Control.Concurrent.* and Control.Parallel.* modules
19:16:55 <sorear> nohope: and the GHC runtime comes with a load-balancing multi-cpu scheduler
19:16:57 <nohope> haha, I'll never get out of this channel anymore.
19:17:18 <nohope> Nor leave this language.
19:17:35 <sorear> nohope: so you can start 100 threads, compile with OSthread support (-threaded), run with +RTS -N4, and you'll get 25 threads running on each of 4 cpus
19:17:38 <dons> > fix ((1:) . scanl (+) 1) -- have a fixpoint!
19:17:40 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
19:18:01 <nohope> sorear: Sounds very good.
19:18:03 <sorear> > nubBy(((>1).).gcd)[2..] -- have a HOF!
19:18:05 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
19:19:00 <cedricshock> nohope: Just never look at the transaction monad; it's too good to be true. I dream about it sometimes, now.
19:20:23 <nohope> So my problem is solved. I do programming in Tcl, PHP and a bit of C and C++, but I was looking for a different paradigm and I found functional paradigm. So I started to look for a good language and I found Haskell. And now my last answer just got answered :)
19:21:03 * nohope compiles hugs (he doesn't need ghc for now)
19:21:31 <zeptar> ogod
19:21:52 <sorear> ?
19:23:19 <dons> nohope: i'd start with a binary release of ghc. it is really a *lot* better environment, these days
19:23:35 <nohope> dons: Really? Isn't hugs enough for learning purposes?
19:23:55 <dons> it used to be preferred.
19:24:01 <dons> but you may as well use ghci
19:24:11 <sproingie> where is nubBy?
19:24:13 <cedricshock> I forgot about ghci.
19:24:14 <dons> which provides a better path into full ghc (and the range of libraries and extensions)
19:24:20 <sorear> sproingie: Data.List
19:24:27 <nohope> dons: I see...
19:24:32 <kpreid> @index nubBy
19:24:33 <lambdabot> Data.List
19:24:39 <dons> I think you'll have a less than ideal experience of Haskell, if you only use hugs
19:24:54 <sproingie> @index gcd
19:24:55 <lambdabot> Prelude
19:25:05 <sorear> dons: you know, in some language communities people are encouraged to NOT use non-standard extensions... :)
19:25:22 <dons> sorear: yeah, but say he wants to build , hmm, any real world haskell
19:25:29 <dons> you'll need ghc immediately
19:25:30 <sproingie> damn that sieve is so freakin mind-bending
19:25:47 <dons> sorear: its not just non-standard extensions either. its the fact that hugs is *slooow*
19:26:04 <dons> and only an interpreter. which dramatically changes how you perceive the language
19:26:04 <sproingie> ghc is considered the standard around here, things are more or less "backported" to other haskells on a best-effort basis
19:26:44 <sproingie> technically the true standard is haskell 98, but things have really diverged
19:26:50 <dons> nohope: you should be able to find binaries for ghc your distro's package system.
19:27:01 <nohope> Yes. I already found that.
19:27:02 <sproingie> speaking of which, when's Haskell' supposed to be final?
19:27:17 <ddarius> hugs just sucks all around
19:27:18 <Pseudonym> When it's done, I suspect/
19:27:36 <sorear> sproingie: Nov 2006
19:27:44 <sorear> sproingie: needless to say, hopes are not high
19:27:45 <sproingie> i thought it was just capturing current best practices, not inventing new stuff
19:27:54 <cedricshock> I need to find a way to break out of writing two functions for everything, one of which just kickstarts the accumulator on the other. There should be a better way to express that.
19:28:05 <sorear> cedricshock: where
19:28:16 <ddarius> sproingie: Haskell was just supposed to do that and form a consensus for existing lazy FPLs of the time...
19:28:33 <kpreid> f x = f' x 0 where f' x n = ...
19:28:37 <ddarius> Or use HOFS
19:28:39 <dmwit> Okay, I'm trying to write a function morph :: State StdGen [a] -> [State StdGen a].  Is this even possible?
19:28:40 <sorear> > let { fac x = fac' x 1 where { fac' 1 a = a ; fac' n a = fac' (n-1) (a*n) } } in fac 10
19:28:42 <lambdabot>  3628800
19:28:54 <dmwit> (It seems like it should be, but the way of it escapes me...)
19:28:55 <sproingie> ddarius: yah but there came an actual language from that
19:28:56 <ddarius> dmwit: Sure.
19:29:12 <sorear> cedricshock: see my >...
19:29:16 <sproingie> i guess Haskell' is another name for ghc then
19:29:21 <ddarius> sproingie: That went significantly beyond the consensus of the time.
19:29:29 <cedricshock> sorear, kpreid: thanks.
19:29:53 <monochrom> cedricshock: Hmm interesting. I would first look into foldr, foldl', scanl, etc.  If, next, the data structure is something other than lists, I would write similar foldr, foldl', scanl, etc., for the data structure.
19:29:59 <Cale> dmead: looks like sequence?
19:30:04 <Cale> er, no
19:30:06 <mauke> sequence in reverse
19:30:14 <Cale> Yeah, it's the opposite
19:30:23 <Cale> How should the effects occur?
19:30:31 <kpreid> @type foldM
19:30:34 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
19:30:36 <sorear> dmwit: what does morph need to do?
19:30:55 <Cale> That is, what's the effect of running the ith list element you get?
19:30:59 <Cale> (on the state)
19:31:27 <dmwit> Like (gen, as) -> [(gen, a) | a <- as]
19:32:04 <sproingie> i see a lot of stuff with very clever maps and folds ... it's like functional spaghetti code
19:32:10 <sproingie> maybe call it origami code
19:32:17 <sorear> dmwit: do you want a reader then?
19:32:23 <ddarius> @google evolution of a haskell programmer
19:32:25 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
19:32:25 <lambdabot> Title: The Evolution of a Haskell Programmer
19:32:31 <cedricshock> monochrom: Yeah, all of those things are nice, I just manage to make even /more/.
19:32:41 <dmwit> sorear: Hmmm, maybe, I'll have a look at that.
19:32:45 <sorear> @remember sproingie i see a lot of stuff with very clever maps and folds ... it's like functional spaghetti code ... maybe call it origami code
19:32:45 <sorear>  
19:32:46 <lambdabot> Done.
19:32:53 <dmwit> sorear: I also want to write to it eventually, though.
19:33:08 <dons> User groups for Haskell! Who'd have thought: http://haskell.org/haskellwiki/User_groups
19:33:09 <lambdabot> Title: User groups - HaskellWiki
19:33:27 <sorear> dons: haskell has users?
19:33:29 <sorear> :)
19:33:49 <merus> nah, nobody uses haskell ;)
19:33:56 <Cale> Ah, there's a problem with it. You need a value of type StdGen to be able to do that, but you effectively don't have one in that context.
19:34:14 <Cale> Because you need a value of type StdGen in order to know how long the list will be.
19:34:28 <SamB_XP> so, none of us are anybody?
19:34:39 <SamB_XP> I guess we won't be needing this "Who's Who"
19:34:45 <Cale> and yet in order to build a list of actions, you need to know how long that list should be
19:34:52 <ddarius> Or none of use Haskell and we just like hanging out here.
19:34:57 <cedricshock> I always feel dirty writing generators for infinite lists. "-> [a]" just seems like it should mean finite.
19:34:59 <ddarius> Certainly the case for me.
19:35:02 <Cale> dmwit: so I think you're a bit stuck.
19:35:19 <dmwit> Rats.
19:35:28 <ddarius> cedricshock: data Stream a = Cons a (Stream a)
19:35:30 <dmwit> I mean, I know the length of the string ahead of time in a pure (non-random) way...
19:35:38 <Cale> ah, okay
19:35:57 <ddarius> dmwit: Do you want to duplicate the state over each or propagate it?
19:36:00 <Cale> Then you could write something which takes that as a parameter and produces a list of actions which do the lookup at the end.
19:36:07 <dmwit> ddarius: duplicate
19:36:17 <dmwit> err... wait
19:36:20 <dmwit> What's the difference?
19:36:36 <dmwit> Cale: Ah, good idea!
19:36:50 <Cale> Note that the result will be different.
19:36:54 <ddarius> Considering it's a StdGen, duplicating it would mean each of element of the resulting list would produce the same random numbers.
19:36:58 <Cale> (if you sequence them)
19:37:44 <Cale> You clearly can't duplicate it if you have that type signature.
19:37:48 <sproingie> i just realized this property of random today
19:37:51 <dmwit> Well, maybe I should back up and see if I'm doing something fundamentally screwy to demand such oddball behavior.
19:38:04 <dmwit> Here's the idea:
19:38:08 <ddarius> dmwit: It looks like you are.
19:38:18 <dmwit> I'm trying to generate a path in some terrain in a random way.
19:38:28 <dmwit> I'd like to do a depth-first search, because any path will do.
19:38:51 <Cale> So your final type will be State StdGen Path
19:39:00 <dmwit> I was originally planning to simply have a State StdGen [Nodes], because the list monad makes for easy backtracking.
19:39:20 <dmwit> This work correctly on the first path.
19:39:26 <Cale> Ah, you really want StateT StdGen [] Nodes
19:39:31 <sorear> dons: HaskODell eh? *mock mock*
19:39:38 <dmwit> But then, if I try to use the random number generator... it bums out taking forever to calculate *all paths*.
19:39:46 <dons> sorear: urgh
19:39:55 <dons> damn wifi
19:39:58 <sorear> *mock tease*
19:40:18 <Cale> Or use my RandT
19:40:22 <dmwit> Oh no, monad transformers!
19:40:25 * dmwit faints
19:40:36 <dmwit> Okay, this will have to wait for another night... =P
19:40:38 <merus> RandT? That just sounds scary.
19:40:41 <Cale> http://www.haskell.org/haskellwiki/New_monads/MonadRandom
19:40:43 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
19:40:54 <Cale> RandT [] is the monad you want
19:40:54 <cedricshock> sorear: I've been writing a rle list, and have been allowing negative runs, but now that I'be started making lists back out of things, they are not really all that cool.
19:41:12 <Cale> It's basically just like the list monad, only you also have getRandom, etc.
19:41:51 <dmwit> Hmmm... at first I thought that site was going too far for my uses, but my uses have grown.
19:41:57 <Cale> (also, you'll have to apply lift to lists which you want to pick from, but that's not such a big deal)
19:42:00 <dmwit> (Where "at first" means about a week ago.)
19:42:11 <dmwit> Okay, bookmark'd, thanks.
19:42:27 <ddarius> Translate each section to RLE 3 'a' -> (replicate 3 'a' ++) and translate RLE -3 'a' to, say, drop 3
19:43:48 <cedricshock> ddarius: Yeah, but whats RLE -3 'a' when there are no 'a's around. That requires some fairly strict normalization (which isn't hard).
19:44:44 <ddarius> cedricshock: I was providing one possible interpretation (note that for negative lengths it ignores it's element), but in reality, negative runs are just a bad idea.
19:44:47 <kc5tja> LAME -- When I used the :m operation to change the current module in GHCI, I cannot reference imported modules like I do in the raw source code.
19:45:04 <kc5tja> E.g., if I have a module CutLexer.hs and it imports Data.ByteString as S, then
19:45:10 <kc5tja> :m CutLexer
19:45:15 <sorear> kc5tja: you need :m *CutLexer
19:45:15 <kc5tja> let z = S.pack "Hello"
19:45:22 <kc5tja> gives an error.
19:45:25 <kc5tja> sorear: Ahh, let me try that.
19:45:32 * dmwit too
19:45:44 <kc5tja> YAY!  That worked.  Thanks!
19:45:54 <sorear> kc5tja: the '*' means to use the internal symbols, as opposed to just the exported ones.
19:46:16 <cedricshock> ddarius: Yeah, in reality they are horrific, while infinite ones are just fine. Is there a type for a positive integer, or can I constrain my type to be positive?
19:47:09 <ddarius> cedricshock: You could use Word, or use a Natural type (no), or use smart constructors.
19:47:19 <ddarius> Word is probably the best solution all around.
19:47:29 <cedricshock> what are smart constructors?
19:47:51 <ddarius> Functions that wrap the actual constructors to enforce invariants and such
19:48:00 <ddarius> @oldwiki SmartConstructor
19:48:00 <lambdabot> http://www.haskell.org/hawiki/SmartConstructor
19:50:11 <dons> its on the new wiki
19:50:18 <dons> ?wiki Smart_constructor
19:50:19 <lambdabot> http://www.haskell.org/haskellwiki/Smart_constructor
19:50:19 <dons> I think
19:50:37 <ddarius> Guessing hawiki names is easier.
19:51:02 <ddarius> Also, they are different, though it looks like the new one is better.
19:51:04 <cedricshock> What's the word type (google is failing me here)
19:51:13 <sorear> @src Word
19:51:14 <lambdabot> Source not found. My mind is going. I can feel it.
19:51:19 <sorear> bad lambdabot!
19:51:30 <sorear> data Word = W# Word#
19:51:51 <sorear>  @src+ anyone?
19:53:16 <ddarius> @index Word
19:53:16 <lambdabot> Data.Word, Foreign, GHC.Exts
19:53:22 <ddarius> @doc Data.Word
19:53:23 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Word.html
19:53:48 <cedricshock> I found this: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Word.html#t%3AWord
19:53:50 <cedricshock> Too late
19:53:51 <lambdabot> http://tinyurl.com/y2v567
20:01:55 <nohope> dons: There is yet nhc, right?
20:03:05 <sorear> nohope: haha...  nhc is dying fast
20:03:21 <nohope> :/
20:03:33 <sorear> nohope: it has this little assumption, wired very very deeply in, that all addresses have the high two bits zero
20:03:39 <dons> yhc is the nhc replacement. but nhc is being maintained.
20:03:50 <sorear> nohope: which was fine, in the grand old days of sbrk(2)
20:04:15 <nohope> ghc looks big when I would prefer a tiny compiler/interpreter :)
20:04:29 <sorear> nohope: but in th Age of Shared Libraries, it is very very fragile
20:04:37 <sorear> no such thing as a tiny haskell implementation.
20:04:45 <sorear> haskell is a huge language :(
20:05:16 <nohope> I just read on the GHC Release Notes that it can compile C++ too :-|
20:05:25 <sorear> also ghc is 1/15 the size of Linux, if that makes you feel better
20:06:59 <monochrom> 1/15 is big :)
20:07:23 <monochrom> "My spaceship is not that fast!  Just 1/15 the speed of light..."
20:08:17 <monochrom> It will come out as "M y   s p a c e s h i p  i s  n o t..." due to relativistic effects.
20:09:15 <dmwit> Curiously, the ellipsis is immune to relativistic effects.
20:09:45 <cedricshock> Wow, transposing this run-length encoded stuff is going to be EASY!
20:10:00 <sjanssen> I'd buy it if monochrom used the Unicode ellipsis character
20:10:17 <monochrom> …
20:13:06 <kc5tja> Well, I'm getting problematic error: head of an empty list exception.  But, ghci tells me nothing about what is throwing that exception: not where it is, or even a call trace.
20:13:11 <kc5tja> Any ideas on how to diagnose this?
20:13:26 <kc5tja> Algebraic substitution on paper suggests my code *should* work.
20:13:32 <kc5tja> (Clearly, though, it doesn't)
20:13:47 <sorear> nohope: if you want to give nhc the coup de grace, implement a OSX-compatible ffi layer.  this will cause Malcolm Wallace to switch to yhc.  concurrently, Matheiu Boespflog will finish rewriting the ghc-superior yhc type checker, and Neil Mitchell will finish his ghc-superior optimizer (part of his phd thesis)...
20:13:47 <sorear> in theory anyway
20:14:05 <sorear> kc5tja: compile with -prof -auto-all, run with +RTS -xc, it just might work
20:14:17 <cedricshock> Unfortunantly, it looses all the benefits of sparsity. Well, at least I learned something today.
20:14:55 <kc5tja> How do I tell ghci to compile with those options?  Just put -prof... on the ghci command-line as if it were ghc?
20:16:01 <sorear> kc5tja: nope, -prof is incompatible with --interactive :(
20:16:22 <sorear> kc5tja: is your ghc very very new? (> 6.7.200703xx ish)
20:17:27 <dmwit> Monoid has a lot of instances that lambdabot/hoogle don't seem to know much about,
20:17:55 <sorear> @instances Monoid
20:17:57 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
20:17:57 <dmwit> like All, Any, Dual a, Product a, Sum a, etc.  Any pointers where to look for more info?
20:18:06 <kc5tja> Nope.  6.6.1 I think.
20:18:10 <kc5tja> But, I know what it is.
20:18:12 <sorear> dmwit: vvv
20:18:16 <sorear> @docs Data.Monoid
20:18:17 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html
20:18:25 <dmwit> Thanks.
20:18:35 <kc5tja> case parent of .... where parent = head nonchildren (which in this case, nonchildren is empty)
20:18:42 <cedricshock> Hmm, fast transposition is available with the main list across the diagonal, but that makes getting rows and columns slow. I think I only get one direction of speed.
20:18:55 <kc5tja> I made an error on my paper substitution.
20:18:57 <kc5tja> So typical.
20:22:38 <sorear> hello ekidd
20:22:47 <ekidd> Hello!
20:24:12 <dmwit> So many monads... so little time.
20:24:19 <cedricshock> This, children, is why you don't try reinventing ways to do things that there's already a nice, standard library for.
20:30:50 * sproingie giggles
20:30:54 <sproingie> >>> Whether it be strategic planning, sales prospecting, company research or defining management best practices - Goliath is your leading source for accurat information.
20:31:31 <dmwit> Oh, monoids are really dead simple.
20:31:35 <dmwit> sorear++ helpful docs
20:32:38 <sorear> dmwit: yeah - about as simple as they come.
20:32:53 <sorear> dmwit: congradulations, you comprehend abstract algebra.
20:33:00 <dmwit> heh
20:33:26 <sorear> don't pay attention when lambdabot tells you 'math is hard'
20:33:26 <sproingie> is there a "monoids and arrows in plain english" resource around?
20:33:48 <dmwit> sproingie: There's a monoids in plain English here:
20:33:51 <sproingie> there's about 3589275981734987124 "monads in plain english" explanations, but i'm not sure what a monoid is
20:34:00 <dmwit> http://www.haskell.org/all_about_monads/html/writermonad.html
20:34:02 <lambdabot> Title: The Writer monad
20:34:02 <sorear> @google monoid
20:34:05 <lambdabot> http://en.wikipedia.org/wiki/Monoid
20:34:05 <lambdabot> Title: Monoid - Wikipedia, the free encyclopedia
20:34:26 <dmwit> sproingie: It's basically just a set with an associative binary operator and an identity.
20:34:28 <sorear> ime, wp's articles on abstract algebra concepts are pretty clear
20:34:35 <sproingie> yah um, not so sure about the plain english part
20:34:37 <sorear> no basically about it! :)
20:34:49 <dmwit> Well... I didn't say it was closed. ;-)
20:35:05 <sproingie> so any set that defines an operator on any two elements of the set?
20:35:34 <sorear> sproingie: the operator needs to be associative, and have an identity (a "zero")
20:35:35 <dmwit> sproingie: The set has to be closed under that operation, and it has to be associative, and you have to have an identity element... but yes.
20:35:48 <sproingie> ah, that maps to another element in the set
20:35:52 <dmwit> right
20:35:59 <sproingie> so Int is a monoid?
20:36:07 <sorear> sproingie: so, { foo x y = x ++ ":" ++ y } doesn't make [Char] a monoid, because it has no zero
20:36:07 <dmwit> It's two monoids.
20:36:16 <sorear> sproingie: very very very many
20:36:18 <dmwit> sproingie: Both Sum Int and Product Int are monoids.
20:36:22 <sorear> two are commonly used
20:36:33 <dmwit> sorear: Fair enough.
20:36:35 <sorear> sproingie: but plain (++) has zero ""
20:37:06 <monochrom> Suppose you write: (+) :: X -> X -> X.  This already implies "X is closed under (+)".  In the presence of a strong type system, you seldom need to say "closed under" beyond a type signature.
20:37:29 <kc5tja> AT LONG LAST, CUT's parser finally works, and properly handles nesting!
20:38:29 <sorear> sproingie: another way to look at this is to say monoids are a generalization of functions with the same argument and return types (like Int -> Int, Double -> Double, [Char] -> [Char])
20:38:39 <dmwit> monochrom: Yes, there's a slight difference between math monoids and Haskell monoids.
20:38:49 <sorear> sproingie: then mzero generalizes id, and mappend generalizes (.)
20:38:55 <sproingie> i can see the immediate use of monads and their properties, e.g. going from Maybe to List to get nondeterminism
20:39:10 <sorear> sproingie: this definition gives the same properties - see Cayley's Theorem
20:39:23 <sorear> sproingie: monoids are very useful too.  consider a tree fold
20:39:46 <sorear> sproingie: if you use a monoid, you don't have to worry about the result depending on how well the tree is balanced
20:39:46 <sproingie> mm yah
20:39:53 <sproingie> so you can generalize folds with monoids?
20:40:04 <sorear> sproingie: yes.
20:40:09 <sorear> @typ Data.Foldable.fold
20:40:12 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
20:40:35 <sproingie> that makes sense to me.  i was never good at abstract math, but folds i can grok
20:40:58 <sproingie> i'll have to come back in a bit and ask about arrows.  gotta grab dinner before the place closes
20:40:59 * monochrom uploads abstract mathematics for everyone to download
20:41:26 <monochrom> arrow is hot!
20:42:11 <sorear> sproingie: you will learn haskell.  you will learn abstract algebra and category theory in the process.  there is little more abstract than that.
20:42:52 <cedricshock> Any linear algebra libraries for haskell?
20:42:59 <monochrom> you will sheafify   *duck*
20:43:11 <kc5tja> monochrom: Sweet!  Except ... I can't make heads or tails of it.  ;D
20:43:17 * sorear STILL doesn't get fibre bundles :(
20:43:19 <monochrom> linear algebra is hot these few days
20:43:38 <monochrom> I actually just know those names and not what they stand for!
20:43:41 * sorear probably could, if he tried again (given that he knows general pointset topology now)
20:43:55 <dmwit> I wish All About Monads would use something other than the Continuation monad to explain monad transformers.
20:44:16 <dmwit> Continuation is the only one they talk about that I can't really approach yet.
20:44:20 * dmwit grumbles
20:44:22 <dolio> Hah.
20:44:24 <cedricshock> dmwit: I never got monads until I read the preprint that's online of that first arrow paper.
20:44:27 <monochrom> I wish Monads could be taught by all kindergartens.
20:44:56 <sorear> I finally grokked monads when I stopped trying.
20:44:59 <monochrom> Oh interesting!  Arrow may make Monad easier...
20:45:15 <dmwit> cedricshock: link?
20:45:19 <cedricshock> monochrom: Linear algebra is always hot.
20:45:31 <dmwit> I mean, I'm pretty good with IO, List, and State now. =P
20:45:35 <cedricshock> dmwit: Looking for it.
20:45:51 <kc5tja> Except, CUT is still emitting a truncated program.  GGAHHH!!
20:45:57 <kc5tja> At least the parser is known to work now though.
20:46:02 <kc5tja> One less piece of broken code.  :)
20:46:16 <dmwit> Yay!
20:46:30 <monochrom> Is that the true meaning of CUT?  That it cuts a program short?
20:46:39 <cedricshock> dmwit: doubly useful link: Hug00 in this: http://www.haskell.org/arrows/biblio.html
20:46:41 <lambdabot> Title: Arrows: bibliography
20:46:59 <sorear> I wish abstract math was more widely taught.
20:47:35 <monochrom> To be fair, you have to had experience with the concrete before you're ready for the abstract.
20:48:14 <cedricshock> sorear: Yeah, a lot of it fits in nicely at the high-school level.
20:48:19 <monochrom> Recall how you learned (+) for whole numbers.  You did like a million exercises before you really saw the point.
20:48:19 <astrolabe> cedricshock: there's a wrapper for LAPACK somewhere.  By the author of YAHC if I recall correctly.
20:48:31 <kc5tja> monochrom: Hahah!  I like that.  Unfortunately, no.  :)
20:48:55 <monochrom> Now isn't it obviously that similarly you need to meet a million examples of monads before you see general monads?
20:49:01 <kc5tja> However, I'm glad to have written an LR(0) parser entirely from scratch in a few handful of lines of code.
20:49:14 <sorear> Monoid == [res : *] [fun : [typ : *] [zero : typ] [oper : typ -> typ -> typ] [assoc : [a : typ] [b : typ] [c : ty] eq (oper a (oper b c)) (oper (oper a b) c)] [lz : [a : typ] eq a (oper zero a)] [rz : [a : typ] eq a (oper a zero)] res] res
20:49:19 <sorear> is just sooo elegant!
20:49:29 <kc5tja> Even though the token stream is recursive descent, writing a recursive descent parser obviously didn't work for some reason.
20:49:35 <kc5tja> So I busted out the big-guns.  ;D
20:49:47 <sorear> LR(0)?  really?
20:49:54 <kc5tja> sorear: yeah -- let me post.
20:49:56 * sorear still doesn't grok LR :(
20:50:45 <cedricshock> astrolabe: Yeah, I found that. I really want an interface for linear algebra (so I can not have a million by million sparse matrix in memory, and instead have the much smaller dataset that produces it)
20:50:50 <hpaste>  kc5tja pasted "Simplest possible LR parser in the world." at http://hpaste.org/1592
20:51:15 <sorear> cedricshock: haha.  meanwhile I (aside: is 16 and in high school) have to raid the irregular stash of books an old hippy math teacher left behind when he moved to thailand last year...
20:51:28 <sorear> and people wonder about my bizarre collection of subject
20:51:59 <Pseudonym> LR(0) parsers are easy.
20:52:18 <sorear> q: what do topology, number theory, galois theory and permutation groups have in common?  a: I had access to books
20:52:33 <cedricshock> sorear: I understand (a bit). I only know the things I've looked up myself online.
20:52:48 * sorear <3 wikipedia
20:52:54 <monochrom> Is this parser just popping things from input and pushing them to output?
20:53:02 <Pseudonym> But for extra credit, turn this into a QLR parser./
20:53:14 <astrolabe> Sounds as though the hippy had good taste
20:54:07 <dmwit> type Mathematician :: Coffee -> Theorem
20:54:17 <kc5tja> monochrom: For everything except Takedown tokens, yes.  Takedown tokens performs an LR reduction, where the last n nodes (where n is the number of nodes in the enclosing scope) is removed from the output list and is attached to its parent node (which IS still in the output list).
20:54:29 <dmwit> err... s/::/=/
20:54:37 <astrolabe> type CSGuy :: DrPepper -> Program
20:54:53 <kc5tja> astrolabe: Nice.  :)
20:55:07 <astrolabe> I copied dmwit :)
20:55:09 <monochrom> I see. Interesting.
20:55:31 <kc5tja> monochrom: That's why I said it's the simplest possible LR parser.  If it didn't do a reduction, it wouldn't be a parser.  :)
20:55:32 <dolio> Oh good. Doom in the browser.
20:55:43 <dmwit> dolio: Eh?
20:55:45 <sorear> shouldn't the result type be [Program] ?
20:56:05 <dmwit> Maybe (Program, Piss).
20:56:16 <dolio> dmwit: http://canvex.lazyilluminati.com/83/play.xhtml
20:56:23 <dmwit> sorear: It takes more than one DrPepper to make more than one Program... =)
20:56:32 <sproingie> there should be a beverage monad then
20:56:38 <sorear> No wonder my GHC compile was causing soo little disk activity.
20:56:40 <dmwit> ... THAT Doom.
20:56:42 <dmwit> Wow.
20:56:45 <sorear> I forgot to run make :)
20:57:21 <monochrom> Did you ran "runhaskell Setup build" instead?
20:57:28 <kc5tja> sorear: Did you look at the code?  Was it helpful in illustrating how LRs work?
20:57:42 <kc5tja> Pseudonym: Never heard of QLRs.
20:57:45 <sorear> kc5tja: I know how LR parsers *work*
20:57:54 <sorear> kc5tja: I just don't know how to write them
20:58:02 <Pseudonym> Right.
20:58:07 <dmwit> dolio: It could be faster. =P
20:58:09 <kc5tja> Ahh, well, hopefully my code will help serve as an illustration.
20:58:17 <Pseudonym> kc5tja: It's a generalisation of "Even Faster LR Parsing".
20:58:17 <dolio> dmwit: Don't blame me. :)
20:58:27 <dmwit> =)
20:58:28 <sorear> IOW, happy's output is comprehensible.  happy itself is opaque.
20:58:39 <kc5tja> Although I *do* cheat by using the output list as the token list as well (not practical in all LR parsers)
20:59:20 <kc5tja> Pseudonym: I have to admit, I hadn't intended on writing it as an LR parser -- it just fell naturally out of the design.  I didn't recognize it for what it was until after I'd finished drawing up the initial set of equations in my notebook.
21:00:06 * sproingie notices another parser called frown.  how's frown compare to happy?
21:00:12 <sorear> AHHH!!!
21:00:20 <kc5tja> My next step is to reimplement CutEmit so that it properly compiles the parse tree into C.
21:00:30 <sorear> Ghc really doens't want to compile :(
21:05:54 <merus> Mathematicians are clearly comonadic. ;)
21:06:18 <sorear> well, ghc is building now...
21:06:30 * sorear eagerly awaits the NewGhciDebugger
21:07:39 <monochrom> which version building you are?
21:08:30 <sorear> 6.7.20070426
21:08:42 <sorear> i'm compiling it with 6.7.20070323
21:08:57 <sorear> 6.7.20070413 doesn't expose GHC.Prim
21:09:04 <sorear> Igloo calls this a feature
21:09:09 <sorear> JaffaCake calls this a bug
21:09:18 <sorear> in any case, it breaks self-compilation
21:09:22 <sjanssen> won't that break a bunch of things?
21:09:25 <monochrom> does anyone call it a prank?
21:10:32 <sorear> sjanssen: no, because Igloo says everyone should have been importing GHC.Exts all along
21:11:12 * sjanssen didn't even know about GHC.Exts
21:12:16 <sorear> YES!!! my gfind clone is finally working properly.
21:13:06 <monochrom> Congrats.  Why clone?
21:15:05 <sorear> Mostly to make sure I understand it.  I've got an ideas for how to make it much much faster.
21:16:05 <sorear> hopefully, once I finish cloning it, I'll remember to make my changes to the real one :)
21:17:34 <dino-> I'm having a funny laziness problem. I have test case code that creates a file, then I use System.Posix.Files fileExist to make sure it's there. Then delete the file with System.Cmd.system, in that order in the do block..
21:17:42 <dino-> If I remove the last rm step, it works.
21:17:52 <dino-> Seems like it's being lazy about the fileExist
21:17:57 <sorear> I'd also kinda like to see how small I can make a speed-optimized finder, with a small table-driven C engine and all the support logic in haskell.
21:18:23 <sorear> aside: why don't you use System.Directory.removeFile?
21:18:34 <sorear> System.Directory.fileExist, too.
21:18:47 <monochrom> Do you create file and delete it in the same code?
21:18:55 <dino-> sorear: I was trying to remove the whole dir and it wasn't working earlier, but that's probably path problems I was having with my created strings.
21:19:13 <dino-> monochrom: no, another process creates the file.
21:19:28 <dino-> monochrom: That gets invoked with runInteractiveProcess
21:19:57 <monochrom> unix? windows?
21:20:01 <dino-> Linux
21:20:10 <dino-> It makes me vaguely nervous that this isn't behaving like a sequence. :o
21:20:32 <monochrom> Do you wait for the process to finish before deleting?
21:21:28 <dino-> monochrom: It's being executed with runInteractiveProcess, but I'm not really sure if it's finishing.
21:21:48 <dino-> Other tests test the output from the process and that's ok and present.
21:21:52 <dino-> In this same do block.
21:22:19 <monochrom> Does rm tell you something?
21:23:11 <mauke> which was the broken function?
21:23:15 <kc5tja> Does Data.ByteString.concat join strings terminated by \n into a single string?
21:23:29 <kc5tja> It's certainly looking like it in CUT's behavior.  :(
21:23:31 <dino-> monochrom: Not sure, I'm not grabbing its output or exit code. I can check that.
21:24:47 <ddarius> :t Data.ByteString.concat
21:24:53 <lambdabot> [Data.ByteString.Base.ByteString] -> Data.ByteString.Base.ByteString
21:25:32 <kc5tja> ddarius: That's not what I asked; I already know that.  My question is, does "abc\ndef" -> "abcdef"?
21:25:36 <ddarius> kc5tja: Why the heck would it do that?
21:25:57 <kc5tja> That's what I'd like to know.
21:26:17 <ddarius> > Data.ByteString.concat [pack "abc\ndef"]
21:26:18 <lambdabot>   Not in scope: `pack'
21:26:19 <kc5tja> Yet, given code that has embedded newlines inside of strings, displaying it produces no newline effects.
21:26:27 <ddarius> > Data.ByteString.concat [Data.ByteString.pack "abc\ndef"]
21:26:28 <lambdabot>   Not in scope: `Data.ByteString.pack'
21:26:38 <ddarius> @index pack
21:26:39 <lambdabot> bzzt
21:26:51 <kc5tja> > "abc\n" ++ "def"
21:26:53 <lambdabot>  "abc\ndef"
21:27:06 <kc5tja> OK, so it's not ++...
21:27:25 <sorear> kc5tja: " ....\  <newline> \..." does NOT embed a newline
21:28:56 <kc5tja> What?
21:29:05 <kc5tja> I'm using \n!
21:29:37 <sorear> \n should do it...
21:31:05 <dino-> Trying to pring out the ExitCode, it never gets to that hPutStrLn action after the system action. Fails at the assertBool one that's killing the whole expression.
21:31:10 <dino-> s/pring/print/
21:32:03 <kc5tja> Huh, note to self: when debugging, make sure you run the correct executable!
21:34:01 <monochrom> Oh, that's why. :)
21:35:43 <kc5tja> Heh
21:35:45 <kc5tja> Yeah.
21:35:53 <kc5tja> I was rather worried there for a moment.
21:36:12 <kc5tja> Hmmm...it parses the input files fast, but output is taking forever as it's munging memory at voracious rates.
21:36:31 <dino-> Same thing occurs when I try System.Posix.Directory.removeDirectory
21:36:32 <kc5tja> Note to self: don't feed Haskell version of CUT a 7MB hunk of source code.
21:38:02 <kc5tja> SWEET.  Except for the length of time involved in its execution, CUT 2.6 in Haskell produces correct output (well, in so far as I've been able to define it in Haskell).
21:38:27 <kc5tja> This calls for a few burgers.
21:41:40 <dons> time to profile :-)
21:41:46 <dons> and think about data structures ;-)
21:47:10 <narain> is there a way to dump the transcript of a ghci session?
21:47:27 <narain> (assuming i hadn't thought of it ahead of time)
21:48:28 <narain> oh wait, i can just use :r to reload the updated source without quitting ghci, right?
21:49:13 <sorear> man 1 script
21:50:30 <shoffsta> script -c ghci output_file
21:50:31 * narain looks at man
21:50:38 <mauke> or just :
21:50:46 <monochrom> Yes :reload
21:51:12 * dmead is back (gone 12:47:15)
21:51:16 <dino-> Huh, I knew about :reload and :r, but not just : alone.
21:51:16 <dmead> allo channel
21:51:30 <monochrom> ehlo
21:51:55 <narain> i like :
21:52:33 <narain> but will it clobber my types? as in if i have values of a custom datatype and it reloads the type definitions which may or may not have changed, what will happen
21:52:40 <narain> ?
21:53:15 <hpaste>  monochrom pasted "System.Posix.Files" at http://hpaste.org/1593
21:53:34 <Heffalump> narain: it'll clobber everything you've defined in the REPL
21:53:38 <monochrom> dino-: The pasted code works for me.
21:53:38 <Heffalump> whether things have changed or not
21:53:57 <narain> Heffalump: oh. hm.
21:57:55 <narain> ?src Eq
21:57:56 <lambdabot> class  Eq a  where
21:57:56 <lambdabot>     (==), (/=)   :: a -> a -> Bool
21:59:54 <monochrom> ?src Arrow
21:59:55 <lambdabot> class Arrow a where
21:59:55 <lambdabot>     arr, pure   :: (b -> c) -> a b c
21:59:55 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
21:59:55 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
21:59:55 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
21:59:57 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
21:59:59 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
22:00:39 <narain> ?pl \x y -> g (f x) (f y)
22:00:40 <lambdabot> (. f) . g . f
22:01:04 <narain> ?pl \y -> g (f x) (f y)
22:01:05 <lambdabot> g (f x) . f
22:05:23 <sproingie> arrow definitely confuses me
22:05:45 <merus> Arrows are great! :D
22:05:50 <sproingie> the types are just alphabet soup until i know what they actually *mean*
22:05:53 <dons> woot, http://programming.reddit.com/info/1ld0m/comments
22:05:55 <lambdabot> Title: Haskell Weekly News: New GHC, Xmonad, DisTract, Jobs, Libraries, User Groups! (r ...
22:06:16 <monochrom> arrow is a generalization of functions. for the most part you just have to think: generalize to support exceptions, states, nondeterminism.
22:07:07 <sproingie> i can't really grok generalization of function beyond a -> b
22:07:07 <mauke> how many arrow tutorials are there?
22:07:08 <monochrom> Whenever you see "Arrow a => a x y" imagine the first-order approximation x->y.
22:07:51 <sorear> dons++ HWN
22:08:10 <monochrom> wikibook has a short section
22:08:32 * merus should think of a toy program for demonstrating arrows
22:09:30 <monochrom> > ((+ 1) >>> (+ 2)) 5
22:09:32 <lambdabot>  8
22:09:37 <monochrom> Like that? :)
22:09:57 <merus> lol, yeah
22:10:00 <monochrom> > ((+ 1) >>> (* 2)) 5
22:10:02 <lambdabot>  12
22:10:13 <monochrom> That one illustrates order.
22:10:34 <eumenides> > (snd &&& fst) (1,2)
22:10:36 <lambdabot>  (2,1)
22:10:47 <Cheery> > ((+ 1) &&& (* 2)) 5
22:10:49 <sproingie> how does >>> differ from .?
22:10:49 <lambdabot>  (6,10)
22:11:10 <sproingie> or for functions, is >>> the same as . ?
22:11:12 <monochrom> >>> works for other arrows.  >>> for pure functions is just flip(.)
22:11:13 <dolio> It's backwards.
22:11:29 <Cheery> I'd like to see arrows in other things as well than just with functions and numbers
22:11:37 <Cheery> @dice 1d6
22:11:38 <lambdabot> 1d6 => 2
22:11:39 <Cheery> @dice 1d6
22:11:40 <lambdabot> 1d6 => 6
22:11:40 <Cheery> @dice 1d6
22:11:41 <lambdabot> 1d6 => 3
22:11:47 <Cheery> hmm
22:11:51 <Cheery> @dice 3d6
22:11:51 <lambdabot> 3d6 => 9
22:12:07 <kc5tja> @dice 10d4+5
22:12:08 <lambdabot> 10d4+5 => 33
22:12:20 <kc5tja> OUCH -- that's more than my hitpoints.  Time to roll up a new character.  :)
22:12:55 <monochrom> haha
22:13:10 <mauke> I finally understand how to use monad transformers
22:13:19 <mauke> but I have no idea what arrows are supposed to do
22:13:27 <kc5tja> I don't, but then again, I haven't yet had a need to use them.
22:14:02 <monochrom> I'll cook up the next example in a minute. Need to lookup doc first for exact syntax.
22:14:06 <sproingie> so a >>> b basically means feed a to b, &&& means return both a and b
22:14:09 <kc5tja> Just as the 80s was the decade for modular programming, the 90s for object oriented programming, so I hope the 2000s-2010s to be the decade for functional programming.
22:14:17 <Cheery> btw, about monads: http://dev.codeflow.org/svn/cheery/small.programs/ForthMonad.hs
22:14:18 <sproingie> what's *** do?  I'm having trouble coming up with something that can show
22:14:45 <sorear> > ((+1) *** (*2)) (10,20)
22:14:47 <lambdabot>  (11,40)
22:14:49 <mauke> *** looks like parallel plumbing
22:15:14 <dons> > (id *** toUpper) ('x', 'x')
22:15:15 <lambdabot>  ('x','X')
22:15:20 <sproingie> weird
22:15:31 <sproingie> but neat
22:15:31 <dons> Cheery: yep. nice little stack monad.
22:15:53 <Cheery> kc5tja: I think 2000s-2010s won't be the decade for functional programming, ppl are just too simple for that to happen
22:16:05 <sproingie> people are as simple now as they always have been
22:16:11 <monochrom> The next step is partial function from x to y.  Think of it as x -> Maybe y but we package it up as an arrow.
22:16:31 <Cheery> sproingie: that's the problem
22:16:43 <dons> Cheery: through some more cores and there's no choice.
22:16:46 <sproingie> functional programming's just got to be taught.
22:16:56 <sproingie> and frankly, programming's largely a vocational skill these days
22:17:03 <sproingie> so there may be a permanent disconnect
22:17:05 <dons> 16 core amd boxes are maybe 3 years away from being standard desktops.
22:17:21 <mgsloan> yep, I'm pretty excited about distributed/multicore programming, as current popular languages can't do it properly
22:17:29 <sproingie> in some ways tho, FP is already here in different guises
22:17:38 <sproingie> BPEL and such are very dataflow-oriented
22:18:09 <mgsloan> provides a strong impetus for migrating to better languages, paradigms
22:18:10 <kc5tja> Cheery: One can hope.  FPLs are (slowly) gaining in popularity, which is damn nice.
22:18:37 <monochrom> The exact syntax is this.  After packaging up, the type of the arrow is written "Kleisli Maybe x y".  Any time you have "f :: Kleisli Maybe x y" and you want to convert it back to "x -> Maybe y" since they're equivalent, write "runKleisli f".
22:18:39 <sorear> current languages CAN do distributed/multicore.   and they will, as long as people have problems sufficiently hard to demand nontrivial amounts of CPU.
22:18:41 <merus> The wheel of fortune turns :)
22:18:52 <sorear> I am, of course, assuming optimizers do not become sentient.
22:18:59 <sorear> If that happens all bets are off.
22:19:30 <kc5tja> sproingie: what is bpel?
22:19:36 <monochrom> Also, if you have a function g :: x -> Maybe y, you can convert to the arrow world by "Kleisli g".
22:20:12 <sorear> By 'nontrivial' I mean >1 day, ie serious scientific computing, NOT script jobs.  Haskell will conquer those.
22:20:19 <mgsloan> sorear - well, current 'popular' languages can do it, but not well
22:20:28 <sproingie> kc5tja: business process execution language
22:20:42 <monochrom> Finally, if you have a pure function x->y and you also want to lift it to the arrow world, "pure f" or "arr f".
22:20:50 <narain> is there any way (other than newtype) that i can override an instance declaration of an existing type? i want  show  to behave differently but the library i'm using already derives it for that type
22:20:52 <Cheery> does haskell have virtual machine -form of some sort?
22:21:01 <monochrom> So now here are some example programs.
22:21:02 <sorear> Cheery: like the York vm?
22:21:07 <kc5tja> Cheery: yes.
22:21:15 <mauke> narain: AFAIK no
22:21:34 <Cheery> ok, that's great then.
22:21:35 <sorear> Cheery: http://haskell.org/haskellwiki/Yhc/RTS
22:21:37 <lambdabot> Title: Yhc/RTS - HaskellWiki
22:21:51 <monochrom> > runKleisli (pure (+ 1) >>> pure (* 2)) Nothing
22:22:01 <monochrom> Hmm that may be wrong.
22:22:03 <narain> mauke: ok, thanks anyway
22:23:09 * merus squees at Data.Proposition !
22:23:22 <Cheery> sorear: think about replacing the javascript with some better language and turn browsers to frontends rather than huge monolithic pieces of shit and you have the rough idea what I'm wondering now.
22:23:32 <monochrom> But no one is listening, so that's fine!
22:24:00 <eumenides> > runKleisli (Kleisli print >>> Kleisli print) 1
22:24:02 <lambdabot>  <IO ()>
22:24:03 <sproingie> got distracted by the RL conversation around here
22:24:04 <mgsloan> hah, yeah, that'd be cool cheery
22:24:05 <Cheery> I'd like to know what's behind the reactive programming -stuf
22:24:22 <mgsloan> though javascript isn't so horrid
22:24:32 <sproingie> i don't quite get the Kleisli stuff just yet
22:24:43 <kc5tja> *OUCH!*  That hurt!  Take this!  data foo = bar | baz | blort!
22:24:50 <kc5tja> ^-- reactive programming
22:24:54 <mgsloan> it's more the browsers, and their incompatibilities.  I'm not going to really do any web stuff until this happens though
22:25:12 <Cheery> mgsloan: yes
22:25:24 <monochrom> haha kc5tja
22:25:47 <Cheery> I neither hate the javascript itself so much, but the fact that somebody smartass decided that .html should be major distribution format for everything
22:26:35 <kc5tja> let v = form (lion LionColor.black) (head Voltron) in ...
22:27:01 <Cheery> Of course it was good idea, especially if we lived in last century.
22:27:02 <kc5tja> Totally -- XML, HTML, I hate them all.
22:27:08 <mgsloan> hah, yeah
22:27:15 * kc5tja rather liked the syntax of Curl.
22:27:18 <kc5tja> (note: not cURL)
22:27:30 <kc5tja> Curl was the application of Lisp-like syntax to hypertext documents.
22:27:41 <Cheery> thought, it's nice to see that services and programs start being largely more important than hypertext documents.
22:27:45 <kc5tja> It looked like someone cross-breeded TeX and HTML, but it was compact, easy to work with, and produced good results.
22:27:47 <mgsloan> the internet in general is getting worse as far as all that goes.  I really hope ipv6 DOESN"T catch on
22:28:12 <sproingie> stick with the elegance that is ipv4, eh?
22:28:15 <kc5tja> mgsloan: Why?  IPv6 is just a datagram transport.
22:28:26 <Cheery> so people *should* have some sort of dreams towards virtual machines oriented web.
22:28:30 <kc5tja> And it's substantially simpler than IPv4.
22:28:40 <mgsloan> I thought ipv6 had 2 additional bytes.  I was wrong.  It's freaking 16 bytes!
22:28:55 <kc5tja> Yes, but it's a 16-byte long consistent entity.
22:28:57 <mauke> oh noes! teh bytes!
22:29:24 <kc5tja> Realistically speaking, though, if you want to conserve bandwidth like a bat out of hell, use CIF.
22:29:32 <kc5tja> (ATM Cells In Ethernet Frames).
22:29:48 <kc5tja> Or, better yet, use Frame Relay raw for the layer 2 protocol.
22:29:57 <sproingie> routing is overrated
22:30:11 <mgsloan> true.  I just shudder to think of all that overhead...
22:30:37 <mgsloan> Overhead that's waay unnecessary
22:31:16 <kc5tja> Well, by the time it does catch on, it will undoubtedly utilize a revision of VJC, since CPU compression and decompression will be cheaper than the raw I/O itself.
22:31:58 <mgsloan> ah, cool
22:32:04 <Cheery> mgsloan: I think that's substantially worse overhead that happens when you query wikipedia
22:32:27 <mgsloan> true, but that's probably more fixable
22:32:33 <Cheery> I don't like the idea of getting tons of stuff I don't need to know, like the layout, navbars, etc.
22:32:35 <kc5tja> 22:29 < mgsloan> true, but that's probably more fixable
22:32:45 <kc5tja> ^-- that message is about the size of a full TCP/IPv6 header.
22:32:55 <mgsloan> yeah, scary isn't it?
22:33:06 <kc5tja> Yup.
22:33:10 <mgsloan> every single data packet carries something that big
22:33:44 * kc5tja is actually a rather large fan of ATM.
22:33:47 <eumenides> hm there's no function flip :: Map k a -> Map a k?
22:34:04 <kc5tja> Even though ATM wastes 10% of link bandwidth, it ends up _saving_ bandwidth when you realize it obviates the need for TCP all-together.
22:34:20 <Cheery> @hoogle Kleisli
22:34:20 <lambdabot> Control.Arrow.Kleisli :: a -> m b -> Kleisli m a b
22:34:21 <lambdabot> Control.Arrow.Kleisli :: newtype Kleisli m a b
22:34:21 <lambdabot> Control.Arrow.runKleisli :: Kleisli m a b -> a -> m b
22:34:26 <monochrom> You could write one, eumenides
22:34:37 <mgsloan> sounds cool
22:35:54 <kc5tja> And for wireless links, some X.25 variant should be used instead of Ethernet, because, well, end-to-end TCP connection over a link with high fault rates _per hop_ is just retarded.
22:36:53 <kc5tja> TCP/IP is great for the wired-LAN.  It pretty much fails miserably for everything else.
22:36:59 * kc5tja gets off his soapbox.  :)
22:37:06 <mgsloan> hehe
22:37:49 <Cheery> if TCP is that bad, why is it used?
22:37:54 <mgsloan> I must admit, if I designed the early internet, I'd probably have done a worse job.  I'd probably have each computer figure out the route and encode it in the packet, or something luny like that
22:38:12 <kc5tja> Cheery: Because 99% of the LANs are wired.
22:38:21 <kc5tja> And, therefore, have relatively low error rates.
22:38:27 <sproingie> @hoogle Monad
22:38:28 <lambdabot> Control.Monad :: module
22:38:28 <lambdabot> Data.Graph.Inductive.Monad :: module
22:38:28 <lambdabot> Data.Graph.Inductive.Query.Monad :: module
22:38:38 <sproingie> @hoogle Control.Monad
22:38:39 <kc5tja> Look at satellite communications, however, and you'll see that 50% is HDLC-based (aka X.25 variant) and 50% is NASA-proprietary.
22:38:40 <lambdabot> No matches, try a more general search
22:38:45 <sproingie> meh
22:39:01 <bos> @seen ndm
22:39:02 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 14h 42m 30s ago, and .
22:39:29 <kc5tja> Cheery: There is also the small matter of the protocol being developed in an open atmosphere, while HDLC and its ilk were corporate developments and (at the time) guarded.
22:39:43 <kc5tja> So, you end up with a _clear_ example of "worse is better" effect.
22:40:11 <kc5tja> Remember that ARPANet was designed for academic and land-based military use only.
22:40:24 <kc5tja> So the protocols were designed accordingly for that use.
22:40:33 * kc5tja isn't saying that TCP or IP are bad protocols.
22:40:53 <kc5tja> I *AM* saying that they're being used in environments that they never were designed for, and consequently _don't_ perform well in those fields.
22:41:27 <Cheery> you'd know my next question.
22:41:39 <kc5tja> Moreover, anyone who has ever had the fun of designing a communications transceiver of any significant bandwidth over any significant distance will be the first to tell you, "Bandwidth _ain't_ cheap."
22:42:44 <mgsloan> somewhat OT, but firewire is pretty impressive
22:43:10 <tessier> If stepcut returns I'm interested in a San Diego based HUG
22:43:23 <kc5tja> mgsloan: Short distances, well-shielded cables, local domain addressing only, non-globally-routable protocol.  All of which makes for a great personal area network.
22:43:30 <mgsloan> yep
22:43:52 <kc5tja> I especially find its addressing model and its inherent counter-rotating ring topology attractive too.
22:44:35 <kc5tja> Just as everything is a file (in principle) in Unix, in Firewire, everything is a chunk of memory.
22:44:42 <kc5tja> Want to send data to a device?  Write to its memory space.
22:44:46 <kc5tja> Even if it's not _really_ memory.
22:44:55 <mgsloan> hmm, know of any good docs on it?  (other than spec, unless that's decent..)  I'd be interested in learning more about it
22:45:02 <kc5tja> Different functions on different data are selected by writing to different sub-regions of a device's memory space.
22:45:05 <kc5tja> Simply brilliant.
22:45:09 <mgsloan> right, that's one of the coolest things - not routing all the data through the cpu
22:45:49 <mgsloan> ooh, different functions? now there's an idea...  (I'm thinking of functions in the haskell and erlang sense..)
22:45:49 <kc5tja> Well, in most cases, the CPU is notified when the transmission is done, just like Ethernet.
22:46:45 <mgsloan> sure, but if you had a firewire hard drive and a firewire camcorder...  no need for your cpu to be the go-between
22:47:11 <kc5tja> Well, like, a hypothetical disk interface might have a write buffer from DISK+0 to DISK+511, and a read buffer at DISK+512 to DISK+1023.  Write control registers might appear at DISK+1024, while read control registers appear at DISK+1536.  So, writing data would involve stuffing data at DISK+0..511, and then writing control data to DISK+1024..
22:47:25 <kc5tja> Oh, I see what you mean.
22:47:29 <kc5tja> yeah, I like that feature VERY much.
22:47:38 <kc5tja> I haven't seen that since IEEE-488.
22:49:56 <sproingie> so everything in firewire is memory-mapped?  interesting.
22:50:59 <sproingie> sounds like that would necessarily have to be a driver abstraction tho.  unless it's unnecessarily intimate with the memory controller
22:52:25 <kc5tja> sproingie: Everything is _modeled_ as memory, yes.
22:52:27 <mgsloan> well, the abstraction would be implemented on the devices.  However, yes, I think some devices directly map to actual mem
22:52:31 <kc5tja> It doesn't actually _have_ to be memory though.
22:52:59 <Cheery> do you guys know resources for really catching the arrows?
22:53:12 <Cheery> I sort of understand what they are, but not what for.
22:53:26 * kc5tja doesn't even grok monad transformers yet; I doubt I'll be able to help with arrows at my level of knowledge.  :)
22:53:41 <Cheery> I'd like to see a practical thing about their usage.
22:54:57 <mgsloan> The wikibooks article i read was pretty simple, but for some reason I can't believe that arrows would have so much 2-element-tuple specific stuff
22:55:07 <sproingie> this was a good one for monad transformers: http://sigfpe.blogspot.com/2006/05/grok-haskell-monad-transformers.html
22:55:12 <lambdabot> Title: A Neighborhood of Infinity: Grok Haskell Monad Transformers, http://tinyurl.com/y6w3jr
22:55:18 <mgsloan> though I think maybe it was half done and hadn't gotten to the juicy stuff
22:55:38 <kc5tja> sproingie: You just made up that article now because there are too many common words with my own statement.  ;D
22:56:07 <sproingie> har.  nope, you just reminded me of it
22:56:28 <kc5tja> Well, I'll throw that onto my list of things to read.
22:56:46 * kc5tja is currently having much fun hacking on CUT after about a month and a half of deadtime.
22:56:51 <sproingie> he has an article on arrows too, but unfortunately no real examples
22:56:58 <sproingie> kc5tja: what's CUT?
22:57:06 <kc5tja> http://www.falvotech.com/content/cut
22:57:09 <lambdabot> Title: CUT
22:57:09 <sproingie> he mentions comonads too ... something *else* i don't know about
22:58:38 <eumenides> http://www.cs.chalmers.se/~rjmh/afp-arrows.pdf this is good
22:58:47 <sproingie> i use cxxtest myself for unit tests in C++
22:58:53 <sproingie> and i don't code in C if I can at all help it :)
22:59:39 <sproingie> ooh 56 pages.  got some readin' to do i guess
22:59:57 <monochrom> I don't code in C.  I ask ghc to do that. :)
23:00:52 <sproingie> is there anything like python's doctest for haskell?
23:01:31 <dons> sproingie: what does it do?
23:01:49 <sproingie> dons: lets you embed tests in comments.
23:01:57 <sproingie> >>> add(1,2)
23:01:57 <sproingie> 3
23:02:10 <sproingie> er, forgot the comment indicators :)
23:02:35 <sproingie> examples right here: http://docs.python.org/lib/module-doctest.html
23:02:37 <lambdabot> Title: 23.2 doctest -- Test interactive Python examples
23:03:02 <monochrom> quickcheck can do that and beyond
23:03:27 <kc5tja> sproingie: I'm sorry -- that article on transformers is just plain opaque.  I can't follow it AT ALL.
23:03:42 <encryptio> how do i put/get/push/pull to/from an ssh server on a nonstandard port using darcs?
23:03:52 <kc5tja> I mean, it introduces a nice set of rules of thumb for using them, but without an understanding of how they work, I just don't feel comfortable using them at all.
23:04:29 <sproingie> kc5tja: the syntax for stacking monad transformers is still kind of opaque to me
23:04:41 <araujo> hello
23:04:58 <kc5tja> encryptio: Not sure.
23:05:13 <sproingie> kc5tja: but the end result is that once you're done, you just call 'lift' to do a computation in the transformed monad
23:05:15 <kc5tja> sproingie: He says that, "It all becomes obvious when you see how to use it."  Uh huh.  Riiiiight.
23:05:34 <sproingie> kc5tja: i suspect it becomes obvious with practice
23:05:39 <araujo> anybody would know what it is the opposite key binding for Shift-A on vim? (go to the beginning of the line)
23:05:43 <encryptio> all i've found on the subject is an old mailing list post from sep. '04...
23:05:51 <encryptio> araujo: shift-i
23:05:52 <kc5tja> shift-I
23:05:54 <sproingie> i wouldn't know, the syntax still befuddles me.  the concept clicks though
23:06:01 <araujo> Thanks encryptio kc5tja
23:06:38 <sproingie> i guess a lot of the monad transformers in the standard library don't even need lift
23:06:43 <kc5tja> encryptio: Does it use normal URL syntax for ports?
23:06:51 <sproingie> not sure how they do that, but it's sure convenient
23:06:52 <kc5tja> ssh:userId@host:port maybe?
23:07:13 <encryptio> kc5tja: darcs doesn't for ssh... i'll try that, but it didn't work last time (similar style)
23:07:22 <kc5tja> encryptio: Hmmm...
23:07:40 <encryptio> "ssh: ssh: No address associated with nodename"
23:07:51 <encryptio> and various other errors stemming
23:07:52 <kc5tja> Might not be doable then, at least from the command line.  Maybe looking at some of the control files inside _darcs might yield an SSH command preferences setting?
23:07:54 <monochrom> I start with a state monad.  The state is an int.  So the full type is "State Int a".  The monad part is "State Int" without the "a".
23:08:37 <kc5tja> Right.  The 'a' part is what would be returned by a function in a program.
23:08:38 <sproingie> huh, quickcheck looks nifty indeed
23:08:52 <monochrom> That is, whenever I see "(Monad m) => ..." it is legal to substitute "State Int" into m.  Note no "a".
23:09:00 <sproingie> i guess one type of 'property' you can give quickcheck is a literal example?
23:09:19 <monochrom> Yes, one type of property is a literal test case.
23:09:45 <sproingie> cool.  can it be embedded in literate haskell docs?
23:09:51 <monochrom> Next, I want to add a reader monad over my state monad.
23:10:34 <Cheery> hmm
23:10:43 <Cheery> could you make neural networks with arrows?
23:11:09 <Cheery> and what kind of thing would it be as an idea?
23:11:09 <sproingie> i imagine arrows are turing complete
23:11:12 <monochrom> The environment of my reader is Bool.  The type of the whole thing is then "ReaderT Bool (State Int) a".
23:11:55 <kc5tja> I don't understand what you mean by "The environment of my reader is Bool."
23:12:41 <monochrom> Here is how I figure out that type.  I go to the doc of ReaderT.  It says "ReaderT r m a".  r is intended to be the environment.  m is intended to be the lower monad.  a is the polymorphic type variable.  So I put r = Bool, m = State Int (recall the foregoing discussion).
23:12:43 <encryptio> here seems to be a patch that fixes the problem: http://tinyurl.com/2d8ctc
23:13:12 <sproingie> would love to stay up, learned lots of haskell today from here, but i gotta blaze
23:13:18 <monochrom> You need to know the idea of the reader monad before any sentence of the form "my environment is ____" makes sense.  It doesn't have to be Bool.
23:13:48 <sproingie> or more like fizzle. time for bed.
23:14:22 <sproingie> nite all
23:14:44 <kc5tja> monochrom: OK, I don't know reader monads, nor even what they're used for (yet).
23:16:05 <monochrom> Perhaps you understand adding a new layer of state over an old layer of state.
23:16:41 <monochrom> I start with a state monad. the state is Int.  "State Int a".  The monad part is "State Int".
23:16:52 <kc5tja> Well, that depends.  When I read stuff like that, I instinctively think, "Just don't do that."  :)
23:17:18 <monochrom> I just need "understand". I don't need "desire".
23:18:18 <monochrom> Next I add another layer of state on top of that.  I want to add Bool.  The whole thing is "StateT Bool (State Int) a".
23:18:52 <monochrom> Here is how I figure that out.  I go to the doc.  It says "StateT s m a".  I plug in s = Bool, m = State Int, as discussed.
23:19:31 <merus> Reader monads are awesome ^^
23:19:52 <monochrom> I think you know how to use get/put to access the Bool and lift get/put to access the Int.
23:27:31 <dons> merus: I think readers are awesome too :-)
23:27:38 <dons> nothing like them for implementing lexical scoping
23:28:54 <kc5tja> Well, I can't say I understand the concept of "lifting" either.
23:29:09 <kc5tja> It just seems so arbitrary to me sometimes.
23:29:20 <monochrom> It is just there to gain access to the lower monad.
23:29:45 <kc5tja> OK, "lower" monad -- so lifting it brings that monad "to the current" level so to speak.
23:29:56 <monochrom> After the stacking you have direct access to the upper one, and indirect access to the lower one through "lift".
23:30:02 <monochrom> YES!
23:30:42 <kc5tja> My next task would be to figure out how it's done behind the scenes.
23:30:49 <ski> @type lift
23:30:51 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
23:31:01 <kc5tja> God, I can't ead a type signature like that.
23:31:05 <dons> kc5tja: by wrapping things in constructors
23:31:10 <dons> F (G (H a))
23:31:30 <dons> :: t m (n a)
23:31:31 <merus> @src lift
23:31:31 <lambdabot> Source not found. Are you on drugs?
23:31:36 <merus> I suppose.
23:31:54 <monochrom> forall m a t. (MonadTrans t, Monad m) => m a -> t m a
23:32:40 <monochrom> m is the lower guy, t is the upper guy
23:33:15 <ski> lift :: State Int a -> StateT Bool (State Int) a    -- e.g.
23:33:31 <dibblego> why would I use Ix a => a instead of just Int?
23:33:45 <mahogny> more general?
23:33:58 <dons> dibblego: two dimensional indicies?
23:34:13 <dibblego> hrm
23:34:27 <monochrom> t = StateT Bool
23:36:04 <ski> (hm, even the emperor uses Ix ..)
23:36:33 <monochrom> which emperor?
23:38:09 <dibblego> have good weekend, I'm out
23:38:24 <monochrom> haha sometwo is derived from someone
23:38:25 <ski> hm .. maybe Shaddam IV ?
23:38:51 <monochrom> Maybe there are also allone, alltwo, ...
23:39:12 <ski> allzero
23:53:39 <johnnyl> @users
23:53:39 <lambdabot> Maximum users seen in #haskell: 329, currently: 298 (90.6%), active: 37 (12.4%)
