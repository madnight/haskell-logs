00:00:00 <goltrpoat> sorear:  how's that frontend going btw?
00:00:07 <Pseudonym> Ah.
00:00:15 <Pseudonym> Are you doing B-trees, hash tables and recno?
00:00:29 <Pseudonym> Again, we don't care about record number indexes for this application.
00:00:31 <sorear> right now my lambdabot hacks are being propped up with a 'TVar (Map ByteString ByteString)'
00:00:41 <sorear> obviously that won't scale for long
00:00:44 <goltrpoat> i got set back a couple of weeks due to work, got TC more or less working though.
00:00:53 <sorear> no, I'd just planned on doing b-trees
00:01:20 <sorear> I'm not sure I understand how to do atomic checkpoints with hash tables, and recno is a whole lot of huh?
00:01:28 <tuxplorer> there is a way to include C programs into haskell programs isn't it? I remember dons once saying something about it in his blog.. but I couldn't find it now.. What is that technique that should be used for using C code in haskell?
00:01:39 <sorear> @where ffi
00:01:40 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
00:01:50 <Pseudonym> goltrpoat: Haskell even provides special syntax for monadic code which makes it look like imperative code.
00:02:04 <sorear> goltrpoat: stalled.
00:02:05 <tuxplorer> Thanks
00:02:12 <Pseudonym> sorear: Right.  Well, recno makes sense as a record store.
00:02:17 <Pseudonym> We're not bothering with that.
00:02:34 <sorear> Pseudonym: I mean, I'm not sure I understand the point of recno.
00:02:35 <Pseudonym> We're only implementing hash tables because it eases the presentation of the likely JFP paper if you have those too.
00:02:46 <Pseudonym> sorear: It's for storing actual records in.
00:02:46 <sorear> my API is Map ByteString ByteString
00:03:06 <Pseudonym> A typical database has records, and then indexes which lets you look up those records.
00:03:33 <sorear> oh, so you would have a recno database, and a bunch of non-recno secondary dbs?
00:03:34 <Pseudonym> If you only have one key that you ever want to look up by, then yes, I can see how you might not need that.
00:03:38 <Pseudonym> Yeah.
00:03:43 <Pseudonym> Which map key to recno.
00:03:55 <mwc> Oh great... makedirhier isn't on my system.... makedirhier == mkdir -p?
00:04:05 <sorear> yeah.
00:04:17 <dons> @seen glguy
00:04:18 <lambdabot> glguy is in #haskell. I last heard glguy speak 3d 11h 10m 41s ago.
00:04:29 <dons> he just commented on reddit
00:04:33 <dons> so he's alive :-)
00:04:39 <qebab> 3 days and 11 hours idle is quite impressive
00:04:41 <ivanm> could be a timed comment...
00:04:52 <sorear> or a cracker!
00:04:55 <ivanm> heh
00:04:57 <dons> its a conspiracy!
00:05:04 <ivanm> the haskell auto-commenter program!
00:05:15 <dons> making all of #haskell appear foolish in public
00:05:20 <Pseudonym> Our application is actually text retrieval.
00:05:23 <dons> damn those lispers! damn them!
00:05:32 <ivanm> *nod*
00:05:45 <ivanm> we need an anti-conspiracy conspiracy!
00:05:53 <Pseudonym> In text retrieval, there usually is no "primary key" apart from record number.
00:05:58 <dons> you're with *them* ivanm , i can tell
00:06:04 <hpaste>  Glen pasted "My homepage" at http://hpaste.org/1492
00:06:17 <ivanm> *gasp* however did you find out, dons!
00:06:21 <dons> wow, we're getting spammed via hpaste?
00:06:23 * ivanm must flee now, whilst he can! :p
00:06:31 <goltrpoat> that's new
00:06:38 <ivanm> no its not...
00:06:58 <ivanm> I seem to recall a discussion a few months ago on whether or not we should restrict hpaste to #haskell nicks
00:07:16 <ivanm> because of vitriolic messages on hpaste
00:07:30 <goltrpoat> nice
00:07:58 <ivanm> but I think they were just spanish people on a related channel or forum, so it was haskell related... kinda
00:08:15 * sorear has acted!
00:08:28 <ivanm> play? musical? movie? TV ad?
00:08:31 <dons> sorear: oh, you have an admin passwd?
00:08:35 <dons> i could't remember mine :}
00:08:44 <dons> thanks sorear
00:08:44 <ivanm> heh
00:08:56 <sorear> yes I do.
00:09:55 <bos> sigh.
00:10:00 <hpaste>  Joe pasted "My homepage" at http://hpaste.org/1493
00:10:19 <bos> i just reimplemented norvig's python spellchecker in haskell, for fun, and the haskell version is way slower than the python version.
00:10:41 <mwc> damn, when's the last time hc-boot worked?
00:10:56 <bos> granted, it's not terribly idiomatic haskell, but still.
00:11:15 <monochrom> What does python spellcheck do?  I mean operationally.
00:11:43 <ivanm> sorear: again please?
00:12:11 <sorear> ivanm: huh?
00:12:11 <bos> generates a pile of possible corrections for a word based on probability, then return the most probable.
00:12:38 <sorear> ivanm: it's already deleted if that's what you mean
00:12:56 <ivanm> there was a new one, not sure if you spotted it, that's all
00:13:23 <ivanm> how about putting in a block to stop people from posting pastes with titles "my homepage"
00:13:48 <sorear> how about an IP block?
00:13:51 <ivanm> hmmm..... hpaste wouldn't happen to keep track of the IPs used to spam?
00:14:00 <ivanm> heh, just thought of that myself as well
00:14:09 <sorear> it wouldn't be hard to add
00:14:11 <qebab> might well be infected drones though?
00:14:33 <qebab> we caught a guy with a botnet on netgamers a couple of weeks ago
00:14:42 <sorear> qebab: imo, we should ban all zombies whether or not they are spamming
00:15:03 <qebab> I don't mind of course :)
00:15:17 <hpaste>  Patty pasted "My homepage" at http://hpaste.org/1494
00:15:47 <sorear> @seen glguy
00:15:47 <lambdabot> glguy is in #haskell. I last heard glguy speak 3d 11h 22m 10s ago.
00:16:01 <foxy-om> @src
00:16:01 <lambdabot> src <id>. Display the implementation of a standard function
00:16:06 <monochrom> I am an alien. No one understands me.
00:16:13 <foxy-om> @src nubBy
00:16:13 <lambdabot> nubBy eq []             =  []
00:16:13 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
00:16:18 <ivanm> how bout that one sorear?
00:16:40 <mwc> @seen dcoutts
00:16:40 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #haskell-overflow and #ghc. I last heard dcoutts speak 56m 47s ago.
00:16:53 <monochrom> An alien kidnapped glguy but it was not me.
00:17:11 <qebab> yeah right, sure it wasn't
00:17:17 <mwc> anybody know how to get the source of an ebuild from packages.gentoo.org?
00:17:36 <dcoutts> hia mwc
00:17:36 <mwc> their ghc pkgbuild must have a binary compiler to bootstrap from
00:17:57 <dcoutts> mwc: yeah, we've got a ghc-bin ebuild for bootstrapping
00:17:59 <mwc> dcoutts, would you gentoo guys happen to have a linux-ppc ghc binary floating around?
00:18:07 <dcoutts> we do, yes
00:18:24 <mwc> suppose you could link me to a tarball?
00:18:33 <mwc> tried to hc-boot 6.6, it died
00:18:43 <ivanm> dcoutts has everything you need, all at the one convenient location and at the right price :p
00:18:49 <dcoutts> mwc: lets move to #gentoo-haskell
00:18:59 <dcoutts> ivanm: ;-)
00:19:09 <ivanm> @bo
00:19:10 <lambdabot> :)
00:20:32 <narain> i just upgraded to ubuntu feisty and now Control.Monad.State is missing from ghc :(
00:20:42 <goltrpoat> mtl
00:20:45 <narain> has this happened to anyone?
00:20:59 <narain> goltrpoat: are you saying i need to install mtl?
00:21:09 <goltrpoat> aye
00:21:12 <goltrpoat> http://darcs.haskell.org/packages/mtl/
00:21:14 <lambdabot> Title: Index of /packages/mtl
00:21:49 <dons> ?hackage mtl
00:21:50 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mtl
00:21:56 <dons> is actually the place to get it from, not darcs
00:22:06 <narain> thanks! ubuntu seems to have a package for it
00:22:07 <dons> all the non-core packages are now distributed seperately, such as mtl.
00:22:13 <goltrpoat> ah
00:22:20 <dons> most are available from hackage, many are in the distros package system anyway
00:22:21 <narain> dons: since 6.6?
00:22:24 <dons> yeah
00:22:31 <narain> ah
00:22:46 <narain> i guess i didn't read the release notes too carefully
00:23:08 <dons> we're moving away from the (unscalable) cathedral distribution model, and towards a more decentralised system
00:23:19 <narain> i just searched for State in the 6.6 release notes and it wasn't mentioned so i gave up :)
00:23:20 <dons> since there are just 100s more packages now than we used to have
00:23:30 <narain> ah, i see
00:24:31 <monochrom> apt-get install libdev-ghc6-*
00:24:57 <monochrom> since the alternative (apt-get install ghc6) is too easy
00:25:08 <narain> monochrom: i guess you mean libghc6-*-dev, that's a good idea
00:25:48 <shachaf> narain: Actually, apt-get uses a regexp.
00:25:59 <shachaf> narain: So it's 'libghc6-.*-dev'.
00:26:03 <qebab> regexps /o\
00:27:00 <narain> good golly, there's a lot of them libghc6 packages
00:27:59 <narain> i don't want to install a library for embedding mozilla in haskell apps!
00:28:37 <dcoutts> narain: that's easy, just don't install libghc6-mozembed :-)
00:28:56 <dcoutts> mind you, that's a nice lib
00:29:11 <narain> i don't have that option with apt-get install libghc6-.*-dev, now do i?
00:29:18 <monochrom> sorry
00:29:19 <narain> i'm sure it's a nice lib
00:29:21 <dcoutts> hah
00:29:27 <narain> :)
00:29:38 <dcoutts> you might want to be a little more selective :-)
00:30:13 <hpaste>  sorear pasted "Pseudonym: approximately what I'm envisioning, re databases...  if there is a much simpler way to do" at http://hpaste.org/1495
00:30:19 <eumenides> http://hpaste.org/1478 any ideas why arrows-0.2 won't build?
00:30:37 <narain> i am, i'm going to install them one by one now since the take-em-all approach is giving me a broken dependency due to mozembed
00:33:10 <hpaste>  fantasma annotated "build errors (help!)" with "still no luck :(" at http://hpaste.org/1491#a1
00:33:47 <dcoutts> w
00:33:49 <dcoutts> erm
00:33:53 <dcoutts> @seen waern
00:33:53 <lambdabot> I saw waern leaving #ghc and #haskell 7h 38m 53s ago, and .
00:43:20 <sorear> @tell Pseudonym http://hpaste.org/1495
00:43:20 <lambdabot> Consider it noted.
00:48:48 <monochrom> Now is a good time to outline an automatic way of synthesizing a haskell program from quickcheck properties.
00:50:34 <joelr1> good morning
00:50:38 <joelr1> dons: thanks a lot!
00:52:06 <goltrpoat> was about to point monochrom to http://www.cs.ioc.ee/tfp-icfp-gpce05/tfp-proc/14num.pdf
01:00:08 <encryptio> @hooble [Maybe a] -> [Maybe a]
01:00:09 <lambdabot> No matches, try a more general search
01:00:14 <encryptio> lol, hooble
01:01:11 <sorear> filter isJust?
01:01:43 <encryptio> > (isJust Nothing, isJust (Just 1))
01:01:45 <lambdabot>  (False,True)
01:01:48 <encryptio> yep
01:02:21 <narain> > concatMap maybeToList [Just 1, Nothing, Just 2, Just 3, Nothing]
01:02:22 <lambdabot>  [1,2,3]
01:02:33 <ClaudiusMaximus> @src catMaybes
01:02:34 <lambdabot> catMaybes ls = [x | Just x <- ls]
01:15:33 <dons> joelr1: well, currently it is constrained to a single type of test. so you can't freely intermix pairs of things to test, with normal properties
01:15:59 <dons> what we'd need is to slightly extend the Testable class
01:16:12 <joelr1> dons: sort of what i thought /intermix/
01:16:41 <joelr1> dons: extend the one in quickcheck you mean, the base library?
01:16:53 <dons> i'd just replace it with a custom class for the driver
01:16:56 <joelr1> dons: i.e. modify qc to be more useful
01:17:04 <joelr1> dons: i see
01:17:05 <dons> wouldn't need to touch the QC library itself
01:17:18 <dons> yeah, extending QC in general is something that needs to happen
01:17:48 <joelr1> dons: i'll wait for you on this. don't have an idea of where to start (testable). i'm still afraid of qc, in fact
01:18:00 <fantasma> I tried everything....I couldn't get the x11 bindings to compile
01:18:39 <joelr1> dons: i just have unit tests for my translator but i figure once i have released the alpha and put it up on the wen then i can take a harder look at prop tests as bugs will come in
01:20:12 <dons> joelr1: i'd really start by trying to get some general properties in their first, for the api.
01:20:24 <dons> in particular, thing about simple things like f (f x) == f x for example
01:20:30 <dons> or are functions supposed to be invertible
01:20:35 <fantasma> dons: by any chance, are you aware of issues with compiling the x11 bindings on freebsd?
01:20:54 <dons> its much hard trying to refactor code to have nice properties, than to start by thinking in terms of properties as you code
01:21:04 <joelr1> dons: my biggest issue is writing arbitraries... i think
01:21:11 <joelr1> dons: i agree with you
01:21:15 <dons> as soon as you write a unit test though, you should be able to say: well, does this hold for all 'x'
01:21:24 <dons> if so, then make 'x' an argument to a qc property
01:21:35 <dons> fantasma: not aware of any issues
01:21:54 <dons> arbitraries take only a bit of practice. mostly you'll just need to see examples
01:22:36 <dcoutts> SmallCheck allows exists properties as well as forall properties
01:22:44 <joelr1> dons: true
01:22:55 <dcoutts> though I've not yet seen in practise and example of how that could be used
01:23:00 <joelr1> dcoutts: i can't tell when to use sc over qc
01:23:05 <dons> dcoutts: hmm, now that's interesting. are these directly just unit tests?
01:23:16 <dons> exists e . f e == g e
01:23:17 <dcoutts> joelr1: so what do you understand as the difference?
01:23:54 <joelr1> dcoutts: well, that qc can run a lot of unnecessary tests... that's it :)
01:24:06 <joelr1> dcoutts: i think sc does not use random, that too
01:24:28 <dcoutts> joelr1: right, so the crucial difference is in how they generate test data
01:24:58 <dcoutts> QC generates it randomly, with a vague notion of size of the test
01:25:18 <dcoutts> it starts with generally smaller test cases and gradually makes them bigger
01:25:22 <joelr1> dcoutts: i think with sc you generate all the prop values, right? non-randomly, right?
01:25:30 <dcoutts> right
01:25:35 <joelr1> dcoutts: i'm listening!
01:25:56 <dcoutts> SC generates *all* the test cases up to some depth threshold
01:26:18 <dons> using induction on the structure of the type.
01:26:25 <dons> dcoutts: are there any non-inductive generators in SC?
01:26:28 <dcoutts> eg if you ask for depth 6 and your test data is lists of ints then you get all tests of lists up to length 6
01:26:34 <dcoutts> and ints from -6 to +6
01:26:52 <dcoutts> dons: erm, what do you mean exactly?
01:27:08 <joelr1> so my biggest question then... when should i use sc? should i use it to test my translator, for example? with qc? instead?
01:27:54 <dons> dcoutts: is it possible to write, say, random generators for values in a type
01:28:34 <dons> or do they always proceed from a breadth first generation based on the type's structure?
01:28:59 <dcoutts> dons: well you could write an instance that was not in the spirit of SC, sure
01:29:13 <dons> so we could do QC-style random walk generators?
01:29:31 <Pseudonym> .quit
01:29:32 <Pseudonym> exit
01:29:32 <lambdabot> Pseudonym: You have 1 new message. '/msg lambdabot @messages' to read it.
01:29:34 <dcoutts> it must be deterministic since it's a pure function with no access to a rng
01:29:39 <Pseudonym> WHoops.
01:29:44 <dcoutts> dons: the series method just takes an int and returns a list of test cases
01:29:55 <Pseudonym> Bye!
01:30:03 <dons> ah right, yes. the purity complicates (or simplifies ;) things
01:30:35 <dons> so pretty much the only thing to go on is the type's structure
01:31:34 <dcoutts> dons: there's still quite a bit of flexibility actually
01:31:51 <dcoutts> eg you can chose the range of Chars you get when testing Char
01:32:00 <dcoutts> eg 0-255 is probably excessive
01:32:30 <dcoutts> for testing string parsing things you'd want a small range including space, nl and things
01:32:35 <joelr1> dcoutts: so what's the rule of thumbs on when to use smallcheck? the char range sounds enticing but it can be done with qc as well, i think
01:33:35 <dcoutts> joelr1: when you've got a type that you're concerned about getting good test case coverage on
01:34:37 <joelr1> dcoutts: when would i be concerned? i thought everything is possible with qc and custom arbitrary generators
01:35:01 <dcoutts> joelr1: eg imagine a type that has a large sub-space of values you want to test but generating them randomly too often doesn't hit that sub-space
01:35:40 <dcoutts> eg supposing all the interesting stuff for your algorithm is on pairs where the first component is 3
01:36:00 <joelr1> dcoutts: ok
01:36:13 <joelr1> dcoutts: can't you restrict qc to generate 3 as the first component?
01:36:16 <dcoutts> in this example we could write a custom generator that generated lots of ones where the fist component was that number
01:36:30 <dcoutts> but with SC we don't have to worry, we know we get full coverage
01:36:41 <joelr1> dcoutts: why not just generate 3 as the first component with qc?
01:37:01 <dons> yes, you could write non-random QC generators
01:37:08 <dons> but all those for the basic types are randomised
01:37:13 <dcoutts> so the point is, in more complex cases, we can worry less about wether we're really getting good test data coverage
01:37:49 <dcoutts> so they're somewhat complementary approaches
01:37:58 <dcoutts> exhaustive coverage of all the smallish cases
01:38:05 <dcoutts> and random coverage of some of the bigger cases
01:38:11 <joelr1> dcoutts: hmm
01:38:21 <dcoutts> some problems always show up in the small cases
01:38:25 <dcoutts> eg strictness bugs
01:38:35 <dcoutts> some need bigger examples
01:38:42 <dcoutts> it depends on what you're testing of course
01:38:47 <dons> yes, i can certainly imagine a flag to the generator optoins in QC that has it switch between randomised and directed generators of the value-space :-)
01:39:06 <joelr1> dcoutts, dons: I'm somewhat loath about randomly generating ASTs for example, pretty-priting and parsing them again as a test of my translator. maybe this is an area to apply smallcheck.
01:39:17 <joelr1> or could this be THE area to apply sc?
01:39:31 <dcoutts> joelr1: all ASTs up to depth 4 for example
01:39:36 <dons> yes, also, you should look at the recent paper on testing ASTs with Clean's QC implementation
01:39:46 <dons> did I point you to that previously, joelr1 ?
01:39:46 <dcoutts> joelr1: just make sure you don't use too wide a range of variable names :-)
01:39:54 <joelr1> dcoutts: that sounds right
01:40:02 <joelr1> dons: no, it's new to me
01:40:07 <joelr1> dons: where is it?
01:40:25 <dons> it was in APLAS last year, Plasjmeijer and hmm, who was the other author.
01:40:30 <dons> dcoutts: is it on your desk there?
01:40:39 <joelr1> dcoutts: i'll be digging for information and examples on smallcheck then, soon enough
01:40:39 <dcoutts> joelr1: so the problem with QC is ensuring quality of coverage, the problem with SC is preventing explosion of the testing space
01:40:53 <joelr1> dcoutts: understood
01:41:36 <dcoutts> dons: Koopman and Plasjmeijer
01:42:11 <joelr1> @google Koopman and Plasjmeijer aplas
01:42:12 <lambdabot> No Result Found.
01:42:14 <joelr1> hmm
01:42:23 <dons> joelr1: here, http://programming.reddit.com/goto?id=rrjp
01:42:30 <dons>  Automatic testing of higher order functions [pdf]   (st.cs.ru.nl)
01:42:35 <dons> is that it, dcoutts ?
01:42:39 <dcoutts> yep
01:43:48 <dons> oh, its actually about testing parsher combinatorsh, but that's still similar to ASTs
01:43:59 * dons uses his .nl FP-guy accent
01:44:31 <joelr1> dons: thanks
01:45:20 <joelr1> overall, i think i'm getting the right haskell spirit this time around. of course it helps that my area of application is one where haskell is strong
01:45:35 <joelr1> i have spent the past couple of days ... thinking of the right abstraction :D
01:47:18 <dons> i've seen you asking more introductory design questions this time around. that's been interesting. you're trying to learn the language more thoroughly?
01:47:56 <dons> you're writing an interpreter, iirc?
01:48:02 <joelr1> dons: i think so :-) i'm not heavy on theory so i just ask questions as i hit an implementation block
01:48:13 <joelr1> @google LtU easylanguage
01:48:15 <lambdabot> http://lambda-the-ultimate.org/node/2201
01:48:15 <lambdabot> Title: Easylanguage: domain specific language for trading stocks | Lambda the Ultimate
01:48:19 <dons> ah yes.
01:48:24 <joelr1> dons: i'm compiling this to c#
01:48:34 <dons> yes, if you can't write an dsl compiler in haskell, there's no hope :-)
01:49:03 <dons> syb traversals, rich ADTs for the syntax tree, and pattern matching alone give you most of the tools you need.
01:49:11 <dons> and with a good QuickCheck generator, you get testing too.
01:49:30 <dons> so you *better* get this done in haskell, or they'll be trouble! ;-)
01:49:33 <joelr1> dons: what are the basic design questions that i was asking? can you give me an example?
01:49:51 <dons> or, things like the use of QuickCheck, things like that.
01:50:01 <dons> sort of feeling your way back into everyday haskell coding practices
01:50:05 <dons> was the impression i was getting
01:50:07 <joelr1> dons: true, true. i did this in ocaml before tackling the same in haskell. took me about a month, including learning ocaml. i had trouble deploying on the web, though.
01:51:03 <joelr1> dons: ah, yes, of course. haskell is not like riding a bicycle: you need to re-learn it after an extended absense
01:51:09 <joelr1> almost re-learn it :)
01:51:43 <gour> hmm, now i understand why some are riding unicycle
01:51:56 <dcoutts> hah
01:51:58 <joelr1> dons: with haskell i saw a straighforward path from writing to deployment on the web (with happs)
01:52:20 <dcoutts> gour: it's just the most practical form of transport for a small city!
01:52:24 <joelr1> can you ride a unicycle downhill?
01:52:27 <dcoutts> sure
01:52:31 <joelr1> hmm
01:52:32 <dcoutts> can't freewheel though
01:52:33 <dons> ah right. yes, i know of very little in the way of web frameworks for ocaml
01:52:44 <gour> dcoutts: it must be something deeper which you're clevderly hiding
01:52:57 <joelr1> dons: there's a framework or two but there's not much of a community behind them
01:53:05 <dcoutts> gour: it's fun :-)
01:53:08 <dons> dcoutts: its not possible at all to freewheel on a unicycle?
01:53:12 <dcoutts> nope
01:53:18 <dcoutts> you'd not be able to balance
01:53:29 <joelr1> dons: this is my biggest attraction with haskell: i can resolve my issues quickly by asking for help. then i can make a note about what i just learned and move forward
01:53:43 <gour> dcoutts: it means your always have to work ;)
01:54:02 <joelr1> unless i misunderstand what freewheeling is, riding a unicycle is freewheeling already
01:54:21 <joelr1> freewheeling = doing tricks on a bici, right?
01:54:24 <dons> yes, i suppose with a modified cluch that would be possible
01:54:24 <dcoutts> joelr1: not having to peddle, eg when going down hill
01:54:37 <joelr1> dons: ah, that's different
01:54:44 <gour> great, i got it right
01:54:45 <dons> yeah
01:54:46 <joelr1> dcoutts: err, that was for you
01:55:14 <dcoutts> dons: balancing like that would be almost completely a different skill to riding normally, since it would not be in your feet but by careful application of a break/clutch
01:55:28 <joelr1> dons: so with ocaml you may have a handful of people behind a framework and need to spend the time digging in. i felt that i would rather dig back into haskell.
01:55:36 <dcoutts> gour: I live in a mostly flat place so it saves little to be able to freewheel down hills
01:55:50 <dons> dcoutts: there's no hand break i imagine, just raw feet on the wheels control?
01:56:04 <dcoutts> feet on peddles, right.
01:56:19 <dcoutts> joelr1: I don't do tricks, I get places.
01:56:28 <dons> and the peddles are fixed to the wheel? there's no intermediate clutch mechanism?
01:56:49 <dcoutts> exactly
01:56:54 <dcoutts> it's very very simple
01:56:57 <dons> yes.
01:57:04 <dcoutts> there's a frame and a wheel, just one moving part
01:57:05 <gour> dcoutts: still i do not see unciycles here. maybe you should come to propagate a bit. i'm even not aware where one would buy one
01:57:21 <dcoutts> gour: unicycle.com of course :-)
01:57:32 <joelr1> dcoutts: interesting... i don't think i would get very far on a unicycle in tenerife, though, it's mostly roads and highways :-)
01:57:40 <gour> dcoutts: by ordering from outside it would cost a fortune
01:57:46 <dons> dcoutts: are there modified unicycles with clutches?
01:57:57 <dons> i can't imagine they've not been investigated
01:58:05 <dcoutts> dons: possibly, I've never heard of any, nor with gears
01:58:10 <dons> by intrepid unicyclers trying to conquer new territory
01:58:27 <dons> interesting.
01:58:44 <araujo> hello
01:58:44 <dcoutts> dons: they all go mountain unicycling
01:58:49 <dcoutts> hia araujo
01:59:00 <dons> dcoutts: up, then walk back down? :-)
01:59:04 <araujo> dcoutts, hi hi!
01:59:23 <dons> i suppose mountain unicycling is a good fit, since its slower/more technical?
01:59:30 <dcoutts> dons: hah, no. Cycling both ways, crazy buggers.
01:59:44 <dons> though i'd imagine balance say, jumping over rocks, is tricky
01:59:46 <dcoutts> you can go places you can't with two wheels
01:59:51 <dons> yeah
01:59:53 <dcoutts> due to it being smaller
02:00:07 <dcoutts> ask shapr about it
02:00:33 * dons `ap` dinner
02:01:13 * dcoutts >>= \hack -> hack c2hs
02:01:15 <joelr1> ?src ap
02:01:16 <lambdabot> ap = liftM2 id
02:01:24 <joelr1> wow
02:01:27 <dcoutts> that's not a very helpful definition
02:01:55 <joelr1> dcoutts: btw, i find your c2hs post very helpful, although i won't have much use for c2hs immediately.
02:01:56 <dcoutts> better is: ap f x = do f' <- f; x' <- x; reutrn (f' x')
02:02:19 <dcoutts> @type Control.Monad.ap
02:02:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
02:02:34 <dcoutts> @hoogle applicative
02:02:34 <lambdabot> No matches found
02:02:36 <dcoutts> bah
02:03:05 <joelr1> dcoutts: there's a guy i know who (potentially) discovered a very nice business: taking C code written by traders and restructuring that to run on fpgas. he wrote his end in lisp, though
02:03:23 <dcoutts> @type (Control.Applicative.<*>)
02:03:26 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
02:03:54 <dcoutts> joelr1: aye, compiling to hardware for fun and profit
02:04:23 <joelr1> dcoutts: yes, huge speedups from what i remember. requires a good c parser, ast, etc. though
02:04:23 <dcoutts> there was a spin-off from my lab a few years ago which does that
02:05:32 <dcoutts> joelr1: well I've only done the first little bit of that, and I'm not really interested in working in that direction, which is why I posted trying to get someone else to work on that stuff
02:06:23 <joelr1> dcoutts: you mean the parsing and the ast, right?
02:06:29 <dcoutts> right
02:06:35 <dcoutts> and the ast is only so-so
02:06:35 <joelr1> dcoutts: btw, i think there's a simple way to resolve the dangling else
02:06:44 <dcoutts> joelr1: it doesn't matter
02:06:47 <dcoutts> that was my point
02:06:49 <joelr1> dcoutts: ok
02:06:58 <dcoutts> it's clearer to leave it as is
02:07:11 <joelr1> dcoutts: right
02:07:13 <dcoutts> the s/r conflict gets resolved in the right way automatically
02:07:16 <hpaste>  fantasma annotated "build errors (help!)" with "please help me" at http://hpaste.org/1491#a2
02:07:33 <joelr1> dcoutts: so count me in to work on that... a while later
02:07:40 <dcoutts> joelr1: ok, great
02:09:02 <fantasmaa> what does greencard do and would it help me with this -> http://hpaste.org/1491
02:10:47 <dmhouse> Greencard's pretty ancient, I don't think anyone uses it any more.
02:11:17 <dmhouse> I think its features were subsumed by GHC.
02:13:14 <fantasmaa> @seen
02:13:50 <fantasmaa>         (Unfortunately X11-1.2 does not work correctly on AMD64.  The latest
02:13:50 <fantasmaa>          darcs version from http://darcs.haskell.org/packages/X11 does.)
02:13:53 <lambdabot> Title: Index of /packages/X11
02:14:13 <fantasmaa> ^^^does that apply to AMD64's processors on the i386 arch?
02:18:50 <dcoutts> fantasmaa: looks like you don't have the C libX11 library, which is pretty odd
02:19:00 <dcoutts> or it doesn't live on the standard search path
02:19:05 <dcoutts> which is a bit more likely
02:19:28 <dcoutts> eg does compiling a hello world C prog using gcc hello.c -lX11 work?
02:19:48 <fantasmaa> I have these in /usr/X11R6/lib -> [libX11.a, libX11.so, libX11.so.6]
02:20:21 <dcoutts> so perhaps /usr/X11R6/lib isn't in the standard liker path
02:20:24 <dcoutts> linker
02:20:46 <dcoutts> try the failing command again with the extra flag -L/usr/X11R6/lib
02:21:08 <fantasmaa> should I make clean before?
02:21:21 <dcoutts> no, just run exactly the failing command with that flag
02:21:28 <dcoutts> not the whole build
02:21:54 <fantasmaa>  runhaskell Setup.hs build -L/usr/X11R6/lib
02:21:54 <fantasmaa> Setup.hs: Unrecognised flags: -L,-/,-u,-s,-r,-/,-X,-1,-1,-R,-6,-/,-l,-i,-b
02:22:06 <dcoutts> fantasmaa: no, just the failing command
02:22:09 <dcoutts> /usr/local/bin/ghc-6.6 -lX11 Graphics/X11/Types_hsc_make.o -o Graphics/X11/Types_hsc_make
02:22:13 <fantasmaa> ohhhhh
02:22:16 <fantasmaa> sorry
02:22:31 <dcoutts> this is just an experiment to see if that's the problem
02:22:48 <fantasmaa> it ran
02:22:53 <dcoutts> ok
02:23:17 <dcoutts> so ideally you should set up your system so that directory is in the standard linker search path
02:23:31 <dcoutts> so it doesn't have to be specified in every command
02:23:56 <fantasmaa> is that an environmental  variable?
02:24:11 <int-e> LDFLAGS should work (LDFLAGS=-L...)
02:24:13 <dcoutts> there's an env var too
02:24:39 <dcoutts> but I think there's a way to just to it globally, like it's done on most linux systems
02:24:57 <fantasmaa> I tried exporting LDFLAGS before but it failed then too
02:25:27 <fantasmaa> echo $LDFLAGS
02:25:27 <fantasmaa>   -L/usr/X11R6/lib -L/usr/local/lib
02:27:00 <igli> on gentoo: /etc/ld.so.conf autogenerated by env-update
02:27:51 <dcoutts> which comes from LDPATH in various /etc/env.d/ files
02:28:04 <dcoutts> fantasmaa: what distro are you using?
02:28:11 <fantasmaa> dcoutts: freebsd
02:28:51 <dcoutts> fantasmaa: hmm, I'd ask over there what the standard thing is, or if every single prog is just supposed to magically know what linker paths to use
02:29:02 <dcoutts> there must be a standard solution
02:29:20 <dcoutts> or this would be a problem for every single X11 program
02:30:50 <igli> no LDFLAGS is standard i believe, but normally set by configure
02:31:10 <dcoutts> fantasmaa: you can just hack it by modifying the X11.cabal file and adding the path to the library-dirs
02:44:42 <hpaste>  tuxplorer pasted "return a implies success, fail_ implies failure, what does the intermediate two statements imply?" at http://hpaste.org/1496
02:44:48 <joelr1> :t (++)
02:44:51 <lambdabot> forall a. [a] -> [a] -> [a]
02:45:47 <joelr1> > let f = flip (++) in [1, 2] `f` [3, 4]
02:45:48 <lambdabot>  [3,4,1,2]
02:48:23 <dmhouse> tuxplorer: it's a bit more complicated than that.
02:48:47 <dmhouse> (>>=), pronounced 'bind', is used to chain computations.
02:49:19 <tuxplorer> dmhouse: even after reading a lot on >>=, I have a lot of confusions with it.. please help me understand it..
02:49:33 <dmhouse> If you look at the type signature, (>>=) :: m a -> (a -> m b) -> m b, you can see that what (>>=) essentially does is rip the value out of its monadic container, pass it to the second argument, and returns whatever the function returns.
02:49:52 <dmhouse> tuxplorer: it seems as if you don't really understand monads. To that end, here are some article recommendations:
02:50:56 <dmhouse> I read, in this order: http://www.haskell.org/haskellwiki/Monads_as_Containers then http://en.wikibooks.org/wiki/Haskell/Understanding_monads then http://www.haskell.org/all_about_monads/html/
02:50:57 <dcoutts> don't use the scary monad word! :-)
02:50:59 <lambdabot> Title: Monads as containers - HaskellWiki
02:51:03 <tuxplorer> am I abstracting between what m a results in and what the function (a->m b) does?
02:51:14 <tuxplorer> using >>=
02:51:15 <tuxplorer> ?
02:51:53 <dcoutts> I'm not sure 'abstracting' is the word, but yeah
02:51:55 <dmhouse> What do you mean by 'abstracting' in this instance?
02:52:11 <dcoutts> you're combining two computations one after the other
02:52:23 <dcoutts> and the second is allowed to use the result of the first
02:52:35 <dcoutts> that's all >>= does
02:52:57 <dcoutts> it's a lot like ';' in an imperative language
02:53:04 <dcoutts> command1; command2
02:53:10 <dmhouse> It might be easier to think about (>>) first. (>>) :: m a -> m b -> m a chains two computations in the sense that it does the first, then the second, then returns the results of the second.
02:53:15 <dcoutts> command1 >>= \x -> command2 x
02:53:38 <tuxplorer> by abstracting, I mean to say if we are throwing off all worries about the intermediate results and what happens to it, only caring about what  the output of the function is alone..
02:53:39 <dcoutts> right, >> is the simple case where the second command does not use the result of the first
02:53:42 <dmhouse> (>>=) :: m a -> (a -> m b) -> m b runs the first, feeds the value produced into the second, then returns the results of the second.
02:54:03 <tuxplorer> dmhouse: yes, I get that now.. that is what I meant by abstracting..
02:54:45 <dcoutts> do { x <- cmd1; cmd2 x }  =  cmd1 >>= \x -> cmd2 x
02:55:15 <dcoutts> so as dons puts it, >>= is a programmable ';' operator
02:55:45 <tuxplorer> dcoutts: yup.. now I get it.. so, I define the whole operation { x <- cmd1; cmd2 x } is termed cmd1 defined by the lambda calculus \x -> cmd2 x ..
02:55:55 <tuxplorer> Is that what monad is?
02:55:59 <dcoutts> yup
02:56:13 <dmhouse> A monad is a definition for (>>=) and a definition for return.
02:56:47 <dcoutts> tuxplorer: and because so many different ideas in programming use this notion of sequential composition there are lots of things which turn out to be monads
02:57:00 <tuxplorer> Thanks dcoutts dmhouse, I would read the book again now.. I found it cryptic till now, and reading it any number of times didn't help..
02:57:04 <dmhouse> Those two definitions are normally designed with a specific semantics in mind, e.g. the Maybe monad is for computations that might fail, (>>=) allows you to chain possibly-failing combinations with the semantics that if any one of the subcomputations fails, the entire computation fails.
02:57:09 <dcoutts> tuxplorer: so it's not just IO and imperative things
02:57:11 <tuxplorer> guess, now it shd be easier :) thanks a lot
02:57:59 <tuxplorer> ah! ok.. so, its like designing transactions in a DBMS envt.. in case of the Maybe class..
02:57:59 <dcoutts> np, have fun
02:58:14 <tuxplorer> either the whole thing happens or the whole thing fails
02:58:26 <dmhouse> Yeah.
02:58:29 <dcoutts> right, you can program your own exception handling system
02:59:38 <tuxplorer> After understanding the meaning of >>= I got another doubt.. when does the first statement return a come into picture?
02:59:54 <tuxplorer> ie., return a = Just a
03:00:10 <dcoutts> return is the thing that brings pure values into the monad
03:00:22 <dmhouse> Remember that a monad is a definition for both return and (>>=).
03:00:59 <dmhouse> So the semantics of the monad need to cover return as well.
03:01:18 <dcoutts> tuxplorer: eg if we're thinking about a monad for actions, then return a is the action that does nothing but gives 'a' when you perform it
03:01:20 <dmhouse> In the case of Maybe, 'return x' is a computation that trivially succeeds and has a result of x.
03:01:22 <tuxplorer> ie., we define the chaining separately and the value for the monadic function separately.. wouldn't just the success case of the chaining function return the value for the monadiv function?
03:03:54 <dmhouse> tuxplorer: the 'success case' for the chaining function depends on the function you pass it.
03:04:23 <tuxplorer> return is the default value independent of the function being passed?
03:05:29 <dmhouse> tuxplorer: no, 'return x' is normally a computation that succeeds, and has a value of x.
03:05:48 <dmhouse> Keep in mind that specific monads are allowed to attribute their own semantics to return/(>>=).
03:06:21 <dmhouse> Perhaps another example will help. The list monad is a little weird at first, but it basically is for computations that have more than one possible return value, like parsing ambiguous grammars.
03:07:06 <dmhouse> 'return x' in the list monad is a computation that succeeds, and has a single return value, which is x.
03:07:27 <dcoutts> so >>= is the thing we use to combine actions, but how do we get an action in the first place? well each type of monad has some primitive actions and in particular, every monad must provide a primitive for making actions out of an ordinary pure value, that primitive is called 'return'
03:07:41 <dcoutts> another primitive they all have is 'fail'
03:08:01 <bwerf> great, icfp is comming again
03:08:03 <joelr1> :t id
03:08:06 <lambdabot> forall a. a -> a
03:08:07 <tuxplorer> ya. I understand it now.. Thanks a lot everyone.. :) This is gr8 help.. making me understand something that I had been viewing as cryptic...
03:08:09 <dmhouse> With 'm >>= f' in the list monad, m is a list of values, and f is a function from a value to another list of values. We run f on every value in m, producing a list of lists of results of f, then collapse that down into a single list.
03:08:23 <dmhouse> I.e. m >>= f = concat (map f m) in the list monad.
03:08:28 <dcoutts> tuxplorer: as another example a primitive of the IO monad is getChar
03:08:33 <bwerf> seeing the who organizes the contest this year i guess alot of generic programming is on the horizon
03:08:55 <dcoutts> tuxplorer: so each monad has it's own set of primitives, but they all must have at least the simple 'return' primitive
03:09:12 <tuxplorer> Thanks :)
03:26:43 <cm-> hi
03:27:05 <cm-> http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Arrays#Mutable_arrays_in_ST_monad_.28module_Data.Array.ST.29
03:27:08 <lambdabot> http://tinyurl.com/2288uq
03:27:40 <cm-> i'm trying this example and get "Couldn't match expected type "forall s. ST s .." vs. "ST s .."
03:28:05 <cm-> do i need to add some magic compiler flags?
03:28:39 <dmhouse> cm-: which version of GHC/Hugs?
03:28:43 <dmhouse> It works fine for me on GHC 6.6.
03:28:49 <cm-> 6.6
03:28:56 <Heffalump> do you have -fglasgow-exts ?
03:29:06 <dmhouse> Heffalump: not even needed, I don't think.
03:29:10 <Heffalump> no, neither do I
03:29:14 <dmhouse> At least, I didn't include it anywhere and it loaded fine.
03:29:18 <Heffalump> but I was just checking since there seems to be a problem
03:29:28 <dmhouse> cm-: could you paste the whole error? hpase.org
03:29:32 <dmhouse> *hpaste.org
03:29:36 <cm-> hmm, okay
03:29:41 <int-e> does 6.6 solve the  runST $ do  ...   problem? or is that just 6.7?
03:29:46 <ToRA> works under ghci 6.6 quite happily
03:29:46 <Heffalump> 6.7
03:29:51 <dmhouse> int-e: it's been solved?!
03:29:55 <Heffalump> and they're planning on taking that out again, AFAIK
03:30:02 <Heffalump> after many people pointed out what a grotesque hack it is
03:30:04 <int-e> dmhouse: sorta. it works occasionally.
03:30:19 <dmhouse> IMO you just need better error handling for that case.
03:31:59 <cm-> weird, why would it work now.. never mind, then.
03:32:16 <cm-> regarding runST $ do .. -- that would have been my second question; how to make that one work? ;-)
03:32:27 <dmhouse> Use parentheses instead.
03:33:00 <int-e> I tend to write   runST doStuff where doStuff = do ...
03:33:02 <cm-> why is there a difference?
03:33:28 <Heffalump> because typechecking runST $ ... involves using the type of ($)
03:33:36 <Heffalump> and it doesn't have the right type to have runST on the LHS
03:33:50 <int-e> @type runST
03:33:52 <lambdabot> forall a. (forall s. ST s a) -> a
03:34:02 <dmhouse> cm-: because ($) is a function, and type-2 polymorphic functions aren't first class in Haskell.
03:34:11 <dmhouse> Err, not type 2, what's the proper term...
03:34:14 <int-e> rank 2
03:35:11 <cm-> ah.. that's why   map (runST . foo) bar   didn't work either?
03:35:18 <int-e> cm-: same thing, yes
03:35:31 <int-e> cm-: map (\x -> runST (foo x)) will work.
03:36:13 <bwerf> i want to try my hand at generic programming but don't really want to dive into functional programming, language suggestions ?
03:36:34 <cm-> :/
03:38:23 <int-e> cm-: this is all a little weird. even eta reduction isn't always safe (writing  f = g  instead of  f x = g x)
03:39:29 <int-e> (and that happened with an explicit type signature for f so the monomorphism restriction was not to blame)
03:41:43 <cm-> hmm :(
03:43:22 <Heffalump> but the current proposed fix is just an ugly hack that would make some cases work but not others
05:40:43 <ivanm> If I have a list of lists, how con I do a cross product such that I have every possible combination?
05:41:07 <ivanm> i.e. cross [[1,2],[3,4]] = [[1,3],[1,4],[2,3],[2,4]] ?
05:41:26 <TSC> The list monad seems promising
05:41:35 <gour> no need for fp (http://www.cs.utexas.edu/~arvindn/hughes/)
05:42:09 <SamB_XP_> > mapM return [[1,2],[3,4]]
05:42:14 <gour> unfortunately, no place for comments :-(
05:42:37 <TSC> Ah, sequence is the one
05:42:42 <SamB_XP_> maybe "mapM (>>= return)" ?
05:42:48 <gour> hmm , lambda fails to parse it - http://www.cs.utexas.edu/~arvindn/hughes/
05:43:13 <SamB_XP_> gour: lambdabot seems to be either missing or broken ;-)
05:43:26 <SamB_XP_> as evidenced by the lack of output for my query
05:43:33 <gour> SamB: it's on the list, but...
05:43:42 <SamB_XP_> so, broken!
05:43:49 <gour> yep
05:43:53 <TSC> sequence [[1,2],[3,4]]  =>  [[1,3],[1,4],[2,3],[2,4]]
05:44:00 <TSC> ivanm: cross = sequence
05:44:11 <ivanm> thanks TSC++
05:44:19 <SamB_XP_> TSC: aww. thats shorter than mine!
05:44:56 <ivanm> @hoogle sequence
05:44:57 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
05:44:57 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
05:44:57 <lambdabot> Language.Haskell.TH.Syntax.sequenceQ :: [Q a] -> Q [a]
05:45:10 <ivanm> what does sequence_ do?
05:45:19 <ivanm> > sequence_ [[1,2],[3,4]]
05:45:20 <TSC> Discards the return values
05:45:21 <lambdabot>  [(),(),(),()]
05:45:23 <ivanm> ahhh
05:45:27 <SamB_XP_> > mapM (>>= return) [[1,2],[3,4]]
05:45:57 <SamB_XP_> @bo
05:45:58 <lambdabot> :)
05:46:52 <SamB_XP_> @ty (>>= return)
05:46:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
05:47:46 <SamB_XP_> oh
05:54:01 <Saizan> > Prelude.mapM (>>= return) [[1,2],[3,4]]
05:54:02 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
05:54:23 <ivanm> I think sequence is nice
05:54:37 <ivanm> > sequence [[1,2],[3,4]]
05:55:27 <ivanm> why didn't LB work?
05:55:32 <ivanm> > Prelude.sequence [[1,2],[3,4]]
05:55:34 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
05:55:40 <ivanm> that's better
05:55:40 <Saizan> conflicting imports
05:55:43 <ivanm> ahhh
05:55:48 <Saizan> ?index sequence
05:55:49 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
05:56:10 <Saizan> with Data.Traversable iirc
05:57:56 <ivanm> *nod*
06:01:24 <matthew-_> when cabal is building executables, why does it not share cached compilations?
06:03:25 <ToRA> @paste
06:03:25 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:03:58 <Spark> ToRA: when is susan back?
06:04:18 <Spark> ToRA: i was using this input layer called OIS, but quickly got pissed off by its extreme and unforgivable shitness
06:05:09 <Spark> so i just looked at sdl, which seems to grab both the keyboard and mouse at the same time, it's obviously inconceivable that someone would want to alt tab from a game
06:05:45 <matthew-_> I have a cabal file that builds 6 executables. For every one, it rebuilds about a dozen modules which are common to every executable. With -O2 this takes some time. Why does this happen?
06:08:09 <bringert> matthew-_: I think the reason is that they could have different compiler options
06:08:36 <matthew-_> bringert: ahh, true.
06:08:45 <bringert> matthew-_: but if they don't, cabal should re-use the compiled modules. my guess is that noone has implemented that yet
06:08:53 <matthew-_> yup.
06:09:06 <Igloo> I don't see why it should rebuild them multiple times. It needs to rebuild them once because they have package name main in the executable rather than foo in the library
06:09:30 <bringert> Igloo: what if they have diffent -D options for example?
06:09:59 <Igloo> bringert: But ghc --make doesn't rebuild things unless it thinks it needs to, and cabal is just calling that
06:10:06 <matthew-_> the way round would be to have 2 different cabal files, one for the libraries which would just build that package, and then one for the executable.
06:10:20 <qebab> Quick question, how would this be done in haskell: http://hpaste.org/1499 ?
06:10:42 <matthew-_> Igloo: yeah, but it seems currently cabal calls ghc --make with different scratch directories for each executable.
06:11:22 <Igloo> Ah, OK. Is there a good reason for that?
06:11:46 <Igloo> But yeah, you're right, the simplest way is to split the library and executables into different cabal packages
06:12:23 <SamB> maybe they potentially have different source paths?
06:12:50 <Igloo> hmm, true
06:13:10 <bringert> Igloo: btw, it's easy to crash ghc by running ghc --make -Dfoo, change one of the modules and then run ghc --make -Dbar
06:13:31 <SamB> but I think that if you have executables and a library in the same package, the library modules should not be re-built for the executables -- instead, the executables should just be linked against the library package ;-)
06:14:31 <Saizan> qebab: looking for a literal translation?
06:14:33 <SamB> (er, also built, I suppose)
06:14:36 <Igloo> bringert: *nod*, GHC does have some of the compilation options in the .hi file, but I don't think any great attempt has been made to make it exhaustive
06:14:45 <matthew-_> also, you know in java you have jar files and tools like izpack which make a jar which allows you to shove an installer front end on your tool/application/package? Well is there anything in haskell like that?
06:15:30 <SamB> matthew-_: ... we have these "ZIP" files
06:15:36 <SamB> they are very similar to JAR files
06:15:39 <qebab> no, Saizan I just want to see more of the syntax for a typical thing I would use haskell for
06:15:45 <matthew-_> SamB: mmm, they're a bit primitive though...
06:15:50 <SamB> hehe ;-)
06:16:27 <matthew-_> I'm currently considering using TH to be able to read in binaries when compiling "the installer" so that the installer, when run can then spit them out in the necessary places. But this really should be a full library or something...
06:16:29 <SamB> outline the desired installation process from the user's perspective?
06:16:29 <qebab> the list comprehensions in python came from haskell, which is probably one of the main reasons I ended up here ;)
06:17:32 <matthew-_> SamB: standard click-through license, choose installation location, run various stuff to make the installation work, add uninstall files, clean up type installer stuff.
06:18:17 <SamB> data Expr = Lambda Var Expr | App Expr Expr | Var Var deriving (E
06:18:18 <SamB> er.
06:18:29 <SamB> s/(E/(Show)/
06:18:35 <bringert> is hackage.haskell.org down?
06:19:08 <nominolo> > let f x | num = toInteger . reverse . show in f 12
06:19:09 <lambdabot>   Not in scope: `num'
06:19:16 <nominolo> > let f x = toInteger . reverse . show in f 12
06:19:17 <lambdabot>   add an instance declaration for (Integral [Char])
06:19:40 <nominolo> > let f x = x + (read . reverse . show) x in f 12
06:19:42 <lambdabot>  33
06:19:44 <SamB> newtype Var = V String deriving (Eq, Ord, Show)
06:19:48 <matthew-_> bringert: works for me
06:19:59 <SamB> or maybe just "type Var = String"
06:20:35 * SamB wonders how to represent values
06:21:26 <SamB> qebab: a common thing you would use Haskell for is writing an interpreter for a programming language ;-)
06:21:44 <qebab> SamB: I'm not planning to do that anytime soon ;)
06:21:53 <qebab> maybe in 3-4 years if all goes well
06:22:09 <SamB> qebab: you drastically overestimate the difficulty of this task
06:22:12 <hpaste>  Saizan annotated "Lychrel numbers" with "not tested" at http://hpaste.org/1499#a1
06:22:35 <SamB> you could do it for a really simple programming language, you know ;-)
06:22:48 <qebab> thank you, Saizan
06:22:56 <qebab> yeah, but that would take away a bit of the fun
06:23:15 <nominolo> > let palin x = x == reverse x; revadd x = x + (read . reverse . show) x in [ r | n <- [0 .. 10**4-1], r <- [revadd n], palin (show n) ]
06:23:17 <lambdabot>  [0.0]
06:23:21 <SamB> okay, a fairly simple language then
06:23:23 <qebab> fun lies in a challenge that is hard, but you are able to overcome imo :)
06:23:33 <nominolo> :t (**)
06:23:35 <lambdabot> forall a. (Floating a) => a -> a -> a
06:23:41 <nominolo> :t (^)
06:23:43 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
06:23:50 <nominolo> > let palin x = x == reverse x; revadd x = x + (read . reverse . show) x in [ r | n <- [0 .. 10^4-1], r <- [revadd n], palin (show n) ]
06:23:51 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,22,44,66,88,110,132,154,176,198,202,222,242,262,28...
06:24:14 <nominolo> qebab: ^^
06:24:39 <bringert> matthew-_: I've uploaded the latest parsedate to hackage
06:24:41 <qebab> that has palindromes in it :o
06:24:55 <qebab> ah
06:24:55 <SamB> actually I've got an in-progress interpreter for a not-quite-functional language (it is reminiscent of functional languages, but lacks higher order functions and types)
06:24:56 <qebab> nevermind me
06:25:22 <qebab> that was just one iteration without removing palindromes :) thanks nominolo
06:25:56 <nominolo> > let palin x = x == reverse x; revadd x = x + (read . reverse . show) x in [ n | n <- [0 .. 10^4-1] palin (show n) ]
06:25:57 <lambdabot>   Not in scope: `n'
06:26:04 <nominolo> > let palin x = x == reverse x; revadd x = x + (read . reverse . show) x in [ n | n <- [0 .. 10^4-1], palin (show n) ]
06:26:06 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,11,22,33,44,55,66,77,88,99,101,111,121,131,141,151,161,...
06:26:31 <nominolo> ah, *no* palindromes
06:26:41 <nominolo> sry
06:26:51 <SamB> > let palin x = x == reverse x; revadd x = x + (read . reverse . show) x in [ n | n <- [0 .. 10^4-1], not (palin (show n)) ]
06:26:52 <lambdabot>  [10,12,13,14,15,16,17,18,19,20,21,23,24,25,26,27,28,29,30,31,32,34,35,36,37,...
06:26:55 <matthew-_> bringert: many thanks.
06:27:49 <SamB> @ask dons did you get the patch I tried to send you?
06:27:49 <lambdabot> Consider it noted.
06:28:11 <nominolo> qebab: range(1,10) does NOT include 10, right?
06:28:29 <qebab> yeah,
06:28:42 <qebab> range(1,3) = [1,2]
06:28:50 <nominolo> then range(0,10) is [1..9] in haskell
06:28:56 <qebab> okay
06:29:06 <nominolo> helps reduce some off-by-one errors
06:29:13 <qebab> thanks :)
06:29:20 <SamB> nominolo: not much
06:30:05 <SamB> also, range(0,10) is [0..9]...
06:30:07 <qebab> and range(0,10,3) ([0,3,6,9]) would be?
06:30:24 <SamB> > [0,3..9]
06:30:26 <lambdabot>  [0,3,6,9]
06:30:34 <qebab> okay, that's nice and easy :)
06:30:48 <SamB> > [6,3..9]
06:30:50 <lambdabot>  []
06:30:53 <SamB> hmm.
06:30:56 <SamB> oh oops
06:31:03 <nominolo> > [6,9 ..]
06:31:04 <SamB> > [3,6..9]
06:31:04 <lambdabot>  [6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,81...
06:31:06 <lambdabot>  [3,6,9]
06:31:42 <qebab> infinite lists is a really neat trick
06:31:42 <nominolo> > [10,8..0]
06:31:42 * qebab wishes python had that
06:31:54 <nominolo> qebab: python has yield
06:31:58 <lambdabot>  [10,8,6,4,2,0]
06:31:59 <syntaxfree> infinite lists are a by-product of lazy evaluation.
06:32:04 <qebab> yeah, but it's not quite the same
06:32:21 <syntaxfree> SICP shows how to get lazy evaluation in a strict language.
06:32:56 <Saizan> syntaxfree: you almost have lazy lists in python with iterators
06:33:24 <ivanm> @pl genShapes n w = (sequence . map (genRowShapes n)) =<< (weightGenerator n w)
06:33:25 <lambdabot> genShapes = ap ((.) . (=<<) . (sequence .) . map . genRowShapes) weightGenerator
06:33:40 * ivanm will keep variables
06:33:53 <ivanm> @pl genShapes' w = (sequence . map (genRowShapes')) =<< (weightGenerator' w)
06:33:53 <lambdabot> genShapes' = (sequence . map genRowShapes' =<<) . weightGenerator'
06:33:59 <Saizan> ivanm: mapM?
06:34:17 <ivanm> *shrug* don't know...
06:34:21 <ivanm> @type mapM
06:34:23 <lambdabot>     Ambiguous occurrence `mapM'
06:34:24 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
06:34:27 <Saizan> ?src mapM
06:34:27 <lambdabot> mapM f as = sequence (map f as)
06:34:35 <ivanm> ahhh......
06:34:59 <nominolo> @instances Functor
06:35:01 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
06:35:34 <ivanm> @hoogle mapM
06:35:35 <lambdabot> Prelude.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
06:35:35 <lambdabot> Maybe.mapMaybe :: (a -> Maybe b) -> [a] -> [b]
06:35:35 <lambdabot> Prelude.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
06:35:41 <ivanm> @type Prelude.mapM
06:35:44 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
06:36:08 <ivanm> Saizan: it doesn't seem to like it :(
06:36:20 <ivanm> sequence . map f = mapM f?
06:36:30 <Saizan> yeah
06:36:38 <Saizan> ?type sequence . map
06:36:41 <lambdabot>     Ambiguous occurrence `sequence'
06:36:41 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
06:36:46 <Saizan> ?type Prelude.sequence . map
06:36:49 <lambdabot>     Couldn't match expected type `[m a]'
06:36:49 <lambdabot>            against inferred type `[a1] -> [b]'
06:36:51 <ivanm> oh, wait, the problem is a missing bracket at the end of the line :s
06:37:12 <Saizan> ?type (Prelude.sequence .) . map
06:37:15 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m [a]
06:37:48 <ivanm> @src Prelude.mapM
06:37:49 <lambdabot> Source not found. You type like i drive.
06:37:55 <ivanm> duh, prelude has no src available
06:38:31 <Saizan> @src doesn't like module names i think
06:38:31 <lambdabot> Source not found. stty: unknown mode: doofus
06:39:11 <nominolo> @source Prelude.mapM
06:39:11 <lambdabot> Prelude.mapM not available
06:39:15 <SamB> @source Prelude
06:39:16 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
06:39:25 <SamB> @src mapM
06:39:25 <lambdabot> mapM f as = sequence (map f as)
06:39:32 <qebab> error messages should be creative like that
06:39:44 <Saizan> @pools
06:39:45 <lambdabot>  not available
06:39:46 <qebab> I spent entire yesterday writing a bunch for my irc bot :)
06:40:06 <ivanm> SamB: Prelude.hs doesn't have much...
06:40:13 <qebab> the best ones were from the film 300
06:40:14 <ivanm> I think you have to get the actual ghc source for the Prelude...
06:40:47 <Saizan> @source Control.Monad
06:40:47 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
06:40:57 <SamB> qebab: I find it kind of annoying with such iffy commands as @src (which uses a rather spotty hand-built database, so there is no way to know for sure what is and is not in it)
06:41:15 <qebab> I can understand that
06:41:30 <ivanm> Saizan: even better... mapM is inlined! :D
06:43:18 * Saizan wonders how inline works with partial application
06:52:08 <SamB> Saizan: hmm?
06:53:32 <Saizan> genShapes' = (mapM foo =<<) . weightGenerator' <-- to inline mapM here for example
06:54:07 <Saizan> given mapM f as = sequence (map f as)
06:56:17 <ivanm> @hoogle Bool -> Int
06:56:18 <lambdabot> No matches, try a more general search
06:56:22 <ivanm> @hoogle Bool -> a
06:56:23 <lambdabot> Control.Exception.assert :: Bool -> a -> a
06:56:23 <lambdabot> Foreign.Marshal.Utils.fromBool :: Num a => Bool -> a
06:56:23 <lambdabot> Monad.guard :: MonadPlus a => Bool -> a ()
06:56:58 <ivanm> I want to turn all "True" to 1, and all "False" to 0... any way of doing it without an if?
06:57:14 <Saizan> ?type fromEnum
06:57:17 <lambdabot> forall a. (Enum a) => a -> Int
06:57:32 <Saizan> > map fromEnum [False ..]
06:57:32 <ivanm> > fromEnum True
06:57:34 <lambdabot>  [0,1]
06:57:34 <lambdabot>  1
06:57:41 <ivanm> ahhh.... thanks!
06:58:06 <Heffalump> what do you have against if? :-)
06:58:14 <Heffalump> though fromEnum is neat
07:01:30 <ivanm> Heffalump: if is uglier to use for pointfree functions if you want to map something
07:01:34 <ivanm> and fromEnum is shorter ;-)
07:09:02 <Saizan> let if' a b c = if a then b else c :)
07:09:39 <ivanm> that's the haskell equivalent of C's trigraph form?
07:10:33 <Saizan> mmh no, if .. then .. else is the equivalent of the trigraph :)
07:10:44 <Saizan> it's yet an expression
07:11:00 <ivanm> I meant in terms of being a shortened version of traditional if then else
07:11:11 * ivanm never remembers the trigraph syntax
07:11:16 <rahikkala> Uhm, I thought trigraphs were those three-character replacements for the funkier punctuation that not all terminals speak
07:11:17 <ivanm> is it a ? b : c ?
07:11:23 <Saizan> yep
07:11:25 <ivanm> rahikkala: probably have the name wrong
07:11:35 <rahikkala> While the ? : operator is called the ternary operator, because, well, it's the only ternary operator in C
07:11:41 <ivanm> Saizan: thought so, couldn't rembmer if it started with something
07:11:48 <ivanm> rahikkala: yeah, that's the one
07:12:00 <ivanm> not only do I forget the syntax, I forget the name as well :s
07:12:05 <Saizan> :D
07:12:09 * ivanm hasn't done much C... uses ternary in Java
07:12:27 <matthew-_>     No instance for (Language.Haskell.TH.Syntax.Lift B.ByteString)
07:12:27 <matthew-_>       arising from use of `lift' at System/Installer/TH.hs:14:18-30
07:12:40 <matthew-_> bummer. So in TH, I can't use bytestring?
07:12:47 <ivanm> so if then else in haskell is like the ternary operator in C since haskells if then else is a function with partial infix syntax?
07:13:35 <bringert> ivanm: yes
07:13:55 <bringert> well, I'd call it an operator rather than a function
07:14:00 <Saizan> more a keyword than a function
07:14:30 <Saizan> but it has a value, where C if then else is just control flow, a statement
07:14:37 <ivanm> *nod*
07:14:48 <Philippa> it's a statement, and it corresponds to an expression but not to a function
07:15:04 <Philippa> which means you can't do something like function composition to give it the condition
07:15:10 <sorear> .
07:15:41 <ivanm> *nod*
07:15:44 <ivanm> "Typically this is due to the person writing the guidelines never having bothered to learn the ternary operator and since they don't know it they don't want anybody else to use it"
07:15:46 <ivanm> heh
07:15:53 <ivanm> that's from wikipedias page on ?:
07:16:12 <Philippa> I realised I wasn't like other C coders any more when I found myself wanting to use ?: regularly
07:16:21 <ivanm> *nod*
07:16:29 <Saizan> i thougt statement and expression where antonym
07:16:35 <Saizan> s
07:16:41 <Philippa> a friend managed to avoid his company ruling it out in coding guidelines by demonstrating that there was much worse code passing them than anything he'd write
07:16:51 <Vq^> Philippa: other C coders don't?
07:16:55 <ivanm> so, in imperative languages ?: is the only way to conditionally return something, but in haskell if... does it
07:17:08 <Philippa> Saizan: not in haskell - a do statement is a valid expression
07:17:11 <ivanm> Plareplane: lol
07:17:26 <Philippa> Vq^: ordinary ones don't use it often
07:18:16 <Vq^> hmm, i guess i'm no ordinary C coder either then
07:18:22 <drigz> ,
07:18:29 <drigz> damn broken keyboard
07:18:30 <drigz> (sorry)
07:18:51 <ivanm> excuses excuses, drigz ;-)
07:26:17 <drigz> this sounds like such a newb question, but how should i install a haskell module (namely, HUnit) that doesn't give any directions/scripts?
07:26:39 <Saizan> has it a .cabal file?
07:26:44 <drigz> nope
07:26:53 <drigz> just a bunch of .lhs files
07:27:07 <xpika> 'drigz: ./configure && make && make install' ?
07:28:09 <Saizan> ?where HUnit
07:28:09 <lambdabot> http://hunit.sourceforge.net/
07:29:06 <Saizan> http://darcs.haskell.org/packages/HUnit/ <-- this repo is cabalized
07:29:08 <lambdabot> Title: Index of /packages/HUnit
07:29:29 <ivanm> drigz: well, the Gentoo ebuild just installs it using cabal, so I'd assume it came with cabal :s
07:29:49 <ivanm> probably because it uses the link Saizan gave
07:31:21 <matthew-_> grr, writing binary data seems really painful.
07:31:49 <xerox> matthew-_, you using Data.Binary ?
07:32:57 <drigz> ivanm: thanks, i'll find the ebuild and look at that for inspiration
07:32:59 <matthew-_> xerox: nope, not come across that yet...
07:33:12 <ivanm> drigz: no worries
07:33:19 <ivanm> but yeah, it just uses cabal
07:33:50 <matthew-_> xerox: I was looking at using System.IO or Bytestring to read the binary file in. then I need to write it somewhere. And it also needs to become a type for which there is an instance of lift into the Q monad!
07:34:11 <ivanm> drigz: it seems to get the source from haskell.org/ghc/dist/
07:34:27 <xerox> ?type Data.Binary.decodeFile
07:34:30 <lambdabot> forall a. (Data.Binary.Binary a) => FilePath -> IO a
07:34:40 <xerox> ?type Data.Binary.decode
07:34:43 <lambdabot> forall a. (Data.Binary.Binary a) => Data.ByteString.Lazy.ByteString -> a
07:34:57 <drigz> ivanm: yeah, i found the ebuild, it seems to be part of some big extra libraries archive
07:35:07 <xerox> ?type Data.Binary.encode
07:35:10 <lambdabot> forall a. (Data.Binary.Binary a) => a -> Data.ByteString.Lazy.ByteString
07:35:39 <sorear> xerox: Data.Binary is NOT for accessing existing formats, only *Haskell* serialization
07:35:47 <sorear> ?type Data.Binary.Get.runGet -- you want this
07:35:50 <lambdabot> forall a. Data.Binary.Get.Get a -> Data.ByteString.Lazy.ByteString -> a
07:36:01 <sorear> ?type Data.Binary.Put.runPut -- or this
07:36:04 <lambdabot> Data.Binary.Put.Put -> Data.ByteString.Lazy.ByteString
07:36:20 <sorear> well, if you can define the format, Data.Binary is good.
07:36:39 <sorear> @seen glguy
07:36:40 <lambdabot> glguy is in #haskell. I last heard glguy speak 3d 18h 43m 2s ago.
07:37:19 <drigz> sorear: they've been having a conversation in haskell-cafe about how Data.Binary has two purposes, serialisation and access
07:37:53 <sorear> drigz: Data.Binary (the module) has one purpose, serialisation.
07:38:05 <sorear> drigz: 'binary' (the package) has two
07:38:15 * sorear read that thread
07:40:04 <drigz> ah, sorry
07:44:28 <drigz> how can i check if a package has registered properly?
07:44:38 <sorear> ghc-pkg list
07:44:41 <drigz> because the Setup.hs said that it had registers, but ghc still can't find the module
07:48:03 <helmut> Hi. I'd like to use alex (with monad wrapper or better without a wrapper), but I'm lacking a bit haskell skill to understand the documentation. Do you recommend something to read?
07:50:23 <hpaste>  alessandro pasted "C++" at http://hpaste.org/1500
07:51:06 <drigz> sorear: thanks
07:51:23 <drigz> package.conf isn't the most nicely formatted file i've ever seen
07:52:11 <matthew-_> err, the ability to give an explicit type to a var, say in a where clause, requires -fglasgow-exts. Is there a LANGUAGE pragma corresponding to this?
07:52:53 <sorear> not afaik
07:53:03 <sorear> @docs Language.Haskell.Extension
07:53:04 <lambdabot> Language.Haskell.Extension not available
07:53:18 <sorear> @docs Distribution.Extension
07:53:19 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/Cabal/Distribution-Extension.html
07:53:41 <Lemmih> drigz: Most formats that aren't designed for humans aren't.
07:54:54 <nominolo> shouldn't be hard to insert some newlines, though
07:57:58 * sorear plugs O(n) pretty printing combinators
08:06:16 <drigz> so what if it appears in ghc-pkg, but :m + HUnit doesn't work?
08:06:27 <drigz> there is a prefix/lib/HUnit-1.1
08:07:24 <drigz> ok i just worked it out
08:07:31 <drigz> it has changed to Test.HUnit it seems
08:16:24 <matthew-_> which is more likely to stack overflow: foldl or foldr ?
08:17:31 <Heffalump> foldl I think
08:17:52 <matthew-_> yeah, that's what I was thinking.
08:17:55 <shachaf> Heffalump: I'd guess foldr.
08:18:06 <matthew-_> I've got TH exploding with stack overflow
08:18:07 <Saizan> foldr can benefit from lazy eval at least
08:18:34 <matthew-_> it's trying to lift to Q Exp a [Integer] 1624823 elements long
08:18:54 <Heffalump> shachaf: foldl has to recurse to the end of the list before it produces any results
08:19:26 <shachaf> Heffalump: foldl uses tail recursion.
08:19:28 <shachaf> > foldr (+) 0 [1..10000000] `seq` 1
08:19:31 <lambdabot>  Exception: stack overflow
08:19:32 <shachaf> > foldl (+) 0 [1..10000000] `seq` 1
08:19:36 <lambdabot> Terminated
08:19:59 <Saizan> shachaf: but it's not strct enough to really benefit from tail recursion
08:20:24 <Botje> @pl \a b -> a `seq` b `seq` (a+b)
08:20:25 <lambdabot> ap (ap . (seq .) . seq) (+)
08:20:26 <Saizan> you build a really long expression
08:20:35 <Botje> sexy
08:20:46 <Saizan> > foldl' (+) 0 [1..10000000] `seq` 1
08:20:51 <lambdabot> Terminated
08:21:22 <Saizan> > sum [1..1000000]
08:21:24 <lambdabot>  500000500000
08:21:45 <Saizan> > sum [1..10000000]
08:21:49 <lambdabot> Terminated
08:23:04 <sorear> > let go ac cr | ac `seq` cr == 10000000 = ac | otherwise = go (ac+cr) (cr+1) in go 0 1
08:23:08 <lambdabot>  49999995000000
08:23:21 <sorear> > let go ac cr | ac `seq` cr > 10000000 = ac | otherwise = go (ac+cr) (cr+1) in go 0 1
08:23:25 <lambdabot>  50000005000000
08:23:30 * sorear waits for stream fusion
08:23:45 <Saizan> on ghci prompt?:)
08:23:59 <cinimod> @type unfoldr
08:24:01 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
08:24:07 <sorear> Saizan: lambdabot doesn't use ghc
08:24:24 <sorear> Saizan: it uses ghc -O2
08:24:44 <sorear> that should be 'lambdabot doesn't use ghc*i*'
08:25:35 <sorear> > 2 + 2
08:25:35 <sorear> @botsnack
08:25:36 <lambdabot> :)
08:25:37 <lambdabot>  4
08:26:00 <sorear> you notice how much longer eval took - it had to run the  optimizer
08:26:12 <Saizan> :O
08:26:34 <Saizan> that' what runplugs do, right?
08:26:39 <sorear> yeah.
08:27:15 <matthew-_> is there anyway to increase the stack size?
08:27:26 <sorear> +RTS -K10M
08:27:27 <matthew-_> or better yet, find out exactly where the stack overflow is happening?
08:28:19 <matthew-_> thanks
08:47:09 <hpaste>  alessandro pasted "C++ 2" at http://hpaste.org/1501
09:05:40 <matthew-_> mmm. given that the RTS options have to come last, how can you specify them in a .cabal file?
09:06:01 <Heffalump> come last to what?
09:06:11 <sorear> matthew-_: they don't
09:06:18 <Heffalump> if you mean when supplying them on the command-line, are you aware of -RTS?
09:06:18 <sorear> +RTS foo bar -RTS otheropts
09:06:34 <matthew-_> thanks! I should read manuals more...
09:07:17 <Heffalump> manuals are overrated :-)
09:19:35 * shapr sings happily
09:19:39 <shapr> Yay code!
09:19:56 <sorear> yay!
09:20:26 * shapr bounces cheerfully
09:21:09 <shapr> Are you guys working on any nifty code?
09:21:35 <matthew-_> define nifty
09:21:52 <shapr> Either you are having fun writing it, or you think the result will entertain yourself or others.
09:21:57 <Heffalump> yes
09:22:07 <sorear> Does IP blocking for hpaste count?
09:22:13 <shapr> Works for me.
09:22:17 <shapr> Heffalump: Cool! What are you writing?
09:22:22 <sorear> we got three spam pastes in a 5-minute interval, 9h ago
09:22:27 <Heffalump> something to reconcile my personal accounts
09:22:29 <shapr> sorear: Yeah, I saw that in the scrollback.
09:22:35 <ndm> hi
09:22:36 <shapr> Heffalump: Oh that sounds like fun, are you using Haskell?
09:22:39 <Igloo> Why would I write something if neither it nor the result was entertaining?
09:22:40 * shapr hugs ndm
09:22:45 <shapr> Igloo: It pays money?
09:22:45 * Codex_ writes rendering engine.
09:22:45 <Heffalump> yes. Well a mixture of Haskell and perl.
09:22:49 * ndm accepts, and wonders why
09:23:01 <shapr> ndm: Will hugs for filepath code.
09:23:13 <shapr> er, "Will hug for filepath code."
09:23:14 <Heffalump> work is mostly annoying C++ at the moment, and the Haskell in it is mainly string processing
09:23:22 <ndm> Igloo, did you see the filepath bug? the cabal version requirement
09:23:22 <sorear> shapr: I've got even more interesting projects in my activation record stack.
09:23:30 <shapr> sorear: Good!
09:23:32 <Igloo> shapr: I hope money won't ever be the only reason for me writing something, especially on a Saturday  :-)
09:23:37 <ndm> and anyone know how to derive Eq for a GADT?
09:23:49 <Igloo> ndm: Yup, about to push a fix (just commenting out the type sig)
09:23:59 <sorear> shapr: like a rewrite of the lambdabot state engine, with transactions, lazy loading, and incremental checkpointing
09:24:02 <ndm> Igloo, cool :)
09:24:07 <shapr> That would be cool.
09:24:15 <sorear> seems like Happs could use something like that :)
09:24:17 <Heffalump> transactions?
09:24:24 <sorear> Heffalump: atomically
09:24:35 <Heffalump> no, I mean why
09:24:52 <ndm> does deriving just plain old not work on GADT's?
09:24:53 <sorear> because locks suck
09:25:05 <vincenz> Hello
09:25:11 <ndm> and if it doesn't, does instance's work?
09:25:17 <vincenz> ndm: instances do work
09:25:20 <sorear> ndm: in 6.6, type classes just plain old don't work on GADT's, iirc
09:25:28 <Heffalump> surely lambdabot is inherently single-threaded
09:25:31 <ndm> that sucks totally!
09:25:39 <Heffalump> errm, I'm sure type classes work
09:25:42 <vincenz> ndm: I don't know, works rather well for me
09:25:45 <dolio> Yeah, that's one of the listed new features for 6.8, no?
09:25:52 <shapr> sorear: HAppS has all that, I think.
09:25:55 <Heffalump> I thought they just interact badly in some corner cases
09:25:57 <dolio> Better GADT-typeclass interactions.
09:26:12 <sorear> ndm: any thoughts on a derive release date? it seems like, modulo telling people the play derivation is obsolete, it should work nicely now?
09:26:16 <vincenz> ndm: What -does- suck is the bug wiith records and GADTS requiring complete recompilation
09:26:22 <vincenz> ndm: But that's fixed in HEAD
09:26:24 <shapr> sorear: Definitely transactions and incremental checkpointing. I'm not sure how much is lazily loaded.
09:26:27 <sorear> shapr: HAppS has transactions, but all the state needs to be in memory
09:26:38 <shapr> sorear: I think that's a feauter.
09:26:40 <shapr> feature*
09:26:50 <sorear> shapr: how can you have incremental checkpointing when the state is a forall a. a?
09:26:57 <sorear> parametricity!
09:27:30 <ndm> sorear, whenever we feel like it - the Play derivation should be done this weekend
09:27:31 <shapr> By incremental checkpointing, do you mean that part of the state can be saved?
09:27:39 * sorear doesn't understand the happs code, so is talking about what is used in hpaste
09:27:54 <shapr> Somedays I understand the core happs code.
09:27:54 * vincenz stops talking to himself
09:28:00 <sorear> shapr: I mean, only the part of the state that has actually changed is written to disk
09:28:09 <shapr> oh, hm
09:28:42 <shapr> I don't think that would be too hard.
09:28:49 <ndm> vincenz, my experience is that GADT's are annoying, but thats probably just me
09:29:05 <shapr> But at the moment I'm teaching myself how to use STM, so I'd rather finish that instead of diving into MACID.
09:29:11 <vincenz> ndm: they're quite useful at times, but to everyone has their own preference :)
09:29:41 <sorear> shapr: isn't MACID === STM?
09:29:58 <sorear> well, STM + Read/Show saving
09:30:00 <shapr> I think there's some difference.
09:30:16 <shapr> But after I understand STM better, I'll be able to answer your question better.
09:30:34 <vincenz> Btw, at the conference I was at, people had a hardware implementation of TM
09:30:39 <vincenz> Though it kinda sucked :/
09:30:55 <vincenz> It could handle everything STM does, but.... they get a L1-latency of 13 cycles
09:33:01 <matthew-_> oh
09:34:53 <kuiqsilver> Hello, I'm new to Haskell, and I'm trying to write some simple functions and play with types, but I'm going in circles.
09:35:45 <sorear> shapr: I don't suppose there is a roadmap for the HAppS code anywhere?
09:35:53 <sorear> I'll write my own if it doesn't exist.
09:44:12 <shapr> sorear: There is a plan, but it's mostly in the head of alexj
09:45:11 <Heffalump> kuiqsilver: can you describe one of your problems more precisely? :-)
09:48:49 <kuiqsilver> Possibly.  I'm trying to figure out the type system.  Let me get an example.
09:49:56 <shapr> I may have to change my nick to kwiksilver just from peer pressure.
09:50:00 * shapr looks at quicksilver 
09:52:37 <kuiqsilver> I have a list of tuples [("a", "alpha"), ("b", "beta")]
09:53:14 <ndm> Igloo, is it a bug if ghc --make fails to compile something that individual compilation can succeed with? its an overlapping instances issue
09:53:16 <kuiqsilver> I want to extract the first element of each tuple and return a list.
09:54:36 <Igloo> ndm: Yup, can't see why it wouldn't be
09:55:06 <shachaf> > map fst [("a", "alpha"), ("b", "beta")]
09:55:11 <lambdabot>  ["a","b"]
09:56:08 <dolio> > fst (unzip [("a", "alpha"), ("b", "beta")])
09:56:10 <lambdabot>  ["a","b"]
09:56:26 <dolio> @free unzip
09:56:29 <lambdabot> $map_Pair ($map f) ($map g) . unzip = unzip . $map ($map_Pair f g)
09:56:47 <ndm> Igloo, will put together a test case later then, its hitting one of my programs
09:57:00 <ndm> i tried a simple test case, and it worked, so something more subtle
09:57:22 <Igloo> ndm: How does it fail?
09:58:08 <kuiqsilver> That was easy enough.  I tried reinventing the wheel.  Or map, at least.
09:58:59 <ndm> Igloo, tells me i have overlapping instances when compiled together
09:59:24 <ndm> Igloo, i do have instance Foo Expr 3 times, but never import them all and use them in the same module
09:59:34 <ndm> its a benchmark on the Foo instances
09:59:50 <Igloo> Ah, I think that's a known bug
10:00:23 <Igloo> Which more commonly results in things working when they technically shouldn't
10:00:37 <ndm> well i quite like it working :)
10:00:50 <Igloo> Basically, GHC doesn't forget instances when it ought to
10:01:06 <ndm> how would you have two instances for Foo Expr in the program, both imported by Main (transitively), but not have them overlap?
10:01:16 <ndm> ah, in my case forgetting would make it work properly
10:01:27 <ndm> i suspected instance remembering was the issue, Hugs has the issue more severly
10:03:12 <Igloo> It's not when you have 2 instances, it's when you have an instance in A, a use in B, and Main imports A and B
10:03:26 <ndm> yeah
10:03:33 <ndm> my case is the reverse, it should work but it doesn't
10:03:44 <ndm> since in B there is also an instance, and they now overlap
10:04:22 <Igloo> And you're just compiling them all with --make, but nothing imports both?
10:04:38 <ndm> well, there is Main, which imports both of them transitively
10:04:52 <ndm> it isn't possible to have a module not export an instance, is it?
10:04:57 <Igloo> no
10:05:08 <ndm> which means there will be somewhere they are both in scope, but i never use the instance at that time
10:05:17 <ndm> not sure if thats legal or not
10:06:48 <Igloo> Not sure OTTOMH. hugs says no, ghc says yes, so I suspect the report says no and GHC possibly shouldn't accept it without -fglasgow-exts
10:07:03 <ndm> anyway, its only a benchmark
10:07:13 <ndm> so i'm happy with "working for the next 2 weeks"
10:07:41 <SamB> Igloo: the report doesn't say "don't accept it"
10:07:49 <Igloo> ta
10:07:54 <SamB> the report probably says "don't expect it to work"
10:08:02 <petekaz> just a quick question, to profile a program with GHC, I compile it as: ghc -prof -make spell.hs, and then run it as ./spell +RTS -P -RTS, is this correct?
10:08:04 <ToRA> matthew-_ : wouldn't you be better using Array or something a bit more, erm, binary?
10:08:07 <Igloo> Oh, I misread what you said
10:08:09 <SamB> GHC would have to go to (maybe a lot of) extra trouble to check that
10:08:28 <Igloo> The report certainly ought to say one way or the other, and Haskell' should clarify the language if not
10:08:58 <SamB> anyway don't expect GHC to catch it anytime soon...
10:09:03 <ndm> a way to not export an instance would be nice
10:09:42 <Igloo> ndm: You get problems when you do something like pass a set from a function that knows about one Ord instance to a function that knows about another one
10:10:15 <Igloo> I think there was a discussion about it on the Haskell' list a while back
10:10:32 <tuxplorer> how does lambdabot evaluate expressions that we paste here? I would like to interface a PHP script and ghci..
10:10:41 <Saizan> petekaz: ghc -prof -auto-all --make spell.hs and then ./spell +RTS -p, ghc user manual for more
10:11:15 <xerox> http://darcs.haskell.org/lambdaweb/ tuxplorer
10:11:17 <lambdabot> Title: Index of /lambdaweb
10:11:21 <petekaz> Saizan: thanks ...
10:11:53 <xerox> http://lambdabot.codersbase.com for a running copy
10:11:54 <lambdabot> Title: Lambdabot Web Interface
10:12:14 <SamB> tuxplorer: one of the most important steps is to pass it through a Haskell parser just to make sure it is actually an expression
10:12:23 <SamB> and not something with ) ( in the middle
10:13:02 <tuxplorer> xerox: That is limited right? I can't run something like let a = [1,2,3] .. returns 404
10:13:22 <tuxplorer> SamB: ok
10:14:13 <xerox> tuxplorer, no
10:14:54 <tuxplorer> does lambdabot use hugs?
10:15:07 <SamB> I don't think so
10:15:24 <SamB> not any of the plugins I know of, anyway...
10:15:25 <jcreigh> lambdabot uses hs-plugins, I believe.
10:15:42 <jcreigh> @where hs-plugins
10:15:43 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
10:18:01 <monochrom> Haskell takes O(log(N)) years to learn, where N is your age.
10:18:14 <SamB> really?
10:18:26 <SamB> what if you are a mathematician who doesn't know any programming languages?
10:18:26 <ndm> > log 20
10:18:28 <tuxplorer> monochrom: cool quote
10:18:28 <lambdabot>  2.995732273553991
10:18:36 <ndm> thats pretty accurate
10:18:39 <int-e> abuse of O() notation.
10:18:52 <SamB> monochrom: what is with the O?
10:18:53 <ndm> for O = 1
10:19:03 <tuxplorer> SamB: that would be easier.. only a person knowing other languages would compare things and get confused :)
10:19:06 <tuxplorer> ;)
10:19:09 <monochrom> Look at how sorear is absorbing up haskell quickly.  Contrast with all those "I've been programming for 15 years".
10:19:22 <sorear> hello.
10:19:30 <monochrom> The O means approximation.
10:19:46 <jcreigh> I thought it meant "on the order of"
10:19:56 <SamB> jcreigh: pretty much
10:20:03 <int-e> O() is an asymptotic upper bound.
10:20:05 <SamB> also it is an upper bound
10:20:10 <monochrom> "means" also means approximation.
10:20:52 <jcreigh> hmm...so what's the lower bound for learning Haskell? (I forget which letter of the greek alphabet that one is...)
10:21:07 <monochrom> Ω
10:21:49 <monochrom> Technically I should write Θ(log N).  There are two problems with that.
10:22:07 <monochrom> 1. Some of you will yell at me "yikes! unicode!"
10:22:08 * jcreigh makes a mental note to try to get unicode working with irssi+screen+xterm again.
10:22:46 <SamB> it helps if you call xterm "uxterm"
10:23:06 <liquidengineer> lol
10:23:10 <monochrom> 2. The target audience, those who've been programming for 15 years, most likely have forgotten Θ; moreover, they use O for Θ.
10:23:19 <liquidengineer> strange; why not have one audience with a flag for unicode support?
10:23:27 <int-e> monochrom: it's still just asymptotic.
10:23:54 <SamB> doesn't Haskell take 3 years to learn anyway?
10:24:08 <monochrom> That's just me.
10:35:35 <jcreigh> monochrom: what encoding is that? UTF-8?
10:35:43 <monochrom> Yes.
10:38:35 <Korollary> hi sigfpe
10:42:11 <ToRA> @paste
10:42:12 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:42:34 <sorear> @seen glguy
10:42:35 <lambdabot> glguy is in #haskell. I last heard glguy speak 3d 21h 48m 57s ago.
10:43:46 <dpiponi> hi korollary. I'm supposed to be in another IRC channel, not this one,  so see ya!
10:44:17 <sorear> silly dpiponi, you can't join another channel after you /quit
10:44:39 <Korollary> He's probably changing servers
10:45:02 <Korollary> There must be a category of irc channels
10:45:08 <sorear> there are other #haskells?
10:45:38 <Korollary> I meant to say "he's probably changing servers as well."
10:50:26 <jcreigh> okay, my setup *might* be unicode-aware now.
10:51:23 * ddarius beats his setups down whenever they become aware.
10:51:54 <jcreigh> "I'm sorry, Derek; I'm afraid I can't let you do that"
10:53:58 <jcreigh> does this look like omega to anybody: Ω
10:54:06 <monochrom> jcreigh: testing, the λ calculus is fun!
10:54:08 <ToRA> jcreigh : yes
10:54:12 <monochrom> Yes.
10:54:16 <sorear> <jcreigh> does this look like omega to anybody: ?
10:54:17 <sorear> ;)
10:54:28 * monochrom beats down sorear
10:54:33 <hpaste>  ToRA pasted "300 lines of haskell + a ps3 :)" at http://hpaste.org/1503
10:54:34 * ToRA finishes his saturday afternoon project
10:55:26 <monochrom> Oh God, a beast has been unleashed!
10:55:28 <jcreigh> monochrom: is that supposed to be lambda?
10:55:33 <monochrom> YES!
10:55:52 <jcreigh> okay. It's not a broken character, but my font renders it strangely.
10:55:58 <monochrom> Congratulations! You have passed the Turing test!
10:59:04 <arjanoosting> i think it does.
11:01:47 <jcreigh> Now I can be a unicode snob. "Consider some function α and a second function β..."
11:02:19 <rmulliga> What do you guys think about writing a MUD server in Haskell?
11:03:23 <monochrom> Many people have thought the same. I wonder what has been done.
11:04:46 <ddarius> Argh!  Crappy scones.
11:06:54 <ddarius> rmullinga: It should be straightforward.  At least as straightforward as doing it in most other languages.
11:06:54 <sioraiocht> @src join (,)
11:06:55 <lambdabot> Source not found. Take a stress pill and think things over.
11:07:07 <ddarius> @src (->) join
11:07:07 <lambdabot> Source not found. My pet ferret can type better than you!
11:07:12 <ddarius> Oh wait
11:07:15 <ddarius> @src join
11:07:15 <lambdabot> join x =  x >>= id
11:08:33 <xerox> sioraiocht, \x -> (x,x).
11:08:41 <sioraiocht> xerox: thanks
11:08:56 <sorear> Lambdabot should have a @rnf command.
11:10:26 <rmulliga> ddarius: I was told by someone who tried, that it is harder to do because manipulations are more difficult in Haskell. Granted I have not read more than 15 pages of the gentle introduction, so I do not know how to filter that comment properly.
11:10:29 <qebab> dear lord
11:10:42 <qebab> finally have an IDE with support for haskell
11:10:58 <qebab> if I knew it would take me this long I'd just continued using gedit :|
11:10:59 <sioraiocht> ew, IDEs are evil anyway
11:11:23 <sioraiocht> all you need for haskell is syntax highlighting, and maybe intelligent indentation
11:11:32 <sioraiocht> aka Emacs
11:11:39 <SamB> sioraiocht: hah!
11:11:44 <SamB> intelligent, they call this?
11:11:58 <sioraiocht> SamB: well, not naïve, then
11:11:59 <qebab> sioraiocht: I'm not used to terminal-based IDEs yet
11:12:03 <qebab> so emacs is a bit scary and insane
11:12:12 <monochrom> which IDE is that?
11:12:14 <qebab> actually a bit scary and a lot insane
11:12:17 <xerox> sioraiocht, join (,)  =  (,) >>= id  =  (\g f x -> \y -> f y (g x)) (,) id  =  \x y -> (,) x y  =  \x y -> (x,y)
11:12:19 <SamB> emacs is terminal based now is it?
11:12:27 <SamB> well, sure, you can use it on a terminal...
11:12:40 <sioraiocht> qebab: the vi/emacs war aside, picking up one will make your development life happier
11:12:40 <qebab> SamB: the version I have seems to be
11:12:42 <SamB> but under X it tends to launch a window of its own
11:12:49 <SamB> qebab: look around for an X version
11:12:54 <qebab> okay
11:12:56 <sioraiocht> qebab: what system are you running?
11:13:00 <qebab> ubuntu
11:13:05 <SamB> !
11:13:08 <qebab> !
11:13:17 <xerox> sudo apt-get install emacs-snapshot
11:13:21 <monochrom> I wonder which IDE qebab refers to.
11:13:48 <Korollary> eclipse maybe
11:14:05 <qebab> monochrom: I spent a millennium searching for a haskell plugin for some IDE, and ended up with eclipse (which I have never used before)
11:14:11 <ndm> hmm, the arbitrary scheme implemented by drift sucks totally...
11:14:27 <sioraiocht> IDEs hinder, they don't help
11:14:31 <ndm> anyone know what a good instance Arbitrary should look like? ideally one that terminates eventually...
11:14:55 <Nafai> sioraiocht: In what way do they hinder?
11:14:59 <SamB> sioraiocht: I was under the impression that they could actually help some people
11:15:07 <SamB> also they worked relatively well in DOS
11:15:10 <sioraiocht> SamB: 'some people', and they are? =p
11:15:25 <monochrom> Me.
11:15:33 <sioraiocht> Nafai: It forces the user to focus on the mechanics of a program instead of the language
11:15:44 <sioraiocht> Nafai: my exception is GUI programming
11:15:46 <SamB> sioraiocht: people who already know how to do the things without an IDE
11:15:58 <Nafai> sioraiocht: I'm not sure I follow?
11:15:59 <SamB> sioraiocht: wait, isn't that what you are supposed to focus on?
11:16:19 <sioraiocht> By program I meant the IDE, not the program you're constructing ;)
11:16:39 <sioraiocht> does that help?
11:16:50 <Inamabilis> Hey - anyone got a sec to explain something hopefully pretty simple? - What does deriving Show mean?
11:16:51 <SamB> it doesn't help people who have to focus on the mechanics of the IDE, no ;-)
11:17:01 <sioraiocht> Inamabilis: Show is a type class, do you know what that is?
11:17:05 <Nafai> sioraiocht: I don't focus on the mechanics of my IDE
11:17:19 <SamB> Inamabilis: basically it makes it so you can do things like this:
11:17:25 <SamB> > show (Left 1)
11:17:26 <lambdabot>  "Left 1"
11:17:38 <SamB> with your datatype
11:17:39 <sioraiocht> Inamabilis: it lets you show a user-defined data type
11:17:59 <Nafai> Inamabilis: Similar to the toString() methods of Java classes, I guess
11:18:07 <monochrom> that means convert to string
11:18:13 <ddarius> http://www.haskell.org/onlinereport/derived.html -- very helpful link </sarcasm>
11:18:14 <lambdabot> Title: The Haskell 98 Report: Derived Instances
11:18:28 <Inamabilis> ok
11:18:30 <sioraiocht> I would make the claim that you could say type classes are analogous to interfaces..
11:18:41 <Inamabilis> ...so converts a userdefined datatype to a human readable form?
11:18:47 <sorear> yeha.
11:18:47 <SamB> ddarius appears to have linked to the part of the report that says *exactly* what will be derived (for Haskell 98-ish types)
11:18:49 <ddarius> sioraiocht: But that falls apart rather quickly.
11:18:52 <monochrom> Perhaps machine readable
11:19:00 <sioraiocht> ddarius: was waiting for that response, why?
11:19:17 <ddarius> Constructor classes already go beyond interfaces.
11:19:19 <SamB> Inamabilis: it is sometimes human readable
11:19:34 <Inamabilis> but not always
11:19:34 <ddarius> Typeclasses don't support dynamic dispatch.
11:19:46 <SamB> but sometimes it would need some indentation to be human-readable
11:19:48 <sioraiocht> Inamabilis: yes, but it does it in the default manner.  deriving means "do it the way that is defined by default".  You can define your own version of the show function
11:19:48 <ddarius> And we'll not even get into extensions.
11:20:12 <sioraiocht> ddarius: FINE, KNOCK DOWN MY TOWER OF CARDS =p
11:21:01 <ddarius> http://www.haskell.org/hawiki/UnderestimatedTypeClasses
11:21:02 <lambdabot> Title: UnderestimatedTypeClasses - The Haskell Wiki
11:21:28 * SamB wonders if there is a document about the infix type/data constructors, and how to derive Show for the data constructors
11:21:29 <sioraiocht> haha
11:21:30 <Inamabilis> if i have "data Tree a = Leaf a | Node (Tree a) a (Tree a)              deriving Show"
11:21:32 <sioraiocht> <-------- owned
11:22:02 <SamB> we still have hawiki?
11:22:14 * ddarius pets hawiki.
11:22:21 <ddarius> @oldwiki UnderestimatedTypeClasses
11:22:21 <lambdabot> http://www.haskell.org/hawiki/UnderestimatedTypeClasses
11:23:09 <monochrom> show (Node (Leaf 0) 1 (Leaf 2))  will give you "Node (Leaf 0) 1 (Leaf 2)"
11:23:38 <monochrom> Try it!
11:24:05 <monochrom> If you delete "deriving Show", show (Node (Leaf 0) 1 (Leaf 2)) is a compile-time error.
11:24:25 <sioraiocht> everytime I think I "know haskell", I end up with a "silly n00b" conversation =p
11:24:52 <tuxplorer> what is available in haskell for dynamic webpages? something similar to rails or PHP or JSP or the likes? WASH, Haaps, HSP? which is better?
11:25:51 <monochrom> Is WASH going through cgi?
11:26:25 <SamB> tuxplorer: well, you could look at the code for hpaste.org
11:26:32 <SamB> @paste
11:26:32 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:26:36 <SamB> hmm.
11:26:39 <tuxplorer> yes. WASH has some CGI thing
11:26:40 <SamB> take off the new ;-)
11:26:45 <ddarius> Incidentally, in that comparison linked on UnderestimatedTypeClasses, Haskell kicks massive ass.
11:27:04 <SamB> ddarius: when does Haskell not kick massive ass?
11:27:06 <monochrom> happs is fancy. at least shapr's version is fancy. has everything under the sun, plus beyond the solar system.
11:27:45 <ddarius> SamB: Point.  But this is an explicit study and those are fairly rare.
11:28:08 <ddarius> It has everything within the Oort Cloud!
11:28:38 <SamB> ... this article appears to be inside the ACM event horizon..
11:30:29 <monochrom> Seems to be nice paper.
11:30:56 <monochrom> Follow the "pdf" link. No need to step into the ACM radius.
11:32:42 <shapr> monochrom: My version?
11:32:58 <SamB> I will omit complaining about this, because nobody can fix it anyway :-)
11:33:10 <Nafai> Hey shapr!
11:33:22 <monochrom> You're paid to enhance happs, aren't you?
11:34:09 <monochrom> SamB: when you're reading the hawiki page, do you see "A _comparison_ (_pdf_) between ..." ?
11:34:39 <SamB> yes
11:34:44 <monochrom> Good.
11:34:58 <monochrom> (Have you tried the _pdf_ link?)
11:35:04 <SamB> I will neglect the complaining about the main link leading to the ACM site, is what I mean ;-)
11:35:18 <monochrom> I see.
11:35:49 <ddarius> I did that because I don't like directly linking to the papers but I wanted to provide a link so that you could read the abstract.
11:36:02 <ddarius> Unfortunately, that was the only one that I could find at the time.
11:37:38 <monochrom> I'm old school.  I like the presence of the acm link.
11:38:05 <ddarius> I'd prefer a citeseer link or pages like BRICS's.
11:39:15 <monochrom> hyperlink is not hyper enough.  one link should expand to many urls.
11:40:15 <monochrom> don't tell that to the www people.  they'll actually follow it up. It'll be a nightmare for us. :)
11:40:44 <xerox> .oO( XXXML )
11:41:51 <ddarius> monochrom: We don't need the W3C people to do that.  We can make annoying popups that list multiple links, like that annoying popups on certain blog pages that "preview" the link when you hover over them.
11:42:23 <shapr> @yarr
11:42:23 <lambdabot> Yeh scurvy dog...
11:43:04 <dolio> @yow!
11:43:05 <lambdabot> I'm also against BODY-SURFING!!
11:44:52 <dolio> @vixen
11:44:53 <lambdabot> <undefined>
11:45:46 <int-e> heh
11:46:47 <shapr> Do you guys say foo' is foo prime or foo tick?
11:46:50 <Lemmih> ?keal
11:46:51 <lambdabot> oh btw my fpu is blown due to a hardcased failsafe i have 3 year warranty right. and then they call fads
11:47:11 <ddarius> foo prime
11:47:12 <shapr> \keal
11:47:15 <ddarius> Hence Haskell prime
11:47:19 <petekaz> how would I do this python snippet in haskell? max(candidates, key=lambda w: NWORDS[w])
11:47:21 <shapr> @keal
11:47:22 <lambdabot> know you know this 24 periods Keal SecretTM
11:47:31 <Nafai> shapr: Still in Sweden?
11:47:37 <shapr> Nafai: Nah, back in Alabama and working.
11:47:42 <shapr> I had a lovely vacation though.
11:47:51 <ddarius> What does NWORDS do?
11:47:51 <Nafai> Cool; I noticed you had disappeared for a while :)
11:47:54 <ddarius> @type maximum
11:47:55 <petekaz> candidates is a list of things, but max uses the lamba to lookup the value to compare.
11:48:00 * Nafai is watching a Google Video on type systems
11:48:09 <lambdabot> thread killed
11:48:14 <shapr> petekaz: compareBy?
11:48:24 <shapr> er no..
11:48:44 <kc5tja> ddarius: It's just an indexable sequence of some kind.
11:48:50 <ddarius> @hoogle maximumBy
11:48:50 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
11:48:50 <lambdabot> Data.List.maximumBy :: (a -> a -> Ordering) -> [a] -> a
11:49:03 <dolio> @type comparing
11:49:03 <petekaz> oh ... didn't know that existed.
11:49:18 <lambdabot> thread killed
11:49:46 <dolio> > maximumBy (comparing abs) [1, 2, 3, -15, 3, 8, 12]
11:49:51 <petekaz> I'll use maximumBy ... somehow I missed this.  I'm looking right at it in the docs, not sure how that happened.
11:49:51 <lambdabot>  -15
11:50:00 <petekaz> dolio: thanks.
11:50:52 <ddarius> @src maximum
11:50:52 <lambdabot> maximum [] = undefined
11:50:52 <lambdabot> maximum xs = foldl1 max xs
11:51:12 <dolio> > maximumBy (compare `on` abs) [1, 2, 3, -15, 3, 8, 12] -- maybe...
11:51:15 <lambdabot>   Not in scope: `on'
11:51:24 <ddarius> List.maximumBy is what you get when you abstract out 'max'
11:51:44 <ddarius> @src max
11:51:44 <lambdabot> max x y = if x <= y then y else x
11:52:21 <ddarius> Data.List.maximumBy is what you get when you inline max but (roughly) abstract out (<=)
11:52:37 <ddarius> So anyway, if you a fooBy, just look at the source for foo and abstract.
11:52:54 <ddarius> Assuming, of course, it doesn't already exist.
12:12:05 <shapr> ddarius: So, is there a way to make a by function so that fooBy = foo . by ?
12:12:49 <ddarius> no
12:13:02 <ddarius> At least not in general.
12:13:20 <dolio> :t nubBy
12:13:37 <lambdabot> thread killed
12:13:42 <Korollary> lol
12:14:32 <sorear> @activity 500
12:14:33 <lambdabot> 1*total 1*#haskell
12:15:10 <allbery_b> bot restart time?
12:15:24 <sorear> @flush
12:15:50 <Korollary> @shame
12:15:51 <lambdabot> Unknown command, try @list
12:16:22 <shapr> @restart
12:16:23 <lambdabot> Unknown command, try @list
12:19:12 <tuxplorer> when I try to install regex-base, it asks for base>=2.0 as dependency.. But where do I get base?
12:19:35 <sorear> you don't
12:19:43 <sorear> it came with your compiler
12:19:55 <Saizan> ?type maximumBy (comparing (\w -> NWORDS Map.! w))
12:19:59 <sorear> if it didn't, you must be trying to use a compiler for a different language
12:20:12 <lambdabot> thread killed
12:20:21 <sorear> @botsnack
12:20:22 <tuxplorer> sorear: then, how do I make my regex-base understand that I have it?
12:20:23 <lambdabot> :)
12:20:56 <SamB> @scheck \f z xs -> scanr f z xs == scanl (flip f) z (reverse xs)
12:20:59 <sorear> tuxplorer: you have it.  just not version 2.0
12:21:01 <lambdabot> Add a type signature
12:21:10 <sorear> tuxplorer: that means ghc 6.6
12:21:18 <SamB> @scheck \f z xs -> scanr (f :: I -> I) z xs == scanl (flip f) z (reverse xs)
12:21:20 <lambdabot> Couldn't match expected type `b -> b' against inferred type `I'
12:21:25 <tuxplorer> sorear: oh! ok..
12:21:31 <SamB> @scheck \f z xs -> scanr (f :: I -> I -> I) z xs == scanl (flip f) z (reverse xs)
12:21:36 <lambdabot>   Failed test no. 2. Test values follow.: -3->
12:21:36 <lambdabot>   {-3->0;-2->0;-1->0;0->0;1->0...
12:21:58 <SamB> @scheck \f z xs -> scanr (f :: B -> B -> B) z xs == scanl (flip f) z (reverse xs)
12:21:59 <lambdabot>  Not in scope: type constructor or class `B'
12:22:19 <SamB> @scheck \f z xs -> scanr f (z :: Bool) xs == scanl (flip f) z (reverse xs)
12:22:21 <lambdabot> Add a type signature
12:22:58 <SamB> @scheck \f z xs -> scanr1 f xs == scanl1 (flip f) (reverse xs) :: [Bool]
12:23:02 <lambdabot> Couldn't match expected type `[Bool]' against inferred type `Bool'
12:23:11 <SamB> @scheck \f z xs -> scanr1 f xs == (scanl1 (flip f) (reverse xs) :: [Bool])
12:23:15 <lambdabot> Add a type signature
12:23:44 <SamB> @scheck \f z xs -> scanr1 f xs == (scanl1 (flip f) (reverse xs :: [Bool]) :: [Bool])
12:23:48 <lambdabot> Add a type signature
12:24:08 * SamB gives up
12:25:22 <bwerf> is there a lanuage which contains some aspects of haskell but allows assignment and stuff so i don't have to learn it coldturkey ?
12:25:32 <SamB> bwerf: that would be horrible
12:25:32 <dolio> @scheck \f z xs -> reverse (scanr (f :: I -> I -> I) z xs) == scanl (flip f) z (reverse xs)
12:25:46 <bwerf> SamB: why
12:25:49 <lambdabot> Plugin `small' failed with: IRCRaised Data.ByteString.last: empty ByteString
12:25:55 <dolio> Heh.
12:26:23 <bwerf> I don't get the whole monad thing, but i would like to try the generic programming and function as value stuff
12:26:43 <dolio> @check \f z xs -> reverse (scanr (f :: I -> I -> I) z xs) == scanl (flip f) z (reverse xs)
12:27:00 <lambdabot> Plugin `check' failed with: IRCRaised Data.ByteString.last: empty ByteString
12:27:31 <SamB> bwerf: monads are very simple. perhaps that is why you have so much difficulty with them?
12:28:20 <bwerf> SamB: i don't see how i would represent a big xml document that is updatable as them
12:28:42 <SamB> er, what?
12:28:44 <bwerf> or better said, i don't see how i would do anything 'updatable'
12:28:48 <SamB> "updateable"?
12:28:57 <bwerf> well how would i do somethign like a database in haskell
12:29:08 <sorear> system.
12:29:13 <sorear> don't duplicate work.
12:29:15 <SamB> not using an XML tree!
12:29:24 <bwerf> remove an element from a linkedlist, that kind of thing
12:29:45 <dolio> You don't remove an element, you build a new list without it.
12:30:00 <SamB> are you a programmer or a computer scientist?
12:30:05 <bwerf> programmer
12:30:15 <dolio> Although you might share some of the old structure.
12:30:46 <bringert> bwerf: look up the definition of tail
12:30:49 <bringert> @src tail
12:30:50 <lambdabot> tail (_:xs) = xs
12:30:51 <lambdabot> tail []     = undefined
12:31:00 <bwerf> yeah that i know from miranda
12:31:03 <bringert> that removes an element from a "linked list"
12:31:20 <sorear> if you know miranda, you know haskell.
12:31:39 <sorear> haskell has more features, but everything you can do in miranda is easy in haskell too.
12:31:44 <bringert> bwerf: all modification in (pure) haskell is like that
12:31:44 <bwerf> i know some trivial stuff to pass a course, i have no clue how to build 'big' software in miranda
12:31:46 <SamB> sorear: you exhaggerate slightly
12:31:56 <SamB> what would you want big software for?
12:32:14 <bwerf> to earn a living
12:32:47 <SamB> well, anyway, as in all languages, building big software is an easy two-step process
12:32:53 <SamB> (1) build small software
12:32:56 <SamB> (2) make it bigger
12:33:05 <shapr> bwerf: Hey, I earn a living with the Miranda sequel.
12:33:05 <bwerf> right
12:33:14 <bringert> bwerf: for your database example, a first approximation could be that a table is a list of rows
12:33:27 <sorear> bwerf: then don't use haskell, haskell in the hands of expers is too fast and cheap, you won't be able to credibly extort your customers
12:33:34 <bwerf> shapr: the one from the UT ?
12:33:44 <shapr> Nah, the one from Glasgow.
12:33:45 <bringert> why do the customers have to know how easy it is?
12:34:04 <SamB> bringert: they will notice that it doesn't use enough RAM
12:34:07 <bwerf> sorear: luckily there are too few experts to go around
12:34:28 <shapr> bwerf: In my opinion, Haskell is a good production language.
12:34:29 <bringert> SamB: I have never had the problem that my Haskell programs use too little RAM
12:34:59 <SamB> bringert: point
12:35:15 <bringert> GF is 68 KLOC Haskell at the moment
12:35:21 <bwerf> ok, i had hoped to be able to use parts of this in a more gradual manner
12:35:29 <shapr> bwerf: That's pretty hard to do.
12:35:34 <shapr> bwerf: I'd suggest the cold turkey approach.
12:35:41 <shapr> hoi jyp
12:35:52 <Codex_> does haskell version of fork() use side effects?
12:35:54 <dolio> SamB: By the way, I suspect that what I sent above is closer to the scanr/scanl identity, although lambdabot is barfing on it.
12:35:56 <jyp> hey shapr !
12:36:01 <bringert> is there a ColdTurkeyT monad transformer?
12:36:13 <shapr> bwerf: Do you have any specific questions we could help with?
12:36:18 <bringert> Codex_: what do you mean?
12:36:21 <SamB> dolio: yeah, me too...
12:36:26 <bringert> Codex_: forkIO is in the IO monad
12:36:27 <sorear> hello jyp
12:36:27 <Korollary> ?type forkIO
12:36:33 <SamB> but probably that wouldn't work on infinite lists...
12:36:33 <bringert> Codex_: but there is also par
12:36:35 <dolio> SamB: Remember that (head $ scanr ...) is the result of foldr, whereas (last $ scanl ...) is the result of foldl.
12:36:42 <jyp> hello sorear
12:36:43 <lambdabot> thread killed
12:36:46 <bwerf> shapr: not right now :)
12:36:50 * Korollary condemns lambdabot 
12:36:55 <shapr> bwerf: Ok, if you think of some, ask 'em!
12:37:14 <sorear> @google GF
12:37:19 <bringert> @where GF
12:37:19 <lambdabot> http://www.gfoffice.com/
12:37:19 <lambdabot> Title: GF Office Furniture
12:37:23 <lambdabot> http://www.cs.chalmers.se/~aarne/GF/
12:37:24 <bringert> grr
12:37:30 <bwerf> oh i do have one, is GHCI a good one to use ?
12:37:30 <bringert> the chalmers one
12:37:36 <shapr> bwerf: I like it.
12:37:42 <bringert> I'm not hacking on furniture
12:37:44 <SamB> dolio: it all started when I looked at Data.List.Stream to see how it fused tails...
12:38:00 <shapr> bwerf: You may run across problems when doing heavy threading stuff in GHCi, but other than that it should be fine.
12:38:15 <sorear> @google gf chalmers
12:38:20 <lambdabot> http://www.amazon.co.uk/gp/pdp/profile/A2L4S9TFMGRARK
12:38:20 <lambdabot> Title: Amazon.co.uk: Profile for G. F. Chalmers
12:38:43 <shapr> haha
12:38:46 <SamB> dolio: (it doesn't have one)
12:39:05 <bwerf> shapr: would javascript be a smaller step for me to experiment with closures and currying ?
12:39:24 <sorear> bwerf: look at o'caml or SML/NJ
12:39:27 <SamB> bwerf: haskell is a lot more comfy than javascript
12:39:28 <bringert> bwerf: javascript does not have currying in itself
12:39:39 <bringert> you can do it though
12:39:55 <sorear> bwerf: currying and closures and higher order goodness, but no laziness or purity
12:40:01 <Korollary> why not just learn haskell and write something small first
12:40:02 <SamB> you can try out Haskell from the comfort of a nice REPL
12:40:03 <bringert> but yeah, o'caml or something would be a better fit for "haskell with assignment"
12:40:11 <shapr> bwerf: Closures are available in many places, but I haven't seen currying done well outside of Haskell.
12:40:28 <bringert> doesn't o'caml have currying?
12:40:36 <shapr> Er, does it?
12:40:45 <SamB> shapr: wouldn't it?
12:40:52 <shapr> Would make sense, I agree.
12:40:55 <SamB> something else has
12:41:01 <SamB> an ML
12:41:02 <bringert> I can't remember, but I can't see why it wouldn't
12:41:04 <Codex_> bringert: I mean forkProcess :: IO () -> IO ProcessID, it seems to return twice from the function?
12:41:17 <SamB> now, it might not be well-used
12:41:19 <dolio> You can do currying in ML, but people don't, no?
12:41:23 <shapr> Currying seems to clash with mutability in my head. I wonder if it would cause problems in OCaml.
12:41:27 <bringert> @hoogle forkProcess
12:41:34 <lambdabot> No matches found
12:42:03 <sorear> ml does currying and uncurrying the same way as haskell.
12:42:11 <SamB> thats what I thought!
12:42:14 <sorear> let foo x y = x + x (* curried *)
12:42:22 <sorear> let foo(x,y) = x + x (* uncurried *)
12:42:27 <bringert> Codex_: return twice?
12:42:27 <SamB> except people have a strange habbit of wrapping the arguments in tuples!
12:42:29 <Korollary> they dont use it much tho. I think the pairs are more efficient in implementations.
12:42:47 <Codex_> bringert: I mean both processes will have their own ProcessID?
12:43:20 <bringert> Codex_: it works like fork(), so the caller will keep its PID, and the new process gets a new PID
12:43:28 <bringert> Codex_: or did I misunderstand the question?
12:43:54 <Codex_> bringert: normally fork() returns two values, processID and 0.
12:44:00 <shapr> bwerf: I think it depends on your goal, really. Haskell will stretch your brain lots and you'll write better code afterwards. Most other languages will stretch your brain less.
12:44:09 <bringert> Codex_: oh, I see. no, forkProcess seems to be different
12:44:49 <bringert> Codex_: it takes an IO action as an argument, and runs that as the child, not like fork() which runs two copies of the same
12:44:50 <bringert> code
12:45:11 <bringert> Codex_: so there is no way it could return in the child
12:45:22 <Codex_> bringert: oh, then I've misunderstood the forkProcess. Thanks.
12:45:42 <araujo> hello
12:45:48 <bringert> Codex_: I haven't actually used it, but that's the only way I can see that it would work based on the haddock docs
12:45:49 <shapr> hola araujo, nice blog!
12:46:03 <bringert> "The IO action passed as an argument is executed in the child process; no other threads will be copied to the child process."
12:46:04 <araujo> Hello shapr !
12:46:09 <araujo> shapr, Thanks! :-)
12:46:10 <bwerf> shapr: the stretching part is what i'm looking for, atleast for the weekend :)
12:46:56 <shapr> bwerf: In that case, I'd recommend Haskell. But it's been stretching my brain for years, so it may take more than a weekend. On the other hand, I get bored with a language when it stop stretching my brain, so I've been happy with Haskell for a long time!
12:48:08 <bwerf> i'd prefer streching with the 'job' language but i've reached the limits i think
12:48:08 <monochrom> Learning Haskell takes Θ(log n) years, where n is your age.
12:48:16 <shapr> bwerf: What's your job language?
12:48:26 <bwerf> delphi, the horror
12:48:28 <shapr> Lucky me, my job language is Haskell.
12:48:34 <scodil> did there used to be a list function called 'select'? I can't find it in any documentation
12:48:44 <Nafai> shapr is a braggar
12:49:05 <bwerf> if it was c++ atleast i could start abusing boost and stl
12:49:09 <sorear> as long as the four letter name gang is alive, no fixed size brain will be able to hold haskell.
12:49:19 <monochrom> delphi is not bad.
12:49:20 <Korollary> abusing boost is not considered good practice
12:49:43 <shapr> Nafai: It did take me a few years to get to this point :-)
12:49:45 <sorear> { oleg, olaf, ralf, ross, ... }
12:49:49 <Nafai> shapr: I know :)
12:49:53 <bringert> scodil: what would it do?
12:49:57 <bwerf> Korollary: lacking generic programming, there isn't much interresting stuff in the language itself
12:50:19 <Korollary> bwerf: That's a job language for you. They are not meant to stretch anything.
12:50:19 <monochrom> Hmm olaf?
12:50:20 <scodil> the code using it looks like it does the same thing as !!, but also gives the rest of the list
12:50:32 <sorear> Olaf Chitil
12:50:51 <scodil> (xs !! n, drop n xs) basically
12:50:55 <monochrom> @remember sorear as long as the four letter name gang is alive, no fixed size brain will be able to hold haskell. { oleg, olaf, ralf, ross, ... }
12:50:56 <lambdabot> Done.
12:51:40 <Nafai> shapr: I'm afraid all I'm doing right now is making myself marketable for J2EE jobs :/
12:51:58 <shapr> scodil: Yeah, select is available from a Posix.select library, I think.
12:52:04 <shapr> @seen juhp
12:52:04 <lambdabot> I haven't seen juhp.
12:52:12 <shapr> @seen simonpj
12:52:12 <lambdabot> I haven't seen simonpj.
12:52:13 <scodil> no that's different, right? that's poll/select
12:52:25 <shapr> Er, which select do you mean?
12:52:38 <sorear> <scodil> the code using it looks like it does the same thing as !!, but also
12:52:38 <sorear>          gives the rest of the list
12:52:38 <sorear> <scodil> (xs !! n, drop n xs) basically
12:52:39 <shapr> Oh, list function... I've never heard of it.
12:54:35 <shapr> bwerf: Jump in! The lambdas are comfy!
12:55:16 <shapr> @seen luke
12:55:17 <lambdabot> I haven't seen luke.
12:55:19 <shapr> @seen luke_
12:55:20 <lambdabot> I haven't seen luke_.
12:55:30 <bwerf> ill reread the 'haskell for cprogrammers' thingy
12:55:36 <monochrom> sugar lambdas are tasty
12:56:46 <bwerf> the 'purely functional' chocolates taste a bit off
12:57:01 * kc5tja was reading SICP this past week.
12:57:03 <dolio> > select _ [] = undefined ; select 0 (x:xs) = (x, xs) ; select n (x:xs) = (x:) `second` select (pred n) xs in select 5 [1..10]
12:57:04 <lambdabot>  Parse error
12:57:07 <dolio> Bah.
12:57:17 <shapr> bwerf: They're non-fattening.. no side-effects. That's probably it.
12:57:52 <tom_> hi all
12:58:06 <shapr> Hi tom
12:58:37 <tom_> I keep on finding myself in need of a function to take a list an return it in chunks of a given size. It's very simple to implement but it seems like the sort of thing that wouldbe in the standard prelude
12:58:48 <tom_> Here's my code for it:
12:59:02 <tom_> splitup _ [] = []
12:59:04 <tom_> splitup n lst = let (x, rest) = splitAt n lst in x : splitup n rest
12:59:22 <tom_> Anyone know if it's there and I'm just missing it?
12:59:45 <Saizan> couldn't find it when i needed
12:59:59 <SamB> it isn't a good idea to try to fully fuse tails, is it?
13:00:10 <shapr> What about recursing with take n?
13:00:18 <dolio> > let splitAtM _ [] = Nothing ; splitAtM n l = Just (splitAt n l) in unfoldr (splitAtM 3) [1..9]
13:00:29 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9]]
13:00:43 <SamB> shapr: aren't you thinking heads?
13:01:00 <shapr> er, yeah
13:01:09 <shapr> something like that..
13:01:14 <SamB> anyway, I'm thinking it is probably a bad idea to recompute the tails in each case?
13:01:18 <shapr> I'm writing some other code and it's clashing in my head..
13:01:32 <SamB> could be O(n^2) instead of O(n)!
13:02:00 <dolio> If only unfoldr took a stop predicate instead of Maybe...
13:02:03 <sorear> SamB: tails runs in O(n)
13:02:14 <SamB> sorear: yes!
13:02:22 <SamB> that ! was not part of the maths, btw
13:02:34 <tom_> I'm not sure I understand
13:03:04 <dolio> tom_: Which?
13:03:22 <tom_> just a sec, I'm going to go try out some stuff then ask some questions :p
13:04:44 <shapr> Is Bas van Dijk here?
13:05:57 <tom_> dolio, will your version behave or perform differently or is it just stated in a different way?
13:07:00 <dolio> tom_: I think it does the same thing. It just uses unfoldr, where you wrote out the recursion explicitly.
13:08:05 <tom_> ah, cool. Sorry, I misunderstood and was trying to figure out how it differed. It certainly feels more elegant
13:08:07 <dolio> unfoldr takes a seed value (the list) and a function to split a seed value into an element and a new seed (splitAt n) and builds a list.
13:08:50 <dolio> And it also has a stopping condition, which can either be (seed -> Bool), or, in this case, you're supposed to return (Maybe (element, seed)), where it stops on Nothing.
13:09:35 <dolio> If it used a function instead, you could write it as: 'unfoldr null (splitAt 3) l'
13:09:56 <dolio> And that would do the same thing as your original code, I think.
13:10:00 <dolio> Just shorter.
13:10:30 <tom_> I'm actually working with infinite lists so I guess this'll work:
13:10:41 <tom_> > take 10 $ unfoldr (Just.(splitAt 5)) [1..]
13:10:53 <lambdabot>  [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23,24,25]...
13:11:18 <dolio> Ah, yeah, if it's infinite, then it's equally conscise.
13:17:42 <dolio> > let unless p f a = if p a then Nothing else Just (f a) in unfoldr (unless null $ splitAt 3) [1..]
13:18:02 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23,...
13:19:16 <tom_> that's quite nice, unless looks like a useful function in its own right
13:19:30 <dolio> Yeah. The name unless is already taken, though.
13:20:02 <dolio> Well, I've got to jet.
13:20:44 <tom_> thanks for the help
13:21:26 <scodil> ls
13:22:04 <drigz> i found a bug in ?pl :p
13:22:31 <drigz> ?pl \x -> (-x)
13:22:44 <lambdabot> subtract
13:23:19 <xs> ?pl \f x -> f (-x)
13:23:28 <lambdabot> (. subtract)
13:24:04 <drigz> > subtract
13:24:53 <drigz> is there a better way of having \x -> (-x) than (0-)?
13:25:05 <jcreigh> negate?
13:25:07 <int-e> @type negate
13:25:25 <drigz> jcreigh: thanks
13:25:34 <jcreigh> is lambdabot really lagging, or is it just me?
13:25:35 <SamB> drigz: in @pl's defense, that is a nasty corner of Haskell's syntax
13:25:46 <lambdabot> thread killed
13:26:12 <drigz> SamB: yeah, i'm not particularly blaming it. pointless isn't exactly a critical tool either :p
13:26:34 <drigz> the reason i tried it is because it seems like a nasty corner case
13:26:58 <drigz> and i'd been wondering how haskell knew if (-) ought to be the unary or binary form
13:27:14 <sorear> > \fix -> let a = 2 in a
13:27:23 <sorear> @pl \mix -> let a = 2 in a
13:27:25 <sjanssen> @seen dons
13:27:25 <sorear> @pl \fix -> let a = 2 in a
13:27:39 <sjanssen> @botsnack
13:27:39 <SamB> @bo
13:27:39 <lambdabot>  Add a type signature
13:27:44 <lambdabot> const 2
13:27:52 <lambdabot> dons is in #haskell-soc and #haskell. I last heard dons speak 9h 30m 37s ago.
13:27:53 <lambdabot> ($ const 2)
13:27:54 <lambdabot> :)
13:27:54 <lambdabot> :)
13:28:10 <sjanssen> @flush
13:28:14 <jcreigh> Doesn't it assume unary, and that's why we have subtract?
13:28:19 <sorear> @part #haskell
13:28:31 <drigz> subtract is flip (-), isn't it?
13:28:36 <drigz> > (-) 2 1
13:28:44 <lb>  1
13:28:45 <drigz> > subtract 2 1
13:28:54 <lb>  -1
13:28:55 <sorear> lb is going to seriously lag until it is done connecting
13:28:59 <sorear> it IS an irc client
13:29:03 <drigz> @type (-)
13:29:12 <lb> forall a. (Num a) => a -> a -> a
13:29:14 <drigz> sorear: connecting?
13:29:25 <nominolo> :t subtract
13:29:29 <sorear> drigz: right. 2 seconds per channel joined
13:29:34 <lb> forall a. (Num a) => a -> a -> a
13:29:35 <sorear> drigz: server flood control
13:29:40 <sorear> @botsnack
13:29:42 <nominolo> @src subtract
13:29:46 <lb> :)
13:29:54 <lb> subtract x y = y - x
13:29:55 <sorear> @botsnack
13:29:58 <lb> :)
13:30:05 <sorear> @botsnack
13:30:05 <lb> :)
13:30:09 <sorear> @botsnack
13:30:09 <lb> :)
13:30:21 <nominolo> @ping
13:30:27 <jcreigh> :t (4-)
13:30:29 <lb> forall t. (Num t) => t -> t
13:30:33 <jcreigh> :t (-4)
13:30:35 <lb> forall a. (Num a) => a
13:30:43 <jcreigh> ah, okay.
13:31:43 <jcreigh> Thinking that (-4) should be a section for consistency is probably a sign of insanity, yes? :)
13:32:24 <nominolo> well, o'caml has ~
13:32:36 <jcreigh> nominolo: how does that work?
13:32:40 <nominolo> but in any case it's going to be confusing
13:32:53 <nominolo> it's negation
13:32:59 <nominolo> so, just a different symbol
13:33:12 <nominolo> therefore (-x) would be a section
13:33:45 <nominolo> but, anyone not aware of sections will confuse it in any case
13:34:02 <nominolo> e.g. (+x) == x in most languages
13:35:02 <nominolo> > :t let (~) x y = x - y in (~3)
13:35:03 <lb>  Parse error
13:35:25 <nominolo> > :t let (-^) x y = x - y in (-^3)
13:35:26 <lb>  Parse error
13:35:42 <nominolo> > :t let sub x y = x - y in (`sub` 3)
13:35:43 <lb>  Parse error
13:35:48 <nominolo> :t let sub x y = x - y in (`sub` 3)
13:35:50 <lb> forall a. (Num a) => a -> a
13:36:43 <nominolo> > let (~) x y = x - y in (~3)
13:36:44 <lb>  Parse error
13:36:47 <drigz> @type let x~y = x-y in (~3)
13:36:50 <lb> Pattern syntax in expression context: ~3
13:37:01 <drigz> @type let x~y = x-y in 3
13:37:04 <lb>     Occurs check: cannot construct the infinite type: t = t -> t1
13:37:04 <lb>     Probable cause: `y' is applied to too many arguments
13:37:06 <nominolo> > let (~:) x y = x - y in (~:3)
13:37:08 <lb>  <Integer -> Integer>
13:38:32 <sorear> remember, ~ is special syntax
13:38:38 <sorear> @pretty let x~y = x-y in 3
13:38:38 <lb>  i = let x ~y = x - y in 3
13:38:54 <sorear> defines a function 'x' with one argument 'y'
13:38:57 <nominolo> oh right
13:39:03 <sorear> in this case ~ is meningless
13:39:14 <nominolo> it's lazy pattern matching
13:39:37 <nominolo> needed for many MonadFix.mfix implementations ..
13:39:38 <ddarius> nominolo: No one actually writes +x
13:40:15 <sorear> ~x
13:40:21 <sorear> == x
13:40:34 <sorear> variables are already irrefutable!
13:40:49 <nominolo> ddarius: yes.  but what would you think if you came from another language that didn't have sections and you see (+3) ?
13:41:00 <bwerf> how can i make ghci remeber what i've defined so far, and continue it in a later session ?
13:42:01 <bringert> bwerf: I don't think it can do that. consider pasting your definitions into a .hs file, and load that next time
13:42:07 <kc5tja> Put your source in files.  :)
13:42:10 <bringert> but without let
13:42:18 <ddarius> nominolo: Probably that something is up because noone ever writes +x, furthermore context would suggest that something is up, e.g. I'd be like "wtf does map 3 mean?"
13:42:26 <bwerf> so no interactive coding ?
13:42:38 <sorear> bwerf: edit a file, and :r
13:42:47 <kc5tja> Not in the same sense as, say, BASIC.
13:42:56 <sorear> bwerf: if you use emacs, *edit* *edit* C-c C-l *edit* *edit*
13:43:08 <ddarius> You could define a command to take lines like :def f x = x * x and define them and write them to a file.
13:43:09 <nominolo> sorear: + C-c C-z
13:43:34 <SamB> bwerf: what language can you do that in anyway?
13:43:44 <ddarius> Admittedly, there is no good reason the Haskell repl's couldn't be as functional as MLs or the Lisps'.
13:43:45 <sorear> nominolo: never heard of that.
13:43:50 <bwerf> the one i use in my dreams :)
13:44:06 <nominolo> sorear: i meant C-c C-z
13:44:07 <SamB> you dream in common lisp?
13:44:09 <sorear> ddarius: play with HBI
13:44:18 <sorear> nornagon: nor that.
13:44:21 <bwerf> guess not
13:44:25 <sorear> nominolo: nor that.
13:44:25 <ddarius> sorear: I know tha hbi was more featureful.
13:44:27 <kc5tja> SamB: Lisp, BASIC, Forth (mostly), and the quintessential example, Smalltalk.
13:44:31 <sorear> nominolo: what does it do?
13:44:43 <ddarius> SamB: As sorear points out, even Haskel.
13:44:46 <ddarius> +l
13:44:53 <SamB> kc5tja: how can you save in Forth?
13:44:55 <sorear> nominolo: and what hath I wroght by never using it in the past?
13:44:59 <nominolo> sorear: switch to the haskell shell
13:45:14 <sorear> I thought you had to use BLOCKs and LOAD in forth.
13:45:23 <kc5tja> SamB: Most Forth systems include a "SAVE" or "TURNKEY" function which allows you to write out the Forth image as an executable to the host environment.
13:45:25 <SamB> and I don't remember being able to write programs in the textpads...
13:45:31 <sorear> which is exactly like save and C-c C-l
13:45:53 <sorear> nominolo: C-x o isn't good enough?
13:46:14 <nominolo> sorear: not if you have more than two buffers
13:46:25 <nominolo> or the haskell buffer is not visible at the moment
13:46:31 <nominolo> "C-c C-z runs the command switch-to-haskell"
13:46:32 <kc5tja> sorear: Blocks in Forth are used for managing overlays and so forth, and are useful for when you want to recompile whole collections of code with a single statement.  It's the normal method of coding in Forth.  But it's not the only way.
13:46:53 <drigz> sorear: i guess by HBI you don't mean heartless bitches international
13:47:23 <sorear> kc5tja: If you use SAVE, you can't edit the code later.
13:47:52 <petekaz> how do I make this more haskellish? f c1 c2 = compare (lookup c1) (lookup c2)
13:48:00 <sorear> kc5tja: are forthers immune from needing to interrupt a debugging session with sleep?
13:48:03 <kc5tja> sorear: (a) That wasn't the question asked, and (b) that's equally not strictly true.
13:48:09 * sorear wouldn't put it past them
13:48:25 <sorear> oh reah.
13:48:33 <sorear> drigz: Haskell B Interactive.
13:48:44 <sorear> drigz: augustss ' interactive haskell repl
13:48:47 <kc5tja> sorear: Forthers code and debug software interactively, in steps even more atomic than those of Haskell.
13:49:10 <drigz> sorear: yeah, i just search for hbi first and got that, before i added haskell
13:49:43 <sorear> drigz: it's >10 years old, reasonably dead, completely nonportabel, and still pummels GHCi in interactive features
13:49:49 <ddarius> petekaz: You don't other than choosing different names.
13:49:50 <drigz> petekaz: apparently some time in the future you will be able to do compare `on` lookup
13:50:28 <petekaz> I was trying uncurry . map (lookup $) stuff.
13:51:24 <nominolo> ?dict pummel
13:51:25 <lb> Supported dictionary-lookup commands:
13:51:25 <lb>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
13:51:25 <lb> Use "dict-help [cmd...]" for more.
13:51:36 <ddarius> petekaz: Not -everything- needs to use crazy higher order functions.
13:52:13 <nominolo> no m-w lookup?
13:53:09 <petekaz> ddarius: I'm a beginner ... just trying to force myself to think in this weird twisted language  :-)
13:53:31 <sorear> @botsnack
13:53:32 <lb> :)
13:53:50 <lambdabot> :)
13:53:51 <sorear> lambdabot: @part #haskell
13:54:07 <ddarius> petekaz: Read this: http://www.willamette.edu/~fruehr/haskell/evolution.html
13:54:07 <lb> Title: The Evolution of a Haskell Programmer
13:54:58 <qwr> :t lookup
13:55:01 <lb> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
13:56:05 <bwerf> wow, ghci has the most ungrokable error messages i've seen in a long time
13:56:48 <Laney> My god. petekaz, what does that function do?
13:56:57 <Laney> I can't figure out the type constraint in `f :: (Ord ([(a, b)] -> Maybe b), Eq a) => a -> a -> Ordering'
13:57:24 <sorear> Laney: that's not even valid Haskell
13:57:31 <Laney> I got that from ghci
13:57:39 <petekaz> Laney: I pass it as an arg to maximumBy
13:57:44 <sorear> Laney: you must have enabled extensions or something
13:57:59 <petekaz> it seems to work.
13:58:01 <Laney> sorear: Not as far as I know!
13:58:12 <sorear> Bah.
13:58:26 <Laney> Prelude> let f c1 c2 = compare (lookup c1) (lookup c2)
13:58:26 <Laney> Prelude> :t f
13:58:26 <Laney> f :: (Ord ([(a, b)] -> Maybe b), Eq a) => a -> a -> Ordering
13:58:26 <sorear> ghci enables extensions without you asking!!
13:58:36 <Laney> Ha, then I guess it may hve.
13:58:37 * sorear has just seen this happen
13:58:53 <petekaz> I should mention that lookup is a locally defined function.
13:58:59 <sorear> anyway, lookup is a pre-defined function which you probably don't want here.
13:59:03 <Laney> Oh haha
13:59:15 <petekaz> I didn't realize it was a builtin ... I'm a newbie.
14:00:02 <Laney> Fair enough. I'll ignore why it seems to go through then
14:00:14 <petekaz> ddarius: that link was great.
14:05:08 <bwerf> what are these "Peanos" that keep poping up in documentation
14:05:25 <ddarius> @google "Peano arithmetic"
14:05:26 <lb> http://en.wikipedia.org/wiki/Peano_arithmetic
14:05:26 <lb> Title: Peano axioms - Wikipedia, the free encyclopedia
14:07:20 <bwerf> ah right
14:08:37 <bwerf> i'm going to have troubles with all this 'math' then
14:09:24 <SamB> yep! maths are great!
14:10:02 <ddarius> bwerf: You shouldn't need to know what Peano arithmetic is to understand the vast majority of Haskell tools/libraries/documentation.
14:10:13 <fmardini> hi guys, i am having issues with installing GraphicsLib on osx, i recently bought the haskell school of expression and i am dying to get started
14:10:35 <fmardini> when i issue make -C lib/x11 i get some errors
14:11:14 <bwerf> math helped me flunk university
14:11:16 <sjanssen> @paste the errors
14:11:16 <lb> Haskell pastebin: http://hpaste.org/new
14:12:13 <hpaste>  fmardini pasted "installing graphicslib" at http://hpaste.org/1504
14:13:21 <nominolo> hm .. graham's number is pretty large .. you can't even expand it to use ^ only
14:13:40 <nominolo> at least not before the end of the universe
14:15:25 <monochrom> Everyone knows Peano arithmetic, under different disguises.
14:15:46 <SamB> bwerf: can you count apples?
14:16:07 <bwerf> nat = 0 | nat + 1
14:16:38 <SamB> pretty much
14:16:47 <monochrom> Yeah, you get the point. It's quite easy.
14:17:16 <monochrom> Eh, why is lb here?  Has lambdabot gone on strike again?
14:17:28 <SamB> > "Hi!"
14:17:30 <lb>  "Hi!"
14:17:52 <SamB> sorear: why is lambdabot not here?
14:18:18 <monochrom> The scrollup says lb is brought in and lambdabot brought out.  Any particular reason?
14:21:19 <sorear> this is why:
14:21:28 <sorear> @botsnack
14:21:29 <lb> :)
14:21:31 <lambdabot> :)
14:21:43 <sorear> it was much, much worse earlier.
14:21:58 <sorear> people were complaining, it was so bad
14:22:09 <bwerf> it was too slow ?
14:22:15 <sorear>  @type didn't work at all - it timed out every time
14:22:22 <sorear> yeah, lagging
14:22:27 <sorear> @botsnack
14:22:28 <lb> :)
14:22:32 <lambdabot> :)
14:22:50 <ddarius> :t 3
14:22:52 <lb> forall t. (Num t) => t
14:22:55 <drigz> > "> 3"
14:22:57 <lb>  "> 3"
14:23:07 <drigz> damn, they quote it
14:23:08 <sjanssen> fmardini: there is a GTK based implementation of SOE that might work better for you
14:23:13 <drigz> > print 3
14:23:15 <lb>  <IO ()>
14:23:20 <sorear> lambdabot: @part #haskell
14:23:24 <lambdabot> thread killed
14:23:31 <nominolo> @seen therp
14:23:32 <lb> therp is in #darcs, #gentoo-haskell and #haskell. I don't know when therp last spoke.
14:23:47 <fmardini> sjanssen: thanks, i will google it
14:24:15 <xerox> drigz, it also puts a space before the result :)
14:24:47 <sorear> drigz: also, IRC doesn't send stuff back to you
14:25:05 <sorear> @where+ zap @where zap
14:25:06 <lb> Done.
14:25:08 <sorear> @where zap
14:25:09 <lb>  @where zap
14:25:17 <sorear> @where+ zap ?where zap
14:25:17 <lb> Done.
14:25:19 <sorear> ?where zap
14:25:20 <lb> ?where zap
14:25:56 <drigz> sorear: yeah, i was hoping it would work with the two bots
14:26:02 <drigz> they would keep triggering each other
14:26:35 <sorear> @where+ zap ?where zap
14:26:35 <lb> Done.
14:26:41 <lb2> Done.
14:26:44 <sorear> lb2: @part #haskell
14:27:00 <sorear> @where+ zap ?where zap
14:27:00 <lb> Done.
14:27:05 <sorear> ?where zap
14:27:06 <lb> ?where zap
14:27:12 <lambdabot> Done.
14:27:13 <lambdabot> ?where zap
14:27:13 <lb> ?where zap
14:27:15 <lambdabot> ?where zap
14:27:15 <drigz> lambdabot didn't reply
14:27:15 <lb> ?where zap
14:27:15 <lambdabot> ?where zap
14:27:15 <lb> ?where zap
14:27:32 <bwerf> i hope they have a spamlimit
14:27:32 <lambdabot> ?where zap
14:27:33 <lb> ?where zap
14:27:35 <lambdabot> ?where zap
14:27:35 <lb> ?where zap
14:27:35 <lambdabot> ?where zap
14:27:35 <lb> ?where zap
14:27:37 <lambdabot> ?where zap
14:27:38 <lb> ?where zap
14:27:40 <lambdabot> ?where zap
14:27:40 <lb> ?where zap
14:27:57 <lambdabot> ?where zap
14:27:57 <lb> ?where zap
14:27:59 <lambdabot> ?where zap
14:27:59 <lb> ?where zap
14:28:02 <lambdabot> ?where zap
14:28:02 <xerox> bwerf, nope
14:28:02 <lb> ?where zap
14:28:08 <balodja> oh, wtf
14:28:13 <dfranke_>  /ignore is your friend.
14:28:13 <lambdabot> ?where zap
14:28:13 <lb> ?where zap
14:28:15 <bwerf> then this might get problematic
14:28:16 <lambdabot> ?where zap
14:28:17 <lb> ?where zap
14:28:17 --- mode: ChanServ set +o xerox
14:28:20 --- kick: lb was kicked by xerox (xerox)
14:28:45 <lambdabot> ?where zap
14:28:45 <lambdabot> ?where zap
14:28:50 <sorear> lambdabot: @part #haskell
14:28:53 <bwerf> lambdabot still lags behind, so it might still spam a few
14:29:00 <xerox> yeah
14:29:07 --- mode: xerox set -o xerox
14:29:35 <shachaf> Is there any reason my ghci session suddenly got vi keybindings?
14:29:47 <shachaf> I'm not objecting -- more wondering how to reproduce it... :-)
14:30:04 <bringert> shachaf: readline settings?
14:30:14 <shachaf> bringert: Yes, but how did it get set?
14:30:14 <dfranke_> mine has emacs keybindings...
14:30:18 <stefan_> blech.
14:30:21 <SamB> you accidentally typed the key-combo that switches readline over?
14:30:35 <shachaf> SamB: I didn't know there was one.
14:30:42 <stefan_> I would have stopped lb sooner, but sorear lagged at just the right moment to not see the spam :)
14:30:45 <SamB> shachaf: neither did I!
14:30:49 <shachaf> SamB: In bash it's "set -o vi"/"set -o emacs".
14:30:55 <bringert> shachaf: I'm guessing you didn't accidently change .inputrc or whatever its called?
14:30:56 <bwerf> do you own a pet ? they have a tendency to find these combos and sequences
14:31:04 <stefan_> I was trying to demo lambdabot's "no reply if nick suffix is "bot"" feature.
14:31:12 <stefan_> @botsnack
14:31:22 <stefan_> yes I am sorear
14:31:53 <monochrom> race conditions on irc
14:32:06 <Botje> perhaps the reply should have leading whitespace.
14:32:23 <timbot> hi!
14:32:31 <stefan_> it should, known issue with @where that nobody is motivated to fix.
14:33:11 * SamB thinks timbot is actually a name belonging to a Python person...
14:33:16 <bwerf> it just needs somethign to never give a reply that is a command
14:33:36 <SamB> (how do we know that a person who's name ends in bot is actually a bot?)
14:33:51 <monochrom> That's worse than undecidable :)
14:33:53 * stefan_ notes with curiousity that SamB, Sam__, and timbot have the same IP
14:33:55 <dfranke_> nostrademons, oh, hi.  I didn't realize you hung around here.
14:34:05 <nostrademons> hey.  yeah, I do, sometimes
14:34:11 <SamB> Sam__ is it now?
14:34:17 <nostrademons> tend to pay attention to #oasis more often
14:34:31 <stefan_> @botsnack
14:34:33 <dfranke_> what's #oasis?
14:34:36 <SamB> how did it get to the third nick!
14:34:58 <nostrademons> smaller channel of a bunch of guys that are interested in programming language design and weird languages
14:35:29 * stefan_ <3 netsplits
14:35:36 <nostrademons> mostly vincenz, psykotic, pkhuong, Cale, Riastradh, I think I've seen sorear in there...lotta familiar names from here
14:36:01 <stefan_> yeah, I've been there occasionally.
14:36:05 <stefan_> it
14:36:16 <stefan_> 's often noisier than #haskell...
14:36:43 <stefan_> @botsnack
14:36:44 <lb> :)
14:37:14 <nostrademons> it's also more of a social channel than #haskell, since it's not focused on any one particular language
14:37:15 <stefan_> aww, might as well make it official
14:37:54 <Botje> my name STARTS with bot! :[
14:42:14 <SamB> anyway, I was merely attempting to impersonate Tim Peters...
14:44:51 <BSP> is there no way to declare new data types at the ghci prompt?
14:45:04 <BSP> i cant seem to find it mentioned in the users guide
14:45:14 <sjanssen> BSP: you can't
14:45:22 <sjanssen> ghci only takes expressions
14:45:37 <BSP> i see, it makes sense i guess
14:45:43 <BSP> bit inflexible though :(
14:45:48 <BSP> ok, thanks!
14:48:49 <petekaz> I have a question about partion application (that is when I don't pass all the args to a function right?).
14:48:59 <BSP> "partial application"
14:49:06 <BSP> fire away :)
14:49:51 <hpaste>  petekaz pasted "partial app" at http://hpaste.org/1505
14:50:15 <petekaz> If I use the train function like this:
14:50:23 <petekaz>     let correct = train . tokens $ c
14:50:43 <monochrom> Again. :)
14:51:13 <petekaz> And I call 'correct' repeatedly, does my frequencyMap get constructed repeatedly?
14:51:32 <petekaz> I do not intend it to.
14:51:43 <petekaz> But memory goes crazy so I'm thinking it may.
14:52:06 <monochrom> Please remind me the precedences of . and $
14:52:46 <monochrom> frequencyMap will be reconstructed.
14:53:04 <petekaz> ahh ... that explains it.  But why is this?
14:53:16 <petekaz> I want to return a closure with this data already constructed.
14:53:24 <petekaz> So I can call correct many times.
14:53:29 <BSP> seems like a limitation of the optimiser?
14:53:52 <BSP> you could probably work around it by explictly constructing the frequency map and returning a function which just takes word
14:54:07 <qwr> petekaz: train words = \word -> ... ?
14:54:40 <monochrom> Yeah, train words = \word -> ...  is worth a try.
14:54:42 <petekaz> I thought train words word was the same thing, just nicer looking.
14:54:54 <petekaz> oh, you mean for the compilers sake
14:55:11 <monochrom> I wouldn't swear a code generator treats them same.
14:55:13 <BSP> but the expressions in where in that case are evaluated after all values have been recieved
14:55:33 <BSP> by doing it explicitly you can sort of lift those where expressions out of the lower function
14:56:04 <BSP> (if that makes any sense)
14:57:35 <petekaz> doesn't seem to be helping.
14:57:43 <petekaz> oh well.  I posted this to cafe.
14:58:09 <BSP> huh.. can you post your new code to hpaste?
14:58:53 <petekaz> The new code just has 'word' on the RHS now.
14:59:45 <monochrom> Oh, you are the poster! I'm just reading it. :)
14:59:54 <petekaz> BSP: oh, you were suggesting something else.  What do you mean?
15:00:12 <monochrom> I'll do some unsafe experiments.
15:00:19 <BSP> well, no, that might have the same effect.. it depends on the scope of where
15:00:53 <dfranke_> Is there any good way to mix literate haskell with haddock and not have to manually remove all the haddock markup from the literate output?
15:01:33 <sorear_> huh?
15:01:35 <BSP> petekaz: basically we just want to force the frequencyMap thunk to be created just once after the partial application of words
15:01:48 <sorear> @users
15:01:48 <lb> Maximum users seen in #haskell: 324, currently: 313 (96.6%), active: 14 (4.5%)
15:01:59 <petekaz> BSP: right, so how do I do that?
15:02:31 <qwr> let ?
15:02:50 <qwr> it would have quite explicit scoping
15:03:13 <BSP> yeah, that might do it..
15:03:25 <petekaz> so it sounds like my approach is just a bad idea as I am relying on the implementation.
15:04:04 <sorear> I'm back!
15:04:12 <BSP> i'm not sure this behaviour is specified in the report though..?
15:04:15 <ekidd> sorear: Hi, then! :-)
15:06:02 <BSP> is there any reason the ghc optimiser couldnt lift the frequencyMap thunk up through the lambdas..? it seems like a fairly glaring omission if it dosent, to my inexperienced eye..
15:06:25 <BSP> well, i guess it could be a space leak
15:07:11 <hyro> One of the exercises on the yaht tutorial suggest implementing a mult function using only addition. I was able to do this with subtraction: mult a b = a + mult a (b - 1). Is there actually a way to do this with addition?
15:07:22 <sjanssen> BSP: the report is very liberal on things like this
15:07:46 <sjanssen> petekaz: are you sure that you're not getting sharing?
15:07:51 <petekaz> no.
15:08:03 <qwr> hyro: sum (map (const x) [1..y])
15:08:12 <sorear> hyro: well, you can use n+k patterns ;)
15:08:12 <petekaz> I just see that memory goes through the roof 500Mb and more.
15:08:13 <drigz> hyro: b + (-1)? you could also use n+k patterns, but apparently they're really bad
15:08:25 <sorear> drigz: no, they aren't really bad
15:08:38 <DRMacIver> Why are n+k patterns claimed to be really bad?
15:08:38 <sjanssen> try adding a trace on the expression that creates frequencyMap
15:08:49 <kpreid> the problem with n+k patterns is that they aren't a general feature :-)
15:08:53 <Heffalump> DRMacIver: because they're ad-hoc
15:08:54 <DRMacIver> Ah
15:09:07 <drigz> i thought they hid computational complexity or something?
15:09:18 <sorear> no.
15:09:21 <Heffalump> not unless you consider (-) to have significant complexity
15:09:22 <hyro> My entire function is... mult 0 b = 0
15:09:22 <hyro> mult a 0 = 0
15:09:22 <hyro> mult a 1 = a
15:09:22 <hyro> mult 1 b = b
15:09:22 <hyro> mult a b = a + mult a (b - 1)
15:09:54 <Botje> hyro: you could work the other way around.
15:09:59 <DRMacIver> mult 1 (-1)
15:10:13 <qwr> > let mult = sum [ x | _ <- [ 1 .. y] in mult 5 6
15:10:14 <lb>  Parse error
15:10:17 <petekaz> Thanks for the help.  I need to run to dinner.  Maybe someone on the list will respond.
15:10:18 <qwr> > let mult = sum [ x | _ <- [ 1 .. y] ] in mult 5 6
15:10:20 <lb>   Not in scope: `y'
15:10:22 <hpaste>  monochrom pasted "how many times a local thunk is created" at http://hpaste.org/1506
15:10:26 <qwr> > let mult x y = sum [ x | _ <- [ 1 .. y] ] in mult 5 6
15:10:28 <lb>  30
15:10:54 <hyro> It's supposed to be a recursive function.
15:11:12 <qwr> hyro: sum is recursive ;)
15:11:15 <monochrom> That may be of interest to BSP petekaz
15:11:25 <drigz> qwr: if we're going to do that, we might as well go all the way:
15:11:54 <drigz> > let mult x y = length [ undefined | _ <- [1..x], _ <- [1..y] ]
15:11:54 <lb>  Parse error
15:12:06 <BSP> monochrom: thanks, i'm taking a look right now
15:12:16 <drigz> > let mult x y = length [ () | _ <- [1..x], _ <- [1..y] ] in mult 4 5
15:12:18 <lb>  20
15:12:30 <hyro> I'm learning... slowly. Not all the syntax makes since yet :)
15:12:30 <monochrom> I am actually shocked that -O is that smart. :)
15:13:17 <sjanssen> ghc++
15:13:19 <BSP> nice...
15:13:30 <BSP> i didn't know about "trace"
15:13:37 <BSP> how extremely useful
15:13:43 <DRMacIver> @pl let mult x y = length [ () | _ <- [1..x], _ <- [1..y] ]
15:13:44 <lb> (line 1, column 23):
15:13:44 <lb> unexpected "["
15:13:44 <lb> expecting variable, "(", operator, ";" or "in"
15:13:52 <DRMacIver> Hm
15:14:02 <DRMacIver> Doesn't handle list comprehensinos?
15:14:05 <kpreid> DRMacIver: pl doesn't understand list comprehensions
15:14:10 <monochrom> I understand the psychology of computers. :)
15:14:12 <kpreid> pl doesn't understand many things
15:14:23 <DRMacIver> How tragic
15:14:31 <sjanssen> pl uses a pseudo-Haskell parser
15:14:33 <drigz> ?pl \x y -> length [ () | _ <- [1..x], _ <- [1..y]]
15:14:33 <lb> (line 1, column 16):
15:14:34 <lb> unexpected "["
15:14:34 <lb> expecting variable, "(", operator or end of input
15:15:00 <kpreid> @pl mult x y = length (do [1..x]; [1..y]; ())
15:15:01 <lb> (line 1, column 10):
15:15:01 <lb> unexpected "="
15:15:01 <lb> expecting variable, "(", operator or end of input
15:15:04 <qwr> > sum (repeat 3 5)
15:15:05 <lb>  Couldn't match expected type `t -> [a]'
15:15:05 <dfranke_> what does @pl do?
15:15:06 <monochrom> I know how to translate comprehension to do.
15:15:15 <kpreid> @. pl undo mult x y = length (do [1..x]; [1..y]; ())
15:15:15 <lb> (line 1, column 21):
15:15:16 <lb> unexpected "{"
15:15:16 <lb> expecting variable, "(", operator or ")"
15:15:33 <kpreid> @pl mult x y = length ([1..x] >> [1..y] >> return ())
15:15:34 <lb> mult = (length .) . flip flip return . ((>>) .) . (. enumFromTo 1) . (>>) . enumFromTo 1
15:15:34 <shachaf> > let mult x y = length ([1..x] >> [1..y] >> return undefined) in mult 4 5
15:15:36 <lb>  20
15:15:40 <drigz> dfranke_: rewrites a function in a manner that doesn't require arguments, just composition of other functions
15:15:56 <sjanssen> @. pl undo \x y -> length (do [1..x]; [1..y]; ())
15:15:57 <dfranke_> ah, ok.
15:15:57 <lb> ((length . (>>)) .) . (. enumFromTo 1) . (>>) . enumFromTo 1
15:16:02 <kpreid> dfranke: for some code it is a great improvement; for others it is quite foul
15:16:02 <qwr> > sum (replicate 3 5)
15:16:04 <lb>  15
15:16:08 <Laney> So-called point-free or pointless style
15:16:14 <Laney> afaik
15:16:32 <kpreid> qwr: nice
15:16:52 <kpreid> @pl \x y -> sum (replicate x y)
15:16:53 <lb> (sum .) . replicate
15:16:57 <monochrom> Pointfree is nice only when you have a library of operators designed for pointfree.
15:17:16 <dmwit> > length ([1..3] >> [1..5])
15:17:18 <lb>  15
15:17:21 <dmwit> =)
15:17:27 <monochrom> For example +, >, == are not quite designed for pointfree.
15:18:17 <sili> does haskell have a 'type' type?
15:18:24 <dfranke_> by the way... tangentially related to point-free programming:
15:18:35 <dmwit> sili: They're called kinds, and they can't be passed around for the most part.
15:18:36 <monochrom> @doc Data.Typeable
15:18:37 <lb> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html
15:18:48 <dmwit> sili: Although you can pass around data constructors.
15:18:55 <monochrom> Data.Typeable may or may not be what sili is looking for.
15:18:59 <dfranke_> suppose I have a declaration, data Foo a b = ...
15:19:35 <dfranke_> If I want Foo Int b to be an instance of, say, Monad, I can just write instance Monad (Foo Int).
15:20:22 <roconnor> Not without haskell extensions
15:20:23 <dfranke_> but unless I'm missing something really obvious, there's no easy way to do that if I want to specify a monomorphic type for b instead of a.
15:20:32 <sili> dmwit: that seems to make sense. i was trying to figure out how static typing can be supported if I wanted to return a 'kind' and instantiate a type with that
15:20:46 <monochrom> That's right dfranke_
15:20:47 <roconnor> dfranke_:  the haskell98 way around it is to make Foo Int a newtype
15:21:25 <mauke> why does haskell's process api hate me
15:21:45 <sili> mauke: tough love
15:22:02 <dfranke_> so I guess I'm wishing for a compile-time combinator library of sorts to turn Foo a b interchangable with Bar b a.
15:23:01 <mauke> runProcess wants Handles. createPipe gives me Fds. fdToHandle enables non-blocking mode.
15:23:36 <mauke> but I want the process to use blocking I/O
15:24:49 <mauke> now I'm looking how to do it manually, and executeFile is broken
15:25:00 <mauke> it doesn't let me set argv[0] of the program
15:25:42 <sjanssen> you can't do that portably
15:25:52 <mauke> yes, I can
15:25:56 <mauke> just call execv
15:26:14 <monochrom> Use runProcess.  Then create thread to read one of the handles; it will block.
15:26:22 <sjanssen> does that work in Windows?
15:26:35 <mauke> irrelevant; this is System.Posix.Process
15:26:39 <sjanssen> oh
15:27:04 <mauke> monochrom: er, huh?
15:27:09 <mauke> why do I need a thread?
15:27:25 <monochrom> because reading blocks.
15:27:43 <qwr> mauke: you could use foreign api
15:27:50 <mauke> qwr: yeah
15:27:58 <mauke> monochrom: you're not making sense
15:28:09 <monochrom> Neither are you, to be frank and blunt.
15:28:25 <DRMacIver> Frank *and* blunt? Oh my.
15:28:37 <mauke> I want to do the equivalent of `` in sh
15:29:12 <monochrom> If you want the parent process to block waiting for data from child, you don't need a second thread for reading, of course.
15:29:29 <mauke> the called program expects stdout to be in blocking mode
15:29:42 <drigz> mauke: is this what you want? http://cgi.cse.unsw.edu.au/~dons/blog/2007/03/10#programmable-semicolons it links to a small 'Process' module
15:29:44 <lb> Title: Haskell hacking, http://tinyurl.com/ywdjsr
15:30:16 <drigz> specifically, this: http://www.cse.unsw.edu.au/~dons/code/cpuperf/Process.hs
15:31:20 <sili> can anyone recommend good reading on weak vs. strong or static vs. dynamic typing? I know what they are, but I want to know more about the implications of each in terms of pragmatics
15:31:51 <mauke> drigz: that code looks like it doesn't work
15:31:56 <Sam__> C has weak static typing...
15:32:15 <qwr> mauke: runInteractiveProcess might be right thing?
15:32:17 <monochrom> mauke: Oh I see, sorry, I thought you were complaining about runInteractiveProcess.  You should use runInteractiveProcess, actually.
15:32:21 <mauke> I mean hGetContents is lazy, i.e. it doesn't actually read anything
15:32:28 <dfranke_> sili, I think the best way to learn that is just to use them.
15:32:54 <mauke> that means the program can block on writing data to the pipe
15:33:01 <monochrom> runProcess is really just for things like "xxx > yyy".
15:33:05 <mauke> in which case waitForProces pid deadlocks
15:33:12 <dfranke_> learn Haskell, Lisp, Java, and C and you'll get the picture.
15:33:29 <sili> dfranke_: i'm looking for other opinions :D
15:33:52 <DRMacIver> TAPL is probably a good choice.
15:33:59 <mauke> monochrom: runInteractiveProcess doesn't let me pass my own stdin/stderr
15:34:09 <mauke> where "my own" = /dev/null
15:34:37 <monochrom> You can fake /dev/null.
15:34:57 <dfranke_> well, here's my two cents on it: static typing is just a nuisance unless it's done really, really well.  Haskell is the only language I know that passes that threshold.
15:35:18 <dfranke_> (ML doesn't)
15:35:20 <mauke> monochrom: by spawning an extra thread that just reads from the process's stderr?
15:36:09 <kilimanjaro> "correctness" is a nuisance
15:36:11 <monochrom> stderr I have to think about.  To fake feeding /dev/null to the child's stdin, just close that handle.
15:36:21 <mauke> yeah, that's the easy part
15:37:50 <qwr> forkIO (hGetContents stderr >>= length)
15:38:31 <dfranke_> static typing's potential has yet to be exhausted, whereas designing a dynamic typesystem is a lot easier.  I think Lisp already has it perfect.
15:39:08 <qwr> dynamic typeing still sucks
15:39:28 <qwr> i'm probably too sloppy coder for it
15:39:38 <mauke>   GHC Note: in order to call waitForProcess without blocking all the other threads in the system, you must compile the program with -threaded.
15:39:48 <mauke> great, and -threaded seems to have issues with gtk2hs
15:39:57 <dfranke_> dynamic typing is the Right Thing for throwaway progarms and rapid prototyping.
15:40:38 <mauke> no, static typing is the right thing for rapid prototyping
15:40:50 <mauke> especially if you have no idea what you're doing
15:41:10 <qwr> anytime i write something in dynamic language that is not completle trivial i have to debug bunch of typos and thinkos
15:41:10 <Heffalump> I think it may depend on how big the thing you are prototyping is.
15:41:24 <Heffalump> For something small dynamic typing is probably better as you can keep it all in your head.
15:41:34 <monochrom> mauke: Perhaps fdToHandle is not that bad.  Although the fd is made non-blocking, the handle may still be blocking.
15:41:36 <pstickne_> also the tools you use make a huge difference...
15:42:04 <mauke> monochrom: the fd is the only thing that matters
15:42:04 <Philippa> Heffalump: depends on the complexity level in your small, but I guess you can redefine 'small' appropriately
15:42:16 <dfranke_> I certainly wouldn't want static typing for writing a shell script.
15:42:28 <monochrom> I'm going to do an experiment.
15:42:45 <Philippa> dfranke: I would, I'd just want a good "anything, I don't care!" type handy
15:43:02 <qwr> compilers like ghc may have sometimes weird messages, but usually it takes only few moments to understand them
15:43:25 <dfranke_> Philippa, but if you don't have manifest type information that's useless.
15:43:26 <qwr> whereas some null for car/cdr in scheme is more fun
15:43:34 <dfranke_> Philippa, just like you can't do anything in Haskell with something of type 'a'.
15:43:37 <Philippa> dfranke: annotations are your friend
15:43:46 <Philippa> a isn't "anything, I don't care!"
15:43:54 <SamB_XP> Philippa: would this type be called Duck?
15:43:59 <Philippa> not when you're holding it
15:44:12 <Philippa> SamB_XP: and functions on it might be called Duckups
15:45:36 <kilimanjaro> qwr, if you don't know how to use a debugger then it isn't going to be of much help for solving problems. The same complaint is made about type errors by novices using GHC... that the error messages are confusing or unhelpful.
15:45:47 <shapr> benja_: Hey, did you ever hear anything about soft refs?
15:46:03 <qwr> kilimanjaro: what's kawa debugger? ;)
15:46:11 <hpaste>  monochrom pasted "this does block, try it" at http://hpaste.org/1507
15:46:20 <monochrom> mauke: try that
15:46:21 <qwr> kilimanjaro: jdb?
15:46:39 <kilimanjaro> qwr, I don't use kawa so I don't know anything about it
15:46:54 <shapr> dcoutts: I like your idea for lazy reading of files with soft refs.
15:47:04 <kilimanjaro> If you are claiming that there are dynamically typed languages with poor tool support, then I think we are in agreement :)
15:47:07 <mauke> monochrom: that's from inside haskell
15:47:08 * shapr is catching up on -cafe
15:47:20 <monochrom> Yes. Are you writing a haskell program?
15:47:24 <mauke> yes
15:47:46 <mauke> a haskell program that runs an external program
15:47:47 <monochrom> I also look at my cpu load monitor while the program blocks.  No activity.
15:48:09 <monochrom> Are you asking me to write your code for you?
15:48:27 <sorear> if you can avoid it, do not bother with haskell's process libs
15:48:38 <sorear> use perl, or /bin/sh even
15:48:55 <mauke> no, right now I'm thinking about how to test for the behavior I'm afraid I'm going to see
15:49:13 <sorear> to clarify, don't use haskell *just* to script.
15:49:21 <mauke> (hmm, a strict hGetContents would be nice)
15:49:33 <monochrom> Use createPipe, get fd.  One of the fd's is just like my use of stdInput in my example.  The rest is history.
15:49:50 <Heffalump> mauke: can't you just deepSeq the result?
15:49:50 <qwr> mauke: it exists. for stict bytestrings
15:49:57 <sorear> if you've got lots of fun tree processing to do as well - then by all means use haskell
15:50:01 <mauke> blargh, I don't want bytestrings
15:50:28 <mauke> sorear: actually, I just want a simple window and gtk2hs looks ok for that
15:51:16 <monochrom> Anyway you began with the plan of createPipe, runProcess, fdToHandle.  Then you're put off by the sentence of fdToHandle saying "will non-block".  I ask you to actually test it.
15:51:46 <mauke> createPipe, fdToHandle, runProcess actually
15:51:49 <mauke> yeah, doing that now
15:54:57 <monochrom> It's taking me too much time today to refute complaints about haskell-related things.
15:56:29 <sjanssen> the non-blocking issue is well known
15:56:31 <kilimanjaro> monochrom, if you don't pick things up we may have to get rid of you
15:56:54 <DRMacIver> monochrom: So, I hear Haskell can't handle mixed type lists??
15:57:05 <sjanssen> @slap DRMacIver
15:57:06 * lb slaps DRMacIver
15:57:25 <mauke> wait, why does runProcess take Maybe Handles?
15:57:48 <SamB_XP> mauke: it can use the existing handles also, I guess?
15:57:57 <mauke> I hope so :-)
15:58:09 <DRMacIver> sjanssen: Ow.
15:59:31 <monochrom> For that question, a look at the source code may reveal the answer readily.
16:00:19 <monochrom> @src maybe
16:00:19 <lb> maybe n _ Nothing  = n
16:00:19 <lb> maybe _ f (Just x) = f x
16:00:40 <sorear> DRMacIver: mixed type lists are easy!  state your requirements exactly and a solution will appear.
16:02:32 <DRMacIver> sorear: I might have been trolling slightly... :)
16:03:04 <sorear> DRMacIver: I might have been bragging slightly... :)
16:03:58 <DRMacIver> Gosh, someone bragging about the expressive power of Haskell? That doesn't happen does it?!
16:04:05 <dmwit> :t first
16:04:08 <lb> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
16:04:18 <monochrom> The source seems to say that if you give Nothing, the parent's stdin/out/err handle is passed on to child.
16:04:20 <sorear> More a case of bragging about my haskell skillz.
16:04:44 <monochrom> Funny thing is, parent's handle is not closed.
16:05:25 <DRMacIver> Oh, just the usual class of IRC bragging then. How dull. :)
16:06:18 <monochrom> Mixed hype list is discouraged in Haskell.
16:06:31 <sorear> Hype is discouraged in Haskell, period.
16:07:01 * sorear uses associated type families for the first time
16:07:02 <DRMacIver> Unless it's about the benefits of purity, the awesome type system and how monads are the most expressive things evar. ;)
16:08:23 <mauke> great, runProcess really is buggy
16:08:32 <mauke> only in a different way
16:09:46 <mauke> oh, and the non-blocking problem is triggered by trying to write >65536 bytes into the pipe
16:10:02 <dmwit> Err?
16:10:06 <dmwit> ?type (***)
16:10:08 <lb> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
16:10:16 <dmwit> Why doesn't that work in a private message?
16:10:44 <dmwit> <dmwit> ?type (***)
16:10:44 <dmwit> <lambdabot> thread killed
16:11:12 <sorear> because lambadbot is b0rken
16:11:21 <sorear> you will notice I kicked her out
16:11:27 <sorear> you should /msg lb
16:11:37 <dmwit> Oh.
16:11:43 <dmwit> ta
16:12:10 <dons> oh, what happened, sorear ?
16:12:21 <sorear> dons: lambdabot is really, really slow
16:12:27 <sorear> dons: >5 second lag
16:12:31 <dons> hmm
16:12:32 <sorear> dons: and ?type is timing out
16:12:34 <dmwit> sorear: Uh, can lb do private messages?
16:12:44 <sorear> dmwit: /mode dmwit +6
16:13:00 <dons> hmm, load averages: 3.29, 3.81, 3.95
16:13:05 <sorear> I ought to pick a better nick that isn't already registered :)
16:13:30 <SamB_XP> dons: oh, that test suite on the "list" package has too many places that have to change when you add/remove a function in Data.Stream...
16:13:31 <sorear> as I suspected ... load?
16:13:40 <jcreigh> dons: how many CPUs in that box?
16:13:41 <sorear> dons: is that all from nobench?
16:13:47 <dmwit> Are you sure it's +6?
16:13:49 <dons> SamB_XP: sure. :-)
16:13:54 <sorear> dmwit: positive.
16:13:54 <dmwit> FreeNode complains.
16:13:59 <dons> sorear: afaik, nothing should be running on the box.
16:14:08 <dons> sorear: but there were around 10 ghc processes going.
16:14:10 <SamB_XP> dons: you might at least try using #include to cut it in half
16:14:22 <mauke> monochrom: http://rafb.net/p/suRE1B72.html
16:14:23 <lb> Title: Nopaste - No description
16:14:23 <sorear> dmwit: what's the error?
16:14:31 <dons> sorear: i think we could hvae lambdabot rejoin now
16:14:32 <SamB_XP> or maybe not really in half...
16:14:34 <DRMacIver> dmwit: You're probably not set to be able to see messages from unregistered users.
16:14:40 <dmwit> Unknown MODE flag
16:14:42 <sorear> dons: what was going on?
16:14:54 <dons> a lot of (unexplained) ghc-6.6 processes were running
16:15:00 <sorear> dmwit: I think that's a client bug, freenode definitely supports +6
16:15:01 <SamB_XP> but at least keep you from having identical properties in two files
16:15:10 <SamB_XP> dons: also, you should test the test suite more often!
16:15:15 <sorear> wow, that was *fast*
16:15:17 <sorear> > 2 + 2
16:15:19 <lambdabot>  4
16:15:19 <lb>  4
16:15:24 <sorear> @botsnack
16:15:25 <lb> :)
16:15:25 <lambdabot> :)
16:15:29 <sorear> lb: @quit
16:15:35 <SamB_XP> to make sure it at least doesn't have any *name errors*
16:15:44 <sorear> dons++
16:15:45 <dons> SamB_XP: thanks. yes.
16:15:46 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
16:15:57 <dmwit> Heh, I did /msg nickserv set unfiltered on, and it replied mode +6 dmwit. =P
16:16:06 <dons> SamB_XP: as you could probably guess, we got a bit busy while writing the paper to keep the entire testsuite up to date.
16:16:24 <SamB_XP> ideally you would automate it
16:16:35 <sorear> dons: btw, I read the polymer paper.
16:16:44 <kilimanjaro> Write haskell code to write papers for you
16:16:45 <mauke> monochrom: for comparison, perl -wle 'my $x = `./iot </dev/null`; print for "got ${\length $x} bytes", $?' produces the expected output
16:17:05 <SamB_XP> kilimanjaro: I meant the test suite
16:17:07 <monochrom> mauke: Oh, darn. Sorry, my bad.  I would, after this, resort to runInteractiveProcess and create a thread on the side that simply says "consume child's stderr".
16:17:22 <sorear> mauke: if you can do it in one line of perl, you shouldn't even TRY to do it in haskell
16:17:23 <SamB_XP> so they don't have like four to ten files that all have to say "blah"
16:17:23 <dmwit> ?type (***)
16:17:32 <sorear> mauke: languages have different niches.  cope.
16:17:37 <mauke> sorear: I don't know how to GUI in Perl
16:17:40 <lambdabot> thread killed
16:17:47 <sorear> dons: ps?
16:17:59 <dons> yep. too many ghc processes.
16:18:02 <dons> what did you do?
16:18:28 <SamB_XP> dons: I wrote what I hope is a "good producer" for tails...
16:18:29 <dons> a type-bsaed dos?
16:18:30 <sorear> I think dmwit broke it.
16:18:37 <dmwit> haha
16:18:38 <qwr> mauke: qtruby?
16:18:45 <sorear> it failed the last time after dmwit ran the same command!
16:20:04 <sorear> dmwit: stop asking for the type of (***) please
16:20:04 <sorear> ;)
16:20:04 <dmwit> =D
16:20:04 <mauke> qwr: I know neither qt nor ruby
16:20:04 <qwr> mauke: or run the perl command from haskell ;)
16:20:04 <dons> i'm not sure why that would be the issue
16:20:04 <sorear> dmwit: iirc, it's Arrow a => a b c -> a d e -> a (b,d) (c,e)
16:20:04 <sorear> now stop bugging lambdabot :)
16:20:04 <SamB> dons: it has to run ghci to check the type, right?
16:20:04 <dmwit> Okay, thanks, I will. ;-)
16:20:04 <dons> sure. but i don't see why that would be the issue.
16:20:04 <sorear> @botsnack
16:20:04 <lb> :)
16:20:04 <lambdabot> :)
16:20:04 <sorear> @botsnack
16:20:04 <lb> :)
16:20:04 <lambdabot> :)
16:20:04 <mauke> qwr: uh... and how am I going to run the perl program from haskell if runProcess is broken?
16:20:08 <sorear> @type (***)
16:20:08 <SamB> dons: what happens when there are too many processes?
16:20:10 <lb> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
16:20:23 <dmwit> Hypocrite!
16:20:23 <lambdabot> thread killed
16:20:24 <sorear> @botsnack
16:20:25 <lb> :)
16:20:25 <lambdabot> :)
16:20:27 <sorear> @botsnack
16:20:27 <dons> bizarre
16:20:27 <lb> :)
16:20:28 <lambdabot> :)
16:20:32 <sjanssen> @type id
16:20:35 <lb> forall a. a -> a
16:20:37 <dmwit> ?botsnack
16:20:38 <lb> :)
16:20:38 <sorear> ok, that didn't trigger bot death
16:20:40 <dons> yes, but the ghc process is still running
16:20:47 <lambdabot> thread killed
16:20:48 <lambdabot> :)
16:20:55 <mauke> @type
16:20:56 <SamB> dons: had you killed many of them just now?
16:20:58 <lb> [1 of 2] Compiling ShowQ            ( scripts/ShowQ.hs, interpreted )
16:20:58 <lb>  
16:20:58 <lb> scripts/ShowQ.hs:46:0:
16:21:00 <sorear> dons: hmm.  did you recompile the bot recently, change versions, etc?
16:21:11 <lambdabot> thread killed
16:21:18 <mauke> wtf
16:21:22 <dons> can we investigate this later? i need breakfast.
16:21:36 <sorear> well, lb isn't having any trouble.
16:21:43 <sorear> unexplained env differences :(
16:21:47 <sorear> lambdabot: @part #haskell
16:22:08 <hpaste>  SamB pasted "tails for streams" at http://hpaste.org/1508
16:23:39 <drigz> SamB: you shouldn't need that INLINE next, since it's only called from one place
16:23:50 <hpaste>  SamB annotated "tails for streams" with "... and for lists" at http://hpaste.org/1508#a1
16:24:04 <SamB> dons: in between your eggs and your investigation, can you look at that and tell me what you think?
16:24:10 <SamB> or maybe you'd prefer a patch?
16:24:43 <dons> @type (***)
16:24:46 <lb> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
16:24:56 <dons> weird.
16:25:06 <lambdabot> thread killed
16:25:07 <dons> lambdabot: @part #haskell
16:26:10 <benja_> shapr: nope, no reply except dcoutts'
16:28:14 <qwr> mauke: seems to work for me... runInteractiveProcess "/bin/ls" [] Nothing Nothing >>= \(inp, out, err, _) -> hClose inp >> forkIO (hGetContents err >>= putStr) >> hGetContents out >>= putStr . map toUpper
16:29:13 <qwr> the waitForProcess that wants threaded runtime would avoid zombies
16:29:55 <qwr> but i think you could have signal handler in haskell too for that
16:33:16 <mauke> it's the wrong thing to do
16:33:44 <mauke> I just want to redirect stderr to /dev/null; that shouldn't require another two file descriptors and a thread
16:34:20 <sorear> How complicated is the gui you want to do?
16:34:48 * SamB wants a POSIX-2-hs lexicon
16:35:01 <SamB> I want to look up dup2 in it
16:35:26 <mauke> sorear: extremely simple
16:35:31 <mauke> I just need a titlebar
16:35:49 <sorear> mauke: look at xmessage then
16:35:49 <mauke> dupTo, in System.Posix.IO
16:35:50 <qwr> dup2 wont affect other running process
16:36:17 <mauke> sorear: that doesn't look interactive
16:36:31 <sorear> it has a titlebar though!
16:36:55 <SamB> qwr: which is why you do it in the forked process!
16:37:29 <SamB> dup2 is the C version of >&
16:37:59 <qwr> SamB: i know. runInteractiveProcess don't give you chance to hack in the forked process
16:38:14 <SamB> qwr: which is why you use the exec* equivalent...
16:38:42 <mauke> why does forkIO want IO () (and not IO a)?
16:39:40 <SamB> mauke: it is really really interested in that () result!
16:41:06 <qwr> SamB: i understood that mauke's problem was that haskell exec* wrappers were broken
16:41:20 <mauke> no, exec* is almost usable
16:41:35 <mauke> it's still broken of course, but that doesn't matter for this program
16:42:10 <SamB> whats broken?
16:42:30 <hpaste>  mauke pasted "readPipe" at http://hpaste.org/1509
16:42:40 <mauke> SamB: it doesn't let you specify argv[0]
16:42:41 <sorear> mauke: just use xmessage or the like to display your simple, titlebar-only gui
16:42:49 <mauke> sorear: and how do I update the titlebar?
16:42:50 <SamB> mauke: ... oh.
16:42:50 <sorear> you have no excuse to be using haskell for this?
16:43:00 <SamB> well, that doesn't sound too too serious ;-)
16:43:02 <sorear> er ...
16:43:30 <mauke> readPipe is how I'm currently reading program output
16:44:06 <sorear> mauke: main = do window <- newGUI ; mapM_ (setTitleBar window) . lines =<< getContents
16:44:20 <sorear> mauke: then program | displayit
16:45:54 <mauke> is newGUI a real function?
16:46:45 <sorear> no.
16:47:12 <mauke> hmm, I'd still have to write program
16:55:57 <mauke> ok, basic functionality works
17:11:38 <sorear> code snippet of the day: mult m1 = M . liftA (unV . apply m1 . V) . unM
17:12:37 * sorear is back to working on his strongly typed linear algebra lib
17:13:23 <mauke> whoa, why unV . f . V?
17:13:45 <sorear> *Vector> :t unV
17:13:45 <sorear> unV :: forall k a. V k a -> Tu k a
17:13:47 <mauke> why does apply m1 need a wrapped A?
17:14:01 <sorear> apply applies a matrix to a vector.
17:14:08 <sorear> a vector is a wrapped tuple
17:14:15 <sorear> a matrix is a wrapped tuple of tuples
17:14:39 <mauke> ah
17:14:52 <sorear> so all those newtype constrs are just to turn a matrix into a vector of vectors.
17:15:11 <sorear> if I didn't tag things, it would be : mult = liftA . apply
17:15:23 <sorear> if I used lists, mult = map . apply
17:15:49 <sorear> which has got to be among the shortest defns of matrix multiplication in the world :)
17:19:49 <SamB_XP> how about mult = fmap . apply?
17:20:25 <sorear> point.
17:20:58 <sorear> apply m v = sum (zipWith smul v m)
17:21:07 <sorear> if you can get the overloading right
17:23:32 <dolio> @type \p f -> liftM2 (>>) (guard . p) (return . f)
17:25:28 * sorear wishes (*) and (+) were distinguishable by the type system
17:25:36 <lb> forall a b (m :: * -> *). (MonadPlus m) => (a -> Bool) -> (a -> b) -> a -> m b
17:25:42 <sorear> Gr.. I hate the lagginess of my connection :(
17:25:50 <dolio> Wow.
17:26:06 <sorear> bots suffer from net lag too!
17:26:08 <sorear> dolio: ?
17:26:18 <dolio> :) 2 minutes.
17:26:42 <sorear> 2 minutes is pretty minor by Cox's standards
17:27:31 <jcreigh> that's awful
17:44:03 <dons> sjanssen: around?
17:44:47 <sjanssen> dons: yep
17:45:11 <sorear> dons: how lazy are lazy bytestrings?  if I have a 32 byte chunk followed by _|_, what can I safely do?
17:46:21 <dons> you can't see the chunk boundaries
17:46:38 <dons> sjanssen: do you have any stub for the web page?
17:46:43 <dons> if not, i'll do that today.
17:46:49 <sjanssen> sorear: you can call tail 31 times
17:47:07 <dons> including a contrib section for things like DR's Mosaic module
17:47:14 <matthew-_> dons: any chance you could make bytestring implement Language.Haskell.TH.Syntax.Lift ? (mmm, yes, that would require extending Exp. I guess not then.)
17:47:22 <dons> hmm. and depneding on package TH
17:47:33 <dons> so i guess not :-)
17:47:43 <sorear> matthew-_: no, it can be done without Exp extending
17:47:48 <matthew-_> really?
17:48:23 <matthew-_> currently I'm ending up with many 1.5MB String literals due to using TH to inline binary files.
17:48:42 <sjanssen> dons: I haven't done anything with the web page
17:48:43 <matthew-_> which ghc isn't particularly nippy about dealing with...
17:49:20 <petekaz> dons: what was the expected skill level of the audience for that blog entry of yours on shell scripting.  I tried to re-read it again, but get lost starting at the error section.
17:50:37 <matthew-_> sorear: ahh, yes of course, it can be. But for it to be useful to me, it'd have to extend Exp otherwise I couldn't use values of ByteString in splices.
17:51:04 <dons> petekaz: its supposed to be a mixture of 'some haskell experience' and 'willing to go all the way' :-)
17:51:13 <dons> so i don't expect everyone reading to follow everything
17:51:19 <matthew-_> (err, I guess the implementation of lift would have to convert to a string, which is what I'm doing anyway...)
17:51:31 <dons> but i did want to present advanced practices
17:51:55 <petekaz> ok, so I guess I don't have to feel completely inept.
17:52:03 <sorear> matthew-_: ah, I see we ARE missing StringPrimL.  nm then.
17:52:46 <petekaz> I hope Simon chooses to present that at oscon as a tutorial to haskell.  I presume he'd have to slow the pace down a bit for that audience.
17:53:07 <petekaz> Then I might be able to grok it if someone records the presentation.
17:54:01 <sorear> dons: when you say 'you can't see the chunk boundaries', I'm not sure I understand.
17:54:14 <sorear> dons: my idea is using lazy bs to parse a network connection
17:54:51 <sorear> getContents is confirmed lazy enough - I wonder if any of the list ops will try to rechunk on me
17:55:10 <matthew-_> sorear: there is a RULE in the .HS.Sytnax.Lift instances for String which is meant to stop Strings being seen as [Char] an enforce the use of litE.stringL
17:55:40 <sorear> matthew-_: I fail to see the relevance of this comment.
17:55:51 <dons> sorear: nope. they shouldn't try to rechunk
17:55:59 <sorear> the best way to make a bytestring is B.unsafePackAddress 3 "abc"#
17:56:01 <dons> you should happily be able to pull packets off the network
17:56:07 <dons> sorear: no it isn't :-)
17:56:11 <dons> pack "foo" is better by far
17:56:34 <sorear> dons: eh?  even in machine generated code?
17:56:50 <sjanssen> sorear: I think there's a RULE for that
17:56:54 <dons> there's a rule.
17:56:54 <sorear> I certainly wouldn't want to keep 3 and "abc"# in sync by hand, if that's what you mean
17:57:05 <dons> if it was machine generated, you could do either.
17:57:12 <sorear> but the rule doesn't use unsafePackAddress, it uses regular packAddress
17:57:18 <sorear> and packAddress costs a strlen
17:57:29 <dons> that's right.
17:57:46 <sorear> Now, if we could have general code in rules, we could optimize pack "foo" to unsafePackAddress:)
17:58:16 <matthew-_> sorear: in which case I suspect I totally misunderstood you. ;)
18:00:32 <sorear> matthew-_: probably the best approach, for certain values of best, is to stick a relocatable elf header on the beginning of your 1.5M string literal, and reference it using the FFI.  that way ghc won't see it at all.
18:01:12 <dons> ok. something that's never been done in a haskell program, afaik. so that is a certain value of 'best' sorear ;-)
18:01:36 <sorear> is it even possible to access external arrays with the ffi?
18:01:45 <sorear> s/arrays/data/
18:01:56 <dons> yeah , via & imports
18:02:00 <sorear> or do I need the FDI for that ;)
18:02:06 <dons> foreign import ... "&sym"
18:04:12 <cragwolf> hello, Haskell newbie here, I'm having a problem with STArray, posting a pared-down version of my code to hpaste
18:04:15 <hpaste>  cragwolf pasted "STArray problem" at http://hpaste.org/1510
18:05:38 <matthew-_> sorear, dons: that sounds like an interesting plan. Any docs you can point me at to work out how to do that?
18:06:16 <sorear> @where ffi
18:06:16 <lb> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
18:07:15 <sorear> cragwolf: the nesting of runST is the problem.  you can't use variables from one call to runST inside another one.
18:07:42 <hpaste>  sorear annotated "STArray problem" with "fixed?" at http://hpaste.org/1510#a1
18:08:09 <sorear> @google "A whirlwind tutorial on" elf
18:08:10 <lb> http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html
18:08:10 <lb> Title: A Whirlwind Tutorial on Creating Really Teensy ELF Executables for Linux
18:08:16 <dons> yeah, its important to remember that each runST is full encapsulated, so no state from inside the runSt can leak out
18:08:40 <sorear> it doesn't cover object files (only executables), but it's a pretty good ref on handcrafting ELF
18:09:50 <Philippa> dons: supposing I want to build an app with gtk2hs that essentially feels like a pile of console windows - how hard is that going to be to do?
18:10:30 <sorear> cragwolf: fixed?
18:10:39 <cragwolf> sorear, dons: thanks, I had previously read something like that about runST but clearly I didn't understand it! I think I understand it now. Fixed sorear, thanks
18:11:34 <dons> Philippa: i don't use gtk2hs, so hmm. not too hard?
18:12:25 <sorear> Philippa: SamB wrote a gtk2hs terminal emulator for his Z-machine
18:13:36 <Philippa> dons: sorry, brainfart, fair enough :-)
18:13:50 <Philippa> sorear: thanks, is the code available?
18:14:18 <sorear> Philippa: I don't know
18:14:20 <sorear> @seen SamB
18:14:21 <lb> SamB is in #perl6 and #haskell. I last heard SamB speak 1h 31m 19s ago.
18:14:35 <sorear> @seen SamB_XP
18:14:36 <lb> SamB_XP is in #haskell-blah and #haskell. I last heard SamB_XP speak 54m 46s ago.
18:14:43 <Philippa> found it
18:21:25 <Saizan> why lb?
18:21:58 <sorear> @botsnack
18:21:58 <lb> :)
18:21:58 <lambdabot> :)
18:22:02 <sorear> @type 2+2
18:22:05 <lb> forall t. (Num t) => t
18:22:18 <lambdabot> thread killed
18:22:23 <sorear> lambdabot: @part #haskell
18:26:54 <Saizan> oh
18:42:35 <monochrom> petekaz: you there?
18:43:55 <dons> sorear: its weird, i see no obvious reason why @type is failing.
18:44:01 <dons> though it fails in console mode too. very strange.
18:44:46 <ddarius> dons: How is the GHCi on the machine behaving?
18:44:55 <ddarius> And @run?
18:45:50 <sorear> and you haven't changed anything in the last day?
18:45:52 <dons> ghci is fine.
18:46:05 <dons> no, though there was a power failure about 6 days ago
18:46:10 <dons> i've not touched the machine since then.
18:46:23 <sorear> very very odd...
18:46:27 <dons> and @run is fine.
18:46:39 <dons> i'm going to clean it out and try building from scratch.
18:46:43 <sorear> is this one of those systems where the netadmins will upgrade ghci without telling you?
18:46:52 <dons> no, its my box.
18:47:05 <dons> the only thing i can think of was the nasty power failure last saturday
18:47:11 <dons> but this only manifested last night, I think?
18:47:12 <mauke> @source Data.Bits
18:47:21 <sorear> 'nasty' power failure?
18:47:32 <dons> yeah, the entire building went off suddenly
18:47:43 <dons> and i wasn't in the country, so who knows if the fsck went ok
18:48:10 <sorear> who knows if it fscked at all.
18:48:28 <sorear> people are so impatient now, most distro maints think journalling is a panacea
18:48:43 <dons> well, its a bsd, it fscked. :-)
18:48:49 <lb> http://darcs.haskell.org/packages/base/Data/Bits.hs
18:48:56 <sorear> debian never runs fsck unless the kernel actually hits an assertion failure
18:48:59 <dons> now, why was lb so slow there?
18:49:04 <dons> is that just your connectoin, sorear ?
18:49:20 <sorear> i think so, the erc lag monitor went off at the same time
18:49:21 <dons> glguy: around?
18:49:31 <dons> have we seen glguy?
18:49:39 <sorear> not for >4 days
18:50:12 <dons> hmm. this is interesting. my runhaskell configure is not terminating
18:50:20 <dons> very odd
18:50:39 <sjanssen> does your ghci work at all?
18:50:40 <sorear> at this point what I did was reboot and try again.
18:50:45 <sorear> then, it worked
18:50:56 <dons> seems to work.
18:51:02 <dons> sorear: oh?
18:51:07 <sorear> at that time I figured out where the mysterious fs corruption was coming from :(
18:51:39 <mauke> @hoogle (Ord a) => a -> a -> a -> Bool
18:51:40 <lb> No matches, try a more general search
18:51:44 <dons> ok. we'll try that.
18:52:16 <sorear> dons: rebooting clears the cache and shuffles everything around... afaict it will fix it iff the memory is dysfunctioning
18:52:17 <dons> its getting pretty old now, this machine. i've had it for 5 years.
18:52:29 <dons> so i'm not sure it would really be happy about sudden power failure
18:52:33 * sorear is making wild guesses
18:52:48 <dons> yeah, i just noticed a couple of unix utils not terminating either
18:52:52 <dons> so the machine seems a bit sick
18:52:57 <sjanssen> scary
18:53:09 <dons> 'sok, i've got other machines to play with :-)
18:53:20 <dons> and its not my laptop, where all the magic happens ;-)
18:53:36 <dons> otherwise i'd be crying and sobbing in a ball in the corner
18:53:45 * sjanssen wonders why lambdabot isn't on the opteron beast yet
18:53:50 <phoniq> anything wacky in /var/log/*?
18:53:59 <dons> not good for gathering benchmark numbers, sjanssen
18:54:06 <dons> when there's competition for cores
18:54:07 <sorear> sjanssen: the opteron beast is a benchmark clean room
18:54:18 <dons> its also the general purpose gpu machine
18:54:21 <sjanssen> makes sense
18:54:29 <dons> so it runs gpu code too, in funny kernel modes
18:54:35 <dons> making it less than stable sometimes
18:54:35 * sorear mutters something about CPUAFFINITY
18:54:43 <dons> yeah, we do always use that as well
18:55:05 <dons> but its no good when you're trying to get 16 core measurements, and some ranomd #haskell guy is trying to find primes at the same time ;-)
18:55:52 <dons> ok. its building now.
18:55:56 <dons> good sign.
18:56:08 <dons> previously it locked at "checking for ghc version... 6.6
18:56:09 <dons> "
18:56:22 <sorear> no, that is a very very very bad sign.
18:56:33 <dons> well, it does mean its going to die, yes :-)
18:56:45 <dons> but i need a new box anyway.
18:57:15 <dons> if we really get stuck, i can move lambdabot over to dcoutts box.
18:57:31 <sorear> ye gods.  I have a 6.2.2 install
18:59:24 * sorear wonders if lambdabot will work on 6.2.2
18:59:41 <sjanssen> isn't that pre Data.Map?
19:01:15 <sjanssen> makeFM theFM codeFM lookFM likeFM thisFM
19:07:00 <dons> nope. @type still busted
19:07:02 <dons> freaky
19:07:11 * dons tries a different box
19:09:59 <shapr> SHAZAM!
19:10:18 <dons> heya shapr
19:10:23 <mauke> why isn't there a decodeUTF8 in the standard libraries?
19:10:24 <sorear> hello.
19:10:27 <Nafai> Hey shapr
19:10:54 * sorear is in the process of installing ghc 6.6 on his parent's dvr
19:11:32 <ddarius> sorear: I'm sure they'll love you for it.
19:11:42 * dmwit is always amused by comments like that, but never knows what to say in response.
19:12:01 <dons> sorear: so you're introducing your dad to haskell? (he's a computer guy, iirc?)
19:12:26 <sorear> no such luck
19:12:42 <dons> oh, that's a pity.
19:12:52 <sorear> it's just a machine that is (a) up 24/7 (b) has quite a few cycles to spare (hardware mpeg encoding and decoding)
19:13:09 <sorear> hopefully it won't be running lambdabot for long.
19:13:39 <dons> yeah, currently lambdabot is completely down.
19:14:35 * ddarius sees "lambdabot on a GPU" in the near future.
19:15:35 <ddarius> Those vector operations will be great for stereo request/replies.
19:15:45 <dons> sjanssen: so i'm working on the web page now.
19:16:05 <dons> sjanssen: do you know of anything else we need to do? other than, tag, upload to hackage, website, announce?
19:16:16 <Philippa> sorear: it's probably not too big a worry however hard you hammer it so long as you set an appropriate niceness level?
19:16:27 <sorear> Philippa: right.
19:16:44 <sorear> nice is inherited?
19:16:51 <sorear> is nice inherited?
19:17:01 <koala_man> yes
19:17:18 <hpaste>  mauke pasted "it works!" at http://hpaste.org/1511
19:17:38 <sorear>     Can't find module `Data.ByteString.Char8'
19:17:49 <sorear> I thought fps came with ghc-6.6?
19:17:55 <dons> in base, yes.
19:18:18 <sorear> stefan@mythpvr0:/usr/local/src/lambdabot$ ghc -V
19:18:19 <sorear> The Glorious Glasgow Haskell Compilation System, version 6.2.2
19:18:22 <sorear> yay for PATH
19:18:26 <dons> right.
19:18:56 <shapr> hiya
19:19:05 <sorear> hm, I'll probably need to install a few more packages...
19:20:25 <ddarius> shapr: How is life?
19:21:10 <sorear> @where arrows
19:21:18 <sorear> @whereplugins
19:21:23 <sorear> @where plugins
19:21:37 <sorear> um, where's lb?
19:22:22 <mauke> lagged
19:26:16 <SamB_XP> sorear: I did?
19:26:23 <SamB_XP> I don't remember writing one of those!
19:26:34 <sproingie> hm.  any good places to look for statefulness idioms in haskell?
19:26:58 <sproingie> i grok STrefs and IORefs and such, but i'm not sure how to manage little bits of state in different places
19:27:04 <dons> sproingie: perhaps Control.Monad.State ?
19:27:22 <dons> or if its really small, just parameters to functions
19:27:27 <sproingie> i looked into how lambdabot did state and my head exploded (a familiar reaction by now)
19:27:33 <dons> though i find i need state so rarely, usually its a major design decision
19:27:46 <dons> lambdabot's not a good place. its a strange application, being huge and dynamic
19:27:48 <ddarius> Lambdabot just uses IORefs I thought (essentially)
19:27:58 <dons> it uses a StateT
19:28:08 <dons> with some magic to statically partition each plugin's state
19:28:20 <sproingie> well i'm doing something like a roguelike and/or mud (starting with something more like wumpus)
19:28:38 <dons> sounds like a perfect case for a Rogue monad
19:28:50 <dons> which would be a StateT over IO, that gives you all the flexibility you need
19:28:51 <ddarius> Control.Monad.State is good for small pieces of state needed throughout the application and counters and such very locally.
19:28:58 <sproingie> yeah i'm just wondering what the idioms are for aggregating all the different stateful pieces
19:29:08 <sproingie> i'll check out Control.Monad.State then
19:29:17 <dons> usually, a single record type with fields for the different 'variables'
19:29:26 <ddarius> I would not recommend explicit state passing for anything but the smallest code.
19:29:36 <sproingie> well i have an eye toward dynamic extension
19:29:38 <dons> sproingie: here's a nice example, our window manager,
19:29:44 <SamB_XP> dynamic extension?
19:29:45 <dons> http://darcs.haskell.org/~sjanssen/xmonad/XMonad.hs
19:29:58 <dons> the different state variables are in the XState record type
19:30:05 <sproingie> not as dynamic as lambdabot perhaps, but at least easy
19:30:07 <SamB_XP> I'd build a roguelike first and then try and figure out how to dynamically extend one...
19:30:15 <dons> and the state itself is threaded (implicitly , of course) in the X monad)
19:30:35 <sproingie> mm that looks nice and readable
19:30:43 <sproingie> the XMonad that is
19:30:58 <dons> also the 'roll your own irc bot' has a small state monad example
19:31:09 <sproingie> where would i find that?
19:31:15 <dons> ?goo roll your own irc bot
19:31:24 * dons waits on lb
19:31:36 <dons> its on the haskell.org wiki
19:31:51 <dmwit> lb still hasn't returned from queries sent minutes ago -- is it still alive?
19:31:53 <SamB_XP> @bo
19:31:54 * sproingie punches it into google, finds it
19:32:04 <dons> sorear: around?
19:32:08 <dmwit> (The @where's above, for example.)
19:32:11 <dons> sorear: is lb playing silly buggers
19:32:30 <sorear> I don't know what happened to lb.
19:32:36 <sorear> there is no process
19:32:46 <sorear> dunno why it's still a nick thought
19:33:07 <paetso> someone had it leave awhile back
19:33:08 <SamB_XP> blame your kernel for not closing the connection!
19:33:12 <sproingie> now that's a nice tutorial.  so little code for something so practical
19:33:32 <dons> that's the haskell way :-)
19:33:37 <dons> haskell-onic, if you will
19:34:02 <dons> we need a nice name for 'the essential beauty, sparseness and elegance of a good haskell program'
19:34:08 <dons> to compete with the 'pythonic' label
19:34:19 <dmwit> "Haskeletonic"
19:34:35 <sproingie> haskellian
19:34:35 <jaredj> hask-oriented
19:34:42 <thorat> hakellitious
19:34:42 <SamB_XP> haskellicious!
19:34:43 <dons> mmm, haskellian
19:34:45 <thorat> hah
19:34:48 <sproingie> YES
19:34:49 <thorat> oh
19:35:13 <thorat> I though bootylicious
19:35:13 <sproingie> i'm down with haskellicious
19:35:32 <dons> monadocious
19:35:38 <thorat> s/though/thought
19:35:41 <Korollary> haskiller
19:35:45 <dons> heh
19:35:47 <sproingie> hask
19:35:48 <sorear> lb has sooo many deps.
19:36:05 <thorat> come on, Destiny's Child wins
19:36:07 <Philippa> other languages' code is "monadectomised", then?
19:36:10 <dons> how's lb'/lb7 coming along? ;-)
19:36:13 <thorat> http://en.wikipedia.org/wiki/Bootylicious
19:36:14 <lb2> Title: Bootylicious - Wikipedia, the free encyclopedia
19:36:28 <SamB_XP> in the future, every LB plugin should have its own Cabal package ;-P
19:36:31 <erider> lol
19:37:00 <dmwit> A bit late, but: currific?
19:37:09 <dmwit> Like terrific, and totally unlike horrific.
19:37:24 <dons> heh, looks like martin bishop is on an ocaml binge on reddit
19:37:30 <sproingie> currfect
19:37:40 <dmwit> haha
19:38:04 <jaredj> very coorr.
19:38:26 <sproingie> hasktastic
19:38:34 <sorear> dons: my attempt to impurify Seen is very .. hard
19:38:39 <sorear> discouragingly so
19:38:47 <thorat> Haskellent
19:38:58 <jaredj> reminds me of, "Sblounschkted!"
19:39:09 <sorear> alas it seems that incrementalism requires exposing your maps and transactionalism requires monads?
19:39:10 <magnus_> .pl f (g x) (h x)
19:39:12 <dmwit> haskanty
19:39:19 <Philippa> I'm not sure I like the idea of an equivalent for "pythonic" though - we don't have just one way to do it
19:39:26 <magnus_> !pl f (g x) (h x)
19:39:31 <sorear> magnus_: Real Soon Now :)
19:39:42 <sorear> i'm on djinn
19:39:47 <dmwit> ?pl \x -> f (g x) (h x)
19:39:48 <lb2> liftM2 f g h
19:39:50 <sproingie> well python is being dragged into TMTOWTDI too
19:39:57 <sproingie> they just don't like to admit it
19:40:02 <magnus_> sorear: you are the djinn author? :)
19:40:13 <SamB_XP> haskellicious, I tell you
19:40:18 <sorear> no way!
19:40:21 <sproingie> hell they even got real closures for 3.0, finally
19:40:45 <thorat> sproingie: so they finally went stackless?
19:40:46 <SamB_XP> sproingie: what was wrong with the ones in 2.2?
19:40:52 <magnus_> thanks dmwit
19:40:56 <sorear> there are some people so great in stature that confusing me with them is not an honor but an insult.  Lennart Augustsoon is one of them.
19:41:13 <sproingie> SamB_XP: outer variables were read-only
19:41:21 <jaredj> sson?
19:41:28 <sorear> yes
19:41:33 <SamB_XP> sproingie: nobody minds that in Haskell!
19:41:45 <thorat> sproingie: so they used to be like java's local classes?
19:41:48 <mauke> yeah, you just use a read-only variable containing a ref
19:41:49 <sproingie> SamB_XP: well yeah but if your language has state and pretends to have closures, it better go all the way
19:42:16 <mauke> that's not closures being broken; it's simply a consequence of python's implicit scoping
19:42:30 <ddarius> sorear: To them?
19:42:31 <SamB_XP> so how did they "fix" it?
19:42:46 <sproingie> special syntax to get at the outer scope
19:43:24 <sproingie> which is kinda blah, but at least now you can do the whole "objects as static closures" tutorial thing in python now
19:43:53 <jaredj> do mediocre programmers have a hope of haskell?
19:44:02 <sproingie> well, come 3.0 they can do it
19:44:22 <mauke> uh, you can do that in current python
19:44:40 <dmwit> jaredj: I tend to think so.
19:45:11 <sorear> @version
19:45:11 <sorear> @#haskellsnack
19:45:11 <lb2> lambdabot 4p514, GHC 6.7.20070413 (Linux i686 2.00GHz)
19:45:11 <lb2> darcs get /usr/local/src/lambdabot
19:45:11 <lb2> Unknown command, try @list
19:45:15 <sorear> yay for all things lagacious.
19:45:32 <jaredj> ( http://www.codinghorror.com/blog/archives/000635.html )
19:45:33 <lb2> Title: Coding Horror: Separating Programming Sheep from Non-Programming Goats
19:46:18 <lambdabot> lambdabot 4p0, GHC 6.6 (Linux i686 2.00GHz)
19:46:20 <lambdabot> darcs get
19:46:22 <lambdabot> Unknown command, try @list
19:46:24 <lambdabot> Title: Coding Horror: Separating Programming Sheep from Non-Programming Goats
19:46:53 <dmwit> jaredj: I haven't read the article yet, but have you seen the paper they're referring to?
19:46:56 <sorear> lb2: @quit
19:47:22 <dmwit> It's terrible!  There's all kinds of hidden variables and changes between "experiments" that they don't address, and they're analysis is very shallow.
19:47:41 <jaredj> i have not seen the paper.
19:48:15 <jaredj> i think if i were in college and didn't know how to program, haskell would be great
19:48:25 <sorear> btw, lambdabot is on a machine that stays up for about a week at a time now.
19:48:33 <jaredj> but i have seen some people who don't seem to make the leap from fortran to c
19:48:57 <sorear> in a few days, ndiswrapper will stop working, and someone will reboot the box in order to get connectivity back
19:49:14 <jaredj> ew
19:49:31 * sorear hates all things wlan
19:49:43 <dmwit> It's very unpredictable.
19:49:55 <mauke> sproingie: re: closure objects, is that what you mean? http://rafb.net/p/uVMgSu31.html
19:49:57 <lambdabot> Title: Nopaste - No description
19:50:35 <magnus_> ?eval liftM2 (+) negate negate 1
19:50:38 <SamB_XP> jaredj: what in the world are they doing in fortran?
19:50:43 <mauke> @help eval
19:50:43 <lambdabot> eval. Do nothing (perversely)
19:51:01 <mauke> > liftM2 (+) negate negate 1
19:51:13 <jaredj> SamB_XP: math
19:51:27 <jaredj> numerical integration, etc.
19:52:13 <sorear> The *other* box I use has a rock-solid Intel PRO/100 natively supported connection.
19:52:13 <sorear> OTOH, it is vulnerable to my lightning paranoia.
19:52:13 <sorear> so in 5h it will definitely be shut down and electrically isolated.
19:52:40 <magnus_> mauke: weird, nothing happens
19:52:49 <mauke> @bot
19:53:06 <dmwit> I think I'm going through bot-withdrawal.
19:53:06 <sorear> *tap tap*
19:53:13 <dmwit> Quick, bring me a patch!
19:53:17 <lambdabot> :)
19:53:18 <lambdabot>  -2
19:53:19 <mauke> magnus_: it's -2
19:53:31 <dmwit> mauke: @botsnack
19:53:32 <dmwit> ;-)
19:53:41 <mauke> > join (liftM2 (+)) negate 1
19:53:44 <lambdabot>  -2
19:53:49 <magnus_> mauke: cheers
19:53:53 <sproingie> mauke: right, closure objects, but with rebindable outer variables, not just with mutable objects.
19:54:16 <mauke> rebindable? sounds evil
19:54:16 <magnus_> when I try it in *my* repl I get the error: No instance for (Monad ((->) a))
19:54:31 <mauke> magnus_: :m +Control.Monad.Reader
19:54:38 <sproingie> mauke: evil as statefulness always is, yes
19:54:50 <magnus_> mauke: reader? weird :)
19:55:08 <mauke> ((->) a) is the reader monad
19:55:29 <magnus_> I gotta read up on the reader monad
19:55:29 <sorear> now, everyone, I just renice +19'd the bot :)
19:55:38 <sproingie> actually instead of a roguelike i'm pondering something like progressquest
19:55:54 <sorear> > nubBy(((>1).).gcd)[2..]
19:55:57 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
19:56:16 <sproingie> except run as sort of a sim that you can drill down into and micromanage.  so unattended it'd run itself like progressquest, and on manual it'd run like a crpg
19:56:21 <SamB_XP> sproingie: is that like idlerpg?
19:58:10 <sproingie> yeah idlerpg is very pq-like
20:00:17 <SamB_XP> where are you going to get the "16-bit" graphics?
20:00:58 <sproingie> glue two 8-bit chips together
20:02:56 <SamB_XP> I meant the art, silly!
20:04:00 * sorear is writing a raytracer in haskell with intention to go waay faster than povray
20:04:43 <SamB_XP> good luck with that!
20:04:52 <sorear> there are ways.
20:04:56 <SamB_XP> let me know if it works -- I might want to highjack it
20:05:27 <sorear> back in the day, before I learned haskell, I wrote a circuit simulator in perl that ran a couple hundred times faster than spice.
20:05:49 <magnus_> what kind of trick did you use?
20:06:06 <sorear> also about a hundred times less numerically stable, but I know more about methods now... it used euler integration!!
20:07:21 <magnus_> I like euler because of its simplicity
20:07:43 <sorear> magnus_: specializing dynamic code generation.
20:07:44 <sorear> magnus_: the perl script wrote C, then invoked gcc -O2
20:07:46 <sorear> just like what dons did for his icfp-07 paper
20:08:04 <magnus_> haha, I'm right now writing a program that generates C intended for execution
20:08:06 <sorear> well, it's pretty inaccurate.
20:08:28 <sorear> it is soo fun seeing your inverting op amps occilate at 1 / stepsize hz
20:08:49 <sorear> and growing exponentially until the voltage hits NaN
20:09:14 * sproingie whips out his NaN-volt voltage regulator
20:09:15 <sorear> NaN volts is a pretty unrealistic prediction ;)
20:09:33 <jaredj> real ultimate power
20:12:29 <mauke> hmm, can't you use Inline::C for that?
20:12:46 <sorear> like I knew about cpan back then ;)
20:13:53 * dylan knew about cpan before he knew about perl.
20:14:09 <ddarius> Numerical analysis is surprisingly interesting.
20:17:41 <SamB_XP> dylan: how can you know about cpan before you know about perl?
20:17:53 <dmwit> Easy, see it linked somewhere.
20:18:15 <dylan> SamB_XP: because that
20:18:17 <dmwit> I found out about it before I even knew there were libraries for C.
20:18:18 <SamB_XP> yeah, but you wouldn't know what it is before you know about perl...
20:18:27 <dylan> 's the place where I got a jabber client from
20:18:42 <SamB_XP> oh, it has apps too?
20:18:51 <dylan> indeed.
20:19:10 <dylan> "to install <I forget the name> jabber client, run cpan -i Some::Jabber::Client"
20:19:22 <dylan> of course, I was on windows, so that didn't really work.
20:19:44 <dylan> then a few months later I learned perl, read said client's source code, decided the author was a moron.
20:19:45 <SamB_XP> heh
20:19:50 <dylan> than I tried to write a jabber client myself
20:19:58 <dylan> than I decided the authors of the jabber protocol were morons.
20:20:00 <bd_> That must've been... fun
20:20:02 <dylan> anyway.
20:20:25 <dylan> bd_: this was after I failed to write a you-know-what client. Grr, single-letter protocol commands...
20:20:31 <bd_> heh
20:20:33 <SamB_XP> did you decide the client auther wasn't actually a moron?
20:20:43 <magnus_> in gch, is there any way to browse a module directory, for example I would like to see what modules exist under Text. :browse Text doesn't work
20:21:09 <sorear> @docs
20:21:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
20:21:42 <magnus_> cheers
20:22:57 <dylan> SamB_XP: nope
20:23:05 <dylan> he didn't use strict or use warnings...
20:23:12 <SamB_XP> oh
20:23:15 <dylan> or use lexical vars.
20:23:21 <SamB_XP> !
20:23:24 <dylan> yes.
20:23:47 <dylan> I was just the start of the long road to being unhappy with pretty much the state of everything.
20:23:53 <SamB_XP> I don't know if I did, either, when I wrote perl, but then I don't know if I knew that perl had the other kind...
20:24:11 <dylan> I read all the camel books, pretty much.
20:24:21 <dylan> I discovered lambas very early.
20:24:30 <dylan> *lambdas.
20:25:01 <dylan> I used functions returning functions storing state before I knew about objects.
20:26:09 <petekaz> monochrom: yes.
20:27:19 <monochrom> Nice.
20:27:58 <monochrom> I was wondering "interact $ (++"\n") . show . (id &&& correct) . init"  that's only good for reading one word from stdin right?
20:28:24 <petekaz> that was not my intention.
20:28:30 <dylan> perl isn't a very bad introduction to functional programming. :)
20:28:56 <petekaz> maybe that's why I thought it was doing nothing after reading the first word.
20:29:26 <dmwit> "If you would like to learn more about the limitations behind arrows, follow the references at the end of this article."
20:29:29 <monochrom> echo "hello" | ./spell
20:29:34 <dmwit> But there are no references at the end of the article.
20:29:35 <dmwit> =(
20:29:36 <monochrom> echo "hello world" | ./spell
20:29:43 <petekaz> I thought that everything after the $ was going to be applied to each line of stdin.
20:29:54 <ddarius> dmwit: There must be no limitations.
20:30:00 <petekaz> right, that works.  but reading a file with lots of words fails.
20:30:01 <dmwit> =)
20:30:07 <monochrom> The former correctly suggests hullo, the second treats "hello world" as one single word.
20:30:37 <ddarius> @type words
20:30:42 <lambdabot> String -> [String]
20:30:47 <jcreigh> "correctly"? hello is fairly common usage.
20:30:54 <monochrom> I changed it to: interact $ unlines . map (show . (id &&& correct)) . tokens
20:31:00 <petekaz> monochrom: oh .. I thought interact was line based.
20:31:34 <dmwit> :t interact
20:31:38 <lambdabot> (String -> String) -> IO ()
20:31:52 <mauke> @src interact
20:31:53 <lambdabot> interact f = do s <- getContents; putStr (f s)
20:31:55 <dmwit> Ah, the type doesn't make that any clearer, interesting.
20:32:14 <petekaz> monochrom: I guess I'm still thinking in Python ...
20:32:30 <petekaz> Let me try it again with your changes.
20:32:39 <ddarius> dmwit: Yes! We should make a type of Lines and Words and distinguish them at compile-time!
20:33:09 <dmwit> =(
20:33:11 <dmwit> I need more sleep.
20:33:22 <monochrom> With my change the performance is still poor.  As words from stdin are processed and answered, things become slower and slower. Also memory grows.
20:33:29 <ddarius> Actually, it would not be impossible to do that.  Impractical, but not impossible.
20:34:03 <ddarius> The one section with all the indexing and taking and dropping and list comprehensions is probably a large part of the problem.
20:34:35 <petekaz> monochrom: well at least you fixed one piece of it for me.  What a stupid mistake.
20:35:00 <monochrom> Another finding: I change the program to just finish training, then query the frequency map (to make sure all of it is forced, e.g., I ask for the maximum frequency), only takes 20M memory and 4 seconds.
20:35:52 <petekaz> why does that help?
20:36:08 <monochrom> In other words if there are slowdowns and memory growth as you perform correction searches, it is unlikely the fault of the frequency map.
20:36:34 <petekaz> I thought as soon as I tried to lookup the first word, it would force the whole freqmap to be evaluated.  how can it search for a word in the tree unless all of it has been created.
20:37:15 <ddarius> It only needs the parts of the tree it actually looks at.
20:37:28 <monochrom> Yes that too.  I wanted a clear experiment to isolate factors beyond doubt.
20:38:34 <SamB_XP> you should try length . M.toList
20:39:06 <monochrom> It is, in fact, more subtle than that.
20:41:20 <petekaz> I could understand how 'known' could result in a partially evaluated freqmap because it only has to find the word, but once I run 'maximumBy' it has to fully evaluate the tree or it would be returning incorrect results, no?
20:42:21 <SamB_XP> oh, maximumBy you say?
20:42:27 <petekaz> because the freq value of the word could be increased as the corpus is read.
20:42:33 <SamB_XP> that should need the whole tree, yes...
20:43:13 <monochrom> No one is refuting that.
20:43:57 <petekaz> oh, I misunderstood then.  I'm trying to understand your last insight.
20:44:09 <petekaz> the 'another finding' comment.
20:45:14 <monochrom> Is it wrong to set up a second experiment to verify a deduced fact?
20:45:43 <petekaz> I'm sorry, I don't think I am communicating clearly.
20:45:59 <petekaz> I don't understand why it only used 20mb for you but it uses 150mb for me.
20:46:23 <petekaz> how does the change you make result in less memory usage?
20:48:15 <monochrom> 20mb if just build the frequency map, no correction.
20:49:00 <petekaz> wow.
20:49:05 <SamB_XP> profile, you should, if answers you seek!
20:49:36 <petekaz> So my program uses 130mb just coming up with permutations of words?
20:49:39 <petekaz> yikes.
20:49:53 <petekaz> that must be all the list building I guess.
20:49:54 <ddarius> petekaz: Isn't that the take/drop/!! part of the code?
20:50:33 <petekaz> I'm running the profiler now.
20:50:49 <phoniq> easier, a correct program fast to make it is, a fast program correct than
20:51:02 <kilimanjaro> No petekaz; the profiler is running you. And you don't even know it...
20:51:12 <petekaz> I'm a newbie, my program is neither correct, nor fast!
20:51:29 <kilimanjaro> petekaz, but I bet it sure looks pretty :)
20:52:21 <jaredj> phoniq: that's dizzying, do you have a yodafier?
20:52:53 <petekaz> kilimanjaro: :-) I tried to make it look nice.
20:52:56 <phoniq> heh
20:53:01 <SamB_XP> phoniq: I'm thinking we are looking at the heap profiling rather than the time profiling...
20:53:32 <monochrom> You should also note that holmes.txt is using UTF-8.  If you read it with GHC, you're pretending it's ISO-8859-1.  This affects answers.
20:53:37 <SamB_XP> easier a correct program to make if RAM you have
20:53:38 <petekaz> I'm running the -p profiler .. is that not the right one?
20:54:05 <jaredj> easier to interpret such sentences it is if a stack-based english parser you have
20:54:32 <jaredj> (except the if is infix, in a concession to mortals)
20:54:38 <SamB_XP> petekaz: well, what does the graph tell you?
20:55:00 <hpaste>  petekaz pasted "profiling results" at http://hpaste.org/1512
20:55:59 <petekaz> so between edits1 and edits2, roughly 70% of the memory allocations were done there (did I interpret the output correctly?)
20:57:35 <phoniq> better
20:57:42 <phoniq> easier than it is to make, a correct program fast, a fast program correct
20:58:21 <sorear> No parse
20:58:25 <phoniq> heh
21:00:43 <SamB_XP> a parse there is not
21:01:10 <SamB_XP> ... it's SUPER GROVER!
21:01:27 <dmwit> > let vowels = "aa" >> "aeiouy"; after xs x = if elem x xs then (dropWhile (/= x) >>> takeWhile (== x) >>> head) x else x in map (after vowels) "ping" -- which bot should I address my /msg's to?
21:01:30 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
21:01:30 <lambdabot>       Expected...
21:01:41 <dmwit> Good enough for me.
21:01:51 <ddarius> petekaz: Don't treat lists as arrays with indexing and slicing and performance will likely improve.
21:03:07 <petekaz> I actually have a bytestring version as well, but that was slow too.
21:03:35 <bos> (!!) is not your friend
21:05:02 <dmwit> > let vowels = "aa" >> "aeiouy"; after xs x = if elem x xs then head . dropWhile (== x) . dropWhile (/= x) $ xs else x in map (after vowels) "ping" -- try two, no arrows this time
21:05:06 <lambdabot>  "pong"
21:05:12 <bos> ddarius: does edison contain any strict collections, or are they all lazy?
21:05:15 <sorear> dmwit: lambdabot
21:05:31 <sorear> dmwit: "lambdabot" is not dons-bot
21:05:35 <dmwit> Yep, got it, I just wanted to figure out how to fix it.
21:05:37 <dmwit> Oh?
21:05:40 <sorear> manzano is dead.
21:05:44 <ddarius> bos: Heck if I know.  Back in the day, I don't think it really specified.
21:06:05 <sorear> I've taken over bot duties until dons can replace the whole computer.
21:06:12 <dmwit> !
21:06:20 <dmwit> Well... thanks.
21:06:30 <sorear> apparently the memory stoped working after the power outage
21:07:02 <bos> i am currently being annoyed by the laziness of Data.Map and Data.Set
21:07:04 <dmwit> Ah, that's probably a bummer for him.
21:07:22 <sorear> note, that dons hasn't told me his password, so lambdabot is unid'd.
21:07:35 <sorear> @botsnack
21:07:35 <sorear> ....
21:07:36 <lambdabot> :)
21:07:40 <sorear> aww, dead again?
21:08:50 <sorear> lambdabot is running nice 19 on a computer whose main function is as a DVR.
21:09:56 <jaredj> nice.
21:10:07 <bos> i look forward to running lambdabot on my phone some day.
21:11:04 <sorear> heheh.  I would have run lambdabot on my router, but the manufacturer doesn't document the root pw ;)
21:11:40 <sorear> it is linux though (says nmap)
21:12:23 <sproingie> i could host lambdabot on my vps
21:12:27 <sproingie> i don't do anything else with it
21:12:36 * sorear notes that lambdabot has only been tested on x86{,_64} -- little endian
21:12:39 <sorear> sproingie: vps?
21:12:45 <sproingie> that's exactly what my vps is
21:12:55 <sproingie> x86_64 that is
21:13:09 <sorear> @vera vps
21:13:10 <lambdabot> No match for "vps".
21:13:35 <sproingie> virtual private system.  xen in this case, i pay $20/mo and do pretty much nada with it
21:14:22 <sproingie> i guess it depends on how much mem it takes up tho.  only 256meg on my slice
21:14:27 * sorear has a physical private system, and probably pays a lot more, but does a lot more too
21:14:28 * ddarius should have read about Abstract Stone Duality a long time ago.
21:14:51 <sorear> <- 384mb with no hope of pleading with admins, at least not when hot
21:14:57 <monochrom> There is an abstract Stone Duality?!
21:17:59 * sorear just got maxima to solve the raytracing eqs.  a bit too much to copy/paste though :)
21:21:13 * dmwit hides his IRC window
21:21:17 <dmwit> Time to actually get some work done. =)
21:27:39 <sorear>     let eq0 = pz*pz*qzz+pz*qz+py*pz*qyz+py*py*qyy+py*qy+px*pz*qxz+px*py*qxy+px*px*qxx+px*qx+q
21:27:39 <sorear>         eq1 = 2*pz*qzz*vz+qz*vz+py*qyz*vz+px*qxz*vz+pz*qyz*vy+2*py*qyy*vy+qy*vy+px*qxy*vy+pz*qxz*vx+py*qxy*vx+2*px*qxx*vx+qx*vx
21:27:39 <sorear>         eq2 = qzz*vz*vz+qyz*vy*vz+qxz*vx*vz+qyy*vy*vy+qxy*vx*vy+qxx*vx*vx
21:27:43 * sorear <3 cases
21:27:50 <jcreigh> gah
21:28:16 <sorear> that's *CAS*es, not *case*s
21:28:20 <dylan> I have access to a physical machine at some NOC with 502MB of ram.
21:28:45 <sorear> the last time I tried this, I had to write those exprs by hand ;)
21:28:48 <dylan> it's not being used for anything either. :(
21:29:03 <sorear> 502 *M* b?
21:30:04 <dylan> mega. :P
21:30:08 <dylan> bytes.
21:30:13 <dylan> err
21:30:15 <dylan> right
21:30:20 <dylan> it's 00:30 here. XD
21:30:21 <jcreigh> but 502 is a strange number of MBs...
21:30:39 <dylan> dylan@lazy:~$ free -m total       used       free     shared    buffers     cached
21:30:42 <dylan> Mem:           504        197        306          0          0         83
21:31:12 <sorear> dylan: on my system (384), free -m reports 377
21:31:15 <stepcut> 504 + 8MB shared video memory == 512MB ?
21:31:41 <dylan> stepcut: possibly.
21:31:52 <dylan> it's not my machine, I'm just the only person left that cares about it
21:31:57 <stepcut> heh
21:32:00 <jcreigh> I forget; do memory card makes buy into the "megabyte = 1,000,000 bytes" thing?
21:32:01 <dylan> it's supposed to be the new home of my LUG's website.
21:32:10 <dylan> but the original guy got busy, and I've been lazy.
21:32:30 <sorear> jcreigh: no, they can't, the physicalities of address decoder logic keep them honest
21:32:39 <jcreigh> sorear: oh, right.
21:34:17 <monochrom> petekaz: On the light side, I want to report that the program corrects "aol's" to "holes".
21:37:21 <petekaz> that's obvious ;-)
21:49:42 <dons> sjanssen, jcreigh: xmonad logo! http://www.cse.unsw.edu.au/~dons/tmp/xmonad.png
21:49:45 <dons> whatddya think?
21:50:08 <jaredj> ahh, it's a lambda
21:50:24 <carmen> looks like a red frowning smiley that got roadkilled
21:50:40 <carmen> and some lambdaX thing is stomping on it
21:50:46 <carmen> furthering injury
21:50:51 <dons> mmm
21:50:59 <jaredj> the monad thing made sense to me but my first thought was, "why does that X have a red finger"
21:51:00 <bos> charming.
21:51:09 <ivanm> dons: nice logo!
21:51:11 <dons> jaredj: oh, that's interesting.
21:51:27 <dons> it sort of has to be sparse, minimal, functional. like xmonad itself
21:51:28 <jaredj> so - gray finger perhaps?
21:51:35 <dons> yeah, that's an option
21:51:35 <jaredj> yes yes of course
21:51:46 <ivanm> isn't the default background a bluey-gray?
21:51:53 <dons> for what?
21:51:53 <ivanm> background colour, that is
21:52:26 <ivanm> for xmonad
21:52:43 <ivanm> or is that just me?
21:52:51 <dons> the default background?
21:53:01 <sorear> xmonad doesn't set the background
21:53:01 <dons> should be white, i think.
21:53:11 <ivanm> yeah, its a bluey gray... but that could just be my X default or something
21:53:13 <ivanm> *shrug*
21:53:13 <sorear> standard X stipple
21:53:19 <ivanm> fair enough
21:53:26 <ivanm> forget I said anything then :p
21:54:43 <ivanm> dons: I'm trying out that amsn bug I was talking to you about
21:55:59 <ivanm> dons: yup, whenever someone tries to reply to me amsn dies
21:56:11 <ivanm> I've got the .xsession-errors file, what do you want me to do with it?
21:56:43 <dons> is there anything interesting in it?
21:56:44 * dylan points to the spam bot.
21:56:59 <sorear> ?
21:57:07 <dylan> KD-Misafir968 just messaged me with "selam"
21:57:09 <ivanm> dons: couldn't find anything interesting: just a lot of notifications
21:57:11 <dylan> I assume it's a spam bot.
21:58:05 --- mode: ChanServ set +o dons
21:58:09 --- mode: dons set +b *!*=KD-Misaf@85.108.5.*
21:58:09 --- kick: KD-Misafir968 was kicked by dons (dons)
21:58:11 --- mode: ChanServ set -o dons
21:58:17 <ivanm> dons: looks like its time based, not sure what causes it
21:58:23 <dons> weird
21:58:41 <ivanm> hang on, I've got an X error
21:58:43 <ivanm> !hpaste
21:58:51 <ivanm> ?hpaste
21:58:52 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:00:50 <hpaste>  ivanm pasted "amsn errors in xmonad" at http://hpaste.org/1513
22:01:03 <ivanm> dons: ^^
22:01:25 <dons> http://www.cse.unsw.edu.au/~dons/tmp/xmonad-bw.png there's an alternative
22:01:47 <dons> huh, X Error of failed request:  BadAtom (invalid Atom parameter)
22:01:49 <carmen> my only prob with the other was hte antialiasing was a bit funky
22:01:52 <carmen> maybe its meant to bea  temp render
22:02:02 <dons> yeah, it was a little weird.
22:02:15 <dons> i think i like the greyscale one better anyway
22:02:19 <ivanm> dons: I think stick with the red >>=
22:02:39 <ivanm> but the gray top bit is better than red
22:02:42 <carmen> thnk theres a unicode char for >>
22:02:47 <carmen> then it looks kerned better
22:03:03 <dons> happen to have it handy?
22:03:07 * carmen gets out APL keyboard
22:03:09 <dons> though, the current one is reasonable, i think
22:03:57 <ivanm> *nod*
22:05:29 <dons> maybe this is better after all, http://www.cse.unsw.edu.au/~dons/tmp/xmonad-tri.png
22:05:43 * ivanm likes
22:05:50 <monochrom> petekaz: I eliminate all uses of Sets. I type WordSet = [String].  With corresponding changes to code, e.g., S.singleton x becomes [x], edits2 = concat . map edits1 . edits1.  10-fold speedup.  Also memory stays 21mb.
22:06:13 <jcreigh> dons: the xmonad logo?
22:06:26 <dmwit> I think the tip of the lambda is key.  Hold on, I'll make a mock-up.
22:06:32 <monochrom> I'll post this interim finding to the mailing list.
22:06:40 <dons> jcreigh: whaddya think? http://www.cse.unsw.edu.au/~dons/tmp/xmonad-tri.png
22:07:39 <jcreigh> Does a WM that doesn't do window decorations really need a logo? :)
22:08:03 <stepcut> jcreigh: it does window decorations! what do you call that red line around the window ?
22:08:43 <ddarius> jcreigh: lambdabot has a "logo"
22:08:44 <jcreigh> stepcut: Well, that's just the window border. xmonad doesn't draw that, it just changes it for the focused window.
22:08:47 <ivanm> stepcut: heh
22:08:50 <dons> jcreigh: for the website :-)
22:09:22 <dons> and what else are we going to put on the xmonad dev team tshirts ? ;-)
22:09:30 <dons> oh, that's right. the entire source code
22:09:33 <stepcut> heh
22:09:35 <ivanm> heh
22:09:39 <nornagon> hehe
22:09:49 <dons> you could print it on a key ring.
22:09:49 <phoniq> ><=
22:09:53 <SamB_XP> dons: wouldn't that be just a *little* hard to read?
22:09:54 <dons> or a mouse pad
22:09:55 <bos> dons: i have a peculiar problem with bytestrings.
22:09:58 <SamB_XP> on a tshirt?
22:10:00 <dons> bos, oh?
22:10:06 <jcreigh> the website should be 100% HTML4 strict with no CSS or presentional markup of any kind to fit the spirt of the project. (tongue firmly in cheek)
22:10:08 <SamB_XP> after it had been through the wash a few times?
22:10:15 <bos> i'm trying to convert a word into lowercase, and it's really slow.
22:10:23 <dons> what kind of bytestring?
22:10:24 <jcreigh> dons: we should print t-shirt that contain the entire source code.
22:10:28 <bos> lazy.
22:10:38 <dons> usually, you'd have:  Data.ByteString.Lazy.Char8.map toLower s ?
22:10:47 <bos> zigacktly.
22:10:50 <dons> and with -O2 that should produce pretty reasoable code
22:11:04 <jcreigh> I wonder what LOC we'd have to get to for xmonad to be t-shirt compatible.
22:11:09 <jcreigh> that would be really sweet.
22:11:16 <dons> bos, check the Core?
22:11:20 <bos> but it's taking 50% of my time and allocation.
22:11:55 <petekaz> monochrom: did you remove dups as well?
22:12:03 <monochrom> No.
22:12:31 <jcreigh> dons: logo is nice. I don't really have a preference over grayscale vs. the color one. For whatever reason, I didn't notice the lambda until dmwit mentioned it.
22:12:31 <petekaz> ok .. I'll do the same too.   thanks!
22:12:54 <dons> bos,hmm. can't really say what is going on without looking at the core. perhaps -O2 -ddump-simpl | less
22:13:03 <dons> then find the map loop.
22:13:16 <dons> or, test what a small loop does on a strict bytestring
22:13:16 <hpaste>  bos pasted "The weird performance case" at http://hpaste.org/1514
22:14:02 <sorear> yay, my raytracer is working
22:14:05 <bd_> sorear: Would you have any objections to my filing an ITP for vty in debian? :)
22:14:07 <bos> yeah, will look at t'core.
22:14:09 <dons> foldl?
22:14:16 <dons> should that be either foldr or foldl' ?
22:14:27 <bos> doesn't matter whether it's foldl or foldl' (foldr produces a stack overflow)
22:14:36 <dons> you probably want insertWith' too
22:14:40 <dons> for strict updates of the Map
22:14:56 <dons> do you get majorly different performance using strict bytestrings instead?
22:15:09 <sorear> bd_: No.  aside, I've pretty thouroughly abandoned the project - if you care about it, i'll give you the whole thing
22:15:17 <bos> performance with strict bytestrings is far worse.
22:15:21 <bd_> sorear: oh dear >_>;
22:15:27 <dons> interesting. this is roughly a spell checker of sorts?
22:15:40 <bos> yes, it's a simple haskell adaptation of peter norvig's spellchecker.
22:15:40 <dons> i have some demo spell checkers lying around in the fps test code
22:15:42 <dons> let me find them
22:15:48 <SamB_XP> sorear: why have you abandoned it?
22:16:02 <bd_> sorear: hmm... I've got some ideas for a terminal library, but it'd probably be very different from vty as it is now. and I might not get around to doing it :)
22:16:08 <sorear> SamB_XP: not interesting me any more
22:16:18 <dons> http://www.cse.unsw.edu.au/~dons/tmp/spellcheck.hs
22:16:24 <bos> dons: actually, i'm not really interested in finding a spellchecker, so much as in understanding why this one is so slow.
22:16:54 <dons> yeah, its not obvious to me why, other than that it is very high level. i'd need to inspect the core output to understand what's happening.
22:16:55 <bd_> In particular, I was interested in having STM's retry combinator drive redraws
22:17:07 <bos> adding strictness to the fold and map update makes little difference.
22:17:16 <dons> and things like the (+) update of the map being fully lazy doesn't look great.
22:17:26 <dons> but , without the core, we know nothing :-)
22:17:33 <bos> but the map doesn't enter the profile at all.
22:17:46 <bos> i have the core handy now.
22:17:51 <sorear> first pretty picture: http://members.cox.net/stefanor/x.png
22:18:10 <sorear> no codegen yet
22:18:27 <bd_> but anyway, I guess if there's no upstream support I'll drop it for now, until/unless I decide to pick it up myself at some point (a bit busy these days for that alas)
22:18:30 <sorear> and all the eq's were correct the first time, thanks to maxima
22:19:04 <sorear> I wrote it when I needed it.  I don't need it for any of my current projects.
22:19:15 <ivanm> sorear: you use maxima then? do you know if there's a haskell plugin for it?
22:19:20 * ivanm is considering using maxima
22:19:50 <sorear> I doubt it.  it supports exactly one language, and only then by virtue of being impl'd in it
22:19:51 <petekaz> monochrom: would Hashtable be better than Map in this case?
22:20:13 <monochrom> hard to say.
22:20:18 <monochrom> worth a try.
22:20:51 <ivanm> sorear: whoops, got confused between maxima and texmacs...
22:20:54 <Pseudonym> It costs almost nothing to replace one with the other.
22:20:55 <ivanm> don't know how that happened :s
22:21:01 <Pseudonym> Data.Map vs Data.Hashtable
22:21:09 <Pseudonym> So try them both.
22:21:25 <sorear> Pseudonym: you're being sarcastic right?  data.hashtable is a mutable structure!
22:21:37 <Pseudonym> Oh, yeah, that's right.
22:21:38 <bos> dons: darcs get http://darcs.serpentine.com/spell-tmp/
22:21:40 <sorear> HashTable a b -> a -> b -> IO ()
22:21:41 <Pseudonym> D'oh.
22:21:42 <lambdabot> Title: Index of /spell-tmp
22:21:52 <Pseudonym> Never mind!
22:21:59 <dons> bos, got it
22:22:01 <ivanm> @seen LeCamarade
22:22:01 <lambdabot> I haven't seen LeCamarade.
22:22:08 <sorear> @uptime
22:22:09 <lambdabot> uptime: 2h 39m 8s, longest uptime: 9d 2h 23m 6s
22:22:13 <ivanm> ahhh
22:22:33 <sorear> manzano is dead, and the bot can't migrate :)
22:23:32 <ivanm> manzano?
22:24:09 <sorear> manzano.cse.unsw.edu.au.  it was a computer
22:24:13 <dons> sorear: its not dead. don't be a drama queen
22:24:25 <ivanm> heh
22:24:33 <sorear> i'll try :)
22:26:24 <dmwit> dons: http://buckwheat.stanford.edu/xmonad-my-try.png
22:28:03 <dmwit> My gimp-fu is weak, but...
22:28:19 <dons> its taking forever to connect for some reason
22:28:24 <ivanm> dmwit: nice!
22:28:54 <dons> ah i see. emphasising the lambda a bit
22:29:00 <dmwit> yeah
22:29:08 <atp> hi folks, quick question... i'm looking at the 99 haskell problems, just the solutions to the first 10 (since those are the ones i've already done), and i see a reference to a 'group' function that apparently is supposed to be in Prelude... and yet, using ghci, i can't seem to find it.  anyone know?
22:29:23 <Pseudonym> It is an X, as in X11, rather than a chi, right?
22:29:24 <dons> its in Data.List
22:29:29 <dons> Pseudonym: yeah
22:29:39 <atp> dons: was that directed at me?
22:29:51 <dons> Pseudonym: as in , http://www.cse.unsw.edu.au/~dons/tmp/xmonad-tri.png
22:29:53 <Pseudonym> xmonad :: (Monad m) => X m
22:29:54 <dons> atp, yeah.
22:29:56 <dons> ?index group
22:29:57 <lambdabot> Data.List
22:30:02 <atp> dons: ah, thanks a bunch :)
22:30:19 <ddarius> instance Monad X
22:30:40 <dons> newtype X a = X (StateT XState IO a)
22:30:40 <dons>     deriving (Functor, Monad, MonadIO, MonadState XState)
22:30:42 <dons> actually ;-)
22:30:58 <petekaz> monochrom: thanks for the help tonight.  I'm falling asleep here (1:30am) so I'm going to hit the sack.
22:30:59 <dons> newtype deriving is my favourite weapon this week. STAND BACK!
22:31:12 <atp> can you just derive Monad like that?
22:31:18 <dons> for newtypes, yes.
22:31:32 <atp> ah, i see, if it's isomorphic to another monad, right?
22:31:42 <atp> that makes sense i guess
22:31:47 <ivanm> Pseudonym: did you ever end up digging up your old vigenere cracker?
22:31:54 <monochrom> Good night petekaz. When you wake up, stuff will be available in email :)
22:31:54 <dons> similarly, you can derive Num and friends
22:32:12 <Pseudonym> ivanm: Oh, yeah, I did, but it's still not on a hard disk that is accessible from the outside world.
22:32:29 <ivanm> Pseudonym: fair enough... if/when it is, can you send it to me?
22:32:33 <Pseudonym> I wonder if you could make the X in the xmonad logo look more like the X11 logo.
22:32:34 <atp> yeah, like if you do Foo a = Foo (Int Integer a) deriving Num, right?
22:32:35 <Pseudonym> ivanm: Sure.
22:32:37 <ivanm> thanks
22:33:15 <atp> i guess that's a convenient thing about newtypes...
22:33:24 <atp> thanks, dons :)
22:33:51 <ddarius> atp: Newtype deriving is a GHC extension.
22:34:00 <atp> ddarius: oh, it is?
22:34:09 <bos> my wifi card chose an interesting time to die.
22:34:16 <atp> ddarius: is it an extension that will be merged into haskell prime eventually, or is it just ghc voodoo?
22:34:37 <SamB_XP> atp: one of these primes...
22:34:40 <SamB_XP> one of these primes!
22:34:41 <atp> hehe
22:34:43 * sorear thinks wireless data transfer is a really dumb idea
22:34:52 <dmwit> Pseudonym: Yeah, but another night.
22:34:53 * atp groans at SamB_XP...
22:35:03 <ddarius> I have no idea if it's being considered for Haskell', but it's a reasonable extension.
22:35:05 <dmwit> Time for going out!
22:35:15 <SamB_XP> oh. I can now make a bad joke without actually trying?
22:35:16 <SamB_XP> cool!
22:35:31 * ddarius has no idea what SamB_XP was getting at.
22:36:03 <SamB_XP> well, I figure Haskell' is going to be the name of the next Haskell standard from now on.
22:36:33 <ddarius> Well, the one after that will be Haskell''
22:36:49 <sorear> Yay unary!
22:36:58 <SamB_XP> Oh? I was assuming we were going to drop the prime and give it a real name.
22:37:03 <SamB_XP> like Haskell 2000
22:37:12 <SamB_XP> or Haskell ME
22:37:16 <igli> lol
22:37:27 <sorear> Haskell Pentium
22:37:30 <atp> hey, i have an incidental question.  from an implementation perspective, do a bunch of binded monad functions always execute in sequence, or do haskell compliers actually determine if the data being threaded through is used and possibly rearrange execution order in the event that there's no dependency conflict?
22:37:47 <ddarius> atp: (>>=) is a normal function.
22:37:59 <bos> dons: see anything interesting in the core?
22:38:19 <ddarius> atp: Uses of it get treated like every other function, they don't enforce sequencing at all.
22:38:20 <monochrom> Haskell Vista
22:38:27 <atp> ddarius: that's pretty cool :)
22:39:26 <ivanm> monochrom: no!!!!!
22:39:34 <SamB_XP> does MSR have a marketing department?
22:39:44 <ivanm> Haskell.Net? :p
22:40:14 <monochrom> "Haskell Vista: The CAF starts NOW!"
22:40:35 <monochrom> (You have to pronounce CAF the British way. :) )
22:41:07 <SamB_XP> monochrom: I still don't get it...
22:41:12 <monochrom> (And now too)
22:41:35 <monochrom> "the c-ah-f starts n-ah-w"
22:41:37 <ivanm> monochrom: and that is?
22:42:09 * ivanm still doesn't get it... is it meant to sound a bit like calf?
22:42:16 <monochrom> Yah
22:42:27 <ivanm> still not getting the presumed joke
22:42:45 <SamB_XP> probably the joke is on us -- and there is no joke!
22:43:06 <ivanm> heh
22:43:37 <monochrom> CAF refers to top level definitions.  main is one of them.  When you launch a Haskell Vista experience, execution begins from main, which is a CAF.
22:43:57 <ddarius> "I am monochrom"
22:44:06 <monochrom> hahahahahah
22:44:23 <ivanm> ok, kinda getting it now... I think
22:44:26 <SamB_XP> where does the punning come into it?
22:44:45 <monochrom> Well, it rhymes, and it's true.
22:44:46 <ivanm> that reminds me... I'm thinking of splitting my program into smaller sub-programs
22:45:08 <ivanm> is it possible to call the main function from one library from another?
22:45:17 <ivanm> can a non-Main library have a main function?
22:45:25 <SamB_XP> ivanm: well it could
22:45:31 <SamB_XP> it might not be terribly usefull
22:45:35 <monochrom> I think yes, but I don't know how.
22:45:36 <ivanm> *nod*
22:46:00 <ivanm> probably easier to have the main function in each library/file just get inputs and pass them to another function, and call that one for external calls?
22:47:24 <ivanm> OK, related question...
22:47:35 <ivanm> each sub-library/program outputs its results to a file
22:47:56 <ivanm> and the others all use these files, and if it doesn't exist they call the creation program
22:48:15 <ivanm> i.e. library/program foo creates file foo.dat, program bar requires foo.dat
22:48:30 <ivanm> if foo.dat exists, use it, otherwise run foo and then use foo.dat
22:49:04 <ivanm> now, if foo.dat doesn't exist, is it possible for foo to both create that file _and_ pass the results to the calling program?
22:49:12 <ivanm> so I'm not write a file, then read it in again?
22:49:42 <sorear> can't you just use make and a disk cache?
22:49:51 <ivanm> huh what?
22:49:57 <ivanm> didn't get that at all, sorear
22:50:28 <sorear> it sounds like you are describing the unix program make(1)
22:50:45 <sorear> and the optimization is just what disk caches are for
22:50:57 <ivanm> ummm... I don't believe I'm re-creating make
22:51:17 <ddarius> Hmm... building programs in a ramdisk...
22:51:30 <ivanm> no, I want to keep the files generated for future use
22:51:34 <kowey> dmwit: do you think you could cook up a jaggies-free version of http://www.haskell.org/haskellwiki/Image:Simple-haskell-logo.png ?
22:51:36 <lambdabot> Title: Image:Simple-haskell-logo.png - HaskellWiki
22:51:45 <ivanm> I'm splitting my latin squares program into three parts: shape generation, latin square generation, latin square filtering
22:52:00 <sorear> ivanm: you want '.'
22:52:12 <ivanm> and I want to design it such that if I have to re-run one program, I don't have to re-run the previous one
22:52:17 <ivanm> sorear: not quite...
22:52:53 <sorear> ivanm: you are creating mind-boggling amounts of data, no?  so it would be better to link the programs using lazy lists than files
22:53:05 <sorear> or better yet, stream fuse them :)
22:53:18 <ivanm> sorear: yes, that's what I'm doing atm (lists, not stream fuses)
22:53:45 <ivanm> but I want to design it such that, if I want to change the filtering function, I don't have to re-generate all the latin squares first, just load them off disk and filter through them
22:54:42 <sorear> ivanm: that sounds like a pretty bad idea.  i'm pretty sure i can generate latin squares at faster than 100MB/s, which is the maximum read throughput of my hd
22:55:10 <ivanm> sorear: it takes 5 days atm (hope to get it faster) to generate all order 5 partial latin squares...
22:55:15 <ivanm> disk writes are faster!!! :p
22:55:37 <sorear> erg, that sounds like a case of program inefficiency.
22:55:52 <ivanm> no, theres just that damn many
22:56:02 <Cale> I'm pretty convinced that the GHC and Ubuntu dev cycles are perfectly misaligned. :)
22:56:04 <ivanm> but yeah, there is an inefficiency which I'm planning on correcting
22:56:23 <ivanm> but previous versions (not by me) have run for > 2 weeks, with the workload spread over multiple machines
22:56:30 <igli> Cale: use a source based distro ;)
22:56:34 <ivanm> sorear: its super-exponential: n^(n^2)!
22:56:41 <Cale> igli: Nah, I just download the binary.
22:56:45 <monochrom> If we slow down GHC now, they will be aligned again!
22:56:46 <sorear> ivanm: and your processor is pegged all this time?
22:56:52 <ivanm> sorear: yup
22:56:59 <ivanm> with only 3 MB of RAM being used! :p
22:57:03 <sorear> ivanm: what is a partial latin square?
22:57:11 <Cale> Still, sucks to always be running GHC from /usr/local/
22:57:11 <ivanm> sorear: a latin square where gaps are allowed
22:57:24 <ivanm> so theres many more possibilities!
22:57:28 <sorear> ivanm: yeah, but there are dark corners there
22:57:33 <ivanm> in what way?
22:57:57 <monochrom> Cale: I have an SCIM question.  It provides "English/European".  Does it help with things like áéïöü?  How to do them?
22:58:08 <sorear> well, can every partial latin square be completed?
22:58:20 <ivanm> sorear: no, but that's beside the point
22:58:21 <Cale> monochrom: I usually just bind a compose key for those.
22:58:42 <Cale> monochrom: I replaced Caps Lock with compose, so I type Compose,a," for ä
22:58:54 <sorear> ivanm: it's an important question of the definition.  I thought a partial latin square was a subset of a complete latin square
22:58:58 <ivanm> sorear: just want to generate each possible way of creating an n*n array where each row and column has each of the values 1..n at most once
22:58:58 <Cale> and Compose,e,' for é
22:59:10 <ivanm> sorear: no, it isn't... other way round
22:59:12 <monochrom> Egads.  Thanks.
22:59:19 <sorear> ivanm: isn't that a complete latin square?
22:59:30 <ivanm> sorear: no, complete is _exactly_ once
22:59:41 <sorear> ah right.
22:59:47 <ivanm> I can send you the draft paper I did for my original attempt if you want more info
22:59:58 <ivanm> (my supervisor _still_ hasn't proof-read it yet :s )
23:00:05 <sorear> and what size are you working on now?
23:00:30 <sorear> 6x6 you said?
23:00:31 <ivanm> I get order 5 taking 5 days
23:00:39 <ivanm> *nod* I need at the very least order 6
23:00:48 <ivanm> to prove my supervisor wrong! ;-)
23:01:13 <ddarius> Down with generate and test, forward test and generate!
23:01:43 <ivanm> ummm.... so you're saying that the tests define the code?
23:01:48 <ivanm> inverse white-box testing?
23:02:14 <ddarius> Generate and test as in the common logic programming/listful style coding pattern.
23:03:15 * sorear writes an order 5 latin square gen in C
23:14:30 <bos> @seen dons
23:14:31 <lambdabot> dons is in #haskell. I last heard dons speak 42m 36s ago.
23:17:00 * dolio snickers.
23:17:17 <dolio> The current ruby quiz is trivially done with parser combinators.
23:17:39 <dfranke_> is there a class other than Ord that I should use for partial orderings?
23:18:36 <bos> not a standard one, no.
23:18:40 <monochrom> You may need to make your own class for that.
23:18:47 <sorear> ivanm: I'm ... impresses
23:19:00 <dfranke_> will anything catch fire if I just use Ord?
23:19:11 <sorear> ivanm: my latin square generator, unoptimized c, runs at 20% cpu
23:19:40 <bos> the typechecker won't help you if you use your type incorrectly.
23:19:56 <monochrom> you have some troube defining "compare".
23:20:32 <bos> monochrom: i find the thread about norvig's spellchecker amusing. i wrote my own transliteration, and found space and time performance to be awful.
23:21:05 <bos> i have space performance under control now, but my haskell version is still 25% the speed of the python  version, even though i'm using bytestrings.
23:21:55 <dfranke_> Probably won't end the world if I just have it return _|_.
23:22:41 <sjanssen> bos: are you using comparison on ByteStrings?
23:22:54 <bos> yes.
23:23:10 <bos> but it's building the training set that takes all the time.
23:23:18 <sjanssen> there's an issue with that -- it calls C memcmp, which turns out to be expensive
23:23:23 <bos> oh.
23:23:41 <bos> i'm spending 40% of my time just lowercasing words.
23:23:52 <sjanssen> so expensive that it loses to [Char] for smallish strings
23:24:04 <ivanm> sorear: my latin square generator is based on birds sudoku solver
23:24:10 <bos> sjanssen: eek!
23:24:31 <ddarius> Bird rocks.
23:24:35 <ivanm> *nod*
23:24:49 <sorear> ivanm: hmm.  I can generate 37 million partial latin squares per second, with -O0
23:24:51 <bos> hey, look at that! it does use memcmp!
23:24:52 <sorear> (gcc)
23:24:59 <ivanm> except I have to optimize the hell out of his code to suit my purposes, since after all they're not _quite_ the same
23:25:12 <ivanm> sorear: size?
23:25:22 <sorear> ivanm: 5x5
23:25:32 <ivanm> mine also works on only creating individual members of each isotopic class...
23:25:51 <ivanm> i.e. if you permute the rows, columns or numbers then its in the same isotopic class
23:25:59 <sorear> ivanm: ooh?
23:26:12 <sorear> 71 million with -O3
23:26:20 <ivanm> I get about 80 3*3... can't remember 4*4, and didn't want to do a plain counting run with 5*5 ;-)
23:26:41 <sorear> this is per-second, not total
23:26:57 <ivanm> *nod*
23:27:24 <ivanm> it takes about 15 seconds to get around 10000 or so 4*4
23:27:35 <sorear> obviously, I can't compare performance, since I'm making no efforts re isotopicity.
23:27:43 <ivanm> *nod*
23:27:54 * sorear rewires for 4x4, and bechmarks.
23:28:46 <ivanm> the reason I used bird's sudoku solver was twofold: 1) it looked the be the most adaptable/extensible out of all the ones on the wiki page
23:28:57 <ivanm> and more importantly, 2) it was the only one I understood at the time :p
23:29:09 <ivanm> but the general algorithm works pretty well
23:29:32 <ivanm> especially when looking at completion of a partial latin square... due to laziness, it never generates more than 2 completions! :D
23:29:59 <sorear> ok, my solver has found 2 billion 4x4s ... *debug debug*
23:30:11 <ivanm> heh
23:30:29 <ivanm> > 4 ^ (4 ^ 2)
23:30:33 <lambdabot>  4294967296
23:30:48 <ivanm> that's an extremely inaccurate upper bound...
23:31:21 <ivanm> my supervisor once did a paper finding and categorising all PLSs of order no greater than 6
23:31:40 <ivanm> but I don't think he gave definitive numbers of how many exist
23:31:40 <sorear> supervisor ... this is a phd project?
23:31:59 <ivanm> sorear: no... I did a summer project on this, and I'm continuing it under the guise of a crypto assignment
23:32:06 <ivanm> since my supervisor is my crypto lecturer
23:32:13 <ivanm> and he wants me to try and finish it
23:32:23 <ivanm> since I'm re-doing and actually finishing some old work of his
23:32:49 <ivanm> brb
23:34:01 <sorear> . . . .
23:34:02 <sorear> . . . .
23:34:02 <sorear> . . . D
23:34:05 <sorear> C B B D
23:34:08 <sorear> =======
23:34:11 <sorear> that's one of my "partial latin squares"
23:36:36 <ivanm> back
23:36:48 <ivanm> sorear: can't have 2 Bs and 2 Ds in the same row/column
23:36:54 <sorear> I know :)
23:36:59 <ivanm> want me to send you a pdf of my code/paper?
23:37:03 <sorear> i forgot a few manips
23:37:07 <ivanm> explaining better what I'm doing?
23:37:07 <ivanm> heh
23:37:14 <sorear> yeah, might as well
23:38:53 <ivanm> sending...
23:39:11 <sorear> well, I've got the offer but no idea what to do :)
23:39:19 <sorear> ps. also behind a nat
23:39:28 <ivanm> oh.... want me to email it to you?
23:39:31 <sorear> if you have a url, that I know what to do with
23:39:42 <ivanm> hmmm.... I'll try and upload it somewhere...
23:40:12 <sorear> anyway, I'm getting real partial latin squares now.
23:40:42 <sorear> 590400 of size 4x4 - correct?
23:40:55 <sorear> that took 1/10 of a second to compute :)
23:41:15 <ivanm> http://users.tpg.com.au/kataryna/Report.pdf
23:41:21 <ivanm> or would you prefer email?
23:41:33 <sorear> nah, http is slightly better.
23:41:46 <sorear> dl'd
23:42:04 * sorear starts X to read it
23:42:47 <ivanm> I had a listing of how many I had in total somewhere, but can't seem to find it :s
23:44:36 <sorear> looking neat.
23:45:01 * ivanm quickly runs counter in ghci
23:45:09 <ivanm> takes about 30 seconds in ghci IIRC
23:45:13 <ivanm> ahhh, here we are
23:45:20 <ivanm> 12272 isotopic classes found
23:45:48 <ivanm> but most of them probably contain double ups, as my code isn't currently perfect (I think I know how to fix the bugs though(
23:47:08 <ivanm> > 12272 * (product [1..4])^3
23:47:12 <lambdabot>  169648128
23:47:25 <ivanm> heh.... that's roughly how many in total I estimate for there to be
23:47:31 <ivanm> that's way too much though...
23:47:45 <ivanm> e.g. the 0 PLS... can't really permute that to get a new one
23:49:19 <sorear> all my pls look correct, except for the ones at the bottom that are scrambled by calling printf() in a signal handler :)
23:50:13 <ivanm> heh
23:50:36 <sorear> "and implemented by Graham Hutton citehutton."
23:50:43 <sorear> is that a typo or a note to self?
23:50:47 <ivanm> yeah, its a draft only
23:51:09 <sorear> order 5 is taking a lot longer ;)
23:51:09 <ivanm> it should be \cite{hutton}, but I've got no idea how to cite code
23:51:13 <ivanm> so I got rid of the \
23:51:27 <ivanm> since I'm waiting for my supervisor to hurry up and read through it and tell me :p
23:52:09 <fuzan> hey all.
23:52:28 <ivanm> hey fuzan, ekidd
23:52:50 <ekidd> Hello.
23:54:17 <ivanm> ekidd: I don't know if its because I came in too late, but I didn't really understand your latest blog post
23:54:28 <sorear> gave up after 2m40s, with 6 billion order-5 pls found
23:54:31 <fuzan> firstly, i'm picking up on an old project. i'm using Binary to build packets (little-endian) and send them out into the nether. issue: the put instance for ByteStrings seems to add all sorts of padding and length. To avoid this, i'm converting the bytestring back to a normal string, and mapM_'ing put over that. That works, however, I think this is a retarded solution.
23:54:35 <ivanm> sorear: heh, exactly
23:54:36 <ekidd> ivanm: Yeah, I'm not sure if it's clear enough.
23:54:49 <ekidd> I should have taken the extra time to do some animations.
23:54:52 <sorear> ivanm: reply-to?
23:54:58 <ivanm> ekidd: then again, I got last in the first paragraph (probability distributions? what the?) :p
23:56:09 <fuzan> so, most importantly: what methods exist for manipulating the default serilization methods for certain types (ByteStrings) ?
23:56:23 <ekidd> ivanm: Yeah, that might make it a bit harder!
23:56:23 <sorear> ivanm: so your project is to count the premature-critical pls?
23:56:28 <ivanm> sorear: yeah
23:56:32 <fuzan> and if not possible, is there any way to do mapM_ over a ByteString? :(
23:56:38 <ivanm> my supervisor did this a few years ago, but missed quite a few...
23:56:48 <ivanm> he also theorized that none exist for n >= 6
23:56:59 <ekidd> Honestly, I posted that article too quickly, because it was neat result and I wanted to write it up before anybody else did. :-)
23:57:16 <ivanm> "missed quite a few" = double up on one or two and missed about 6 all up IIRC ;-)
23:57:34 <ivanm> ekidd: fair enough, maybe I have to find your original 4 parts and read them first
23:58:35 <ekidd> ivanm: Part 3 is the one with the big payoff. You could start with that and then go back and read parts 1 and 2 as needed.
23:59:24 <ivanm> *nod*
