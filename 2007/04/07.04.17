00:02:53 <fuzan> retarded fix, lol.
00:03:16 <fuzan> delete a stray '\r' from configure.ac, autocreconf
00:07:40 <dons> mmm
00:14:00 <DRMacIver> Morning
00:23:02 <fuzan> dons: where's showq provided?
00:23:19 <fuzan> i can't find it in scripts/
00:23:46 <fuzan> oh, my. my fault.
00:24:58 <aes2> Can I use a finger tree to also keep track of a reversed version of a sequence that itself in represented in the finger tree in the the measurements?
00:25:19 <aes2> /s/in/is
00:30:48 <Pseudonym> http://andrew.bromage.org/darcs/diff/
00:30:50 <lambdabot> Title: Index of /darcs/diff
00:30:52 <Pseudonym> diff in 120 lines
00:31:07 * Pseudonym might suggest this for SPJ's tutorial
00:41:36 <fuzan> hmm, can't seem to get lb to find the ShowQ interface
00:47:19 <fuzan> alas, i spotted th eissue once again.
01:07:18 <MarcWeber> Is there a run..Command/Process function which does escaping ( eg ">" ) and where stdin/out is not redirected so they can still be accessed by console?
01:09:37 <Cale> MarcWeber: escaping?
01:10:35 <Cale> When you call runInteractiveProcess, you pass the filename of the executable, and the list of arguments as the exact strings you want that executable to receive
01:11:07 <Cale> You'll get some input and output handles, which I suppose you have to manage yourself if you'd like the user to interact with the process.
01:11:26 <Cale> There's a library called HSH which possibly implements some nicer ways to manage that.
01:11:51 <fuzan> @check \i -> i > 5 (i :: Int)
01:11:53 <lambdabot>   add an instance declaration for (Num (Int -> Int))
01:12:01 <fuzan> how would you get it to work on simple expressions?
01:12:08 <Cale> er, oh, perhaps you want runProcess with Nothing passed as each of the handles?
01:12:33 <Cale> fuzan: you're applying 5 to i there
01:12:41 <Cale> (as if it were a function)
01:12:49 <Cale> @check \i -> (i :: Int) > 5
01:12:51 <lambdabot>  Falsifiable, after 0 tests: 0
01:13:05 <fuzan> hmm.
01:13:21 <Cale> \i -> i > 5 (i :: Int)
01:13:23 <Cale> is the same as
01:13:26 <Cale> \i -> i > 5 i
01:13:33 <fuzan> ohh.
01:13:36 <fuzan> you're entirely correct :)
01:13:38 <Cale> up to type signatures
01:13:56 <fuzan> I conviced myself I was specifying the type. I got confused looking at some examples :)
01:14:06 <MarcWeber> Cale: Right. I don't know how to bind the handles to stdin/stdout/stderr of my main application
01:14:30 <MarcWeber> Cale: I'll have a loo k at HSH
01:14:45 <Cale> You want to pass over control of stdin/stdout/stderr to the program?
01:15:08 <MarcWeber> No but to the user
01:16:13 <MarcWeber> Cale: I want to call ssh. If the user didn't copy the public key I want him still be able to enter the passphrase
01:16:52 <quicksilver> you shouldn't need to do anything special to make that work
01:17:03 <quicksilver> as a subprocess, ssh will 'share' your stdin
01:17:20 <quicksilver> it will take over when you launch it and be able to accept a password
01:17:23 <MarcWeber> quicksilver: Even if I have a handle to stdin?
01:17:37 <quicksilver> I don't know what you mean by that question
01:17:41 <quicksilver> everyone has a handle to stdin
01:17:45 <quicksilver> it's called stdin :)
01:17:55 <MarcWeber> quicksilver: When using runInteractiveCommand :: String -> IO () there is no problem
01:18:44 <MarcWeber> But when using run...Process:: String -> [Arg] ... -> Handles -> IO () it won't share, right?
01:19:03 <quicksilver> well it will, if you choose to give it your stdin
01:19:14 <MarcWeber> quicksilver: Then it will close it ;)
01:20:06 <quicksilver> oh that's odd
01:20:09 <quicksilver> why does it do that?
01:20:41 <fuzan> @check (sum [1..]) < (product [1..])
01:20:47 <lambdabot> Plugin `check' failed with: IRCRaised Data.ByteString.last: empty ByteString
01:20:50 <fuzan> :(
01:22:21 <quicksilver> MarcWeber: you can probably dup your stdin
01:22:28 <quicksilver> MarcWeber: if you're on a POSIX os
01:22:35 <quicksilver> MarcWeber: I don't know why it closes them, though
01:25:18 <Cale> Maybe you can't dup handles on some OS?
01:26:14 <quicksilver> but runProcess is synchronous, isn't it?
01:26:37 <quicksilver> so it doesn't need to dup the handle, just 'borrow' it
01:26:37 <Cale> doesn't seem to be
01:26:41 <quicksilver> (like runCommand)
01:26:51 <Cale> Seems asynchronous to me
01:27:05 <quicksilver> ah, maybe it is
01:27:21 <quicksilver> haddock could be more explicit about that, really :)
01:29:02 <dolio> fuzan: Check that the sum of all natural numbers is less than their product? :)
01:29:30 <quicksilver> fuzan: that wasn't a property, it was just a bool
01:29:40 <quicksilver> > sum [1..] < product [1..]
01:29:45 <lambdabot> Terminated
01:29:59 <quicksilver> maybe you want @check \l -> sum l < product l
01:30:07 <dolio> @check True
01:30:09 <lambdabot>  OK, passed 500 tests.
01:30:11 <fuzan> tha tmakes more sense :)
01:30:26 <int-e> > zipWith (<) (scanl (+) 0 [1..]) (scanl (*) 1 [1..])
01:30:27 <lambdabot>  [True,False,False,False,True,True,True,True,True,True,True,True,True,True,Tr...
01:30:27 <fuzan> @check \l -> sum l < product (l :: Integer)
01:30:29 <lambdabot>  Couldn't match expected type `Integer' against inferred type `[a]'
01:30:50 <fuzan> @check \l -> sum l < product (l :: [Integer])
01:30:51 <lambdabot>  Falsifiable, after 2 tests: [-2,1]
01:31:10 <fuzan> i'm glad it's checking sums of negative numbers, lol
01:31:22 <fuzan> can you configure the generators with @check ?
01:31:31 <fuzan> or would you just specify a requirement
01:31:41 <int-e> @check \l -> all (>0) l ==> sum l < product (l :: [Integer])
01:31:43 <lambdabot>  Falsifiable, after 2 tests: [1]
01:33:11 * dcoutts notes that binary deserialisation is an applicative functor
01:33:15 <int-e> @check \l -> let l' = map (succ . abs) l in sum l' < product (l' :: [Integer]) -- or maybe just translate the numbers
01:33:16 <lambdabot>  Falsifiable, after 1 tests: [0]
01:34:03 <quicksilver> @check \l -> all (>0) l ==> sum l <= product (l :: [Integer])
01:34:05 <lambdabot>  Falsifiable, after 24 tests: [2,1,1,3]
01:34:12 <quicksilver> :)
01:34:26 <int-e> dcoutts: but not a monad?
01:34:37 <Cale> @check \l -> all (>1) l ==> sum l <= product (l :: [Integer])
01:34:39 <lambdabot>  Arguments exhausted after 175 tests.
01:34:57 <fuzan> cute :)
01:35:05 <dcoutts> int-e: that too, but most interestingly it's an applicative functor, since that fact allows us to optimise it
01:35:57 <dcoutts> eg consider a constructor C :: Int -> Int -> Foo
01:36:03 <dcoutts> C <$> Get.int <*> Get.int
01:36:21 <dcoutts> this gives us a form of code that is much easier to work with than:
01:36:42 <dcoutts> do a <- Get.int; b <- Get.int; return C a b
01:36:59 <int-e> dcoutts: every monad is an applicative functor, I thought.
01:37:06 <dcoutts> int-e: that's true
01:37:16 <dcoutts> the point is we want to do a single bounds check for those two Get.int's
01:37:18 <duey> Hi, what does this error mean "Instance of Fractional Integer required for definition of remfix"
01:37:35 <Cale> duey: It means that you probably applied / to some integers
01:37:36 <int-e> oh, you mean matching is easier in that form.
01:37:42 <duey> Yep
01:37:42 <dcoutts> int-e: yes
01:37:54 <Cale> duey: If you want integer division, that's `div`
01:38:06 <Cale> or else convert the integers to something else with fromIntegral
01:38:11 <dcoutts> int-e: much much easier, since it's not full of '\x ->' lambdas that you get from >>= style code
01:38:34 <dcoutts> int-e: matching under lambdas is more or less impossible with current ghc rules system
01:38:46 <int-e> dcoutts: yes. that makes sense.
01:38:59 <dcoutts> but it's just nice that actually we only really need it to be an applicative functor
01:39:15 <dcoutts> other uses might want it to be a monad possibly
01:39:16 <duey> Cool, thanks :)
01:40:37 <LeCamarade> But if functional programming is this good, why isn't it mainstream? Don't get LB to slap me. Just answer.
01:40:37 <LeCamarade> I'm confused about it, as you may imagine.
01:40:53 <duey> LeCamarade: because people don't like it
01:41:04 <duey> I guess if you are brought up with functional, you program functional
01:41:04 <dcoutts> LeCamarade: how many years did it take for OOP to go mainstream?
01:41:13 <LeCamarade> @google pissed off about functional programming
01:41:16 <lambdabot> http://lambda-the-ultimate.org/node/678
01:41:16 <lambdabot> Title: From Perl Monks: "pissed off about functional programming" | Lambda the Ultimate
01:41:23 <dcoutts> heh
01:41:27 <Cale> LeCamarade: Inertia.
01:41:45 <Syzygy-> LeCamarade: Bits and pieces flow into the mainstream, though slowly. And the purer kinds of functional programming are very different in mindset than the imperative - so people who don't care about neat features, but rather just want the job done, tend to stay with what they know.
01:42:03 <Cale> LeCamarade: People learn to program with non-FP languages, and then don't want to spend the effort to learn anything too different from that.
01:42:06 <dcoutts> LeCamarade: my point is, OOP took about 15 years or more, and FP is even more radical for most programmers than the transition to OOP
01:42:08 <nominolo> @check \xs -> [ x | Just x <- xs] == map fromJust $ filter isJust xs
01:42:09 <lambdabot>  Couldn't match expected type `[t]'
01:42:23 <nominolo> @check \xs -> [ x | Just x <- xs] == map fromJust $ filter isJust (xs :: [Int])
01:42:24 <lambdabot>  Couldn't match expected type `[t]'
01:42:52 <Syzygy-> :t filter
01:42:55 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
01:43:04 <LeCamarade> dcoutts: But if we spend all that time and money tracking down bugs that _don't exist_ in this side, isn't it saner to ... dcoutts FP seems straight-forward to me. In fact, I think procedural is a horrid perversion. This while I have Java in one terminal. Blame the boss.
01:43:12 <Syzygy-> @check \xs -> [ x | Just x <- xs] == map fromJust $ filter isJust (xs :: [Maybe Int])
01:43:13 <lambdabot>  Couldn't match expected type `[t]'
01:44:02 <Syzygy-> :t map fromJust $ filter isJust (xs :: [Maybe Int])
01:44:05 <lambdabot> Not in scope: `xs'
01:44:11 <Syzygy-> :t \xs -> map fromJust $ filter isJust (xs :: [Maybe Int])
01:44:14 <lambdabot> [Maybe Int] -> [Int]
01:44:22 <Syzygy-> :t \xs -> [ x | Just x <- xs]
01:44:25 <lambdabot> forall t. [Maybe t] -> [t]
01:45:04 <Syzygy-> @check \(xs :: [Maybe Int]) -> [ x | Just x <- xs] == map fromJust $ filter isJust xs
01:45:04 <lambdabot>  Parse error in pattern
01:45:05 * LeCamarade goes off to #haskell-blah to scream at the walls.
01:45:06 <Cale> LeCamarade: yep. We've all had this feeling that the rest of the world is insane. You get used to it.
01:45:10 <Syzygy-> Nope.
01:45:21 <nominolo> Syzygy-: :)
01:45:24 <raxas> LeCamarade: it's just pride and clerical academism of fp people which prevents wide adoption. they do not care about interfacing to existing code and technologies.
01:45:41 <Cale> A friend of mine said the other day "There should be a word for the moment of horror when one realizes that, despite displays of great confidence, the people around you have no idea what the fuck they are doing."
01:45:44 <Syzygy-> @check \xs -> [ x | Just x <- (xs :: [Maybe Int])] == map fromJust $ filter isJust xs
01:45:46 <lambdabot>  Couldn't match expected type `[Int]'
01:45:57 <Syzygy-> @check \xs -> [ x | Just x <- (xs :: [Maybe Int])] == map fromJust $ filter isJust (xs :: [Maybe Int])
01:45:58 <lambdabot>  Couldn't match expected type `[Int]'
01:46:02 <nominolo> Syzygy-: I guess the list comprehension is more readable, anyways :)
01:46:04 <Syzygy-> Ok. I give up.
01:46:16 <LeCamarade> raxas: I thought of that, too, the first time. The academics seem to patronise FP and threaten out the rest. It may be a reason.
01:46:20 <dcoutts> raxas: pay us to spend time on that stuff and we will. You really can't get academic funding for 'development' work. So nobody pays and it only gets done on volunteer time.
01:46:24 <Syzygy-> nominolo: AND it doesn't use fromJust, which is a virtue. :)
01:47:00 <nominolo> > [ x | Just x <- [Just 4, Nothing, Nothing, Just 2] ]
01:47:02 <lambdabot>  [4,2]
01:47:08 <int-e> Syzygy-: $ has lower precedence than ==
01:47:08 <LeCamarade> raxas: But many languages (JavaScript, Python, Ruby) that I do have things that are basic blocks in functional, and they are what _rocks_ in those languages. That should be a door-opener for FP. But it isn't.
01:47:42 <Cale> It is actually, it's just not as big a door as you'd think.
01:48:02 <dcoutts> raxas: academics get funded to write papers, funding bodies say that for development work we should get commercial funding, but it's hard to convince companies of 'unproven' stuff. So there's this gap where nobody pays for the work.
01:48:10 <quicksilver> even perl has 'map' and (ugly) lambdas
01:48:48 <jward> I just started learning Haskell as my first functional language last week.  It has the stigma of being hard, useless (from an employement perspective), acedemic, and deeply unfriendly.
01:48:59 <quicksilver> raxas: in that case how do you explain all the existing interfaces to existing code and technologies?
01:49:13 <haraldk> Anyone built Yi from darcs recently?
01:49:17 <johnnowak> LeCamarade: I think that academics appear to "patronize FP" simply because there's more interesting work to be done there at the moment. Type theory makes for good papers.
01:49:31 <Cale> jward: at least it's mostly lost the stigma of being slow
01:49:57 <jward> Cale:  People use Ruby... I think slow has become fasionable ^_^
01:50:05 <Cale> jward: haha
01:50:22 <Syzygy-> @check \xs -> ([ x | Just x <- xs]) == (map fromJust $ filter isJust (xs :: [Maybe Int]))
01:50:23 <lambdabot>  OK, passed 500 tests.
01:50:28 <Syzygy-> int-e: Ah.
01:50:57 <raxas> dcoutts: python has the same age as haskell. python is an industrial success. haskell is not. why?
01:51:07 <Syzygy-> jward: I don't find it unfriendly - but that's including the community, and to a certain extent ignoring the error messages.
01:51:22 <dolio> How often is the technically superior choice (in any area) mainstream anyways?
01:51:25 <quicksilver> raxas: idiots can program python. idiots are cheap.
01:51:27 <Syzygy-> raxas: python is much less of a cognitive shift from more spread programs.
01:51:31 <johnnowak> raxas: why is windows an industrial success?
01:51:36 <dcoutts> raxas: python is a simple step away from the experience of the mainstream imperative programmer
01:51:37 <quicksilver> raxas: hire monkeys and you can pay peanuts
01:51:53 <johnnowak> quicksilver: i thought monkeys ate bananas.
01:52:06 <raxas> thats pride and academic clericalism you just showed I speak of
01:52:07 <Cale> I think that a lot of people don't realise, when they start out in programming Haskell, that a lot of the time they spend "fighting with the compiler", is actually time they'd have spent "fighting with the debugger" in other languages.
01:52:12 <johnnowak> maybe you're living in american and hiring elephants
01:52:26 <quicksilver> raxas: no, it's sarcasm and an acerbic sense of humour
01:52:38 <quicksilver> johnnowak: they like bananas, but peanuts are cheaper :)
01:52:46 <Cale> This becomes more obvious when, after having programmed in Haskell for some time, one returns to programming in another language, especially if that language is dynamically typed.
01:52:47 <haraldk> Cale: That may be true, but with error messages being what they are, the difference may not always be appreciable ;-)
01:53:05 <johnnowak> Cale: i don't think that's necessarily true.
01:53:09 <Cale> haraldk: Hey, at the very least, you have a line number!
01:53:10 <Syzygy-> raxas: As a fullblown academic, I have issues with characterising this as academic pride anc clericalism
01:53:13 <Syzygy-> :P
01:54:24 <Cale> johnnowak: In what respect?
01:54:48 <Cale> Of course, I'm not claiming that all bugs are caught by the typechecker. Just a very significant number of them.
01:55:02 <haraldk> Cale: not always (a line number, that is). Like now, when the build script tells me to report a ghc bug
01:55:09 <haraldk> (but I don't think it is)
01:55:15 <Cale> haraldk: Oh?
01:55:17 <LeCamarade> quicksilver: Python has comprehensions, map, lambda, higher-order funcs, and those rock. But they don't turn the whole Python community into sweaty FP fans, when you tell them everything in Haskell is like that.
01:55:31 <Cale> If the thing is telling you to report a GHC bug, there's definitely a bug in GHC.
01:56:12 <dcoutts> LeCamarade: the FP stuff in python does feel natural, it's kind of bolted on
01:56:17 <johnnowak> Cale: understanding the type system in haskell requires a sophistication one doesn't need to get started with python. one needs to understand at least the basics of the system to understand the errors ghc spits out. with python, it is often more clear what the problem is. also, some classes of problems are avoided via runtime polymorphism, all containers being heterogeneous, etc.
01:56:17 <haraldk> Yup. Got yi from darcs, followed build instructions, compiler error message when starting yi
01:56:24 <dcoutts> LeCamarade: erm does/doesn't
01:56:51 <johnnowak> Cale: that's not to say that I don't think you're right about many circumstances, but I think it is an overgeneralization
01:57:00 <Cale> johnnowak: Problems are avoided by heterogeneous containers?
01:57:05 <quicksilver> LeCamarade: I think the language is less relevant than the programmer, in some sense. You can write excellent code in most languages.
01:57:19 <quicksilver> LeCamarade: haskell just makes writing (a certain kind of ) excellent code easier
01:57:25 <duey> watching this rant is so much better than doing zzzhaskell assignments
01:57:46 <quicksilver> LeCamarade: python makes slightly different things easy, but it also makes many other things less easy (less easy to get bug-free, in particular)
01:57:57 <johnnowak> Cale: for a beginning programmer, understanding why containers might be homogenous and understanding their types is simply more complex than putting any A in any B. i'm not suggesting it makes things easier in the long run
01:58:03 <Cale> I've only ever had the experience of heterogeneous containers allowing me to put something into them which shouldn't have been there anyway.
01:58:47 <Cale> And then having to work out how that item ended up in them, somewhere far away from the code which put it there.
01:59:01 <raxas> quicksilver: that's true haskell is superior to any imperative language. but still there is no good and simple way to adapt it with existing software
01:59:30 <johnnowak> even something as simple as "print 1 + 2" demonstrates why python isn't simply putting offer errors the compiler would catch
01:59:43 <LeCamarade> quicksilver: That's right. Even Java code can be excellent. It's just that, in the end, writing a whole new class just because you want to iterate ... that's not worth it.
02:00:07 <johnnowak> and even the error for "print 1 + 2" in ghci is completely incomprehensible to a new programmer
02:00:08 <Cale> johnnowak: hm?
02:00:19 <duey> could someone explain what a "composition of sections" is?
02:00:29 <Cale> print 1 + 2 in Haskell is not parenthesized correctly
02:00:36 <duey> or redirect me to some usefull documentation
02:00:43 <Cale> It would be print (1 + 2)
02:01:18 <Cale> The error you get is that there's no instance of Num for IO ()
02:01:21 <quicksilver> I've taught Java using only homogenous containers (arrays)
02:01:22 <johnnowak> Cale: aye, but the error message doesn't make it clear. the python versus does what's "expected", at least for some definition of expected.
02:01:22 <raxas> considering advanced development tools, integrated ides for mainstream languages, haskell is like Cinderella
02:01:28 <quicksilver> and that didn't confuse the students at all
02:01:36 <quicksilver> in fact, they liked homogenous containers
02:01:47 <quicksilver> 'an array of Shapes' made sense to them
02:01:58 <Cale> because you're treating (print 1) as a number
02:02:07 <johnnowak> Cale: i understand why it is happening
02:02:10 <Cale> that should be obvious to anyone who knows the basics of the syntax
02:02:21 <Cale> (once it's pointed out by the compiler at least)
02:02:24 <quicksilver> Cale: I think that's a bit harsh of you :)
02:02:38 <Cale> Well, once you know that function application happens first
02:02:41 <fuzan> I kind of wish I had a nice Haskell IDE with emacs commands.
02:02:43 <Cale> and then operators
02:02:46 <quicksilver> Cale: I don't think 'precedence of application is highest' is a particularly natural thing to beginning programmers
02:03:00 <Cale> Well, we do say it pretty early on, I hope :)
02:03:08 <quicksilver> I agree with johnnowak that that error message is pretty nasty
02:03:11 <quicksilver> Cale: say it, sure
02:03:17 <quicksilver> Cale: but say it /= they understand it
02:03:22 <Cale> By the time you get to doing IO, it should be clear :)
02:03:32 <johnnowak> quicksilver: homogenous containers were probably a bad example :)
02:03:43 <jward> Some people like myself have very long periods of extream stupidity.
02:03:43 <Cale> duey: a composition of sections?
02:03:54 <duey> indeed
02:03:58 <joelr1> good morning
02:04:00 <quicksilver> duey: a section is a partially applied operator
02:04:03 <duey> its a question in the SOE book
02:04:04 <quicksilver> duey: like (*2)
02:04:12 <duey> hmmm
02:04:15 <quicksilver> duey: a composition is several in a row, composed as functions
02:04:23 <Cale> and a composition is an expression where functions are being combined with (.)
02:04:26 <quicksilver> :t (*2) . (+1) . (*3)
02:04:28 <lambdabot> forall a. (Num a) => a -> a
02:04:39 <quicksilver> > (*2) . (+1) . (*3) $ 8
02:04:40 <duey> makes sense
02:04:41 <lambdabot>  50
02:04:41 <duey> thanks
02:04:59 <quicksilver> "multiply by 3, add one and then multiply by two"
02:06:01 <johnnowak> duey: just read the . as "follows"
02:06:04 <Cale> You can also have sections which go the other way
02:06:04 <fuzan> i really am starting to dislike pointfree syntax :)
02:06:10 <Cale> > (^2) 5
02:06:12 <lambdabot>  25
02:06:12 <Cale> > (2^) 5
02:06:14 <lambdabot>  32
02:06:19 <fuzan> other than for extreme simple cases
02:06:42 <duey> hmm
02:06:44 <Cale> fuzan: fix ((0:) . scanl (+) 1)
02:07:12 <fuzan> see? that's ridiculous :)
02:07:22 <dolio> It is?
02:07:25 <fuzan> missing arguments that are left to be inferred.
02:07:36 <Cale> > liftM2 (,) (+5) (+7) 8
02:07:38 <lambdabot>  (13,15)
02:07:43 <dolio> Apparently I've been here too long.
02:07:44 <quicksilver> > ("put the "++) . (++" in the box") $ "cat"
02:07:45 <lambdabot>  "put the cat in the box"
02:07:58 <quicksilver> duey: a non-numerical example of a composition of functions :)
02:08:05 <fuzan> i mean, unless smmeone knows hte type of every function
02:08:13 <fuzan> point-free syntax can be incredibly confusing.
02:08:26 <fuzan> from an engineering perpsective, it's not a useful feature.
02:08:30 <duey> yeh, I am a little confused as to how this would be useful
02:08:33 <Cale> The type of everything should be the first thing you think about :)
02:08:33 <fuzan> even though at times, it cna be really cool.
02:08:38 <fuzan> i agree.
02:08:51 <johnnowak> duey: people often call it "pointless" instead of "pointfree" for a reason :)
02:09:01 <fuzan> but for longterm readability, stick to lambda abstractions.
02:09:04 <duey> haha
02:09:10 <Cale> > let map f = foldr ((:) . f) [] in map (*2) [1..10]
02:09:12 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
02:09:25 <Cale> Sometimes partially-points-free is good :)
02:09:38 <fuzan> > filter (\x -> even (x + 1)) [1..10]
02:09:40 <lambdabot>  [1,3,5,7,9]
02:09:55 <Cale> > filter (even . (+1)) [1..10]
02:09:57 <lambdabot>  [1,3,5,7,9]
02:10:01 <fuzan> beat me to it :)
02:10:10 <dolio> > filter odd [1..10]
02:10:12 <lambdabot>  [1,3,5,7,9]
02:10:15 <fuzan> in this case, pf is more readable
02:10:43 <fuzan> but when you start dropping variables on functions that aren't basic prelude, I have to sit and stare for more than 10 seconds.
02:10:46 <haraldk> I don't know, I think perhaps "odd" is a little better
02:10:57 <LeCamarade> But, in the end, the world is trapped in the imperative. Everything from GNU and Microsoft is done in C-inspired languages. But the light I see is that the new Languages that Don't Suck (Ruby, for example) allow FP. And I learnt closures in JavaScript, which is where every other next-generation hacker will begin. So, yeah, there is hope.
02:11:11 <quicksilver> duey: (*2) is more concise than (\x -> x*2)
02:11:15 <johnnowak> fuzan: this sort of concept would be better in a language with keyword syntax for function invocations
02:11:27 <johnnowak> something like smalltalk
02:11:31 <quicksilver> duey: (+1) . (*2) may or may not be better than (\x -> x*2 + 1), it's a matter of taste
02:11:52 <duey> Oh I see
02:12:02 <duey> so it allows you to remove \x
02:12:05 <quicksilver> right
02:12:08 <fuzan> sometimes people do retarded shit. like mad flipping to make sure they can fold over a list when the parameters are out of order.
02:12:11 <fuzan> i really dislike that.
02:12:15 <mux> morning haskellers :)
02:12:17 <quicksilver> it's a way of making lambda abstractions implicit
02:12:17 <Cale> Certainly, as the polynomials get more complicated, lambdas get better.
02:12:18 <vincenz> Hello
02:12:36 <Cale> @pl \x -> 5*x^2 + 10*x + 17
02:12:37 <lambdabot> (17 +) . ap ((+) . (5 *) . (^ 2)) (10 *)
02:12:38 <fuzan> johnnowak: i've never looked at smalltalk :) I should.
02:12:52 <johnnowak> fuzan: aye, and Io as well
02:13:11 <vincenz> Anyone familiar with any HOLLs?
02:13:13 <Cale> @pl \x -> 3*x^3 + 5*x^2 + 10*x + 17
02:13:13 <lambdabot> (17 +) . ap ((+) . ap ((+) . (3 *) . (^ 3)) ((5 *) . (^ 2))) (10 *)
02:13:41 <Cale> certainly bad at that point :)
02:14:13 <quicksilver> fuzan: yes, I'm not a fan of mad flipping
02:14:28 <quicksilver> fuzan: I'll sometimes allow myself a single use of flip, though
02:14:30 <Cale> sum . sequence [(3*) . (^3), (5*) . (^2), (10*), const 17]
02:14:46 <thorkilnaur> @pl \x -> ((3*x+5)*x+10)*x+17
02:14:47 <lambdabot> (17 +) . ((*) =<< (10 +) . ((*) =<< (5 +) . (3 *)))
02:15:16 <Cale> You can sometimes do a much better job than @pl if you do it yourself :)
02:15:24 <thorkilnaur> Hmmm, Horner'ing didn't seem to improve the matter ...
02:16:04 <thorkilnaur> What on earth is =<<?
02:16:16 <Cale> bind
02:16:17 <mux> it's just flip >>=
02:16:17 <fuzan> :t (=<<)
02:16:20 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
02:16:34 <fuzan> :t (>>=)
02:16:37 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:16:44 <Cale> In this case, it's being used in the (e ->) monad
02:16:58 <vincenz> Anyone remember the name of the haskell based logic framework?
02:17:03 <Cale> So (=<<) :: (a -> (e -> b)) -> (e -> a) -> e -> b
02:17:27 <haraldk> Cale: I hadn't heard of that one, the e-> monad
02:17:29 <quicksilver> which is almost but not quite CPS
02:17:42 <duey> foo xs = map (\x -> (x + 1) / 2) xs
02:18:04 <mux> map ((/2) . (+1))
02:18:04 <vincenz> cale?
02:18:14 <duey> oh I had it the other way around
02:18:15 <Cale> vincenz: LogicT?
02:18:59 <duey> thanks
02:18:59 <fuzan> @pl \xs -> map (\x -> (x + 1) / 2) xs
02:19:07 <lambdabot> map ((/ 2) . (1 +))
02:19:07 <thorkilnaur> Thanks everybody, there is certainly something to think about
02:19:20 <vincenz> Cale: no it was a different name
02:19:23 <vincenz> Cale: more like a prover framework
02:20:07 <Cale> > fix ((0:) . (1:) . ap (zipWith (+)) tail)
02:20:09 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
02:20:29 <duey> @pl map f (map g xs)
02:20:30 <lambdabot> map f (map g xs)
02:20:34 <duey> lol
02:20:53 <mux> @pl foo xs = map f (map g xs)
02:20:53 <Cale> @pl \xs -> map f (map g xs)
02:20:53 <lambdabot> foo = map (f . g)
02:20:54 <lambdabot> map (f . g)
02:21:10 <Cale> @pl \f g xs -> map f (map g xs)
02:21:11 <lambdabot> (. map) . (.) . map
02:22:03 <Cale> (But if you're doing an exercise, they probably want the one mux did :)
02:22:04 <fuzan> Cale:  how well do functions like that desugar?
02:22:24 <Cale> Just fine?
02:22:28 <mux> heh
02:22:36 <vincenz> Cale: I think it was "Ivor"
02:22:46 <Cale> (. map) = flip (.) map
02:22:48 <duey> lambdabot is my friend
02:22:52 <mux> I wonder what associated types desugar into
02:23:06 <vincenz> though it seems old
02:23:15 <jward> What's the purpose of lambdabot?
02:23:33 <duey> solving lambdas
02:23:41 <fuzan> demonstration and simple assistance.
02:23:51 <Cale> It does lots of stuff
02:23:54 <phoniq> botsnack
02:23:55 <Cale> @localtime Cale
02:23:57 <lambdabot> Local time for Cale is Tue Apr 17 05:22:07
02:23:59 <Cale> @botsnack
02:24:00 <lambdabot> :)
02:24:09 <Cale> @seen fuzan
02:24:10 <lambdabot> fuzan is in #haskell. I last heard fuzan speak 28s ago.
02:24:15 <ChilliX> mux: The gory details are all online: http://hackage.haskell.org/trac/ghc/wiki/TypeFunctions
02:24:15 <mux> jward: it's very useful for many things: looking up functions with hoogle, evaluating terms, rewriting to point-free style, rewriting monadic do blocks with >>=, etc etc
02:24:17 <lambdabot> Title: TypeFunctions - GHC - Trac
02:24:34 <Cale> @undo do {x <- [1..10]; y <- [1..10]; return (x,y)}
02:24:34 <mux> ChilliX: I've been reading these pages since yesterday ;-)
02:24:35 <lambdabot> [1 .. 10] >>= \ x -> [1 .. 10] >>= \ y -> return (x, y)
02:24:44 <Cale> @redo [1 .. 10] >>= \ x -> [1 .. 10] >>= \ y -> return (x, y)
02:24:45 <lambdabot> do { x <- [1 .. 10]; y <- [1 .. 10]; return (x, y)}
02:24:57 <mux> ChilliX: I'm just not skilled with System F and/or System Fc to understand it all
02:25:07 <mux> +enough
02:25:27 <Cale> @tell jward You can send messages to be received when the person next speaks.
02:25:28 <lambdabot> Consider it noted.
02:25:41 <mux> I still didn't manage to rewrite the MonadState type-class without functional dependencies using associated types :-(
02:25:44 <Cale> @karma Cale
02:25:45 <lambdabot> You have a karma of 46
02:25:49 <mux> @karma
02:25:50 <lambdabot> You have a karma of 3
02:25:50 <haraldk> after re-getting and applying all the 923 patches of yi, I failed to reproduce the error...
02:25:55 <Cale> @karma+ mux
02:25:56 <lambdabot> mux's karma raised to 4.
02:26:02 <mux> yay!
02:26:05 <mux> heh
02:26:40 <jward> I'll have to learn more about Haskell and functional programming to take advantage of it then :)
02:26:40 <lambdabot> jward: You have 1 new message. '/msg lambdabot @messages' to read it.
02:26:44 <Cale> @listcommands
02:26:45 <lambdabot> Unknown command, try @list
02:26:48 <Cale> @list
02:26:49 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
02:27:00 <mux> @seen dons -- best use of lambdabot
02:27:00 <Cale> oh right, djinn
02:27:00 <lambdabot> dons is in #haskell-soc and #haskell. I last heard dons speak 2h 19m 20s ago.
02:27:22 <mux> @djinn b -> (a -> b) -> Maybe a -> b
02:27:23 <lambdabot> f a b c =
02:27:23 <lambdabot>     case c of
02:27:23 <lambdabot>     Nothing -> a
02:27:23 <lambdabot>     Just d -> b d
02:27:33 <mux> djinn++
02:27:37 <Cale> @djinn (e -> a -> b) -> (e -> a) -> e -> b
02:27:38 <lambdabot> f a b c = a c (b c)
02:27:48 <Cale> @. pl djinn (e -> a -> b) -> (e -> a) -> e -> b
02:27:49 <lambdabot> f = ap
02:28:09 <Cale> @hoogle  (e -> a -> b) -> (e -> a) -> e -> b
02:28:10 <lambdabot> No matches, try a more general search
02:28:13 <Cale> boo!
02:28:14 <Cale> hehe
02:28:16 <mux> @let answer = 42
02:28:19 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
02:28:24 <Cale> @hoogle (a -> b) -> [a] -> [b]
02:28:24 <mux> mmm
02:28:25 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
02:28:25 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
02:28:25 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
02:28:31 <mux> how does @let work again?
02:28:42 <Cale> mux: at the moment it doesn't
02:28:47 <mux> ah
02:28:58 <Cale> @type map
02:29:00 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
02:29:04 <mux> @hoogle  b -> (a -> b) -> Maybe a -> b
02:29:04 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
02:29:37 <dolio> @. elite vixen
02:29:37 <lambdabot> <unDephiN3d>
02:29:55 <Cale> @elite Can you jam with the Console-Cowboys in cyberspace?
02:29:56 <lambdabot> (aN joo j4M \/\/iTH +He COnSo|e-(oW8OYz in (Yb3rzPAce?
02:30:30 <Cale> @vixen Are you broken?
02:30:30 <lambdabot> <undefined>
02:30:37 <Cale> seems so
02:31:13 <Cale> @babel fr en Ceci n'est pas une pipe.
02:31:15 <lambdabot> Plugin `babel' failed with: IRCRaised Data.ByteString.last: empty ByteString
02:31:27 * Cale wonders why so many plugins are broken.
02:31:45 <johnnowak> Cale: lambdabot must be written in python :)
02:31:49 <Cale> heh
02:32:01 <mux> @check \xs ->  (not . all) xs == any xs
02:32:02 <lambdabot>  Couldn't match expected type `Bool'
02:32:03 <dolio> I think sorear said most are fixed now, but lambdabot hasn't been recompiled in a while.
02:32:08 <Cale> oh
02:32:13 <mux> I hope some day I'll be able to use quickcheck
02:32:39 <Cale> If that's the case, we'll have to annoy dons to recompile lambdabot :)
02:32:49 <haraldk> didn't he just say "passed 500 tests" a while back? What was that?
02:32:51 <johnnowak> dolio: unfortunate that you have to recompile it to make such fixes, no?
02:33:00 <Cale> haraldk: That was quickcheck
02:33:10 <Cale> quickcheck tests properties about code
02:33:36 <mux> I never seem to be able to remember the syntax
02:33:44 <haraldk> oh, sorry, I thought mux said he hoped lambdabot would some day use quickcheck
02:33:53 <Cale> @check \(f :: Integer -> Integer) (g :: Integer -> Integer) (xs :: [Integer]) -> map (f . g) xs == map f . map g $ xs
02:33:54 <lambdabot>  Parse error in pattern
02:33:58 <mux> :-P
02:34:04 <Cale> oh, no pattern type signatures
02:34:26 <mux> @check \(xs :: [Bool]) ->  (not . all) xs == any xs
02:34:26 <lambdabot>  Parse error in pattern
02:34:30 <dolio> johnnowak: I guess. It's not that big a job.
02:34:50 <quicksilver> @check map (f . g) xs == map f . map g $ (xs :: [Integer)
02:34:51 <lambdabot>  Parse error
02:34:55 <quicksilver> @check map (f . g) xs == map f . map g $ (xs :: [Integer])
02:34:56 <Cale> @check \f g xs -> map ((f :: Integer -> Integer) . (g :: Integer -> Integer)) xs == map f . map g $ xs
02:34:56 <lambdabot>   Not in scope: `xs'
02:34:57 <lambdabot>  Couldn't match expected type `[Integer]'
02:35:12 <johnnowak> dolio: recompiling once it works, no... but recompiling to see if it works repeatedly, perhaps.
02:35:18 <quicksilver> @check \f g xs -> map (f . g) xs == map f . map g $ (xs :: [Integer])
02:35:19 <lambdabot>  Couldn't match expected type `[c]'
02:35:24 <Cale> @check \f g xs -> map ((f :: Integer -> Integer) . (g :: Integer -> Integer)) xs == (map f . map g $ xs)
02:35:26 <johnnowak> dolio: can you run lambdabot without compiling it?
02:35:28 <lambdabot>  OK, passed 500 tests.
02:35:33 <Cale> woops :)
02:35:42 <mux> I'm happy to see I'm not the only one who has problems with QC :-)
02:35:42 <Cale> @check \f g xs -> map ((f :: Integer -> Integer) . (g :: Integer -> Integer)) xs == map f (map g xs)
02:35:46 <lambdabot>  OK, passed 500 tests.
02:35:46 <haraldk> @check odd == \x -> even (x + 1)
02:35:48 <lambdabot>   add an instance declaration for (Eq (a -> Bool))     In the expression: odd...
02:35:57 <Cale> This is easier when you can write your type signatures separately
02:36:10 <mux> @check \xs -> (not . all) (xs :: [Bool]) == any xs
02:36:11 <lambdabot>  Couldn't match expected type `Bool'
02:36:12 <dolio> johnnowak: Probably, if you load the appropriate module into ghci.
02:36:23 <Cale> @check \n x -> odd x == even (x + 1)
02:36:25 <lambdabot>  Add a type signature
02:36:32 <Cale> @check \n x -> odd (x :: Integer) == even (x + 1)
02:36:33 <lambdabot>  Add a type signature
02:36:39 <Cale> oh
02:36:41 <Cale> @check \x -> odd (x :: Integer) == even (x + 1)
02:36:42 <lambdabot>  OK, passed 500 tests.
02:36:48 <Cale> duh :)
02:36:49 <haraldk> @check \hmm-> odd == \x -> even (x + 1)
02:36:50 <lambdabot>   add an instance declaration for (Eq (a -> Bool))     In the expression: odd...
02:37:10 <Cale> (==) can't be applied to functions
02:37:25 <Cale> It can only test whether two instances of Eq are equal.
02:37:40 <mux> I can't seem to run LB anymore, hmm..
02:37:50 <Cale> @scheck  \x -> odd (x :: Integer) == even (x + 1)
02:37:52 <lambdabot>   Completed 13 test(s) without failure.
02:38:08 <Cale> scheck tests a bunch of small values of the given types
02:38:23 <mux> @scheck \xs -> (not . all) (xs :: [Bool]) == any xs
02:38:24 <lambdabot> Couldn't match expected type `Bool'
02:38:27 <mux> grrr
02:38:36 <Cale> @check \xs -> reverse (reverse (xs :: [T])) == xs
02:38:40 <lambdabot>  OK, passed 500 tests.
02:38:52 <haraldk> @check \x-> odd (x :: Integer) == even (x - 1)
02:38:54 <lambdabot>  OK, passed 500 tests.
02:39:10 <Cale> @scheck \xs -> (not . and) (xs :: [Bool]) == or xs
02:39:12 <lambdabot>   Failed test no. 2. Test values follow.: [True]
02:39:43 <haraldk> @elite wow, you rule, lambdabot
02:39:44 <lambdabot> WoW, u RUl3, laMBdabO+
02:41:31 <Cale> @unpl even . (+1)
02:41:32 <lambdabot> (\ d -> even (d + 1))
02:41:43 <Cheery> how would you turn thing like: [True,True,False,True] to "1101" ?
02:42:10 <Cheery> and backwards, of course
02:42:18 <mux> > map (\b -> if b then '1' else '0') [True,True,False,True]
02:42:19 <lambdabot>  "1101"
02:42:41 <Cale> > map (=='1') "1101"
02:42:43 <lambdabot>  [True,True,False,True]
02:42:51 <Cheery> :)
02:42:52 <mux> :)
02:43:00 <dolio> > map (toEnum . fromEnum) [True,True,False,True] :: String
02:43:02 <lambdabot>  "\SOH\SOH\NUL\SOH"
02:43:08 <dolio> Whoops.
02:43:18 <dolio> > map (intToDigit . fromEnum) [True,True,False,True] :: String
02:43:19 <lambdabot>  "1101"
02:43:25 <mux> yeah, that's nicer
02:44:37 <Cale> > map (chr . (+ ord '0') . fromEnum) [True,True,False,True] -- you could also do this
02:44:39 <lambdabot>  "1101"
02:44:47 <haraldk> is there an opposite function of not for use in higher order functions?
02:45:06 <Cale> (not .) ?
02:45:07 <mux> Cale: what if my character encoding doesn't have contiguous and ordered digits? :)
02:45:14 <earthy> opposit of not?
02:45:18 <haraldk> so that yes True = True and yes False = False?
02:45:18 <earthy> wtf?
02:45:24 <ToRA> > concatMap (show . fromEnum) [True, True, False, True] -- yet another variation
02:45:25 <Cale> haraldk: id
02:45:26 <earthy> you mean 'id'
02:45:26 <lambdabot>  "1101"
02:45:31 <quicksilver> > let bc True = '1'; bc False = '0' in map bc [True,True,False,True]
02:45:32 <haraldk> duh!
02:45:33 <lambdabot>  "1101"
02:45:47 <Cale> haraldk: also, xor is /=
02:46:32 <haraldk> > xor True False
02:46:33 <lambdabot>   add an instance declaration for (Bits Bool)
02:46:33 <lambdabot>     In the expression: xor True...
02:46:42 <Cale> > True /= False
02:46:44 <mux> there should be a type-class for types that have exactly two nullary data constructors
02:46:44 <lambdabot>  True
02:46:47 <Cale> > True /= True
02:46:49 <lambdabot>  False
02:46:55 <earthy> > (/=) False False
02:46:55 <Cale> > False /= False
02:46:57 <lambdabot>  False
02:46:57 <lambdabot>  False
02:47:13 <haraldk> :-)
02:47:21 <vali> hello!
02:47:25 <Cale> hello!
02:47:34 <earthy> hi vali
02:47:40 <vali> i am trying to make my first haskell program and it isn't working, hehe
02:47:46 <Cale> @paste
02:47:47 <earthy> good!
02:47:47 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:47:54 <earthy> what are you stuck with? :)
02:47:54 <mux> [(x,y) | x <- [False..], y <- [False..], x || y]
02:47:58 <mux> 2D> [(x,y) | x <- [False..], y <- [False..], x || y]
02:48:00 <mux> GAH
02:48:04 <mux> > [(x,y) | x <- [False..], y <- [False..], x || y]
02:48:05 <lambdabot>  Parse error
02:48:16 <mux> > [(x,y) | x <- [False ..], y <- [False ..], x || y]
02:48:18 <lambdabot>  [(False,True),(True,False),(True,True)]
02:48:36 <mux> lots of noise for not much..
02:48:37 * mux hides
02:48:48 <hpaste>  vali pasted "?" at http://hpaste.org/1426
02:49:09 <mux> vali: add a $ after putStrLn
02:49:27 <vali> mux: oh, thank you. what does $ mean?
02:49:28 <hpaste>  mux annotated "?" with "should do" at http://hpaste.org/1426#a1
02:49:37 <hpaste>  Cale annotated "?" with "fixed" at http://hpaste.org/1426#a2
02:49:38 <earthy> or ( and ) around the "f 5: " ++ show (f 5)
02:49:45 <Cale> either of those :)
02:50:00 <vali> this is an extremely helpful channel. thank you
02:50:01 <mux> vali: it's just function application but it has a priority such that it'll eat any token until the end
02:50:03 <Cale> Remember that function application always happens first.
02:50:10 <tuxplorer> Can some one get me a link for comparison of haskell and lisp? When I Google, I find only posts dated as old as 93
02:50:35 <tuxplorer> what advantages does haskell have over lisp?
02:50:40 <Cale> So putStrLn is applied to "f 5: " to give an action, and then that action is being ++'d with show (f 5)
02:50:43 <earthy> static typing with type inference
02:50:45 <Cale> and that's why it's complaining :)
02:50:47 <earthy> lazy evalutation
02:50:50 <mux> monads
02:50:57 <earthy> mux: lisp's got monads
02:51:03 <vali> Cale: aah, thank you
02:51:06 <mux> really? *blushes*
02:51:19 * mux never did any LISP
02:51:34 <quicksilver> purity
02:51:35 <Cale> Well, it *can* have monads.
02:51:38 <Svrog> earthy: lisp has monads in the same sense that c supports classes
02:51:45 <mux> ah.
02:51:47 <tuxplorer> any detailed links? how to search for links that the haskell bot here has?
02:51:50 <Cale> Monads are not in the standard library of any lisp that I know of.
02:51:52 <vali> tuxplorer: i started learning lisp about a year ago and i switched to haskell recently
02:52:09 <Svrog> as in you can do oop in c but its not practical - as far as i know thats the case with monads in lisp or caml as well
02:52:13 <mux> does LISP have impredicative polymorphism?
02:52:18 <earthy> yeah. some weird guy named steele did a paper called 'Building Interpreters by Composing Monads' once
02:52:26 <quicksilver> lisp has monads in the same sense that 68000 assembler has monads :P
02:52:37 <LeCamarade> quicksilver: :oD
02:52:40 <tuxplorer> vali: I never learnt lisp.. started with haskell.. but I need some strong points to put b4 the local LUG guys this weekend.. I'm giving them an intro to haskell
02:52:50 <Cale> mux: It's typically dynamically typed, so it wouldn't need it.
02:52:58 <mux> ah, ugh!
02:53:02 <earthy> it's just that lisp doesn't generally have the overloading that makes monadic code so clean in Haskell
02:53:05 * mux throws LISP far away
02:53:05 <vali> tuxplorer: i have made a lisp to convince my friends why they should use haskell instead of lisp
02:53:11 <vali> tuxplorer: err a list*
02:53:22 <johnnowak> vali: i'd like to see it
02:53:32 <tuxplorer> vali: can you give me such code samples if possible?
02:53:36 <LeCamarade> tuxplorer: You can learn Lisp is 6 hours. I'm serious.
02:53:42 <vali> johnnowak: sure. it's based on my experience as a lisp and haskell newbie
02:53:52 <earthy> but, static type system with type inference and lazy evaluation are the big difference points
02:53:57 <johnnowak> LeCamarade: does that mean you can learn scheme in three?
02:54:22 <tuxplorer> LeCamarade: really?
02:54:30 <LeCamarade> johnnowak: Scheme ... Scheme everybody already knows. They just don't know they do. :oD
02:54:31 <Cale> A real syntax is another thing which Haskell has and Lisp doesn't. Whether that's a good thing depends on your perspective ;)
02:54:33 <Svrog> tuxplorer: id suggest not listing static typing as an advantage of haskell over lisp in a lisp users group hehe
02:54:53 <LeCamarade> tuxplorer: Seriously. Not kidding.
02:54:55 <johnnowak> tuxplorer: aye, certainly. after the first few hours, you're just picking up the libraries.
02:55:02 <tuxplorer> Svrog: LUG = Linux User Group :) my mistake not having mentioned iot
02:55:08 <Svrog> ah
02:55:15 <Svrog> oops
02:55:18 <dabblego> how about referring to the static type system inadvertenty with "higher-order polymorphism"?
02:55:19 <mux> I learnt haskell in ~5 months :-P and I'm still not able to understand everything, or I would be able to recode that damn MonadState type-class without FDs using the new and shiny associated types
02:55:23 <vali> tuxplorer, johnnowak: lisp is a great language, the lisp tools are not great. haskell is a great language and the haskell tools are also great. that's how i see it
02:55:37 <Cale> It depends on what you mean by "learn"
02:55:59 <Cale> Sure, you can "learn" lisp in a few hours, because the core principles are so simple.
02:56:10 <johnnowak> vali: tools are often a way of compensating for things not easily provided by the language
02:56:11 <Cale> But there's quite a lot to most lisps.
02:56:18 <earthy> common lisp is *huge*
02:56:31 <LeCamarade> tuxplorer: The harder parts are learning to expect to do Polish notation, rather than Algebraic. That's all.
02:56:48 <tuxplorer> ah! ok.. :)
02:56:55 <johnnowak> LeCamarade: unless you never learned algebraic notation.. then it's easy. :)
02:56:58 <LeCamarade> earthy: Yeah, but tuxplorer doesn't need all the funcs.
02:57:04 <Svrog> yeah cl is huge - i always thought scheme was much nicer
02:57:12 <Cale> I'd say the quoting is the trickiest part to understand at first.
02:57:32 <Cheery> @djinn (a -> Maybe a) -> a -> [a]
02:57:32 <lambdabot> -- f cannot be realized.
02:57:43 <LeCamarade> johnnowak: Yeah, the shift from algebraic is the hardest. Nothing, though, compared to actions and purity.
02:57:55 <quicksilver> @djinn Maybe a -> [a]
02:57:56 <lambdabot> -- f cannot be realized.
02:58:00 <johnnowak> Cale: you're probably tight.
02:58:03 <quicksilver> djinn's not much good at lists :)
02:58:14 <Cheery> hmm
02:58:26 <vali> johnnowak: perhaps. but there are some issues that i ran into with lisp, as a newbie that really bother me. on windows, i had to use clisp because sbcl didn't work. on linux, i used sbcl because it gave me better performance. producing binaries was very awkward. and if i wanted to use sockets, i found that most of the socket-libraries didn't support UDP etc. then i found haskell and GHC and everything was great
02:58:28 <Cheery> @hoogle (a -> Maybe a) -> a -> [a]
02:58:29 <lambdabot> No matches, try a more general search
02:58:37 <johnnowak> LeCamarade: and even then, i got used to it very quickly, but i still need to look up haskell syntax on occasion...
02:59:05 <johnnowak> vali: use scheme, not lisp. move to lisp if you later decide it'll be more productive for real world things.
02:59:11 <quicksilver> well lisp notoriously has 'no syntax' so clearly you wouldn't need to look up syntax
02:59:18 <quicksilver> you might get stuck in other ways though :)
02:59:35 <quicksilver> haskell doesn't have very 'much' syntax, certainly compared to languages like perl...
02:59:40 <vali> johnnowak: i never tried scheme, but i think haskell is the right language for me.
02:59:42 <ToRA> @type unfoldr
02:59:44 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
02:59:58 <ToRA> Cheery: that any help?
02:59:58 <LeCamarade> johnnowak: Yeah. The light-weight syntax is a major plus. Very major. But, in designing the libs, they forgot the simplicity of the language. Scheme got it right. Simplicity is one of the hardest things about programming. If not the hardest.
03:00:03 <Cale> ((lambda (x) `(+ ,x x)) 5) -- mmmm quasiquote :)
03:00:07 <johnnowak> vali: if you can use haskell, you already know scheme
03:00:21 <johnnowak> LeCamarade: i completely agree
03:00:25 <Cheery> ToRA: not sure, thought I guess I need it only if I want to make it simpler
03:00:38 <vali> johnnowak: aah. i better keep reading haskell then. i just started a few days ago
03:00:54 <Cheery> haskell syntax is almost no-syntax
03:01:18 <Cale> Actually, as far as languages go, Haskell syntax is pretty complicated.
03:01:24 <LeCamarade> vali: Haskell can't be replaced for me. But I would still encourage one to do a Lisp-like (Clisp, especially). It educates and edifies. Much like Haskell.
03:01:40 <nominolo> @where bytestring
03:01:41 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
03:01:44 <johnnowak> Cheery: not to me.. i learned to program with scheme. :) i've been anything at every other syntax since (with the exception of Io and forth-like languages such as Factor)
03:01:48 <int-e> haskell has quite a bit of syntactic sugar. guards, let *and* where, list comprehension, do notation ...
03:01:53 <johnnowak> s/anything/annoyed/
03:01:58 <int-e> I'm sure I forgot some.
03:02:06 <Cheery> infix syntax
03:02:12 <Cale> sections
03:02:21 <Cheery> you mean layouts?
03:02:21 <Svrog> yeah - it's worth learning a lisp dialect even if you know haskell
03:02:30 <Cale> > map (+1) [1..10]
03:02:32 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
03:02:35 <Cale> Cheery: like that
03:02:37 <Cheery> ah, those. :)
03:02:47 <Cale> oh, actually, there's another one
03:02:54 <Cheery> I must agree, haskell syntax is vast
03:02:54 <Cale> > [1..10]
03:02:56 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
03:03:00 <Cale> enumerations :)
03:03:02 <ToRA> don't forget n+k patterns
03:03:02 <Cheery> but it feels so tiny
03:03:15 <LeCamarade> Haskell beats Lisp in that syntactic sugar is necessary, yet Lisp has none, except for list creation. '`, and the like.
03:03:16 <Cale> if then else :)
03:03:17 <ToRA> > let (n+1) = 3 in n
03:03:18 <lambdabot>  Parse error in pattern
03:03:21 <int-e> ToRA: even n-patterns are syntactic sufar
03:03:33 <Cheery> if then else feels almost useless
03:03:43 <int-e> > let f 0 = x -- means  f t | t == 0 = x
03:03:43 <lambdabot>  Parse error
03:03:47 <tuxplorer> oops.. sorry guys, got Disconnected
03:04:01 <mux> so, can anyone help me with associated/indexed types?
03:04:05 <Cale> It's useful because it's more readable than case.
03:04:15 <LeCamarade> ToRA: I think we should stop mentioning n+k patterns, until everyone forgets them. :oD
03:04:25 <Cheery> int-e, what does let f (Just a) = x means?
03:04:26 <johnnowak> LeCamarade: syntactic sugar isn't necessary in certain types of languages. if you look at Io, it has sugar for operators, but that's it, and it's very clear and readable
03:05:03 <ToRA> LeCamarade: i never new about them till i read the history of haskell paper...then i was shocked; i guess ignorance is bliss :)
03:05:20 <int-e> Cheery: pattern matching is a core feature. it can be written with case though:  f t = case t of Just a -> x; more cases for the rest of the function
03:05:20 <Cheery> Mostly haskell feels just improved lisp by syntax
03:05:36 <Maddas> Err...
03:05:48 <int-e> Cheery: but matching numerical literals is not actually a pattern match, semantically.
03:05:48 <Cale> Laziness :)
03:05:49 <LeCamarade> I'm yet to do Io (shunned it, because I still have Erlang on my list), but I think sugar is necessary to remove patterns in code and to enforce better practice without being a boss on the other end of the world.
03:05:51 <Maddas> Except that it's different in almost every regard as well :-)
03:06:10 <Cale> I think people underestimate the effect of laziness.
03:06:15 <int-e> Cheery: (it's actually a comparison)
03:06:22 <Cheery> ic
03:06:23 <johnnowak> LeCamarade: it also doesn't count as sugar if you do it via inspecting message chains at runtime :)
03:06:31 <tuxplorer> What is the main advantage of laziness and immutability? isn't former more like a solution for the latter?
03:06:53 <quicksilver> tuxplorer: the advantage of laziness is not computing stuff you don't need to compute :)
03:07:01 <Cale> Laziness turns data structures into control structures.
03:07:06 <Cheery> I can't name a main advantage for laziness
03:07:10 <int-e> tuxplorer: the latter is a necessity to make the former even remotely managable
03:07:11 <johnnowak> LeCamarade: i'd put io ahead of erlang if you already know haskell. probably more interesting, and definitely more of a shift.
03:07:13 <Cale> Lists become loops, essentially.
03:07:19 <LeCamarade> Haskell's only worthy comparisons are ML (syntax), Lisp (acrobatic capability), and Hell (learning). I'm being frank.
03:07:20 <mux> laziness is good for ammortized data structured
03:07:29 <Cale> (or vice-versa, depending on the way you're looking at it)
03:07:35 <quicksilver> tuxplorer: with sufficient skill, the advantage is also algorithms which are written over large data structures and yet run in constant space
03:07:50 <Maddas> LeCamarade: What about, say, Dylan or Smalltalk?
03:07:52 <Cale> It makes it possible to break programs down in ways that you couldn't before.
03:07:55 <LeCamarade> johnnowak: You mean Io won't take me back to loops? If it won't, I can add it to the list.
03:08:00 <tuxplorer> quicksilver: ah! That was a good point to convince people. :)
03:08:00 <mux> and for modularity
03:08:02 <Cale> And makes library functions more reusable.
03:08:02 <Cheery> with lazy language you tend to describe the program and forget in which order everything is evaluated unless it interests you
03:08:10 <int-e> (getting laziness to work for you is hard. it would be even harder if there were side effects.)
03:08:25 <johnnowak> LeCamarade: it abstracts recursion/iteration, if that's your question :)
03:08:28 <Cale> It's not that hard to put laziness to work.
03:08:39 <quicksilver> laziness keeps you honest, as SPJ put it
03:08:44 <Cale> It requires thinking a little differently from strict evaluation
03:09:00 <Cale> You just think of everything in terms of demand.
03:09:01 <johnnowak> LeCamarade: it does have a tailCall method if you insist on working that way, but that's really missing the point
03:09:02 <int-e> that is hard :-P (ok, more for some than for others.)
03:09:14 <johnnowak> LeCamarade: and this is coming from a scheme programmer. :)
03:09:24 <Cheery> has anybody ever translated lambda calculus to tag cellular automaton?
03:09:28 <LeCamarade> Okay. I have appended it. :oD
03:09:34 <Cale> It's hard at first, I suppose, if you're used to strict evaluation, especially.
03:09:47 <Cale> I kind of found it pretty natural myself.
03:09:48 <johnnowak> LeCamarade: i'll see you in #io when you get to it. :)
03:10:02 <Cale> Haskell basically evaluates things much like I'd evaluate them on paper.
03:10:09 <LeCamarade> johnnowak: Oh, good.
03:10:14 <tuxplorer> Cale: are you a prof?
03:10:22 <Cale> tuxplorer: no
03:10:30 <Cale> Maybe someday though :)
03:10:36 <tuxplorer> :)
03:11:00 <LeCamarade> tuxplorer: Usually, it is safe to assume they are, until told otherwise. #haskell is like that. Australian profs.
03:11:09 * LeCamarade hopes he will pass for a prof ...
03:11:14 <Cale> I'm not Australian. Yet.
03:11:17 <tuxplorer> LeCamarade: :) ok
03:11:31 <Cale> If I keep staying up at these hours, eventually I'll have to move there though.
03:11:35 <Cheery> because lines do not describe evaluation order, I tend to think my program as a set of combinators which will be just evaluated in the order where I combine them to
03:11:39 <LeCamarade> Cale: Hang around long enough. dons will kidnap you to UNSW.
03:11:41 <int-e> Cale: the next tricky step is to understand where and why to put the occasional required  seq.
03:11:46 <Svrog> LeCamarade: if you already know lisp or scheme it's probably not worth learning erlang - it has a few nice things like being able to pattern match binary blobs but other than that it's just feels like lisp with more syntax and pattern matching
03:12:03 <Cheery> considering the laziness of the language comes by nature
03:12:05 <Cale> int-e: right
03:12:11 <johnnowak> Svrog: aye
03:12:35 <Cale> int-e: and I'll admit that takes significant amounts of getting used to the language
03:12:52 <Cheery> Cale: does it? I got used to it under a week
03:13:04 <LeCamarade> Svrog: Actually, I am learning Erlang for the concurrency and understanding the design of the runtime better (includes hotswapping, et al). It can be really edifying. After Haskell, one has really reached the highest Blurb of our times. :oD
03:13:04 <Cale> Cheery: Where to put seq's?
03:13:21 <Cale> I didn't even know about seq until after a month or so.
03:13:39 <Cale> I suppose everyone learns things in a different order :)
03:13:39 <Cheery> @hoogle seq
03:13:40 <lambdabot> Prelude.seq :: a -> b -> b
03:13:41 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
03:13:41 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
03:13:43 <johnnowak> LeCamarade: you could learn about coroutines in Io instead. :)
03:13:59 <Cale> seq is a somewhat magical function
03:14:15 <Cale> seq x y  demands the evaluation of x before resulting in y
03:14:38 <LeCamarade> johnnowak: I do coroutines in Perl 6. Pugs, you know ... I am going to learn Io, alright. It's on the list! But I wonder what project will teach me ...
03:14:49 <int-e> the moment the value of y is demanded - seq x x is equivalent to just x.
03:14:49 <Cheery> hmm, where does the return value of x goes to?
03:14:55 <Cale> That means, evaluation up to determining the top-level data constructor in x
03:14:56 <int-e> Cheery: nowhere
03:15:06 <Cale> It goes away, unless you have another reference to x somewhere.
03:15:14 * LeCamarade believes the only way to learn a language is to get some program and clone it, with the true hope of surplanting.
03:15:19 <Cheery> like:
03:15:29 <Svrog> well, after haskell there are other interesting languages like j, forth, joy, prolog, oz, mercury :)
03:15:38 <Cheery> let foo = bar in seq foo guuxgaax
03:15:45 <quicksilver> joy's pretty cool
03:15:49 <Svrog> yes
03:15:50 <johnnowak> joy is very cool
03:16:06 <Cheery> Cale: that is how it is used?
03:16:12 <int-e> Cheery: if guuxgaax doesn't contain a reference to foo, then foo is evaluated and its result is discarded
03:16:13 <Cale> let foo = bar 5 in seq foo (guuxgaax foo)
03:16:18 <Cale> something like that
03:16:47 <LeCamarade> Svrog: My first questions are: functional? If not, out the window. I have written enough for loops in my life. Lazy? If not, lower on the list. I have worried enough about the Other End in my life.
03:16:55 <int-e> Cheery: one example is this: let sum_acc (x:xs) acc = let acc' = x+acc in acc' `seq` sum_acc xs acc'; sum_acc [] acc = acc
03:16:59 <Svrog> j and joy are functional
03:16:59 <Cale> That'll evaluate foo up to determining its top-level constructor and then apply guuxgaax
03:17:08 <Cheery> Why would one want to control the evaluation order such way?
03:17:09 <LeCamarade> The industry doesn't know how much use lazy eval can be.
03:17:14 <Svrog> forth can be
03:17:18 <Svrog> with a few extensions
03:17:24 <quicksilver> Cheery: to make sure big ugly unevaluated thunks don't hang around wasting space
03:17:25 <Cale> Cheery: to prevent the accumulation of large unevaluated expressions
03:17:29 <Svrog> but it's really just a shape-shifting high level assembler :)
03:17:32 <quicksilver> Cheery: it's not something you have to worry about very often, fortunately
03:17:50 <int-e> Cheery: the point of the seq there is to evaluate the accumulator before processing the tail of the list, instead of building up a big expression of lots of unevaluated additions.
03:17:52 <Cheery> huh, I guess I understand. :)
03:17:58 <Cale> For example...
03:18:02 <johnnowak> Svrog: why is joy functional but forth not?
03:18:03 <Cale> foldl (+) 0 [1,2,3]
03:18:12 <Cale> = foldl (+) (0 + 1) [2,3]
03:18:20 <Cale> = foldl (+) ((0 + 1) + 2) [3]
03:18:25 <Cale> = foldl (+) (((0 + 1) + 2) + 3) []
03:18:29 <Cale> = (((0 + 1) + 2) + 3)
03:18:34 <Cale> = ((1 + 2) + 3)
03:18:37 <Cale> = (3 + 3)
03:18:39 <Svrog> forth is very low level, has no lists, exposes the return stack and its internals
03:18:39 <Cale> = 6
03:18:56 <Svrog> deals with memory addresses directly
03:18:58 <Svrog> etc
03:19:01 <Cale> You can see that it builds up a large expression the size of the original list before reducing anything.
03:19:03 <LeCamarade> @quote functional
03:19:04 <lambdabot> Paltas says: i read that the python developer considered to remove nearly all functional programming methods from python.. wondered if he got a stroke or something..
03:19:23 * mux postes to -cafe@ and hopes to get answers
03:19:28 <Cale> If the list is being built as we go along as well, this will result in lots of memory getting used before anything is evaluated.
03:19:42 <Svrog> johnnowak: http://wiki.forthfreak.net/index.cgi?FunForth
03:19:45 <lambdabot> Title: FunForth - Kwiki
03:19:53 <Saizan> mmh what kind of code is the best to learn more about using laziness the right way? implementing data structures and articulate algorithms?
03:19:56 <johnnowak> Svrog: ah -- very nice, thanks
03:20:06 <Cale> So there's a version of foldl which seq's its second parameter before continuing
03:20:07 <quicksilver> joy is something like 'the spirit of forth, in a functional setting'
03:20:09 <Cale> called foldl'
03:20:16 <Cale> that is
03:20:22 <Cale> foldl' f z [] = z
03:20:32 <Cheery> aha, interesting
03:20:35 <quicksilver> although that's a bit unfair to the elegance of joy
03:20:54 <Cale> foldl' f z (x:xs) = let y = f z x in y `seq` foldl' f y xs
03:21:12 <Cale> Then:
03:21:17 <Cale> foldl' (+) 0 [1,2,3]
03:21:24 <Cale> = foldl' (+) 1 [2,3]
03:21:29 <Cale> = foldl' (+) 3 [3]
03:21:33 <Cale> = foldl' (+) 6 []
03:21:36 <Cale> = 6
03:21:48 <Cale> Leaving out the steps with let in them :)
03:21:54 <int-e> Cheery: indeed the sum_acc function that I posted is a special case of foldl'; it's foldl' (+), with swapped arguments
03:22:06 <mux> Cale: now rewrite this into System Fc k pz thx! :-)
03:23:14 <Cale> Basically, the rule to remember with Haskell's evaluation is that functions are evaluated before their parameters.
03:23:21 <nominolo> @src foldr
03:23:22 <lambdabot> foldr k z xs = go xs
03:23:22 <lambdabot>     where go []     = z
03:23:22 <lambdabot>           go (y:ys) = y `k` go ys
03:23:30 <mux> I think 'call-by-need' sums it up pretty nicely
03:24:03 <nominolo> > foldr mplus (Just 42) [Nothing,Just 3]
03:24:04 <lambdabot>  Just 3
03:24:10 <nominolo> > foldr mplus (Just 42) [Nothing,Nothing]
03:24:11 <lambdabot>  Just 42
03:24:17 <Cale> If a parameter occurs multiple times in the body of a function, the results are shared between the copies.
03:24:50 <Cale> To restate that, Lazy evaluation is outermost-first with sharing of duplicated parameters.
03:25:10 <LeCamarade> See that style of programmming that lambdabot shows when you @src foldr ? I think it rocks, but I'm yet to appreciate it ...
03:25:15 <Cale> By contrast, strict evaluation which everyone's used to these days is innermost-first.
03:25:34 <Cale> LeCamarade: It's hackish stuff to get GHC to optimise things better.
03:25:47 <Cale> It can be safely ignored, I think :)
03:25:52 <Cale> foldr f z [] = z
03:26:01 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
03:26:32 <LeCamarade> Cale: Yeah, dons once explained it briefly, and he made it look Glorious.
03:26:43 <Cheery> Cale: I've been this far satisfied with the speed of code I've done, it's great to hear that I have such things to do when it does not satisfy me.
03:26:45 <LPhas> someone knows an example of HaXml used to parse something?
03:27:02 <LeCamarade> Cheery: Put it right.
03:27:06 <Cale> Cheery: yeah
03:27:10 <LeCamarade> @beer Cheery
03:27:11 <lambdabot> Cheery is in #haskell. I last heard Cheery speak 26s ago.
03:27:14 <Cale> hehe
03:27:21 <Cale> that spell-corrected to @seen
03:27:39 <therp> lphas: well, if you don't mind a pretty unrefined example?
03:27:45 <LeCamarade> lambdabot: You don't give beers? Tight-fisted tasmanian daemon!
03:28:04 <nominolo> @losers
03:28:04 <lambdabot> Maximum users seen in #haskell: 336, currently: 308 (91.7%), active: 36 (11.7%)
03:28:31 <nominolo> @uses
03:28:32 <lambdabot> Maximum users seen in #haskell: 336, currently: 309 (92.0%), active: 36 (11.7%)
03:29:00 <LeCamarade> nominolo: Quit hurting LB's respect. :oD
03:31:59 <mux> @slap nominolo
03:31:59 <lambdabot> why on earth would I slap nominolo
03:32:04 <mux> heh
03:32:14 <toxic> @slap -f nominolo
03:32:14 * lambdabot smacks -f nominolo about with a large trout
03:32:43 <nominolo> o_O
03:39:55 <hpaste>  Cheery pasted "Rule 110 cellular automaton" at http://hpaste.org/1428
03:41:31 <hpaste>  Cheery pasted "Tag cellular automaton" at http://hpaste.org/1429
03:46:25 <drigz> 'interact id' will not print output until EOF. how can i change this?
03:46:48 <drigz> i.e. ghc -e 'interact id' behaves differently from 'cat' in this respect
03:47:09 <quicksilver> drigz: but setting the buffering on the file handles
03:47:12 <Cale> @type hSetBuffering
03:47:14 <quicksilver> s/but/by/
03:47:14 <lambdabot> Not in scope: `hSetBuffering'
03:47:19 <Cale> @type System.IO.hSetBuffering
03:47:22 <lambdabot> GHC.IOBase.Handle -> GHC.IOBase.BufferMode -> IO ()
03:47:45 <quicksilver> 'cat' is actually a more complex program than most people imagine :)
03:47:50 <dcoutts> drigz: presumably you mean until EOL, not EOF
03:48:05 <quicksilver> it sets buffering based on whether or not the fds it have are ttys
03:48:34 <dcoutts> drigz: hmm, I can't reproduce the problem, for me ghc -e 'interact id' behaves just like cat
03:48:51 <dcoutts> ie it echos lines after I press enter
03:49:11 <dcoutts> so just like with cat, it's line buffered
03:49:12 <Cale> Depending on your version of GHC, it might be line-buffered or block-buffered.
03:49:29 <int-e> interestingly, cat -n  seems to set buffering differently from just  cat  ... weird.
03:49:42 <int-e> (cat -n numbers lines)
03:49:57 <dcoutts> int-e: how would I notice that?
03:50:07 <dcoutts> seems the same to me so far
03:50:20 <Cale> ghc -e 'mapM System.IO.hGetBuffering [System.IO.stdin, System.IO.stdout] >>= print'
03:50:20 <quicksilver> 'cat.c' is 788 lines, btw
03:50:27 <Cale> do that, and see what you get.
03:50:44 <int-e> dcoutts: cat produces output after every line I input; cat -n consumes the few lines I typed, and then prints all of them
03:50:59 <int-e> dcoutts: ymmb
03:51:01 <int-e> dcoutts: ymmv
03:51:12 <dcoutts> int-e: right, for me they're both line buffered
03:52:10 <Cale> @src interact
03:52:11 <lambdabot> interact f = do s <- getContents; putStr (f s)
03:52:42 <mauke> I need an online haskell interpreter
03:52:44 <Cale> oh, that's interesting
03:52:56 <Cale> That's not compliant with H98 then.
03:52:56 <mux> interact rocks
03:53:00 <Saizan> ?where lambdaweb
03:53:01 <lambdabot> http://lambdabot.codersbase.com
03:53:05 <Cale> interact    ::  (String -> String) -> IO ()
03:53:05 <Cale> -- The hSetBuffering ensures the expected interactive behaviour
03:53:05 <Cale> interact f  =  do hSetBuffering stdin  NoBuffering
03:53:05 <Cale>                   hSetBuffering stdout NoBuffering
03:53:05 <Cale>                   s <- getContents
03:53:06 <Cale>                   putStr (f s)
03:53:12 <Cale> that's the version from the report!
03:53:15 <mauke> I have the sudden urge to write a haskell program and I'm not at home :/
03:56:59 <ndm> @seen dons
03:56:59 <lambdabot> dons is in #haskell-soc and #haskell. I last heard dons speak 3h 49m 19s ago.
03:57:17 <ndm> @seen the binary strike force
03:57:17 <lambdabot> I haven't seen the.
03:59:57 <Saizan> does the mantainer of HXT come here sometimes?
04:00:42 <Igloo> dcoutts: Re filepath, ndm was going to try to fix something before the GHC 6.6.1 release; I don't know if 1.0 should be held up for that
04:01:09 <dcoutts> Igloo: right, we'll see what ndm says
04:01:32 <ndm> dcoutts, Igloo: give me until the end of the day, that should be plenty
04:01:32 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
04:01:44 <dcoutts> oh hia ndm :-)
04:01:57 <dcoutts> ndm: binary? did you have a Q?
04:02:02 <dcoutts> I'm hacking on that right now
04:02:13 <ndm> dcoutts: as a binary strike force member, you recently changed your instance to "put (0 :: Word8) >> put x >> put y
04:02:22 <dcoutts> (rules for eliminating bounds checks in read at the moment)
04:02:30 <dcoutts> ndm: did we? ok
04:02:36 <ndm> dcoutts: i'm writing the automatic derivation for derive, and want to get it however you want it :)
04:02:51 <ndm> i thought putWord8 was clearer...
04:03:07 <ndm> just wondering if there is something fundamental you've changed, or if someone is having a clean up
04:03:11 <dcoutts> ndm: I'm currently using Put.word8 as a naming scheme
04:03:30 <dcoutts> ndm: you'd have to ask kolmodin about recent changes, I've not been involved
04:03:37 <ndm> @seen kolmodin
04:03:38 <lambdabot> kolmodin is in #darcs, #gentoo-haskell, #haskell-soc and #haskell. I last heard kolmodin speak 1h 10m 31s ago.
04:03:39 <dcoutts> I'm hacking on the next version :-)
04:03:54 <pejo> Not sure if this is old news - but for those of you who don't reveiw for icfp - SPJ has a bunch of new articles on his homepage. :-)
04:03:56 <ndm> i just want to know what the ideal instance looks like :)
04:04:37 <dcoutts> ndm: the next version will look like: put (a,b,c) = Put.word8 a >> Put.word8 b >> Put.word8 c
04:04:58 <dcoutts> ndm: and get = (,,) <$> Get.word8 <*> Get.word8 <*> Get.word8
04:05:08 <dcoutts> ndm: concise :-)
04:05:17 <dcoutts> and an applicative style allows for rule matching
04:05:18 <ndm> dcoutts: but how will you know the size of the tag?
04:05:30 <dcoutts> hmm?
04:05:33 <ndm> and isn't Get.word8 confining the size of a,b,c - which are unknown?
04:05:42 <ndm> i.e. how will Maybe a get a tag bit of size 2
04:05:44 <dcoutts> yeah, that's only an example
04:06:22 <ndm> with Derive, i'm no longer overly fussed - it makes it trivial to derive the instances automatically
04:06:33 <dcoutts> ndm: I'm not sure that we use variable sized tags
04:06:34 <ndm> but the <$> and <*> are always handy
04:06:47 <ndm> dcoutts: Derive does, so you can support > 256 constructors
04:06:55 <ndm> you don't, but thats a bug in your implementation :)
04:07:08 <ndm> where a tag of 0 bytes is just no tag
04:07:13 <dcoutts> ndm: ah right, so you use one two or four bytes then?
04:07:23 <ndm> dcoutts: yep
04:07:24 <dcoutts> or 0 of course
04:07:53 <ndm> indeedy
04:07:55 <dcoutts> ndm: right, sensible. Or we could always use 4 bytes and make all memory references aligned, which is worth about 4-5x performance
04:08:04 <ndm> in your example does (,,) write out a tag bit?
04:08:09 <dcoutts> no
04:08:19 <dcoutts> since it doesn't need one
04:08:31 <ndm> dcoutts: will all the bytes stay 4 aligned? even as you intermingle the data?
04:08:52 <dcoutts> you'd have to make the format alignment preserving, it may not be worth it
04:09:05 <ndm> yeah, i'd think you ended up padding a lot of things to get that property
04:09:18 <dcoutts> ndm: I've only been thinking about the bottom layer of this at the moment, independent of serialisation formats
04:09:34 <ndm> fair enough, i just wanted to check your change in derivation scheme wasn't fundamental
04:09:43 <ndm> i want our derivation to be perfect :)
04:09:52 <matthew-_> you know how getProgName just gives the leaf name rather than the full path? well, I'd be quite happy to deal with the error if on windoze and can't find the full path, so is there a way of getting the full path on other platforms?
04:10:08 <dcoutts> ndm: got some particular purpose you're worried about?
04:10:13 <matthew-_> currently I'm reading the "_" env var which is bash and zsh specific...
04:10:14 <ndm> matthew-_: wrong, windows can find the full path trivially, linux can't
04:10:26 <ndm> matthew-_: thats why we have a broken library design
04:10:47 <ndm> dcoutts: just will be releasing derive shortly, and want it all shiney and spangley
04:10:54 <matthew-_> ndm: oh, ok.
04:10:56 <dcoutts> ndm: right
04:10:56 <mux> there is just no such thing as a "real full path" under unix
04:11:17 <dcoutts> because in linux there's no restriction that the executable file has a path
04:11:31 <ndm> indeed, but it would still be a useful api
04:11:32 <dcoutts> you can 'delete' the binary for a running program
04:11:36 <matthew-_> mux: ok sure - but the path through which the program was invoked will do for me...
04:11:49 <ndm> getFullProgName :: Maybe String
04:11:54 <mauke> readlink "/proc/self/exe"
04:12:05 <ndm> matthew-_: you basically want argv[0] ?
04:12:10 <matthew-_> ndm: yep.
04:12:22 <mauke> argv[0] has nothing to do with files or the path
04:12:33 <dcoutts> right, so I think you can always find the name that the exe was invoked as
04:12:33 <mux> yeah that's just argv[0]
04:12:44 <dcoutts> but as ndm says that's not directly related to the file name
04:12:45 <eumenides> ndm: do you think it would be possible to use qualified names with Data.Derive so put/get doesn't conflict with the state monad?
04:14:10 <matthew-_> ok, so I know that argv[0] can be changed and all the rest of it, and that it doesn't necessarily have anything to do with the the program as it was executed, but for my needs, it'll do...
04:14:19 <mauke> hahaha, the type checker example code in HaskellRetrospective.pdf uses the names newTyVar and unify
04:14:38 <quicksilver> matthew-_: you'll have to search through PATH for things which look like getProgName...
04:14:42 <mauke> they're stealing my ideas ... from the future!
04:15:13 <matthew-_> quicksilver: Mmm. how about $ ./foo ?
04:15:54 <matthew-_> in fact, I'm explicitly dealing with the program being invoked outside of $PATH, either through an absolute or relative path
04:17:06 <kolmodin> ndm: hia
04:17:09 <gabor> anybody knows how ghc can be told to just save the .c files without invoking the C compiler?
04:17:16 * kolmodin reads up
04:17:26 <gabor> i.e. does ghc respects the CC envvar?
04:17:52 <dcoutts> gabor: no, but you can use -pgmc=my-cc
04:17:58 <robreim> ndm: are you able to test a network library patch under windows right now?
04:18:08 <mauke> -pgmc=true
04:18:11 <quicksilver> matthew-_: if $ ./foo then argv[0] will be "./foo"
04:18:15 <dcoutts> gabor: and there's another flag to get the .hc output file
04:18:38 * gabor looks
04:18:40 <dcoutts> gabor: -C I think, but I may be mis-remembering. It's in the ghc manual on the web.
04:18:42 <quicksilver> matthew-_: if argv[0] contains /-components then you don't look in the PATH, rather in the cwd
04:18:51 <quicksilver> matthew-_: but really this is embedding sh-semantics into your app :P
04:18:52 <kolmodin> ndm: where have we changed putWord8 to put?
04:19:53 <quicksilver> matthew-_: nobody can promsie to you that all shells work that way, although the common ones do
04:19:56 <matthew-_> quicksilver: sure, I can't find how to access argv[0] though. getArgs drops [0] helpfully.
04:20:11 <quicksilver> matthew-_: I thought getProgName was argv[0] ?
04:20:13 <ohmega> hey! i heard about this xmonad thing!
04:20:38 <matthew-_> nope
04:20:40 <matthew-_> "we just return the leafname of the program as invoked"
04:20:44 <dcoutts> ohmega: you heard it was cool right? :-)
04:20:58 <matthew-_> i.e. /foo/bah/baz will return "baz" in getProgName
04:21:52 <ohmega> i was using wmii but all the plan9 crud is getting on my nerves of course! nice that someone had the same idea :)
04:25:20 <matthew-_> grrr. This is a little frustrating. /me considers rewriting getArgs to give the proper argv
04:25:44 <quicksilver> matthew-_: yes, it seems stupid to me
04:25:56 <quicksilver> matthew-_: like they half-fixed a problem and left it more broken than the original
04:26:28 <quicksilver> matthew-_: maybe tehre is something in System.Posix?
04:30:43 <ndm> eumenides: if thats what people want, easily
04:31:04 <ndm> robreim: what will i need to test the patch
04:31:18 <ndm> kolmodin: http://www.cse.unsw.edu.au/~dons/binary.html - and in the haddock
04:31:19 <lambdabot> Title: Data.Binary - efficient, pure binary serialisation for Haskell
04:31:35 <gabor> dcoutts: thanks, this seems to work :-)
04:33:00 <ohmega> hm.
04:33:15 <ohmega> the README file should say: $ runghc Setup.lhs configure
04:33:27 <kolmodin> ndm: the deriving code doesn't work that way
04:33:29 <ohmega> in X11-extras I think
04:33:48 <ndm> kolmodin: i meant in the example, not in the deriving code - i've been working off the example
04:33:50 <kolmodin> ndm: I think dons might have rewritten the code on the homepage
04:34:09 <kolmodin> ndm: the deriving tool, as far as I know, doesn't generate code like that
04:34:11 <ndm> kolmodin: plus have you seen derive? that does binary deriving, and others
04:34:22 <kolmodin> it deis it the getWord8 style
04:34:25 <kolmodin> *does
04:34:37 <ndm> limited to 256 constructors?
04:34:44 <kolmodin> ndm: possibly
04:34:55 <robreim> ndm: ghc-6.6, the latest darcs pull of the network library, windows and the patch at http://hackage.haskell.org/trac/ghc/ticket/1238
04:34:57 <lambdabot> Title: #1238 (ByteString based datagram communication) - GHC - Trac
04:35:00 <kolmodin> I wrote that in january some time
04:35:08 <kolmodin> haven't had time to look into it further
04:35:34 <ndm> kolmodin: i'd just direct people at Data.Derive, if i were you - it has all the necessary tools to do Binary Deriving, and more output formats etc
04:36:09 <eumenides> ndm: it'd be really handy. perhaps as a command line option to derive
04:36:36 <kolmodin> ndm: I should look into that then. thanks!
04:37:40 <ndm> eumenides: its a sensible default for something like get/put
04:39:17 * ndm -> lunch
04:40:31 <kolmodin> ndm: so your derive is the new Drift?
04:41:34 <kolmodin> gah, I think I missed him
04:42:35 <mauke> blargh
04:42:42 <kolmodin> ndm: found your homepage, Indeed you are the "new" drift
04:42:43 <mauke> why can't hugs derive through newtypes?
04:46:55 <dcoutts> mauke: it's a Haskell extension that Hugs does not implement
04:47:04 <haraldk> mauke: well, it is an extension, perhaps they haven't ... exactly
04:49:04 <mauke> but it's so simple/useful :(
04:54:43 <drigz> by the way, to everybody who helped me earlier, thanks! (sorry, i went to lunch)
04:59:18 <SamB_XP_> mauke: you could maybe implement it!
04:59:46 <kolmodin> ndm: looks like I can retire my hack in favor of your much nicer app
05:18:18 <SamB_XP_> snap.com is wierd... they open pages in an actual browser to render thumbnails... with a PDF plugin and everything!
05:18:37 <ivanm> its annoying though...
05:19:18 <SamB_XP_> I mean, I can see the toolbars of the PDF plugin in this one screenshot!
05:20:22 <Saizan> and the bookmarks toolbar maybe?:D
05:21:37 <SamB_XP_> Saizan: that isn't part of the client area of any browser!
05:21:44 <LeCamarade> I guess they just run a Mozilla engine, and then grab the images off it.
05:22:28 <SamB_XP_> does adobe's PDF plugin look the same in Linux?
05:22:52 <LeCamarade> It isn't that hard. Get Firefox, remix it, so that it will write a JPEG of the display it should otherwise paint, and you have it. I think. Must be wrong.
05:23:10 <SamB_XP_> I don't think that works with plugins, somehow ;-)
05:23:41 <SamB_XP_> except maybe with randr...
05:24:13 * earthy thinks vnc and a custom client would suffice to display *any* app
05:24:21 <SamB_XP_> now, render to imaginary display, that could work...
05:24:34 <SamB_XP_> earthy: well, it does not display the non-client area
05:24:35 <int-e> x11 allows screen captures anyway.
05:25:28 <SamB_XP_> yeah. it probably just runs a hacked-up mozilla that saves a screenshot in a framebuffer-based X server -- *if* adobes PDF viewer looks the same in Linux as in Windows.
05:25:37 <SamB_XP_> er. by framebuffer-based...
05:25:50 <SamB_XP_> I mean that it does not actually use a graphics card.
05:26:51 <SamB_XP_> I know they queue things up to render, because I once encountered one that had not yet been rendered and was told it had just been added to the queue ;-)
05:27:12 <earthy> given VNC and a capturing client they could actually just run windows
05:27:25 <earthy> as VNC displays the entire display
05:27:47 <SamB_XP_> eh? windows you say?
05:27:57 <SamB_XP_> well, they could run windows even with no VNC...
05:28:10 <earthy> but could they capture programmatically?
05:28:15 <SamB_XP_> sure!
05:28:30 <SamB_XP_> what kind of window system has no screen capture facility?
05:28:45 <earthy> AmigaOS
05:28:53 <SamB_XP_> huh.
05:29:09 <SamB_XP_> well, I bet you can do it anyway on AmigaOS if you don't mind tearing...
05:29:18 <earthy> iirc. :)
05:30:11 <SamB_XP_> anyway, paint shop pro can grab screenshots of individual windows, so...
05:30:24 <SamB_XP_> (or should I call them widgets?)
05:30:31 <earthy> yeah, that's doable
05:30:39 <SamB_XP_> (win32 might only refer to the toplevel ones as windows)
05:31:27 <SamB_XP_> anyway, the mozilla trick would still work fine, but then again you could use the IE control...
05:31:44 <earthy> or embed gecko
05:32:21 <Fibs> um, hi :)
05:32:28 <earthy> hi fibs
05:33:20 <vali> hello Fibs
05:33:28 <Fibs> I really don't know much about haskell but I thought I'd learn something new, so yeah, I thought this might be a good place to start
05:35:11 <Saizan> fibs: yeah, most of us arrived here for the same reason :)
05:35:45 <earthy> not all though :)
05:35:57 <earthy> jaffacake already knew a good bit of haskell :)
05:36:12 <Fibs> It's really fascinating
05:36:17 <Saizan> the others are the one that made our decision right :)
05:36:35 <Saizan> *ones
05:37:36 <fasta> @where RefMonad
05:37:36 <lambdabot> I know nothing about refmonad.
05:37:48 <SamB_XP_> earthy: I call embedding gecko "hacked up mozilla" ;-)
05:37:55 <fasta> @hoogle RefMonad
05:37:56 <lambdabot> No matches found
05:38:04 <earthy> samb: :)
05:38:26 <fasta> Anybody else knows where I can get a RefMonad?
05:38:50 <fasta> Never mind
05:38:52 <SamB_XP_> @google refmonad
05:38:55 <lambdabot> http://swik.net/RefMonad
05:38:56 <lambdabot> Title: RefMonad - SWiK
05:39:07 <fasta> http://liinwww.ira.uka.de/~rahn/loop/src/prog/Util/RefMonad.hs <- there is one
05:41:40 <pixel> shouldn't  subRegex (mkRegex "$") "foo" "s"  return "foos" ?
05:42:31 <pixel> i have a one-line fix on http://darcs.haskell.org/libraries/regex-compat/Text/Regex.hs
05:42:42 <pixel> where's the best place to report this?
05:43:00 <fasta> pixel: just send it in via darcs
05:43:31 <fasta> pixel: and be sure that it's not you that's misunderstanding.
05:43:40 <fasta> who's*
05:43:59 <pixel> fasta: well, that's why i wanted some reviewing first :)
05:44:46 <fasta> pixel: 1) you read the documentation 2) If documentation is not clear, file a bug for the documentation, otherwise send the patch
05:45:11 <mux> pixel: the documentation says that by default, mkRegex builds multi-line regexes
05:45:19 <mux> so ^ and $ are not supposed to work AFAICT
05:45:19 <glen_quagmire> is there a way to create/modify a module in runtime and save it (to directory/file) ??
05:45:26 <mux> you should use mkRegexWithOpts
05:45:40 <pixel> fasta: hum, you're right, seems like it's documented already ("This is unsafe if the regex matches an empty string.")
05:46:06 <mux> > subRegex (mkRegexWithOpts "$" True True) "foo" "s"
05:46:07 <lambdabot>   Not in scope: `mkRegexWithOpts'
05:46:22 <mux> > subRegex (Text.Regex.mkRegexWithOpts "$" True True) "foo" "s"
05:46:22 <fasta> Who nuked chalmers?  http://www.cs.chalmers.se/~rjmh/Globals.ps
05:46:23 <lambdabot>   Not in scope: `Text.Regex.mkRegexWithOpts'
05:46:47 <pixel> mux: this works nicely:  subRegex (mkRegex "(.)$") "foo" "\\1s"
05:47:01 <mux> pixel: ah.
05:47:13 <pixel> the culprit is line: lookup [] _ _ = []
05:47:17 <mux> but that's using a back-reference
05:47:29 <pixel> which really means: if strings matched is empty, return empty
05:47:34 <mux> not exactly the same as your previous try it seems
05:47:48 <mux> anyways, if it works and is expected.. :-)
05:47:54 <fasta> yep, chalmers is wiped off the map
05:48:13 <pixel> whereas removing that line makes it work as "could be expected"...
05:49:19 <pixel> seems like i won't be able to translate s/$/s/ so simply, but at least the "(.)$" "\\1s" trick works :)
05:49:20 * mux gets reply from SPJ saying that what I'm trying to do doesn't work GHC HEAD yet
05:49:31 <mux> it was well worth ruining my existing GHC 6.6 installation
05:49:33 * mux cries
05:49:46 * igli give mux a cookie: there, there
05:49:56 <igli> gives* even
05:49:57 * mux sobs on igli's shoulder
05:50:08 * earthy pulls the cutting edge from mux's bloody hands
05:50:15 * earthy bandages them
05:50:21 * igli hands mux a hankie and tells him to get over it (in a nice way ;)
05:50:38 <pejo> fasta, can't you donwload that globals.ps?
05:50:40 * LeCamarade thinks mux is such a cry baby. But give mux a cookie, all the same.
05:50:42 <igli> you can reinstall surely, mux?
05:51:04 <LeCamarade> s/give/giveth/
05:51:06 * mux likes being handed cookies, and rejoices
05:51:09 <mux> igli: yeah, sure :-)
05:52:04 <igli> heh :D
05:52:18 <fasta> pejo: no
05:52:28 <mux> as LeCamarade found out, I was just being a cry baby
05:52:53 <pixel> what's the best place for a System.Posix.User.getAllUserEntries bugfix?
05:53:03 <fasta> pixel: same answer
05:53:04 <pixel> i tried http://haskell.org/pipermail/libraries/2007-April/007349.html but didn't get any answer
05:53:05 <lambdabot> Title: System.Posix.User.getAllUserEntries bugfix
05:53:12 <earthy> pixel: the GHC trac
05:53:59 <fasta> pixel: you can also spam every place with a program until it is included in base.
05:56:40 <vali> does "take" only work with lists, or does it work with tuples as well?
05:56:58 <Igloo> only lists
05:57:11 <kuribas> vali: what would be the type of that?
05:57:46 <roconnor> > (logBase 2 10)*13395
05:57:47 <lambdabot>  44497.226831016225
05:57:49 <vali> kuribas: hmm, i suppose tuples can store many different types
05:58:29 <fasta> kuribas: You would get something like HLists, I guess
06:00:30 <dolio> take wouldn't really type on HLists, though.
06:00:39 <kuribas> I don't think you can represent a list by a tuple.
06:00:47 <dolio> Because 'htake 3 hlist' has a different type than 'htake 4 hlist'
06:01:19 <dolio> That'd probably require dependent types.
06:01:25 <mux> well, mtl-at will have to wait
06:01:46 <dolio> Or you'd have to use type-level naturals.
06:02:30 <pixel> earthy: thanks, reported in ghc trac
06:07:11 <tom_> does anyone here know of a bloom filter implementation in haskell?
06:10:46 <tom_> I haven't been able to find so i guess I'll try implementing it myself
06:13:39 <tom_> I could use some advice on doing it though, any thoughts on the best way to get effcient arrays of bits. I'll mainly be flipping and testing individual bits
06:14:10 <twanvl> UArray Bool?
06:15:29 <tom_> How much storage would that use? Just 1 bit per element or is it more?
06:16:00 <twanvl> I think just 1 bit per element
06:16:12 <Saizan> 1 bit
06:16:24 <tom_> Excelent, that sounds like just what I need then
06:16:26 <tom_> thanks
06:16:54 <Saizan> STU or IOU if you need mutable ones
06:17:29 <tom_> I'm wondering if i'll need to use the IO monad to get this working efficiently, but I'm hoping now
06:18:15 <tom_> I was planning on using a tree of bit arrays (which will be UArray Bool now) so when I produce an update version it can share most of it's structure with the previous version
06:19:00 <Saizan> seems good
06:19:54 <Saizan> http://www.haskell.org/haskellwiki/Modern_array_libraries <-- a nice overview of the various array flavors
06:20:21 <lambdabot> Title: Modern array libraries - HaskellWiki
06:20:59 <tom_> thanks
06:40:22 <mauke> argh
06:40:40 <mauke> mauke_: why are you still online!
06:40:40 <nominolo> @hoogle (a -> Maybe b) -> [a] -> Maybe b
06:40:41 <lambdabot> No matches, try a more general search
06:41:04 <nominolo> what would be a good name for a funtion with this signature?
06:41:20 <nominolo> i.e. a generalized findBy
06:41:23 <nominolo> :t findBy
06:41:25 <lambdabot> Not in scope: `findBy'
06:41:29 <nominolo> er
06:41:37 <nominolo> :t Data.List.findWith
06:41:39 <lambdabot> Not in scope: `Data.List.findWith'
06:42:12 <mauke> :t (msum .) . map
06:42:14 <nominolo> :t find
06:42:15 <lambdabot> forall (m :: * -> *) a a1. (MonadPlus m) => (a1 -> m a) -> [a1] -> m a
06:42:16 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
06:43:00 <nominolo> ok, so I guess findBy would be a candidate :)
06:43:00 <quicksilver> nominolo: head . catMaybes . map ?
06:43:10 <nominolo> :t catMaybes
06:43:13 <lambdabot> forall a. [Maybe a] -> [a]
06:43:14 <quicksilver> :t head . catMaybes . map
06:43:16 <lambdabot>     Couldn't match expected type `[Maybe a]'
06:43:17 <lambdabot>            against inferred type `[a1] -> [b]'
06:43:26 <quicksilver> :t \f -> head . catMaybes . map f
06:43:29 <lambdabot> forall a a1. (a1 -> Maybe a) -> [a1] -> a
06:43:34 <balodja> > floor -1.001
06:43:34 <lambdabot>   add an instance declaration for (Fractional (a -> b))
06:43:39 <balodja> hm-m-m
06:43:45 <mauke> > let foo f = msum . map f in foo (\x -> if x > 5 then Just x else Nothing) [1 .. 10]
06:43:47 <lambdabot>  Just 6
06:43:53 <balodja> what's wrong?
06:43:59 <rahikkala> > floor (-1.001)
06:44:01 <lambdabot>  -2
06:44:02 <mauke> balodja: the - operator
06:44:09 <balodja> oh, i see
06:44:10 <nominolo>  findBy f = msum . map f
06:44:17 <nominolo> this is the one i look for
06:44:27 <Igloo> There needs to be a yhc channel so I can suddenly exclaim "It's all ndm's fault!" without everyone looking oddly at me
06:44:55 <quicksilver> Igloo: you can certainly exclaim that here if you like
06:45:02 <quicksilver> Igloo: it has a certain ring of truth to it, I think
06:45:06 <quicksilver> It's all ndm's fault!!!
06:45:25 * Lemmih looks oddly at quicksilver.
06:47:22 <mauke> > let foo f = msum . map f in foo (\x -> guard (x > 5) >> return x) [1 .. 10]
06:47:23 <lambdabot>   add an instance declaration for (Show (m a))
06:47:37 <mauke> > let foo f = msum . map f in foo (\x -> guard (x > 5) >> return x) [1 .. 10] :: [Int]
06:47:39 <lambdabot>  [6,7,8,9,10]
06:47:53 <mauke> > let foo f = msum . map f in foo (\x -> guard (x > 5) >> return x) [1 .. 10] :: Maybe Double
06:47:55 <lambdabot>  Just 6.0
06:48:07 <quicksilver> nominolo: ah, you're right of course
06:48:15 <quicksilver> nominolo: msum is better than head.catMaybes
06:48:18 <fantasmaa> anyone know of any application online that will let me execute some quick java code?
06:49:02 <nominolo> quicksilver: actually, i didn't know of catMaybes
06:51:24 <ADEpt> is there a variant of Data.Map that is strict in it's arguments? Or what should one use to implement poor man's memoization of some recursive numeric function?
06:52:47 <hpaste>  ADEpt pasted "problem14 finishes in 30 secs, problem14' eats 1.3Gb of ram in 30 minutes" at http://hpaste.org/1430
06:53:17 <nominolo> ADEpt: s/minutes/seconds/ ?
06:53:52 <haraldk> fantasmaa: topcoder ;-)
06:54:04 <ADEpt> nominolo: no, minutes
06:55:10 <nominolo> ADEpt: ah, I took your problem14<prime> for problem14<end-quote>
06:55:41 <mauke> ADEpt: an array?
06:56:24 <ADEpt> mauke: i have no way to estimate the upper index bound :(
06:57:31 <mauke> unrelated comment: do you know evalState/execState?
06:58:17 <dolio> ADEpt: You might be able to get something out of the little memoizing module I made here: http://haskell.org/haskellwiki/Haskell_Quiz/Happy_Numbers/Solution_Dolio
06:58:20 <lambdabot> Title: Haskell Quiz/Happy Numbers/Solution Dolio - HaskellWiki, http://tinyurl.com/yqwvr3
07:00:19 <dolio> It'll memoize, at least, an arbitrary function on positive integers (I think it has a bug with negative Integers).
07:00:20 <ADEpt> mauke: oh, fst could be avoided, of course.
07:04:20 <fantasmaa> ADEpt: is that project euler?
07:05:17 <quicksilver> > catMaybes [Just 4, Nothing, Just 3, Nothing, Nothing, Just 12]
07:05:19 <lambdabot>  [4,3,12]
07:05:23 <quicksilver> nominolo: it's useful :)
07:05:45 <quicksilver> nominolo: I actually use head.catMaybes quite often but to be honest I should probably be using msum
07:06:10 <nominolo> quicksilver: oh, I just used that earlier that day
07:06:18 <nominolo> though, i used list comprehensions
07:06:36 <quicksilver> yes, list comprehension + pattern match is more powerful than catMaybes
07:06:39 <fantasmaa> ADEpt: i did that problem in haskell in one line (if I remember correctly)
07:06:52 <quicksilver> in fact catMaybes l = [ x | Just x <- l]
07:06:54 <nominolo> @check \xs -> catMaybes xs == [ x | Just x <- xs ]
07:06:55 <lambdabot>  Add a type signature
07:07:04 <nominolo> @check \xs -> catMaybes (xs :: Maybe Int) == [ x | Just x <- xs ]
07:07:05 <lambdabot>  Couldn't match expected type `[Maybe a]'
07:07:19 <nominolo> @check \xs -> catMaybes (xs :: [Maybe Int]) == [ x | Just x <- xs ]
07:07:20 <lambdabot>  OK, passed 500 tests.
07:07:26 <quicksilver> @src catMaybes
07:07:27 <lambdabot> catMaybes ls = [x | Just x <- ls]
07:07:31 <quicksilver> and there you go :)
07:07:34 <nominolo> lol
07:07:35 <ADEpt> fantasmaa: and which line it was? :)
07:08:35 <vali> mergeSort :: Ord a => [a] -> [a] ... hmm, does this mean: mergeSort takes a list as parameter, returns a list and that it is of type "a" in the class "Ord"?
07:09:14 <fantasmaa> ADEpt: I dont think I have it here at school but I definitely have it at home some where
07:09:28 <dolio> Mine's more than 1 line, but it doesn't use dynamic programming.
07:09:29 <fantasmaa> > let p 0 = 1; p n = sum $ map (\k -> ((-1)^(k+1))*(p(n-(k*(3*k-1) `div` 2)) + p(n-(k*(3*k+1)) `div` 2))) [1..n] in p 13
07:09:31 <lambdabot>  101
07:09:50 <nominolo> vali: no, "a" must be an instance of Ord
07:09:55 <Igloo> vali: Each element of each list is of type a, and a is in the class Ord, yes
07:10:00 <nominolo> vali: i.e., it must be comparable
07:10:17 <vali> hmm, ok
07:10:46 <nominolo> or, there is an _Ord_er defined on "a"
07:11:50 <LeCamarade> ?src reverse
07:11:51 <lambdabot> reverse = foldl (flip (:)) []
07:15:49 <nominolo> that's an evil src
07:15:55 <fantasmaa> ADEpt: up to which problem are you?
07:16:31 <Cale> evil?
07:16:39 <Cale> That's actually one of the nicer ones.
07:16:46 <nominolo> not newbie-friendly
07:16:56 <nominolo> @src foldr
07:16:56 <lambdabot> foldr k z xs = go xs
07:16:57 <lambdabot>     where go []     = z
07:16:57 <lambdabot>           go (y:ys) = y `k` go ys
07:16:58 <Cale> In fact, that's how I'd define it :)
07:17:09 <Cale> That foldr is terrible
07:17:16 <nominolo> this is, well .. it could be nicer :)
07:17:24 <nominolo> @src fromMaybe
07:17:24 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
07:17:32 <Cale> @src map
07:17:33 <lambdabot> map _ []     = []
07:17:33 <lambdabot> map f (x:xs) = f x : map f xs
07:17:48 <dolio> @src sortBy
07:17:49 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
07:17:56 <Cale> map f = foldr ((:) . f) []
07:18:43 * Saizan founds that many DFA-related functions could be better expressed in haskell, rather than insiemistic notation
07:19:09 <ADEpt> fantasmaa: i'm not doing them in order. Did about 20 in total in 1 day ... You can see here: http://projecteuler.net/index.php?section=profile&profile=10336
07:19:11 <lambdabot> Title: Project Euler
07:19:45 <fantasmaa> nice
07:20:34 <fantasmaa> let me know when you get to 28, it seems very easy but I havent used haskell in a month so I'm strugling
07:20:54 <dolio> Is GHC's sort really insertion sort?
07:21:27 <Cale> @src sort
07:21:28 <lambdabot> sort = sortBy compare
07:21:28 <rahikkala> sortBy cmp l = mergesort cmp l
07:21:41 <rahikkala> Quicksort replaced by mergesort, 14/5/2002.
07:22:07 <Cale> @src sortBy
07:22:07 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
07:22:09 <dolio> Where does lambdabot pull from?
07:22:18 <Cale> okay, I don't know where it's getting that sortBy
07:22:48 <ADEpt> fantasmaa: err.. You mean problem 28? I haven't doe it yet.
07:22:49 <Cale> Most things it gets from the GHC sources, but that looks like it's maybe the Report version
07:23:04 <rahikkala> http://haskell.org/onlinereport/list.html
07:23:05 <lambdabot> Title: The Haskell 98 Library Report: List Utilities
07:23:34 <dolio> Ah. That'd explain it, I guess.
07:29:51 <pierre-> can you recommend me some bsd os with good haskell support?
07:30:09 <earthy> freebsd
07:30:19 <earthy> mac os x
07:30:27 <LeCamarade> dons uses OpenBSD.
07:30:46 <earthy> didn't that have an issue on x86-64?
07:30:56 <LeCamarade> pierre-: So he can help you anytime.
07:31:13 <LeCamarade> @google haskell openbsd
07:31:14 <lambdabot> http://www.cse.unsw.edu.au/~dons/haskell_openbsd.html
07:31:14 <lambdabot> Title: Haskell on OpenBSD
07:31:53 <ndm> Igloo: whats all my fault? (this time)
07:32:19 <pierre-> LeCamarade: i thought on openbsd, but i found that ghc in ports is very old
07:33:17 <LeCamarade> pierre-: No, you don't have to rely on the packages. You can get it from the web.
07:33:23 <LeCamarade> @where ghc
07:33:24 <lambdabot> http://haskell.org/ghc
07:33:26 <LeCamarade> There.
07:33:45 <LeCamarade> pierre-: Avez-vous compris?
07:34:32 <pierre-> LeCamarade: oui, merci :-)
07:34:53 <ndm> @seen dons
07:34:53 <lambdabot> dons is in #haskell-soc and #haskell. I last heard dons speak 7h 27m 13s ago.
07:35:45 <Igloo> ndm: I don't know, but your buildbot keeps telling me you're to blame  :-)
07:35:55 <LeCamarade> pierre-: De rien. Et vous savez nous avons #haskell-fr, si vous e^tes interesse' ...
07:36:11 <ndm> Igloo: ah, those buildbot failures - they are actually the bytestring peoples fault!
07:36:12 * LeCamarade says a profuse sorry to the non-Francophone lambdamen. :oD
07:36:38 <ndm> Igloo: GHC 6.6 works fine, GHC 6.4.2 requires fps - beacuse of our requirement for binary - which screws up the dependancies
07:36:53 <tom_> How can I specify that a type must be of 2 classes in signature? I want to recieve a value fo a type which is both a memeber of Integral and of bits
07:36:53 <bluestorm> LeCamarade: seems you're on a qwerty keyword, trying to speak french ^^
07:37:06 <tom_> This is what I have right now: bloom :: (Bits b, Bits c, Integral c) =>  (a -> b) -> c -> Int -> Bloom a b
07:37:17 <kbral> @version
07:37:17 <lambdabot> lambdabot 4p517, GHC 6.6 (OpenBSD i386)
07:37:18 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
07:37:30 <tom_> But ghc complains of "Ambiguous type variable `t' in the constraints:"
07:37:30 <LeCamarade> bluestorm: Yeah. Without even an AltGr key! Torment! My keyboard has an accent. :oD
07:37:49 <bluestorm> you shoud try the qwerty_intl keymap
07:38:15 <LeCamarade> Hmm ... I'll need like a few pointers on how to fix that ...
07:38:58 <mauke> tom_: hmm, your type signature looks ok
07:39:20 <bluestorm> LeCamarade:
07:39:22 <mauke> LeCamarade: compose key ftw!
07:39:28 <bluestorm> setxkbmap -layout us -variant intl
07:39:45 <bluestorm> then '+e will do wonders
07:40:05 <mauke> deadkeys :/
07:40:48 <tom_> ah, the problem was my use of literals when calling it. I've changed the calls to include type sigs and it works
07:41:00 <LeCamarade> bluestorm: Okay, I have set that. So ... now that I have no AltGr, next?
07:41:03 <tom_> But now my call looks like this: (bloom id (1024::Int) (10::Int) :: Bloom Int Int)
07:41:07 <LeCamarade> +e?
07:41:14 <bluestorm> pres ' then e
07:41:17 <tom_> which is less pretty, any way of having it just pick a type that fits?
07:41:31 <bluestorm> (to do ' you have to do '+space)
07:41:43 <bluestorm> (setxkbmap -layout us  will get your configuration back ^^)
07:42:05 <LeCamarade> Oh! Libert, galit, Fraternit!
07:42:28 <bluestorm> you can even do  and other cool things with some imagination
07:42:47 <LeCamarade> Yeah. Least I can write, now.
07:45:17 <LeCamarade> En francais.
07:45:23 <LeCamarade> bluestorm: Can you gimme a guide to these key sequences? Link, I mean.
07:45:35 <bluestorm> hm
07:46:02 <sjanssen> @keal
07:46:02 <lambdabot>  what have you been smoking? you narrow minded Haskell user?
07:46:07 <procyon112> ?src foldr
07:46:08 <lambdabot> foldr k z xs = go xs
07:46:08 <lambdabot>     where go []     = z
07:46:08 <lambdabot>           go (y:ys) = y `k` go ys
07:46:23 <LeCamarade> bluestorm: hm?
07:47:26 <ndm> @seen dcoutts
07:47:27 <lambdabot> dcoutts is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard dcoutts speak 2h 11m 16s ago.
07:47:33 <ndm> @slap dcoutts
07:47:34 * lambdabot smacks dcoutts about with a large trout
07:47:44 <kolmodin> ?localtime dcoutts
07:47:46 <lambdabot> Local time for dcoutts is Wed Apr 18 00:46:34
07:48:05 <nominolo> does anyone know if ghc has a switch to print out the dependency list, i.e. the files that will be used by 'ghc --make' ?
07:48:11 <bluestorm> i once found a image of the keymap
07:48:18 <sjanssen> nominolo: there's ghc -M
07:48:22 <bluestorm> but i can't found it anymore
07:48:35 <bluestorm> so you'll have to try each key :p
07:49:34 <nominolo> sjanssen: i was looking for something simpler, but ok.  I just want to restrict my todo-list to the files that are actually used :)
07:53:53 <Saizan> do you think it would be hard to implement a -fmonomorphic-literals ? or is there something equivalent?
07:54:14 <matthew-_> mmm. is there any magic variable set by cabal during compilation? using TH and doing file access during compilation, I'm somewhat at the mercy of where compilation is invoked from in terms of relative paths.
07:54:45 <ndm> Igloo: have you take a look at the makeRelative issue in filepath?
07:55:03 <doserj> Saizan: use -fno-implicit-prelude
07:55:09 <Igloo> ndm: I've read the bug discussion
07:55:12 <ndm> i was looking for some Unix person's input on what the "right thing" (TM) is
07:55:25 <doserj> then literals use whatever fromInteger is in scope
07:55:29 <ndm> i.e. should makeRelative introduce .. 's in the path?
07:55:41 <ndm> or is that bad, evil and wrong?
07:56:05 <Igloo> ndm: Oh, not sure about that OTTOMH
07:56:15 <ndm> @abbrev OTTOMH
07:56:15 <lambdabot> Unknown command, try @list
07:56:21 <ndm> @wtf OTTOMH
07:56:21 <lambdabot> Maybe you meant: bf ft wn
07:56:27 <kolmodin> :)
07:56:28 <matthew-_> off the top of my head
07:57:01 <Saizan> doserj, uhm i was thinking of it, is it called also on fractional literals?
07:57:41 <ndm> the implementation bit is easy, but i'd like someones feedback on the properties - then i can get the right implementation
07:58:21 <kolmodin> ndm: /foo/bar doesn't have to be the same as /foo/../foo/bar as you can have soft links in the filesystem
07:58:36 <doserj> Saizan: fractional literals use fromRational
07:58:39 <ndm> kolmodin: so should makeRelative not introduce .. then?
07:58:46 <kolmodin> ndm: correct
07:59:07 <ndm> kolmodin: thats all i needed to hear - now i can come up with properties that test that, and implementation to match
08:00:03 <doserj> Saizan: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#rebindable-syntax
08:00:05 <lambdabot> Title: 7.3. Syntactic extensions, http://tinyurl.com/y6v6by
08:00:25 <Saizan> thanks
08:00:51 <kolmodin> ndm: I'm pretty sure that has bitten me a couple of times
08:01:30 <kolmodin> although now I can't repeat that behaviour
08:04:39 <sjanssen> mkdir -p a/b/bar; ln -s a/b foo # should do it
08:04:44 <kolmodin> ndm: aye, my shell was playing tricks on me. don't introduce ..
08:04:57 <ndm> kolmodin: your wish is my command
08:05:10 <kolmodin> awsome! get me another cup of tea!
08:05:24 <kolmodin> j/k :) thanks!
08:05:52 <kolmodin> ndm: btw, great work with the derive stuff. I can deprecate my hack now
08:06:25 <ndm> kolmodin: cool :) - nice we hope to have it released within a few days
08:06:45 <kolmodin> nice :D
08:21:48 <roemer> is there someone who can help me with installing wxHaskell in Ubuntu Feisty Fawn?
08:23:34 <fasfafa> http://lads.sytes.net Join Please
08:23:38 <lambdabot> Title: lads - [ LV ]
08:23:39 <fasfafa> http://lads.sytes.net Join Please
08:23:41 <lambdabot> Title: lads - [ LV ]
08:24:07 <LeCamarade> roemer: Maybe not. But say the problem.
08:24:52 <roemer> i followed the following:    1.  Make sure you have the following packages installed:
08:24:52 <roemer>           * libwxgtk-2.6-0
08:24:52 <roemer>           * libwxgtk-2.6-dev
08:24:52 <roemer>           * ghc6
08:24:52 <roemer>           * freeglut3-dev
08:24:52 <roemer>           * g++
08:24:54 <roemer>           * libx11-dev
08:24:56 <roemer>    2. Build wxhaskell with the following commands:
08:24:58 <roemer> darcs get http://darcs.haskell.org/wxhaskell
08:25:00 <lambdabot> Title: Index of /wxhaskell
08:25:00 <roemer> cd wxhaskell
08:25:02 <roemer> ./configure --with-opengl
08:25:04 <roemer> make
08:25:06 <roemer> sudo make install
08:25:08 <roemer> make wx
08:25:10 <roemer> sudo make wx-install
08:25:14 <roemer> except "darcs...", i downloaded wxhaskell fom the site
08:25:40 <roemer> but when i want to doe "make" (after configure) it gives error(S)
08:25:52 <sjanssen> @paste them
08:25:53 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:26:27 <LeCamarade> roemer: Also, dumping lots of text here usually gets the admins against you. Use hpaste.
08:26:27 <roemer> last lines from te make-log: wxc/include/wrapper.h:474: error: conversion from char* to const wxString is ambiguous
08:26:27 <roemer> /usr/include/wx-2.6/wx/string.h:643: note: candidates are: wxString::wxString(wxChar, size_t) <near match>
08:26:27 <roemer> /usr/include/wx-2.6/wx/string.h:633: note:                 wxString::wxString(int) <near match>
08:26:27 <roemer> wxc/include/wrapper.h: At global scope:
08:26:27 <roemer> wxc/include/wrapper.h:534: error: default argument for parameter of type const wxString& has type const char [11]
08:26:30 <roemer> make: *** [out/wxc/ewxw_main.o] Error 1
08:26:42 <roemer> oeps.. sorry, how does hpaste works?
08:26:52 <LeCamarade> roemer: No, don't put the big text here.
08:26:57 <LeCamarade> @slap roemer
08:26:57 * lambdabot slaps roemer
08:27:11 <LeCamarade> @paste
08:27:12 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:27:29 <LeCamarade> Go there, and put the stuff there, under appropriate headings.
08:27:37 <sjanssen> roemer: I'd suggest using the darcs version, the release may be quite stale
08:31:49 * ndm thinks haskell should stop making tarballs, and demand everyone uses the darcs versions of everything
08:32:06 <milkcan> hi everyone, shooting rampages are great!
08:32:10 <milkcan> death to all students in virginia
08:32:14 <ndm> i hate that hackage is tarball based, it guarantees out of date code with known bugs
08:32:31 <ndm> milkcan: #haskell-blah for things not on the topic of haskell
08:32:54 <milkcan> hahahha
08:33:41 <LeCamarade> ndm: Youre right. Much better. But ... that may require darcs' availability to go further.
08:33:43 --- mode: ChanServ set +o sjanssen
08:34:03 <LeCamarade> @slap milkcan
08:34:03 <lambdabot> why on earth would I slap milkcan
08:34:10 <LeCamarade> @slap -f milkcan
08:34:11 * lambdabot smacks -f milkcan about with a large trout
08:34:20 <ndm> LeCamarade: i can't believe there are many haskell users who aren't darcs users already (apart from kosmikus)
08:34:31 <twanvl> One advantage of tarbals is that you can actually refer to a release by saying "version x.y.z"
08:35:04 <sjanssen> bah, can gaim not kick people?
08:35:28 <LeCamarade> Well, not all users of Haskells current tarballs are Haskell users. Some are grandmothers who have been told to type `make and hit the big button.
08:35:49 <LeCamarade> twanvl: You can do that with darcs, too.
08:36:08 <twanvl> yes
08:36:41 <Blacksitox> erg0t, :)
08:38:10 <milkcan> shooting rampages are funny
08:38:15 <erg0t> h
08:38:58 * LeCamarade wishes the slaps were more-vicious.
08:39:03 <LeCamarade> @slap -f milkcan
08:39:04 <lambdabot> why on earth would I slap -f milkcan
08:39:16 <LeCamarade> @slap -f milkcan
08:39:17 * lambdabot slaps -f milkcan
08:39:32 <ndm> milkcan: you probably want to stop saying that, its off topic, and might be considered a bit offensive by some (and not particularly funny by anyone)
08:40:10 --- mode: ChanServ set +o Igloo
08:40:19 <milkcan> its very funny
08:40:36 --- mode: Igloo set +b *!*@host-212-149-255-186.kpylaajakaista.net
08:40:44 --- kick: milkcan was kicked by Igloo (Igloo)
08:41:06 <osfameron> now *that* was funnier
08:41:07 <LeCamarade> @beer Igloo
08:41:08 <lambdabot> Igloo is in #darcs, #ghc and #haskell. I last heard Igloo speak 31m 55s ago.
08:41:51 <LeCamarade> lambdabot: You should start handing beers around! Tight-fisted Tasmanian devil.
08:42:11 <malcolmw> @karma+ Igloo
08:42:12 <lambdabot> Igloo's karma raised to 18.
08:42:38 * sjanssen resolves to use a real irc client from now on
08:42:45 <Igloo> @karma+ ndm # waking me up  :-)
08:42:46 <lambdabot> ndm's karma raised to 17.
08:43:02 <glguy> sjanssen: did you try to ban him and couldn't get the command right?
08:43:16 <sjanssen> glguy: gaim issue, I think
08:43:26 <glguy> ah
08:43:45 <glguy> I only use gaim or trillian for IRC when I'm in a desperate pinch ;)
08:43:48 <mux> IRC over gaim must be very painful
08:44:26 <glguy> when I just have to have my IRC fix
08:44:35 <glguy> but can't install a proper client, and can't ssh out
08:44:54 <sjanssen> mux: it doesn't really bother me
08:46:56 <roemer> LeCamarade: I used darcs, and when i run "./configure" i get "permission denied", and when i run "sudo ./configure", i get "command not found", while i am in the correct dir... any idea?
08:47:18 <malcolmw> chmod +x configure ?
08:48:32 <roemer> thanks :)  (yeah, newbie here)
08:49:03 --- mode: ChanServ set -o sjanssen
08:49:32 <emu> i think chanserv can do the kicking and banning for you too
08:50:58 <Saizan> emu: doesn't seem so from /msg chanserv help
08:51:36 <Thomsn> Does someone know why i'm getting an type error when i'm trying to load a function "check :: [Int] -> Bool   check x = count(filter x) >= 5" to Hugs? (filter filters modulo 2 and count .. counts)
08:52:03 <mauke> :t filter
08:52:06 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
08:52:12 <mauke> filter takes two arguments
08:53:07 <Botje> Thomsn: you probably want even or odd, then.
08:53:15 <Botje> > even 42
08:53:16 <lambdabot>  True
08:53:30 <mauke> length (filter even x) >= 5
08:53:39 <Thomsn> Sorry, mean a self defined function filter that realy only filters a list by even.
08:53:54 <mauke> don't redefine standard functions :(
08:54:03 <Thomsn> The name is filter1. ;)
08:54:09 <mauke> what's its type?
08:54:21 <mux> filter1 is less descriptive than 'filter even' and you don't gain much
08:54:21 <Thomsn> [Int] -> [Int]
08:54:38 <mauke> what's the type of count?
08:54:48 <Thomsn> [Int] -> Int
08:54:56 <mux> erm.
08:55:06 <mauke> what's the error message?
08:55:09 <Saizan> :D
08:55:31 <LeCamarade> You know, before Haskell I had millions of ideas on how to improve the languages I did. And at first I was pissed that they wouldn't work in Haskell. But they are for bugs we don't have! :oD
08:55:39 <Thomsn> Ah... omg...
08:55:44 <Thomsn> Sorry, my mistake.
08:55:52 <Thomsn> Have found the error...
08:55:58 <LeCamarade> @elite Haskell rocketh
08:55:59 <lambdabot> H4$KELl ROcKEt|-|
08:56:11 <Thomsn> But thanks for the help. :)
08:56:21 <Botje> I want a Haskell rocket :[
08:56:42 <Thomsn> Good bye.
08:56:47 <LeCamarade> Botje: Haskell _is_ a rocket.
08:57:21 <Botje> I can't shoot people to the moon with it.
08:57:22 <Saizan> @quote launch
08:57:23 <lambdabot> lennart says: Should Haskell also provide unrestricted side effects, setjmp/longjmp, missile launching functions, etc?  After all, people who don't want to use them can just avoid them. :)
08:57:31 <Botje> therefore it's not a rocket :p
08:58:18 <LeCamarade> It a higher-order rocket - can launch other rockets,. Or take them. Or return them.
08:59:56 <ndm> well semantically _|_ is do anything
09:00:13 <ndm> so you can make error "launch" launch a missile without breaking the semantics
09:00:21 <ndm> although in that case use of Catch should be mandatory
09:00:37 <LeCamarade> ndm: Which brings me to ...
09:00:46 <Botje> but you can't catch rockets!
09:01:29 <LeCamarade> ndm: Why is it that if I call System.Cmd, I cant seem to trap the error in case of a command that fails in the shell beneath System.Cmd.system ?
09:01:58 <LeCamarade> s/call System\.Cmd/call System.Cmd.system/
09:02:20 <ndm> LeCamarade: you mean haskell crashes? and GHC/Hugs? Windows/Linux?
09:02:30 <LeCamarade> no!
09:02:38 <LeCamarade> Lemme get code ...
09:02:45 <Igloo> LeCamarade: If you are using the Prelude's catch then try Control.Exception's catch instead
09:04:09 <ndm> quickcheck++
09:04:41 <ndm> coding up the new filepath method is great, specify some properties that completely capture the semantics, then coding is just a case of satisfying that
09:05:06 <ndm> it turns coding from something clever to something stupid :)
09:05:38 <Saizan> we should have a deriver from quickcheck properties :)
09:05:46 <LeCamarade> Igloo: It doesnt work, either.
09:05:58 <LeCamarade> It seems. I guess 'tis my fault.
09:05:59 <ndm> Saizan: like to be hard... - and the quickcheck properties are rarely complete
09:06:12 <ndm> Saizan: esc/haskell may be a proover from code to quickcheck though :)
09:06:14 <LeCamarade> Just dunno which fault. Segfault in my head.
09:07:55 <LeCamarade> Igloo: Oh, I got it to work.
09:07:57 <Saizan> esc?
09:08:10 <LeCamarade> Thanks, all.
09:16:13 <ndm> Saizan: esc/haskell
09:16:17 <ndm> @google dana esc haskell
09:16:19 <lambdabot> http://www.cl.cam.ac.uk/~nx200/research/escH-hw.ps
09:16:38 <ndm> Saizan: from the haskell workshop, a proof system for haskell - still unuseable so far
09:17:08 <Saizan> oh
09:32:41 <kolmodin> ndm, Igloo: dcoutts was about to create a filepath tarball and upload to hackage earlier today. he didn't get very far, did he?
10:08:37 <kosmikus> ndm: I *am* a darcs user. I just haven't migrated all my (older) projects.
10:09:20 <ndm> kolmodin: he was waiting for me to check in a fix to the makeRelative bug - which i've done now
10:09:34 <ndm> kosmikus: i am still waiting for lhs2tex to move :)
10:10:11 <kolmodin> ndm: ah, ok. so he'll resume that in the morning then
10:10:17 <ddarius> ndm: Poke it with a stick.
10:10:38 <ndm> ddarius: poke what?
10:10:47 <ddarius> lhs2tex
10:10:49 <cod3po37> does anyone know what happened to the Haskell for Lego Mindstorm's projects at http://haskell.cs.yale.edu/lego/ ?
10:11:20 <inverselimit> Is there a function/idiomatic way to call a list of functions on a list of inputs [f,g,h]->[x,y,z]->[f x ,g y, h z]?
10:11:52 <ClaudiusMaximus> > zipWith ($) [(+1), (+2), (+3)] [10,20,30]
10:11:54 <lambdabot>  [11,22,33]
10:12:00 <ndm> cod3po37: the upcoming TMR will have an article about Haskell on a lego mind storms, phil wadler had a student which was doing it - and yhc is the obvious thing to port over
10:12:15 <cod3po37> TMR?
10:12:15 <ddarius> @where tmr
10:12:16 <lambdabot> http://www.haskell.org/tmrwiki/FrontPage
10:12:22 <ndm> inverselimit: list comprehensions
10:12:42 <ndm> > [f x | x <- [10,20,30], f <- [sin, cos,id]]
10:12:44 <lambdabot>  [-0.5440211108893698,-0.8390715290764524,10.0,0.9129452507276277,0.408082061...
10:12:56 <ddarius> @where+ tmr http://www.haskell.org/haskellwiki/TheMonadReader
10:12:56 <lambdabot> Done.
10:13:00 <inverselimit> thanks.
10:13:04 <ndm> oh, you don't want powerset - just use the zipWith
10:13:24 <cod3po37> cool...spring is almost over and it's time for some summer projects :D
10:14:32 <mauke> :t zipWith id
10:14:33 <ddarius> > [f x | x <- [10,20,30] | f <- [(+1), (+2), (+3)] ]
10:14:33 <lambdabot>  Parse error
10:14:35 <lambdabot> forall b c. [b -> c] -> [b] -> [c]
10:14:54 <ndm> cod3po37: porting the yhc bytecode to lego mindstorms should be doable
10:15:02 <ndm> ddarius: lambdabot doesn't support parallel zipz
10:15:15 <ddarius> ndm: I was just checking.
10:15:21 <fasta> Is a semi-group the same as a monoid?
10:16:06 <fasta> ddarius: I heard you know quite a lot about data structures. Is that correct?
10:16:24 <ddarius> I'm pretty sure not, but I forget which operations/relations semi-groups drop.
10:16:26 <mauke> Alternatively, a monoid is a semigroup with an identity element.
10:16:54 <cod3po37> well, I'd even settle for the moment for something like iCommand where you just tell the NXT what to do over BlueTooth...I'm not 100% certain how that would work in a language like Haskell. But getting a better handle on Haskell is the 1st project of the summer.
10:17:08 <fasta> mauke: what do you mean by alternatively in this case?
10:17:21 <Saizan> semi-groups are groups without inverses iirc
10:18:12 <ddarius> @google semi-group
10:18:14 <lambdabot> http://mathworld.wolfram.com/Semigroup.html
10:18:14 <ddarius> mauke is correct
10:18:40 <mauke> fasta: http://en.wikipedia.org/wiki/Monoid
10:18:41 <lambdabot> Title: Monoid - Wikipedia, the free encyclopedia
10:19:08 <glen_quagmire> give me the best tutorial for noobie
10:19:18 <mauke> @where yaht
10:19:18 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
10:19:24 <fasta> "Some authors require semigroups to be non-empty. Others use the term semigroup synonymously with monoid, that is, they assume that a semigroup has an identity element. "
10:19:45 <fasta> mauke: yes, I found that article before you suggested it.
10:20:03 <merus> semi-groups are <3
10:20:28 <glen_quagmire> thanks
10:22:27 <inverselimit> Any advice on constructing a simple ring from arbitrary elements?  E.g. in Python, I would subclass dict (hash table) and just overload + and *.
10:23:26 <Saizan> ?src Num
10:23:26 <lambdabot> class  (Eq a, Show a) => Num a  where
10:23:27 <lambdabot>     (+), (-), (*)           :: a -> a -> a
10:23:27 <lambdabot>     negate, abs, signum     :: a -> a
10:23:27 <lambdabot>     fromInteger             :: Integer -> a
10:23:45 <Saizan> you make your type an instance of Num
10:24:07 <Daveman> xerox :D
10:24:09 <inverselimit> so I can just send abs and signum to bottom if they don't apply
10:24:31 <Saizan> yeaah
10:24:47 <fasta> inverselimit: error "Not implemented" -- is possible
10:24:53 <mauke> method implementations are optional
10:25:04 <mauke> you'll get runtime errors
10:25:04 <Saizan> error "Num class is too big for me!"
10:25:12 <fasta> but can give annoying warnings
10:25:23 <inverselimit> how about the hash tables?
10:25:35 <mauke> why hash tables?
10:25:36 <sjanssen> inverselimit: use Data.Map
10:25:39 <Saizan> Data.Map
10:25:54 <inverselimit> ok I'll check it out.  Thanks!
10:26:43 * Daveman waves to mauke from afar
10:26:56 <mauke> hello, Daveman
10:27:16 <Daveman> Hi :)
10:29:02 <jcreigh> quickcheck is good magic.
10:31:29 <fasta> Unfortunately not all data types have known random generators
10:32:06 <dylan> Maddas: you can't program me!!!
10:32:53 <Maddas> dylan: Forgive my futile attempts, unprogrammable one!
10:33:50 <dylan> wireless keyboards are bad for coding.
10:34:34 <dylan> "eval :::::: Expr ->>>"
10:35:00 <dylan> instead of "eval :: Expr ->"...
10:35:47 <plediii> more like "eval :"
10:37:33 <dylan> plediii: hmm?
10:37:47 <dylan> it skips chars too, but the repeating thing is more annoying
10:37:59 <plediii> hmm, mine never repeats
10:38:10 <plediii> it often spontaneously fails though.
10:38:13 <dylan> it does the when usb component goes insane
10:38:20 <plediii> I've found that's when the battery slips out of place
10:38:23 <dylan> the=that
10:42:04 <SyntaxNinja> @seen shapr
10:42:05 <lambdabot> I saw shapr leaving #haskell 19h 28m 6s ago, and .
10:43:23 <ndm> @seen dcoutts
10:43:24 <lambdabot> dcoutts is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard dcoutts speak 5h 7m 13s ago.
10:43:26 <ndm> @seen dons
10:43:26 <lambdabot> dons is in #haskell-soc and #haskell. I last heard dons speak 10h 35m 45s ago.
10:44:00 <ndm> @tell dons you recently changed the standard instances for your binary library on your home page and the haddocks, any reason?  i'm trying to come up with "the perfect instances" for Data.Derive
10:44:01 <lambdabot> Consider it noted.
10:44:38 <ndm> @tell dcoutts any idea on what Yhc does to use Data.Binary, which requires fps on GHC 6.4, but not on 6.6? its a pain in the butt, if you have any insight as to the "right answer" it would be appreciated!
10:44:39 <lambdabot> Consider it noted.
10:44:56 <LordBrain> i want to use a windows library from ghc, and i need to know how to tell it where the headers and libs are, add them to the search path... only i'm in windows instead of unix, and my ghc and gcc are underneath the visual haskell directory
10:46:59 <sjanssen> ndm: does Yhc have Data.ByteString as part of base?
10:47:11 <ndm> sjanssen: no, but it will one day
10:47:40 <ndm> sjanssen: we need to move to using the standard base libraries, but its a lot of work, and i don't have the time to do it
10:48:33 <sjanssen> ndm: oh, were you asking how the compiler itself can use binary, or how programs built with Yhc can use it?
10:48:40 <sjanssen> s/built with/built by
10:48:56 <ndm> sjanssen: the compiler itself, not programs built with it
10:49:06 <ndm> programs built with can come later
10:49:39 <sjanssen> ah okay, I was trying to answer the latter :)
10:49:54 <sjanssen> fps v. base 2.0 is annoying
10:49:58 <ndm> the latter i can answer
10:50:07 <ndm> the former is can, but every answer i come up with sucks
10:50:33 <sjanssen> and ghc 6.8 may move Data.ByteString into yet another package
10:52:18 <sjanssen> ndm: I think cabal configurations are supposed to do this
10:52:38 <sjanssen> not like that's an immediate solution, though :(
10:53:32 <ndm> sjanssen: which will mean depending on GHC 6.8+ for a feature that isn't even written yet :-)
10:54:19 <sjanssen> ndm: cabal configurations should be backwards compatible
10:54:27 <sjanssen> you can still build cabal on 6.4, right?
10:55:07 <ndm> sjanssen: but still, requires us to tell all users to upgrade cabal first, so we might as well tell them to upgrade to fps
10:56:42 <sjanssen> ndm: you can't use fps with 6.6 (without some major hacking)
10:56:54 <ndm> sjanssen: yeah, all fun things into the mix :)
10:57:13 <sjanssen> ndm: does Yhc use cabal?
10:57:32 <ndm> sjanssen: not yet, but i want to make it, as part of my new and spangly build system written in haskell
10:57:44 <ndm> sjanssen: well the build system will actually build it using haskell, which is neat
10:58:03 <ndm> if cabal wasn't annoying and crap in various funny ways
10:58:15 <ndm> being purely designed for people who write linux packaging systems :(
10:58:53 <sjanssen> ndm: what are your complaints?
10:58:59 <sjanssen> I know about the sdist bug
10:59:18 <ndm> sjanssen: configure is totally illogical, it checks for things it doesn't need, it doesn't complain about things it does need
10:59:23 <LeCamarade> ndm: Not being system-specific is such a shockingly-overwhelmingly difficult thing. We think in idioms, which are shaped by platforms, which vary drastically.
10:59:50 <ndm> LeCamarade: i know, but the set of idioms chosen is always going to be something for someone to complain about :) its my right!
11:00:49 <LeCamarade> ndm: Oui, monsieur. C'est ton droit. 'Tis yo right.
11:00:53 <LeCamarade> :oD
11:00:54 <sjanssen> ndm: that's just a bug waiting to be fixed :)
11:00:57 <ndm> sjanssen: my thoughts on the hooks interface is probably less favourable than a fishes thoughts about hooks
11:01:21 <LeCamarade> ndm: :oD
11:02:02 <procyon112> I'm happy as long as it works on Linux.  I'm used to hacking my windows boxes to make stuff work.. on my linux boxes things "just work" and I want to keep it that way :)  It's a weird reversal of days gone by.
11:06:53 <ndm> hmm, i'm just about to implement deriving "has" for derive
11:07:05 <ndm> given a data structure data Foo = Foo {bar :: Bool}
11:07:30 <ndm> would you expect "has_bar", "hasBar", "hasbar" or what to be a function that takes a Foo and returns a boolean if it has the field bar?
11:08:45 <LeCamarade> ndm: Yes.
11:08:57 <ndm> LeCamarade: which one?
11:08:58 <sjanssen> ndm: I vote hasBar
11:09:08 <ndm> drift goes for hasbar, but i hate that
11:09:16 <ndm> sjanssen: i'm leaning that way too
11:09:20 <sjanssen> hasbar is the worst of the three
11:09:28 <ndm> yep, i agree with that too
11:09:35 <ndm> and _ is not very HaskellIsh
11:09:44 <ndm> hasBar it is then :)
11:09:49 <fasta> I like has_bar, but has-bar even more, but this isn't lisp.
11:10:13 <fasta> How about hASBAR?
11:10:15 <LeCamarade> ndm: hasBar.
11:10:17 * fasta ducks
11:10:26 <ndm> fasta: this isn't the win32 binding
11:10:26 <sjanssen> @slap fasta
11:10:27 * lambdabot smacks fasta about with a large trout
11:10:40 <fasta> @photontorpedo sjanssen
11:10:40 <lambdabot> how does haskell do with large systems?
11:10:53 <fasta> @photontorpedo
11:10:54 <lambdabot> scheme, lisp, php, python, perl, tcl, al banned
11:12:05 <sjanssen> fasta: those are quotes from protontorpedo, a strange person that used to come to #haskell
11:12:11 <sjanssen> @protontorpedo
11:12:12 <lambdabot> does huge or ghc have more stuff?
11:12:36 <sjanssen> @palomer -- haven't typed this one in a while
11:12:37 <lambdabot> They're telling you lies!
11:12:44 <Saizan> <Saizan> @photontorpedo
11:12:45 <Saizan> <lambdabot> is haskell more powerful than any jedii?
11:13:04 <fasta> sjanssen: I thought they were jokes made up by dons.
11:13:20 <sjanssen> fasta: nope, real live IRC quotes
11:13:36 <fasta> @fasta
11:13:37 <lambdabot> Maybe you meant: fact paste
11:13:59 <fasta> sjanssen: so, it only works for photontorpedo?
11:14:06 <Saizan> @keal
11:14:06 <lambdabot> what are epsilons?
11:14:10 <Maddas> sjanssen: Which might as well mean that they are just jokes made up by someone else :-
11:14:11 <Maddas> :-)
11:14:22 <fasta> @dons
11:14:23 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
11:14:42 <fasta> @sjanssen
11:14:43 <lambdabot> Unknown command, try @list
11:14:45 <sjanssen> @girl19 -- is another spoof
11:14:46 <lambdabot> LOL
11:14:58 <fasta> Ok, so only people dons thought were funny.
11:15:00 <inverselimit> another ring question: data E= E Data.Map.Map Char Int  gives the error  `Data.Map.Map' is not applied to enough type arguments  Expected kind `?', but `Data.Map.Map' has kind `* -> * -> *'  how do I declare a data type which wraps a map Char->Int?
11:15:02 <sjanssen> well, not spoof really.  Another person we immortalize with a @
11:15:05 <Maddas> @quote dons
11:15:05 <lambdabot> dons says: think of a monad as a spacesuite full of nuclear waste in the ocean next to a container of apples.  now, you can't put oranges in the space suite or the nucelar waste falls in the ocean, *
11:15:06 <lambdabot> but* the apples are carried around anyway, and you just take what you need.
11:15:14 <sjanssen> fasta: generally people that we're poking fun of
11:15:36 <sjanssen> inverselimit: data E= E (Data.Map.Map Char Int)
11:15:44 <Saizan> or with newtype
11:17:16 <sjanssen> @v
11:17:16 <lambdabot> Exception: <<loop>>
11:17:22 <sjanssen> @v
11:17:23 <lambdabot> Exception: <<loop>>
11:17:26 <sjanssen> @v
11:17:27 <lambdabot> "\""
11:17:36 <LeCamarade> @yow
11:17:37 <lambdabot> I know th'MAMBO!!  I have a TWO-TONE CHEMISTRY SET!!
11:24:46 <fantasmaa> can someone help me create the list [2,2,2,2,4,4,4,4,6,6,6,6,8,8,8,8...etc] (I'm brain dead today)
11:25:49 <dmhouse> > let genXs n = replicate 4 n ++ genXs (n + 2) in genXs 2
11:25:51 <lambdabot>  [2,2,2,2,4,4,4,4,6,6,6,6,8,8,8,8,10,10,10,10,12,12,12,12,14,14,14,14,16,16,1...
11:26:17 <dmwit> > [2,4..] >>= replicate 4
11:26:19 <lambdabot>  [2,2,2,2,4,4,4,4,6,6,6,6,8,8,8,8,10,10,10,10,12,12,12,12,14,14,14,14,16,16,1...
11:26:20 <sjanssen> > concatMap (replicate 4) [2, 4 ..]
11:26:21 <lambdabot>  [2,2,2,2,4,4,4,4,6,6,6,6,8,8,8,8,10,10,10,10,12,12,12,12,14,14,14,14,16,16,1...
11:26:28 <dmhouse> Oh, concat is lazy. Cool.
11:26:39 <xerox> > fix (replicate 4 2 . map (+2))
11:26:40 <lambdabot>  Couldn't match expected type `b -> c' against inferred type `[t]'
11:26:50 <xerox> lagged.
11:26:58 <fantasmaa> thanks all :)
11:27:13 <dmhouse> > fix ((replicate 4 2 ++) . map (+2)) -- nice, xerox.
11:27:14 <lambdabot>  [2,2,2,2,4,4,4,4,6,6,6,6,8,8,8,8,10,10,10,10,12,12,12,12,14,14,14,14,16,16,1...
11:27:35 <xerox> @karma+ dmwit :)
11:27:35 <lambdabot> dmwit's karma raised to 3.
11:27:52 <dmwit> Yay!
11:27:59 <dmhouse> A bit too eager on the old TAB there :)
11:28:15 <fantasmaa> lol!
11:32:58 <eumenides> how do i convert (preferably O(1)) GHC.Word.Word8 <=> String?
11:34:01 <sjanssen> presumably you mean Word8 to Char?
11:34:16 <eumenides> Oops, no. [GHC.Word.Word8] <=> String
11:34:45 <fasta> eumenides: that would only be O(1) if the representation is the same
11:34:55 <fasta> eumenides: (and if GHC supports that)
11:35:03 <sjanssen> eumenides: map (toEnum . fromIntegral)
11:35:09 <sjanssen> that is O(n)
11:36:29 <sjanssen> maybe you could unsafeCoerce#, but I can't recommend that
11:38:05 <Saizan> but Char is 32bit, could it still work?
11:38:53 <dmwit> sjanssen: Now that it's been possible to use it a little, do you still like the current rotation behavior of mod+enter?
11:39:03 <sjanssen> I believe the representations are the same (Word8 is stored as a Word# internally)
11:39:51 <fasta> Imho, that should be compiler optimizations.
11:40:34 <fasta> If it's "to difficult" to implement the compiler technology is not adequate.
11:40:37 <eumenides> wait, nvm. i just switched to the Char8 ByteString since i no longer need the other one for Binary (which was too much trouble so I dropped it)
11:40:37 <LordBrain> i think its generally true, that pretty much anything you could ever want to be lazy is lazy by default in haskell... But don't quote me on that.
11:40:42 <fasta> too*
11:41:01 <sjanssen> dmwit: not really
11:41:08 <sjanssen> dmwit: what are your opinions?
11:41:20 <sjanssen> dmwit: we might just roll back that change
11:41:25 <dmwit> sjanssen: That'
11:41:31 <dmwit> s what I was hoping for. =P
11:41:50 <fasta> LordBrain: One would hope that is the case, yes.
11:42:04 <fasta> LordBrain: but not all is
11:42:37 <LordBrain> some counter examples coming to your mind?
11:42:56 <sjanssen> eumenides: the data types in Data.ByteString and .Char8 are actually the same thing
11:43:42 <eumenides> sjanssen: Binary uses Data.ByteString.Lazy
11:43:55 <eumenides> sjanssen: i don't know if all the bytestrings are the same, but they sure don't typecheck
11:44:44 <fasta> LordBrain: some functions using mfix
11:45:08 <eumenides> wow haha, i converted my toy roguelike to use Data.Array.IArray for the screen, and it's actually noticably slower
11:45:17 <eumenides> ... than using [[a]]
11:45:41 <fasta> eumenides: what operations do you use?
11:45:52 <sjanssen> eumenides: .Lazy and .Lazy.Char8 are the same
11:46:09 <sjanssen> but the lazy and strict variants are distinct
11:46:31 <eumenides> sjanssen: well, one uses Word8 in pack/unpack, the other uses Char
11:47:01 <eumenides> fasta: just arrayList when constructing the level and ! to access the tiles. but i have to convert to strings anyway to show it
11:47:21 <sjanssen> eumenides: right, the functions exported are different, but the actual ByteString data type is the same
11:48:28 <eumenides> sjanssen: well, that doesn't help :/
11:48:42 <fasta> eumenides: ok, then you either have small tiles or the array implementation is rather bad
11:49:04 <eumenides> fasta: 80x23
11:49:22 <fasta> eumenides: 23 is considered small I guess.
11:50:07 <fasta> eumenides: OTOH, I would expect arrays to go faster, but GHC does lots of optimization for lists.
11:50:29 <LordBrain> hmm
11:52:26 <sjanssen> dmwit: if you feel like hacking, I'd accept a patch to make mod+enter behave exactly like dwm
11:53:28 <dmwit> Okay, I'll probably work on that tomorrow at 2:30. (My regularly scheduled hacking time! =)
11:53:34 <eumenides> fasta: arrays are considerably faster when i compile instead of running in ghci (for lists both compiling and ghci was about the same)
11:55:28 <fasta> eumenides: heh, ok, then I am not surprised.
11:55:50 <fantasmaa> sjanssen: do you know of anyone using xmonad on *bsd?
11:56:11 <sjanssen> fantasmaa: dons uses OpenBSD
11:56:15 <sjanssen> fantasmaa: problems?
11:56:27 <fantasmaa> not yet :)
12:05:10 <fons> hi all
12:06:04 <fantasmaa> hi
12:10:54 <hpaste>  fons pasted "Port0.hs" at http://hpaste.org/1432
12:12:00 <hpaste>  fons pasted "portpatch.diff" at http://hpaste.org/1433
12:12:47 <fons> can anyone tell me why patch Port0.hs < portpatch.diff gives me an error?
12:13:59 <fons> patching file Port0.hs
12:14:06 <fons> patch: **** malformed patch at line 5:  --------------
12:14:07 <fons> :S
12:14:43 <fons> the patch seems to be reversed but -R doesn't help either
12:21:16 <dmwit> fons: Try patch <portpatch.diff (i.e. not give Port0.hs)?
12:39:20 <monochrom> dons!
12:39:25 <monochrom> @seen dons
12:39:26 <lambdabot> dons is in #haskell-soc and #haskell. I last heard dons speak 12h 31m 45s ago.
12:53:26 <glguy> I'll need to be more careful with the inherit flags
12:53:30 <glguy> and try this again tonight
13:08:25 <fons> dmwit, It didn't work, that doesn't seem to be the problem
13:09:43 <fons> dmwit, manually applyting the patch line by line seems to make sense (altough the file arguments of diff were swaped)
13:11:08 <fons> I'm obviously doing something stupidly wrong
13:11:45 <fons> I have used patches other times but I never got a similar error
13:14:20 <Heffalump> dmwit: have you checked that hte patch has the right kind of line endings?
13:29:10 <dcnstrct> Happy 17th bday ?
13:29:21 <dcnstrct> when is Haskell's bday exactly?
13:30:07 <Igloo> I can't remember, but you missed it
13:30:55 <stepcut> April 1
13:31:06 <dcnstrct> HAR HAR
13:32:01 <stepcut> dcnstrct: http://haskell.org/haskellwiki/History_of_Haskell
13:32:03 <lambdabot> Title: History of Haskell - HaskellWiki
13:32:13 <stepcut> an interesting paper, if you have not read it
13:32:26 <stepcut> actually, it is interesting even if you have read it :p
13:45:11 <nominolo> @check x == x
13:45:12 <lambdabot>   Not in scope: `x'
13:45:21 <nominolo> @check True == True
13:45:23 <lambdabot>  OK, passed 500 tests.
13:45:59 <nominolo> hm, why does quickcheck run 500 tests for a no-parameter function?
13:46:21 <sjanssen> nominolo: quickcheck isn't that smart
13:46:30 <roconnor> @scheck True == True
13:46:32 <lambdabot>   Completed 1 test(s) without failure.
13:46:42 <nominolo> @help scheck
13:46:42 <lambdabot> scheck <expr>
13:46:42 <lambdabot> You have SmallCheck and 3 seconds. Test something.
13:46:56 <SamB_XP_> nominolo: quickcheck knows nothing about the types involved, really...
13:48:40 <nominolo> SamB_XP_: hm, I thought it does, though implicitly
13:48:47 <nominolo> i.e. using the Gen instances
13:49:03 <nominolo> @instances Gen
13:49:04 <lambdabot> Couldn't find class `Gen'. Try @instances-importing
13:49:11 <nominolo> @instances Test.QuickCheckGen
13:49:11 <SamB_XP_> it only knows how to generate values, not the structure of the type
13:49:12 <lambdabot> Couldn't find class `Test.QuickCheckGen'. Try @instances-importing
13:49:31 <SamB_XP_> honestly, neither does SmallCheck
13:49:40 <SamB_XP_> it just uses a different strategy to generate test data
13:50:01 <roconnor> @instances Arbitary
13:50:02 <lambdabot> Couldn't find class `Arbitary'. Try @instances-importing
13:50:11 <roconnor> @instances Arbitrary
13:50:12 <lambdabot> Couldn't find class `Arbitrary'. Try @instances-importing
13:50:22 <roconnor> @instances Test.QuickCheck.Arbitrary
13:50:46 <nominolo> SamB_XP_: ok, maybe I should take a closer look at the QC paper ..
13:50:50 <allbery_b> @instances-importing Test.QuickCheck Arbitrary
13:50:52 <lambdabot> (), (a -> b), (a, b), Bool, Double, Float, Int, Integer, [a]
13:51:09 <SamB_XP_> nominolo: also take a gander at smallcheck
13:51:29 <roconnor> QuickCheck uses Arbitrary rather than Generators because they use a non-uniform distribution.
13:51:49 <nominolo> @scheck \x -> x == x
13:51:50 <lambdabot> Add a type signature
13:51:55 <nominolo> @scheck \x -> x == (x :: Int)
13:51:56 <lambdabot>   Completed 13 test(s) without failure.
13:52:21 <nominolo> @scheck \x -> x == (x :: Bool)
13:52:23 <lambdabot>   Completed 2 test(s) without failure.
13:52:53 <nominolo> @scheck \x -> x == (x :: (Bool,Bool))
13:52:54 <lambdabot>   Completed 4 test(s) without failure.
13:52:59 <nominolo> @scheck \x -> x == (x :: (Bool,Int))
13:53:01 <lambdabot>   Completed 26 test(s) without failure.
13:53:29 <sjanssen> only 26?
13:53:48 <sjanssen> @scheck \x y -> (x :: Bool, y :: Int) == (x, y)
13:53:50 <lambdabot>   Completed 26 test(s) without failure.
13:54:04 <roconnor> they don't call it small check for nothing
13:54:11 <nominolo> heh
13:54:28 <roconnor> It's great for checking tautlogies
13:54:28 <sjanssen> I don't think the range was always this small
13:54:44 <nominolo> @scheck \x -> x `elem` [1..100]
13:54:45 <lambdabot> Add a type signature
13:54:52 <sjanssen> @scheck \xs -> xs == (xs :: [Bool])
13:54:53 <lambdabot>   Completed 127 test(s) without failure.
13:54:53 <nominolo> @scheck \x -> (x :: Int) `elem` [1..100]
13:54:55 <lambdabot>   Failed test no. 1. Test values follow.: 0
13:54:57 <roconnor> @scheck \x y -> (((x <= y) <= x) <= x :: Bool)
13:54:59 <lambdabot>   Completed 4 test(s) without failure.
13:55:05 <nominolo> @scheck \x -> (x :: Int) `elem` [0..100]
13:55:06 <lambdabot>   Failed test no. 1. Test values follow.: -1
13:55:16 <nominolo> @scheck \x -> (x :: Int) `elem` [-100..100]
13:55:18 <lambdabot>   Completed 13 test(s) without failure.
13:55:21 <nominolo> lol
13:55:24 <Jaak> ow
13:55:38 <roconnor> @qcheck  \x -> (x :: Int) `elem` [-100..100]
13:55:39 <lambdabot> Maybe you meant: check scheck
13:55:42 <roconnor> @check  \x -> (x :: Int) `elem` [-100..100]
13:55:44 <lambdabot>  Falsifiable, after 271 tests: 107
13:55:57 <roconnor> oh boy
13:55:59 <roconnor> 271 tests
13:56:09 <sjanssen> 271 tests seems high
13:56:11 <roconnor> there are only 201 valid numbers.
13:56:15 <nominolo> @check \x -> (x :: Int) `elem` [-100..100]
13:56:17 <lambdabot>  Falsifiable, after 244 tests: 108
13:56:19 <roconnor> that's random for you
13:56:32 <roconnor> @check  \x -> (x :: Int) `elem` [minbound..maxbound]
13:56:33 <lambdabot>   Not in scope: `maxbound'
13:56:40 <roconnor> @check  \x -> (x :: Int) `elem` [minBound..maxBound]
13:56:46 <lambdabot> Plugin `check' failed with: IRCRaised Data.ByteString.last: empty ByteString
13:56:56 <roconnor> ?
13:56:58 <nominolo> ouch
13:57:06 <roconnor> oh
13:57:09 <roconnor> the list is too big
13:57:15 <roconnor> I guess that is fair
13:57:28 <nominolo> hey, just a few GB ...
13:57:34 <roconnor> @check  \x -> (x :: Word8) `elem` [minBound..maxBound]
13:57:36 <lambdabot>  OK, passed 500 tests.
13:57:42 <roconnor> @check  \x -> (x :: Int8) `elem` [minBound..maxBound]
13:57:43 <lambdabot>   add an instance declaration for (Arbitrary Int8)     In the expression: let...
13:57:50 <roconnor> boo
13:58:05 <nominolo> > 4 * (maxBound :: Int)
13:58:07 <lambdabot>  -4
13:58:18 <nominolo> > 4 * fromIntegral (maxBound :: Int) :: Integer
13:58:19 <lambdabot>  8589934588
13:58:27 <xerox> :t foldr'
13:58:30 <lambdabot> Not in scope: `foldr''
13:58:39 <roconnor> there is no foldr'
13:59:55 <nominolo> > 2 ** 30
13:59:56 <lambdabot>  1.073741824e9
14:00:00 <xerox> ahm.
14:00:10 <nominolo> > 4 * fromIntegral (maxBound :: Int) :: Integer / (2 ** 30)
14:00:10 <lambdabot>  Parse error
14:00:26 <nominolo> > (4 * fromIntegral (maxBound :: Int) :: Integer) / (2 ** 30)
14:00:27 <lambdabot>   add an instance declaration for (Floating Integer)
14:00:29 <roconnor> > 2 ^ 30
14:00:31 <lambdabot>  1073741824
14:00:35 <nominolo> > (4 * fromIntegral (maxBound :: Int) :: Integer) `div` (2 ** 30)
14:00:36 <lambdabot>   add an instance declaration for (Floating Integer)
14:00:44 <nominolo> @slap lambdabot
14:00:44 <lambdabot> why on earth would I slap lambdabot
14:00:50 <nominolo> @slap lambdabot
14:00:50 <lambdabot> why on earth would I slap lambdabot
14:00:54 <roconnor> > (4 * fromIntegral (maxBound :: Int) :: Integer) `div` (2 ^ 30)
14:00:54 <nominolo> @slap -f lambdabot
14:00:55 * lambdabot smacks -f lambdabot about with a large trout
14:00:56 <lambdabot>  7
14:01:22 <roconnor> @type (^)
14:01:25 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
14:01:29 <nominolo> ah, i missed the type difference
14:01:29 <roconnor> @type (^^)
14:01:32 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
14:01:35 <roconnor> @type (**)
14:01:37 <lambdabot> forall a. (Floating a) => a -> a -> a
14:01:54 <LordBrain> various exponent functions?
14:02:13 <roconnor> 3^3
14:02:17 <roconnor> > 3 ^ 3
14:02:19 <lambdabot>  27
14:02:22 <roconnor> > 3 ^^ 3
14:02:24 <lambdabot>  27.0
14:02:28 <roconnor> > 3 ** 3
14:02:30 <lambdabot>  27.0
14:03:02 <nominolo> :t 3 ^^ 4
14:03:04 <lambdabot> forall t. (Fractional t) => t
14:03:11 <LordBrain> > 2 ^^ (1/2)
14:03:13 <lambdabot>  Add a type signature
14:03:16 <nominolo> @instances Fractional
14:03:17 <lambdabot> Double, Float
14:03:27 <LordBrain> > 2 ^^ .5
14:03:27 <lambdabot>  Parse error
14:03:32 <LordBrain> > 2 ^^ 0.5
14:03:33 <roconnor> Where is Rational?
14:03:33 <lambdabot>  Add a type signature
14:03:40 <LordBrain> > 2 ^^ 0.5::Float
14:03:42 <lambdabot>  Add a type signature
14:03:57 <LordBrain> > 2 ^^ (0.5::Float)
14:03:58 <lambdabot>   add an instance declaration for (Integral Float)
14:03:58 <lambdabot>     In the expression: 2 ^...
14:04:18 <LordBrain> > (0.5::Float) ^^ 2
14:04:20 <lambdabot>  0.25
14:04:37 <LordBrain> dislexic read of the type signature
14:10:18 <chessguy> hi haskellers
14:10:32 <Daveman> chessguy :)
14:14:51 <monochrom> muskellers
14:15:48 <procyon112> hey chessguy!
14:15:55 <procyon112> know anything about pi calculus?
14:17:12 <chessguy> sorry, was on the phone
14:17:17 <chessguy> no, i don't think i do
14:17:34 <chessguy> other than that it's some kind of alternative to lambda
14:17:49 <procyon112> I'm just wondering if pi calculus can be a generalization of Neural Networks.
14:18:08 <chessguy> hmm, interesting
14:18:34 <chessguy> you shoul /join #ai
14:19:04 <procyon112> And if so, perhaps a strongly typed pi calculus can be used to derive Strongly Typed recurrent ANNs
14:19:19 <procyon112> Already in #AI :)
14:19:42 <SamB_XP_> isn't pi calculus used for functional nets?
14:19:48 <chessguy> you haven't given up on strongly-typed GP in haskell, have you?
14:20:05 <DRMacIver> GP?
14:20:16 <procyon112> no.. I'm thinking of a possible experiment using my STGP
14:20:16 <chessguy> genetic programming
14:20:29 <DRMacIver> ah, right.
14:25:35 <chessguy> so whast would the experiment be?
14:25:38 <chessguy> *what
14:27:31 <procyon112> If I can encode a higher order typing on pi calculus channels, and encode the pi calculus combinitorially (making it variable free) I might be able to evolve neural nets that pass around higher order functions and such instead of just reals or bools.. but do it in a type safe fashion, so if a neuron is listening to a channel that ensures [Int->a->a], then he can safely apply anything recieved on that channel and be assured that it is
14:28:03 <chessguy> you got cut off with "...be assured that i"
14:28:14 <procyon112> anything recieved on that channel and be assured that it is type safe.
14:28:23 <chessguy> ah
14:29:44 <procyon112> Basically, I can evolve a swarm of higher order processes that intercommunicate, but constrain the search space only to those swarms that make type sense.
14:30:19 <chessguy> interesting
14:31:41 <nominolo> functional nets? is that the stuff based on join-calculus?
14:32:42 <nominolo> ah, yep
14:32:47 <nominolo> oh, Odersky
14:34:15 <procyon112> I'm not sure if I'm barking up the wrong tree, or just in uncharted territory with this Idea.
14:36:19 <nominolo> procyon112: maybe you could ask on the TYPES mailing list
14:36:23 <nominolo> or check the archives
14:36:47 <chessguy> types mailing list? where
14:37:34 <nominolo> @go "types-list@lists.seas.upenn.edu"
14:37:36 <lambdabot> http://lists.seas.upenn.edu/mailman/listinfo/types-list
14:37:37 <lambdabot> Title: The TYPES Forum
14:37:47 <earthy> that's the on
14:37:48 <earthy> +e
14:37:53 <chessguy> nice
14:37:55 <earthy> my browser is slow
14:38:01 <nominolo> it's pretty low-volume, but has a long history
14:38:03 <earthy> yeah, it's pretty nice
14:38:14 <earthy> and has a lot of knowledgeable people
14:38:29 <nominolo> note, that the old archives are somewhere else
14:39:03 <nominolo> it's linked on that site
14:42:29 <chessguy> nominolo: thanks, i signed up
15:00:51 <procyon112> The types forum isn't really appropriate.  I'm pretty sure asking about NN/pi calculus questions would be modded out (I've dealt with that list before with much more topical posts.. they are very strict)
15:01:55 <procyon112> If it were a question on how to type the pi calculus, sure...
15:03:03 <nominolo> oh, ok.  then LtU, maybe.  otherwise, no idea
15:04:39 <plediii> when I try to import FiniteMap in ghc, I get an error that it is hidden.  How do I use it?
15:05:25 <chessguy_away> you installed it yourself?
15:05:41 <monochrom> Could you switch to Data.Map instead?  FiniteMap may be deprecated and phasing out.
15:05:49 <xerox> plediii, you ought to import Data.Map
15:06:04 <xerox> .oO(turn off that stereo!)
15:06:33 <monochrom> doesn't hurt to get a "second opinion"
15:06:33 <chessguy_away> ?
15:07:07 <xerox> monochrom, provided it's not just echo :)
15:07:37 <nominolo> @quote stereo
15:07:37 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
15:07:39 <chessguy_away> oh, that kind of stereo
15:07:45 * chessguy_away is a little slow today
15:07:59 <monochrom> echo is good.  if you ask "1+1=?", you expect a million echoes of "2", demonstrating the unanimity of mathematics.
15:08:25 <nominolo> chessguy_: i thought of that physical thing too, at first
15:08:35 <xerox> agreed.
15:09:51 <plediii> I'm trying to use Data.Map, but it doesn't seem to have the same functions as my tutorial (e.g., listToFM).  How do I get a list of the functions is Data.Map?
15:10:08 <xerox> ?docs Data.Map
15:10:09 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
15:11:43 <xerox> which tutorial are you reading?
15:11:51 <chessguy_away> @type fromList
15:11:53 <lambdabot> Not in scope: `fromList'
15:12:04 <chessguy_away> @type Data.Map.fromList
15:12:06 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
15:12:08 <Igloo> SyntaxNinja: What's the rationale for the Cabal poshooks returning an ExitCode?
15:12:22 <plediii> "yet another haskell tutorial" by Hal Daume III
15:12:50 <qwr> @hoogle listToFM
15:12:51 <lambdabot> Data.FiniteMap.listToFM :: Ord key => [(key, elt)] -> FiniteMap key elt
15:12:51 <lambdabot> Data.FiniteMap.addListToFM :: Ord key => FiniteMap key elt -> [(key, elt)] -> FiniteMap key elt
15:12:51 <lambdabot> Data.FiniteMap.addListToFM_C :: Ord key => (elt -> elt -> elt) -> FiniteMap key elt -> [(key, elt)] -> FiniteMap key elt
15:13:22 <plediii> thanks for the link xerox
15:14:15 <xerox> plediii, you can ask lambdabot for the link to the module's documentation with ?docs <ModuleName>
15:14:32 <xerox> ?src Data.Map will give you the link to the source file
15:14:33 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
15:14:44 <xerox> ?src Data.Map
15:14:45 <lambdabot> Source not found. My pet ferret can type better than you!
15:14:55 <chessguy_away> no, src will give the actual code, if LB knows it
15:14:56 <xerox> at least it should
15:14:59 <chessguy_away> ?src (!!)
15:15:00 <lambdabot> xs     !! n | n < 0 = undefined
15:15:00 <lambdabot> []     !! _         = undefined
15:15:00 <lambdabot> (x:_)  !! 0         = x
15:15:00 <lambdabot> (_:xs) !! n         = xs !! (n-1)
15:15:01 <xerox> ah!
15:15:03 <Saizan> ?source Data.Map
15:15:03 <lambdabot> http://darcs.haskell.org/packages/base/Data/Map.hs
15:15:06 <xerox> ?source Data.Map
15:15:07 <lambdabot> http://darcs.haskell.org/packages/base/Data/Map.hs
15:15:13 <xerox> aka ?fptools
15:15:17 <Saizan> ?source GHC.Base.Show
15:15:18 <lambdabot> GHC.Base.Show not available
15:15:29 <chessguy_away> @source Show
15:15:30 <lambdabot> Show not available
15:15:33 <chessguy_away> :i Show
15:15:41 <chessguy_away> @index Show
15:15:42 <lambdabot> Text.Show, Prelude
15:15:57 <chessguy_away> hi sorear
15:15:59 <plediii> xerox: I'll keep those commands in mind
15:16:25 <chessguy> @source Prelude
15:16:25 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
15:16:44 <procyon112> chessguy: I think I came off as a crackpot in #ai. Haskell has broken me and I am not content to think that a neuron described as "neuron inputs = atan $ foldr (+) 0 inputs" ceases to be a neuron if described as "neuron f g k ins = f $ foldr g k inputs"
15:16:57 <xerox> they're handy, there's also @index <name> which will tell you in which modules the function <name> is defined, and ?hoogle <type> which searches for functions given the type
15:17:11 <chessguy> procyon112: don't worry, there are plenty of crackpots in #ai, and you're not one of them
15:17:16 <procyon112> hehe
15:17:17 <merus> Yay crackpots!
15:17:25 <procyon112> Damn.  I can keep trying though.
15:17:29 <chessguy> ?src sum
15:17:30 <lambdabot> sum = foldl (+) 0
15:17:30 <procyon112> Maybe someday!
15:17:32 <chessguy> by the way :)
15:19:30 <sorear> hi chessguy!
15:21:29 <chessguy> ndm++ nice QC blog today
15:22:18 <ndm> thanks chessguy
15:22:30 <ndm> also nice quickcheck for making it all possible :)
15:25:14 <sorear> ndm: are you "218"?  (is it a deliberate pseudonym?)
15:29:07 <nominolo> @unpl (((>1).).gcd)
15:29:07 <lambdabot> (\ e h -> (gcd e h) > 1)
15:29:27 <nominolo> @src nubBy
15:29:27 <lambdabot> nubBy eq []             =  []
15:29:28 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
15:30:28 <ndm> sorear: nope
15:30:40 <ndm> who is 218?
15:31:11 <sorear> nominolo: gcd never returns less than 1, so (>1) is just a shorter way of writing (/=1).
15:31:26 <procyon112> chessguy: Here's my premise... Strongly typed GP *severely* constrains search space... to the point that in many of the combinator STGP experiments I've seen exhaustive search actually outperforms GP because the search space is too small for GP to be adventageous.
15:31:48 <sorear> nominolo: also, a number has a gcd of ==1 with a prime iff it is divisible by the prime (number theoretic result)
15:31:57 <sorear> ndm: http://haskell.org/haskellwiki/?title=Libraries_and_tools/Web_programming&curid=1628&diff=12559&oldid=12237
15:32:00 <lambdabot> Title: Libraries and tools/Web programming - HaskellWiki, http://tinyurl.com/2eyz9w
15:32:01 <nominolo> sorear: yep. i know
15:32:19 <nominolo> sorear: i was just decoding this ((f.).) stuff
15:32:33 <ndm> sorear, sensible guess - but no, i have never heard of 218
15:32:52 <ndm> > map ord "218"
15:32:52 <fasta> procyon112: what makes you so sure that you have a method that generates less bogus programs? I am not hearing anything that does that now.
15:32:53 <lambdabot>  [50,49,56]
15:32:56 <procyon112> chessguy: This leads me to believe that evolutionary algorithms may be able to find good strongly typed training algorithms for complex neural networks, even in cases where the training algorithms are very difficult for us to spot.
15:33:46 <hpaste>  dmwit annotated "problem14 finishes in 30 secs, problem14' eats 1.3Gb of ram in 30 minutes" with "for ADEpt" at http://hpaste.org/1430#a1
15:34:36 <procyon112> fasta: The vast majority of programs evolved are useless.. but if they are strongly typed, then they are at least correct.
15:35:33 <fasta> procyon112: I am well aware of that, but you haven't said anything that's different from how that's done today.
15:35:56 <nominolo> @src gcd
15:35:56 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
15:35:57 <lambdabot> gcd x y = gcd' (abs x) (abs y)
15:35:57 <lambdabot>    where gcd' a 0  =  a
15:35:57 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
15:36:34 <dmwit> Is rem faster than mod or something?
15:36:55 <nominolo> dmwit: no, rounding is different, iirc
15:37:09 <dmwit> nominolo: Only for negative numbers, though, right?
15:37:13 <dmwit> ?help quickcheck
15:37:14 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:37:15 <nominolo> > (-3) `mod` 5
15:37:15 <procyon112> fasta: I don't have a method that generates more "correct" programs.. I'm just not believing that certain problem spaces are too complex to explore that have previously been discounted.
15:37:16 <lambdabot>  2
15:37:20 <nominolo> > (-3) `rem` 5
15:37:21 <lambdabot>  -3
15:37:31 <dmwit> nominolo: But in gcd', you don't get any negative numbers...
15:37:38 <dmwit> ?help qc
15:37:38 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:37:46 <fasta> procyon112: ok, fair enough. You are entitled to your own believes :)
15:37:56 <ADEpt> dmwit: thnx, will look into that
15:38:08 <nominolo> dmwit: yes, would make no difference there i guess
15:38:43 <nominolo> @src rem
15:38:43 <lambdabot> Source not found. That's something I cannot allow to happen.
15:38:49 <nominolo> @src mod
15:38:50 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
15:39:00 <sorear> @src Integral
15:39:01 <lambdabot> class  (Real a, Enum a) => Integral a  where
15:39:01 <lambdabot>     quot, rem, div, mod :: a -> a -> a
15:39:01 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
15:39:01 <lambdabot>     toInteger           :: a -> Integer
15:39:26 <nominolo> ?help @src
15:39:27 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:39:27 <procyon112> fasta: for instance, the evolving of training algorithms for recurrent NN's that pass around higher order functions instead of reals, for instance.  recurrent dataflow networks.
15:39:28 <sorear> dmwit: that impl of gcd is straight from the Prelude, and hasn't been touched in oh 10+ years
15:40:01 <dmwit> Okay.  I was just curious.
15:40:07 <sorear> dmwit: fwiw, `rem` is a single machin instruction on i386 (IDIV), `mod` needs a conditional branch afterward to fix up the rounding
15:40:15 <fasta> procyon112: a neural network that passes around higher order functions is not called a neural net anymore, I guess.
15:40:31 <dmwit> sorear: Ah, okay, that may be why then.
15:40:42 <ndm> dmwit: i checked in a patch to derive today which should make it build out of teh box on GHC 6.4.2 - if it doesn't then let me know
15:42:09 <procyon112> fasta: yeah.. but it's a higher order abstraction... instead of "neuron inps = atan $ foldr (+) 0 inps" it becomes "neuron f g k inps = f $ foldr g k inps"... It's the same thing really, functionally.
15:45:01 <procyon112> fasta: And it might be a simpler problem for GP to find solutions to.  Imagine that NN passing reals around happens to be a complex instance, and passing monads around is a simpler problem.. GP may actually have an easier time finding good NN algorithms if free to explore the higher order space.
15:45:56 <fasta> procyon112: When can we expect to read a coherent article on this matter?
15:46:01 <sorear> ndm: now testing on 6.4.2
15:46:01 <dmwit> ndm: Now I get way more compiler errors.
15:46:13 <sorear> failed: Setup.hs: cannot satisfy dependency filepath-any
15:46:17 <monochrom> I knew rem was faster than mod.
15:46:18 <procyon112> fasta: I'm not saying it is.. I'm just saying I want to play around with the ideas ;)
15:46:38 <ndm> sorear, install filepath from haskell.org
15:46:44 <sorear> @hackage filepath
15:46:45 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/filepath
15:46:45 <ndm> dmwit, hpaste?
15:46:56 <ndm> sorear, no luck - wait til tomorrow
15:47:23 <hpaste>  dmwit pasted "Derive build on 6.4.1" at http://hpaste.org/1434
15:47:26 <procyon112> fasta: When I get the Haskell GP lib up to speed first, then start playing with building a NN lib... it will be a while before article time :)
15:47:48 <fasta> procyon112: Genetic Programming in Haskell will work about as fast as in Lisp. It doesn't matter how you call it. It will still go slow (unless you have a few million machines lying around)
15:48:14 <Igloo> ndm: These filepath patches are good for 6.6.1, right?
15:48:59 <fasta> procyon112: finding programs to do anything useful is difficult because the search space is gigantic. You need to know what you are looking for and preferably: you should be looking out to lots of things at the same time.
15:49:06 <ndm> Igloo, yep, all of them - just sent another one (no code changes, testing code only)
15:49:10 <procyon112> fasta: Yeah, probably.. but the type inference algorithms are a hell of a alot easier to write in haskell.
15:49:23 <sorear> Compiling System.FilePath.Windows ( ./System/FilePath/Windows.hs, dist/build/System/FilePath/Windows.o )  ... why?
15:49:26 <fasta> procyon112: I don't agree with that assertion.
15:49:36 <sorear> I'm not on windows, why is it building?
15:49:38 <ndm> sorear, in case you want to use Windows FilePath's on your Linux system
15:49:49 <sorear> how do I do that?
15:49:54 <ndm> sorear, System.FilePath.Posix and System.FilePath.Windows are both 100% portable
15:50:01 <ndm> import the appropriate one and you can do the magic
15:50:10 <ndm> only System.FilePath chooses a platform specific one
15:50:18 <sorear> I thought they were only for local name use :)
15:50:34 <ndm> nope, you can play with both types of filepath, regardless of OS
15:51:04 <ndm> dmwit, GHC 6.4.1 you say... - just checking (I checked 6.4.2 i think)
15:51:08 <sorear> ndm: http://haskell.org/ghc/docs/6.4.1/html/libraries/base/Data-Char.html
15:51:10 <lambdabot> http://tinyurl.com/yvglmh
15:51:55 <sorear> I suppose (`elem` "listOfCharactersMentionedInTheReport") is somehow unsatisfactory?
15:52:14 <sorear> anyway, I get dmwit's errors with 6.4.2
15:52:15 <dmwit> ndm: Yes, 6.4.1
15:52:21 <ndm> grr, my GHCi 6.4.2 definately showed them with :b and :i - perhaps Malcolm upgraded the library or something...
15:52:28 <ndm> its the shared copy of GHC on teh network
15:52:40 <ndm> sorear, no, `elem` chars is perfectly fine by me
15:52:51 <procyon112> fasta: at least there are more examples of type inferrence algorithms in haskell than any language I've seen.  I'm well aware of the search space though.  I may find working algorithms or I may not. At the least, I've taught myself Haskell, learned some new things and developed some good Haskell libs for others to play with.
15:53:40 <sorear> ndm: hmm.  the Report allows unicode symbols.
15:53:58 <sorear> ascSymbol -> ! | # | $ | % | & | * | + | . | / | < | = | > | ? | @ | \ | ^ | | | - | ~
15:54:02 <sorear> asciiwise
15:54:08 <ndm> sorear, we only use it to promote from a prefix application to an operator one - so it doesn't matter if we miss some - its still safe
15:54:41 <sorear> ndm: huh? it will make unparsible code!
15:55:38 <ndm> sorear, if isOperator is conservative, then we always win surely?
15:55:41 <fasta> procyon112: I don't think you need a type inferencer
15:55:51 <ndm> or are you refering to inside the ppr thing?
15:57:03 <procyon112> fasta: How so?  (I don't need a full inferrer, but I do need unification and type variables to construct well typed trees)
15:57:31 <Dybber> (HAppS Question) In the example here: http://www.haskell.org/haskellwiki/HAppS_tutorial#Methods_and_paths - will it ever get to the 2 error handlers (notFound & notImplemented)?
15:57:34 <lambdabot> Title: HAppS tutorial - HaskellWiki, http://tinyurl.com/2d9fra
15:58:19 <sorear> ndm: sorry, I thought this was in the ppr :)
15:58:29 <sorear> never mind then.
15:58:40 <Dybber> lambdabot, is rather nice, is it open source? :)
15:58:47 <ndm> hmm, how does the ppr figure out what is an operator then?
15:58:48 <sorear> @version
15:58:49 <lambdabot> lambdabot 4p517, GHC 6.6 (OpenBSD i386)
15:58:49 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
15:59:02 <procyon112> fasta: Unless I use Koza's premise of "closure".. that all primitives return the same type... but Koza GP cannot be turing complete, or even primitively recursive because of that principle.  Hence he uses overgeneral types which blow up his search space.
15:59:06 <sorear> ndm: It uses isAlpha x || x == '_'
15:59:33 <Dybber> thanks sorear :)
15:59:33 <ndm> sorear, any reason Helper can't use the same?
15:59:56 <sorear> ndm: no, thanks for bringing my attn to this
16:00:30 <ndm> sorear, cool - will patch that now then
16:01:07 <procyon112> fasta: Additionally.. Koza GP cannot have variable abstraction.. which takes away alot of power from the trees.  STGP can introduce variable abstraction through SK combinators.
16:01:29 <fasta> procyon112: Ok, what I had in mind essentially is the same as what you said - no full type inferencer.
16:02:13 <fasta> procyon112: what is STGP?
16:02:24 <sorear> strongly typed genetic programming?
16:02:30 <fasta> sorear: of course
16:02:31 <procyon112> yes
16:03:12 <ndm> dmwit: have another go, just pushed a new 6.4 patch
16:03:16 <fasta> procyon112: I know that the people that are building Novamente take a similar approach.
16:03:31 <chessguy> what's novamente?
16:03:58 <ndm> anyone used HOOD, or still have an active working installation?
16:03:59 <fasta> procyon112: but they estimated that they need at least 40,000 AMD64 CPUs a year ago or something like that to have something that worked.
16:04:31 <ndm> anyone possibly think they might ever want an Observable instance?
16:04:32 <fasta> chessguy: AI architecture based on the ideas of WebMind
16:04:45 <fasta> chessguy: $20M went into it, IIRC
16:04:59 <procyon112> fasta: It very well may...  but if they are looking for a single training algorithm, then they only need to find it once :)
16:05:01 <chessguy> looks to me like they're doing General AI, not specific-purpose AI
16:05:07 <dmead> ndm that'd be neat
16:05:11 <dmwit> ndm: Great success!
16:05:16 <fasta> chessguy: right
16:05:25 <chessguy> that's significantly harder
16:05:35 <sorear> ndm: is there any technical / labor reason we can't have guess understand fields?  it looks feasable to me
16:05:40 <procyon112> significantly is an understatement ;)
16:05:42 <fasta> procyon112: the training algorithm for neural nets cannot really be made any better.
16:06:01 <dmwit> ndm++ for being helpful a lot
16:06:15 <ndm> sorear, i'm thinking it through - the hard bit would be a data structure that has both field constructors and non-field constructors
16:06:28 <fasta> procyon112: s/cannot really/cannot
16:07:00 <ndm> sorear, the biggest issue is i have no idea what the canonical data structure would then look like, in order for it to have the necessary variation
16:07:08 <fasta> procyon112: the only advantage is that when you evolve your programs in a symbolic way, you might get something out that's understandable by a human.
16:07:16 <chessguy> fasta:  do you have any evidence of that?
16:07:16 <procyon112> fasta: The training algorithm for feedforward neural networks of real and boolean types cannot be made better.  There are few known training algorithms for recurrent and spiking networks, and the ones we have suck, and no work at all that I am aware of for higher order NN.
16:08:02 <procyon112> fasta: Most recurrent and spiking nets are evolved with GP rather than trained.
16:09:41 <procyon112> Spiking nets in particular are proven to have a higher density of data storage capacity than feed-forward.. but we can't train them well yet.
16:09:43 <fasta> procyon112: but can't feedforward neural networks represent any input-output mapping?
16:10:28 <sorear> no, there are only aleph-1 feedforward networks networks, but aleph-2 input-output mappings.
16:11:08 <fasta> sorear: but there are only aleph-1 algorithms
16:11:08 <sorear> aren't feedforward networks also restrained to be continuous?
16:11:15 <ndm> hmm, you could set it up so records were in the environment, with Record Int > Ctor Int > Field Int - and allow Ctor to be both a child of Env and Record
16:11:42 <ndm> but it might get tricky - i'd like to have formalised environments and its suborderings before making that section any more complex
16:12:41 <procyon112> fasta: in many cases it becomes computationally intractable.  Turing Machines, for instance, are computationally complete, but that doesn't make them computationally practical.
16:13:53 <procyon112> fasta: recurrent networks are demonstrably more efficient with fewer neurons than feedforward networks, especially when dealing with temporal problems.
16:14:31 <LordBrain> i adapted a hackage package Network.Pcap to work with winpcap.
16:15:04 <dmead> hey channel
16:15:04 <fasta> sorear: why would there be aleph-1 feedforward neural networks?
16:15:12 <dmead> wheres the timestamp stuff
16:15:13 <dmead> in the stdlib
16:15:25 <fasta> procyon112: that sounds a bit counter-intuitive
16:15:26 <chessguy> ?hoogle timestamp
16:15:27 <lambdabot> No matches found
16:15:31 <chessguy> ?hoogle time
16:15:32 <lambdabot> System.Time :: module
16:15:33 <lambdabot> Time :: module
16:15:33 <lambdabot> System.Locale.time12Fmt :: TimeLocale -> String
16:15:35 <dmead> ah
16:15:36 <dmead> thanks
16:16:24 <fasta> procyon112: if feedforward networks can represent every algorithm and the algorithm that optimizes it is optimal, then that shouldn't be true.
16:18:42 <sorear> fasta: ffnns are isocardinal to [real], [real] <= nat -> real <= nat -> nat -> bool <= (nat x nat) -> bool <= nat -> bool <= real
16:21:10 <ndm> ouch! have people looked at how complex Show/Read are?
16:21:29 <procyon112> fasta: Many patterns are dependant on what happened previously.  In a recurrent network, the network can remember prior inputs, and encode mappings as functions of time.  In a feedforward network, since there is no way for the network to remember prior inputs after training, it needs to encode the entire function as value mappings.  For trivial functions of time, this is difficult for feedforward networks, and impossible for most fun
16:22:04 <fasta> sorear: I know about cardinal numbers, but I am not exactly understanding your notation. You appear to be using function spaces and probably there sizes of those?
16:22:09 <Igloo> ndm: IWW?
16:22:22 <fantasma> ?hoogle [a] -> [(a),(a)]
16:22:23 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
16:22:40 <fantasma> ?hoogle Int -> [a] -> [(a),(a)]
16:22:41 <lambdabot> No matches, try a more general search
16:22:47 <dmwit> splitAt
16:23:01 <fantasma> splitAt does ([a],[a])
16:23:05 <fasta> procyon112: that's an intuitive explanation. Can you give a formal argument to why my argument is flawed?
16:23:09 <fantasma> I want tupples inside a list
16:23:21 <ndm> Igloo, just quite hard - i don't suppose you know of a description of what the algorithm should look like?
16:23:22 <sorear> ndm: they are soo easy!  (ps, I was planning on implementing those)
16:23:28 <sorear> I do!
16:23:29 <procyon112> fasta: the feedforward training algorithm is optimal *for the feedforward data representation*.  The feedforward data representation is definitely not optimal.
16:23:40 <ndm> sorear, in that case they are all yours :-)
16:23:40 <sorear> ndm: http://haskell.org/onlinereport/derived.html
16:23:42 <lambdabot> Title: The Haskell 98 Report: Derived Instances
16:23:51 <Igloo> ndm: Do you mean the showsPrec stuff?
16:24:09 <EvilTerran> fantasma, what do you want it to do?
16:24:11 <sorear> ndm: we need fixity info in the CtorDef to properly derive Show/Read tho
16:24:13 <fasta> procyon112: ok, I suspected that would be the answer. :)
16:24:43 <procyon112> fasta: There's a proof out there of spiking networks being a higher density encoding... not sure where it is right now.  I think there is one for recurrents also... again, no idea where :)
16:24:48 <sorear> ndm: you *really* need helper functions for read.  fortunately, they are in the prelude ;)
16:24:48 <Igloo> ndm: Oh, you're trying to write deriving Show/Read for yhc?
16:25:03 <ndm> Igloo - no, for derive
16:25:13 <fasta> procyon112: I haven't heard of those before this conversation. That's a nice result.
16:25:37 <ndm> sorear, can we get the fixity stuff out of the AST, or do we have to directly ask template haskell?
16:25:39 <fantasma> EvilTerran: ultimately, I want to make a list of tupples such that when given a list of numbers, [(a,b)] --b is the number of times a occurs in the list
16:25:58 <Igloo> ndm: Have you tried the description in http://haskell.org/onlinereport/derived.html ?
16:25:59 <lambdabot> Title: The Haskell 98 Report: Derived Instances
16:26:12 <ndm> Igloo, no - i missed that first time through
16:26:49 <sorear> ndm: we can get it out of the AST.  but what of SYB?
16:27:03 <sorear> oh, wait, ISTR someone killed CtorDef.
16:27:25 <sorear> Igloo: in fact I pointed him to it :)
16:27:38 <Igloo> Oh, so you did  :-)
16:27:56 <ndm> sorear, yes, we killed SYB - and i suggest we leave it dead until we have a reason to bring it back to life
16:28:13 <ndm> sorear, CtorDef = Con from SYB with a type =
16:28:36 <EvilTerran> fantasma, I don't think there's a library function for that...
16:28:58 <fantasma> EvilTerran: I know
16:29:12 <sorear> map (head &&& length) . group . sort -- is the idiomatic way to do it
16:29:55 <EvilTerran> well, sorear beat me to the punch. i was trying to think of a pointsfree using sort...
16:30:43 * EvilTerran had forgotten about "group"
16:30:55 * fantasma has just learned about group
16:31:32 <fantasma> :t &&&
16:31:36 <lambdabot> parse error on input `&&&'
16:31:39 <EvilTerran> :t (&&&)
16:31:40 <thedward> @type (&&&)
16:31:43 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
16:31:44 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
16:32:22 <EvilTerran> (f &&& g) x = (f x, g x) -- approximately
16:33:10 <EvilTerran> > (head &&& length) "foobly boobly"
16:33:11 <lambdabot>  ('f',13)
16:33:12 <thedward> > unwords $ map  (((arr (toUpper . head)) &&& tail) >>> arr (uncurry (:))) (words "hello, world")
16:33:14 <lambdabot>  "Hello, World"
16:33:35 <sorear> yeah, wel I used &&& too.  surely that's worth points :)
16:33:35 <sorear> the type of (&&&) is as ugly as ap, btw...
16:33:35 <sorear> :t (&&&)
16:33:38 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
16:33:39 <sorear> oh, so I'm lagging.
16:33:41 <sorear> I wondered why fantasma didn't immediately retry with parens ;)
16:33:47 <sorear> EvilTerran:
16:33:49 <sorear> @src (&&&)
16:33:50 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
16:33:57 <sorear> @src (->) &&&
16:33:57 <lambdabot> Source not found. Where did you learn to type?
16:34:05 <sorear> @src (->) (&&&)
16:34:05 <lambdabot> Source not found. I feel much better now.
16:35:04 <TomMD> @slap lambdabot
16:35:05 * lambdabot beats up lambdabot
16:35:19 <TomMD> Darn bot, insulting people when it can't find source.
16:37:11 <Igloo> ndm: What does "makeRelative x y" do in English?
16:37:27 <EvilTerran> @type (&&&) :: (a->b) -> (a->c) -> a -> (b,c)
16:37:30 <lambdabot> (a->b) -> (a->c) -> a -> (b,c) :: forall a b c. (a -> b) -> (a -> c) -> a -> (b, c)
16:38:24 <fantasma> @index (&&&)
16:38:24 <lambdabot> Control.Arrow
16:38:38 <ndm> Igloo, you are going to display the path "y" to the user, but the user knows they are operating relative to x - show the cleanest possible path that the user would like to see
16:39:04 <ndm> Igloo - undo the canoncialisePath in some sense
16:39:14 <LordBrain> uh
16:39:29 <LordBrain> why would visual haskell say that it can't find Control.Monad.State ?
16:39:35 <Igloo> ndm: OK, so the assumption is that x is the working directory, and y is reachable from x?
16:39:38 <ddarius> @src (&&&) -- the definition of an adjunct via the unit and functor's mapping on arrows.
16:39:38 <lambdabot> Source not found. That's something I cannot allow to happen.
16:39:49 <ddarius> @src (&&&)
16:39:50 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
16:39:51 <ddarius> Bah.
16:39:58 <Igloo> In fact, only the second half of that is important
16:40:25 <ddarius> Isn't y always reachable from x?
16:40:31 <LordBrain> anyone have visual haskell experience?
16:41:09 <Igloo> ddarius: If y is "sh" then only if x === "/bin"
16:41:25 <ndm> Igloo, x is usually the working directory (hence makeRelative... which is currentDirectory based)
16:41:30 <sorear> LordBrain: maybe you didn't install mtl?
16:41:42 <LordBrain> it is a member of package mtl-1.0, which is hidden
16:41:46 <ndm> makeRelative "/bin" "/bin/sh" = "sh"
16:41:51 <LordBrain> thats the rest of the message
16:42:02 <sorear> LordBrain: you MUST declare a dependency on mtl
16:42:07 <LordBrain> oh
16:42:38 <sorear> LordBrain: don't you just hate it when code depends on libs without declaring it?  ghc has a feature to prevent this, which is used by cabal and vh
16:43:02 <LordBrain> how do i make that decration?
16:43:18 <LordBrain> declaration
16:43:22 <sorear> there should be some kind of project preferences thing.
16:43:32 <sorear> <- has not used ms dev tools in >3 yrs
16:43:32 * dibblego decorates #haskell
16:44:30 <sorear> @users
16:44:31 <lambdabot> Maximum users seen in #haskell: 336, currently: 297 (88.4%), active: 37 (12.5%)
16:44:32 <sorear> @uptime
16:44:33 <lambdabot> uptime: 1d 21h 18m 18s, longest uptime: 5d 3h 40m 45s
16:44:51 <ndm> LordBrain - why do you want to use VH? I used it once, and found it slow and unreliable - and i love visual studio
16:45:02 <LordBrain> well
16:45:08 <LordBrain> i do not know now
16:45:30 <LordBrain> really i just needed ghc for windows
16:45:39 <LordBrain> but i am at work,and we use VS
16:45:44 <LordBrain> so i figured i'd try it
16:46:01 <LordBrain> and then once i had it installed, i figured why install another ghc
16:46:29 <LordBrain> so i've been using the ghc that came with VS
16:46:35 <ndm> i recommend an uninstall and use a normal GHC
16:46:36 <LordBrain> then i installed a package from cabal
16:46:42 <ndm> since thats exactly what i did
16:46:53 <LordBrain> well
16:47:01 <ndm> the VS GHC is a non-stable release, its not 6.4 or 6.6 or anything else
16:47:22 <sorear> not even 6.5.xxxxx?
16:48:24 <LordBrain> by this time, i've already read thru and done tutorials on building dlls and all in vs
16:49:02 <ndm> sorear, it is, i think - but with tweaks in various directions
16:49:02 <LordBrain> its kind of a shame to scrap it all now
16:50:17 <ndm> my experiences weren't all negative - it has some good bits
16:50:35 <ndm> i just found in the end it wasn't worth it - you may find the other way
16:50:51 <LordBrain> i figured instead of uninstalling VH, i could just use the ghc that it provides
16:51:00 <LordBrain> but then i installed a package
16:51:02 <LordBrain> and
16:51:13 <LordBrain> it seems like its only there in VH, not at the commandline
16:52:01 <sorear> hmm, there seems to be a contradiction in the report.
16:52:16 <LordBrain> which report are you referring to?
16:52:17 <sorear> data Foo = (:+){ x = Int, y = Int }
16:52:20 <sorear> haskell98
16:52:38 <sorear> as an infix op, that must show using infix.
16:52:39 <wmind> anyone familiar with moggis work on monads?
16:52:51 <sorear> as a record, that must show using record syntax.
16:52:59 <sorear> the two cannot be used together...
16:53:41 <LordBrain> is :+ an allowed name for a record?
16:53:52 <ddarius> wmind: Everyone here?
16:53:53 <sorear> certainly.
16:53:59 <wmind> ddarius: great :)
16:54:12 <wmind> Moggi defines a Monadic exponential
16:54:15 <sorear>                   |   con { fielddecl[1] , ... , fielddecl[n] }        (n>=0)  -- allowed syntax for a constructor
16:54:29 <sorear>    con            ->  conid | ( consym )                   (constructor)  -- (:+) is a valid con
16:54:35 <wmind> which is just like the usual exponential
16:55:06 <wmind> but for morphism   AxB -> T C  (with T being the Monad)
16:55:43 * sorear writes gauss elim in hasell, quickly!
16:55:55 <wmind> really cannot tell why that exponential will be different from the usual one
16:55:56 <ndm> sorear, report it for Haskell'
16:56:14 <ddarius> wmind: What does the transpose look like?
16:56:27 <wmind> ddarius: transpose?
16:56:43 <wmind> ddarius: not sure what you mean by transpose
16:56:54 <ddarius> What is the "type" of that function "curried" look like?
16:57:10 <ddarius> A -> (TC)^B or something else?
16:57:25 <basti_> :t curry
16:57:27 <wmind> ddarius: a exactly
16:57:27 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
16:58:19 <wmind> ddarius: that is the thing there is no example of an the 'monadic' exponential object
16:59:11 <wmind> ddarius: so all I know about the curried version is that it is   A-> (B^C)_T
16:59:20 <wmind> ddarius: ops
16:59:32 <wmind> ddarius: A->(C^B)_T
16:59:53 <wmind> ddarius: where (C^B)_T is the monadic exponential object
17:00:19 <wmind> ddarius: what I was trying to find out is wether this is the same as the usual C^B
17:00:31 <wmind> ddarius: because I cannot see why shouldn't it be
17:00:46 <wmind> ddarius: same goes for the application morphism
17:02:01 <wmind> The definition is basically the same as for a regular exponential but with AxB->T C instead of AxB -> C
17:02:40 <wmind> so it seems as if, as long as there is a 'regular' exponential defined, then it can be used for the particular case where the target is of the form TC
17:02:58 <ddarius> wmind: You are talking about the "T-exponentials"?
17:03:05 <wmind> ddarius: yeap
17:03:38 <ddarius> wmind: Okay, yes they are just normal exponentials, however you may have T-exponentials without having all exponentials.
17:03:54 <wmind> ddarius: yes that was my impression
17:05:23 <wmind> ddarius: now it just was not what I was expecting in the beginning, mostly because I expected the uncurried version to be also of form   X -> T Y
17:05:40 <ndm> hmm, the haskell report also doesn't say what the derivation for Bounded of Either is
17:05:47 <ndm> @instances Either
17:05:48 <lambdabot> Couldn't find class `Either'. Try @instances-importing
17:06:03 <LordBrain> trying to use the gcc which came with visual haskell is a pain too... it doesn't seem to see stdlib.h
17:06:04 <ddarius> wmind: It is... ?
17:06:23 <wmind> ddarius: it is?
17:06:47 <dolio> @src minBound Either
17:06:48 <lambdabot> Source not found. Take a stress pill and think things over.
17:06:52 <wmind> ddarius: if we take a regular exponential it is not...
17:07:15 <Igloo> ndm: Because there isn't one?  :-)
17:07:40 <Igloo> ndm: Or do you mean it doesn't tell you have it should be derived?
17:07:48 <wmind> ddarius: say  in haskell  AxB -> [C], the curried would be   A->(B->[C])
17:08:00 <ndm> Igloo, it doesn't say how to derive it, or if deriving it is legal or not
17:08:06 <wmind> ddarius: so it's not of the form A->[X]
17:08:24 <ndm> Igloo - it says how to do it for a single constructor type, and how to for an Enum, but nothing in between
17:09:47 <ndm> oh, it says above that "If C is Bounded, the type must be either an enumeration (all constructors must be nullary) or have only one constructor."
17:09:56 <Igloo> ndm: Ah, yes, it's not 100% clear, but I think the intent is that there isn't one
17:10:14 <ndm> although its a silly restriction, since inductively its obvious what it should be
17:10:21 <ddarius> wmind: Ah, you meant curried version.  If it was of the form A -> TX then (barring potential weirdness) it would be the exponentials in the Kleisli category.
17:10:46 <dolio> What were you thinking? minBound = Left minBound, maxBound = Right maxBound?
17:11:02 <ddarius> T-exponentials aren't really trying for that, they are more about "first class parameterized computations"
17:11:57 <Igloo> dolio: That's what I'd expect
17:12:30 <ndm> yes, its the obvious thing
17:12:33 <wmind> ddarius: well the thing that seemes weird is precisely that the curried version of a function cannot live in the Kleisli cat
17:12:52 <ndm> since at the moment you restrict to either 0-arity constructors, or 1 constructor of any arity
17:12:58 <wmind> ddarius: but I see that you're saying that is not the point at all
17:13:01 <ndm> which isn't a continuous domain
17:13:06 <Igloo> ndm: Perhaps bring it up for Haskell'?
17:13:17 <ndm> Igloo, i'm already composing the email
17:13:22 <Igloo> :-)
17:14:15 <wmind> ddarius: and I'm not really sure if I can see what's the role of these first class parameterized computations
17:14:17 <wmind> :-|
17:14:19 <dolio> Hmm, I guess there are Ord instances for Either, so maybe it's not as weird as I was thinking.
17:15:32 <LordBrain> why all the long faces?
17:15:34 <fantasma> does filter work as its given list is being created or does it wait for the list to be fully created before it starts to filter?
17:15:52 <wmind> ddarius: but yes that clarifies to me what the T-Exponentials are supposed to be like
17:15:57 <LordBrain> it waits
17:16:03 <LordBrain> it works
17:16:09 <LordBrain> i mean as its being constructed.. its lazy
17:16:50 <LordBrain> > filter (<2) (repeat 1)
17:16:52 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:17:43 <fantasma> is the nub function also lazy?
17:17:48 <LordBrain> yeah
17:18:49 <LordBrain> nice huh?
17:19:51 <fantasma> yah
17:20:02 <fantasma> it starts going really slow after awhile though
17:20:17 <LordBrain> oh
17:20:21 <fantasma> my list is only 28,123 long :(
17:20:22 <LordBrain> hadn't noticed
17:21:13 <LordBrain> hmmm
17:21:16 <dolio> @src nubBy
17:21:17 <lambdabot> nubBy eq []             =  []
17:21:17 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
17:21:20 <Igloo> nub is quadratic time and linear space
17:21:24 <LordBrain> maybe try increasing your heapsize
17:21:38 <Igloo> If you don't mind sorting your data, then doing that and writing a nubSorted will be better
17:21:49 <monochrom> why use nub? why use unordered list?
17:22:00 <fantasma> well I'm doing something kinda stupid
17:22:06 <LordBrain> i thought you were saying filter slows down
17:22:26 <fantasma> h = (nub . filter (\x -> x < 28124))[x+y | x <- abundantNumbers, y <- abundantNumbers]
17:23:19 <thedward> @src Handle
17:23:19 <lambdabot> Source not found. I've seen penguins that can type better than that.
17:23:59 <thedward> @src hGetChar
17:24:00 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
17:24:09 <LordBrain> hmmm, i think it's actually slightly more readable when you use sections like (< 28124)
17:24:19 <LordBrain> at least to haskellers :)
17:24:40 <fantasma> ah of course
17:24:44 <monochrom> readability depends on fluency.
17:24:46 <dolio> fantasma: You could probably rewrite that so that you don't generate any duplicates.
17:24:48 * qwr . o O ( Data.Set )
17:24:51 <LordBrain> yeah
17:25:52 <wmind> ddarius: thanks, I'm out!
17:25:53 <monochrom> As a matter of principle, I write my programs readable for learned programmers, not beginners.
17:26:33 <monochrom> Even the child psychologists recommend adults to talk like adults, not talk funny and kiddish, to kids.
17:26:36 <LordBrain> well to make it readable to a beginner would involve a lot more verbiage
17:26:52 <LordBrain> and actually make it less readable to the experienced people due to clutter
17:27:21 <LordBrain> hmmm nice analogy
17:27:28 <LordBrain> :)
17:27:30 <sorear> grr.
17:27:48 <sorear> I finished correctly implementing guassian elim, as I learned it
17:27:49 * Sgeo begins designing a Haskell client for a difficult to understand chat protocol
17:28:00 <LordBrain> which protocol?
17:28:09 <Sgeo> JRChat
17:28:10 <sorear> as I learned it, [[1,0],[0,1]] is un-invertable :(
17:28:13 <LordBrain> you're not doing qq by chance?
17:28:18 <dolio> > let f [] = []; f (x:xs) = [ x + y | y <- xs ] ++ f xs in f [1..10]
17:28:20 <lambdabot>  [3,4,5,6,7,8,9,10,11,5,6,7,8,9,10,11,12,7,8,9,10,11,12,13,9,10,11,12,13,14,1...
17:28:20 <Sgeo> What's qq?
17:28:22 <sorear> obviously I learned it wrong! :)
17:28:25 <monochrom> hahahahha
17:28:43 <ddarius> Crap!
17:28:50 <sorear> ddarius: ?
17:28:51 <dolio> > let f xs = nub [ x + y | x <- xs, y <- xs ] in f [1..10]
17:28:52 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
17:29:18 <dolio> Oops, I missed the x + x case, but you get the idea.
17:29:19 <LordBrain> qq is an extremely popular instant messaging client, the only reason most of us havent  heard of it, is that all its users are in china or south africa
17:29:36 <fantasma> dolio: isnt that essentially the same thing I was doing?
17:29:54 <dolio> fantasma: The second is, but check out the first.
17:30:05 <fantasma> ah I see
17:30:22 <dolio> fantasma: Actually, that generated duplicates.
17:30:29 <LordBrain> http://en.wikipedia.org/wiki/Qq
17:30:31 <lambdabot> Title: Tencent QQ - Wikipedia, the free encyclopedia
17:30:43 <LordBrain> world's third most popular client according to the great wikipedia
17:30:59 <ddarius> sorear: I had a bit more to say about T-exponentials.
17:31:07 <fantasma> > nub $ repeat 1
17:31:11 <lambdabot> Terminated
17:31:28 <ddarius> > head $ nub $ repeat 1
17:31:30 <lambdabot>  1
17:31:59 <fantasma> shouldn't it return the empty set?
17:32:22 <ddarius> fantasma: Why?
17:32:36 <ddarius> It returns (1:_|_)
17:32:57 <fantasma> :t nub
17:33:00 <lambdabot> forall a. (Eq a) => [a] -> [a]
17:33:19 <monochrom> 1 is correct.
17:34:29 <dolio> fantasma: Oh, the problem is that different numbers sum to the same thing, so you'd still have to nub with the first one. But it cuts the candidate list in half. :)
17:34:54 <kpreid> > nub $ join replicate =<< [0..]
17:34:56 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:36:01 <thedward> @src join
17:36:02 <lambdabot> join x =  x >>= id
17:36:58 <plediii> Is there some command to trace the function calls a command entails?
17:38:13 <sorear> plediii: look at 'hat'
17:38:16 <sorear> @where hat
17:38:16 <lambdabot> http://www.haskell.org/hat/
17:40:10 <LordBrain> @type replicate
17:40:13 <lambdabot> forall a. Int -> a -> [a]
17:40:37 <plediii> thanks sorear
17:40:53 <ndm> plediii - be prepared for it not to work though...
17:41:23 <plediii> :(
17:41:42 <fantasma> how can the heap size be set in ghci?
17:41:53 <sorear> ndm: haha, my corner case is handled by hugs in a way that conflicts with a different part of the report!
17:42:04 <sorear> fantasma: ghci +RTS -M386M
17:42:18 <sorear> -M is max heap size, -H is initial
17:42:24 <sorear> it really is all in the manual :(
17:42:35 <LordBrain> kpreid, i know it will be simple once i see it... but how is that working... replicate takes 2 parameters for instance, and i dont see where they are coming from
17:42:48 <fantasma> sorear: sorry :)
17:42:49 <kpreid> LordBrain: join
17:42:52 <ndm> sorear, GHC 6.4.2 also had a bug relative to both the report and hugs that i found
17:44:27 <sorear> fantasma: http://haskell.org/ghc/dist/current/docs/users_guide/runtime-control.html#rts-options-gc
17:44:29 <lambdabot> Title: 4.14. Running a compiled program, http://tinyurl.com/2hoaa9
17:44:32 <LordBrain> > join replicate =< [0..4]
17:44:33 <lambdabot>   Not in scope: `=<'
17:44:38 <LordBrain> > join replicate =<< [0..4]
17:44:41 <lambdabot>  [1,2,2,3,3,3,4,4,4,4]
17:45:27 <fantasma> sorear: thank you
17:45:28 <ddarius> > join (*) 3
17:45:30 <lambdabot>  9
17:45:30 <LordBrain> gtg
17:49:42 <ndm> sorear, so Yhc gets it right, just different? its nice for Yhc to be right for once
17:50:48 <ohmega> hm.. xmonad needs tagging support.
17:51:20 <ndm> @seen dons
17:51:21 <lambdabot> dons is in #haskell-soc and #haskell. I last heard dons speak 17h 43m 39s ago.
17:51:21 <sorear> ndm: yhc and ghc both get it reasonable.  more reasonably than hugs.
17:51:38 <sorear> ndm: in any case, the spec is contradictory, so rightness is impossible
17:55:37 <sorear> *vomit*
17:55:43 <sorear> (id $!)
17:55:52 <dibblego> when compiling Frag, I get ./BitSet.hs:30:21: Not in scope: `getBounds' -- wtf is that?
17:55:53 <sorear> PEOPLE!  ID IS STRICT ALREADY!!!
17:56:00 <dibblego> lol
17:56:07 <sorear> something that was removed in 6.6
17:56:15 <sorear> see the darcs history for happy
17:56:24 <sorear> they had to fix that from 1.15 -> 1.16
17:56:30 <dibblego> getBounds was removed in 6.6?
17:56:34 <dibblego> I am using 6.4.2 compiler
17:56:53 <Igloo> It was renamed and made monadic
17:57:10 <dibblego> I'm not clear on the correction; should I use a 6.6 compiler?
17:57:18 <ndm> sorear, Dr Haskell warns about id $!
17:58:07 <sorear> ndm: cool.  (is drhaskell alive?)
17:58:39 <ndm> sorear, not really - i need to cabalise Yhc and do some other bits before its worth reviving it
17:59:39 <sorear> imho, dormant should be one of the standard tags.  not that I do a good job of keeping it updated on my site :)
18:00:13 <dibblego> should I use a 6.4.1 compiler instead of 6.4.2?
18:00:14 <ndm> possibly, i have dead, and released is meant to be in a useable state
18:00:41 <sorear> catch isn't released, but development is active.
18:00:52 <ndm> true
18:01:04 <ndm> but i want to release it very shortly, and development isn't that active anymore
18:01:35 <ndm> it now works enough to get me a PhD, and is probably 3 years of research away from being a standard tool for programmers
18:07:18 <dcoutts> hia ndm :-)
18:07:19 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
18:07:24 <dcoutts> @arr!
18:07:24 <lambdabot> I'll crush ye barnacles!
18:07:27 <ndm> hi dcoutts
18:07:36 <sorear> hi dcoutts!
18:07:51 <dcoutts> ndm: the 'right answer' is to use cabal configurations, which do not exist yet.
18:08:07 <dcoutts> the answer is there is no answer
18:08:09 <SamB_XP_> don't you love it when the answer doesn't exist yet?
18:08:12 <ndm> dcoutts, thats not a particularly right answer, when i have 3 failing buildbots
18:08:23 <ndm> that second answer is even less satisfactory
18:08:25 <SamB_XP_> perhaps "worse is better"
18:09:13 <dcoutts> ndm: this is because some of your buildbots use ghc-6.4.2 to build yhc and some use 6.6 right?
18:10:10 <ndm> dcoutts, yep
18:10:25 <ndm> dcoutts, and some of our users use 6.4 as well
18:10:37 <SamB_XP_> how do they manage?
18:10:49 <SamB_XP_> I suppose by not trying to build Xmonad?
18:11:08 <ndm> indeed
18:11:41 <ndm> i guess we may be able to say 6.6 only, but its annoying that the reason is poor library compability and hacks galore rather than an actual feature or bug
18:12:22 <dcoutts> there is a spec for cabal configurations available if anyone want to implement it
18:12:34 <dcoutts> it's going to be even more important when base gets split up
18:12:58 <dcoutts> instead of saying base >= 1.0 you'd going to have half a dozen libs you'll depend on
18:13:45 <dcoutts> fortunately, one of the SoC projects is to implement the Cabal configurations spec
18:14:03 <ndm> yeah, but its all GHC 6.8 stuff at best
18:14:29 <SamB_XP_> dcoutts: that sounds like it would make things easier rather than harder to me...
18:14:34 <SamB_XP_> the split up base
18:14:53 <dcoutts> SamB_XP_: sure there are lots of advantages to splitting up base
18:15:14 <dcoutts> but compatability for cabal based build systems is not one of them
18:15:47 <dcoutts> without configurations it'd be impossible for a single .cabal file to let you build a package with both ghc 6.6 and 6.8
18:16:04 <dcoutts> or rather base-2.0 and the next version
18:17:16 <ndm> or rather ghc 6.4 and 6.6, as is the current case
18:17:25 <dcoutts> right
18:17:42 <dcoutts> but the base split up will be the same problem but about 10 times worse
18:19:08 <sorear> ndm: how does one test derivations these days?
18:19:19 <sorear> ndm: I have deriving TTypeable implemented for you ;)
18:19:36 * ndm sees total failure as a badness of 1.0, and 10 times worse as still 1.0
18:19:38 <sorear> it's type correct in ghci, but I doubt that's enough
18:20:13 <ndm> sorear, runhaskell Derive.hs Example.hs --derive=TTypeable -n
18:20:33 <ndm> sorear, the testing story is not overly great - partly because with automatic derivation its not that necessary
18:20:46 <ndm> and what is TTypeable? i saw you mention it on the ML
18:20:53 <sorear> yay, the ppr goes crazy!
18:21:14 <sorear> oleg's static typeable that you say has too high an instance burden
18:21:15 <ndm> the ppr likes using its horizontal space way too easily
18:21:23 <ndm> yep
18:21:33 <ndm> one instance per type
18:22:02 <sorear> well,  now you can just say '{-! derive : TTypeable !-}' :)
18:22:15 <ndm> that doesn't actually work, only with drift
18:22:17 <sorear> almost as nice as deriving(Typeable)
18:22:33 <ndm> but you can do {-# OPTIONS_DERIVE --derive=TTypeable #-}
18:22:38 <sorear> er, {-! TTypeable !-} ten
18:22:55 <robreim> I'm trying out xmonad. Nice :) dmenu doesn't seem to work though. Where do I find this dmenu_path I see in the source code?
18:22:59 <ndm> that does it for all types in a file
18:24:40 <sorear> ndm: and I didn't have to change ANY of the built in files ;)  though I'd like to get Valcon extended with Type
18:25:05 <robreim> never mind, I think I've discovered it's in a newer version than I'm currently running.
18:25:49 <ndm> sorear, go for it with Valcon - its a very powerful mechanism in there, and its very handy!
18:27:12 <dcoutts> Igloo: thank for the patches, I'll try and look at them today
18:28:33 <ndm> sorear++
18:28:54 <ndm> patches applied and pushed
18:33:20 <fantasma> why is it so slow for haskell to perform 28000^2 addition calculations?
18:33:36 <sorear> (^) is slow, use join (*)
18:33:46 <sorear> GHC is too dumb to rewrite x^2
18:33:54 <fantasma> hmmm
18:34:02 <fantasma> I would have never guessed that
18:34:06 <jcreigh> > 28000^2
18:34:08 <lambdabot>  784000000
18:34:21 <sorear> and by slow, I mean the rhs defaults to Integer, so you get the pain of arb precision as well as a non-inline loop
18:35:11 <fantasma> sorear: I'm doing (+) 28000^2 times
18:35:20 <sorear> ooh.
18:35:37 <sorear> well, that's about a billion adds
18:35:55 <jcreigh> ~784 million, maybe. :)
18:35:57 <sorear> so expect a second on a modern cpu, if you are doing nothing else, and all with Int
18:36:23 <procyon112> > [1,2,3]
18:36:23 <fantasma> I must be doing something wrong =\
18:36:25 <lambdabot>  [1,2,3]
18:36:36 <procyon112> > [Int, Bool]
18:36:38 <lambdabot>   Not in scope: data constructor `Bool'
18:36:40 <jcreigh> fantasma: how long is it taking?
18:36:47 <procyon112> > [Int, Float]
18:36:48 <lambdabot>   Not in scope: data constructor `Float'
18:37:11 <fantasma> jcreigh: I havent seen it stop yet (it's been going for at least a few minutes(
18:37:22 <jcreigh> fantasma: compiled with -O, right?
18:37:28 <procyon112> > [Int, Int]
18:37:29 <lambdabot>   Not in scope: data constructor `Int'
18:37:38 <fantasma> jcreigh: interactive
18:37:46 <dmwit> procyon112: What are you trying to do?
18:37:48 <jcreigh> fantasma: yes, that's slow
18:37:52 <sorear> fantasma: that's your problem
18:37:53 <jcreigh> fantasma: compile with ghc -O
18:37:59 <dmwit> :t [] Int
18:38:01 <lambdabot> Not in scope: data constructor `Int'
18:38:01 <procyon112> > [Just, Just]
18:38:03 <lambdabot>  Add a type signature
18:38:04 <dmwit> :t (Int, Bool)
18:38:06 <fantasma> interactive is really that much slower?
18:38:06 <jcreigh> then see if you still have a problem.
18:38:07 <sorear> PLEASE use -O before complaining about speed!
18:38:07 <lambdabot> Not in scope: data constructor `Int'
18:38:07 <lambdabot>  
18:38:07 <lambdabot> <interactive>:1:6: Not in scope: data constructor `Bool'
18:38:11 <jcreigh> fantasma: yes
18:38:13 <sorear> fantasma: more than 30 times
18:38:18 <fantasma> wow I had no idea
18:38:24 <dmwit> :t (undefined, undefined) :: (Int, Bool)
18:38:27 <lambdabot> (Int, Bool) :: (Int, Bool)
18:38:37 <procyon112> I'm trying to see if it's possible to have a list of constructors.
18:38:48 <sjanssen> heh, David Roundy sent me an xmonad 'test' that makes sure the line count is under 400 :)
18:38:49 <procyon112> :t Just
18:38:52 <lambdabot> forall a. a -> Maybe a
18:39:04 <jcreigh> fantasma: This isn't Ruby, where slow interpretation is the best you'll ever get. :)
18:39:08 <dmwit> sjanssen: Haha!  I think we might be failing that one... =P
18:39:31 <procyon112> > [Just, Just] :: forall a. [a -> Maybe a]
18:39:32 <lambdabot>  Parse error
18:39:35 <sjanssen> dmwit: yeah, we need to update our propaganda
18:39:42 <procyon112> > [Just, Just] :: [a -> Maybe a]
18:39:44 <lambdabot>  Add a type signature
18:40:04 <dmwit> > [Just, Just] :: [Int -> Maybe Int]
18:40:06 <lambdabot>  [<Int -> Maybe Int>,<Int -> Maybe Int>]
18:41:32 <procyon112> > [Just, Just] :: [a->b]
18:41:33 <lambdabot>   Just
18:41:34 <lambdabot>     In the expression: [Just, Just]
18:41:34 <lambdabot>     In the expression: [Just, Just...
18:42:27 <jcreigh> sjanssen: what were the plans regarding the xmonad homepage?
18:42:50 <dmwit> > cycle [Just, Nothing] >>= ($ 5)
18:42:52 <lambdabot>  Couldn't match expected type `a -> Maybe a'
18:43:06 <dmwit> > cycle [Just, \x -> Nothing] >>= ($ 5)
18:43:07 <lambdabot>  Couldn't match expected type `[]' against inferred type `Maybe'
18:43:18 <sjanssen> jcreigh: I've got ftp access now
18:43:36 <sjanssen> in the long term we might have it redirect to space on haskell.org.  Not really sure yet
18:43:49 <jcreigh> ah, cool.
18:43:53 <dmwit> > (cycle [Just, \x -> Nothing]) >>= ($ 5) -- why doesn't it know I want the *list* monad?
18:43:54 <lambdabot>  Couldn't match expected type `[]' against inferred type `Maybe'
18:44:17 <jcreigh> :t Just $ 5
18:44:20 <lambdabot> forall a. (Num a) => Maybe a
18:44:24 <liquidengineer> Hi
18:44:33 <jcreigh> dmwit: if you're in the list monad, return a list.
18:44:50 <liquidengineer> I'm having a math brainfault.  If I want to figure out if a number is a multiple of four, I just mod it by four and test for 0, yes?
18:44:51 * dmwit feels small
18:45:08 <dmwit> > liftM ($ 5) $ cycle [Just, \x -> Nothing]
18:45:10 <lambdabot>  [Just 5,Nothing,Just 5,Nothing,Just 5,Nothing,Just 5,Nothing,Just 5,Nothing,...
18:45:20 <procyon112> > zipWith (\x y-> x y) [Just, Just, Just] [1,2,3]
18:45:22 <lambdabot>  [Just 1,Just 2,Just 3]
18:45:24 <dmwit> liquidengineer: Sounds good!
18:45:37 <dmwit> > zipWith ($) [Just, Just, Just] [1, 2, 3]
18:45:39 <lambdabot>  [Just 1,Just 2,Just 3]
18:47:06 <dmwit> > filter (\x -> x .&. 4 == 0) [1..]
18:47:07 <lambdabot>  Add a type signature
18:47:13 <dmwit> > filter (\x -> x .&. 4 == 0) [1..] :: [Int]
18:47:15 <lambdabot>  [1,2,3,8,9,10,11,16,17,18,19,24,25,26,27,32,33,34,35,40,41,42,43,48,49,50,51...
18:47:24 <dmwit> > filter (\x -> x .&. 3 == 0) [1..] :: [Int]
18:47:25 <lambdabot>  [4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,1...
18:47:53 <dmwit> But that only works for testing divisibility of things that are a power of two.
18:48:13 * jcreigh wonders if GHC is clever enough to do that on its own.
18:48:19 <dmwit> jcreigh: Nope.
18:48:26 <dmwit> =(
18:48:55 <jcreigh> does -O imply -fvia-C?
18:48:58 <dmwit> A couple nights ago somebody (sorear?) commented that "even" expands to a division operation...
18:49:40 <dmwit> jcreigh: Oh, does `mod` get turned to % in C?  Then gcc is probably smart enough to do that for you.
18:49:41 <sorear> yup, it was me
18:49:51 <jcreigh> dmwit: dunno...
18:49:52 <sorear> but only with -fasm
18:50:01 <sorear> with -fvia-C, gcc optimizes it to a bit test
18:59:49 <liquidengineer> Server spplit?
19:00:27 <dmwit> *burp*
19:00:39 <dmwit> It was the most delicious server split I've had in ages, you must send me the recipe!
19:01:18 <liquidengineer> Mind if I run some functions by ya'll?
19:01:25 <liquidengineer> I'm having some difficulties
19:01:27 <dmwit> ?hpaste
19:01:27 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:01:28 <liquidengineer> they're really short
19:01:40 <dmwit> Or here is fine if they're very short. =)
19:02:15 <hpaste>  (anonymous) pasted "Determine if an input is ((multiple of 4) plus 1)" at http://hpaste.org/1436
19:02:29 <liquidengineer> that was me....sorry
19:02:59 <liquidengineer> That should work, shouldn't it?
19:03:03 <dmwit> liquidengineer: if p then True else False === p
19:03:04 <sorear> jcreigh: -O implies -fvia-C  iff your ghc is 6.6 or older
19:03:04 <sorear> in HEAD, the options are independant
19:03:04 <sorear> dmwit, jcreigh: I've looked at the asm, -fvia-C has a bit test, -fasm has a IDIV
19:03:29 <dmwit> sorear: Ah, neat, thanks!
19:04:12 <dmwit> liquidengineer: It works, yes.
19:04:13 <liquidengineer> dmwit?
19:04:16 <liquidengineer> ah
19:04:17 <hpaste>  dmwit annotated "Determine if an input is ((multiple of 4) plus 1)" with "a possible simplification" at http://hpaste.org/1436#a1
19:04:24 <sorear> liquidengineer: you did all this!?
19:04:28 <sorear> huh?  what did I do?
19:07:10 <hpaste>  liquidengineer annotated "Determine if an input is ((multiple of 4) plus 1)" with "Now with pickMove" at http://hpaste.org/1436#a2
19:07:24 <liquidengineer> Now, this is where I'm having problems
19:07:45 <liquidengineer> pickMove should return a 1, 2, or 3 as explained in the comments
19:07:47 <liquidengineer> It does not.
19:08:30 <dmwit> liquidengineer: Imagine what happens if you pass that function 0.
19:08:46 <dmwit> Err... to be more specific:
19:09:00 <dmwit> Imagine if numToTake == pieces.
19:09:44 <liquidengineer> You'd zero out pieces?
19:09:51 <dmwit> liquidengineer: You don't really want a recursive function here.
19:09:58 <liquidengineer> I don't?
19:10:05 <liquidengineer> a case statement, maybe?
19:10:10 <dmwit> There's some simple modular arithmetic that will give the number you're looking for.
19:10:15 <liquidengineer> Oh?
19:10:29 <dmwit> Suppose there are 37 pieces.
19:10:33 <liquidengineer> Yes.
19:10:37 <dmwit> (I assume you can take up to three at a time, yes?)
19:10:40 <liquidengineer> Yes
19:10:46 <dmwit> How many do you want to take?
19:10:50 <liquidengineer> but I have to take at least 1
19:10:55 <dmwit> Sure.
19:11:15 <liquidengineer> I want to take the minimum to leave a multiple of 4, plus 1
19:11:35 <dmwit> liquidengineer: Actually, I think you want to leave it as a multiple of four, if we're thinking of the same game.
19:11:47 <bd_> @hoogle digitToInt
19:11:48 <lambdabot> Char.digitToInt :: Char -> Int
19:12:12 <liquidengineer> dmwit: I'm trying to play a variant of Nim, "21," as defined here
19:12:13 <liquidengineer> http://en.wikipedia.org/wiki/Nim#Other_variations_of_the_game
19:12:20 <liquidengineer> Did I read the algorithm wrong?
19:13:16 <dmwit> liquidengineer: Is the goal to take the last piece, or make the opponent take the last piece?
19:13:51 <liquidengineer> "loss is achieved through speaking 21"
19:13:58 <liquidengineer> so I'm guessing if you take the last piece, you lose
19:14:15 <dmwit> Ah, okay.
19:14:18 <dmwit> Fine then.
19:14:21 <liquidengineer> (note that I've modified it to count down from 21, instead of up.
19:14:27 <dmwit> Still, there is simple modular arithmetic to do what you want.
19:14:42 <dmwit> (I promise!  It's even on the page you pointed me to.)
19:14:48 <liquidengineer> lol
19:14:53 <liquidengineer> let me look closer
19:16:12 <liquidengineer> n ? 1 (mod k+1) (in mis?re play).
19:16:14 <liquidengineer> Is that it?
19:16:27 <liquidengineer> (I suck at mod)
19:16:37 <dmwit> Yep, pretty much.
19:16:57 <liquidengineer> I suppose, if you can't take 1, 2, or 3, you've lost.
19:17:07 <liquidengineer> so if n = 0, you lose, yes?
19:17:14 <dmwit> Right.
19:17:25 <dmwit> Err... if n=0 when it gets to you, you've just won.
19:19:30 <liquidengineer> Crap
19:19:39 <liquidengineer> I'm blanking on how to convert that to haskell
19:19:47 <liquidengineer> stupid lack of sleep. -_-
19:20:53 <liquidengineer> Is it this?
19:20:54 <liquidengineer> pieces `mod` (numToTake+1)
19:21:30 <dmwit> liquidengineer: What is numToTake?
19:21:35 <liquidengineer> 3
19:21:41 <liquidengineer> the max you can remove
19:21:53 <dmwit> Ah!
19:22:07 <dmwit> Then mult4plus1 might be wrong in other cases, but we're just using it for now?
19:22:10 <dmwit> Okay.
19:22:40 <liquidengineer> When is it wrong?
19:22:49 <liquidengineer> It should always be right...
19:22:56 <dmwit> Well... if you play a different game where numToTake is 30.
19:23:01 <liquidengineer> ah
19:23:13 <liquidengineer> numToTake will only ever be 3
19:23:20 <liquidengineer> I just renamed it to maxToTake
19:23:36 <liquidengineer> you'll never be able to take less than 1 or more than 3
19:23:40 <dmwit> Well, in the situation where there are 2 pieces left, you know (as a simple case) that you want to take one.
19:23:49 <dmwit> So pieces `mod` (numToTake + 1) can't be it.
19:23:54 <dmwit> ;-)
19:24:40 <liquidengineer> Crap
19:24:41 <liquidengineer> yeah
19:24:45 <liquidengineer> am I close?
19:26:23 <dmwit> Yeah.
19:27:19 <dmwit> liquidengineer: You may need a special case for cases where there is "no winning strategy" -- i.e. when the other play has caught you in a trap.
19:28:10 <liquidengineer> I was planning to catch that in a function that uses this one
19:28:19 <dmwit> liquidengineer: Try writing down in a list the number of pieces you would take (you being a smart player) if it came to you at each of the positions in [1..8] then see if you can find a pattern.
19:29:00 <liquidengineer> okay
19:29:07 <liquidengineer> I'll be back after I compute
19:29:15 <dmwit> Let me know when you have it, and we'll compare answers. =)
19:29:40 <dmwit> > [1,1..] -- hmm, what does this do?
19:29:42 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
19:31:55 <liquidengineer> dmwit: there doesn't seem to be a solution for 4
19:31:57 <liquidengineer> err. 5
19:32:08 <dmwit> Hmmm?
19:32:09 <liquidengineer> that is, if you take 3, it's 2, which is not a multiple of 4 + 1
19:32:25 <dmwit> Yes, and what are the other choices?
19:32:35 <liquidengineer> that is, if you take 2, it's 1 which is not a multiple of 4 + 1
19:32:46 <dmwit> No, if you take 2, it becomes 3!
19:32:51 <dmwit> And if you take 1...?
19:32:59 <liquidengineer> 4
19:33:07 <liquidengineer> which is NOT a multiple of 4 + 1.
19:33:12 <dmwit> Oh, I see what you mean.
19:33:19 <dmwit> Yeah, this is the "caught you in a trap" case, right?
19:33:25 <dmwit> There's nothing you can do.
19:33:44 <dmwit> So pick an arbitrary number (say 1), and skip to the next case.
19:34:01 <liquidengineer> Huh
19:34:05 <liquidengineer> that's so strange
19:34:14 <liquidengineer> does the algorithm mention that that I linked to??
19:34:14 <dmwit> Incidentally, I'm surprised you didn't claim this was a problem at 1... because it is.
19:34:25 <liquidengineer> I haven't gotten down there yet
19:34:39 <liquidengineer> I wonder...do you think it only works if you start with 21?
19:34:39 <dmwit> liquidengineer: It isn't strange -- it's the PURPOSE of the algorithm!  If both you and your opponent can do this, then it *can't* be the perfect strategy.
19:34:47 <dmwit> liquidengineer: Certainly not.
19:36:00 <liquidengineer> Do you think they count 0 as a multiple of 4?
19:36:06 <jcreigh> The reason you're supposed to leave a multiple of 4 + 1 is because it's bad for the other guy...so the fact that 5 is a losing position should not be shocking, right?
19:36:10 <dmwit> definitely
19:36:35 <dmwit> > 4 `mod` 4 == 0
19:36:37 <lambdabot>  True
19:37:14 <liquidengineer> I run into the same problem with 4
19:37:29 <dmwit> You shouldn't.
19:37:41 <liquidengineer> > [4 - 3, 4 - 2, 4 - 1]
19:37:43 <lambdabot>  [1,2,3]
19:37:54 <liquidengineer> none of those are multiples of 4
19:37:56 <liquidengineer> + 1
19:38:01 <dmwit> One of them is. ;-)
19:38:10 <liquidengineer> Oh!
19:38:13 <liquidengineer> Zero is a multiple of 4
19:38:14 <liquidengineer> Right?
19:38:17 <dmwit> right
19:39:42 <liquidengineer> and I get down to 1 and I've lost
19:39:51 <liquidengineer> because if there's one on the stack it's all over but the crying
19:39:55 <dmwit> Good!
19:40:00 <dmwit> > cycle [0..3] -- this is what I get, where 0 means we're caught in a trap and have to do something arbitrary
19:40:02 <lambdabot>  [0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1...
19:40:07 <dmwit> Do you also get this?
19:40:18 <liquidengineer> Mine's backwards
19:40:22 <liquidengineer> I counted down from 8
19:40:24 <liquidengineer> ;)
19:40:26 <dmwit> =
19:40:27 <liquidengineer> but yeah
19:40:27 <dmwit> P
19:40:33 <liquidengineer> otherwise yes
19:40:40 <liquidengineer> 3,2,1 repeating
19:40:47 <dmwit> Okay -- do you see a pattern? ;-)
19:41:07 <liquidengineer> 8-5 = 3
19:41:16 <liquidengineer> 7-5 = 3
19:41:20 <liquidengineer> err. 2
19:41:28 <liquidengineer> 6-5 = 1
19:41:41 <liquidengineer> 5-5 = 0, so you've gotta substitute a move
19:41:51 <dmwit> The next step is to see if you can figure out what modular operation gives you these same results.
19:42:03 <dmwit> Do you understand modular arithmetic?
19:42:28 <liquidengineer> 7 `mod` 5
19:42:44 <dmwit> > 7 `mod` 5
19:42:45 <lambdabot>  2
19:42:51 <dmwit> Not quite.
19:43:02 <liquidengineer> Isn't that what we want?
19:43:05 <dmwit> > 2 `mod` 5
19:43:07 <lambdabot>  2
19:43:21 <dmwit> But that should have been a 1, so that isn't quite it.
19:43:28 <liquidengineer> switch 'em?
19:43:54 <dmwit> Wait half a tick.
19:44:19 <dmwit> liquidengineer: No, don't switch them.
19:44:27 <dmwit> Look, here's the problem:
19:44:35 <dmwit> > 24 `mod` 5
19:44:37 <lambdabot>  4
19:44:40 <dmwit> But you can't take 4 pieces!
19:44:59 <liquidengineer> point
19:45:32 <dmwit> You know how the hour in military time goes from 0 to 23, then resets?
19:45:37 <liquidengineer> Yes
19:45:57 <liquidengineer> 0 is really 12 AM
19:46:07 <dmwit> That is because military hour is done modulo 24, and is a pretty good analog for most other modulo operations.
19:46:08 <jcreigh> 12 AM is really 0. :)
19:46:16 <liquidengineer> 12 mod 12?
19:46:41 <liquidengineer> Oh!
19:46:48 <dmwit> Actually, that one is a little frustrating because there is a translation to something that doesn't behave quite like a modulo.
19:46:52 <liquidengineer> 12 mod 24 and so on?
19:46:57 <dmwit> So, maybe we should talk about the minutes in time. ;-)
19:47:05 <dmwit> These range from 0 to 59, then reset, right?
19:47:14 <liquidengineer> Yes
19:47:15 <dmwit> That means they are done modulo 60.
19:47:19 <liquidengineer> Yes
19:47:29 <dmwit> And if you start at 45 and add 30, you get 15, not 75, right?
19:47:39 <liquidengineer> Yes
19:47:54 <dmwit> If you start at 45 and add 90, you still get 15.
19:47:57 <dmwit> So the general rule is:
19:48:14 <dmwit> after you add, use the *remainder* you would get if you divided by 60.
19:48:27 <dmwit> This is the essence of modular arithmetic -- you always deal with the remainder of a division.
19:48:44 <dmwit> So if you are using integers modulo n, they will always be in the range [0..n-1].
19:49:07 <liquidengineer> Yeah
19:49:13 <dmwit> Cool.
19:49:21 <dmwit> Now we're starting with a number that can be as big as it wants.
19:49:26 <dmwit> So it isn't in any modulo system.
19:49:33 <dmwit> But our *end result* is different, right?
19:49:38 <liquidengineer> Yes
19:49:42 <liquidengineer> It will be in the system
19:49:42 <dmwit> Right.
19:49:59 <dmwit> Which system?
19:51:16 <liquidengineer> modulo 4?
19:51:20 <jcreigh> > map (`mod` 4) [1..]
19:51:20 <dmwit> Perfect!
19:51:22 <lambdabot>  [1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2...
19:51:28 <jcreigh> ^^^ does that suggest anything to you?
19:51:41 <dmwit> And then we just need to be careful about off-by-one errors, and we should be pretty close to done.
19:52:15 <liquidengineer> so let's say I have 50 stones
19:52:21 <dmwit> yes
19:52:22 <liquidengineer> > 50 `mod` 4
19:52:24 <lambdabot>  2
19:52:29 <liquidengineer> so I want to take 2?
19:52:32 <dmwit> Close!
19:52:35 <jcreigh> not quite.
19:52:39 <dmwit> As I said, there might be off-by-one errors.
19:52:47 <jcreigh> > 6 `mod` 4
19:52:48 <lambdabot>  2
19:53:04 <dmwit> This is why I asked you to figure out the strategy for the first eight numbers.
19:53:24 <liquidengineer> it was 3 2 1 repeating
19:53:43 <liquidengineer> from 8 to 1
19:53:55 <jcreigh> so let's just say you have "zero" meaning "I'm screwed", the any other N meaning "take that many".
19:54:01 <liquidengineer> Yeah
19:54:09 <liquidengineer> that's what I want
19:55:06 <jcreigh> so with 6, you're supposed to take 1, right?
19:55:30 <liquidengineer> six mod four is 2
19:55:41 <liquidengineer> but yeah
19:55:52 <liquidengineer> according to the excercise, I need to take 1
19:56:05 <liquidengineer> so, it's x mod 4 - 1?
19:56:16 <liquidengineer> so, it's (x mod 4) - 1?
19:56:26 <dmwit> In general, you want to do additions and subtractions before using a mod.
19:56:27 <jcreigh> N mod M is always in the range [0..M-1]
19:56:47 <jcreigh> (x `mod` 4) - 1 will be in the range [-1..2]
19:56:51 <liquidengineer> ah
19:56:54 <liquidengineer> so....
19:57:00 <liquidengineer> (x - 1) `mod` 4
19:57:09 <dmwit> Cool!
19:57:11 <dmwit> Let's try it out.
19:57:21 <dmwit> > map (\x -> x - 1 `mod` 4) [1..]
19:57:22 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
19:57:33 <dmwit> > map (\x -> (x - 1) `mod` 4) [1..]
19:57:35 <lambdabot>  [0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1...
19:57:41 <dmwit> Just what we wanted!
19:57:48 <liquidengineer> w00t!
20:00:27 <dcoutts> @seen ndm
20:00:27 <lambdabot> I saw ndm leaving #haskell 1h 10m 51s ago, and .
20:00:59 <hpaste>  liquidengineer annotated "Determine if an input is ((multiple of 4) plus 1)" with "Fixed pickMove" at http://hpaste.org/1436#a3
20:01:14 <liquidengineer> I added some code to deal with the 0
20:01:39 <dcoutts> @tell ndm we should write a TMR article some time on test driven development for Haskell components using property & performance tests
20:01:40 <lambdabot> Consider it noted.
20:02:11 <dmwit> liquidengineer: Cool!
20:02:24 <dmwit> liquidengineer: Also, you may be interested in this trick:
20:02:39 <dmwit> > map (max 1) [0,1,2,3]
20:02:41 <lambdabot>  [1,1,2,3]
20:03:00 <dmwit> > map (\x -> if x != 0 then x else 1) [0,1,2,3]
20:03:01 <lambdabot>   Not in scope: `!='
20:03:06 <dmwit> > map (\x -> if x /= 0 then x else 1) [0,1,2,3]
20:03:08 <lambdabot>  [1,1,2,3]
20:03:10 <dcoutts> @tell ndm filepath is your nice example of the property case and binary is a good example of both I think, though our property coverage at the moment isn't great, but I'm fixing that now in my new impl.
20:03:10 <lambdabot> Consider it noted.
20:03:24 <jcreigh> > "!=" /= "/="
20:03:26 <lambdabot>  True
20:03:34 * jcreigh sometimes types != as well
20:03:36 <fantasma> does intersection using (\\) take a long time with lists that are millions of elements long?
20:03:50 <dmwit> WHY did they choose /= unlike just about every other language?
20:04:02 <dcoutts> @tell ndm specify, prototype, benchmark, optimise, profit. :-)
20:04:02 <lambdabot> Consider it noted.
20:04:11 <jcreigh> because it, if you half-close your eyes, looks like an actual "not equals" symbol.
20:04:23 <dmwit> ...
20:04:30 <dmwit> About as much as (\ looks like lambda, I guess.
20:04:31 <jcreigh> at least, I assume that's what they were thinking.
20:05:11 <dylan> okay, gentle people of haskell. what will I do with 21 additional function keys?
20:05:12 <liquidengineer> what's the easiest way to generate a random number between x and y?
20:05:18 <jcreigh> well, technically the parens aren't required for a lambda...
20:05:21 <liquidengineer> x and y inclusive
20:05:50 <dmwit> > getStdGen >>= randomR (1,5)
20:05:51 <lambdabot>  Couldn't match expected type `IO' against inferred type `(,) t'
20:06:00 <dmwit> :t randomR
20:06:02 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
20:06:31 <jcreigh> :t randomRIO
20:06:34 <lambdabot> forall a. (Random a) => (a, a) -> IO a
20:07:07 <liquidengineer> ?
20:07:08 <dmwit> > liftM randomR (1, 5) getStdGen
20:07:08 <jcreigh> liquidengineer: do you just need one, or a bunch?
20:07:09 <lambdabot>  Couldn't match expected type `IO StdGen -> t'
20:07:28 <liquidengineer> Just one
20:07:31 <dmwit> > liftM (randomR (1, 5)) getStdGen -- geez, I'm bad at this
20:07:32 <lambdabot>   add an instance declaration for (Typeable StdGen)
20:07:33 <liquidengineer> I want to write a stupid nim player
20:07:43 <liquidengineer> that just picks a number between one and 3
20:08:20 <dmwit> :t (randomR (1, 5))
20:08:23 <lambdabot> forall t g. (Num t, Random t, RandomGen g) => g -> (t, g)
20:08:31 <dmwit> :t liftM (randomR (1, 5))
20:08:34 <lambdabot> forall t a1 (m :: * -> *). (Num t, Random t, RandomGen a1, Monad m) => m a1 -> m (t, a1)
20:09:16 * liquidengineer is now very confused
20:09:22 * dmwit too
20:10:04 <dolio> lambdabot's show instance for functions/IO actions relies to Typeable.
20:10:06 <liquidengineer> I just want a random number
20:10:10 <dolio> I think that's the problem.
20:10:20 <liquidengineer> shouldn't that be really easy?
20:10:20 <dmwit> liquidengineer: Inside the IO monad, you can do randomRIO (1, 3)
20:10:23 <jcreigh> liquidengineer: you're probably going to want to just make your Nim player in be in IO for now.
20:10:26 <dmwit> > randomRIO (1, 3)
20:10:28 <lambdabot>  <IO Integer>
20:10:58 <liquidengineer> I just want an int
20:11:02 <jcreigh> liquidengineer: it's not as easy as it is in other languages because of Haskell's pure nature.
20:11:10 <dmwit> > randomRIO (1, 3) :: IO Int
20:11:12 <lambdabot>  <IO Int>
20:11:16 <liquidengineer> I'd rather not convert everything to IO
20:11:45 <dmwit> liquidengineer: You can produce a list of random numbers in the IO monad, then pass it out to your pure functions.
20:11:56 <liquidengineer> jcreigh: is there any plan in haskell' to simplify that?
20:12:29 <dcoutts> Igloo: good job cleaning up all the ExitCode nonsense, that was indeed one big pile of inconsistencies
20:13:31 <dmwit> liquidengineer: No, I think getting a random number will (and should) stay as it is.
20:13:31 <jcreigh> liquidengineer: I don't believe so. There's no way to simplify it without comprising purity...there's already hacks around it, but you don't want to use those.
20:13:39 <fantasma> what's the syntax for block comment?
20:13:45 <dcoutts> Igloo: the default should certainly be to exit (or throw an exception) rather than passing ignoreable ExitCodes back to callers
20:13:47 <dmwit> {- ... -}
20:13:52 <fantasma> ah yes
20:13:54 <fantasma> thanks
20:14:14 <jcreigh> > randomRs (1,3) (mkStdGen 42)
20:14:15 <liquidengineer> dmwit: I just wonder 'cause I could see Haskell newbies being turned off by this...
20:14:16 <lambdabot>  [3,1,2,2,3,2,1,3,1,1,1,1,1,3,3,2,3,2,1,1,3,1,1,2,2,2,1,3,3,1,2,3,1,3,2,1,1,3...
20:14:25 <liquidengineer> Oooh!
20:14:45 <jcreigh> there's a handy infinite list of pseudo-random numbers seeded from 42...
20:14:52 <dcoutts> Igloo: perhaps an exception with the exit code would be even better inside rawSystemPathExit ? for progs using cabal that'd prefer to catch the exception than just exit, eg GUIs etc etc
20:15:26 <dmwit> liquidengineer: I think the party line goes something like, "In that case, newbies shouldn't want random numbers." ;-)
20:15:38 <dcoutts> Igloo: but that change (if we want it) is much easier now that you've eliminated the ExitCode return values, so good stuff. :-)
20:16:46 <liquidengineer> dmwit: that's a little...eh....ungood?
20:17:17 <dmwit> liquidengineer: It's also not totally serious.
20:17:19 <liquidengineer> I don't really think someone who wants a set of random ints should have to learn about IO monads when they're barely above hello world level
20:17:42 <liquidengineer> but I'm not sure how to reconcile that with purity
20:18:01 <jcreigh> liquidengineer: You can't. There's hacks you can do with unsafePerformIO, but they only lead the newbie down the wrong path.
20:18:16 <dmwit> liquidengineer: It's easy to do without IO.  Just pass it a random number generator; it will spit back a random number and an updated random number generator.
20:18:43 <jcreigh> although there could be a nice, easy tutorial on PRNG in Haskell. I found that standard documentation to be pretty confusing when I was starting out.
20:18:52 <liquidengineer> dmwit: yeah...I've got a library I wrote for that
20:18:56 <liquidengineer> jcreigh: yeah
20:19:02 <liquidengineer> I'm just gonna set the idiot to take 1
20:19:19 <hpaste>  fantasma pasted "I'm stuck!" at http://hpaste.org/1437
20:21:44 <dolio> fantasma: What's wrong with the commented out finalanswer?
20:22:24 <fantasma> dolio: I get stack overflow errors from GHC (despite changing the stack size to 512k)
20:22:41 <dmwit> > 28123*28123*4 / 1024
20:22:42 <lambdabot>  3089465.34765625
20:23:16 <dmwit> All the sums would be some 3G of memory, it looks like.
20:23:28 <dmwit> fantasma: Observe this trick.
20:23:36 <dmwit> Is n a sum of two numbers in xs?
20:23:44 <fantasma> well I was hoping the filter would greatly reduce that
20:23:46 <dmwit> Yes, if n - x is an element of xs for some x in xs.
20:23:58 <dmwit> So, you only need n tests, not n^2 ones.
20:24:12 <dolio> fantasma: This is project euler problem? If so, which number is it?
20:24:19 <fantasma> dolio: problem 23
20:24:59 <fantasma> dmwit: ah I think I understand what you're saying
20:26:16 <dmwit> Oh, I guess there's less than 28123 abundant numbers. =P
20:26:38 <dolio> ?serc (\\)
20:26:39 <lambdabot> (\\) = foldl (flip delete)
20:27:08 <dmwit> That's probably what's blowing your stack.
20:27:14 <dolio> Yeah.
20:28:18 <dolio> foldl' (flip delete) probably wouldn't overflow, although it might not be the best solution.
20:28:34 <dmwit> ?src nub
20:28:34 <lambdabot> nub = nubBy (==)
20:28:38 <liquidengineer> I've gotta bail
20:28:41 <dmwit> ?src nubBy
20:28:42 <lambdabot> nubBy eq []             =  []
20:28:42 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
20:28:43 <liquidengineer> thanks for the help
20:28:50 <liquidengineer> I thought nub was evil and slow?
20:29:06 <dmwit> liquidengineer: You can often do better than nub.
20:29:32 <dmwit> I was just wondering if nub used delete.
20:30:12 <dolio> let f [] = [] ; f (x:xs) = [x + y | y <- xs] ++ f xs in f [1..]
20:30:24 <dolio> > let f [] = [] ; f (x:xs) = [x + y | y <- xs] ++ f xs in f [1..]
20:30:26 <lambdabot>  [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,3...
20:30:56 <fantasma> I use that to make the list of sums
20:31:08 <dmwit> > let f [] = [] ; f (x:xs) = [x + y | y <- xs] ++ f xs in f [2,3,5,7,11]
20:31:09 <lambdabot>  [5,7,9,13,8,10,14,12,16,18]
20:31:41 <dmwit> > let f [] = [] ; f (x:xs) = [x + y | y <- xs] ++ f xs in sort $ f [3,5,7,11,13,17,19,23]
20:31:43 <lambdabot>  [8,10,12,14,16,16,18,18,20,20,22,22,24,24,24,26,26,28,28,30,30,30,32,34,36,3...
20:31:52 <dolio> Yeah. Note that misses the x + x case.
20:31:56 <dolio> If that matters.
20:32:16 <fantasma> :(
20:32:20 <fantasma> didnt realize
20:32:34 <dolio> It's simple to fix.
20:32:58 <dolio> > let f [] = [] ; f xs@(x:xt) = [x + y | y <- xs] ++ f xt in f [2, 3, 5, 7]
20:32:59 <lambdabot>  [4,5,7,9,6,8,10,10,12,14]
20:35:21 <fantasma> I will try using foldl'
20:35:30 <fantasma> @src (\\)
20:35:31 <lambdabot> (\\) = foldl (flip delete)
20:36:41 <sorear> ok, why'd I leave #haskell?
20:37:04 <SamB_XP_> sorear: because you are an idiot?
20:37:17 <rahikkala> 05:03 -!- sorear [n=user@ip68-7-248-101.sd.sd.cox.net] has left #haskell ["ERC Version 5.2 stable pre-release (IRC client for  Emacs)"]
20:37:20 <rahikkala> 06:35 -!- sorear [n=user@ip68-7-248-101.sd.sd.cox.net] has joined #haskell
20:37:36 <rahikkala> So, obviously you left #haskell because you were trying to do too much inside emacs
20:38:01 <fantasma> sorear: what's the other name for foldl' ;)
20:38:13 <sorear> other name?
20:38:20 <sorear> I've seen foldlStrict
20:38:28 <sorear> I misunderstand you, surely
20:38:45 <dolio> usefulFoldl?
20:39:27 <liquidengineer> is != a legal operator?
20:39:32 <sorear> yes.
20:39:48 <sorear> it's not predefined though
20:39:55 <liquidengineer> h
20:39:56 <dmwit> liquidengineer: Surely you want /=
20:39:56 <liquidengineer> ah
20:40:00 <liquidengineer> ....
20:40:05 <liquidengineer> interesting
20:40:08 <dmwit> > 3 /= 5
20:40:10 <lambdabot>  True
20:40:10 <liquidengineer> you are right
20:40:17 <liquidengineer> why doesn't haskell use !
20:40:23 <mlh> > 5.0 /= 5
20:40:25 <lambdabot>  False
20:40:28 <liquidengineer> it's the thingie all other languages use for not equals
20:40:30 <sjanssen> /= looks more like math notation
20:40:34 <dolio> That'd be too conventional.
20:40:38 <liquidengineer> lol
20:40:49 <mlh> how 'bout =/=
20:41:00 <sjanssen> mlh: too long ;)
20:41:03 <liquidengineer> I'm actively moving between PHP, C, and haskell right now
20:41:06 <mlh> yeah just joshing
20:41:10 <liquidengineer> continuity of operators is good. :)
20:41:10 <sorear> sjanssen: How about #, a la Modula-3?
20:41:30 <Cale> liquidengineer: actually, some other programming languages also use /= for not-equals
20:41:33 <sjanssen> sorear: hmm.  My excuse for that one is "huh?" :)
20:41:46 <sorear>  @google Modula-3
20:41:49 <sorear> :)
20:41:57 <sjanssen> that seems like a really goofy syntax
20:42:11 * sorear tries to remember what FORTH uses
20:42:22 <liquidengineer> Cale: Yeah
20:42:27 <sjanssen> # is obviously supposed to be the suffix for unboxed things
20:42:28 * mlh tries not to remember any Forth at all
20:42:47 <Cale> Ada, Eiffel and Fortran 90
20:42:49 <SamB_XP_> sjanssen: or dangerous things!
20:42:56 <liquidengineer> But I'm thinking it would be easier for programmers coming from the mainline languages to pick up haskell if it were as similar as possible
20:42:57 <dmwit> ?remember sjanssen # is obviously supposed to be the suffix for unboxed things
20:42:58 <lambdabot> Done.
20:43:05 <liquidengineer> that is, Java, C, PHP/Python/Perl
20:43:06 <sorear> @flash
20:43:12 <dmwit> ?help flash
20:43:13 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:43:19 <qeb`away> does anyone have a tip for a good IDE for Haskell?
20:43:24 <sorear> qeb`away: emacs
20:43:26 <dmwit> vim
20:43:29 <Cale> liquidengineer: Better to shock people a bit to rid them of their preconceived notions of the way that everything's going to work ;)
20:43:32 <SamB_XP_> liquidengineer: similar-looking would only make it more confusing
20:43:37 <dmwit> sorear: Obviously, we must now duel.
20:43:42 <qeb`away> the inevitable vim/emacs ): ouch
20:43:47 <qeb`away> anything else?
20:43:47 <liquidengineer> oh dea
20:43:50 <liquidengineer> @paste
20:43:51 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:43:54 <sorear> qeb`away: there's always ed
20:43:58 <qeb`away> haskell would be my second language, and I'm not familiar with vim or emacs
20:43:58 <sorear> qeb`away: tsp uses it
20:44:04 <mlh> SamB_XP_: take that thought to it's conclusion ... :-0
20:44:06 <dmwit> qeb`away: There's a Haskell IDE for Visual Studio, if you have it.
20:44:16 <sjanssen> dmwit: he's an emacser, attack the pinky!
20:44:19 <qeb`away> Visual Studio would run on linux?
20:44:22 <qeb`away> haha
20:44:26 <qeb`away> I like this channel already
20:44:41 <hpaste>  liquidengineer pasted "playNim with strange error." at http://hpaste.org/1438
20:44:41 <SamB_XP_> mlh: so obviously we should write code in chinese!
20:44:51 <qeb`away> sorear: do you have a link for ed?
20:45:03 <hpaste>  liquidengineer annotated "playNim with strange error." with "And now with the error." at http://hpaste.org/1438#a1
20:45:03 <dmwit> qeb`away: It's already installed, probably.
20:45:14 <dmwit> qeb`away: You won't like it, if you're looking for an IDE...
20:45:21 <liquidengineer> What's it wanting me to show here?
20:45:25 <sieni> hmm... does visual studio run under wine?
20:45:27 <sorear> qeb`away: just run 'ed'
20:45:28 <fantasma> wow ghc is handling my memory very nicely....
20:45:28 <SamB_XP_> I think ken likes ed
20:45:34 <sorear> qeb`away: or 'man ed'
20:45:40 <sorear> @seen tsp
20:45:41 <lambdabot> tsp is in #haskell-blah and #haskell. I last heard tsp speak 1d 13h 37m 27s ago.
20:45:44 <SamB_XP_> maybe he has moved on to a more advanced editor, like sam...
20:45:48 <Cale> liquidengineer: what did you type at the prompt?
20:45:53 <qeb`away> well, a text editor with syntax highlighting and validation would be great, I'm not looking for anything more really
20:45:54 <liquidengineer> playNim 21
20:46:05 <Cale> liquidengineer: playNim needs another parameter
20:46:07 <liquidengineer> Oh!
20:46:08 <liquidengineer> Wow
20:46:09 <mlh> qeb`away: sorta: http://appdb.winehq.org/appview.php?iAppId=3180
20:46:11 <lambdabot> Title: Wine Application DB - Viewing App - Visual Studio
20:46:14 <sorear> qeb`away: emacs can do that.  vim just does highlighing
20:46:14 <SamB_XP_> qeb`away: ed isn't even a visual editor!
20:46:16 <liquidengineer> coding when exhausted is *fun*
20:46:26 <qeb`away> I just noticed, SamB_XP_
20:46:27 <Cale> liquidengineer: It's saying it doesn't know how to stringify a function.
20:46:39 <qeb`away> liquidengineer: I'm suffering from insomnia currently, tell me about it :|
20:47:06 <qeb`away> sorear: it's not so much that I don't like emacs, I would just have to learn it first, and I'm not sure if I have the patience for it right now
20:47:07 <sorear> dmwit: you can't afford to duel this summer, sorry.  you're 300 miles away and gas just costs too much.
20:47:08 <liquidengineer> I had insomnia last nigh
20:47:08 <Cale> I've had about 2 hours sleep in the last 48, so I'm about ready to sleep :)
20:47:13 <liquidengineer> it's made today interesting
20:47:17 <qeb`away> liquidengineer: try 4 days
20:47:19 <qeb`away> :)
20:47:20 <fantasma> sorear: http://hpaste.org/1437 :D
20:47:34 <liquidengineer> qeb`away: you win -_-
20:47:36 <liquidengineer> sYikes
20:47:38 <dmwit> sorear: Derrr, you know where I am?
20:47:42 <dmwit> oh
20:47:46 <Cale> The longest I've ever stayed up continuously was 59 hours.
20:48:05 <sorear> dmwit: Right, I had to google.
20:48:20 <sorear> dmwit: Stanford is in central ca, who knew?
20:48:20 <Cale> I was doing mathematics almost the whole time, though after the first 24 hours, productivity dropped off pretty quickly.
20:48:43 <SamB_XP_> Cale: you should have done the math about your productivity curve!
20:48:51 <liquidengineer> Oh crap
20:48:53 <SamB_XP_> and realized that it would be more productive to get sleep!
20:49:00 <liquidengineer> my smart player loses when the dumb one takes 3 every time
20:49:12 <liquidengineer> What am I doing wrong?
20:49:43 * fantasma is about to give up and rewrite the program in c
20:49:52 <sorear> fantasma: it smells like you are blaming the wrong function because of laziness.  how fast is it replacing + with `seq`?
20:50:02 <Cale> By the end of it, everything was hilarious, and my vision was starting to get pretty messed up. Things were bright, and colours sort of shifted around a bunch.
20:51:02 <dmwit> sorear: San Diego is more like 500 miles...
20:51:33 <fantasma> sorear: you mean s/x + y/x `seq` y/ ?
20:51:55 <qeb`away> oh
20:52:00 <qeb`away> gedit actually has syntax highlighting
20:52:12 <qeb`away> that'll do for now :)
20:52:15 <hpaste>  liquidengineer annotated "playNim with strange error." with "playNim failing when stupid player (player 2) always chooses 3" at http://hpaste.org/1438#a2
20:52:22 <sorear> fantasma: yes.
20:53:31 <liquidengineer> dmwit: SHouldn't player1 ALWAYS win?
20:53:49 <dmwit> liquidengineer: If the starting number is 21, yes.
20:54:03 <liquidengineer> then why did player2 win this round?
20:54:43 <dmwit> liquidengineer: Gah!  I keep thinking of the game where the person to take the last one wins.
20:54:45 <fantasma> ...1 gig swap being used only to end in a stack overflow
20:54:52 <liquidengineer> sory
20:54:53 <sorear> fantasma: if you rewrite it in C, keeping the all the lazy lists, I will bet it will be even slower than the haskell version.
20:54:56 <liquidengineer> *sorry
20:55:08 <dmwit> liquidengineer: In your case, 21 is already a "losing" number.
20:55:14 <dmwit> > (21 - 1) `mod` 4
20:55:16 <lambdabot>  0
20:55:19 <sorear> fantasma: eliminating indirection will pay off much much much more
20:55:20 <fantasma> sorear: I wouldn't use lists, I just don't know how to do it any other way besides lists in haskell
20:55:23 <liquidengineer> well damn.
20:55:44 <liquidengineer> so how do I tell what stack sizes are illegal?
20:55:49 <liquidengineer> multiples of 21?
20:55:57 <dmwit> Same way you tell if you've been caught in a trap.
20:56:18 <liquidengineer> Yes, but that was an hour ago, and my IQ has dropped off slightly....
20:56:24 <liquidengineer> *more than slightly
20:56:39 <dons> re.
20:56:39 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
20:56:50 <dmwit> liquidengineer: Then go to bed!
20:56:52 <dmwit> ;-)
20:56:57 <sorear> fantasma: I'm running the profiler now!
20:57:19 <sorear> grr, apparently you need +RTS -P.
20:57:29 <liquidengineer> lol
20:57:36 <fantasma> -P?
20:57:42 <fantasma> i thought it was -K
20:58:00 <sorear> no, -K is stack size control.
20:58:38 <liquidengineer> dmwit: I don't want to write logic for this...I just want to put some text in a comment at the top that says "These stack sizes will bite you."
20:58:39 <sorear> I wondered why you were setting the compiler stack size :)
20:58:55 <fantasma> well that's what it said to do in the error message :D
21:01:19 <liquidengineer> dmwit: Okay, I got it.
21:01:28 <liquidengineer> I start with a number x
21:01:32 <fantasma> sorear: -P isn't a valid +RTS option
21:01:39 <sorear> fantasma: you're using nothing but arbitrary precision arithmetic
21:01:59 <sorear> fantasma: +RTS options are for the _Run Time_ system
21:02:07 <liquidengineer> if x-1, x-2, or x-3 is not a multiple of four + 1, then I'm screwed, yes?  That's a bad stack
21:02:08 <sorear> so you use it when you _Run_ the program
21:02:13 <sorear> not when you compile it
21:02:46 <sorear> anyway, I just made your program 33% faster using type signature :)
21:03:04 <fantasma> f :: Int?
21:03:19 <sorear> yes.
21:06:27 <fantasma> Stack space overflow: current size 8388608 bytes.
21:06:27 <fantasma> Use `+RTS -Ksize' to increase it.
21:06:48 <liquidengineer> sorear: do type signature's speeed up programs that much?
21:07:08 <TSC> If you change Integer to Int it might
21:07:19 <sorear> liquidengineer: not directly.  but Integer is slow, and Num a => a is slower still
21:07:41 <sorear> by contrast, Int# is quite fast
21:07:50 <liquidengineer> why the pound sign?
21:08:03 <liquidengineer> and why is Integer slow?
21:08:03 <sorear> because it was unboxed by the optimizer!
21:08:04 <igli> "kdevelop 3.3.6 can (1) create a haskell project for ghc (2) does some rudimentary autocompletion and (3) its quite good tool to organize all the web&local haskell docs into one indexed viewer"
21:08:07 <SamB_XP_> primitive (unboxed) version!
21:09:05 <fantasma> how big can a stack be?
21:10:07 <fantasma> apparently by 100 megabyte stack isnt big enough....
21:10:23 <fantasma> s/by/my
21:10:26 <SamB_XP_> you are probably using the wrong fold ;-)
21:11:11 <fantasma> I'm using foldl`
21:11:25 <SamB_XP_> try foldl'
21:12:16 <fantasma> same thing =\
21:12:24 <qeb`away> this is scary
21:12:31 <qeb`away> how can a recursive fibonacci row be that fast?
21:12:35 <qeb`away> did I do something wrong? :|
21:12:46 <liquidengineer> Gotta go before I fall asleep at my desk
21:12:47 <liquidengineer> Bye
21:12:51 <liquidengineer> thanks for all the help
21:13:03 <qeb`away> fib x =
21:13:03 <qeb`away>  if x < 2
21:13:03 <qeb`away>   then 1
21:13:03 <qeb`away>    else fib (x-1) + fib (x-2) <= that IS correct, right?
21:13:33 <dons> ?wiki The_Fibonacci_sequence
21:13:34 <lambdabot> http://www.haskell.org/haskellwiki/The_Fibonacci_sequence
21:14:45 <dons> qeb`away: so that's solution number 1. :-) ^^
21:15:00 <fantasma> I give up
21:15:13 <qeb`away> it's not that, but the interpreter did fib 10^20 before I managed to blink, and that doesn't seem natural
21:15:55 <dons> did it overflow on Int?
21:16:07 <fantasma> yeah
21:16:15 <fantasma> and on foldl'
21:16:32 <fantasma> and -K100M (whatever that is)
21:16:34 <dons> > fix ((1:) . scanl (+) 1) -- haskellers preferred ;-)
21:16:36 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
21:16:45 <SamB_XP_> qeb`away: what is surprising about that?
21:16:50 <SamB_XP_> 10 isn't very big
21:17:00 <SamB_XP_> and ^20 isn't very hard to do ;-)
21:17:03 <dons> > let fib = 1 : 1 : zipWith (+) fib (tail fib) in fib -- also recommended
21:17:04 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
21:17:20 <dons> yeah, SamB_XP_ is right.
21:17:21 <qeb`away> it does the same for 10^90 :|
21:17:30 <qeb`away> and 110
21:17:36 <dons> ^ doesn't bind tighter than application :-)
21:17:43 <SamB_XP_> > let fibs = 1 : 1 : zipWith (+) fib (tail fib), fib n = fibs !! n in fib 10 ^ 90
21:17:44 <lambdabot>  Parse error
21:17:52 <SamB_XP_> > let fibs = 1 : 1 : zipWith (+) fib (tail fib); fib n = fibs !! n in fib 10 ^ 90
21:17:54 <lambdabot>      The equation(s) for `fib' have one argument,
21:17:54 <lambdabot>     but its type `[a]' has ...
21:18:08 <dons> fibs n ?
21:18:16 <dons> take 10
21:18:26 <SamB_XP_> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs); fib n = fibs !! n in fib 10 ^ 90
21:18:27 <lambdabot>  2786766608095752287141874763055829616008458909356529297512774308657035154553...
21:18:39 <dons> haskell rocks
21:18:47 <dons> it rocks unnaturally
21:18:51 <SamB_XP_> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs); fib n = fibs !! n in fib 10
21:18:52 <lambdabot>  89
21:19:00 <SamB_XP_> > 89 ^ 90
21:19:02 <lambdabot>  2786766608095752287141874763055829616008458909356529297512774308657035154553...
21:19:11 <qeb`away> so basically, haskell is very, very good for numeric calculations?
21:19:12 <robreim> dons, is there any plans to make xmonad's tagging system similar to dwm's?
21:19:24 <fantasma> dons: I gave sjans(s)en ftp access to xmonad.org for now
21:19:49 <ClaudiusMaximus> > let f x = x + 100 in f 10^2
21:19:51 <lambdabot>  12100
21:20:01 <sorear> qeb`away: Personally, I'm a big fan of the Gosper/Salamin :)
21:20:24 <qeb`away> can you translate that for me? :P
21:20:31 <dons> robreim: not that i know of.
21:20:33 <dons> fantasma: ah great!
21:20:41 <qeb`away> and fib 10^1000 seemed to make it a bit angry
21:20:42 <dons> fantasma: so yes, we need to be able to edit that page :-)
21:20:50 <dons> since we're hoping to release xmonad rather soon
21:20:52 <sorear> @seen JohnMeacham
21:20:53 <lambdabot> JohnMeacham is in #haskell-blah and #haskell. I don't know when JohnMeacham last spoke.
21:21:11 <sorear> where can I get a copy of DrIFT?
21:21:14 <ClaudiusMaximus> > let f x = x + 100 in f (10^2)
21:21:16 <lambdabot>  200
21:21:20 <sorear> JohnMeacham: still haven't fixed the corrupt repo!
21:21:22 <fantasma> dons: I'll be getting a dedicated server soon so I'll be able to get you shell accounts and such
21:21:50 <dons> would it be possible to just redirect xmonad.org to say, haskell.org/xmonad cleverly somehow?
21:22:03 <SamB_XP_> dons: why cleverly?
21:22:08 <dons> then we don't need to worry about your server going down
21:22:09 * sorear swallows his pride and fetches a tarball
21:22:12 <dons> or you disappearing :-)
21:22:15 <SamB_XP_> wouldn't the normal way work well enough/
21:22:20 <SamB_XP_> s|/|?|
21:22:24 <fantasma> dons: I think haskell would have to do a quick dns entry
21:22:32 <dons> yeah.
21:22:51 <SamB_XP_> what was that HTTP code...
21:23:03 <igli> an easy way is just to set the server to redirect (standard HTTP)
21:23:19 <jcreigh> dons: HTTP redirect or virtual hosting?
21:23:29 <fantasma> well if they wanted to use darcs or other services http redirect wouldnt work ;)
21:23:36 <SamB_XP_> fantasma: oh.
21:23:58 <SamB_XP_> you make a good point
21:24:08 <sorear> can't we just give sjanssen the pw to xmonad.org?
21:24:28 <jcreigh> 19:41 <jcreigh> sjanssen: what were the plans regarding the xmonad homepage?
21:24:28 <jcreigh> 19:42 <sjanssen> jcreigh: I've got ftp access now
21:24:32 <jcreigh> 19:42 <sjanssen> in the long term we might have it redirect to space on haskell.org.  Not really sure yet
21:24:48 <dons> yeah, we'd need the haskell.org/xmonad page set up
21:24:54 <dons> then we'd look at redirecting however
21:25:34 <sorear> why?
21:25:41 <igli> fantasma: i'd just give them the correct darcs address tbh, but the DNS thing would be the best sol'n longer term :)
21:26:06 <sorear> haskell.org has had no shortage of downtime itself ;)
21:26:28 <dons> because that's where all other haskell projects live, sorear
21:26:35 <qeb`away> what is the haskell compiler coded in?
21:26:51 <qeb`away> it is unnaturally fast :|
21:26:51 <dons> most haskell compilers are written in haskell
21:26:59 <qeb`away> bootstrapped, then?
21:27:01 <dons> one is written in LML, one interpreter is written in C.
21:27:04 <jcreigh> qeb`away: yeah
21:27:14 <qeb`away> okay
21:27:18 <dons> qeb`away: not boostrapped, just recursion ;-)
21:27:26 <qeb`away> how comes it does so well with recursive algorithms?
21:27:47 <dons> recursive calls are compiled to gotos
21:27:49 <sorear> not drift, not jhc, not catch,....
21:27:49 <sorear> not lambdabot
21:27:51 <sorear> not hs-plugins
21:27:52 <robreim> dons, would it be a bad idea to add dwm-like tagging to xmonad?
21:27:53 <jcreigh> I think the usual way to port GHC to new arch is to compile to slow, portable C, then compile that.
21:28:00 * jcreigh has never even compiled GHC
21:28:24 <dons> robreim: none of the devs uses the extended tagging. it wouldn't be impossible, but we've not had a compelling argument for it
21:28:35 <SamB_XP_> gotos are so slow though :-(
21:28:41 <fantasma> plus they have to stay under 400 lines of code
21:28:46 <robreim> dons, ok, thanks.
21:29:06 <SamB_XP_> fantasma: ... there is no shame in being under *500* lines
21:29:13 <fantasma> I say you make xmonad a one-liner
21:29:21 <dons> i liked it when xmonad was 90 lines
21:29:22 <jcreigh> ya'know, it's funny: We can say under 400 LoC and nobody actually checks the numbers. :)
21:29:24 <dons> then we added features
21:29:28 <sorear> SamB_XP_: cite your sources for anything that contentious, I think you just said the compilers equivalent of "Vim is better than emacs"
21:29:47 <SamB_XP_> sorear: they are slow compared to loops!
21:29:56 <dons> they are?
21:30:01 <jcreigh> SamB_XP_: what? I don't understand. What arch are you talking about?
21:30:10 <SamB_XP_> jcreigh: it isn't the architecture!
21:30:14 <dons> SamB_XP_: how do you think loops are implemented? ;-)
21:30:18 <SamB_XP_> it is the confusion of the compiler!
21:30:21 <fantasma> it's phsycological
21:30:21 <dons> its all jmp lbl in the end.
21:30:35 <dons> at worst, jmp *reg
21:30:38 <jcreigh> SamB_XP_: okay, I'm thinking about JMP instructions...what are you thinking about?
21:30:41 <SamB_XP_> sure, if the code is already totally optimized...
21:30:54 <dons> what do you mean? like, umm, compiled to asm :-)
21:30:57 <SamB_XP_> then its fine to use a goto
21:31:33 <SamB_XP_> but the C compiler is more likely to be able to do something with a loop
21:32:15 <sorear> dons:
21:32:19 <sorear> stefan@stefans:~$ cat /usr/local/src/*/_darcs/prefs/defaultrepo  | grep http | cut -c 8- | sed 's/\/.*//' | sort | uniq -c | sort -n | cut -c 5- | pr -5 -t -w128
21:32:19 <sorear>   1 happs.org              1 shim.haskellco.de      1 www.repetae.net        3 www.n-heptane.com     11 www.cs.york.ac.uk
21:32:19 <sorear>   1 haskell.org            1 www.abridgegame.org    1 www.scannedinavian.c   8 www.cse.unsw.edu.au   19 darcs.haskell.org
21:32:19 <sorear>   1 repetae.net            1 www.elis.ugent.be      1 www.stefanwehr.de
21:32:23 <jcreigh> SamB_XP_: oh, you're talking C. Yeah, sure, I could see that. But GCC is pretty darn smart. (For example, gcc turns naive recursive factorial into a loop)
21:32:43 <SamB_XP_> jcreigh: ask JohnMeacham ;-)
21:32:48 <sorear> SamB_XP_: I suppose you've never heard of basic blocks?
21:32:58 <dons> sorear: hehe
21:33:06 <SamB_XP_> ask JohnMeacham !
21:33:11 <dons> so most things are on haskell.org. god help us when i leave cse.unsw.edu.au
21:33:28 <SamB_XP_> dons: noooooo you can't leave!
21:33:29 <dons> nd the york guys are overly active :-)
21:33:42 <SamB_XP_> you had better set up a mirror well in advance
21:33:47 <igli> heh finally someone's talking at object-code level. (huge sigh of relief)
21:33:53 <dons> yeah, im' not sure how to do the transition.
21:34:11 <sorear> n-heptane is stepcut, fwiw
21:34:23 <igli> reliable mirror first, then http redirect with explanation, then dns redirect
21:34:23 <SamB_XP_> darcs messages and HTTP redirects?
21:34:44 <SamB_XP_> igli: the darcs repos would have to simply have a message put in them
21:34:53 <dons> yeah, you can do that though.
21:34:57 <igli> ok, don't know darcs
21:35:03 <dons> "This is an old repo. Please use ...."
21:35:05 <SamB_XP_> libcurl can't handle redirects unfortunately :-(
21:35:11 <igli> know of it of course :)
21:35:21 <dons> SamB_XP_: really??
21:35:32 <SamB_XP_> dons: why else would darcs have trouble?
21:35:47 <igli> heh you should add it, it can't be much to do.
21:36:09 <SamB_XP_> ... it is probably managed under CVS!
21:36:17 <igli> you get the status code with the new URL
21:36:37 <SamB_XP_> or do you mean to darcs?
21:39:23 <jargonjustin> After hearing about Pugs and reading through the "Write Yourself a Scheme in 48 hours" tutorial, I'm curious as to how an interpreter with mutable data would be implemented in Haskell.
21:40:05 <dcoutts> jargonjustin: using a monad of some kind
21:40:33 <dcoutts> eg you can have mutable arrays in the IO and ST monads
21:40:55 <dcoutts> often you don't really need mutable structures though, persistent ones + GC will do just fine
21:41:14 <qeb`away> the 6000th number in the fibonacci row is disturbingly huge :|
21:41:28 <dmead> :|
21:41:33 <qeb`away> so, are there any limits on how big an int can be in haskell, or just limited by memory?
21:41:41 <Heffalump> does GHC optimise single-threaded persistent structures?
21:41:42 <Philippa> there're limits on an Int, but not on an Integer
21:41:48 <qeb`away> ah, okay
21:41:52 <dcoutts> jargonjustin: or just using tail recursive functions and passing parameters can get you constant space use
21:41:59 <Heffalump> qeb`away: the standard requires they be at least 29 bits
21:42:02 <jcreigh> qeb`away: Int is going to be about 32 bits, Integer is unlimited.
21:42:03 <dcoutts> Heffalump: not if they're boxed
21:42:12 <qeb`away> okay, thanks
21:42:16 <Heffalump> in GHC it'll be the machine word size (I think)
21:42:53 <jargonjustin> dcoutts: Thanks, I understood using the ST or IORef monad for a mutable environment, but transforming it with mutable arrays would seem to work.
21:43:07 * jargonjustin wanders off read and ponder
21:43:40 <Cale> fib 6000 should be about 1.3KB.
21:44:03 <qeb`away> yes :|
21:44:08 <qeb`away> that seems about right
21:44:24 <qeb`away> okay
21:44:32 <qeb`away> did I do anything wrong here:
21:44:40 <qeb`away> *Main> fib 20
21:44:40 <qeb`away> 10946
21:44:43 <qeb`away> that this is slower than:
21:44:48 <qeb`away> *Main> fib 10^10
21:44:48 <qeb`away> 31181719929966183601
21:44:52 <qeb`away> ?
21:44:59 <Heffalump> fib 10^10 = (fib 10)^10
21:45:00 <dmead> thats strange
21:45:02 <Heffalump> not fib (10^10)
21:45:06 <qeb`away> oh :o
21:45:16 <dmead> :o
21:45:27 <Cale> But fib 20 being slow indicates that you're implementing it the slow way.
21:45:32 <qeb`away> yeah
21:45:36 <dibblego> The Slow Way
21:45:37 <qeb`away> I did the very standard recursive one
21:45:49 <dmead> the list comprehension?
21:45:59 <qeb`away> if n < 2 then 1, else fib (n-1) + fib(n-2)
21:46:02 <Cale> dmead: the doubly recursive way
21:46:07 <qeb`away> yeah
21:46:09 <dmead> ah
21:46:20 <qeb`away> list comprehension is nice :))
21:46:28 <dmead> yeaaa
21:46:30 <dmead> i never use them
21:46:31 <dmead> hehe
21:46:37 <Cale> > fix ((0:) . scanl (+) 1)
21:46:39 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
21:46:40 <qeb`away> I use them a lot in python
21:47:12 <Cale> > fix ((0:) . scanl (+) 1) !! 6000
21:47:14 <lambdabot>  3770131493877999453339002248807757912361173379301004455354900435250458435396...
21:47:44 <qeb`away> okay :|
21:47:49 <qeb`away> that's pretty impressive
21:47:51 <dmead> are they exactly the same as in haskell?
21:48:02 <int-e> fib (10^10) will take a while, even with a good implementation.
21:48:03 <araujo> hello!
21:48:03 <qeb`away> I'm not sure, didn't get that far in haskell yet
21:48:07 <dmead> ah
21:48:07 <Heffalump> > length $ show $ fix ((0:) . scanl (+) 1) !! 6000
21:48:08 <dmead> k
21:48:09 <lambdabot>  1254
21:48:46 <goltrpoat> dmead:  what, python comprehensions?  they're similar, not exactly the same though
21:48:57 <dmead> ah
21:48:58 <dmead> kk
21:49:35 <qeb`away> fizzbuzz can be f. ex. ['Fizz'*(i%3<1)+'Buzz'*(i%5<1) or i for i in range(1,101)] and you do things like map(lambda etc,sequence) and reduce(lambda etc, sequence)
21:49:52 <goltrpoat> similar enough to where you can talk about 'generators' and 'predicates' in both, though.  the differences are superficial, other than the different evaluation strategy.
21:49:58 <sorear> int-e: fib(10^9) takes about 15s on my computer... do you consider that a while?
21:50:19 <Heffalump> sorear: using exponentiation?
21:50:28 <sorear> Heffalump: no, an exact method
21:50:31 <dmead> ah yea...
21:50:36 <Heffalump> I meant matrix exponentiation
21:50:37 <dmead> i tried python for about 4 hours
21:50:40 <Heffalump> not the sqrt 5 trick
21:50:41 <dmead> i found it undesireable
21:50:42 <dmead> :s
21:50:56 <sorear> Heffalump: the legendary Gosper/Salamin, HAKMEM #14
21:50:57 <qeb`away> python is very good as a beginners language and for learning OOP
21:50:59 <int-e> sorear: for 10^10 you can expect to take it more than 10 times as long.
21:51:19 <sorear> int-e: only slightly more - fib is O(n log n log log n)
21:51:37 <int-e> sorear: ring operations. but multiplying such big numbers takes a while.
21:51:45 <int-e> sorear: oh wait
21:51:46 <int-e> sorear: nm
21:51:59 <int-e> sorear: missed the n factor, sorry.
21:52:10 <Heffalump> sorear: that is matrix exponentiation (having googled)
21:52:34 <sorear> Heffalump: close to it...
21:52:55 <sorear> it uses a constant factor less operations iirc
21:53:04 <sorear> ShoernageStrassen++
21:53:09 <Heffalump> oh, ok. I think I may have misread something.
21:53:45 <inverselimit> I found python to be a good gateway drug to functional style
21:53:51 <dmead> is there something quick you can do to find the successor of a char?
21:53:56 <sorear> succ
21:53:58 <sorear> > succ 'a'
21:53:59 <lambdabot>  'b'
21:54:03 <dmead> awesome
21:54:04 <sorear> overloading :)
21:54:06 <int-e> sorear: and you may get into memory trouble with 10^10.
21:55:41 <goltrpoat> what was that about matrix exponentiation, anyway?
21:56:17 <int-e> goltrpoat: you can find fibonacci numbers by exponentiating the matrix [[0,1],[1,1]]
21:56:45 <goltrpoat> oh, that's pretty.  thanks
21:56:54 <goltrpoat> didn't realize that.
21:57:34 <Heffalump> someone once asked me about fib in an interview and looked quite surprised when I first trotted through the solutions he was expecting (doubly recursive, then tupled) then explained the exponentiation solution and launched into a discussion of its time complexity
21:57:51 <Heffalump> since he hadn't seen it before
21:57:54 <goltrpoat> hah
21:58:07 <monochrom> Why are interviewers so incompetent?
21:58:31 <Stinger> exponentiation solution?
21:58:40 <int-e> why do you conclude that the interviewer was incompetent from that?
22:00:32 <monochrom> I know now. Because someone says "hah".
22:00:58 <goltrpoat> int-e:  because incompetent interviewers are a matter of lore, and everyone has at least three stories to support that point of view? :)
22:01:23 <monochrom> Interviewees are also incompetent.
22:02:04 <goltrpoat> right, so then everyone who's ever interviewed anyone has a stack of stories about the idiots they've interviewed.
22:02:37 <inverselimit> I find most people, when slightly outside their specialty, incompetent.  Myself included
22:03:54 <goltrpoat> i recently realized that most people are much smarter than i am.  so now i just nod and smile.  hopefully that'll help convey a modicum of intelligence on my part.
22:04:06 <sorear> muahahaha!
22:04:17 <monochrom> sorear has a new story.
22:04:38 <sorear> not this time, I was just responding to goltrpoat
22:06:37 <sorear> How slow is atomicModifyIORef?
22:06:57 <sorear> does it use RCU or similar to only cost one comparison?
22:07:24 <sorear> (which would probably be trivial compared to the costs of intergenerational pointer updates)
22:09:22 <sorear> ooh, nice *sarcasm*
22:09:23 <goltrpoat> it'd be fairly hard to make it noticeably slow in the usual usage case, no?
22:09:25 <sorear> #if defined(THREADED_RTS)
22:09:25 <sorear>     foreign "C" ACQUIRE_LOCK(atomic_modify_mutvar_mutex "ptr") [R1,R2];
22:09:25 <sorear> #endif
22:09:38 <sorear> yup, ONE LOCK for all iorefs
22:10:00 <goltrpoat> oh heh.
22:10:03 <sorear> that's in rts/PrimOps.cmm, btw.
22:10:28 <sorear> how hard can it be to implement rcu? :P
22:10:37 <goltrpoat> well, the haddock does seem to basically say, "don't do this, use MVars"
22:11:08 <sjanssen> sorear: oh god, that's horrendous
22:13:07 <goltrpoat> i don't know if rcu is a one size fits all type deal, but then the mechanism isn't meant as one size fits all.  dunno.
22:13:58 <sorear> rcu is far from one size fits all.  it only works when you are only modifying one variable at a time.  it only works when your modification function is pure.
22:14:05 <sorear> both conditions are met here
22:14:29 <sorear> I really ought to work up the confidence to be a ghc hacker
22:14:38 <Heffalump> just do it
22:14:48 <goltrpoat> i think you can reduce it to 'it only works when your modification function is pure'
22:14:54 <sorear> I know how to implement inline cmm... rcu as a library!
22:20:17 <sorear> worse, it appears that atomicModifyIORef *necessarily* creates thunks
22:21:20 <sjanssen> so why would anyone use IORef over MVar?
22:21:43 <sorear> this variable is expected to be pretty well hammered...
22:21:55 <sorear> it only stores the entire state of lambdabot7
22:22:15 <sorear> IORef (Map ByteString (TVar ByteString))
22:22:27 <sorear> the outer ioref is so we can add new tvars on reference
22:23:10 <goltrpoat> i think it was only ever intended to be a lightweight interface
22:24:24 <goltrpoat> eg, if you have one problem, and you want to split it up between 10 instances of an algorithm, instead of a single one, then atomicModifyIORef is the way to go
22:24:29 <sjanssen> 'on reference'?
22:24:32 <goltrpoat> anything more complicated, and it gets silly
22:24:57 <sorear> sjanssen: yes.  creation on first use
22:25:15 <sorear> I have a lazy mindset even in deep IO code
22:25:20 <sjanssen> sure
22:25:44 * sorear decides to punt and go with TVar (Map ByteString ByteString), and profile later
22:25:51 <sjanssen> why not TVar (Map ByteString (TVar ByteString))?  lambdabot shouldn't need to handle more than a couple requests per second
22:26:20 <sorear> some requests generate a lot of activity ... @seen
22:26:49 <sjanssen> sorear: an extra indirection of TVar will allow transactions to succeed more often
22:27:05 <LeCamarade> sjanssen: Is it safe to say that? LB could get some currently-unknown utility that requires many-requests processing.
22:27:28 <sorear> LeCamarade: @rc isn't used very often
22:27:49 <sorear> night #haskell.
22:27:49 <sjanssen> LeCamarade: sure, it could happen.  But you know what they say about premature optimization
22:27:58 <sjanssen> goodnight
22:28:30 <LeCamarade> sorear: For the moment, no. Is there a case where one module could depend on it, and then that module is over-used?
22:28:54 <LeCamarade> sjanssen: Sure. I hate premature optimisation. It's why I don't do C. :oD
22:29:07 <sorear> huh?  anyway, my parents just noticed I'm still awake.
22:38:27 <dibblego> ?src repeat
22:38:28 <lambdabot> repeat x = xs where xs = x : xs
22:39:58 <dibblego> ?src take
22:39:59 <lambdabot> take n _      | n <= 0 =  []
22:39:59 <lambdabot> take _ []              =  []
22:39:59 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
22:40:35 <HairyDude> > take 0 "wibble"
22:40:37 <lambdabot>  ""
22:41:07 <HairyDude> ah, no pattern match error or infinite regress then
22:41:14 <igli> wow that looks exactly like ML
22:41:40 <bos> there's not nearly enough "let" sprinkled around for it to resemble ML.
22:41:46 <igli> heh
22:43:05 <HairyDude> > take (-1) "wibble"
22:43:07 <lambdabot>  ""
22:47:30 <LeCamarade> putStrLn "Libert"
22:47:36 <LeCamarade> > putStrLn "Libert"
22:47:37 <lambdabot>      lexical error in string/character literal (UTF-8 decoding error)
22:48:23 <LeCamarade> Merde. Ce lambdabot-ci est trs Australien! Pas juste!
22:49:50 <igli> oui. c'est vrai.
22:50:21 <igli> Mais Australien? Sais pas, peut-etre Anglophile?
22:50:43 <LeCamarade> igli: Mais nous devons tre en #haskell-fr, donc nous n'avons pas le droit de se plaindre.
22:50:51 <igli> lol
22:51:27 <igli> Si, on a toujours le droit de se plaindre. C'est l'informatique, n'est-ce pas?
22:51:28 <LeCamarade> igli: Tout les gurus ici sont Australiens. galement lambdabot.
22:51:35 <igli> Ah.
22:52:00 <igli> ;)
22:52:53 <LeCamarade> igli: Non. Lnformatique est Amricaine. Nous n'avons pas le droit. Peut-tre en #haskell-fr, mais ceci est presque vide tout le temps.
22:53:52 <igli> Alors, qu'est-ce qu'on va faire?  Lnformatique c'est  Anglophile, ai-je dit, pas Anglais.
22:54:26 <igli> Mais c'est quoi, l'i18n?
22:55:26 <igli> heh and the ROTW?
22:55:29 <LeCamarade> Au moins nous avons Ocaml. Les Japonais ont Ruby. Les Anglophones ont presque tout  cot. Nous sommes vaincu. C'est fini. i18n = internationalization/internationalisation.
22:56:14 <LeCamarade> Les caractres entre `i et `n sont 18. Voil i18n.
22:56:18 <igli> Oui, je le sais, mais nous ne sommes jamais vaincu, si nous parlons en Francais, n'est-ce pas?
22:56:38 <igli> jamais vaincus?
22:57:15 * igli is using a UK keyboard ;)
22:57:34 <LeCamarade> Nous sommes vaincu. Pouvez-vous crire "Salut, Monde!" en franais?
22:57:48 <igli> Oui, bien sur.
22:57:54 * LeCamarade can help him write accents with a UK keyboard.
22:58:09 <igli> ty would be obliged :)
22:58:19 * LeCamarade is using a US keyboard - utterly un-aware of the rest of the world.
22:58:24 <igli> lmao
22:58:38 <igli> Vous-etes Canadien?
22:58:45 <LeCamarade> igli: Alors, q'elle systme d'exploitation?
22:58:50 <igli> Vous etes Canadien, pardonnez?
22:58:57 <LeCamarade> igli: Moi? Canadien? Non!
22:59:02 <igli> rotfl
22:59:18 <arcatan> APL!
23:00:20 <LeCamarade> igli: Et je ne suis pas mme Europen.
23:00:32 <igli> C'est une systeme que j'ecrit a ce moment-ci, LeCamarade. C'est pas complet, mais la langue, c'est la.
23:00:45 <igli> D'accord; d'ou?
23:01:12 <LeCamarade> igli: Alors, Unix, n'est-ce pas? Pouvons-nous aller  #haskell-fr?
23:01:28 <igli> D'accord, moment, s'il vous plait.
23:01:36 * LeCamarade est all  #haskell-fr
23:03:39 <user317> how do i get a stacktrace out of an exception?  i tried running: ./Main +RTS -xc -RTS; but all i get is: <GHC.List.CAF>Main: Prelude.head: empty list, i know that the head in question is not in Main
23:57:59 <LeCamarade> Haskell gems (gleaned from many sources): Are you ready? Mainly for n00bs, this one.
23:58:41 <LeCamarade> 1. For every time you use the IO monad outside main, your quality score goes down by 50%.
23:58:57 <mrchebas_> @hoogle (a->Bool) -> [a] -> [[a]]
23:58:58 <lambdabot> No matches, try a more general search
23:59:42 <LeCamarade> 2. Dont work with data that isn't yet generated. A function for each part. One to collect the data, another to process it.
