00:00:55 <Korollary> I like my kaiser rolls sans cole slaw
00:01:03 <lokadin> Sometimes I find chat bots more talkative and entertaining than people
00:01:18 <Korollary> That only means that you're talking to the wrong people
00:02:04 <lokadin> I guess you're right
00:02:53 * lokadin grumbles over low cognitive population density
00:03:11 <LeCamarade> ?quote monad
00:03:12 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
00:03:42 <LeCamarade> @quote peyton
00:03:42 <lambdabot> syntaxfree says: Many people think the core ideas behind Haskell came from academic luminaries such as Philip Wadler and Simon Peyton-Jones. What actually happened is that during a functional
00:03:43 <lambdabot> programming conference, some key academics were teleported to the Deep Complex Universe. In the Deep Complex Universe some Gnomes were having Tangling problems. Wadler & friends solved their
00:03:43 <lambdabot> problems and as a reward the Tangled Gnomes gave them the S
00:04:13 <LeCamarade> @quote water
00:04:14 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
00:04:29 <LeCamarade> @quote c
00:04:29 <lambdabot> metaperl says:   Haskell people are forever focused on correctness as opposed to deliverables... perfectionism taken to mal-productive levels
00:04:46 <LeCamarade> @quote c++
00:04:47 <lambdabot> JaffaCake says: gcc is getting smarter, so we need to hit it with a bigger stick
00:04:59 <LeCamarade> @quote unsw
00:05:00 <lambdabot> No quotes match. Wrong!  You cheating scum!
00:05:15 * LeCamarade is really, really lovin
00:05:23 <boegel> @quote boegel
00:05:24 <lambdabot> boegel says: goes to inflate Itkovians balls
00:05:26 <boegel> @quote boegel
00:05:27 <lambdabot> boegel says: goes to inflate Itkovians balls
00:05:28 <LeCamarade> dis. Maybe he should go to #haskell-blah?
00:05:33 <boegel> I did say other things
00:05:47 <lokadin> :)
00:06:04 <LeCamarade> @quote machine
00:06:05 <lambdabot> procyon_ says: Emacs built a time machine once and went back in time to stop the JFK assassination. As Oswald shot, Emacs met all three bullets with M-x bullet-mode-hook, deflecting them. JFK's head
00:06:05 <lambdabot> exploded out of sheer amazement.
00:06:21 <Korollary> that's a good one.
00:06:23 <LeCamarade> @quote vi
00:06:24 <lambdabot> sebazzz says: la vez que salimos, que vino erg0t de bsas, nos metimos en un ciber para contactarnos con tizoc, y erg0t no sabia manejar windows xp ...
00:06:35 <boegel> LeCamarade: haha!
00:06:58 <dolio> @quote qwe1234
00:06:58 * LeCamarade thinks it's unfair! Emacs praise on #haskell? And none for the Greatest Achievement in Editing?
00:06:59 <lambdabot> qwe1234 says: i can program in assembly as well as i can program in c++
00:07:05 <LeCamarade> @quote vim -- Please ...
00:07:06 <lambdabot> No quotes for this person. I've seen penguins that can type better than that.
00:07:40 <LeCamarade> @quote editor
00:07:41 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
00:07:57 <LeCamarade> @help remember
00:07:58 <lambdabot> quote <nick>
00:07:58 <lambdabot> remember <nick> <quote>
00:07:58 <lambdabot> Quote somebody, a random person, or save a memorable quote
00:08:01 <lokadin> vim is a complete monolithic interface for keyboard gurus
00:08:26 <LeCamarade> @remember lokadin  vim is a complete monolithic interface for keyboard gurus
00:08:27 <lambdabot> Done.
00:08:42 <lokadin> :) yay!
00:08:52 * lokadin hugs LeCamarade 
00:08:52 <boegel> @karma lokadin
00:08:53 <lambdabot> lokadin has a karma of 0
00:08:58 <boegel> @karma boegel
00:08:58 <lambdabot> You have a karma of 3
00:09:02 <boegel> w00!
00:09:05 <LeCamarade> Vi is to editing what Haskell is to hacking. And Emacs is like the C++ of editing.
00:09:31 <lokadin> @remember LeCamarade  Vi is to editing what Haskell is to hacking. And Emacs is like the C++ of editing.
00:09:31 <lambdabot> Done.
00:09:43 <LeCamarade> :oD
00:09:48 <boegel> vi sucks
00:09:55 <dolio> Isn't Emacs like the Emacs Lisp of editing?
00:09:59 * boegel wonders is he will get quoted too :P
00:10:32 <LeCamarade> boegel: At the risk of being sent to #haskell-blah, that statement, of vi == Haskell, is true.
00:11:14 <LeCamarade> dolio: Emacs Lisp is functional (i.e., good). Emacs is not, in any way, like Emacs Lisp. EOT
00:12:03 <dolio> Yeah, but I've heard that as lisps go, elisp isn't exactly top notch.
00:12:10 <dolio> I haven't done much with it, though.
00:12:31 <lokadin> what does EOT mean?
00:13:04 * lokadin wonders if he should feel embarrassed and goes to check in the dictionary
00:13:10 <lucca> end of transmission
00:13:12 <LeCamarade> dolio: Not top-notch, but Emacs is below bottom-notch. I haven't touched Elisp, either. I'll stick to Clisp. End Of Text. ;oD
00:13:22 <lucca> or thereabouts
00:13:51 <lokadin> I think both are right! :)
00:13:54 <LeCamarade> lucca: End Of Transmission. And many other things that ... and $ zipWith (==) "End Of T"
00:14:08 <Adamant> Vi is worse than Visual Studio.
00:14:45 <lokadin> To my understanding they are nothing alike
00:14:52 <LeCamarade> > let isEOT x = and $ zipWith (==) "End Of T" x in isEOT "End Of Transmission"
00:14:54 <lambdabot>  True
00:15:00 <LeCamarade> > let isEOT x = and $ zipWith (==) "End Of T" x in isEOT "End Of Text"
00:15:01 <lambdabot>  True
00:15:22 <Adamant> lokadin, they are both alike in that they must bow down to Emacs
00:15:34 <LeCamarade> Adamant: Visual Studio is MS' idea of Emacs.
00:15:48 <Adamant> on a more serious note, anyone try Haskell with Textmate?
00:16:12 <Adamant> LeCamarade, Vi is a 70's BSD hacker's idea of Visual Studio
00:16:16 <LeCamarade> @go textmate
00:16:19 <lambdabot> http://macromates.com/
00:16:20 <lambdabot> Title: TextMate â€” The Missing Editor for Mac OS X
00:16:26 <LeCamarade> Adamant: :oD
00:16:48 <LeCamarade> > take 2 "Visual Studio"
00:16:50 <lambdabot>  "Vi"
00:17:20 <Adamant> see!
00:17:39 <Adamant> you can't spell "Visual Studio" without vi
00:18:05 * LeCamarade is hacking one for Emacs ...
00:18:16 <dolio> > sum . map ((subtract $ ord 'a') . ord) $ "algore"
00:18:17 <lambdabot>  52
00:18:24 <dolio> > sum . map ((subtract $ ord 'a') . ord) $ "williamgates"
00:18:26 <lambdabot>  119
00:18:31 <Adamant> I might be getting a Mac, so I want to try Textmate.
00:19:03 <Adamant> an updated Emacs would be nice.
00:19:50 <lucca> Adamant: it's fairly trivial to build a good graphical emacs
00:20:01 * dolio was considering giving emacs+haskell-mode another try earlier tonight.
00:20:56 <Adamant> Haskell is indeed supported.
00:21:32 <LeCamarade> > (\(x:_:y:_:_:z:x') -> 'E':x:'a':y:z:[]) "Microsoft Emacs-usual Studio"
00:21:34 <lambdabot>  "EMacs"
00:21:46 <dolio> Yeah, I used it a couple years back, but at some point, I figured I should learn vi to see what it was like, and haven't gotten around to going back at all.
00:22:14 <Adamant> ah. well, whatever your feelings on Vi, if you use Unix you should learn it.
00:22:24 <LeCamarade> Adamant: Well-said.
00:22:29 <dolio> Since it's a pain to switch once your fingers have become accustomed to the keys.
00:22:40 <Adamant> but let us not forget Ed is the Standard Editor
00:22:45 <LeCamarade> dolio: Well-said.
00:23:27 <LeCamarade> > take 2 . last . words $ "Standard Editor"
00:23:29 <lambdabot>  "Ed"
00:24:08 <nornagon> > const 'vi' $ "emacs"
00:24:09 <lambdabot>  Improperly terminated character constant
00:24:15 <dolio> > (3 +) . sum . map (ord . toUpper) . filter isAlpha $ "Bill Gates"
00:24:16 <nornagon> oops.
00:24:16 <lambdabot>  666
00:24:18 <LeCamarade> The Official Glorious Haskell Take on Contentious Subjects, Release 1.0:
00:24:23 <nornagon> > const "vi" $ "emacs"
00:24:24 <dolio> There we are. It actually uses ascii.
00:24:25 <lambdabot>  "vi"
00:24:26 <LeCamarade> > take 2 "Visual Studio"
00:24:28 <lambdabot>  "Vi"
00:24:29 <LeCamarade> > take 2 . last . words $ "Standard Editor"
00:24:31 <lambdabot>  "Ed"
00:24:35 <LeCamarade> > (\(x:_:y:_:_:z:x') -> 'E':x:'a':y:z:[]) "Microsoft Emacs-usual Studio"
00:24:36 <lambdabot>  "EMacs"
00:26:25 <LeCamarade> > [take 2 "Visual Studio", (\(x:_:y:_:_:z:x') -> 'E':x:'a':y:z:[]) "Microsoft Emacs-usual Studio", take 2 . last . words $ "Standard Editor"]
00:26:26 <lambdabot>  ["Vi","EMacs","Ed"]
00:27:31 <nornagon> GENIUS
00:27:58 <Adamant> *applause*
00:28:01 <lucca> http://www.accela.net/~lucca/image/curves.jpg
00:28:32 <nornagon> hehe
00:29:34 <dolio> I didn't realize there was that much to learn about pico.
00:30:50 <Adamant> is pico free/open now?
00:30:52 <LeCamarade> Emacs' curve is correct.
00:31:10 <LeCamarade> By the time you're done learning C+K, someone re-binds it.
00:31:56 <LeCamarade> editor rants > #haskell-blah
00:32:21 <LeCamarade> Adamant: nano is the free replacement for pico.
00:32:29 <LeCamarade> @go nano editor
00:32:31 <lambdabot> http://www.gentoo.org/doc/en/nano-basics-guide.xml
00:32:31 <lambdabot> Title: Gentoo Linux Documentation -- Nano Basics Guide
00:32:38 <Adamant> I know nano
00:32:46 <opqdonut> bah nano is too simplistic for a programming editor
00:33:08 <Adamant> yeah, but it's good for editing config files.
00:33:20 <LeCamarade> Adamant: That is the free pico.
00:33:31 <opqdonut> i use ed when i don't want to start emacs
00:33:59 <Adamant> LeCamarade, I was wondering if they changed the license
00:34:43 <LeCamarade> Adamant: Try editing .ghci with it... :oD The licence is probably still the same. Anyway, it took GNU a short time to replace it, so it ceased to matter. And nano is better, I think/
00:36:54 <LeCamarade> From my .ghci:
00:36:57 <LeCamarade> let (cmd) % args = System.Cmd.system $ concat [cmd, " ", args]
00:37:06 <LeCamarade> So that I can say:
00:37:26 <LeCamarade> "echo" % "we made it"
00:37:43 <LeCamarade> "vi" % "test.hs"
00:37:49 <LeCamarade> And then just reload it.
01:39:13 <rubyruy> q: this fabled parallel-out-of-the-box aspect of functional programming... i assumed there's some sort of magic switch i can throw on that can make a haskell program take advantage of parallel processing (like erlang) - but it seems that it actually has to be done explicitly, by spawning threads, talking to mutexes, semaphores and all that junk - same junk i have to deal with in ruby. is this correct?
01:40:00 <rubyruy> (i know it's harder to shoot yourself in the foot using FP - but do i still have to make things explicitly parallel ? )
01:50:22 <quicksilver> rubyruy: yes, I think so. Implicit parallelism is quite hard to get right
01:50:28 <quicksilver> rubyruy: you dont' have to do forks and mutexs though
01:50:43 <quicksilver> rubyruy: you can just use `par` and the constructs built on it (parMap)
01:50:43 <rubyruy> what's the overhead for it roughly?
01:51:22 <quicksilver> the overhead of the lightweight threads the runtime uses is fairly good
01:51:25 <rubyruy> oh so parmap is a parallel map?
01:51:29 * quicksilver nods
01:51:36 <rubyruy> i can use it more-or-less like a normal map?
01:52:19 <rubyruy> also - besides concurrency - can haskell also be easily distributed to run on separate machines?
01:52:24 <Lemmih> There's also NDP.
01:54:22 <Syzygy-> quicksilver: What do I need to have installed to use par?
01:54:59 <Syzygy-> And connected to that - can haskell handle massive parallellisation along the lines of a x-node cluster and the likes?
01:55:35 <quicksilver> Syzygy-: par is standard is recent ghcs
01:55:45 <quicksilver> I don't know about distributed parallelism though
01:56:44 <tuxplorer> I get an error "Setup.hs: cannot satisfy dependency binary-any" in configure step, when trying to install HAppS
01:56:55 <tuxplorer> what package is binary-any?
01:57:11 <eumenides> Data.Binary?
01:58:06 <tuxplorer> can someone get me a link to the source of the package referred to by the word "binary-any" ?
01:58:43 <eumenides> tuxplorer: http://hackage.haskell.org/packages/archive/pkg-list.html
01:59:52 <tuxplorer> eumenides: Thanks
02:00:08 <Cheery> How do I write a separate scanner with Parsec?
02:04:51 <tuxplorer> eumenides: It again asks for HList-any now.. but there is only a dlist in that package list page..
02:05:29 <Cheery> ie. how would I get something like this out from Parsec? [Char] -> ([(SourcePos,Tok)],[String])
02:06:11 <eumenides> tuxplorer: darcs get http://darcs.haskell.org/HList/
02:06:13 <lambdabot> Title: Index of /HList
02:06:38 <Cheery> hmm, maybe... I guess I found it out
02:07:14 <tuxplorer> eumenides: isn't there a good package management method in haskell? like gem in ruby?
02:08:25 <rubyruy> iirc gem => cabal
02:09:31 <eumenides> tuxplorer: finding these is pretty easy. google "haskell + #{packagename}"
02:11:12 <tuxplorer> eumenides, yup.. I was able to find for HList(just after posting here) but not for network, binary etc.. which showed up some other stuff.. Its painful and time consuming to get 100 packages individually and compile to just install one HAppS. it would be nice if all these packages are available as binary..
02:13:21 <matthew-_> tuxplorer: there seems to be a push to get libraries onto hackage.
02:13:29 <eumenides> tuxplorer: it's not awfully friendly, no. i'm still not sure why arrows-0.2 won't build
02:13:55 <tuxplorer> is that an issue with the cabalizing system?
02:35:58 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1543
02:36:52 <chrismbrown> morning all
02:37:12 <LeCamarade> chrismbrown: Mornin'.
02:41:58 <TomMD> Is there a quick and easy way to see how many bytes a Data.Binary.Get routine parsed without counting them at every interaction?
02:42:21 <TomMD> I suppose I could use 'remaining' but... yuck
02:44:02 <TomMD> I am guessing bytesRead is O(1) and thus suitable for this task.
02:52:28 <dblhelix> niksnut: arthur b. vraagt of je nog naar utrecht komt?
02:53:53 <LeCamarade> @seen dblhelix
02:53:53 <lambdabot> dblhelix is in #oasis, #haskell.dut, #haskell-blah and #haskell. I last heard dblhelix speak 1m 25s ago.
03:00:22 <LeCamarade> System.FilePath.pathSeparator _should_ be a string. Some platforms use strings to separate.
03:00:27 <LeCamarade> Not just chars.
03:01:12 <LeCamarade> @where filepath
03:01:13 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/filepath/
03:02:45 <LeCamarade> @tell ndm I think System.FilePath.pathSeparator should be a string, since some platforms use more than one char to separate. And that wouldn't pause any probs, since a path is going to end up as a string, anyway. My two cents. (The French say `Mes deux centimes'.)
03:02:46 <lambdabot> Consider it noted.
03:04:43 <quicksilver> surely it should me 'Mes deux Eurocent'
03:04:45 <quicksilver> s
03:05:15 <earthy> nope
03:05:22 <mux> expect we never say that :-P
03:05:25 <LeCamarade> quicksilver: You trying to spite us for selling out?
03:05:27 <mux> one way or the other
03:05:30 <LeCamarade> :oD
03:05:38 <earthy> as 'centime' is very much 'one-hundredth'
03:05:50 <mauke_> my 2%
03:11:40 <DRMacIver> Hm. Does Template Haskell allow more than one stage of code generation? e.g. can I use template haskell to generate template haskell?
03:14:45 <int-e> put the other stage in a different module.
03:15:06 <DRMacIver> Hm. How do you mean?
03:15:32 <DRMacIver> (I mean, why does that make a difference?)
03:16:36 <matthew-_> DRMacIver: due to limitations of TH.
03:17:02 <DRMacIver> ok
03:17:10 <matthew-_> but yes, you can nest levels of splicing etc
03:17:39 <matthew-_> there's even an example at the bottom of http://www.haskell.org/hawiki/TemplateHaskellTutorial which does nesting.
03:17:40 <lambdabot> Title: TemplateHaskellTutorial - The Haskell Wiki
03:18:54 <DRMacIver> ok
03:18:56 <DRMacIver> Thanks
03:48:23 <Neil|Work> I have a couple of questions
03:48:52 <Neil|Work> 1) Is anyone here using Haskell commercially?  I'm quite interested in knowing what sort of applications people are finding for it outside the realm of academia
03:49:41 <earthy> hm. not me.
03:49:56 <quicksilver> Neil|Work: it's used in credit suisse for financial modelling, I believe
03:50:12 <DRMacIver> Linspire are using it for their tools set.
03:50:21 <Neil|Work> ah yes, I did read about Linspire
03:50:24 <matthew-_> there was mention on the last HWN about a commercial CMS written in Haskell with WASH
03:50:25 <earthy> yeah, and Joel Reymont (IIRC) is using it in online gambling stuff
03:50:33 <DRMacIver> I think there have been a few commercial web apps made with HApps, but I don't know how well they did.
03:50:41 <DRMacIver> (Or who they are)
03:50:49 <pejo> Neil, http://cufp.galois.com/
03:50:51 <lambdabot> Title: Commercial Users of Functional Programming
03:51:02 <Neil|Work> pejo :: aha, that's perfect
03:51:03 <Neil|Work> thanks :)
03:52:01 <Neil|Work> I was looking into it but functional languages only seem to be used in universities, odd posix applications and the occasional maths-heavy software firm
03:52:15 <Neil|Work> I know that's a bit naive, but there doesn't seem to be a lot else on the net
03:52:32 <Neil|Work> ok then... and 2) I think I've got my head around most of the theory of the language (up to a rough understanding of monads), but I need some practical experience
03:52:48 <DRMacIver> I think that impression is not totally unfair. :)
03:53:04 <DRMacIver> But there are also knock on effects with the good ideas being borrowed by more mainstream language.
03:53:07 <Neil|Work> either some written exercises to follow, or some suggestsions for something to write
03:53:12 <Neil|Work> I was thinking tic tac toe
03:53:29 <DRMacIver> (Python generators, C# acquiring monads, etc.)
03:53:35 <Neil|Work> *nods*
03:53:47 <Neil|Work> DRMacIver :: that's what drove me to pick up Haskell
03:53:49 <matthew-_> it's just a matter of working for the right companies where the situations can pop up where you can say, "damnit, I'm using Haskell for this". As ever, for the management, it's a leap of faith.
03:53:50 <DRMacIver> And first class functions finally becoming mainstreamish dammit. :)
03:54:08 <Neil|Work> there's a bunch of functional stuff in boost, which I wanted to pick up for my C++ dev
03:54:16 <DRMacIver> LShift seem to routinely talk about Haskell. I have no idea if they ever use it in real life.
03:55:19 <Neil|Work> matthew-_ :: I'm in quite a nice situation, in that I'm not really tied to a language if I don't need to be
03:55:35 <Neil|Work> I was thinking about using Haskell for build system stuff, the only downside is the lack of knowledge here about it
03:55:52 <Neil|Work> but then nobody ever maintains my code, so...
03:56:26 <LeCamarade> I am going to write me a blog engine in Haskell.
03:56:30 <LeCamarade> That don't count, but ...
03:56:32 <LeCamarade>  :oD
03:56:43 * LeCamarade hopes to get the time.
03:56:48 <Neil|Work> you're braver than me
03:56:50 <Neil|Work> I hate webdev :/
03:58:28 <LeCamarade> Neil|Work: I end up having to do it - I'm a second-gen geek. JavaScript is my toy, not ... say, awk. :oD
03:59:05 <LeCamarade> There are more of us on the way. The future is ours. We think `web dev' when there is anything to do. :oD
03:59:17 <EvilTerran> are there tricks necessary for getting a Cabal doodad working with winhugs?
03:59:35 <EvilTerran> or am i being overly optimistic by thinking it even possible?
04:00:04 <Neil|Work> LeCamarade :: lol
04:00:32 <DRMacIver> Javascript is a great toy.
04:00:37 <DRMacIver> I really like it for doing small things. :)
04:00:40 <Neil|Work> I went the other way, low level funky stuff
04:01:19 <Neil|Work> DRMacIver :: it's a neat little language - runtime prototyping is so easy to abuse
04:01:25 <Neil|Work> 2.myfunc();
04:01:26 <DRMacIver> Yeah
04:02:09 <DRMacIver> I've been playing with ideas for adding a multiple dispatch system in it by messing with Function.prototype.
04:02:24 <DRMacIver> It looks... disturbingly doable.
04:02:43 <matthew-_> yeah, I find the nicest thing about web dev is using javascript. Even the DOM is fairly sane these days.
04:04:02 <Neil|Work> the problem I always had with webdev it was architecture
04:04:02 <Neil|Work> -it
04:04:02 <DRMacIver> Agreed. I spend most of my day doing Java and PL/SQL, so javascript is a breath of fresh air. :)
04:04:06 <Neil|Work> having an html front end was an absolute pain when it came to building your systems modularly
04:04:20 <Neil|Work> I always used to proxy it off, but then the pages ended up looking awful
04:04:21 <matthew-_> and then of course, my chunks module just makes it a dream to drive from haskell ;-P
04:04:32 <Neil|Work> doesn't seem to be so much of a problem these days though
04:06:42 <LeCamarade> For one, JavaScript is probably why I still do Webdev.
04:07:20 <DRMacIver> I wish TCO was standard in Javascript implementations though.
04:07:47 <DRMacIver> Although I saw an amusing hack for implementing it the other day.
04:07:53 <matthew-_> also, I really really like JSON. It's a damn easy way to communicate between haskell and javascript.
04:07:55 <DRMacIver> (Well, tail recursion. Not fullblown TCO.)
04:08:07 <Neil|Work> JSON?
04:08:10 <LeCamarade> The cross-browserness is the biggest problem. And then, when the GWT guys decide to heal it, they go Java. new KillThemAll()
04:08:13 <DRMacIver> Yeah. A JSON parser was one of the first things I wrote in Haskell. :)
04:08:26 <LeCamarade> JSON rocketh/
04:08:34 <LeCamarade> A lot.
04:08:36 <DRMacIver> LeCamarade: Have you seen JSorcerer? It's a JS -> Cross browser compatible JS compiler.
04:08:42 <DRMacIver> Unfortunately non-free.
04:08:46 <LeCamarade> It's my first option for databasing. Seriously.
04:08:48 <matthew-_> Neil|Work: json.org
04:09:00 <LeCamarade> DRMacIver: What???
04:09:07 <LeCamarade> @go jsorcerer
04:09:09 <lambdabot> http://cgi.ebay.com/DISNEY-ARRIBAS-JSORCERER-MICKEY-MOUSE-CLEAR-PAPERWEIGHT_W0QQitemZ190019430881QQcmdZViewItem
04:09:10 <lambdabot> Title: eBay: DISNEY ARRIBAS JSORCERER MICKEY MOUSE CLEAR PAPERWEIGHT (item 190019430881 ...
04:09:12 <DRMacIver> Hm
04:09:16 <DRMacIver> Maybe I've got the name wrong
04:09:16 <opqdonut> ok
04:09:17 * Neil|Work looks
04:09:18 <DRMacIver> One second
04:09:24 <LeCamarade> @go jsorcerer javascript
04:09:27 <lambdabot> http://www.sosresearch.org/caale/caalesimulators.html
04:09:38 <Neil|Work> oh, that's pretty neat
04:09:46 <DRMacIver> JS-Sorcerer
04:09:51 <DRMacIver> @go JS-Sorcerer
04:09:53 <lambdabot> http://www.dhitechnologies.com/products/jssorcerer/
04:09:53 <lambdabot> Title: DHI Technologies, Inc.
04:09:56 <LeCamarade> It would rock no-end. I had done my lib, but ... it always fell short.
04:10:32 <LeCamarade> Neil|Work: Where's that thing about C# and monads?
04:11:24 <DRMacIver> Hm. I never remember where I saw that and need to find it afresh each time.
04:11:28 <DRMacIver> I think it's LINQ related.
04:12:12 <DRMacIver> Oops. I've got to get going.
04:12:15 <Neil|Work> LeCamarade :: I don't know, you were the one that mentioned it :)
04:12:19 <DRMacIver> No, I was. :)
04:12:25 <Neil|Work> ah
04:12:28 <LeCamarade> Oh. Linq.
04:13:10 <DRMacIver> LeCamarade: I'll try to dig it up later. I think basically C# 3.0 will have a feature which is rather monad like (but rather list comprehension centric) that arose out of LINQ.
04:13:15 <Neil|Work> http://msdn2.microsoft.com/en-us/netframework/aa904594.aspx
04:41:14 <MarcWebe1> Do you know a lib containing overloaded accessors for tuple members? such as  instance Fst (,,,) where fst (a,_,_,_) = a ?
04:42:34 <Maddas> LeCamarade: If Emacs is the C++ of editing, it still encompasses a Haskell implementation (Viper mode), so that's fine with me :-)
04:45:51 <LeCamarade> Maddas: Yeah, but ... don't we want it simply Haskell? ;oD
04:52:30 <LeCamarade> :w
04:52:54 * LeCamarade realises he typed the wrong command here. At least it's not an emacs command.
04:55:58 * fasta is into algebra programming at the moment (repMin to the max :) )
04:58:20 <fasta> http://pastebin.ca/455692 <- what do you think about it?
05:01:07 <gour> hmm, erlang goes into typesetting - http://code.google.com/p/erlguten/
05:01:08 <lambdabot> Title: erlguten - Google Code
05:02:24 <matthew-_> that strikes me as a pretty stupid idea.
05:02:35 <matthew-_> Erlang's algorithmic performance pretty much sucks.
05:02:56 <matthew-_> and I fail to see how typesetting can utilise any of the things that Erlang is good at.
05:03:35 <gour> mathrick: but it is there...
05:03:48 <matthew-_> otoh, no prizes for guessing who the project owners are: torbjorn.tornkvist, joearms !
05:04:00 <gour> mathrick: oops, wrong nick
05:04:03 <matthew-_> np
05:04:36 * gour would like to have lyx-like apps in haskell
05:05:17 <fasta> matthew-_: but it will be distributed across the planet! ;)
05:05:31 <kuribas> TeX's language would be easier with referential transparency.
05:06:21 <matthew-_> fasta: well actually, I'm not sure you could distribute it!
05:08:14 <fasta> matthew-_: of course you can
05:08:32 <fasta> matthew-_: I am sure some parts of the problem are not dependent
05:08:39 <SamB_XP> kuribas: tried lout?
05:08:47 <matthew-_> yeah, I guess you could treat each chapter seperately
05:09:00 <fasta> matthew-_: I was thinking about that indeed
05:09:01 <gour> SamB_XP: still developed?
05:09:10 <SamB_XP> gour: as far as I know
05:09:20 <kuribas> SamB_XP: I tried it, but the typesetting algorithms aren't as good as TeX.
05:09:28 <SamB_XP> mmm.
05:09:33 * gour thought lout is dead
05:09:58 <LeCamarade> Actually, come to think of it, is there a case where ready parallelism is too far-fetched?
05:25:51 <Maddas> matthew-_: But surely we all know that people very rarely use a programming language for a particular task because it is an adequate choice rather than the programmer's favourite language :-)
05:31:14 <matthew-_> Maddas: surely the trick is choose your favourite language on the grounds that it's a defensible choice in all cases!
05:33:35 <joelr1> good day!
05:33:56 <Maddas> matthew-_: Yeah, and that trick boils down to being good at defending choices, not necessarily making good choices :-)
05:33:58 <joelr1> is there a command in haskell mode to load the current buffer into ghci as a _module_, i.e. without interpreting it?
05:35:45 <matthew-_> Maddas: yep. So I guess really, the trick to choosing the right programming language is to not be a programmer and be a politician instead!
05:36:24 <MarcWebe1> joelr1: Why do you want that? I only know about :m and :l
05:36:37 <huschi> hi. anybody with hxt experience here?
05:36:52 <joelr1> MarcWebe1: c-c c-l with run :l whereas i want something to run :m
05:37:02 <joelr1> MarcWebe1: because i tend to compile first
05:37:04 <quicksilver> joelr1: :m doesn't load anything
05:37:12 <quicksilver> joelr1: :m just changes the module search path, effectively
05:37:25 <joelr1> quicksilver: ugh... that's what i want regardless
05:37:27 <SamB_XP> Maddas, matthew-_: but wouldn't you want to have a good favorite
05:37:38 <quicksilver> joelr1: what about :l isn't doing what you want?
05:37:46 <Maddas> Sure. But 'good' depends very much on what you're doing :-)
05:38:16 <Maddas> (Perhaps I'm just not sold on the idea of having only one favourite)
05:38:18 <joelr1> quicksilver: no. that loads the source code into the interpreter. i want to use my compiled code, otherwise ghci is doing the work again
05:38:39 <quicksilver> joelr1: :l should load compiled code, if it finds it
05:38:48 <quicksilver> joelr1: it only interprets as a last resort
05:38:51 <joelr1> quicksilver: hmm... perfect then
05:38:57 <quicksilver> joelr1: if it fails to find compiled stuff
05:39:00 <joelr1> quicksilver: but how would i know if it found it?
05:39:07 <quicksilver> it says 'Foo.o'
05:39:12 <quicksilver> instead of 'Foo.hs (interpreted)
05:39:28 <matthew-_> SamB_XP: I guess ideally you shouldn't have a favourite. You should know many languages and choose the right one for the right job. The problem is it tends to take me about a week to relearn a language if I've not touched it for a while which makes switching languages unattractive.
05:39:30 <joelr1> quicksilver: that's my problem. it's not finding it for some reason.
05:39:57 <joelr1> quicksilver: i always recompile first and when i c-c c-l it always re-interprets
05:39:58 <quicksilver> joelr1: I imagine you're not obeying the module-name -> file-name correspondance, perhaps?
05:39:59 <Maddas> matthew-_: Yeah, but I think it's still worth the effort, assuming you're working on substantial problems.
05:40:19 <matthew-_> Maddas: oh indeed.
05:40:23 <Maddas> matthew-_: But then again, the language itself is only so important.
05:40:30 <joelr1> quicksilver: i think i am
05:40:34 <joelr1> quicksilver: i am for sure
05:41:30 <MarcWebe1> matthew-_: So it's not only me who thinks this way ;-)
05:41:53 <hpaste>  joelr1 pasted "emacs and c-c c-l" at http://hpaste.org/1544
05:42:01 <joelr1> quicksilver: check the above
05:43:41 <ekidd> Good morning.
05:43:42 <joelr1> quicksilver: does that look right to you?
05:43:51 <matthew-_> MarcWebe1: sorry, in respect to what? Language choices?
05:44:40 <MarcWebe1> matthew-_: Needing one week to refresh a language.
05:45:36 <matthew-_> MarcWebe1: yeah, it depends on the language. I'm sure I could drop back into Java quickly and Erlang would be a day or two. But I'm sure going from those back to Haskell after a break of, say, 2 months would be tough going.
05:46:18 <matthew-_> It's probably just the APIs to the standard libraries that I forget which slows things down when you start work in the language.
05:46:27 <MarcWebe1> matthew-_: The point is is's not only the language but also its libs..
05:47:48 <matthew-_> absolutely. eg whilst in haskell, foldl and foldr take args in different order, in erlang, they both take them in the same order. That kinda thing trips you up a lot I find.
05:47:49 <gour> haskell is described as "..general purpose..language"
05:47:57 <matthew-_> so is javascript.
05:48:06 <gour> is it?
05:48:20 <MarcWebe1> gour, matthew-_ Any touring complete language is, isn't it? *lol*
05:48:23 <gour> it must be joke
05:49:58 <matthew-_> nope. Define general purpose anyway. So long as you can fork and hit the filesystem and networks I'd call it general purpose.
05:50:29 <matthew-_> In fact, I'd probably say general purpose iff not DSL
05:50:37 <arcatan> what about, say, PHP?
05:50:39 <gour> "for solving general purpose problems"
05:51:29 <matthew-_> PHP is an abomination. OTOH, people do seem to be able to write some impressive applications in PHP, if impressive only due to the vast range of incorporated security failings.
05:51:51 <flux> I wouldn't call prolog a general purpose language..
05:52:08 <matthew-_> I might be tempted to call prolog a DSL
05:52:20 <fasta> flux: why wouldn't it be?
05:52:30 <gour> from wikipedia "By purpose, programming languages might be considered general purpose, system programming languages, scripting languages, domain-specific languages, or concurrent/distributed languages (or a combination of these)"
05:52:37 <flux> because it really has a more narrow purpose than a general one :)
05:52:41 <MarcWebe1> flux: That would have been my next question.. Why? Because there exists DSL's embedding Prolog in haskell .. (http://citeseer.ist.psu.edu/cache/papers/cs/14072/http:zSzzSzwww.comlab.ox.ac.ukzSzouclzSzuserszSzsilvija.sereszSzPaperszSzehp.pdf/spivey99embedding.pdf)
05:52:46 <fasta> flux: haha
05:52:46 <lambdabot> http://tinyurl.com/2a6d2b
05:53:05 <flux> and PHP is a language for instantiating templates
05:53:24 <flux> albeit, very smart templates :)
05:53:32 <fasta> flux: we are obviously not talking about the same
05:53:40 <flux> if it didn't default to outputting text, I might think otherwise ;)
05:56:19 <flux> how would this sound: if a language has specialized constructs for performing the main task of the language, it's not general purpose? or is it useful to have 'general purpose' as a synonym for 'programming language'
05:57:05 <quicksilver> PHP was initially a templating language but has progressed to the point of being a general purpose one
05:57:21 <quicksilver> Perl was initially a text extraction/reporting language but has progressed to being general purpose
05:57:24 <quicksilver> etc
05:57:31 <fasta> flux: it doesn't matter how it sounds. "General purpose" already has established meaning.
05:57:42 <quicksilver> I'd agree that prolog is not general purpose, though
05:58:03 <flux> fasta, turing complete with io interface?
05:58:07 <gour> do we agree that haskell is?
05:58:44 <joelr1> quicksilver: you are right, although it doesn't say "foo.o". it will just omit the compilation message
05:58:47 <earthy> general purpose? definitely.
05:59:02 <flux> what would haskell's purpose be if not general..
05:59:21 <matthew-_> quicksilver: mmm. Has Perl "progressed" or "digressed" ;)
05:59:25 <fasta> flux: the io interface is not needed
05:59:41 <gour> right, therefore one would expect to see more 'general-purpose' apps written in it, like the above one written in erlang
05:59:51 <flux> hmm.. I think sed is turing-complete?
05:59:56 <ToRA> why would you say prolog is not general purpose; there are certainly libraries to do io, networking etc. in it?  There's even visual prolog...?
06:00:03 <matthew-_> mod rewrite in apache is turing complete ffs!
06:00:06 <flux> and there are tons of esoteric languages that are turing-complete
06:00:31 <flux> I think turing-completeness by itself is not a sufficient precondition (but required) for a general purpose language.
06:00:51 <flux> although I suppose general-purposeness is not only about the language, but about the implementation too..
06:01:57 <flux> I'm yet to hear someone say postscript is a general purpose language, and it's not every very esoteric
06:02:02 <flux> s/every/even/
06:03:34 <matthew-_> flux: I almost implemented Early Chart-parsing in postscript as part of a coursework for my undergrad degree. It clearly is general purpose stack machine with the advantage that you can use it to break printers.
06:07:04 <chessguy> 'morning haskellers
06:09:04 <chessguy> yes, it is morning for me :)
06:09:43 <matthew-_> Are you west coast USA then?
06:10:52 <quicksilver> I strongly suspect turing complete is neither necessary nor sufficient
06:11:03 <quicksilver> I think it very likely that you can do without general recursion
06:11:25 <quicksilver> joelr1: good :)
06:19:04 <joelr1> any template haskell experts in da house?
06:23:46 <matthew-_> joelr1: not an expert, but I've used it a fair bit recently.
06:24:13 <joelr1> matthew-_: have you used lisp as well? i'm wondering if TH is a suitable macro language
06:25:29 <matthew-_> joelr1: nope, I've never used lisp. You can certainly rewrite and modify the AST of haskell modules dynamically at compile time with TH and thus achieve macro-style expansions.
06:26:07 <chrismbrown> joelr1: I dabbled in it a bit about a year ago, but I'm a bit rusty now... so I'm no expert...
06:26:20 <joelr1> matthew-_: so i can, basically, have a dynamic language that is expanded at compile time, right?
06:26:33 * joelr1 just posted a message to cafe about this
06:26:47 * chrismbrown reads your email
06:27:28 <matthew-_> joelr1: yep. You can call a function at compile time, with some arguements (which must be valid haskell). That function can return an AST which then gets spliced in in place of the function call in the module. Compilation continues
06:28:01 <chrismbrown> joelr1: you have two ASTs, say, and have similar functions working over them both?
06:28:36 <joelr1> matthew-_, chrismbrown: say, i have two modules, A and B. both of them have data Type that has the same constructors and arguments
06:28:48 <chrismbrown> ok
06:28:53 <joelr1> i don't want to have a single type and share it because i expect to expand one of the types
06:29:30 <joelr1> an even better example is Expr that i have in both ASTs. both Expr-s have the same Var constructor but, obviously, it belongs to different data types
06:30:00 <joelr1> so i end up repeating these "macros" for both ASTs:
06:30:00 <joelr1> var x = Var (VarIdent x) []
06:30:01 <joelr1> var' x subs = Var (VarIdent x) subs
06:30:30 <sjanssen> for different values of 'Var', surely
06:30:58 <joelr1> matthew-_, chrismbrown: i would love to have a single TH var macro or two (var and var'). i don't think you can simply do optional arguments in haskell so two macros will be fine
06:31:10 <matthew-_> joelr1: I'd probably suggest that your modelling of the data is broken in that case. If it was me, I'd factor out the common behaviour and then allow for extension. Eg data Exp a = Foo | Bar | Ext a
06:31:23 <joelr1> sjanssen: what do you mean for different values of Var? it's a constructor in two separate ASTs
06:31:53 <chrismbrown> matthew-_, joelr1: yes I agree, this was what I was going to suggest (factor out common behaviour)
06:31:56 <joelr1> matthew-_: i'd rather use macros and keep my ASTs without sharing
06:32:01 <sjanssen> joelr1: it's in two ASTs, but only one data type?
06:32:10 <joelr1> sjanssen: two different data types
06:32:16 <joelr1> thus my wanting to use TH
06:32:23 <chrismbrown> why are they different?
06:32:34 <sjanssen> joelr1: that isn't possible (unless you've omitted module qualification, or something)
06:32:37 <chrismbrown> what is the context?
06:32:50 <sjanssen> data X = Var; data Y = Var -- is not valid
06:32:52 <joelr1> basically, these are two different languages
06:33:01 <matthew-_> joelr1: my experience of TH is that it's not without issues. Thus avoiding its use by refactoring a little elsewhere is preferable IMHO.
06:33:04 <joelr1> sjanssen: they belong to two different modules
06:33:11 <sjanssen> joelr1: okay
06:33:16 <chrismbrown> oh, ok
06:33:42 <joelr1> matthew-_: these are two different languages, you see thus two different ASTs . i may be extending one later so refactoring now may create more work down the road
06:33:48 <sjanssen> so what about "var x = Var (VarIdent x) []" is a macro?
06:33:55 <sjanssen> it looks like a function to me
06:34:10 <joelr1> sjanssen: i know :) i have to duplicate that "macro" for every AST
06:34:11 <Saizan> the fact that he wants to use it with two different values of Var
06:34:17 <joelr1> sjanssen: thus i want to make it a real macro with TH
06:34:47 <Saizan> you can do it quite easily if Var can just be resolved with whatever is in scope
06:35:01 <chrismbrown> joelr1: but var and var' do two different things, so you will still have to create two macros in TH surely...?
06:35:46 <joelr1> Saizan: yes, it can
06:35:51 <ToRA> couldn't you use typeclasses to get around this problem?  define some primitives that both ast's must implement, and then define your macros in the type class in terms of the primitives?
06:36:08 <joelr1> chrismbrown: that yes. two different macros unless there are "optional" arguments in TH
06:36:31 <chrismbrown> hmm, or generalise the macros so that there is one implementation but they work over both ASTs
06:36:34 <sjanssen> joelr1: you need to define both var and var' for two different ASTs in two different modules?
06:36:49 <sjanssen> or is var for one AST and var' for another?
06:36:49 <joelr1> chrismbrown: optional or default args would be nifty since the only difference between var and var' is that var' takes a list of subscripts and var uses an empty list
06:37:03 <joelr1> chrismbrown: that's what i want, to generalize the macros
06:37:29 <matthew-_> joelr1: maybe paste some code? I'm certainly getting confused here...
06:37:30 <chrismbrown> I think typeclasses may be easier
06:37:33 <joelr1> sjanssen: nope. see the subscript explanation. it's var and var' for one ast and exactly the same implementation for the other
06:37:53 <sjanssen> joelr1: this certainly sounds like a job for typeclasses
06:37:59 <sjanssen> what is the type of Var?
06:37:59 <joelr1> sjanssen: hmm
06:38:04 <joelr1> sjanssen: Expr
06:38:10 <joelr1> sjanssen: A.Expr and B.Expr
06:38:13 <chrismbrown> and var'?
06:38:17 <sjanssen> Var :: ??? -> Expr
06:38:25 <sjanssen> joelr1: what does it contain?
06:38:32 <sjanssen> String?
06:38:37 <joelr1> chrismbrown: same thing. the only difference is that var' takes a list of subscripts
06:38:44 <joelr1> sjanssen: sec
06:38:54 <joelr1> data Expr
06:38:55 <joelr1>     = Var VarIdent Subscript
06:39:06 <joelr1> VarIdent = VarIdent String, Subscript = [Expr]
06:39:20 <sjanssen> joelr1: is VarIdent shared between the modules?
06:39:40 <joelr1> meaning that this is a reference to a varible that may use a list of subscripts to be able to refer to array elements
06:39:49 <joelr1> sjanssen: nothing is shared between ASTs
06:39:58 <joelr1> sjanssen: again, i don't want to share
06:40:17 <joelr1> because i may modify one of the asts and trying to factor things now may complicate things later. i would rather use macros.
06:40:28 <hpaste>  sjanssen pasted "preliminary solution to joelr1's var problem" at http://hpaste.org/1545
06:40:42 <sjanssen> joelr1: but could you possibly share VarIdent?
06:40:52 <sjanssen> it makes this much simpler
06:40:54 <chrismbrown> I think the only way around this is with typeclasses
06:40:55 <joelr1> sjanssen: don't want to share anything :) why bother?
06:41:09 <sjanssen> joelr1: okay, then you'll need to write this as a MPTC
06:41:17 <sjanssen> (this meaning my solution above)
06:41:23 <joelr1> chrismbrown: why not macros? at compile time haskell will know what module Var is coming from, no?
06:41:41 * joelr1 is drowning in MTPC already
06:41:47 <sjanssen> joelr1: principled overloaded (via typeclasses) is how we do this in Haskell
06:41:52 <joelr1> my morphing function is implemented on top of mtpc
06:41:54 <sjanssen> s/overloaded/overloading
06:42:04 <sjanssen> doing this in TH just doesn't make sense
06:42:19 <joelr1> class Morpher a b | a -> b where
06:42:20 <joelr1>     morph :: a -> Core b
06:42:34 <sjanssen> can you do dynamic name capture in TH?
06:42:37 <joelr1> sjanssen: why not? it's less boilerplate code!
06:42:37 <chrismbrown> I agree, I'm a little confused as to why TH would be needed for this. In fact what is the difference between A.Expr and B.Expr ?
06:42:50 <joelr1> sjanssen: beats me (dynamic name capture). what is that?
06:43:05 <chrismbrown> if A.Expr and B.Expr are the same then you only need one var and var'...
06:43:16 <sjanssen> joelr1: the ability to choose whichever 'Var' is in scope
06:43:23 <joelr1> chrismbrown: TH to be able to return either A.Expr or B.Expr at compile time. or, for ghc to use A.Expr or B.Expr at compile time, depending on what module the expansion is taking place in
06:43:45 <joelr1> chrismbrown: but yes, only one set of TH macros
06:44:11 <joelr1> classes are great but create lots of boilerplace code
06:44:15 <joelr1> plate
06:44:19 <chrismbrown> you can choose using qualified names though surely
06:44:30 <joelr1> i would need a class for ever macro then the implementation for every ast
06:44:40 <joelr1> whereas a macro is just that, a small simple macro
06:44:55 <chrismbrown> joelr1: surely one class containing all your macros?
06:45:12 <joelr1> chrismbrown: true
06:45:22 <joelr1> chrismbrown: but the code would be exactly the same
06:45:37 <joelr1> i don't see the benefit over duplicating the var and var' functions
06:45:51 <joelr1> as it is, i skip the instance ... where "header" :D
06:45:57 <chrismbrown> joelr1: how exactly do the ASTs differ? but you say you may be extending one later?
06:46:36 <joelr1> chrismbrown: some basic constructors look very much alike. Var, For, While, the type data type
06:47:00 <joelr1> chrismbrown: yes, imagine that i'm translating from various languages
06:47:25 <joelr1> i want separate ASTs for every source language and then a "core" uber-AST that encompasses the features of every language that i'm translating from
06:47:37 <joelr1> so i'll be extending the core AST periodically
06:48:12 <chrismbrown> if these ASTs are so similar can you not unify them in some way? that way you would only need one implementation of your macros
06:48:19 <joelr1> so various constructors may look the same in different ASTs but the datatypes themselves will be different
06:48:40 <joelr1> chrismbrown: i will have one implementation regardless since it's one macro per constructor
06:49:23 <joelr1> the question is how to write this, i guess
06:49:23 <chrismbrown> joelr1: you need a different implementation for each type - you say the constructors can be different...?
06:49:27 <joelr1> i don't know TH
06:49:49 <joelr1> chrismbrown: they may be different later but for now i have various constructors that look exactly the same
06:49:58 <joelr1> they just take their data types from different modules
06:50:11 <chrismbrown> so you need to design it now so that you can extend later surely...?
06:50:13 <joelr1> A.VarIdent, B.VarIdent, A.Expr, B.Expr, etc
06:50:23 <joelr1> yes, that's why i want me macros
06:50:53 <chrismbrown> if the data type are both exactly the same, you don't even need type classes surely....
06:51:28 <joelr1> chrismbrown: they look the same but they are different data types. in different modules
06:51:39 <chrismbrown> yes, but that doesn't matter
06:51:40 <sjanssen> alternatively, perhaps you should make your AST better, so you don't need these "macros"?
06:51:46 <joelr1> chrismbrown: data VarIdent = VarIdent String in module A is not the same as in module B
06:51:50 <chrismbrown> you can specify which data type using a qualified name
06:51:58 <joelr1> chrismbrown: how is that?
06:52:01 <chrismbrown> joelr1: you just said they were!
06:52:05 * chrismbrown is confused
06:52:29 <joelr1> chrismbrown: see varident above :-) look at it carefully. it's the SAME ... visually
06:52:57 <joelr1> chrismbrown: the constructors are named the same, the argument types are named the same. String is the same everywhere
06:53:14 <sjanssen> I'd change "data Expr = Var VarIdent [Expr] | ..." to "data Expr = Var VarIdent | Subscript Expr [Expr] | ..."
06:53:21 <joelr1> chrismbrown: but as far as type checking is concerned A.VarIdent is no the same as B.VarIdent
06:53:31 <chrismbrown> no, but why is that a problem?
06:53:51 <joelr1> sjanssen: how would that help /subscript/?
06:54:07 <sjanssen> chrismbrown: that is a problem if joelr1 wants to reuse the same function for different data types
06:54:14 <joelr1> sjanssen: subscript by itself is not an expression, unless you want to have a separate expr for subscripted access
06:54:39 <joelr1> yes, sjanssen  is right. i want to reuse the same function and the only way to do it seems to be via TH
06:54:48 <sjanssen> joelr: you have these helpers because your AST isn't convenient
06:54:49 <joelr1> which i have to learn
06:55:09 <joelr1> sjanssen: true
06:55:28 <joelr1> sjanssen: but i would still need a separate function for subscripted access in your example
06:55:37 <joelr1> sjanssen: which is exactly what i have now
06:55:39 <chrismbrown> what I would do is have a C.VarIdent and then have transformers from A.VarIdent -> C.VarIdent and B.VarIdent -> C.Varident, then you only need one implementation of your macros. I'm don't understand why you have identical ASTs in separate modules... it makes little sense
06:56:32 <joelr1> chrismbrown: i already have the transformers but i need to write the AST by hand when creating unit tests. i have to type the same thing over and over so i created a bunch of shortcuts like var and var'
06:56:43 <sjanssen> joelr1: you'll always need a separate function for subscripts -- Haskell doesn't have variadic functions
06:56:56 <joelr1> chrismbrown: plus, the ASTs are not identical. expr in the two modules will have different # of constructors
06:57:26 <joelr1> sjanssen: i already have var and var'. although i agree that i should probably use a separate constructor for subscripted access
06:57:45 <joelr1> sjanssen: it doesn't bother me much right now as i can use [] to mean "not subscripteD"
06:57:51 <chrismbrown> joelr1: lol, ok. I think I'm just getting a little confused! I do think typeclasses are probably the way to go... unless you insist on using TH haskell for some reason.... :)
06:58:09 <shapr> @yow !
06:58:10 <lambdabot> Where does it go when you flush?
06:58:10 <sjanssen> joelr1: can arbitrary expressions be subscripted in your language?
06:58:17 <shapr> Surrealist Humor time!
06:58:25 <joelr1> sjanssen: no, i don't think so. only arrays.
06:58:54 <sjanssen> joelr1: only arrays can be subscripted in Java, but you can subscript arbitrary expressions
06:58:57 <joelr1> chrismbrown: yes, i'm probably not expressiing myself clearly. oh, well
06:59:05 <LeCamarade> When you flush, it goes into some Monad somewhere.
06:59:10 <joelr1> sjanssen: no, not an option in my case
06:59:17 <sjanssen> (getSomeInput())[0] -- is legal, for example
06:59:18 * LeCamarade thought LB should know this by now.
06:59:23 <chrismbrown> joelr1: it's just I don't know your context so it's making it a bit hard for me to understand....
06:59:33 <joelr1> sjanssen: i mean, not in one of the ASTs anyway
06:59:45 <fantasmaa> sjanssen: is anyone working on a manpage for xmonad?
06:59:54 <joelr1> sjanssen: in the other it means "the value of this expression that many invocations of the function ago"
07:00:05 <sjanssen> fantasmaa: not that I'm aware of.  It's one of our TODOs for 0.2
07:00:10 <sjanssen> fantasmaa: patches accepted!
07:00:35 <fantasmaa> sjanssen: I'll work on one if you don't mind
07:00:47 <joelr1> chrismbrown: it's super-simple. i want var and var' to have the same code but be of type A.Expr or B.Expr, depending on the module where they are used. TH looks like the only way.
07:01:08 <joelr1> thank you gents for a stimulating discussion!
07:01:18 <sjanssen> fantasmaa: yes, please
07:01:38 <joelr1> i think i need to move indoors. it's too hot and sunny on my terrace
07:01:44 <chrismbrown> joelr1: sorry I couldn't be anymore help, let me know if you get it sorted!
07:01:57 <joelr1> and people are splashing in the pool below
07:02:02 <joelr1> chrismbrown: will do
07:02:10 <joelr1> tenerife rocks
07:04:05 * ptolomy wikipedias tenerife.
07:06:48 <joelr1> it must be +25-27C in the sun
07:06:52 <joelr1> maybe more
07:10:02 * joelr1 invites everyone over
07:10:02 <assl0r> hi
07:10:55 <Nafai> joelr1: Just wanted to tell you I enjoy your blog entries on Haskell/Erlang/etc
07:10:56 <joelr1> assl0r: hello
07:11:16 <joelr1> Nafai: thanks! i haven't posted in a while since i'm busy with my startup
07:11:22 <assl0r> perhaps its a stupid beginner question: is it possible to write a "imperative" (do) main function which calls my stupid beginner functions and prints their results to the screen?
07:11:29 <joelr1> Nafai: i'll surely have plenty to post in a few weeks
07:11:41 <sjanssen> assl0r: sure
07:11:47 <joelr1> assl0r: just do it
07:11:56 <assl0r> well, i tried already ;)
07:12:08 <sjanssen> main = do print [1..10]; print (2 * 5); print (product [1..100]) -- etc.
07:12:38 <Saizan> var' = return $ LamE [VarP (mkName "x"),VarP (mkName "subs")] $ (ConE (mkName "Var")) `AppE` ((ConE (mkName "VarIdent")) `AppE` (VarE (mkName "x"))) `AppE` (VarE (mkName "subs")) <-- var' in pure TH :)
07:12:58 <assl0r> sjanssen, ah okay ;)
07:13:29 <Nafai> joelr1: Cool!
07:13:32 <sjanssen> assl0r: and you can replace the ; with newlines and indentation (recommended)
07:14:03 <assl0r> main :: IO()
07:14:09 <joelr1> Saizan: must be exactly what i want! thank you
07:14:13 <assl0r> is my main signature
07:14:20 <assl0r>    Couldn't match expected type `t1 -> t2 -> IO t' against inferred type `IO ()'
07:14:39 <sjanssen> assl0r: you probably have a simple typo
07:14:42 <sjanssen> @paste if you want
07:14:42 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:14:47 <assl0r> k
07:15:27 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1546
07:15:30 <vincenz> augustss: ping
07:16:05 <joelr1> Saizan: what resources did you use to learn about LamE and others?
07:16:13 <joelr1> what is a LamE anyway?
07:16:17 <sjanssen> assl0r: you need parens around your function calls
07:16:21 <EvilTerran> is it possible to do what "takeWhile (not.null) (sequence $ repeat getLine)" looks like it could do (but doesn't), without explicit recursion?
07:17:05 <Saizan> joelr1: a lambda
07:17:12 <assl0r> sjanssen, thx!
07:17:14 <sjanssen> print (bonus 600.0 600.0) -- for example
07:17:30 <sjanssen> assl0r: you can delete every ; in that program, by the way
07:17:35 <EvilTerran> (inserting liftM or what-have-you as appropriate)
07:17:39 <assl0r> sjanssen, i have already ;)
07:17:43 <sjanssen> embrace the automatic layout!
07:18:04 <joelr1> Saizan: so what did you use to learn?
07:18:19 <Saizan> joelr1: a nice resource is the source of Language.Haskell.Helper in derive, you can also use the combinator dfefined there
07:19:03 <joelr1> Saizan: thanks! will look. you mean Data.Derive, right?
07:19:11 <joelr1> or the derive cmd line tool
07:19:14 <assl0r> how do i concatenate strings? print "foo" . bonus(1.0 1.0)
07:19:37 <assl0r> not a composition of course...
07:19:44 <sjanssen> ++
07:19:52 <sjanssen> @hoogle [a] -> [a] -> [a]
07:19:54 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
07:19:54 <lambdabot> List.intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
07:19:54 <lambdabot> List.unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
07:19:59 <sjanssen> hoogle++
07:20:03 <Saizan> joelr1: that package, yes
07:20:11 <EvilTerran> assl0r, http://www.haskell.org/tutorial/
07:20:12 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
07:20:23 <joelr1> Saizan: ok, thanks
07:20:39 <Saizan> joelr1: though i'd read first a tutorial to get the general idea
07:20:57 <joelr1> right
07:24:26 <nominolo> @seen sboehme
07:24:26 <lambdabot> I saw sboehme leaving #haskell 5h 46m 32s ago, and .
07:25:58 <assl0r> "foo" ++  ( bonus 1.0 1.0) -- doesn't work because i need to "convert" double to char, but how is that done?
07:26:32 <ventonegro> > show 1.0
07:26:35 <EvilTerran> assl0r, may i suggest you read a tutorial to get the groundwork down?
07:26:36 <lambdabot>  "1.0"
07:28:08 <EvilTerran> @djinn Monad m => (Bool -> a) -> [m a] -> [m a]
07:28:09 <lambdabot> Cannot parse command
07:28:18 <EvilTerran> @djinn (Bool -> a) -> [m a] -> [m a]
07:28:18 <lambdabot> f _ a = a
07:28:26 <EvilTerran> ...
07:28:26 <foxy-om> @google Coq in a hurry
07:28:28 <lambdabot> http://www.cs.chalmers.se/Cs/Research/Logic/TypesSS05/Extra/bertot_coq.pdf
07:30:52 <EvilTerran> @hoogle (m a -> m b) -> m(a -> b)
07:30:53 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
07:30:53 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
07:30:53 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
07:37:52 <quicksilver> :t filterM
07:37:55 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
07:38:42 <EvilTerran> it occurs to me that when I said "Bool->a" above, i meant "a->Bool" =/
07:39:28 <quicksilver> that's ok, because that's what I assumed you meant
07:39:48 <quicksilver> are you sure you want to work with [m a] and not m [a] ?
07:40:05 <EvilTerran> yeah, i figured, with what you suggested
07:40:32 <quicksilver> :t \f -> liftM . filter f
07:40:35 <lambdabot>     Couldn't match expected type `a1 -> r' against inferred type `[a]'
07:40:35 <lambdabot>     In the second argument of `(.)', namely `filter f'
07:40:37 <EvilTerran> the context i was originally intending to use it in was reading lines of input until the first blank
07:40:50 <quicksilver> :t \f -> liftM (filter f)
07:40:52 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> Bool) -> m [a] -> m [a]
07:40:58 <EvilTerran> and doing something funky involving (repeat getLine :: [IO a])
07:41:28 <quicksilver> repeat getLine is fine
07:41:38 <quicksilver> but eventaully you presumably extract a finite portion
07:41:41 <quicksilver> and then sequence it
07:41:49 <quicksilver> (sequence takes you from [m a] to m [a])
07:42:04 <EvilTerran> I want to do "lines <- getUntilEmptyLine (repeat getLine)"
07:42:20 <ndm> @seen dons
07:42:21 <lambdabot> dons is in #haskell-soc and #haskell. I last heard dons speak 9h 20m 18s ago.
07:42:26 <ndm> @seen dcoutts
07:42:27 <EvilTerran> and have lines :: [String]
07:42:27 <lambdabot> dcoutts is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard dcoutts speak 13h 1m 33s ago.
07:42:52 <ndm> @tell dcoutts you've got a typo in your ICFP paper, the first reference to Olaf - its "Type inference" not "Typer inference"
07:42:53 <lambdabot> Consider it noted.
07:43:06 <EvilTerran> @paste
07:43:06 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:43:31 <quicksilver> EvilTerran: off-hand I think you'll find that there aren't quite the monadic flow control ops you need for htat
07:43:42 <quicksilver> EvilTerran: but it's not hard to code using explicit recursion
07:43:53 <hpaste>  EvilTerran pasted "getLines" at http://hpaste.org/1547
07:44:13 <EvilTerran> yeah, that's my explicitly-recursing one there
07:44:24 <EvilTerran> i just prefer to avoid explicit recursion if i can.
07:44:31 <ndm> @tell dcoutts plus am very jealous that you have space left over - i had to delete content to fit within 12 pages - i should have borrowed some space off your paper
07:44:32 <lambdabot> Consider it noted.
07:45:09 <ndm> @tell dcoutts I don't suppose you have any space left on a HW paper that I could borrow? just a page should do it :)
07:45:10 <lambdabot> Consider it noted.
07:47:36 <chrismbrown> does anyone here know if hunit is written in Haskell 98?
07:51:00 <fasta> chrismbrown: you mean without any extensions?
07:51:36 <chrismbrown> fasta: yeah, no implementation specific extensions, just pure Haskell 98
07:51:48 * sjanssen points out that nearly every Haskell program uses an extension: hierarchical modules
07:52:19 <fasta> chrismbrown: I browsed it now.
07:52:27 <fasta> chrismbrown: it appears to be pure Haskell 98
07:52:35 <fasta> chrismbrown: even no hierarchical modules
07:52:37 <chrismbrown> fasta: that's great, thanks!
07:53:52 <chrismbrown> ok, I don't suppose there is an easy way to convert a literate haskell file into an illiterate one is there?
07:54:18 <ndm> chrismbrown: yes, use cpphs with the --unlit flag
07:54:19 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
07:54:27 <ndm> @messages
07:54:28 <lambdabot> LeCamarade said 4h 51m 41s ago: I think System.FilePath.pathSeparator should be a string, since some platforms use more than one char to separate. And that wouldn't pause any probs, since a path is
07:54:28 <lambdabot> going to end up as a string, anyway. My two cents. (The French say `Mes deux centimes'.)
07:54:50 <fasta> chrismbrown: why do you only need H98?
07:55:21 <chrismbrown> fasta: To my duplicate code analyser
07:55:25 <ndm> @tell LeCamarade alas haskell doesn't deal with strings as easily as Char - no break/span etc, and i think its too late to change for this release (GHC comes out in a few days), but i'll write it down to think about
07:55:25 <lambdabot> Consider it noted.
07:55:34 <fasta> chrismbrown: ok
07:55:35 <chrismbrown> fasta: to TEST my duplicate code analsyer
07:55:41 <fasta> chrismbrown: yes, I got that
07:55:49 <chrismbrown> fasta:  :)
07:55:59 <fasta> The only thing I don't like about Haskell is that it piles feature upon feature - the exact opposite of Scheme.
07:56:25 <jcreigh> The thing I like about Haskell is that it piles feature upon feature - the exact opposite of Scheme. :P
07:56:41 <EvilTerran> chrismbrown, "sed 's/^> //p"
07:56:45 <sjanssen> jcreigh++ ftw
07:56:49 <jcreigh> I mean, seriously, isn't it nice just have arrays availible without having to see if your implementation supports that SFRI?
07:56:54 <EvilTerran> oh, wait, it's already been solved. and probably better. never mind.
07:57:04 <chrismbrown> EvilTerran: cheers anyway
07:57:24 <fasta> jcreigh: there are vectors in R5RS
07:57:37 <jcreigh> fasta: multi-dimensional?
07:57:46 <fasta> jcreigh: you can build them easily
07:57:49 <quicksilver> EvilTerran: I think that's fine
07:57:57 <jcreigh> fasta: is that a "no"?
07:57:59 <fasta> jcreigh: where are Haskell's multi-dimensional arrays?
07:58:10 <jcreigh> fasta: use a key of (Int, Int)
07:58:20 <fasta> jcreigh: ah, bad example ;)
07:58:56 <quicksilver> haskell is so expressive multidimensional arrays aren't even a separate feature, they're part of the same abstraction
07:58:59 <EvilTerran> quicksilver, it won't detect code lines that're right next to text lines. i can't remember if those're errors or to be treated as text
07:59:03 <quicksilver> score 1 for the haskell camp :)
07:59:08 <matthew-_> is there no haskell equivalent of select? I want to wait for some file handles to become ready to read.
07:59:14 <EvilTerran> quicksilver, also \begin{code} \end{code} or whatever it's called
07:59:19 <mux> matthew-_: this is best done using threads
07:59:28 <quicksilver> matthew-_: it's in POSIX, I think, but you're better off using thread
07:59:34 <fasta> jcreigh: If Scheme and Haskell had the same libraries and both very good implementations, I would pick Scheme.
07:59:35 <mux> @hoogle waitfor
07:59:36 <lambdabot> System.Process.waitForProcess :: ProcessHandle -> IO ExitCode
07:59:36 <lambdabot> IO.hWaitForInput :: Handle -> Int -> IO Bool
07:59:43 <mux> otherwise there's that
07:59:53 <fasta> jcreigh: by good implementation, I mean one with soft-type inference and other cool stuff.
08:00:19 <quicksilver> once you have type inference it doesn't sound much like scheme to me
08:00:39 <fasta> quicksilver: soft-type inference
08:00:57 <matthew-_> mux, quicksilver: eww, that's grim. All I want to do is to wait on the stdout and stderr of a spawned process and print it out to my stdout and stderr. Spawing threads seems a bit much. Plus, this is being called at compile time, by TH. Can you even spawn threads then?
08:01:17 <mux> spawning thread is uber-cheap
08:01:21 <EvilTerran> matthew-_, <lambdabot> IO.hWaitForInput :: Handle -> Int -> IO Bool ?
08:01:30 <quicksilver> fasta: even so
08:01:36 <mux> forkIO (forever (getLine >> putStrLn)) where forever a = a >> forever a
08:01:41 <matthew-_> EvilTerran : I want waitForReady :: [Handle] -> IO Handle
08:01:45 <mux> or something
08:01:56 <matthew-_> mux: ahh, green threads?
08:01:58 <fasta> quicksilver: it's just that nobody did a decent job on it
08:02:12 * fasta hates green threads as terminology
08:02:13 <mux> matthew-_: yes, forkIO are micro-threads, only forkOS threads are expensive
08:02:19 <kuribas> jcreigh: It is easy to extend scheme, for example to embed a logic language (kanren, schelog), but I haven't seen one in haskell that is easy to use.
08:02:28 <quicksilver> matthew-_: indeed, forkIO threads are implemented using a select loop behind the scenes
08:02:34 <mux> matthew-_: and these days there are very few reasons to use forkOS
08:02:38 <quicksilver> matthew-_: they're "just" an easy interface to select, if you like :P)
08:02:41 <matthew-_> right, ok, that doesn't repulse me as much then ;)
08:02:50 <quicksilver> (although actually they're a bit more than that)
08:03:20 <matthew-_> mux: err, how about wanting to use all the cores of your CPU? That would strike me as a reason to use forkOS no?
08:03:23 <fasta> I think it's a waste that every language community build there own mediocre tools
08:03:33 <sjanssen> matthew-_: ghc does that transparently
08:03:36 <mux> matthew-_: GHC does that for you
08:03:42 <matthew-_> ooooooh!
08:03:46 <sjanssen> it schedules N Haskell thread to run on M cpus
08:03:48 <fasta> builds*
08:03:49 <mux> you just have to pass it the number of cores
08:04:00 <mux> ./foo +RTS -N X -RTS
08:04:01 <fasta> mux: why is that the case any way?
08:04:08 <mux> slightly unfortunate
08:04:13 <fasta> Why can't it detect the number of cores automatically?
08:04:17 * matthew-_ does jig of joy. That's pretty much the same as the current Erlang smp support. Nice.
08:04:19 <mux> fasta: probably because there isn't any portable way to determine that
08:04:33 <quicksilver> I think they just haven't got round to it, to be honest
08:04:39 <mux> fasta: I guess we'll have to add support for detecting this on various OSes soon
08:04:39 <fasta> quicksilver: I think so too
08:04:40 <quicksilver> there are cases where you don't want to use them all, though
08:04:51 <mux> quicksilver: yes, but having a default value is sane
08:04:59 <mux> you can still use -N 0 if you want to only use one core
08:05:00 <fasta> mux: I wanted to say the same
08:05:07 <quicksilver> it's trivial on linux-ish OSes but there isn't a POSIX api for CPU info
08:05:15 <mux> yes, no portable way
08:05:25 <quicksilver> there are, I imagine, MacOS and Win32 apis but that's fiddly porting work :)
08:05:29 <fasta> But can't you just _try_ with different values?
08:05:35 <fasta> I.e. do binary search
08:05:36 <quicksilver> fasta: no, it always works
08:05:45 <quicksilver> fasta: it's just more efficient not to use more threads than you ahve cores
08:05:56 <quicksilver> well, for some algorithms actually you want to use more :)
08:06:02 <fasta> quicksilver: so, what happens when you tell ghc that you have 1000 cores?
08:06:22 <quicksilver> you want to use (number of cores + some fudge factors depending how often threads block)
08:06:23 <sjanssen> fasta: ghc creates 1000 OS threads (which means big overhead)
08:06:35 <fasta> sjanssen: ah, ok
08:06:59 <sjanssen> quicksilver: but IO never blocks a thread managed by ghc, right?
08:07:29 <quicksilver> sjanssen: I think only if you're good and use hWaitForInput
08:07:42 <quicksilver> sjanssen: maybe it is also ok with simple read and write calls too
08:07:58 <sjanssen> quicksilver: all of the Handle based calls don't block OS threads
08:08:08 <quicksilver> sjanssen: but if you have some more exotic call which blocks, or some other resource contention which isn't Handle-based
08:08:27 <sjanssen> quicksilver: what sort of resource?
08:08:38 <quicksilver> graphics card?
08:08:40 <matthew-_> so the runtime just maintains a list of which "threads" are ready and which are blocked and the OS threads just choose between them?
08:08:43 <quicksilver> TV tuner?
08:09:44 <sjanssen> quicksilver: assuming those don't use standard IO primitives, you'd probably use a "safe" FFI call (safe calls automatically spin off an OS thread to avoid blocking every Haskell thread)
08:10:01 <quicksilver> sjanssen: *nod*
08:10:46 <sjanssen> I'm fairly certain that it's never good to tell ghc to use more OS threads than CPUs
08:10:57 <sjanssen> unless you're trying to cheat other programs out of their timeslice
08:11:04 <psnl> quicksilver: if your FFI call is not reenterent, and you call out of correct order, then it goes tits-up. the rest of the time it works.
08:11:25 <sjanssen> matthew-_: essentially.  ghc has a built in scheduler
08:11:55 <nn-laptop> ! seen samb
08:11:59 <nn-laptop> !seen samb
08:12:08 <psnl> quicksilver: using the FFI with haskell threads is the same as using C functions with C threads
08:12:12 <int-e> use @ or ?, not !
08:12:37 <quicksilver> psnl: *nod
08:12:40 <nn-laptop> @seen samb
08:12:41 <lambdabot> samb is in #perl6 and #haskell. I last heard samb speak 1d 2h 20m 10s ago.
08:13:08 <sjanssen> psnl: not exactly
08:13:31 <sjanssen> depending on whether the FFI call is safe/unsafe
08:14:09 <sjanssen> if a blocking FFI call is marked as unsafe, you can get deadlock
08:14:30 <sjanssen> deadlock that wouldn't happen in C and preemptive OS threads
08:14:47 <psnl> sjanssen: thinks... yes
08:19:05 <rjeq> wow, @pl can be used to simplify expressions
08:19:50 <Saizan> you thought it was only an obfuscation tool?
08:19:55 <quicksilver> or complify them :)
08:20:07 <rjeq> i never knew it could do things like:
08:20:13 <Neil|Work> complify?  is that a word?
08:20:13 <quicksilver> @pl \((a,b),(c,d)) -> ((d,a),(c,b))
08:20:14 <rjeq> @pl ((.) . (.)) f
08:20:15 <lambdabot> uncurry (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. flip (,)) . (.) . flip . ((,) .) . flip (,)))
08:20:15 <lambdabot> ((f .) .)
08:20:28 <quicksilver> Neil|Work: it is now :)
08:20:50 <Saizan> quicksilver: insane O_o
08:20:51 <quicksilver> rjeq: yes, @pl is, to some extent, a normaliser
08:20:54 <Neil|Work> OED says otherwise ;)
08:20:59 <quicksilver> rjeq: although I it's not normalising...
08:21:06 <quicksilver> rjeq: so that's a bad name for it :)
08:21:16 <rjeq> @unpl (uncurry (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. flip (,)) . (.) . flip . ((,) .) . flip (,))))
08:21:17 <lambdabot> (uncurry (uncurry (\ ah f -> (\ p aa -> ((,)) ((,) aa ah) ((,) (fst p) f)) >>= \ bf -> snd >>= \ be -> return (bf be))))
08:21:29 <quicksilver> @pl "a"++
08:21:29 <lambdabot> (line 1, column 6):
08:21:30 <lambdabot> unexpected end of input
08:21:30 <lambdabot> expecting white space or simple term
08:21:34 <quicksilver> @pl ("a"++)
08:21:35 <lambdabot> ('a' :)
08:21:39 <quicksilver> e.g.
08:21:49 <rjeq> @pl (uncurry (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. flip (,)) . (.) . flip . ((,) .) . flip (,)))) (a,b)
08:21:50 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. flip (,)) . (.) . flip . ((,) .) . flip (,)) a b
08:22:03 <Neil|Work> @pl (\x -> x)
08:22:04 <lambdabot> id
08:22:06 <ndm> which "extension" corresponds to typing unsafeCoerce# ? - http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Language-Haskell-Extension.html
08:22:07 <Neil|Work> neat
08:22:09 <rjeq> @pl (uncurry (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. flip (,)) . (.) . flip . ((,) .) . flip (,)))) ((a,b),(c,d))
08:22:10 <lambdabot> ((d, a), (c, b))
08:22:11 <lambdabot> http://tinyurl.com/2xjyqs
08:22:17 <ndm> i.e, having a # at the end
08:22:23 <rjeq> @pl (uncurry (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. flip (,)) . (.) . flip . ((,) .) . flip (,)))) ((a,b),c)
08:22:24 <lambdabot> ((snd c, a), (fst c, b))
08:22:26 <Neil|Work> who wrote lambdabot?
08:22:29 <rjeq> i'll stop now
08:22:29 <ndm> Igloo: you seem to be encouraging LANGUAGE, do you know?
08:23:06 <ndm> Neil|Work: shapr, dons - others have contributed too
08:23:11 <Igloo> ndm: I don't think there is one for #-in-ids
08:23:15 <Neil|Work> ah
08:23:28 <ndm> Igloo: :( - does that mean i just need a big hammery -fglasgow-exts?
08:23:37 <Neil|Work> beats the regular channel bots
08:23:37 <Igloo> ndm: AFAIK, yes
08:23:44 <Neil|Work> with... !googlefight
08:23:49 <ndm> Igloo: and shouldn't there be? (or perhaps GHC could have never abused the lexer...)
08:23:59 <Igloo> There should be
08:24:21 <shapr> Silly question, why can't I do [5..1] as well as [1..5] ?
08:24:31 <Igloo> You can do [5,4..1]
08:24:36 <ndm> shapr: [5,4..1]
08:25:19 <shapr> ah, doh
08:25:26 <shapr> I guess I expect it to read my mind.
08:25:26 <quicksilver> a deer
08:25:57 <shapr> a female deer
08:26:23 <Nafai> ray
08:26:26 <Nafai> a drop of golden sun!
08:26:39 <shapr> lambda, a toy I play with often..
08:27:00 <Neil|Work> it worries me that I know all the words to that song
08:27:11 <sjanssen> Monad! the class I love to instance
08:27:35 <Nafai> Neil|Work: It's my Mom's favorite movie, so I watched it a lot growing up :/
08:27:41 <Neil|Work> although looking at the chatlog, I'm not that worried
08:27:47 <Lor> shapr, as for rationale, what should [first..last-1] return for first = last?
08:28:31 <mux> I think it returns []
08:28:31 <quicksilver> > [5..4]
08:28:33 <lambdabot>  []
08:28:39 * quicksilver nods
08:28:42 <quicksilver> goodp oint by Lor
08:28:48 <mux> oh no
08:28:57 <mux> I just rm'ed files bah
08:30:34 <therp> my whole server infrastructure just evaporated. it looks like the provider that hosts my site just died as a corporate entity. I'm so tempted to go for google mails
08:31:24 <therp> and also the Liskell repo is going to down.. exactly in the week I wanted to push updates..
08:37:21 <matthew-_> is there anyway I can tell ghc about another -optl from within TH ?!
08:37:37 * matthew-_ suspects not.
08:45:43 <assl0r_> can anyone recommend a good QuickCheck tutorial?
08:46:05 <emu> the manual
08:46:28 <emu> it has lots of examples
08:53:57 <fantasmaa> does xmonad have any command line arguments?
08:54:22 <sjanssen> nope
08:55:20 <fantasmaa> not even -v(ersion)
08:55:47 <sjanssen> nothing
08:55:51 <fantasmaa> alright
08:56:23 <Lor> How does (or will) xmonad compare with ion, feature-wise?
08:57:37 <sjanssen> much much lighter
08:59:41 <sjanssen> it's probably easier to say which features xmonad won't have :)
09:00:18 <sjanssen> xmonad won't have: window decorations, a REPL, dynamic code loading
09:00:32 <bos> and definitely no ponies.
09:00:40 <kc5tja> NOT YOURS!
09:00:41 <sjanssen> absolutely not
09:00:53 <bos> im in ur window manager ripping out ur features lol
09:01:00 <bos> ahem.
09:01:33 <Lor> No title bars or visual tabs?
09:01:39 <kc5tja> Well, I find xmonad handles dialog boxes a bit better than ion3, at least on my home box.  I haven't tried it at work yet.
09:01:52 <kc5tja> Lor: nope.  Focus follows mouse.
09:02:14 <Lor> I don't use any borders with ion either, but I really like having some visual feedback about the windows that are stacked in a single frame.
09:02:16 <sjanssen> Lor: there will be an optional statusbar, but probably no tabs
09:02:38 <sjanssen> I don't plan to have tabbing at all
09:02:40 <kc5tja> Lor: No more than one window per frame.
09:02:54 <kc5tja> I didn't think I'd like that, since I use it extensively in Ion3.
09:03:08 <sjanssen> kc5tja: but after you've used it for a while?
09:03:14 <kc5tja> But it turns out, I like it better that way, which is why I haven't switched back (at home at least; again, haven't tried it in a work environment yet)
09:03:40 <sjanssen> yes, I discovered this too (with dwm actually, but that's essentially the same story)
09:03:40 <Lor> When you have a gazillion xterms, tabs come really handy.
09:04:02 <sjanssen> well, there is fullscreen mode
09:04:25 <kc5tja> Lor: I often have 4 to 8 xterms open on my box at home open at any given time.
09:04:42 <kc5tja> It's not that bad.
09:04:58 <kc5tja> Also, there's always screen.  :)
09:04:59 <Lor> I have about 20.
09:05:25 <quicksilver> using screen inside a wm just to manage xterms sounds a bit like a wm failure
09:05:33 <quicksilver> I use screen inside a wm, but that's for different reasons
09:06:02 <kc5tja> quicksilver: Hardly; I use screen inside wms all the time, especially *NON*-tiled or tabbed wms.
09:06:36 <kc5tja> quicksilver: Screen is also nice for when you find your X session is acting futzy, so you have to kill X and restart (like I have to, on a seemingly three-times-a-week basis because of the resources Java sucks up on my workstation)
09:07:23 <quicksilver> kc5tja: well the former sounds very much like a wm-or-x failure
09:07:27 <quicksilver> kc5tja: erm, latter I meant to type
09:07:31 <kc5tja> Moreover, the damn nice thing about screen is, frankly, CTRL-A (shift)A, which lets you rename a particular session.
09:07:46 <quicksilver> kc5tja: since you are using screen to work around a bug in another program, not because it's the right solution
09:08:03 <kc5tja> quicksilver: I still wouldn't have it any other way, personally.
09:08:10 <quicksilver> kc5tja: the former sounds to me like your wms aren't giving you the power you want
09:08:14 <quicksilver> which is what I mean by a wm-failing
09:08:25 <quicksilver> don't get me wrong, I love screen :)
09:08:31 <quicksilver> and use it constantly
09:08:43 <quicksilver> but I think that a wm should aim to offer the kind of features you're talking about
09:08:47 <sjanssen> quicksilver: a WM can't reattach xterms to a new X session
09:09:19 <quicksilver> sjanssen: right, that's an example of a case when screen *is* what you want :)
09:09:40 <quicksilver> sjanssen: I'm trying to distinguish re-attach-ability from just 'good management of multiple terminal programs'
09:09:50 <sjanssen> ah, right
09:09:59 <sjanssen> quicksilver: in that case then, I agree
09:14:23 <sjanssen> Lor: if you're willing to split your screen, xmonad's tiling mode might work for you
09:14:44 <Lor> How's it different from ion's?
09:15:10 <sjanssen> http://xmonad.org/images/screen-sjanssen.png there's a screen shot
09:15:22 <sjanssen> the area on the left is always one window, the right is the rest of them
09:15:30 <sjanssen> the split is configurable, by the way
09:15:47 <bos> @hoogle getCurrentTime
09:15:48 <lambdabot> No matches found
09:18:09 <Lor> I see. Instead of tabs I'd have a large number of thin windows at one side.
09:18:51 <andun> Lor: i'm a ion user trying xmonad right now
09:19:06 <Saizan> in tiling mode i found difficult to change which of the windows is the main one at the start, has it changed? or was i just unaware of the commands?
09:19:38 <andun> Saizan: you can make a window the main one with mod+RET
09:19:56 <sjanssen> Saizan: the behavior changed shortly before the 0.1 release
09:20:18 <sjanssen> if mod-ret cycles the window order instead of swapping two windows, you should upgrade
09:20:20 <ventonegro> is there any lexical extension in GHC for long strings?
09:20:52 <EvilTerran> heredocs?
09:21:39 <andun> sjanssen: is it possible to move a window to another workspace?
09:21:57 <sioraiocht>  is there a good tutorial on state monads?
09:22:03 <ventonegro> can't find in the manual
09:22:21 <sjanssen> andun: mod-shift-wsnumber
09:23:11 <andun> cool. for some reason it doesn't work with my Emacs, though
09:23:52 <sjanssen> does it work with other windows?
09:24:01 <andun> yes. kinda wierd
09:24:06 <quicksilver> ventonegro: "kljhkljh\   \lkjhkljh"
09:24:09 <sjanssen> I haven't seen that before
09:24:20 <quicksilver> ventonegro: there can be a newline in the space between the two \s
09:24:27 <quicksilver> ventonegro: in fact, any whitespace at all :)
09:24:32 <EvilTerran> ventonegro, http://haskell.org/onlinereport/lexemes.html#lexemes-char
09:24:34 <lambdabot> Title: Haskell 98 Lexical Structure
09:24:45 <quicksilver> ventonegro: personally, I find that ugly, and I just use concat ["lkjhlkjh","kjhlkjh",..]
09:24:50 <ventonegro> quicksilver, i know strings gaps, but it becomes tiresime after a while
09:24:52 <quicksilver> ventonegro: with each string on a new lines :)
09:25:10 <ventonegro> tiresome
09:25:14 <andun> sjanssen: if i'm fast enough it works for some reason
09:25:37 <ventonegro> quicksilver, thanks anyway!
09:26:02 <sjanssen> andun: weird
09:26:28 <andun> sjanssen: maybe i'm just slow. the mad+shift combination is a bit inconvenient on my dvorak keyboard
09:27:43 * EvilTerran notes that you can't put comments in string gaps
09:27:57 <therp> are there X11 bindings to Xft?
09:28:43 <therp> the question should actually read: are there Haskell bindings to Xft ("Xft" in X11 context)
09:29:17 <bos> no.
09:29:36 <therp> but as X11 are bindings to C, this shouldn't be hard, right?
09:29:40 <bos> people rarely use Xft directly.
09:30:43 <fantasmaa> sjanssen: do you have a preference as to which macro I use for the man page? (mdoc or man)
09:30:43 <bos> well, it's not hard, but it would be time consuming. there are about 20 entry points and 20 structures you'd need to write FFI wrappers for.
09:31:09 <therp> should not require more than one day work
09:31:18 <bos> a long day :-)
09:31:29 <bos> why do you want to do that?
09:31:50 <bos> i'm not saying it's a bad idea, just a curious way to spend your time.
09:32:38 <sjanssen> fantasmaa: I know very little about man pages, so the choice is up to you
09:32:56 <sjanssen> therp: is Xft that small?
09:33:35 <quicksilver> ventonegro: If I was doing enough text that it become annoying I might put it in a separate file
09:34:08 <therp> sjanssen: as bos said, it shouldn't be more than 20 entry points.. I'd say it's less than 20 structures..
09:34:40 <fantasmaa> sjanssen: well mdoc is cleaner (and more scalable) but not everyone has them
09:34:47 <ventonegro> quicksilver, but i'd like to ship a single executable
09:35:01 <therp> bos: xmonad looks interesting, but if its ever going to show me some text it HAS to talk to xft. fonts not rendered by freetype are forbidden on my desktop
09:35:07 <ventonegro> quicksilver, and pray my boss does not suspect it's written in haskell :-)
09:35:21 <quicksilver> ventonegro: then, as part of your build process, convert the text file into compilable haskell
09:35:26 <sjanssen> fantasmaa: portability is nice
09:35:44 <fantasmaa> sjanssen: man it is :)
09:36:02 <ventonegro> quicksilver, yep, it's a good solution
09:36:33 <sjanssen> therp: patches welcome :)
09:36:57 <sjanssen> patches for the as-yet-vaporware status bar, that is
09:37:09 <therp> sjanssen: sure. the last incarnation of Xft patches for ion came from me.
09:38:10 <quicksilver> hGetContents h1 >>= fmap ("varname = "++) (hPutStrLn h2 . show)
09:38:15 <quicksilver> ventonegro: something like that :)
09:38:33 <quicksilver> ventonegro: although that will screw up any unicode chars :(
09:40:29 <fantasmaa> xmonad or Xmonad ?
09:40:56 <shapr> SHAZAM!
09:41:04 * shapr throws sugar lambdas
09:41:39 * shapr becomes CAPTAIN LAMBDA!
09:41:56 <Vq^> :)
09:42:05 <Saizan> captain lambda :OOOO
09:42:50 <sjanssen> fantasmaa: xmonad
09:43:51 <shapr> Saizan: Have you been a good boy and evaluated all your homework to redexes?
09:44:23 <fantasmaa> thanks
09:44:34 <Saizan> i had some type errors :(
09:44:58 <shapr> aww
09:51:56 <shapr> doodle ooo
09:52:00 <shapr> doodle oo
09:52:10 <shapr> bum bum bum BA bum bum
09:52:15 * shapr hums mission impossible
09:52:36 <shapr> What's every body working on today?
09:53:12 * savanni waves hi to shapr before answering
09:53:25 <savanni> I'm working on normal job work, but thinking about a web app that I'm writing in Haskell.
09:53:36 <shapr> Spiffy
09:53:39 <shapr> Hiya savanni
09:53:50 <savanni> It's difficult because I'm *still* super-slow at Haskell coding.
09:54:15 <shapr> me too!
09:54:45 <bos> hi, andy
09:54:55 <shapr> Hiya Andy
09:55:02 <andygill> hi guys
09:55:06 <shapr> How's the N800?
09:55:34 <andygill> Still going fine; got various ajax apps working on it.
09:55:54 <benny> you like the n800?
09:56:45 <andygill> yes, but still wish it was easier to write apps for.
09:57:04 <bos> it's a fairly closed environment, given how much gnome etc factors into it.
09:57:06 <shapr> stepcut built GHC 6.5 for it once.
09:57:20 <benny> I liked the n770 more, I think the n800 is too bulky for not so many extra features
09:57:38 <shapr> benny: I'd really like to have the double memory and speed.
09:58:23 <benny> shapr: of course, that would be nice... I mainly used it as an ebook reader, it was pretty neat for that.
09:58:58 <shapr> I mostly use it to read research papers, but it's way slow at loading PDFs.
09:59:13 <shapr> andygill: How's code treating you?
09:59:31 <benny> did you use this alternative pdf reader? (can't recall the name, but is apparently well known)
09:59:47 <shapr> I've tried evince, yeah.
09:59:58 <benny> no, it wasn't evince, it was something else... let me see
10:00:45 <EvilTerran> benny, foxit?
10:00:59 <EvilTerran> ghostscript+gsview?
10:01:11 <benny> oh, I thought about fbreader, but it doesn't support pdf
10:02:43 <joelr1> is there a capitalize function that operates on strings?
10:03:13 <joelr1> @hoogle upcase
10:03:13 <lambdabot> No matches found
10:03:17 <twanvl> > map toUpper "abc"
10:03:21 <lambdabot>  "ABC"
10:03:27 <ddarius> "foo" -> "Foo" or "foo" -> "FOO" ?
10:03:31 <joelr1> twanvl: just the first letter
10:03:47 <joelr1> capitalize the first letter, my apologies
10:04:08 <andygill> The pdf reader for n800 is a big slow, but the html renderer is good.
10:04:26 <andygill> s/big/bit/
10:04:33 <ddarius> > unwords . map (\(c:cs) -> toUpper c:cs) . words $ "bar baz badoodle"
10:04:34 <lambdabot>  "Bar Baz Badoodle"
10:04:52 <joelr1> ddarius: yes, that's it
10:04:54 <twanvl> > (\(x:xs) -> toTitle x:xs) "abc"
10:04:55 <lambdabot>  "Abc"
10:05:02 <joelr1> @hoogle toTitle
10:05:03 <lambdabot> No matches found
10:05:16 <joelr1> > toTitle "foobar"
10:05:17 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
10:05:23 <joelr1> oh
10:06:40 <vali> hello
10:06:59 <joelr1> hi
10:08:28 <magnus_> hmm has anyone got push to work with darcs-server and gpg signing?
10:08:32 <ddarius> @index toTitle
10:08:32 <lambdabot> bzzt
10:09:55 <bos> @seen JaffaCake
10:09:56 <lambdabot> JaffaCake is in #haskell-soc, #haskell and #ghc. I last heard JaffaCake speak 2h 32m 33s ago.
10:12:01 <shapr> magnus_: Yeah, I used that for years with the darcs wiki tutorial.
10:12:07 <shapr> Er, not with gpg signing...
10:12:14 <shapr> But I have had gpg signing working separately.
10:13:10 <rmulliga> I'm sorry if this is a really dumb question, but I read through the entire prelude function list and I couldn't find something to translate Int -> String,  is there a standard function that does this?
10:13:24 <ndm> read
10:13:25 <ddarius> > show 3
10:13:33 <lambdabot>  "3"
10:13:40 * ndm reads things backwards
10:13:45 <ndm> @hoogle Int -> String
10:13:47 <lambdabot> Test.QuickCheck.configEvery :: Config -> Int -> [String] -> String
10:14:36 <EvilTerran> @hoogle a -> String
10:14:37 <lambdabot> Prelude.show :: Show a => a -> String
10:14:37 <lambdabot> Text.Html.prettyHtml :: HTML html => html -> String
10:14:37 <lambdabot> Text.Html.renderHtml :: HTML html => html -> String
10:14:50 <ndm> hoogle should get that, bad hoogle
10:15:40 <Saizan> will hoogle 4 do?
10:15:52 <rmulliga> ddarius: thanks
10:16:07 <ndm> Saizan, yes - definately
10:16:22 <ndm> Saizan, i have a new design which makes read the very first priority
10:17:10 <ndm> i am taking a break from my other work, and tonight is pure Hoogle 4 development time
10:17:18 <shapr> Reading is definitely my priority.
10:17:33 <Saizan> nice :9
10:17:54 <Saizan> ":)"
10:21:08 <shapr> It's a beautiful day in the neighborhood, a beautiful day for some code!
10:34:39 <magnus_> shapr: I used to use darcs-server without any gpg but that may be a bit unsecure
10:38:58 <kc5tja> @where xmonad
10:38:59 <lambdabot> I know nothing about xmonad.
10:39:05 <kc5tja> _O_
10:39:13 <kc5tja> O_O rather.
10:39:16 <sjanssen> huh?
10:39:19 <sjanssen> @where ghc
10:39:19 <lambdabot> http://haskell.org/ghc
10:39:24 <kc5tja> (the former is what happens when your eyes cross too far)
10:39:26 <arcatan> spoil: http://www.xmonad.org/
10:39:27 <lambdabot> Title: xmonad : a tiling window manager
10:39:33 <sjanssen> we must have lost some state
10:39:44 <shapr> magnus_: Yeah, it is but at the moment darcs is obscure enough to be left out of the spam deluge.
10:39:49 <kc5tja> sjanssen: That's because lambdabot is a pure functional bot.  ;D
10:39:50 <sjanssen> @where+ xmonad http://www.xmonad.org/
10:39:51 <lambdabot> Done.
10:39:53 <sjanssen> @where thunk
10:39:54 <lambdabot> I know nothing about thunk.
10:40:53 <shapr> magnus_: Still, I did get gpg working.
10:41:04 <shapr> @where+ thunk http://www.xmonad.org/
10:41:05 <lambdabot> Done.
10:44:43 <magnus_> shapr: you use ssh on xmonad?
10:45:56 <shapr> huh?
10:46:03 <shapr> I use xmonad on my desktop.
10:47:34 <magnus_> I mean the xmonad darcs repository, sorry
10:47:52 <magnus_> oh wait, you are not an xmonad author
10:48:03 <magnus_> I confused a few things :)
10:49:30 <shapr> No, I'm just an ethusiastic user.
10:49:39 <shapr> But I do use darcs over ssh for lots of repos.
10:50:02 <opqdonut> yeah it's handy
10:50:35 <magnus_> and when you collaborate you create more ssh users or you use email?
10:51:01 <fantasmaa> does xmonad still support the Mod-Tab hotkey even though it is the same as Mod-J
10:51:16 <dmwit> fantasmaa: It is trivial to add it yourself.
10:51:24 <shapr> magnus_: For the moment we're using ssh pubkeys and a shared developer account.
10:51:24 <sjanssen> fantasmaa: it does
10:53:41 <magnus_> shapr: Ah, that is an interesting solution
10:53:42 <shapr> Random useless question.. how many arrows could you get on a single legal line of code?
10:54:00 <shapr> I can see using -> <- -< on the same line, but not more.. is there a way to get more?
10:54:30 <sjanssen> I'm sure you could use >>> too
10:54:42 <sjanssen> and >>= if you get inventive
10:56:36 <hpaste>  joelr1 pasted "how would you refactor this?" at http://hpaste.org/1548
10:56:45 * joelr1 needs some help with refactoring
10:56:51 <joelr1> any suggestions?
10:56:59 <bos> @hoogle count
10:57:00 <lambdabot> Text.ParserCombinators.ReadP.count :: Int -> ReadP a -> ReadP [a]
10:57:00 <lambdabot> Text.ParserCombinators.Parsec.Combinator.count :: Int -> GenParser tok st a -> GenParser tok st [a]
10:57:00 <lambdabot> Test.HUnit.Base.counts :: State -> Counts
10:57:12 <shapr> magnus_: There's another simpler solution.. instead of having developers push to the server, have a cron job pull from their repos every hour or so.
10:57:29 <bos> joelr1: use maybe?
10:57:34 <shapr> magnus_: That way you don't need any user accounts or other complexity.
10:57:38 <joelr1> bos: what do you mean?
10:57:41 <joelr1> exactly
10:58:11 <dmwit> :t maybe
10:58:13 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
10:58:33 <bos> joelr1: maybe (return []) (morph e) (C.fromEntryName order)
10:59:14 <bos> although your code is weird; it's rebinding args 3 times.
10:59:26 <joelr1> bos: yeah, i'm translating my ocaml code :-(
10:59:32 <dmwit> I think it can be better with some (>>=) in the Maybe monad.
10:59:33 <joelr1> dmwit: thanks
10:59:38 <joelr1> dmwit: how?
10:59:47 <joelr1> it's the end of the day and i have a mental block
10:59:57 <dmwit> I'm thinking, give me a sec.
11:00:26 <vali> hmm, someone said that haskell doesn't support OO. however, this tutorial i'm reading keeps talking about instances and classes?
11:00:28 <bos> no, it's potentially augmenting args each time.
11:00:32 <joelr1> i'm, basically, building up the args of a function from a record. the args must be in sequence
11:00:43 <bos> so if you use the Maybe monad, it will drop out instead of augmenting the list.
11:00:47 <allbery_b> vali: typeclasses are not quite like standard OO
11:00:56 <joelr1> bos: right. if some things are missing then nothing is added
11:01:12 <vali> allbery_b: ah, so it's called typeclasses
11:02:29 <dmwit> ?hoogle Maybe a -> [a]
11:02:30 <lambdabot> Maybe.maybeToList :: Maybe a -> [a]
11:03:14 <joelr1> i guess i could create a whole bunch of args lists, some of which could be empty. once i concatenate them at the end it's not gonna matter
11:03:21 <joelr1> it's gonna be a single list
11:03:52 <joelr1> in that case it's always the same pattern: return empty list if nothing, run morph on the value otherwise
11:04:24 <dmwit> That would probably be the most abstractable way to do it.
11:04:45 <joelr1> right, a whole bunch of maybe runs
11:05:04 <joelr1> fair enough, thanks!
11:07:22 <fantasmaa> @tell dons I am nearly finished creating a man page for xmonad.
11:07:22 <lambdabot> Consider it noted.
11:08:16 <hpaste>  joelr1 annotated "how would you refactor this?" with "refactored" at http://hpaste.org/1548#a1
11:08:26 <joelr1> something like this, i think
11:08:34 * shapr throws more sugar lambdas
11:09:51 <joelr1> ?src maybe
11:09:51 <lambdabot> maybe n _ Nothing  = n
11:09:52 <lambdabot> maybe _ f (Just x) = f x
11:10:41 <hpaste>  bos annotated "how would you refactor this?" with "(no title)" at http://hpaste.org/1548#a2
11:11:22 <hpaste>  bos annotated "how would you refactor this?" with "oopsie" at http://hpaste.org/1548#a3
11:12:05 <joelr1> bos: awesome. i think i would generalize it over maybe as well, to be able to supply another "discriminator"
11:12:09 <joelr1> instead of maybe
11:12:14 <joelr1> bos: thanks
11:12:21 <bos> yep
11:13:13 <EvilTerran> @pl \f g -> f . ?foo . g
11:13:14 <lambdabot> (line 1, column 13):
11:13:14 <lambdabot> unexpected "?"
11:13:14 <lambdabot> expecting space or simple term
11:13:25 <EvilTerran> @pl \f g -> f . undefined . g
11:13:25 <lambdabot> (. (undefined .)) . (.)
11:13:33 <EvilTerran> ew.
11:17:25 <dmwit> Often, if it is complicated enough for you to need ?pl, it won't turn out very pretty... =P
11:19:41 <EvilTerran> i was merely confirming my suspicions that it was as badas i thought
11:20:05 <Cheery> yeah!
11:20:26 <Cheery> I made my first wiki parser I've ever done.
11:20:40 <Saizan> can changing kernel cause ghc compiled binary to not work?
11:20:53 <Cheery> as the reward I got some html
11:21:39 <Cheery> thought, could you reward me and tell me how could I write my parser better? I paste the sources here soon
11:21:54 <sjanssen> EvilTerran: you can "optimize" that to const undefined
11:22:19 <hpaste>  Cheery pasted "This is the source code of my hikiwiki parser." at http://hpaste.org/1549
11:22:19 <sjanssen> Saizan: probably not
11:22:22 * kc5tja begins the installation process for xmonad on my local workstation...
11:22:59 <Saizan> "PAP object entered"
11:23:01 <hpaste>  Cheery annotated "This is the source code of my hikiwiki parser." with "This is the test page of the very same parser." at http://hpaste.org/1549#a1
11:23:03 <EvilTerran> sjanssen, i'm after something that works for (\f g -> f . foo . g). i merely stuck undefined in for lack of anything else to put in its place, given that it seems to not like implicit parameters.
11:23:48 <eumenides> @pl \f h -> f . g . h
11:23:49 <lambdabot> (. (g .)) . (.)
11:24:47 <MarcWebe1> sjanssen: How do you do? Did you get my last messaages? If you have some minutes left you can ping me again. If you are no longer interested because of alternatives / no time that's fine too. Just give me a sign.
11:24:52 <hpaste>  Cheery annotated "This is the source code of my hikiwiki parser." with "this is the sample output of my wikitext parser." at http://hpaste.org/1549#a2
11:26:29 <Cheery> so, ways to write it better?
11:27:12 <kc5tja> And it's failing miserably already.  :(
11:27:12 <dmwit> Wow, does that HTML actually render in browsers?
11:27:28 <Cheery> dmwit: I tried, yes it does!
11:27:33 <kc5tja> Trying to set up X11 package, and when running runghc Setup.py configure, I get these errors:
11:27:39 <kc5tja> ./Setup.hs:16:18: Not in scope: `buildHook'
11:27:39 <kc5tja> ./Setup.hs:17:30: Not in scope: `buildHook'
11:27:41 <kc5tja> Any ideas?
11:27:49 <kc5tja> GHC 6.4.1, by the way.
11:27:58 <Cheery> but true, it's not correct hence lacking the header and body
11:28:49 <sjanssen> kc5tja: only the standard advice: "upgrade cabal"
11:28:51 <Cheery> I think making those small tiny details just correct is the thing I'll do after everything else is well in that code
11:29:02 <sjanssen> you can upgrade Cabal independently of GHC, if you'd like
11:31:31 <Cheery> token scanner pummeled together from Parsec monads is quite big part of that, I think it would also give me headache if working long with this project without rewriting it, do you know some better modules for combining such token scanner my hikiwiki -syntax benefits from?
11:32:39 <bos> should cabal be running hsc2hs for me?
11:32:47 <fantasmaa> if it finds it
11:33:07 <bos> huh. i'm trying to build HsSyck, and it's barfing because the sole source file is a .hsc file.
11:33:37 <fantasmaa> you can use --with-hsc2hs=PATH to specify a path to the binary
11:33:47 <sjanssen> bos: it's always worked transparently for me
11:34:07 <bos> yeah, it finds hsc2hs in /usr/bin, but it doesn't run it.
11:34:28 <fantasmaa> bos: what version of cabal?
11:34:33 <bos> current darcs head.
11:34:59 <Cheery> @where lexer
11:35:00 <lambdabot> I know nothing about lexer.
11:35:11 <bos> looks like a regression. cabal 1.1.6 at least gets a little bit through the build.
11:36:10 <fantasmaa> darcs head has only solved the problems from 1.1.6
11:36:15 <fantasmaa> for me at least
11:36:20 <joelr1> ?src maybe
11:36:21 <lambdabot> maybe n _ Nothing  = n
11:36:21 <lambdabot> maybe _ f (Just x) = f x
11:38:00 <bos> oh, my bad.
11:38:45 <sjanssen> should configure.ac be in a source distribution, if configure is already included?
11:39:10 <bos> yes.
11:39:22 <bos> it's normal to have both.
11:40:45 <joelr1> @undo do { e <- f; return [ e ]; }
11:40:46 <lambdabot> f >>= \ e -> return [e]
11:41:32 <sjanssen> @type \f -> fmap (return . return) f
11:41:33 <bos> @users
11:41:35 <qz> c
11:41:35 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *) (f :: * -> *). (Monad m, Monad m1, Functor f) => f a -> f (m (m1 a))
11:41:35 <lambdabot> Maximum users seen in #haskell: 329, currently: 311 (94.5%), active: 51 (16.4%)
11:42:06 <sjanssen> @type \f -> fmap return f -- only one return
11:42:09 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f a -> f (m a)
11:42:32 <joelr1> sjanssen: is that for me?
11:43:01 <sjanssen> joelr1: yep
11:43:21 <sjanssen> @type liftM (:[]) -- also equivalent
11:43:24 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m [a1]
11:43:35 <joelr1> :t (:[])
11:43:38 <lambdabot> forall a. a -> [a]
11:43:55 <joelr1> sjanssen: thanks
11:45:26 <fantasmaa> sjanssen: do you have a list of files that xmonad modifies?
11:46:49 <sjanssen> fantasmaa: modifies?  none
11:47:27 <fantasmaa> the configuration file is compiled into xmonad, like dwm, yes?
11:48:31 <sjanssen> right
11:51:49 <fantasmaa> any known bugs?
11:54:33 <monochrom> (:[]) looks like someone wanting to devour the input.  And indeed, mapping from x to [x] is devouring. :)
11:55:01 <emu> the list monster
11:55:08 <EvilTerran> i tend to say unhead = (:[]) or sth for clarity...
11:55:11 <emu> map return
11:55:32 <nominolo> :t map return
11:55:38 <lambdabot> forall a (m :: * -> *). (Monad m) => [a] -> [m a]
11:56:00 <EvilTerran> map return 1
11:56:04 <EvilTerran> > map return 1
11:56:05 <lambdabot>   add an instance declaration for (Show (m a))
11:56:18 <emu> > map return 1 :: [[Int]]
11:56:19 <lambdabot>   add an instance declaration for (Num [Int])
11:56:26 <emu> > map return [1] :: [[Int]]
11:56:28 <EvilTerran> > return 1 :: [a]
11:56:28 <lambdabot>  [[1]]
11:56:29 <lambdabot>   add (Num a) to the expected type of an expression
11:56:55 <emu> @src return List
11:56:56 <lambdabot> Source not found. It can only be attributed to human error.
11:57:05 <emu> @help src
11:57:06 <lambdabot> src <id>. Display the implementation of a standard function
11:57:20 <emu> @src return []
11:57:21 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
11:57:26 <emu> i have considered it
11:58:13 <vali> hmm. is (f . g) 5 the same as f(g(5)) ?
11:58:23 <sjanssen> vali: yes
11:58:35 <monochrom> Sweet .
11:58:44 <sjanssen> @pl f(g(5))
11:58:45 <lambdabot> f (g 5)
11:58:48 <vali> sjanssen: oh. are both ways legal in haskell?
11:58:53 <sjanssen> @pl (f . g) 5
11:58:54 <lambdabot> f (g 5)
11:59:00 <opqdonut> @pl \x -> f (g x)
11:59:01 <lambdabot> f . g
11:59:03 <quicksilver> vali: "." isn't special syntax, actually
11:59:04 <opqdonut> there
11:59:11 <quicksilver> vali: "." is just an 'ordinary' operator
11:59:13 <opqdonut> ?src (.)
11:59:14 <lambdabot> (.) f g x = f (g x)
11:59:16 <opqdonut> there
11:59:24 <sjanssen> vali: yes
11:59:40 <fantasmaa> sjanssen: are there any known bugs with xmonad 0.1?
11:59:52 <opqdonut> vali: well g(5) is really just g (5) which is g 5
12:00:01 <opqdonut> (if that was what your "both ways" meant)
12:00:50 <monochrom> space is special syntax :)
12:01:22 <sjanssen> fantasmaa: numlock handling is broken in 0.1, but fixed in darcs
12:01:29 <shapr> mmm code
12:01:36 <opqdonut> monochrom: a shame that, really
12:01:41 <opqdonut> :src ( )
12:01:46 <opqdonut> would be just over-cool
12:01:52 <opqdonut> ?src ( )
12:01:52 <lambdabot> Source not found. stty: unknown mode: doofus
12:01:55 <opqdonut> :/
12:02:12 <quicksilver> nah, function application is fundamental. That's fine with me
12:02:24 <monochrom> Well, something has to be special syntax, otherwise you can't bootstrap non-special operators.
12:02:58 <quicksilver> you need something to separate identifiers too
12:03:03 <quicksilver> otherwiseallyourprogramslooklikethis
12:03:04 <EvilTerran> it's &ApplyFunction; :)
12:03:10 <opqdonut> well, separating can be done wiht lexer
12:03:17 <opqdonut> ala f.g
12:03:22 <quicksilver> opqdonut: and, indeed, space is handled by the lexer
12:03:29 <opqdonut> yes, of course
12:05:26 <bos> sjanssen: is it accidental that X11-extras tarball doesn't contain a configure script?
12:05:35 <sjanssen> bos: yes
12:05:46 <bos> ok.
12:05:59 <sjanssen> we fudged that release a bit.  The 0.0 version is an accident too :(
12:06:04 <monochrom> For me, I'm glad the special syntax of haskell is minimal and close to the foundation of computing, i.e., like quicksilver says, a special syntax for function application, the rest can be built on top.  Consider, in contrast, most languages make sequential composition ";" special.  dons's blog entry "programmable semicolon" puts this into perspective.
12:07:00 <opqdonut> weeel, for a procedural language ; isn't really "special syntax"
12:08:05 <EvilTerran> (;) is kinda like (>>=)
12:08:10 <flux> monochrom, well, with stuff like pattern matching and type classes I wouldn't say it's "minimal".. but I don't see why it should be.
12:08:20 <monochrom> The corresponding Haskell operator is >>= and it's re-programmable.  Can't say the same of many other languages.
12:08:52 <monochrom> Ha, ok, not minimal, but close to foundation.
12:08:53 <flux> lisp is much more minimal than haskell :)
12:09:06 <EvilTerran> haskell is purer than lisp
12:09:26 <EvilTerran> functional-programming-wise
12:09:34 <flux> I suppose there could be a pure variant of lisp, and infact isn't ACL2 one
12:09:43 <opqdonut> monochrom: yeah but functional programming is a very different approach
12:09:51 <flux> I'm not sure if anyone's build any useful software with ACL2, though
12:10:04 <opqdonut> i'd say haskell's guards for example are unneeded special syntax
12:10:20 <opqdonut> pattern matching should also be made more general etc
12:10:24 <EvilTerran> if' True = const; if' False = flip const
12:10:27 <opqdonut> how about \ and -> ?
12:10:35 <opqdonut> EvilTerran: exactly
12:10:49 <monochrom> Haskell is a functional language, yes.  But the notion of "what should be fundamental, what should be programmable" transcends that classification.
12:11:12 <opqdonut> yes, and i did refer to pattern matching and guards
12:11:38 <EvilTerran> i'm slightly skeptical of the use of guards.
12:11:50 <EvilTerran> utility-vs-complexity
12:12:16 <EvilTerran> (by "complexity", i mean that added to syntax and whatnot)
12:12:33 <opqdonut> same here
12:13:18 <emu> i actually prefer guards. if-then-else is just clunky in haskell syntax.  i don't know why i feel that way.
12:13:33 <EvilTerran> altho i guess it's helpful to be able to do arbitrary conditions in a case
12:14:56 <EvilTerran> otherwise trying to do sth like "case xs of { x:_ | x > 10 -> (...) | otherwise -> (...); [] -> (...) } would be awkward
12:15:22 <EvilTerran> (in more complex cases, naturally)
12:15:26 <monochrom> Where is dons's "programmable semicolon"?
12:15:30 <roconnor> (if' True then id else flip) const
12:15:47 <EvilTerran> roconnor, what?
12:15:49 <roconnor> (if' b then id else flip) const
12:16:06 <roconnor> @pl \b -> (if' b then id else flip) const
12:16:07 <lambdabot> (line 1, column 14):
12:16:07 <lambdabot> unexpected reserved word "then"
12:16:07 <lambdabot> expecting variable, "(", operator or ")"
12:16:26 <roconnor> @pl \b -> (if' b id flip) const
12:16:26 <lambdabot> flip (flip (flip if' id) flip) const
12:16:38 <ulfdoz> what's "if'"?
12:16:39 <thedward> @google haskell programmable semicolon
12:16:41 <lambdabot> http://www.cse.unsw.edu.au/~dons/blog
12:16:41 <EvilTerran> :t if'
12:16:41 <lambdabot> Title: Haskell hacking
12:16:50 <lambdabot> forall a. Bool -> a -> a -> a
12:16:55 <EvilTerran> @src if'
12:16:55 <lambdabot> Source not found. Where did you learn to type?
12:17:00 <monochrom> it is http://cgi.cse.unsw.edu.au/~dons/blog/2007/03/10
12:17:01 <lambdabot> Title: Haskell hacking
12:17:03 <ulfdoz> axo
12:17:06 <roconnor> if' is only defined for @pl
12:17:19 <EvilTerran> if' True then' else' = then'; if' False then' else' = else'
12:17:56 * allbery_b should wear a sign: "human fuzzer"
12:17:58 <vali> what is most commonly used for writing GUI applications in haskell?
12:18:05 <EvilTerran> or, if you prefer, if' True = const; if' False = flip const
12:18:07 <monochrom> Inside the text, somewhere he will mention "a monad gives us a programmable ';' (the semicolon statement terminator from the imperative world)"
12:18:30 <Philippa> allbery_b: is that related to fluffer? :-)
12:18:59 <allbery_b> no.  security term, a fuzzer is a program which feeds random input to another program or service to try to make it crash
12:19:20 <allbery_b> I seem to be hitting all the unimplemented and/or partially implemented features of gtk2hs :/
12:20:32 <roconnor> @type flip (flip (flip if' id) flip) const
12:20:35 <lambdabot> forall b. Bool -> b -> b -> b
12:39:41 <roconnor> hmm
12:39:47 <roconnor> where is haskell-gtk?
12:40:01 <roconnor> isn't there a debian package?
12:40:48 <ventonegro> libghc6-gtk-dev
12:41:03 <Heffalump> the main package his gtk2hs
12:41:06 <Heffalump> s/his/is/
12:42:33 <roconnor> hmm, it's not it the ubuntu repositories for edgy
12:42:40 <roconnor> at least I can't find it
12:43:13 <ventonegro> look for libghc6-
12:45:03 <hpaste>  assl0r pasted "(no title)" at http://hpaste.org/1550
12:45:07 <roconnor> the closest I find is libghc6-x11-dev virtual package ... which is empty
12:45:15 <ventonegro> weird
12:45:23 <shapr> I love doing macrobatics in elisp!
12:45:31 <ventonegro> i use debian and there is lots of libghc6-*
12:45:40 <roconnor> yep, I have tonnes
12:45:42 <ventonegro> s/is/are/
12:45:46 <roconnor> but no gtk :(
12:46:14 <matthew-_> I have 4. This is Debian unstable
12:46:22 <ventonegro> switch to debian :-)
12:50:50 <roconnor> ah libghc6-glib-dev is in Feisty not Edgy
12:52:23 <roconnor> and libghc6-gtk-dev
12:54:46 <hpaste>  andun pasted "GHC problems" at http://hpaste.org/1551
12:56:21 <shapr> I just heard someone saying "God bless STM."
12:56:22 * shapr grins
12:57:02 <matthew-_> sadly, God won't commit to such technologies.
12:57:07 <shapr> @quote STM
12:57:08 <lambdabot> Lemmih says: God bless STM!
12:57:13 <matthew-_> geddit! commit! geddit!
12:57:14 * shapr laughs
12:57:36 <shapr> I really want to make retry and rollback jokes now...
12:57:48 <matthew-_> well you could try...
12:57:53 * matthew-_ is on a roll!
12:57:54 <sjanssen> shapr: don't do it `orElse`
12:58:49 <matthew-_> ahh, #haskell: the only place where self recursive jokes are considered "good form".
12:59:37 <TRWBW> howdy. is language warring allowed here?
12:59:57 <capisce> as in?
13:00:00 <roconnor> can we write haskell poetry using haskell keywords?
13:00:04 <TRWBW> as in C is better than haskell
13:00:07 <Heffalump> if you asked first, you'll probably be polite and measured enough for it to be reasonable.
13:00:08 <sjanssen> make love, not war
13:00:08 <roconnor> an make an executable program?
13:00:11 * sjanssen wouldn't mind make -j3 love
13:00:37 <Heffalump> though I don't think the issue has come up before
13:00:50 <TRWBW> well as i see it, haskell programs end up burying their iteration in recursion, which just makes it obscure. better to put the iteration and change of global state directly in the language.
13:00:54 <shapr> TRWBW: I don't think anyone on #haskell will mind if you believe that C is better than Haskell.
13:01:13 <black_13> does haskall have the ability to persist object state?
13:01:16 <shapr> TRWBW: Why or how is iteration better than recursion?
13:01:26 <roconnor> @type newIOref
13:01:29 <lambdabot> Not in scope: `newIOref'
13:01:32 <roconnor> @type newIORef
13:01:33 <shapr> black_13: yup
13:01:34 <lambdabot> Not in scope: `newIORef'
13:01:40 <Heffalump> I don't think using recursion versus iteration is one of the main "selling points" of Haskell
13:01:40 <roconnor> @hoogle newIORef
13:01:42 <lambdabot> Data.IORef.newIORef :: a -> IO (IORef a)
13:01:57 <black_13> shapr, interestign how does it do that?
13:01:58 <Heffalump> but if you really think it should be in _global_ state, are all your loop variables local?
13:02:02 <TRWBW> shapr: they are equivalent. but people end up burying global state and iteration in haskell anyway, to get the job done. they recursively pass through something that gets modified on return to be "global state", and use tail recursion for iteration.
13:02:08 <shapr> TRWBW: Also, there are several reasons to not change global state in the language.
13:02:10 <TRWBW> shapr: it's like obfuscated C
13:02:24 <shapr> TRWBW: Or maybe C programmers write obfuscated Haskell?
13:02:31 <roconnor> Global state is sooooo 1970's
13:02:35 <shapr> From my viewpoint everything in C has an implicit IO signature.
13:02:39 <TRWBW> shapr: my point is, global state is a useful feature. real programs end up using it.
13:03:01 <shapr> TRWBW: What's the difference between local and global state?
13:03:05 <Heffalump> TRWBW: and the Haskell viewpoint is that it's better for it to be as explicit as possible when you do have to do it.
13:03:06 <TRWBW> shapr: you gonna say that IRC client you are using now isn't best thought of as global state?
13:03:09 * sjanssen points out that global state is possible in Haskell
13:03:12 <andun> i'm a little frustrated about ghc now. i put my code (and the few error messages i got) on hpaste (http://hpaste.org/1551). if anyone could help me, i'd appreciate it.
13:03:17 <matthew-_> TRWBW: for distributed systems, global state is meaningless as you'll never be able to usefully achieve global concensus
13:03:21 <TRWBW> sjanssen: i'm agreeing, but it does it in an ughly way
13:03:43 <Heffalump> but perhaps discouraging it is a good thing (if you do think it's ugly, which I don't)
13:03:45 <TRWBW> matthew-_: of course you can, you just use relaxed constancy constraints and locks
13:03:49 <shapr> TRWBW: I disagree, in Haskell I write small functions that wander around and operate on a big global state.
13:03:56 <Heffalump> people are encouraged to structure their code to avoid global state
13:04:04 <Heffalump> not forced, encouraged
13:04:18 <sjanssen> andun: obviously that first error is not your fault
13:04:33 <TRWBW> Heffalump: that's my point. in C functions are second class citizens. that's probably bad. but in haskell global modifiable state is a second class citizen. equally bad.
13:04:34 <roconnor> andun: ghc --make Server.hs
13:05:16 <Heffalump> well, I think global modifiable state is dangerous and worthy of being treated with care
13:05:27 <andun> roconnor: oh, thanks. i was looking for something like that.
13:05:36 <Heffalump> but I'd also dispute that it's a second class citizen in Haskell. It's just not implicit.
13:05:44 <TRWBW> Heffalump: i don't see it as bad or good. it's a technique.
13:05:50 <matthew-_> I think that as we move to greater levels of concurrently, any shared mutable state is a desaster.
13:06:01 <koala_man> TRWBW: how do you like scheme?
13:06:06 <capisce> TRWBW: why is global state so critical?
13:06:08 <TRWBW> koala_man: mem
13:06:09 <Heffalump> and Haskell offers more powerful ways of encapsulating it than C does
13:06:16 <Heffalump> (for example the ST monad)
13:06:41 <sjanssen> I'd argue that state is actually a second class citizen in C
13:06:53 <TRWBW> capisce: because programs interact with the real world, including the user.
13:07:11 <TRWBW> capisce: and because people think in terms of time, change.
13:07:17 <capisce> that's message passing, not global state
13:07:24 <Heffalump> I think you are conflating global state and user interaction.
13:07:39 <sjanssen> there is absolutely no mechanism for reasoning about your state in C.  In Haskell we have all sorts of tools local state like the State monad, guaranteed safe state by ST, etc.
13:07:43 <Heffalump> Haskell programmers learn to think in terms of dependency. That's just as natural once you get used to it.
13:07:45 <matthew-_> TRWBW: why does the need for unregulated global mutable state follow from the need to interact with "the real world"?
13:08:00 <roconnor> IO has a notion of time, and every monad has a notion of sequence (aka change).
13:08:08 <roconnor> @hoogle time
13:08:09 <lambdabot> System.Time :: module
13:08:09 <lambdabot> Time :: module
13:08:09 <lambdabot> System.Locale.time12Fmt :: TimeLocale -> String
13:08:14 <TRWBW> matthew-_: do you know what "putting words in someone's mouth" means?
13:08:18 <roconnor> @hoogle getTime
13:08:19 <lambdabot> No matches found
13:08:24 <roconnor> hmmm
13:08:30 <roconnor> or maybe not ;)
13:09:17 <roconnor> @hoogle getClockTime
13:09:17 <lambdabot> Time.getClockTime :: IO ClockTime
13:09:20 <roconnor> :)
13:09:55 <sjanssen> TRWBW: "because people think in terms of time, change."  I don't quite agree with this.  There are several ways to think about programs, each method useful for a different task
13:10:14 * roconnor thinks in terms of time travel.
13:10:27 <matthew-_> @seen sorear
13:10:27 <lambdabot> I saw sorear leaving #darcs, #haskell-overflow, #haskell-blah, #ghc, #haskell and #haskell-soc 14h 45m 52s ago, and .
13:10:31 * vali cheers at roconnor 
13:10:50 <chessguy> hi haskellers
13:10:54 <chessguy> ?map
13:10:55 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
13:10:56 <sjanssen> TRWBW: functional programming's reduction model is highly useful for very many tasks
13:11:02 <chessguy> @bot
13:11:03 <lambdabot> :)
13:11:23 <TRWBW> sjanssen: i don't deny that. but global state and iteration is very natural. read a recipe. they've been around for thousands of years, and they aren't written: soup=simmer(40 minutes,unsimmered_soup)
13:12:10 <roconnor> soup = simmer 40 =<< unsimmered_soup
13:12:29 <vali> TRWBW: some things, e.g. mathematics, are not organized like recipes
13:12:40 <sjanssen> TRWBW: and Haskell has the ability to express these imperative/mutable concepts as well
13:13:07 <TRWBW> sjanssen: in terms of what? passing an object through a recursion so that it is modified on each return?
13:13:22 <TRWBW> sjanssen: where modified = replaced
13:13:24 <sjanssen> TRWBW: using a monad of some sort
13:14:28 <chessguy> by the way, if you think recursion and iteration are equivalent, you should try doing a tree traversal both ways
13:14:41 <sjanssen> State (which is the automated version of passing through recursion and yielding a new result), or ST/IO (which provide essentially the same mutable variable model as C and the like)
13:16:28 <TRWBW> sjanssen: like i said, second class citizens
13:16:31 <matthew-_> are there compilers that turn iteration into tail-call recursion?
13:16:33 <roconnor> > execState (replicateM_ 100 (+1)) 0
13:16:35 <lambdabot>      The section `(+ 1)' takes one argument,
13:16:35 <lambdabot>     but its type `State s a' has...
13:16:47 <sjanssen> TRWBW: no, first class citizens!
13:16:50 <roconnor> > execState (replicateM_ 100 (modify (+1))) 0
13:16:52 <lambdabot>  100
13:17:17 <roconnor> > execState (replicateM_ 100 (modify (*2))) 1
13:17:18 <lambdabot>  1267650600228229401496703205376
13:17:19 <TRWBW> sjanssen: why not just code up a haskell "C intepreter" and code in C?
13:17:20 <sjanssen> TRWBW: you can't discount Haskell just because the core functionality is powerful enough to express a State monad -- that doesn't make sense
13:17:41 <TRWBW> well i've made my points. seems like everyone here is drinking the kool-aid.
13:17:46 <sjanssen> TRWBW: I program in Haskell because I don't like the Cish mindset :)
13:17:50 <ventonegro> TRWBW, hehehe
13:18:02 <ventonegro> these discussions are usually pointless
13:18:14 <chessguy> TRWBW: what do you expect?
13:18:38 <ventonegro> people like TRWBW  think we are masochists that try to push on others, and it's not entirely their fault
13:18:39 <qebab> nothing good ever comes out of a 'which language is better out of x and y'
13:18:44 <qebab> they are too general
13:18:45 <chessguy> you can't really believe you're going to show up in here and show us all the "error" of our ways, and we're all going to give up haskell
13:19:06 <qebab> different tools for different tasks
13:19:10 <assl0r_> how do i print the result of quickCheck from another function? show (quickCheck foo) collides with wrong types
13:19:20 <assl0r_> quickCheck returns IO
13:19:22 <sjanssen> @hoogle quickCheck
13:19:23 <lambdabot> Test.QuickCheck.quickCheck :: Testable a => a -> IO ()
13:19:23 <lambdabot> Test.QuickCheck :: module
13:19:30 <ventonegro> it's hard for people to realise the power we have here
13:19:32 <Gwern> doesn't quickcheck have an IO type of some sort?
13:19:32 <roconnor> The right way of attacking Haskell is to talk about it's memory usage.
13:19:40 * Gwern guesses so
13:20:03 <Gwern> roconnor: the right way to reply to that is to point out strict functions and profilers, no?
13:20:10 <sjanssen> assl0r_: quickCheck already prints out the test result, is that sufficient?
13:20:36 <matthew-_> the right way to attack the profilers is to point out the power of the debug tools that Erlang has and the fact that Haskell seems about 5 years behind.
13:20:57 <Gwern> sjanssen: maybe he wants to do something like call all the quickcheck tests inside main and do nothing if any fail?
13:20:58 <pejo> matthew, isn't Erlang strict?
13:21:12 <assl0r_> well, i think i cannot see the wood for the trees... ;)
13:21:51 <matthew-_> pejo: yep.
13:22:32 <matthew-_> pejo: but still. there's such a gulf of difference. And I realise it's harder etc, etc ...
13:22:48 <pejo> matthew, 'we' have been building tools for strict languages an awful long time compared to the lazy evaluated ones.
13:23:40 <matthew-_> mmm. true.
13:25:55 <rictic> HaskellNewbie question: I have a program that uses HSQL.  It runs fine with runhaskell, but I'm not sure how to point ghc to HSQL.  I get 'undefined symbol' errors when trying to compile with ghc.  I installed HSQL with the standard cabal instructions, and I'm using the sqlite3 subpackage[?] of HSQL in this program.
13:26:08 <sjanssen> rictic: compile with --make
13:26:48 <rictic> sjanssen: beautiful.
13:26:53 <rictic> Many thanks :)
13:31:25 <kc5tja> sjanssen: I'm sorry for the very late response.  I got called away into some meetings.  I'm looking into upgrading cabal now.
13:33:38 <shapr> Aww, I missed most of the TRWBW discussion because I was working!
13:33:50 <shapr> TRWBW: My fulltime job is Haskell, and I really enjoy it.
13:34:12 * kc5tja isn't having much luck with cabal; apparently the latest cabal requires GHC 6.6
13:34:14 <shapr> TRWBW: One thing I think might be correct is... "Use what fits your head. If you like Haskell, use it. If you like C, use it."
13:34:50 <matthew-_> shapr: what if they both fit?
13:34:55 <shapr> Then use 'em both.
13:35:01 <shapr> I use lots of tools, whatever fits the task best.
13:35:26 <shapr> TRWBW: Another thing could be, "It's hard to understand a programming language without using it for six months or real tasks or something."
13:36:04 <shapr> TRWBW: Would you like to try writing something in Haskell and see if it matches the points you made?
13:39:27 <kc5tja> shapr: Give up -- as far as I can read, TRWBW is trolling.
13:39:39 <qebab> indeed
13:39:43 <kc5tja> ventonegro claims that it's not entirely his fault, and I feel quite opposite that.
13:40:00 <kc5tja> I've _NEVER_ seen a single message from anyone claiming that Haskell is the one true language to end them all.
13:40:20 <sjanssen> I'll admit that I've thought it ;)
13:40:25 <kc5tja> And, I love Forth, and I am probably going to learn Scheme next.  But, still, Haskell has much to teach, if you're willing to listen.
13:40:31 <ventonegro> sjanssen, :-D
13:40:34 <Gwern> Haskell is the one true language
13:40:45 <kc5tja> Gwern: IS NOT!
13:40:47 <Gwern> all good languages are but corruptions or extensions of haskell
13:40:49 <sjanssen> @remember Gwern Haskell is the one true language
13:40:50 <lambdabot> Done.
13:40:55 <Gwern> bow before it, and learn its ways
13:41:08 <ventonegro> kc5tja, i stand corrected, it's his fault all right :-)
13:41:11 <chessguy> i think eventually, we will be able to say Haskell : C :: C : Assembly
13:41:14 <Gwern> kc5tja: is too!
13:41:28 <Gwern> chessguy: eventually?
13:41:38 <sjanssen> @remember Gwern all good languages are but corruptions or extensions of haskell
13:41:39 <lambdabot> Done.
13:41:40 <kc5tja> Gwern: no no no, if you're going to troll, you need all caps and more exclamation points.  Like this: IS TOooO!!1`~1`
13:41:42 <chessguy> if not now
13:41:43 <kc5tja> ;D
13:42:02 <Gwern> chessguy: that's more like it
13:42:06 <Gwern> kc5tja: no u.
13:42:10 <Gwern> UR DOING IT WRONG
13:42:10 <kc5tja> Hahah :)
13:42:24 <merus> Man, haskell continues to warp my mind O_o;;
13:42:26 <black_13> are there any libraries that (boost?) that give you haskell like abilities to c++
13:42:49 <kc5tja> merus: Good!  Then it's having precisely the intended effect.  That's the sensation of your mind growing and expanding beyond the capacity of your skull.
13:43:00 <Gwern> boost does some pretty neat stuff, but I think it adds more like regular functional programming stuff than peculiarly haskell-stuff
13:43:20 <kc5tja> Soon, you'll look like a Telosian, and you'll have the power to manipulate other people's perceptions with the greatest of ease.  The Matrix will have nothing on you.
13:43:23 <merus> I wish I had more problems to solve, though. Haskell doesn't help so much with philosophy :(
13:43:54 <emu> it doesn't?
13:43:57 <Gwern> merus: so rewrite something in haskell
13:44:04 <black_13> Gwern, i was hoping for something for object persistence
13:44:10 <emu> write a theorem prover
13:44:10 <Gwern> maybe some of the command line coreutils. that's good exercise
13:44:12 * kc5tja still hasn't debugged his Haskell implementation of CUT.
13:44:32 <chessguy> merus: give it a couple years :)
13:44:33 * kc5tja is just having a nightmare trying to figure it out, but I'm probably just going to start over from scratch with it.
13:44:40 <merus> chessguy, meh.
13:46:51 <kc5tja> Well, I just plain have to compile GHC.
13:47:05 <kc5tja> Unless the binaries include EM64T-compatible binaries.
13:49:10 <sjanssen> kc5tja: I believe there are generic Linux binaries for that architecture
13:50:21 <kc5tja> OOH...I can use GHC 0.29!
13:51:07 <sjanssen> I'm fairly certain that won't build xmonad
13:52:26 <augustss> ghc 0.29!
13:52:30 <kc5tja> I'm fairly certain it wouldn't even build itself.  ;)
13:52:43 <augustss> it couldn't
13:52:57 <TRWBW> so this is what you discuss in #haskell? problems getting it to build?
13:53:10 * TRWBW just asking
13:53:29 <augustss> problems getting a 1992 or so version to build :)
13:54:29 <augustss> we also discuss if the excessive use of monads causes global warming
13:54:50 <savanni> I even sometimes ask questions on how the language works.
13:54:57 <Gwern> TRWBW: no. usually it's more like abstruse discussions of monad transformers, type theory, and the best ways to use monads and higher order functions
13:55:10 <Gwern> (in my experience. and some discussions of applications like darcs, xmonad, or ghc)
13:55:11 <chessguy> lol. yeah, this compiler couldn't compile itself 15 years ago. it must be crap!
13:55:26 <shapr> TRWBW: I like to talk about unicycles too.
13:55:31 <chessguy> ?spell abstruse
13:55:59 <shapr> TRWBW: Seriously though, if you want to know why we like it so much, try it yourself for a month. I'd be happy to help you learn.
13:57:00 <Gwern> chessguy: what? abstruse is a valid word to use... even if this is IRC
13:57:14 <tibbe> but it's so slow, use C++ instead
13:58:18 <chessguy> Gwern: i was curious whether it was a real word or not. i've never heard it, and i'm a vocab geek
13:58:21 <shapr> merus: Actually, Haskell might be able to help with Philosophy
13:58:49 <chessguy> apparently it is. http://dictionary.reference.com/search?db=dictionary&q=abstruse
13:58:50 <lambdabot> Title: abstruse - Definitions from Dictionary.com
13:58:52 <shapr> merus: Have you seen http://www.linearity.org/cas/thesis/ ?
13:58:53 <chessguy> Gwern++
13:58:54 <lambdabot> Title: On the Formulae-as-Types Correspondence for Classical Logic
13:58:57 <Gwern> chessguy: pretty sure it is
13:59:22 <Gwern> chessguy: heh. "Because knowledge is power!"
13:59:36 <chessguy> indeed!
14:00:29 <shapr> chessguy: Outside my windows, this day looks crepuscular.
14:01:02 <Gwern> shapr: what a perfectly cromulent word
14:01:03 * chessguy giggles at shapr begging for superficial karma edification
14:01:49 <sjanssen> TRWBW: do you have doubts that Haskell is practical?
14:02:05 <Gwern> chessguy: I'm sure he did it jes' for the giggls
14:02:07 <Gwern> *giggles
14:02:28 <shapr> Let's see what random unusual words come to mind.. jaunt, mastication, sycophant, vitriolic, ichor, superheterodyne... hmm
14:02:40 * chessguy feels an ad for xmonad coming from sjanssen 
14:02:43 <sjanssen> TRWBW: http://xmonad.org/ is a window manager in Haskell.  You can't get more down to earth than that
14:02:44 <lambdabot> Title: xmonad : a tiling window manager
14:02:47 <sjanssen> chessguy wins!
14:02:51 <chessguy> hehehe
14:03:01 <savanni> oooooooo
14:03:05 <chessguy> what's the ration of LOC from C to haskell?
14:03:16 <emu> @TRWBW
14:03:17 <lambdabot> Unknown command, try @list
14:03:23 <Gwern> points for chessguy
14:03:32 <chessguy> uh
14:03:33 <chessguy> ratio
14:03:44 <dmwit> chessguy: For xmonad, I'm guessing it will only end up being about 2:1.
14:03:52 <sjanssen> emu: TRWBW hasn't put in enough time to get his own command :)
14:04:02 <TRWBW> sjanssen: nanoblogger has 5 times more google hits than xmonad
14:04:04 <sjanssen> @palomer
14:04:05 <lambdabot> That's a lie
14:04:09 <TRWBW> sjanssen: nanoblogger is written in bash
14:04:17 <emu> @protontorpedo
14:04:18 <lambdabot> some dude called topmind says that oo is bs
14:04:24 <dmwit> TRWBW: How old is nanoblogger?
14:04:25 <Gwern> dmwit: xmonad is ~500 LOC, I thought, and dwm was 2000 LOC, no?
14:04:40 <dmwit> Gwern: Right, but xmonad doesn't have a floating layer or a status bar yet.
14:04:40 <Gwern> so wouldn't that be 1:4 then?
14:05:17 <shapr> TRWBW: How is that relevant?
14:05:31 <sjanssen> TRWBW: I fail to see the relevance
14:05:42 <shapr> TRWBW: What's the essence of your question, do you think that Haskell isn't practical, do you think it's not efficient, or what?
14:05:46 <Gwern> dmwit: hmm. but the status bar was going to be a separate program according to sjanssen or someone, and I'm not sure what a floating layer is?
14:05:55 <shapr> TRWBW: Is there anything we can really measure?
14:06:09 <shapr> If it can't really be measured, it's just opinion.
14:06:26 <sjanssen> Gwern: xmonad isn't feature complete.  I'd say we'll exceed dwm's functionality at around 600 loc
14:06:52 <dmwit> Gwern: I think if you're going to compare LOC from two languages, you'd have to compare all the lines of code it takes one language to duplicate the featureset of the other language's program.
14:07:16 <Gwern> sjanssen: ok. but that's still not a 1:2 ratio - 600:2000
14:07:17 <shapr> In some cases that almost requires an interpreter of that other language.
14:07:28 <mauke> > 600%2000
14:07:34 <lambdabot>  3%10
14:08:54 <dmwit> shapr: Well, okay, that's a good point.
14:08:54 <augustss> > approxRational (600%2000) 1
14:08:56 <lambdabot>  0%1
14:09:40 <dmwit> So, LOC is just as slippery now as it always was.
14:09:59 <augustss> > approxRational (600%2000) 0.5
14:10:00 <lambdabot>  0%1
14:10:07 <dmwit> Anyway, it seems to me like Haskell wins the LOC battle only on algorithmically tricky stuff.
14:10:12 <shapr> TRWBW: So far you've said that global state and iteration are very natural. That's pretty hard to substatiate.
14:10:15 <augustss> > approxRational (600%2000) 0.1
14:10:17 <lambdabot>  1%3
14:10:34 <dmwit> For things that simply require interaction with libraries/the user, I think the win is much smaller.
14:10:51 <sjanssen> dmwit: you can't really beat C for xlib calls
14:10:57 <dmwit> right
14:11:06 <augustss> that's because xlib was made for C
14:12:07 <shapr> TRWBW: You also said that people hide iteration in recursion. I think recursion is more natural than iteration because recursion only requires function calls, where iteration requires more code.
14:12:29 <shapr> So, I claim that people hide recursion in iteration :-)
14:12:55 <Cale> And hey, people don't generally hide iteration in recursion. People hide higher order functions in iteration :)
14:13:17 <Cale> If what you're really writing is a map or filter, it's a shame to write it as a loop.
14:14:43 <Cale> Recursion has its place, but most programs which one would write as loops are actually maps, filters, or folds, with the occasional zip or zipWith.
14:15:27 <sjanssen> @where hmp3
14:15:28 <lambdabot> http://www.cse.unsw.edu.au/~dons/hmp3.html
14:19:06 <Nafai> I think using maps, filters, folds, etc actually encourages you to write smaller better-factored functions verses iteration where it is easy to put a large amount of code inside a for loop
14:20:18 <Cale> It's also just more expressive.
14:20:33 <Nafai> Indeed
14:22:00 <augustss> and once you can read it, i think it's also more understandable
14:22:00 <Cale> With a loop in an imperative language, I have to read through the entire loop body to figure out that iterations are independent of one another. With map, that becomes immediately obvious, regardless of what's going on.
14:23:11 <chessguy> i still want to see TRWBW's "natural" tree traversal, written iteratively
14:23:57 <chessguy> like i thought :)
14:24:04 <augustss> I guess he gave up
14:24:12 <xerox> Today I was coding in matlab, and I defined a function with two arguments, I then wanted to map that function, partially applied in its first argument, to a vector. The instructor argued that I should have been passing the *vector* as second argument to obtain the wanted result, but that forced me to modify the code I had written in first place by exchanging a * with a .* which is pointwise multiplication. The trick worked, but that is real
14:24:12 <merus> He never gives up.
14:24:12 <xerox> ly poor composability. Furthermore, the same trick didn't work for a more complex function, resulting in some headache.
14:25:10 <monochrom> I love compositionality.
14:25:14 <Cale> xerox: Do you happen to know if there's an explicit form of zipWith in matlab?
14:25:40 <Cale> Are functions even first class?
14:26:03 <Cale> I recall wanting zipWith and not being able to find one.
14:26:11 <xerox> I don't think so Cale, I couldn't find that information in the documentation.
14:26:13 <dmwit> Cale: Functions are passed by name.
14:26:16 <dmwit> =(
14:26:28 <augustss> wow, that sucks
14:26:34 <dmwit> As in, if you want the function rand, you pass "rand", then use eval.
14:27:31 <Cale> ugh
14:28:42 <xerox> I don't know if the following will work: function zs = zipWith(f, xs, ys); zs = xs .f ys;
14:28:52 <Maddas> dmwit: Is that really the only way?
14:29:08 <dmwit> Maddas: Yep, you really have to pass a string.
14:29:34 <xerox> I guess you are supposed to do f(xs,ys)?  I don't have matlab to try now.
14:29:52 <Cale> I get a syntax error in octave.
14:29:59 <dmwit> xerox: Neither of those quite match the semantics of zipWith.
14:30:11 <Cale> A language designed for matrix manipulation which doesn't have proper higher order functions seems crazy.
14:30:20 <dmwit> The first, even if it works (it doesn't) requires xs and ys to have the same dimensions.
14:30:20 <Maddas> dmwit: I think you are wrong
14:30:56 <Maddas> dmwit: This works perfectly fine, here: f = @(g) g(1); q = @(x) x + 1; f(q);
14:30:57 <dmwit> The second relies on f to already be vectorized, which it may not be.
14:31:03 <Maddas> does that really pass them as strings?
14:31:30 <szabi> If I have two different types (data T1 = T1 Int; data T2 = T2 [Float] Int) how can I use these in pattern matching?
14:31:33 <szabi> like:
14:31:33 <xerox> dmwit, it was explained to me that relying on functions to be already vectorized is the way matlab works.
14:31:42 <szabi> f (T1 i) = i
14:31:59 <szabi> f (T2 ls n) = n
14:31:59 <szabi> ?
14:32:02 <Maddas> xerox: Programming matlab seems to be mainly about finding the function that already does what you want :-)
14:32:03 <dmwit> xerox: Yes. =(
14:32:31 <Cale> ah, nice
14:33:09 <xerox> szabi, you define a class of types, |class Foo t where f :: t -> Int|; and then you instantiate your types |instance Foo T1 where f (T1 i) = i| |instance Foo T2 where f (T2 _ n) = n|.
14:33:18 <Maddas> dmwit: Is the function q really passed as a string in my example? It doesn't look like it to me, but I don't know anything about the internals
14:33:23 <mauke> szabi: you can't use two different types for the same variable
14:33:32 <szabi> hugs xerox
14:33:34 <szabi> auch
14:33:37 * xerox hugs back
14:33:37 <szabi> xerox: thanks
14:33:40 <dmwit> Maddas: I must be using an older version of Matlab, that doesn't work here.
14:33:41 <Cale> Maddas: it doesn't look like it, but thanks for pointing that out
14:33:50 <Cale> That works in octave.
14:34:10 <Maddas> (I tried it on my university account before pasting)
14:34:19 <nominolo> @seen SyntaxNinja
14:34:19 <lambdabot> SyntaxNinja is in #haskell, #darcs and #haskell-blah. I don't know when SyntaxNinja last spoke.
14:34:20 <dmwit> I believe you.
14:34:32 <xerox> Maddas, we are supposed not to use any predefined functions. You know, introductionary courses.
14:34:54 <Maddas> Oh, our introductory courses were mainly about finding the right predefined functions :-)
14:35:16 <Maddas> (Ok, not /mainly/, but you didn't end up rewriting existing routines AFAIK)
14:36:15 <nominolo> matlab is pretty messy
14:37:32 <Maddas> I find it really awfully messy, but I've only ever used it for courses. And whenever I felt like rewriting the code in a proper programming language, it became clear that even for my simple problems, the vast amount of existing Matlab code would take far too long to duplicate :-/
14:38:38 <nominolo> it has pretty useful built-in functions, but just like emacs lisp, rewriting stuff in a better language is too much effort
14:38:59 <dmwit> My worst nightmare is embodied in Matlab's max function.
14:39:02 <nominolo> i don't know octave.  is it nicer?
14:39:14 <Cale> It's free.
14:39:18 <nominolo> heh
14:39:26 <nominolo> so, not as good?
14:39:43 <Cale> I don't have enough experience with either one to be able to tell the difference.
14:40:00 <Cale> So far, they've seemed identical.
14:40:23 <nominolo> ok.  but i guess matlab has a lot more toolkits
14:40:35 <nominolo> afaik, that's why it's so successful
14:40:45 <Maddas> Yeah, I think Octave wouldn't have been very useful to me most of the time without the Matlab toolkits.
14:40:49 <nominolo> or, *still* so successful
14:41:00 <Maddas> I don't really use matlab for the basic math functions very often ;-)
14:42:03 * Maddas installs Octave anyway, thanks for the tip
14:42:15 <nominolo> i used it (rather, had to use it) for my BSc thesis
14:42:19 <nominolo> was boring ..
14:42:27 <Saizan> is there a possibility that a ghc built under 2.6.18 builds binaries that don't work well under 2.6.20? ive an happs server that doesn't seem to listen to its port..
14:43:10 <sjanssen> Saizan: these things shouldn't change across kernel versions
14:44:31 <SyntaxNinja> hi nominolo
14:44:43 <nominolo> hi SyntaxNinja
14:45:20 <SyntaxNinja> nominolo: do you get my private messages?
14:45:21 <nominolo> @localtime SyntaxNinja
14:45:38 <nominolo> @bot
14:45:39 <lambdabot> :)
14:45:47 <nominolo> ?
14:45:52 <nominolo> SyntaxNinja: yep
14:46:10 <Maddas> nominolo: all my Chalmers courses use Matlab, so they make us write e.g. LZW compression routines in it. Since most students (me included) don't know Matlab well, these group projects result in really horrible code :)
14:47:25 <nominolo> Maddas: i think most people don't know matlab very well, it seems.  or are not mainly programmers
14:47:28 <astrolabe> Horrible code is unavoidable in Matlab in my opinion.
14:47:55 <nominolo> Maddas: hejsan, en till Chalmerist .. :)
14:48:13 <xerox> Do we have some Haskell that generates Matlab code? :)
14:49:02 <vick> Hello, i'm trying to install haskell98 hugs on windows vista but i'm getting the error 'could not extract the file hugs98.chm"
14:50:38 <Maddas> nominolo: only on exchange ;-)
14:50:50 <nominolo> Maddas: oh, for how long?
14:50:58 <Maddas> Until June :)
14:51:12 <Maddas> xerox: I'll be the first to use your Haskell->Matlab compiler :-P
14:51:26 <ikaruz> hi, what would be the best way to implement a small web services with haskell? Is HAppS a good approach? Or should I consider sth else?
14:51:37 <nominolo> Maddas: where are you going back, then?
14:51:47 <Maddas> Switzerland
14:52:07 <Maddas> (ETH Zurich)
14:52:17 <nominolo> oh, dann kannst ja auch deutsch :)
14:52:36 <nominolo> oder duetsch?
14:53:06 <Maddas> deutsch :-) (though, appropriately enough, it's duetsch in Swiss German)
14:54:18 <nominolo> interesting.  i'm at chalmers, too, if you haven't figured that out yourself, yet ;)
14:54:28 <nominolo> (so are many more on this channel)
14:55:07 * Maddas nods :-)
15:07:27 <dobblego> have any of you written a programming.reddit alternative yet?
15:07:52 <dmwit> dobblego: go go go!
15:08:06 <dobblego> not me, you! :)
15:08:38 <sorear> @seen matthew-_
15:08:38 <lambdabot> matthew-_ is in #haskell. I last heard matthew-_ speak 1h 33m 48s ago.
15:10:05 <sorear> hello.
15:14:21 <sorear> matthew-_: pong?
15:14:24 <sorear> @users
15:14:25 <lambdabot> Maximum users seen in #haskell: 329, currently: 305 (92.7%), active: 53 (17.4%)
15:19:04 <sorear> ndm++ Hoogle patches
15:21:00 <Cale> "I've never been a good estimator of how long things are going to take" -- Donald E. Knuth
15:22:14 <ddarius> Cale: He's always ignoring constant factors.
15:22:31 <Maddas> :-)
15:22:35 <Cale> :)
15:23:03 <nominolo> heh
15:23:23 <dmwit> :t randomRs
15:23:26 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
15:23:45 <nominolo> @src randomRs
15:23:46 <lambdabot> Source not found. My mind is going. I can feel it.
15:23:56 <sorear> it's a class method
15:24:00 <sorear> @src Random
15:24:01 <lambdabot> class Random a where
15:24:01 <lambdabot>   random    :: RandomGen g => g -> (a, g)
15:24:01 <lambdabot>   randoms   :: RandomGen g => g -> [a]
15:24:01 <lambdabot>   randomR   :: RandomGen g => (a,a) -> g -> (a,g)
15:24:01 <lambdabot>   randomRs  :: RandomGen g => (a,a) -> g -> [a]
15:24:03 <lambdabot>   randomRIO :: (a,a) -> IO a
15:24:05 <lambdabot>   randomIO  :: IO a
15:24:15 <sorear> @src Bool randomRs
15:24:16 <lambdabot> Source not found. I feel much better now.
15:24:23 <sorear> @src (,) randomRs
15:24:23 <dmwit> sorear: But surely nobody implements it...
15:24:24 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
15:24:34 <sorear> :(
15:25:06 <dmwit> randomRs r g = let (x, g') = randomR r g in x : randomRs r g'
15:25:21 <nominolo> @quote knuth
15:25:21 <lambdabot> knuth says: We will perhaps eventually be writing only small modules which are identified by name as they are used to build larger ones, so that devices like indentation, rather than delimiters,
15:25:22 <lambdabot> might become feasible for expressing local structure in the source language. ["Structured Programming with goto Statements", Computing Surveys, Vol 6 No 4, Dec. 1974]
15:25:48 <dmwit> huh
15:25:54 <dmwit> That is quite a quote.
15:26:00 <nominolo> loooong
15:26:34 * nominolo feels he doesn't really get it, too
15:27:12 <Botje> he's talking about for and while loops, people
15:27:14 <dmwit> nominolo: I think it's just kind of a neat one because Knuth seems to be predicting the Python and Haskell indentation style.
15:27:17 <Botje> nothing to see here, move along :P
15:28:22 <nominolo> i think modules = (named) functions
15:28:47 <nominolo> oh, yes, and indentation significance.  true
15:29:39 <Botje> @quote
15:29:40 <lambdabot> fr30n says: <fr30n> php? eso es para vrutos
15:36:06 <nominolo> @quote dijkstra
15:36:08 <lambdabot> No quotes match. Just what do you think you're doing Dave?
15:36:27 <Botje> @quote pong
15:36:27 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
15:36:30 <nominolo> @who the fuck is dave?
15:36:31 <lambdabot> Maybe you meant: echo ghc show what wn
15:36:34 <Botje> that's a shame.
15:36:45 <dmwit> He's from 2001: A Space Odyssey!
15:36:52 <nominolo> ahhh
15:38:37 <dmwit> ?prot
15:38:37 <lambdabot> here is the big one: is it mroe prctical than say python?
15:38:44 <dmwit> ?prot
15:38:45 <lambdabot> why is haskell bette than java? java has a shitload of frameworks. its xrazy
15:38:53 <dmwit> XRAZY!
15:39:09 <dmwit> No word should be allowed to have that many letters from the end of the alphabet.
15:40:53 <nominolo> ?help prot
15:40:54 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:41:01 <dmwit> ?help protontorpedo
15:41:02 <lambdabot> protontorpedo is silly
15:41:07 <dmwit> ?prot
15:41:07 <lambdabot> so haskell is free?
15:41:10 <dmwit> ?prot
15:41:11 <lambdabot> Im wondering if there are uncharted business waters that haskell can enable, even if it is simply by not accepting norms
15:41:28 <dmwit> ?qwerty
15:41:29 <lambdabot> Unknown command, try @list
15:41:31 <sorear> ?keal
15:41:31 <lambdabot> write an algorthim that generates the correct responses for a phone survey based on number of rings whether answered how quickly hung up on and the mood of the receiver
15:41:34 <sorear> ?x
15:41:35 <lambdabot> Maybe you meant: . v
15:41:39 <sorear> ?v
15:41:39 <lambdabot> "\""
15:41:57 <dmwit> ?list quote
15:41:57 <lambdabot> quote provides: quote remember ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo
15:42:09 <vick> shouldn't f 1 2 , call function 'f' with arguments 1 and 2 ?
15:42:18 <dmwit> yep!
15:42:18 <nominolo> ?quote yhjulwwiefzojcbxybbruweejw
15:42:19 <lambdabot> No quotes match. That's something I cannot allow to happen.
15:42:26 <nominolo> ey!
15:42:30 <dmwit> ?yhjulwwiefzojcbxybbruweejw
15:42:31 <lambdabot> Exception: <<loop>>
15:42:33 <dmwit> ?yhjulwwiefzojcbxybbruweejw
15:42:34 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
15:42:41 <osfameron> snappy quote
15:42:46 <dmwit> > fix show
15:42:48 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
15:43:27 <dmwit> > map length . group . fix $ show
15:43:31 <lambdabot> Terminated
15:43:33 <nominolo> is that an expanded, showed lambda of the fixpoint?
15:43:33 <vick> dmwit: ERROR - Cannot infer instance when i try f 1 2, but f(1,2) works
15:43:43 <sorear> I know the story behing @yhjulwwiefzojcbxybbruweejw, if anyone cares!
15:43:47 <dmwit> vick: What is the type of f?
15:43:54 <dmwit> sorear: I care!
15:43:56 * nominolo cares
15:44:29 <dmwit> nominolo: That is the fixed point of show, which is close to what you said.
15:44:30 <sorear> dmwit, nominolo: BITD lambdabot generated an expression of the form 'let v = foo bar in show v'
15:44:36 <nominolo>  \iamafixedpointcombinator.<forgot the stuff that belonged here> ..
15:44:38 <sorear> > let v = 22 in show v
15:44:40 <lambdabot>  "22"
15:44:54 <sorear> ... but that breaks if foo bar contains v!
15:44:58 <sorear> > let v = v in show v
15:44:59 <lambdabot>  Exception: <<loop>>
15:45:08 <sorear> > let v = take 20 $ show v in show v
15:45:10 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
15:45:23 <sorear> etc etc.
15:45:42 <sorear> then they renamed it to yhjulwwiefzojcbxybbruweejw, in the hopes that nobody would find it
15:45:47 <sorear> people did
15:45:51 <vick> dmwit: function
15:45:57 <sorear> it still exists, but it has a random name now :(
15:45:58 <dmwit> vick: More specific.
15:46:05 <dmwit> vick: Fire up ghci or so and type :t f
15:46:11 <vick> dmwit: i have a file with f(a,b) = a+b
15:46:20 <sorear> vick: that's your problem
15:46:27 <vick> Where ?
15:46:29 <dmwit> vick: Change it to "f a b = a+b"
15:46:30 <sorear> vick: it usually should be f a b = a + b
15:46:48 <sorear> vick:  f(a,b) = ... means thhe function takes a tuple, which usually isn't what you want
15:46:48 <vick> but the interpretter gave me no error on loading
15:46:49 <dmwit> Function declaration follows the same syntax as function application. ;-)
15:46:56 <vick> tuple ?
15:47:05 <sorear> vick: like an anonymous struct
15:47:17 <dmwit> > (3, 4, 5, "hi there!")
15:47:18 <monochrom> That's right on.
15:47:20 <lambdabot>  (3,4,5,"hi there!")
15:47:21 <sorear> vick: analogies can help - what languages are you familiar with?
15:48:13 <ptolomy> Anyone know the status of record syntax in haskell prime?
15:48:40 <monochrom> The power of tuples lies in this:
15:49:03 <monochrom> let f x = (x+1, x-1) in f 10
15:49:06 <monochrom> > let f x = (x+1, x-1) in f 10
15:49:08 <lambdabot>  (11,9)
15:49:29 <monochrom> You can define a function that returns a fixed number (but bigger than one) of answers.
15:50:06 <dmwit> > let f x = (x+1) in f 10 -- or even exactly one!  But that's silly
15:50:08 <lambdabot>  11
15:52:50 <stepcut> ?where haskell-mode
15:52:51 <lambdabot> http://haskell.org/haskellwiki/Haskell_mode_for_Emacs
15:54:53 <nominolo> > let f x = () in f 42  -- or exactly None!
15:54:55 <lambdabot>  ()
15:55:23 <Saizan> ?djinn a -> b -> ()
15:55:24 <lambdabot> f _ _ = ()
15:55:38 <dmwit> I claim that the zero-tuple ought to have negative one commas inside.
15:55:44 <nominolo> ?djinn a -> () -> (a,b)
15:55:45 <lambdabot> -- f cannot be realized.
15:55:48 <nominolo> ?djinn a -> () -> (a,a)
15:55:49 <lambdabot> f a _ = (a, a)
15:56:14 <chessguy> yyyyyyyyo!
15:56:24 <dmwit> ?YARR
15:56:25 <lambdabot> Unknown command, try @list
15:56:27 <dmwit> ?yarr!
15:56:28 <lambdabot> Shiver me timbers!
15:56:31 <nominolo> wuzzuuup!
15:56:32 <Igloo> dmwit: It does. You should avoid having too many on your screen at once, or your monitor might implode
15:56:36 <chessguy> @yow
15:56:36 <lambdabot> I'm EMOTIONAL now because I have MERCHANDISING CLOUT!!
15:57:05 <dmwit> Igloo: Heh, or the anti-comma's might interact with the commas to create a MASSIVE EXPLOSION!
15:57:39 <nominolo> yeah, then haskell-programs can generate energy!
15:57:48 <Igloo> That's why they have to be kept inside other punctuation
15:57:59 <dmwit> Or, more often, monads.
15:58:15 <nominolo> but beware the run-function
15:58:29 <nominolo> that get's all the final fire-stream blown in it's face
15:58:32 <chessguy> monads-as-anti-comma-containment-fields?
15:59:00 <dmwit> Structural integrity is failing!  Hull breach on lines 5 and 19!
15:59:01 <nominolo> chessguy: yes, your next blogentry's title
15:59:06 <ptolomy> I wonder if it really is unreasonably hard to write a multi-threaded server with logging and lots of state manipulation of a zoo of large datatypes with many members or if it just deceptively easy in other languages..
15:59:34 <ddarius> @google "Haskell Webserver with Plugins"
15:59:35 <lambdabot> No Result Found.
15:59:40 <ddarius> @google "Haskell Webserver"
15:59:42 <lambdabot> http://www.mail-archive.com/haskell@haskell.org/msg10050.html
15:59:42 <lambdabot> Title: Hello everybody, About a Haskell WebServer ??
16:00:38 <ptolomy> I read the paper for that server earlier today.
16:02:49 <ptolomy> http://citeseer.ist.psu.edu/marlow00writing.html
16:02:50 <lambdabot> Title: Writing High-Performance Server Applications in Haskell Case Study: A Haskell We ...
16:05:26 <sorear> TAG anticomma
16:06:31 <dmwit> ?google TAG inurl:tunes.org/~nef/logs/haskell
16:06:33 <lambdabot> No Result Found.
16:11:07 <ddarius> @google TAG site:tunes.org
16:11:10 <lambdabot> http://lists.tunes.org/archives/gclist/2002-June/002317.html
16:11:10 <lambdabot> Title: [gclist] forwarding pointers & tag-free collection
16:11:41 <dmwit> There's really quite a lot of results, actually.
16:12:11 <dmwit> Even if you use somethingl like site:tunes.org inurl:haskell, there's 250 results, of which only a handful are actually fun ones. =)
16:12:48 <fantasma> hello all
16:19:01 <sorear> dmwit: that's because google smashes case
16:19:13 <dmwit> yeah
16:19:20 <sorear> dmwit: grep is just as fast, when you have all 200MB of logs in RAM
16:19:30 <dmwit> heh
16:23:43 <stepcut> is the latest version of haskell-mode for emacs debianized anywhere?
16:27:11 <vali> good night
16:29:05 <obsethryl> stepcut: debian-stable, debian-unstable, debian-testing, debian-volatile ?
16:30:25 <vincenz> hey
16:30:29 <sorear> hello!
16:31:15 <dolio> Woo! Americans rule at monster truck rallies! Take that, Europe!
16:31:29 * sorear buries his face in shame
16:31:31 <vincenz> lol
16:31:44 <vincenz> Europeans don't actually look at those things, so I bet there's like 0 funding for that in Europe
16:32:33 <dolio> I don't understand. What's not to like about a huge, robotic lizard crushing cars in its mechanical claws?
16:32:46 <dmead> allo channel
16:34:15 <vincenz> dons: dcoutts still there?
16:34:36 <vincenz> @localtime dons
16:34:38 <lambdabot> Local time for dons is Wed Apr 25 09:33:09 2007
16:35:23 * vincenz hopes he didn't burn his #haskell-access ticket with his comments on Transactional Memory
16:35:48 <sorear> the ones in the CAFE 2007 blogpost?
16:35:51 <vincenz> DATE
16:35:51 <sorear> er, DATE
16:35:54 <vincenz> es
16:35:55 <vincenz> +y
16:36:16 <jcreigh> pdf--
16:36:18 <sorear> this isn't the first time I've had that memmo
16:36:35 <emu> i need xmonad for windows
16:36:36 <vincenz> well I was just summarising what I heard in my own words and with my own spin
16:36:38 <sorear> jcreigh: gv rules!
16:36:56 <vincenz> evince
16:37:02 <jcreigh> sorear: I know...I'm using gv. I just don't like trying to read something typeset for paper (using, for example, a two-column layout) on a computer.
16:37:07 <vincenz> evince++
16:37:22 <sorear> I'm not too worried about the price of compilers.  it's not like any of us are going to be alive in 40 years
16:37:45 <vincenz> 40?
16:37:46 <jcreigh> If only there was some sort of MARKUP LANGUAGE that was pretty much universal, perhaps with the ability to HYPERLINK to othe papers. :)
16:37:53 <vincenz> 2015 = 8 years from now
16:37:53 <emu> thats an odd thing to hear from a kid
16:38:48 <sorear> well, once you factor in the coup d'etat in 2038...
16:38:57 <jcreigh> heh.
16:38:59 <thorat> what are the odds?
16:39:46 <thoughtpolice> 1:1
16:39:59 <dolio> vincenz: Transactional memory probably isn't the best way to do all kinds of parallelism. I don't think anyone here would dispute that.
16:40:02 <emu> by 2038, an OS written in Haskell will have completely displaced Unix and all of its devilish incarnations
16:40:11 * emu takes another puff
16:40:16 <jcreigh> heh.
16:40:30 <dolio> vincenz: Data parallelism is probably better, if it applies.
16:40:33 <sorear> I don't think anyone would honestly have thought transactional memory was the way to performance.
16:40:44 * thorat thought we were talking about asteroids :S
16:41:03 <emu> stepcut: i don't know, but it really isn't hard to install manually.
16:41:21 <dolio> Transactional memory is more like an easier way to do what people have already been doing with locks and threading.
16:41:28 <sorear> The only way is to arrange communication such that all races are harmless.
16:41:49 <sorear> Of course, if anyone here actually cared about performance, this would be #assembly.
16:42:13 <sorear> I'm proud to be a lazy bum.  Haskell forward!
16:42:17 <vincenz> dolio: data parallelism is only 1/3
16:42:19 <emu> hey now, strong static typing for performance!
16:42:23 <thoughtpolice> sorear: word. :)
16:42:24 <emu> (then this would be #ocaml
16:42:36 <stepcut> emu: if you are only installing it once, then it is not bad. But if you are doing OS development, then you might want to install it several times a day ;)
16:42:40 <dolio> 1/3 of what?
16:42:44 <emu> stepcut: aha
16:42:48 <ddarius> Doing parallelism very well would be more beneficial than doing sequential code very well.
16:42:49 <jcreigh> I think the big wins in optimization come from, eg, going from O(N^2) to O(log N), not writing a faster O(N^2), but I could be wrong.
16:43:12 <sorear> jcreigh: that's if you have constant manpower
16:43:23 <stepcut> emu: anyway, it is (probably) easy to update the haskell-mode 2.1 to haskell-mode CVS, but that would silly to do, if someone has already done it :p
16:43:28 <sorear> jcreigh: if manpower is variable, doing both is the only reasonable option
16:43:51 <emu> stepcut: yes i imagine, if you are familiar with debian packaging
16:44:23 <jcreigh> sorear: I don't quite follow you.
16:47:01 <vincenz> dolio: of the types of parallism
16:47:07 <vincenz> dolio: you've got: data, task and functional
16:47:14 <vincenz> functional is the complex one and the one we need to work more on
16:47:22 <jcreigh> @hoogle forever
16:47:23 <lambdabot> No matches found
16:50:25 <ddarius> @type \f -> fix (f >>)
16:50:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
16:50:31 <dolio> vincenz: I guess I'm not up on my terminology. What does functional parallelism refer to? Like, annotating your pure functions with 'par' and such (only, ideally, not having to annotate at all)?
16:50:41 <vincenz> dolio: ok, imagine some video app
16:50:42 <vincenz> erm
16:50:43 <vincenz> game app
16:50:47 <vincenz> right?
16:50:54 <vincenz> you've got video, audio and ai
16:50:58 <vincenz> that's task level parallelism
16:51:06 <dolio> Right.
16:51:07 <vincenz> you zoom into video
16:51:15 <vincenz> you've got a DFT, a FIR filter some other crud
16:51:21 <vincenz> each of those have data-level parallelism
16:51:32 <vincenz> the functional parallelism is the parallelism between DFT and the FIR
16:51:50 <vincenz> they could, for instance, be processing different frames (in a pipeline fashion)
16:52:01 <vincenz> but they communicate quite heavily
16:52:09 <vincenz> task-level and data-level are low on communication
16:52:21 <vincenz> (very low)
16:52:29 <dolio> Hmm, I see.
16:53:01 <vincenz> parallelism is easy at very coarse grain and at very fine grain
16:53:09 <vincenz> but the crucial issue is enabling at that middle level
16:53:27 <vincenz> very coarse grain: threads
16:53:33 <vincenz> very fine grain: compiler support and VLIW
16:53:34 <vincenz> or simd
16:53:49 <vincenz> or possibly vector-computers
16:56:02 <vincenz> for very coarse grain, aka task-level, STM or HTM seem good solutions
16:56:18 <vincenz> most likely STM cause HTM has some issues
16:57:10 <sorear> Die Zustellung Ihrer Email an: <s.schwarz@francotyp.com> ist nicht erlaubt.
16:57:10 <sorear> Dies kann folgende Gruende haben: / - Entschluesselung nicht moeglich / - Digitale Signatur konnte nicht geprueft werden / - Emails im Klartext nicht erlaubt
16:57:13 <dolio> Yeah. That certainly doesn't cover all the cases, though.
16:57:21 <sorear> I can guess what that means, but...
16:57:38 <dolio> At least, not nicely.
16:57:52 <sorear> what ever happened to all internet errors being in the same language?
16:58:16 <vincenz> dolio: all cases?
16:58:49 <dobblego> sorear, when I worked for IBM, all error messages were "an error has occurred" -- this was good enough for all languages
16:59:05 <vincenz> dobblego: definitely better than STL errors
16:59:14 <vincenz> especially when you have templates with > 100 levels of nesting
16:59:18 <dobblego> http://www.ibm.com/contact/employees/us/ try foo/bar
16:59:20 <dolio> I mean, STM isn't going to help you easily parallelize every parallelizable problem.
16:59:40 <vincenz> STM is great for when you have coarse grain parallelisable and you know that only rarely will you have conflicts
16:59:41 <sjanssen> now just translate STL errors to German and you're set
16:59:42 <dobblego> oh they've updated the error message :)
16:59:43 <sorear> vincenz: hmm.  this is just too ironic to not be true.  the first clause is "message is in/not in english?
16:59:50 <sorear> s/?/"?
16:59:54 <dolio> You could use task-level parallelism to mimic data parallelism, but it'd be nasty.
17:00:04 <vincenz> sorear: my german is not that good, but no, I don't think so
17:00:05 <sjanssen> sorear: I don't see anything about English in the error
17:00:20 <vincenz> dolio: data parallelism is handled at the instruction level,
17:00:32 <sjanssen> been a while since I half assed high school German
17:00:47 * sorear thought vincenz was a german in germany, for some reason
17:00:50 <vincenz> dolio: data parallelism is not solved fully, but there are definitely good solutions out there
17:00:54 <vincenz> <- belgian in belgium
17:01:09 <dolio> vincenz: Well, I was thinking of, say, the haskell parallel arrays and array comprehensions in development.
17:01:53 <vincenz> dolio: right, for more complex operations per data element, that certainly is still an interesting area
17:01:53 <mauke> the delivery of your email to: <...> is not allowed
17:02:02 <dmead> alllright
17:02:09 <dmead> ?paste
17:02:12 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:02:22 <mauke> this can have the following reasons: / - decryption not possible / - digital signature could not be checked / - emails in cleartext not allowed
17:03:44 <vincenz> mauke++
17:04:03 <sorear> mauke++
17:04:42 <hpaste>  dmead pasted "screwy ghci problem" at http://hpaste.org/1552
17:04:51 <dmead> can someone take a look at my paste?
17:04:59 <dmead> ghci things i'm redefining a function
17:05:11 <dmead> and i haven't touched this code since i've upgraded ghc
17:05:13 <dmead> sooo...
17:05:15 <dmead> :<
17:05:19 <dmead> *ghci thinks
17:05:33 <sorear> what version of ghci?
17:05:43 <dmead> 6.4.2
17:05:49 <dmead> actually, this isn't upgraded
17:05:59 <dmead> but the error is obvously weird
17:06:01 <stepcut> ddarius: you made a typo
17:06:06 <stepcut> removaArrows
17:06:13 <dmead> oh
17:06:27 <dmead> ah
17:06:28 <dmead> where?
17:06:34 <stepcut> second to last line
17:06:39 <stepcut> removaArrows (a :<-> b)
17:06:53 <dmead> ahh
17:06:54 <dmead> thanks :)
17:06:58 <dmead> i need new glasses =/
17:07:01 <stepcut> :p
17:07:28 <dmead> yea i found an awful problem in my prover that went unnoticed for like 4 months
17:07:35 <stepcut> heh
17:07:41 <sorear> QuickCheck!
17:07:52 <dmead> ahh
17:07:54 <dmead> yea
17:07:58 <dmead> but it was my own blunder
17:08:08 <dmead> probably would have written the wrong test for it as well
17:08:47 <sorear> I think any Python type checker should be called QuackCheck.
17:08:55 <stepcut> heh
17:09:04 <dmead> o0
17:09:16 <dmead> are you hating on python or is that a refrence to snakes somehow
17:09:18 <dmead> or the prey of snakes
17:09:32 <sorear> @google duck typing
17:09:34 <lambdabot> http://en.wikipedia.org/wiki/Duck_typing
17:09:35 <lambdabot> Title: Duck typing - Wikipedia, the free encyclopedia
17:09:35 <thedward> presumably a reference to duck typing?
17:10:11 <dmead> ahh
17:11:21 <dolio> I think 'duck typing' came out of the Ruby community, no?
17:11:26 <dolio> Specifically Dave Thomas?
17:11:47 <jcreigh> From the Ruby community, yes, but I don't recall if Dave Thomas coined the term.
17:12:00 <dolio> Ah, wiki says differently I guess.
17:12:10 <dolio> Alex Martelli.
17:12:21 <dolio> And comp.lang.python, as well.
17:13:14 <dmead> ah
17:13:15 <dmead> thats cool
17:13:23 <vincenz> new blog article
17:13:24 <vincenz> http://notvincenz.blogspot.com/2007/04/memory-bottlenecks.html
17:13:24 <lambdabot> Title: lambda.oasis: Memory bottlenecks
17:13:34 <dmead> kinda like static type inference
17:13:43 <jcreigh> really? hmm. I had thought some Rubyist had made it up. I first heard it used describing Ruby, anyway.
17:13:44 <dmead> but you just name it
17:13:45 <dmead> HMM
17:15:30 <dmead> (f <-> g) = ( f &  g) v (~f & ~g)
17:15:38 <dmead> does that look wrong to anyone else?
17:16:32 <jcreigh> what operation is <-> supposed to be?
17:16:38 <TSC> Does f <-> g mean f=g ?
17:16:40 <dmead> biconditional
17:16:43 <dobblego> implies if and only if I expect
17:17:07 <dobblego> I also assume & is conjunection
17:17:10 <dmead> aye
17:17:10 <dobblego> *conjunction
17:17:18 <dobblego> you can determine if it is correct with a truth table
17:17:26 <jcreigh> http://en.wikipedia.org/wiki/Biconditional -- Truth table seems to be right
17:17:58 <mauke> s/E($expr)($expr)/DC$1$2ND$1$2/go
17:18:31 <mauke> that doesn't help you of course, but it means f <=> g = (f & g) v ~(f v g) :-)
17:18:50 <dmead> :o
17:19:02 <dmead> k
17:19:03 <dmead> phew
17:19:08 <dmead> :)
17:19:24 <mauke> I happen to have this logic expression evaluator written in perl regexes
17:19:33 <dmead> neat
17:19:38 <magnus_> that is the same as what dmead wrote
17:19:57 <dmead> magnus_, yes ,he was testing mine i assume
17:21:20 <magnus_> ah
17:22:07 <hpaste>  dibblego pasted "for dmead" at http://hpaste.org/1553
17:22:16 <monochrom> @src words
17:22:17 <lambdabot> words s = case dropWhile isSpace s of
17:22:17 <lambdabot>     "" -> []
17:22:17 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
17:22:29 <dobblego> that first line is supposed to be f g Â¬f Â¬g fâ†”g fâˆ§g Â¬fâˆ§Â¬g (fâˆ§g)âˆ¨(Â¬fâˆ§Â¬g)
17:22:37 <dmead> neat
17:22:38 <obsethryl> vincenz: thank you for the quality content in this blog of yours, looks very promising indeed
17:22:50 <vincenz> obsethryl: thank you
17:22:53 <obsethryl> i just looked at it through the link you provided
17:31:31 <fantasma> is there a way for cabal to install manpages without having to run an external Makefile?
17:39:40 <sorear> @botsnack
17:39:41 <lambdabot> :)
17:40:37 <sorear> @botsnack
17:40:37 <lambdabot> :)
17:42:25 <fantasma> @sorearsnack
17:42:26 <lambdabot> Unknown command, try @list
17:43:13 <sorear> hey, 6 minutes of lag is worrying!
17:43:46 <monochrom> I did not experience 6 minutes of lag.
17:44:14 <monochrom> Are you travelling at 1% of lightspeed away from lambdabot?
17:45:01 <vincenz> monochrom: don't blame sorear, it could be lambdabot who is travelling
17:45:25 <monochrom> @src words
17:45:26 <lambdabot> words s = case dropWhile isSpace s of
17:45:26 <lambdabot>     "" -> []
17:45:26 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
17:45:36 <monochrom> I'm travelling with lambdabot.
17:46:04 <monochrom> Or, hahahaha.
17:46:26 <lispy> anyone here use INCLUDE pragmas with ghc before?
18:02:17 <dons> "Baby, if they made you in Haskell, it would infer that you were just my type"
18:02:17 <lambdabot> dons: You have 5 new messages. '/msg lambdabot @messages' to read them.
18:03:05 <sorear> CPU Temp:  +66.0 C  (low  =   +10 C, high =   +60 C)   ALARM   I'm starting to suspect I should check the fans...
18:03:06 <lispy> hey dons
18:03:12 <sorear> hello dons
18:03:13 <vincenz> heya dons
18:03:13 <lispy> (just saying hi)
18:03:13 <Philippa> dons: damn but that's an awful line :-)
18:03:24 <vincenz> dons: if you want karma on reddit, ...
18:04:00 <vincenz> sorear: you have a lot of groupies?
18:04:25 <sorear> @all-dicts groupies
18:04:28 <lambdabot> No match for "groupies".
18:04:30 <sorear> ?
18:04:32 <vincenz> groupies, followers, fans
18:04:53 <sorear> Yeah, I've got plenty of those.
18:05:04 <sorear> Unfortunately they aren't the right homonym.
18:05:04 <vincenz> then no need to check them
18:07:31 <sjanssen> dons: has anyone attempted to add ogg support to hmp3?
18:07:41 <fbuilesv> Hello, is there any way to use a pattern for function like: function ~True ~True = Something? Where ~True means not true.
18:07:53 <sorear> function False False = Something
18:08:10 <sorear> function x y | x /= True && y /= True = Something
18:08:12 <fbuilesv> sorear, I dont want false
18:08:23 <fbuilesv> I read Bool also considers bottom as a possible element
18:08:25 <sorear> fbuilesv: LEM
18:08:53 <fbuilesv> sorear: LEM?
18:09:03 <sorear> fbuilesv: well, _|_ is very nasty - anything that cares *at all* about a value, returns _|_ if given _|_
18:09:11 <dons> sjanssen: not yet, but kfish added mpg321-remote control support to ogg123
18:09:13 <sorear> fbuilesv: all haskell functions are continuous
18:09:22 <dons> sjanssen: so it would be fairly easy to support now, i think
18:09:30 <sorear> fbuilesv: Law of the Excluded Middle - everything is True or False
18:09:45 <dons> > let f ~True = 1 in f False
18:09:46 <lambdabot>  1
18:09:55 <sjanssen> dons: I might try to do that
18:10:09 <dons> sjanssen: yeah, if you use ogg, that'd be great.
18:10:20 <vincenz> dons: did I hit your /ignore group?
18:10:25 <dons> the main technical part was ensuring ogg123 spoke the same protocol as mpg*, which is does now.
18:10:26 <narain> :t ~
18:10:28 <lambdabot> parse error (possibly incorrect indentation)
18:10:29 <dons> vincenz: no?
18:10:32 <vincenz> oh, whew :)
18:10:45 <sjanssen> well, I have everything in flac right now -- I have the choice of converting to ogg or mp3
18:10:57 <dmwit> narain: It tells pattern matches to always succeed.
18:10:59 <monochrom> You can't reliably detect _|_
18:11:02 <fbuilesv> sorear: If I use x /= true && y /= true = False and then evaluate that function with bot (bottom) I won't get any response?
18:11:04 <sjanssen> ogg is the more moral choice, I suppose
18:11:13 <dmwit> > let f ~True = 1 in map f [False, True]
18:11:15 <lambdabot>  [1,1]
18:11:32 <monochrom> If the bottom comes from an infinite loop, you don't get any response.
18:12:01 <narain> dmwit: huh. i guess i should go through the Report at least once
18:12:29 <dmwit> narain: Although I don't know how it actually works... =P
18:12:40 <dmwit> > let f ~(x, y) = x + y in f 3
18:12:41 <lambdabot>   add an instance declaration for (Num (t, t))
18:12:46 <narain> ?where report
18:12:46 <lambdabot> http://www.haskell.org/onlinereport/
18:13:08 <dmwit> > let f ~(x, y) = (y, x) in f 3
18:13:09 <lambdabot>   add an instance declaration for (Num (t, t1))
18:13:39 <dmwit> Ah, the *compiler* protects you from bologna like that.
18:13:50 <lispy> type checker
18:14:14 <dmwit> type checker \subset compiler, no?
18:14:17 <lispy> the power of automated proof at every compile
18:14:35 <lispy> depends on how you use the term i guess
18:14:47 <dmwit> anyway
18:14:59 * narain wishes symbols in the haskell grammar definitions in the Report were hyperlinked
18:15:18 <lispy> narain: it's a good idea...i wonder how hard it would be to implement
18:15:25 <monochrom> Ah, hyperlink would be nice
18:15:44 <lispy> ie, how many people you'd have to mention it to before someone said, "Here, edit this darcs repository and send me a patch."
18:16:50 <narain> would it require hand-editing the html source?
18:17:59 <lispy> i've no clue...
18:18:19 <lispy> i wonder if it could be easily converted to one of those formats like docbook
18:19:01 <narain> i wonder how the w3c does it... the grammars in their specs are always hyperlinked
18:19:40 <lispy> i bet they store it in xml then do an xslt to generate html and then apply a style sheet
18:20:13 <sorear> @quote xslt
18:20:14 <lambdabot> darius says: I imagine XSLT programmers say "It's a one pager" the way most other programmers say "It's a one liner".
18:22:09 <lispy> nice
18:22:15 <narain> the html source of the online report certainly looks like it's machine-generated
18:22:50 <lispy> ya know, i wouldn't be surprised if the translator is written in haskell :)
18:23:07 <lispy> who is in charge of that document?
18:23:16 <narain> hey, the source is in a public cvs repo
18:23:28 <sorear> lemme see, I wrote a patch to it a few months ago
18:23:49 <sorear> I sent it to malcomw
18:24:17 <sorear> map succ "L`kbnkl-V`kk`bd?br-xnqj-`b-tj"
18:26:43 <narain> "Build the html by creating a `html' subdirectory, copy the .html and
18:26:43 <narain> .gif files to it, and run tex.hs twice"
18:26:48 <narain> where/what is tex.hs?
18:27:36 <narain> never mind, found it
18:28:19 <lispy> narain: so from the sounds of it, you could create a database (maybe like hoogle does, or using the hoogle database) and then auto hyperlink based on that?
18:28:33 <narain> egads, i'm not going into that code (tex.hs)
18:28:50 <lispy> something wrong with it?
18:29:03 * scsibug just checked it out too...scary 
18:29:17 <narain> "This program has evolved in a rather unplanned manner and is now a jumble of absolutely crappy code, tacked-on features, no documentation, and other fun stuff."
18:29:23 <sorear> scarier than happy?
18:29:47 <lispy> honesty++
18:29:48 <narain> that's just the beginning of the introductory comment, it goes on
18:30:03 <sorear> quoth JaffaCake: "I can't believe I wrote code that dumb"
18:30:52 <lispy> and i'm told FPers have too much ego!
18:31:52 <sorear> lispy: The rest of the email had more of an "I'm humbded and ashamed" quality than a "I don't believe you" quality.
18:34:16 <narain> also the grammar symbols and function references in the report source aren't marked up very well... that along with the scariness of tex.hs leads me to believe that tweaking the report to add hyperlinks is a job for someone with more bravery and haskell-fu than i
18:36:50 <scsibug> am I wrong to expect concurrent haskell to take adantage of a multicore machine?  I can't get more than full utilization of 1 core.
18:37:05 <scsibug> (on OS X, with G5 dual core)
18:37:12 <sorear> you need to enable it
18:37:17 <sorear> compile with -threaded
18:37:22 <sorear> run with +RTS -N2
18:37:32 <scsibug> i have -threaded, but not the RTS flag...
18:37:46 <sorear> also, don't use concurrency just for parallelism if you can avoid it - Control.Parallel is PURE
18:38:24 <scsibug> I don't have -N as a valid RTS flag (ghc 6.6)
18:38:43 <sorear> that means you didn't compile with -threaded
18:38:46 <monochrom> ghc -threaded --make haha.hs
18:38:53 <monochrom> haha +RTS -N2
18:38:57 <sorear> scsibug: what is the exact compiler command line?
18:39:04 <monochrom> I forgot -O
18:39:11 <scsibug> ghc --make -threaded myprogram.hs
18:39:36 <sorear> scsibug: rm *.hi when changing compiler flags
18:39:44 <monochrom> OH! I forgot that too.
18:39:52 <scsibug> do I have to use -O?
18:40:04 <scsibug> that brings up another problem, which I think is a bug in the GD bindings
18:40:07 <sorear> scsibug: no, it will only make your program dozens of times faster
18:40:12 <sorear> @quote -O
18:40:13 <lambdabot> ClaudiusMaximus says: compiling with -O2 reduced the time taken by my program's execution from 28mins to 17secs
18:40:35 <scsibug> damn, I really need to track down why programs linking with GD can't stand -O/-O2
18:40:49 <scsibug> I get a parse error for the gd-extras.h header
18:41:00 <sorear> try -O2 -fasm
18:41:04 <sorear> does that work?
18:41:14 <scsibug> nope
18:41:55 <hpaste>  scsibug pasted "linking gd" at http://hpaste.org/1554
18:42:01 <sorear> also be advised that putpixel is inherently quite slow unless it can be inlined
18:43:11 <sorear> scsibug: that happens with -fasm?!
18:43:23 <scsibug> it happens with -O or -O2
18:43:24 <sorear> try -O -fasm
18:43:30 <sorear> rather than -fasm -O
18:43:49 <scsibug> wow, well, that's different...
18:43:49 <sorear> -O implies -fvia-C, and I suspect ghc follows a last-specification rule
18:44:03 <hpaste>  scsibug annotated "linking gd" with "(no title)" at http://hpaste.org/1554#a1
18:45:03 <sorear> that error almost invariably means you forgot --make.
18:45:08 <sorear> which is very strange!
18:45:15 <scsibug> indeed! I'm confused :/
18:45:15 <sorear> since you DID use --make
18:45:43 <sorear> what sort of definition does Plot.drawPlot have?
18:45:49 <sjanssen> it also can mean that a package forgot to include some modules
18:46:03 <sorear> scsibug: do you still get the error with -fforce-recomp -O -fasm?
18:46:46 <scsibug> hah, no, that fixed it
18:47:15 <sorear> oh, nice.
18:47:25 <scsibug> still don't seem to have the -N option though
18:47:30 <sorear> if -fforce-recomp ever fixes anything I'd call it a ghc bug :(
18:47:41 <sorear> where are you trying to use -N?
18:47:45 <sorear> what command line?
18:47:50 <scsibug> when running the program itself
18:48:02 <sorear> after +RTS?
18:48:05 <scsibug> ./mandelbrot +RTS -N2
18:48:18 <sorear> and that gives you an error?
18:48:29 <scsibug> "unknown RTS option -N2"
18:48:42 <sorear> try 'ls -l' is the modtime for mandelbrot reasonable?
18:48:53 <scsibug> yep
18:49:22 <sorear> How very odd.
18:49:23 <scsibug> same after deleting all .o/.hi files and recompiling
18:49:51 <monochrom> multiple ghc versions?
18:50:02 <sjanssen> you're compiling with "ghc --make -O -fasm -threaded mandelbrot.hs"?
18:50:10 <sorear> scsibug: does ./mandlebrot +RTS --help list -N?
18:50:25 <scsibug> ghc --make -fforce-recomp -O2 -fasm -threaded mandelbrot.hs
18:50:34 <scsibug> no, -N does not appear in the listing
18:50:48 <sjanssen> and the output of ghc --version?
18:50:54 <scsibug> 6.6
18:51:00 <sjanssen> hmm
18:51:03 * sorear googles for threaded rts ppc
18:51:39 <sjanssen> I've personally used the threaded RTS on an x86 OS X
18:52:11 <scsibug> I may try that later tonight, to see if it's indeed an architecture issue
18:52:54 <scsibug> although I am very pleased to have -O2 working (!)
18:53:11 <scsibug> probably gives me a larger performance boost than with threading :->
18:53:48 <sorear> if you are using any sort of put pixel call, try using image buffers instead
18:54:08 <sorear> foreign call overhead is probably killing you
18:54:26 <sorear> but benchmark both ways, this kind of stuff is known to be unpredictable
18:54:32 <scsibug> i've got to make that call regardless though
18:54:49 <scsibug> does it matter if I bunch them all together, versus calling it as I compute pixels?
18:54:50 <sorear> well, a million putpixels vs. one putimage.
18:54:58 <sorear> yes, a lot
18:55:03 <scsibug> hrm, GD has a putimage call?
18:55:07 <scsibug> I should implement that then ;)
18:55:11 <jcreigh> Hmm. All Chan operations are non-blocking except for reading out of an empty Chan, right?
18:55:20 <sorear> scsibug: I've actually never used gd
18:55:30 <sorear> scsibug: I'm talking graphics in general
18:55:45 <sorear> jcreigh: are you talking re. block and unblock?
18:55:47 <scsibug> ah.. I'm just not sure that is available in the GD API
18:56:05 <sorear> jcreigh: Chan is *not* exception safe, you will corrupt the data structures if you try
18:57:35 <SamB_XP> exactly how can you mess up a Chan with an exception?
18:57:51 <jcreigh> maybe I don't understand the basic idea, even.
18:58:10 <sjanssen> sorear: async exceptions?
18:58:28 <scsibug> well, I'm off... much thanks sorear and monochrom
18:58:48 <jcreigh> I had thought that a Chan was a message queue: Writing to the Chan simply adds it to a FIFO and returns immediately. reading from the Chan gets the first value, or, if it's empty, blocks until there *is* a first value.
18:58:58 <sorear> jcreigh: right.
18:59:05 <sorear> SamB_XP: sjanssen has it
18:59:15 <SamB_XP> ah.
18:59:19 <SamB_XP> that is nice ;-)
18:59:20 <sjanssen> that is unfortunate
18:59:29 <SamB_XP> that too
18:59:37 <monochrom> hahaha
19:00:07 <SamB_XP> (it depends, I suppose, on if you could *have* asynch exceptions or not...)
19:00:16 <jcreigh> okay...what would be an example of something that would produce an asynchronous exception?
19:00:30 <sjanssen> @hoogle throwTo
19:00:31 <lambdabot> Control.Concurrent.throwTo :: ThreadId -> Exception -> IO ()
19:00:39 <SamB_XP> sjanssen: anything else?
19:00:41 <sjanssen> jcreigh: that's the easiest way to create one
19:00:49 <sjanssen> SamB_XP: I'm not sure, off the top of my head
19:01:16 <sjanssen> one could just use TChan, I suppose
19:01:54 * jcreigh sighs
19:02:01 <jcreigh> what's the difference between a Chan and a TChan?
19:02:08 <SamB_XP> TChan is STMy
19:02:11 <sjanssen> jcreigh: you can ignore this exception issue
19:02:40 <jcreigh> so when we're talking about "exceptions" proper, does that include things like Prelude's "error" and pattern match failures?
19:03:01 <SamB_XP> those are synchronous exceptions
19:03:09 <sjanssen> in GHC, all _|_'s become exceptions
19:03:16 <jcreigh> Are they catchable? I've always wondered.
19:03:35 <SamB_XP> ... why would we bother to call them exceptions if they were not catchable?
19:03:44 <jcreigh> SamB_XP: that's what I'm wondering. :)
19:03:58 <sjanssen> jcreigh: but Chan is safe from from these synchronous exceptions (as long as there isn't a bug in the library itself)
19:04:00 <SamB_XP> @doc Control.Exception
19:04:01 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
19:04:21 <SamB_XP> jcreigh: look at that
19:04:22 <sorear> no, error makes async exceptions.
19:04:28 <sorear> as does throw
19:04:33 <SamB_XP> sorear: how so?
19:04:34 <sorear> throwIO is synchronous
19:04:46 <sorear> @google A semantics for asynchronous exceptions
19:04:50 <lambdabot> http://java.sun.com/docs/books/jls/second_edition/html/exceptions.doc.html
19:04:51 <lambdabot> Title: Exceptions
19:04:57 <sorear> spj says it, I don't quire get it either
19:05:04 <sorear> @google "A semantics for asynchronous exceptions"
19:05:05 <lambdabot> No Result Found.
19:05:13 <SamB_XP> those would have to be somewhat synchronous, though
19:05:30 <sorear> SamB_XP: they arrive at undetermined times
19:05:39 <SamB_XP> because they aren't going to spontaneously throw themselves when you haven't just forced a _|_
19:05:41 <sorear> SamB_XP: because evaluation order is unspecified
19:05:48 <monochrom> let ones = 1 : error "whee" in take 2 ones
19:06:00 <monochrom> Err
19:06:07 <monochrom> let ones = 1 : error "whee" in print (take 2 ones)
19:06:21 <monochrom> The exception occurs at print, not at ones.
19:06:27 <SamB_XP> I mean, I assume Chan doesn't look at the messages...
19:07:57 <monochrom> error is async, but probably not to the point of jeopardizing Chan.  throwTo is async, and that affects Chan.
19:08:03 <SamB_XP> I guess I'm using a concept of "asynchronous" more like that of a CPU or OS maker ;-)
19:08:04 <sorear> right.
19:08:24 <sorear> (to monochrom)
19:08:49 <sjanssen> sorear: have you seen this bug in the wild?
19:09:06 <SamB_XP> i.e. "having nothing to do with the thread's evaluation"
19:09:16 <jcreigh> excuse my stupidity once more: So what's the difference between a synchronous exception and an asynchronous exception?
19:09:24 <fantasma> sjanssen: xmonad man page complete: http://xmonad.org/xmonad.1.gz
19:09:32 <SamB_XP> jcreigh: apparantly SPJ is crazy ;-)
19:09:43 <sorear> sjanssen: Yes.
19:09:49 <SamB_XP> actually, I think there are probably three levels of synchronicity
19:09:57 <sjanssen> sorear: bet that was fun to track down
19:10:14 <sorear> sjanssen: It was the underlying problem of one of lambdabot's two infamous netsplit bugs
19:10:22 <sjanssen> ah
19:10:48 <jcreigh> is it just me, or is that xmonad manpage gziped *twice*?
19:11:00 <fantasma> it's gzipped once
19:11:01 <sorear> a certain operation was called too often, and was timed out using asynch throwTo
19:12:42 <jcreigh> fantasma: this is what I have to do to extract it: http://rafb.net/p/B1lNrd85.html
19:12:44 <lambdabot> Title: Nopaste - xmonad manpage (double gzip)
19:13:09 <sorear> !paste are you alive?
19:13:10 <hpaste> Haskell paste bin: http://hpaste.org/
19:13:33 <jcreigh> I tend not to use hpaste when I'm pasting something other than Haskell code.
19:13:52 <jcreigh> I thought hpaste was for, well, Haskell.
19:13:52 <fantasma> let me recreate the ifle
19:13:57 <fantasma> s/ifle/file
19:13:57 <SamB_XP> what about... error messages?
19:14:20 <SamB_XP> sample texts for parsing?
19:15:15 <fantasma> jcreigh: try it now
19:15:42 <jcreigh> fantasma: works fine now.
19:15:55 <jcreigh> fantasma++
19:15:58 <fantasma> sorry about that
19:16:59 <fantasma> http://xmonad.org/manpage.html
19:17:01 <lambdabot> Title: Manpage of xmonad
19:17:50 <ivanm> the "return ot main contents" link at the top of that man page doesn't work
19:17:50 <lambdabot> ivanm: You have 1 new message. '/msg lambdabot @messages' to read it.
19:18:07 <dcoutts> allbery_b: you were having gtk2hs troubles, did you get it sorted or did you find a bug or missing feature?
19:18:07 <lambdabot> dcoutts: You have 3 new messages. '/msg lambdabot @messages' to read them.
19:18:38 <dons> fantasma: wonderful. you wrote a man page for us?
19:18:49 <dons> heya dcoutts
19:18:53 <fantasma> yeah
19:18:58 <fantasma> ivanm: I'll remove the link
19:19:04 <ivanm> fantasma: *nod*
19:19:14 <dons> fantasma: in troff form (or whatever it is) too?
19:19:22 <ivanm> dons: with the xmonad page, its just a little confusing having the headings in red _and_ the hyperlinks in red
19:19:24 <fantasma> dons: of course
19:19:32 <sorear> ivanm: hello
19:19:32 <dons> ivanm: ok.
19:19:41 <ivanm> hey sorear
19:19:44 <dons> fantasma: submitted it as a patch to the src repo?
19:20:10 <fantasma> dons: you just want me to darcs send it?
19:20:23 <dino-> I'm having some parsec trouble. I have a situation where I'm doing a manyTill anyChar $ try foo  and I want the foo after this succeeds, not the list of anyChar
19:20:38 <sjanssen> now, how do we get Cabal to install this manpage?
19:20:52 <fantasma> sjanssen: that is what I was pondering earlier
19:20:53 <lispy> ?hoogle manyTill
19:20:54 <lambdabot> Text.ParserCombinators.ReadP.manyTill :: ReadP a -> ReadP end -> ReadP [a]
19:20:54 <lambdabot> Text.ParserCombinators.Parsec.Combinator.manyTill :: GenParser tok st a -> GenParser tok st end -> GenParser tok st [a]
19:21:08 <Philippa> dino-: use the lookahead combinator?
19:21:10 <jcreigh> okay, so foo = error "explode" would cause an asynchronous exception, because we could pass "foo" all over the place and it won't error until something actually tries to force it, and a synchronous exception would be x <- readFile "DoesNotExist.txt", because the exception occurs in code that's prepared to deal with it? Is this correct?
19:21:18 <mauke> ?hoogle followedBy
19:21:18 <sjanssen> fantasma: yes, you should darcs send the man page
19:21:19 <lambdabot> Text.ParserCombinators.Parsec.Combinator.notFollowedBy :: Show tok => GenParser tok st tok -> GenParser tok st ()
19:21:20 <dons> fantasma: well, it makes sense to have it in the repo
19:21:36 <sjanssen> we can work out installation issues later
19:21:37 <dons> so say, the deb package can use the man page
19:21:50 <fantasma> sjanssen: you can use a postInstall hook to copy the file but there might be a better way
19:21:53 <monochrom> jcreigh: that is my understanding
19:21:57 <dons> nah. no hooks!
19:22:14 <fantasma> heh, thought so
19:22:29 <ivanm> so, you want haskell to be hook-free? (R) :p
19:23:36 <dino-> Philippa: What would that lookahead be?
19:23:55 <dino-> Oh, lookAhead
19:24:23 <dcoutts> hia dons
19:24:35 <dcoutts> @tell ndm cheers for the bug report on the paper
19:24:35 <lambdabot> Consider it noted.
19:25:23 <dons> bug report?
19:26:09 <dcoutts> dons: typo in a paper title, I've just pushed the fix
19:27:30 <dons> in the title? wow.
19:27:58 <dons> ah i see.
19:28:07 <dons> not 'the paper title' ;-) 'a paper title'
19:31:10 <fantasma> how come copying a file to a repository doesn't count as a 'change'?
19:31:11 <jcreigh> hmm, threading is hard.
19:31:21 <jcreigh> fantasma: did you "darcs add" it?
19:31:29 <fantasma> ah ok
19:31:31 <fantasma> thanks
19:32:25 <dons> so you're just adding xmonad.1 to the repo?
19:32:42 <lispy> fantasma: 'darcs record -l' is probably your friend
19:32:49 <dons> sjanssen: so how are we going to take over^h^h^h what next for xmonad?
19:32:51 <lispy> fantasma: it's short for --look-for-adds
19:33:18 <fantasma> thanks lispy
19:33:25 <ivanm> dons: how about adding a window manager? *ducks*
19:33:35 * jcreigh wonders why there's --look-for-adds instead of --ignore-adds
19:33:51 <lispy> fantasma: you can also edit your darcs prefs so that it's a default
19:33:57 <sjanssen> dons: float mode and status bar are the things to tackle
19:34:21 <sjanssen> we need to decide between float layer and float layout
19:34:21 <lispy> jcreigh: at least in the past, look for adds has had terrible performance...but i think my patch to fix that was accepted at some point
19:34:49 <dons> sjanssen: my inclination would be a float layer. but we'll need to try both i think
19:35:06 <dons> since rarely do you want all windows 'unmanged'
19:35:19 <sjanssen> actually, a float layer is practically required (for transient windows)
19:35:28 <lispy> jcreigh: and there is a --dont-look-for-adds or similar to ignore it
19:35:33 <dons> right. and status bars perhaps
19:35:41 <dons> jcreigh: what have you done wrt. status bars?
19:35:43 <gravity> I should make my quick 'n dirty xmonad debian packages less dirty
19:35:56 <jcreigh> dons: well, right now I'm trying to mock up a threading solution, with little success.
19:36:05 <sorear> dons: btw, yesterday I found a way to handle an out of process sbar w/o threading
19:36:16 <jcreigh> turns out that threading is hard.
19:36:24 <brad_> hi
19:36:29 <brad_> anyone using xmonad here?
19:36:31 <sorear> hello brad!
19:36:34 <dons> heh
19:36:35 <jcreigh> brad_: yes!
19:36:41 <brad_> OH GOOD
19:36:49 <brad_> just the fellas i want to talk to!
19:36:54 <sjanssen> jcreigh: do the notes in TODO help?
19:37:02 <sorear> brad_: you joined in the middle of an xmonad conversation
19:37:04 <lispy> brad_: heh, you actually just walked into an xmonad developer discussion :)
19:37:04 <sjanssen> jcreigh: a bit outdated, but I think they might help
19:37:09 --- mode: ChanServ set +o dons
19:37:14 --- topic: set to '["The Haskell programming language: yeah, we wrote a window manager","The Summer of Code is on","http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]' by dons
19:37:18 <brad_> dons, you told me to get the latest "Cabal" for X11, i presume you mean the darcs repo?
19:37:19 --- mode: ChanServ set -o dons
19:37:19 * sorear waits for the /topic
19:37:39 <dons> fantasma: which cabal did you update to?
19:37:48 <dons> brad_: the darcs one would be ok, i think, yes.
19:37:55 <fantasma> dons: 1.1.7, darcs head
19:38:11 <lispy> dons: i probably asked this question to death...but, does hs-plugins work on ghc6.6?
19:38:18 <dons> yes
19:38:19 <brad_> dons - it asks me to run autoreconf prior to cabal steps, but these get me no where, is there a more detailed step here?
19:38:20 <dons> > 1+2
19:38:25 <lambdabot>  3
19:38:25 <lispy> ?version
19:38:26 <lambdabot> lambdabot 4p517, GHC 6.6 (Linux i686 2.66GHz)
19:38:26 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:38:32 <lispy> awesome
19:38:37 <lispy> so i should upgrade my lambdabots
19:38:41 <dons> brad_: hmm. what goes wrong?
19:39:10 <ClaudiusMaximus> lispy: darcs version works, the rc tarball doesn't, haven't checked if there is a newer tarball...
19:39:13 <dons> brad_: the other optoin, btw, is to symlink /usr/X11R6/lib into /usr/lib/ if you're feeling evil
19:39:26 <sorear> brad_: AltData.Typeable anything means you need to upgrade hsplugins
19:39:35 <dons> sorear: wrong person.
19:39:42 <sorear> lispy: AltData.Typeable anything means you need to upgrade hsplugins
19:39:43 <brad_> i just run "autoreconf261" on freebsd, it spits out some junk
19:39:53 <fantasma> brad_: what are you trying to build?
19:39:54 <ivanm> hey ekidd
19:39:54 <dons> brad_: does it generate ./configure though?
19:39:59 <jcreigh> well, here's what I've done. (NOTE: I've never done any threading before.) I set up a Chan (X ()). Then I spawn three threads: One to wait for events and write "handle event" into the Chan. One to read from stdin and write "writeStatusbar line" into the Chan. and one to actually execute these actions in the X monad.
19:40:21 <dons> jcreigh: can you post the code to the list?
19:40:21 <brad_> yes i get a ./configure
19:40:31 <sorear> jcreigh: why do we need to handle stdin/stdout?
19:40:31 <dons> brad_: that's ok then, I think?
19:40:39 <dons> warnings are typical of the autoconf compiler
19:40:55 <sorear> jcreigh: PropertyNotify on the root should be Just As Good
19:41:00 <sjanssen> sorear: to support scriptable state messages (current time, batter power, etc.)
19:41:03 <lispy> sorear: AltData.Typeable?  I'm just a lambdabot user!
19:41:05 <dons> sjanssen: i have this feeling we should do some background research on ui design
19:41:15 <brad_> well then if i run setup.hs configure, i get garbage
19:41:19 <brad_> like:
19:41:24 <sorear> lispy: if you don't have it, you don't want to know.  I was anticipating the error you'd complain of.
19:41:27 <sjanssen> sorear: a user has a shell script pipe in to the statusbar
19:41:33 <jcreigh> ...but this "doesn't work". If I have more than one thread feeding the Chan, xmonad runs for 5 or 10 seconds, then locks hard.
19:41:34 <lispy> sorear: heh
19:41:37 <brad_> Setup.hs:17:30: Couldn't match expected type `UserHooks'
19:41:39 <brad_> etc
19:41:49 <sorear> sjanssen: and this is better than PropertyNotify ... how?
19:42:07 <dons> fantasma: did you have any issues building cabal from darcs?
19:42:12 <ekidd> ivanm: Hello! I'll be around in a few minutes.
19:42:23 <sjanssen> sorear: you want the user to write little shell scripts that make X calls?
19:42:32 <fantasma> dons: I has issues with a few packages from darcs
19:42:32 <sorear> sjanssen: well, easier to iface with shell scripts..  but any -package X11 worthy of the name should let your sbar program access the root in 10 lines
19:42:48 <fantasma> brad_: can you paste Setup.hs for the package you're trying to build
19:42:49 <dmead> hey
19:42:51 <dmead> guysss
19:42:54 <jcreigh> sorear: also, it's trivial to replace the thread that reads from stdin with a thread that does it in pure Haskell. Or *would* be trivial, if my code worked.
19:42:58 <dons> fantasma: he's trying to build cabal
19:43:00 <sorear> sjanssen: sure, if it's easier than convincing Simon to drop the threaded rts!
19:43:02 <dmead> is there a mutable list someplace in the stdlib?
19:43:06 <brad_> yes fantasma, how do i paste?
19:43:07 <sorear> dmead: No.
19:43:12 <dmead> :/
19:43:15 <fantasma> brad_: actually nvm I'll just look at it
19:43:19 <sorear> dmead: we have arrays but they are fixed size
19:43:19 <dons> dmead: there are mutable arrays.
19:43:28 <dons> dmead: but usually a tree is more appropriate
19:43:39 <dons> something like Data.Sequence
19:43:42 <dmead> ahh
19:43:43 <dmead> yea
19:43:49 <sjanssen> jcreigh: are you using an MVar or anything for Display?
19:43:51 <lispy> dmead: also, why do you want a mutable list?
19:43:51 <dmead> i have to traverse all around a tree
19:43:56 <dmead> and keep updating a list
19:43:57 <jcreigh> sjanssen: no...
19:43:57 <sjanssen> jcreigh: or using X11's thread support?
19:44:07 <brad_> fantasma - are you also on freebsd?
19:44:30 <sjanssen> jcreigh: this is going to be a problem
19:44:30 <sorear> sjanssen: what's wrong with having user code call X?
19:44:30 <lispy> dmead: i bet some "tying the knott" magic applies here
19:44:30 <jcreigh> neither. I figured I would be fine if only one thread made X11 calls. That's wrong, I guess?
19:44:30 <sorear> sjanssen: apis exist to be used!
19:44:30 <fantasma> brad_: instead of doing runhaskell Setup.lhs do runhaskell DefaultSetup.lhs
19:44:30 <dmead> lispy, oh?
19:44:31 <fantasma> brad_: yeah I am
19:44:35 <sjanssen> jcreigh: getting the next event is an X11 call
19:44:46 <lispy> dmead: yeah, it's basically the haskell idiom for things like dynamic programming
19:44:50 <dons> dmead: ok. sounds like a job for a tree, or Data.Sequence
19:44:50 <dons> sjanssen, jcreigh: so am i right in thinking no one is going to do the external sbar process, unless i do it myself?
19:45:01 <jcreigh> scheduleX $ (io $ safeNextEvents d) >>= mapM_ handle
19:45:02 <lispy> dmead: which is probably why you want a mutable list...just gussing here
19:45:11 <brad_> fantasma - there is no DefaultSetup.lhs file in the dir
19:45:13 <dmead> ahh
19:45:14 <dmead> hm
19:45:14 <sorear> dons: would you object to using X to communicate with Xmonad?
19:45:24 <dons> possibly.
19:45:25 <jcreigh> scheduleX writes into the Chan (X ()) (so we don't actually get events in that thread)
19:45:33 <sorear> awww:(
19:45:40 <sjanssen> jcreigh: didn't we decide that safeNextEvents is broken?
19:45:50 <fantasma> brad_: then you can create it yourself -> http://darcs.haskell.org/cabal/DefaultSetup.lhs
19:45:55 <dmead> yea, after processing the left branch of a tree i want the updates to the list to be visible to the right branch
19:45:55 <sjanssen> jcreigh: but the X () actions certainly make X11 calls
19:45:58 <sorear> sjanssen: safeNextEvents isn't impossible
19:45:59 <lispy> sjanssen: so just rename i t unsafeNextEwents ;)
19:46:26 <sorear> sjanssen: you can't write it with hWaitForInput, but it is certainly doable with a poll binding
19:46:50 <sjanssen> sorear: right
19:47:22 <jcreigh> ...and just for testing, I haven't got a binding to "poll", yet, some I'm simulating it with threadDelay (only for testing, sorear!)
19:47:36 <sjanssen> dons: jcreigh seems hell bent on doing it in process
19:47:51 <jcreigh> actually, my motivation is waning fast.
19:47:52 <lispy> dmead: http://www.haskell.org/hawiki/TyingTheKnot
19:47:54 <lambdabot> Title: TyingTheKnot - The Haskell Wiki
19:48:04 <jcreigh> now that I actually try to do it. :)
19:48:05 <sorear> dons: what's wrong with PropertyNotify, in your opinion?
19:48:13 <brad_> fantasma - got the file, did cabal confingure, but cabal build barfed
19:48:49 <fantasma> brad_: you did ``runhaskell DefaultSetup.lhs configure'' and that failed?
19:49:13 <jcreigh> surely the simple act of writing a X () value into a Chan doesn't actually execute it, right?
19:49:29 <brad_> not no, that step was fine, but the build step barfed
19:49:37 <sjanssen> jcreigh: no, that doesn't cause it to be executed
19:50:02 <sorear> data Layout = Full | Tall | Wide deriving (Enum, Bounded, Eq)
19:50:02 <sorear>  
19:50:02 <sorear> -- | 'rot' for Layout.
19:50:02 <sorear> rotateLayout :: Layout -> Layout
19:50:06 <sorear> rotateLayout x = if x == maxBound then minBound else succ x
19:50:25 <sorear> dons: you could just use {-! EnumCyclic !-} and depend on deriveth ;)
19:50:36 <sorear> 4 loc down!
19:50:57 <sjanssen> sorear: we get enough build complaints :(
19:51:02 <brad_> well its okay, i guess i will stick with dwm
19:51:03 <jcreigh> sorear: 2, the way we count.
19:51:09 <dons> brad_: aren't you supposed to build cabal with a makefile?
19:51:16 <dons> i thought it bootstrapped via 'make' ?
19:51:32 <brad_> dons - i have no idea. i am looking for some spoonfeeding
19:51:43 <lispy> at least on windows you build cabal initially with a make file
19:51:56 <dons> brad_: hmm. this isn't so great. basically, its the two libs we use that we don't control that people complain about
19:52:00 <dons> buildign Cabal, and building X11.
19:52:05 <dons> brad_: what OS are you on?
19:52:11 <brad_> freebsd6.2
19:52:11 <dons> maybe we could just distribute binaries..
19:52:37 <lispy> cabal should just come with ghc right?
19:52:42 <lispy> or do they need a very new version?
19:52:54 <brad_> dons- when you say "build cabal", my understanding is that cabal is just Setup.hs, what is there to build?
19:52:55 <dons> lispy: they need a new version on freebsd, it seems. due to the location of X11
19:53:05 <lispy> hrm
19:53:11 <dons> brad_: no, there's the Cabal library, which is a build system.
19:53:17 <sorear> dons: maybe we ought to wait for therp's SoC project before distring binaries? ;)
19:53:17 <dino-> lispy, Philippa, mauke: Thanks for help with parsec.
19:53:20 <gravity> Is freebsd still on xorg 6.x?
19:53:28 <dmead> oh btw
19:53:29 <brad_> yes, freebsd is out of touch with X, they are going to destroy /use/X11R6
19:53:35 <lispy> dino-: you're always welcome, but i didn't help much :)
19:53:37 <brad_> they are going to 7.2
19:53:40 <brad_> at some point
19:53:41 <dmead> is there a way to turn off occurs checking in pattern matching?
19:53:46 <dons> brad_: and currently you've got a darcs version of Cabal, that you're trying to build, right?
19:53:49 <brad_> i am sure by freebsd7
19:53:54 <dino-> lispy: Yeah. The API doc is missing for that stuff as well, that whole Combinators module.
19:53:55 <sorear> dmead: no!
19:54:00 <dino-> Looking at source for parsec now.
19:54:01 <sjanssen> hmm, even status bar as an external process is going to require safeNextEvent
19:54:07 <dmead> boo
19:54:07 <sorear> sjanssen: no
19:54:14 <brad_> dons- i am not sure, i think my Cabal came with my ghc, right?
19:54:14 <jcreigh> sjanssen: how so?
19:54:17 <brad_> not sure
19:54:17 <sjanssen> sorear: yes, to handle expose events
19:54:30 <sjanssen> sorear: and redraw the window when status changes
19:54:32 <brad_> i am using freebsd port for ghc6.6
19:54:38 <lispy> dino-: yeah, i almost recommended that...just imprementing manyTill2 or something that has the type you need
19:54:44 <dons> brad_: there is a cabal that comes with ghc, yes. but it has a bug wrt. ld flags that means on FreeBSD you need to update your version of Cabal
19:54:51 <brad_> AH
19:54:52 <sorear> I'm so fed up with the "AWW! IT'S NOT POSSIBLE!" that I'm going to implement it [PropertyNotify] myself.
19:54:55 <sjanssen> both of these can happen at any time -- and therefore must not exclude each other
19:54:57 <brad_> where can i find it?
19:54:58 <dons> brad_: so I thought that's what you were doing?
19:55:02 <dons> haskell.org/cabal
19:55:15 <dons> get the darcs version of it. build it and install it.
19:55:22 <dons> then hopefully X11-1.2 builds out of the box
19:55:24 <dons> and you're home.
19:55:26 <brad_> sorry dons, i am an idiot, i have not understood directions
19:55:31 <dons> its ok :-)
19:55:32 <dmead> does it still crash kde ?
19:55:34 <sjanssen> sorear: PropertyNotify is a pretty big hack, though
19:55:36 <brad_> i will try again
19:56:14 <sorear> dons: where is the xmonad print call?
19:56:17 <sjanssen> sorear: it's an even bigger hack because we're just too lazy to write multiple event loops
19:56:37 <brad_> exiting temporarily to see if i can get this right...
19:56:54 <sorear> ConfigureNotify -- where is the line that prints this stuff?
19:56:57 <dino-> But I could just fall back on trusty regex if necessary. What I want to do with parsec is simply this: .*(\d{3}).xyz
19:56:57 <dino-> lispy: Yeah or skipManyTill, something like that.
19:57:15 <sjanssen> sorear: look in 'windows' IIRC
19:57:19 <lispy> dino-: skipManyTill rings a bell...
19:57:20 <dons> ?temp
19:57:21 <lambdabot>   now 17.2°, min 15.2°, max 18.4°, rain 0.0mm, wind 30km/h SSW
19:57:38 <dmead> ?temp
19:57:39 <lambdabot>   now 17.2°, min 15.2°, max 18.4°, rain 0.0mm, wind 30km/h SSW
19:57:55 <dmead> it doesn't figure your location an contact NOAA?
19:58:00 <jcreigh> sjanssen: I think we could get around it with a third process. statusbar &; while true; do date; slee 1; done | send_text_to_statusbar
19:58:02 <dons> heh
19:58:06 <jcreigh> sjanssen: but that may or may not be a good idea.
19:58:22 <sorear> where is windows defined?
19:58:35 * sorear remembers grep
19:58:36 <dons> grep
19:58:39 <dmead> in the dictionary
19:58:47 <dino-> lispy: Alas, there's only skipMany and skipMany1
20:00:20 <lispy> dino-: i found a skipManyTill on the web, but it's got the wrong type
20:00:30 <lispy> dino-: http://www.khjk.org/~sm/code/k-tex/Text/ParserCombinators/Nonlinear.lhs
20:00:34 <lambdabot> http://tinyurl.com/yq2yqk
20:00:36 <brad_> by the way, if i install Cabal locally to $HOME/local using --prefix=$HOME/local and --user, will it override the old default Cabal?
20:01:23 <lispy> ?hoogle skipManyTill
20:01:24 <lambdabot> No matches found
20:01:54 <dons> brad_: it will be usable, yes
20:02:04 <brad_> by the way your advice seems to be working...
20:02:11 <dons> oh good!
20:02:16 <dons> cabal is building, or X11 is building?
20:02:19 <brad_> not done building yet but it isn't crapping out where it did
20:02:21 <brad_> X11
20:02:24 <dons> great!
20:02:27 <dino-> lispy: Interesting! They've got it defined as: skipManyTill p q = skip (manyTill p q)
20:02:39 <lispy> ?tell ndm a thought for failed hoogle searches.  I might misremember some function as skipTillMany when the real name is skipManyTill.  Maybe it could break up identifiers on camel case and permute them.
20:02:40 <lambdabot> Consider it noted.
20:02:41 <dons> brad_: this is our most FAQ , btw. getting X11 to build on bsd systems.
20:02:59 <dcoutts> dons: was this a solution to the 'how do we find out about -L/usr/X11R6/lib' problem?
20:03:01 <brad_> by the way, does anyone have xmonad sample configs?
20:03:12 <brad_> yes dcoutts
20:03:22 <dons> dcoutts: seems to be.
20:03:24 <brad_> the answer was as dons said, update Cabal!
20:03:43 <dons> brad_: we need a collection of small samples, do you think?
20:03:43 <lispy> dino-: yes, parsec combinators are usually impressively simple to define
20:03:46 <dcoutts> dons: but I don't understand! we've not made cabal magically know about -L/usr/X11R6/lib
20:03:50 <dons> currently people just hack Config.hs only a little
20:03:54 <dcoutts> dons: what has actually changed?
20:03:58 <brad_> yes dons, i like to use dwm so each app fills the entire screen
20:04:00 <dons> dcoutts: I don't know...
20:04:07 <brad_> more like gnu screen for X
20:04:12 <dons> brad_: ok. so to get that just stay in full screen mode
20:04:18 <dons> no config hacking required.
20:04:25 <dcoutts> dons: can someone check with build -v, is cabal passing -L/usr/X11R6/lib or what?
20:04:38 <dons> dwm doesn't do full screen very well (or at least, it used not to)
20:04:38 <dcoutts> perhaps it was something in X11's configure script
20:04:44 <dons> dcoutts: hmm. yes
20:05:22 <dons> yes, there were patches to X11's configure recently
20:07:01 <sorear> Oh, nice.
20:07:11 <sorear> X11 doesn't bind XChangeProperty
20:07:20 <sorear> are there haddocks for X11-extras?
20:07:29 <sjanssen> sorear: of course it doesn't
20:07:55 <dons> brad_: so X11 built? got xmonad built now?
20:08:05 <sorear> is that sjanssen-cynical or sorear-stupid?
20:08:14 <brad_> dons - X11-extras gave barfage
20:08:18 <sjanssen> sorear: big on the cynical
20:08:26 <dons> brad_: more info.
20:08:32 <fantasma> sjanssen: did you get the patch?
20:08:33 <brad_> a million of these: Extras.hsc:654:0:  error: syntax error before ')' token
20:08:40 <sjanssen> brad_: did you run autoreconf in X11-extras?
20:08:54 <brad_> sjanssen - no, i will try that
20:09:03 <dons> sjanssen: i think i'll update X11-extras now eh? a new release with configure
20:09:31 <brad_> should autoreconf happen before Cabal build steps?
20:09:39 <dons> only for X11-extras
20:09:40 <sjanssen> brad_: yes
20:09:48 <dons> it should happen before the configure step
20:09:59 <fantasma> brad_: no, this is what I had to do for X11-extras since autoreconf didnt work for me -- I copied *.buildinfo from another package and put it in that directory
20:10:00 <sjanssen> only for the broken X11-extras-0.0 release, to be precise
20:10:11 <dons> fantasma: hmm.
20:10:31 <dons> sjanssen: i'm going to upload X11-extras-0.1 now
20:11:12 <brad_> thanks dons and fantasma, i will wait!
20:11:28 <dons> sjanssen: this also means adding configure to the darccs repo
20:11:35 <sjanssen> dons: just use cabal sdist
20:11:45 <dons> that picks up ./configure ?
20:11:49 <sjanssen> I don't think configure belongs in the repo -- at least as I understand it
20:12:00 <brad_> well at least i can say i contributed something for once, as a guinea pig!
20:12:09 <sjanssen> dons: yeah, I modified the .cabal file to do that
20:12:14 <dons> ah ok.
20:12:23 <sjanssen> dons: you should probably double check the tarball, just in case
20:12:27 <fantasma> brad_: did you try making X11-extras.buildinfo?
20:12:32 <dons> sjanssen: will do so.
20:12:41 <brad_> how did you do that fantasma?
20:12:55 <fantasma> brad_: I'll paste one of mine just a sec
20:12:59 <brad_> awesome!
20:13:09 <dons> brad_: anyway, autoreconf ; configure ; build  ; install
20:13:14 <dons> no need to wait on me for this
20:13:27 <jcreigh> sjanssen: that's correct. "configure" definitely does *not* belong in the repo.
20:13:39 <dons> ok. if sdist can handle it, that's good
20:13:43 <sorear> can anyone divine what the return value of XChangeProperty is?
20:13:51 <sorear> it isn't void and isn't documented
20:14:17 <sjanssen> sorear: error code, I believe
20:14:22 <hpaste>  fantasma pasted "brad_ here you go" at http://hpaste.org/1556
20:14:24 <sjanssen> all of xlib is like that
20:14:32 <sorear> I thought X programs died on error :)
20:15:14 <hpaste>  petekaz pasted "how to make my trie strict?" at http://hpaste.org/1557
20:15:28 <sorear> scary sig of the day: xChangeProperty :: Display -> Window -> Atom -> Atom -> CInt -> CInt -> Ptr CUChar -> CInt -> IO Status
20:15:48 <petekaz> how can I make 'insertWith' strict with the least amount of work?  Can I use a bang pattern?  Where would I use it?
20:16:24 <sjanssen> petekaz: use insertWith'
20:16:26 <sorear> sjanssen: XChangeProperty wants a char*.  should I wrap it with Data.ByteString.Base.withCStringLen?
20:16:28 <hpaste>  jcreigh pasted "my (broken) attempt at threading in xmonad" at http://hpaste.org/1558
20:16:30 <sorear> or [Char]?
20:16:44 <jcreigh> can you guys see anything really obvious I'm doing wrong?
20:16:46 <sjanssen> sorear: [Char] for 6.4 compatibility
20:17:00 <sorear> Ow.
20:17:09 <petekaz> sjanssen: ahh .. instead of M.insert?
20:17:24 <petekaz> but don't I need to make my insertWith strict as well?
20:18:22 <sjanssen> petekaz: use insertWith' instead of insertWith
20:18:35 <sjanssen> petekaz: oh sorry, I'm confused
20:18:41 <sjanssen> thought you were talking about Data.Map
20:18:41 <hpaste>  monochrom annotated "how to make my trie strict?" with "an improvement" at http://hpaste.org/1557#a1
20:19:31 <sorear> sjanssen: this is bytes, but usually characters.  [Char] or [CUChar]?
20:19:57 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/X11-extras-0.1
20:19:59 <lambdabot> http://tinyurl.com/yucwdk
20:20:16 <sjanssen> sorear: do you see any convention in X11?  I'd follow that
20:20:42 <jcreigh> (BTW, sorry for the ugly code. It's alpha quality ATM...)
20:21:11 <dons> sjanssen: X11-extras, Fail: ./_darcs/inventory: openBinaryFile: permission denied (Permission denied)
20:21:17 <petekaz> monochrom: is it easier just to use a ! somewhere?  perhaps in front of the 'm' variable?  or would it be better to do '!t@(T mv m)'?  Would that have the same effect?
20:21:30 <sjanssen> jcreigh: the problem is that nextEvent can happen while an X () event is running
20:21:49 <jcreigh> sjanssen: how?
20:22:02 <jcreigh> it's only called in safeNextEvents, which is only called in the X11 thread.
20:22:06 <monochrom> No.
20:22:49 <petekaz> (not a man of many words eh)
20:22:59 <petekaz> I'll stick with your version.
20:23:24 <brad_> well x11-extras-0.1 worked, and i got xmonad to install!
20:23:28 <sjanssen> dons: try again
20:23:31 <dons> great!
20:23:40 <brad_> now i will exit and see what happens.....
20:23:50 <brad_> thanks for all the help and patience!
20:24:23 <petekaz> monochrom: wouldn't I need to make sure that the M.insert is also forced?  Why do we only need a seq in one of the lines?  and not the others?
20:25:16 <monochrom> Data.Map.Map itself is highly lazy.  seqing it does not go very far.
20:25:36 <sjanssen> jcreigh: oh, it hangs because the call to getLine will block
20:25:43 <petekaz> seq does not force everything under it to occur?
20:25:55 <jcreigh> block? but...just *that* thread, right?
20:26:10 <sjanssen> monochrom: Data.Map is spine strict
20:26:19 * jcreigh is horribly naive
20:26:19 <brad_> here in xmonad!
20:26:37 <brad_> oh dear, i don't know any of the key sequences
20:26:40 <monochrom> > let x = True : undefined in seq x (head x)
20:26:42 <lambdabot>  True
20:26:47 <jcreigh> brad_: just like dwm, for the most part
20:26:49 <fantasma> brad_: check out the man page!
20:26:52 <monochrom> That tells you how far seq brings you.
20:26:53 <sjanssen> jcreigh: but it is blocking the X11 handler thread
20:26:59 <fantasma> http://xmonad.org/manpage.html
20:27:00 <lambdabot> Title: Manpage of xmonad
20:27:05 <brad_> well you will have to give me one - starting my browser?
20:27:12 <brad_> then i can check the docs!
20:27:17 <dons> brad_: or just look in xmonad/Config.hs
20:27:31 <dons> but they keys are mostly the same as dwm
20:27:33 <fantasma> sjanssen: push my patch
20:27:38 <fantasma> ;)
20:27:44 <monochrom> If Data.Map is strict along its spine, maybe there is benefit seqing that.
20:27:45 <brad_> cool, i will check the Config.hs
20:27:51 <brad_> two more questions:
20:27:55 <hpaste>  sorear pasted "good enough?" at http://hpaste.org/1559
20:28:01 <sorear> sjanssen: ?
20:28:04 <brad_> 1. is xmonad a good code base to study to learn how haskell does event code?
20:28:12 <brad_> or is it all in the xlib bindings?
20:28:27 <brad_> 2. is there a haskell foundation for donations?
20:28:30 <petekaz> monochrom: to seq that, could we just use this bang pattern I was reading about?
20:28:42 <petekaz> i.e., !m
20:28:46 <sjanssen> fantasma: I haven't received a patch
20:28:46 <monochrom> Yes.
20:28:46 <brad_> i like to contribute money to freebsd.org and wikipedia, would like to support haskell
20:28:51 <dons> 2. no :/ 1. hmm. its a good code base. but something with haskell threads might be better
20:29:06 <dons> we do have a .org, but no donation system.
20:29:10 <fantasma> sjanssen: hmmm, let me try again
20:29:21 <Philippa> though it'd be worth raising on the haskell mailing list
20:29:23 <brad_> dons, you should get a paypal link for haskell.org
20:29:40 <brad_> i would send donations, i cannot help with code, i am too stupid, but i can contribute $$
20:29:41 <jcreigh> sjanssen: I'm sorry I'm so dense about this. How does the "getLine" thread end up blocking the X11 handler thread?
20:29:55 <sproingie> there's probably plenty of haskell hackers who wouldn't mind donations
20:30:10 <sproingie> the core haskell devs are probably pretty well paid :)
20:30:27 <dons> brad_: hehe. we've never really considered paid work in the community, since people already tend to have haskell jobs :-)
20:30:37 <dons> but i'm sure it would help motivate some of the undergrads
20:30:42 <sorear> sjanssen: shall I push the patch?
20:30:51 <dons> its an interesting question in general. not sure how best to proceed in this respect.
20:30:58 <brad_> it can also pay for bandwith, machines, etc
20:31:18 <dons> brad_: right. that's what we're using last year's SoC money for.machines.
20:31:31 <brad_> cool, thanks google
20:32:12 <sjanssen> jcreigh: you call scheduleX (trace =<< getLine) -- the X thread will read that (trace =<< getLine) and execute it, blocking if there is no input
20:32:26 <sjanssen> sorear: you're able to push the patch?
20:32:37 <sorear> sjanssen: er, send
20:33:03 <sjanssen> sorear: yes, feel free
20:33:44 <brad_> by the way, it would be cool if xmonad's build had a config option to use our own Config.hs
20:33:54 <fantasma> sjanssen: when I record the patch, the last patch is the file with three dollar signs added in, what is that?
20:34:10 <jcreigh> brad_: that way we currently do that is for you to edit Config.hs and make it your own.
20:34:33 <sjanssen> fantasma: I don't know
20:34:38 <brad_> yes jcreigh, but once that is built, it would be cool to say --withconfig=
20:35:22 <brad_> that is one thing about dwm that kind of tweaks me, the hassle of copying around the configs
20:37:34 <hpaste>  monochrom annotated "how to make my trie strict?" with "more improvement" at http://hpaste.org/1557#a2
20:38:10 <sjanssen> sorear: with the PropertyNotify approach, it seems we'll need an X client for each thing that wants to publish some state
20:38:41 <ivanm> *nod*
20:38:50 <sorear> sjanssen: what kinds of things want to publish state?
20:38:53 <ivanm> whoops, wrong channel
20:38:59 <monochrom> If newtrie is not seq'd, it remains a thunk in (T mv (M.insert k newtrie m)).  I haven't thought seriously about whether it's good or bad.  But it's certainly more strict now.
20:39:35 <sjanssen> sorear: xmonad publishes workspace state.  We also want the statusbar to be able to display user extensible information (date, battery state, etc.)
20:39:49 <sjanssen> sorear: so at least 2
20:39:53 <jcreigh> sjanssen: oh, I had thought that "scheduleX . trace =<< getLine" would do the getLine in the current thread. hmm.
20:40:12 <sorear> sjanssen: xmonad's state is published from within xmonad
20:40:25 <sorear> sjanssen: how do I bind a #define?
20:40:32 <sorear> specifically PropModeReplace
20:40:48 <xpika> what are intsets for?
20:40:53 <sorear> ints
20:40:54 <sjanssen> sorear: don't know off the top of my head
20:41:04 <jcreigh> propModeReplace = #{const PropModeReplace}, I think
20:41:08 <sorear> jcreigh: ty.
20:41:39 <dmead> @where stateT
20:41:40 <lambdabot> I know nothing about statet.
20:41:45 <dmead> @where state monad
20:41:45 <lambdabot> I know nothing about state.
20:42:10 <monochrom> My purpose is to chase down all potential occurences of "fn v v'" and seq them.  There are two occurences.  One is directly in the code.  The other is hidden behind the recursive call.  I seq both and I get all "fn v v'"s.  I am not too keen on seqing Data.Map, since it's behind a facade and little can be touched.  If you like, you can seq them too, but I'm doubtful of the benefit.  fn v v' is by and large the dominating prob
20:42:10 <monochrom> lem.
20:42:11 <dmead> @where mindreading
20:42:12 <lambdabot> I know nothing about mindreading.
20:42:15 <dmead> obviously.
20:42:32 <brad_> in xmonad's Config.hs, how do i specify that an app start in a particular workspace?
20:42:44 <brad_> in dwm, it is the Rule declaration
20:42:45 <sjanssen> jcreigh: you're right, I parsed that line incorrectly
20:42:48 <kc5tja> I know nobody probably cares, but I just heard this -- we discovered the first Earth-class planet within a star's habitable zone in the Gliese 581 star system.  Distance: 20.5 ly.  Mass: about 5 Me (where 1 Me is one earth mass), with a diameter of 1.5 De (yeah, 1.5 times the diameter of Earth).  Computer models of the planet, given what we know of it now, seems to indicate a rocky or water world.
20:42:51 <sjanssen> brad_: xmonad can't do that yet
20:42:54 <dmead> yea
20:42:55 <kc5tja> http://www.space.com/scienceastronomy/070424_hab_exoplanet.html
20:42:57 <dmead> kc5tja, i saw that too
20:42:57 <lambdabot> Title: SPACE.com -- Major Discovery: New Planet Could Harbor Water and Life
20:43:00 <dmead> pretty awesome
20:43:09 <dmead> but it's 1.5x our size
20:43:26 <brad_> oh, well can i use alt-shift-2 to move it?
20:43:29 <dmead> prolly be pretty hard on your spine
20:43:32 <kc5tja> dmead: That doesn't mean anything.  Life can exist at a wide variety of masses.
20:43:33 <sjanssen> brad_: correct
20:43:38 <brad_> cool!
20:43:38 <dmead> no, i mean for us
20:43:41 <dmead> it's not really useful
20:43:49 <monochrom> I read 1 Me as 1 mega electron-Volt. :)
20:44:02 <dmead> any inhabitants will have to submit to our manifest destiny
20:44:04 <dmead> :P
20:44:07 <kc5tja> Actually, it's *5 times* our planet's mass, so it has 5x the gravitational pull.
20:44:12 <dmead> oh
20:44:15 <sorear> kc5tja: no
20:44:16 <dmead> i read 1.5x
20:44:27 <dmwit> 1.5x the *radius*
20:44:31 <sorear> kc5tja: 5x our pull *at the same distance*
20:44:34 <dmead> ahh
20:44:39 <dmead> what did they say about mass?
20:44:41 <sorear> kc5tja: don't forget gravity falls off
20:44:43 <dmead> is that 5x?
20:44:44 <jcreigh> sjanssen: dang it. I was hoping that was it.
20:44:45 <narain> > 5 / (1.5 ^ 2)
20:44:46 <lambdabot>  2.2222222222222223
20:45:13 <sjanssen> sorear: by my count, there will be three clients: statusbar listener/drawer, xmonad (already exists, writes info about workspace changes), second writer (user extensible information)
20:45:42 <dons> right.
20:45:44 <sorear> since we are already going OOP for the sbar drawer, that's only +1
20:45:48 <dons> two writers, one reader.
20:45:49 <monochrom> narain++  quick and good physics
20:46:03 <narain> heh, thanks
20:46:08 <dons> sbar could take user stuff from stdin, xmonad info from a named pipe
20:46:10 <dons> for example
20:46:12 <sjanssen> dons: the yucky thing is that these three things each need their own connection
20:46:20 <sjanssen> or we need to bind to poll
20:46:24 <kc5tja> That's 1.5 times our radius.
20:46:59 <monochrom> I don't want to bring my laptop there!  It'll weigh 12 pounds instead of 5.5...
20:47:45 <kc5tja> http://www.thisislondon.co.uk/news/article-23393718-details/Found:+The+New+Earth/article.do
20:47:46 <jcreigh> dons: how does sbar read from stdin and a named pipe, given that it needs to wait for X11 expose events as well? (right?)
20:47:48 <lambdabot> Title: Found: The New Earth | News | This is London, http://tinyurl.com/2cwo5y
20:47:49 <sorear> Haha.  My patch didn't work!
20:47:53 <kc5tja> " It has a mass five times that of Earth, probably made of the same sort of rock as makes up our world and with enough gravity to hold a substantial atmosphere.
20:47:56 <kc5tja> "
20:48:00 <jcreigh> I thought that was the whole problem to begin with.
20:48:02 <sorear> Turns out I need to install after recompiling!
20:48:20 <sjanssen> sorear: do you concur on the three connections statement?
20:48:31 <kc5tja> Anyway, I need to get home...
20:48:48 <dons> still, what about dzen.
20:48:54 <sorear> sjanssen: yes.
20:49:14 <dons>  (echo "This is a message"; sleep 10) | dzen2
20:49:20 <dons> http://gotmor.googlepages.com/dzen
20:49:21 <lambdabot> Title: gotmor - dzen
20:49:45 <sorear> there, sent.
20:49:55 <dons> maybe we should try dzen
20:50:03 <sjanssen> dons: do you know if dzen can read several pipes at once?
20:50:21 <dons> investigating.
20:50:33 <sorear> dons: it's on the ml now
20:50:39 <dmead> ah!
20:50:40 <dmead> i got it
20:50:44 <dmead> AH HA
20:50:59 <dons> sorear: so that's a demo patch, basically, of how we'd do IPC via X11?
20:51:26 <dons> sjanssen: dzen seems to fit the bill for some of sbar anyway
20:51:31 <Jessehk> I know this is a silly question, but I'm looking for a simple answer. :)
20:51:32 <jcreigh> I didn't see any option in dzen to read multiple pipes. Not to say it's not there.
20:51:39 <dons> might need a multiplexing wrapper in front to suck in the two input optoins
20:51:47 <Jessehk> can I make a classe's read function the "inverse" of its show function?
20:52:04 <dons> mysbar | mux-from-xmonad-named-pipe | dzen2 -- is what i'm thinking
20:52:18 <sorear> dons: not a demo, it's a real start
20:52:33 <sorear> dons: run xmonad, create some windows, xprop -root
20:52:37 <Cale> Jessehk: by writing it that way, sure
20:52:38 <sjanssen> dons: we can even do the muxing in xmonad, if we want
20:52:39 <monochrom> Did you program your own show function?
20:52:46 <dons> oh,  echo "Applications" | dzen2 -l 4 -p -m < menufile
20:52:50 <Cale> Jessehk: You can't get an automatic inverse.
20:52:59 <Jessehk> Cale: That would've been neat. ;)
20:53:23 <monochrom> automatic inverse is the subject matter of a chapter in Bird and de Moor "Algebra of Programming"
20:53:28 <sorear> sjanssen: what's your opin on my patch?
20:53:36 <jcreigh> dons: It's non-obvious to me how to do a statusbar nicely with multihead and dzen. (multiple dzens? Only one statusbar?)
20:53:48 <dons> sjanssen: yeah.
20:53:52 <dons> xmoand | dzen
20:54:25 <dons> sjanssen: so the idea would be,   mysbar | xmonad | dzen ?
20:54:35 <dons> where xmonad has a stdin/stdout mux?
20:54:38 <lispy> does ghc have anything like distcc?
20:54:51 <sorear> lispy: no.
20:54:51 <sjanssen> dons: yeah
20:54:53 <dons> sjanssen: runing in a simple thread that does no X calls
20:55:01 <dons> and just waitFDs on stdin
20:55:02 <sjanssen> jcreigh: probably multiple dzens, I guess
20:55:10 <sjanssen> jcreigh: a little bit of a problem
20:55:11 <sorear> dons: that wouldn't help with interactivity though
20:55:32 <lispy> sorear: *pout* what about using distcc with ghc?
20:56:05 <sjanssen> lispy: I can think of exactly one Haskell project that could really use distcc
20:56:27 <Korollary> JHC?
20:56:35 <sjanssen> s/distcc/distributed compilation
20:56:41 <bos> @hoogle pow
20:56:42 <lambdabot> No matches found
20:56:50 <lispy> sjanssen: darcs could benefit, not a huge amount...but it would be handy
20:56:55 <dons> sjanssen: seen http://del.icio.us/url/15451625a1e025f46fefcb3239a80329
20:56:56 <lambdabot> Title: del.icio.us/url/15451625a1e025f46fefcb3239a80329
20:56:59 <sorear>         FILE * f = fopen(GLIDERDB,"r");
20:56:59 <sorear>         if (ferror(f)) {
20:57:01 <sjanssen> lispy: how long is a typical darcs build?
20:57:03 <sorear> wow.
20:57:22 <lispy> sjanssen: O(n)
20:57:34 <sorear> bos: (^)
20:57:40 <lispy> sjanssen: i haven't timed it...but on my ibook (for example) it takes a while...10 minutes probably
20:57:42 <sorear> > 2.2 ** 10
20:57:44 <lispy> mayb 20
20:57:44 <lambdabot>  2655.9922791424024
20:57:52 <sorear> > 2 ^^ -10
20:57:53 <lambdabot>      precedence parsing error
20:57:53 <lambdabot>         cannot mix `(^^)' [infixr 8] and prefix...
20:57:57 <sorear> > 2 ^^ (-10)
20:57:59 <bos> @type (^)
20:57:59 <lambdabot>  9.765625e-4
20:58:01 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
20:58:02 <sorear> > 2 ^ 10
20:58:04 <lambdabot>  1024
20:58:07 <bos> @type (^^)
20:58:10 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
20:58:15 <sorear> @src (^)
20:58:16 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
20:58:18 <bos> ah, thanks.
20:59:10 <bos> @hoogle Double -> Integer
20:59:11 <lambdabot> No matches, try a more general search
20:59:19 <bos> @hoogle fromRational
20:59:20 <lambdabot> Prelude.fromRational :: Fractional a => Rational -> a
20:59:42 <bos> @type floor
20:59:44 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
21:02:44 <dons> ok. dzen2 seems plausible
21:02:51 <jcreigh> dons, sjanssen: Okay, I can't figure out why it's locking up. I'm giving up. Both methods of implementing a statusbar seem fraught with peril to me, and I'm obviously not competent enough at present to pull off the one that seems to me as if it would suck less. Please do not feel at all compelled to implement it one way or the other because I like (at least the concept of) threading; do what seems best to you.
21:02:55 <dons> while true ; do echo hello ; sleep 1 ; done | dzen2 works as expected, pretty much
21:03:16 <lispy> dons: have you seen the new lazy repos? with darcs?
21:03:30 <jcreigh> if it turns out that there's something that sits at the top of the screen and gives workspace info and the window name, I will be happy.
21:03:40 <monochrom> lazy repo??!!!
21:03:56 <lispy> monochrom: yeah, it's very new
21:04:15 <lispy> i've yet to try it, but it sounds cool...i guess darcs doesn't fetch patch files until they are needed
21:04:26 <monochrom> If no one pulls then a commit will just sit there? :)
21:04:34 <brad_> in xmonad - this config line seems not to work: , ((modMask .|. shiftMask, xK_w), spawn "exec firefox")
21:04:49 <brad_> nor removing the exec
21:05:01 <sjanssen> dons: and how do we support multiple heads?
21:05:02 <lispy> monochrom: heh
21:05:10 <jcreigh> brad_: mod-shift-w is the default binding to switch to the first screen.
21:05:10 <lispy> will xmonad also work in windows?
21:05:17 <lispy> like that blackbox port?
21:05:18 <brad_> ooohhh
21:05:21 <brad_> okay
21:05:32 <monochrom> This is vulnerable to all kinds of philosophy jokes.
21:05:32 <brad_> is mod-shift-f open?
21:05:37 <brad_> f for firefox?
21:05:37 <jcreigh> so that's overriding yours, because it's later in the list.
21:05:46 <jcreigh> yeah, mod-shift-f is open in the default config.
21:06:05 <brad_> thanks jcreigh!
21:06:22 <monochrom> "If no one is around when a patch is committed to the repos, does it make a sound?"
21:06:34 <jcreigh> if you don't have a multihead setup, you can probably just comment out those "keybindings to other screens" lines (near the end of the config file) and free up those keys.
21:06:53 <jcreigh> hmm, maybe xmonad should only bind them if it detects multiple screens.
21:06:55 <lispy> monochrom: well, really it's the other way around...patches are only fetched as needed :)
21:07:18 <monochrom> This world is going crazier and crazier!
21:07:38 <sorear> jcreigh: shall I implement the status bar for you?
21:08:36 <sjanssen> I'm beginning to think X properties are the way to go
21:09:00 <sorear> sjanssen: do you think that because it means you don't have to write code? :p
21:10:18 <fantasma> do you need sendmail installed to use darcs send?
21:10:44 <sjanssen> fantasma: yes, you'll need a mailer set up
21:11:07 <sjanssen> fantasma: use darcs send -o and send the patch as an attachment
21:11:28 <fantasma> sjanssen: do I also need to send the file xmonad.1 ?
21:11:35 <sjanssen> fantasma: no
21:11:44 <fantasma> why not?
21:11:57 <sjanssen> darcs send -o generates a self contained patch
21:12:51 <sorear> fantasma: do yourself a favor.  I speak from experience both ways - in the long run having the local MTA working is very much nicer than having to fuss with side channels.
21:13:18 <fantasma> yeah but configuring sendmail is such a pain
21:13:29 <sorear> then install a different mta
21:13:31 <dcoutts> fantasma: it doesn't have to be sendmain, use msmtp
21:13:37 <sorear> <- exim
21:13:52 <jcreigh> fantasma: but it's O(1) pain
21:14:02 <sorear> fantasma: I said MTA, not sendmail.
21:14:02 <sproingie> i use postfix.  anything that isn't sendmail is generally better
21:14:18 <jcreigh> fantasma: (oh, and defintely don't use "sendmail". use exim, postfix, or whatever. just not sendmail)
21:14:20 <dcoutts> fantasma: erm ssmtp I mean, it's a really small forwarding mailer, one line of config to set your ISP's smtp server
21:14:38 <fantasma> dcoutts: thank you, that's exactly what I need
21:14:43 <sorear> fantasma: why are you afraid of mtas?
21:14:56 <fantasma> ?jargon MTA
21:14:58 <lambdabot> No match for "MTA".
21:15:04 <jcreigh> mail transfer agent
21:15:05 <dons> hmm. i think we can do a lot with dzen, from playing around with it.
21:15:08 <dcoutts> sorear: they often require too much config and sit in memory doing nothing when you don't need them
21:15:15 <dons> if we can just get xmonad to keep it top most. then we'll be set.
21:15:22 <sorear> come on people.  SWAP!!
21:15:27 <dcoutts> ssmtp just runs when you actually foward mail
21:15:37 <dcoutts> it's just what you need for darcs
21:15:49 <sorear> dcoutts: But what about inetd? ;)
21:16:07 <dcoutts> that's for listening for incomming things
21:16:28 <dcoutts> this is for providing the /usr/sbin/sendmail interface that darcs expects
21:16:29 <sorear> dcoutts: mail being sent is an incoming thing
21:16:32 <sorear> oh, right
21:16:52 <sorear> bah, I thought darcs used localhost:25 for some reason
21:16:53 <jcreigh> dons: doesn't it normally stay topmost? (ie, I think it does magic like dmenu)
21:17:05 <sproingie> some stuff likes to connect to local port 25, it's more portable than invoking a sendmail exe
21:17:05 <dons> seems to go bottommost for me.
21:17:08 <dons> unlike dmenu
21:17:13 <jcreigh> strange
21:17:14 <sproingie> ssmtp from inetd is nice
21:17:14 <dons> well, it starts topmost
21:17:25 <dons> then if i move to a new workspace, and back, it ends up on the bottom
21:17:43 <jcreigh> dons: ah, yes, you're right.
21:18:01 <jcreigh> well, you wouldn't notice if xmonad resized its windows not to overlap with the statusbar.
21:18:08 <dons> right.
21:18:21 <dons> set aside an area at the top for a statusbar
21:20:15 <jcreigh> how would you represent workspace status? ASCII art?
21:20:40 <sjanssen> can you do color/highlighting with dzen2?
21:20:49 <jcreigh> sjanssen: not that I could see. :(
21:21:05 <dons> sjanssen: colour?
21:21:26 <dons> seems to support configurable fg/bg/menu items
21:21:47 <jcreigh> dons: but to make "3" show up a different color because that's the current workspace.
21:21:50 <jcreigh> for example
21:22:13 <dons> i'd imagine if we want to use this, we'll fork and hack it
21:22:20 <sjanssen> http://gotmor.googlepages.com/dzen2-collapsed-dwm.png -- is this thing at the top dzen2?
21:22:41 <dons> sjanssen: yeah
21:22:43 <jcreigh> sjanssen: yeah, the red bar with "Syslog" centered in it.
21:22:48 <dons> the red thing
21:23:43 <jcreigh> we'd have a statusbar written in C?
21:23:48 <sjanssen> ah, so the things on the left and right are dwm's
21:23:59 <jcreigh> sjanssen: that's what it looks like to me.
21:24:04 <dons> sjanssen: looks like it, though dzen runs across the entire screen width by default
21:24:19 <dons> jcreigh: only if we want something working now.
21:24:28 <dons> but feel free to write a more customised dzen in haskell for us
21:24:49 <bos> we'll need a #xmonad soon.
21:24:56 <dons> hmm. yes.
21:24:57 <jcreigh> meh
21:26:52 <bos> btw, xmonad has horrible failure modes if it can't access the correct display.
21:27:07 <jcreigh> bos: oh? What does it do?
21:27:20 <bos> e.g. if i try to run it in an Xnest :1, but it can't run there, it tries to manage :0 instead.
21:27:39 <bos> and it doesn't seem to accept the usual -display :1 argument.
21:27:49 <bos> instead, it turns :0 grey.
21:27:54 <jcreigh> bos: oh, I think xmonad just always wants to start on :0
21:27:59 <bos> so i have to kill my primary x session.
21:28:16 <bos> i can force it to run on :1 with DISPLAY=:1, but this behaviour i found surprising.
21:28:21 <lispy> i bet that's an easy bug to fix
21:28:30 <jcreigh> yeah.
21:28:34 <lispy> bos: i bet you could have it patched in no time! ;)
21:28:40 <sorear> or we could just support ICCCM!
21:28:50 <sorear> then xmonad would replace your :0 mgr
21:30:40 <jcreigh> hmm. XOpenDisplay() says that it uses $DISPLAY if the diplay its given is NULL. but we pass the empty string...
21:30:41 <dons> bos, hmm. ok. thanks for the report. we've done very little investgating of non-simple display setups
21:30:54 <dons> jcreigh: oh, hmm.
21:30:58 <jcreigh> I wonder if the X11 package converts that to NULL.
21:31:00 <bos> http://uk.geocities.com/church_of_rockall/index.html
21:31:01 <bos> oops, wrong window.
21:31:02 <lambdabot> Title: The Most Holy Church of Rockall
21:31:04 <fantasma> dcoutts: where do you specify username and password for ssmtp to send with?
21:32:21 <jcreigh> but $DISPLAY works (according to bos), just not a -display cmd line argument.
21:32:58 <dons> since we don't recognise -display
21:33:03 <dons> sounds like a 2 line patch
21:33:20 <scsibug> fantasma: ssmtp.conf in /etc should be where that goes
21:33:24 <lispy> do you use getopts?
21:33:29 <lispy> or manual parsing of the commandline?
21:33:38 <jcreigh> no parsing of the command line, currently.
21:33:41 <dmwit> But then an entire half-percent of the codebase would be devoted to handling the command line! =P
21:36:28 <sorear> dons, sjanssen: I've registered #xmonad, pw will be freely given to either of you on request - do NOT take this as pressure to move soon
21:37:19 <ivanm> sorear: does that mean you're pressuring them but don't want to sound like you're pressuring them? :p
21:37:39 <dcoutts> fantasma: /etc/ssmt/ssmtp.conf I think
21:37:57 <fantasma> dcoutts: right, but what do I use to specify my password?
21:38:03 <sorear> ivanm: no, it seems as if I'm the only person on earth who likes reading documentation
21:38:15 <scsibug> fantasma:  AuthUser and AuthPass
21:38:16 <ivanm> as in for support queries?
21:38:16 <sorear> ivanm: so I did it, that way dons wouldn't have to /msg chanserv help
21:38:28 <fantasma> scsibug: thanks
21:38:34 <dcoutts> fantasma: dunno, check the sample .conf file or check the ssmtp man page
21:38:41 <scsibug> fantasma: you should have a man page for the conf file
21:38:46 <ivanm> sorear: why is dons /msg'ing chanserv?
21:39:01 <sorear> ivanm: because that's how you register channels?
21:39:13 <ivanm> *nod* duh
21:39:14 <scsibug> if User/Pass doesn't work, you may have to specify a specific AuthMethod
21:39:48 <ivanm> sorear: so xmonad is going to split off into its own channel, leaving us to contemplate solely upon higher-order theoretical discussioins? :p
21:40:20 <sorear> ivanm: no, this is just a sinister plot to slow down your autojoiner
21:40:41 <ivanm> heh... hang on, why would it slow down?
21:40:48 <ivanm> because I have to join more channels?
21:40:52 <sorear> ivanm: 2seconds per channel
21:40:58 <ivanm> *nod*
21:41:02 <sorear> dontchya love flood control?
21:41:06 <ivanm> heh
21:42:43 <narain> ?quote
21:42:44 <lambdabot> jjuggle says: I was riding around town and this cop on patrol on a bike rode up next to me and said, "There's always a show off." I offered to teach him to ride and help set up a unicycle patrol
21:42:44 <lambdabot> squad, but he declined.
21:46:34 <AStorm> Hello. Any news and progress on Haskell Prime?
21:47:09 <sorear> It's due to come out in November
21:47:12 <sorear> ... 06
21:47:24 <ivanm> lol
21:47:27 <bos> @yhjulwwiefzojcbxybbruweejw
21:47:28 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
21:47:30 <ivanm> time warp?
21:48:00 <dmwit> ?yhj
21:48:01 <lambdabot> "\"#$%&'()*+,\""
21:48:30 <bd_> what's ?yhj
21:48:37 <jcreigh> When Haskell' is finished, it's going to slingshot around to sun, come back in time, and save the whales.
21:48:37 <ivanm> random garbage, AFAIK
21:48:41 <ivanm> @help yhj
21:48:41 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:48:47 <dmwit> It's short for ?yhjulwwiefzojcbxybbruweejw.
21:48:57 <ivanm> @help yhjulwwiefzojcbxybbruweejw
21:48:58 <lambdabot> V RETURNS!
21:49:03 <ivanm> @help v
21:49:04 <lambdabot> let v = show v in v
21:49:09 <ivanm> heh
21:49:11 <AStorm> :P
21:49:14 <AStorm> ?v whatever
21:49:15 <lambdabot> Just 'J'
21:49:22 <bd_> ah, but they do different things, don't they?
21:49:26 <bd_> ?yhj
21:49:26 <lambdabot> Exception: <<loop>>
21:49:30 <dmwit> ?v
21:49:30 <bd_> heh
21:49:31 <lambdabot> "\""
21:49:32 <dmwit> ?v
21:49:33 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
21:49:34 <dmwit> ?v
21:49:35 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
21:49:37 <dmwit> ?yhj
21:49:37 <ivanm> random quotations or something
21:49:37 <lambdabot> "\""
21:49:40 <dmwit> ?yhj
21:49:41 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
21:49:47 <dmwit> They're the same, I think.
21:50:13 <AStorm> It's either garbage, or some unary encoding
21:50:27 <bd_> ?v
21:50:28 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
21:50:44 <ivanm> dons: whats the story behind V and yhjulwwiefzojcbxybbruweejw again?
21:50:51 <ivanm> @yhjulwwiefzojcbxybbruweejw
21:50:51 <lambdabot> Exception: <<loop>>
21:50:54 <_dolio> > fix show
21:50:56 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
21:51:52 <AStorm> ?dance
21:51:52 <lambdabot> unexpected end of input: expecting number
21:52:00 <AStorm> ?
21:52:01 <dmwit> ?dance 3
21:52:02 <lambdabot> 3 => 3
21:52:07 <narain> ?dance 42
21:52:08 <lambdabot> 42 => 42
21:52:10 <ivanm> ?dance 42
21:52:10 <lambdabot> 42 => 42
21:52:15 <dmwit> Fascinating.
21:52:19 <ivanm> @help dance
21:52:19 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:52:21 <dolio> ?beer dmwit
21:52:22 <lambdabot> dmwit is in #haskell-blah and #haskell. I last heard dmwit speak 6s ago.
21:52:28 <ivanm> beer == quote?
21:52:33 <dmwit> beer == seen
21:52:34 <ivanm> s/quote/seen
21:52:41 <narain> ivanm: spell-check
21:52:45 <dmwit> ?dice 42
21:52:45 <lambdabot> 42 => 42
21:52:48 <dmwit> Aha.
21:52:59 <AStorm> It's pattern-matched
21:52:59 <narain> ohhh
21:53:02 <ivanm> narain: oh, minimum editing distance?
21:53:04 <AStorm> ?dunce 42
21:53:04 <lambdabot> 42 => 42
21:53:05 <jcreigh> ?dice 3d6
21:53:06 <lambdabot> 3d6 => 7
21:53:13 <jcreigh> ivanm: yeah, edit distance
21:53:16 <dmwit> ?dance 3d6
21:53:17 <lambdabot> 3d6 => 8
21:53:43 <AStorm> ?drop 3d3
21:53:43 <lambdabot> Unknown command, try @list
21:54:04 <AStorm> Ahha, now I know, what's the edit distance limit :>
21:54:08 <dmwit> ?drip 3d3
21:54:09 <lambdabot> Unknown command, try @list
21:54:24 <sorear> AStorm: it's in the source code :)
21:54:25 <narain> ?pick 1d2
21:54:26 <lambdabot> Maybe you meant: dice dict
21:54:32 <AStorm> sorear: blah
21:54:38 <narain> ?face 1d2
21:54:38 <lambdabot> I know nothing about 1d2
21:54:44 <narain> ?
21:54:46 <ivanm> sorear: would it just be the closest actual command to what was entered?
21:54:50 <dmwit> ?rice 42
21:54:50 <lambdabot> 42 => 42
21:54:53 <sorear> ivanm: yes
21:54:56 <ivanm> ala error-correcting for coding theory?
21:55:00 <dmwit> ?price 3d6
21:55:01 <lambdabot> 3d6 => 12
21:55:08 <sorear> ivanm: yes, but Levenschtein not Hamming
21:55:11 <narain> why didn't ?face work
21:55:13 <narain> ?
21:55:16 <ivanm> sorear: *nod*
21:55:25 <AStorm> narain: because it's already taken
21:55:28 * ivanm is only learning hamming distance for coding theory subject
21:55:29 <AStorm> @help face
21:55:30 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:55:34 <dmwit> ?help where
21:55:35 <lambdabot> where <key>. Return element associated with key
21:55:42 <dmwit> ?list
21:55:42 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
21:55:54 <ivanm> lambdabot needs to do correction for help command as well :(
21:55:57 <narain> ?fact
21:55:58 <lambdabot> I can not handle empty facts.
21:56:01 <narain> ?help fact
21:56:01 <lambdabot> fact <fact>, Retrieve a fact from the database
21:56:05 <narain> ah.
21:56:06 <dmwit> ?fact faq
21:56:06 <lambdabot> I know nothing about faq
21:56:17 <AStorm> ?fact lambdabot
21:56:17 <lambdabot> lambdabot: Lambdabot is a bot of curious opinions, and is female.
21:56:20 <AStorm> :>
21:56:28 <narain> ivanm: i second that
21:56:34 <dmwit> ?figlet spell
21:56:35 <lambdabot> Couldn't run the figlet command.
21:56:46 <ivanm> @help fact
21:56:47 <lambdabot> fact <fact>, Retrieve a fact from the database
21:56:50 <ivanm> @fact dons
21:56:51 <lambdabot> I know nothing about dons
21:56:52 <ivanm> heh
21:57:02 <dmwit> ?fact Haskell
21:57:03 <lambdabot> haskell: Haskell is the language of choice for discriminating hackers.
21:57:10 <sproingie> @fact nothing
21:57:11 <lambdabot> I know nothing about nothing
21:57:14 <dmwit> ?fact lambda
21:57:14 <lambdabot> I know nothing about lambda
21:57:16 <AStorm> discriminating... whom? :>
21:57:18 <rahikkala> ?fact C
21:57:19 <lambdabot> I know nothing about c
21:57:20 <dmwit> ?fact love
21:57:20 <lambdabot> I know nothing about love
21:57:29 <sorear> stop random walking and read the database!
21:57:35 <bos> ?fact+ lambda lambda is the ultimate imperative!
21:57:35 <lambdabot> I know nothing about lambda
21:57:37 <AStorm> dmwit: go have a priv talk with the bot :P
21:57:37 <sproingie> lambdabot is sgt shultz
21:57:37 <ivanm> @where database
21:57:38 <lambdabot> I know nothing about database.
21:57:42 <dmwit> But... I thought we would be together forever!
21:57:43 <ivanm> heh
21:57:50 <ivanm> sproingie: lol!
21:57:56 <sorear> http://www.cse.unsw.edu.au/~dons/lambdabot/State/fact
21:58:05 <sieni> ?fact anything
21:58:05 <lambdabot> I know nothing about anything
21:58:08 <AStorm> ?fact facts
21:58:08 <lambdabot> I know nothing about facts
21:58:10 <ivanm> sorear: I can't read it
21:58:15 <ivanm> its binary encoded in some way
21:58:19 <sorear> @part #haskell
21:58:23 <sorear> gzip
21:58:28 <ivanm> *nod*
21:58:35 <AStorm> Mhm.
21:58:56 <AStorm> Even has the header :P
21:59:41 <ivanm> @fact chessguy
22:00:18 <narain> sorear: why did you send lambdabot away?
22:00:29 <ivanm> :(
22:00:34 <sorear> only flood control mechanism we have :(
22:00:39 <ivanm> heh
22:00:48 <narain> aww
22:00:53 <monochrom> hahaha
22:00:55 <narain> no fair
22:01:02 <AStorm> sorear: add a "lock" command
22:01:07 <shoffsta> *** lambdabot has joined chat #xmonad.
22:01:10 <ivanm> when did dons take lambdabot over from Pseudonym?
22:01:22 <sorear> ivanm: never
22:01:36 <ivanm> sorear: that's what it says in the fact database under pseudonym...
22:01:41 <ivanm> or is that a joke?
22:01:45 <sorear> Pseudonym was the first of a dozen maintainers, dons was the last.
22:01:51 <ivanm> *nod*
22:01:59 <ivanm> so who initially developed LB?
22:02:28 <sorear> Pseudonym
22:02:31 <narain> ?botsnack
22:02:32 <lambdabot> :)
22:02:45 * monochrom floods lambdabot with questions
22:02:47 <sorear> from AUTHORS:
22:02:48 <ivanm> @fact hsu
22:02:49 <lambdabot> hsu: I know nothing about Haskell Secret Underground.
22:02:49 <sorear> Andrew J. Bromage <ajb@spamcop.net> aka Pseudonym on #haskell
22:02:49 <sorear>     * the 'bot itself
22:02:49 <sorear>     * @free
22:03:01 <ivanm> *nod*
22:03:07 <narain> ?help free
22:03:07 <lambdabot> free <ident>. Generate theorems for free
22:03:14 <monochrom> hahahaha that hsu one is cool
22:03:20 <ivanm> @botsnack
22:03:21 <lambdabot> :)
22:03:55 <AStorm> Haskell world domination or bust
22:04:09 <narain> ?fact world domination
22:04:10 <lambdabot> I know nothing about world
22:04:35 <AStorm> Sure, she talks on IRC all the time
22:04:52 <ivanm> @fact recursion
22:04:52 <lambdabot> recursion: recursion
22:04:58 <ivanm> heh
22:05:02 <narain> has anyone that it would be nice if lambdabot prefixed responses with the nick of the person who asked?
22:05:20 <narain> e.g. when lots of people are sending commands and the responses get interleaved
22:05:27 <ivanm> maybe... what happens if you're doing it for someone else?
22:05:38 <AStorm> add a ?to command?
22:05:49 <AStorm> ?to someone <some other command>
22:05:49 <lambdabot> Maybe you meant: todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell . bf ft id pl rc v wn yow
22:06:18 <ivanm> AStorm: so @to foo @pl <blah> ?
22:06:24 <AStorm> Mhm
22:06:32 <ivanm> will ping foo with the pl'd form?
22:06:40 <ivanm> don't think LB can read interior commands...
22:06:44 <AStorm> I hope so :-)
22:06:53 <AStorm> Why not? It's in Haskell, it should.
22:06:57 <ivanm> unless they define @to that way...
22:07:00 <ivanm> suppose so...
22:07:09 <AStorm> The commands are just functions
22:07:10 <sorear> @. show show "foo"
22:07:10 <lambdabot> "\"\\\"foo\\\"\"\n"
22:07:15 <ivanm> Haskell can do _everything___!!!
22:07:17 <narain> mbot, the math bot in #math behaves like that -- so you know what the response is apropos to
22:07:28 <narain> ?faq
22:07:28 <sorear> narain: mbot is lambdabot!
22:07:29 <lambdabot> The answer is: Yes! Haskell can do that.
22:07:38 <narain> sorear: ??
22:07:45 <ivanm> sorear: you for real?
22:07:49 <sorear> narain: or rather, a fork of it, maintained by Cale.
22:07:54 <ivanm> *nod*
22:08:14 * narain had no idea
22:08:39 <sorear> do /who *Robots* ... there are like six lambdabots running on freenode!
22:08:54 <monochrom> Scary
22:09:33 <AStorm> transformers? :P
22:10:12 <merus> ROBOTS IN DISGUISE
22:10:22 <araujo> heelloo
22:10:23 * sorear /kick merus
22:10:32 <gregor> is this a good place for a new Haskell programmer to get a critique of his first Haskell program?
22:10:33 <merus> :(
22:10:40 <narain> so... a lambdabot fork already does the nick-prefixing thing. may i ask why lambdabot doesn't? #haskell people don't think it necessary?
22:10:42 <sorear> gregor: absolutely (yes)
22:10:44 <araujo> gregor, for sure
22:10:47 <dons> gregor: certainly! :-)
22:10:47 <gregor> k
22:10:49 <dons> welcome!
22:10:52 <gregor> thanks
22:11:00 <AStorm> gregor: unless you don't want to hear criticisms, yes :>
22:11:00 <gregor> my first try at something that wasn't an exercise in a book
22:11:02 <sorear> this is after all #haskell!
22:11:07 <sorear> yay!
22:11:39 <AStorm> BTW, could you recommend some dead-tree Haskell book?
22:11:58 <gregor> problem statement: implement nth_powers :: Int -> [Int] to produce an infinite list of the nth powers of 1, 2, 3, ...
22:12:07 <sorear> gregor: if the code is fairly short (< 200 lines or so), go to hpaste.org/new
22:12:23 <gregor> it is six lines
22:12:29 <AStorm> Should be like 1 or 2 lines :>
22:12:30 <araujo> AStorm, Introduction to Functional Programing from Bird
22:12:32 <ivanm> AStorm: the craft of functional programming
22:12:39 <AStorm> Hmm hmm :>
22:12:46 <sorear> gregor: so nth_powers 2 = [1,4,9,16,25,36,..] ?
22:12:47 <gregor> should i paste in directly, or something else?
22:12:48 <AStorm> Let's see if the library has it
22:12:50 <gregor> yep
22:12:51 <ivanm> or the new one "programming in haskell" by graham somethingorother
22:12:53 <AStorm> if not, I'll suggest it to them
22:12:55 <sorear> gregor: hpaste.org
22:12:57 <gregor> k
22:12:58 <narain> ?hpaste -- gregor
22:12:59 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:13:03 <dcoutts> AStorm: 'Programming in Haskell'
22:13:08 <dcoutts> new book
22:13:11 <ivanm> AStorm: or haskell school of expression
22:13:17 <ivanm> dcoutts: who's the author of that one again?
22:13:25 <sorear> hudak iirc
22:13:27 <sorear> paul
22:13:31 <hpaste>  gregor pasted "nth_powers" at http://hpaste.org/1561
22:13:32 <monochrom> "Algebra of Programming"   (tee hee hee ...)
22:13:33 <AStorm> They don't havt anything with Haskell keyword, so... :P
22:13:36 <dcoutts> @google Graham Hutton Programming in Haskell
22:13:41 <lambdabot> http://www.cs.nott.ac.uk/~gmh/book.html
22:13:41 <lambdabot> Title: Programming in Haskell
22:13:42 <gregor> http://hpaste.org/1561
22:13:47 <dcoutts> ivanm: ^^
22:14:12 <ivanm> dcoutts: that's the one, couldn't remember his surname
22:14:18 <gregor> i looked a bit for Prelude functions to use in place of some of what i did, figuring they must be there, but i couldn't see how to rewrite that to use a fold
22:14:19 <sorear> gregor: nth_powers k = map (^k) [1..]   btw
22:14:21 <lispy> "Programming in Haskell" by Graham Paul? ;)
22:14:24 <gregor> well
22:14:25 <gregor> :)
22:14:29 <dcoutts> AStorm: my review of that book will appear in the next TMR, in the next couple of days
22:14:34 * ivanm had traumatic experiences with someone called hutton
22:14:34 <gregor> I was trying to use a particular technique I saw somewhere
22:14:53 <AStorm> a running sum, you say? That will be slower :>
22:15:18 <sorear> gregor: runningsum is a scanl
22:15:23 <Gwern> hmm. I think I'll install darcs-ghc in gentoo. should be interesting at least
22:15:23 <gregor> sum of odd integers -> squares
22:15:31 <gregor> scanl... looking
22:15:58 <sorear> but, map (^2) is much clearer :)
22:16:04 <sorear> > map (^3) [1..]
22:16:04 <narain> gregor: how will that help with computing arbitrary powers?
22:16:06 <lambdabot>  [1,8,27,64,125,216,343,512,729,1000,1331,1728,2197,2744,3375,4096,4913,5832,...
22:16:17 <narain> :t scanl -- gregor
22:16:19 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
22:16:27 <narain> hmm, that may not help too much
22:16:37 <ivanm> narain: you really want AStorm's @to function, don't you? :p
22:16:54 <narain> ivanm: haha, didn't think of that
22:17:01 <gregor> narain -- the idea is to generalize
22:17:17 <gregor> run take 20 (nth_powers 4)
22:17:35 <AStorm> sorear: that will only work for things having (^) operator defined :>
22:17:41 <AStorm> Do something on sums :P
22:17:47 <ivanm> gregor: what are you trying to do?
22:17:48 <gregor> dropping every nth element and then doing a running sum, and then repeating for n-1 .... until n == 1 gives the nth powers
22:17:54 <sorear> AStorm: Everything has (^) operator defined.
22:18:00 <sorear> :t (^2)
22:18:02 <AStorm> Everything of Num?
22:18:02 <lambdabot> forall a. (Num a) => a -> a
22:18:05 <ivanm> > 'a'^'d'
22:18:06 <lambdabot>   add an instance declaration for (Integral Char)
22:18:06 <lambdabot>     In the expression: 'a' ...
22:18:06 <sorear> :t (+)
22:18:09 <lambdabot> forall a. (Num a) => a -> a -> a
22:18:12 <gregor> algorithm i saw in Multidimensional Programming by Ashcroft, Wadler et al.
22:18:14 <narain> gregor: ah. interesting approach
22:18:42 <AStorm> So many good books I don't have access to... drat!
22:18:45 <gregor> wanted to see if i could figure out how to implement in haskell. seems to work, but i suspect my implementation looks like baby-talk
22:19:00 <sorear> gregor: btw, your nth_powers will give bogus results at large values, since it uses Int
22:19:01 <AStorm> gregor: not too much
22:19:05 <narain> > let runningsum = scanl (+) 0 in runningsum [1,2,0,1,3,2]
22:19:07 <lambdabot>  [0,1,3,3,4,7,9]
22:19:13 <sorear> > 20^20
22:19:14 <gregor> sorear: yeah. I need arbitrary precision ints
22:19:15 <lambdabot>  104857600000000000000000000
22:19:18 <sorear> > 20^20 :: Int
22:19:19 <lambdabot>  0
22:19:24 <AStorm> gregor: use Integer type
22:19:34 <sorear> gregor: just don't specify a type - Integer will be defaulted
22:19:39 <gregor> ah
22:19:40 <gregor> k
22:19:50 <AStorm> Int is shorter Integer :P
22:19:50 <gregor> let me try that plus scanl
22:20:08 <sorear> well, adding types can help with debugging, so don't religiously avoid them.
22:20:24 <narain> gregor: though it generally *is* good style to declare types of top-level functions, so you may just want to replace Int with Integer
22:20:32 <AStorm> Plareplane: thanks, but then, I wanted a dead tree version to recommend for friends :P
22:20:39 <narain> yes, they help with debugging a lot
22:20:52 <AStorm> and it's not in the library and they won't buy it
22:20:54 <AStorm> Blah.
22:21:16 <Plareplane> AStorm: 8]
22:22:02 <narain> gregor: to be honest, now that i know your approach, your code actually looks quite neat
22:22:28 <narain> though i think you don't need nested wheres
22:22:35 <sorear> gregor: I suggest map (^n) and -prof.
22:23:28 <gregor> narain: tx
22:24:06 <AStorm> There's some Henderson's book, and Simon's one :|
22:24:29 <AStorm> I mean Peyton's one
22:24:29 <sorear> @botsnack
22:24:29 <lambdabot> :)
22:24:46 <sorear> AStorm: Peyton isn't anybody's name
22:24:50 <gregor> BTW, is the dead tree version of the Haskell Report a good buy, after already reading Graham Huttons, book, plus Haskell School of Expression, plus Haskell: Craft of functional programming?
22:25:09 <sorear> AStorm: Peyton-Jones is a single atomic token
22:25:15 <AStorm> sorear: Simon Peyton Jones :P
22:25:18 <AStorm> Ok :P
22:25:23 <sorear> Simon L. Peyton-Jones
22:25:29 <AStorm> Ok, better
22:25:33 <AStorm> that M$ researcher, anyway
22:26:27 <AStorm> Stupid parser broke his name :P
22:26:46 <gregor> hrm
22:26:56 <gregor> If I say nth_powers :: Integer -> [Integer]
22:27:02 <gregor> then it doesn't like me using [1..]
22:27:15 <AStorm> Because it's backwards then
22:27:23 <AStorm> It expects a number
22:27:34 <AStorm> nth_powers 5
22:27:35 <AStorm> :>
22:27:46 <gregor> er
22:28:19 <gregor> "nth_powers n = aux n [1..] where ..." isn't legal after saying "nth_powers :: Integer -> [Integer]"
22:28:37 <sorear> gregor: what's aux?
22:28:51 <sorear> gregor: oh!  you've run into a problem with list indexing
22:28:59 <sorear> @type take
22:29:00 <AStorm> sorear: do you know some Reade's book? What's in it?
22:29:02 <lambdabot> forall a. Int -> [a] -> [a]
22:29:06 <gregor> sorear: http://hpaste.org/1561
22:29:07 <sorear> @type genericTake
22:29:09 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
22:29:16 <sorear> AStorm: who is Reade?
22:29:26 <AStorm> Some Chris Reade :P
22:29:32 <sorear> I have never read a dead-tree book on FP.
22:29:32 <AStorm> I don't know the book, except it's 1989
22:29:47 <sorear> Or any deadtree CS book newer than ~1970
22:30:03 <AStorm> some "Elements of functional programming"
22:30:12 <narain> gregor: rule of thumb, any time you find yourself manually recursing down a list, check if you can use one of the built-in functions: map, foldr, scanl, unfoldr, iterate
22:30:33 <AStorm> Blah, it teaches Standard ML
22:30:34 <narain> why do list indexing functions take Int? is it for speed?
22:30:39 <gregor> narain: k. I'm having trouble so far adopting scanl. don't know yet what I'm doing wrong.
22:31:34 <narain> what are you trying to do with scanl?
22:31:48 <dons> narain: to add a bit of type constrainting
22:32:01 <dons> so ultimately, yeah, for speed
22:32:41 <AStorm> Heh, and the Henderson's book is about LISP :P
22:33:18 <AStorm> So, no Haskell on one of the best TUs in Poland. Have to fix that.
22:33:29 <sorear> gregor: in practice you should just use 'nth_powers n = map (^n) [1..]' and let the profiler worry about how fast it is.
22:33:58 <narain> dons: is it a better tradeoff than making the more flexible functions default and calling the Int-only one specificTake for people who need it?
22:34:13 <sorear> gregor: we can make exceptions in autodidactic circumstances, however
22:35:17 <AStorm> Unless someone needs nth_powers n 6 !! 1024
22:35:20 <AStorm> or something :P
22:35:24 <gregor> sorear: i understand. i felt this would be a good approach to make me work out some list processing one level deeper than that solution, and had infinite lists
22:35:26 <AStorm> s/n//
22:35:44 <sorear> see above on autodidactic circumstances, then ;)
22:36:32 <AStorm> Hm, would Int use 64-bit data type on 64-bit architectures?
22:36:40 <gregor> hrm. The way I put scanl in there is not equivalent to my previous implementation of runningsum.
22:36:52 <AStorm> or is it sharply defined?
22:36:53 * sorear is going down for overnight halt in 60 seconds
22:37:01 <gregor> I'll go look more deeply at scanl
22:37:03 <narain> AStorm: right, one probably doesn't need arbitrarily large Integers for indexing lists :) but people run into type errors then trying to index lists with Integers
22:37:05 <sorear> AStorm: anything 30-bits or higher
22:37:12 * AStorm is going down for morning PE in 5 minutes
22:37:29 <AStorm> :P
22:37:31 <sorear> that's 3*0*, not 3*2*
22:37:37 * narain should have gone down for overnight halt 60 minutes ago
22:37:52 <dmwit> > (20::Int)^20
22:37:54 <lambdabot>  0
22:38:10 <dmwit> :t (^)
22:38:13 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
22:38:26 <dmwit> > (20::Int)^(20::Int)
22:38:28 <lambdabot>  0
22:38:39 <narain> wow, it's like sorear has an auto-shutdown cron job or something
22:38:44 <bos> sweet. cabal-rpm can now handle every hackage package i've thrown at it.
22:38:55 <bos> even broken stuff like X11-extras and Crypto :-)
22:39:25 <dons> X11-extras is broken?
22:39:41 <dons> got today's release? maybe its unborked
22:39:46 <bos> it has a few little packaging problems, such as no configure script in the tarball.
22:39:57 <dons> yeah, that's fixed now.
22:39:57 <narain> gregor: scanl transforms a list into a new list threading a value through it, such as my runningsum above
22:40:02 <dons> grab X11-extras-0.1 from hackage
22:40:13 <bos> ok, i grabbed it earlier today, but that was in the stale ancient age of 0.0 :-)
22:40:26 <dons> yeah :-) we move fast in open source haskell land
22:40:32 <sjanssen> bos: get with the times
22:40:46 <sjanssen> 0.0 is our allotted "oops" release
22:40:57 <bos> i'll have to whack cabal-install a bit so i can use it as a library inside cabal-rpm, downloading automatically for me
22:41:55 <dolio> > let dropAt n l = let (h, e:t) = splitAt (n - 1) l in h ++ dropAt n t; nth 1 = id; nth n = nth (n - 1) . scanl1 (+) . dropAt n in nth 3 [1..]
22:41:56 <lambdabot>  [1,8,27,64,125,216,343,512,729,1000,1331,1728,2197,2744,3375,4096,4913,5832,...
22:43:39 <merus> > let del xs = zipWith (-) (tail xs) xs; cube = map (^3) [1..] in take 20 $ del $ del $ del cube
22:43:41 <lambdabot>  [6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6]
22:44:33 <AStorm> BTW, does wxHaskell work now with ghc 6.6 and newest wxWidgets? (like 2.6.3.3)
22:46:00 <gregor> > let runningsum a [] = [a]; runningsum a (x:xs) = a + x : runningsum (a + x) xs in runningsum 0 [1, 3, 5, 7, 9]
22:46:02 <lambdabot>  [1,4,9,16,25,25]
22:46:08 <gregor> > scanl (+) 0 [1, 3, 5, 7, 9]
22:46:10 <lambdabot>  [0,1,4,9,16,25]
22:46:20 <AStorm> so start from 1
22:46:37 <gregor> I tried doing a drop 1 on that scanl but still didn't get it right
22:46:38 <dmwit> > scanl1 (+) [1,3,5,7,9]
22:46:39 <lambdabot>  [1,4,9,16,25]
22:47:23 <AStorm> ?where scanl1
22:47:23 <lambdabot> I know nothing about scanl1.
22:47:26 <narain> gregor: scanl1 is probably a better choice, also  drop 1 == tail
22:47:34 <narain> ?src drop
22:47:34 <lambdabot> drop n xs     | n <= 0 =  xs
22:47:35 <lambdabot> drop _ []              =  []
22:47:35 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
22:47:37 <dmwit> > drop 1 []
22:47:38 <lambdabot>  []
22:47:42 <AStorm> ?src scanl1
22:47:43 <lambdabot> scanl1 f (x:xs) =  scanl f x xs
22:47:43 <lambdabot> scanl1 _ []     =  []
22:47:44 <narain> well, almost ==.
22:50:03 <AStorm> ?src scanl
22:50:03 <lambdabot> scanl f q ls = q : case ls of
22:50:04 <lambdabot>     []   -> []
22:50:04 <lambdabot>     x:xs -> scanl f (f q x) xs
22:50:25 <AStorm> recursive definition :>
22:53:13 <gregor> hm
22:57:43 <merus> If I overflow the value of an Int in Haskell, does it wrap around to a negative number?
22:58:18 <dmwit> > maxBound + 1 :: Int
22:58:20 <lambdabot>  -2147483648
22:58:31 <Lor> Whatever it does, you can't rely on the exact behavior since the size of Int may vary across implementations.
22:59:01 <merus> I was wondering why forward differences of always increasing sequences were coming back negative.
23:01:30 <hpaste>  gregor pasted "(no title)" at http://hpaste.org/1562
23:02:03 <gregor> the two versions I think should be equivalent but aren't are here: http://hpaste.org/1562
23:02:26 <scsibug> dons: fyi, just sent you a small bugfix patch for mkcabal
23:02:50 <scsibug> my email has been flaky lately, so if you don't get it, let me know
23:04:12 <dolio> gregor: What goes wrong with the second?
23:10:20 <gregor> dolio: "take 20 (nth_powers2 2)" ----> [2,6,12,20,30,42,56,72,90,110,132,156,182,210,240,272,306,342,380,420] when it should ----> [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400]
23:10:57 <gregor> I may need to just look at it again tomorrow. I'm probably more tired than I should be to be trying out a new programming language.
23:11:07 <gregor> ah, hubris
23:11:13 <dolio> Hmm...
23:11:57 <gregor> scanl1 seems like the right thing to be doing, and when I do simple one-off tests it behaves the way i want
23:12:15 <gregor> it has to be something simple i'm not seeing in my code the way I'm applying it in context
23:12:25 <dmwit> gregor: You're pattern matching is different.
23:12:35 <dmwit> In aux, you match (x:xs) in one and (xs) in the other.
23:12:36 <dolio> Oh yeah.
23:13:17 <gregor> d'oh!
23:13:20 <gregor> i couldn't see it
23:13:23 <gregor> copy-paste-edit error!
23:13:34 <gregor> thanks!
23:13:47 <gregor> fixing that fixes the problem
23:14:29 <dmwit> Tomorrow: obfuscating aux using foldl!
23:14:31 <dmwit> ;-)
23:14:35 <gregor> so with that fixed, is there anything remaining about my style that is un-Haskell like?
23:15:21 <dmwit> Explicit recursion is usually avoided, but I think in this case it makes "aux" more readable.
23:15:29 <gregor> dmwik: 'k
23:15:32 <dolio> :) Did you see my version above?
23:15:40 <gregor> i still have a hard time reading Haskell, even my own!
23:15:50 <gregor> except very simple stuff
23:16:08 <gregor> i need to write more code in it so it seems more natural
23:16:26 <gregor> dolio: i saw it, but I'm not worthy!
23:16:29 <gregor> :/
23:16:32 <gregor> er
23:16:33 <gregor> :)
23:16:36 <dolio> Hehehe.
23:16:39 <dmwit> dolio: Where's yours?
23:16:51 <gregor> dolio, you're freakin' me out, man!
23:16:55 <dolio> I wouldn't sweat it. It's the result of my hanging out here reading the output of @pl too much.
23:17:03 <sjanssen> dmwit: and the day after: obfuscating by writing every foldl as a foldr!
23:17:11 <dmwit> =)
23:17:37 <dolio> > let dropAt n l = let (h, e:t) = splitAt (n - 1) l in h ++ dropAt n t; nth 1 = id; nth n = nth (n - 1) . scanl1 (+) . dropAt n in nth 4 [1..]
23:17:39 <lambdabot>  [1,16,81,256,625,1296,2401,4096,6561,10000,14641,20736,28561,38416,50625,655...
23:18:21 <dmwit> hum
23:18:33 <gregor> so, next question i have is: how badly does my version perform vs nth_powers k = map (^k) [1..]
23:19:09 <gregor> someone mentioned profiling
23:19:47 <gregor> hey
23:19:49 <dmwit> dolio: Oh, okay, you just renamed some things and collapsed aux a little.  Got it.  Nice!
23:19:53 <gregor> I just found a typo in GHCi
23:19:56 <gregor> "  :set editor <cmd>           set the comand used for :edit
23:19:57 <gregor> "
23:20:03 <gregor> s/the comand/the command/
23:21:28 <gregor> ... wishing for :profile take 100 (nth_powers 9)
23:21:31 <gregor> in GHCi
23:21:46 <dmwit> I think you actually have to build it with ghc.
23:21:58 <dmwit> There's like a -prof flag or so?
23:22:04 <gregor> what do you folks use for ide?
23:22:09 <gregor> I have the Eclipse plugin
23:22:19 <gregor> I've gotten used to IDEness for Java
23:22:25 <dmwit> vim and emacs are the two biggest ones here, I think.
23:22:28 <gregor> used to be a vim user mostly
23:22:31 <dolio> You have EclipseFP?
23:23:02 <gregor> FP: Haskell support for Eclipse 0.10.0
23:23:18 <gregor> its got some syntax highlighting
23:23:20 <ddarius> There was a poll years ago.  There weren't too many respondents (<100), but emacs closely followed by vim dominated the results.
23:23:25 <gregor> and I can run the GHCi session within the IDE
23:24:03 <gregor> there is some haskell-specific vim mode? I'm a pretty basic vim user.
23:24:17 <dolio> Nothing too special.
23:24:25 <dolio> It does some highlighting and indenting.
23:24:46 <ddarius> http://www.cs.kent.ac.uk/projects/refactor-fp/surveys/haskell-editors-July-2002-summary.txt
23:24:49 <lambdabot> http://tinyurl.com/yoxdgm
23:30:46 <m4St3R_b41T3R> hello
23:31:07 <dolio> @elite Hello.
23:31:07 <lambdabot> |-|El10.
23:31:38 <dmwit> Bait me!
23:32:06 <m4St3R_b41T3R> ^_^"
23:36:07 <dolio> So, someone on reddit has posted a story at least three times...
23:36:13 <dolio> Asking for GOTO to come back.
23:36:26 <m4St3R_b41T3R> good ol reddit
23:38:13 <Cale> Yeah, I noticed that -- mark it as spam.
23:38:50 <QtPlatypus> dolio: A joke?
23:39:00 <Cale> No, it's apparently serious.
23:39:22 <m4St3R_b41T3R> come back where?
23:39:27 <dmwit> Some kind of warped call/cc?
23:39:30 <dolio> To programming languages.
23:39:40 <sjanssen> @tell sorear you forgot to send your property related changes to X11-extras
23:39:40 <lambdabot> Consider it noted.
23:39:41 <m4St3R_b41T3R> it's still there!
23:39:48 <Cale> In old languages.
23:39:52 <dolio> Not the ones he uses, I guess.
23:40:09 <m4St3R_b41T3R> dolio well maybe he should use other languages, if he wants it so bad
23:40:32 <dolio> He probably won't like that answer.
23:41:33 <QtPlatypus> dolio: Which languages is he complaining lack gotos?
23:41:46 <sjanssen> @hoogle castCharToCChar
23:41:47 <lambdabot> Foreign.C.String.castCharToCChar :: Char -> CChar
23:42:02 <Cale> He doesn't even mention any specific languages
23:42:56 <dolio> Yeah. It's sort of a generalized rant, that thinking in terms of "objects" and stuff is too hard for novices/people who aren't software engineers.
23:43:14 <whaleofconfusion> he likes goto because it's "easier"?
23:43:30 <Cale> And he somehow thinks that GOTO is going to be easier to reason about for non-programmers.
23:43:55 <Cale> Which is just about the most ridiculous thing I've heard in a few hours.
23:44:44 <m4St3R_b41T3R> the internet is great
23:45:23 <Cale> If by "great" you mean "mostly full of idiots", then yeah, it's pretty great.
23:45:46 <m4St3R_b41T3R> it's very entertainting
23:46:21 <dolio> It may be easier to think about if you're writing "10 PRINT 'BOOGER' ; 20 GOTO 10", but when you get too far beyond that it gets bad.
23:47:49 <arcatan> I think goto is great for choose your own adventure style text adventure games
23:48:17 <Cale> arcatan: how is it any better than procedures for that?
23:48:28 <gregor> dolio, dmwit, narain, sorear, AStorm: Thanks for your help. I did run the profiler. My version was fun to write, but a very bad performer vs sorear's map and ^ answer. ^ does seem to work fine for larger #s, too. I wasn't sure what its specifics were.
23:49:08 <whaleofconfusion> no it's a joke, the "choose your own adventure" books always had like "if you choose to evade the dragon, go to page 12.  If you choose to right, go to page 38"
23:49:10 <gregor> I've ordered the Haskell Report from Amazon & I'll see how that goes
23:49:21 <whaleofconfusion> *fight
23:49:33 <gregor> gtg
23:49:43 <Cale> whaleofconfusion: Well, I've seen old basic programs which essentially implemented such games as spaghetti with gotos.
23:49:48 <dmwit> gregor: Cool, catch you later!
23:50:46 <arcatan> Cale: the obvious way of calling procedures inside procedures inside procedures inside.. is not so nice for memory
23:51:01 <whaleofconfusion> tail optimization
23:52:02 <QtPlatypus> Or you create a data structure what has pointers to each bit of the story and your code just navagates the datastructure.
23:52:27 <Cale> Yeah, I sort of take tail-call optimisation for granted these days.
23:52:46 <arcatan> these text adventures are made by 12 years old QBASIC programmers anyway
23:52:59 <Japsu> mmh, memories...
23:53:15 <johnnowak> QtPlatypus: yeah, that's just as easy to explain as GOTOs... :)
23:53:45 <Japsu> It's funny how much easier such text adventures are to make in Basic... Sometime GOTO just is your friend.
23:54:29 <Cale> If more procedural languages implemented tail-call optimisation, you could just expect people to use procedures in the obvious way.
23:54:44 <Japsu> heh, yeah
23:54:53 <Cale> and that would be easier to understand than gotos
23:55:16 <whaleofconfusion> it's not as if stack size is a problem in a text adventure game anyway
23:55:44 <Lor> Where is this goto article?
23:56:26 <dolio> http://www.amazon.com/gp/blog/post/PLNK2SCYDGXUSPN3V
23:56:28 <ddarius> "Pointers are the GOTOs of data structures"
23:56:28 <lambdabot> Title: Mark Guzdial's Amazon Blog
23:57:52 <johnnowak> Cale: it isn't even trivial to explain to a new programmer what tail-call optimization is, much less get them to make use of it
23:58:12 <ddarius> johnnowak: JUSt don't tell them otherwise.
23:58:19 <Korollary> tail-call optimization is an implementation detail anyway.
23:58:32 <johnnowak> ddarius: it's quite easy to write code that won't be optimized
23:58:33 <Cale> johnnowak: No, they don't have to even know that it's going on.
23:58:35 <ddarius> Korollary: No. IT isn't.
23:58:35 <whaleofconfusion> I like his phrase, "the rationalizations and theorems" as if the two things were related
23:59:01 <Korollary> How is it not? Just because R5RS says so?
23:59:57 <ddarius> Korollary: Roughly for the same reason mergesort v. bubblesort is not an implementation detail.
