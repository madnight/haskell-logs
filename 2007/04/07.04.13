00:08:39 <vincenz> augustss++
00:12:12 <plediii> grr, why is `(flip map)` a parse error?
00:12:24 <ivanm> @type flip map
00:12:27 <lambdabot> forall a b. [a] -> (a -> b) -> [b]
00:12:56 <int-e> plediii: because `...` needs an identifier in the middle
00:13:25 <plediii> I don't know what you mean by middle.
00:13:38 <int-e> between the first ` and the second `
00:13:53 <int-e> plediii: without that restriction, what would `x`x`x` mean?
00:15:27 <stepcut> hrm, I need an, instance MonadError Exception IO, but there is already a conflicting, instance MonadError IOError IO, in Control.Monad.Error. Is there a good work around ?
00:15:57 <dmwit> Project Euler problems aren't all that hard -- but there's a LOT of them!
00:15:58 <dmwit> =)
00:17:27 <plediii> Ok, so nothing more complex than a symbol can be infixed by `...`
00:17:37 <int-e> plediii: right
00:18:54 <larrythe1ow> hi
00:19:16 <larrythe1ow> I am going to learn haskell because ivanm said it was cool :D
00:19:22 <Korollary> dont believe him
00:19:45 <ivanm> lol... considering the amount of garbage I give him, its amazing he believes me on this ;-)
00:20:10 <Korollary> Maybe you're on to something
00:21:04 <int-e> dmwit: the problems are also somewhat repetetitive.
00:21:11 <Korollary> int-e: lol
00:21:36 <dmwit> int-e: And some are painful... converting numbers to words springs to mind.
00:22:48 <larrythe1ow> ivanm: you mean me? You never give me garbage. You told me about that portage for mac os x thing yesterday and stuff.
00:22:59 <larrythe1ow> and you discipline me with crowbar sattelites.
00:23:01 <larrythe1ow> :D
00:23:15 <larrythe1ow> anyway
00:23:20 <larrythe1ow> time to dive into haskell
00:23:30 <int-e> dmwit: or problem 54 (scoring poker hands)
00:23:37 <larrythe1ow> what good compiler do you use, ivanm or others who use gentoo?
00:23:52 <ivanm> larrythe1ow: go to #gentoo-haskell for that
00:23:57 <larrythe1ow> oh
00:24:08 <Stinger> ghc would be the standard no?
00:24:14 <ivanm> yeah...
00:25:37 <larrythe1ow> oh but ivanm you told me that gentoo-haskell was for ebuilds stuff
00:25:56 <ivanm> and for gentoo-specific questions
00:26:03 <ivanm> but in terms of what compiler/interpreter to use
00:26:08 <larrythe1ow> ..
00:26:12 <larrythe1ow> okay
00:26:14 <ivanm> ghc is the standard compiler which now comes with an interpreter
00:26:19 <larrythe1ow> oh okay
00:26:22 <ivanm> larrythe1ow: I mean in terms of what "gentooers" use
00:26:37 <ivanm> hugs is an interpreter, and theres some other compilers as well
00:26:45 <larrythe1ow> what... an interpreter.. but I thought haskell was compiled?
00:26:46 <larrythe1ow> :S
00:27:01 <larrythe1ow> damn I feel noob all over again like when I started gentoo
00:27:03 <olliej> larrythe1ow: hugs is an interpreter for haskell
00:27:16 <Stinger> you can run haskell programs through an interpretter
00:27:20 <olliej> larrythe1ow: ghc, yhc, nhc, etc are copmilers
00:27:31 <larrythe1ow> Stinger: wow
00:27:33 <Korollary> compiled to native code, interpreted, interpreted in JVM, what have you. Nowadays a lot of languages target all kinds of things.
00:28:22 <larrythe1ow> so what... you run simple programs with the interpretter and big through the compiler so that they execute faster or do you just use interpretted to test code so you don't have to keep compiling?
00:29:08 <hpaste>  stepcut pasted "`flip map`" at http://hpaste.org/1370
00:29:09 <ivanm> larrythe1ow: both
00:29:17 <larrythe1ow> oh okay
00:29:19 <larrythe1ow> sounds cool
00:29:28 <ivanm> lambdabot has an interpreter here so we can also run code on IRC
00:29:35 <ivanm> > map (+1) [1..10]
00:29:35 <larrythe1ow> wow
00:29:37 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
00:29:39 <Stinger> its sometimes useful (for me) to be able to load a program into the interpreter and run bits of it to see whats going wrong :P
00:29:42 <larrythe1ow> now that is cool
00:30:03 <larrythe1ow> emerging ghc
00:30:11 <larrythe1ow> now I need a cool free ebook on haskell
00:30:19 <ivanm> @where wikibook
00:30:20 <lambdabot> http://en.wikibooks.org/wiki/Haskell
00:30:20 <larrythe1ow> not a boring one like C books.
00:30:21 <Cheery> yet another haskell tutorial
00:30:32 <ivanm> @where YAHT
00:30:32 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
00:30:41 <larrythe1ow> is it fun like ruby and python books or boring like C ones?
00:30:45 <ivanm> Cheery: isn't YAHT being integrated into the wikibook?
00:30:54 <ivanm> larrythe1ow: it talks about nuclear waste... work it out ;-)
00:30:55 <Cheery> now when I use irssi, I really realised how useful that lambdabot is
00:31:15 <Cheery> ivanm: it seems a lot like so, maybe
00:31:44 <larrythe1ow> irssi ftw
00:31:50 <larrythe1ow> cool
00:32:07 <larrythe1ow> ghc takes a long time to compile :|
00:32:21 <larrythe1ow> wait.. has anyone written an OS in haskell?
00:32:25 <larrythe1ow> :P that'd be cool.
00:32:26 <ivanm> larrythe1ow: its a haskell compiler written in haskell
00:32:30 <ivanm> larrythe1ow: dons is working on it :p
00:32:31 <dmwit> ?where house
00:32:32 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
00:32:40 <ivanm> larrythe1ow: emerge ghc-bin instead... no need to compile
00:32:50 <larrythe1ow> oh you could have told me that
00:33:13 <larrythe1ow> awesome
00:33:18 <larrythe1ow> an OS in haskell
00:33:36 <larrythe1ow> so far it looks like haskell > python
00:33:45 <larrythe1ow> hopefully it is as beautiful as ruby though
00:34:47 <ivanm> larrythecow: I _did_ tell you about ghc-bin...
00:35:09 <ivanm> python got the concept of list comprehensions from haskell... IMHO, they butchured it
00:35:58 <Dazhbog> they've a good record for butchering useful things :P
00:36:12 <larrythecow> hm
00:36:38 <larrythecow> yes python is nice because it is portable and is easy so it made a good first language because everything worked
00:36:56 <larrythecow> but when I started reading code in other languages and learned a bit of ruby..
00:36:58 <Mitar> how can I convert between GLsizei and GLdouble type?
00:37:04 <larrythecow> I learned that python isn't actually that great.
00:37:26 <larrythecow> ghc is still compiling
00:37:27 <larrythecow> argh
00:37:37 <Dazhbog> larrythecow: did you use irb with ruby?
00:38:12 <larrythecow> yes
00:38:19 <larrythecow> irb and also freeride
00:38:21 <Dazhbog> ghc takes a loong time to compile :P
00:38:32 <larrythecow> how long? it has been 10 minutes
00:38:49 <larrythecow> because if it is going to be an hour then I'll cancel and do bin
00:38:51 <Dazhbog> depends on your machine
00:39:08 <int-e> Mitar: fromIntegral  should convert GLsizei to GLdouble.
00:39:09 <Korollary> @index Gldouble
00:39:10 <lambdabot> bzzt
00:39:20 <Korollary> argh
00:39:25 <Korollary> @index GLdouble
00:39:26 <lambdabot> Graphics.Rendering.OpenGL.GL.BasicTypes, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
00:39:27 <int-e> @type truncate
00:39:30 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
00:39:32 <Cale> larrythecow: usually something like a whole afternoon
00:39:39 <sjanssen> larrythecow: an hour is a decent estimate for many machines
00:39:45 <ivanm> larrythecow: it took ome > 4 hrs to compile ghc-6.6
00:39:47 <Cale> larrythecow: though dons can do it in 9 minutes on his 8 core machine
00:39:51 <int-e> Mitar: truncate / round / floor / ceiling  go into the other direction
00:39:55 <ivanm> but only 2 hrs to do 6.4
00:40:03 <ivanm> Cale: he can??? bastard!!!!
00:40:07 <Cale> larrythecow: basically, unless you have a *really* good reason, don't compile it.
00:40:22 <ivanm> why not? I did...
00:40:38 <Cale> You need to have a working GHC compiler to compile it anyway.
00:41:01 <Cale> So just get the binary unless none exists for your platform, or you want to hack on it.
00:41:08 <ivanm> *shrug*
00:41:19 <Mitar> (fromInteger 123 :: Graphics.UI.GLUT.GLsizei) :: Graphics.UI.GLUT.GLdouble
00:41:31 <Mitar> how do I run it?
00:41:35 <sjanssen> larrythecow: if you're building ghc right now, you already have ghc-bin installed
00:41:38 <Cale> Compiling things needlessly serves no purpose but to hasten the heat-death of the universe.
00:42:13 <int-e> Mitar: fromIntegral, not fromInteger. there's a difference :)
00:42:18 <int-e> @type fromInteger
00:42:20 <lambdabot> forall a. (Num a) => Integer -> a
00:42:22 <int-e> @type fromIntegral
00:42:24 <lambdabot> forall a b. (Num b, Integral a) => a -> b
00:42:40 <int-e> @src fromIntegral
00:42:40 <lambdabot> fromIntegral = fromInteger . toInteger
00:42:53 <Korollary> heh
00:42:53 <larrythecow> okay.. I am not venturing into the Beginners Track
00:43:08 <Korollary> Does anyone really use fromInteger?
00:43:21 <int-e> Korollary: yes. when defining Num instances :-P
00:43:31 <ivanm> Korollary: I do, when converting from Int to Double
00:43:50 <ivanm> Cale: or to show how uber-l33+ you are ;-)
00:43:56 <ivanm> @leet uber-leet
00:43:57 <lambdabot>  Parse error
00:44:03 <ivanm> @help leet
00:44:03 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:44:08 <ivanm> @help list
00:44:08 <lambdabot> list [module|command]
00:44:09 <lambdabot> show all commands or command for [module]. http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
00:44:11 <Cale> @elite uber-leet
00:44:11 <lambdabot> U8er-lE3t
00:44:18 <ivanm> oh, its elite, not leet
00:44:26 <int-e> @leet 1 -- ?
00:44:26 <lambdabot>  Parse error
00:44:50 <int-e> oh. let.
00:44:57 <ivanm> ahhh.....
00:45:02 <ivanm> that explains it
00:45:21 <larrythecow> wait a minute, I meant I AM venturing into the beginners traxk
00:45:22 <int-e> @leet leet = "l33t"
00:45:24 <larrythecow> track
00:45:25 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
00:46:58 <larrythecow> what is the command to start ghc?
00:47:08 <dmwit> ghci
00:47:16 <dmwit> or ghc if you want to compile something
00:47:17 <ivanm> for the interpreter
00:47:37 <larrythecow> ghc says command not found
00:47:45 <dmwit> rehash?
00:47:55 <ivanm> ummm.... did you compile it fully? or emerge ghc-bin?
00:48:34 <larrythecow> I half compiled then quit when you said it'd take forever and a half and emerged ghc-bin
00:48:50 <sjanssen> larrythecow: I think ghc-bin goes somewhere in /opt
00:49:19 <ivanm> larrythecow: ask kolmodin on #gentoo-haskell
00:49:29 <ivanm> queries related to gentoo-specific stuff are more properly asked there
00:49:45 <larrythecow> ah got it
00:50:06 <larrythecow> /opt/ghc/bin/ghc(i)
00:50:51 <kolmodin> I'm off to work, ask me in 30 min if you haven't solved it :)
00:53:14 <dmwit> > init "hello"
00:53:16 <lambdabot>  "hell"
00:53:25 <ivanm> lol
00:53:30 <boegel> hehe
00:54:26 <larrythecow> so how long will the beginners track take?
00:54:38 <LeCamarade> ?src init
00:54:39 <lambdabot> init [x]    = []
00:54:39 <lambdabot> init (x:xs) = x : init xs
00:54:39 <lambdabot> init []     = undefined
00:55:55 <ivanm> larrythecow: the rest of your life ;-)
00:56:33 <dmwit> ?src tail
00:56:33 <lambdabot> tail (_:xs) = xs
00:56:34 <lambdabot> tail []     = undefined
00:56:42 <dmwit> Bah.
00:57:01 <int-e> why bah?
00:57:30 <dmwit> I wanted something that pattern-matched on _, to see the preferred alignment.
00:58:02 <dmwit> I always center things, which looks good, but which is not robust to changes.
01:00:33 <LeCamarade> ?src zip
01:00:33 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
01:00:34 <lambdabot> zip _      _      = []
01:01:43 <LeCamarade> You know, a bit off-hand, but I've been finkin': is it possible to have a lazy-eval architecture? As in, lazy from the asm? Sounds like a joke.
01:02:38 <dcoutts> LeCamarade: check out the work on functional computer architectures from the '80s and early '90s.
01:02:59 <dcoutts> there was a lot of research on that topic
01:03:17 <fuzan> howdy all.
01:03:48 <dcoutts> LeCamarade: there were comercial LISP machines, though of course LISP isn't lazy.
01:04:12 <ivanm> with darcs, how do I revert back to a previous/initial state for a file?
01:04:14 <LeCamarade> What?!?! So, actually, some people were that crazy? Hmm ... yeah, lemme check around. It would be nice to kick such ASM.
01:04:14 <dcoutts> there were certainly many designs for machines that ran combinator code or did graph reduction
01:04:49 <dcoutts> ivanm: depends if you'r talking about recorded changes or just changes in the working copy
01:05:18 <dcoutts> ivanm: darcs revert for reverting changes in the working copy
01:05:22 <ivanm> well, I recorded them so that I'd have a copy of what I did (even though I don't want to keep it)
01:05:22 <LeCamarade> dcoutts: But then, when does the laziness stop? Because, as far as the machine is concerned, everything is waiting to happen. When is the evaluation needed?
01:05:43 <ivanm> but I want to go back to the original versions, just still remembering the altered copies
01:05:47 <dcoutts> LeCamarade: exactly the same place as evaluation is required now
01:06:29 <LeCamarade> And ... when is that? When exiting main? :oD
01:06:44 <dcoutts> when entering main
01:06:57 <dcoutts> you're asking for an expression to be reduced to weak head normal form
01:07:12 <dcoutts> that places demands on sub-expressions etc
01:07:26 <larrythecow> ivanm: no seriously, how long will it take me to finish the beginners track?
01:07:29 <dcoutts> ivanm: what do you mean by 'original', do you mean the current recorded version or older recorded versions ?
01:07:43 <LeCamarade> Where is main in mov ax, 23, which is a complete ASM? Or did the lazy architectures require more?
01:07:47 <ivanm> larrythecow: I've been using haskell since december last year, and am still on the beginner's track...
01:08:18 <dcoutts> larrythecow: there's a new book that gets you there quicker!
01:08:26 <earthy> hell, I consider myself somewhere near the end of the beginner's track
01:08:35 <earthy> and I eat parser combinator libraries for breakfast
01:08:42 <dcoutts> @google graham hutton book "programming in Haskell"
01:08:46 <lambdabot> http://www.cs.nott.ac.uk/~gmh/book.html
01:08:47 <lambdabot> Title: Programming in Haskell
01:08:48 <ivanm> dcoutts: I recently set up a darcs repo of some files I'd done, and I want to go back to those files that I started with (i.e. remove all patches), preferably whilst keeping those patches that I made so that I can access them in future if I want
01:08:53 <dolio> LeCamarade: You're probably thinking of things too much in terms of current architectures.
01:09:06 <fuzan> larrythecow: books help liek dcoutts says, however, the best thing you can do is to start implementing code, asking intelligent questions, and reading other people's code.
01:09:09 <int-e> LeCamarade: it wouldn't work that way I think; the architecture would rather provide hardware support for, say, entering thunks if they're unevaluated
01:09:10 <ivanm> dcoutts: so graham's new book is really that good? better than any other beginner's book?
01:09:29 <vincenz> ivanm: 'graham'?
01:09:33 <dolio> A lazy machine would be more like something that does what the haskell runtime does, only in hardware.
01:09:33 <ivanm> fuzan: agreed... reading through code is a great way to learn
01:09:41 <ivanm> vincenz: graham hutton's
01:09:44 <vincenz> oh
01:09:47 <dcoutts> ivanm: ah ok, so you probably want to make a copy of the repo giving you an earlier version, I think you can 'darcs get' your current repo and select a tag or date or something and that'll give you an earlier version of the repo.
01:09:47 <LeCamarade> larrythecow: Just relax. Haskell is lazy, so you might as well get lazy. It will work itself onto you, slowly, surely. When people learn Java in three days, they expect Haskell to be the same. Wrong. Relax. Take some time.
01:10:15 <LeCamarade> @google grahham hutton haskell book
01:10:20 <lambdabot> http://www.google.com/sorry/?continue=http://www.google.com/search%3Fhl%3Den%26q%3Dgrahham%2520hutton%2520haskell%2520book%26btnI%3DI%27m%2BFeeling%2BLucky
01:10:21 <lambdabot> Title: 403 Forbidden
01:10:27 <LeCamarade> @google graham hutton haskell book
01:10:33 <lambdabot> http://www.google.com/sorry/?continue=http://www.google.com/search%3Fhl%3Den%26q%3Dgraham%2520hutton%2520haskell%2520book%26btnI%3DI%27m%2BFeeling%2BLucky
01:10:33 <lambdabot> Title: 403 Forbidden
01:10:51 <ivanm> dcoutts: oh... I kinda am using a copy of the repo for at the moment... maybe it'll be easier to copy the changed file and record it as a new name, then revert all changes to the original file?
01:11:04 <dcoutts> ivanm: alternatively just make a copy and keep unrecording patches until you get back to the initial checkin patches.
01:11:16 <ivanm> *nod*...
01:11:28 <ivanm> is it possible to just revert all patches for a single file?
01:11:32 <dcoutts> ivanm: probably not, you can't easily revert all patches that apply to a single file
01:11:39 <ivanm> oh :(
01:11:44 <dons> nice, lennart A's got a blog, http://augustss.blogspot.com/2007/04/overloading-haskell-numbers-part-1.html
01:11:47 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2gh7aw
01:11:48 <dcoutts> ivanm: because many patches will touch other files or have dependencies on other patches
01:11:59 <ivanm> yeah, I suppose so
01:12:11 <vincenz> dons: yeah :)
01:12:14 <dcoutts> so it'd be impossible to get a consistent repo that way
01:12:15 <vincenz> dons: pretty spiffy too
01:12:27 <dons> http://programming.reddit.com/info/1hk2q/comments
01:12:28 <lambdabot> Title: Overloading Haskell numbers, part 1, symbolic expressions. (reddit.com)
01:12:33 <dons> yeah. very very nice.
01:12:46 <ivanm> dons: he's lying! in his first post, he says "I have started a blog, just like everyone else"... not _everyone_ has a blog!
01:12:57 <ivanm> ;-)
01:13:12 <vincenz> ivanm: everyone I know about has a blog
01:13:20 <vincenz> though everyone I know I know them cause they have a blog...hmmm
01:13:21 <ivanm> dcoutts: OK, I might just manually copy the file than obliterate everything
01:13:24 <ivanm> vincenz: I don't...
01:13:34 <larrythecow> woah! I asked Prelude> 5 * 4 + 3 -7 + 8 * 2 * 2 * 2 * 2 / 284
01:13:36 <hpaste>  LeCamarade pasted "which(1) in Haskell. Any Criticism?" at http://hpaste.org/1371
01:13:40 <larrythecow> and haskell responded instantly
01:13:41 <larrythecow> :D
01:13:51 <vincenz> larrythecow: lazy evaluation at its best!
01:13:53 <larrythecow> if only I could do that in maths tests
01:13:54 * earthy doesn't have a blog
01:14:06 <ivanm> vincenz: the only website I have is a dodgy one I used to host some files at one point (its space on my ISP's server)
01:14:22 <vincenz> ivanm: I was saying that very much tongue-in-cheek
01:14:26 <ivanm> earthy: shall we create the "haskeller's without blogs" society? :p
01:14:34 <ivanm> vincenz: no, really?
01:14:40 <vincenz> ivanm: I suggest you publicize that society through a blog
01:14:43 <ivanm> (actually, I didn't get that...)
01:14:47 <ivanm> vincenz: lol
01:14:52 <fuzan> my haskell blog is horrible :)
01:15:06 <fuzan> i never have the endurance to finish a blog.
01:15:08 <LeCamarade> Okay, the seasoned lambdamen. I have written which(1), which must be the easiest POSIX thing. It's at hpaste. Can someone tell me if I have finally learnt how to do things `the Haskell way'?
01:15:16 <earthy> ivanm: well, I was thinking about starting one
01:15:17 * ivanm wanted to create a website over summer... he learnt haskell instead!
01:15:21 <earthy> just to get my own ideas down on paper
01:15:32 <ivanm> earthy: *nod*
01:15:32 <larrythecow> this one is bound to crash it: Prelude> 5 * 4 + 3 -7 + 8 * 2 * 2 * 2 * 2 / 284 ^ 2 ^ 2 ^ 74
01:15:35 <ivanm> me too
01:15:39 * vincenz mostly blogs in his personal notebook
01:15:39 <earthy> s/paper/screen text/ :)
01:15:48 <vincenz> gotta go
01:16:00 <ivanm> earthy: the problem is, where would you do it? I don't particularly want a generic myspace/blogspot/etc/blog
01:16:06 <eumenides> LeCamarade: maybe wrap the code at 72 chars or so
01:16:17 <larrythecow> hah.. it is still working it out...
01:16:21 <osfameron> ivanm: Vox?
01:16:22 <fuzan> LeCamarade: feel free to use do notation to reduce huge lines :)
01:16:24 <LeCamarade> ivanm: problem is that once you start Haskell, you want to use it everywhere. The Haskell report is curiously silent about the potential damage to one's job.
01:16:30 <ivanm> osfameron: never heard of it...
01:16:42 <osfameron> ivanm: produced by people that do movable type
01:16:46 * LeCamarade is noting all your points feverishly ...
01:16:50 <int-e> LeCamarade: I'd split that long line, and probably use do notation. and in split,  I'd accumulate with (x:cp) instead of (cp ++ [x]) and do a reverse in the end.
01:16:52 <ivanm> LeCamarade: heh... currently, my job is a student, so I'm _trying_ to use it everywhere for it ;-)
01:17:03 <ivanm> @google vox
01:17:06 <lambdabot> http://www.google.com/sorry/?continue=http://www.google.com/search%3Fhl%3Den%26q%3Dvox%26btnI%3DI%27m%2BFeeling%2BLucky
01:17:07 <lambdabot> Title: 403 Forbidden
01:17:17 <ivanm> *gasp* is google down?
01:17:18 <osfameron> ivanm: I have part of a haskell blog at http://osfameron.vox.com/  (but I need tuits to get to chapter 2!)
01:17:23 <larrythecow> you can wrap bash scripts into haskell right?
01:17:28 * ivanm goes to check in that fandagled thing called a "browser"
01:17:32 <larrythecow> and make it execute bash scripts?
01:17:39 <int-e> ivanm: looks more like google blacklists lambdabot's IP
01:17:45 <fuzan> ivanm: yah, it's nice being able to con teachers into letting me use haskell :)
01:17:52 <ivanm> int-e: why?
01:18:04 <int-e> ivanm: too many search requests perhaps?
01:18:04 <ivanm> fuzan: its "choose-your-own" projects :D
01:18:13 <ivanm> int-e: I suppose :(
01:18:20 <dcoutts> int-e: it's didn't mind my one earlier
01:18:24 <dcoutts> @google graham hutton book "programming in Haskell"
01:18:30 <lambdabot> http://www.google.com/sorry/?continue=http://www.google.com/search%3Fhl%3Den%26q%3Dgraham%2520hutton%2520book%2520%2522programming%2520in%2520Haskell%2522%26btnI%3DI%27m%2BFeeling%2BLucky
01:18:30 <lambdabot> Title: 403 Forbidden
01:18:31 <ivanm> fuzan: I might be doing a special topics project just dealing with haskell :D
01:18:38 <dcoutts> but now it does complain
01:19:00 <ivanm> osfameron: my original point was, if I was going to do a blog, I'd want it on my own site...
01:19:10 <ivanm> osfameron: but that involves me _having_ my own site ;-)
01:20:25 <osfameron> ivanm: ah, sure, I wasn't sure if you meant "generic" at all... or generic as in "naff like myspace" ;-)
01:20:43 <ivanm> osfameron: nah, I meant as in using another website...
01:20:44 <osfameron> fair enough.  I'm quite keen on outsourcing stuff rather than hosting, as I really hate sysadmin
01:20:54 <ivanm> lol, never had that experience..
01:20:59 <earthy> ivanm: well, I do have my own domain
01:21:04 <earthy> and I can run my own server no problem
01:21:09 <ivanm> I might start one, but don't know when I'd have time ;-)
01:21:12 <ivanm> earthy: nice!
01:21:12 <earthy> it's just... I don't wanna ;)
01:21:16 <ivanm> lol
01:21:17 <hpaste>  (anonymous) annotated "which(1) in Haskell. Any Criticism?" with "(no title)" at http://hpaste.org/1371#a1
01:21:31 <earthy> well, not really, but there's also such a thing as 'time to invest'
01:21:33 <osfameron> I wrote my own "blog engine" in Perl once, for an asciimation series I was doing... but it was pish, I'd use a packaged one these days (fun experience though)
01:21:36 <dcoutts> @seen swiert
01:21:37 <lambdabot> I saw swiert leaving #haskell 15h 31m 10s ago, and .
01:21:52 <earthy> well, he was walking around the halls here yesterday
01:21:52 <ivanm> anyone made a blog engine in hakell? :p
01:21:55 <ivanm> *haskell
01:21:59 <earthy> ivanm: ndm did, kinda
01:22:04 <dcoutts> ivanm: yep
01:22:07 * LeCamarade is done splitting up the long line in his hpaste dump, and wonders if everyone is happy with him, now ...
01:22:11 <ivanm> kinda? how kinda is kinda?
01:22:11 <dcoutts> I think shapr did
01:22:35 * ivanm was just about to google... then realised that google is arguing with LB
01:22:50 <earthy> ivanm: it's a 'website integrator' where you write snippets of html and the indices and the nice layout stuff is added in
01:23:23 <LeCamarade> Why does Google seem to be blocking lambdabot?
01:23:25 <ivanm> ahhh.....  a bit like a wiki-engine then?
01:23:33 <dmwit> ?go testing
01:23:41 <ivanm> LeCamarade: we just discussed this above... too many requests?
01:23:42 <lambdabot> http://www.testing.com/
01:23:42 <lambdabot> Title: Testing Foundations - Brian Marick
01:23:50 <ivanm> what? go works, but not google?
01:23:56 <ivanm> isn't go just an alias for google?
01:24:06 <dmwit> ivanm: Yes, it's spell-corrected to google.
01:24:40 <ivanm> ahhh...
01:24:48 <ivanm> @google google lambdabot
01:24:52 <lambdabot> http://www.google.com/sorry/?continue=http://www.google.com/search%3Fhl%3Den%26q%3Dgoogle%2520lambdabot%26btnI%3DI%27m%2BFeeling%2BLucky
01:24:53 <lambdabot> Title: 403 Forbidden
01:25:00 <ivanm> nope... :(
01:25:07 <ivanm> @go google lambdabot
01:25:12 <lambdabot> http://www.google.com/sorry/?continue=http://www.google.com/search%3Fhl%3Den%26q%3Dgoogle%2520lambdabot%26btnI%3DI%27m%2BFeeling%2BLucky
01:25:12 <lambdabot> Title: 403 Forbidden
01:25:16 <ivanm> ?go google lambdabot
01:25:19 <LeCamarade> @yahoo lambdabot
01:25:22 <lambdabot> http://tunes.org/~nef/logs/haskell/06.08.01
01:25:22 <lambdabot> Unknown command, try @list
01:25:39 <ivanm> hmmm... what difference is there between @go and ?go?
01:25:49 <ivanm> LeCamarade: it's not magic!
01:26:03 <dmwit> Huh, that really is more different!
01:26:06 <earthy> it is barely distinguishable though. ;)
01:26:08 <LeCamarade> Hmm ... how can the *Haskell* community be is such a position as to be taken hostage by Google? Our own Google is six monads away ...
01:26:31 <LeCamarade> ivanm: Yeah, but you'd think we like a bit of variety. Dons! Whence art thou!
01:26:41 <hpaste>  dolio annotated "which(1) in Haskell. Any Criticism?" with "An alternate split" at http://hpaste.org/1371#a2
01:26:47 <ivanm> whence? shouldn't it be wherefore?
01:27:13 <ivanm> ?google why doesn't google like lambdabot?
01:27:16 <lambdabot> http://www.google.com/sorry/?continue=http://www.google.com/search%3Fhl%3Den%26q%3Dwhy%2520doesn%27t%2520google%2520like%2520lambdabot%253F%26btnI%3DI%27m%2BFeeling%2BLucky
01:27:17 <lambdabot> Title: 403 Forbidden
01:27:28 <ivanm> OK, only ?go works... DON"T ABUSE IT!!!
01:27:29 <ivanm> ;-)
01:27:44 <ivanm> @seen dons
01:27:45 <lambdabot> dons is in #haskell-soc, #haskell-overflow and #haskell. I last heard dons speak 15m 11s ago.
01:28:16 <int-e> ivanm: ?go doesn't work any better either. I guess we should just stop trying and let the dust settle
01:28:36 <ivanm> int-e: I just did a ?go up above, whilst the others weren't working...
01:28:45 <int-e> (?go, @go, ?google and @google are exactly the same thing)
01:28:48 <int-e> ivanm: you got lucky
01:29:06 <ivanm> *shrug*... may be
01:29:49 <dons> ivanm: yo.
01:29:52 <LeCamarade> ivanm: Yeah. Let's give it a pause. Or ... what if we hit something like google.co.uk, would it do the same? Maybe, if that survives, we can be hitting randomly-select domains. Else Just (.com).
01:30:01 <dons> hehe
01:30:10 <dons> ?users
01:30:11 <lambdabot> Maximum users seen in #haskell: 336, currently: 301 (89.6%), active: 35 (11.6%)
01:30:24 <ivanm> dons: any specific info about google and LB?
01:31:49 <ADEpt> @hoogle a -> [(a->b)] -> [b]
01:31:50 <lambdabot> No matches, try a more general search
01:32:07 <ADEpt> @hoogle [(a->b)] -> a -> [b]
01:32:08 <lambdabot> No matches, try a more general search
01:32:32 <int-e> @type map . flip id
01:32:34 <lambdabot> forall a c. a -> [a -> c] -> [c]
01:33:12 <dons> i have no specific info.
01:33:21 <ADEpt> thnx :)
01:33:22 <ivanm> :(
01:33:22 <dons> though I wish LB said "does not compute" more often.
01:33:33 <ivanm> lol
01:33:40 <ivanm> you're the programmer... make it so!
01:33:48 <dons> ?go xmonad
01:33:53 <lambdabot> http://www.google.com/sorry/?continue=http://www.google.com/search%3Fhl%3Den%26q%3Dxmonad%26btnI%3DI%27m%2BFeeling%2BLucky
01:33:54 <lambdabot> Title: 403 Forbidden
01:33:57 <dons> huh.
01:34:05 <osfameron> LB?
01:34:10 <ivanm> lambdabot
01:34:10 <dmwit> lambdabot
01:34:12 * dons investigates
01:34:16 <dcoutts> dons: it's thinks you're a bot
01:34:16 <int-e> @quote stereo
01:34:17 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
01:34:18 <ivanm> go dons go!
01:34:20 <osfameron> ah, silly me
01:34:22 <dcoutts> dons: see the link
01:34:35 <ivanm> @quote lambdabot
01:34:36 <lambdabot> lambdabot says: I know nothing about comprehending.
01:34:45 <ivanm> @quote google
01:34:46 <lambdabot> dibblego says: I'm glad I googled it before going to see the doctor
01:34:53 <dons>     ... but your query looks similar to automated requests from a computer virus or spyware
01:34:56 <dons>     application. To protect our users, we can't process your request right now.
01:34:59 <dons> lambdabot *is* spyware!
01:35:02 <dcoutts> captcha
01:35:02 <dons> it can SEE you!
01:35:11 <ivanm> dcoutts: I loked at that site... it just says the file can't be found
01:35:20 <dcoutts> ivanm: you were too slow :-)
01:35:28 <ivanm> ahhh.....
01:35:33 <ski> @ghc
01:35:33 <lambdabot> ghc says: Warning: you can make GHC diverge by using SPECIALISE INLINE on an ordinarily-recursive function.
01:35:40 <dcoutts> it only seem to have that page there for a few seconds
01:35:42 <dons> cool
01:35:53 <dons> ok. let me try to fixify this.
01:36:03 <ivanm> dinner time... dons, I hope you've fixed this by the time I'm back...
01:36:16 <dcoutts> ivanm: now now, no demands please
01:36:29 <ivanm> maybe using LeCamarade's suggestion of rotating googles?
01:36:46 <ivanm> dcoutts: I said _hope_, not "you better"
01:36:54 <dcoutts> @arr
01:36:55 <lambdabot> I'll keel haul ya fer that!
01:37:03 <dcoutts> ivanm: ok ok :-)
01:37:18 * dcoutts notes that dons is a busy man
01:37:34 <dcoutts> we shouldn't load him up with too much extra work, that's all
01:37:39 <ivanm> dcoutts: aren't we all (assuming we're all men)?
01:37:55 <ivanm> dcoutts: presumably he'd like LB fixed as well... not pressuring him or anything ;-)
01:38:20 * dcoutts thinks he has more immediate priorities
01:38:21 <dons> ?go haskell
01:38:28 <dons> come on...
01:38:30 <lambdabot> http://www.google.com/sorry/?continue=http://www.google.com/search%3Fhl%3Den%26q%3Dhaskell%26btnI%3DI%27m%2BFeeling%2BLucky
01:38:30 <lambdabot> Title: 403 Forbidden
01:39:13 <dons> grr. have to do it from the same machine.
01:39:44 <dcoutts> ssh
01:39:46 <LeCamarade> dons: Try hard-recoding google.co.ug into it. Or gimme her UserAgent stuff, so I can see if it works on other Google domains.
01:40:08 <LeCamarade> Do they know her by UserAgent? I doubt. Spyware changes UserAgent names every millisecond.
01:40:27 <LeCamarade> Oh, so it is the IP?
01:40:33 <dcoutts> LeCamarade: probably by the ip address and pattern of search history
01:41:03 <sjanssen> dons: I just fixed that mysterious focus change on workspace switch bug
01:41:32 <dcoutts> sjanssen: does that bug fix have an interesting story?
01:41:48 <sjanssen> dcoutts: I was a bit surprised at the resolution
01:41:55 <LeCamarade> How about we give her a set of proxies and stuff ... or we use Yahoo! :oD I mean, frig, but we all had happy lives before Goo.
01:42:13 <sjanssen> when xmonad switches workspaces, it moves the new windows in first, then the old windows out
01:42:21 <dcoutts> sjanssen: right
01:43:38 <sjanssen> I added code to ignore window entry in refresh (this is called whenever there's an expected layout change: new window, workspace switch, etc.)
01:43:44 <sjanssen> but the bug persisted
01:44:15 <sjanssen> I finally realized that entry events are also generated when we move the stale windows off screen
01:44:38 <dcoutts> ah, so focus was being given to one of the windows that we're being unmapped ?
01:44:51 <dcoutts> we're/were
01:45:24 <dons> i think they go by IP
01:45:26 <dons> with a timeout
01:45:28 <dons> sjanssen: woot
01:45:43 <sjanssen> nah, focus was given to a window *under* one of the old windows
01:45:47 <dons> sjanssen: oh, ChilliX suggests we publish the doc as a Technical Report
01:45:53 <dcoutts> swiert: hia, quick Q.. how long is the FP course at Nottingham? in how many weeks do students cover the material in the book?
01:45:56 <dons> that way it can be cited. (our xmonad doc)
01:46:05 <dons> I think this is a good idea.
01:46:21 <dcoutts> dons: not just the next TMR edition? or is that not citable?
01:46:22 * dons ponders how to fix lambdabot
01:46:36 <dons> dcoutts: well, it'll be done in say, 2weeks.
01:46:43 <dons> I think maybe a revised version could go to the TMR?
01:47:16 <dons> hmm. grr. captchas aren't nice for ssh over remote connections.
01:47:27 <dcoutts> heh heh, no.
01:47:34 <dons> oh, maybe i can forward traffic .
01:47:46 <sjanssen> dons: sounds good to me
01:48:04 <dons> sjanssen: do you agree, we won't get this done by the TMR deadline?
01:48:22 <dcoutts> dons: might need to do an http proxy rather than direct ssh forwarding, eg tinyproxy serving on localhost on the lambdabot box
01:48:37 <sjanssen> dons: yeah, I think it's late to make TMR
01:48:42 <dcoutts> isn't the TMR deadline today?
01:48:58 <dons> yeah. so no chanc.e
01:49:08 * dcoutts busily finishes off his review
01:49:13 <dons> swiert: unfortunately, we won't have the xmonad article ready for TMR today! :( sorry!
01:49:26 <dcoutts> swiert: but I will (probably)
01:49:46 <dons> we plan to finish it in the coming 2 weeks though. and perhaps have a revised version for the next TMR.
01:49:47 <dcoutts> give or take a few hours
01:50:01 <LeCamarade> dcoutts: :oD
01:50:15 <dcoutts> we should write something about building libs and optimising code for TMR
01:50:28 <dcoutts> haskell development methodologies etc
01:51:06 <dons> ?go google
01:51:08 <lambdabot> http://www.google.com/
01:51:08 <lambdabot> Title: Google
01:51:11 <dons> interesting.
01:51:16 <dons> did someone fix this?
01:51:27 <int-e> dons: maybe it's just rate limited?
01:51:28 <dcoutts> @google graham hutton book "programming in Haskell"
01:51:34 <lambdabot> http://www.google.com/sorry/?continue=http://www.google.com/search%3Fhl%3Den%26q%3Dgraham%2520hutton%2520book%2520%2522programming%2520in%2520Haskell%2522%26btnI%3DI%27m%2BFeeling%2BLucky
01:51:34 <lambdabot> Title: 403 Forbidden
01:51:37 <dcoutts> nope
01:51:38 <dons> ah
01:51:46 <dcoutts> mind you that's a search I did earlier
01:51:53 <dcoutts> maybe it remembers
01:52:06 <dcoutts> @google graham hutton programming Haskell
01:52:09 <lambdabot> http://www.cs.nott.ac.uk/~gmh/book.html
01:52:10 <lambdabot> Title: Programming in Haskell
01:52:14 <dcoutts> ah!
01:52:20 <dcoutts> subtly different query
01:52:26 <dons> oh, yes, unsw proxy I think.
01:52:32 <dcoutts> ah right
01:52:34 <kuribas> Does the dependency fps-any mean ByteString?
01:52:35 <dcoutts> of course
01:52:42 <dcoutts> kuribas: yep
01:52:52 <dcoutts> kuribas: so you can delete that dep if you're using ghc-6.6
01:53:24 <LeCamarade> @google tomfoolery
01:53:27 <lambdabot> http://www.thefreedictionary.com/tomfoolery
01:53:27 <lambdabot> Title: tomfoolery - definition of tomfoolery by the Free Online Dictionary, Thesaurus a ...
01:53:30 <kuribas> dcoutts: Ah, I see.  Thanks :)
01:53:36 <dons> hmm. this is annonying.
01:53:52 <dons> basically, if its in the unsw proxy cache, it'll work.
01:54:15 <dons> but new searches won't. and getting at the captcha is not so easy on my remote machine.
01:54:19 <dons> esp. with the 10 second timeout
01:55:05 <sjanssen> what made google angry in the first place?
01:55:24 <dons> just some policy change, I suppose.
01:55:31 <sjanssen> I guess they sample searches over a long period of time?
01:55:56 <dons> particularly since we hit 'I'm feeling lucky'
01:57:54 <LeCamarade> @google Haskell Prime
01:58:01 <lambdabot> http://www.google.com/sorry/?continue=http://www.google.com/search%3Fhl%3Den%26q%3DHaskell%2520Prime%26btnI%3DI%27m%2BFeeling%2BLucky
01:58:01 <lambdabot> Title: 403 Forbidden
01:58:13 <sjanssen> @slap LeCamarade
01:58:14 * lambdabot smacks LeCamarade about with a large trout
01:59:32 * LeCamarade picks himself off the ground, staggers, wipes the saliva off his neck ... `Look, I am working on a solution, here! I was testing ... I meant no ...' falls back down to the ground, and breathes his last.
02:01:59 <dons> ?go test
02:02:06 <lambdabot> http://www.google.com/sorry/?continue=http://www.google.com/search%3Fhl%3Den%26q%3Dtest%26btnI%3DI%27m%2BFeeling%2BLucky
02:02:09 <dons> sigh.
02:02:50 <dons> i hate this timeout issue.
02:03:48 <dons> ?go test
02:03:49 <lambdabot> http://www.test.com/
02:03:49 <lambdabot> Title: Test.com Web Based Testing Software
02:03:57 <dons> proxies suck
02:03:57 <LeCamarade> Yay!
02:04:36 * LeCamarade giveth his profuse thanks to dons, who seems to have healed it ... He did, didn't he?
02:04:46 <dons> nah, its not fixed.
02:04:49 <dons> ?go something else
02:04:54 <lambdabot> http://www.modestypanel.com/SorSE/
02:04:54 <lambdabot> Title: Sexxx or Something else?
02:04:58 <dons> oh, maybe it is.
02:05:01 <dons> ?go haskell
02:05:05 <lambdabot> http://www.google.com/sorry/?continue=http://www.google.com/search%3Fhl%3Den%26q%3Dhaskell%26btnI%3DI%27m%2BFeeling%2BLucky
02:05:06 <lambdabot> Title: 403 Forbidden
02:05:09 <dons> nope
02:06:26 <dons> i do actually manage to get the captcha decoded, but then it just returns to the same screen
02:06:32 <dons> maybe it needs javascript too
02:07:04 * dons kicks google
02:09:30 <LeCamarade> dons: I know this may be tripe, but how about chaning three chars: com and putting co.uk? Would it puke, still?
02:11:26 <swiert> dcoutts: Let me check how long the terms are in Nottingham.
02:14:11 <LeCamarade> http://google.com/search?q=haskell
02:14:13 <lambdabot> Title: haskell - Google Search
02:15:24 <swiert> dcoutts: Spring Term	Monday 8 Jan 2007 â€“ Friday 23 March 2007;
02:15:25 <swiert> Summer Term	Monday 23 April 2007 - Friday 15 June 2007
02:15:57 <fuzan> hmm, i'm trying to run the xslt example from http://happs.org/HAppS/doc/tutorial.html
02:15:59 <lambdabot> Title: HAppS Tutorial
02:16:05 <fuzan> it builds, yet errors with a:
02:16:13 <fuzan> user error (decodeStringM: parsing failed @ "MyState \"H")
02:16:23 <fuzan> no luck with google or staring at code
02:16:44 <swiert> dcoutts: About 4 months, excluding Easter holidays.
02:17:49 <swiert> dcoutts: But I doubt they cover everything in the book... You may want to check with Graham to be sure.
02:18:30 <swiert> dons: Do you have a realistic estimate when you could have it ready?
02:18:52 <swiert> There are a few other articles in the pipes, that will need a bit more time to finish.
02:19:32 <dons> swiert: hmm. i don't have a good estimate, as i'm travelling all week. :/
02:20:19 <swiert> dons: Fair enough.
02:22:09 <fuzan> oh, got it. not sure what it was.
02:24:27 <roconnor> > log 2
02:24:29 <lambdabot>  0.6931471805599453
02:27:49 <dcoutts> swiert: ok
02:28:52 <dcoutts> swiert: btw, if you think it's appropriate we could include a short excerpt, like they have on amazon.
02:29:17 <dcoutts> though I'm already up to about 8 pages
02:31:11 <swiert> dcoutts: Might be a good idea. I'd have to have a look at the review.
02:31:30 <dcoutts> swiert: I should have a draft soon
02:31:32 <swiert> Doesn't the amazon text just quote the back cover?
02:31:49 <dcoutts> swiert: no, it's got lots, check it out
02:33:31 <dcoutts> it's got the 'search inside' thing:
02:33:40 <dcoutts> http://www.amazon.com/gp/reader/0521692695/ref=sib_dp_pt/104-2504597-0223117#reader-link
02:33:43 <lambdabot> http://tinyurl.com/2a488k
02:34:19 <dcoutts> swiert: their excerpt is the whole of chapter 1
02:34:45 <swiert> Didn't Graham use to have a draft online?
02:34:59 <dcoutts> no idea
02:35:20 <dcoutts> you'd probably have sent it to me if he did
02:35:33 <dcoutts> remember all the hassle we had with that :-)
02:37:00 <swiert> Sure :)
02:48:18 <dolio> @src sort
02:48:18 <lambdabot> sort = sortBy compare
02:48:29 <dolio> @src sortBy
02:48:30 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
02:49:30 <joelr1> good morning
02:51:00 <joelr1> is it useful to buy graham if you already have "the haskell school of expression"?
02:51:52 <int-e> lambdabot: liar
02:57:04 <waern> wouldn't it be nice if all IO operations had signatures like: IO m => .. -> m a
02:57:34 <norpan> do you need more than one kind of IO?
02:57:35 <waern> and the IO class provided some basic IO operations
02:58:09 <waern> norpan: you wouldn't have to explicitly lift IO operations when working in other monads
02:58:13 <norpan> that would be a big class
02:58:41 <norpan> explicitly lift IO operations?
02:58:46 <waern> norpan, couldn't it just provide some fundamental IO operations?
02:58:58 <dolio> @instances MonadIO
02:59:00 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
02:59:39 <dolio> You could have them all pre-lifted, I suppose.
02:59:41 <norpan> waern: it would have to provide all IO operations
03:00:22 <waern> dolio: not the same thing, is it?
03:00:22 <norpan> and you can introduce arbitrarily many IO operations via foreign import
03:00:44 <waern> norpan, yes, but couldn't foreign import just give the IO m => .. -> m a type signature?
03:01:05 <norpan> I don't see the point, you'd still need the IO monad and lift it
03:01:19 <norpan> or another monad which is exactly like the IO monad
03:01:30 <earthy> pfff. trying to wrap one's head around smart parser combinators is not the easiest thing to do
03:02:20 <waern> norpan, couldn't you just instantiate your monad in the IO class?
03:02:49 <dolio> waern: Well, MonadIO provides liftIO which lifts any IO action into a MonadIO action. So, no, it's not the same.
03:03:18 <waern> norpan, ah, hmm no you would need all the operations in the class, ok
03:03:29 <dolio> waern: I was saying you could maybe have an IO core, and then have all the standard use functions be 'liftIO (coreFucnction)'.
03:03:52 <dolio> Which is about what you're suggesting, I guess.
03:04:49 <norpan> yeah
03:04:53 <waern> dolio, yes...
03:04:54 <waern> argh
03:04:54 <norpan> that could be one thing
03:04:57 <waern> I hate lifting :)
03:05:06 <norpan> lifting is good for your biceps
03:06:30 * osfameron doesn't understand what lifting is :-(
03:08:07 <roconnor> > (^2) . (+2) 0
03:08:08 <lambdabot>   add an instance declaration for (Num (a -> b))
03:08:13 <roconnor> > (^2) . (+2) $ 0
03:08:14 <lambdabot>  4
03:08:23 <roconnor> > liftM (^2)  (+2) $ 0
03:08:25 <lambdabot>  4
03:08:33 <roconnor> lifting is composition
03:08:51 <dolio> In this case, it refers to taking a computation in one monad, and turning it into a computation in a transformed monad.
03:09:27 <dolio> So, turning 'IO a' into 'StateT s IO a' for example.
03:10:21 <osfameron> right
03:11:04 <waern> dolio: if that IO core is a class.. you could derive it for any monad that can do IO :)
03:11:14 <osfameron> monads seem to be like roles applied to data, and lifting would be the process that makes sure that data has the appropriate roles to be consumed by another function?
03:14:25 <dolio> waern: I guess. But how many monads can do IO besides IO, and things that wrap IO?
03:14:46 <waern> dolio: all monad transformers applied to IO?
03:15:06 <waern> ReaderT r IO a, etc
03:16:17 <dolio> Right, but that's covered by what I explained earlier by wrapping all the functions with liftIO.
03:16:33 <dolio> You'd still need to implement IO itself, although you wouldn't use it directly.
03:17:24 <waern> not if you could automatically derive the "IO class" :)
03:18:38 <dolio> I'm not sure I understand. MonadIO is the class of all monads that do IO.
03:19:04 <dolio> But the IO monad itself is the concrete type that actually has an implementation of getLine and such that does actual work.
03:19:28 <waern> yes, yes
03:19:29 <dolio> All the transformers just wrap IO in no-ops for the outer monad.
03:19:41 <waern> yep
03:20:51 <dolio> Anyway, I don't know why all the IO functions aren't "MonadIO m => ..." Maybe there's something wrong I haven't thought of, or maybe simply no one has bothered.
03:20:54 <waern> hmm I'll try to come up with something that will illustrate my idea
03:20:58 <hpaste>  peteso annotated "any more elegant solutions?" with "Once more with feeling" at http://hpaste.org/1366#a2
03:21:00 <dolio> It'd require a revision to the standard, certainly.
03:21:11 <waern> dolio: that's sort of what I mean...
03:21:37 <waern> yes
03:26:05 <ivanm> @seen dons
03:26:06 <lambdabot> dons is in #haskell-soc, #haskell-overflow and #haskell. I last heard dons speak 1h 6m 33s ago.
03:26:22 <ivanm> anyone know if dons managed to fix the google search in lambdabot?
03:33:31 <waern> dolio: I found a haskell prime ticket for this: http://hackage.haskell.org/trac/haskell-prime/ticket/110
03:33:33 <lambdabot> Title: #110 (Generalize types of IO actions) - Haskell Prime - Trac
03:37:21 <dolio> Ah, I guess it is just a question of the standard then (except where you need to unlift things).
03:43:24 <mux> is there a reason the Parsec monad isn't an instance of MonadState?
03:52:59 <Saizan> mmh given {get,modify,put}State you could make an instance yourself.. so i don't think so
03:53:11 <mux> that's what I'm doing right now
03:53:24 <ToRA> mux: i've asked that before - apparantly it's something to do with parsec existing before MonadState did...
03:57:40 <Cheery> describe main things which describe the user interface primarily in today's operating system
04:03:52 <junyer> hi
04:04:28 <junyer> a friend of mine had an idea (not an overly original one, i suspect) that i would like to try implementing in haskell
04:05:05 <junyer> would it be possible to define some kind of abstract interface for a data structure
04:05:23 <dmwit> Sure!
04:05:30 <junyer> and, based on the methods invoked, use type inference to select the underlying implementation
04:05:41 <junyer> i've had a few stabs at it without success
04:05:59 <dcoutts> ah, type classes
04:05:59 <dmwit> Err... what do you mean?
04:06:19 <chrisbrown> junyer: do you mean using overloading? that would involve using type classes
04:06:22 <vincenz> type classes = teh win
04:06:42 <junyer> well, maybe some pseudocode will clarify matters
04:06:48 <dcoutts> @hpaste
04:06:49 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:07:01 <dcoutts> junyer: ^^ try hpaste
04:07:38 <junyer> let x = newAbstractBase ; push x 1 ; let y = shift x ; -- push/shift means queue (very rough example)
04:07:52 <junyer> similarly, push/pop means stack
04:08:21 <junyer> and then it gets more complicated for key/value structures
04:08:40 <junyer> i.e. deciding whether it's a hash table or a tree or..
04:08:47 <dons> sounds like type class overloading.
04:08:56 <dcoutts> a list makes an excellent stack
04:09:11 <dons> or possibly, you have a fixed type ,that uses an internal representation based on the type of the keys or values?
04:09:15 <Cheery> junyer: do you think in terms of creating a query system which is selected on compile time?
04:09:23 <dons> (which you could do with associated types or functional dependencies)
04:09:25 <TomMD> Problem: I've found that, now that I know many many Haskell core features, I use all of these abilities when writing Haskell code.  This code then is not a very smart thing to show Haskell initiates because they might get turned away by the volume of nuancies.
04:10:22 <Cheery> ie. data structure which can be double ended queue, list, map, anything, but it is just inferred about the code
04:10:30 <junyer> right
04:10:34 <junyer> where might i read how to do that?
04:10:39 <Cheery> type classes and data structures are a start, and I loved them
04:10:45 <junyer> or, perhaps, where is an existing module for it? :P
04:11:09 <dcoutts> junyer: there's the edison collecton library
04:11:21 <Cheery> what you describes, I associate with table oriented programming, there's not very much about them
04:11:39 <eivuokko> Yo
04:11:46 <Cheery> wo
04:11:58 <dcoutts> junyer:  edison or the collections lib has various interfaces for different kinds of collection types and then various implementations of those interfaces
04:12:05 <junyer> ahh
04:12:08 <junyer> thanks, i'll look into that
04:12:15 <dcoutts> @where collections
04:12:16 <lambdabot> I know nothing about collections.
04:12:20 <dcoutts> hrm
04:12:26 <dcoutts> @where collection
04:12:27 <lambdabot> I know nothing about collection.
04:12:29 <dcoutts> bah
04:12:42 <junyer> http://www.haskell.org/ghc/docs/edison/
04:12:44 <lambdabot> Title: Edison User's Guide* (Haskell version)
04:12:44 <dons> i think its on hackage?
04:12:45 <junyer> got it
04:13:56 <dcoutts> http://haskell.org/haskellwiki/Library/New_collections
04:13:58 <lambdabot> Title: Library/New collections - HaskellWiki
04:14:24 <dcoutts> @where+ collections http://haskell.org/haskellwiki/Library/New_collections
04:14:25 <lambdabot> Done.
04:17:25 <Cheery> junyer: you were thinking of making a data type which can take variety of properties and it's final implementation is deduced from the context, right?
04:18:32 <junyer> yes, i was thinking (perhaps absurdly) of modelling it based on the c++ stl concepts
04:19:28 <junyer> so based on the required traits of each method that is used with a particular object, you figure out what type that object should be
04:19:39 <Cheery> ok, how were you thinking about doing it? table oriented programming proposes things similar to relational databases
04:20:22 <junyer> my first thought was along the lines of saying "yes" or "no" to each particular trait
04:20:32 <junyer> although how this turns into code is something i haven't worked out
04:21:55 <Cheery> junyer: well, if you care, I'd probably have a link for you
04:22:11 <junyer> i would certainly appreciate any information you have
04:22:17 <Cheery> @google table oriented programming
04:22:22 <lambdabot> http://www.google.com/sorry/?continue=http://www.google.com/search%3Fhl%3Den%26q%3Dtable%2520oriented%2520programming%26btnI%3DI%27m%2BFeeling%2BLucky
04:22:53 <Cheery> gah
04:22:55 <Cheery> http://www.geocities.com/tablizer/top.htm
04:22:55 <lambdabot> Title: Table Oriented Programming
04:23:34 <junyer> sweet, thanks
04:23:45 <Cheery> they think the thing as a paradigm, but all there is can be reduced to thing you described
04:24:22 <Cheery> how much do you know about haskell?
04:24:45 <junyer> not a great deal
04:25:37 <junyer> it's all i'm using outside of work these days
04:25:47 <junyer> so you could say that i'm dedicating myself to learning it
04:26:17 <Cheery> why you want to learn it?
04:26:54 <junyer> because i can't get more evil in perl without finding a buyer for my soul
04:27:25 <junyer> (and just maybe i can end up contributing to pugs.. heh)
04:28:17 <Cheery> ok. I just wonder what you are looking from haskell, since you came to this channel
04:28:49 <junyer> a new way of thinking about (and then doing) things
04:29:06 <junyer> i tried erlang briefly, but it wasn't quite my cup of tea
04:29:25 <Cheery> aha, I also tried erlang before haskell
04:29:57 <Cheery> I think it had too bulky syntax compared to what the syntax actually represented
04:30:13 <Cheery> the concurrency, etc. things were great thought
04:30:42 <junyer> yes, friends of mine are quite keen on the concurrency and also the pattern matching
04:30:53 <junyer> although i guess their work gives them those particular needs
04:31:09 <junyer> (telephony, unsurprisingly)
04:31:33 <Cheery> pattern matching <3
04:32:22 <Cheery> I guess the graph reduction and relationship of lambda calculus and haskell could interest you
04:32:41 <junyer> my mathematical background isn't very strong
04:32:55 <junyer> so i struggle with the heavily theoretical aspects
04:33:04 <Cheery> neither were mine when I found those out
04:33:11 <junyer> (and papers about haskell make my eyes glaze over)
04:33:22 <junyer> (like the one about wobbly types..)
04:33:31 <Cheery> but they are about the first neat things which hit my eyes when I entered the haskell
04:34:50 <Cheery> and their existence explains the weird syntax and the reason why those combinators just work
04:35:06 <junyer> i still haven't totally grokked monads yet :P
04:35:22 <Cheery> would you like to?
04:35:27 <junyer> of course
04:35:48 <dylan> http://hardison.net/warez/monads.txt
04:35:57 <dylan> ^ perhaps helpful, or at least funny.
04:36:16 <junyer> heheh
04:36:22 <junyer> okay
04:36:24 <int-e> Monads are a bit zen-like. To fully comprehend them you have to realize that there is almost nothing to understand.
04:36:45 <dcoutts> heh
04:36:58 <Cheery> the basic thing in them is that they are used to attach lambdas together instead of attaching them together directly, to get data about computation along the lambdas
04:37:03 <dcoutts> true, and don't call them monads
04:37:11 * ivanm starts paying attention "I want to know this as well"
04:37:11 <dcoutts> they're just things that can be sequenced
04:37:28 <int-e> yes, Sequencable would be a nice name for them
04:37:43 <dcoutts> and that explains why they're such a common pattern
04:37:50 <int-e> right after WarmAndFuzzyThing
04:38:02 <dylan> the good thing about my "Bob vs monad" description is it leads to people saying "Wait, subtraction of Bobs is just addition of negative numbers!" which leads naturally to explaining >> in terms of bind. or fmap/join.
04:38:56 <dylan> I should try turning that chat log into a proper introduction.
04:39:36 <Saizan> "You could have invented monad" from sigfpe helped me a lot to understand what's really the nature of the general monad and what's instead an effect of the particular instance
04:39:37 <ivanm> dylan: please do... or at least in a prettier format than txt ;-)
04:39:52 <dylan> ivanm: it's just the first 10 lines or so.
04:40:29 <ivanm> oh, OK... so what's the rest?
04:40:48 <int-e> my favourite monad instance to make the point that monads don't do anything is  data Null a = Null; instance Monad Null where return _ = Null; _ >>= _ = Null
04:40:55 <dylan> just a conversation where I further explain to my friend what I knew about monads a few months ago.
04:41:05 <cba> i have a stupid question. Is there a better way to write: do { a <- f >>= \s -> return (g s); ...}
04:41:08 <int-e> put values into a monad, never get them back, yay.
04:41:10 <Cheery> junyer: so, why attach lambdas together with monad instead of attaching them together directly?
04:41:41 <int-e> cba: liftM g f
04:41:50 <int-e> cba: for the f >>= \s -> return (g s) part
04:41:58 <Cheery> it enables you to define inside lambda which computational side effects you cause and exploit
04:42:04 <int-e> (some people prefer  fmap  instead of  liftM)
04:42:11 <cba> int-e: thanks
04:42:15 <Cheery> then spit it out as the result of lambda
04:42:52 <int-e> @pl f >>= \s -> return (g s)
04:42:53 <lambdabot> g `fmap` f
04:43:13 <int-e> infix, hmm.
04:44:07 <ivanm> dylan: hey, that's a pretty good tute...
04:44:57 <cba> @pl f >>= \s -> return (s,c)
04:44:58 <lambdabot> flip (,) c `fmap` f
04:45:03 <Cheery> junyer: to prevent confusions, there are rules on how monads should behave
04:45:19 <dylan> anyone know a scheme implementation that has turtle graphics?
04:48:40 <junyer> hmm
04:49:41 <junyer> the documentation for class Monad has method descriptions that are easy to understand
04:49:57 <junyer> "Sequentially compose two actions, [..]"
04:49:58 <junyer> et cetera
04:50:30 <junyer> i'm always inquisitive enough to want to know how the magic works though
04:51:12 <joelr1> how do you shorten the ghci prompt?
04:51:19 <int-e> junyer: the magic is in the individual monad instances.
04:51:25 <joelr1> after several :m +...
04:51:27 <junyer> ahh
04:52:06 <int-e> joelr1: :set prompt "> "
04:52:15 <joelr1> int-e: thanks
04:53:47 <cba> how does lamdbabot store its information? in a sql-database?
04:54:23 <int-e> no. there are several state files for the individual plugins that have state
04:54:38 <int-e> (and the format depends on the plugin.)
05:04:51 <ToRA> ?paste
05:04:52 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:05:16 <cba> int-e: thanks
05:05:34 <vincenz> what's the word ...
05:08:35 <hpaste>  ToRA pasted "little ghci q" at http://hpaste.org/1372
05:13:52 <junyer> hmm
05:14:09 <junyer> thanks for all your suggestions, folks
05:14:20 <junyer> much reading material to be.. well, read, i guess
05:14:50 <ToRA> any ghci experts know how to keep a module set in context between :reloads ?
05:17:20 <int-e> ToRA: hmm. an idea:  :def r \_ -> return ":m <your list of modules>"
05:17:57 <ToRA> yeah, i just discovered how :def works
05:18:06 <ToRA> it feels a bit round-the-houses though
05:20:16 <chessguy> ?hoogle RWST
05:20:16 <lambdabot> Control.Monad.RWS.RWST :: (r -> s -> m (a, s, w)) -> RWST r w s m a
05:20:17 <lambdabot> Control.Monad.RWS.RWST :: newtype RWST r w s m a
05:20:17 <lambdabot> Control.Monad.RWS.evalRWST :: Monad m => RWST r w s m a -> r -> s -> m (a, w)
05:21:38 <ToRA> wow, didn't realise RWST was in the libraries
05:21:38 <chessguy> RWST is Reader-Writer-State Transformer?
05:24:11 <chessguy> ?source Control.Monad.RWS.Lazy
05:24:12 <lambdabot> Control.Monad.RWS.Lazy not available
05:29:10 <chessguy> hm. i'll be back
05:30:00 <vincenz[flow]> ADEpt: #oasis
05:36:04 <balodja> does haskell perform any convertion in getLine and pusStrLn?
05:36:21 <balodja> character set convertion, i mean
05:36:38 <opqdonut> isn't haskell utf-8 all the way?
05:36:51 <int-e> no conversion is done
05:36:53 <earthy> uhm, no. ;)
05:37:06 <earthy> haskell's strings are unicode strings
05:37:16 <int-e> (hmm. I guess newline conversion is done on Windows)
05:37:22 <earthy> however, there is no specification as to how those strings interface
05:37:35 <earthy> so, *internally* they're unicode
05:38:10 <earthy> externally... depends on the compiler, really.
05:39:16 <int-e> oh. right. I was assuming ghc.
05:39:36 <balodja> i mean. consider, that you have not-utf8 locale. and you use getLine, how does ghc(for example) convert [Char8] to String?
05:40:55 <earthy> it doesn't, afaik
05:41:14 <earthy> you simply get 'wrong' code points. :)
05:41:32 <earthy> which is just fine, if you output the exact same string again and parse it in the same local
05:41:36 <earthy> +e
05:41:55 <balodja> that's awful. and are there any IO actions that return apropriate type of string?
05:42:23 <balodja> not String, but something more suitable in that situation
05:44:39 <earthy> there's a conversion lib, based upon Data.ByteString
05:46:43 <Igloo> dcoutts: Any idea why ppHsc2hs only takes certain ccOptions?
05:46:53 <Igloo> dcoutts: (in Cabal's Distribution.PreProcess)
05:47:50 <dcoutts> Igloo: because those are the cpp options, not general gcc options
05:48:12 <Igloo> dcoutts: But hsc2hs makes a C program and runs it, doesn't it?
05:48:13 <dcoutts> at least it's guessing that those are the cpp options
05:48:21 <dcoutts> yes
05:48:40 <Igloo> So surely it needs all the ccOptions and ldOptions?
05:49:20 <balodja> earthy: may i be sure that ghc will not strip non-utf8 byte sequencies while performing getLine?
05:50:05 <dcoutts> Igloo: looks like it tries to pass -D and -I flags directly, and others via --cflags
05:50:26 <dcoutts> Igloo: but I don't know why it doesn't pass all the remaining ccOptions via --cflags
05:50:32 <Igloo> dcoutts: But only those starting with -U get passed with --cflags AFAICS
05:50:35 <dcoutts> and yeah, it is missing the ldoptions
05:50:46 <dcoutts> Igloo: indeed, and I'm not sure why that is
05:50:46 <Igloo> OK, I'll just fix it and see what breaks then
05:51:25 <dcoutts> Igloo: probably either all the ccoptons should go via --cflag or they should be partitioned into -D*, -I* flags and all others
05:51:41 <dcoutts> and passed directly and via --cflag respectively
05:52:12 <dcoutts> Igloo: have fun, I'm off!
05:52:26 <Igloo> OK, see ya  :-)
05:52:33 <Igloo> And thanks for the info
05:58:52 <joelr1> @pl f a = fmap a dims
05:58:52 <lambdabot> f = flip fmap dims
06:02:45 <swiert> dcoutts, ndm: Thanks for the submissions!
06:16:57 <hpaste>  chessguy pasted "Obvious overkill, in this case but..." at http://hpaste.org/1373
06:17:16 <chessguy> would you say my rewrite of this code is more flexible? this is the way i've been tending to write my code
06:19:57 <Saizan> chessguy, shoudln't items be (Item i) => p -> [i] at this point?
06:20:11 <chessguy> ah, yes
06:20:13 <int-e> chessguy: hmm. as a downside you can't write  item { price = 20 }  anymore.
06:20:41 <chessguy> if item :: sItem ?
06:20:46 <chessguy> er, SItem
06:20:52 <int-e> yes
06:21:31 <chessguy> it would be item {sPrice = 20 }
06:21:57 <Saizan> you want also overloaded setters maybe? but depends on your usage pattern
06:22:05 <int-e> I'm not convinced your actual code will become more flexible.
06:22:18 <int-e> Saizan: probably. but that sounds unwieldy.
06:23:22 <chessguy> so i'm adding flexibility in the ability to rewrite the underlying representation of Item, but not really adding flexibility in the client code
06:24:36 <int-e> chessguy: as long as items are never created or modified, or pattern matched on.
06:24:54 <chessguy> hm?
06:25:23 <int-e> chessguy: the Item class only allows inspecting existing items.
06:26:42 <chessguy> i suppose you could also add sItem :: productName -> quantity -> SItem to the class
06:27:07 <int-e> chessguy: which means that to do anything else you either have to know the underlying representation or you have to extend the class.
06:27:10 <chessguy> err, more likel sItem :: String -> Item -> SItem
06:27:34 <chessguy> ugh
06:27:47 <int-e> you want a  -> i  at the end
06:27:48 <chessguy> sItem :: String -> Int -> SItem
06:27:55 <chessguy> yeah, whatever
06:27:58 <chessguy> yeesh
06:28:16 <araujo> morning
06:28:17 <chessguy> my brain isn't working
06:29:04 <ivanm> brain? you have a brain? you lucky, lucky bastard! (ala monty python)
06:36:27 <chessguy> ivanm: sometimes i'm not so sure i did
06:36:29 <chessguy> get one
06:36:40 <ivanm> lol
06:37:36 <chessguy> i'm going to stop talking now
06:40:20 <ivanm> you do that ;-)
06:53:54 <drigz> what's the best way to do something like: if c in ['B', 'H', 'R', 'U']?
06:54:05 <drigz> currently i use pattern matching, one line for each character
06:54:05 <Igloo> `elem`
06:54:11 <drigz> but it's not very concise
06:54:22 <drigz> Igloo: ah, thanks
06:54:26 <drigz> ?hoogle elem
06:54:27 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
06:54:27 <lambdabot> Array.elems :: Ix a => Array a b -> [b]
06:54:27 <lambdabot> List.elemIndex :: Eq => a -> [a] -> Maybe Int
07:07:39 <nominolo> > let f x | x `elem` "BHRU" = 1; f _ = 0 in map f ['A'..'Z']
07:07:40 <lambdabot>  [0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0]
07:07:49 <nominolo> drigz: ^^
07:17:46 <Botje> > map (fromEnum . (`elem`BHRU)) ['A'..'Z']
07:17:48 <lambdabot>   Not in scope: data constructor `BHRU'
07:17:52 <Botje> > map (fromEnum . (`elem`'BHRU')) ['A'..'Z']
07:17:53 <lambdabot>  Improperly terminated character constant
07:17:54 <Botje> bleh :)
07:17:59 <Botje> > map (fromEnum . (`elem`"BHRU")) ['A'..'Z']
07:18:00 <Botje> BLEH.
07:18:00 <lambdabot>  [0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0]
07:18:12 <fax> > fromEnum . (`elem`"BHRU")
07:18:13 <lambdabot>  <Char -> Int>
07:18:32 <fax> oic
07:22:57 * earthy laughs at http://bash.org/?747877
07:22:58 <lambdabot> Title: QDB: Quote #747877
07:23:07 <earthy> that's even more true for ghc! :)
07:25:39 <netsrot> Hi, is there any binding to ODE?
07:26:13 <Igloo> I haven't heard of one
07:26:41 <netsrot> ok, thanks anyhow.
07:34:46 <waern> someone did something like wxFruit for gtk2hs IIRC, does anyone know where to find that?
07:36:35 <chessguy_work> @go haskell wxfruit
07:36:37 <lambdabot> http://zoo.cs.yale.edu/classes/cs490/03-04b/bartholomew.robinson/
07:36:37 <lambdabot> Title: wxFruit
07:37:08 <chessguy_work> hm, that's the wxWidgets version
07:39:22 <waern> I found this: http://www.cs.uu.nl/wiki/Stc/GenuinelyFunctionalUserInterfaces
07:39:25 <lambdabot> Title: Stc / Genuinely Functional User Interfaces
07:40:22 <waern> someone is working on Fruit :)
07:50:40 <drigz> :t array
07:50:43 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
07:51:33 <drigz> ?hoogle (Ix i) => (i, i) -> (i -> e) -> Array i e
07:51:34 <lambdabot> No matches, try a more general search
07:51:44 <drigz> ?hoogle (Ix i) => (i -> e) -> (i, i) -> Array i e
07:51:45 <lambdabot> No matches, try a more general search
07:56:53 <ndm> @seen sorear
07:56:53 <lambdabot> I saw sorear leaving #haskell-blah, #darcs, #haskell-overflow, #ghc, #haskell and #happs 9h 36m 45s ago, and .
07:57:24 <ndm> @tell sorear i needed an instance for Ppr Body, so i've added one calling pprBody True - if that will break things then let me know!
07:57:24 <lambdabot> Consider it noted.
07:58:58 <eivuokko> Anyone know state of external core in ghc?  Is the output usable now or still broken?
08:06:12 <LeCamarade> Mais que c'est bien silent ici, dans #haskell ...
08:07:38 <LeCamarade> Okay, how would you write a split func? I wrote one I am just not happy with. It's in my hpaste dump.
08:08:00 <LeCamarade> I'm reading dons' paper on Yi.
08:08:07 <LeCamarade> Sounds bonne.
08:10:59 <Igloo> eivuokko: Still broken
08:11:07 <LeCamarade> 1~145|<311
08:11:26 <LeCamarade> 1~1 4 5 |< 3 1 1
08:11:59 <earthy> uhm, netsrot, you were asking for an ODE binding?http://www.haskell.org/haskellwiki/Libraries_and_tools/Mathematics has a link to http://darcs.haskell.org/~lemmih/hode/
08:12:02 <lambdabot> Title: Libraries and tools/Mathematics - HaskellWiki, http://tinyurl.com/hq4t3
08:13:03 <ndm> eivuokko: broken, but Tim and Aaron are hoping to have it fixed by the start of the summer
08:13:29 * ndm curses, Catch requires GHC Core to work on GHC_Haskell programs
08:22:39 <eivuokko> Thanks Igloo, ndm.
08:29:44 <jibe> hello, could anyone tell me if there is such a thing as fromDouble and toDouble somewhere in ghc?  thx
08:30:11 <Saizan> ?type fromFractinal
08:30:15 <Saizan> ?type fromFractional
08:30:15 <lambdabot> Not in scope: `fromFractinal'
08:30:18 <lambdabot> Not in scope: `fromFractional'
08:34:48 <Saizan> ?hoogle realToFrac
08:34:49 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => a -> b
08:34:56 <Igloo> There are to/fromRational, realToFrac, and floor, ceiling, truncate
08:36:15 <int-e> @type round
08:36:18 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
08:37:18 <glguy> jibe, what type are you trying to convert to a double?
08:37:50 <jibe> glguy: i've got to go both ways between float and double.
08:37:59 <jibe> to/fromRational seems to do it
08:38:03 <glguy> why are you using floats?
08:38:33 <Igloo> realToFrac is what you want for that
08:40:24 <jibe> glguy: it didn't seem a bad idea at the time  :-) (I am just starting haskell)
08:40:30 <jibe> Igloo: thank you
08:41:21 <glguy> jibe: if yo uare just learning, check out the Rational type also:
08:41:42 <glguy> > (4%5) + (7%13)
08:41:43 <lambdabot>  87%65
08:42:57 <Saizan> is there a Surreal module? :)
08:44:49 <jibe> thanks people.
08:54:04 <[vincenz]> Saizan: yes
08:54:07 <[vincenz]> > undefined + undefined
08:54:08 <lambdabot>  Undefined
08:54:12 <[vincenz]> > undefined + 1
08:54:14 <lambdabot>  Undefined
08:54:17 <[vincenz]> > undefined *2
08:54:18 <lambdabot>  Undefined
08:56:49 <chessguy_work> what is RWST ?
08:56:53 <roconnor> data Surreal = Surreal [Surreal] [Sureal]
08:56:58 <chessguy_work> is that a Reader Writer State transformer?
08:57:10 <glguy> chessguy_work: reader writer state transformer
08:57:26 <chessguy_work> interesting
08:57:30 <glguy> :k Control.Monad.RWS.RWST
08:57:32 <opqdonut> data Surreal = Onion
08:57:32 <fasta> > undefined
08:57:32 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
08:57:34 <lambdabot>  Undefined
08:57:41 <roconnor> it takes a monad and adds reader, writer, and state abilities
08:57:51 <chessguy_work> is the source code available somewhere? i can't find it in the libraries
08:58:05 <glguy> ?fptools Control.Monad.RWS
08:58:06 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/RWS.hs
08:58:20 <chessguy_work> not very useful :)
08:58:35 <glguy> Well, you have to use your eyes
08:58:40 <glguy> see that it imports Lazy
08:58:42 <glguy> and then open that
08:58:48 <chessguy_work> but i can't find Lazy
08:58:55 <glguy> http://darcs.haskell.org/packages/mtl/Control/Monad/RWS/Lazy.hs
08:58:58 <chessguy_work> ?fptools Control.Monad.RWS.Lazy
08:58:59 <lambdabot> Control.Monad.RWS.Lazy not available
08:59:02 * glguy holds chessguy's hand ;)
08:59:16 <chessguy_work> i'm tellin' your fiance
08:59:17 <chessguy_work> e
08:59:24 <chessguy_work> '
08:59:55 <chessguy_work> that's not in the main tree of the libraries
09:01:16 <chessguy_work> so why would you want Reader, Writer, and State?
09:01:24 <chessguy_work> i mean, State can be read and written
09:01:47 <Saizan> Writer works very differently from a written State
09:02:09 <balodja> @src ($!)
09:02:09 <lambdabot> Source not found. Do you think like you type?
09:02:14 <roconnor> writer makes a log doesn't it?
09:02:36 <roconnor> so you just go tell, tell, tell, and it keeps on appending to some monoid.
09:03:14 <roconnor> chessguy_work: I used a reader-writer-state in my TMR article
09:03:28 <Saizan> yeah, with State you'd have to modify . mappend
09:03:29 <roconnor> When making my assembler
09:03:44 <roconnor> I used the state to keep track of the instruction count
09:03:44 <thedward> > unwords $ map  (((arr (toUpper . head)) &&& tail) >>> arr (uncurry (:))) (words "hello, world")
09:03:46 <lambdabot>  "Hello, World"
09:03:51 <balodja> @t ($!)
09:03:52 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
09:03:58 <roconnor> I used writer to output (label,instruction number) pairs
09:04:12 <balodja> @type ($!)
09:04:12 <Saizan> @type ($!)
09:04:14 <lambdabot> forall a b. (a -> b) -> a -> b
09:04:16 <lambdabot> forall a b. (a -> b) -> a -> b
09:04:16 <psnl> baruch: /win 22
09:04:20 <balodja> @type ($)
09:04:22 <lambdabot> forall a b. (a -> b) -> a -> b
09:04:29 <balodja> what's the difference?
09:04:34 <roconnor> and I used reader to get a lookup table of label -> instruction numbers.
09:04:41 <Saizan> $! is strict in the value
09:05:03 <Saizan> f $! a = a `seq` f a
09:05:04 <roconnor> > const 5 $ undefined
09:05:06 <lambdabot>  5
09:05:09 <roconnor> > const 5 $! undefined
09:05:11 <lambdabot>  Undefined
09:05:23 <balodja> Saizan: thanks
09:07:08 <chessguy_work> roconnor: so...why
09:07:17 <chessguy_work> why not just put everything in the state?
09:07:37 <roconnor> chessguy_work: so I don't accidently write over the reader part.
09:07:54 <roconnor> and so I don't accidently mess up the writer part
09:08:37 <chessguy_work> ok, so it's kind of like the different protection levels in classes in OO
09:09:07 <roconnor> yeah, a reader is kinda like a final variable. ... I guess
09:12:21 <chessguy_work> interesting
09:12:50 <roconnor> (secrectly the reader variable is the writer variable)
09:13:12 <roconnor> but to understand that, you will have to read my article :)
09:13:42 <Cheery> What is depedently typed lambda calculus?
09:14:37 <roconnor> Cheery: it has functions from objects to types.
09:14:54 <roconnor> like vector : nat -> Type -- lists of length n
09:15:11 <Cheery> roconnor: what does it mean in practise?
09:15:34 <roconnor> Cheery: you can have more specific types ... such as lists of length n.
09:16:06 <roconnor> when n is a run-type parameter
09:16:06 <Cheery> that's neat
09:16:20 <roconnor> template haskell gives you a bit of that, but only at compile time.
09:16:31 <Cheery> is there flaws of some sort on it?
09:16:37 <Cheery> why haskell does not use it?
09:16:58 <roconnor> Cheery: type checking becomes undecidable if your language is Turing complete.
09:17:24 <roconnor> The typical solution is to disallow general recursion.
09:17:33 <Saizan> undecidable for some corner case or commonly?
09:18:23 <roconnor> Hmmm
09:18:37 <roconnor> Probably about as common as programs that loop forever.
09:18:53 <roconnor> Most programs are not supposed to do that.
09:19:03 <roconnor> But it is easy to accidently make a program do that
09:19:22 <roconnor> So your compiler will loop forever if you make a certain kind of mistake
09:19:27 <roconnor> ... at least that is what I would guess.
09:19:36 <Saizan> not very nice..
09:19:40 * roconnor wonders if the problem is more severe than that.
09:20:25 <Cheery> so type system gets so powerful that you can make loops..
09:20:31 <sieni> what about event loops?
09:21:00 <Saizan> well you can already make loops, but they are catched
09:21:05 <Saizan> > \x -> x x
09:21:06 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
09:21:07 <lambdabot>     Probab...
09:22:30 <chessguy_work> wait, so haskell isn't turing complete?
09:22:36 <roconnor> yes it is
09:22:46 <roconnor> haskell doesn't have dependent types
09:22:47 <chessguy_work> <roconnor> Cheery: type checking becomes undecidable if your language is Turing complete.
09:23:09 <Saizan> "assuming it has dependent types"
09:23:15 <chessguy_work> ah
09:23:42 <roconnor> I do a lot of programming in a dependently typed langauge. It's my job :)
09:23:52 <Saizan> which one?
09:23:53 <ndm> @pl foldr1With q = foldr1 (with q)
09:23:54 <lambdabot> foldr1With = foldr1 . with
09:23:58 <roconnor> Coq
09:24:09 <Saizan> oh
09:24:24 <mattam> Templates as in C++ make type-checking undecidable too IIRC
09:24:44 <DRMacIver> Nothing wrong with undecideable type checking. :)
09:24:44 <ndm> @pl with q x y = AppE (AppE f x) y
09:24:45 <lambdabot> with = const (AppE . AppE f)
09:24:55 <ndm> @pl with q x y = AppE (AppE q x) y
09:24:56 <lambdabot> with = (AppE .) . AppE
09:25:01 <roconnor> mattam: I guess that goes to show that having undecidable type checking may not be so bad.
09:25:12 * mattam just proved quicksort in Coq :)
09:25:28 <mattam> Now that's your opinion :)
09:25:29 <roconnor> mattam: congrats \o/
09:25:45 <roconnor> you have passed level 5
09:26:04 <Cheery> has anyone thought about trying to derive type-system -kind from pure lambda calculus?
09:26:06 <mattam> Now i've learned that working with decidable equality/comparisons is a pita.
09:26:33 <roconnor> Cheery: what do you mean?
09:26:57 <Cheery> I've understood the current simply typed lambda calculus comes from set theory, but have you tried to implement the type system on pure lambda calculus?
09:27:46 <roconnor> I don't think I would say that the simply typed lambda calculus comes from set theory.
09:27:48 <mattam> You mean without typing the types ?
09:27:57 <chessguy_work> ?src evalStateT
09:27:58 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
09:28:05 <Cheery> mattam: yes, all being lambdas
09:28:12 <roconnor> by pure lambda calculus you mean the untyped lambda calculus?
09:28:12 <chessguy_work> evalStateT :: (Monad m) => StateT s m a -> s -> m a
09:28:12 <chessguy_work> evalStateT m s = do
09:28:12 <chessguy_work>     ~(a, _) <- runStateT m s
09:28:12 <chessguy_work>     return a
09:28:19 <chessguy_work> why is the ~ needed t here?
09:28:34 <chessguy_work> i've never understood irrefutable patterns
09:28:44 <roconnor> chessguy_work: It isn't need there.  I just added it for emphasis.
09:28:57 <roconnor> oh wait
09:28:57 <syntaxfree> Common Lisp has an Eq instance for functions, so to speak. How do they do that?
09:28:59 <Cheery> roconnor: yes, untyped lambda calculus I mean
09:29:00 <monochrom> down with national borders! down with national character encodings!
09:29:00 <roconnor> nevermind
09:29:03 <chessguy_work> lol
09:29:10 <chessguy_work> this is in http://darcs.haskell.org/packages/mtl/Control/Monad/State/Lazy.hs
09:29:11 <roconnor> chessguy_work: I thought that was my code.
09:29:38 <chessguy_work> i was going to say, wow, you wrote the State and StateT code!
09:29:54 <shoffsta> is it possible to specify default values for the database columns in HaskellDB?
09:29:56 <roconnor> Sorry, i use a ~ in my article.
09:29:58 <shoffsta> does anybody know?
09:30:17 <roconnor> chessguy_work: that is presumably going to be important to make the state lazy.
09:30:56 <chessguy_work> ah, so irrefutable patterns have to do with strictness?
09:31:10 <Cheery> roconnor: so... do you know anyone who would have tried to implement type system or type system -like stuff on untyped lambda calculus?
09:31:29 <mattam> Cheery: generally the types and terms are intermingled in dependent type theories, so having untyped types would also mean having untyped terms somehow
09:31:48 <monochrom> > case undefined of 0 -> "whee"
09:31:50 <lambdabot>  Undefined
09:31:51 <roconnor> Cheery: well, I've seen it implemented in the typed lambda calculus. ... presumable it is mechanical to translate.
09:31:54 <monochrom> > case undefined of ~0 -> "whee"
09:31:56 <lambdabot>  "whee"
09:31:59 <mattam> simply-typed lambda calculs is one such attempt Cheery
09:32:12 <chessguy_work> wtf
09:32:26 <chessguy_work> monochrom: that doesn't even make sense
09:32:27 <chessguy_work> to me
09:32:29 <monochrom> hee hee hee!
09:32:43 <monochrom> I replace the pattern "0" with the pattern "~0"
09:33:57 <roconnor> monochrom: single patterns with no bound variables should always be lazy ;)
09:34:11 <monochrom> How about this?  You already know Just and Nothing.
09:34:24 <monochrom> > case undefined of Just x -> "whee"
09:34:26 <lambdabot>  Undefined
09:34:34 <monochrom> > case undefined of ~(Just x) -> "whee"
09:34:36 <lambdabot>  "whee"
09:35:28 <roconnor> > case undefined of ~(Just x) -> "whee"++x
09:35:30 <lambdabot>  Undefined
09:35:37 <chessguy_work> but why should undefined ever match Just x
09:35:46 <monochrom> If you replace "whee" by some code that really uses x, both programs diverge.  But if you don't use x, ~ saves you an evaluation.
09:35:49 <roconnor> > take 4 $ case undefined of ~(Just x) -> "whee"++x
09:35:50 <lambdabot>  Undefined
09:35:52 <Saizan> > case Nothing of ~(Just x) -> "whee"++x
09:35:54 <lambdabot>   Irrefutable pattern failed for pattern (Data.Maybe.Just x)
09:36:02 <Saizan> > case Nothing of ~(Just x) -> "whee"
09:36:04 <lambdabot>  "whee"
09:36:22 <monochrom> "undefined" is my short hand for "an expression that takes forever"
09:36:27 <roconnor> > take 4 $ case undefined of ~(Just x) -> const "whee" x
09:36:28 <Saizan> chessguy_work, because the value is not really inspected until someone asks for a binded variable
09:36:28 <lambdabot>  "whee"
09:36:35 <roconnor> > case undefined of ~(Just x) -> const "whee" x
09:36:37 <lambdabot>  "whee"
09:36:38 <chessguy_work> oh!
09:36:50 <chessguy_work> so that pattern will always be match
09:36:51 <chessguy_work> ed
09:37:00 <Saizan> "irrefutable"
09:37:00 <chessguy_work> thus the "irrefutable"
09:37:12 <monochrom> irrefusible
09:37:37 <chessguy_work> so in the code i pasted, it just makes sure it's lazy
09:37:46 <monochrom> "She offered herself to me. It was an irrefusible offer. I much regret it now."
09:38:16 <monochrom> That's the confession of case undefined of ~(Just x) -> "whee"++x
09:38:28 <Saizan> :D
09:40:00 * monochrom loves "teaching haskell by cultural shock"
09:40:13 <roconnor> @src (++)
09:40:14 <lambdabot> (++) []     ys = ys
09:40:14 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
09:44:29 <chessguy_work> wow
09:44:34 <chessguy_work> this stuff is really cool
09:45:31 <chessguy_work> @instances-importing MonadState
09:45:33 <lambdabot> s (ContT r m), s (ErrorT e m), s (RWS r w s), s (RWST r w s m), s (ReaderT r m), s (State s), s (StateT s m), s (WriterT w m)
09:49:03 <chessguy_work> @quote state
09:49:04 <lambdabot> state says:  ?. ++ . read . show . state ?. ++ . read . show . state
09:49:10 <inono> why arent any of these examples working in hugs!!!
09:49:16 <inono> inc n = n + 1 << syntax error. wtf
09:49:27 <xerox> let inc n = n + 1 in inc 4
09:49:38 <inono> oh
09:49:41 <inono> how do i make it remember inc across lineS?
09:49:42 <ndm> xerox: not in hugs
09:49:46 <xerox> in GHCi you can write "let inc n = n+1" and have it added to the environment
09:49:50 <xerox> but you can't in hugs
09:49:51 <ndm> xerox: woops, i missed the =
09:49:58 <ndm> inono: write stuff in a file, load the file
09:50:07 <inono> where do i get this ghci?
09:50:14 <xerox> ?where ghc
09:50:15 <lambdabot> http://haskell.org/ghc
09:50:19 <xerox> there you go!
09:50:38 * monochrom hugs hugs
09:50:44 * monochrom ghci ghci
09:51:36 <inono> wow ghc6 is huge
09:51:43 <inono> im going to get coffe now.. lol..
09:51:46 <inono> thanks guys!
09:51:46 <xerox> megabytes of fun
09:51:53 <xerox> you're welcome
09:58:51 <Cheery> @google untyped lambda calculus implementation in haskell
09:58:54 <lambdabot> http://okmij.org/ftp/Computation/lambda-calc.html
09:58:55 <lambdabot> Title: Lambda Calculus and Lambda Calculators
09:59:26 <Cheery> I'd need a ready-made toy to play with
09:59:58 <Cheery> something with a ghci-like interpreter and source code format similar to haskell, possibly
10:00:22 <Cheery> kind of experimental language, requirement that it'd be easy to modify
10:00:24 <fax> Cheery: erm
10:00:25 <fax> lisp?
10:00:32 <fax> scheme
10:00:46 <Cheery> untyped lambda calculus thing
10:01:05 <fax> unlambda?
10:01:24 <medfly> im new to haskell. can i somehow use if x not equal to something?
10:01:27 <medfly> if so how? :)
10:01:37 <kpreid> > 1 /= 2
10:01:39 <lambdabot>  True
10:01:57 <Cheery> fax: yes, but with haskell-like syntax and interpreter
10:02:05 <fax> why?
10:02:12 <fax> if its not haskell why haskel like syntax? :S
10:02:21 <medfly> oh, cool
10:02:23 <medfly> thanks
10:02:23 <LeCamarade> let x = 10 in if x /= 11 then "Not ten!" else "ten!!!
10:02:33 <kpreid> > 1 â‰  2
10:02:34 <lambdabot>  Illegal character ''\137''
10:02:40 <LeCamarade> >let x= 10 in if x /= 11 then "Not ten!" else "ten!!!"
10:02:41 <xerox> http://www.dreamnation.fsnet.co.uk/supp2.html#monad
10:02:42 <fax> â‰ _â‰ 
10:02:43 <lambdabot> Title: Supporting Cast
10:02:44 <xerox> "The spirits did not die however. They flared up into the atmosphere to form a vast intelligence, a huge mind cloud of electro-magnetic energy, an evil intelligence, twisted by the pain of purification. It was the quintessence of human evil. The Monad."
10:02:46 <Cheery> fax: because haskell has a type system and I want to play without a type system
10:03:00 <fax> Cheery: so why does it have to be haskell like?
10:03:44 <emu> on a side note, you could probably cook up an untyped lambda calculus interpreter with whatever syntax you wanted, in about an hour, in haskell
10:04:23 <Cheery> fax: well, it's also good if it'd be just well-done
10:05:16 <Cheery> emu: yeh, but I were thinking whether I could've used that about-a-minute to add a single tiny thing in and then play around with it
10:07:43 <[vincenz]> @seen ski
10:07:44 <lambdabot> ski is in #haskell-blah and #haskell. I don't know when ski last spoke.
10:08:48 <Cheery> is there singularity around today?
10:09:11 <Cheery> got just damn much good stuff in one moment today :)
10:30:30 <syntaxfree> common lisp is oddly underwhelming at times.
10:30:43 <syntaxfree> Paul Graham in "On Lisp" makes such a fuss of this function called "complement".
10:30:48 <syntaxfree> Complement is just (not .)
10:30:54 <chessguy_work> lol
10:31:00 <thetallguy> Cheery: you might look at Q
10:31:11 <thetallguy> http://q-lang.sourceforge.net/qdoc/qdoc.html#Top
10:31:12 <lambdabot> Title: The Q Programming Language: Top
10:31:14 <chessguy_work> @type just (not .)
10:31:18 <lambdabot> Not in scope: `just'
10:31:26 <syntaxfree> :t (not .)
10:31:29 <lambdabot> forall a. (a -> Bool) -> a -> Bool
10:31:43 <chessguy_work> syntaxfree: i was 'just' kidding
10:31:48 <syntaxfree> hahahah
10:31:53 <syntaxfree> :t Just (not .)
10:31:55 <lambdabot> forall a. Maybe ((a -> Bool) -> a -> Bool)
10:32:03 <syntaxfree> :t Just . (not .)
10:32:05 <lambdabot> forall a. (a -> Bool) -> Maybe (a -> Bool)
10:33:48 <syntaxfree> otoh, there's nothing in Haskell like defnode.
10:38:27 <tibbe_> @seen dons
10:38:28 <lambdabot> dons is in #haskell-soc, #haskell-overflow and #haskell. I last heard dons speak 6h 25m 42s ago.
10:39:08 <inono> hey guys, how do I get the types of things to show up when i'm using hgci?
10:39:19 <tibbe_> @msg dons it's a bit unintuitive to enter an email into mkcabal, almost everything leads to a "no parse"
10:39:19 <lambdabot> Not enough privileges
10:39:23 <tibbe_> gah!
10:39:40 <twanvl> :t 1+1
10:39:43 <lambdabot> forall t. (Num t) => t
10:40:16 <inono> precede it with :t I take it?
10:40:22 <twanvl> yes
10:40:34 <inono> interesting, another type printing i have to get used to
10:40:50 <inono> is there any guide to haskell for ocaml users?
10:41:31 <xerox> inono, maybe you will like the gentle introduction
10:42:00 <inono> sure as long as it doesnt treat me like a baby whose never done functional programming before :-)
10:42:16 <xerox> no it should not
10:42:22 <inono> great
10:43:33 <inono> hmm, haskell does automatic type coercion?
10:44:12 <tibbe> @msg dons it's a bit unintuitive to enter an email into mkcabal, almost everything leads to a "no parse"
10:44:13 <lambdabot> Not enough privileges
10:44:33 <tibbe> why can't I send messages?
10:44:47 <inono> how do i view the types the gentle introduction is talking about?
10:44:57 <stepcut> tibbe: you have to register with NickServ?
10:45:05 <inono> i put in :t inc but I get inc :: (Num a) => a -> a ... instead of Integer -> Integer
10:45:32 <emu> inono: it's more general
10:45:54 <emu> since Integer is an instance of Num, you can take "Integer" and substitute it for "a"
10:46:20 <inono> what does the (Num a) part mean
10:46:30 <emu> it means that a is an instance of Num
10:46:36 <inono> oh
10:46:47 <emu> read it as: IF a is an instance of Num, THEN the type is a -> a
10:47:34 <inono> so Num is like a base type for fractional and integer?
10:47:45 <emu> I wouldn't call it a base type
10:47:48 <emu> it's a class of types
10:48:00 <emu> that class includes Integer, Float ..
10:48:04 <inono> like
10:48:15 <emu> @instances Num
10:48:15 <inono> data Num = Integer | Float | ... ?
10:48:16 <lambdabot> Double, Float, Int, Integer
10:48:16 <tibbe> stepcut, yup, registered
10:48:53 <emu> inono: i'm afraid that analogy may cause further confusion
10:48:58 <doserj> @src Num
10:48:58 <lambdabot> class  (Eq a, Show a) => Num a  where
10:48:59 <lambdabot>     (+), (-), (*)           :: a -> a -> a
10:48:59 <lambdabot>     negate, abs, signum     :: a -> a
10:48:59 <lambdabot>     fromInteger             :: Integer -> a
10:49:11 <arjanb> inono: no it's more like aa interface in some other languages
10:49:20 <inono> oh all right
10:49:39 <inono> intereseting, i can do math by mixing ints and floats :_)
10:49:49 <emu> > 1 + 1.0
10:49:52 <lambdabot>  2.0
10:50:07 <emu> that works because haskell defines numeric literals to be things like: (fromIntegral 1) whenever you see 1
10:50:14 <emu> :t fromIntegral
10:50:16 <lambdabot> forall a b. (Num b, Integral a) => a -> b
10:50:43 <emu> :t fromInteger
10:50:46 <lambdabot> forall a. (Num a) => Integer -> a
10:51:50 <inono> neat
10:52:08 <inono> any reason why it doesnt just display Num -> Num instead of (Num a) => a -> a?
10:52:15 <emu> because Num is not a type
10:52:21 <emu> it's a class of types
10:52:26 <inono> ah
10:53:00 <[vincenz]> emu: or colloquially said, a typeclass :)
10:53:15 <emu> sometimes the significance of the name doesn't quite get across =)
10:54:22 <twanvl> If only we could have contexts on type synonyms: type Num a = Num a => a, then we could really confuse people :)
10:54:31 <inono> haha, a string is a [Char] ? nice
10:54:35 <xerox> inono, a type class is a set of types. Instantiating a type in a class means making the type an element of the set.
10:54:36 <emu> yep
10:55:03 <inono> i take it its immutable then
10:55:32 <emu> this is a pure functional language after all
10:55:42 <xerox> inono, the last bit: the syntax identifier :: type may be extended to identifier :: (constraints) => type where constraints are things like "Num a" which you can read as "a \in Num".
10:56:07 <mux> any idea why defining an 'instance MonadState (GenParser tok st) where ...' would give me a kind error?
10:56:08 <inono> sweet, haskell has pattern matching too :_)
10:56:11 <xerox> There, `a' is a type variable.
10:56:17 <mux>     `GenParser tok st' is not applied to enough type arguments
10:56:17 <mux>     Expected kind `*', but `GenParser tok st' has kind `* -> *'
10:56:17 <mux>     In the instance declaration for `MS.MonadState (GenParser tok st)'
10:56:47 <twanvl> instance MonadState st (GenParser tok st)?
10:56:57 <twanvl> MonadState has two arguments
10:57:23 <mux> oh
10:57:47 <mux> that sounds weird, I think I saw 'instance MonadState (State s) ..' ?
10:58:00 <hpaste>  plediii pasted "is this the only way to make func2 point-free ?" at http://hpaste.org/1374
10:58:52 <DRMacIver> Hm
10:58:54 <DRMacIver> @src curry
10:58:55 <lambdabot> curry f x y = f (x, y)
10:58:59 <doserj> @pl \ f g l -> filter f (map g l)
10:58:59 <lambdabot> (. map) . (.) . filter
10:59:02 <mux> twanvl: well, thanks anyways
10:59:19 <plediii> yikes
10:59:50 <DRMacIver> I swear pointfree style exists so that perl refugees will feel at home.
11:00:18 <dmwit> I think it increases readability in *some* cases.
11:00:22 <plediii> I don't think it's more readable, just doing it as an exercise.
11:00:31 <plediii> In that case.
11:00:37 <DRMacIver> dmwit: Yeah, I know. I don't really dislike it. :)
11:00:49 <DRMacIver> dmwit: It's just that in a lot of cases it's a way of producing *really* unreadable code.
11:01:03 <inono> is (5,6) a tuple?
11:01:09 <DRMacIver> Yes.
11:01:36 <inono> how are you supposed to define a custom type in ghci?
11:01:59 <dmwit> With the data keyword (or, often, even just the type keyword).
11:02:18 <inono> parse error on data?
11:02:21 <twanvl> You can't do that from the interactive prompt, you need a source file for that
11:02:23 <doserj> inono: you load a file
11:03:50 <inono> now if i could only figure out how to load a file into ghci
11:04:02 <Saizan> :load file.hs
11:04:26 <mux> @where mtl
11:04:26 <lambdabot> www.cs.brown.edu/~jwicks/mtl_reference/
11:04:27 <doserj> :help might help...
11:05:07 <inono> cool
11:05:55 <Saizan> roconnor, in your TMR article, T is just a mark for where the temp registers begin?
11:06:35 <inono> wow... you can curry type constructors?!
11:07:01 <doserj> you mean data constructors?
11:07:05 <inono> err, yea?
11:07:25 <Saizan> ?type curry (:)
11:07:28 <lambdabot> forall a b. a -> b -> [(a, b)] -> [(a, b)]
11:07:39 <doserj> data constructors are ordinary functions
11:07:44 <inono> interesting
11:07:48 <doserj> the only difference is that you can pattern match on them
11:08:06 <dmwit> ?type uncurry (:)
11:08:08 <lambdabot> forall a. (a, [a]) -> [a]
11:08:28 <[vincenz]> @type rice `and` curry
11:08:31 <lambdabot> Not in scope: `rice'
11:08:36 <roconnor> Saizan: correct
11:08:48 <chessguy_work> @type ?rice `and` curry
11:08:51 <lambdabot>     Couldn't match expected type `(((a, b) -> c) -> a -> b -> c) -> t'
11:08:52 <lambdabot>            against inferred type `Bool'
11:09:26 <doserj> @type and
11:09:28 <lambdabot> [Bool] -> Bool
11:10:18 <Saizan> roconnor, nice article btw, this "tying the knot" was quite scaring the other times that i've seen it
11:10:44 <dmwit> ?pl \blargle -> ing blargle out
11:10:45 <lambdabot> flip ing out
11:11:01 <dmwit> hehe
11:11:07 <monochrom> haha
11:11:20 <xerox> hehe
11:11:26 <hpaste>  mux pasted "MonadState for Parsec" at http://hpaste.org/1376
11:11:36 <mux> any comments on that?
11:11:47 <mux> the problem is that it adds a dependency on mtl from Parsec
11:12:08 <titus> @pl (\gs -> elem 2 gs && elem 3 gs)
11:12:09 <lambdabot> ap ((&&) . elem 2) (elem 3)
11:12:27 <monochrom> Hmm, dependency is not nice.
11:12:47 <dmwit> all (`elem` gs) [2,3]
11:12:52 <monochrom> Then again, there is no way mtl depends back on parsec, so ok!
11:13:00 <dmwit> Mine is shorter! =)
11:13:25 <roconnor> Saizan: It worked very nicely for my task, and the mdo was even better.
11:13:31 <dmwit> o, but mine is wrong.
11:13:31 <monochrom> mtl and arrow are things close to the ground level.  should be ok for higher-level packages to depend on them.
11:13:35 <roconnor> Unfortunatly I'm not sure how well it scales up
11:13:39 <mux> monochrom: what I'm thinking is that since people are supposed to work on ParsecT for SoC, it'll end up depending on mtl too I guess
11:13:52 <roconnor> But it was good enough for me to make some simple code.
11:14:02 <dmwit> ?pl \gs -> all (`elem` gs) [2,3]
11:14:03 <lambdabot> flip all [2, 3] . flip elem
11:14:06 <roconnor> For the ICFP we wrote a COMMAND.UMZ shell
11:14:43 <titus> what's `ap'?
11:14:56 <roconnor> @type ap
11:14:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
11:15:10 <dmwit> titus: It applies a function held inside a monad to data held inside a monad.
11:15:14 <mux> monadic function application
11:15:18 <monochrom> mtl is like plumbing and sewage.  "I'm a factory owner, and I'm upgrading my factory but the upgrade requires tapping into the city's water pipes and sewage."  Go right ahead!
11:15:27 <mux> monochrom: *nods*
11:15:33 <dmwit> titus: Above, it was probably using the (-> r) monad.
11:16:02 <titus> dmwit: is that in Control.Monad?
11:16:11 <mux> monochrom: the "bad" thing is that I consider the "real" fix to be to have the Parsec monad use StateT
11:16:12 <dmwit> ?index ap
11:16:12 <xerox> dmwit, it's ((->) r) or (r ->)
11:16:13 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
11:16:13 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
11:16:23 <dmwit> xerox: Ah, okay.
11:16:27 <mux> monochrom: it makes things nicer if it's in the MonadState class, but there is still wasted code imo
11:16:32 <titus> jeez, I need some lambdabot-fu
11:16:54 <mux> monochrom: what do you think?
11:17:23 <chessguy_work> syntaxfree: how do you like 'On Lisp', overall?
11:17:44 <monochrom> Parsec could use StateT, but there are delicate strictness issues to pay attention to.
11:18:51 <monochrom> Right now Parsec puts a bang on its state (and also user state), and I actually like it that way.
11:19:08 <hpaste>  mux annotated "MonadState for Parsec" with "with a better import" at http://hpaste.org/1376#a1
11:19:28 <mux> monochrom: okay.
11:19:51 <mux> I'll darcs record this and send to libraries@ etc
11:22:49 <titus> @pl (\cs -> length cs == 5 || null cs)
11:22:50 <lambdabot> ap ((||) . (5 ==) . length) null
11:24:02 <DRMacIver> @pl (x, y, z) -> (z, x, y)
11:24:03 <lambdabot> (line 1, column 11):
11:24:03 <lambdabot> unexpected ">" or "-"
11:24:03 <lambdabot> expecting variable, "(", operator or end of input
11:24:08 <DRMacIver> oops
11:25:26 <DRMacIver> Ah, right.
11:25:29 <DRMacIver> @pl \(x, y, z) -> (z, x, y)
11:25:30 <lambdabot> (line 1, column 7):
11:25:30 <lambdabot> unexpected ","
11:25:30 <lambdabot> expecting letter or digit, operator or ")"
11:25:30 <lambdabot> ambiguous use of a non associative operator
11:25:39 <DRMacIver> Sigh. :)
11:25:49 * DRMacIver still hasn't quite got the hang of the basic syntax
11:26:17 <doserj> thats a bug in @pl ...
11:26:22 <DRMacIver> Ah
11:26:27 <DRMacIver> That makes me feel better. :)
11:29:05 <xerox> @pl f (x,(y,z)) = (z,(x,y))
11:29:06 <lambdabot> f = uncurry ((`ap` snd) . (. fst) . (flip (,) .) . (,))
11:29:21 <chessguy_work> @pl \ x y z -> (z,x,y)
11:29:21 <lambdabot> flip . flip (,,)
11:30:20 <drigz> > let split p = filter (not.p.head) . group in split (==',') "a,bc,def"
11:30:22 <lambdabot>  ["a","b","c","d","e","f"]
11:30:42 <drigz> > let split p = filter (not.p.head) . group p in split (==',') "a,bc,def"
11:30:44 <lambdabot>  Couldn't match expected type `[a]'
11:32:37 <drigz> ?pl \a b -> (f a) == (f b)
11:32:38 <lambdabot> (. f) . (==) . f
11:33:00 <dmwit> > let split p = let (b, e) = break (==',') in b:split e in split "a,bc,def"
11:33:01 <lambdabot>  Couldn't match expected type `(t, t1)'
11:33:23 <dmwit> > let split [] = []; split p = let (b, e) = break (==',') in b:split e in split "a,bc,def"
11:33:24 <lambdabot>  Couldn't match expected type `(t, t1)'
11:33:30 <drigz> > let split p = filter (not.p.head) . groupBy (\a b -> (p a) == (p b)) in split (==',') "a,bc,def"
11:33:31 <lambdabot>  ["a","bc","def"]
11:34:05 <drigz> i wish there was a groupWith :(
11:34:09 <doserj> another case for `on`
11:34:29 <dmwit> > groupBy (\x y -> y == ',') "a,bc,def"
11:34:31 <lambdabot>  ["a,","b","c,","d","e","f"]
11:34:43 <dmwit> > groupBy (\x y -> y /= ',') "a,bc,def"
11:34:45 <lambdabot>  ["a",",bc",",def"]
11:35:16 <tibbe> @seen dons
11:35:17 <lambdabot> dons is in #haskell-soc, #haskell-overflow and #haskell. I last heard dons speak 7h 22m 31s ago.
11:36:51 <drigz> doserj: `on`?
11:37:26 <doserj> on f g x y = f (g x) (g y)
11:37:56 <doserj> then you can use "groupBy ((==) `on` p)"
11:38:26 <drigz> could it become part of GHC any time soon?
11:38:41 <doserj> I think it is in 6.7
11:38:50 <drigz> cool
11:39:53 <dmwit> > let maplast f [] = []; maplast f (x:xs) = x:map f xs in maplast tail $ groupBy (\_ y -> y /= ',') "a,bc,def"
11:39:55 <lambdabot>  ["a","bc","def"]
11:40:18 <dmwit> > let maplast f [] = []; maplast f (x:xs) = x:map f xs in maplast tail $ groupBy (\_ y -> y /= ',') "abcdef"
11:40:20 <lambdabot>  ["abcdef"]
11:40:26 <dmwit> ?src words
11:40:27 <lambdabot> words s = case dropWhile isSpace s of
11:40:27 <lambdabot>     "" -> []
11:40:27 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
11:40:35 <dmwit> > let maplast f [] = []; maplast f (x:xs) = x:map f xs in maplast tail $ groupBy (\_ y -> y /= ',') "abc,,def"
11:40:37 <lambdabot>  ["abc","","def"]
11:40:49 <dmwit> Hmmm... depends on the behaviour you want, I suppose.
11:42:06 <drigz> > on
11:42:07 <lambdabot>   Not in scope: `on'
11:43:03 <dmwit> ?let on f g x y = f (g x) (g y)
11:43:06 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
11:43:27 <dmwit> ... huh
11:44:11 <drigz> @help let
11:44:12 <lambdabot> let <x> = <e>. Add a binding
11:44:36 <drigz> ?pl \f g x y -> f (g x) (g y)
11:44:36 <lambdabot> join . ((flip . ((.) .)) .) . (.)
11:46:16 <inono> what, you cant do 'a' + 2? :P
11:46:45 <doserj> you can, if you define instance Num Char
11:46:49 <xerox> that's because the type of 'a'
11:47:05 <xerox> its two arguments must be of the same type
11:47:20 <xerox> ...and that type must be an instance of Num.
11:47:25 <inono> can you overload functions on a specific type?
11:47:39 <xerox> err, '+', no idea why I wrote 'a'.
11:47:49 <xerox> ?type (+) -- see
11:47:52 <lambdabot> forall a. (Num a) => a -> a -> a
11:48:18 <xerox> `a' can be any type that is in the set Num.
11:48:25 <inono> how do i implement + for my own subtype of Num?
11:48:38 <drigz> is there a way to say that type T can be coerced to class C with function f?
11:48:41 <xerox> instance Num Inono where
11:48:46 <xerox>   .. + .. = ....
11:49:22 <doserj> drigz: what do you mean with "coerced to class C"?
11:49:29 <inono> xerox, sorry im not following you? how would i add ths instancE?
11:50:30 <drigz> doserj: if necessary, this function can convert it to a type that is an instance of class C
11:50:33 <xerox> inono, you can't do that on the GHCi prompt, you must write a module. In that module you need to 1) define the type, like |data Inono = Inono Int| and then the instance with |instance Num Inono where (Inono x) + (Inono y) = Inono (x+y)|, a simple example.
11:51:06 <drigz> like you can't add an integer to a fraction, but if you try and add them, you can coerce the integer to a fraction
11:51:16 <Saizan> drigz: and have the conversion happen automagically?
11:51:21 <drigz> yeah
11:51:22 <doserj> f:: C a => T -> a -- like this?
11:51:27 <inono> hm
11:51:38 <drigz> doserj: yes
11:51:48 <xerox> http://www.haskell.org/tutorial/classes.html
11:51:49 <lambdabot> Title: A Gentle Introduction to Haskell: Classes
11:51:50 <inono> haskell has generators? i thought that was anti-functional
11:51:58 <Saizan> drigz, then no, you can't :)
11:52:06 <xerox> what do you mean by generator?
11:52:13 <inono> [ f x |  x <- xs ]
11:52:13 <drigz> Saizan: :( thanks
11:52:29 <xerox> that's the list monad.
11:52:46 <xerox> in particular that is called list comprehension
11:52:49 <inono> well it says "x <- xs" is a generator in the tutorial
11:53:00 <Saizan> drigz: with some typeclass hackery you can probably obtain the same effects, but that depends on the functions involved
11:53:41 <drigz> inono: i may be wrong, but what i've found is that haskell has taken a lot of words which are used in imperative programming and changed their meaning a bit
11:54:21 <drigz> Saizan: probably a bit beyond me atm, but thanks
11:54:22 <inono> drigz, the reason i ask is because i read an article a few months ago saying that functional programming constructs such as 'map' eradicate the need for generators
11:54:40 <doserj> [ f x |  x <- xs ] == map f xs
11:54:41 <drigz> inono: list comprehensions are just syntactic sugar apparently
11:54:41 <Saizan> well, it "generates" value from the list xs, because each value is computed only when demanded because of lazy evaluation, but the list is immutable as any other thing
11:55:21 <inono> doserj, yeah so why two values? :)
11:55:24 <inono> two ways to do it *
11:55:28 <drigz> inono: you can write them other ways but sometimes it's a lot nicer to use LCs
11:55:37 <xerox> oh, there are plenty of ways to do the same thing!
11:55:39 <Cale> inono: The reason that we don't need generators is precisely because we have lazy lists.
11:55:53 <xerox> hiya Cale.
11:55:55 <Cale> hello
11:55:56 <inono> but i thought you have generatorS?
11:56:19 <Cale> Well, we can, but there's nothing like yield in the libraries which come with GHC.
11:56:34 <Cale> You could invent a monad which did have such a control structure though.
11:56:41 <Cale> (probably based on Cont)
11:56:44 <sebell> inono: Stop calling them generators if what you really mean is `Python generators'
11:56:44 <inono> so.. its syntactic sugar for map?
11:56:57 <inono> sebell, i didnt call them generators the tutorial did :-)
11:57:01 <Cale> List comprehensions are syntax sugar for concatMap and filter.
11:57:09 <doserj> > [(x,y,x+y) | x <- [1..10], y <- [1..10], even x, odd y]
11:57:10 <lambdabot>  [(2,1,3),(2,3,5),(2,5,7),(2,7,9),(2,9,11),(4,1,5),(4,3,7),(4,5,9),(4,7,11),(...
11:57:21 <sebell> inono: The tutorial is referring to something other than what you are, that's where the ambiguity is.
11:57:31 <inono> sebell, all right and yeah i was talking about python gens
11:57:44 <Cale> > [(x,y,z) | x <- [1..20], y <- [x..20], z <- [y..20], x^2 + y^2 == z^2]
11:57:46 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
11:57:47 <inono> oh sweet, you can filter things? I like that
11:58:27 <Cheery> does there exist in untyped lambda calculus something comparable to: -1 * -1 = 1, 1*1=1 ?
11:58:41 <tibbe> does ghc 6.6 allow for string literals to be bytestrings?
11:59:18 <Cale> Cheery: well, how are you representing integers?
11:59:30 <DRMacIver> Cale: Hm. Doesn't filter use concatMap?
11:59:31 <Cale> Church numerals only really give you natural numbers.
11:59:42 <Cale> DRMacIver: It could, I suppose.
11:59:43 <DRMacIver> No, apparently not.
11:59:54 <Cheery> Cale: I don't mean numbers but the effect
12:00:16 <Igloo> tibbe: No
12:00:21 <Igloo> tibbe: 6.8 will, with a flag
12:00:24 <DRMacIver> I'd assumed that it was just using the monad operations throughout in a list comprehension. My mistake.
12:00:52 <doserj> http://hackage.haskell.org/trac/ghc/ticket/1126
12:00:53 <lambdabot> Title: #1126 (Add Data.String, containing IsString(fromString), to base) - GHC - Trac
12:01:00 <Cale> DRMacIver: List comprehensions used to stand for monad operations. I've been hoping that someone would put that feature back.
12:01:20 <Cale> Apparently if someone does it, the patch will be accepted.
12:01:27 <DRMacIver> Huh. I thought it still did.
12:01:34 <lucca> Cheery: something like ```s``s`kskk``s``s`kskk ?
12:01:38 <tibbe> Igloo, so the best thing to do is, myString = B.pack "literal" ?
12:02:10 <lucca> for some very strange values of one
12:02:12 <inono> im confused about the defining infix operators part
12:02:15 <Saizan> packAddr "literal"#
12:02:31 <Igloo> tibbe: Yes
12:02:34 <inono> can you actually define your own infix operators?
12:02:41 <Cale> inono: yep
12:03:00 <DRMacIver> I really wish that feature were more common in other languages.
12:03:03 <Igloo> Oh, or maybe what Saizan says
12:03:22 <DRMacIver> Just having at most operator overloading is a total travesty.
12:03:23 <Igloo> If you don't mind using extensions
12:03:24 <doserj> Igloo: any chance for rebindable syntac for if-then-else? :)
12:03:28 <Cale> > let x +- y = (x+y, x-y) in 5 +- 2
12:03:30 <lambdabot>  (7,3)
12:03:47 <inono> ah
12:03:49 <inono> thats awesome
12:04:06 <DRMacIver> Fortress is apparently intending to allow you to use the entirety of unicode in definining your operators. :D
12:04:16 <drigz> > let (+) = (-) in 5+2
12:04:18 <lambdabot>  3
12:04:18 <inono> aww, you cant define prefix opersator?
12:04:29 <Saizan> tibbe, http://haskell.org/ghc/docs/latest/html/libraries/base/Data-ByteString-Char8.html#v%3ApackAddress
12:04:31 <lambdabot> http://tinyurl.com/2k84jv
12:04:43 <Igloo> doserj: I can't see why a patch wouldn't be accepted  :-)  (although I don't have the final say, of course)
12:05:12 <DRMacIver> inono: Prefix operators are called 'functions' :)
12:05:44 <inono> and postfix either? :(
12:05:57 <drigz> is that a lambdabot bug? it didn't include the anchor in the tinyurl
12:06:07 <Cale> You can actually sorta simulate postfix with infix sections
12:06:14 <Cale> Though it only works in GHC
12:06:43 <Cale> > let (!) n = product [1..n] in (5 !)
12:06:44 <lambdabot>  120
12:06:49 <lucca> drigz: anchors never get sent to a server, so it could never get past tinyurl's indirection anyway, I think
12:06:51 <Cale> kind of cheesy :)
12:06:55 <tibbe> Saizan, what do I gain by using that pack?
12:07:00 <Cale> The parens are non-optional
12:07:35 <doserj> but the whitespace isn't...
12:07:44 <Cale> right
12:07:59 <Saizan> tibbe: it's more efficient i think
12:08:15 <tibbe> Saizan, ok
12:08:30 <xerox> Cale, aha, I'll keep that in mind, I always call it 'f'.
12:08:32 <Saizan> the unsafe one especially
12:08:34 <drigz> lucca: it can, i just tried it :)
12:09:12 <drigz> lucca: tinyurl just stores the url and sends it to your browser
12:09:45 <lucca> aha
12:09:51 <lucca> miracles of modern technology
12:11:37 <Cheery> yeh, I'm wondering exactly for that
12:11:45 <Cheery> oops, wrong channel :)
12:12:36 <inono> how do i define alternative versions of my functions?
12:12:41 <ketil> Is it possible to just install a new version of the base package for ghc?
12:13:20 <ketil> @where base
12:13:21 <lambdabot> http://darcs.haskell.org/packages/base/
12:13:25 <inono> like sum n = 0 if n ==[] and sum n = let x:xs = n in x + sum xs if n != [] /
12:14:11 <ketil> ...only one way to find out?
12:14:22 <lucca> guards
12:14:32 <DRMacIver> sum = foldr (+) 0
12:14:33 <drigz> > let sum [] = 0; sum (x:xs) = x + sum xs in sum [1, 6, 9]
12:14:35 <lambdabot>  16
12:14:45 <DRMacIver> Or you could do it that way. :)
12:15:14 <drigz> > let sum _ = 0; sum (x:xs) = x + sum xs in sum [1, 6, 9]
12:15:16 <lambdabot>      Warning: Pattern match(es) are overlapped
12:15:16 <lambdabot>              In the definition...
12:15:34 <inono> ah using a semicolon ?
12:15:47 <monochrom> Do not develop the habit of "n==[]".
12:16:01 <doserj> inono: either semicolon, or layout
12:16:03 <inono> i know, which is why i was asking how to do it
12:16:07 <inono> doserj, how do you do it with a layout
12:16:23 <DRMacIver> monochrom: Yeah. He should be using length n == 0
12:16:29 <drigz> inono: you can use separate lines in a source file
12:16:42 <drigz> inono: the semicolon takes the place of a newline
12:16:43 <monochrom> Please don't do that either!
12:17:22 <drigz> monochrom: is there a technical disadvantage to ==[]?
12:17:30 <dylan> > null []
12:17:32 <lambdabot>  True
12:17:48 <Cheery> lol
12:17:50 <DRMacIver> monochrom: He could do head n in the exception monad? :)
12:18:04 <dylan> ?src null
12:18:05 <lambdabot> null []     = True
12:18:05 <lambdabot> null (_:_)  = False
12:18:06 <doserj> @type (== [])
12:18:08 <lambdabot> forall a. (Eq [a]) => [a] -> Bool
12:18:16 <inono> does haskell have optimization for tail recursion
12:18:17 <doserj> drigz: it changes the type!
12:18:23 <DRMacIver> inono: Of course...
12:18:34 <inono> then sum = foldl (+) 0 is better ;)
12:18:42 <DRMacIver> Actually not.
12:18:43 <drigz> doserj: ah, i see
12:18:52 <monochrom> You have a list n of type [X] and you ask "n==[]".  This presupposes that X is in the typeclass Eq.  Most often X is not.
12:18:56 <inono> hows that? it starts unfolding right away rather than recursing to the end i thought
12:18:56 <DRMacIver> A lot of the time where you'd expect that to be the case, Haskell's lazy evaluation strategy suprirsed you.
12:19:04 <qwr> inono: lazy fucks it up ;)
12:19:06 <monochrom> :type \n -> n==[]
12:19:11 <drigz> inono: apparently one should always use foldl' instead of foldl
12:19:15 <monochrom> @type \n -> n==[]
12:19:18 <lambdabot> forall a. (Eq [a]) => [a] -> Bool
12:19:19 <qwr> inono: and makes foldr more efective
12:19:19 <inono> whats foldl' ?
12:19:27 <qwr> inono: strict foldl
12:19:32 <DRMacIver> Hm. In this case you're right actually, as you'll really always want + to be evaluated eagerly.
12:19:33 <inono> eager foldl?
12:19:40 <qwr> inono: yes
12:19:56 <DRMacIver> So "sum = foldl' (+)" would indeed be better. My mistake.
12:19:58 <Cheery> is there something you can't express through SKI or is clearly impossible?
12:20:06 <monochrom> You get an Eq constraint even though you don't need it.
12:20:13 <inono> foldl in lazy being slower... thats an interstint ghtought
12:20:24 <Cheery> ie. can you find combinators you can't find directly by combining SKI?
12:20:33 <inono> i dont see why since there's less unwrapping?
12:20:34 <DRMacIver> inono: It's not exactly that it's slower. It's that if you foldr then you preserve laziness.
12:20:47 <DRMacIver> inono: So if you use foldr you'll often need to evaluate much less of the expression.
12:20:53 <emu> SKI is sufficient by itself
12:20:57 <emu> SK actually
12:21:17 <inono> DRMacIver, you mean if i want to evaluate it partially?
12:21:39 <DRMacIver> Yeah.
12:22:41 <DRMacIver> For example if you define (++) = foldr :
12:22:44 <DRMacIver> err. Is that right?
12:23:09 <emu> @type foldr (:)
12:23:12 <lambdabot> forall a. [a] -> [a] -> [a]
12:23:24 <drigz> ?src (++)
12:23:25 <lambdabot> (++) []     ys = ys
12:23:25 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
12:23:32 <DRMacIver> Well, it's not defined that way. :)
12:23:34 <DRMacIver> But it's the same idea.
12:23:45 <doserj> foldr (:) = id
12:23:46 <inono> yeah neither of them are tail recursive
12:24:04 <emu> doserj: that's foldr (:) []
12:24:09 <DRMacIver> inono: Right. But it doesn't need to be.
12:24:18 <DRMacIver> inono: Because this runs in O(1) stack.
12:24:19 <doserj> ups, ok.
12:24:22 <emu> > foldr (:) [1,2,3] [4,5,6]
12:24:23 <lambdabot>  [4,5,6,1,2,3]
12:24:34 <emu> > flip (foldr (:)) [1,2,3] [4,5,6]
12:24:35 <lambdabot>  [1,2,3,4,5,6]
12:24:45 <DRMacIver> inono: Because you don't evaluate terms from the resulting list until you need them.
12:25:24 <DRMacIver> so e.g. to get head $ [1, 2, 3] ++ [4, 5, 6] you'd evaluate this as 1 :: ([2, 3] ++ [4, 5, 6]) = 1
12:25:28 <inono> but that would be true in either case no?
12:25:29 <DRMacIver> Without ever caring about the remainder.
12:26:07 <emu> :: is ML for cons :P
12:26:12 <DRMacIver> (Someone who knows what they're talking about should feel free to shout at me if I'm talking bollocks. A Haskell expert I am not)
12:26:19 <DRMacIver> Gah. I always get that wrong. :)
12:26:23 * DRMacIver learned ML first
12:26:38 <inono> yeah i tried :: too first, ;(
12:27:08 <inono> @src foldr
12:27:08 <lambdabot> foldr k z xs = go xs
12:27:09 <lambdabot>     where go []     = z
12:27:09 <lambdabot>           go (y:ys) = y `k` go ys
12:27:11 <sieni> yeah, the inverted meanings of : and :: can get slightly annoying, if you use both :-)
12:27:17 <Cale> foldr f z [] = z
12:27:26 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
12:27:32 <inono> huh, what does `k` mean
12:27:32 <DRMacIver> inono: You couldn't do this with foldl because you'd be evaluating it as umm... curses. How does this work?
12:27:36 <DRMacIver> One second
12:27:55 <emu> a `k` b == k a b
12:27:56 <Cale> The @src command gives you the exact code from the libraries, but this often includes cheap tricks to get GHC to optimise things better.
12:28:08 <Cale> Rather than the code which is morally correct.
12:28:10 <inono> so.... why nto just do k a b?
12:28:15 * emu shrugs.
12:28:22 <emu> the precedence is low
12:28:30 <emu> you would have to write k y (go ys) instead
12:28:33 <inono> so.... whats a `k`b c ?
12:28:34 <Cale> inono: sometimes it's nice to make things infix
12:28:43 <inono> k a (b c) ?
12:28:46 <Cale> yeah
12:28:47 <emu> yep
12:28:52 <inono> ok
12:29:02 <Cale> function application binds tighter than anything else
12:29:04 <drigz> inono: it's good for things like 6 `div` 4
12:29:04 <doserj> especially when using folds
12:29:11 <monochrom> Since k is thought of as a binary operator, you write it infix.
12:29:24 <DRMacIver> Gah. I've lost the plot. Pretend I gave a coherent explanation of why this owuldn't work. :)
12:29:30 <inono> ok what?
12:29:34 <inono> i dont see how foldr is better at all
12:29:36 <Cale> DRMacIver: Why what wouldn't work?
12:29:53 <Cale> foldr is better because it has a chance of working on infinite lists
12:29:56 <emu> that head $ a ++ b is efficient?
12:30:01 <DRMacIver> Cale: Why foldl would prevent lazy evaluation of the list if you used it to define ++
12:30:07 <fasta> Can anyone explain why my application only works in ghci or in ghc with some changes, but not with the same code base?
12:30:21 <fasta> The module system appears to be broken
12:30:21 <monochrom> "foldr is better" is wrong.  "foldl is better" is also wrong.  "foldl' is better" is also wrong.  "orange is better" is wrong.  "fish is better" is also wrong.
12:30:23 <DRMacIver> It should be obvious, but I don't see it at the moment. I blame it being friday.
12:30:38 <emu> friday IS better
12:30:39 <jre2> is any work still being made on mage (the nethack-ish haskell clone)?
12:30:42 * fasta is with monochrom
12:30:56 <monochrom> Friday is indeed better. This one is right. :)
12:31:02 <Cale> DRMacIver: how would you use foldl to define (++)?
12:31:16 <fasta> Is it pointless discussion day?
12:31:16 <emu> even Friday the 13th. c
12:31:22 * emu cues scary music
12:31:28 <emu> ?pl discussion day
12:31:29 <lambdabot> discussion day
12:31:45 <chessguy_work> monochrom: what on earth are you talking about?
12:32:01 <monochrom> > take 10 ("hello " ++ cycle "kitty ")
12:32:03 <lambdabot>  "hello kitt"
12:32:08 <inono> foldr (+) 0 [1,2,3,4,5] =>  y `k` go ys => k y (go ys) , (+) 0 (+ 1 (+ 2 (+ 3 (+ 4 (+ 5)))))
12:32:10 <Cale>  xs ++ ys = foldl (flip (:)) ys (reverse xs) ?
12:32:21 <Cale> foldr (+) 0 [1,2,3]
12:32:30 <inono> @src foldl
12:32:30 <lambdabot> foldl f z xs = lgo z xs
12:32:30 <lambdabot>     where lgo z []     =  z
12:32:30 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
12:32:31 <DRMacIver> Cale: Hm. Good question. :)
12:32:35 <Cale> = 1 + foldr (+) 0 [2,3]
12:32:36 <emu> > head $ foldl (flip (:)) [] [1..]
12:32:42 <lambdabot> Terminated
12:32:44 <monochrom> > let xs ++ ys = foldl (flip (:)) ys (reverse xs) in take 10 ("hello " ++ cycle "kitty ")
12:32:46 <Cale> = 1 + (2 + foldr (+) 0 [3])
12:32:50 <lambdabot>  "hello kitt"
12:32:51 <emu> > head $ foldr (:) [] [1..]
12:32:52 <lambdabot>  1
12:32:54 <Cale> = 1 + (2 + (3 + foldr (+) 0 []))
12:32:56 <inono> what the heck is lgo
12:33:00 <Cale> = 1 + (2 + (3 + 0))
12:33:25 <monochrom> Oh I see
12:33:30 <drigz> inono: short for left go
12:33:33 <monochrom> > take 10 (cycle "hello " ++ "kitty ")
12:33:34 <inono> meaning what
12:33:36 <lambdabot>  "hello hell"
12:33:42 <drigz> inono: go means nothing in particular
12:33:45 <monochrom> > let xs ++ ys = foldl (flip (:)) ys (reverse xs) in take 10 (cycle "hello " ++ "kitty ")
12:33:47 <Cale> That definition with go is more complicated than it has to be.
12:33:49 <lambdabot> Terminated
12:33:51 <inono> so what does lgo z [] mean
12:33:56 <chessguy_work> drigz: unless you like board games :)
12:34:01 <xerox> monochrom, perverse
12:34:03 <drigz> call the function lgo on the arguments z and []
12:34:09 <drigz> inono: lgo is defined below
12:34:18 <Cale> foldl f z [] = z; foldl f z (x:xs) = foldl f (f z x) xs
12:34:22 <monochrom> This shows that if you use foldl to define ++ it breaks on infinite lists.
12:34:34 <Cale> foldr f z [] = z; foldr f z (x:xs) = f x (foldr f z xs)
12:34:40 <balodja> how to use ``let a = if b == "asdf" ...'' inside do-notation?
12:34:55 <Cale> balodja: indent it correctly
12:35:06 <monochrom> On finite lists there is also a time complexity issue.
12:35:19 <Cale> balodja: the 'then' and 'else' should be indented more than the 'if', and should be indented to the same level.
12:35:48 <balodja> more than the 'if'... ok, thanks
12:36:09 <Cale> let a = if b = "asdf"
12:36:10 <inono> foldl + 0 [1,2,3] => (((+ 0 1) + 2) + 3) ???
12:36:22 <Cale>           then foo
12:36:26 <Cale>           else bar
12:36:42 <Cale> foldl (+) 0 [1,2,3]
12:36:51 <inono> or rather (+(+(+ 0 1) 2) 3) ?
12:36:51 <Cale> = foldl (+) (0 + 1) [2,3]
12:36:58 <Cale> = foldl (+) ((0 + 1) + 2) [3]
12:37:03 <tibbe> anyone tried the PCRE regex backend, does it support named capture groups? documentation is a bit sparse
12:37:05 <Cale> = foldl (+) (((0 + 1) + 2) + 3) []
12:37:08 <Cale> = (((0 + 1) + 2) + 3)
12:37:13 <Cale> = ((1 + 2) + 3)
12:37:15 <Cale> = (3 + 3)
12:37:17 <Cale> = 6
12:37:22 <Cale> that's how it's evaluated
12:37:24 <inono> yeah i like prefix + better
12:37:29 <inono> makes it easier to see the lazy evaluation at work
12:37:45 <inono> so yeah... would be kind of hard to extract an infinte list out of fold
12:37:51 <inono> foldl *
12:37:54 <drigz> > + 1 2
12:37:55 <lambdabot>  Parse error
12:38:03 <Cale> foldl always recurses to the end of the list before returning any part of the result
12:38:10 <fasta> Oh, how I hate this buggy module system.
12:38:14 <inono> drigz, i know i was feeling lazy to write (+)
12:38:16 <thedward> > (+) 1 2
12:38:18 <lambdabot>  3
12:38:32 <fasta> Of course, reproducing it in a simple example would be a nightmare....
12:38:33 <Cale> foldr f z (x:xs) immediately returns f of x and something which can wait until later.
12:38:48 <Heffalump> unless f demands it, of course
12:39:01 <Cale> Well, f will have to demand it before it'll get evaluated.
12:39:04 <inono> hehe, now ill have to remember to use foldr in haskell :P
12:39:04 <balodja> Cale: may i break the line after 'let a =' and start a new block(inside do)?
12:39:25 <Cale> balodja: sure, but you should indent it farther than 'a'
12:39:38 <Cale> so that it's inside the declaration of a
12:40:31 * chessguy_work just used foldr in code he sent to a potential employer yesterday
12:40:46 <DRMacIver> Cool. :)
12:41:05 * DRMacIver had to explain what a monad was in a phone interview yesterday
12:41:13 <Cale> :)
12:41:25 <DRMacIver> I preceded my explanation with "God only knows". :)
12:41:30 <Cale> haha
12:41:50 <Cale> "That's sort of a philosophical question...
12:41:52 <emu> it's the complement of a comonad
12:42:07 <Heffalump> who was the interview with?
12:42:15 <DRMacIver> Well, basically what I said was "I don't really understand them. They're much easier to use than they are to understand. But, here's the gist of it."
12:42:24 <chessguy_work> i was asked that in my last interview too
12:42:27 <DRMacIver> Startup company in London doing statistical natural language processing.
12:42:33 <inono> why isnt this working?
12:42:38 <DRMacIver> They don't actually use Haskell
12:42:38 <inono> let mlength [] = 0; mlength x:xs = 1 + mlength xs
12:42:41 <emu> why did they ask you about monads?
12:42:48 <emu> inono: (x:xs)
12:42:53 <DRMacIver> Because I mentioned I was playing with Haskell.
12:42:57 <Cale> I tend to just explain that it's a specific type of combinator library that implements a particular means of combination so that code can be shared between different monads.
12:43:10 <DRMacIver> The guy giving the interview was a fellow languages geek. :)
12:43:19 <chessguy_work> i usually talk about monads in terms of being explicit about side effects
12:43:20 <emu> Cale: wouldn't that be a description of mtl?
12:43:28 <DRMacIver> So we discussed Monads, Nice, Scheme, etc.
12:43:28 <inono> does haskell have a "match" like ML?
12:43:34 <emu> inono: case
12:43:41 <emu> like SML
12:43:46 <Cale> emu: Well I'm referring to the code that's shared as things like mapM and sequence
12:43:48 <DRMacIver> Given that he's the CTO of the company I consider this a Good Sign. :)
12:44:05 <chessguy_work> DRMacIver: what language do they use?
12:44:26 <DRMacIver> chessguy_work: Mostly Java and Ruby unfortunately.
12:44:33 <inono> i once talked up ruby during a java interview
12:44:38 <Cale> emu: essentially, it saves you from writing your own for-loop in a bunch of different domain-specific languages.
12:44:45 <DRMacIver> The prototype was in Lisp, but they didn't feel it had enough support to use it for their product.
12:45:01 <emu> Cale: certainly, it's a great thing. but it isn't a desc of Monads themselves
12:45:22 <inono> once i understand what a monad is i will feel a lot smarter
12:45:26 <chessguy_work> i've talked about haskell in probably every interview i've had in the last 6 months. i'm starting to shy away from it a little
12:45:27 <Cale> emu: It doesn't give you the details of what those common means of combination are
12:45:44 <Cale> emu: But I think it does a pretty good job of saying what they're good for in programming.
12:45:49 <inono> i'm sure its something trivial  but it sounds fancy... you functional people and your 'side effects' or 'boolean guards' !! hehe
12:46:05 <DRMacIver> I more or less understand what monads are categorically and I can more or less use them. I just haven't managed to really connect the two yet.
12:46:14 <emu> inono: yer right, it is trivial =)
12:46:30 <inono> whatever makes you feel smarter than the inferior imperative people right? ;)
12:46:53 <emu> no really, it is trivial.  work on understanding type-classes, and monads are just a type-class.
12:46:58 <Cale> DRMacIver: return = eta, join = mu, T = fmap
12:47:05 <Cale> er, fmap = T :)
12:47:07 <inono> emu, i think ill learn on picking up the haskell basics first
12:47:17 <inono> emu, and hopefully not forget them before i actually get to use haskell in my school class
12:47:22 <DRMacIver> Cale: I understand the translation between the two. :) I just haven't internalised it or figured out how the ideas relate.
12:47:23 <emu> that's cool
12:47:26 <LeCamarade> Question: I have been watching darcs working. I have put the _darcs file and ram under watch, and only RAM is swelling. Is this caused by lazy eval, or was it designed to be like that?
12:47:31 <inono> seems a lot like ML except with call-by-need so far
12:47:41 <Heffalump> LeCamarade: there's a #darcs, btw
12:47:52 <LeCamarade> Oh, okay.
12:47:54 <emu> you can certainly use a portion of haskell that way
12:48:00 * LeCamarade goes to #darcs
12:48:01 * emu also came from SML
12:48:03 <DRMacIver> inono: The type classes make a huge difference.
12:48:08 <Cale> LeCamarade: uh, could be a bug? That's not specific enough to know what's wrong.
12:48:10 <chessguy_work> oooh, another haskell channel!
12:48:20 * Heffalump doesn't mind answering here
12:48:21 <monochrom> DRMacIver: On the relation, Moggi's papers help.
12:48:23 <Heffalump> I was just letting you know
12:48:24 <emu> SML lacks type-classes, and it's really helpful
12:48:30 <LeCamarade> emu: Haskell has big, big ML influences, but the differences are big.
12:48:35 <Cale> LeCamarade: Maybe it needs a lot of memory for something that it's doing.
12:48:46 <Heffalump> it really does depend on what you asked it to do
12:49:00 <monochrom> Everyone says Moggi's paper was scary, but I know you and I know no fear.
12:49:00 <DRMacIver> monochrom: I'm not very good at getting around to reading all those papers. I should.
12:49:02 <emu> LeCamarade: i wouldn't write proper haskell like SML, once you learn it
12:49:12 <emu> but to get comfy
12:49:39 <emu> before you learn to structure your program using monads and stuff like that
12:49:45 <DRMacIver> inono: The thing you need to worry about with ML and Haskell is that although there are easy translations between the language cores, these translations do not preserve good code.
12:49:51 <LeCamarade> Cale: Well, I think the lines running (when it is saying `Copying patch n of nn' should be *copying*, not caching.
12:50:33 <DRMacIver> Anyway, this weekend's brain activity is dedicated to learning C, so I'll probably put off reading more about Haskell for a while. :)
12:50:43 <inono> is emacs the best editor for haskell?
12:50:49 <monochrom> C is hard to learn.
12:50:52 <LeCamarade> emu: Well, you can actually treat Haskell like SML for the first day. You'll be just fine only making a few changes to syntax thinking.
12:51:12 <DRMacIver> monochrom: Yeah, but I'm supposed to be interviewing for a position to write C compilers in two weeks. I figure I should brush up on the basics. :)
12:51:13 <emu> inono: there's good supprot in emacs, but plenty of other editors are in widespread use
12:51:18 <LeCamarade> To bve frank, the call-by-need won't bother you much, most of the time you'll be coding Haskell.
12:51:28 * dylan came from to haskell via two camels. 
12:51:44 <inono> dont see why it would matter if there were no side effects :_)
12:52:01 <Madhadron> Anyone know whether Parsec has ByteString support yet?
12:52:12 <monochrom> The same code has different termination behaviour in ML and Haskell.
12:52:22 <inono> thats cause ML uses eager iirc
12:52:35 <monochrom> Yes.  Apart from that, you're ready!
12:52:40 <DRMacIver> inono: well, the amount of time taken to run the code is one side effect Haskell *does* have. :)
12:52:46 <LeCamarade> inono: Well, just about every main has side effects. Sometimes severe ones.
12:53:08 <DRMacIver> (Plus what LeCamarade said)
12:54:04 * Heffalump used to write a C compiler for a living
12:54:12 <LeCamarade> darcs is in swap, now. And there is no big change in the directory. Lazy eval ...
12:54:18 <mtahti> Hi! I'm trying to define a function intRoot :: Int -> Maybe Int that takes an integer and returns its integer root if such root exists. Can anyone please tell me how to catch exceptions that arise from lookups like this: (array (1, 100) [(i*i, i) | i <- [1..10]]) ! 2
12:54:34 <Heffalump> LeCamarade: so what did you ask it to do?
12:54:44 <ketil> Anybody know the rationale behind the current Random module?
12:55:11 <dmwit> Madhadron: I think it is a SoC project.
12:55:11 <LeCamarade> I am getting the Yi editor. Currently copying patch 339 of 596.
12:55:30 <Heffalump> and the 339 hasn't changed?
12:55:32 <dmwit> LeCamarade: You realize that _darcs is a directory, right?
12:55:35 <Heffalump> while it went into swap?
12:55:35 <Madhadron> dmwit, Oh well
12:55:40 <ketil> In particular, why is the ps part of the time ignored when seeding the StdGen?
12:55:48 <Madhadron> Guess I'm writing this tiff library without it.
12:55:50 <Heffalump> when it's getting patches, it is just downloading files into _darcs/patches, AFAIK
12:56:20 <emu> mtahti: because the 2nd elt is not defined
12:56:22 <Heffalump> so if you are just watching the _darcs directory entry, nothing will change
12:56:23 <dmwit> mtahti: Prefer to do the checking before hand; error catching has to be in the IO monad.
12:56:30 <inono> oh well... back to the non-functional word of C#. thanks for all the help
12:56:50 <Heffalump> if you watch the contents of _darcs/patches/, or the size of _darcs, or something like that, you should see progress as the number of patches copied changes
12:56:56 <LeCamarade> Heffalump: Yeah, that's the dir I'm watching.
12:57:10 <dmwit> mtahti: Never mind.  Sorry, I misunderstood.
12:57:17 <emu> mtahti: sometimes i do: listArray (1,100) (repeat Nothing) // [ (i*i,i) | i <- [1..10] ]
12:57:28 <emu> mtahti: sometimes i do: listArray (1,100) (repeat Nothing) // [ Just (i*i,i) | i <- [1..10] ]
12:57:31 <emu> sorry
12:57:49 <dmwit> mtahti: You might want to look at Data.Map, which can return your Maybe value for you.
12:57:55 <dmwit> :t Data.Map.lookup
12:57:58 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
12:58:09 <emu> Map is a good idea
12:58:13 <dmwit> (Maybe is an instance of Monad.)
12:58:28 <dmwit> :t Data.Map.fromList
12:58:30 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
12:58:57 <Heffalump> LeCamarade: ok, so can you describe the symptoms more precisely? Is the number of patches it says it has copied going up? Are you seeing any change in the total size of contents of the _darcs directory?
12:59:16 <emu> > 2 `M.lookup` M.fromList [ (i*i,i) | i <- [1...10] ]
12:59:17 <lambdabot>   Not in scope: `...'
12:59:34 <emu> > 2 `M.lookup` M.fromList [ (i*i,i) | i <- [1..10] ]
12:59:35 <lambdabot>   add an instance declaration for (Show (m t))
12:59:57 <emu> > 2 `M.lookup` M.fromList [ (i*i,i) | i <- [1..10] ] :: Maybe Int
12:59:59 <lambdabot>  Nothing
13:00:00 <mtahti> Thanks a lot dmwit and emu!
13:03:49 <LeCamarade> Heffalump: Yes, the number is climbing steadily. _darcs is growing, although my watching command can't be recursive to see what's happening beyong the dirs in _darcs, which display constant values, same for all dirs (4096 in ext3). RAM usage is still climbing steadily with the count of patches. Not a bug, I think. More of a question like `would strict eval have the same effect on RAM'?
13:04:36 <medfly> what does "not in scope" mean?
13:04:40 <LeCamarade> Of course memory is not a valid worry in today's world. Writing a good program is a more-pertinent worry.
13:04:56 <drigz> LeCamarade: use du to see the full size of the folders
13:05:10 <shoffsta> :t Test.QuickCheck.generate
13:05:13 <lambdabot> forall a. Int -> StdGen -> Gen a -> a
13:05:35 <shoffsta> What is the first argument of Test.QuickCheck.generate used for?
13:06:22 <drigz> medfly: that value hasn't been declared
13:07:25 <LeCamarade> drigz: du(1) is not suited for being watch(1)ed. It fills the screen too much.
13:08:01 <drigz> LeCamarade: you can use flags to turn off the recursion
13:08:39 <dylan> du -hs works, though
13:09:19 <drigz> or du --max-depth=1 if you want _darcs and subdirs
13:09:23 <balodja> does lambdabot has a timeout for evaluation?
13:09:28 <LeCamarade> drigz: Oh. You mean to see the size growing, rather than of the individual elements. Okay, that works, even though it was not what I was targetting at first. It works well for the diagnostics. Thanks.
13:09:33 <drigz> > length [1..]
13:09:38 <lambdabot> Terminated
13:09:56 <balodja> thanks
13:12:04 <LeCamarade> Hey, I just darcsed dons' source. It should be very edifying to read the code.
13:12:39 <LeCamarade> Just looking at Main.hs, I have learnt two good practices.
13:12:53 <LeCamarade> module Main (main) where ...
13:13:34 <LeCamarade> And to do that main :: m a (more-specific) that I had stopped doing.
13:27:37 <Madhadron> Has anyone else tried to build Binary on GHC 6.4?
13:29:08 <dylan> LeCamarade: dons is written in haskell?
13:29:32 <dylan> that explains a lot...
13:29:56 <emu> @yow
13:29:57 <lambdabot> Hello.  Just walk along and try NOT to think about your INTESTINES
13:29:57 <lambdabot> being almost FORTY YARDS LONG!!
13:30:19 <shoffsta> dylan: hehe :)
13:32:06 <SyntaxNinja> @seen shapr
13:32:07 <lambdabot> I saw shapr leaving #haskell-soc and #haskell 1d 7h 59m 49s ago, and .
13:32:14 <SyntaxNinja> is he still out of "town"?
13:34:16 <emu> @hoogle liftA2
13:34:17 <lambdabot> No matches found
13:34:24 <chessguy_work> @quote corecur
13:34:25 <lambdabot> No quotes match. I feel much better now.
13:34:32 <chessguy_work> @quote each other
13:34:33 <lambdabot> No quotes for this person. Do you think like you type?
13:34:40 <chessguy_work> @quote recursiv
13:34:40 <lambdabot> <basti_> says: Snow doeth lay upon the lands. Even with cunning newtype; deriving the newtype is recursive. Great leaders brings less pain.
13:34:44 <chessguy_work> @quote recursiv
13:34:44 <lambdabot> ghc says: even with cunning newtype deriving the newtype is recursive
13:34:48 <chessguy_work> sigh
13:35:46 <chessguy_work> @quote recursively.coded
13:35:47 <lambdabot> Masklinn says: truth is that lambdabot and dons recursively coded each other
13:37:17 <Heffalump> which came first, the lambdabot or the dons?
13:37:38 <xerox> check the logs
13:37:49 <Cheery> lambdabot wrote dons who wrote lambdabot
13:38:06 <Cheery> ..who wrote dons
13:38:17 <Cheery> simple, isn't it?
13:38:45 <emu> > fix (["dons","lambdabot"]++)
13:38:47 <lambdabot>  ["dons","lambdabot","dons","lambdabot","dons","lambdabot","dons","lambdabot"...
13:39:10 <emu> > intersperse "wrote" $ fix (["dons","lambdabot"]++)
13:39:12 <lambdabot>  ["dons","wrote","lambdabot","wrote","dons","wrote","lambdabot","wrote","dons...
13:39:20 <Tene> @quote no
13:39:21 <lambdabot> no says: hacerle caso a br1
13:39:57 <Cheery> > concat " who wrote " $ fix (["dons", "lambdabot"]++)
13:39:58 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
13:40:11 <ndm> > unwords $ intersperse "wrote" $ fix (["dons","lambdabot"]++)
13:40:13 <lambdabot>  "dons wrote lambdabot wrote dons wrote lambdabot wrote dons wrote lambdabot ...
13:40:28 <Cheery> > unwords " who wrote " $ fix (["dons", "lambdabot"]++)
13:40:30 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
13:40:42 <dmhouse> > unwords $ intersperse "wrote" $ cycle ["dons", "lambdabot"]
13:40:44 <lambdabot>  "dons wrote lambdabot wrote dons wrote lambdabot wrote dons wrote lambdabot ...
13:40:44 <lambdabot> dmhouse: You have 1 new message. '/msg lambdabot @messages' to read it.
13:40:50 <ndm> > unwords $ intersperse "wrote" $ cycle ["dons","lambdabot"]
13:40:52 <lambdabot>  "dons wrote lambdabot wrote dons wrote lambdabot wrote dons wrote lambdabot ...
13:40:53 <emu> Phooey looks cool. anyone try v1.0?
13:41:02 <Cheery> > unwords $ intersperse " who wrote " $ fix (["dons", "lambdabot"]++)
13:41:04 <lambdabot>  "dons  who wrote  lambdabot  who wrote  dons  who wrote  lambdabot  who wrot...
13:41:05 <ndm> no point in using fix, when cycle does just fine
13:41:11 <dmhouse> ndm: I got there first :)
13:41:13 <emu> i know, i just like fix
13:41:23 <Cheery> me too.. now
13:41:26 <dmhouse> Hrm, cycle = fix . (++), that's quite nice.
13:41:30 <ndm> @karma dmhouse++ -- being first
13:41:31 <lambdabot> dmhouse++ has a karma of 0
13:41:37 <dylan> fix is subtly different from fix, isn't it?
13:41:44 <ndm> @karma++ dmhouse -- being first
13:41:45 <lambdabot> dmhouse's karma raised to 10.
13:41:47 <dylan> err
13:41:48 <chessguy_work> ndm: it's @karma+ dmhouse
13:41:50 * dylan slaps himself
13:42:00 <dylan> cycle is different from fix . (++), isn't it?
13:42:00 <Cheery> @type fix
13:42:02 * chessguy_work fixes dylan's brain
13:42:03 <lambdabot> forall a. (a -> a) -> a
13:42:05 <dmhouse> dylan: how?
13:42:13 <Heffalump> I think using fix is better as it helps demonstrate that (dons, lambdabot) is a fixed point of the writing process.
13:42:25 <dmhouse> Cheery: fix f = f (f (f (f (f ... ))))
13:42:26 <ndm> dylan: if you want to generate a list by repeating one list again and again then cycle is easier to understand
13:42:30 * ndm has brain issues with fix
13:42:43 <dylan> "dons wrote lambdabot wrote dons wrote lambdabot wrote dons wrote lambdabot "
13:42:49 <dmhouse> Cheery: it finds the 'fix point' of a function, which is a value that gets mapped to itself by the function, i.e. an x such that x = f x.
13:42:51 <dylan> vs
13:43:01 <dylan> hmm, n/m
13:43:04 <chessguy_work> ?src cycle
13:43:05 <lambdabot> cycle [] = undefined
13:43:05 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
13:43:10 <dylan> it looked like it was in a different order
13:43:15 <Cheery> dmhouse: similar to limes of some sort?
13:43:42 <dmhouse> Cheery: I don't know what limes is.
13:43:57 <Cheery> well, nvm
13:44:00 <ndm> hmmm, is cycle [] a pattern match or a non-termination?
13:44:11 <dmhouse> > cycle []
13:44:12 <Cheery> > cycle []
13:44:13 <lambdabot>  Exception: Prelude.cycle: empty list
13:44:14 <lambdabot>  Exception: Prelude.cycle: empty list
13:44:18 <Cheery> :(
13:44:22 <ndm> i can see arguments both ways, NT is the inductive defintion, pat-match is the more helpful on
13:44:24 <dmhouse> Non-termination. (Well, an error call.)
13:44:32 <sarnold> sjanssen: what firefox plugin are you running to number all the links in this screenshot? http://cse.unl.edu/%7Esjanssen/xmonad-tiles.png
13:44:36 <ndm> dmhouse: i meant looping, rather than an error call
13:45:37 <dmhouse> ndm: ah, right, yeah, I can see why that might happen.
13:46:22 <ndm> for my PhD the two different _|_'s are entirely different, so I make a big distinction - even though haskell doesn't
13:47:08 <fasta> ndm: you do termination analysis, right?
13:47:22 <Heffalump> how do you handle least fixed points?
13:47:55 <ndm> fasta: no, i don't - that was the original plan, but got ditched
13:48:03 <eumenides> sarnold: it's conkeror
13:48:03 <ndm> Heffalump: how do you mean?
13:48:23 <sarnold> thanks eumenides :)
13:48:29 <fasta> ndm: Too undefined? Too uncertain how to attack the problem in any meaningful way?
13:48:46 <ndm> fasta: too useless, to be honest :)
13:49:13 <fasta> ndm: What are you doing now?
13:49:14 <Heffalump> ndm: well, you've changed your semantic domain to have two bottoms. What's the meet/join (I forget which is which, but whichever one the one that goes downwards) of the two?
13:49:27 <ndm> fasta: i don't think an automated terminatino analysis would be a useful practical problem to solve, since i think the missing cases are too large, and teh refactoring to get termination is too painful
13:49:40 <sarnold> sjanssen: thanks :) eumenides got me squared away :)
13:50:02 <ndm> Heffalump: i treat error as a generator of _|_, so there is no real _|_-PAT in the language
13:50:11 <ndm> Heffalump: hence its not necessary to deal with that kind fo thing
13:50:26 <ndm> fasta: pattern match checking, i have a tool that will prove the absence of pattern match errors in a haskell program
13:51:16 <fasta> ndm: did you have to do anything new to solve that problem?
13:51:26 <ndm> fasta: yes, a whole ICFP papers worth :)
13:51:36 <chessguy_work> now there's a unique quit message
13:51:55 <ndm> fasta: various transforms to make haskell first order, various constranit generation and propagation rules etc
13:52:09 <ndm> fasta: i can send you a copy of the paper if you want?
13:52:19 <Heffalump> paper or submission? ;-)
13:52:33 <ndm> Heffalump: i wrote a paper which i submitted, doesn't that make it both?
13:52:36 <fasta> ndm: sure do you do /dcc ?
13:52:44 <ndm> fasta: no, email?
13:53:01 <tibbe> @paste
13:53:02 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:54:13 <Heffalump> ndm: well, it's not an ICFP paper yet. I agree it's a paper.
13:54:21 <tibbe> how can I get "Not in scope: type constructor or class `MatchArray'" when I "import Text.Regex.Base" which exports that type?
13:54:35 <fasta> Oh, well, if it hasn't been published yet, I will wait.
13:54:56 * fasta has seen more than enough published crap, so pre-published will probably be even worse.
13:55:01 * Heffalump didn't mean to put fasta off it, I'm sure it's very good..
13:55:17 <ndm> Heffalump: true, the smilie was to signify hopefullness :)
13:56:11 <chessguy_work> ?hoogle MatchArray
13:56:12 <lambdabot> No matches found
13:56:58 <chessguy_work> tibbe: i think you want Text.Regex.Base.RegexLike
13:57:22 <chessguy_work> @type Text.Regex.Base.RegexLike.MatchArray]
13:57:24 <chessguy_work> @type Text.Regex.Base.RegexLike.MatchArray
13:57:24 <lambdabot> parse error on input `]'
13:57:26 <lambdabot>     Not in scope:
13:57:27 <lambdabot>       data constructor `Text.Regex.Base.RegexLike.MatchArray'
13:57:32 <ndm> fasta: you can read my already published and peer reviewed version of an earlier paper leading up to that, but its not as good by a long way
13:59:11 <fasta> @hoogle forever
13:59:12 <lambdabot> No matches found
13:59:29 <fasta> My ghc tells me that it has forever defined in Control.Monad
13:59:32 <fasta> er ghci
13:59:53 <ndm> fasta: its a newer addition, not in Hoogle yet
14:00:30 <fasta> ndm: when I load ghci in a shell and then do :m + Control.Monad and then :i forever it doesn't find it
14:00:45 <fasta> Ah, I already understand
14:01:02 <fasta> I am starting ghci-6.7 somewhere
14:03:13 <emu> how goes wxhaskell development?
14:04:14 * emu will find out in a moment
14:14:53 <balodja> dons: hi. finally i forced runplugs(in lambdabot) to work, but sometimes ``load: couldn't find symbol <<resource>>
14:15:19 <balodja> occur. would you advise me, how to debug such things? :)
14:15:23 <glguy> !paste
14:15:23 <hpaste> Haskell paste bin: http://hpaste.org/
14:49:36 <tibbe> how do I write a type signature for (before, match, after, groups) = tmpl =~ pattern to force the 4 tuple elements to be ByteStrings?
14:51:16 <glguy> (a,b,c,d) :: (Int,Bool,(),Maybe Double)
14:52:36 <glguy> (a,b,c,d) = your function
14:53:03 <chessguy_work> i don't think that's a valid function name :)
14:53:22 <glguy> chessguy_work: "your" is
14:53:26 <glguy> "function" is the argument!
14:53:44 <chessguy_work> i mean (a,b,c,d) :)
14:54:05 <glguy> chessguy_work: sure, but what I wrote works :)
14:54:29 <glguy> assuming for an implementation of: your = undefined   -- or better
14:54:30 <chessguy_work> ohhhh
14:54:43 * chessguy_work re-reads and comprehends
14:56:49 <dolio> You could write some mutually recursive functions that way.
14:57:29 <dolio> (f, g, h) = fix (\(f, g, h) -> (the, function, definitions))
14:57:31 <dolio> Or something like that.
14:59:13 <dolio> Oops, I guess he left.
14:59:57 <DRMacIver> Remind me, is there some reason that only works in a lazy evaluation strategy?
15:00:10 <tibbe> glguy, thanks
15:00:51 <DRMacIver> I know there's a problem defining a fully general Y combinator in an eager evaluation strategy, I don't remember if there's a way to make most special cases work...
15:02:03 <dolio> I don't know. That example might work in an eager language.
15:02:44 <dolio> I think the problem is more like getting 'fix (1:)' to work in an eager language.
15:03:09 <DRMacIver> Yeah, you're probably right.
15:03:49 <DRMacIver> (I suspect it's defining it in generality that proves difficult with an eager evaluation strategy)
15:04:07 <monochrom> Yes, "fix f = let x=f x in x" works by lazy.  In an eager language you have to try a different way.
15:04:09 <dolio> Definining it for functions isn't a problem, certainly.
15:04:16 <DRMacIver> monochrom: Yes, I realise that. :)
15:04:33 <dolio> Like 'fix factorial_base' works in scheme.
15:05:02 <DRMacIver> The standard eager Y combinator has type ( (a -> a) -> (a ->a ) -> (a -> a)
15:05:08 <DRMacIver> err
15:05:11 <DRMacIver> Bracket mismatch
15:05:31 <DRMacIver> Please use the hindly milner meaning inference algorithm to infer what I actually meant. :)
15:12:17 <dolio> > let (g, h) = fix (\(~(g', h')) -> (\x -> if x == 0 then 1 else h' x, \x -> x * g' (x - 1))) in g 5
15:12:19 <lambdabot>  120
15:13:07 <tibbe> hmm, If I want a part of a ByteString between two indicies do I use drop/take or is there a more efficient way?
15:14:14 <xerox> tibbe, you do, but internally it will not do what you think
15:14:37 <twanvl> that depends on what he thinks
15:15:50 <xerox> take and drop are O(1) on bytestrings
15:16:26 <xerox> splitAt is also O(1)
15:16:27 <inono> does anyone know if Haskell can be run on Palm?
15:16:41 <dmwit> What language are ByteStrings implemented in?
15:16:52 <glguy> haskell
15:17:36 <doserj> low-level, unsafe haskell...
15:21:37 <inono> does GHC compile to C?
15:21:57 <glguy> it *can*
15:21:58 <bos> it can.
15:22:06 <inono> so then I can compile something to C and then compile on any arch?
15:22:08 <bos> but by default, it generates asm on popular platforms.
15:22:22 <bos> not necessarily.
15:22:28 <inono> hows that?
15:22:32 <inono> i want to run haskell on palm
15:22:34 <kc5tja> inono: You will need to port the GHC runtime libraries to your arch first.
15:23:11 <bos> i'm pretty sure it has baked-in architecture details that are generated early during build.
15:23:14 <DRMacIver> Isn't it currently rather hard to get GHC working on nonstandard runtimes?
15:23:35 <bos> nonstandard runtimes?
15:23:38 <DRMacIver> err
15:23:40 <DRMacIver> architectures
15:23:43 <DRMacIver> Brain hiccup
15:23:44 <inono> so... haskell+palm yes or no?
15:23:46 <sorear> hello!
15:23:47 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
15:23:51 <sorear> @messages
15:23:51 <lambdabot> ndm said 7h 26m 26s ago: i needed an instance for Ppr Body, so i've added one calling pprBody True - if that will break things then let me know!
15:23:54 <bos> porting a compiler to any arch is usually a pain.
15:24:00 <DRMacIver> Hi sorear
15:24:13 <kc5tja> bos: If it generates C-- or plain-ANSI C, it can make assumptions.  As long as it doesn't depend on GCC-specific features, it'll still run (even if slowly) on other platforms.
15:24:24 <sorear> inono: the big problem is GMP
15:24:37 <sorear> inono: Yhc is presently *almost* working on Palm
15:24:52 <inono> YHC?
15:24:59 <sorear> inono: but GNU's portable multiprecision arithmatic library barfs on Palm
15:25:04 <sorear> York Haskell Compiler
15:25:04 <emu> i'm pretty sure ghc -fvia-C depends on gcc extensions
15:25:09 <sorear> it does
15:25:24 <kc5tja> Then GHC -> C-- -> ANSI C -> whatever.
15:25:29 <sorear> ghc -fvia-C -unreg is closer, but it still isn't quite portable (I'm told)
15:26:11 <DRMacIver> You could go via lambdavm if there's a JVM for your palm. :)
15:26:14 <sorear> every haskell compiler uses libgmp to implement Integer.  libgmp doesn't work on Palm.  If you can fix that, Yhc will work.
15:26:17 <DRMacIver> But I bet lambdavm doesn't work on J2ME
15:26:39 <inono> mm.. was toying with writing a compiler for a simple langauge in haskell, but it needs to run on palm
15:27:07 <DRMacIver> Why?
15:27:12 <sorear> @seen ndm
15:27:12 <lambdabot> I saw ndm leaving #haskell 1h 26m 47s ago, and .
15:27:23 <inono> well, cause the main target for the language would be palm..heh
15:27:40 <DRMacIver> inono: So? Why does the compiler need to run on the palm?
15:28:07 <inono> why not? :-)\
15:28:32 <kc5tja> Interactive development.
15:28:40 <kc5tja> It's a wonderful thing, really.
15:28:44 <tibbe> does map ($ a b) work the same way as map ($ a) would for a list of functions of two unapplied arguments?
15:28:44 <inono> exactly
15:28:47 <DRMacIver> Well your compiler doesn't have to run on the platform you're compiling to. I mean, it's useful, but it's by no means guaranteed. :)
15:29:06 <xerox> tibbe, no
15:29:14 <inono> DRMacIver, i would probably include an interpreter as well and do JIT
15:29:25 <DRMacIver> Ah
15:29:32 <DRMacIver> That's more of an issue then, yes. :)
15:29:40 <inono> and s/do/offer
15:29:47 <tibbe> xerox, darn
15:29:58 <tibbe> why can't it just read my mind
15:30:16 <xerox> ?type \a b -> map (($ b) . ($ a))
15:30:19 <lambdabot> forall a b a1. a1 -> a -> [a1 -> a -> b] -> [b]
15:30:27 <DRMacIver> tibbe: Just use the DWIMonad.
15:30:36 <tibbe> DRMacIver, ?
15:30:39 <inono> what is this forall ?
15:30:44 <DRMacIver> DWIM = Do What I Mean
15:31:05 <DRMacIver> Logically this involves external state, so should be wrapped in a monad. So... :)
15:31:15 <tibbe> :p
15:31:17 <xerox> inono, it just means 'for all a, b, and a1', where a, b, and a1 are variables that vary in the set of types.
15:31:36 <inono> meaning a,b,a1 can be anything?
15:31:37 <xerox> tibbe, that other code does that, though.
15:31:44 <xerox> inono, they can be any type.
15:32:02 <xerox> they can as well be the same type
15:32:04 <ddarius> Incidentally, ($ a b) means ($ (a b))
15:34:10 <rhz> How do I install/access the module C2HS in GHC?
15:37:16 <rhz> oh I think I'm looking for the Foreign module. Sorry..
15:40:31 <sjanssen> @yow!
15:40:32 <lambdabot> If I felt any more SOPHISTICATED I would DIE of EMBARRASSMENT!
15:41:36 <sjanssen> I've let the Haskell mailing lists get away from me ... 160 posts to read
15:42:13 <monochrom> 80 for me
15:42:31 <ddarius> Only 84 for me, but I'm only subscribed to haskell-cafe and haskell
15:42:45 <monochrom> And only because I ellided the entire "weaving" thread...
15:43:11 <DRMacIver> 0 for me. But only because I don't read the mailing lists. :)
15:43:32 <sorear> @slap DRMacIver
15:43:32 * lambdabot slaps DRMacIver
15:43:34 * monochrom gives DRMacIver a cookie.
15:43:43 <sorear> How dare you avoid suffering! :)
15:44:55 <DRMacIver> I'll start reading them once I've gotten around to writing my filter software (some time in 2015 probably). :)
15:46:13 <monochrom> Train and use a word-based Bayesian filter meanwhile.  Works for me.
15:46:32 <Excedrin> osbf-lua = best spam filter
15:46:35 <sjanssen> wow, this k-minima thread is huge
15:46:43 <sjanssen> any worthwhile posts?
15:47:02 <monochrom> I'm considering skipping k-minima too.  But I don't know what's inside at all.
15:47:02 <sjanssen> anything better than minima k = take k . sort?
15:47:19 <chessguy> sjanssen: some interesting discussions of runtime complexity of lazy algorithms
15:47:21 <sorear> the one where he says to the effect of "I don't believe you" to "head . sort is O(n)", maybe?
15:47:26 <chessguy> i didn't read them all
15:47:38 <DRMacIver> monochrom: Any suggestions? :)
15:47:44 <monochrom> bogofilter
15:47:46 <sorear> i read them all, but didn't remember ;)
15:48:09 <sjanssen> hmm, what's the complexity of that minima?  O(n log k)?
15:48:12 <chessguy> how would you describe the semantics of data S a = S a ?
15:48:22 <sorear> unary tuple
15:48:25 <monochrom> (amount you read) times (amount you remember) <= planck's constant.
15:48:30 <sorear> it only lifts
15:48:50 <Igloo> sjanssen: You can do it in O(n + k log k), as I describe in that thread
15:48:55 <monochrom> S a = a U {_|_}
15:49:28 <sjanssen> Igloo: with a max heap, eh?
15:49:35 <monochrom> In some books + is used instead of U.
15:49:53 <sjanssen> nah, that wouldn't work
15:49:54 <sorear> No, a min heap would be O(n + k log n)
15:50:45 <sjanssen> the solution I have in mind is O(n log k)
15:51:04 <rhz> Is it possible to pass a list of values to a foreign function via the FFI without using the IO monad?
15:51:30 <bos> only very basic values.
15:51:35 <tibbe> I'm feeling a bit stupid here, I'm trying to design a class Context which has one function "lookup" which I can instantiate with Map or [(a, b)]. how to write the class declaration?
15:51:37 <chessguy> isn't there a 'median of medians' algorithm for selections?
15:52:27 <chessguy> @type all
15:52:29 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
15:52:30 <bos> and in fact, if you're passing a list, almost certainly not
15:52:41 <sjanssen> class Context c a b | c -> a b where lookup :: a -> c -> Maybe b?
15:52:51 <monochrom> Regarding k-min.  Is the data already in a list?  Is the data already in an array?  They are very different.  Certain algorithms make such an assumption.
15:53:13 <sjanssen> instance Ord k => Context (Map k b) k b where lookup = Data.Map.lookup
15:53:18 <sorear> rhz: yes.
15:53:32 <rhz> sorear: how??
15:53:36 <sorear> rhz: this is the raison d'etre of unsafePerformIO
15:53:48 <bos> sorear: that's cheating :-)
15:53:56 <Igloo> monochrom: You can convert between the two in O(n) time, so it doesn't matter
15:53:57 <sjanssen> rhz: you'll have to use IO internally, but then wrap it with unsafePerformIO
15:54:08 <sorear> bos: no, the documentation says it exists for this very purpose
15:54:15 <bos> yeah, i know.
15:54:17 <sorear> every OTHER use of it is an abuse
15:54:26 <tibbe> sjanssen, thanks
15:57:40 <rhz> i see
16:03:21 <sjanssen> wow, busy on the xmonad list
16:03:48 <lennart> grrr, my mac irc client refuses to connect.  very strange
16:04:13 <sjanssen> I really like that other people do the support on the mailing list ;)
16:08:51 <chessguy> hmm, i wonder if propositional logic could be done as a monad
16:09:44 <DukeDave> well yes, the title 'propositional logic' isn't already scary enough is it ;)
16:09:58 <DukeDave> Hey kids we're doing 'monadic propositional logic'
16:10:01 <chessguy> bah, that's not scary
16:10:07 <chessguy> ok, that is
16:10:10 * DukeDave watches everyone die
16:11:14 <DukeDave> that aside, what are you thinking?
16:11:30 <chessguy> well, it could be some sort of MonadState
16:11:44 <chessguy> which contains the knowledge base
16:12:23 <chessguy> oh, there's a good man to talk to about propositional logic :)
16:12:41 <chessguy> hiya augustss
16:13:13 <DukeDave> ah that makes sense
16:13:32 <Saizan> what the state would carry? the valutation function for the terms?
16:13:43 <DukeDave> gah, why am I always in the mood for a hack when I've got 'marked' work to be doing :(
16:14:12 <augustss> howdy
16:14:16 <thorat> hey
16:15:12 <chessguy> augustss: i'm wondering if propositional logic could be modelled with a monad
16:15:16 <ddarius> monadic propositional logic would suggest something else altogether
16:15:30 <ddarius> Mind you, it wouldn't mean something else, just suggest it.
16:15:53 <chessguy> Saizan: it would contain the knowledge base (list of sentences known to be true), and maybe a list of symbols
16:16:12 <augustss> chessguy: why would you need a monad?
16:16:48 <augustss> chessguy: i'm sure you can, but i'm not sure why
16:16:49 <chessguy> and then you would have something like entails :: Sentence a -> Sentence a -> KnowledgeBase Bool
16:17:11 <augustss> What's a?
16:17:58 <chessguy> probably some type which indicates the symbols in the language
16:19:09 <dmead> chessguy: my prover does that
16:19:19 <dmead> not with monads i mean
16:19:20 <chessguy> e.g., data WumpusSymbol = Pit Int Int | Breeze Int Int | ...
16:19:27 <chessguy> dmead: link?
16:19:58 <dmead> darcs get http://taz.cs.wcupa.edu/~dmead/code/prover/
16:19:59 <lambdabot> Title: Index of /~dmead/code/prover
16:20:00 <augustss> propositional logic is trivial, so i'm not sure why you need to complicate it
16:20:08 <dmead> i think thats the latest version
16:20:23 <Saizan> inst a sentence in propositional logic just some "terms" connected with and, or,not, implies?
16:20:43 <bos> hmm, cabal-install needs to be librarified.
16:20:51 <augustss> Saizan: yes
16:21:17 <dmead> i got a nifty parsec configuration
16:21:46 <dmead> anExpr "P->Q" evaluates to a constructor statement
16:21:59 <Saizan> so i don't see why a monad would help
16:22:03 <dmead> it doesn't
16:22:20 <dmead> for propositional logic you just construct the knowledge base and see if nil is a member
16:22:25 <dmead> thats all
16:22:51 <chessguy> well, i was thinking of state so you could do ask/tell operations on the knowledge base
16:22:57 <chessguy> but then it's just state
16:23:14 <dmead> for resolution theorem proving?
16:23:29 <chessguy> and maybe learning
16:23:38 <dmead> it's not that complicated
16:23:41 <Dybber> Can anyone help me making this to a more functional style http://hpaste.org/1377? If possible. Isn't it very imperatively written?
16:23:42 <augustss> I don't know what you want to do, really.  But as I said, propositional logic is trivial.
16:23:57 <dmead> but in propositional logic you just search for nil in the knowledge base
16:24:01 <dmead> you don't really ask it anythinhg
16:24:21 <dmead> however, you can ask something of a knowledge base in first order logic
16:24:32 <augustss> Or you just figure out if the statement is true.  there are excellent algorithms.
16:24:44 <dmead> right
16:24:45 <chessguy> dmead: err...building your code gives "provermain.hs doesn't exist"
16:24:56 <dmead> uh oh
16:25:11 <dmead> hold on i'll correct that
16:25:19 <augustss> now predicate logic is a different matter.  then knowledge bases and other mystery stuff could be handy
16:25:51 <chessguy> is predicate logic different from FOL?
16:25:56 <dmead> chessguy, heres an excellent example
16:25:57 <dmead> no
16:26:00 <dmead> same thing
16:26:01 <dmead> http://www.rci.rutgers.edu/~cfs/472_html/Logic_KR/resolution.html
16:26:03 <lambdabot> Title: Resolution Theorem Proving
16:26:18 <dmead> theres also a prover on the haskell wiki that does FOL/predicate logic
16:26:26 <dmead> and i'm working on something similar
16:27:07 <dmead> chessguy, this is from the theorem prover section on the wiki
16:27:08 <dmead> http://www.cs.yale.edu/homes/cc392/report.html
16:27:09 <lambdabot> Title: First-Order Logic Resolution Theorem Prover In Haskell
16:27:18 <dmead> with that prover you can ask something of a knowledge base
16:27:51 <chessguy> oh yes, i've seen that. the "curiosity killed the cat" example is cute
16:27:55 <dmead> aye
16:28:08 <dmead> that parses regular language expressions though
16:28:21 <dmead> mine will just work on normal FOL formulas
16:28:52 <twanvl> Dybber: It doesn't look too imperative to me, I see no obvious ways to improve it.
16:29:46 <Dybber> twanvl, ok, thanks, its some C# code i've converted (just to learn haskell) and it looked very similar
16:29:46 <dmead> chessguy gnu make works fine with mine
16:30:03 <dmead> the cabal script is broken i expect
16:30:10 <chessguy> oh, i didn't try that
16:30:10 <dmead> just do "make" to build it
16:30:22 <chessguy> i just saw the Setup.lhs
16:30:26 <dmead> right right
16:30:30 <dmead> i have to remmeber to fix that
16:31:30 <chessguy> what are classes?
16:31:46 <dmead> propositional logic variables are also called classes
16:31:56 <dmead> because they refer to classes of objects
16:32:00 <Icebreaker> Hey all, I've got a question.
16:32:05 <dmead> Icebreaker, shoot
16:32:19 <Icebreaker> I just solved this series of puzzles: http://mathsnet.net/geometry/solid/houses.html
16:32:21 <lambdabot> Title: MathsNet Interactive Geometry: 3D
16:32:38 <Icebreaker> They were pretty good, but now, well, I'm out of puzzles to solve. ): Anyone got any other good ones?
16:32:42 <dmead> chessguy, try ./a.out check "(P->Q)&(Q->R)->(P->R)"
16:33:17 <sorear> dmead: by 'prover on the haskell wiki' I hope you're not referring to my prover?
16:33:23 <dmead> FOL?
16:33:36 <sorear> that one was written before I had any real idea of proving technology
16:33:42 <sorear> I still don't know what FOL was
16:33:48 <chessguy> dmead: umm, that hangs
16:33:53 <sorear> mine was implication + top level quantification
16:34:02 <chessguy> or maybe it's just taking a while
16:34:06 <sorear> like forall a b c . (a -> b) -> (b -> c) -> a -> c
16:34:12 <sorear> same class djinn handles
16:34:13 <dmead> it should be instantaneous
16:34:16 <dmead> ahh
16:34:17 <dmead> kewl
16:34:36 <dmead> ./a.out check "((P->Q)&(Q->R))->(P->R)"
16:34:36 <dmead> ((P->Q)&(Q->R))->(P->R) : Passed
16:34:41 <dmead> forgot a set of ()
16:34:46 <dmead> sorry, it's still in beta =)
16:35:15 <chessguy> ah, that worked
16:35:25 <dmead> if you load up ProverTest in ghci
16:35:32 <dmead> you'll see a bunch of test variables
16:36:10 <chessguy> oh, i'll have to get HUnit
16:36:13 <chessguy> ?where hunit
16:36:14 <lambdabot> http://hunit.sourceforge.net/
16:36:20 <chessguy> yuck
16:36:27 <dmead> it's on portage if you happen to be on gentoo
16:36:33 <dmead> you don't need it though
16:36:39 <sorear> it's also in apt
16:36:42 <sorear> and extralibs
16:36:51 <dmead> extralibs is fedora?
16:37:32 <chessguy> [andrew@localhost prover]$ ghci ProverTest.hs
16:37:32 <chessguy> ProverTest.hs:3:7:
16:37:32 <chessguy>     Could not find module `Test.HUnit':
16:37:32 <chessguy>       Use -v to see a list of the files searched for.
16:38:01 <dmead> by not need i mean you can comment out three lines
16:38:07 <chessguy> lol
16:38:14 <dmead> :P
16:40:00 <chessguy> i assume the test function comes from HUnit
16:40:32 <dmead> yes
16:41:09 <chessguy> Not in scope: `~:'
16:41:22 <dmead> from?
16:41:35 <chessguy> ProverTest.hs:103:25:
16:41:50 <chessguy> createProverTest a = a   ~: ("isTautology (anExpr" ++ a  ++ ")") ~: True ~=? isTautology (anExpr a)
16:42:11 <dmead> comment that line
16:42:19 <dmead> it uses HUnit
16:43:37 <DukeDave> Icebreaker, damn you, I was getting on with my work as well! ;)
16:44:09 <dmead> chessguy, standby...
16:44:19 <Icebreaker> Hahaha
16:44:31 <Icebreaker> You're welcome. (;
16:47:39 <rhz> Can I pass a module created using c2hs to ghci along with a shared library using -lmylib on the command line?
16:48:00 <chessguy> so FOL is a type of predicate logic, but not the only type?
16:48:05 <dmead> chessguy, add this line to ProverTest.hs
16:48:41 <dmead> showDatabase a = resolveDB(cnfdb (makeNeg (anExpr a)))
16:48:48 <dmead> and you can see the process in action
16:48:59 <dmead> FOL is the same thing as predicate logic
16:49:31 <dmead> propositional or set logic is below that
16:49:36 <chessguy> what do i pass showDatabase?
16:49:41 <dmead> one of the string variables
16:49:45 <dmead> try s25
16:49:48 <dmead> it's pretty long
16:50:46 <dmead> because nil is a member of that datbase
16:50:49 <chessguy> what is this list it returns?
16:50:56 <dmead> the knowledge base
16:51:23 <kolmodin> dons, dcoutts: I've got yet mail about being able to pick the endianess in binary
16:51:42 <dmead> calling each of those functions in that line might give you a better idea of the process
16:52:24 <kolmodin> perhaps we should bundle a monad transformer to do that... that's the simplemst way I've found to add stuff to binary, aye?
16:52:40 <dmead> chessguy: you'll notice that nil has come up the database
16:53:11 <dmead> finding nil via the resolution rule is equivilant to having False in a conjunction
16:53:19 <dmead> thereby rendering the enter expression false
16:53:35 <sorear> @botsnack
16:53:35 <sorear> GRR.
16:53:36 <lambdabot> :)
16:53:46 <dmead> remember that the expression that database represents is the negation of the original statement
16:53:51 <dmead> so the original is true by RAA
16:54:10 <dmead> (reducto ad absurdium, or proof by contradiction)
16:54:14 <sorear> hi kolmodin
16:54:34 <chessguy> hmm
16:55:25 <dmead> try conjunctive normal form
16:55:33 <dmead> cnf s25
16:55:38 <dmead> err rather
16:55:41 <dmead> cnf (anExpr s25)
16:56:09 <rhz> Is ghci compatible with the ffi?
16:56:21 <chessguy> nice
16:56:35 <Mitar> what does this warnings mean?
16:56:36 <Mitar> Defaulting the following constraint(s) to type `Integer'
16:56:36 <Mitar> 	     `Integral b' arising from use of `fromIntegral'
16:56:38 <dmead> the resolution rule is on line 55 of Prover.hs
16:56:48 <dmead> if your interested
16:56:55 <Mitar> in line: * pixelResolution) 0.0 (fromIntegral . truncate $ (fromIntegral height) * pixelResolution)
16:57:22 <chessguy> @karma+ dmead   thanks! interesting stuff
16:57:23 <lambdabot> dmead's karma raised to 4.
16:57:29 <dmead> ooo 4
16:57:30 <dmead> nice
16:57:39 <dmead> @karma dons
16:57:39 <lambdabot> dons has a karma of 133
16:57:45 <dmead> climbin the ladder!
16:57:46 <chessguy> hehe
16:57:54 <chessguy> @help karma
16:57:54 <lambdabot> karma <polynick>. Return a person's karma value
16:58:02 <chessguy> plynick?
16:58:05 <chessguy> +o
16:58:13 <dmead> maybe aliases
16:58:15 <monochrom> polynomial nick?
16:58:21 <sorear> rhz: yes
16:58:34 <sorear> aliases, yes
16:58:38 <dmead> rhz: did you get your C++ calls worked out?
16:58:47 <sorear> by analogy with polytypes
16:59:01 <sorear> it is a half-implemented feature
16:59:28 <sorear> the plan was to allow regexes, open aliases (@tell *xmonad this is broken), etc
16:59:45 <dmead> ahh
16:59:48 <sorear> I probably should remove the one thing that has been implemented se far
16:59:53 <sorear> @karma dons|sorear
16:59:54 <lambdabot> dons|sorear has a karma of 165
17:00:03 <sorear> that's all it does
17:00:09 <chessguy> @karma dons
17:00:10 <lambdabot> dons has a karma of 133
17:00:12 <chessguy> @karma sorear
17:00:13 <lambdabot> sorear has a karma of 32
17:00:16 <dmead> @karma dons|sorear|dmead
17:00:17 <lambdabot> dons|sorear|dmead has a karma of 169
17:00:22 <dmead> rockin
17:00:27 <SamB> dons|sorear++
17:00:29 <chessguy> i wonder why someone would want to know that
17:00:38 <jcreigh> @karma dons|sorear
17:00:39 <lambdabot> dons|sorear has a karma of 165
17:00:40 <rhz> dmead: Well I ported the library to C
17:00:40 <dmead> maybe that went along with the dev team idea
17:00:47 <chessguy> @karma+ dons|sorear
17:00:48 <lambdabot> dons|sorear's karma raised to 2.
17:00:52 <jcreigh> ???
17:01:11 <jcreigh> what's what about?
17:01:11 <chessguy> haha
17:01:11 <jcreigh> regex?
17:01:11 <dmead> rhz: i've done the C->C++ thing alot
17:01:11 <rhz> dmead: It wasn't a very complicated thing it mainly used stuff from iostream
17:01:12 <ddarius> jcreigh: It makes perfect sense.
17:01:12 <ddarius> (what is happening that is)
17:01:17 <dmead> ah
17:01:23 <dmead> do you still need help?
17:01:46 <dmead> if so, leave a message, it's food time :P
17:01:55 * dmead is away: hunting
17:02:32 <jcreigh> @karma dons
17:02:32 <lambdabot> dons has a karma of 133
17:02:35 <jcreigh> @karma sorear
17:02:36 <lambdabot> sorear has a karma of 32
17:02:51 <jcreigh> "sum the karma of all matching nicks"?
17:02:53 <jcreigh> @karma .
17:02:53 <lambdabot> . has a karma of 0
17:03:01 <sorear> yes
17:03:02 <jcreigh> @karma .*
17:03:03 <lambdabot> .* has a karma of 0
17:03:05 <sorear> no regexes
17:03:16 <bd_> @map karma users #haskell
17:03:17 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
17:03:19 <bd_> :(
17:03:21 <sorear> in retrospect that would be an obvious enhancement
17:03:27 <chessguy> @. karma elite "foo"
17:03:28 <lambdabot> "ph00" has a karma of 0
17:03:48 <chessguy> @. elite karma dons
17:03:49 <lambdabot> dONs H4z A x4RMA Oph 133
17:04:34 <kolmodin> ?karma
17:04:35 <lambdabot> You have a karma of 3
17:04:38 <kolmodin> :/
17:04:45 <chessguy> ?karma
17:04:45 <lambdabot> You have a karma of 6
17:04:50 <rhz> sorear: ghci is telling me: parse error on input `import'
17:05:02 <SamB> @. karma elite dons
17:05:03 <lambdabot> D0ns has a karma of 0
17:05:08 <rhz> on the line with foreign import ccall safe ..
17:05:22 <SamB> rhz: you put programs in files
17:05:41 <kolmodin> so I only do 1/40 of dons? that sucks
17:06:00 <rhz> SamB: What do you mean?
17:06:12 <ddarius> > 133 / 3
17:06:13 <lambdabot>  44.333333333333336
17:06:31 <kolmodin> you see, even less, argh!
17:06:44 <ddarius> @karma darius
17:06:45 <lambdabot> darius has a karma of 0
17:06:48 <ddarius> @karma ddarius
17:06:49 <lambdabot> You have a karma of 3
17:06:54 <rhz> ?karma
17:06:54 <lambdabot> You have a karma of 0
17:07:10 <SamB> rhz: you can't do foreign imports in the REPL
17:07:17 <SamB> you have to put them in a module and load that
17:07:25 <rhz> SamB: It is in a module
17:07:31 <SamB> ah.
17:07:33 <SamB> maybe -ffi
17:07:36 <rhz> but when I load the module in ghci it gives me an error
17:07:49 <SamB> or is it -fffi
17:07:57 <twanvl> I think both work
17:08:20 <Saizan> have you {-# OPTIONS -fffi #-} as the first line of your module?
17:08:31 <SamB> twanvl: I don't remember whether or not they changed it recently :-(
17:08:34 <rhz> -ffi helped.
17:09:51 <sorear> or even {-# LANGUAGE ForeignFunctionInterface #-}
17:09:54 <sorear> Both work.
17:11:53 <kolmodin> sorear: I prefer the LANGUAGE pragme
17:11:56 <kolmodin> -e+a
17:12:14 <monochrom> OPTIONS_GHC
17:12:32 <kolmodin> aye, OPTIONS is dephrecated
17:12:46 <kolmodin> and OPTIONS_GHC is .. um.. GHC specific
17:12:51 <monochrom> Yes.
17:13:02 <bos> http://www.toontalk.com/english/computer.htm
17:13:04 <lambdabot> Title: Computer scientists ask "What is ToonTalk?"
17:13:06 * Saizan is lazy, OPTIONS is the shorter one
17:13:11 <sorear> I really need to finish hv.
17:13:23 <sorear> Then people will lose the "Only ghc matters" excuse.
17:13:37 <Saizan> hv?
17:13:45 <monochrom> haskell vapour
17:14:02 <TomMD> ?google haskell vapour
17:14:05 <lambdabot> http://my.ece.ucsb.edu/arpan/patents_and_publications.htm
17:14:05 <lambdabot> Title: Patents and Publications
17:14:50 <kolmodin> right, that's it for me. g'night!
17:15:01 <sorear> haskell validator, actually
17:15:14 <sorear> lightweight hugs-killing C parser/typechecker
17:15:40 <dmead> hmm
17:15:45 <dmead> can you run it in a webpage?
17:15:51 <dmead> like that ruby demo thing
17:15:53 <Saizan> C?
17:15:53 <sorear> Good idea!
17:16:03 <Saizan> compiler?
17:16:16 <jcreigh> Saizan: Haskell parser/typechecker, writtin in C, I believe.
17:16:19 <dmead> Saizen: he means it's a haskell interpreter
17:16:30 <dmead> i think
17:16:39 <sorear> C: the implementation language of choice when constant factors matter.
17:16:53 <Saizan> oh
17:16:55 <sorear> which isn't often, but I'm pretty sure it applies here
17:17:13 <sorear> it parses and typechecks haskell, definitely won't interpret
17:17:23 <sorear> at best it will emit Yhc bytecode
17:17:36 <dmead> still pretty good
17:17:59 * monochrom attempts buffer overrun to hv
17:18:34 <ddarius> sorear: I'm missing the upshot.
17:18:36 <sorear> Nice try, but I've already implemented a re-usable growing buffer.
17:18:42 <sorear> GHC is *slow*
17:19:00 <ddarius> It's fast enough for parsing and typechecking.
17:19:02 <jcreigh> ddarius: think integrating with editors and whatnot.
17:19:06 <sorear> 0.7 seconds to start on reasonably high-end hardware...
17:19:18 <monochrom> I love you.
17:19:30 <sorear> ?
17:19:42 * sorear backs away slowly
17:19:42 <monochrom> I mean this:
17:19:45 <monochrom> sorear++
17:20:18 * ddarius is willing to bet that the end result will still suffer from buffer overruns.
17:27:11 <ariks> is pattern matching with cases pretty much equivalent to pattern matching with functions?
17:28:13 <int-e> yes
17:28:57 <int-e> in the sense that you could replace a case statement by a function with the obvious definition.
17:28:59 <sorear> exactly equivalent.
17:29:13 <sorear> the only difference is in parsing context
17:29:42 <sorear> 'a' : xs is a valid case pattern, but it must be expresssed as ('a' : xs) in a function pattern
17:30:09 <int-e> ok, I meant operationally.
17:30:16 <int-e> obviously the syntax has to change.
17:30:35 <sorear> operationally, afaik there is no difference whatsoever.
17:31:39 <ariks> yeah that's want i meant :), i wasn't sure if there was some insidiously subtle distinction that went over my head.
17:31:42 <ariks> thanks
17:31:57 <sorear> let has an insidiously subtle distinction, beware
17:32:04 <sorear> *let/where have
17:35:16 <dobblego> is that distinction explicitly noted somewhere?
17:36:08 <sorear> yes, I think
17:37:01 <int-e> all bindings done with 'let' or 'where' are irrefutable (lazy). So  let 0 = 42 in () results in () whereas  case 0 of 42 -> () results in bottom.
17:38:24 <ray> like on the website! where it says let 2+2=5 in 2+2
17:39:47 <monochrom> > let Just 10 = undefined in "whee"
17:39:49 <lambdabot>  "whee"
17:39:51 <monochrom> whee!
17:40:40 <dobblego> > case Just 10 of undefined -> "whee"
17:40:41 <lambdabot>  "whee"
17:40:59 <sorear> fun!
17:41:10 <rhz_> how do I convert from Double to CDouble and visa versa?
17:41:11 <sorear> note that undefined is a VARIABLE binding
17:41:19 <sorear> realToFrac
17:43:21 <Mitar> what means
17:43:23 <Mitar> This binding for `color' shadows an existing binding
17:43:25 <Mitar> 	     In the binding group for: color
17:43:52 <sorear> you are using -Wall and HOpenGL
17:44:11 <sorear> and you are defining a variable (possibly by let or function-parameter) named 'color'
17:44:41 <sorear> and there is a variable named 'color' with larger scope
17:44:59 <sorear> like most languages, haskell follows the innermost definition rule
17:45:11 <sorear> like most languages, haskell can warn about this
17:45:15 <monochrom> Your crystal ball is amazing.
17:45:20 <TomMD> Trying to make the switch from vim to emacs - how do I get emacs to use Haskell syntax highlighting and spacing?
17:45:29 <sorear> @where haskell-mode
17:45:29 <lambdabot> http://haskell.org/haskellwiki/Haskell_mode_for_Emacs
17:45:36 <TomMD> excellent
17:45:46 <sorear> then M-x haskell-mode
17:48:03 <sorear> @tell dons your stats script is still doing funny things with my stats
17:48:04 <lambdabot> Consider it noted.
17:48:17 <sorear> @uptime
17:48:18 <lambdabot> uptime: 9d 9h 37m 20s, longest uptime: 9d 9h 37m 20s
17:48:32 <sorear> Heh. I wonder if all this @flushing is keeping lambdabot alive
17:48:52 <sorear> it forces all the module states ... remember the bot is dying of space leaks
17:49:07 <DukeDave> Hey gang, off topic but causing me woe:  are any of you familiar with the fast fourier transform?
17:49:18 <sorear> yes.
17:49:27 <chessguy> i bet someone in #math is
17:49:33 <sorear> In fact, dons tried to get me to translate an ocaml fft to haskell.
17:49:50 <DukeDave> Ilol, I was about to ask in there but I got scared... I know this is a nice channel *_*
17:49:59 <sorear> I failed, but it was mostly just syntactic woes .... I understand the algorithm pretty well
17:50:04 <chessguy> lol
17:50:11 <sorear> ask away, we've been far more OT in the past :)
17:50:19 <DukeDave> well mine is a 'total misunderstanding' problem :)
17:50:21 <chessguy> #math isn't too bad. just make sure you actually ask your question, and not just whether anybody knows FFTs
17:50:24 <sorear> or if you're a wuss, #haskell-{overflow,blah}
17:50:49 <DukeDave> okay, so an fft converts from time domain to frequency domain right
17:50:51 <sorear> those channels are 'all the people of #haskell but without a topic'
17:50:57 <sorear> yes, or conversely
17:51:13 <DukeDave> so if I have a time domain 'sample' of e.g.,  [0 0 0 0 1]
17:51:19 <sorear> except for some constant factors the thransform is its own inverse
17:51:25 <larrythecow> is a Double just a floating point number?
17:51:28 <sorear> yes
17:51:52 <sorear> double precision IEEE floating point (but this isn't actually mandated in the h98 report)
17:52:09 <DukeDave> I'd expect to get a frequency sample which says something like "it's 1 per 5"
17:52:24 <sorear> what are you actually getting?
17:52:42 <sorear> btw, the cooley-tukey fft (most common type) only works on power-of-two sizes
17:52:47 <DukeDave> e.g. if I'm sampling every 10th of a second, it would be 2hz
17:53:02 <sorear> I don't recall if there is some kind of adjustment, but a size-5 probably isn't a valid fft
17:53:03 <DukeDave> well I'm playing around in Matlab, which has an fft function
17:53:25 <sorear> ok, matlab almost certainly has the wierd-size algorithms implemented
17:53:28 <DukeDave> ah, okay, that's interesting, some sample code we were given was trucating to 1024
17:53:34 <sorear> the do exist, they just get much less press :)
17:53:39 <DukeDave> heh
17:54:28 <sorear> but cooley-tukey is the most popular and most optimized (CPUs are optimized for Cooley-Tukey, not vice versa!) so use power of two sizes if you want maximum perf
17:54:51 <DukeDave> well if I evaluate  fft([0; 0; 0; 0; 1])
17:54:58 <sorear> anyway, remember that a pure frequency is a sign wave
17:55:12 <DukeDave> hmm, okay
17:55:21 <sorear> so that sharp square wave of yours will peak at 2hz, but there will be a LOT of harmonics
17:55:54 <knoppix_> aug cant seem to get lamdabot to compile a litle help maby
17:55:55 <knoppix_> ??
17:56:01 <DukeDave> explaining why I get a result of [1; 1; 1; 1; 1]
17:56:09 <DukeDave> I suppose?
17:56:30 <DukeDave> Gah, I just can't get my head around it
17:56:47 <sorear> er, impulses (due to wierd reciprocity reasons) have a broadband spectrum
17:56:58 <sorear> a click is equally loud at all frequencies
17:57:14 <sorear> you'll get something that makes more sense if you feed fft a sign wave
17:57:31 <sorear> fft([0; 1; 0; -1]) or similar
17:57:56 <sorear> btw, that is ML list syntax - is Matlab a full ML?
17:58:19 * sorear has never used it, and knows nothing except that it is a popular commercial CAS
17:59:08 <sorear> I don't fully grok why impulses transform the way they do
17:59:12 <DukeDave> looks right to me
17:59:32 <sorear> what, I said too much and can't id what you are replying to ;)
17:59:59 <DukeDave> the syntax of your Matlab expression ;)
18:00:01 <Excedrin> ML list syntax <> SML list syntax ?
18:00:37 <sorear> By ML list syntax I meant O'Caml list syntax.  It seems like it ought to be the same in the whole family.
18:00:40 <DukeDave> Hum, that (after removing the complex part) has give [0 4 0 4]
18:00:48 <DukeDave> *given
18:01:06 <sorear> looks good
18:01:10 <Excedrin> SML would use: fft [0, 1, 0, ~1]
18:01:25 <DukeDave> but that's just on frequency?
18:01:27 <DukeDave> *one
18:01:33 <sorear> it might be more legible in a larger samle
18:02:03 <sorear> > [ sin (x*2*pi) | x <- [0.0,0.1..0.99] ]
18:02:05 <lambdabot>  [0.0,0.5877852522924731,0.9510565162951535,0.9510565162951535,0.587785252292...
18:02:23 <sorear> > [ take 5 (show (sin (x*2*pi))) | x <- [0.0,0.1..0.99] ]
18:02:25 <lambdabot>  ["0.0","0.587","0.951","0.951","0.587","1.224","-0.58","-0.95","-0.95","-0.5...
18:02:39 <sorear> > intercalate ' ' [ take 5 (show (sin (x*2*pi))) | x <- [0.0,0.1..0.99] ]
18:02:41 <lambdabot>   Not in scope: `intercalate'
18:02:50 <sorear> > concat $ intersperse " " [ take 5 (show (sin (x*2*pi))) | x <- [0.0,0.1..0.99] ]
18:02:52 <lambdabot>  "0.0 0.587 0.951 0.951 0.587 1.224 -0.58 -0.95 -0.95 -0.58 -1.13"
18:03:00 <sorear> like that table
18:03:17 <sorear> > concat $ intersperse ";" [ take 5 (show (sin (x*2*pi))) | x <- [0.0,0.1..0.99] ]
18:03:19 <lambdabot>  "0.0;0.587;0.951;0.951;0.587;1.224;-0.58;-0.95;-0.95;-0.58;-1.13"
18:03:31 <Excedrin> is intercalate a word?
18:03:43 <sorear> yes, and a 6.7 function too!
18:03:48 <ddarius> @spell intercalate
18:03:48 <lambdabot> intercalate
18:03:49 <DukeDave> Haha, excelent hackery :)
18:04:11 <sorear> at least the biochem textbooks I've seen think it is a work
18:04:14 <sorear> *word
18:04:26 <ddarius> DukeDave: Lookup Nyquist Frequency
18:04:55 <DukeDave> ddarius, it just occured to me that might have something to do with it :)
18:04:58 <Excedrin> does it insert days in a calendar?
18:06:13 <ddarius> If you pad the end with some zeroes (a good amount say 45 more), the result will be slightly more sensical, especially if you plot the angle of the complex results.
18:09:12 <DukeDave> I have no idea what I'm looking at
18:10:43 <ddarius> Plot either the real or imaginary part of the result.
18:14:31 <ddarius> > let dft xs n = map (zipWith (*) cs) $ tails $ cycle xs where cs = map (\x -> Complex.cis (x/(2*n*pi))) [0..n] in map Complex.realPart $ dft (0:0:1:replicate 61 0)
18:14:32 <lambdabot>   Not in scope: `Complex.realPart'
18:15:12 <DukeDave> right, so I'm seeing this:      __/\_/\_______
18:15:13 <DukeDave> :)
18:17:12 <ddarius> Well, you should be seeing a sine wave with a frequency of 5/len or 5/(2len)
18:18:44 <DukeDave> Thanks for baring with my btw :)
18:19:04 <DukeDave> okay so I'm doing:    foo = fft([0.0;0.587;0.951;0.951;0.587;1.224;-0.58;-0.95;-0.95;-0.58;-1.13]);
18:19:22 <DukeDave> then to get the real part out:    foo = foo .* conj(foo);
18:19:48 <DukeDave> so now foo is a 1 by 11 matrix
18:20:14 <DukeDave> which peaks at indicies 1 and 10
18:27:33 <ddarius> DukeDave: So, that should say that you have something that is similar to a unit frequency sine wave.
18:28:35 <ddarius> The peak at 10 is kind of an artifact, any real input will lead to symmetry about the middle of the results.
18:28:41 <larrythecow> guys, since I'm new to compiled languages, what happens when I compile a program? I know it turns into an executable but what sort..? I use ghc. Does it turn into a .sh script or what?
18:29:15 <ddarius> It turns it into an executable file, like the actual bash program or any other actual program.
18:29:57 <monochrom> machine code
18:30:01 <larrythecow> ddarius: awesome, so I can open it and expect it to just run?
18:30:13 <monochrom> yes
18:30:21 <ddarius> You can type in ./myprogram and it should go.
18:30:23 <larrythecow> what is the command to run it? haskell <program>?
18:30:30 <larrythecow> oh just ./
18:30:32 <larrythecow> awesome
18:30:44 <ddarius> You just execute it like you would anything in bin.
18:30:48 <monochrom> In some settings, even just myprogram
18:30:58 <larrythecow> what if I make interpretted haskell script?
18:31:19 <larrythecow> how do I run that?
18:31:21 <rhz> ghci is passing corrupted arrays to my shared library via ffi
18:31:25 <ddarius> If you are using a GUI (i.e. KDE/Gnome), double clicking on it will probably execute it as well.
18:31:34 <monochrom> same.
18:31:41 <larrythecow> ddarius; yes I do usually use xfce.
18:31:50 <larrythecow> but sometimes just screen v. terminals
18:32:01 <DukeDave> ddarius, it was that part at the end which was confusing me, I'm starting to make sense of it now
18:32:02 <monochrom> Many ways to run a haskell program interpreted.
18:32:06 <DukeDave> thanks for you explanations
18:32:18 <larrythecow> monochrom: such as...?
18:32:21 <Excedrin> rhz: do you mean that ghc and ghci produce different results?
18:32:22 <monochrom> One way is "runhaskell myprogram.hs" or replace runhaskell by runhugs or runghc
18:32:32 <larrythecow> cool
18:32:51 <larrythecow> how do I make a haskell interpreted script anyway?
18:33:10 <rhz> Excedrin: I haven't tried it with ghc yet because I have no main function. I guess I ought to give that a try..
18:33:13 <monochrom> main = putStrLn "hello"
18:33:29 <monochrom> Put that line in a file myprogram.hs.  runhaskell myprogram.hs
18:33:42 <larrythecow> cool
18:33:43 <larrythecow> :)
18:33:45 <monochrom> You can also compile it.  No change to source code file.
18:34:18 <larrythecow> yes put interpretted is sometimes better. (eg; you can open it and read it, if you find a bug you don't have to recompile)
18:34:29 <monochrom> absolutely
18:34:44 <chessguy> well thanks for informing us :)
18:34:51 <larrythecow> mainly since I am a beginner I want to be able to read things.
18:35:20 <larrythecow> because if you learn to read a programming language then learning to program in it is much much faster, I have learnt.
18:35:39 <ddarius> DukeDave: The whole symmetry thing is related to the Nyquist frequency, which is the frequency at the middle of the graph.  If you sample uniformly 100 times, you can't tell a 30hz from an 80 hz frequency.
18:35:41 <larrythecow> anyway, thanks a lot guys.
18:35:50 <larrythecow> I'm going to go back to reading about haskell now.
18:35:50 <ddarius> www.dspguide.com has some good pictures and explanations.
18:35:51 <rhz> Excedrin: If I run it through ghc it just Seg faults..
18:36:01 <rhz> when I run the executable
18:36:24 <Excedrin> rhz: what kind of arrays are you using?
18:37:00 <sjanssen> rhz: can you paste the code?
18:38:16 <rhz_> on laptop now
18:38:27 <rhz_> I'll try to paste the code
18:38:40 <monochrom> The prospect of a programmer mistake cannot be dismissed yet.  Full disclosure of code is encouraged.  Reduction of code to five lines and still compilable by everyone else exhibiting the same problem is desirable.
18:39:17 <larrythecow> oh and I was just wondering, are there any good Haskell 3d capable game engines that can use blender models?
18:39:39 <DukeDave> Thanks ddarius, I'll have a read
18:39:48 <larrythecow> because making simple games that involve things you enjoy (making little 3d characters) also makes programming easier to learn for me.
18:39:50 <sjanssen> there is a rudimentary first person shooter in Haskell:
18:39:52 <sjanssen> @where frag
18:39:52 <lambdabot> http://www.haskell.org/haskellwiki/Frag
18:40:07 <larrythecow> oh okay
18:40:20 <chessguy> i've tried and failed to build that game, so good luck with it
18:40:23 <ddarius> DukeDave: Specifically, the hopefully obvious image on this page about aliasing.
18:40:26 <ddarius> http://www.dspguide.com/ch3/2.htm
18:40:29 <lambdabot> Title: The Sampling Theorem
18:40:43 <larrythecow> but no game engine? just a game engine that already has a game and is specific only to FPS? :\
18:40:52 <rhz_> what does the announce button do on hpaste.org?
18:41:05 <sjanssen> larrythecow: I don't know of anything like that
18:41:12 <TSC> Announces your paste here
18:41:15 <larrythecow> damn.
18:41:20 <sjanssen> rhz_: hpaste will say "rhz_ has pasted ..."
18:41:31 <larrythecow> oh well.
18:41:31 * SamB wonders if ZZT counts as a shooter...
18:41:37 <larrythecow> thanks guys
18:41:40 <hpaste>  rhz pasted "ffi trouble" at http://hpaste.org/1378
18:41:48 <rhz_> there we go
18:42:27 * chessguy gives frag a shot again
18:42:47 <sjanssen> mmm, you're using the FFI eh?
18:42:57 <rhz_> yes
18:43:03 <sjanssen> rhz_: this FFI stuff drastically increases the chances that it's your fault ;)
18:43:22 <rhz_> sjanssen: that is possible.
18:43:45 <rhz_> sjanssen: I was hoping for some assistance debugging
18:44:00 <chessguy> did Graphics.UI.GLUT get moved?
18:44:55 <rhz_> I've tried building frag too and it just crashes when I run it
18:44:57 <sjanssen> rhz_: can we see the original .chs too?
18:45:36 <chessguy> rhz_: i get complaints about it not being able to find GLUT
18:46:02 <rhz_> what does "annotate" do on hpaste?
18:46:32 <Mitar> i have a type defined like this: type GLdouble = Double
18:46:37 <chessguy> ?where opengl
18:46:37 <lambdabot> I know nothing about opengl.
18:46:40 <sjanssen> rhz_: makes a new "sub paste"
18:47:03 <hpaste>  rhz annotated "ffi trouble" with "the chs file" at http://hpaste.org/1378#a1
18:47:03 <Mitar> and my question is how can I convert from Double to GLdouble?
18:47:31 <rhz_> realToFrac I think..
18:47:49 <TSC> Mitar: They're the same type
18:48:08 <TSC> "type" makes an alias: two names for one type
18:48:22 <rhz_> the chs file is now pasted
18:48:27 <Mitar> hmm, how can i convert between float and double?
18:48:36 <rhz_> realToFrac I think..
18:48:43 <sjanssen> @hoogle fromRational
18:48:44 <lambdabot> Prelude.fromRational :: Fractional a => Rational -> a
18:48:51 <sjanssen> @src realToFrac
18:48:51 <lambdabot> realToFrac = fromRational . toRational
18:48:58 <sjanssen> yeah, realToFrac is the one
18:50:21 <monochrom> Please do not suspect that rhz_ is a bot programmed to answer "realToFrac I think.."
18:50:59 <Mitar> :-))
18:51:03 <Mitar> thanks
18:51:28 <rhz_> would not be a very useful bot
18:52:39 <sjanssen> rhz_: have you tried running this through gdb?
18:52:59 <rhz_> no
18:53:29 <rhz_> don't know much about gdb
18:53:42 <sjanssen> do you know how to get a backtrace out of it?
18:55:44 <hpaste>  rhz annotated "ffi trouble" with "backtrace" at http://hpaste.org/1378#a2
18:56:14 <rhz_> i think so... see the paste for the backtrace
18:58:06 <sjanssen> that backtrace seems to indicate that you've crashed inside Haskell code, not the C library
18:58:29 <rhz_> ok..
18:58:44 <sjanssen> oh wait, this is way simpler than I thought!
18:59:17 <sjanssen> rhz_: the C call isn't happening before you peek off the array
18:59:32 <rhz_> i thought something like that could be happening
18:59:34 <rhz_> laziness...
19:00:06 <sjanssen> yeah, you probably shouldn't be using the 'call' thing
19:00:41 <sjanssen> is there another c2hs directive similar to call that generates an IO function?
19:01:40 <sjanssen> rhz_: you're forgetting to free some of the stuff you allocate, by the way
19:02:09 <rhz_> yes true
19:02:41 <sjanssen> maybe it should just be 'call' instead of 'call fun'?  I really don't know c2hs well
19:02:59 <chessguy> ugh
19:03:37 <rhz_> well that puts the c function call inside the IO monad. That may solve this problem, but I don't want it inside the IO monad.
19:03:51 <sjanssen> rhz_: it must be, to guarantee sequencing
19:04:40 <sjanssen> is solve_gp supposed to be the nice Haskell wrapper around the lower level C function?
19:04:56 <rhz_> that is basically the idea..
19:05:20 <sjanssen> okay, then why shouldn't solve_simple_quadprog be in the IO monad?
19:05:40 <rhz_> good point
19:05:46 <sjanssen> you're already doing your marshaling in IO (with an unsafePerformIO around it)
19:11:24 <rhz_> Changed it as suggested. But still seg faults.. :(
19:11:53 <rhz_> the backtrace is the same.
19:12:05 <rhz_> looks the same
19:14:07 <sjanssen> so it's no longer "let result = ...", but "result <- ..."?
19:14:42 <rhz_> it is:    result <- {# call solve_simple_quadprog #} matArrArr vecArr (fromIntegral n) xArr
19:21:19 <rhz_> sjanssen: besides if your previous comment about it peeking the array before the c function is called was right it still wouldn't explain why the seg fault. Seg faults don't usually occur from reading from memory, only from writing to memory don't they?
19:21:50 <sjanssen> nah, a seg fault can happen when you read from invalid memory
19:25:30 <rhz_> If I put    print "hello" at the top of the do block then it seg faults before saying hello..
19:25:51 <sorear> hello!
19:25:56 <sorear> ouch, segfault
19:26:00 <rhz_> hi..
19:26:01 * sorear reads the @where logs
19:26:13 <sorear> rhz_: I just joined
19:26:20 <rhz_> ok
19:26:21 <sjanssen> rhz_: at the beginning of solve_qp?
19:26:29 <rhz_> yep
19:26:38 <sjanssen> humm
19:26:57 <rhz_> that might mean my ghc has bugs..
19:27:07 <dmead> or your C is wrong/ish
19:27:14 <dmead> can i take a look?
19:27:41 <rhz_> ok
19:27:59 <rhz_> but no.. the seg fault is occuring before it gets to the c function
19:28:06 <dmead> oh :o
19:28:10 <dmead> link?
19:28:20 * dmead is back (gone 02:26:26)
19:28:23 <sjanssen> http://hpaste.org/1378
19:28:29 <rhz_> maybe I build my shared library wrongly
19:28:42 <sjanssen> can link errors cause seg faults?
19:29:02 <rhz_> don't know.
19:29:16 <dmead> it can if one of the objects is out of date
19:29:21 <dmead> but then you'd get a linker error
19:29:22 <rhz_> Can I just give ghc the c source instead?
19:29:36 <dmead> i'm afraid that wouldn't work
19:30:20 <rhz_> seems like a reasonable thing to do
19:30:20 <dmead> post your .h?
19:30:25 <sorear> sjanssen: Yes, GNU LD has fancy features which under some fancy conditions can cause unresolved symbols to be fixed up to NULL.
19:30:37 <sorear> sjanssen: but that doesn't happen by defalt.
19:32:29 <hpaste>  rhz annotated "ffi trouble" with "SimpleQuadProg.h" at http://hpaste.org/1378#a3
19:33:13 <rhz_> theres the header
19:33:28 <dmead> seems reasonable enough
19:33:42 <dmead> and your objective is to build a haskell interface to your library right?
19:34:20 <dmead> can you write a test program in c++ to verify it's kosher?
19:34:32 <sorear> @type Foreign.newArray
19:34:35 <lambdabot> forall a. (Foreign.Storable.Storable a) => [a] -> IO (GHC.Ptr.Ptr a)
19:35:27 <sorear> style point, =<< is prefered over >>= in one-liners like your newArray line
19:35:40 <sorear> keeps the data flowing in the same direction
19:35:45 <sorear> @ty (=<<)
19:35:48 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
19:36:25 <sorear> I'm very wary of those realToFrac calls...
19:37:00 <rhz_> I've since modified the code a little bit
19:37:07 <sjanssen> sorear: why aren't those safe?
19:37:12 <rhz_> there is no >>= or =<<
19:37:25 <sorear> haha, found it
19:37:26 <sjanssen> no way realToFrac is causing a segfault
19:37:35 <rhz_> why c++?
19:37:55 <sorear>  double solve_simple_quadprog(double G[][MATRIX_DIM], double g0[], int n, double x[]);  -- expects an array of arrays, ie a single block of memory, ie a Ptr CDouble
19:38:17 <sorear>     matArrArr <- mapM newArray (map (map realToFrac) mat) >>= newArray  -- provides an array of pointers to arrays, a Ptr (Ptr CDouble)
19:38:23 <sorear> so, type error
19:38:34 <sorear> and the typechecker didn't catch it because of the FFI
19:38:44 <rhz_> but c2hs generates a type declaration with (Ptr (Ptr CDouble))
19:38:52 <sjanssen> c2hs generated incorrect code
19:38:58 <sorear> that would be a c2hs bug
19:39:04 <rhz_> ok..
19:39:09 <dmead>  ouch
19:39:22 <sjanssen> rhz_: for simple stuff like this, you can just use the FFI directly
19:39:30 <rhz_> yeah i suppose
19:39:44 <sjanssen> then you'll have the satisfaction of blaming yourself, instead of c2hs
19:39:49 <dmead> :P
19:40:35 <sorear> @flush to seq everything
19:40:41 <sorear> @users
19:40:42 <lambdabot> Maximum users seen in #haskell: 338, currently: 298 (88.2%), active: 36 (12.1%)
19:41:11 <sorear> still not up to where it was before it became demented :(
19:41:20 <fuzan> i see that the hpaste code doesn't follow most examples of using HAppS with XSL/XML. Is either method preferred over others?
19:41:32 <sjanssen> hey, I wonder if frequent @flush will combat lambdabots memory leak
19:41:53 <sjanssen> sorear: didn't dons mention that lambdabot has been running longer than usual?
19:41:56 <sorear> I thought of that a couple hours ago, which is why I'm doing it :)
19:41:59 <sorear> no, I did
19:42:04 <sorear> @seen dons
19:42:05 <lambdabot> dons is in #haskell-soc, #haskell-overflow and #haskell. I last heard dons speak 15h 29m 18s ago.
19:42:13 <rhz_> I guess my c is a bit rusty. Is an array of arrays just a pointer, not a pointer to a pointer?
19:42:17 <sorear> where is he?
19:42:20 <sorear> rhz_: correct.
19:42:22 <sjanssen> yeah, that coincides with your frequent @flushing
19:42:30 <TSC> An array of arrays is a pointer to (array[x])
19:42:31 <sjanssen> sorear: he's visiting the US
19:42:43 <dmead> rhz_ pointer arrays is nasty stuff
19:42:44 <sorear> ooh, the US!
19:43:00 * sorear didn't know rhz_ was a pointable type
19:43:06 <dmead> :P
19:43:17 <sorear> sjanssen: can you give an approx date of mentioning?
19:43:40 <dmead> rhz_, your program is in C or C++?
19:43:52 <sorear> they are the same in this regard
19:43:59 <fuzan> rhz_: any pointer in c is a "pointer".
19:43:59 <sorear> C
19:44:00 <sjanssen> sorear: I can't recall.  He's mentioned it a few times
19:44:02 <dmead> i know
19:44:05 <dmead> i'm wondering about his linkage
19:44:16 <sorear> dmead: C, since it wouldn't even have linked if he was using C++
19:44:33 <dmead> indeed, he was asking about C++ -> C wrapper the other day
19:44:37 <sorear> @seen meijer
19:44:38 <lambdabot> I saw meijer leaving #haskell 6h 51m 28s ago, and .
19:44:49 * sorear noticed the name in the logs
19:45:09 <dmead> ?
19:45:20 <sjanssen> sorear: hmmm
19:47:08 <nn-laptop> any one need a free server account on a server that has ghc6 installed
19:47:19 <fuzan> rhz_: generally, an array of arrays would be handled with a pointer that points to the first element of an array in which each element contains a pointer pointing to an array.
19:47:25 <sorear> dons.*visit isn't in the last week of logs
19:47:30 <sorear> fuzan: not in C!
19:47:34 <Excedrin> nn-laptop: sure
19:47:43 <sjanssen> sorear: grep for travel, perhaps?
19:47:45 <fuzan> sorear: how is that not how c does it?
19:47:54 <dmead> fuzan: at that point you should really be using the stdlib lists
19:48:04 <sorear> fuzan: it just isn't.  Are you asking how C does it?
19:48:22 * sorear can grep the draft C99 standard and provide anchors
19:48:35 <sorear> dmead: C stdlib has lists!?
19:48:39 <dmead> yea man
19:48:42 <fuzan> he asked for an array or arrays :)
19:48:43 <dmead> err
19:48:45 <dmead> C++ stdlib
19:48:46 <dmead> i mean
19:48:47 <dmead> :P
19:48:57 <sorear> ok, C++ stdlib IS a lot nicer :)
19:48:59 <nn-laptop> ok to get; it join the servers irc at srv256.homelinux.net port 6667
19:49:01 <dmead> C++ stdlib on gcc is actually quite nice
19:49:02 <fuzan> int *arr[10];
19:49:06 <dmead> but like nobody knows about it
19:49:09 <nn-laptop> ok to get; it join the servers irc at srv256.homelinux.net port 6667 , Excedrin
19:49:12 <fuzan> *(arr+i)
19:49:17 <sorear> fuzan: that's not an array of arrays
19:49:26 <sorear> this is an array of arrays:
19:49:31 <sorear> int arr[10][10];
19:49:41 <fuzan> i spose :)
19:49:43 <nn-laptop> Excedrin, join #account
19:49:43 <dmead> or a two dimentional array...
19:49:47 <dmead> :p
19:50:26 <sorear> nn-laptop: you might want to advertise this on the Wiki, so people who aren't awake atm can ask.
19:51:18 <fuzan> anyone play with happs much for web dev?
19:51:30 <rhz_> fuzan: that is what we established did not happen
19:51:36 <rhz_> (with arrays)
19:51:42 <sorear> fuzan: glguy
19:51:52 <sorear> fuzan: also, join #happs and ask in there
19:52:01 <fuzan> wasn't aware of its own channel.
19:52:04 <Korollary> isnt there a web dev mailing list?
19:52:10 <dmead> indeed there is
19:52:11 <sorear> fuzan: be prepared to wait a couple hours for a reply :)
19:52:25 <dmead> theres also some talk on haskell-cafe about web stuff
19:52:26 <Korollary> The mailing lists are excellent
19:52:33 <sorear> I'm not subscribed to it.  Therefore, few others probably are too.
19:52:33 <dmead> the guy doing the web interface to gnuplot is using happs
19:53:03 <sorear> happs isn't big enough to warrant separating off the community yet IMO
19:53:41 <fuzan> i was just playing with it, and had written a little toy using XSL/XML and then noticed how HPaste wasn't.
19:53:57 <fuzan> not sure if it's for any technical reasons
19:54:01 <dmead> wasnt in happs?
19:54:26 <fuzan> it's happs, it's just not generating XML
19:54:39 <fuzan> and some fo the tutorials do
19:54:40 <sorear> sure it is!
19:54:46 <sorear> well, sgml at least
19:54:50 <fuzan> ya
19:55:10 <fuzan> i'm not aware of the techincal advantages of using either
19:55:12 <fuzan> or browser support
19:55:31 <rhz_> it works now. thanks for all the debugging help..
19:55:38 <sorear> yw
19:55:58 <sorear> fuzan: the xslt is done server side, unless the client doesn't support it
19:56:18 <sorear> I use unless quite deliberately, since it just gives raw xml to elinks :(
19:56:26 <dmead> ah
19:56:50 <sjanssen> sorear: huh, that's weird
19:57:00 <fuzan> yah, from what i've noticed it generates XML docs, and the client renders according to the xsl
19:58:35 <dmead> so when are we gonna see the equivalent of ruby on rails or python on planes?
19:58:36 <dmead> ie
19:58:39 <dmead> haskell on heat?
19:58:42 <dmead> haskell in heat?
19:58:47 <dmead> hmm
19:58:59 <sjanssen> "in heat" has an awkward meaning ...
19:59:00 <dmead> haskell from hell?
19:59:03 <dmead> :P
19:59:09 <rhz_> so does on heat..
19:59:23 <dmead> whats another noun thats go to do with being awesome?
19:59:24 <sjanssen> Haskell packing heat
19:59:27 <dmead> oo
19:59:28 <dmead> nice
20:00:14 <fuzan> glguy_: :)  why did you decide not to use XML in hpaste?
20:00:18 <sjanssen> don't mess with that framework, it'll shoot you
20:00:53 <rhz_> for some reason ghc --make isn't producing an executable for me anymore.
20:01:03 <sorear> we must not try to take over the world too quickly, our arrogance will haunt us!
20:01:11 <sorear> rhz_: that happens when you don't have Main.main
20:01:18 <sorear> yes it MUST be in module Main
20:01:19 <sjanssen> @remember sorear we must not try to take over the world too quickly, our arrogance will haunt us!
20:01:20 <lambdabot> Done.
20:01:32 <dmead> @remember haskell packing heat
20:01:32 <lambdabot> Done.
20:01:37 <sorear> @quote haskell
20:01:37 <lambdabot> haskell says: packing heat
20:01:51 <fuzan> haha
20:01:53 <sorear> @remember sjanssen Haskell packing heat
20:01:53 <lambdabot> Done.
20:01:58 <dmead> ah
20:01:58 <sorear> @flush
20:02:38 <dmead> hmm
20:02:45 <dmead> whats a word having to do with transportation that starts with h?
20:02:54 <sjanssen> helicopter
20:02:56 <sjanssen> highway
20:03:03 <sorear> "haskell on hangars" has been used many times
20:03:04 <dmead> hmm
20:03:11 <dmead> haskell on helicopters?
20:03:15 <dmead> is pretty tight
20:03:19 <dmead> and goes with ruby on rails
20:03:23 <dmead> or python on planes
20:03:23 <sorear> hydroplanes?
20:03:34 <dmead> hmm
20:03:34 <dmead> no
20:03:37 <dmead> too verbose
20:03:54 <dmead> and planes is taken
20:04:09 <sorear> hyperdrives?
20:04:16 <dmead> i dunno...
20:04:19 <sorear> Haskell on hyperdrive!
20:04:23 <sjanssen> Haskell jumps to hyperspace
20:04:25 <dmead> i think helicopters fits the motif pretty good
20:04:31 <rhz_> oh then maybe I was presumptuous in saying it was working..
20:05:17 <dmead> ah yes, a common mistake
20:05:17 <sjanssen> Haskell does the Kessel run in twelve parsecs
20:05:27 <dmead> :P
20:06:28 <sorear> "Haskell in hyperspace" should be able to run Kessel in ZERO parsecs?
20:06:54 <dmead> nice one
20:07:23 <dmead> but i'm pretty sure lucas uses a parsec in the wrong context :P
20:07:31 <dmead> solo seems to mean time when he says that
20:07:33 <araujo> hello
20:07:37 <dmead> but parsecs is distance =/
20:08:02 <sorear> no, parsec is a parser library.  :)
20:08:16 <dmead> :P
20:08:37 <dolio> It's the ship that made the Kessel run in less than twelve parsecs.
20:10:32 <rhz_> ok. It's not seg faulting any more. It almost works. It's just zeroing out random entries in the array of arrays for no apparent reason. But I'm starting to get worn out by debugging it...
20:11:14 <shachaf> Haskell in Hiding?
20:12:21 <dmead> well
20:12:27 <dmead> MAYBE thats current...
20:12:28 <dmead> :P
20:14:50 <rhz_> I just used concat on my list of lists and then newArray to convert it into an array. But I'm not sure if that is right.
20:15:58 <sorear> @flush
20:16:08 <sorear> rhz_: that's right, but error prone
20:16:21 <rhz_> error prone?
20:16:26 <sorear> if your matrix isn't actually square, you'll get Nasty Indexing Bugs
20:16:29 <sjanssen> sorear: are you going to start doing that ever 15 minutes?
20:16:35 <rhz_> it is square
20:16:36 <sorear> yes!
20:16:44 <sorear> possibly in /msg
20:16:45 <dmead> umm
20:16:56 <dmead> couldnt you set up a timer on lambdabot to @flush itself?
20:17:06 <sjanssen> sorear: should probably just get that functionality in lambdabot
20:17:10 <dmead> hopefully it won't go blind
20:17:18 <sorear> The chances of that going in are neglible.
20:17:21 <sorear> @let x = 2
20:17:24 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
20:17:34 <sorear> that bug has been fixed in the source for over a month.
20:18:12 <sorear> if five broken plugins that can't be worked around won't motivate dons to recompile, fixing a comparative annoyance like this ... forget it.
20:22:29 <rhz_> @x
20:22:30 <lambdabot> Maybe you meant: . v
20:22:50 <sorear> > x
20:22:51 <lambdabot>   Not in scope: `x'
20:22:57 <sorear> see, not @letted
20:23:24 <rhz_> @let sdf = 3
20:23:26 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
20:23:45 <dolio> That wouldn't work anyway, would it? It'd need to be:
20:23:49 <dolio> > L.x
20:23:50 <lambdabot>   Not in scope: `L.x'
20:24:04 <sorear> actually that was fixed, iirc
20:24:12 <dolio> Oh. Nice.
20:24:17 <rhz_> @print "hello"
20:24:18 <lambdabot> Not enough privileges
20:24:22 <rhz_> >print "hello"
20:24:26 <rhz_> hmm
20:24:36 <dmead> no io for you!
20:25:19 <rhz_> @"hello"
20:25:19 <lambdabot> Unknown command, try @list
20:25:29 <rhz_> >@list
20:25:33 <rhz_> @list
20:25:33 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
20:25:46 <sorear> rhz_: there MUST be a space after the >
20:26:03 <sorear> so all your commands so far have been just random text lambdabot ignores.
20:26:15 <rhz_> > print "hello"
20:26:16 <lambdabot>  <IO ()>
20:26:22 <rhz_> ok
20:26:45 <sorear> lambdabot has a special show instance that catches stuff like that
20:26:48 <sorear> > 2 + 2
20:26:50 <lambdabot>  4
20:26:50 <sorear> fantasmaa: hi
20:26:58 <sorear> fantasmaa: you've been looked for
20:27:10 <sorear> fantasmaa: such a shame you came when dons was traveling
20:27:10 <dolio> > Foreign.unsafePerformIO (print "hello")
20:27:11 <lambdabot>   Not in scope: `Foreign.unsafePerformIO'
20:27:15 <dmead> whats is lambdabot essentially?
20:27:22 <dmead> and subset of ghci?
20:27:23 <sorear> @where lambdabot
20:27:24 <lambdabot> Right here! Seriously, though: http://www.cse.unsw.edu.au/~dons/lambdabot.html
20:27:24 <fantasmaa> sorear: hello, sorry
20:27:26 <sorear> it's a bot
20:27:41 <sorear> ghci is NOT used directly
20:27:42 <dmead> right, but how does it eval haskell expressions?
20:27:43 <dmead> ah
20:27:45 <sjanssen> hey fantasmaa
20:27:55 <fantasmaa> hey :)
20:27:57 <sorear> dmead: it forks an interpreter
20:28:07 <sjanssen> fantasmaa: could we set up a redirect on xmonad.org?
20:28:20 <fantasmaa> ah sure
20:28:29 <sjanssen> cool
20:28:34 <fantasmaa> what do you want it to point to
20:28:37 <sjanssen> I'm not a 100% on the URL yet, though
20:28:37 <dmead> aah
20:28:42 <rhz_> > :m Foreign
20:28:43 <lambdabot>  Parse error
20:28:57 <fantasmaa> sjanssen: I will be getting a dedicated server soon
20:29:15 <sjanssen> fantasmaa: whoa, you're getting a dedicated server for xmonad.org?
20:29:16 <fantasmaa> at that point you can do everything you want on there if you'd like :)
20:29:32 <fantasmaa> that and some other sites + services
20:30:40 <sjanssen> fantasmaa: is this the sort of thing that we could give accounts to a couple people?  I'd like to be able to edit the website when needed
20:30:45 <wy> I found Haskell's I/O too complex for a simple job
20:30:56 <fantasmaa> sjanssen: of course
20:31:03 <sjanssen> wy: oh?  complex in what way?
20:31:14 <dmead> wy: i agree, but say la vee
20:31:21 <dolio> Heh.
20:31:29 <dmead> if you've got simple stuff to do haskell is not a good choice
20:31:30 <wy> I just need to read a text file of numbers and store them into integer binary format.
20:31:45 <rhz_> nah the FFI is still buggering up my array of arrays
20:32:12 <dmead> wy: IO is like the last thing you learn in haskell (for most people)
20:32:22 <dmead> wy: just use a ghci session and emacs
20:32:26 <dmead> and bind your test variables
20:32:37 <wy> dmead: yes. but I must learn it now.
20:32:52 <sorear> rhz_: Lambdabot is NOT GHCI, it just interprets expressions.  Not declarations, not :-commands, not imports.
20:32:56 <sjanssen> fantasmaa: could I get your email address if I need to contact you about setting up a redirect (xmonad 0.1 should be out soonish, and we'll want to tweak the website before then)
20:32:58 <sorear> C-x C-l
20:33:03 <wy> The data is from a huge matlab .mat file.
20:33:11 <rhz_> sorear: ok
20:33:14 <fantasmaa> sjanssen: can I pm you it?
20:33:23 <sjanssen> fantasmaa: that'd be great
20:33:28 <dmead> wy: so? bind it to a variable
20:33:51 <sorear> wy: so you want to convert 120\n123\n64 into "\120\123\64" ?
20:34:19 <wy> sorear: Yes. I also need to do some calculation with the numbers.
20:34:31 <dmead> what class is this for :P
20:34:38 <wy> sorear: It seems there is nothing as easy as scanf() in C.
20:34:47 <sorear> sure there is, read
20:35:06 <sjanssen> wy: readLn
20:35:14 <sorear> you want "interact $ map (toEnum . read) . lines"
20:35:29 <sorear> main = interact $ map (toEnum . read) . lines
20:35:32 <wy> sorear: Do I first need to get the string from the file?
20:35:41 <sorear> that's what interact is for!
20:35:46 <sorear> @type interact
20:35:49 <lambdabot> (String -> String) -> IO ()
20:36:34 <wy> sorear: I don't quite understand. How do I use interact?
20:37:13 <sorear> try "ghc -e 'interact $ show' at a shell prompt.  Type something.  Type an eof.
20:37:35 <sorear> Any explanation would be less clear than a demonstration
20:37:39 <dmead> wy: http://www.haskell.org/~pairwise/intro/intro.html
20:37:41 <lambdabot> Title: Haskell for C Programmers
20:37:51 <sorear> you write a pure function, and interact turns it into a UNIX filter
20:40:42 <wy> sorear: I need more manipulation with the numbers. Actually I just want to convert the text file from matlab to binary format. Then each time read the binary format in to do some processing.
20:41:28 <aaronp> wy: You could use readFile instead of interact.
20:41:36 <aaronp> @type readFile
20:41:39 <lambdabot> FilePath -> IO String
20:42:46 <sorear> getContents is better than readFile
20:42:55 <sorear> @type getContents
20:42:58 <lambdabot> IO String
20:43:09 <sorear> makes your code easier to use, no need to edit filenames
20:45:27 <wy> sorear: I got the string. So how to I parse the numbers into integers?
20:46:22 <dolio> > map read . lines $ "1234\n834\n395\n8349\n"
20:46:24 <lambdabot>  [1234,834,395,8349]
20:46:41 <dmead> > :t lines
20:46:42 <lambdabot>  Parse error
20:46:49 <dmead> ?src lines
20:46:49 <lambdabot> Source not found. The more you drive -- the dumber you get.
20:46:59 <dmead> ?type lines
20:47:01 <lambdabot> String -> [String]
20:47:02 <dmead> o0
20:47:03 <dmead> ah
20:47:21 <dmead> >read "2+2"
20:47:25 <dmead> > read "2+2"
20:47:26 <lambdabot>  Exception: Prelude.read: no parse
20:47:26 <sorear> @ty map read . lines
20:47:26 <sorear> *drum drum*
20:47:26 <sorear> can anyone other than lambdabot hear me?
20:47:29 <lambdabot> forall a. (Read a) => String -> [a]
20:47:29 <dmead> > read "22"
20:47:31 <lambdabot>  22
20:47:40 <dmead> i can
20:47:52 <dolio> I heard those last three lines.
20:47:55 <wy> But I have a IO String now.
20:48:08 <sorear> I hate it when that happens.
20:49:00 <sorear> IO String is an action that when performed, gives a string.
20:49:10 <sorear> Surely you want a larger action!
20:49:19 <sorear> So you need to combine actions with >>=
20:49:30 <sorear> and/or fmp
20:49:33 <sorear> *fmap
20:49:41 <sorear> fmap :: (a -> b) -> IO a -> IO b
20:49:53 <sorear> @typ fmap (map read . lines) getContents
20:49:55 <lambdabot> forall a. (Read a) => IO [a]
20:50:15 <sorear> Now, this large raction reads a bunch of <anything>.
20:50:26 <glguy> fuzan: I don't get it, why would I use XML in hpaste?
20:50:27 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
20:50:50 <sorear> Now, you wanted to turn these into bytes.  (going back to the original w/o interact, for didactic purposes)
20:51:00 <sorear> @typ (map read . lines) `fmap` getContents
20:51:03 <lambdabot> forall a. (Read a) => IO [a]
20:51:17 <sorear> @typ ((map toEnum . map read . lines) `fmap` getContents)
20:51:18 <wy> Anyone here has experience about Matlab? I want to let it to output binary data, but it only output ascii.
20:51:20 <lambdabot> forall a. (Enum a) => IO [a]
20:51:35 <sorear> adding an extra stage to the map, we can make any enum.
20:51:39 <sorear> Now, we use
20:51:49 <sorear> (>>=) :: IO a -> (a -> IO b) -> IO b
20:51:56 <sorear> @typ ((map toEnum . map read . lines) `fmap` getContents) >>= putStr
20:51:58 <lambdabot> IO ()
20:52:23 <sorear> so by using the IO Combinators fmap and >>=, we can build a complete action that does something useful.
20:52:41 <sorear> you don't actually need fmap
20:52:54 <sorear> fun `fmap` act === act >>= \x -> return (fun x)
20:52:56 <sorear> where
20:52:59 <sorear> return :: a -> IO a
20:53:10 <sorear> makes no-op actions, useful for things like this
20:53:21 <sorear> do notation is Just Syntax Sugar
20:53:51 <sorear> @undo do { str <- getContents; let str' = map toEnum (map read (lines str)) ; putStr str' }
20:53:52 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 85}) "Parse error"
20:54:13 <sorear> @undo do { str <- getContents ; let { str' = map toEnum (map read (lines str)) } ; putStr str' }
20:54:14 <lambdabot> getContents >>= \ str -> let { str' = map toEnum (map read (lines str))} in putStr str'
20:54:32 <wy> sorear: Where does the file name go?
20:55:13 <sorear> you know how to redirect stdin?
20:55:15 <fuzan> glguy: my question to you is why didn't you? :)
20:55:25 <wy> sorear: not yet
20:56:01 <sorear> OK, most UNIX programs read from a distinguished file called 'stdin'
20:56:13 <sorear> by default this is actually the keyboard
20:56:13 <wy> sorear: Actually I want to put the file name into the program
20:56:28 <sorear> if you type 'cat', it shows you everything you type
20:56:30 <wy> I don't want it to be a filter.
20:56:37 <sorear> why not?
20:56:43 <sorear> but you can change where stdin comes from
20:56:49 <sorear> 'cat < MyFile.hs'
20:57:00 <sorear> that will display the contents of MyFile.hs
20:57:28 <fantasmaa> redundant
20:57:32 <wy> Let's say we now have the string from readFile. What should I do?
20:57:51 <sorear> use it to build a larger action
20:58:01 <sorear> readFile "foo" reads foo, and returns it
20:58:19 <sorear> putStr <arg> prints <arg>, and returns ()
20:58:22 <wy> My program looks like this: main = do contents <- readFile "test.txt"
20:58:28 <wy> What do I add to it?
20:58:38 <sorear> readFile "foo" >>= putStr   reads foo, and prints it, and returns ()
20:58:54 <sorear> @google do notation considered harmful
20:58:57 <lambdabot> http://syntaxfree.wordpress.com/2006/12/12/do-notation-considered-harmful/
20:58:57 <lambdabot> Title: Do-notation considered harmful « Data.Syntaxfree
20:59:32 <wy> sorear: Do you think it's harmful?
21:00:14 <sorear> yes.
21:00:41 <fantasmaa> sorear you replaced ``do'' with a monad?
21:00:58 <wy> sorear: But I also read an article named " 'considered harmful' articles are considered harmful" ;-)
21:01:27 <dolio> Well, that's obviously self-refuting, so you can ignore it. :)
21:01:35 <desp> :D
21:02:22 <sorear> fantasmaa: no, I replaced an invisible monad with a visible one.
21:02:41 <sorear> would you rather run from/fight an invisible lion or a visible one?
21:02:53 <fuzan> xml vs sgml, what do yo'all preer?
21:02:54 <fantasmaa> well, ignorance is bliss
21:02:56 <fuzan> prefer
21:03:23 <sorear> S EXPRESS10NS F0RE\/ER!!!!
21:03:37 <wy> sorear: So now I have main = readFile "test.txt" >>= putStr. What do I add to it in order to get the numbers into a list?
21:03:46 <sorear> XML, if those are my only two options
21:04:03 <fantasmaa> wy: are you trying to solve a project euler problem by any chance? :D
21:04:15 <sorear> main = print . lines =<< readFile "test.txt"
21:04:28 <fuzan> sorear: what do you prefer?
21:04:38 <sorear> =<< is just flip >>=, it makes the data flow clearer imo
21:04:46 <sorear> <sorear> XML, if those are my only two options
21:04:46 <fuzan> sorear: i want to write a little HAppS app, but I'm not comfortable choosing my output
21:04:57 <sorear> oh, HTML
21:05:13 <sorear> since XML output is broken for my user agent of choice
21:05:49 <fuzan> sorear: it says that HAppS can detect usually if XML is uncompatable with client browsers and output the generated xhtml
21:05:54 <fuzan> sorear: is that true?
21:06:03 <wy> sorear: I guess I need something like scanf, because each line of the file is like "number1, number2".
21:06:51 <sorear> fuzan: it exists in theory, but it is broke
21:07:04 <fantasmaa> wy: I wrote a program to input a comma delimited list of numbers into a list
21:07:05 <sorear> elinks is mis-detected as a XML capable browser
21:07:23 <fuzan> ah
21:07:32 <fantasmaa> wy: want me to dig it up?
21:07:46 <wy> fantasmaa: Yes. Thanks.
21:11:52 <hpaste>  fantasma pasted "wy this might help" at http://hpaste.org/1379
21:12:47 <sorear> stefan@stefans:~/cadt/src$ /usr/bin/happy Parser.y
21:12:48 <sorear> happy: parE
21:12:54 <sorear> error message of the day!
21:13:07 <Korollary> parE? wtf
21:13:33 <sorear> yes, that's what it said.
21:13:42 <sorear> and exitted 1
21:15:03 <fantasmaa> wy: the lines function probably isn't important for your text file -- the words function is however
21:17:15 <wy> fantasmaa: I got it. Thanks very much.
21:17:49 <petekaz> Which is preferable?  Data.Map or Data.HashTable
21:18:31 <dolio> I'd say Map.
21:18:38 <Korollary> It depends on the data
21:18:41 <thoughtpolice> if i have a list of a datatype, many of the elements different constructors of the datatype, does anybody know of a realiable way directly extract elements based on the constructor? Or some way of pulling the elements out and keeping their data in tact.
21:19:01 <thoughtpolice> i'm using System.Console.Getopt and I need to take the list of flags it returns back and put it in another data structure.
21:19:52 <sorear> Map, by far.
21:20:04 <sorear> filter
21:20:04 <petekaz> ok ... thanks.
21:20:20 <Korollary> what is the rationale for that?
21:20:49 <petekaz> I'm just trying to write Norvig's 20-line Python spell checker in Haskell as an exercise.
21:20:50 <sorear> Map is pure functional, no IO hoops
21:21:00 <wy> sorear: I remember someone told me not to use hashtables in Haskell. Is that you?
21:21:06 <sorear> probably.
21:21:17 <fantasmaa> @quote hashtable
21:21:17 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
21:21:30 <sorear> dons says Data.HashTable is much slower than a naive hand-coded impl.
21:21:49 <Korollary> somebody ought to fix that
21:22:21 <fantasmaa> I nominate you
21:22:36 <Korollary> duly noted
21:22:50 <Korollary> could be a SoC kind of thing
21:23:19 <sorear> that's next year :)
21:23:26 <wy> sorear: What's the algorithm in Data.Map using? Is it a hashtable or balanced tree?
21:24:17 <fantasmaa> are all the SoC project taken?
21:24:20 <TSC> Balanced binary tree
21:24:21 <sorear> balanced tree.
21:24:29 <sorear> *rech*
21:24:34 <sorear> How old is happy?
21:24:47 <sorear> it obviously predates monads :?
21:24:51 <sorear> * :/
21:25:09 <wy> So the insertion can't be as fast as a hashtable
21:25:22 <fuzan> :t plain
21:25:25 <lambdabot> Not in scope: `plain'
21:25:27 <sorear> it can be faster.  hashtables have poor locality.
21:26:19 <wy> Do we have arrays in Haskell?
21:26:48 <TSC> Yes, Data.Array*
21:27:01 <sorear> I hesitate to say it, but yes.
21:27:17 <ulfdoz> .oO( Homework at saturday 6:26... )
21:27:29 <sorear> Don't optimize prematurely.
21:28:22 <sorear> So here I find myself debugging happy itself.  Sigh.
21:30:40 <wy> How can I convert a number from Double to Int?
21:30:56 <TSC> @type truncate
21:30:58 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
21:31:40 <TSC> Depends how you want to covert; truncate might be sufficient
21:31:50 <dmwit> There's also floor and ceiling.
21:31:56 <TSC> Or round
21:32:07 <dmwit> :t round
21:32:10 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
21:32:13 <sorear> And even unsafeCoerce#
21:32:29 <dmwit> Oh, I thought I remembered round taking a number of digits to round to.
21:32:43 <sorear> Only use at Double# -> Word64# if you value your type safety :)
21:32:45 <dmwit> ?hoogle Double -> Int -> Double
21:32:46 <lambdabot> No matches, try a more general search
21:33:06 <dmwit> ?hoogle (Real a, Integral b) => b -> a -> a
21:33:08 <lambdabot> Prelude.const :: a -> b -> a
21:33:08 <lambdabot> Prelude.seq :: a -> b -> b
21:33:08 <lambdabot> Control.Parallel.par :: a -> b -> b
21:33:46 <sorear> I think I'll spend the next couple weeks modernizing happy :(
21:36:13 <TSC> It doesn't sound so... happy
21:36:18 <sorear> > lexer :: (Token -> P a) -> P a
21:36:19 <lambdabot>   Not in scope: type constructor or class `P'
21:36:23 <sorear> *barf* manual CPS
21:36:33 <sorear> happy seems to predate Monad.
21:36:41 <sorear> uses plenty of monads though
21:36:47 <sorear> note difference in case
21:39:23 <wy> sorear: Yeah. I finally got the numbers into a list. So how can I write them out into a file?
21:39:38 <LoganCapaldo> @hoogle writeFile
21:39:39 <lambdabot> Prelude.writeFile :: FilePath -> String -> IO ()
21:39:39 <lambdabot> System.Win32.File.c_WriteFile :: HANDLE -> Ptr a -> DWORD -> Ptr DWORD -> LPOVERLAPPED -> IO Bool
21:39:39 <lambdabot> System.Win32.File.win32_WriteFile :: HANDLE -> Ptr a -> DWORD -> Maybe LPOVERLAPPED -> IO DWORD
21:41:43 <wy> It seems can't write binary data
21:42:08 <sorear> it sure can
21:42:15 <sorear> unless you are using DOS/Windows
21:42:31 <sorear> @hoogle writeBinaryFile
21:42:32 <lambdabot> No matches found
21:45:58 <wy> I'm a little worried about the internal representation of lists, because I have millions of numbers.
21:46:18 <sorear> arrays will be much, much, much worse
21:46:28 <sorear> with lists, you will need maybe 1k of memory
21:46:52 <sorear> with an array, yo will need 12M of memory per 1m numbers
21:47:22 <wy> That's strange. Why? Because lists are lazy?
21:47:32 <sorear> lists are linked lists, but thanks to laziness only one node will be in RAM at a time
21:47:35 <sorear> yes
21:47:52 <wy> It's sooo cooool
21:48:38 <wy> But what about accessing, say, the 100,000th element?
21:48:53 <sorear> that will take O(100000) time
21:48:59 <wy> uhh
21:49:12 <sorear> and if you hold a reference to the first element, O(100000) space
21:49:22 <sorear> lists are best suited for 1-pass algorithms
21:49:53 <wy> I still haven't written the data out. Don't know how to do.
21:50:44 <sorear> writeFile doesn't work?
21:52:02 <wy> It needs a String for the second argument. But I have a [Int]
21:52:14 <LoganCapaldo> @hoogle [a] -> String
21:52:15 <sorear> map toEnum
21:52:15 <lambdabot> No matches, try a more general search
21:52:30 <sorear> @ty map toEnum :: [Int] -> String
21:52:32 <lambdabot> [Int] -> String :: [Int] -> String
21:53:45 <fantasmaa> > map toEnum [1,2,3,4,6,8]
21:53:46 <lambdabot>  [1,2,3,4,6,8]
21:53:57 <TSC> Maybe wy wants to write them in a binary format
21:54:01 <wy> Good! I got it.
21:54:10 <wy> It's not binary?
21:54:30 <LoganCapaldo> everything is binary ;)
21:54:57 <sorear> wy: map toEnum has an overloaded type, lambdabot arbitrarily picked one
21:54:57 <wy> I got error if I eval:  map toEnum [1,2,3,4,6,8]
21:55:06 <sorear> > map toEnum [1,2,3,4,6,8] :: String
21:55:07 <lambdabot>  "\SOH\STX\ETX\EOT\ACK\b"
21:55:18 <sorear> does that look more binary:)
21:55:53 <brad__> who writes http://swik.net/Haskell/Data.Syntaxfree ???
21:55:55 <lambdabot> Title: Haskell : Data.Syntaxfree - SWiK
21:56:00 <wy> It looks cool. What is Enum?
21:56:09 <brad__> some brilliant stuff in there!
21:56:30 <LoganCapaldo> @seen syntaxfree
21:56:30 <lambdabot> syntaxfree is in #haskell. I last heard syntaxfree speak 11h 22m 40s ago.
21:56:36 <LoganCapaldo> Him maybe?
21:56:42 * LoganCapaldo is guessing
21:56:44 <fantasmaa> lol
21:56:48 <sorear> it is him
21:56:55 <sorear> he even has the same legal name!
21:57:16 <brad__> a great blog, just slightly surreal enough to bother reading
21:57:29 <brad__> like any great blog, some real WTF moments in there
21:57:50 <brad__> have people looked at http://www.patryshev.com/monad/m-intro.html ?
21:57:54 <wy> It takes forever to write the file.
21:57:57 <fantasmaa> > map read [1,3,4,6,7,2,5] --maybe this is what you needed?
21:58:13 <brad__> wonder if it is worth the time reading
21:58:18 <wy> It seems I can't stop the program in haskell-mode
21:58:18 <fantasmaa> > map read [1,3,4,6,7,2,5]
21:58:41 <sorear> C-c C-c
21:58:49 <sorear> also, the interpreter is slow
21:58:51 <wy> It doesn't work
21:58:54 <fantasmaa> > map show [1,2,3,4,5,6,7,8]
21:58:58 <sorear> try harder
21:59:11 <sorear> it doesn't always work the frist time ;( :(
21:59:16 <fantasmaa> > fix show
21:59:21 <int-e> @bot :/
21:59:21 <fantasmaa> where is the bot
21:59:34 <wy> No it doesn't work however hard I tried.
21:59:46 <sorear> @botsnack
21:59:58 <sorear> @activity-full 600
21:59:58 <fantasmaa> @seen lambdabot
22:00:15 <sorear> @msg #haskell foo
22:00:23 <glguy> lambdabot: @bot
22:00:25 <glguy> ??
22:00:32 <glguy> :(
22:00:34 <sorear> I can't /ctcp dons ping
22:00:39 <sorear> so it's the network
22:00:48 <fantasmaa> bye bot
22:00:49 <LoganCapaldo> Someone set us up the bomb?
22:01:08 <glguy> I'm in your bot, stealing ur responses
22:01:32 <wy> The compiled version is also slow
22:02:36 <LoganCapaldo> how big of a list of numbers anyways?
22:03:18 <LoganCapaldo> @go haskell mmap
22:03:22 <LoganCapaldo> oh wait
22:03:26 <glguy> how quickly you forget!
22:03:28 <LoganCapaldo> I forgot already
22:03:45 <glguy> the @ commands are just a part of the channel now
22:03:47 <sorear> it's in Data.ByteString, named mmapFile, commented out
22:03:54 <glguy> it can be hard to remember that there is a bot listening for them
22:03:58 <wy> The list is about 800,000 numbers. But I may have more
22:04:01 <TSC> wy: Maybe you could use Data.Binary for I/O
22:04:21 <sorear> no he can't
22:04:22 <TSC> (well, to make the string)
22:04:48 <sorear> you should probably be using lazy ByteString if you have that much data
22:04:59 <LoganCapaldo> Whyforth commented out is it?
22:04:59 <sorear> google for the great computer language shootout
22:05:07 <sorear> look at the code for sum-file
22:05:34 <sorear> Because they neglected the "Ignore windoze" commandment :(
22:05:39 <sorear> portability--
22:05:53 * sorear slaps himself
22:05:57 <LoganCapaldo> windows hath mmap
22:06:27 <sorear> yes, but the bytestring team didn't know that
22:06:34 <LoganCapaldo> heh
22:07:10 <araujo> anybody uses screen here?
22:07:41 <TSC> araujo: Sure
22:07:47 <LoganCapaldo> sometimes
22:08:16 <LoganCapaldo> in the future, every file will be mmap'ed
22:08:19 <araujo> TSC: what is the keys combination to take a programm to the background?
22:08:20 <LoganCapaldo> bwahahahahaha
22:08:29 <sorear> C-z
22:08:34 <araujo> thanks sorear
22:08:38 <wy> uhhh. I guess that's why they use Matlab.
22:08:40 * araujo tries
22:09:30 <dcoutts> LoganCapaldo: the problem with mmap on 32bit machines is the danger of exhausting address space
22:09:37 <dcoutts> if you load lots of files
22:09:40 <araujo> sorear: mm.. should i have started screen with a specific option to use that?
22:09:42 <wy> It seems I can only use something like Matlab or IDL for that amount of data.
22:09:55 <TSC> araujo: What are you trying to do?
22:10:14 * LoganCapaldo waits for his 128bit address space
22:10:43 <araujo> TSC: i am trying to get back to the shell without stopping my current program on screen
22:10:51 <sorear> wy: that kind of comment is considered nonproductive here, it just makes people think you're a troll
22:10:57 <LoganCapaldo> C-a d
22:11:54 <wy> I'm just trying to figure out a way to finish the task. I don't like the mablab language, but it's really fast
22:12:13 <araujo> Thanks LoganCapaldo
22:12:40 <TSC> araujo: Oh, you wanted to detach from the screen session
22:13:12 <sorear> wy: remember to use -O
22:13:30 <wy> sorear: I used -O2
22:13:38 <sorear> good enough,
22:15:18 <wy> Can I use Data.ByteString.Lazy.Char8 for the integers?
22:16:21 <dcoutts> @tell swiert it was suggested to me that a review date would be helpful, I note TMR editions do not seem to have the date in them, perhaps they should.
22:17:14 <LoganCapaldo> dcoutts: lost cause
22:17:17 <sorear> I just sent off a bugrep to simonmar ... I hope he is in this week
22:17:19 <araujo> yes TSC , sorry, i wasn't clear enough
22:17:22 <dcoutts> @tell swiert and I've been asked for the list price in Swedish Kronor but have no idea how to find that out! :-)
22:17:34 <dcoutts> LoganCapaldo: hmm? you mean the 32bit and mmpa thing?
22:17:46 <LoganCapaldo> @tell dcoutts lambdabot is MIA
22:18:04 <dcoutts> oh yeah, so it is :-)
22:18:04 <sorear> dcoutts: /ctcp dons ping
22:18:10 <TSC> araujo: That's ok; if you'd known the term you would have been able to find it in the docs
22:18:19 <sorear> manzano, if not all of unsw, is detached from the 'net
22:18:21 <araujo> right
22:18:36 * sorear /whois dcoutts
22:19:19 <sorear> gentoo/developer/dcoutts?  what kind of hostname is THAT? :)
22:19:19 <sorear> dcoutts, you still at unsw?
22:20:15 <sorear> Yay, my happy bug report has been bounced as spam.
22:20:35 <sorear> What lists is JaffaCake subscribed to?
22:20:52 <sorear> pinging #haskell!
22:21:02 <sorear> drat, not AGAIN
22:21:40 <sorear> *twiddle*
22:22:16 <sorear> I think freenode is having trouble :/
22:23:32 <TSC> I can hear you
22:23:36 <jyp> hey sorear :)
22:23:45 <sorear> hi jyp
22:25:35 <sorear> dcoutts_: ping
22:25:57 * dcoutts_ discovers the problem with lambdabot
22:25:57 <sorear> eh?
22:26:00 <dcoutts_> the box was off
22:26:02 <dcoutts_> probably because of a power cut earlier
22:26:07 <dcoutts_> like the one that just kicked me offline
22:26:22 <sorear> why hasn't lb timed out, then?
22:26:33 <sorear> when my connection dies, I time out in minutes
22:26:48 <dcoutts_> hmm, dunno
22:26:49 <sorear> btw, can you hear me?
22:26:57 <dcoutts_> but I think lambdabot runs on that box
22:27:01 <sorear> I think freenode is burping and I can't @botsnack
22:27:14 <dcoutts_> and it was definately off, and I turned it on
22:27:29 <sorear> clog thinks I'm talking, but I'd like a second opinion
22:27:42 <dcoutts_> sorear: you are talking :-)
22:27:48 <sorear> ah good :)
22:28:12 <dcoutts> @botsnack
22:28:35 <dcoutts> I wonder if lambdabot starts automatically when one turns that box on... seems not
22:29:25 <sorear> ISTR dons saying it was in his .profile
22:29:33 <sorear> can you guess his password? :)
22:30:04 <sorear> I don't suppose he left emergency contact info?
22:30:26 <dmwit> This hardly qualifies as an emergency...
22:30:50 <dcoutts> sorear: he might be around this weekend, but then he'll be away for a few days
22:32:07 <sorear> I am having a remarkable amount of trouble communicating to JaffaCake.
22:32:31 <sorear> i'll try hashcash stamps, and if that doesn't work I'm going to spam g-h-u
22:36:03 <fuzan> hmm
22:36:08 <fuzan> me dislikes happs examples not compiling.
22:37:34 <LoganCapaldo> fuzan: theres a #HAppS channel also
22:43:31 <sorear> Sure is quiet here.
22:43:37 <sorear> I want to @yow...
22:44:56 <stepcut>  I want to dress you up as TALLULAH BANKHEAD and cover you with VASELINE and WHEAT THINS..
22:45:14 <stepcut> Now, my ENTIRE LIFE is flashing before my EYES as I park my DODGE DART in your EXXON service area for a COMPLETE LUBRICATION!!
22:45:29 <sorear> Is there a Microsoft anti-spam system or do they just use spamassassin?
22:45:55 <sorear> damn, even with a hashcash stamp it won't take my message.
22:46:08 * sorear annoys g-h-u
22:54:29 <sorear> ping #Haskell
22:54:38 <arcatan> pong sorear
22:55:05 <sorear> man, this is so boring
22:55:25 <sorear> my project is stalled because of a bug in a program I didn't write and can't understand
22:55:38 <jyp> GHC?
22:55:39 <sorear> and nobody needs my help on #haskell
22:55:43 <sorear> Happy
22:55:46 <jyp> ha.
22:55:51 <sorear> stefan@stefans:~/cadt/src$ happy Parser.y
22:55:51 <sorear> happy: parE
22:56:02 <sorear> now that is SUCH a helpful error message!
22:56:39 <sorear> and adding insult to injury SimonM's mail system thinks my bug report is spam.
22:56:48 <sorear> Thankfully, g-h-u took it.
22:57:09 <sorear> Happy isn't glasgow haskell, but I'm pretty sure SimonM reads the list...
22:57:26 <sorear> nice.
22:57:30 <dmead> :>
22:57:41 <dmead> tellhim your lolcopter is broken
22:58:02 <sorear> dcoutts: the www.cse.unsw.edu.au web server is down, is it off too?
22:58:20 <dcoutts> sorear: or maybe it didn't restart after the powercut
22:58:21 <LoganCapaldo> dude, its a roflcopter
22:58:26 <LoganCapaldo> and a lolcano
22:58:36 <LoganCapaldo> Like ZOMG
22:58:41 <ulfdoz> sorear: you could encrypt it, with a key generate from the binary. ;)
22:58:41 <dmead> lawls
22:58:53 <dmead> i want to be a roflcopter mechanic when i grow up =/
22:59:09 * sorear starts to type @remember ...
22:59:47 <dcoutts> sorear: I once looked into fixing that bug, but I can't remember now what the bug in the grammar is that causes that error message
22:59:58 <dcoutts> sorear: the front end of happy is pretty simple
23:00:12 <glguy> Saizan: you there?
23:00:18 <dcoutts> shouldn't be too hard to an another checking pass
23:00:34 <sorear> so, happy is another of those programs that nobody understands, just like the nhc98 typechecker.
23:01:06 <LoganCapaldo> understanding is overrated
23:01:19 <LoganCapaldo> I don;t understand ghc but I can use it.
23:01:21 <LoganCapaldo> sort of
23:01:24 <sorear> "Announcing Irk, a LALR(1) parser generator for haskell."
23:01:46 <sorear> "The big difference between Irk and Happy is that the one person who groks Irk, is still alive."
23:02:12 <sorear> that makes me think...
23:02:15 <sorear> @where frown
23:02:20 <sorear> :)
23:02:55 <stepcut> http://www.informatik.uni-bonn.de/~ralf/frown/index.html
23:03:27 <sorear> I did find it ;)
23:04:42 <sorear> Who wrote happy?
23:04:56 <sorear> same guy who wrote the nhc typechecker?
23:08:48 <dmead> sorear you seem bored
23:08:53 <dmead> might i suggest some video games
23:08:56 <dmead> or alcohol
23:09:22 <dcoutts> sorear: it was by Andy Gill and Simon Marlow, both of whom are still around :-)
23:10:24 <sorear> I'm installing Frown now.  If the obvious translation gives a meaningful error, I'm making list noise...
23:10:31 * sorear thinks to check the ghc trac
23:11:48 <sorear> googling "happy: parE" gives for #1 ... myspace
23:13:10 <stepcut> yay!
23:17:35 * stepcut finally gets the brilliant idea of putting the relevant pages numbers from "Implementing lazy functional languages on stock hardware: the Spineless Tagless G-machine *", in the comments in his code, so he can find them again later
23:18:44 <LoganCapaldo> stepcut: sounds like a patent to me
23:20:02 <sorear> comments?  haskell-swf still
23:20:03 <sorear> ?
23:20:34 <stepcut> sorear: yes, though a side project
23:20:52 <stepcut> sorear: I had to do taxes and stuff, so I haven't been able to work on haskell-swf in a while
23:21:09 <sorear> reading the penultimate chapter of "the implementation of functional programming languages" (google: slpj-book-1987), might also be a good idea
23:21:16 <sorear> that introduces the basic G-machine
23:21:41 <stepcut> sorear: and then I got a bit confused about how things are supposed to work, because swf does not have pointers. So, I decided to do a simple STG->C compiler
23:21:43 <sorear> so you can grasp what spineless tagless means, and you know where the design is flexible
23:24:13 <stepcut> is that book different from "Implementing Functional Languages: a tutorial", also by SPJ?
23:25:00 <stepcut> it would appear so
23:26:28 <sorear> I haven't read the "a tutorial" one.
23:27:08 <stepcut> hrm, I already had the 1987 one downloaded :)
23:27:37 <stepcut> hrm, this book looks quite useful
23:31:10 * stepcut goes to bed
23:31:12 <tibbe> does haskell support unicode chars in identifiers or just a-z?
23:32:10 <sjanssen> ghc 6.6 has some UTF-8 support
23:32:43 <tibbe> ok
23:33:35 <sjanssen> and the Haskell report supports Unicode identifiers as well
23:40:21 <hpaste>  thoughtpolice pasted "hsns, v0.5" at http://hpaste.org/1380
23:42:22 <sorear> dcoutts: there is a pretty obvious way to crush the bug in question, I've modified my local happy and will suffer the collateral damage
23:42:37 <dcoutts> sorear: what's your fix?
23:42:53 <sorear> dcoutts: comment out parE, and add '> parE = thenE'
23:43:03 <sorear> that means you only get one error per run
23:43:10 <sorear> far nicer than zero, imo :)
23:53:50 <plediii> @pl \ f l -> l ++ map f l
23:54:21 <plediii> It doesn't work for newbies :(
23:54:33 <sorear> right.
23:54:38 <sorear> scroll back
23:54:46 <sorear> *** lambdabot (n=lambdabo@manzano.cse.unsw.EDU.AU) has quit: Read error: 110
23:54:47 <sorear>     (Connection timed out)                                                [22:36]
23:55:02 <sorear> unsw it seems has suffered a power failure :(
23:55:51 <sorear> oh, and ap (++) . map
23:55:51 <sjanssen> terrible timing
23:56:14 <sorear> that's pl-by-hand, beware of errors
23:57:05 <plediii> should I feel bad that I find pl incredibly difficult?
23:57:29 <sorear> I'm afraid I don't understand you.
23:57:47 <sorear> writing pl code is easy
23:57:58 <sorear> reading it is practically impossible
23:58:02 <sorear> no matter who you are
23:58:24 <plediii> pl means point-free right?
23:58:30 <sorear> yes
23:58:35 <sorear> aka "point-less"
23:58:58 <plediii> For simple examples I have no problem with it, commonly use it in lisp
23:59:14 <plediii> but for some examples it takes me a long time to free the points
23:59:38 <plediii> I just can't figure out how to "expose" some particular variables.
23:59:47 <sorear> the base algorithm is incredibly simple.
