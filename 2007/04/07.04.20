00:00:35 <dcoutts> foxy-om: -C/--cppopts is already done by the ccOptions stuff
00:00:45 <dcoutts> the only extra one is -i/--include=
00:01:06 <dcoutts> and that we can do automatically just by using the source dirs as the -i directories
00:01:19 <dcoutts> I'm trying that now
00:01:36 <dcoutts> foxy-om: I think we can make it 'Just Work'tm without adding any new fields
00:01:56 <dcoutts> just by making cabal 'do the right thing'
00:17:36 <hpaste>  quicksilver annotated "(Unfaithful) Boyer-Moore Al-Gore-Rhythm" with "solution (GHC extension)" at http://hpaste.org/1476#a1
00:17:50 <LeCamarade> quicksilver: I'm checking ...
00:18:15 <stepcut> it would be nice if ghc had a flag like ocamls -rectypes
00:18:24 <stepcut> evil, but nice :)
00:18:39 <quicksilver> LeCamarade: it's only a few extra chars. With an explicit 'forall', ghc 'binds' the type variable a, so that the second instance of a is 'the same a'
00:18:51 <quicksilver> stepcut: funnily enough that was discussed yesterday
00:19:01 <stepcut> oh ?
00:19:42 <sjanssen> what are rectypes?
00:20:04 <LeCamarade> quicksilver: So, if I used a' as the name, for example, would it still puke on me? [Cheking ...]
00:20:15 <stepcut> sjanssen: infinite types
00:20:16 <sjanssen> recursive types, like type X a = X (X a)?
00:20:18 <sjanssen> okay
00:20:38 <sjanssen> stepcut: are you allergic to newtypes or something? ;)
00:20:56 <quicksilver> sjanssen: automatic inference of equirecursive types, he means
00:21:07 <quicksilver> sjanssen: that's what the ocaml option turns on
00:21:15 <quicksilver> the (dis)advantage is no more type errors, ever!
00:21:24 <quicksilver> every single expression in lambda calculus has a type...
00:21:41 <stepcut> sjanssen: maybe.  I can't always figure out how to get newtype to do what I want.
00:22:06 <quicksilver> http://groups.google.com/group/comp.lang.functional/browse_thread/thread/8ccaf9b51924b24e/003c558d7bceb6ae
00:22:09 <lambdabot> Title: Inferring Recursive Types - comp.lang.functional | Google Groups, http://tinyurl.com/ynq7kv
00:22:16 <quicksilver> stepcut: that newsgroup thread is a fairly interesting discussion
00:22:38 <quicksilver> stepcut: and includes a link to a post by ajb on haskell-cafe where he explains why they are harmful, in his opinion
00:23:13 <stepcut> quicksilver: they are definitely evil :)
00:24:05 <LeCamarade> quicksilver: So, I am not allowed, while using that extension, to specify the type class of the next a? Will every next type named a in that scope have to be, in fact, the same type as the one with forall against it?
00:24:28 <quicksilver> LeCamarade: right, exactly
00:24:40 <quicksilver> LeCamarade: you don't need to re-specify Eq a, because we have already established Eq a
00:24:50 <quicksilver> LeCamarade: it *is* the same a, after all
00:24:54 * LeCamarade breathes a French swear word.
00:25:07 <sjanssen> ah yes, Pseudonym to save the day
00:25:13 <LeCamarade> quicksilver: Merci beaucoup.
00:25:17 <quicksilver> LeCamarade: you force it to be the same 'a' because you compare it to 'reverse x'
00:25:29 <hpaste>  stepcut pasted "how do I new type this up ?" at http://hpaste.org/1477
00:26:22 <LeCamarade> quicksilver: I I had passed x in on her own, would it still be a problem? No, I don't think. Then, the types would have worked, no?
00:26:56 <quicksilver> LeCamarade: right
00:27:04 <quicksilver> LeCamarade: then you could use b, instea
00:27:30 <stepcut> sjanssen: I have not been able to figure out how to newtype that up, so that I could do, 'numstr (succ zero)', or 'add (succ zero) (succ zero)'
00:27:46 <stepcut> maybe I am missing some trick ?
00:27:52 <LeCamarade> quicksilver: a would still be claimed? Even then? When the new func is essentially oblivious of the first one?
00:28:06 <LeCamarade> Why b? a would work, no?
00:28:24 <LeCamarade> The scopes are tight, no? Anyway, lemme try it out.
00:29:18 <quicksilver> LeCamarade: you could reuse a if you took away the explicity forall
00:29:30 <quicksilver> LeCamarade: the explicty forall makes 'a' into a scoped type var
00:29:34 <quicksilver> LeCamarade: that's the point of the GHC extension
00:30:04 <LeCamarade> quicksilver: Ah.
00:30:16 <quicksilver> LeCamarade: that's why it fixed your initial issue :)
00:30:18 <_roconnor> > 48*24
00:30:19 <lambdabot>  1152
00:30:21 * LeCamarade watches it sink into his thick skull ... feels bon.
00:31:09 <LeCamarade> Next!
00:31:13 <sjanssen> stepcut: this is standard peano encoding?
00:31:30 <LeCamarade> Are comprehensions better-optimised? I want a reason to ban map and filter.
00:32:51 <sjanssen> rather church encoding
00:33:59 <quicksilver> LeCamarade: no, they're not
00:34:19 <quicksilver> LeCamarade: list comprehensions are basically concatMap, although it's a bit more subtle than that
00:36:08 <stepcut> sjanssen: yes
00:37:07 <LeCamarade> quicksilver: So, they are not optimised? Bah. :o(
00:37:17 <quicksilver> LeCamarade: they are neither more nor less optimised, explicitly
00:37:32 <quicksilver> LeCamarade: they are capable of benefitting from fusion just like the map/filter versions are
00:37:36 <LeCamarade> They should be - they are more-explicit about what they are doing.
00:37:52 <hpaste>  sjanssen annotated "how do I new type this up ?" with "with a newtype" at http://hpaste.org/1477#a1
00:38:03 <quicksilver> [ f a | a <- l ]  is not 'more explicit' than map f l
00:38:11 <eumenides> uhm, is arrows-0.2 broken? the darcs version won't even configure, the 0.2 package breaks when compiling
00:38:13 <quicksilver> in fact, it's exactly the same, hopefully
00:39:06 <LeCamarade> It is. From the compiler's point of view, map is just another function. The comprehensions a clearly a map-filter construct. I'd optimise 'em.
00:39:29 <dcoutts> LeCamarade: we can fuse and optimise them in both forms equally well
00:39:44 <hpaste>  eumenides pasted "arrows-0.2 woes" at http://hpaste.org/1478
00:39:45 <dcoutts> LeCamarade: because one desugars into the other
00:40:25 <dcoutts> LeCamarade: since we can do the general case, the special case of list comprehensions just works as a consequence
00:40:33 <LeCamarade> dcoutts: Oh, so in the end the compiler doesn't know of this mapping is a result of an explicit use of map or a comprehension?
00:40:34 <quicksilver> LeCamarade: the point is, the compiler is just as good at optimising map and filter :)
00:40:48 <dcoutts> LeCamarade: right.
00:40:49 <quicksilver> LeCamarade: to the compiler, map and filter aren't "just functions"
00:40:57 <quicksilver> LeCamarade: they are functions for which is has optimisation RULES
00:41:21 <quicksilver> and thanks to work from dons and dcoutts it will soon be able to pull even more dramatic optimisation tricks
00:41:23 <dcoutts> and list comprehensions are tuned into combinatrons of functions which also have special RULES
00:41:37 <quicksilver> but even stock GHC has foldr/build fusion which catches some cases well
00:41:49 <LeCamarade> quicksilver: Wow.
00:41:53 <dcoutts> foldr/build fuses all list comprehnesions perfectly
00:42:05 <dcoutts> the stream system isn't quite as good at that yet
00:42:26 <LeCamarade> Okay, let the only reason for comprehensions over maps and filters be legibility.
00:42:36 <quicksilver> yup
00:42:44 <quicksilver> legibility and to some extent conciseness
00:42:47 <dcoutts> the foldr/build system eliminates all lists on the interior of the list comp and can fuse with generators and consumers
00:42:48 <quicksilver> (which go hand in hand, really)
00:43:12 <quicksilver> just a shame we lost general monad comprehensions :)
00:43:26 <dcoutts> quicksilver: it's called 'do' notation :-)
00:43:35 <dcoutts> the only limitation is on the form of the consumer, it must be a foldr not a foldl
00:43:43 <LeCamarade> If I were designing an FPL, I'd not make map and filter too accessible (standard), and then I optimise the comprehension. And have syntax for folding with comprehensions.
00:44:05 <quicksilver> but map generalises to fmap and mapM
00:44:36 <quicksilver> and there are plenty of times when list comprehensions would be an ugly way to do it
00:44:44 <sjanssen> LeCamarade: I'd rather specify that comprehensions desugar into a few functions, then optimize the heck out of those
00:44:46 <quicksilver> for a simple case I much prefer an explicity map
00:44:47 <dcoutts> LeCamarade: how about just applying fold functions to the list comp? what's wrong with that?
00:44:57 <sjanssen> LeCamarade: this is what Haskell does, by the way ;)
00:45:16 <dcoutts> sum [ x * x | x <- xs ]
00:45:43 * dcoutts notes that this example doesn't fuse under build/foldr
00:45:50 <dcoutts> but does with streams
00:46:02 <LeCamarade> sjanssen: Problem is, I like any two things that look similar in syntax to be treated equally by the compiler. I'd not want a bunch of functions the compiler is aware of. I want some syntax to represent the special cases, and I optimise those.
00:46:35 <dcoutts> LeCamarade: the compiler is not aware of these functions, they're just implemented in the standard library
00:46:45 <LeCamarade> dcoutts: Conciseness. Applying the fold is what I do today. I'd want it to go away into a comprehension.
00:47:20 <dcoutts> LeCamarade: it's only aware of them in the sense that it desugars into uses of a few special functions. The compiler does not treat them specially for optimisation.
00:48:04 <LeCamarade> dcoutts: Oh.
00:48:28 <dcoutts> LeCamarade: I can't see that there is anything much more consise than applying 'sum'
00:48:42 <dcoutts> what kind of syntax could you use that's shorter than that?
00:48:45 <dcoutts> sum [ x * x | x <- xs ]
00:48:52 <LeCamarade> sometwo: comprehension -> {compiler} -> map/filter -> {compiler}.
00:49:23 <Lor> Ah, that reminds me, I've been meaning to write something about monoid comprehensions to LtU.
00:49:30 <LeCamarade> dcoutts, so it is comprehension -> {compiler} -> map/filter -> {compiler}.
00:49:41 <dcoutts> actually it's concatMap, guard and return rather than map/filter, but yeah.
00:50:48 <dcoutts> Lor: that is a comprehension where the result is combined using the monoid operation, or something else?
00:51:11 <Lor> dcoutts, yeah.
00:51:59 <dcoutts> @hoogle mappend
00:51:59 <lambdabot> Data.Monoid.mappend :: Monoid a => a -> a -> a
00:52:07 <Lor> dcoutts: see http://citeseer.ist.psu.edu/fegaras98optimizing.html
00:52:09 <lambdabot> Title: Optimizing Object Queries Using an Effective Calculus - Fegaras, Maier (Research ...
00:52:23 <Lor> Hey, wow.
00:52:33 <dcoutts> Lor: so itsn't that just: mconcat [ ... | ... ]  ?
00:53:02 <Lor> Effectively yes. But without the intermediate list.
00:53:29 <dcoutts> so fuse it, right.
00:53:44 <hpaste>  stepcut annotated "how do I new type this up ?" with "and now, without newtype :(" at http://hpaste.org/1477#a2
00:53:51 <dcoutts> @src mconcat
00:53:51 <lambdabot> Source not found. My mind is going. I can feel it.
00:54:18 <sjanssen> stepcut: that works?
00:54:19 <stepcut> sjanssen: hrm, your solution changes the encoding so that it does not need newtype at all... that isn't quite what I was hoping for :)
00:54:36 <stepcut> sjanssen: works for me
00:54:42 <dcoutts> Lor: ghc should be able to do that since mconcat = foldr mappend mempty
00:54:55 <sjanssen> stepcut: you had errors in the original
00:55:05 <sjanssen> succ n = \f g -> g n -- is wrong, I think
00:55:12 <dcoutts> Lor: ie since mconcat is a foldr it can fuse with the list comprehension
00:55:16 <stepcut> sjanssen: sorry, I just copied it from some python code :)
00:55:45 <stepcut> sjanssen: let me check it real quick
00:57:01 <Lor> dcoutts, right. However, there are further optimizations available if the monoid is commutative or idempotent.
00:57:16 <dcoutts> Lor: ah right
00:57:35 <Lor> No doubt these could be made optimizable in GHC, too, with some judicious types and rules.
00:57:53 <dcoutts> that'd be an interesting project
00:58:47 <hpaste>  stepcut annotated "how do I new type this up ?" with "original version in ocaml" at http://hpaste.org/1477#a3
00:59:09 <stepcut> sjanssen: I transliterated it to ocaml, seems to work fine
00:59:42 <sjanssen> stepcut: this isn't the usual Church encoding, by the way
01:00:14 <stepcut> sjanssen: i think it came from some paper newsham was reading
01:01:32 <stepcut> sjanssen: anyway, I ran into the same problem when I tried to implement the SKI combinators as haskell functions
01:01:57 <stepcut> certain valid programs would not type check due to the infinite types
01:02:16 <sjanssen> right
01:02:39 <sjanssen> you want be able to hack around recursive types on a large scale
01:02:59 <sjanssen> s/want/won't
01:03:03 <stepcut> yes, that is why ocaml -rectypes is nice -- until you need laziness, then it gets dodgey
01:03:32 <sjanssen> well, accepting many obviously wrong programs is a downside too
01:03:48 <stepcut> right, that is why it is disable by default on ocaml ;)
01:04:13 <stepcut> i am not even sure if it is documentetd
01:04:40 <stepcut> well, -h shows it,  -rectypes  Allow arbitrary recursive types
01:05:54 <DRMacIver> What's a recursive type in this context? Something like foo = foo -> foo ?
01:05:57 <flux> hm, it doesn't eventually allow wrong programs to compile? only it might lead to impenetrable error messages
01:06:19 <stepcut> is there anyway to write a haskell program that generates GHC core, and have GHC finish the core->compiled excutable stages ?
01:08:02 <stepcut> DRMacIver, flux: http://groups.google.com/group/comp.lang.functional/msg/2a3a33bfd23a7184?q=ocaml+rectypes&hl=en&lr=lang_en&ie=UTF-8&oe=UTF-8&safe=off&rnum=1
01:08:05 <lambdabot> Title: infinite types ? (haskell) - comp.lang.functional | Google Groups, http://tinyurl.com/2dvqft
01:08:47 <dcoutts> stepcut: that has been possible but it is at various times somewhat bitrotted
01:09:05 <dcoutts> stepcut: I think someone is working on fixing it at the moment
01:09:21 <stepcut> no rush, my SKI compiler can wait ;)
01:09:24 <DRMacIver> Thanks.
01:09:25 <dcoutts> heh
01:11:13 <stepcut> ?localtime stepcut
01:11:15 <lambdabot> Local time for stepcut is Fri Apr 20 01:10:02 2007
01:11:16 * stepcut goes to bed
01:11:26 <stepcut> sjanssen: thanks for your help
01:40:58 <cddar> I've a recursive monadic function (loop) that i use for simulating simple iterations. Using hat I saw that there is no tail call optimization. How can i accomplish tail call optimization?
01:41:57 <LeCamarade> @docs quickcheck
01:41:57 <lambdabot> quickcheck not available
01:42:11 <LeCamarade> @docs check
01:42:12 <lambdabot> check not available
01:42:16 <mnislaih> I don't have a good knowledge of Hat, but I doubt that it can tell you that. The program transformations it does would probably defeat tail calls
01:42:35 <cddar> hmm
01:43:14 <cddar> is tail call optimisation by default in ghc compilations?
01:43:19 <LeCamarade> cddar: I think the optimisations _do_ happen under all cases. I think.
01:43:28 <mnislaih> also you say it is monadic, hmmm
01:43:44 <dcoutts> cddar: it's not clear that you can make a monadic loop tail recursive in all cases
01:43:44 <sjanssen> cddar: are you seeing a stack explosion?
01:43:52 <cddar> sjanssen, yes
01:44:11 <sjanssen> @paste the code, cddar?
01:44:12 <lambdabot> Haskell pastebin: http://hpaste.org/new
01:44:14 <dcoutts> cddar: since the final call is always a >>=
01:44:24 <dcoutts> not a tail call
01:44:45 <cddar> dcoutts, hmm. what else can i use?
01:45:46 <cddar> it is something like loop n = do; something1; something2; (loop (n-1))  >>= return
01:46:02 <sjanssen> cddar: drop the >>= return
01:46:09 <dcoutts> cddar: it really depends on what your >>= expands into
01:46:17 <sjanssen> the monad laws say that m >>= return = m
01:46:22 <dcoutts> that'll help
01:46:33 <dcoutts> but you've still got >>= loop blah
01:46:35 <cddar> hmm, thanks
01:46:43 <cddar> how?
01:47:07 <sjanssen> @undo do; something1; something2; (loop (n-1)) -- see how this becomes >>= ?
01:47:07 <lambdabot> something1 >> something2 >> (loop (n - 1))
01:47:13 <sjanssen> bah, >>
01:47:14 <dcoutts> right
01:47:24 <sjanssen> essentially the same story, though
01:48:05 <dcoutts> so the top call here is to >> not loop
01:48:25 <dcoutts> so as it stands it's not a tail call
01:48:41 <cddar> yes
01:48:44 <dcoutts> if >> expands into something helpful then it could become so
01:48:55 <dcoutts> cddar: but hat will not show you that
01:49:16 <dcoutts> hat will show you what you wrote, not what an optimising compiler might possibly be able to do
01:49:17 <cddar> i use trace but, ok i get it
01:49:37 <dcoutts> so if this >> is in IO, then it will become a tail call
01:50:01 <dcoutts> it depends on the definition of >>=
01:50:27 <cddar> hmm
01:52:16 <mnislaih> a good tip for obtaining tail-call optimisation is to make sure that your function is strict in all its arguments
01:52:35 <mnislaih> you can get that with bang-patterns in ghc 6.6, or use the `seq` trick
01:53:00 <cddar> mnislaih, hmm this is interesting, what is seq trick?
01:53:16 <mnislaih> f x y | x `seq` y `seq` False  = undefined
01:53:32 <mnislaih> where f is your function
01:54:04 <cddar> hmm
01:54:57 <sjanssen> you probably don't need to resort to this
01:55:21 <sjanssen> do you see the stack blow up with ghc -O (without hat)?
01:55:32 <cddar> yes
01:55:57 <sjanssen> can you paste it for us?
01:55:58 <sjanssen> @paste
01:55:59 <lambdabot> Haskell pastebin: http://hpaste.org/new
01:56:26 <cddar> i developing some kind of genetic algorithms application and i am passing big lists to the next iteration
01:56:33 <cddar> i need tail opt.
01:58:55 <sjanssen> cddar: hard to say exactly what's going on without seeing the code.  But you can be fairly certain that TCO is happening
01:59:26 <cddar> i am pasting the code however it is over 5k i guess
01:59:50 <sjanssen> one common pitfall with laziness and tail recursion is that you can accidentally build up a giant thunk in an accumulator
02:00:04 <sjanssen> that would be the first place I'd look
02:02:36 <cddar> i am passing lists of integer values with length 200 and in each iteration the stack is growing. for 2500th iteration operation gets so slow because of the paging and fetch memory operations
02:03:11 <cddar> see it does not even fit in 250 mbs of memory
02:03:17 <sjanssen> I wager this is heap growth, not stack growth
02:04:16 <cddar> hmm
02:04:30 <LeCamarade> cddar: Maybe you can give them the problem function.
02:04:59 * LeCamarade thinks it is cool to watch these exchanges every once in a while.
02:06:13 * mnislaih bets sjanssen is 100% right about the giant thunk
02:06:31 <mnislaih> cddar do you know how to indicate strictness in your code ?
02:06:33 <hpaste>  cddar pasted "ga problem function" at http://hpaste.org/1479
02:07:50 <sjanssen> yikes!
02:07:51 <cddar> it is hard to follow without the rest
02:08:14 <sjanssen> cddar: if you need to write your parameter list on multiple lines, a refactor is in order :)
02:09:01 <mnislaih> first step: make the iterNo parameter strict
02:09:37 <sjanssen> mnislaih: it's already strict (by the < comparison in an if)
02:09:38 <mnislaih> though, shouldn't GHC figure out that ?
02:09:42 <mnislaih> yep
02:10:03 <sjanssen> I bet you're building up a really deep thunk in the first parameter
02:10:44 <mnislaih> is fittestOf strict in its 1st arg ?
02:11:09 <cddar> both are with fitnessOf
02:13:18 <cddar> first parameter has always 200 individuals
02:13:28 <cddar> first parameter has always 200 elements
02:16:22 <mnislaih> cddar, how is Individual declared
02:17:08 <cddar> [Int] Int
02:17:29 <cddar> a list of Int with another integer value
02:17:45 <mnislaih> does fittestOf force the whole list of Ints
02:17:50 <mnislaih> ?
02:18:55 <cddar> fittestOf force the list of Individuals?
02:19:48 <mnislaih> fittestOf selects the fittests one of a list of Individuals. For doing this, does it inspect the list of Ints inside the individual or just the 2nd Int
02:19:49 <hpaste>  sjanssen annotated "ga problem function" with "more readable" at http://hpaste.org/1479#a1
02:20:16 <sjanssen> @hoogle rnf
02:20:17 <lambdabot> Control.Parallel.Strategies.rnf :: NFData a => Strategy a
02:20:48 <cddar> it uses just the 2nd
02:21:13 <mnislaih> well, there is the giant thunk sjanssen pointed out
02:21:49 <cddar> however i cant understand why
02:22:04 <sjanssen> @type \x -> Control.Exception.evaluate (Control.Parallel.Strategies.rnf x)
02:22:06 <lambdabot> forall a. (NFData a) => a -> IO Done
02:22:43 <hpaste>  sjanssen annotated "ga problem function" with "is this the magic fix?" at http://hpaste.org/1479#a2
02:24:34 <cddar> hmm
02:24:53 <cddar> i should think a lot
02:25:00 <cddar> mnislaih, thanks a lot
02:25:09 <cddar> sjanssen, thanks for your help too
02:25:24 <sjanssen> cddar: did you see my last paste?
02:25:32 <sjanssen> I bet it fixes the issue
02:25:40 <mnislaih> sjanssen solution is good.  you will also need to write a NFData instance for Individual
02:26:05 <sjanssen> oh yeah, what is the defn. of Individual?
02:26:07 <cddar> hmm i saw, thanks a lot
02:27:04 <cddar> Individual [Int] Int
02:28:13 <mnislaih> a possible instance
02:28:14 <mnislaih> instance NFData Individual where rnf (Individual ii i) = rnf ii `seq` rnf i `seq` ()
02:30:14 <cddar> hmm
02:31:41 <mnislaih> cddar:  that the purpose of rnf is to fully evaluate its argument.
02:31:49 <mnislaih> rnf = reduce to normal form
02:34:03 <cddar> rnf ok i get it
02:40:07 <hpaste>  mdmkolbe-work pasted "(no title)" at http://hpaste.org/1480
02:40:34 <mdmkolbe-work> How do I get an account for the Trac (http://hackage.haskell.org/trac/ghc)?  The register link is giving me this error http://hpaste.org/1480 after I enter the user name and password for the new account
02:42:39 <mnislaih> can't you use guest/guest?
02:45:26 <mdmkolbe-work> I can, but most Wikis prefer you to register and create an actuall acount.  Is that not the case with the Haskell Wiki?
02:47:22 <mnislaih> the Haskell wiki yes, but in the GHC Trac they actually suggest that you use the guest account.
02:47:53 <mnislaih> that said, you can probably ask Igloo for an account
03:04:22 <Cheery> agh, still having problems with this sigINT
03:05:08 <Cheery> when I install a handler for sigINT, the thing inside (Catch) is done
03:05:14 <Cheery> thought I'd want something like this:
03:06:19 <Cheery> IO a -> IO a -> IO a
03:08:45 <Cheery> ie. I want that handler for sigINT would cut off the thing which it is installed on
03:11:39 <Cheery> that I could write something like: cut sigINT (putStrLn "Interrupted!") canHalt
03:11:41 <mdmkolbe-work> does ghci have something equivalent to bash's 'time' (i.e. quick way to measure the time to evaluate a function)?
03:15:18 <quicksilver> Cheery: then you write a handler which throws an exception back to the main thread
03:15:34 <quicksilver> installHandler sigINT (Catch (throwTo mainthread (ErrorCall "sigint"))) Nothing
03:15:42 <quicksilver> Cheery: (that's an example from one of my programs)
03:16:11 <quicksilver> Cheery: mainthread isn't built-in, you need to call myThreadId in main to get it
03:16:29 <Cheery> looks like a black magic
03:16:43 <quicksilver> Cheery: ? don't think so, it's quite straightforward
03:17:05 <quicksilver> Cheery: it says 'on sig INT, Catch the signal and call this function which throws an exception to the main thread
03:17:58 <Cheery> @type myThreadId
03:18:01 <lambdabot> Not in scope: `myThreadId'
03:18:13 <Cheery> @hoogle myThreadId
03:18:14 <lambdabot> Control.Concurrent.myThreadId :: IO ThreadId
03:18:29 <Cheery> @hoogle mainthread
03:18:30 <lambdabot> No matches found
03:18:39 <quicksilver> I just do mainthread <- myThreadId
03:18:40 <Cheery> oops
03:18:41 <quicksilver> in main
03:18:56 <Cheery> ok
03:19:00 <quicksilver> What I do think is surprising is taht there is no default way to say 'convert these signals to exceptions'
03:19:07 <quicksilver> since, to me, that seems a very obvious thing to want :)
03:20:55 <igli> hmm maybe you could just write a generic wrapper then?
03:21:43 <quicksilver> yes, it's quite easy
03:22:23 <quicksilver> sigToExc s tid = installHandler s (Catch (throwTo tid (ErrorCall (show s)))) Nothing
03:22:46 <quicksilver> You might think of a better exception type than ErrorCall, though
03:26:23 <igli> heh don't ask me, i'm a hs noob :)
03:27:29 <igli> i'd have a Signal exception with attr Num (enum of Name)
03:28:53 <quicksilver> unfortunately exceptions are a data type at the moment, and hence closed
03:29:06 <quicksilver> this is a subject upon which many papers and alternatives have been suggested :)_
03:29:20 <quicksilver> we could use DynException, for example
03:29:24 <quicksilver> feels a bit heavyweight though
03:30:05 <igli> hmm data types are closed? strange.
03:31:15 <quicksilver> well, they have to be really
03:31:22 <quicksilver> if you define a type Foo = Bar | Baz
03:31:29 <quicksilver> and define functions working on it
03:31:39 <quicksilver> which proceed by case analysis of Bar | Baz
03:31:46 <quicksilver> then if someone else is allowed to add a new case, you're screwed :P
03:31:55 <igli> heh
03:32:12 <quicksilver> types are closed but classes are open
03:32:21 <quicksilver> so classes would be the haskell tool of choice in this case
03:32:34 <quicksilver> but the details are a bit tricky, for exceptions
03:32:40 <quicksilver> hence the papers written on the subject
03:32:46 <quicksilver> The problem has been solved, in fact
03:32:51 <quicksilver> the problem is, it's been solved more than once :)
03:33:02 <quicksilver> the great haskell powers that be have to decide which solution to standardise on
03:34:14 <encryptio> foldl starts at the left end (head) of the list, and foldr starts at thr right end (tail) of the list. no?
03:35:12 <igli> hmm which is the most elegant and efficient sol'n in your opinion quicksilver?
03:37:42 <quicksilver> encryptio: in a sense yes, but in another sense they both start from the left
03:38:10 <quicksilver> @go haskellwiki fold
03:38:12 <encryptio> starts calling the given function with the two elements at the left
03:38:12 <lambdabot> http://www.haskell.org/haskellwiki/Fold
03:38:13 <lambdabot> Title: Fold - HaskellWiki
03:38:28 <quicksilver> encryptio: that article is rather well written by our very own Cale
03:38:37 <quicksilver> encryptio: and has purty pictures which helped me quite a bit
03:40:49 <foxy-om> @seen dcoutts
03:40:49 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #haskell-overflow and #ghc. I last heard dcoutts speak 20m 51s ago.
03:47:13 <mdmkolbe-work> @info Int#
03:47:14 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
03:52:54 <Cheery> do you guys have dice here?
03:53:18 <Cheery> @dice
03:53:19 <lambdabot> unexpected end of input: expecting number
03:53:24 <Cheery> @dice 6d
03:53:24 <lambdabot> unexpected end of input: expecting number
03:53:36 <Cheery> @info
03:53:37 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
03:53:45 <kaol> @dice 1 50
03:53:46 <lambdabot> 1 50 => 150
03:54:38 <Cheery> kaol: um, what's the syntax? I'd need a hit from one 1d6 dice
03:54:38 <int-e> @dice 3d6
03:54:39 <lambdabot> 3d6 => 11
03:54:44 <Cheery> @dice 1d6
03:54:45 <lambdabot> 1d6 => 6
03:54:47 <int-e> @dice 1d6+5
03:54:48 <lambdabot> 1d6+5 => 9
04:04:04 <quicksilver> Cheery: http://xkcd.com/c221.html
04:04:05 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
04:25:15 <Cheery> @dice 1d6
04:25:15 <lambdabot> 1d6 => 4
04:26:03 <Cheery> seems like I'm next going to write some combinators for handling vertex data
04:27:02 <vali> hello noble haskellers
04:27:17 <boegel> Cheery: your next task depends on @dice? nice going :-)
04:27:51 <opqdonut> :D
04:28:30 * boegel always makes his next task depend on how much he wants to start some task
04:43:16 <t0mas> hi! :)
04:44:30 <t0mas> I'm using wxHaskell.. and when I set a function as an event handler to a ListCtrl with "on listEvent" it gets an EventList as the last parameter..
04:44:59 <t0mas> but I want to set something like this: on listEvent := do handler; otherFunc a b c d
04:45:07 <LeCamarade> @tell ivanm You don't know how much time I have spent on your little function. And I don't even think I have it right. :o(
04:45:08 <lambdabot> Consider it noted.
04:45:11 <t0mas> where a b c d are parameters only availible in the main gui function..
04:45:25 <t0mas> but.. then my extra EventList parameter gets added to otherFunc
04:45:38 <t0mas> while I need it to be in handler..
04:45:46 <t0mas> is there some way to fix that?
04:49:21 <therp> quicksilver: wah, I just read about 70 xkcd strips.
04:51:19 <therp> but otoh, why not waste a bit of time while ghc is compiling
04:52:12 <Cheery> boegel: well, there's bunch of things I want to do :D
04:52:22 <Cheery> so I need dice or something to choose amongst them
04:53:08 <boegel> Cheery: ok, I see
05:01:59 <ekidd> Good morning.
05:02:05 <boegel> yo ekidd
05:02:25 <boegel> ekidd: you wake up late :p
05:03:27 <vali> ekidd: hello
05:34:55 <ivanm> @tell LeCamarade did you implement that function I was talking about before?
05:34:56 <lambdabot> Consider it noted.
05:42:23 <xerox> anybody knows how to force a redraw of a GTK canvas?
05:42:59 <mux> widgetQueueDraw
05:46:25 <xerox> yay it works, thanks :)
05:50:32 * SamB_XP_ wonders why you'd need to do that
05:51:07 <xerox> I wanted to redraw a canvas, after having modified its underlying pixbuf.
05:51:53 <mux> I do the same for redrawing my GtkDrawingArea
05:52:10 <mux> SamB_XP_: it's how things are supposed to be used
05:52:15 <SamB_XP_> ah
05:52:23 <SamB_XP_> the "force" threw me
05:53:03 <mux> of course it doesn't make much sense if the widget is not one of the kinds that we're drawing in ourselves
05:59:43 <ndm> anyone know why the GHC instances for typeable are not the same as the other compilers ones?
05:59:47 <ndm> and in particular if the generated ones for other compilers would work on GHC?
05:59:52 <ndm> regarding: http://darcs.haskell.org/packages/base/include/Typeable.h
06:11:53 <LeCamarade> @where http
06:11:54 <lambdabot> http://www.haskell.org/http/
06:13:39 <fantasma> > let primes = sieve [2..] where
06:13:39 <fantasma>  sieve (p:ns) = p : sieve [n | n <- ns, n `mod` p > 0] in take 10 primes
06:13:39 <lambdabot>  Parse error
06:14:04 <fantasma> > let primes = sieve [2..] where sieve (p:ns) = p : sieve [n | n <- ns, n `mod` p > 0] in take 10 primes
06:14:06 <lambdabot>  [2,3,5,7,11,13,17,19,23,29]
06:15:10 <fantasma> > let primes = sieve [2..] where sieve (p:ns) = p : sieve [n | n <- ns, n `mod` p > 0] in (head . flip . take 1000) primes
06:15:11 <lambdabot>  Couldn't match expected type `a -> b -> c'
06:15:58 <fantasma> > let primes = sieve [2..] where sieve (p:ns) = p : sieve [n | n <- ns, n `mod` p > 0] in last (take 1000 primes)
06:16:00 <lambdabot>  7919
06:16:11 <fantasma> > let primes = sieve [2..] where sieve (p:ns) = p : sieve [n | n <- ns, n `mod` p > 0] in last (take 100000 primes)
06:16:15 <lambdabot> Terminated
06:16:23 <fantasma> :(
06:16:25 <Pastorn> how do i catch the line made by system "date +%Y-%m-%d"
06:16:49 <Pastorn> i need a function of the type :: String -> IO String
06:17:02 <fantasma> @hoogle String -> IO String
06:17:03 <lambdabot> System.getEnv :: String -> IO String
06:17:03 <lambdabot> System.Console.Readline.quoteFilename :: String -> Bool -> Ptr CChar -> IO String
06:17:22 <fantasma> ?src getEnv
06:17:23 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
06:17:29 <fantasma> ?src System.getEnv
06:17:29 <lambdabot> Source not found. Maybe if you used more than just two fingers...
06:17:40 <Pastorn> ?scr System.IO.getEnv
06:17:41 <lambdabot> Maybe you meant: arr rc src
06:17:46 <Pastorn> ?scr System.Cmd.getEnv
06:17:47 <lambdabot> Maybe you meant: arr rc src
06:17:47 <ivanm> ?src and
06:17:48 <lambdabot> and   =  foldr (&&) True
06:17:59 <Saizan> Pastorn: you need to use System.Process and run date with that argument
06:18:06 <Saizan> ?hoogle system
06:18:07 <lambdabot> System.system :: String -> IO ExitCode
06:18:07 <lambdabot> System :: module
06:18:07 <lambdabot> System.Win32.Info.SystemColor :: type SystemColor
06:18:23 <Saizan> ?docs System.Process
06:18:24 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Process.html
06:18:53 <Pastorn> Saizan: thanks =)
06:19:58 <Pastorn> ?type runProcess
06:20:01 <lambdabot> Not in scope: `runProcess'
06:20:14 <Pastorn> ?type System.Process.runProcess
06:20:17 <lambdabot> FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> Maybe GHC.IOBase.Handle -> Maybe GHC.IOBase.Handle -> Maybe GHC.IOBase.Handle -> IO System.Process.Internals.ProcessHandle
06:20:25 <Pastorn> i want to cry
06:20:34 <Saizan> :D
06:20:46 <xerox> Maybe Cry :)
06:20:50 <Saizan> ?type System.Process.runCommand
06:20:52 <lambdabot> String -> IO System.Process.Internals.ProcessHandle
06:20:57 <Saizan> mmh no
06:21:31 <Saizan> i'd use runInteractiveCommand, but i've never used this module before ..
06:22:08 <xerox> Why do you not use the Time module?
06:22:08 <Pastorn> When I get a grip of this I should add this to the wikibook
06:22:28 <Pastorn> cause later on i'm gonna use wget
06:22:42 <Pastorn> and i DON'T want to write that manually
06:22:56 <Pastorn> besides, it's good exercise
06:23:04 <xerox> http://haskell.org/http/
06:23:06 <lambdabot> Title: Haskell HTTP package
06:23:09 <Pastorn> if i don't kill myself first
06:23:12 <Pastorn> xerox: no
06:23:33 <xerox> no?
06:24:04 <Pastorn> no
06:24:11 <Pastorn> I want to learn this
06:24:50 <Pastorn> I'll get in to the guts of TCP/IP at school in 6 months or so
06:24:57 <LeCamarade> @where base-2.0
06:24:58 <lambdabot> I know nothing about base-2.0.
06:25:07 <Pastorn> @paste
06:25:08 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:25:34 <LeCamarade> @where Networl
06:25:34 <lambdabot> I know nothing about networl.
06:25:37 <LeCamarade> @where Network
06:25:38 <lambdabot> I know nothing about network.
06:25:48 <xerox> LeCamarade, what are you looking for?
06:26:10 <LeCamarade> Maybe I'm a little sleep-deprived, but HTTP has refused to install.
06:26:11 <lambdabot> LeCamarade: You have 2 new messages. '/msg lambdabot @messages' to read them.
06:26:11 <pixel> Pastorn: see readProcess at http://www.cse.unsw.edu.au/~dons/code/newpopen
06:26:12 <lambdabot> Title: Index of /~dons/code/newpopen
06:26:27 <xerox> LeCamarade, did you use the self-contained bundle?
06:26:39 <hpaste>  Pastorn pasted "catch this!" at http://hpaste.org/1481
06:26:45 <pixel> Pastorn: see http://pleac.cvs.sourceforge.net/*checkout*/pleac/pleac/pleac/pleac_haskell.data for examples
06:26:47 <LeCamarade> No. Get HTTP by darcs.
06:26:48 <lambdabot> http://tinyurl.com/24ffbt
06:26:57 <LeCamarade> s/Get/Got/
06:27:04 <fantasma> what is the idiomatic way to generate primes in haskell
06:27:44 <xerox> > let primes = 2 : 3 : [n | n <- [5,7..], all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes)]
06:27:44 <lambdabot>  Parse error
06:28:02 <fantasma> the sieve is really inefficient though
06:28:29 <LeCamarade> fantasma: Generating primes isn't supposed to be efficient. :oD
06:28:49 <pixel> fantasma: http://haskell.org/haskellwiki/99_questions/31_to_41#Problem_39
06:28:51 <lambdabot> Title: 99 questions/31 to 41 - HaskellWiki
06:29:07 <xerox> I'm awfully lagged :(
06:29:19 <fantasma> I remember seeing someone do a prime generator with a monad or something
06:29:30 <Saizan> LeCamarade: which error do you get?
06:29:32 <Pastorn> pixel: what am i supposed to do with those?
06:29:50 <qebab> there aren't really any efficient algorithms for producing primes, are there?
06:30:07 <LeCamarade> Saizan: Setup.lhs cannot satisfy dependency network-any.
06:30:20 <Saizan> the only one is the Atkin sieve, quadratic in space though
06:30:20 <qebab> for small primes they are okay, but when you get to large ones *shudders*
06:30:23 <LeCamarade> Maybe lemme first try apt-getting. (Debian).
06:30:25 <xerox> > nubBy (\x y -> y `mod` x == 0) [2..]
06:30:27 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
06:30:47 <xerox> (Credit goes to Cale ;))
06:30:52 <qebab> :o
06:31:01 <xerox> > let primes = 2 : 3 : [n | n <- [5,7..], all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes)] in primes
06:31:03 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
06:31:04 <LeCamarade> I see it in apt-cache! w007, Debian!
06:31:14 <qebab> is it just me being newb, or does that generate an infinite list? [2..]
06:31:20 <pixel> Pastorn: Right s <- readProcess "date" ["+%Y-%m-%d"] ""
06:31:22 <fantasma> > let x = nubBy (\x y -> y `mod` x == 0) [2..] in last (take 10000 x)
06:31:26 <drigz> Pastorn: still having trouble? does this help? http://www.cse.unsw.edu.au/~dons/code/cpuperf/Process.hs
06:31:26 <lambdabot> Terminated
06:31:31 <xerox> qebab, yes, an infinite list of prime numbers.
06:31:38 <fantasma> > let x = nubBy (\x y -> y `mod` x == 0) [2..] in last (take 1000 x)
06:31:41 <lambdabot>  7919
06:31:46 <fantasma> > let x = nubBy (\x y -> y `mod` x == 0) [2..] in last (take 5000 x)
06:31:50 <lambdabot> Terminated
06:31:52 <opqdonut> > [1..]
06:31:52 <xerox> fantasma, last (take n xs) = xs !! n
06:31:53 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
06:31:54 <byteshack> qebab: it has the hability te generate an infinite list
06:31:54 <dolio_> http://www.polyomino.f2s.com/david/haskell/main.html
06:31:57 <lambdabot> Title: Haskell for Maths
06:32:01 <qebab> that's a nice thing
06:32:08 <xerox> qebab, indeed :)
06:32:09 <Pastorn> drigz: thanks =)
06:32:15 <fantasma> xerox: haha wow I forgot, thanks
06:32:16 <dolio_> That has some more efficient prime code in the basic number theory section.
06:32:16 <qebab> and this would be possible for things like fibonacci numbers as well?
06:32:44 <Saizan> > fix ((1:) . scanl (+) 0)
06:32:46 <lambdabot>  [1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,1094...
06:32:49 <fantasma> fibonacci is the best in haskell
06:32:50 <qebab> I have a friend who implemented the ackerman function in perl once :) he was going to print A(5,5) or something insane
06:32:51 <xerox> > let evens = map (+1) odds; odds = 1 : map (+1) evens in (take 10 odds, take 10 evens) -- qebab, mutually recursive infinite lists.
06:32:52 <lambdabot>  ([1,3,5,7,9,11,13,15,17,19],[2,4,6,8,10,12,14,16,18,20])
06:32:54 <qebab> it segfaulted
06:32:59 <Saizan> > fix ((1:) . scanl (+) 1)
06:33:01 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
06:33:28 <Saizan> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs
06:33:30 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
06:33:38 <opqdonut> > fix (\x zipWith (+) (1:x) x)
06:33:38 <lambdabot>  Parse error
06:33:39 <qebab> amusing :o
06:33:45 <opqdonut> > fix (\x -> zipWith (+) (1:x) x)
06:33:47 <lambdabot>  Exception: <<loop>>
06:33:47 <qebab> I better start learning this language for real
06:33:51 <opqdonut> hrmm
06:34:07 <Saizan> opqdonut: you are forgetting the base case :)
06:35:07 <dolio> > fix ((1:) . ap (zipWith (+)) (1:))
06:35:11 <Saizan> qebab: a pratical application of this is that for example you can write a 2-pass assembler as a 1-pass lazily-recursive one :)
06:35:14 <lambdabot>  [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1771...
06:35:34 <dolio> > fix ((1:) . (1:) . ap (zipWith (+)) tail)
06:35:36 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
06:35:37 <fantasma> :i nubBy
06:35:45 <fantasma> :index nubBy
06:35:51 <qebab> I'm a bit of a maths geek really, so I was thinking more about series and such :P
06:35:54 <fantasma> ?index nubBy
06:35:54 <lambdabot> Data.List
06:35:55 <int-e> fantasma: use @ or ?
06:36:13 <fantasma> thanks
06:36:23 <xerox> > (fix ((1:) . (1:) . ap (zipWith (+)) tail)) !! 1000000
06:36:29 <lambdabot> Terminated
06:36:38 <xerox> > let fib n = 1 + l n 0 0 1 where l k s pp p = let f = pp+p in if f <= k then l k (s+f) p f else s in fib 1000000000
06:36:40 <lambdabot>  1836311902
06:36:48 <fantasma> nice
06:36:58 <qebab> that's fast
06:37:01 <xerox> :D
06:37:05 <int-e> too small
06:37:08 <qebab> that's beautiful
06:37:19 <qebab> > let fib n = 1 + l n 0 0 1 where l k s pp p = let f = pp+p in if f <= k then l k (s+f) p f else s in fib 2000000000
06:37:21 <lambdabot>  4807526975
06:37:25 <qebab> :o
06:37:28 <fantasma> > let fib n = 1 + l n 0 0 1 where l k s pp p = let f = pp+p in if f <= k then l k (s+f) p f else s in fib 99999999999
06:37:29 <lambdabot>  225851433716
06:37:36 <fantasma> > let fib n = 1 + l n 0 0 1 where l k s pp p = let f = pp+p in if f <= k then l k (s+f) p f else s in fib 999999999999999999999999
06:37:39 <xerox> wrote it for projecteuler
06:37:39 <lambdabot>  2046711111473984623691758
06:37:44 <qebab> aha
06:37:47 <xerox> yarr :)
06:37:47 <qebab> projecteuler is nice :)
06:38:00 <qebab> thats one thing haskell should excel for
06:38:05 <fantasma> @remember xerox > let fib n = 1 + l n 0 0 1 where l k s pp p = let f = pp+p in if f <= k then l k (s+f) p f else s in fib 1000000000
06:38:06 <lambdabot> Done.
06:38:26 <dolio> @quote xerox fib
06:38:32 <lambdabot> xerox says: > let fib n = 1 + l n 0 0 1 where l k s pp p = let f = pp+p in if f <= k then l k (s+f) p f else s in fib 1000000000
06:38:42 <int-e> > let fib n = 1 + l n 0 0 1 where l k s pp p = let f = pp+p in if f <= k then l k (s+f) p f else s in fib in map fib [1..]
06:38:43 <lambdabot>  Parse error
06:38:57 <int-e> > let fib n = 1 + l n 0 0 1 where l k s pp p = let f = pp+p in if f <= k then l k (s+f) p f else s in map fib [1..]
06:38:58 <lambdabot>  [2,4,7,7,12,12,12,20,20,20,20,20,33,33,33,33,33,33,33,33,54,54,54,54,54,54,5...
06:39:02 <int-e> fib?
06:39:16 <fantasma> xerox: which problem are you up to in projecteuler?
06:39:19 <qebab> I've been using python for projecteuler
06:39:37 <qebab> it's slower, so I have to plan things better ;)
06:39:57 <xerox> int-e, no, sumfib
06:39:58 <fantasma> I've done all but 1 in haskell
06:40:12 <qebab> how is haskell for string treatment?
06:40:27 <xerox> sumfib n = sum (map fib [1..n)
06:40:31 <xerox> modulo syntax errors
06:40:39 <xerox> fantasma, just started :)
06:40:59 <qebab> some of the problems really learn you quite a lot
06:40:59 <fantasma> nice
06:41:03 <dylan> > words "it can be good" !! 3
06:41:05 <lambdabot>  "good"
06:41:09 <qebab> not necessarily useful information, but it's fun anyway :)
06:41:34 <qebab> ... and I really should be doing maths right now, so laters, I guess
06:41:56 <fantasma> nooo
06:42:01 <fantasma> do more project euler :)
06:42:09 <qebab> I want to :P
06:42:52 <fantasma> > "projecteuler" > "mathclass"
06:42:54 <lambdabot>  True
06:47:27 <fasta> How would purely functional data structures look like in C?
06:48:02 <LeCamarade> fasta: They'd clone everything before working with it. No pointer, as in.
06:48:40 <fasta> LeCamarade: that would be pretty inefficient.
06:48:48 <fasta> LeCamarade: GHC doesn't work that way
06:49:08 <LeCamarade> fasta: It's why Data.ByteString was thought up for Haskell. GHC works that way.
06:49:24 <dolio> Yeah, actually, you'd probably want to use pointers, and only clone the portion that's required, and share the rest.
06:49:33 <fasta> dolio: right
06:49:59 <fasta> I was just wondering how for example a [a] would be implemented in C (with sharing)
06:51:11 <dolio> Well, the problem with C there is that it isn't easy to write a nice [a].
06:51:24 <dolio> You could write [Int] more easily.
06:51:48 <LeCamarade> fasta: In C++ you can try [a]. But in C ... you'd have evil void * challenges.
06:52:02 <fasta> dolio: that would be fine too.
06:52:13 <fasta> LeCamarade: and indeed void * would correspond to a
06:52:39 <LeCamarade> fasta: void * would correspond to [a]
06:53:05 <fasta> LeCamarade: AFAIK, void * would correspond to a
06:53:06 <xerox> int-e, actually, it's the sum of the first fibonacci numbers less than or equal to n, that's why there are repeating ones.
06:53:32 <int-e> xerox: ah.
06:53:33 <fasta> LeCamarade: It's a list of things of unknown type
06:53:38 <fasta> LeCamarade: i.e. void *
06:54:26 <int-e> xerox: and if you add 1 to every number you get fibonacci numbers again :)
06:54:35 <LeCamarade> fasta: Yeah, but a is not normally a list. [a] is the usual way to represent a list.
06:54:50 <xerox> int-e, woah :D
06:55:04 <fasta> LeCamarade: ?
06:55:17 <fasta> LeCamarade: By "a" I mean an element of the list
06:55:45 <xerox> > let fib n = 1 + l n 0 0 1 where l k s pp p = let f = pp+p in if f <= k then l k (s+f) p f else s in map (+1) . nub . map fib $ [1..]
06:55:49 <lambdabot> Terminated
06:55:54 <LeCamarade> fasta: Okay, we can go to #haskell-blah, and I show you what I mean.
06:56:02 <LeCamarade> If you're into it.
06:56:03 <int-e> xerox: that's the observation below the  fix ((1:) . scanl (+) 1)  fibonacci generator.
06:56:04 <xerox> eh, nub.
06:56:08 <int-e> xerox: err behind
06:56:55 <xerox> neat
06:57:13 <fasta> LeCamarade: I am there.
07:04:29 <fantasma> how can I declare a variable.... map (\x -> in this area) [1..] ?
07:04:52 <Saizan> using let?
07:05:11 <fantasma> do I seperate with commas?
07:05:46 <Saizan> > map (\x -> let x2 = x*x; x3 = x +x in x2*x3) [1..]
07:05:48 <lambdabot>  [2,16,54,128,250,432,686,1024,1458,2000,2662,3456,4394,5488,6750,8192,9826,1...
07:06:19 <fantasma> I see, thanks very much
07:09:57 <Syzygy-> kolmodin: The numbers in your post yesterday do add up. You need to be careful to only add the ones corresponding to subtractions, and ignore the ones that are checkpoints.
07:10:00 <Syzygy-> So you get
07:10:18 <Syzygy-> > 2*52 + 170 + 48 + 6 + 11 + 25 + 1
07:10:20 <lambdabot>  365
07:12:04 <dolio> @hpaste
07:12:05 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:14:50 <kolmodin> Syzygy-: aye, but also, they say 10 min coffee break adds upp to 11 days. true? I haven't checked that :)
07:16:00 <nornagon> 10 mins * 261 days = 43.5 hours
07:16:06 <nornagon> /= 11 days
07:16:44 <Syzygy-> kolmodin: Oh right.
07:16:52 <Syzygy-> I didn't care to check that much.
07:16:53 <dolio> fasta: Are you still looking for sample immutable linked-list code in C?
07:17:04 <fasta> dolio: if it also does sharing
07:17:07 <Syzygy-> So - obvious next question: How long coffee breaks do you need for it to work out.
07:17:24 <kolmodin> > 10 * 365 / 60 / 24
07:17:26 <lambdabot>  2.5347222222222223
07:17:32 <Syzygy-> Yikes!
07:17:32 <Syzygy-> :P
07:17:35 <kolmodin> hmm..
07:17:38 <kolmodin> anyway.. :)
07:17:42 <Syzygy-> I doubt that 365 though.
07:17:50 <Syzygy-> Should be more like 261, like in nornagons
07:17:51 <kolmodin> yeah
07:17:57 <Syzygy-> > 10 * 261 / 60 / 24
07:17:58 <lambdabot>  1.8125
07:18:04 <kolmodin> as I said, I haven't checked those numbers :)
07:18:06 <Syzygy-> Still. Just under 2h/day coffee.
07:18:19 <hpaste>  dolio pasted "Immutable linked list." at http://hpaste.org/1482
07:23:08 <cm> hi; is there a haskell library to load pngs?
07:23:10 <psykotic> stupid theory question--isn't the principal type property for type inference trivial in a simply-typed lambda calculus, because of the absence of type vars?
07:24:13 <Philippa> psykotic: yep
07:24:42 <Philippa> well, the absence of type vars or subtyping or anything else that could mean a value has more than one type
07:24:43 <psykotic> that's what i thought. in that case i'm very confused. did you see that google techtalk on reddit about parametricity?
07:24:46 <psykotic> right
07:24:51 <Philippa> nope
07:25:15 <psykotic> the presenter mentions that the principal type property was proved for the original simply typed LC type inference algorithm
07:25:24 <psykotic> maybe he reversed the chronology
07:26:18 <psykotic> he lists three stages: the original algorithm by curry and freys. then the proof of completeness and the principal type property, by hindley and milner. finally, the extension to a limited form of polymorphic lc by damas and milner.
07:27:22 <dolio> fasta: Did you see that paste?
07:27:35 <psykotic> the completeness thing makes sense (i heard that before), but i was confused about how principal types were nontrivial at the simply typed level. there isn't really a lot of leeway in how you type terms in that calculus :)
07:27:43 <fasta> dolio: no
07:27:50 <fasta> dolio: yes
07:27:55 <dolio> Heh. :)
07:28:02 <dolio> Apologies for not pointing to it earlier.
07:30:05 <dolio> Note that you could still mutate that if you wanted. I didn't try to make the appropriate variables constant or anything. But if you only use head, tail, cons and such, you get the sort of list that Haskell has.
07:41:08 <cm> psykotic, hindley was using a calculus involving type variables.
07:41:23 <psykotic> cm, not originally.
07:41:52 <cm> psykotic, well, in the work about principal types.
07:42:33 <psykotic> cm, i haven't read the primary source, i was just going by a presentation i saw, and it seemed self-contradictory. so yeah, i would expect that to be the case, since PTs don't have interesting meaning in a simply typed setting, as far as i can tell.
07:46:48 <psykotic> cm, do you have any online links to these original papers? i remember trying to find them a few years ago, but it's impossible to find a lot of things published before the mid 80s
07:48:15 <cm> psykotic: i found http://links.jstor.org/sici?sici=0002-9947%28196912%29146%3C29%3ATPTOAO%3E2.0.CO%3B2-C&size=LARGE
07:48:26 <lambdabot> Title: JSTOR: Transactions of the American Mathematical Society: Vol. 146, p. 29, http://tinyurl.com/275uvy
07:49:21 <psykotic> cm, JSTOR wants extortion fees for papers, unless you're a student at an institution with a subscription :)
07:49:22 <fasta> dolio: everything you left as exercise for the reader was of interest to me :) I think I maybe write it myself once.
07:49:33 <Pastorn> :type handle
07:49:35 <cm> psykotic, it displays the first page or me.
07:49:37 <cm> for*
07:49:38 <fasta> psykotic: they all want that
07:49:38 <Pastorn> ?type handle
07:49:41 <lambdabot> Not in scope: `handle'
07:49:49 <hpaste>  dolio annotated "Immutable linked list." with "folding" at http://hpaste.org/1482#a1
07:49:51 <cm> psykotic, and he introduces type variables on the first page ;)
07:49:51 <psykotic> fasta, most do, yeah.
07:49:53 <Pastorn> ?type System.IO.handle
07:49:55 <lambdabot> Not in scope: `System.IO.handle'
07:50:06 <Pastorn> ?type System.Process.handle
07:50:09 <lambdabot> Not in scope: `System.Process.handle'
07:50:16 <fasta> psykotic: can you name one that doesn't? (peer-reviewed, that is)
07:51:52 <dolio> fasta: Heh. I'm not sure there's a great way to solve those problems in C. The best way might be to write a garbage collector. :)
07:52:01 <Pastorn> ?type (>>)
07:52:04 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
07:52:06 <Pastorn> ?type (>>=)
07:52:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:52:21 <Pupeno2> [OT] in "Sandra is beautiful", is "beautiful" and adjetive?
07:52:32 <Pastorn> yes
07:52:43 <psykotic> fasta, if you google for "open access journals" you can find a multitude, but all the illustrious ones with a long history behind them do, afaik.
07:52:54 <Pastorn> Pupeno2:  seing how it is an attribute
07:53:03 <psykotic> fasta, mostly because they're owned by scumbag publishing houses like elsevier.
07:53:14 <Pupeno2> Pastorn: what?
07:53:42 <psykotic> fasta, the absurdity of tax dollars funding research, which is published in journals, which in turn has to be bought back with tax dollars makes me really mad.
07:53:55 <Pastorn> Pupeno2: come to #h4xx0r
07:54:00 <fasta> psykotic: thanks
07:54:18 <Botje> dolio: you could implement the fold with a while() loop
07:54:21 <Pupeno2> Pastorn: ok.
07:54:54 <dolio> Botje: Oh yeah. Believe it or not, that didn't even occur to me.
07:55:02 <Botje> :))
07:55:20 <psykotic> fasta, people are finally getting pissed off though. i remember reading an open letter from knuth where he resigned as editor from one of the big algorithm journals due to increasing extortionist pricing policies.
07:55:21 <Botje> @remember Botje> dolio: you could implement the fold with a while() loop dolio> Botje: Oh yeah. Believe it or not, that didn't even occur to me.
07:55:22 <lambdabot> Done.
07:55:34 <fasta> psykotic: I remember the same
07:55:58 <Botje> how does GHC implement linked lists anyway?
07:56:15 <psykotic> fasta, i wish this could be raised to a political issue, because this is the kind of thing that _should_ piss off politicians.
07:56:26 <fasta> psykotic: write a letter
07:56:30 <quicksilver> the same way it implements any kind of algebraic data structure, Botje
07:56:43 <psykotic> as it is, the governments are basically subsidizing the big publishing houses.
07:57:02 <psykotic> fasta, i was involved in something about this when i was still a student. didn't have any effect :)
07:58:38 <pejo> psykotic, did you see the letter by Knuth about this?
07:58:52 <psykotic> pejo, yes, i just mentioned that letter of his.
07:59:05 <psykotic> pejo, john baez has also more recently written about this.
07:59:15 <pejo> Duh, sorry. Missed that one.
07:59:19 <doserj> http://www.publicknowledge.org/issues/openaccess
07:59:21 <lambdabot> Title: Open Access | Public Knowledge
07:59:36 <psykotic> http://math.ucr.edu/home/baez/journals.html
07:59:37 <lambdabot> Title: What We Can Do About Science Journals
08:20:18 <Pastorn> is it possible to do fst for (IO (a,b) -> IO a ) as a lambda expression?
08:20:38 <Syzygy-> Pastorn: You really want to do liftM fst instead.
08:20:56 <Pastorn> right... forgot i had that =)
08:21:05 <Syzygy-> > liftM fst $ Just (3,4)
08:21:07 <lambdabot>  Just 3
08:21:38 <Pastorn> where is it? Data.Monad?
08:21:47 <Syzygy-> ?index liftM
08:21:47 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
08:22:04 <Pastorn> Why is it called Control?
08:23:05 <Syzygy-> Because it handles control flow in some way or another. *guess*
08:23:21 <mux> good questions, someone was advocating removing them from Control. because it's not just about control
08:23:22 <Syzygy-> Monad isn't really a Data contained as much as it handles meta-aspects of data containers...
08:23:43 <Syzygy-> An answer that always works is "Historical accident" :P
08:23:54 <mux> I propose WarmFuzzyThings.*
08:24:00 <Syzygy-> Agreed.
08:24:25 <quicksilver> I think Control is not a bad name
08:24:27 <Syzygy-> Though I'm very much considering CategoryTheory.* instead
08:24:29 <quicksilver> monads control stuff
08:24:44 * Syzygy- thinks all of Haskell libraries should be sorted according to their algebraic classification.
08:24:56 <Syzygy-> So we could have Category.Abelian.Pushout.(,)
08:25:02 <mux> quicksilver: I guess in a very abstract way, and in that sense pretty much anything can be said to control things
08:25:03 <Syzygy-> (or is that Pullback? I forget)
08:25:08 * quicksilver thinks that wouldn't be likely to make Haskell more accessible
08:25:27 <Syzygy-> quicksilver: You're just thinking about the wrong audience. :P
08:40:00 <matthew-_> ndm: ping
08:40:08 <ndm> matthew-_: pong
08:40:37 <matthew-_> there seems to be some suggestion that the current darcs filepath is broken
08:40:55 <ndm> matthew-_: where? and broken in what way? and which darcs version?
08:40:58 <ToRA> ndm: well the Setup.hs doesn't seem to work
08:41:14 <matthew-_> ToRA: (forgot you were here too!)
08:41:16 <ToRA> get a type error about Maybe Hooks vs Hooks
08:41:21 <ndm> ToRA: which version of Cabal? I noticed that Igloo checked in a change that requires a higher version
08:41:24 <ndm> Igloo: ping
08:41:25 <ToRA> darcs pulled about 5 minutes ago
08:41:33 <ToRA> ah, how do i find out my versoin of Cabal?
08:41:42 <ndm> ToRA: i pulled yesterday to the department server, and it didn't work - so i had to upgrade cabal
08:41:47 <ndm> ToRA: ghc-pkg list
08:42:06 <ToRA> Cabal-1.1.6,
08:42:06 <ndm> I'm on 1.1.7, which does seem to work
08:42:10 <ToRA> ok
08:42:11 <ToRA> my fault then
08:42:14 <ndm> hmm, thats not great
08:42:19 <ndm> no, 1.1.7 isn't a released version
08:42:23 <matthew-_> I have cabal 1.1.6 and that's fine with filepath-0.11.
08:42:44 <ndm> thats not a good sign
08:42:52 <ToRA> @paste
08:42:53 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:42:54 <ndm> ToRA: easier solution, just replace the Setup.hs with a default one
08:43:02 <ndm> main = defaultMain
08:43:14 <hpaste>  ToRA pasted "type error on filepath cabal" at http://hpaste.org/1485
08:43:52 <ToRA> ndm: ^^ fwiw
08:43:54 <ndm> ToRA: i'll email the libraries list, and see what people say - its not my change, i'll see if it can be fixed
08:44:13 <matthew-_> thanks ndm
08:44:16 <mrhuschi> what does "orphan instances" mean?
08:45:00 <ToRA> you've defined an instance of a typeclass in a module that doesn't contain either the data type the instance is being declared on, or the declaration of the type class
08:45:21 <mrhuschi> ah thx.
08:45:26 <ToRA> i interpret it as ghc warning you that it's having to think extra hard in order to resolve where the instances are coming from
08:45:49 <mrhuschi> ok.
08:46:34 <ndm> ToRA: sent, we'll see what people say
08:46:51 <mrhuschi> but by putting all instance declarations for a certain datatype or class into one module the file can become very large.
08:48:01 <allbery_b> whee.  compiled gtk2hs program causes valgrind to drop core
08:48:20 <allbery_b> ...said program has some kind of memory corruption happening
09:10:09 <Saizan> re "type error on filepath cabal", you just need to remove a typesign btw
09:10:27 <Cale> quicksilver: Just thought I'd mention that's a direct copy of what I put on wikipedia.
09:13:32 <chessguy> hi haskellers
09:15:06 <monochrom> muskelleers
09:15:17 <monochrom> hasketteers
09:39:59 <shapr> @yow !
09:39:59 <lambdabot> I didn't order any WOO-WOO ... Maybe a YUBBA ... But no WOO-WOO!
09:40:18 <norpan> indeed
09:40:22 <ddarius> @time shapr
09:40:24 <lambdabot> Local time for shapr is Fri Apr 20 11:39:09 2007
09:40:28 <ddarius> Moin shapr
09:40:39 <norpan> huh, only noon
09:41:05 <shapr> greetz ddarius
09:41:32 <ndm> Saizan: good point
09:42:04 <quicksilver> Cale: I know, I even pointed that out to you in surprise at one point :)
09:42:19 <Cale> ah :)
09:44:31 <shapr> ddarius: What's up?
09:44:52 <xerox> hello Cale :)
09:44:58 <Cale> hi
09:45:18 <ddarius> shapr: I am now certified (again) to perform CPR.
09:45:24 <shapr> spiffy
09:45:34 <ndm> hmm, i need my certification updating...
09:45:36 <shapr> I can perform CPS, but that's about it.
09:45:45 <xerox> Cale, I just wrote a chaotic map program! Want to try it out?
09:45:51 <quicksilver> I can't even perform CPS reliably
09:46:03 <shapr> And though "CPS" > "CPR", I suspect string ordering isn't the same as ordering in real life.
09:46:04 <quicksilver> just about manage CPD
09:46:08 <Cale> xerox: cool :)
09:46:27 <mauke> btw, now I know what an "occurs check" is :-)
09:46:45 <quicksilver> most people find that out when they write their first type-checker
09:47:01 <mauke> heh, yeah
09:47:12 <quicksilver> may it be the first of many!
09:47:16 <mauke> I wouldn't need it if I knew how to compare infinite structures
09:47:44 <quicksilver> May your years be long and your type inference algorithms sound. (Ancient Jewish Proverb)
09:48:13 <xerox> Cale, get yourself some square XPM files :)  I'm still darcspushing.
09:48:40 <mauke> @remember quicksilver May your years be long and your type inference algorithms sound. (Ancient Jewish Proverb)
09:48:40 <lambdabot> Done.
09:49:01 <xerox> It comes with a demo one, if you don't have any.
09:49:13 <xerox> Cale, http://darcs.haskell.org/~paolo/darcs/arnold/
09:49:14 <lambdabot> Title: Index of /~paolo/darcs/arnold
09:51:12 <monochrom> Crazy!  Someone is compiling ghc on PS3...
09:53:15 <Cale> What a great kitten picture, hehe
09:54:17 <xerox> hehe :D
09:54:17 <xerox> Go all the way through 300 iterations!
09:54:33 <Cale> yeah, I'm doing that now
09:54:59 <Cale> 60 must be a divisor of the image size :)
09:55:15 <Cale> looks like 60x5? :)
09:55:32 <xerox> (The latter arrows represent PageUp/PageDown if it's not clear.)
09:56:24 <xerox> 25 little squares
09:56:35 <xerox> (The image is 300x300.)
09:57:03 <xerox> The same at 120.
09:57:14 <xerox> 150 gets 9 squares :)
09:57:28 <chessguy> xerox, Cale: what are you working on?
09:57:37 <xerox> 180 -> 25.  Patterns!
09:57:43 <xerox> chessguy, http://darcs.haskell.org/~paolo/darcs/arnold/
09:57:45 <lambdabot> Title: Index of /~paolo/darcs/arnold
09:58:12 <chessguy> what's a .xpm file?
09:58:19 <xerox> A bitmap.
09:58:37 <norpan> a very sparse image format
09:58:43 <Cale> An X Window System Pixmap
09:58:57 <emu> in C syntax
09:59:00 <norpan> yup
09:59:06 <norpan> so that you can #include it
09:59:26 <xerox> GTK can load it directly in a pixbuf, which is handy
09:59:41 <monochrom> as an array in C
09:59:50 <chessguy> interesting
09:59:51 <emu> monochrom: excellent; massively parallel haskell/ps3 apps!
10:00:09 <monochrom> of course, the syntax is simple, not full C.
10:00:36 <xerox> you can convert anything in xpm with GIMP, or imagemagick
10:00:59 <monochrom> yeah, I'm thinking if it gets done before the oscon talk, something could be shown.
10:02:09 <monochrom> "open-source game development on PS3 with parallelization performance beating the hell of commercial rivals" is going to be a killer
10:02:23 <xerox> Anybody has got a windows computer to compile my gtk program in Win32?
10:03:25 <ddarius> monochrom: All we need to do then is wait for the games.
10:04:12 <kartoo> YAHT's 10th chapter seems to be missing in the pdf!! Is there any new version that has the chapter? or is it under development?
10:05:23 <allbery_b> gtk2gs question: how do I intercept the window manager delete-window and remap it to hide the window instead?  the Window class doesn't seem to provide such a signal
10:05:53 <emu> however the Cell processors don't work like general purpose, i thought.  i wonder how parallization looks on them.
10:06:18 * emu looked in the window at EB games today and noticed the prices dropping on PS3s =)
10:07:46 <ToRA> monochrom: hi...
10:07:51 * allbery_b thinks maybe it's time to concede that gtk2hs is not yet usable, and rewrite this thing in some other language :(
10:08:13 <allbery_b> I keep hitting "oh, that doesn't actually work yet"
10:10:30 <DRMacIver> I was reading a blog post earlier that suggested that BusinessObject's CAL was a pretty good Haskell substitute which let you use Java well enough to use the Java GUI frameworks.
10:10:51 <DRMacIver> (It's not pure, so it's not a drop in replacement for Haskell, but is apparently strongly inspired by it)
10:13:04 <ndm> DRMacIver: they keep posting their announcements to the list
10:13:19 <ndm> DRMacIver: sounds more like advertising than a real Haskell competitor
10:14:20 <DRMacIver> Fair enough. I was thinking more in light of the integration with Java providing decent GUI options, so it being a compromise. Never used it myself though.
10:14:43 <Cheery> best way to generate html in haskell?
10:15:09 <ToRA> Cheery: Text.(X)Html. combinators?
10:16:02 <Cheery> sure, why not, I'm thinking about doing a small wiki -language, and thinking where should I head to
10:17:21 <kartoo> Where can I get YAHT's chapter 10? Advanced Techniques.. It is supposed to deal in detail on exceptions..
10:17:41 <Cale> kartoo: I don't know if it's been written
10:17:54 <kartoo> Cale: oh! ok
10:18:32 <kartoo> Cale: Any other place which would deal on exceptions & would be a lil novice friendly, like YAHT?
10:18:48 <Cale> Well, maybe there's some stuff in the Wikibook.
10:19:01 <Cale> That's definitely a place to look anyway :)
10:19:17 <kartoo> okay :) Thanks you
10:19:37 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html -- there's also this module
10:19:40 <lambdabot> http://tinyurl.com/sqmlj
10:20:38 <kartoo> cale: is YAHT just a primer? Seems like the book got over before learning much..
10:20:47 <Cale> Mostly
10:20:49 <shapr> I was thinking about important problems in "our" area, and I came up with the need for a serious laziness tutorial, and type error slicing being available in the most common IDE/editors. Does anyone else have suggestions?
10:21:25 <Nafai> shapr: What's "type error slicing"?
10:21:47 <shapr> It shows the various chunks of code that nail down certain types, and where they clash.
10:22:16 <shapr> Like, half of a module might require Int, and that would be highlighted in red, and the other half might require double, and that would be blue, and some chunks would be white because they don't care.
10:22:37 <Nafai> Interesting
10:22:48 <shapr> http://www.macs.hw.ac.uk/ultra/compositional-analysis/type-error-slicing/
10:22:51 <lambdabot> Title: A Type Error Slicer for MiniML, http://tinyurl.com/2835ce
10:27:47 <shapr> Man, I killed the conversation!
10:27:57 <shapr> Quick, let me insult laziness...
10:28:18 <shapr> Then I can argue with myself.
10:28:31 <pejo> shapr, I don't understand your initial comment - what did the laziness tutorial had to do with the type error slicing?
10:28:49 <quicksilver> shapr: I agree, those are both important/useful things
10:28:50 <shapr> pejo: Hamming's book says "Work on important problems in your area."
10:28:53 <quicksilver> shapr: (better now?)
10:28:58 <shapr> quicksilver: Yay! Thanks!
10:29:08 <quicksilver> shapr: although 'tutorial' almost feels like the wrong word
10:29:11 <shapr> pejo: So I tried to think up some important problems that need working.
10:29:13 <pejo> shapr, I fully agree. But I don't see the connection between them.
10:29:30 <pejo> shapr, oh, they're not related in any way?
10:29:34 <shapr> quicksilver: I think the lack is in the culture... there's very little deep understanding of laziness floating about.
10:29:44 <quicksilver> agreed
10:29:51 * quicksilver certainly wouldn't claim anything deep
10:29:54 <shapr> pejo: Well, they're both important in daily use of Haskell.
10:30:41 <quicksilver> shapr: one thing which I think is particular fuzzy for me is the gap between (a) what is guaranteed by h98 semantics and (b) what is common folklore reliant on GHC's particular implementations
10:30:44 <shapr> pejo: So I guess my question is specifically, what features or document would save you an hour a day of time when using Haskell?
10:31:20 <shapr> For me, having the types (and type clashes) of my code jump out at me while I'm writing the code would save me that much time.
10:31:40 <shapr> Also having a deeper understanding of laziness would mean I'd rarely have to go space leak and time leak hunting.
10:32:02 <kartoo> shapr: is there a "type error slicing" plugin for vim?
10:32:06 <shapr> I don't think so.
10:32:15 <shapr> I don't think there's a type error slicing plugin for anything.
10:32:15 <pejo> shapr, agreed. It's quite a lot of work to implement the type clash suggestion though, but I'd love to have it.
10:32:29 <araujo> morning
10:32:33 <shapr> Well, hIDE had something like it years ago.
10:32:38 <Vq^> hello araujo
10:32:44 <araujo> hi Vq^ !
10:32:49 <shapr> hej Vq^
10:32:56 <kartoo> shapr: okay.
10:32:58 <Vq^> tjenare formarn :)
10:33:02 <shapr> tja
10:33:19 <quicksilver> Yi has type information, I believe
10:33:28 <Vq^> shapr: back in the united somethings of australia?
10:33:29 <quicksilver> but Yi is incomplete and I don't think it does error slicing :)
10:33:36 <shapr> quicksilver: Yeah, ozone had a presentation at Haskell Workshop 2003 about "Is Haskell really just GHC?"
10:33:53 <shapr> Vq^: Er, yeah... but I don't think the USA has invaded Australia yet.
10:34:13 <Vq^> shapr: yeah yeah, it wont be long...
10:34:34 <quicksilver> error slicing requires either (a) access to your compiler's type inference error state or (b) some very clever tricks with partitioning the program into maximal consistent sections and observing the types in those
10:34:50 <quicksilver> I say, having been too lazy to read the paper shapr referenced to see which it uses
10:35:05 <shapr> Would ghc-api give you (a) ?
10:35:21 <quicksilver> I don't know, I've not looked :(
10:35:34 <shapr> Could be interesting.
10:36:22 <quicksilver> where are the ghc api docs?
10:36:32 <emu>  i investigated GHC API a bit to see if i could get type inference info out of it
10:36:41 <shapr> emu: What did you find?
10:36:42 <emu> i never got anything really useful though
10:36:51 <emu> it is like it got the info and stripped it
10:36:57 <Cheery> what would I need for a web app written in haskell?
10:37:05 <emu> kinda frustrating, but, i don't know it very well
10:37:56 <fuzan_> Cheery: there's HAppS, and WASH? I forget nor know anything about the second.
10:38:25 <pejo> shapr/quicksilver, one could run the compiler on the source automatically every now and then, and conclude that the new code introduced between two runs is the thing that "causes" the type error.
10:38:26 <Cheery> HAppS is a html server?
10:38:43 <quicksilver> no, it's a framework for dispatching requests
10:38:54 <emu> i think shim is a good starting point for these features
10:39:24 <quicksilver> although it does incorporate an http server
10:39:57 <fuzan_> HAppS needs a full rewrite :)
10:40:02 <Cheery> quicksilver: that means it is more general than just a html server?
10:40:14 <quicksilver> Cheery: indeed
10:40:37 <Cheery> that's great!
10:40:47 <quicksilver> fuzan_: really? why do you say that?
10:42:00 <shapr> fuzan_: How so?
10:42:28 <fuzan_> quicksilver: well, i think they're in the process of a rewrite right now. their api is changing pretty fast.
10:42:46 <shapr> I think it's reliable now.
10:43:07 <shapr> In fact, I'm pretty sure it is.
10:43:15 <fuzan_> probably. i might be a little misinformed :) 90% of the tutorial examples I tried less than a few weeks ago wouldn't compile.
10:43:16 <shapr> HAppS is my full time employment :-)
10:43:32 <shapr> Yeah, the tutorial still needs improvement :-(
10:43:44 <fuzan_> shapr: congrats :)
10:43:55 * fuzan_ is still looking for employment.
10:44:02 <shapr> alexj has a particular goal in mind for HAppS and there's always the clash between adding the features he wants and updating the tutorial.
10:44:22 <shapr> We just added UDP server support that works almost exactly like the HTTP server.
10:44:25 <fuzan> ah
10:45:04 <Vq^> oh
10:45:20 <quicksilver> shapr: cute
10:45:22 <Vq^> maybe thats usable for me
10:45:31 <quicksilver> shapr: happs-name-server, anyone?
10:45:32 <shapr> Lemmih and I were able to generalize the ServerParts framework to UDP as well.
10:45:40 <shapr> DNS?
10:45:51 <quicksilver> well dns was just an example of a udp protocol I knew of
10:45:59 <quicksilver> but it would be cute :)
10:46:02 <shapr> There's DNS client code in HAppS, a DNS server wouldn't require much more.
10:46:15 <quicksilver> bind, althought it works, has been notoriously buggy over the years
10:46:53 <shapr> Would be useful for the email over DNS idea I had recently.
10:48:08 <ndm> shapr: whats the ultimate goal for HAppS, i.e. why is someone paying people to work on it
10:48:22 <quicksilver> world domination, clearly
10:48:36 * quicksilver supplies ndm with a pair of HAppS earpieces and assimilates him
10:48:48 * shapr grins
10:48:49 <ndm> quicksilver: always a worthy goal, but usually expensive to fund a project to world domination
10:48:57 <quicksilver> ndm: payoff's good, though
10:49:06 <shapr> Actually, the HAppS goal is seriously cool...
10:49:06 <ndm> typically cheaper to fund it to commerical success, and then use that money to obtain world domination
10:49:20 <ndm> and it is?
10:49:22 <shapr> My paraphrase of alex' AngloHaskell talk is:
10:49:51 <Philippa> ...point, we should start arranging an AngloHaskell for this year
10:49:57 <shapr> 'Aunt Bessie cannot run a website or webapp with purely monetary resources right now, it really requires hiring and interacting with sysadmins, NOCs, etc.'
10:50:24 <ndm> June 14th? i've got a wedding to go to that day, so its a traditional AngloHaskell day
10:50:53 <ndm> although perhaps AngloHaskell is less required with Fun in the Afternoon
10:51:09 <ndm> and the hackathon
10:51:20 <shapr> 'But Amazon now offers S3 storage and EC2 image hosting. With that, you could download a demo image, pay someone to customize it for you, upload it to EC2. Amazon covers the failover of both hosting and storage.'
10:51:26 <pejo> quicksilver, bind9 is greatly improved over bind8.
10:51:45 <quicksilver> pejo: yes, I know. It was more a historical observation than a criticism of the code
10:52:03 <quicksilver> pejo: bind is a pretty good example of a large, complex C program which despite being written by a very smart guy, had bugs
10:52:16 <quicksilver> pejo: so in principle you might imagine it might be a rather good haskell case
10:52:31 <ndm> shapr: my friend uses that for his PhD, its very cool
10:52:42 <pejo> quicksilver, well, people will just point to djb and his software as replacements. "Look, this can be done in C".
10:53:51 <quicksilver> pejo: funnily enough, most people I see pointing at djb are saying quite rude things
10:53:52 <pejo> quicksilver, I'm not defending C in any way, but I'm afraid we're very misunderstood. :-)
10:53:58 <quicksilver> pejo: don't know why that would be
10:54:11 <shapr> In my opinion, that sort of Aunt Bessie support is desperately needed. Many of my friends and acquaintances have problems in that area, and come to me for advice.
10:54:42 <xerox> shapr, in this framework, where does the happs server run?
10:56:01 <Philippa> ndm: AH does have the advantage that it's easier for people who aren't 'big names' to do a talk
10:56:11 <Philippa> still, #anglohaskell?
10:56:14 <ndm> Philippa: true
10:56:33 <shapr> The HAppS server is another part of the simplification, it handles most of the services you'd expect from a webapp. It includes DNS client, storage handling, transaction safety, etc
10:56:48 <shapr> If the HAppS server is running, you can trust that all of the necessary services are working.
10:57:29 <shapr> There are more nifty HAppS features that will support this idea, but I don't know which are still under NDA, so I can't tell you yet.
10:58:21 <quicksilver> xerox: on amazon EC2
10:58:38 <shapr> Oh yeah, I misunderstood the question.
10:59:32 <shapr> So the idea is to have a working EC2 image that you can modify for your own purposes.
11:00:16 <shapr> Alex' real goal is to be able to use this for his nifty webapp ideas, of which he has many.
11:01:04 <shapr> There aren't any webapp frameworks that already do this, thus the need for HAppS.
11:09:53 <quicksilver> shapr: since we dont' know what kind of nifty webapp ideas Alex has, we cannot refute that argument :)
11:29:13 <kartoo> Isn't there a limit on the range of integers in haskell? When I run a fibonacci program, I get very long numbers being displayed as the elements of the list.. How come this isn't possible in C and such imperative languages, while haskell can have no limits on the range of the numbers for integers?
11:30:09 <dylan> > maxBound :: Int
11:30:13 <lambdabot>  2147483647
11:30:14 <dylan> > maxBound :: Integer
11:30:16 <lambdabot>   add an instance declaration for (Bounded Integer)
11:30:16 <lambdabot>     In the expression: ma...
11:30:37 <Cale> kartoo: The Integer type switches to arbitrary precision integers automatically when the numbers get large enough, using the GMP library.
11:30:40 <xerox> kartoo, GHC uses libgmp for Integers, which you can use in C as well
11:30:42 <emu> kartoo: because Haskell is a high level language and C is not
11:30:46 <kartoo> 130849508466328924086396609314991822658318068098198850936734860838436447101528196708357662666934856206891799743896814704094667037241134911338394669074522683565119982450075882603244949183101644660834894801525501042769
11:30:52 <Cale> kartoo: There's no reason it can't be done in other languages.
11:30:56 <kartoo> I get such long numbers in the list as time goes
11:31:09 <Cale> In fact, it's just a shame that other languages don't do it.
11:31:13 <monochrom> C's int has only a constant number of bits.  Haskell's Int too.  But Haskell also has Integer, multiprecision, as many bits as you have memory.
11:31:32 <Cale> I sort of think that Int shouldn't be in the Prelude :)
11:31:41 <monochrom> Implementation detail.  Some haskell compilers use the GMP library for Integer.
11:31:50 <Cale> Well, right.
11:31:57 <mauke> perl -wle 'use bigint; my $f = 1; $f *= $_ for 1 .. 100; print $f'
11:32:23 <Cale> GMP is just one way to supply that functionality.
11:32:38 <Daveman> xerox :D
11:32:39 <monochrom> Java has BigInteger.  The GMP library is written for use in C.  The syntax is bothersome but the expressive power is there.
11:33:04 <kartoo> Aah! This Integer thing is really cool.. Haskell is fit for stuff like Molecular dynamics it seems!! high precision would matter a lot there
11:33:05 <xerox> hi
11:33:19 <emu> GMP and CLISP share an author, but I don't recall if GMP was written originally for CLISP
11:35:22 <emu> kartoo: haskell has a decent set of numeric types, including floating point, ratios, and complex
11:36:16 <Cale> > sum [1/product [1..n] | n <- [0..100]] :: Rational
11:36:18 <lambdabot>  4299778907798767752801199122242037634663518280784714275131782813346597523870...
11:36:26 <Cale> > sum [1/product [1..n] | n <- [0..100]]
11:36:28 <lambdabot>  2.7182818284590455
11:36:28 <kartoo> emu: wow!
11:36:41 <monochrom> Machine code has constant-sized ints and floats.  It doesn't "have" linked lists and trees.  Or does it?  You could write your own, or use a library.  The syntax is going to be cumbersome.
11:36:57 <kartoo> how many such multiprecision datatypes are there in Haskell?
11:37:29 <monochrom> The hallmark of a good language is, when you use a non-native data type, the syntax is just as streamlined as the native ones.
11:37:43 <emu> @instances Num
11:37:44 <lambdabot> Double, Float, Int, Integer
11:37:48 <Cale> kartoo: You can create your own.
11:37:49 <emu> hm that's not the full list
11:38:05 <monochrom> Integer and Rational.
11:38:17 <kartoo> Instance Declaration?
11:38:22 <Cale> kartoo: In the standard libraries, Integer and Rational are basically the only ones.
11:38:37 <emu> you implement Num for your own type
11:39:58 <kartoo> This is cool.. Just starting to be able to appreciate haskell after long time of reading through hoping that I might like it :)
12:02:28 <roconnor> Where does GHC store it's packages?
12:02:33 <roconnor> under linux
12:04:00 <xs> usually /usr/local/lib
12:04:17 <ministepcut> ghc-pkg show pkg might tell you
12:04:21 <roconnor> ah great
12:04:26 <roconnor> I reinstalled ghc
12:04:36 <roconnor> is there an easy way to teach it about the packages I have there?
12:05:17 <earthy> ghc-pkg install
12:07:34 <roconnor> well, there is no install command
12:07:56 <ministepcut> ghc-pkg register ?
12:07:57 <roconnor> does cabal-get work?
12:08:01 <roconnor> maybe I should just reinstall them
12:08:11 <roconnor> seems like a bit of a pain
12:12:07 <SamB_XP_> roconnor: is it the same release?
12:12:11 <roconnor> yep
12:12:16 <roconnor> er
12:12:21 <roconnor> Hmmm
12:12:25 <roconnor> maybe not
12:12:26 <roconnor> good point
12:12:39 <roconnor> ah
12:12:41 <SamB_XP_> still a pain, but...
12:12:41 <roconnor> looks the same
12:12:53 <roconnor> same version of ghc
12:12:59 <SamB_XP_> oh
12:13:13 <roconnor> I upgraded from Dapper to Edgy
12:13:31 <SamB_XP_> huh
12:13:41 <SamB_XP_> but a different build?
12:14:33 <roconnor> let me double check
12:15:20 <bringert> roconnor: if you use cabal-install, it's a breeze to install most packages
12:15:22 <roconnor> ah different version
12:15:27 <roconnor> 6.4.1 vs 6.4.2
12:15:34 <roconnor> okay, a rebuild is in order
12:15:50 <roconnor> bringert: how do I use cabal-install?
12:16:05 <roconnor> or do you just mean the ./Setup.lhs configure build install cycle?
12:16:29 <bringert> roconnor: http://darcs.haskell.org/packages/cabal-install/.
12:16:32 <lambdabot> Title: Index of /packages/cabal-install
12:16:34 <bringert> get that
12:16:48 <bringert> install it with the normal cabal install cycle
12:17:00 <bringert> then use "sudo cabal-install install <pkg>"
12:17:15 <bringert> it downloads, builds and installs for you
12:17:20 <roconnor> does it download from hackage?
12:17:21 <roconnor> ah
12:17:25 <bringert> it gets dependencies too
12:17:42 <bringert> on linux, it just works
12:17:55 <bringert> I'm not sure about Windows
12:18:37 <bringert> roconnor: oh, I forgot, I think it requires you to install the darcs version of cabal as well
12:18:39 <igli> i know the feeling ;)
12:18:54 <ptolomy> say, anyone aware of a haskell implementation of DAWGs (Directed Acyclic Word Graph) or DAG (I assume the name for the more general) that I could look at? I'm having trouble understanding how one would create such a thing in a language without identity.
12:18:57 <bringert> roconnor: but that's quite easy
12:19:27 <bringert> ptolomy: you could use node labels
12:19:32 <roconnor> ah
12:19:42 <roconnor> so what's the diff between cabal-get and cabal-install
12:19:48 <bringert> cabal-get is no more
12:19:54 <bringert> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
12:19:56 <lambdabot> Title: CabalInstall - Hackage - Trac
12:20:00 <ptolomy> bringert: Such as manually assigning an identity value to nodes?
12:20:08 <icarroll> Is there a PNG library for Haskell?
12:20:16 <bringert> ptolomy: could be done automatically, but yeah
12:20:23 <roconnor> sure, but what as the difference between them?
12:20:28 <roconnor> why the name change?
12:20:52 <bringert> icarroll: there's a GD binding
12:21:02 <bringert> roconnor: I don't know
12:22:52 <icarroll> bringert: Thanks. :)
12:26:12 <shapr> Is there a predicate type? I guess it'd be a -> Bool?
12:26:55 <shapr> Is there a way to read an MVar only when it changes value?
12:27:29 <shapr> I'm trying to write an "until" that blocks until an MVar has a particular value.
12:27:52 <sjanssen> shapr: I know you could do it with a TMVar
12:28:01 <Igloo> STM backtracking would do that, wouldn't it?
12:28:54 <sjanssen> otherwise, I don't think you can do it without constantly polling
12:29:03 <shapr> I'll try the STM approach then.
12:29:35 <shapr> How would it work with a TMVar?
12:30:22 <sjanssen> f var oldval = do t <- takeTMVar var; guard (oldval /= t); return t
12:31:30 <ToRA> sjanssen: guard in STM == retry?
12:31:34 <sjanssen> oh, you probably don't want takeTMVar
12:31:58 <sjanssen> ToRA: guard calls mzero when the predicate is false
12:32:07 <sjanssen> mzero = retry for STM
12:33:13 <sjanssen> STM++
12:33:14 <ToRA> do you mean fail or mzero? i can't see a monadplus instance for stm in the apidocs
12:33:35 <sjanssen> @type Control.Monad.guard
12:33:37 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
12:34:40 <dmwit> Why does HashTable have to live in IO?
12:35:12 <sjanssen> ToRA: the instance is in Control.Monad.* somewhere
12:36:27 <dmwit> (This is a philosophical question, not a complaining one.)
12:37:44 <sjanssen> dmwit: we don't have a nice way to express things that work in many monads with mutability
12:37:46 <igli> (it just sounds like one ;)
12:40:17 <dmwit> sjanssen: I'm not sure I understand what you just said.
12:40:24 <dmwit> Are you saying that HashTable is mutable in some way?
12:40:28 <monochrom> HashTable operations break referential transparency.
12:40:57 <sjanssen> dmwit: it needs to be mutable to support updates efficiently
12:41:03 <dylan> I remember bd_ talking about a HashTable based on DiffArray that was pure...
12:41:05 <monochrom> Yes, mutable, deliberately mutable.
12:41:24 <dylan> bd_: *poke*
12:41:30 <monochrom> Somehow DiffArray is still very slow.
12:41:31 <encryptio> is it okay to use unsafePerformIO to read files that will never ever change during the runtime of the program?
12:41:35 <ToRA> sjanssen: aah found it - in C.M.STM, the online haddock doc neglects to mention it :( - cheers for that, useful to know :)
12:41:38 <dmwit> huh
12:41:52 <monochrom> encryptio: that's tough, but I'd say yes.
12:42:21 <sjanssen> encryptio: that's a bit shady
12:42:32 <sjanssen> encryptio: can you possibly avoid it?
12:42:51 <encryptio> sjanssen: not without threading MonadIO a => a all over the place.
12:43:25 <dmwit> encryptio: Read it once at the beginning, then pass it to all the functions that need it?
12:44:34 <monochrom> Since it's a philosophy question, I can also volunteer a philosophy answer.  I'm philosophically against the perl mindset and "let's port perl code to haskell".  The perl mindset includes religiously fitting all data structures into a hash table.  I'm more than happy to lock you inside IO if you try to duplicate that in haskell.
12:44:55 <sjanssen> encryptio: is your program already monadic?
12:45:04 <encryptio> sjanssen: monadic in ReadP
12:45:30 <sjanssen> encryptio: maybe you can add a ReaderT AllTheFilesYouNeed around ReadP
12:45:30 <SamB_XP_> or, worse, ST!
12:45:57 <ptolomy> is HashTable that much faster than Data.Map/IntMap?
12:46:21 <fuzan> does one need to use sempahores with modifyMVar ?  I saw an example in which an alternate MVar was passed around as a "sempaphore" and taken/put as a mutex
12:46:28 <dylan> ptolomy: they are different things. HashTables have different gurantees than Map.
12:46:37 <hpaste>  shapr pasted "silly stm" at http://hpaste.org/1486
12:46:56 <encryptio> the docs look all but nonexistent for Control.Monad.Reader
12:47:07 <sjanssen> hash tables are nonexistent
12:47:27 <sjanssen> encryptio: do you know the State monad?  Reader is just non-modifiable state
12:47:54 <encryptio> i know State(T), yes...
12:48:30 <sjanssen> monochrom: yeah, I think hash tables are overrated
12:48:56 <monochrom> Many people use a hash table for a record.  data Student = Student{name::String; ident::Integer}  they bastardize it as #s["name"]=... #s["ident"]=...  Godawful.
12:49:08 <encryptio> hash tables are awesome, but there are often much better solutions (like a better type system)
12:49:36 <earthy> hash tables do have O(1) lookup given a good hash function
12:49:54 <earthy> which is kinda unbeatable. :)
12:49:56 <encryptio> earthy: and no chaining.
12:50:03 <sjanssen> earthy: in practical terms, O(log n) is just as good
12:50:21 <earthy> sjanssen: that's actually what Doaitse uses in his parsers
12:51:10 <earthy> (builds a search tree of the tokens in the first set, and maps from each token in the first set to the following parser)
12:51:24 <monochrom> You can encode everything as a hash table.  I can encode everything as an Integer.  They are not the most efficient.  They are hardly the most maintainable.
12:52:22 <ptolomy> Hm.. isn't a ST hashtable possible?
12:52:31 <sjanssen> ptolomy: yes
12:52:36 <ptolomy> err "Why is HashTable IO only?"
12:52:58 <monochrom> No one has got around to add ST.
12:53:06 <sjanssen> we don't really have the right language features to be useful
12:53:22 <sjanssen> ATs may make it workable
12:53:33 <dmwit> On a side note, I find this fascinating:
12:53:35 <dmwit> http://en.wikipedia.org/wiki/Cuckoo_hashing
12:53:37 <lambdabot> Title: Cuckoo hashing - Wikipedia, the free encyclopedia
12:53:49 <dmwit> It is counterintuitive (to me) that this should be a better method of hashing in any world.
12:53:57 <monochrom> If you think you will use it in ST all the time, go ahead add it.  Should be just a few more lines of code.  ST and IO are brothers under the hood.
12:54:46 <monochrom> I won't do it.  I certainly couldn't care less.  I have real record types and real syntax, thank you very much.
12:55:41 <sjanssen> not to mention that real records have a major speed advantage
12:55:44 <Botje> dmwit: interesting. implementing the algorithm needs detection of infinite loops :p
12:55:56 <dmwit> Yeah...
12:56:20 <dmwit> And arbitrarily many hash functions.
12:57:00 <encryptio> "many hash functions" is really easy.
12:57:38 <encryptio> if you're willing to let yourself use seeded hash functions: sha1 (seed ++ key) -- for each seed, this is a different hash function
13:11:54 <ptolomy> monochrom: Eew. I wasn't considering using hashtables as a gross fake record. I don't love haskell records, but.. eew. I was more thinking in terms of "golly, I sure use Data.Map a lot. If HashTable is appreciably faster, a ST hashtable could come in handy."
13:13:41 <monochrom> First, it still remains to determine which one is faster.
13:16:36 <monochrom> Even in the most ideal situation (e.g. no collision), the true cost of a hash table op is still O(1 + cost of hashing the key).  Consider %s["ksjdkjfoiweurijkfnmxncvkjhdsjfhewuriuskljkdfdwoeirpsxisdf"].  That takes forever in hashing.  In contrast, if most other keys can be easily distinguished from this particular key by just the first few characters, a BST wins.
13:21:06 <monochrom> Second, most legit applications of hash tables are hopelessly interwined with interacting to the outside world.  For example, in a server, you may want a table recording which port is connected to which client.  Accepting and relinquishing these client connections, and most other operations that needs this table, are in IO already.  It's rare to find a use in ST.
13:24:11 <monochrom> About the only application of hash tables in ST I can think of is: you do DFS over an immutable graph, use a hash table to remember which vertices you've visited.
13:28:05 <monochrom> If you need that application now, feel free to use unsafePerformIO. :)
13:28:50 <monochrom> There is also unsafeIOToST.
13:37:59 <hpaste>  shapr pasted "blocks forever?" at http://hpaste.org/1487
13:43:03 <sjanssen> shapr: you're only executing loop twice, is that intentional?
13:43:15 <shapr> yarr
13:43:17 <shapr> No
13:43:39 <fuzan> phone interviews = 100% adrenaline
13:44:09 <Lemmih> Hi shapr.
13:44:24 <SamB_XP_> fuzan: you should try selling them then!
13:44:32 <shapr> hiya Lemmih, are you in your new abode?
13:44:59 <Lemmih> Yeps (:
13:46:28 <shapr> Yay!
13:48:19 <CosmicRay> shapr!
13:48:29 <shapr> CosmicRay!
13:48:32 <shapr> How's the snow?
13:48:43 <eumenides> http://hpaste.org/1478 does anyone know what the trouble is about with these arrows-0.2 compilation errors?
13:48:50 <CosmicRay> Finally melted!  any where you are?  (I forget exactly where that is..)
13:49:09 <shapr> I'm back in Alabama for now.
13:49:13 <CosmicRay> shapr: you may be interested that I bought a pulse-to-tone converter so I can connect my grandpa's 40-year-old rotary-dial phone to my asterisk box ;-)
13:49:15 <shapr> I spent two weeks in Sweden, it was fun!
13:49:19 <shapr> wow cool!
13:49:26 <fuzan> SamB_XP_: haha, what a business plan!
13:49:35 <CosmicRay> nice.  bit of weathershock with that trip, I bet.
13:49:51 <fuzan> SamB_XP_: Rollercoasters.. psh. Skydiving? psh. Try our interview process, and you might even earn a job!
13:51:12 <dylan> shapr: any success in getting enough south-eastern-US haskell programmers to meet?
13:51:29 <CosmicRay> oh, is anything going to happen in portland for oscon?
13:52:07 <dylan> portland, OR, ja?
13:52:12 <CosmicRay> yeah
13:53:21 <dylan> CosmicRay: hey, you're the author of offlineimap. Thanks for that program.
13:53:22 <SamB_XP_> dylan: south-eastern?
13:53:26 <SamB_XP_> picky-picky!
13:53:38 <dylan> SamB_XP_: it's a larg-ish area.
13:54:52 <dylan> so far, I think there's like 2 haskellers in FL, shapr and an unknown number in AL, and 1 person in GA. Last I heard, anyway.
13:55:02 <dylan> @seen LordBrain
13:55:03 <lambdabot> I saw LordBrain leaving #haskell-overflow, #haskell-blah and #haskell 1d 21h 25m ago, and .
13:56:34 <dylan> there are three window managers written in common lisp, and none in scheme. :(
13:57:06 * dylan ponders embedding a scheme in xmonad.
13:57:11 <dylan> or hs-plugins...
13:57:48 <earthy> hs-plugins would be nicer.
13:57:51 <dino-> I'm working on something. I just added unix to Build-Depends and I get a metric ton of warnings about things like "PACKAGE_TARNAME" redefined and similar. Is that normal?
13:58:00 * earthy ponders shim
13:58:08 * earthy quickly stops pondering
13:58:08 * sjanssen doesn't want either ;)
13:58:14 <dylan> earthy: I want an excuse to use scheme for something other than xbindkeys.
13:58:33 <earthy> dylan: start using gnucash
13:58:36 <dylan> sjanssen: I want to define layout rules at runtime. it's a deep-seated desire.
13:58:52 <dylan> earthy: no, after it lost a years worth of finicial data, I decided to stop using it.
13:59:00 <dylan> *financial.
13:59:12 <earthy> wow. what the fuck did you do for it to break down like that?
13:59:25 <earthy> (and didn't you have the previous save point?)
13:59:40 <SamB_XP_> gnucash RPG! play today!
13:59:49 <dylan> I did nothing to it. it segfaulted.
14:00:04 <dylan> I restarted it, and it did something nuts to all the files in the directory it was supposed to save to.
14:00:05 <dino-> dylan: I'm not trying to sound like a jerk, but regular backups of your ~, my friend.
14:00:20 <dylan> dino-: I lost nothing, but I no longer run gnu cash.
14:00:22 <earthy> plus, gnucash makes a fresh backup on each save
14:00:31 <earthy> save early, save often. :)
14:00:32 * sjanssen is tired of hearing anecdotes about a single slow Haskell program, followed by the generalization "Haskell is slow"
14:00:39 <dylan> ~/ is kept under darcs (and previously, svn. (and previously, cvs))
14:00:45 <earthy> sjanssen: Haskell is actually pretty fast
14:00:56 <earthy> but it doesn't seem like it is
14:01:08 <earthy> we need experience reports
14:01:16 <earthy> (and I suck at writing them ;))
14:01:19 <dylan> I find darcs to be fast enough.
14:01:19 <Codex_> monads make io pretty slow.
14:01:28 <SamB_XP_> Codex_: ?????
14:01:35 <earthy> codex: that's utter utter nonsens and you know it.
14:01:38 <sjanssen> Codex_: you're wrong.
14:01:43 <fuzan> sjanssen: i did an io test comparing my version of cat to my haskell implemenation. it's rouhgly 69% slower for my initial naive solution. but i'm planning to take more stabs at it. I'll post the blog for you guys to pick later.
14:01:50 <SamB_XP_> monads don't really do anything...
14:01:58 <Codex_> maybe I'm just using them wrong. :)
14:02:02 <sjanssen> fuzan: using [Char]?
14:02:06 <dylan> with zero compiler optimization, monadic I/O might be a bit slower. Perhaps...
14:02:25 <earthy> anyway, off to bed.
14:02:29 <SamB_XP_> slower than what?
14:02:31 <earthy> no playing with shim for me today
14:02:41 <dylan> SamB_XP_: than with optimization.
14:02:42 <Codex_> (but I didn't figure out any other way to write pixels to a bitmap...)
14:03:09 <fuzan> sjanssen: bytestring
14:03:12 <earthy> codex: fill an unboxed array
14:03:19 <sjanssen> fuzan: ahh, now that's more interesting
14:03:23 <fuzan> gotta run to school, be back in like 10
14:03:26 <earthy> then marshall that out in one go
14:03:29 <fuzan> i may be doing something stupid.
14:03:40 <fuzan> let me link you righ tnow.
14:03:50 <sjanssen> fuzan: yeah, definitely paste it
14:04:01 <sjanssen> #haskell is GHC's missing -O3 flag
14:04:03 <fuzan> http://fuzan.org/?q=node/13
14:04:06 <lambdabot> Title: Rewriting Basic Utilities in Haskell | Functional Fuzan
14:04:27 <fuzan> i'm practicing my blog writing skills :) i'm not comfortable enough to attempt something publicworthy :)
14:08:01 <sjanssen> fuzan: I have a feeling that cat doesn't do the line splitting thing when the input isn't from a terminal
14:08:08 <sjanssen> that could explain a pretty big speed hit
14:08:16 <roemer> hi guys
14:09:21 <sjanssen> greetings
14:09:25 <roemer> i've got a problem: first time i'm using readFile and writeFile. when, in an application, i've opened a file, and used data from it, and want to write it back, using writeFile (same path), i get an lock-error... someone know how to deal with this?
14:10:58 <monochrom> It's unsafe to readFile and then write to it.
14:11:20 <monochrom> (It is unclear when the reading is really finished.)
14:11:54 <monochrom> Let me see: if we make sure the whole file has been read, is it ok then?
14:12:00 <roemer> yes
14:12:40 <roemer> seems logic... so... i guess i have to search for a function which checks that?
14:13:18 <monochrom> OK. Force the file to be read, even if you don't use the data.
14:13:49 <ptolomy> if I pass ghc '-O3', does it interprets that as 'oh. you mean -O2. Okay.'?
14:14:33 <monochrom> do { xs <- readFile; ... ; seq (last xs) (return ()); writeFile ... }   may work.
14:14:40 <igli> don't know about that, but -O3 is a waste of time tbh ptolomy
14:15:20 <ptolomy> igli: Don't doubt it is.. I just noticed that an old build script of mine uses it, and I thought, "Wait a minute.. the docs only mention -O2.."
14:15:42 <ptolomy> (I assume you mean waste of time in terms of 'will take longer to compile and not likely to result in faster code')
14:15:48 <igli> ah ok, well it's gcc more than ghc
14:15:52 <igli> heh indeed
14:16:18 <igli> known to result in slower code in the majority of cases tbh; it's more a testing ground for optimisation.
14:17:04 <monochrom> I tried and it works.
14:18:51 <monochrom> If the file is so large that you don't want to waste time to read the rest of the file (it does take time and battery power), you have to avoid readFile, and have to use openFile and close explicitly for precise control.
14:20:15 <monochrom> hClose instead of close :)
14:21:18 <roemer> tnx :) think that may help
14:21:27 <monochrom> There is a best of both worlds.
14:22:03 <hpaste>  monochrom pasted "premature close and write" at http://hpaste.org/1488
14:22:10 <monochrom> Try that one.
14:23:15 <monochrom> Normally hGetContents will automatically close after all is read. If your program reads everything anyway, that's good.  But if you positively plan to skip things, may as well close it manually.
14:23:36 <monochrom> Note that after closing, the content of cs is no longer valid. Don't use it.
14:23:51 <monochrom> Clarification. Note that after closing, the content of cs is no longer valid. Don't use cs after closing.
14:23:55 <dino-> monochrom: Is this a situation where non-lazy bytestring stuff may be of use as well?
14:24:48 <monochrom> I haven't learned the bytestring lib.  But most likely yes.  Maybe even lazy bytestring provides that much control too.
14:33:11 <fuzan> sjanssen: anything to pick on? :)
14:38:04 <sjanssen> fuzan: I see no appreciable difference between the two
14:38:28 <fuzan> sjanssen: what do you mean?
14:38:30 <sjanssen> for a 350MB file
14:38:37 <sjanssen> between standard cat and your program
14:38:44 <fuzan> in your benchmakrs?
14:38:59 <fuzan> maybe my machine is thrashing on the haskell implementation. what options did you compile with?
14:39:23 <sjanssen> -O2
14:39:33 <fuzan> hmm. let me try again.
14:43:20 <fuzan> sjanssen: i'm getting the same results.
14:43:28 <fuzan> sjanssen: ~.505 compared to ~.747
14:44:20 <sjanssen> my test file might not be large enough
14:44:36 <dolio> cat appears to be about 20% faster on my machine.
14:44:38 <sjanssen> I'm sure the entire 350MB is in RAM
14:44:49 <dolio> Using ghc 6.7
14:45:05 <fuzan> dolio: than my solution?
14:45:10 <dolio> Right.
14:45:20 <fuzan> let me vary the filesize.
14:47:05 <fuzan> .07/.11 with a 102m file.
14:47:23 <fuzan> > 0.07 / 0.11 * 100
14:47:25 <lambdabot>  63.63636363636365
14:47:33 <fuzan> yah, roughly the same difference.
14:48:57 <dolio> Didn't dons have some page where he was showing various ways of implementing cat in Haskell, and actually beat C on one?
14:49:28 <dolio> Or was that something else? wc, maybe?
14:49:49 <SamB_XP_> wc I'm pretty sure was done
14:50:01 <SamB_XP_> not sure about cat...
14:50:19 <fuzan> is there anyway to optimize my solution?
14:54:22 <dolio> fuzan: There's not much to optimize there, besides ByteString and the compiler itself.
14:54:22 <fuzan> i think it's probably due to GC.
14:54:59 <waern> dcoutts: ping
14:55:08 <monochrom> LazyByteString may reduce GC pressure. (Fewer, bigger items to deallocate)
14:55:26 <fuzan> I am using ByteString.Lazy :(
14:55:48 <monochrom> Increase heap. Play with # of generations.
14:55:56 <fuzan> ghc opts?
14:56:05 <monochrom> +RTS opts
14:57:03 <monochrom> +RTS -H10000000m -G1
14:57:18 <monochrom> (I hate it when I am the one looking up the doc)
14:57:33 <fuzan> if found this:  http://www.macs.hw.ac.uk/~dsg/gph/docs/4.06/users_guide/runtime-control.html
14:57:38 <lambdabot> http://tinyurl.com/ytkemm
14:58:16 <monochrom> Have you ever seen http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html ?
14:58:19 <lambdabot> Title: The Glorious Glasgow Haskell Compilation System User's Guide, Version 6.6, http://tinyurl.com/y4o7nt
14:58:44 <fuzan> nope, but i've just marked it.
14:59:45 <sjanssen> I don't think this program is GC bound
15:00:38 <monochrom> @google GHC doc
15:00:47 <monochrom> @botsnack
15:01:01 <augustss> woo woo, I can irc again :)
15:01:07 <lambdabot> augustss: You have 1 new message. '/msg lambdabot @messages' to read it.
15:01:08 <lambdabot> http://www.freshports.org/lang/ghc-doc
15:01:09 <lambdabot> Title: FreshPorts -- lang/ghc-doc
15:01:09 <lambdabot> :)
15:02:07 <monochrom> Well, freshports is still useful because it suggests http://www.haskell.org/ghc/documentation.html
15:02:09 <lambdabot> Title: The Glasgow Haskell Compiler
15:03:42 <fuzan> it's neither bound by the GC, stack, or heap sizes
15:03:48 <fuzan> in my experiments
15:04:17 <sjanssen> I see a few possible factors:
15:04:28 <augustss> @users
15:04:29 <lambdabot> Maximum users seen in #haskell: 336, currently: 301 (89.6%), active: 35 (11.6%)
15:04:55 <sjanssen> ByteString will allocate a new buffer for each chunk, cat reuses the same buffer.  So you might be seeing cache effects
15:05:31 <monochrom> each chunk is 64K
15:05:36 <sjanssen> actually, that's the only thing I see
15:08:44 <fuzan> hmm.
15:08:55 <sjanssen> by "see", I mean "imagine"
15:09:06 <sjanssen> or cat uses some fancy IO mechanism?
15:11:32 <nominolo> hm, how do you do binary search at the type-level?
15:12:41 <sjanssen> you have a type level array?
15:12:58 <nominolo> a type-level binary tree
15:13:04 <nominolo> though, i might make it a list
15:13:31 <sjanssen> think prolog
15:13:45 <sorear> nominolo: just remember that case can only be done using a class.
15:13:49 <sorear> take it from there
15:14:57 <nominolo> the problem is, that if i have a class Tree s, instance Tree A, instance Tree B, .. instance (Tree a, Tree b) => Tree (a,b)
15:15:05 <nominolo> now, i try to look
15:15:34 <sjanssen> you probably don't want a Tree type class
15:15:38 <nominolo> class Tree a => Has a x; instance Has A A
15:15:49 <nominolo> now here's the problem:
15:16:07 <ptolomy> I think the chances of writing a haskell program that is faster than a specialized, mature, and non-naive C program aren't that good.
15:16:52 <sjanssen> ptolomy: but the chances of writing a Haskell program that is more robust in less time is -- IMO
15:17:03 <nominolo> instance (Tree a, Tree b, Tree (a,b), ... oh
15:17:04 <ptolomy> Absolutely.
15:17:21 <nominolo> hm,  maybe that works
15:18:41 <matthew-_> @seenbringert
15:18:41 <lambdabot> Unknown command, try @list
15:18:43 <matthew-_> @seen bringert
15:18:44 <lambdabot> bringert is in #haskell. I last heard bringert speak 2h 57m 41s ago.
15:18:52 <bringert> hi matthew-_
15:18:56 <matthew-_> ahh!
15:19:13 <matthew-_> um, I notice that the version of parsedate on hackage is older than the one on your website.
15:19:20 <sorear> hello.
15:20:07 <sorear> @flush
15:20:09 <sorear> @uptime
15:20:09 <lambdabot> uptime: 4d 19h 53m 49s, longest uptime: 5d 3h 40m 45s
15:21:07 <bringert> matthew-_: parsedate isn't really updated anymore, it's been merged into the time package.
15:21:12 <matthew-_> oh!
15:21:14 <monochrom> mind-numbing tasks such as copy stdin to stdout --- you can't beat C or machine code.  At best you can write a haskell program that writes the best C or machine code program.
15:21:53 <bringert> matthew-_: but Ashley has said that he plans to split up the time package, and the version with parsing has not been released yet. it's only available in darcs
15:22:03 <sorear> monochrom: IO bound code is just as fast in Haskell as C :)
15:22:03 <monochrom> However, complicated tasks --- you can beat C or machine code, since no one will bother to handcode the most efficient C or machine code program for that task.
15:22:54 <Batterseapower> does anyone know of a Haskell curses wrapper?
15:23:11 <Batterseapower> i'm trying to import curses myself but its a real headache
15:23:28 <matthew-_> bringert: ok. so for the time being, as I have code that depends on the parsecCalendarTime method, should I just push people towards your website for parsedate?
15:23:37 <sorear> @where hscurses
15:23:38 <lambdabot> http://www.informatik.uni-freiburg.de/~wehr/haskell/
15:23:56 <monochrom> sorear: we're experiencing "cat" being still faster than a ByteString.Lazy implementation.  Our current conjecture is: cat reuses the same buffer, bytestring uses new chucks all the time, cache hit vs cache flush.
15:23:59 <ptolomy> or curses.hsc from hmp3.
15:24:04 <bringert> matthew-_: oh, I guess I could just upload the current parsedate to hackge in the meantime
15:24:28 <Batterseapower> sorear, ptolomy: thanks a lot! i'll look into both
15:24:46 <sorear> ptolomy, Batterseapower: curses.hsc from hmp3 is just an older version of hscurses
15:24:49 <nominolo> !hpaste
15:24:59 <nominolo> !paste
15:25:00 <hpaste> Haskell paste bin: http://hpaste.org/
15:25:20 <Philippa> is there a tolerable curses emulation available for windows, JOOI?
15:25:30 <sorear> monochrom: really?  even with real workloads?  (my disks cap out at 100MBps, thank you)
15:25:37 <matthew-_> bringert: that would be great ;) Being under BSD3, I guess I could just distribute it myself to eliminate the dependency.
15:25:42 <sorear> who is JOOI?
15:25:49 <ptolomy> sorear: Really? wiki says it is smaller, but has the advantage of ByteString support.
15:25:50 <matthew-_> just out of interest
15:26:04 <monochrom> sorear: fuzan is obtaining such results.  I haven't tried myself.
15:26:13 <bringert> gotta reboot, brb
15:26:13 <sjanssen> I'm not seeing any difference
15:26:17 <Batterseapower> apparently JOOI = just out of interest
15:26:26 <sorear> ptolomy: I'm speaking from a comment in the hs-curses sources.
15:26:37 <Batterseapower> actually, i'm going to have to compile this wrapper with pdcurses.. hope this isnt going to be a problem  :/
15:26:45 <sorear> ptolomy: hs-curses used to be part of hmp3, but was split out
15:27:06 * matthew-_ votes for -bot doing automatic acronynm expansion...
15:27:07 * ptolomy was working on a curses-type lib using ansi stuff with the intention of making it cross-platform and quickly learned that he is an idiot.
15:27:30 <Philippa> automatic would be bad
15:27:34 <Philippa> on-demand'd be a good feature though, yeah
15:27:44 <Philippa> heh
15:27:54 <sorear> ptolomy: you can look at my abandoned curses-type lib
15:27:56 <Philippa> yeah, I wouldn't want to do it
15:28:22 <sorear> ptolomy: it's fast enough that the benchmark program spends 75% of its time in the tty driver, not user
15:28:44 <sorear> ptolomy: otoh, it's missing all the clever diff algorithms and terminfo support
15:29:53 <monochrom> sorear: I think this conjecture can be defended.  Have GBs of RAM, experimenting with merely MBs of file.  First experiment is IO bound.  Subsequently just an exercise of copying RAM to cache.  The difference between cat and lazybytestring is then RAM to cache hit vs RAM to cache flush.
15:30:17 <monochrom> Damn, there is a word for "can be defended".  It's "tenable".
15:30:22 <hpaste>  nominolo pasted "I might need a list" at http://hpaste.org/1489
15:30:32 * sorear works with 10+ gb's of files and <400 mb's of ram
15:30:53 <Batterseapower> monochrom: what about "defensible"? :)
15:31:18 <monochrom> Yes, that is I/O bound, cache performance is helped because it has time to prefetch.
15:31:21 <nominolo> ok, i guess binary trees down work that well in the haskell type-checker ...
15:31:28 <nominolo> any ideas?
15:31:41 <nominolo> otherwise, i just change to a list
15:31:48 <monochrom> If HList works, the same idea carries over to trees.
15:32:01 <monochrom> Perhaps HList doesn't work.
15:32:10 <sorear> nominolo: your Tree a => context is stupid, because it forces the whole tree to be validated
15:32:10 <sjanssen> nominolo: that isn't binary search, by the way
15:32:46 <sorear> nominolo: if you care about efficiency use a real tree (with ordering and interior nodes), otherwise use a list
15:32:48 <nominolo> sjanssen: well, it's backtracking search
15:33:00 <sorear> nominolo: backtracking /= binary
15:33:11 * nominolo knows
15:33:31 <monochrom> First, try not to backtrack.
15:34:07 <sorear> That won't be a problem.
15:34:09 <nominolo> well, it's only done during typechecking
15:34:15 <sorear> GHC - Prolog = backtracking
15:34:33 <sorear> the fact that you need backtracking is the reason your code doesn't work
15:34:37 <monochrom> Woah?  I thought that's Prolog - GHC.
15:34:40 <sorear> backtracking simply isn't supported.
15:34:48 <sorear> monochrom: er, right :)
15:34:53 <monochrom> OK!
15:34:54 <nominolo> sorear: how do you mean "your Tree a => context is stupid, because it forces the whole tree to be validated" ?
15:35:12 <monochrom> (You can't backtrack a HList either.)
15:35:16 * nominolo votes for replacing Haskell type-system with prolog
15:35:34 * monochrom votes for full specification before implementation
15:35:43 <monochrom> and full proof of refinement
15:35:56 <sorear> nominolo: to check 'Has <tree> <type>', the type checker must first check 'Tree <tree>', which requires validation on the whole tree ... O(n)
15:36:02 <nominolo> monochrom: well, in haskell spec and code are often quite the same
15:36:31 <ptolomy> Hmm. with my records, I see a common pattern of "foo { field = someFunction (field foo) }"..  is there a way to abstract that out into a function?
15:36:37 <augustss> but you can't do proper specs in haskell
15:37:23 <nominolo> sorear: ok.  i don't get it completely.  but i haven't read the papers yet, i'm just trying to solve an immediate problem ..
15:37:54 <Philippa> ptolomy: not currently, unfortunately
15:38:05 <ptolomy> Dang.
15:38:06 <eumenides> @type readFile >>> print
15:38:08 <lambdabot>     No instance for (Show (IO String))
15:38:09 <lambdabot>       arising from use of `print' at <interactive>:1:13-17
15:38:24 <sorear> @type readFile >>= print
15:38:27 <lambdabot>     Couldn't match expected type `(->) FilePath'
15:38:27 <lambdabot>            against inferred type `IO'
15:38:30 <nominolo> ptolomy: unfortunately, no.  i had the same problem ..
15:38:45 <sorear> ptolomy: you CAN do it, but not directly in haskell
15:38:49 <nominolo> you might be able to use TH, though
15:38:52 <igli> hmm no backtracking? i thought the data persistence could give you a similar thing?
15:38:55 * ptolomy is scared of TH.
15:39:02 <sorear> ptolomy: you would need to generate code, Derive or similar
15:39:02 * nominolo too
15:39:09 <augustss> ptolomy: haskell records are a nasty addon.  they are not that wonderful
15:39:19 <sorear> ptolomy: look at Data/Derive/Set.hs, you should be able to use it
15:39:27 <sorear> if you dare
15:39:54 <augustss> @djinn-env
15:39:55 <eumenides> haskell records are awesome. i can't imagine writing anything longer than 100 lines without them
15:39:55 <lambdabot> Plugin `djinn' failed with: IRCRaised Data.ByteString.last: empty ByteString
15:40:38 <augustss> when are we going to get the working lambda-bot back?
15:40:44 <Batterseapower> sorear: ok, seems like its going to be a big deal to convert hscurses to use pdcurses :( and i cant find a hspdcurses.. do you any other useful links at all?
15:40:48 * Batterseapower looks hopeful
15:42:42 <Heffalump> lambdabot has lost its magic smoke!
15:44:22 <monochrom> If proof checker doesn't believe your proof of correctness, code doesn't compile. No testing allowed until proof goes through. Then you can test.
15:44:22 <monochrom> Yes. Just often.
15:44:26 <monochrom> Anyway, think of it as using QuickCheck's language for type signatures.  The checker, though, doesn't just try random tests.  It expects you to provide a full proof, and it checks your proof.
15:44:33 <monochrom> Clearly, the most popular way of using this system is: you write in the type signature "anything is mapped to anything".  Then you have nothing to proof.  In the doc, you write "it happens to answer 42".
15:44:46 <monochrom> The moral is: if you have an expressive type system, people will at first be excited, then they start falling back to a restricted subset of it, and you're back to prolog - backtracking.
15:47:33 <monochrom> I like eumenides. A fan of haskell records.  Rare these days. :)
15:48:40 <augustss> I'm a fan of records.  just not haskell records :)
15:49:39 <Batterseapower> forgive my ignorance, but why are haskell records considered evil?
15:49:56 <Heffalump> they're not really evil, they're just not very good
15:49:57 <augustss> not evil, just not very nice
15:50:17 <Heffalump> and record update syntax is an ugly wart on the "function application binds tighter than everything else" rule that otherwise applies
15:50:37 <augustss> for one, field names have to b unique.  just like in C of 1978
15:50:57 <Batterseapower> well, i did know about that namespace pollution issue
15:51:19 <Batterseapower> are there any other nasties i should know about though?
15:51:55 <sorear> augustss: are eg. ML records any better?
15:52:10 <augustss> record update not only binds funny, it's alo not first class like most construct
15:52:12 <Heffalump> record updating isn't first-class, either. But that's workable round by just defining a function.
15:52:23 <Heffalump> sorear: ML has records?
15:52:26 <sorear> augustss: can better records be implemented without subtyping (--> typed binders)
15:52:33 <augustss> sorear: if you are referring to SML records, only a little better
15:52:35 <sorear> Heffalump: oca at least
15:52:41 * Heffalump hasn't used ML for ages, so can't remember.
15:53:02 <monochrom> haskell records are not evil. just imperfect.
15:53:25 <Philippa> augustss: I don't mind the unique field names so much in the absence of subtyping or similar. Though that's arguably rather the issue
15:53:51 <augustss> Philippa: overloading is enough
15:53:53 <Philippa> sorear: HList :-)
15:54:07 <Philippa> yeah, I know. Like I said, rather the issue
15:54:20 <augustss> it's not an easy problem.  if it were, we'd have better records by now
15:54:33 <augustss> Philippa: yeah, I know you do :)
15:55:07 <Philippa> I think if we'd not got the existing system we'd have better records now
15:55:26 <augustss> most likely
15:55:31 <Philippa> although I don't know whether we would've got something TREXish or something based on Daan Leijen's work
15:55:50 <augustss> but it's somewhat symmetrical with constructors having to be unique
15:55:53 <dmead> happy 4/20 pals
15:56:04 <dmead> *cheers*
15:56:20 <Heffalump> dmead: ??
15:56:22 <Philippa> dmead: did you bring enough to share?
15:56:29 <dmead> no =/
15:56:41 <augustss> oh, 420
15:56:55 <dmead> aka 4:20
15:57:06 <augustss> Heffalump: use wikipedia
15:57:17 <Heffalump> so I've just been told :-)
15:58:20 <bd_> dylan: hm?
15:58:24 <bd_> 15:39 < dylan> I remember bd_ talking about a HashTable based on DiffArray that was pure...
15:58:40 <bd_> dylan: I wrote one, but it's not tested or benchmarked or optimized really >.>
15:58:48 <bd_> Maybe I wrote a few quickcheck properties
15:59:25 <Batterseapower> augustss, Philippa: do you know a resource where the uninitiated can learn what record overloading is? :) my google-fu seems weak today
15:59:49 <Philippa> Batterseapower: it would be overloading of field accessors rather than of records
16:00:20 <Batterseapower> oh, if you added a subtype relationship on records?
16:00:23 <Philippa> if you declared them all overloaded and defined the sugar in terms of them, you'd immediately significantly improve the record system's power
16:00:34 <Philippa> just using type classes
16:00:58 <Batterseapower> right, i think i see.. thanks!
16:01:10 <ptolomy> hmm.. is it possible (i'm currently failing) to make a class (let's call it Tupeable) that has a function 'toTup :: [a] -> C a' where C can be (,), (,,), etc.. I can't really figure out how to do it.
16:01:38 <Philippa> no, because you can't tell how many items're in the lists
16:02:11 <Batterseapower> you could return bottom if the list length is wrong, i guess?
16:02:11 <Philippa> so you can't tell the type of the tuple without inspecting the list value
16:02:18 <Batterseapower> but its sort of useless :)
16:02:38 <Philippa> point
16:03:42 <ptolomy> well, I was planning on having the return type be '(MyMonad m) => m (C a)', and my monad would handle the bad lenghts.
16:04:32 <Philippa> ah. It still can't be C a though
16:04:43 <ptolomy> oh.
16:04:44 <ptolomy> right.
16:04:46 * ptolomy sees.
16:04:54 <ptolomy> wait.
16:04:55 * ptolomy un-gets it.
16:05:00 <ptolomy> backtrack!
16:07:03 <ptolomy> Oh, right. the Cs has varying lengths of type arguments.
16:18:44 <encryptio> @pl (\x y -> take 2 x == take 2 y)
16:18:45 <lambdabot> (. take 2) . (==) . take 2
16:19:08 <xerox> ptolomy, ping
16:19:41 <hpaste>  xerox pasted "Toople - ptolomy" at http://hpaste.org/1490
16:20:13 * ptolomy boggles.
16:20:17 <ptolomy> Neat! thanks.
16:20:58 <encryptio> @hoogle toLower
16:20:59 <lambdabot> Char.toLower :: Char -> Char
16:21:13 <xerox> you're welcome
16:24:44 <vagif> hello, question on HaXml installation on ubuntu
16:24:55 <vagif> running make
16:25:01 <vagif> gives me following:
16:25:37 <vagif> mv: cannot stat 'a.out': No cush file or directory
16:29:48 <dons> moin
16:29:48 <lambdabot> dons: You have 4 new messages. '/msg lambdabot @messages' to read them.
16:36:27 <sorear> hekllo dons
16:39:57 <sorear> @seen glguy
16:39:57 <lambdabot> glguy is in #haskell. I last heard glguy speak 3d 3h 46m 21s ago.
16:49:24 <sorear> @users
16:49:24 <lambdabot> Maximum users seen in #haskell: 336, currently: 292 (86.9%), active: 31 (10.6%)
16:49:47 <sorear> @seen ndm
16:49:48 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 5h 30m 38s ago, and .
16:58:56 <dmead> @losers
16:58:57 <lambdabot> Maximum users seen in #haskell: 336, currently: 293 (87.2%), active: 29 (9.9%)
16:59:08 <dmead> ?karma dmead
16:59:09 <lambdabot> You have a karma of 4
16:59:17 <dmead> ?karma sorear
16:59:17 <lambdabot> sorear has a karma of 36
16:59:34 <sorear> ?karma audreyt
16:59:35 <lambdabot> audreyt has a karma of 634
16:59:40 <dmead> :o
16:59:48 <Saizan> 634?
16:59:49 <sorear> see, I've got practically no karma.
16:59:59 <Saizan> ?karma Saizan
16:59:59 <lambdabot> You have a karma of 2
17:00:09 <sorear> Saizan: yes, audreyt is quite the karma monger
17:00:26 <Saizan> mmh what has he done for it?
17:00:30 <sorear> Saizan: she even has a bot to ++ her semi-automatically :)
17:00:44 <Saizan> :D
17:01:37 <sorear> [03:50] <svnbot6> r11066 | lwall++ | Latest thinking on STM verbiage.
17:01:37 <sorear> lwall--
17:01:44 * dmead is away: stargate... i mean fargate time
17:01:52 <sorear> the #perl6 commit announce bots use ++
17:02:07 <Saizan> that's cheating!
17:02:59 <Saizan> btw, we need multichannel for hpaste!
17:03:02 <sorear> at least it doesn't do nick swizzling correctly.
17:03:08 <sorear> @karma TimToady
17:03:09 <lambdabot> TimToady has a karma of 30
17:03:25 <sorear> he's an active committer, but not under that name!
17:03:31 <sorear> @karma lwall
17:03:32 <lambdabot> lwall has a karma of 64
17:04:37 <sorear> Saizan: I poked glguy a week ago with patches to implement machine readable rc-lists, and he says "ok, I'll apply it toneight" ... 4+ days ago
17:04:45 <sorear> so don't expect anything soon
17:04:54 <sorear> @karma C/C
17:04:55 <lambdabot> C/C has a karma of 22
17:05:09 <Saizan> on hpaste-devel?
17:05:16 <Adamant> dmead: yeah, it's bad for you... but we f-ing need it!
17:05:32 <stepcut> ?karma stepcut
17:05:33 <lambdabot> You have a karma of 4
17:05:38 <sorear> hpaste-devel?
17:05:44 <sorear> never heard of it!
17:05:48 * sorear joins
17:06:03 <Saizan> well, the hpaste repo has code for the old api
17:06:09 <sorear>    No such list hpaste-devel
17:06:19 <Saizan> hpaste-devel is almost 0.8.8
17:06:28 <Saizan> http://www.scannedinavian.com/~eric/hpaste-devel
17:07:22 <Saizan> (a repo, not a list)
17:08:12 <sorear> hehe.
17:09:43 <Saizan> deriving xml for non record types is ugly, with a contructor A Int Int, parsing has to care about the order..
17:13:50 <dmead> Adamant, NEPTUNIANS SUCK
17:14:10 <Adamant> dmead, but what about Mooninites?
17:14:33 <dmead> on the moon, their weekends are so advanced they encompass the entire week
17:14:45 <Adamant> QUAD LASER!
17:14:53 <dmead> dude
17:14:54 <dmead> my dad
17:14:58 <dmead> owns a dealership
17:15:11 <Adamant> :)
17:16:52 <Saizan> tonight i was among some art-literature students, is nice to return home and read some sci-fiction-related conversation :D
17:17:07 <Adamant> heh, not quite sci-fi
17:17:09 <Adamant> :)
17:21:10 <MarcWeber> y
17:21:51 <ClaudiusMaximus> @hoogle (Monad m) => m a -> m (m a)
17:21:52 <lambdabot> Prelude.id :: a -> a
17:21:52 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
17:21:52 <lambdabot> Prelude.asTypeOf :: a -> a -> a
17:22:20 <ClaudiusMaximus> @hoogle power
17:22:21 <lambdabot> No matches found
17:22:47 <dmwit> :t join
17:22:50 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:23:05 <Saizan>  m a -> m (m a) is cojoin :)
17:23:07 <dmwit> ClaudiusMaximus: What are you looking for?
17:23:11 <dmwit> A powerset function?
17:23:14 <ClaudiusMaximus> dmwit: yes
17:23:30 <dmwit> ?go Licensed prelude extensions
17:23:35 <lambdabot> http://devlinux.org/
17:23:35 <lambdabot> Title: dev/Linux: the First Hackers' Distributed Republic
17:24:50 <Saizan> let pset [] = [[]]; pset (x:xs) = let ys = pset xs in map (x:) ys ++ ys in pset [1..3]
17:24:59 <Saizan> > let pset [] = [[]]; pset (x:xs) = let ys = pset xs in map (x:) ys ++ ys in pset [1..3]
17:25:00 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
17:25:35 <dmwit> > let pset = filterM (const [True, False]) in pset [1..3]
17:25:37 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
17:26:02 <ClaudiusMaximus> thanks :)
17:26:13 <dmwit> :t filterM
17:26:15 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
17:26:42 <dmwit> Hmmm, how does that work?
17:26:45 <dmwit> :src filterM
17:26:50 <dmwit> ?src filterM
17:26:51 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
17:27:04 <Saizan> filterM for [] is a decision tree
17:28:37 <dmwit> Ah, got it.
17:28:40 <dmwit> Very cool.
17:30:20 <Saizan> ?type let filterM f (x:xs) = f x >>= \b -> if b then return x else fail "" in filterM -- ?
17:30:22 <lambdabot> forall t (m :: * -> *). (Monad m) => (t -> m Bool) -> [t] -> m t
17:30:57 <Saizan> > let filterM f (x:xs) = f x >>= \b -> if b then return x else fail "" in filterM (const [True,False]) [1..3]
17:30:59 <lambdabot>  [1]
17:31:10 <Saizan> not quite :)
17:31:20 <Saizan> oh, the recursion..
17:32:38 <dons> sjanssen: i'm back. what remains to do? just the web page content?
17:33:07 <Saizan> > let filterM f (x:xs) = f x >>= \b -> if b then fmap (x:) (filterM f xs) else filterM f xs; filterM _ [] = return [] in filterM (const [True,False]) [1..3]
17:33:09 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
17:33:13 <dmwit> > let filterM _ [] = return []; filterM p (x:xs) = do { t <- p x; xs' <- filterM p xs; return (if t then x:xs' else xs') } in filterM (const [True, False]) [1..3]
17:33:15 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
17:33:20 <sorear> what hackage package is Data.FingerTree in?
17:33:29 <sorear> or will I have to package it myself?
17:33:31 <dons> its in base, as Data.Sequence
17:33:43 <sorear> Too crippled :(
17:33:52 <dons> that's the only impl. i know of.
17:34:04 * sorear recognizes that the D.FT co-author is the hackage maint, and hopes this is significant
17:34:08 <dons> feel free to write a full fingerTree impl (maybe there's on on the papers's website?)
17:34:18 <dons> also, check Hinze's site.
17:34:22 <sorear> the paper's site has a full impl.
17:34:31 <dons> take it and cabalise it then :-)
17:34:35 <dons> then CC. Ross and ralf about it
17:34:38 <sorear> I've seen the .hs file from Hinze and Paterson.
17:34:43 <dons> its the open source way!
17:34:49 <sorear> ok, then :)
17:35:09 <sorear> should I have cc'd Daan for cabalizing pprint?
17:35:09 * dons is full of caffeine and back in the sun
17:35:13 <dons> let's take over the world!!
17:35:15 <sorear> yeah!
17:35:30 <dons> sorear: yeah, its always a good idea to CC. the original author when you do some packaging
17:35:36 * Saizan is full of alcohol and in the dark
17:35:50 <dons> hah
17:35:54 <dons> ?temp
17:35:54 <lambdabot>   now 21.2, min 14.6, max 21.2, rain 0.0mm, wind 6km/h SW
17:36:01 <dons> not so warm though. ah well.
17:36:26 * sorear is in San Diego, which just happens to be having a rainy day ATM
17:36:29 <dons> sorear: oh, did you look at duncan's Language.C mail?
17:36:31 <ddarius> You need the bot to tell you that?
17:36:40 <Saizan> (mmh that sentence is a summary of my life..)
17:36:53 <sorear> dons: I read it, I didn't see much significance-to-me
17:37:12 <sorear> I don't need much of a language.c
17:37:16 <dons> oh, you don't do much C programming/generation?
17:37:20 <dons> ok.
17:37:22 <sorear> I have use for a pretty printer, but that's it
17:37:33 <dons> yeah, and doing clever transforms on C.
17:37:41 <dons> want to write your own optimiser ;-0
17:37:51 <sorear> the problem with these parsers is that they are non-modular
17:38:20 <sorear> if you want to write a preprocessor adding ADTs and deriving to C, you need to write a special parser
17:38:46 <sorear> so I just massively restrict the grammer, and force people to define adts in separate files :(
17:39:08 * sorear suspects modular parsers is firmly in thesis territory
17:39:15 <sorear> s/is/are
17:39:20 <ddarius> @google "Earley parser"
17:39:22 <lambdabot> http://en.wikipedia.org/wiki/Earley's_algorithm
17:39:43 <sorear> ddarius: I'd rather not have cubic time either :)
17:40:07 <sorear> besides, C is context sensitive
17:40:43 <Saizan> :O
17:40:44 <dons> you know, there are commercial parsers for C that sell for real money
17:40:58 <dons> people have been known to make quite a bit out of analysing C programs.
17:41:08 <ddarius> sorear: Have fun finding an efficient general context sensitive parser.
17:41:12 <dons> and haskell would be an ideal candidate for writing such analysers.
17:41:32 <dons> hint: you could make money out of haskell, just writing C analysers, given a full Language.C
17:41:36 <sorear> analysing is such a generic word, what does it mean in this context?
17:41:52 <dons> any kind of analysis on the src.
17:41:59 <dons> an extended lint. a type checker for a richer type system.
17:42:03 <dons> finding bugs, basically
17:42:21 <sorear> heh.  (reading your mail)  didn't you write just such a program for ICFP? ;)
17:42:30 <dons> i wrote a generator, yeah
17:42:34 <dons> and optimiser.
17:42:41 <dons> i wish we'd had language.C at the time
17:42:43 * sorear wonders if fftw in 400 loc is posible with Language.C
17:43:10 <dons> exactly. pick a big commercial program written in C/C++, with a well understood algorithm at its core.
17:43:21 <dons> and then specialise it generatively. ==> $profit
17:45:31 * sorear can't count how many times he's wondered "why doesn't grep just output machine code into memory?  surely it would be a lot faster that way!"
17:46:22 <Saizan> a common question, indeed.
17:46:25 <monochrom> grep outputs machine code?
17:47:42 <SamB_XP_> monochrom: no. but it could compile a regex to such!
17:47:43 <dons> well, it does `compile' the regex
17:47:52 <dons> but a native code regex compiler. hmm. tasty
17:48:09 <monochrom> Not every unix utility has to be ghc.
17:48:15 <dons> sorear: want to get a haskell workshop paper? write a `jit' native code regex lib :-)
17:48:22 <dons> monochrom: only the fun ones. :-)
17:49:44 <Saizan> and typechecked regex expressions
17:49:49 <sorear> Well, I'm an impatient #haskeller which is a bit of a special case.  200MB of logs in cache and <1 second of patience.
17:50:14 <QtPlatypus> sorear: Impatience is good.
17:50:16 <dons> mm, http://tlca.di.unito.it/opltlca/
17:50:19 <lambdabot> Title: TLCA List of Open Problems
17:50:29 <sorear> I love suffix arrays but *gnash* I can't figure out how to generalize them to arbitrary regular expressions.
17:50:31 <dons> there's a chance for someone to get famous. answer one of the 21 open questions on typed lambda calculus.
17:51:13 <monochrom> You don't want to learn Jedi from Yoda.  "Patience!" is all he says all day.
17:53:02 * ddarius suspects that the value of "famous" in that sentence is rather small.
17:53:18 <dons> http://programming.reddit.com/info/1jo7g/comments
17:53:19 <lambdabot> Title: The 21 Open Problems in Typed Lambda Calculus (reddit.com)
17:53:27 <dons> ddarius: well, if you're a phd student in programming languages.
17:53:33 <dons> it's a chance to get a POPL paper :-)
17:54:18 <ddarius> @google "Emil Post" "Post systems"
17:54:21 <lambdabot> http://citeseer.ist.psu.edu/34521.html
17:54:21 <lambdabot> Title: The Equivalence of Post Systems and Turing Machines (ResearchIndex)
17:59:20 <ddarius> @spell irresistable
17:59:21 <lambdabot> irresistible irresistibly arrestable resistible irritable
17:59:31 <ddarius> Good, I had it right.
18:00:06 <shachaf> ddarius: "irresistable" /= "irresistible"
18:00:25 <ddarius> shachaf: Yep, but that's not what I had in the email.
18:00:34 <shachaf> ddarius: Oh. Never mind.
18:03:35 <sorear> hmm, is uncurried functions just ML style?
18:03:55 * sorear is reading a paper on the Data.Map implementation, and wonders about the tupling of arguments
18:04:05 <dons> @seen glguy
18:04:05 <lambdabot> glguy is in #haskell. I last heard glguy speak 3d 5h 10m 28s ago.
18:04:20 <dons> I wonder where glguy is.
18:04:28 <sorear> Mee too.
18:04:46 <sorear> he said he was going to apply my patch "tonight" .. 4d ago
18:05:02 <dons> probably travelling or something like that.
18:05:04 * sorear gives glguy a hard time.
18:05:24 <ddarius> sorear: Yes.
18:05:49 <Saizan> he was switching job in this period i think
18:06:48 <sorear> ooh, NJ-SML
18:06:54 <sorear> is that the same as SML/NJ?
18:12:34 <monochrom> ML requires a data constructor takes only one parameter. you are forced to use a tuple.  in the long run this discourages currying in other parts of the program too.
18:13:29 <monochrom> actually may be I am wrong.  but everyone uses a tuple upon a data constructor.
18:15:08 <monochrom> Another point.  Like Haskell, in ML you can turn an infix operator into a prefix function.
18:15:51 <monochrom> "op +" is the function.  It's type: int*int -> int
18:16:38 <Saizan> so they simply like tuples?
18:16:43 <monochrom> So they prefer tuples and they build the preference into the language too.
18:21:52 <dons> ?users
18:21:52 <lambdabot> Maximum users seen in #haskell: 336, currently: 285 (84.8%), active: 31 (10.9%)
18:22:20 <dons> hey, does anyone know of a way to block the google text ads we now have on reddit?
18:24:44 <monochrom> is it intrusive? I don't find it intrusive.
18:25:09 <dons> i find it a little intrusive, yes.
18:25:15 <dons> particular the large font version
18:25:30 <dons> it also tends to flash on rendering in my firefox.
18:25:56 <monochrom> I only see a narrow sidepane on the right.
18:26:33 <Saizan> adblock if you use firefox
18:26:49 <monochrom> I have programmed myself to ignore all sidepanes. Perhaps that is why I'm ok with it.
18:26:53 <dons> Saizan: cheers
18:27:01 <dons> monochrom: yeah, I suspect its just habituation.
18:27:11 <dons> it seems distracting after 6 months of reddit with no ads whatsoever ;-)
18:27:21 <monochrom> I am old-school.
18:27:32 <dons> and since I'm generating half the content on their site, do I really need their ads mwhaha
18:27:39 <Saizan> with Filterset.G for updated filters
18:27:54 <monochrom> wait til you generate half of the revenue :)
18:28:10 <dons> hehe. what, you don't think #haskell spends much at reddit ? :-)
18:28:37 <dons> i think reddit should send you tshirts based on your karma
18:29:04 <dons> some way of repaying the people who generate the content, anyway.
18:29:16 <dons> since they're all quadrillionaires now
18:31:09 <dons> its funny that the ocaml/haskell janest advert is top of the list on reddit.
18:31:30 <dons> that might generate rather too many applications for them i suspect.
18:31:41 <psykotic> dons, the tshirt thing is a good idea.
18:31:49 <psykotic> dons, especially if it's somewhat exclusive.
18:32:00 <dons> psykotic: yeah. i mean, gee, google gives them away for SoC (all admins and students)
18:32:13 <dons> so maybe, you get 1 or 2k points (or 10k? ) you get a tshirt.
18:32:20 <sorear> does anyone think a transactional, file-backed BS -> BS map is of sufficiently general utility that I should develop it outside megamonad-bot?
18:32:32 <psykotic> i used to be on a game programming site (now defunct) called flipCode, and a lot of the early article writers got flipCode tshirts, which became somewhat of a collector's item (the owner stopped giving them out at some point)
18:32:43 <dons> sorear: hmm. yes. sounds a bit like Pseudonym's db thingy
18:32:47 <bd_> sorear: sounds like it could be useful... a bit like berkelydb for haskell?
18:32:48 <monochrom> haha "do you think in closures?"
18:33:02 <sorear> gsoc is already spending $5k per project.  what more is a t-shirt?
18:33:11 <sorear> i imagine reddit's costs are lower
18:33:29 <sorear> bd_: yeah, a lot like berkelydb.  does bdb do transactions?
18:33:48 <psykotic> sorear, yes, the nonfree versions do
18:33:49 <ddarius> flipCode died?
18:33:49 <dons> sorear: if its like berkelydb, you definitely should talk to Pseudonym about it
18:33:56 <dons> he's writing a paper on an STM db right now.
18:34:07 <bd_> sorear: It does, yeah, but through page-level locking
18:34:21 <sorear> ick :)  I want transparent stm interop!
18:34:27 <psykotic> sorear, steve dekorte built a hack on top of bdb that gives you transactions, he calls it twindb
18:34:40 <bd_> sorear: well, I just mean in terms of functionality :)
18:34:42 <psykotic> not performance optimal though
18:34:43 <sorear> @seen Pseudonym
18:34:44 <lambdabot> I saw Pseudonym leaving #haskell-blah and #haskell 18h 17m 52s ago, and .
18:35:02 <dons> he'll be back on monday, probably, or sunday afternoon, .au time.
18:35:06 <bd_> psykotic: Er, isn't it built-in? http://pybsddb.sourceforge.net/ref/txn/intro.html
18:35:08 <lambdabot> Title: Berkeley DB Reference Guide: Berkeley DB and transactions
18:35:08 <psykotic> ddarius, yes, long time ago now. and even before it died, it had stagnated. reminds me of a lot of programming.reddit.com actually.
18:35:31 <psykotic> bd_, last i checked it's the only the non-free sleepy eye versions of bdb that support transactions.
18:36:08 <bd_> hmm, I thought it was under the GTL...
18:36:12 <psykotic> bd_, the stuff they talk about on that page you link (environments, etc) is definitely only in the full version.
18:36:29 <psykotic> bd_, the _old_ versions are. the more recent ones are super expensive, several hundred grand.
18:36:43 <bd_> ah
18:36:48 <bd_> wait
18:36:49 <sorear> so, transactions are #1 for me, as is String-based storage.  I'm also going to implement lazy loading and incremental checkpointing, for overhead.
18:36:54 <bd_> psykotic: subversion uses transactions in bdb, though
18:36:59 <sorear> I really don't care about constant factors
18:36:59 <bd_> and it has for a while
18:37:00 <psykotic> hmm
18:37:07 <bd_> with environments, note
18:37:19 <monochrom> Haahaha, dailywtf has renamed to "worse than failure"?
18:37:23 <psykotic> it's possible my intel is way out of date then, let me check
18:37:48 <sorear> ooh, cool, tweak is in sid now!
18:38:03 <sorear> tweak == simon tatham's proof of concept O(log n) editor
18:38:21 <sorear> you may have heard me ranting about finger trees in yi :)
18:38:51 <psykotic> bd_, oh you're right. they use a super draconian license to prevent any commercial use of the OSI license, that's what i remembered.
18:38:51 <psykotic> bd_, it's the older bdb versions that's under a non-insane license.
18:38:51 <Saizan> is there some work on versioned serialization to let the user "easily" recover the old data when changing format?
18:39:25 <sorear> yes
18:39:33 <sorear> see the HApps/HList work
18:40:24 <sorear> @botsnack
18:40:24 <lambdabot> :)
18:40:35 <dons> i would say versioning is pretty well understood in fact.
18:41:50 <sorear> tfilemap a good name?
18:42:02 <psykotic> dons, it's one of those things you definitely have to address up front though. if you take the live image approach of some smalltalk and lisp systems then you can easily end up in a situation where migrating data between (what amounts to) versions requires major hacking.
18:42:10 * sorear checks hackage for bdb bindings
18:44:56 <ddarius> Grr
18:50:24 <stepcut> sorear: I have some
18:50:33 <stepcut> sorear: they mostly work :)
18:51:24 <syntaxfree> I'm reading "Thinking Forth".
18:51:36 <syntaxfree> Forth seems to be the symmetrical opposite of everything Haskell stands for.
18:52:14 <Philippa> heh
18:52:21 <Philippa> it's an interesting language, certainly. I should read more about it sometime
18:52:36 <Philippa> though arguably one symmetric opposite of Forth is Administrative Normal Form
18:52:53 <Philippa> (where all values that aren't being immediately returned from a function get named)
18:53:00 <syntaxfree> Leo Brodie basically constructs the need for a function around the problems of managing procedural code.
18:53:13 * ddarius suspects that it's not so much that Philippa should read more about Forth, but rather that she should play with it more.
18:53:13 <syntaxfree> Functions are one strategy in keeping code loosely-coupled.
18:53:27 <syntaxfree> I'm used to thinking of functions as the primitives of computation itself.
18:53:53 <Philippa> ddarius: that too, but in practice I find it easier to read enough that I get a fairly good grip on something than I do to start hacking anything of size
18:54:12 <stepcut> sweet!
18:54:20 <ddarius> I do too.  But, in practice, I often never actually get around to hacking in the language.
18:54:26 <Philippa> once in a while I surprise someone with how little code I've written for my level of knowledge...
18:54:34 <Philippa> I'm good at thought experiments, I guess
18:54:42 <syntaxfree> Philippa: that's my case, somewhat.
18:55:07 <syntaxfree> I write this lengthy software methodology rants, and yet I haven't much of a portfolio to show either.
18:55:07 <Philippa> mmm. In fact, wander into -blah a moment?
18:55:11 <syntaxfree> s/this/these/
18:55:14 <ddarius> syntaxfree: Have you programmed in assembly before (mildly significantly)?
18:55:38 <syntaxfree> I've done very simple stuff on a Z80-based computer.
18:55:51 <Philippa> does a few blitters and code templates for a really trivial compiler count for that?
18:55:52 <syntaxfree> a lot of fun things in that box couldn't be reached from Basic ;)
18:56:05 <syntaxfree> what is a "blitter"?
18:56:37 <Philippa> http://en.wikipedia.org/wiki/Blitter
18:56:54 <syntaxfree> (my software methodology rants, rotting already: http://syntaxfree.wordpress.com)
18:56:56 <lambdabot> Title: Data.Syntaxfree
18:57:00 <Philippa> (but it's also used to describe routines that do the same job)
18:57:15 <ddarius> syntaxfree: Do you think you could readily write an application in assembly?
18:57:31 <syntaxfree> I don't think I could readily write an application in anything but Haskell.
18:57:46 <syntaxfree> Maybe strugglingly in Scheme and Common Lisp.
18:58:35 <Philippa> I'd be at least intellectually capable of writing nearasdammit anything so long as I've got macro facilities, though odds are the first thing I write is a compiler :-)
18:58:49 <Philippa> syntaxfree's background is a bit unusual, IIRC
18:58:51 <dons> hehe. i think i could probably do it in ocaml, standard ml or erlang without too much trouble
18:59:09 <dons> though i'd be scared of not having a type system for the erlang stuff
18:59:14 <ddarius> dons: It?
18:59:24 <dons> "syntaxfree> I don't think I could readily write an application in anything but Haskell" :-)
18:59:31 <Philippa> same here. Although that's a slightly risky statement given that I haven't technically written a line in any of them :-)
18:59:43 <syntaxfree> I should be able to use MLs or Erlang too, I guess.
18:59:54 <Philippa> well, FCVO "readily" where "ready" isn't mutually exclusive with RTFMing
19:00:03 <syntaxfree> Though I'd stumble upon the same walls I stumble into with Lisp: no free laziness.
19:00:29 <syntaxfree> to be perfectly honest, there are limits on what applications I'd be able to write.
19:00:41 <syntaxfree> I don't think I could write a driver or a RDBMS where I'm at.
19:00:47 * sorear has written a few simple-ish programs in assembly
19:00:51 <ddarius> Programming in assembly is significantly different from programming in a high-level language.
19:00:59 <Saizan> a matrix calculator (addition product inverse determinant and solution of a linear system) running in spim count for a working application in assembly?
19:01:16 <syntaxfree> spim count?
19:01:24 <sorear> my background is even more unusual ... I've written three large pices of operating systems
19:01:25 <syntaxfree> (what about eigenvalues/vectors?)
19:01:26 <ddarius> @google mips spim
19:01:28 <lambdabot> http://www.cs.wisc.edu/~larus/spim.html
19:01:29 <lambdabot> Title: SPIM MIPS Simulator
19:01:30 <dons> http://programming.reddit.com/info/1jolg/details
19:01:32 <lambdabot> Title: Haskell for GUI programming (reddit.com)
19:02:16 <syntaxfree> man, I sometimes feel depressed just being around these people ;)
19:02:18 <saint> i wrote a novel in assembly.
19:02:21 <saint> it was a coming of age story
19:02:29 <saint> and... it compiled.
19:02:34 <saint> assembled.
19:02:51 <sorear> it's very easy to write type correct asm progs that go wrong
19:02:54 <Philippa> and then hung?
19:03:14 <saint> i don't like to talk about what happened next. it's a sensitive issue.
19:03:36 <Philippa> ddarius: in fairness it's only really much much different when you try to write code that performs at all well
19:03:41 <sorear> btw, use nasm -f elf -g dwarf2, then link as if it were C.
19:03:42 <araujo> dons, yay!
19:03:50 <sorear> gdb makes asm programming *much* easier :(
19:03:55 <Saizan> yeah, "oh i forgot to save that register for later, now i'm writing on random addresses of memory.."
19:04:15 <Philippa> otherwise you just have to shuffle a bit of extra info around in your code so you remember what's being kept where, and try hard not to screw up
19:04:18 <ddarius> Philippa: Not true.  But yes, a lot of the times nowadays it's about the same as writing in C.
19:04:36 <ddarius> But if you have fun with it or do low-level stuff it gets a lot more interesting.
19:04:47 <syntaxfree> "As any knowledgeable programmer will tell you, a number that might conceivably change in future versions of the program should be made into a constant and referred to throughout the program by name, not by value. For instance, the number of columns representing the width of your computer paper forms should be expressed as a constant. Even assembly languages provide  EQUs and labels for associating values such as addresses and bit-patterns with names. 
19:04:55 <syntaxfree> that is *very* weird coming from a Haskell background.
19:05:10 <Philippa> ddarius: perhaps my POV's limited somewhat by only having written code targetting the 286 and 386?
19:05:13 <sorear> A couple weeks ago I spent a whole day doing low level hacking on a super-super-fast haskell lib for writing into memory.
19:05:16 <dons> araujo++ :-)
19:05:18 <ddarius> syntaxfree: Why do you say so?
19:05:41 <sorear> I had #'s and unsafe array access everywhere, and only got ONE segfault in the whole day.
19:06:01 <dons> that's nice.
19:06:02 <sorear> Then, to see how bad my code still was, I wrote a naive C program.
19:06:10 <syntaxfree> I mean, if you're writing something that cares about printing width, your printing function should pass width as a parameter.
19:06:14 <sorear> really, really, naive.
19:06:22 <sorear> it segfaulted the very first time
19:06:22 <ddarius> Philippa: Writing DOS programs is fun... ish.  Implementing control structures, crazy ones that you don't see everyday is fun, but less so after CPS rips the magic out of life.
19:06:24 <syntaxfree> Maybe you could hardcode the width into your main function or something, but.
19:06:40 <Philippa> syntaxfree: *hah*. No, if you're writing something that cares in that sense then you also care too much about performance to not inline it
19:06:43 <monochrom> Hardcoding constants is a widespread habit.
19:06:51 <dons> oh, i love these 'i just found haskell: omg!' blog posts, http://www.noulakaz.net/weblog/2007/04/20/i-like-haskell-a-lot/
19:06:53 <lambdabot> Title: Avinash Meetoo: Blog  Blog Archive  I like Haskell a lot&#8230;
19:06:55 <sorear> Philippa: static argument transform!
19:07:01 <syntaxfree> but don't optimizing compilers inline functions when useful?
19:07:01 <ddarius> It's nice to get to a point where you can pretty much immediately see through code (in a HLL) into assembly.
19:07:13 <Philippa> sorear: this is asm, there's no notion of argument :-)
19:07:42 <Philippa> yeah, while I could per se I could certainly look at compiler output and often see what was going on immediately
19:07:45 <syntaxfree> why do programs segfault?
19:07:49 <Philippa> er, couldn't per se
19:07:56 <mauke> @hoogle [(a,b)] -> [a] -> [b]
19:07:58 <lambdabot> No matches, try a more general search
19:08:02 <Philippa> I didn't see asm even if I saw sequences of low level ops, if that makes sense
19:08:09 <monochrom> programs segfault because the OS is trying to be a draconian police
19:08:21 <syntaxfree> what is "segmentation"?
19:08:34 <Philippa> hahahahaha
19:08:35 <Philippa> oh dear
19:08:37 <ddarius> dons: One by one, they fall.
19:08:45 <syntaxfree> "Contemporary programming languages such as C, Modula 2, and Edison apply this concept to the architecture of their procedures. "
19:08:49 <monochrom> old term for a piece of memory the OS grants you. you step outside, fault.
19:08:51 <Philippa> syntaxfree: older machines had memory split up into 'segments'
19:08:55 <syntaxfree> heh. Edison??
19:09:13 <Philippa> and you would put the segment you're addressing in one register and the offset into that segment in another to address something
19:09:17 <syntaxfree> oh. segfaults are about manual memory management.
19:09:31 <Philippa> segfaults are about trying to read memory you shouldn't
19:09:31 <monochrom> No. OS automatic memory management.
19:09:34 <syntaxfree> and the OS trying to keep one program from overwriting another's turf.
19:09:38 <dons> ddarius: hehe
19:09:49 <dons> ddarius: some of them don't though (ekidd, there's others too)
19:09:51 <syntaxfree> monochrom: OS automatic memory *protection*, you mean.
19:09:55 <dons> sigfpe comes to mind as well
19:09:57 <edwinb> it sounds like all the cool kids are moving to Haskell now...
19:10:06 <Saizan> segfaults are like "permission denied" in a unix filesystem
19:10:07 <syntaxfree> sigfpe is brilliant.
19:10:12 <dons> edwinb: that's been the case for a couple of years, I think.
19:10:13 * edwinb worries
19:10:20 <edwinb> I don't like the idea of being a cool kid... ;)
19:10:30 <dons> sure, you're plenty cool. you have a blog! :-)
19:10:40 <edwinb> yeah, that I haven't posted to for months...
19:10:44 <dons> that's cool.
19:10:47 <edwinb> but, hey, I have one anyway!
19:10:52 <syntaxfree> my programming blog is abandoned, too.
19:10:58 <ddarius> dons: Fairly recently, it's almost reached a point where it's self-sustaining.  Before something had to happen (pugs, darcs) for people to be like "Oh, look! Haskell!"
19:10:59 <dons> gotta leave the fans guessing, edwinb  :-)
19:11:06 <syntaxfree> I'm preparing in my head a post about my experiences with common lisp.
19:11:06 <edwinb> it's not abandoned, I'm just too busy doing stuff to post to it ;)
19:11:07 <dons> ddarius: yeah. that's right.
19:11:10 <syntaxfree> It's a mess.
19:11:14 <edwinb> (I claim...)
19:11:20 <dons> i think we have reached a self-sustaining situation (just)
19:11:27 <ddarius> As does Andris Birkmanis.
19:11:38 <dolio> @type unzip
19:11:41 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
19:11:42 <dons> its now *the* FP language to look at first, closely tied with erlang.
19:11:55 <monochrom> It is also automatic allocation and deallocation because you are given segments at program launch.  During execution the program can't change the segments or add, remove.
19:12:15 <foxy-om> dons: 346/6 vs. 133 :(
19:12:27 <dons> foxy-om: hmm?
19:12:28 <syntaxfree> dons: do you think this "the language for really smart people" aura helps or gets in the way?
19:12:37 <Philippa> dons: to put it another way, we've stopped avoiding success
19:12:46 <dons> syntaxfree: it attracts good programmers, at least.
19:12:52 <Saizan> with memory segmentation, do you also have a segment for the stack?
19:12:57 <dons> and the bad programmers either are too scared, or don't read blog articles about languages anyway
19:13:03 <syntaxfree> dons: nah. it even attracted me.
19:13:13 <monochrom> Yes for some platforms, no for others.
19:13:16 <dons> Philippa: yeah. i agree.
19:13:23 <syntaxfree> do you know the story of how I came about Haskell?
19:13:34 <foxy-om> dons: cricket!
19:13:45 <dons> shapr said something once about how we developed our weapons in secret for 20 years, then launched a surprise attack
19:13:47 <saint> tell us, i'll write it in assembler! and publish it!... i wonder if it will... assemble...
19:13:49 <dons> foxy-om: oh!!!
19:13:55 <dons> foxy-om: i just got off a plane from the US
19:14:01 <dons> so been in world cup blackout for the lsat week
19:14:06 <foxy-om> ah
19:14:10 <dons> there is *zero* cricket reporting over there.
19:14:15 <Saizan> something that i don't quite get with segmentation is that the stack should be able to grow, but segments seems to have a fixed size
19:14:22 <syntaxfree> those eccentric haskellers.
19:14:28 <syntaxfree> if it's not unicycling, it's crickets.
19:14:37 <syntaxfree> I've gotta say, I'm pining for a penny-farthing.
19:15:03 <monochrom> All memory schemes give you a fixed size.
19:15:11 <ddarius> Thank god (re zero cricket reporting)
19:15:14 <dons> syntaxfree: you know the brazillian haskell textbook as a unicycle on the cover... :-)
19:15:17 <dons> (have you seen it?)
19:15:20 <norpan> gsp
19:15:22 <syntaxfree> only online.
19:15:24 <edwinb> I just spent a fortnight in the US trying to get my cricket news from the BBC...
19:15:47 <syntaxfree> anyway, I became attracted to Haskell because I stumbled upon "Theorems for free!"
19:15:58 <syntaxfree> I first looked at it and thought the notation looked cool.
19:16:08 <monochrom> freaky
19:16:30 <monochrom> BTW I don't do unicycling or crickets.
19:16:40 <syntaxfree> I had been taking a Scheme 101 course.
19:17:08 <dons> foxy-om: last result i saw was .au v sri lanka
19:17:24 <sorear> Saizan: there's mega super duper hacky code in linux which detects segfaults at adresses within 4K of the bottom of the stack, and automatically increases the stack size.  of course it uses paging, but I imagine the principle is the same in segmented environments.
19:17:26 <dons> foxy-om: what match have you been watching?
19:17:32 <foxy-om> ah, well www.cricinfo.com has live broadcasting
19:17:37 <foxy-om> dons, .au v .nz
19:17:42 <foxy-om> we got walloped
19:17:45 <dons> ah ha!
19:17:51 <dons> mwhahaha
19:17:56 <foxy-om> aob
19:17:58 <foxy-om> sob
19:18:05 <syntaxfree> heh. "if hurried then cereal else eggs" in forth is "hurried? if cereal else eggs then clean"
19:18:06 <dons> damn, i missed it.
19:18:10 <syntaxfree> "then" is a continuation of sorts.
19:18:25 <sorear> syntaxfree: where'd clean come from?
19:18:35 <dons> foxy-om: makes me really wonder what was going on here during january, when england took out the summer one day series
19:18:41 <monochrom> You can mix paging and segmentation.  Use pages to support segments.
19:18:43 <dons> maybe just burn out after the ashes
19:18:44 <syntaxfree> it's something that's done after everything.
19:18:58 <syntaxfree> in Haskell it'd be "clean $ if hurried then cereal else eggs"
19:19:02 <sorear> syntaxfree: also, portable forth uses ALL UPPERCASE
19:19:14 <ddarius> My impression is that segments (for the IA32 architecture) aren't really used.
19:19:15 <sorear> syntaxfree: some forths support lowercase as an extension
19:19:29 <foxy-om> dons: my brother (in the UK) has a match-fixing theory
19:19:35 <dons> heh
19:19:45 <dons> so does my Dad, actually
19:19:52 <sorear> ddarius: right, afair they are mostly for MULTICS compatibility, and we all know how that turned out
19:19:54 <saint> does anyone know (or have done) any workable direct manipulation gui's in haskell?
19:20:21 <sorear> ddarius: amd64 more or less doesn't support segments in 64 bit mode
19:20:41 <sorear> so they are being abandoned even by the chip makers
19:21:13 <dons> hey kosmikus
19:21:59 <monochrom> 286 did segmentation.  386 provides both.  Then people wanted "linear addressing", so segmentation went out of favour.  To support swapping to disk, you still need (transparent) paging.
19:22:04 <dons> foxy-om: yeah, the US is weird. I can't imagine I'd see much rugby/cricket or (gasp) AFL there.
19:22:23 <sorear> monochrom: you can swap with segments!
19:22:29 <dons> foxy-om: btw, is there any AFL played at all in NZ?
19:22:35 <monochrom> segments went out of favour.
19:22:41 <foxy-om> dons: yeah, some, not much (club level)
19:22:45 <edwinb> I got bored enough in the US that I tried to work out the rules of baseball...
19:22:56 <dons> the only international stuff I ever see in that is this funny combined Ireland/.au game played once a year (combined gaelic football/AFL)
19:22:56 <sorear> monochrom: olde unix swapped with segments, and that's why we have "swapped out" as a process status code - it was all or nothing
19:23:17 <Saizan> two-level-paged segments! increase your indirection!
19:23:48 <monochrom> with the introduction of paging, you have more choice
19:24:03 <monochrom> it was a great indirection game.
19:24:38 <monochrom> recall that paging already introduces an indirection.
19:27:48 <sorear> saint: what is direct manipulation?
19:28:16 <monochrom> Niklaus Wirth's "Good Ideas through the looking glass" poked fun at all those indirections.
19:28:20 <dons> ah yes saint , i was going to ask the same thing. we'll need a little clarification
19:29:08 <dons> http://programming.reddit.com/info/1joqj/comments
19:29:09 <lambdabot> Title: More playing with sections (and flip) in Haskell (reddit.com)
19:29:11 <monochrom> Jedi is a direct manipulation.
19:29:13 <dons> quite a few blog articles today
19:29:27 <ddarius> You could have some fun given direct access to the page tables.
19:30:13 * sorear had a decent stint with kernel dev as a hobby, and knows all too well the fun you can have with the x86 MMU
19:30:47 * foxy-om thinks Coq rocks!
19:31:09 <saint> sorear: direct manipulation is where you actually manipulate the thing you're trying to work with. like... drawing a line between two pictures of computers to represent them communicating
19:31:10 <syntaxfree> Forth is ugly.
19:31:29 <monochrom> x86 provides four levels of privilege: rings 0 to 3.  We end up using just two: 0 and 3.  This is not just one OS.  I always wonder why.  Do you know?
19:31:32 <SamB> saint: that sounds rather odd
19:31:45 <monochrom> For example I would really think drivers should go to ring 1 not 0.
19:31:46 <SamB> I think it would make more sense to toggle bits in memory with a microscope!
19:32:00 <allbery_b> because those extra rings (a) cost overhead (b) don't actually gain you much
19:32:10 <saint> that's true!
19:32:13 <saint> i prefer doing that normally
19:32:41 <allbery_b> some versions of OS/2 used ring 1 for video drivers.  it provided little extra protection against buggy video drivers, at a significant slowdown
19:32:42 <SamB> saint: you have an appropriate instrument?
19:33:05 <saint> SamB: i use a tuba
19:33:09 <SamB> video drivers are better off in ... whatever ring I'm in ;-P
19:33:11 <monochrom> In practice most Windows crashes and all Linux X hangs (X can hard-hang the whole kernel) are due to drivers in ring 0.  Shouldn't we eat the overhead and get some safety back?
19:33:27 <allbery_b> the problem is, you don't
19:33:41 <allbery_b> de facto, ring 1 might as well be ring 3
19:33:46 <SamB> saint: that doesn't sound like a kind of electron microscope!
19:33:57 <monochrom> OK I see.
19:34:05 <syntaxfree> monochrom: what's the difference between crashing and hanging?
19:34:12 <saint> SamB: it's a scanning tuba.
19:34:19 <monochrom> I guess no difference.
19:34:26 <SamB> it would be nice if things would crash rather than hang ;-)
19:34:30 <ddarius> Out
19:34:37 * sorear never has problems with linux X hangs.
19:34:41 <dolio> On a crash, the computer reboots for you. :)
19:34:50 <SamB> sorear: yeah. we know.
19:35:00 <SamB> you only use it on sundays to go to church and all that...
19:35:51 <monochrom> If you use mature drivers you don't hang.
19:36:34 <allbery_b> (IIRC ring 1 lets you provide a list of directly accessible I/O ports.  but that lets you do things that will lock the system bus (== hard hangs)
19:37:02 <sorear> allbery_b: you can provide a list of directly accessible IO ports at all rings.
19:37:24 <monochrom> Yeah, I guess the real problem is deadlock.  You need a temporal logic for that.
19:37:25 * allbery_b is misrecalling the details, clearly
19:37:47 <allbery_b> it's only been 10 or so years since I last thought about this crap
19:38:19 <SamB> anyway, if you wanted more than the two rings, probably 4 would be *far* too few...
19:38:25 <monochrom> Ha! A temporal logic monitor is not out of reach...
19:39:34 <syntaxfree> (setq apples 20) in forth is 20 APPLES !
19:41:13 <allbery_b> APPLES @ ORANGES @ == IF ." YAY" THEN
19:41:46 <allbery_b> hm, don't recall if equality was == or =
19:42:00 <allbery_b> forth's another one from the dim past :)
19:42:00 <monochrom> Let's say =
19:42:24 <allbery_b> even dimmer than OS/2; I think I did FORTH last when poking at CommuniTree in 1980
19:42:36 <allbery_b> er, Conference Tree
19:43:00 <syntaxfree> Thinking Forth introduces pointers first. how weird.
19:43:11 <syntaxfree> was Forth every widely used?
19:43:11 <monochrom> Only the morons inventing C and Haskell have the gut to use = for something other than equality.
19:43:31 <allbery_b> it used to be heavily used in astronomy
19:43:34 <SamB> eh?
19:43:37 <allbery_b> very fast and compact code
19:43:40 <syntaxfree> astronomy?
19:43:45 <SamB> only C and Haskell?
19:43:46 <allbery_b> telescope control
19:44:10 <syntaxfree> Stata, for one, uses == for comparison and = for assignment.
19:44:22 <syntaxfree> R uses <- for assignment and = for equality. much better, i think.
19:44:31 <allbery_b> I think = was equals, since it wasn't needed for assignment (! was used for that)
19:44:35 <monochrom> Heh, java and perl and python etc just follow the status quo, not entirely guilty
19:45:00 <SamB> istr a simple majority of the programming languages I've seen using "="
19:45:30 <monochrom> Yes
19:45:50 <SamB> of course, I suppose the same idiots invented sh as invented C...
19:46:06 <allbery_b> before the advent of C, most languages considered assignment a statement, not an expression, so there was no conflict between = for assignment and = for equality
19:46:19 <syntaxfree> Haskell could've used "is"
19:46:24 <SamB> !
19:46:31 <SamB> but that would be a keyword!
19:46:31 <syntaxfree> inc is (+1)
19:46:34 <SamB> and keywards are nasty
19:46:36 <syntaxfree> inc x is x+1
19:46:39 <ski> (but '=' is equality in haskell ..)
19:46:50 <SamB> ski: no, it is binding!
19:46:57 <phoniq> 'is'.  that's hot.
19:46:57 <ski> which is equality
19:47:05 <syntaxfree> ski ;)
19:47:06 <SamB> no it isn't!
19:47:07 <allbery_b> sh was invented by Steven R. Bourne; C, by Dennis Ritchie
19:47:15 <monochrom> Suppose you invent Java.  You have a choice: use ":=" and alienate everyone because they use "="; or use "=" and perpetuate a mistake.  Your goal for java is popularity not correctness.
19:47:21 <allbery_b> and sh is worse; it's based on Algol 60 syntax :)
19:47:35 <ski> 'foo = 5' means that we assume that 'foo' is equal to '5'
19:47:45 <SamB> allbery_b: are you sure he invented sh?
19:47:52 <allbery_b> the v7 sh, yes
19:47:54 <monochrom> IOW if C used := Java would use := too, similarly sh, Perl, Python, etc.
19:47:54 <ski> 'foo x = x*x + 1' means that we assume that for all 'x', 'foo x' is equal to 'x*x + 1'
19:48:03 <monochrom> So the root cause is clear.
19:48:03 <allbery_b> there were earlier ones by other people but they've mostly been forgotten
19:48:11 <syntaxfree> question.
19:48:17 <allbery_b> except that csh and derivatives are extensions of the v6 Unix Mashey shell
19:48:34 <SamB> because I'm pretty sure ken had a shell
19:48:35 <Philippa> what did BCPL and B use?
19:48:53 <syntaxfree> you can't have a storage-based Eq instance for functions unless you have some reflexivity, which in turn requires a dynamic language. True or false?
19:49:03 <SamB> even way back in the days before the directories formed a tree!
19:49:14 <SamB> when they were a directed graph
19:49:23 <allbery_b> yes, but they did a new shell for each release, more or less
19:49:26 <monochrom> reflexivity? reflection?
19:49:48 <SamB> before fork(2), even!
19:50:06 <allbery_b> thus Bourne's v7 shell was not very similar to Mashey's v6 shell
19:50:23 <monochrom> storage-based Eq = look at addresses?
19:50:26 <syntaxfree> SamB: how do directories form a directed graph?
19:50:26 <ski> (the only irritating thing is that we don't use '=' for "comparision" equality, as well .. but Prolog and Mercury does that)
19:50:30 <syntaxfree> monochrom: yep.
19:50:57 * allbery_b is trying to remember how BCPL worked
19:50:58 <SamB> syntaxfree: well, you neglect to have a hierarchical structure
19:51:03 <syntaxfree> oh.
19:51:04 <monochrom> OK.  No need for dynamic.  Just need some exposure of the current addresses.
19:51:07 <syntaxfree> that's ... cool.
19:51:18 <SamB> and just have the directory links in each directory point wherever you like
19:51:18 <syntaxfree> monochrom: can Haskell ever have that?
19:51:33 <sorear> monochrom: doesn't java "fix" the problem by not allowing = as a operator, only at top level?
19:51:47 <sorear> syntaxfree: sure, lok at GHC.Prim.reallyUnsafePtrEq#
19:51:49 <syntaxfree> SamB: wow. But doesn't ln -s achieve that?
19:51:55 <sorear> that will work at function types
19:51:56 <allbery_b> I think = was used for assignment and == for equality --- but = wasn't used in top level declarations
19:52:05 <SamB> syntaxfree: that is only symlinks
19:52:07 <sorear> syntaxfree: symbolic links are just references,
19:52:15 <sorear> we're talking hard links
19:52:51 <SamB> I think you had to make your own .. in those days
19:52:52 <monochrom> Note: during evaluation of "f==f", first load address of f, then --- GC kicks in! moves f around! --- load address of f second time, hmm the two are different, unequal!
19:53:34 <monochrom> Java sidesteps this by probably another level of indirection.
19:53:45 <sorear> SamB: were files GC'd, or did the admin have to periodically reap them by hand?
19:53:53 <allbery_b> yeh, in early Unix there was no requirement that directories link together in a sane way.  this made filesystem validation rather difficult, though, so it was restricted to a DAG
19:54:00 <SamB> sorear: I have no idea
19:54:15 <SamB> I'm not that much older than you, you know ;-P
19:54:18 <sorear> monochrom: no, the problem doesn't exist in Haskell or Java
19:54:35 <monochrom> Really!
19:54:43 <sorear> monochrom: since the gc fixes addresses when it moves stuff
19:54:49 <allbery_b> in v7 unix and earlier, there was no mkdir system call.
19:54:58 <sorear> monochrom: consider, if it didn't, 'fst (2,2)'
19:55:11 <sorear> monochrom: tuple it, move w/o fixing, fst, segfault
19:55:24 <allbery_b> /bin/mkdir used mknod() to create a "raw" directory, then link() to create the "." and ".." entries
19:55:29 <sorear> monochrom: also, Java still has a non-moving collector afaik
19:55:32 <SamB> I was going to say...
19:55:43 <allbery_b> it was setuid root to have permissions to call mknod()
19:55:48 <SamB> how can you have .. and still have the fs being an acyclic graph?
19:56:27 <monochrom> I see. Thanks.
19:56:56 <allbery_b> IIRC it was around v5 that ".." came about that the filesystem was converted from a tree to a DAG
19:57:04 <allbery_b> *about and that
19:57:06 <monochrom> (It helps that I'm now skimming through the G machine etc, so I have some confidence imagining a model of this.)
19:57:40 <SamB> it is not quite a DAG, though, with "." and ".."
19:57:45 <sorear> The real problem with reallyUnsafePtrEq# is that it almost always returns False.  (ok, 0#, False doesn't exist this far down)
19:58:13 <sorear> because almost every operation returns a newly constructed thunk, and these have different addresses.
19:58:35 <allbery_b> strictly speaking, no.  but effectively it is, or at least it can be treated as one
19:59:06 <SamB> well if you strip out the "." and ".." links, yes ;-)
19:59:07 <sorear> Array and IORef == uses address equality, but doesn't have this problem because the compared addresses are those of Array# and MutVar# primitives, which are unlifted (never made into thunks)
19:59:10 <monochrom> PtrEq is very useful.  In DFSing a graph, PtrEq or even PtrOrd is a very efficient way to ask "have I visited this node yet?"
19:59:37 <allbery_b> "." is a convenience; ".." allows backward traversal of the tree
20:00:08 <monochrom> Err, I guess if part of the graph is still a thunk, there is a problem.
20:00:11 <SamB> perhaps unsafePtrEq# ought to seq its args...
20:01:13 <monochrom> Yeah but I wonder if it opens a can of worms.
20:01:56 <Saizan> just tag your nodes!
20:02:19 <sorear> storage == on functions is not allowed for semantic reasons, since it makes inlining visible:
20:02:43 <sorear> let id = (\x -> x) in id == id -- True
20:02:56 <sorear> (\x -> x) == (\x -> x) -- False
20:03:32 <monochrom> Yeah, if I built the graph myself, I'd certainly add a field for that. But if the graph is given untagged, I'm stuck.
20:06:18 <Saizan> tthis reminds me of: is there a simple way to map subsets of [1..n] to [1..2^n] ? by simple i mean an arithmetic expression that takes the elements(ordered) of the subset as variables
20:06:43 <sorear> map (2^)
20:07:56 <Saizan> that doesn't even typecheks
20:08:18 <sorear> > map (2^) [3,5,7]
20:08:20 <lambdabot>  [8,32,128]
20:08:30 <sorear> I misunderstand?
20:08:43 <Saizan> i think so, i need [Int] -> Int
20:08:52 <sorear> oh!
20:08:56 <hyrax42> sum . map (2^) no?
20:08:57 <sorear> bit packing
20:09:47 <monochrom> sum . map (2^) works, is arithmetic
20:10:00 <monochrom> bit ops also works, if you allow that
20:10:41 <Saizan> > (sum . map (2^) $ [8,9] ) <= 10^2
20:10:43 <lambdabot>  False
20:11:14 <Saizan> by bit packing you mean .!. ?
20:11:15 <hyrax42> ?hoogle Bits a => a -> Int -> a
20:11:16 <lambdabot> Data.Bits.clearBit :: Bits a => a -> Int -> a
20:11:17 <lambdabot> Data.Bits.complementBit :: Bits a => a -> Int -> a
20:11:17 <lambdabot> Data.Bits.rotate :: Bits a => a -> Int -> a
20:11:22 <sorear> If you have a *huge* amount of data, take advantage of the (GHC) fact that UArray and Integer use the same storage management layer
20:11:39 <rubyruy> hello there
20:11:48 <hyrax42> ?type Data.Bits.setBit
20:11:51 <lambdabot> forall a. (Bits a) => a -> Int -> a
20:12:09 <rubyruy> i'm just trying to work myself through a tutorial (yaht.pdf) and i'm having trouble understanding how to instantiate a type
20:12:13 <monochrom> Ha, setBit may be the easiest
20:12:25 <rubyruy> like for instance: data Pair a b = Pair a b --- ok, so how do i use it?
20:12:55 <monochrom> Pair "hello" True :: Pair String Bool
20:12:56 <hyrax42> so foldr Data.Bits.setBit 0
20:13:00 <syntaxfree> what's the shortest path to learning theoretical typed lambda calculus?
20:13:00 <hyrax42> ought to do it
20:13:00 <hyrax42> :t foldr Data.Bits.setBit 0
20:13:02 <lambdabot> [Int] -> Int
20:13:33 <sorear> hyrax42: actually that won't work, the arguments are in the wrong order
20:13:40 <sorear> hyrax42: semantically you want foldl
20:13:49 <sorear> hyrax42: foldl' in practice, of course
20:14:04 <sorear> > foldl' setBit 0 [2,3,5,7,11]
20:14:04 <lambdabot>  Add a type signature
20:14:12 <Saizan> > foldl' Data.Bits.setBit 0 [1..10] :: Int
20:14:13 <lambdabot>  2046
20:14:25 <sorear> > showIntAtBase 2 intToDigit (foldl' setBit 0 [2,3,5,7,11] ::Int) ""
20:14:26 <hyrax42> :t foldl' Data.Bits.setBit 0
20:14:28 <lambdabot>  "100010101100"
20:14:29 <lambdabot> forall a. (Bits a) => [Int] -> a
20:15:20 <rubyruy> ohhhh wait a sec
20:15:20 <hyrax42> sorear: yeah the lack of Bits a => ... a confused me
20:15:30 <rubyruy> i was trying to do x = Pair 1 2
20:15:59 <rubyruy> does haskell even have variable assignment in that sense?
20:15:59 <sorear> rubyruy: that will work
20:16:11 <mauke> wait, assignment? no
20:16:13 <rubyruy> not in ghci it isn't :(
20:16:20 <sorear> at the top level you can define vars
20:16:21 <sorear> oh
20:16:24 <mauke> in ghc you can use let x = Pair 1 2
20:16:25 <sorear> let x = Pair 1 2
20:16:33 <mauke> er, ghci
20:16:48 <rubyruy> ahhhhh
20:16:49 <hyrax42> sorear: typing faster than me again
20:17:26 <hyrax42> I'll just go back to the stuff I'm supposed to be doing
20:17:28 <rubyruy> is there a to-the-point syntax reference for haskell that is not written in terms of BNF and/or calculus by any chance?
20:17:46 <sorear> there is BNF
20:17:53 <rubyruy> *not* bnf :p
20:18:08 <sorear> if you can't stand BNF the best you'll get is a 'happy' parser
20:18:13 <sorear> happy is a yacc clone
20:18:27 <rubyruy> no no i just mean a tutorial overview of the syntax
20:18:35 <sorear> oh, there are pretty diagrams
20:18:56 <dons> rubyruy: there's a couple of guides to the syntax on the haskell wiki
20:19:18 <rubyruy> all the tutorials go by teaching language concepts first - which is fine - but i often wonder, "ok so what exactly is 'let' or '->'  " etc
20:19:20 <rubyruy> ahh
20:20:16 <SyntaxNinja> @seen shapr
20:20:17 <lambdabot> shapr is in #haskell-blah and #haskell. I last heard shapr speak 6h 30m 56s ago.
20:21:57 <rubyruy> oh my lots of good stuff here!
20:21:59 <rubyruy> (wiki)
20:22:41 <sorear> rubyruy: I would suggest learning BNF.  it's extremely easy compared to any real programming language, it is widely used, and it's pretty much the best syntax language around.
20:23:04 <sorear> I can explain it in a couple lines:
20:23:15 <monochrom> I don't actually understand the (to me) conflicting requirements "what is let" and "no BNF, no calculus".
20:23:20 <rubyruy> i can find my way through bnf but it's not the kind of reference i was looking for
20:23:46 <sorear> a bnf description defines a set of _productions_.  a production is a set of strings.  one production eventually is the language.
20:23:55 <shachaf> sorear: All rubyruy wants is to understand Haskell syntax.
20:24:00 <shachaf> sorear: Not write a parser.
20:24:01 <sorear> a production is 'name = rhs'
20:24:06 <rubyruy> rightoh
20:24:20 <monochrom> For example, I could answer, "let is a keyword, not a variable name", but I got that information from the BNF.  As for what it does, that's in the calculus.
20:24:58 <sorear> shachaf: he needs to write a parser.  even if not an explicit one.  if he can't mentally parse haskell, he will have no hope of dealing with haskell's abstract concepts.
20:25:34 <rubyruy> I fully intend to look through both the BNF and the calculus with a fine tooth comb but i'm just trying to get a grip on the language first
20:25:35 <monochrom> And finally, if I actually couldn't care about BNF and calculus, just some informal, you-know-what-I-mean description, that's exactly the conceptual tutorials.  I learned from those too.
20:26:03 <rubyruy> it's a little too much to swallow my first functional programming language from formal definitions alone
20:26:08 <shachaf> sorear: I'm not objecting to reading the BNF.
20:26:10 <monochrom> So, "no BNF, no calculus, and conceptual tutorials not answering my question", that pretty much leaves the empty set?
20:26:24 <shachaf> sorear: But a basic intuition about a language's syntax can make it much easier.
20:26:51 <rubyruy> monochrom: i can link you to the equivalent reference for ruby if you'd like
20:26:56 <rubyruy> just to see what i'm asking for
20:26:59 <thorat> rubyruy: I suppose you like Ruby, maybe you'll like http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
20:27:01 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/l986o
20:27:06 <sorear> rubyruy: for future reference, what languages are you familiar with?  many types of questions are easier to answer if we can give analogies.  (More is better, since e.g sorear doesn't know e.g ruby.)
20:27:29 <shachaf> @google syntax across languages
20:27:31 <lambdabot> http://merd.sourceforge.net/pixel/language-study/syntax-across-languages.html
20:27:32 <lambdabot> Title: syntax across languages
20:27:56 <sorear> all the ruby I've seen looks like a cross between befunge and apl :)
20:28:11 <mauke> hey, what about Perl?
20:28:26 <sorear> mauke: perl has a LOT more alphanumerics.
20:28:35 <rubyruy> ruby is pretty :(
20:29:14 <sorear> "pretty" /= "immediately comprehensible to the untrained eye"
20:29:20 <sorear> emphasis on untrained.
20:29:32 <thorat> rubyruy: the link I suggested is actually a Haskell tutorial
20:29:33 <rubyruy> well that depends
20:29:43 <rubyruy> we like our DSL
20:29:52 <rubyruy> thorat: that looks better then the one i'm using actually yes
20:30:01 <sorear> if I knew ruby, it would probably look more like ruby and less like befunge
20:31:08 <rubyruy> actually.. since i brought it up - how suited is haskell for meta programming stuff
20:31:13 * sorear was going for the CS equivalent of "It's all greek to me", ie expressing the extent of his noncomprehension.  Any percieved insult against Ruby is purely imaginary.
20:31:43 <mauke> very well, if you want to implement RSA in the type system
20:31:54 <rubyruy> like can haskell be extended in haskell during runtime? that dun stuff
20:31:59 <sorear> rubyruy: moderately.  most of the stuff you need metaprogramming for in other languages can be expressed directly in haskell, and we DO have lisp style macros.
20:32:04 <thorat> rubyruy: and the reason I suggested it is that Scheme is a "dynamic" language with closures and continuations -- like Ruby.
20:32:05 <sorear> yes, it can
20:32:09 <sorear> @where hs-plugins
20:32:10 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
20:32:22 <rubyruy> macros you say?
20:32:33 <sorear> yes, macros.
20:32:35 <sorear> @where th
20:32:36 <lambdabot> I know nothing about th.
20:32:40 <sorear> @where template-haskell
20:32:41 <lambdabot> I know nothing about template-haskell.
20:32:53 <sorear> @where+ th http://www.haskell.org/th
20:32:54 <lambdabot> Done.
20:32:58 <jcreigh> I've never really understood what is meant by "meta programming". It seems to me that all programming must be meta, it's only a matter of degree.
20:33:24 <rubyruy> yeah ruby and scheme do have a lot more to do with eachother then it seems - i was just working with a ruby extention that exposes the internal parse tree as lisp-style s-expressions. magical
20:33:31 <jcreigh> sorear: I'm not too familar with Template Haskell, but is it really "lisp style"?
20:33:34 <monochrom> It's a meta of degree
20:33:42 <sorear> jcreigh: meta programming is programs that write programs.
20:33:54 <rubyruy> oh that is pretty neat
20:34:01 <rubyruy> (the template stuff)
20:34:04 <sorear> jcreigh: sure, although lisp macros are massively ugly when bolted on to haskell
20:34:15 <rubyruy> Ruby has spoiled me for extranious syntax
20:34:16 <sorear> jcreigh: we have quasiquote and unquote
20:34:31 <sorear> @docs Language.Haskell.TH.Syntax
20:34:32 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/template-haskell/Language-Haskell-TH-Syntax.html
20:34:42 <sorear> ^^^ look at the size of the declarations and weep
20:35:02 <sorear> not like lisp, "all the world is an atom or cons"
20:35:26 <monochrom> Some macros are written to fake lazy evaluation.  Well Haskell has real lazy evaluation.  Others are legit uses of macros and templates etc., Haskell is catching up and IMO is adequate.
20:35:37 <sorear> even if you can't understand the syntax just yet, appreciate the textual size of the types (Exp et al)
20:35:54 <sorear> monochrom: others are used to fake HOFs.  We have real HOFs.
20:35:58 <rubyruy> so.. with this template thing... you could do some evil stuff like fake loops eh?
20:36:02 <Adamant> let me pimp Liskell right now
20:36:21 <Adamant> http://clemens.endorphin.org/liskell
20:36:22 <lambdabot> Title: Liskell - clemens.endorphin.org
20:36:28 <jcreigh> rubyruy: "fake" loops?
20:36:40 <sorear> rubyruy: yes, but *obligatory warning about premature optimization*
20:36:54 <rubyruy> sorear: hence the "evil"
20:36:56 <monochrom> Template Haskell has a back door for you to tell the compiler to launch your favourite mp3 player during compilation.
20:36:59 <Saizan> th is nice only with the abstraction included in derive
20:37:25 <rubyruy> as in write something that acts like do ... loop that simply translates to tail recursion
20:37:30 <monochrom> derive sounds nice
20:37:38 <syntaxfree> "In a philosophical sense I think this means that the computer understands a word. It understands the word DUP, perhaps more profoundly than you do, because theres never any question in its mind what DUP means. "
20:37:38 <jcreigh> ah
20:37:41 <rubyruy> (again - i dont think this is a good idea - just wondering if that's the kind of thing you could do with th)
20:37:47 <syntaxfree> computers have a mind?
20:38:14 <monochrom> computers have intelligence too!
20:38:54 <fantasma> any dwm users around?
20:38:55 <tuxplorer> >let foofunc x = x*x
20:39:02 <tuxplorer> >:t foofunc
20:39:13 <tuxplorer> foofunc :: (Num a) => a -> a
20:39:28 <tuxplorer> What does that => signify?
20:39:43 <sorear> it divides context (left) from type (right)
20:39:45 <tuxplorer> When I do > :t map, I get map :: (a -> b) -> [a] -> [b]
20:39:50 <tuxplorer> without the =>
20:40:05 <sorear> tuxplorer: the => is omitted if the context is empty
20:40:07 <monochrom> Regarding metaprogramming that turns loops into tail recursion.  Actually, Haskell has no primitive loop construct.  There are library functions representing loops, the function body uses tail recursion.
20:40:19 <Saizan> => is used only when the type variables have a typeclass constraint
20:40:24 <sorear> rubyruy: the biggest difference between TH and Lisp macros, is that in TH macro calls must be explicitly marked.
20:40:32 <sorear> rubyruy: and quotation, too
20:40:36 <rubyruy> i don't actually know how lisp macros work
20:40:41 <rubyruy> is it just pre-compile?
20:40:43 <tuxplorer> Saizan: ah! ok
20:40:52 <tuxplorer> Thanks..
20:40:52 <sorear> rubyruy: so you would need something like $( loopify [| ...body... |] )
20:41:05 <sorear> while in lisp, macros look just like other functions
20:41:10 <rubyruy> ah
20:41:14 <rubyruy> that's probably dangerous
20:41:41 <sorear> scheme \elem lisp, here
20:42:52 <rubyruy> oo another question that was on my mind - is haskell at all suited to aspect oriented programming - or can the goals of AOP be achieved in a more functional-programming-kind-of-way ?
20:42:55 <Saizan> mmh don't you have to quote even in lisp? i think a difference is that lisp uses atoms as a DSL for the macro sometimes
20:43:33 <at_> q: is it possible to call a function without arguments?  what's the syntax?
20:43:41 <sorear> Saizan: in lisp, all arguments to macros are automatically quoted, and the macro must eval any argument that shouldn't have been quoted
20:43:44 <monochrom> IMO Haskell has a functional, compositional, modularized answer to AOP.
20:43:46 <sorear> at_: 'function'
20:43:49 <syntaxfree> the problem with lisp is that it assumes the car of a list is a function.
20:44:01 <rubyruy> monochrom: do tell
20:44:10 <monochrom> It's too long.
20:44:13 <sorear> at_: because of laziness, there is no difference between mentioning a function and calling it with no arguments
20:44:15 <at_> sorear: that's a syntax for character, no?
20:44:23 <monochrom> I think someone wrote it up somewhere
20:44:23 <sorear> at_: omit the quotes
20:44:44 <syntaxfree> what are the goals of aop?
20:44:50 <sorear> what IS aop?
20:45:10 <jcreigh> syntaxfree: I don't understand. What do you mean, "assumes the car of a list is a function"?
20:45:57 <sorear> syntaxfree: only for lists that get passed to the evaluator.  most don't.
20:45:59 <rubyruy> sorear: i... that's a tough one to answer quickly... probably easiest by example... sec
20:46:18 <jcreigh> syntaxfree: OH, syntaxwise. Sure.
20:46:32 <jcreigh> don't mind me.
20:47:04 <tuxplorer> what is wrong with let foo = foldr (+) 0 (zipWith (+)) ?
20:47:26 <mauke> zipWith (+) doesn't look like a list
20:47:45 <sorear> tuxplorer: try (let foo x y = sum x + sum y) ?
20:47:48 <tuxplorer> is it possible to make a pointfree function for the above operation?
20:47:53 <SamB_XP_> isn't AOP one of those misnomers?
20:47:54 <sorear> sure!
20:48:10 <sorear> :t (foldr (+) 0 .) . zipWith (+)
20:48:12 <lambdabot> forall a. (Num a) => [a] -> [a] -> a
20:48:22 <monochrom> I haven't read these, but http://www.cs.iastate.edu/~leavens/FOAL/papers-2007/Hofer-Ostermann.pdf and http://www.cs.iastate.edu/~leavens/FOAL/papers-2007/Sulzmann-Wang.pdf sound promising on AOP in Haskell.
20:48:25 <lambdabot> http://tinyurl.com/2he73y
20:48:27 <rubyruy> sorear: Say you're writing (in a non-fp language) a banking app of sorts and you're working on a method that transfers money from one account to another, like transfer(from, to, amount). At the core the function should simply deduct money from the 'from' account and add the same mount to the 'to' account. However, IRL such a function would annoyingly good
20:48:34 <rubyruy> err s/good/huge
20:48:48 <rubyruy> because you first have to add stuff like, permissions checking
20:49:05 <rubyruy> and also checks for things like, don't overdraw the account
20:49:12 <tuxplorer> sorear: Thanks...
20:49:21 <Saizan> rubyruy:  IRC mangled your first message
20:49:25 <rubyruy> and whatever mechanism you use to ensure operations stay atomic
20:49:30 <SamB_XP_> rubyruy: mwahaha, if only!
20:49:31 <Saizan> rubyruy:  too long
20:49:57 <rubyruy> [1] Say you're writing (in a non-fp language) a banking app of sorts and you're working on a method that transfers money from one account to another, like transfer(from, to, amount).
20:49:59 <rubyruy> [2] At the core the function should simply deduct money from the 'from' account and add the same mount to the 'to' account. However, IRL such a function would annoyingly good
20:50:01 <rubyruy> that go through?
20:50:06 <Saizan> oh
20:50:19 <Saizan> it just ended :)
20:50:27 <Saizan> sorry
20:50:36 <mauke> it would good.
20:50:41 <rubyruy> i meant huge
20:50:42 <rubyruy> :p
20:50:48 <mauke> "it would huge"?
20:50:49 <sorear> I'd just use STM :)
20:50:53 <at_> sorear: is it possible to define a function without arguments then?  what's the difference between the very function and its value what it is called?  how can I tell the difference whether the function, uhm, is being "abstracted" or beta-reduced?
20:50:57 <SamB_XP_> I think he meant "it would sleep"
20:51:03 <monochrom> "annoyingly good" is good? is annoying?
20:51:05 <rubyruy> so AOP basically says let's split that extra stuff in different modules and have agreed-upon "join points" where they can hook into
20:51:14 <monochrom> Haskell is annoyingly good! :)
20:51:33 <rubyruy> it all seems like a good idea but when you actually see it used it ends up pretty ugly
20:51:35 <mauke> at_: a function without arguments is just a value
20:51:37 <sorear> at_: the point is a function with no arguments IS a value.  'x = 2' defines a function without arguments.
20:51:55 <rubyruy> hence me wondering if haskell can do it differently
20:52:01 <sorear> at_: it is called when you use the value, and no sooner
20:54:16 <at_> sorear: how do you implement random() function (without arguments) in haskell?
20:54:25 <sorear> at_: you don't
20:54:35 <kpreid> @type random
20:54:37 <rubyruy> wait i know this - you cant have a random() function!
20:54:38 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
20:54:52 <kpreid> there's random: it takes arguments!
20:55:01 <kpreid> @type randomIO
20:55:01 <sorear> at_: indeed, you can't have a random() with ANY number of arguments, you have to thread the seed yourself
20:55:04 <lambdabot> forall a. (Random a) => IO a
20:55:05 <at_> sorear: then how do you do Monte-Carlo numeric integration or something?
20:55:15 <kpreid> there's a monadic version
20:55:17 <mauke> at_: by using arguments
20:55:18 <sorear> at_: you thread the seed yourself!
20:55:19 <rubyruy> monads?
20:55:31 <mauke> monads just hide stuff under the carpet
20:55:32 <sorear> rubyruy: monads are just an abstraction, like numbers
20:55:49 <sorear> rubyruy: you don't use 'numbers', you always use a specific kind of numbers
20:55:59 <rubyruy> i think my brain just melted
20:56:23 <monochrom> Melting is good.  Learning is unlearning.
20:56:38 <Korollary> just learn the language and see for yourself. Stop listening to these nerds.
20:56:39 <monochrom> Melt it, then cool it to a better shape.
20:56:49 <sorear> rubyruy: you will appreciate the symmetry monads give haskell.  until then, try to think more concretely (IO, Maybe, [])
20:56:54 <SamB_XP_> Korollary: and you aren't a nerd?
20:57:02 <Korollary> SamB_XP_: I am the anti-nerd.
20:57:04 <rubyruy> we're on irc
20:57:12 <rubyruy> we're all nerds
20:57:14 * SamB_XP_ always thought monads were rather assymetrical
20:57:48 <rubyruy> this is like learning ruby all over again :p
20:57:58 <rubyruy> except you guys talk about 'symetry' and 'abstractions'
20:58:03 <monochrom> Learning is unlearning.
20:58:07 <rubyruy> the ruby guys talk about 'beauty' and 'eigenclasses'
20:58:07 <mauke> @quote
20:58:08 <lambdabot> qwe1234 says: dynamic typing is *always* a compiler bug.
20:58:23 <SamB_XP_> rubyruy: ... eigenclasses?
20:58:23 <monochrom> Ok, I give them credit for the name "eigenclasses".
20:58:41 <SamB_XP_> is that like "type" in python?
20:58:50 <rubyruy> the eigenclass is the class of the Class of your class :p
20:58:53 <SamB_XP_> type(type) is type
20:58:53 <monochrom> "symmetry" is sorear's word.  But yes we're all keen on abstraction.  You will join us.
20:59:22 * sorear only uses symmetry because he is a closet mathematician
20:59:23 <rubyruy> which is why we have class << self
20:59:25 <SamB_XP_> (rather odd overloading, there)
21:00:22 <SamB_XP_> sorear: arrows are a heck of a lot more symmetrical
21:00:24 <rubyruy> personally i think the eigenclass is just the C structs underneeth bleeding through - but that's just me
21:01:01 <SamB_XP_> rubyruy: like "type" in python, then. (though on good days it doesn't bleed *too* much)
21:02:02 <mauke> this is all so much simpler in perl :-)
21:02:03 <monochrom> I think I understand sorear's symmetry.  In general symmetry refers to the group of isomorphisms between the things in question.  If the group is nice we say the symmetry is nice.  Now tell me your brain has imploded.
21:03:20 <SamB_XP_> I'm not seeing where the isomorphisms come in.
21:03:29 <monochrom> Haskell's type and typeclass aren't C structs bleeding through at all.
21:03:32 <SamB_XP_> like, what are the things in question, even?
21:03:40 <monochrom> monads
21:03:58 <SamB_XP_> (there are structs in there, that are not in C's imagination?)
21:04:03 <monochrom> On the downside, if you see how Haskell is translated to C, your eyes will bleed.
21:04:17 <rubyruy> haskell is translated??
21:04:23 <mauke> sometimes
21:04:25 <monochrom> Does not have to be.
21:04:28 <rubyruy> oh ok
21:04:30 <SamB_XP_> kinda-sorta sometimes, yes
21:04:46 <sorear> rubyruy: it can be interpreted or compiled
21:05:09 <jcreigh> rubyruy: actually Haskell applications are usually compiled with GHC (either directly to machine code, or to C and then via gcc)
21:05:26 <monochrom> When porting Haskell to a previously unsupported platform, usually get the Haskell-to-C part to work first.
21:05:35 <rubyruy> weird - i figrued it would go directly to binaries
21:05:36 <SamB_XP_> but the "to C" part is what monochrom was referring to with "your eyes will bleed"
21:05:37 <sorear> rubyruy: actually, it took quite a bit of lateral thinking to make the first compiler; back in the early 80's, everyone "knew" that the predecessors of Haskell where impossible to compile.
21:06:09 <rubyruy> but i guess it's a good way to piggy-back on C's ubiquitous support
21:06:21 <monochrom> If someone has time, then work further on lets-skip-C-too.
21:06:25 <mauke> re: bleeding eyes, see also http://rafb.net/p/KBxoYm60.html
21:06:27 <lambdabot> Title: Nopaste - No description
21:06:30 <sorear> curiously, (one of) the person responsible for that lateral thinking is common here.
21:06:57 <Saizan> augustss?
21:07:00 <sorear> rubyruy: it's not just C's ubiquity - C also has good optimizers.  that's not easy to do.
21:07:02 <sorear> yes.
21:07:18 <SamB_XP_> sorear: to bad those optimizers are so slow!
21:07:23 <rubyruy> but surely C's optimizers are optimizing for actual C programs
21:07:36 <monochrom> I am indeed reading the infamous G machine thing.  (The tutorial by Peyton Jones and Lester. But yeah, invented by Augustss, as they wrote.)
21:07:49 <SamB_XP_> rubyruy: they are none the wiser if you feed them the output of GHC...
21:07:58 <monochrom> In retrospect it all makes sense. :)
21:08:21 <sorear> monochrom: augustss set me straight when I tried to say he invented the G-machine a few days ago.
21:08:33 <monochrom> Some confidence in heaps and GC is necessary before one dares to invent such a beast.
21:08:42 <monochrom> OH! Do tell!
21:09:11 <sorear> monochrom: augustsson wrote the first compiler, but it went straight to VAX.  it was johnsson who put an abstract machine in the middle.
21:09:15 <rubyruy> i thought (and i may well be VERY VERY VERY mistaken) that the way optimizers work is look for various patterns heuristically. Wouldn't machine-generated code have fairly different (but not completely different) patterns from human-written stuff?
21:09:35 <sorear> rubyruy: right, see "not completely different"
21:09:53 <SamB_XP_> rubyruy: they aren't looking for common human patterns.
21:10:02 <SamB_XP_> just things they can transform...
21:10:18 <monochrom> Circa 1980 the popular opinion was "yeah I have seen heap and GC" but psychologically inconfident about committing to it.  You need psychological commitmment to get brain to work.
21:10:20 <SamB_XP_> (some of which might happen to be common human patterns...)
21:10:46 <monochrom> If you think "nah, let's not go there", then you will never go there.
21:11:22 <SamB_XP_> are we there yet?
21:11:31 * SamB_XP_ wails from the back seat
21:11:54 <sorear> @remember SamB are we there yet?
21:11:55 <lambdabot> Done.
21:13:18 <Saizan> "haskell is not an acceptable haskell"?
21:13:21 <monochrom> I have experienced this before.  Someone posed a toy algorithmic problem.  At first I thought "I could do it dynamic programming, that will be like n^3, beyond that I don't know what could be improved."  Then the friend said, "it's linear!"  Within a minute I saw the linear way, it was easy too.
21:14:03 <monochrom> Note that I did not come up with the linear way when I thought it was impossible.
21:14:13 <Cale> Whoa, that was odd. I was reading a PDF in Evince (which I'd opened with Firefox), and had Firefox open in the background with a flash game that was playing music. Firefox crashes, and the music goes into a short loop. I kill off the remnants of the Firefox process, music keeps looping. I check lsof and apparently evince has the sound device open.
21:14:24 <Cale> (Closing evince killed the sound)
21:14:34 <monochrom> Once there is some assurance it could be done, only then I started thinking "okay, how would I do it linearly?"
21:14:57 <TSC> Cale: Maybe evince inherited the open file handle?
21:15:13 <monochrom> Heh
21:15:17 <Cale> Apparently it did.
21:15:23 <SamB_XP_> TSC: usually those things aren't set to be inherited, are they?
21:15:32 <SamB_XP_> across exec, I mean...
21:16:02 <tuxplorer> what is the difference between a data and a class? both seem to be similar? I can have methods operating on a data as well as class.. I find "data" in haskell similar to the class in OO languages like C++.. constructor and all that is there.. the only thing that I could see is that methods aren't bundled with data..
21:16:17 <TSC> SamB_XP_: I thought exec closed them...
21:18:17 <sorear> man flock.  CLOEXEC is NOT the default.
21:18:20 <monochrom> Take class in C++, remove methods (esp. virtual methods). For the moment pretend all fields public. (The module system can hide them later.)  Then you more or less has Haskell's data.
21:18:31 <sorear> er, fdctl.
21:18:36 <monochrom> Note no dynamic dispatch.
21:18:43 <mauke> fnctl
21:19:03 <sorear> that sounds right :)
21:19:06 <jcreigh> hmm. I wonder if the way we restart xmond leaks fds then.
21:19:15 <monochrom> Since all fields public, you can write operations outside "class".
21:19:43 <tuxplorer> monochrom: is there inheritance in the classes of Haskell? Is instance of similar to inheritance?
21:19:44 <sorear> jcreigh: (assuming linux) "ls /proc/`pidof xmonad`/fs"
21:19:46 <sorear> jcreigh: (assuming linux) "ls /proc/`pidof xmonad`/fd"
21:20:04 <sorear> jcreigh: if you see more than 4 fds, there is probably a leak.
21:20:13 <sorear> (stdin, stdout, stderr, X socket)
21:20:14 <mauke> tuxplorer: haskell's typeclasses are interfaces
21:20:17 <monochrom> No dynamic inheritance.
21:20:33 <pchiusano> hello
21:20:34 <jcreigh> even after multiple restarts, there's only those four. Strange.
21:20:41 <mauke> "instance Foo Bar" is like "Bar implements Foo"
21:20:57 <sorear> hello, pchiusano!
21:20:58 <monochrom> data Meh a = A | B a Int
21:21:02 <tuxplorer> ok. I get it now.. Thanks
21:21:17 <pchiusano> sorear, are you ever NOT on #haskell :-)
21:21:31 <pchiusano> I swear, every time I am on here, so are you
21:21:58 <sorear> pchiusano: I sleep at night.
21:22:04 <sorear> @time
21:22:06 <lambdabot> Local time for sorear is Fri Apr 20 21:20:47 2007
21:22:31 <pchiusano> heh, ok
21:22:33 <sorear> of course, no school tomorrow, so night starts around 1am
21:22:40 <monochrom> That is similarly to: <template class a> struct Meh {}; <template class a> struct A : Meh<a> {}; <template class a> struct B : Meh<a> { a first_field; int second_field; };
21:23:07 <SamB_XP_> sorear: you is one o' them californians?
21:23:11 <sorear> monochrom: that's template<class a> right?
21:23:14 <sorear> SamB_XP_: yes!
21:23:17 <sorear> sd even
21:23:17 <monochrom> yeah
21:23:39 <monochrom> It's a strange match.  I don't recommend comparison between apples and oranges.
21:23:51 <SamB_XP_> how about apples and PCs?
21:23:57 <jcreigh> sorear: west coast US?
21:23:59 <pchiusano> I have a question
21:24:09 <jcreigh> oh, nm
21:24:13 <sorear> jcreigh: that's where california is
21:24:35 <pchiusano> does haskell have some way of doing throw/catch
21:24:35 <tuxplorer> monochrom: Thanks.. though they are apples and oranges, as a person who had used the other imperative and OO langs for longtime, I'm unable to refrain from comparing. :)
21:24:38 <sorear> even wikipedia knows that! ;)
21:24:55 <sorear> pchiusano: 'error' does throw, Control.Exception.catc
21:24:58 <sorear> +h
21:25:00 <pchiusano> not for error-handling exactly, but if I want to exit a nested computation with a value
21:25:01 <jcreigh> Sorry. I guess I can't read. (Looked at localtime line, didn't notice SamB_XP_'s question...)
21:25:43 <monochrom> It's a temptation better resisted, I advise.
21:26:05 <tuxplorer> bracket does some error handling right?
21:26:06 <pchiusano> doesn't error take a String?
21:26:17 <tuxplorer> similar to try catch finally in other langs..
21:26:21 <pchiusano> I don't want to throw a String, I want to throw a value
21:26:40 <SamB_XP_> @hoogle Dynamic -> a
21:26:41 <lambdabot> No matches, try a more general search
21:26:43 <pchiusano> bracket?
21:26:44 <monochrom> I clear my mind and then I learn stuff.  After learning (not before!) I compare.  That is my secret of learning things quickly.
21:26:52 <SamB_XP_> hmm.
21:27:11 <SamB_XP_> what was it, Typeable a => a -> b?
21:27:11 <tuxplorer> bracket tryfoo dothird dosecond..
21:27:13 <monochrom> That was how I managed to learn haskell in log(n) time rather than O(n) time.
21:27:18 <SamB_XP_> or Typeable a => a -> IO b?
21:27:25 <ivanm> I have a list of a given size populated with 0s and 1s (or indeed any two values).  How can I generate each possible way of creating such lists such that the number of 1s is a given value?
21:27:26 <SamB_XP_> @hoogle throwD
21:27:27 <lambdabot> Control.Exception.throwDyn :: Typeable exception => exception -> b
21:27:28 <lambdabot> Control.Exception.throwDynTo :: Typeable exception => ThreadId -> exception -> IO ()
21:27:29 <tuxplorer> monochrom: ok. Thanks :)
21:27:46 <sorear> ivanm: recursion
21:28:04 <ivanm> sorear: just keep going through and see if I should set this value ot a 1 or not?
21:28:11 <ivanm> there's no fancy command that does something like that?
21:28:36 <ivanm> I know you mentioned replicateM to someone earlier this month, but it allows for less than the wanted number of 1s as well
21:29:08 <tuxplorer> bracket catches errors only in the dosecond part?? (bracket tryfoo dothird dosecond)
21:29:18 <sorear> > let comb 0 tot = [replicate tot 0] ; comb num 0 = [] ; comb (num+1) tot = map (1:) (comb num tot) ++ map (0:) (comb (num+1) tot) in comb 5 10
21:29:19 <lambdabot>  Parse error in pattern
21:29:25 <ivanm> heh
21:29:30 <sorear> *grumble*
21:29:38 <sorear> lambdabot doens't support n+k
21:29:40 <ivanm> *gasp* even sorear can get something wrong? :p
21:29:42 <pchiusano> hmm, bracket is not really what I want
21:29:51 <monochrom> @src bracket
21:29:52 <lambdabot> bracket before after thing = block $ do
21:29:52 <lambdabot>     a <- before
21:29:52 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
21:29:52 <lambdabot>     after a
21:29:52 <lambdabot>     return r
21:30:05 <monochrom> That should answer all questions :)
21:30:11 <sorear> > let comb 0 tot = [replicate tot 0] ; comb num 0 = [] ; comb num tot = map (1:) (comb (num-1) (tot-1)) ++ map (0:) (comb num (tot-1)) in comb 5 10
21:30:13 <lambdabot>  [[1,1,1,1,1,0,0,0,0,0],[1,1,1,1,0,1,0,0,0,0],[1,1,1,1,0,0,1,0,0,0],[1,1,1,1,...
21:30:14 <tuxplorer> :)
21:30:23 <sorear> > let comb 0 tot = [replicate tot 0] ; comb num 0 = [] ; comb num tot = map (1:) (comb (num-1) (tot-1)) ++ map (0:) (comb num (tot-1)) in comb 2 4
21:30:24 <lambdabot>  [[1,1,0,0],[1,0,1,0],[1,0,0,1],[0,1,1,0],[0,1,0,1],[0,0,1,1]]
21:30:41 <chessguy> hi all
21:31:02 <sorear> > filter ((==2) . sum) (replicateM 4 [0,1])
21:31:04 <ivanm> sorear: that looks like what I want, thanks!
21:31:04 <lambdabot>  [[0,0,1,1],[0,1,0,1],[0,1,1,0],[1,0,0,1],[1,0,1,0],[1,1,0,0]]
21:31:17 * chessguy dials in from the back yard of Dulles airport
21:31:19 <sorear> the second way is probably a lot slower though
21:31:35 <monochrom> how's backyard?
21:31:42 <ivanm> sorear: so how does your first way work?
21:31:48 * ivanm is trying to read through it...
21:31:57 <sorear> @pretty let comb 0 tot = [replicate tot 0] ; comb num 0 = [] ; comb num tot = map (1:) (comb (num-1) (tot-1)) ++ map (0:) (comb num (tot-1)) in comb 2 4
21:31:58 <lambdabot>  i = let comb 0 tot = [replicate tot 0]
21:31:58 <lambdabot>          comb num 0 = []
21:31:58 <lambdabot>          comb num tot
21:31:58 <lambdabot>            = map (1 :) (comb (num - 1) (tot - 1)) ++
21:31:58 <lambdabot>                map (0 :) (comb num (tot - 1))
21:32:00 <lambdabot>        in comb 2 4
21:32:10 <sorear> that should be prettier
21:32:29 <sorear> so, if you want 0 zeros, the only possibility is all zeros
21:32:43 <sorear> if you want >0 zeros in 0 positions, there are no possibilities
21:32:50 <ivanm> so num keeps treack of how many 1s there are, and tot on how long it is?
21:32:54 <sorear> yeah
21:33:00 <ivanm> *nod*
21:33:15 <sorear> otherwise, consider both the starting-with-1 and starting-with-0 cases.
21:33:22 <ivanm> I was thinking of doing something like that, just wanted to check in with the combined wisdom here to see if there was a better way ;-)
21:34:00 <ivanm> the only other way I could think of was the filtering of replicateM
21:34:10 <ivanm> which generates a lot of spurious results
21:34:16 <ivanm> thanks sorear++ !
21:34:22 <fantasma> ivanm: isn't your problem just a derangement problem?
21:34:22 <sorear> yw.
21:34:27 <pchiusano> monochrom
21:34:36 <pchiusano> can you explain @src bracket
21:34:47 <pchiusano> @src bracket
21:34:47 <lambdabot> bracket before after thing = block $ do
21:34:48 <lambdabot>     a <- before
21:34:48 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
21:34:48 <lambdabot>     after a
21:34:48 <lambdabot>     return r
21:34:51 <monochrom> It displays the source code...
21:34:52 <ivanm> fantasma: derangement?
21:34:59 <pchiusano> the throw and catch
21:35:08 <pchiusano> where do those functions come from
21:35:26 <pchiusano> and what is their type
21:35:32 <fantasma> ivanm: do you want to know how many possible lists there would be?
21:35:48 <ivanm> no, I want to generate all the lists
21:35:48 <chessguy> ?hoogle throw
21:35:49 <lambdabot> Control.Exception.throw :: Exception -> a
21:35:50 <lambdabot> Control.Concurrent.throwTo :: ThreadId -> Exception -> IO ()
21:35:50 <lambdabot> Control.Exception.throwDyn :: Typeable exception => exception -> b
21:35:56 <chessguy> ?hogle catch
21:35:57 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
21:35:57 <monochrom> They're in Control.Exception.
21:35:57 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
21:35:57 <lambdabot> GHC.ConsoleHandler.Catch :: (ConsoleEvent -> IO ()) -> Handler
21:36:28 <monochrom> unblock is also in Control.Exception. You can ignore it as a first-order approximation.
21:36:38 <sorear> > let { comb n t = if (t == 0) then guard (n == 0) else do { x <- [0,1] ; tell [x] ; comb (n-x) (t-1) } } in execWriterT (comb 2 4)
21:36:40 <lambdabot>  Couldn't match expected type `WriterT w m a'
21:36:45 <ivanm> fantasma: I'm trying to create a matrix (stored as [[a]]) with a given weight (i.e. number of non-zeros) such that the weight of each row/column is non-increasing
21:36:47 <monochrom> @doc Control.Exception
21:36:48 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
21:36:54 <monochrom> Try that.
21:37:12 <pchiusano> okay, so I need to import Control.Exception to use those
21:37:13 <sorear> @type Control.Monad.Writer.execWriterT
21:37:16 <lambdabot> forall w (m :: * -> *) a. (Monad m) => WriterT w m a -> m w
21:37:47 <sorear> @ty let { comb n t = if (t == 0) then guard (n == 0) else do { x <- [0,1] ; tell [x] ; comb (n-x) (t-1) } } in comb
21:37:50 <lambdabot>     No instance for (MonadWriter [a] [])
21:37:50 <lambdabot>       arising from use of `tell' at <interactive>:1:72-79
21:38:10 <sorear> > let { comb n t = if (t == 0) then guard (n == 0) else do { x <- lift [0,1] ; tell [x] ; comb (n-x) (t-1) } } in execWriterT (comb 2 4)
21:38:11 <lambdabot>  [[0,0,1,1],[0,1,0,1],[0,1,1,0],[1,0,0,1],[1,0,1,0],[1,1,0,0]]
21:38:44 <fantasma> surely there has to be an easier way to do that
21:39:20 <ivanm> @pretty let { comb n t = if (t == 0) then guard (n == 0) else do { x <- lift [0,1] ; tell [x] ; comb (n-x) (t-1) } } in execWriterT (comb 2 4)
21:39:21 <lambdabot>  i = let comb n t
21:39:21 <lambdabot>            = if (t == 0) then guard (n == 0) else
21:39:21 <lambdabot>                do x <- lift [0, 1]
21:39:21 <lambdabot>                   tell [x]
21:39:21 <lambdabot>                   comb (n - x) (t - 1)
21:39:23 <lambdabot>        in execWriterT (comb 2 4)
21:39:38 * ivanm isn't sure if he gets that code...
21:39:45 <sorear> it's not 'better'
21:39:53 <ivanm> heh
21:40:04 <sorear> it's a very different way of looking at the problem
21:40:09 <ivanm> more a matter of working out how to obsfucate random functions? :p
21:40:13 <ivanm> *nod*
21:40:22 <fantasma> ivanm: what do you plan on doing with the nth matrix?
21:40:25 <ivanm> what's guard?
21:40:25 <sorear> using the WriterT transformer (like python generators) and [] (backtracking)
21:40:29 <sorear> @src guard
21:40:30 <lambdabot> guard True  =  return ()
21:40:30 <lambdabot> guard False =  mzero
21:40:34 <ivanm> fantasma: creating the "shape" of a partial latin square
21:40:52 <fantasma> ahhh I see
21:40:54 <ivanm> I'll then use that shape matrix to generate the partial latin squares with that shape
21:41:09 <ivanm> atm, I'm populating values and creating the shape (by allowing the 0 value) at the same time
21:41:17 <ivanm> which is too costly and wastes a lot of time
21:42:04 <fantasma> can you create a latin "cube" from the square?
21:42:20 <ivanm> never heard of a latin cube before...
21:42:26 <ivanm> but I don't see why not...
21:42:37 <ivanm> it'd be a lot harder though... not sure if its possible
21:42:46 * ivanm hasn't done much theory stuff...
21:42:55 <ivanm> I'm just coding this for one of my lecturers
21:43:54 <fantasma> I think I have a permute function lying around somewhere
21:44:29 <ivanm> as in permuting symbols?.... yeah, I've got one...
21:44:41 <Nafai> shim is nice
21:45:21 <ivanm> didn't think of that... permute ((replicate w 1) ++ (replicate (n-w) 0))
21:45:36 <SamB_XP_> er?
21:45:44 <SamB_XP_> isn't that going to give you lots of duplicates?
21:45:53 <ivanm> ummm.... yeah... it will
21:45:57 <ivanm> forget that then
21:46:06 <fantasma> > let permute [] = [[]]; permute list = concat $ map (\(x:xs) -> map (x:) (permute xs)) (take (length list) (unfoldr (\x -> Just (x, tail x ++ [head x])) list)) in permute "hello"
21:46:08 <lambdabot>  ["hello","helol","helol","hello","heoll","heoll","hlloe","hlleo","hloel","hl...
21:46:08 * ivanm thinks he'll go with sorear's suggestion
21:46:48 <fantasma> > let permute [] = [[]]; permute list = concat $ map (\(x:xs) -> map (x:) (permute xs)) (take (length list) (unfoldr (\x -> Just (x, tail x ++ [head x])) list)) in (nub . permute) "hello"
21:46:50 <lambdabot>  ["hello","helol","heoll","hlloe","hlleo","hloel","hlole","hlelo","hleol","ho...
21:46:56 <ivanm> > let permute [] = [[]]; permute list = concat $ map (\(x:xs) -> map (x:) (permute xs)) (take (length list) (unfoldr (\x -> Just (x, tail x ++ [head x])) list)) in permute ((replicate 2 1) ++ (replicate (4-2) 0))
21:46:58 <lambdabot>  [[1,1,0,0],[1,1,0,0],[1,0,0,1],[1,0,1,0],[1,0,1,0],[1,0,0,1],[1,0,0,1],[1,0,...
21:47:12 <ivanm> but yeah, its going to generate duplicates, so it'd be slower
21:47:25 <ivanm> > let permute [] = [[]]; permute list = concat $ map (\(x:xs) -> map (x:) (permute xs)) (take (length list) (unfoldr (\x -> Just (x, tail x ++ [head x])) list)) in nub $ permute ((replicate 2 1) ++ (replicate (4-2) 0))
21:47:26 <lambdabot>  [[1,1,0,0],[1,0,0,1],[1,0,1,0],[0,0,1,1],[0,1,1,0],[0,1,0,1]]
21:47:31 <fantasma> > let permute [] = [[]]; permute list = concat $ map (\(x:xs) -> map (x:) (permute xs)) (take (length list) (unfoldr (\x -> Just (x, tail x ++ [head x])) list)) in (map read . nub . permute) "1100"
21:47:33 <lambdabot>  [1100,1001,1010,11,110,101]
21:47:34 <ivanm> and I need speed
21:47:52 <ivanm> nope, don't want it a list of ints, not as a big int
21:48:06 <ivanm> s/don't/""
21:48:20 <ivanm> since I won't actually be using 0 and 1, but an algebraic datatype
21:49:42 <fantasma> ghc is finished compiling!
21:50:27 <ivanm> @botsnack
21:50:28 <lambdabot> :)
21:50:40 * ivanm was too lazy to smile himself
21:51:16 <fantasma> ...I spoke too soon
21:53:20 <SamB_XP_> @b
21:53:20 <lambdabot> Maybe you meant: b52s babel bf botsnack brain bug . v
21:53:25 <SamB_XP_> @bo
21:53:26 <lambdabot> :)
21:54:29 * ivanm thinks SamB_XP_ is even lazier
21:58:08 <jcreigh> hmm, HaXml generates a lot of warnings.
22:02:04 <dons> jcreigh: so its all the xinerama code working to your liking for xmonad 0.1 to be released?
22:02:29 <dons> jcreigh: also, any chance of 2/3 monitor screen shots? :-)
22:02:30 <jcreigh> Yeah, I think so.
22:02:35 <dons> would make great propaganda...
22:02:52 <ivanm> dons: I tried xmonad the other day... and amsn doesn't seem to like it
22:03:02 <jcreigh> http://www.jcreigh.com/xmonad/triplehead.jpeg (sorry, bad photo)
22:03:06 <dons> ivanm: in what sense?
22:03:08 * SamB_XP_ pulls out big knife to chop off a third of the screen
22:03:16 <ivanm> don't know why, but whenever you try and talk to someone with it, the whole program crashes
22:03:18 <dons> amsn is a open source now?
22:03:21 <jcreigh> I should try to take a better one...
22:03:28 <ivanm> always was, afaik
22:03:31 <dons> ivanm: hmm. anything else?
22:03:33 <ivanm> its a tk-based msn client
22:03:55 <dons> ok. do you have a log of your .xsession-errors file from the crash?
22:04:06 <ivanm> dons: nah, that's about it... the gentoo ebuild just needs to be edited so that a config file can be passed to it according to kolmodin
22:04:12 <ivanm> I'll have a look, but I doubt it...
22:04:13 <dons> could you perhaps do that for me? run amsn, when it crashes, don't log in, go the console, get the .xsession-errors file
22:04:58 <dons> jcreigh: that's pretty sweet, actually
22:05:01 * ivanm tries logging in using xnest
22:05:09 <dons> jcreigh: any chance you could do another for the web site?
22:05:23 <dons> maybe with some pretty graphics on one window, and the others similar to how they are now?
22:05:25 <SamB_XP_> what? no Xephyr?
22:05:36 <dons> i guess that is firefox on the left? maybe have some image up or something
22:05:55 <jcreigh> yeah, firefox.
22:06:00 * ivanm forgets... whats the key command for opening a new xterm in xmonad?
22:06:09 <dons> mod-shift-return
22:06:17 <jcreigh> I'll have the original image open in firefox. :)
22:06:21 <dons> to run a program, mod-p, assuming you have dmenu
22:06:23 <ivanm> OK, it doesn't work in xnest :(
22:06:27 <dons> jcreigh: yeah. that's fun :-)
22:06:36 <dons> ivanm: do you have an error log?
22:06:44 <ivanm> where would I find it?
22:07:00 <dons> hmm. .xsession-errors ? or /var/log/*
22:07:34 <fantasma> dons: do you have any idea what would make xmonad stretch a tiled xterm below the screen?
22:07:52 <dons> hmm. yes. perhaps if you had a bogus setting in .Xresources for the xterm geometry?
22:08:04 <dons> or you'd aliased xterm to some xterm with a weird geometry
22:08:16 <dons> does it resize properly if you , say, cycle through the tiling modes (mod-space)
22:08:29 <dons> fantasma: btw, sjanssen has a login to xmonad.org now, is that right?
22:08:37 <fantasma> dons: yeah
22:08:51 <dons> (we're planning on updating the website today/tomorrow, and releasing 0.1 shortly after)
22:08:58 <dons> thanks so much for setting up the site!
22:09:08 <dons> i hope it doesn't cost you much?
22:09:14 <fantasma> nah
22:09:27 <fantasma> hopefully getting a dedicated server though
22:09:39 <dons> we'll host the src and tarballs on haskell.org anyway, so the downloads won't cost you
22:09:42 <ivanm> dons: nah, can't seem to find anything atm
22:09:44 <fantasma> intel xeon 3060 + 100 mbit = gun
22:09:52 <dons> cool
22:09:55 <fantasma> s/gun/fun
22:10:43 <fantasma> dons: and the answer to cycling between tile and float ...the windows stay the exact same
22:11:27 <fantasma> (and the xterms seemed to run fine under twm)
22:13:10 <jcreigh> ...and HaXml is *still* compiling...
22:15:08 * sorear compiles the megamonad-bot branch for the first time...
22:15:47 <sorear> hello jyp!
22:15:51 <sorear> er, oops
22:17:37 <jwp> jwp?
22:18:22 <sorear> yeah, you ... I misread it as 'jyp' (Jean-Phillipe Bernardy)
22:32:48 <jcreigh> dons: I'm uploading the least blurry of the latest batch now...it's not really an improvement. You guys need to get a different PR man. :)
22:34:17 <jcreigh> http://www.jcreigh.com/tmp/img_0121.jpg [uncompressed; resize to suit]
22:34:49 * jcreigh wonders if anybody can read his WEP key on the sticky note in the upper left hand corner...
22:35:24 <ivanm> jcreigh: heh, I like whats in the LHS monitor
22:35:43 <jcreigh> well, that's what I happened to be looking at. :)
22:36:05 <ivanm> upper left hand corner of which monitor?
22:36:19 <jcreigh> of the photo; there's a sticky note on the router.
22:37:35 <ivanm> I can read WEP, and that's about it
22:39:00 * dons zooms in to investigate
22:39:12 <jcreigh> dons: I doubt you're in range. :)
22:39:33 <dons> hehe
22:40:40 <dons> yeah, jcreigh though really you should have the same image in the left monitor 9or a fake version of it
22:40:48 <dons> just so there's the impression of recursion...
22:40:52 <ivanm> recursive images!
22:40:54 <ivanm> :D
22:41:18 <ivanm> 1. take a photo 2. upload it 3. view the photo in LHS monitor 4. repeat
22:41:34 <jcreigh> ivanm: well, you don't have to actually upload a photo to view it. :)
22:42:42 <ivanm> true... but then you have to add another step to the end, where you finally upload it
22:42:49 <ivanm> so its not as recursive anymore
22:43:11 <ivanm> but, step 2 could mean upload it from the camera :p
22:43:18 <ivanm> never specified the net, did I? ;-)
22:43:20 <dons> yeah, i don't see how you can easily make it truly recursive
22:43:29 <foxy-om> > nubBy (\x y -> x + 2 /= y) $ nubBy (\x y -> mod y x == 0) [2..] -- why doesn't this compute twin primes?
22:43:30 <fantasma> dons: what version autoconf do you use for x11-extras?
22:43:32 <QtPlatypus> Some cams have a live output.
22:43:33 <lambdabot> Terminated
22:43:37 <dons> fantasma: autoreconf ?
22:43:44 <jcreigh> HApps wants HList-any: Is this darcs get http://darcs.haskell.org/HList/?
22:43:45 <dons> yeah, unless there's a live output option
22:43:46 <lambdabot> Title: Index of /HList
22:43:53 <dons> jcreigh: check for hlist on hackage?
22:44:11 <dons> foxy-om: nub is too strict?
22:44:12 <jcreigh> dons: I don't see it there...
22:44:27 <dons> since it has to get to the tail to before it can generate its first nub?
22:44:31 <dons> or is it just too slow
22:44:47 <foxy-om> > nubBy (\x y -> mod y x == 0) [2..]
22:44:48 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
22:45:01 <dons> oh, interesting.
22:45:35 <dons> ah, i'm confused about how nub worked :-)
22:45:40 <dons> keep the first occurence, not the last
22:46:44 <foxy-om> @type nubBy
22:46:45 <tuxplorer> @src lambdabot
22:46:46 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
22:46:46 <lambdabot> Source not found. Where did you learn to type?
22:46:50 <ClaudiusMaximus> > nubBy (\x y -> x /= y + 2) $ nubBy (\x y -> mod y x == 0) [2..] -- maybe this?
22:46:54 <lambdabot> Terminated
22:47:11 <dons> > nubBy (\x y -> x /= y + 2) $ nubBy (\x y -> mod y x == 0) [2..100]
22:47:12 <lambdabot>  [2]
22:47:16 <dons> > nubBy (\x y -> x /= y + 2) $ nubBy (\x y -> mod y x == 0) [2..1000]
22:47:17 <lambdabot>  [2]
22:47:20 <tuxplorer> dons: where is lambdabot's source code?
22:47:20 <dons> > nubBy (\x y -> x /= y + 2) $ nubBy (\x y -> mod y x == 0) [2..10000]
22:47:23 <lambdabot>  [2]
22:47:25 <dons> ?source
22:47:25 <lambdabot>  not available
22:47:28 <dons> ?where lambdabot
22:47:28 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
22:47:36 <dons> @version
22:47:36 <lambdabot> lambdabot 4p517, GHC 6.6 (OpenBSD i386)
22:47:36 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:47:45 <tuxplorer> Thanks
22:47:45 <foxy-om> > nubBy (\x y -> x +2 /= y) $ nubBy (\x y -> mod y x == 0) [2..10000]
22:47:47 <lambdabot>  [2]
22:47:58 <foxy-om> @botslap
22:47:58 <lambdabot> Unknown command, try @list
22:48:07 <foxy-om> @botsnack
22:48:07 <dons> > nubBy (\x y -> x +2 /= y) $ nubBy (\x y -> mod y x == 0) [2..1000000]
22:48:07 <lambdabot> :)
22:48:12 <lambdabot> Terminated
22:48:58 <foxy-om> > nubBy (\x y -> x + 2 /= y) [1,1,2,3,5,8]
22:48:59 <lambdabot>  [1,3]
22:49:27 <foxy-om> ah, nubBy doesn't do what I thought it did...
22:50:08 <fantasma> dons: when I try to configure X11-extras, it says I don't satisfy the x11 dependency (yet I have v.6.9 installed)
22:50:38 <dons> you have the Haskell X11 library?
22:50:54 <dons> $ ghc-pkg list X11
22:50:54 <dons> /home/dons/lib/ghc-6.6/package.conf:
22:50:54 <dons>     X11-1.1, X11-1.2
22:51:00 <fantasma> ohhhhh
22:51:10 <fantasma> i thought that was just x11
22:51:13 <dons> its unfortunate that the Haskell X11 _binding_ is call 'X11'
22:51:28 <dons> this has confused a few people who assume they do have (Hs-)X11 already
22:51:32 <fantasma> thanks (sorry to bother you with my ignorance)
22:51:36 <dons> that's fine.
22:51:41 <dons> we should be more precise I think in the README
22:53:14 <foxy-om> http://lambda-the-ultimate.org/node/2206
22:53:15 <lambdabot> Title: Why is there not a PL with a mathematical type system? | Lambda the Ultimate
22:53:37 <whaleofconfusion> isn't there?
22:54:13 <jcreigh> hmm. I wonder how we can make xmonad perform better when the system is under load.
22:54:48 <dons> almost all recent FP languages have well-defined type system. how are they defined? with mathematics, of couse. so the title seems a bit confusing.
22:55:02 <dons> jcreigh: you've actually seen performance issues??
22:55:06 <whaleofconfusion> having read the article what about mathematica or matlab
22:55:16 <dons> whaleofconfusion: do they even have type systems?
22:55:21 <monochrom> "mathematics" is now a buzzword.
22:55:28 <foxy-om> whaleofconfusion: they're untyped
22:55:36 <dons> yeah, seems so. the title makes no sense
22:55:39 <whaleofconfusion> they don't have static type inference, but they must have some kind of typing
22:55:47 <whaleofconfusion> even if it's just duck typing
22:55:51 <dons> they're type systems aren't even defined though.
22:56:00 <monochrom> If you talk to a bunch of people doing matrix computations, they call it "mathematics".
22:56:07 <ivanm> sounds like the B-Method... but that's just a formal method
22:56:11 <dons> are there even *informal, textual* descriptions of the mathematica type system?
22:56:13 <ivanm> can't really program in it
22:56:22 <monochrom> Yes.
22:56:37 <foxy-om> matlab has no type system
22:56:39 <jcreigh> yeah. When I'm compiling something, sometimes it's slow (1-2 seconds) to switch workspaces or open an xterm. But it's not consistently slow.
22:56:55 <dons> but no precise semantics, i'd imagine. (dynamic languages rarely have precise type semantics)
22:56:56 <ivanm> foxy-om: well, it has types, but automatically works out what they are and changes variable types on the fly
22:57:09 <dons> jcreigh: wow.
22:57:14 <dons> jcreigh: sounds like X rather than xmonad though
22:57:22 <jcreigh> maybe I just need to renice GHC. :)
22:57:24 <monochrom> Mathematica's type system is basically built-in types plus untyped lambda calculus plus open variants.
22:57:26 <dons> jcreigh: i run X11 under an increase 'nice' value, so it stays responsive
22:57:28 <jcreigh> possibly.
22:57:58 <monochrom> Anyway, to continue with my drivel.
22:58:08 <jcreigh> The default nice value for X was like -10, but I changed to 0 because I was getting choppy audio.
22:58:47 <dons> yeah, the LtU poster just doesn't know much about the area, and the title is misleading
22:58:49 <monochrom> If you talk to a bunch of people doing graph theory, they also call it "mathematics", although they add "discrete".
22:59:55 <pGeist> dons:  which post is this?
22:59:56 <ivanm> *nod*
23:00:05 <monochrom> If you talk to a bunch of people doing computability and complexity, they call it "mathematics".
23:00:10 <pGeist> the RZ one?
23:00:32 <monochrom> And finally if you talk to highschool students doing trig and integrals, they call it "mathematics".
23:00:36 <pGeist> oh heh.  wrong nick.
23:00:51 <goltrpoat> or, wrong channel rather.
23:01:05 <ivanm> monochrom: fine then, define "mathematics" :p
23:01:20 <ddarius> monochrom: Do you have a point?
23:01:28 <monochrom> It appears to me a "mathematics library for haskell" has to include everything all the way from adding integers to de Rham cohomology.
23:02:19 <monochrom> I'm saying why are people hijacking the word "mathematics" for their own fetish.
23:02:37 <ivanm> yeah...
23:02:39 <goltrpoat> agreed, the idea of a "mathematics library" is silly
23:02:48 <ddarius> monochrom: All those things are mathematics though.
23:03:15 <monochrom> "haskell needs a better math library!"  turns out the speaker means matrices.  That's stupid.
23:03:23 <goltrpoat> linear algebra folk are going to want one thing, abstract algebra folk are going to want another thing, and applied folk are going to want something different entirely
23:03:29 <ddarius> monochrom: I can agree with that.
23:03:42 <ddarius> The magic of heirarchical libraries.
23:04:04 <monochrom> How about "haskell needs a better silver-bullet library!"  I should post that to the cafe.
23:05:24 <monochrom> But I have to wait for the next April 1.
23:05:43 <dolio> That's no good. We might have a silver bullet library by then.
23:05:52 <goltrpoat> hehe was about to say that
23:06:12 <ddarius> The post would imply that that is the case.
23:08:04 <tuxplorer> what does the in keyword do?
23:08:19 <dolio> > let x = 5 in x + x
23:08:21 <lambdabot>  10
23:08:21 <jcreigh> > let x = 5 in x*x
23:08:23 <lambdabot>  25
23:08:36 <tuxplorer> ok.
23:09:37 <ddarius> > let x = 5 in x^x
23:09:38 <lambdabot>  3125
23:10:36 <qebab> in x^x creates a list and it looks up the fifth value? :o
23:11:02 <qebab> > let x = 5 in x/(x/2)
23:11:04 <lambdabot>  2.0
23:11:14 <monochrom> Recall that in a piece of syntax, not every token has meaning (in isolation).  Often just delimiter, punctuation.
23:11:35 <goltrpoat> qebab:  hmm?
23:11:40 <qebab> never mind me
23:11:54 <qebab> I still haven't gotten around to read about haskell
23:12:04 <qebab> I'm just snapping up random pieces of syntax from this channel
23:12:56 <monochrom> Oh, we forgot to mention to rubyruy that "the programmable semicolon" (the way dons puts it) also relieves Haskell from a lot of conventional needs of metaprogramming.
23:13:25 <ddarius> Not really.
23:13:41 <rubyruy> i'm pretty close to giving up - at least for the night
23:13:45 <rubyruy> these tutorials are ridiculous
23:13:50 <monochrom> haha
23:13:55 <dons> rubyruy: are you reading YAHT or the wikibook?
23:13:57 <sorear> rubyruy: Give up for the night.
23:14:06 <dons> rubyruy: or perhaps one of the practical tutes?
23:14:10 <rubyruy> i tried yaht and now this one: http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/parser.html
23:14:11 <sorear> rubyruy: Haskell and sleepiness do not mix.
23:14:12 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/yzphh2
23:14:19 <rubyruy> right
23:14:24 <dons> ok, they're good, but thorough/hard
23:14:38 <rubyruy> the scheme one is the more ridiculous one
23:14:48 <rubyruy> it just zooms by HUGE parts of the language
23:14:50 <dons> its quite nice if you're in to writing interpreters, imo.
23:14:54 <sorear> it's been criticised before.
23:15:00 <rubyruy> and then spends a lot of time discussing the finer points of parsing
23:15:01 <dons> yeah, its sometimes reported as being rather tough
23:15:03 <rubyruy> sigh
23:15:18 <goltrpoat> the scheme one is actually great, but requires some background.  i know a lot of people hated it, but i thought it was an excellent tutorial
23:15:23 <dons> there's a *lot* of tutes out there now, almost all findable from haskell.org
23:15:25 <monochrom> It's a good second tutorial
23:15:28 <qebab> few languages mix well with sleepiness :) better to read when you are well awake, you'll enjoy it more and not give up as easily
23:15:40 <dons> so you should be able to find something to tackle when not so tired :-)
23:15:58 <rubyruy> it's not an intro tutorial - there is no way anyone could complete this without prior knowledge of haskell
23:16:13 <rubyruy> at least some of it i mean
23:16:21 <dons> i think you're supposed to have a knowledge of another functional language
23:16:24 <rubyruy> i'm sure it would be a great second or third read
23:16:27 <dons> for example, scheme or lisp
23:16:40 <qebab> how is the wikibook for this?
23:16:49 <rubyruy> i know some scheme - but i mean - it glances over a lot of syntax and zooms right through monads
23:16:58 <qebab> should I start by reading something else, or is that a nice enough start?
23:17:06 <dons> yeah, so you're at the point where the syntax is still alien.
23:17:13 <dons> we usually say to start with YAHT
23:17:16 <dons> or the wikibook
23:17:17 <kowey> the wikibook is (deliberately) the slowest of the lot
23:17:23 <rubyruy> "Ok so monads are these things, and the << binds an action to the previous one. Moving right along, here is how << can be used to write a parser [insert magic]" :(
23:17:28 <dons> for specific requirements, some of the 'practical haskell' tutes are recommended
23:17:41 <goltrpoat> someone i know had some luck with that haskell for C programmers tutorial (the name escapes me at the moment)
23:17:59 <goltrpoat> i told him to go through YAHT initially, then loaned him my copy of 'road to logic,' but i guess that was the one that stuck
23:18:01 <qebab> I don't know C, so I don't think that would be a good point to start
23:18:04 <goltrpoat> ah ok
23:18:10 <dcoutts> hia dons
23:18:19 <dons> hey dcoutts
23:18:30 <rubyruy> not a single tutorial i stumbbled upon even bothered explaining how the whitespace/indentation stuff actually works! Yaht breifly mentioned indentation is relevant, but no more
23:18:44 <rubyruy> it took me forever to figure out you have to align the bloody things and that's how they know they belong to eachother
23:18:50 <dons> rubyruy: hmm, perhaps you'd be best off with one of the intro textbooks?
23:18:52 <rubyruy> and i'm still not sure exactly how it works
23:18:59 <dons> "the craft of FP" for example
23:18:59 <kowey> rubyruy: have a look at http://en.wikibooks.org/wiki/Haskell/Indentation
23:19:01 <lambdabot> Title: Haskell/Indentation - Wikibooks, collection of open-content textbooks
23:19:06 <qebab> I had a bit of problems with the indentation
23:19:14 <qebab> I tried using tabs first, but that didn't work
23:19:15 <dcoutts> dons: fell good to be back? nice and sunny here compared to portland I bet
23:19:29 <dons> dcoutts: yeah, quite enjoyed the sun today :-)
23:19:31 <qebab> however spaces did
23:19:37 <dcoutts> dons: I'm glade Gill and co liked our stuff so much, that's very reassuring
23:19:46 <dcoutts> hia int-e
23:19:49 <dons> dcoutts: yeah, you got the mail about virtual data?
23:19:52 <dcoutts> yep
23:20:04 <ClaudiusMaximus> @hoogle (a->b) -> (b->b->c) -> (a->a->c)
23:20:04 <int-e> hi
23:20:05 <lambdabot> No matches, try a more general search
23:20:07 <monochrom> I learned indentation from the Gentle Introduction.  Everyone hates Gentle Introduction and I don't understand why.  It worked for me.
23:20:12 <dolio> > let arr 0 a b = a*b ; arr 1 a b = a^b ; arr n a b = foldr1 (arr $ pred n) $ genericReplicate b a in arr 2 3 3
23:20:14 <lambdabot>  7625597484987
23:20:33 <rubyruy> Why can't i find anything like the Ruby Crystalized intro :(
23:20:39 <ivanm> monochrom: in this day and age, people don't want gentleness, they want to be hit over the head! :p
23:20:41 <goltrpoat> i didn't actually learn the indentation rules (as per report) until i had been programming in haskell for a couple of years
23:20:42 <goltrpoat> heh
23:20:42 <rubyruy> it's so great - you jump right in and it tells you how things work
23:21:03 <goltrpoat> i'd just sort of align things the way that made sense and it would work, so i figured it was magic.
23:21:25 <qebab> I like that whitespace is important, it *usually* makes programs more readable
23:21:56 <qebab> and I'm used to indenting anyway
23:22:08 <qebab> it was just a bit different ;)
23:23:02 <hpaste>  fantasma pasted "build errors (help!)" at http://hpaste.org/1491
23:23:37 <sorear> fantasma: you need to install X11
23:23:46 <rubyruy> i think it's a fine idea - i just wished someone started a tutorial with it
23:23:50 <sorear> not the haskell package,the C package
23:23:58 <sorear> and you need the development files
23:24:17 <sorear> package 'xorg-dev' or similar
23:24:36 <fantasma> sorear: ah I see thanks
23:24:54 <rubyruy> see this? http://www.ruby-doc.org/docs/ProgrammingRuby/html/language.html it's perfect :p
23:24:56 <lambdabot> Title: Programming Ruby: The Pragmatic Programmer's Guide
23:25:10 <rubyruy> is there anything like that for haskell?
23:25:37 <rubyruy> it starts with syntax, mentions the core ideas (everything is an object etc) tells you the basic syntax elements and slowly builds on that
23:25:40 <qebab> that's the first tutorial I ever did :)
23:25:52 <rubyruy> that's the Right Way of learning a programming language imo
23:26:08 <fantasma> I really liked that book
23:26:09 <qebab> I think you might be right
23:27:04 <fantasma> Introduction to Functional Programming is supposedly a good book
23:27:43 <rubyruy> haskell specific?
23:27:50 <foxy-om> @google barendregt introduction to lambda calculus
23:27:52 <lambdabot> http://ling.ucsd.edu/~barker/Lambda/barendregt.94.pdf
23:28:18 <sorear> yay, new lambdabot state system works.
23:28:20 <rubyruy> heeey wait a second i think my girlfriend has that book
23:28:24 <foxy-om> read that, then apply sugar
23:28:59 <rubyruy> foxy-om: isn't that lisp ? :p
23:29:28 <fantasma> lol there were 6 blank pages in the begining of that pdf book
23:29:33 <goltrpoat> it's somewhat difficult to draw terribly meaningful comparisons between ruby tutorials and haskell tutorials
23:29:51 <rubyruy> that is true - haskell ones have to teach you FP as well
23:29:55 <rubyruy> i accept that
23:29:55 <goltrpoat> ruby is a very easy to grasp language, it was designed with that explicit goal
23:30:24 <foxy-om> rubyruy: NO! :P
23:30:45 <fantasma> foxy-om: thanks for the link, looks like a good read
23:34:13 <rubyruy> ok let's give the wikibook a try
23:34:26 <rubyruy> a brand new hello world? boy i hope so!
23:35:15 <monochrom> what's special about ruby, setting it apart from yet another o.method language?
23:35:29 <rubyruy> well we have closures for one
23:35:43 <rubyruy> we even call them lambdas sometime!
23:35:51 <rubyruy> and you can do a lot of FP stuff from them
23:36:15 <rubyruy> map, filter etc
23:36:18 <qebab> ruby isn't that special, but it's quite powerful/high level, and easy to grasp
23:36:19 <qebab> yeah
23:36:26 <qebab> but it isn't quite the same
23:37:15 <rubyruy> the sheer hackability is pretty cool too. defining new classes at runtime, modifying existing ones, injecting code before/after existing methods - you can do A LOT of stuff with it
23:37:20 <goltrpoat> monochrom:  from what i've seen, it's a more accessible smalltalk
23:37:30 <goltrpoat> but.. i haven't done a whole lot with it
23:38:05 <rubyruy> it's kept me pretty happy but it has it's sore spots. It was actually type inference that lead me to haskell, not FP.
23:40:43 <mwc> Anybody got a ghc-6.6 binary for linux/ppc?
23:42:46 <rubyruy> oh my - i rather am enjoying the wikibook - it's very much what i wanted. slow my arse. slow gets things done right :p
23:43:07 <rubyruy> it does things in the right order is what i'm most pleased with
23:43:19 <Pseudonym> Smalltalk is... well, let's just say it makes a nice museum piece.
23:43:22 <goltrpoat> http://haskell.org/ghc/dist/6.6/ghc-6.6-ppc-apple-darwin.tar.gz
23:43:27 <goltrpoat> says google
23:43:28 <eumenides> ruby is awful. i spent days debugging a game of life because i couldn't understand what it was doing with 2d array references
23:43:42 <Pseudonym> Let me paraphrase that.
23:43:48 <Pseudonym> "Ruby is awful.  I didn't understand it!"
23:43:56 <nornagon> heh.
23:44:00 <shachaf> goltrpoat: That's not Linux, that's OSX.
23:44:21 <eumenides> Pseudonym: in the same way i don't understand unlambda.
23:44:24 <goltrpoat> oh, sorry.  latched on to the ppc bit.
23:44:29 <fantasmaa> someone help me with my build error: http://hpaste.org/1491
23:45:01 <goltrpoat> pseudonym:  you don't like smalltalk?
23:45:39 <mwc> Gentoo has a PPC ebuild for 6.4.2... they must have a bootstrap compiler
23:45:41 <Pseudonym> I thin k it's dated.
23:46:42 <fantasmaa> @seen
23:46:44 <goltrpoat> well.. dated, sure, it had a lot of cool stuff in it though.
23:47:05 <goltrpoat> i was rather excited about strongtalk until i realized just how buggy the implementation was.
23:47:14 <Pseudonym> I don't think that adding numbers by passing messages to them is "cool".,
23:47:18 <dons> rubyruy: oh, that's good to know.
23:47:22 <Pseudonym> But yes, it had cool stuff.
23:47:33 <dons> rubyruy: so perhaps we shoudl recommend the wikibook more often?
23:47:46 <goltrpoat> well, most interesting languages are single-paradigm.
23:47:49 <rubyruy> for total newbs like me? yes
23:47:57 <goltrpoat> numbers are weird in smalltalk, IO is weird in haskell.  give and take.
23:47:57 <goltrpoat> heh
23:48:07 <rubyruy> i'd recommend yaht if they want something faster
23:48:14 <Pseudonym> Most useful languages are multi-paradigm.
23:48:15 <fantasmaa> dons: you're on openBSD right? ...where are the xorg development libraries?
23:48:30 <Pseudonym> And I think Haskell hides its IO weirdness very well with good syntax.
23:48:32 <kowey> the wikiboook still has some rough edges in the middle, probably more so than yaht
23:48:37 <dons> in the XF4 src
23:48:42 <dons> fantasmaa: its a seperate cvs module
23:48:54 <kowey> but i think our slower intro is helpful for some, and the advanced stuff by dmhouse and apfelmus is great
23:48:55 <rubyruy> hmmm what am i looking forward to?
23:49:00 <dons> or do you mean the compiled stuff, thatins /usr/X11R6/
23:49:08 <fantasmaa> dons: http://hpaste.org/1491
23:49:39 <dons> or , you might need to tweak the include path
23:49:41 <goltrpoat> pseudonym:  useful or used?  multi-paradigm languages attract more people for the obvious reasons.
23:49:53 <dons> or set CPPFLAGS and LDFLAGS to /usr/X11R6/include and /usr/X11R6/lib
23:49:54 <Pseudonym> Useful.
23:50:11 <Pseudonym> Multi-paradigm languages let you pick the tool that matches the problem best.
23:50:21 <fantasmaa> dons: thanks will try
23:50:33 <kowey> well, the 'Type declarations' module is a little dry, I think... and I believe that Elementary and Intermediate Haskell chapters could use a little more attention
23:50:43 <sorear> hello Pseudonym
23:50:46 <goltrpoat> sure, but single-paradigm languages tend to be able to apply mechanisms that takes advantage of not letting you pick every tool under the moon.
23:50:53 <monochrom> Multi-paradigm languages are hard to create.  First you need to unify three conflicting type systems...
23:51:01 <goltrpoat> takes=take
23:51:03 <kowey> rubyruy: we'd be happy to have your criticism and complaints, of course :-)
23:51:11 <sorear> Pseudonym: I was told to mention by BerkelyDB like project to you
23:51:17 <sorear> s/by/my
23:51:34 <rubyruy> heh we'll i'll be glad to leave comments on the talk pages then
23:51:38 <goltrpoat> pseudonym:  i mean, haskell is about as single-paradigm as it gets.
23:51:42 <rubyruy> nice to know it's being worked on
23:52:09 <kowey> well... to be honest, I personally will not be able to contribute much, just a little gardening here and there
23:52:39 <kowey> or when the urge just becomes overpowering, but we'd appreciate this kind of  thing being noted down somewhere so that somebody can be bold and go fix
23:52:54 <mwc> Uhm, isn't there supposed to be a way of bootstrapping ghc through the c files that are generated through -fvia-c?
23:53:09 <sorear> yes
23:53:54 <Pseudonym> G'day sorear.
23:53:54 * mwc whistles and executes ./configure --enable-hc-boot
23:54:00 <Pseudonym> sorear Oh?
23:54:09 <Pseudonym> goltrpoat: I disagree with that.
23:54:17 <sorear> you want this: http://hackage.haskell.org/trac/ghc/wiki/Building/Porting
23:54:19 <lambdabot> Title: Building/Porting - GHC - Trac
23:54:29 <goltrpoat> hmm?
23:54:34 <Pseudonym> Haskell even supports imperative programming!
23:54:47 <Pseudonym> It supports functional programming, dataflow programming, OO...
23:54:48 <goltrpoat> and c++ supports functional programming
23:54:49 <goltrpoat> point?
23:54:49 <goltrpoat> :)
23:55:00 <Pseudonym> And let's not forget generic programming.
23:55:06 <mwc> ST/IO is my favourite imperative language
23:55:06 <Pseudonym> Sure, C++ is multi-paradigm.
23:55:20 <Pseudonym> OO, generic, generative, imperative...
23:55:28 <Pseudonym> What's not multi-paradigm about it?
23:55:32 <mwc> C++ is multiparadigm in the same way a dog with 4 table legs nailed onto it is an octopus
23:55:49 <foxy-om> @remember
23:55:49 <lambdabot> Incorrect arguments to quote
23:56:06 <nornagon> @remember mwc C++ is multiparadigm in the same way a dog with 4 table legs nailed onto it is an octopus
23:56:06 <foxy-om> @remember mwc	C++ is multiparadigm in the same way a dog with 4 table legs nailed onto it is an octopus
23:56:06 <lambdabot> Done.
23:56:07 <lambdabot> Done.
23:56:11 <nornagon> oops.
23:56:13 <goltrpoat> you're blurring the line rather considerably there.  just because i can write in c++ whatever i can write in haskell, doesn't mean that c++ supports functional programming.
23:56:17 <nornagon> @quote mwc
23:56:17 <lambdabot> mwc says: I'm thinking we should file a bug report and require ghc to produce executables that sound like famous classical pieces
23:56:41 <sorear> Pseudonym: yes, apparently you've got some similar project.  my list of requirements is [STM transactions, lazy loading, incrementental checkpointing, good asymptotic performance].  I was
23:56:48 <sorear> <dons> sorear: if its like berkelydb, you definitely should talk to Pseudonym about it
23:56:56 <Pseudonym> sorear: Yes, we're working on a similar project.
23:57:01 <sorear> so, here I am ?
23:57:27 <Pseudonym> We're specifically concentrating on high concurrency with STM.
23:57:43 <Pseudonym> We're not thinking so much about transaction safety.
23:58:23 <goltrpoat> haskell "supports" impertive programming in the sense that, by a rather wild stroke of luck, operation sequencing happens to have a nice applicative representation.  i don't see how that makes haskell multi-paradigm.
23:58:39 <goltrpoat> imperative, rather
23:59:01 <sorear> ok, there's the difference.  I want transaction peace-of-mind, but I try to ignore constant factors as much as possible.
23:59:10 <Pseudonym> Right.
23:59:18 <Pseudonym> Still, it might be fun to collaborate.
23:59:28 <Pseudonym> Our application can afford to rebuild the index.
23:59:36 <sorear> alas, the requirement to support transactions is forcing my design to include most of a database.
