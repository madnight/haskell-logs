00:00:26 * ivanm would just like to get auctex to play nicely with haskell-mode using mmm-mode in emacs ;-)
00:00:29 <procyon112> dons: We're randomly backtracking...  is that close enough?
00:01:13 <dons> heh
00:01:38 <sorear> @pretty insert_ix 0 a lst = a : lst ; insert_ix (k + 1) a (l:ls) = l : insert_ix k a ls ; insert_rand a lst g1 = let (ix,g2) = randomR (0, length lst) g1 in (insert_ix ix a lst, g2) ; shuffle [] g1 = ([], g1) ; shuffle (x:xs) g1 = let (xs', g2) = shuffle xs g1 in insert_rand x xs' g2
00:01:39 <lambdabot> "Parse error in pattern" at column 81
00:02:52 <sorear> > let insert_ix 0 a lst = a : lst ; insert_ix (k + 1) a (l:ls) = l : insert_ix k a ls ; insert_rand a lst g1 = let (ix,g2) = randomR (0, length lst) g1 in (insert_ix ix a lst, g2) ; shuffle [] g1 = ([], g1) ; shuffle (x:xs) g1 = let (xs', g2) = shuffle xs g1 in insert_rand x xs' g2 in 0
00:02:53 <lambdabot>  Parse error in pattern
00:03:24 <sorear> > let { insert_ix 0 a lst = a : lst ; insert_ix (k + 1) a (l:ls) = l : insert_ix k a ls ; insert_rand a lst g1 = let { (ix,g2) = randomR (0, length lst) g1 } in (insert_ix ix a lst, g2) ; shuffle [] g1 = ([], g1) ; shuffle (x:xs) g1 = let { (xs', g2) = shuffle xs g1 } in insert_rand x xs' g2 } in 0
00:03:25 <lambdabot>  Parse error in pattern
00:03:40 <sorear> > let { insert_ix 0 a lst = a : lst ; insert_ix k a (l:ls) = l : insert_ix (k-1) a ls ; insert_rand a lst g1 = let { (ix,g2) = randomR (0, length lst) g1 } in (insert_ix ix a lst, g2) ; shuffle [] g1 = ([], g1) ; shuffle (x:xs) g1 = let { (xs', g2) = shuffle xs g1 } in insert_rand x xs' g2 } in 0
00:03:41 <lambdabot>  0
00:04:47 <procyon112> sorear++
00:10:26 <hpaste>  procyon112 annotated "Help with "amb" idiom" with "WooHoo!  Random Backtracking!" at http://hpaste.org/1247#a4
00:10:38 <procyon112> Got it!
00:11:02 <sorear> yay!
00:11:47 <procyon112> I can now, given a list of primitive functions, create a lazy list of all possible properly typed syntax trees of depth n in random order!
00:12:13 <sorear> hurray!
00:14:02 <procyon112> This makes not only GP goodness, but exhaustive search trivial!
00:14:37 <sorear> And because of laziness it is a depth first traversal, running in O(n) space!
00:15:42 <procyon112> My type checker is a bit slow though i think... Full trees of depth 8+ are pretty painful.. but they are 2**8 big too, so...
00:16:08 <sorear> 2^8 is only 256
00:16:29 <procyon112> er.. right.  so, I guess it's slow :)
00:17:46 <procyon112> I think I should be simplifying my unification constraints at some point.... not sure though.
00:21:32 <procyon112> A random tree of depth 8 that unifies to Int just gave me a unifier of 322 constraints.
00:23:31 <procyon112> depth2Tree where (expression,unifier) = (App (App (Prim "K") (Prim "Uno")) (App (Prim "Add") (Prim "Uno")),5,[(TVar 0,TInt :-> TInt),(TVar 3,TInt :-> TInt),(TVar 2,TInt),(TVar 1,TInt),(TVar 4,TInt)])
00:23:58 <procyon112> Doesn't look to bad at that depth ;)
00:25:18 <procyon112> But there are multiple variables pointing to the same type... is that supposed to happen?
00:26:00 <procyon112> It's "correct", but should the most general unifier be simpler?
00:26:56 <procyon112>  (App (App (Prim "K")
00:26:56 <procyon112> 	     (Prim "Uno")) (App (Prim "Add") (Prim "Uno"))
00:31:33 <LeCamarade> @who
00:31:34 <lambdabot> Maybe you meant: echo ghc show what wn
00:31:46 <LeCamarade> ?yow
00:31:47 <lambdabot> BI-BI-BI-BI-BI-BI-BI-BI-BI-BI-BI-BI-BI-BI-BI-BI-BI-BI-BI-BI-BI-BI-BI-BI-
00:31:51 <LeCamarade> ?yow
00:31:52 <lambdabot> UH-OH!!  We're out of AUTOMOBILE PARTS and RUBBER GOODS!
00:32:57 <sorear> FINALLY!
00:33:15 <dmwit> ?fortune
00:33:15 <lambdabot> I'm not an Iranian!!  I voted for Dianne Feinstein!!
00:33:23 <dmwit> ?fortune
00:33:24 <lambdabot> Yes, it is written.  Good shall always destroy evil.
00:33:24 <lambdabot> 		-- Sirah the Yang, "The Omega Glory", stardate unknown
00:33:25 <sorear> After a whole day of hacking GHC primops and micro-tuning address hackery - my first segfault!
00:33:38 <procyon112> hehe
00:33:52 <procyon112> night all.  Thanks sorear!
00:34:15 <sorear> Meanwhile, my first UNoptimized attempt at a C version (to compare against) faulted the very first time it was run.
01:14:39 <sorear> I begin to wonder how much of a difference there really is between languages, coloring-wise.
01:15:19 <sorear> HsColour does a perfectly acceptable job on GHC-Core, STG code, and (!) C--
01:16:28 <joelr1> good morning
01:18:00 <malcolmw> sorear: it's all in the lexing - most languages are similar in that respect (but consider e.g. primed identifiers)
01:19:09 <quicksilver> malcolmw: escape characters are the worst problem for attempts at language-independent lexing
01:19:13 <quicksilver> malcolmw: especially perl :)
01:19:34 <malcolmw> quicksilver: comments too
01:19:52 <quicksilver> malcolmw: *nod*, and the ability (or not) to escape comment characters inside commetns
01:19:57 <quicksilver> malcolmw: so really it's a similar issue
01:21:58 <joelr1> how do you type in a multi-line string in haskell?
01:22:47 <ski> foo = "bar\
01:22:53 <ski>       \baz"
01:23:36 <joelr1> ah!
01:24:00 <sorear> joelr1: note that if you are using CPP, it will eat the first backslash rendering your code invalid
01:24:05 <ski> (aka string gaps)
01:24:12 <joelr1> it's slowly coming back to me
01:24:15 <sorear> you can work around it by adding a space after the '\'
01:24:46 <sorear> but GNU cpp, in its infinite wisdom, accepts that syntax as an extension.
01:24:51 <quicksilver> I quite like this idiom:
01:24:59 <quicksilver> foo = concat
01:25:05 <quicksilver> ["bar",
01:25:10 <quicksilver>  "blah"
01:25:10 <quicksilver> ]
01:25:48 <quicksilver> it has the benefit that editor indentation and motion commands work  well with it (as well as CPP)
01:26:36 <quicksilver> (and you can adjust it trivially to insert newlines in, if that's what you want
01:26:45 <ski> > "a\ \b"
01:26:46 <lambdabot>  "ab"
01:27:13 <sorear> night all.
01:29:47 <joelr1> night?
01:29:55 <joelr1> where is it night right now?
01:29:56 <joelr1> :D
01:30:01 <quicksilver> in USAnia, it is...
01:30:15 <matthew-_> narnia?
01:30:34 <ski> nangiala !
01:31:21 <matthew-_> when is the next HWN coming out?
01:33:44 <LeCamarade> @time joelr1
01:33:45 <lambdabot> Local time for joelr1 is 2007-04-04 09:31:26 +0100
01:33:50 <LeCamarade> @time quicksilver
01:33:52 <lambdabot> Local time for quicksilver is Wed Apr  4 09:31:23 2007
01:34:07 <LeCamarade> @time ski
01:34:09 <lambdabot> Local time for ski is Wed Apr  4 10:32:31 2007
01:34:17 <joelr1> cool
01:34:33 <matthew-_> @time dons
01:34:36 <lambdabot> Local time for dons is Wed Apr  4 18:32:09 2007
01:34:54 <LeCamarade> @list
01:34:54 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
01:36:14 <LeCamarade> @seen dons
01:36:14 <lambdabot> dons is in #haskell, #haskell-overflow and #haskell-soc. I last heard dons speak 1h 35m ago.
01:36:19 <LeCamarade> @seen igloo
01:36:20 <lambdabot> igloo is in #haskell, #gentoo-haskell, #haskell-soc, #ghc, #darcs and #haskell.hac07. I last heard igloo speak 6h 14m 43s ago.
01:36:35 <LeCamarade> @seen Korollary
01:36:36 <lambdabot> Korollary is in #haskell, #haskell-blah and #haskell-overflow. I don't know when Korollary last spoke.
01:37:50 <LeCamarade> @src concat
01:37:51 <lambdabot> concat = foldr (++) []
01:39:22 <LeCamarade> let concat = foldl (++) [] in concat ["This", " and ", "that"]
01:39:36 <LeCamarade> let concat = foldr (++) [] in concat ["This", " and ", "that"]
01:40:46 <quicksilver> LeCamarade: if you want lambdabot to execute that, you need a leading '> '
01:40:58 <quicksilver> > let concat = foldl (++) [] in concat ["This", " and ","that"]
01:40:59 <lambdabot>  "This and that"
01:41:51 <LeCamarade> quicksilver: Damn. I forgot. putStrLn "Thanks"
01:42:22 <LeCamarade> Don't you guys wonder why it is not foldl in concat?
01:42:30 <quicksilver> LeCamarade: no, because we know why :)
01:42:31 <LeCamarade> I mean, same effect, no?
01:42:39 <quicksilver> yes, same effect
01:42:43 <quicksilver> but foldr is faster
01:43:05 <LeCamarade> @src foldl
01:43:06 <lambdabot> foldl f z xs = lgo z xs
01:43:06 <lambdabot>     where lgo z []     =  z
01:43:06 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
01:43:09 <LeCamarade> @src foldl
01:43:09 <lambdabot> foldl f z xs = lgo z xs
01:43:10 <lambdabot>     where lgo z []     =  z
01:43:10 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
01:43:28 <quicksilver> and, furthermore, foldr is a 'good' producer: this means that it can be run on infinite lists and produce output in finite time
01:43:29 <LeCamarade> @src foldr
01:43:30 <lambdabot> foldr k z xs = go xs
01:43:30 <lambdabot>     where go []     = z
01:43:30 <lambdabot>           go (y:ys) = y `k` go ys
01:44:09 <quicksilver> > concat (cycle ["this"," and"," that"," and "])
01:44:11 <lambdabot>  "this and that and this and that and this and that and this and that and thi...
01:44:27 <quicksilver> > foldl (++) [] (cycle ["this"," and"," that"," and "])
01:44:31 <lambdabot> Terminated
01:45:13 <LeCamarade> Hmm ...
01:45:16 <quicksilver> LeCamarade: in general, foldl needs to evaluate the entire input list before producing any output, whereas foldr can produce output as it goes
01:45:40 <LeCamarade> But I always thought of foldl as: ...
01:45:56 <quicksilver> LeCamarade: furthermore, in a lazy language, foldl builds up an ugly big thunk on the stack (unless the strictness analyzer manages to optimise that away)
01:47:03 <quicksilver> http://www.haskell.org/haskellwiki/Fold
01:47:04 <lambdabot> Title: Fold - HaskellWiki
01:47:17 <LeCamarade> Okay, reading that ...
01:49:21 <ivanm> Is it possible to use haskellcharts or some other graphing routine to produce a graph when using lhs2tex?
01:52:54 <LeCamarade> quicksilver: Oh! I always thought the foldl went *from the left*, rather than *to the left*.
01:53:01 <quicksilver> LeCamarade: :)
01:53:08 <LeCamarade> So, I figured, it should be more efficient.
01:53:13 <quicksilver> LeCamarade: there is a sense in which it goes from the left
01:53:21 <quicksilver> LeCamarade: but english is a bit ambiguous
01:54:02 <LeCamarade> For a while, actually, as you explained, I typed my heated response, and I realised we had the same reasons for supporting the opposite things. I was starting to wonder if this is Java.
01:54:24 <joelr1> is there any difference between daan leijen's pretty-printer and the hughes-pj one included with ghc?
01:54:48 <matthew-_> I always think about them in terms of where the brackets are. Foldl puts all the opening brackets on the far left, foldr puts all the closing brackets on the right.
01:59:07 <LeCamarade> @djinn
01:59:07 <lambdabot> Plugin `djinn' failed with: IRCRaised Data.ByteString.last: empty ByteString
01:59:34 <LeCamarade> @slap LeCamarade
01:59:34 <lambdabot> why on earth would I slap LeCamarade
02:00:19 <quicksilver> @djinn a->a
02:00:19 <lambdabot> f a = a
02:00:48 <quicksilver> @djinn (b->c)->a->b->(a,c)
02:00:48 <lambdabot> f a b c = (b, a c)
02:00:58 <matthew-_> mmm. So I must be being dumb
02:00:59 <eumenides> @djinn StateT Int IO ()
02:01:00 <lambdabot> -- f cannot be realized.
02:01:04 <matthew-_> > foldl (flip (||)) False (True : repeat False)
02:01:09 <lambdabot> Terminated
02:01:16 <matthew-_> >foldr (||) False (True : repeat False)
02:01:42 <quicksilver> > foldr (||) False (True : repeat False)
02:01:44 <lambdabot>  True
02:01:54 <LeCamarade> What's missing in lambdabot: @java_loving_boss_is_here
02:01:54 <matthew-_> right, so the flip isn't doing what I was thinking
02:02:54 <quicksilver> flipping a commutative function doesn't do much :)
02:03:15 <quicksilver> > foldr (flip(||)) False (True : repeat False)
02:03:16 <matthew-_> indeed.
02:03:17 <lambdabot>  Exception: stack overflow
02:03:30 <quicksilver> ah, but || isn't truly commutative it seems
02:03:36 <quicksilver> @src (||)
02:03:36 <lambdabot> True  || _ =  True
02:03:36 <lambdabot> False || x =  x
02:03:40 <matthew-_> indeed.
02:03:45 <matthew-_> left biased shortcut
02:04:32 <matthew-_> which is why foldr (||) False (True : repeat False) even works
02:13:43 <matthew-_> @pl foldr (maybe id (:)) [] [Nothing, Just 3, Nothing, Just 4, Just 0]
02:13:44 <lambdabot> foldr (maybe id (:)) [] [Nothing, Just 3, Nothing, Just 4, Just 0]
02:14:13 <matthew-_> mmm. I would assume there must be a library function or something to do this as it seems pretty common...
02:14:16 <matthew-_> > foldr (maybe id (:)) [] [Nothing, Just 3, Nothing, Just 4, Just 0]
02:14:18 <lambdabot>  [3,4,0]
02:17:13 <joelr1> is there a quick way to apply a function to every file in a directory tree?
02:18:06 <ivanm> tree map?
02:18:59 <quicksilver> ivanm: there isn't a function to return the directory as a tree, as far as I know ;)
02:19:07 <matthew-_> let f = \dir -> getDirectoryContents dir >>= mapM (\elem -> f elem >>= return . ((magic elem):))
02:19:14 <matthew-_> or something like that ;)
02:19:28 <ivanm> "to every file in a directory tree?" <-- thought it was in a tree already :s
02:19:39 <joelr1> matthew-_: thanks
02:22:00 <matthew-_> joelr1: that's wrong, but it's the sort of pattern I'd come up with. It's nothing special though - get the list, recurse (test for if it's a file or dir on recursion) and then apply your magic afterwards. That'll ensure it's depth first
02:39:40 <matthew-_> ivanm: I agree - there should be a library which just treats the filesystem as a tree and allows you to map or fold over it.
02:40:10 <ivanm> matthew-_: no, I thought you'd already imported the files as a tree... but yeah, a library that does that would be cool
02:40:47 <matthew-_> it'd have to be in the IO monad, but you could support both map/fold and mapM/foldM
02:40:52 <matthew-_> I don't think it'd be that hard
02:45:29 <ski> > catMaybes [Nothing, Just 3, Nothing, Just 4, Just 0]  -- matthew-_
02:45:31 <lambdabot>  [3,4,0]
02:45:40 <ski> @index catMaybes
02:45:41 <lambdabot> Data.Maybe
02:45:54 <matthew-_> ski! woot, thanks. slight delay there!
02:46:18 <matthew-_> ivanm: there doesn't seem to be anything like this in hackage including missingh
02:46:34 <ivanm> *shrug* wouldn't have a clue... write it! ;-)
02:46:50 <matthew-_> sure, I will do, but I don't want to replicate other ppl's work
02:48:32 <matthew-_> ski: strange, I was expecting something based on MonadPlus
02:48:52 <matthew-_> but I guess you'd be getting real close to the fold / filter implementation
02:49:09 <ski> @src catMaybes
02:49:10 <lambdabot> catMaybes ls = [x | Just x <- ls]
02:49:28 <matthew-_> yeah, exactly
03:15:01 <araujo> morning
03:23:05 <tup> using binary, "runGet getWord8 L.empty" and "runGet getWordhost L.empty" segfault. is this a bug or am i doing something wrong?
03:23:56 <dons> hmm.
03:24:16 <dons> well, it should really through an exception, iirc.
03:25:39 <fasta> Somewhere, somehow I evaluate undefined, while I believe that shouldn't happen. Most likely, I am wrong, but I can't find the location. What's the easiest way to find out the actual location of the problem? (I know what undefined value is getting evaluated, I just don't understand what is forcing it).
03:26:15 <tup> yeah, functions using readN throw exception, but those calling getPtr segfault.
03:26:18 <dons> find all your undefineds first, and replace them with: error "this line"
03:26:22 <ivanm> dons: would you have any idea which way would the be best to automatically generate a graph using lhs2tex?
03:26:39 <fasta> dons: I know that already
03:26:57 <fasta> dons: I just don't know the series of steps leading to the evaluation of (error "here is it")
03:27:03 <dons> fasta: possibly profiling will reveal what function was on top of the call stack
03:27:08 <dons> when the error occured.
03:27:12 <dons> ivanm: nope.
03:27:20 <ivanm> k, thanks anyway
03:27:27 <fasta> dons: Ok, I will see whether that helps.
03:28:46 <Cale> The -xc RTS option will give you a cost-centre stack trace
03:29:54 <Cale> fasta: If you use undefined explicitly in your code, you can also replace instances of it with calls to error.
03:30:09 <fasta> Cale: yes, I already learned that lesson.
03:31:08 <fasta> Cale: I am adding a vertex to a graph with an undefined label (i.e. (error "This node has no label")) then I get all the vertices in the graph, but this shouldn't evaluate the labels, but it is evaluating it somehow.
03:32:04 <Cale> hmm
03:32:22 <Cale> Is it possible that there's a comparison on labels somewhere?
03:33:11 <Cale> (maybe even while building the graph)
03:33:28 <fasta> Cale: the most likely cause is that for debugging purposes I am evaluating it somewhere.
03:33:48 <fasta> Cale: I don't use comparisons (at least not that I am aware of)
03:34:00 <fasta> Still compiling....
03:34:28 <fasta> (with optimizations off, that is)
03:37:11 <fasta> This is the stack trace: test_add_vertex_undefined,Foo.Test.CAF>Main: foobar
03:37:22 <fasta> A.k.a. completely useless.
03:37:30 <dons> did you use -prof -auto-all ?
03:38:28 <fasta> dons: Uhm, I removed that some time ago. I will try with :)
03:38:38 <dons> that might help.
03:38:45 <dons> otherwise you get no useful info from -prof
03:39:06 <fasta> dons: Hmm, no, it is enabled.
03:39:39 <dons> test_add_vertex_undefined looks useful, what does that point at ?
03:40:31 <fasta> dons: It is the test case adding a vertex with label (error "this should not be evaluated")
03:40:46 <fasta> dons: (and then gets all the vertices in the graph)
03:40:56 <fasta> dons: So, it shouldn't evaluate the label
03:41:00 <dons> then something somewhere down from  main forces it, eh?
03:41:53 <fasta> dons: I am sure it's a function called "to_directed" that is the problem, but GHC doesn't tell me that in any way.
03:42:03 <fasta> dons: that gets called from test_add_vertex_undefined
03:42:35 <fasta> dons: I think that copies the undefined value, but that shouldn't be a problem, right?
03:43:12 <fasta> dons: i.e. it should be a lazy value
03:43:50 <fasta> dons: test a = snd $ (a, 2) -- AFAIK, this is the same. test undefined
03:44:19 <ivanm> I'm trying to bludgeon my way through the lhs2tex guide, but some parts of it don't make sense
03:44:30 <ivanm> anyone familiar with it?
03:47:20 <stefanha> I would like to generate a histogram for a dataset.  The dataset is [Double] in a closed range [0, 255].  The histogram would be [Int] of length 256.  Any ideas on how to do this efficiently?  I feel it should be doable in linear time, eg. using a foldl over the dataset.  But how do I increment a frequency in O(1)?
03:47:38 <fasta> stefanha: Introduction to Algorithms covers that
03:48:03 <fasta> stefanha: the closed range implies O(1), btw
03:48:25 <dons> using buckets, i'd imagine?
03:48:57 <stefanha> Strictly speaking, yes.  But I mean in very few (1?) instructions like you would expect from C arrays.
03:49:10 <fasta> stefanha: well, Haskell has arrays.
03:49:17 <dons> well, either a mutable array, or a Data.IntMap (O(log n) update)
03:49:55 * fasta knows lots of peoples who still believe that Haskell doesn't have mutable arrays. 
03:49:59 <stefanha> Ah, so do mutable arrays support in-place update?
03:50:00 <dons> for bytes, we use this to implement bucket sort in data.bytestring
03:50:02 <dons> countOccurrences :: (Storable a, Num a) => Ptr a -> Ptr Word8 -> Int -> IO ()
03:50:02 <dons> STRICT3(countOccurrences)
03:50:02 <dons> countOccurrences counts str l = go 0
03:50:02 <dons>  where
03:50:04 <dons>     STRICT1(go)
03:50:07 <dons>     go i | i == l    = return ()
03:50:09 <dons>          | otherwise = do k <- fromIntegral `fmap` peekElemOff str i
03:50:12 <dons>                           x <- peekElemOff counts k
03:50:15 <dons>                           pokeElemOff counts k (x + 1)
03:50:17 <dons>                           go (i + 1)
03:50:20 <dons> given a ptr to a mutable buffer of size N
03:50:22 <dons> but you can just use a mutable array
03:50:27 <dons> or Data.Map might be fine anyway
03:50:31 <fasta> Show off ;)
03:50:48 <stefanha> Cool, thanks.
03:51:05 <fasta> stefanha: DiffArray is easiest to use
03:53:18 <beelsebob> yay, why would I want 6th order functions?
03:53:56 <dcoutts> to show off?
03:53:59 <dons> to break a compiler?
03:54:12 <dons> to do some generics?
03:54:15 <dcoutts> to confuse yourself and others?
03:54:43 <dcoutts> to obfuscate?
03:54:57 <dcoutts> beelsebob: come on tell! us tell us!
03:55:03 <dcoutts> or do we have to keep guessing?
03:55:19 <dons> i bet generic data traversal.
03:55:29 <dons> or else, as a benchmark
03:55:33 <fasta> What option do I need to add to use the GHC break point stuff? It might help in this case, although I don't expect it to.
03:55:41 <Cale> @type callCC
03:55:44 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
03:56:43 <dons> @type Data.Generic.Basics.gunfold
03:56:46 <lambdabot> Couldn't find qualified module.
03:56:48 <ivanm> for lhs2tex, how do I put boxes around all my code?
03:56:49 <dons> @type Data.Generics.Basics.gunfold
03:56:52 <lambdabot> forall (c :: * -> *) a. (Data a) => (forall b r. (Data b) => c (b -> r) -> c r) -> (forall r. r -> c r) -> Constr -> c a
03:58:04 <dons> its time like this I suspect Data.Generics was written just to test the type checker
03:58:36 * dons type runhaskell Setup.hs configure to build an autoconf'd C program
03:58:45 <dons> haskell eats my brain
04:00:40 <Cale> http://f8d.org/?c=44
04:00:43 <lambdabot> Title: Moments
04:10:20 <fasta> What does this mean? *** Exception: No match in record selector Var.tcTyVarDetails
04:10:29 <fasta> A bug in the debugger?
04:21:31 <Cheery> @djinn ((t -> Maybe a -> t1) -> t -> t1) -> ((t -> Maybe a -> t1) -> t -> t1) -> ((t -> Maybe a -> t1) -> t -> t1)
04:21:32 <lambdabot> f a b c d =
04:21:32 <lambdabot>     a (\ _ e ->
04:21:32 <lambdabot>        case e of
04:21:32 <lambdabot>        Nothing -> b (\ _ f ->
04:21:32 <lambdabot>                      case f of
04:21:34 <lambdabot>                      Nothing -> c d Nothing
04:21:36 <lambdabot>                      Just g -> c d (Just g)) d
04:21:38 <lambdabot>        Just h -> c d (Just h)) d
04:21:42 <dons> hehe
04:22:46 <fridim> I didn't find it in the FAQ. Why an object oriented haskell (o'haskell for instance) didn't worked as Ocaml has worked for caml ? I mean is OOP really not needed ?
04:23:14 <Cheery> dons: my stylesheet stuff reduced to this form:
04:23:16 <Cheery> background (color 255 255 0 . image "foobar.png" . fixed)
04:23:29 <Cheery> now I'm wondering which would be the best way to implement it. :)
04:24:04 <mr_tenor> fridim: what is lacking in the language?
04:24:06 <Cheery> I think the color, image, fixed, etc. -stuff should be just functions, not methods
04:24:44 <Cheery> but then, what kind of beast should be created then?
04:25:07 <Cheery> and should I forget about using the function composition?
04:28:14 <fridim> mr_tenor: I don't know haskell, I'am just asking
04:29:03 <dons> fridim: yeah, the O caml part is just buzz, no one uses it.
04:29:17 <dons> and similarly, OO just leads to ugly code in haskell too
04:29:28 <mr_tenor> fridim: i'm still a haskell n00b, but i find the type system better than, say, c++ and java
04:29:43 <mr_tenor> i can't find anything i miss from C++
04:30:34 <ivanm> does anyone know how I can automatically get frames put around my code blocks using lhs2tex?
04:30:35 <mr_tenor> "Are you quite sure that all those bells and whistles, all those wonderful facilities of your so called powerful programming languages, belong to the solution set rather than the problem set?" (Edsger Dijkstra)
04:30:59 <fridim> dons: may I ask why?
04:31:45 <dons> fridim: just seems to be unnecessary, most of the OO stuff. also objects, being stateful, mutable, combinations of typeclasses and existentials are just unnecessary, when we can use existentials or typeclasses directly
04:31:49 <dons> without state
04:34:32 <Cheery> hah! solved it. :)
04:35:24 <Cheery> class Mutant mutant mutator where mutate :: mutant -> mutator -> mutant
04:36:00 <fridim> ok, I have to go, thanks
04:36:24 * Cale figures out why all the comments on YouTube videos are so stupid.
04:36:36 <Cale> YouTube limits comments to 500 characters.
04:37:00 <Cheery> data Foo = Foo ; data Bar = Bar
04:37:44 <Cheery> oh well, I guess I change the order in the base class, to make it more nice
04:37:56 <Cheery> foo mutant = mutator mutant Foo
04:38:25 <Cheery> class Mutant m g where mutate :: g -> m -> m
04:38:35 <Cheery> erm, yet once more
04:38:37 <Cale> This means that any review which is much longer than "THIS IS AWESOME!!!11" is likely to need editing down to an irritating degree, eventually driving away anyone who would want to comment intelligently.
04:38:53 <Cheery> class Mutant m g where mutator :: g -> m -> m
04:39:01 <Cheery> foo = mutator Foo
04:39:08 <Cheery> bar = mutator Bar
04:39:23 <Cheery> base_mutant (foo . bar)
04:39:43 <Cheery> :P
04:39:46 <Cheery> problem solved!
04:40:02 <TSC> What's the nicest way to do something like "words", but using a separator other than whitespace?
04:40:52 <dons> concat (intersperse ":" ["a","b","c"])
04:40:59 <dons> > concat (intersperse ":" ["a","b","c"])
04:41:01 <lambdabot>  "a:b:c"
04:41:08 <TSC> Isn't that unwords?
04:41:10 <dons> oh, that's unwords
04:41:13 <TSC> (:
04:41:15 <dons> yeah, you want a 'split'
04:41:34 <dons> its not in the standard libs, but you can roll your own (or grab one of the many implemented out there, check the mailing list archives or google)
04:41:38 <dons> lambdabot has one.
04:41:47 <TSC> Ah, that will do
04:41:50 <TSC> @where lambdabot
04:41:50 <lambdabot> Right here! Seriously, though: http://www.cse.unsw.edu.au/~dons/lambdabot.html
04:41:58 <TSC> Thanks
04:42:21 <mightybyte> TSC: Text.Regex.splitRegex
04:43:02 <TSC> Ah, I should have looked at the bottom of Text.Regex's documentation
04:43:09 <TSC> Thanks to you too (:
04:43:15 <mightybyte> No problem
04:43:32 <mightybyte> I used it for the first time yesterday, so it was fresh on my mind. :)
04:45:20 <TSC> This is the first time I've used the regex package seriously
04:45:25 <TSC> It seems easy
04:46:03 <SamB_XP> it probably *is* easy ;-)
04:50:42 <mightybyte> TSC: http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/ is a nice little tutorial showing some of the possibilities.
04:50:45 <lambdabot> Title: teideal glic deisbh√©alach ª Blog Archive ª A Haskell regular expression tutoria ..., http://tinyurl.com/2xtgpw
04:51:18 <TSC> Thanks
04:55:15 <fasta> Is there a way I can call something which might throw an exception and when it doesn't throw one return True?
04:55:34 <fasta> (Or do a similar thing with quickcheck)
04:59:52 <fasta> Oh, I see it already works "out of the box". Nice
05:01:04 * ivanm wonders if anyone at all uses lhs2tex
05:02:51 <fasta> ivanm: IRC is not the best medium for this question.
05:03:02 <ivanm> fasta: then what is?
05:03:12 <fasta> ivanm: mailing list or when you are really really sure you RTFM, the author
05:03:27 <ivanm> well, I need to know _tonight_, and the author is unavailable
05:03:37 <fasta> ivanm: lots of users are academic users, and most don't use IRC.
05:04:12 <ivanm> well, as I said, I kind of need to know now (I left the actual writing up of my assignment to the last minute)
05:04:25 <ivanm> and AFAIK, IRC is the only instant response medium
05:04:49 <lypanov> unless you are part of a netsplit
05:05:01 <fasta> ivanm: I only am able to create a simple "hello world" example, as I didn't experiment more with it.
05:05:11 <ivanm> fair enough
05:05:14 <fasta> ivanm: So, it's very unlikely I can help. Good luck
05:05:35 <ivanm> its just that I've seen examples where they have boxes around them (e.g. http://darcs.brianweb.net/sudoku/src/Sudoku.lhs), but I can't work out how
05:05:42 <ivanm> unless that's an old version :s
05:06:50 <fasta> ivanm: So, it's just a layout thing you are after? I think that's done with a style file.
05:07:02 <ivanm> ahhh, OK
05:07:12 <fasta> ivanm: There probably is some hook where you can do your own custom Tex
05:07:16 <fasta> er TeX
05:07:21 <ivanm> k, thanks
05:09:13 <hpaste>  MathematicalOrc pasted "Another cryptic compiler error" at http://hpaste.org/1250
05:10:46 <fasta> Cryptic is in the eye of the beholder.
05:11:26 <fasta> It says that in column 18 of line 15 there is an error.
05:11:41 <fasta> It also says that Coord is not an instance of Num
05:11:56 <fasta> It also says that it is saying that because you use the literal value 0
05:19:30 <dhart> jhj
05:20:10 <quicksilver> fasta: I don't think MathematicOrc is IRCing at the moment
05:20:21 <quicksilver> fasta: I did know his IRC nickname once, but I've forgotten it :)
05:23:21 <fasta> quicksilver: I assumed it was someone who wanted to be somewhat anonymous.
05:23:29 <Cheery> Has anybody implemented database in lambda calculus?
05:23:45 <Cheery> like, relational database or such
05:23:58 <fasta> Cheery: You can't in lambda calculus
05:24:17 <fasta> Cheery: just like you can't do it on a Turing machine.
05:24:24 <fasta> Cheery: next question
05:24:35 <Cheery> you'd know the next question
05:24:37 <fasta> (well, in memory data base can)
05:24:37 <Cheery> why?
05:25:05 <fasta> There's no notion of I/O in those formalisms.
05:25:29 <Cheery> ok, can one do something closely related to database?
05:25:43 <fasta> Cheery: yes, there are bindings for various data bases.
05:25:58 <fasta> Cheery: it would help if you first tried to ask a real question
05:26:29 <fasta> Cheery: or google haskell data base bindings
05:26:36 <Cheery> what am I wondering is that could one make a such data structure in lambda calculus that it'd self-optimize itself to the best possible choice?
05:27:32 <earthy> nope
05:27:46 <earthy> 'best possible choice' is an ill-defined term
05:28:34 <fasta> Cheery: a data structure holding what exactly? What data structure?
05:28:53 <quicksilver> I suspect Cheery is thinking of 'automatic' query optimisation
05:28:59 <Cheery> ie. it wouldn't be queue, list, or map, but it'd be able to do similar things to those. Difference would be that when it'd be reduced, it'd drop in functionality
05:29:14 <fasta> Cheery: if you truly have an interesting question, write it up and turn into a PDF, then I will read it.
05:29:15 <quicksilver> using, e.g., lazy evaluation semantics and alegbraic rules to 'automatically' optimise
05:29:30 <quicksilver> I think the answer is that you can get some short way down that road easily enough
05:29:48 <quicksilver> there lie some problems further down though; some are interesting, and some are NP-complete :)
05:43:21 * lypanov wonders what this lambda calculus thing that everyone is talking about is
05:45:04 <Ulfalizer> http://www.youtube.com/watch?v=FZFG5PKw504
05:45:20 <lypanov> hehe
05:47:43 <Codex_> lypanov: you want good introduction to lambda calculus?
05:49:00 <Codex_> lypanov: read this: folli.loria.fr/cds/1999/library/pdf/curry-howard.pdf (should use LOTS of time for it, like a year or two.)
05:51:34 <jacobian> thats a great book
05:52:29 <jacobian> This one is good too: http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
05:52:31 <lambdabot> Title: Type Theory and Functional Programming
05:53:32 <dylan> @where xmonad
05:53:33 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
05:58:10 <dons> dylan: so we do tiling now, (really well, imo). you using xmonad yet?
05:58:31 * ivanm is trying to get lhs2tex to print multiple lines when doing eval
05:58:42 <dons> ivanm: you could talk to kosmikus, he's the author
05:58:48 <dons> @seen kosmikus
05:58:49 <lambdabot> kosmikus is in #gentoo-haskell, #haskell and #darcs. I last heard kosmikus speak 15h 37m 52s ago.
05:59:00 <ivanm> Yeah, he's not here :(
05:59:09 <ivanm> kolmodin says he's in Chicago
05:59:25 <quicksilver> ah, the dreaded Kobal
05:59:35 <ivanm> I might have to evaluate it manually and then paste the results in :(
05:59:37 <quicksilver> a secret society formed of haskell hackers whose names begin with 'Ko'
05:59:42 <ivanm> lol
06:00:01 <ivanm> I count 4
06:00:37 <dylan> dons: not yet, I'm looking to implement grid mode in it and then I might be able to use it
06:01:01 <dylan> I'm getting tired of all the depressed people in #dwm
06:02:47 <dons> what's the difference between grid mode and the tiled ones we have?
06:02:55 <dons> you tile the entire screen into squares?
06:03:11 * dons things adding new tiling methods should be pretty easy
06:03:47 <dons> re. depressed dwm, what do you expect, they use C, so everythings tedious, error prone and sad
06:05:32 <hpaste>  stefanha pasted "histogram using foldl and DiffUArray = stack overflow" at http://hpaste.org/1251
06:06:11 <quicksilver> stefanha: use foldr?
06:06:23 <mauke> what happens if you use foldl' instead?
06:06:42 <dylan> dons: for two windows, it's like NMASTER = 2
06:07:01 <dylan> dons: for 3 or four windows, it's devided into four sqaures
06:07:09 <stefanha> foldr does the same.
06:07:28 <dylan> for 5 or 6 windows, it looks like ###\n###
06:07:40 <dylan> for 7 to 9 windows, it looks like the brady bunch thing.
06:09:38 <stefanha> foldl' all the way :)  Thanks guys, I was trying to make it strict using seq or ! or something, but didn't succeed.
06:11:02 <mauke> foldl' is my friend
06:21:18 <quicksilver> dylan: brady bunch thing?
06:21:37 <phoniq> now the theme to the brady bunch is stuck in my head
06:24:29 <dylan> quicksilver: 9 windows tiled like ###\n###\n### like the brady bunch squares
06:30:59 <quicksilver> dylan: what about 7 and 8?
06:31:22 <hpaste>  anonymous pasted "Reading input until happy" at http://hpaste.org/1252
06:37:37 <dylan> quicksilver: then you have some empty squares
06:40:00 <ivanm> are Ratio Int values instances of Fractional?
06:40:21 <nornagon> @instances Ratio Int
06:40:22 <lambdabot> Couldn't find class `Ratio Int'. Try @instances-importing
06:40:28 <nornagon> @instances Fractional
06:40:29 <lambdabot> Double, Float
06:40:39 <nornagon> apparently not.
06:40:39 <ivanm> oh, OK
06:41:04 <ivanm> @instances Ratio
06:41:06 <lambdabot> Couldn't find class `Ratio'. Try @instances-importing
06:42:01 <ivanm> (fromIntegral (1%2 :: Ratio Int)) :: Double
06:42:07 <ivanm> > (fromIntegral (1%2 :: Ratio Int)) :: Double
06:42:09 <lambdabot>        add an instance declaration for (Integral (Ratio Int))
06:42:09 <lambdabot>     In the expr...
06:42:19 <ivanm> @type 1%2
06:42:22 <lambdabot> forall t. (Integral t) => Ratio t
06:42:41 <ivanm> @doc Ratio
06:42:41 <lambdabot> Ratio not available
06:42:43 <mauke> @hoogle Ratio t -> Double
06:42:44 <lambdabot> No matches, try a more general search
06:42:50 <ivanm> @hoogle Ratio
06:42:51 <lambdabot> Data.Ratio :: module
06:42:51 <lambdabot> Ratio :: module
06:42:51 <lambdabot> Data.Ratio.Ratio :: data Ratio a
06:43:48 <ivanm> Ratio only has functions to import, not export :(
06:43:55 <mauke> @type liftM2 (/) (fromIntegral . numerator) (fromIntegral . denominator)
06:43:57 <dhart> I have a problem in a class deriving from Show. In the the show class I return a string cointaining some '\n' characters. But in WinHugs they don't appear as newlines but as "\n" characters.
06:43:58 <lambdabot> forall b a. (Fractional b, Integral a) => Ratio a -> b
06:44:02 <ivanm> oh well, I'll stick with my division function
06:44:05 <dhart> Any idea what could be wrong?
06:44:12 <ivanm> thanks anyway
06:44:37 <mauke> > liftM2 (/) (fromIntegral . numerator) (fromIntegral . denominator) $ 1%2
06:44:39 <lambdabot>  0.5
07:01:44 <joelr1> dons: ping
07:16:50 <joelr1> .
07:17:25 <caust1c> klapmuetz kommt aus ulm? :o
07:17:49 <caust1c> argh, wrong chan
07:17:51 <caust1c> sry mates ;D
07:19:27 <Botje> dhart: if you're still here: windows uses \r\n to terminate lines, instead of \n
07:19:54 <Botje> although haskell _SHOULD_ substitute the right line ending :/
07:20:37 <glguy> it should replace \n with \r\n in string literals?
07:21:29 <glguy> (I'm just trying to figure out what you are suggesting so I can properly disagree with you ;)
07:21:37 <dhart> I have done more testing and I've seen it works fine if I feed the show result in the "putStr" function. I just thought thwt WinHugs would automatically feed it in that function...
07:22:05 <Saizan> it probably uses print, which is putStr . show
07:22:27 <joelr1> folks, how do you define a quickcheck arbitrary for data Foo = V SomeType | A | B | C?
07:22:43 <joelr1> would elements [ V . arbitrary, A, B, C] work here?
07:22:48 <Saizan> double escape + single unescape == single escaped string
07:22:58 <dhart> It doesnt because I get different results in WinHugs when I type: "putStr $ show $ myData" and "show $ myData"
07:23:54 <glguy> dhart: does show myData do the same thing as: print (show myData)?
07:31:32 <glguy> WinHugs is adding an implicit print to expressions that are not in the IO monad
07:33:36 <fasta> <no location info>: file name does not match module name `Main' <- ever had this before?
07:33:56 <glguy> Visual Haskell?
07:35:11 <fasta> No, just ghci-6.6
07:36:40 <joelr1> any quickcheck experts online?
07:37:17 <Igloo> fasta: You've not put "module Foo where" at the top of Foo.hs
07:39:01 <fasta> Igloo: I have put module Main where .... at the top of a file called Main.hs in the top-level of the directory my project is holding.
07:39:51 <Igloo> fasta: It's a different file that's causing the problem
07:39:58 <Igloo> Newer GHCs would tell you which one
07:40:16 <fasta> Igloo: Ok, nice. How new?
07:40:25 <Igloo> 6.6 branch or HEAD
07:40:47 <fasta> Igloo: is there some policy for HEAD that says that it always should build?
07:41:01 <Igloo> HEAD doesn't always build
07:41:05 <fasta> Igloo: since often when I try to build HEAD it doesn't.
07:41:10 <glguy> looks at Igloo walking around with his gun on his hip
07:41:12 <glguy> ;)
07:42:20 <fasta> Igloo: e.g. now, it doesn't build from HEAD
07:42:22 <glguy> ?where stats
07:42:23 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
07:42:35 * glguy built the 20070402 snapshot successfully
07:43:37 <fasta> and everytime I install a different ghc, I need to rebuild all the installed libraries again by hand...
07:44:14 <Igloo> You should use cabal-install, or provide patches if it doesn't meet your needs
07:45:00 <fasta> I only have cabal-setup on my system
07:45:49 <Saizan> to have cabal-install i need to build the cabal package separately?
07:46:45 <roconnor> Anyone have a reference where the strong monad laws are written in equational form?
07:47:00 <fasta> There's a new darcs repo as I just found out.
07:47:24 <quicksilver> roconnor: Moggi, Monads for Computation, or whatever that paper is called
07:48:17 <roconnor> quicksilver: that seems to only have it written in diagram form
07:48:59 <sorear> .
07:56:13 <dhart> anybody here has some experience with HOpenGL?
07:56:21 <sorear> yes
07:56:28 <ToRA> yup
07:57:29 <sorear> unfortunatly, an X.org bug (which was filed five years ago) causes OpenGL-anything to be next to useless for me *whine* *whine*
07:58:31 <MarcWeber> sorear: Then it's not that easy to fix, is it? Or would your problem be distributing a fixed Xorg with your applications? ;(
07:59:05 <dhart> Mu simple HOpenGL application seems to have problems closing correctly. Is there some special exit function I should call?
07:59:47 <quicksilver> roconnor: it's not hard to translate diagrams to equations, though
08:00:25 <ToRA> dhart: i've always used exitWith ExitSuccess out of System.Exit
08:00:35 <sorear> MarcWeber: The bug only shows up if you do NOT have 3d hardware ... which makes me almost unique :(
08:01:10 <lypanov> Codex_: thx for the link!
08:04:13 <dylan> sorear: can I call update and getEvent in two different threads for vty?
08:04:51 <dhart> ToRA: I don't seem to find an Esc key in the Key datastruture of HOpenGL, nor in the SpecialKey strucutre...
08:05:11 <ToRA> '\ESC'
08:05:15 <ToRA> > '\ESC'
08:05:16 <lambdabot>  '\ESC'
08:05:33 <ToRA> is the char escape code
08:05:41 * sorear checks
08:05:42 <dhart> thx a bunch
08:05:53 <ToRA> np
08:06:12 <sorear> yes, should be safe
08:06:27 <dylan> Sweet.
08:23:00 <sorear> @uptime
08:23:01 <lambdabot> uptime: 10m 15s, longest uptime: 5d 3h 40m 45s
08:23:09 <sorear> @let x = 2
08:23:12 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
08:23:27 <roconnor> moggi writes the strong monad laws in equational form in ``computational lambda-calculus and monads''
08:25:00 <MarcWeber> sorear: Me too.  I have but I have no driver ;)
08:47:40 * beelsebob pokes dons and dcoutts 
08:47:53 <beelsebob> sry, didn't mean to leave you hanging like that
08:48:57 * LPhas is reading Haskell Hacking on dons' blog and is finding it very cool
08:49:45 <sorear> You may need to poke them a LOT harder, they normally wake up about 6h from now (I'll assume they usually sleep more than that)
08:50:04 <beelsebob> well, they were up about 4 hours ago
08:50:07 <beelsebob> (when I went out)
08:50:08 <beelsebob> :P
08:50:38 <LPhas> does dons sleep? O_O
08:50:58 <beelsebob> I don't think so
08:55:28 <dmwit> Anybody here use gtk2hs?
08:57:44 <sorear> probably, it's more or less the standard haskell GUI lib
08:57:47 <dhart> I have a problem passing around a global State around my Haskell program, what would be the best way of doing this?
08:58:23 <bringert> wtf is this about? http://www.haskell.org/pipermail/haskell/2007-April/019317.html
08:58:24 <sorear> why do you want global state?
08:58:25 <lambdabot> Title: [Haskell] Re: The real Warm, fuzzy thing Transformer
08:58:39 <bringert> is he trolling?
08:59:16 <dhart> I am writing a game for my Master thesis in haskell and I need to keep a global state of the world.
08:59:26 <opqdonut> bringert: Monads scare people, thus we rename them!
08:59:49 <bringert> opqdonut: I got that part. It's the weird reply I don't get.
09:00:05 <opqdonut> ah
09:00:07 <sorear> dhart: The best way is to re-re-think your program.  after you are sure you actually need global state, state monads help to avoid bugs, since it's impossible with them to accidentally duplicate or destroy worlds.
09:00:12 <sorear> @src State
09:00:13 <lambdabot> Source not found. Take a stress pill and think things over.
09:00:21 <sorear> @slap src
09:00:22 * lambdabot beats up src
09:00:30 <sorear> @docs Control.Monad.State
09:00:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
09:01:54 <alexj> if we wanted to rename monads to something more friendly in the real world, why not use the word "procedure"
09:01:55 <dylan> sorear: hmm, isn't imgWidth supposed to be exported from Graphics.Vty indirectly from Graphics.Vty.Types?
09:02:19 <alexj> a procedure is a sequenced set of actions that produce a value.
09:02:21 <dhart> sorear: I don't mind rethinking my program, because the simple thought of global state in Haskell makes me cringe, but I dont see another way around it when working with a static game world.
09:03:20 <dylan> the Reader monad, if it's static. :)
09:04:02 <dhart> dylan: so many monads, my head is going to burst! by static, I dont mean readonly, I just mean static as in global
09:04:03 <sorear> dhart: If your program's interface is externally stateful (do monsters move? etc) usually the best way to mode it is internal state.
09:04:26 <sorear> s/mode/model
09:04:56 <sorear> dylan: yes
09:05:02 <dhart> sorear: I do not really understand your last statement, could you be more explicit?
09:05:23 <dylan> sorear: well, how can I access it?
09:05:54 <sorear> dhart: one wants to make a program as specification-like as possible.  if the specification uses state and update rules, then the program should too.
09:06:48 <dylan> sorear: btw, the darcs version of vty 3 doesn't seem to export the Event type
09:06:50 <dhart> sorear: Therefore you are recommending the State Monad?
09:07:21 <sorear> dhart: yes.
09:07:37 <sorear> dylan: you mean it doesn't export imgWidth/imgHeight at all?
09:08:33 <hpaste>  beelsebob pasted "Removing list comprehensions" at http://hpaste.org/1253
09:08:42 * beelsebob pokes people with that
09:08:57 <beelsebob> Any nice ideas on how else you might remove list comprehensions from that?
09:09:15 <beelsebob> my supervisor mumbled about concatMap, but I don't see how it applies in that situation
09:09:38 * beelsebob notes his version is silly
09:10:12 <hpaste>  beelsebob annotated "Removing list comprehensions" with "fix v1" at http://hpaste.org/1253#a1
09:10:53 <dylan> sorear: darcs-head does, the last vty-3.0 tag doesn't have imgWidth.
09:11:05 <dylan> sorear: but darcs-head doesn't seem to export Event
09:11:31 <sorear> beelsebob: p <*> q = join (p `ap` q)
09:11:52 <sorear> beelsebob: as long as you remember to use newtypes and define a monad :)
09:11:54 <beelsebob> sorear: attempting to avoid monads
09:12:02 <Igloo> beelsebob: Why do you want to?
09:12:05 <beelsebob> because this is an example for the paper
09:12:13 <Igloo> (avoid list comprehensions, that is)
09:12:13 <beelsebob> and we don't want to confuse it with adding monads to it
09:12:28 <beelsebob> Igloo: because it's interesting to do the transformation and see how the example comes out
09:12:51 <sorear> beelsebob: the Report defines listcomps in terms of concatMap
09:13:04 <Igloo> I don't think you will get anything clearer than a list comprehension for that
09:13:08 <beelsebob> oh? *goes and looks*
09:13:22 <beelsebob> Igloo: sure, nice too look though
09:13:41 <Igloo> beelsebob: Do you mean to return (f a, rr) BTW?
09:13:50 <beelsebob> Igloo: I did wonder that
09:14:04 <beelsebob> I was just fiddling with what my supervisor definde
09:14:10 <hpaste>  sorear annotated "Removing list comprehensions" with "with concatMap and Map" at http://hpaste.org/1253#a2
09:15:09 <dhart> sorear: In the State monad, what is the "return value a" in "State s a"....
09:15:13 <sorear> beelsebob: is <*> supposed to be liftM2 (,) ?
09:15:35 <sorear> dhart: it's for composing actions
09:15:55 <beelsebob> sorear: it's supposed to be concatinating two parsers
09:16:08 <sorear> dhart: imagine an action which takes one step - we want to know if the game is over.
09:16:18 <beelsebob> so yes, it should have type [(a,String)] and thus Igloo's observation must be correct
09:16:23 <beelsebob> actually no
09:16:27 <sorear> dhart: but if we just have (s -> s), we can't get any other information out
09:16:31 <beelsebob> should it not be (f, a rr)
09:16:40 <Igloo> no
09:16:44 <sorear> beelsebob: by concatinate, do you mean it returns a tuple?
09:17:17 <sorear> dhart: so, we change the type to s -> ( a, s )
09:17:20 <beelsebob> sorear: no, I mean if you have one parser called p that parses "a", and another called q that parses "b", this one makes p <*> q that parses "ab"
09:17:31 <beelsebob> but yes, it should return a tuple
09:17:54 <beelsebob> because parser in this case is defined as Parser a = String -> [(a,String)]
09:18:15 * sorear came frighteningly close to telling dhart s -> (# a, s #)  :)
09:18:18 <dhart> sorear: It's for computing stuff about the State. But why is the return type fixed in the type of the State monad. It would mean that I can have only one type of computation in it.
09:18:41 <sorear> dhart: it's fixed in the type of a state *action*
09:18:56 <sorear> dhart: so an action returns all bools, or all ints, but never both
09:19:15 <sorear> dhart: however the combinators are polymorphic like:
09:19:29 <sorear> (>>=) :: State s a -> (a -> State s b) -> State s b
09:19:46 <sorear> you have to use the same type of state in a sequence, but the type isn't fixed
09:20:08 <sorear> we use this trick for all monads, as codified in the monad type
09:20:11 <sorear> @src Monad
09:20:12 <lambdabot> class  Monad m  where
09:20:12 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
09:20:12 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
09:20:12 <lambdabot>     return      :: a -> m a
09:20:12 <lambdabot>     fail        :: String -> m a
09:21:16 <dhart> Thx for all the explanation, I need to think this over a few times to grasp it correctly
09:21:58 <ivanm> does anyone know if its possible to do barcharts using haskellcharts?
09:22:00 <hpaste>  sorear annotated "Removing list comprehensions" with "hopefully fixed" at http://hpaste.org/1253#a3
09:22:51 <dhart> sorear: What is the difference between State and MonadState? I'm confused.
09:23:32 <ivanm> sorear: since you know everything, is it possible to do barcharts using haskellcharts?
09:23:34 <ivanm> ;-)
09:23:57 <sorear> ivanm: never heard of the latter, sorry.
09:24:05 <ivanm> no worries
09:24:41 <sorear> dhart: MonadState is a typeclass used so that get/gets/put/modify will work on both State and StateT
09:25:07 <beelsebob> Igloo: am I thinking straight that it would come down to "(p <*> q) inp = concatMap (\(f,r) -> concatMap (\(a,rr) -> [(f a,rr)]) (q r)) (p inp)" with our assumption
09:25:35 <sorear> since you are not using StateT, you can just pretend  MonadState s m => foobar  ===  foobar[m/State s]
09:25:41 <sorear> so
09:25:46 <sorear> @type modify
09:25:49 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
09:26:02 <sorear> --> (s -> s) -> State s ()
09:27:58 <dhart> So modify takes a function which takes an input state s and modifies it by outputing an output state. But I would be expecting modifiy to also take as input a "State s"
09:29:03 <sorear> why?  it doesn't need a modifying action
09:29:22 <sorear> remember State s a === s -> (a, s)
09:29:30 <hpaste>  beelsebob annotated "Removing list comprehensions" with "can that be simplified?" at http://hpaste.org/1253#a4
09:29:38 <sorear> so modify :: (s -> s) -> s -> ((), s)
09:29:45 <sorear> @djinn (s -> s) -> s -> ((), s)
09:29:47 <lambdabot> f a b = ((), a b)
09:30:14 <chris2> hmm, you guys deal a lot with infinite lists... any literature on programming algorithms operating on infinite lists? e.g. taking a random sample or something
09:30:42 <sorear> Not sure that exists, per se.
09:30:54 <hpaste>  Cheery pasted "Why the error appears?" at http://hpaste.org/1254
09:30:59 <sorear> however there are the codata papers, which *might* be useful
09:31:00 <quicksilver> dhart: or, another way of looking at it, is that input already does take a state input
09:31:10 <Cheery> the error does not appear if I explicitly define the type
09:31:10 <quicksilver> dhart: it's just that its implicit in the type
09:31:24 <pierre-> xmonad is really great
09:31:26 <Cheery> and it does not appear if I rewrite the thing like this:
09:31:35 <pierre-> i found it better than wmii
09:31:40 <Cheery> stupid m = mutator Stupid m
09:32:02 <dmwit> pierre-: Fewer things you can do == less decisions to have to make. =)
09:32:48 <Cheery> why can't I omit the 'm' -variable without adding the type?
09:33:04 <pierre-> dwwit: it seems to be right :-)
09:33:40 <pierre-> i never thought that something can be easier than wmii
09:33:51 <quicksilver> Cheery: I think this is related to the monomorphism restriction
09:34:10 <Cheery> never heard
09:34:16 <quicksilver> Cheery: CAFs have to be monomorphic
09:34:26 <Cheery> CAF?
09:34:27 <quicksilver> Cheery: giving a 'dummy' argument is the standard work-around
09:34:33 <quicksilver> Cheery: constant-applicative-form
09:34:43 <quicksilver> Cheery: a top level definition with no (visible) parameter
09:35:25 <quicksilver> http://www.haskell.org/haskellwiki/MonomorphismRestriction
09:35:26 <lambdabot> Title: Monomorphism restriction - HaskellWiki
09:35:30 <Cheery> another work-around would be to use the function once
09:35:32 <quicksilver> Cheery: you are not alone in finding it annoying :)
09:36:11 <Cheery> those variables given to my hulk -mutant aren't doing that
09:37:21 <Cheery> What restricts me here?
09:37:40 <Cheery> oh well, I guess that link answers
09:39:01 <haskellboy> is anyone here frim Ireland ?
09:40:11 <haskellboy> Does anyone know how to use the Haskell School of Expression code with GHC instead of the Nov' 2002 version of Hugs???
09:40:31 <haskellboy> GHC is so much better than Hugs
09:42:06 <dmwit> haskellboy: What code isn't working?
09:42:08 <dmwit> ?hpaste
09:42:09 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:43:37 <Saizan> Cheery: if you explicitly give it a type the restriction won't happen
09:43:47 <quicksilver> haskellboy: it's supposed to work if you import the special compatibility pacakge
09:43:56 <quicksilver> Graphics.HGL.SOE is it called?
09:44:02 <quicksilver> or something with SOE in the name anyway
09:44:36 <Cheery> Hmm, that thing did not completely answered the question why the restriction is there
09:44:49 <beelsebob> no wonder I was confused by Olaf saying to apply eta-reduction
09:44:55 <beelsebob> he meant eta-expansion
09:45:30 <quicksilver> Cheery: basically, because people assume that CAFs are evaluated only once
09:45:36 <quicksilver> Cheery: a kind of cheap memoisation
09:45:48 <quicksilver> Cheery: and you can't make that promise in the presence of polymorphism
09:47:29 <Cheery> ah, understood it
09:48:34 <Cheery> btw. what do you think about that thing?
09:48:41 <SyntaxNinja> boy, I sure wish I knew a bunch of Haskellers I could hire ;)
09:49:26 <Cheery> what kind of work would you have?
09:50:45 <Cheery> Is it ok to use the composition like that?
09:51:04 <Cheery> ie. use it to compose a data structure from mutators
09:51:13 <SyntaxNinja> some Haskell web platform and web stuff, a bit of php, maybe some formal methods, testing, debugging, product deployment, just about everything.  some researchy stuff too; language design for security
09:51:16 <Cheery> where the mutators are less or more generic
09:52:14 <Cheery> SyntaxNinja: wow, is it bad if most generic-style code would be released as open source?
09:52:25 <Cheery> *generic type code
09:52:58 <SyntaxNinja> Cheery: bad? what do you mean?
09:53:35 <ddarius_> SyntaxNinja: Give me a bit more than 3 years, and I'll be there.
09:54:08 <Cheery> SyntaxNinja: like, would you mind?
09:54:16 <glguy> SyntaxNinja: and here I was thinking I was special ;)
09:54:33 <SyntaxNinja> ddarius: deal.
09:54:39 <SyntaxNinja> glguy: you are special.
09:54:46 <glguy> just like everyone else :)
09:54:57 <SyntaxNinja> glguy: you are 3 years more special than ddarius ;)
09:55:02 <malcolmw> haskellboy: I'm from Ireland originally
09:55:11 <glguy> is he 19 yrs old?
09:55:21 <ddarius> NO
09:55:24 <SyntaxNinja> Cheery: we release some code open source, and if you were dedicated to that, then you could help us release more, but a lot of code doesn't get released.
09:55:27 <ddarius> Bloody keyboard.
09:56:23 <ddarius> SyntaxNinja: Not that it matters now, but do you guys value a security clearance at all?
09:56:37 <SyntaxNinja> ddarius: yeah
09:57:18 <SyntaxNinja> no one has them, but they are good to be able to get.
09:57:46 <ddarius> SyntaxNinja: That's good to know for future reference.  I have one now.
09:57:57 <sorear> Cheery: where's the code?
09:58:12 <Cheery> http://hpaste.org/1254
09:58:17 <alexj> syntaxninja: you are not the only one in the market for haskellers.
09:58:26 <SyntaxNinja> hi alexj!
09:58:30 <Cheery> the error is solved, thought what do you think about the style?
09:58:31 <SyntaxNinja> \kick alexj
09:58:32 <SyntaxNinja> ;)
09:58:43 <alexj> hi syntaxninja
09:59:43 <alexj> though for some of what I am doing, it may make sense for you guys to be in the market for me (haven't really thought it through yet).
09:59:51 <Cheery> base (param 1 2 . param' A . param'' Just Foo . param''' "x")
10:00:14 <ddarius> Cheery: That looks ugly.
10:00:26 <alexj> is guess its a what do galois clients look like sort of thing.
10:00:40 <alexj> perhaps that is a simpler way to go.
10:00:43 <SyntaxNinja> ddarius:  check your msgs ;)
10:00:58 <Cheery> ddarius: a bit ugly, yes
10:01:17 <alexj> ddarius: if you want to work remotely and on your own hours, send me an email.
10:01:58 <Cheery> ddarius: but it allows you to specify a structure with default values
10:02:42 <Cheery> I plan to use this in a combination with some of the cascading style sheet -thing
10:03:26 <Cheery> for example, you can say: background (color 255 125 0 . image "foobar.png" . fixed)
10:05:30 <Cheery> orQ
10:06:09 <int-e> Cheery: is there any reason not to use a list?
10:06:11 <glguy> what does that let you do that: background [color 255 125 0, fixed]
10:06:14 <glguy> does?
10:06:16 <glguy> not*
10:06:52 <Cheery> background (image "foobar.png" . fixed . (xpos left) . (ypos $ pixels 50))
10:07:20 <glguy> what does composition let you do that a list doesn't?
10:07:53 <ddarius> Cheery: Wait, was that line above just an example with param' etc being like foo, bar etc?
10:08:01 * ddarius hasn't looked at the pasted code.
10:08:06 <Cheery> let stuff = fixed . xpos left . ypos centered in background (image "foobar.png" . stuff)
10:08:30 <glguy> Cheery: let stuff = [what,ever] in background (image "" : stuff)
10:08:40 <Cheery> :)
10:08:57 <glguy> let stuff = [a,b] in background (stuff ++ [what,ever]) ?
10:08:57 <Cheery> yeh, maybe the list -thing would neither be bad
10:09:24 * ddarius wonders if technophobicgeek will like my reply on LtU
10:10:40 <Cheery> glguy, thought, the same mechanics would go below
10:11:30 <Cheery> take your list and put it through: foldl mutator (Hulk [])
10:11:58 <Cheery> or:
10:12:15 <glguy> Cheery: you can do it however you like, I just didn't understand the motivation for the design
10:12:19 <int-e> Cheery: it's really a style question; I think a list feels more natural there
10:12:21 <Cheery> hulk $ foldl (.) id [stuff...]
10:12:52 <sorear> runEndo . mconcat . map Endo :)
10:13:10 <int-e> Cheery: functionally composition and lists achieve about the same, as you just said.
10:13:54 <quicksilver> you can do more with lists though
10:14:18 <quicksilver> you can't do much with a composition except run it
10:14:43 <Cheery> yes, but there's yet one thing
10:15:05 <Cheery> lets say I want to just define that the background is coloured red
10:15:11 <Cheery> background red
10:15:27 <int-e> and if you provide a function  combine :: [Mutator] -> Mutator, you get all the benefits of function composition back
10:15:57 <int-e> and you can change the representation of Mutator freely later, which isn't possible when using composition.
10:16:13 <hpaste>  beelsebob pasted "bug hunt!" at http://hpaste.org/1255
10:16:57 <Cheery> hmm...
10:17:08 <sorear> yay for monadic parser combinators :)
10:17:10 <beelsebob_> arse
10:17:12 <beelsebob_> was'nt in the channel through internet made of jam
10:17:14 <beelsebob_> :/
10:17:16 <beelsebob_> sorear: oh?
10:17:20 <beelsebob_> have you just screamed at my code?
10:17:56 <sorear> I only gave 1 line of text
10:18:21 * beelsebob_ confused
10:19:04 <beelsebob_> thing that confuses me is that the only thing in my code that can return the empty list is pEmpty
10:19:18 <sorear> Not quite.
10:19:30 <beelsebob_> well, pFail can too
10:19:37 <beelsebob_> oh yeh... no parse
10:19:40 <sorear> I think I see refutable pattern matches in the list comps
10:19:44 <beelsebob_> not successfully parsed empty list
10:19:47 <kolmodin> ?localtime dons
10:19:49 <sorear> those desugar to filter
10:19:51 <lambdabot> Local time for dons is Thu Apr  5 03:17:21 2007
10:19:59 <Cheery> ok, I think I'll provide that list combiner and keep this structure
10:20:10 <kolmodin> dons: optimistic ping..
10:20:30 <kolmodin> ?seen dons
10:20:31 <lambdabot> dons is in #haskell-soc, #haskell-overflow and #haskell. I don't know when dons last spoke.
10:21:03 <int-e> beelsebob_: (without trying) do you want  pEmpty [NilT]  in parse perhaps?
10:21:13 <beelsebob_> oh... good point
10:21:28 <beelsebob_> I also want to catch the empty list in pOpen
10:23:13 <beelsebob_> wait... why do I need NilT at all
10:23:14 <beelsebob_> silly bob
10:23:18 <beelsebob_> nil list is NilT
10:23:42 <hpaste>  sorear annotated "bug hunt!" with "refactor - separate opening logic from parsing of '('" at http://hpaste.org/1255#a1
10:24:45 <beelsebob_> that's a nice refactor
10:25:12 <sorear> wow, I didn't notice you already had pure
10:25:28 <beelsebob_> hehe
10:25:29 <beelsebob_> :P
10:25:56 <hpaste>  MarcWeber pasted "How can I track the time when each character has been typed?" at http://hpaste.org/1256
10:26:00 <beelsebob_> still fails for "()"
10:26:02 <beelsebob_> :P
10:26:09 <beelsebob_> but now succeeds for the empty string
10:26:30 <hpaste>  beelsebob annotated "bug hunt!" with "neaten up tree" at http://hpaste.org/1255#a2
10:27:41 <beelsebob_> damn thing is so hard to debug
10:27:45 <beelsebob_> kinda the point though :P
10:28:16 <sorear> MarcWeber: can you just use ttyrec? ;)
10:28:35 <beelsebob_> oh, I know why it fails
10:28:48 <beelsebob_> the parse inbetween pSym '(' and pSym ')' fails
10:28:53 <beelsebob_> because it's not got the empty string
10:29:20 <sorear> So instead of using pEnd, we should use pSuceed in parse
10:29:27 <MarcWeber> sorear: No. I want to track wmii events to add them to a database.
10:29:30 <sorear> and only pEnd at the very end...
10:29:54 <hpaste> checkpoint files are 808K now
10:29:55 <beelsebob_> uhh... I see pEnd at the very end
10:29:59 <int-e> oh, pure == pSucceed :)
10:30:00 <beelsebob_> but I don't get why pSucceed
10:30:22 <MarcWeber> Then I want to sum up the time I've stayed on each tag to get a nice time tracking tool ;)
10:30:34 <sorear> because parsing a tree can suceed with no input, returning the BranchT []
10:30:50 <beelsebob_> no, it should return [] for no input
10:30:57 <beelsebob_> it should return BranchT [] for "()"
10:31:09 <beelsebob_> or rather it should return [BranchT []] for "()"
10:32:17 <sorear> oh right, duh.
10:32:40 <sorear> GHC can't constant fold 2^26 :: Int !?
10:36:46 <hpaste>  int-e annotated "bug hunt!" with "so this works" at http://hpaste.org/1255#a3
10:37:06 <beelsebob_> makes sense
10:40:53 <hpaste>  beelsebob annotated "bug hunt!" with "Any more obvious tidying to do?" at http://hpaste.org/1255#a4
10:41:37 <beelsebob_> okay... this could be fun
10:41:44 <beelsebob_> now I have to build the EDT and FDT for them
10:55:39 <fasta> Can I install Edison with Cabal-install?
10:56:49 <Gwern> so I'm using the +RTS -S option; how do I see what is the maximum amount of RAM a program ever actually uses during a run? is that the "maximum residency" line?
10:57:16 <sorear> top(1)
10:57:36 <sorear> the RTS only tells you about the amount of heap your program uses
10:57:42 <Gwern> sorear: doesn't top just record how much the program asks for? I'm interested in how much is actually used
10:57:59 <sorear> Ok, sorry, mis-understood what you were interested in :)
10:58:41 <Gwern> (the idea is to see purely for kicks how much I can restrict memory usage)
10:58:46 <sorear> also, garbage collected heap isn't the whole story - on some systems ByteStrings exist outside the heap
10:59:13 <Gwern> so I should be looking at the peak heap size then?
10:59:35 <sorear> aiui current GHC uses pinned MutableByteArray#s, which are just garbage collected heap blocks, but Hugs/older GHC use the C heap
11:00:21 <sorear> Gwern: I suppose you've read the relevant section of the user's guide already?
11:00:43 <Gwern> sorear: I did look it over, but this is the first time I've done thinking about memory, so I probably missed stuff
11:01:42 <sorear> I'm not very familiar with the RTS flags and stuff.
11:02:06 <hpaste>  lienmeister pasted "lsb32 and lsb64 using DeBruijn sequence" at http://hpaste.org/1257
11:03:06 <sorear> So THAT's what it's called!
11:03:12 <sorear> Beaten again :)
11:03:38 * resiak has seen that name before...
11:03:47 * sorear independendly invented this bit trick yesterday
11:04:13 <sorear> resiak: de Bruijn numbers are also used a lot in the context of Haskell
11:04:33 <resiak> sorear: ah, that's right, numbering bound variables rahter than naming them
11:04:39 <sorear> and de Bruijn graphs are the standard method for highly efficient life search programs
11:05:02 * resiak thinks back to his programming languages course
11:05:15 <sorear> he's got a fair number of easily confusable inventions :)
11:09:19 <cjeris> lienmeister: unfortunately, googling "Jorg's useful and ugly bit wizardry page" gives only one unrelated hit, and "Did you mean: Jorg's useful and ugly bitch wizardry page"
11:10:04 <sorear> cjeris: Joerg maybe?
11:10:27 <sorear> I've never seen Jorg (no umlaut) used as a name
11:11:56 <cjeris> ah, found it, one should search just for Jorg bit wizardry.
11:14:54 <stepcut> I am looking for a paper "GADT + ____________ = dependent types", anyone remember what goes in the blank ?
11:15:33 <Saizan> Oleg?
11:15:42 <stepcut> [PS] GADTs + Extensible Kinds = Dependent Programming
11:15:44 <stepcut> found it :)
11:15:49 <sorear> From experience I can say "totality" will satify ti
11:16:10 <sorear> Hmm.  Haskell + MPTC + FD already has extensible kinds.
11:16:15 <ivanm> sorear: have you ever head of vital?
11:16:41 <sorear> ivanm: yes ...  I thought it was some kind of VB-clone for haskell :)
11:16:58 <ivanm> lol... do you know anything more about it than that?
11:17:09 <ivanm> I'm only asking because it comes with histogram-drawing functions
11:17:31 <sorear> no.
11:17:36 <ivanm> its a java file? :s
11:18:07 <sorear> http://hpaste.org/522#a1 - if haskell was total, this would be a proof that the naturals form a monoid with (+) and 0
11:18:08 <ivanm> s/file/program
11:18:29 <sorear> using GADTs and rank-2 types
11:20:28 <sorear> since then I've figured out how to use 2 type classes and 11 instances to embed System Fw in the type system, a total language expressive enough to represent GADTs
11:20:43 <ivanm> lol
11:21:05 <ivanm> I might not understand all that you're doing there, but it sure _sounds_ impressive! ;-)
11:21:13 <emu> he is training to become Oleg
11:21:14 <sorear> I don't try to be too clever since I know Oleg will always be a step ahead
11:23:42 <bos> only one step? :-)
11:24:40 <sioraiocht> dons: does lambdabot have any admin IRC functions...kick, ban, etc?
11:25:00 <sorear> sioraiocht: yes
11:25:13 <sorear> @help topic-cons
11:25:13 <lambdabot>  @topic-cons #chan <mess> -- Add a new topic item to the front of the topic list
11:25:30 <sioraiocht> sorear: thanks
11:25:31 <sorear> Of course this only works if lambdabot is opped, which it isn't here
11:25:44 <sorear> lambdabot also has admin commands of its own
11:25:48 <sioraiocht> sorear: understandable, was asking for someone else looking for a new bot
11:25:57 <sorear> @msg #haskell Hi!
11:25:58 <lambdabot> Hi!
11:26:07 <vflvsklvkslvl> @msg #haskell Hi!
11:26:08 <lambdabot> Not enough privileges
11:26:15 <sorear> @msg #haskell Hi!
11:26:15 <lambdabot> Hi!
11:26:40 <lambdabot> Stop abusing me!
11:28:11 <sorear> Unfortunately, there's no mystery; we may have 20-odd admins but only one regularly uses @msg :(
11:35:31 <freshhawk> haskell.org down?
11:35:50 <fasta> How do I tell cabal-setup to install packages with profiling libraries too?
11:36:04 <int-e> freshhawk: no
11:36:05 <fasta> freshhawk: no
11:36:24 <fasta> Anyone ever used cabal-setup?
11:36:52 <sioraiocht> anyone know how to get something for the haskell.org cvs repository? i'm cvs-challenged
11:38:05 <freshhawk> int-e, fasta: hmm, must be network issue on my end, thanks
11:38:38 <fasta> sioraiocht: AFAIK, they use darcs
11:38:45 <sioraiocht> ah
11:38:57 <Lemmih> fasta: cabal-setup configure --help
11:38:58 <fasta> sioraiocht: assuming for meant from
11:39:10 <sioraiocht> fasta: yes, thanks :)
11:39:29 <fasta> Lemmih: ok, it uses the same flag convention as darcs.
11:39:29 <sorear> Lemmih: how do I install cabal-setup?
11:39:41 <fasta> Lemmih: I am more used to full help with --help
11:39:57 <Lemmih> sorear: It's in the cabal darcs repository.
11:40:04 <sorear> Lemmih: I've 7 installed versions of GHC here, most (all?) of which came with cabal-setup sources - none fo them installed it
11:40:06 <fasta> Lemmih: That doesn't work here.
11:40:15 <fasta> Lemmih: my version is too old?
11:40:16 <sorear> Lemmih: yes, but make didn't work
11:40:34 <Lemmih> fasta: How doesn't it work?
11:40:38 <sorear> Lemmih: or rather make built ghc, ghc-pkg, hsc2hs, etc but not cabal-setup
11:41:01 <Lemmih> sorear: It's distributed with Cabal, not GHC.
11:41:06 <sorear> and make install didn't try to install it.
11:41:25 <sorear> Lemmih: This is a ./darcs-all --extra get --complete tree
11:42:13 <fasta> Lemmih: with the version from darcs: setup: /usr/local/bin/cabal-setup: copyFile: resource busy (Text file busy)
11:42:30 <fasta> Lemmih: this is trying to install the new version from darcs.
11:42:40 <fasta> Lemmih: so, it's actually using the old version, of course
11:42:45 <sorear> base_GHCziBase_Z0T_closure eh?
11:43:00 <sorear> ghc picks interesting uniques :)
11:43:11 <fasta> Lemmih: it does work now
11:44:32 <Lemmih> sorear: head to libaries/Cabal/cabal-setup/
11:45:25 <sorear> Lemmih: the code is there.  hence my confusion as to why fptools didn't try to build it.
11:46:07 <sorear> or is this code intended to not be used yet?
11:46:29 <stepcut> is there a {-# LANGUAGE #-} pragma for GADTs ?
11:46:44 <sorear> stepcut: no
11:46:47 <Lemmih> sorear: It's usable but not installed by default.
11:46:56 <sorear> that's ... strange?
11:47:02 <stepcut> so, I have to use {-# OPTIONS -fglasgow-exts #-} instead ?
11:47:13 <Lemmih> sorear: Indeed, send a patch (:
11:47:15 <stepcut> what do I put in the .cabal file ?
11:47:30 <stepcut> options-ghc: -fglasgow-exts ?
11:47:32 <sorear> GHC-Options: -fglasgow-exts
11:47:59 <stepcut> :-/
11:48:01 <stepcut> ok, thanks
11:48:52 <sorear> Hugs-Options: -e 'putStrLn "Please patch Language/Haskell/Extension.hs in Cabal to support gadts!" >> System.Exit.exitWith (System.Exit.ExitFailure 1)'
11:50:16 <sfogarty> Hello... so I have finally gotten this Haskell program what links to liblpk.a working on the latest version of Haskell. It compiles and runs. I would like to run functions from ghci, so I can play around with intermediate data structures. Unfortunately ghci seems only to like .so files, and my best attempts to create one have failed. So I thought I might ask you nice folk: is there a way to refer ghci to a .a file, instead of a .so file?
11:50:31 <fasta> Igloo: I installed a recent GHC, but now I get this: /tmp/ghc30786_0/ghc30786_14.hscpp:1:0:   file name does not match module name `Main'
11:51:11 <phoniq> sfogarty: no, since you can't runtime-link .a's
11:51:26 <sfogarty> Curses! Alright, thanks for the quick answer. I'll poke around with trying to create a .so then.
11:51:27 <sorear> phoniq: yes you can
11:51:30 <phoniq> eh?
11:51:41 <sorear> phoniq: a .a is just a bunch of .o's
11:51:55 <sorear> sfogarty: use ar x liblpk.a, then tell ghci *.o
11:52:09 <malcolmw> just got an email from Google with subject line: Student Allocation Announcement
11:52:24 <sorear> sfogarty: maybe even ld -r *.o -o /tmp/liblpk_HS.o
11:52:33 <phoniq> oh duh i misunderstood
11:53:00 <Heffalump> so when's Haskell going to take it's driving test?
11:53:06 <Heffalump> s/it's/its/
11:53:07 <phoniq> er, hm.
11:53:35 <phoniq> it isn't dlopening these things then i take it
11:53:40 <malcolmw> Heffalump: is Haskell 17 years old already?
11:53:42 <sfogarty> sorear: Do I not have to compile the .o's with fPIC first?
11:54:07 <Heffalump> malcolmw: well, the topic claims it is
11:54:25 <Heffalump> although I note that it was set on the morning of April 1st.
11:54:35 <sorear> phoniq: no, the GHC wrote their own dynamic linker :)
11:54:39 <sorear> + folks
11:54:46 <sorear> sfogarty: No
11:54:56 <sfogarty> alright then. I'll try that, thank you greatly
11:54:57 <phoniq> wild.  now i get it.
11:55:01 <sorear> sfogarty: -fPIC improves performance, but isn't strictly necessary
11:55:34 <sorear> sfogarty: (on i386 that is - I hear tell it is needed on some not-generally-used-in-pcs risc families)
11:55:57 <sfogarty> sorear: I am nowhere near that exotic.
11:56:01 <int-e> sorear: hmm? it is needed on x86 to get references to data correct
11:56:25 <fasta> Igloo: deleting all the .o and .hi files seemed to help.
11:56:27 <sorear> int-e: Relocations!
11:56:46 <sorear> int-e: which destroy sharing, but see above on "performance"
11:58:27 <int-e> ok, the dynamic linker can deal with that in principle, I thought it wouldn't.
11:58:50 <dozer> I have a data declaration with four constructors e.g. "data MyDat One | Two | Three | Four", but in part of the app there is a function that is only defined for options One and Two.
11:59:11 <dozer> it's not realy an option for me to make the func return Maybe MyDat
11:59:36 <dozer> how can I re-work this? (don't have to use a data type if classes would work better)
12:00:09 <int-e> dozer: leave it undefined for the alternatives? (or return some error)
12:00:28 <sfogarty> Hm. Only ET_DYN and ET_EXEC can be loaded.
12:00:43 <dozer> not an option - the function should /never/ be applied to the other options, and to do so is a code-writing time error
12:01:27 <sfogarty> will try with fpic, just in case
12:02:12 <Lemmih> data MyDat a where One :: MyDat LessThanThree; Two :: MyDat LessThanThree; Three :: MyDat MoreThanTwo ... ?
12:02:29 <sorear> @where catch
12:02:30 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
12:02:41 <sorear> dozer: ndm's program can handle this
12:03:04 <sorear> dozer: warning, a thesis program (and wip at that)
12:09:58 <sorear> This can't be right.
12:10:38 <sorear> I have an inner loop that runs 3x faster with ForeignPtr Int -> IO ()   than  Addr# -> State# RealWorld# -> State# RealWorld
12:11:05 <sorear> I always thought foreignptrs were supposed to be SLOWER?
12:17:13 <mightybyte> Anyone here familiar with the Cat programming language?
12:19:54 <sfogart1> Hmn. I am getting an interesting error when loading the -o files.
12:19:56 <sfogart1> ghc-6.6: lpk/lp.o: unknown symbol `yywrap'
12:20:25 <sfogart1> Any thoughts? It does compile, doesn't like loading dynamically
12:20:34 <Cheery> Hmm...
12:20:48 <qwr> some yacc generated staff missing?
12:20:57 <Cheery> after doing the Mutant -thing further
12:20:59 <sfogart1> yacc is used
12:21:15 <Cheery> I think it may not be just good
12:22:40 <sfogart1> similar errors if I try to  omit that file
12:22:40 <sfogart1> ghc-6.6: lpk/read.o: unknown symbol `yylineno'
12:22:45 <Cheery> or hmm...
12:22:48 <sfogart1> is there a yacc library I need to include?
12:23:14 <sfogart1> well, bison/flex
12:23:33 <qwr> sfogart1: add -lfl
12:24:46 <Cheery> any way how I put it, it does not seem getting nicer, but there's an another thing which may go well
12:25:39 <sfogart1> Hmn. Can't find libfl.so... probably because I have a pesky -L in there.
12:25:47 <sfogart1> no, I don't
12:25:48 <Cheery> if It'd accept multiple functions of same definition, I could do:
12:26:21 <sorear> mightybyte: hehe.  Yes I am, though probably not the Cat you were thinking of.
12:26:33 <qwr> sfogart1: comes from flex package on debian
12:27:00 <Cheery> background { color = RGB 1 2 3, fixed = Yes, image = "foobar.png" }
12:27:33 <sfogart1> qwr: I have a /usr/lib/libfl.a :) No .so there. Looking.
12:27:37 <Cheery> thought, it does not allow multiple declarations
12:27:49 <dmead_> rawr
12:27:50 <dmead_> haskell
12:28:04 <qwr> sfogart1: hmm. .a should work for linking a lib?
12:29:08 <sfogart1> gwr: been told ghci does not like .a. (This is my entire problem: I have a liblpk.a that I want to load into ghci).
12:29:57 <qwr> sfogart1: extract the libyywrap.o from the .a and link it into your .so?
12:30:06 <sfogart1> Heh. Why not.
12:31:32 <sfogart1> gwr: AHA! It loaded. Lets see if it actually runs
12:31:42 <allbery_b> stupid gtk2hs (or maybe gtk2) question?
12:32:13 <dmwit> go go go! =)
12:32:23 <sjanssen> @yow
12:32:24 <lambdabot> Mmmmmm-MMMMMM!!  A plate of STEAMING PIECES of a PIG mixed with the
12:32:24 <lambdabot> shreds of SEVERAL CHICKENS!! ... Oh BOY!!  I'm about to swallow a
12:32:24 <lambdabot> TORN-OFF section of a COW'S LEFT LEG soaked in COTTONSEED OIL and
12:32:24 <lambdabot> SUGAR!! ... Let's see ... Next, I'll have the GROUND-UP flesh of CUTE,
12:32:24 <lambdabot> BABY LAMBS fried in the MELTED, FATTY TISSUES from a warm-blooded
12:32:26 <lambdabot> [3 @more lines]
12:32:30 <sjanssen> @more
12:32:30 <lambdabot> animal someone once PETTED!! ... YUM!!  That was GOOD!!  For DESSERT,
12:32:31 <lambdabot> I'll have a TOFU BURGER with BEAN SPROUTS on a stone-ground, WHOLE
12:32:32 <lambdabot> WHEAT BUN!!
12:32:36 <Vq^> :)
12:32:40 <allbery_b> insofar as I can tell, I cannot "real world" right justify the contents of a label:  I can tell it to right justify, but this has relationship only to multiple lines of text within the widget, not to the position of the text block within th elabel
12:33:32 <allbery_b> setting the x align to 1.00 aligns the label itself to the right but also does not affect the text block
12:33:49 <dmwit> Maybe set the label to not expand?
12:34:47 <allbery_b> sure, then insert a magic spring to the left of it, having given up and changed the "right-justified label" to an HBox so I have somewhere to put the spring
12:34:58 <allbery_b> but then I can't tell that to have a width of e.g. 6 characters
12:35:21 <allbery_b> and also seems to be 2-3 widgets mroe than I really think I *should* need to do this
12:35:32 <sorear> Oh I feel dumb.
12:35:45 <sjanssen> sorear: what'd you do?
12:36:04 <sorear> sjanssen: I "found" foreignptrs were 3x faster than ptrs
12:36:14 <sorear> sjanssen: my f-ptr loop wasn't incrementing
12:36:30 <sorear> sjanssen: so it wrote to the same byte 256 million time
12:36:48 <sjanssen> yep, that'll speed things up
12:37:06 <sorear> @ty pokeElemOff
12:37:09 <lambdabot> Not in scope: `pokeElemOff'
12:37:20 <sorear> @hoogle poke
12:37:21 <lambdabot> Foreign.Storable.poke :: Storable a => Ptr a -> a -> IO ()
12:37:21 <lambdabot> Foreign.Storable.pokeByteOff :: Storable a => Ptr b -> Int -> a -> IO ()
12:37:21 <lambdabot> Foreign.Storable.pokeElemOff :: Storable a => Ptr a -> Int -> a -> IO ()
12:38:19 <sorear> Now my foreignptrs are 2000x faster - segfault after .03 seconds! :)
12:39:40 <dmwit> :instances Floating
12:39:51 <dmwit> ?instances Floating
12:39:53 <lambdabot> Double, Float
12:40:10 <opqdonut> ?instances []
12:40:11 <lambdabot> Plugin `instances' failed with: IRCRaised regex failed: (ReturnCode 7,"brackets ([ ]) not balanced")
12:40:19 <stepcut> sorear: awesome!
12:40:19 <opqdonut> :O :D
12:40:35 <opqdonut> ?instances (->)
12:40:36 <lambdabot> Couldn't find class `(->)'. Try @instances-importing
12:40:38 <allbery_b> okay, so I put the extra hbox and label=spring back in.  and, just as last time, setting the "spring" to expand+fill and the reallabel to not expand *still* leaves me with left justified text
12:40:51 <dmwit> opqdonut: Those are type constructors, not classes.
12:41:00 <allbery_b> (and three widgets where I should need only one)
12:41:03 <opqdonut> what are the respective classes then?
12:41:10 <opqdonut> and isn't : the list constructor
12:41:13 <dmwit> ?instances Monad
12:41:14 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
12:41:21 <dmwit> opqdonut: Yes, but [] is the *type* constructor.
12:41:25 <dmwit> ?kind []
12:41:25 <opqdonut> ah, it works that way around
12:41:28 <lambdabot> * -> *
12:41:32 <opqdonut> my bad
12:41:36 <sorear> Raw Addr# w/ pointer arithmetic, Ptr with array operations, and ForeignPtr with array operations are equally fast now.
12:41:38 <mauke> : is one of the list data constructors
12:41:51 <sfogart1> sorear, qwr: Thank you very much, it's not pretty but it works!
12:42:09 <dmwit> allbery_b: I don't know... =(
12:43:19 <procyon112> is unification without the occurs check non halting in some cases?
12:43:31 <sorear> no
12:43:38 <procyon112> Mine is.... hmmm....
12:44:28 <sorear> procyon112: remember, you are traversing a cyclic graph
12:44:35 <sorear> this demands caution
12:45:16 <procyon112> It only is non halting when I take out the occurs.  It does not appear to be nonhalting when I leave occurs in and introduce (a->a)->a
12:45:25 <allbery_b> artgh.  so, fill the "spring" with zeroes, then set invisible.  it obeys (i.e. takes zero space)
12:45:43 <allbery_b> there is *no* way to do this, is there?  nobody in the world right-justifies numeric fields?!
12:46:11 <sorear> procyon112: makes sense - without occurs types can be cylic, with occurs+fix they can't
12:46:36 * allbery_b gives up and goes home
12:47:14 <dmwit> allbery_b: In glade, I can get it to work using a text view widget.
12:47:25 <procyon112> sorear: I can also get *very* long, but halting unifiers in some cases without the occurs check (maybe infinite... I didn't let them finish printing), but the unification appears to halt in those cases.
12:47:33 <procyon112> Something is wrong.  bah.
12:49:19 <dmwit> allbery_b: Though, as you say, trying to make it work with a label doesn't seem to be working.
12:50:54 <procyon112> sorear: This might be a job for haskell-cafe ;)  I'm in over my head here.
12:54:47 <roconnor> @pl \a b c -> f a (f b c)
12:54:48 <lambdabot> (. f) . (.) . f
12:55:16 <roconnor> @pl \a b c -> f (f a b) c
12:55:16 <lambdabot> (f .) . f
12:55:45 <procyon112> hehe.  Emacs doesn't like printing multimegabyte tautologies in it's buffers....
12:56:00 <mauke> @pl \f a b c -> f (f a b) c
12:56:00 <lambdabot> (.) =<< (.)
12:56:56 <sorear> eyah, emacs sucks
12:57:09 <maht> that's not news
12:57:33 <sjanssen> vim ftw ;)
12:57:57 <procyon112> I'm abusing it though... I can't hold the fact that I gave it that pathalogical tautology to print against it.
12:58:14 <sorear> procyon112: no, that's emacs' fault
12:58:36 <sorear> procyon112: algorithms are known to display a size-k buffer in O(log k) time
12:58:37 <sfogart1> classic victim.. blaming themselves.
12:58:46 <procyon112> lol
12:58:53 <sorear> procyon112: emacs still uses stupid linear algorithms
12:59:16 <sorear> Gap buffers?  Come on, who still uses those?
13:00:08 <procyon112> yeah.. and greedy at that.  It should window it's views in the buffer and swap everything outside the window to disk.
13:00:27 * sorear has a VM OS
13:02:04 <procyon112> Then swap to a memory mapped file.  The pointers in the buffer are of limited bitlength for perf.  They should be pointers into the "window", not from the start of the buffer.
13:03:24 <procyon112> It beats the hell out of Eclipse or VS though :)
13:05:05 <sorear> wow, they even misspell wallops...
13:06:43 <sorear> HAH!
13:06:45 <sorear> L2++
13:07:14 <sorear> It takes 1 minute and 3 seconds for my computer to write 256MB of data one words at a time.
13:08:03 <sorear> I've tried ForeignPtr, Ptr-with-indexing, MutableByteArray#, Addr# fiddling, and now C.
13:08:12 <sorear> all within 0.5% of each other
13:08:33 <sorear> GHC has a deservedly bad reputation for loop code generation
13:08:43 <sorear> but apparently this one wasn't cpu bound.
13:09:13 <sorear> er, 1m3 to write 256MB 100 times.
13:09:13 <sjanssen> > 256/63
13:09:15 <lambdabot>  4.063492063492063
13:09:32 <sorear> sorry, I forgot one other common aspect of my tests :)
13:09:36 <bos> yeah, that'll be diskbound.
13:09:37 <sorear> > 25600/63
13:09:39 <lambdabot>  406.3492063492063
13:09:55 <sorear> bos: I have 384 mb ram, so the buffer fits comfortably
13:10:05 <sorear> and my hd light is dark
13:10:09 <bos> are you writing to a series of files?
13:10:21 <sjanssen> sorear: why the (*100)?
13:10:28 <sjanssen> oh, 100 times
13:10:33 <sorear> bos: no, I'm writing to a single 256 MByte memory block 100 times
13:10:37 <bos> oh.
13:10:51 <bos> well, that's about 512MB/sec of memory bandwidth.
13:10:59 <sorear> Apparently all I succeeded in doing was benchmarking my memory.
13:11:18 <sjanssen> sorear: is the code online?
13:11:19 <bos> which is about a tenth of your real memory bandwidth, depending on what kind of machine you have.
13:11:44 <bos> so 500MB/sec isn't actually all that bad.
13:12:13 <sorear> bos: oh? where does the rest go?  (FWIW memtest86+ says 5120MB/s memory bandwidth)
13:12:33 <bos> sorear: GHC RTS boogums?
13:12:39 <sorear> sjanssen: no (should it be?)
13:13:02 <sjanssen> sorear: I was going to offer to check it on my machine
13:13:10 <sorear> bos: performance was identcal with all four Haskell loops and void words(int *buf, int ct) { while (ct--) *buf++ = 42; }
13:13:25 <sorear> bos: so I don't think the rts matters here
13:13:37 <bos> well that's weird.
13:13:41 <bos> sorear: what OS?
13:13:43 <beelsebob_> byargh!
13:13:48 <beelsebob_> horrible!
13:14:05 <bos> normally the best you'll do with gcc is about 0.5x what memtest86 reports.
13:14:07 <sorear> what I was *trying* to do was measure the perf difference between ByteArray#, Addr# array, Addr# arithmetic, and ForeignPtr array
13:14:14 <bos> but you're still off that by a factor of five.
13:14:41 <sorear> what does memtest86 do? (read a configuration register?)
13:14:44 <hpaste>  beelsebob pasted "Which debugging session do you prefer?" at http://hpaste.org/1258
13:15:02 <sorear> bos: Linux 2.6.18 (Debian sid's build)
13:15:05 <bos> no, it measures the bandwidth directly, but it uses streaming instructions, which gcc isn't smart enough to do.
13:15:16 <beelsebob_> sorear: now successfully rebroken :P
13:15:30 <sorear> streaming instructions?
13:15:31 <beelsebob_> (deliberate this time)
13:15:41 <bos> sorear: SSE2
13:15:54 <eumenides> uhm, how do i catch a read parse exception?
13:15:59 <sorear> eumenides: reads
13:16:06 <sorear> > read "abc" :: Int
13:16:08 <lambdabot>  Exception: Prelude.read: no parse
13:16:10 <beelsebob_> bos: ghc *should* use SSE, as long as you're using a version of gcc that does
13:16:16 <sorear> > reads "abc" :: [(Int, String)]
13:16:18 <lambdabot>  []
13:16:19 <beelsebob_> no idea when it might do so though
13:16:31 <bos> beelsebob_: yes, and i said gcc doesn't use them :-)
13:16:31 * sorear tries again with -march=pentium4
13:16:37 <eumenides> sorear: oo. cool. exactly what i need
13:16:46 <beelsebob_> bos: which gcc are you using? 3.4 or later should use them
13:17:23 <bos> beelsebob_: i've tried every gcc up to 4.2 CVS HEAD; it doesn't stream loops.
13:17:31 <beelsebob_> sucks
13:17:38 <bos> the reason i know this is that i work on a C compiler that *does*.
13:17:46 <bos> and you get a big performance benefit.
13:17:48 <beelsebob_> strange
13:17:57 <beelsebob_> gcc 3.4 gave a huge benefit on PPC
13:18:03 <beelsebob_> because it started using AltiVec
13:18:25 <beelsebob_> maybe it just didn't work so well for the vector unit stuff on x86
13:18:46 <sorear> is there anything like -ddump-asm for gcc?
13:18:53 <bos> gcc -S
13:18:54 <sorear> I know about -S
13:19:03 <sorear> I'd just prefer it on stdout :)
13:19:08 <bos> then no.
13:21:43 <mwc> beelsebob_, autovectorization optimizations didn't come into existence until 4.0
13:22:11 <mwc> bos, you work with what compiler? ICC? one of the pathscale ones?
13:22:23 <bos> pathscale.
13:23:38 <mwc> We have pathscale on our clusters. It's superlative
13:24:00 <bos> yay us!
13:24:51 <bos> we have a compiler team about 1% the size of the intel compiler team (i'm not exaggerating), and yet competitive performance ;-)
13:25:09 <bos> but i haven't tried building ghc with it yet :-)
13:25:31 <mwc> sorear, beelsebob_, fwiw, I saw a bug a little while ago that said something to the effect that SSE instructions were only generated on x86-64, and that they should be enabled for IA32
13:25:43 <beelsebob_> interesting
13:26:17 <beelsebob_> mwc: don't you remember, 3.4 got renamed to 4.0
13:26:21 <mauke> sorear: -o /dev/stdout
13:26:43 <mwc> beelsebob_, really? I thought 3.4 was the last release series before 4.0 came out
13:26:44 <beelsebob_> mwc: I still call it that because that's what I was playing with with beta versions, and I never got used to it being v4
13:27:55 <Cheery> grr
13:29:03 <Cheery> When working with cascading style sheets, the effort coming from trying to get this all to line up is minor compared to frustration it brings up
13:29:39 <beelsebob_> Cheery: just make it meet the standard, and it'll work in FF and Safari and probably IE 7, then just ignore IE 6
13:30:03 <beelsebob_> anyone still using it is too much of an idiot to be graced with a webpage
13:30:45 <sorear> Even elinks does a good job with css!
13:31:36 <Cheery> I'm not writing a cascading style sheet, making a tool to generate it
13:31:53 <beelsebob_> then make it generate standards stuff :)
13:32:09 <emu> beelsebob_: ie.. most of the world
13:32:46 <Cheery> yes, but the biggest frustration is the lack of similarity in the declarations
13:32:51 <beelsebob_> emu: 48% of people using it just implies that 48% of people are stupid :P
13:33:00 <beelsebob_> at least 48% even
13:33:04 <emu> i'm not disagreeing
13:33:13 <Cheery> 90% of people using windows implies that 90% of people are stupid
13:33:22 <emu> 90% of people are below average? :P
13:33:35 <mwc> Windows actually seems to me to be very similar to lawyers
13:33:58 <mwc> Windows and Lawyers both create complicated, byzantine ecosystems that require you to pay them tribute to get any work done
13:34:05 <Cheery> windows sounds fragile, especially after you have used it
13:35:11 <emu> the thing is, what lawyers do is inherently hard; it's just needlessly over-complicated further
13:35:17 <Cheery> but anyways, more what is frustrating me is that there's lots of almost-similar but not at all similar -declarations
13:35:30 <beelsebob_> Cheery: how do you mean?
13:35:39 <beelsebob_> the structure of them in CSS is nearly the same?
13:36:15 <Cheery> caption-side, there you can give values: top, left, right, bottom
13:36:40 <Cheery> while there's: border-top... margin-top... padding-top... and so on.
13:37:15 <sorear> that's because caption is a sum while border is a product
13:37:43 <araujo> hello
13:37:44 <sorear> unfortunately the people who designed this evidently never heard of the semiring algebra of data types
13:38:49 <bos> i think it's safe to say that the world of web designers doesn't have much intersection with the world of mathhematicians.
13:38:49 <Cheery> then there's things like: list-position, and position, which does completely different things while have 75% similar names
13:39:17 <phoniq> if it did, it'd all be latex
13:39:40 <beelsebob_> phoniq: except that latex and css are trying to do completely different things
13:39:42 <Cheery> the worst thing is that you can find only one or two declaration with same possible input values
13:39:51 <beelsebob_> maybe html would be latex though
13:40:08 <sorear> Cheery: don't make css in haskell.  make css done right in haskell.
13:40:16 <Cheery> there's slight differences in what kind of scalars does different things take! :(
13:40:36 <maht> list-position isn't like position at all
13:40:41 <Cheery> sorear: how?
13:40:59 <maht> but anyway, don't let me defend that stuff
13:41:14 <sorear> stefan@stefans:~/memset$ gcc -O2 -o Unal Unal.c -march=pentium4 -msse3 -S
13:41:14 <sorear> stefan@stefans:~/memset$ time ./Unal a b c
13:41:14 <sorear> ./Unal: line 1: .file: command not found
13:41:16 <Cheery> more like, after I've done it right, how do I compile the css done right to css done right now?
13:50:36 <joelr1> folks, how can i make the following polymorphic?
13:50:39 <joelr1> arb1 :: (a -> b) -> Gen b
13:50:39 <joelr1> arb1 x = liftM x arbitrary
13:50:50 <joelr1> the above doesn't work
13:51:23 <sjanssen> @hoogle arbitrary
13:51:24 <lambdabot> Test.QuickCheck.arbitrary :: Arbitrary a => Gen a
13:51:24 <lambdabot> Test.QuickCheck.Arbitrary :: class Arbitrary a
13:51:24 <lambdabot> Test.QuickCheck.coarbitrary :: Arbitrary a => a -> Gen b -> Gen b
13:51:35 <joelr1> whereas if I plug in Int instead of 'a' then it works
13:51:41 <sjanssen> @type \x -> liftM x Test.QuickCheck.arbitrary
13:51:44 <lambdabot> forall a1 r. (Arbitrary a1) => (a1 -> r) -> Gen r
13:52:02 <sjanssen> joelr1: you need to add an Arbitrary context to a
13:52:15 <joelr1> sjanssen: let me see...
13:52:40 <sjanssen> joelr1: when in doubt, use type inference :)
13:53:18 <joelr1> sjanssen: i tried but i should have tried harder
13:53:47 <sjanssen> joelr1: btw, which editor do you use?  There's a handy script for vim and emacs to dump an inferred type signature into a file.  Highly recommended.
13:54:02 <joelr1> sjanssen: emacs
13:54:08 <sjanssen> @where typeof
13:54:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/typeof/
13:54:18 <joelr1> sjanssen: i run ghci from the command line, though, what about you?
13:55:08 <sjanssen> I'm a vimmer, so I run ghci in a separate terminal
13:55:21 <sjanssen> the script doesn't depend on any of the fancy emacs/ghci interaction
13:55:30 <joelr1> sjanssen: can vi indent haskell just as well as emacs?
13:56:19 <sjanssen> joelr1: probably not.  I just use the vim indent mode that copies indent from the previous line
13:56:21 <sjanssen> I get by with that
13:56:34 <joelr1> sjanssen: ok
13:57:05 <joelr1> sjanssen: i'm dumb this evening! why doesn't this signature work? arb1 :: forall a b. (Arbitrary a) => (a -> b) -> Gen b
13:57:10 <joelr1> it complains about =>
13:57:15 <joelr1> ghci does
13:57:28 <Saizan> take away the forall
13:57:34 <sjanssen> you can drop the forall junk
13:57:36 <joelr1> it looks exactly like the lambdabot output
13:57:39 <Saizan> s/forall/forall a b./
13:57:45 <joelr1> i see
13:58:08 <sjanssen> lambdabot/ghci are stupid: when -fglasgow-exts is on, forall is always emitted
13:59:02 <sorear> but without -fglasgow-exts, forall is unparseable
13:59:22 <joelr1> ah, that's it
14:01:08 <joelr1> this is a monster!
14:01:09 <joelr1> arb6 :: (Arbitrary a) => (a -> a -> a -> a -> a -> a -> b) -> Gen b
14:01:09 <joelr1> arb6 x = return x `ap` arb `ap` arb `ap` arb `ap` arb `ap` arb `ap` arb
14:01:22 <joelr1> but there's no liftM6 :D
14:01:44 <sjanssen> @hoogle liftM6
14:01:45 <lambdabot> No matches found
14:01:53 <sjanssen> @hoogle liftM4
14:01:54 <lambdabot> Monad.liftM4 :: Monad a => (b -> c -> d -> e -> f) -> a b -> a c -> a d -> a e -> a f
14:01:54 <lambdabot> Control.Monad.liftM4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
14:02:00 <sjanssen> @hoogle liftM5
14:02:01 <lambdabot> Monad.liftM5 :: Monad a => (b -> c -> d -> e -> f -> g) -> a b -> a c -> a d -> a e -> a f -> a g
14:02:01 <lambdabot> Control.Monad.liftM5 :: Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
14:02:12 <sjanssen> liftM5 should be enough for anyone
14:02:16 <sorear> joelr1: I'd suggest using something like DrIFT or Data.Derive
14:02:21 <dylan> @src Control.Monad.liftM5
14:02:22 <lambdabot> Source not found. I feel much better now.
14:02:30 <joelr1> sjanssen: well, i've got a constructor with 6 arguments
14:02:44 <sjanssen> joelr1: yes, I was kidding
14:02:49 <joelr1> :D
14:03:11 <joelr1> with arb6 i can do arbitrary = oneof [ arb6 Foo, ... ]
14:03:33 <joelr1> spencer, where would you use smallcheck?
14:04:25 <joelr1> sjanssen: .
14:04:38 <sjanssen> smallcheck is useful to prove that your property holds for some subset of values
14:05:29 <sjanssen> quickcheck can't prove anything, it can only show that your property is probably correct
14:06:13 <joelr1> hmm
14:06:21 <emu> probably is only one letter off from provably
14:06:21 <sjanssen> I'd also use smallcheck over quickcheck for unit tests, because quickcheck isn't smart enough to run 0-arity properties only once
14:06:45 <joelr1> sjanssen: did you ever use smallcheck? are there examples? i don't dig it for some reason
14:07:41 <joelr1> sjanssen: i'm trying to test a parser. i thought i would generate some random ast and then pretty-print and parser that
14:08:55 <sjanssen> quickcheck is probably fine for that
14:09:05 <joelr1> right
14:09:32 <emu> the emacs haskell-mode has (finally) integrated the command to copy an inferred type-signature into the buffer, also
14:09:37 <joelr1> i just found out that my fine arb6 is all for naught: it doesn't work when the arguments are of different type
14:10:00 <sjanssen> and quickcheck is certainly more established (ie. it's packaged as a Haskell library, plenty of projects to steal examples from, etc.)
14:10:41 <sjanssen> joelr1: arb6 will work fine with a different type signature :)
14:10:47 <joelr1> sjanssen: yeah
14:10:56 <joelr1> sjanssen: simple too. but VEEEEERY long
14:11:00 <sjanssen> a really long type signature
14:11:02 <joelr1> i'll paste it shortly :D
14:11:12 <joelr1> sjanssen: i'm looking for example quickcheck projects
14:11:34 <sjanssen> joelr1: you don't have to write type signatures for everything.  Especially for internal testing type stuff
14:11:46 <joelr1> sjanssen: i know but
14:11:52 <sjanssen> ByteString uses quickcheck extensively
14:12:07 <joelr1> sjanssen: my 6-argument constructor has the arguments of a different type
14:12:17 <sorear> joelr1: just use code generation!
14:12:22 <joelr1> and i'm using the arbs everywhere
14:12:27 <joelr1> sorear: come again?
14:12:55 <sorear> joelr1: when writing programs is tedious, write programs that write programs
14:12:58 <joelr1> sorear: how would you do that? i don't know template haskell
14:13:10 <sjanssen> oh yeah, drift might be able to derive Arbitrary for you
14:13:32 <sorear> Data.Derive could probably be made to do it without too much work.
14:14:47 <joelr1> hmm
14:14:48 <sjanssen> joelr1: you can also look at the tests for binary.  It tests some things like \x -> decode (encode x) == x
14:14:54 <joelr1> right
14:15:08 <joelr1> how would I alias Arbitrary to A?
14:15:23 <joelr1> i suppose declare class A and make it an instance of arbitrary, right?
14:15:34 <sjanssen> joelr1: by the way, the compiler will infer the most general signature for arb6 (ie. each argument is a different type)
14:15:45 <procyon112> Thanks for hosting that, sorear!
14:15:48 <procyon112> sorear++
14:15:48 <joelr1> sjanssen: it doesn't infer that.
14:15:49 <sjanssen> joelr1: that can't be done
14:15:57 <procyon112> stupid email munging...
14:16:15 <sorear> @flush
14:16:24 <joelr1> sjanssen: it infers the same type for all arguments and complains the next time i use arb on a different type
14:16:28 <joelr1> that is without a type signature
14:16:41 <sorear> admins have special powers karma-wise, they can protect themselves from bot crashes!
14:16:49 <sjanssen> joelr1: what is 'arb'?
14:16:57 <joelr1> arb = arbitrary
14:17:03 <sjanssen> that is probably the issue
14:17:07 <joelr1> oh, maybe i had to put a signature on that
14:17:08 <sorear> joelr1: put a sig on arb
14:17:11 <joelr1> and leave it off of the others
14:17:12 <joelr1> let me try
14:17:18 <sorear> joelr1: this is the stupid MR
14:17:33 <joelr1> MR? monomorphism resriction
14:17:52 <kc5tja_> Dude, that would make an awesome name for a prog-rock band.
14:17:56 <kc5tja_> Monomorphism Restriction.
14:17:58 <joelr1> most awesome!!!
14:18:07 <joelr1> thank you sorear, thank you sjanssen
14:18:18 <joelr1> that signature was running off the screen already!
14:18:27 <joelr1> and that's just before => :D
14:18:29 <roconnor> Is there an easy way to compute the culmative binomial distribution?
14:19:08 <sorear> @ty let f x = (x, x) in f . f . f . f . f . f . f $ 2
14:19:11 <lambdabot> forall a. (Num a) => (((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a, a)
14:19:11 <lambdabot> ), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))))), ((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a))
14:19:11 <lambdabot> , ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)),
14:19:11 <lambdabot>  ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))))))
14:19:19 <joelr1> getting back to haskell feels GOOOOD
14:21:32 <roconnor> @check \n -> sum [product [n..i] `div` product [1..i] | i <- [0..n]] = 2^n
14:21:32 <lambdabot>  Parse error
14:21:37 <roconnor> @check \n -> sum [product [n..i] `div` product [1..i] | i <- [0..n]] == 2^n
14:21:39 <lambdabot>  Add a type signature
14:21:49 <roconnor> @check \n -> sum [product [n..i] `div` product [1..i] | i <- [0..n]] == 2^(n::Integer)
14:21:51 <lambdabot>  Falsifiable, after 0 tests: 0
14:22:20 <Saizan> @remember sorear @ty let f x = (x, x) in f . f . f . f . f . f . f $ 2
14:22:21 <lambdabot> Done.
14:22:33 <joelr1> how do you make Maybe an instance of Arbitrary?
14:22:34 <roconnor> @check \n -> sum [product [i..n] `div` product [1..i] | i <- [0..n]] == 2^(n::Integer)
14:22:36 <lambdabot>  Exception: Prelude.^: negative exponent
14:22:56 <roconnor> @check \n -> (0 <= n) ==> sum [product [i..n] `div` product [1..i] | i <- [0..n]] == 2^(n::Integer)
14:22:56 <lambdabot>  Falsifiable, after 0 tests: 2
14:23:16 <roconnor> > let n = 2 in [product [i..n] `div` product [1..i] | i <- [0..n]]
14:23:17 <lambdabot>  [0,2,1]
14:23:26 <sorear> joelr1: upgrade ghc
14:23:37 <joelr1> sorear: huh?
14:23:40 <sorear> joelr1: the bug was fixed about a week after 6.6 was released
14:23:47 <joelr1> sorear: what bug?
14:23:49 <sorear> <joelr1> how do you make Maybe an instance of Arbitrary?
14:23:57 <joelr1> sorear: hmm
14:24:03 <roconnor> > let n = 2 in [product [(i+1)..n] `div` product [1..i] | i <- [0..n]]
14:24:04 <lambdabot>  [2,2,0]
14:24:13 <joelr1> No instance for (Arbitrary (Maybe Int))
14:24:14 <joelr1> right
14:24:18 <joelr1> let me try
14:24:25 <sorear> http://darcs.haskell.org/binary/tests/QuickCheckUtils.hs
14:24:35 <sorear> there's an instance in there
14:24:51 <joelr1> sorear: ok, i just have to import that
14:25:34 <roconnor> > let n = 2 in [product [(n-i+1)..n] `div` product [1..i] | i <- [0..n]]
14:25:35 <lambdabot>  [1,2,1]
14:25:46 <roconnor> @check \n -> (0 <= n) ==> sum [product [(n-i+1)..n] `div` product [1..i] | i <- [0..n]] == 2^(n::Integer)
14:25:47 <lambdabot>  OK, passed 500 tests.
14:26:30 <joelr1> sorear: apparently not the most recent ghc in darwinports
14:28:10 <joelr1> is coarbitrary used automatically?
14:29:08 <joelr1> i.e. what's the effect if it's not present, i.e.     coarbitrary = undefined
14:29:23 <sjanssen> coarbitrary is used to generate arbitrary functions
14:30:11 <joelr1> sjanssen: generate? but i define them for each instance of arbitrary!
14:30:32 <sjanssen> so if one of your properties takes a (MyType -> MyType), you'll need to write a coarbitrary
14:30:59 <joelr1> sjanssen: i see. it's used if a property takes a function then?
14:31:03 <SyntaxNinja> is haskell.org down?
14:31:13 <sjanssen> joelr1: it doesn't generate code for the 'arbitrary' function, it generates random functions to supply to properties
14:31:16 <sjanssen> joelr1: correct
14:31:27 <joelr1> sjanssen: hmm
14:31:43 <sjanssen> SyntaxNinja: seems to be down from here
14:31:57 <joelr1> sjanssen: so i can leave coarbitrary = undefined until i get an undefined exception from prelude then?
14:32:22 <araujo> yeah, looks down
14:32:47 <joelr1> i wonder why QC sets coarbitrary to undefined for Char and Maybe a
14:33:03 <sjanssen> joelr1: sure.  It's probably better to use coarbitrary = error "no coarbitrary for MyType" to help you track down the error later
14:33:12 <SyntaxNinja> thanks
14:33:27 <sorear> joelr1: because QC is b0rken
14:33:35 <joelr1> sorear: i see
14:33:55 <sorear> joelr1: the lack of coarbitraries is a bug (on trac already)
14:34:08 <joelr1> fair enough
14:34:14 <roconnor> is there a haskell probability library?
14:34:25 <joelr1> @localtime araujo
14:34:27 <lambdabot> Local time for araujo is Wed Apr  4 17:28:07
14:34:35 <araujo> hello joelr1
14:34:45 <joelr1> araujo: hmm... i thought you were in spain :) hi!
14:34:49 <sorear> roconnor: like PFP?
14:34:52 <araujo> :-)
14:35:26 <roconnor> @where PFP?
14:35:27 <lambdabot> I know nothing about pfp?.
14:35:28 <stepcut> roconnor: see also, http://www.randomhacks.net/articles/2007/02/21/refactoring-probability-distributions
14:35:30 <roconnor> @where PFP
14:35:30 <lambdabot> I know nothing about pfp.
14:35:31 <lambdabot> Title: Refactoring probability distributions, part 1: PerhapsT, http://tinyurl.com/ythywo
14:35:41 <stepcut> http://web.engr.oregonstate.edu/~erwig/pfp/
14:35:43 <lambdabot> Title: PFP - Probabilistic Functional Programming in Haskell
14:36:16 <Cin> hi. does GHC support threads on Windows? it seems haskell.org is dead at the moment.
14:36:24 <sjanssen> Cin: yep
14:36:29 <Cin> sjanssen, thanks.
14:42:56 <dylan> dons: the dwm author seems to think you're hiding code in X11-extras to make xmonad smaller.
14:43:09 <dylan> sjanssen: ^
14:43:33 <dylan> he can't believe you can make a window manager <400 lines otherwise. XD
14:43:42 <sjanssen> dylan: yeah, dons set him straight on that
14:43:55 <sjanssen> and the 400 lines thing isn't true anymore
14:44:02 <sorear> anselm knows about xmonad?
14:44:22 <araujo> news spread fast
14:44:31 <sjanssen> sorear: somebody posted it to the dwm mailing list
14:44:48 <araujo> sjanssen, how many more lines does it have?
14:44:49 <glguy> so after hearing the news, did he toss his C compiler out and pick up a Haskell book?
14:45:45 <sjanssen> araujo: sitting at 469 right now
14:45:51 <araujo> Ok
14:46:12 <araujo> just do some point free functions
14:46:13 <sjanssen> I think 600 is a reasonable final number
14:46:13 <araujo> :-P
14:46:43 <sjanssen> 600 after adding float mode and statusbar
14:46:49 <araujo> nice
14:47:03 <joelr1> folks, one more QC question... how do i write a string generator that creates strings starting with a given char set (first char), of up to N characters in length and where the tail is of another charset?
14:47:19 <araujo> i think it's nice if you keep it just <1000
14:47:27 <joelr1> to generate variable names, for example
14:49:08 <araujo> joelr1, returning them as tuples?
14:49:21 <SamB_XP> newtype!
14:49:25 <joelr1> araujo: returning them as tuples? no, i mean generating the string itself
14:49:58 <SamB_XP> why do I want to answer joelr1's question in Parsec?
14:50:45 <joelr1> SamB_XP :D
14:50:56 <joelr1> SamB_XP: i'm already using parsec
14:51:07 <joelr1> SamB_XP: now i need to feed it something
14:51:08 <SamB_XP> joelr1: it wouldn't work
14:51:13 <joelr1> which should have proper variable names
14:51:28 <joelr1> SamB_XP: yes, it would. i random-generate the AST and then pretty-print it
14:51:40 <araujo> joelr1, your question is about how to convert between different charsets?
14:51:50 <araujo> well, there is libs for it around
14:51:58 <araujo> there are*
14:51:59 <SamB_XP> I just *want* to answer it in Parsec. I did not say that I *could*
14:52:13 <joelr1> he
14:52:25 <SamB_XP> it would be nice if you could run it backwards ;-)
14:53:38 <araujo> joelr1, something like, data C = C UTF8 String ?
14:54:27 <SamB_XP> araujo: you are confusing charsets with encodings
14:54:42 <SamB_XP> araujo: when joelr1 says charsets, he means *sets of characters*
14:54:48 <joelr1> araujo, SamB_XP: sorry, i did not expres myself clearly enough
14:55:16 <joelr1> i meant to say where the first symbol starts with alpha and the tail can be one of '_' or alpha
14:55:26 <joelr1> and where the whole string is, say, up to 20 chars
14:55:26 <SamB_XP> he wants to generate things like [A-Z][A-Za-z0-9_]*
14:55:32 <joelr1> SamB_XP: right on
14:55:34 <sjanssen> is there a 'choose' combinator?
14:55:37 <sjanssen> @hoogle choose
14:55:37 <lambdabot> Test.QuickCheck.choose :: Random a => (a, a) -> Gen a
14:55:53 <joelr1> a generator for QC
14:56:01 <araujo> hah ok
14:56:07 <sjanssen> do first <- choose ('a', 'z'); ...
14:56:24 <araujo> SamB_XP, *
14:56:29 <araujo> Ok :-P
14:57:03 <joelr1> sjanssen: what about combining the head with the tail? i.e. head a-z but tail _ or a-z
14:57:11 <joelr1> and limiting the overall length
14:57:28 <sjanssen> I dunno
14:57:34 <joelr1> i know sized $ \n can be used to limit length but i'm not sure where exactly to plug it in
14:57:40 <joelr1> i guess i have to keep experimenting
15:02:53 <sorear> Well, I think I've learned enough from builder hacking to start work on my binary-competitive pretty printing lib now :)
15:07:05 <joelr1> sorear: what's builder?
15:07:20 <sorear> Data.Binary.Builder
15:07:23 <joelr1> sorear: and what's wrong with regular pretty-printing?
15:07:51 <sorear> Ross Paterson and Lennart kolmodin 's ultra-tuned bytestring construction library
15:08:10 <sorear> Well, lots of strings
15:08:12 <joelr1> sorear: oh, you mean to specify the format of a binary? /going to look at the lib/
15:08:22 <joelr1> sorear: did you hack the library or just use it?
15:08:37 <sorear> Binary serialization has a reputation for being much faster than text serialization.  I want to fix this.
15:09:02 <sorear> joelr1: actually hacking it, intuition-building exercise.
15:09:26 <joelr1>  sorear: can't find builder...
15:09:30 <joelr1> in tests anyway
15:09:38 <sorear> I'm still pretty shocked I was able to improve on the rossp/kolmodin builder by 20x...
15:09:42 <sorear> it would be in src
15:09:58 <joelr1> sorear: wow! 20x! how did you do it?
15:10:39 <joelr1> inquiring minds wanna know!
15:11:50 <sorear> lots of little wierd things
15:11:59 <sorear> I'm also working on a ml post
15:12:06 <kolmodin> sorear: I'm impressed! I'd like to hear more when it's not midnight
15:12:11 <kolmodin> ?localtime kolmodin
15:12:14 <lambdabot> Local time for kolmodin is Thu Apr  5 00:09:43 2007
15:12:20 <sorear> Ten things I learned from my first serious attempt at low level haskell coding
15:12:25 <phoniq> what a slick bot
15:12:43 <joelr1> sorear: did you look at the core output?
15:12:49 <joelr1> sorear: how did you tackle profiling?
15:13:04 <joelr1> sorear: how did you wrestle strictness down?
15:13:09 <sorear> joelr1: a little bit, but mostly, I wrote a benchmark script
15:13:14 <sorear> edit -> compile -> time
15:13:45 <joelr1> that must have been tedious then
15:14:05 <joelr1> you must have known in what direction to dig then
15:14:07 <joelr1> how?
15:14:25 <sorear> Random walking :)
15:14:45 <sorear> a lot of very obvious pessimizations were wins, and vice versa
15:16:25 <joelr1> kudos to sorear
15:16:51 <joelr1> kolmodin: did you guys ever get to erlang-style patterns on binaries?
15:16:55 <sorear> I find it pretty amazing that I only got one segfault from the haskell.
15:17:14 <sorear> Meanwhile, I wrote a C test program so I would have something to compare against
15:17:17 <sorear> 20 lines of C
15:17:25 <sorear> segfaulted the very first run
15:17:35 <sorear> 20 lines of *unclever unoptized* C
15:18:50 <joelr1> sorear: i ... had a lot of trouble with haskell at one point in time... hehehe
15:19:05 <joelr1> i was probably the champion ghc crasher
15:19:17 <joelr1> that was a year ago, though
15:19:20 <Lemmih> sorear: ETA on that mail?
15:19:44 <ddarius> Lemmih has found his 'L'
15:19:49 <sorear> 20minutes if no more distractions come up :)
15:20:21 * joelr1 shuts up
15:23:06 <kolmodin> joelr1: we haven't got to that yet with binary. someone else has though, not with binary..
15:23:09 <beelsebob> sorear: for completeness's sake, want to see the version with the obvious when you see it refactoring?
15:23:16 <sorear> sure
15:23:33 <joelr1> kolmodin: not sure i understand how doing it _not_ with binary would be useful
15:23:34 <hpaste>  beelsebob pasted "Obvious when you see it refactoring" at http://hpaste.org/1260
15:24:32 <kolmodin> joelr1: same here! :D
15:24:48 <kolmodin> joelr1: but it was done before binary, remember it's only a few months old
15:25:40 <joelr1> kolmodin: right
15:30:55 <klam> need these gone    2 dell xps m1710 350 for one 500 for 2, 1 apple macbook black for 600 MSN Solutions1981@hotmail.com or aim: solutions1981
15:31:18 <Lemmih> ?slap klam
15:31:19 * lambdabot slaps klam
15:31:46 <ddarius> beelsebob: Now abstract everything to use a monad.
15:31:51 <opqdonut> ?slap Lamperi
15:31:52 <lambdabot> why on earth would I slap Lamperi
15:31:57 <opqdonut> :/
15:32:07 <beelsebob> ddarius: *no*
15:32:14 <beelsebob> ddarius: monads are *bad*
15:32:19 <beelsebob> they abstract *too* far
15:32:31 <beelsebob> the point of an abstraction is to make the objective *more* clear, not less so
15:33:55 <ddarius> You don't want to be able to turn a non-deterministic parser into a deterministic one with just a change of a type?  Also, the code would actually be clearer as it would abstract away from fairly irrelevant implementation details.  I'm not saying present a monadic interface.  But failing that, at least use list comprehensions instead of those concatMaps.
15:34:33 <klam> need these gone    2 dell xps m1710 350 for one 500 for 2, 1 apple macbook black for 600 MSN Solutions1981@hotmail.com or aim: solutions1981
15:34:49 <beelsebob> the concat maps were actually a transformation from list comprehensions to make it a better example for a paper ddarius
15:34:59 <beelsebob> but in the mean time, the parser combinators are irrelant
15:35:09 <beelsebob> the parser is 3 lines at the bottom
15:35:15 <beelsebob> and it really couldn't be made clearer
15:35:54 <ddarius> beelsebob: As I said, I didn't say change the interface, I was talking purely about the implementation.  What's the paper on?
15:36:28 <beelsebob> ddarius: debugging functional programs
15:36:32 <sorear> I was under the impression this was going to go into  a research paper for a haskell-like language w/o type classes?
15:36:32 <sorear> ddarius: you weren't here whan this all started I take it?
15:36:34 <sorear> <*hpaste>  beelsebob pasted "Removing list comprehensions" at http://hpaste.org/1253
15:36:36 <sorear> * beelsebob pokes people with that
15:36:38 <sorear> <beelsebob> Any nice ideas on how else you might remove list comprehensions from that?
15:37:00 <beelsebob> sorear: indeed it is
15:37:13 <beelsebob> although it works for type classes
15:37:22 <beelsebob> and in fact shows great promise for debugging monads
15:37:30 <beelsebob> but that was not the point the example was meant to be demonstrating
15:38:06 <beelsebob> ddarius: my personal opinion is that the monad abstraction is an entirely pointless one
15:38:14 <beelsebob> it is only useful if it being a monad means something
15:38:18 <beelsebob> and it really doesn't in this case
15:38:34 <beelsebob> I gain nothing useful towards my understanding of the code by knowing it's a monad
15:39:09 <sorear> I was under the impression monads are mostly for code reuse.
15:39:36 <sorear> The age of monomorphic `thenIO_` are behind us.
15:39:44 <ddarius> beelsebob: The operations of a MonadPlus have inherent meaning to them, which is why there are multiple types that implement them.  Again, I was not saying you should present a monadic interface, but that some of your code is better represented using monads.
15:40:26 <ddarius> Essentially, all I wanted was (++) -> mplus, concatMap -> (>>=), (:[]) -> return, and no doubt a few others.
15:40:29 <beelsebob> ddarius: sure, they have inhearent meaning -- but that meaning is not relevant to parser combinators, in fact, it's only really relevant if you're writing some fun category theory stuff
15:40:45 <beelsebob> I don't get an understanding of how parser combinators work by understanding category theory
15:40:51 <beelsebob> so it's pointless to use the monad abstraction
15:41:08 <ddarius> beelsebob: Actually, in Category Theory they have less inherent meaning.  But, I'm not referring to category theory at all.
15:41:53 <ddarius> beelsebob: mplus virtually always means "choose either of these", (>>=) virtually always means "this and then that"
15:41:59 <ddarius> return "success"
15:42:04 <ddarius> mzero "fail"
15:42:13 <dcoutts> @yarr
15:42:13 <lambdabot> Yarrr!
15:42:14 <beelsebob> ddarius: but that's exactly my point "virtually always means"
15:42:15 <dcoutts> g'night kolmodin
15:42:16 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
15:42:18 <beelsebob> it doesn't always mean that
15:42:30 <beelsebob> it doesn't give me any information at all
15:42:42 <ddarius> beelsebob: To some extent they do.
15:42:47 <beelsebob> it just so happens that this is one of the better cases where it doesn't lead me down the garden path!
15:43:09 <ddarius> For example, the algebraic laws they satisfy are part of the laws you'd associate with those interpretations.
15:43:14 <beelsebob> dcoutts: welcome, we're yet again having an argument about why I think monads are an idiotic abstraction 90% of the times they're used
15:43:58 <beelsebob> in the mean time... I have a paper to write
15:44:55 <dcoutts> beelsebob: heh :-)
15:45:09 <beelsebob> :)
15:45:26 <dcoutts> beelsebob: what should we be using half the time? parameter passing, monoids, applicative functors ?
15:46:00 <beelsebob> dcoutts: so far most of the cases *I've* come across, have been solved by a small amount of parameter passing, and a lot of continuation passing
15:46:06 <beelsebob> (no not using the Cont monad)
15:46:12 <beelsebob> but that's a fairly biassed stand point
15:46:20 * dcoutts dislikes the use of Monad m = m purely for being able to return errors
15:46:36 <beelsebob> dcoutts: note, most of my argument is that it's often a bad idea to abstract at all
15:46:49 <beelsebob> 90% of the times monads are used it's to abstract something too far
15:46:50 <dcoutts> ohh, controversial ;-)
15:47:04 <beelsebob> so far in fact that the code becomes completely meaningless
15:47:13 <dcoutts> it is a danger
15:47:13 <beelsebob> (to the casual reader)
15:47:58 <Philippa> the casual reader needs to know which monad's being used, big deal
15:47:59 <sorear> > ap zip tail [0..]
15:48:01 <lambdabot>  [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12...
15:48:03 <sorear> yay monads!
15:48:16 <beelsebob> sorear: I think you just proved my point
15:48:25 <beelsebob> reading that code I haven't a fucking clue what it will do
15:48:36 <ddarius> "Given the results of the previous section, one may wonder whether there is any real difference between monads and CPS."
15:48:54 <sorear> CPS = Code Perversion System?
15:49:05 <sorear> (cont. passing style I know)
15:49:32 <Philippa> the existance of monad transformers
15:49:41 <Philippa> beelsebob: I'd rate that as daft/wanky code myself, FWIW
15:49:51 <beelsebob> hehe :D
15:51:32 <ddarius> beelsebob: As Philippa said, the output of @pl or imitations thereof, are not representative of monadic code.  Also, using an ADT instead of (->) directly and slightly better names would make that more sensical.
15:52:21 <Philippa> right. The names should generally represent the constrained CPS that the monad supports
15:53:57 <sorear> Just don't take sane naming too far.
15:53:58 <Philippa> parameter and continuation passing smell in approximately the same way general recursion smells
15:54:24 <beelsebob> Philippa: a lot nicer than a Haskell programmer's monads?
15:54:26 <beelsebob> :P :D
15:54:34 <sorear> Rest assured I will not likely use 'parseConcatenationOfNondeterministicStringParsers'
15:54:58 <sorear> now, liftM2 (,) ...
15:55:07 <sorear> that I'll consider
15:55:30 <beelsebob> sorear: but liftM2 (,) means nothing
15:55:36 <beelsebob> it tells me nothing about what I'm doing
15:55:40 <beelsebob> I don't even know that I'm parsing
15:55:46 <beelsebob> let along dealing with concatination
15:55:58 <Philippa> beelsebob: that's the thing though - no. Monads're the equivalent of a combinator capturing a recursion pattern here
15:56:12 <Philippa> okay, the monad implementation probably does a lot of CPS and probably stinks...
15:56:18 <Philippa> GADTs + fusion are nifty there
15:56:35 * beelsebob must do washing up
15:56:38 <beelsebob> bbfn
16:01:16 <ddarius> You missed your chance to kick someone, Pseudonym.
16:01:44 <Pseudonym> Dammit.
16:01:58 --- mode: ChanServ set +o Pseudonym
16:02:03 <Pseudonym> I'm ready for next time!
16:02:50 <ddarius> beelsebob: First, that's no argument against using it in your implementation.  Second, the idea would be to understand each monadic value as an action in a language, then liftM2 (,) means execute each action and pair the results.
16:03:13 --- mode: Pseudonym set -o Pseudonym
16:04:32 <Philippa> I have to admit I'd find that nicer if (,) were pair, and nicer still if you could write l `liftM2 pair` r
16:04:56 <Philippa> I used liftM for the first time in ages in a parser a while back though
16:05:10 <sorear> And nicer still if they implemented the categorical syntax for applicative functors.
16:05:11 <beelsebob> ddarius: 1) yes there is, there's no argument *for* doing it, and therefore it's a pointless abstraction that impedes understanding 2) I don't want to understand monadic values, I want to write understandable parser combinators 3) I don't want to have to understand a different meaning for something with the same name lots of different times... The point of classes is that the functions have the same meaning for different types, not different meanings
16:05:20 <Pseudonym> In general, it'd be nice if you could backquote expressions.
16:05:22 <beelsebob> (back)
16:05:29 <Pseudonym> I agree.
16:05:45 <Philippa> and they have the same meaning in exactly the same way that + and * do
16:06:04 <phoniq> > [0,(0.1)..1]
16:06:06 <lambdabot>  [0.0,0.1,0.2,0.30000000000000004,0.4,0.5,0.6,0.7,0.7999999999999999,0.899999...
16:06:25 <Philippa> it's also not 'pointless' when it gives us a firm base for building new abstractions
16:06:29 <Philippa> which is very much does
16:06:57 <Philippa> which I admit doesn't apply directly to your parsing case - what does apply is getting to make use of everyone's pre-existing knowledge about monads
16:07:57 <ddarius> beelsebob: Re 1) code reuse.  Re 2) see 1 and 3 Re 3) You are understanding -one- meaning that can be used in many context, i.e. exactly the point of classes according to you.
16:08:08 <sorear> Lemmih: which list?
16:08:34 <beelsebob> ddarius: you just had to explain a meaning to me specific to my context -- that's a different meaning for each type, not the same
16:08:59 <Lemmih> sorear: libraries@ & haskell-cafe@?
16:08:59 <Philippa> he didn't have to, he chose to
16:09:04 <ddarius> How is, "Execute each action and pair the results" specific to your context?
16:09:07 <sorear> Type classes are a very powerful tool for introducing context sensitive operations in Haskell.
16:09:16 <beelsebob> Philippa: yes, but I wouldn't have had a clue what was going on with it if he didn't
16:09:31 <sorear> If you don't want the meaning of liftM2 to be context sensitve, go back to Miranda :)
16:09:46 <Philippa> yes, but you've already admitted to hating monads and I suspect wouldn't take great offence if I suggested you're not particularly good with them
16:09:46 <ddarius> beelsebob: That's because "I don't want to understand monadic values"
16:10:22 <Philippa> there's a really simple solution to /that/, too: pretend for a moment that "thunk for an a" is a different type to a
16:10:54 <Philippa> (alternatively, work for a moment in a language where that's the case - a laziness monad drops out naturally, in fact)
16:11:37 <Philippa> we can ignore the distinction when doing pure work, but if you want to think impurely you can't - no big surprise there
16:12:41 <Philippa> you'd absolutely vomit if I talked enough about some of the things I've figured out I could do with the end-result of the SoC Parsec proposals
16:13:05 <sorear> Philippa: is it likely to be worse than my hacked builder?
16:13:12 <Philippa> but that's a purity issue
16:13:18 <Philippa> sorear: don't think I've seen that?
16:13:20 <sorear> realWorld# is faster than actually threading state!
16:18:50 <dcoutts> sorear: and most of the time the continuation gives you the data dependency you need to keep it single threaded
16:20:58 <ddarius> joelr1: There's little you can't do with TH.
16:21:19 <joelr1> ddarius: i know, the question is how :) so much to learn, so little time
16:21:30 <joelr1> ddarius: want to finish rewriting my parser from ocaml this week
16:24:40 <ihope> What does block buffering accomplish?
16:24:45 <ddarius> joelr1: Skimming your problem: What you would do is make a list representing parts of the code you want to generate that differ, e.g. reserved word/arity pairs or whatever is relevant.  Then you'll write a TH function to generate the code from that list.  To write that function, you use runQ [| ... |] >>= print to see what the code should look like for well-chosen examples, then just generalize from there.
16:24:52 <ddarius> ihope: Performance.
16:25:12 <ddarius> ihope: Data is read from the handle in blocks.
16:25:47 <ihope> ...I see, maybe.
16:26:24 <joelr1> ddarius: it would extremely help if you could reply with a small example of how i would do that. i don't know TH at all
16:26:46 <sjanssen> ihope: making calls into the operating system is expensive, so it's better to reduce them
16:26:50 <sorear> I can do this with Data.Derive
16:27:13 <sjanssen> in a block buffering scheme, you reduce the number of system calls you make by a constant factor (the size of the buffer)
16:27:15 <ihope> I see.
16:30:53 <mauke> http://perl.plover.com/FAQs/Buffering.html
16:30:55 <lambdabot> Title: Suffering from Buffering?
16:34:26 <ddarius> @index Syntax
16:34:27 <lambdabot> bzzt
16:34:34 <ddarius> @index runQ
16:34:35 <lambdabot> Language.Haskell.TH.Syntax, Language.Haskell.TH
16:50:39 <sorear> @where derive
16:50:39 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/derive
16:58:08 <dons> ?users
16:58:08 <lambdabot> Maximum users seen in #haskell: 336, currently: 292 (86.9%), active: 36 (12.3%)
16:58:11 <dons> ?uptime
16:58:11 <lambdabot> uptime: 8h 45m 25s, longest uptime: 5d 3h 40m 45s
16:58:47 <sorear> hi dons
16:59:54 <sorear> What's the password on the SoC-trac?
17:00:06 <sorear> I've found a typo and guest/guest isn't working
17:01:00 <dons> hmm. not sure. i think its normal account logins.
17:01:07 <dons> so you'd have to log in as sorear
17:01:39 <sorear> Only nickserv and hpaste know me as that.  I have no trac account.
17:02:09 <dons> maybe it is time to get one! :-)
17:02:43 <sorear> How do I do that?
17:02:59 <sorear> I thought that fell under the capacity of "never ask for power"
17:03:18 <sorear> you see, I'm so helpless in lift I have to actually READ netiquette guides :)
17:03:23 <sorear> s/lift/life
17:04:10 <dons> its ok being helpless in the lift. trained emergency staff will be there shortly to assist.
17:05:37 <sorear> If I'm in a lift I'm already hundreds (thousands?) of miles from home... will they help me get back?
17:06:43 <dons> they will do their best. our trained response team will help you catch a bus.
17:07:02 <dons> you don't have lifts in california?
17:07:09 <sjanssen> elevators.
17:07:34 <dons> ah, of course!
17:07:58 <dons> and you live in apartments, not flats, I presume? :-)
17:08:03 <sjanssen> naturally
17:08:14 <sorear> What are the naming conventions for trac user names?
17:08:22 <dons> i'm 'dons' on trac.
17:08:52 <sorear> that only makes is more confusing, since they have a PhilippaCowderoy
17:09:14 <dons> jcreigh: your window border patch cleans things up nicely for me.
17:09:14 <sjanssen> choose whatever makes you happy
17:09:20 <ddarius> Several thousands.
17:09:21 <sjanssen> I'm sjanssen
17:09:26 <dons> jcreigh: want to see whether we can make the border colour a config setting?
17:10:06 <ddarius> Wie geht's, ekidd?
17:10:34 <ekidd> ddarius: Hello! I'm in the process of replacing my iBook battery.
17:10:42 <sorear> sjanssen: I don't want a repeat of the Haskell Wiki, where I registered 'Stefan' than discovered of Ljungstrand, Monnier, Holdermanns, ... the next day :)
17:11:32 <ddarius> So use sorear.
17:11:52 <ddarius> ekidd: Sounds like fun for the whole family.
17:12:55 <ekidd> ddarius: If all goes according to plan, this should boost my battery life from 1.5 to ~8 hours. More Haskell hacking!
17:17:50 <procyon112> Why don't my debug traces finish printing?  Is there a way to flush them?
17:19:41 <dons> hFlush stderr
17:20:07 <sjanssen> or hSetBuffering stderr NoBuffering
17:20:09 <dons> or set hSetBuffering on stderr to HotFlushes , sorry, unbuffered, at the start
17:21:03 <procyon112> ?hoogle hFlush
17:21:04 <lambdabot> IO.hFlush :: Handle -> IO ()
17:21:49 <sorear> procyon112: did you get my reply?
17:23:36 <procyon112> yes
17:24:39 <procyon112> hmm... shouldn't "trace (show bigList) (seq (hFlush stderr) doInfiniteLoop)" flush the bigList before looping?
17:25:03 <sjanssen> no
17:25:10 <sorear> seq (hFlush stderr) x === x
17:25:30 <sorear> since hFlush stderr is a partially applied function, thus in WHNF
17:25:57 <sorear> you need to pass it a State# RealWorld for the action to occur
17:26:12 <sorear> the portable way of doing that is unsafePerformIO
17:26:28 <SamB_XP> hooray dangerous portability!
17:26:44 <sorear> unsafePerformIO is actually pretty portable.
17:26:45 <procyon112> I'm debugging, so I'm not worried about portability :)
17:27:07 <sjanssen> procyon112: just do hSetBuffering stderr NoBuffering as the first step in your main
17:27:14 <sorear> SamB_XP: unsafePerformIO has been formally adopted by the haskell-98 committee.  Hierarchal modules haven't.
17:27:27 <SamB_XP> sorear: oh?
17:27:49 <dons> sorear: hmm?
17:27:53 <sjanssen> I've always wondered about that.  Why hasn't it been accepted
17:27:55 <SamB_XP> there is a non-hierarchical FFI API?
17:27:57 <sorear> SamB_XP: you need unsafePerformIO to make good interfaces to most foreign functions, so they rolled unsafePerformIO into the FFI spec
17:27:58 <dons> sorear: usafePerformIO is part of the FFI standard.
17:28:07 <procyon112> sorear: I'm not convinced that redirecting the arrow's left and right hand sides to a map lookup will solve the infinite loop... It seems it would just make it faster...
17:28:09 <dons> hier modules are part of the hier modules (draft) standard
17:28:11 <sorear> SamB_XP: yeah, import Foreign
17:28:23 <SamB_XP> sjanssen: I though the reason was "because there is no Haskell 98 committee"
17:28:26 <sorear> FFI is an accepted addendum iirc.
17:28:29 <dons> its not really anything to do with the h98 comittee, which doesn't exist.
17:28:50 <dons> ffi and hier modules are the only accepted addendums :-)
17:29:29 <sorear> procyon112: it lets you notice when you are revisiting visited nodes, which you'll do infinitely often in a cyclic graph
17:30:54 <dons> sorear: so do you have any patches to commit back into the binary builder code?
17:31:05 <dons> dcoutts and I were pondering your discoveries yesterday.
17:31:13 <dons> some quite interesting ideas there.
17:31:17 <dcoutts> ah yes
17:32:30 <procyon112> hmm. even with hSetBuffering stderr NoBuffering, I only get a partial list printout.
17:34:17 <procyon112> sorear: where am I revisiting nodes though?  I'm not seeing the line where that can happen.
17:34:31 <kolmodin> dons: try 'runGet getWord8 empty'
17:34:55 <dons> it fails, doesn't it?
17:35:02 <dons> since that's unchecked?
17:35:05 <kolmodin> dons: so hard you c'n belive it
17:35:07 <kolmodin> segfault
17:35:13 <kolmodin> aye
17:35:21 <dons> so that's a little surprising
17:35:21 <kolmodin> got a patch about it earlier today
17:35:25 <dons> cool
17:35:34 <kolmodin> yeah, but the patch suprised me
17:35:41 <dons> oh?
17:35:47 <kolmodin> -                       when (B.length now < n) $
17:35:47 <kolmodin> -                         fail "too few bytes"
17:35:47 <kolmodin> +                       () <- when (B.length now < n) $
17:35:48 <kolmodin> +                               fail "too few bytes"
17:35:53 <kolmodin> wtf?
17:36:00 <dons> hmm?
17:36:11 <dons> someone trying to force evaluation?
17:36:25 <procyon112> sorear: unify [] = [].  unify ((t1 t2):cs) | t1==t2 = unify cs... no revisits there.
17:36:42 <kolmodin> dons: yes
17:36:46 <dons> kolmodin: you should just fix it to do this test once at the start.
17:36:55 <kolmodin> dons: the weird part is that it worked
17:37:04 <dons> hmm.
17:37:14 <dons> lazy monads eh?
17:37:41 <kolmodin> something like that. my world was rocked a bit
17:38:29 <dons> ah well, better now than during the haskell workshop ;-)
17:38:35 <dons> (can you add a test for this too?)
17:38:38 <kolmodin> I really didn't they it'd make a difference
17:38:53 <kolmodin> dons: sure, I'll add one the next days
17:39:46 <procyon112> sorear: I may have just pegged it.
17:40:35 <kolmodin> the patch I got did enforce 'fail' on another place too, but I don't see how that's required
17:40:39 <kolmodin> this was on getBytes
17:41:07 <sorear> back.
17:42:27 <procyon112> sorear: nope.  I made it halting.. but incorrect :P
17:42:50 <sorear> procyon112: remember == probably doesn't do what you think it does
17:42:54 <kolmodin> dons: I'll look more into it when I'm more.. um... never mind
17:42:58 <kolmodin> ?localtime kolmodin
17:43:02 <lambdabot> Local time for kolmodin is Thu Apr  5 02:40:31 2007
17:43:04 <sorear> > let x = [0..] in x == x  -- this is true, right?
17:43:08 <lambdabot> Terminated
17:43:12 <kolmodin> (shit!)
17:43:35 <procyon112> sorear: oh.... that would be bad
17:44:25 <sorear> dons: that [patching builder] would be in direct conflict with my sinister plans.  Why speed binary when you can give a bigger number for Text.PrettyPrint.Leijen_FPS_CPS is x% faster than Data.Binary?  (kidding of course) :)
17:45:43 <dons> heh
17:46:45 <dcoutts> dons: you'll not make it in by 11... ;-)
17:46:58 <dons> grr.
17:47:03 <dons> ghc had to be restarted.
17:47:10 <dcoutts> :-(
17:47:18 <sjanssen> dcoutts the slave driver?
17:47:20 <dcoutts> you can let it build while you're on the train
17:47:23 <dcoutts> @yarr!
17:47:23 <dons> (-O2 is not good for partial builds getting restarted)
17:47:23 <lambdabot> Swab the deck!
17:47:29 <dons> dcoutts: indeed
17:47:39 <dcoutts> sjanssen: I'm the paper driver apparently
17:47:50 <dcoutts> ChilliX told me so :-)
17:47:54 <dons> dcoutts: go chase rl to write section 3.
17:48:00 <dons> yes, dcoutts is the official paper driver.
17:48:08 <dcoutts> dons: I will as soon as he gets in!
17:48:10 <sorear> you can't just build with: ssh serenety.cse.unsw.edu.au ghc --make -j20 ? :)
17:48:14 * dons is merely a bulid slave.
17:48:18 <sorear> that would be fast!
17:48:42 <sorear> (too bad we don't have -j)
17:48:59 <sjanssen> sorear: there's always ghc -M
17:49:30 <dons> yeah, ghc -j could just be a wrapper that dumps ghc -M and calls gnu make.
17:49:32 <sorear> The bad news is file-at-a-time is twice as slow as --make
17:49:38 <dons> hmm?
17:49:47 <sorear> the good news is it uses sixteen times as many cores!
17:49:56 <dons> it should be a bit faster, since the compiler space doesn't grow so badly
17:49:59 <procyon112> sorear: just fixing the == guard by expressing it with explicit pattern matches did not change anything.
17:50:19 <sorear> <*procyon112> sorear: unify [] = [].  unify ((t1 t2):cs) | t1==t2 = unify
17:50:35 <sorear> if t1 and t2 are infinite, and the same, that guard will diverge
17:50:41 <sorear> > [0..] == [0..]
17:50:46 <lambdabot> Terminated
17:51:27 <sorear> ghc does NOT take advantage of pointer equality in ==
17:51:57 <sjanssen> that'd be evil evil evli
17:52:12 <procyon112> sorear: right.  I got rid of the guard and replaced it with ((TVar, x):rest) | x==TVar = unify rest and ((TInt,TInt):rest) = unify rest
17:52:40 <resiak> sjanssen: why would it be so bad?
17:52:47 <sorear> procyon112: you need more than one TVar, else it's hardly a type system
17:53:08 <procyon112> sorear: I do :P  I was being concise
17:53:27 <sjanssen> resiak: because "let x = [0..] in x == x" and "[0..] == [0..]" should be the same thing
17:54:29 <sorear> procyon112: the fundamental problem is that you aren't checking for revisiting nodes
17:54:51 <sorear> if you try to unify  (a -> a)@a  and (b -> b)@b
17:54:59 <sorear> it sees that -> == ->
17:55:02 <dons> resiak: yeah, it would make equational reasoning much harder, since you can't just replace variable names with their definitions
17:55:21 <sorear> then it has ( (a -> a)@a, (b -> b)@b ) ( (a -> a)@a, (b -> b)@b )
17:55:26 <sorear> then it has ( (a -> a)@a, (b -> b)@b ) ( (a -> a)@a, (b -> b)@b ) ( (a -> a)@a, (b -> b)@b )
17:55:35 <sorear> then it has ( (a -> a)@a, (b -> b)@b ) ( (a -> a)@a, (b -> b)@b ) ( (a -> a)@a, (b -> b)@b ) ( (a -> a)@a, (b -> b)@b )
17:55:44 <sorear> and so on ad infinitum
17:55:50 <resiak> sjanssen, dons: doh, yeah, that makes sense
17:57:24 <procyon112> sorear: what does @ mean in (a->a)@a?
17:58:03 <sorear> I'm alluding to as-pattens
17:58:11 <sorear> (a -> a) @ a is:
17:59:05 <sorear>    lhs  /-\
17:59:05 <sorear>         | V
17:59:05 <sorear> ROOT => FUN
17:59:05 <sorear>         | ^
17:59:09 <sorear>    rhs  \-/
17:59:17 <sorear> get the picture? :)
17:59:45 * QtPlatypus doesn't.
18:00:25 <Lemmih> Is it some sort of rocket?
18:00:29 <QtPlatypus> How would I read "@"
18:00:38 <procyon112> sorear: yes
18:00:45 <procyon112> sorear: but then, shouldn't
18:00:48 <sorear> alternatively, M.fromList [(0, 0 :-> 0)]
18:00:49 <mauke> "as"
18:01:06 <sorear> procyon112: shouldn't?
18:01:21 <procyon112> Here's a constraint set then, that should send my unifier into non-halting:
18:01:50 <procyon112> [(a,a->a),(b,b->b),(a,b)]
18:02:02 <procyon112> But it doesn't... It's well behaved.
18:02:03 <sorear> let anInfiniteType = anInfiniteType :-> anInfiniteType in [(anInfiniteType , anInfiniteType)]  -- should do it
18:02:11 * sorear resolves
18:03:02 <procyon112> sorear: express that as a list of constraints... my solver doesn't do lets ;)
18:04:10 <procyon112> sorear: or native lists
18:05:42 <procyon112> sorear: got one that does it
18:05:56 <sorear> cool
18:06:41 <procyon112> unify [(a,b),(b,a),(a,a->a),(b,a->b)]
18:07:02 <procyon112> I'll try to diagnose that
18:07:23 <sorear> your checker has a very interesting approach ... not like mine in some important ways
18:07:43 <procyon112> sorear: Mine is pretty much straight out of TAPL chapter 22.
18:08:13 <sorear> Oh. Don't have that :)
18:08:21 <procyon112> Great book.
18:08:34 <sorear> and I've yet to understand a single description of a type inference algorithm
18:08:41 <procyon112> ^^ the (b,a) constraint is not needed to make it blow stack.
18:08:44 <sorear> I've invented plenty tough
18:09:44 <procyon112> sorear: TAPL makes it quite simple... It's not *easy*, but it's the best book/paper I've seen to explain all things type related.
18:10:41 <procyon112> I figure once I get through "The Art of Prolog" with TAPL under my belt, I will be ready to change my name to Oleg :)
18:13:48 <procyon112> Hmmm... [(a,a->a),(b,b->b),(a,b)] unifies, but if I move (a,b) to the head, it blows the stack....
18:14:32 <sorear> [(a,a->a),(a,a->a)] does NOT
18:16:34 <procyon112> sorear: does NOT unify you mean
18:16:51 <procyon112> sorear: cuz it *does* blow the stack ;)
18:16:59 <sorear> right :)
18:17:21 <sorear> it steps to [(a->a, (a->a)->(a->a)]
18:17:34 <sorear> which steps (by decomposition) to
18:17:49 <sorear> [(a,a->a),(a,a->a)]
18:17:53 <sorear> look familiar? :)
18:18:09 <procyon112> yes
18:21:34 <sorear> how hard is TAPL?  harder than the implementation of functional programming languages?
18:22:48 <procyon112> sorear: Implementation of PL: a tutorial, or his other implementation of programming languages that has type inferrence?
18:23:15 <sorear> his other implementation of functional programming languages
18:23:21 <sorear> the 500 page one
18:24:29 <procyon112> easier than the 500 page one.. harder than the 300 page one ;)
18:25:03 <procyon112> (the 300 page one, IFPL:A Tutorial doesn't deal with type inference)
18:25:43 <procyon112> TAPL is a gentler learning curve, and MUCH more comprehensive when it comes to type issues.
18:27:00 <procyon112> And covers Existential, dependant, subtyping, sum types, product types, F, Fc, Fw, and more. With implementation code in OCaml
18:28:27 <sorear> Fc?!
18:28:39 <sorear> that's a bit new
18:28:41 <sorear> >2000 iirc
18:28:47 <sorear> isn't tapl 1996?
18:29:23 <procyon112> er.. not Fc.  and no, it'
18:29:27 <procyon112> it's 2002
18:29:46 <procyon112> F, Fw, F<: and F<:w
18:30:50 <procyon112> Where F<:w has <: as a subscript and w as a superscript to F :)
18:31:56 <Pseudonym> @yow
18:31:57 <lambdabot> My CODE of ETHICS is vacationing at famed SCHROON LAKE in upstate New
18:31:57 <lambdabot> York!!
18:32:04 <Pseudonym> IRC + typography don't mix.
18:32:30 <sorear> well, it's a book on types, so...
18:32:31 <mwc> Pseudonym, use the latex notation
18:34:06 <sjanssen> > null [undefined :: Integer ..]
18:34:08 <lambdabot>  False
18:35:25 <sjanssen> > null [undefined :: Int ..]
18:35:27 <lambdabot>  Undefined
18:36:38 <sjanssen> @tell dcoutts how does the new list stuff handle enumFrom undefined, where undefined is Int or Integer?
18:36:38 <lambdabot> Consider it noted.
18:37:19 <Pseudonym> > [ 2^31-2::Int ..]
18:37:21 <lambdabot>  [2147483646,2147483647]
18:37:31 <Pseudonym> sjanssen: Does that answer your question?
18:38:01 <sjanssen> Pseudonym: yes, I understand why Int is that way
18:38:19 <Pseudonym> And you understand why Integer isn't.
18:38:20 <sjanssen> I'm wondering whether it's reasonable to give Integer the same strictness
18:38:58 <sjanssen> making enumFrom :: Integer -> [Integer] lazy is just a space leak waiting to happen
18:39:03 <mwc> Hmmm, Haskell is 17 now?
18:39:07 <sorear> No, it happened.
18:39:27 <sorear> I used last [0..]  as a do-nothing-in-constand-space-forever op.
18:39:36 <sorear> Kaboom.
18:39:57 <sjanssen> I've seen it before, for what it's worth
18:40:08 <dcoutts> sjanssen: you mean is it strict or not?
18:40:08 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
18:40:33 <sjanssen> dcoutts: yes, is enumFrom :: Integer -> [Integer] strict?
18:42:25 <beelsebob> =====================================================================================================================================================================================================================================================================================================================================================================================================================================================
18:42:31 <dcoutts> sjanssen: the current base definitions are strict for Int, our stuff doesn't change that but we coulld do easily
18:43:17 <Pseudonym> Honestly, though.  Generally, if you use an enumFrom* operation, it's generally because you want the elements in the list.
18:43:22 <sjanssen> dcoutts: yes, Int should be strict.  But what about Integer (note that base makes it lazy)?
18:43:35 <Pseudonym> I don't see any advantage to making it strict.
18:43:38 <dcoutts> sjanssen: technically it should be non-strict for Int too
18:43:45 <dcoutts> Pseudonym: makes it a tad quicker
18:43:59 <Pseudonym> dcoutts: I guess.
18:43:59 <dcoutts> Pseudonym: for Int at least since it can be unboxed
18:44:04 <sjanssen> dcoutts: I don't see how that is possible, remember it has to do bounds checking
18:44:10 <Pseudonym> OK, exercise:
18:44:10 <dcoutts> for Integer there is no such advantage
18:44:23 <Pseudonym> Come up with an Enum type for which it doesn't make sense to make enumFrom* strict.
18:44:26 <bd_> dcoutts, there's a reason for it to be strict
18:44:27 <dcoutts> since it's not unboxable
18:44:37 <bd_> > enumFrom 1 !! 1000000 :: Integer
18:44:40 <lambdabot>  Exception: stack overflow
18:44:43 <bd_> > enumFrom 1 !! 1000000 :: Int
18:44:45 <lambdabot>  1000001
18:44:53 <Pseudonym> bd_: If you write that, you deserve what you get.
18:44:54 <sjanssen> dcoutts: not unboxable today.  It might be unboxable in the future
18:45:02 <dcoutts> sjanssen: true
18:45:09 <bd_> Pseudonym: True, but people have been surprised in the past
18:45:14 <sorear> dcoutts: Integer *can* be unboxed
18:45:22 <sorear> not automatically
18:45:32 <sjanssen> as far as I can tell Integer is the *only* Enum instance where enumFrom isn't strict
18:45:41 <bd_> sjanssen: Also Double I think
18:45:43 <bd_> > enumFrom 1 !! 1000000 :: Double
18:45:45 <Pseudonym> bd_: Remember this only came up when sjanssen wanted a constant-space infinite loop, and was surprised when that didn't happen.
18:45:46 <lambdabot>  Exception: stack overflow
18:45:56 <bd_> heh
18:45:59 <sorear> Pseudonym: actually sorear
18:46:02 <sjanssen> > null [undefined :: Double ..]
18:46:03 <lambdabot>  False
18:46:04 <Pseudonym> Ah, yes.
18:46:06 <dcoutts> sjanssen: anything that doesn't override the enumFromTo but uses the default will be lazy
18:46:09 <Pseudonym> Sorry.
18:46:17 <dcoutts> since the Enum default impl is lazy
18:46:31 <Pseudonym> OK, I got one.
18:46:37 <Pseudonym> data Peano = Zero | Succ Peano
18:46:38 <sjanssen> dcoutts: I think you're incorrect.  derived instances of Enum do bounds checking
18:46:44 <Pseudonym> Define the "obvious" enum instance.
18:47:06 <Pseudonym> It doesn't always make sense for enumFrom* to be lazy on Peano.
18:47:08 <dcoutts> sjanssen: hmm ok, I'd have to look in more detail
18:47:16 <sjanssen> > null [undefined :: Bool ..] -- proof for dcoutts
18:47:18 <lambdabot>  Undefined
18:47:19 <Pseudonym> Because you can peel off Succs from an undefined just fine.
18:48:10 <dcoutts> sjanssen: ah, that's because they're defined in terms of enumFromTo for Int, and that is strict
18:48:33 <sjanssen> dcoutts: they have to be strict, otherwise they wouldn't work
18:48:42 <sorear> dcoutts:
18:48:42 <sorear> enumFromLargeInteger :: Int# -> ByteArray# -> [Integer]
18:48:42 <sorear> enumFromLargeInteger l# ba# = case int2Integer# 1# of (# l2#, ba2 #) -> J# l# ba# : (case plusInteger# l# ba# l2# ba2# of (# l3#, ba3# #) -> enumFromLargeInteger l3# ba3#
18:49:02 <dcoutts> sjanssen: I don't see why
18:50:05 <sjanssen> dcoutts: enumFrom terminates after the largest element, how can you do this lazily?
18:50:27 <sjanssen> well, I guess the implementation could always yield at least one cons cell, but that is pretty useless
18:53:04 <sjanssen> enumFrom x = x : if isMaxValue x then [] else enumFrom (succ x) -- is a lazier option
18:53:49 <dcoutts> sjanssen: hmm, good point
18:54:33 <dcoutts> yeah so it only need to check for the max bound when it increments
18:54:36 <sjanssen> that extra laziness is worthless though
18:54:52 <dcoutts> I'm not sure what the h98 report specifies for the strictness of enumFromTo
18:55:06 <dcoutts> the base has a note that the Int instance is indeed to strict
18:55:23 <procyon112> sorear:  I think I've got it!
18:57:10 <procyon112> sorear: The occurs check needs to stay, but instead of failing, if moves the constraint to the end of the list.  This makes the constraint still available for substitutions, but doesn't force it to traverse the constraint indefinitely.
18:57:24 <procyon112> sorear: so the guard becomes:
18:58:16 <procyon112> | tyX `occursIn` tyS = fmap (++[(tyX,tyS)]) $ unify rest
18:59:25 <sjanssen> dcoutts: the report says (referring to Int, Integer, Float, Double) "For all four of these Prelude numeric types, all of the enumFrom family of functions are strict in all their arguments"
18:59:43 * sjanssen goes to report the bug and write a patch
19:00:51 <dcoutts> sjanssen: ah ok, good
19:01:01 <sjanssen> yikes, Hugs is even worse.  null [undefined :: Int ..] == False in Hugs
19:01:56 <procyon112> sorear: yes.. this appears to be testing ok for everything I throw at it.
19:21:00 * sorear 's brain fills with swirling pointers...
19:24:59 <procyon112> night all
19:35:19 <sorear> @spell Patterson
19:35:21 <lambdabot> Patterson
19:35:23 <sorear> @spell Paterson
19:35:23 <lambdabot> Paterson
19:35:29 <sorear> aww, both valid
19:36:13 <sorear> ok, Paterson it is
19:37:29 <sjanssen> @spell Janssen
19:37:30 <lambdabot> Jansen Jensen Kansan Hansen Jasen
19:37:40 <sjanssen> I hate you
19:38:16 <dons> hehe.
19:38:26 <dons> @spell Spencer
19:38:27 <lambdabot> Spencer
19:38:34 <dons> Spencer Kansan, I like it!
19:39:32 <sorear> The algorithm intro I'm writing for my uber-fast pretty printing lib is start to sound a bit ... papery
19:40:52 <dons> sorear: you'll be pleased to know, one of the nobench programs now runs 159x faster with a new ghc optimisation rl added.
19:41:02 <sorear> nice.
19:41:02 <kc5tja_> @spell supercalifragilisticexpialidocious.
19:41:25 <sorear> dons: is this like a RULESy thing?
19:41:37 <dons> nah, static argument transformation
19:41:44 <sorear> nice
19:41:52 <sorear> will that fold 2^26?
19:41:54 <dons> fixes the 'atom' benchmark, which ghc has been losing to hugs on for 20 years.
19:42:22 <sorear> so when was this added?
19:42:31 * sorear intents to read the patch long description
19:42:34 <dons> its in our stream fusion branch of ghc.
19:42:42 <dons> so you'll have to wait to till the paper is done
19:42:53 <sorear> ouch, you branched all of gcc?  not just base?
19:43:05 <sorear> what did you have to change in the compiler proper?
19:43:41 <dons> too busy right now. deadline in 30 hours. read the paper to find out ;-)
19:43:54 <dons> new optimisations, in ghc. stuff in base too.
19:45:07 <sorear> so how badly do we want general computation and guards in rules?
19:46:00 <dons> not really. lightweight term rewriting does 98% of things we need.
19:46:54 <sjanssen> hmm, where might Hugs define instance Enum Integer?
19:46:55 * sorear also has an idea for adding inline C to GHC
19:47:01 <sorear> Hugs.Prelude maybe?
19:47:27 <sjanssen> oh, that isn't in base?
19:47:37 <kc5tja_> You creates of sheep!  Everyone knows, BCPL is the language of the future!  :D
19:47:43 <sorear> grep saves the day!
19:47:46 <sorear> /usr/src/hugs98-98.200503.08/libraries/hugsbase/Hugs/Prelude.hs:instance Enum Integer where
19:47:53 <sjanssen> please don't tell me I have to use CVS to fix this simple patch...
19:47:58 <sjanssen> s/patch/bug
19:48:27 <sjanssen> @google hugsbase
19:48:30 <lambdabot> http://osdir.com/ml/lang.haskell.cvs.hugs/2005-04/msg00000.html
19:48:30 <lambdabot> Title: cvs commit: hugs98/libraries/hugsbase/Hugs Array.hs Int.hs Prelude.hs Wo
19:48:42 <dons> yeah, there's a few other strictness bugs floating around
19:48:53 <dons> since StrictCheck et al are fairly new.
19:49:58 <dons> sjanssen: i note that tiled xmonad is perfect for doing 3 or 4 simultaneous ghc builds , and observing their progress
19:50:31 <sjanssen> :)
19:50:33 <c> or compiling dwm with different settings (say if youre on an 8086 and it takes 12 seconds)
19:51:17 <sjanssen> pssh, why would you build dwm if you've already got xmonad?
19:51:34 <c> does xmonad run on win32 yet?
19:51:41 <c> im longing for a proper wm on win32
19:51:54 <c> bblean can mostly be hacked to work like dwm, but its tiling plugin sucks
19:52:04 <dons> are there any unixy window managers that run on windows?
19:52:05 <sjanssen> xmonad would probably run on one of those X servers in windows
19:52:58 <glguy> you can use nearly any window manager with cygwin/X
19:53:06 <glguy> or do you mean directly instead of explorer?
19:53:32 <c> i mean i dont know the goals of xmonad
19:53:40 <sorear> I'd like to hack yi to use the xmonad/dwm layout algorith.
19:53:42 <c> but , it seems it could be abstracted away from X to work on win32, plan9, osux
19:53:50 <sorear> would anyone hurt me if I did that?
19:53:51 <dons> its a dwm clone, with some nicer features, in 400 lines.
19:53:52 <c> that is, if theres alternate WMs on osux and an API for them , besids X. (afaik there isnt, is there?)
19:54:44 <sjanssen> xmonad (and every X window manager, I imagine) is very X specific
19:57:20 <sjanssen> ARG talked about an API for window management on the dwm list recently
19:59:03 <sorear> does anyone but arg know the suckless wiki password?
19:59:28 <kc5tja_> sorear: only those with 80x25 screens.  ;D
19:59:54 <sorear> Oh well.  my screen is 128x48
20:00:13 <sjanssen> sorear: 128 still seems a bit tight
20:00:26 <kc5tja_> With the font that I use at work, it's 262x100 something.
20:00:35 <kc5tja_> People are always like, "How can you SEE anything?!"
20:00:53 <sorear> No, I care about legibility.
20:01:04 <sorear> I use the linux console because fixed is ugly
20:01:09 <kc5tja_> So do I.  I just happen to be able to read a 5x8 pixel font just fine.
20:01:23 <sorear> much, much, much, uglier than the intel rom font
20:01:47 <kc5tja_> I disagree, personally, but then, I did come up with my own 8x8 font that I'd like to expand to 8x16 for the PC.
20:02:15 <kc5tja_> I could write it in Forth in about a couple hours, but I am thinking of using Haskell for the practice.
20:02:40 <sorear> oh this sounds really easy
20:02:43 * sorear man psf
20:02:51 <sorear> just a little list processing
20:03:06 <kc5tja_> Nothing appropriate.
20:03:25 <kc5tja_> Is that the console font format, or the X11 format?
20:03:32 <sorear> fst
20:03:48 <sorear> and it turns out there's no manpage
20:03:50 <allbery_b> grah.  still can't solve my gtk2hs right-justified label issue
20:03:56 * sorear mg /usr/share/doc/console-tools/file-formats/psf
20:04:00 <kc5tja_> sorear: OK, I'm confused.  What are you talking about?
20:04:05 <kc5tja_> Oh, OK, just making sure.  :)
20:04:10 <kc5tja_> There is no list processing involved.
20:04:33 <allbery_b> okay, maybe I could use a textview... after figuring out how to make it match everything else in that part of the window instead of a white background, and using the rather more complicated API (since it's really an embedded editor window)
20:04:34 * kc5tja_ was going to read in the full 2KB binary image that I used for the Kestrel, scan double it, then spit it back out in the PSF.
20:05:02 <sorear> exactly - list processing.
20:05:12 <dcoutts> allbery_b: single line or multi-line ? have you used the x-align?
20:05:13 <kc5tja_> Well, more like ByteString processing.  :)
20:05:19 <sorear> [Word8]
20:05:19 <allbery_b> single line
20:05:34 <sorear> bytestrings are slower than strings when you have that little data
20:05:37 <allbery_b> I'm putting a number in it, I want it to be up to 5 digits and right-justified
20:06:01 <allbery_b> the justification attribute doesn't apply to single line labels; the x-align aligns the *widget* but not the text within it
20:06:02 <dcoutts> allbery_b: and have you set the packing so your label expand to fill the space available?
20:06:08 <jcreigh> dons: what, you don't like red? :)
20:06:10 <kc5tja_> sorear: Believe me, speed isn't the issue.
20:06:24 <allbery_b> as far as I can tell, gtk2 formats the next into a "box" whose alignment you cannot specify
20:06:26 <kc5tja_> For that little data, on an 800MHz box, even if it takes one second, I'm still happy.
20:06:37 <dcoutts> allbery_b: you can see how it all works interactively if you try it in glade
20:06:57 <allbery_b> I can right-justify the text that gets formatted into that "box", or the label that holds the "box", but the "box" itself is always left-justified
20:06:58 <sorear> ok, I just finished writing the scan doubler
20:07:00 <sorear> in haskell
20:07:10 <allbery_b> and yes, I've been mucking with this in glade as well
20:07:13 <kc5tja_> You don't even know the source image format.
20:07:21 <sorear> it's not psf?
20:07:28 <kc5tja_> No, it's for my Kestrel.
20:07:30 <sorear> if it was: interact (\(0x36:0x04:0:8:xs) -> 0x36:0x04:0:16:(xs >>= replicate 2))
20:07:33 <kc5tja_> I want to move it to the PC though.
20:07:38 <sorear> standard formats ftw!
20:08:03 <sorear> given that you're copying the nicities off it, does this mean the kestrel project is dead?
20:08:05 <kc5tja_> sorear: The format is pretty standard -- it's a raw, uncompressed, 2048x8 bitmap.
20:08:08 <sorear> would be a shame
20:08:40 <sorear> kc5tja_: so <data for char0> <data for char1> ...
20:08:41 <kc5tja_> sorear: No.  Quite the contrary; the whole reason I'm moving the font onto the PC is precisely because I *LIKE* the Kestrel's font.
20:09:01 <sorear> kc5tja_: where the data for each character is stored left-right top-bottom?
20:09:23 <dcoutts> allbery_b: your label needs to "expand" and "fill" and the x-align needs to be 1.
20:09:24 <kc5tja_> Right; take a 2048 pixel wide bitmap, draw all 256 characters onto it, then save it as a bitmap.
20:09:40 <kc5tja_> PSF is column-major in comparison.
20:10:17 <dons> woot,! http://www.haskell.org/pipermail/haskell-cafe/2007-April/024127.html
20:10:18 <kc5tja_> (the reason this layout was chosen is because it's the most natural font format for use in the ROM's drawing routines)
20:10:18 <lambdabot> Title: [Haskell-cafe] 25k lines of ASP to 4.2k lines of Haskell, with considerably more ..., http://tinyurl.com/yporof
20:10:20 <sorear> no, psf is left-right-top-bottom too
20:10:25 <dons> jcreigh: i guess red is ok.
20:10:44 <jcreigh> dons: I gues circular dependencies are out, huh?
20:10:45 <sorear> so kestrel is column major?
20:10:56 <sorear> psf is row major
20:11:02 <sjanssen> jcreigh: yes
20:11:10 <allbery_b> dcoutts: did all three.  the 0 that is specified as the default text in glade is still left-justified; likewise the actual data when I run the program
20:11:45 <sjanssen> jcreigh: I've noticed this annoying issue too.  It seems like every config (even the static stuff) has to be in XState, which is getting bloated
20:12:23 <dons> mod up! http://programming.reddit.com/info/1fh3p/comments
20:12:24 <lambdabot> Title: Haskell in the real world: building a commercial website in Haskell with WASH (r ...
20:12:31 <dons> (its been a while, and reddit has been sucking muchly)
20:12:46 <dcoutts> allbery_b: so you can see in glade that the label widget is wider than the text, the x-align is 1.0 and it still is at the far left of it's allocated space ?
20:13:05 <dcoutts> allbery_b: I tried what I said a second ago in glade and it works, I'm not sure what's going on
20:13:29 <kc5tja_> sorear: Dude, I just cannot find the format for this file.
20:13:40 <sorear> @remember AdamPeacock Once I looked at the source code, 25000 lines of ASP, I reckoned it would be easier to rewrite it in a real language.
20:13:41 <lambdabot> Done.
20:13:51 <allbery_b> the label widget has a width of 5 characters, this is visible in the window view.  the content "0" i left-justified
20:15:04 <jcreigh> sjanssen: is defaultLayoutDesc the only one like that, or are there others?
20:15:10 <sorear> kc5tja_: if it is 2048 bytes and uncompressed, there isn't much flexibility.  try my script (assumes char/row/col ordering, but that's the natural thing for a row-major display), if your screen is garbled then try the 5 other permutations
20:15:11 <allbery_b> http://www.ece.cmu.edu/~allbery/hwatchmwp.glade (hwatchmwp.gladep is also there if it matters)
20:15:30 <allbery_b> it's possible the installed version of glade here is buggy, but it looks like I set everything right
20:15:59 <sorear> display tubes have are row-major in a tradition that goes back to the days of Farnsworth
20:16:52 <sjanssen> jcreigh: defaultLayoutDesc is the only one right now
20:17:05 <jcreigh> everything was fine when you just had to edit Main.hs :)
20:17:08 <jcreigh> hmm.
20:17:30 <sjanssen> jcreigh: but grabkeys is stuck in Main.hs because it uses several variables in Config.hs
20:17:32 <dcoutts> allbery_b: I can't reproduce that, if the packing were wrong you'd end up with centered text, not left aligned
20:17:55 <kc5tja_> sorear: The Kestrel's ROM expects a 2Kx8 bitmap -- period.  It doesn't need flexibility, because it's not a full-on GUI.
20:17:55 <allbery_b> hrm.  I have another one that actually works correctly, but it's in a table instead of an hbox
20:17:57 <sorear> Hmm.  Haskell-mode seems to think ^#define .... is a comment
20:18:22 <allbery_b> yeh, I noticed it thinks # is a comment character
20:18:26 <sorear> kc5tja_: Does the kestral have a row-major display bitmap?
20:18:33 <allbery_b> {-# ... #-} also messes it up
20:18:35 <kc5tja_> sorear: that's all it has.
20:18:56 <kc5tja_> no text mode; the ROM blits text to the screen in using a row-major blitting operation.
20:19:10 <sorear> kc5tja_: ok, then, unless your display rom programmer was intoxicated you are storing fonts row-major
20:19:32 <sorear> kc5tja_: the only question is whether the data for characters is interleaved
20:19:39 <allbery_b> guess I'll try reimplementing that part of the gui as a table instead and see if it obeys the x-align
20:20:14 <sorear> a0 a1 a2 a3 a4 a5 a6 a7 b0 b1 b2 b3 b4 b5 b6 b7 ...  vs
20:20:35 <sorear> ... a0 b0 ... a1 b1 ... a2 b2 ... a3 b3 ... a4 b4 ...a5 b5
20:20:52 <sorear> both would be about equally easy to implement I think
20:21:23 <sorear> I think the former would be ever-so-slightly simpler still, which would be Very Good since that's the psf order
20:21:35 <sorear> in which case you can just double bytes
20:22:32 <sorear> @botsnack
20:22:32 <lambdabot> :)
20:22:39 <kc5tja_> sorear: It's stored like a normal 2048 pixel by 8 pixel bitmap would be (like a graphic image).  So it's a0 b0 c0 ... a1 b1 c1 ... etc.
20:22:47 <kc5tja_> 256 bytes of raster 0 data, 256 bytes of raster 1 data, etc.
20:23:15 <sorear> ah, ok
20:23:23 <sorear> sounds like a job for transpose!
20:23:32 <sorear> @type transpose
20:23:35 <lambdabot> forall a. [[a]] -> [[a]]
20:24:04 * kc5tja_ was just going to read in 8 chunks of 256 bytes, then zip8 them.  :)
20:25:05 <sorear> @ty let chunk k [] = [] ; chunk k l = take k l : chunk k (drop k l) in interact $ (++) [0x36,4,0,16] . concat . transpose . chunk 256
20:25:08 <lambdabot>     No instance for (Num Char)
20:25:08 <lambdabot>       arising from the literal `54' at <interactive>:1:84-87
20:25:37 <sorear> @ty let chunk k [] = [] ; chunk k l = take k l : chunk k (drop k l) in interact $ (++) "\54\4\0\16" . concat . transpose . chunk 256
20:25:39 <lambdabot> IO ()
20:25:46 <sorear> is that a forth oneliner too? :)
20:27:12 <allbery_b> okay, that's got it, if not quite the way I want the spacing
20:27:52 <allbery_b> I killed the internal boxes and the field widths (which caused centering instead of right justification!)
20:28:35 <allbery_b> the result is somewhat wider than I wanted but I don't think there's a way to tell it to shrink the middle column of the table
20:31:03 <kc5tja_> sorear: If I had concat, transpose, and all its dependent words in the dictionary already, YES.
20:31:21 * kc5tja_ doesn't like these chest-beating contests with respect to languages.  >:(
20:31:41 * kc5tja_ sighs -- I'm just so not intended for this world.
20:32:04 <jcreigh> kc5tja_: which world?
20:32:11 <kc5tja_> _This_ world.
20:32:19 <kc5tja_> Sol 3
20:32:22 <jcreigh> oh.
20:32:25 <kc5tja_> circa 21st century.
20:32:46 <jcreigh> sorry, but there's not another one within convienent range WRT time or space.
20:33:00 <kc5tja_> I doubt it'd help.
20:33:05 <SamB_XP> kc5tja: that is not particularly precise
20:33:22 <kc5tja_> SamB_XP: What isn't?
20:33:28 <SamB_XP> that designation
20:33:32 <chessguy> hi haskellers
20:33:33 <kc5tja_> So what?
20:33:35 <kc5tja_> Who cares?
20:33:36 <SamB_XP> "circa 21st century"?
20:33:39 <kc5tja_> It's precise enough.
20:33:51 <jcreigh> chessguy: hey
20:34:03 <SamB_XP> that includes the world after 90 years have passed!
20:34:16 <chessguy> jcreigh: how goes the chess engine?
20:34:32 <jcreigh> chessguy: oh, haven't touched it. :)
20:34:37 <chessguy> awww
20:34:38 <kc5tja_> Do you REALLY think that we're going to be that different in 90 years, given 6000 years of known, recorded history of war and unnecessary competition?
20:34:47 <jcreigh> been busy with other stuff.
20:34:57 <chessguy> i know how that goes
20:35:36 <SamB_XP> kc5tja: what about computers!
20:35:39 <chessguy> i haven't done much with mine lately either
20:35:56 <SamB_XP> computers are very upsetting
20:36:07 <chessguy> @quote computer
20:36:08 <lambdabot> dons says: Welcome to computer science, we count from 0.
20:37:15 <SamB_XP> @quote computer
20:37:15 <lambdabot> conal says: monochrom: maybe that's only because computers program people as much as vice versa.
20:37:21 <SamB_XP> @quote computer
20:37:22 <lambdabot> Makali says: Whenever a programmer thinks, "Hey, skins, what a cool idea", their computer's speakers should create some sort of cock-shaped soundwave and plunge it repeatedly through their skulls.
20:37:28 <sorear> Oh, I think in 20 years computers will replace us, and in 90 years nobody will be able to tell the difference
20:37:35 <sorear> they'll be as dumb as we are
20:37:51 <chessguy> sorear: like animal farm?
20:38:03 <kc5tja_> @hoogle transpose
20:38:04 <jcreigh> sorear: you're saying that someday computers will program in PHP? :)
20:38:04 <lambdabot> List.transpose :: [[a]] -> [[a]]
20:38:04 <lambdabot> Data.Graph.transposeG :: Graph -> Graph
20:38:08 <sorear> more intellectual maybe, but if 5 billion years of evolotion are any guide..
20:38:13 <SamB_XP> gotta love the retirement plan!
20:38:17 <sorear> chessguy: yeah!
20:38:59 <sorear> chessguy: thank you for pointing out the reference!
20:39:08 <sorear> Computers are the new proletariat.
20:39:18 <chessguy> i haven't actually read the book, but i'd like to
20:39:48 <jcreigh> chessguy: you should. it's a fun read
20:39:53 <chessguy> i bet
20:41:32 <dmwit> Could somebody take a look at http://hpaste.org/1248?  I don't understand the meaning of the error message.
20:42:01 <kc5tja_> sorear: Your code won't compile in GHCI.
20:42:09 <sorear> why has hpaste stopped answeing?
20:42:24 <kc5tja_> "Main.hs:xx:0: parse error on input `module'"
20:42:32 <kc5tja_> And I'm not sure why.  No useful error is given.
20:42:36 <sjanssen> sorear: works for me
20:42:41 <sorear> kc5tja_: Nice one!
20:43:00 <kc5tja_> xx is 12 on my box, but that's only because I put in a comment.
20:43:04 <sorear> kc5tja_: it errored on the auto-inserted module t
20:43:08 <sorear> oh, sorry
20:43:16 <sorear> I thought it said xx :)
20:43:30 <chessguy> ?hoogle printName
20:43:31 <lambdabot> No matches found
20:43:39 <kc5tja_> module FontVerter where chunk k [] = [] chunk k l = take k l : chunk k (drop k l)
20:43:44 <kc5tja_> doggone irssi.
20:43:46 <sorear> ?hoogle pprName
20:43:46 <lambdabot> Language.Haskell.TH.PprLib.pprName :: Name -> Doc
20:43:53 <dmwit> printName x = widgetGetName x >>= putStrLn
20:44:02 <MarcWeber> dmwit: GHC doesn't know which type to choose for a (line 6)
20:44:10 <sorear> kc5tja_: there needs to be a ; between the defns for chunk
20:44:22 <kc5tja_> sorear: Not when they're on separate lines.
20:44:23 <MarcWeber> So using (printName :: WidgetClass -> IO ()) should fix it
20:44:23 <sorear> no idea why it said module
20:44:30 <dmwit> MarcWeber: But, why should it need to?  The widgetGetName function is defined for all WidgetClass instances...
20:44:36 <kc5tja_> module FontVerter where
20:44:38 <kc5tja_>   chunk k [] = []
20:44:40 <kc5tja_>   chunk k l = take k l : chunk k (drop k l)
20:44:43 <kc5tja_> ...etc...
20:44:47 <dmwit> Wait, really?
20:44:50 <kc5tja_> (hand pasted)
20:44:58 <chessguy> kc5tja: that's what hpaste is for
20:45:12 <kc5tja_> C'mon it's only 3 lines here.  But I digress.
20:46:00 <sorear> kc5tja_: and module is the first line in the file?
20:46:09 <kc5tja_> MUST it be the first line?
20:46:17 <kc5tja_> If so, that's contradictory with my CUT sources.
20:46:24 <sorear> no, whitespace can precede it
20:46:33 <sorear> incl. comments and pragmas
20:46:36 <dmwit> MarcWeber: No, WidgetClass is a class, not a type...
20:46:53 <kc5tja_> OK, I figured it out.
20:46:59 <kc5tja_> I had the import preceding the module.
20:47:01 <kc5tja_> Thanks.
20:47:08 <chessguy> it would have to be (printName :: WidgetClass w => w -> IO ())
20:47:18 <chessguy> which is a mouthful
20:47:22 <MarcWeber> dmwit: Have look at the definition of windowNew. See which type it returns
20:47:39 <chessguy> ?hoogle windowNew
20:47:40 <lambdabot> No matches found
20:48:16 <dmwit> MarcWeber: IO Window, but why?  I want this to work on the button/entry widgets, too.
20:48:43 <MarcWeber> dmwit: Then you need existantial types.
20:49:22 <dmwit> chessguy: Sorry, I missed the meaning of your comment that starts, "it would have to be..."
20:49:30 <dmwit> ?go existential types
20:49:33 <lambdabot> http://www.cs.washington.edu/homes/djg/papers/exists_imp.pdf
20:50:08 <chessguy> dmwit: oh, instead of MarcWeber's (printName :: WidgetClass -> IO ())
20:50:29 <dmwit> chessguy: Oh, okay, yeah.  What you wrote is what I currently have.
20:50:57 <MarcWeber> dmwit: Sorry, can't test it now. Have to reinstall gtk2hs
20:50:59 <chessguy> oh, so it is
20:51:39 * kc5tja_ sighs
20:51:44 <kc5tja_> Now ghc isn't building the code.
20:51:44 <dmwit> ?go existential types haskell
20:51:46 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
20:51:47 <lambdabot> Title: Haskell/Existentially quantified types - Wikibooks, collection of open-content t ...
20:52:22 <kc5tja_> ghc -o fontverter --make Main.hs ==> no Main module.
20:52:27 <sjanssen> dmwit: I think you want to give the parameter the type Widget
20:52:34 <kc5tja_> ghc --make Main.hs ==> compiles to .o file, but no binary.
20:52:34 <MarcWeber> dmwit: Just try (printName :: Window -> IO ())
20:52:45 <kc5tja_> module has been adjusted to expose main.
20:52:53 <dmwit> MarcWeber: That crashes if you ever focus on any widget other than the main window. ;-)
20:52:55 <kc5tja_> Haskell just isn't being my friend.  :(
20:53:00 <dmwit> sjanssen: Okay, I'll try it.
20:53:23 <chessguy> dmead_: oh weird. i get a different error from that code than what you did
20:53:33 <MarcWeber> dmwit: No because you register that handler only for the window widget: onSetFocus      window (printName)
20:54:03 <dmwit> MarcWeber: Empirically false. =P
20:54:04 <kc5tja_> n/m -- I got it.
20:54:13 <sjanssen> dmwit: gtk2hs simulates OO subtyping with typeclasses and data types.  'Widget' is the supertype of everything in WidgetClass
20:55:55 <dmwit> Okay, I'm still getting crashes, but it is less often, and I think I can take it from here.
20:55:57 <dmwit> Thanks all.
20:56:44 <chessguy> well, i got up to the point where it says (GtkTest:4268): libglade-WARNING **: could not find glade file 'hworld.glade'
20:56:49 <chessguy> which is expected
20:56:53 <dmwit> Heh, oh.
20:56:59 <dmwit> Should I hpaste it for you?
20:57:04 <chessguy> if you want
20:57:34 <chessguy> i'd kind of like to learn some gtk2hs stuff too, so i wouldn't mind playing around with it
20:57:51 <hpaste>  dmwit annotated "gtk2hs: ambiguous type error" with "hworld.glade" at http://hpaste.org/1248#a1
20:59:11 <dmwit> On a side note, urxvt doesn't really play nice with xmonad. =(
20:59:14 <chessguy> ok, the program runs for me now, but at the end, when i quit, it gives me a segmentation fault
20:59:43 <dmwit> !
20:59:56 <dino-> So I wrote a small command-line utility in Haskell recently: http://ui3.info/d/proj/storylen.html
20:59:58 <lambdabot> Title: storylen - story word count and categorization
21:00:26 <dino-> And I followed the How to write a Haskell program page closely, doing as many of the steps as seem relevant for this project.
21:00:33 <hpaste>  chessguy annotated "gtk2hs: ambiguous type error" with "my session" at http://hpaste.org/1248#a2
21:00:47 <dino-> It's under darcs, it's got the right file structure, it's cabalized. It has a web page.
21:00:48 <chessguy> all i did was click ok and then click close
21:01:13 <dons> dino-: nice. does it use bytestrings?
21:01:15 <dons> dmwit: oh?
21:01:35 <dino-> dons: It does indeed.
21:01:37 <dmwit> dons: It doesn't repaint properly when it resizes.
21:01:52 <dino-> And before it used ByteString, it was ridiculous slow.
21:02:41 <dino-> So, my question is: is this suitable for announcing on haskell@haskell.org?
21:03:02 <dons> dino-: sure, or drop it by haskell-cafe@
21:03:10 <dino-> It's so.. not a Functional Graph Library, or an XML toolkit or even a Gameboy emulator.
21:03:19 <sorear> dons: nice.  I just discovered another advantage of my mutable-byte-array state-block approach (cf builder hacking results, parameter reduction) - it allows highly efficient mon{a,oi}d transformers
21:03:48 <chessguy> dino-:  it seems pretty specific to your needs. i don't know that many people will use it, but it could be an interesting project for people to read through
21:04:04 <dmwit> chessguy: Yes, I can replicate the problem.  (It's 100% reproducible -- pressing close always triggers a problem, no matter what happened before.)
21:04:15 <dmwit> I just don't know enough to say waht it is yet... =)
21:04:21 <kc5tja_> @type replicate
21:04:24 <lambdabot> forall a. Int -> a -> [a]
21:04:27 <dino-> chessguy: Perhaps gathering an all plain text library of books will become a trend. :)
21:05:14 <chessguy> dmwit: hmm, i wonder if the onClick event for close is getting captured before the printName
21:05:34 <chessguy> dmwit: and then by the time the printName executes, the window is already destroyed
21:05:59 <dmwit> Well, commenting out the printName line seems to fix it, so...
21:06:11 <chessguy> hmm. all thought just tabbing around the window is enough to give a segmentation fault too
21:06:17 <chessguy> s/thought/though/
21:06:24 <dmwit> Yeah, that's why I was saying it still crashed sometimes.
21:06:38 <dmwit> Specifically, tabbing past "OK" or shift-tabbing before the entry box will do it.
21:06:44 <chessguy> yes
21:06:47 <chessguy> interesting
21:07:02 <jcreigh> type  ReadS a = String -> [(a,String)] -- okay, but what should I return as the String?
21:07:06 <chessguy> you might want to chat with dcoutts about this, he knows a lot about gtk2hs
21:07:10 <dcoutts> @arr
21:07:11 <lambdabot> Drink up, me 'earties
21:07:13 <abz> yeah dons, thanks for the reddit.
21:07:24 <chessguy> speaking of which :)
21:07:25 <dmwit> Hi dcoutts!
21:07:26 <jcreigh> I'm trying to declare an instace of Read...
21:07:33 <dcoutts> abz: looks good!
21:07:41 <abz> thanks.
21:07:46 <dcoutts> abz: nice success story too :-)
21:08:05 <dcoutts> abz: I wonder if this'll motivate anyone to clean up wash
21:08:23 <abz> it needs it, i've got a good list of TODOs for wash
21:08:27 <chessguy> ?src Read
21:08:28 <lambdabot> class Read a where
21:08:28 <lambdabot>   readsPrec    :: Int -> ReadS a
21:08:28 <lambdabot>   readList     :: ReadS [a]
21:08:28 <lambdabot>   readPrec     :: ReadPrec a
21:08:28 <lambdabot>   readListPrec :: ReadPrec [a]
21:08:36 <dons> abz, yeah, great work.
21:08:44 <dcoutts> abz: heh, I bet. #1 make it build in less than 2 hours ;-)
21:09:32 <abz> fast_cgi is the most needed thing. atm it just exitWith Success after each page...
21:09:38 <dmwit> dcoutts: I'm playing with gtk2hs, and found a few ways to make it send makeNewGObject a NULL pointer.  Do you want/have time to educate me? =)
21:10:21 <abz> which means that you have to do everything (like send emails) before rendering the page.
21:10:21 <dcoutts> abz: I suggest you post your wash todo list as a follow up to the mailing list and/or your general development experiences with it, I'm sure people will be interested
21:11:09 <dcoutts> abz: you've seen Happs to of course, I wonder if any integration between the two would help since wash is mainly about front end and happs mainly about back end
21:11:20 <abz> dcoutts: good thought, will do.
21:11:30 <dino-> Speaking of ByteString, I was having performance problems until someone told me to use -O2. And dcoutts emailed about the inlining: http://www.haskell.org/pipermail/haskell-cafe/2007-March/024027.html
21:11:32 <lambdabot> Title: [Haskell-cafe] Data.ByteStream.Char8.words performance, http://tinyurl.com/yrqe5b
21:11:38 <dino-> But the discussion never went further.
21:11:57 <MarcWeber> abz Where can I read about the success story? Do you want to join web-devel@haskell.org ?
21:12:05 <dcoutts> dmwit: if you can give makeNewGObject a NULL pointer it's a bug and we'd apreciate if you report how to reproduce it
21:12:08 <abz> dcoutts: yes, I've seen Happs.
21:12:19 <kc5tja_> Awesome.  I now have 8x8 and 8x16 console fonts.
21:12:30 <abz> http://article.gmane.org/gmane.comp.lang.haskell.cafe/21159
21:12:32 <lambdabot> Title: Gmane -- Mail To News And Back Again
21:12:39 <kc5tja_> sorear: However, you ruined it for me; I was going to try and do this myself for practice.  But, still, it's done.
21:13:08 <abz> I was thinking of posting it to web-devel, but I didn't know that it had enough readers...
21:13:37 <chessguy> probably most web-devel readers are on -cafe and/or haskell@
21:13:42 <dcoutts> abz: yeah, -cafe has a bigger readership, web-devel is probably a good place for more detailed discussions
21:13:49 <dmwit> dcoutts: Okay, I'll make a minimal test-case and forward it to the dev list.
21:13:57 <glguy> Is there a reasonably efficient method of altering a doubly linked list without assignments?
21:14:16 <sorear> use finger trees instead? :)
21:14:17 <dcoutts> dmwit: cheers
21:14:18 <glguy> I'm assuming you'd have to rebuild the whole skeleton
21:14:41 <glguy> sorear, that's not a bad suggestion... maybe I'm just looking at this wrong..
21:14:53 <dcoutts> glguy: aye, modifying a circularly linked data structure requires rebuilding the whole thing
21:16:11 <glguy> I'm trying to figure out how I might store the equivalent of a doubly-connected edge list in a functional data structure
21:16:28 <glguy> and have a more efficient way to update it than copy it
21:17:18 <dcoutts> dmwit: btw did you figure out the type error?
21:17:31 <dcoutts> dmwit: it's just like the error you get if you (read . show)
21:17:41 <dmwit> dcoutts: Yes, sjanssen told me I could use Widget instead of (Widgetclass a) => a.
21:18:05 <dcoutts> right otherwise it has no idea which Widgetclass instance you mean
21:18:25 <dmwit> I'm still not sure I understand why it should care, though.
21:18:26 <SamB_XP> little does it know that it *doesn't really matter*...
21:18:34 <MarcWeber> abz: We have 9 subscribers
21:18:40 <SamB_XP> dmwit: it doesn't know any better than to care!
21:18:45 <dmwit> I mean, widgetGetName is part of the API for WidgetClass...
21:19:05 <dmwit> All instances of it have to provide that function!
21:19:16 <dcoutts> dmwit: but the result might depend on which instance it is
21:19:36 * dmwit blinks
21:19:48 <abz> marcweber: will join
21:19:51 <abz> brb
21:20:09 <dcoutts> dmwit: suppose the WidgetClass provided a method to get the type name as a string and widgetGetName used it? then it'd depend on which instance it is
21:20:23 <MarcWeber> abz: I'm interested in adding fastcgi support, too. But I'm still struggling with WASH source code...
21:20:35 <dcoutts> dmwit: of course in this case it doesn't actually matter, but there's no way from the outside to see that
21:20:43 * dcoutts -> lunch
21:20:45 <dmwit> So there's no dynamic dispatch?
21:20:50 <dmwit> Okay, I guess that makes sense.
21:26:55 <jcreigh> lol...I was wondering why my chess engine was so slow after a minor refactor. turns out that runghc isn't as fast as ghc -O... :)
21:26:59 * MarcWeber has to checkfs his disks
21:29:50 <SamB_XP> dmwit: well there is dynamic dispatch
21:29:58 <SamB_XP> but the Haskell compiler knows nothing of that
21:30:17 <dmwit> hm?
21:30:23 <SamB_XP> it happens in C land
21:30:34 <dmwit> Now I'm confused again.
21:31:04 <dmwit> If there's definitely enough information at runtime to do the calculation, and it is easy to see at compile time that there will be enough information at runtime, why should the compile fail?
21:31:14 <SamB_XP> you aren't familiar with the object oriented language known as C?
21:31:40 <dmwit> Wait, are you saying that there is dynamic dispatch, but only in other languages?
21:31:58 <SamB_XP> well, the Haskell compiler doesn't know anything about this, and anyway the typesystem doesn't allow it ;-)
21:32:39 <dmwit> So, let me say more specifically that I was asking whether *Haskell* has dynamic dispatch.
21:33:04 <SamB_XP> nope
21:33:12 <dmwit> ok
21:33:18 <SamB_XP> C doesn't have it either, though ;-P
21:33:44 <dmwit> Well, it does if it's hand-crafted. ;-)
21:33:52 <SamB_XP> yeah ;-)
21:35:01 <dmwit> This reminds me of that joke where in the punchline, the guy says,
21:35:16 <dmwit> You must be a mathematician, because what you said is completely true, but totally unhelpful.
21:35:19 <dmwit> =P
21:36:21 <SamB_XP> well, I can't help it if I see a false statement and try and correct it!
21:36:30 <dmwit> =D
21:44:20 <SamB_XP> at least I try to restrain myself during classes
21:44:47 <dmwit> Heh, yeah, the person who corrects the prof always looks sort of silly.
21:45:16 <dmwit> Plus, if you hold back, you get to feel superior!  "I figured that mistake out ages before the other guy." =)
21:45:50 <SamB_XP> I find that my lab group doesn't like it so much ;-)
21:46:23 <SamB_XP> (when I refrain from pointing out mistakes)
21:47:39 <sorear> There's a certain satisfaction to be had from correctly correcting the prof.
21:47:50 <SamB_XP> yeah.
21:47:53 <SamB_XP> but it can take time
21:48:04 <SamB_XP> so it is best to save it for break and/or after class ;-)
21:48:42 <dmwit> It is a delicate art.
21:48:57 <dmwit> I find that "clarifying" certain points is an effective form of correction.
21:49:20 <SamB_XP> another way to do it is to say that you are confused
21:56:29 * glguy wonders what blue cheese would smell like when it goes bad
21:58:37 <glguy> and furthermore :) who looked at this stuff and said "hmm, that dairy product looks moldy enough, I'll try eating it
21:59:19 <abz> MarcWeber: joined
22:00:02 <dino-> glguy: Oh come on now, the bleu-class cheeses are delicious.
22:00:24 <glguy> dino-, I'm not sitting here eating blue cheese on crackers because I like punishment :)
22:00:25 <dino-> I actually did have a Roquefort go bad recently. It smelled foul in a way that was unlike its normal foulness.
22:00:54 <dino-> There was mucus.
22:01:25 <glguy> maybe you'd just discovered a new cheese?
22:01:55 <dino-> heh, that could be
22:03:31 <sorear> Muahahaha.
22:04:35 <allbery_b> remember that italian cheese with worm in it
22:04:39 <allbery_b> worms
22:04:45 <dino-> Ok, that's nasty.
22:04:58 <sorear> Why isn't : newtype Foo# = Foo# Int# : legal?
22:04:59 <allbery_b> you can't eat it until you've left it in a  paper bag for a day so the worms come out
22:05:15 <glguy> why does the paper bag drive them out?
22:05:17 <sorear> it seems like it should define a new type of kind #
22:05:35 * allbery_b doesn't know and isn't sure he wants to know
22:06:34 <allbery_b> as to cheese in general (and I say this as a cheese lover) I have to assume someone got desperate when their milk went bad
22:10:07 <glguy> ugh, I hate when minesweeper forces you to guess
22:10:17 <glguy> especially at the end of a large level
22:12:04 <jcreigh> well, it is NP-complete and all
22:12:38 <glguy> sure, but so is sudoku
22:13:03 <jcreigh> you have to backtrack to solve sudoku as well.
22:13:07 <glguy> and sudoku puzzles that require guessing are considered malformed by many :)
22:13:22 <glguy> well... I consider minesweeper in the same sense
22:13:55 <sorear> glguy: look at simon tatham's puzzle collection
22:14:16 <sorear> glguy: portable, has minesweeper and a couple gazillon others
22:14:34 <sorear> and an option to never generate puzzles that require backtracking
22:14:44 <sorear> unfortunately it requires a GUI :(
22:14:48 <glguy> heh
22:15:04 <jcreigh> whoa, author of putty?
22:15:05 <sorear> http://chiark.greenend.ac.uk/~sgtatham/
22:15:10 <jcreigh> SimonTatham++
22:15:12 <sorear> jcreigh: yerp
22:15:56 <sorear> @flush
22:17:14 * sorear obsessivly checks #haskell stats
22:18:16 * Heffalump used to work with him
22:18:42 <sorear> cool!
22:18:47 <sorear> dons: ping
22:29:21 <dons> this is rather nice, http://programming.reddit.com/info/1fh8x/comments
22:29:23 <lambdabot> Title: What Haskell teaches us about writing Enterprise-scale software (reddit.com)
22:45:31 <sorear> nice. on my system unaligned word writes are twice as slow as aligned (256k buffer).  still 25% faster than byte writes though
22:46:36 <dcoutts> that makes sense
22:46:53 <dcoutts> since for an unaligned access the cpu needs to do two aligned accesses
22:47:19 <sorear> OTOH, the breaking is done in hardware (i386).
22:47:47 <dcoutts> so an unaligned word read/write primitive would want to use byte reads/writes on hardware that doesn't allow unaligned access and on system that do allow it then use it
22:47:59 <dcoutts> sorear: breaking?
22:48:09 <sorear> into two accesses
22:48:14 <dcoutts> right
22:48:18 <narain> if i want to make a data type which combines two things of different types, is it more idiomatic to make it a record type or simply a pair?
22:48:25 <dcoutts> hence faster than doing it manually in code
22:48:45 <dcoutts> narain: depends how much you need to use it
22:49:01 <dcoutts> for a one off I'd use a pair
22:49:02 <sorear> also, the p4 manual says that unaligned writes are much slower on the p4 than previous processors, since they eliminated the integer-unit shifter
22:49:21 <narain> dcoutts: almost all the time
22:49:39 <sorear> so that 33% faster includes the time needed to send the data all the way from the store unit to the mmx unit and back
22:49:46 <dcoutts> sorear: still it's probably quicker than using multiple instructions to do byte reads/writes
22:49:54 <dcoutts> right
22:50:11 <sorear> dcoutts: plus, I'm benchmarking on a p4 :)
22:50:15 <narain> dcoutts: i take it you would recommend a record in that case?
22:50:22 <sorear> unfortunately we still don't have unaligned access primops
22:50:26 <dcoutts> narain: aye
22:50:33 <dcoutts> sorear: you could write one for us ;-)
22:50:41 <narain> dcoutts: ok, thanks!
22:51:06 <sorear> perhaps even in big/little/host endian versions!
22:51:14 <dcoutts> go for it
22:51:20 <sorear> i386 has an opcode for byteswapping
22:51:23 <dcoutts> narain: there's no hard and fast rule, just go for whichever feels nicer
22:51:44 <dcoutts> sorear: I'm not suggesting going that low level
22:52:03 <dcoutts> unless you want to pattern match that case in the x86 NCG
22:52:26 <narain> dcoutts: i usually do, but my gut instinct wasn't telling me anything in this case
22:52:43 <narain> so i thought i'd rely on received wisdom and do whatever was more idiomatic
22:53:08 <sorear> heh.  no, i don't think I'm going to mess with the NCG as my first hacking in ghc, sounds way too easy to introduce subtle codegen bugs
22:53:43 * sorear is probably over-estimating the fragility of ghc
23:03:38 <narain> hmm... when defining a monad, i can't just supply my own definition of join directly, can i?
23:03:46 <narain> :t join
23:03:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
23:05:26 <sorear> right.
23:05:38 <sorear> join is outside the class, stupidly.
23:06:00 <narain> that's a little annoying, because i'm thinking of my monad in terms of fmap and join
23:07:12 <narain> so i'll define >>= using join but have to tuck join into a where clause
23:07:33 <sjanssen> the default definitions would probably be cyclic if join was in the class
23:08:21 <narain> but that would be ok because of laziness, right? :)
23:08:29 <sorear> sjanssen: Eq
23:08:35 <sorear> @src (==)
23:08:35 <lambdabot> x == y = not (x /= y)
23:08:38 <sorear> @src (/=)
23:08:39 <lambdabot> x /= y = not (x == y)
23:09:05 <sorear> @src compare
23:09:06 <lambdabot> compare x y | x == y    = EQ
23:09:06 <lambdabot>             | x <= y    = LT
23:09:06 <lambdabot>             | otherwise = GT
23:09:08 <sorear> @src <=
23:09:09 <lambdabot> x <= y = case compare x y of { GT -> False; _other -> True }
23:09:12 <sjanssen> yeah, Ord too
23:09:17 <narain> i remembered seeing that and convincing myself it was ok
23:09:18 <sorear> @src show
23:09:19 <lambdabot> show x = shows x ""
23:09:20 <sjanssen> I guess it's not a big deal then :)
23:09:21 <sorear> @src shows
23:09:21 <lambdabot> Source not found. Just what do you think you're doing Dave?
23:09:25 <sorear> @src showsPrec
23:09:26 <lambdabot> showsPrec _ x s = show x ++ s
23:09:33 <sorear> show is cyclic too!
23:09:59 <sorear> @src (-)
23:10:00 <lambdabot> x - y = x + negate y
23:10:03 <sorear> @src negate
23:10:03 <lambdabot> negate x = 0 - x
23:10:08 * sorear stops
23:10:14 <sjanssen> bah, those are all over
23:10:36 <sjanssen> and they're really not very nice -- there's no way for the compiler to give good warnings
23:10:55 <sorear> there is imo
23:10:56 <sjanssen> and the runtime behavior is just an infinite loop
23:11:03 <narain> ah, #haskell, when you can ask a simple question and be taken on a whirlwind tour of the unique corners of the language
23:11:15 <sorear> we can for each class infer a default method dependency graph
23:11:18 <sjanssen> yeah, we could add a pragma or something that shows the dependency graph
23:11:36 <sjanssen> sorear: but sometimes the cycles are intentional
23:11:41 <sorear> then for each instance we create a pruned graph with the overriden methods removed
23:11:58 <sorear> then for each instance, we warn if the pruned graph is still cyclic
23:12:04 <sjanssen> or could theoretically be cyclic
23:12:18 <sorear> sjanssen: emphasis on 'sometimes'
23:12:35 <sorear> sjanssen: ndm is the only one here who complains about -Wincomplete-cases
23:12:51 <sjanssen> why does ndm complain?
23:12:52 <sorear> and he probably wouldn't if his thesis wasn't about improving it
23:12:55 <sorear> catch?
23:13:24 <sjanssen> oh right, the incomplete case checker is broken
23:13:54 <sjanssen> I've seen those bugs before
23:18:28 <narain> :t join . fmap
23:18:30 <lambdabot>     Occurs check: cannot construct the infinite type: f = (->) (f a)
23:18:30 <lambdabot>     Probable cause: `fmap' is applied to too many arguments
23:18:33 <dmwit> ?remember narain ah, #haskell, where you can ask a simple question and be taken on a whirlwind tour of the unique corners of the language
23:18:34 <lambdabot> Done.
23:18:36 <narain> :t (join .) . fmap
23:18:39 <lambdabot> forall a a1 (f :: * -> *). (Monad f, Functor f) => (a1 -> f a) -> f a1 -> f a
23:18:49 <narain> :t (>>=)
23:18:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
23:19:09 <narain> hmm, almost
23:19:27 <dmwit> ?unpl (join .) . fmap
23:19:28 <lambdabot> (\ d i -> (fmap d i) >>= \ e -> e)
23:19:36 <Cheery> today I get radical and remove all the unnecessary declaration choices and ugly possible values from cascading style sheets
23:19:38 <dmwit> ... =(
23:19:38 <narain> ?pl \m f -> join (fmap f m)
23:19:39 <lambdabot> (join .) . flip fmap
23:20:03 <Cheery> die shitty w3c!
23:20:20 <dmwit> Yay!
23:21:57 <narain> Cheery: what's this about, if i may ask?
23:22:20 <Cheery> yesterday's thing
23:22:36 <narain> Cheery: i wasn't there
23:24:27 <Cheery> I'm writing a css generator, yesterday decided to remove all which shouldn't be there
23:25:50 <narain> css... *generator*? i wouldn't think generating output in a language would send you into ugly corners of the spec
23:26:04 <narain> that usually happens when trying to parse, not generate... ?
23:26:24 <Cheery> so, this looks even more uglier when parsed?
23:26:41 <narain> i wouldn't know
23:26:55 <narain> i was speaking about languages in general
23:27:50 <narain> i never found css ugly myself though
23:28:08 <narain> offtopic: what's the syntax for single-line comments in haskell?
23:28:20 <Cheery> well, css problems are that there are some things which are obsolete / horrible in practise / available by other means
23:28:37 <Cheery> this is your code -- this is your comment
23:28:44 <narain> oh right thanks
23:28:52 <Cheery> multiline is {- COMMENT -}
23:29:39 <Cheery> another css problem is that each property accepts totally different set of values, while they accept same sort of values
23:30:30 <narain> hmm
23:31:02 <Cheery> good example is font-size
23:31:32 <narain> ..., x-small, small, um medium?, large, x-large, ...
23:31:40 <Cheery> there's xx-small, x-small, small, medium, large, x-large xx-large smaller, and in the end you can just give a length or percents
23:31:59 <narain> are there smaller and larger also?
23:32:05 <narain> i forget
23:33:18 <Cheery> font-weight is ridiculous in kind
23:33:34 <Cheery> normal bold bolder light 100 200 300 400 500 600 700 800 900
23:34:01 <narain> well, they tried to keep to what the standard was in typography
23:34:26 <narain> it's not like they could make up their own measures of typeface weight
23:34:46 <narain> (i assume this is what they did, at least)
23:35:33 <narain> to what purpose are you generating css? are you trying to cover all possible cases?
23:35:34 <Cheery> I think they could have, anyways, the cascading style sheet is used mainly with web sites, not for typography
23:36:18 <narain> well (1) it can be used in print (2) it's supposed to be used also by designers
23:36:26 <Cheery> nah, I tried that, I think I'm fed up with it, now things are going to fly and bend
23:37:27 <Cheery> what's the role of visibility and display -properties?
23:37:33 <narain> what's your css generator for, anyway? if you don't need to cover all cases you could just pick the bits which are easy to generate and/or of interest to you and generate those
23:37:49 <narain> visibility hides an element but it still takes up space
23:37:54 <narain> display eliminates it completely
23:38:08 <sorear> @users
23:38:08 <lambdabot> Maximum users seen in #haskell: 336, currently: 273 (81.3%), active: 20 (7.3%)
23:38:21 <Cheery> my target is just web sites
23:38:28 <narain> display also changes other things
23:38:38 <Cheery> narain: so, what's the point of an element if it is hidden?
23:38:39 <narain> like you could make a list display inline instead of as a block
23:38:55 <Cheery> ie. why leave the blank space in those cases?
23:39:31 <narain> hmm i feel like i used it once but i can't recall why
23:40:05 <narain> doesn't the spec suggest any uses?
23:40:39 <hyrax42> aren't there non-standard selectors for hover &c.?
23:40:48 * allbery_b curses sorear --- he's wasted the last 45 minutes playing those puzzles instead of going to bed :)
23:40:52 <hyrax42> they can change the visibility
23:41:03 <sorear> muahahaha!
23:41:09 <hyrax42> also I believe I've seen hidden used for browser warnings
23:41:18 <narain> hyrax42: hover is a standard selector
23:41:22 <hyrax42> serve the same HTML, different CSS based on user agen
23:41:38 <hyrax42> so a warning can be hidden and shown for NS 4.7 or something
23:42:02 <sorear> a lot of hidden's raison d'etre is that it can be set from javascript
23:42:24 <hyrax42> and you get all these "pure CSS dropdowns" that I assume use hover and hidden for magic
23:43:03 <narain> i think the question is why would you ever want to use hidden instead of display:none
23:43:26 <narain> if you have something hidden, it still takes up space if it's in the normal flow
23:43:48 <hyrax42> oh I confused them
23:43:54 <narain> which you would often not want because it would look like empty space sitting there for no reason
23:43:56 <hyrax42> narain: for really annoying link-stles
23:43:59 <hyrax42> tyles
23:44:02 <hyrax42> styles
23:44:54 <narain> yeah, the only reason i can think of is if you have something in the normal flow which is revealed interactively and you don't want the following text to jump around
23:45:12 <Cheery> I've already removed all related to background images because they indicate immature style and are the easiest thing to make web pages hyper unreadable
23:45:15 <narain> like awful link styles, as you said
23:45:27 <hyrax42> speakng of jumping around, I hate it when people change the typeface on hover for links
23:45:37 <narain> background images ... indicate immature style? :)
23:45:42 <hyrax42> I'd actually rather the text disappear than have it get reflowed
23:45:48 <narain> often... but not necessarily always
23:45:57 <Cheery> hmm, I wonder whether I could find some sites with background images
23:46:06 <Cheery> I think they all suck
23:46:12 <hyrax42> myspace.com
23:46:25 <narain> http://www.squidfingers.com/patterns/
23:46:26 <lambdabot> Title: Squidfingers / Patterns
23:46:47 <narain> stylish tileable pixel backgrounds
23:46:49 <Cheery> http://users.nac.net/falken/annoying/backgrounds.html
23:46:51 <lambdabot> Title: Background Images
23:46:54 <narain> never used them personally
23:47:08 <narain> Cheery: hahaha
23:47:48 <narain> Cheery: good use of background images: http://www.cameronmoll.com/
23:47:49 <lambdabot> Title: Authentic Boredom ~ Delivered weekly by Cameron Moll
23:50:33 <narain> what's -fallow-undecidable-instances all about?
23:50:42 <Cheery> narain: those squidfinger patterns would be mostly annoying, I think
23:51:21 <sorear> narain: it allows instances even when the compiler can't decide them
23:51:22 <narain> well i certainly don't advocate putting them everywhere
23:51:57 <sorear> narain: so that option gives GHC licence to crash when a type error occurs
23:52:11 <narain> hmm, i don't like the sound of that
23:52:16 <sorear> narain: but if you don't mess up, it gives you much more oleg-power
23:52:23 <sorear> crash means infinite loop here
23:53:01 <sorear> you can set it on a module-by-module basis, which lets oleg write his modules without making your code unsafe
23:53:02 <narain> i'm having trouble with a mptc and ghc's telling me i might want to use that flag
23:53:14 <sorear> coverage condition?
23:53:15 <Cheery> lol
23:53:16 <Cheery> http://users.nac.net/falken/annoying/main.html
23:53:17 <lambdabot> Title: How to make an Annoying Web Page
23:53:45 <sorear> class Foo a b | a -> b      instance Foo a b => Foo (X a) (X b)  -- something like this, narain?
23:54:16 <sorear> the compiler doesn't normally look at fundeps on the left of => to decide if the fundeps on the right are satisfied
23:54:26 <narain> no, i'm not using fundeps
23:54:28 <sorear> so that example, while perfectly safe, needs -fallow-undecidable-instances
23:54:39 <narain> class Foo a b where bar :: a -> a -> a
23:54:53 <sorear> er, why don't you use b?
23:55:01 <sorear> in the type
23:55:10 <narain> well, there are other things in the class
23:55:16 <narain> one of them happens to not need b
23:55:30 <sorear> what kind of class is this?
23:55:34 <sorear> the affine space?
23:55:50 <sorear> the usual fix for this is fundeps
23:55:51 <narain> a class of linear transformations, yes
23:56:10 <narain> hmm, ok i'll try that
23:56:16 <sorear> class LinTrans pointy veccy | pointy -> veccy, veccy -> pointy
23:56:36 <narain> no that's not exactly what it is but i'll try it out anyway
23:56:42 <narain> fundeps i mean
23:58:13 <narain> it worked!
23:58:15 <Cin> hello. I'm trying to understand the following code: parseNumber :: Parser LispVal (new line) parseNumber = liftM (Number . read) $ many1 digit
23:58:19 <Cin> is this defining a monad?
23:58:29 <sorear> no
23:58:33 <sorear> that's a value
23:58:38 <sorear> all monads are types
23:58:51 <Cin> oh I see
23:58:53 <sorear> monad operations are used to construct the value however
23:59:04 <Cin> so its -type- is a monad, but it is a value
23:59:14 <sorear> like foo = 2 + 2  doesn't define a kind of number even though it uses +
23:59:15 <sorear> yes
23:59:16 <Cin> okay
23:59:29 <narain> sorear: i'm not sure i wanted the fundep though
23:59:59 <narain> i can think of theoretical cases where a may not imply b
