00:00:10 <sjanssen> robreim: I thought I had these rules working, but they aren't
00:00:17 <sjanssen> false alarm
00:02:31 <robreim> k
00:03:37 <sjanssen> I think my advice about explicitly quantifying x was bad :(
00:05:14 <robreim> Will the rules work without the quantification though?
00:06:15 <sjanssen> yeah, all of a sudden they do
00:06:23 <sjanssen> I don't really understand why, though
00:10:44 <hpaste>  sjanssen annotated "StringClass" with "RULES that work" at http://hpaste.org/1276#a3
00:11:56 <dcoutts> sjanssen: want to read out draft?
00:12:02 <dcoutts> out/our
00:12:05 <dons> pretty please :-)
00:12:10 <sjanssen> sure
00:12:11 <dons> ?time sjanssen
00:12:21 <dons> ok, i'll mail you a copy.
00:12:26 <sjanssen> Fri Apr  6 02:09:32 CDT 2007
00:12:38 <dons> hehe. ok. i'll mail it quickly
00:13:07 <sorear> Unsuprisingly, ML is Just Another Language to me...
00:13:44 <sjanssen> sorear: meaning easy to learn?  or boring?
00:14:16 <sorear> mostly the former I hope :)
00:15:01 <sorear> how do you define a signature for a top level function?  I have types in mind and I'm too tired to check subtyping manually ;)
00:15:03 <dons> its pretty interesting. get your head into module/functors
00:15:15 <dons> (ML that is)
00:20:20 <robreim> sjanssen: thanks for your help on the string / RULES stuff. I'll have a closer look at your annotation when I get back. bbl.
00:20:31 <joelr1> does anyone know how to clear the shell buffer in emacs?
00:20:52 <procyon112> open a new one?
00:21:00 <sorear> just delete the text!
00:21:06 <joelr1> i managed to pick up ocaml very quickly. very straightforward and logical. unlike haskell ;-)
00:21:15 <sorear> C-M-< C-SPC C-M-> C-w
00:21:23 <sorear> that sould clear the bugger
00:21:27 <joelr1> sorear: hmm... i didn't think about that
00:21:34 <dmwit> ?hoogle (Ord a) => a -> a -> a
00:21:35 <lambdabot> Prelude.max :: Ord a => a -> a -> a
00:21:36 <lambdabot> Prelude.min :: Ord a => a -> a -> a
00:21:36 <lambdabot> Prelude.asTypeOf :: a -> a -> a
00:21:39 <joelr1> there's something about output groups but that doesn't clear buffer
00:21:47 <joelr1> maybe i'm asking in the wrong channel :D
00:23:19 <dons> sjanssen: check your mail box. comments within the next 12 hours would be good :-)
00:28:10 <sorear> How do I tell ocaml "import Prel"?
00:43:48 <procyon112> can I pattern match in guards?
00:45:36 <dmwit> procyon112: I think you have to do all the pattern matching before the guard.
00:45:41 <matthew-_> procyon112: yes, but it's a ghc extension
00:46:27 <sorear> hehe.  I like the idea of ocaml's = throwing a runtime error if called at functional type ;)
00:46:59 <matthew-_> > let n = Just 3 in case n of _ | Nothing <- n -> False; m | Just x <- m -> x > 2
00:47:00 <lambdabot>  Parse error
00:48:46 <matthew-_> procyon112: err, that example does work in ghci with glasgow-exts, just not a lambdabot ;)
00:49:20 <procyon112> :)
00:49:41 <procyon112> thx.  I think I will use mutually recursive functions though... cleaner.
01:05:58 * sorear just caught himself defining return in ocaml
01:08:28 <joelr1> sorear: why do you use ocaml?
01:08:42 <sorear> joelr1: experiment
01:08:59 <joelr1> cool
01:09:04 <sorear> joelr1: I just today figured out how to write an unlambda compiler
01:09:27 <joelr1> sorear: you must have a lot of time on your hands
01:09:27 <sorear> targetting GHC, it runs 22x faster than the fast C interpreter
01:09:30 <joelr1> ;-)
01:09:40 <sorear> to the best of my knowledge it is the very first compiler
01:09:55 <sorear> but the code does not take any advantage of laziness
01:10:02 <joelr1> the very first unlambda compiler targeting ghc and written in ocaml?
01:10:22 <sorear> no, now it is targeting ghc and written in portable haskell
01:10:39 <sorear> soon it will still be written in haskell but targeting ocamlc
01:10:55 <joelr1> oh
01:11:00 <sorear> er, ocamlcopt
01:11:03 <sieni> written in befunge and targeting ghc... now that would be impressive
01:11:48 <sorear> actually the compiler is trivial
01:12:04 <sorear> i have embedded unlambda as a dsl in ocaml and ghc
01:12:27 <sorear> so all I need to do is translate into normal syntax, and add some kind of prologue/epilogue
01:13:05 <joelr1> is there a command to run ghc from within emacs? to be able to click on errors and be taken there
01:13:08 <sorear> the inventor of unlambda claims that after much thought, he is pretty sure the language cannot be compiler...
01:13:18 <sorear> M-x compile
01:13:22 <sorear> then use C-`
01:13:57 <joelr1> C-` is undefined
01:14:02 <joelr1> what does it do for you/
01:14:14 <sorear> sorry, C-x `
01:14:47 <joelr1> no next-error capable buffer found
01:15:02 <joelr1> :t mapM
01:15:04 <lambdabot>     Ambiguous occurrence `mapM'
01:15:04 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
01:15:16 <sorear> you need to run M-x compile first ;)
01:15:22 <joelr1> ah
01:15:22 <sorear> :t Prelude.mapM
01:15:25 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
01:18:54 <joelr1> sorear: any way to "re-run compile"?
01:18:58 <joelr1> i.e. run last command
01:19:31 <sorear> It should says .... (default: ...):  or suchlike
01:19:35 <sorear> just press RET
01:19:37 <joelr1> recompile. but that's not bound to a key
01:19:38 <joelr1> ok
01:24:59 <DRMacIver> Hm. Does Haskell have any sort of 'array' class? I need a table of integer -> 'a with O(1) lookup. (I don't care too much what the update time is like. I mean, O(n!!!) would be bad, but O(n) isn't a big deal)
01:25:45 <sorear> Are you sure you mean Integer?
01:25:53 <DRMacIver> Not really.
01:26:03 <sorear> Are the valid indexes limited to some range?
01:26:13 <DRMacIver> It's a colloquial integer rather than anything else. :) Int32 would be fine.
01:26:19 <mux> you provide the bounds when creating the array so  you could use Integer's
01:26:23 <sorear> And are they dense in that range
01:26:24 <sieni> DRMacIver: is n!!! here (n!!)!, (n!)!! or ((n!)!)!?
01:26:36 <DRMacIver> sorear: Yes.
01:26:45 <sorear> DRMacIver: then you want
01:26:49 <sorear> @docs Data.Array
01:26:50 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
01:26:55 <DRMacIver> sieni: They're all pretty awful. :)
01:27:01 <DRMacIver> sorear: Oh, ha ha. I should have looked there. :)
01:27:09 <DRMacIver> Sorry
01:27:20 <sorear> if your data is of a primitive type (Int, Bool, etc), you will gain *immensely* from:
01:27:24 <sorear> @docs Data.Array.Unboxed
01:27:24 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-Unboxed.html
01:27:56 <sorear> there are also IO and ST arrays, which give you O(1) update - but force you to sequence your operations monadically.
01:28:16 <sorear> ST is like IO but escapable:
01:28:23 <sorear> @ty Control.Monad.ST.runST
01:28:25 <lambdabot> forall a. (forall s. ST s a) -> a
01:28:43 <DRMacIver> The data isn't a primitive unfortunately.
01:28:56 <sjanssen> and DiffArray, which can give you O(1) updates in a pure setting, by making deals with the devil
01:29:32 <sorear> but DiffArray has a v. large constant factor (mostly for thread safety reasons)
01:29:33 <DRMacIver> I really don't care about the updates. :) This is set up once at the beginning of the program and then never changes. But that's useful to know, thanks.
01:29:58 <sjanssen> anyway, Data.Array should work fine for you
01:31:30 <joelr1> sorear: if my derived class was FunParser, how would create an instance for  [NumExpr]?
01:31:47 <joelr1> instance FunParser [NumExpr] where <- doesn't work
01:31:56 <sorear> joelr1: right.
01:32:08 <sorear> joelr1: do you need all lists to work similarly?
01:32:24 <sorear> [a,b,c,d,e] -- will this work for ALL your lists?
01:32:40 <joelr1> sorear: hmm... i guess so. they are comma-separated lists in my case. i would prefer to instantiate them separately though
01:33:12 <joelr1> enclosed in parenthesis
01:33:31 <joelr1> (a, b, c, d) since i'm using derive to do function call parsers
01:33:45 <sorear> haskell 98 requires type class instances to only care about the outermost constructor
01:34:09 <sorear> you can guide derive using newtypes, though it might not be terribly pleasant
01:34:23 <sorear> derive works using the compiler to parse data declarations
01:34:36 <sorear> this hurts because it's impossible to annotate a data
01:34:45 <sorear> like "this field should be comma-separated"
01:34:53 <sjanssen> or you could just -fglasgow-exts and stop worrying about it :)
01:35:06 <joelr1> hmm
01:35:10 <joelr1> that would work for me
01:36:27 <sorear> I'm liking ML ... a little too much
01:36:53 <sieni> sorear: well, ML is nice <3
01:36:54 <joelr1> sorear: i liked it a whole lot too
01:37:07 <joelr1> until i had to hook up my compiler to the web
01:37:15 <joelr1> which is why i'm rewriting it in haskell
01:37:30 <sorear> ocaml uses sockets!?
01:37:33 * sorear straces
01:37:40 <sieni> I also like many different women even though they have quite different characteristics
01:37:57 <sorear> Oh, you mean lack of network support?
01:38:24 <sorear> Heh.  I thought it was "Why does my *compiler* need Internet access?"
01:38:36 <joelr1> sorear: mainly, it's community support for the libraries
01:39:01 <sorear> joelr1: huh?
01:39:01 <joelr1> sorear: for example, i can get help with haskell stuff, including networking and web apps any time on cafe or here
01:39:18 <joelr1> and there's wash or happs for web stuff
01:39:42 <sjanssen> ocaml doesn't have an analog?
01:39:44 <joelr1> with ocaml there's ocamlnet if you want a constructor set but there's just one guy behind it, really
01:39:58 <joelr1> and that guy is busy
01:40:12 <joelr1> and the library is hard to comprehend
01:40:45 <joelr1> then there are a couple of other web solutions but they are still unsatisfying
01:41:12 <joelr1> then i tried the ocaml ffi to package my translator as a ruby class
01:41:22 <joelr1> and the ffi is godawful compared to haskell
01:41:38 <DRMacIver> Hm. I wonder how much type erasure one can get away with in a language with subtyping.
01:41:51 <pejo> sorear, what is it you like with ML?
01:41:56 <joelr1> and i could not package my stuff such that i could build a shared library with ruby, etc. etc.
01:42:09 <joelr1> but ocaml was VERY straightforward
01:42:15 <joelr1> and very fast to boot
01:42:19 <sorear> DRMacIver: as much as you want, see unsafeCoerce# :)
01:42:36 <DRMacIver> sorear: Heh. Well, I mean "in a type safe manner" obviously. ;)
01:42:47 <joelr1> @where option
01:42:47 <sorear> pejo: can't really say.
01:42:47 <lambdabot> I know nothing about option.
01:43:10 <joelr1> :t Text.ParserCombinators.Parsec.option
01:43:12 <lambdabot> forall a tok st. -> Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
01:43:20 <pejo> DRMacIver, just any type system, or some specific? (Hindley-Milner?)
01:43:23 <DRMacIver> I'm essentially wondering about how much of the subtyping can be handled purely at compile time. I think the answer is most - you just need tagged unions in some cases.
01:43:25 <sorear> Three guesses what has caused me the most difficulty with ML.
01:43:31 <DRMacIver> pejo: Well I had in mind ML_sub
01:44:01 <DRMacIver> Possibly Daniel Bonniot's flavour of ML_sub with structural interfaces.
01:45:20 <DRMacIver> (If you have no idea what I'm talking about, imagine Hindley Milner + Subtyping + Haskell's type classes)
01:45:50 <pejo> DRMacIver, "Polymorphic subtyping in O'Haskell" by Nordlander might be a good start.
01:47:09 <joelr1> is there a shorter way to write this? just p = p >>= return . Just
01:47:34 <joelr1> i sense a flip can eliminate the p
01:47:49 <joelr1> :t just a = a >>= return . Just
01:47:51 <lambdabot> parse error on input `='
01:48:10 <dmwit> just = return . Just <<=
01:48:22 <joelr1> :t <<=
01:48:25 <lambdabot> parse error on input `<<='
01:48:26 <dmwit> :t (<<=)
01:48:29 <lambdabot> Not in scope: `<<='
01:48:32 <dmwit> :t (=<<)
01:48:35 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
01:48:39 <sjanssen> joelr1: just = fmap Just
01:49:07 <joelr1> right! thanks!
01:49:22 <joelr1> i think =<< is handy too. i should remember it
01:49:47 <DRMacIver> pejo: Mm. I'll take a look. Thanks.
01:50:18 <sjanssen> sorear: I think we're too lazy to guess
01:51:02 <sorear> val foo (a :: int) = ...
01:51:14 <sorear> er, let
01:51:21 <DRMacIver> Heh
01:51:37 <DRMacIver> I find switching between ML and Haskell amazingly hard.
01:52:00 <DRMacIver> The syntaxes are just slightly different, and there's no real correlation between good ML code and good Haskell code.
01:52:42 <sieni> DRMacIver: yeah, like trying to learn spanish and italian at the same time
01:53:27 <sieni> the inverted meaning of : and :: is also quite a charm :-)
01:53:40 <DRMacIver> Well, I know more ML than Haskell. So perhaps it's more like trying to learn spanish when you already know vaguely good italian and regularly visit italy. :)
01:54:01 <DRMacIver> (Although actually, now that I think about it I've not written any ML in *ages*)
01:54:21 <DRMacIver> Yeah, the : and :: difference drove me mad when I was first learning Haskell. :)
01:54:42 <sorear> let ess0 (na : expr) : node cps = na >>= (return <. ess1) ;;
01:54:58 <sorear> Yup, I just can't live without my monads :)
01:55:03 <sieni> I would need a sensible project to improve my skills (in at least, say Haskell, Standard ML and C++)
01:55:24 <sorear> Actually quite a bit shorter than the longhand cps version.
01:55:36 <DRMacIver> I'm currently playing with creating languages. So that gives me a great reason to play with Haskell. :)
01:55:59 <DRMacIver> Although my main language creation project at the moment is in Java.
01:57:03 <DRMacIver> Which reminds me, I need to fix my parser for that. When I was actually trying to use it I discovered it couldn't handle generics, which upset me.
02:00:06 <DRMacIver> (The level of awkardness of javacc compared to parsec really makes me sad. :-/ I should try to find something better)
02:00:35 <joelr1> > flip True
02:00:37 <lambdabot>  Couldn't match expected type `a -> b -> c'
02:00:46 <matthew-_> DRMacIver: for java, I really like antlr
02:01:24 <joelr1> :t flip
02:01:27 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
02:01:30 <Syzygy-> > let flip = not in flip True
02:01:31 <lambdabot>  False
02:01:40 <matthew-_> lol
02:01:44 <joelr1> :t not
02:01:46 <lambdabot> Bool -> Bool
02:02:30 <dmwit> > let flip = pred in flip True
02:02:32 <lambdabot>  False
02:02:42 <Syzygy-> > pred False
02:02:44 <lambdabot>  Exception: Prelude.Enum.Bool.pred: bad argument
02:02:46 <joelr1> :t pred
02:02:46 <Syzygy-> HEhe
02:02:48 <dmwit> ;-)
02:02:49 <lambdabot> forall a. (Enum a) => a -> a
02:03:03 <joelr1> what does pred do?
02:03:18 <dmwit> joelr1: It gives the enumerated type just before the one given.
02:03:18 <Syzygy-> Returns the previous element of that Enum.
02:03:23 <dmwit> i.e. predecessor
02:03:28 <dmwit> > pred 3
02:03:30 <Syzygy-> And Bool is an Enum, with False < True.
02:03:30 <lambdabot>  2
02:03:32 <joelr1> :t succ
02:03:35 <lambdabot> forall a. (Enum a) => a -> a
02:03:37 <joelr1> cool
02:04:04 <pejo> DRMacIver, there's some funky interactions between type classes and subtyping iirc. I can't really talk right now though, good luck with the subtyping!
02:04:16 <DRMacIver> matthew-_: Hm. I'll give it a go.  Thanks.
02:04:31 <DRMacIver> pejo: Well I'm not actively doing anything with it at the moment, just speculating. :) Thanks though.
02:04:45 <DRMacIver> (I have a large number of random trains of thought on the go at any one time. It keeps me from getting bored)
02:04:59 * joelr1 is gonna solicit code refactoring suggestions
02:05:02 <joelr1> @paste
02:05:02 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:05:42 <hpaste>  joelr1 pasted "how can i refactor this?" at http://hpaste.org/1278
02:05:52 <joelr1> any suggestions?
02:05:56 <joelr1> it looks very ugly to me
02:06:26 <Syzygy-> :t choice
02:06:29 <lambdabot> Not in scope: `choice'
02:06:43 <joelr1> choice is a parsec combinator
02:06:50 <Syzygy-> Oh. right.
02:06:50 <joelr1> after' is one of mine
02:06:59 <joelr1> after xs a = reschoice xs >> a
02:07:04 <joelr1> after' xs x = reschoice xs >> return x
02:07:35 <joelr1> after takes a parser, thus no return
02:09:08 <joelr1> for one i should probably have seq xs = sequence $ fmap reserved
02:09:19 <joelr1> so that i can do seq [ "Next", "Bar" ]
02:09:25 <dmwit> :t seq
02:09:28 <lambdabot> forall a t. a -> t -> t
02:09:32 <dmwit> (seq is already taken)
02:09:33 <joelr1> but that's not the part i'm worried about
02:09:36 <joelr1> dmwit: yeah
02:10:25 <joelr1> the tricky bit is that the 2nd word (lower/higher) changes depending on whether you are selling or buying
02:17:26 <sorear> Interesting.
02:17:36 <joelr1> what>
02:18:03 <sorear> As a backend for my unlambda compiler, ocamlopt was exactly as fast as ghc -O2.
02:18:12 <joelr1> hmm
02:18:19 <sorear> not faster or slower by any detectable amount
02:19:47 <sorear> goodnight.
02:20:02 <sjanssen> that proves it.  All those "OCaml is faster" claims are bullocks :)
02:20:11 <therp> good morning everyone
02:21:03 <sorear> sjanssen: basically the two were operating from the same code.
02:21:49 <sorear> sjanssen: the ocaml was explicit CPS w/ side effects, the haskell became cps w/ state threads at the simplifier..
02:22:14 <sorear> I'm pretty sure ocamlopt *itself* was faster than ghc -O2 ;)
02:22:26 <joelr1> sjanssen: if you wanna see the real goods time building ghc vs ocaml ;-)
02:22:48 <mnislaih> Igloo: where is cabal-install repo now ?
02:22:56 <joelr1> ghc = hours?, ocaml = a few minutes
02:23:05 <sjanssen> joelr1: that is most likely an apples to oranges comparison
02:23:13 <dons> ghc thinks harder ;-)
02:23:22 <sjanssen> ghc is less than an hour on a modern-ish system
02:23:24 <sorear> joelr1: ghc = 90 minutes; they changed HEAD in a way that dramatically speeds the bootstrap
02:23:25 <joelr1> sjanssen: only because ghc builds more libraries, possibly
02:23:27 <sjanssen> 10 minutes if you're dons
02:23:30 <dons> just building stage1 of the ghc build system (i.e. just the compiler) can be done in around 2 minutes.
02:23:33 <sorear> sjanssen: 6.
02:23:39 <dons> building the compiler *twice*, then the libraries, 6 minutes
02:23:42 <dons> priceless.
02:23:52 <sorear> dons: doesn't stage one need to build base?
02:24:02 <sorear> dons: I can't imagine stage two is standalone :)
02:24:04 <dons> nope. it uses the old base.
02:24:13 <joelr1> dons: i'm not dissing ghc, i'm rewriting from ocaml myself. just noting the obvious
02:24:14 <dons> stage1 + libs is standalone.
02:24:17 <dons> :-)
02:24:38 <therp> soreor: what are the tricks for speeding up bootstrapping?
02:24:43 <joelr1> dons: and i'm talking about building a production version
02:25:23 <sorear> dons: in case you missed it, I figured out how to write an unlambda compiler today ... I implemented it first targeting potable Haskell, then Ocaml.  The final executables were both 22x the speed of the reference interpreter.
02:25:37 <opqdonut> haha
02:25:37 <sorear> no difference between ghc -O2 w/o primops and ocamlopt!
02:26:07 <sjanssen> sorear: ah, the Haskell code wasn't especially low level?
02:26:18 <dons> ghc -O2 =~ ocamlopt
02:26:28 <dons> xavier =~ simonpj
02:26:34 <dons> ;-)
02:26:48 <joelr1> @paste
02:26:49 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:27:22 <hpaste>  joelr1 pasted "any suggestions?" at http://hpaste.org/1279
02:27:25 <sorear> then again, this was my very first ocaml program :)
02:27:25 <sorear> therp: -fasm
02:27:25 <sorear> @botsnack
02:27:25 <lambdabot> :)
02:27:26 <sorear> grr.
02:28:22 <sorear> sjanssen: Nope.  Hand-coded contt io monad in the obvious way (no h98 mtl); character IO; recursive newtypes and native haskell functions.
02:29:23 <sorear> joelr1: that would be my fault
02:29:47 <matthew-_> um, if I'm cabalising some code which is going to make an executable (not a library) so there are no exposed modules, do I have to list the transitive closure of modules imported by the Main or just the immediate imports?
02:29:49 <joelr1> sorear: how come? generated code not general enough?
02:29:49 <sorear> joelr1: I assumed your parser was stateless so I said in the class 'CharParser s a', ie ANY state
02:30:02 <dons> matthew-_: you don't list anything
02:30:09 <dons> but in the executable section you set Main-is: Main.hs
02:30:20 <dons> see, e.g. cpuperf on hackage.haskell.org for an example
02:30:20 <joelr1> sorear: hmm... so this can't be solved with type signatures?
02:30:26 <sorear> joelr1: since you have a state, define a type for it, refine the type of the class method
02:30:28 <sorear> joelr1: right.
02:30:28 <joelr1> i.e. you can't generate code for any state?
02:30:32 <matthew-_> dons: many thanks
02:31:23 <sorear> joelr1: so chage  'parse :: CharParser s a' in the class to 'parse :: CharParser <state> a', where <state> is your state type
02:31:54 <sorear> matthew-_: also setting Other-modules is a Good Idea because it allows haddock and sdist to work.
02:32:42 <matthew-_> if I have several executables, can I just set hs-source-dirs and ghc-options in the main stanza rather than replicating them everywhere in the executable stanzas?
02:33:04 <sorear> no, there's a cabal bug that will mis-parse that
02:33:09 <matthew-_> ok, ta
02:33:17 <sorear> bye.
02:34:12 <joelr1> dons: what are the papers about?
02:36:24 <dons> busy busy .... deforestation for lists, and high perf monte carlo simulators
02:36:36 <joelr1> dons: yes! monter carlo!
02:36:51 <joelr1> i want monte carlo!
02:36:55 <LeCamarade> Now, all, if I have a function that returns stuff in the IO monad, how can I use it recursively?
02:37:13 <dons> joelr1: yeah, we talk about financial simulations a fair bit
02:38:19 <ToRA> @type (let f x = if x == 1 then return 1 else f (x-1) in f)
02:38:21 <lambdabot> forall a (m :: * -> *) t. (Num t, Monad m, Num a) => a -> m t
02:38:26 <ToRA> LeCamarade: like any normal function?
02:38:57 <dons> thanks sjanssen
02:39:54 <LeCamarade> ToRA: Actually, I should have said it returns an action. I need to use it recursively. I am trying to write the filesystem as a tree. Lemme see if I can dump at hpaste.
02:40:01 <hpaste>  joelr1 annotated "any suggestions?" with "arghh" at http://hpaste.org/1279#a1
02:41:42 <ToRA> joelr1: what's that map a mapping of?
02:42:03 <joelr1> oh
02:42:04 <ToRA> you sig says it's a mapping of strings to /every/ type
02:42:11 <joelr1> i'm an idiot
02:42:12 <joelr1> again
02:43:07 <ToRA> joelr1: that can't be true, you're using liftM3 :)
02:43:28 <joelr1> ToRA: i'm a very peculiar kind of an idiot
02:46:07 <hpaste>  LeCamarade pasted "Recursively Perform the IO Action? But How?" at http://hpaste.org/1280
02:46:49 <LeCamarade> Okay, monks. My horror is at hpaste, now.
02:47:33 <ToRA> does sequence help?
02:47:38 <ToRA> @type sequence
02:47:40 <lambdabot>     Ambiguous occurrence `sequence'
02:47:41 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
02:48:13 <ToRA> @type Prelude.sequence
02:48:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
02:50:32 <LeCamarade> Which module gives me the separator used on the operating system? System.Directory? I don't see it!
02:50:51 <dons> use the filepath library
02:50:56 <dons> ?hackage filepath
02:50:56 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/filepath
02:51:34 <LeCamarade> dons: Not standard?
02:54:00 <hpaste>  ToRA annotated "Recursively Perform the IO Action? But How?" with "(no title)" at http://hpaste.org/1280#a1
02:54:17 <dons> the filepath is a core package now.
02:54:27 <dons> but accessing seperators isn't in the base library, no.
02:54:40 <ToRA> LeCamarade: that any help?
02:54:52 <fuzan> hey -- what does planet.haskell.org use for syntax highlighting?
02:55:10 <LeCamarade> ToRA: Hold on. Hold on, man. Wait ...
02:55:21 <dons> fuzan: there's an article on my blog about that.
02:55:24 <dons> its HsColour
02:55:53 <matthew-_> say you have x:: Maybe a where a is some ADT and you do case x of (Just (Constructor b)) -> b; _ -> Nothing. Is there a "better" way of stripping off the constructor?
02:56:00 <fuzan> dons: ah, found it. thanks :)
02:56:26 <fuzan> back to linux I go.
02:56:53 <ToRA> matthew-_: data X = Constructor { fromConstructor :: b } ; fromConstructor . fromJust  ?
02:57:06 <matthew-_> err, no fields
02:57:46 <ToRA> matthew-_, then you're going to have to pattern match to strip off the constructor arn't you?
02:58:37 <ToRA> oh, liftM (\Constructor b -> b) x would also do it
02:58:54 <Igloo> mnislaih: http://darcs.haskell.org/packages/cabal-install/
02:58:55 <lambdabot> Title: Index of /packages/cabal-install
02:59:08 <mnislaih> ah, thanks
02:59:16 <ToRA> (mm; something there doesn't quite type-check...)
02:59:36 <LeCamarade> ToRA: It worketh. Or should, when I'm done fixing my own bits. You rock.
02:59:44 <ToRA> np
03:00:39 <LeCamarade> Now, what is the use of Monad.liftM? Anybody care to give any example of the utility?
03:00:52 <ToRA> > liftM (+1) Nothing
03:00:54 <lambdabot>  Nothing
03:00:57 <ToRA> > liftM (+1) (Just 3)
03:00:59 <lambdabot>  Just 4
03:01:03 <ToRA> tons of use
03:01:05 <joelr1> dons: what's the link on your blog for hscolor?
03:01:43 <hpaste>  matthew-_ pasted "Doesn't work - pattern matches must be statically defined? Boo! Hiss!" at http://hpaste.org/1281
03:02:51 <ToRA> matthew-_: you're such a dreamer :p
03:03:03 <matthew-_> isn't there some weird extension to make that work?
03:03:33 <ToRA> matthew-_: wouldn't it fundamentally break some stuff ... like function application?
03:03:40 <joelr1> i don't see the articles on the dons blog
03:03:43 <LeCamarade> ToRA: Oh, so you use it to say `pass the Maybe-Child as the arg to this one, if the Maybe-Child is not a Nothing'?
03:03:56 <matthew-_> err, well it'd have to be a total function I think
03:04:11 <ToRA> LeCamarade: yeah in the case of maybe
03:04:16 <dmwit> matthew-_: There would have to be a way of inverting functions -- in general, not possible, right?
03:04:18 <ToRA> LeCamarade: liftM = fmap for monads
03:04:42 <Heffalump> LeCamarade: if you write do x <- m ; let y = f x
03:04:42 <joelr1> i think i do now
03:04:49 <Heffalump> you can write do x <- liftM f m
03:04:50 <Heffalump> instead
03:05:07 <dons> joelr1: hmm, its an old one.
03:05:10 <dmwit> matthew-_: If you can write that inverse yourself, then you can write the function you want.
03:05:10 <matthew-_> dmwit: yep, but it's ok for constructors of ADTs.
03:05:20 <joelr1> dons: looking in google reader
03:05:33 <dons> its also mentoined on tmoertal's blog
03:06:05 <LeCamarade> ToRA:  Hmm ... neat
03:06:15 <LeCamarade> Heffalump: Thanks.
03:06:15 <ToRA> matthew-_; just replace (v -> a) with (a -> v), make the whole function M.lookup >>= liftM, and pass in (\Constructor c -> c) as an arg?
03:06:24 <ToRA> matthew-_: filling in the appropriate blanks
03:06:57 <joelr1> dons: would hscolour support c# coloring, for example?
03:06:59 <matthew-_> yeah, that func sucks though
03:07:04 <joelr1> dons: can that be added?
03:07:08 <LeCamarade> @src sequence
03:07:08 <lambdabot> sequence ms = foldr k (return []) ms
03:07:09 <lambdabot>     where
03:07:09 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
03:08:03 <matthew-_> ToRA: and you either meant liftM f . M.lookup or M.lookup >>= f ;)
03:08:48 <ToRA> matthew-_: M.lookup >>= return.f most likely
03:08:52 <matthew-_> quite
03:09:26 <matthew-_> oh grrrr, you can't do pattern matching on functions
03:09:27 <matthew-_> let x = Just in case x of Just -> True; _ -> False
03:10:27 <Orphi> hi peeps.
03:10:38 <ToRA> matthew-_: was that a simple example, or you just wanting Maybe.isJust ?
03:10:48 <matthew-_> that was just a simple example
03:10:54 <Orphi> just a short one... how do I write a function that returns x + 1?
03:11:02 <Orphi> i.e., WITHOUT being lazy
03:12:05 <opqdonut> well, the context of the function call can force it to be evaluated immediately
03:12:41 <Orphi> basically I'm writing a block of code with lots and lots of functions where I don't "need" laziness
03:12:55 <Orphi> would f x = id $ x + 1 would?
03:13:04 <Orphi> er... I mean $1
03:13:06 <Orphi> no...
03:13:08 <Orphi> $!
03:13:08 <dmwit> Orphi: Take a look at seq.
03:13:12 <dmwit> :t seq
03:13:14 <lambdabot> forall a t. a -> t -> t
03:13:35 <dmwit> f x = x + 1 `seq` x + 1, maybe?  I've never really played with strictness, though, so I'm not sure.
03:13:44 <Orphi> mmm... maybe
03:13:46 <dmwit> (+) is strict already, though.
03:14:02 <ToRA> matthew-_: i think there's something fundamentally wrong if you need to pattern match on functions; your functions are supposed to tell each other apart by their behaviour when applied to arguments.  It's like using case/instanceof's instead of subclass polymorphism...
03:14:25 <Orphi> yeah, but f x = x + 1 will just return the expression x + 1
03:14:52 <Orphi> chain a few dozen such functions together and try to execute it 44100 times a second and... it won't be pretty
03:15:04 <dmwit> Orphi: No, (+) is strict.
03:15:31 <Orphi> dmwit: only when you try to execute it
03:16:26 <ToRA> > let f = (undefined + 1) `seq` False in f
03:16:28 <lambdabot>  Undefined
03:16:53 <dmwit> > let x = undefined + 1 in 3
03:16:55 <lambdabot>  3
03:17:08 <Orphi> > let f x = let y = x + 1 in y `seq` y    in f undefined
03:17:10 <lambdabot>  Undefined
03:17:15 <Orphi> > let f x = let y = x + 1 in y `seq` y    in f 7
03:17:17 <lambdabot>  8
03:17:24 <Orphi> ok... that looks like it can work.
03:17:51 <dmwit> Orphi: But see ToRA's evaluation, too.
03:19:38 <Orphi> > let f x = id $ x + 1 in f 7
03:19:40 <lambdabot>  8
03:19:44 <Orphi> > let f x = id $ x + 1 in f undefined
03:19:45 <lambdabot>  Undefined
03:19:50 <Orphi> hmm... ok, thanks guys.
03:20:02 <dmwit> > let f x = x + 1 in f undefined
03:20:04 <lambdabot>  Undefined
03:20:11 <Orphi> yeah, true
03:20:28 <Orphi> time to go profile...
03:21:03 <LeCamarade> You know, guys? I am a bit uncomfortable with how frequently `forall' shows up. I mean, for something I have never used. Am I missing the party? What drinks are being served? What's `forall'?
03:21:54 <dmwit> > let f a = a in f undefined `seq` True
03:21:55 <Heffalump> in what?
03:21:56 <lambdabot>  Undefined
03:22:06 <Heffalump> it's just a somewhat hidden part of a type
03:22:10 <Heffalump> forall a . a -> a
03:22:20 <opqdonut> LeCamarade: "forall a. a -> a" is what you usually think of as "a -> a"
03:22:29 <Heffalump> means that you have a function that takes a value of type a, and gives you a value of type a, for any a.
03:22:36 <dmwit> Is there a way to tell apart strict and lazy functions using just lambdabot?
03:22:39 <opqdonut> when there are no quantifiers a free variable is "forall"
03:22:58 <LeCamarade> opqdonut: Where the `->' is for types, not functions, right?
03:23:07 <Heffalump> LeCamarade: right.
03:23:12 <Heffalump> but -> is the type of a function.
03:23:15 <dmwit> > let f a b = b in f undefined 3
03:23:17 <lambdabot>  3
03:23:22 <Heffalump> you should only see forall in types, not in expressions
03:24:07 <LeCamarade> So, I don't need to lose sleep over it - until I take over dons' coat? And SPJ's vest?
03:25:58 <Heffalump> correct :-)
03:26:49 <LeCamarade> Thanks, then. :oD Phew!
03:27:08 <LeCamarade> ?yow
03:27:09 <lambdabot> over in west Philadelphia a puppy is vomiting ...
03:27:19 <dmwit> ?quote
03:27:20 <lambdabot> BjarneStroustrup says: any verbose and tedious solution is error-prone because programmers get bored. [S 9.4 of C++, 2nd edition]
03:27:34 <LeCamarade> ?quote
03:27:35 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich internet application-driven environment.
03:27:35 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
03:27:53 <DRMacIver> Heh
03:28:01 <LeCamarade> ?fortune
03:28:01 <lambdabot> The idea of male and female are universal constants.
03:28:01 <lambdabot> 		-- Kirk, "Metamorphosis", stardate 3219.8
03:29:39 <DRMacIver> What's the relevance of Yoneda's lemma in Haskell?
03:29:51 <DRMacIver> Other than Haskell generally being a category theorist's wet dream.
03:33:54 <LeCamarade> data Tree a = Leaf a | Branch [Leaf a] | BadLeaf a
03:34:40 <LeCamarade> Why does that throw an error (on compiling), that the constructor Leaf is not known.
03:34:51 <dmwit> Branch [Tree a]
03:35:16 <dmwit> Leaf is a value constructor, Tree is a type constructor.
03:36:13 <dmwit> ?yarr
03:36:14 <lambdabot> Well Ahoy! thar.
03:36:40 <LeCamarade> dmwit: Ah! I'm not thinking sane.
03:36:41 <LeCamarade> Thanks.
03:36:41 <LeCamarade> A big fat bunch.
03:37:03 <LeCamarade> let asmanyasyouwant = 20 in take asmanyasyouwant $ repeat "Thanks, "
03:37:13 <dmwit> heh
03:37:16 <yip> http://skyways.lib.ks.us/ksevents/hsfair/fairbook.html
03:37:18 <lambdabot> Title: HASKELL COUNTY FAIR BOOK
03:37:42 <LeCamarade> ?tiny
03:37:42 <lambdabot> Url not valid.
03:38:02 <dmwit> WATER FIGHT!
03:38:27 <LeCamarade> ?tiny http://skyways.lib.ks.us/ksevents/hsfair/fairbook.html
03:38:29 <lambdabot> http://tinyurl.com/26nzpa
03:40:10 <LeCamarade> clear
03:41:37 <tsp> program som k√∂rs...
03:43:44 <yip> http://research.microsoft.com/~akenn/fun/picklercombinators.pdf
03:44:01 <yip> anyone know if there is a library available that implements the ideas in that paper?
03:44:55 <dons> there's certainly Data.Binary, which is close, i suppose.
03:45:11 <dons> joerlr had a go with picklers, and didn't get terribly efficient serialisation
03:46:40 <yip> hm... i'm actually interested in serializing into a string
03:48:22 <dons> into a bytestring?
03:48:24 <dons> or string?
03:48:31 <dons> strings will be terribly inefficient.
03:48:41 <dons> and you can always just serialise to a bytestring, then unpack
03:49:04 <yip> ok bytestring, but using only ascii characters
03:49:54 <dons> yeah, so Data.Binary should be fine for that, and fast.
03:49:58 <dons> ?hackage binary
03:49:59 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
03:50:45 <yip> but Data.Binary doesn't seem to have the feature from that pickling paper, where you get a both a serialize function and parse function from a single data description
03:51:06 <dons> right.
03:51:23 <dons> you write an instance of binary
03:51:35 <dons> of Binary, which lets you specify the parser as an inverse of the serialiser
03:51:39 <dons> there's tools to derive those though.
04:03:53 <yip> how do those tools work?
04:07:09 <mr_tenor> man... i just found this: http://files.qkwozz.com/funnies/higherorder.jpg
04:07:42 <mr_tenor> i wonder how many people passing these images around get it
04:08:34 <ivanm> is that map definition even valid?
04:08:45 <ivanm> doesn't it have to be (x:xs) on the LHS of the last line? ;-)
04:09:08 * yip doesn't get it
04:09:13 <ToRA> @src map
04:09:14 <lambdabot> map _ []     = []
04:09:14 <lambdabot> map f (x:xs) = f x : map f xs
04:09:19 <mr_tenor> heh
04:09:32 * ivanm doesn't get the joke either...
04:10:20 <ivanm> or is the error meant to be the joke?
04:10:29 <ivanm> if so, it's not very funny...
04:10:36 <mr_tenor> http://en.wikipedia.org/wiki/Kittah
04:10:36 <lambdabot> Title: Kittah - Wikipedia, the free encyclopedia
04:11:02 <ToRA> maybe it's some clever comment on the fact that the cat image has now been lifted to a higher level as being a joke that can accept other jokes to make them funny...
04:11:04 <mr_tenor> http://www.encyclopediadramatica.com/index.php/I_am_in_your_base_killing_your_d00ds
04:11:07 <lambdabot> Title: I am in your base killing your d00ds - Encyclopedia Dramatica, http://tinyurl.com/yz3esx
04:11:24 <mr_tenor> it's been an internet meme for the last 1/2 year maybe
04:12:17 <ivanm> o...k... then...
04:13:04 <mr_tenor> so as you observe, the disconnect between haskell and cat pictures is pretty large. that's why it shocked me.
04:13:17 <ivanm> yes...
04:13:32 <ivanm> though someone definitely has way too much time on their hands...
04:13:42 <mr_tenor> that's the internet for you :)
04:16:31 <joelr1> is anyone using the emacs haskell mode?
04:16:38 <joelr1> err, ghci
04:16:41 <joelr1> from emacs
04:16:44 <ivanm> yep
04:16:50 <ivanm> not atm, that is, but I use it
04:16:56 <ivanm> latest version, IIRC
04:17:02 <joelr1> do you like it? any issues?
04:17:30 <joelr1> ivanm: how do you invoke it?
04:18:09 <ivanm> C-z when inside a haskell file
04:18:14 <ivanm> then C-l to load the file
04:19:37 <joelr1> yay
04:19:47 <joelr1> wow
04:19:50 <joelr1> awesum!
04:20:12 <yip> joelr1: you've had a go with picklers?
04:20:31 <joelr1> yip: picklers? why do you ask?
04:20:46 <yip> joelr1: I am interested in picklers
04:21:41 <joelr1> i think you may want to use the new binary librari, that's what i would use now
04:22:13 <joelr1> i tried the approach in "pickler combinators" (paper by andrew kennedy, i think) but it didn't work out _that_ well
04:22:31 <yip> this paper? http://research.microsoft.com/~akenn/fun/picklercombinators.pdf
04:22:36 <joelr1> yes
04:23:01 <yip> i am interested in that approach because you write a single function and you get both a serialize function and a parse function
04:23:14 <araujo> morning
04:23:14 <mr_tenor> ooo
04:23:30 <joelr1> yip: i think hat's a different paper
04:23:42 <joelr1> the one on invertible arrows or something like that
04:23:50 <joelr1> yip: but maybe i'm mistaken
04:24:58 <yip> well my understanding is that you use combinators to make a PU MyType value, and then you can apply functions pickle and unpickle for serialization and parse
04:25:38 <joelr1> yip: right
04:26:15 <yip> so why doesn't Data.Binary take the same approach?
04:27:17 <dons> efficiency, and it takes the other route, based on the classic 'Bits between the lambdas' paper.
04:27:44 <dons> so rather than building an abstract structure representing the functions to read and show
04:27:51 <dons> you are required to directly write them as functions.
04:28:00 <dons> and we can spend more time thinking about how to (massively) optimise the result
04:28:07 <dons> if performance matters, it matters. :-)
04:29:23 <yip> what about sophisticated compiler optimization techniques?
04:31:49 <dons> i suppose we could spend a year working out how to do that. or we could just get something done now for people to use :-) so we did the latter.
04:31:53 <dons> does haskell need more papers?
04:32:15 <dons> Binary instances are rather easy to write, btw.
04:32:43 <ndm> or easy to automatically derive, using "derive"
04:32:43 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
04:32:47 <ndm> even in template haskell
04:32:57 <ivanm> what _is_ template haskell?
04:33:02 <ivanm> @where template haskell
04:33:03 <lambdabot> I know nothing about template.
04:33:17 <ndm> @google template haskell
04:33:18 <lambdabot> http://www.haskell.org/th/
04:33:19 <lambdabot> Title: Template Haskell
04:33:52 <ndm> @tell sorear that is a good sign - and honestly as I use it more, I get more used to it - although perhaps having a Yhc.Core AST and conversion would be simpler
04:33:52 <lambdabot> Consider it noted.
04:34:05 <ndm> @tell sorear less and more intuitive syntactic forms :)
04:34:05 <lambdabot> Consider it noted.
04:34:22 <matthew-_> ivanm: it's an efficient and comprehensive way to break your head via monumental confusion
04:34:41 <matthew-_> ivanm: but it's also quite useful ;)
04:34:49 <ivanm> lol
04:35:15 <ivanm> OK, but how does it do it? what's its underlying principle?
04:36:01 <matthew-_> basically, you get to write code that the compiler will execute. The code can then access and modify the AST of other parts of your code
04:36:35 <matthew-_> and can generate new code
04:36:50 <ivanm> so its a way of writing code that will write code?
04:37:25 <ndm> ivanm: yes, pretty much
04:37:50 <ndm> ivanm: although its got a reputation for being a bit fragile - we are hitting new pretty print bugs reliably every few days
04:38:21 <joelr1> ndm: ah! thanks again!
04:38:26 <ivanm> lol... pretty print?
04:38:36 <ndm> ivanm: the abstract syntax tree to text
04:38:38 <ivanm> is that the formatting for haskell output?
04:38:45 <matthew-_> yes
04:38:46 <ndm> joelr1: no problem, i'm glad its being useful :)
04:39:02 <ToRA> has anyone tried to do a runtime multi-stage/code generation project for haskell?
04:39:11 <matthew-_> pprint takes an AST of haskell code and makes a String representing the haskell code corresponding to the AST
04:39:14 <joelr1> ndm: i think i'll try to write a pretty printer based on sorear's code
04:39:16 <ivanm> ndm, matthew-_: k, thanks
04:39:29 <joelr1> ndm: and i should really try to understand the library
04:39:39 <ndm> joelr1: if you come up with anything, send it over :)
04:40:23 <LeCamarade> getHashHaskell >>= mapM hiIAmBack
04:41:13 <joelr1> ndm: that would be very specific to my code, i think. i just have a bunch of constructors where the name represents the function and args the fun args
04:41:40 <joelr1> stefan wrote the code to parse the function calls
04:41:48 <LeCamarade> I think it is like orders easier to write a garbage-collector for a (purely) functional language, than for an imperative one, right? After the last reference in the function, it can be freed, no?
04:41:49 <ndm> joelr1: fair enough then, but if you can think of reuse opportunities its always nice
04:41:57 <joelr1> sure
04:42:07 <ndm> LeCamarade: i would have said they are the same, pretty much
04:42:23 <ndm> LeCamarade: you define a reachability relation (typically trivial), then the hard bit is exactly the same
04:43:10 <LeCamarade> Well, can't you even make it static (and correct) in a PFL?
04:43:24 <LeCamarade> ndm: In a PFL you can make it static, no?
04:43:43 <ndm> LeCamarade: do you mean region inference?
04:43:59 <ndm> LeCamarade: as far as i'm aware, in a lazy language that tends to leak memory pretty bad
04:46:31 <LeCamarade> ndm: Well, I was thinking: funcCall x = let x = gigabyte in length x. The gig can be thrown away immediately, without worries about anybody else (in Java, a reference to the gig may still tarry). I think that bit is the harder part. The rest is a call for void free(void *);
04:47:04 <ndm> LeCamarade: kind of, sometimes - laszy evaluation complicates that
04:47:38 <ndm> LeCamarade: if funcCall is not used strictly, then you can't collect length - its very subtle
04:49:10 <LeCamarade> ndm: Hmm ... yeah, I see. But, you can collect lazily, as well. You can *statically* wire in a collector (which will be called lazily) just after the length part.
04:49:36 <LeCamarade> ndm: I guess I am asking if the Haskell GC could be re-implemented statically.
04:50:09 <ndm> LeCamarade: basic answer is look up region inference, perhaps - but its not been done yet in a way that isn't quite leaky - but it may well be possible
04:50:32 <joelr1> does anyone have a quickcheck generator for variable names?
04:50:41 <ndm> although you should remember that typically GC is faster than free/malloc
04:51:33 <LeCamarade> ndm: Because, when I once gave it some thought, non-purity was the reson we needed ref-counting (and usually a thread to do that). But with purity you can just be evil about the cleaning and still be correct.
04:52:03 <Heffalump> joelr1: no, but if you make one it'd be useful :-)
04:52:14 <ndm> LeCamarade: quite possibly - i believe laziness plays an issue too though - laziness can be considered a form of impurity with thunks and updating
04:52:27 <joelr1> someone sent me an example.. digging for it
04:52:38 <Heffalump> thunk evaluation is a side-effecting operation as far as the GC is concerned
04:53:46 <hpaste>  joelr1 pasted "qc variable name generator" at http://hpaste.org/1282
04:53:52 <joelr1> Heffalump: ^^
04:54:01 <LeCamarade> Hmm ... I should look at the GC's source. But that stuff gets scary. The source, I mean.
04:54:15 <LeCamarade> Lots of voodoo.
04:54:26 <Heffalump> joelr1: oh, I think a variable name generator needs more intelligence than that
04:54:40 <Heffalump> oh, I guess it depends on how you use them afterwards
04:54:53 <ndm> LeCamarade: perhaps take a look at Yhc first? simpler and more abstract
04:54:57 <Heffalump> to generate programs you probably just need to keep a list of variables you've got in scope and use that
04:55:05 <Heffalump> rather than hope your generator will produce repeats sometimes
04:55:10 <ndm> LeCamarade: plus if you do want to submit an alternative GC we have them pluggable and would happily accept another
04:55:23 <joelr1> Heffalump: you gotta start somewhere
04:55:40 <Heffalump> true
04:55:48 <LeCamarade> ndm: I'll look at Yhc. Not that I'm a seasoned Haskeller or anything. Alternative GC? Not before I am twenty years older, I think. :oD
04:55:55 <Heffalump> but one that simple I'd just write when I needed it, not bother looking for someone else's :-)
04:56:16 <ndm> the problem of generating syntactically correct and meaningful programs is a hard one
04:56:29 <Heffalump> I would generate syntax trees.
04:56:35 <ndm> things like QuickCheck aren't that suited, we have some stuff in development at York to do it
04:56:45 <ndm> even with syntax trees, most are meaningless
04:56:54 <ndm> unless you overrestrict, and then you end up not getting full coverage
04:56:59 <Heffalump> I started on a prototype of a C program generator for some stuff I wanted to do at ARM (in my spare time cos my manager wouldn't let me do it for work)
04:57:12 <ndm> how successful?
04:57:27 <Heffalump> didn't get that far, was just the skeleton of one
04:57:36 <Heffalump> I wasn't aiming for full coverage, just a restricted subset.
04:57:49 <ndm> I once did a Pasta program generator, was of slight use, but in program analysis checking the result usually means doing it manually
04:57:51 <Heffalump> the main thing I had working was an interpreter for the subset.
04:57:57 <ndm> and then a regression test suite is easier
04:58:55 <bakert> hello folks.  i can't quite remember how i get around this one: Could not find module `Data.Time.LocalTime':
04:58:56 <bakert>       it is a member of package time-1.0, which is hidden
04:59:00 <bakert> can you?
04:59:06 <bakert> ghc-pkg something something???
05:00:56 <ndm> ghc-pkg --help ?
05:01:13 <yip> bakert: are you using -O?
05:02:40 <bakert> well i tried ghc-pkg expoes time
05:02:49 <bakert> and  ghc-pkg expoes time-1.0 to no avail
05:03:03 <bakert> I am using -O
05:03:06 <bakert> or -0
05:03:10 <bakert> in the cabal file
05:03:14 <yip> try without -O
05:03:20 <bakert> perhaps i just need to add it to build-depends???
05:03:49 <bakert> oh sorry yes i think that was it.
05:03:50 <bakert> doh
05:03:53 <bakert> sorrreeeee!
05:04:09 <yip> well, it should also work with optimization. it's a bug in ghc 6.6
05:07:39 <joelr1> ndm, Heffalump: i'm trying to test my parser by generating arbitrary syntax trees, pp-ing them and re-parsing
05:08:06 <ndm> joelr1: ah, now that sounds like it would work well - since a semantically correct syntax tree is not required
05:09:04 <joelr1> ndm: i guess so. i used to produce expr that had everything bunched in them, for example, but then i could not produce a valid syntax tree. i had to split my expr into <type>Expr
05:09:16 <joelr1> now i think it should work
05:34:01 <hpaste>  TuringTest annotated "how can i refactor this?" with "(no title)" at http://hpaste.org/1278#a2
05:43:10 <dhart> Is there a smart way to fix cyclic imports in haskell?
05:43:41 <dons> use .hs-boot files to break the module recursion
05:43:46 <dons> check the ghc user's guide.
05:44:20 <dhart> kk
05:46:03 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1283
05:46:15 <mr_tenor> why doesn't the aboe work?
05:46:22 <mr_tenor> *above*
05:46:41 <mr_tenor> I thought that the types would be bound inside the topleel function
05:47:31 <dhart> I eallt don't like GHC's solution to cyclic imports
05:47:32 <ToRA> forall a . a -> a at the top level
05:47:40 <dhart> *really
05:48:13 <ndm> dhart: i would have said that it wasn't a solution, really - the answer is to not have cyclic imports
05:48:25 <dhart> right...
05:48:31 <ndm> dhart: generally putting your data type declarations into separate files will break most cycles
05:48:55 <hpaste>  ToRA annotated "(no title)" with "add a forall" at http://hpaste.org/1283#a1
05:49:15 <dhart> ndm: but then we get back to ugly C/C++ system of header and source files
05:50:07 <ndm> dhart: yes, what you'd really like is cyclic imports to be dealt with automatically, but that just doesn't happen
05:50:18 <dhart> ndm: thx for the help.
05:50:58 <mr_tenor> ToRA: thanks. "In Haskell, any use of a lowercase type implicitly begins with a forall keyword" according to http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types though :(
05:51:00 <lambdabot> Title: Haskell/Existentially quantified types - Wikibooks, collection of open-content t ..., http://tinyurl.com/f9umb
05:51:31 <joelr1> dons: does yi use the ghc 6.6 api?
05:52:06 <astrolabe> Not as ugly as C/C++ in my opinion because there is less repeated information.
05:52:30 <ToRA> mr_tenor: yeah - though here (/i think/) because you added the forall, the (ghc) type-checker knows that it's a new user type variable and treats sub uses as bound, instead of implicitly putting the forall before them too
05:52:41 <dons> joelr1: it does now, yes.
05:53:10 <ndm> dons: got your ICFP paper in yet?
05:53:12 <joelr1> dons: awesome! how much bigger does the api make it?
05:53:49 <dons> ndm, ha! 9 more hours!
05:54:05 <dons> ndm ... ICFP paper*s* ;-)
05:54:09 <ndm> dons: i know, i'm sat in the office with a pile of chocolate biscuits
05:54:15 <ndm> dons: oh!
05:54:20 <dons> hehe. us too. tim tams and green tea.
05:54:25 <dons> or 'proper tea' for duncan
05:54:31 <jyp> joelr1: 9952212 bytes (aka huge)
05:54:40 <dons> jyp, great work, btw.
05:54:44 <mr_tenor> ToRA: ah, gotcha. thanks! that's nasty if you aren't aware it's going on. the "`a1' is bound by" and "`a' is bound by" errors give some clue, but not the whole picture
05:54:47 <joelr1> ndm: what is your paper about?
05:54:47 * dons goes back to writing papers.
05:54:48 <dcoutts> property is theft!
05:54:50 <jyp> dons: thanks
05:54:51 <dons> jyp++
05:55:00 <ndm> joelr1: Catch
05:55:04 <ndm> @where catch
05:55:04 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
05:55:12 * dcoutts goes back to writing papers too (the same paper)
05:55:27 <joelr1> hehe
05:55:28 <dcoutts> ndm: how's your draft btw?
05:55:35 <joelr1> jyp: what's the work?
05:55:44 <ndm> dcoutts: done over a week ago, just polishing the last little bits from colin's final corrections
05:55:48 <jyp> joelr1: The yi stuff :)
05:55:50 <dons> joelr1: jyp has been the driver behind yi for the past 5 months.
05:55:55 <joelr1> so all these papers will soon be available someplace, right?
05:55:56 <ndm> dcoutts: been in Oxford all week, so not done anything on it
05:56:00 <dcoutts> ndm: bah you're organised ;-)
05:56:14 <joelr1> jyp = jean-philippe. what's the Y about? yi?
05:56:23 <ndm> we almost managed to get into a fight in Oxford centre, which i wasn't expecting
05:56:33 <dcoutts> ndm: did you win ?
05:56:46 <jyp> joelr1: No special significance I can remember... I got that nick for a long time.
05:56:52 <ndm> dcoutts: no, i stopped it from happening - taking my drunken friends home
05:57:02 <dcoutts> ndm: what was it over? strict or lazy typing, or static vs dynamic types ?
05:57:13 <dcoutts> erm typing/evaluation
05:57:29 <ndm> it was with locals, on the ettiquete of pushing into cash machine queues when you are two drunk to understand the concept of a line
05:57:32 <dcoutts> no I've got it, whether or not general recursion is legit
05:57:42 <dcoutts> oh, boring :-(
05:58:06 <ndm> remember BCTCS is theory, it would be strict vs depenent types, always
05:58:18 <ndm> and I would probably be one of the few arguing for merely strict types
05:58:25 <dcoutts> :-)
05:59:05 <dcoutts> ndm: btw the drunken locals generally recurse, or just curse
05:59:29 <ndm> dcoutts: i would say that we were hte more drunken party in this particular example
05:59:40 <ndm> (not particularly me, but my course mates from York)
06:00:14 <joelr1> ndm: how does catch work? do you modify the compiler?
06:00:43 <ndm> joelr1: you compile using Yhc, which dumps out a Core Haskell file, fully linked
06:00:56 <ndm> joelr1: then you transform that to a first-order Core language, then you analyse
06:01:07 <ndm> but simply typing "catch Main" does all of that for you
06:01:26 <ndm> http://www.cs.york.ac.uk/fp/darcs/catch/catch.htm
06:01:27 <lambdabot> Title: Catch: A User Manual
06:01:35 <joelr1> ndm: does yhc handle ghc extended syntax?
06:01:38 <ndm> that document is the manual, explaining how it works from the user perspective
06:01:41 <ndm> joelr1: no
06:01:57 <joelr1> ndm: i read about yhc recently. it's in need of hackers, right?
06:02:06 <ndm> joelr1: but you should be able to convert GHC Core to Yhc Core, then you can use Catch just fine - its not been done yet (partly because GHC Core is broken), but can be
06:02:11 <ndm> joelr1: yes, it is
06:02:57 <joelr1> i had this crazy idea this morning
06:03:04 <joelr1> automated optimization of haskell programs
06:03:22 <ivanm> joelr1: problem is, how do you want to optimize it?
06:03:28 <ivanm> speed or binary size?
06:03:32 <joelr1> wrap your program in a quickcheck property of sorts to verify correctness. parse it once to get to a syntax tree
06:03:49 <ndm> joelr1: how would that be more than -O2
06:03:55 <joelr1> then modify the binary tree using a database of community-supplied transformations, as well as genetically-evolved ones
06:04:04 <joelr1> run that and check the timings
06:04:05 <ivanm> ndm: automatic inlining where useful?
06:04:21 <joelr1> pick the best , pretty-print and list transformations used
06:04:21 <ndm> joelr1: much better to have a clever optimisation algorithm, which is the second part of my PhD
06:04:25 <ndm> ivanm: yes
06:04:44 <ivanm> ndm: and the first part is?
06:04:45 <ndm> sounds a lot like profile driven optimisations
06:04:47 <joelr1> ndm: something like sorear did with the binary library
06:04:49 <ndm> ivanm: catch
06:04:54 <joelr1> where he was able to speed it up 20x or so
06:05:04 <ndm> joelr1: what did he do? i haven't heard
06:05:05 <Pseudonym> Memoisation is run-time driven optimisation.
06:05:10 * ivanm looks around wildly trying to find what to catch
06:05:13 <joelr1> ndm: profile-driven optimizations it is
06:05:22 <joelr1> ndm: it even made it to reddit.
06:05:28 <ndm> joelr1: link?
06:05:29 <joelr1> @hoogle what i learned from low level
06:05:30 <lambdabot> Did you mean: What i Learned From Low Level
06:05:30 <lambdabot> Prelude.undefined :: a
06:05:30 <lambdabot> Test.QuickCheck.Batch.bottom :: a
06:05:34 <joelr1> no
06:05:37 <ivanm> Pseudonym: want to see my eventual vigenere cracker?
06:05:39 <ndm> @google what i learned from low level
06:05:41 <lambdabot> http://www.ag.ohio-state.edu/~rer/rerhtml/rer_44.html
06:05:41 <lambdabot> Title: Lessons Learned from Existing Low-Level Radioactive Waste Disposal Facilities? R ...
06:05:43 <Pseudonym> ivanm: Oh, sure.
06:05:46 <Pseudonym> That'd be cool.
06:06:08 <joelr1> @google what i learned from low level haskell
06:06:11 <lambdabot> http://osteele.com/archives/2006/02/page/2/
06:06:11 <lambdabot> Title: 2006 February at Oliver Steele
06:06:28 <joelr1> @google what i learned from low level haskel reddit
06:06:31 <lambdabot> http://programming.reddit.com/
06:06:31 <lambdabot> Title: reddit.com: programming - what&#39;s new online
06:06:34 <ivanm> Pseudonym: sending... it uses lhs2tex to pretty-print
06:07:04 <ndm> http://groups.google.com/group/fa.haskell/browse_thread/thread/1c1215eae015a79f/8abb334039544c20#8abb334039544c20
06:07:07 <lambdabot> Title: What I learned from my first serious attempt low-level Haskell programming - fa. ..., http://tinyurl.com/2clth3
06:07:20 <joelr1> right
06:07:41 <ndm> joelr1: my optimiser is intended to do very clever stuff automatically, we'll see if it works later
06:07:51 <joelr1> ndm: stefan said he was sort of taking stabs in the dark, without looking much at the core output
06:08:16 <ndm> joelr1: you shouldn't have to optimise like that, high level only, the compiler should get the low level bits right
06:08:48 <ndm> i have an optimisation model based on excess entropy reduction, which is very different from GHC, and hopefully will work better
06:09:03 <joelr1> ndm: cool
06:09:56 <astrolabe> ndm: entropy in what sense?
06:10:38 <ndm> astrolabe: every program has an inherent complexity, how long it takes to do what it does, that cannot be reduced without a better algorithm (high-level optimisation)
06:10:56 <ndm> astrolabe: entropy being time to execute, in some sense
06:11:17 <ndm> but more actions to execute, with the emphasis on wasted entropy being actions which are later reversed
06:11:18 <ndm> i.e.
06:11:36 <ndm> length [1..x] has the action to generate a list, and to consume it
06:11:36 <Philippa> construct/deconstruct?
06:12:01 <ndm> the entropy is to produce x, the wasted entropy is to build and consume a list
06:13:03 <astrolabe> ndm: I think I see, but now I don't know why you call it 'entropy' :)
06:13:16 <mr_tenor> so not information theoretic entropy
06:14:48 <Philippa> sort of. A longer execution trace is more entropy, no?
06:15:16 <mr_tenor> not if it's like "repeat 0" ;)
06:16:01 <Philippa> the trace for which is "build a thunk"
06:16:03 <astrolabe> Maybe bureoucracy is the word ;)
06:16:12 <ndm> astrolabe: yes, quite possibly
06:16:40 <mr_tenor> that's interesting actually... is "bad" code code that compresses well? :/
06:16:50 <ndm> astrolabe: but entropy is the energy required for information change, so you can define it in terms of  used_entropy - required_entropy= beurocracy
06:16:51 <dhart> Does someone have 10mn to look at a piece of code of mine concerning monads and help me understand what is going wrong?
06:17:25 <ndm> mr_tenor: no, code written in a sensible way does well, if you write a bad algorithm (a high required_entropy), it does badly - profiling at a high level should find you this
06:17:38 <Botje> dhart: sure
06:18:09 <Philippa> ndm: he's not talking about performance necessarily
06:18:51 <ndm> mr_tenor: if you write your code using high level cominators and natural folds/maps etc that often has a high beurocracy, but is shorter - i would call that good code
06:19:15 <hpaste>  dhart pasted "GameMonad" at http://hpaste.org/1284
06:19:52 <astrolabe> @spell bureacracy
06:19:52 <dhart> Botje: http://hpaste.org/1284 -- I get a monad error in the "Cell Rendering" section, and I dont understand why
06:19:52 <lambdabot> bureaucracy bureaucrat bureaucracy's bureaucrats
06:21:19 <Philippa> ndm: I can't help but want to suggest that's grounds for having explicit catamorphism and anamorphism operators in a language
06:21:43 <mr_tenor> ndm: and i guess that there's not enough semantic information about the stuff the compiler generates to meaningfully measure some form of "entropy"
06:21:46 <ndm> Philippa: perhaps, but i like the fact that you can define them yourself, and then use rules or something
06:21:49 <Philippa> that is, not just defining folds and unfolds on some of the library functions
06:22:00 <Philippa> yeah, except you can't do that in H98 :-)
06:22:18 <ndm> mr_tenor: i don't think so, the profiling combines high and low level stuff in one
06:23:09 <mr_tenor> just pondering :)
06:24:01 <DRMacIver> Hm
06:24:03 <dhart> Botje: any idea what could be going wrong? It's expecting a GameMonad b as return value and I'm giving it back a GameMonad IO
06:24:35 <DRMacIver> Why is overloading on type classes dispatched at runtime? It seems an obvious thing to want to do at compile time.
06:26:20 <Botje> where is rect defined?
06:27:04 <chessguy> 'morning
06:27:10 <psykotic> DRMacIver, you mean when the type is known?
06:28:12 <gh_> hi, I want to "cabalise" my project, so i've created a simple .cabal file, and the setup.lhs file too, but when i create a tarball with "Setup.py sdist", I realise that only the main file of my project is inside, how can i tell cabal to include everything ?
06:28:16 <dhart> Botje: rect is defined in HOpenGL
06:28:35 <DRMacIver> psykotic: Yeah. Any instance of a parametric type which is actually used has all its type parameters resolved at compile time, so the point of resolution seems a good place to select the overloaded function.
06:28:43 <dhart> rect (Vertex2 x1 y1) (Vertex2 x2, y2) is exactly equivalent to the following sequence:
06:28:43 <dhart>     renderPrimitive Polygon $ do
06:28:43 <dhart>         vertex (Vertex2 x1 y1)
06:28:43 <dhart>         vertex (Vertex2 x2 y1)
06:28:43 <dhart>         vertex (Vertex2 x2 y2)
06:28:44 <dhart>         vertex (Vertex2 x1 y2)
06:28:51 <DRMacIver> psykotic: But I'm clueless at this sort of thing, so it's very possible I'm missing something. :)
06:28:53 <ndm> @seen sorear
06:28:53 <lambdabot> I saw sorear leaving #darcs, #haskell-overflow, #ghc and #haskell 3h 55m 19s ago, and .
06:29:05 <psykotic> DRMacIver, well there's a trade off in code bloatage i guess.
06:29:07 <dhart> renderPrimitive :: PrimitiveMode -> IO a -> IO a
06:29:30 <DRMacIver> Mm. I suppose there is that.
06:29:48 <psykotic> DRMacIver, with the dictionary passing approach you can just have one piece of generated code for a given function with parameters parameterized over typeclasses
06:30:00 <DRMacIver> Right. I see what you mean. :)
06:30:54 <Philippa> on the other hand, it's not uncommon to see specialisation happening as well
06:31:01 <psykotic> couldn't it be possible to get the right effect by aggressive inlining of the dict passing code?
06:31:07 <Philippa> right
06:31:12 <Philippa> JHC essentially does that
06:31:18 <DRMacIver> ok
06:31:27 <Philippa> (but it passes typeids rather than dictionaries - not that that makes much difference once it gets to GRIN)
06:32:11 <Botje> dhart: no idea then .. :/
06:32:25 <dhart> Botje: thx anyway
06:33:28 <dhart> @seen Cale
06:33:29 <lambdabot> I saw Cale leaving #oasis, #ghc, #haskell-overflow and #haskell 5h 15m 23s ago, and .
06:39:16 <robreim> Is there anything in Haskell which prevents extending its pattern matching to include conditionals?
06:39:38 <edwardk> philippa: it doesn't? i thought the main advantage of that approach was the ability to cut down on dictionary overhead, since you pas one additional typeid per type used rather than per dictionary used.
06:40:13 <edwardk> i will admit its pretty much an even tradeoff though
06:40:31 <edwardk> er per free type variable, not per type
06:40:52 <ndm> edwardk: optimised code shouldn't use dictionaries, they are slow, and mean you get less optimisation
06:41:32 <edwardk> ndm: sure, but 'optimized' code in that sense becomes nigh illegible ;)
06:41:58 <ndm> edwardk: i meant once optimised by the compiler, not written by the user
06:42:04 <edwardk> yeah
06:42:08 <edwardk> ok
06:42:11 <edwardk> that i'll buy =)
06:49:39 <Philippa> edwardk: okay, yeah, there's a point there - the bulk of the real gains're already there from GRIN being first-order though
06:50:18 <Philippa> robreim: it already does - Foo bar baz | bar == baz
06:50:56 <edwardk> true enough
06:51:09 <robreim> Well, I mean pattern matching specifically rather than guards, though I agree that covers most of the uses.
06:51:29 <edwardk> rob: have a suggested syntax for such a feature?
06:52:02 <ndm> robreim: do you think when people mean f x True x they usually mean match the two x's, or they mean they typo'd?
06:52:29 <chessguy> man, this is a phenomenal paper
06:52:30 <chessguy> http://worrydream.com/MagicInk/
06:52:31 <lambdabot> Title: Magic Ink: Information Software and the Graphical Interface
06:52:40 <matthew-_> ndm: if they're at all familiar with Erlang or Prolog, then they should match.
06:53:09 <ndm> matthew-_: possibly, but my feeling is it would let lots of bugs through, at the cost of == which is much clearer
06:53:26 <ndm> matthew-_: plus is f x x structural or Eq equality on x?
06:53:43 <ndm> one breaks the abstraction barrier, one is against all other conventions for pattern matching
06:54:58 <matthew-_> mmm. though at the type level, unification of types happens all the time...
06:55:28 <robreim> To be honest, I haven't looked into conditional pattern matching in any big way. Someone mentioned to me that ocaml had it and I grew jealous :)
06:56:19 <ndm> matthew-_: data types, not constructor values - types are not abstract in Haskell programs
06:59:38 <erider> morning
07:01:08 <mightybyte> chessguy: How did you find that paper?
07:01:28 <chessguy> i think someone here linked to it the other day
07:01:35 <chessguy> or maybe i saw it on a blog
07:01:39 <chessguy> i don't remember
07:01:58 <joelr1> ndm: is there something analogous to lst in Data.Derive but using parens?
07:01:59 <mightybyte> Looks very interesting
07:02:08 <chessguy> yes, fascinating stuff
07:02:11 <mightybyte> Over a year old too
07:02:17 <chessguy> anyone that does GUI design should have to read it
07:02:19 <ndm> joelr1: you mean tuples? we have tup
07:02:42 <joelr1> ndm: i need to print out FunName ( x, y, z )
07:02:50 <ndm> tup should do it
07:02:53 <ndm> i think
07:02:56 <joelr1> ndm: i see this       body = l1 "choice" $ lst [ clause con | con <- ctors ]
07:03:14 <ndm> sorear knows these things much better than me, he did most of the AST bits
07:03:15 <joelr1> i think i can skip l1 and use tup so long as tup can take a list
07:03:29 <ndm> tup :: [Exp] -> Exp
07:03:37 <joelr1> cool
07:04:21 <joelr1> ndm: mm... i don't think it's gonna work
07:05:34 <joelr1> ndm: what i need is to generate "instance Pretty <type> where" and then "pretty (Ctr arg arg arg ...) = text "Ctr" <> text "(" <> pretty arg ... text ")"
07:05:49 <joelr1> one pretty for each constructor
07:05:57 <ndm> thats easy enough to do
07:06:03 <joelr1> ndm: really?
07:06:05 <dons> ?time dons
07:06:05 <ndm> take a look at Play, it does something similar
07:06:08 <lambdabot> Local time for dons is Sat Apr  7 00:04:23 2007
07:06:11 <joelr1> play?
07:06:13 <joelr1> ok
07:06:21 <dons> 8 hours to go!!!
07:06:22 <ndm> joelr1: actually Data or Typeable in derive may be simpler, and have that pattern - particularly Data
07:06:27 <ndm> ?time icfp
07:06:32 <joelr1> dons is living in the future
07:07:00 <joelr1> ndm: mmm... ok... let me see if i can figure it out
07:07:25 <hpaste>  joelr1 pasted "Data.Derive and pretty-printing" at http://hpaste.org/1285
07:07:44 <joelr1> ^^^ this is what i'm trying to beat into submission
07:08:52 <ndm> joelr1: sclause [] looks a bit suspicious, the [] should be the left hand side pattern match
07:08:57 <ndm> you can a different clause for each one?
07:09:35 <joelr1> ndm: large datatype with, say, 170 constructors, all taking different arguments
07:09:46 <ndm> joelr1: easy enough
07:09:57 <joelr1> where each argument type is instance of Pretty
07:10:14 <ndm> http://www.cs.york.ac.uk/fp/darcs/derive/Data/Derive/Data.hs#
07:10:54 <ndm> each sclause is likely to take (ctp ctor 'x') as the pattern match on the left hand side
07:10:57 <joelr1> ndm: k? z?
07:11:21 <ndm> joelr1: those bits are specific to Data, you can ignore them - gfoldl takes k z and the value, which is what is matched against
07:11:49 <joelr1> ctp x where x is the arg list?
07:12:35 <ndm> 'x' is a variable so you can match multiple constructors
07:12:50 <ndm> ctp ctro 'x' generates (Ctor x1 x2 x3) as appropriate
07:13:08 <ndm> then you can refer to x1 etc on your RHS
07:13:10 <joelr1> ndm: can you hack a draft version that i can go from? that would be awesome
07:13:33 <joelr1> for example, i can't even imagine how to generate "instance Pretty x where "
07:13:47 <joelr1> that should be the first thing generated
07:13:52 <ndm> joelr1: i would like to do a common derivings thingy, so you can give a data type and an instance and it can "infer" a constructor, that would be cool;
07:14:32 <ndm> simple_instance "Pretty" dat [funs]
07:14:44 <ndm> and for each constructor, what do you want to be produced?
07:14:58 <Igloo> Wow, I didn't realise yi was > 2 years old
07:15:05 <ndm> i.e. pretty (C x1 x2) = x1 >> x2 (or something)
07:15:24 <joelr1> "<>" instead of >>
07:15:31 <joelr1> that's the pretty-printing combinator
07:16:26 <dons> Igloo: yeah,
07:16:26 <dons> Thu Oct 14 12:22:28 EST 2004  dons@cse.unsw.edu.au
07:16:27 <dons>   * Initial import of riot-hsplugins as hemacs
07:16:47 <dons> what a bunch of slackers we are :-)
07:17:11 <hpaste>  ndm annotated "Data.Derive and pretty-printing" with "(no title)" at http://hpaste.org/1285#a1
07:17:44 <ndm> joelr1: ^^^ - thats a mininally modified Data one, which might suit you
07:17:57 <joelr1> ndm: let me run with that, thanks a lot!
07:18:12 * joelr1 has grand plans of world domination
07:18:26 <joelr1> i shall make it a point to hire as many haskell hackers as i can afford
07:18:29 <ndm> i would like to do a standard deriver one, so you can construct the simple standard instances without much work
07:19:10 <ndm> or at least get something to start with
07:19:32 <joelr1> ndm: that would be cool, although with the two bits i already have i should be covered
07:25:40 <joelr1> ndm: how do you modify this  "AppE (AppE (l0 "<>") x) y" to run "pretty" on x instead of just returning x?
07:26:22 <ndm> joelr1: AppE (AppE (l0 "<>") (l1 "pretty" x) y
07:26:40 <joelr1> seems logical, thanks!
07:26:46 <ndm> AppE (AppE (l0 "<>") (l1 "pretty" x)) y
07:26:52 <ndm> i was missing a bracket :)
07:27:12 <ndm> it might be y that needs the pretty wrapper, my brain doesn't understand foldl's, but its easy to fix if necessary
07:27:45 <joelr1> ok
07:27:50 <joelr1> let me see what this expands to
07:29:08 <ndm> i definately want an app that does this automatically, would cover 80% of cases
07:29:16 <joelr1> ndm: y needs pretty too. would it be (l1 "pretty" y)?
07:29:34 <ndm> joelr1: one value is the recursive construction, which would have already been pretty wrapped
07:29:36 <joelr1> ndm: one day i may be able to grasp the derive library :)
07:30:13 <joelr1> ndm: mmm... so how do you add pretty to y then? l2?
07:30:14 <hpaste>  ndm annotated "Data.Derive and pretty-printing" with "(no title)" at http://hpaste.org/1285#a2
07:30:21 <joelr1> l0, l1, l2, l3, etc?
07:30:35 <ndm> joelr1: l1 says write the function with 1 argument
07:30:45 <joelr1> ah, ok
07:31:00 <ndm> the foldl1 makes each argument the x once, appart from the first one - mapping it first removes that issue
07:31:35 <ndm> the hard bit of the derive library is Template Haskell, everything else is pretty easy - or at least well encapsulated
07:31:57 <joelr1> 	    { pretty Main.Foo x1 = x1
07:31:57 <joelr1> 	      pretty Main.Bar x1 x2 = (<>) (pretty x1) x2 }
07:32:11 <joelr1> it didn't add pretty to x1 (first case) or x2
07:32:59 <ndm> joelr1: is that using the one i just posted to hpaste?
07:33:00 <joelr1> actually,
07:33:13 <joelr1> the one you just pased does this
07:33:14 <ndm> thats the issue that foldl1 was causing
07:33:36 <hpaste>  joelr1 annotated "Data.Derive and pretty-printing" with "results" at http://hpaste.org/1285#a3
07:34:00 <joelr1> meaning that it never adds pretty to a 1 argument constructor and always misses the last argument
07:34:07 <joelr1> #2 probably covers #1
07:34:29 <ndm> using the one with the map (l1 "pretty") ?
07:34:45 <joelr1> using your very last paste
07:35:03 <joelr1> ndm: the one where you are mapping pretty
07:36:00 <hpaste>  ndm annotated "Data.Derive and pretty-printing" with "(no title)" at http://hpaste.org/1285#a4
07:36:36 <ndm> joelr1: it may be hte AppE's in the foldl are getting confused, that may remove the issue
07:36:43 <joelr1> checking
07:36:48 <ndm> if it doesn't work, change it to foldr1 instead of foldl1 and paste both answers
07:36:54 * ndm is not a fold person
07:37:43 <joelr1> ok, sec
07:37:56 * dylan folds ndm 
07:38:10 * ndm responds with a mutable variable
07:39:15 <hpaste>  joelr1 annotated "Data.Derive and pretty-printing" with "(no title)" at http://hpaste.org/1285#a5
07:39:32 <joelr1> neither adds pretty to the last argument of a constructor
07:41:45 <ndm> joelr1: i'm not convinced that the code that is running is that code above, i suspect there is some stale code floating around - change to: f ctor = error "here"
07:42:24 <joelr1> i pasted the code with the answers, though
07:42:31 <joelr1> sec
07:43:06 <joelr1> ndm: you are right. wtf?!
07:43:08 <ndm> yes, you have changed the code, but something may be failing to recompile it, or derive may be failing to run and using a stale copy - its not polished enough to always get it right
07:43:29 <ndm> joelr1: the derive.exe program on failing sometimes just does nothing, so if you have a bug it may not appear so obviously
07:43:42 <ndm> (its on the list of things to fix before an official release)
07:43:54 <joelr1> i'm such an idiot
07:43:58 <ndm> if you load your new module that does the deriving in GHCi, does it load succesfully?
07:43:59 <joelr1> once sec
07:44:18 <joelr1> nono, i have two versions of the function, one above the other, same name. no complains from ghc
07:44:35 <ndm> yeah, they are considered pattern matches
07:44:47 <ndm> the first one is completely overlapping the second one
07:44:53 <ndm> at a guess
07:45:07 <joelr1> works now, thanks a lot!
07:45:19 <joelr1> ndm: you saved me about 500 lines of code :D
07:45:30 <ndm> joelr1: good good :)
07:46:23 <joelr1> ndm: this is for the pretty-printing stage of my parser
07:47:01 <ndm> neat, are you using TH for this?
07:47:17 <joelr1> ndm: i don't even know what TH stands for.
07:47:19 <joelr1> seriously, though
07:47:23 <ndm> Template Haskell
07:47:25 <joelr1> no, i don't know template haskell
07:47:31 <joelr1> it's foreign science to me
07:47:36 <ndm> so you are using it like a drift replacement?
07:48:12 <joelr1> now, let me see if i can figure out how to add parens around the whole thing, commas in between and the name of the constructor in front
07:49:30 <ndm> l1 (ctorName ctor) x -- gives the constructor name in front
07:49:55 <ndm> commas can be done with tup, depending on quite where you want them - tup [x,y,z] = (x,y,z)
07:50:11 <joelr1> ndm: let me see if there's a combinator
07:50:12 <joelr1> one sec
07:51:41 <joelr1> ndm: tupled :: [Doc] -> Doc
07:52:02 <ndm> oh, you mean at runtime!
07:52:07 <joelr1> ndm: this takes a list of printers (pretty arg1 would be one), separates and encloses
07:52:10 <ndm> i thought you meant at derive taime
07:52:24 <joelr1> hmm
07:52:29 <ndm> wouldn't you want tupled instead of foldl?
07:52:48 <ndm> l1 "tupled" $ map (l1 "pretty") ...
07:53:16 <ndm> perhaps with lst in there, actually
07:53:23 <joelr1> ndm: i guess i want tupled around map pretty over args
07:53:23 <ndm> l1 "tupled" $ lst $ map (l1 "pretty") ...
07:53:33 <joelr1> let me try
07:53:46 <joelr1> this stuff is magical
07:54:39 <joelr1> ndm: what does this do? ctv ctor 'x'
07:55:12 <ndm> joelr1: constructor value, i.e. ctv (constructor for ":")'x' would give you ((:) 'x1' 'x2')
07:56:06 <joelr1> ndm: and ctp ctor 'x'?
07:57:13 <ndm> joelr1: exactly the same, but as a pattern, rather than as a value
07:58:03 <joelr1> darn awesome
07:58:06 <joelr1> works
07:58:18 <joelr1> let me see if i can figure one one last bit on my own
07:58:53 <ndm> cool, i'm off now, but back in about 45 mins - msg me if you get anything stuck in the meantime
07:59:18 <joelr1> ndm: thanks again!
08:05:16 <benja_> data MList m a = MNil | MCons a (m (MList m a))   -- does anyone know a cabalized package with a data structure like this?
08:06:01 <benja_> I've seen it discussed on some wiki page; I'm wondering whether I could import some package instead of rolling my own version of it
08:06:27 <benja_> (the idea is that it's a list whose tail you get through a monadic computation)
08:26:43 <glguy> is there a good latex package I should look at if I want to draw a diagram with two points, and a cirled centered around each point that passes through the other point
08:27:00 <glguy> and a third circle whose diameter is the segment between my two points
08:27:14 <glguy> I've never don't LaTeX diagrams before
08:27:55 <glguy> (or would I be better off using a different program like Inkspace)
08:28:14 <opqdonut> i've heard xypic and metafont are good packages
08:28:15 <dons> glguy: how about using xcircuit or one of the vector graphis programs, like Inkspace?
08:28:20 <dons> pstricks is good too
08:28:26 <opqdonut> yeah pstricks is nice
08:28:36 <dons> i always use xcircuit, but i'm trying to migrate to inkscape
08:28:56 <glguy> if I use inkscape and then export to eps, I can include that in a latex document, no?
08:29:02 <dons> yep.
08:29:11 <dons> that how i always do it, via .eps includes
08:29:27 <dylan> does .eps work with pdflatex?
08:29:31 <glguy> how do you know how large to make it?
08:29:47 <dons> glguy: you make it as large as you want
08:29:51 <dons> then scale it in the latex
08:30:09 <dons> e.g.
08:30:10 <dons> \begin{figure}
08:30:10 <dons>   \begin{center}
08:30:10 <dons>     \includegraphics[scale=0.6]{images/surface-lines.eps}
08:30:10 <dons>     \caption{Molecular weight distribution during polymerisation}
08:30:12 <dons>     \label{fig:molecular-weight}
08:30:15 <dons>   \end{center}
08:30:17 <dons> \end{figure}
08:30:23 <dons> --> \includegraphics[scale=0.6]{images/surface-lines.eps}
08:30:44 <dons> that's using \usepackage{graphicx}
08:30:55 <dons> can you tell im' writing papers *right now* ?
08:31:13 <glguy> :)
08:31:15 * joelr1 can tell
08:36:07 <Lemmih> \quit
08:37:43 <ndm> glguy: i used xypic, its great if you want to do the diagrams it was diesgned for, otherwise it sucks
08:38:05 <ndm> using inkscape looked very attractive, it even has a .tex output format, but when i used .tex output it basically ate itself for breakfast
08:38:12 <opqdonut> :)
08:38:15 <ndm> it put the text and the lines on different pages
08:38:32 * ndm managed to avoid graphics for ICFP, but i need them for HW
08:38:40 <glguy> ndm: did you see what diagram I was trying to make?
08:38:44 <ndm> lhs2tex produces _very_ pretty code
08:38:45 <glguy> (yeah... this is for homework)
08:38:46 <ndm> glguy: no
08:39:10 <ndm> glguy: read back, xypic is my suggestion
08:39:29 <ndm> glguy: its massive advantage is you get .ps and .pdf both in vector format without things going wrong
08:42:15 * ndm has a final draft, with 6 hours to spare
08:42:39 <kosmikus> metapost is also nice for diagrams, but takes some time to get used to
08:43:32 <SamB_XP> and it can only solve linear equations!
08:43:37 <kosmikus> and tikz / pgf look interesting as well, but I haven't really worked with them
08:44:18 <kosmikus> SamB_XP: better than nothing ;)
08:46:58 <dhart> hi Cale
08:47:12 <dons> ndm, bah! 6 hours! you can write another paper in that time.
08:47:45 <emu> xfig could work.
08:47:46 <ndm> dons: i can write my HW paper in that time, and have it rejected from ICFP in the goal of getting feedback :)
08:47:55 <dons> hehe
08:48:12 <dhart> Cale: I've been having a problem using the GameMonad we talked about yesterday. I was wondering if you could have a quick look at the code and tell me what is going wrong?
08:48:21 <opqdonut> is hw homework or hardware or ...?
08:48:42 <ndm> HW = haskell workshop
08:48:50 <opqdonut> ahh :)
08:49:30 <kosmikus> wow. I envy people who can write HW papers in 6 hours ...
08:49:33 <joelr1> ndm: is that another paper on the same subject?
08:50:10 <ndm> joelr1: no, totally different subject
08:50:23 * joelr1 loves haskell papers
08:50:28 <joelr1> ndm: what's the subject?
08:51:04 <kosmikus> btw, it's HCAR time again. I'll send a call for contributions next week. Deadline will be end of the month.
08:51:08 <ndm> joelr1: traversals and queries in Hskell 98 in a more type-safe manner than Scrap Your Boilerplate, with shorter stuff
08:51:11 <hpaste>  dhart annotated "GameMonad" with "(no title)" at http://hpaste.org/1284#a1
08:51:34 <ndm> and no rank-2 types!
08:51:37 <dons> kosmikus: wow. HCAR already.
08:51:39 <joelr1> ndm: that must be related to th, no?
08:51:41 <dons> and TMR next week or two.
08:51:49 <ndm> joelr1: nope, not at all - no th requirement
08:51:57 <dons> and ICFP today. busy busy time for the haskell crew.
08:51:58 <ndm> TMR is the 16th, we have a Yhc article for that
08:52:06 <joelr1> ndm: what are you traversing then?
08:52:08 <dons> cool.
08:52:09 <ndm> and SoC for the next few weeks
08:52:10 <kosmikus> ndm: sounds even more interesting.
08:52:13 <ndm> joelr1: data, at runtime
08:52:15 <dons> we've got an xmonad one lined up too.
08:52:18 <joelr1> hmm
08:52:30 <ndm> joelr1: exactly hte same concept as SYB, but simpler, safer and shorter
08:52:33 * dons doses up on green tea and keeps writing
08:52:35 <kosmikus> ndm: so what you're basically saying is that it takes you 6 hours to make most of my work on Haskell so far superfluous? ;)
08:52:37 <joelr1> cool
08:52:47 <yip> dhart: GameMonad?
08:52:49 <ndm> kosmikus: did you do SYB stuff?
08:53:09 <kosmikus> ndm: yes, I guess so.
08:53:10 <dons> ndm, just a few years of generics ;-)
08:53:12 * joelr1 wonders what kosmikus's full name is
08:53:45 <ndm> kosmikus: only the first SYB paper, the rest (i.e. yours) aren't in this one
08:54:05 <kosmikus> ndm: I'm still curious though.
08:54:11 <ndm> and probably can't be extended to do so - its the common cases of traversals and queries
08:54:15 <joelr1> i'm eating condensed milk, drinking tea, listening to rumba (folk dance) and extracting constructors from data types
08:54:20 <joelr1> my idea of a fun friday afternoon
08:54:24 <ndm> http://www.cs.york.ac.uk/fp/darcs/play/play.htm
08:54:25 <lambdabot> Title: Play With Your Boilerplate
08:54:48 <ndm> kosmikus: ^ thats an initial tutorial on using my one, its changed since then, and its not particularly formal - but it gives a slight overview of what is different
08:55:53 <kosmikus> ndm: thanks, I'll have a look
08:56:18 <ndm> kosmikus: thoughts and comments welcome, i'll send you a draft of my paper once its done (alas more than 6 hours, but probably not more than a few weeks)
08:57:32 * benja_ goes have a look too
08:58:04 <ndm> its not intended for public consumption, partly because all the names of the functions have changed, and its got a slightly different foundation, particularly PlayEx
08:58:13 <ndm> but i will have a library released on it before HW
08:58:58 <kosmikus> ok
09:04:27 <fons> Hello there
09:04:37 <fons> hi ndm
09:04:50 <benja_> "Now lets imagine that programmers in your language are paid by the depth of expression they produce" -- hah :)
09:04:58 <ndm> hi fons
09:05:35 <ndm> benja_: i've worked for companies where performance metrics including ridiculous source code stats, its not that far fetched, alas
09:05:55 <fons> I have a type problem in my code which I dont know how to solve (and I'm not really sure why is caused). I have made a simplified example, can anyone have a look at it?
09:06:09 <hpaste>  fons pasted "Type error" at http://hpaste.org/1286
09:06:21 <hpaste>  joelr1 annotated "Data.Derive and pretty-printing" with "what should I plug in place of XXX" at http://hpaste.org/1285#a6
09:06:29 <joelr1> ndm: ^^
09:06:42 <joelr1> ndm: i can't figure out how to print the name of the constructor :-(
09:06:48 <joelr1> ndm: not quoted
09:06:58 <dons> i think the nestedness of my data structures should be the key performance metric
09:07:05 <beelsebob_> is there a universal reference for the Hindley Milner type system?
09:07:46 <ndm> joelr1: l0 (the letter L)
09:08:12 <joelr1> ndm: i thought so too but it didn't work. let me try
09:08:32 <ndm> joelr1: in that case i'd take a look at trim, it may be (inadvertantly) calling show
09:08:46 <ndm> (oh, just checked, its definately not)
09:09:20 <hpaste>  joelr1 annotated "Data.Derive and pretty-printing" with "(no title)" at http://hpaste.org/1285#a7
09:09:26 <ndm> try: l0 "Test" and see if that works
09:09:40 <joelr1> ndm: it's complaining about my use of >>:
09:10:13 * ndm hunts for the >>: definition
09:10:23 * fons thinks people is quite busy so he'll try haskell-cafe instead
09:10:34 <fons> :)
09:11:17 <ndm> fons: as soon as i see type classes, i'm no use at type error messages
09:11:28 <joelr1> ndm: i took it from this bit of code
09:11:29 <joelr1>       clause con = l1 "reserved" (lit (trim (ctorName con)))
09:11:29 <joelr1>                    >>: args con (ctorArity con)
09:11:31 <kosmikus> ndm: not sure if I get this right, but you seem to imply that you're at an advantage over Compos for not requiring GADTs. But you require MPTCs instead. For the simple case where you don't require MPTCs, Compos is also extension-free.
09:12:04 <ndm> kosmikus: true, but MPTC is a Hugs+GHC extension which is well understood, GADT's are GHC only and still very new
09:12:25 <joelr1> what is mptc again?
09:12:25 <ndm> kosmikus: plus the current version of Play doesn't require MPTC's (but thats since that tutorial)
09:12:51 <ndm> mptc = multi-parameter type classes
09:12:56 <joelr1> ah
09:13:16 <ndm> and i think Compos required GADTs in all cases, but i might be wrong
09:13:46 <kosmikus> ndm: MPTCs having been invented earlier doesn't make them nicer than GADTs, but I see your point.
09:14:18 <kosmikus> ndm: Compos requires GADTs as soon as multiple datatypes are involved.
09:14:20 <ndm> kosmikus: i would say they are more standard, plus they will probably make H', but GADT's wont
09:14:37 <ndm> kosmikus: ok, will have to be clear about that then - i think i'm not in the tutorial
09:15:11 <ndm> joelr1:       args ctor 0 = l1 "empty" - should be l0
09:15:26 <joelr1> ndm: yep, just fixed that
09:15:27 <kosmikus> ndm: [MPTCS vs. GADTs in Haskell'] yes, you're probably right -- unfortunately ;)
09:15:38 <joelr1> ndm: i think i'm getting closer. i'm not returning a list somewhere
09:15:47 <joelr1> or vise versa
09:15:55 <SamB> hmm. too bad DOS doesn't have an INTWINCH
09:15:57 <ndm> joelr1: if you annotate with the type error i can take a look
09:16:16 <joelr1> ndm: thanks, let me see if i can do it
09:16:25 <ndm> kosmikus: what is your current research?
09:16:27 <fons> ndm, how is yhc's Core API going? Any other new backends appart from the Javascript one?
09:16:41 <ndm> fons: not yet, there is a prototype C one around, but not public
09:17:05 <ndm> fons: we also have a few new users around the place, a Java one is being done, we have two static analysis tool, one for testing, one for proof
09:17:08 <bringert> ndm: writing a Play paper for ICFP?
09:17:24 <ndm> we'll also have a possible ICFP paper which uses Yhc.Core
09:17:29 <ndm> bringert: haskell workshop was my target
09:17:48 <bringert> ah, I missed part of this discussion
09:17:58 <ndm> fons: there will also be a the monad reader article on Yhc.Core in a few weeks
09:18:09 <fons> ndm, I think I told you, I decided to discard Yhc and I'm using an embedded compiler instead, the Core API solution was far more general than what I needed
09:18:27 <kosmikus> ndm: oh, I've just written another "SYB with GADTs" paper, and am currently working on dependent types
09:18:28 <ndm> fons: fair enough, its very general which is good - but not always the right solution
09:18:42 <ndm> kosmikus: dependent types scare me
09:18:55 <ndm> kosmikus: can you auto-derive SYB instances for GADT's?
09:18:55 <kosmikus> ndm: that's exactly what I plan to address
09:19:10 <ndm> kosmikus: we were hoping the derive framework would be able to do it at some point
09:19:23 <ndm> http://www.cs.york.ac.uk/fp/darcs/derive/derive.htm
09:19:23 <kosmikus> ndm: I'm trying to argue if I could overcome my fears, you should be able to do the same ;)
09:19:24 <lambdabot> Title: Data.Derive: A User Manual
09:19:42 <ndm> kosmikus: does it make it more work to write a program that you just don't care about?
09:19:44 <Philippa> ndm: I get the impression your fears're more with strongly normalising languages?
09:19:55 <Philippa> that's most people's first experience of Haskell, too
09:19:55 <fons> ndm, at least from what I know Yhc's Core is nicer than GHC's one (which seems to be broken right now isn't it?)
09:19:57 <ndm> Philippa: partly, yes, as that makes hacking impossible
09:20:27 <ndm> fons: its different, simpler, and has less type information - i define nicer in that way, but others don't. GHC's core is broken though, but one day I hope it will relive
09:20:43 <ndm> fons: once it does, we will translate GHC Core to Yhc.Core (the reverse is likely to be a lot harder)
09:20:47 <bringert> kosmikus: how would I get lhs2TeX |inline code| to line break?
09:20:58 <kosmikus> ndm: "deriving SYB instances for GADTs" is different from what I was talking about, but shouldn't be really difficult
09:21:25 <ndm> kosmikus: oh yes, i'm sure its much more than that, but hte lack of auto-derivation makes it harder to use practically
09:21:26 <kosmikus> bringert: inline code can line break; it's just like inline math
09:21:43 <bringert> hmm, strange
09:21:55 <kosmikus> ndm: deriving SYB gfoldl for a GADT is trivial.
09:22:46 <fons> COuld anyone please have a look at "Type error" at http://hpaste.org/1286 , it is a basic error, but I don't understand why the compiler doesn't have enough type info and considers the type ambiguos
09:23:26 <bringert> kosmikus: "Some code: |order [pizza one large [cheese], drink one large beer, ?]| that should line break."
09:23:39 <bringert> kosmikus: the code runs of the page
09:23:41 <chessguy> data HDSignal a = HDSignal looks suspicious to me
09:23:42 <bringert> off
09:23:45 <kosmikus> bringert: let me check
09:23:53 <chessguy> but i'm no guru
09:24:09 <bringert> chessguy: phantom type?
09:24:15 <fons> chessguy, that's perfectly fine :) it's a phantom type parameter
09:24:29 <chessguy> ok, please ignore me then
09:24:45 * chessguy searches the wiki
09:25:08 <fons> chessguy, that's fine, I didn't know that could be done a few weeks ago, and it's really useful to Embed languages in Haskell
09:25:25 <fons> chessguy, the problem comes from the fuunction connectIX
09:25:46 <kosmikus> bringert: confirmed
09:25:59 <fons> chessguy, I don't understand why GHC considers the type ambiguous
09:26:47 <Cale> fons: Where you're using the supplySig function, it can't tell which instance of HDPrimType to supply.
09:27:00 <Philippa> because when you write HDSignal as a term it can't tell HDSignal Arse from HDSignal Elbow
09:27:46 <fons> Cale, but I'm not using any class function
09:28:12 <int-e> fons: you use supplySig and plugSig in connectIx
09:28:15 <Cale> fons: huh? You are too -- it's right in the signature.
09:28:23 <fons> oh yep, sorry
09:28:26 <fons> hahaha
09:28:29 <Cale> supplySig  :: (DestPort d, PortIndex ix, HDPrimType a) => HDSignal a -> ix -> d -> d
09:28:34 <fons> yep yep
09:28:37 <fons> sorry about that
09:28:57 <kosmikus> bringert: I probably use different settings, but I'd have to look it up
09:29:14 <fons> what I meant is that the compiler doesn't actually need to know what isntance is being suplied (or at least I don't understand why does it need that)
09:29:17 <kosmikus> bringert: inserting {-"\linebreak"-} in your inline code at the right point should help if this is a one-time situation
09:29:34 <bringert> kosmikus: that would do for now, thanks.
09:30:41 <Philippa> fons: it needs it because otherwise the term's not well-typed. In other words, Because It Said So.
09:31:02 <int-e> fons: you'll somehow have to tell the compiler that the HDSignal x it's looking for is an HDSignal y, where y is a suitable HDPrimType instance. ghc can't conjure class dictionaries out of thin air
09:31:06 <Philippa> oh, and because in cases with overloading it needs to know which dictionary
09:33:57 <hpaste>  joelr1 annotated "Data.Derive and pretty-printing" with "(no title)" at http://hpaste.org/1285#a8
09:34:03 <joelr1> ndm: ^^
09:34:05 <yip> does Data.Time deprecate System.Time?
09:35:38 <joelr1> fons: what's your code for? HDSignal?
09:35:42 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1287
09:35:47 <chessguy> augh
09:35:55 <chessguy> i didn't mean to paste that  yet
09:36:47 <hpaste>  ndm annotated "Data.Derive and pretty-printing" with "(no title)" at http://hpaste.org/1285#a9
09:37:06 <ndm> joelr1: like that, i'm not sure about the lit call, thats the only part
09:37:28 <joelr1> ndm: yes, lit works in another piece of code that i have
09:37:31 <joelr1> ndm: thanks
09:37:39 <hpaste>  chessguy annotated "(no title)" with "this is what i meant to paste" at http://hpaste.org/1287#a1
09:39:00 <joelr1> ndm: awesome, thanks!
09:39:12 <fons> ok, thanks :( it worked well without the HDPrimType a restriction
09:39:22 <fons> let's see if I find a good solution
09:44:09 <chessguy> fons: there was just a reply on -cafe too
09:44:20 <chessguy> > plugSig  :: (HDPrimType a) => s  -> (HDSignal a -> b) -> b
09:44:20 <chessguy> The above is odd, in that the plugSig can internally produce (HDPrimType a =>
09:44:20 <chessguy> HDSignal a) for any "a" that satisfies the constraint.
09:44:20 <chessguy> Perhaps you want to use a functional dependency?
09:44:23 <lambdabot>   Not in scope: type constructor or class `HDSignal'
09:45:28 <benja_> ndm: what's "the compos paper"?
09:45:53 <ndm> benja_: bringert wrote it, ICFP 2006. scroll to the top of that doucment for a link
09:47:20 <benja_> ah, sorry, missed that somehow. thanks
09:55:32 <sorear> hello.
09:55:33 <lambdabot> sorear: You have 2 new messages. '/msg lambdabot @messages' to read them.
09:57:45 <stepcut> hello
09:57:57 <emu> no messages for you
09:58:01 <stepcut> :(
09:58:16 <stepcut> @tell stepcut messages for you!
09:58:17 <lambdabot> You can tell yourself!
09:58:34 <narain> @tell stepcut messages for you!
09:58:35 <lambdabot> Consider it noted.
09:58:35 <emu> @tell stepcut beep
09:58:35 <lambdabot> Consider it noted.
09:58:41 <stepcut> hello
09:58:42 <lambdabot> stepcut: You have 2 new messages. '/msg lambdabot @messages' to read them.
09:58:44 <stepcut> yay!
09:59:37 <chessguy> message for you, sir!
10:00:03 <potts> Hello
10:00:21 <potts> I am looking for a rather simple file filter (to get features added later)
10:00:56 <glguy> Is there a named property that states that given two unique polynomials of degree n, that they can have at most n intersections?
10:01:08 <potts> The first cut just reads a binary file (which can include NULLs) and dumps the contents as hex, i.e. DEADBEEF... with no line breaks.
10:01:10 <sorear> @messages
10:01:11 <lambdabot> ndm said 5h 27m 27s ago: that is a good sign - and honestly as I use it more, I get more used to it - although perhaps having a Yhc.Core AST and conversion would be simpler
10:01:11 <lambdabot> ndm said 5h 27m 14s ago: less and more intuitive syntactic forms :)
10:02:14 <narain> glguy: may be related to the fundamental theorem of algebra
10:02:20 <potts> I was looking at writeFile ofile (map showLitChar s) in IO monad, but that is a type train wreck
10:02:33 <yip> is there something like assert in haskell?
10:02:44 <sorear> @hoogle assert
10:02:45 <lambdabot> Control.Exception.assert :: Bool -> a -> a
10:02:45 <lambdabot> Test.HUnit.Base.assert :: Assertable t => t -> Assertion
10:02:45 <lambdabot> Control.Exception.assertions :: Exception -> Maybe String
10:02:49 <dons> yeah, 'assert' :-)
10:03:04 <narain> glguy: in fact it is the very same
10:03:07 <yip> > assert
10:03:09 <lambdabot>   Not in scope: `assert'
10:03:31 <chessguy> > Control.Exception.assert
10:03:32 <lambdabot>   Not in scope: `Control.Exception.assert'
10:06:13 <astrolabe> glguy: you mean polynomials in one variable?
10:06:39 <sorear> @localtime dons
10:06:42 <lambdabot> Local time for dons is Sat Apr  7 03:05:02 2007
10:06:44 <dons> ?yow!
10:06:45 <lambdabot> I'm sitting on my SPEED QUEEN ... To me, it's ENJOYABLE ... I'm WARM
10:06:45 <lambdabot> ... I'm VIBRATORY ...
10:07:35 <astrolabe> glguy: If so, then their intersections correspond to roots of the difference of the polynomials, and as narain said, it follows from the fundamental theorem of algebra.
10:08:07 <astrolabe> glguy: In higher dimensions, there is a similar result called iirc Noether's theorem.
10:10:01 <glguy> astrolabe: perfect, thanks. thanks narain :)
10:10:11 <narain> there's also a pretty impressive noether's theorem in physics
10:10:17 <sorear> in higher dimensions you can still use the subtraction trick
10:10:20 <ndm> hi sorear
10:10:27 <potts> this is a one-liner in Perl: perl -ne '@a=split"";for(@a){printf"%02x ",ord;print"\n"unless++$c % 20}' sample.txt
10:10:32 <sorear> you'll just get a system of polynormal
10:10:36 <sorear> hello ndm
10:11:07 <mauke> split"" better written as split//
10:11:50 <sorear> nice, hexdump
10:12:05 <mauke> also, perl -ne 'for(/./sg){...
10:12:27 <potts> How can I do that with GHC in the IO monad?
10:13:00 <potts> That is, to translate a binary file to hex ASCII?
10:13:10 <mauke> @hoogle Int -> [a] -> [[a]]
10:13:11 <lambdabot> No matches, try a more general search
10:13:15 <mauke> :(
10:14:21 <sorear> ghc -e interact$concat.zipWith(\a b -> a : printf "%02x" (fromEnum b)) (cycle ('\n':replicate 19 ' '))
10:14:37 <sorear> i'm not even gonna bother trying to quote that
10:14:38 <sorear> sh--
10:14:48 <mauke> heh, nice
10:15:22 <narain> are we looking for the  chunks  function?
10:15:57 <sorear> @pl \x y -> f x (g y)
10:15:58 <lambdabot> (. g) . f
10:16:02 <mauke> not in scope: printf
10:16:02 <mauke> also, doesn't work
10:16:39 <sorear> ghc -e interact$concat.zipWith((.Text.Printf.printf "%c%02x").fromEnum)(cycle('\n':replicate 19' '))
10:17:08 <potts> I have two file paths, doing something like main = do s <- readFile ifile; writefile ofile (...)
10:17:33 <potts> trying to fill in the ...
10:17:56 <Heffalump> ghc has a -e ?
10:19:02 <mauke> sorear: (. g) . f, not (. f) . g
10:19:35 <glguy> Some days I drink tea just to hear the tea pot whistle
10:20:08 <potts> if I use printf "%02X" I get "bad formatting char X" so it is not using C format strings, at least not fully
10:20:37 <mauke> > printf "%X" 42 :: String
10:20:40 <dons> potts: right.
10:20:40 <lambdabot>  Exception: Printf.printf: bad formatting char X
10:20:46 <mauke> blah, another printf bug
10:21:15 * glguy adjusts the heat to make the whistle sound clearer
10:21:30 <narain> glguy: nothing whistles when i make tea :(
10:22:07 <glguy> ":(" is right
10:22:53 <narain> next time i'll whistle while making tea
10:23:41 <mauke> ghc -e 'interact$concat.zipWith(flip$Text.Printf.printf"%02x %s")(cycle$replicate 19""++["\n"])'
10:25:49 <potts> mauke: that looks promising but I can't test that in my current Cygwin environment; I'm writing a program as an .lhs file to load in ghci
10:27:25 <mauke> wait, why does that code even work
10:28:06 <mauke> writeFile ofile (concat $ zipWith (Text.Printf.printf "%02x %s") s (cycle $ replicate 19 "" ++ ["\n"]))
10:28:53 <mauke> printf is a bit too smart for its own good
10:31:28 <potts> mauke: that works nicely!
10:31:59 <potts> thanks!
10:32:29 <mauke> actually, writeFile ofile (concat $ zipWith (printf "%02x %s") s (cycle $ replicate 19 "" ++ ["\n"]))
10:32:35 <mauke> assuming import Text.Printf
10:32:50 <potts> I'll break it apart... for now I don't want it so nicely formatted so I can do some regex transforms first, but that will be useful
10:36:59 <potts> Clever infinite list for the line breaks...
10:38:44 <sorear> And after fusion it becomes just a counter!  (at least with dcoutts' new fusion system)
10:41:47 <sorear> Is there a prefered style for implementation comments?
10:46:42 <procyon112> ?src forM
10:46:42 <lambdabot> forM = flip mapM
10:47:40 <procyon112> ?src mapM
10:47:41 <lambdabot> mapM f as = sequence (map f as)
10:48:57 <chessguy> heya procyon112
10:49:00 <chessguy> how's code
10:50:25 <chessguy> ?src mapM_
10:50:26 <lambdabot> mapM_ f as = sequence_ (map f as)
10:50:39 <chessguy> ?src sequence
10:50:39 <lambdabot> sequence ms = foldr k (return []) ms
10:50:40 <lambdabot>     where
10:50:40 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
10:50:45 <chessguy> ?src sequence_
10:50:46 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
10:52:46 <procyon112> It's good.  Synced up to your latest and I'm looking at starting to work on it
10:53:29 <procyon112> I tried switching my unification constraints to a Data.Set instead of a list, foolishly thinking it would boost performance... it was about 3xs slower.
10:53:31 <chessguy> cool
10:53:36 <chessguy> ouch
10:53:56 <procyon112> So, that's one optimization I need not try :)
10:56:24 <chessguy> indeed
10:57:56 <chessguy> ok, well i'm getting out of here early today. have a good easter if i don't see you, and feel free to email if you need to know anything about my code
10:58:15 <procyon112> ok
11:12:25 <dons> are the papers written yet?
11:12:36 <dons> argh. no. back to work then.
11:15:26 <kmg> @pl \(a,b) -> b == 0
11:15:26 <lambdabot> (0 ==) . snd
11:17:42 <joelr1> how do you concat 2 strings?
11:17:48 <opqdonut> joelr1: ++
11:17:52 <joelr1> ah!
11:17:54 <opqdonut> > "lol" ++ "kekek"
11:17:58 <lambdabot>  "lolkekek"
11:18:03 <opqdonut> :t "lol"
11:18:03 <joelr1> :t (++)
11:18:07 <lambdabot> forall a. [a] -> [a] -> [a]
11:18:08 <lambdabot> [Char]
11:18:10 <joelr1> he
11:18:17 <opqdonut> rememver that strings are just char lists!
11:26:23 <sorear> what should I call my ultra-ultra-fast bytestring Wadler-combinator-set pretty printing module? WadlerFPS?
11:30:09 <SyntaxNinja> sorear: warm fuzzy thing.
11:30:23 <sorear> :)
11:30:32 <merus> warm fuzzy thing++
11:30:37 <sorear> but it's a monOID!
11:30:38 <sorear> :)
11:30:56 <integral> warm fluffy thing?
11:31:35 <sorear> and <nitpick> I can't have those spaces in my module name </nitpick>
11:31:55 <integral> Text.PrettyPrint.WarmFluffyThing !
11:37:23 <joelr1> ndm: can i add another fun to this?     simple_instance "Arbitrary" dat [funN "parse" [ sclause [] body ] ]
11:37:41 <joelr1> sorear: hi
11:37:44 <phoniq> 2
11:37:45 <phoniq> 2
11:37:50 <joelr1> sorear: Data.Derive totally rocks
11:38:08 <phoniq> whoops
11:38:34 <ndm> joelr1: simple_instance "Arbitrary" dat [funN "parse" [ sclause [] body ], funN "parse" [clauses] ]
11:38:43 <joelr1> ndm: thanks
11:38:50 <joelr1> i'm deriving Arbitrary now :D
11:38:52 <sorear> we're glad you like it, libraries don't exist to take up space :)
11:39:32 <sorear> joelr1: simple_instance "Arbitrary" dat [funN "parse" [ sclause [] body ++ clauses ] ]  should work too / better
11:39:34 <joelr1> sorear, ndm: i now have automatically derived parses, pretty printers and arbitrary instances. working on the latter
11:39:44 <emu> what can you derive Arbitrary for though? sometimes i worry about what such an automatic derivation would produce
11:39:56 <ndm> joelr1: we'll definately want the arbitrary ones back in!
11:40:02 <joelr1> sorear: no, i need to have arbitrary and coarbitrary
11:40:15 <joelr1> ndm: sure
11:40:15 <sorear> joelr1: why me?
11:40:19 <ndm> sorear: i'm going to put up a web page on derive tonight (if the ICFP paper finishes fast enough)
11:40:26 <sorear> <joelr1> sorear: no, i need to have arbitrary and coarbitrary  -- in reference to what?
11:40:37 <ndm> sorear, he means in ref to the above example
11:40:44 <joelr1> sorear: you said it's better to ++ clauses
11:40:56 <joelr1> sorear: i'm saying i want to funNs: arb and coarb
11:40:58 <sorear> joelr1: iff they are the same function, sorry
11:41:01 <sorear> :)
11:41:08 <kmg_> @list
11:41:08 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
11:41:11 <ndm> "Arbitrary" dat [funN "arbitrary" [ sclause [] body ], funN "coarbitrary" [clauses] ]
11:41:27 <ndm> its my fault, my example of two funN "parse" was a typo - i intended to change one of their names
11:41:28 <joelr1> where the coarb should say error ("no coarb impl for " ++ meth name)
11:41:38 <joelr1> that's what i'm gonna work on right now
11:42:07 <sorear> joelr1: ghc will do that automatically if you leave out a method definition
11:42:08 <joelr1> it looks very similar to the parser bit that sorear did so i shouldn't have too much trouble
11:42:22 <joelr1> sorear: nope. it will complain
11:42:37 <joelr1> sorear: that there's no default and no coarb defined
11:42:38 <sorear> just a warning, I though ?
11:42:51 <joelr1> sorear: i guess you thought wrong
11:43:12 <ndm> if you leave coarb, it puts in a version that calls error, and gives a warning
11:43:12 <joelr1> anyway, be back with a solution in a few minutes
11:43:17 <sorear> oh well.  it has to happen occasionally ;)
11:43:20 <ndm> the warning is quite annoying, i think, as coarb is rarely used
11:43:33 <ndm> i should really add a smallcheck deriver as well, for Colin
11:43:34 <joelr1> i hate warnings
11:43:51 <ndm> i think the coarb one is particarly annoying, since coarb is rarely used
11:44:02 <ndm> a CoArbitary class would probably be a better choice
11:44:04 <sorear> but we can derive coarb!
11:44:58 <joelr1> ndm: was there a reason why you said sclause for arb and [clauses] for coarb?
11:45:34 <ndm> joelr1: no, slcause is probably the right thing to use
11:46:29 <ndm> sorear: i was thinking if it is possible to do "reverse derivations" - take a representative data type, and an example derivation, and automatically infer backwards the derivation function - for a restricted class
11:46:39 <ndm> would make writing common derivers much easier, and would be neat :)
11:47:04 <Saizan> record syntax works only when you have a single contructor?
11:47:27 <allbery_b> afaik it works for multiple constructors
11:47:42 <ndm> Saizan: no, multiple
11:47:48 <allbery_b> hm, yes, in fact it's the only way you can use the same field name multiple times
11:47:57 <Saizan> oh, forgot a parens
11:48:21 <allbery_b> (in multiple data constructors for a type; the field types must match)
11:50:06 <joelr1> is this correct?       cbody = l1 "error" $ l2 "++" (lit "no coarbitrary for ") (lit name)
11:50:22 <dylan> sorear: something weird happens when I call Vty.update from different threads.
11:51:48 <sorear> yay.  ISTR it being un-thread-safe in the paste.
11:52:10 <sorear> joelr1: yes, but a bit suboptimal
11:52:20 <joelr1> sorear: i welcome your input!
11:52:45 <sorear> i'd write it as   cbody = l1 "error" $ lit ("no coarbitrary for " ++ name)
11:52:57 <dons> ?time dons
11:53:02 <lambdabot> Local time for dons is Sat Apr  7 04:51:22 2007
11:53:09 <sorear> the optizer will probably make it the same, but less typing ;)J
11:53:09 <dons> oh, plenty of time left.
11:53:24 <joelr1> true, true
11:53:33 <kolmodin> dons: how are you guys doing? finished? :)
11:53:36 * sorear wonders how many strings of 'g' there are in dons' paper
11:53:43 <dylan> sorear: I found a way around it by passing pure functions through a TChan :)
11:53:45 <joelr1> gstrings?
11:53:51 <dons> kolmodin: getting there :-)
11:54:02 <sorear> the key your nose lands on when you fall asleep on the keyboard :)
11:54:22 <kolmodin> dons: will you post the paper here when you are done?
11:54:24 <joelr1> for it it's usually C-<something> hehe
11:54:25 * ndm puts the keyboard further away
11:54:28 <dons> kolmodin: sure.
11:54:39 <balodja> @src seq
11:54:39 <lambdabot> Source not found. stty: unknown mode: doofus
11:55:27 <mauke> @type seq
11:55:29 <lambdabot> forall a t. a -> t -> t
11:55:44 <mauke> seq a b = case a of _ -> b
11:55:48 <kolmodin> dons: great
11:56:15 <sorear> mauke: in core, yes.  in haskell, that won't work
11:56:28 <mauke> :(
11:56:29 <balodja> what's the meaning of seq?
11:56:30 <joelr1> arb2 x = return x `ap` arb `ap` arb
11:56:38 <joelr1> @undo
11:56:39 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
11:56:51 <sorear> joelr1: we have liftmk for that
11:56:53 <integral> seq a@_|_ b = a; seq _ b = b -- roughly
11:57:02 <joelr1> @undo  return x `ap` arb `ap` arb
11:57:03 <lambdabot> return x `ap` arb `ap` arb
11:57:10 <joelr1> sorear: liftmk?
11:57:11 <sorear> @redo  return x `ap` arb `ap` arb
11:57:12 <lambdabot> return x `ap` arb `ap` arb
11:57:24 <sorear> joelr1: one of the Data.Derive combinators
11:57:28 <joelr1> sorear: thing is i don't know how many arguments a constructor may have
11:57:37 <joelr1> so i thought of chaining `ap`s
11:57:46 <balodja> integral: what is the difference between seq and '\a b -> b' then?
11:57:58 <joelr1> sorear: but show me the way!
11:58:04 <integral> balodja: The strictness of the first argument.
11:58:10 <ndm> sorear: i was thinking we might want to split the "simple template haskell" combinators into a separate module within derive, since they stand on their own
11:58:31 <doserj> balodja: seq evaluates a until it is clear that a is not _|_
11:59:38 <joelr1> sorear: i need to generate a call to the constructor with arbitrary for every parameter
11:59:40 <joelr1> :t ap
11:59:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:00:06 <joelr1> :t fmap
12:00:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:00:19 <joelr1> :t liftM
12:00:22 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:00:25 <sorear> joelr1: liftmk works by chaining ap's, it takes a list
12:00:25 <sorear> > seq undefined 2
12:00:25 <sorear> > (\a b -> b) undefined 2
12:00:25 <sorear> Oh, joy!
12:00:27 <sorear> @botsnack
12:00:27 <lambdabot>  Undefined
12:00:28 <lambdabot>  2
12:00:28 <lambdabot> :)
12:00:33 <sorear> liftmk :: Exp -> [Exp] -> Exp
12:00:35 <sorear> liftmk hd args = foldl ap' (return' hd) args
12:00:39 <sorear> so liftmk <a> [<b>, <c>] == return a `ap` b `ap` c
12:00:43 <sorear> joelr1: if you find any commonality between derivers, don't hesistate to add it to Data/Derive.hs
12:00:47 <sorear> that's what it is there for!
12:00:53 <sorear> I think I'm back now :)
12:00:57 <sorear> joelr1: will liftmk work for you?
12:01:12 <sorear> ndm: agreed.  I had the same thought but forgot about it :)
12:01:15 <joelr1> sorear: positively
12:01:20 <joelr1> :t replicate
12:01:22 <lambdabot> forall a. Int -> a -> [a]
12:01:36 <joelr1> what's the monadic version of replicate?
12:01:43 <sorear> :t replicateM
12:01:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
12:01:52 <ndm> sorear: cool, will factor it out at some point (unless you beat me to it) - do you have any outstanding patches floating around that aren't in the main repo?
12:01:55 <sorear> > replicateM 4 [0,1]
12:01:57 <lambdabot>  [[0,0,0,0],[0,0,0,1],[0,0,1,0],[0,0,1,1],[0,1,0,0],[0,1,0,1],[0,1,1,0],[0,1,...
12:02:01 <sorear> ndm: no
12:02:30 <joelr1> > replicateM 2 [1]
12:02:32 <lambdabot>  [[1,1]]
12:02:53 <sorear> [] is the easiest monad to demo in-channel :)
12:03:46 <ndm> > mapM removeFile ["README","passwords","fps","icfp_paper.tex"]
12:03:47 <lambdabot>   Not in scope: `removeFile'
12:04:05 * ndm tries and fails to eliminate the competition ;)
12:05:47 <joelr1> @where replicateM
12:05:47 <lambdabot> I know nothing about replicatem.
12:06:03 <Heffalump> ndm: you'd just be eliminating the Haskell-related competition, though
12:06:43 <sorear> ndm: also don't forget dons is on unix
12:07:10 <ndm> Heffalump: true :) - its the talks on LISP Macros and Type Systems I don't want to sit through
12:07:11 <sorear> ndm: fps would fail to be deleted with EISDIR
12:07:35 <sorear> ndm: this would throw an exception, preventing the paper from being deleted
12:07:52 <Saizan> ?hoogle a -> (a,a)
12:07:53 <lambdabot> Control.Monad.RWS.execRWS :: RWS r w s a -> r -> s -> (s, w)
12:07:53 <lambdabot> Control.Monad.RWS.evalRWS :: RWS r w s a -> r -> s -> (a, w)
12:07:54 <ndm> sorear: good point, i'll reorder
12:07:58 <sorear> join (,)
12:08:08 <sorear> Saizan: join (,)
12:08:25 <sorear> also, why not mapM_? :)
12:08:36 <Saizan> thanks
12:09:40 <stepcut> if I am editing someone else's latex document, what is a good way to add comments ? \marginpar ?
12:10:13 <ndm> \begin{comment}
12:10:20 <benmos> Hi. Does anyone know anything about the relationship between HEP (Haskell Execution Platform) and the current GHC RTS? (Just trying to establish how relevant this doc is:http://www.haskell.org/ghc/docs/papers/hep.ps.gz)
12:10:22 <ndm> stepcut: are you using lhs2tex
12:10:48 <swiert> stepcut: I tend to add comments in a different color.
12:10:51 <benmos> (It seems as though there was an attempt to merge Hugs and GHC which was aborted - but I couldn't see it mentioned in the History of Haskell paper...)
12:10:55 <stepcut> ndm: possibly. The document is named .lhs, but I don't think lhs2tex is actually being used
12:11:15 <ndm> stepcut: in that case \begin{comment}
12:11:23 <ndm> benmos: i think its totally out of date
12:11:27 <stepcut> what if I want the comment to show up in the .dvi ?
12:11:41 <benmos> ok thanks - I kinda suspected that...
12:11:54 <ndm> benmos: i think it and all the ideas got junked lots earlier
12:12:14 <ndm> stepcut: i use \comment{macro}, which i define to output something in bold, but other colours work to
12:12:16 <benmos> ok
12:12:25 <sorear> ndm: what's a good way to describe the implementation of a module?  I don't think anyone will understand my internally-imperative pretty printer compiler without the 160 lines of comments ;)
12:12:45 <stepcut> ndm: ok, that sounds like what I want -- just wanted to make sure I wasn't reinventing something builtin
12:12:54 <swiert> stepcut: \newcommand{\note}[1]{\textcolor{Red}{\textbf{stepcut:~}#1}}
12:12:55 <ndm> sorear: haddock at the top?
12:13:14 <stepcut> swiert: spiffy, I think that is exactly what I want
12:13:19 <sorear> ndm: haddocks I thought were mainly directed at library users.
12:13:21 <ndm> sorear: are you writing this for the template haskell thing?
12:13:33 <sorear> ndm: what I'm writing is directed at future maintainers
12:13:34 <sorear> ndm: no
12:13:45 <ndm> sorear: a little manual style thing is often good
12:13:56 <swiert> Don't forget to \usepackage{color}
12:14:25 <balodja> a stupid question. why ghc doesn't accept '_|_' in source code?
12:14:26 <notsmack> .lhs?
12:14:26 <dylan> blaa, I want to pattern match on ByteStrings
12:14:41 <sorear> balodja: because it's not in the report, sadly
12:15:13 <sorear> balodja: that value can be generated using infinite recursion, or (more usefully) Prelude.error
12:15:16 <sorear> :t error
12:15:19 <lambdabot> forall a. [Char] -> a
12:15:28 <sorear> _|_ inhabits every type!
12:15:39 <sorear> operationally error throws an exception
12:15:46 <sorear> those are _|_ too
12:15:52 <stepcut> balodja: in general '_anything' is the same as '_', so allowing _|_ => undefined would be a special exception
12:16:05 <balodja> oh, i understand. thanks
12:16:11 <dylan> _|_ is not 'undefined'?
12:16:12 <sorear> stepcut: uh?
12:16:16 <dylan> > undefined
12:16:18 <lambdabot>  Undefined
12:16:18 * stepcut could be wrong
12:16:27 * dmead is back (gone 17:04:11)
12:16:38 <sorear> stepcut: _|_ lexes as (reservedid _) (reservedop |) (reservedid _)
12:16:39 <joelr1> @where ap
12:16:40 <lambdabot> I know nothing about ap.
12:16:45 <dmead> man
12:16:48 <Saizan> ?info ap
12:16:48 <sorear> joelr1: Control.Monad
12:16:48 <lambdabot> ap
12:16:48 <dmead> coffee is made of awesome
12:16:49 <joelr1> @hoogle ap
12:16:50 <lambdabot> Monad.ap :: Monad a => a (b -> c) -> a b -> a c
12:16:51 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
12:16:51 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
12:17:09 <sorear> stepcut: and btw _foo is a varid
12:17:22 <stepcut> sorear: ah
12:17:29 <balodja> so, _|_ is just a pattern?
12:17:40 <sorear> _|_ is a syntax error
12:17:58 <sorear> | introduces a guard, to the right of which must be an expression
12:18:14 <sorear> _ is only legal in patterns, and is an error in expressions
12:18:41 <sorear> actually with pattern guards foo _|_ <- True = False is legal
12:18:48 <sorear> but that's pretty ...
12:18:50 <sorear> IOHCC
12:19:10 <hpaste>  joelr1 pasted "derivation of Arbitrary" at http://hpaste.org/1288
12:19:13 <dons> yay. one paper done.
12:19:16 <dons> one more to go!
12:19:22 <joelr1> sorear, ndm: i think i got it
12:19:26 <dons> 0 days 02h 43m 06s
12:19:27 <dons> we can do it!
12:20:29 <ndm> joelr1: well done
12:20:30 <sorear> dons: can you have the @where stats use UTC? (Of course I'd prefer PDT, but UTC is likely to satisfy more people than australia time)
12:20:41 * joelr1 bows
12:20:50 <stepcut> lambdabot needs a countdown timer, for things like the ICFP paper submission deadline, or ICFP contest
12:20:58 <ndm> the string should be used instead of list char, thats a job for the peephole optimiser though
12:20:59 <joelr1> not much of my input, it's sorear's code that i stole :D
12:21:07 <stepcut> @panic
12:21:08 <lambdabot> Unknown command, try @list
12:21:12 <sorear> @todo-add <stepcut> lambdabot needs a countdown timer, for things like the ICFP paper submission deadline, or ICFP contest
12:21:13 <lambdabot> Entry added to the todo list
12:21:19 <joelr1> ndm: i did not include it. is that a fault?
12:21:26 <joelr1> ndm: did not import it that is
12:21:44 <potts> Does anyone know why a little file filter executed in ghci would complete after processing only a small subset of the file?
12:21:47 <ndm> joelr1: no, its just an option for later - so error ['a','b'] goes back to error "ab" in teh result
12:21:58 <joelr1> fair enough
12:22:15 <sorear> ndm: IMO the peephole should be called by .TH and .SYB, not the derivers.  do you agree?
12:22:26 <potts> >main = do
12:22:28 <potts> >    s <- readFile ifile
12:22:28 <lambdabot>  Parse error
12:22:29 <potts> >    writeFile ofile (concat $ zipWith (printf "%02x%s") s (cycle $ [" "]))
12:22:30 <lambdabot>   Not in scope: `s'
12:22:31 <potts> >    putStr "Filtering successful\n"
12:22:33 <lambdabot>  <IO ()>
12:22:42 <potts> oops
12:22:58 <ndm> sorear, thats fine by me - i was just trying not to break other code while testing it out
12:23:19 <ndm> i.e. i wasn't sure whether it should peephole expressions or statements etc, but now its finalised a bit more, put it to the top
12:23:30 <sorear> ndm: ah, that makes perfect sense :)
12:24:31 <potts> anyway it works fine on a small test file, but when I give it something bigger (3 MiB) it completes but after outputting only about 1 KiB
12:24:49 <potts> Should it not lazily complete the whole file?
12:27:17 <Pastorn> ?where alex
12:27:18 <lambdabot> http://www.haskell.org/alex/
12:28:19 <sjanssen> potts: yes, writeFile should complete before reaching the last putStr statement
12:28:44 <potts> hmmm...
12:29:14 <ndm> hmm "Area(s) in which persons best qualified to review your paper are likely to be doing their own research"
12:29:19 <ndm> what exactly does that mean?
12:29:23 <sorear> potts: the only thing I can think of that would cause this is that readFile silently truncates on the first IO error
12:29:32 <sorear> potts: can you cat the file?
12:29:47 <Philippa> ndm: where it's hard to find a review who isn't doing something similar
12:29:50 <Philippa> *reviewer
12:30:08 <potts> This is with ghci 6.6 on a WinXP system, loading a .lhs file with the ifile and ofile path defined.
12:30:18 <ndm> Philippa: i guess my abstract makes it quite obvious, "Haskell, program analysis" - I guess
12:30:38 <dmead> ghc is a grumpy beast
12:30:45 <dmead> it crashes on my proff's machine =/
12:31:00 <emu> ndm: a list of research areas, such that, a person in them would be likely to understand your paper
12:31:07 <sorear> potts: windows dumbness probably.  readFile uses text mode.  I'll bet there is a ^Z about 1k into your file
12:31:33 <dons> ?yow!
12:31:34 <lambdabot> Is he the MAGIC INCA carrying a FROG on his shoulders??  Is the FROG
12:31:34 <lambdabot> his GUIDELIGHT??  It is curious that a DOG runs already on the
12:31:34 <lambdabot> ESCALATOR ...
12:31:35 <sjanssen> mmm, that would do it
12:31:39 <dons> tea tea tea paper paper paper write write write
12:31:44 <sjanssen> @localtime dons
12:31:46 <dons> oh, the sun is coming up. fun fun fun
12:31:49 <lambdabot> Local time for dons is Sat Apr  7 05:30:11 2007
12:31:53 <dmead> what time is it there dons?
12:31:57 <dmead> oof
12:31:58 <sorear> dons: is yow your way of staying awake?
12:32:04 <balodja> @pl seq (seq a b) c
12:32:05 <lambdabot> seq (seq a b) c
12:32:14 <dmead> i stay awake for long period by not drinking coffee
12:32:18 <mauke> @pl \seq -> seq (seq a b) c
12:32:19 <lambdabot> flip (ap id (flip ($ a) b)) c
12:32:24 <dmead> but getting a steady supply of nice cold water instead
12:32:26 <dons> i am the MAGIC INCA carrying a FROG on his shoulders
12:32:27 <dmead> *ice cold
12:32:31 <sjanssen> balodja: same as a `seq` b `seq` c
12:32:34 * ndm suspects that my submission may not be that blind, i've presented some bits of it to at least two of the reviewers within the last 2 days
12:32:39 <ndm> actually, yesterday!
12:32:58 <sjanssen> uh oh, dons has become zippy
12:33:08 <balodja> sjanssen: i'm trying to get pointless form :)
12:33:19 <mauke> @pl \a b c -> seq (seq a b) c
12:33:20 <lambdabot> (seq .) . seq
12:33:30 <balodja> hm, that's it :)
12:33:42 <potts> sorear: that sounds plausible... it is binary, if I cat the file I get a lot of graphics chars and beeping...
12:33:45 <yip> if assert fails from a subthread will it shut down the whole program?
12:34:01 <sorear> yip: no
12:34:16 <sorear> yip: it will (should) silently kill the thread
12:34:25 <sorear> yip: which I am sure is Bad
12:34:35 <balodja> @pl \a b c d -> seq (seq (seq a b) c) d
12:34:35 <lambdabot> (((seq .) . seq) .) . seq
12:34:38 * sorear tests, maybe ghc hq thought of this already
12:34:40 <sjanssen> silently?  I think you'll get the message on stderr
12:34:52 <mauke> @pl \a b c -> seq a (seq b c)
12:34:52 <lambdabot> (. seq) . (.) . seq
12:35:10 <mauke> @pl \a b c d -> seq a (seq b (seq c d))
12:35:11 <lambdabot> (. ((. seq) . (.) . seq)) . (.) . (.) . seq
12:35:15 <balodja> an ugly one
12:35:32 <mauke> @. unpl pl \a b c d -> seq a (seq b (seq c d))
12:35:32 <lambdabot> (\ n ac h k -> seq n (seq ac (seq h k)))
12:35:47 <mauke> unpl: you win this round
12:36:12 <sjanssen> @pl (\a b c d -> seq (seq a b) (seq c d))
12:36:13 <lambdabot> flip flip seq . (((.) . (.) . seq) .) . seq
12:37:01 <sorear> pl gets a lot of things ever so subtly wrong.
12:37:05 <sorear> @pl liftM
12:37:06 <lambdabot> fmap
12:37:11 <mauke> <3
12:37:16 <potts> ugh, some Googling leads me to think I might need to use a ton of code with UnsafeInterleaveIO and all that... to read a binary file?
12:37:19 <sorear> some things more subtle than others.
12:37:39 <sorear> @ty \x y z -> x z (y z)
12:37:42 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
12:37:46 <sorear> @. type pl \x y z -> x z (y z)
12:37:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:38:02 <joelr1> i have modules named EasyParser, EasyTester, EasyPrinter
12:38:04 <sorear> and somethings less subtle.
12:38:09 <_frederik_> is there a datatype for when i have a pair of functions (a -> m b, b -> m a) for instance to specify a relation if m is []
12:38:10 <joelr1> i like everything but Tester for some reason
12:38:14 <sorear> @pl \foo -> let a = 2  in a
12:38:14 <lambdabot> const 2
12:38:17 <sorear> @pl \fix -> let a = 2  in a
12:38:18 <lambdabot> ($ const 2)
12:38:19 <joelr1> but I thought i'd call it that for consistency
12:38:25 <sorear> alpha renaming breaks pl :)
12:38:37 <potts> oh, there is a readBinaryFile...
12:39:14 <_frederik_> the pair of such functions is an arrow, easily
12:39:19 <sjanssen> sorear: yeah, why haven't you fixed pl yet? ;)
12:39:22 <sorear> _frederik_: so you want both kliesli compositions to be 'return'?
12:39:32 <_frederik_> i don't know
12:39:38 <mauke> @index readBinaryFile
12:39:39 <lambdabot> bzzt
12:39:57 <_frederik_> perhaps. i think of it as >>=
12:40:17 * ndm has submitted, woohoo!
12:40:50 <mauke> @type \s -> openBinaryFile s ReadMode >>= hGetContents
12:40:51 <sorear> yeay!
12:40:53 <lambdabot> Not in scope: `openBinaryFile'
12:40:53 <lambdabot>  
12:40:53 <lambdabot> <interactive>:1:23: Not in scope: data constructor `ReadMode'
12:41:00 <potts> @index readBinaryFile
12:41:01 <lambdabot> bzzt
12:41:08 <sorear> ndm: and I'll bet sleep sounds like a really good idea right now? :)
12:41:18 <sjanssen> @localtime ndm
12:41:20 <lambdabot> Local time for ndm is 06 April 2007 8:39:40 pm
12:41:28 <mauke> @type \s -> System.IO.openBinaryFile s System.IO.ReadMode >>= System.IO.hGetContents
12:41:30 <sorear> er, /me got confused
12:41:31 <ndm> sorear: i was going to update my website :)
12:41:31 <lambdabot> FilePath -> IO String
12:41:43 <sorear> @. links where ndm
12:41:44 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "links"
12:42:31 <potts> Should be in System.IO.Binary but GHCi can't find this lib?
12:42:58 <mauke> why do you think it should be in System.IO.Binary?
12:43:49 <sjanssen> potts: there is no readBinaryFile.  You should use mauke's little snippet above to write your own readBinaryFile
12:43:57 <potts> http://software.complete.org/missingh/static/doc/System-IO-Binary.html
12:44:00 <lambdabot> http://tinyurl.com/yowydd
12:44:02 <mauke> missingh
12:44:17 <sjanssen> potts: missingh is a third party library, not packaged with ghc
12:44:45 <potts> ok
12:48:40 <joelr1> @derive
12:48:41 <lambdabot> Unknown command, try @list
12:48:41 <joelr1> err
12:48:46 <dylan> hmm, in a multithreaded application, how do you stop all the threads?
12:48:50 <joelr1> @where derive
12:48:50 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/derive
12:49:06 <sieni> dylan: with exit()
12:49:26 <dylan> sieni: ah, from System.Exit?
12:50:04 <potts> Cool, it seems to have worked!
12:50:27 <potts> (Can a 39 yr-old engineer say "cool?")
12:50:34 <sieni> dylan: that was intended as a semihumorous comment
12:50:38 <Heffalump> "cool" has an age limit?
12:50:42 <dmead> @hoogle showPrec
12:50:42 * Heffalump looks worried
12:50:43 <lambdabot> No matches found
12:50:43 <sorear> careful. on Linux 'exit' only kills the current thread.
12:50:50 <Pastorn> @seen cantadou
12:50:50 <lambdabot> I haven't seen cantadou.
12:50:57 <dmead> ?src showPrec
12:50:58 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
12:51:00 <dmead> :<
12:51:04 <sorear> (assuming libpthreads doesn't wrap it, which it very well might)
12:51:13 <dylan> of course, these are forkIO threads. if the main thread closes, all the other ones go poof too
12:51:16 <ndm> potts: on the internet you can be a 39 year old engineer, or a 12 year old girl - your choice
12:51:31 <dmead> dylan: i don't know about that
12:51:55 <dmead> if a child thread is blocking, it won't terminate till it stops
12:52:02 <dmead> even if you kill the main thread
12:52:19 <dylan> well, this is the observed behavior, and what the GHC docs say
12:52:28 <dmead> oh
12:52:34 <potts> 12 yo girl with a full bear? that's weird, ndm!
12:52:41 <dmead> ahh
12:52:46 <potts> sorry, "bear" == "beard..."
12:52:46 <dmead> in C++ thats usually what happens
12:52:52 <stepcut> a full bear! what kind of web sites are you visiting :(
12:52:55 <sorear> dmead: I just tested it
12:52:57 <dmead> assuming the main thread dies without calling pthread_exit
12:53:10 <sorear> stefan@stefans:~/packedwlm$ time ghc -e 'Control.Concurrent.forkIO (System.Posix.Unistd.sleep 30 >> return ())'
12:53:10 <sorear> ThreadId 14
12:53:10 <sorear> real    0m0.762s
12:53:21 <sorear> yes, ghc is really that slow ;(
12:53:25 <dmead> :<
12:53:35 <sorear> sleep is implemented as a blocking foreign call
12:53:55 <sorear> it's ridiculously expensive compared to threadDelay, which is internal to the rts
12:54:22 <dmead> hmm
12:55:16 <int-e> sorear: the startup overhead is very big
12:56:15 <sorear> int-e: I know.  It sucks.
12:56:31 <sorear> int-e: why can't ghc lazily load base?
12:56:43 <sorear> why must the whole thing be slurped in?
12:57:13 <sorear> after all, I can start an arbitrarily large binary program in microseconds through the glory of mmap(2)
12:57:52 <potts> Well, the Haskell worked, now I'm just waiting for vim to do a regexp search and replace on a 20 MiB text file (whee...) using 50% of my CPU... wow...
12:58:24 <sorear> tr is very fast
13:00:02 <ndm> potts: hypertheaded machine?
13:01:21 <mauke> http://blogs.msdn.com/oldnewthing/archive/2005/12/02/499389.aspx
13:01:22 <lambdabot> Title: The Old New Thing : Psychic debugging: Why your CPU usage is hovering at 50%
13:02:35 <potts> ndm: yes (system info claims 2 CPUs, x86 Family 15 Model 4, whatever that is...)
13:02:41 <sorear> but on HT if your cpu usage is at 50% it's really more like 80%
13:02:52 <sorear> it ain't HT if the cpus are independant
13:02:56 <ndm> well at 50% my fans spin very loud!
13:03:32 <potts> interesting...
13:03:37 <sorear> my fans are variable loudness and are always quiet at 0%, sometimes equally quiet at 100%
13:03:56 <potts> I may have to find a better way...
13:03:59 * sorear should hook up an ammeter and see if the volume correlates to current draw
13:04:01 <ndm> my computer is louder than everyone in the office, which is weird because they are identical (in theory)
13:04:03 <xerox> sorear, what hardware are you on?
13:04:27 <sorear> xerox: PC compatible
13:04:47 <sorear> I don't know anything about my psu specs
13:05:03 <xerox> sorear, laptop? I'm looking for a decent *quiet* laptop, so I asked.
13:05:10 <sorear> I can give you cpuid numbers and benchmark results, but I doubt that will help
13:05:21 <sorear> xerox: no, tower type
13:05:48 <xerox> alright
13:06:01 <sorear> and the fans always make fan noises whhhhhhhhhhhh
13:06:16 <sorear> but sometimes they also maye iiiiiiiiiiiiii noises
13:06:44 <sorear> iiiiiiiiii as in ick
13:07:18 <mauke> yay, a constructor called BONES
13:07:23 <potts> I will have to try this on my Linux box at home... I suspect Cygwin is doing something nasty.
13:07:30 <mauke> binary op not-equal (string)
13:07:38 <sorear> xerox: actually it must be the psu because CPU activity and GPU activity make the same noise
13:07:52 <sorear> not that I do much of the latter :)
13:08:36 <sorear> mauke: it's monomorphic!?  Yuck!
13:08:41 <sorear> :)
13:08:50 <mauke> what!
13:08:59 <potts> Ahh! the first regexp replace finished, but that took WAY too long...
13:23:50 <eumenides> dv@mobius:~/tmp/yi$ runhaskell Setup.hs build
13:23:50 <eumenides> *** Exception: failed to extract ghc path from command line
13:23:52 <eumenides> eugh?
13:24:59 <jyp> eumenides: do you have gnu make?
13:25:13 <eumenides> jyp: yes
13:25:27 <jyp> eumenides: then use the makefile...
13:25:38 <jyp> as explained in the README
13:25:51 <sorear> ick, make :)
13:25:57 <sorear> what's wrong with Cabal?
13:26:13 <eumenides> jyp: oh doh, README
13:26:34 <jyp> sorear: well the makefile gives the required options to Cabal
13:26:51 <jyp> sorear: and there is more than one cabal package too.
13:27:01 <sorear> if it doesn't work with cabal-setup it's just broken :)
13:27:35 <sorear> we need to have cabal work, not have makefiles to paper over cabal's problems
13:27:49 <jyp> cabal is way more complex than makefiles for this type of work
13:29:01 <jyp> sorear: I agree, but it's a lot of work
13:29:25 <sorear> cabal should be easier to hack ;)
13:29:34 <jyp> oh, yes.
13:29:47 <procyon112> ?src dropWhile
13:29:48 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:30:08 <procyon112> ?src dropwhile
13:30:09 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
13:30:34 <jyp> ?src Data.List.dropWhile
13:30:34 <lambdabot> Source not found. Take a stress pill and think things over.
13:30:56 <jyp> @hoogle dropWhile
13:30:57 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
13:30:57 <lambdabot> Data.PackedString.dropWhilePS :: (Char -> Bool) -> PackedString -> PackedString
13:31:22 <procyon112> ?src Prelude.dropWhile
13:31:23 <lambdabot> Source not found. Where did you learn to type?
13:32:55 <procyon112> Can I short circuit our of a foldr?
13:33:04 <procyon112> out even
13:33:18 <Heffalump> procyon112: yes, just don't use the second argument.
13:33:28 <Heffalump> and lazy evaluation will do the rest
13:38:57 <sorear> @src any
13:38:58 <lambdabot> any p =  or . map p
13:39:02 <sorear> @src or
13:39:02 <lambdabot> or    =  foldr (||) False
13:39:13 <sorear> > repeat True
13:39:15 <lambdabot>  [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,...
13:39:18 <sorear> > or $ repeat True
13:39:20 <lambdabot>  True
13:39:37 <eumenides> i've installed two things called FilePath but none of them satisfy yi. which one do i need?
13:39:58 <sorear> eumenides: read the mailing list!
13:40:00 <jyp> eumenides: http://darcs.haskell.org/packages/filepath/
13:40:02 <lambdabot> Title: Index of /packages/filepath
13:42:13 <eumenides> sorear: oh yeah. i did. but between reading and this there were a host of other things to install so i forgot about it :)
13:42:36 <sorear> hehe.
13:47:43 <xerox> 'lo fean
13:47:52 <fean> hi
13:51:54 <procyon112> ?src mzero
13:51:55 <lambdabot> Source not found. Where did you learn to type?
13:52:02 <procyon112> @hoogle mzero
13:52:03 <lambdabot> Control.Monad.mzero :: MonadPlus m => m a
13:52:12 <procyon112> ?src fail
13:52:13 <lambdabot> fail s      = error s
13:52:39 <merus> So I'm trying to install a Cabal package. ghci -package Cabal works, but trying to runghc the setup file can't find Distribution.Simple. :/
13:52:51 <merus> Was I supposed to put something somewhere?
13:53:06 <ndm> @where+ catch http://www-users.cs.york.ac.uk/~ndm/catch/
13:53:06 <lambdabot> Done.
13:53:08 <ndm> @where play
13:53:09 <lambdabot> I know nothing about play.
13:53:12 <ndm> @where derive
13:53:12 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/derive
13:53:22 <mauke> @where deride
13:53:22 <ndm> @where+ derive http://www-users.cs.york.ac.uk/~ndm/derive/
13:53:22 <lambdabot> Done.
13:53:22 <lambdabot> I know nothing about deride.
13:53:33 <ndm> @where filepath
13:53:33 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php#filepath
13:53:40 <ndm> @where+ filepath http://www-users.cs.york.ac.uk/~ndm/filepath/
13:53:40 <lambdabot> Done.
13:53:54 <ndm> @where winhugs
13:53:55 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/winhugs.php
13:54:03 <ndm> @where+ winhugs http://www-users.cs.york.ac.uk/~ndm/winhugs/
13:54:03 <lambdabot> Done.
13:56:36 <sorear> @flush
13:56:46 <eumenides> oh god this FilePath thing won't install
13:57:05 <icarroll> @quote primality
13:57:06 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
13:57:15 <icarroll> @quote miller-rabin
13:57:16 <lambdabot> No quotes match. The more you drive -- the dumber you get.
13:58:31 <ndm> eumenides: how come?
13:59:13 <eumenides> ndm: i don't know :( it seems to install fine, but yi can't find it
14:02:02 <potts> I have to sign off... thanks everyone for your help!
14:03:04 <jyp> eumenides: what says ghc-pkg list ?
14:04:09 <ndm> finished my website, now i realise i haven't eaten anything other than cookies for just over 10 hours, so go to find a chinese
14:04:24 <eumenides> jyp: /usr/local/lib/ghc-6.6/package.conf: filepath-1.0
14:04:44 <ndm> sorear: if you have anything you think should be on the derive page, just send it over - http://www-users.cs.york.ac.uk/~ndm/derive/
14:04:44 <dmead> @hoogle parsec
14:04:45 <lambdabot> Text.ParserCombinators.Parsec :: module
14:04:45 <lambdabot> Distribution.Setup.parseCleanArgs :: [String] -> [OptDescr a] -> IO (Int, [a], [String])
14:04:45 <lambdabot> Distribution.Setup.parseConfigureArgs :: ConfigFlags -> [String] -> [OptDescr a] -> IO (ConfigFlags, [a], [String])
14:04:46 <lambdabot> Title: Neil Mitchell - Derive
14:04:53 <ndm> i'll do it myself, but can't be bothered quite now :)
14:05:25 <ndm> bye all
14:05:28 <jyp> eumenides: mine says FilePath-1.0 (note the difference in case...)
14:05:32 <dmead> bye bye
14:05:55 <jyp> eumenides: maybe just fix the case somewhere a cabal file.
14:06:18 <jyp> ndm: what's the latest story about the package exact name?
14:06:51 <dons> yay. submitted.
14:06:54 <dons> phew.
14:06:56 <procyon112> ?src replicateM
14:06:57 <lambdabot> replicateM n x = sequence (replicate n x)
14:08:04 <eumenides> jyp: yay it worked! now i get: setup: Unrecognised flags: --disable-haddock-use-packages. maybe i should get a newer haddock?
14:08:58 <jyp> eumenides: is that what make emacs says?
14:09:08 <eumenides> jyp: yes
14:09:14 <jyp> ah...
14:09:30 <jyp> easiest is to install new haddock then
14:09:45 <jyp> uh
14:11:11 <jyp> eumenides: what if you just comment the offending line in cabal-make.inc ?
14:13:04 <eumenides> yip: i get a new error. possibly unrelated: ./setup build --with-ghc=/usr/bin/local/ghc \ setup: fd:5: hGetLine: end of file
14:14:40 <yip> eh?
14:14:43 <jyp> eumenides: that one is new
14:15:27 <jyp> eumenides: maybe you need the latest cabal?
14:16:30 <eumenides> jyp: more recent than the one with ghc 6.6?
14:16:59 <jyp> eumenides: Cabal-1.1.7...
14:17:55 <eumenides> jyp: well, okay
14:18:19 <jyp> http://darcs.haskell.org/packages/Cabal/
14:18:20 <lambdabot> Title: Index of /packages/Cabal
14:18:44 <eumenides> oh i was getting a different one haha
14:33:32 <jyp> eumenides: I will have to go now... Would you mind updating README with up to date install information?
14:33:36 <dons> yaya. all submitted.
14:33:40 <dons> ?time dons
14:33:44 <lambdabot> Local time for dons is Sat Apr  7 07:32:09 2007
14:33:50 <jyp> Yay dons ;)
14:34:07 <dcoutts> @yarr!
14:34:08 <lambdabot> I'll keel haul ya fer that!
14:34:11 <dcoutts> woo hoo!
14:34:18 * dcoutts is shattered
14:34:38 <dons> yeah, we pulled an all nighter
14:34:39 <eumenides> jyp: how would i do that?
14:35:05 <kolmodin> ?localtime dons
14:35:08 <lambdabot> Local time for dons is Sat Apr  7 07:33:35 2007
14:35:15 <kolmodin> well done! :)
14:35:21 <dons> want a copy, kolmodin ? :-)
14:35:33 <jyp> eumenides: just edit README; and "darcs send" when you're done :)
14:35:58 <eumenides> jyp: ooh. mayhap
14:35:58 <jyp> eumenides: or just mail me info if you're unsure.
14:36:04 <kolmodin> dons: just got one of dcoutts
14:36:08 <kolmodin> thanks anyway :)
14:36:17 <jyp> eumenides: many thanks!
14:36:28 <sorear> dons: jyp here just confessed to using Makefiles for haskell :)
14:36:56 <dons> hehe
14:37:12 * jyp blushes
14:37:51 <jyp> Anyhoo... Makefiles are great :)
14:38:01 <jyp> well... gotta run :p
14:40:07 * Heffalump thinks makefiles are much better than language-specific build systems
14:41:07 <yip> wasn't there a make-like haskell DSL?
14:41:12 * sorear thinks makefiles are too much boilerplate, and wishes they had higher-order functionality, like a Haskell DSL
14:41:34 <dmead> have you ever used scons?
14:41:43 <dmead> sorear
14:41:48 <phoniq> kde went to cmake
14:41:53 <yip> scons is a make-like python DSL :)
14:41:56 <phoniq> little clunky, works well
14:41:58 <sorear> dmead: used isn't the right term
14:42:05 <sorear> dmead: more like cursed
14:42:08 <dmead> hehe
14:42:13 <dmead> yip: it's not a dsl
14:42:19 <dmead> you have access to all of python
14:42:32 <Heffalump> sorear: that's true.
14:42:42 <dmead> and cmake just simplifies writting makefiles
14:42:46 <yip> with a DSL you usually have access to all of the host language
14:42:50 <dmead> ah
14:42:56 <phoniq> cmake generates makefiles
14:43:00 * kc5tja_ has had nothing but horrifying problems using CMake for his own projects.  :(
14:43:06 <yip> i guess i should be saying EDSL instead of DSL
14:43:11 <dmead> i used cmake on a few quake projects
14:43:18 <dmead> it's not too bad, if your alternative is makefiles
14:43:22 <phoniq> i just converted a big, big project to cmake, and was relieved
14:43:22 <phoniq> he
14:43:25 <phoniq> heh
14:43:35 <stepcut> sorear: how does your unlambda compiler work? Does it compile unlambda -> binary executable ?
14:43:38 <phoniq> i was just going to say that, i was prolly relieved cause i was coming from straight-make
14:43:44 <dmead> ahh
14:43:45 <dmead> yea
14:43:55 <sorear> stepcut: it is just a syntax translator
14:43:56 <phoniq> you could probably put together something killer and makeish w/ haskell
14:43:58 <kc5tja_> CMake kept producing empty makefiles (e.g., makefiles that did nothing upon trying to actually make something).
14:43:59 <dmead> i went from cmake to scons
14:44:10 <dmead> and its really very similar if you just use scons for a basic build system
14:44:16 <kc5tja_> CMake worked fine on Slackware, but failed outright on Gobo, despite being compiled from the same version of the source.  :(
14:44:16 <sorear> stepcut: I have embedded unlambda as a DSL in both Haskell and O'Caml
14:44:29 <dmead> =/
14:44:44 <sorear> stepcut: so all I have to do is translate the syntax, and the inliner takes care of the rest :)
14:44:47 <dmead> is slackware still on 2.4?
14:44:48 * kc5tja_ has had very, very good results with Scons, actually.
14:45:00 <dmead> i used that for years till gentoo came along
14:45:03 <kc5tja_> But I ended up going back to GNU make, via non-recursive makefiles.
14:45:18 * sorear wishes scons followed the GNU interface standards
14:45:32 <dmead> it'd take over if it supported recursion
14:45:34 <sorear> at the very least, it needs a good manpage :(
14:45:47 * kc5tja_ wishes the GNU interface standards weren't so damn complicated.  :)
14:45:50 <dmead> it has A manpage..
14:46:01 <kc5tja_> sorear: SCons has an outstanding manpage.
14:46:07 <tiglionabbit> :t floor
14:46:10 <dmead> jesus
14:46:11 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
14:46:11 <sorear> dmead: yeah, I've already spent far too long trying to make any sense of it
14:46:12 <dmead> it's...
14:46:28 <dmead> 5922 lines long..
14:46:51 <kc5tja_> Perhaps what SCons needs most is an *info* page, not a manpage.  :D
14:47:04 <dmead> or just some good examples
14:47:19 <dmead> it takes a while to see whats going on, that is if you don't know python
14:47:58 * kc5tja_ has more than once pondered a Haskell-based build system that could be used for non-Haskell projects.  But then, that requires Haskell to be present on people's machines.
14:48:21 <tiglionabbit> why can't I use floor after dividing Integers?
14:48:34 <phoniq> part of the problem is figuring out what problem you're going to solve
14:48:37 <sorear> you don't need to, just use div
14:48:41 <sorear> > 100 `div` 3
14:48:42 <tiglionabbit> it says 'No instance for (RealFrac Integer)
14:48:43 <lambdabot>  33
14:48:53 <sorear> > (-100) `div` 3
14:48:54 <lambdabot>  -34
14:49:01 <Saizan> ?type (/)
14:49:04 <lambdabot> forall a. (Fractional a) => a -> a -> a
14:49:05 <phoniq> there's platform detection, doing the actual build, determining what needs building, integration with autobuild systems...
14:49:06 <mauke> > 100 / 3 :: Integer
14:49:07 <sorear> / is only for floating point numbers
14:49:07 <lambdabot>   add an instance declaration for (Fractional Integer)
14:49:07 <lambdabot>     In the expression:...
14:49:14 <phoniq> platform detection is a complete PITA
14:49:28 <dmead> PITA?
14:49:32 <phoniq> pain in the ass
14:49:33 * kc5tja_ feels that emitting makefiles is an adequate solution.  However, the makefiles really ought to be non-recursive (e.g., makes *including* sub-makefiles, not *invoking* them).
14:49:36 <tiglionabbit> how do I divide integers then?
14:49:43 <tiglionabbit> and round down
14:49:56 <phoniq> i pretty much agree with you there
14:49:56 <tiglionabbit> or up
14:50:16 <phoniq> though since the generated makefiles are essentially opaque, why does it matter if they recurse or not?
14:50:32 <phoniq> at that point your interface is basically a bunch of make targets
14:50:36 <procyon112> ?src liftM
14:50:37 <kc5tja_> With respect to platform detection, I think these ought to be handled by separate utilities, and not as functions of the build system.  The whole "separation of concerns" thing.  :)
14:50:37 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
14:51:04 <kc5tja_> phoniq: It matters because of speed and performance.  It really, really does make a difference.
14:51:06 <sorear> kc5tja_: what do you think of the autoconf/automake split then :)
14:51:16 <tiglionabbit> guys?
14:51:25 <phoniq> ok, i'll buy that
14:51:27 <sorear> tiglionabbit: div, quot
14:51:32 <sorear> > 100 `div` 3
14:51:34 <lambdabot>  33
14:51:39 <sorear> > (-100) `div` 3
14:51:41 <lambdabot>  -34
14:51:41 <tiglionabbit> quot?
14:51:45 <tiglionabbit> oh
14:51:46 <sorear> > (-100) `quot` 3
14:51:47 <lambdabot>  -33
14:51:49 <tiglionabbit> thank you
14:51:49 <sorear> > 100 `quot` 3
14:51:51 <lambdabot>  33
14:51:56 <phoniq> it's really hard to define your interface between platform detection and build, though.
14:52:02 <sorear> quot rounds to zero, div to -infinity
14:52:20 <sorear> phoniq: @CC@ isn't good enough for you?
14:52:22 <phoniq> the platform appears right in the code you're compiling, a-la #ifdef __ppc__
14:52:34 <phoniq> heh, not nearly good enough
14:52:44 <kc5tja_> phoniq: I don't think so.  A source file will need to know the basic integer sizes, etc.  So, invoke a command "get-int-sizes" and redirect the output to some file.
14:53:03 <kc5tja_> phoniq: Detecting a library likewise can be done with the pkg-config script.
14:53:26 <phoniq> not all packages have such stuff
14:53:41 <kc5tja_> If they want to be auto-configured, they'd better GET such stuff.
14:53:43 <phoniq> i'm just saying it ineviably gets messy and calls for something slick and scriptable
14:54:07 <phoniq> i deal with a lot of physics c++ software
14:54:24 <phoniq> these guys dig up old packages that just happen to do something they need, and you've gotta integrate it somehow
14:54:49 <kc5tja_> Yeah, and autoconf certainly isn't going to help you with that.
14:56:25 <phoniq> i think it's time somebody did for 'make' what the svn guys did for cvs.  There's some basic stuff about make that Just Works and makes sense and a ton that misses the mark
14:56:33 <phoniq> and gnu make is essentially a dead project afaict
14:57:20 <phoniq> anyway, off topic.  it'd be interesting to try to write a real basic make in haskell and see what it looks like.
14:57:35 <yip> thing is that make is a widely adopted standard, with implementations available on pretty much every platform
14:57:52 <phoniq> yah
14:58:22 <Heffalump> one key thing that any replacement needs to do is parse makefiles, at least to the extent that compilers produce them with -M
14:58:30 <phoniq> i worked for weeks to try to get boost::jam to work, that turned out to be a train wreck
14:58:43 <kc5tja_> That implies that it ought to be written in something like Java or Python, where implementations are pretty much universal.
14:58:49 <kc5tja_> But, for the love of god, PLEASE stay away from XML!
14:58:53 <kc5tja_> :)
14:59:03 <phoniq> agree and agree
14:59:57 <kc5tja_> Maybe I will fool around with the idea myself.  I think it'd be a nice project.  Take ideas from Scons, CMake, the various Make implementations, Project files of various types, etc.
15:00:06 <Saizan> XML is very nice once you use arrows to work with it (HXT ftw)
15:00:34 <yip> XML is not nice to author though :(
15:00:42 <kc5tja_> XML is not nice.  Period.  It's a gratuitous waste of both disk space and bandwidth.
15:01:32 <phoniq> i dunno what you do about MS C++ tools
15:02:02 <phoniq> i think one of the reasons boost.jam is so twisted is it tries to handle unices and MSVC
15:02:32 <phoniq> i spose you decide at the outset that that stuff is out of scope
15:04:16 <kc5tja_> Well, for a project build system to replace make, by definition, it's mutually incompatible with MSVC project files.
15:06:02 <beelsebob_> sorear: was it you that came up with that horrible example of bad monadic programming that produced a list of pairs of integers in ascending order?
15:06:22 <sorear> > ap zip tail [0..]
15:06:24 <lambdabot>  [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12...
15:06:27 <sorear> I think so?
15:06:42 <sorear> anyway, ap may be a monad operator, but it is used as S here
15:07:05 <sorear> schoenfinkel's substituted application operator
15:07:19 <sorear> 60-90 years old, predates monads
15:08:36 <sorear> > map (id &&& succ) [0..]  -- try arrow abuse?
15:08:36 <mauke> man, haskell makes writing interpreters way too easy
15:08:37 <lambdabot>  [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12...
15:08:48 <sorear> mauke: compilers too
15:08:59 <mauke> but I don't know how to write compilers :(
15:09:01 <augustss> just easy enough
15:09:12 <mauke> @type second
15:09:14 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
15:09:21 <augustss> if you can write an interpreter, you can write a compiler
15:09:30 <sorear> writing optimizing compilers is VERY easy
15:09:34 <mauke> > map (second succ) [0..]
15:09:36 <lambdabot>   add an instance declaration for (Num (d, b))
15:09:36 <lambdabot>     In the expression: 0
15:09:41 <sorear> you simply translate into haskell and invoke ghc -O@
15:09:49 <mauke> haha
15:09:59 <sorear> even unlambda falls to that
15:10:04 <augustss> except that ghc isn't really good enough
15:10:05 <beelsebob_> thanks sorear
15:10:06 <mauke> augustss: how?
15:10:24 <sorear> augustss: ocamlopt is no better -I have numbers
15:10:30 <beelsebob_> sorry, I disappeared momentarily, had a minor panic about ICFP submission
15:10:56 <augustss> sorear: ghc sucks at loop optimizations, and index optimizations
15:11:01 <sorear> augustss: and 22x faster than an optimized C interpreter is "good enough" in my book ;)
15:11:19 <sorear> oh yeah.
15:11:41 <xerox> > fix $ ((0,1) :) . map (join (***) (+1))
15:11:42 <sorear> but since there are no integers in unlambda ...
15:11:42 <lambdabot>  [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12...
15:11:58 <edwinb> beelsebob_: my minor panic about ICFP submission was 2 weeks ago. That was when I realised it was impossible ;)
15:12:06 <beelsebob_> lol
15:12:17 <augustss> mauke: well, in an interpreter you execute the code.  just imagine that instead of executing you generate some form of instructions so you can execute them later
15:12:21 <beelsebob_> edwinb: we realised at 2256 that one of our examples was wrong
15:12:28 <edwinb> eek
15:12:37 <edwinb> did you fix it in time?
15:12:38 <beelsebob_> luckily it still showed the right things when corrected
15:12:42 <sorear> the deadline was 2300?
15:12:42 <edwinb> ah good
15:12:45 <beelsebob_> yeh
15:12:52 <beelsebob_> the deadline was 1100 samoan time
15:12:59 <beelsebob_> which I am assured was 2300 our time
15:13:06 <edwinb> it was
15:13:14 <mauke> augustss: ok, so I could compile the program to Haskell
15:13:34 <beelsebob_> I was about to say "we haven't got the confirmation email" but it just popped into my inbox
15:13:36 <beelsebob_> thank god
15:13:37 <sorear> How many people DIDN'T submit papers? ;)
15:14:13 <augustss> mauke: you could
15:14:15 <beelsebob_> what, how many people in this channel?
15:14:21 <beelsebob_> edwinb didn't apparently
15:14:22 <augustss> @users
15:14:22 <lambdabot> Maximum users seen in #haskell: 336, currently: 301 (89.6%), active: 42 (14.0%)
15:14:30 <sorear> Fri Apr  6 10:19:35 PDT 2007  Adrian Hey <ahey@iee.org>
15:14:30 <sorear>   * Moving AVL trees to Data.Tree.AVL sub-dir
15:14:31 <edwinb> @submitted_papers
15:14:32 <lambdabot> Unknown command, try @list
15:14:35 <mauke> augustss: but I don't see how that helps me compile to other forms of code
15:14:38 <edwinb> weird, I thought she knew everything
15:14:46 <sorear> OK, /whois Adrian Hey?
15:14:54 <beelsebob_> rofl
15:15:15 * sorear remembers wildcard who
15:15:16 <procyon112> ?src evalState
15:15:17 <lambdabot> Source not found. My pet ferret can type better than you!
15:15:17 <augustss> mauke: you need to use your imagination :)
15:15:33 <procyon112> @hoogle evalState
15:15:34 <lambdabot> Control.Monad.State.evalState :: State s a -> s -> a
15:15:34 <lambdabot> Control.Monad.State.evalStateT :: Monad m => StateT s m a -> s -> m a
15:15:34 * beelsebob_ giggles at lambdabot 
15:15:45 <sorear> mauke: and it's very easy to think something can't be compiled
15:15:55 <procyon112> ?src Control.Monad.State.evalState
15:15:56 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
15:15:58 <augustss> mauke: but the only easy compiler to get from an interpreter is the one that translates to the language the interpreter the is written in
15:16:03 <joelr1> :t sequence
15:16:06 <lambdabot>     Ambiguous occurrence `sequence'
15:16:06 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
15:16:22 <mauke> augustss: yeah. my interpreter uses a lot of high-level haskell features
15:16:26 <sorear> mauke: until augustss here invented the G-machine, *everyone* believed it was impossible to compile lazy languages
15:16:44 <sorear> (or was it Johnsson?)
15:16:56 <augustss> sorear: don't confuse me with Thomas Johnsson even if we shared an office at the time
15:17:20 <joelr1> :t Control.Monad.sequence
15:17:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
15:17:32 <augustss> but I actually wrote a compiler for a functional language to VAX assembly before the G machine
15:17:39 <mauke> what's so hard about compiling lazy languages?
15:17:58 <sorear> augustss: OK, there was the 1984 and 1987 bib refs in IFPL, and I couldn't remember who wrote which
15:18:07 <augustss> mauke: it was all in peoples minds, really
15:18:31 <sorear> mauke: extremely dynamic control flow leading to mental block
15:19:03 <augustss> yeah, it takes a little getting used to
15:19:45 <augustss> when we wrote the LML compiler there were no pure lazy functional languages that could be used for anything serious
15:19:47 <mauke> I dream of writing a brainfuck compiler one day
15:19:53 <icarroll> Where can I find an implementation of the Miller-Rabin primality test in Haskell?
15:20:01 <sorear> Meanwhile, as a relatively young person I'm going "What was Augustsson *thinking*?  Who compiles anything directly to assembly!"
15:20:25 <sorear> Oh, how nice it is we can give gcc most of the hard work.
15:20:40 <edwinb> If you see augustss's IOCCC entries, you learn not to question what he's thinking...
15:20:46 <augustss> sorear: compiling to assembly is the only way to go.  even simon&simon has finally realized that
15:21:04 <joelr1> augustss: why?
15:21:06 <augustss> edwinb: you learn to question if i'm thinking at all
15:21:08 <int-e> augustss: then what is cmm about?
15:21:08 <sorear> then why is he on the c-- committee ;)
15:21:11 <joelr1> hi lennart
15:21:12 <edwinb> heh
15:21:34 <int-e> joelr1: C provides too few guarantees and ironically, too little control over things like the stack.
15:21:39 <emu> lambdabot: the ultimate couch potato
15:21:40 <augustss> joelr1: something like cmm would be fine.  but today there's no other alternative, imo
15:21:44 <emu> whoops
15:21:49 <joelr1> @where commaSep
15:21:50 <lambdabot> I know nothing about commasep.
15:21:53 <augustss> translating to C just ties your hands far too much
15:22:09 <joelr1> interesting
15:22:56 <augustss> translating to C is fine for languages related to C.  but it's stops you from using the CPU in innovative ways
15:23:00 <edwinb> Hmm, I haven't looked at how cmm is coming along for a while
15:23:03 <int-e> really, whenever you try to do anything mildly fancy it'll probably work but the standard will flag is as undefined behaviour. one particularily bad example is taking two pointers and comparing them.
15:23:33 <augustss> like in the nu-G machine we used the stack point to point in the heap.  (because x86 has so few registers)
15:24:07 <augustss> s/point/pointer/
15:24:14 <joelr1> what's a shortcut for this? do { xs <- commaSep1 identifier; return $ map VarIdent xs }
15:24:25 <joelr1> @undo do { xs <- commaSep1 identifier; return $ map VarIdent xs }
15:24:25 <lambdabot> commaSep1 identifier >>= \ xs -> return $ map VarIdent xs
15:24:31 <sorear> map VarIdent $ commaSep1 identifier
15:25:02 <joelr1> sorear: where's the do?
15:25:07 <meester> :)
15:25:13 <int-e> @. pl undo do { xs <- commaSep1 identifier; return $ map VarIdent xs }
15:25:13 <lambdabot> map VarIdent `fmap` commaSep1 identifier
15:25:29 <joelr1> int-e: awesome!
15:25:29 <augustss> that looks better
15:25:29 <sorear> joelr1: unneeded
15:25:41 <joelr1> int-e: what's .pl?
15:25:44 <icarroll> Anyone know where to find Miller-Rabin in Haskell?
15:25:48 <sorear> @help .
15:25:49 <lambdabot> . <cmd1> <cmd2> [args].
15:25:49 <lambdabot> . [or compose] is the composition of two plugins
15:25:49 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
15:25:55 <sorear> @help pl
15:25:55 <lambdabot> pointless <expr>. Play with pointfree code.
15:25:58 <augustss> icarroll: perhaps you should write one
15:26:00 <sorear> @help undo
15:26:01 <lambdabot> undo <expr>
15:26:01 <lambdabot> Translate do notation to Monad operators.
15:26:03 <joelr1> aha
15:26:47 <icarroll> augustss: I'm working on it, but the descriptions of the algorithm and the provided code aren't very clear.
15:27:54 <augustss> icarroll: i know what you mean.  i wish more people would use high level languages to describe algorithms
15:28:07 <hpaste>  dmead pasted "FOL representation" at http://hpaste.org/1289
15:28:47 <icarroll> augustss: yeah, in the Wikipedia article,the description of the algorithm and the provided Ruby code aren't very similar, so I'm having trouble figuring out where my code is going wrong.
15:28:57 <sjanssen> icarroll: I've written Miller-Rabin before.  The CLR algorithms book has a pretty good description
15:29:09 <icarroll> sjanssen: thanks, I'll take a look
15:29:54 <eumenides> does anyone know what's wrong now? http://img480.imageshack.us/img480/73/200704070023221024x768swg4.png
15:29:56 <lambdabot> http://tinyurl.com/ypev3a
15:30:51 <dmead> yes
15:30:56 <dmead> you don't seem to have a  window manager
15:30:58 <dmead> :P
15:31:06 <Cale> Clearly he has a window manager
15:31:11 <sjanssen> dmead: it's xmonad!
15:31:14 <dmead> oh
15:31:15 <dmead> :P
15:31:16 <sjanssen> (I think)
15:31:24 <yip> i read about xmonad on reddit
15:31:37 <Cale> Or else something like ratpoison or larswm
15:32:36 <sjanssen> Cale: the slightly broken active window border is a pretty sure sign it's xmonad from about 3 days ago ;)
15:33:22 <eumenides> hello? yi errors? :(
15:33:38 <Cale> eumenides: I'm not sure, but dons is the one you need to talk to.
15:33:52 <yip> sjanssen: does xmonad have the same philosophy as dwm?
15:33:52 <sjanssen> jyp, more likely
15:33:54 <yip> "Because dwm is customized through editing its source code, it's pointless to make binary packages of it. This keeps its userbase small and elitist. No novices asking stupid questions."
15:33:55 <sjanssen> @seen jyp
15:33:55 <lambdabot> I saw jyp leaving #haskell and #oasis 55m 46s ago, and .
15:34:24 <sjanssen> yip: similar, but perhaps slightly less pretentious
15:34:48 <yip> sjanssen: ok. btw haskell itself seems to have the same philosophy :P
15:35:04 <dmead> so we
15:35:13 <dmead> so we're against diversity in computing now?
15:36:10 <sjanssen> yip: I don't hate newbies or anything, but xmonad is for a specific type of user, and that's probably not going to change
15:37:55 <sorear> So many people have this '/RET problem
15:38:15 * sorear has changed his emacs keybindigns, and does not suffer from it :)
15:38:36 <yip> btw, did anyone else see that comment on reddit about Gerald Sussman: "He looks like George Constanza except he's smarter."
15:38:56 <augustss> lol
15:38:57 * sorear doesn't do reddit
15:39:35 <yip> well now is the time to register, if only to mod that comment up
15:41:11 <augustss> i just did
15:41:52 <mauke> re: IOCCC, what do you think about http://90.128.44.217/stuff/c/ifalse.c ?
15:41:59 <mauke> is it obfuscated enough?
15:44:02 <dmead> :o
15:47:17 <yip> is it good and fast to use ByteString as a key in Data.Map?
15:47:39 <sjanssen> depends on the length of the keys
15:47:51 <Heffalump> how good is the Ord instance?
15:47:52 <mr_tenor> mauke: if you dun gcc -E and then indent on it, it looks like regular C with single letter variable names at first glance... is the algorithm cool? :)
15:47:55 <sjanssen> remember comparison of strings is O(min m n)
15:47:56 <augustss> mauke: it's obfuscated, but these days you seem to also have to do something amazing
15:47:59 <yip> sjanssen: 20 bytes
15:48:15 <mauke> mr_tenor: try figuring out what it does :-)
15:48:26 <mr_tenor> wow. you're good ;)
15:48:37 <mr_tenor> (sorry, thought it was one of yours)
15:48:42 <yip> sjanssen: would ByteString key be a lot faster then String key?
15:48:46 <mauke> er, what?
15:48:51 <sjanssen> yip: much much faster
15:49:08 <mauke> too many pronouns. please dereference and try again.
15:49:15 <mr_tenor> mauke: nm. misparsed your reply - i just got up
15:49:32 <yip> sjanssen: does ByteString comparison use memcmp?
15:50:21 <Heffalump> oh, mr_tenor had the same idea I did :-)
15:50:24 <sjanssen> yip: last time I checked
15:50:57 <sorear> yip: no
15:51:05 <mauke> running gcc -E first is important. most indenters choke on sw\ itch :-)
15:51:15 <mr_tenor> yah :)
15:51:15 <Heffalump> is there any actual point to the use of index[array], beyond a minor extra piece of obfuscation?
15:51:21 <sorear> yip: bytestrings  are MUCH slower than strings at that length?
15:51:43 <mauke> Heffalump: no
15:52:18 <mauke> 1[1[i]] just looks cute
15:52:24 <sjanssen> sorear: do you have something quantitative to support that claim?
15:52:27 <sorear> http://www.cse.unsw.edu.au/~dons/tmp/A.hs -- bytestrings are 2x slower than strings
15:52:29 <mr_tenor> yeah, cute ;)
15:52:33 <sorear> sjanssen: yes!
15:52:57 <sjanssen> oh right, we just talked about this a week ago
15:52:58 <sjanssen> :(
15:53:02 <fuzan> salut!
15:53:13 <sjanssen> it's *because* ByteString uses memcmp that it's slower
15:53:14 <yip> sorear: :O
15:53:52 <sorear> dons was as amazed as you are, when he first showed me several months ago
15:54:04 <sorear> not long after the rdtsc release iirc
15:54:17 <yip> is rdtsc really an accurate time measurement?
15:54:20 <sjanssen> sorear: what's sad is that I already knew this but forgot already
15:55:02 <kc5tja_> yip: It's the most accurate measurement of time available on the PC platform.
15:55:16 <sorear> yip: yes, more accurate than gettimeofday, because measures CPU time not motherboard time, there can be a difference because CPUU clocks are unstable
15:55:18 <kc5tja_> yip: It ticks once for every microprocessor clock cycle.
15:55:38 <sorear> rdtsc is better precisely because the processor clock is less stable
15:56:18 <sorear> if the processor runs 1% faster momentarily, it will skew gettimeofday measurements, but the error will cancel out for rdtsc
15:57:58 <yip> if the strings would be longer, then bytestring would be faster?
15:58:14 <sorear> much much much faster for long strings
15:58:18 <sjanssen> yes, the FFI overhead is just a constant
15:58:24 <sorear> dons has bulk benchmarks of >>20x
15:59:18 <sorear> isn't it amusing how dons makes links from the fps homepage to favorable benchmarks, but forces you to remember the URL of unfavorable ones?
15:59:23 <sorear> :)
15:59:30 <yip> can i accurately predict rdtsc by looking at the assembly output and counting instructions?
15:59:47 <sorear> yes, but
16:00:01 <kc5tja_> yip: No.  You can get ballpark, but that's it.  The reason is that instructions can take varying cycles due to cache misses.
16:00:04 <sorear> the timing of instructions is extremely complicated
16:00:20 <kc5tja_> (and also pipeline interlocks too)
16:00:22 <yip> what about OS scheduling?
16:00:25 <kc5tja_> (forgot about those)
16:00:27 <sorear> you'll probably need intel security clearance to get the needed docs
16:00:44 <sorear> yip: that will cause a HUGE effect on the rdtsc times
16:00:59 <sorear> HUGE enough that you can reliably filter out the bad measurements
16:01:19 <sjanssen> you need operating system support to get really accurate numbers
16:01:32 <sorear> What I would like is if Haskell had something like CODE words.
16:01:50 <sorear> foreign import literalcmm ...  maybe
16:02:12 <kc5tja_> One of the tips that Michael Abrash recommended with regards to rdtsc is to use an external timer source (e.g., the PIT interrupt, for example), run your code in as tight a loop as possible, then take the time it took to run however many iterations of the loop to figure out the amortized time cost of the body of the loop.
16:02:37 <yip> does the ghc profiler use rdtsc?
16:02:39 <kc5tja_> (so, if you have 1000 instructions in a loop, and it takes 10 microseconds, you can be reasonably assured that instructions are being executed at a rate of 1 per 10 nanoseconds).
16:02:45 <sorear> yip: no
16:02:52 <yip> sorear: gettimeofday?
16:03:14 <sorear> yip: settimer probably, it might hook into the schedular
16:03:25 <sorear> yip: the ghc profiler doesn't work by measuring time
16:03:32 <sorear> that would create overhead
16:03:39 <sorear> skewing overhead
16:04:08 <sorear> instead it forces an asynch exn 1000 times per second, and analyses the stack
16:04:25 <sorear> that's slower and less accurate, but (theoretically) fair
16:04:49 <yip> interesting. has the rdtsc module been tested on SMP?
16:04:54 <sorear> I say theoretically because the annotations used to associate an insn with a line of code clog the simplifier
16:05:24 <sorear> yip: nothing to test.  cpu clocks are independant, so you'll get detectably bogus results if your process migrates
16:05:40 <sorear> ht I'm not sure of
16:16:38 <mauke> @hoogle compa
16:16:39 <lambdabot> Prelude.compare :: Ord a => a -> a -> Ordering
16:16:39 <lambdabot> Text.Html.compact :: HtmlAttr
16:16:39 <lambdabot> System.Win32.Mem.c_HeapCompact :: HANDLE -> HeapAllocFlags -> IO UINT
16:19:07 <mauke> wasn't there some helper function for comparing selected fields?
16:19:45 <sorear> :t comparing
16:19:48 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
16:19:49 <sorear> hoogle is old
16:19:54 <sorear> @hoogle+
16:19:55 <lambdabot> System.Win32.Mem.gMEM_NOCOMPACT :: GlobalAllocFlags
16:19:56 <lambdabot> System.Win32.Mem.heapCompact :: HANDLE -> HeapAllocFlags -> IO UINT
16:19:56 <lambdabot> Text.ParserCombinators.Parsec.Error.messageCompare :: Message -> Message -> Ordering
16:19:58 <sorear> @hoogle+
16:20:12 <mauke> @index comparing
16:20:13 <lambdabot> bzzt
16:20:23 <lambdabot> Data.Ord
16:21:24 * sorear wonders if dons will be up and cheerful in an hour like he usually is
16:22:10 <sjanssen> sorear: doesn't seem likely
16:22:20 <sjanssen> @localtime dons
16:22:23 <lambdabot> Local time for dons is Sat Apr  7 09:20:52 2007
16:22:45 <dons> moin
16:22:52 <dylan> hmm...
16:23:02 <kc5tja_> SHHHH!!!  Stop talking about him -- he's awake!
16:23:04 <kc5tja_> I mean
16:23:05 <kc5tja_> *COUGH!*
16:23:08 <kc5tja_> 'Mornin.
16:23:09 <dylan> % ghci
16:23:09 <dylan> ghc-6.6: not built for interactive use
16:23:16 <dylan> ^ on debian-ppc...
16:23:21 <sorear> dylan: right.
16:23:32 <sorear> dylan: ghci stilldoesn't support ppc
16:23:42 <dylan> aw feck.
16:23:42 <sorear> don't know if it ever did...
16:23:45 <LPhas> sorear: ??
16:23:57 <dylan> ghci works on mac-ppc...
16:23:59 <cjay> ??
16:24:10 <dylan> at least, I seem to remember it working...
16:24:14 <cjay> works for me on gentoo linux/ppc
16:24:20 <sorear> dylan: ok.  Couldn't remember if it was all ppc or just ppc-linux
16:24:38 <kc5tja_> Based on cjay's input, it's a Debian thing.
16:25:37 <LPhas> cjay: try to download and install from ghc site
16:25:41 <LPhas> @where ghc
16:25:41 <lambdabot> http://haskell.org/ghc
16:25:59 <dylan> so, how does one run Setup.lhs without runhaskell?
16:26:12 <cjay> LPhas: why?
16:26:36 <Saizan> you can compile it
16:26:41 <LPhas> dylan: ghc --make Setup.lhs -o setup $$ setup ...
16:26:42 <kc5tja_> 16:22 < cjay> works for me on gentoo linux/ppc
16:26:47 <kc5tja_> He already compiled it.
16:26:56 <kc5tja_> 16:21 < dylan> ghc-6.6: not built for interactive use
16:26:56 <kc5tja_> 16:21 < dylan> ^ on debian-ppc...
16:27:01 <kc5tja_> HE's the one having the problems.  :)
16:27:18 <LPhas> cjay: but you compiled it or it's the debian-packaged one?
16:27:35 <cjay> LPhas: gentoo compiled it and it works
16:28:04 <LPhas> cjay: oh damn, i took you for dylan
16:28:08 <LPhas> :P
16:28:20 <cjay> :>
16:28:38 <LPhas> time to go to sleep :|
16:28:45 <cjay> ack
16:28:51 <dmwit> syn-ack
16:30:55 <kc5tja_> protocol error.
16:31:24 <dmwit> Ah, I got it backwards. =(
16:34:09 <dylan> /usr/bin/ld: cannot find -lHSrts_thr
16:34:22 <dylan> fascinating.
16:34:38 <dylan> I don't have a threaded rts?
16:34:48 <Lemmih> -l-lHSrts_thr?
16:35:14 <dylan> this works perfectly well in x86 land, I should mention
16:35:37 <Igloo> You don't have one, as it was randomly failing tests
16:36:01 <dylan> okay, so maybe I should re-evaluate my distro choice for this laptop.
16:37:18 * zbrown notes that Ubuntu Feisty Fawn 7.04 Beta is _amazing_
16:37:31 <zbrown> dylan: if you need a distro to try, try ubuntu 7.04 :)
16:38:16 <joelr1> zbrown: why not edgy?
16:38:24 <joelr1> zbrown: what's the big difference?
16:38:54 <zbrown> joelr1: ummm the built-in restricted module usage, you don't have to go hunt for binary drivers, there's a tool that will enable most of them (display drivers have to be explicitly enabled)
16:39:19 <zbrown> Also, some of the added tools have been better refined
16:39:31 <zbrown> 6.10 was good, but not as good as this release
16:39:34 <dylan> zbrown: ubuntu is dropping PPC
16:39:58 <zbrown> dylan: oh? i recall hearing that, wha'ter you using now?
16:40:08 <dylan> zbrown: debian.
16:40:18 <dylan> pretty much it is debian or gentoo for PPC hardware.
16:40:32 <dylan> also ubuntu has a lot of stuff by default I don't need.
16:40:33 <zbrown> dylan: ah, i prefer YDL
16:40:49 <dylan> I like having a decent package manager.
16:41:09 <zbrown> dylan: heh, then its down to debian overall because i don't consider gentoo to have one lol
16:41:10 <LPhas> on x86, arch linux worth a try
16:41:23 <dylan> but this isn't x86
16:41:25 <zbrown> ya, arch is nice, i use it on my deskto
16:41:36 <LPhas> i use on my server
16:41:41 <zbrown> dylan: so why linux over osx for your ppc?
16:41:44 <zbrown> out of curiosity
16:41:54 <dylan> I use arch on my TV computer, debian on most everything else, and gentoo on my dual core AMD box
16:42:08 <dylan> zbrown: speed and a decent package manager
16:42:13 <zbrown> oic
16:42:15 <LPhas> zbrown: because you can do aptitude install gobby instead of compiling messy things for ours
16:42:17 <zbrown> good reasons
16:42:32 <dylan> the problem with OSX is it has 2-3 somewhat OK package managers...
16:43:04 <zbrown> I dunno, I've always just worked on macs, but mostly within the constraints of xcode
16:43:20 <zbrown> i use ubuntu on this laptop because i'm too lazy to setup debian properly
16:43:26 <LPhas> dylan: if you know about a decent BINARY package manager for osx, you save me from buy a now HD for install linux and osx on my mac
16:43:41 <xpika> whats wrong with compiling from source?
16:43:49 <LPhas> time
16:43:53 <zbrown> xpika: some ppl are lazy lol?
16:45:07 * ddarius is looking at a bulletproof armor plate that says, "HANDLE WITH CARE"
16:45:17 <LPhas> it's not lazyness, i mean, with gentoo you type "emerge gobby" like "apt blah blah" on debian
16:45:36 <LPhas> it's only that if i need gobby, i need gobby NOW, not in one hour
16:45:44 <mr_tenor> dependency management
16:47:27 <kc5tja_> This is why C should never have become popular.  Compiling C takes forever.  Forth...now THERE'S a language with instantaneous compile times.  ;D  (And I'm not kidding either; Forth is rediculously fast to compile; the tradeoff is usually poorer code though.)
16:47:36 <kc5tja_> (but who's caring?  ;) )
16:47:49 <zbrown> kc5tja_: eh just let the processor make up for it ;)
16:48:37 <cjay> kc5tja_: there are really fast C compilers
16:48:41 <titus_> LPhas: I know what you mean, I am currently engaged on a big yak shaving mission to build yi on ubuntu, whose ghc packages are old
16:48:46 <kc5tja_> Well, modern forth systems do produce very efficient code (at least on x86 machines; it rivals optimized C code).  But it pulls a lot of dirty tricks to do it -- just like C code has to pull similar tricks.  The difference is, Forth gets by without having to read in huge quantities of source files every time.
16:48:57 <kc5tja_> cjay: I know, I was being facetious.
16:48:59 <zbrown> titus_: which version of ubuntu?
16:49:09 <titus_> zbrown: edgy
16:49:21 <kc5tja_> However, said fast C compilers tend not to produce as good a code as the more thorough compilers.  Ditto for Forth.
16:49:25 <zbrown> titus_: ah ok, ya feisty has 6.6
16:49:57 <titus_> takes a while to build that ghc ... :-)
16:50:00 <LPhas> titus_: building a few ghc packages is ok
16:50:06 <cjay> kc5tja_: is it really a language thing?
16:50:18 <zbrown> titus_: took about one hour on my laptop (core duo)
16:50:31 <LPhas> titus_: i started build things for gobby on osx, well, 4 hours ago
16:50:33 <cjay> we all know that gcc sucks ;)
16:50:34 <kc5tja_> cjay: What do you mean by "it"?
16:51:21 <cjay> kc5tja_: the speed difference
16:51:45 <kc5tja_> Forth lacks a linking phase; it goes from raw source to raw executable (linking occurs by including chunks of source).  It also lacks a parser (it's all lexer; using RPN allows this).  So, yeah, Forth definitely can compile much faster than C.
16:51:48 <ddarius> cjay: Yes and no, in most cases.
16:52:17 <kc5tja_> It also doesn't include files thousands of times over, which helps out a lot too.
16:52:32 <cjay> I see
16:52:57 <kc5tja_> The biggest problem with C, as far as compile speeds are concerned, is the repeated inclusion of header files.
16:53:16 <yip> that's why we have precompiled headers :)
16:53:26 <kc5tja_> It'd be made much faster if people put their #ifndef SYMBOL_H/#endif pairs around the #include itself instead of inside it.
16:53:56 <yip> master c programmers advise against using that trick at all
16:53:56 <zbrown> kc5tja_: ya i was going to say, i do that
16:54:01 <kc5tja_> yip: Who do you mean by 'we', white man?  GCC doesn't use precompiled headers, as far as I know.  I know Turbo C/C++ used them.
16:54:16 <yip> GCC has had support for precompiled headers for quite a while now
16:54:25 <yip> pch are much more important in c++ then they are in c
16:54:41 <kc5tja_> (for those who are easily offended, the 'white man' reference refers to the joke involving Lone Ranger and Tanto riding into some kind of battle.)
16:54:58 <mr_tenor> kc5tja_ : that sounds dangerous
16:55:31 <titus_> kc5tja: Blazing Saddles?
16:55:53 <kc5tja_> yip: They take the same amount of time to parse in C++ and C.  They'd have equal effect.
16:56:01 <kc5tja_> titus_: As far as I know the joke predates the movie.
16:57:09 <dons> night all!
16:57:18 <xpika> ?
16:57:24 <xpika> its 9.45 am
16:57:27 <sorear> kc5tja_: read the gnu cpp manual
16:57:51 <sorear> kc5tja_: if it detects a #ifndef/#endif pair, it marks the header as "do not reread" in its tables
16:57:53 <dmwit> ?localtime dons
16:57:55 <lambdabot> Local time for dons is Sat Apr  7 09:56:26 2007
16:57:58 <mr_tenor> is dons logged in remotely from overseas or something?
16:58:01 <mux> instance Monoid (a -> a) where mempty      = id mappend f g = f . g
16:58:03 <sorear> mega-yucky and fragile, but not slow
16:58:06 <mux> why isn't this valid?
16:58:09 <dmwit> Maybe he was just up all night.
16:58:24 <xpika> thats my theory
16:58:28 <sorear> mux: instances must be of the form (T a b c ...) where the type variables are *distinct*
16:58:36 <sorear> a and a aren't distinct
16:58:49 <sorear> (a -> a) is syntax sugar for (->) a a
16:59:02 <mux> yes I've read that distinct, but I don't get it - it seems to me the instance should be of the form 'Monoid x'
16:59:26 <sorear> you think ((->) a a) matches (T a b)?!
16:59:46 <sorear> or are you saying you can't figure out why there is a restriction?
17:00:01 <mux> no, I don't get why I should match (T a b c) ?
17:00:16 <sorear> I think the restriction is perfectly understandable, even if its motivations are obscure.
17:00:31 <sorear> what do you mean 'why I should match'
17:00:36 <mux> well I want to know the motivates, otherwise I can't say I understand it
17:00:42 <mux> motivation, rather
17:00:59 * sorear would like to hear one good explanation of why that error is confusing.  So would SPJ.
17:01:43 <kc5tja_> sorear: I prefer a proper module system instead.
17:01:46 <Igloo> It's tweaked a bit to try to be clearer now
17:01:47 <mux> I'm not saying the error message is confusing, I had badly read it as first but that's not the point
17:01:54 <mux> I want to know *why* there is this restriction
17:02:07 <kc5tja_> sorear: I note also that gcc *still* has to open and close those files to detect whether or not it has to reread the file.
17:02:14 <sorear> mux: the motivation is that the type checker is turing complete, so we have to put pretty heavy restrictions to stop you from accidentally writing a crashing type level program, since that would crash the compiler (and be impossible to debug).
17:02:20 <LoganCapaldo> "What restriction?", he asked
17:02:56 <mux> sorear: are you saying that if it was allowed to write what I wrote, it would make the type checking undecidable or something?
17:03:12 <sorear> mux: no, the restrictions are very conservative
17:03:38 <sorear> what you wrote is allowed with {-# LANGUAGE FlexibleInstances #-}
17:03:46 <sorear> but that won't work on hbc, nhc, or yhc
17:03:54 <mux> ah, good
17:04:07 <mux> that makes more sense to me
17:04:08 <sorear> only hugs and ghc support the newer extensions
17:04:13 <yip> am i doing something wrong if i am doing a fold with >>=?
17:04:14 <sorear> only ghc supports the newest
17:04:22 <sorear> yip: not at all
17:04:25 <mux> what I couldn't get is why this wouldn't be possible while it looked prefectly reasonable
17:04:35 <mux> it turns out it is perfectly possible
17:04:40 <mux> though not with Haskell98
17:05:26 <sorear> > map length $ group $ sort $ foldr (=<<) [0] $ replicate 10 (id&&&succ)
17:05:28 <lambdabot>  Couldn't match expected type `[a]' against inferred type `(a, a)'
17:05:42 <sorear> > map length $ group $ sort $ foldr (=<<) [0] $ replicate 10 (\x->[x,x+1])
17:05:44 <lambdabot>  [1,10,45,120,210,252,210,120,45,10,1]
17:06:02 <ddarius> @src foldM
17:06:03 <lambdabot> foldM _ a []     = return a
17:06:03 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
17:06:32 <dmwit> Hmmm, numlock seems to kill all of xmonad's keyboard shortcuts.
17:06:32 <sorear> actually I believe there is a fold with =<< in the lambdabot source (run output filters, bottom of Lambdabot.hs)
17:06:44 <mux> hmm, can I hide specific instances of a module?
17:06:48 <sorear> no
17:06:58 <sorear> instances are uncontrollable
17:12:40 <ddarius> sorear: They are teenaged.
17:17:53 <yip> is there something like foldM that will stop in the middle if a certain condition is met? i have [IORef Int] and i want to test if any are equal to zero
17:18:24 <sorear> yeah, foldM
17:19:25 <yip> won't that always cause readIORef to be performed on every element of the list?
17:19:41 <ddarius> MaybeT IO
17:20:04 <sorear> not necessarily, you need a way out but that can be arranged in ways other than modifyign the fold
17:20:19 <ddarius> e.g. throwing an IO exception.
17:20:29 <sorear> or using ErrorT
17:20:49 <yip> hm... not sure those will work. i'm actually in STM, not IO
17:21:02 <sorear> oh, they'll still work
17:21:13 <sorear> they are transformers and will work anywhere
17:21:32 <sorear> there's even catchSTM, though I forget its location
17:21:46 <yip> seems really ugly
17:22:10 <sorear> you could just write anyM once and for all ;)
17:22:31 <yip> yeah i was looking for an anyM :)
17:23:56 <mauke> rebuildValM f x [] = liftM (join (,)) . f $ x
17:24:01 <mauke> is that still readable?
17:25:18 <LoganCapaldo> mauke: readbale for who? I see a . and a , and a dolalr and a... :)
17:25:29 <mauke> can you see what it does? :-)
17:26:17 <LoganCapaldo> return (f x, f x) ?
17:26:25 <LoganCapaldo> err
17:26:38 <LoganCapaldo> >>= \x -> return (f x, f x)
17:26:59 <LoganCapaldo> I think
17:27:06 <mauke> f x >>= \y -> return (y, y)
17:27:58 <LoganCapaldo> I was close!
17:28:04 <LoganCapaldo> Do I still get second place? :)
17:32:16 <mauke> why is Data.Sequence so awesome? :-)
17:32:35 <sorear> Data.FingerTree is awesomer
17:33:30 <LoganCapaldo> Data.HandTree ftw
17:33:50 <mauke> hmm, update is not awesome enough
17:34:08 <sorear> ?
17:35:14 <mauke> I need it to extend the sequence when updating a non-existent element
17:35:18 <Botje> @pl \x y -> y
17:35:19 <lambdabot> const id
17:35:28 <Botje> heh :)
17:35:56 <Cale> mauke: just split the sequence at the appropriate point and add it on one end of one of the sequences, then concatenate
17:36:47 <mauke> doesn't work
17:36:47 <Cale> That'll still be O(log(min(i,n-i)))
17:36:58 <mauke> the position of the new element will be wrong
17:37:16 <Cale> oh -- you mean if you try to update off the end?
17:37:43 <Cale> Well, that's entirely different -- you'll need to pick some element to insert in all the spaces up to that point.
17:37:46 <sorear> mauke: what are you trying to do?
17:38:03 <mauke> yeah
17:38:17 <mauke> sorear: working on my C/C++ interpreter
17:38:19 <sorear> Cale: replicate can be implemented in logtime too ;) too bad it's not in the lib IIRC
17:38:37 <sorear> mauke: so you want to extend the heap on sbrk?
17:39:06 <mauke> er, what?
17:39:35 <Cale> sorear: at least enough primitives are implemented to allow for that
17:39:54 <sorear> mauke: last I checked C arrays crashed on access past the end.  they don't need to grow.
17:40:01 <mauke> this isn't C
17:40:09 <Cale> It's C/C++
17:40:10 <mauke> I'm talking about code like [ : x 42 "hi"
17:40:16 <Cale> which is an entirely different language :)
17:40:33 <sorear> I thought it was a disjunction :)
17:40:52 <sorear> [ : is a syntax error iirc
17:41:05 <mauke> not in C/C++
17:41:18 <sorear> what IS C/C++ ?
17:41:53 <mauke> http://www.cpax.org.uk/prg/portable/c/c++/rfe00000.html
17:41:53 <Cale> It's a language explicitly designed to confuse those who conflate C and C++
17:41:54 <lambdabot> Title: C/C++ Request For Enlightenment 0 - Design Philosophy
17:48:45 <robreim> "The C/C++ programming language is designed to be a complete replacement for the C and C++ programming languages. It addresses all of the problems inherent in those languages, whilst introducing a few of its own." Wow... ALL the problems of those languages. I'm impressed.
17:50:26 <RyanT5000> lol
17:50:30 <RyanT5000> addresses
17:50:35 <RyanT5000> *problems
17:50:38 <RyanT5000> ;)
17:50:50 <RyanT5000> i doubt it *corrects* them all
17:50:50 <jyasskin> "addresses", not "fixes". :)
17:51:14 <RyanT5000> (though i agree they probably *meant* "corrects")
17:51:33 <robreim> Oh I see... that C/C++ page is satirical...
17:52:02 <RyanT5000> ah, good
17:54:44 <dino-> perl -le 'print "hi" x 42'
17:56:05 <dino-> Where is perlbot when I need her?
17:56:27 <mauke> ghc -e 'putStrLn . concat . replicate 42 $ "hi"'
17:57:23 <ddarius>  > runPugs "print \"hi\" x 42"
18:10:19 <RyanT5000> is newtype free at runtime?
18:12:09 <ddarius> Yes.
18:12:41 <RyanT5000> good, that's what i thought
18:12:57 <xpika> >
18:13:01 <xpika> >  concat . replicate 42 $ "hi "
18:13:03 <lambdabot>  "hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi ...
18:15:57 <dino-> > concat . take 42 $ repeat "hi "
18:15:59 <lambdabot>  "hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi ...
18:16:16 <Ulfalizer> repeat "hi "
18:16:22 <Ulfalizer> > repeat "hi "
18:16:23 <lambdabot>  ["hi ","hi ","hi ","hi ","hi ","hi ","hi ","hi ","hi ","hi ","hi ","hi ","hi...
18:16:25 <mauke> > join . intersperse " " . replicate 42 $ "hi"
18:16:27 <lambdabot>  "hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi ...
18:17:07 * xpika thinks rest is superfluos
18:18:30 <dino-> ya, replicate is implemented in terms of take and repeat.
18:21:22 <xpika> i write shell all my shell scripts in haskell
18:21:35 <xpika> except for simple alias things
18:23:35 <xpika> haskell > ( shell && bash && perl && sed )
18:24:17 <chessguy> hi all
18:24:26 <xpika> chessguy: yo
18:24:48 <chessguy> what's the happs around here tonight
18:24:53 <xpika> is anyone here doing the summer of code for haskell?
18:25:37 <xpika> chessguy: mainly ppl ranting about C
18:25:47 <chessguy> ewww
18:26:46 <xpika> among other things of course
18:27:08 <jyasskin> People are saying 'hi' a lot.
18:29:14 <ddarius> > cycle "hi "
18:29:16 <lambdabot>  "hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi ...
18:32:06 <xpika> > take (42*3) . cycle $ "hi "
18:32:08 <lambdabot>  "hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi ...
18:33:23 <xpika> shaved a slight bit off
18:33:40 <xpika> but it was part pre-computed
18:38:08 <chessguy> > 42 * 3
18:38:10 <lambdabot>  126
18:38:59 <chessguy> > take (120) $ cycle $ "hi "
18:39:01 <lambdabot>  "hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi ...
18:40:11 <Lemmih> > take (24*3) $ cycle $ "hi "
18:40:12 <lambdabot>  "hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi "
18:42:13 <foxy-om> Lemmih, are you a Cabal maintainer?
18:44:28 <sorear> hi!
18:44:42 <Lemmih> foxy-om: Kinda.
18:44:54 <ddarius> @oldwiki SillySignatures
18:44:54 <lambdabot> http://www.haskell.org/hawiki/SillySignatures
18:46:05 <sorear> Lemmih: jyp admitted a ~8 hours ago that he uses Makefiles instead of Cabal for a large pure-haskell program
18:47:35 <foxy-om> Lemmih: Well, I'm having trouble getting Cabal to work nicely with c2hs.  1) I have to pass a buildinfo flag to tell c2hs where to find a foo.chi file referenced from bar.chi and 2) when ghc is compiling a generated bar.hs I get "src\\Matlab\\MatMatrix.chs:22:7: file name does not match module name `MatMatrix'"
18:51:03 <Lemmih> foxy-om: I thought it was supposed to Just Work.
18:51:45 <foxy-om> So did I, but apparently it doesn't :(
18:52:32 <Lemmih> I'd poke Duncan. He knows a lot more about c2hs than I.
18:52:37 <foxy-om> ok
18:54:06 <sorear> Can anyone think of a good benchmarky program or algorithm that uses a lot of small strings?  (Preferably pretty small; I know GHC satisfies my other conditions but it Just Won't Do.)
18:54:48 <liquidengineer> Evening
18:55:16 <sorear> hi!
18:56:23 <Lemmih> Perhaps a supercollider emulator based on string theory? It should have lots of very small strings.
18:56:36 * ddarius wonders what 's := "*"; every !s := "**"' results in in Icon.
18:58:24 * sorear checks nobench
19:10:47 <liquidengineer> May I ask an off topic question?
19:11:01 <liquidengineer> I tried asking in the channels where it would be on topic, but everyone seems alsleep
19:12:32 <sjanssen> just ask
19:14:04 <kc5tja_> Well, I've been at work all day, and quite busy with my Java code.  And now I'm going to be riding my rear end home, and I'm planning on some serious relaxation.
19:14:13 <kc5tja_> It's been a very stressful week.  :(
19:14:37 <ddarius> kc5tja_: Indeed.  And for me, so will next week.
19:15:06 <kc5tja_> Likewise.
19:15:13 <kc5tja_> You don't happen to work at Google, by any chance, do you?  ;)
19:15:53 <ddarius> No.
19:17:00 <kc5tja_> Awww, shucks.  I was hoping we could form a Disgruntled Java Coders Convention or some such.  Not that Java is terribly all that bad as far as a *language* goes, but really, does the JRE have to suck so much ass?
19:17:46 * ddarius uses C# which is nicer than he thought it would be, but he won't be doing any programming next week. Not at work at any rate.
19:18:43 <ddarius> C# makes you appreciate how significant type inference is.
19:25:22 <kc5tja_> ddarius: I also code in Haskell (though not at work) -- trust me, I'm well aware of type inferencing.  :D
19:25:37 <kc5tja_> I'd much rather type: main = do
19:26:00 <kc5tja_> instead of: public static void isomorphic transcendental quaternion main(Strings args[]) {
19:26:04 <kc5tja_> ;D
19:26:41 <kc5tja_> I like the idea of type tags a lot, where it makes sense (e.g., defining new types).  But not when you're defining procedures.  That's just ... tiring.
19:26:48 <ddarius> In typical Java/C# code, the types are annoying but minor.  If you try to port a Haskell library to C# the types alone make the library unusable.
19:27:34 <sorear> kc5tja_: you may have noticed that haskell doesn't support inferring the types of data constructors :)
19:29:22 <kc5tja_> sorear: And it should be so.
19:29:33 <kc5tja_> sorear: I have no problems typing type names when defining types.
19:29:42 <kc5tja_> (wow, say that 10 times fast)
19:30:04 <sorear> that 10 times fast)
19:30:11 <ddarius> Some people have an issue with "having" to "define types" in the first place (or so that is what they say)>
19:30:36 <kc5tja_> I would love to be able to define something like Year = 1975..2012
19:30:45 <ddarius> say /quit
19:31:08 <sorear> ddarius: And these same people support crc's  for machine/machine communication? :)
19:31:13 <sorear> /quit
19:31:42 * sorear knows how to escape strings
19:31:57 <kc5tja_> I just put a space in front.
19:31:59 <kc5tja_>  /quit
19:32:05 <kc5tja_> It's not perfect, but it gets the job done.
19:32:44 <ddarius> sorear: Heck if I know.  What's wrong with crc's for machine/machine communication?
19:33:25 <sorear> ddarius: human/machine has a higher error rate, and they don't support effective redundancy checks (typing)
19:33:44 <sorear> support means to believe in here
19:34:23 <kc5tja_> Actually, that's not strictly true.
19:34:52 <kc5tja_> If we strip away the error redundancy systems, our inter-machine communications would be a right mess.
19:34:59 <kc5tja_> We'll be back to 56K lines for long distance networking.
19:35:30 <kc5tja_> But, I digress.  I'm now heading for my bike.  Laters.
19:35:59 * sorear wonders on the space usage of strict bytestring pack
19:36:39 <sorear> *rech*
19:37:02 <sorear> 12 | 20 bytes/character :(
19:37:35 <ddarius> > 12 .|. 20
19:37:36 <lambdabot>  Add a type signature
19:37:41 <ddarius> > 12 .|. 20 :: Int
19:37:42 <lambdabot>  28
19:37:56 <sorear> | is set disjunction, not boolean lattice join :)
19:42:47 * ddarius doesn't see the difference.
19:43:24 <sjanssen> sorear: does pack still call length?
19:43:47 <sorear> in 6.6 - yes
19:44:02 <sjanssen> is it the same way in fps?  I seem to remember fixing that
19:44:11 <sorear> ergo, it holds on to the beginning of the *un*packed string :(
19:44:25 * sorear checks
19:45:00 <sorear> sjanssen: it calls length in fps darcs
19:46:23 * sorear wonders if unsafeCoerce# :: Word8 -> Char is ever unsafe in GHC
19:46:23 <sjanssen> bah
19:47:09 <sjanssen> w2c is much safe, and free when unboxed
19:47:15 <sjanssen> s/safe/safer
19:47:34 <sorear> ah good :)
19:47:55 <sorear> didn't think the compiler was smart enough to optimize map w2c to id
19:48:16 <sjanssen> well, I don't think map w2c is id
19:48:31 <sjanssen> pretty sure it'd have to create a new list
19:48:40 <sorear> why?
19:49:00 <sorear> they are both single constructor types with a single non-pointer argument
19:49:08 <sjanssen> I suppose it *could*, but I don't think ghc does that
19:49:23 <sjanssen> I doubt ghc turns map id into id
19:49:48 <ddarius> With a good producer it would fuse away though, no?
19:49:59 <sjanssen> sure
19:50:44 <sorear>     GHCi can't bind a variable of unlifted type:
19:50:46 <sorear> nice.
20:02:01 <glguy> To whom it may concern, I am no longer holding Guy Lewis Steele Jr. (AKA The Great Quux) personally responsible for the Java programming language. After due search I have discovered that he did not join the Java team until after the language itself had been designed.
20:02:14 <glguy> -- Raymond (friend of mine)
20:03:40 <sorear> the fact that you feel the need to qualify Raymond with (friend of mine) say a lot
20:04:02 <sorear> unfortunately it's not speaking in a language I understand
20:05:17 <glguy> sorear: he's not anyone that I'd expect anyone to know
20:06:15 <sorear> Ok.. Just mis-interpreted the qualifier.  badly :)
20:16:15 <glguy> sorear: how did you read it
20:17:17 <sorear> I think I erroneously committed to ES, then read (friend of mine), which caused a semantic warning
20:21:55 <glguy> OHH yeah, no he's nota friend of mine
20:27:16 <ivanm> @seen ndm
20:27:17 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 6h 21m 49s ago, and .
20:29:49 <sorear> yeah, it's usually pretty dark in the York area around now :)
20:30:09 <ivanm> lol, wouldn't have a clue ;-)
20:30:18 * sorear hopes it is something he can handle, like a derive question
20:30:29 <ivanm> just trying to find out how to install filepath so I can play with yi
20:30:38 <sorear> @where filepath
20:30:38 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/filepath/
20:30:42 <sjanssen> @hackage filepath
20:30:42 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/filepath
20:30:57 <sorear> http://darcs.haskell.org/packages/filepath/
20:30:57 <sjanssen> oh c'mon, why isn't that on Hackage?
20:30:58 <lambdabot> Title: Index of /packages/filepath
20:31:00 <ivanm> lol, that was easier than trying to go through the wiki ;-)
20:31:07 <sjanssen> @hackage FilePath
20:31:07 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/FilePath
20:31:13 <sjanssen> lame
20:31:21 <ivanm> sjanssen: because I think ndm wants to fix it up a bit more before releasing it
20:31:25 <sorear> BiCapitalization--
20:31:36 <ivanm> LB is case-sensitive?
20:31:39 <sjanssen> sorear: neither worked btw
20:31:39 <sorear> BiCapitalisation--
20:31:41 <ivanm> or the hackage database is?
20:32:06 <sorear> @where ffi
20:32:06 <ivanm> oh, I thought lambdabot was finding that from a database :(
20:32:07 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
20:32:29 <sjanssen> ivanm: the hackage db is case sensitive.
20:32:56 <ivanm> *nod*
20:33:05 <sjanssen> and @hackage is just a dummy plugin, it doesn't know what's in hackage
20:33:24 <ivanm> ahhh, k... automatic url generation from the given value?
20:33:40 <sjanssen> yeah
20:33:51 <sjanssen> @hackage ivamLib
20:33:52 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ivamLib
20:34:08 <sjanssen> meh, imagine that I spelled your nick correctly
20:34:19 <ivanm> lol
20:34:49 <ivanm> just a standard cabal installation?
20:35:06 <syntaxfree> how do you escape an ascii character again? \0x65?
20:35:16 <syntaxfree> > print ['\0x65']
20:35:17 <lambdabot>  Improperly terminated character constant
20:35:37 <ivanm> > print '\0x65'
20:35:38 <lambdabot>  Improperly terminated character constant
20:35:59 <syntaxfree> > print '\0x065'
20:36:00 <lambdabot>  Improperly terminated character constant
20:36:00 <kpreid> > '\x65'
20:36:02 <lambdabot>  'e'
20:36:03 <syntaxfree> > print '\0x065.'
20:36:03 <lambdabot>  Improperly terminated character constant
20:36:11 <kpreid> syntaxfree: no 0
20:36:12 <syntaxfree> > print '\x7'
20:36:14 <lambdabot>  <IO ()>
20:36:19 <ivanm> lol
20:36:24 <sjanssen> > '\65'
20:36:26 <lambdabot>  'A'
20:36:33 <ivanm> > '\x7'
20:36:34 <lambdabot>  '\a'
20:36:39 <syntaxfree> @hackage \7
20:36:39 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/\7
20:36:52 <syntaxfree> daaah. That didn't work :/
20:36:56 <syntaxfree> print "A\7"
20:37:06 <syntaxfree> > print "A\7"
20:37:08 <lambdabot>  <IO ()>
20:37:12 <syntaxfree> > print "AB\7"
20:37:14 <lambdabot>  <IO ()>
20:37:18 <syntaxfree> :(
20:37:23 <kpreid> > "AB\7"
20:37:25 <lambdabot>  "AB\a"
20:37:43 <Adamant> Cale, what's the best way to get fluent with using ghci interactively for someone used to Lisp and Scheme REPL's? I see you are also interested in Scheme.
20:37:57 <Cale> Keep two windows open
20:38:04 <Cale> One with your editor, one with ghci
20:38:14 <Cale> Reloading your file is just : in ghci
20:38:29 <Cale> So save and reload often to transfer over your new definitions.
20:38:45 <Cale> Doing that makes it pretty much interactive.
20:38:56 <Cale> Haskell could really use a Dr. Scheme-alike.
20:38:56 <syntaxfree> Prelude> putStrLn "AB\7"
20:38:58 <syntaxfree> AB
20:39:09 <syntaxfree> Prelude> putStrLn "AB\7C"
20:39:09 <syntaxfree> ABC
20:39:13 <Adamant> ah. I kind of miss just being able to type things into the interpreter easily.
20:39:13 <syntaxfree> huh?
20:39:26 <kpreid> syntaxfree: \7 is a control character.
20:39:33 <syntaxfree> yes. a backspace.
20:39:41 <syntaxfree> but wh. AHh.
20:39:42 <Cale> Well, this is only about 1 extra character of typing, plus whatever it takes to change focus between the windows :)
20:39:43 <syntaxfree> nevermind.
20:39:55 <syntaxfree> I thought I had seen "AB\7" - >"A"
20:40:05 <kpreid> Adamant: also, if you find yourself doing something like ":" followed by "main" frequently then you can define a command to do that for you with :set
20:40:06 <LoganCapaldo> sounds like a job for some kind of emacs inferior mode
20:40:19 <sorear> inf-haskell :)
20:40:28 <kpreid> Adamant: given sufficient cleverness, you can even pretend to have interactive definitions that way...
20:40:30 <Adamant> yeah. I'm just kind of used to firing up the interpreter on the command line for a lot of things, instead of using Emacs all the time
20:40:41 <syntaxfree> you mean, :def
20:40:46 <sorear> LoganCapaldo: just because autoloading is b0rked doesn't mean the mode doesn't exist
20:40:47 <kpreid> er, yes, I do
20:40:55 <kpreid> sorry, haven't used ghci for that in a while
20:41:04 <LoganCapaldo> sorear: I don't know if it exists or not
20:41:09 <LoganCapaldo> I don't use emacs :)
20:41:10 <Adamant> thanks all.
20:41:13 <sorear> LoganCapaldo: I do.  It exists.
20:41:26 <sorear> C-c C-l in haskell-mode
20:41:32 <Adamant> LoganCapaldo, s/Emacs/$EDITOROFCHOICE
20:43:27 <emu> C-c C-r to :reload
20:56:07 <syntaxfree> http://www.knuthfacts.com/index.php?factId=3
20:56:09 <lambdabot> Title: Donald E. Knuth - Facts
20:58:24 <ivanm> sorear: in the latest version, you don't need the C-c out the front IIRC
21:02:11 <sorear> ivanm: Shadowing redisplay is the dumbest key idea I've heard in a long time.
21:02:45 <ivanm> what? don't know what you mean by "shadowing redisplay"
21:04:36 <sorear> what am I supposed to do when the kernel prints something if I don't have C-l?
21:08:11 <ivanm> ahhh, I think I get what you mean... the C-c at the beginning is telling emacs that the following key-combination is for it rather than anything else?
21:08:40 <SamB> \me wishes he knew the Pascal for '\x1b'
21:09:04 <SamB> hmm.
21:09:07 <SamB> too much DOS?
21:09:18 <sorear> SUB iirc
21:09:34 <sorear> that's the ascii, not pascal syntax
21:10:54 <sorear> ivanm: emacs hears all.  C-c is just another prefix key, reserved for mode specific commands.  by emacs policy modes are not supposed to define any key that doesn't either start with C-c or do roughly the same thing as the standard key.
21:11:05 <ivanm> ahhh, k
21:11:21 <sorear> eg. C mode defines '*' to be a key that inserts '*' as usual (but also reindents).
21:11:45 <ivanm> so it'd be C-c * ?
21:12:01 <sorear> no, it's just *
21:12:16 <sorear> because it does roughly the same thing as the standard *
21:12:17 <SamB> for some reason, the mousewheel doesn't work in turbo pascal
21:12:23 <SamB> any idea why that might be ;-)?
21:12:42 <ivanm> sorear: OK, got you... so C-l normally does something else? what?
21:12:56 <ivanm> SamB: because its a DOS program?
21:13:14 <SamB> ivanm: I suspect it is the lack of a SCROLL WHEEL interrupt ;-)
21:13:15 <sorear> ivanm: redisplay.  you ever use a text-mode program, and for whatever reason the screen is corrupted?
21:13:18 <allbery_b> in xemacs C-i is bound to a function which invokes a mode-specific indentation command if one exists, or self-inserts otherwise
21:13:32 <allbery_b> oh, misread.  c-l.
21:13:34 <sorear> allbery_b: clean your monitor, we're
21:13:36 <sorear> oh  ;)
21:13:41 <ivanm> sorear: yep, when cat-ing the contents of a binary file :s
21:13:54 * allbery_b needs to clean his eyes, more like.  or go to bed. :>
21:14:10 <ivanm> bed? what kind of mystical device is that? ;-)
21:14:16 <sorear> ivanm: so in all this time you never found out about the conventional Unix ^L key combo?
21:14:46 <sorear> or are you using a different os?
21:14:51 <ivanm> nope... I've been using linux as my default OS for only about 8 months now, and haven't really looked at key combos much
21:14:58 <SamB> ivanm: have you never had the kernel display some garbage on top of the display of an open application?
21:15:09 <ivanm> and I _really_ need to go through using emacs properly...
21:15:18 <ivanm> SamB: not that I can recall...
21:15:27 <SamB> ivanm: do you not use the console?
21:15:39 <sorear> one of the big reasons I use text mode is because I *want* to see the kernel messages
21:15:51 <ivanm> I use terminals inside an X session usually
21:15:55 <sorear> i've had hard disks *die* on me before
21:15:59 <allbery_b> that's what xconsole is for :)
21:16:00 <SamB> my system boots to textmode because I have an irrational fear of GDM
21:16:01 <ivanm> oh.. that's bad
21:16:06 <SamB> or XDM or whatever
21:16:09 <sorear> cannot open /lib/libc.so.6: IO error
21:16:14 <sorear> I've seen that
21:16:16 <andrei> sorear, Yeah.. but you'll find out one way or another just after the kernel message
21:16:20 <ivanm> SamB: lol... KDM, XDM, qingy, SLiM?
21:16:36 <SamB> well okay maybe not quite irrational
21:17:18 <SamB> basically, I like to have some kind of remedy if I hose my X configuration
21:17:26 <sorear> If there was a decent gv for the linux framebuffer I would completely uninstall X.
21:17:40 <SamB> (though this dates back to before the installation of ethernet in this building)
21:17:42 <allbery_b> also, in emacs C-l both redisplays and positions the current line at the center of the window
21:18:09 <sorear> gv is the ONLY x program I use.
21:18:28 <sorear> OK, I use xterm (only) to start gv and xmonad (only) to keep it fullscreen
21:18:31 <ivanm> SamB: *nod*... I've had to go into a console a few times to fix up X errors before
21:18:44 <ivanm> sorear: lol... I like X
21:18:46 <LoganCapaldo> gv?
21:18:54 <sorear> aka ghostview
21:18:54 <ivanm> ghostview?
21:19:03 <sorear> postscript/pdf viewer
21:19:10 <LoganCapaldo> oh
21:19:11 <SamB> sorear: do you not also use an X server?
21:19:12 <sorear> since spj doesn't do plain text :(
21:19:20 <SamB> along with ghostscript itself, which gv embeds?
21:19:22 <sorear> SamB: s/program/client/
21:19:41 <kilimanjaro> sorear, do you live in a cave?
21:19:43 <sorear> I consider that part of ghostview.
21:20:15 <SamB> well, it is no more a part of ghostview than the web browser is part of internet explorer...
21:20:17 <sorear> kilimanjaro: suprisingly enough, no.  no caves in sandiego
21:20:39 <kilimanjaro> Most caves aren't suitable for human habitation anyways
21:20:59 <SamB> sorear: you live with your parents, right?
21:21:02 <sorear> SamB: yes
21:21:25 <sorear> SamB: MSHTML is documented. AFAIK gs -sDEVICE=x11 isn't.
21:21:33 <SamB> did you know that dosemu doesn't support S in terminal mode?
21:21:50 <sorear> ouch. I use that a LOT
21:22:03 <sorear> it's the first letter of my name!
21:22:05 <SamB> maybe you use it in a more raw mode
21:22:17 <SamB> or don't use dosemu ;-)
21:22:35 <ivanm> lol
21:22:56 <ivanm> so sorear will be known as orear if using dosemu? ;-)
21:22:58 <SamB> and for some reason the X mode doesn't like the 3 at the top of my keynoard
21:23:11 <SamB> ivanm: it is only capital S that doesn't work for me in terminal mode
21:23:20 <ivanm> ahhh, k
21:23:27 <SamB> makes it a bit difficult to use it with putty
21:23:35 <sorear> but Stefan O'Rear will be tefan O'Rear
21:24:15 <SamB> oh, I think the syntax is ord(0x1b)
21:24:20 * qwr wonders, whether it would be possible to build kghostscript with framebuffer enabled qtembedded...
21:24:57 <SamB> qwr: wouldn't that kinda require framebuffer?
21:24:59 <SamB> oh.
21:25:03 <SamB> he wants that?
21:25:14 <SamB> framebuffer messes up the console!
21:25:33 <sorear> SamB: I use framebuffer.
21:25:51 <sorear> SamB: linux thesedays runs console ON the framebuffer
21:26:08 <qwr> sorear: depends on kernel config ;)
21:26:15 <sorear> well, it's an option, but I'm not old enough to need 80x25
21:26:28 <SamB> last I checked, it only did that if you modprobe a relevant module
21:26:42 <SamB> well, I would be happy to set it to that largish mode
21:26:49 <SamB> 132 by something?
21:26:51 <sorear> SamB: the debian boot scripts support this thing called /etc/modules
21:26:58 <sorear> I use 128x48
21:27:11 <SamB> oh, I think it also disappeared my cursor last I tried it
21:27:26 <sorear> qwr: I would rather have xorg on this machine than kdelibs, thank you very much.
21:28:03 * qwr has both. although i don't use kde desktop :)
21:28:23 <qwr> but kpdf beats anything on viewing pdf's
21:28:34 <qwr> and konqueror is sometimes nice to have
21:28:58 <sorear> gv is a good-enough pdf viewer for me.
21:29:01 <SamB> hmm.
21:29:14 * SamB thinks maybe pascal doesn't support C-style hex constants
21:29:47 <ivanm> sorear: how about xpdf? or epdfviewer?
21:29:55 <ivanm> or acroread :p
21:30:06 <SamB> and I confused chr with ord
21:30:35 <sorear> ivanm: xpdf is good too, but sometimes mangles fonts.  never used the second. haven't used the third in 3-4 yrs.
21:30:44 <ivanm> lol
21:30:57 <LoganCapaldo> sorear: I feel like if the only reason you use gv is because SPJ doesn't do plain text that the real solution is to write a Haskell program to pull the plain text out of a ps
21:31:00 * ivanm normally uses evince... epdfviewer is a gnome-free version of evince, but its not updated as often
21:31:01 * SamB is trying to recreate ZZT
21:31:17 * SamB figured it would be easiest to do in its native tongue of Turbo Pascal
21:31:38 <LoganCapaldo> ZZT was written in turbo pascal? I did not know that
21:31:52 <SamB> it certainly seems to have been
21:32:06 <sorear> LoganCapaldo: translating pdf to pretty text is easy - pdftotext | fmt.  Translating maths notation to ASCII maths notation is non-trivial.
21:32:06 <SamB> it is easier to tell after you unpack it ;-)
21:32:42 <qwr> freepascal probably supports most of turbo pascal extensions
21:33:00 <SamB> qwr: well, it is easier to compare the generated code using the same brand of compiler
21:33:34 <SamB> also does it have CRT and DOS units?
21:33:47 <SamB> or come with a Turbo Vision IDE?
21:34:29 <foxy-om> is there a library function to replace substrings within a string?
21:35:06 <Korollary> Text.Regex.subRegex does it I think
21:35:12 <LoganCapaldo> foxy-om: Maybe, but I wrote one :)
21:35:21 <qwr> SamB: seems there is some turbo vision clone ;)
21:35:33 <foxy-om> Korollary: ta
21:35:47 <SamB> qwr: Free Vision ain't a clone
21:35:58 <SamB> it is Turbo Vision -- liberated
21:36:37 <SamB> anyway, I bet Free Pascal doesn't support the PC speaker
21:36:45 <Korollary> heh
21:37:00 <SamB> (and isn't Free Vision a C++ version or something?)
21:41:08 <SamB> okay, now how do you do a "case"...
21:52:38 * SamB thinks he must have messed up the joystick detection or something...
22:00:12 * SamB looks at his joystick detection and Tim Sweeney's in IDA
22:00:40 <SamB> well, actually the one that I call mine is supposed to be the same as his
22:01:48 <LoganCapaldo> SamB: so are you just basically trying to  reconstruct the source code?
22:01:59 <SamB> yes
22:02:09 <LoganCapaldo> craaaazy
22:02:38 <SamB> for some reason I added my name to the title screen though
22:04:15 <SamB> maybe I will be a reverse engineer when I grow up?
22:06:15 <ivanm> lol
22:06:21 <LoganCapaldo> you need to change the scripting laqnguage into Haskell :)
22:06:36 <LoganCapaldo> much better vandalism then adding your name to the title screen
22:06:49 <SamB> you want me to replace ZZT OOP with Haskell?
22:06:58 <SamB> and then claim this to be "vandalism"?
22:07:34 <SamB> I seriously doubt I could pass off such a program as being ZZT anyway
22:07:51 <SamB> (it wouldn't run any of the existing ZZT files, after all)
22:07:57 <LoganCapaldo> ZZT -- Now with more monads!
22:09:25 <SamB> okay, for some reason I am unable to spot any obvious differences between our actual joystick detection code...
22:10:01 * LoganCapaldo wonders about reimplementing ZZT as a game within ZZT
22:10:18 <SamB> do you remember nothing of ZZT OOP?
22:10:31 <LoganCapaldo> not much
22:10:37 <LoganCapaldo> it was a long time ago
22:10:40 <SamB> it isn't turing complete
22:10:46 <SamB> unless you leverage the level, maybe
22:11:17 <LoganCapaldo> sure it isn't?
22:11:31 <LoganCapaldo> I presume you could implement Life in ZZT
22:11:40 <SamB> quite sure! it doesn't even have counters!
22:11:58 <LoganCapaldo> which would then give you turing completeness :)
22:12:09 <SamB> also the number of "objects" allowed is not very large
22:12:19 <LoganCapaldo> hmm
22:12:32 <LoganCapaldo> I mostly used it to indulge in my star trek fantasies
22:12:39 <badger_homes> eddie haskell
22:13:10 <LoganCapaldo> Mostly I walked into people and they said things like "Beam me up, Scotty!"
22:13:29 <badger_homes> hey Loge's
22:14:04 <SamB> wait, maybe I am wrong...
22:14:10 * SamB doesn't know what all this code does...
22:14:13 <badger_homes> sceme me up bobby, i'v for the gripes
22:14:24 * SamB thinks he was looking at the wrong function
22:14:40 <narain> ?hoogle Bool -> a -> Maybe a
22:14:41 <lambdabot> No matches, try a more general search
22:15:19 <badger_homes> i am confused, where am i
22:15:22 <LoganCapaldo> @type (\c v -> if c Just v else Nothing)
22:15:25 <lambdabot> parse error on input `else'
22:15:28 <narain> ?pl \x y -> if x then Just y else Nothing
22:15:29 <lambdabot> flip flip Nothing . (. Just) . if'
22:15:31 <badger_homes> i was reading the yourtube and all of a sudden i'm hreere
22:15:39 <LoganCapaldo> @type (\c v -> if c then Just v else Nothing)
22:15:41 <lambdabot> forall a. Bool -> a -> Maybe a
22:15:50 <LoganCapaldo> I fail at typing
22:16:01 <badger_homes> i fail at knowing where i am
22:16:05 <badger_homes> come on help me ou t
22:16:15 <badger_homes> pleas,e loges, please
22:16:27 <SamB> ah
22:16:34 <SamB> now I see a difference ;-)
22:16:45 <badger_homes> oh, big bird :(
22:18:08 <narain> > 1+1<3
22:18:09 <lambdabot>  True
22:19:08 <LoganCapaldo> @type (\a -> case a of Just a -> (True, a); Nothing -> (False, undefined))
22:19:11 <lambdabot> forall t. Maybe t -> (Bool, t)
22:20:06 <narain> ?hoogle Maybe a -> a
22:20:07 <lambdabot> Maybe.fromJust :: Maybe a -> a
22:20:07 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
22:20:07 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
22:20:42 <LoganCapaldo> @type (uncurry (\c v -> if c then Just v else Nothing)) .  (\a -> case a of Just a -> (True, a); Nothing -> (False, undefined))
22:20:45 <lambdabot> forall b. Maybe b -> Maybe b
22:21:03 <LoganCapaldo> @type (uncurry (\c v -> if c then Just v else Nothing)) .  (\a -> case a of Just a -> (True, a); Nothing -> (False, undefined)) Nothing
22:21:06 <lambdabot>     Couldn't match expected type `a -> (Bool, b)'
22:21:06 <lambdabot>            against inferred type `(a1, b1)'
22:21:11 <narain> for a moment i thought  maybe  should have a type of  (a -> b) -> Maybe a -> Maybe b, then i realized that's just  liftM
22:21:15 <LoganCapaldo> @type (uncurry (\c v -> if c then Just v else Nothing)) .  (\a -> case a of Just a -> (True, a); Nothing -> (False, undefined)) $ Nothing
22:21:18 <lambdabot> forall b. Maybe b
22:21:25 <LoganCapaldo> > (uncurry (\c v -> if c then Just v else Nothing)) .  (\a -> case a of Just a -> (True, a); Nothing -> (False, undefined)) $ Nothing
22:21:27 <lambdabot>  Nothing
22:21:36 <LoganCapaldo> > (uncurry (\c v -> if c then Just v else Nothing)) .  (\a -> case a of Just a -> (True, a); Nothing -> (False, undefined)) $ Just 42
22:21:37 <lambdabot>  Just 42
22:22:34 <LoganCapaldo> > (id Nothing, id $ Just 42 )
22:22:35 <lambdabot>  (Nothing,Just 42)
22:24:21 <SamB> okay, I think I've stumbled upon the logic he used ;-)
22:25:15 <narain> :t (Nothing, id $ Just return) -- what would you do if you couldn't get tickets for the movie?
22:25:17 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (Maybe a, Maybe (a1 -> m a1))
22:25:57 <LoganCapaldo> > ((\a b c -> if a then b else c) True 1 undefined, (\a b c -> if a then b else c) False undefined "Ok")
22:25:59 <lambdabot>  (1,"Ok")
22:26:04 <LoganCapaldo> sweet
22:26:32 <LoganCapaldo> Bool + functions = Maybe, and Either
22:26:52 <LoganCapaldo> Maybe + Either gives you pretty much everything else afaict
22:27:02 <LoganCapaldo> So long "data" :)
22:27:33 <narain> and functions + functions = Bool :-P
22:27:43 <LoganCapaldo> true
22:27:53 <LoganCapaldo> I mean (\x y -> x)
22:28:08 <narain> :)
22:28:43 <narain> > ((\x y -> x) 1 undefined, (\x y -> y) undefined "Ok")
22:28:45 <lambdabot>  (1,"Ok")
22:30:29 <narain> too bad you can't do case analysis on lambdas
22:30:37 <LoganCapaldo> > (\(x, y) -> x ) (1, (True, (1, (False, undefined)))
22:30:37 <lambdabot>  Parse error
22:30:48 <LoganCapaldo> > (\(x, y) -> x ) (1, (True, (1, (False, undefined))))
22:30:49 <lambdabot>  1
22:32:08 <LoganCapaldo> That's head fyi :)
22:32:27 <narain> ah yes
22:32:51 <narain> that list's type will be hideous though
22:33:06 <narain> :t (1, (True, (1, (False, undefined))))
22:33:09 <lambdabot> forall t t1 a. (Num t, Num t1) => (t, (Bool, (t1, (Bool, a))))
22:33:21 <LoganCapaldo> yeah
22:33:57 <LoganCapaldo> I was trying for List = (a, Maybe (List a))
22:34:34 <narain> ohh i see that
22:34:56 <narain> shouldn't that be List = Maybe (a, List a)?
22:35:22 <LoganCapaldo> yeah
22:36:08 <narain> > (\(True,(x,xs)) -> x) (True, (1, (False, undefined)))
22:36:10 <lambdabot>  1
22:36:17 <narain> > (\(True,(x,xs)) -> x) (False, undefined)
22:36:19 <lambdabot>   Non-exhaustive patterns in lambda
22:36:28 <narain> > head []
22:36:29 <lambdabot>  Exception: Prelude.head: empty list
22:36:51 <narain> darn, i couldn't replicate the error message
22:43:42 <LoganCapaldo> you don't really need case on lambdas
22:43:50 <LoganCapaldo> you just turn it inside out
22:44:32 <narain> ah, right
22:46:01 <LoganCapaldo> > let just x = (\j nothing -> j x); let nothing = (\j nothing -> nothing undefined) in (just 2) (+1) (const 0)
22:46:02 <lambdabot>  Parse error
22:46:09 <LoganCapaldo> > let just x = (\j nothing -> j x); nothing = (\j nothing -> nothing undefined) in (just 2) (+1) (const 0)
22:46:10 <lambdabot>  3
22:46:31 <LoganCapaldo> > let just x = (\j nothing -> j x); nothing = (\j nothing -> nothing undefined) in nothing (+1) (const 0)
22:46:33 <lambdabot>  0
22:48:29 <LoganCapaldo>  let left x = (\l r -> l x); right x = (\l r -> r x), etc.
22:49:39 <narain> :t zero
22:49:42 <lambdabot> Not in scope: `zero'
22:49:44 <narain> good
22:55:27 <wy> hello!
22:55:34 <wy> @users
22:55:35 <lambdabot> Maximum users seen in #haskell: 336, currently: 274 (81.5%), active: 23 (8.4%)
22:55:45 <wy> Good!
22:57:11 <wy> I recent came back to write some SML, and noticed that it seems ML's datatype constructor can't be curried. Is that so?
22:58:52 <narain> i can't recall for sure, but that sounds about right
22:59:37 <sorear> To me too.
23:00:05 <sorear> For the record, deep down glasgow haskell doesn't support curried data types
23:00:14 <wy> I didn't noticed this change when I transfer to Haskell, but when I tried ML today, I suddently realized that.
23:00:16 <narain> ?pl \(Foo x) -> x
23:00:16 <lambdabot> (line 1, column 7):
23:00:17 <lambdabot> unexpected "x"
23:00:17 <lambdabot> expecting operator or ")"
23:00:18 <sorear> when you write Maybe it is compiled as \x -> Maybe x
23:01:00 <sorear> Meanwhile, I wrote my first ML program (oca, but I didn't use the o) yesterday.
23:01:13 <sorear> It's a lot less bad than the name makes it sound ;)
23:01:25 <narain> can i pointlessly deconstruct values?
23:01:30 <LoganCapaldo> sorear: doncha mean when you write Just it is complied as \x -> Just x? Or am I confused?
23:01:42 <sorear> LoganCapaldo: you're right :)
23:01:49 <sorear> \x -> Just x
23:02:26 <wy> The theory is almost the same, but Haskell is a lot more convenient
23:02:27 * LoganCapaldo had visions of type level lambdas
23:02:45 <narain> as in can i do  \Foo x -> x  pointlessly? i have a  newtype Foo = Foo SomeType  and i would like to get  x  out of  Foo x
23:03:01 <sorear> newtype Foo = Foo { unFoo :: SomeType }
23:03:24 <sorear> let the compiler write unFoo for you :)
23:03:38 <narain> sorear: that's one solution... but it makes pattern matching on Foo ugly in other places
23:03:46 <narain> ...or doesn't it?
23:03:55 <wolverian> you don't have to use the field syntax
23:04:04 <sorear> and vice versa
23:04:13 <narain> even in patterns?
23:04:17 <sorear> > (\Just{} -> 2) (Just 2)
23:04:18 <lambdabot>  2
23:04:23 <sorear> even in patterns
23:04:37 <sorear> > (\(:){} -> 2) "foo"
23:04:37 <narain> well! that makes things a lot nicer
23:04:38 <lambdabot>  2
23:04:54 <arke> hmm
23:04:55 <sorear> altho (:){} is verging on IOHCC territory
23:05:11 <wolverian> it's deeply in there imho :)
23:05:17 <LoganCapaldo> verging is such a weak word
23:05:21 <arke> anybody have a neat little haskell thinking excercise for me to do while i wait for the other computer to finish installing the new operating system? √ñ:)
23:05:30 * arke notes that he is a nooob
23:06:22 <narain> > fix ((0:).scanl(+)1)
23:06:23 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
23:06:31 <sorear> newtype IO a = IO ( () -> a )
23:07:24 <arke> thats a fibonaci, right? o.O
23:07:31 <sjanssen> @src IO
23:07:32 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
23:07:32 <sorear> instance Monad IO where return = IO . const ; (IO a) >>= b = IO $ \() -> let x = a () in x `seq` case b x of IO fn -> fn ()
23:07:36 <narain> arke: yes
23:07:44 <sorear> what is wrong with this definition of IO?
23:07:52 <sorear> (note: I am not asking)
23:08:05 <sorear> and don't google unless you want to be spoiled
23:08:35 <arke> narain: heh, interesting...
23:08:58 <narain> sorear: oh great, now i feel compelled to think about it too
23:09:05 <sorear> anyone who does want to be spoiled speak up and I'll pm you a URL
23:10:08 <narain> arke: the exercise is, figure out how that works
23:10:23 <sjanssen> I think I know
23:10:25 <jyp> I remember that one :)
23:10:25 <LoganCapaldo> sorear: well it doesn't allow for IORefs and such afaict, but I somehow suspect that's not what you were looking for
23:10:35 <arke> both are excercises that make me head explode √ :)
23:10:49 <jyp> I feel such an old haskell hacker now :p
23:11:49 <arke> hehe, spoil me. =)
23:12:07 <arke> meanwhile, i'll look further at the fibonnaci
23:12:18 <sorear> you ask too quickly, I'm still looking :)
23:13:11 <arke> hehe √ =)
23:13:17 <arke> argh stupid german keyboard
23:13:28 * LoganCapaldo thinks its gonna be something he'd never ever think of, of if he thinks of it he'll dismiss it
23:15:06 <LoganCapaldo> its too easyto write unsafePerformIO?
23:15:15 <arke> aah
23:15:28 <arke> narain: local ghci says fix not in scope ... what do i have to import?
23:15:31 <sorear> LoganCapaldo: that's easy in GHC too
23:15:36 <sorear> @src unsafePerformIO
23:15:36 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
23:15:45 <narain> ?hoogle fix
23:15:46 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
23:15:46 <lambdabot> Control.Monad.Fix :: module
23:15:46 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
23:16:00 <sjanssen> so are we supposed to blurt out answers?
23:16:01 <narain> huh, i didn't know that was in Control.Monad.Fix
23:16:03 <LoganCapaldo> i'm just guessing at this point :
23:16:29 <LoganCapaldo> sjanssen: no, I'm the only one who can blurt out answers because they are guranteed to be wrong :)
23:16:35 <sjanssen> :)
23:17:32 <LoganCapaldo> I wanted to use the Writer monad in some code the other day
23:17:37 <narain> ?pl \x y -> f (g x) (g y)
23:17:37 <lambdabot> (. g) . f . g
23:17:44 <LoganCapaldo> but I was not in Haskell
23:18:09 <sorear> Yesterday I wanted to use the Cont monad, but I wasn't in Haskell.
23:18:17 <sorear> So I implemented it :)
23:18:29 <sorear> now O'caml has monad too!
23:18:36 <narain> ?src liftM2
23:18:37 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
23:19:06 <narain> ?hoogle (a -> b) -> (b -> b -> c) -> (a -> a -> c)
23:19:07 <lambdabot> No matches, try a more general search
23:19:28 <Korollary> sorear: I thought others had already done monads in ocaml
23:19:32 <LoganCapaldo> yeah but I was not using a language in which iplemnting monads would be convient
23:19:41 <LoganCapaldo> sady
23:19:44 <LoganCapaldo> *sadly
23:19:57 <sorear> Korollary: well it was easier than googling :)
23:20:10 <sorear> let return x y = y x ;;
23:20:18 <Korollary> what were you doing in ocaml?
23:20:53 <sorear> let (>>=) a f c = a (fun v -> f v c)
23:21:02 <sorear> Korollary: unlambda *compiler*
23:21:12 <arke> hah! :)
23:21:20 <sorear> pretty sure I'm the first person to figure out how to write one
23:21:38 <sorear> I wrote it in haskell first, easier that way
23:21:39 <narain> is (..) reserved?
23:21:42 <sorear> yes
23:21:47 <Korollary> I'll bet it will be widely used
23:21:47 <eumenides> jyp: ha yi still doesn't compile
23:21:48 <arke> shouldn't be hard to write an unlambda -> haskell converter though, would it?
23:21:49 <narain> :(
23:21:57 <sorear> actually I'm talking about the OUTPUT here
23:22:02 <LoganCapaldo> Can I have the secret answer please?
23:22:02 * arke would imagine the most work to be the unlambda c instruction
23:22:37 <sorear> arke: unlambda has a 'd' operator that Madore himself believes was compiler-proof
23:23:12 <arke> d is the lazy execution instruction, right?
23:23:17 <int-e> yes
23:23:18 <narain> is (.:) allowed?
23:23:20 <sorear> I know this is a true compiler because it runs 22 times faster than the interpreter
23:23:23 <sorear> yes
23:23:25 <sorear> :)
23:23:32 <arke> heh, cool :)
23:23:40 <narain> sorear: thanks
23:24:27 * arke tries to think of a simple use for d
23:24:45 <arke> i dont remember much from unlambda and it was mostly over my head anyway :)
23:25:07 <jyp> eumenides: what's the matter?
23:25:19 <sorear> Actually it was even nicer ... I was able to write unlambda as a haskell dsl
23:25:36 <sorear> so the 'compiler' just translated syntax and tacked on an import
23:25:44 <eumenides> jyp: it seems serious: http://img480.imageshack.us/img480/73/200704070023221024x768swg4.png
23:25:47 <lambdabot> http://tinyurl.com/ypev3a
23:25:51 <sorear> then, just for fun, I re-wrote the dsl in O'Caml
23:26:20 <arke> ...whats a dsl? :)
23:26:27 * arke points out again that he is a noooooob
23:26:31 <jyp> eumenides: looks like a wrong version of vty
23:26:33 <narain> arke: domain specific language
23:26:35 <sorear> ghc -O2 -funfolding-creation-threshold=1000 -funfolding-use-threshold=1000 was exactly (within 5%) as fast as ocamlopt!!
23:26:47 <jyp> eumenides: I'll update here.
23:27:07 <arke> ah, i see
23:27:13 <sorear> of course ocamlopt proper was a couple dozen times faster :)
23:27:15 <narain> arke: basically, implement a language by implementing its keywords as functions and variables in a "host" language
23:27:45 <sorear> so I had a application operator @@, and variables s, k, i, v, etc
23:28:02 <LoganCapaldo> narain: not necessarily in a host language
23:28:04 <arke> if i remember correctly, ...
23:28:08 <LoganCapaldo> e.g.: SQL
23:28:23 <narain> LoganCapaldo: ah right, i overspecified
23:28:50 <narain> make that "one way to implement a dsl is to ..."
23:29:09 <arke> s x y z = (x z) (y z) ... oh wait, haskell is lazy o.O
23:29:25 <sorear> of course it helps that I don't know the magic go-faster options for ocamlopt ;)
23:29:39 <jyp> eumenides, sorear: indeed, vty changed.
23:30:16 <sorear> arke: nor witll that work in ocaml - unlambda has variable strictness
23:30:43 <arke> which means...?
23:30:47 <eumenides> jyp: so do i get an old one?
23:31:02 <sorear> jyp, eumenides: it turns out I uploaded a broken version and forgot to upload for two months, so if you can't find Event it's because you need to pull again
23:31:40 <jyp> sorear: did you just commit a fix?
23:31:41 <sorear> (I've also pretty much ceased development fwiw)
23:32:07 <sorear> jyp: no, I recorded the fix months ago.  but my webspace is not updated in real time
23:32:15 <sorear> only when I do a ftp upload
23:32:25 <sorear> which I forgot to do after fixing
23:32:41 <sorear> dylan poked me 2 days ago, I uploaded then
23:32:48 <jyp> sorear: I did a pull 2 minutes ago...
23:33:06 <sorear> and it's still broken?
23:33:29 <jyp> Well if I don't change yi code, yes.
23:33:35 <jyp> maybe an import is missing
23:33:48 <sorear> still only one exposed module
23:34:13 <sorear> if anything is actually gone, it's probably an export list bug introduced in the refactor 2m ago
23:34:39 <jyp> EvResize is defined in LLInput
23:34:49 <jyp> which is not re-exported by the Vty module
23:34:57 <sorear> LLInput isn't exposed
23:35:08 <sorear> if it's not re-exported, it's a bug
23:35:31 <jyp> Would you fix it?
23:35:48 <jyp> Or give me hints how to do it?
23:36:32 <jyp> Or let my creativity flow freely? :p
23:36:53 <sorear> jyp: ok, uploading
23:37:11 <jyp> sorear: thanks! :)
23:37:15 <sorear> jyp: since I'm too lazy to write an incremental uploader this will take a few minutes
23:37:18 <sorear> :)
23:54:11 <eumenides> sorear: fixed?
23:54:38 <jyp> eumenides: yes
23:54:42 <sorear> eumenides: data is moving slowly
23:58:29 * sorear decides ftp is too slow and painful, and proceeds to nmap members.cox.net (is there some other protocol usable?)
23:59:35 <ketil> why is ftp too slow?
