00:01:51 <dcoutts> dons: well it desugars ok and some of them seem to fuse, I'm just tweaking the rules
00:02:04 <dcoutts> bind is turning back into the unfused form unnecessarily
00:02:11 <dcoutts> unfusible
00:03:04 <sorear> I have to wonder if list comprehensions predate -O.
00:03:40 <dcoutts> sorear: you could probably do the trivial list desugaring these days, yes
00:03:51 <dcoutts> if all you wanted was to generate ok list code
00:04:42 <dcoutts> dons: I'm doing 3 special cases,  [ e | p <- l, b, Q ],  [ e | p <- l ] and [ e | p <- l, b ]
00:05:15 <dcoutts> sorear: the rules I'd use to optimise the trivial desugaring are not quite expresible in the current ghc rules language
00:05:44 <sorear> dcoutts: and they don't naturally fall out of the simplifier?
00:06:33 <dcoutts> sorear: it's things like concatMap (\x -> if p x then [x] else [])
00:08:04 <sorear> hmm, after concatMap is inlined and specialized, it seems like ++ should be inlinable -> turning into id and :, thus producing the same code as an inlined filter
00:08:12 <dcoutts> however if it was: concatMap (\x -> gaurd p (\y -> return y)) then you can apply more algebraic rules
00:09:37 <dcoutts> sorear: ok but you have to do this: (if e1 then [e2] else []) ++ ys  -> if e1 then [e2] ++ ys else ys
00:10:05 <sorear> if/then/else is a case right?
00:10:09 <dcoutts> yep
00:10:15 <dcoutts> so that you can notice [e2] ++ ys -> e2:ys
00:10:18 <sorear> you mean ghc doesn't hoist expressions into cases?
00:10:37 <dcoutts> it can sometimes, but sometimes it's a benefit to go the other way
00:10:53 <dcoutts> it's not always obvious which way to go
00:10:58 <sorear> beh, ghc is too ... committal
00:11:33 <dcoutts> heh, you try a mighty simplifier, there's a lot of heuristics or very very deep backtracking searches
00:11:55 <sorear> try == try to write here?
00:12:17 <dcoutts> no, I just mean it's a hard problem
00:12:32 <dons> its a hard problem. lots of snakes and ladders between you and perfect code.
00:12:48 <dons> most of the ladders have some snakes at the top
00:13:20 <dcoutts> dons: looks good so far, obviously once we get the fused code we need rl's stuff, but I'm getting things to fuse
00:13:31 <dons> ogreat!
00:13:44 <sorear> yes, v.low on my v.long todo list
00:13:44 <sorear> although I think it would be more productive at a very low level
00:13:44 <sorear> code motion with profiling-directed cache simulation for fitness seems ideally suited for gp
00:13:50 * sorear realises he has gone off on a complete tangent
00:13:58 <sorear> @botsncak
00:13:58 <lambdabot> :)
00:14:35 <dcoutts> sorear: a little bit of limited backtracking search might not be so bad
00:14:50 <dcoutts> "if I did this would it expose something good?"
00:15:55 <foxy-om> are there instructions anywhere to turn a .dll or .lib into a library that ghc can link against?
00:16:20 <sorear> @where ffi
00:16:21 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
00:17:58 <foxy-om> the ffi doesn't help :-(
00:18:04 <dcoutts> foxy-om: there's no transform necessary
00:18:09 <dcoutts> you can just link to it
00:18:33 <dcoutts> if it's on the standard linker path just say -lfoo for libfoo.a
00:18:53 <foxy-om> dcoutts, but I have libmx.dll
00:19:02 <dcoutts> foxy-om: ghc can link to all .dll and .lib files that gcc can, it's the same mechanism
00:19:23 <dcoutts> on windows if you only have the .dll you might need an import .lib file I think
00:19:31 <araujo> hello!
00:19:41 <sorear> hello!
00:19:43 <dcoutts> which I think you can generate using dlltool
00:19:48 <araujo> sorear!!
00:19:54 <araujo> dcoutts!!!
00:20:32 <dcoutts> dons: ah, hmm cases seem to be getting in the way...
00:23:18 <foxy-om> dcoutts, I used dlltool to generate a libmx.lib file and that is in my directory, but ld.exe is saying it can't find -lmx
00:26:33 <dcoutts> foxy-om: you'd need to add the current dir to the linker search path then with -L.
00:32:14 <shapr> d00d
00:33:26 * araujo throws a sugar-lambda at shapr 
00:44:43 * shapr sleeps on the sugar-lambda.
01:01:03 <sorear> dons: the hs-plugins web site contains refs to AltData
01:02:18 * stefanha laughs at Wireless Power finally Reality on Slashdot.
01:05:56 <sorear> dons: how do I tell hs-plugins what ghc to use?
01:06:42 <dons> its set in config.h iirc
01:06:52 <dons> or else it uses 'ghc' from the path. can't recall which.
01:07:26 <sorear> my path ghc is 6.7.20070323, and as you might imagine that doesn't work too well :)
01:08:00 <dons> it doesn't?
01:08:47 <sorear> ISTR the hi format was changed
01:08:57 <dons> oh. right. yes.
01:09:08 <dons> ghc-api plugins would make a good SoC project
01:09:16 <dons> take whatever yi is using for plugins now
01:09:23 <dons> and provide an hs-plugins-like api to that
01:11:59 <sorear> Now, I re-compile hs-plugins ... using cabal configure, then ./configure.  Hmm, I wonder how easy it would be to get configure.ac to understand cabal's phrasing of 'compiler?' ...
01:13:23 <sorear> One thing I'd like to see is garbage collection for plugins ... unload is such an eyesore
01:13:34 <sorear> That sounds so easy to implement (not)
01:15:27 <tsp> hmm
01:15:55 <tsp> I was dreaming that I could load an entire file into ram, run a lines on it, and it would be evaluated lazily
01:16:15 <sorear> Prelude System.Eval.Haskell> eval "2 + 2 :: Int" [] :: IO (Maybe Int)
01:16:15 <sorear> Just 4
01:16:19 <sorear> yeah!
01:16:44 <foxy-om> dcoutts, I defined a pointer {#pointer *Array as Array newtype#} in one file with a context "mx", the second file I'm trying to interface to uses *mxArrays but their type is being called Ptr (), is there any magic I need to do?
01:17:38 <dcoutts> {# import OtherModule #}
01:18:41 <foxy-om> ah... thanks :)
01:19:36 <sorear> Ooh, yay, segfault with plugins...
01:19:40 <dmead> hey
01:23:47 <sorear> dons: I unloaded a module and I can still access it's functions, even performGC doesn't give me a segfault.  Am I just lucky or is unloading actually lazy?
01:37:01 <foxy-om> dcoutts, is there a standard way of marshaling between char *foo[], i.e. (Ptr (Ptr CChar)), and [String] ?
01:38:03 <dcoutts> foxy-om: see the Foreign.* libraries for the array stuff
01:51:31 <dons> http://www.google.com/tisp/ i particularly like the PHD snorkelling in the sewer with a network cable
01:51:31 <lambdabot> Title: Welcome to Google TiSP
01:52:46 <dmead> hehe yea i saw that too
01:52:56 <dmead> sign me up!
01:53:21 <dmead> but hey, maybe thats some commentary there
01:53:39 <dons> the cool thing is that every house is already connected!
01:54:18 <dmead> =P
01:54:29 <tsp> ack this would be ugly
01:55:00 <tsp> <set lang=eo>vi havas 310 mesagxojn en</set><set lang=en>inbox.</set>
01:55:10 <dmead> what what?
01:55:19 <dons> 'The nanobots travel with exhilarating nano-speed through the sewer system'
01:55:33 <tsp> I want to write a screen reader - more like a speech interface
01:55:42 <tsp> but none of the current ones like esperanto
01:56:01 <dmead> isn't esperanto that made up language?
01:56:16 <Vq^> dmead: isn't all languages made up?
01:56:33 <tsp> dmead: yeah
01:56:37 <tsp> it's cool though
01:56:40 <dmead> ahh
01:56:41 <dmead> yes
01:56:41 <dmead> hehe
01:57:10 <dons> not haskell. its semantics were carved into the structure of the universe
01:57:25 <Vq^> dons: isn't that lisp? :P
01:57:28 <dmead> well
01:57:30 <dmead> no
01:57:37 <dmead> haskell from the structure of the universe
01:57:39 <dmead> err
01:57:41 <dmead> i mean
01:57:45 <dmead> lisp from the structure of the universe
01:57:53 <dmead> haskell is lisp from a human perspective
01:58:09 <dmead> with all the artificial concepts embedded so we can understand it :P
01:58:13 <dons> i think its the other way around ;-) lisp is to haskell as newtonian physics is to ..
01:58:23 <dmead> quantum physics?
01:58:30 <tsp> haskell is just weird
01:58:39 <dons> i was going to say something about strings ..
01:58:42 <tsp> but its better than lisp, not lots of ()s
01:58:50 <dmead> bah, string theory is a load of crap
01:58:57 <dmead> says a physicist pal of mine
01:59:06 <dmead> yea tsp
01:59:08 <dons> i prefer [a] theory!
01:59:20 <dons> free theorems for all!
01:59:21 <dmead> () does not sound nice to listen to i bet
01:59:23 <dmead> hehe
02:00:58 <dmead> tsp: have you thought about trying to write a parser to turn your haskell code into standard format?
02:09:51 <foxy-om> dcoutts, If my foreign code allocates memory should I be using ForeignPtr to refer to it?  When I do {#pointer *Array as Array foreign newtype#} (with the foreign keyword) I get "Couldn't match expected type `Ptr Array' against inferred type `Array'"
02:11:55 <tsp> dmead: standard format? heh
02:12:01 <tsp> dmead: I oculd care less about indenting
02:12:41 <tsp> > ((2**64)-1)/2
02:12:43 <lambdabot>  9.223372036854776e18
02:12:49 <tsp> big number
02:14:36 <dcoutts> foxy-om: if that foreign memory needs freeing and you don't know when your Haskell prog is going to stop needing that foreign memory then you can use a ForeignPtr with a finaliser that frees the memory.
02:14:59 <dcoutts> foxy-om: and that error message is because you asked for a newtype
02:15:21 <dcoutts> it gave you a type declaration like: newtype Array = Array (Ptr Array)
02:15:40 <dcoutts> without newtype is just gives you: type Array = Ptr ()
02:16:02 <dcoutts> so the newtype is usually better since it gives you more type safety
02:16:25 <dcoutts> so you'd just need to wrap / unwrap the ptr in the Array newtype constructor
02:16:50 <foxy-om> so if I have lots of *mxArrays floating around and I need to finalize them what should I do? {#pointer *Array as Array foreign newtype#} ?
02:18:19 <foxy-om> I'm now getting errors: "Couldn't match expected type `Ptr ()' against inferred type `Array'"
02:31:41 <n00b> Hi - I'm writing my first Haskell program, and I'm stuck with eta reduction.
02:31:41 <n00b> Why does this give a type error?
02:31:41 <n00b> summation = sum zipWith (*)
02:31:41 <n00b> summation a b = sum zipWith (*) a b is OK
02:32:30 <foxy-om> :t sum zipWith (*)
02:32:32 <lambdabot>     Couldn't match expected type `[a]'
02:32:33 <lambdabot>            against inferred type `(a1 -> b -> c) -> [a1] -> [b] -> [c]'
02:33:18 <tiglionabbit> n00b: do you mean to say sum (zipWith (*) a b) ?
02:33:24 <foxy-om> :t \a b -> sum zipWith (*) a b
02:33:24 <tiglionabbit> or with a $
02:33:26 <lambdabot>     Couldn't match expected type `[a]'
02:33:26 <lambdabot>            against inferred type `(a1 -> b -> c) -> [a1] -> [b] -> [c]'
02:33:34 <n00b> yes, sorry
02:33:40 <foxy-om> :t sum $ zipWith (*)
02:33:42 <lambdabot>     Couldn't match expected type `[a]'
02:33:43 <lambdabot>            against inferred type `[a1] -> [a1] -> [a1]'
02:33:46 <tiglionabbit> :t sum $ zipWith (*)
02:33:49 <lambdabot>     Couldn't match expected type `[a]'
02:33:49 <lambdabot>            against inferred type `[a1] -> [a1] -> [a1]'
02:33:52 <tiglionabbit> eep
02:34:01 <foxy-om> :t zipWith (*)
02:34:03 <lambdabot> forall a. (Num a) => [a] -> [a] -> [a]
02:34:10 <foxy-om> :t sum
02:34:13 <lambdabot> forall a. (Num a) => [a] -> a
02:34:40 <foxy-om> :t \a b -> sum $ zipWith (*) a b
02:34:43 <lambdabot> forall a. (Num a) => [a] -> [a] -> a
02:34:49 <tiglionabbit> ya that's right
02:35:11 <foxy-om> you can't curry with $ in there methinks
02:37:11 <diffbavis> @pl \a b -> sum $ zipWith (*) a b
02:37:12 <lambdabot> (sum .) . zipWith (*)
02:37:45 <dcoutts> foxy-om: you'd use the foreign fee function when you make the ForeignPtr as for Array vs Ptr (), you need to wrap or unwrap with the Array newtype constructor
02:38:37 <n00b>  (sum .) . zipWith (*) - what's with the double . ?
02:39:33 <dons> ?unpl  (sum .) . zipWith (*)
02:39:34 <lambdabot> (\ d g -> sum (zipWith (*) d g))
02:40:30 <dons> basically, when you want to be 'point free' on two functions, you'll need two (.)'s to soak up the args
02:44:35 <n00b> Not following - won't zipWith (*) take up both arguments, leaving one result?
02:48:40 <n00b> Sorry, that should have been
02:48:40 <n00b> Won't zipWith (*) take up both arguments, leaving one result for sum?
02:51:54 <dolio> Arguing with the dynamic language weenies, eh dons?
02:52:20 <foxy-om> dcoutts, I've got the marshaling to C working [unArray (Array a) = unsafeForeignPtrToPtr a] but when I try marshal from C the function returns a (Ptr Array) and the Array data constructor expects a ForeignPtr... ?
02:54:01 <dcoutts> foxy-om: you don't want to use unsafeForeignPtrToPtr, use withForeignPtr
02:54:25 <dcoutts> and when you get one of these foreign arrays you need to make a new ForeignPtr
02:54:36 <dcoutts> @hoogle newForeignPtr
02:54:37 <lambdabot> Foreign.Concurrent.newForeignPtr :: Ptr a -> IO () -> IO (ForeignPtr a)
02:54:37 <lambdabot> Foreign.ForeignPtr.newForeignPtr :: FinalizerPtr a -> Ptr a -> IO (ForeignPtr a)
02:54:37 <lambdabot> Foreign.ForeignPtr.newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)
02:54:50 <dcoutts> you want Foreign.ForeignPtr.newForeignPtr
03:01:46 <matthew-_> if I want to write portable code that does work on files and needs to run under windoze, should I use the System.Posix stuff?
03:02:28 <n00b> :t zipWith (*)
03:02:30 <lambdabot> forall a. (Num a) => [a] -> [a] -> [a]
03:02:36 <n00b> :t sum
03:02:38 <lambdabot> forall a. (Num a) => [a] -> a
03:03:21 <matthew-_> sheesh, haskell file system functions are a complete mess, scattered all over the place...
03:04:28 <dons> matthew-_: in System.IO and System.Directory?
03:04:39 <tsp> haskell itself is a mess, but has useful features
03:04:52 <tsp> monads are really, really hard to understand - I just want to keep state, but don't know where to look
03:05:19 <dons> they're trivially simple though. 2 operations, 3 laws.
03:05:30 <tsp> heh
03:05:31 <dons> > runState (do x <- get; put (x+1) ; return ()) 7
03:05:32 <lambdabot>  ((),8)
03:05:47 <matthew-_> dons: and prelude and file ops in System.Directory and System.Posix.Files is plural, but System.Posix.Directory is singular...
03:05:57 <dons> simple usage of state are best done in the State monad, tsp.
03:06:03 <foxy-om> @paste
03:06:04 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:06:12 <tsp> where do I find the state monad?
03:06:17 <matthew-_> the findExecutable in System.Directory should probably be in System.Environment...
03:06:22 <dons> ?docs Control.Monad.State
03:06:22 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
03:06:23 <tsp> and how would I access things in it? like variables and such
03:06:37 <dons> you use 'runState' to run some stateful code
03:06:46 <dons> it takes a computation as an argument, and an initial state
03:06:52 <dons> it returns the final state, and any 'return' value
03:07:13 <dons> to access variables, you'd pass data in a record, whose labels would be your variable names.
03:07:21 <dons> e.g. to simulate global variables
03:07:26 <tsp> ah
03:07:28 <tsp> labels?
03:07:35 <tsp> so I could do state.x = 3?
03:07:42 <dons> yeah
03:07:48 <dons> gimme a sec to write an example...
03:08:35 <hpaste>  foxy-om pasted "c2hs marshaling" at http://hpaste.org/1215
03:09:01 * foxy-om prostrates himself
03:09:06 <foxy-om> dcoutts, ^^
03:09:48 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1216
03:09:50 <hpaste>  foxy-om annotated "c2hs marshaling" with "with C code" at http://hpaste.org/1215#a1
03:10:04 <tiglionabbit> I'm trying to compile frag, but it says this:  http://hpaste.org/1216
03:10:14 <tiglionabbit> oh, hpaste just notified :P
03:10:39 <nominolo> dons: do you have some shortcuts for common code examples?
03:10:53 <nominolo> i'm having a strange deja vu
03:11:00 <nominolo> (about the runState example)
03:11:18 <dcoutts> foxy-om: you don't say what the error is but I'm guessing that it's a type error with your marshalers. You need to tell c2hs that your marshalers are monadic rather than pure. See the c2hs manual/tutorial.
03:11:23 <nominolo> @example runState
03:11:23 <lambdabot> Unknown command, try @list
03:11:44 <nominolo> would be a nice lambdabot feature, i think
03:12:14 <tsp> > @src +
03:12:14 <lambdabot>  Parse error
03:12:23 <tsp> heh, + is built into haskell
03:12:28 <tsp> I assume anyway
03:12:31 <hpaste>  foxy-om annotated "c2hs marshaling" with "With error message" at http://hpaste.org/1215#a2
03:12:32 <nominolo> @src (+)
03:12:33 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
03:12:54 <doserj> ?src Num
03:12:55 <lambdabot> class  (Eq a, Show a) => Num a  where
03:12:55 <lambdabot>     (+), (-), (*)           :: a -> a -> a
03:12:55 <lambdabot>     negate, abs, signum     :: a -> a
03:12:55 <lambdabot>     fromInteger             :: Integer -> a
03:13:03 <tiglionabbit> umm
03:13:04 <dolio> @src Int (+)
03:13:04 <lambdabot> Source not found. Take a stress pill and think things over.
03:13:06 <nominolo> oh, lb got a lesson on friendlyness?
03:13:07 <tiglionabbit> any help here?
03:13:17 <tiglionabbit> I wanna see this thing running
03:13:40 <foxy-om> @where c2hs manual
03:13:40 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
03:14:01 <dons> + is part of the Num class
03:14:14 <dons> you can thus define your own + for any type you add to num
03:14:33 <hpaste>  dons pasted "tsp state monad example" at http://hpaste.org/1217
03:14:35 <foxy-om> dcoutts, I'm using the manual and I don't see anywhere about declaring marshallers monadic
03:14:55 <dons> tsp, see http://hpaste.org/1217 for a simple state variable
03:15:05 <dcoutts> foxy-om: it's something like that they take an extra * to indicate it
03:15:19 <dolio> @where frag
03:15:19 <lambdabot> http://www.haskell.org/haskellwiki/Frag
03:15:20 <tsp> interesting
03:15:28 <dons> simulates a 'global' variable 'x' with scope restricted to the contents of the runState function
03:15:36 <tsp> S i isn't defined anywhere - and I didn't think vars could have spaces
03:15:37 <n00b> @where lambdabot
03:15:37 <lambdabot> Right here! Seriously, though: http://www.cse.unsw.edu.au/~dons/lambdabot.html
03:15:50 <dons> S is defined locally, data S = S { x :: Int }
03:15:56 <foxy-om> dcoutts, whoops, it's there
03:15:56 <dcoutts> foxy-om: it's described here: http://www.cse.unsw.edu.au/~chak/haskell/c2hs/docu/c2hs-2.html#ss2.7
03:15:58 <lambdabot> Title: The Binding Generator C->Haskell: Implementation of Haskell Binding Modules, http://tinyurl.com/j64dt
03:15:58 <dons> as you add more state, you add more fields to the state type, S
03:16:28 <tsp> ah
03:16:37 <tsp> wow, you can use S before it's defined?
03:16:41 <dons> tsp, so with a state monad you specify precisely which variables are to act as globals, and their scope, by writing a state type.
03:16:48 <dons> sure. haskell doesn't care about declaration order
03:17:08 * tiglionabbit feels ignored
03:17:32 <tsp> ah
03:17:50 <dons> more haskell practice required before you get to say 'haskell itself is a mess', tsp :-)
03:17:57 <tsp> if I was writing, say, a game, it would store your coordinates, hp, etc
03:18:00 <tsp> cool
03:18:02 <dons> yeah.
03:18:07 <dolio> tiglionabbit: At a glance, I'd say the API for Data.Array has changed.
03:18:12 <tsp> all passed in a convenient variable
03:18:19 <dons> exactly, for example, the Xmonad window manager stores the screen size and window geometry in a state monad
03:18:39 <tsp> neat
03:18:59 <tiglionabbit> dolio: I'm using ubuntu packages for ghc and hopengl.  Perhaps they're out of date?  Any way to check?
03:19:02 <tsp> given all that, data S = S {...} is the same as C's #define? I could replace the S with the S {...}?
03:19:04 <dons> what is mutable state anyway? it is just a set of global variables that are threaded through the code.
03:19:22 <dolio> tiglionabbit: Actually, I think it's more likely that frag is out of date.
03:19:33 <tiglionabbit> really?  =\
03:19:35 <dons> tsp, hmm? no, that's a struct definitoin
03:20:11 <dons> its declaring a new type S, which is a data structure introduced with the 'S' constructor (same name as the type), of one field, x, of type Int
03:20:24 <psykotic> tsp: it's worth noting that the name S serves double duty here as a type and a kind of constructor
03:20:28 <psykotic> ah, lost the typing race
03:20:36 <dons> you *could* say S 7 which is the same as saying S { x = 7 }, in this case, since there's only one field
03:20:48 <tsp> ack
03:20:57 <tsp> why do I need to type S twice?
03:21:04 <dolio> Oh.
03:21:07 <tsp> would data S = { x :: int } be the same?
03:21:27 <dolio> tiglionabbit: Try this: add 'import Data.Array.MArray' to the import declarations in BitSet
03:21:45 <dons> tsp, no, you always need to specify the constructor, since it is possible to have multiple variants
03:21:54 <tsp> hmm
03:22:04 <Cale> (and there would be no way to infer the type otherwise)
03:22:06 <dons> data MyType = S Int | T Bool Int | U Char
03:22:22 <dons> and there would be no way to distinguish type Int from type S, as Cale says
03:22:23 <tiglionabbit> dolio: didn't appear to change anything
03:22:31 <tiglionabbit> do you guys have frag working?
03:22:46 <dons> tiglionabbit: i've got frag working (I'm the sort-of maintainer)
03:22:50 <dons> but haven't built it recently
03:22:59 <dons> we do have 2 students working on it this year though.
03:23:12 <dons> specifically on better AI , I think
03:23:25 <Cheery> who was doing that prolog -thing on haskell?
03:23:32 <tiglionabbit> dons: do you have a working build?
03:23:37 <dons> tsp, have you read YAHT?
03:23:44 <tiglionabbit> I downloaded it from darcs, which is probably a bad idea
03:23:49 <dons> what are some other good resources. oh, the wikibook.
03:23:57 <dons> tiglionabbit: that's the only way to get frag :-)
03:24:04 <tiglionabbit> aren't there like, tags?
03:24:05 <tiglionabbit> anywhere?
03:24:19 <dons> not yet. its just a snapshot of the end of thesis result the original author had.
03:24:30 <dons> there's been very little development since Mun finished his thesis
03:24:36 <dons> i've accepted a couple of patches, that's about it.
03:24:40 <tiglionabbit> hm
03:24:49 <dons> so its possible it is missing some ghc 6.6-issm
03:24:56 <tiglionabbit> how does darcs compare to svn?
03:25:07 <dons> similar, supports offline and cherry picking better.
03:25:09 <tsp> I tried data S = S { x :: int; y :: int }
03:25:11 <tsp> but it died
03:25:16 <dons> every haskell project uses it.
03:25:18 <dons> tsp, int /= Int
03:25:24 <dons> case matters.
03:25:31 <n00b> @pl \v \w -> 1 / (1 + exp (-fromIntegral(summation v w)))
03:25:31 <lambdabot> (line 1, column 4):
03:25:31 <dons> data S = S { x :: Int , y :: Int }
03:25:31 <lambdabot> unexpected "\\"
03:25:31 <lambdabot> expecting operator, pattern or "->"
03:25:38 <dons> tsp, you're making up syntax as you go ;-)
03:25:49 <tsp> dons: the cods are pieceso f crap
03:25:51 <tsp> docs
03:26:00 <tsp> edbrowse wants nothing to do with them :)
03:26:05 <nominolo> Anyone celebrated Haskell's 17th birthday, today?
03:26:13 <dons> oh yes!
03:26:21 <tiglionabbit> cherry picking?
03:26:23 <tsp> dons: haskell has been around for 17 years? wow
03:26:24 <dons> HAPPY 17th BIRTHDAY HASKELL!
03:26:36 <dons> April 1 1990
03:26:37 <nominolo> \o/
03:26:49 <dons> anyone in here younger than haskell?
03:26:54 <dons> sorear is , I think.
03:27:29 <tiglionabbit> dons: any chance you could build it now and magically make it work, so that I may see it?
03:27:40 <dolio> tiglionabbit: Are you on ubuntu edgy?
03:27:42 <dons> tiglionabbit: there are screenshots on the wiki, aren't there?
03:27:43 <tiglionabbit> yep
03:27:47 <dons> ?where Frag
03:27:48 <lambdabot> http://www.haskell.org/haskellwiki/Frag
03:27:54 <dons> you just want to see some screenshots?
03:27:56 <tiglionabbit> yeah but I want to be able to mess with the source
03:28:00 <n00b> @pl \v w -> 1 / (1 + exp (-fromIntegral(summation v w)))
03:28:00 <lambdabot> (((1 /) . (1 +) . exp . subtract . fromIntegral) .) . summation
03:28:01 <dolio> tiglionabbit: I may have been wrong. getBounds is 6.6, it seems, and edgy is on 6.4.
03:28:10 <tiglionabbit> ad
03:28:11 <dons> oh, its getbounds error is it?
03:28:11 <tiglionabbit> *ah
03:28:18 <tiglionabbit> that's what I was thinking
03:28:20 <dons> yeah, you replace that with a call to 'bounds' iirc.
03:28:27 <dons> or the other way around.
03:28:29 <dolio> tiglionabbit: You can try changing 'getBounds' to 'bounds'. I'm not 100% sure that will fix it, though.
03:28:42 <tiglionabbit> wouldn't it be better to get the new version of the library?
03:28:44 <goban> dons, was haskell really invented on april fools
03:28:58 <tiglionabbit> XD would make sense
03:28:59 <matthew-_> is there anyway to populate getArgs using ghci?
03:29:07 <dons> well, no, the initial language design document was released on april 1
03:29:08 <goban> or are YOU fooling us
03:29:17 <dons> matthew-_: yeah, :set args foo -- iirc
03:29:20 <nominolo> goban: Haskell 1.0, was released then, yes
03:29:25 <matthew-_> dons: cheers
03:29:27 <goban> dons, hahaha cool
03:29:29 <dolio> tiglionabbit: Unless you feel like upgrading to feisty, getting the new version might be a pain.
03:29:41 <tiglionabbit> dolio: howso?
03:30:01 <dolio> You'd either need to find edgy packages for GHC 6.6, or compile it yourself.
03:30:12 <dolio> And I don't know of the former existing.
03:30:32 <dons> here's a copy of the initial haskell announcment, April 1 1990. http://groups.google.com/group/comp.lang.functional/msg/a5cc6ac1df70e358?hl=en&
03:30:34 <lambdabot> Title: Is Haskell available? - comp.lang.functional | Google Groups, http://tinyurl.com/ygg7jd
03:30:34 <nominolo> goban: http://research.microsoft.com/~simonpj/papers/history-of-haskell/index.htm [PDF]
03:30:37 <lambdabot> Title: A History of Haskell, http://tinyurl.com/yowkle
03:30:45 <dons>   The Haskell Committee, formed in September 1987 to design a "common"
03:30:45 <dons>   non-strict purely functional language, has (finally) completed its work
03:30:46 <dons>   and wishes to announce a Report about the language.
03:30:58 <dons>   Two implementations of Haskell will soon be available, one built at the
03:30:58 <dons>   University of Glasgow, the other at Yale University.
03:31:12 <dons> the first is referring to GHC, the second is Yale Haskell, which was made obsolete around 1994.
03:31:15 <goban> microsoft research invented haskell?
03:31:21 <dons> HBC was also released at around this time.
03:31:44 <dons> goban: nope, but a few of the original designers now work for microsoft's language research branch
03:32:02 <dons>   To add to Paul's message from Monday, please could you make cheques
03:32:02 <dons>   payable to "The Haskell Project" if ordering the report from Yale
03:32:02 <dons>   or "University of Glasgow" if ordering from Glasgow.
03:32:03 <tiglionabbit> gosh, I'm trying to find out what the versions are named now
03:32:05 <dons> hehe.
03:32:12 <tiglionabbit> they don't put the animal names up on the site in big letters anymore
03:32:22 <dolio> Heh.
03:32:47 <dolio> Feisty should be coming out this month, so if you can wait, that might be the easiest method.
03:33:06 <tiglionabbit> okay, good idea
03:33:35 <dolio> You might want to switch the getBounds for bounds right now anyway.
03:33:43 <dolio> That might be the only change necessary, and you could play now.
03:33:56 <dolio> And if that doesn't work, you could always try again later.
03:34:05 --- mode: ChanServ set +o dons
03:34:10 --- topic: set to '["The Haskell programming language: Happy 17th birthday, Haskell!","The Summer of Code is on","http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]' by dons
03:34:14 --- mode: ChanServ set -o dons
03:34:59 <tiglionabbit> I keep thinking about languages, trying to design what I think would be the best way to solve certain problems and make code compact and readable, and I keep ending up with haskell-isms....
03:37:13 <foxy-om> @karma+ dcoutts
03:37:13 <lambdabot> dcoutts's karma raised to 44.
03:37:31 <dcoutts> foxy-om: you got it working I take it? :-)
03:37:38 <foxy-om> :)
03:41:54 <tiglionabbit> yeah, bounds is not the same type as getBounds
03:42:02 <tiglionabbit> :t bounds
03:42:05 <lambdabot> forall i e. (Ix i) => Array i e -> (i, i)
03:42:07 <tiglionabbit> :t getBounds
03:42:10 <lambdabot> Not in scope: `getBounds'
03:42:14 <tiglionabbit> ...?
03:43:04 <xerox> ?index getBounds
03:43:04 <lambdabot> bzzt
03:43:10 * mux has fun with april fools commits :-)
03:43:26 <hpaste>  tiglionabbit pasted "getBounds != bounds" at http://hpaste.org/1218
03:43:48 <xerox> :t liftM2 (,) minBound maxBound
03:43:51 <lambdabot> forall a1 a2 (m :: * -> *). (Bounded (m a1), Bounded (m a2), Monad m) => m (a1, a2)
03:43:58 <xerox> auhm.
03:44:11 <tiglionabbit> is that what I want?
03:44:32 <xerox> nope
03:44:52 <xerox> or yes?
03:45:14 <xerox> > let getBounds = liftM2 (,) minBound maxBound in getBounds (undefined :: Int)
03:45:15 <lambdabot>   add an instance declaration for (Bounded (Int -> a2))
03:45:57 <tiglionabbit> @src liftM2
03:45:58 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
03:46:49 <tiglionabbit> =\ stil not right
03:46:53 <xerox> ah
03:46:57 <xerox> gotcha
03:47:44 <sekr_veled> hey guys
03:47:46 <doserj> tiglionabbit: try sizeBS (BitSet bs) = return . rangeSize . bounds $ bs
03:48:17 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1219
03:48:22 <xerox> > let getBounds = ((minBound,maxBound) `asTypeOf`) . (join (,)) in getBounds (undefined :: Int)
03:48:24 <lambdabot>  (-2147483648,2147483647)
03:48:31 <xerox> gotta dash~~
03:48:35 <sekr_veled> i'm very new to haskell and trying to figure it out
03:49:07 <sekr_veled> i'm trying to write a very basic 2-SAT solver
03:49:56 <sekr_veled> data Formula = Atomic Char | Disjunction Formula Formula | Conjunction Formula Formula | Negation Formula
03:50:04 <sekr_veled> i've started with this kind of data
03:50:15 <sekr_veled> and trying to convert it to DNF
03:50:19 <dolio> tiglionabbit: If I'm reading the old docs correctly, the correct code should probably be...
03:50:31 <tiglionabbit> @karma+ doserj
03:50:32 <lambdabot> doserj's karma raised to 1.
03:50:46 <sekr_veled> but all my tries ended with an infinite loop
03:50:56 <dolio> tiglionabbit: Oh, nevermind, your problem was already solved. :)
03:51:05 <tiglionabbit> =] I think so.  It's compiling happily
03:51:20 <tiglionabbit> we'll know in a moment
03:52:00 <tiglionabbit> eep, lots of warnings
03:52:24 <sekr_veled> i think it's because of the rule dNF (Conjunction xs ys) = (dNF (Conjunction (dNF xs) (dNF ys)))
03:52:54 <sekr_veled> which i have to do i think since the inner Formula again has a Disjunction
03:53:37 <nornagon> @where vty
03:53:37 <lambdabot> http://members.cox.net/stefanor/vty/
03:54:10 <sekr_veled> any one that can help?
03:56:20 <tiglionabbit> okay which files are the levels?
03:56:59 <tiglionabbit> oh I see, it's a name that refers to 3 files
03:58:49 <sekr_veled> what shoud i do to get hep here?
03:58:59 <sekr_veled> help*
04:00:24 <astrolabe> sekr_veled: you are doing the right thing
04:00:35 <astrolabe> (about getting help)
04:00:56 <sekr_veled> astrolabe: so why no body cares ?
04:01:15 <astrolabe> probably those who could understand haven't read it yet
04:01:22 <doserj> sekr_veled: @paste it
04:01:33 <sekr_veled> maybe..
04:01:59 <sekr_veled> i have a data structuredata Formula    = Atomic Char | Disjunction Formula Formula | Conjunction Formula Formula | Negation Formula
04:02:09 <sekr_veled> for a 2-sat solver
04:02:11 <doserj> @paste
04:02:12 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:02:57 <doserj> It's difficult to say what you are doing wrong withoud seeing what you are doing...
04:03:06 <sekr_veled> ok
04:03:13 <sekr_veled> how can i paste all the code
04:03:24 <matthew-_> in the haddock for System.Process, why does the example for runInteractiveProcess have a fork?
04:03:24 <matthew-_> (inp,out,err,pid) <- runInteractiveProcess "..."
04:03:25 <matthew-_>    forkIO (hPutStr inp str)
04:03:49 <matthew-_> why is the fork at all necessary?
04:03:49 <astrolabe> sekr_veled: if there is a lot of code, it would be a good idea to find a smallish subset that gives the same problem
04:04:33 <sekr_veled> ok.. should i use the hpaste thing?
04:04:40 <astrolabe> yeah
04:05:20 <hpaste>  sekr pasted "dNF" at http://hpaste.org/1220
04:05:39 <sekr_veled> http://hpaste.org/1220
04:06:42 <sekr_veled> the main problem is to produce the logical values which should be true for the statement in the form data Formula
04:06:51 <lizhn> hello, i want to use ByteString, can i just  replace all occurrences of String with B in my code ?
04:07:37 <dcoutts> lizhn: so long as you don't need to use [] or (:) and do not rely on the lazyness of String, then yeah mostly
04:08:18 <sekr_veled> i've read in Wikipedia that DNF is most suitable for 2-SAT
04:08:21 <lizhn> dcoutts: oh, thanks you.
04:08:40 <sekr_veled> so i'm first trying to have a dNF form of the Formula
04:08:46 <astrolabe> sekr_veled: It's not the problem, but you don't need ( ) round the rhs of your equations
04:09:22 <sekr_veled> ok
04:09:59 <sekr_veled> this is what i'm used to from Java =)
04:11:26 <astrolabe> sekr_veled: this line dNF (Conjunction xs ys) = (dNF (Conjunction (dNF xs) (dNF ys)))
04:12:03 <astrolabe> this doesn't simpligy the formula, it makes it more complicated I think
04:12:11 <astrolabe> *simplify
04:12:31 <sekr_veled> yes i think so but i couldnt solve
04:12:41 <foxy-om> any matlab/octave users out there?
04:12:50 <matthew-_> how are you meant to use hGetContents - the laziness and semiclosed handle state seem to cause endless problems.
04:12:50 <astrolabe> maybe you meant    dNF (Conjunction xs ys) = Conjunction (dNF xs) (dNF ys)
04:13:07 <sekr_veled> for that parameters
04:13:16 <sekr_veled> the dNF of the xs can be
04:13:24 <sekr_veled> (Disjunction xs ys)
04:13:40 <sekr_veled> which makes the outer again something that is not dNF
04:13:59 * astrolabe looks up DNF
04:14:21 <sekr_veled> am i wrong?
04:15:23 <astrolabe> sekr_veled: My suggestion was wrong
04:15:46 <hpaste>  matthew-_ pasted "Why does hGetContents do the annoying lazy thing making the `seq` necessary?" at http://hpaste.org/1221
04:16:16 <astrolabe> sekr_veled: why can't you delete that case altogether?
04:17:09 <astrolabe> sekr_veled: hang on, I think I'm getting it
04:17:30 <astrolabe> I think my suggestion was right
04:18:50 <sekr_veled> so dNF (Conjunction xs ys) = Conjunction (dNF xs) (dNF ys)
04:19:02 <sekr_veled> without deleting the case?
04:19:37 <astrolabe> um.  Sorry, still thinking
04:20:24 <astrolabe> Your choice of cases seems a bit strange to me
04:21:06 <astrolabe> It is a bit hard to see that they are exclusive
04:21:18 <astrolabe> er or inclusive
04:21:31 <sekr_veled> i dont really know if i'm doing the wright thing
04:22:38 <dons> matthew-_: either you program for lazy IO, or your use strict IO. if you are coding for strict IO, but using lazy stuff, then things will be a little weird.
04:22:40 <sekr_veled> i read in wikipedia that DNF can be formed with de-morgan's, double negation and distribution of ORoverAND
04:22:57 <sekr_veled> so this is what i'm trying to do indeed
04:23:04 <dons> matthew-_: note that Data.ByteString.* provides strict IO, as does length s `seq return () on the lazy IO string.
04:23:12 <n00b> @pl \w v -> 1 / (1 + exp (- summation w v))
04:23:12 <lambdabot> (((1 /) . (1 +) . exp . subtract) .) . summation
04:23:48 <matthew-_> dons: indeed. I'm utterly unused to lazy IO. You'd say doing length s `seq` return () is better than s `seq` return () ?
04:24:22 <dons> yes, because `seq` only reduces to the outermost constructor
04:24:30 <dons> i.e. (_:_) form for lists
04:24:35 <matthew-_> gotcha.
04:24:38 <dons> so you only force the first Char on the string.
04:24:41 <matthew-_> yep.
04:24:46 <dons> last s or length s will consume the lot though
04:24:56 <doserj> sekr_veled: youd dNF (Atomic ...) and dNF (Disjunction ...) seem ok
04:25:21 <doserj> dNF (Negation ...) seems wrong
04:25:35 <matthew-_> dons: hGetContents is the only IO thing I've come across which is giving me issues due to laziness. Is it unique like that or have I just not noticed it elsewhere?
04:25:44 <dons> what issues are you having?
04:26:21 <dons> it would only be an issue if you attempted to open a lot of files without consuming them (you'll run out of FDs), or if you try to write to the same file you're reading from lazily.
04:26:23 <sekr_veled> i think it doesnt matter
04:26:27 <matthew-_> well, if I'm "good" and close handles *even after calling hGetContents* then the result of hGetContents is nothing
04:26:31 <dons> (i.e. treating the file as a true mutable variable)
04:26:37 <doserj> always think about that the result of dNF (something) should be in dNF
04:26:39 <dons> that's not good though. :-)
04:26:46 <dons> you don't mix hClose with lazy IO.
04:26:55 <sekr_veled> because i handle dNF as dnf(revFormula formula)
04:26:56 <matthew-_> dons: So I've noticed ;-)
04:26:59 <dons> since it just closes the handle, and what you have read depends on how much you've demanded
04:27:13 <matthew-_> dons: it says it "semi-closes" the handle
04:27:14 <dons> hClose is really for strict IO, since you need to know you've evaluated the input to a certain depth first.
04:27:19 <doserj> oh...
04:27:30 <sekr_veled> so revFormula has always Negation over Atomic
04:27:32 <dons> hGetContents does, yes.
04:27:39 <matthew-_> ok, so there's no strict equivalent of hGetContents then?
04:27:43 <dons> meaning you can't read from the handle.
04:27:53 <matthew-_> I'd have to use hGetLine until I hit an error?
04:27:55 <dons> sure , hGetContents >>= \s -> length s `seq` return s
04:28:01 <dons> that's strict hGetContents
04:28:06 <nornagon> vty doesn't seem like a very good option for a roguelike; the docs tell me doing single character writes is likely to be inefficient
04:28:07 <matthew-_> yep, ok, if that's the "work around"
04:28:09 <sekr_veled> it is useless though to even have Negation xs because xs is just Atomic =)
04:28:25 <dons> well, its writing the strict version using the lazy one. that's just how you do it, its not really a work around.
04:28:42 <dons> but why are you hClosing anyway?
04:28:47 <dons> if you're trying to do lazy IO?
04:28:55 <matthew-_> I'm not trying to do lazy IO
04:28:57 <dons> just let the GC close the handle once you've read all the data
04:28:58 <matthew-_> I want strict IO
04:29:24 <dons> ok. why?
04:29:33 <matthew-_> and my mummy always told me to clean up after myself, including file handles!
04:29:35 <dons> are you mutating the file? or have precise resource constraints?
04:29:36 <doserj> ok, so after refFormula all Negations are inside
04:30:00 <dons> note that the lazy IO will close its handle automatically
04:30:05 <dons> its not necessary to do that by hand.
04:30:07 <sekr_veled> maybe there is some other way to get the assignments which makes Formula true
04:30:15 <matthew-_> no, hang on. If I think about it, I don't actually need strict IO. Ok, so I'll drop the hClose calls and everything works.
04:30:16 <doserj> then dNF (Conjunction should actually be auite easy
04:30:21 <QtPlatypus> matthew-_: The whole point of having a GC is that it handels cleaning up resorces for you.
04:30:35 <astrolabe> sekr_veled: I think I have it
04:30:59 <matthew-_> QtPlatypus: most GCs I know only clean memory, not file handles
04:31:02 <dons> matthew-_: right. using hClose is a bit like using 'free()' with GC-llocated memory. you're mixing two different resource management systems.
04:31:10 <mux> nice, I didn't know GHC 6.7 had indexed data types
04:31:11 <doserj> just keep the distributive laws, that you alread have
04:31:13 <sekr_veled> solve2SAT (Conjunction (Disjunction (Atomic 'a') (Negation (Atomic 'b'))) (Atomic 'c')) returns "ac"
04:31:15 <matthew-_> dons: ahh, ok, that makes lots of sense.
04:31:18 <dons> a Handle is just a object in memory with a finaliser attached :-)
04:31:18 <doserj> otherwise, do nothing
04:31:19 <astrolabe> sekr_veled: You don't need to check for atomics, they should be the default
04:31:21 * mux learns about the new GMap lib
04:31:50 <matthew-_> yep, true enough.
04:31:58 <dons> so yes, Haskell does let us use the GC to manage all sorts of resources
04:32:09 <matthew-_> ok, well that works fine. Thanks for your patience. ;)
04:32:23 <dons> foreign ptrs are another example, you attache a finaliser which is an arbitrary action run by the GC when a resource is deallocated
04:32:30 <sekr_veled> astrolabe: which atomics, dNF (Conjunction (Atomic a) (Atomic b)) ?
04:32:41 <dons> so you can, say, run C's munmap on an object created with mmap.
04:32:52 <matthew-_> yep. How do you attach finalizers to stuff?
04:32:56 <dons> there's all sorts of resource managment like this you can ask the GC to do.
04:32:59 <dons> ?hoogle finaliser
04:33:00 <lambdabot> No matches found
04:33:08 <dons> ?hoogle Finaliser
04:33:08 <lambdabot> No matches found
04:33:10 <matthew-_> ?hoogle finalizer
04:33:11 <lambdabot> Foreign.Marshal.Alloc.finalizerFree :: FinalizerPtr a
04:33:12 <lambdabot> Foreign.ForeignPtr.FinalizerPtr :: type FinalizerPtr a
04:33:12 <lambdabot> Foreign.Concurrent.addForeignPtrFinalizer :: ForeignPtr a -> IO () -> IO ()
04:33:15 <dons> ah
04:33:16 <dons> hehe
04:33:19 <matthew-_> ew. 'merkin spelling
04:33:36 <sekr_veled> doserj: sorry, i couldnt understand what u really mean
04:33:39 <dons> Foreign.Concurrent.* is a good one. you get a heap allocated object onto some resource
04:33:47 <dons> and attach an arbitrary IO action to run on finalisation
04:33:53 <pejo> dons, can any arbitrary code be attached to the finalizer?
04:34:00 <dons> indeed!
04:34:04 <dons> ghc extension though
04:34:14 <dons> addForeignPtrFinalizer :: ForeignPtr a -> IO () -> IO ()
04:34:36 <dons> hmm. this is probably underexploited.
04:34:53 <dons> there's lots of nice "clean up" actions on resources we could have the GC manage this way
04:35:15 <dons> i've used it to call munmap, but you can probably think of other nice uses
04:35:32 <dons> ?docs Foreign.Concurrent
04:35:33 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Concurrent.html
04:36:11 <foxy-om> dons, following the World Cup?
04:36:19 <hpaste>  astrolabe annotated "dNF" with "(no title)" at http://hpaste.org/1220#a1
04:36:57 <dons> foxy-om: trying to. but only on the radio
04:37:44 <sekr_veled> thanks astrolabe, i'm trying
04:38:00 <astrolabe> sekr_veled: I'm not convinced its complete
04:38:07 <pejo> dons, sounds scary to me, I must say. Guess I should leave the use of it to you. :-)
04:38:41 <dons> i suppose the use of GC to manage mmapped memory is reasonable though.
04:38:41 <doserj> astrolabe: I don't think it works.
04:38:57 <sekr_veled> it doesnt
04:39:07 <sekr_veled> just because the thing that i've told
04:39:08 <sekr_veled> form5 = (Disjunction (Disjunction (Disjunction (Conjunction (Conjunction (Conjunction (Conjunction (Negation (Disjunction (Atomic 'a') (Atomic 'b'))) (Disjunction (Atomic 'a') (Atomic 'b'))) (Disjunction (Atomic 'c') (Atomic 'd'))) (Disjunction (Negation (Atomic 'a')) (Negation (Atomic 'b')))) (Negation (Conjunction (Atomic 'c') (Atomic 'd')))) (Negation (Disjunction (Atomic 'e') ( Conjunction (Atomic 'f')  (Negation (Conjunction (Atomic 'g') (Atomic 'h')))
04:39:17 <doserj> sekr_veled: it is probably easiest with a small helper function
04:39:56 <sekr_veled> doserj: to check if the returned value is still in DNF?
04:40:05 <doserj> you recursivle dNF both arguments, then check whether they are disjunctions, and then apply distributive laws *once*, i.e., not recursively
04:40:30 <astrolabe> sekr_veled: right.  This is suprisingly difficult.  Maybe the whole format is wrong.
04:40:42 <doserj> that is, you apply distributive law recursively, but not dNF
04:40:42 <sekr_veled> yep
04:40:53 <sekr_veled> maybe
04:40:59 <sekr_veled> doserj: i'm trying
04:41:21 <astrolabe> doserj: sounds as though he knows what he's talking about
04:41:33 <n00b> @pl \w v ->sum $ zipWith (*) w v
04:41:33 <lambdabot> (sum .) . zipWith (*)
04:41:41 <sekr_veled> my main problem is to produce the assignments to make the Formula true
04:42:33 <sekr_veled> i first tried to convert it all Conjunctions because then i wouldnt have to deal with a mutual recursive func. which will eval Disj.s
04:43:04 <doserj> find_satisfying_valuation t = map fst (filter (\(v,b) -> b==True) (truthtable t)) -- :)
04:43:23 <sekr_veled> but changing all Disj.s to Conj.s makes the Formula different even though they seem logicly equialent
04:44:22 <sekr_veled> doserj: there can be any combination of Chars in the alphabet which makes the map function unresponsive
04:45:10 <doserj> there are only finitely many in any formula
04:46:21 <doserj> but for formulas with more than a handful variables, it will become slow, yes
04:46:53 <sekr_veled> doserj: i couldnt also understand the syntax. i'm a newbie.. sorry..
04:48:08 <sekr_veled> doserj: can you show on an example how you solve such a Formula?
04:48:25 <doserj> you could only understand it if you knew the type of (truthtable t)
04:48:41 <doserj> (and you still would have to implement it)
04:48:56 <sekr_veled> what is the type of truthtable?
04:49:30 <doserj> in my code snippets, it is truthtable :: Term -> [(Valuation,Bool)]
04:50:20 <doserj> Term is what you call Formula
04:50:35 <doserj> type Valuation = [(String,Bool)]
04:50:52 <sekr_veled> ok so what is the initial conds of truthtable
04:50:56 <doserj> or in you case: type Valuation = [(Char,Bool)]
04:51:05 <doserj> but you should work on your dNF function
04:51:09 <doserj> :)
04:51:50 <sekr_veled> ok i'm just trying to understand
04:53:03 <nominolo> @pl \f w v -> sum $ zipWith f w v
04:53:04 <lambdabot> ((sum .) .) . zipWith
04:53:34 <sekr_veled> so your code snippet takes an initial truthtable to filter the True values
04:54:13 <nominolo> :t foldl (.)
04:54:16 <lambdabot> forall c a. (a -> c) -> [a -> a] -> a -> c
04:55:57 <sekr_veled> ok thanks anyway doserj and astrolabe.. i think i have to study more on it
04:58:16 <hpaste>  (anonymous) pasted "Need suggestions for improving performance" at http://hpaste.org/1222
04:59:31 <lizhn> i forgot filling the author field .... = =
05:05:23 <hpaste>  lizhn annotated "Need suggestions for improving performance" with "i'm the author of the above paste" at http://hpaste.org/1222#a1
05:05:35 <dons> lizhn: you don't like the 'do' notation?
05:05:50 <dons> hmm, and most of those operations are pure anyway
05:06:04 <lizhn> dons: i want to be familiar with >>=
05:06:22 <lizhn> dons: and those monad operation
05:06:32 <lizhn> dons: *operations
05:06:36 <dons> ok. do you need to use a regex lib instead?
05:06:51 <lizhn> dons: do you mean change backend?
05:07:01 <dons> anyway, i'll jsut do a quick rewrite, see if that suggests anything.
05:07:20 <lizhn> dons: very thanks
05:07:21 <dons> oh, 50MB, definitely you should use ByteStrings instead
05:07:26 <dons> not [Char]
05:07:46 <lizhn> but i've heard that B can't be used in : and []
05:07:47 <dons> should be perfectly possible to get C++-ish performance that way, assuming you use similar algorithms
05:07:55 <dons> you can't pattern match
05:08:01 <dons> you do have cons and empty.
05:08:16 <dons> so there are equivalents
05:09:23 <lizhn> what do you mean 'equivalents'?
05:10:11 <Cheery> why there's no 'prefixes' in haskell?
05:10:24 <dons> hmm?
05:10:29 <Cheery> or, uhm, nvm.
05:10:55 <Cheery> dons: prefixes like they'd appear to enclose the thing after them unless put into ()
05:11:16 <dons> lizhn: note you're doing many many traversals of this data
05:11:33 <dons> Cheery: do you have an example? i don't understand.
05:11:34 <lizhn> dons: yes
05:11:59 <Cheery> well, consider next
05:12:05 <Cheery> const Just 1
05:12:09 <Cheery> > const Just 1
05:12:11 <lambdabot>  Add a type signature
05:12:43 <dons> lizhn: this isn't very efficient,     | (read (a !! ord) :: Int) >  (read (b !! ord) :: Int) = GT
05:12:44 <lizhn> dons: i am not sure whether thinking haskell programs like in C-like ones is ok...
05:12:58 <dons> since you should really just read it once when parsing
05:12:58 <Cheery> oh yeah
05:12:58 <matthew-_> dons: speaking of finalizers, is it guaranteed that the finalizer will be run?
05:13:19 <dons> lizhn: also, myCompare ord a b = (read (a !! ord) :: Int) `compare`  (read (b !! ord) :: Int)
05:13:23 <matthew-_> because the java gc says that the finalizer may not be run if the object is never gc'd
05:13:25 <dons> is the same thing as the entire block :-)
05:13:26 <Cheery> > const 1 Just
05:13:27 <lambdabot>  1
05:13:41 <dons> matthew-_: its not guaranteed. its GC :-)
05:13:45 <dons> there are no guarantees
05:13:57 <lizhn> dons: i think i mislead what laziness is
05:14:02 <Cheery> I don't prefer type constructors would be prefixes, I think it'd suck
05:14:15 <dons> lizhn: well, it just means results won't be computed till you need them
05:14:26 <dons> it *doesn't* mean that doing lots and lots of expensive operations won't be expensive :-)
05:14:34 <dons> for example, !! to index lists is O(n)
05:14:49 <dons> it would be better to put the strings into an IntMap or some other structure with better complexity on indexing
05:14:57 <lizhn> dons: lol , you get my intent
05:15:10 <dons> also, the String-based regex is very slow
05:15:19 <dons> much better to use bytestring-based regex-pcre or regex-posix
05:15:30 <lizhn> dons: i thought compiler will expand the code after all....
05:15:44 <dons> expand?
05:16:07 <lizhn> dons: and then simplify it like we reduce math formulas...
05:16:11 <Cheery> dons: think of a prefix, say it's a,   then, f a b  would turn to  f (a b)
05:17:06 <Cheery> but I thought it'd may have something one does not like about
05:17:10 <dons> lizhn: well, there's some optimistoins that work like that, yes.
05:18:11 <dons> lizhn: also, you recompute the regex each time
05:18:21 <lizhn> dons: i've thought to profiling it, but i am not sure it can work even if i press CTRL+C...
05:18:49 <lizhn> dons: that regex parts really expensive ...
05:19:19 <dons> yeah.
05:19:41 <dons> you must rewrite it to use, for example, regex-pcre or regex-posix with bytestrings instead
05:19:53 <dons> it will be too slow on 50MB with [Char]
05:20:14 <hpaste>  dons pasted "quick clean up (untested)" at http://hpaste.org/1223
05:20:26 <dons> ^^ that's jsut a quick clean up, but i didn't type  check it.
05:20:49 <lizhn> dons: in this case , is it possible not to do so many regex matching?
05:21:06 <dons> the regexes look very simple
05:21:11 <dons> maybe you can just use string matching?
05:21:15 <dons> ^@U: ?
05:21:21 <dons> so just a string of prefix "@U:" ?
05:21:22 <lizhn> that's delimiter
05:21:34 <lizhn> or title of the paragraph
05:21:35 <dons> ah, you split on those delimiters
05:21:53 <dons> yeah, still there's no need to use regexes for splitting on string contstants.
05:22:03 <dons> i'd probably use lazy bytestrings with a custom split function
05:22:38 <lizhn> that split function can suport 'string' delimiter rather than 'char' one ?
05:22:46 <dons> sure.
05:22:51 <dons> :t isPrefixOf
05:22:53 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
05:22:56 <dons> just generalise that.
05:23:10 <lizhn> let me try your clean version first ....
05:23:45 <dons> i wrote a rather scary (and very fast) =~ that uses isPrefixOf on bytestrings recently,
05:23:48 <dons> s =~ pref = go s
05:23:50 <dons>     where go !s | S.null s              = Nothing
05:23:53 <dons>                 | pref `S.isPrefixOf` s =
05:23:56 <dons>                     let hdr  = S.drop (S.length pref) s
05:23:58 <dons>                         rest = S.takeWhile matches hdr
05:24:01 <dons>                     in if S.null rest then Nothing else Just (B.fromChunks [rest])
05:24:04 <dons>                 | otherwise = go (S.unsafeTail s)
05:24:07 <dons> that just says if a string constant is a sub string of the current string
05:24:12 <dons> you could then use that to split
05:24:19 <dons> (advanced haskell though, I must admit)
05:24:45 <dons> lizhn: i think my version would only be a little faster.
05:25:02 <dons> it just recompiles the regex only once, and uses a slightly more efficient compareBy function
05:25:26 <lizhn> hmmm,
05:26:00 <lizhn> thanks anyway.....
05:27:25 <lizhn> dons: if i use profiling , can i press CTRL+C before it finish?  would produce 'partial' result?
05:30:58 <ndm> @seen sorear
05:30:59 <lambdabot> I saw sorear leaving #darcs, #haskell-overflow, #ghc and #haskell 3h 48m 42s ago, and .
05:44:40 <Cheery> what license for combinator modules does haskell community prefer?
05:45:09 <ndm> Cheery: we prefer BSD3, because we are sponsored by Microsoft
05:45:35 <Cheery> what is BSD3?
05:46:15 <ndm> Cheery: do what you want with the code, apart from pretending you wrote it
05:47:14 <Cheery> hmm
05:48:53 <Cheery> if I'd put this code to GPL, it'd basically mean the guys using it should either get an another license or release code they derived from my work
05:50:57 <Cheery> oh well, I guess the BSD3 should be ok
05:51:55 <Cheery> this thing in the end is just one or two days work
05:53:36 <ndm> Cheery: some people choose to pick the GPL, for somethings - Hoogle is
05:53:47 <foxy-om> does BSD3 allow free derivatives but require licence for commercial use?
05:54:05 <ndm> nope
05:54:12 <ndm> it allows _everything_
05:54:41 <ddarius> Well Hoogle is more of an application than a library, yes?
05:54:43 <foxy-om> are there any licences like that (free for free but require licence for commercial)?
05:55:12 <ndm> yes, Creative Commons lets you pick that
05:55:16 <ndm> ddarius: yes, a program
05:55:17 <Cheery> foxy-om: depends how you define commercial
05:55:27 <ndm> foxy-om: with CC you can pick exactly what you want
05:55:32 <rahikkala> There's also multilicensing
05:55:37 <Cheery> if you define commercial as a selling of that product, GPL prohibits it
05:55:55 <rahikkala> That is, you release your software under several different licenses
05:55:59 <ndm> although FSF don't reconise things that choose between as open source (because they are idiots)
05:56:15 <ndm> Cheery: no it doesn't, it just requires you let your users resell it
05:56:29 <rahikkala> Cheery: GPL prohibits commercial use? Where?
05:56:49 <kfish> ndm: CC licenses are not recommended for sourcecode, but they provide logos etc. for GPL licensing
05:56:59 <foxy-om> rahikkala so how do I release code that is free for nonprofit and requires licensing if used in commercial products?
05:57:06 <Cheery> but if you define it as using or providing services with it, it doesn't
05:57:18 <rahikkala> Cheery: http://www.gnu.org/licenses/gpl-faq.html#DoesTheGPLAllowMoney
05:57:20 <lambdabot> Title: Frequently Asked Questions about the GNU GPL - GNU Project - Free Software Found ...
05:57:43 <ndm> kfish: they are designed for source code
05:57:48 <ndm> kfish: and everything
05:58:06 <ndm> foxy-om: go to the CC website, select those options, and you end up with a license
05:58:23 <foxy-om> @google Creative Commons
05:58:25 <lambdabot> http://creativecommons.org/
05:58:25 <lambdabot> Title: Creative Commons
05:58:58 <kfish> http://wiki.creativecommons.org/FAQ#Can_I_use_a_Creative_Commons_license_for_software.3F
05:59:00 <lambdabot> Title: Frequently Asked Questions - CcWiki, http://tinyurl.com/ydgwsu
05:59:21 <rahikkala> foxy-om: Well, 1. that's actually not a good idea because the commercial/nonprofit distinction is orthogonal to software freedom, 2. consult a lawyer and write or find a suitable license :p
06:02:09 <ndm> @pl \(x,y) -> x ++ y
06:02:09 <lambdabot> uncurry (++)
06:02:37 <ndm> @pl \(x,y) -> f x ++ g y
06:02:37 <lambdabot> uncurry ((. g) . (++) . f)
06:11:16 <xerox> ?type uncurry (++) . (f *** g)
06:11:19 <lambdabot> Not in scope: `f'
06:11:19 <lambdabot>  
06:11:19 <lambdabot> <interactive>:1:22: Not in scope: `g'
06:11:21 <xerox> ops.
06:12:10 <xerox> ?type let (.::) = (.) . (.) . (.) in uncurry (++) .:: (***)
06:12:13 <lambdabot> forall a b b'. (b -> [a]) -> (b' -> [a]) -> (b, b') -> [a]
06:12:40 <xerox> ?type uncurry (++) . (?f *** ?g)
06:12:42 <lambdabot> forall a b b'. (?f::b -> [a], ?g::b' -> [a]) => (b, b') -> [a]
06:16:13 <dons> we require BSD3 since we care about freedom. ndm's microsoft thing is just weird ;-)
06:16:25 <dons> e.g. ghc has been BSD-style since the beginning. free the source!
06:17:17 <xerox> @yarr!
06:17:18 <lambdabot> Aye Aye Cap'n
06:17:28 <xerox> (She agrees.)
06:18:56 <LPhas> lambdabot is a "she"?
06:20:47 <lemmih> ?vixen Are you female?
06:20:47 <lambdabot> <undefined>
06:21:20 <lemmih> Oh /-:
06:21:35 <Cheery> ?vixen Gender
06:21:35 <lambdabot> <undefined>
06:25:38 <n00b> @pl \a -> sum $ map (^2) a
06:25:38 <lambdabot> sum . map (^ 2)
06:27:34 <dons> hah, "Haskell" is in the reddit censored words list for today :-)
06:28:11 <dons> e.g. http://programming.reddit.com/info/1at09/comments/c1b01y
06:28:12 <lambdabot> Title: ask reddit: thoughts on writing a Haskell/Lisp hybrid language (reddit.com)
06:30:41 <tsp> waht's a reddit
06:31:26 <dons> reddit.com
06:31:35 <dons> in particular, programming.reddit.com
06:31:47 <tsp> is it like digg?
06:33:40 <astrolabe> A bit like digg
06:33:54 <astrolabe> When did they start censoring words?
06:34:18 <xerox> **** *** censorship!
06:37:53 <astrolabe> heh
06:38:24 <LPhas> If lambdabot is a female, i think that's something insane in a channell full of people that talk to her only about haskell :P poor girl
06:39:09 <xerox> ?vixen asl?
06:39:09 <lambdabot> <undefined>
06:39:18 <xerox> something has gone wrong.
06:39:45 <Vq^> LPhas: what about all the males she talkes Haskell to? ;P
06:40:33 <dons> astrolabe: on april 1.
06:40:50 <dons> tsp, like digg, but more haskell articles
06:45:54 <astrolabe> dons: Odd coincidence
06:59:00 <ndm> if you combined the best from Haskell and Lisp, wouldn't you end up with Haskell, a good debugger and a nice IDE?
06:59:15 <ndm> with perhaps a (>>=) instruction on the CPU
07:00:13 <ndm> dons: case and let are certainly not required for a minimal haskell core
07:01:00 <dons> ndm, according to h98 they're pretty useful ;-)
07:01:05 <kilimanjaro> The case and let used in the IR are pretty simple, actually
07:01:07 <ndm> (i now see your comment about operational uses)
07:01:14 <ndm> dons: they are :)
07:01:47 <dons> it was in reference to writing an small interpreter, in which case directly interpreting case and let seem a reasonabel choice if you want to do it in 20 lines or so.
07:02:10 <kilimanjaro> It's also nice to distinguish uses of let from arbitrary function application
07:02:27 <ndm> yeah, we now have a Yhc.Core interpetter in ~70 lines
07:02:45 <ndm> the hardest thing to support is defaults and literals in case expressinos
07:03:07 <ndm> my ICFP paper has a first-order core interpretter in 10 lines
07:03:25 <ndm> which has lazy evaluation in it a well
07:05:18 <Igloo> Why not desugar literals to equality tests?
07:05:30 * Igloo isn't sure what you mean by defaults
07:05:36 <ndm> because Yhc core doesn't
07:05:47 <Igloo> Why not, though?
07:05:51 <ndm> case x of {[] -> y, _ -> z}
07:05:56 <ndm> i.e. _, the default case
07:06:22 <ndm> Igloo: we want case x of {1 -> y; 2 -> z; _ -> q} to only require one lookup in an array
07:07:00 <ndm> i suspect it may actually compile down to nearly a list of =='s though, so perhaps that would be bettr
07:07:41 <Igloo> Would case x of {1 -> y; 2000000000 -> z; _ -> q} also only require one lookup in a (huge) array?
07:07:59 <Igloo> Or do you mean you handle it specially when all the values are small?
07:08:01 <ndm> no, i think they get compiled to a LOOKUP_SWITCH
07:08:09 <ndm> we have TABLE_SWITCH as well
07:08:14 <Igloo> OK
07:08:22 <ndm> but LOOKUP_SWITCH takes an array of lhs,rhs
07:08:38 <kilimanjaro> There was actually a good paper on implementing multi way branches like case or cond in Scheme, with a bunch of profiling done
07:08:40 <ndm> which is faster, because its only one instruction - being a bytecode compiler makes that matter
07:20:44 <ndm> Data/Derive/Peephole.hs:36:30: Not in scope: `peehole'
07:20:47 <ndm> :-)
07:20:54 <mux> heh
07:21:22 <_matthew-> wow, obfuscation or what?! :
07:21:30 <_matthew-> @pl \simple -> (8 - ((length simple) `mod` 8)) `mod` 8
07:21:30 <lambdabot> (`mod` 8) . (-) 8 . (`mod` 8) . length
07:22:58 <Saizan> it's better than the original IMO
07:23:08 <_matthew-> O.o
07:23:21 <xerox> it's just a pipe, from right to left
07:41:19 <lizhn> is there faster algorithm or function like splitRegex? or split function with 'string' delimiters?
07:41:33 * shachaf has now officially switched to XMonad.
07:45:08 <mux> lizhn: lambdabot has a split function like this
07:45:10 <ndm> @seen sorear
07:45:10 <lambdabot> I saw sorear leaving #darcs, #haskell-overflow, #ghc and #haskell 6h 2m 53s ago, and .
07:45:13 <mux> split :: Eq a => [a] -- ^ Glue that holds pieces together -> [a]         -- ^ List to break into pieces -> [[a]]       -- ^ Result: list of pieces
07:45:23 <mux> in Lib/Util.hs
07:45:47 <ndm> @pl (.) snd id
07:45:47 <lambdabot> snd
07:49:51 <ndm> @pl (>>) x (return ())
07:49:51 <lambdabot> x >> return
07:58:04 <foxy-om> dcoutts, ping
08:02:34 <_matthew-> @seen dons
08:02:34 <lambdabot> dons is in #haskell-soc, #haskell-overflow and #haskell. I last heard dons speak 1h 47s ago.
08:02:56 <_matthew-> mmm. I guess it's a bit late for him in .au.
08:03:22 <matthew-_> with hs-plugins, does ghc need to be installed on the target system?
08:04:48 <narain> > liftM2 (,) [1,2,3] [4,5,6]
08:04:50 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
08:04:54 <xerox> if you use runplugs you need it on the target machine too
08:06:10 <narain> ?pl \x y -> (f(x,y), f(y,x))
08:06:10 <lambdabot> ap (ap . (((,) . f) .) . (,)) ((f .) . flip (,))
08:06:20 <narain> huh.
08:09:18 <foxy-om> @hoogle when
08:09:18 <lambdabot> Monad.when :: Monad a => Bool -> a () -> a ()
08:09:19 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
08:11:45 <foxy-om> @hoogle CChar
08:11:45 <lambdabot> Foreign.C.Types.CChar :: data CChar
08:11:45 <lambdabot> Foreign.C.String.castCharToCChar :: Char -> CChar
08:11:45 <lambdabot> Foreign.C.String.castCCharToChar :: CChar -> Char
08:12:20 <matthew-_> xerox: runplugs? I'm just wanting to dynamically load .hi files on the target system and run them as per the hs-plugins tutorial.
08:14:40 <matthew-_> ahh, runplugs as in the lambdabot source file? Presumeably that needs ghc due to the eval and compilation?
08:23:02 <foxy-om> matthew-_: hs-plugins requires ghc on the target machine, it compiles snippets and dynamically loads them
08:24:06 <matthew-_> foxy-om: even if you're just loading precompiled things?
08:24:26 <foxy-om> unless you have .hi and .o files, but they have to be compiled with the same version of ghc
08:24:34 <matthew-_> yep, that's fine.
08:25:11 <foxy-om> > eval "2 + 2"
08:25:11 <lambdabot>   Not in scope: `eval'
08:30:06 <sorear> hello.
08:30:12 <ndm> hi sorear
08:30:24 <ndm> i've added peepholing, but its effect on Binary isn't that great
08:30:33 <ndm> its effect on Play is massive :)
08:40:14 <ndm> sorear, yeah, defining foldr && and calling it concat is probably not a great idea :)
08:41:02 <sorear> @botsnack
08:41:02 <lambdabot> :)
08:41:08 <sorear> FINALLY
08:41:20 <sorear> I do so love there freenodeburps.
08:41:27 <sorear> ndm: still here?
08:41:36 <ndm> sorear, yep :)
08:41:47 <ndm> sorear: i did of course mean and', not concat'
08:42:44 <sorear> Have you said more than 6 things in the last ~5m?  I for one lost six messages... :(
08:43:10 <ndm> i've added peepholing, but its effect on Binary isn't that great
08:43:16 <ndm> its effect on Play is massive :)
08:43:22 <ndm> thats about all i said
08:43:45 <sorear> oh good :)
08:44:15 <ndm> defining Play is very very tricky though
08:44:27 <sorear> even with the time needed to download n hunderd k  of data, clog was more responsive than freenode ...
08:44:30 <ndm> but thats because Play is tricky, i now understand TH enough that its no longer an issue
08:53:04 <sorear> Wow.
08:53:27 <sorear> I managed to totally forget where-bound variables could be polymorphic.
09:01:58 <ndm> sorear, i think i have a safe sequence of smiplifications now that does what we need
09:02:33 <sorear> Wow, freenode is having fun today
09:02:43 <ndm> this would be a million times easier if we had Play instances on TH - which I think we will once I've got Play deriving working
09:03:54 <sorear> good.
09:05:12 <sorear> One thing I note drift does that we can't is derive:has et al, since they track field names and we don't.
09:06:14 <ndm> we can add that, i suspect, we'll have to see if SYB and TH both support it
09:06:27 <ndm> we'll definately add Is deriving, we use that in Yhc
09:07:22 <sorear> TH supports it top-of-head
09:08:10 <ndm> i'm not sure about SYB, i'll have to check
09:08:13 <sorear> Ah, constrFiels looks good
09:11:14 <dino-> hlog
09:11:43 <dino-> I was just looking over the wiki page on How To write... http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
09:11:44 <lambdabot> Title: How to write a Haskell program - HaskellWiki
09:12:11 <dino-> And the part about getting cabalized has a link to HNop, the minimal Haskell project
09:12:24 <dino-> Looking at that, I'm confused by there being two projects in there: hnop and nop
09:12:38 <dino-> http://semantic.org/hnop/
09:12:39 <lambdabot> Title: Index of /hnop
09:12:57 <dino-> Is this how I should be starting something? These two project have very different Setup.hs sources too.
09:13:23 <arcatan> nop is a library and hnop is executable, I think
09:13:51 <dino-> So, how do you get a plain, starting Setup.hs usually for something new?
09:13:53 <sorear> Igloo just gave the go-ahead for fixing Language.Haskell.TH in place.  if we don't care about compatibility to ghc <= 6.6, we can ditch FixedPpr soon.
09:15:42 <dino-> mm, maybe I should spend some time reading the cabal documentation
09:16:17 <sorear> mkcabal
09:16:20 <ndm> sorear, neat :)
09:16:36 <ndm> sorear, i checked in a fix to your one this morning, it could crash on the (.) operator otherwise
09:16:50 <sorear> Yeah.
09:19:13 <sorear> "Oh, every qualified name ends with something other than a .!"
09:21:15 <ndm> sorear, indeed
09:23:09 <dino-> Ok, so the say to use mkcabal is to dl dons's source and build it?
09:23:13 <dino-> s/say/way/
09:23:36 <sorear> yah
09:23:39 <ndm> hmm, does TH expose PackedString in its API?
09:23:49 <ndm> and if so, aren't they totally screwed for GHC 6.8?
09:24:04 <sorear> it appears Name is abstract
09:24:20 <sorear> with only String-based accessors
09:24:30 <ndm> ModName :)
09:24:46 <ndm> its a type, so that exports the alias as well (it has to) and its aliased to PackedString
09:24:53 <Igloo> "totally screwed"? It is just an API change if so, no?
09:25:02 <Igloo> The TH API certainly isn't intended to be stable
09:25:14 <ndm> Igloo: you have to break compatability, totally screwed is an overstatement :)
09:25:34 * Igloo thinks there will be bigger changes than that to worry about  :-)
09:26:20 <sorear> hmm.  Is a type synonym, so they aren't totally screwed.
09:26:20 <sorear> more like totall screwed
09:26:47 <sorear> Freenode is having soo much fun today...
09:27:05 <ndm> sorear, i'm about to write automatic derivers for Data and Typeable
09:27:16 <ndm> sorear, should they go in one module, or two separate ones?
09:27:29 <sorear> In FixedPpr I also changed the th prettyprinter to work on ~-patterns
09:27:44 <sorear> ndm: probably two, because of the naming convention thing
09:28:12 <ndm> sorear, cool :) - i'll set that up now
09:28:32 <ndm> once we've got that, we can add SYB on Template Haskell, and make our peephole have less horrid boilerplate
09:28:42 * ndm is still contemplating switching to Play after that
09:30:53 <dino-> sorear: thanks
09:30:59 <sorear> Igloo: why does TH use Int#?  (does it predate -funboxed-strict-fields?)
09:31:49 <sorear> I expected template-haskell to be portable (though of course splice syntax is GHC-only)
09:32:06 <Igloo> I suspect that's a unique, which is an Int# inside GHC
09:32:25 <sorear> yes, it is a unique
09:32:39 <sorear> do we need to keep the repr synched for unsafeCoerce# reasons?
09:33:27 <Igloo> I doubt it needs to be synced, more likely the definition was just copied and Simon didn't feel like putting I#'s in explicitly only for the compiler to optimise them out again  :-)
09:34:00 <ndm> yeah, it does have an Ick feeling looking through the Syntax
09:35:17 <Igloo> I would treat things like Name as abstract for now if I were you
09:35:47 <Igloo> And put in more helper functions to ask questions about a name if necessary
09:36:22 <ndm> is there any reason that half the TH things don't derive Ord, Data, Typeable etc?
09:37:30 <Igloo> Ord would be an odd thing for most of it, but I don't see a reason not to add to if you want it
09:37:42 <sorear> Is there any deep reason for template-haskell to not be h98+hier-mods?
09:37:43 <Igloo> I don't know much about Data and Typeable
09:37:55 <Igloo> How do you mean?
09:38:11 <ndm> Igloo: its just a Syntax tree, but certain internal decisions mean it can't be
09:38:17 <Igloo> Do you mean not supporting other GHC extensions?
09:38:19 <sorear> Abstractly, it's just a bunch of generally useful data types.
09:38:30 <Igloo> ndm: Huh?
09:38:48 <ndm> Igloo: two point (1) Data and Typeable are generally useful, most of base derives them, so why not this
09:38:55 <Igloo> sorear: Oh, you mean "Why does language.Haskell.TH use extensions"?
09:39:03 <sorear> If template-haskell ran on hugs, data.derive would too
09:39:06 <ndm> Igloo: second one is sorears point
09:39:17 <sorear> though individual derivers might still not work
09:39:18 <Igloo> ndm: I don't know much about them, so I don't know what the reasons for/against would be
09:39:21 <sorear> @botsnack
09:39:22 <lambdabot> :)
09:39:23 <sorear> Igloo: yes.
09:39:26 <Igloo> If they would be useful then I see no reason not to derive them
09:39:39 <Igloo> sorear: What extensions are used (outside of the definition of Name)?
09:39:49 <ndm> Igloo: takes up more object code space, but its perfect and exactly what these were designed for
09:40:00 <sorear> Does PackedString count as an extension?
09:40:07 <ndm> Igloo: packed string, Int# - a couple of forall's
09:40:20 <Igloo> Is Int# used outside of Name?
09:40:34 <Cheer1> how do you define precedence rules for infix operators?
09:40:42 <Cheer1> like, if you define two operators, like:
09:40:45 <Cheer1> & and :-
09:41:01 <Igloo> Cheer1: infixl 4 &
09:41:26 <Cheer1> then I have:  a & b & c :- backgroundColor "#FF9000"
09:41:53 <Igloo> I think the forall in the definition of Q is just to make the type signatures nicer
09:42:02 <ndm> Igloo: in NameFlavour
09:42:18 <doserj> http://www.haskell.org/onlinereport/decls.html#sect4.4.2
09:42:19 <lambdabot> Title: The Haskell 98 Report: Declarations
09:42:19 <Igloo> ndm: That's part of Name
09:43:17 <Igloo> Name is really designed to match GHC's internals; like I said above, I think you should treat it as abstract, for now at least
09:43:35 <ndm> yeah, but if this was all fixed, we could have a much nicer model :)
09:44:07 <Igloo> I'm not sure how you fix it without actually making Name abstract
09:44:23 <Igloo> Name's have to include enough info that reify knows what to do with them
09:51:13 <sorear> At least the bot's netsplit bug is fixed :)
09:52:07 <ndm> lovely :)
09:52:21 <ndm> we can now derive Data
09:52:30 <sorear> yay!
09:53:36 <ndm> once i've added Typeable, we can derive SYB for TH
09:53:43 <ndm> and then our Peephole shrinks and grows in power
09:54:08 <sorear> I still think Play is better ;-)
09:54:12 <ndm> sorear, thoughts on depending on Play?
09:54:21 <ndm> would make the free variable computation easier, if we do need it
09:54:26 <ndm> and i think we may do, in teh end
09:55:02 <sorear> doesn't hackage-whatever-it-was-called chase deps now?
09:55:12 <sorear> does Play have any funny deps itself?
09:55:35 <ndm> nope, Play has no deps
09:55:48 <ndm> and i don't think its in Hackage yet, but it will be in a bit
09:55:49 <sorear> OTOH, unreleased software-ness might be a problem.
09:56:07 <ndm> oh, btw - i'm off to Oxford all next week, out of email contact
09:56:12 <ndm> so you wouldn't get any patches commited
09:56:18 <ndm> do you have a Haskell.org account?
09:56:23 <sorear> no.
09:56:27 <ndm> I'll move derive over there, but doubt I'll have time before i set off
09:56:30 <ndm> we'll get you one
09:56:52 <Igloo> What's happening in Oxford?
09:57:00 <ndm> actually i think i've added your private key, so you can login as ndm
09:57:04 <ndm> Igloo: BCTCS
09:57:17 * sorear thinks so too
09:57:19 <ndm> Igloo: British Colloquium of Theoretical Computer Science
10:00:52 <sorear> Igloo: will anything break if I make Language.Haskell.TH.Syntax depend on Data.Char?
10:01:10 * Igloo fails to find any details on this proposed British Learned Society
10:01:15 <Igloo> sorear: No
10:05:18 <ndm> Igloo: they've proposed it several years running, i've never bothered with IEEE/BCS things, and this looks like another one
10:05:38 <Cheer1> How do I find out the existing precedence multipliers of operators?
10:06:06 <Igloo> Cheer1: :i in ghci
10:06:11 <Cheer1> k
10:06:25 <Cheer1> ooh, nice
10:07:35 <mwc> Guys, this is amazing! I have developed an algorithm to solve NP problems in O(N) time
10:07:40 <mwc> so long as N <= 2
10:07:46 <mwc> I'm sure it can be generalized
10:08:12 <mux> hmm, April 1st :-)
10:08:32 <Cheer1> gah, I got fooled
10:08:49 <mwc> actually, you didn't. 2! = 2 ;)
10:09:06 <mwc> N! being the runtime for the TSP
10:09:12 <mwc> the canonical NP problem
10:09:34 <Cheer1> what does it mean in practise?
10:10:47 <mwc> My revolutionary technique allows you to find the shortest path between any two points in euclidean space. And you can do it with a modern dual core workstation!
10:11:58 <mwc> I refer to this technique as "Brutalizing-the-idiot-who-set-the-problem-until-N-is-an-acceptably-small-value search"
10:12:05 <bmtv_> You'll revolutionize the Internets.
10:12:59 <ndm> Did but 1249 follow the libraries submission process?
10:13:09 <ndm> i don't remember seeing it on libraries, only somewhere else
10:13:15 <ndm> its the silly remove Data.Map.map
10:13:28 <ndm> (can we mark that as invalid, as it will never happen?)
10:13:42 <phoniq> > 2 ^ 3
10:13:43 <lambdabot>  8
10:16:16 <LPhas> phoniq: O_O
10:16:19 <LPhas> asd
10:17:27 <phoniq> demonstrating the lambdabot to guy over my shoulder
10:17:54 <Igloo> ndm: That would be wontfix
10:18:52 <ndm> Igloo: we don't have a "crazy" flag?
10:19:57 <Igloo> :-)
10:22:15 <dmead> > listM2 (*) [1..20] [2..30]
10:22:16 <lambdabot>   Not in scope: `listM2'
10:22:21 <dmead> > liftM2 (*) [1..20] [2..30]
10:22:22 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
10:22:37 <dmead> > liftM2 (*) [1..5] [2..30]
10:22:39 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
10:22:44 <dmead> do do doo
10:27:21 <ndm> hmm, cyclic module imports
10:27:29 <ndm> Data.Derive depends on TemplateHaskell
10:27:30 <Igloo> Nnnoooooooo!
10:27:50 <ndm> deriving TemplateHaskell for Typeable and Data requries importing Data.Derive
10:28:40 <Igloo> You want a derive declaration
10:28:46 <ndm> yeah, i would
10:28:50 <LPhas> working in cabal, what can be used for writing a parser?
10:29:00 <ndm> deriving Ord, Typeable, Data on everything in template haskell
10:29:15 <ndm> would there be any chance of that making GHC 6.6.1 :-)
10:29:19 <Igloo> I think GHC might have one. It would be great to get it standardised for H'
10:29:22 <ndm> since it seems like it was an oversight from the begining
10:29:35 <ndm> SYB sucks, you sholdn't standardise on it
10:29:42 <Igloo> LPhas: I don't follow?
10:29:42 <ndm> you want to standardise on Play :)
10:29:46 <NichardRixon> man, playing with C++'s <functional> gives me a whole new appreciation of Haskell
10:29:51 <ndm> plus its H98
10:29:59 <ndm> and shiney and type safe
10:30:03 <Igloo> ndm: I didn't mean standardising on either of them
10:30:04 <NichardRixon> the way the STL uses bind2nd and everything is just weeeeeird
10:30:12 <ndm> Igloo: a standardised deriving thing?
10:30:18 <phoniq> NichardRixon: check out boost::function
10:30:24 <phoniq> stdc++ functional is way outdated
10:30:30 <NichardRixon> yeah, I just picked that up
10:30:31 <Igloo> ndm: I just meant data D ... deriving X   should be equivalent to data D ...; derive D X
10:30:33 <NichardRixon> it looks much nicer
10:30:52 <Igloo> Or some similar syntax
10:30:53 <ndm> Igloo: definately, deriving support is a weak area of the language
10:31:05 <LPhas> Igloo: well i know that beying cabal included in ghc, it has to be "stand-alone", p.e. the xerox's work on SoC last year
10:31:11 <Igloo> And that's all you need to solve your cyclic problem, as then the Data derivations can be moved out of the TH module
10:31:27 <LPhas> Igloo: so, if you have to write a parser inside Cabal, what can you use?
10:31:28 <ndm> Igloo: kind of, this is my deriving framework, so that wouldn't help
10:31:53 <Igloo> Does your deriving framework actually use the Data instance then?
10:32:37 <ndm> Igloo: it does, but it adds it in a preprocessor, does the deriving, then remove its
10:32:46 <ndm> Igloo: so you don't have to use GHC on teh results
10:32:52 <ndm> we can also do it with Template Haskell
10:33:00 <Igloo> LPhas: Do you mean you want to write a Setup.hs that parses things?
10:33:23 <LPhas> Igloo: let me explain better
10:34:53 <LPhas> Igloo: i applyied for this http://hackage.haskell.org/trac/summer-of-code/ticket/1131 , so i'm gathering information on "how to do", while i wait the list of acceptance
10:34:55 <lambdabot> Title: #1131 (Implement Cabal configurations) - Haskell.org Google Summer of Code - Tra ...
10:35:21 <ndm> LPhas: its probably best to wait until you get the answer through
10:35:29 <ndm> LPhas: just in case you don't get it
10:35:43 <LPhas> Igloo: LPhas i'm sick at home and i've nothing to do :P
10:35:45 <ndm> hmm, does TemplateHaskell have a Let, is LetE a letrec or let
10:36:11 <Igloo> Haskell doesn't have a non-rec let, so neither does TH
10:36:34 <Igloo> LPhas: You'd want to use whatever Cabal does for parsing the existing syntax
10:36:40 <ndm> :(, me wants non-rec let
10:44:44 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1224
11:02:08 <ray> so how about that lambda the ultimate april fools joke
11:05:05 * rahikkala looks at it
11:05:10 <rahikkala> :D :D :D
11:06:00 <DRMacIver> Heh
11:06:09 <DRMacIver> Didn't turn up in my aggregator for some reason
11:08:17 <sorear> Is freenode working yet?
11:08:21 <sorear> @botsnack
11:08:21 <lambdabot> :)
11:08:23 <jeroeng_> Can someone help me with a nasty spaceleak problem?
11:08:27 * sorear reads the logs, since he doesn't get messages directed to the channel anymore
11:08:32 <sorear> I don't know.
11:08:39 <sorear> However, people will try
11:08:47 <sorear> but only if you say what it is.
11:08:55 <sorear> (asking to ask is such a peeve of mine...)
11:09:59 <jeroeng_> Well, I'm trying to write a Trie-datastructure to store a dictionary (about 350 000 entries)
11:10:31 <jeroeng_> The file itself is about 3.5 megabytes, but my programme uses about 70 megabytes of memory
11:11:45 <jeroeng_> I've added seq's, tried the bang-patterns, profiled the thing with a whole bunch of cost centres, but I still can't figure out why it leaks so much
11:12:22 <sorear> I don't think that's a leak, unfortunately
11:12:31 <jeroeng_> It's not?
11:12:33 <sorear> what kind of trie structure are you using?
11:12:54 <jeroeng_> A home-made one, using Data.Map recursively
11:13:05 <sorear> 20x is within normal bounds for Haskell's inefficient data structures...
11:13:13 <sorear> Ah, Data.Map.
11:13:21 <sorear> And you have one of those for each node?
11:13:24 <jeroeng_> Jup
11:13:32 <jeroeng_> So that's what's using all the memory?
11:14:26 <sorear> A Map takes at least 24 bytes per entry.
11:14:33 <sorear>               | Bin {-# UNPACK #-} !Size !k a !(Map k a) !(Map k a)
11:14:42 <jeroeng_> sorear: Is there a better datastructure for this? Perhaps Data.Graph.Inductive?
11:14:47 <sorear> So 4 bytes for each of those fields, plus one for the tag.
11:14:52 <sorear> s/one/4
11:15:05 <DRMacIver> Ouch
11:15:24 <DRMacIver> Although I guess that's about the order of magnitude (if not slightly better) that one would expect from doing this in Java
11:16:32 <jeroeng_> So I've been hunting for a leak which is nonexistent, mm :)
11:17:53 <jeroeng_> sorear: Do you know a fix for this? A more suitable datastructure?
11:18:20 <sorear> IntMap might be a little better...
11:18:33 <sorear> you could use the PATRICIA technique
11:19:24 <jeroeng_> Thanks, that sounds promising
11:21:21 <ddarius> jeroeng_: Is the text unicode char's or would ASCII suffice?
11:21:36 <jeroeng_> ASCII would suffice
11:22:10 <sorear> @seen
11:23:12 <sorear> If I have a module in ., and I want to use an identically-named module in base, what can I tell ghci?
11:23:27 <ddarius> Then wouldn't data Trie = Empty | Branch !Word8 (Array Int Trie) be effective enough (there actually probably isn't a difference between Word8 and Char there, and maybe Word8 v. Int would make a difference but probably not)
11:24:07 <sorear> ddarius: Array will use a lot more than the 24 bytes per node jeroeng_ is complaining about
11:24:09 <ddarius> Can't you set directories GHC(i) checks and the order.
11:24:16 <ndm> sorear, i now have the binary peepholing stuff in derive
11:24:22 <sorear> ndm: yay!
11:24:37 <rashakil> instead of a map, you could use an association list.  Or a bytestring parallel to a list of subnodes.
11:24:38 <ndm> sorear, not the put >> return () stuff, as thats unsafe
11:24:41 <ndm> but the rest
11:25:18 <jeroeng_> Currently my trie is defined as data Trie v k= Trie !(Maybe v) !(Map k (Trie k v)) | DeadEnd v [k]
11:25:30 <ndm> now to get on to Play replaceChildren, the really hard one...
11:25:35 <jeroeng_> I thought the dead-end may save me some space, but it did not
11:25:39 <rashakil> use an array -- keep it sorted -- use binary search on a sorted array instead of a map.
11:26:07 <sorear> ndm: I'm now having a bit of trouble testing my changes to Language.Haskell.TH.Ppr - GHC wants to use everthing possible from ., but then I get a type error because [| 2 + 2 |] :: base:Language.Haskell.TH.Syntax.Q while runQ is resolved from . to have type *main*:Language.Haskell.TH.Syntax.Q
11:26:22 <sorear> Igloo: ideas?
11:26:42 <jeroeng_> rashakil: Isn't inserting into maps very expensive?
11:26:53 <ndm> sorear, -I
11:26:56 <rashakil> you mean into arrays?
11:27:05 <ndm> sorear, that should remove . from the import list
11:27:05 <jeroeng_> Yes, arrays.
11:27:19 <sorear> ghc-6.7.20070323: unrecognised flags: -I
11:27:23 <ndm> -i
11:27:28 <ndm> i always forget which one it is
11:27:34 <rashakil> when the array's only 256 elements long?
11:27:44 <rashakil> or much less?
11:28:02 <sorear> Hmm.  When I use -i, it breaks because I need changes made to the . modules.
11:28:21 <sorear> Is there any way to persuade the desugarer to use non-base modules?
11:28:21 <jeroeng_> Well, I think that in my case it will be much less.
11:28:26 <Igloo> sorear: I'm not entirely sure what you're doing, but various names in TH are magic and need to be in the template-haskell package
11:28:43 <jeroeng_> I'm trying to make a Trie to store a dictionary, so at each branch there's at most 30 elements or so
11:28:46 <sorear> Igloo: Ouch.
11:29:00 * sorear tries -fno-implicit-prelude
11:29:13 <sorear> after all, if do isn't magic why [| |]
11:29:50 <sorear> No luck :(
11:34:19 <Cheery> aagh, I think I give up with this StyleSheet -generator -thing
11:34:53 <Cheery> I got it to generate stuff, but refining and structuring the interface you didn't create is tedious
11:37:25 <Cheery> if anyone like stepcut wants to get the sources at the point they were when I stopped doing, sure, just ask
11:42:24 <phoniq> whoa, template haskell, that's mindboggling
11:43:15 <phoniq> i just got the Printf example
11:43:31 <phoniq> this language is insane
11:49:09 * kolmodin is back
11:49:50 <waern> kolmodin: http://www.dtek.chalmers.se/~davve/Sk%c3%a4rmbild.png
11:50:32 <kolmodin> waern: wohooo! yay!
11:50:34 <kolmodin> @yarr!
11:50:35 <lambdabot> Gangway!
11:50:52 <kolmodin> but also: oh noes!
11:50:57 <kolmodin> scintilla, again? :)
11:51:01 <sorear> waern: Haddock-ghc doesn't generate type documentation if there is no source type annotiation
11:51:17 <waern> sorear, yep, that's how it works in the original
11:51:19 <kolmodin> waern: is the code online?
11:51:37 <ndm> waern: i thought that was meant to be one of teh big advantages of haddock-ghc?
11:51:43 <waern> yes
11:52:05 <waern> I'll get to that, sometime
11:52:06 <sorear> Well, at least haddock-ghc can understand gadts.
11:52:15 <kolmodin> ndm: yet to be implemented
11:52:17 <sorear> That alone makes it highly non-useless.
11:52:22 <mux> ndm: are you aware of that annoying google bug where if you search some operator in prefix notation, ie '(//)', hoogle suggests you (did you mean...) the very same thing?
11:52:22 <waern> kolmodin, not finished yet
11:52:28 <mux> ndm: searching without parentheses ust works
11:52:38 <mux> err, s/google/hoogle/ heh
11:52:47 <kolmodin> waern: code not finished? is code ever finished? :)
11:52:51 <sorear> It's been seen many times before...
11:52:53 <ndm> mux, yeah, will be fixed in Hoogle 4, which has a much more complete parser
11:52:59 <mux> cool
11:53:00 <ndm> the Hoogle 3 parser is a layer of hacks
11:53:02 <sorear> what won't be? ;)
11:53:08 <ndm> nothing :)
11:53:14 <waern> kolmodin, I'm working on generating bindings for the whole API now
11:53:20 <ndm> Clean and ML support are in Hoogle 5, thats it so far
11:53:31 <waern> sorear, I'm not sure it properly renders GADTS to html yet though
11:53:40 <ndm> once I have done Play, Derive and BinaryDefer, Hoogle 4 is my next free time project :)
11:54:01 <ndm> oh, and TagSoup, but thats only about 10 minutes off finished
11:54:10 <kolmodin> waern: ah
11:54:28 <waern> kolmodin, I have to do some marshalling for the basic Scintilla types
11:54:40 <kolmodin> right
11:54:45 <waern> then generate all the function bindings from the iface file
11:55:43 <kolmodin> ok, hmm
11:55:59 <waern> I have written the parser already though
11:56:37 <kolmodin> for the iface?
11:56:41 <waern> yep
11:57:06 <matthew-_> ok, parsec gurus, how would you parse a quote delimited string which can span multiple lines and include backslash (\) escaped quotes?
11:57:17 <kolmodin> so projekcts basically pick between sourceview and scintilla
11:57:21 <waern> kolmodin: it's quite nice that the iface contains docs, so we'll get proper Haddock docs
11:58:04 <kolmodin> waern: true
12:00:02 <sorear> @google scintilla
12:00:04 <lambdabot> http://www.scintilla.org/
12:00:04 <lambdabot> Title: Scintilla and SciTE
12:02:38 <matthew-_> ahh, well it's actually a piece of small cake...
12:08:10 <Gwern> have dons or sjanssen been around recently?
12:11:07 <sorear> @seen dons
12:11:07 <lambdabot> dons is in #haskell-soc, #haskell-overflow and #haskell. I last heard dons speak 5h 9m 19s ago.
12:11:10 <sorear> @seen sjanssen
12:11:10 <lambdabot> sjanssen is in #haskell-soc, #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard sjanssen speak 13h 4m 38s ago.
12:11:26 <mux> @pl f x y z = f x z y
12:11:26 <lambdabot> f = fix (flip .)
12:11:58 <sorear> I think you meant
12:12:06 <sorear> @pl \f x y z -> f x z y
12:12:06 <lambdabot> (flip .)
12:12:17 <mux> right, thanks
12:14:55 <sorear> @spell parenthesis
12:14:56 <lambdabot> parenthesis
12:16:43 <iseff> has anyone used Crypto to encrypt Strings instead of just Integrals
12:17:56 <rahikkala> > foldr (.) id (replicate 1000000 id) "hello"
12:17:57 <lambdabot>  "hello"
12:18:48 <sorear> Not even with a million and one repetitions will id fail to return its argument.
12:19:49 <sorear> > fold ["x","y"]
12:19:50 <lambdabot>   Not in scope: `fold'
12:21:00 <rahikkala> This should obviously be added to nobench: How long it takes for an implementation to pass a value through id, say, 1e9 times
12:21:19 <kolmodin> waern: det mest skrmmande r ju att du har ubuntu p svenska! :)
12:21:28 <resiak> > (iterate id "hello") !! 1000001
12:21:29 <sorear> I suspect -O11 will do very interestingly.
12:21:30 <lambdabot>  "hello"
12:21:52 <sorear> Oh, those two will be different.
12:22:06 <sorear> The foldr stores functions in a data structure.
12:22:08 <rahikkala> What's -O11?
12:22:20 <sorear> ndm's first order mega-optimizer
12:22:51 <stepcut> it took me a while to get it :(
12:23:58 <lightstep> where can i get the source for house/hop? the official site cuts the connection after transmitting about 1 MB of the file
12:24:10 <sorear> @where house
12:24:10 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
12:24:19 * sorear tests this
12:24:23 <sorear> lightstep: try wget
12:25:17 <waern> kolmodin: det blir ofta ganska inkonsekvent, ja
12:25:28 <Gwern> sorear: first order mega-optimizer? is that part of some april fool's joke?
12:25:28 <kolmodin> :)
12:25:51 <sorear>         Received 2.0 MiB of 25 MiB
12:25:58 <sorear> It's going fine for me!
12:26:16 <sorear> Gwern: no, it's very old
12:26:44 <stepcut> Gwern: http://neilmitchell.blogspot.com/2006/10/30-faster-than-ghc.html
12:26:46 <sorear> Gwern: and the requirement for ndm to produce a PhD thesis is no AFJ
12:26:53 <stepcut> i think that was the start of -O11
12:26:58 <kolmodin> waern: har du vervgt att anvnda sourceview?
12:27:21 <Gwern> sorear: :( please speak to me in english. ndm is a person I gather, and I know what a PhD thesis is, but what is an AFJ?
12:27:25 <sorear> lightstep: I just downloaded all 26MiB w/o hitches.
12:27:32 <sorear> April Fools Joke
12:27:38 <waern> kolmodin: ja, men den kan ju inte gra speciellt mycket
12:27:39 <kolmodin> (why am I talking in swedish?)
12:27:48 <lightstep> well, the server still kicks me, but wget just resumes the download, so it's fine
12:28:05 <kolmodin> waern: no, true, but you can add functionalities through gtk
12:28:17 <kolmodin> waern: to do completion boxes, etc
12:28:32 <waern> kolmodin: hm, ok. without modifying the source view widget itself?
12:28:50 <kolmodin> waern: yeah, you just draw other controls on top of it
12:28:58 <Gwern> I keep hearing about yhc. is it supposed to replace ghc once it defeats ghc performance-wise or something?
12:29:05 <sorear> Nah.
12:29:10 <sorear> It's a fork of nhc98
12:29:13 <ndm> Gwern: ndm is me :)
12:29:24 * Gwern nods. hmm hmm I see
12:29:34 <kolmodin> waern: otoh, much has to be fixed for it to be nice
12:29:42 <ndm> and GHC will be the main Haskell compiler for some time to come
12:29:44 <kolmodin> waern: but again, otoh, scintilla is pretty scary
12:29:47 <waern> kolmodin, ok, I don't know much about it
12:29:49 <sorear> Gwern: yhc is 20x slower than ghc, and is expected to stay that way indefinitely - it has other things to excell in
12:30:01 <waern> kolmodin, I figured Scintilla has pretty much all I want
12:30:24 <ndm> sorear, the -O11 will go back into Yhc, probably
12:30:25 <kolmodin> waern: yeah, it's been around
12:30:36 <waern> kolmodin, scary in what way?
12:30:37 <sorear> Gwern: like portability - except for the FFI layer yhc is ansi C
12:30:55 <Cale> Programming reddit has hit a new all-time low for me. Only 4 of the 100 newest posts I haven't modded down.
12:31:01 <waern> kolmodin: it will get a proper Haskell API so it won't be scary anymore
12:31:14 <kolmodin> waern: that will help a lot
12:31:32 <mux> @instances Monoid
12:31:33 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
12:31:41 * sorear rebuilds ghc, to make absolutely sure it wasn't broken by his TH patches
12:32:09 <mux> > mempty :: (a -> b)
12:32:10 <lambdabot>   add (Monoid b) to the expected type of an expression
12:32:11 <lambdabot>     In the expression:...
12:32:13 <sorear> Looks like you're missing libraries/filepath,
12:32:13 <sorear> maybe you haven't done 'sh darcs-all get'?
12:32:15 <sorear> wtf!
12:32:17 <sorear> ?!
12:32:18 <lambdabot> Maybe you meant: . v
12:32:27 <sorear> filepath is in the core libs now!
12:32:32 <mux> > (+1) `mappend` mempty
12:32:33 <lambdabot>  Add a type signature
12:32:36 <kolmodin> waern: let me know when you put it online
12:32:40 <mux> > (+1) `mappend` mempty $ 2
12:32:41 <lambdabot>  Add a type signature
12:32:46 <lightstep> > mappend LT LT
12:32:48 <lambdabot>  LT
12:32:51 <lightstep> > mappend LT GT
12:32:52 <lambdabot>  LT
12:32:58 <mux> > ((+1) `mappend` mempty :: Int -> Int) $ 2
12:32:59 <lambdabot>   add an instance declaration for (Monoid Int)
12:32:59 <lambdabot>     In the expression: ((+ 1))...
12:33:13 <sorear> mux: it's a reader, not a endomorphism
12:33:14 <ndm> sorear, it got added in teh last few days, now filepath comes with GHC
12:33:15 <waern> kolmodin, well, there's no reason for the repo not being online I guess...
12:33:27 <mux> hmm
12:33:36 <sorear> > (("foo"++) `mappend` ("bar"++)) "M"
12:33:37 <lambdabot>  "fooMbarM"
12:33:47 <sorear> actually, that's unportable
12:34:00 <sorear> the behavor silently changed between 6.4 and 6.6
12:34:06 <sorear> your code will still typecheck
12:34:14 <sorear> it'll just give a different answer
12:34:22 <mux> (> (+1) `mappend` (+2)) 3
12:34:25 <mux> oops
12:34:31 <mux> > ((+1) `mappend` (+2)) 3
12:34:32 <lambdabot>  Add a type signature
12:34:45 <sorear> mux: bzzt.  Numbers aren't monoids.
12:35:03 <sorear> mux: were you expecting mappend to act as (.)?
12:35:11 <sorear> mux: that is the 6.4 behavior
12:35:17 <sorear> mux: lambdabot is running 6.6
12:35:38 <mux> I'm not really expecting anything, I was trying to see if I could use Monoids to improve some code of mine
12:38:46 <waern> kolmodin: of course
12:38:47 <sorear> Are there any haskell compileres that DON'T separate renaming from typechecking?
12:38:55 <kolmodin> waern: to be honest, scintilla seems to be much much more active than sourceview
12:39:06 <sorear> Methinks implementing TH would be easier if they could be inteleaved.
12:39:18 <kolmodin> waern: and there are lots and lots of bindings for it
12:39:41 <waern> kolmodin: yep, the sourceview project says it's not intended to be as feature-rich as scintilla
12:39:57 <kolmodin> waern: so many developens can't be wrong... let's go for it :)
12:40:00 <ndm> sorear, it would be a nightmare if they weren't separated
12:40:05 <ndm> thus me suspects they may be
12:40:11 <ndm> in Yhc at least :)
12:40:23 <kolmodin> waern: so a bit cleaner bindings this time then :)
12:40:38 <Rened> Is there any way to get a stack trace out of a program compiled with GHC when it runs out of stack?
12:40:55 <waern> kolmodin, hehe, yes, hopefully
12:42:12 <sorear> Rened: probably not.
12:42:25 <sorear> Rened: but if it can be done at all, +RTS -xc will do the trick
12:42:46 <sorear> Rened: that's a runtime option; it only works if the program is compiled with -prof
12:42:59 <sorear> Rened: and for best results, -auto-all -caf-all
12:44:15 <kolmodin> waern: then again.. monodevelop uses gtksourceview
12:44:47 <Rened> sorear: well I got <Auxil.evolve,Main.main> out of that... which I already knew.
12:45:11 <Rened> Maybe I need to try compiling without optimizations. Thanks for the help.
12:46:42 <kolmodin> waern: http://www.monodevelop.com/Image:Md-main.png
12:46:44 <lambdabot> Title: Image:Md-main.png - MonoDevelop
12:47:09 <kolmodin> waern: doesn't look too shabby
12:47:41 <ddarius> Hmm, a browser in a browser... I guess it makes sense.
12:48:13 <Rened> Should -auto-all work together with -caf-all? GHC 6.6 gives me symbol collisions with both.
12:48:33 <sorear> Yes, it should.
12:48:42 <sorear> That is a (reported) bug.
12:49:06 <mux> @instances MonadPlus
12:49:07 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
12:49:51 <waern> kolmodin: nope
12:50:03 <sorear> http://hackage.haskell.org/trac/ghc/ticket/249
12:50:05 <lambdabot> Title: #249 (-caf-all bugs) - GHC - Trac
12:55:32 <Rened> Is there anything to watch out for with tail recursion inside let bindings?
12:55:49 <mux> sorear: why aren't Integers monoids? they are unbounded
12:56:15 <Rened> I am trying to get PolyGP running under GHC 6.6. It is suffering from some strange stack overflow.
12:56:39 <sorear> Rened: tail recursion period is often best avoided in Haskell...
12:56:46 <sorear> mux: ambiguity
12:56:57 <sorear> mux: do you want mappend to add or multiply?
12:56:58 <Rened> I suspect there must me some recursion of the let bound parameters I am not seeing.
12:57:06 <mux> sorear: actually not, but that got me curious =)
12:57:12 <lightstep> mux, in haskell, numbers aren't monoids, to proviide more specific overloading
12:57:50 <Rened> With my own code I have not had problems with tail recursive code.
12:57:56 <mux> I have some code modifying some state record
12:58:11 <mux> and it has several conditional branches where we might not touch the state
12:58:17 <Rened> And direct tail recursion is often faster than HOF based code.
12:58:27 <mux> ie: if ... then state else if .. then state else state { foo = bar }
12:58:37 <mux> I think I just need the state monad to make this right
12:59:02 <mux> however, I'm not using it in other places of the code because gtk callbacks are involved
12:59:17 <mux> but maybe I should just use runState just here
12:59:33 <mux> I'm not sure I'm being very clear
12:59:49 <lightstep> if you only modify some pure state, you can compose the modification functions for each condition
13:00:11 <sorear> readert with iorefs is the standard approach for multi-threaded stateful io code
13:00:12 <lightstep> (if cond1 then mod1 else id) . (if cond2 then mod2 else id)
13:00:13 <mux> maybe I should just paste this...
13:01:15 <hpaste>  mux pasted "state fun" at http://hpaste.org/1225
13:01:47 <mux> I avoid one branch that returns state with a maybe
13:01:50 <mux> but that still is ugly
13:02:48 <mux> hmm I see how to improve the Just s part, I think
13:03:55 <mux> writing it higher order
13:06:12 <lightstep> i think that usually, people would put the square first
13:06:56 <mux> yeah, I was thinking about that :)
13:08:07 <mux> if I write it higher-order I end up with just as many branches where I want to return id
13:14:03 <matthew-_> mmm. So I'm using Data.Graph.buildGraphFromEdges to construct a graph. I then transposeG the graph, but how am I meant to update the mappings I get back from buildGraphFromEdges?
13:15:52 <hpaste>  lightstep annotated "state fun" with "another attempt (probably not better)" at http://hpaste.org/1225#a1
13:16:49 <lightstep> i don't know if there is a better way to put it - it's pure game logiv
13:16:58 <lightstep> *logic
13:17:05 <ddarius> :t if True then const else id $ if False then 3 else 5
13:17:07 <lambdabot> forall a b. (Num (a -> b -> a)) => a -> b -> a
13:17:35 <ddarius> darn
13:18:13 <mux> I guess I want this combinator
13:18:14 <mux> let maybeFunc b f = if b then f else id
13:18:25 <sorear> ddarius: if is lower prec than $
13:18:41 <mux> does this exists already?
13:18:42 <sorear> :t if True then const else (id $ if False then 3 else 5)
13:18:45 <lambdabot> forall a b. (Num (a -> b -> a)) => a -> b -> a
13:19:58 <ddarius> sorear: I just wasn't thinking for a second.
13:23:08 <doserj> > let True ? x = const x; False ? x = id in even 3 ? "even" $ "odd"
13:23:09 <lambdabot>  "odd"
13:27:56 <kuribas> doserj: It would be nice if that was in the prelude.
13:28:15 <ddarius> The catamorphism for Bools
13:30:25 <sorear> it was a probably a mistake to add algebraic types to haskell.  Church encode everything! ;)
13:31:45 <ddarius> Then Haskell would've needed rank-2 types.
13:32:45 * int80_h loves #haskell
13:33:26 <sorear> ddarius: no it wouldn't ... if (->) is the only primitve type, types form a full lattice
13:33:37 <LPhas> sorear: you are saying that they better used Church numerals instead of actual implementation?
13:33:51 <sorear> ddarius: granted that pretty well eliminates the type advantage
13:35:07 <sorear> LPhas: that's irrelevant - semantically everything is lazy, but that doesn't stop compilers from strictness analysing and pre-emptively evaluating things that will be needed.
13:35:42 <ddarius> LPhas: With good support for HOFs (which GHC has) and a compact representation of them, Church encoded data structures would be more or less as efficient space- and speed-wise as say C++ style objects.
13:36:03 <sorear> LPhas: in the same way, specifying Church numerals in the semantics will not (legally - technically is another matter) bar compilers from substituting binary bignums
13:37:08 <sorear> Indeed, GHC 6.6 actually uses a form of Church encoding in the backend - the "vectored returns" system
13:37:10 <lightstep> but Int32?
13:37:20 <sorear> lightstep: range analysis!
13:37:34 <sorear> lightstep: having Int in the language was a BIG mistake imo
13:38:10 <sorear> lightstep: it only buys a relatively small efficiency factor (10x?) and in return gives us unchecked integer overflow bugs
13:38:13 <lightstep> i agree. but Int32 is good for stuff like CRCs
13:39:11 <ndm> lightstep: only if you rely on undocumented behaviour
13:39:18 <bd_> I wonder if Integer could be converted to Int by appropriate static analysis...
13:39:29 <ddarius> bd_: Sure it could.
13:39:33 <ndm> I'm thinking Yhc might have an option where maxBound::Int+1 automatically converts you to an Integer
13:39:39 <bd_> ddarius: usefully so that is :)
13:39:48 <ndm> bd_, very very unlikely that it would get any cases
13:40:16 <ndm> most numbers are either constant (who cares, you can precompute them), or enter the sysetm externally
13:40:17 <ddarius> ndm: Isn't using Integers in GHC essentially that.
13:40:26 <ndm> i.e. read/show etc
13:40:31 <ndm> ddarius: kind of
13:40:51 <bd_> ddarius: There's still overhead from a computed jump or branch as it determines what form of Integers are being used.
13:40:52 <LPhas> ndm: such an option doesn't require an overhead on every operation?
13:41:03 <ndm> LPhas: probably does
13:41:51 <ddarius> If you could propagate some (meaningful) constraints to the parsing stage you might be able to use two different dynamically chosen branches depending on whether the input was in range.
13:42:12 <ddarius> I wonder if I could twist typeclasses to do that?
13:42:14 <ddarius> @faq
13:42:15 <lambdabot> The answer is: Yes! Haskell can do that.
13:42:39 <sorear> This kind of thing is called "Specialization".
13:42:50 <ddarius> Yes
13:42:58 <sorear> It is being very actively persued in -O11 and jhc.
13:43:12 <ddarius> Not this particular form I doubt.
13:43:21 <ddarius> And not within the language I also doubt.
13:44:16 <ddarius> Hmm, I actually feel fairly confident that I could do this.
13:58:01 <ndm> sorear, can i use [| in my Play derivation?
13:58:07 <ndm> sorear, or will something go wrong?
14:00:14 <ndm> ping sorear
14:02:53 <sorear> pong.
14:03:19 <sorear> It won't work, but not for any deep reason
14:03:32 <ndm> sorear, how easy would it be to get it working?
14:03:36 <sorear> quasiquote syntax needs to be renamed, which requires unique names
14:03:47 <sorear> so it needs Q (a state monad)
14:04:00 <sorear> currently we use bare Exp values
14:04:16 <ndm> is there unsafePerformQ @
14:04:18 <ndm> ?
14:04:42 <sorear> unsafePerformIO . runQ ...
14:04:54 <ndm> what to renamings give us?
14:05:13 <sorear> Static scoping.
14:05:19 <sorear> s/static/lexical/
14:05:36 <sorear> also note that the pretty printer uses original names
14:05:52 <sorear> so [| 2 + 2 |]  pprs as 2 GHC.Num.+ 2
14:06:06 <ndm> so its unlikely to work?
14:06:12 <ndm> shame, but never mind
14:14:26 <ndm> back later, bye!
14:16:07 <araujo> hello
14:16:13 <sorear> stefan@stefans:/usr/local/src/derive$ ghci -fth -v0
14:16:13 <sorear> Prelude> :m + Language.Haskell.TH
14:16:13 <sorear> Prelude Language.Haskell.TH> fmap ppr $ runQ [| 2 + 2 |]
14:16:13 <sorear> 2 GHC.Num.+ 2
14:16:28 <sorear> It works now!
14:16:55 <xerox> :D
14:17:02 <xerox> you rewrote the ppr?
14:17:19 <sorear> no, just added an extra flag to the pprName
14:17:41 <xerox> aye
14:17:52 <sorear> Prelude Language.Haskell.TH> fmap ppr $ runQ [| (+) 2 2 |] -- better example, this one didn't work before
14:17:52 <sorear> (GHC.Num.+) 2 2
14:18:25 <sorear> so, now, assuming they take my patch, Data.Derive.FixedPpr can go away
14:22:41 <kuribas> Is there a convenient monad that can return an Error like Maybe, but with a error description as string?
14:22:59 <Botje> kuribas: like Either e?
14:23:23 <Botje> > fail "Out of dubloons!" :: Either String Int
14:23:24 <lambdabot>  Left "Out of dubloons!"
14:23:58 <kuribas> Botje: yes, but Either isn't an Monad apparently.
14:24:18 <Botje> no, but Either e is.
14:24:23 <Botje> @instances Monad
14:24:24 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
14:25:02 <Botje> > fail "Out of dubloons" >> return 5 :: Either String Int
14:25:03 <lambdabot>  Left "Out of dubloons"
14:25:08 <Botje> > return 42 :: Either String Int
14:25:09 <lambdabot>  Right 42
14:25:13 <Botje> see? :)
14:26:44 * sorear gazes in amazement at GHC Bug #627
14:26:48 <kuribas> Hm, strange...
14:27:32 <kuribas> Botje: I get No instance for (Monad (Either String)) in ghci.
14:28:03 * Igloo thinks sorear Needs a better hobby than reading 1-year old nonsense bugs  :-)
14:28:21 <Igloo> kuribas: Import Control.Monad.Error
14:29:13 <sorear> Actually, I'm trying to find the docs for why ghc can't build itself with --make.
14:29:28 <kuribas> Igloo: Ah yes, now it works.  Thanks!
14:29:31 <sorear> The low-priority bug list seemed like a good place to start.
14:32:24 <Igloo> http://hackage.haskell.org/trac/ghc/ticket/930
14:32:25 <lambdabot> Title: #930 (ghc-6.6: panic! (the 'impossible' happened) mkWWcpr: not a product GHC-Bri ...
14:35:44 <sorear> @botsnack
14:35:44 <sorear> Not Again.
14:35:45 <lambdabot> :)
14:56:07 <stepcut> so, I want to make a function like, lookup :: a -> [(a,b)] -> m a, if there is a match, I can use 'return' but what should I use when there is not a match? fail, mzero, throwError ?
14:56:24 <stepcut> It seems like depending on what I pick, I can get the Maybe or Either, but not both...
14:56:42 <sorear> fail will work for both
14:57:09 <stepcut> oh right
14:57:33 <stepcut> I forget :) The problem with fail is that some people think it should die a horrible death because it violates monad laws or something
14:57:40 <stepcut> ?
14:58:05 <sorear> @seen Cale
14:58:05 <lambdabot> Cale is in #oasis, #ghc, #haskell-overflow and #haskell. I last heard Cale speak 2h 27m 9s ago.
15:01:32 <ddarius> stepcut: It just isn't part of being a Monad.
15:02:22 <stepcut> ddarius: so, people would not have a problem if it was not part of the Monad class itself ?
15:12:04 <kuribas> ddarius_: is there any practical reason against it?  It is convenient...
15:12:27 <ddarius_> kuribas: To start, many monads can't implement it.
15:12:54 <ddarius> Personally, I'm ambivalent about it.
15:14:09 <ddarius> Perhaps we should bring back monad comprehensions and add MonadFail as a constraint if you use a refutable pattern match in them.
15:14:23 <DRMacIver> Hm. What were monad comprehensions?
15:15:05 <ddarius> DRMacIver: List comprehensions generalize immediately to arbitrary monads/monads with zeroes.
15:15:22 <stepcut> hrm, is there a function like, returnL :: [a] -> m a, that will return the head of the list when the return type is (Maybe a), but the whole list when it's [a] ?
15:15:42 <ddarius> :t msum
15:15:44 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
15:15:50 <DRMacIver> ok.
15:16:24 <ddarius> :t msum . map return -- perhaps
15:16:27 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [a] -> m a
15:16:49 <stepcut> spiffy
15:16:53 <stepcut> > (msum . map return $ [1,3,4]) :: Maybe Int
15:16:55 <lambdabot>  Just 1
15:16:59 <stepcut> > (msum . map return $ [1,3,4]) :: [Int]
15:17:00 <lambdabot>  [1,3,4]
15:18:29 <oren> Is there any strategy for figuring out why the GC doesn't clean up objects in complex lazy situations? I used the profiler so I know which objects are kept, but I have no idea wwhy
15:19:00 <ddarius> oren: There's retainer profiling...
15:19:26 <siti> you're screwed TBH ;)
15:19:35 <siti> experimentation is the best
15:20:07 * ddarius wonders if the reachability graph can be output and usefully navigated/displayed for this purpose...
15:20:13 <oren> Ah, -hr
15:20:20 <oren> I'll give it a spin. Thanks
15:36:04 <dibblego> ?type splitAt
15:36:06 <lambdabot> forall a. Int -> [a] -> ([a], [a])
15:41:00 <dino-> I have a simple project, trying to cabalize. I just ran dons's mkcabel on it and told it Executable (NOT Library)..
15:41:18 <dino-> When I try to configure, I'm getting: "Setup.lhs: Error: Non-empty library, but empty exposed modules list. Cabal may not build this library correctly"
15:41:28 <dino-> Not sure what this means.
15:41:45 <sorear> It's a bug in cabal, or maybe mkcabal
15:42:00 <sorear> cabal sees the global Ghc-Options (in the top section)
15:42:07 <int80_h> can anyone help with my darcs install on gentoo? have have logs on rafb
15:42:16 <sorear> and it suddenly thinks you have a library...
15:42:50 <dino-> sorear: I was wondering about that, the duplicated ghc-options in the first section.
15:42:54 <dino-> I can just remove that?
15:45:13 <int80_h> http://rafb.net/p/3sR1xk65.html
15:45:15 <lambdabot> Title: Nopaste - darck 1.0.7 install problems
15:45:25 <int80_h> am I in the right room? #gentoo wasn't really responsive
15:46:19 <dino-> It's possible #darcs has someone who's using Gentoo as well.
15:46:34 <int80_h> cd #darcs
15:46:37 <int80_h> doh
15:46:39 <int80_h> sorry
15:50:51 <dino-> sorear: Thank you. That fixed the config.
15:56:58 <dcoutts> foxy-om: pong
15:57:21 <dcoutts> mux: pong
15:59:39 <int80_h> the true solution here is to install netbsd and begone with linux forever
16:00:42 <int-e> int80_h: hmm. weird, I didn't have any problems with gentoo. but I'm using ~x86 for all haskell related stuff, so it's using different versions of the packages
16:02:59 <sorear> int80_h: so netbsd has a source system that actually works?
16:03:55 * sorear is actually considering trying *BSD.  All the usual complaints don't apply, with my thoroughly standard desktop PC and 0 need for 3D.
16:04:48 * qwr uses debian. works enough without compiling everything from source.
16:05:08 <sorear> Me too.
16:07:46 <jcreigh> sorear: oh, really? which BSD?
16:08:16 * jcreigh has never ventured from Linux land
16:09:12 <sorear> jcreigh: it's an uninstantiated type variable
16:09:28 <sorear> jcreigh: never persued the thought long enough to instantiate it
16:17:48 <ddarius> Who can immediately guess what ASU86 refers to as a bibliography reference?
16:20:28 <sorear> Something tells me it has something to do with FP foundations :)
16:21:10 * sorear wants to say Augustsson's 1986 G-machine thingy, but the letters aren't right
16:22:08 <doserj> Aho, Seti, Ullman?
16:25:50 <ddarius> Aho, Sethi, and Ullman "Compilers, Principles, Techniques" The Dragon book.
16:27:14 <dcoutts> Igloo: btw, the reason Cabal isn't being quiet enough is because you made it more verbose during the hackathon! :-)
16:27:36 <Igloo> dcoutts: I didn't make -v0 any more verbose
16:27:43 <dcoutts> Igloo: hmm, ok
16:27:56 <dcoutts> I thought some of the levels got a bit screwed
16:28:09 <dcoutts> it's cerrtainly more verbose by default
16:28:46 <Igloo> I think the default was 0, but I changed it to 1 and made 0 silent. Or something like that.
16:28:59 <Igloo> Except 0 still isn't silent yet, it seems
16:30:32 <sorear> @users
16:30:32 <lambdabot> Maximum users seen in #haskell: 337, currently: 292 (86.6%), active: 34 (11.6%)
16:31:12 <Cale> sorear: hello
16:31:58 <sorear> hi.  (the @seen was a light-summon, since stepcut dared to mention fail)
16:33:15 <Cale> heh
16:34:32 <ndm> @seen sorear
16:34:33 <lambdabot> sorear is in #happs, #darcs, #haskell-overflow, #ghc and #haskell. I last heard sorear speak 2m 34s ago.
16:34:44 <ndm> error $ show $ ppr $ LamE [cons (vr "x") (vr "xs")] (vr "z")
16:34:55 <ndm> sorear, that gives as an output:
16:35:04 <ndm> \(:) x xs -> z
16:35:18 <sorear> Yow.
16:35:28 <ndm> if you do [vr "q",cons ...], you get \q (:) x xs ->
16:35:32 <sorear> Looks like another pretty-printer bug.
16:35:33 <ndm> which is even worse
16:35:37 <ndm> yep, definately
16:35:45 <ndm> not sure if thats your bug, or always been there
16:36:07 <sorear> Judging from how broken it was before, I don't think ppr has ever been used before ...
16:36:24 <sorear> even GHC -ddump-splices clearly doens't use it
16:36:26 <ndm> :(
16:36:44 <ndm> well that bug is fairly fatal for replaceChildren in Play
16:36:55 <ndm> if i've got it right, which i may well have not
16:37:00 <sorear> It sounds like a one-line fix though
16:37:19 <ndm> yeah, PatT gets a set of brackets, i guess
16:41:08 <sorear> fixed (now testing)
16:41:15 <sorear> there's a lot of idiocy in the ppr...
16:48:49 <araujo> hello
16:49:33 <sorear> hi!
16:52:27 <sorear> @where play
16:52:28 <lambdabot> I know nothing about play.
16:52:57 <sorear> @where+ play http://www.cs.york.ac.uk/fp/darcs/play/play.htm
16:52:57 <lambdabot> Done.
16:53:12 * sorear is motivated to continue hacking lambdabot7
16:53:25 * sorear still thinks megamonadbot was a better name :(
17:00:13 <nihraguk> i'm new to haskell and am finding it quite difficult to 'get' the whole functional programming thing, but for some reason i already feel like the language seems a lot more elegant than python/ruby.
17:00:34 <nihraguk> but like women, elegant != easy
17:01:22 <c> if you think theyre mutually exclusive, ive got some monads in brooklyn im trying to sell
17:01:54 <nihraguk> i have no idea what you mean
17:02:29 <Pseudonym> I'm certain there ARE monads in Brooklyn,
17:02:41 <Cale> nihraguk: Well, it gets easier over time. Reprogramming your brain to separate "loops" into "map/filter/fold" is one of the larger first steps.
17:04:04 <nihraguk> Cale: hmm thanks that sounds helpful. i think i sorta understand the use of map and filter, but how fold is used in some of the example code i've seen sometimes puzzles me
17:04:15 <lemmih> Unfold your mind, filter your impure thoughts, find the map to tranquility.
17:04:31 <dibblego> would a btree node contains keys in a linked list, an array or something different?
17:04:38 <nihraguk> right now i'm trying to write a simple MUD server as a learning exercise.
17:04:41 <Cale> The cleanest way to think about foldr f z is that it's replacing each (:) in the list with f, and the [] at the end with z
17:04:57 <sorear> A page?
17:05:22 <mwc> nihraguk, another way to think of it is the kind of operation you want to do. A map does something in isolation to everything
17:05:36 <nihraguk> Cale: nod, but that doesn't seem to work well with the use of the initial variable in fold to accumulate data/count stuff
17:05:36 <sorear> @remember Lemmih Unfold your mind, filter your impure thoughts, find the map to tranquility.
17:05:37 <lambdabot> Done.
17:05:45 <mwc> nihraguk, whereas a fold is a way of figuring something out based on every element in the list
17:06:01 <Cale> nihraguk: well, foldl is more about accumulation
17:06:15 <nihraguk> mwc: nods..
17:06:23 <Cale> I have some pretty diagrams...
17:06:25 <hpaste>  mux annotated "state fun" with "with a State monad" at http://hpaste.org/1225#a2
17:06:35 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
17:06:39 <lambdabot> Title: Fold Diagrams - CaleWiki
17:06:42 <mwc> nihraguk, basically a fold calls a function on every element of the list, and lets you string along a value through. that's where your initial parameter comes from
17:06:59 <Cale> hmm
17:07:32 <ddarius> foldl' f z xs more or less works out to acc = z; for(int i = 0; i < xs.size(); ++i) acc = f(acc,xs[i]); return acc
17:07:34 <Cale> mwc: that's an interesting picture of it. Is mapAccumL equivalent to foldl in some way?
17:07:46 * nihraguk nods.. i understand what fold does on the abstract level, but i haven't quite reprogrammed my brain to apply it effectively in programming yet. 
17:08:06 <mux> if someone can point me at a non-monadic elegant version, I'd be glad (cf http://hpaste.org/1225#a2)
17:08:28 <mwc> nihraguk, the canonical fold is summing a list of numbers
17:08:31 <mwc> > sum [1..100]
17:08:32 <lambdabot>  5050
17:08:36 <mwc> or you could do
17:08:38 <Cale> nihraguk: yeah, you sort of have to write a bunch of things which happen to be folds and then realise that you're doing the same thing over and over
17:08:43 <ddarius> The canonical foldl'
17:08:56 <mwc> > foldl (+) 0 [1..100]
17:08:57 <lambdabot>  5050
17:09:09 <sorear> > foldr (+) 0 [1..100]
17:09:10 <lambdabot>  5050
17:09:13 <sorear> > foldl' (+) 0 [1..100]
17:09:15 <lambdabot>  5050
17:09:32 <sorear> The difference between the l's and the r's is associativity.
17:09:38 <mauke> > 100 * 101 `div` 2
17:09:40 <lambdabot>  5050
17:10:00 <Cale> > foldr (\x y -> concat ["(f ",show x," ",y,")"]) "z" [1,2,3,4,5]
17:10:02 <lambdabot>  "(f 1 (f 2 (f 3 (f 4 (f 5 z)))))"
17:10:02 <ddarius> nihraguk: Along the lines of what Cale said, you write code then recognize that it fits the pattern of a fold and then abstract out.  Eventually, you see things as folds immediately or stop thinking in terms of recursive definitions.
17:10:17 <mwc> fold{l,r} always seemed to have backward names to me
17:10:18 <Cale> > foldl (\x y -> concat ["(f ",x," ",show y,")"]) "z" [1,2,3,4,5]
17:10:19 <lambdabot>  "(f (f (f (f (f z 1) 2) 3) 4) 5)"
17:10:25 * nihraguk nods. hope that comes sooner rather than later :p
17:10:34 <mwc> foldleft to me more obviously folds "Towards the left" rather than starts left and goes right
17:10:37 <Cale> mwc: look at my diagrams
17:10:43 <mwc> Cale, oh, I know
17:10:52 <mwc> they just seem to be backwards to the way I understand it
17:10:59 <ddarius> nihraguk: Really, foldr naturally follows from thinking about recursive solutions to problems over lists.  You have the base case and the inductive case.
17:11:07 <sorear> nihraguk: foldl' is just a performance hack, and you should pretend it doesn't exist for as long as possible.
17:11:15 <nihraguk> sorear: heh ok
17:11:30 <ddarius> sorear: Which will be as long as the program doesn't get any sizeable input.
17:11:34 <nihraguk> ddarius: i see.
17:11:54 <Cale> Well, 95% of the time, you want foldr, and about 4% of the remaining time, foldl', and the other folds are rarer.
17:12:06 <Cale> 4% of the total time, sorry
17:12:20 * ddarius still has no idea why some people think foldl's are so rare.
17:12:21 <mwc> Cale, lol, I must be doing something wrong, because I'm the exact opposite
17:12:39 <Cale> foldr is common (or it should be) because it works well with laziness.
17:12:41 <ddarius> foldr is underused in my opinion, but not -that- underused.
17:12:46 <Cale> Plus it's just easier to understand.
17:13:02 <ddarius> foldl' is easy to understand too, and captures and -extremely- common pattern.
17:13:04 <Cale> It should be the default fold which you reach for before trying anything else.
17:13:25 <Cale> foldr is far more natural, because it's replacing the list structure with program structure
17:13:31 <Cale> (directly)
17:13:36 <dons> scanr1 !!
17:13:43 <Cale> foldl is twisting things around at the same time
17:13:55 <ddarius> foldl' is just accumulating over a list.
17:13:59 <Cale> and it's tail recursive, which means that it operates poorly on infinite lists
17:14:22 <ddarius> The C-style loop above is very common.
17:14:26 <mwc> Cale, I dunno, foldl always seemed more natural to me, because "I get the first in the list, do something, then feed that as input into doinging something on the second thing in the list, etc.
17:14:54 <ddarius> foldr is natural for recursive solutions (being the "most general" recursive solution), foldl' for iterative.
17:14:59 <Cale> hmm, foldr does that too :)
17:15:09 <Cale> mwc: look at the diagram for foldr
17:15:35 <Cale> at the top of the diagram is f being applied to 1 and something to be computed still
17:15:38 <dcoutts> foldl is a strict loop, foldr is a lazy one
17:15:51 <dcoutts> by the time foldl returns it's consumed the whole list
17:15:55 <mwc> Cale, right, that's what I mean
17:15:55 <Cale> Diagrams are evaluated top-down
17:16:13 <dcoutts> foldr gives you a different view of a list to consume at your leisure
17:16:18 <Cale> So f 1 (...) will reduce f next
17:16:21 <mwc> when you force the value, in the end, the first thing to to be computed is f 5 z
17:16:27 <Cale> No it isn't.
17:16:48 <Cale> and that's where you're probably getting confused :)
17:17:00 <dibblego> @remember dcoutts foldr gives you a different view of a list to consume at your leisure
17:17:01 <lambdabot> Done.
17:17:09 <mwc> Either I'm thinking too specifically functions that are strict in both args, or I'm totally misreading your diagrams
17:17:10 <Cale> Well, perhaps it is, if f is strict.
17:17:20 <dons> @src foldr
17:17:21 <lambdabot> foldr k z xs = go xs
17:17:21 <lambdabot>     where go []     = z
17:17:21 <lambdabot>           go (y:ys) = y `k` go ys
17:17:37 <Cale> But quite often f isn't completely strict.
17:17:50 <sorear> Generally, you don't want foldr if your function is unconditionally strict.
17:17:57 <Cale> dons: can we improve the source text for @src?
17:18:11 <dons> that's the library definition!
17:18:12 <sorear> I think that's a good foldr, conditionally
17:18:24 <Cale> dons: I know, but it's not the definition you want to *show* people.
17:18:32 <mwc> anyways, I still maintain that foldr and foldl are named backwards. Fold is a verb, so saying foldl to me means you fold leftwards
17:18:38 <mwc> whereas foldl actually goes rightwards
17:18:39 <dons> oh, its good for them to see worker/wrapper code
17:18:42 <Cale> dons: It has that ugly go hack in it.
17:18:58 <dibblego> Cale, newtype is and write your own Show
17:19:01 <dibblego> s/is/it
17:19:03 <sorear> maybe we should have two srcs.  @pegagogy-src and @implementation-src .  Better name ideas anyone?
17:19:06 <dons> hack? that's how I'd write it straight out :-)
17:19:10 <Cale> dibblego: what?
17:19:16 <dmwit> What is the "go" for, anyway?
17:19:17 <Cale> foldr f z [] = z; foldr f z (x:xs) = f x (foldr f z xs)
17:19:20 <dibblego> just talking crap
17:19:22 <Cale> That's how I'd write it.
17:19:25 <sorear> dons: yeah, well that's because you're on the Streams Team!
17:19:35 <dons> Go Team Stream!
17:19:37 <ddarius> sorear: @src and @realsrc
17:19:45 <kpreid> I'd write it foldr k z = go where ... :-)
17:19:52 <sorear> dmwit: ghc can't inline recursive functions, like Cale's foldr
17:19:59 <dons> of course, I'd probably write foldr as:
17:20:01 <dons> foldr f z (Stream next s0) = loop_foldr s0
17:20:01 <dons>   where
17:20:01 <dons>     loop_foldr !s = case next s of
17:20:01 <dons>       Done       -> z
17:20:04 <dons>       Skip    s' -> expose s' $ loop_foldr s'
17:20:06 <dons>       Yield x s' -> expose s' $ f x (loop_foldr s')
17:20:10 <dons> mwhahaha
17:20:11 <Cale> heh
17:20:12 <sorear> dmwit: but the real foldr is nonrecursive (containing a recursive def)
17:20:20 <sorear> dmwit: so ghc CAN inline it
17:20:30 <dmwit> huh
17:20:36 <sorear> dmwit: then, a little inlining later, it's as if foldr was specialized
17:20:39 <Cale> It would be nice if the inliner could be smarter in that particular way.
17:20:39 <Botje> @do-as-i-say-src and @do-as-i-do-src
17:20:39 <lambdabot> Unknown command, try @list
17:21:00 <sorear> dmwit: one of the many hacks ghc uses trying to be -O11 ;)
17:21:05 <Cale> Perhaps it's too difficult to find places where it's likely to be beneficial.
17:21:11 <dmwit> =P
17:21:36 <sorear> My mind still boggles at the fact that GHC 6.6 uses to represent data structures...
17:21:41 <sorear> church encoding!
17:22:07 <sorear> aka vectored returns
17:22:18 <dons> hmm? you mean integer tags?
17:22:30 <ddarius> Actually, isn't it only one layer.  I.e. a functional case for lists not foldr.
17:22:39 <sorear> no, in the stg-machine.
17:22:54 <sorear> a list is a function which takes two return addresses
17:23:07 <sorear> one address is for conses, the other for nils
17:23:11 * dons hands sorear a closure
17:23:25 * sorear enters it
17:23:29 <Cale> sorear: and why shouldn't it be? :)
17:23:57 <ddarius> sorear: Yes, but what is the "type" for the one for conses.
17:24:19 <sorear> Cale: well, the Haskell Committee ruined so many nice properties of the language just so we would have ADTs and not c-e
17:24:22 <mwc> makes sense... the cons evaluates its thunk to figure out what it is, then picks the appropriate return path. That's just a vanilla plain jump
17:24:27 <mwc> as opposed to a function call
17:24:48 <kpreid> sorear: c-e?
17:24:50 <ddarius> caseList cons nil [] = nil; caseList cons nil (x:xs) = cons x xs is rather different from foldr.
17:24:51 <Cale> c-e?
17:25:04 <sorear> kpreid: compulsive abbreviation
17:25:10 <sorear> church encoding...
17:25:34 <Cale> sorear: which nice properties?
17:25:47 <sorear> ddarius: it's not foldr, but without SN^H^Hstrong normalization they are equivalent
17:25:47 <Cale> Are you talking about seq?
17:25:53 * mwc goes to eat, drink, and generally be merry
17:25:56 <mwc> have fun y'all
17:25:59 <mauke> heh, that caseList is my destruct function :-)
17:26:27 <ddarius> sorear: Equivalent but different.
17:27:08 <sorear> Cale: seq is one I think.  More pertinently, the type system takes a very different form when there is only one atom.
17:27:30 <Cale> I think that having proper datatypes is rather important.
17:28:02 <Cale> I mean, sure, you could do it with just functions, and a single recursive type, but that would be extremely strange.
17:29:12 <sorear> You do lose a lot of type safety that way.  Natural *can* be unified with List Natural.
17:29:55 <sorear> Indeed, once you admit equirecursive types, it becomes impossible to have a type error.
17:30:11 <sorear> (which kinda defeats the purpose of a type system)
17:32:50 <dmwit> xmonad ping
17:34:11 <glen_quagmire> do you?
17:34:17 <glen_quagmire> is there midi library?
17:34:21 <dmead> hey channel
17:34:26 <glen_quagmire> i want to make a midi sequencer in haskell
17:34:31 <dmwit> hey dmead
17:34:36 <sorear> All together now, "Hey dmead"
17:34:40 <sorear> Hey dmead!
17:34:52 <glen_quagmire> Hey dmead!
17:35:21 <sorear> Is halp @freshname's only user?
17:35:30 <stepcut> dmead: haskcore mightt have something
17:35:46 <dmead> glen you mean
17:35:48 <dmead> giggity
17:36:09 <stepcut> yeah, that's what I meant :)
17:36:35 <dmwit> ?freshname
17:36:36 <lambdabot> Haex
17:36:51 <dmwit> ?halp freshname
17:36:51 <lambdabot> freshname. Return a unique Haskell project name.
17:37:05 <glen_quagmire> oh i see
17:37:09 <stepcut> glen_quagmire: If not, I have a library for parsing MIDI data, you could probably extend it to create MIDI data too
17:37:36 <glen_quagmire> haskell is also extendable using C/C++ right?
17:37:58 <glen_quagmire> like, wrapper of C++ realtime midi thingy
17:38:03 <dmwit> glen_quagmire: Yes, the magic search word is FFI.
17:38:03 <sorear> C
17:38:04 <stepcut> glen_quagmire: C yes. C++ yes, but harder.
17:38:57 <stepcut> glen_quagmire: if the C++ library explicitly exports the names for C users, then it is easy to call from Haskell
17:39:47 <glen_quagmire> i see
17:40:24 <stepcut> It is hard to call C++ because the C++ compilers mangle the function names in compiler specific ways
17:40:26 <ddarius_> C++ can't even talk to C++ without a lot of pain.
17:40:55 <Pseudonym> Only in the same sense that GHC can't talk to JHC.
17:41:47 <stepcut> glen_quagmire: so if you want to call a C++ library, you typically use extern "C" statements to export unmanagled names, or something similar
17:42:13 <dcoutts> stepcut: though there is now a vendor-agreed standard abi
17:42:17 <ddarius> Unfortunately that's easier said then done.
17:42:56 <stepcut> glen_quagmire: although it is possibly to call the C++ library directly, if you can figure out how to demangle the names, http://www.haskell.org/haskellwiki/CPlusPlus_from_Haskell
17:42:57 <lambdabot> Title: CPlusPlus from Haskell - HaskellWiki
17:42:57 <glen_quagmire> too deep for me. i may give up
17:43:23 <dmead> haskell maybe overkill for a squencer
17:43:30 <dmead> cause you'd have to do so much i/o
17:43:38 <dons> bah.
17:43:39 <stepcut> glen_quagmire: step 1 is to see if the C++ authors made a 'C' wrapper
17:43:49 <dons> the more IO the better!
17:44:31 <dmead> stepcut: if not he could probably make his own C++ -> C layer
17:45:04 * dcoutts prods dons to fix his perms problem
17:45:23 <stepcut> dmead: yeah, it's usually pretty boilerplate
17:46:11 <sorear> A large part of the problem is that there is no standard imbedding of OO in Haskell.
17:46:25 <dmead> meh
17:46:37 <dmead> you can just have clever named to access c++ classes
17:46:40 <sorear> If we could agree on that, a (say) G++ -> Haskell wrapper would be relatively easy.
17:47:04 <dmead> isn't it already?
17:47:10 <kc5tja> dcoutts: What is this standard ABI?  Is there a document on this?  Does GCC adhere to it?  Inquiring minds want to know.  :)
17:47:17 <sorear> No, because you have holy wars.
17:47:18 <encryptio> :t liftM
17:47:20 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
17:47:20 <encryptio> :t liftIO
17:47:22 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
17:47:27 <sorear> Nested records or classes?
17:47:35 <dmead> i mean
17:47:45 <dcoutts> kc5tja: yes gcc now uses it, I'm sure you can find docs on it on gcc's website
17:47:51 <dmead> when i used to do alot of C++ class in quake 3
17:47:53 <stepcut> sorear: did you see the C++ in Haskell code on that page I pasted ?
17:48:02 <dmead> nobody expects you to approximate the c++ classes with structs
17:48:10 <dmead> just stick an underscore in the name
17:48:13 <dmead> class a
17:48:15 <dmead> void foo
17:48:17 <dmead> int bar
17:48:22 <stepcut> main =
17:48:22 <dmead> then in C you'd have
17:48:22 <stepcut>     do kapp <- kapplication "Calculator" "A Calculator in Haskell" "1.0"
17:48:22 <stepcut>        mainWidget <- createWidget noParent layout
17:48:22 <stepcut>        (kapp ->> setMainWidget) (castPtr mainWidget)
17:48:22 <stepcut>        (kapp ->> qapplication_exec)
17:48:27 <dmead> void a_foo
17:48:31 <dmead> int a_ar
17:48:33 <dmead> etc
17:48:48 <dmead> it's conceptually sound enough i think
17:48:56 <nihraguk> hmm can i put a TChan inside a datatype? would that be a bad idea?
17:49:07 <sorear> Sure!
17:49:14 <sjanssen> nihraguk: sure, TChan is just like any other type
17:49:14 <dmead> what a tchan?
17:49:15 <Cale> nihraguk: you can, and it's probably a fine idea.
17:49:17 <nihraguk> ok, thanks :)
17:49:22 <sorear> You can put ANYTHING[1] in a data type.
17:49:31 <Cale> dmead: A transactional channel for use with STM.
17:49:40 <sorear> [1] Except unboxed tuples, but those are pure evil to begin with.
17:49:48 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/stm/Control-Concurrent-STM-TChan.html
17:49:50 <lambdabot> http://tinyurl.com/2y6xtu
17:50:04 <nihraguk> i'm just wondering if that will infect everything with the STM/TChan monads, but i guess not
17:50:06 <sorear> @. docs index newTChan
17:50:06 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
17:50:11 <sorear> :(
17:50:13 <dmead> ah
17:50:22 <mauke> nihraguk: no, infection happens at the code level, not data
17:50:28 <nihraguk> ah ok
17:51:06 <mauke> src :: GPL Program
17:51:53 <sjanssen> unsafeIgnoreCopyleft :: GPL a -> a
17:52:38 <sorear> yah, well, haskell is unsound :)
17:52:45 <sjanssen> @seen Gwern
17:52:45 <lambdabot> I saw Gwern leaving #haskell 3h 54m 16s ago, and .
17:53:28 <sjanssen> @seen dmwit
17:53:28 <lambdabot> dmwit is in #haskell and #haskell-blah. I last heard dmwit speak 15m 24s ago.
17:53:34 <sjanssen> dmwit: pong
17:55:19 <sorear> M.Map TypeRep [Dynamic] just seems so unclean to me.
17:55:50 <sorear> I want to write M.Map TypeRep [Any] instead, and use unsafeCoerce# instead of fromDyn...
17:55:55 <sorear> what's wrong with me?
17:56:05 <mauke> @remember sjanssen unsafeIgnoreCopyleft :: GPL a -> a
17:56:05 <lambdabot> Done.
17:56:28 <dons> hmm. does the GPL obey the monad laws?
17:57:03 <dons> > return a >>= k  ==  k a
17:57:03 <dons> > m >>= return  ==  m
17:57:03 <dons> > m >>= (\x -> k x >>= h)  ==  (m >>= k) >>= h
17:57:04 <lambdabot>   Not in scope: `a'
17:57:05 <lambdabot>   Not in scope: `h'
17:57:05 <lambdabot>   Not in scope: `m'
17:57:51 <kc5tja> If one attempts to map GPL, they just get a complex route leading somewhere.  Precisely where, nobody's been able to figure out.  Attempting to liftM the GPL results in a "too much legalese" error.  Can't help you, sorry.  :D
17:58:30 <dons> oh, i'm not considering GPL transformers. oi, my head hurts!
17:58:31 <ddarius> No fmap makes sense.  If you have a GPL'd program you can make another.
17:58:44 <mauke> a derived work!
17:58:56 <dons>     fmap        :: (a -> b) -> f a -> f b
17:59:08 <dons> yes, if you apply some transform to GPL a, you get a new program GPL b
17:59:35 <kc5tja> And like the IO monad, once you enter into GPL, you can't get out.  ;D
17:59:50 <dons> right.
18:00:04 <stepcut> unless you use the GPL comonad ?
18:00:15 <kc5tja> or unsafeCoerceLicense#
18:00:35 <doserj> but you can't take an arbitrary program and turn it into a GPL one...
18:00:36 <sorear> or undefined.  HINAPA :(
18:00:44 <sorear> return!!
18:00:49 <doserj> so there is no return::a -> GPL a
18:01:09 <dons> so how do you introduce a new GPL value then?
18:01:19 <sorear> Ah, but that is  Id a -> GPL a   and Id is also called PD
18:04:07 <stepcut> hrm, the lack of 'return' seems problematic
18:04:37 <kc5tja> How is return missing though?
18:04:40 <doserj> well, you have the function liberate:: PD a -> GPL a
18:04:45 <kc5tja> Somewhere, a person needs the ability to create new software.
18:05:01 <kc5tja> And what about join?
18:05:12 <kc5tja> I suspect that's used to build distributions.
18:05:32 <stepcut> kc5tja: I don't think it is legal to do, return :: MicrosoftLicenseAgreement a -> GPL (MicrosoftLicenseAgreement a) ?
18:06:01 * stepcut ponders what that would mean
18:06:04 <sjanssen> obviously GPL is a restricted monad
18:06:16 <sorear> stepcut: that's completely legal
18:06:16 <kc5tja> return :: OpenSource a => a -> GPL a
18:06:21 <sjanssen> return :: CopyrightableWork a => a -> GPL a
18:06:43 <sorear> stepcut: but there is very little you can do with GPL (MicrosoftLicenseAgreement a)
18:06:50 <sjanssen> instance CopyrightableWork SourceCode
18:07:29 <stepcut> sorear: I suppose
18:07:38 <sorear> It's possible to apply the GPL to panes of glass.  It would however accomplish nothing...
18:11:56 <dons> if we assume that values not in any monad are in the public domain
18:12:02 <dons> then we have, return :: a -> GPl a
18:12:39 <dons> you can do anything you want with a value of 'a', its in the public domain :-)
18:15:21 <stepcut> dons: but (MicrosoftLicenseAgreement l) unifies with type 'a', doesn't it ?
18:15:36 <whaleofconfusion> i have the power to enjoy cheese dip
18:15:37 <dons> seems problematic.
18:16:32 <stepcut> yeah
18:17:12 <stepcut> sjanssen's suggestion of a restricted monad seems like it might work
18:18:01 <oren> I'm trying to wrap a cabal package, and haddock dies whenever it sees CPP lines in the source. Any way to let it ignore them?
18:18:05 <stepcut>  return :: IOwnTheCopyright a => a -> GPL a
18:18:37 <dons> oren: yeah, you need to specify, Extensions:          CPP
18:18:39 <dons> in the .cabal file
18:19:04 <oren> As opposed to -cpp in the GHC options - got it
18:19:22 <dons> yep
18:19:54 <sorear> oren: also, write a library, not an executable
18:20:34 <oren> Its a library :-)
18:21:24 <sorear> good; http://hackage.haskell.org/trac/hackage/ticket/102
18:21:26 <lambdabot> Title: #102 (building haddock for executables wont CPP) - Hackage - Trac
18:23:57 <oren> is there a standard Cabal extension for glasgow-extensions? Specifically, multi-param classes? The doc doesn't seem to list one
18:24:11 <sorear> MultiParamTypeClasses
18:24:22 <sorear> @docs Distribution.Extension
18:24:23 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/Cabal/Distribution-Extension.html
18:25:21 <oren> Thanks
18:25:27 <sorear> Is the Show TypeRep instance surjective?
18:30:38 <sjanssen> dons: do you know who hughes at rpi dot edu is?  (xmonad contributor)
18:32:20 <dons> sjanssen: that's rashakil
18:32:28 <sjanssen> okay
18:32:35 <dons> though i was confused at first at rpi.edu.is ;-)
18:32:35 <sjanssen> I really don't like this layout changes
18:32:49 <dons> i don't like the code either. i like vertical mode though.
18:33:14 <dons> you could rollback the changes and do vertical mode in the style suggested
18:34:09 <sjanssen> vertical mode is great.  nearly 80 line functions and some strange layout algorithm that seems to be entirely non predictable is not
18:34:21 <sjanssen> @seen rashakil
18:34:22 <lambdabot> I saw rashakil leaving #haskell 36m 37s ago, and .
18:34:49 <dons> sjanssen: yep. i'd be fine if you rolled back those patches
18:35:15 <dons> like we've said, the layout code should be pure, and QuickCheckable
18:35:19 <dons> not a hugh imperative chunk
18:36:04 <sorear> dons: [binary] what is the motivation for tracking number-of-bytes-read?
18:36:13 <sjanssen> dons: have you tried it out at all?  I just don't understand it
18:36:26 <dons> sure. i've been using it for a couple of days now.
18:36:45 <sjanssen> try switching to horizontal mode and opening a bunch of xterms.  Why aren't they all the same size?
18:37:14 <dons> urgh. yuck
18:37:39 <dons> ok. i think we basically consider this an experiment. you want to roll back, or should i do it?
18:37:50 <sjanssen> I will
18:38:05 <dons> the trick of using the same code to do vert or horizontal layout is nice (just flip the args to the layout algo)
18:38:25 <dons> we should be able to do something like that with the original cleaner layout code
18:39:30 <sjanssen> I wish rashakil would've sent his horizontal layout and this 'disposition' junk as separate patches
18:39:35 <waern> how does the EOF Char literal look?
18:40:05 <sorear> ... we don't have eof here
18:40:10 <dons> :hoogle hIsEof
18:40:19 <sorear> things return Maybe, or just fai
18:40:20 <dons> ?hoogle hIsEof
18:40:20 <lambdabot> IO.hIsEOF :: Handle -> IO Bool
18:40:45 <dons> sorear: you're very bitter these days.
18:41:03 <dmwit> sjanssen: Do you use gmplayer?
18:41:20 <sorear> hmm.  problem.
18:41:51 <sjanssen> dmwit: nope
18:42:31 <sjanssen> dons: it looks like a simple rollback isn't possible due to dependencies
18:42:32 <dmwit> Okay.
18:44:05 <dons> sjanssen: you can roll them back one at a time usually.
18:44:19 * dons tries
18:44:39 <sjanssen> I'd have to rollback all sorts of useful changes to get to the bad patches
18:44:55 <dons> grr. i see what you mean.
18:45:22 <dmwit> Anyway, gmplayer screws up its rendering, and I was wondering if it is even possible that it is related to xmonad forcing it to a bigger window size than it knows how to deal with.
18:45:39 <dmwit> (or if I should look somewhere else for a solution.)
18:45:44 <sjanssen> dmwit: I've seen some funkiness with other video players
18:45:50 <sjanssen> I don't really know what causes it
18:45:52 <jcreigh> horizontal layout is broken on Xinerama, BTW.
18:46:05 <sjanssen> jcreigh: oh?  what happens?
18:46:13 <dmwit> The really odd thing is that it isn't the videos that screw up, it's the GTK (?) UI piece.
18:46:30 <jcreigh> sjanssen: the lower windows always show up on screen 1.
18:46:48 <dons> what might be better then is to revert back to before the badness
18:46:52 <jcreigh> but I don't really care, because I expect this will get fixed when we refactor the layout code anyway.
18:47:08 <dons> manually merge in the few smaller changes that were made after the vert layout code
18:47:37 <jcreigh> hmm...how does that work for me? Do I have to "unpull" a bunch of patchs, or will some giant "UNDO" patch show up in the repo?
18:48:39 <sjanssen> dons: you were looking in to a mailing list, yeah?
18:49:04 <dons> yes. have to find my admin passwd for haskell.org's mailing list admin thingy
18:49:18 <sjanssen> ah :)
18:50:53 <jcreigh> I was thinking, if we have some function like Rectangle -> [Window] -> [(Window, Rectangle)] (or whatever) doing our layout, then it would be trivial to do any sort of rotation.
18:54:05 <sjanssen> dons: maybe doing the revert by hand is best
18:54:37 <dons> sjanssen: yeah, i think so. can you take that on?
18:54:44 <sjanssen> yeah, I'll do it
18:54:54 <dons> and i promise not to apply any external patches till version 0.1 is tagged.
18:55:03 <jcreigh> "external"?
18:58:14 <dons> 3rd party random contributors ;-)
18:58:42 <jcreigh> ah
18:59:20 * sorear thinks he will write a fast bytestring-based text serialization lib
18:59:21 <jcreigh> Working with xmonad has reinforced the functional programming answer to bugs with mutable state: "Don't do that, then!"
18:59:58 <sorear> @remember jcreigh Working with xmonad has reinforced the functional programming answer to bugs with mutable state: "Don't do that, then!"
18:59:59 <lambdabot> Done.
19:01:17 <dolio> dons: Heh, so, you ask for examples where people are writing lots of type-incorrect code that is nonetheless bug-free, and the example you get is one where Haskell's type system is *too* permissive?
19:01:30 <dons> apparently :/
19:01:39 <jcreigh> hmm?
19:01:43 <dons> he wanted a Natural type, but got Integer by default. sigh.
19:03:41 <sorear> @where xmonad
19:03:41 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
19:05:38 <dons> http://lambda-the-ultimate.org/node/2164
19:05:39 <lambdabot> Title: Mutable variables eliminated from .NET | Lambda the Ultimate
19:06:43 <sjanssen> vimdiff++
19:08:05 * jcreigh continues in his plan to get bloatware into dmenu...
19:08:34 <sjanssen> jcreigh: how were your patches received?
19:09:20 <jcreigh> sjanssen: well, I tried to talk to the guy on IRC...he never replied. (The #dwm channel on oftc seems pretty dead) I'm gonna try emailing him.
19:15:09 <sorear>         , focus  :: {-# UNPACK #-} !(M.Map Int a)    -- ^ the window focused in each stack
19:15:23 <sorear> that won't work, Map has two constructors ...
19:15:48 <jcreigh> ???
19:15:58 <sorear> Bin and Tip
19:16:02 <sjanssen> yeah, that's correct
19:16:49 <sorear> Too bad we can't just use nullPtr for Tip and make it a one-constr type :)
19:17:08 <jcreigh> I don't understand. Bin and Tip? What the heck?
19:17:22 <sorear> (Non-exported) constructors of Map.
19:17:29 <sorear> Tip is empty, Bin is non-empty.
19:17:49 <sorear> The point being that {-# UNPACK #-} only has an effect on single-constructor types.
19:18:02 <sorear> so it's just wasted characters here.
19:18:12 <jcreigh> oh, unpacking "won't work". gotcha.
19:18:12 <sorear> (thankfully none of them newlines ;)
19:18:19 <jcreigh> lol
19:19:12 <dons> yes, it only works on single-constructor data
19:22:24 <jcreigh> okay, now we'll see if 9 extra LOC is too much for the dmenu folks to bear...
19:30:40 <stepcut> hrm, I need a way to make a type-constructor that converts something of type, Maybe a, to type, [a]. I don't think I can do that :-/
19:32:17 <dons> you'd need a smart constructor
19:32:24 <crazyrk> <>  hiya <><>499)<>
19:32:39 <dons> ?hoogle maybeToList
19:32:40 <lambdabot> Maybe.maybeToList :: Maybe a -> [a]
19:32:51 <crazyrk> hello
19:33:07 <crazyrk> im having some problems to compile a program in haskell with ghci
19:33:16 <crazyrk> can someone help me ?
19:33:17 <stepcut> dons: yeah, that is a function, I need a *type constructor* :)
19:33:25 <dibblego> the number of Australians who think a tsunami is caused by climate change makes me ashamed of being called Australian
19:33:31 <dibblego> er, wrong window
19:33:42 <Pseudonym> stepcut: Why on earth do you need a type constructor?
19:33:47 <qwr> crazyrk: no, unless you say what your problem is
19:34:11 <crazyrk> ok, im a newbie in this programming language
19:34:26 <crazyrk> and i dont know how to compile hello.hs,
19:34:36 <crazyrk> i cant understand the part of this website
19:34:41 <crazyrk> that says how to compile
19:34:42 <crazyrk> http://haskell.org/haskellwiki/Haskell_in_5_steps
19:34:43 <lambdabot> Title: Haskell in 5 steps - HaskellWiki
19:34:50 <crazyrk> well
19:35:02 <crazyrk> it says something like $ ghci hello hello.hs
19:35:21 <crazyrk> but i dont know where i can do this because im using windows...
19:35:32 <Pseudonym> ghc -o hello hello.hs
19:35:35 <Pseudonym> That's what it says.
19:35:37 <dibblego> ghc -o hello hello.hs
19:35:40 <stepcut> Pseudonym: wacky reasons...
19:35:40 <crazyrk> well but
19:35:43 <dibblego> you do that at the command prompt
19:35:47 <crazyrk> k
19:35:49 <crazyrk> like
19:35:50 <Pseudonym> stepcut: I'm all ears.
19:35:57 <crazyrk> exec ghc.exe -o hello hello.hs
19:36:04 <crazyrk> with hello.hs in the same dir of ghci ?
19:36:07 <Pseudonym> You don't need the exec.
19:36:14 <crazyrk> well k
19:36:17 <dibblego> crazyrk, no, the command prompt, just type ghc ...
19:36:20 <Pseudonym> crazyrk: ghc.exe should be somewhere on your $PATH.
19:36:25 <Pseudonym> As should ghci.
19:36:26 <dibblego> s/$PATH/%PATH%
19:36:32 <Pseudonym> Err... yeah.
19:36:33 <crazyrk> well
19:36:34 <Pseudonym> PATH, anyway.
19:36:36 <crazyrk> ok let me try
19:37:03 <Pseudonym> You can check by typing "env" at the command prompt.
19:37:08 <Pseudonym> Look for the PATH line.
19:37:19 <dibblego> also, echo %PATH%
19:37:39 <stepcut> Pseudonym: well, it all started when I tried to figure out what I should name this function:
19:37:40 <stepcut> someFunction :: (Functor f, Functor g) => (f a -> f b) -> (g a -> g b)
19:37:46 <crazyrk> k
19:37:48 <crazyrk> i did it
19:37:57 <Pseudonym> stepcut: superNaturalTransformation
19:38:00 <crazyrk> but it didnt create a .exe
19:38:09 <crazyrk> like hello.exe, as its saying on the website
19:38:24 <dibblego> what did it do?
19:38:25 <stepcut> Pseudonym: would that be similar to a Natural Transformation from category theory ?
19:38:29 <Pseudonym> ?free someFunction :: (F a -> F b) -> (G a -> G b)
19:38:29 <lambdabot> $map_F g . h = k . $map_F f => $map_G g . someFunction h = someFunction k . $map_G f
19:38:34 <Pseudonym> Woo.
19:38:37 <sorear> ghc.exe -o hello.exe hello.hs  maybe?
19:38:38 <crazyrk> it says something like: Compiling main
19:38:44 <sorear> yeah
19:38:45 <crazyrk> k
19:38:46 <crazyrk> a sec
19:38:48 <crazyrk> let me try
19:38:49 <dibblego> sorear, try what sorear said
19:38:53 <sorear> should create .o and .hi files
19:38:55 <sorear> dibblego: why?
19:38:57 <Pseudonym> stepcut: It's actually a mapping between natural transformations.
19:39:03 <Pseudonym> A natural transformation is a mapping between functors.
19:39:04 <dibblego> sorear, because! :)
19:39:07 <Pseudonym> Example: Maybe a -> [a]
19:39:08 <sorear> ok. :)
19:39:12 <Pseudonym> Maybe is a functor, as is [].
19:39:36 <sorear> There's a commuation law too
19:39:44 <Pseudonym> Yup.
19:39:47 <dons> class (Functor f, Functor g) => NatTransf f g where
19:39:48 <dons>     eta :: f a -> g a
19:39:49 <Pseudonym> And that's the function's free theorem.
19:39:58 <Pseudonym> ?free foo :: Maybe a -> [a]
19:39:58 <lambdabot> $map f . foo = foo . $map_Maybe f
19:40:05 <Pseudonym> That the law you were looking for?
19:40:06 <crazyrk> [sorear]: it says: Warning: ignoring unrecognized input 'hello.exe'
19:40:18 <crazyrk> when i tried to exec like ghci.exe hello.exe hello.hs
19:40:24 <dibblego> crazyrk, -o
19:40:27 <dons> crazyrk: don't use ghci. :-)
19:40:29 <crazyrk> omg
19:40:32 <dons> ghc.exe hello.hs
19:40:35 <crazyrk> totally forget about it
19:40:35 <Pseudonym> sorear: It might make more sense if you spell both of those map functions "fmap".
19:40:36 <dons> ./hello.exe
19:40:38 <dibblego> <sorear> ghc.exe -o hello.exe hello.hs  maybe?
19:40:41 <stepcut> Pseudonym: my understanding (which is exceedingly limited) is that a natural transformation is a mapping between two functors, but that both functors are to/from the same categories. Like f : C -> D, g : C -> D ?
19:40:44 <Pseudonym> fmap f . foo = foo . fmap f
19:40:46 <sorear> crazyrk: ghci is an interpreter, hence the 'i'
19:40:49 <crazyrk> there is no ghc.exe here
19:40:54 <sorear> ghc is the compiler
19:41:01 <crazyrk> omg
19:41:06 <dons> do you have ghc in your path? if you have ghci, (the interpreter) , you also have ghc.
19:41:08 <sorear> ok, then you can't compile programs.
19:41:16 <crazyrk> thats why there is a i there ?
19:41:20 <crazyrk> haha omg, thank you guys
19:41:23 <dibblego> i means interpreter
19:41:28 <dibblego> you want the compiler (ghc)
19:41:43 <sorear> stepcut: right.
19:41:48 <Pseudonym> stepcut: Yes.
19:41:55 <chessguy> hi all
19:41:55 <lambdabot> chessguy: You have 2 new messages. '/msg lambdabot @messages' to read them.
19:42:03 <chessguy> oh my
19:42:05 <Pseudonym> "Functor" in this case means endofunctor.
19:42:14 <sorear> stepcut: My understanding is probably even more limited than yours.
19:42:22 <Pseudonym> A Haskell Functor is actually a functor from the category Haskell to the category Haskell.
19:42:25 <crazyrk> ok, now i have 3 archives: hello.hi, hello.o and hello.exe
19:42:32 <dons> hello.exe is your program.
19:42:33 <crazyrk> what do hello.hi and hello.o do ?
19:42:38 <sorear> stepcut: strictly limited to everithing (a) on wikipedia (b) provable by sorear
19:42:47 <sorear> crazyrk: caching
19:42:51 <dons> crazyrk: they're just temporary files created by the compiler, basically
19:42:53 <stepcut> sorear: that about matches mine ;)
19:42:57 <Pseudonym> stepcut: It might make more sense when you think about arrows.
19:43:03 <crazyrk> [sorear]: so, i can delete them ?
19:43:08 <sorear> crazyrk: yes
19:43:08 <Pseudonym> An arrow is not necessarily in the category Haskell, conceptually speaking.
19:43:12 <crazyrk> and the program will keep working ?
19:43:20 <sorear> crazyrk: yes
19:43:35 <crazyrk> [sorear]: whoa
19:43:35 <sorear> crazyrk: btw, your messages to me are littered with control-O's
19:43:51 <sorear> <*crazyrk> [sore^Oar]^O: ^Owhoa
19:43:59 <crazyrk> sorry, i didnt understand what you said
19:44:50 <stepcut> Pseudonym: ok. some people have suggested that functors could be viewed as a mapping from the category Hask to a subcategory, such as Maybe. Though, I guess that could still be consider a mapping from Hask -> Hask
19:45:04 <Pseudonym> Right.
19:45:05 <sorear> stepcut: into v. onto
19:45:14 <Pseudonym> An arrow is also such a mapping.
19:45:17 <Pseudonym> ?t pure
19:45:17 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
19:45:23 <Pseudonym> :t pure
19:45:25 <lambdabot>     Ambiguous occurrence `pure'
19:45:26 <lambdabot>     It could refer to either `pure', imported from Control.Arrow
19:45:29 <sorear> :t arr
19:45:29 <Pseudonym> :t arr
19:45:33 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
19:45:33 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
19:45:36 <Pseudonym> Right.
19:45:44 <crazyrk> well, can i type like cd c:\blabla\blabla on cmd ?
19:45:46 <Pseudonym> It's a mapping from Haskell to another category A.
19:45:57 <sorear> crazyrk: should work ...
19:45:59 <crazyrk> or can i only access folders by typing the folders names ?
19:46:08 <sorear> crazyrk: I'ven't used windows in >3 years
19:46:10 <Pseudonym> With >>> being the composition operator in this new category.
19:46:17 <crazyrk> well, but can i make a program like ghc.bat
19:46:21 <Pseudonym> arr f >>> arr g = arr (f . g)
19:46:28 <crazyrk> to go to c:\ghc\ghc~ auto ?
19:46:34 <Pseudonym> Or I might have gotten one of them flipped.
19:46:40 <Pseudonym> It might be arr (g . f)
19:46:44 <qwr> crazyrk: add the ghc directory to your path
19:46:44 <Pseudonym> In fact, I think it is.
19:46:54 <qwr> crazyrk: unless it already is there...
19:46:59 <crazyrk> [qwr]: you mean
19:47:08 <crazyrk> i create a icon ?
19:47:10 <chessguy> @src (>>>)
19:47:10 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
19:47:18 <Pseudonym> @type (>>>)
19:47:21 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
19:47:23 <crazyrk> but can i make a icon to cmd start on this folder ?
19:47:26 <sorear> @src Arrow
19:47:26 <lambdabot> class Arrow a where
19:47:27 <lambdabot>     arr, pure   :: (b -> c) -> a b c
19:47:27 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
19:47:27 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
19:47:27 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
19:47:27 <Pseudonym> Yes.
19:47:28 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
19:47:30 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
19:47:32 <Pseudonym> @type (.)_
19:47:33 <Pseudonym> @type (.)
19:47:34 <lambdabot> Pattern syntax in expression context: _
19:47:36 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
19:47:36 <qwr> crazyrk: i mean right-click on the damn system, get properties and search the path there...
19:47:54 <crazyrk> [qwr]: oh yeah
19:48:00 <crazyrk> like on desktop you say ?
19:48:11 <stepcut> neat. I think I can define my function using the NatTransf class that dons referenced
19:48:31 <dons> stepcut: yeh, I reckon son.
19:48:34 <dons> reckon so.
19:48:35 <qwr> crazyrk: http://www.computerhope.com/issues/ch000549.htm
19:48:36 <lambdabot> Title: How to set the path in Windows 2000 / Windows XP.
19:48:57 <sioraiocht> can someone explain what data Hash    = HT !Int !Int !(A.IOArray Int Buckets) means?
19:49:08 <dons> strict fields in the HT struct.
19:49:09 <sioraiocht> what are all those exclamation points?
19:49:23 <dons> so they're evaluated on update.
19:49:34 <crazyrk> [qwr]: thanks..
19:49:49 <dons> sioraiocht: its like having a `seq` on each update to the HT type.
19:50:07 <dons> but note, HT is pretty slow, and Map is likely to be better performing, if you're considering using this type.
19:50:30 <sioraiocht> dons: it was someone else's code, just tring to understand it
19:50:42 <sioraiocht> s/tring/trying/
19:50:46 <dons> ah ok. looks a lot ike the standard HashTable type.
19:51:02 <stepcut> cool, thanks. I have to run and go make dinner, bbl.
19:51:56 <sioraiocht> dons: I don't think I understand haskell enough to understand how you have hashtables in haskell...i take it you need monads?
19:52:10 <sioraiocht> :t MapM
19:52:12 <lambdabot> Not in scope: data constructor `MapM'
19:52:19 <sioraiocht> :t MapM_
19:52:22 <lambdabot> Not in scope: data constructor `MapM_'
19:52:41 <dons> sioraiocht: for true mutable hashtables, you run in the IO or ST monad, yeah.
19:52:50 <dons> since an updated destroys the old entry
19:52:54 <sioraiocht> dons: thanks :)
19:53:12 <Pseudonym> It's a little known fact that one of the free theorems for Arrows is this:
19:53:14 <oren> dons: I got my infamous streaming parser to work, except that it has a mysterious (to me anyway) memory "leak". You can see it in http://www.ben-kiki.org/oren/YamlReference/ if you are interested. It was trickeir than I expected...
19:53:19 <lambdabot> Title: YamlReference
19:53:21 <dons> normallly you'd use a Trie or Map, and keep things both pure and more flexible (hashtables are rarely used, except in particularly well suited scenarios)
19:53:26 <Pseudonym> If foo :: A a a -> B a a (A and B are arrows), then:
19:53:32 <dons> oren: did you sort out the leak?
19:53:36 <Pseudonym> foo a >>> arr f = arr f >>> foo a
19:53:58 <Pseudonym> Direct analogy to the free theroem for F a -> G a.
19:54:00 <oren> dons: Nope. Tried profiling it with -h<all-sort-sof-stuff> and didn't get very far
19:54:50 * crazyrk ouvindo Metalslug anthology psp - ! [quality:??kbits ??KHz time:00:00] -=[Cyber]=-
19:55:00 <crazyrk> sorry
19:55:22 <oren> I probably reached my understanding of Haskell run-time behavior at this point. Getting the streaming right wasn't a picnic, I had to streamline everything (up to hacking around the record constructors)
19:56:30 <dons> i don't have time to look into it this week, so you might want to try posting the code and profiling info to haskell-cafe@ and seeking advice
19:57:18 <dons> dibblego: heh ,they evacuated bondi for the tsunami...
19:57:55 <crazyrk> well men, can you help me with some questions about windows ? or only say where i can get answers ?
19:58:20 <dibblego> dons, we are idiots
19:58:42 <oren> dons: Sure, thanks. I'll do that.
19:59:00 <dons> crazyrk: specific haskell questions we can help with, some small windows questions we can maybe help with. but for general windows help you'll need to try somewhere else
19:59:11 <crazyrk> [dons]: ok
19:59:21 <crazyrk> a little time ago i defraged my hard disk
19:59:34 <crazyrk> and them, windows xp started to show the blue screen of death
19:59:47 <crazyrk> before i do the defrag, it started to show problems
19:59:48 <Pseudonym> crazyrk: And not everyone here is a man.
19:59:50 <dons> ok. that's not the kind of question to ask on #haskell.
19:59:56 <crazyrk> k
19:59:57 <crazyrk> sorry
19:59:58 <Pseudonym> I am, of course.  But, for example, lambdabot isn't.
19:59:59 <sorear> Pseudonym: still?
20:00:08 <crazyrk> isnt lambdabot a bot ?
20:00:17 <Pseudonym> That's not a man.
20:00:20 <dibblego> crazyrk, your jurisdiction likely has laws regarding faulty goods and the obligations of suppliers in those events
20:00:25 <dons> dibblego: heh
20:00:33 <dibblego> crazyrk, in Australia, it is called the "Trade Practices Act 1974"
20:00:43 <crazyrk> wait
20:00:47 <dibblego> crazyrk, I also happen to know it is section 74B (I use this piece of law often)
20:00:52 <crazyrk> i cant understand at all what you are saying
20:00:58 <crazyrk> ill try a translator, wait a second
20:01:06 <dibblego> crazyrk, wherever you are from has a law regarding defective goods
20:01:22 <crazyrk> [dibblego]: oh
20:01:30 <crazyrk> you mean that my HD is with problems ?
20:01:31 <dibblego> crazyrk, if you ask a man to buy a fish and he gives you a turtle, you can demand a refund
20:01:49 <crazyrk> yes, thats no problem, but this HD was old
20:01:59 <crazyrk> i mean, it was very good when it was on the warranty
20:02:11 <crazyrk> but like 2 years later it started this problem
20:02:19 * sorear still wonders what ^O means
20:02:26 <dibblego> yes. manufacturers calculate so that your device becomes faulty soon after warranty expiry
20:02:38 <mlh_> crazyrk: stop. go directly to #windows
20:02:42 <crazyrk> ok
20:02:56 <crazyrk> it doesnt exist
20:02:56 <dibblego> in Australia, houses are guaranteed for 7 years; I once built houses - they fall over after 7 years and 1 month
20:03:20 <crazyrk> dibllego
20:03:23 <sorear> @localtime dibllego
20:03:25 <crazyrk> i agree with you but,
20:03:28 <sorear> @localtime dibblego
20:03:29 <lambdabot> Local time for dibblego is Mon Apr  2 13:01:12
20:03:34 <sorear> aww :)
20:03:35 <crazyrk> when i defrag the disk, it start the problems
20:03:45 <crazyrk> when its not "defraged" it works fine
20:04:03 <sorear> crazyrk: defrag touches lots of disk.
20:04:06 <crazyrk> but i think: defrag was made to improve HD's velocity, not to trash them, am i right ?
20:04:10 <dibblego> crazyrk, windows is defective
20:04:28 <sorear> crazyrk: defrag won't make your disk actually spin faster
20:04:32 <sorear> crazyrk: think of a book
20:04:39 <crazyrk> yea, but this helps the hd
20:04:52 <sorear> crazyrk: if you rearrange the pages so the things you want to read are close together
20:04:53 <crazyrk> oh sorry
20:04:53 <mlh_> please ..
20:04:58 <crazyrk> i said it wrond
20:04:59 <sorear> crazyrk: you can read it faster
20:05:06 <crazyrk> wrong*, scandisk did it
20:05:09 <sorear> crazyrk: but it doesn't actually make the pages lighter
20:05:24 <crazyrk> not defrag, i used scandisk, and the hd started to show the blue screen of death
20:05:34 <crazyrk> no problems with defrag, i said it wrong :(
20:05:49 <Pseudonym> You're still asking in the wrong place, BTW.
20:06:09 <Cale> Yeah, this channel is about the programming language Haskell.
20:06:17 <sioraiocht> wow, so much hate..
20:06:19 <Gwern> if a program does "executeFile prog True args Nothing" where the program is itself and the args were the ones it itself was called with, would the PID change?
20:06:25 <Pseudonym> If the question is Haskell + Windows, this is the right place.
20:06:31 <crazyrk> ok, sorry
20:06:32 <Gwern> sioraiocht: well, Windows, y'know
20:06:35 <crazyrk> ill ask on windows
20:06:36 <Pseudonym> If it's Windows - Haskell, wrong place.
20:06:40 <Pseudonym> Good luck.
20:06:46 <sioraiocht> Gwern: understood.
20:06:53 <Pseudonym> And please come back with more Haskell questions, let us know how you're going!
20:06:55 * sorear exorcises crazyrk's pc
20:07:08 <crazyrk> ok :)
20:07:21 * Gwern had a haskell question :(
20:07:41 <crazyrk> at windows, ppl ignore me
20:07:42 <crazyrk> ;(
20:07:52 <dons> Gwern: does executeFile change the PID, when you exec a process in the current address space?
20:07:58 <Gwern> crazyrk: at windows, people have enough problems of their own
20:08:06 <Gwern> dons: I have no idea, that's why I'm asking
20:08:14 <crazyrk> :p
20:08:24 <Gwern> I don't have a clue what xmonad's restart does or means
20:08:59 <dons> hehe. it replaces the current xmonad process with a new one, running in the same address space
20:09:25 <dons> man 2 execve
20:09:32 <Gwern> dons: so... does this mean a restart would not pick up config changes made by a recompile and install?
20:09:42 <Gwern> (wait, you can't install over a running xmonad anyway)
20:09:51 <dons>      The new process also inherits the following attributes from the calling
20:09:51 <dons>      process:
20:09:51 <dons>            process ID           see getpid(2)
20:10:05 <dons> Gwern: it means a restart *will* pick up config changes.
20:10:24 <dons> you can install over a running xmonad, btw. rm -f `which xmonad`; install
20:10:40 <Gwern> ah, so you have to remove it first. that makes sense
20:10:55 <Gwern> dons: short answer is the PID won't change, if I understand you
20:11:54 <mlh_> correct, exec does not change the PID.  That's a unix/posix thing, not a haskell thing
20:11:55 <crazyrk> well, what os you all recomend me to use to work with haskell ?
20:12:09 <dons> see man execve for the precise semantics for what's happening, Gwern
20:12:43 <dons> crazyrk: using linux would make thing easiest, if you're considering switching OSs to do more coding. gentoo, debian, fedora, ubunutu, are all good choices  i think
20:13:02 <crazyrk> [dons]: what about a os for a newbie in linux ?
20:13:45 <dons> linux is a good os for a newbie to linux.
20:14:03 <dino-> crazyrk: Perhaps Ubuntu then.
20:14:08 <sorear> When are you have is linux, it's extremely hard to get anything done.
20:14:30 <sorear> kernel panic: no init found
20:14:41 <crazyrk> is it very hard to learn how to deal with ubuntu ?
20:14:43 <dons> sorear is so bitter for such a young fellow. its disheartening.
20:14:50 <dons> sorear: don't you still want to change the world?
20:15:27 <dino-> crazyrk: I'm probably not a good person to ask about the relative easyness of a given distro for new users, but word on the street is that much Just Works Right with Ubuntu without so much fuss.
20:15:44 <Cale> crazyrk: Ubuntu is pretty easy to get started with.
20:15:49 <crazyrk> thanks
20:16:04 <Cale> crazyrk: I found it easier to install than windows.
20:16:17 <crazyrk> how can i register my nickname in this network ?
20:16:26 <Cale>  /msg nickserv help register
20:17:10 <dino-> crazyrk: I followed these instructions: http://freenode.net/faq.shtml#nicksetup
20:17:11 <lambdabot> Title: freenode: frequently-asked questions
20:17:22 <crazyrk> already registered dino- ;)
20:17:23 <crazyrk> thx
20:17:48 <dino-> That page goes into doing everything including an alternative nick.
20:18:55 <dino-> Hey, I got a project I'm working on set up with cabal today. It's pretty cool. I'm annoyed I spent time writing Makefiles for Haskell projects prior to this.
20:25:14 <dons> dino-: hehe. welcome to the 21st century :-) we have lambdas now.
20:25:34 <dons> the Makefile days for building haskell libraries in particular were very bad
20:25:53 <dons> it was extremely difficult to generate portable haskell libraries before cabal
20:26:07 <dino-> dons: I hadn't really tried anything serious with H and Makefiles. :o
20:26:24 <dons> applications weren't too hard, ghc --make Main.hs -O
20:26:37 <dino-> But I was also never really thrilled with Ant and similar things over in the Java world, as build systems go.
20:26:38 <dons> but generated libHSfoo.{a,o,p_o} urgh. too hard
20:26:55 <sorear> Now we just write up a short machine readable description of our project, and it All Just Works
20:27:37 <dino-> Is it possible to add new targets beyond the configure, build, etc.. ?
20:27:45 <sioraiocht> is there an xor operator in haskell?
20:27:52 <sorear> yes
20:27:56 <sorear> /= for bools
20:28:01 <sorear> `xor` for ints
20:28:13 <sioraiocht> tanks
20:28:14 <dons> ?hoogle xor
20:28:14 <lambdabot> Data.Bits.xor :: Bits a => a -> a -> a
20:28:19 <sorear> dino-: not really
20:28:31 <sorear> dino-: we want rpm, deb, ghci, etc targets
20:28:37 <dons> dino-: right, its possible, but not encouraged at all.
20:28:51 <dons> so for other targets we usually have seperate tools
20:29:02 <dons> e.g. cabal-check, rpm generating, deb generation
20:29:37 <sorear> Why don't we have cabal-configure, cabal-build, cabal-install?  Just history?
20:30:32 <dons> cabal was designed as a Makefile system, originally.
20:30:41 <dons> only now does the standalone tool/target concept appear
20:30:54 <dons> so in the next year or two i'd imagine we'll end up with seperate tools for each target
20:31:04 <dons> or at least:  cabal {configure,build,install}
20:31:06 <dons> and the rest
20:31:36 <sorear> hm.  How do they handle hooks?  (What are hooks used for, anyway?)
20:31:42 <dons> if you recall all the Makefile/autoconf build systems we originally wanted to handle
20:31:53 <dons> hooks were the obvious way to bring across legacy build systems
20:32:11 <dons> but it turned out that hooks just made for problems, so they're very rarely used now
20:32:26 <Pseudonym> Or that by next year, cabal will also make toast.
20:32:29 <dons> so much so we could probably get rid of Setup.hs files
20:32:44 <dons> and just use defaultMain by default, without much harm
20:33:00 <sorear> So, in theory, hooks aren't need now - we can use .cabal for everything (and autoconf for ffi)?
20:33:14 <dons> autoconf for ffi dependencies/C files, yeah
20:33:33 <dons> since configure scripts are run automatically anyway
20:33:43 <dons> you can stick anything you need run in that, and forget about custom hooks
20:34:55 <sorear> whoa!  since when does hackage do haddock?
20:35:02 <sjanssen> oh, configure scripts are run automatically?
20:35:08 <sorear> yes
20:35:08 * sjanssen didn't know that
20:36:24 <dons> oh that's cool!
20:36:30 <dons> hackage + haddock. woot!
20:36:35 * dons detects ross' hand in this
20:36:55 <sorear> @karma ross
20:36:55 <lambdabot> ross has a karma of 0
20:36:57 <sorear> @karma rossp
20:36:57 <dons> eg. http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary-0.3
20:36:57 <lambdabot> rossp has a karma of 0
20:36:59 <lambdabot> http://tinyurl.com/25ptqt
20:37:00 <dons> click on the module list.
20:37:04 <sorear> @karma rpaterson
20:37:05 <lambdabot> rpaterson has a karma of 0
20:37:21 <sorear> who to ++?
20:38:57 <sorear> Too bad there are no source links :)
20:40:55 <sorear> Hmm, I have no cabal-setup program.  Do I need to do something special for it to be installed?
20:43:01 <ddarius> dons: sorear stopped wanting to change the world when he became a Haskell programmer.
20:43:11 <dons> heh
20:43:38 <brad_> i have a beyond trivial question: maintaining a simple global Int counter
20:43:48 <brad_> lets say i have i = [0..]
20:44:04 <brad_> but i cannot say i = tail i
20:44:27 <dons> you want a unique supply of integers?
20:44:33 <brad_> yes
20:44:42 <dons> such that some method 'get' returns the next element in the list each time its called?
20:44:57 <brad_> exactly, i can tell it should be something i should know
20:45:01 <dons> (this is a classic state monad)
20:45:07 <brad_> ah
20:45:36 <brad_> thanks!
20:45:57 <sjanssen> @hoogle runState
20:45:58 <lambdabot> Control.Monad.State.runState :: State s a -> (s -> (a, s))
20:45:58 <lambdabot> Control.Monad.State.runStateT :: StateT s m a -> (s -> m (a, s))
20:46:06 <dons> > let next = do { (i:rs) <- get ; put rs } in runState (do a <- next ; b <- next ; return [a,b]) [1..]
20:46:08 <lambdabot>  ([(),()],[3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
20:46:16 <brad_> wow dons, thanks!
20:46:25 <dons> > let next = do { (i:rs) <- get ; put rs; return i } in runState (do a <- next ; b <- next ; return [a,b]) [1..]
20:46:27 <lambdabot>  ([1,2],[3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
20:46:49 <crazyrk> well ppl
20:46:51 <crazyrk> im leaving
20:46:57 <dons> see the stateful code in the first argument to runState, brad_ ?
20:46:59 <crazyrk> good bye
20:47:06 <crazyrk> and good morning for every1
20:47:13 <dons> it just runs this 'next' function, which pops the head of the supply
20:47:41 <brad_> i see, or i will soon! thanks so much dons
20:47:48 <dons> so all the plumbing of this [1..] list around is hidden by the monad.
20:47:49 <brad_> this is one for the cookbook
20:48:04 <dons> yeah.
20:48:16 <brad_> a classic howto that is a little trickier than meets the eye
20:48:20 <sjanssen> yikes, the layout refactor cut out 63 LoC!
20:48:48 <stepcut> nice!
20:48:56 <sjanssen> phrased otherwise, the initial layout patches added 63 lines of bloat
20:49:00 <dons> sjanssen: good sign.
20:49:07 <stepcut> not nice :(
20:49:17 <dons> is the layout algo pure now?
20:49:29 <brad_> thanks to all for the help! bye
20:49:38 <sjanssen> it's the same as it was before
20:49:48 <sjanssen> I haven't done vert mode yet
20:49:59 <dons> ok
20:53:21 <narain> is . a valid character in operator names?
20:53:34 <stepcut> narain: yes
20:53:40 <narain> cool, thanks
20:54:09 <stepcut> e.g: .+.
20:57:49 <narain> ?pl \x y -> f x (g y)
20:57:49 <lambdabot> (. g) . f
21:00:04 <Cale> ?pl \x y z -> x z (y z)
21:00:05 <lambdabot> ap
21:01:07 <narain> huh?
21:01:09 <narain> :t ap
21:01:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
21:01:24 <dolio> ?pl curry $ ap (f . fst) (g . snd)
21:01:24 <lambdabot> curry (liftM2 f fst (g . snd))
21:01:28 <narain> that's... an interesting instantiation
21:01:41 <Cale> indeed :)
21:01:59 <Cale> > map (ap (,) (^2)) [0..10]
21:02:01 <lambdabot>  [(0,0),(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]
21:02:58 <narain> so it's not as useless as my initial suspicions :)
21:03:00 <Cale> @type ap (,)
21:03:02 <lambdabot> forall a b. (a -> b) -> a -> (a, b)
21:03:34 <Cale> > let fibs = 0 : 1 : ap (zipWith (+)) tail fibs
21:03:34 <lambdabot>  Parse error
21:03:37 <Cale> > let fibs = 0 : 1 : ap (zipWith (+)) tail fibs in fibs
21:03:38 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
21:04:03 <QtPlatypus> :t (,)
21:04:05 <lambdabot> forall a b. a -> b -> (a, b)
21:04:34 <narain> > let fibs = fix ((0:).(1:).ap (zipWith (+)) tail) in fibs
21:04:35 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
21:04:47 <QtPlatypus> > (,) "a" "b"
21:04:49 <lambdabot>  ("a","b")
21:05:10 <narain> > (1,) 2 -- doesn't work :(
21:05:11 <lambdabot>  Parse error
21:05:49 <narain> > let x *> = map (x *) in 2 *> [1..3]
21:05:49 <lambdabot>  Parse error
21:05:52 <narain> aww
21:05:53 <dons> oren: good email. hopefully that will get some people looking into it
21:06:01 <dolio> Yeah, you can't section (,) and variations.
21:06:08 <dons> if you've not solved it by the weekend, remind me, and i'll have a look
21:06:14 <dmwit> > let (*>) x = map (x *) in 2 *> [1..3]
21:06:16 <lambdabot>  [2,4,6]
21:06:50 <narain> can't use sections in function definitions either apparently
21:07:12 <QtPlatypus> ?pl (\a -> (a,"b"))
21:07:12 <lambdabot> flip (,) "b"
21:07:21 <dmwit> > let (x *>) = map (x *) in 2 *> [1..3] -- does this work?
21:07:21 <lambdabot>  Parse error in pattern
21:07:23 <narain> seemed like a nice analogue to curried definitions with partial arguments
21:07:36 <QtPlatypus> ?pl (\b -> ("a",b))
21:07:37 <lambdabot> (,) "a"
21:09:02 <narain> ?pl \x y -> f (g x) y
21:09:02 <lambdabot> f . g
21:09:15 <dolio> Yeah. I'm not sure why that isn't allowed. There might be a good reason I haven't thought of.
21:09:41 <narain> > let (*>) = (*) . map in 2 *> [1..3]
21:09:42 <lambdabot>  Couldn't match expected type `[a] -> [b]'
21:10:21 <dolio> > let (*>) = map . (*) in 2 *> [1..3]
21:10:22 <lambdabot>  [2,4,6]
21:10:30 <narain> > let (*>) = map . (*) in 2 *> [1..5]
21:10:31 <lambdabot>  [2,4,6,8,10]
21:10:44 <narain> that's rather impenetrable though
21:11:32 <dolio> Eh. Depends how much point free code you've stared at.
21:12:10 <narain> not enough, clearly
21:12:12 <dons> yeah, looks like it could be optimised some more, imo
21:13:01 <narain> dons: really? i am intrigued
21:13:53 <dolio> I think he's pulling your leg.
21:14:01 <narain> :t (?f .) . ?g
21:14:04 <lambdabot> forall b c a a1. (?f::b -> c, ?g::a1 -> a -> b) => a1 -> a -> c
21:14:16 <narain> ah right.
21:14:30 <narain> dolio, dons: but it's past midnight over here!
21:14:54 <Gwern> narain: maybe not where they are, you insensitive clod!
21:15:11 <dolio> It's past midnight where I am, too.
21:15:20 <narain> i hereby declare myself off limits to april fool's
21:15:24 <EvilTerran> it's very much past midnight where i am
21:15:50 <dolio> I don't think 'map . (*)' is that bad, although I might not use it myself.
21:15:54 * EvilTerran exclaims, having provided nothing else to the conversation for several hours (if not days)
21:16:03 <dolio> Although, I'm certain I have.
21:16:24 <dolio> When I was trying to get my main function to one line.
21:17:51 <dolio> putStrLn . unlines . flip map [1..10] . func . read =<< getArgs
21:17:54 <dolio> Or something like that.
21:19:07 <narain> took me a minute to read that
21:19:45 <dolio> :)
21:20:33 <Cale> Get the program args, read them, apply func, you get a function, which you map over [1..10], then apply unlines to that and print it out.
21:20:35 <dmwit> map read?
21:20:56 <Cale> yeah, probably should be map read
21:21:01 <dolio> Yeah, well, I was just making stuff up.
21:22:22 <narain> i find point-free code and long chains of function compositions tempting, but (this may be my newbness showing) i always wonder if writing code that takes myself a minute a line to parse is really a good idea
21:22:28 <narain> but i go ahead and do it anyway
21:22:45 <Gwern> narain: rmemeber, bug count per line of code is a constant! so shorter is better! :)
21:23:49 <narain> Gwern: but is a bug in a line you don't understand better than two in two lines you do?
21:24:32 <Gwern> narain: yes!
21:24:50 <Gwern> because it means fewer permutations before it randomly works, and besides 1 bug is still better than 2 :)
21:25:25 <Gwern> remember, permutations rises exponentially, so it's more feasible to do random changes in one line then two
21:25:53 <narain> remind me never to ask you to debug my code :p
21:26:17 <dolio> I think it gets easier to read that stuff as you go on, too.
21:26:19 <narain> "random changes"? egads
21:26:32 <narain> dolio: i hope so
21:26:40 <dolio> It's like piping things on the console.
21:26:51 <narain> except in reverse
21:26:58 <dolio> cat foo | bar | sed 'baz' | quux > file
21:27:02 <dolio> Right.
21:27:31 <dolio> At least there's =<<
21:27:45 <dolio> Otherwise you'd have to switch the drection you're reading in the middle of the line. :)
21:27:58 <narain> :)
21:27:59 <Cale> I hate these stupid blog comment systems which destroy whitespace.
21:28:51 * Gwern looms over narain. Be a good little coder, and I will never need to debug your code. Ooooo!
21:29:20 * narain runs and cowers under blanket
21:30:09 * sorear does something completely different - find Daan Leijen's code hard to optimize!
21:30:44 <sorear> @where x11-extras
21:30:44 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/X11-extras
21:30:47 <oren> dons: thanks
21:34:16 * sorear runs xmonad
21:35:17 <dmwit> o neat
21:35:19 <Gwern> sorear: what's your opinion of it?
21:36:23 <sorear> Not ion.
21:36:38 <sorear> So far I'm still trying to figure out how to use it ;)
21:37:20 <Gwern> sorear: documentation is minimal, true
21:37:31 <Gwern> but xmonad is not for the weak! :)
21:38:13 <dmwit> sorear: The most useful keys are mod+j, mod+k, and mod is alt by default.
21:38:19 <sjanssen> sorear: when shall I expect patches? :)
21:38:36 <sjanssen> xmonad is currently under a feature freeze, by the way
21:38:43 <dmwit> mod+space is pretty key, too, if you haven't changed it to be Tile by default... ;-)
21:39:13 <sorear> I figured that much out already...
21:39:24 <sjanssen> hmm, I'm almost happy with this layout code
21:39:51 <dons> is it pure ? :-)
21:40:00 <sorear> So xmonad has three modes per workspace: * Fullscreen TOS  * Everything, vertically  *Everything, horizontally  ?
21:40:07 <dons> yeah.
21:40:16 <dons> fullscreen, tile h, tile v.
21:40:30 <Gwern> what more could you want, really?
21:40:44 <sorear> A modeline!
21:40:54 <Gwern> sorear: actually, that's not a bad idea
21:41:03 * sorear is a spoiled emacser
21:41:08 <jcreigh> hmm? what would that mean?
21:41:09 <stepcut> cool 3D effects!
21:41:13 <Gwern> I found stumpwm's modeline to be surprisingly nice, and we all know and like screen's modeline
21:41:15 <sjanssen> @slap stepcut
21:41:16 * lambdabot slaps stepcut
21:41:33 * Gwern wonders what 3d effects there *could* be in xmonad
21:42:00 <araujo> modline ... sounds nice
21:42:05 <dons> you could switch tiling modes by spinning windows into their new locations
21:42:12 <araujo> modeline ....
21:42:21 <dons> sort of like superman 1, where the bad guys were trapped in glass and sent to earth
21:42:26 <stepcut> heh
21:42:29 <sjanssen> lol
21:42:41 <sjanssen> dons: Superman II
21:42:45 <dmwit> I guess the modeline would be external, huh?
21:42:47 <sorear> A console port!
21:42:47 <sorear> Ooh, dmenu is cool...
21:42:52 <dons> maybe have some glass breaking sound effect as your break out the windows into new locations
21:42:55 <dons> sjanssen: ah yes.
21:42:59 <jcreigh> yes, dmenu is fun.
21:43:24 <jcreigh> Gwern: xmonad has awesome 3d effects. Those monitors look so real! :)
21:43:37 <Gwern> jcreigh: -_-
21:43:47 <Gwern> but if the modeline is an external program, wouldn
21:43:52 <Gwern> t it be limited?
21:44:12 <sjanssen> what exactly would a modeline do?
21:44:13 <dmwit> Not if xmonad prints enough state information.
21:44:15 <Gwern> like, how could it know the names of various X clients, or virtual desktop names?
21:44:29 <dons> query the X server, given the xid of the client
21:44:30 <jcreigh> dmwit: oh, hey, I have some patches to dmenu and xmonad to make it play nice with xinerama. (starts only on the current screen.)
21:44:33 <sjanssen> Gwern: you can query the X server to get names
21:44:36 <Gwern> dmwit: I suppose so, but you'd have to know ahead of time what state information is wanted
21:44:39 <araujo> sjanssen, to evaluate haskell expressions :-)
21:44:51 <sjanssen> araujo: not gonna happen
21:44:56 <dmwit> jcreigh: Those would be nice.
21:44:58 <Gwern> sjanssen: and would that give you positions and that sort of thing?
21:45:07 <araujo> sjanssen, haha
21:45:16 <dmwit> sjanssen: I guess the modeline would be much like dwm's top bar.
21:45:29 <araujo> sjanssen, i think sorear meant a line to run xmonad options actually
21:45:29 * Shimei would like a date/time in the modeline, presumably like dwm and wmii
21:45:30 <jcreigh> dmwit: since there's a feature freeze in effect, I'll use side-channel distribution:
21:45:39 <araujo> a la emacs
21:45:54 <sorear> araujo: no, that's called a minibuffer
21:46:04 <sorear> araujo: which would be nice in xmonad too
21:46:04 <dmwit> jcreigh: Oh, I see it in the darcs pull.
21:46:07 <sjanssen> we will have a statusbar at some point (probably an external program)
21:46:12 <araujo> sorear, oh, ok , it's true
21:46:15 <jcreigh> dmwit: oh, really?
21:46:19 <Shimei> sorear: alt-p serves as that, more or less.
21:46:22 <narain> ?docs Graphics.Rendering.OpenGL.GL
21:46:23 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL-GL.html
21:46:32 <sorear> Shimei: dmenu doesn't tell time :)
21:46:39 <dmwit> Yeah, it says to grab the patch for dmenu from jcreigh.com.
21:46:44 <dons> jcreigh: you could probably do it. fork dmenu to read a string from stdin and statically display it
21:46:57 <dons> then our statusbar program is just dstatus taking text from the xmonad state file
21:47:04 <jcreigh> dmwit: oh, okay, cool, I hadn't realized that one make it into the repo.
21:47:24 <jcreigh> dmwit: so after you patch dmenu, just change you mod-p binding to use "dmenu"
21:47:42 <Shimei> sorear: Yeah. Was referring to the minibuffer, though I suppose it doesn't change xmonad options.
21:47:58 <dmwit> jcreigh: Errr... doesn't it already?
21:47:58 <Gwern> sorear: time?  echo `date` to it?
21:48:00 <sorear> But already after like 3-minutes of use I find xmonad's workspaces MUCH easier to use than ion's taks.
21:48:07 * araujo should give it a try to xmonad
21:48:08 <sorear> *tags
21:48:15 <sorear> I love it!
21:48:23 <araujo> does it work with latest X?
21:48:38 <sorear> araujo: I'm running X.org from debian sid
21:48:40 <Gwern> araujo: seems fine here
21:49:02 <jcreigh> dmwit: no, I mean, right now it'll say spawn "dmenu ... blah blah blah". Change it to use the new "dmenu" action from Operations.hs:
21:49:03 <sorear> Eek, there's a bunch of stuff that looks like it came from deriving(Show) on tty6
21:49:05 <jcreigh> , ((modMask,               xK_p     ), dmenu)
21:49:07 <sorear> :)
21:49:09 <sjanssen> I've had success reports with both new and very old Xlibs
21:49:38 <sjanssen> sorear: yeah, that's the skeleton of our statusbar
21:49:50 <jcreigh> (I guess I could have named that action better...)
21:50:03 <sjanssen> could probably be disabled until somebody actually writes it :)
21:50:11 <sorear> but anyway - xmonad is much better than ion3 in every way.
21:50:21 <dolio> > foldr1 ((++) . (++ " - ")) . map show $ [1..10]
21:50:22 <lambdabot>  "1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10"
21:50:23 <dmwit> jcreigh: Ah, okay, got it.
21:50:32 <sorear> And I've been using ion3, oh, a couple thousand times longer.
21:50:38 <dolio> > intercalate " - " . map show $ [1..10]
21:50:39 <lambdabot>   Not in scope: `intercalate'
21:50:41 <araujo> Good.
21:50:55 <sorear> dons++ sjanssen++ jcreigh++
21:53:12 <jcreigh> ISTR ion3 having workspaces.
21:53:35 <sorear> Doesn't matter since I never found them :)
21:53:51 <sorear> Config.hs is much more readable than ion3(1)
21:54:09 <jcreigh> ah.
21:54:24 <jcreigh> yes, that's what I didn't like about ion3: So bloody hard to configure. (WMPlex? WMFrame? JUST BIND THE FRIKKIN KEY, OKAY?)
21:56:31 <sorear> OK, this is odd
21:56:39 <sorear> I have three windows open on ws#1
21:56:45 <sorear> M-2 M-1
21:56:52 <sorear> the top window has changed!
21:57:17 <sorear> xmonad is sooo easy to configure
21:57:25 <sorear> I've already added a binding
21:57:28 <sjanssen> sorear: in fullscreen mode?
21:57:33 <sorear> sjanssen: yes
21:57:41 <sorear> Mod-t : change to tty1
21:58:03 <sorear> since for some stoopid reason the vt hotkeys don't work on debian x.org
21:58:08 <Gwern> sorear: are you mad? xmonad is difficult to configure
21:58:12 <sorear> ISTR xkb not loadingat all
21:58:19 <sorear> Gwern: it is?
21:58:29 <sorear> Gwern: I just added a tuple and recompiled...
21:58:41 <sorear> Gwern: then I M-C-S-q
21:58:56 <dibblego> ?where thunk
21:58:56 <Gwern> sorear: compared to something like ratpoison or fluxbox which don't involve knowing an entire language or recompiling or having a development environment at all?
21:58:56 <lambdabot> thunk is now known as xmonad
21:59:09 <dibblego> ?foldoc thunk
21:59:10 <lambdabot> *** "thunk" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
21:59:11 <lambdabot> thunk
21:59:11 <lambdabot>  
21:59:11 <lambdabot>         <programming> /thuhnk/ 1. "A piece of coding which provides an
21:59:11 <lambdabot>         address", according to P. Z. Ingerman, who invented thunks in
21:59:12 <lambdabot> [39 @more lines]
21:59:48 <sorear> Gwern: every configuration file is written in an entire language
22:00:03 <jcreigh> (or else it's not, and you wish it was.)
22:00:13 <sorear> Gwern: it's just that xmonad's configuration language was designed
22:00:41 <sorear> Gwern: it's also turing strong, which is a Big Plus
22:00:52 <Gwern> sorear: yeah, but crippled DSLs are often more straightforward
22:00:57 <jcreigh> "turing strong". that's good, I hadn't heard that one.
22:01:11 <Gwern> which is easier to learn and write, "((modMask,               xK_p     ), dmenu)
22:01:18 <Gwern> or "bind p dmenu"?
22:01:53 <sorear> the first
22:02:08 <dons> Gwern: feel free to use bind :: Char -> IO () -> (...) ; bind c a = ((modMask , key c, a)
22:02:08 <sorear> since it is a syntax I knew
22:02:29 <dons> to write the bind syntax directly in  your config file. DSLs are one of haskell's strengths, after all
22:02:43 <Gwern> dons: sure, but the point is it isn't already there
22:02:44 <sorear> also, xmonad uses the dons school of configuration
22:03:03 <dons> shrug. its unreleased software. if you don't like something, fix it :-)
22:03:28 * Gwern wasn't saying that xmonad's system of writing systems for configuration was bad - but that its system for configuration was bad
22:03:32 <dibblego> 1 is to first as infinity is to?
22:03:33 <sorear> Oh, don't get me wrong - I think remain is pretty brilliant
22:03:37 <sjanssen> but if it counts as a feature, don't fix it this week! ;)
22:04:11 <dons> Gwern: its really a matter of opinion whether haskell is a good or bad configuration language. at least you get your config files type checked
22:04:17 <sorear> remain, as in re-main from the hs-plugins paper
22:06:09 <Gwern> dons: some helper functions could be added, I guess
22:06:27 <Gwern> but if you're just passing strings to the shell, how much is the typechecking really helping?
22:06:37 <QtPlatypus> dibblego: Not a number
22:06:40 <dons> what kind of configuration are you doing?
22:06:59 <dons> well, the shell is untyped, so that part isn't checked. we're not embedding a type system for the shell.
22:08:25 <Gwern> dons: weere you asking me what kind of configuration?
22:08:32 <jcreigh> Haskell is certainly better as being a configuration language than C. (see dwm's config if you don't believe me)
22:09:19 <Gwern> jcreigh: well, c'mon, that's hardly a fair comparison now :)
22:09:21 <dons> Gwern: yeah. what are you doing such that the existing config.hs is problematic?
22:09:29 <QtPlatypus> dibblego: Or to be more accurate, while 1 can be placed into a one to one corraspondence with the first member of an ordered list, no member of an ordered list can be placed in one to one corrasponce with infinity.
22:09:37 <jcreigh> Gwern: what? why not? :)
22:10:04 <Gwern> dons: I'm repeating the same "exe=`echo PROMPT | dmenu` && PROGRAM $exe" thing again and again
22:10:33 <dons> you mean, to bind to other shell programs?
22:10:48 <dons> then i suggest utilising your configuration language, and writing a where clause :-)
22:11:04 <Gwern> dons: meh, I guess
22:11:06 <sorear> dibblego: wikipedia Ordinal_Number
22:11:15 <dons> you've got all of haskell at your disposal. don't repeat code, refactor
22:11:27 <dibblego> I just thought there might be a word like infinitieth or something
22:11:44 <Gwern> dons: I'm not fond of making extensive local changes, so I was kind of hoping sjanssen would add some helper functions
22:12:08 <sjanssen> can an xmonad user test this for me: exists empty workspaces n and m, create a few xterms on n, switch to m, switch back to n.  Is the display blank?
22:13:27 * ddarius randomly decides to start learning Icon now.
22:13:43 <dons> sjanssen: yes.
22:13:49 <sorear> Wow, Phillip Wadler uses 'creat' as a word :)
22:13:55 <dons> that's the one i was reporting yesterday, and rashkil confirmed it.
22:14:03 <sorear> QC! ;)
22:14:04 <sjanssen> dons: good, at least I didn't break it just now
22:14:06 <Gwern> sjanssen: if it helps, I get that using aterms
22:14:13 <dons> yeah, it was present before rashkil's patches too
22:15:40 <sjanssen> Gwern: in your email, you just suggested one helper function, right?
22:15:48 <sjanssen> something about abstracting piping to dmenu?
22:16:06 <dons> we could provide a dmenu wrapper function, yeah.
22:16:15 <dons> or a bind combinator in general that constructors 3-tuples
22:16:19 <sorear> Remember, factoring out a function consumes 1 LoC.
22:16:31 * dons slaps sorear 
22:16:43 * sorear plugs CoC
22:17:04 <sjanssen> Gwern: your config file might use this several times, but the default one doesn't.  Therefore, I don't think it really makes sense at this time
22:17:16 <ddarius> Wow.  The Foreword of the Icon book takes a -very- narrow view of programmers.
22:18:01 <ddarius> sorear: Simply tack it on to the end of another function definition.
22:18:18 <Gwern> sjanssen: perhaps as time goes on more people will do that sort of thing or the default will add some
22:18:49 <ddarius> It's your Config.hs; do with it as you will.
22:19:00 <Gwern> sjanssen: btw, I get that blank display thing with the last patch you added as well as the one before that
22:19:54 <QtPlatypus> ddarius: How so?
22:19:56 <dons> Gwern: here's a helper for your config.hs
22:19:57 <dons> bind :: KeySym -> Maybe KeyMask -> X () -> ((KeyMask,KeySym), X())
22:19:57 <dons> bind Nothing  c a = ((modMask, c,        a)
22:19:57 <dons> bind (Just m) c a = ((modMask .|. m, c), a)
22:20:20 <dons> Gwern: so you can write:
22:20:23 <dons> keys = M.fromList $
22:20:23 <dons>     [ bind xK_Return (Just shiftMask) (spawn "xterm")
22:20:23 <dons>     , bind xK_space  Nothing          switchLayout
22:20:24 <dons>     ]
22:20:27 <ddarius> QtPlatypus: A semicolon.
22:20:34 <dons> then writer a helper for wrapping dmenu, and off you go
22:20:40 <ddarius> Or are you referring to the Icon book?
22:21:10 <Gwern> oy, thanks
22:22:07 <QtPlatypus> The Icon book.
22:22:24 <Gwern> I guess my dmenu wrapper would look like this: prompt app = spawn "exe=`echo " ++ app ++ " | dmenu` && exec " ++ app ++ " $exe"
22:22:32 <dons> yeah.
22:22:40 <brad_> hi
22:22:42 <brad_> again
22:22:48 <dons> see how cool it is having a full language for your configuration, Gwern :-)
22:22:55 <dons> you can write local functions to abstract out patterns.
22:23:02 <dons> can't do that in a crippled DSL.
22:23:14 <Gwern> dons: I already knew that from stumpwm...
22:23:28 <brad_> back to the problem i had earlier regarding a global counter:
22:23:54 <ddarius> Apparently, if you don't program in Icon you are programming in C or C++.  There are only comparisons against them in the Foreword.
22:24:12 <Gwern> ddarius: what's interesting about Icon?
22:24:23 <brad_> if i have tick = do n <- get; modify (+1);  m <- get; return m;
22:24:46 <brad_> that doesn't really seem to update the global value i pass in as a parameter
22:25:25 <brad_> if i say i <- evalState tick i
22:25:32 <brad_> then i am incrementing i
22:25:44 <dons> well, you throw away the 'n' - why?
22:25:45 <ddarius> Gwern: Not too much feature-wise, it's more the style of programming it encourages that I don't have that much experience in (not to that extent).
22:25:57 <brad_> i have no idea, i copied the code from the web
22:26:00 <Gwern> ddarius: some sort of OO style?
22:26:03 <glguy> brad_: m <- get; return m;   -- is -- get
22:26:05 <dons> you then incremener the global state, then return that incremented value
22:26:14 <glguy> brad_: evalState discards the state values
22:26:30 <dons> so you want to do what, return the current value, then increment it for next time?
22:26:34 <glguy> (which isn't hte problem here, nvm)
22:26:40 <ddarius> I've been wanting to learn a language in the Icon family for several years now.  But I don't expect any significant catharsis
22:26:41 <brad_> yes, as glguy said, evalstate discards the stae, what should i use?
22:27:11 <ddarius> Gwern: generators, "pattern matching", implicit backtracking of some sort
22:27:11 <glguy> brad_: if you want to tick many times:
22:27:15 <glguy> i <- tick
22:27:32 <glguy> and do one evalState around everything
22:27:37 <ddarius> Kind of like a weak version of a logic language, but not.
22:28:11 <brad_> hmmm, interesting glguy, but there must be an easier way to maintain a global incrementer?
22:28:19 <ddarius> glguy: ANd how do we know that (re get), the monad laws.
22:29:24 <brad_> dons, you mentioned a problem with me throwing away the n, but by using modify, am i not incrementing my global counter?
22:29:28 <dons> brad, don't you just want:
22:29:29 <dons> next = do
22:29:29 <dons>     n <- get
22:29:29 <dons>     modify (+1)
22:29:29 <dons>     return n
22:29:45 <brad_> dons - yes this is likely what i want
22:29:47 <dons> i.e. return current value, increment counter for next time?
22:30:06 <glguy> brad_: can you paste your code to hpaste.org?
22:30:18 <glguy> brad_: my impression is that you are misusing State
22:30:24 <brad_> can i call that the same way : evalState next i, where i is my global counter?
22:30:41 <glguy> brad_: you should only use evalState once
22:30:59 <glguy> for each lifetime of the global counter
22:31:03 <glguy> in your program
22:31:07 <dons> brad_: yeah, evalState/runState/execState are the ways to "launch" a stateful computation
22:31:23 <dons> the first argument is the entry point to any code that needs to run with a given state
22:31:27 <dons> the second arg is the initial state, of course
22:32:06 <brad_> well thanks, i will try it out now and see if it works for me!
22:33:24 <foxy-om> how much is a 16-way opteron system?
22:33:40 <Gwern> if you have to ask...
22:33:59 <sjanssen> I bet dons knows :)
22:34:09 <Gwern> well, dons knows everything
22:34:17 <Gwern> dons even knows the last digit of Omega
22:34:18 <jemfinch> I'm curious, does anyone know of any articles about code parameterized by a monad?
22:35:03 <dons> foxy-om: bout 20k .au pesos
22:35:16 <jemfinch> I'd like to read about what sorts of things monad parameters are used for, what sorts of problems they solve, etc.
22:35:20 <foxy-om> damn, what can I get for about 8k.nz
22:35:24 <glguy> ?google 20000 australian pesos to us dollars
22:35:28 <siti> is there a way to make ghc build in parallel ?
22:35:28 <dons> 4 way maybe ?
22:35:28 <lambdabot> http://english.people.com.cn/english/200105/28/eng20010528_71230.html
22:35:29 <lambdabot> Title: Philippine Government Offers 20,000 Dlrs for Clue of Kidnappers
22:35:32 <glguy> :(
22:36:07 <foxy-om> > (20000.0/0.87)*0.6
22:36:08 <lambdabot>  13793.103448275862
22:36:09 <jcreigh> @go 20000 AUD in USD
22:36:10 <lambdabot> 20,000 Australian dollars = 16,154 U.S. dollars
22:36:15 <siti> foxy-om: what part of nz?
22:36:23 <foxy-om> dorkland
22:36:27 <siti> hah
22:36:30 <dons> haha
22:36:31 <Gwern> ghc build in parallel? offhand, ghc goes through gcc doesn't it, so wouldn't distcc work?
22:36:41 * foxy-om from windy city
22:37:04 <foxy-om> what's the ghc list email?
22:37:05 <dons> foxy-om: let me find you the guys we bought ours from.
22:37:35 <siti> Gwern: I am using -fasm, I want it to build the seperate source files in parallel, I am using cabal with about 5 targets as well...
22:37:58 <Gwern> siti: heck, I'm just throwing out suggestions, don't look at me as an expert!
22:38:08 * Gwern points in the direction of dons and company
22:38:11 <siti> hehe
22:38:42 <siti> foxy-om: why do you need such a monster machine?
22:38:53 <ski> (ddarius : "Icon book" ?)
22:39:10 <sjanssen> siti: you can use ghc -M to generate a Makefile to use -j with
22:39:10 <ddarius> @google "Icon Programming Language"
22:39:12 <lambdabot> http://www.cs.arizona.edu/icon/
22:39:12 <lambdabot> Title: The Icon Programming Language
22:39:12 <foxy-om> siti: density functional theory
22:39:19 <sjanssen> s/-j/make -j/
22:39:27 <siti> sjanssen: ok
22:39:30 <dons> ?google 8000 new zealand dollars in australian dollars
22:39:31 <lambdabot> 8,000 New Zealand dollars = 7,067.97078 Australian dollars
22:39:53 <siti> foxy-om: what about a sun machine? they might have an 8 way opteron for that?
22:40:04 <Gwern> "The GHC build system works with make's -j flag, which spawns multiple compile processes in parallel. Even on a single processor machine it's usually worthwhile using at least make -j2, because the I/O will be overlapped with compute-intensive compilation. On a multicore machine, higher -j values will speed up the build even more."
22:40:11 <dons> you can get a 4 way for 10k, http://www.ipspty.com.au/index.php?comp=op8
22:40:11 <Gwern> (http://hackage.haskell.org/trac/ghc/wiki/Building/Hacking)
22:40:11 <lambdabot> Title: PC Builder & Configuration - IPS Intelligent Systems Pty Ltd
22:40:13 <lambdabot> Title: Building/Hacking - GHC - Trac
22:40:18 <siti> Gwern: cheers!
22:40:29 <dons> yeah, i typically build with -j10 or so
22:40:31 <siti> now to make cabal work with it
22:40:32 <Gwern> siti: well, I was sort of right
22:40:36 <siti> :D
22:40:42 <Gwern> dons: good grief what sort of machine are you using?
22:40:45 <dons> you average about 6 jobs in parallel currently in the build system.
22:40:55 <dons> see above wrt. 16 way amd64 machines.
22:41:05 <siti>  ./Setup.lhs build -j4
22:41:05 <siti> Setup.lhs: Unrecognised flags: -j,-4 :(
22:41:17 <sjanssen> siti: cabal doesn't do parallel builds yet
22:41:25 <siti> yes, fustrating :(
22:41:43 <sorear> ghc doesn't do parallel builds yet
22:42:21 <sorear> ghc can itself be built parallel because it is built not by the GHC compilation manager, but by the decaying corpse of fptools
22:42:25 <sjanssen> it did at one point (according to a paper on smp ghc)
22:42:29 <siti> I see
22:43:23 <sorear> don't mess with fptools.  it is ancient and fickle.  *quotes lovecraft*
22:48:57 <sorear> hello twanvl
22:49:24 <sorear> I broke deriving Functor and can't figure out how to fix it :(
22:49:25 <twanvl> good morning
22:50:42 <twanvl> what did you (intend to) change?
22:50:52 <sorear> No more strings!
22:50:58 <sorear> we use ASTs now
22:51:13 <sorear> which means we can efficiently support multiple backends
22:51:20 <sorear> TH, SYB, and preprocessor
22:51:41 <sorear> the corner cases (zenary constrs, etc) are no longer handled by derivers
22:51:42 <twanvl> nice
22:51:51 <sorear> we have a generic Peephole module now
22:53:16 <twanvl> You could probably also remove the generation of the required classes (the context) from the Functor code, because other classes don't use it either.
22:53:23 <twanvl> What i mean is:
22:53:40 <twanvl> Say you have data X a = X (Blob a)
22:54:06 <twanvl> then you derive "instance Eq X", etc.
22:54:27 <twanvl> but for Functor you derive "instance (Functor Blob) => Functor X"
22:54:44 <sorear> twanvl: Well, it doesn't work anyway
22:54:58 <sorear> twanvl: since we don't know the instances of Blob
22:55:07 <sorear> twanvl: and more importantly, their contexts
22:55:10 <twanvl> you could just assume there is one
22:55:25 <sorear> ideally, we'd have inference for instance contexts
22:55:40 <sorear> but that smells strongly of "undecidable"
22:55:49 <brad_> back again just to say thanks for all the help!
22:55:54 <twanvl> I got to go now
22:56:04 <sorear> bye.
22:56:10 <twanvl> bye
23:03:30 <Cheery> hmm, interesting
23:04:39 <Cheery> first time when I have use from map I guess
23:07:28 <Cheery> or wait, this can be hard
23:07:46 <Cheery> thing is I've a set of selectors, and a set of declarations
23:08:02 <Cheery> there's links between different selectors and declarations
23:11:24 <Cheery> now, one should first group selectors, which happen to share same declaration
23:11:48 <Cheery> then one should group declarations which happen to share same group of selectors
23:17:56 <sorear> .
23:17:59 <ivanm> @hoogle factor
23:18:00 <lambdabot> No matches found
23:18:15 <ivanm> Pseudonym: you there?
23:21:04 <Cheery> @hoogle Map k a -> Map a k
23:21:05 <lambdabot> No matches, try a more general search
23:21:29 <ivanm> how would you implement a function to find the factors of a number?
23:21:37 <sorear> Cheery: fromList . map (uncurry (flip (,))) . toList
23:21:55 <ivanm> e.g. factors 12 would return [1,2,3,4,6,10]
23:22:08 <sorear> > (\ n -> filter (\x -> n `mod` x == 0) [1..n]) 12
23:22:10 <lambdabot>  [1,2,3,4,6,12]
23:22:26 <ivanm> thanks sorear!
23:22:38 <ivanm> @pl \ n -> filter (\x -> n `mod` x == 0) [1..n]
23:22:38 <lambdabot> ap (filter . flip flip 0 . ((==) .) . mod) (enumFromTo 1)
23:22:48 <ivanm> I think the lambda version is nicer...
23:22:48 <sorear> > (\ n -> [ x | x <- [1..n] , n `mod` x == 0]) 12
23:22:50 <lambdabot>  [1,2,3,4,6,12]
23:23:26 <sorear> > (\ n -> [ x | x <- [1..n] , gcd n x /= 1]) 12
23:23:27 <lambdabot>  [2,3,4,6,8,9,10,12]
23:23:41 * ivanm didn't think about the obvious "filter through to find the ones that work" approach :s
23:24:07 <ivanm> sorear: don't think that's it... just finds those with a gcd > 1
23:24:31 <ivanm> but your first two are identical except for synctatic sugar, aren't they?
23:24:49 <sorear> right.
23:25:24 <sorear> wrt the gcd one, I was thinking of a different favorite one-liner of mine, where it doesn't matter
23:25:43 <ivanm> ahhh, k
23:25:48 <sorear> > nubBy(((>1).).gcd)[2..]  -- this one - only uses gcd at nrs >2
23:25:50 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
23:27:00 <ivanm> so what is it meant to return? 2:odds?
23:27:11 <ivanm> no, primes?
23:29:37 <Cheery> hmm, I think I just group declarations with selectors first
23:30:03 <sorear> primes, yeah
23:30:27 <ivanm> @seen Pseudonym
23:30:28 <lambdabot> Pseudonym is in #haskell-blah and #haskell. I last heard Pseudonym speak 2h 58m ago.
23:31:13 <kc5tja> xmonad's "alt+tab" doesn't work with numlock turned on.  Oops.  :)
23:31:24 <ivanm> @tell Pseudonym I managed to get the Trie working, but didn't use it... worked out that my other way of doing it was inefficient because I had someone written a function as "foo = foo pred", instead of "foo = bar pred" :s
23:31:24 <lambdabot> Consider it noted.
23:31:44 <dons> kc5tja: yeah, i'd not be surprised if there were some other numlock/scrLk etc issues
23:31:52 <dons> who knows what happens if you hold down SysRq at the same time
23:31:59 <kc5tja> It prints a reverse-video mu on the screen when I hit it in IRC.  :D
23:32:03 <kc5tja> Hah
23:32:03 <kc5tja> :)
23:32:42 * kc5tja goes to finish laundry, and then head to bed.
23:34:39 <sorear> Aiieee....  Now reading Yet Another Pretty Printing paper.   the way Olaf wields laziness just makes my head spin :)
23:35:12 <dons> sjanssen: much nicer looking 'refresh' code. cheers.
23:35:27 <glguy_> How does one use modern versions of packages with Ubuntu? I just installed it on a secondary machine and would like to install things like ghc 6.6
23:35:54 <glguy_> from source?
23:36:42 <ivanm> @src (=<<)
23:36:42 <lambdabot> f =<< x = x >>= f
23:36:49 <dons> sjanssen: i'd like to generalise 'promote' before the release
23:36:49 <ivanm> thought so...
23:37:03 <dons> sjanssen: since it acts like a cycle on the window stack, depending on where the current focus is.
23:37:18 <dons> so my plan is to just make it a cycle clockwise of the stack
23:37:27 <dolio> glguy_: Wait until the next release? :)
23:37:28 <sjanssen> dons: how did the old vertical tiling mode work?  just like horizontal rotated 90 degrees clockwise?
23:37:33 <dons> yep
23:38:06 <ivanm> for lists, >>= is the same as concat . map, isn't it?
23:38:12 <glguy_> dolio, so are you saying that Ubuntu isn't suitable for me if I want to run newer versions of packages?
23:38:15 <dons> @src [] (>>=)
23:38:15 <lambdabot> m >>= k     = foldr ((++) . k) [] m
23:38:20 <dons> @src concatMap
23:38:20 <lambdabot> concatMap f = foldr ((++) . f) []
23:38:24 <dons> :-)
23:38:40 <ivanm> @src concat
23:38:40 <lambdabot> concat = foldr (++) []
23:38:43 * glguy_ thinks that that should be on the front page of the main website so that people like me don't waste their time downloading the CD and performing the install
23:39:00 <dolio> glguy_: They tend to freeze package versions between releases. And something as esoteric as GHC doesn't get interim update repositories.
23:39:06 <ivanm> so, what would be the relative efficiency of >>= vs concat . map vs concatMap? anything?
23:39:19 <sjanssen> ivanm: they should all be the same
23:39:28 <dolio> glguy_: But feisty (which I have installed at the moment) has 6.6, and it's due later this month.
23:39:47 <ivanm> sjanssen: thought so, just checking
23:39:51 <glguy_> dolio, is it easy to update to feisty?
23:40:04 <ivanm> but (>>=) is more efficient to type ;)
23:40:23 <dolio> glguy_: You mean right now?
23:40:33 <glguy_> dolio, Yeah
23:40:51 <glguy_> I don't want to have to switch to Gentoo, for example, just for it to be easy to run newer software
23:41:28 <dolio> glguy_: It's not too hard. You'd change all the 'edgy' in /etc/apt/sources.list to 'feisty', and then do 'apt-get dist-upgrade'
23:41:36 <dolio> glguy_: And then download packages for an hour.
23:41:59 <sjanssen> glguy_: oh, why not?
23:42:05 * sjanssen never misses a minor version of awk
23:42:29 <dolio> Debian unstable might be a better fit, though.
23:42:40 <dolio> They had ghc 6.6 pretty quick.
23:42:43 * sorear uses that.
23:43:12 <sorear> Actually, if you can get any GHC, installing HEAD from source is quite painless.
23:43:32 <sorear> Head takes a third the time to build as 6.6
23:43:48 <glguy_> Why is that?
23:44:02 <sorear> they switched the compiler from -fvia-C default to -fasm default (with -O)
23:44:11 <sorear> so everything builds three times faster
23:44:21 <sorear> and that includes the stage2 compiler + libs
23:44:30 <glguy_> could 6.6 be built like that?
23:44:45 <glguy_> if you changed the makefile
23:44:54 <sjanssen> yeah
23:44:56 <sorear> probably.  but it might be hard to find docs...
23:45:02 <pejo> Rebuilding the GHC packages from debian for ubuntu shouldn't be that much work.
23:45:30 <glguy_> I'm not interested in porting them by hand for any software I want to run a modern version of
23:45:42 <glguy_> but I guess its good to know that you can
23:47:55 <sorear> HEAD is ultra painless.  autoreconf && ./configure && make && make install.  Wait 83 minutes.
23:48:27 <glguy_> are there any other distros I should consider if I'm going to use this box to play with Linux and come out of my BSD shell :)
23:48:32 <sorear> Marvel in the ability of the Glorious Linux Scheduler to prevent you from noticing that your CPU is busy.
23:48:46 <glguy_> besides Gentoo and Debian?
23:49:03 <ski> sorear : where's that paper ?
23:49:05 <foof> what's wrong with BSD?
23:49:06 <liyang> Ubuntu, I choose you!
23:49:07 <ivanm> @pl \ xs -> concat . map (second factors) $ xs
23:49:07 <lambdabot> (second factors =<<)
23:49:09 <dufflebunk> glguy_: try #sourcemage
23:49:18 <sorear> ski: which?
23:49:26 * dufflebunk has no other comment on the matter of linux distro
23:49:29 <glguy_> foof: nothing, I'm just experimenting with this extra computer I reclaimed from my little brother
23:49:31 <ski> sorear : Yet Another Pretty Printing paper
23:49:38 <sorear> ski: I'm reading a whole bunch
23:49:59 <ivanm> @pl \ xs -> concat . map (concat . map (second factors)) $ xs
23:50:00 <lambdabot> ((second factors =<<) =<<)
23:50:08 <sorear> ski: that one was "pretty printing with lazy dequeues"
23:50:15 * foof only uses Debian and Gentoo, but has heard good things about Ubuntu
23:51:03 <sorear> ski: I'm also looking at on of Doitse Swierstra's papers, Wadler's "A prettier printer", and (if I can find it!) Derek Oppen's pretty printer.
23:51:04 <ivanm> @pl \ (x,ys) = (x, concat (map factors ys))
23:51:05 <lambdabot> (line 1, column 10):
23:51:05 <lambdabot> unexpected "="
23:51:05 <lambdabot> expecting operator, pattern or "->"
23:51:15 <sorear> The last might be hard, given a 1980 data
23:51:21 <ski> sorear : ty (http://citeseer.ist.psu.edu/491952.html)
23:51:22 <lambdabot> Title: Pretty Printing with Lazy Dequeues - Chitil (ResearchIndex)
23:51:29 <ivanm> @pl \zs -> concat . map (\ (x,ys) -> (x, concat (map factors ys))) $ zs
23:51:29 <glguy_> I just remember Gentoo having a long setup time last time I played with it, even using stage3
23:51:30 <lambdabot> (second (factors =<<) =<<)
23:51:30 <sorear> also the ACM isn't exactly known for free full text
23:51:52 <sjanssen> glguy_: when was the last time you played with Gentoo?
23:51:59 <dons> olaf probably has his papers online though.
23:52:04 <glguy_> 2005 I think
23:52:14 <sorear> dons: yeah, I've already read the olaf paper
23:52:22 <glguy_> sjanssen, I mostly mean after the install is done
23:52:27 <ivanm> @type \zs -> concat . map (\ (x,ys) -> (x, concat (map factors ys))) $ zs
23:52:29 <lambdabot> Not in scope: `factors'
23:52:32 <glguy_> and I was getting all the stuff I wanted installed
23:52:34 <sorear> dons: curiously almost every link to it was broken
23:52:34 <glguy_> and configured
23:52:52 <sjanssen> glguy_: is this for a desktop or a server?
23:52:55 <glguy_> deskto
23:52:56 <sorear> dons: now I'm reading doitse's 2004 paper, the newest of the bunch
23:52:57 <glguy_> p
23:53:06 <glguy_> I use OpenBSD on my server
23:53:09 * sorear always reads the name Doitse very wrong ...
23:53:14 <glguy_> maybe it was 2004
23:53:23 <ivanm> @type \zs -> concat . map (\ (x,ys) -> (x, concat (map (\ n -> [i | i <- [1..n], n `mod ` i == 0]) ys))) $ zs
23:53:24 <glguy_> I think that the LiveCD was a 04 version
23:53:25 <lambdabot>     Couldn't match expected type `[a]'
23:53:25 <lambdabot>            against inferred type `(t, [a1])'
23:53:48 <ivanm> @type \zs -> concat . map (\ (x,ys) -> (x, concat (map (\ n -> [i | i <- [1..n], n `mod ` i == 0]) ys))) $ (zs :: [(String,[Int])]
23:53:50 <lambdabot> parse error (possibly incorrect indentation)
23:53:57 <ivanm> arrggghhhh!!!!!
23:53:57 <sjanssen> glguy_: since then Gentoo's gotten a real installer
23:54:04 <glguy_> what??
23:54:09 <glguy_> how can they still call it gentoo?
23:54:19 <sjanssen> glguy_: it's graphical and everything
23:54:30 <glguy_> I think it's april 2nd now
23:54:32 <glguy_> too late
23:54:58 <Adamant> there is an installer, it's just horribly borked.
23:55:14 <sjanssen> Adamant: yeah, sometimes
23:55:14 <ivanm> *nod*
23:55:25 <sjanssen> it worked very well the last time I used it
23:55:39 <Adamant> yeah, it's "try your luck".
23:55:46 * sorear likes his binary packages!
23:55:57 <Adamant> so use tinderbox.
23:56:05 <Adamant> it's what any sane person would do.
23:56:39 <sjanssen> glguy_: but yes, if you want to install Gentoo be ready to tweak
23:57:05 <sjanssen> especially if you have exotic-ish hardware (like new laptops)
23:57:36 <glguy_> This is not new hardware
23:57:54 <glguy_> asus p4b266 mobo p4 1.6ghz proc ati radeon 64
23:58:10 <glguy_> audigy2
23:58:15 <glguy_> and intel nic
