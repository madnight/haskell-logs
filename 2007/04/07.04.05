00:00:02 <sorear> narain: what are the types a and b?
00:00:49 <narain> a is a spatial transformation type and b is a vector type
00:01:12 <sorear> like rotate, reflect, etc?
00:01:29 <narain> class Transform t v where
00:01:33 <narain> ident :: t
00:01:39 <narain> apply :: t -> v -> v
00:01:46 <narain> compose :: t -> t -> t
00:01:51 <narain> inv :: t -> t
00:01:53 <narain> you get the idea
00:02:01 <sorear> you can think of t as being analagous to (v -> v)
00:02:02 <Cin> so, (many1 digit) collects digits into a string?
00:02:07 <narain> sorear, yes
00:02:18 <sorear> so any given monotype t only works on one kind of v
00:02:31 <sorear> just as any monotyped function only works on one type of argument
00:02:36 <narain> well i could have different implementations of vectors... no?
00:02:45 <narain> (in theory)
00:03:04 <sorear> In that case, the usual approach is to split the class.
00:03:42 <sorear> class Transform t where
00:03:42 <sorear>   ident :: t
00:03:42 <sorear>   compose :: t -> t -> t
00:03:42 <sorear>   inv :: t -> t
00:03:46 <sorear> class Transform t => Transform2 t v where
00:03:49 <sorear>   apply :: t -> v -> v
00:04:10 <sorear> but it will be harder to use that way - more ambiguity errors
00:04:24 <narain> hmm, i see, that seems to make sense
00:05:42 <narain> i probably could have avoided all this trouble by not using MPTCs in the first place, but i felt like making all my types instances of type classes :)
00:05:58 <sorear> hehe.
00:07:01 <narain> well, thanks a lot sorear, you really helped clarify all this
00:07:05 <sorear> yw
00:08:11 <narain> at this rate i'll keep playing with the type system and never get anything implemented :(
00:08:41 <narain> *at the rate i'm going
00:16:15 <Cin> parseNumber = liftM (Number . read) $ many1 digit -- so this grabs all the digits from a string to a string, then converts that string to an number, and that is then converted to a Number...?
00:16:32 <sorear> precisely.
00:17:02 <Cin> bare with me
00:17:52 <Cheery> what is the point of separated-borders?
00:17:53 <Cin> so far, that's defining operations. but we want parseNumber to return an actual Number so liftM is used? :
00:18:18 <Cheery> or wait, border-collaps
00:18:53 <sorear> yes.
00:19:06 <sjanssen> Cin: liftM "lifts" a normal function into a monadic one
00:19:10 <sjanssen> @hoogle liftM
00:19:11 <lambdabot> Monad.liftM :: Monad a => (b -> c) -> a b -> a c
00:19:11 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
00:19:11 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
00:19:32 <Cin> yes, I found that confusig
00:20:58 <sjanssen> "liftM :: Monad m => (a -> b) -> (m a -> m b)" takes a function from a's to b's, and creates a new function that takes a's wrapped in m and yields b's wrapped in m
00:22:38 <Cin> sjanssen, takes a function from a's what?
00:23:15 <sjanssen> I mean that it is a function that takes an a and yields a b
00:23:21 <sorear> ooh, nice, first reply to my perf post was direct SPJ
00:23:51 <sjanssen> I mean that it is a function that takes an 'a' and yields a 'b' (single quotes around type variables to eliminate ambiguity)
00:25:58 <sjanssen> let's look at your example.  "Number . read" has type "String -> Expr"
00:26:28 <sjanssen> and "many1 digit" has type "Parser String"
00:26:46 <Cin> okay
00:27:03 <sjanssen> so in the example code, liftM has the type "(String -> Expr) -> (Parser String -> Parser Expr)"
00:27:31 <Cin> I see
00:28:16 <sjanssen> in English, you could say: given a transformation from Strings to Exprs, we have a transformation from Parsers of Strings to Parsers of Exprs
00:28:52 <Bourbaki> does anyone know this book? "The Haskell Road to Logic, Maths and Programming" and if so is it any good?
00:30:21 <Cin> sjanssen: hm, right. I think I'll read more of A Gentle Introduction to Haskell
00:30:33 <osfameron> "Gentle"!
00:31:12 <Cin> hehe
00:31:56 <osfameron> all the online haskell tutorials terrify me.  I am just about able to read the School of Expression without turning into a gibbering Cthulhu cultist however
00:32:07 <Cin> haha
00:32:22 <sjanssen> osfameron: I've heard that YAHT isn't so bad
00:32:42 <osfameron> the writing and explanations of YAHT are poor, but the exercises are well chosen.
00:32:59 <sorear> night all.
00:33:08 <sjanssen> goodnight sorear
00:33:13 <osfameron> nighty
00:33:56 <Cin> I'm doing Write Yourself a Scheme in 4 Hours, but I find myself wondering about most of it.
00:34:25 <sjanssen> Write Yourself a Scheme isn't exactly introductory material
00:34:38 <osfameron> it seems to help if you already know both scheme and haskell
00:35:08 <Cin> oh, okay
00:35:15 <Cin> A Gentle Introduction is the way to go?
00:35:34 <sjanssen> Cin: have you done some sort of functional programming before?
00:36:03 <Cin> sjanssen, not really. I have been doing Common Lisp for a few months, but it's been mainly in an imperative style
00:36:42 <osfameron> the "Gentle" of the Gentle introduction is a little bit like the sadistic mocking "We're not going to hurt you" of Mafia hitmen
00:37:54 <Cin> it seemed quite acceptable of what I'd read of it. but I got a little bored because I wasn't taking anything in. if I sat writing up my own examples with a compiler, I think that would work quite well as a way of learning
00:38:12 <sjanssen> Cin: try the gentle intro, just remember that there are other resources that are actually gentle, if you get stuck
00:38:47 <sjanssen> YAHT and the wiki book are what most people recommend
00:39:06 <Cin> sjanssen, okay, thanks. I'll have a look at those too
00:41:15 <osfameron> actually... the gentle introduction looks less scary now after having read some other stuff - looks like a good reference
00:43:40 <Cheery> ok, now I removed the most useless css -stuff
00:43:55 <Cheery> now there's about 35 or 40
00:44:57 <_roconnor> @docs System
00:44:58 <lambdabot> System not available
00:45:03 <_roconnor> @hoogle system
00:45:04 <lambdabot> System.system :: String -> IO ExitCode
00:45:04 <lambdabot> System :: module
00:45:04 <lambdabot> System.Win32.Info.SystemColor :: type SystemColor
00:45:15 <_roconnor> @docs System.system
00:45:15 <lambdabot> System.system not available
00:51:16 <_roconnor> @type when
00:51:19 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
00:51:47 <_roconnor> @type (\x -> x >> return ())
00:51:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
00:56:26 <andersca> hello
00:56:58 <bdash> andersca: hi!
00:57:17 <andersca> bdash: hah! didn't expect to see you here! :)
01:01:49 <joelr1> good morning!
01:02:53 <dons> hey joelr1 , you might be interested in today's good news story, http://article.gmane.org/gmane.comp.lang.haskell.cafe/21159
01:02:55 <lambdabot> Title: Gmane -- Mail To News And Back Again
01:03:37 <joelr1> dons: the one you posted? i have reddit in my google reader ;)
01:03:49 <dons> hah
01:04:00 <joelr1> dons: thanks for the tip, though. it was a welcome email when i received it on haskell this morning
01:04:30 <joelr1> dons: i plan to do something similar but using happs. no particular reason apart from alex's goals towards amazon ec2 and s3
01:04:57 <joelr1> dons: plan = do it before the end of the month
01:06:23 <joelr1> dons: mine is supposed to be a money-making haskell web app of my own
01:09:09 <dons> wonderful.  i wish you success and may your lambdas always beta reduce.
01:09:34 <joelr1> dons: i'm translating from a custom trading systems programming language to c# and plan to sell translations on the web
01:10:33 <olliej> dons: my thesis is finally had its final submission (about 10 months after the original submission -- grumble)
01:10:54 <joelr1> dons: i wrote a working translator in ocaml in about a month, learning ocaml included. then had conceptual trouble deploying it on the web. i thought about ruby + ocaml, etc. then remembered the warn and fuzzy haskell feelings and started a rewrite.
01:11:32 <dons> congratulations olliej !
01:11:53 <olliej> dons: soon the pain than is my writing will be recorded forever
01:12:07 * dons disappears to finish two icfp papers in two days... WRITE WRITE WRITE!
01:12:15 <Syzygy-> Go dons, go!
01:12:29 <Syzygy-> olliej: http://www.phdcomics.com/comics/archive.php?comicid=844
01:12:30 <lambdabot> Title: Piled Higher and Deeper
01:14:38 <olliej> Syzygy-: mines's a real degree dammit -- it's only being mailed to me because i'm no longer in the country :D
01:14:49 <olliej> ... it better be a real degree anyway
01:14:52 <olliej> :D
01:14:58 <alec> :)
01:15:06 <Syzygy-> olliej: You're not familiar with phdcomics, I hear....
01:15:07 <robreim> I'm trying to build/install the network library with hugs using cabal. I did 'runhugs -98 ./Setup.hs configure', but 'runhugs -98 ./Setup.hs build' returns the error message 'ERROR "dist/build/Network/BSD.hs" - Can't find imported module "GHC.IOBase"'. I'm guessing there's some sort of hsc2hs or cpphs trick I need?
01:15:29 * Syzygy- linked it for the empty feeling of "Well, that was the thesis .. now what...", not for the mailing quip.
01:16:20 <olliej> Syzygy-: hehe
01:16:38 <olliej> Syzygy-: i slept for a whlie
01:16:43 <olliej> *while even
01:16:56 <Syzygy-> In the storyline, the guy handing in there really is a PhD at a regular university; not a customer at some scheme...
01:17:07 <Syzygy-> Go read the comic though - if you're doing academia it's well worth it.
01:17:17 <olliej> Syzygy-: i've escaped academia
01:17:23 <alec> robreim: did you get it from darcs, hackage, or somewhere else?
01:17:26 <olliej> i dno't feel like inflicting a phd upon myself
01:17:30 <Syzygy-> Ok, then for the nostalgia of it. ;)
01:17:32 <robreim> alec: darcs
01:17:34 <olliej> heh
01:17:52 <alec> robreim: sounds like either the preprocessor isn't picking up hugs or the darcs version is broken for hugs because of a ghc dependency
01:18:59 <alec> robreim: did you try passing the '--hugs' flag to the configure step?
01:19:10 <robreim> Nope, I'll try that.
01:19:52 <robreim> No difference.
01:20:44 <alec> robreim: that's the extent of my hugs experience, I won't be of much further help
01:21:12 <robreim> thanks for your help
01:23:51 <robreim> I do have cpphs-hugs and hsc2hs-hugs installed on my computer (running debian with the 'experimental' distribution of hugs) but using the --with-(cpphs|hsc2hs) flags set to those different commands doesn't seem to make any difference.
01:25:33 <sjanssen> @remember dons i wish you success and may your lambdas always beta reduce.
01:25:34 <lambdabot> Done.
02:01:02 <joelr1> sjanssen: yes, that's a very good one! :D
02:04:02 <tsp> > let swedishSwearWords = [("anteckningar","shit"),("tillbeh√∂r","penis")] in first (first swedishSwearWords))
02:04:03 <lambdabot>  Parse error
02:04:21 <tsp> damn, my new swedish swear words gave a parse error
02:04:40 <tsp> > "anteckningar tillbeh√∂r"
02:04:41 <lambdabot>  "anteckningar tillbeh\246r"
02:04:50 <opqdonut> > first (1,2)
02:04:51 <lambdabot>   add an instance declaration for (Arrow (,))
02:04:51 <lambdabot>     In the expression: first (1...
02:04:59 <opqdonut> see, firsting doesn't work for tuples
02:05:11 <opqdonut> :t first
02:05:13 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
02:05:18 <tsp> thought I was giving it a tuple?
02:05:20 <opqdonut> and besides i think that is not the first you want?
02:05:21 <joelr1> @where FilePath
02:05:22 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php#filepath
02:05:23 <lypanov> huh...
02:05:27 <lypanov> isn't it just because you did )) ?
02:05:46 <tsp> maybe it doesn't like the swedish swear words
02:05:59 <lypanov> your ()s don't match up
02:06:02 <tsp> oh
02:06:05 * lypanov is a haskell beginner so ignore him if need be
02:06:06 <Syzygy-> tsp: You call that a swearword?
02:06:12 <lypanov> where beginner == hasn't used it :P
02:06:20 <tsp> I'm assuming they're swear words
02:06:32 <opqdonut> > let swedishSwearWords = [("anteckningar","shit"),("tillbehˆr","penis")] in head $ fst swedishSwearWords
02:06:33 <lambdabot>      lexical error in string/character literal (UTF-8 decoding error)
02:06:37 <lypanov> lol
02:06:39 <tsp> anteckningar and tillbeh√∂r are strange enough
02:06:43 <opqdonut> that is probably what you meant
02:06:47 <Syzygy-> ...
02:06:55 <joelr1> is there a haskell colorizer for various languages?
02:06:59 <Syzygy-> anteckningar = notes. tillbeh√∂r = accessories.
02:07:02 <opqdonut> > let swedishSwearWords = [(1,2),(3,4)] in head $ fst swedishSwearWords
02:07:02 <tsp> ah, fst
02:07:03 <lambdabot>  Couldn't match expected type `(a, b)'
02:07:11 <tsp> Syzygy-: lol
02:07:13 <opqdonut> > let swedishSwearWords = [(1,2),(3,4)] in fst $ head swedishSwearWords
02:07:15 <lambdabot>  1
02:07:15 <opqdonut> gah i suck
02:07:24 <Syzygy-> opqdonut: You want to map somewhere....
02:07:32 <tsp> ah, head, that'll work
02:07:45 <opqdonut> Syzygy-: i was just trying to guess what tsp wanted to do
02:07:57 <Syzygy-> Oh, yeah, I kinda missed the start....
02:08:13 <opqdonut> nvm
02:08:29 <tsp> I tried to learn swedish, but gave up after hej and sverige :)
02:09:01 <lypanov> i gave up after jag
02:09:08 <tsp> lypanov: heh
02:09:09 <lypanov> "Jag ... (tried to etc)"
02:09:40 <tsp> I happen to like the verbs - similar to esperanto, jag har/du har/etc - never got to adjectives and adverbs though
02:10:06 <Syzygy-> lypanov: "Jag f√∂rs√∂kte" :)
02:10:18 <tsp> but I accidentally used the wrong windows iso on my test vm, too lazy to reinstall - so its all in swedish
02:10:27 <lypanov> Syzygy-: gave up i guess?
02:10:42 <Syzygy-> Hehe
02:11:34 <tsp> oh, that's why I couldn't telnet to the box - I kept typing administrator, it wants administrat√∂r
02:11:40 <lypanov> lol
02:11:42 <Syzygy-> Hehe
02:13:03 <tsp> weird, even among windows oses the o isn't showing up right - my screen reader says quote, when its an o when I type it in  here
02:13:18 <Syzygy-> oO
02:13:27 <Syzygy-> You use a screen reader?
02:13:44 <opqdonut> tsp: probably charset issue
02:14:01 <tsp> yup, screen reader
02:14:27 <tsp> luckally enough I have a synth that speaks swedish, even if jag tal√§r svenska inte :)
02:14:33 <Syzygy-> Hehe
02:14:44 <lypanov> inte -> ?
02:14:47 <tsp> not
02:14:50 * lypanov nods
02:14:51 <Syzygy-> You blind^Wvisually impaired^W^Wwhatever the right term should be?
02:14:55 <lypanov> wanted to confirm :)
02:14:55 <tsp> Syzygy-: yup
02:15:00 <Syzygy-> lypanov: inte == not
02:15:05 <Syzygy-> tsp: Right-o.
02:15:19 <Syzygy-> First time I encounter someone I know works that way.
02:15:28 <tsp> I have the choice of learning english, spanish, swedish, finnish, german, etc - but I finally found a synth that speaks esperanto
02:15:34 <Syzygy-> Wow!
02:15:37 <Syzygy-> Cooooooool.
02:15:45 <tsp> I even ahve one that speaks chinese, but that is weird
02:15:50 <lypanov> i suppose i really should take up esperanto again lol
02:16:02 <Syzygy-> How do the readers handle mixed languages?
02:16:03 <tsp> I need a terminal that supports utf-8 :)
02:16:17 <tsp> ah, haskell always breaks on this
02:16:18 <Syzygy-> Say, if I should start talking swedish or german in here, what'd happen at your end?
02:16:22 <Syzygy-> Hehe
02:16:33 <tsp> > '√•'
02:16:34 <lambdabot>  Improperly terminated character constant
02:16:46 <tsp> Syzygy-: it'd try to read it currently using an english synth
02:16:55 <Syzygy-> For that matter, what does haskell code sound like?
02:17:07 <tsp> why does it break? I hit the apostrophe, alt-0229, and another ' - it shows up on my end just fine
02:17:22 <lypanov> shows up here fine also
02:17:23 <tsp> code, and most everything else is just a really fast stream of words
02:17:25 <Syzygy-> tsp: So it'd be a combination of horribly mispronounced fragments and reading letters?
02:17:36 <tsp> http://silenceisdefeat.org/~tspivey/eloquence.flac
02:17:39 <tsp> Syzygy-: yup
02:17:54 <tsp> reading anteckningar in english and swedish sounds totally different
02:18:02 <Syzygy-> Oh bugger. The computer I got here doesn't do sound. :(
02:18:14 <tsp> wow
02:18:16 <tsp> a computer without sound
02:18:36 <Syzygy-> Well, it has a soudncard, but I don't seem to have access rights to it, and I don'
02:18:51 <Syzygy-> I don't want to bug the sysadmin about it, since I'm only here for two weeks.
02:18:56 <tsp> running windows? you should be able to access it - volume control :)
02:19:02 <Syzygy-> Nonono, linux
02:19:05 <tsp> ah
02:19:07 <Syzygy-> And I'm very much not root.
02:19:11 <Syzygy-> So I can't poke at it.
02:19:14 <tsp> damn
02:19:26 <Syzygy-> I'm getting through by bringing my mp3player to work :)
02:19:42 <tsp> your at work, on a linux box? neat
02:19:48 <Syzygy-> Suer
02:20:00 <Syzygy-> The only ppl here who don't use linux are the MacOS 9 diehards....
02:20:06 <tsp> ouch OS 9
02:20:13 <tsp> would that even run haskell?
02:20:20 <Syzygy-> Dunno, wouldn't bet on it.
02:20:23 <lypanov> os9?? lol
02:20:31 <Syzygy-> Though haskell isn't very much around here either.
02:20:41 <dmead> lol
02:20:46 <Syzygy-> Which is funky, since I'm at on of the departments housing Per Martin-L√∂f.
02:21:31 <tsp> lol, my screen reader said martin-loaf due to the √∂ - how do you type those anyways? I have to hit ^a^v"o
02:21:41 <Syzygy-> http://en.wikipedia.org/wiki/Per_Martin-L%C3%B6f
02:21:42 <lambdabot> Title: Per Martin-L√∂f - Wikipedia, the free encyclopedia
02:21:54 <Syzygy-> tsp: I'm in sweden, using a swedish keyboard.
02:22:01 <Syzygy-> I haev a key dedicated to each of √• √§ √∂
02:22:11 <tsp> ah
02:22:45 <tsp> I hate this windows terminal emulator - it works great for normal text, but it only supports unicode in japanese
02:23:10 <tsp> utf-8 tera term pro
02:24:02 <joelr1> folks, can you please try building the deriver library?
02:24:04 <joelr1> @where derive
02:24:05 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/derive
02:24:13 <joelr1> it doesn't build on my end with ghc 6.6
02:24:17 <joelr1> and i wonder why
02:24:24 <dmead> 6.6 isn't on portage yet
02:24:35 <Syzygy-> It's in the layover though.
02:25:57 <joelr1> ugh... portage? layover? what brand of ... ah, gentoo!
02:25:58 <eivuokko> Yo.
02:26:20 <joelr1> eivuokko: long time
02:27:01 <eivuokko> Yeah :)
02:27:23 * joelr1 high-fives eivuokko 
02:28:28 <eivuokko> Anyone got experiences if newStablePtr/freeStablePtr are expensive to call (calling atleast hundreds of times per second)  or for gc?  (with ghc rts)
02:28:31 <fuzan> is there some function for lifting multiple items? ie. i want to compare three IO Integers, a b c
02:28:39 * eivuokko returns high-five
02:28:57 <joelr1> fuzan: lifM3?
02:29:05 <Syzygy-> liftM3 you mean
02:29:08 <fuzan> :t liftM3
02:29:11 <joelr1> yes
02:29:11 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
02:29:36 <fuzan> oh snap, that'll do it. thanks :)
02:29:44 <joelr1> i used to wonder what liftMx do until i looked at the implementation
02:29:59 <Syzygy-> ?src liftM3
02:29:59 <lambdabot> liftM3 f m1 m2 m3 = do { x1 <- m1; x2 <- m2; x3 <- m3; return (f x1 x2 x3) }
02:30:04 <Syzygy-> Hehe
02:30:12 <joelr1> Syzygy-: that's neat! i didn't know you could do that
02:32:07 <dmead> >liftM2 (,) [1..5] [6..10]
02:32:07 <joelr1> @paste
02:32:08 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:32:15 <dmead> > liftM2 (,) [1..5] [6..10]
02:32:17 <lambdabot>  [(1,6),(1,7),(1,8),(1,9),(1,10),(2,6),(2,7),(2,8),(2,9),(2,10),(3,6),(3,7),(...
02:32:24 <dmead> cartesian product
02:32:55 <Syzygy-> ?t guard
02:32:56 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
02:33:00 <Syzygy-> ?type guard
02:33:03 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
02:33:09 <hpaste>  joelr1 pasted "Error compiling derive" at http://hpaste.org/1261
02:33:18 <joelr1> any suggestions on how to fix this?
02:33:43 <Syzygy-> > liftM2 (,) [1..5] [6..10] >>= guard . (\(x,y) -> x+y==10)
02:33:45 <lambdabot>  [(),(),(),()]
02:33:53 <Syzygy-> > liftM2 (,) [1..5] [6..10] >> guard . (\(x,y) -> x+y==10)
02:33:54 <lambdabot>  Couldn't match expected type `[]'
02:34:37 <Syzygy-> Hmmmm... Some way to do the do x <- a; y <- b; guard (a+b==10); return (a+b) with binds?
02:35:47 <dmead> with a comprehension i think
02:36:01 <dmead> peoples
02:36:07 <dmead> is there a constructor for upper case chars?
02:36:26 <dmead> outside of the parsec class
02:36:28 <tsp> what does this come out as? √Ñ¬à
02:36:30 <tsp> damn
02:36:37 <tsp> utf-8 doesn't work on any modern os
02:36:42 <dmead> :s
02:36:45 <tsp> at least not mine :)
02:36:53 <dmead> maybe it's just irc
02:36:56 <tsp> maybe
02:37:10 <dmead> what did you mean to type?
02:37:23 <Syzygy-> dmead: Constructor?
02:37:26 <tsp> esperanto C
02:37:30 <dmead> ah
02:37:31 <tsp> it comes up in the shell as a normal C
02:37:38 <tsp> but appears in files as an esperanto one
02:37:49 <fuzan> tsc, i saw a "? ??" :)
02:37:51 <Syzygy-> I saw √Ñ and a white blob
02:38:00 <tsp> hmm, I'll put it in a text file
02:38:00 <xpika> what does  * -> * translate to?
02:38:06 <tsp> ≈ú
02:38:14 <tsp> I heard a ?
02:38:20 <Syzygy-> xpika: It's a kind that takes another type in order to generate a basic type.
02:38:23 <xpika> as in return :: forall a (m :: * -> *). (Monad m) => a -> m a
02:38:42 <tsp> what did taht come out as for you?
02:38:53 <Syzygy-> xpika: It means that m needs to be a type of kind * -> *, i.e. something that maps types to new types.
02:39:06 <Syzygy-> tsp: ^S
02:39:11 <tsp> ah, there should be a unicode help channel around here somewhere
02:39:28 <tsp> damn, it just shows up as either (1) a normal S in the shell, or 2) a ? in irc
02:39:29 <Syzygy-> #unicode for instance
02:39:40 <Syzygy-> Topic for #unicode: UNICODE users channel
02:39:45 <Syzygy-> (and it goes on to more)
02:39:50 <tsp> hmm, good idea
02:40:26 <xpika> so M needs to be of type data Something x = ...
02:41:14 <ski> @kind Maybe
02:41:14 <Syzygy-> M needs to be something like IO, or [], or Maybe
02:41:17 <lambdabot> * -> *
02:41:19 <ski> @src Maybe
02:41:20 <lambdabot> data Maybe a = Nothing | Just a
02:41:40 <xpika> ok
02:41:41 <ski> @kind Either
02:41:44 <lambdabot> * -> * -> *
02:41:46 <ski> @kind Either String
02:41:49 <lambdabot> * -> *
02:41:56 <xpika> :)
02:42:47 <Syzygy-> :k Either undefined
02:42:50 <lambdabot> Not in scope: type variable `undefined'
02:42:52 <Syzygy-> Doh.
02:42:57 <Syzygy-> Is there smoe null type?
02:43:07 <ski> Void
02:43:08 <ski> ?
02:43:19 <Syzygy-> :k Either Void
02:43:22 <lambdabot> Not in scope: type constructor or class `Void'
02:43:35 <eivuokko> There isn't for context like that.  Usually such type is designated by type variable.
02:44:06 <ski> @djinn Either a b -> (a -> Void,b -> Void) -> Void
02:44:07 <lambdabot> f a =
02:44:07 <lambdabot>     case a of
02:44:07 <lambdabot>     Left b -> \ (c, _) -> c b
02:44:07 <lambdabot>     Right d -> \ (_, e) -> e d
02:44:08 <xerox> ?kind Control.Monad.RWS.RWST
02:44:10 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
02:44:13 <dmead> tsp: hows your haskell coming?
02:44:27 <ski> @djinn-env
02:44:27 <lambdabot> Plugin `djinn' failed with: IRCRaised Data.ByteString.last: empty ByteString
02:44:32 <ski> bah
02:45:16 <dmead> ski: you doing some logic too?
02:46:56 <joelr1> any template haskell experts in the house?
02:49:19 <dcoutts> joelr1: the Q functor instance is almost certainly defined in one of the TH modules
02:49:38 <joelr1> dcoutts: oh...
02:49:39 <dcoutts> otherwise if it's only in a later version or something then just define it locally
02:49:43 <dcoutts> @type fmap
02:49:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:49:47 <dcoutts> @type liftM1
02:49:50 <lambdabot> Not in scope: `liftM1'
02:49:53 <joelr1> M
02:49:56 <dcoutts> @type Control.Monad.liftM1
02:49:58 <lambdabot> Not in scope: `Control.Monad.liftM1'
02:50:01 <joelr1> @type liftM
02:50:04 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
02:50:06 <dcoutts> ah yes :-)
02:50:37 <joelr1> dcoutts: i guess i have to go fishing through the TH modules. i wouldn't know how to define a local instance
02:50:45 <joelr1> meaning what to put in the "methods"
02:51:17 <dcoutts> joelr1: notice how the type of fmap and liftM have a remarkable similarity? :-)
02:51:45 <joelr1> dcoutts: they look almost the same, yes, except functor is used instead of monad
02:51:46 <joelr1> why?
02:54:24 <ski> mathematically, every monad is a functor, and its 'fmap' is just 'liftM' as defined by
02:54:28 <ski> @src liftM
02:54:29 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
02:54:45 <Syzygy-> ?src IO fmap
02:54:45 <lambdabot> fmap f x = x >>= (return . f)
02:55:00 <ski> @undo do { x1 <- m1; return (f x1) }
02:55:01 <lambdabot> m1 >>= \ x1 -> return (f x1)
02:55:01 <Syzygy-> See any similarity?
02:55:33 <ski> (every instance of 'Monad' ought to be an instance of 'Functor' with 'fmap' being same as 'liftM')
02:55:43 <joelr1> yes, yes, just trying to figure out what this has to do with the TH error in http://hpaste.org/1261
02:56:51 <ski> (it would be better if 'Functor' was a superclass of 'Monad' .. but we'd like the class system to be more expressive so we can e.g. state defaults nicer ..)
02:59:10 <joelr1> dcoutts: it's TH.Syntax
03:00:36 <joelr1> dcoutts: but it's imported. weird...
03:00:49 <dcoutts> weird indeed
03:03:08 <joelr1> dcoutts: if I add a local  instance declaration then i get "Data/Derive/TH.hs:23:10: Not in scope: data constructor `Q`" any tips on this?
03:03:14 <mnislaih> I can't find the Functor instance fo Q either
03:03:20 <joelr1> i guess i have to go fishing for Q
03:03:30 <joelr1> mnislaih: TH.Syntax, it's there
03:03:38 <joelr1> mnislaih: in ghc 6.6 at leat
03:03:41 <joelr1> least
03:04:50 <mnislaih> if you were in 6.7, you can say "derive instance Functor Q" inside your module
03:04:52 <joelr1> cause Q is exported from TH.Syntax as well
03:05:12 <joelr1> is the list of new features in 6.7 posted someplace?
03:05:19 <mnislaih> but you can always write the instance manually
03:05:27 <mnislaih> or just use liftM
03:05:28 <joelr1> mnislaih: i did. see the next error above
03:08:04 <joelr1> i'm starting to get this weird feeling... that the sources in darcs that i'm looking at do not match the compiler that i'm using
03:08:40 <mnislaih>  you are looking at the ghc sources?
03:08:53 <joelr1> mnislaih: yes, but i pulled them from darcs so they must be 6.7
03:09:04 <joelr1> i'll have to go find my darwinports sources for 6.6
03:09:26 <mnislaih> those would be at http://darcs.haskell.org/ghc-6.6/
03:09:27 <lambdabot> Title: Index of /ghc-6.6
03:09:49 <joelr1> mnislaih: well, that makes my job easier. so hunting for Functor Q I go
03:10:08 <mnislaih> but if you are looking for the Language.Syntax.TH, that is at http://darcs.haskell.org/libraries/template-haskell/
03:10:09 <lambdabot> Title: Index of /libraries/template-haskell
03:10:54 <joelr1> mnislaih: thanks, looking...
03:11:38 <joelr1> mnislaih: same thing. look at the instance Functior Q
03:11:40 <joelr1> it's there
03:11:43 <joelr1> and Q is exported
03:11:51 <mnislaih> Thu Mar 22 18:01:42 CET 2007  Ian Lynagh <igloo@earth.li>
03:11:51 <mnislaih>   * Add instance Functor Q and make Quasi require Functor
03:12:03 <joelr1> @#%@#
03:12:03 <lambdabot> Unknown command, try @list
03:12:04 <mnislaih> that was added a few days ago
03:12:09 <mnislaih> :S
03:12:24 <joelr1> mnislaih: added to 6.6 a few days ago?
03:12:42 <mnislaih> it's not there in 6.6,
03:12:54 <joelr1> much grief
03:13:11 <mnislaih> yep,
03:13:13 <joelr1> still, why does it complain about missing Q?
03:13:22 <joelr1> not in scope data constructor Q
03:13:56 <mnislaih> because it is not exported
03:14:27 <mnislaih> you cannot really define the Functor instance locally,
03:14:38 <mnislaih> (I believe)
03:15:09 <joelr1> mnislaih: are you on 6.7? how close is that to production?
03:15:32 <joelr1> mnislaih: where can i read up on the features? /googling/
03:15:39 <mnislaih> it flukes sometimes, but not very often
03:15:57 <mnislaih> dont know.
03:16:30 <mnislaih> well there is the debugger, stand-alone deriving, a lot of improvements to the type system
03:16:53 <mnislaih> and now that Gregory Wright added a ghc-devel MacPort
03:16:57 <joelr1> mnislaih: what's standalone deriving?
03:17:17 <joelr1> mnislaih: don't see that (macport)
03:17:24 <joelr1> i only see 6.5 and 6.7
03:17:27 <joelr1> err, 6.6
03:17:29 <mnislaih> ask ghc to derive Q for you, even if you didn't define Q yourself
03:17:52 <mnislaih> G Wright posted to the glasgow-haskell-users list 2 or 3 days ago
03:19:18 <joelr1> mnislaih: looking...
03:20:27 <joelr1> found the post
03:20:47 <joelr1> i guess i'll just build the darcs version ... but then i'll have to rebuild my libs... argh...
03:21:06 <mnislaih> oh, and cabal-install comes there too
03:21:11 <joelr1> i guess i gotta look at it as my contribution to ghc development
03:21:17 <joelr1> mnislaih: what's cabal-install?
03:21:40 <mnislaih> havent seen hackage ?
03:21:45 <mnislaih> hackage.haskell.org
03:23:06 <joelr1> mnislaih: yes, seen hackage
03:23:11 <joelr1> so it pulls from there automatically?
03:23:47 <mnislaih> yep
03:25:28 <joelr1> mnislaih: does it automatically get invoked when you do runhaskell Setup.hs configure?
03:26:11 <mnislaih> no, I don't think so. But you better ask one of the cabal developers, they might have plans for that
03:27:39 <joelr1> mnislaih: ok, i'll try to run it
03:28:38 <joelr1> mnislaih = pepe?
03:28:47 <mnislaih> yes
03:28:55 <joelr1> ah, i'll have to remember that
03:29:00 <joelr1> @localtime mnislaih
03:29:02 <lambdabot> Local time for mnislaih is 2007-04-05 12:26:25 +0200
03:29:09 <mnislaih> hm?
03:29:12 <joelr1> mnislaih: madrid?
03:29:16 <mnislaih> valencia
03:29:27 <joelr1> mnislaih: cool! what do you dedicate yourself to?
03:29:38 <mnislaih> PhD procrastinating
03:29:46 <mnislaih> you are in Mallorca right ?
03:29:52 <joelr1> mnislaih: nah, tenerife
03:29:57 <mnislaih> ahh
03:30:28 <joelr1> but i can't afford to procrastinate :-)
03:32:29 <joelr1> mnislaih: i gave meself 1 week to rewrite my translator from ocaml
03:53:54 <joelr1> mnislaih: what did you do about System.Console.Readline?
03:54:24 <mnislaih> follow the instructions at http://mult.ifario.us/articles/tag/macosx
03:55:13 <joelr1> ok
03:55:17 <mnislaih> if that's dead, http://hackage.haskell.org/trac/ghc/wiki/X86OSXGhc
03:55:18 <lambdabot> Title: X86OSXGhc - GHC - Trac
03:56:12 <joelr1> i have readline in macports
03:56:17 <joelr1> i guess i should just point to it
03:56:23 <mnislaih> yep
04:09:48 <mnislaih> joelr1: I forgot to mention, after configure, check that ghc/libraries/readline says READLINE_BUILD_PACKAGE=yes
04:10:08 <joelr1> shoot, i didn't
04:10:19 <mnislaih> that's ghc/libraries/readline/config.mg sry
04:10:24 <mnislaih> config.mk
04:10:43 <joelr1> yes, it does
04:10:51 <joelr1> maybe i need to do a global distclean
04:10:57 <mnislaih> it's all fine then
04:11:17 <joelr1> cause just reconfiguring and letting make take over from where it left does not work
04:11:38 <mnislaih> you don't need to reconfigure if it was already allright
04:11:52 <joelr1> i did need to reconfigure to add readline paths
04:12:06 <joelr1> i still get the error from ghci
04:12:09 <mnislaih> oh,
04:12:19 <joelr1> should i clean in the compiler/ghci and deriver/ghci directories?
04:12:22 <mnislaih> yeah, make distclean is the safest way
04:12:33 <mnislaih> but you can try to touch InteractiveUI.hs
04:12:44 <mnislaih> and make clean only the readline package
04:12:52 <mnislaih> not sure if that will do the trick though
04:12:59 <joelr1> doing
04:19:31 <tsp> I guess if teckningar are notes, I can shorten that to teckning = one of them?
04:19:45 <tsp> that's an odd sounding word if I ever heard one :)
04:23:37 <joelr1> tsp: are you learning swedish?
04:23:44 <Syzygy-> teckningar = drawings
04:23:55 <Syzygy-> And yes, -ar is one of the plural suffices.
04:28:58 <joelr1> folks, is there a syntax colorizer in haskell?
04:29:05 <joelr1> that can be used for other languages
04:32:47 <dons> yeah, HsColour
04:32:50 <dons> ?where HsColour
04:32:51 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/hscolour/
04:32:59 <dons> its the one we use on hpaste.org
04:34:36 <joelr1> dons: that only colorizes haskell code, though. can be be extended?
04:35:11 <SamB_XP> it doesn't even support .txt!
04:35:13 <joelr1> i guess i'll need to loook into it
04:39:05 <joelr1> what do you make of this error?
04:39:05 <joelr1> unknown symbol `_derivezm0zi1_DataziDeriveziPeephole_zdf7_closure'
04:39:13 <joelr1> this happens when i run ghci -package derive
04:39:29 <joelr1> where derive is something that i just built and installed
04:40:04 <phoniq> running that through c++filt might help
04:40:23 <joelr1> phoniq: but derive is a haskell package, cabalized too
04:41:07 <phoniq> oops.  haskell's mangled symbol names look c++ish.
04:49:38 <joelr1> mnislaih: have you see this?
04:49:39 <joelr1> basicTypes/OccName.lhs-boot:1:0:
04:49:39 <joelr1>     Failed to load interface for `Prelude':
04:50:05 <mnislaih> that would be for stage2 ?
04:50:33 <joelr1> mnislaih: i guess. this is when trying to pick up after reconfigure. let me clean, configure and rebuild everything again
04:50:39 <mnislaih> oh, yes, that's probably due to split-objs causing trouble
04:50:49 <mnislaih> create a custom build.mk with split-objs disabled
04:51:04 <mnislaih> you know, in ghc/mk/
04:51:37 <mnislaih> and then make clean ; make -j2
04:52:17 <mnislaih> joelr1: make sure you disable split objs
04:52:38 <joelr1> mnislaih: why would i?
04:52:50 <joelr1> mnislaih: doesn't it help? or it fails on mac osx
04:53:14 <joelr1> or does it help pick up after a failure?
04:53:26 <mnislaih> split objs seem to cause trouble on mac osx. I disabled it a while ago and never looked back
04:54:40 <mnislaih> spying the macports settings for ghc-6.6 might give some further info on why
04:56:15 <joelr1> mnislaih: fishing for those settings ...
04:57:38 <mnislaih> note that everything works finely without split objs, it's just that link times will be a bit longer
04:58:39 <joelr1> mnislaih: where should i look for settings in macports? i have 3 files under distfiles/ghc
04:58:46 <joelr1> untar the bootstrap files?
04:59:09 <mnislaih> I guess in the port file mainly
04:59:14 <joelr1> i wish i could just look at the patches
04:59:30 <joelr1> mnislaih: silly question, i know, but where's the port file?
04:59:48 <mnislaih> dont know in the filesystem. it's all available in the macports subversion repo
05:00:09 <mnislaih> let me find the link
05:00:43 <mnislaih> http://trac.macosforge.org/projects/macports/browser/trunk/dports/lang/ghc
05:00:45 <lambdabot> Title: /trunk/dports/lang/ghc - MacPorts - Trac, http://tinyurl.com/yuucya
05:00:52 <mnislaih> there you go, the portfile and the patches are there
05:01:35 <joelr1> thanks pepe
05:01:37 <joelr1> Plan to throw one away. You will do that, anyway. Your only choice is whether to try to sell the throwaway to customers. - Frederick Brooks.
05:01:51 <joelr1> boom! right in the spot
05:02:09 <mnislaih> heh :)
05:02:11 <joelr1> this has happened to me a couple of times already, except i never sold the throwaway to customers :D
05:02:25 <joelr1> mnislaih: happening to me right now, throwing away the ocaml version
05:03:00 <mnislaih> viva haskell ;)
05:03:44 <joelr1> viva le haskell
05:03:51 <joelr1> sounds cooler i think
05:04:07 <joelr1> how do the french say viva?
05:04:26 <joelr1> pepe, didn't find anything re: split-objs
05:05:03 <joelr1> mnislaih: not in the port file anyway. loooking at patches
05:06:40 <joelr1> patch files have nothing on that either. but ghc is still building so i'll wait until it fails
05:06:54 <joelr1> make -j 2 screams
05:07:04 <joelr1> make -j fails with out of memory errors eventually
05:07:56 <mnislaih> ¬∫
05:08:24 <joelr1> mnislaih: i think you are right. editing config
05:09:25 <mnislaih> hopefully I'm right. Otherwise you won't be building ghc today :)
05:09:40 <joelr1> mnislaih: still, it's strange that there's no patch for it in macports
05:10:32 <mnislaih> prolly the port does something that solves the problem with split objs
05:10:39 <robreim> Are there any plans to implement a String typeclass to clean up all the different String and ByteString.* functions?
05:11:02 <mnislaih> gotta go for lunch
05:11:04 <mnislaih> gl joelr1
05:11:06 <dcoutts> robreim: not any immediate plans
05:11:15 <joelr1> thanks mnislaih
05:12:14 <robreim> dcoutts: got any idea what sort of problems such an endeavor might encounter?
05:12:40 <dcoutts> type, performance and dependencies
05:13:20 <joelr1> dcoutts: duncan, any idea on why a module of an installed library could not be found?
05:14:07 <robreim> dcoutts: sorry if it should be obvious to me, but can you elaborate? Perhaps with examples?
05:15:26 <quicksilver> joelr1: you got mail :)
05:15:36 <joelr1> quicksilver: checking...
05:15:48 <quicksilver> let constructorName = takeWhile (/=' ') . show in constructorName (Just undefined)
05:15:51 <quicksilver> > let constructorName = takeWhile (/=' ') . show in constructorName (Just undefined)
05:15:52 <lambdabot>  "Just"
05:15:57 <quicksilver> that's pretty interesting
05:15:59 <dcoutts> joelr1: the module might not be exposed, the package might not be exposed
05:16:01 <quicksilver> not that that:
05:16:03 <joelr1> quicksilver: is that you, jules?
05:16:06 <quicksilver> > show (just undefined)
05:16:06 <lambdabot>   Not in scope: `just'
05:16:12 <quicksilver> > show (Just undefined)
05:16:13 <lambdabot>  Undefined
05:16:15 <dcoutts> robreim: sorry, no time. I've got to finish a paper.
05:16:19 <quicksilver> joelr1: right
05:16:26 <robreim> no problem. Thanks anyhow.
05:16:39 <dcoutts> robreim: ask me in two days time :-)
05:16:40 <quicksilver> joelr1: metaprogramming is great but you don't always needs it; or not as much as many people imagine, anyhow
05:16:58 <joelr1> quicksilver: appreciate your email. reading...
05:17:25 <Syzygy-> > let constructorName = takeWhile (/=' ') . show; test = (23 :: Integer) in constructorName test
05:17:26 <lambdabot>  "23"
05:17:30 <Syzygy-> Doh.
05:17:38 <robreim> dcoutts: I'll try to remember. In the meantime, best wishes with your paper. Gambatte!
05:17:52 <Syzygy-> > let constructorName = takeWhile (/=' ') . show; test = (return 15)::Maybe Integer in constructorName test
05:17:52 <mux> dcoutts: out of curiosity, what's your paper about?
05:17:54 <lambdabot>  "Just"
05:17:57 <Syzygy-> Ah!
05:18:23 <quicksilver> and I bet there is a typeclass hack to tell how many parameters a constructor has, too
05:18:26 <quicksilver> although not a h98 one
05:18:35 <dcoutts> mux: fusion
05:19:00 <mux> dcoutts: again! ;-)
05:19:14 <dcoutts> mux: up, more fusion
05:19:41 <joelr1> quicksilver: awesome suggestions, thanks. i do want to automatically choose the # and type of args, though
05:19:46 <mux> great, I wish I could attend your talk
05:20:21 <joelr1> i have a suspicion that dons and dcoutts are writing a paper together. maybe two!
05:20:23 <joelr1> hehe
05:20:31 <dcoutts> @arr
05:20:32 <lambdabot> Aye
05:20:37 <joelr1> two days... two papers... two days
05:21:05 <dcoutts> mux: the conference isn't for months yet but the deadline...
05:21:26 <mux> oh
05:22:37 <joelr1> @arr
05:22:38 <lambdabot> Aye
05:22:42 <joelr1> hmm
05:24:10 <quicksilver> joelr1: yeah, I know you do
05:24:17 <quicksilver> joelr1: I thought the point was interesting to make nonetheless
05:25:15 <joelr1> quicksilver: i concur
05:27:56 <araujo> morning!
05:28:34 <joelr1> @where derive
05:28:35 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/derive
05:34:36 <hpaste>  quicksilver pasted "Counting arguments using a type class" at http://hpaste.org/1262
05:34:43 <quicksilver> joelr1: check that paste
05:36:27 <joelr1> quicksilver: hmm...
05:36:45 <joelr1> quicksilver: i gotta save that pasted!
05:38:54 <joelr1> quicksilver: totally love it but i have something like 100 parsers to derive, very tedious by hand
05:39:14 <hpaste>  quicksilver annotated "Counting arguments using a type class" with "Now it describes the arguments too" at http://hpaste.org/1262#a1
05:39:15 <joelr1> quicksilver: i'm saving your tips for other future uses, though
05:39:38 <quicksilver> joelr1: now it counts the types and lists them in a concrete data type
05:39:49 <joelr1> hmm...
05:40:03 <joelr1> let me take that a bit further
05:40:42 <joelr1> quicksilver: if you can grab the arg types as a list you can probably generate a list of parsers from it, right? if you were able to attach a type to each parser
05:41:07 <tsp> Program som k√∂rs!
05:41:15 <joelr1> although you would need to collect all your types into the separate ArgTypes ADT.
05:41:20 <joelr1> quicksilver: right ^^^
05:41:21 <joelr1> ?
05:41:25 <tsp> just realized I had to reinstall inux :)
05:41:28 <tsp> linux
05:41:49 <tsp> accidentally deleted the disk
05:41:56 <Cale> whoa
05:42:10 <Cale> Which linux will you be installing? :)
05:42:15 <joelr1> ubuntu!
05:42:25 <Cale> Yeah, Ubuntu rocks :)
05:43:04 <tsp> arch
05:43:06 <Cale> Too bad about your files, eh? Or do you keep a separate home partition?
05:43:14 <tsp> Cale: heh, it was my haskell test box
05:43:15 <tsp> vmware
05:43:16 <Cale> ah
05:43:23 <tsp> everything important is on this sparc box
05:43:26 <quicksilver> joelr1: sorry, I was tidying it up
05:43:27 <joelr1> Cale: big time! that's what i'm using as my amazon EC2 image
05:43:36 <joelr1> quicksilver: another paste? :D
05:43:47 <hpaste>  quicksilver annotated "Counting arguments using a type class" with "tidier, no more quadratic instance explosion" at http://hpaste.org/1262#a2
05:43:47 <joelr1> quicksilver: more type class magic?
05:44:23 <hpaste>  quicksilver annotated "Counting arguments using a type class" with "try again (was tidier, no more quadratic instance explosion" at http://hpaste.org/1262#a3
05:44:44 <quicksilver> joelr1: better, don't need instances for each possible a->b->TestType
05:44:57 <quicksilver> Cale: care to take a look?
05:45:07 <Cale> okay
05:45:09 <quicksilver> Cale: objective was to produce a type class framework which can 'introspect' an ADT
05:45:19 <quicksilver> Cale: and find out how many parameters, and what types, each constructor has
05:45:28 <joelr1> quicksilver: i still see them there, instances for each possible a -> b -> TestType
05:45:36 <Cale> Have you looked at SYB?
05:45:41 <quicksilver> joelr1: not in the last paste. just one instance for it
05:45:55 <quicksilver> Cale: yes; this is just H98 + MPTCs, though
05:45:58 <joelr1> quicksilver: instance DescribeArgs (String->TestType) TestType where descArgs _ = [JStr]
05:45:59 <Cale> ah, okay
05:46:03 <joelr1> this is the last paste
05:46:06 <joelr1> the tidier one
05:46:26 <quicksilver> joelr1: no, that's the one I pasted in error :)
05:46:28 <quicksilver> joelr1: scroll down
05:46:32 <quicksilver> joelr1: or, reload
05:46:44 <joelr1> quicksilver: got it
05:47:33 <joelr1> quicksilver: can you paste the output from a couple of examples? like you did with CountArgs?
05:47:45 <joelr1> quicksilver: well, never mind that, a better question
05:48:28 <joelr1> quicksilver: does this solution require me to gather all my types under ArgTypes?
05:49:35 <hpaste>  quicksilver annotated "Counting arguments using a type class" with "with examples + one more constructor" at http://hpaste.org/1262#a4
05:49:42 <quicksilver> joelr1: yes
05:49:54 <quicksilver> joelr1: or you could use 'Typeable'
05:50:02 <quicksilver> joelr1: which is a built-in haskell way to concretize most types
05:50:19 <quicksilver> joelr1: I don't think it's a bad thing to collect all your types into a constructor, personally
05:50:41 <joelr1> quicksilver: well, i have a huge AST, right
05:50:58 <quicksilver> joelr1: but presumably no more than a dozen parameter types...
05:51:05 <quicksilver> joelr1: most DSLs just have 4 or 5
05:51:15 <joelr1> quicksilver: with types for numerical expressions, string expressions, etc.
05:51:51 <quicksilver> joelr1: ok, go on
05:52:07 <joelr1> quicksilver: to tell you the truth, arguments can only be of type string, bool or num expression, although just NumExpr can look like this
05:52:10 <joelr1> @paste
05:52:11 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:52:27 <hpaste>  joelr1 pasted "NumExpr" at http://hpaste.org/1263
05:52:50 <joelr1> string expression and bool expr look similar
05:53:05 <joelr1> so what i'm trying to derive is a parser for this type
05:53:24 * quicksilver nods
05:53:54 <joelr1> the reason that have separate NumGroup, BoolGroup, StrGroup or same for NumArrayVar, etc. is because i would like to use quickcheck to generate a random AST
05:54:18 <joelr1> and with just Expr (like i had before) i would be generating invalid ASTs at times
05:54:36 <joelr1> the way i have it now everything is nicely typed
05:54:40 * quicksilver nods
05:54:47 <quicksilver> well, perhaps you want data.typeable then
05:54:53 <joelr1> the kicker is that NumCall has about... let me count them
05:54:54 <quicksilver> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html
05:54:56 <lambdabot> http://tinyurl.com/ylclo5
05:55:12 <quicksilver> or, to be honest, perhaps you want to do with with Data.Derive just as stefan suggested
05:55:24 <quicksilver> but it's interesting to see how far you can get within the language
05:55:42 <joelr1> quicksilver: 170+ constructors describing the various numerical functions
05:56:11 <quicksilver> joelr1: funky :)
05:56:17 <joelr1> quicksilver: so i want to 1) derive parsers for these and 2) derive pretty-printers
05:56:22 <joelr1>  based on the types
05:56:45 <quicksilver> there was a paper on writing pretty printers and parsers simultaneously
05:56:52 <joelr1> it's easy because the format is always the same: function name '(' arg1 , arg2 , ... ')'
05:57:04 <joelr1> quicksilver: don't have that paper
05:57:16 <quicksilver> joelr1: http://www.cs.ru.nl/A.vanWeelden/bi-arrows/
05:57:18 <lambdabot> Title: There and Back Again: Arrows for Invertible Programming
05:57:33 <joelr1> quicksilver: but i can imagine that you can somehow derive an unparser from a parser
05:57:52 <joelr1> this sucks. full paper at ACM :(
05:57:54 <joelr1> why?!
05:58:01 <quicksilver> joelr1: http://citeseer.ist.psu.edu/alimarine05there.html
05:58:02 <lambdabot> Title: There and Back Again: Arrows for Invertible Programming (ResearchIndex)
05:58:08 <quicksilver> joelr1: downloadable from that link
05:58:11 <quicksilver> joelr1: good old citeseer
05:58:32 <Botje> damn you, quicksilver. I was just about to start working for school :)
05:58:42 <quicksilver> Botje: damn me for which part?
05:58:55 <Botje> linking to a paper about stuff that interests me ;)
05:58:57 <quicksilver> joelr1: I think I'll email my snippet to the -cafe. No doubt there are even cleverer generalisations
05:59:43 <joelr1> quicksilver: definitely but hang on a bit
05:59:57 <joelr1> quicksilver: maybe you'll want to add more?
06:00:19 <joelr1> anyway, i downloaded the paper. eventually, i'll set friday aside (saturday maybe?) just to reading papers :D
06:00:28 <quicksilver> :)
06:00:46 <quicksilver> Cale: seen this trick before?
06:00:49 <joelr1> but back to the grind, would you say that it's impossible to derive the parser and pprinter with your approach?
06:01:06 <quicksilver> > let constructorName = takeWhile (/=' ') . show in constructorName (Just undefined)
06:01:07 <lambdabot>  "Just"
06:01:31 <quicksilver> joelr1: no, not at all. But in the design I outlines, you would need to 'shadow' all your argument types with a concrete ADT
06:01:41 <quicksilver> joelr1: at least that's work that only needs doing once, but it's still work
06:02:00 <quicksilver> joelr1: on the other hand, you could use Data.Typeable and its TypeRep, which gives you that for most types for free
06:02:23 <joelr1> quicksilver: another paste would be _very_ welcome ;-)
06:02:29 <quicksilver> joelr1: for which part?
06:02:34 <joelr1> keeping the old paste, of course, for pasting both
06:02:37 <joelr1> for typeable
06:06:20 <hpaste>  quicksilver annotated "Counting arguments using a type class" with "Data.Typeable version" at http://hpaste.org/1262#a5
06:06:54 <quicksilver> joelr1: it's almost identical. My 'ConcreteType' class was just a cut-down special case of Data.Typeable.
06:07:19 <joelr1> quicksilver: looking
06:07:52 <quicksilver> joelr1: oh, I removed the multiple parameters on the typeclasses. They were not necessary, I was just confused.
06:07:57 <joelr1> quicksilver: so no unification of types is needed
06:08:59 <joelr1> quicksilver: would you say that what's needed now is to make each type an instance of a Parseable class and an instance of a PrettyPrintable one?
06:09:29 <joelr1> cause then, it would seem, you could just fmap parse to the list of returned types to parse
06:09:39 <joelr1> and fmap pprint to pretty-print
06:09:50 <quicksilver> joelr1: more or less, yes
06:09:59 <joelr1> quicksilver: why more or less?
06:10:02 <quicksilver> joelr1: there's some work to do in terms of adding commas in between productions
06:10:08 <quicksilver> joelr1: and brackets around them
06:10:12 <quicksilver> joelr1: it's not hard though
06:10:47 <quicksilver> joelr1: anyhow I have to grab some lunch and do some work. I'll paste the last version to the -cafe in case anyone has a comment
06:11:06 <joelr1> quicksilver: thanks a lot! can i ask one more q?
06:11:36 <joelr1> should this support liftMx to return the type?
06:11:44 <joelr1> with the parsed arguments
06:12:41 <joelr1> anyhow, this is extra-fine type class hackery! :D thanks again
06:13:04 <Saizan> couldn't this be handled once with some typeclass recursiveness hackery?
06:13:16 <joelr1> Saizan: don't ask me
06:13:22 <joelr1> i wouldn't know
06:13:27 <Saizan> enumering types i mean
06:15:38 <joelr1> i also wonder if there's a hack to get the constructors... hmm... after this i figure (almost) anything is possible!
06:16:04 <quicksilver> joelr1: 'get the constructors'? what do you mean?
06:16:13 <Saizan> given the type?
06:16:17 <joelr1> quicksilver: i thought you were out to lunch :D
06:16:20 <desp> odd
06:16:32 <quicksilver> joelr1: no, I went to buy a sandwich
06:16:45 <quicksilver> joelr1: ah, well that's a tricky one because they don't have the same type as each other
06:16:58 <quicksilver> joelr1: so without existentials, you can't make that a well-typed program
06:17:01 <joelr1> well, if my NumCall has 170 constructors metaprogramming lets me derive the whole type
06:18:53 <quicksilver> joelr1: yes, I see what you mean
06:19:06 <quicksilver> joelr1: I can't think of a way of doing that :)
06:19:22 <Saizan> something with TH maybe?
06:19:35 <quicksilver> Saizan: the point of this tangent it to avoid true metaprogramming
06:19:46 <quicksilver> Saizan: he already knows how to do it with Data.Derive, more or less
06:19:53 <Saizan> oh ok
06:19:59 <quicksilver> Saizan: I was showing how close he could get with a couple of typeclasses
06:25:48 <joelr1> very close indeed
06:35:17 <hpaste>  Saizan annotated "Counting arguments using a type class" with "one recursive case to rule them all" at http://hpaste.org/1262#a6
06:37:09 <joelr1> Saizan: looking
06:37:38 <joelr1> Saizan: what does that give you? you didn't post example output
06:38:50 <Saizan> it gives you the same functionality with only 2 instances, regardless of the number and arity of the contructors
06:39:21 <joelr1> i see
06:40:05 <joelr1> haskell is awesome precisely because of folks like you (Saizan, quicksilver, dons, dcoutts, Cale and others too)
06:40:14 <joelr1> i think this is strongly underappreciated
06:41:17 <quicksilver> Saizan: ah, I wondered if that was possibly
06:41:27 <quicksilver> Saizan: I ran out of time to try it :)
06:41:38 <joelr1>  i had a chance to compare during my ocaml month
06:42:28 <joelr1> how in the world do i debug: baz.hs:30:3: Not in scope: `a1'
06:42:47 <joelr1> (posted to cafe)
06:43:20 <Philippa> joelr1: well, in one sense it's trivial - the identifier's not bound there
06:43:36 <Philippa> do you know where the binding site you're expecting to cover that use is?
06:43:40 <joelr1> Philippa: right. the question where does it come from. it's not obvious by looking at the code
06:43:58 <Philippa> you mean there's no a1 at 30:3? Oh
06:44:02 <Philippa> which implementation're you using?
06:44:06 <joelr1> Philippa: beats me! it's template haskell generating a1, i think
06:44:12 <Philippa> ah
06:44:13 <joelr1> Philippa: take a look at the last message in cafe
06:44:18 <Philippa> in that case, have fun
06:44:32 <joelr1> Philippa: under Automatic Derivation of ..
06:44:43 <Philippa> something that might help: you can use debug.trace from inside the quotation monad
06:44:52 <joelr1> hmm
06:45:03 <Philippa> another something that /might/ help: IIRC there're show instances on the quoted code types
06:45:10 <Saizan> you can dump the code generated by TH with a flag
06:45:15 <Igloo> joelr1: Pretty-print the stuff you're splicing in
06:45:39 <Igloo> and if that doesn't help, print the actual datatype
06:45:47 <joelr1> Saizan: which flag
06:45:52 <Saizan> -ddump-splices iirc
06:46:05 <joelr1> Igloo: i'm not splicing much in, just a name
06:46:38 <joelr1> that helped
06:47:13 <hpaste>  joelr1 annotated "NumExpr" with "result from -ddump-splices" at http://hpaste.org/1263#a1
06:48:46 <hpaste>  sebell pasted "Parsec string matching issues" at http://hpaste.org/1264
06:51:03 <joelr1> sebell: if you are matching a portion you need to use try, i think
06:51:09 <hpaste>  sebell annotated "Parsec string matching issues" with "Possible fix" at http://hpaste.org/1264#a1
06:51:12 <joelr1> sebell: so that the parser fakes reading no input
06:51:26 <joelr1> sebell: yup
06:53:31 <sebell> bleh. That was a blonde moment
06:55:57 <joelr1> happens to me all the time
06:58:32 <joelr1> :t fromInteger
06:58:35 <lambdabot> forall a. (Num a) => Integer -> a
07:05:22 <sorear> hello!
07:05:31 <glguy> oh dear :)
07:05:43 <joelr1> hi stefan
07:05:49 <joelr1> glguy: what;s your name?
07:06:05 <glguy> *** glguy is n=eric@
07:06:12 <glguy> :)
07:06:18 <sorear> and with a little googling...
07:06:26 <sorear> you may have heard of 'hpaste'
07:06:34 <sorear> read the who-wrote-it
07:06:35 <glguy> it doesn't take much to tie me to a real name and email
07:06:41 <sorear> then read the darcs inventor
07:07:01 <glguy> joelr1: why do you ask?
07:07:08 <sorear> Eric Mertens <emertens@gmail.com>**20070118045641]
07:07:14 <glguy> yeah, that one
07:08:11 <joelr1> glguy: for no reason. just like to associate nicks with name of people posting to cafe
07:08:24 <glguy> ah
07:08:29 <glguy> I don't post *too* much
07:08:37 <joelr1> yeah, unlike me
07:08:49 <beelsebob> is there a properly proscribed way of renaming files/folers in darcs?
07:08:52 <sebell> My inbox is full of Joel ;)
07:09:43 <sorear> beelsebob: darcs mv
07:09:47 <glguy> I remembered that I am off tomorrow when I got to work today
07:10:00 <glguy> that really brightened up my morning :)
07:17:28 * sorear has a LOT of mails to reply to...
07:21:20 <joelr1> sorear: not really :D
07:22:04 <joelr1> sorear: you should get one last mail that clears it up. well, almost since the parser doesn't work right but that doesn't seem to have anything to do with derivation
07:28:57 <matthew-_> @src Monad ((,) a)
07:28:58 <lambdabot> Source not found. You type like i drive.
07:29:01 <matthew-_> @src Monad (,)
07:29:01 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
07:29:50 <matthew-_> @type \f -> f >>= (,)
07:29:53 <lambdabot> forall a b. (b -> a) -> b -> (a, b)
07:30:03 <sorear> @src (,) >>=
07:30:03 <lambdabot> Source not found. Maybe if you used more than just two fingers...
07:30:07 <sorear> @src , >>=
07:30:08 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
07:30:11 <glguy> (,) isn't a monad?
07:30:20 <sorear> glguy: import
07:30:23 <mauke> (,) takes two args, it can't be a monad
07:30:26 <sorear> @instances Monad
07:30:28 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
07:30:31 <matthew-_> it's the -> r
07:30:37 <sorear> @instances-importing Control.Monad.Instances Monad
07:30:39 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
07:30:44 <matthew-_> must be. (,) is a function
07:30:45 <sorear> @instances-importing Control.Monad.Writer Monad
07:30:46 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
07:30:57 <matthew-_> so it must be the ((->) r) which is the monad
07:30:59 <glguy> ah, I see what you were trying to do
07:31:05 <sorear> @tell dons @instances-importing Control.Monad.Writer Monad doesn't find (,) a
07:31:06 <lambdabot> Consider it noted.
07:31:13 <sorear> @flush
07:31:21 <glguy> @wipe
07:31:22 <lambdabot> Maybe you meant: dice time type wiki
07:31:59 <dhart> I have a quick question: in using HOpenGL, GHC seems to be bafled by "Vertex2 100 100", saying "ambigouis type variable". Is there a way of "casting" he values to GLfloat?
07:32:15 <matthew-_> 100::GLfloat
07:32:22 <mauke> (100 :: GLfloat)
07:32:23 <dhart> thx a bunch
07:32:42 <mauke> @bot
07:32:43 <lambdabot> :)
07:32:48 <mauke> bah, lag
07:36:51 <sorear> joelr1: so how long did it take you to figure out I was S. O'Rear?  A *lot* of people seem to think I'm a random guy with a pseudonym and an earache...
07:37:21 <joelr1> sorear: ugh... a minute yesterday. you said something and then sent me an email
07:40:15 <joelr1> mnislaih: i wonder if my prelude error is caused by my using make -j 2
07:40:45 <mnislaih> the prelude error means that base did not build
07:41:06 <sebell> joelr1: Which snapshot are you building?
07:41:07 <mnislaih> make -j2 works fine here
07:41:20 <mnislaih> did split-objs help ?
07:41:26 <dhart> And how would I do a conversion from Integer to GLfloat?
07:41:32 <sorear> fromInteger
07:42:02 <joelr1> sebell: ugh... 0404
07:42:15 <joelr1> mnislaih: no, it did not
07:42:36 <joelr1> mnislaih: i put NO in my build.mk
07:42:47 <mnislaih> can you check what happens when you call make from libraries/base ?
07:42:50 <joelr1> mnislaih: oh, i did manage to build the "quickest" configuration, btw
07:42:56 <joelr1> i can't build the perf one
07:43:04 <joelr1> with or without split objects
07:44:15 <sebell> joelr1: Hmm. I build 0404 yesterday without any issues... (default build)
07:44:39 <joelr1> sebell: platform?
07:44:48 <sebell> Linux x86. Are you using Mac OS X?
07:44:54 <joelr1> sebell: 100%
07:44:57 * sebell doesn't think he has 0404 on his Mac
07:46:29 <mnislaih> joelr1: it's certainly possible to build "perf" in Os X, although I don't have 0404 either. I have Mar 29 here
07:46:45 <sorear> I'm using 0402, built from darcs with my TH patches
07:46:58 <joelr1> sorear: mac osx ? intel?
07:47:03 <sorear> wanted to spare myself the embarrasement of sending patches that broke the build
07:47:04 * mnislaih builds from darcs too
07:47:11 <sorear> sorry, PC intel
07:47:22 <joelr1> i'm building from darcs myself
07:47:29 <sorear> having mukke, why not make install?
07:47:53 <joelr1> mukke?
07:47:57 <joelr1> who is mukke
07:48:24 <sorear> past tense of make?
07:50:33 <sebell> joelr1: I don't know if it would make a different, but I would try the source snapshot distribution
07:50:36 <sebell> *difference
07:54:47 <joelr1> my example parser doesn't work :-(
07:55:17 <joelr1> can anyone suggest a reason?
07:56:02 <sorear> have you looked at the generated code?
07:56:30 <joelr1> i should, let me just make a paste
07:56:32 <joelr1> @paste
07:56:33 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:57:02 <hpaste>  joelr1 pasted "simple parser not working" at http://hpaste.org/1265
07:58:00 <hpaste>  joelr1 annotated "simple parser not working" with "generated code" at http://hpaste.org/1265#a1
07:58:39 <joelr1> sorear: i don't think it's the code
08:00:27 <joelr1> meaning i don't think it's the derivation that's causing the problem, it's the structure of the parser
08:03:01 <sorear> joelr1: found it
08:03:09 <joelr1> sorear: found what?
08:04:50 <hpaste>  joelr1 annotated "simple parser not working" with "still no dice" at http://hpaste.org/1265#a2
08:05:14 <joelr1> this is what i'm trying: run fooParser "Bar (10, 10.345)"
08:06:01 <beelsebob> joelr1: why not just use Happy?
08:06:29 <joelr1> beelsebob: too late. plus, my original ocaml parser was written yacc-style and i much rather use the combinators
08:06:57 <joelr1> beelsebob: i can test things in chunks
08:08:40 <joelr1> sorear: what did you find?
08:11:55 <sorear> joelr1: mail sent
08:13:20 <joelr1> sorear: thanks stefan. can you tell me why the choice version with try doesn't work?
08:13:24 <joelr1> in the paste
08:13:44 <joelr1> i.e. one that has choice [ try $ float, integer ]
08:14:02 <joelr1> it would seem to me that it would try float first and then integer
08:14:25 <joelr1> this works on Foo, for example
08:14:44 <joelr1> *Main> run fooParser "Foo (10.345)"
08:14:44 <joelr1> Foo (Num 10.345)
08:15:04 <joelr1> it doesn't work for run fooParser "Bar (10, 10.345), though. let me try your version anyhow
08:18:17 <quicksilver> joelr1: surely the float will match an int though
08:18:30 <quicksilver> joelr1: and just return a floatified version of the int?
08:18:48 <yaarg> why did the designer of sed decide to use / as a delimter?
08:18:53 <yaarg> i mean really WTF was he thinking?
08:19:10 <joelr1> quicksilver: right but there's on constructor that starts with a double
08:19:35 <joelr1> i mean bar wants int first ... oh, i see... i think i see
08:19:49 <joelr1> it eats up the int as a float and bombs out
08:19:51 <ibid> yaarg: i believe it predates sed :)
08:20:06 <ibid> yaarg: probably comes from the original ed
08:20:26 <yaarg> probably right
08:20:27 <ibid> (you do know that grep comes from the ed command g/re/p :)
08:20:41 <ibid> (the name, that is)
08:20:56 <yaarg> yup
08:21:23 <robreim> I can't make changes to my trac proposal. Has this something to do with that big spamming I heard mention of?
08:21:38 <yaarg> i just realised i spammed the wrong channel too :)
08:21:56 <sorear> robreim: log in as guest, pw guest
08:22:18 <sorear> anons can still make changes, it's just registered users that are locked out
08:22:23 <robreim> sorear: I'm logged in as myself. Is guest preferable?
08:22:27 <robreim> oh ok, thanks :)
08:22:38 <ibid> why does that make sense?
08:22:54 <sorear> robreim: and nag Igloo (?) to add you to the 'developers' group
08:23:00 <joelr1> sorear: what is your sign parser?
08:23:15 <sorear> joelr1: it's from the Token source
08:23:25 * sorear makes sure it is exported
08:23:33 <joelr1> sorear: it's not exported... i think
08:23:42 <Igloo> robreim: What's your username?
08:23:57 <sorear>     sign            =   (char '-' >> return negate)
08:23:58 <sorear>                     <|> (char '+' >> return id)
08:23:58 <sorear>                     <|> return id
08:24:06 <robreim> Igloo: robreim
08:24:07 <sorear> that shouldn't be too much to copy :)
08:24:37 <Igloo> robreim: OK, should work now
08:24:38 <joelr1> sorear: right, thanks
08:24:52 <robreim> Igloo: yup! Thanks plenty :)
08:26:28 <joelr1> sign doesn't work with doubles :(
08:26:32 <joelr1> working on it
08:28:36 <sorear> joelr1: it does too
08:28:54 <sorear> joelr1: you're just running into the fact lambda bound variables are monomorphic :(
08:28:59 <joelr1> ugh
08:29:36 <joelr1> sorear: so what am i to do?
08:29:42 <sorear> you could work around it by having sign return +1 or -1
08:30:17 <sorear> then replace each sg with (fromIntegral sg *)
08:30:25 <sorear> fromInteger even
08:31:02 <joelr1> right
08:31:12 <joelr1> trying
08:34:27 <joelr1> :t either
08:34:32 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
08:34:50 <sorear> @djinn (a -> c) -> (b -> c) -> Either a b -> c
08:34:51 <lambdabot> f a b c =
08:34:51 <lambdabot>     case c of
08:34:51 <lambdabot>     Left d -> a d
08:34:51 <lambdabot>     Right e -> b e
08:35:08 <sorear> @src either
08:35:09 <lambdabot> either f _ (Left x)     =  f x
08:35:10 <lambdabot> either _ g (Right y)    =  g y
08:35:25 <sorear> probably that last is the clearest :)j
08:36:30 <joelr1> sorear: i like the 1st one, actually. so either takes two functions and one either a b returned by naturalOrFloat
08:36:43 <joelr1> :t naturalOrFloat
08:36:46 <lambdabot> Not in scope: `naturalOrFloat'
08:36:53 <joelr1> @where naturalOrFloat
08:36:54 <lambdabot> I know nothing about naturalorfloat.
08:37:03 <sorear> :t Text.ParserCombinators.Parsec.Token.natOrFloat
08:37:06 <lambdabot>     Not in scope: `Text.ParserCombinators.Parsec.Token.natOrFloat'
08:37:09 <sorear> :t Text.ParserCombinators.Parsec.Token.naturalOrFloat
08:37:12 <lambdabot> forall st. Text.ParserCombinators.Parsec.Token.TokenParser st -> Text.ParserCombinators.Parsec.Char.CharParser st (Either Integer Double)
08:38:02 <quicksilver> sorear: would be a small-but-cute enhancement to djinn
08:38:13 <quicksilver> sorear: for it to rewrite top-level cases as multiple definitions
08:38:51 <sjanssen> top level cases on a simple variable
08:39:09 <sorear> hehe.  djinn was given to us by a hacker of far greature stature than I
08:39:25 <sjanssen> sorear: but it'd be great fun to send a patch to lennart!
08:39:25 <sorear> or were you not implying I wrote it?
08:41:06 <tsp> > "haskell √§r en Program som k√∂rs"
08:41:09 <lambdabot>  "haskell \228r en Program som k\246rs"
08:41:37 <earthy> haskell is a program with what now?
08:41:40 <tsp> no idea
08:41:50 <mauke> > "‚Ç¨"
08:41:52 <lambdabot>  "\8364"
08:41:58 <sorear> > "?"
08:42:00 <lambdabot>  "?"
08:42:07 <tsp> same thing here - a ?
08:42:12 <quicksilver> sorear: I didn't intend to imply you wrote it. Just you had contrasted the two definitions
08:42:20 <earthy> > "\8364"
08:42:21 <lambdabot>  "\8364"
08:42:25 <earthy> pity. :)
08:42:28 <mauke> U+20AC (0xe2 0x82 0xac): EURO SIGN [‚Ç¨]
08:42:43 <tsp> what is a program som k√∂rs?
08:42:44 <sjanssen> since when did lambdabot learn UTF-8?
08:43:04 <sorear> sjanssen: it doesn'
08:43:21 <sorear> sjanssen: it passes an uninterpreted string of bytes to GHCI 6.6
08:43:28 <sorear> sjanssen: which does know utf8
08:43:48 <sorear> well, GHC actually
08:44:03 <chessguy> ?version
08:44:04 <lambdabot> lambdabot 4p517, GHC 6.6 (OpenBSD i386)
08:44:04 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
08:44:39 <tsp> OpenBSD? yuck
08:44:42 <tsp> freebsd ftw
08:44:43 <glguy> lol
08:44:47 <hpaste>  joelr1 annotated "simple parser not working" with "a generated parser issue?" at http://hpaste.org/1265#a3
08:45:11 <joelr1> sorear: still not working but i'm fighting it
08:47:01 <sjanssen> wow, 77 Haskell mailing list posts since I sent to sleep
08:47:47 <chessguy> ?vera ftw
08:47:50 <lambdabot> No match for "ftw".
08:47:56 <sorear> it's all joelr1's fault ;)
08:48:02 <sorear> chessguy: for teh win
08:48:17 * joelr1 hides in his cave
08:48:23 <chessguy> win?
08:48:38 <syntaxfree> I'm trying out common lisp.
08:48:39 <sorear> hello syntaxfree!
08:48:42 <sorear> yay?
08:48:46 <tsp> common lisp? heh
08:48:49 <syntaxfree> I feel like I'm cheating on my wife or something.
08:48:55 <opqdonut> :DD
08:48:59 <hpaste>  joelr1 annotated "simple parser not working" with "close but no cigar" at http://hpaste.org/1265#a4
08:49:04 <syntaxfree> I became curious because of the CLOS article that came out on reddit.
08:49:10 <glguy> syntaxfree: well, she's probably cheating with lambdabot
08:49:16 <glguy> syntaxfree: so it all works out
08:49:18 <chessguy> @quote cheat
08:49:19 <lambdabot> sebazzz says: * sebazzz sabe que emonk es un negro sucio y cheatero
08:49:32 <syntaxfree> the "generic dispatch" thing is actually very very close to what I'm used to in gnu r.
08:49:32 <chessguy> uh
08:49:36 <syntaxfree> but no lazy evaluation is weird!
08:49:38 <joelr1> syntaxfree: set your feelings free
08:49:52 <greenrd> Is it my overactive imagination, or did someone once announce a library to make it easier to use the GHC API?
08:49:55 <syntaxfree> anyway, hello everyone!
08:49:57 <chessguy> i don't think that quote should be in there
08:50:00 <joelr1> syntaxfree: i'm a language whore although haskell is becoming my favorite
08:50:02 <sorear> greenrd: hs-plugins
08:50:08 <int-e> joelr1: you're using the result of sign with two different types I think; use  fromIntegral sign  in the Num case?
08:50:10 <syntaxfree> hey sorear :)
08:50:20 <sorear> @remember syntaxfree I'm trying out common lisp.  ...  I feel like I'm cheating on my wife or something.
08:50:21 <lambdabot> Done.
08:50:25 <greenrd> sorear: I don't think it's that I'm thinking of. hs-plugins is for loading code dynamically, right?
08:50:35 <syntaxfree> (defun g (x y) (setq x (+ y x)))
08:50:39 <sjanssen> greenrd: I vaguely remember that announcement
08:50:41 <joelr1> int-e: let me try
08:50:42 <greenrd> I've found lemmih's ghc-api library, but that's not what I'm thinking of - I think it's just a snapshot of the ghc api
08:50:45 <sorear> greenrd: yeah, but it uses ghc-plugis
08:50:55 <sorear> er, ghc-api
08:50:55 <syntaxfree> (defun dup (f i) (funcall f i i))
08:50:57 <greenrd> ok
08:51:00 <mauke> syntaxfree: (defun g (x y) (incf x y))
08:51:15 <chessguy> is this #haskell or #lisp?
08:51:16 <greenrd> but I'm actually interested in parsing and pretty printing Haskell code with all ghc extensions enabled
08:51:19 <greenrd> hehe
08:51:27 <sorear> syntaxfree: don't you just love languages where funcall is explicit? :)
08:51:33 <syntaxfree> guess what (dup #'+ (g x x)) yields?
08:51:42 <syntaxfree> sorear: I prefer the scheme way, I think.
08:51:52 <emu> (setq x (+ y x)) is pointless (sorry)
08:52:02 <glguy> incf?
08:52:03 <emu> take it to #lisp
08:52:10 <chessguy> yeah, anyway
08:52:12 <joelr1> int-e: doesn't work
08:52:19 <syntaxfree> I'm just bitching about "no lazy evaluation".
08:52:28 <syntaxfree> It's meant for haskellers to feel all smug and superior.
08:52:44 <emu> bitch about the lack in scheme
08:52:55 <emu> CLers love their side-effects
08:53:19 <sjanssen> most Haskell features are meant to make us feel smug and superior
08:53:33 <joelr1> int-e: Expected type: Either Integer Integer
08:53:34 <greenrd> hehe
08:53:37 <chessguy> that's gotta be even weirder than african tribal people who stick bones through their noses
08:53:52 * glguy wouldn't mind learning a lisp dialect that didn't have crappy naming conventions
08:54:10 <sebell> glguy: What's wrong with Scheme?
08:54:14 <emu> hey dontcha love nthcdr or rplacd
08:54:36 <syntaxfree> I thought CLers loved their macros.
08:54:43 <sorear> emu: "If I were to do it again?  I would spell creat with an e."
08:54:43 <emu> that too
08:54:49 <emu> hehe
08:54:54 <syntaxfree> In the end, it strikes me that I'm losing out by knowing just one programming language.
08:54:56 <joelr1> i feel particularly stupid today
08:55:11 <mauke> yeah, a common function like rplacd needs a short name, while a seldom used low-level function like multiple-value-bind ... er
08:55:17 <syntaxfree> If I'm going for a mistress, I might as well choose  Lisp instead of Cobol or something.
08:55:18 * sorear has done memcpy(dst, dst, sizeof src) in haskell
08:55:32 <joelr1> mind you, i wrote a fully-functioning translator from one language to another in a month, while learning ocaml
08:55:39 <joelr1> what does that say about haskell?!
08:55:43 <int-e> joelr1: what is the type of naturalOrFloat?
08:55:48 <emu> mauke: except no one uses rplacd anymore =)
08:55:53 <sorear> :t Text.ParserCombinators.Parsec.Token.naturalOrFloat
08:55:54 <joelr1> int-e: one sec
08:55:55 <hpaste>  DIARULE annotated "(no title)" with "NEW YORK" at http://hpaste.org/1109#a4
08:55:56 <lambdabot> forall st. Text.ParserCombinators.Parsec.Token.TokenParser st -> Text.ParserCombinators.Parsec.Char.CharParser st (Either Integer Double)
08:56:00 <emu> it mostly exists for the purposes of dredging up funny names
08:56:01 <sorear> int-e: ^^
08:56:04 <syntaxfree> learning a ML would really be cheating.
08:56:19 <mauke> rplaca, cdadr, ...
08:56:25 <syntaxfree> why would I learn another functional typeful language? What's wrong with the one I'd have? That'd be vicious thrill-seeking.
08:56:30 <syntaxfree> Oh, c'mon. I love cadaddr.
08:56:34 <hpaste>  joelr1 annotated "simple parser not working" with "not working" at http://hpaste.org/1265#a5
08:56:42 <joelr1> there
08:56:51 <sorear> syntaxfree: they only go up to 4, for no good reason :)
08:56:53 <emu> syntaxfree: actually, only up to 3 (a|d) are defined
08:57:06 <emu> in scheme it is special cased for any number
08:57:23 <mauke> what?
08:57:26 <sorear> Oh.  ISTR getting that 4 from r5rs.
08:57:28 <mauke> I don't want to learn scheme anymore :(
08:57:35 <sjanssen> joelr1: what is the type of naturalOrFloat?
08:57:39 <sorear> :t Text.ParserCombinators.Parsec.Token.naturalOrFloat
08:57:40 <cjeris> emu: scheme has an infinite number of symbols bound in the initial environment???
08:57:42 <lambdabot> forall st. Text.ParserCombinators.Parsec.Token.TokenParser st -> Text.ParserCombinators.Parsec.Char.CharParser st (Either Integer Double)
08:57:43 <sorear> sjanssen: ^^
08:57:56 <joelr1> i dig a fair bit of lisp programming, on two projects. ran away from lisp afterwards.
08:58:01 <joelr1> no, make that 3 projects
08:58:02 <int-e> joelr1: I think you want  either (Int . (sign *)) (Num . (fromIntegral sign *)) num
08:58:02 <emu> i was pretty sure it was scheme. maybe just mzscheme.  but scheme doesnt have symbols like lisp.
08:58:03 <cjeris> sorear: i think it's 4 in Common Lisp.
08:58:10 <joelr1> that's excluding those of my own
08:58:15 <sjanssen> @hoogle lexeme
08:58:16 <lambdabot> Text.ParserCombinators.Parsec.Token.lexeme :: TokenParser st -> CharParser st a -> CharParser st a
08:58:16 <lambdabot> Text.Read.Lexeme :: data Lexeme
08:58:22 <sjanssen> @hoogle sign
08:58:23 <lambdabot> Prelude.significand :: RealFloat a => a -> a
08:58:23 <lambdabot> Prelude.signum :: Num a => a -> a
08:58:23 <lambdabot> Control.Concurrent.QSem.signalQSem :: QSem -> IO ()
08:58:34 <joelr1> int-e: trying
08:58:35 <int-e> sjanssen: sign is defined in the paste
08:58:37 <sorear> int-e: i had intended for him to use (fromInteger sign *) in the Num case
08:58:40 <mauke> hmm, I should write an Acme::CADR
08:58:40 <emu> my job is work in CL.  but anyway, i have to run.
08:58:41 <sebell> emu: What do you mean, doesn't have symbols like CL?
08:58:45 <quicksilver> XLISP had cadadrs up to 7, if I'm not mistaken
08:58:45 <int-e> sorear: me too
08:58:49 <hpaste>  sjanssen annotated "simple parser not working" with "should be fixed" at http://hpaste.org/1265#a6
08:58:55 <joelr1> finally! the magic moment
08:58:57 <int-e> sorear: well, fromIntegral but that's a small difference :)
08:59:04 <joelr1> int-e and sjanssen win
08:59:08 <dhart> How does one combine Monads togther?
08:59:24 <joelr1> that's one ugly little parser, though
08:59:26 <joelr1> dammit
08:59:31 <joelr1> lets see if it works now
08:59:33 <sorear> dhart: you can't
08:59:38 <syntaxfree> with monad combinators! \o/
08:59:56 <sorear> dhart: values of a monad can be combined with >>=, and functions derived from it like replicateM
08:59:57 <dhart> sorear: I thought it was possible? Monad combinators?
09:00:24 <Cale> dhart: By combining monads, you do mean the types, right?
09:00:51 <Cale> There's a technique which is commonly used called monad transformers to build up monads from pieces.
09:00:55 <hpaste>  joelr1 annotated "simple parser not working" with "yay! i can move on now!" at http://hpaste.org/1265#a7
09:00:58 <syntaxfree> I'm joking about monad combinators.
09:01:00 <syntaxfree> sorry.
09:01:01 <joelr1> thank you folks
09:01:03 <dhart> Let me introduce the simple example I am trying to implement, to make things clearer
09:01:07 <dhart> <dhart> class Renderable a where
09:01:07 <dhart> <dhart> 	render :: a -> IO ()
09:01:18 <Cale> (But you can't automatically construct a monad transformer from a monad.)
09:01:38 <dhart> I want to add a "Reader RenderParams" and a "State GameState"
09:01:44 <Cale> (I might not be around long, I haven't had any sleep)
09:02:18 <sorear> Oh, then just use ReaderT RenderParams (State GameState) as your monad
09:02:32 <sorear> the order matters in general, but not in this case
09:02:33 <Cale> dhart: You can:  newtype MyMonad a = MM (ReaderT RenderParams (StateT GameState IO) a)
09:02:43 <Cale>   deriving (Functor, Monad)
09:03:04 <dhart> Why "ReaderT" and not "Reader", same question for "State" and "StateT"
09:03:13 <joelr1> as for why i ran away from lisp... one project was a new one and i totally hated my boss's technique since he wrote lisp c-style. the next one was ITA and just grokking the code was difficult. you couldn't just run a bunch of unit tests to see what breaks. HUGE codebase. then, i joined another project and had to refactor. again, impossible to change and see what breaks, no unit tests and dynamic typing. argh!
09:03:17 <sorear> @kind ReaderT
09:03:20 <sorear> @kind Reader
09:03:20 <lambdabot> * -> (* -> *) -> * -> *
09:03:21 <Cale> Because they're transforming the underlying monad.
09:03:23 <lambdabot> * -> * -> *
09:03:25 <hpaste>  sjanssen annotated "simple parser not working" with "reduce the ugly" at http://hpaste.org/1265#a8
09:03:29 <joelr1> ocaml is fast and cool but haskell is wicked!
09:03:37 <Cale> ReaderT is a thing which adds reader-like functionality to another monad.
09:03:39 <sorear> as you se ReaderT takes an extra parameter
09:03:51 <dhart> right
09:03:55 <sorear> (kinds are to types as types are to values)
09:04:05 <joelr1> sjanssen: you cheated! you  just removed the parens :D
09:04:29 <joelr1> err, the curly braces, etc
09:04:48 <joelr1> how do i remember my own quote?
09:04:48 <sjanssen> yes, cuz they're ugly ;)
09:05:02 <joelr1> sjanssen: nah, i'm taking to that style nowadays
09:05:03 <Cale> Newtype-deriving is a simple Haskell extension which lets you derive any class for your newtype that the old type supports.
09:05:06 <glguy> {; } is good for one thing: one-liners for lambdabot
09:05:09 <Cale> (well, almost any class)
09:05:19 <sjanssen> joelr1: how come?
09:05:21 <sorear>  @remember joelr1 foo bar?
09:05:22 <glguy> (also for machine generated code)
09:05:27 <joelr1> oh, c'mon you guys
09:05:27 <glguy> but not for normal human use!
09:05:43 <joelr1> @remember joelr1 ocaml is fast and cool but haskell is wicked!
09:05:44 <lambdabot> Done.
09:05:46 <joelr1> there
09:06:08 * glguy reminds the insane masses not to quote themselves :-p
09:06:30 <Cale> dhart: Because the types get so long and complicated, and it's easy to abuse/get confused about the layering which occurs when building up monads with monad transformers, it's a good idea to newtype the whole stack and then write your own run function.
09:06:37 <joelr1> sjanssen: dunno why. i'll try reformatting some code to see. i have also taken to putting commas and semis before the statements
09:07:02 <sebell> joelr1: I agree, that's gross :)
09:07:11 <joelr1> Cale: what about putting the whole stack into a monad of its own?
09:07:25 <joelr1> sebell: do { ... } is gross? or putting commas in front?
09:07:25 <dhart> Cale and sorear: Thx for the help. I'll try to play around with the newtype you provided le Cale.
09:07:29 <sjanssen> joelr1: yes, that style is common in Haskell.  It makes it easier to rearrange the order of lines
09:07:40 <Cale> joelr1: Well, it is a monad already -- you could smash it out by hand, but there's not a whole lot of point to that usually.
09:08:11 <joelr1> Cale: i remember having a lot of trouble with lifting when i had ErrorT in the middle of the stack
09:08:21 <joelr1> Cale: so i guess my point would be to simplify the lifting?
09:08:47 <Cale> Well, what you should normally do is what I was about to describe...
09:09:07 <Cale> You can either derive MonadState GameState and MonadReader RenderParams, or you can provide your own interfaces to their functionality.
09:09:51 <sebell> joelr1: do { ; } -- especially if you're not binding
09:10:04 <joelr1> Cale: is there an example of doing so? could you add a tiny bit to the wiki maybe?
09:10:11 <Cale> Providing your own names for get and put, etc in your monad is generally a good idea, because the names can help the library user understand what it is that's being manipulated, and if the monad representation ever has to change, you only need to change the operations in one place.
09:10:27 <joelr1> sebell: well, yes, i agree that one-liners are cooler with >>=
09:10:50 <dhart> Cale: I got this error with the newtype you gave me: Can't make a derived instance of `Monad GameMonad'
09:10:50 <dhart>       (`Monad' is not a derivable class
09:11:06 <Cale> dhart: Which Haskell implementation are you using?
09:11:18 <Cale> -fglasgow-exts ?
09:11:23 <dhart> I'm compiling with GHC 6.6
09:11:45 <Cale> okay, then add {-# OPTIONS_GHC -fglasgow-exts #-} to the top of your file
09:11:53 <kmg> @pl \x -> (rem x 3 == 0) || (rem x 5 == 0)
09:11:54 <lambdabot> ap ((||) . (0 ==) . flip rem 3) ((0 ==) . flip rem 5)
09:11:57 <Cale> which should turn on newtype deriving
09:12:14 <dhart> It worked with that compile option, thx a lot.
09:12:36 <dhart> I like to understand what I did. What is the difference brought by that compile option?
09:12:55 <Cale> It turns on all the features of GHC beyond the Haskell 98 standard.
09:12:56 <kmg> @pl \x -> x <= 10^6
09:12:56 <lambdabot> (<= 10 ^ 6)
09:13:07 <Cale> Well, all the non-dangerous ones, anyway.
09:13:24 <dhart> I didn't know that newtype could not derive in H98
09:13:40 <Cale> It can derive only the usual things like Read and Show in H98.
09:13:47 <kmg> @pl \x -> rem x 2 == 0
09:13:48 <lambdabot> (0 ==) . flip rem 2
09:13:54 <joelr1> sorear: my next step would be to derive a pretty printer
09:14:23 <joelr1> sorear: the inverse of the derived parser. just so that i could print the constructor name and then the args within parens and separated by comma
09:14:41 <kmg> @pl \y -> y*y
09:14:42 <lambdabot> join (*)
09:16:09 <dhart> Cale: I'm still confused as to what the run function is used for in Monads: is it for executing the list of actions? In that case, how would one define and implement a run method for my new monad?
09:16:29 <joelr1> sorear: i'm sure it's gona be a struggle but i really like working with derive so far. as opposed to dealing with naked TH
09:17:40 <Cale> dhart: Well, when you're working with monadic values, you think of those as abstract computations waiting to be run. They often need something extra -- like an initial state or environment, in order to begin working.
09:18:28 <Cale> (We know that internally, State and Reader are implemented as ordinary functions, but that's an implementation detail)
09:19:22 <Cale> runState, given a State computation, and an initial state, runs the computation using the initial state, and gives a resulting value together with the final state.
09:19:59 <dhart> I know I have to give my custom monad the starting ReaderT state (RenderParams) and a starting StateT state (GameState), and that it should return the finale GameState + some extra computation values
09:20:46 <dhart> runGameMonad :: r -> s -> (s',a) -- but I think I'm missing something there
09:20:53 <sorear> @tell ndm [Apr 5 16:14 UTC 2007] <joelr1> sorear: I'm sure it's gonna be a struggle but I really like working with derive so far; esp. as opposed to dealing with naked TH.
09:20:54 <lambdabot> Consider it noted.
09:21:05 <Cale> Right, so runMyMonad :: MyMonad a -> RenderParms -> GameState -> IO (a, GameState)
09:21:08 <Cale> perhaps
09:21:08 <sorear> he'll be pleased when he gets back :)
09:21:21 <joelr1> dhart: did you look at the code for ... what was that game's name? implemented using Yampa
09:21:25 <Cale> Note that we can't escape IO here.
09:21:29 <sorear> joelr1: frag
09:21:37 <joelr1> yep, frag
09:21:42 <joelr1> dhart: did you look at frag?
09:21:43 <Cale> So we'll actually be producing an IO action.
09:22:05 <joelr1> sorear: i'm about to save hundreds of lines of code
09:22:08 <joelr1> parsing code
09:22:13 <dhart> joelr1: I did look at frag but failed to compile it succesfully
09:22:34 <joelr1> dhart: ok, then you can see how they are doing state, etc
09:22:48 <dhart> Cale: it's a good thing we cant escape IO here as the function calling my render function expects an IO back
09:23:58 <Cale> (of course, you probably want to find a more creative name than MyMonad :)
09:24:17 <Cale> If you want more detail about how I think monad transformers are best used...
09:24:35 <Cale> http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
09:24:39 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
09:25:18 <Cale> I'm afraid I aimed that article a little higher than at the complete monad transformer beginner, but hopefully it's not too bad.
09:25:46 <chessguy> i was wondering when Cale would trot out that link :)
09:25:57 <sorear> is yi.org named after tuomov/dons/jyp's yi?
09:26:16 <Cale> chessguy: I've finally begun to package up the things where I've repeated myself over and over in the past :)
09:26:23 <chessguy> hehe
09:26:35 <dmwit> Does anybody have some suggested reading for Typeable?
09:26:48 <sorear> @google Typing dynamic typing
09:26:52 <lambdabot> http://www.cs.uu.nl/~arthurb/dynamic.html
09:26:52 <sorear> iirc
09:26:52 <lambdabot> Title: Typing Dynamic Typing
09:27:17 <dmwit> Awesome, thanks!
09:28:14 <dhart> Cale: I have pmed you if you dont mind.
09:28:18 <sorear> dmwit: no, that's not the write paper
09:28:24 <Cale> dhart: no you haven't
09:28:30 <sorear> dhart: check your sever messages
09:28:35 <Cale> dhart: You're probably not registered.
09:28:35 <sorear> <*dhart> Cale: I have pmed you if you dont mind.
09:28:44 <dhart> Cale: right
09:28:45 <sorear> the * means not-identified
09:28:51 <dhart> Cale: must not be registered
09:28:58 <dmwit> Hmmm... this paper seems to be about Dynamic, not Typeable.
09:29:04 <sorear> only registered users are allowed to send pms
09:29:13 <Cale> sorear: My client doesn't show that marker.
09:29:19 <glguy> what marker?
09:29:24 <sorear> dmwit: actually it's about neither, I pulled the wrong name
09:29:26 <dhart> ok, so this is my current runGameMonad implementation:
09:29:27 <dhart> runGameMonad :: GameMonad a -> RenderParms -> GameState -> IO (a, GameState)
09:29:27 <dhart> runGameMonad gm rp gs =
09:29:27 <dhart> 	let (a, newState) = runStateT gs in
09:29:27 <dhart> 	let b = runReaderT rp in
09:29:41 <dhart> but I'm really stuck due to all this Monadic layering.
09:29:50 <sorear> Cale: apparantly your client has to explicitly request it
09:29:59 <sorear> Cale: i'm using erc-capab-module
09:30:43 <Cale> runGameMonad (GM x) rp gs = runStateT gs (runReaderT rp x)
09:30:47 <sorear> dmwit: the first "Scrap your boilerplate" paper has a section on typeable
09:30:50 <Cale> I think that'll do it.
09:31:08 <sorear> @google scrap your bolrod
09:31:10 <lambdabot> http://tunes.org/~nef/logs/haskell/06.03.15
09:31:12 <Cale> er
09:31:14 <sorear> @google scrap your boilerplate
09:31:16 <lambdabot> http://www.cs.vu.nl/boilerplate/
09:31:16 <lambdabot> Title: Scrap your boilerplate ... in Haskell
09:31:19 <Cale> modulo bad parameter order
09:31:28 <Cale> er...
09:31:36 <Cale> never mind, I'm tired :)
09:31:42 <dhart> Cale: I'm baffled. I still have so much to learn about Haskell
09:31:47 <chessguy> bolrod?
09:31:51 <dhart> Cale: thx, I'll try it out
09:31:54 <Cale> runGameMonad (GM x) rp gs = runStateT (runReaderT x rp) gs
09:31:57 <Cale> I think
09:32:01 <Cale> @type runReaderT
09:32:04 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
09:32:07 <Cale> yes.
09:32:20 <Cale> GM is the newtype constructor for your newtype.
09:32:30 <dmwit> sorear: Thanks again.
09:32:44 <Cale> If you keep it within the module where you're defining your monad, and don'
09:32:48 <Cale> and don't export it
09:32:49 <sorear> Thu Mar  8 08:32:47 PST 2007  Ian Lynagh <igloo@earth.li>
09:32:49 <sorear>   * Build the libraries with cabal
09:32:56 <sorear> Igloo++ Igloo++ Igloo++
09:33:01 <sorear> fptools must die.
09:33:05 <sorear> @flush
09:33:12 <Cale> then you'll have control over which parts of the application can define new operations for your GameMonad
09:33:26 <Cale> You might want to derive MonadIO though
09:33:44 <Cale> Which will let you liftIO any IO action, making it a GameMonad action.
09:36:05 <dhart> why do you provide 2 arguments to runStateT?
09:36:07 <chessguy> ?hoogle lift
09:36:08 <lambdabot> Control.Monad.Trans.lift :: (MonadTrans t, Monad m) => m a -> t m a
09:36:08 <lambdabot> Text.ParserCombinators.ReadPrec.lift :: ReadP a -> ReadPrec a
09:36:08 <lambdabot> Language.Haskell.TH.Syntax.lift :: Lift t => t -> Q Exp
09:36:14 <Cale> dhart: because it takes two
09:36:18 <chessguy> @hoogle+
09:36:19 <lambdabot> Language.Haskell.TH.Syntax.Lift :: class Lift t
09:36:19 <lambdabot> Monad.liftM :: Monad a => (b -> c) -> a b -> a c
09:36:19 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
09:36:22 <Cale> dhart: the computation, and the initial state
09:36:23 <glguy> cool, now dhart has a ~ in front of his name for not being identified
09:36:30 <Cale> @type runStateT
09:36:32 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
09:36:37 <dhart> @hoogle runStateT
09:36:38 <lambdabot> Control.Monad.State.runStateT :: StateT s m a -> (s -> m (a, s))
09:36:39 <chessguy> ?where hoogle
09:36:40 <lambdabot> http://www.haskell.org/hoogle
09:36:52 <dmead_> > "hello channel"
09:36:53 <lambdabot>  "hello channel"
09:37:40 <dhart> It's weird, my hoogle says "runStateT :: (s -> m (a, s))", but the extra parameter probably comes from the fact the function is inside the monad definition
09:37:52 <sorear> yeah
09:37:58 <sorear> it's a record selector
09:38:02 <sorear> @src StateT
09:38:02 <lambdabot> Source not found. Maybe if you used more than just two fingers...
09:38:05 <sorear> @src State
09:38:06 <lambdabot> Source not found. Just what do you think you're doing Dave?
09:38:15 * sorear beats up @src
09:38:23 <dmwit> lambdabot, his name isn't Dave.
09:38:27 <chessguy> why is there a liftIO, but not, say, a liftState
09:38:38 <dmwit> :t liftIO
09:38:40 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
09:38:45 <Cale> dhart: hoogle suffers from some irritating bugs
09:38:51 <sorear> chessguy: you don't need it
09:38:56 <sorear> :t put
09:38:58 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
09:39:26 <Cale> dhart: You probably shouldn't trust it to give accurate type signatures for everything, use :t instead.
09:39:27 <chessguy> ...
09:39:28 <sorear> chessguy: mtl uses undecidable instances to automatically lift get/put into any monad stack containing a State or StateT
09:39:55 <sorear> it's IO that is broken, for needing liftIO
09:40:05 <sorear> we should have all IO ops auto-lift
09:40:18 <Cale> It doesn't *need* liftIO, it's just extremely convenient to have it.
09:40:32 <Cale> You could also do lift . lift . lift
09:40:42 <Cale> With as many lifts as needed.
09:41:05 <sorear> "io theMRSucks = liftIO theMRSucks" ftw
09:41:10 <dhart> Cale: thx for everything, I understand it much better now. I'm curious, now that the StateT monad is inside the ReaderT, how conveluted it will be to do "put" and "get" functions?
09:41:21 <sorear> value restriction probably sucks more though
09:41:37 <Cale> dhart: not at all, because there's an instance which makes them available "through" the ReaderT
09:42:20 <Cale> dhart: Though that's a good observation.
09:42:44 <Cale> Ordinarily, without that instance, you'd have to use lift in order to get at them.
09:43:06 <Cale> lift takes an action in an underlying monad, and gives the equivalent in the transformed monad.
09:43:14 <Cale> @type lift
09:43:17 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
09:43:37 <Cale> m a -> t m a
09:43:59 <Cale> @type lift get
09:44:02 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, MonadState a m) => t m a
09:44:18 <Cale> @type \x -> lift (put x)
09:44:21 <lambdabot> forall s (m :: * -> *) (t :: (* -> *) -> * -> *). (MonadTrans t, MonadState s m) => s -> t m ()
09:45:02 <sorear> No wonder darcs stopped...
09:45:14 * sorear wishes flow control was harder to accidentally use
09:45:16 <Cale> But that's unnecessary in this case, because there's a "lifting instance" for MonadState for any ReaderT over another MonadState instance.
09:45:35 <sorear> @src ReaderT get
09:45:35 <lambdabot> Source not found. That's something I cannot allow to happen.
09:45:38 <sorear> :(
09:46:01 <sioraiocht> @src fix
09:46:02 <lambdabot> fix f = let x = f x in x
09:46:11 <chessguy> Cale: i definitely agree with your comments in your article about the arbitrary existence of some lifting operations and not others being *very* confusing
09:48:21 <tsp> argh, everything's being a Meddelandef√§ltet today
09:49:06 <Cale> chessguy: Yes, that was one thing which made monad transformers a lot harder for me to figure out at first. Once I fully realised that was what was going on, things started making a whole lot more sense.
09:49:40 <Cale> Part of me would sort of prefer that those instances were left out.
09:49:44 <dhart> Cale: nice, I'll check it out first thing tomorow. Now I need to leave work ^^ thx for all the help
09:49:52 <sorear> @babel fr en Meddelandef√§lt
09:49:53 <lambdabot> Plugin `babel' failed with: IRCRaised Data.ByteString.last: empty ByteString
09:49:57 <sorear> :(
09:50:07 <Cale> dhart: quite welcome :)
09:50:11 <Cale> oop
09:50:12 <chessguy> Cale:  or maybe require an extra import at least
09:50:13 <tsp> it's swedish for something
09:50:20 <chessguy> sorear: that's not french
09:50:20 <Cale> chessguy: yes!
09:50:30 <Cale> import Control.Monad.LiftingInstances
09:50:35 <tsp> there's a Meddelandef√§ltet, and a program som k√∂rs
09:51:08 <sorear> tsp: Oh.  So I went through all the trouble of /whois, host, and whois(1) only to discover "Calgary, CA" isn't relevant?
09:51:09 <sorear> :)
09:51:29 <monochrom> They don't use French in Calgary.
09:51:40 * sorear has no clue where calgary is, but knows that the only non-english language spoken in any large part of CA is french
09:51:41 <tsp> sorear: heh, british columbia, but close enough
09:51:49 <tsp> I hate french
09:51:53 <tsp> mi parolas Esperanton
09:52:14 <monochrom> Western Canada is very English and also pro-US actually.
09:52:29 <chessguy> what a bunch of weirdos
09:52:35 <Cale> Boooo US.
09:52:50 <sorear> tsp: Calgary is from the snail-mail contact address for your ISP, it isn't specifically tagged as referring to you.
09:52:54 <tsp> heh, french can manges la merde francaise for all I'm concerned
09:52:56 <Cale> (I live in Ontario)
09:52:57 <joelr1> :t >>=
09:52:57 <[malte]> tsp, anka≈≠ vi? tamen mi dezirus pli bone paroli Haskelon
09:52:59 <lambdabot> parse error on input `>>='
09:53:17 <chessguy> :t (>>=)
09:53:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:53:22 <sebell> :t (>>=)
09:53:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:53:40 <joelr1> aha
09:53:43 <joelr1> :t (>>)
09:53:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
09:53:56 <tsp> [malte]: mi lernas esperanton :) Cxu vi parolas bona haskelon?
09:53:58 <chessguy> @hoogle m a -> (a -> b)
09:53:59 <lambdabot> No matches, try a more general search
09:54:13 <tsp> I seriously need an utf-8 client
09:54:21 <[malte]> tsp, ni da≈≠rigu en #esperanto
09:54:32 <chessguy> @hoogle (a -> b) -> m a
09:54:33 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
09:54:34 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
09:54:34 <lambdabot> Control.Monad.Error.catchError :: MonadError e m => m a -> (e -> m a) -> m a
09:54:43 <chessguy> @hoogle (a -> b) -> m a -> m b
09:54:44 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
09:54:44 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
09:54:44 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
09:57:36 <chessguy> ?where ndm
09:57:37 <lambdabot> http://www.cs.york.ac.uk/~ndm/
09:58:14 <sorear> neil d. mitchell, phd student, yhc hacker, #haskeller
09:58:40 <daniel_larsson> "meddelandef√§lt" = message field
09:58:41 <daniel_larsson> "Programmet som k√∂rs" = The program that's running
09:58:45 <sorear> gone for a week
09:59:08 <chessguy> yeah, i was actually looking for his homepage
09:59:27 <daniel_larsson> tsp: above, if you're still confused :)
09:59:45 <ozzilee> Can someone help me with some really newbie questions? First, how do I get out of GHCi?
10:00:01 <Igloo> :q
10:01:32 <Cale> Or ctrl-c
10:01:34 <chessguy> ozzilee: many commands to ghci involve a colon, followed by a letter, as just demonstrated
10:01:36 <sorear> Igloo: when I pulled your most recent 4 patches, darcs died with an internal consistency error
10:01:42 <sorear> Cale: only on windows
10:01:48 <sorear> :?
10:01:49 <Cale> sorear: huh?
10:02:01 <Cale> sorear: ctrl-c works for me on ubuntu
10:02:17 <Cale> er...
10:02:20 <daniel_larsson> Cale: not on my ubuntu. Ctrl-D works fine though
10:02:22 <Cale> sorry, ctrl-d
10:02:26 <Cale> yeah
10:02:27 <ozzilee> ctrl-c doesn't work on os x either
10:02:28 <sorear> Cale: on windows ghci dies messily on ctrl-c, on (Debian sid) it stops computation, displays "Interrupted", adn returns to the repl
10:02:43 <ozzilee> crtl-d does though, thanks
10:02:47 <glguy> : reloads the current file
10:03:02 <sorear> ozzilee: type :? <ENTER>
10:03:04 * Cale wonders how long he's been "awake"
10:03:09 <sorear> read what it says
10:04:10 <ozzilee> sorear: thanks
10:04:10 <Cale> Hmm, 23 hours.
10:04:18 <joelr1> can this be made shorter?
10:04:20 <joelr1> do { x <- foo; y <- bar; return $ N x y }
10:04:32 <joelr1> :t liftM2
10:04:34 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
10:04:34 <Cale> joelr1: liftM2 N foo bar
10:04:40 <joelr1> argh
10:04:46 <joelr1> i'm an idiot. thanks cale
10:06:12 <narain> :t do {x <- foo; y <- bar; return $ N x y}
10:06:14 <lambdabot> Not in scope: `foo'
10:06:15 <lambdabot>  
10:06:15 <lambdabot> <interactive>:1:19: Not in scope: `bar'
10:06:33 <narain> ignore that
10:07:53 <ozzilee> Ok, I can declare a function "foo" with "let foo x = x + 1", is this correct?
10:07:59 <chessguy> :t do {?x <- ?foo; ?y <- ?bar; return $ ?N ?x ?y}
10:08:02 <lambdabot> Parse error in pattern
10:08:15 <narain> ozzilee: yes
10:08:32 <chessguy> > let foo x = x + 1 in foo 1
10:08:34 <lambdabot>  2
10:08:36 <joelr1> how abou tthis one?
10:08:39 <joelr1> foo = option Nothing $ do { reserved "xx"; strExpr >>= return . Just }
10:08:40 <narain> :t do {x <- ?foo; y <- ?bar; return $ ?N x y}
10:08:43 <lambdabot> parse error on input `?'
10:08:48 <joelr1> even shorter without sacrificing clarity?
10:09:49 <narain> :t ?x + ?y
10:09:52 <lambdabot> forall a. (?x::a, ?y::a, Num a) => a
10:10:22 <chessguy> :t do {return ?x}
10:10:25 <lambdabot> forall t (t1 :: * -> *). (?x::t, Monad t1) => t1 t
10:11:11 <sorear> foo = option Nothing $ reserved "xx" >> fmap Just strExpr
10:11:38 <narain> ?t option
10:11:39 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
10:11:43 <narain> :t option
10:11:46 <lambdabot> Not in scope: `option'
10:12:13 <sorear> it is in parsec
10:12:24 <narain> oh, ok
10:13:11 <sorear> OR, if you are willing to use a recent addition (maybe just in trac, but I think it's in darcs too)
10:13:23 <sorear> foo = optionMaybe $ reserved "xx" >> strExpr
10:17:38 <joelr1> sorear: hmm
10:18:05 <joelr1> sorear: @#@#% of course! we are in the maybe monad!!!
10:18:15 <sorear> no we are in parsec
10:18:31 <joelr1> sorear: in that particular parser
10:18:38 <sorear> haskell-mode doesn't properly highlight CPP :(
10:20:04 <dmwit> sorear: :set ft=cpp ;-)
10:20:14 <joelr1> sorear: what about this one? shares = do { e <- numExpr; reserved "xx"; return $ Qty e }
10:20:24 <sorear> dmwit: but if I do that it doesn't properly hl Haskell :)
10:20:52 <sorear> shares = fmap Qty numExpr *> reserved "xx"
10:21:07 <sorear> where x *> y = do { a <- x ; y ; return x}
10:21:13 <dmwit> sorear: I think the real problem here is that you have C++ and Haskell in the same buffer. =P
10:21:18 <joelr1> hmm
10:21:25 <sorear> dmwit: CPP, not C++
10:21:47 <dmwit> ?where cpp
10:21:48 <lambdabot> I know nothing about cpp.
10:21:48 <sorear> dmwit: I don't want to write all this unboxed primop mangling by hand :)
10:21:55 <sorear> dmwit: C PreProcessor
10:21:58 <sorear> ghc -cpp
10:21:58 <dmwit> o
10:22:10 <sorear> ?where hscpp
10:22:11 <lambdabot> I know nothing about hscpp.
10:22:19 <sorear> ?google hscpp
10:22:22 <lambdabot> http://urchin.earth.li/pipermail/debian-haskell/2004-September/000012.html
10:22:22 <lambdabot> Title: [Debian-haskell] Re: [Haskell] hscpp
10:22:30 <thedward> is it likely that there will be some sort of String type class in the future? To generalize over [Char] and Bytestring (and whatever else)?
10:22:33 <joelr1> sorear: thanks
10:23:02 <sorear> ... who here has heard of heat sink corner press pins?
10:23:21 <sorear> thedward: not likely at all
10:23:25 * sorear cynicises
10:23:39 <sorear> look at ross' collections
10:23:43 <sorear> @where collections
10:23:44 <lambdabot> I know nothing about collections.
10:24:21 <glguy> Foldable and Traversable generalize of some of that stuff though
10:24:42 <thedward> well, I am mainly wondering if there is some reason it would be a bad idea.
10:24:59 <glguy> thedward: what function would it have?
10:25:46 <sorear> @where+ hscpp It's called cpphs, dimwit!
10:25:47 <lambdabot> Done.
10:25:53 <sorear> @where cpphs
10:25:54 <lambdabot> http://www.cs.york.ac.uk/fp/cpphs/
10:25:57 <thedward> glguy: to make it easier to write code that operates on any type of String?
10:26:06 <dmwit> haha
10:26:11 <dmwit> ?where hscpp
10:26:11 <lambdabot> It's called cpphs, dimwit!
10:26:14 <dmwit> =)
10:26:58 <glguy> thedward: ok... so I'll clarify: what function*s* would it have?
10:27:05 <sorear> also http://haskell.org/cpphs/
10:27:06 <lambdabot> Title: cpphs
10:28:04 <thedward> glguy: hmm. well all the ones that come immediately to mind are list functions; maybe it should be a List type class :)
10:28:17 <glguy> thedward: like Traversable?
10:28:21 <sjanssen> thedward: I've hacked up a little 'Stringable' class before
10:28:38 <thedward> ooh. Traversable, I've been meaning to read up on that.
10:28:38 <sorear> thedward: ross paterson's collections probably do what you want
10:28:51 <Debolaz> Which book is the defacto guide to Haskell?
10:28:57 * Debolaz is on a shopping spree.
10:29:12 <sjanssen> it'd be a nice thing to have, especially with the half a dozen string representations around
10:29:15 <thedward> well, what I actually want is to write some code that with either Strings or Bytestrings
10:29:22 <sjanssen> sorear: I think you mean jyp's collections package
10:29:30 <sjanssen> there is also Edison
10:29:56 <sebell> thedward: You could always just write your code with a qualified module name
10:30:12 <sjanssen> thedward: feel free to yank http://darcs.haskell.org/SoC/fps-soc/Data/Stringable.hs
10:30:51 <sorear> we NED properly overloaded basic ops, like ++
10:31:20 <sjanssen> emphasized typos are especially humorous
10:31:33 <glguy> (.) = fmap  (++) = mappend ? :)
10:31:35 <thedward> sjanssen: that is exactly the sort of thing I want. Thanks. :)
10:31:43 <sorear> glguy: yah
10:32:07 <narain> :t mappend
10:32:10 <lambdabot> forall a. (Monoid a) => a -> a -> a
10:32:25 <narain> Mon*oid*? eep
10:32:37 <sjanssen> narain: they're much simpler than Monads
10:32:40 <sorear> it's elementary abstract algebra!
10:32:42 <sorear> !!
10:32:46 <opqdonut> yeh
10:32:47 <sorear> @src Monoid
10:32:48 <lambdabot> class Monoid a where
10:32:48 <lambdabot>     mempty  :: a
10:32:48 <lambdabot>     mappend :: a -> a -> a
10:32:48 <lambdabot>     mconcat :: [a] -> a
10:32:53 <opqdonut> ?instances Monoid
10:32:53 <glguy> monoids have an associative operation and an identity
10:32:55 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
10:33:18 <opqdonut> (++) for [] i'd guess?
10:33:20 <narain> that's it? haha, that's cute
10:33:28 <sorear> opqdonut: yes
10:33:28 <opqdonut> and . for (a->b)?
10:33:37 <sorear> opqdonut: no, liftM2 mappend
10:33:42 <narain> > mappend (1,2) (3,4)
10:33:42 <sorear> @src (->) mappend
10:33:43 <lambdabot>  Add a type signature
10:33:43 <lambdabot> Source not found. That's something I cannot allow to happen.
10:33:50 <glguy> > Sum 1 `mappend` Sum 10
10:33:51 <lambdabot>  Sum {getSum = 11}
10:34:14 <sorear> > mappend ("foo"++) ("bar"++) "baz"  -- silently different in 6.6 and 6.4!
10:34:15 <lambdabot>  "foobazbarbaz"
10:34:19 <sjanssen> > mappend (Sum 1, Product 2) (Sum 3, Product 4)
10:34:20 <narain> :t mappend (?a,?b) (?c,?d)
10:34:20 <lambdabot>  (Sum {getSum = 4},Product {getProduct = 8})
10:34:23 <lambdabot> forall t t1. (?a::t, ?b::t1, ?c::t, ?d::t1, Monoid (t, t1)) => (t, t1)
10:34:27 <sorear> 6.4 saz: "foobarbaz"
10:34:31 <glguy> > (Product 3, Sum 3) `mappend` (Product 2, Sum 2)
10:34:33 <lambdabot>  (Product {getProduct = 6},Sum {getSum = 5})
10:34:40 <glguy> oh, someone already did that :)
10:34:52 <narain> ohh
10:35:10 <narain> fun
10:35:19 <glguy> > mempty :: Sum Int
10:35:21 <lambdabot>  Sum {getSum = 0}
10:35:26 <sjanssen> narain: there are several monoids with the numbers, so we have newtype wrappers to choose them
10:35:58 <narain> sjanssen: that makes sense
10:36:13 <narain> > mempty :: All
10:36:14 <lambdabot>  All {getAll = True}
10:36:31 <narain> just checking
10:36:55 <sjanssen> to see monoids used to great effect, see the fingertree paper by Hinze and Paterson
10:37:06 <narain> wait, () is a monoid? what's mappend for ()? const?
10:37:21 <narain> > mappend () ()
10:37:23 <lambdabot>  ()
10:37:26 <glguy> > () `mappend` undefined
10:37:28 <lambdabot>  ()
10:37:39 <glguy> > undefined `mappend` ()
10:37:41 <lambdabot>  ()
10:37:47 <glguy> mappend _ _ = ()
10:38:20 <narain> now that's just silly
10:38:31 <sorear> The Ordering instance is very useful.
10:38:50 <opqdonut> > [()..]
10:38:52 <lambdabot>  [()]
10:38:54 <opqdonut> :D
10:38:57 <opqdonut> excellent
10:39:03 <glguy> > liftM2 mappend [LT ..] [LT ..]
10:39:03 <sjanssen> yes, compare on lists is something like:
10:39:05 <lambdabot>  [LT,LT,LT,LT,EQ,GT,GT,GT,GT]
10:39:32 <sjanssen> > mconcat (zipWith compare "stuff" "stuff2")
10:39:33 <lambdabot>  EQ
10:39:36 <sjanssen> bah
10:39:43 <sorear> @scheck \a b c d -> ((a `compare` b) `mappend` (c `compare` d)) == ((a,b) `compare` (c,d))  :: Bool -> Bool -> Bool -> Bool -> Bool
10:39:45 <lambdabot> Couldn't match expected type `Bool -> Bool -> Bool -> Bool -> Bool'
10:39:46 <sjanssen> close
10:39:49 <glguy> > liftM2 (\x y -> (x,y,mappend x y)) [LT ..] [LT ..]
10:39:51 <lambdabot>  [(LT,LT,LT),(LT,EQ,LT),(LT,GT,LT),(EQ,LT,LT),(EQ,EQ,EQ),(EQ,GT,GT),(GT,LT,GT...
10:39:54 <sorear> @scheck (\a b c d -> ((a `compare` b) `mappend` (c `compare` d)) == ((a,b) `compare` (c,d)))  :: Bool -> Bool -> Bool -> Bool -> Bool
10:39:56 <lambdabot>   Failed test no. 3. Test values follow.: True, True, False, True
10:40:01 <narain> ?src Ordering
10:40:02 <lambdabot> data Ordering = LT | EQ | GT
10:40:11 <sorear> @scheck (\a b c d -> ((a `compare` b) `mappend` (c `compare` d)) == ((a,c) `compare` (b,d)))  :: Bool -> Bool -> Bool -> Bool -> Bool
10:40:13 <lambdabot>   Completed 16 test(s) without failure.
10:40:30 <sorear> @src (,) compare
10:40:31 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
10:40:42 <narain> ?src Ordering compare
10:40:43 <lambdabot> Source not found. Do you think like you type?
10:40:46 <narain> oh wait
10:40:52 <narain> ?src Ordering mappend
10:40:53 <lambdabot> Source not found. You type like i drive.
10:41:03 <narain> i didn't come here to be insulted
10:41:09 <glguy> qq
10:41:40 <dmwit> How does lambdabot drive?
10:41:45 <sorear> glguy: how dare you!
10:41:52 <sorear> :)
10:42:00 <glguy> umm... lol? ;)
10:42:17 <sorear> narain: patch it
10:42:41 <glguy> and if you think "sure, that's a good idea", then fix ?vixen and ?let first
10:42:49 <glguy> and then bother changing the error messages
10:43:03 <dmwit> What's wrong with ?vixen?
10:43:05 <glguy> afterward
10:43:13 <glguy> ?vixen didn't used to say this:
10:43:13 <lambdabot> <undefined>
10:43:25 <narain> ?vixen
10:43:26 <lambdabot> <undefined>
10:43:27 <dmwit> I thought dons just disabled it for a while.
10:43:27 <narain> ?vixen
10:43:27 <sjanssen> I think we're waiting on a fix for the regex libraries for let
10:43:28 <lambdabot> <undefined>
10:43:31 <narain> ?vixen
10:43:32 <lambdabot> <undefined>
10:43:38 <narain> take that you foul mouthed bot
10:43:41 <glguy> or fix this:
10:43:48 <glguy> ?type mapM
10:43:50 <lambdabot>     Ambiguous occurrence `mapM'
10:43:51 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
10:43:56 <sorear> glguy: don't discourage fixes
10:44:04 <sjanssen> glguy: you know how to use darcs send
10:44:29 <glguy> sjanssen: I'm only arguing that there are much more important things to worry about than sudo insults
10:44:30 <narain> not like i know nearly enough to fix any bugs in lambdabot
10:44:42 <sorear> glguy: also, if narain removes the insults, @let will be AUTOMATICALLY fixed
10:44:53 <glguy> ?
10:45:01 <sorear> since @let is fixed in darcs but dons hasn't bothered to recompile
10:45:05 <glguy> ahh
10:45:20 <glguy> but if the insults are fixed, dons will be hot to recompile?
10:45:24 <sjanssen> narain: you'd be surprised.  lambdabot is a good project to cut your teeth on
10:45:25 <glguy> "fixed"
10:45:41 <sjanssen> bug dons to recompile in 24 hours or so, after the ICFP deadline
10:45:54 <narain> im already cutting my teeth on something else
10:45:57 <sorear> when are ICFP papers published?
10:46:12 * sorear is still managing to avoid hacking ghc
10:46:21 <sjanssen> probably at ICFP, August or so?
10:48:28 <narain> anyway i wouldn't want to lobotomize lambdabot's testy personality
10:53:53 <sebell> Hmmm. I can't seem to use runInteractiveCommand from GHCI
11:11:47 <sjanssen> @yow
11:11:48 <lambdabot> ... the MYSTERIANS are in here with my CORDUROY SOAP DISH!!
11:12:41 <opqdonut> @. elite yow
11:12:42 <lambdabot> WhY iS ev3Ry+hinG mAd3 of lY(r4 zp4nd3x?
11:14:15 <sjanssen> sebell: what happens?
11:16:01 <sebell>  sjanssen: I get EOF exception when trying to read from the output handle
11:18:09 <hpaste>  sjanssen pasted "ghci session with runInteractiveCommand" at http://hpaste.org/1266
11:20:58 <sjanssen> sebell: do simple things like "ls" work?
11:22:13 <sebell> sjanssen: that seems to work for me
11:23:29 <sebell> sjanssen: the issue seems to be with my own function (which in turn uses unsafeInterleaveIO)
11:26:39 <sioraiocht> anyone know how to get haskell mode in emacs to use ghci instead of hugs? i fixed it once but i can't remember how and this is a new install
11:27:03 <sebell> (add-hook 'haskell-mode-hook 'turn-on-haskell-ghci)
11:27:35 <sorear> aslo look at the haskell interpreter command in customize
11:27:44 <freshhawk> is there a current best practice for avoiding thread starvation / memory issues when you have multiple producers and one consumer communication over a tchan?
11:28:06 <freshhawk> *communicating
11:28:08 <sioraiocht> sebell, sorear : tahnks
11:28:44 <sorear> yay, I finally got a chance to use Any
11:29:07 <sjanssen> @pl ssfold p f a0 xs = foldr (\x xs a -> if p a then a else xs (f a x)) id xs a0
11:29:09 <lambdabot> ssfold = (flip .) . flip flip id . ((foldr . (const .)) .) . (. ((ap id .) . flip)) . (.) . ap . (if' =<<)
11:29:32 <mauke> @. pl . unpl pl ssfold p f a0 xs = foldr (\x xs a -> if p a then a else xs (f a x)) id xs a0
11:29:35 <lambdabot> ssfold = (flip .) . flip flip id . ((foldr . (const .)) .) . (. flip (flip . (((.) . (>>=) . (id >>=)) .) . flip flip (return .) . (((.) . (>>=)) .) . flip) (return .)) . (.) . (>>=) . (if' =<<)
11:30:40 <narain> @. unpl pl ssfold p f a0 xs = foldr (\x xs a -> if p a then a else xs (f a x)) id xs a0
11:30:41 <lambdabot> ssfold aa bl b c = foldr (\ br _ -> (aa >>= if') >>= \ be -> ((\ o -> o) >>= \ ay -> (\ s -> bl s br) >>= \ ax -> return (ay ax)) >>= \ bd -> return (be bd)) (\ k -> k) c b
11:30:57 <sjanssen> hmm, lambdabot seems to be generating bad results here
11:31:26 <sjanssen> @pl ssfold p f a0 xs0 = foldr (\x xs a -> if p a then a else xs (f a x)) id xs0 a0
11:31:28 <lambdabot> ssfold = (flip .) . flip flip id . (foldr .) . (. ((flip (.) .) . flip)) . (.) . (.) . ap . (if' =<<)
11:31:32 <kpreid> pl or unpl?
11:31:38 <mauke> unpl is almost pure obfuscation
11:31:40 <sjanssen> kpreid: pl
11:31:57 <kpreid> both have flaws in their parsing, but I wrote unpl :)
11:33:22 <narain> does pl work by eliminating one argument at a time?
11:33:23 <sorear> kpreid: unfortunately you aren't doing enough type checking :) I want eta expansion and monad op inlining
11:33:40 <sioraiocht> is it possible to do parallel list comprehension?
11:33:51 <kpreid> sorear: so write it :-)
11:34:00 <narain> @pl \xs0 -> foldr (\x xs a -> if p a then a else xs (f a x)) id xs0 a0
11:34:01 <lambdabot> flip (foldr ((ap (if' =<< p) .) . flip (.) . flip f) id) a0
11:34:07 <sioraiocht> and by that i mean do the evaluation on each member of the list in parallel
11:34:07 <mauke> I think ghc supports it as an extension
11:34:13 <narain> @pl \a0 xs0 = foldr (\x xs a -> if p a then a else xs (f a x)) id xs0 a0
11:34:14 <lambdabot> (line 1, column 9):
11:34:14 <lambdabot> unexpected "="
11:34:14 <lambdabot> expecting pattern or "->"
11:34:21 <LeCamarade> Stuck with a problem. I need to iterate over data that I collect from an IO monad (hence can't get rid of the blemish). But I can't return that, because it would ruin my returns ... I don't know if I should just think harder, or it isnormal to meet such quirks (and think of a work-around). Do I just need some sleep? :D
11:34:21 <narain> @pl \a0 xs0 -> foldr (\x xs a -> if p a then a else xs (f a x)) id xs0 a0
11:34:23 <lambdabot> flip (foldr ((ap (if' =<< p) .) . flip (.) . flip f) id)
11:34:26 <sorear> narain: it is ordinary abstraction elimination, followed by the most sophisticated optimizer in the Haskell world.
11:34:40 <sorear> sioraiocht: Control.Parallel.Strategies.parList
11:34:49 <mauke> LeCamarade: I don't understand
11:35:01 <mauke> sorear: wtf? what's wrong with zipWith?
11:35:11 <LeCamarade> I am trying to get the filesystem as a tree.
11:35:14 <mnislaih> help. where is the combinator for onclick in the xhtml package ?
11:35:14 <sorear> <sioraiocht> and by that i mean do the evaluation on each member of the list in
11:35:14 <sorear>              parallel
11:35:29 <sorear> mauke: does zipWith do parallelism?
11:35:29 <sebell> LeCamarade: You stay in the IO Monad
11:35:39 <sioraiocht> sorear: thanks
11:35:50 <LeCamarade> mauke: Yeah.
11:35:58 <mauke> sorear: oh, right :( my interpretation was faulty
11:36:22 <LeCamarade> The problem is that I think I should be returning the next file/dir, yet that would require ... wait a second ...
11:36:41 <LeCamarade> mauke: Lemme first try what I thought of ...
11:37:01 <sorear> sioraiocht: confusingly, parallel list comprehension is also the name of an unrelated ghc extension
11:37:16 <sioraiocht> sorear: ah
11:38:36 <sebell> sjanssen: I added EOF checking to my hGetContentsTimeout, but now it doesn't behave as it does in the compiled program -- in fact, the compiled program never reached EOF before at all
11:40:57 <sjanssen> sebell: may I see the code?
11:43:49 <hpaste>  sebell pasted "hGetContentsTimeout" at http://hpaste.org/1267
11:45:09 <stepcut> haddock barfs on this line:     deriving (Monad, MonadIO, MonadFix, Functor, MonadReader TaskIOStyle), because of the MonadReader TaskIOStyle
11:45:15 <stepcut> what is the best work-around ?
11:45:33 <sjanssen> stepcut #ifndef HADDOCK
11:46:17 <procyon112> fix haddock?  *nudge-nudge-wink-wink*
11:46:41 <sjanssen> or perhaps a dummy instance guarded by #ifdef HADDOCK
11:47:20 <sjanssen> sebell: you should probably use waitProcess p to make sure you don't leave zombies
11:47:35 <stepcut> sjanssen: spiffy, thanks
11:47:49 <sioraiocht> sorear: so if Strategy is a -> Done, then how does parList get a value from a Strategy to build the list
11:48:03 <sorear> sioraiocht: ?
11:48:08 <sorear> type Done = ()
11:48:18 <sorear> it just represents a side effect
11:48:26 <sjanssen> @hoogle using
11:48:27 <lambdabot> Control.Parallel.Strategies.using :: a -> Strategy a -> a
11:48:29 <sorear> par :: Done -> Done -> Done  -- do it in parallel!
11:48:51 <sioraiocht> @t Control.Parallel.Strategies.parList
11:48:51 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
11:48:59 <sioraiocht> @type Control.Parallel.Strategies.parList
11:49:02 <lambdabot> forall a. Strategy a -> [a] -> Done
11:49:18 <sioraiocht> ohh, n/m i get it, now
11:51:42 <stepcut> hrm, now haddocks dies on: #ifndef HADDOCK
11:51:44 <stepcut> :-l
11:53:37 <sorear> stepcut: is your program a program?
11:54:14 <stepcut> ?? it's a module in a library...
11:54:21 <sorear> http://hackage.haskell.org/trac/hackage/ticket/102
11:54:22 <lambdabot> Title: #102 (building haddock for executables wont CPP) - Hackage - Trac
11:54:40 <sorear> haddock doesn't cpp, you need to have something else (like cabal) do it first
11:54:48 <sorear> or just upgrade to haddock.ghc
11:55:12 <stepcut> ok, I was justing running 'haddock ABIO.hs', but in practice, it is run by cabal
11:55:41 <sorear> haddock ABIO.hs wouldn't work anyway
11:55:51 <Saizan>  ?where derive
11:55:56 <sorear> you need to specify an output format and a output directory
11:55:56 <Saizan> ?where derive
11:55:57 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/derive
11:56:05 <sjanssen> sebell: does the program work differently if you compile with -threaded?
11:56:09 <sorear> derive is pouplar? what have I done :(
11:57:22 <Saizan> well i have to do that "derive a 'untyped' representation for my state type", and thought derive could help
12:02:40 <glguy> @temp
12:02:42 <lambdabot>   now 17.6∞, min 17.5∞, max 24.2∞, rain 0.0mm, wind 31km/h SW
12:04:16 <glguy> !say hello
12:04:16 <hpaste> hello
12:04:26 <sorear> !say hi?
12:04:49 <glguy> ?admin+ :n=user@ip68-7-248-101.sd.sd.cox.net
12:04:50 <lambdabot> Not enough privileges
12:04:56 <glguy> err
12:04:59 <glguy> !admin+ :n=user@ip68-7-248-101.sd.sd.cox.net
12:05:08 <emu> @temp where?
12:05:08 <lambdabot>   now 17.6∞, min 17.5∞, max 24.2∞, rain 0.0mm, wind 31km/h SW
12:05:12 <glguy> I forget if the leading : needed to be there
12:05:13 <Saizan> derive's cabal misses mtl in build-depends
12:05:46 <sorear> it shouldn't depend on mtl
12:06:11 <sorear> @admin + hpaste
12:06:22 <sorear> !msg lambdabot @msg #haskell Muahahaha?
12:06:36 <sorear> !say testing?
12:07:48 <Saizan> Data/Derive/Play.hs:import Control.Monad.State
12:07:59 <glguy> !admin+ n=user@ip68-7-248-101.sd.sd.cox.net
12:08:05 <sorear> !msg lambdabot @msg #haskell Muahahaha?
12:08:10 <Saizan> well maybe i've pulled a very recent patch
12:08:16 <sorear> !say hi?
12:08:19 * glguy goes to check the code
12:08:23 <glguy> did I remove !admin+ ??
12:08:42 <sjanssen> speaking of derive, aren't these blank lines in derive.cabal illegal?
12:08:53 <Igloo> Hmm, what's the flag to show which RULES are being applied?
12:09:00 <sorear> -ddump-simpl-stats
12:09:23 <sorear> sjanssen: I only wrote the .cabal, never tested it :)
12:09:28 <Igloo> Thanks
12:09:34 * Igloo wonders what -ddump-rules is meant to do
12:09:37 <glguy> !admin+ :sorear!n=user@ip68-7-248-101.sd.sd.cox.net
12:09:43 <glguy> sorear: that should do it
12:09:46 <glguy> i was forgetting the nick
12:09:51 <sorear> !msg lambdabot @msg #haskell Muahahaha?
12:09:55 <sorear> !say hi?
12:09:55 <hpaste> hi?
12:10:03 <glguy> > PRIVMSG lambdabot @msg #haskell Muahahaha?
12:10:03 <glguy> :sorear!n=user@ip68-7-248-101.sd.sd.cox.net PRIVMSG #haskell :!say hi?
12:10:04 <lambdabot>  Parse error
12:10:20 <glguy> lambdabot rejected the command, but hpaste tried making it
12:10:37 <glguy> !say @admin + glguy
12:10:37 <hpaste> @admin + glguy
12:10:37 <sorear> @admin + hpaste
12:10:53 <sorear> !say @msg #haskell Bwahaha!
12:10:53 <hpaste> @msg #haskell Bwahaha!
12:10:54 <lambdabot> Bwahaha!
12:10:58 <Igloo> sorear: Do you happen to know if you can print the source before and after the rules are applied?
12:11:00 <lambdabot> ?
12:11:38 <sorear> -ddump-simpl-iterations, -dverbose-core2core
12:11:43 <sorear> or so the wiki said
12:11:55 <sorear> @wiki GHC/Using_rules
12:11:56 <lambdabot> http://www.haskell.org/haskellwiki/GHC/Using_rules
12:13:03 <sjanssen> boo, derive isn't darcs sendable
12:13:28 <sorear> I've directly bood ndm twice.
12:13:44 <sorear> Just for that I'll say his email in cleartext:
12:13:49 <sorear> ndm@cs.york.ac.uk
12:14:00 <sorear> FTR he is out of communication for a week
12:14:08 <sorear> with intent to continue hacking derive
12:14:45 <sjanssen> he must be paranoid, he doesn't even include his email in darcs record messages
12:16:12 <sjanssen> anyway, I just fixed the .cabal and replaced fmap with liftM for 6.6 compatibility
12:16:45 <sjanssen> sorear: do you want the patches too?
12:16:49 <sorear> darcs send --to=ndm@cs.york.ac.uk
12:17:06 <sorear> sjanssen: no, I'm respecting his absense as if it were a lock
12:17:10 <sjanssen> yep, already sent to ndm
12:17:53 <Igloo> sorear: Thanks!
12:18:11 <joelr1> sorear: he took a week off to hack derive?
12:19:17 <sorear> he's also attending some kind of conference
12:19:29 <sorear> but the details are a bit fuzzy
12:21:38 <joelr1> sorear: what do you do for a living?
12:21:53 <joelr1> sjanssen: and what about you?
12:22:26 <pejo> sorear, wasn't it BTCS or something like that?
12:23:16 <sjanssen> joelr1: I'm a computer science undergrad
12:23:32 <joelr1> sjanssen: cool
12:24:26 <sebell> sjanssen: Yes, I see the same behavior with GHCI as -threaded
12:24:38 <sebell> (sorry for the late response)
12:24:41 <sorear> joelr1: I stay at home and act like a 16-year-old dependant?
12:25:04 <joelr1> sorear: :D
12:25:35 <joelr1> sorear: i stay at home too
12:25:51 <sjanssen> sebell: ghci uses the threaded RTS, so I think you've officially narrowed your problem
12:26:06 <sjanssen> sorear: just "act like"?
12:26:11 <sorear> yeah, but you probably don't get infinite free food, shelter, internet, and education :)
12:26:19 <sjanssen> infinite?
12:26:23 <sebell> sjanssen: Indeed.
12:26:23 <joelr1> sorear: infinite?
12:26:26 <glguy> sjanssen: in the verizon sense
12:26:34 <joelr1> 5Gb of food
12:26:35 <joelr1> hehe
12:26:35 <glguy> infinite for 5gig, which ever comes first
12:26:36 <sorear> in the Haskell sense
12:26:38 <sjanssen> glguy: 5 gigabytes of steak/month
12:26:56 <sorear> no, my supplies are infinite but lazily evaluated
12:27:12 <sorear> I only consume a finite amount in any given timeslot
12:27:30 <qwr> so you're just not forced a strict evaluation?
12:28:08 <sjanssen> sorear's refrigerator is just one big thunk
12:28:13 <joelr1> hehe
12:28:45 <glguy>  /set format_unidentified_nick Loser:$0
12:28:47 <glguy> oops
12:28:54 <glguy>  /set format_unidentified_nick Loser:$0
12:28:57 <glguy> err!
12:29:03 <glguy> damn spaces
12:29:14 <glguy> you'd think that when you press UP
12:29:17 <glguy> that it would fix that
12:29:41 <sjanssen> now we all know that glguy hates unregistered nicks
12:30:34 <joelr1> i think i just eliminated over 1000 lines of code thanks to sorear, maybe 1500
12:30:37 <glguy> hate is such a strong word
12:30:41 <joelr1> and that's not the end
12:30:55 <joelr1> i should be able to blow away 500-1000 more
12:30:56 <joelr1> he
12:30:56 <sorear> apr1 : 09:56:07 <ndm> oh, btw - i'm off to Oxford all next week, out of email contact
12:31:17 <sorear> BCTCS
12:31:29 <mauke> 0xf0rd
12:31:30 <sorear> http://www.cs.swan.ac.uk/BCTCS2006/
12:31:32 <lambdabot> Title: BCTCS 2006
12:31:45 * qwr is too lazy to register the damn nick. and there seem to be plenty of free nicks for backup. ;)
12:32:14 <glguy> 14:29 (*) Loser:qwr is too lazy to register the ... ;-)
12:32:29 <qwr> yeah :)
12:33:18 <sorear> * *qwr is too lazy to register the damn nick. and there seem to be plenty of free
12:33:18 <sorear>   nicks for backup. ;)
12:33:32 <sorear> you realize it would have taken less typing just to register?
12:33:44 <sorear>  /msg nickserv register <password>
12:35:03 <qwr> now, that i didn't have to figure out how, it was easy ;)
12:35:37 * glguy wonders where Loser:qwr went
12:36:02 <glguy>  /set format_unidentified_nick ~$0
12:36:05 <glguy> :(
12:36:14 <sjanssen> @slap glguy
12:36:15 <lambdabot> why on earth would I slap glguy
12:36:25 * glguy isn't actually intentionally sending this stuff to channel
12:36:42 <glguy> Time to drink some more coffee I guess
12:38:37 * glguy wonders why people would want to turn garbage pop music *up* when we aren't supposed to have audible music at all
12:38:57 <glguy> I wonder if he just doesn't know what he's listening to
12:39:10 <monochrom> in an office?
12:39:12 <glguy> yeah
12:39:38 * glguy is completely ready to start his new job in Portland
12:39:40 <monochrom> someone should let him know he should stop
12:40:12 <glguy> monochrom: I Don't want to open myself up to the possibility of a conversation with him
12:40:40 <procyon112> lol
12:41:13 <glguy> which I would consider worse than having to block out christina aguilara(?)
12:41:36 <astrolabe> You could try singing along
12:42:05 <monochrom> You could compete and play Carmina Burana.
12:42:39 <stepcut> hrm, for some reason ./Setup haddock, is running cphhs on ABIO.hs, but it never actually runs haddock on it :(
12:43:07 <stepcut> oh wait, hahaha
12:43:19 <stepcut> I'm just looking in the wrong output directory :)
12:44:56 <sjanssen> glguy: throw things at him
12:45:00 <sorear> glguy: How about explosives?
12:45:35 <monochrom> A power outage.
12:46:21 <sjanssen> one of those EMPs the movies always use?
12:46:22 <sorear> ghc -e 'cycle "\0\255"' > /dev/audio
12:46:29 <glguy> poweroutage woudl be great
12:46:35 <glguy> because I would get to go home earlier
12:46:36 <sjanssen> sorear++
12:46:53 <glguy> sorear: does that do more than static?
12:46:55 * sjanssen waits for @flush
12:47:04 <sorear> glguy: eeeeeeeeeeeeeee!
12:47:12 <glguy> ?help flush
12:47:13 <lambdabot> flush. flush state to disk
12:47:24 <sorear> glguy: maximum amplitude, maximum frequency square wave
12:47:32 * monochrom tries
12:47:34 <glguy> Oh, does sorear @flush after karma to ensure that it is saved?
12:47:36 <sorear> glguy: or silence if you aren't using 8-bit unsigned :)
12:47:39 <sorear> @flush
12:47:40 <sorear> yeah
12:47:43 <glguy> ?karma
12:47:43 <lambdabot> You have a karma of 50
12:47:48 <glguy> mine hasn't changed for a while
12:48:09 <sorear> My karma high watered at fourty after shapr rewarded my for yi synhl.
12:48:13 <glguy> everyone was excited about hpaste, but then I faded away
12:48:20 <sorear> Then I lost it all to the bot crash.
12:48:24 <glguy> ahh
12:48:27 <glguy> ?karma sorear
12:48:28 <lambdabot> sorear has a karma of 30
12:48:33 <sorear> glguy: hpaste is boring, you need new features
12:48:34 <glguy> The great bot crash of 2007?
12:48:40 <glguy> sorear: I agree
12:49:06 <SamB_XP> like nethack?
12:49:25 * glguy has been playing with Factor recently
12:49:34 <sorear> glguy: like ... type checking ... more channels ... multisyntax with autodetection ... an announce api ...
12:49:46 <glguy> announce api?
12:49:51 <sorear> you realize they are still using lisppaste over in #darcs?
12:50:02 <sorear> like connect and recieve a lazy [Announce]
12:50:12 <SamB_XP> interesting idea, sorear
12:50:31 <SamB_XP> why don't you go write an RFC for one of those?
12:50:49 * sorear would write hpaste-mode for emacs if it had a decent api
12:50:53 <sjanssen> type checking would be really nice IMO
12:51:06 <sorear> SamB_XP: you really think the ietf cares about pastebots?!
12:51:08 <glguy> I've never used the GHC API, what would that take?
12:51:17 <sjanssen> newbies always forget to state the error messages
12:51:20 <glguy> sorear: nope, they care about cash money
12:51:30 <SamB_XP> sorear: I was thinking something more along the lines of "lazy RSS"
12:51:50 <sorear> glguy: GHC API will probably segfault in no time, it's too big.  Do as lambdabot does and fork a subprocess.
12:52:14 <hpaste>  boowax annotated "Monad Issue" with "(no title)" at http://hpaste.org/1268#a1
12:52:22 <sorear> > array (0,maxBound::Int) [(1000000,'a')]  -- look, segfault is caught!
12:52:25 <lambdabot> Terminated
12:52:25 <boowax> Since you guys were helpful to me last time, I've come back for more! I'm having a problem getting something to compile, can any of you guys give me some insight as to how to fix it? http://hpaste.org/1268#a1
12:52:28 <sjanssen> GHC API also won't protect you from evil TH hacks
12:52:47 <sorear> filtering out {-# OPTION will :)
12:52:49 <monochrom> ghc -e 'map Char.chr $ Random.randomRs (0,255) $ Random.mkStdGen 42' > /dev/audio
12:53:15 <sorear> monochrom: THAT is static.
12:53:18 <SamB_XP> GHC API doesn't support -fno-th?
12:53:36 <monochrom> Yeah
12:53:40 <sorear> SamB_XP: -fno-th can be overriden with {-# OPTIONS -fth #-}
12:53:48 <sorear> so we need to filter as well
12:54:02 <SamB_XP> okay, so -fno-th-I-really-mean-it
12:54:04 <monochrom> Ha, I don't need map.
12:54:13 <sjanssen> or just run ghc with dropped privileges
12:54:24 <sorear> tuukkah: ping?
12:54:34 <sorear> I meant twanvl :)
12:54:39 <sorear> twanvl: ping?
12:54:45 <twanvl> sorear: pong
12:54:49 <monochrom> ghc -e 'Random.randomRs ('\0','\255') $ Random.mkStdGen 42' > /dev/audio
12:56:19 <xerox> ghc -e 'Control.Monad.Fix.fix (\xs -> 1 : 1 : zipWith (+) xs (tail xs))' > /dev/audio
12:56:41 <joelr1> requiring TH seems to make ghc want functions to be defined before use
12:56:42 <sorear> twanvl: My original plan had been to concentrate all the prettying logic in Peephole ... any particular reason you are doing the prettying in lK ?
12:57:01 <twanvl> No, I just didn't know that
12:57:04 <sorear> joelr1: yeah, that's why we have the derivations in separate modules
12:57:15 <joelr1> aha!
12:57:29 <twanvl> But why not do it immediatly?
12:58:01 <sorear> separation of concerns?
12:58:18 <sorear> smart constructors can only act as bottom-up traversals
12:58:28 <xerox> ghc -e 'cycle (replicate 1000 '\0' ++ replicate 1000 '\255')' > /dev/audio
12:58:29 <xerox> alarm
12:58:30 <sorear> the peephole can be context sensitive
12:59:48 <sorear> also, we really don't want special case code in derivations, because the goal of derive is to make adding derivations easier, and it helps if there is less code involved.
13:00:21 <boowax> any takers for helping me with this: http://hpaste.org/1268#a1 ? I'm new to Haskell so it may be a fairly simple fix
13:01:06 <Saizan> boowax: you are trying to compare two values which have different types, it seems
13:01:13 <chessguy> procyon112: ping?
13:02:30 <Saizan> your valTy is not a simple Type, but a Either ErrorTy Type, so you have to unpack it
13:02:45 <SamB_XP> Saizan: well, the paste is called "Monad issues"
13:02:46 <boowax> saizan: yes, that seems to be the case...the type in question is an Either ErrorTy Type and I just want to compare on Type....is there an easy way to extract it from the Either?
13:02:54 <SamB_XP> so remember to use monads in the solution ;-P
13:02:57 <joelr1> is there a way to resolve recursive module dependencies in haskell?
13:03:03 <joelr1> or with ghc to be precise
13:03:19 <SamB_XP> joelr1: you mean {-# SOURCE #-}?
13:03:20 <sjanssen> with pain, yes
13:03:27 <SamB_XP> and .hs-boot
13:03:36 <joelr1> i put my derived parsers in a separate module but just realized (ghc told me) that mod1 (non-derived) needs funs from mod2
13:03:48 <sjanssen> joelr1: it's better to eliminate the cyclic dependencies
13:03:56 <SamB_XP> yes, quite
13:04:04 <procyon112> sorear: I just had a weird realization
13:04:05 <joelr1> sjanssen: that would require moving huge chunks of code from one module to another
13:04:11 <joelr1> i can try ... i guess
13:04:17 <SamB_XP> well, you can try the other way first
13:04:24 <sorear> procyon112: cool, type theory ocks
13:04:34 <SamB_XP> but don't blame *me* if you somehow manage to crash GHC (if this somehow involves TH)
13:04:38 <joelr1> SamB_XP: which way? moving chunks is not gonna work, chunks are too huge
13:04:46 <procyon112> sorear: You know Turing's halting problem thought experiment proof?  Imagine a list of all possible computer programs.....
13:04:46 <joelr1> this does involve TH
13:04:59 <sorear> procyon112: yeah, semi-decidable
13:04:59 <procyon112> sorear: My code generates that list :)
13:05:01 <sjanssen> joelr1: there is no real limit to cut and paste
13:05:17 <sorear> joelr1: stop using _derive_print_instance
13:05:22 <SamB_XP> sorear: well, don't worry about it until GHC crashes okay?
13:05:28 <Saizan> boowax: you can pattern match on it, like how you do with ty, or use the function either, or reqrite that function in a MonadError fashion maybe
13:05:29 <joelr1> sorear: i'm not!
13:05:37 <joelr1> sorear: i just ghc --make
13:05:48 <sorear> joelr1: you just have a bunch of $( derive ... )'s rgith?
13:05:53 <joelr1> $( derive makeFunParser ''StrCall )
13:05:54 <joelr1> yea
13:06:01 <joelr1> in mod2 that's required by mod1
13:06:01 <xerox> ghc -e 'let tune = 42 in Monad.join $ map (\(t,s) -> replicate (t*10) s) (zip (Random.randomRs (0::Int,10) (Random.mkStdGen tune)) (Random.randomRs ('\0','\255') (Random.mkStdGen tune)))' > /dev/audio
13:06:03 <xerox> mewzik
13:06:17 <joelr1> i think i'm an idiot
13:06:29 <SamB_XP> procyon112: do you have a decision procedure that determines whether or not a given file is a computer program?
13:06:29 <sorear> so mod2 is a bunch of derives,and mod1 is the data types, and they are mutually recursive?
13:06:32 <procyon112> sorear: All my future career programming asignments are in that list... Now I just need an algorithm to map specifications to an index, and my entire career is lazily evaluated :)
13:06:43 <xerox> (t*100) is more audible, maybe.
13:06:49 <sorear> procyon112: beware of the exponential.
13:07:08 <sorear> what, people are having fun writing haskell audio programs?
13:07:09 <SamB_XP> procyon112: you'd be surprise how long it takes to generate some of those entries
13:07:23 <SamB_XP> also, isn't the index essentially the same thing as the entry?
13:07:39 <joelr1> i just need to reverse the require order
13:07:41 <sorear> my BF theorem prover can't prove S, it's just too complicated
13:07:49 <joelr1> and move a few little bits to the TH module
13:08:13 <stepcut> argh. So, I tried to use #ifdef __HADDOCK__, but now cpp is stripping out most of my file because it has the strings /* and later */
13:08:36 <procyon112> SamB_XP: Yeah... mapping spec to index is a substantially more difficult problem than generating a lazy list of all possible well-typed programs :)
13:08:56 <joelr1> no, does not work
13:09:55 <joelr1> sorear: as soon as i derive it wants stuff from ModuleA but it I keep everything in one module then i need to order the functions
13:10:23 <procyon112> SamB_XP: It works by generating all possible well-typed abstract syntax trees in a turing complete language.
13:10:30 <joelr1> and in at least one case i don't think i can order the functions
13:10:51 <sorear> joelr1: can you hpaste a small thing?
13:11:06 <joelr1> sorear: sure
13:11:10 <joelr1> what do you need?
13:11:21 <Gwern> has anyone else been using dmenu? am I just imagining it or does dmenu convert apostrophes to backticks?
13:11:24 <joelr1> @paste
13:11:25 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:11:39 <procyon112> SamB_XP: Using S,K and Y (ap, const and fix) as primitives, all possible programs can be expressed, so this just filters out the poorly typed ones and returns the valid ones in a lazy list.
13:12:17 <mauke> Gwern: you're imagining it :-)
13:12:26 <SamB_XP> procyon112: dude, that won't be able to fulful the requirements of most specs!
13:12:31 <chessguy> procyon112: so when are we going to be ready to integrate? i wanna play!
13:12:41 <hpaste>  joelr1 pasted "small thing" at http://hpaste.org/1269
13:12:48 <joelr1> sorear: there ^^^
13:12:57 <SamB_XP> people are always wanting the programs to read files or do something on the intarweb or something like that
13:13:00 <sjanssen> joelr1: if you're trying to build ghc 6.7 just because you want to use derive, I have patches for you
13:13:25 <sorear> procyon112: just pull the occurs check out, and eliminite Y, and optimize the type checker to (const True)
13:13:35 <joelr1> sjanssen: i thought i could use derive with 6.6. i'm doing that at the moment, actually. do you have patches for ghc 6.7? because it doesn't build for me :D
13:13:42 <joelr1> sjanssen: thanks, of course
13:13:46 <procyon112> SamB_XP: I can just add primitives to access those things.
13:13:57 <mauke> Gwern: it seems to use LEFT SINGLE QUOTATION MARK [‚Äò] and RIGHT SINGLE QUOTATION MARK [‚Äô], though
13:14:03 <SamB_XP> what about EGA graphics!
13:14:13 <joelr1> sjanssen: i patched derive this morning (someone complained about my 70 messages :D)
13:14:32 <sjanssen> joelr1: ah, did you send your fix to ndm?
13:14:34 <procyon112> chessguy: Next step is a well-typed crossover operator.... then I should be able to integrate.
13:14:34 <Gwern> mauke: weird. I wonder how I should fix that?
13:14:40 <joelr1> sjanssen: nope
13:14:50 <SamB_XP> hoarder of patches!
13:14:50 <joelr1> sjanssen: i thought it was a glitch in the matrix
13:14:50 <chessguy> procyon112: cool! any guess on an ETA?
13:15:09 <SamB_XP> procyon112: so you can use it to make pretty pictures?
13:15:10 <sjanssen> joelr1: was it the *same* cat?
13:15:14 <joelr1> i thought that surely sorear and ndm would have the stuff that builds
13:15:17 <sorear> joelr1: what's BoolCall, what is boolCall
13:15:18 <sorear> ?
13:15:27 <sjanssen> joelr1: anyway, I sent ndm a fix for that
13:15:32 <procyon112> chessguy: no firm estimate.. couple of days.  I might get lots of time to work on it this weekend, or I might get none at all.
13:15:40 <joelr1> sorear: BoolCall has a bunch of constructors for funs that return Bool (conceptually)
13:15:42 <joelr1> same for others
13:15:43 <sorear> joelr1: I don't usually bother to test except on <1 week old ghc:)
13:15:43 <chessguy> lol, ok
13:15:47 <procyon112> SamB_XP: I could... it's turing complete :)
13:15:50 <sorear> joelr1: boolCall?
13:15:53 <joelr1> boolCall is the parser, same for numCall, etc.
13:16:06 <SamB_XP> procyon112: I was referring to the term "integrate"
13:16:08 <sorear> hmm.  what do you use boolCall for?
13:16:09 <joelr1> sorear: boolCall is supposed to parse all the boolean functions
13:16:21 <SamB_XP> it seems that the chief use of integration is making pretty pictures ;-P
13:16:24 <joelr1> sorear: i use it in the condExpr, hang on
13:16:39 <chessguy> procyon112: i'm thinking about just outputing stats to text files, and then basically using gnuplot for the interface
13:17:01 <hpaste>  joelr1 annotated "small thing" with "boolCall used here" at http://hpaste.org/1269#a1
13:17:05 <sorear> joelr1: I think you might be able to avoid dependencies by using the class method directly.
13:17:06 <joelr1> sorear: check
13:17:06 <procyon112> chessguy: That sounds cool for now.
13:17:06 <boowax> saizan: thanks for the help! I tried doing it with the pattern matching as you suggested and I'm having other issues with that...can you show me how to use the Either function you mentioned? my attempt at google-ing it was less than helpful
13:18:03 <chessguy> procyon112: we can extend your REPL to seed and evolve populations, i think
13:18:05 * SamB_XP wishes you could change resolution in DOS by dragging on the corner of the window
13:18:05 <sorear> joelr1: replace boolCall with parse globally, the type checker will know what you mean
13:18:23 <sorear> @docs Data.Either
13:18:24 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Either.html
13:18:46 <joelr1> sorear: interesting... that would surely be hard to grok, though. parse? where does it come from? that type of thing
13:18:55 <SamB_XP> well, more to the point, in near-DOS
13:19:03 <joelr1> let me try with boolCall
13:19:06 <procyon112> chessguy: I can't get my unifier to do infinite types... I've got a thread on haskell-cafe about it... but it's no hold up.  I can still do turing-complete trees by adding fix as a primitive.
13:19:41 <joelr1> sorear: you rock!
13:19:44 <sorear> if you want to be explicit you could use (parse :: CharParser s BoolExpr)
13:19:45 <sorear> :)
13:19:46 <chessguy> procyon112: i can't even grok infinite types
13:20:13 <procyon112> chessguy: Yea.. I can see the REPL and/or GUI doing cool things.. like selecting primitives, kicking off runs, selecting type schemes, all sorts of stuff.
13:21:29 <procyon112> chessguy: infinite types are easy.  It's the type of general recursion... (a->a)->a.  It just means that this might not halt (all non-infinite types halt) because the type refers back to itself.
13:22:01 <chessguy> hmm
13:22:22 <joelr1> sorear: no, not needed
13:22:34 <procyon112> chessguy: so, my unifier's problem is that it can'
13:22:43 <procyon112> t figure out infinite types
13:23:27 <procyon112> chessguy: but that's ok, because you can cheat, by giving fix as a primitive, and telling the unifier it's type (a->a)->a, so it doesn't have to figure it out.
13:23:55 <procyon112> chessguy: and anything that can be resolved to an infinite type, can also be resolved in terms of fix.
13:23:56 <chessguy> o
13:23:58 <chessguy> ok
13:24:10 <Saizan> boowax: another thing, you are using throwError in one of the case branches, so the typesign for checker doesn't seem quite right, unless you have some custom throwError
13:25:35 <procyon112> chessguy: Haskell uses that method... It doesn't do infinite type either, but it gives fix as part of the language, and recursive lets and functions in terms of fix, so that any program can be written.
13:25:48 <chessguy> i see
13:27:48 <kscaldef> anyone around who might be able to help me with a HaXml problem (hopefully a simple one)?
13:29:01 <Heffalump> depends on how simple
13:29:42 <kscaldef> I'm just trying to parse and validate a document.  The parsing goes fine, and the DTD and content look sane
13:29:53 <procyon112> chessguy: It might be nice to have an infinite type checker as a kind of GP system because more funky recursive programs can be expressed easier if infinite types are allowed, but using fix works in a pinch, even if it makes it more difficult on the evolution, which I'm not confident it does.
13:29:58 <kscaldef> but when I call validate, it compains about everything
13:30:11 <kscaldef> every element is unknown, every atttribute is unknown
13:30:19 <chessguy> procyon112: we can always add it later, too
13:30:30 <chessguy> (assuming we can get it working
13:31:31 * chessguy finally breaks down and orders TAPL from amazon
13:31:31 <procyon112> chessguy: I've never seen a paper on infinite types vs. fix in GP... actually, I've only seen about 3 papers on recursive GP ever :)
13:32:00 <joelr1> yay, my stuff compiles! with derive and everything! kudos to sorear
13:32:05 <kscaldef> so, it seems like what I want to do is very simple, but I must be doing something dumb
13:32:22 * joelr1 high-fives sorear and goes to watch a movie. hacking to continue a little later
13:32:24 <procyon112> PolyGP is the only deep work I've seen on this stuff.
13:32:52 <chessguy> that was an interesting paper, if a little out-dated
13:33:01 <joelr1> quality time with one's wife is very important! wives can only handle so many all-day haskell hacking sessions
13:33:22 <Heffalump> kscaldef: nothing obvious comes to mind
13:33:36 <chessguy> joelr1: that's why i need to solve all the world's problems in haskell in the next 10.5 months, before i get married!
13:33:38 <Heffalump> but HaXml is a little temperamental in my experience
13:33:48 <joelr1> ehehe
13:33:58 <kscaldef> hmm... is there another validating XML parser I should consider?
13:34:12 * joelr1 looks forward to using HaXml /will know who to go to/
13:34:17 <chessguy> (man, i'm going to have to start pulling all-nighters soon)
13:34:20 * joelr1 is away
13:34:34 <monochrom> I swear by HXT
13:34:44 <joelr1> oh, year, here's a going-away present: http://flickr.com/photos/joelr1
13:34:45 <lambdabot> Title: Flickr: Photos from joelr1
13:34:47 <procyon112> chessguy: I've already solved all the worlds problems in Haskell... All the solutions are somewhere in that lazy list of mine :)
13:36:28 <kscaldef> monochrom: well, the existence of a cookbook for hxt is encouraging
13:36:50 <procyon112> map eval allPossiblePrograms -- is fun to watch
13:37:36 <Saizan> hxt is very nice the moment you realize it's like a list monad with arrow combinators
13:38:14 <emu> count halting allPrograms / count (not . halting) allPrograms
13:38:27 <procyon112> hehe
13:38:32 <chessguy> lol
13:39:00 <Saizan> you can calculate the chaitin constant! :D
13:39:01 <monochrom> I have a code optimiser that simplifies that code to 0.
13:39:10 <kscaldef> Saizan: I'm not sure I have enough haskell experience for that realization to apply
13:39:25 <procyon112> Saizan: Isn't it effectively 1?
13:39:33 <Heffalump> so, arrows are supposed to be good at tracking static properties of functions, right?
13:39:35 <emu> count halting allPrograms / length allPrograms, sorry
13:39:53 <chessguy> it's oo/oo
13:40:12 <emu> counting and length are probably not good ways to put this
13:40:30 <Saizan> procyon112, isn't it the probability that a random program halts? and is quite impossible to know its value
13:41:05 <monochrom> lim n->oo (count programs under n that halts / n)
13:41:31 <emu> that sounds better
13:41:40 * monochrom was a mathematician
13:41:50 * emu is not
13:41:56 <procyon112> Saizan: The research I've seen estimates the value as infintessimally close to 1.
13:41:57 * monochrom is not
13:42:01 <Syzygy-> monochrom: Was? What happened?
13:42:13 <monochrom> I entered computer science.
13:42:52 * dylan wants a new job
13:42:57 <procyon112> Saizan: So, all programs are non-halting, except for the infinitely small subset we are actually interested in ;)
13:44:01 <emu> that speaks about decidable languages then too?
13:46:39 <procyon112> Essentually, if you introduce general recursion into the language, then the the ratio of non-halting programs to halting approaches 1 as the allowable size of the programs approach infinity.
13:47:07 <Heffalump> dylan: what's wrong with your current one?
13:47:24 <emu> approaches 1? that would be 1:1
13:47:53 <Heffalump> procyon112: is the argument easy to summarise?
13:47:53 <procyon112> emu: er... sorry. ratio of non-halting to total count.. my bad
13:48:37 <procyon112> Heffalump: I've only seen it done experimentally.. I'm not sure if it's proven.
13:49:46 <emu> whacha do, pick a compact representation of a turing machine and simulate n-bit ones ?
13:49:54 <emu> *all n-bit ones
13:49:58 <emu> for each n
13:50:20 <emu> they still need some kind of bound
13:50:34 <Saizan> yeah, you generate all bit-strings of lenght < n and see if they halt
13:50:45 <procyon112> emu: I haven't personally, but I've seen a few papers that did more or less that for different representations.
13:51:24 <emu> then you're testing linear bounded automatons
13:52:26 <procyon112> emu: I'm more interested in the practical applications than the proof, so whether the limit is assymptotically 1 or not is less important to me than "it looks like it, so it's pretty close to something like that", since I'm developing large GP trees.
13:54:17 <sorear>  What order are the fields in a foreign import decl?
13:55:12 <sjanssen> foreign import ccall "foo.h funcname" funcname :: stuff
13:56:24 <sorear> where does unsafe go?
13:56:54 <mauke> foreign import ccall safe "unistd.h execv" c_execv :: Ptr CChar -> Ptr (Ptr CChar) -> IO CInt
13:56:55 <sorear> ok, random search found it
13:57:07 <sorear> the ffi could use more DWIM
13:57:15 <sorear> permutation parsers aren't that hard
13:57:38 <sjanssen> or you could just learn the syntax
13:58:02 <sorear> that's like expecting me to memorize the options to fsck
13:58:14 <sorear> i just about never use it
13:58:15 <monochrom> I heard some programmers bitched about the freedom in Java of allowing "public static final" to be permuted.
13:58:26 <sorear> but when I need it, I need documentation or dwim
13:58:36 <monochrom> dwim = ?
13:58:47 <sorear> do what I (obviously) mean
13:59:07 <mauke> int const unsigned typedef long foo;
14:00:07 <sorear> bwahaha!
14:00:39 <sorear> I've thoughroughly read that section of the spec, and implemented it
14:00:45 <sorear> and I still did a double take
14:01:06 <sorear> Oh, right, typedef *is* a storage class qualifier...
14:03:11 <sorear> *Main Control.Concurrent System.Posix.Unistd> ghc-6.7.20070402: internal error: interpretBCO: unknown or unimplemented opcode 36080
14:03:13 <sorear> nice.
14:03:27 <monochrom> haha
14:09:28 <matthew-_> ok, I need a map with fold in a monad
14:09:38 <sjanssen> @type foldM
14:09:41 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
14:09:54 <matthew-_> fantastic. cheers.
14:10:59 <syntaxfree> oh, boy.
14:11:59 <monochrom> hey, girl.
14:14:08 <Saizan> syntaxfree, it has been a long time, isn't it?
14:14:17 <syntaxfree> yeah.
14:14:26 <syntaxfree> I haven't been hacking much.
14:14:28 <syntaxfree> or at all.
14:15:30 <Saizan> we could have used a rant or two :)
14:16:08 <matthew-_> @pl foldM (\(ls,acc) l -> f (l,acc) >>= \(l',acc') -> return (l:ls, acc'))
14:16:10 <lambdabot> foldM (uncurry (flip (ap . (((>>=) . f) .) . flip (,)) . flip flip snd . (ap .) . flip flip fst . (((.) . const . (return .) . (,)) .) . flip (:)))
14:16:22 <matthew-_> ew. Um, any clues?!
14:16:35 <syntaxfree> Lispers have no zygomorphisms.
14:16:43 <syntaxfree> I think I'm gonna rant about that.
14:16:58 <syntaxfree> I saw an article on CLOS on reddit.
14:17:09 <Saizan> zygomorphism?
14:17:15 <syntaxfree> the generic dispatch mechanism is precisely what I'm used to in GNU R.
14:17:21 <syntaxfree> So I decided to hack on it for a while.
14:17:28 <syntaxfree> In the beginning, it's great fun.
14:17:48 <syntaxfree> You feel somewhat like cheating on your wife, but, c'mon. Variadic functions, named arguments, macros...
14:18:04 <syntaxfree> It's like going to this bordello where the girls will do all that kinky stuff your wife won't.
14:18:28 <syntaxfree> but then, after a while, the fun wears off and you start feeling dirty for messing with the impure stuff.
14:18:44 <syntaxfree> Finally, you return home thinking of how much you really love your wife and shouldn't have done that.
14:20:24 <Saizan> ?type \f -> foldM (\(ls,acc) l -> first (l:) `fmap` f (l,acc) )
14:20:24 <syntaxfree> @help define
14:20:27 <lambdabot> forall b d (m :: * -> *). (Functor m, Monad m) => ((b, d) -> m ([b], d)) -> ([b], d) -> [b] -> m ([b], d)
14:20:27 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:21:45 <matthew-_> ahh, I thought I didn't know "first" - in Arrows.
14:22:07 <matthew-_> Saizan: cheers, a solution that forces me to learn Arrows ;)
14:23:17 <Saizan> well first f (x,y) = (f x,y) for the (->) arrow
14:23:18 <sorear> Is there a recommended style for implementation documentation?
14:23:24 <sorear> @src (->) first
14:23:25 <lambdabot> first f = f *** id
14:23:31 <sorear> @src (->) ***
14:23:31 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
14:23:36 <sorear> @src (->) (***)
14:23:37 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
14:23:57 <syntaxfree> > ((+1) *** (-1)) (3,5)
14:23:58 <lambdabot>   add an instance declaration for (Num (b' -> c'))
14:24:07 <sorear> :t (-1)
14:24:10 <sorear> nice try.
14:24:10 <lambdabot> forall a. (Num a) => a
14:24:19 <sorear> sections aren't that simple :(
14:24:34 <Saizan> screw unary minus!
14:24:42 * luis eyes syntaxfree
14:24:48 * sorear almost never uses negative numbers in Haskell
14:24:49 <syntaxfree> > ((+1) *** (subtract 1)) (3,5)
14:24:51 <lambdabot>  (4,4)
14:25:09 * sorear wouldn't mind if unary minus was spelled N E G A T E
14:25:14 <sjanssen> I think - should be made part of the lexical syntax for num literals
14:25:50 <sorear> sjanssen: but then foo-1 woudn't work
14:25:55 <sjanssen> such that (-1) parses as negative one, and (- 1) parses as subtract 1
14:26:10 <sorear> foo-1  lexes now as foo - 1
14:26:17 <sorear> foo-1  would lex as foo -1
14:26:19 <sjanssen> sorear: correct.  I think it's less hackish than what we have now
14:26:33 <syntaxfree> maybe we should undefine (-) altogether.
14:26:36 <syntaxfree> leave it for custom operators.
14:26:37 <sorear> I think it should be eliminated altogether
14:26:47 <matthew-_> Saizan: sorry, my original was wrong!
14:26:51 <syntaxfree> it'd be great fun to make (-) = (*)
14:26:58 <matthew-_>  foldM (\(ls,acc) l -> f (l,acc) >>= \(l',acc') -> return (l':ls, acc'))
14:27:08 <matthew-_> i.e. the l' in the return
14:28:41 <Saizan> ?type \f -> foldM (\(ls,acc) l -> first (:ls) `fmap` f (l,acc))  --?
14:28:44 <lambdabot> forall b b1 d (m :: * -> *). (Functor m, Monad m) => ((b, d) -> m (b1, d)) -> ([b1], d) -> [b] -> m ([b1], d)
14:29:24 <matthew-_> Saizan: yep, quite why I couldn't work that out, I'm not sure ;)
14:29:29 <procyon112> ?hoogle (***)
14:29:31 <lambdabot> Did you mean: (***)
14:29:31 <lambdabot> Prelude.undefined :: a
14:29:31 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
14:30:37 * sjanssen wonders how import Prelude hiding ((-)) would work
14:31:14 <mauke> ?hoogle ***
14:31:15 <lambdabot> Control.Arrow.(***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
14:32:35 <procyon112> that's handy.  I have no idea what arrows are, but *** will be very useful :)
14:33:03 <mauke> ?hoogle &&&
14:33:04 <lambdabot> Control.Arrow.(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
14:33:19 <Saizan> ?hoogle +++
14:33:20 <lambdabot> Control.Arrow.(+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
14:33:21 <lambdabot> Text.Html.(+++) :: (HTML a, HTML b) => a -> b -> Html
14:33:21 <lambdabot> Text.ParserCombinators.ReadP.(+++) :: ReadP a -> ReadP a -> ReadP a
14:43:46 * sorear uses Haskell to write the world's first unlambda compiler!
14:47:34 <matthew-_> grrr. Do I take it that readFile and writeFile close the file handles as lazily as possible?
14:47:50 <bos> yes.
14:47:59 <matthew-_> so if you've read it with readFile and then later on you try to write to it you have major issues?
14:48:07 <bos> yes.
14:48:16 <bos> at least if you're using windows.
14:48:22 <matthew-_> linux here!
14:48:23 <matthew-_> so the way round is to actually get the handles properly and hClose them?
14:48:25 <bos> but probably on other OSes too.
14:48:39 <bos> yes, you need to do the I/O quite imperatively.
14:48:44 <matthew-_> ok, thanks
14:51:32 <qwr> matthew-_: use strict bytestring's readFile
14:51:48 <qwr> matthew-_: if you want the whole file
14:52:05 <qwr> and want to close it right away
14:54:28 <matthew-_> qwr: ahh, thanks. I'll look into that.
14:55:44 <qwr> and Data.ByteString.Char8 unpacks as [Char]
14:56:19 <desp> @whereis tackling
14:56:20 <lambdabot> Maybe you meant: where where+
14:56:24 <desp> @where tackling
14:56:25 <lambdabot> I know nothing about tackling.
14:56:32 <desp> @where awkward squad
14:56:32 <lambdabot> I know nothing about awkward.
14:56:55 <mauke> @google awkward squad
14:56:59 <lambdabot> http://en.wikipedia.org/wiki/Awkward_Squad
14:56:59 <lambdabot> Title: Awkward Squad - Wikipedia, the free encyclopedia
14:57:05 <desp> @remember tackling http://research.microsoft.com/~simonpj/papers/marktoberdorf/
14:57:05 <lambdabot> Done.
14:58:36 <sorear> @flush
14:58:54 <mauke> @unflush
14:58:55 <lambdabot> Not enough privileges
14:59:00 <sorear> just ... so many opportunities for side tracking
14:59:00 <mauke> :(
14:59:39 <desp> @remember awkward http://research.microsoft.com/~simonpj/papers/marktoberdorf/
14:59:39 <lambdabot> Done.
14:59:43 <desp> @where awkward
14:59:44 <lambdabot> I know nothing about awkward.
14:59:46 <desp> argh!
14:59:56 <desp> I lose.
15:00:21 <sorear> @quote awkward
15:00:22 <lambdabot> awkward says: http://research.microsoft.com/~simonpj/papers/marktoberdorf/
15:00:32 <sorear> @quote tackling
15:00:33 <lambdabot> tackling says: http://research.microsoft.com/~simonpj/papers/marktoberdorf/
15:01:07 <sorear> @where+ tackling http://research.microsoft.com/~simonpj/papers/marktoberdorf/
15:01:07 <lambdabot> Done.
15:01:15 <sorear> @where+ awkward http://research.microsoft.com/~simonpj/papers/marktoberdorf/
15:01:16 <lambdabot> Done.
15:01:25 <mauke> @where tackling the awkward squad
15:01:26 <lambdabot> http://research.microsoft.com/~simonpj/papers/marktoberdorf/
15:02:16 <desp> sorear: thanks
15:02:23 <sorear> yw
15:03:14 <desp> sorear: care to get sidetracked again?  how do you like http://desp.night.pl/juwenalia3.png as a t-shirt design? ;)
15:04:22 <sorear> Heh.  cute.  (Just personally not big on patterned clothing)
15:04:30 <desp> ah.
15:04:53 <sorear> I can't read the text but something screams "promoting a technical conference and/or video game"
15:05:15 <desp> it's actually for a student's festival.  for the students of the departament of mathematics and computer science.
15:05:25 <desp> s/'s/s'/
15:06:06 <dmwit> Just a guess, but is matematyki "mathematics"? ;-)
15:06:12 <desp> yup
15:06:23 <desp> and you could probably say "informatics"
15:06:28 <dmwit> And "wydziat" is clearly "Wuzdat?"
15:06:36 <desp> ;)
15:06:52 <sorear> What's the best haskell compiler for recursive-newtype-intensive programs? (hbc?)
15:07:14 <mauke> haha, "what's the the best compiler for X"
15:07:42 <sorear> there is a undisputed best compiler for general haskell, GHC
15:07:45 <mauke> .oO( metahc -fghc )
15:08:01 <sorear> but a long-standing bug renders it useless for my purpose
15:08:05 <mauke> just change the build options, etc
15:08:14 <sorear> we actually have that
15:08:17 <sorear> @where hmake
15:08:17 <lambdabot> http://haskell.org/hmake
15:23:58 <dmead> hey channel
15:24:07 <dmead> i'm in type constructor hell =/
15:26:28 <stepcut> heh
15:26:39 <monochrom> type constructor is easy
15:27:53 <monochrom> actually everything is easy. then humans cook up messy code. so there is some chance you are in complexity hell and not type constructor per se, and the complexity is self-inflicted.
15:28:47 <wmind> why don't imperative languages have nice simple sum types
15:28:58 <wmind> most even have some sort of case for the pattern matching...
15:29:17 <mauke> OCaml does :-)
15:29:36 <dmead> i have a dependant typing problem actually
15:29:36 <wmind> does OCalm count as imperative?
15:29:44 <dmead> it's in between
15:30:04 <stepcut> what about javascript ?
15:30:04 <dmead> ?seen sorear
15:30:05 <lambdabot> sorear is in #darcs, #haskell-overflow, #ghc and #haskell. I last heard sorear speak 21m 48s ago.
15:30:12 <dmead> ?seen dons
15:30:12 <lambdabot> dons is in #haskell-soc, #haskell-overflow and #haskell. I last heard dons speak 10h 57m 30s ago.
15:30:25 <dmead> yeaaa
15:30:26 <wmind> stepcut: I don't know :)
15:30:34 <monochrom> Pascal has nice simple sum type.
15:30:36 <dmead> i'm trying to figure out a dependant type structure for FOL
15:30:40 <dmead> i mean
15:30:43 <dcoutts> dmead: he's probably still a sleep
15:30:46 <dmead> ah
15:30:51 <wmind> monochrom: you mean variant records?
15:30:59 <monochrom> Yes.
15:31:13 <dmead> you know whats nice
15:31:33 <dmead> if you include a type synonym in an data declaration
15:31:37 <dmead> it can't be shown
15:31:40 <dmead> =/
15:31:41 <lightstep> i think Fortress is functional, since you have some kind of tagging for side-effects of functions, like monadic operations in askell
15:31:42 <wmind> monochrom: well that's not even safe ...
15:31:44 <dmead> apparently...
15:31:58 <monochrom> I recall that it's safe.  C's union not safe.
15:32:46 <wmind> monochrom: how can it be safe?
15:32:53 <monochrom> OK, I forgot.
15:33:09 <wmind> monochrom: it's a record, and some fields are enabled depending on others
15:33:24 <wmind> monochrom: you check the flag field and decide what to access
15:33:31 <wmind> monochrom: it can't be safe
15:34:24 <dmead> ?paste
15:34:24 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:34:32 <wmind> monochrom: plus I don't even find that simple :D  an haskell like sum and then pattern  matching in case would do the job
15:35:24 <augustss> yo
15:36:52 <sorear> hello!
15:37:28 <hpaste>  dmead pasted "dependant types for FOL?" at http://hpaste.org/1270
15:37:29 <sorear> dmead: you called?
15:37:53 <hpaste>  dmead annotated "dependant types for FOL?" with "(no title)" at http://hpaste.org/1270#a1
15:38:02 <dmead> allo
15:38:20 <dmead> augustss: you probably know the answer to this
15:38:50 <dmead> i'm trying to figure out a nice way to represent FOL as type constructors
15:39:53 <sorear> augustss: can hbc survive newtype V = V (U V -> U V)
15:39:54 <augustss> dmead: you need dependent types to represent quantifiers
15:40:20 <sorear> I non-negotiably have that type in my program.  I could use hugs, but I'd like an optimizing compiler.
15:40:26 <augustss> sorear: probably, but i don't know
15:41:09 <dmead> augustss: indeed, did you have seperate types for propositions, predicates and variables in dijnn?
15:41:17 <sorear> About how much of a fight do you think hbc install will put up?
15:41:21 <Igloo> sorear: Is this the known GHC-loops bug? If so, and you have a real use for it, then you should let SPJ know
15:41:42 <augustss> what djinn does have little relevance, since djinn only does propositional logic
15:42:09 <dmead> oh
15:42:17 <dmead> i thought yours did FOL
15:42:30 <sorear> Igloo: does it matter if the program is not one anybody will actually use?
15:42:50 <sorear> Igloo: or rather, the functionality is pretty useless
15:43:04 <sorear> Igloo: it's an Unlambda compiler
15:43:12 <augustss> dmead: no quantifiers.  quantifiers makes it undecidable
15:43:16 <sorear> should I still tell him?
15:43:42 <augustss> sorear: installing hbc is most likely a major pain
15:43:44 <dmead> augustss: what method for proving did you use?
15:44:21 <sorear> some kind of CJK calculus
15:44:24 <Igloo> sorear: If you want to run the program, then yes
15:44:33 <augustss> dmead: a variation of Gentzen's LJ
15:44:36 <Igloo> sorear: The description on http://www.haskell.org/ghc/docs/6.6/html/users_guide/bugs.html#bugs-ghc says:
15:44:37 <sorear> there's a well commented source file in the djinn repo
15:44:38 <lambdabot> Title: 12.2. Known bugs or infelicities, http://tinyurl.com/22mp2v
15:44:39 <dmead> hmm
15:44:41 <Igloo> We have never found another class of programs, other than this contrived one, that makes GHC diverge, and fixing the problem would impose an extra overhead on every compilation. So the bug remains un-fixed.
15:44:52 <dmead> i'm trying to do resolution
15:45:01 <sorear> @where spj
15:45:02 <lambdabot> I know nothing about spj.
15:45:18 <Igloo> assuming that is the same problem you're running into
15:45:41 <Igloo> glasgow-haskell-users@haskell.org is probably the best place to bring it up
15:45:42 <augustss> dmead: does resolution give you a constructive proof?
15:46:01 <dmead> augustss: yes
15:46:21 <dmead> err
15:46:24 <dmead> it's gives you a proof
15:46:30 <dmead> what do you mean by constructive proof?
15:47:03 <monochrom> Whenever "a or b" is proved, the proof tells you "it's actually a" or "it's actually b".
15:47:07 <augustss> you can't use the law of excluded middle (or double negation, or something equivalent)
15:47:21 <dmead> ah
15:47:26 <monochrom> Whenever "exist x. Px" is proved, the proof tells you a lot about the x chosen.
15:47:35 <augustss> I wanted a proof method that gave me programs
15:47:41 <dmead> ah
15:48:04 <dmead> resolution just says when you have a v b and ~a v c
15:48:10 <dmead> you can write b v c
15:48:33 <monochrom> yeah, usually, when proving "exist x. Px", an algorithm (maybe slow but still) is produced for crunching out an x.
15:49:14 <augustss> dmead: but that uses excluded middle
15:49:14 <dmead> hmm, resolution in FOL is still much simpler than that
15:49:14 <monochrom> Yes that one kills constructivity.
15:49:38 <dmead> whats wrong with that?
15:49:47 <dmead> @hoogle halp
15:49:48 <lambdabot> No matches found
15:49:51 <dmead> hmm
15:49:52 <augustss> proving for propositional calculus in classical logic is easy
15:50:04 <dmead> right
15:50:12 <dmead> in FOL you skolemize each predicate
15:50:14 <augustss> it's the constructive part that is the challange
15:50:26 <dmead> and it gives you an interpretation ( i think ) that is valid to do resolution with
15:50:28 <monochrom> It doesn't tell you "it's b" or "it's c".  More detailedly, it says "a or ~a, but I don't care which, it's probably impossible to find out anyway"
15:50:44 <dmead> oh well
15:50:46 <stepcut> Igloo: are you subscribed to debian-haskell@lists.urchin.earth.li ?
15:50:55 <dmead> thats just the resolution rulew
15:51:08 <dmead> the entire proof method requires you to break a sentence into a list of conjuncts
15:51:20 <Igloo> stepcut: Yes
15:51:26 <augustss> dmead: what method you use depends on what your purpose is (and your philosophy :) )
15:51:32 <dmead> hmm
15:51:39 <monochrom> Yes, one could refrain from that rule. Fewer things can be proved, but all proofs provide more information.
15:52:06 <dmead> resolution is an inference rule
15:52:11 <monochrom> It is okay because constructivity does mean fewer things provable anyway.
15:53:02 <sorear> @all-dicts skolemize
15:53:04 <lambdabot> No match for "skolemize".
15:53:24 <dmead> http://planetmath.org/encyclopedia/Skolemization.html
15:53:26 <lambdabot> Title: PlanetMath: Skolemization
15:54:19 <augustss> Thoralf Skolem
15:54:22 <sorear> brilliant
15:54:50 <sorear> computing a supertype of an arbitrary type with no existentail quantification...
15:55:03 <monochrom> it sounds like resolution is in-grained in classical non-constructive logic then.
15:55:17 <luis> Does anybody have an HTML version of YAHT?
15:55:32 <dmead> ni
15:55:34 <dmead> no
15:55:38 <Saizan> ?google wikibook YAHT
15:55:40 <lambdabot> http://en.wikibooks.org/wiki/Haskell/YAHT
15:55:49 <sorear> how embarrasing
15:55:51 <dmead> you can use resolution in FOL if you have a correct skolem function
15:55:55 <sorear> @hoogle Char -> IO ()
15:55:56 <lambdabot> Prelude.putChar :: Char -> IO ()
15:55:57 <lambdabot> System.Console.Readline.completeInternal :: Char -> IO ()
15:55:57 <lambdabot> System.Console.Readline.setPendingInput :: Char -> IO ()
15:56:03 <luis> Saizan: thanks
15:56:05 <monochrom> <a href="yaht.pdf">yaht</a>
15:56:07 <sorear> I can't believe putChar slipped :)
15:56:17 <dmead> hey
15:56:26 <dmead> i'm making a type synonym
15:56:27 <sorear> ndm++
15:56:29 <sorear> @flush
15:56:30 <dmead> which is Char -> [Char]
15:56:36 <dmead> can i add a show instance for that?
15:56:41 <sorear> no
15:56:44 <dmead> =/
15:56:47 <sorear> you can if it's a newtype
15:56:52 <dmead> HMM
15:56:54 <dmead> alright
15:57:00 <sorear> but type synonyms are basically macros
15:57:20 <dmead> right
15:57:29 <dmead> it's sorta tricky
15:57:51 <dmead> i've got a few paragraphs what what a well formed formula for FOL is
15:58:09 <dmead> and i'm trying to cram that into not as many lines of data types
15:58:20 <dmead> *of what
15:59:57 <monochrom> should be just a few lines
16:00:05 <dmead> yea
16:00:24 <dmead> i keep running into problems with show =/
16:00:33 <augustss> why
16:00:40 <augustss> can't you just derive it?
16:03:54 <Igloo> stepcut: Why did you ask? Did I miss a message there?
16:04:16 <hpaste>  dmead pasted "layout manager hates me" at http://hpaste.org/1271
16:05:44 <stepcut> Igloo: no, but I am going to send one, and I wanted to make sure you had the opportunity to see it
16:05:53 <Igloo> OK  :-)
16:05:59 <stepcut> Igloo: debian packages (everyones, not just yours) install the documentation in /usr/share/doc
16:06:10 <hpaste>  sorear pasted "Is this a GHCi bug?" at http://hpaste.org/1272
16:06:23 <Igloo> stepcut: I have plans to do something else, probably for 6.6.1
16:06:34 <stepcut> Igloo: but ghc-pkg describe pkgName, says that it is stored in /usr/share/pkgName-1.0/doc/html
16:06:56 <stepcut> Igloo: which is, (a) wrong (b) unfortunate, because haddock uses that information to try to create links between packages
16:06:57 <Igloo> stepcut: I'm not quite sure what something else is, but I do now know how to merge docs into one big haddock index
16:07:04 <Igloo> stepcut: Right, there's a bug about that too
16:07:07 <Igloo> I'll look into it at the same time
16:07:28 <sorear> Can someone take a quick look at that paste and tell me if I should file a ticket?
16:07:28 <stepcut> Igloo: spiffy, I wasn't sure if anyone had noticed yet
16:07:46 <Igloo> I think Ross Patterson filed it a week or so ago
16:08:09 <augustss> dmead: what's the 'a in 'Formula a' anyway?
16:08:22 <monochrom> s/Not Formula/Not (Formula a)/
16:09:00 <augustss> I mean, i can see it in quantifier, but it makes little sense to me
16:09:03 <chessguy> ?uptime
16:09:04 <lambdabot> uptime: 1d 7h 56m 42s, longest uptime: 5d 3h 40m 45s
16:09:14 <stepcut> Igloo: spiffy, I want to make sure I update my cabalDebianTemplate when we figure out what the right thing to do is
16:10:14 <augustss> sorear: seems a bit fishy
16:10:17 <stepcut> Igloo: also, since I am bugging you, what is the policy for updating things like libghc6-time-dev ? Version 1.1 has bringerts time parsing functions, and fixes a bug in formatDate
16:10:20 <Igloo> *nod*
16:10:52 <sorear> Igloo: I can't find the ticket
16:11:08 <Igloo> stepcut: Prod me, I guess  :-)
16:11:14 <stepcut> ok
16:11:38 <stepcut> I wasn't sure if it was frozen due to etch, policy, or just no one complaining :)
16:11:53 <Igloo> sorear: It's not in tract AFAIK, just documented at the URL I gave above (in the GHC user guide)
16:12:57 <stepcut> you can't make rfc2822 date's using time-1.0 because there is no (clean) way to show seconds rounded to whole numbers ;)
16:13:11 <Igloo> stepcut: Oh, true, technically I probably shouldn't upload it to unstable
16:13:16 <Cin> hi. the wikibook about Haskell is really good, so far. I especially like the summaries and excersizes, they help a lot to re-enforce what I has just been read. thanks for the link :)
16:13:18 <stepcut> s/date's/dates/
16:13:44 <stepcut> Igloo: are you involved with the GSoC project to try to auto debianize and autobuild hackagedb ?
16:14:29 <sorear> Igloo: Oh, this paste has nothing whatsoever with recursive newtypes.
16:14:30 <sorear> isearch-backward doesn't take regexes?!
16:14:38 <sorear> found it (isearch-backward-regexp, C-M-r)
16:14:42 <stepcut> :p
16:15:25 <Igloo> sorear: Oh, well, if it's an unknown bug then file it!
16:15:31 <sorear> stepcut: does that mean I should take aptage off my TODO list?
16:15:56 <stepcut> sorear: dunno, I am not even sure if the project was approved
16:16:37 <sorear> Igloo: Is a registered wiki account 'sorear' usable for bug reporting on GHC-trac?  ISTR some of the others were locked.
16:16:52 <sorear> s/wiki//
16:18:40 <Igloo> sorear: It is now
16:19:22 <sorear> ty
16:27:11 <dmead> augustss: dont i need it there for the other types?
16:27:28 <dmead> wait
16:27:29 <dmead> nm
16:27:30 <dmead> XD
16:27:42 <augustss> dmead: what other types would you need?
16:28:09 <dmead> for efficency reasons in resolution i need a seperate type for propositional classes
16:28:30 <augustss> hmmmm
16:28:37 <dmead> and predicates, and  the quantifiers
16:28:47 <dmead> i know it could all be in the same recursive type
16:28:55 <augustss> go for the simple solution first, then optimize
16:28:56 <dmead> but that complicates things at many stages
16:29:11 <sorear> #1268
16:29:13 <dmead> this is my attempt at optimization
16:29:15 <dmead> hehe
16:29:27 <dmead> my prover thats up on the wiki already does propositional stuff
16:30:16 <sorear> There's efficiency and then there is efficiency.
16:30:26 <sorear> Avoiding nub is the first kind.
16:30:40 <dmead> is nub short for something?
16:30:44 <sorear> no
16:30:46 <dmead> cause thats e-slang for newb
16:30:52 <augustss> dmead: no
16:30:58 <augustss> it's an english word
16:30:59 <sorear> Writing pretty printing combinator libraries that do not allocate using GHC primops is the second kind.
16:31:29 <dmead> ah
16:31:42 <sorear> Wow, it's even in my dictionary!
16:31:48 <augustss> dmead: meaning "the essence of"
16:32:19 <narain> is there a good type class for things that behave like invertible functions?
16:32:31 <augustss> narain: no
16:32:46 <augustss> narain: but you can make one
16:32:47 <sorear> Transform isn't good enough for you?
16:32:53 <narain> yes, i guess i will
16:32:58 <sorear> augustss: he did, yesterday
16:33:23 <augustss> i guess it all depends on what ones means by "is"
16:33:24 <narain> sorear: yes, then i saw a discussion of Monoid today
16:33:48 <sorear> Invertable functions form a group, which is a ... duh!
16:33:48 <narain> then i thought, hey, a transform is a monoid
16:33:56 <sorear> a transform is a group.
16:34:02 <sorear> a group is a transform.
16:34:06 <sorear> they are the same.
16:34:14 <narain> not really...?
16:34:17 <sorear> transform2 is still needed however
16:34:39 <sorear> class Transform t where
16:34:40 <sorear>   comp :: t -> t -> t
16:34:40 <sorear>   nill :: t
16:34:40 <sorear>   invr :: t -> t
16:34:41 <narain> a transform is something that transforms other things
16:35:05 <sorear> class Group g where
16:35:05 <sorear>   operate :: t -> t -> t
16:35:05 <sorear>   identity :: t
16:35:05 <sorear>   inverse :: t -> t
16:35:23 <narain> ah well
16:35:32 <narain> guess it's more of a different perspective
16:35:40 <sorear> class Group t => Transform t e where
16:35:40 <sorear>   transform :: t -> e -> e
16:35:51 <narain> the reals form a group but not really a transform
16:35:57 <narain> sorear: right
16:36:07 <narain> so is Group built-in?
16:36:12 <sorear> no :(
16:36:20 <sorear> further we require a 'homomorphism' law
16:36:33 <sorear> transform a . transform b == transform (a `comp` b)
16:36:44 <sorear> id == transform nill
16:36:52 <sek> what module are abstract algebra notions in?
16:36:58 <dmead> can you guys see an error here?
16:36:59 <dmead> http://hpaste.org/1271
16:37:03 <sorear> sek: none
16:37:08 <dmead> ghci says i have a bad layout
16:37:08 <sorear> @where numericprelude
16:37:09 <lambdabot> darcs.haskell.org/numericprelude/
16:37:11 <dmead> but i don't see how
16:37:16 <sorear> ^^^ non standard lib
16:37:37 <sjanssen> dmead: "newtype Proposition = Char" probably doesn't mean what you think it does
16:37:49 <sek> nice, thanks. Will check it out
16:37:56 <dmead> ah
16:38:16 <sjanssen> dmead: but the compiler is complaining about layout?
16:38:20 <dmead> yes
16:38:24 <dmead> i changed newtype to data
16:38:27 <dmead> and it's alright
16:38:29 <narain> yeah, i really feel the numeric prelude should be part of the standard
16:38:35 * narain <3 math
16:38:37 <sorear> yay for type systems
16:38:39 <sorear> curr   = unsafePerformIO (newIORef Nothing)
16:38:48 <dmead> narain: theres a discussion on the mailing list to that effect
16:38:52 <sorear> thankfully I caught that before trying to use it :)
16:39:04 <narain> dmead: what was the consensus?
16:39:15 <dmead> i forget
16:39:21 <dmead> sorear started the topic
16:39:28 <narain> ok, i'll look
16:39:34 <sorear> "Why the Prelude must die" ?
16:39:57 <sorear> IMO it was fairly OT by the time the numeric prelude was mentioned.
16:40:32 <sjanssen> dmead: I'm not getting layout errors
16:40:56 <dmead> weird
16:41:03 <hpaste>  sjanssen annotated "layout manager hates me" with "fixed" at http://hpaste.org/1271#a1
16:41:16 <ptolomy> Y'know, I used to think the Haskell Anti-Syntactical Sugar Lobby was a bit goofy, but just yesterday I was converting a ~200 line program that used strings extensively to use ByteString, and I realized how often I use limiting syntax.
16:41:41 <sjanssen> dmead: I got a kind error " `Formula' is not applied to enough type arguments"
16:41:52 <dcoutts> ptolomy: syntactic sugar is great :-)
16:41:55 <Botje> HASSL? that's cool.
16:42:06 <dmead> ah
16:42:10 <dmead> are you on 6.6 per chance?
16:42:11 <ptolomy> Now I think the Haskell Anti-Syntactical Sugar Lobby is slightly less goofy. :)
16:42:12 <dcoutts> ptolomy: and yeah, I miss it when using ByteString
16:42:13 <narain> sorear: good golly that's a long thread
16:42:21 <sjanssen> dmead: yes.  Are you using tabs?
16:42:25 <dmead> yes
16:42:26 <dmead> hehe
16:42:32 <dmead> i think
16:42:46 <sjanssen> I think we just need to make our sugar overloaded
16:42:46 <dmead> i forget if emacs just maps tab to spaces for haskell-mode
16:42:51 <dcoutts> ptolomy: so surely it's an argument for extending the syntactic sugar rather than eliminating it
16:43:01 <dcoutts> sjanssen: just
16:43:03 <dcoutts> erm
16:43:06 <dcoutts> just/right
16:43:07 <ptolomy> dcoutts: Yeah, ruins all my fun pattern matching.
16:43:13 <ptolomy> dcoutts: Absolutely.
16:43:17 <dmead> i wouldn't want to use haskell without the sugar
16:43:23 <dmead> it's really ugly and perlish at times otherwise
16:43:24 <ptolomy> I'm all for string-as-a-typeclass now.
16:43:27 <dmead> from what i've seen
16:43:32 <sjanssen> dmead: if you're using tabs, and they aren't displayed as 8 spaces in your editor, you're going to have problems
16:43:35 <sorear> What is the best way to get IO (Maybe Char) in the style of C's getchar?
16:43:37 <dmead> ah
16:43:41 <dcoutts> ptolomy: heh, I'm just writing a rant against that particular idea...
16:43:45 <mauke> no, I'm not :(
16:43:55 <sjanssen> dcoutts: so is ICFP crunch time over?
16:43:56 <dmead> i have another question
16:43:57 <ptolomy> dcoutts: I should add "or any viable alternative".
16:43:59 <dmead> if anyones up for it
16:44:07 <dcoutts> sjanssen: oh not yet, but I was inspired to rant
16:44:08 <sorear> I can't figure out any way better than catchJust getChar...
16:44:16 <dmead> how do you define a type with just the upper case letters?
16:44:20 <mauke> sorear: yeah, that's how I'd do it
16:44:21 <sorear> dmead: newtype
16:44:29 <dmead> newtype Upper = ?
16:44:34 <sorear> mauke: seriously? *gulp*
16:44:50 <dmead> i see theres UppercaseLetter in data.char
16:44:55 <mauke> yeah, like OCaml
16:45:01 <dmead> but theres nothing writting on/with it
16:45:07 <sorear> ocaml uses eof exceptions :(
16:45:09 <sorear> ?
16:45:21 <mauke> yes
16:45:32 <monochrom> yes
16:45:37 <sjanssen> yes
16:45:46 * sjanssen is just trusting mauke and monochrom
16:46:09 <dmead> yes
16:46:11 <dmead> (follower)
16:46:16 <mauke> val input_char : in_channel -> char
16:46:24 <mauke> Raise End_of_file if there are no more characters to read.
16:46:33 <ptolomy> "Ocaml reminds me of my ex-girlfriend: fast and ugly."
16:46:37 <sjanssen> sorear: you could also check the return value of hGetBuf
16:46:55 <monochrom> plus ocaml is eager. the two together causes it to easy to write naive code that stack-overflows because of layers and layers of try-catch.
16:47:21 <dmead> ?type toupper
16:47:24 <lambdabot> Not in scope: `toupper'
16:47:29 <sorear> but .. try-catch can be implemented so as to have the try-bluck in tail call context!
16:47:34 <sorear> or is ml too dumb?
16:47:40 <sorear> ?type toUpper
16:47:43 <lambdabot> Char -> Char
16:47:50 <narain> something i saw in the Prelude-must-die thread: "For example: we know that all Monads are Functors, but that is not expressed in the type classes, because it would be too much a pain to do so."
16:47:54 <sorear> much as I hate it, haskell uses CamelCase
16:47:57 <narain> is this true? why would it be a pain?
16:48:09 <mauke> is there a name for the match/try inversion pattern I'm thinking of?
16:48:14 <sorear> because we don't have the class system extension proposal?
16:48:28 <sjanssen> narain: the "pain" is exactly one line of boilerplate
16:48:40 <monochrom> boilerplate is pain :)
16:49:04 <dmead> > newtype Upper = toUpper Char
16:49:05 <lambdabot>  Parse error
16:49:19 <dmead> hmm
16:49:20 <sjanssen> sorear: please don't tie the functor/monad issue to class system extensions -- every time somebody proposes to fix the hierarchy we get sidetracked with extension proposals
16:49:33 <mauke> let rec mangle_lines fh a = match ( try Some (words (input_line fh)) with | _ -> None ) with  | None -> a  | Some w -> mangle_lines fh (parse_info w :: a)
16:49:41 <narain> sjanssen: do you mean having to also instantiate Functor every time you want to define a Monad?
16:49:48 <mauke> ^ does that pattern have a name?
16:50:02 <dmead> mauke: either?
16:50:03 <sjanssen> there are certainly advantages to such extensions, but it's really not needed for Functor/Monad
16:50:09 <sjanssen> narain: correct
16:50:10 <dmead> ?type Either
16:50:13 <lambdabot> Not in scope: data constructor `Either'
16:50:43 <narain> sjanssen: i wouldn't mind that
16:50:46 <mauke> dmead: huh?
16:50:56 <dmead> Either type
16:50:58 <sjanssen> instance Functor T where fmap f x = x >>= return . f -- is not very painful at all
16:51:12 <dmead> Either a = Left a | Right a
16:51:17 <dmead> or something like that
16:51:20 <mauke> fmap = liftM
16:51:28 <mauke> dmead: ... ok?
16:51:59 <sjanssen> mauke: yes, assuming liftM isn't removed/rewritten when Functor becomes a superclass of Monad
16:52:19 <sorear> @hoogle isJust
16:52:20 <lambdabot> Maybe.isJust :: Maybe a -> Bool
16:56:56 * stepcut looks forward to that day
16:57:37 <stepcut> anyone know why the NatTransf class from gofer never made it into haskell? Was it a bad idea? Or just underappreciated ?
17:00:21 <dan__> blah
17:00:37 <mauke> yes, master?
17:00:44 <dan__> :P
17:01:22 <Cale> stepcut: a bit of both.
17:01:59 <dmead> wonderful
17:01:59 <narain> ?quote
17:02:00 <lambdabot> beelsebob says: > filter isJuggler #haskell
17:02:02 <Cale> stepcut: It was less appreciated than it should have been, but it also makes a strange assumption that there should be some canonical natural transformation where there is one.
17:02:19 <dmead> newtype Proposition = toUpper Char
17:02:19 <dmead> fails for me
17:02:34 <stepcut> Cale: it also seems like have 'eta' all over the code is less descriptive than maybeToList, etc
17:02:52 <Cale> well, naming is another thing, sure
17:03:11 <Cale> join could have been called mu :)
17:03:19 <Cale> and return could have been eta again
17:03:34 * sorear would like that :)
17:04:04 <stepcut> well, even if eta was called something else, having only one name for all the various casting seems like you would lose track of types
17:04:23 <stepcut> like if fromInteger, fromRational, etc, all got replaced by a function 'from'
17:04:27 <stepcut> and then you would do:
17:04:39 <stepcut> from ((from 1.0) + (from 1))
17:04:45 <stepcut> and have no idea what is really going to happen
17:04:53 <stepcut> it'd be like C all over again ;)
17:05:41 <stepcut> (casting is not really the right term)
17:06:28 <narain> is there a way to get the compiler to print out all the types it has inferred in my code?
17:06:56 <narain> (that (from .. from) bit reminded me that i've wanted that before)
17:12:44 <narain> sorear: i just remembered why i hadn't called my transform type class Group
17:12:48 <sebell> Are there any issues with using unsafeInterleaveIO in my code with a threaded GHC RTS?
17:12:58 <narain> sorear: because composition isn't commutative
17:13:38 <chessguy> hmm, where have all the bloggers gone? :(
17:14:12 <sjanssen> chessguy: the answer is blowin' in the wind
17:14:18 <chessguy> ?
17:15:03 <sorear> narain: since when have groups been commutative?
17:15:08 <sorear> narain: and -ddump-types
17:15:27 <sorear> sorry, was away filing Yet Another Ghc Ticket ;)
17:15:29 <narain> sorear: thanks
17:15:41 <narain> sorear: and, they're not? i was so sure they are
17:15:52 <sorear> commutative groups are called abelian groups.
17:16:21 <narain> oh
17:16:53 <sorear> one of the canonical examples of a group is SO(3), rotations in 3-space, anyone who knows anything about computer graphics can tell you those don't commute
17:17:02 <narain> this is what happens when you learn a subject from blogs rather than having a formal education in it
17:17:28 <narain> sorear: yes, i can tell you those don't commute :)
17:17:33 <sorear> <- random books and wikipedia, no formal education
17:18:13 <sorear> @where ffi
17:18:14 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
17:18:38 <narain> well then, no further objections to Group now
17:20:41 <dmead> i herby request overlapping type constructors for haskell prime
17:20:44 <dmead> :<
17:20:53 <sorear> overlapping?
17:21:00 <dmead> yes
17:22:38 <dmead> i'll write up an example
17:22:38 <dmead> ?paste
17:22:39 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:22:40 <dmead> poo?
17:22:42 <dmead> ah
17:22:46 <dmead> still online
17:24:13 <hpaste>  dmead pasted "(no title)" at http://hpaste.org/1273
17:24:19 <dmead> like that
17:24:36 <sjanssen> dmead: what is the type of 'P'?
17:24:39 <dmead> and then you'd typecast it when instantiating an instance
17:24:42 <dmead> it's just a constructor
17:24:49 <sjanssen> it has to have a type
17:24:58 <dmead> oh
17:24:59 <dmead> i mean
17:25:10 <dmead> it should be able to be in the context of a proposition or a term in a formula
17:25:36 <sjanssen> it still has to have a type
17:25:38 <dmead> via a typecast
17:25:46 <sjanssen> there is no such thing as a typecast
17:26:02 <dmead> but then how can we place constraints on a datatype
17:26:40 <sjanssen> what is the type of f, where f P = Q ?
17:26:54 <dmead> is that an instance?
17:27:01 <sjanssen> f is a function
17:27:35 <dmead> you should be able to typecast it to whichever you need
17:27:55 <dmead> or use a type signature rather
17:28:06 <dmead> f :: Proposition -> Formula
17:28:09 <dmead> should be valid
17:28:19 <dmead> f :: Formula -> Formula
17:28:21 <dmead> should also work
17:28:46 <dmead> i wouldn't expect type inference to work correctly
17:29:59 <sjanssen> I don't see any big benefits
17:30:33 <dmead> you could have dependant type structures with what is essentially constraints
17:30:46 <dmead> if parent types have a subset of constructors from a child type
17:31:03 <monochrom> Please don't try to fit powerful dependent typing into haskell typing.
17:31:04 <dmead> you could look at a really specific set of constructors
17:31:12 <dmead> =/
17:33:09 <monochrom> It's just the same as saying please don't use a hammer to cut meat.
17:34:23 <procyon112> @seen chessguy
17:34:24 <lambdabot> chessguy is in #haskell, #ghc, #haskell-overflow and #haskell-blah. I last heard chessguy speak 20m 5s ago.
17:34:41 <chessguy> yo!
17:34:55 <dmead> :P
17:35:03 <dmead> haskell is asking for good dependant typing
17:35:09 <procyon112> chessguy: I have a crossover operation.  It's likely slower than hell, but it works.
17:35:24 <chessguy> sweet!
17:36:02 <procyon112> chessguy: I think we may want to store types and tree size in the tree representation... I think my algorithms are getting to be n**4 or so from all the retraversing.
17:36:10 <Cale> dmead: yeah, sort of. The general approach has been to strengthen the system gradually while trying to maintain as much type inference as possible though.
17:36:15 <monochrom> haskell is asking for stuff? information wants to be free? software wants to be open-source? green-house gas wants to go away?
17:36:25 <dmead> Cale: yea..
17:36:27 <procyon112> chessguy: But this will work as a preliminary version.
17:36:33 <chessguy> fair enough
17:36:47 <chessguy> should we work together on the integration?
17:36:50 <dmead> i'm pulling my hair out trying to represent logic as it really exists
17:36:59 <dmead> and not just a single recursive type
17:37:10 <procyon112> chessguy: nah.. I'll sync up and do it.
17:37:21 <Cale> dmead: I'd represent only the syntax of logic, and leave all the semantics for runtime.
17:37:30 <dmead> oh sure
17:37:44 <chessguy> ok, let me know if you need to know anything about my code
17:37:53 <procyon112> chessguy: and write another version of "Problem" that does the same as yours, but with strongly typed operations.
17:38:09 <monochrom> Even, represent just the context-free part of the syntax.
17:38:23 <chessguy> sounds good
17:41:03 <dmead> yea
17:41:33 <dmead> a recursive definition would let screwy things happen though
17:45:22 <monochrom> Most screwy things will have to be checked at runtime using code.
17:45:56 <dmead> thats true
17:46:08 <dmead> but i also have to match to a subset of constructors
17:46:23 <dmead> ahhh wait
17:46:27 <dmead> i just realized
17:46:28 <dmead> it won't work
17:46:29 <dmead> at all
17:46:33 <dmead> :<
17:49:47 <procyon112> how would I make an infinite list ["a".."z","aa","ab".."az","ba"...] ?
17:50:49 <dmead> liiike?
17:50:57 <dmead> i don't see a pattern =/
17:51:05 <dmead> oh
17:51:06 <narain> procyon112: try writing a function Int -> [Char] and map it onto [1..]
17:51:23 <int-e> > iterate (['a'..'z']:) [] >>= sequence
17:51:32 <dmead> or a list comprehension
17:51:33 <Cale> concatMap (\n -> replicateM n ['a'..'z']) [1..]
17:51:49 <Cale> that can be simplified :)
17:51:53 <procyon112> > concatMap (\n -> replicateM n ['a'..'z']) [1..]
17:51:55 <lambdabot>  ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s"...
17:52:04 <Cale> > concatMap (\n -> replicateM n ['a'..'c']) [1..]
17:52:05 <lambdabot>  ["a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aac",...
17:52:09 <emu> ['a'..'z']*
17:52:28 <chessguy> @pl \n -> replicateM n ['a'..'c']
17:52:29 <lambdabot> flip replicateM ['a'..'c']
17:52:30 <emu> in lexicographic order!
17:52:45 <narain> emu: that would put "aa" before "b"
17:53:10 <sorear> dcoutts: I think you did a rant-to-sender
17:53:15 <procyon112> cool thx
17:53:17 <chessguy> ?hoogle sequence
17:53:22 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
17:53:24 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
17:53:26 <lambdabot> Language.Haskell.TH.Syntax.sequenceQ :: [Q a] -> Q [a]
17:53:36 <dcoutts> sorear: does it matter? it's cc'd to the list and aimed generally
17:53:47 <dcoutts> I'm not ranting at him speciically? was that unclear?
17:53:54 <Cale> > Prelude.sequence [(2+), (2*), (2^)] 5
17:53:56 <lambdabot>  [7,10,32]
17:54:00 <sorear> dcoutts: I never got your rant
17:54:08 <sorear> dcoutts: r. marlow implies he got it
17:54:12 <chessguy> > iterate (['a'..'z']:) [] >>= Prelude.sequence
17:54:14 <lambdabot>  ["","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r",...
17:54:21 <dcoutts> sorear: it's on the libraries list no?
17:54:25 <chessguy> > drop 30 $ iterate (['a'..'z']:) [] >>= Prelude.sequence
17:54:26 <lambdabot>  ["ad","ae","af","ag","ah","ai","aj","ak","al","am","an","ao","ap","aq","ar",...
17:54:33 <sorear> dcoutts: therefore, I conjecture you replied to sender not list
17:54:42 <int-e> > sequence []
17:54:52 * sorear checks the archives, since his inbox is 5m latency
17:54:53 <dcoutts> sorear: I've got my reply via the list and it says it's cc'd to the list, perhaps it's being slow
17:54:57 <chessguy> > Prelude.sequence []
17:54:59 <lambdabot>   add an instance declaration for (Show (m [a]))
17:55:04 <chessguy> int-e: it's a LB bug
17:55:07 <int-e> hmm. I wonder why lambdabot doesn't like me. in privmsg, it gives me "Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString"
17:55:25 <sorear> int-e: @let?
17:55:26 <dcoutts> int-e: that plugin is borked
17:55:26 <int-e> ah
17:55:43 <chessguy> @load int-e
17:55:43 <lambdabot> Plugin `dummy' failed with: IRCRaised Prelude.read: no parse
17:55:45 <int-e> chessguy: didn't see the Prelude. in your line :)
17:55:50 <sorear> int-e: actually it works perfectly in the source, just dons can't be bothered to recompiler
17:56:00 <int-e> > 1+1
17:56:02 <lambdabot>  2
17:56:07 <sorear>    The requested URL /pipermail/libaries/2007-April was not found on this server.
17:56:10 <sorear> *grr*
17:56:12 <robreim> dcoutts: Say a typeclass was made which made fromStringable possible in a similar way to fromIntegral. I understand fromIntegral passes everything through the Integer type. What do you think should be the pivotal type for strings?
17:56:32 <dcoutts> robreim: String presumably
17:56:37 <sorear> dcoutts:  I'm not sure this really makes sense.  -- this is it, I think
17:57:41 <robreim> dcoutts: pardon my ignorance, but when converting between strict and lazy bytestrings are conversions to String the best way to do it?
17:57:52 <dcoutts> robreim: no :-)
17:58:06 <dcoutts> robreim: but you can optimise all the conversion as the fromIntegral system does
17:58:08 <robreim> I was thinking perhaps strict ByteStrings might be the best since it's generally more efficient but no less general?
17:58:13 <robreim> fair enough
17:58:24 <dcoutts> robreim: it is less general, it doesn't do unicode
17:58:32 <robreim> ah, good point
17:58:48 <procyon112> ?hoogle replicateM
17:58:49 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
17:58:49 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
17:59:11 <wolverian> http://worrydream.com/MagicInk/ -- heh, there's a book called "The Little Schemer" and its description is "An elephant journeys to find Lambda the Ultimate." in one of the example graphics
17:59:13 <lambdabot> Title: Magic Ink: Information Software and the Graphical Interface
18:00:00 <sorear> the question "does bytestring do unicode?" does not type check
18:00:12 <sorear> unicode is not a property of bytes
18:00:38 <dcoutts> sorear: the nice thing about String is that it doesn't use an encoding of Unicode
18:01:02 <dcoutts> it is a sequence of code points rather than an encoding into a sequence of bytes
18:01:10 <sorear> String does use an encoding, but it is just an implementation detail.
18:01:13 <sorear> UTF-32
18:01:16 <dcoutts> nope
18:01:19 <sorear> ?
18:01:30 <dcoutts> it's a sequence of code points
18:01:42 <robreim> you mean a bunch of lazy thunks?
18:01:48 <dcoutts> which bears a remarkable similarity to UTF-32
18:01:51 <sorear> wait, I thought my memory only stored bytes
18:02:22 <sjanssen> sorear: UTF-32 specifies an encoding into sequences of bytes.  An [Char] is not a sequence of bytes
18:02:37 <dcoutts> sjanssen: thanks, that's clearer
18:02:41 <sorear> sjanssen: I think we are talking implementation
18:02:59 <sorear> [char]'s encoding is not user visible
18:03:05 <dcoutts> sorear: yes it is!
18:03:10 <dcoutts> type String = [Char]
18:03:11 <sjanssen> sorear: UTF-32 is a very concrete thing, [] isn't
18:03:19 <dcoutts> Char is a unicode code point
18:03:24 <dcoutts> that's how it is specified
18:03:50 <sorear> dcoutts: if the compiler decided tomorrow to store Char with all bits flipped (a different encoding!) and changed the accessors appropriately, you would not notice.
18:04:01 <dcoutts> the whole problem with String is that the whole thing is user visible :-) there's no implementation hiding at all
18:04:08 <sorear> and please don't mention unsafeCoerce#
18:04:14 <narain> > ord '‡§∞'
18:04:14 <lambdabot>  Improperly terminated character constant
18:04:15 <sorear> IMO the ONLY place encodings should
18:04:19 <sjanssen> sorear: umm, isn't that a very clear argument that says [Char] /= UTF-32?
18:04:25 <dcoutts> sorear: you're right I would not notice if Char was sored differently
18:04:39 <sorear> <dcoutts> sorear: the nice thing about String is that it doesn't use an encoding of Unicode
18:04:57 <sorear> sjanssen: to me the word 'use' implies that the topic is implementation details.
18:05:20 <sorear> I agree that semantically, [Char] has no encoding.
18:05:31 <sjanssen> we're splitting hairs, really
18:05:44 <dcoutts> sorear: but doesn't that make my point, you could change the way char is stored therefore String it can't be the same thing as UTF-32 which has a precise definition in terms of sequences of bytes.
18:06:05 <dcoutts> hence String is a good interchange format for strings
18:06:26 <sorear> Ok.  I understand now.
18:07:15 <sorear> Even utf8 compactstring works - it advertises an implementation, but then so does Map - but a compactstring is logically a sequence of code points too
18:07:21 <sorear> if I understand you
18:08:23 <sjanssen> sure, anything that can represent the full unicode range is a potential candidate for a conversion base
18:09:06 <dcoutts> sjanssen: and since String is at the root of the dependency tree it's probably the best candidate
18:09:22 <dcoutts> every string type needs to convert to and from the one true String
18:10:10 <dcoutts> So we just need to add another class to Data.String and then a conversion operator and a bunch of rules to optimise the conversions
18:10:11 <sorear> dcoutts: As I suddenly realize that in a few months String will be by far the most efficient conversion base :)
18:10:14 <dcoutts> like fromIntegral
18:10:19 <sorear> fusion!
18:10:27 <dcoutts> well, there's that too
18:10:43 <sjanssen> String also has the best story for laziness
18:10:48 <dcoutts> yes
18:11:10 <dcoutts> sjanssen: want to make a proposal? add another class with toString into Data.String
18:11:32 <dcoutts> sjanssen: you might want to rename the IsString class while you're at it, it's not used much yes so there is still time
18:11:33 <sorear> don't we already ha
18:11:41 <sorear> beh, nm, show would NOT work here
18:12:10 <sorear> my nubulator misfired on class A a where toString :: a -> String
18:12:14 <dcoutts> sjanssen: the two classes would be independent, and a convert string op would use both type classes
18:12:32 <chessguy> can monads be explained completely in terms of type theory?
18:12:44 <sorear> yes, see modal logic
18:13:00 <chessguy> monads are modal?
18:13:12 <sorear> I've only heard of it, not studied it.
18:13:27 <dcoutts> sjanssen: then we'd add rules like convertString = id :: String -> String  and other similar rules in the ByteString modules
18:14:17 <dcoutts> sjanssen: hmm, perhaps we don't need a toString at all
18:14:23 <procyon112> @djinn a->(b->c->d)->(b->c)->b->d
18:14:24 <lambdabot> f _ a b c = a c (b c)
18:14:45 <sjanssen> dcoutts: why don't we need toString?
18:15:15 <chessguy> @djinn ( a -> Bool ) -> ( a -> b -> a ) -> a -> [b] -> a
18:15:16 <lambdabot> f _ _ a _ = a
18:15:20 <sorear> dcoutts: how about a -Wunfused-list flag, since [Char] sucks in the heap? ;)
18:15:56 <dcoutts> sjanssen: mm, maybe we do. I was getting confused
18:16:24 <chessguy> ?seen ski
18:16:25 <lambdabot> ski is in #oasis, #haskell-blah and #haskell. I last heard ski speak 15h 19m 57s ago.
18:24:46 <robreim> dcoutts: actually, I was just toying with the String class you're talking about now and was wondering how to optimise. I'm looking at implementing the efficient conversion between strict and lazy bytestrings. How can I optimise this when I can't pattern match the return value?
18:25:32 <dcoutts> robreim: rules
18:25:40 <dmead> dcoutts: i have a typing question for you
18:25:57 <dcoutts> dmead: sorry, I really should be writing this paper
18:26:07 <hpaste>  dmead pasted "very verbose FOL" at http://hpaste.org/1274
18:26:08 <dcoutts> ask me in 20 hours :-)
18:26:13 <dmead> hehe k
18:26:30 <dmead> anyone who know typing really well
18:26:40 <dmead> could maybe look
18:26:43 <dmead> if they were nice
18:29:30 <robreim> Oooh, a new toy. I just found an example of rules in the definition of fromIntegral in GHC.Float
18:30:08 <dmead> sorear around?
18:31:48 <chessguy> dmead: what's your question?
18:32:05 <dmead> in that hpaste
18:32:20 <dmead> i have defintions of a FOL representation
18:32:22 <dmead> but
18:32:27 <dmead> theres some clumsiness to it
18:32:28 <dmead> like
18:32:38 <chessguy> does it even compile?
18:32:40 <dmead> yes
18:33:49 <dmead> i'm trying to simplifiy it but keep a set of propositional constructors and another of predicate constructors seperate from the formula definition
18:34:09 <dmead> ie
18:34:10 <int-e> dmead: I'd probably call :& :/\ for symmetry
18:34:28 <dmead> i'll have it mapped to a nice show function later
18:34:38 <dmead> and a parsec configuration
18:34:50 <dmead> for output and input repectively
18:36:06 <monochrom> I admire dcoutts for being able to write a paper in just 20 hours :)
18:36:19 <dmead> depends what kind of paper :P
18:38:58 <chessguy> dmead: i still don't really know what you're asking
18:39:51 <dons> ?yow!
18:39:52 <lambdabot> Yow!  We're going to a new disco!
18:40:11 <monochrom> OK, it looks good. There are several design decisions you can change.
18:40:12 <dmead> :o
18:40:24 <dmead> Actually
18:40:39 <dmead> now i need to know how to give a type to all the uppercase characters
18:40:49 <monochrom> One thing I tend to do is merge Quantifier into Formula, i.e., Formula = ... | Forall Formula | Some Formula | ...
18:41:06 <dmead> ah yes
18:41:17 * int-e wonders if the Forall or Some should take a variable name or something
18:41:20 <dmead> quantifiers would never need to be pattern matched on their own
18:41:36 <dmead> they take a forumla
18:41:43 <dmead> Forall <formula>
18:41:44 <dmead> or
18:41:48 <dmead> Some <formula>
18:41:49 <int-e> yes, so forall a. a  is encoded how?
18:41:58 <int-e> but I'm making assumptions :)
18:42:04 <dmead> forall is a haskell function
18:42:09 <dmead> Forall is my data constructor
18:42:19 <chessguy> ?hoogle forall
18:42:20 <lambdabot> Prelude.forall :: keyword
18:42:20 <lambdabot> Test.QuickCheck.forAll :: (Show a, Testable b) => Gen a -> (a -> b) -> Property
18:42:20 <lambdabot> Language.Haskell.TH.forallT :: [Name] -> CxtQ -> TypeQ -> TypeQ
18:42:27 <chessguy> that's not a function :)
18:42:32 <int-e> dmead: that's not my point.
18:42:39 <monochrom> Clearly we mean the logical universal quantifier there.
18:42:49 <dmead> hehe k
18:43:01 <monochrom> How do you say "every man is a chick"?
18:43:14 <dmead> let me think
18:43:29 <dmead> (to get it into this syntax)
18:43:58 <monochrom> I may write ‚àÄx. men(x) ‚áí chick(x)
18:44:23 <dmead> Forall ( MakePred (M, [x]) :-> MakePred(C,[x])
18:44:24 <dmead> ahh
18:44:35 <dmead> i am missing a bit in the quantifier
18:44:48 <dmead> Forall ( MakePred (M, [x]) :-> MakePred(C,[x]) )
18:44:51 <dmead> ^ missing a )
18:45:13 <yaarg> .
18:45:14 <dmead> actually...
18:45:15 <dmead> it's
18:45:24 <dmead> Forall ( MakePred (P,  [x]) :-> MakePred(Q,[x]) )
18:45:38 <dmead> i can't think of a cleaner way to represent a predicate
18:45:42 <dmead> other than a tuple like that
18:45:53 <chessguy> i think you want to say Forall x ( MakePred (M, x) :-> MakePred (C,x))
18:45:57 <dmead> yes, i do
18:46:07 <dmead> but i need to have a datatype for variables first
18:46:19 <dmead> and didn't make a spot in quantifier for the x in forall x
18:46:32 <dmead> thats it!
18:46:35 <dmead> i'm learning prolog!
18:46:47 <chessguy> haha
18:47:33 <int-e> . o O ( he'll be back )
18:47:48 <dmead> do you guys know how to use newtype to create a type of all the upper case letters?
18:47:58 <monochrom> Have you considered merging Predicate into Formula?  Formula = ... | Pred Char [Char]
18:48:01 <dmead> theres a constructor in data.char but its like not used anywhere
18:48:06 <procyon112> chessguy: Whoa.. refactoring some of this code, I think I may end up being able to express an entire GP run as a backtracking list Monad... scary
18:48:16 <dmead> i have
18:48:18 <chessguy> procyon112: hmmm
18:48:22 <int-e> data UC = A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z
18:48:35 <dmead> thats not too nice :<
18:48:53 <chessguy> procyon112: don't you use some flexibility then the evolution strategy?
18:49:07 <monochrom> why uppercase?
18:49:17 <dmead> to express propositional classes and predicate names
18:49:24 <procyon112> chessguy:  I'm looking at making the crossover function return a randomly ordered lazy list of all possible crossovers
18:49:32 <dmead> hold on
18:49:35 <dmead> making changes
18:49:53 <monochrom> Shouldn't you just write the parser to reject lowercase, and forget about it?
18:49:59 <int-e> dmead: you can define  newtype UC = UC Char, and provide a mkUC :: Char -> Maybe UC smart constructor and fromUC :: UC -> Char
18:50:18 <procyon112> chessguy: And my tree generator returns a randomly ordered list of all possible trees
18:50:19 <int-e> dmead: but before you do that answer the question whether it's worth the effort :)
18:50:34 <dmead> ah
18:50:34 <dmead> hmm
18:50:43 <dmead> i was thinking in terms of something more concise
18:50:44 <dmead> as in
18:50:45 <dmead> Char
18:50:49 <dmead> we should also have
18:50:50 <dmead> Upper
18:50:51 <dmead> or
18:50:52 <dmead> Lower
18:51:05 <chessguy> procyon112: that sounds awesome
18:51:42 <procyon112> chessguy: so it's starting to look like we could make a lazy list of crossovers of lazy lists of trees....  Possibly abstracting the whole GP process into a demented zipWith.
18:52:10 <chessguy> in haskell, dementia is fine :)
18:53:30 <monochrom> I dunno. Next you're going to say that a predicate symbol comes with a known arity, so a formula should give it the exact number of arguments, therefore in Predicate you want something better than [Char], you want statically-checked list length...  Oh but the length depends on the predicate symbol, so you want to statically find out the assigned arity of the predicate symbol, then use it to statically check the argument lengt
18:53:30 <monochrom> h...
18:53:36 <procyon112> chessguy: But if I abstract too far, the concepts of "generation" and "population" might be abstracted away... I don't think that's a bad thing, but it won't be GP anymore, just isomorphic to it
18:53:46 <monochrom> There seems to be no end to your restrictions.
18:54:04 <monochrom> 24 hours later you will ask how to prove or disprove a formula statically.
18:54:04 <dmead> mmm
18:54:11 <dmead> :P
18:54:17 <dmead> ahhh i'm not sure what you mean
18:54:32 <dmead> the number of variables you can pass to a predicate doesn't have restrictions
18:54:35 <dmead> Pxyz
18:54:43 <dmead> Pxzysajdhfgs
18:54:48 <dmead> both are valid
18:55:02 <dmead> thats what i used a [Char] list
18:55:12 <monochrom> "data TrueFormula = ....   how do I complete this data declaration to ensure that all and only true FOL formulas are represented?  I so need dependent typing!"
18:55:25 <chessguy> dmead: x is not the same as 'x'
18:55:49 <dmead> well sure
18:56:11 <procyon112> chessguy: "problemSolution = head $ zipWith fitness allPossiblePrograms searchStrategies" doesn't really seem very GPish :)
18:56:33 <chessguy> what's searchStrategies
18:56:47 <procyon112> chessguy: crossover/mutation...
18:56:49 <dmead> this is turning out to be rather circular instead of just dependant
18:57:34 <chessguy> procyon112: there's a lot more to evolution strategy than just the reproduction operators
18:57:57 <procyon112> chessguy: I know... I'm oversimplifying because I don'
18:58:02 <monochrom> people love reproduction.
18:58:06 <dmead> :P
18:58:11 <procyon112> t know how far backtracking will take the abstraction
18:58:32 <chessguy> hm
18:58:58 <sorear> .
18:59:04 <sorear> dmead: pong
18:59:06 <narain> is there any point defining something to be a monad if i may never need to use it as one?
18:59:10 <dmead> ping
18:59:24 <chessguy> @quote backwards
18:59:25 <lambdabot> No quotes match. My pet ferret can type better than you!
18:59:41 <procyon112> chessguy: I'm just saying, that it may be possible to express the entire algorithm as a lazy list sorted by fitness.. at which point, it's more like fuzzy unification than GP.
19:00:00 <monochrom> monad is rather special - you will most likely want to use it as a monad in the near future. I would say define the monad.
19:00:15 <chessguy> procyon112: ohhhhhh, now i get what you're saying. sorry
19:00:30 <chessguy> (light bulb goes off)
19:01:04 <dmead> it's just a jump to the left
19:01:18 <narain> monochrom: ok, now i'll have to be on the lookout for opportunities for using monadic operations
19:01:19 <chessguy> procyon112: mmm, i don't think that's likely to be very useful
19:02:18 <monochrom> heh, sounds like I've spewed a self-fulfilling prophecy!
19:03:08 <dmead> is a forumla a valid parameter to pass to a predicate?
19:03:09 <procyon112> chessguy: so, being aware that we may be able to factor out primary tenets of what makes GP GP, we need to stop at that point, leave GP in place, and do the factorization on the side, as an option... otherwise our GP lib will be some other form of problem solving that is isomorphic to GP, but not useful to people who just want GP.
19:03:45 <chessguy> i don't think it is isomorphic
19:04:22 <procyon112> chessguy: don't think it's isomorphic to what?
19:04:29 <chessguy> to GP
19:05:05 <procyon112> chessguy: no.. my question was on the other side of the arrow :)  You don't think GP is isomorphic to....
19:05:21 <phoniq> foo a b = a ** b
19:05:27 <phoniq> foo :: forall a. (Floating a) => a -> a -> a
19:05:30 <chessguy> ugh
19:05:40 <phoniq> how can i restrict this so that the first arg is integral?
19:05:46 <chessguy> i don't think GP is isomorphic to your zipWith think
19:05:50 <chessguy> *thing
19:06:02 <int-e> phoniq: that will make them all integral
19:06:04 <chessguy> ?hoogle Integral
19:06:05 <lambdabot> Prelude.Integral :: class (Real a, Enum a) => Integral a
19:06:05 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
19:06:08 <int-e> phoniq: because the types are equal
19:06:11 <monochrom> dmead: in most logics no.  but in most logics there is an expression language (function symbols, constants, vars) and any expression is fair game in predicate arguments, e.g., forall x. isChick( father(x) ), isChick predicate, father function
19:06:15 <phoniq> ah
19:06:22 <phoniq> the type signature is just what ghci tells me
19:06:32 <dmead> ahh
19:06:35 <phoniq> what ought it be is the question...   old man C is getting his ass kicked
19:07:07 <chessguy> procyon112: your zipWith thing basically says to generate all possible programs in random order and find the best one you can (correct me if i'm wrong). that's very different from what GP does
19:07:14 <phoniq> that's what i've managed to boil the problem down to.
19:07:15 <procyon112> chessguy: I haven't invented the zipWith, that's just wild speculation, but I think parts of GP can be expressed lazily, to the point where anyone using the code would not recognize it as GP anymore.
19:07:34 <chessguy> perhaps
19:07:37 <int-e> phoniq: just convert the first argument using fromIntegral
19:07:55 <int-e> > fromIntegral (length [1,2,3]) ** 2.3
19:07:56 <lambdabot>  12.513502532843182
19:08:00 <chessguy> but as long as we can supply the front end to the user in ways that look like GP, it doesn't matter how we do it behind the scenes
19:08:14 <phoniq> ca-ching
19:08:37 <phoniq> foo :: forall a b. (Floating b, Integral a) => a -> b -> b
19:08:39 <int-e> phoniq: oh and if your exponent is an integer, use ^^ not **; if it is a nonnegative integer, use ^
19:08:49 <phoniq> yah, it's a float
19:09:04 <procyon112> chessguy:  I suppose.  Is the purpose to be a model GP teaching lib, or a highly abstract applied GP lib?
19:09:08 <phoniq> as in
19:09:16 <phoniq> pmf k n p = (nchoosek n k) * (p**k) * ((1-p)**(n-k))
19:09:20 <phoniq> probability mass function
19:09:37 <chessguy> procyon112: i would like to see the latter, with emphasis on flexibility
19:09:47 <int-e> I'd try  pmf k n p = fromIntegral (nchoosek n k) * (p^k) * ((1-p)^(n-k))
19:10:18 <int-e> (assuming that nchoosek is of type Integer -> Integer -> Integer or similar)
19:10:39 <int-e> @type (^)
19:10:41 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
19:10:53 <procyon112> chessguy: ok.  Right now I have a function "return all programs, in random order" and I just use head to grab the first one... this is my random tree generator.
19:10:58 <dmead> oof
19:10:59 <phoniq> yah.  just saw something else, too.  thanks.
19:11:08 <dmead> i'm looking at the other FOL prover on the wiki
19:11:08 <chessguy> procyon112: ok
19:11:16 <dmead> and he delegates like everything to strings
19:11:32 <chessguy> dmead: link?
19:11:45 <dmead> http://www.cs.yale.edu/homes/cc392/report.html
19:11:51 <lambdabot> Title: First-Order Logic Resolution Theorem Prover In Haskell
19:11:53 <procyon112> chessguy: next I am looking at "given 2 programs, return all possible crossed-over programs in random order".. then I take the head.. that's my reproduction.
19:11:58 <dmead> i'm trying to keep my representation in haskell code
19:12:09 <dmead> he's got a correct structure, but it all maps down to strings
19:12:10 <chessguy> procyon112: ok
19:12:35 <monochrom> hah, string is too crude
19:12:38 <dmead> yea
19:12:41 <dmead> brb
19:12:45 * dmead is away: coffee break
19:13:28 <procyon112> chessguy: I can easily see that we can combine these, and make a function that is "return all possible crossovers of all possible programs"
19:13:59 <chessguy> ermm
19:14:08 <chessguy> wouldn't that just be all possible programs again?
19:14:58 <phoniq> is there a way to get ghc to show you what it is doing as it inferrs type?
19:15:08 <procyon112> chessguy: Yes, but it's not a big leap to imagine, that in the generating of this list, we may be able to use the fitness function to semi-order the list of all programs, moving higher fitness programs progrssively towards the front.
19:15:49 <chessguy> hmm
19:16:44 <procyon112> chessguy: At which point, the parameter to this function is "how hard should I look" and the output is a lazy list of all programs, semi-sorted with the most fit found individual at the head.
19:17:45 <chessguy> procyon112: but now you're losing your gp-ness
19:18:33 <monochrom> phoniq: heh, unfortunately no
19:18:40 <procyon112> chessguy: Exactly!  The algorithm might do the exact thing as gp, but at some point, it's not really gp anymore :)
19:19:39 <chessguy> procyon112: well personally, i love all the abstraction stuff, but i want to provide a front end that "looks" like GP, that gives the client the ability to mix and match evolutionary strategies, etc.
19:19:52 <phoniq> that'd be a pretty cool thing
19:20:43 <monochrom> Yeah!
19:20:59 <procyon112> chessguy: Agreed.  But I don't want that to keep us from exploring a lazy isomorphism to GP if we find ourselves discovering one...
19:21:39 <chessguy> procyon112: i still don't think they're quite isomorphic
19:24:16 <chessguy> procyon112: i'm willing to explore with you though!
19:24:36 <procyon112> chessguy: Possibly a GP monad ;)
19:24:44 <chessguy> now that would be cool
19:25:35 <chessguy> so what's next?
19:26:10 <procyon112> chessguy: integration.  I'll work on that this weekend.
19:26:23 <chessguy> ok, cool
19:28:13 <procyon112> I'll have to see how much overlap between the 2 systems I can maintain (I think all of it will overlap)... Otherwise, for things that don't I'll have to come up with a way to select between options in the framework you have provided.
19:28:36 <chessguy> we can always scrap my code too.
19:30:07 <procyon112> chessguy: I like your monomorphic rose trees though... those are more textbook than my strongly typed, functions as terminals trees, which are MUCH more experimental and barely documented.
19:30:57 <chessguy> experimental doesn't mean bad
19:31:10 <procyon112> I want to have the ability to do both though
19:31:21 <chessguy> fair enough
19:32:31 <chessguy> i have to admit, there are parts of my code i'm quite fond of :)
19:35:11 <procyon112> gotta go now. night.
19:35:13 <chessguy> 'night
19:39:42 * SamB_XP wonders if virtual floppy disk software shouldn't simulate the clicking sound a bit
19:40:11 <c> ive got IBM HDs to supply the clicks
19:40:30 <c> lately the deathstar (replaced once) has been making weird 'singing' sounds
19:40:39 <c> like the platter rubbing against the enclosure or something
19:40:42 <SamB_XP> you know, so you don't think it is not working just because it makes no noise?
19:40:45 <gustavderdrache> hehe
19:41:43 <sorear> SamB_XP: old PC BIOSes were programmed to simulate a click on every keypress ;)
19:41:52 <SamB_XP> sorear: really?
19:41:54 <sorear> guess too many people missed typewriters
19:42:02 <SamB_XP> because my keyboard already clicks
19:42:09 <sorear> SamB_XP: i've inferred it from the RBIL
19:42:20 <SamB_XP> they must have had low-quality keyboards back then
19:42:25 <SamB_XP> what entry is that?
19:42:26 <sorear> SamB_XP: SET KEYCLICK VOLUME  supervisor calls
19:42:57 <sorear> I haven't had a chance to look anything up in RBIL since the last time I replaced my hd :)
19:43:09 <sorear> linux++
19:43:14 <sorear> man++
19:43:37 <SamB_XP> I see something about PC Jr.
19:43:42 <sorear> (or were you asking what RBIL is?)
19:43:50 <sorear> oh ok, that proves you know ;)
19:43:56 <SamB_XP> and something about HP Vectra
19:44:06 <SamB_XP> I had the RBIL viewer open already
19:44:35 <sorear> I'll admit to not keeping careful track of what the system fields were
19:44:51 <SamB_XP> so, maybe those had bad keyboards
19:45:03 <sorear> SamB_XP: ooh, what kind of excuse do you have? (direct port access in zsnes?)
19:45:33 <SamB_XP> oh. I was trying to un-break a videogame that someone seems to have broken in an attempt to crack
19:47:03 <SamB_XP> i.e. playing with IDA 3.05
19:47:30 <SamB_XP> which unfortunately is not infallible and does not support reading RBIL directly
19:48:00 <sorear> > id . id : []
19:48:01 <lambdabot>  Add a type signature
19:49:27 <luis> style question: do you usually use identifiers_like_this or idsLikeThis?
19:49:50 <sorear> a_b_c when I cna get away with it
19:49:51 <jcreigh> usually the latter
19:49:53 <sjanssen> likeThis
19:50:16 <sjanssen> luis: thatIsStandardHaskellConventionAsEvidencedByTheStandardLibraries
19:50:23 <SamB_XP> sorear: do you like the glasses minor mode then?
19:50:36 <luis> sjanssen: thanks
19:50:56 <sorear> SamB_XP: I also like mg compatibility ;)
19:52:59 <sorear> let { go '`' (a:b:r) = (:) '(' . a . (:) ' ' . b . (:) ')' : r ; go x r = if isAlpha r then (:) x : r else r } in ($")(\_->return())}") . (++) "{import Runtime;main=unU(" . foldr go [] $ "```sii``sii"
19:53:05 <sorear> > let { go '`' (a:b:r) = (:) '(' . a . (:) ' ' . b . (:) ')' : r ; go x r = if isAlpha r then (:) x : r else r } in ($")(\_->return())}") . (++) "{import Runtime;main=unU(" . foldr go [] $ "```sii``sii"
19:53:06 <lambdabot>  Illegal escape sequence
19:53:15 <sorear> > let { go '`' (a:b:r) = (:) '(' . a . (:) ' ' . b . (:) ')' : r ; go x r = if isAlpha r then (:) x : r else r } in ($")(\\_->return())}") . (++) "{import Runtime;main=unU(" . foldr go [] $ "```sii``sii"
19:53:17 <lambdabot>  Couldn't match expected type `[Char] -> b'
19:54:12 <sorear> > let { go '`' (a:b:r) = ((:) '(' . a . (:) ' ' . b . (:) ')') : r ; go x r = if isAlpha r then (:) x : r else r } in ($")(\\_->return())}") . (++) "{import Runtime;main=unU(" . foldr go [] $ "```sii``sii"
19:54:13 <lambdabot>  Couldn't match expected type `[Char] -> b'
19:54:21 <sorear> > let { go '`' (a:b:r) = ((:) '(' . a . (:) ' ' . b . (:) ')') : r ; go x r = if isAlpha x then (:) x : r else r } in ($")(\\_->return())}") . (++) "{import Runtime;main=unU(" . foldr go [] $ "```sii``sii"
19:54:22 <lambdabot>  Couldn't match expected type `Char'
19:56:07 <sioraiocht> how would I get fptools using darcs?
19:56:25 <chessguy> ?where fptools
19:56:25 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/building/sec-cvs.html
19:56:29 <sioraiocht> thanks
19:56:41 <sorear> getting fptools is a bad idea
19:56:44 <sioraiocht> y?
19:56:55 <sorear> fptools is ancient and we want to get rid of it
19:56:59 <sioraiocht> lol oh
19:57:01 <sorear> cabal is the way forward
19:57:09 <chessguy> sioraiocht: that wasn't necessarily an answer to your question
19:57:16 <sorear> currently, exactly one program is still using fptools
19:57:26 <sioraiocht> kk
19:57:29 <sjanssen> fptools barely exists anyway
19:57:38 <sjanssen> sioraiocht: is there something specific you're looking for?
19:57:42 <chessguy> sorear: what program?
19:57:50 <sioraiocht> sjanssen: no
19:57:56 <emu> fptools itself!
19:57:58 <sorear> chessguy: The Glorious Glasgow Haskell Compilation System
19:58:06 <chessguy> wow
19:58:12 <chessguy> that's sad
19:58:14 * sorear realises chessguy probably would have understood 'ghc'
19:58:19 <emu> enough Gs?
19:58:21 <sioraiocht> hahah
19:58:25 <sioraiocht> GGHCS?
19:58:30 <sjanssen> ghc doesn't really use fptools
19:58:34 <chessguy> ?vera ghc
19:58:36 <lambdabot> No match for "ghc".
19:58:40 <chessguy> boooooooooooo!
19:58:52 <chessguy> @slap herself
19:58:53 * lambdabot slaps herself
20:00:37 <sorear> > let { go '`' (a:b:r) = ((:) '(' . a . (:) ' ' . b . (:) ')') : r ; go x r = if isAlpha x then (:) x : r else r } in ($")(\\_->return())}") . (++) "{import Runtime;main=unU(" . (\[x]->x) . foldr go [] $ "```sii``sii"
20:00:38 <lambdabot>  Couldn't match expected type `[Char]'
20:00:45 <SamB_XP> grrr.
20:00:53 <SamB_XP> assign doesn't seem to work in XP...
20:03:35 <sorear> WOW...
20:04:01 <sorear> I just wrote a program to parse unlambda, by reversing it with foldr and using a stack
20:04:05 <sorear> laziness++
20:04:24 <sorear> dumbfounding that it works, I was just trying for conciseness...
20:30:01 <sorear> Are there any compute-boudn unlambda programs?
20:36:58 <olliej> sorear: unlambda?
20:37:13 <sorear> yes
20:37:25 <sorear> I've written the first compiler ever for it
20:37:37 * olliej googles
20:37:45 <sorear> now to see how mine + hugs compares to a C interpreter ;)
20:40:09 <olliej> sorear: !! why oh why would you do such a thing???
20:40:34 <sorear> because I like feeling smarter than people!
20:40:58 <sorear> david madore thinks this language is compiler-proof.  he's wrong.
20:42:56 <olliej> sorear: uh huh
20:43:10 <olliej> sorear: how few lines did you get it down to?
20:44:17 <sorear> not trying yet
20:44:39 <sorear> actually, I'm not going to be able to make a fair test
20:44:45 <sorear> I'm compiling to haskell
20:45:12 <sorear> and out of the three portable reliable compilers, two are slow and one has a fatal bug
20:45:28 <olliej> bugger
20:46:07 <glguy> that's a shame, how ever will people run their unlambda programs in a diverse setting?
20:47:02 <sorear> yay!
20:47:10 <sorear> ghci crashed again
20:47:32 <sorear> strangley it was a runtime crash
20:47:35 <Gwern> sorear: you realize, of course, that you're only reinforcing the stereotype that haskell is good for compiler and language research but nothing else :)
20:47:41 <sorear> the bug would have mad the typechecker explode
20:47:55 <xpika> ghci often crashes for me, but compiled files not so much
20:48:17 <xpika> especially when i run FFI packages
20:50:27 <sorear> > 32784384 / 2306048
20:50:29 <lambdabot>  14.216696269982238
20:50:43 <sorear> ok, my compiler is fourteen times faster than the refernce interpreter
20:51:48 <stepcut> sorear: can you make a convincing argument that it is a compiler ?
20:52:28 <sorear> stepcut: no, nor can I make such an argument for GHC
20:52:46 <sorear> both are heavily optimized interpreter generators
20:53:00 <stepcut> sorear: I can agree with that view
20:53:06 <olliej> sorear: stg ftw!
20:54:06 * sorear looks at core in a fit of lunacy
20:54:21 <olliej> sorear: core is perfectly readable
20:54:59 <sorear> olliej: even English is unreadable when there are six thousand lines of it and no section marks :)
20:55:05 <olliej> hehehe
20:55:15 <olliej> sorear: excuses :D
20:55:16 <stepcut> sorear: although, if ghc is compiling code that is entirely unboxed -- it seems like it is easier to argue that it is a compiler
20:55:44 * jcreigh makes a cunning argument based on it having "compiler" in the name
20:56:00 <glguy> sorear: quick, change your compiler's name!
20:56:00 <jcreigh> and it's fast, too.
20:56:10 <olliej> stepcut: well, even unboxed it's still just doing graph reduction
20:56:21 <olliej> eg. "interpreting"
20:56:43 <sorear> jcreigh: I haven't tried half my tricks yet ;)
20:57:00 <jcreigh> all discussion is pedantry
20:58:00 <jcreigh> I was talking about GHC...I don't know whether your code is a compiler, but I certainly think GHC is.
20:58:22 <sorear> > 50880512 / 2306048
20:58:24 <lambdabot>  22.063943161634104
20:58:48 <olliej> sorear: does unlambda support io at all?
20:58:51 <sorear> with a little help from -funfolding-use-threshold=1000 -funfolding-creation-threshold=1000, my code is now 22 times faster than the C interpreter!
20:58:53 <sorear> olliej: yes
20:59:13 <sorear> olliej: indeed, those numbers are "characters written by (cpu bound program) in 30s)
20:59:19 <stepcut> sorear: what about -O11 ?
20:59:29 <sorear> not released ;)
20:59:57 <glguy> stepcut: is -O11 provided in a patch to Gentoo's gcc?
21:00:39 <stepcut> glguy: no, ndm's patch to yhc
21:00:56 <xpika> > sum . map (\k -> (4*(-1)**(k+1))/(2*k-1) ) $ [1..100000]
21:00:57 <lambdabot>  3.1415826535897198
21:01:07 * stepcut goes off to eat dinner
21:01:15 <glguy> > iterate (\x -> x + sin x) 1
21:01:17 <lambdabot>  [1.0,1.8414709848078965,2.80506170934973,3.135276332899716,3.141592611590653...
21:01:20 * sorear rewrites the "RTS" using State#
21:01:20 <monochrom> sorear: congratulations! you're cunning.
21:01:45 <xpika> glguy: sin is cheating
21:02:00 <xpika> > 4*atan 1
21:02:01 <glguy> xpika: there are no rules!
21:02:02 <lambdabot>  3.141592653589793
21:02:02 <chessguy> @pl \k -> (4*(-1)**(k+1))/(2*k-1)
21:02:03 <lambdabot> ap ((/) . (4 *) . (subtract 1 **) . (1 +)) (subtract 1 . (2 *))
21:02:11 <stepcut> > pi
21:02:13 <monochrom> Eh! A fixed point formula for pi!
21:02:13 <lambdabot>  3.141592653589793
21:02:19 <stepcut> yay! I win!
21:02:20 <sorear> once you think about it in the right way, it's obviously compilable
21:02:33 <sorear> ALL my compiler does is translate into infix
21:02:51 <sorear> the RTS module defines unlambda apply/etc operators
21:02:59 <chessguy> > head $ drop 20 $ iterate (\x -> x + sin x) 1
21:03:00 <lambdabot>  3.141592653589793
21:03:03 <sorear> which are hopefully inlined :)
21:03:09 <chessguy> > head $ drop 40 $ iterate (\x -> x + sin x) 1
21:03:11 <lambdabot>  3.141592653589793
21:03:23 <chessguy> not a very good formula
21:03:38 <dons> papers papers papers! yow!
21:03:38 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
21:04:00 <monochrom> If you say "papers" 3 times you get 3 messages?
21:04:21 <sorear> you want me to write a paper on the unlambda compiler!?
21:04:22 <chessguy> dons: how's the soc-project-picking going?
21:05:30 <olliej> sorear: that would be awesome :D
21:06:14 <sjanssen> dons: paper done yet?
21:06:47 <sorear> ghc primops sure are verbose :(
21:09:23 <sorear> I would just like to say -O2, -funfolding-use-threshold=1000, -funfolding-creation-threshold=1000, and contravariant recursive newtypes make for a very volatile combination :)
21:09:33 <sorear> > 50880512 / 2306048
21:09:35 <lambdabot>  22.063943161634104
21:09:46 <sorear> > 50421760 / 2306048
21:09:48 <lambdabot>  21.865008880994672
21:09:51 <sorear> Nice.
21:09:52 <sorear> GHC++
21:09:58 <int-e> sorear: can you compare to http://int-e.home.tlink.de/tmp/unlambda.c ? (use -DNDEBUG when compiling with gcc)
21:10:03 <sorear> manual unboxing made my monad slower!
21:10:42 <sorear> int-e: I wrote an interpreter decently faster than mandleson's, alas it's not on this HD :)
21:11:16 <int-e> sorear: this one is faster, too.
21:12:18 <int-e> sorear: in particular it doesn't copy the whole context on every call/cc - this is what makes mandelson's original *very* slow for one of the quines.
21:12:27 <glguy> what might I need to support rotating my video 180 degrees in Linux?
21:12:29 <sorear> int-e: reference counting?
21:12:39 <sorear> xrandr
21:12:44 <sjanssen> glguy: the extension is xrandr
21:13:00 <sorear> xrandr --help
21:13:11 <sorear> xrandr -x -y
21:13:54 <int-e> sorear: yes. (probably not the best choice actually)
21:13:58 <sorear> int-e: mine didn't do that eiter... mine was actually based on minischeme, but with the switch switched out for a computed goto, and a generational garbage collector added
21:13:59 <glguy> looks like my hardware doesn't support it
21:14:10 <sorear> int-e: generational GC was a HUGE win
21:14:21 <sorear> int-e: slower than c-refcnt to faster than mandleson
21:14:56 <int-e> but this was 6 years ago, I didn't believe in GC back then *g*
21:15:29 <sorear> about 2/3 for me
21:16:10 <dons> sjanssen: there's two papers, both almost done :-)
21:16:15 <dons> but its pretty hectic round here.
21:16:19 <sorear> but still, I doubt either of our interpreters can outperform the spineless tagless G-machine
21:16:27 <sjanssen> dons: two papers?  streams and what else? (if I may ask)
21:17:27 <sorear> int-e: yours stopped early, it was supposed to be 30 seconds of loop
21:17:37 <dons> streams, and runtime-specialised monte carlo simulations, using haskell code generators and dynamic linking
21:17:53 <dons> for high performance numerical tasks
21:18:11 <bos> yum!
21:18:51 <jcreigh> crap. I think we need to move the screen switching bindings...
21:19:01 <sjanssen> jcreigh: how come?
21:19:06 * jcreigh just did mod-shift-q trying to move a window to screen 1...
21:19:12 <hpaste>  robreim pasted "StringClass" at http://hpaste.org/1276
21:19:12 <jcreigh> :)
21:19:30 <sorear> jcreigh: a single key for quit is a disaster waiting to happen.
21:19:31 <robreim> So is that StringClass basically all that's needed to bring all the different String data types together?
21:19:41 <sorear> jcreigh: make quit a long command
21:19:52 <sorear> jcreigh: hey! you could abuse dmenu for that!
21:20:11 <sjanssen> robreim: you might want to separate the toString/fromString
21:20:12 <jcreigh> heh. just have "killall xmonad" as a dmenu entry?
21:20:31 <sorear> int-e: looks like your interpreter is still about 60% faster than my compiler.
21:20:40 * sorear wonders what he could do with RULES
21:20:45 <robreim> sjanssen: how do you mean separate them? Different classes?
21:20:50 <dons> jcreigh: i'd be up for alt-shift-ctrl-q to be quit
21:20:56 <dons> and alt-shift-q to be a harmless restart
21:21:11 <sjanssen> robreim: GHC already has a class with fromString, it's useful for overloaded string literals
21:21:21 <sjanssen> robreim: yeah, two classes
21:21:37 <int-e> sorear: nice :)
21:21:45 <jcreigh> dons: hmm. that could work.
21:21:47 <robreim> sjanssen: oh, cool. Where can I find GHC's fromString?
21:22:02 <sorear> how good is o'caml / smlnj with extremely lambda intensive code?
21:22:21 <int-e> sorear: but also impressive for a haskell program, I've found low level coding in Haskell to be very difficult.
21:23:02 <sjanssen> robreim: it's in the darcs version of the base library.  In GHC.* IIRC
21:23:02 <sorear> don't give me that look
21:23:11 <robreim> thanks
21:23:25 <sorear> my code is strict so I think a language optimized for strict code is better
21:23:40 * sjanssen continues to give sorear that look
21:23:45 <jcreigh> dons: I assume mod-shift-q to quit is a dwm-ism?
21:24:03 <sorear> in general which is the fastest ML?
21:24:15 <sjanssen> robreim: and you'll want to do the RULES a bit differently
21:24:48 <robreim> sjanssen: likely. I only heard about RULES for the first time this morning. What'd I screw up?
21:25:09 <stepcut> sorear: i would guess ocaml or sml/nj ?
21:25:20 * stepcut ponders
21:25:36 <sorear> so is mlton still any good?
21:25:55 <stepcut> sorear: dunno, I only have experience with ocaml
21:26:08 <stepcut> I actually forgot about mlton until after I made my statement
21:26:26 <sjanssen> robreim: it's better to match directly against forall x. toString (fromString x) then convertString, because convertString might be inlined
21:26:31 <sjanssen> s/then/than
21:26:32 * sorear aptgets ocaml
21:27:04 * sorear googles ocaml tutorial
21:27:36 * robreim has scored a job with Jane st Capital so will have to learn all about ocaml soon enough.
21:28:13 <stepcut> sorear: http://gqflp.free.fr/blog/images/ocaml.jpg
21:28:45 * dons inserts more ! into introduction, to jazz things up wadler style
21:29:06 <sjanssen> @yow
21:29:07 <lambdabot> I was born in a Hostess Cupcake factory before the sexual revolution!
21:29:17 <sjanssen> dons: add quotes like these ^^^
21:29:22 * sorear remembers he doesn't usually need tutorials, and reads the ocaml report!
21:29:33 <jcreigh> what paper is this?
21:30:34 <monochrom> "Streams are lazy and fast!"
21:30:37 <xpika> does ocaml actually have anything over haskell?
21:30:59 <dons>  We can finally write the code we \emph{want} to be able to write without
21:30:59 <dons> sacrificing performance!
21:31:00 <dons> :-)
21:31:19 <stepcut> sorear: this is probably the best 'tutorial', the ocaml oreilly book (free, online) -> http://caml.inria.fr/pub/docs/oreilly-book/html/index.html
21:31:21 <lambdabot> Title: Developing applications with Objective Caml
21:31:51 <monochrom> ocaml has subtyping
21:32:27 <xpika> ?
21:32:32 <stepcut> xpika: module functors
21:32:43 <xpika> ??
21:32:52 * xpika googles
21:32:58 <robreim> xpika: from what I've heard, Functors are somehow more general than typeclasses (don't ask me how!) and pattern matching is nicer in ocaml (it supports conditionals for example)
21:34:08 <brad_> a question - lets say i have a module where i am manipulating the contents of a Data.Map...it is considered better style to pass this as a parameter to each function, or to leave it as a module level "global", sorry if this is not enough info
21:34:13 <monochrom> You don't know subtyping? subtyping is as in OOP.
21:34:28 <stepcut> I don't think I felt like I was missing anything when I switched from ocaml to haskell
21:35:13 <monochrom> better to make it a parameter
21:35:44 <xpika> monochrom: inheritance?
21:35:58 <brad_> i tend to agree with you monochrom - otherwise i would have "void" functions (functions doing something but returning nothing of value to caller)
21:36:07 <jcreigh> @seen dmwit
21:36:08 <lambdabot> dmwit is in #haskell-blah and #haskell. I last heard dmwit speak 6h 29m 49s ago.
21:36:19 <jcreigh> where are we at with the xmonad ML?
21:36:46 <stepcut> is there xmonad bug tracking software yet ?
21:37:01 <sjanssen> jcreigh: we shall commence bugging dons with full force tomorrow
21:37:09 <brad_> i presume that it is considered bad form to have somehting akin to a void function in haskell...
21:37:37 <sorear> My first experience with ocaml:
21:37:44 <sorear> # let ap cont1 cont2 = cont1 (fn ()^[[D
21:37:51 <sorear> what! no readline in the repl!!!?
21:38:02 <jcreigh> sorear: rlwrap or socat FTW
21:38:05 <stepcut> sorear: no, use the emacs mode
21:38:15 <monochrom> haha
21:38:53 <monochrom> who doesn't use emacs anyway!
21:39:16 <stepcut> sorear: ocaml also does not have --make or any idea where to find 3rd party libraries. You have to use ocamlfind -- but the ocaml interpreter has a different syntax for using ocamlfind
21:39:57 <sorear> oh, that probably won't be a problem
21:40:10 <sorear> I only need getchar putchar and a single ref
21:40:15 <stepcut> :p
21:40:55 <stepcut> sorear: also, make sure you get the right version of the compiler, I think ocamlc generates bytecode, and ocamlmopt generates native
21:41:21 <hpaste>  robreim annotated "StringClass" with "like this sjanssen?" at http://hpaste.org/1276#a1
21:41:35 <tautologico> sorear: use ledit with the repl
21:42:11 <sorear> ich, no layout rule :)
21:42:13 <stepcut> sorear: if you need backtraces you have to use ocamlc, but for speed, ocamlopt is your friend (though both are fast)
21:42:34 <tautologico> http://wiki.cocan.org/tips_for_using_the_ocaml_toplevel
21:42:36 <lambdabot> Title: Tips for using the OCaml toplevel
21:42:40 <sorear> stepcut: hah. unlambda programs can't crash, the language isn't expressive enough :)
21:43:40 <sorear> match ... with === case ... of ?
21:43:52 <stepcut> sorear: yes
21:44:09 <stepcut> sorear: with some minor differences
21:44:16 <chessguy> i assume FOL has been done in haskell?
21:44:34 <robreim> I'm still not convinced those RULES are being applied for convertString...
21:44:44 <sorear>  # multiply 2 [1; 2; 3];;
21:44:58 <sorear> wait .. shouldn't that eval to [6]?
21:45:04 <sorear> since ; == seq?
21:45:18 <tautologico> nope
21:45:28 <tautologico> [1; 2; 3] is the list [1, 2, 3]
21:45:41 <tautologico> , is the tupling operator in ocaml, not used for lists
21:45:52 <sorear> ah, like the way C overloads , as comma and function-arg-separator
21:46:19 <hpaste>  sjanssen annotated "StringClass" with "better" at http://hpaste.org/1276#a2
21:46:21 <tautologico> [1, 2] is (int * int) list in ocaml
21:46:36 <sorear> I get the concept of "strict type-infered functional language", just a few syntactic quirks to learn ;)
21:46:41 <brad_> thanks for the help, goodbye!
21:47:13 <sorear> tautologico: how does ocaml know list is a postfix type constructor?  (magic? lowercase? all are postfix?)
21:47:15 <sjanssen> robreim: ^^^ be sure to test that first rule
21:47:47 <tautologico> all are postfix
21:48:40 <tautologico> * is tuple type constructor
21:48:41 <tautologico> infix
21:50:08 <sorear> do they have +?
21:50:23 <tautologico> + as in?
21:50:32 <tautologico> sum types?
21:50:40 <sorear> Yeah, `Either`
21:51:08 <tautologico> type suit = Clubs | Hearts | Diamonds | Spades
21:51:28 <tautologico> type Value = IntVal of int | ListVal of int list
21:51:29 <syntaxfree> you want data, not type.
21:51:43 <syntaxfree> ahh. that's not Haskell.
21:51:47 <tautologico> ocaml
21:52:28 <tautologico> tupling is not implicit in variant type constructors, as in haskell
21:52:31 <chessguy> syntaxfree: this channel has apparently turned into #OCaml tonight
21:53:17 <araujo> hello
21:53:19 <chessguy> which means it's definitely time for bed :)
21:53:21 <monochrom> This is because we came to Haskell for its unpopularity. Well Haskell is popular now and OCaml is the next unpopular thing.
21:54:02 <sorear> how do I use socat?
21:54:32 <araujo> @hoogle socat
21:54:33 <lambdabot> No matches found
21:54:44 <sorear> @botsnack
21:54:44 <lambdabot> :)
21:55:02 <tautologico> socat?
21:55:10 <sorear> Yay for emacs.  I just managed to set my channel buffer to CAML mode
21:55:21 <stepcut> haha
21:59:16 <monochrom> Do you usually set it to lhs mode? :)
21:59:34 <sorear> no, (ERC)
21:59:43 <monochrom> So that when you type "> 1+1" for lambdabot you actually get colour? :)
22:00:56 <stepcut> heh, for next april fools, we should have > 1+1 output using mirc colors
22:01:10 <monochrom> haha
22:02:05 <monochrom> It is, however, still in time for an easter egg!
22:02:12 <stepcut> heh
22:02:34 <crazyrk> hello guys
22:08:00 <dmead> oh man
22:08:04 <dmead> this is so ugly
22:08:48 <crazyrk> ?
22:09:54 <hpaste>  dmead pasted "ugly FOL" at http://hpaste.org/1277
22:10:59 <sorear> I expect to have regular brainos on this code.  "But ... why is this being evaluated so early!"
22:11:21 * sorear has written impure lazy code. fun fun fun!
22:11:34 <dmead> sounds like a blast :P
22:12:27 <sjanssen> bleh, why aren't these rules firing?
22:13:04 <andrei> I have a question; Given a tuple (a,b), b is an integer and I want it printed out as a hex value. show will print it out as a decimal. I can do a showHex, but then the show over the whole tuple will add a whole bunch of ""'s since the insides of the tuple are already a string
22:13:08 <andrei> Any way to avoid them?
22:13:22 <andrei> (aside from writing my own showtuple)
22:13:29 <dmead> nope
22:13:34 <dmead> it's not hard to write your own show
22:13:44 <andrei> I know; but it seems.. inelegant
22:13:58 <dmead> well
22:14:02 <dmead> you overload the Show class
22:14:07 <andrei> Just seems like there should be a better solution
22:14:15 <sjanssen> andrei: Show is not meant for pretty printing
22:14:23 <dmead> write a show function, overload show for your type
22:14:32 <dmead> and it will print when you return your type
22:14:52 <andrei> dmead, I know how to do it; just was wondering if there was a better way of doing things
22:15:12 <sorear> awww, no backticks?
22:15:21 <dmead> ?
22:15:53 <dmead> andrei: you could use newtype and have it derive show for you
22:16:00 <sorear> how do you say x `foo` y in ocaml?
22:16:09 <dmead> well
22:16:11 <stepcut> sorear: I don't think you can
22:16:15 <dmead> ML has regulaar infix operators
22:16:29 <stepcut> sorear: or maybe you have to use only special characters in your function name
22:16:32 <sorear> Man, this sucks! I'm going back to Haskell! ;)
22:16:37 <dmead> :P
22:16:46 <dmead> Ocaml is eager right?
22:17:03 <sorear> yeah
22:17:16 <dmead> hmm weird
22:17:27 <shachaf> sorear: 	 $ debugFilter : -- handler that prints all requests and responses on console
22:17:30 <shachaf>        noState : -- handler that defines application to have no persistent state
22:17:35 <dmead> i got my FOL representation working
22:17:37 <dmead> but it's SO ugly
22:17:39 <dmead> and verbose
22:17:43 <shachaf> sorear: http://alan.petitepomme.net/cwn/2006.11.14.html
22:17:45 <lambdabot> Title: Caml Weekly News
22:18:09 <shachaf> sorear: Search for "infix".
22:18:38 <sorear> shachaf: why did you paste happs boilerplate at me?
22:18:43 <tautologico> you have to define an operator as infix, otherwise you can't do like `foo` in ocaml
22:18:53 <sorear> shachaf: any clue why your name won't tab-complete?
22:19:01 <sorear> > "shachaf"
22:19:03 <lambdabot>  "shachaf"
22:19:07 <sorear> > map ord "shachaf"
22:19:08 <lambdabot>  [115,104,97,99,104,97,102]
22:19:12 <dmead> woah
22:19:18 <dmead> i didn't know xchat did tab completion
22:19:20 <dmead> :O
22:19:23 <dmead> cool
22:19:32 <sorear> No completions of sh
22:19:48 <dmead> i got a bunch
22:19:57 <dmead> shachaf,
22:20:06 <dmead> shachaf,
22:20:08 <dmead> shachaf,
22:21:14 <dmwit> dmead: It also has an option to complete in temporal order; people who spoke last get completed first.
22:21:39 <dmead> ah
22:21:49 <tautologico> haskell has a nicer syntax, type classes and it's pure; I like purity. But I rarely miss haskell's laziness when programming in a ml language
22:21:50 <sorear> Having to write all this cps is icky.
22:21:57 <sorear> Where's my Cont monad!
22:22:18 * sorear is just making a big deal of adjustment
22:23:22 <tautologico> you don't need monads, you have side effects :)
22:24:20 <sorear> how do you do nondeterminism or call/cc with just side effects?
22:24:47 <stepcut> sorear: http://okmij.org/ftp/packages/cc-monad.ml
22:24:49 <stepcut> ;)
22:29:41 <sorear> Is there anything in ocaml analagous to newtype?
22:31:37 <tautologico> I guess you can get a similar effect using functors
22:31:38 <stepcut> not that I remember
22:32:02 <tautologico> but no, nothing directly recognizable as newtype
22:32:36 <sorear> this'll make my code soo much more error-prone :(
22:37:02 <dmead> i wonder what the prolog scene is like
22:37:05 <dmead> hmm
22:37:07 <dmead> 20 people
22:39:35 <dons> rockin'!
22:41:02 <dmead> hey dons
22:41:28 <dmead> i came up with a FOL syntax using just type constructors
22:41:47 <dmead> and it takes two lines to say a short formula =/
22:52:00 <robreim> I've never used prolog but it looks like a really nice language. I'd love to know why it never really took off.
23:02:23 <dmwit> ?help name
23:02:23 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:02:32 <dmwit> ?help hname
23:02:33 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:02:39 <dmwit> ?list
23:02:39 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
23:02:53 <dmwit> ?fresh
23:02:53 <lambdabot> Haex
23:03:02 <sorear> @help freshname
23:03:02 <lambdabot> freshname. Return a unique Haskell project name.
23:03:58 <dmwit> ?fresh
23:03:59 <lambdabot> Haey
23:04:04 <dmwit> ....
23:04:13 <dmwit> ?fresh
23:04:14 <lambdabot> Haez
23:04:24 <dmwit> =(
23:04:31 <jyp> ?fresh
23:04:31 <lambdabot> Hafa
23:04:39 <dmwit> That is...
23:04:40 <dmwit> so bad.
23:04:47 <dmwit> Also, pretty great.
23:05:03 <sorear> hi jyp
23:05:12 <jyp> hey sorear
23:05:43 <dmead> robreim: aas i understand it was thought a real AI could be built using it
23:06:27 <stepcut> what the trick for enforcing a /= e in this instance declaration: instance (IsSubset e b) => IsSubset e (a :*: b)
23:06:56 <dmead> pattern guard?
23:07:09 <stepcut> dmead: i mean at the type level
23:07:24 <dmead> i don't think you can
23:07:45 <stepcut> dmead: you can, it's just ugly
23:09:54 <stepcut> hrm, it does involve overlapping-instances
23:10:06 <robreim> dmead: So people stopped using prolog in fear that their programs would become sentient? ;)
23:10:19 <sorear> stepcut: you can't do it portably
23:10:37 <sorear> even ghc vs hugs have different behavor for the same impl of it
23:10:42 <stepcut> sorear: :p
23:10:46 <sorear> both support incoherent instances
23:11:23 <sorear> about half of HList is dedicated to conditionally-compiled TypeEq classes that happen to work on ghc version foo or hugs version bar :(
23:11:32 <stepcut> yeah
23:11:40 * sorear thinks TypeEq or at least :/= should be a primitive type class
23:12:00 * sorear realizes Data.Derive can handle this
23:13:13 <sorear> I'm actually *shudder* starting to get the hang of ml syntax...
23:13:32 <sorear> probably won't typecheck though :)
23:14:06 <sorear> hmm.  is 'to' a reserved word?
23:14:17 * sorear wishes emacs could highlight these things
23:14:26 <stepcut> sorear: tuareg mode
23:14:39 <stepcut> tuareg-mode - An emacs-mode for ocaml programs
23:14:46 <sorear> grr.
23:14:51 <sorear> AHHHH!
23:15:15 <stepcut> i think to is a reserved word, but I don't remember what for
23:15:20 * sorear thinks that pun is extremely bad
23:16:12 <stepcut> :p
23:16:27 <sorear> ocaml has multiple phases too?!
23:16:41 <stepcut> ?
23:16:44 <fuzan> how could I say that a type Kind is of either, Basic | Array | or Function, where Function takes a list of some type wrapped in a monad. I can't seem to get it quite right.
23:16:58 <fuzan> data Kind = Basic | Array | Function StateT [Scope] IO [Type]
23:17:01 <sorear> Let rec would be excusable if the compiler could use it to hide phasiness.
23:17:10 <sorear> fuzan: bzzt, precedence
23:17:36 <sorear> ick, *State*T?
23:17:39 <stepcut> sorear: what do you mean by phases?
23:17:40 <sorear> oh!
23:17:49 <sorear> data Kind = Basic | Array | Function (ReaderT [Scope] IO [Type])
23:18:16 <sorear> fuzan: I took the liberty of switching to readert; lexical scoping is much nicer than dynamic :)
23:18:48 <sorear> stepcut: if you have any syntax errors, your type errors are hidden.
23:18:55 <fuzan> i'm not entirely sure on the differences between readert / statet :)
23:19:34 <fuzan> ick, it can't automatically derive the types for Eq/Show anymore :(
23:19:57 <sorear> yeah
23:20:01 <sorear> @src Reader
23:20:01 <lambdabot> Source not found. Maybe if you used more than just two fingers...
23:20:12 <stepcut> sorear: I think so, to a degree. I think the interpreter might be a bit more flexible
23:20:24 <sorear> @unmtl ReaderT [Scope] IO [Type]
23:20:25 <lambdabot> [Scope] -> IO [Type]
23:20:26 <sorear> sjanssen++
23:20:36 <sorear> you can't show functions
23:22:07 <fuzan> I'm just trying to bind the type of parameters to the Function Kind, such that I can check to make sure function calls provide the correct parameters. however, my checkType function returns "m Type", and I don't think there's a way to escape the monadics to be able to define something such as "Function [Type]"
23:22:27 <sorear> ocaml folks: how do I load a file *and* get a repl?
23:25:17 <user317> is there any way to get a stacktrace from an exception?
23:25:37 <sorear> +RTS -xc at runtime
23:25:47 <sorear> -prof -auto-all -caf-all at compile time
23:25:59 <sorear> some versions of GHC are buggy and will fail to link
23:26:08 <sorear> if this happens, try again without -caf-all
23:26:13 <drigz> is there a nicer way to put \x -> [x] than 'return' (result of @pl)
23:26:24 <sorear> @quote eat.*comment
23:26:25 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
23:26:41 <sorear> aka the robot ninja monkey operator, (:[])
23:26:52 <sorear> replicate 1 would also work
23:30:19 <drigz> sorear: thanks :D
23:31:20 <joelr1> good morning!
23:31:59 <stepcut> @quote robot ninja
23:32:00 <lambdabot> No quotes for this person. It can only be attributed to human error.
23:32:11 <stepcut> @quote robot.*ninja
23:32:12 <lambdabot> No quotes match. My mind is going. I can feel it.
23:32:40 <sorear> morning joelr1!
23:33:32 <joelr1> sorear: do you ever sleep?
23:33:47 <sorear> yes
23:34:15 <sorear> I've never been on #haskell at 4am
23:34:26 <joelr1> @localtime sorear
23:34:28 <lambdabot> Local time for sorear is Thu Apr  5 23:32:26 2007
23:34:57 <joelr1> sorear: are you on the west coast of the us?
23:35:02 <sorear> yeah
23:35:07 <sorear> san diego
23:35:13 <joelr1> cool
23:35:21 <sorear> as you might have guessed from the sd in my hostname ;)
23:35:43 <joelr1> sorear: nah, i didn't go anywhere that deep. in fact i didn't go at all
23:37:01 <joelr1> sorear: i think i asked you already but did you look at core output when optimizing?
23:37:38 <sorear> joelr1: optimizing what?
23:37:47 <joelr1> sorear: you know, binary
23:38:26 <sorear> not really.  just a quick skim looking for not-inlined things.  mostly I relied on time(1)
23:39:01 <joelr1> sorear: do you think the kinds of optimizations that you did could be performed by a robot?
23:39:18 <joelr1> sorear: assuming that your program was coded as a qc property
23:39:20 <joelr1> quickcheck
23:39:39 <sorear> joelr1: possibly, depending on the robot.  GP could certainly have done it :)
23:39:59 <sorear> deterministic rewrite systems? no way.
23:40:35 <joelr1> sorear: it may sound crazy, but i envision something like that... imagine parsing a haskell program into an AST then manipulating that ast by applying certain rules, generating code and timing it
23:41:26 <joelr1> the rules, in fact, don't have to be evolved genetically, although they may be. there could be a database of rewriting rules contributed by the community
23:41:35 <sorear> joelr1: me too.  actually, my plans are to work at a lower level.
23:41:45 <sjanssen> "manipulating that ast by applying certain rules" is called an optimizing compiler, methinks ;)
23:41:58 <sorear> joelr1: something lke a cross between BitC and RTL
23:42:05 <joelr1> sorear: then you could run a farm at amazon ec2 to speed up the optimizastion
23:42:10 <joelr1> what's RTL?
23:42:18 <sorear> register transfer language
23:42:20 <joelr1> sjanssen: hi to you too, spencer!
23:42:25 <sorear> gcc's equivalent to Core
23:42:30 <joelr1> @localtime sjanssen
23:42:52 <joelr1> @localtime joelr1
23:42:54 <lambdabot> Local time for joelr1 is 2007-04-06 07:41:07 +0100
23:43:04 <sjanssen> Fri Apr  6 01:40:11 CDT 2007
23:43:12 * joelr1 is up bright and early
23:43:19 <joelr1> sjanssen: where are you?
23:43:27 <sjanssen> Nebraska
23:43:45 <joelr1> sorear: but anyway, optimizing randomly, sort of. yes
23:43:53 <andrei> Hi, I have a library that's terribly badly designed (not mine, binutils); now it loves to print things to files. Unfortunately I really need those strings, so I'd like to have them as a String; so I need a Handle. Can I make a handle to a string if I'm sure it's wide enough?
23:43:56 <sjanssen> United States
23:43:58 <joelr1> on a wide scale
23:44:09 <joelr1> sjanssen: i know :) i lived there for about 10 years
23:44:17 <joelr1> sjanssen: not in nebraska :) fortunately
23:44:20 <bos> andrei: a handle to a string?
23:44:53 <bos> andrei: do you mean you want to read the entire handle and get a string?
23:45:28 <sorear> andrei: there's a function in glibc to open a string buffer as a FILE *
23:46:13 <andrei> sorear, Ah, thanks I'll look for that
23:47:00 <sorear> pretty sure it's glibc only though, if you care about portability you'll want a temporary file and bytestring readFile
23:47:26 <sorear> does ocaml evan have type *aliases*?!
23:47:44 <andrei> sorear, glibc is fine, my code depends heavily on gnu binutils libraries
23:48:35 <andrei> Do you by chance remember the name?
23:48:46 <sorear> no
23:50:44 <bos> andrei: fmemopen or open_memstream
23:51:18 <sjanssen> @seen robreim
23:51:19 <lambdabot> robreim is in #haskell. I last heard robreim speak 41m 14s ago.
23:51:41 <bos> that stuff should be easy to wrap using the ffi
23:51:59 <bos> and it's well documented in the glibc texinfo
23:56:43 <andrei> Thanks
23:58:16 <dmwit> > succ LT
23:58:17 <lambdabot>  EQ
23:58:21 <dmwit> > succ GT
23:58:23 <lambdabot>  Exception: Prelude.Enum.Ordering.succ: bad argument
23:58:31 <sorear> The ML module/functor system is ... very interesting
23:58:44 <dmwit> ?hoogle (Enum a) => a -> a
23:58:45 <lambdabot> Prelude.pred :: Enum a => a -> a
23:58:46 <lambdabot> Prelude.succ :: Enum a => a -> a
23:58:46 <lambdabot> Prelude.id :: a -> a
23:59:02 <dmwit> No succMod? =/
23:59:12 <dmwit> > pred LT
23:59:13 <lambdabot>  Exception: Prelude.Enum.Ordering.pred: bad argument
23:59:30 <robreim> sjanssen: ping
