00:00:24 <narain> :t guard
00:00:26 <lb> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
00:01:20 <Cheery> @type ( (+1) *** (+2) )
00:01:22 <lb> forall b b'. (Num b', Num b) => (b, b') -> (b, b')
00:01:41 <Cheery> ( (+1) *** (+2) ) (10,10)
00:01:45 <Cheery> > ( (+1) *** (+2) ) (10,10)
00:01:47 <lb>  (11,12)
00:02:07 <Cheery> any function is an arrow?
00:03:57 <narain> > (\[x] -> x) [42]
00:04:00 <lb>  42
00:04:22 <narain> hmm, haskell-mode gets confused by \[
00:04:38 <narain> Cheery: yes, i believe it is
00:04:42 <narain> ?instances Arrow
00:04:43 <lb> (->), Kleisli m
00:06:05 <Cheery> > map ((*2) &&& (*3)) [1..]
00:06:07 <lb>  [(2,3),(4,6),(6,9),(8,12),(10,15),(12,18),(14,21),(16,24),(18,27),(20,30),(2...
00:06:12 <sorear> JohnMeacham: ping?
00:06:26 <eumenides> @type (print &&& print) (1,2)
00:06:29 <lb> (IO (), IO ())
00:06:40 <JohnMeacham> sorear: pong.
00:07:09 <Cheery> (arr (\x -> 20*x+2))
00:07:15 <Cheery> > (arr (\x -> 20*x+2)) 4
00:07:17 <lb>  82
00:07:21 <sorear> JohnMeacham: what license is Doc/Pretty.hs under?  the nearest COPYING file I can find says GPL, but it is so similar to Daan's BSD3 file I have to ask.
00:07:40 <sorear> I'm cabalising it as a separate module.
00:07:58 <narain> :t arr
00:08:01 <lb> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
00:08:58 <sorear> whose idea was lazy repos?
00:09:00 <JohnMeacham> yes, it is based on Daan's one. so BSD3. the only really changes were to add 'oob' for out of band data and to put it into the DocLike framework.
00:09:05 <fuzan> http://hpaste.org/1401, if anyone gets the chance. I've been boned for the past hour :(
00:17:39 <norpan> boned indeed
00:17:50 <fuzan> :'(
00:18:09 <norpan> i have some kind of dns trouble, i can't access that page
00:18:58 <sorear> JohnMeacham: ok, tidied up and cabalised...  expect an announce as soon as rossp gives me a hackage acct (note that I stripped DocLike)
00:19:48 <fuzan> norpan:   http://65.254.53.221/hpaste
00:20:43 <norpan> you cannot do it like that
00:21:12 <sorear> http://65.254.53.221:8000/
00:21:13 <lb> Title: ScannedInAvian.com
00:21:18 <sorear> http://65.254.53.221:8000/new
00:21:26 <jargonjustin> I'm having trouble figuring out type-errors with case.  The matching expressions: "e@(Left _) -> e" and "Left e -> Left e" seem to type differently, is there a particular reason for this?  I thought the first would be more efficient.
00:21:31 <sorear> http://65.254.53.221:8080/
00:21:32 <lb> Title: ScannedInAvian.com
00:21:58 <sorear> norpan: http://65.254.53.221:8000/ works (I tried it in a browser)
00:21:59 <lb> Title: ScannedInAvian.com
00:22:23 <sorear> they should type identically.
00:22:25 <sorear> norpan: http://65.254.53.221:8000/ works (I tried it in a browser)
00:22:25 <lb> Title: ScannedInAvian.com
00:22:27 <norpan> sorry, got disconnected
00:22:32 <JohnMeacham> sorear: hmm.. I am not sure there is a point outside of DocLike, that is the main reason I wrote that library... As in, if you just wanted Pretty, then Daan's original version is probably the one to package.
00:22:50 <jargonjustin> sorear: That's what I thought, okay.  Back to debugging…
00:23:02 <norpan> you need to return a type that can contain both a FieldIdent and a BlockIdent
00:23:26 <sorear> JohnMeacham: hmm, ok.  I figured yours - DocLike == Daan + oob
00:23:33 <fuzan> norpan: i know, they're both of type Tree, yet, I can't seem to grasp how to define it correctly.
00:23:49 <JohnMeacham> yeah. pretty much.
00:23:58 <norpan> put them both in the same type
00:24:32 <norpan> type Ident = FieldIdent (Tree FieldIdent_) | BlockIdent (Tree BlockIdent_)
00:24:37 <JohnMeacham> I mean, I think that is the case.. it was a long time ago I wrote it... DocLike is very nice for writing 'Show' instances I find..
00:24:38 <norpan> err not type, data
00:25:03 <JohnMeacham> I need to give PPrint some precidence arguments so it can do parens inteligently.. hrm.
00:26:04 <augustss> jargonjust: your two expressions with Left have different types.
00:26:32 <hpaste>  jargonjustin pasted "Case expression typing" at http://hpaste.org/1402
00:26:46 <jargonjustin> augustss: How so?
00:26:57 <jargonjustin> Oh!
00:27:00 <jargonjustin> Okay, that makes sense.
00:27:12 <augustss> jargonjustin: in the second one the type of the Right branch is flexible, but in the first one the Right branch is forced to have the same type as the scrutinee
00:27:16 <jargonjustin> Same left type, different right types.
00:27:43 <augustss> it's a bit of a quirk
00:27:48 <fuzan> norpan: It' snot possible to do waht I was trying to do?
00:28:15 <augustss> and you're right, the former is more efficient in general
00:28:19 <jargonjustin> augustss: Thanks, the debugging messages were clear but I could not for the life of me figure out why they were different
00:28:46 <augustss> it's non-obvious
00:29:14 <Cheery> @type loop
00:29:17 <lb> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
00:31:36 <Cheery> why arrows are useful?
00:32:35 <dcoutts> bos: the sdist patch looks ok to me, if you've tested it I'll not bother :-) tell me an I'll apply
00:35:28 <tibbe> Cheery, I find them useful in HXT, a library to parse XML
00:36:47 <_roconnor> is there a haskell.org page devoted to symbolic differentiation in haskell?
00:36:54 <_roconnor> I've read 3 blog posts on it now.
00:36:59 <augustss> Cheery: because there are several patterns of computation that can be abstracted by arrows. :)
00:37:03 <_roconnor> They should probably be collected
00:37:12 <DRMacIver> Morning
00:37:35 <augustss> _roconnor: do it!
00:37:39 <DRMacIver> What are arrows exactly?
00:38:04 <sorear> @google generalizing monads to arrow
00:38:05 <augustss> A generalization of the Haskell -> type, you could say.
00:38:08 <sorear> @google generalizing monads to arrows
00:38:11 <lb> http://citeseer.ist.psu.edu/hughes98generalising.html
00:38:11 <lb> Title: Generalising Monads to Arrows - Hughes (ResearchIndex)
00:38:13 <lb> http://citeseer.ist.psu.edu/hughes98generalising.html
00:38:13 <lb> Title: Generalising Monads to Arrows - Hughes (ResearchIndex)
00:39:46 <DRMacIver> ok
00:40:09 <tibbe> DRMacIver, I found this explanation very helpful: http://en.wikibooks.org/wiki/Haskell/Understanding_arrows
00:40:10 <lb> Title: Haskell/Understanding arrows - Wikibooks, collection of open-content textbooks
00:41:22 <tibbe> I  parsec abstracted over the token type so I can use ByteStrings?
00:41:55 <sorear> no
00:43:34 <narain> :t liftM2
00:43:36 <lb> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
00:44:26 <augustss> well, the parsing fundamental combinators in parsec are paramterized on the token type.  but a lot of the useful ones are only available for [Char]
00:45:23 <sorear> Note that they are parameterised on the *token type*
00:45:28 <sorear> not the *stream type*
00:45:33 <sorear> you must use []
00:45:42 <tibbe> I wish type signatures would use a, b, c, ... etc instead of a1, a2, ..
00:46:55 <augustss> sorear: that's true.  but you could tokenize to [ByteStream]
00:47:07 <DRMacIver> tibbe: Thanks
00:47:19 <tibbe> no problem
00:47:44 <falconair> hi, does it make sense to tread data coming from a network connection
00:47:51 <tibbe> sorear, oh, I see
00:48:08 <sorear> JohnMeacham: turns out you deleted a bunch of combinators subsumed by DocLike.  *sigh*  I'm using Leijen's code now.
00:48:12 <narain> ?src minimumBy
00:48:13 <lb> Source not found. I feel much better now.
00:48:51 <falconair> sorry, does it make sense to treat data coming from a network connection as some sort of a list, where if there is no data, a thread 'sleeps' otherwise its contents are treated similarly to any list (except i would have to use monad comprehension syntax with hGetContencts or something)?
00:49:51 <dcoutts> falconair: yep, it makes sense
00:50:04 <dcoutts> that's exactly what hGetContents will give you
00:50:37 <dcoutts> either for String or Lazy.ByteString
00:50:40 <sorear> it's called lazy IO
00:50:43 <narain> is there a minBy like minimumBy?
00:51:01 <roconnor> Okay, I started http://haskell.org/haskellwiki/Functional_differentiation
00:51:02 <lb> Title: Functional differentiation - HaskellWiki
00:51:11 <roconnor> But now I must make breakfast
00:51:12 <dcoutts> narain: what would it mean?
00:51:24 <falconair> dcoutts: cool, there is a company called streambase which advertises that users can use a language similar to sql to process network data (stock quotes) ... i figured that if i think of sql as list/monad comprehension, it shouldn't be complicated at all ... certainly not worth a six figure dollar amount
00:51:39 <dcoutts> heh
00:51:43 <int-e> @src minimumBy
00:51:43 <lb> Source not found. I've seen penguins that can type better than that.
00:51:45 <narain> dcoutts: minBy (comparing abs) 3 -4 = 3
00:52:01 <narain> > minimumBy (comparing abs) [1,-2,3,-4]
00:52:03 <lb>  1
00:52:20 <dcoutts> narain: I see, no there isn't, not a standard function
00:52:29 <dcoutts> but looks like it's a one liner
00:52:53 <narain> hmm, it probably is
00:52:59 <int-e> minBy f a b = minimumBy f [a,b]
00:53:14 <int-e> (does the compiler do a good job with that?)
00:53:38 <narain> no fair, i need a pointless version... but i'm too sleepy to think it up myself
00:53:57 <int-e> @pl minBy f a b = minimumBy f [a,b]
00:53:58 <lb> minBy = (. ((. return) . (:))) . (.) . minimumBy
00:53:59 <narain> i probably shouldn't be bothering you guys with questions when i'm not thinking properly
00:54:03 <int-e> (sorry)
00:54:36 <sjanssen> int-e: doesn't minBy f a b = f a b?
00:54:43 <int-e> sjanssen: no
00:54:45 <sjanssen> @hoogle minimumBy
00:54:46 <lb> List.minimumBy :: (a -> a -> a) -> [a] -> a
00:54:46 <lb> Data.List.minimumBy :: (a -> a -> Ordering) -> [a] -> a
00:55:10 <narain> lb's  first result has the wrong type
00:55:15 <narain> hoogle's, actually
00:56:03 <sjanssen> narain: the List.minimumBy is the version from the Haskell report, I think
00:56:45 <narain> but it does have the wrong type, doesn't it?
00:57:05 <sjanssen> it just has a different type
00:57:25 <sjanssen> Data.List.minimumBy and List.minimumby are two different functions
00:57:42 <narain> hmm, how can you take an arbitrary function (a -> a -> a) and use it to compare?
00:58:17 <sjanssen> @type min
00:58:19 <narain> oh, it expects a min-like function?
00:58:19 <lb> forall a. (Ord a) => a -> a -> a
00:58:26 <sjanssen> narain: correct
00:58:27 <narain> ah, i just got it
00:58:52 <sjanssen> @src min
00:58:52 <lb> min x y = if x <= y then x else y
00:59:52 <sjanssen> @type \f a b -> case compare a b of GT -> b; _ -> a
00:59:54 <lb> forall t a. (Ord a) => t -> a -> a -> a
01:00:07 <sjanssen> @type \f a b -> case f a b of GT -> b; _ -> a -- oops
01:00:10 <lb> forall t. (t -> t -> Ordering) -> t -> t -> t
01:01:55 <foxy-om> @where GSLHaskell
01:01:55 <lb> I know nothing about gslhaskell.
01:03:21 <Cheery> > ( (+20) >>> (*3) ) 5
01:03:23 <lb>  75
01:03:46 <Cheery> > ( (+20) >>> (*3) ) 1
01:03:48 <lb>  63
01:20:23 <roconnor> > ( (+20) <<< (*3) ) 5
01:20:25 <lb>  35
01:26:13 <sorear> sjanssen: IIRC 'tabled' means exactly opposite things in Commonwealth and US English.  Beware.  (you used the US meaning)
01:26:28 * sorear thinks
01:26:45 * sorear realises that message could not have been misinterpreted by a sane person
01:26:53 * sorear decides he is tired
01:27:37 <sjanssen> sorear: wow, that's quite interesting
01:27:55 <ivanm> sorear: well, I definetely didn't get it
01:28:42 <sorear> ivanm: you would only have gotten the message I'm referring to if you are subscribed to xmonad@
01:28:52 <ivanm> ahhhhh
01:29:39 <sjanssen> I wonder how a word picks up opposite meanings
01:30:38 <_frederik_> it's because americans are strong and hold things they are reading in front of them, so dropping them on the table means to put them away; whereas europeans are weak and have to bend over the table while they read
01:31:13 <sjanssen> ha
01:32:00 <_frederik_> or perhaps americans have to hold things up because they are too fat to bend over the table
01:32:17 <sjanssen> or Americans have such poor vision (and perhaps are too vain to wear glasses) that they *must* hold things to read them
01:32:31 <_frederik_> clearly a study is in order
01:32:45 <sjanssen> ah yes, your alternative version is more acceptably offensive
01:32:58 <sjanssen> can't play favorites, after all
01:33:51 <sorear> hello, therp
01:33:52 <nomeata> Hi. Is there a reason why mmapFile in ByteString is not uncommented?
01:34:01 <therp> good morning sorear
01:34:02 <sorear> ask dcoutts
01:34:22 <sorear> someone asked earlier, I think it was dcoutts
01:34:23 <dcoutts> nomeata: it depends on posix or win32 functions that are not in base
01:34:57 <sorear> <dcoutts> bos: does the chap doing the shared lib stuff have an online identity?
01:34:57 <sorear> <bos> yeah, it's clemens fruhwirth
01:34:57 <sorear> <dcoutts> bos: we should get him in here and talk about stuff
01:34:57 <sorear> <bos> i forget his nick, but he's on here sometimes iirc
01:35:19 <therp> yes that's me.
01:35:45 <Heffalump> wi therp
01:35:48 <Heffalump> ahem.
01:36:14 * Heffalump looks forward to your project, it'd be nice not to have huge GHC-produced binaries.
01:36:14 <dcoutts> hia therp, contrats on getting the project :-)
01:36:18 <therp> I have not yet done my duty to properly do my report.
01:36:37 <nomeata> Another question: Can I plug into the garbage collector somewho to replace some data (e.g. a mma’ped Filed) by a thunk, to free resources (in this case, open file handles)?
01:36:51 * sorear looks forward to sharing physical pages between haskell programs!
01:36:52 <therp> dcoutts: thnx :)
01:36:59 <dcoutts> nomeata: not easily
01:37:16 <sorear> nomeata: mmap does it for free, the OS replaces pages in RAM with thunks
01:37:17 <Heffalump> so you want to unevaluate things?
01:37:28 <sorear> norpan: unevaluation is the essence of VM
01:37:40 <Heffalump> sorear: not with regard to resources like file handles
01:37:41 <LeCamarade> What's that Prelude func that is the equivalent of: let func x = take ((length x) - 1) x  ?
01:37:50 <sorear> init
01:37:54 <dcoutts> nomeata: you can use weak references, possibly, but it might not do what you want
01:38:04 <LeCamarade> sorear: Thanks fatly.
01:38:25 <nomeata> sorear: so I can savely mmap more than 1024 files? cool!
01:38:40 <sorear> be prepared to hit procfs :)
01:38:52 <dcoutts> therp: I think I told Simon to recommend Ulrich Drepper's DSO guide to you
01:39:00 <nomeata> procfs?
01:39:09 <dcoutts> therp: it's a good place to start, if you've not seen it already
01:39:10 <nomeata> maximum fs per process?
01:39:27 <nomeata> that’s why I’d like to unmmap some files and mmap again on demand
01:39:40 <therp> dcoutts: googling.. :)
01:39:50 <dcoutts> should be first hit, big pdf
01:39:52 <nomeata> Basically I want to use the content of a whole directory of text files in a pure manner, without reading it all into memory
01:40:06 <dcoutts> therp: "how to write shared libraries"
01:40:30 <therp> ah, that's a big one.
01:40:41 <therp> nice
01:41:12 <dcoutts> therp: yeah, it's big but it's fairly well written and really tells you a lot
01:42:07 <dcoutts> therp: when reading it I couldn't help thinking about the various simplifications or optimisations we could make that the C people can't because they have to try and preserve full compatability with the static linking scheme
01:42:22 <dcoutts> eg in terms of search orders and scopes etc
01:42:56 <dcoutts> eg it'd be nice (and faster) if we only had to search for names in dependent libs rather than in all loaded libs
01:43:02 <therp> my first concern at the moment is to test the pic code generator in GHC
01:43:07 * nomeata notices that I currently need only 345, so mmap them all might be an option. Or just slurp it all in – 3,5MB at the moment. Woudn’t scale very well, but what the hell.
01:43:19 <dcoutts> therp: sure, premature optimisation and all that :-)
01:43:41 <dcoutts> therp: sill it's a good guide to the whole area, saying why we need PIC and all that
01:43:55 <therp> I wonder why GHC has -fPIC, as there is no proper use in the current static world in GHC
01:44:15 <dcoutts> therp: ah, well they've got PIC working on OSX I think
01:44:31 <dcoutts> Wolfgan Thaller (sp?) did it for OSX
01:44:39 <dcoutts> so the ncg can do PIC, mostly
01:44:44 <dcoutts> when it's not broken
01:44:55 <dcoutts> so a lot of the stuff is there already
01:45:05 <dcoutts> but none of the ELF bits, just the Mach bits
01:45:24 <dcoutts> though much of the PIC infrastructure will be shared one hopes
01:45:26 <therp> I plan to use gcc for that anyway
01:46:01 <dcoutts> therp: hmm, better ask Simon about that, I seem to recall that it was hard to do via gcc
01:46:11 <dcoutts> but maybe I'm wrong
01:46:13 <therp> really? hm ok.
01:46:23 <dcoutts> which is why Wolfgang extended the NCG to do PIC code
01:46:31 <therp> as I said, I haven't talked to Simon yet
01:46:34 <dcoutts> we should get the details from Simon
01:46:37 <dcoutts> yeah
01:46:55 <dcoutts> therp: well, we can find him in #ghc tomorrow
01:47:03 <dcoutts> @localtime therp
01:47:14 <therp> 10:45 AM
01:47:21 <dcoutts> lb? what no timeinfo
01:47:34 <dcoutts> therp: ok, so your european time :-)
01:47:44 <LeCamarade> @time tehrp
01:47:52 <LeCamarade> @time therp
01:47:58 * dcoutts is still in Australia for the next 10 days
01:48:27 <sorear> @botsnack
01:48:27 <lb> :)
01:48:35 <sorear> ok, I need to sleep now.
01:48:49 <sorear> My computer does not run while I sleep.
01:48:53 <sorear> @time chessguy
01:49:12 <sorear> @time newsham
01:49:12 <dcoutts> therp: so in the mean time I'd read that big pdf and possibly look at the PIC stuff which I think is mentioned on the ghc wiki somewhere
01:49:16 <_frederik_> hello, is there a way to tell what time a cabal package was most recently installed? i want to be able to depend on it in a makefile (and rebuild things if its install date is newer than something which depends on it)
01:49:25 <sorear> @time stepcut
01:49:29 <sorear> @localtime stepcut
01:49:36 <sorear> @localtime newsham
01:49:58 <sorear> stepcut, newsham: ping
01:50:02 <sorear> stepcut, newsham: lb is going down for system halt
01:50:13 <sorear> stepcut, newsham: if you want to start your bots
01:50:25 <dcoutts> therp: http://hackage.haskell.org/trac/ghc/wiki/Commentary/PositionIndependentCode
01:50:27 <lb> Title: Commentary/PositionIndependentCode - GHC - Trac, http://tinyurl.com/35xb6j
01:50:40 <sorear> night.
01:53:14 <therp> dcoutts: thanks for the pointers
01:53:39 <therp> dcoutts: I'm a bit unable to handle them at the moment.. (other releases/code)
01:53:52 <dcoutts> ok, np
02:34:14 <tibbe> is there a tutorial for writing a simple recursive descent LL(1) parser somewhere?
02:34:21 <tibbe> I have a really simply language, regular in fact
02:34:42 <tibbe> but the regex gets messy and is harder on error tracking
02:41:11 <DRMacIver> tibbe_: Any particular reason not to use parsec or happy?
02:41:44 <tibbe_> DRMacIver, ByteString
02:41:55 <tibbe_> happy is to heavyweight for my language
02:42:04 <DRMacIver> I thought Parsec had a clone with ByteString support?
02:42:17 <tibbe_> I heard someone was working on it
02:42:29 <tibbe_> but I think I can parse it using 4 or so small functions
02:42:39 <tibbe_> I only need an idiomatic way of writing them
02:42:48 <tibbe_> I know I've seen examples somewhere
02:42:58 <tibbe_> I don't need backtracking
02:43:48 <DRMacIver> Fair enough.
02:44:14 <DRMacIver> I'm not aware of any good tutorials that don't just have "Here's how to use parsec!" I'm afraid.
02:44:22 <DRMacIver> What's the language look like?
02:46:41 <tibbe_> it's string templates
02:46:49 <tibbe_> basically fourth literals
02:47:07 <tibbe_> $$ escape, $identifier, ${identifier} and everything else
02:47:29 <tibbe_> hmm, a look ahead of 2 would actually be good
02:47:50 <tibbe_> it would be nice if $$ didn't end up as a literal of its own
02:48:15 <tibbe_> so "asdas$$sadas" would get parser as Lit "..." not Lit "...", Lit "$", Lit "..."
02:48:24 <tibbe_> s/parser/parsed
02:48:35 <tibbe_> I can type lying down
02:48:39 <tibbe_> can't!
02:48:45 <tibbe_> gawd
02:54:47 <Saizan> i've some course notes in pascal if you want :D
02:56:58 <xerox> eek (:
02:57:14 <xerox> (Don't show everybody how we do cs in Italy please! ;) )
02:58:51 <osfameron> heh, is it bad?
03:23:53 <Saizan> isn't there a way to emulate negative context for instances?
03:25:11 <Saizan> to make instance IsNotChar x => Foo [x] where .. and instance Foo [Char] where .. work nicely?
03:26:20 <opqdonut> probably make a typeclass, and then make Char and the other types you wish to use members of it
03:26:30 <opqdonut> and then just implement the Char operations in the nice way
03:27:54 <Saizan> the point is that the differences arises only between String and [a] when a /= Char
03:27:55 <int-e> Saizan: nope. if you wonder how 'show' does it, the trick is in the showList function of the Show class
03:29:43 <int-e> and the instance for lists is basically  instance Show a => Show [a] where showsPrec _ = showList
03:32:12 <ndm> @seen sorear
03:32:25 <ndm> @seen lambdabot
03:33:03 <Saizan> mmh, sho showList for Char is defined differently than all the others?
03:33:11 <int-e> exactly
03:33:37 <int-e> @type showList
03:34:08 <Saizan> class Show a where
03:34:08 <Saizan>   showsPrec :: Int -> a -> ShowS
03:34:08 <Saizan>   show :: a -> String
03:34:08 <Saizan>   showList :: [a] -> ShowS
03:44:44 <rhz> Applying a certain patch in my darcs repository gives this error message: darcs: ./.DS_Store: openBinaryFile: does not exist (No such file or directory). My repository is thus corrupted. Is there any way to fix this?
03:45:54 <foxy-om> what does darcs repair do?
03:46:17 <arjanb> i would first make a backup of the repo
03:46:24 <rhz> It says: applying patch 30 of 42... Unnappicable patch: (then gives the error message)
03:46:38 <foxy-om> are you on a windows machine?
03:46:48 <foxy-om> what arjanb said, BTW
03:46:48 <rhz> I am on Mac OS X
03:47:32 <foxy-om> I've come across that sort of error when filenames differ in case
03:47:47 <foxy-om> between what the repo has and what the patch says
03:47:54 <rhz> .DS_Store are invisible files on OS X uses
03:48:23 <rhz> They ought to be ignored because there is an entry in the prefs/boring file for them I think
03:48:33 <rhz> But I am getting this error anyways
03:49:52 <rhz> I start a new repository but then I'd lose all the change comments.
03:50:12 <rhz> for applie patches
03:50:15 <rhz> applied
03:50:44 <Saizan> tried repair?
03:50:49 <rhz> yeah
03:51:14 <rhz> repair generates the same error
03:53:43 <balodja> does ghc work on any big-endian archs?
03:59:23 <ndm> balodja: yes
03:59:44 <ndm> rhz: ask on teh darcs mailing list, its more likely to get a response
04:05:26 <LeCamarade> System.Posix.Process.executeFile quits my program. Which fun can I use to just start a new process on the side? Something akin to a shell. I am writing a shell, yeah. Following dons' paper on Yi and Lambdabot.
04:05:47 <LeCamarade> Not a thing as grand, of course. :oD Just a toy.
04:06:32 <foxy-om> @hoogle system
04:07:14 <foxy-om> System.Cmd.system
04:07:39 <LeCamarade> foxy-om: Is it system that I have to use? Because I think it sucks. I was hoping to use bings to the execv* family of POSIX funcs.
04:08:08 <LeCamarade> I need to get some info about the newly-forked process, and yet system is just opaque surrender.
04:08:37 <foxy-om> are you trying to execute haskell code or an executable?
04:08:54 <LeCamarade> foxy-om: An executable.
04:09:37 <foxy-om> why does executeFile crash?
04:10:37 <LeCamarade> No. It just quits my program, and yet I want it to keep running ... to get the next command.
04:11:35 <Saizan> execv* substitute the running process, you have to call them in a forked one
04:11:56 <foxy-om> do { pid <- forkProcess $ executeFile "/usr/bin/rm" False ["-r","/"] Nothing }
04:12:56 <foxy-om> with different arguments to executeFile, obviously o.O
04:14:06 <LeCamarade> Okay, I already thought of that (saving my root directory, of course), and I figured that Maybe $ that may cause fat overhead. Else Just $ do it.
04:14:49 <LeCamarade> Alright. I'll just go with that. I mean, I am not planning to take over the world.
04:15:01 <Saizan> why not use System.Process ?
04:16:05 <LeCamarade> Saizan: Eh! Good! I had eschewed it saying `me wants POSIX! Me no write shells for DOS!'
04:16:14 <LeCamarade> Okay, I think it is what I want.
04:16:34 <LeCamarade> Saizan: Oh, Lord, it is what I want.
04:16:42 <Saizan> :D
04:16:48 <LeCamarade> Or is it?
04:16:55 <foxy-om> I think you'll find that you need a language that supports dependent types to take over the world.
04:18:41 <Saizan> well it seems to do what you want, plus in a portable way..
04:19:30 <Saizan> it's not System.Win32.Process :)
04:21:50 <Herald> i have a data type (((Int,Int),[Int]),Int,Int) , how can i extract the [Int] using prelude functions ?
04:21:56 <nornagon> ...
04:22:13 <nornagon> get a real data type please :(
04:22:27 <ivanm> snd. fst ?
04:23:02 <Herald> type doesnt match (a,b) so fst and snd dont like it
04:23:05 <nornagon> nope
04:23:11 <nornagon> snd and fst are for two-tuples only
04:23:34 <nornagon> fst3 (a,_,_) = a
04:23:36 <foxy-om> \a b c -> snd a
04:23:38 <nornagon> snd.fst3
04:23:51 <foxy-om> ^^
04:23:54 <nornagon> foxy-om: \(a,_,_) -> snd a
04:24:03 <nornagon> if you want to do it that way
04:24:19 <Pseudonym> @pl \((a,b),c,d) -> b
04:24:25 <Herald> ideally id like to just use prelude
04:24:36 <Herald> but if it cant be done ill make a function, yes
04:24:38 <nornagon> Herald: there are some things that can't be done with the prelude.
04:24:43 <nornagon> @botsmack
04:24:44 <Pseudonym> Herald: Is there a reason why you can't use a lambda expression?
04:24:59 <Herald> not other than i dont know what a lambda expression is :P
04:25:18 <nornagon> \args -> body  -- lambda expression
04:25:24 <Pseudonym> \((_,x),_,_) -> x
04:25:25 <nornagon> like an inline, anonymous function.
04:25:31 <Pseudonym> Like that.
04:25:38 <Mitar> is there a truncate which would return double and not integer?
04:25:41 <foxy-om> what's wrong with snd . fst3
04:25:56 <nornagon> Mitar: fromInteger.truncate? :)
04:26:07 <Herald> foxy-om: nothing, but id like to not have to make a function if poss
04:26:19 <foxy-om> @where fst3
04:26:28 <Pseudonym> @botslap
04:26:28 <nornagon> lb is down
04:26:43 <foxy-om> rofl -- botslap
04:26:56 <Herald> hm, ill try that Pseudonym
04:26:58 <Herald> thanks
04:27:04 <Pseudonym> Cool.
04:27:35 <foxy-om> So how's the latest world domination plot going, anyway?
04:28:34 <LeCamarade> foxy-om: You mean me?
04:28:54 <foxy-om> Just in general... (KLC)
04:29:01 <LeCamarade> Still looking for where I put Pinky and the Brain's number. :oD
04:29:25 <LeCamarade> Um ... how would you guys like a shell written in Haskell?
04:29:42 * LeCamarade knows nobody wants that. He walks away, crying.
04:30:09 <Pseudonym> I read that as "walks away, currying"
04:30:36 <Mitar> is there a pararell mapM_ ?
04:30:40 * LeCamarade knows, besides, that he will get fed up with the project in a short while. And thinks pseudonym should be taken away from Haskell before he hurts himself.
04:30:52 <Pseudonym> Too late.
04:30:56 <foxy-om> Self-application isn't allowed
04:31:30 <LeCamarade> Pseudonym: You're finished already? Try HA? (Haskellaholics Anonymous)?
04:31:41 <nornagon> LeCamarade: it's called "ghci" :)
04:32:42 <Mitar> is there a float point square function in haskell?
04:32:49 <LeCamarade> nornagon: Yeah, I once thought of LeCamarade:x:1001:ghci, but I had started groing fur on my eyelids. And I changed it back to ash.
04:32:52 <foxy-om> > 2**2.3
04:33:08 <Pseudonym> sqrt works for Floats.
04:33:19 <Pseudonym> sqrt :: (Floating a) => a -> a
04:33:37 <nornagon> man, that post on planet haskell recently about automatic differentiation was *cool*
04:33:51 <foxy-om> @where automatic differentiation
04:33:56 <Mitar> sqrt is root not square :-)
04:34:00 <nornagon> lb is still down.
04:34:13 <nornagon> > 2.3 ** 2
04:34:15 * foxy-om expects real people to fill in for lambdabot in the interim
04:34:20 <ivanm> oh lb, lb, wherefore are thou lb? :p
04:34:31 <Pseudonym> (\x -> x*x)
04:34:36 <ivanm> foxy-om: it's about "yay-much"
04:34:37 <Pseudonym> There you go, square function.
04:34:42 <Mitar> but ** is
04:34:53 <jacobian_> Can you put multiple type class constraints on a type?
04:35:00 <foxy-om> yup
04:35:02 <jacobian_> how?
04:35:12 <Mitar> but would that be optimized? CPUs have instructions for square ... don't they?
04:36:16 <nornagon> no.
04:36:39 <foxy-om> (Foo a, Bar a) => a -> a
04:37:20 <jacobian_> thanks foxy-om
04:37:27 <foxy-om> L)
04:37:30 <foxy-om> :)
04:40:00 <Mitar> is there a pararell mapM_ ?
04:41:07 <foxy-om> liftM parMap
04:41:14 <Saizan> Mitar: i don't think you can write mapM_ in general
04:41:22 <foxy-om> or something, according to manual hoogle
04:41:23 <Saizan> +a parallel
04:41:28 <nornagon> @src mapM_
04:41:33 <nornagon> right :p
04:41:46 <Saizan> mapM_ f xs = sequence_ (map f xs)
04:41:53 <Mitar> I would like to use it on IO monad, but it does not matter in which order does IO actions are evaluated
04:42:07 <foxy-om> @type liftM
04:42:28 <nornagon> liftM :: (Monad m) => (a1 -> r) -> m a1 -> m r
04:43:31 <LeCamarade> What is the deifference between foldr and foldr1?
04:43:39 <foxy-om> sequence_ $ parMap <strategy> f xs
04:43:44 <LeCamarade> s/deifference/difference/gi
04:44:19 <Saizan> foxy-on that would compute the IO actions in parallel but not execute them
04:44:28 <Mitar> foxy-om, I tried this but it is not really parallel, I think the sequence forces it back to sequential
04:45:01 <Saizan> @type par
04:45:18 <foxy-om> par :: a -> b -> b
04:45:22 <foxy-om> Mitar: write it by hand
04:46:38 <Saizan> askdjaskj*XmlSerialize Control.Parallel> (putStrLn "foo" `par` putStrLn "bar")
04:46:39 <Saizan> bar
04:47:09 <foxy-om> parMapM_ :: Strategy a -> (b -> m c) -> [b] -> m [c]
04:47:46 * foxy-om has listened to one song 72 times in the past 48 hours
04:48:37 <foxy-om> Note that actual parallelism is only supported by certain implementations (GHC with the -threaded option, and GPH, for now). On other implementations, par a b = b.
04:50:58 <Saizan> you probably need unsafePerformIO
04:55:15 <balodja> what is better for unicode symbol arrays? Char or Integer?
04:56:03 <nornagon> I'm pretty sure Char does unicode stuff.
04:56:39 <balodja> as I know Char is utf8, so it is not fast enough, yeah?
04:56:51 <Heffalump> Integer is bound to be slower than Char.
04:57:00 <Heffalump> seeing as it's unbounded
04:57:33 <Saizan> CHar is full unicode, 32bit
04:57:40 <Saizan> s/CH/Ch/
04:57:42 <balodja> oh! that's good!
04:57:46 <balodja> thanks
04:58:49 * balodja is trying to bind iconv library for recoding
04:58:50 <Saizan> current IO implementations use only 8 bit though
05:01:17 <foxy-om> nornagon, I agree, neat article on automatic differentiation
05:03:24 <Saizan> balodja, have you seen this? http://hackage.haskell.org/cgi-bin/hackage-scripts/package/iconv-0.2
05:07:07 <jacobian_> Hmm, I just wrote a reverse in the type system :)
05:07:31 <balodja> Saizan: that's pure binding. as you know recoding means functions, but pure binding with gnu's iconv cannot be done without monads
05:07:47 <arjanoosting> bedankt voor de info! en geniet van het lekkere weer!
05:08:38 <Saizan> balodja, the interface is pure
05:08:47 <jacobian_> I can't seem to get it to be mirrored in the value system though
05:09:00 <jacobian_> Do I need an extra parameter that is a phantom type in order to do that?
05:10:22 <balodja> Saizan: i can't believe :)
05:10:35 * balodja is looking through the code
05:11:13 <Heffalump> jacobian_: can't you use a class member to do it?
05:15:05 <jacobian_> Heffalump: Thanks for the hint!
05:19:07 <jacobian_> http://paste.lisp.org/display/39762
05:20:35 <balodja> Saizan: one more question. how did find it? :)
05:20:44 <balodja> @hoogle iconv
05:21:04 <balodja>  <@lambdabot> No matches found
05:21:28 <ReTaL> how do i get a String from an "IO String"?
05:21:59 <kaol> you don't
05:22:10 <foxy-om> jacobian_: have you seen http://okmij.org/ftp/Haskell/types.html
05:22:48 <jacobian_> wow, nope
05:22:51 <jacobian_> Thanks foxy-om
05:23:24 <jacobian_> Has anyone ever encoded the type of a sort?
05:23:59 <ReTaL> ok so another question, how can  I call sleep/usleep in a function without letting it return IO?
05:24:11 <nornagon> (a -> Ordering) -> [a] -> [a]?
05:25:13 <Heffalump> jacobian_: of course, you're not actually reflecting your reverse at the value level, more like rewriting it.
05:25:31 <Heffalump> Although you probably wouldn't be able to write anything but reverse.
05:26:25 <ndm> @pl value c ns = snd $ c ns
05:28:11 <jacobian_> I also wonder if you can do a reverse without the accumulator
05:28:30 <kaol> ReTaL: if that's all you want, you might get away with using unsafePerformIO. But it's named the way it is for a reason.
05:29:44 <ReTaL> i get what you mean
05:29:46 <Saizan> balodja, skimming the hackage list from time to time :)
05:32:10 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1404
05:32:25 <ReTaL> kaol, do i only ned to input "System.IO.Unsafe"? his is my code: http://hpaste.org/1404
05:34:30 <ReTaL> i think i got it
05:34:53 <Mitar> this does not work as intended: http://hpaste.org/1405
05:35:39 <Mitar> any ideas?
05:35:50 <balodja> Saizan: although it is using String, i think i'll couple with it. thank you
05:38:38 <Saizan> Mitar, what does it do?
05:38:50 <Mitar> it prints only b and d
05:40:35 <hpaste>  foxy-om annotated "(no title)" with "try this" at http://hpaste.org/1405#a1
05:40:46 <Saizan> because do { a `par` b; .. } "connects" only b to the chain of IO actions to be excuted
05:42:01 <hpaste>  foxy-om annotated "(no title)" with "hrm" at http://hpaste.org/1405#a2
05:42:13 <Mitar> Saizan: and is there a solution?
05:42:19 <foxy-om> Mitar are you running with -threaded?
05:42:24 <Mitar> yes
05:42:29 <Mitar> and with +RTS -N2
05:42:30 <Mitar> :-)
05:42:45 <Mitar> but it should be no difference there ..
05:42:58 <Mitar> those switch should not change the semantics of the program
05:43:17 <Saizan> parsequence_ (x1:xs) = do { unsafePerformIO x1 `par` parsequence_ xs }  <-- i can think only of this solution, but i've not used Concurrent.Parallel before
05:44:41 <foxy-om> what happens when you do "parsequence_ (x1:(x2:xs)) = do x1 `par` (parsequence_ xs)"
05:44:52 <foxy-om> get rid of that x2
05:45:25 <Saizan> that will not print anything i suspect
05:46:11 <Mitar> only d
05:46:12 <Mitar> :-)
05:46:23 <hpaste>  foxy-om annotated "(no title)" with "try this" at http://hpaste.org/1405#a3
05:46:29 <Saizan> ah right, you have a rule for [x] :)
05:46:38 <foxy-om> as expected, now ^^
05:47:13 <Saizan> foxy-on: seq :: a -> b -> b
05:47:24 <foxy-om> o.O
05:48:38 <Mitar> Saizan, your solution also does not work
05:48:43 <Saizan> seq a b, means force a before you can access b, |seq a a| has no effect
05:48:57 <hpaste>  foxy-om annotated "(no title)" with "what about this?" at http://hpaste.org/1405#a4
05:49:13 <Saizan> Mitar: oh
05:49:55 <Mitar> foxy-om, it does not compile
05:49:55 <foxy-om> the problem seems to be that the calls to `par` are being lazily ignored
05:50:01 <foxy-om> heh
05:51:03 <Saizan> Mitar: it works here
05:51:16 <Saizan> *Main> main
05:51:16 <Saizan> d
05:51:16 <Saizan> *Main> a
05:51:16 <Saizan> b
05:51:16 <Saizan> c
05:51:29 <Mitar> can you paste the exact code?
05:51:36 <foxy-om> Saizan is that with unsafePerformIO?
05:51:48 <Saizan> yeah
05:52:05 <foxy-om> yucky, :P
05:52:34 <hpaste>  Saizan annotated "(no title)" with "unsafe" at http://hpaste.org/1405#a5
05:52:50 <balodja> when I use package in sources via import and then try co compile/link it, ghc throws errors from ld about undefined reference. but when I passing package's static library as argument(-optl <path_to_library.a>) everything goes well. where should I search for error/bug?
05:53:26 <Saizan> Mitar: you can also skip the second clause
05:53:32 <Mitar> Saizan: I only get d with your code
05:54:06 <foxy-om> balodja: Cabal .cabal file, extra-libraries or some such field
05:54:36 <foxy-om> Mitar, are you *sure* you're running with -threaded, it sounds like your previous code should have worked
05:54:47 <foxy-om> without needing unsafePerformIO
05:55:08 <foxy-om> Note that actual parallelism is only supported by certain implementations (GHC with the -threaded option, and GPH, for now). On other implementations, par a b = b.
05:55:19 <Mitar> i dun with ghc -O2 --make -threaded test.hs
05:55:26 <foxy-om> ^^ from Control.Parallel
05:55:38 <Mitar> ohh
05:55:41 <Mitar> now it works???
05:55:43 <foxy-om> it looks like par a b is throwing away the a
05:55:59 <foxy-om> OK, try it without unsafePerformIO
05:56:13 <balodja> foxy-om: that may happen because package's library is not registered in package.conf?
05:56:18 <Mitar> it works randomly
05:56:36 <foxy-om> balodja, yes, I think so
05:56:51 <Mitar> Saizan: your solution works randomly - the problem with terminal
05:56:52 <Mitar> ?
05:57:10 <Saizan> balodja, do you use --make when compiling?
05:57:29 <Mitar> try redirecting it to the file -> i am always getting only d there
05:58:24 <Saizan> uhm yeah, it doesn't work when compiled
05:58:49 <Saizan> ah now i see, you are not asking for the ()
05:59:43 <Mitar> and I get:  warning: implicit declaration of function 'newSpark'
06:00:39 <Saizan> Mitar: it works if you compile without optimization
06:01:08 <Mitar> nop, i get the same random behaviour
06:01:22 <Saizan> uh, true
06:01:33 <Saizan> ah well it's unsafe for a reason :)
06:01:43 <balodja> Saizan: when compiling source, that uses the package, no. the package itself is compiled with defaultMain from Distribution.Simple
06:01:53 <Mitar> yes :-)
06:02:11 <Mitar> with more complex IO functions (OpenGL drawing) I get bus errors with this solution
06:02:36 <foxy-om> Mitar, use a queue STM that each fork writes to once it's finished, then you have another thread reading from it...
06:03:21 <Saizan> balodja: if you don't compile with --make and don't provide explicit -package flags, the libs don't get linked
06:03:50 <balodja> thanks one more time
06:04:17 <Saizan> yeah you need to go Concurrent, not just parallel ..
06:07:07 <Mitar> bah ... I was thinking that this would be nice example of simple transformation from non-parallel to parallel without changing the semantics
06:13:35 <Mitar> but this should really be possible ... because I can think of many useful examples where the order of actions is not important and would be nice it would be easily parallelised
06:14:54 <Mitar>  fir
06:19:42 <Saizan> try asking on the mailing list
06:21:20 <RemiTurk> hi all
06:22:33 <ndm> hi RemiTurk
07:22:52 <ihope> Is right-shifting by one bit significantly faster than dividing by 2 on an even Integer?
07:27:49 <ihope> What does Haskell have for right-shift-by-one on Integers, anyway?
07:28:06 <nominolo> @instances Bit
07:28:48 <ihope> Pienso que no hay lambdabot.
07:28:57 <nominolo> i figured
07:29:17 <nominolo> i think you can just use (x::Integer) `shiftR` 1
07:29:26 <Botje> there was a lb here yesterday ..
07:29:37 <ihope> Well, mbot is a lambdabot.
07:29:47 <ihope> Let's invade #math!
07:29:51 <Botje> :p
07:29:52 <ihope> Or #physics.
07:29:59 <Saizan> Botje, then sorear has gone to sleep :)
07:30:22 <Botje> 10:54 -!- lb [n=lb@ip68-7-248-101.sd.sd.cox.net] has quit [Remote closed the connection]
07:30:28 <ihope> shiftR :: forall a. (Bits a) => a -> Int -> a
07:31:04 <nominolo> yes, works
07:31:09 <Saizan> ( i tried to build lambdabot but couldn't ..)
07:31:10 <xerox> instance Bits Integer -- Defined in Data.Bits
07:32:02 <ihope> So is a shiftR by 1 quicker than dividing by 2?
07:33:41 <nominolo> maybe a few nanoseconds?
07:33:46 <xerox>    shift x i | i >= 0    = x * 2^i
07:33:46 <xerox> 	     | otherwise = x `div` 2^(-i)
07:33:52 <nominolo> why care?
07:33:52 <eumenides> if it matters you're using the wrong language?
07:33:56 <hpaste>  junyer pasted "type inference futility" at http://hpaste.org/1406
07:34:00 <xerox> ...for instance Bits Integer.
07:34:07 <junyer> (hi again)
07:34:21 <xerox> ihope, http://darcs.haskell.org/ghc-6.6/packages/base/Data/Bits.hs
07:35:32 <junyer> ghc's complaining about an ambiguous type variable
07:35:56 <junyer> i'd hoped it would kind of infer that i meant MehQueue
07:36:25 <junyer> so i'm not sure what i need to add to help it
07:36:29 <ihope> So after a bit of optimization, it's exactly the same...
07:36:48 <Saizan> junyer, can you paste the code?
07:36:49 <kayess> Just trying to write my first Haskell program. Got what is I'm sure a very stupid question
07:36:53 <junyer> <hpaste>  junyer pasted "type inference futility" at http://hpaste.org/1406
07:37:08 <Botje> junyer: I'm guessing you need to do  x <- new :: MehBase MehQueue
07:37:10 <Botje> or somesuch
07:37:38 <ihope> kayess: ask it. We won't laugh ;-)
07:37:38 <junyer> i'm working towards having the type inferred based on the methods i call
07:37:48 <Saizan> x <- new :: IO MehQueue
07:38:13 <Saizan> junyer, if you call only class methods the type can never be determined
07:38:15 <kayess> thanks. I have a function which I've set up like this: inner :: [a] -> ([a], [a]) -> [a]
07:38:24 <gaal> is lambdabot sick?
07:38:29 <kayess> The body is this: inner i (x, y) = x ++ i ++ y
07:38:31 <ihope> gaal: yep.
07:38:32 <Botje> yeah.
07:38:34 <junyer> doh
07:38:50 <nominolo> no, she's on vacation with googlebot
07:38:53 <kayess> I'm trying to curry it to use in map so I'm doing this: ( inner " leads to " )
07:38:59 * gaal routes flowers through dons
07:39:04 <kayess> I think I'm not understanding strings ...
07:39:18 <junyer> there's no freaky -f switch to ghc that i can abuse?
07:39:22 * junyer crosses his fingers
07:39:28 <ihope> kayess: String is the same thing as [Char] for most practical purposes.
07:39:31 <Botje> kayess: could you paste the code you're using on htpaste.org somewhere?
07:39:45 <kayess> sure. I'll give it a go
07:39:50 <Saizan> junyer, there's a "default" directive
07:40:43 <Saizan> !paste
07:40:44 <hpaste> Haskell paste bin: http://hpaste.org/
07:41:17 <kayess> Here it is: http://hpaste.org/1407
07:41:34 <kayess> I thought the first bit was going to be hard and the map easy, but I can't work out the types
07:41:47 <nominolo> Saizan: what kind of build error did you get?
07:42:35 <eumenides> >  concat $ intersperse " leads to " [ "fear", "anger", "hate", "suffering" ]
07:42:45 <Saizan> kayess: putStrLn expects a [Char] but you are giving it a [[Char]]
07:43:01 <fasta> What happens when I take a DiffArray and give it to two different functions which both only operate on half of the elements?
07:43:17 <junyer> -fextended-default-rules won't give me love, unfortunately
07:43:39 <Saizan> nominolo, i was using the build script and it stopped while compiling lambdabot with a warning
07:43:39 <junyer> (at least, the documentation doesn't suggest that it will.. and i just tried it)
07:43:42 <fasta> Will the DiffArray be copied a zillion times?
07:43:49 <hpaste>  (anonymous) annotated "yoda" with "(no title)" at http://hpaste.org/1407#a1
07:44:16 <Saizan> junyer, i wouldn't care, when you have more code you'll end up forcing the type anyway
07:44:23 <kayess> The error i get is with the inner function though, or am I misunderstanding the error message? added to hpaste
07:44:41 <junyer> actually, i did have more, but cut it down for the purposes of pasting
07:44:47 <junyer> (i was getting exactly the same error regardless)
07:45:10 <junyer> i.e. there was a HasPush and a HasPop
07:45:19 <junyer> instance HasPush MehQueue
07:45:21 <junyer> instance HasPush MehStack
07:45:26 <junyer> instance HasPop MehStack
07:45:58 <junyer> calling new and shift still had ambiguity
07:47:05 <Botje> how is haskell supposed to know which one to pick? they're both HasPush :)
07:47:17 <kayess> Thinking about it I can see I should be using fold rather than map
07:47:41 <hpaste>  (anonymous) annotated "yoda" with "(no title)" at http://hpaste.org/1407#a2
07:47:50 <Botje> kayess: foldl1 or foldr1, yes
07:48:11 <junyer> oh, there's an instance HasShift MehQueue already
07:48:23 <junyer> and since i was just calling shift, i figured it would be obvious
07:48:36 <junyer> i was actually wondering if i'd have to allow overlapping instances
07:48:41 <junyer> but that isn't even the case (yet)
07:48:50 <kayess> thanks. I guessed foldl
07:48:53 <junyer> at least, not in what i pasted :P
07:49:03 <kayess> I still get a similar error though
07:49:15 <hpaste>  (anonymous) annotated "yoda" with "(no title)" at http://hpaste.org/1407#a3
07:49:47 <eumenides> kayess: http://hpaste.org/1407#a2
07:50:32 <eumenides> kayess: works even better if you use unwords instead of concat :)
07:50:39 <kayess> Just saw it. concating the parts together makes sense, but still doesn't work
07:50:41 <tibbe> it's amazing how much you can miss a pen and paper when you don't have one :/
07:51:39 <eumenides> kayess: er, are you sure? works here
07:51:54 <Saizan> kayess, your first error was telling you that given your use of putStrLn, the function you gave to map should have Char as the return type, instead it has [Char], using concat or unwords solves the problem as eumenides said
07:54:10 <kayess> So the errors are kindof being reported inside out then and I should read them from the bottom?
07:55:52 <Saizan> "expected" is what the typecheker wants, "inferred" is what you have written, and it reports the error the first time that it can't find a type that matches both
07:56:14 <Saizan> and it can be far away from the point you have made a mistake
07:57:20 <Saizan> in this case if inner was  [a] -> ([a], [a]) -> a, the code would have passed the typechecking
07:57:27 <kayess> A little idiocy with brackets and concat sorted it out and I'm nearly there: fear leads to angeranger leads to hatehate leads to suffering
07:57:43 <eumenides> kayess: use unwords instead of concat
07:58:27 <junyer> thanks anyway, folks
07:58:30 <tibbe> kayess, it sometimes helps to add explicit type signatures to your top level functions to make sure you and the type checker agree on the type of a function, it can sometimes make type errors appear closer to the source. It also serves as good documentation and finally it's required for Haddock documentation
07:58:34 <kayess> I still want the commas in there, but at least unwords gives the spaces. Thanks everyone
07:58:36 <Saizan> kayess, you'll learn to understand the errors better
07:58:38 <junyer> might have to google a bit/lot more
07:58:50 <junyer> (because now i'm really stuck)
07:59:03 <junyer> i'm not even using -fglasgow-exts yet :/
07:59:18 <kayess> Learning to read errors always seems to be the first and hardest thing to learn :-)
08:00:45 <kayess> "it sometimes helps to add explicit type signatures to your top level functions" do you main? I've added them to the two functions I wrote (haven't I?)
08:00:52 <Saizan> putStrLn . concat . map ( inner " leads to " ) . inner_duplicate $ [ "fear", "anger", "hate", "suffering" ]  <-- easier to read imho
08:01:12 <kayess> certainly less brackets
08:03:08 <roconnor> @pl (\x y -> x++" leads to "++y)
08:04:40 <kayess> that syntax looks a bit beyond me for the time being. I'm going to have to do some thinking about this dot for function composition before I start looking properly at the binding stuff
08:06:13 <xerox> roconnor, (. (++)) . (++ " leads to ")
08:07:50 <eumenides> kayess: you could also use print instead of putStrLn. then you'd see the ["fear leads to anger","anger leads to hate","hate leads to suffering"] as the output and you'd know that you have to concat it
08:08:26 <roconnor> @xerox-snack
08:08:31 <xerox> :)
08:09:02 <Saizan> isn't  :t (. (++)) . (++ " leads to ")
08:09:02 <Saizan> <interactive>:1:11:
08:09:02 <Saizan>     Couldn't match expected type `([a] -> [a]) -> c'
08:09:02 <Saizan>            against inferred type `[Char]'
08:09:02 <Saizan>     In the second argument of `(.)', namely `(++ " leads to ")'
08:09:09 <kayess> emenides, that's kind of how I was expecting printStrLn to work. I guess the Str in the name should have given it away
08:09:26 <Saizan> (++) . (++ "leads to"), seems to work
08:09:48 <xerox> :(
08:09:49 <xerox> silly infix operators
08:09:53 <sorear> .
08:09:53 <eumenides> kayess: http://undergraduate.csse.uwa.edu.au/units/230.301/lectureNotes/tourofprelude.html
08:10:00 <xerox> hiya sorear
08:10:07 <sorear> do I need to bring lb back?
08:10:12 <Saizan> yeah
08:10:13 <sorear> @botsnack
08:10:21 <xerox> sorear, do you use ./build to build lb?
08:10:26 <sorear> yes
08:10:34 <sorear> after editing it ;)
08:10:39 <sorear> sh build actually
08:10:57 <Saizan> which cabal?
08:11:04 <xerox> I find I need ./BotPP instead of BotPP for one
08:11:11 <xerox> but still..
08:11:29 <sorear> sh build should handle everything.
08:11:47 <kayess> I'd just been going through the first few pages of this http://haskell.org/tutorial/index.html to get me started
08:12:14 <sorear> modulo the stuff I needed to change because my 'ghc' is incompatible with LB, i did a fresh get, sh build, edit online.rc, ./lambdabot -e rc\ online.rc
08:12:14 <xerox> from ghci it works at least
08:12:36 <sorear> if you tried to install, that's your problem
08:12:53 <xerox> np, it doesn't pass the build phase
08:13:15 <xerox> it gave me /tmp/ghc1087_0/ghc1087_8.hspp:21:1: lexical error at character 'i
08:13:22 <xerox> and now on a fresh get complains about binary
08:13:30 <xerox> @botsnack
08:13:30 <botlambda> :)
08:13:35 <xerox> > 2+2
08:13:35 <botlambda> Terminated
08:13:38 <xerox> @quit
08:15:02 <Saizan> @pl (\x y -> x++" leads to "++y)
08:15:09 <lb> (. (" leads to " ++)) . (++)
08:15:42 <Saizan> aww
08:15:46 <xerox> :)
08:17:41 <roconnor> @pl  (\l -> zipWith  (\x y -> x++" leads to "++y)  l (tail l)) [ "fear", "anger", "hate", "suffering" ]
08:17:42 <lb> ap (zipWith (flip ((.) . (++)) (" leads to " ++))) tail ["fear", "anger", "hate", "suffering"]
08:18:00 <eumenides> he wanted commas though
08:18:04 <xerox> nice
08:18:16 <roconnor> > intersperse ","  (\l -> zipWith  (\x y -> x++" leads to "++y)  l (tail l)) [ "fear", "anger", "hate", "suffering" ]
08:18:20 <lb>      The lambda expression `\ l -> ...' has one argument,
08:18:21 <lb>     but its type `[...
08:18:29 <roconnor> > intersperse ","  $ (\l -> zipWith  (\x y -> x++" leads to "++y)  l (tail l)) [ "fear", "anger", "hate", "suffering" ]
08:18:32 <lb>  ["fear leads to anger",",","anger leads to hate",",","hate leads to suffering"]
08:19:02 <roconnor> > concat $ intersperse ","  $ (\l -> zipWith  (\x y -> x++" leads to "++y)  l (tail l)) [ "fear", "anger", "hate", "suffering" ]
08:19:04 <lb>  "fear leads to anger,anger leads to hate,hate leads to suffering"
08:19:17 <roconnor> @pl concat $ intersperse ", "  $ (\l -> zipWith  (\x y -> x++" leads to "++y)  l (tail l)) [ "fear", "anger", "hate", "suffering" ]
08:19:19 <lb> join $ intersperse ", " $ ap (zipWith (flip ((.) . (++)) (" leads to " ++))) tail ["fear", "anger", "hate", "suffering"]
08:19:40 <roconnor> > join $ intersperse ", " $ ap (zipWith (flip ((.) . (++)) (" leads to " ++))) tail ["fear", "anger", "hate", "suffering"]
08:19:42 <lb>  "fear leads to anger, anger leads to hate, hate leads to suffering"
08:19:49 <sorear> xerox: if you're paranoid/careful enough to use tor, you might be interested to know botlambda connected directly.  Infostrada SpA, Milano
08:21:08 <xerox> haha.
08:25:03 <hpaste>  (anonymous) annotated "yoda" with "are we sure?" at http://hpaste.org/1407#a4
08:25:11 <ihope> I wonder what the largest number a person can get GHCi to output is...
08:25:39 <sorear> not hard at all!
08:25:46 <Botje> whichever limit the gmp library imposes
08:25:46 <ihope> ...not importing anything and using only ASCII input.
08:26:24 <ihope> GHCi seems to impose a limit on input length.
08:26:26 <Botje> (iterate (**3) 3) !! 6
08:26:38 <Botje> that's already pretty big :)
08:26:41 <ihope> (iterate (**9) 9) !! 9
08:26:46 <ihope> Bigger :-)
08:26:50 <Botje> duh.
08:27:07 <ihope> You can get pretty big... much bigger than Graham's number.
08:27:18 <eumenides> both countably infinite according to ghci :)
08:27:29 <ihope> Heh.
08:27:42 <sorear> Data.ByteString.Lazy> putStr (repeat 57)
08:28:11 <sorear> infinite string of nines, orutput from the same buffer (so just write(2), no cpu)
08:28:14 <sorear> i hope
08:28:21 <ihope> let graham n = iterate (hyper 3 (n+2) 3) 4 !! n
08:28:25 <ihope> graham 99999999999999...
08:29:06 <ihope> And isn't it putStr (repeat '9') you want?
08:29:12 <sorear> no
08:29:22 <Heffalump> sorear: I guess the thing you evaluate has to be of type Integer
08:29:24 <Heffalump> not type String
08:29:25 <sorear> So, what's the smallest number that can't be described in a IRC-length line of English?
08:29:35 <sorear> Heffalump: that was IO ()
08:29:45 <Heffalump> ok, not IO () either
08:30:15 <sorear> ihope: ByteString.Lazy uses numbers, not characters.
08:30:20 <Heffalump> I guess the other obvious restriction is that the number must actually be finite.
08:30:47 <sorear> ihope: I should have used ByteString.Lazy.Char8, but fixing that would have been harder then typing the ascii code for '9' from memory.
08:31:16 <ihope> You can putStr a ByteString?
08:31:23 <ihope> And yes, finite.
08:31:29 <Saizan> ?hoogle putStr
08:31:29 <lb> Prelude.putStr :: String -> IO ()
08:31:30 <lb> Prelude.putStrLn :: String -> IO ()
08:31:30 <lb> IO.hPutStr :: Handle -> String -> IO ()
08:31:47 <Saizan> ?type Data.ByteString.Lazy.putStr
08:31:51 <lb> Data.ByteString.Lazy.ByteString -> IO ()
08:33:24 <ihope> Interesting.
08:33:38 <araujo> morning
08:38:58 <xerox> > unfoldr (\xs -> listToMaybe [(x ++ " leads to " ++ y, tail xs) | (x:y:_) <- [xs]]) ["fear","anger","hate","suffering"]
08:39:00 <lb>  ["fear leads to anger","anger leads to hate","hate leads to suffering"]
08:41:00 <Saizan> cabal-install is very nice, especially the build-dep random.cabal thing
08:41:50 <LeCamarade> Does GHCi have any startup (conf) files?
08:43:23 <xerox> .ghcirc
08:43:34 <LeCamarade> Mais que personne ne reponds pas?
08:43:43 <LeCamarade> Oh, thanks.
08:43:55 <LeCamarade> I didn't see it in the man.
08:45:39 <LeCamarade> Didn't work!
08:45:58 <LeCamarade> xerox: .ghcirc no work (sic)!
08:46:10 <xerox> try .ghci ?
08:46:56 <mauke> wtf, why does ghci use a busy wait?
08:47:06 <LeCamarade> xerox: Worketh! Thanks fatly.
08:47:20 <xerox> np
08:47:24 <bos> mauke: it's the ghc non-threaded runtime.
08:53:14 <tibbe> is there a big difference in writing a recursive descent parser for LL(1) and LL(2)?
08:53:21 <tibbe> or any other LL(k) for that matter?
08:53:23 <sorear> no
08:53:40 <tibbe> I'm doing it as an exercise in haskell right now
08:53:43 <sorear> LL(2) just means you need to keep two lookahead tokens.
08:53:47 <tibbe> I could use a tutorial though
08:53:50 <tibbe> right
08:54:06 <sorear> if you're using a list as input, you can look as far ahead as you want (LL(omega))
08:54:16 <ihope> What the...
08:54:24 <sorear> ?
08:54:39 <tibbe> I have a couple of parser functions, some for nonterminals and some for terminals, right now I use look-ahead in both categories, is that excepted?
08:54:52 <ihope> The :i command was giving "Interrupted." every time.
08:55:23 <sorear> yes.
08:55:31 <sorear> this is a known quirk
08:55:32 <tibbe> what grammars can parsec parse?
08:55:38 <sorear> LL(omega)
08:55:41 <ihope> Any idea why?
08:55:55 <sorear> you used ^C at some point
08:56:06 <sorear> ghci registers ^C from one to five times
08:56:11 <sorear> just keep trying the :i
08:56:47 <sorear> tibbe: all of the computable, getParserState >>= myFunction
08:58:26 <tibbe> I think I remember seing an example of a parser in my Programming Languages course at CTH :) I'll go check it out
09:07:36 <kayess> Ok. thanks everyone. I got something that works and I understand. I'll have to push my knowledge out further later though. It's later here
09:24:13 <eivuokko> When ext-core output in ghc starts working again, what will it contain from System FC?  Will there be type level coercions or will they just show up as "runtime" casts?  Or have I misunderstood something?
09:29:40 <sorear> eivuokko: ext core feeds into the core path, it has to be able to lint and everytinh
09:33:54 <tuxplorer> Question from YAHT: Write a datatype Tuple which can hold one, two, three or four elements, depending on the constructor (that is, there should be four constructors, one for each number of arguments)
09:33:54 <tuxplorer> When I try to overload constructors, I get an error that "Constructor `Tuple' should have 1 argument, but has been given 2 When checking the pattern: Tuple a b In a pattern binding: Tuple a b = Tuple a b"
09:35:24 <tuxplorer> Initial definition: data Tuple a = Tuple a
09:35:39 <tuxplorer> What should I do?
09:36:13 <tibbe> what's the performance difference between using a monadic parser and a direct recursive descent implementation?
09:38:08 <Philippa> that'll vary from haskell implementation to haskell implementation
09:38:26 <eivuokko> sorear, I am not sure I understood implications... Does that mean the ext-core typesystem will be more complex?
09:38:44 <Philippa> theoretically it should be possible to make it pretty much equivalent
09:38:52 <sorear> eivuokko: no, it should be the same as Core (much simpler than haskell)
09:39:35 <Philippa> sorear: the answer he's looking for is "yes, all the FC stuff should be there because it's in Core" :-)
09:40:04 <eivuokko> The FC stuff in ext-core typesystem would be major headache.
09:40:34 <Philippa> why? It shouldn't be particularly, it doesn't even show up unless code uses the relevant extensions
09:40:50 <tuxplorer> The question that I asked above may be trivial, but I've been struggling with it.. I want to learn haskell properly.. If someone can help me with that it would be gr8..
09:41:01 <eivuokko> Well, I don't understand System FC typesystem coecion stuff ;)
09:41:47 <sorear> cast :: a -> TEq a b -> b
09:41:54 <Philippa> tuxplorer: that definition shows us a single type constructor (Tuple), with a single data constructor (also called Tuple) that takes a single parm
09:41:57 <sorear> that's basically all you need to know
09:42:04 <eivuokko> Hmm
09:42:07 <Saizan> tuxplorer, you have to define all your constructors in the same data declaration
09:42:19 <sorear> (note that type equalities are *types*, but that can be ignored)
09:42:27 <eivuokko> sorear, And that could only show up in forall-contexts?
09:42:37 <tuxplorer> Saizan: using | ?
09:42:45 <Saizan> tuxplorer, yes
09:43:07 <tuxplorer> Saizan: Thanks.. will try that and ask you people if I have any more doubts
09:43:18 <Saizan> k :)
09:45:34 <tuxplorer> data Tuple a b c d = Tuple a | Tuple a b | Tuple a b c | Tuple a b c d
09:45:34 <tuxplorer> what is wrong with this? or how should I change it for it to work? It says multiple declaration..
09:46:06 <Saizan> you can't have different contructors with the same name
09:46:10 <Lemmih> tuxplorer: Tuple1 a | Tuple2 a b ...
09:47:03 <tuxplorer> Lemmih: oh! ok.. The constructors should have diff names unlike the overloaded constructors in C++, Ruby and the likes?
09:47:47 <ihope> Yep. Different names are required.
09:47:50 <Saizan> you don't overload contructors in OO, do you?
09:48:25 <Lemmih> tuxplorer: Yes, overloading is a bit more tricky when you have a type-system.
09:48:48 <tibbe> how do I make QuickCheck create data constructors of a data type I have? data F = L String | V String
09:49:03 <tuxplorer> Saizan: yes, we do..
09:49:14 <tuxplorer> Thanks everyone.. for getting me past that hurdle :)
09:51:49 * Saizan realizes that haskell has shifted his understanding of the word "overload"
09:52:21 <Saizan> overload -> typeclasses for me, instead in OO overload -> variadic functions, right?
09:53:28 <Heffalump> OO overloading isn't particularly about variadic functions
09:53:51 <Saizan> well same function name with different arguments
09:53:59 <Heffalump> yeah
09:54:04 <Heffalump> though actually that's not particularly OO-ish
09:54:09 <Heffalump> it just happens C++ and Java have it
09:54:26 <Heffalump> OO really is about overloading based on receiver types
09:54:34 <tuxplorer> Saizan:  oh! yes I took the word Overload in that sense of variadic fns only :)
09:54:42 <Heffalump> either dynamically (Java, and C++ virtual functions) and statically (C++ non-virtual functions)
09:55:02 <Heffalump> in Haskell the only overloading mechanism is typeclasses, as you say
09:55:23 <Mitar> is there any already existing function which would compare dtwo float numbers and return true if they are aproximately equal?
09:58:14 <stepcut> aboutEqual f1 f2 = True
09:58:15 <stepcut> ;)
09:59:06 <_roconnor> Mitar: I wrote one
09:59:15 <Mitar> :-)
09:59:45 <_roconnor> class AlmostEq a where
09:59:45 <_roconnor>  almostEq :: a -> a -> Bool
09:59:53 <_roconnor> infix 4 `almostEq`
10:00:01 <Heffalump> stepcut: that's not already existing. Arguably (const (const True)) is, though.
10:01:25 <_roconnor> instance AlmostEq Scalar where
10:01:25 <_roconnor>  a `almostEq` b = abs (a-b) < sqrt epsilon
10:01:26 <stepcut> Heffalump: true
10:01:44 <_roconnor> where Scalar = Double
10:01:58 <tuxplorer> Is there a solution manual for YAHT, where I can refer for solutions if something that I try with the exercise doesn't work out well?
10:02:00 <_roconnor> and epsilon = encodeFloat 1 (fromIntegral $ 1-floatDigits epsilon)
10:02:37 <_roconnor> @type encodeFloat
10:02:39 <lb> forall a. (RealFloat a) => Integer -> Int -> a
10:02:57 <_roconnor> I should make that instance (RealFloat a) => AlmostEq a
10:04:37 <_roconnor> of course one may prefer relative error rather than absolute error, depending on your application
10:04:59 <_roconnor> ... in fact relative error would probably be better in general
10:10:37 <Saizan> ?go wikibook YAHT
10:10:39 <lb> http://en.wikibooks.org/wiki/Haskell/YAHT
10:13:15 <DRMacIver> Hm. Anyone know of a good source to read about bayesian filtering? I new how it worked at one point, but my probability is really rusty.
10:13:26 <DRMacIver> bayesian spam filtering even
10:18:24 <tibbe> I have: "data F = L String | V String; instance Arbitrary F where, arbitraray = oneof [liftM L arbitraray, liftM V arbitrary]" why doesn't it work?]
10:19:17 <Saizan> ?type arbitrary
10:19:20 <lb> Not in scope: `arbitrary'
10:19:32 <Saizan> isn't arbitrary just a list?
10:19:51 <tibbe> it's a QuickCheck function
10:19:57 <tibbe> ?hoogle arbitrary
10:19:58 <lb> Test.QuickCheck.arbitrary :: Arbitrary a => Gen a
10:19:58 <lb> Test.QuickCheck.Arbitrary :: class Arbitrary a
10:19:58 <lb> Test.QuickCheck.coarbitrary :: Arbitrary a => a -> Gen b -> Gen b
10:20:09 <Saizan> ?hoogle Gen
10:20:11 <lb> Test.QuickCheck.Gen :: data Gen a
10:20:11 <lb> Distribution.Extension.Generics :: Extension
10:20:11 <lb> Data.Generics.Aliases.Generic' :: Generic c -> Generic' c
10:20:52 <tibbe> hmm, it looks like QC doesn't have an Arbitrary instance for Char, how come?
10:21:07 <tibbe> that would probably one of the first instances I would expect
10:31:46 <chessguy> DRMacIver: you should read paul graham's Plan for Spam
10:32:03 <chessguy> and Ed Kidd recently blogged about doing it in haskell too
10:32:29 <chessguy> http://www.paulgraham.com/spam.html is the first
10:32:30 <lb> Title: A Plan for Spam
10:33:09 <chessguy> http://www.randomhacks.net/articles/2007/03/03/smart-classification-with-haskell is the second
10:33:12 <lb> Title: Smart classification using Bayesian monads in Haskell, http://tinyurl.com/yosb9v
10:34:59 <DRMacIver> chessguy: Thanks
10:39:08 <ariks> damn.. "probably no" for extensible records in haskell-prime =(
10:40:40 <ariks>  2
10:40:48 <ariks> http://hackage.haskell.org/trac/haskell-prime/report/9
10:40:50 <lb> Title: {9} Proposals - Haskell Prime - Trac
10:42:40 <tibbe> is there a way to assure that the lists generated by arbitrary is of at least length 1?
10:43:42 <chessguy> what do you mean by extensible?
10:44:22 <roconnor> @check \l -> (1 <= length l) ==>  (length l > 0)
10:44:24 <lb>  Add a type signature
10:44:37 <roconnor> @check \(l::[Int]) -> (1 <= length l) ==>  (length l > 0)
10:44:38 <lb>  Parse error in pattern
10:44:54 <roconnor> @check \l -> (1 <= length l) ==>  (length (l::[Int]) > 0)
10:44:56 <lb>  OK, passed 500 tests.
10:45:28 <roconnor> @check \l -> (not . null $ l) ==>  (length (l::[Int]) > 0)
10:45:30 <lb>  OK, passed 500 tests.
10:45:54 <chessguy> @pl \p l -> p l
10:45:55 <lb> id
10:46:00 <sorear> hi.
10:46:10 <chessguy> hi sorear
10:47:51 <chessguy> i'm not sure i get the point of church encodings
10:48:03 <chessguy> for example, church-encoded booleans
10:48:09 <sorear> the point is, data is unneccessary
10:48:16 <chessguy> but it's not
10:48:19 <sorear> ?
10:48:37 <chessguy> ok, so you would encode True as \t f -> t, right?
10:48:46 <sorear> right,
10:48:49 <sorear> .
10:49:09 <chessguy> but that doesn't do anything useful unless you supply some kind of values
10:49:18 <sorear> eh?
10:49:28 <sorear> just supply more church values
10:49:34 <ariks> chessguy: "We can extend a record r with a label l and value e
10:49:35 <ariks> using the syntax fl = e j r"
10:49:57 <ariks> from, http://www.cs.uu.nl/~daan/download/papers/scopedlabels.pdf
10:49:58 <chessguy> let me find the example TAPL gives
10:50:17 <DRMacIver> Hm
10:50:21 <chessguy> ok, this is what the book gives:
10:50:25 <chessguy> let tru = \t f -> t
10:50:31 <chessguy> let fls = \t f -> f
10:50:40 <chessguy> let test = \l m n -> l m n
10:50:44 <DRMacIver> You know, I think Haskell is currently the only language which gives me "That's *so* cool" moments. :)
10:50:54 <chessguy> and evaluate test tru v w
10:51:01 <DRMacIver> Even if it's not neccessarily the one I want to program in on a regular basis.
10:51:22 <chessguy> but unless you do something like let v = "True", and likewise for w, that doesn't do much
10:51:41 <ariks> DRMacIver: if you are referring to  what i pasted, that doesn't work in haskell
10:51:48 <sorear> let not x = x fal tru
10:51:48 <pejo> chessguy, v and w are the "then" and "else" branches of that test.
10:51:54 <sorear> it does too!
10:52:12 <DRMacIver> ariks: No, I'm not.
10:52:34 <chessguy> but you have to have values at some point
10:52:36 * DRMacIver is playing with the probabilistic functional programming library.
10:52:46 <pejo> chessguy, lambda abstractions are values.
10:53:23 <chessguy> well yeah, but i mean more of what we would usually think of as values
10:53:33 <chessguy> like "true" or "false"
10:54:09 <chessguy> and again with church-encoded numbers
10:54:13 <mauke> true is \a b -> a
10:54:20 <pejo> chessguy, I don't understand what you mean. We usually thin of lambda abstractions as values.
10:54:21 <mauke> that's a perfectly fine value
10:54:44 <chessguy> i'm not saying it's not valid
10:54:50 <chessguy> i'm saying i don't see how its useful
10:55:21 <mauke> you can write programs with it
10:55:32 <pejo> chessguy, it allows us to work in a small calculus, simplifying proofs and such. You don't gain anything by adding more values.
10:56:01 <chessguy> see, that's what i don't get. how you don't gain anything by adding more values
10:56:18 <pejo> chessguy, you can still compute the same thing, no more, no less.
10:56:23 <chessguy> like ok, let 0 = \s z -> z
10:56:33 <chessguy> let 1 = \s z -> s z
10:56:43 <chessguy> how would i calculate 0 + 1 = 1
10:56:50 <sorear> chessguy: we can still get information out, without values!
10:56:55 <sorear> chessguy: termination!
10:57:06 <chessguy> well, ok, information, yes
10:57:10 <chessguy> but not values
10:57:38 <mauke> we get functions, which are values
10:57:56 <chessguy> hmm
10:58:02 <chessguy> i would say they represent values
10:58:14 <pejo> chessguy, plus = \m n s z -> m s (n s z)
10:58:50 <chessguy> pejo: yes, and if you plug the church-encoded 0 and 1 into that, you'll get back \s z -> s z
10:58:52 <chessguy> but that's not 1
10:59:05 <sorear> yes it is ?
10:59:13 <chessguy> it's the church-encoding of 1
10:59:17 <_frederik_> what is the proper way to handle generated code in cabal?
10:59:32 <sorear> -pgmF I'm afraid
10:59:45 <mauke> it looks like a 1, it quacks like a 1, ...
11:00:22 <chessguy> heh
11:01:34 <pejo> chessguy, check page 67, if you insist on refusing to call lambda abstractions for values.
11:02:10 <chessguy> the factorial thing
11:02:12 <chessguy> ?
11:02:24 <pejo> chessguy, and page 72 defines lambda abstractions as values, if you look ahead a little.
11:02:53 <pejo> chessguy, no, the "Representation" section.
11:03:11 <chessguy> ah
11:03:29 <balodja> what's the use of Monad.Reader? is there any article of something like that?
11:05:27 <chessguy> ok, i guess this is really addressing my concern: "Putting all this together, suppose we have a whole program that does some complicated calculation with numbers to yield a boolean result. If we replace all the numbers and arithmetic operations with lambda-terms representing them and evaluate the program, we will get the same result. Thsu, in terms of their effects on the overall results of programs, there is no observable differ
11:05:27 <chessguy> ence between the real numbers and their Church-numeral representation"
11:06:19 <chessguy> so lambda terms are just a representation of plato's idea of 3, just as the symbol '3' is.
11:08:04 * chessguy goes to ponder this for a bit
11:08:18 <_frederik_> sorear: -pgmF?
11:11:22 <sorear> it's a ghc-options
11:11:26 <sorear> @where manual
11:11:26 <lb> I know nothing about manual.
11:11:59 <sorear> http://haskell.org/ghc/dist/current/docs/users_guide/options-phases.html#pre-processor
11:12:01 <lb> Title: 4.10. Options related to a particular phase, http://tinyurl.com/2s44y5
11:13:45 <_frederik_> sorear: thanks, so how do i do that?
11:14:04 <ddarius> chessguy_away: Uh, yeah.  That's the point.  Bitfields are just as much a representation of numbers/bools as are lambda terms.  If we had out putStr that took lambda terms instead of [Char] we would be good.
11:14:17 <_frederik_> like: GHC-Options: -pgmF my-cmd
11:14:21 <_frederik_> will that work in the cabal file?
11:14:46 <sorear> _frederik_: yes.
11:14:52 <sorear> you may also need -F
11:14:59 <sorear> and read the docs!
11:15:12 <sorear> -pgmF does *not* use the normal unix calling convention
11:17:23 <_frederik_> sorear: so i have a perl script which spits out a bunch of haskell code, how do i make sure it is run whenever the resulting file is needed?
11:17:33 <_frederik_> i don't think it is clear from the documentation
11:18:12 <DRMacIver> A perl script which outputs Haskell code...
11:18:17 <sorear> ah, that's a bit different :(
11:18:29 <sorear> pgmF won't easily help you here
11:18:47 <sorear> there isn't really a good way
11:18:55 <_frederik_> yeah, i think you thought i meant "preprocessed" by "generated"
11:19:13 <sorear> people usually go to autotools at this point :(
11:19:21 <_frederik_> autotools?
11:19:26 <twanvl> You could handle it as preprocessing some dummy file
11:20:30 <_frederik_> twanvl: have you tried that?
11:20:45 <twanvl> no
11:21:19 <_frederik_> also, i'm curious how i can tell cabal to only pass these options to ghc for one particular file
11:21:28 <_frederik_> or if i should put them in OPTIONS_GHC at the top of that file
11:21:33 <_frederik_> (e.g. the dummy file)
11:23:50 <_frederik_> i told simon that it would be nice if i could just specify a command, 'make' in my case, which should be run before each file is read, with that file as an argument. but he didn't understand the reason for that
11:23:57 <_frederik_> (simon marlow i think)
11:24:29 <sorear> _frederik_: autotools == autoconf + (auto)make
11:24:52 <_frederik_> sorear: how will that help?
11:25:09 <_frederik_> sorear: i was under the impression that autotools was kind of lame
11:25:33 <_frederik_> how do i tell cabal to only preprocess one file?
11:26:02 <sorear> they are quite powerful and general.  far more general than cabal.  but harder to use, and less haskell-specific automation (haddocks, etc)
11:26:30 <_frederik_> or do i have to tell cabal to preprocess every file?
11:28:54 <glguy> rather than having ghc or cabal call make for you, it seems like you should be having make call ghc for you
11:30:30 <_frederik_> glguy: that is one possibility
11:31:02 <_frederik_> glguy: but it doesn't work very well; for instance if the files in question are used by multiple executables then i have to have make list the generation rule for each one
11:31:30 <_frederik_> glguy: since make can't see the dependencies that ghc knows about
11:32:17 <Saizan> you can get them with ghc -M YourTopmodule.hs
11:32:39 <Saizan> appended to ./Makefile
11:33:08 <Cheery> does haskell use TIGRE?
11:33:28 <_frederik_> Saizan: those are not enough, IIRC, they require hand-listing of all source files
11:33:56 <nominolo> @go TIGRE
11:33:57 <lb> http://www.holdthattiger.com/
11:33:57 <lb> Title: Le TIGRE
11:34:31 <nominolo> Cheery: ghc uses STG
11:34:48 <nominolo> no idea about yhc or hugs
11:38:06 <nominolo> Do people have some general (or specific) complaints about or feature requests for cabal?  I am going to work on cabal-config during SoC, but this might be a bit too few work, ie. i'd maybe have time to do some further hacking
11:38:33 <Cheery> @google STG
11:38:35 <lb> http://www.stginc.com/
11:38:35 <lb> Title: STG, Inc. - Customer focused. Performance based.
11:38:46 <Cheery> @google STG haskell
11:38:48 <lb> http://programming.reddit.com/info/1at09/comments
11:38:48 <lb> Title: ask reddit: thoughts on writing a Haskell/Lisp hybrid language (reddit.com)
11:38:48 <nominolo> @go spineless tagless g-machine
11:38:50 <lb> http://citeseer.ist.psu.edu/peytonjones92implementing.html
11:38:50 <lb> Title: Implementing lazy functional languages on stock hardware: the Spineless Tagless  ...
11:39:06 <LeCamarade> nominolo: Oh, lord!
11:39:09 <LeCamarade> Nice!
11:39:22 <nominolo> should i create a wiki-page?
11:39:29 <LeCamarade> Already!
11:41:00 <jcpetruzza> i'm using cabal for the first time, and i'm following the indications in http://en.wikibooks.org/wiki/Haskell/Packaging
11:41:01 <lb> Title: Haskell/Packaging - Wikibooks, collection of open-content textbooks
11:42:06 <jcpetruzza> i configured it with --prefix=$HOME and can build it fine
11:42:48 <jcpetruzza> however, when i try to install it, i get: Unable to rename "/opt/local/lib/ghc-6.6/package.conf" to "/opt/local/lib/ghc-6.6/package.conf.old"
11:43:03 <jcpetruzza> do i need to be root even to install it on my home dir?
11:45:26 <bringert> nominolo: one thing that could help you with how to get configurations right could be to try to use configurations for a bunch of existing packages. The largest problem requiring configurations right now is that modules keep moving between packages.
11:45:38 <bringert> nominolo: for example Data.ByteString moved from fps to base
11:47:24 <nominolo> bringert: consider it noted
11:47:28 <bringert> nominolo: ah, that was the use case in the proposal :-)
11:47:45 <sorear> jcpetruzza: you need to configure with --user as well as --prefix
11:48:02 <bringert> nominolo: the part at the bottom of http://www.mail-archive.com/cabal-devel@haskell.org/msg00282.html would also be nice
11:48:03 <lb> Title: Configurations proposal, take n
11:48:19 <bringert> with backward compatibility of course
11:48:34 <sorear> jcpetruzza: --prefix says where to put the files, but GHC uses a database to find the files; --user specifies to update the database in $HOME
11:48:35 <nominolo> bringert: you mean the different syntax?
11:49:30 <bringert> yeah
11:49:38 <jcpetruzza> sorear: thank you very much
11:49:49 <sorear> jcpetruzza: you're welcome
11:52:24 <nominolo> hm, how hard would it be to extract configuration settings automatically?
11:52:30 <nominolo> i.e. using import statements
11:52:39 <nominolo> and maybe some feedback from hackage
11:53:20 <eumenides> what does hpaste use to do the syntax colouring?
11:53:25 <sorear> HsColour
11:53:29 <sorear> @where HsColour
11:53:30 <lb> http://www.cs.york.ac.uk/fp/darcs/hscolour/
11:53:35 <bringert> nominolo: that could be an interesting tool, but it should probably to outside of cabal itself
11:53:45 <sorear> would someone with proportional fonts proofread this: http://members.cox.net/stefanor/wl-ppr-html/wl-pprint/index.html
11:53:52 <bringert> nominolo: there are some more things to tackle: http://hackage.haskell.org/trac/hackage/report/3 :-)
11:53:58 <lb> Title: {3} All Tickets by Milestone - Hackage - Trac
11:54:15 <bringert> sorear: Wadler\/Leijen ?
11:54:19 <nominolo> bringert: yep, needs a complete haskell parser as a dependency, too
11:54:39 <bringert> nominolo: why a complete parser?
11:54:58 <bringert> nominolo: wouldn't parsing imports be enough?
11:54:59 <sorear> bringert: should be Wadler/Leijen
11:56:08 <nominolo> bringert: well, maybe figuring out which functions + types are actually used might help pin down a package version
11:56:34 <nominolo> bringert: but it gets really tricky once someone uses preprocessing or TH
11:56:43 <bringert> nominolo: ah. that sounds tricky, you would also need a type checker
11:56:59 <bringert> nominolo: to figure out what types functions are expected to have
11:57:00 <nominolo> bringert: ghc-api could work
11:57:03 <bringert> yeah
11:57:12 <nominolo> but that's waay into the future
11:58:44 <sorear> bringert: aside from that escape glitch, does it look uploadable?
11:59:18 * sorear contemplates writing a Cabal competetor as an extension module for autotools
11:59:29 <bringert> sorear: <$> and </> in the intro are not linked
12:00:01 <sorear> Those symbols are used sooo often... you think they should be linked?
12:00:24 <sorear> if so, '</>' is certainly easier to type than @\<\/\>@ :)
12:00:40 <bringert> sorear: not in all the code examples, but maybe in the intro?
12:00:48 <bringert> sorear: all the other functions are linked there
12:00:54 <bringert> sorear: but it's not important
12:01:09 <bringert> sorear: I haven't read it all carefully, but it looks good to me
12:01:19 <bringert> sorear: definitely uploadable
12:02:06 <sorear> If I upload to hackage, is there any reason to bother keeping tarballs and haddocks on my web-space?
12:05:23 <sjanssen> sorear: I don't see any good reason
12:05:40 <sjanssen> hackage should be the first place anyone looks for such things, anyway
12:09:30 <nominolo> does hackage host haddock docs, already?
12:10:33 <sjanssen> yep
12:11:09 <nominolo> hm, the links for fps are broken, btw
12:14:09 <Cale> fps is part of the ghc distribution now anyway
12:18:41 <sorear> hmm.  I wonder if I should cc the announce to Daan
12:20:52 <chessguy> is there darcs access to hackage?
12:21:33 <bringert> chessguy: you mean a darcs repo for the code for the web interface? or something else?
12:21:37 <sorear> not afaik
12:22:05 <dmead> sup haskellers
12:22:30 * sorear just finished packaging Daan Leijen's pretty printing code
12:22:34 <sjanssen> work
12:22:40 <chessguy> i mean if there's a page on the website for a package foo which you can download as foo.gz, then you should also be able to do something like darcs get http://darcs.hackage.org/foo
12:22:41 <sjanssen> s/work/word
12:23:10 <sjanssen> chessguy: no darcs integration in hackage ... for now
12:23:23 <chessguy> boo!
12:24:16 <thoughtpolice> is the stm library stable enough to use in production code?
12:24:26 <sorear> definitely
12:24:48 <thoughtpolice> wondering, 'cause the lib page on it says experimental
12:25:00 <chessguy> ?source stm
12:25:01 <lb> stm not available
12:25:06 <chessguy> ?docs stm
12:25:07 <sorear> it's only been here for two years of stable releases ;)
12:25:07 <lb> stm not available
12:25:16 <sorear> ?docs Control.Concurrent.STM
12:25:17 <lb> http://haskell.org/ghc/docs/latest/html/libraries/stm/Control-Concurrent-STM.html
12:25:21 <Heffalump> I'd say the bigger question is how widely used it is
12:25:33 <Mitar> why I am getting .pref file empty? and in .stat file I get only command line?
12:26:22 <MarcWeber> matthew-_: ping. On which os are you working?
12:36:29 <tibbe> is there such a thing as "map" with look-ahead?
12:36:47 <tibbe> I'm writing a merge to merge pairs of elements
12:37:02 <tibbe> according to some criteria (having the same constructor)
12:37:59 <monochrom> you have to write it yourself.
12:39:08 <sorear> it's not hard
12:39:12 <sorear> @ty map . inits
12:39:16 <lb>     Couldn't match expected type `a -> b'
12:39:16 <lb>            against inferred type `[[a1]]'
12:39:17 <sorear> @ty map . tails
12:39:20 <lb>     Couldn't match expected type `a -> b'
12:39:20 <lb>            against inferred type `[[a1]]'
12:39:25 <sorear> @ty map ?f . tails
12:39:28 <lb> forall b a. (?f::[a] -> b) => [a] -> [b]
12:40:16 <kaol> what does ?f mean in that?
12:40:25 <sorear> implicit parameter
12:40:32 <sorear> it's an obscure ghc ext
12:40:54 <sorear> I discovered a month or two ago that it could be used as a placeholder in @ty
12:45:45 <balodja> class (Monad m) => MonadReader r m | m -> r where ...
12:45:55 <balodja> what is the meaning of | m -> r?
12:46:09 <sorear> funcitonal dependency
12:46:11 <tibbe> if you choose and m you must specify r
12:46:20 <tibbe> a functional dependency
12:46:27 <sorear> @where manual
12:46:27 <lb> I know nothing about manual.
12:46:28 <tibbe> or so I think ;)
12:46:37 <Heffalump> no, it means if you choose an m, r is uniquely determined
12:46:40 <sorear> @where+ manual http://haskell.org/ghc/dist/current/docs/users_guide/
12:46:41 <lb> Done.
12:46:47 <Heffalump> and it'll reject instances that violate that
12:46:57 <sorear> http://haskell.org/ghc/dist/current/docs/users_guide/other-type-extensions.html#functional-dependencies
12:46:59 <lb> Title: 7.5. Other type system extensions, http://tinyurl.com/ywd9d4
12:47:23 <balodja> thank you
13:05:49 <Cheery> You know what would be a breakthrough? map lambda calculus to easy-to-implement and efficient cellular computer
13:06:06 <balodja> so, as i understand in '| m -> r' m means not a Monad, but an instance of Monad? and since 'm determines r' m there in fact means 'm r'?
13:06:47 <Cheery> it'd be a breakthrough in kind because that'd be quite ultimate at making parallel machines
13:07:28 <Cheery> with easy-to-understand language. :)
13:11:32 <dons> moin
13:11:49 <Cheery> hi
13:12:06 <ndm> @seen sorear
13:12:07 <lb> sorear is in #darcs, #ghc, #haskell-overflow, #haskell-blah and #haskell. I last heard sorear speak 25m 9s ago.
13:14:23 <ndm> sorear: did you send me an updated public key?
13:16:31 <sorear> I think so
13:16:46 <sorear> I tried to
13:16:50 <sorear> hi dons.
13:17:04 <tibbe> morning dons
13:17:06 <tibbe> @localtyme
13:17:34 <sorear> ndm: I have a feeling what I sent you wasn't actually my public key.  but whatever it was, it DID come from me.
13:17:48 <ndm> sorear: cool, will upload it on monday - just with an unsecure email i'm careful about uploading public keys :)
13:18:10 <sorear> understandably ;)
13:30:41 <jcreigh> dons: when you say that clockwise vs. counterclockwise focusing/promoting is a "feature" in Operations.hs, are you being sarcastic?
13:30:46 <eumenides> @src Control.Monad
13:30:46 <lb> Source not found. Do you think like you type?
13:31:03 <dons> jcreigh: yes.
13:31:16 <dons> it means, i could't , in 20 mins, work out how to make it always go CW.
13:31:23 <jcreigh> dons: ah, okay.
13:31:39 <dons> or, I could, but that changed the semnatics of wide mode a bit
13:31:51 <dons> where the mster window wasn't the focused window when switching
13:32:08 <dons> that's the behaviour i'd like: focus window in mode N always becomes master in mode N+1
13:32:12 <dons> and cycling always goes CW
13:32:31 <dons> and master in Tall stays as master in Wide
13:32:32 <tibbe> hmm, what would be an idiomatic way of organizing QuickCheck tests? separate file? do I need a separate runner so I can have darcs run them on comit?
13:32:54 <dons> jcreigh: just fixing the CW issue would be enough
13:33:04 <dons> then we can think for 0.2 about simpler layout configuration
13:33:28 <jcreigh> dons: yes, it seems like focus and cycling should always go the same way...hmm...
13:34:00 <dons> i was thinking: Full screen focued -> master tall -> master wide -> fullscreen focus
13:34:06 <dons> in terms of what happens when switching modes
13:34:12 <jcreigh> dons: BTW, in the future, if something is a bug, I'd be less confused if it was called a bug. ;)
13:34:18 <dons> ah ok. :-)
13:34:27 <dons> well, we can live with it, its just odd.
13:34:37 <dons> maybe we could switch back to the old style promote, not sure.
13:34:49 <dons> though i find the cycling mode more 'predictable'
13:34:54 <jcreigh> oh, right. that would be nice too. (If focused fullscreen became master)
13:35:08 <dons> as sjanssen has said (that we can always predict what the screen looks like befire hitting a key)
13:35:21 <jcreigh> dons: well, focus suffers from the same issue. (mod-jk is CW in tall, CCW in wide)
13:35:30 <dons> ah, ok.
13:35:43 <dons> that's interesting. so the wide mode is rendered in reverse order
13:35:52 <dons> you can reverse the list, then render, then cycling works
13:35:57 <dons> but the master window is messed up
13:36:07 <dons> maybe that could be tweaked a bit.
13:36:14 <jcreigh> yeah, I'll try to think of some way to fix that today.
13:36:26 <jcreigh> (the CC vs. CCW issue)
13:36:32 <dons> ok.
13:36:40 <x2Fusion> Download today, http://beam.to/picy
13:36:45 <dons> grr
13:36:53 * dons out and about. bbl
13:37:03 <sjanssen> I think the current behavior is correct
13:37:59 <dons> which behaviour? :-)
13:38:12 <sjanssen> mod-j in tall and wide mode
13:38:20 <dons> the cycling order, or the master->master->focus issue (i think that is correctly currently)
13:38:50 <dons> ah, it just goes in reverse order though. so not a clockwise direction.
13:38:59 <dons> its more, what, left->right,up-.down ?
13:39:09 <sjanssen> both of them are right, I think
13:39:35 <dons> what's your thought on how this interacts with promote cycling?
13:39:45 <dons> since then its more obvious which direction things go? you find it ok?
13:40:04 <dons> so the rule is, left to right, then down.
13:40:17 * dons stops thinking in terms of clockfaces
13:40:56 <sjanssen> the reason one is cw and the other is ccw is because one layout is a mirror image of the other
13:41:07 <dons> yeah.
13:41:26 <dons> maybe we can have some text explaining this?
13:41:34 <sjanssen> yeah, we should
13:41:36 <dons> explaining the connection between the two modes.
13:41:56 <dons> sjanssen: i like your goal, as you stated a few days ago, about predictability of window placement.
13:42:04 <dons> i think that makes a good guiding principle
13:42:10 <dons> that distinguishes xmonad from others
13:42:19 <dons> simple, predictable tiling
13:42:32 <jcreigh> one thing I was thinking about was maybe having a key that mirrors any arbitrary layout. so mod-space to cycle layous, and mod-shift-space (or whatever?) to toggle mirroring.
13:42:41 <dons> (which corresponds, basically, to my principle of being able to express QC properties about things)
13:42:48 <jcreigh> then any other (user?) layout gets mirroring for free.
13:42:54 <Botje> does xmonad has a floating layer?
13:42:57 <Botje> *have
13:42:59 <Botje> (like wmii)
13:43:01 <sjanssen> Botje: not yet
13:43:06 <Botje> ah.
13:43:12 <Uncountable> does ghc have unicode symbol equivalents for ascii operators?
13:43:35 <dons> for some, yes.
13:43:35 <sorear> some of them
13:43:36 <Uncountable> is there a list of them?
13:43:40 <dons> lambda, forall, arrow. check the ghc 6.6 user's guide
13:43:50 <dons> bbl
13:43:52 <jcreigh> oh, really? You can code Haskell using, for example, the actual lambda glyph?
13:44:14 <sjanssen> lambda is interpreted as a lower case character IIRC
13:44:38 <sorear> yeah, those Greek haskellers need to name variables too ;)
13:46:30 <Uncountable> do you know what it's called? i'm not finding it in the loc
13:46:40 <Uncountable> toc
13:46:46 <nelhage> Doesn't seem to work here
13:46:46 <nelhage> Prelude> :t λ x -> x
13:46:59 <nelhage> <no location info>: not an expression: `λ x -> x'
13:47:09 <nelhage> > λ x -> x
13:47:10 <lb>  Illegal character ''\187''
13:47:37 <Uncountable> nelhage: that looks like \hat I here, so you're maybe using the wrong symbol
13:47:58 <sjanssen> dons, jcreigh: what do you think of David Roundy's suggestions about layout?
13:48:38 <sjanssen> on the one hand, extra flexibility is useful
13:48:40 <monochrom> ghc doesn't have unicode symbol equivalents for ascii operators.
13:49:08 <sjanssen> on the other hand, I don't want to make xmonad too complicated to configure
13:49:21 <nelhage> I'm pretty sure that's a utf-8 encoded lambda.
13:49:31 <nelhage> Which would indeed look like \hat I in iso-8859-1
13:49:42 <sjanssen> nelhage: it's interpreted as a lower case letter
13:49:46 <monochrom> Yes that one was a lambda.
13:49:52 <sjanssen> not as the special \ token
13:49:58 <monochrom> lb isn't utf-8 aware.
13:50:29 <sjanssen> monochrom: but the UTF-8 generally works by accident
13:50:45 <sjanssen> > "λ"
13:50:48 <lb>  "\955"
13:50:51 <nelhage> let λ = 5 in λ doesn't work either
13:50:54 <Uncountable> so do unicode symbols work or not?
13:51:21 <monochrom> > (\ λ -> λ ) True
13:51:22 <fasta> When I use map to create bindings:
13:51:22 <Uncountable> are there special symbols for eg ++, /= or >>=?
13:51:22 <fasta> let [a,b] = map (\f -> f constant_value) [f,g]
13:51:22 <fasta> in some_other_expression_using_a_and_b
13:51:22 <fasta>  
13:51:22 <fasta> Is this as efficient as doing:
13:51:22 <lb>  Illegal character ''\187''
13:51:22 <fasta>   let a = f constant_value
13:51:24 <fasta>       b = g constant_value
13:51:26 <fasta>   in some_other_expression_using_a_and_b
13:51:28 <fasta> ?
13:51:59 <jcreigh> sjanssen: I don't know...what about LayoutDesc { tileFraction :: Rational, layouts :: [Rational -> Rectangle -> [Window] -> [(Window, Rectangle)]] }? The layout we use is the head of the list, rotating layout just rotates that list.
13:52:11 <monochrom> I gather the impression that Uncountable will ask the same question uncountably many times. :)
13:52:22 <sjanssen> Uncountable: no, there aren't symbols for those, but you can define your own
13:53:13 <sjanssen> jcreigh: yeah, that will work a bit better, but do you think it's a good idea?
13:53:18 <fasta> I.e. is the list never actually used in the compiled code?
13:53:47 <Uncountable> well i first got the answer "for some" by two people, and then an opposite answer
13:54:16 <sjanssen> Uncountable: there are Unicode replacements for some special tokens
13:54:28 <Uncountable> such as?
13:54:45 <sjanssen> forall and -> both have Unicode replacements (both of which were mentioned earlier)
13:56:19 <sjanssen> "are there special symbols for eg ++, /= or >>=?": no, there aren't any equivalents for those, but you can define your own.
13:56:20 <fasta> Uncountable: and if you care enough, you can write your own preprocessor
13:56:50 <Uncountable> i don't care that much. i was just interested.
13:57:21 <fasta> AFAIK, the lambdas only work when you use GHC
13:57:24 <Uncountable> here there's a list of a few: http://hackage.haskell.org/trac/haskell-prime/wiki/UnicodeInHaskellSource but i don't know if it's comprehensive or if ghc supports more
13:57:26 <lb> Title: UnicodeInHaskellSource - Haskell Prime - Trac, http://tinyurl.com/yfvxzv
13:57:34 <fasta> So, when you use ghci... bye bye
13:57:37 <jcreigh> sjanssen: I think it would be a (small, at least) improvement over what we have now..."refresh" could stop caring about layout types, and the default config could look like "LayoutDesc { layouts = [ fullScreenLayout, tileLayout, flipLayout tileLayout ], tileFraction = 1%2 }"
13:57:55 <fasta> Anyone with an answer to my question?
14:00:09 <monochrom> fasta: perhaps ask on a mailing list.
14:00:22 <eumenides> hm. haddock chokes on my code with a parse error. it compiles and runs fine though. now what?
14:00:51 <SamB> you have a syntax error in your comments!
14:01:09 <SamB> unfortunately haddock doesn't have very good syntax error reporting...
14:01:13 <monochrom> Marc Weber the Webber.
14:01:43 <eumenides> SamB: but i'm only using -- | :(
14:02:21 <SamB> you probably used a character that haddock holds as sacred!
14:02:30 <monochrom> -- |   at the wrong place is still an error.
14:04:11 <sorear> For instance, Wadler/Leijen is a syntax error.
14:04:23 <sorear> you need to write either\/or!
14:04:40 <jcreigh> sorear: what? Do you mean the string of characters "Wadler/Leijen"?
14:04:56 <sorear> @paste your code, haddock errors are best found by experienced eyes
14:04:56 <lb> Haskell pastebin: http://hpaste.org/new
14:04:59 <Heffalump> sorear: have you seen the chapter by Wadler in "The Fun of Programming" about pretty printing?
14:05:06 <sorear> jcreigh: I mean -- | Wadler / Leijen
14:05:19 <sorear> Heffalump: is that the same as the paper "A Prettier Printer" ?
14:05:24 <jcreigh> sorear: why does haddock choke on that?
14:05:30 <sorear> Heffalump: I haven't read the fun of programming
14:05:40 <sorear> jcreigh: because / is special syntax!
14:05:54 <eumenides> sorear: unfortunately it's 19kb. or does haddock actually report the error positions properly?
14:06:01 <Heffalump> sorear: yes
14:06:39 <Heffalump> (just wondering if you'd make a conscious decision to implement one particular set of combinators over another)
14:07:39 <eumenides> sorear: i guess not since it reports it in the middle of code
14:07:50 <sorear> eumenides: the error positions are pretty good, paste the comment immediately preceding the error line, and a bit of context
14:07:59 <sorear> eumenides: it usually reports right after the error
14:08:17 <sorear> and, curiously enough, right after most comments is code ;)
14:08:48 <sorear> Heffalump: the code on the ML isn't mine, it was originally written by Daan Leijen
14:09:17 <Heffalump> ah, I see.
14:09:32 <hpaste>  eumenides pasted "haddock error" at http://hpaste.org/1408
14:09:53 <Heffalump> Wadler's code in "A Prettier Printer" is here, btw, though I'm not sure of the licensing status: http://web.comlab.ox.ac.uk/oucl/publications/books/fop/
14:09:55 <lb> Title: The Fun of Programming
14:10:08 <eumenides> well, there it is. i'm not sure what to make of it.
14:10:29 <sorear> eumenides: I do :)  this is actually a diff. issue
14:10:35 <sorear>                , MonadReader Ambience <-- line 249
14:10:47 <sorear> you can't derive a multi-token type
14:10:58 <sorear> it is a parse error in your code, not the comment
14:11:15 <sorear> haddock is h98 only
14:11:21 <sorear> you have two choices
14:11:34 <sorear> put the offending code in #ifndef __HADDOCK__
14:11:59 <sorear> or you can use waern's experimental GHC-api-based haddock, which parses everything ghc does (and generally works well)
14:12:03 <sorear> @where haddock.ghc
14:12:04 <lb> I know nothing about haddock.ghc.
14:12:12 <sorear> @googel haddock.ghc
14:12:13 <lb> http://darcs.haskell.org/SoC/haddock.ghc/
14:12:13 <lb> Title: Index of /SoC/haddock.ghc
14:12:17 <sorear> that's it
14:12:27 <eumenides> sorear: cool. thanks. i'll the latter later
14:13:56 <eumenides> sorear: the #ifndef does in {- -} ?
14:14:22 <sorear> no, it's a CPP directive, it goes at the beginning of the line
14:14:25 <sorear> code...
14:14:26 <ohmega-> if i have a list of key/value pairs [(a,b)] and i want to update the value of some key, what's the easiest way to do this?
14:14:29 <sorear> #ifndef __HADDOCK__
14:14:33 <sorear> ghc exts code...
14:14:35 <sorear> #endif
14:14:38 <sorear> more code...
14:14:41 <ohmega-> suppose i have some function f : b -> b
14:15:09 <sorear> ohmega-: you should probably be using Data.Map - there is a update function predefined
14:15:13 <sorear> @docs Data.Map
14:15:14 <lb> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
14:15:34 <sorear> @uptime
14:15:35 <lb> uptime: 6h 51s, longest uptime: 9d 2h 23m 6s
14:15:51 <eumenides> sorear: do i need to enable a flag? i get a lexical error
14:15:55 <jcreigh> does lb have lambdabot's memories?
14:15:57 <sorear> -cpp
14:16:02 <sorear> jcreigh: some of them
14:16:02 <monochrom> No.
14:16:29 <monochrom> Damn. I will never say no again.
14:16:38 <sorear> @karma audreyt
14:16:39 <lb> audreyt has a karma of 41
14:17:01 <eumenides> sorear: great! thanks
14:17:03 <ohmega-> ok thanks
14:21:17 <ohmega-> but i was just prototyping something and lists are fine performancewise, i just wondered whether you had a clever solution :)
14:21:52 <jcreigh> ohmega-: the clever solution is to use the right data structure. :)
14:22:06 <chessguy> monochrom: do you like programming in java more than haskell?
14:22:17 <ohmega-> uh oh ok :)
14:23:16 <dmwit> ohmega-: If you _really_ want to use lists, just use lookup and (:).
14:23:54 <dmwit> I believe lookup stops at the first success, so putting a new entry at the beginning of the list will...
14:24:17 <dmwit> Well, I guess it would probably work, but it would make plenty of bloat. =(
14:24:29 <ohmega-> yes, i have to remove my old element etc and the code looks kind of ugly
14:24:54 <dmwit> ohmega-: Or don't remove it. ;-)
14:25:21 <sorear> deleteBy (comparing fst!
14:25:37 <jcreigh> I didn't think "comparing" was standard.
14:26:09 <sorear> @karma diakopter
14:26:10 <lb> diakopter has a karma of 1
14:26:11 <dmwit> let update f k (a, b) = if k == a then (a, f b) else (a, b) in map (update desiredUpdateFunction desiredUpdateKey) associations
14:26:11 <sjanssen> new in base 2.0 IIRC
14:26:15 <dmwit> How about something like that?
14:27:16 <dmwit> let update f k (a, b) = if k == a then (a, f b) else (a, b) in map (update (+1) 2) [(1, 3), (2, 4), (3, 5)]
14:27:22 <dmwit> > let update f k (a, b) = if k == a then (a, f b) else (a, b) in map (update (+1) 2) [(1, 3), (2, 4), (3, 5)]
14:27:24 <lb>  [(1,3),(2,5),(3,5)]
14:28:58 <nominolo> :t comparing
14:29:02 <lb> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
14:30:41 <chessguy> @quote currying
14:30:42 <lb> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
14:30:47 <chessguy> @quote curry
14:30:48 <lb> VirginiaCurry says: "You know, Haskell actually never liked the name Haskell." -- Virgina Curry (Haskell B. Curry's widow)
14:31:02 <dmwit> ?quote chicken
14:31:02 <lb> No quotes match. You type like i drive.
14:31:45 <nominolo> are the quotes stored somewhere, publically?
14:31:54 <sorear> Yes.
14:32:02 <nominolo> @where quotes
14:32:02 <lb> I know nothing about quotes.
14:32:13 <sorear> http://www.cse.unsw.edu.au/~dons/lambdabot/State/quote
14:32:14 <sorear> iirc
14:32:41 <nominolo> yikes!
14:32:50 <chessguy> you have to download it
14:33:00 <sorear> nominolo: it's dons' fault!
14:33:03 <nominolo> thats a gzipped file with mimetype text
14:33:28 <sorear> nominolo: that's his fault too.
14:33:43 <nominolo> i hate wrong mimetypes -- can easily lead to firefox DoS-attacks :/
14:33:48 <nominolo> sorear: heh
14:34:00 <sorear> nominolo: at least you caught on - the last person to ask for quotes called it binary gibberish
14:34:38 <chessguy> heh. that was probably me
14:34:56 <sorear> ooh, deltabot!
14:35:07 <nominolo> well, to be fair, there's no GZ header
14:35:09 <chessguy> ?
14:35:27 <sorear> it might be raw zlib :(
14:35:44 <sorear> lambdabot binds directly to zlib, it doesn't call gzip
14:36:02 <nominolo> yeah, probably
14:36:39 <Saizan> <Saizan> @run 1323 <deltabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString <-- is there an obvious solution for this problem?
14:37:01 <sorear> yes, copy runplugs into .
14:37:10 <sorear> sh build should have done it for you
14:37:18 <sorear> i wonder why it didn't
14:37:32 <Saizan> it's yet there..
14:38:03 <sorear> parse error
14:39:49 <Saizan> it's probably that the configure script has catched 6.7 instead of 6.6 somewhere..
14:42:12 <sorear> yeah, that would do it.
14:42:17 <sorear> edit 'build'
14:42:25 <sorear> replace all ghc with ghc-6.6
14:43:08 <sorear> add -w /path/to/ghc  to the ./Setup configure line
14:43:14 <sorear> then re-run build
14:43:29 <sorear> that's what I had to do, my GHC is ghc-6.7.20070413
14:43:38 <sorear> but I have /usr/bin/ghc-6.6
14:43:47 * sorear curses C
14:44:11 <sorear> the correct pretty printing of 'int sam = (foo * bar) * baz;' ....
14:44:13 <Saizan> thet's what i've done before building this..
14:44:17 <sorear> depends on the type of foo!
14:44:38 <TomMD> foo :: Foo -- A universal constant fact in examples.
14:46:25 <sorear> there sure are a lot of lambdabots these days.  xerox, saizan, newsham, stepcut, ADEpt, dons, sorear, Cale, chessguy...
14:47:15 * Cale really wishes that Ubuntu would incorporate the Reiser 4 patch into its kernels so that he didn't have to recompile the kernel and all the restricted drivers after every dist upgrade.
14:47:44 * jcreigh is far too lazy to use anything other than ext3
14:48:04 * thoughtpolice wants to know if anybody's tried ext4
14:48:10 <jcreigh> there's an ext4?
14:48:15 <thoughtpolice> yeah it was released
14:48:18 <Saizan> yes
14:48:21 <jcreigh> you can only do backwords compatible extensions for so long...
14:48:26 <dons> re.
14:48:37 <thoughtpolice> http://en.wikipedia.org/wiki/Ext4
14:48:37 <lb> Title: Ext4 - Wikipedia, the free encyclopedia
14:48:41 <Cale> Well, I have a disk that I've been using for a long time which was formatted reiser4, and I don't have enough storage elsewhere to move its contents to do a reformat.
14:48:46 <eumenides> didn't the guy kill his wife?
14:48:51 <thoughtpolice> reiser?
14:48:53 <thoughtpolice> he's on trial
14:49:04 <dons> sjanssen: re. configuration
14:49:10 <jcreigh> eumenides: I do not believe that he has been convicted of that crime.
14:49:30 <dons> i was thinking we'd be able to allow people to provide their own Config.hs with full layout implementatoins and so on, simply by making sure the right things are exported from Operations.hs
14:49:32 <thoughtpolice> his wife is still missing however, but i'm not sure on all the details.
14:49:46 <dons> sjanssen: then people could hack their own layout code into the bottom of Config.hs and call it
14:50:14 <dons> hmm. more mod-shift-c issues eh?
14:50:27 <thoughtpolice> i'm wondering what'll happen to reiserfs as a consequence.
14:50:27 <chessguy> ?src print
14:50:28 <lb> print x = putStrLn (show x)
14:50:56 <chessguy> ?src putStr
14:50:56 <lb> putStr s  = hPutStr stdout s
14:51:11 <morner> so: what do you guys do for profiling, around here?
14:51:19 <dons> ghc -O -prof -auto-all
14:51:25 <dons> then run the compiled rpogram with +RTS -p
14:51:35 <dons> and you get a profiler dump into foo.prof file
14:51:38 <Saizan> someone tried to use the -w flag with cabal-install ? it doesn't get propagated when building dependencies here
14:51:45 <dons> check the ghc user's manual, there's a few other profiling tricks too
14:51:48 <morner> that's convenient
14:52:29 <sorear> Saizan: I'm willing to bet cabal-install will horribly botch lambdabot.   just because there is a .cabal doesn't mean it is intended to be used directly.
14:52:37 <morner> the internet is all about King, Hall and Trinder's strategic profiler
14:52:40 <monstre> Newbie question: why does a tail-recursive function to compute, say, the factorial using an accumulator still seems to blow up the stack?
14:53:05 <sorear> because it isn't really tail recursive
14:53:19 <Saizan> sorear, well i've tried to use build-dep to get haskell-src and arrows but they got installed on 6.7
14:53:41 <sorear> your factorial, after lots of iteraction in constant stack, returns (10 * (9 * (8 * (7 * (6 * ... )))))
14:53:51 <sorear> and then we force that thunk
14:53:59 <sorear> and the forcing isn't tail recursive
14:54:11 <DRMacIver> It seems really odd to me that * and + don't evaluate their arguments eagerly.
14:54:26 <monstre> So how do I calculate the factorial in constant space then?
14:54:28 <sorear> DRMacIver: they do!
14:54:33 <sorear> monstre: foldl'
14:54:47 <sorear> > foldl' (*) 1 [1..10000000]
14:54:50 <DRMacIver> sorear: Then why is the function building up thunks?
14:54:52 <lb> Terminated
14:54:59 <DRMacIver> Oh, because it doesn't evaluate its arguments eagerly.
14:55:01 <DRMacIver> Sigh.
14:55:02 <sorear> DRMacIver: because * is itself delayed.
14:55:14 <DRMacIver> Right. I realised as soon as I asked.
14:55:18 <sorear> > foldl' (*) 1 [1..3000000]
14:55:19 <astrolabe> Am I correct in thinking that I can't let an ordered pair be an instance of a class (except through deriving)?
14:55:23 <lb> Terminated
14:55:23 <monstre> foldl' uses seq to make the accumulator strict, right?
14:55:32 <sorear> > foldl' (*) (1::Int) [1..10000000]
14:55:34 <sorear> yes.
14:55:37 <lb> Terminated
14:55:42 <sorear> > foldl' (*) (1::Int) [1..1000000]
14:55:44 <lb>  0
14:55:58 <sorear> astrolabe: no, you are wrong
14:56:10 <sorear> (,) can instantiate as many classes as you want
14:56:19 <astrolabe> sorear: oh good
14:56:27 <monstre> foldl (+) 0 [1..1000000]
14:56:32 <monstre> > foldl (+) 0 [1..1000000]
14:56:33 <astrolabe> sorear: what is the syntax?
14:56:36 <lb>  Exception: stack overflow
14:56:39 <sorear> you are probably running into the (T a b c) restriction that everyone but me can't understand :/
14:56:40 <sorear> oh.
14:56:43 <monstre> > foldl' (+) 0 [1..1000000]
14:56:46 <lb>  500000500000
14:56:50 <sorear> syntax!  that's easier.
14:57:01 <monstre> alright, thanks for the explanation
14:57:02 <sorear> instance MyClass (a, b) where
14:57:06 <sorear> -OR-
14:57:12 <DRMacIver> What's the (T a b c) restriction that everybody but you can't understand?
14:57:13 <sorear> instance MyClass ((,) a b) where
14:57:32 <sorear> you can't write instance MyClass (Foo Int) where
14:57:56 <sorear> it has to be a constructor (let's call it T) followed by some number of variables
14:58:16 <astrolabe> sorear: Ah, I see what I was misunderstanding.  Thanks.
14:58:22 <DRMacIver> I see.
14:58:24 <Saizan> but you can write instance Integral a => MyClass (Foo a) where, and it seems absurd to me..
14:58:42 <sorear> why?
14:58:49 <monstre> > sum [1..1000000]
14:58:52 <lb>  500000500000
14:59:27 <Saizan> MyClass (Foo Int)  is a weaker declaration, should be more manageable
14:59:35 <jcreigh> aww, nuts, full screen layout can't be written as a function with type Rectange -> [Window] -> [(Window, Rectangle)]
14:59:39 <jcreigh> hmm.
15:00:17 <DRMacIver> Hm?
15:00:48 <tibbe> how can I make some data constructors public to allow for testing but hide them from public use? use an .Interal module?
15:01:16 <tibbe> which my public module imports without reexporting the contructors?
15:01:47 <dmwit> jcreigh: We need a z-component?
15:01:58 <dmwit> This would be useful for float mode eventually, too.
15:02:27 <jcreigh> dmwit: I don't know...right now, full screen looks at which window is focused, so you can't generalize it to something with that simple of a type.
15:02:56 <dmwit> ...ah
15:03:22 <dmwit> Yes, things are even a bit more complicated than what I was thinking about.
15:04:17 <monstre> Shouldn't foldl' actually be in the Prelude rather than plain foldl?
15:04:25 <monstre> Why would you ever prefer the latter?
15:04:37 <dmwit> ?src reverse
15:04:38 <lb> reverse = foldl (flip (:)) []
15:04:43 <jcreigh> maybe layout needs to be StackSet a -> WorkspaceId -> Rectangle -> [(a, Rectangle)]
15:04:45 <dons> for lazy things :-)
15:04:55 <dons> foldl' is a bit unspecfied in fact.
15:04:58 <dons> it could be stricter!
15:05:01 <dons> ?src foldl'
15:05:01 <lb> foldl' f a []     = a
15:05:01 <lb> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:05:14 <monstre> wouldn't you use foldr for lazy things?
15:05:14 <dons> notice its not strict in a in the [] case?
15:05:27 <dmwit> monstre: Not if the function is left-associative...
15:05:35 <sjanssen> dons: sure it is
15:05:43 <sjanssen> a `seq` a is equivalent to a
15:06:02 <dons> you'd write it as something like this now,
15:06:03 <dons> foldl' f !a []     = a
15:06:04 <dons> foldl' f !a (x:xs) = foldl' f (f a x) xs
15:06:29 <dons> sjanssen: we hit this difference when strictness testing our streams code
15:06:43 <monstre> okay, but isn't foldl' a more sensible default still, even though foldl *might* have its uses?
15:06:58 <dons> you can distinguish the two foldl's by handing them an empty list, and some arg only
15:07:00 <sjanssen> monstre: yes, foldl is rarely useful
15:07:11 <dmwit> I think they wanted to preserve the meaning that ' => lazy.
15:07:19 <dmwit> s/lazy/strict
15:07:19 <Cale> ' => strict
15:07:50 <Igloo> dons: Hmm? What do you mean?
15:07:55 <sjanssen> dons: with the usual definition "foldl' f _|_ []" is still _|_
15:07:57 <Cale> Even if it is less commonly used, foldl is the more straightforward left fold.
15:08:39 <dons> let me find the example csae
15:10:43 <sorear> sjanssen: (on a very old topic) instance IsString Doc!
15:12:13 <sjanssen> sorear: that's actually somewhat legitimate
15:12:36 <dons> so strictCheck fails with
15:12:37 <dons>     ** test 2 of Reducing lists (folds) failed (after 231 steps) with the binding(s)
15:12:40 <dons>     **   <function /= _|_>
15:12:42 <dons>     **   _|_
15:12:45 <dons>     **   [_|_]
15:12:51 <dons> when comparing the base's foldl' against ours. implying that the streams one is stricter.
15:12:56 <dons> now, the code is, ..
15:13:03 <dons> base:
15:13:04 <dons> foldl' f a []     = a
15:13:05 <dons> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:14:08 <sjanssen> dons: it looks like the streams code is strict in the elements of the list too?
15:14:13 <dons> versus
15:14:14 <dons> foldl' f z0 xs0 = go z0 xs0
15:14:14 <dons>   where
15:14:14 <dons>     go !z []     = z
15:14:14 <dons>     go !z (x:xs) = go (f z x) xs
15:14:23 <sorear> dons: is that the current streams code, ie will ghc 6.8 become stricter when I add -O?
15:14:26 <eumenides> is ByteString compressed in any way?
15:14:38 <monstre> Are there any documents out there that will explain how to reason about space complexity in a lazy language?
15:14:46 <monstre> Because I'm very confused right now...
15:14:48 <sorear> eumenides: yes, it's packed down to one byte per character
15:14:55 <Igloo> dons: OK, so not the empty list case then
15:14:55 <dons> sorear: hmm? its just this one funcion that is stricter, and we argue that foldl' should be fully strict
15:15:10 <dons> so its the list of one elem, I think.
15:15:15 <dons> containing bottom.
15:15:33 <Igloo> Right, or any other non-zero length, and presumably a function that ignore its arguments
15:15:35 <sorear> wha'ts f in the testcase?
15:15:47 <dons> a non bottom function, probably const
15:16:10 <dons> similar for foldl1'
15:16:18 <dons> recall that foldl' is not h98
15:16:24 <dons> so its not specified anywhere, really.
15:16:27 <sorear> not even in List?
15:16:38 <dons> I think the double bang pattern is the obvious implementation now
15:16:45 <dons> rather than the seq version in List
15:17:04 <dons> sorear: that's an implementation of a strict foldl, not *the* strict foldl ;-)
15:17:25 <sjanssen> dons: the second definition you pasted is the actual definition tested?
15:17:26 <dons> eumenides: bytestrings are compressed if you use the zlib or bzlib packages on them
15:17:33 <dons> yes.
15:17:41 <dons> that's the one we use in fact, since it yields much better code
15:17:51 <eumenides> dons: interesting. thanks
15:17:53 <dons> becaues now any call to foldl' can go via an unboxed worker
15:18:19 <dons> we need strictness properties specified! they're subtle.
15:18:32 <dons> you could write code for foldl1 that depended on the above behaviour. hmm.
15:18:42 <dons> IOHCC anyone ;-)
16:04:14 <dons> sjanssen: i put some preliminary thoughts down for allowing custom hacking in config.hs, for 0.2
16:04:36 <dons> basically, tidy up apis and expose anything necessary, for anything in Operations.hs to be reimplemented in Config.hs
16:09:27 * araujo loves to use haskell as a pseudo code language
16:10:15 <dons> hehe
16:10:41 <chessguy> @bot
16:15:40 <araujo> dons, chessguy hi hi!
16:15:56 <chessguy> araujo: hi and bye
16:16:21 <dons> hey araujo
16:18:52 <lb> :)
16:19:10 <sorear> I'd quote the "damn it!  haskell psuedo code is indistinguishable from real code", but my lambdabot's state isn't recent enough :)
16:19:14 <dmwit> LAAAAAG
16:19:50 <dmwit> ?index isSymbol
16:19:59 <ddarius> araujo: Ever read http://citeseer.ist.psu.edu/hudak94haskell.html
16:20:04 * sorear <3 cox communications
16:20:08 <sorear> NOT!
16:20:43 <lb> bzzt
16:20:44 <lb> Title: Haskell vs. Ada vs. C++ vs. Awk vs. ... An Experiment in Software Prototyping Pr ...
16:20:58 <dmwit> ?index isPunctuation
16:20:58 <lb> bzzt
16:21:11 <sorear> not . isAlphaNum ?
16:21:52 <dmwit> sorear: It's used in Derive, I'd rather not muck about with it.
16:22:07 <dmwit> (Actually, both of those are.)
16:22:16 <sorear> oh, it's local I think
16:22:21 <dmwit> Are filepath and FilePath different somehow?
16:22:25 <sorear> vim /isSymbol
16:22:33 <sorear> emacs C-s isSymbol
16:22:37 <araujo> ddarius: yes, i glanced over that a while ago :-)
16:22:42 <sorear> filepatch is newer iirc
16:22:42 <dmwit> Well, ghc can't find it, so I doubt it will be as simple as /
16:22:44 <araujo> nice stuff
16:22:59 <dmwit> Ah, darn, I installed filepath and it was asking for FilePath.
16:23:03 <dmwit> That's probably the problem.
16:26:53 <sorear> newer versions of derive use filepath
16:27:09 <dmwit> Newer... as in the last 24 hours?
16:27:18 <sorear> more like 2
16:27:34 * dmwit darcs get's
16:27:52 <sorear> hehe.  mutt flag combo of the day:
16:27:58 <sorear> O T
16:28:45 <ddarius> "We provided them with a copy of P1 without explaining that it was a program, and based on preconceptions from their past experience, they had studied P1 under the assumption that it was a mixture of requirements specification and top level design."
16:29:56 <sorear> is that real?
16:30:00 * sorear wants to @google
16:30:14 <jcreigh> sorear: http://www.google.com :P
16:30:15 <lb> Title: Google
16:30:23 <jcreigh> http://mail.python.org/pipermail/python-list/2005-October/344273.html
16:30:24 <lb> Title: "no variable or argument declarations are necessary.", http://tinyurl.com/35rs2b
16:32:12 <araujo> lb == lambdabot?
16:32:29 <jcreigh> non-offcial lambdabot
16:33:01 <dons> yeah. i should fix that now actually.
16:34:53 <Excedrin> what sort of stuff should I look into regarding classifiers that deal with numbers (as in, 0.99 is treated as "similar" to 1) or 2d points or 2d figures (possibly with rotation, scaling, etc)?
16:35:29 <sorear> not quite sure what you mean?  it's advanced cs i think :(
16:35:54 <sorear> araujo: it was called lambdabot-sorear, but xerox asked me to shorten the nick
16:36:22 <dons> i think 'lb' is good, actually
16:36:30 <dons> 'lam' or 'lambda' might also be good
16:37:28 <ddarius> sorear: Is what real?
16:37:31 <Excedrin> sorear: I'm a little familiar with stuff like naive bayes plus some tokenizer for spam filtering; should the same sort of thing be possible with numbers?
16:38:03 <dmwit> Excedrin: Are you trying to recognize pictures of numbers, or what?
16:38:41 <dmwit> (These questions might better be addressed to #ai, too, FYI.)
16:39:07 <Excedrin> no, there's a couple different things that I'd like to try, one is classifying lists of numbers, the other is for lists of 2d points that describe some geometrical figure
16:39:11 <Excedrin> I'll try there, thanks
16:39:46 <dmwit> There's lots of techniques available for that, they'll give you good things to look at.
16:41:41 <araujo> sorear: :-)
16:41:51 <araujo> sorear: you think we can hav it on #haskell.es too? :-)
16:42:19 <dmwit> Which language is es?
16:42:27 <sorear> ddarius: the quote
16:42:29 <sorear> spanish
16:42:33 <sorear> espanol
16:42:46 <dmwit> oh
16:42:49 <dmwit> duh
16:42:52 <dmwit> of course
16:43:54 <ddarius> It's from the paper I linked to above.
16:45:18 <dmwit> Bah:
16:45:29 <dmwit> ./Language/Haskell/TH/Helper.hs:111:26: Not in scope: `isSymbol'
16:45:39 <dmwit> ./Language/Haskell/TH/Helper.hs:111:40: Not in scope: `isPunctuation'
16:46:58 <sorear> @seen ndm
16:46:59 <lb> I saw ndm leaving #haskell 3h 4m 17s ago, and .
16:47:40 <dmwit> How long will lb be around?  (Can I ?ask him about it?)
16:48:25 <sorear> lb will be around until dons recovers from jetlag enough to fix lambdabot.
16:48:28 * araujo throws a lambda at sorear 
16:48:46 <sorear> it will take a nap in ~5 hours
16:50:04 <dmwit> ?ask ndm Where are isSymbol and isPunctuation defined in Derive?
16:50:05 <lb> Consider it noted.
16:50:16 <dons> sorear: ok. i should have it up in the next 30 mins.
16:50:23 <dons> though i need more caffeine
16:51:45 * araujo has lambdabot addiction
16:52:39 <dmwit> !yarr!
16:52:49 <dmwit> ?yarr?
16:52:50 <lb> Ahoy mateys
16:53:23 <monochrom> Oh, right, dons's natural clock is saying "good morning" now. :)
16:53:37 <dons> good morning!
16:55:09 <dons> i note it is 5pm though.
16:55:10 <pirothezero> hey just wondering is there a break/return command in haskell?
16:55:32 <dons> nope. since its not an imperative language :-)
16:55:47 <pirothezero> funny my notepad highlights both words in it
16:55:47 <dons> you write expressions rather than sequential loops and statements, so break/return don't make sense.
16:55:57 <dmwit> Don't worry, it will do the minimum amount of work needed to get the answer.
16:55:58 <pirothezero> ya well I am writing one at the moment
16:56:00 <dons> 'return' is a monad function.
16:56:04 <dons> 'break' is a list function
16:56:09 <pirothezero> and for some reason when I want to move onto to next entry it doesnt want to work based on types
16:56:15 <pirothezero> o
16:56:27 <dons> ?src return
16:56:27 <lb> Source not found. And you call yourself a Rocket Scientist!
16:56:34 <dons> ?src Monad
16:56:34 <lb> class  Monad m  where
16:56:34 <lb>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
16:56:34 <lb>     (>>)        :: forall a b. m a -> m b -> m b
16:56:34 <lb>     return      :: a -> m a
16:56:34 <lb>     fail        :: String -> m a
16:56:39 <dons> ?src break
16:56:39 <lb> break p =  span (not . p)
16:57:53 <pirothezero> http://hpaste.org/1409
16:58:05 <pirothezero> not sure what to do with the otherwise on that
16:58:22 <sorear> pirothezero: justso you know, you could just have left [X] Announce
16:58:22 <pirothezero> I wanted to do top_gopd names but it freaked out on tops
16:58:28 <pirothezero> o
16:58:30 <sorear> <hpaste>  eumenides pasted "haddock error" at http://hpaste.org/1408
16:58:31 <pirothezero> does it appear on here?
16:58:34 <pirothezero> thought it was for the main page
16:58:34 <sorear> yes.
16:58:34 <pirothezero> lol
16:58:42 <pirothezero> cool thanks
16:59:30 <pirothezero> *** Term           : gopd (super_managers name database)
16:59:30 <pirothezero> *** Type           : [Char]
16:59:30 <pirothezero> *** Does not match : Char
16:59:38 <pirothezero> is the error I get forgot to paste it in the bin
16:59:48 <dons> heh hugs.
17:00:14 <pirothezero> lol
17:00:16 <dons> sounds like you're using a String, but something expects a Char
17:00:22 <ddarius> pirothezero: Two notes not related to whatever issue you are having: 1) It's up to you, but camelCase is usual Haskell style and 2) you definitely want to look into higher order list processing functions, e.g. map.
17:00:28 <dons> [Char] does not match Char
17:00:58 <sorear> dons:                                         | otherwise = break   looks fishy!
17:01:22 <ddarius> Example, list_employees = map employee
17:01:22 <dons> urgh
17:01:22 <dons> yeah, looks suspicious.
17:01:22 <dons> you want to return [] perhaps?
17:01:26 <dons> 'break' is a function, remember.
17:01:39 <dons> and listen to ddarius, he is wise beyond his years :-)
17:01:40 <dmwit> So does "gopd snames" -- snames is a String, not a DB, right?
17:02:08 <pirothezero> snames is a list of strings
17:02:16 <dmwit> Yeah, cancel my last sentence.
17:02:56 <sorear> pirothezero: also, when you're less familiar with haskell it's an especially good idea to write type signatures, they help make the errors easier sometimes
17:03:27 <pirothezero> ya I have type for employee, spouse income and managers
17:03:47 <ddarius> Actually, adding top-level type signatures is very good practice no matter what level you are in Haskell.  It massively helps in communicating your intent to the compiler and other programmers.
17:03:49 <pirothezero> pretty much database is a List of records and a record is a tuple in the form (string, string, income, string)
17:04:01 <araujo> programming in haskell is thinking in terms of signatures
17:04:20 <sorear> I'm talking inner type signatures.
17:04:27 <sorear> what is the type of gopd?
17:04:28 <fuzan> hwo the hell do you get lambdabot to join channels? heh
17:04:34 <dmwit> gopd uses a variable from top_gopd. =(
17:04:37 <sorear> @help join
17:04:37 <lb> join <channel>
17:04:43 <fuzan> i've tried.
17:04:45 <araujo> fuzan: you need to throw lambdas at sorear
17:04:46 <sorear> dmwit: so?
17:04:50 <fuzan> i think it's erroring connecting to freenode
17:05:00 <fuzan> ......sending message to bogus server
17:05:01 <sorear> dmwit: it's not monomorphic...
17:05:12 <pirothezero> gopd is a list of strings
17:05:15 <dmwit> sorear: Syntactically correct, but I'm fragile and easily confused.
17:05:16 <ddarius> Once you start abstracting things to ridiculous degrees, your type signatures practically determine your code.
17:05:50 <sorear> fuzan: what command are you typing at what prompt? it sounds like you are missing a server tag
17:06:24 <sorear> fuzan: also, you need to set the nickname (lambdabot in first line of online.rc) to something unique :)
17:06:30 <pirothezero> like if in otherwise I put [] it works and I get back what I want just the list of strings has "carol","","",""eric",""
17:06:46 <pirothezero> and I dont really want to go through that list and take out the ""
17:06:55 <pirothezero> its gacky =/
17:07:00 <fuzan> ah :) let me play more.
17:07:30 <sorear> pirothezero: oh, you should be using a concatMap-like pattern
17:07:58 <pirothezero> so ++ ?
17:08:07 <pirothezero> or do you mean ++ with Map on something?
17:08:08 <sorear> yeah
17:08:09 <sorear> ++
17:08:32 <sorear> hold on 30s, I'll write it...
17:09:14 <hpaste>  sorear annotated "pirothezero" with "using ++" at http://hpaste.org/1409#a1
17:09:17 <pirothezero> this is a module in one of my classes and I like the idea behind functional, just takes some time to get your mind working in that way
17:09:51 <sorear> if you like first order haskell you'll love what we can do with higher order abstraction
17:10:15 <dmwit> pirothezero: DB is a list?
17:10:19 <dmwit> If so, you should consider:
17:10:20 <sorear> you are reminded of the diff boxes, if you want to know what I changed
17:10:35 <dmwit> 1. Writing a function from an element of the list to a Bool, telling whether that element is grossly overpaid.
17:10:38 <dmwit> 2. Using filter
17:10:57 <pirothezero> DB is a list of records
17:11:04 <dmwit> :t filter
17:11:07 <lb> forall a. (a -> Bool) -> [a] -> [a]
17:11:13 * ddarius <3 banjos.
17:11:20 <ddarius> @spell banjos
17:11:20 <lb> banjos
17:11:35 <pirothezero> database2 = [("Carol", "Eric", 200000, "Bob"), ("Fran", "Dan", 200000, "Eric")]
17:11:37 <pirothezero> like that
17:11:51 <dmwit> Yeah, you should definitely consider my two-step plan above.
17:11:57 <pirothezero> ya we were looking at using filter
17:12:01 <dmwit> As ddarius said, you should also look at map.
17:12:11 <dmwit> It expresses your intent for list_employees much more succinctly.
17:12:28 <dmwit> list_employees db = map employee db
17:13:25 <malsyned> Can anybody remind me what the pragma is to put ghc command line options into a source file?
17:13:31 <pirothezero> well employee atm is employee :: Record -> String
17:13:32 <ddarius> @spell banjoes
17:13:33 <lb> banjo es banjo-es banjos banjo's bankers
17:13:36 <pirothezero> would that matter?
17:13:37 <dmwit> A similar trick can be used on your emp_to_income function. ;-)
17:13:54 <dmwit> pirothezero: That's exactly what it should be.
17:14:09 <hpaste>  sorear annotated "pirothezero" with "first introduction of filter and map" at http://hpaste.org/1409#a2
17:14:29 <pirothezero> ah cool
17:14:29 <sorear> malsyned: {-# OPTIONS_GHC -ffoo-bar #-}
17:15:01 <malsyned> sorear: thanks!
17:15:24 <malsyned> it's the little stuff you forget when you take a break from a language.
17:16:31 <dons> jcreigh: did you have a look at a configure script for X11-extras?
17:16:46 <dons> I think that is the best way forward for xinerama conditional support
17:17:00 <jcreigh> dons: darcs pull
17:17:14 <jcreigh> I did that yesterday. :)
17:17:32 <fuzan> what exactly does "you need to copy lambdabot.cabal.plugins to lambdabot.cabal" in teh lambdabot intsall mean? I'm not sure what or to where i'm copying. I blame my ignorance.
17:17:42 <fuzan> I'd like to enable evaluation.
17:17:45 <jcreigh> dons: sjanssen said that you had to explictly set some include paths to build on OpenBSD...let me know if autoconf magic fixes that.
17:18:10 <dons> ah ok. interesting. i'll see.
17:19:03 <dons> jcreigh: oh, we need to now autoreconf before running ./Setu.hs ?
17:19:08 <fuzan> i think I figured it out.
17:19:12 <jcreigh> autoconf && autoheader
17:19:12 <sorear> fuzan: Stop.  lambdabot.cabal.plugins is guaranteed to not work
17:19:24 <jcreigh> (and have autoconf installed, of course)
17:19:30 <fuzan> sorear: just after I copied over :\
17:19:31 <sorear> fuzan: that is if you want a fully dynamic bot, which hasn't worked in YEARS
17:19:33 <dons> jcreigh: ok. can you adjust the README to mention this?
17:19:39 <dons> sorear: heh. years eh?
17:19:40 <sorear> @dynamic-load foo.o
17:19:41 <lb> Unknown command, try @list
17:19:44 <jcreigh> dons: look at the README. :)
17:19:54 <fuzan> I just want simple evaluation :)
17:19:57 <fuzan> >1+2
17:19:58 <sorear> memory issues :)
17:20:10 <sorear> fuzan: the static bot can do that just fine.
17:20:17 <sorear> fuzan: darcs revert -a lambdabot.cabal
17:20:26 <dons> sorear: 06.06.07:18:18:01 <dons> @dynamic-reload instances
17:20:37 <dons> that's not even 1 year ago!!
17:20:42 * dons accuses sorear of FUD
17:20:44 <sorear> ooh, more recent than I thought
17:20:52 * sorear hides
17:21:32 <sorear> fuzan's the second this year who has tried to use the .plugins file.  we need better docs.  (or it working)
17:21:50 <dons> yeah
17:24:25 <dons> is autconf;autoheader just autoreconf ?
17:24:46 <dons> seems to work, anyway
17:24:47 <jcreigh> dons: I don't know; is it?
17:25:15 <sorear> aiui autoreconf is recursive autoconf
17:25:16 <jcreigh> autoheader seemed to be required to build include/config.h.in
17:25:37 <dons> oh? to create it?
17:25:41 <pirothezero> hmm alright i am going to come back later ill keep an eye out for you guys that helped ;) ill go over that annoted sample and understand it
17:25:42 <pirothezero> thanks
17:25:54 <dons> sorear: it does some other things too
17:25:58 <sorear> ah, I found the docsj
17:26:08 <jcreigh> dons: yes. include/config.h.in is autogenerated. (but note that X11-extras.buildinfo.in is handwritten)
17:26:08 <sorear> `autoreconf' runs `autoconf', `autoheader', `aclocal', `automake', `libtoolize', and `autopoint' (when appropriate) repeatedly to update the GNU Build System in the specified directories and their subdirectories (see Subdirectories).  By default, it only remakes those files that are older than their sources.
17:26:21 <dons> there we go.
17:26:26 <jcreigh> ah, okay.
17:26:27 <dons> autoreconf does the header gen too
17:26:40 <dons> but no need to specify that, since people might not have automke et al
17:26:42 <jcreigh> cool. I'll update the README to reflect the cooler way to do it.
17:26:52 <dons> ok. so it didn't find my xinerama headers.
17:26:58 * dons tries tweaking CPP_*
17:28:48 <hpaste>  dmwit annotated "pirothezero" with "more map/filter goodness" at http://hpaste.org/1409#a3
17:30:47 <igli> man that hpaste is lovely
17:30:51 <dons> jcreigh: ok cool. just setting CPPFLAGs was enough.
17:30:58 <dons> igli: hehe. :-) yeah, its pretty
17:31:11 <jcreigh> dons: What did you have to change them to?
17:31:14 <igli> yeah i love it. well impressed :D
17:31:36 <dons> its around 500 lines of haskell running on top of HAppS, btw.
17:31:48 <dons> jcreigh:  export CPPFLAGS="-I/usr/X11R6/include"
17:32:15 * sorear wonders what would happen to Cabal if autotools suddenly started grokking Haskell
17:33:50 <jcreigh> dons: hmm. I'd hoped that would all happen magically.
17:34:37 <jcreigh> dons: if you run ./configure without setting CPPFLAGS, what does the X11-extras.buildinfo file it generate look like?
17:35:24 <dons> let me do that.
17:35:56 <dmwit> Whoa, lambdabot is a big download. =P
17:36:59 <dons> jcreigh: hmm,
17:37:49 <dons> $ cat X11-extras.buildinfo
17:37:49 <dons> cc-options:  -I/usr/X11R6/include
17:37:49 <dons> ld-options:  -L/usr/X11R6/lib
17:38:12 <jcreigh> cool. So autoconf's X11 finder is working, I just need to somehow hook it up to my check.
17:38:17 <dons> with the CPP, we also get:
17:38:17 <dons> extra-libraries: Xinerama
17:38:20 <dons> that's the missing bit
17:41:59 <igli> dons: i wish i knew what HAppS was, sorry only ever done a bit of ML, so just lurking atm ;)
17:42:21 <hpaste>  dmwit pasted "error building ByteString" at http://hpaste.org/1410
17:42:54 <dons> igli: its a web framework for haskell
17:42:54 <sorear> > nubBy(((<1).).gcd)[2..] -- obfuscated one liner of the day!
17:42:56 <lb>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
17:43:15 <sorear> erm,
17:43:17 <dmwit> heh
17:43:18 <igli> ah
17:43:22 <sorear> > nubBy(((>1).).gcd)[2..] -- obfuscated correct one liner of the day!
17:43:24 <lb>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
17:43:26 <dons> dmwit: is that with ghc 6.4.x ?
17:43:38 <dmwit> dons: 6.4.1
17:43:50 <sorear> @seen glguy
17:43:50 <lb> glguy is in #haskell. I last heard glguy speak 6h 14m 54s ago.
17:43:52 <sorear> @where fps
17:43:53 <lb> http://www.cse.unsw.edu.au/~dons/fps.html
17:43:53 <dons> ok, either update to ghc 6.6, or install the fps package.
17:43:59 <dmwit> Oh, okay.
17:44:03 <dmwit> Will that work for lb?
17:44:30 <dons> hmm used to. but untested recently.
17:44:33 <dons> i'd install 6.6
17:44:50 <sorear> and do install a binary
17:45:41 <sorear> 6.6 sources supposedly take forever to compile
17:46:01 <dons> well ,about the same as 6.4.2
17:46:11 <dons> but faster, since there's less core libs
17:46:21 * dons accuses sorear of more FUD! shock!
17:46:29 <dmwit> Ubuntu Dapper doesn't have a binary for 6.6. =(
17:47:04 <dons> dmwit: just grab it from hackage
17:47:07 <dons> ?hackage binary
17:47:07 <lb> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
17:47:52 <dmwit> No, I mean there isn't a ghc 6.6 binary in Ubuntu Dapper's repos.
17:48:05 <sorear> binary as in not source
17:48:08 <dons> oh. you could possibly just use a generic linux 6.6 binary
17:48:09 <dmwit> right
17:48:12 <dons> that's what I always use.
17:49:09 <sorear> the generic linux binary works well on openbsd?
17:49:47 * sorear is familiar with the concept of ABI emulation, but would have expected a discouraging amount of pain to be involved
17:49:50 <dons> heh. that's not quite what I meant. it does work though.
17:50:18 <ddarius> sorear: That's like the obfuscated one-liner of the quarter.  But it isn't actually all that obfuscated.
17:50:21 <dons> which makes me wonder why linux can't emulate openbsd..
17:50:39 <kilimanjaro> Does anybody know of a purely functional typed language for fault tolerant distributed or grid computing (not erlang)? I know some work was done on Haskell and distributed computing in the late 90s.
17:50:40 <dmwit> I think I'll stick with 6.4 for now, upgrading looks like it will be a serious pain.
17:50:44 <jcreigh> dons: I'm sure it could be done. but I don't think anybody cares enough.
17:50:51 <sorear> dons: because nobody writes closed source evil sw for openbsd ;)
17:51:08 <dons> *exactly*
17:51:10 <sorear> why emulate openbsd when you can make
17:51:53 <sorear> kilimanjaro: you might want to look at the DPH project
17:51:58 <dmwit> ?hackage arrows
17:51:59 <lb> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/arrows
17:52:00 <sorear> @google data parallel haskell
17:52:02 <lb> http://www.cse.unsw.edu.au/~chak/project/dph/
17:52:02 <lb> Title: Manuel M T Chakravarty - Data Parallel Haskell
17:52:16 <sorear> chakravarty is on unsw!?
17:52:23 <dons> yeah...
17:52:28 * sorear was sure he was one of the MSR folks
17:52:29 <dons> he's my supervisor.
17:52:33 <jcreigh> dons: try adding
17:52:34 <jcreigh> LDFLAGS="$LDFLAGS $X_LDFLAGS $X_LIBS $X_EXTRA_LIBS"
17:52:35 <jcreigh> CFLAGS="$CFLAGS $X_CFLAGS"
17:52:35 <ddarius> "managing them ziplessly"?
17:53:00 <jcreigh> ...below AC_PATH_XTRA, then re-autoconf
17:53:03 <kilimanjaro> sorear, thanks
17:53:10 <dmwit> ARGH
17:53:24 <dmwit> ?hackage base
17:53:24 <lb> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/base
17:53:29 <sorear> dmwit: upgrading isn't THAT painful
17:53:41 <dmwit> But... all my precious packages!
17:53:47 <sorear> dmwit: download the binary tarball, unpack, make install, reinstall your libs
17:53:53 <dmwit> I won't be able to get them through apt-get this time... =(
17:54:12 <sorear> they'll still work with 6.4
17:54:16 <kilimanjaro> Data Paralle Haskell isn't really for distributed computing though. I'd like to be able to have a single server running processes on several heterogeneous systems such that I can have full uptime (the performance boost would be helpful too, but I can get that by just buying more expensive computers)
17:54:17 <Igloo> You don't want to get base from hackage - ghc includes it
17:54:18 <dons> jcreigh: ok. trying
17:54:35 <dmwit> Igloo: "cannot satisfy dependency base >= 2.0"
17:54:40 <dons> kilimanjaro: right. its for multicore/cluster based array programming
17:54:51 <dons> where you just add more nodes for faster programs. so more like map/reduce
17:54:54 <dmwit> (For the arrows package, required by lambdabot.)=
17:54:55 <sorear> dmwit: ghc is really really good at coexisting with other versions of itself...
17:55:09 <sorear> dmwit: don't use arrows from hackage
17:55:09 <Igloo> Ah. Well installing base 2.0 with ghc 6.4 isn't going to be trivial either
17:55:20 <sorear> dmwit: ghc 6.6 comes with arrows
17:55:41 <dmwit> ^@$#%*@!
17:55:50 * dmwit is old-fashioned and doesn't like change
17:55:51 <Igloo> Only in extralibs
17:55:57 <kilimanjaro> dons, ohh ok, I just misunderstood it from a brief scan of the webpage. Thanks :)
17:56:51 <dons> jcreigh: closer
17:56:51 <dons> checking X11/extensions/Xinerama.h usability... yes
17:56:52 <dons> checking X11/extensions/Xinerama.h presence... no
17:56:52 <dons> configure: WARNING: X11/extensions/Xinerama.h: accepted by the compiler, rejected by the preprocessor!
17:56:55 <dons> configure: WARNING: X11/extensions/Xinerama.h: proceeding with the compiler's result
17:56:59 <jcreigh> hmm.
17:57:04 <dons> cc-options:  -I/usr/X11R6/include
17:57:05 <dons> ld-options:  -L/usr/X11R6/lib
17:57:05 <dons> extra-libraries: Xinerama
17:57:07 <dons> looks right.
17:57:20 <dons> but one of the flags didn't get to cpp, I guess?
17:57:29 <jcreigh> okay, it'll probably compile fine then, but the scary warning indicates I don't have it quite right.
17:57:54 <dons> right. it did compile
18:03:06 <sorear> I've found a bug in my language processor with possible obfuscated language applications - mode-change directives that scope over everything textually *preceding* the directive.
18:16:29 <sorear> jyp++
18:25:16 * swig brings the ruccas
18:28:20 <jcreigh> weird.
18:33:44 <dmead> any thoughts on when case statements are better than writting out the function name a bunch of times?
18:34:07 <jcreigh> in an expression? :)
18:34:09 <dons> yeah, i use them for lookup tables
18:34:22 <dmead> i mean for top level pattern matching
18:34:34 <dmead> lookup tables?
18:35:31 <dons> dmead: yeah, association lists as function.
18:36:02 <jcreigh> if test -n "$x_includes"; then CPPFLAGS="$CPPFLAGS -I $x_includes"
18:36:02 <jcreigh> fi
18:36:20 <jcreigh> dons: ^^^ try that instead of the lines setting CFLAGS and LDFLAGS...
18:36:35 <jcreigh> irssi messed up my formating...or vim on copy...
18:36:48 <dons> ok.
18:37:55 <dons> jcreigh: ok. good!
18:37:55 <dons> checking X11/extensions/Xinerama.h presence... yes
18:37:56 <dons> checking for X11/extensions/Xinerama.h... yes
18:38:01 <dons> checking for X11/extensions/Xinerama.h... yes
18:38:10 <jcreigh> sweet.
18:38:12 <dons> and no need to tweak any CPPFLAgs.
18:38:40 <jcreigh> okay, I'll send that patch then.
18:40:18 <dons> sjanssen: we'll have to sort out this mod-shift-c / killclient issue before 0.1
18:40:28 <dons> jcreigh: btw, can you reproduce the kill client issue with xclock?
18:40:53 <jaredj> ah yes -
18:40:53 <jcreigh> lemme check
18:40:53 <jaredj> :d
18:40:53 <jaredj> @xmonad
18:40:58 <lb> Unknown command, try @list
18:41:17 <jaredj> @google xmonad
18:41:24 <lb> http://www.xmonad.org/
18:41:24 <lb> Title: xmonad : a lightweight X11 window manager.
18:41:44 <dons> we at the xmonad organisations only have your best interests in mind.
18:42:02 <sorear> jaredj: lb shares a really low reliability net connection with sorear, don't expect it to answer anything quickly
18:42:03 <jcreigh> hmm, I *can* kill xclock with mod-shift-c
18:42:26 <jaredj> sorear: fair enough
18:42:32 <dons> oh interesting, jcreigh
18:43:06 <jcreigh> "interesting"? Frustrating as heck. :)
18:43:48 <jcreigh> usually, the code I write runs on a server that I can control...all this "fails on my system, but not on wet thursdays" stuff is new to me.
18:44:03 <jaredj> heh
18:44:12 <dons> x11 is complex, and we're using multiple versions on multiple systems, with different configurations
18:44:39 <ddarius> Sounds like fun.
18:44:58 <jaredj> :P
18:45:05 * jaredj gets a drink
18:46:34 <jcreigh> autoconf patch sent. now autoconf might actually do us some good.
18:46:58 <jaredj> i'm so spoiled on gnome at home
18:47:27 <sorear> X is for wimps ;)
18:47:40 <jaredj> i hack too much at work, and there's no ... oomph left to, say, try to run plan9 at home
18:48:02 * stepcut is holding out for coyotos ;)
18:48:20 <jaredj> the best i can do is run debian instead of ubuntu. take that, ubuntu!
18:48:20 <igli> plan 9 man, that is sweet
18:48:25 <jaredj> would be
18:48:27 <jaredj> if i ran it
18:48:41 <jaredj> but no youtube
18:48:43 <igli> gentoo is cool imo
18:49:00 <jcreigh> dons, sjanssen: to reproduce the xclock thing, are you running xclock with any special arguments?
18:49:26 <dons> nope.
18:49:34 <sorear> jaredj: I don't use ANY graphical environment!
18:49:44 * jaredj boggles
18:49:48 <jaredj> how do you watch youtube
18:49:52 <dons> sorear: don't you miss nice antialiased fonts?
18:50:01 <jcreigh> jaredj: ASCII art output lib. :)
18:50:08 <jaredj> jcreigh: lol
18:50:09 <dons> i just use X as a console with antialiased fonts, anyway
18:50:15 <jaredj> ^^^
18:50:19 <jaredj> (at work)
18:50:22 <jaredj> (+ firefox)
18:50:22 <sorear> dons: my dirty glasses antialias the fonts for me
18:50:33 <dons> heh
18:50:35 <jaredj> CRTs are good for that too
18:50:41 <jcreigh> seriously, I could probably run on the console, were it not for multihead and firefox.
18:50:41 <dmead> sorear: you should install kde...
18:50:42 <dmead> :P
18:50:57 * jaredj bows at the altar of firefox
18:51:03 <dmead> eh
18:51:08 <dmead> ff is getting bad lately
18:51:17 <dons> yeh, reddit is pretty impossible without firefox.
18:51:22 <dons> same with google's SoC app
18:51:27 <dmead> they just keep cramming more shit into the same loop
18:51:33 <dmead> and refuse to learn to program in threads
18:51:37 <jaredj> haha
18:51:44 <dmead> seriously...
18:51:46 <dmead> use konq
18:51:51 * stepcut uses konq
18:51:55 <dmead> good!
18:52:00 <jcreigh> Firefox is like some violent god...you have to keep sacrificing RAM to it...
18:52:01 * sorear uses elinks
18:52:07 <jaredj> jcreigh: lmao
18:52:16 <jaredj> baaa!
18:52:16 <dmead> the 1.5 branch was fast
18:52:17 <dmead> after that
18:52:18 <sorear> elinks is ... way too fat
18:52:23 <dmead> i don't know what happened...
18:52:26 <dmead> lol
18:52:27 <jcreigh> yeah. I run 1.5
18:52:31 <jaredj> ^^
18:52:39 <jaredj> but no svg
18:52:45 <dmead> yea, try going into the mozilla irc server
18:52:47 <dmead> in #firefox
18:52:55 <dmead> and ask the devs why ff is so slow and laggy
18:52:58 <jaredj> O.o
18:53:01 <stepcut> but, unfortunately, I think konqueror uses an O(n*n) algorithm for openning the bookmarks menu :(
18:53:02 <dmead> and t hey'll insult your intelligence
18:53:31 <monochrom> I don't find firefox using much memory.
18:53:31 <jaredj> heck you can say _anything_ in #lisp and get that :)
18:53:54 <dmead> "why is it laggy, it runs fine on my pentium 3.06ghz dual core"
18:54:05 <dmead> is seriously the response i got
18:54:21 <dylan> firefox 2 is laggy on my dual core 2ghz amd machine...
18:54:37 <monochrom> My response would be "512MB PC133 memory, 1GHz celeron, laptop".
18:54:38 <sorear> I've uninstalled firefox completely.
18:54:55 <jaredj> sorear: it wouldn't be much use with no X
18:55:02 <sorear> When I want to know how something looks with proportional fonts, I past a link on #haskell.
18:55:03 <dylan> I try to use w3m, but I like to read web comics. :(
18:55:20 <dmead> jaredj: you can use a framebuffer or something
18:55:22 <jaredj> dylan: w3m + xterm + debian = image glory!
18:55:25 <sorear> I use elinks, on the console, AND read web comics.
18:55:26 <dmead> without X
18:55:29 <dylan> jaredj: or urxvt
18:55:38 <sorear> dylan: apt-get install fbi
18:55:41 <dylan> jaredj: except for rendering errors and bug.
18:55:45 <dylan> *bugs
18:55:49 <jaredj> meh
18:55:58 <dmead> apparently you can watch movies with console frambuffers
18:55:59 <sorear> dylan: or zgv, if you're not using fbcon
18:56:02 <dmead> but i haven't tried
18:56:03 <monochrom> I have such an underpowered laptop, I find that all you people with better computers and still complaining about bloatware (same bloatware I use) unbelievable.  The bloatware works so efficiently for me.
18:56:07 <jcreigh> sorear: comics *other* than killnine? :)
18:56:12 <dmwit> dmead: With what, mplayer?
18:56:18 <dylan> sorear: I run X because I need vertical split
18:56:19 <dmead> dmwit yep
18:56:21 <sorear> jcreigh: I can view images!
18:56:46 <sorear> split is overrated.
18:56:56 <jaredj> screen
18:56:57 <sorear> everything I want can be accomplished with vcs.
18:57:02 <dmead> sorear: what do you use for music?
18:57:04 <jcreigh> jaredj: "vertical split"
18:57:08 <dylan> my load avg is 0 right now, though. firefox is mostly swaped out and idle.
18:57:12 <sorear> dmead: what's that? ;)
18:57:15 <jaredj> jcreigh: oh right
18:57:22 <dmwit> dmead: mpd doesn't need X
18:57:23 <dmead> :P
18:57:23 <jaredj> um, ratpoison :)
18:57:32 <dylan> jaredj: no, dwm. :)
18:57:38 <dylan> and eventually xmonad.
18:57:46 <jaredj> i hope
18:57:55 <jaredj> i tried wmii, it seemed like it would be cool
18:57:56 <dylan> once it's more mature and I hack tags onto it
18:58:13 <jaredj> the fs bit was cool. dwm was too. but i kept going back to ratpoison
18:58:21 <jaredj> tags, w00t
18:58:33 <dmead> whats ratpoison again?
18:58:42 <jaredj> dmead: like screen, but a window manager
18:58:43 <dmwit> dmead: Full-screen windows only.
18:58:44 <jcreigh> dmead: GNU screen applied to WM.
18:58:52 <dmead> ah
18:58:55 <jaredj> it splits both ways, fwiw :)
18:59:00 <jcreigh> dmead: no, ratpoison does splits.
18:59:10 <dmead> ^^
18:59:11 <jaredj> much better multihead than wmii or dwm, i'm afraid
18:59:11 <jcreigh> err, meant that for dmwit
18:59:18 <dmwit> o
18:59:23 <jcreigh> jaredj: that's why I added Xinerama support to xmonad.
18:59:27 <jaredj> !!
18:59:36 * jaredj hugs jcreigh
18:59:44 <dmead> someone needs to make xmonad standards compliant
18:59:46 <dmead> so we can try it out
18:59:48 <dylan> I like traditional nn-xinerama for one reason:
18:59:54 <dmwit> jaredj: Incidentally, that is also why you won't being seeing tags in xmonad. =P
18:59:57 <dylan> at work, gaim cannot interrupt my codig.
18:59:58 <jaredj> someone needs to make red hat haskell compliant
19:00:01 <dylan> *coding.
19:00:02 <jcreigh> dmead: "standards compliant"? ICCCM?
19:00:02 <jaredj> dmwit: wha?
19:00:07 <dmead> jcreigh yes
19:00:33 <dmwit> jaredj: Allowing windows to be on multiple workspaces doesn't play well with the possibility of multiple visible workspaces.
19:00:40 <dons> i don't see why we can't be a  proper ICCCM wm, 'cept that the ICCCM standard is so huge
19:00:43 <dmwit> There are other objections, too, but the idea is the same.
19:00:54 <dons> note that david r hacked up a tagging mode yesterday
19:00:57 <dons> sorry, tabs.
19:01:00 <jaredj> hmm, that is hard
19:01:12 <dmead> well
19:01:16 <dmead> it's really just a few key things
19:01:19 <dylan> dons: I think your brain stores words like mine does!
19:01:20 <dmead> like playing nice with other wm
19:01:21 <jcreigh> also, xmonad has layout settings per workspace, which doesn't play nice with tags either.
19:01:22 <dmead> etc
19:01:32 <dylan> dons: I earlier typed "simple" instead of "symbol"...
19:01:59 <dmead> dylan: i'm pretty sure thats a muscle memory thing too
19:02:02 <jaredj> jcreigh: i almost hacked up a wmii script that would start two wmiiwm's and when i sent a tag command would send it to both of them, so windows on each screen matching the tag would show on their respective screens
19:02:02 <monochrom> lambda is simple!
19:02:29 <dons> dylan: oh, what was the quote?
19:02:31 <jaredj> (i actually use multiple-screen multihead atm, not xinerama)
19:02:41 <dons> yeah, i do have a bunch of haskell keywords and functions in my spine
19:02:51 <jaredj> :d
19:02:52 <jcreigh> jaredj: I've never tried that...what's the limitations? Can't move windows from one screen to another, right?
19:03:16 <jaredj> jcreigh: yeh :( tuomov thinks it oughtn't to be too hard, but atm you can't
19:03:18 <dons> yeah, i'm not sure about the multiple tagging thing either, as a productiivty issue
19:03:23 <dons> it just seems too complex...
19:03:39 <dons> though if someone hacks it up as an external Config.hs, i won't complain :-)
19:04:00 <dylan> dons: about a vim snippet: "(comments ten lines (if # is a comment simple in your programming language))"
19:04:18 <jcreigh> jaredj: oh, are you running ion?
19:04:29 <jaredj> was once, but ratpoison won out
19:04:50 <dons> bloatware!
19:04:53 <dons> mwhahaha
19:04:56 <jaredj> *shrug*
19:05:01 * dons does evil wm dev laugh
19:05:02 <jaredj> it has cool keybinding
19:05:19 * jcreigh doesn't buy into LOC wars...
19:05:20 <dons> keybindings *are* cool, that's true.
19:05:23 <dylan> does xmonad have a bottom bar yet?
19:05:27 <jaredj> it's easy to say, "i'm gonna type Ctrl-T. pay attention to these things. then if i say [, pay attention to these"
19:05:46 <jaredj> and the config is much simpler than ion2 or 3
19:05:47 <dons> dylan: nope. its a 0.2 goal, external statusbar
19:05:55 <dons> based on dmeu, or a reimplementation.
19:05:56 <johnnowak> jcreigh: "so what if it depends on 45MB of libraries, it's 500LOC!"
19:06:02 <jaredj> hahahaah
19:06:05 <jaredj> yep
19:06:05 <dons> hah
19:06:05 <dylan> dons: I mean a list of tags, a mode indicator, and the title of a window.
19:06:23 <jaredj> and the time and the load!
19:06:24 <dmwit> dylan: So did he. ;-)
19:06:29 <dons> every X program depends on 45M of libraries :-)
19:06:30 <dylan> dmwit: ah.
19:06:40 <jaredj> and the temperature in, uh, on K2!
19:06:49 <dcoutts> dons: not if it uses xcb! :-)
19:06:55 <dons> yeah, xcb forever.
19:06:57 <dcoutts> xhb rather
19:07:02 <jaredj> boo xhb
19:07:06 <dons> sjanssen: how's the binding going? ;-)
19:07:10 <jaredj> *google*
19:07:10 <monochrom> Every program running on Intel depends on 45M of libraries compiled to transistors.
19:07:12 <dcoutts> X C Binding -> X Haskell Binding
19:07:20 <jaredj> ah
19:07:32 <jaredj> XHB: Summary for SPDR HOMEBUILDERS ET - Yahoo! Finance
19:07:41 <stepcut> I heard someone suggest than xcb was generated from an xml spec, and than perhaps xhb could also be ?
19:07:48 <dons> right.
19:07:57 <dons> that's the plan, to generate most of it for c2hs, I think.
19:08:17 <dons> sjanssen's sponsored to do the binding for SoC by PSU.
19:08:17 <stepcut> so, would the xhb binding still depend on xcb ?
19:08:24 <dcoutts> stepcut: the marshaling/serialisation of the X commands is indeed generated, the connection layer is hand written
19:08:24 <dons> xhsb, I should say.
19:08:25 <ddarius> dons: lambdabot?
19:08:39 <dons> oh, you want me to reboot it eh?
19:08:47 <dcoutts> stepcut: it depends, it could be done either way
19:09:00 <ddarius> I'm just wondering about it.  You said something about, "in 30 minutes" quite a while ago.
19:09:15 <dons> oh. got distracted.
19:09:19 <jaredj> lb != lambdabot?
19:09:24 <dons> and remote system admin sucks
19:09:30 <dcoutts> stepcut: but I think it is probably better to go via xcb since that allows you to share connections with other libs in the same process, eg cairo
19:09:46 <jaredj> there's some bloat, eh
19:09:53 <dcoutts> if you don't share the connection buffers etc you'd have to use multiple connections
19:09:53 <stepcut> dcoutts: ah, that does sound useful :)
19:10:16 <dcoutts> stepcut: yeah, you could make some really nice things with just xhsb and cairo
19:10:34 <stepcut> are there advantages to *not* binding to xcb, and going direct ?
19:10:42 <dcoutts> fewer deps on C libs
19:11:15 <dcoutts> but xcb is going to be widely deployed in future and it's only 80k vs ~1Mb for xlib
19:11:20 <jaredj> !
19:11:35 <dcoutts> stepcut: current xorg's xlib actually uses xcb underneath
19:11:44 <stepcut> yeah, it sounds like binding to xcb is a lot better than going direct
19:11:58 <dcoutts> so apps that use xlib can start to transition to xcb bit by bit
19:12:15 <jaredj> how...?
19:12:19 <dcoutts> xcb can also be used fully threaded
19:12:38 <jaredj> if you can do it in 80k, why was Xlib 1mb?
19:12:55 <dcoutts> better understanding of the problem
19:13:01 <dcoutts> less useless features
19:13:09 <dcoutts> less/fewer
19:13:33 <monochrom> Nice
19:13:33 <dcoutts> jaredj: there's a good description in a couple presentations linked from the xcb site
19:13:41 <sorear> jaredj: in short, inverse second system effect
19:14:49 <dcoutts> they even modelled the connection layer in Z, to try and prove the threading works
19:15:10 <dcoutts> so multiple threads can share a single connection and event queue
19:15:18 <dcoutts> without deadlocking each other
19:15:22 <jaredj> nice
19:15:31 <dcoutts> there's a paper on that too
19:15:37 <jaredj> making threads not deadlock is cool
19:15:43 <jaredj> well, good.
19:16:01 <jaredj> i'm glad someone did it.
19:16:23 <dmead> is there some documentation on the function composition operator?
19:16:35 <sorear> @src .
19:16:35 <lb> (.) f g x = f (g x)
19:16:41 <dmead> ah
19:16:43 <dmead> thanks
19:17:34 <dmwit> set to explode on monday
19:17:48 <dons> jcreigh: investigating the kill issue now.
19:18:02 <dons> seems that the send destroy isn't working for some reason.
19:18:06 <jaredj> agh, terrists!
19:18:31 <jaredj> begone foul agents of terr
19:18:54 <sorear> jaredj: your or key seems broken ;)
19:19:00 <jaredj> rofl
19:19:32 <dmwit> I want to ?remember that, but... =)
19:19:44 <jaredj> |
19:19:53 <jaredj> heehee *snerk*
19:19:55 <jaredj> terr|
19:19:57 <dcoutts> right, time to do some proper work
19:20:05 <dmwit> ha!
19:20:17 <sorear> dmwit: just say ?remember in channel, I'll grep the logs once lambdabot takes over
19:20:19 <dcoutts> sorear: I'm working on binary again, trying to make it faster, I'll probably borrow some of your tricks
19:20:35 <sorear> I don't mind
19:20:49 <dcoutts> and thinking about the appropriate QC properties
19:21:01 <dcoutts> eg those subtle chunk boundary issues
19:21:11 <dmwit> ?remember sorear [jaredj: agh, terrists!  begone foul agents of terr] sorear: your or key seems broken
19:21:12 <lb> Not enough privileges
19:21:20 <sorear> yes, I had several bugs with those
19:21:47 <sorear> at one point I had an off-by-one bug that manifested by deleting a character every time the buffer spilled
19:22:06 <igli> what haskell has buffer overflow?!
19:22:09 <sorear> subtle subtle
19:23:02 <dcoutts> igli: only if you code at a very low level, using mutable buffers
19:23:06 <jaredj> my date had an off-by-one bug :(
19:23:10 <sorear> igli: if my code was a television program it would have a "don't try this at home" disclaimer
19:23:11 <_frederik_> hello, how do i add c++ sources to a cabal project? there is a field that says c-sources but i can't see anything else
19:23:12 <igli> dcoutts: k ty
19:23:19 <igli> sorear: hehe
19:23:50 <monochrom> sorear's code is x-rated
19:23:54 <dmwit> ?yow
19:23:55 <lb> Couldn't find fortune file
19:24:08 <jaredj> wow, that was a close VEGETABLE
19:24:10 <igli> man i really want to try haskell. maxiphobic heaps and persistence. love it.
19:24:36 <ddarius> www.haskell.org/ghc
19:24:55 <sorear> I'm also gonna grep \+\+, so if anyone has karma to give...
19:25:02 <dmwit> _frederik_: You might want to use something other than cabal for things that are not purely Haskell. (?)
19:25:16 <dmwit> ?karma c
19:25:17 <lb> c has a karma of 18
19:25:18 <dmwit> c++
19:25:20 <dmwit> ?karma c
19:25:20 <lb> c has a karma of 18
19:25:23 <dmwit> ;-)
19:25:33 <ddarius> ?karma+ c
19:25:34 <lb> c's karma raised to 19.
19:25:37 <thetallguy> ?karma stepcut
19:25:38 <lb> stepcut has a karma of 3
19:25:43 <balodja> what's the difference between Int and Integer?
19:25:48 <sorear> range
19:25:56 <dmwit> > maxBound :: Int
19:25:58 <lb>  2147483647
19:26:01 <sorear> > 5000000 * 5000000 :: Int
19:26:03 <lb>  -1004630016
19:26:04 <dmwit> > 2147483648 :: Integer
19:26:04 <sorear> > 5000000 * 5000000 :: Integer
19:26:05 <ddarius> > 2^70 :: Int
19:26:07 <lb>  2147483648
19:26:07 <lb>  25000000000000
19:26:08 <lb>  0
19:26:09 <thetallguy> ?karma+ stepcut
19:26:09 <lb> stepcut's karma raised to 4.
19:26:17 <sorear> _frederik_: auiu, cabal is very minimalist.  you'd be better off with autotools
19:26:19 <dons> lambdabot's on its way.
19:26:24 <dons> ?yow!
19:26:25 <lb> Couldn't find fortune file
19:26:25 <sorear> dcoutts: feel free to flame me for that
19:26:34 <sorear> lb: @quit
19:26:39 <lambdabot> Is this going to involve RAW human ecstasy?
19:26:47 <dons> damn straight!
19:26:47 <ddarius> Does lambdabot @google work?
19:26:51 <sorear> dons++ lambdabot returns!
19:26:55 <sorear> @google haskell
19:26:55 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
19:27:07 <lambdabot> http://www.haskell.org/
19:27:12 <jaredj> hooray
19:27:13 <lambdabot> Title: Haskell - HaskellWiki
19:27:14 <ddarius> HOOray!
19:27:20 <dons> well, not sure google is fixed.
19:27:42 <dmwit> lambdabot: > "I just wonder if this works"
19:27:42 <jaredj> sorear: auiu?
19:27:55 <dons> > 1 + 2
19:28:04 <lambdabot>  3
19:28:29 <dons> oh, though i probably should pull some patches.
19:28:32 <sorear> jaredj: aiui
19:28:40 <dmwit> lambdabot:> "I just wonder if this works"
19:28:56 <sorear> dons: pretty please would you upgrade regex-*?
19:28:58 <jaredj> > "I am a HAL-9000 computer. I became operational at the H.A.L. plant in Urbana, Illinois on the 12th of January 1992."
19:29:00 <lambdabot>  "I am a HAL-9000 computer. I became operational at the H.A.L. plant in Urban...
19:29:10 <dons> sorear: ok. url? or will the hackage version work?
19:29:11 <dcoutts> lambdabot!
19:29:15 <dcoutts> @botsnack
19:29:15 <lambdabot> :)
19:29:41 <jaredj> sorear: ah, iui
19:29:54 <lambdabot> Thou durst treat me as a subservient BOT!!
19:30:08 <jaredj> durst++
19:30:34 <sorear> Today's lesson in Olde English brought to you by NetHack.
19:32:41 <dmead> hello, lambdabot
19:32:53 <dmead> aw
19:32:56 <lambdabot> Kneel, human.
19:32:58 <dmead> it doesn't know it's own name?
19:33:38 <jaredj> argh
19:33:44 <dcoutts> @vixen dmead wants to know if you know your own name?
19:33:44 <lambdabot> <undefined>
19:33:45 <jaredj> my file finding code is not flexible enough
19:33:49 <dcoutts> heh
19:34:08 <Pseudonym> @vixen define "truthiness"
19:34:09 <lambdabot> <undefined>
19:34:48 <dmead> aw
19:35:08 <sjanssen> dons: I can't reproduce this xclock thing
19:36:02 <dons> sjanssen: ok. i need to try again after quitting
19:36:16 <dons> so far i've only ever see this 'destroy notify' stuff stop working after a 'restart'
19:36:16 <jaredj> hmh. counterstrike time
19:36:47 <sjanssen> dons: ah, I never use the restart feature
19:38:20 <dons> sjanssen: maybe try a restart now, then open xclock, then see if you can still close it?
19:38:37 <sjanssen> hmm, I'd need to get xmonad in my path :)
19:38:45 <dons> heh.
19:39:00 <dons> do we at least not die if its not in the path now?
19:39:06 <dons> or did we just document this feature?
19:39:31 <araujo> lambdabot is back!
19:39:36 <araujo> @botsnack
19:39:37 <lambdabot> :)
19:39:38 <dons> ah, we don't catch anything.
19:39:48 <dons> I think we should call the findInPath thingy from System.Directory first
19:39:54 <dons> then conditionally reexecute
19:41:26 <ddarius> Wow. People really love lambdabot.
19:41:34 <dcoutts> @arr!
19:41:35 <lambdabot> Har de har har!
19:41:38 <ddarius> It's probably the most loved bot on freenode.
19:41:38 <dons> lambdabot *is* love
19:41:49 <dcoutts> @botsnack
19:41:49 <lambdabot> :)
19:42:12 <lambdabot> I love each and everyone one of you!
19:42:15 <dcoutts> ddarius: you should use the proper pronoun, 'she'
19:42:21 <dcoutts> @where lambdabot
19:42:21 <lambdabot> I know nothing about lambdabot.
19:42:25 <dcoutts> hah hah
19:42:26 <ddarius> True.
19:42:27 <balodja> sorry for stupid question. but how to truncate from Integer to Int? :)
19:42:27 <dons> hah
19:42:32 <dons> fromIntegral
19:42:35 <ddarius>  @where love
19:42:38 <dons> > fromIntegral 1000000000000000000000000000
19:42:40 <lambdabot>  1000000000000000000000000000
19:42:41 <dons> > fromIntegral 1000000000000000000000000000 :: Int
19:42:42 <lambdabot>  -402653184
19:42:50 <balodja> thanks
19:43:06 <dcoutts> http://www.cse.unsw.edu.au/~dons/images/lambdabot.png
19:43:12 <dcoutts> ddarius: she ^^
19:43:27 <sjanssen> dons: I can still kill xclock after restarting
19:43:31 <ddarius> dcoutts: I know. [21:40] <ddarius> True.
19:43:48 <_frederik_> sorear, dmwit: thanks
19:44:01 <dcoutts> ddarius: ok, you've seen the picture before :-)
19:44:04 <QtPlatypus> dcoutts: She doesn't look healthy.
19:44:12 <sorear> ok, i've got all 7500 lines uttered wo lambdabot
19:44:16 <_frederik_> does someone have an example of a minimal haskell library install with autotools?
19:44:24 <dcoutts> QtPlatypus: we're always bother her, it's difficult to find a moment to sleep
19:44:25 <ddarius> She's reading about Arrows.
19:44:45 <_frederik_> i can just look at the darcs source i guess
19:44:59 <dons> sjanssen: hmm. i bet if I restart it'll start working.
19:45:05 <dcoutts> _frederik_: I've got a non-minimal example, gtk2hs.
19:45:16 <_frederik_> ok
19:45:26 <_frederik_> is it better than darcs?
19:45:45 <dcoutts> dunno
19:45:47 <shachaf> sjanssen: What's the right capitalization of "xmonad"?
19:45:50 <emu> why use autotools?
19:45:55 <_frederik_> ok thanks
19:45:59 <dcoutts> autotools do suck
19:46:05 <dmwit> shachaf: xmonad
19:46:07 <emu> ?where cabal
19:46:08 <lambdabot> I know nothing about cabal.
19:46:12 <dcoutts> cabal is better if it'll cope with your project
19:46:13 * emu slaps lambdabot 
19:46:16 <_frederik_> yeah i probably will not use autotools, just make + my own stuf
19:46:21 <sorear> @karma sorear
19:46:22 <lambdabot> You have a karma of 33
19:46:26 <dons> scw: hmm, 'xmonad' or 'XMonad'
19:46:26 <emu> no, use Cabal
19:46:26 <sorear> ndm++ dmhouse++ jcreigh++ hpaste++ dmhouse++ simplifier++ bos++ jyp++
19:46:28 <sorear> @flush
19:46:35 <sorear_> sorear++
19:46:40 <emu> it's easy and will fit right in with haskell libraries
19:47:01 <_frederik_> emu: cabal won't deal well with my project
19:47:04 <dcoutts> _frederik_: generally the only thing that's worse than autotools is home grown replacements using make :-)
19:47:19 <dmwit> ?help flush
19:47:20 <lambdabot> flush. flush state to disk
19:47:24 <_frederik_> dcoutts: well, i'm not using autotools
19:47:24 <ddarius> Who doesn't love m4?
19:47:32 <dcoutts> me!
19:47:43 <_frederik_> the purpose of m4 in autotools is because they didn't want to depend on a shell which had functions
19:47:47 <_frederik_> functions
19:47:49 <dcoutts> gtk2hs is only using autotools because cabal doesn't cope yet, and I'm trying to make improvements in that direction
19:47:58 <_frederik_> so they depended on a weird macro preprocessor instead
19:48:16 <_frederik_> dcoutts: i have been waiting for cabal to not suck for years
19:48:36 <shachaf> Does any XMonad user here run 'unclutter' (especially 'unclutter -keystroke')?
19:48:41 <dcoutts> _frederik_: so what areas would cabal need to be extended for your project?
19:48:43 <ddarius> I guess it could be worse.  It could be like TeX.  TeX as a programming language is sheer insanity incarnate.
19:48:59 <sorear> @remember jcreigh "hmm...I'm blacklist by google...what can I do online? Guess I'll just surf Youtube...wait, crap!"
19:49:00 <lambdabot> Done.
19:49:01 <_frederik_> dcoutts: but i think that was dumb of me because it is broken more fundamentally
19:49:18 <sorear> @remember ray i named my superuser "haskell"
19:49:18 <_frederik_> dcoutts: it just needs to be able to do more than some small collection of tricks
19:49:19 <lambdabot> Done.
19:49:34 <dmwit> shachaf: Sounds like no; is there a problem?
19:49:35 <dcoutts> _frederik_: can you be more specific?
19:49:40 <shachaf> dmwit: It doesn't seem to work (with -keystroke) under XMonad, though it does under plain X.
19:49:50 * dmwit goes to install unclutter
19:49:51 <sorear> @remember dmhouse instance Lambdabot where { ?pl = xerox, ?where = shapr, ... }
19:49:52 <lambdabot> Done.
19:49:59 <dons> shachaf: i run unclutter, yes.
19:50:17 <dons> but not with the keystroke flag, just unclutter -idle 1 &
19:50:18 <_frederik_> dcoutts: all the stuff i've been talking about today. generated files. c++ files. what is needed is an interpreter of a language, such as 'make' is.
19:50:22 <dcoutts> _frederik_: of course cabal it was created quickly and not in a very extensible way. That's well known. It works just well enough for most smallish libs so people are not motivated to push it further.
19:50:28 <sorear> ?remember sorear [jaredj: agh, terrists!  begone foul agents of terr] sorear: your or key seems broken
19:50:29 <lambdabot> Done.
19:50:39 <dons> shachaf: is there an interaction?
19:50:50 <ddarius> lambdabot holds the collective knowledge of #haskell
19:50:52 <ddarius> @quote
19:50:53 <lambdabot> PaulPotts says: Haskell is an even "redder" pill than Lisp or Scheme
19:50:54 <_frederik_> dcoutts: i don't think it's so well known. i got a lot of flack for criticizing it
19:51:05 <sorear> @tell swiert it was suggested to me that a review date would be helpful, I note TMR editions do not seem to have the date in them, perhaps they should.
19:51:06 <lambdabot> Consider it noted.
19:51:11 <dcoutts> _frederik_: well I'm a cabal maintainer and I know it :-)
19:51:27 <sorear> @tell swiert [from dcoutts] and I've been asked for the list price in Swedish Kronor but have no idea how to find that out! :-)
19:51:28 <lambdabot> Consider it noted.
19:51:54 <sorear> ?tell glguy [from dmhouse] I'm getting http://hpaste.org/1387 when I try to build hpaste (from darcs) with the latest (from darcs) HAppS. I also had to comment out the 'thefor = strAttr "for"' line in HPasteAdmin, why's that?
19:51:54 <lambdabot> Consider it noted.
19:51:57 <dcoutts> sorear: in the end I added a 'street price' bit :-)
19:52:02 <shachaf> dons: Interaction?
19:52:03 <_frederik_> do people realise that one can send private messages to lambdabot?
19:52:19 <dons> shachaf: I was presuming you had a bug report? :-)
19:52:24 <dons> _frederik_: i hope so.
19:52:27 <dcoutts> _frederik_: so there's this tension between being declarative and having a full language to describe the build systems.
19:52:34 <dons> _frederik_: since a lot of code was written to support that :-)
19:52:39 <dmwit> shachaf: xmonad grabs keypresses, that may interfere with you.
19:52:52 <dons> sjanssen: so re. restart, I think we can first, findExecutable :: String -> IO (Maybe FilePath)
19:53:00 <ddarius> @where tmr
19:53:01 <lambdabot> I know nothing about tmr.
19:53:02 <dmwit> The man page for unclutter says clients that grab keypress events may interfere.
19:53:09 <dons> then optionally restart, rather than just shooting ourselves
19:53:13 <ddarius> @where+ tmr http://www.haskell.org/haskellwiki/The_Monad.Reader
19:53:13 <lambdabot> Done.
19:53:17 <_frederik_> dcoutts: well, i came to haskell because it is nice and elegant and mathematical. so it's a bit disappointing to have to spend so much time trying to figure out how to use an interface which is exactly the opposite, namely cabal
19:53:23 <dons> dmwit: so that would be all tiling wms?
19:53:31 <dcoutts> _frederik_: if you make it declarative then it's easier to translate into other systems, eg distro packages or to build using IDEs etc, it gives a lot more introspection data, on the other hand it does limit the expressiveness of the build system.
19:53:36 <dmwit> dons: I honestly don't know, it's a conjecture only.
19:53:38 <shachaf> dmwit: Oh, hmm. OK.
19:53:51 * shachaf imagines a mouse-based tiling WM.
19:53:52 <dons> shachaf: so do you have a bug report? does something go wrong?
19:54:13 <sorear> ok, I'm dons
19:54:19 <sorear> s/s$/e
19:54:27 <_frederik_> dcoutts: yeah, if you make it useless then it is really broadly useful
19:54:32 <shachaf> dons: Well, it doesn't work (don't you love that type of bug report?).
19:54:41 <sorear> @flush
19:54:41 <_frederik_> dcoutts: sorry, i am going to sleep now
19:54:43 <shachaf> dons: I don't really need it anyway, I just thought it'd be interesting.
19:54:50 <dmwit> shachaf: unclutter -keystroke seems to work here.
19:54:58 <dmwit> Do you have other things that might be relevant?
19:54:58 <dcoutts> _frederik_: I'm not sure we'll ever find an elegant mathematical build system :-) it's a bit of a grubby problem. I do have some ideas of how to make it a lot nicer but it does take a lot of work.
19:55:08 <dcoutts> _frederik_: 'k g'night
19:55:10 <dons> sorear: you're not dons.
19:55:44 <shachaf> dmwit: Under XMonad?
19:55:48 <dmwit> yes
19:56:20 <shachaf> dmwit: Hmm, that's odd.
19:56:24 <dons> shachaf: unless you're writing articles, i'd just use 'xmonad' :-)
19:56:27 <dmwit> shachaf: Can you run unclutter in a terminal to see if it prints any messages?
19:56:35 <dons> in fact, i'd suggest the program's name is 'xmonad'
19:56:37 <shachaf> dmwit: It doesn't.
19:56:44 <dmwit> hum
19:56:46 <dons> the internal monad is the 'X monad'
19:57:31 <shachaf> dons: OK, thanks (from my shift-finger).
19:58:30 <dons> sjanssen: just pushed a patch for 'restart'. should now silently fail if xmonad isn't in the path.
19:58:52 <shachaf> dmwit: You don't run Ubuntu by any chance, do you?
19:58:54 <dons> which avoids the complete quit out of X bug, I think.
19:59:00 <dons> sjanssen: if you'd like to test it
19:59:18 <dmwit> shachaf: I do, but stand by.
19:59:35 <dmwit> shachaf: I just discovered that xchat hides the cursor on keypress anyway, so my "test" may be broken. =P
20:00:08 <dmwit> shachaf: You're right, it does not hide the cursor, nor print any message.
20:00:44 <shachaf> dmwit: Hmm, it looks like some other GTK apps do it (gedit, though not Firefox).
20:01:03 <shachaf> dmwit: I guess Firefox and xterm would be the two big ones.
20:01:25 <shachaf> dmwit: "-idle 1" is probably good enough.
20:01:35 <dmwit> shachaf: Okay, sorry it doesn't work for you.
20:02:10 * dmwit goes to work
20:02:11 <sjanssen> dons: seems to work
20:07:13 <dons> ok good. one less failure point.
20:07:25 <dons> now just have to track down the kill window issue
20:09:12 <igli> ddarius: ty for pointer, i have it installed, i just haven't got round to it. maybe this room'll make me change that tho ;)
20:09:13 <dcoutts> 13595 rules fired!
20:09:23 <dcoutts> 1738 foldr/build
20:10:09 <ddarius> igli: Dead seriously: The community of Haskell is almost reason enough to use it.
20:10:10 <sjanssen> @yow
20:10:11 <lambdabot> Barbie says, Take quaaludes in gin and go to a disco right away!
20:10:12 <lambdabot> But Ken says, WOO-WOO!!  No credit at "Mr. Liquor"!!
20:10:12 <dons> dcoutts: woo!
20:10:16 <dons> dcoutts: what's that in?
20:10:24 <dons> that's not ghc is it?
20:10:28 * dons suspects it is..
20:10:30 <Pseudonym> Use Haskell, because you'll get to hang around with ME!  And I'm COOL!
20:10:37 <dons> that's true.
20:10:41 <dcoutts> dons: but I've no idea where that comes from, it's in binary.
20:10:41 <ddarius> Damn straight!
20:10:52 <dons> dcoutts: huh..
20:10:57 <igli> ddarius: very good to know, thanks. i bought a book called "The Fun of Programming" a few years ago; can i ask noob q's on the code?
20:10:59 <dcoutts> dons: Benchmark.hs, but I don't see any lists anywhere...
20:11:07 <ddarius> Of course.
20:11:11 <dons> *binary* has 13k stream rules? hmm. ah, lists? cons?
20:11:26 <ddarius> Alternatively, The community of Lisp as almost reason enough to use Haskell.
20:11:26 <sorear> dons: cons doesn't fuse
20:11:32 <ddarius> s/as/is/
20:11:45 <dons> hmm, is the list of functions unwrapped and applied to the generated list?
20:11:45 <igli> ok thanks man; bear in mind i know ML, but it's been years.. i'll get the book, it had *lush* stuff in it
20:12:05 <dcoutts> dons: 2000 unpacks, 1700 unapck-append, 1200 unpack-list
20:12:09 <dons> sorear:
20:12:10 <dcoutts> dons: I don't get it at all
20:12:10 <dons> cons w (Stream next0 s0) = Stream next (S2 :!: s0)
20:12:11 <dons>   where
20:12:11 <dons>     {-# INLINE next #-}
20:12:11 <dons>     next (S2 :!: s) = Yield w (S1 :!: s)
20:12:13 <dons>     next (S1 :!: s) = case next0 s of
20:12:15 <dons>         Done       -> Done
20:12:18 <dons>         Skip    s' -> Skip    (S1 :!: s')
20:12:20 <dons>         Yield x s' -> Yield x (S1 :!: s')
20:12:23 <dons> ;-)
20:12:36 <chessguy> @type \x y -> x + y
20:12:40 <lambdabot> forall a. (Num a) => a -> a -> a
20:12:54 <chessguy> @type \(x :: Int) y -> x + y
20:12:57 <lambdabot> Int -> Int -> Int
20:13:01 <sorear> dons .... cons has a foldr/build rule, and it is commented out with a reason .... are we sure the reason is invalid?
20:13:26 <chessguy> @type \(x :: Num a => a) y -> x + y
20:13:29 <lambdabot>     All of the type variables in the constraint `Num a' are already in scope
20:13:29 <lambdabot>         (at least one must be universally quantified here)
20:13:41 <dcoutts> sorear: I'm pretty sure the reason is valid
20:13:45 <chessguy> eh?
20:13:58 <sjanssen> sorear: the ghc user guide claims that (:) is a good producer
20:14:00 <dcoutts> sorear: SPJ tried it, and cites the example in that comment
20:14:11 <dons> sjanssen: i note that i can kill xclock after restarting.
20:14:12 <Philippa> sjanssen: I'd hope so!
20:14:15 <dons> sorry, quitting,
20:14:32 <dons> sorear: yeah, there's a good reason. it kills compile times
20:14:36 <dcoutts> Philippa: the problem is massive code blowups with constant lists
20:14:56 <dcoutts> foldr f z [ .... ]
20:15:05 <dons> really really kills , like 2sec -> 20 minutes per module :-)
20:15:11 <sorear> and stream cons fuses!
20:15:17 <dons> sure .
20:15:23 <dons> we used to have it on by default.
20:15:23 <dcoutts> sorear: though we're not sure it's a good idea
20:15:33 <dons> its not obviously going to speed things up
20:15:52 <dons> maybe, if we could avoid it for string literals
20:16:02 <chessguy> @type x :: (Num a => a)
20:16:04 <lambdabot>     Couldn't match expected type `a' (a rigid variable)
20:16:05 <lambdabot>            against inferred type `Integer'
20:16:12 <igli> man ain't it always so; can't find the fscking book.
20:16:14 <chessguy> wtf
20:16:29 <sorear> dons: I'm also a little squeamish about those data constructors.  why doesn't stream-fused code turn into a giant wad of peano number manipulation?
20:16:36 <sorear> > x
20:16:37 <lambdabot>   Not in scope: `x'
20:16:40 <sorear> > L.x
20:16:42 <lambdabot>   Not in scope: `L.x'
20:16:42 <dons> sjanssen: ah, and after restart i can still kill xclock
20:16:50 <dons> sjanssen: so something else disables the destroy code
20:16:56 <dcoutts> sorear: SpecConstr
20:16:59 <chessguy> sorear: some kind of defaulting?
20:17:13 <chessguy> @type sorear :: (Num a => a)
20:17:16 <lambdabot> Not in scope: `sorear'
20:17:21 <dons> sorear: yeah, read the paper. we devote a large section to this :-)
20:17:22 <sorear> @type x
20:17:25 <lambdabot> Integer
20:17:38 <chessguy> @let x = "foo"
20:17:39 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
20:17:46 <dcoutts> sorear: constructor specialisation, it's a vital optimisation for that kind of code
20:17:55 <ddarius> igli: Meh, there're plenty of resources available on line.
20:17:58 <sorear> @google GSL07
20:18:02 <lambdabot> http://www.goldstandardlabs.com/store/index.php?main_page=product_info&products_id=73&zenid=17b6d2ea431dbec498d6748c08296fd6
20:18:02 <lambdabot> Title: VSS, The 21:51 [GSL07] - $9.00 : GSL
20:18:29 <dons> @google CLS07
20:18:32 <lambdabot> http://www.golfbuyitonline.co.uk/cobra-golf-cls07-ladies-8.5-inch-stand-bags.php
20:18:32 <lambdabot> Title: Cobra Golf CLS07 Ladies 8.5 inch Stand bags
20:18:33 <sorear> @google from lists to streams to nothing at all
20:18:34 <dons> hehe
20:18:34 <lambdabot> http://www.cse.unsw.edu.au/~dons/papers/CLS07.html
20:18:35 <lambdabot> Title: Stream Fusion: From Lists to Streams to Nothing at All
20:18:38 <igli> ddarius: cool, i'll check the links. (book wasn't for noobs btw, you'd love it if you haven't seen it.)
20:18:46 <sorear> I like my title memory ;)
20:19:09 <dons> its a good title, that's why ;-)
20:19:10 <ddarius> Grargh!
20:19:18 <sorear> igli: books are so overrated ;) I never found haskell difficult, somehow...
20:19:41 <igli> heh it's not a book on how to prog haskell tho
20:20:16 <igli> surprised no-one's heard of it tbh (silly me ;)
20:20:39 <ddarius> I'm betting almost everyone in here has heard of it.
20:21:26 <ddarius> sorear: You only say that because you fortuitously chose to be a programmer/computer scientist.
20:22:00 <ddarius> (for some values of "be")
20:22:13 <Philippa> and to an extent, FSVO 'chose'
20:22:14 <monochrom> I never found haskell difficult. This is because I did not know many other languages.  If you already know N languages, learning haskell takes N years.  Learning is unlearning.
20:22:21 * sorear looks at Fig. 1 in CSL07 and faints (dons)
20:22:23 <dons> hehe
20:22:58 <dons> sorear: looks good to me.
20:23:09 <sorear> dons: that's the point :)
20:23:23 <dons> ah good. so you 'swooned' I think
20:23:30 <sorear> yeah.
20:23:50 <dons> not uncommon when reading haskell papers.
20:24:27 <desp> monochrom: nah
20:25:16 <chessguy> i don't think you necessarily have to unlearn what you learned from other languages, you just have to have an open enough mind to add a different way of thinking
20:26:18 <monochrom> Yes.  I did that.  I actually needed just log(N) years.
20:26:29 <desp> chessguy: exactly, I was trying to say something like that
20:26:30 <desp> :)
20:26:42 <monochrom> It is, however, hard to demand other people to be open-minded.
20:26:49 <dons> hmm. yes, I knew 0 languages, and learnt haskell in 1.
20:26:58 <desp> monochrom: not if you've got a big enough axe
20:27:03 <monochrom> You knew English.
20:27:14 <sorear> I've been using Haskell for about 1 year now
20:27:16 <ddarius> Ack dons!  Exponential time!
20:27:29 <sorear> I jointed #haskell with 0.5y haskell experience
20:27:33 <dcoutts> dons: yay, first benchmark of my new binary code, word8 writes in groups of 1 up to 16, old code: 14-415Mb/s, new code: 32-178Mb/s
20:27:37 <Philippa> do I have to count the couple of years between the FP course at nottingham and my actually coding in it again?
20:27:40 <monochrom> An open mind that's dead is not very useful either... :)
20:27:45 <igli> lol
20:27:49 <dons> > 1 + logBase (exp 1) 1
20:27:50 <lambdabot>  1.0
20:27:51 <Philippa> also, do I have to count /every/ turing complete language I knew at that point? :-)
20:27:51 <dons> > 1 + logBase (exp 1) 2
20:27:51 <chessguy> @spell jointed
20:27:53 <lambdabot> jointed
20:27:53 <lambdabot>  1.6931471805599454
20:27:54 <dons> > 1 + logBase (exp 1) 3
20:27:56 <lambdabot>  2.09861228866811
20:27:58 <dons> > 1 + logBase (exp 1) 10
20:28:00 <lambdabot>  3.302585092994046
20:28:03 <dons> how's that?
20:28:06 <dons> > 1 + logBase (exp 1) 100
20:28:07 <lambdabot>  5.605170185988092
20:28:11 <dons> :-)
20:28:12 <ddarius> Philippa: Does C++ count twice?
20:28:21 <chessguy> what? jointed is a word?
20:28:23 * chessguy checks dictionary.com
20:28:27 <dons> dcoutts: woo.
20:28:30 <dcoutts> dons: and I'm not using any of sorear's tricks yet. One thing to note though is that the rules currently only mach specific forms.
20:28:32 <Philippa> ddarius: good question, I did learn C first
20:28:34 <ddarius> chessguy: Yes!
20:28:34 <dons> i love double speed ups.
20:28:41 <dons> dcoutts: oh, only from rules??
20:28:43 <dcoutts> more than double
20:28:48 * ddarius is referring to C++ and the C++ template system.
20:28:50 <dcoutts> > 178/45
20:28:51 <lambdabot>  3.9555555555555557
20:28:54 <Philippa> I never actually wrote any serious template code
20:28:58 <Philippa> yeah, got that, was just typing more
20:29:00 <chessguy> ah, duh. just not a verb
20:29:03 <Philippa> well, not that value of "serious"
20:29:04 <dcoutts> 4x speedup for the writing 16 bytes in a go
20:29:10 <dons> even better
20:29:15 <ddarius> Ah.
20:29:16 <dons> only from rules, though?
20:29:21 <dons> dcoutts: if so, that's a great result.
20:29:29 <dcoutts> dons: rules and my simple impl
20:29:35 <dons> ok
20:29:36 <Philippa> oh, and do lambda calculus variants I put together myself count as new languages? :-)
20:29:44 <Philippa> (and do they have to have an actual implementation first?)
20:29:46 <ddarius> Philippa: No.
20:29:56 <fuzan> i'm tring to build hs-plugins on my archlinux box, yet every time I try to configure it says:
20:30:03 <sorear> Coutts et al reads really strange in an academic paper.
20:30:06 <fuzan> checking for C compiler default output file name... configure: error: C compiler cannot create executables
20:30:16 <ddarius> That said, most of my language implementations came after I learned Haskell.
20:30:20 <dcoutts> sorear: heh heh, it does doesn't it :-)
20:30:55 <dcoutts> sorear: for the submission we have to refer to ourselves in the third person as it's a double-blind review process
20:31:29 <chessguy> @remember desp [monochrom]: It is, however, hard to demand other people to be open-minded. [desp]: not if you've got a big enough axe
20:31:29 <dcoutts> we have to cite our own papers without making it really obvious we're the same authors
20:31:30 <lambdabot> Done.
20:32:18 <dons> the opening sentence is great, http://programming.reddit.com/info/1i7w1/details
20:32:19 <lambdabot> Title: Comparing Approaches to Generic Programming in Haskell (PDF) (reddit.com)
20:33:00 <igli> hmm makes me want to finish my doctorate hearing you guys talk..
20:33:13 <igli> although it was hardcore C ;)
20:33:27 <ddarius> "third webshop" ?
20:33:30 <desp> :)
20:33:44 <igli> does that mean i'm excommunicated?
20:33:46 <chessguy> what's a webshop? an online store?
20:34:06 <chessguy> igli: just be glad you're not lynched (yet)
20:34:08 <ddarius> igli: I'm willing to bet everyone here knows and can competently program in C.
20:34:12 <igli> kik
20:34:19 <dons> igli: its ok if it was C that you generated from your haskell compiler
20:34:23 <igli> lol sorry (is that allowd)
20:34:38 <igli> dons: sorry, i'm a machine coder at heart
20:34:50 <dons> that must be a strange place to live
20:34:56 <monochrom> Since you were not baptized, you will not be excommunicated.
20:34:57 <dons> abstractions are really nice.
20:35:00 <igli> heh
20:35:07 <igli> yeah, i like tables ;)
20:35:12 <dcoutts> dons: yeah, "third webshop" :-) nice
20:35:40 <igli> nah i like ML and Prolog a lot
20:36:38 <chessguy> ?uptime
20:36:39 <lambdabot> uptime: 1h 10m 28s, longest uptime: 5d 3h 40m 45s
20:36:45 <ddarius> Somehow, Triump the Insult Comic Dog and Prolog come together in my mind...
20:36:57 <ddarius> s/Triump/Triumph
20:37:09 <igli> yeah well i'm prob'y a lot older than you sunshine ;)
20:37:15 <ivanm> does anyone know if there's a mathematica-like notebook interface for haskell?
20:38:03 <ddarius> igli: Probably.  ML is ugly, Prolog is ugly in an entirely different way.
20:38:38 <igli> heh well maybe haskell can show me the light ;)
20:38:56 <monochrom> ML is not ugly.
20:38:58 <igli> i really like the look of darcs as well
20:39:05 <igli> ++monochrom
20:39:29 <igli> now LISP.. there's an ugly lang <troll>
20:39:50 <monochrom> Unmatched tag.
20:39:58 <johnnowak> off with his cdr!
20:40:10 <johnnowak> em. car.
20:40:21 <desp> Prolog is more alien than ugly.
20:40:29 <chessguy> taking of his tail would be pretty painful too :)
20:40:31 <fuzan> SML is kinda ugly :)
20:40:52 <johnnowak> chessguy: whatever works :)
20:40:52 <fuzan> very monolithic.
20:41:05 <desp> seriously, all these languages are beautiful. just take a look at C++/CLI.
20:41:16 <fuzan> I cant' seem to figure out why configure breaks on hs-plugins :(
20:41:19 <chessguy> @remember johnnowak off with his car!
20:41:20 <lambdabot> Done.
20:41:25 <ddarius> monochrom: Only syntactically for the most part.
20:42:21 <monochrom> All Things Bright And Beautiful.
20:42:23 <ddarius> desp: Prolog is a good language to learn, but if you don't want to gouge your eyes out from the lack of sane "HOFs" something is wrong with you.
20:42:59 <desp> pardon, HOFs?
20:43:13 <ddarius> Higher order functions
20:43:20 <desp> ah
20:43:32 <chessguy> Hysterically Ostentatious Forks
20:44:06 <desp> in my case, it was more mind-gouging, because of the declarativeness of it all.
20:44:26 <ddarius> You usually don't want Prolog style backtracking and such.
20:48:37 <igli> hmm i like that tho ;)
20:49:24 <dons> its a useful technique. i'm not sure i'd base an entire language on it.
20:49:39 <ddarius> igli: It means you spend most of the time battling the language, battling it into a functional language no less.
20:49:41 <dons> seems like you'd want backtracking for some problem, so may as well just use a backtracking monad
20:49:57 <dons> ddarius: exactly, this has been my experience too
20:50:01 <desp> yep.
20:50:02 <ivanm> dons: thanks for getting lambdabot working again!!! did you manage to resolve the google problem?
20:50:08 <dons> ivanm: haven't looked at it yet.
20:50:12 <igli> dons: thanks that what i wanted to hear ;)
20:50:23 <jcreigh> @google lambdabot
20:50:25 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
20:50:25 <lambdabot> Title: lambdabot
20:50:31 <ivanm> dons: oh, just got her going anyway?
20:50:32 <ddarius> @google "Programming in an Integrated Functional and Logic Language"
20:50:35 <lambdabot> http://www.cs.tu-berlin.de/journal/jflp/articles/1999/A99-03/A99-03.html
20:50:36 <lambdabot> Title: JFLP: Volume 1999, Article 3
20:50:39 <ivanm> hey, it _is_ working!
20:50:41 <dons> igli: yeah, since in haskell at least, the ';' operator can be reprogrammed, depending on which monad you use.
20:51:07 <dons> so that how you code evaluates changes based on the monad, from purely functional, to imperative, to backtracking, and more.
20:51:14 <igli> woah
20:51:23 <dons> that way you don't get frustrated if you're stuck in just imperative or just backtracking evaluation
20:51:53 <igli> kk i'll go and read some dox :D
20:51:55 <dons> 'whoa' is an appropriate response :-)
20:52:17 <igli> heh it's a *real* compliment from me.
20:52:30 <dons> you see language design choices at a completely different level once you grok the 'programmable semicolon' model of monads, imo.
20:53:18 <ddarius> dons: As monad transformers?
20:53:28 * fuzan curses hs-plugins
20:53:29 <merus> programmable semicolon is as close to a "monads as monads" worldview as I've seen yet.
20:53:35 <Philippa> ...hmm, we should do a Haskell film starring Keanu Reeves then
20:53:47 <Philippa> merus: that's because you don't speak category theory :-)
20:53:49 <dons> yeah, and the arbitrary restrictions most languages make, once they pick just one fixed monad stack
20:53:58 <monochrom> Apparently you can also make things strict or lazy at will.
20:54:01 <merus> Philippa, woe is me.
20:54:14 <dons> fuzan: you using the darcs repo? you using ghc 6.6?
20:54:18 <dons> you on linux?
20:54:21 <fuzan> yes yes yes
20:54:27 <dons> ok. what goes wrong then?
20:54:31 <monochrom> (Of course I mean choose at will but hide it behind ; so the external syntax shows nothing.)
20:54:32 <sorear> 64bit?
20:54:38 <fuzan> configure: error: C compiler cannot create executables
20:54:39 <fuzan> 32
20:54:43 <dons> no 64 bit issues that i know of, atm.
20:54:55 <dons> fuzan: hmm, that's not hs-plugins. maybe you have a funny CPPFLAGs setting?
20:55:00 <sorear> fuzan: is that wrong?
20:55:01 <dons> check the configure log
20:55:04 <fuzan> from config.log: conftest.c:10: error: stray '\33' in program
20:55:11 <dons> oh interesting.
20:55:16 <dons> i think i have a patch for this..
20:55:33 <dons> Artem Gr             hs-plugins CYGWIN CR/LF patch
20:55:34 <fuzan> it built fine on my gentoo box.
20:55:37 <dons> sounds plausible.
20:55:40 <dons> > '\33'
20:55:42 <lambdabot>  '!'
20:55:44 <dons> hmm.
20:55:57 <dons> i have no idea, actually. that's highly mysterious.
20:56:01 <dons> more investigation.
20:56:20 <fuzan> i've been looking into it, i'm trying to get lambdabot runnign for my school's lug on my alternate machine.
20:56:46 <fuzan> gcc-4.1.2
20:57:01 <thoughtpolice> dons: i couldn't get hs-plugins to build on 6.6 (archlinux) for the same reason
20:57:08 <dons> huh. ok.
20:57:14 <dons> just because ./configure was failing?
20:57:17 <thoughtpolice> i ended up changing ./configure to get farther in the build process
20:57:20 <dons> and failing one of its automated tests?
20:57:21 <thoughtpolice> but that didn't get me much farther
20:57:24 <thoughtpolice> yes
20:57:29 <dons> does it help to regenerate configure? using autoreconf?
20:57:43 <thoughtpolice> hm i'll have to get the darcs again
20:57:45 <thoughtpolice> just a sec
20:57:58 <fuzan> nope.
20:58:16 <igli> fuzan: it does sound like a flag error; have you got custom LDFLAGS or anything?
20:58:53 <fuzan> no idea. I installed archlinux so I wouldn't have to configure much :)
20:59:06 <thoughtpolice> fuzan: you're an arch user too huhu
20:59:16 <fuzan> fuzan: not really. I kind of dislike it :)
20:59:24 <fuzan> thoughtpolice: gentoo.
20:59:36 <igli> yay!
20:59:56 <igli> well then you know what i'm on about tf
21:00:02 <thoughtpolice> dons: also, i modified configure with a simple patch to get through configure to ./Setup.lhs build, but there was also a syntax error in one of the modules that killed the compilation. i'm getting the source again and if you need it i'll give you the place of err.
21:00:15 <sorear> igli: tf?
21:00:21 <igli> er thank friday ;)
21:00:34 <dons> thoughtpolice: you using the darcs repo with 6.6 as well?
21:00:40 <sorear> thoughtpolice: INSTANCE_TYPEABLE0 in AltData, perchance?
21:00:41 <igli> fuzan: haskell on gentoo is nice tho
21:01:01 <dons> right, that's the error expected with an old hs-plugins src.
21:01:27 <igli> what i really want to know is: what's arch like for a gentoo head? (OT i know..)
21:02:02 * sorear suspects that there is actually no difference whatsoever between distroes
21:02:32 * igli suspects sorear is talking out of his rear ;)
21:02:49 <igli> er sorry
21:02:59 <dcoutts> @slap igli
21:02:59 * lambdabot smacks igli about with a large trout
21:03:04 <igli> lol
21:03:11 <sorear> my family left that place many years ago, thank you
21:03:31 <igli> eh?
21:03:45 <dcoutts> igli: and lambdabot will do it again if you're rude again :-)
21:03:49 <sorear> o'rear, it's a surname...
21:04:00 <igli> dcoutts: no prob, will behave
21:04:10 <igli> sorear: apologies for my bad manners
21:04:21 <sorear> igli: I didn't notice
21:04:26 <igli> heh cool
21:04:27 <jcreigh> sorear's nick is hard to tokenize. :)
21:04:44 <thoughtpolice> thou: yes
21:04:45 <igli> you mean parse or lex? ;)
21:04:48 <thoughtpolice> sorear: bingo
21:04:50 <thoughtpolice> er
21:04:52 <thoughtpolice> dons: yes
21:05:37 <sorear> upgrade to darcs hs-plugins then, the tarball is known to be 6.6-incompatible
21:05:51 <sorear> that error is the manifestation
21:06:39 <igli> jcreigh: my bad, you *said* tokenise.
21:10:05 <thoughtpolice> sorear: ah
21:10:39 <hpaste>  thoughtpolice pasted "hs-plugins build err" at http://hpaste.org/1411
21:10:53 <thoughtpolice> dons: look at that paste and you'll see the err
21:10:58 <thoughtpolice> now at least I have hs-plugins installed :)
21:11:10 <sorear>  | ^[[?1034h"
21:11:20 <sorear> thoughtpolice: there's your problem
21:11:28 <sorear> afaik that's an xterm mouse control code
21:11:51 <thoughtpolice> sorear: i hadn't thought as to what was injecting it into the string
21:12:02 <sorear> you must have accidentally done somethign while you were setting TOP?
21:12:07 <thoughtpolice> nope
21:12:10 <thoughtpolice> i just configured it like normal
21:12:16 <thoughtpolice> didn't really change anything
21:12:22 <sorear> wahat is TOP, anyway?
21:12:25 <thoughtpolice> um
21:13:18 <sorear> hmm, thoughtpolice: pwd | hd
21:13:26 <sorear> any funny characters?
21:13:29 <thoughtpolice> TOP=`echo "Directory.getCurrentDirectory >>= putStrLn.init.tail.show " | ghc --interactive -ignore-dot-ghci -v0`
21:13:32 <sorear> try /usr/bin/hd too
21:13:46 <igli> conftest.c:10: error: stray '\33' in program
21:13:52 <sorear> Oooh.
21:13:56 <sorear> Ouch.
21:14:10 <igli> didn't someone mention that? it's ASCII ! or summat?
21:14:13 <sorear> sounds like arch's readline is messing you up.
21:14:13 <thoughtpolice> /bin/sh: /usr/bin/hd: No such file or directory
21:14:18 <thoughtpolice> :(
21:14:37 <sorear> igli: haskell is the only lang where \33 is !, the rest of the world uses octal and \33 is ESC
21:14:52 <igli> not hex? sorry, asm head ;)
21:14:59 <thoughtpolice> well at least hs-plugins is installed
21:15:02 <thoughtpolice> maybe i can do something fun
21:15:46 <jcreigh> igli: not octal.
21:16:12 <igli> no not in hex either, thinking ASCII 33 (and i don;t know what that is)
21:16:20 <monochrom> > (12, o12, x12)
21:16:21 <lambdabot>   Not in scope: `x12'
21:16:24 <jcreigh> igli: most languages use have "\123" escape codes that use octal. Haskell's is decimal.
21:16:31 <monochrom> > (12, \o12, \x12)
21:16:32 <lambdabot>  Parse error
21:16:41 <igli> jcreigh: cool
21:16:41 <jcreigh> s/languages use/languages/
21:16:43 <monochrom> I'll go read the docs
21:16:44 <sorear> thoughtpolice: ghci -v0 < /dev/null | hexdump  # what comes out?
21:17:36 <monochrom> (012, 0o12, 0x12)
21:17:42 <monochrom> > (012, 0o12, 0x12)
21:17:44 <lambdabot>  (12,10,18)
21:18:36 <monochrom> ('\33', '\o41', '\x21')
21:18:45 <monochrom> > ('\33', '\o41', '\x21')
21:18:47 <lambdabot>  ('!','!','!')
21:19:18 <fuzan> > chr 33
21:19:20 <lambdabot>  '!'
21:19:28 <thoughtpolice> 0000000 5b1b 414f 4404 6834
21:19:31 <thoughtpolice> 00000008
21:19:39 <sorear> nice.
21:19:44 <sorear> we have nonportability
21:19:48 <thoughtpolice> er, 0000008
21:19:51 <thoughtpolice> :/
21:19:58 <sorear> on my system, that command gives no ouput!
21:20:12 <sorear> and I'll bet on dons' too
21:20:48 <sorear> thoughtpolice: try "ghc -e '' | hexdump"
21:20:52 <fuzan> igli: what exactly do you change? drop the fail condition in the configure?
21:21:02 <fuzan> err
21:21:03 <fuzan> not igli
21:21:09 <igli> tf
21:21:10 <fuzan> thoughtpolice:
21:21:57 <thoughtpolice> /bin/sh: ghc -e '' | hexdump: command not found
21:22:02 <thoughtpolice> ?
21:22:07 <thoughtpolice> dunno why /exec got it wrong
21:22:10 <sorear> sorry, no quotes
21:22:11 <thoughtpolice> but it puts out the same thing as before
21:22:41 <igli> ghc isn't installed?
21:22:46 <dmead> type everything after the colon : ghc -e '' | hexdump
21:23:02 <igli> bin/sh: ghc -e '' | hexdump: command not found
21:23:11 <sorear> thoughtpolice: what dmead said
21:23:42 <dmead> is hexdump part of binutils?
21:23:51 <sorear> afaik no.
21:23:54 <igli> which hexdump
21:24:00 <dmead> he might not have it installed then
21:24:09 <dmead> thats what would throw the command not found
21:24:17 <ddarius> xxd?
21:24:23 <dmead> dan@localhost /spare1/wc3_install $ ghc -e '' | poo
21:24:23 <dmead> bash: poo: command not found
21:24:23 <dmead> dan@localhost /spare1/wc3_install $
21:24:25 <sorear> dmead: HE TYPED IT ALL IN QUOTES.
21:24:37 <dmead> oh
21:24:37 <sorear> stefan@stefans:~/cadt/src$ "ghc -e '' | hexdump"
21:24:37 <sorear> -bash: ghc -e '' | hexdump: command not found
21:24:38 <dmead> xD
21:24:38 <igli> no he didn't
21:24:48 <igli> oic
21:24:50 <igli> sorry
21:25:01 <dmead> oh yea ah ah
21:25:03 * igli is tired and apologises
21:25:10 * sorear is tired and apologises
21:25:14 <thoughtpolice> dmead: it's on there, it's just irssi's /exec -o isn't outputting it
21:25:15 <thoughtpolice> dunno why
21:25:16 * dmead farts
21:25:18 <thoughtpolice> but yeah the command runs
21:25:26 <thoughtpolice> it gives the same output as ghci -v0 < /dev/null | hexdump
21:25:35 <sorear> ooh...
21:26:01 <sorear> echo 'main = return ()' > /tmp/Foo.hs
21:26:01 <sorear> runhaskell /tmp/Foo.hs | hexdump
21:26:02 <sorear> ?
21:26:58 <thoughtpolice> same thing
21:27:00 <dons> thoughtpolice: so, hmm,
21:27:01 <dons> #define TOP "/usr/src/hs-plugins
21:27:02 <dons> | ^[[?1034h"
21:27:04 <dons> is odd.
21:27:21 <dons> that is, you'll need to tweak,
21:27:22 <dons> TOP=`echo "Directory.getCurrentDirectory >>= putStrLn.init.tail.show " | ghc --interactive -ignore-dot-ghci -v0`
21:27:35 <dons> so why do we get an escape sequence from that?
21:28:36 <sorear> dons: he gets the same sequence from that, ghc -e, and runhaskell
21:28:41 <dons> weird.
21:28:47 <thoughtpolice> i realize this
21:28:52 <dons> is it the new tab completion in ghci ?
21:28:55 <sorear> echo 'main = return ()' > /tmp/Foo.hs
21:28:55 <sorear> ghc /tmp/Foo.hs -o /tmp/Foo
21:28:55 <sorear> /tmp/Foo | hexdump
21:28:56 <sorear> ?
21:29:07 <sorear> dons: couldn't be, I have 6.6 too wo problems
21:29:26 <thoughtpolice> that actually doesn't output anything
21:29:27 <thoughtpolice> the last one
21:29:34 <sorear> great!
21:29:38 <dcoutts> dons: fixed the rules to be more robust, can now match write/write in any sequence of ops in a do block, not just folding them up from the back.
21:29:47 <dons> mm. nice!
21:29:59 <sorear> dons: would it hurt to compile the haskell getpwd, or even use /bin/pwd?
21:30:02 <dcoutts> so you can now write the natural code and we can match it
21:30:14 <sorear> yay!
21:30:34 <dcoutts> now for sorear's tricks...
21:31:00 <dons> sorear: well, no `pwd` on win32 I think was the problem.
21:31:18 <dons> i'll look at why we added that code.
21:53:19 <dibblego> ?where lambdabot
21:53:20 <lambdabot> I know nothing about lambdabot.
21:53:25 <dibblego> wtf? silly
21:53:30 <ddarius> ?version
21:53:30 <lambdabot> lambdabot 4p517, GHC 6.6 (OpenBSD i386)
21:53:31 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
21:53:31 <dibblego> ?go lambdabot
21:53:32 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
21:53:33 <lambdabot> Title: lambdabot
21:54:54 <fuzan> can I merge a new hs-plugins yet ?:)
21:55:27 <dons> oh. maybe the where database got zapped.
21:55:34 <dons> i've got a backup here somehwere
21:59:49 <LeCamarade> ?src sequence
21:59:50 <lambdabot> sequence ms = foldr k (return []) ms
21:59:50 <lambdabot>     where
21:59:50 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
22:00:25 <foxy-om> @botslap
22:00:25 <lambdabot> Unknown command, try @list
22:00:43 <LeCamarade> lambdabot is back. Bon. Now, I am yet to understand sequence.
22:01:11 <LeCamarade> foxy-om: Try @slap foxy-om
22:01:26 <LeCamarade> Someone, please explain sequence.
22:01:35 <Cale> sequence [] = return []; sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
22:02:02 <Cale> Basically, it takes a list of actions and produces an action that runs each in turn, giving a list of the results.
22:02:15 <LeCamarade> Yeah, I saw the source. I just don't get it. Because ... wait, lemme breathe in then read it again.
22:02:19 <Cale> sequence = foldr (liftM2 (:)) (return [])
22:02:27 <dons> ?src foldr
22:02:27 <lambdabot> foldr k z xs = go xs
22:02:27 <lambdabot>     where go []     = z
22:02:27 <lambdabot>           go (y:ys) = y `k` go ys
22:02:34 <LeCamarade> Oh! The last one is clearer ...
22:02:38 <dons> so foldr is just the loop that glues actions together
22:02:48 <dons> the glue is >>
22:02:52 <Cale> I hate that definition of foldr :)
22:03:06 <dons> so you say :-)
22:03:16 <dons> worker/wrapper transform is good for you though.
22:03:21 <Cale> Basically, what foldr does is replaces list structure with other functions. Here, sequence is replacing the list structure with program structure.
22:03:56 <Cale> foldr f z [] = z; foldr f z (x:xs) = f x (foldr f z xs)
22:04:16 <dons> mm. yes. the list nodes are replaced with semicolons :-) yielding a program
22:04:19 <dons> isn't haskell fun!
22:04:20 <LeCamarade> Okay ...
22:04:57 <ddarius> sequence_ [foo,bar,baz] -> do foo; bar; baz
22:05:05 <dons> LeCamarade: its a slighly strange way to think about it, I suppose. but remember that io actions are just values, that can be strung together with ; (which is just >>)
22:05:22 <dons> and foldr does the stringing, taking a list of actions, yielding a single action, which is the sequencing of the list
22:05:27 <sorear> this isn't ML, ; isn't actually an operator :)
22:05:37 <jcreigh> foldr f 0 [1,2,3] = (f 1 (f 2 (f 3 0)))
22:06:02 <LeCamarade> dons: Okay, lemme try to re-implement sequence and see if it has sunk in well.
22:06:13 <dons> so foldr (>>) (return ()) [getChar,getChar] --->
22:06:18 <LeCamarade> Nice way to spen pre-8:30 office time.
22:06:22 <dons> getChar >> getChar >> return ()
22:06:24 <dons> which is:
22:06:29 <dons> do getChar ; getChar ; return ()
22:06:36 <Cale> > foldr (\x y -> concat ["(f ",show x," ",y,")"]) "z" [1,2,3,4,5]
22:06:37 <lambdabot>  "(f 1 (f 2 (f 3 (f 4 (f 5 z)))))"
22:06:49 <LeCamarade> dons: Hmm ...
22:06:53 <dons> we really need a @reduce plugin
22:07:04 <dons> which takes an expr and reduces it according to some strategy
22:07:06 <sorear> like @run?
22:07:07 <ddarius> That's actually been suggested for years.
22:07:09 <sorear> ooh
22:07:23 <dons> maybe with the new hat
22:07:26 <ddarius> It would very much help in explaining space complexity I'd bet.
22:07:28 <Cale> dons is talking about sequence_ rather than sequence, but the idea is similar
22:07:29 <jcreigh> "some strategy"?
22:07:35 <dons> ddarius: yeah, i think 'hat' could probably do the job.
22:07:41 <Cale> jcreigh: lazy evaluation, strict evaluation, etc.
22:08:26 <sorear> something could be done quite easily, probably starting from a resurrected @lambda.
22:08:30 <dons> that, and just picking which redex to reduce next
22:08:33 <bos> @seen dcoutts
22:08:33 <lambdabot> dcoutts is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard dcoutts speak 21m 49s ago.
22:08:39 <dons> sorear: hmm, but we'd want it for full haskell
22:08:41 <sorear> the question is, how do you make it tolerably quiet
22:08:42 <dons> which is what hat provides
22:08:46 <dons> step-wise haskell eval
22:08:56 <bos> @msg dcoutts yes, the sdist patch is tested and works.
22:08:56 <lambdabot> Not enough privileges
22:08:57 * ddarius was going to add such a feature to @eval.
22:09:01 <sorear> dons: hat is too strict.
22:09:03 <bos> durr.
22:09:03 <ddarius> But probably after rewriting it.
22:09:06 <thoughtpolice> well i'm out.
22:09:07 <thoughtpolice> later
22:09:16 <ddarius>  @tell
22:09:23 <dons> sorear: you sure? ndm seemed to think it was doable?
22:09:30 <sorear> dons: it needs to evel the whole expr before the trace is finished - what if the exp is NT-_|_?
22:10:26 <bos> @tell dcoutts yes, the sdist patch is tested and works.
22:10:27 <lambdabot> Consider it noted.
22:10:34 <bos> ah. whew.
22:10:38 <sorear> @msg bos this is what msg does!
22:10:39 <dons> wouldn't it just produce a bottom exception at the end, sorear ?
22:10:59 <dons> and once we'vee got the trace, we can then present pieces of it
22:11:05 <sorear> dons: _|_ leads a double life.  I don't expect you to solve any halting problem
22:11:12 <bos> sorear: thanks for the illustration :-)
22:11:24 <dons> sorear: if it diverges, we just terminate.
22:11:25 <dons> that's fine.
22:11:44 <dons> same with memory. we know how to eval haskell in a sandbox, remember ;-)
22:12:10 <dons> that is, we solve the halting problem by giving up. :-)
22:12:11 <sorear> dons: I want to see the first reduction.  'Terminated' isn't it.
22:12:30 <dons> shrug. i'm happy to restrict it to non-bottom programs
22:12:42 <dons> doesn't seem like a reason not to provide this option.
22:12:48 <dons> and *you* were suggesting use @lambda!
22:12:48 * sorear knows how to impl lazy hat...
22:12:51 <dons> that's even more restricted.
22:13:01 <sorear> restricted differently.
22:13:13 <dons> yes, to "not haskell"
22:13:14 <sorear> _|_ is far more common than IO, imo
22:13:19 <dons> and since this is #haskell
22:16:06 <ddarius> Perhaps a Haskell->Haskell preprocessor could be made to output the traces (doesn't Hat work something like this?)
22:16:19 <sorear> yes.
22:16:34 <sorear> which is a problem - getting the traces out lazily.
22:16:49 <sorear> lazy hat "works" by interpreting yhc.core
22:16:51 <sorear> hmm.
22:17:08 <sorear> we could haskell->haskell with a abort-after-k
22:17:26 <dons> interpreting a core language would be fine.
22:17:28 * sorear adds "patch hat with step limit?" to ~/TODO
22:17:49 <sorear> except that you only get Core output ;)
22:27:03 <dcoutts> bos: ok, great
22:27:03 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
22:27:32 <bos> dcoutts: thanks!
22:31:39 <dons> sjanssen: i think i might revert the cycle patch, back to the original definition of 'promote'
22:31:56 <dons> using cycle for a week or so, i find i mostly use it as a slow way to do 'promote'
22:35:06 <bos> ooh, augustss started blogging!
22:39:32 <sorear> yeah, just finished replacing 130 lines of perl with 323 lines of haskell :)
22:39:44 <bos> eek!
22:40:05 <bos> i thought we weren't supposed to talk about it when that happens :-)
22:40:15 <LeCamarade> ?src sequence
22:40:16 <lambdabot> sequence ms = foldr k (return []) ms
22:40:16 <lambdabot>     where
22:40:16 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
22:40:31 * LeCamarade asks for some understanding, as he has no neater way to quickly check the defs ...
22:40:44 <sorear> I *may* have added a few features in the process.
22:40:56 <sorear> cadt actually understands c declarators
22:41:04 <sorear> with parsec
22:41:11 <sorear> astgen hacked em up with perl regexes
22:41:49 <Cale> LeCamarade: I recommend looking them up in the Prelude that comes with the Report... http://haskell.org/onlinereport/standard-prelude.html
22:41:50 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
22:42:19 <LeCamarade> Cale: Oui, monsieur.
22:42:30 <sorear> and cadt is more reusable, supports --options, supports selecting what to do ...
22:42:44 <sorear> night all.
22:42:48 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
22:43:04 <Cale> > Prelude.sequence [[1,2,3],[4,5],[6,7,8]]
22:43:06 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
22:43:24 <Cale> (Bad conflicting imports!)
22:43:49 <Cale> > Prelude.sequence [(+2), (*2), (^2)] 10
22:43:51 <lambdabot>  [12,20,100]
22:43:51 * LeCamarade runs, on his Debian, sudo apt-get install haskell98-report --yes --force-yes
22:44:50 <Cale> sequence is pretty versatile :)
22:45:46 <LeCamarade> Cale: It certainly is. It seemed impossible, though, the first time.
22:46:08 <LeCamarade> You know, IO's stickiness, et al.
22:47:42 <Cale> The monad is sticking though :)
22:48:00 <Cale> sequence :: (Monad m) => [m a] -> m [a]
22:49:11 <LeCamarade> Yeah. Now I see why. Tre`s versatile, cette fonction-ci.
23:06:25 <dmwit> Wow, that last sequence example is way cool!
23:06:45 <dmwit> I need to learn more about the (r ->) monad, I think.
23:10:59 <ddarius> dmwit: People don't actually write code like that.
23:17:48 <dmwit> But, but, but...
23:21:03 <Cale> ddarius: sure they do :)
23:21:26 <Cale> I use the (r ->) monad all the time.
23:23:03 * stepcut uses the elite (-> r) monad all the time :p
23:23:16 * dmwit feels like being childish and sticking my tongue out or singing "I told you so" or something like that
23:24:57 <ddarius> stepcut: That would be kind of impressive because (-> r) is contravariant.
23:25:11 <stepcut> ddarius: Indeed, that is what makes it so elite
23:27:38 <fuzan> short of being useful, currying leads to really annoying bugs.
23:27:47 <bos> it does?
23:28:07 <fuzan> generally, not giving enough parameters to a function leads to an error :)
23:28:12 <fuzan> sometimes, it leads to a new function.
23:28:49 <bos> too few parameters always gives a new function. it's just that the type is likely to be wrong for the context.
23:28:49 <dmwit> ?. djinn type curry
23:28:52 <lambdabot> f a b c = a (b, c)
23:29:19 <fuzan> yah, but then you're trying to figure out what's wrong in the next context.
23:29:25 <fuzan> when your error is actually somewhere else.
23:29:43 <dmwit> But... it doesn't type-check, right?
23:29:44 <fuzan> i'm getting good at catching it now, but i've spent many a minutes scratching bodyparts.
23:29:52 <dmwit> heh
23:29:53 <fuzan> yup.
23:30:03 <stepcut> fuzan: adding explicit type signatures can help resolve that
23:30:24 <fuzan> stepcut: yah, that's true
23:30:45 <fuzan> I tend to still add type signature after implementation though :(
23:31:15 <stepcut> I often have ghci tell me the types
23:31:26 <stepcut> and then I just copy and paste
23:32:05 <stepcut> of course, you have to have an idea of what the type ought to be, so you can recognize when you did something funny
23:33:57 <stepcut> the real trouble is listening to the compilers advise when it finds a type error -- it often has really wacky suggestions
23:38:10 <fuzan> true :)
