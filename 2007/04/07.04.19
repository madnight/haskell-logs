00:00:38 <ejt_> I think someone just needs to cobble together the basics, then there'd be lots of people who'd start playing with and improving it
00:00:55 <ivanm> @google haskell "blog engine"
00:00:58 <lambdabot> http://e-scribe.com/news/322
00:00:58 <lambdabot> Title: E-Scribe News : It&#8217;s Haskell
00:01:26 <ivanm> :@
00:01:35 <ivanm> @google "haskell blog engine"
00:01:37 <lambdabot> No Result Found.
00:01:41 <ivanm> :(
00:02:50 <LeCamarade> @haskell haskell blog engine
00:02:51 <lambdabot> Unknown command, try @list
00:02:58 <ivanm> heh
00:03:01 <LeCamarade> @google haskell blog engine
00:03:04 <lambdabot> http://www.ronkes.nl/blog/?2005-08-11-haskellgameengine
00:03:38 <ivanm> thats a game engine, not a blog engine...
00:03:44 <ivanm> @google haskell "blogging engine"
00:03:54 <lambdabot> http://swik.net/User:syndication/tagged/blogging
00:03:54 <lambdabot> Title: Syndication - SWiK
00:05:11 <LeCamarade> ivanm: Yeah.
00:05:23 <LeCamarade> ivanm: Go to the real Google. :oD
00:05:39 <ivanm> LeCamarade: yes sir! :p
00:12:08 <newsham> @farber
00:12:09 <lambdabot> Unknown command, try @list
00:12:13 <newsham> :(
00:13:59 <eumenides> hm the +RTS -hc graph only seems to chronicle the first 200ms?
00:14:44 <ADEpt> eumenides: rather, every 200 ms
00:15:00 <ADEpt> eumenides: it samples every 200 ms, even
00:15:41 <eumenides> ADEpt: oh..
00:16:27 <ADEpt> eumenides: so make your code run longer
00:16:58 <ADEpt> eumenides: or, there was a switch to +RTS to change sampling interval
00:17:02 <robreim> ?seen dons
00:17:02 <lambdabot> dons is in #haskell-soc and #haskell. I last heard dons speak 1h 29m 44s ago.
00:17:13 <eumenides> ADEpt: well, it's interactive
00:17:17 <robreim> ?seen sjanssen
00:17:18 <lambdabot> sjanssen is in #haskell, #gentoo-haskell, #haskell-overflow, #ghc and #haskell-soc. I last heard sjanssen speak 31m 54s ago.
00:17:56 <ejt_> that's a good way to find other haskell channels
00:18:42 <sjanssen> robreim: 'sup?
00:20:11 <robreim> sjanssen, hey. I just added dwm-like tabbing to xmonad (or at least, I gues this is how it works in dwm given their description). Interested?
00:20:36 <sjanssen> tabbing?
00:20:55 <robreim> whoops, tagging sorry :)
00:21:16 <sjanssen> how does the tagging interact with multiple screens?
00:23:22 <robreim> Sorry, phone. I don't know since I don't have multiple screens, but I've been paying attention to how it interacts with screens and I *think* it should be ok. It'd be great if somebody could test it though.
00:24:05 <sjanssen> what happens when I have tag A on one screen, but then try to view that same tag on another screen?
00:24:54 <robreim> as in shift-meta n? It should work the same as it does now - ie just switch screens.
00:25:40 <sjanssen> okay, what happens if a window is tagged with both A and B, and screen one is viewing A and screen two is viewing B?
00:26:43 <robreim> It should appear on both screens
00:26:52 <robreim> All in theory of course :)
00:26:54 <sjanssen> which isn't possible
00:27:00 <robreim> Oh really?
00:27:08 * robreim doesn't know much about xinerama
00:27:40 <robreim> Oh wait, I think I see why.
00:27:46 <sjanssen> xinerama essentially makes several physical screens into one big virtual screen
00:28:00 <robreim> So what is likely to happen if it tries to do that?
00:28:20 <LeCamarade> Does GHC run the same pure function twice, or does she cache the result?
00:28:39 <sjanssen> the window will appear on whichever screen is rendered last, and the first screen will have a hole where that window should have been
00:28:56 <sjanssen> LeCamarade: depends on the circumstances
00:29:15 <LeCamarade> (Essentially, substituting all next calls with the result got). Without a let or a where?
00:29:48 <sjanssen> LeCamarade: generally, you will see result sharing whenever something is bound to a variable (via let, where, top level binding, or as a parameter to a function)
00:30:03 <newsham> ?seen sorear
00:30:04 <lambdabot> I saw sorear leaving #haskell-soc, #darcs, #haskell-overflow, #haskell-blah, #ghc and #haskell 2h 13m 31s ago, and .
00:30:10 <robreim> I see. Hmm, ok I'll look into making windows show on screens only if they aren't already shown on screens to the "left".
00:30:17 <LeCamarade> sjanssen: And not when there is not binding?
00:30:28 <LeCamarade> s/is not/is no/
00:31:31 <sjanssen> robreim: this issue made us decide that there isn't really a sane user interface for the screen system+tagging
00:31:43 <sjanssen> robreim: are you implementing tagging because you miss the feature?
00:32:00 <robreim> sjanssen, nope. Mostly because it looked interesting and I wanted to play with it.
00:32:32 <dcoutts> @yarr!
00:32:32 <lambdabot> Aye
00:32:38 <sjanssen> robreim: alright.  I want to let you know that I'm reluctant to add tagging to xmonad
00:33:23 <sjanssen> LeCamarade: what's your situation, exactly?
00:33:27 <robreim> sjanssen, ok, thanks for the warning. If I do somehow manage to make it work nicely are you likely to want it or would it be too crufty?
00:33:51 <LeCamarade> sjanssen: No, just asking. Nothing serious. Carry on ... not that I may ever need it ...
00:34:59 <sjanssen> robreim: of course "nicely" is a fairly subjective term :)
00:35:17 <boegel> @seen dons
00:35:17 <lambdabot> dons is in #haskell-soc and #haskell. I last heard dons speak 1h 47m 59s ago.
00:35:27 <boegel> damned, did I miss him again?
00:35:41 <boegel> @localtime dons
00:35:43 <lambdabot> Local time for dons is Thu Apr 19 17:34:33 2007
00:37:28 <sjanssen> LeCamarade: say you've got the program "main = do x <- readLn; print (expensiveComputation x); main" -- a loop that repeatedly grabs input, and then prints a result
00:37:37 <robreim> sjanssen, :)  . Ok, I need to go out for a bit. Thanks for your feedback.
00:38:23 <sjanssen> LeCamarade: if the user types the same line twice, ghc will generally have to do the computation twice
00:39:13 <sjanssen> LeCamarade: say you've got another situation "main = do print (expensiveComputation 0); print (expensiveComputation 0)"
00:40:05 <sjanssen> ghc generally doesn't optimize that into "let x = expensiveComputation 0 in do print x; print x".  This optimization is called common subexpression elimination (CSE for short)
00:52:00 <LeCamarade> sjanssen: Okay, so I think GHC should segregate between action guys and plain pure functions (in fact, I had asked about pure functions), and cache the pure ones.
00:53:18 <sjanssen> LeCamarade: a Haskell implementation is certainly allowed to do that sort of caching, but it's tricky
00:53:44 <sjanssen> the cache can eat up a lot of memory, for example
00:53:54 <LeCamarade> sjanssen: I understand, because in practice this kind of idealism fails us ... :oD
00:53:59 <ejt_> LeCamarade: that sort of segregation is already done by the IO monad
00:55:01 <sjanssen> LeCamarade: there's also tension between pointer and (==) equality
00:55:12 <LeCamarade> sjanssen: When I get 'round to not crying when I look at GHC source, I'll try my weird hopes out ... see why they can't work.
01:05:05 <hpaste>  dolio annotated "First pass ExtMonad" with "an illustration of the problem" at http://hpaste.org/1449#a2
01:09:09 <dolio> @tell Philippa I fooled some with ExtMonad, and got one working--a sorted, non-empty list. However, I can't get sorted lists to work with GADTs, and I'm not sure what fundep you wanted me to add. If you feel like trying to solve the problem, you can annotate http://hpaste.org/1449
01:09:10 <lambdabot> Consider it noted.
01:10:16 <sjanssen> dolio: you understand why smap needs to have the Ord b constraint?
01:11:02 <dolio> sjanssen: Yeah. You need to provide it to construct SList b.
01:11:20 <sjanssen> right
01:11:57 <sjanssen> and I think you can trick ghc into accepting cat without the Ord constraint too
01:12:12 <dolio> Same with cat, although, since I'm not GHC's type checker, I can see a way to deduce it from the available information.
01:13:03 <dolio> There may be. I'm not too skilled with fooling with GADTs.
01:21:03 <sjanssen> cat' :: [SList a] -> SList a; cat' (x@(Cons _ _):xs) = x `union` cat' xs -- this works
01:21:34 <sjanssen> but doesn't handle empty lists
01:23:12 <dolio> Ah, yeah. The problem is that you need to provide the context to construct Nil.
01:24:01 <sjanssen> right
01:24:20 <sjanssen> cat' (x@ ~(Cons _ _):xs) = x `union` cat' xs -- surprisingly, this works
01:24:28 <dolio> And it can't use 'Ord (SList a)' from SList (SList a), and the fact that you need 'Ord a' for 'Ord (SList a)' to get 'Ord a' itself.
01:24:30 <sjanssen> but it probably shouldn't
01:25:17 <sjanssen> dolio: things are a bit simpler if you try to write cat :: [SList a] -> SList a instead of SList (SList a) -> SList a
01:25:54 <sjanssen> and flattening to [] is trivial
01:26:24 <dolio> Are they? You still have the same core problem with 'cat [] = Nil'
01:26:51 <dolio> The left hand side doesn't provide the needed context.
01:27:13 <sjanssen> yeah
01:29:32 <dolio> I thought about making 'Nil :: SList a', but that breaks things in other places, because then Nil doesn't provide context.
01:29:33 <sjanssen> hmm, I wonder if this could work if you represented SList as it's catamorphism
01:30:57 <dolio> Well, even if I find a way to do it for SList, the real issue is whether you can do it with Data.Set. I just made up my own GADT because Set isn't one.
01:31:15 <sjanssen> data SList a where Cata :: Ord a => (forall b. (a -> b -> b) -> b -> b)
01:32:08 <dolio> I'll give that a try, though.
01:35:40 <fuzan> ot, but has anyone here played with plan9?
01:36:49 <sjanssen> hmm, cons is tricky with Cata
01:37:12 <dolio> Yeah, I'm not sure how to keep it sorted.
01:42:50 <hpaste>  sjanssen annotated "First pass ExtMonad" with "this works" at http://hpaste.org/1449#a3
01:42:54 <sjanssen> dolio: ^^^
01:43:51 <dolio> Ah, so you can remove the constraint from Nil.
01:43:54 <sjanssen> that forces an Ord constraint on cons, but that's okay I think
01:44:20 <dolio> Ah, perhaps. I suppose it's not a big deal.
01:47:16 <dolio> sjanssen++
01:58:18 * LeCamarade shakes his head at how much he has come to depend on lazy eval, and wishes he had learnt about it earlier.
02:52:30 <ejt_> hi, I'm trying to build a project that I wrote that uses ffi, it builds fine on one machine
02:52:51 <ejt_> but on another it gives me a parse error on the import in 'foreign import ...'
02:53:02 <ejt_> any ideas ?
02:53:10 <ejt_> have I forgotten to install something ?
02:53:27 <mwc> ejt_, what comiler versions?
02:54:01 <ejt_> error is on ghc6.6 (debian etch)
02:55:46 <Lemmih> ejt_: Perhaps you forgot -fffi?
02:57:08 <ejt_> adding -fffi to the ghc-options line in my cabal file has no effect
02:59:46 <ejt_> hmmm, running ghc --make, works fine, its just building with cabal that fails
03:03:55 <Lemmih> ejt_: Try a verbose build.
03:05:12 <pixel> sortBy (comparing (read :: String -> Int)) ["100", "3", "20"]
03:05:33 <roconnor_> @check \a ->  -1 <= (a::Rational) && a <= 0 && 1/2*a^2 <= 1/6 ==> 1/6 < a+1
03:05:35 <lambdabot>  Arguments exhausted after 244 tests.
03:05:37 <pixel> any better way to write the Int constraint?
03:07:53 <ejt_> Lemmih: found it; I needed 'extensions: ForeignFunctionInterface' in the first section of my cabal file.  I must have a different version of cabal at work
03:07:58 <ejt_> thx
03:08:20 <sjanssen> pixel: that's probably the best way
03:09:32 <sjanssen> map snd . sortBy (comparing fst) . map (\x -> (read x :: Int, x)) -- may typically run faster
03:14:45 <pixel> sjanssen: adding it, thanks
03:16:03 <roconnor_> >1/2*(5/6)^2
03:16:07 <roconnor_> > 1/2*(5/6)^2
03:16:08 <lambdabot>  0.34722222222222227
03:16:13 <roconnor_> 1/6
03:17:51 <jward> Anyone have any advice for getting ghc running on FreeBSD running on AMD64?
03:20:28 <noj> I think someone is working on it
03:20:39 <noj> i.e. it's not working at the moment
03:22:06 <jward> Bummer.  I'll go back to working on learning on windows then and maybe take a crack at getting it running later.
03:24:25 <vali> foldr (+) 0 (checkMod [1..1000]) ... this doesn't work. am i passing the 3rd argument incorrectly?
03:25:10 <noj> what's checkMod??
03:25:22 <noj> -?
03:25:30 <vali> noj: it's a function i made
03:25:45 <noj> so, then it's something wrong with that
03:25:58 <vali> oh
03:26:04 <noj> foldr (+) 0 (take 100 [1..1000])  works
03:26:14 <noj> for instance
03:26:50 <Saizan> vali: what's the type of checkMod?
03:26:59 <vali> checkMod :: [Int] -> [Int]
03:27:33 <Saizan> so i should work
03:27:35 <Saizan> *it
03:27:42 <Saizan> what's the error?
03:28:10 <joelr1> good morning
03:28:10 <lambdabot> joelr1: You have 1 new message. '/msg lambdabot @messages' to read it.
03:28:26 <vali> Couldn't match expected type `[Int]' against inferred type `Int' In the expression: foldr (+) 0 (checkMod ([1 .. 1000]))
03:28:45 <Saizan> ?type folder
03:28:47 <lambdabot> Not in scope: `folder'
03:28:49 <Saizan> ?type foldr
03:28:52 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
03:29:32 <campusblo> hello folks i need to write a highlighter for code
03:29:47 <campusblo> i already got it to be able to recognize most things
03:29:50 <xerox> ?where hscolor
03:29:51 <lambdabot> I know nothing about hscolor.
03:30:03 <campusblo> im having problems with comments
03:30:03 <Saizan> > let checkMod = filter (\x -> x `mod 3 == 0 || x `mod` 5 == 0) in foldr (+) 0 (checkMod [1..1000])
03:30:04 <lambdabot>  Parse error
03:30:24 <Saizan> > let checkMod = filter (\x -> (x `mod` 3) == 0 || (x `mod` 5) == 0) in foldr (+) 0 (checkMod [1..1000])
03:30:26 <lambdabot>  234168
03:30:43 <campusblo> i can check for the opencomment. but not the entire comment or the close comments
03:30:48 <campusblo> someone suggested i use stacks
03:30:54 <campusblo> how would i do this?
03:31:41 <procyon112> @seen chessguy
03:31:42 <lambdabot> I saw chessguy leaving #haskell, #darcs, #haskell-soc and #haskell-overflow 13h 1m 46s ago, and .
03:31:52 <vali> Saizan: hmm, why didn't it work the way i did it? i need to put it in let?
03:32:31 <campusblo> anyone here who can help?
03:32:32 <Saizan> vali: your are using this expression inside a larger one, right?
03:32:59 <vali> Saizan: i can paste the code so you can see
03:33:21 <hpaste>  vali pasted "mod" at http://hpaste.org/1461
03:33:54 <Saizan> campusblo, i think they meant something like: you put a marker in the stack on opencomment and pop it on closecomment and then all the chars that you parse while the stack is non-empty are part of the comment
03:34:18 <noj> vali, your type signature for sumPassed is wrong
03:34:30 <noj> [Int] -> Int
03:34:45 <Saizan> no
03:34:52 <Saizan> it's just Int in his case
03:35:00 <pixel> campusblo: http://www.cs.york.ac.uk/fp/darcs/hscolour/
03:35:02 <lambdabot> Title: hscolour
03:35:51 <campusblo> ok thanks
03:35:56 <campusblo> pixel
03:36:48 <Saizan> the stack is nice so you can check that the comments are properly nested
03:37:03 <Saizan> *because
03:41:53 <vali> oh wait, sumPassed should just return Int, not [Int]
03:42:10 <vali> now i only have an error in my putStr, hmm
03:42:51 <Saizan> vali: function application has the highest priority
03:43:04 <vali> Saizan: what does function application mean?
03:43:24 <Saizan> so putStr "Solution: " ++ show sumPassed is aprsed as (putStr "Solution: ") ++ (show sumPassed)   and can't typecheck
03:43:52 <Saizan> vali: simply putting a function in front of its arguments,  f x
03:44:35 <Saizan> you need to write putStr ("Solution: " ++ show sumPassed)
03:45:16 <vali> Saizan: aaah, it's the same error i had with foldr earlier. i see. thank you
03:57:45 <LeCamarade> ?src ==
03:57:45 <lambdabot> x == y = not (x /= y)
03:57:54 <LeCamarade> ?src /=
03:57:55 <lambdabot> x /= y = not (x == y)
03:57:55 <ivanm> ?src /=
03:57:56 <lambdabot> x /= y = not (x == y)
03:57:59 <ivanm> heh
03:58:24 <tphyahoo> can the following be condensed, or the case statement gotten rid of?
03:58:26 <tphyahoo>                     case result of
03:58:26 <tphyahoo>                       Left result -> putStrLn result
03:58:26 <tphyahoo>                       Right result -> putStrLn result
03:58:55 <LeCamarade> So, it just matches patterns, right? Not necessarily the result (which would be _|_).
03:59:14 <tphyahoo> I can't just do putstr result, because result is of type either, and I need a string.
03:59:17 <Lemmih> @type either putStrLn putStrLn
03:59:19 <lambdabot> Either String String -> IO ()
04:00:13 <Lemmih> @type \result -> join either putStrLn result
04:00:16 <lambdabot> Either String String -> IO ()
04:01:10 <procyon112> > fmap putStrLn (Left "Test")
04:01:12 <lambdabot>  Left "Test"
04:01:23 <procyon112> > fmap putStrLn (Right "Test")
04:01:25 <lambdabot>  Right <IO ()>
04:01:38 <ivanm> LeCamarade: for ==, /=?
04:02:09 <ivanm> the Eq class is defined like that, so you just have to provide one of the two when implementing Eq and the other is automatically provided
04:02:13 <LeCamarade> ivanm: Yep.
04:02:23 <ivanm> same with Ord
04:03:32 <ivanm> ?src <
04:03:33 <lambdabot> x <  y = case compare x y of { LT -> True;  _other -> False }
04:03:39 <ivanm> ?src <=
04:03:40 <lambdabot> x <= y = case compare x y of { GT -> False; _other -> True }
04:03:47 <LeCamarade> ?src >
04:03:47 <lambdabot> x >  y = case compare x y of { GT -> True;  _other -> False }
04:03:53 <ivanm> hmmm.... not what I wanted
04:04:13 <LeCamarade> ivanm: Ne'er mind. I get it.
04:04:14 <ivanm> IIRC, for Ord, the define >, >=, == and <
04:04:18 <ivanm> OK
04:04:27 <ivanm> ?src show
04:04:28 <lambdabot> show x = shows x ""
04:04:35 <ivanm> ?src shows
04:04:36 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
04:04:40 <ivanm> heh
04:04:45 <ivanm> ?hoogle show
04:04:46 <lambdabot> Prelude.show :: Show a => a -> String
04:04:47 <lambdabot> Text.Show :: module
04:04:47 <lambdabot> Prelude.Show :: class Show a
04:04:59 <ivanm> ?doc Prelude.Show
04:05:00 <lambdabot> Prelude.Show not available
04:05:05 <ivanm> ?doc Show
04:05:06 <lambdabot> Show not available
04:05:09 <ivanm> ?doc Prelude
04:05:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
04:06:55 <ivanm> what does showsPrec do?
04:07:13 <ivanm> > show (\ x -> x + 1)
04:07:14 <lambdabot>  "<Integer -> Integer>"
04:21:36 <tphyahoo> @type putStrLn
04:21:39 <lambdabot> String -> IO ()
04:36:24 <opqdonut_> what would be the easiest way to blit images into an x window?
04:36:27 <opqdonut_> nothing else
04:36:37 <earthy> hm. icfpcontest.org has dates...
04:36:40 <earthy> how useful. :)
04:36:52 <ivanm> how about prunes? *ducks*
04:37:08 <earthy> hm. prunes. :)
04:37:14 <earthy> *hmmm*.
04:37:44 <opqdonut> hmm HGL
04:40:37 <quicksilver> opqdonut: HGL might be fastest. xmonad contains low level X bindings
04:40:45 <quicksilver> opqdonut: but low level X bindings are pretty painful
04:40:52 <quicksilver> opqdonut: I'd bet you're better off with GL or Gtk
04:41:49 <opqdonut> GL might be
04:42:12 <opqdonut> i have an intellectual problem with gtk :>
04:44:04 <tphyahoo> belated thanks to those who helped me with my Either issue earlier.
04:44:22 <quicksilver> opqdonut: SDL is the obvious answer but I think the SDl binding is a bit bit-rotted
05:07:30 <roconnor_> @docs RealFrac
05:07:31 <lambdabot> RealFrac not available
05:07:35 <roconnor_> @src RealFrac
05:07:35 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
05:07:36 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
05:07:36 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
05:07:41 <roconnor_> @src RealFloat
05:07:42 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
05:08:06 <MarcWeber> If i have some content/ element representing XML (lib HaXml). _How do extract text? I can get the tags/attributes using xtract "query". There is a text parser function. But I don't know how to apply it.
05:08:09 <LeCamarade> @where RealFrac
05:08:10 <lambdabot> I know nothing about realfrac.
05:08:47 <LeCamarade> @docs Haxml
05:08:48 <lambdabot> Haxml not available
05:10:19 <roconnor_> @hoogle Rational
05:10:20 <lambdabot> Prelude.Rational :: type Rational
05:10:20 <lambdabot> Text.PrettyPrint.HughesPJ.rational :: Rational -> Doc
05:10:20 <lambdabot> Language.Haskell.TH.RationalL :: Rational -> Lit
05:10:30 <dons> moin
05:14:33 <dons> interreesting, http://www.wardtek.ca/2007/04/first-haskell-tutorial-finished/
05:14:36 <lambdabot> Title: Jay&#8217;s Realm » Blog Archive » First Haskell Tutorial Finished
05:14:44 <dons> "the random code flying past on #haskell is becoming less alien" :-)
05:14:52 * dons waves to however the author is
05:20:08 <quicksilver> > properFraction 1.45 :: (Int,Float)
05:20:10 <lambdabot>  (1,0.45000005)
05:20:23 <quicksilver> I think 'properFraction' is an odd name for that method
05:28:00 <LoganCapaldo> > properFraction 1.45 :: (Int, Int)
05:28:01 <lambdabot>   add an instance declaration for (RealFrac Int)
05:28:01 <lambdabot>     In the expression: prope...
05:28:16 <LoganCapaldo> > properFraction 1.45 :: (Int, Rational)
05:28:18 <lambdabot>  (1,9%20)
05:28:29 <LoganCapaldo> > properFraction 1.45 :: (Rational, Rational)
05:28:31 <lambdabot>   add an instance declaration for (Integral Rational)
05:28:31 <lambdabot>     In the expression: ...
05:28:44 <LoganCapaldo> oh now it makes sense
05:29:19 * LoganCapaldo thinks its a pretty good name now
05:31:06 <quicksilver> well the point is that the return value isn't the proper fraction
05:31:15 <quicksilver> the return value is the integer part *plus* the proper fraction
05:31:26 <quicksilver> well *plus* meaning *comma* :)
05:36:30 <quicksilver> @localtime dcoutts
05:36:31 <lambdabot> Local time for dcoutts is Thu Apr 19 22:35:20
05:37:01 <Daveman> o_O
05:38:29 <Gu1> as a newbie programmer, would it be easier for me to learn scheme, since there are so many books out there on it (and it's a functional language) then learn haskell?
05:38:59 <ivanm> haskell teaches you more strict stuff from the word go...
05:39:09 * ivanm learnt scheme first, and is now learning haskell
05:39:26 <ivanm> scheme's simpler and more expressive, but haskell forces you to do things properly
05:39:35 <ivanm> so its probably better IMHO to learn haskell first
05:39:38 <Gu1> nod
05:40:16 <LeCamarade> Gu1: So, what languages do you do?
05:40:28 <quicksilver> I would recommend haskell
05:40:45 <quicksilver> the key thing about haskell is not to be scared if some people say scary things about monads
05:40:46 <Gu1> LeCamarade: none right now
05:40:56 <quicksilver> because you don't need to understand that stuff straightaway :)
05:41:19 <LeCamarade> Gu1: Good...
05:41:43 <LeCamarade> Guys, is Haskell good for a first language? I have my reservations.
05:42:00 <LeCamarade> Gu1: If you don't mind, can you tell me how old you are?
05:42:11 <ejt> I think it's great; you probably have an advantage if you haven't been corrupted by an imperative language first
05:42:14 <johnnowak> Gu1: learn scheme first. the language is much simpler so you can focus on fundamentals, and there is a lot of great material out there that makes use of scheme.
05:42:15 * LeCamarade is feeling a little patronising ...
05:42:23 <Gu1> i have "programming in haskell by graham hutton', but even for supposedly for a beginner book, it seems advanced
05:42:30 <johnnowak> Gu1: don't listen to anyone else here. :)
05:42:31 <Gu1> 26
05:42:31 <ndm> Gu1: learn Haskell, Scheme has a deep inner beauty (hidden (by excessive) bracketing)
05:42:39 * ivanm learnt scheme with SICP
05:42:44 <ivanm> its pretty good...
05:42:51 <johnnowak> aye, do SICP and/or HTDP
05:42:56 * ndm also learnt scheme with SICP
05:42:58 <ivanm> HTDP?
05:43:00 <LeCamarade> johnnowak: I think Haskell ignores the basics to concentrate on the advanced, and yet a beginner needs the basics.
05:43:03 <johnnowak> how to design programs
05:43:13 <ivanm> never heard of it before...
05:43:35 <Gu1> what about 'the little schemer'
05:43:40 <LeCamarade> A Haskell programmer needs to know why everything else is obscene - by having once thought it rocked to do it imperatively.
05:43:48 <johnnowak> http://www.htdp.org/ -- full text
05:43:49 <ivanm> Gu1: I tried reading one of those books... couldn't get it
05:43:50 <lambdabot> Title: How to Design Programs
05:44:00 <quicksilver> LeCamarade: I disagree completely with both those statements
05:44:24 <ivanm> *nod*
05:44:26 <Philippa> so do I
05:44:26 <lambdabot> Philippa: You have 1 new message. '/msg lambdabot @messages' to read it.
05:44:34 <LeCamarade> @quote bridge
05:44:35 <xs> Gu1: the little schemer is really good if you stick with it :) i know several people who learnt scheme from it.
05:44:35 <lambdabot> No quotes match. Wrong!  You cheating scum!
05:44:38 <quicksilver> LeCamarade: a haskell programmer only needs to know those things, to overcome his instinctive distaste for the fact it's so different. If he doesn't have that problem because he hasn't been brought up on other languages
05:45:04 <quicksilver> and I have no idea at all why you think 'haskell ignores the basics to concentrate on the advanced'
05:45:24 <Gu1> xs: I understand that it uses a question / answer, socratic method of teaching
05:45:50 <johnnowak> Gu1: i like the little schemer a lot
05:45:59 <LeCamarade> Okay, actually programming IO becomes better if you start out in a monad. You try the imperative later, and you write it better than old-timers.
05:46:04 <ivanm> xs: I read the reasoned schemer... didn't get most of the stuff they were talking about
05:46:11 <johnnowak> quicksilver: the type system in haskell adds a lot of conceptual overhead that isn't there with scheme
05:46:11 * LeCamarade grabs his chin, ponders.
05:46:18 <quicksilver> johnnowak: that, I agree with
05:46:27 <ivanm> but its a _good_ overhead
05:46:28 <Philippa> LeCamarade: I suspect you treat things like IO as part of "the basics"?
05:46:30 <xs> ivanm: that's harder to get than the little schemer. i didn't find it too bad (but i only read the first few chapters.)
05:46:34 <ivanm> makes you think more clearly about what you're doing
05:46:36 <Gu1> i'm a tennis pro by trade... i know that you have to learn the basics before attempting to hit a drop volley
05:46:38 <quicksilver> johnnowak: although scheme has a type system too
05:46:40 <johnnowak> quicksilver: and when you're learning, i think reducing overhead should go before reducing bugs in big programs
05:46:42 <ivanm> xs: fair enough
05:46:46 <joelr1> how do you write a pattern guard for an argument that can take several values, e.g. data X = X | Y | Z?
05:46:47 <johnnowak> quicksilver: aye, but it is much simpler
05:46:47 <quicksilver> johnnowak: it's just that it isn't static
05:47:04 <nominolo> @go $4500 in EUR
05:47:05 <lambdabot> US$ 4,500 = 3,322.25914 Euros
05:47:10 <quicksilver> joelr1: you can't, directly
05:47:11 <Philippa> joelr1: you don't, unless you can use a wildcard
05:47:14 <Philippa> sucks, huh?
05:47:22 <eumenides> scheme is ugly, and not fun
05:47:27 <quicksilver> joelr1: you can write foo X = r ; foo Y = r; where r = ....
05:47:48 <joelr1> quicksilver: that's what i don't want to do. i want a guard ;-)
05:47:58 <LeCamarade> Philippa: No, but a program of a beginner must do something visible first.
05:48:06 <quicksilver> LeCamarade: so learn to program in a REPL
05:48:09 <quicksilver> > 1 + 2
05:48:10 <LeCamarade> I think Haskell would be good, alright.
05:48:11 <lambdabot>  3
05:48:11 <joelr1> Philippa: what do you mean?
05:48:15 <quicksilver> that's a program with a visible result
05:48:26 <LeCamarade> quicksilver: Yeah. Fine solution. Very fine solution.
05:48:35 <Philippa> joelr1: if the case works on all constructors, you can do foo | guard
05:48:47 <joelr1> i have a very long Op data type where 1/2 the ops are numeric and the rest boolean. i want to infer the type using guards
05:48:50 <Philippa> or even if it's just all constructors not handled by previous cases
05:48:52 <johnnowak> Gu1: Start with How to Design Programs and Scheme. It's a very good introduction to how to program.
05:48:56 <Philippa> yeah, that's not going to work easily
05:49:17 <LeCamarade> Gu1: What system do you have there?
05:49:23 <Gu1> xp pro
05:49:24 <joelr1> Philippa: so then i can just do X | Y = ..., otherwise =
05:49:26 <joelr1> ok
05:49:35 <LeCamarade> Gu1: Good.
05:49:36 <Gu1> eventually i intend on getting a mac book pro
05:49:48 <LeCamarade> Gu1: Even better.
05:49:51 <Philippa> the good news is that once you have an isBoolean predicate and so forth you can use that in guards in future
05:49:57 <Philippa> so at least you only deal with this pain once
05:49:58 <Gu1> i appreciate the advice
05:50:02 <joelr1> Philippa: thanks
05:50:06 * quicksilver agrees with Philippa 
05:50:09 <quicksilver> that's the way I'd do it
05:50:19 <Gu1> i hope if i read the code you guys spout off in here, eventually i will learn through osmosis
05:50:33 <johnnowak> Gu1: unlikely. :)
05:50:42 <Philippa> Gu1: it helps, but you need other sources of info
05:50:57 <Philippa> a lot of the code thrown about in here is doing stuff that most coders think is "weird voodoo shit"
05:51:09 <Philippa> it isn't, but it /is/ stuff that takes a little background
05:51:10 <Gu1> i've noticed
05:51:11 <quicksilver> and some of it is deliberate weird for the sake of weirdness
05:51:20 <quicksilver> there is good signal amongst the noise though. Sometimes.
05:51:21 <LeCamarade> Gu1: You know that you should do a nifty project in order to get the basics.
05:51:37 <LeCamarade> quicksilver: Very right on the weirdness. :oD
05:51:39 <Philippa> writing interpreters is common and compilers are at least somewhat regularly undertaken in here
05:51:40 <johnnowak> aye, and looking at 2-3 liners doesn't teach much about how to structure a program.
05:51:52 <Philippa> mmm. Pointless style. I'd rather work in ANF myself...
05:52:28 <quicksilver> johnnowak: how to structure a program is a higher level piece of knowledge than how to program at all, though :)
05:52:50 <LeCamarade> Gu1: Understand that you don't have to understand much for a long time.
05:53:16 <joelr1> Philippa: what's the right syntax, again? this doesn't seem to work: let x op | op Minus | Plus = TyNum | otherwise = TyBool
05:53:22 <LeCamarade> Gu1: For starters, just writing replacements for the standard functions should suffice.
05:53:30 <LeCamarade> They are easy.
05:53:31 <Philippa> joelr1: you'll need to use an = per case
05:53:31 <joelr1> i remember how to do this in ocaml but now haskell :-(
05:53:34 <Gu1> "I learned this, at least, by my experiment; that if one advances confidently in the direction of his dreams, and endeavors to live a life which he has imagined [as opposed to principles and methods observed], he will meet with a success in uncommon hours.
05:53:35 <johnnowak> quicksilver: I mean structuring on the local level as well. What should a function do, etc. It's one thing I think HtDP does very well. You learn how to tackle problems right away.
05:53:38 <LeCamarade> And very educative.
05:53:40 <Philippa> the | just separates out guards from the patterns they're attached to
05:54:11 <joelr1> Philippa: that's what i was driving at, is there a way to bunch the values or do i need to put them in a list and resort to looking up in that?
05:54:15 <Philippa> anyway, 'mafraid I can't stay and chat much - I've got to get out of the house shortly
05:54:27 <Philippa> joelr1: you need to either put them in a list or write the predicate longhand
05:54:38 <joelr1> Philippa: ouch! thanks, though
05:54:44 <Philippa> longhand's not too bad so long as you at least keep the bools with each other
05:54:57 <Philippa> not pleasant, but at least you can copy'n'paste
05:56:18 <Philippa> most of my interpreters have a Primitive type but treat primitive operations much the same as non-primitive while typechecking etc etc - they go in an environment and it's just the actual values that look a little different
05:56:22 <Philippa> this is why!
05:59:36 <Gu1> wow, HTDP looks like it will be a really good book... and best of all i can read / print it out for free
06:00:15 <johnnowak> aye
06:01:34 <johnnowak> Gu1: it makes use of DrScheme (which has windows binaries), which makes things easy... even has various learning levels to catch common mistakes until you get better, etc. beats dealing with a terminal and ghci.
06:02:32 <Gu1> fantastic
06:03:10 <LeCamarade> > 1 + 2
06:03:12 <lambdabot>  3
06:03:31 <LeCamarade> > let double = * 2 in double 2
06:03:32 <lambdabot>  Parse error
06:03:46 <LeCamarade> > let double = (* 2) in double 2
06:03:48 <lambdabot>  4
06:04:46 <LeCamarade> > let len x = if x == [] then 0 else 1 + len (tail x) in len [1 .. 10]
06:04:48 <lambdabot>  10
06:05:22 <LeCamarade> Gu1: I think I see, after all, that Haskell is good enough for the programs you'll want to start out with. :oD
06:05:40 <xerox> GHC 6.6 does ship Data.Binary?
06:06:43 <bringert> xerox: no, GHC 6.6 predates Data.Binary
06:06:46 <ekidd> Yay!
06:06:53 <johnnowak> (let ((double (lambda (n) (* n 2)))) (double 2))
06:06:57 <johnnowak> :)
06:06:58 * ekidd just finished the graphics for another probability monad post
06:07:47 <xerox> bringert, I see. I remember doing :m + Data.Binary just after having installed .debs, no darcs sources, but that must be wrong.
06:08:26 <joelr1> ndm: thanks for the tip
06:10:43 <ndm> joelr1: no probs
06:11:05 <ndm> although feeling a bit foolish that i misspelt derive :)
06:15:57 <nominolo> :t noMsg
06:16:00 <lambdabot> forall a. (Error a) => a
06:20:58 <quicksilver> ndm: make a package of Whirling.Derve.Ish and cover your tracks!
06:21:21 <ndm> quicksilver: too many projects already :)
06:25:30 <quicksilver> ndm: w.r.t. your reply, yes I knew that derive could do it. I was mainly pointing out (a) how close Show gets us and (b) that something like this might be a candidate for a built-in compiler derivation
06:25:54 <quicksilver> ndm: this kind of 'gentle' metaprogramming is a fairly frequent thing
06:26:04 <quicksilver> ndm: on the other hand, it might be said to encourage poor programming style :)
06:27:18 <ndm> quicksilver: yeah, its not necessarily the best idea - i was just showing how you can do it with Enum, if you bend Enum ever so slightly :)
06:27:26 <ndm> maybe a candidate for Haskell'
06:27:43 <pitecus> I get this when trying to build with Cabal:     Could not find module `Text.Regex':
06:27:43 <pitecus>       it is a member of package regex-compat-0.71, which is hidden
06:27:52 <pitecus> Any idea how to fix it?
06:28:51 <audreyt> ghc-pkg expose regex-compat
06:29:58 <quicksilver> ndm: if it is an enum you don't need to use fromEnum, surely, the .. syntax works directly with enums
06:30:04 <quicksilver> ndm: (just as in my first example)
06:30:26 <Saizan> pitecus, add regex-compat to build-depends in the cabal file
06:31:06 <pitecus> Saizan, I did this: Build-depends:  base, haskell98, parsec, regex-compat
06:31:11 <pitecus> but i still get the same error
06:31:22 <Saizan> have rerun configure?
06:32:02 <ndm> quicksilver: you may well be right, i figured i was being too verbose in there somewhere
06:32:18 <ndm> quicksilver: feel free to post a refined version of mine, i think its necessary :)
06:32:59 <pitecus> Saizan, Thanks rerunning configure did it
06:40:18 <nominolo> will multi-param type-classes be part of Haskell' ?
06:41:22 <quicksilver> yes, I believe they will
06:41:26 <quicksilver> but probably not fundeps
06:41:45 <nominolo> oh
06:41:59 <nominolo> despite some important libs using it?
06:46:49 <quicksilver> haskell98 doesn't contain MPTCs
06:46:54 <quicksilver> and that doesn't stop the important libs using them
06:47:05 <quicksilver> haskell' will contain (almost) strictly more than haskell98
06:47:10 <quicksilver> so it's hardly making things worse :P
06:53:57 <nominolo> ok, so i guess, MTCS + fundeps is not considered "well-enough undestood"
06:58:37 <earthy> nominolo: yup
07:09:29 <quicksilver> nominolo: well it's known that something is needed to make mptcs useful
07:09:39 <quicksilver> nominolo: but one school of thought is that ATs are better than fundeps
07:09:52 <quicksilver> nominolo: and my reading is that the AT camp is likely to hold sway in haskell'
07:10:15 <nominolo> ok
07:10:31 <nominolo> well, i was building a sort of error-transformer typeclass
07:10:49 <nominolo> but i found a simpler scheme, for now
07:10:55 <nominolo> it's actually nicer
07:11:30 <nominolo> though, if one were to generalize this, it might require multi-param type-classes
07:12:04 <dolio> ATs aren't widely implemented enough to get in, though, no? Although, that depends on when h' gets settled on.
07:12:14 <nominolo> otoh, MonadError already requires MPTCs and fundeps ...
07:13:02 <ndm> quicksilver: i think thats unlikely, FD's are much more likely to go in
07:13:15 <ndm> quicksilver: unless H' gets held up a few years, in which case things may be different
07:14:09 <ndm> personally I think AT's are nicer than FD's, but H' isn't about developing new things - its about standardising existing things
07:14:09 <ndm> although Haskell originally had the same goal, and completely changed, so perhaps
07:15:56 <quicksilver> ndm: yes you could be right, but ATs seem to have the strong support of the GHC team
07:15:59 <ndm> dolio: ATs aren't implemented _at all_!
07:16:07 <quicksilver> ndm: and the GHC team are not without influence on H'...
07:16:10 <dolio> ndm: Precisely. :)
07:16:21 <ndm> quicksilver: indeed, but you can't standardise on something that doesn't exist :)
07:16:39 <quicksilver> I thought there was a partial implementation of ATs in GHC? at least head?
07:16:41 <ndm> (well you can, but its a really silly idea)
07:16:55 <ndm> quicksilver: partial unreleased implementation is not an implementation
07:17:45 <quicksilver> http://hackage.haskell.org/trac/haskell-prime/wiki/MultiParamTypeClassesDilemma
07:17:48 <lambdabot> Title: MultiParamTypeClassesDilemma - Haskell Prime - Trac, http://tinyurl.com/2ff543
07:19:06 <dolio> Yeah, it doesn't do associated type synonyms yet, which is, in some ways, the part that actually replaces functional dependencies.
07:19:48 <nominolo> hm, how would you name a class that states "Param a can be converted into something of type T" ?
07:20:03 <nominolo> where T is fixed
07:20:10 <quicksilver> T-able
07:20:27 <quicksilver> T-like
07:20:30 <nominolo> hm, T = HTTPError
07:20:36 <nominolo> in my case
07:21:41 <nominolo> can a type class have the same name as a type?
07:21:45 * nominolo tries
07:21:51 <twanvl> yes
07:22:20 <dolio> That could be confusing, though.
07:22:47 <quicksilver> Ideally, all programs should use a given Uppercase identifier as a type, a class, and a module
07:22:59 <quicksilver> preferably to refer to totally different things
07:23:11 <dolio> :)
07:23:18 <quicksilver> you get bonus points for unrelated modules Foo, Foo.Foo and Foo.Foo.Foo
07:23:22 <nominolo> ok, it's not possible
07:23:27 <nominolo> at least not in ghci
07:23:52 <int-e> quicksilver: each providing a Foo type and a Foo data constructor for some different type?
07:23:59 <quicksilver> int-e: yes :)
07:24:10 <nominolo> but I think I call the Typeclass HTTPError and the datatype HTTPErrorType or sth.
07:25:19 <quicksilver> @quote angel
07:25:20 <lambdabot> ghc says: Urk! Inventing strangely-kinded void TyCon: :t{tc a5gUj} (* -> *) -> * -> *
07:25:21 <dolio> You could expand HTTP on one of them. Verbose is good, right?
07:25:26 <quicksilver> @quote angle
07:25:26 <lambdabot> Andrzej says: (on Simon Marlow) So YOU are the GOD's angle with the sword!
07:25:53 <quicksilver> I like Andrzej comparing Simon M to Gabriel. But I think Dan Weston may have topped that by comparing Simon PJ to Dumbledore
07:26:29 <nominolo> dolio: what do you mean?
07:26:50 <dolio> :) I meant 'HyperTextTransferProtocolError'
07:27:38 <nominolo> hm ...
07:27:41 <nominolo> no!
07:27:43 <LeCamarade> dolio: HyoertextTransferProtocolV1_1_Type_HeyWeAllLikeVerbose_Right
07:27:43 <nominolo> ;)
07:27:58 <LeCamarade> Wait, is there a limit to identifier length?
07:28:17 <dolio> LeCamarade: Is that the kind of Java code you run into at work? :)
07:28:41 <LeCamarade> dolio: It's worse with Java. And normal.
07:29:15 <LeCamarade> > take 10 $ repeat "Java"
07:29:15 <dolio> How'd your haskell vs. C thing turn out, by the way?
07:29:25 <lambdabot>  ["Java","Java","Java","Java","Java","Java","Java","Java","Java","Java"]
07:29:45 <LeCamarade> > concat $ take 10 $ repeat "Java"
07:29:47 <lambdabot>  "JavaJavaJavaJavaJavaJavaJavaJavaJavaJava"
07:30:30 <LeCamarade> dolio: Still reading the spec. Waiting for the cards to roll in, so I can get dirty. Of course Haskell has the speed advantage, and speed is the benchmark.
07:31:02 <LeCamarade> I mean coding speed.
07:31:11 <LeCamarade> LoD
07:31:18 <dolio> Well, good luck, then.
07:31:59 * LeCamarade swallows hard. He's been toying with a small algorithm, and is stuck with a cryptic message.
07:33:02 <dolio> I suppose it may be to your advantage to be working in a language where you don't have to rewrite linked lists for every program. :)
07:33:37 <quicksilver> LeCamarade: concat . take 10 . repeat $ "Java"
07:34:41 <LeCamarade> quicksilver: Yeah. Both work. I use yours more often.
07:37:55 <MarcWeber> How do I run the HaXml parser 'text' on a Content node ?
07:43:07 <myname> Hello world ! Is there a nice Haskell editor under Linux, because hugs[98] is weird, and ghci is just an interpreter.
07:43:28 <quicksilver> emacs
07:45:06 <myname> quicksilver, I donwloaded haskell-mode for emacs yet how to use it ???
07:45:50 <Saizan> ?where haskell-mode
07:45:51 <lambdabot> http://haskell.org/haskellwiki/Haskell_mode_for_Emacs
07:46:14 <myname> cool, thanks =)
07:46:24 <Saizan> minmal setup :)
07:46:26 <hpaste>  quicksilver pasted "my emacs-haskell mode config" at http://hpaste.org/1462
07:46:36 <quicksilver> myname: check that paste for what I did
07:47:15 <dino-> I'm working with dates using System.Time.CalendarTime ..
07:47:29 <dino-> When I construct one, I'm only interested in y m d h m s and none of the rest of the fields.
07:47:52 <dino-> I get compiler warnings about fields like tz, wday etc.. not initialised.
07:48:04 <dino-> Is the "right" way to deal with that just ignoring the warnings?
07:48:57 <quicksilver> I doubt it
07:49:05 <dino-> I guess I could just make something up, but it seems weird to arbitrarily set something like ctYDay to 1 even if this date is not, in fact, Jauary 1st.
07:49:09 <dino-> January
07:49:22 <quicksilver> if you intend to do anything with it then you need to set those correctly, I suspect
07:49:26 <dino-> Or set ctWDay to Monday every time, etc..
07:49:53 <dino-> Hm. Maybe System.Time isn't the right module for this job then. I don't really have easy access to what year day or week day this is.
07:50:53 <quicksilver> possibly not. what feature of the module were you interested in?
07:51:24 <shapr> Good morning #haskell!
07:51:24 <dino-> Put y m d h m s in, be able to compare dates for sorting purposes. Format them into strings like "yyyymmdd"
07:51:27 <dino-> That's it.
07:51:41 <dcnstrct> what font do you guys like to program with ? and anti-aliased or no ?
07:51:45 <dino-> I'll never care about TZ, weekday, etc..
07:51:48 <quicksilver> dino-: Data.Time.* might be more sane?
07:53:08 <dino-> quicksilver: Hm. To start with I have a string like "2007:04:19 10:45:53", which I'm parsing with parsec into those 6 items.
07:53:28 <dino-> So I went for CalendarTime because of its ability to construct with CalendarTime { ctYear = ... }
07:53:44 <shapr> I would like to be able to add and subtract dates.
07:53:53 <shapr> And I'd like to be able to specify just part of the dates as well.
07:54:46 <dino-> System.Time seems to be able to do all this stuff in terms of diffing dates.
07:54:46 <quicksilver> dino-: pretty sure you want Data.Time.*
07:55:01 <quicksilver> dino-: I think System.Time is deprecated and, indeed, incomplete by design
07:55:07 <nominolo> myname: you can also try out shim
07:55:19 <nominolo> ?where shim
07:55:20 <lambdabot> http://shim.haskellco.de/trac/
07:55:49 <nominolo> it requires haskell-mode, though
07:56:05 <nominolo> ?where hoogle.el
07:56:06 <lambdabot> I know nothing about hoogle.el.
07:56:29 <nominolo> http://clemens.endorphin.org/patches/hoogle.el
07:57:54 <dino-> :/  I don't see any way to get 6 ints repesenting y, m, d...  into that Data.Time
07:58:09 <dino-> Would deprecation show up in the Haddock docs for System.Time?
07:58:39 <quicksilver> dino-: LocalTime (fromGregorian y m d) (TimeOfDay h m s)
07:59:27 <quicksilver> dino-: I'm not sure what the official status is, but System.Time is clearly broken since it provides no useful construction functions
08:00:02 <dino-> quicksilver: Ok. Thanks.
08:01:10 <myname> Ok, nice. Thanks for all
08:02:29 <dino-> quicksilver: I wasn't readily seeing the relationship between these Data.Time.* modules at first. The way they interface with the types like Day, TimeOfDay.
08:02:43 <dozer> @hoogle ++
08:02:44 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
08:02:44 <lambdabot> Control.Arrow.(+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
08:02:44 <lambdabot> Text.Html.(+++) :: (HTML a, HTML b) => a -> b -> Html
08:02:48 <dino-> But I see it n ow.
08:03:25 <quicksilver> dino-: yes, the docs are pretty terse :)
08:04:21 <ndm> @seen Igloo
08:04:21 <lambdabot> Igloo is in #darcs, #ghc and #haskell. I last heard Igloo speak 30m 59s ago.
08:05:18 <dozer> is there a how-to-use-lambdabot doc somewhere?
08:05:28 <quicksilver> @help commands
08:05:29 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:05:34 <quicksilver> @help list
08:05:34 <lambdabot> list [module|command]
08:05:35 <lambdabot> show all commands or command for [module]. http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
08:05:42 <quicksilver> you can check there
08:05:49 <dozer> sweet
08:30:59 <beelsebob> argh, the name for the property I want has popped out my head...
08:31:12 <beelsebob> what's it called when no matter what evaluation order you take you get the same result
08:31:23 <psnl> church-rosser
08:31:28 <beelsebob> ah, yes
08:31:30 <beelsebob> thanks
08:33:56 * beelsebob just borkened it
08:33:56 <beelsebob> :(
08:34:32 <beelsebob> In fact... in a particular moment of stupidity I wrote in my notes that you can have church-rosser as long as you evaluate it in this order
08:34:34 <beelsebob> no... wait
08:34:35 <quicksilver> or 'strongly normalising' IIRC
08:34:36 <beelsebob> :/
08:46:50 <nominolo> hm, does anyone know if Network.HTTP supports chunked data transfers?
08:57:43 <shapr> GHCi should qualify types in error messages if they have the same name but are in different modules
08:57:55 <shapr> Today's error - Couldn't match expected type `Request' \n against inferred type `Request'
08:58:49 <joelr1> ndm: ping
09:00:30 <ndm> joelr1: pong
09:00:41 <joelr1> ndm: question re: SYB or derive, one sec
09:00:44 <hpaste>  joelr1 pasted "Candidate for derivation" at http://hpaste.org/1463
09:01:02 <fasta> Is there a data structure with O(1) head, O(1) tail, O(log n) concatenation, O(log n) split, O(log n) reversal, O(log n) insertion and O(log n) deletion?
09:01:22 <joelr1> ndm: i'm trying to figure out if i could do the paste with syb
09:01:45 <ndm> joelr1: my initial thoughts are no, but its possible - type based translation is not something that these kind of things are good at
09:01:46 <joelr1> ndm: is it possible to use the same constructor name in a different module ?
09:02:02 <ndm> joelr1: perhaps what you really want is a fold?
09:02:05 <quicksilver> fasta: sounds like a variant of a tree could have those properties
09:02:14 <joelr1> ndm: fold?
09:02:16 <fasta> quicksilver: I already know it exists :)
09:02:33 <ndm> joelr1: a fold takes a function for each constructor, and applies them
09:02:44 <joelr1> ndm: what i want is to apply the constructor of the same name in a different module... unless i want to handle a certain constructor specially
09:02:46 <fasta> quicksilver: I also have an idea of its structure.
09:03:14 <ndm> joelr1: but a constructor in a different module is a very very special case, if it was a fold you could make that a general one, and have a morph just be a variant on a fold
09:03:28 <ndm> joelr1: give me 5 minutes, just going to paper guess what would work..
09:03:34 <joelr1> ndm: thanks!
09:03:35 <fasta> quicksilver: I assume there is no functional implementation possible, though.
09:04:02 <quicksilver> fasta: I don't see why not; I think it's just a tree but using 'sequences' at each level instead of lists
09:04:10 <ndm> joelr1: why monadic? any particular reason, or just good future proofing?
09:04:12 <quicksilver> fasta: and keeping track of first-and-last pointers
09:04:19 <joelr1> ndm: the special case (in my case) would be where the series of actions are different from just applying the constructor of the same name
09:04:35 <joelr1> ndm: very good and specific reason: updating the state :D
09:04:36 <joelr1> ndm: it's a state monad
09:04:38 <fasta> quicksilver: how do you keep track of the first and last pointers? With a double zipper (wild guess)?
09:04:53 <joelr1> ndm: i'm translating ast1 into ast2 and imagine that ast2 is object-based
09:05:23 <ndm> joelr1: cool, will incorporate that thoughts
09:05:24 <joelr1> ndm: so a list of statements becomes an object (state) with fields, methods, etc. the monad updates the object sometimes
09:06:02 <hpaste>  joelr1 annotated "Candidate for derivation" with "special processing" at http://hpaste.org/1463#a1
09:06:13 <joelr1> ndm: this is special processing ^^^^
09:06:31 <joelr1> ndm: notice how i'm not applying the constructor of the same name but in a different module
09:06:39 <quicksilver> fasta: I can't pm you at the moment since I'm not authenticated
09:06:49 <ndm> joelr1: yep
09:06:57 <quicksilver> fasta: in any case, I don't have time to think it through properly but maybe Edison has something?
09:07:00 <fasta> quicksilver: ok, go to #foobarxor
09:07:16 <qebab> are there any sources with code samples for haskell? I'd really like to see if I can understand them before I buy a book
09:08:12 <shapr> dons: Hey, we'd like to nominate Lazy.toStrict and BS.toLazy for inclusion
09:08:12 <ndm> @google graham hutton programming haskell
09:08:20 <lambdabot> http://www.cs.nott.ac.uk/~gmh/book.html
09:08:20 <lambdabot> Title: Programming in Haskell
09:08:22 <fasta> qebab: http://www.google.com/codesearch?q=lang%3Ahaskell&hl=en&btnG=Search+Code
09:08:27 <qebab> thanks
09:08:32 <ndm> qebab: that book website has code samples as well
09:08:34 <lambdabot> Title: lang:haskell - Google Code Search, http://tinyurl.com/yrfztz
09:08:49 <qebab> thanks guys :)
09:08:52 <xerox> anybody knows what's the most direct way to get a (square) image loaded in a Gtk2Hs window?
09:08:54 <shapr> @tell dons BS.Lazy.toStrict and BS.toLazy would be functions we'd use often in HAppS. We're writing our own versions of those, want a patch?
09:08:55 <lambdabot> Consider it noted.
09:08:56 <fasta> quicksilver: no, Edison doesn't have anything appropriate.
09:09:21 <fasta> quicksilver: the problem with data structures is that missing one operation makes them useless...
09:12:11 <ndm> joelr1: its easy enough to do the class, but its definately not suitable for inclusion in Derive - its way too specific
09:12:33 <joelr1> ndm: i just posted a message to cafe. please feel free to reply with your thoughts to stimulate a discussion.
09:12:40 <ndm> joelr1: i'd recommend emailing the list asking for a more general solution, i'm sure there is one out there
09:12:54 <joelr1> ndm: what do you mean by inclusion in derive?
09:12:56 <ndm> joelr1: will do :)
09:13:06 <joelr1> ndm: something that you would try to guess?
09:13:18 <ndm> joelr1: its way too specific to add Morph as a built in derivation
09:13:27 <joelr1> ndm: how would you do the class to handle special cases?
09:13:30 <ndm> joelr1: but of course you can have it in your library, and use it with derive just as easily
09:13:51 <ndm> joelr1: you just derive each one you want, and ignore a load of them, and write those by hand
09:14:25 <joelr1> ndm: i have code from sorear that does sort of this thing for arbitraries but i'm not sure how i can 1) refer to a constructor of the same name in a different module and 2) how i can special-case certain constructors while scrapping the boilerplate of others
09:14:49 <ndm> joelr1: just generate the code, then modify it by hand after
09:14:52 <joelr1> ndm: but i don't believe ghc lets me instantiate twice, does it?
09:15:00 <joelr1> ndm: oh, no! horror!
09:15:03 <ndm> joelr1: one instance, just modify it after
09:15:10 <joelr1> horror! horror!
09:15:20 <ndm> joelr1: yeah, the way you suggest, you don't have a chance of doing it automatically in any obvious way that i can see
09:15:28 <joelr1> ndm: it would have been cool if i could instantiate twice and "override" the second time :D
09:15:52 <ndm> joelr1: ask Oleg, he's the person for that kind of type-class hackery, but i think its impossible
09:16:02 <joelr1> ndm: yeah, probably
09:16:04 <joelr1> oh, well
09:16:28 <ndm> class MorphDefault where ...
09:16:29 <joelr1> ndm: i thought SYB could be a candidate. if there's a way to refer to a constructor in another module
09:16:34 <ndm> class Morph where ...
09:16:50 <ndm> then do the special cases in Morph, and call MorphDefault for the rest
09:16:54 <ndm> no special cases, i think
09:17:04 <ndm> joelr1: the issue isn't another module, its another data type
09:17:25 <joelr1> ndm: yeah, i but we are dealing with typeable, etc. right? assume we are
09:17:46 <joelr1> ndm: so the "default" case is one where the constructor name is the same and the # of arguments to the contructor is the same
09:17:59 <joelr1> ndm: and the values are produced by applying morph to arguments
09:20:00 <ndm> joelr1: i don't think thats necessary an issue - see what people say on the list,  it looks like there should be a simpler way to do it
09:20:31 <joelr1> ndm: right. thanks!
09:21:00 <gour> beschmi: hi, what's the prospect of getting vim support in shim?
09:23:47 <joelr1> ndm: just sent a clarification to the list. back to my drawing board :)
09:24:08 <joelr1> ndm: did you see the entry on easylanguage (trading language) on LtU?
09:25:03 <ndm> joelr1: when?
09:25:35 <joelr1> ndm: very recently. let me look it up for you...
09:25:46 <joelr1> @google EasyLanguage Lambda the Ultimate
09:25:49 <lambdabot> http://lambda-the-ultimate.org/node/2201
09:25:49 <lambdabot> Title: Easylanguage: domain specific language for trading stocks | Lambda the Ultimate
09:25:58 <joelr1> ndm: ha! that was easy
09:26:07 <joelr1> ndm: that's the language i'm translating into c#
09:26:49 <ndm> joelr1: i don't read the forums, just hte main page - looks fun
09:27:52 <joelr1> ndm: it's a pain in the rear, sort of, but much fun
09:29:05 <ndm> that language looks horrible, from a computer science point of view
09:31:14 <gour> @seen beschmi
09:31:14 <lambdabot> beschmi is in #haskell and #darcs. I don't know when beschmi last spoke.
09:32:36 <quicksilver> intriguing choice of name 'easylanguage'
09:32:47 <quicksilver> if I was trying to protect my job in options trading automation
09:32:53 <quicksilver> I'd be more likely to call it bloodyhardlanguage
09:38:03 <dozer> @hoogle [[a]]->[a]
09:38:04 <lambdabot> Prelude.concat :: [[a]] -> [a]
09:39:44 <mdmkolbe-work> what is the lambdabot command for converting from a type to code that has that type?
09:39:47 <Saizan> ?where gtk2hs
09:39:48 <lambdabot> http://haskell.org/gtk2hs/
09:40:24 <quicksilver> mdmkolbe-work: djinn
09:40:33 <quicksilver> @djinn (a,b) -> a
09:40:34 <lambdabot> f (a, _) = a
09:40:36 <mdmkolbe-work> thx
09:40:54 <mdmkolbe-work> @djinn (a -> a) -> a
09:40:55 <lambdabot> -- f cannot be realized.
09:41:02 <dmwit> :t fix
09:41:04 <mdmkolbe-work> @djinn (a -> a) -> a ->
09:41:04 <lambdabot> Cannot parse command
09:41:06 <lambdabot> forall a. (a -> a) -> a
09:41:08 <mdmkolbe-work> @djinn (a -> a) -> a -> a
09:41:08 <lambdabot> f a = a
09:41:08 <quicksilver> hard to 'prove' fix :)
09:41:22 <quicksilver> you need it as an axoim
09:41:32 <quicksilver> (and djinn doesn't have it)
09:42:14 <mdmkolbe-work> @djinn a -> (a -> a) -> a
09:42:16 <lambdabot> f a b = b a
09:42:18 <dozer> been told by the compiler that fmapM in Data.FunctorM is deprecated
09:42:27 <dozer> is there a drop-in replacement for it?
09:42:49 <dolio> Something from Data.Traversable or Data.Foldable.
09:42:51 <dmwit> :t flip ($)
09:42:54 <lambdabot> forall a b. a -> (a -> b) -> b
09:42:55 <mdmkolbe-work> @djinn a -> (a -> a) -> (a -> a) -> a
09:42:56 <lambdabot> f a b c = c (b a)
09:44:08 <dmwit> :t (>>>)
09:44:11 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
09:44:29 <mdmkolbe-work> did someone rewrite djinn recently (1yr) to ensure all the arguments are actually used?  I seem to remember it used to do stupid stuff like "@djinn a -> (a -> a) -> a" producing "f a _ = a"
09:44:56 <dolio> dozer: Data.Traversable.traverse looks like the right function.
09:45:07 <dmwit> ?djinn a -> b -> (b -> a) -> (a, a)
09:45:08 <lambdabot> f a b c = (c b, a)
09:45:29 <dmwit> huh
09:46:04 <dozer> @hoogle traverse
09:46:05 <lambdabot> No matches found
09:46:06 <dolio> dozer: Or Data.Traversable.mapM
09:46:26 <hiben> hi
09:47:10 <mdmkolbe-work> dmwit: if that "huh" was to me, I ask b/c I'm not able to get it to do the stupid stuff anymore and I'm just wondering if it's b/c i'm missremembering or it changed or what.
09:49:07 <dozer> thanks, that mapM was what I needed
09:54:57 <Cheery> how would you create a parser with layout rules, similar to haskell -layouts?
09:55:06 <Cheery> (parsec stuff)
09:57:10 <Cheery> I'm sadistic enough to implement a subset of python in haskell. >:-{)
09:59:01 <tuxplorer> is there a command that I can type in ghci to see what functions are available in the current module? something similar to the methods command in Ruby's irb..
09:59:18 <Cheery> yes
09:59:28 <Cheery> or wait, it's not a command
09:59:45 <Cheery> press tab
10:00:01 <Cheery> I tend to quick-search stuff with it
10:00:12 <Cheery> I type :m <tab>
10:00:28 <Cheery> then it gives me a list of available modules in my system
10:00:34 <tuxplorer> Cheery: pressing tab shows me only the commands from my $PATH
10:00:39 <dozer> @hoogle [a] -> [b] -> [(a, b)]
10:00:40 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
10:01:07 <dozer> is there a builtin that makes the cross-product of two lists (all pair-wise combinations)?
10:01:24 <Cheery> is somebody able to get hoogle -search to ghci?
10:01:28 <shapr> @seen syntaxninja
10:01:29 <lambdabot> I saw syntaxninja leaving #haskell, #darcs and #haskell-blah 15h 40m 19s ago, and .
10:01:32 <shapr> hmm
10:01:33 <ddarius> liftM2
10:01:45 <Cheery> ie. :hoogle Int -> Char
10:01:54 <ddarius> > liftM2 (,) [1..3] [4..5]
10:01:57 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
10:02:02 <Lajexander> @hoogle stdout
10:02:03 <lambdabot> IO.stdout :: Handle
10:02:29 <ddarius> Or you can use list comprehensions.
10:03:00 <tuxplorer> Cheery: Why am I getting just the list of linux commands in my $PATH when I press <TAB> in ghci? is there any other way to get the list?
10:04:02 <Cheery> hmm
10:04:19 <dozer> ?t liftM2 (,)
10:04:19 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
10:04:39 <tuxplorer> Cheery: yup got one for that.. :) let me try that.. :browse <module>
10:04:55 <dozer> thanks ddarius
10:05:51 <tuxplorer> It works.. :)
10:06:15 <Cheery> ok
10:06:35 <Cheery> btw. I found that too, it can be found by: :help
10:07:20 <Cheery> but now I'm wondering an another thing, I found an editor variable, how can I set it for my user account?
10:07:39 <Cheery> ie. is there some .ghcirc or such?
10:08:58 <doserj> it is called .ghci
10:09:15 <vali> sumPassed :: Int
10:09:15 <vali> sumPassed = foldr (+) 0 (checkMod [1..999])
10:09:15 <doserj> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-dot-files.html
10:09:17 <lambdabot> Title: 3.8. The .ghci file, http://tinyurl.com/2935xp
10:09:24 <vali> is sumPassed a function or a variable?
10:09:58 <tuxplorer> http://www.mail-archive.com/hugs-bugs@haskell.org/msg02918.html says that its too much effort to do something like that? I thought there is no such thing.. like user prefs for ghci :)
10:09:58 <lambdabot> Title: Re: User preferences lost between Hugs upgrades on Windows
10:10:43 <sjanssen> @quote
10:10:44 <lambdabot> beelsebob says: [lambdabot] Parse error [beelsebob] where bitch?
10:13:23 <hpaste>  vali pasted "function/variable?" at http://hpaste.org/1464
10:13:23 <tuxplorer> @quote
10:13:23 <lambdabot> nmessenger says: <chessguy> lambdabot drives? <nmessenger> ...men wild!
10:13:51 <Lemmih> vali: There isn't a meaningful distinction between the two.
10:14:27 <dolio> It's more like a constant.
10:14:43 <sjanssen> vali: sumPassed is not a function
10:15:03 <tuxplorer> vali: data and functions being represented uniformly is one main feature of functional programming
10:15:13 <vali> aah
10:15:16 <sjanssen> vali: but we don't want to imply that functions are any different from other data types -- because they're really the same!
10:15:27 <ddarius> vali: There can be, but for the most part there isn't.
10:15:33 <titus> sjanssen: in what sense is it not a function?
10:15:33 <araujo> morning
10:15:37 <vali> oh, i see.
10:16:21 <sjanssen> titus: did you see vali's example?  A function is anything that can be applied to -- sumPassed :: Int clearly can't be applied
10:16:28 <Lajexander> @paste
10:16:29 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:17:12 <vali> sjanssen: by applied to, do you mean that it should take a parameter?
10:17:12 <CounterFX> does anyone know if there is a simple way of suppressing lazy evaluation in haskell?
10:18:14 <sjanssen> vali: that it is able to take a parameter
10:18:20 <hpaste>  Pastorn pasted "how do I do this using StdOut instead?" at http://hpaste.org/1465
10:18:21 <titus> sjanssen: I did yeah...but must a function have arity > 0? in category theory it seems to be common to express constants as functions from Unit -> T
10:18:21 <tuxplorer> CounterFX: use do
10:18:29 <sjanssen> CounterFX: not globally
10:18:51 <CounterFX> hmm didn't think of do
10:18:52 <sjanssen> CounterFX: are you fighting a space leak?
10:19:01 <eumenides> @type Kleisli print
10:19:04 <lambdabot> forall a. (Show a) => Kleisli IO a ()
10:19:07 <eumenides> huh
10:19:18 <sjanssen> tuxplorer, CounterFX: do does not enforce strict evaluation
10:19:30 <CounterFX> nopes... i just have a serious of reads, and i want haskell to fail immediately when it encounters a parse failures
10:19:48 <sjanssen> titus: my definition of function is "any value of type a -> b", of course you can have your own definition
10:20:03 <CounterFX> i.e. i want it to test immediately whether the input is parsable, and not when the value is actually 'needed'
10:20:14 <tuxplorer> sjanssen: do doesn't do the sequence immediately on encountering it?
10:20:25 <vali> sjanssen: thank you. i get it now
10:20:26 <sjanssen> CounterFX: the usual strategy is to use seq or pattern matching
10:20:43 <sjanssen> tuxplorer: nope, it depends on the monad
10:21:07 <tuxplorer> sjanssen: ok.
10:23:01 <sjanssen> say you have "a, b :: String", and you want to read them and pass them to function "f":
10:23:09 <dolio> > (do { a <- (+1) ; b <- undefined ; return (const a b) }) 2
10:23:10 <lambdabot>  3
10:23:12 <titus> sjanssen: it just chimed with something I've been reading, I am a little way into Pierce's "Basic C.T..." and was intrigued by the idea that he gives truth the type Unit -> Boolean
10:23:31 <titus> Truth out of the void!
10:23:32 <sjanssen> let x = read a; y = read b in x `seq` y `seq` f x y
10:24:54 <CounterFX> sjanssen: yups, that did the trick
10:25:06 <CounterFX> sjanssen: thanks a lot :)
10:26:31 <beelsebob> o.O
10:26:34 <beelsebob> I did?
10:27:50 <sieni> > const undefined 8
10:27:52 <lambdabot>  Undefined
10:27:58 <sieni> oops
10:28:03 <sieni> > const 8 undefined
10:28:05 <lambdabot>  8
10:28:14 <sjanssen> > const 8 $! undefined
10:28:16 <lambdabot>  Undefined
10:30:32 <Saizan> can i refer to a type variable in the typesing with a type annotation? ghc treats them as distinct ..
10:30:59 <sjanssen> Saizan: in ghc you can use -fglasgow-exts, then qualify the variable with forall
10:31:15 <Saizan> oh, missed forall
10:32:32 <sjanssen> @keal
10:32:32 <lambdabot> somone would expect that trees 500gb hdds of expressions as if they were floppy dicks
10:32:49 <sjanssen> hahaha
10:35:21 <sjanssen> what a crazy guy
10:35:32 <Saizan> i cna't parse that sentence O_o
10:35:34 <Lemmih> ?keal
10:35:35 <lambdabot> nsa try kill me numerous times
10:35:36 <Saizan> *can't
10:35:46 <sjanssen> lol, the gems just keep coming
10:35:56 <sjanssen> @keal -- hoping for the expressions quote
10:35:57 <lambdabot> i use an 8088
10:36:52 <sjanssen> @keal
10:36:52 <lambdabot> love a black and white lower 128 from 32 up of ascii glyphs?
10:37:46 <lambdabot> evaluating expressions is ALL haskell does?????
10:38:08 <dolio> @protontorpedo
10:38:09 <lambdabot> is functional progrmaming the same as object oriented?
10:38:49 <dolio> @protontorpedo
10:38:50 <lambdabot> Im not a loser
10:38:51 * sjanssen wants a #haskell tshirt with the expressions quote
10:39:08 <chessguy> hi haskellers
10:39:27 <sjanssen> greetings, chessguy
10:39:58 <dolio> @quote chessguy
10:39:59 <lambdabot> chessguy says: <igli> monads are *sweet* :D <chessguy> they're abstract enough to be sour, too, if you need them to be
10:40:00 <sjanssen> how's code?
10:40:33 <chessguy> mmm, not coding at the moment. i'm working
10:40:37 * chessguy rolls his eyes
10:40:46 <sjanssen> chessguy: what do you do?
10:40:59 <chessguy> heh. not much
10:41:25 <chessguy> i work for an internet marketing company, setting up advertising campaigns in there intranet application
10:43:33 <chessguy> and in my down time i look for more rewarding work :)
10:45:20 <chessguy> @quote dolio
10:45:21 <lambdabot> dolio says: [psnl] its been made worse by uni doing a sexual awareness week [dolio] Some people at your university weren't aware of sex?
10:46:26 <chessguy> hmm, seems quiet in here today, or did i do that
10:46:39 <zbrown> @quote chessguy
10:46:40 <lambdabot> chessguy says: [in regards to #haskell] man, it's amazing the difference between what happens when someone asks for help here, and what happens when they ask for help in another language channel
10:46:41 <dolio> Yeah. We were all talking about you just before you came in.
10:46:41 <dmhouse> What's an easy datatype for representing graphs?
10:46:58 <chessguy> Data.Graph maybe?
10:49:24 <dmhouse> I thought perhaps data Node w a = Node a [(w, Node)], which is a node labelled with types a, and arcs weighted with type w.
10:50:04 <dmhouse> chessguy: that's likely to be something very optimised and complicated, I'd prefer something simple I can play around with.
10:50:59 <chessguy> type Graph = Table [Vertex]
10:50:59 <chessguy> type Table a = Array Vertex a
10:50:59 <chessguy> type Bounds = (Vertex, Vertex)
10:50:59 <chessguy> type Edge = (Vertex, Vertex)
10:50:59 <chessguy> type Vertex = Int
10:51:03 <chessguy> doesn't look so bad
10:51:08 <dozer> @pastebin
10:51:09 <lambdabot> Unknown command, try @list
10:51:14 <dozer> ?pastebin
10:51:15 <lambdabot> Unknown command, try @list
10:51:20 <chessguy> @paste
10:51:21 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:51:31 <dmhouse> chessguy: what's the Bounds type for?
10:51:43 <chessguy> dmead: beats me. http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Graph.html#t%3ATable
10:51:45 <lambdabot> http://tinyurl.com/29l92y
10:51:52 <dozer> one day I will remember cheesguy
10:52:47 <mattam> ls
10:52:55 <chessguy> what the heck is so hard about spelling chess? it's C H E S S. 5 letters! not chees, or cheese, or chsesesseee or any other such combination
10:53:10 <dmhouse> It's c h e TAB.
10:53:19 <chessguy> dmead: not unless you want to talk to cheery
10:53:30 <dmhouse> Hehe, irony. :)
10:53:35 <sjanssen> @remember chessguy what the heck is so hard about spelling chess? it's C H E S S. 5 letters! not chees, or cheese, or chsesesseee or any other such combination
10:53:35 <lambdabot> Done.
10:53:48 <Philippa> chezzgi: what's the big deal?
10:53:53 <sjanssen> @remember cheesguy what the heck is so hard about spelling chess? it's C H E S S. 5 letters! not chees, or cheese, or chsesesseee or any other such combination
10:53:53 <lambdabot> Done.
10:54:02 <sjanssen> @remember cheeseguy what the heck is so hard about spelling chess? it's C H E S S. 5 letters! not chees, or cheese, or chsesesseee or any other such combination
10:54:03 <lambdabot> Done.
10:54:06 <chessguy> @slap sjanssen
10:54:07 * lambdabot slaps sjanssen
10:54:20 <dmhouse> chessguy: well, ERC tends to use some random heuristic for TAB-completion, that includes who spoke most recently, I think.
10:54:24 <chessguy> @quote chsesess
10:54:25 <lambdabot> cheesguy says: what the heck is so hard about spelling chess? it's C H E S S. 5 letters! not chees, or cheese, or chsesesseee or any other such combination
10:54:27 <sjanssen> @remember chsesesseeeguy what the heck is so hard about spelling chess? it's C H E S S. 5 letters! not chees, or cheese, or chsesesseee or any other such combination
10:54:27 <lambdabot> Done.
10:54:33 <hpaste>  dozer pasted "dig" at http://hpaste.org/1466
10:54:33 <opqdonut> :-DDD
10:54:44 <chessguy> dmhouse: oh really? i thought it was a lexical ordering
10:54:55 <dozer> in that example code, can I tie ObjectStatement and ObjectResponse together in some way?
10:55:01 <chessguy> sjanssen: you do realize that was all redundant, right?
10:55:18 <dmhouse> chessguy: well, c h e TAB works.
10:55:24 <chessguy> not for me
10:55:26 <dmhouse> (I.e., comes up with your nick.)
10:55:33 <chessguy> ?version dmhouse
10:55:33 <dmhouse> chessguy: you on ERC?
10:55:33 <lambdabot> lambdabot 4p517, GHC 6.6 (OpenBSD i386)
10:55:34 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
10:55:45 <chessguy> no
10:55:56 <tibbe_> @hoogle (a -> b) -> (a, b) -> (b, b)
10:55:57 <chessguy> oh, i mis-read what you were saying
10:55:58 <lambdabot> Data.Graph.Inductive.Query.Monad.mapFst :: (a -> b) -> (a, c) -> (b, c)
10:55:58 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
10:56:08 <dmhouse> Right, well, that's why I qualified my statement with "ERC tends to". :)
10:56:11 <tibbe_> @hoogle (a -> b) -> (a, a) -> (b, b)
10:56:12 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
10:56:16 <int-e> chessguy: xchat has that feature, too.
10:56:22 <chessguy> right, that's why i explained that i mis-read you
10:56:25 <sjanssen> chessguy: it does deliver a nice insult to whomever mispells your name in @quote
10:56:30 <sjanssen> @quote cheesguy
10:56:31 <lambdabot> cheesguy says: what the heck is so hard about spelling chess? it's C H E S S. 5 letters! not chees, or cheese, or chsesesseee or any other such combination
10:56:33 <dmhouse> chessguy: hehe, sorry. Missed that.
10:56:47 <chessguy> sjanssen: it would do that even if you hadn't added those extra @quotes
10:56:52 <chessguy> err, @remembers
10:57:03 <chessguy> @quote sesseee
10:57:04 <lambdabot> cheeseguy says: what the heck is so hard about spelling chess? it's C H E S S. 5 letters! not chees, or cheese, or chsesesseee or any other such combination
10:57:16 <sjanssen> chessguy: nope, because 'cheesguy' doesn't match 'chees'
10:57:35 <chessguy> oh, well, ok
10:57:45 <chessguy> int-e: which feature
10:57:53 <sjanssen> chessguy: plus, it seems to get on your nerves ;)
10:58:17 <sjanssen> dozer: "tie together"?
10:58:21 <chessguy> it was a legitimate question!
10:58:22 <int-e> chessguy: tab completion for nicks.
10:58:35 <chessguy> int-e: yes, i know it has that.
10:58:41 <roemer> does anybody know if there's an (hopefully easy) way to get the system date available in a Haskell program?
10:58:55 <chessguy> int-e: apparently, it tab-completes according to a lexical order, and ERC doesn't though
10:58:59 <sjanssen> @docs Data.Time
10:59:00 <lambdabot> Data.Time not available
10:59:10 <chessguy> @hoogle Time
10:59:11 <lambdabot> System.Time :: module
10:59:11 <lambdabot> Time :: module
10:59:11 <lambdabot> System.Locale.TimeLocale :: ([(String, String)] -> [(String, String)] -> [(String, String)] -> String, String -> String -> String -> String -> String -> TimeLocale)
10:59:14 <dozer> sjanssen: so that the compiler knows and checks that ask always produces an ObjectResponse if you feed it an ObjectStatement for example
10:59:21 <Jaak> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Time.html ?
10:59:23 <lambdabot> http://tinyurl.com/yrtcx7
10:59:33 <chessguy> wow, that's a crazy type signature
11:00:00 <chessguy> and what the heck is :: module
11:00:04 <sjanssen> roemer: http://www.haskell.org/ghc/docs/latest/html/libraries/time/Data-Time-Clock.html
11:00:06 <lambdabot> http://tinyurl.com/2ydz82
11:00:15 <int-e> chessguy: oh. xchat has a switch to choose 'last spoke order' or alphabetical orer.
11:00:21 <ndm> chessguy: hoogle way of saying its a module, Hoogle 4 will be "module Time"
11:00:22 <eumenides> @type Kleisli readFile &&& Kleisli readFile
11:00:25 <lambdabot> Kleisli IO FilePath (String, String)
11:00:42 <xerox> ?type Data.Array.MArray.mapIndices -- I think there's something weird about this type.
11:00:42 <dmhouse> ndm: what's the timeline looking like for Hoogle 4?
11:00:45 <lambdabot> forall i j (a :: * -> * -> *) e (m :: * -> *). (Ix j, Ix i, Data.Array.Base.MArray a e m) => (i, i) -> (i -> j) -> a j e -> m (a i e)
11:00:59 <xerox> Shouldn't it be (j -> i) ?
11:01:09 <ndm> dmhouse: slow, am writing a Haskell Workshop paper on soemthing else
11:01:12 <xerox> And what's the first (i, i) for?
11:01:28 <ndm> dmhouse: i may manage to get a weekend on it next month, that may get it to pre-alpha quality
11:01:35 <dmhouse> ndm: good good. :)
11:01:41 <hpaste>  sjanssen annotated "dig" with "something like this?" at http://hpaste.org/1466#a1
11:01:44 <chessguy> int-e: oooh, that's handy
11:01:44 <dmhouse> ndm: just that there's a lot of cool features but no code. :(
11:01:47 <chessguy> never saw that before
11:01:55 <ndm> dmhouse: although some libraries like tagsoup, binarydefer etc are popping out - those are required for 4
11:02:02 <ndm> dmhouse: yeah, i feel the same way...
11:02:27 <xerox> Anybody else thinks its weird?
11:02:29 <ndm> i definately should have planned more, forked later and used branching...
11:02:43 <ndm> but thats experience for you
11:02:46 <dmhouse> ndm: yep, I saw those libs :) TagSoup especially looks useful.
11:02:49 <dmhouse> Yeah, exactly.
11:03:04 <sjanssen> xerox: the (i, i) is the bounds of the created array
11:03:17 <ndm> anyway, food - i'll maybe put together a revised hoogle 4 time line and dependency tree, and perhaps blog it up
11:03:25 <ptolomy> I'm profiling a ghc-build application, and I'm troubled to find that in 15 seconds of runtime, it manages 1 tick, meaning it usually shows some arbitrary function taking 100% of the time.
11:03:27 <ptolomy> ANy hints?
11:04:07 <chessguy> ndm: you need to hire a coder to help you :)
11:04:09 <xerox> sjanssen, okay (BTW I don't need bounds checking.)
11:04:19 <chessguy> it just so happens i know one that knows haskell, too!
11:04:26 <dolio> xerox: (i, i) is the index range of the new array, and (i -> j) tells, given an index from the new array, where to get it from the old array.
11:04:51 <roemer> sjanssen: am i wrong or is that only for the time of the day?
11:05:21 <xerox> dolio, ah, that's twisted.
11:05:31 <dolio> xerox: Yeah. :)
11:05:42 <sjanssen> roemer: you might be right.  Browse around the Data.Time hierarchy -- it's in there somewhere
11:07:25 <ptolomy> Is the GHC time profiling usually accurate?
11:11:40 <ndm> chessguy: no money :)
11:11:45 <ndm> ptolomy: usually, yes
11:12:38 <chessguy> ndm: bah, universities have plenty of money
11:12:51 <ptolomy> Would the fact that my code is probably mostly bytestring-based account for the lack of time samples, perhaps? Or do I want to make it run for a few minutes to get a reasonable profile?
11:12:52 <chessguy> just tell them it's for a research project
11:14:17 <astrolabe> xerox: I don't understand the signature, but it seems the right way round to me.
11:14:34 <astrolabe> Ah, sorry, just scrolled down.
11:15:18 <xerox> astrolabe, I just want to apply a function to the indices, but it's not straightforward this way.
11:15:34 <tibbe_> ghc 6.8 will have overloaded string literals right?
11:15:57 <ptolomy> tibbe_: Whoa. It will?
11:16:10 <astrolabe> xerox: for a mutable array?  Why isn't it straightforward?
11:16:14 <xerox> "It may be thought of as providing function composition on the right with the mapping that the original array embodies."
11:16:40 <astrolabe> xerox: that is straight-forward!
11:16:42 <xerox> astrolabe, yup, it's an MArray.
11:17:52 <tibbe> ptolomy, I was asking, I think someone mentioned it.
11:18:35 * ptolomy checks trac.
11:18:57 <chessguy> overloaded string literals?
11:19:20 <chessguy> they are overloaded, they have type String and type [Char] :)
11:20:02 <tibbe> chessguy, ByteStrings
11:20:29 * tibbe grrrs at ghc, "Stop hoarding that show function for Strings!"
11:21:21 <chessguy> anyway, i heard 6.8 isn't likely to arrive for a while
11:22:45 <tibbe> ok
11:22:49 <kpreid> Cheery: re parsec layout, write a stateful lexer which turns sequences of \n followed by whitespace into break/indent/dedent tokens depending on the space relative to the previous one
11:23:22 <chessguy> ?seen cheery
11:23:23 <lambdabot> cheery is in #haskell. I last heard cheery speak 1h 15m 43s ago.
11:23:26 <kpreid> Cheery: that's sufficient for Python; Haskell is trickier
11:24:58 <xerox> astrolabe, it is not straight-forward because this way I have to apply the inverse function instead of just applying my function.
11:28:51 <astrolabe> xerox: You suprise me.  I don't understand.
11:31:18 <tibbe> lets have a little petition, since "show" is take by class Show for Strings what would be a good name to use for show:ing things as bytestrings?
11:32:23 <tibbe> I have a Template data type representing a string template (in a templating language) and I need a Template -> ByteString function but can't come up with a good name
11:32:37 <xerox> ?type Data.Binary.encode
11:32:38 <tibbe> I use showTemplate at the moment but I would like a one word function
11:32:40 <lambdabot> forall a. (Data.Binary.Binary a) => a -> Data.ByteString.Lazy.ByteString
11:32:42 <Saizan> render?
11:33:00 <eumenides> instance Show ByteString where show = show . unpack ?
11:33:01 <tibbe> Saizan, render does the variable substitution, it's useful to show the actual template sometimes
11:33:12 <tibbe> eumenides, I want the result as a ByteString
11:33:14 <dozer> @hoogle maybe
11:33:15 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
11:33:15 <lambdabot> Maybe :: module
11:33:15 <lambdabot> Prelude.Maybe :: data Maybe a
11:33:27 <tibbe> for my Quickcheck property: showByteString . parse / id
11:33:53 <eumenides> tibbe: ah right.
11:33:53 <tibbe> show.parse/id reads much better than showByteString.parse/id or something like that
11:34:22 <tibbe> I was thinking: display, repr, literal
11:34:33 <tibbe> but they're not perfect
11:34:51 <sjanssen> tibbe: one option is to use show and use qualified imports
11:35:58 <tibbe> sjanssen, I think that would be a bit confusing to users, they expect show to return a String
11:36:14 <sioraiocht> @where parsec
11:36:15 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
11:36:23 <sjanssen> tibbe: how will this class efficiently construct ByteStrings?
11:36:43 <sjanssen> (a totally question totally unrelated to the name)
11:36:43 <tibbe> the thing is that if I use normal Show, show . parse == id doesn't hold and that is a nice property to have
11:37:30 <tibbe> sjanssen, yet to be discovered, right now it uses a regex to split the template into [Frag] where Frag = Lit ByteString | Var ByteString
11:37:33 <tibbe> for string literals and variable respectively
11:38:01 <tibbe> if performance testing reveals that lazy bytestrings are more efficient I will switch to those
11:38:15 <sjanssen> tibbe: you want your template function to be polymorphic, ie. it could take an Int and automatically convert it to a ByteString?
11:38:17 <tibbe> I would like to use parsec but it doesn't support bytestrings at the moment
11:38:26 <tibbe> sjanssen, no
11:38:28 <ndm> tibbe: what if performance testing reveals [Char] to be more efficient?
11:38:39 <tibbe> ndm, I'll switch to it
11:38:45 <tibbe> but I doubt it
11:39:11 <sjanssen> tibbe: I don't see why you need this ByteString Show, then
11:39:13 <tibbe> sjanssen, I'm not sure yet what performance implications too much polymorphism will have, I'm a bit scared of the whole Stringable thing
11:39:38 <tibbe> sjanssen, because it is nice to have an inverse to parse
11:39:58 <sjanssen> oh, parse :: String -> Template?
11:40:07 <sjanssen> (or ByteString, probably)
11:40:10 <tibbe> parse :: ByteString -> Template
11:40:18 <tibbe> showXXX :: Template -> ByteString
11:40:24 <sjanssen> ah, I see
11:40:27 <tibbe> showXXX . parse == id
11:40:38 <sjanssen> I'd call it showTemplate
11:40:47 <tibbe> that's what it's called right now :)
11:40:54 <tibbe> but it feels a tad bit long
11:41:11 <sjanssen> meh, it shouldn't be a frequently used operation, right?
11:41:15 <tibbe> but it's the best I can think of so I guess it stays
11:41:18 <tibbe> nope
11:41:27 <sjanssen> primarily for debugging purposes, I would imagine
11:41:31 <tibbe> but it forces me to realign my QuickCheck output ;)
11:41:38 <tibbe> QuickCheck purposes!
11:42:20 <tibbe> of course I could do a B.pack in my quickcheck
11:42:45 <tibbe> but then it's: B.pack . show . parse == id
11:42:47 <tibbe> not as nice
11:42:55 <tibbe> it breaks the symmetry
11:43:10 <tibbe> I guess it's just an esthetic preference
11:43:23 <sjanssen> tibbe: you want to change the name for indentation purposes?! ;)
11:43:27 <tibbe> I should say "just", I think estethics are very important
11:43:32 <tibbe> sjanssen, yes! :D
11:44:11 <tibbe> well, render, substitute, parse, etc are very natural names for templates, I was digging for a similar thing for outputing the template as is
11:44:14 <tibbe> "id"
11:44:18 <tibbe> but that's used
11:44:21 <tibbe> and it's not really id
11:44:37 <sjanssen> unparse?
11:44:49 <sjanssen> makes it clear that it is the inverse of parsing
11:44:51 <sioraiocht> has anyone used wxHaskell recently'?
11:45:25 <tibbe> perhaps just call it template
11:45:45 <tibbe> but that sounds a bit like something that contructs a template
11:46:12 <tibbe> I'll go actually implement some features instead
11:46:18 <tibbe> so I can release it
11:46:29 <tibbe> it's almost done
11:46:34 <tibbe> just need to polish the error reporting
11:47:05 <sjanssen> lazy ByteStrings are almost certainly going to be more efficient for this task, btw.
11:47:13 <sjanssen> because 'concat' is much cheaper
11:48:05 <dmhouse> Lazy ByteStrings are almost always faster. :)
11:49:13 <tibbe> sjanssen, I'll try to change then, I wasn't sure how much chunking my [Frag] representation bought me
11:50:18 <sioraiocht> is there a current forerunner for GUI bindings in haskell? anyone?
11:51:03 <chessguy> ?where gtk2hs
11:51:04 <lambdabot> http://haskell.org/gtk2hs/
11:52:19 <tibbe> Test.Regex.Posix doesn't have a lazy ByteString version, only a strict one :(
11:53:22 <sioraiocht> thanks!
11:57:05 <Cheery> I've tried parsec now, It's excellent
11:57:48 <Cheery> It was just a moment after I got handle of it
12:02:11 <sjanssen> tibbe: the posix backend supposedly sucks
12:03:02 <sioraiocht> Cheery: just had a similar experience
12:03:15 <sioraiocht> I'm trying to implement a parser for this http://scienceblogs.com/goodmath/2007/03/programming_with_shapes_clunk.php#more with Parsec
12:03:17 <lambdabot> Title: Good Math, Bad Math : Programming with Shapes: Clunk, http://tinyurl.com/ywzagv
12:10:19 <shapr> @yow !
12:10:20 <lambdabot> In 1962, you could buy a pair of SHARKSKIN SLACKS, with a "Continental
12:10:21 <lambdabot> Belt," for $10.99!!
12:10:26 <tibbe> sjanssen, :(
12:11:19 <shapr> bringert! Yow!
12:11:27 <bringert> hi shapr
12:11:46 <bringert> shapr: back in the US?
12:12:17 <shapr> bringert: Yup, didn't get your mail till yesterday.
12:12:24 <stepcut> good old, SW, USA!
12:12:24 <chessguy> @get-shapr
12:12:25 <lambdabot> shapr!!
12:12:32 <shapr> chessguy!
12:12:40 <shapr> stepcut: SW?
12:12:48 <stepcut> isn't that the state code for sweden ?
12:12:53 <shapr> haha
12:13:00 * shapr isn't sure whether to laugh or cry.
12:13:18 <shapr> I liked benja_'s comment that Sweden should be SV for Sverige, and that SW was totally wrong :-)
12:13:31 <stepcut> heh
12:13:45 <shapr> It does match the ISO code.
12:13:54 <chessguy> @quote benja
12:13:54 <lambdabot> No quotes match. It can only be attributed to human error.
12:15:14 <chessguy> @quote benja_
12:15:15 <lambdabot> No quotes match. Take a stress pill and think things over.
12:15:28 * chessguy takes a few
12:16:08 <lekro> is it possible to use an operator as a data type constructor? ghc doesn't seem to accept it, but maybe I don't know the right syntax
12:17:11 <dolio> What are you trying?
12:17:34 <dolio> It has to begin with :
12:17:44 <lekro> I'd like to express formal terms: data Term = Term <+> Term | Term <*> Term | Identifier String
12:18:19 <dolio> Ah. Yeah. 'data Term = Term :+ Term | Term :* Term | ...'
12:18:32 <dolio> Although :+ is already taken by Comlpex.
12:19:08 <dolio> Complex, even. You could avoid importing that, though.
12:19:10 <lekro> ah, thanks :)
12:19:28 <DRMacIver> Hm. Is : the only character you're allowed to start an infix data constructor with?
12:19:47 <doserj> yes
12:19:48 <dolio> Yep.
12:19:58 <dolio> : is the capital symbol.
12:21:02 <DRMacIver> ok
12:29:38 <monochrom> :<+> is definitely fair game.
12:30:02 <DRMacIver> aka the Jaws smiley type constructor.
12:30:22 <monochrom> The gurus write :<+>: or :+: so that the leading colon doesn't look too strange.
12:30:37 <monochrom> YES! Haskell is a smiley language!
12:30:45 <DRMacIver> Ah, the well known Tie Fighter operators. :)
12:30:52 <monochrom> Even APL doesn't attain to that status! :)
12:31:29 <monochrom> A grad student in my department showed all six Star War episodes at school in the last two days.
12:31:42 <sjanssen> yikes
12:31:49 <dolio> That's quite a marathon.
12:32:22 <dolio> I'm not sure I'd be able to sit through 1 - 3 in one day.
12:32:29 <dolio> Maybe 4 - 6.
12:32:39 <sjanssen> dolio: yeah, you'd need to rearrange them
12:32:39 <monochrom> I have a set of Wagner's Ring cycle DVDs.  I should do that some time.
12:32:42 * DRMacIver hasn't bothered seeng 3 yet.
12:33:08 <Philippa> 3 has one good moment in it, but it's mostly because someone finally gets hurt for doing the same silly thing that's been done in all the other fight scenes
12:33:18 <sjanssen> DRMacIver: it's certainly the best of the three
12:33:25 <monochrom> What was the silly thing?
12:33:35 <DRMacIver> sjanssen: Yeah, but that's not exactly a ringing endoresement. :)
12:33:57 <DRMacIver> resounding
12:33:59 <DRMacIver> Whatever
12:34:01 <DRMacIver> Brain be tired
12:34:16 <monochrom> You're infected by my Wagner's Ring cycle!
12:37:31 <tibbe> whats the definition of >>= and return in a parser monad like parsec?
12:37:36 <tibbe> @src parsec
12:37:36 <lambdabot> Source not found. You speak an infinite deal of nothing
12:37:57 <monochrom> That's a lot of code.
12:37:57 <dmhouse> ?libsrc Text.ParserCombinators.Parsec
12:37:58 <lambdabot> Unknown command, try @list
12:38:07 <dmhouse> ?fptools Text.ParserCombinators.Parsec
12:38:07 <lambdabot> http://darcs.haskell.org/packages/parsec/Text/ParserCombinators/Parsec.hs
12:38:57 <monochrom> dmhouse beats me to it
12:39:45 <dozer> yay! just finnished my first sereous bit of haskell
12:40:24 <monochrom> Actually go ahead to Parser/Prim.hs
12:40:24 <dmhouse> dozer: cool :) What did you write?
12:40:38 <monochrom> Damn, Parsec/Prim.hs
12:40:59 <dozer> something unbelievably hideously complex - sort of like xslt for knowledge representations
12:41:10 <tibbe> I want to roll my own parser for ByteStrings, really simple, no backtracking, just keeping track of the position, I'm parsing a regular language
12:42:07 <dozer> but the whole of www.ncl.ac.uk seems down now, so I can't commit the code or blog it
12:42:07 <dozer> damn
12:42:10 <sjanssen> tibbe: sounds like you want a State monad
12:42:38 <sjanssen> tibbe: or if you're parsing ByteStrings you can use the Get monad from the binary lib
12:42:59 <sjanssen> it is tuned for speed
12:45:27 <sjanssen> tibbe: one handy feature of using binary is that you can (ab)use it to get UTF-8 support
12:47:39 <tibbe> sjanssen, good idea!
12:47:39 <tibbe> I need to keep track of source positions too but I could use StateT I guess
12:49:27 <sjanssen> Get keeps track of the input position already, right?
12:50:01 <tibbe> oh it does? cool
12:51:08 <MarcWeber> Do you know when CRef from HaXml is used?
12:51:55 <shapr> when?
12:53:51 <MarcWeber> shapr: I want to extract some text from a HTML document. I've managed filtering the content using xtract which is no great deal. But I don't no a nice way to get the content as String yet.
12:54:14 <MarcWeber> There is a parser called text but I can't see an easy way to use it.
12:55:15 <shapr> I used to know how to do that, but I can't remember, sorry.
12:57:02 <tibbe> MarcWeber, Is HaXml like HXT? I know how to do it in HXT
12:57:10 <tibbe> @google Haskell HXT
12:57:12 <lambdabot> http://www.fh-wedel.de/~si/HXmlToolbox/
12:57:13 <lambdabot> Title: Haskell XML Toolbox 7.1
12:57:21 <tibbe> not that link though
12:57:56 <bringert> MarcWeber: have you seen ndm's tagsoup library?
12:58:10 <MarcWeber> Not yet.
12:58:18 <chessguy> ?where tagsoup
12:58:19 <lambdabot> I know nothing about tagsoup.
12:58:23 <chessguy> dumb bot
12:58:27 <chessguy> ?where ndm
12:58:27 <lambdabot> http://www.cs.york.ac.uk/~ndm/
12:58:47 <chessguy> ?where+ tagsoup http://www-users.cs.york.ac.uk/~ndm/tagsoup/
12:58:47 <lambdabot> Done.
12:59:22 <tibbe> this is trickier than I thought
12:59:50 <MarcWeber> tibbe: Not sure what you're trying to do.
13:00:07 <tibbe> oh, something not related to HTML
13:00:09 <MarcWeber> I tried to get a list of packages from hackage.haskell.org
13:00:39 <tibbe> I want to parse the bytestring "Hello, $name! Want some ${fruit}s?"
13:00:45 <tibbe> while keeping track of the line column
13:00:54 <tibbe> would be easy with parsec if it worked with bytestrings
13:01:08 <tibbe> I'm trying to figure out if I can do it with Data.Binary
13:01:21 <Cheery> I have syntax separated by spaces, like this:   a=>bcd !2 -h axxaXax
13:02:31 <sjanssen> tibbe: actually, it might be better to just use State ByteString
13:02:32 <Cheery> I'd like to know, how could I make sure the last expression is correct even if user forgets the space from the end?
13:02:49 <tibbe> sjanssen, I think so too
13:02:51 <sjanssen> it looks like Get is missing a couple primitives (takeWhile, for example)
13:03:00 <tibbe> yes
13:03:11 <tibbe> so I'll roll my own parser
13:03:21 <tibbe> it only has to parse bytestring into my data type
13:03:50 <monochrom> Use a monad with state and error.
13:03:58 <tibbe> yes
13:04:07 <tibbe> actually calling error "..." is enough in my case
13:04:23 <monochrom> parsec itself is a very dressed up monad with state and error.
13:04:26 <Cheery> heh, state and error, does that have some reference with trial&error?
13:04:28 <tibbe> so newtype Parser a = Parser ByteString a
13:04:35 <tibbe> :)
13:04:43 <MarcWeber> tibbe: Why don't you unpack the Bytestring to use parsec?
13:05:04 <tibbe> MarcWeber, I want to avoid packing and unpacking for efficieny reasons
13:05:09 <monochrom> Oh yeah, try unpack and use parsec, see if it's fast enough.
13:05:14 <Cheery> hmm, my parsec -problem turned out on itself, I don't need end-terminator
13:05:17 <tibbe> I could I guess
13:05:23 <sjanssen> I don't think parsec is a good fit here
13:05:34 <xerox> dcoutts, ping!
13:05:36 <tibbe> fast enough is a bit hard to define in this case, as fast as possible is better
13:05:39 <Cheery> I can specify the separator just at the place when I put the stuff to list
13:05:48 <sjanssen> tibbe: you'll take a *huge* performance hit by repacking (in both memory and time)
13:05:53 <tibbe> the language is really simple, regular in fact
13:06:00 <tibbe> sjanssen, exactly
13:06:22 <tibbe> I'll implement a tiny subset of parsec
13:06:35 <tibbe> I don't need backtracking, only 2 chars of look ahead
13:06:44 <sjanssen> why not just use State ByteString?
13:06:50 <tibbe> I will
13:06:59 <sjanssen> okay :)
13:07:08 <tibbe> how will put and get work, will they share the bytestring or realloc if I consume a part?
13:07:19 <tibbe> how will put and get work, will they share the bytestring or realloc if I consume a part?i
13:07:28 <tibbe> I guess I have to implement it and fump to Core :D
13:07:33 <tibbe> yay, fun
13:07:47 <sjanssen> why do you need put?
13:08:48 <sjanssen> I'd say you need three primitives: get :: Parse Char, peek :: Parse Char, takeWhile :: (Char -> Bool) -> Parse ByteString
13:09:42 <tibbe> need to peek 2 chars
13:09:44 <tibbe> take 2
13:09:58 <tibbe> I don't need put, it was just an example :)
13:10:07 <tibbe> or
13:10:20 <roemer> question: i'm working with wxHaskell and made a textEntry and a button. If one hit enter in the extEntry, the button must be "activated". I found out something about processEnter, but "processEnter text [on command := button]" doesn't work... someone known the right way?
13:10:22 <tibbe> when I do takeWhile will it not use put to put back the rest of the ByteString?
13:10:29 <xerox> I wonder how is it called that GUI device that lets you choose a value from a range moving a little thing on a line.
13:10:43 <chessguy> slider
13:10:56 <xerox> That must be it, thanks.
13:11:03 <ndm> MarcWeber: TagSoup isn't on hackage because i can't upload to it - cabal bug
13:11:05 <sjanssen> tibbe: I'd use the takeWhile function from ByteString, which shares the underlying byte arrays
13:11:14 <xerox> I can find no "slider" in Gtk2Hs docs, though :(
13:11:17 <ndm> MarcWeber: but if you do have any tagsoup questions, i'm happy to answer them
13:11:29 <SamB_XP> xerox: scrollbar?
13:11:39 <tibbe> sjanssen, right but I still need to put back the rest
13:11:40 <xerox> SamB_XP, nope.
13:11:48 <chessguy> SamB_XP: that doesn't usually select a value
13:11:55 <xerox> Ah, it must be the Abstract Scale here <http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Abstract-Scale.html>
13:11:56 <lambdabot> http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Abstract-Scale.html>
13:11:58 <tibbe> sjanssen, also, wont I need some kind of alternative operator? <+>
13:12:06 <sjanssen> tibbe: why do you need to put it back?
13:12:15 <MarcWeber> ndm: I'm reading your documentation now .. ;)
13:12:21 <SamB> ah, yeah, that doesn't look much like a slider...
13:14:32 <tibbe> sjanssen, I probably don't understand the state monad while enough
13:15:04 <tibbe> wouldn't takeWhile (in the monad) take part of the string kept as state and put the rest back?
13:15:28 <tibbe> sjanssen, how would I otherwise keep track of the current position? store it seperately?
13:16:31 <kolmodin> I guess a takeWhile could be useful for binary
13:16:34 <nominolo> "Haskell doesn't have true dependent types so comparisons on the type level are boolean in nature. The types match or they do not. You can't examine the types and decide whether one is "greater" than the other in some sense."
13:16:44 <nominolo> ^-- really?
13:16:57 <kolmodin> mostly for: takeWhile (/=0)
13:17:01 <nominolo> (from http://abstractabsurd.blogspot.com/2007/04/arrows-security.html)
13:17:06 <lambdabot> Title: Abstract Absurdities: Arrows & Security
13:18:10 <nominolo> this statement sounds to be solvable in 1-oleg-hour or so
13:18:29 <nominolo> s/solvable/possible to disprove/
13:19:43 <ndm> nominolo: in Haskell or in GHC-skell
13:19:59 <nominolo> GHC-skell ?
13:20:07 <nominolo> ah
13:20:10 <nominolo> got it
13:20:19 <nominolo> -fglasgow-exts, I assume
13:21:03 <mnislaih_> if oleg needs 1 hour, then it must be a tough problem
13:21:26 <nominolo> @where hlist
13:21:27 <lambdabot> http://homepages.cwi.nl/~ralf/HList
13:22:41 <MarcWeber> ndm: How would you get the contents of a list/ tree ?  eg   <h3><ul><li><li><li></ul><h3><ul><li ... ? h3 does contain the section headline and li the items.
13:22:49 <bringert> nominolo: it's not hard to do
13:23:02 <MarcWeber> Your examples do all only try to get one value.
13:23:23 <nominolo> bringert: i don't think so, either
13:23:31 <nominolo> maybe 5 oleg-minutes or so
13:23:37 <bringert> nominolo: there's one example in our HaskellDB paper
13:24:45 <MarcWeber> ndm: Use tagsoup only if structure has been lost. The page I want to get some information from is well formatted XHTML.
13:25:13 <nominolo> @where HaskellDB
13:25:14 <lambdabot> http://haskelldb.sourceforge.net/
13:25:20 <bringert> nominolo: that guy just hasn't realized that MPTC + fundeps + undecidable instances is a turing complete language on the type level
13:25:47 <roemer> anybody could tell how to activate a button from an textEntry with the return key? [wxHaskell]
13:26:11 <roemer> found processEnter, but don't know how to implement
13:26:15 <nominolo> bringert: you can send the type-checker into non-termination with that?
13:26:23 <bringert> nominolo: sure
13:26:43 <nominolo> oh
13:26:46 <ndm> MarcWeber: even on fully structured XHTML, its often quicker to tag-soup it
13:26:55 <DRMacIver> turing complete type systems are surely a good thing.
13:27:02 <ndm> MarcWeber: can you give me a sample file, plus the information you want extracting?
13:27:10 <MarcWeber> ndm: sure
13:27:14 <nominolo> i guess i have to read up on that, then.  any suggestions?
13:28:00 <bringert> nominolo: some people think that's bad to have undecidable type checking, but I don't really agree. hindley-milner type checking is already exponential, and between exponential and non-terminating, who cares?
13:28:12 <hpaste>  sjanssen pasted "a parser that might work" at http://hpaste.org/1469
13:28:14 <MarcWeber> ndm: This is the page and I want to get the categories with packages.. http://hackage.haskell.org/packages/archive/pkg-list.html
13:28:16 <sjanssen> tibbe: ^^^
13:28:27 <MarcWeber> ndm: I want to create some nix expressions automatically
13:28:29 <DRMacIver> I'm not sure I even see why having undecideable type checking is a bad thing.
13:28:34 <monochrom> Between exponential and non-terminating, there is still doubly-exponential.  *duck*
13:28:35 <DRMacIver> s/is/would be/
13:28:39 <dieJana> Cale, are you around?
13:28:40 <bringert> nominolo: hmm, oleg has lots of papers about it. I don't remember how much mcbride's "faking it" covers
13:28:46 <ndm> MarcWeber: result :: [(Section,[Package])] ?
13:28:48 <Cheery> ok, now I've a parser which works just well, except one thing
13:28:54 <dmhouse> DRMacIver: I'm not sure I like the idea of my compiler never terminating.
13:28:55 <MarcWeber> ndm: Something like that
13:29:10 <MarcWeber> ndm: where Package is (Name, description, href)
13:29:18 <Cheery> the parser allows gibberlish after the sentences now, and I don't want it
13:29:19 <DRMacIver> dmhouse: But it does terminate. It terminates when the programmer gets bored and hits control c. :)
13:29:31 <Cale> dieJana: Hello, yep.
13:29:45 <ndm> MarcWeber: mind if i make it a tagsoup example? since it is haskell related
13:29:47 <DRMacIver> dmhouse: It has no practical significance (as long as it doesn't slow the mainline case down too much).
13:29:55 <bringert> nominolo: you may want to look at this http://www.cs.virginia.edu/~jba5b/singleton/
13:29:57 <lambdabot> Title: Simulating Dependent Types with Guarded Algebraic Datatypes
13:29:57 <Cheery> the parser is: sepBy parseExpression space
13:29:59 <MarcWeber> ndm: Why should I?
13:30:03 <ndm> MarcWeber: easy enough :)
13:30:09 <ndm> MarcWeber: no reason, just checking first
13:30:16 <bringert> nominolo: but that uses GADTs
13:30:28 <nominolo> bringert: thanks
13:30:40 <Cheery> > parseTest (string "expr") "expr"
13:30:41 <lambdabot>   Not in scope: `string'
13:30:55 <Cheery> > parseTest (many1 letter) "expr"
13:30:56 <lambdabot>   Not in scope: `letter'
13:31:02 <ndm> MarcWeber: give me 5 mins, its typically quite easy with tagsoup :)
13:31:20 <tibbe> why does Data.Binary define its own State monad?
13:32:08 <Cheery> so, how would I prevent this succeeding? parseTest myparser "expr expr exprgibberlishshit"
13:32:09 <MarcWeber> ndm: No problem. I did need some hours to get to no HaXml. I ended up getting this
13:32:10 <hpaste>  MarcWeber pasted "My HaXml attempt" at http://hpaste.org/1470
13:32:22 <ndm> MarcWeber: lol, its 10 minutes tops with tagsoup
13:32:34 <ndm> and thats horrid!
13:32:40 <Orphi> hi guys... I have some random bubble about optimising my program. which mail list would be the correct place - haskell or haskell-cafe?
13:32:56 <sjanssen> tibbe: probably to convince GHC to do more optimization
13:33:32 <mauke> Cheery: parser << eof
13:33:40 <tibbe> sjanssen, ok
13:33:44 <MarcWeber> But I'm stuck at extracting the text from content. Using regex might have worked, too
13:34:13 <MarcWeber> ndm: And you are right if you've written the library by yourself and you don't have to learn it first ;)
13:34:15 <bringert> nominolo: as an exercise, implement type-level binary artihmetic
13:34:21 <bringert> :-)
13:34:24 <bringert> it's fun
13:34:46 <ndm> MarcWeber: of course :) - learning is the hard bit
13:34:55 <bringert> nominolo: MPTCs + fundeps + undecidable instances = type-level prolog
13:35:01 <ndm> although the manual is designed to reduce the learning curve
13:35:08 <bringert> it's even untyped
13:35:14 <MarcWeber> bringert: You make me think of HList .. ;) Only got some pieces of it yet.
13:35:48 <bringert> MarcWeber: yeah, HList does a lot of that stuff
13:36:16 <bringert> they even have special type-level tricks to get good better error messages
13:36:20 <bringert> iirc
13:36:41 <MarcWeber> bringert: And the stack based language exapmle .. horrible to read.. ).. Sorry I'm not sure I can follow yet..
13:39:08 <bringert> MarcWeber: it was quite a while since I read the HList paper, but yeah they do some nasty stuff
13:39:17 <sjanssen> @remember bringert nominolo: as an exercise, implement type-level binary artihmetic
13:39:18 <lambdabot> Done.
13:39:43 <MarcWeber> bringert: My problem is: Reading is not enough for me.. I have to do some exercises. ;)
13:39:50 <Cheery> mauke: got it, thanks
13:39:54 * sjanssen thinks that associated types will make class programming easier
13:40:30 <bringert> sjanssen: I hope so too, but I haven't gotten around to playing with it. have you tried?
13:40:45 <Cheery> I feel haskell teaches me whole time to writing better programs
13:41:16 <sjanssen> bringert: I've gotten that impression from the literature, "Associated Types With Class" and friends
13:41:21 <Cheery> when I'm typing it, everything I decide I can immediately see in the code
13:41:54 <sjanssen> the fact that ATs present a functional model, rather than a relational one, helps
13:42:19 <Cheery> ie. I think I just understood how to write better parsers and a general principle when toying with my circular tag interpreter
13:43:44 <Cheery> the general principle: one thing at a time - worry about things which are important at the time of your design
13:44:38 <MarcWeber> ndm, bringert Which editors are you using?
13:44:49 <ndm> MarcWeber: textpad, on windows
13:45:08 <bringert> MarcWeber: I use emacs on linux and aquamacs on os x
13:45:25 <bringert> MarcWeber: why do you ask?
13:45:53 <monochrom> A good language promotes good thought.
13:46:02 <MarcWeber> bringert: I've written some vim scripts which do work fine.. And I'm happy to use them. I thought I could share them .. ;)
13:46:31 <dieJan1> Cale, I prived you :)
13:46:37 <sjanssen> MarcWeber: what do they do?
13:46:51 <MarcWeber> sjanssen: Kind of completion and tagging by one command
13:46:56 <Cale> dieJana: perhaps you're not logged in?
13:47:01 <dieJana> now I have
13:47:03 <dieJana> sorry
13:47:19 <dieJana> if you could just copy paste... :)
13:47:42 <Cale> um, I didn't get your messages because you have to be registered to send privmsgs.
13:47:51 <dieJana> ah, right
13:47:55 <sjanssen> MarcWeber: I'm always interested in Haskell vimscripts.  You could post them on haskell-cafe too
13:48:14 <tibbe> @hoogle Int64
13:48:15 <lambdabot> Data.Int.Int64 :: data Int64
13:48:46 <MarcWeber> sjanssen: I already did some time ago. And I noticed much later that they also appeard on haskell weekly news. A link is also on haskell.org. But I didn't get much feedback yet. You can see a screenshot here: http://www.mawercer.de/marcweber/vim/ss/vim/
13:48:49 <lambdabot> Title: Index of /marcweber/vim/ss/vim
13:51:07 <sjanssen> MarcWeber: I think I found the ml post.  I'll try it right now
13:52:27 <vali> is there a simple way to haskellify this:  screenshot here: http://www.maw
13:52:30 <MarcWeber> sjanssen: I've moved to hg. You can't access the darcs repo. Couldn't figure out how to use it on windows
13:52:31 <vali> oops
13:52:43 <vali> checkMod xs = filter (\x -> x `mod` 3 == 0 || x `mod` 5 == 0) xs
13:53:01 <ndm> MarcWeber: pushed, all working, 14 lines
13:53:17 <sjanssen> MarcWeber: what's the URL then?
13:53:22 <ndm> @hpaste
13:53:23 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:53:34 <mauke> vali: well, you could remove xs
13:53:40 <hpaste>  ndm pasted "hackage downloading (for MarcWeber)" at http://hpaste.org/1471
13:54:03 <monochrom> vali's is already good haskell
13:54:04 <ndm> MarcWeber: i added two functions to the library, since they look like they may be quite well used, so you'll need a brand new tagsoup
13:54:10 <MarcWeber> sjanssen: Wait some secs. darcs is no longer up to date
13:54:30 <MarcWeber> ndm: No problem.
13:54:35 <vali> mauke: hmm. but i think filter wants 2 arguments
13:54:42 <mauke> @pl checkMod xs = filter (\x -> x `mod` 3 == 0 || x `mod` 5 == 0) xs
13:54:43 <lambdabot> checkMod = filter (ap ((||) . (0 ==) . (`mod` 3)) ((0 ==) . (`mod` 5)))
13:54:47 <ndm> MarcWeber: please test, and let me know if it fails anywhere :)#
13:54:56 <mauke> nothing wants arguments :-)
13:55:26 <MarcWeber> sjanssen: clone ssh://vl@mawercer.de/vl_repo
13:55:41 <mauke> btw, the last part is probably more readable as liftM2 (||) ((0 ==) . (`mod` 3)) ((0 ==) . (`mod` 5)). it's still insane, of course.
13:55:58 <vali> mauke: that looks very greek to me
13:56:21 <vali> mauke: how can i write it without xs?
13:56:34 <mauke> checkMod = filter (\x -> x `mod` 3 == 0 || x `mod` 5 == 0)
13:56:47 <tibbe> @paste
13:56:48 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:56:52 <sjanssen> @type \x -> any (\y -> x `mod` y == 0) [3, 5]
13:56:55 <lambdabot> forall a. (Integral a) => a -> Bool
13:57:06 <sjanssen> @pl \y -> x `mod` y == 0
13:57:06 <lambdabot> (0 ==) . (x `mod`)
13:57:38 <Saizan> vali: evey function with n arguments is a 1-argument function that returns a n-1 one
13:58:15 <vali> Saizan: hmm
13:58:20 <Cheery> @hoogle m a -> m b -> m a
13:58:21 <lambdabot> Prelude.asTypeOf :: a -> a -> a
13:58:21 <lambdabot> Prelude.const :: a -> b -> a
13:58:21 <lambdabot> Prelude.seq :: a -> b -> b
13:58:40 <Cheery> @hoogle (Monad m) => m a -> m b -> m a
13:58:42 <lambdabot> Prelude.asTypeOf :: a -> a -> a
13:58:42 <lambdabot> Prelude.const :: a -> b -> a
13:58:42 <lambdabot> Prelude.seq :: a -> b -> b
13:58:47 <mauke> checkMod = filter (liftM2 (||) (divBy 5) (divBy 3)) where divBy a b = b `mod` a == 0
13:59:12 <ndm> MarcWeber: i'm off now, but if that turns out not to work, please do email me
13:59:13 <mauke> a << b = do { x <- a; b; return a }
13:59:21 <mauke> er, return x
13:59:32 <Cheery> I just wonder whether it can be expressed more clearly: m >>= m' . return
13:59:37 <MarcWeber> ndm: I will
13:59:42 <sjanssen> MarcWeber: it wants a password
13:59:59 <MarcWeber> vldwp @ sjanssen
14:00:04 <mauke> Cheery: that has the type m a -> (a -> b) -> m b
14:00:13 <mauke> er, wait
14:00:17 <eumenides> ?src asTypeOf
14:00:18 <lambdabot> asTypeOf = const
14:00:41 <mauke> m a -> (m a -> m b) -> m b?
14:00:46 <dmhouse> eumenides: it's the type signature that makes it work. asTypeOf :: a -> a -> a, whereas const :: a -> b -> a.
14:00:47 <mauke> that's just m' m
14:00:52 <ndm> hehe, the whole point of asTypeOf isn't its implementation, its type sig
14:01:29 <dmhouse> asTypeOf is actually pretty pointless, I've never found somewhere where you can't just use a type declaration.
14:01:53 <mauke> it's useful if your type is really big/complicated
14:01:57 <Cheery> mauke: what I'd like to do override the result of eof with the earlier result
14:02:02 <dmhouse> I guess.
14:02:06 <sjanssen> dmhouse: asTypeOf is handy when you don't have scoped type variables
14:02:13 <dmwit> mauke: Sounds like you need a type synonym...
14:02:31 <xerox> > let bounds x = (minBound `asTypeOf` x,maxBound `asTypeOf` x) in bounds Word8
14:02:32 <lambdabot>   Not in scope: data constructor `Word8'
14:02:33 <mauke> Cheery: I use a << b = do { x <- a; b; return a } for that
14:02:33 <xerox> err.
14:02:39 <dmwit> :t \m m' -> m >>= m' . return
14:02:40 <xerox> > let bounds x = (minBound `asTypeOf` x,maxBound `asTypeOf` x) in bounds (undefined :: Word8)
14:02:42 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *) b. (Monad m1, Monad m) => m a -> (m1 a -> m b) -> m b
14:02:42 <lambdabot>  (0,255)
14:02:52 <sjanssen> what xerox said
14:03:28 <sjanssen> MarcWeber: 'vldwp @ sjanssen' is the password?  It doesn't seem to work
14:03:57 <MarcWeber> sjanssen: Without @ sjanssen . The message was for you ;)
14:03:57 <Cheery> @pl (\m m' -> m >>= (m'>>) . return)
14:03:58 <lambdabot> (. ((. return) . (>>))) . (>>=)
14:03:59 <xerox> Anybody knows how to do a clean exit from gtk2hs? Using just `mainQuit' make GTK complain.
14:04:16 <dmhouse> ?undo do x <- a; b; return a
14:04:16 <lambdabot> a >>= \ x -> b >> return a
14:04:28 <sjanssen> MarcWeber: hg doesn't support checking out over the web?
14:04:33 <dmhouse> ?undo do x <- a; b; return x
14:04:34 <lambdabot> a >>= \ x -> b >> return x
14:04:54 <MarcWeber> sjanssen: Don't know. This way you can do hg push to commit your patches ;)
14:04:54 <monochrom> The idiom (do x <- a; b; return a) is so common when I use Parsec that I gave it a name.
14:04:58 <dmhouse> ?. undo pl do x <- a; b; return x
14:04:59 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 3, srcColumn = 26}) "Parse error"
14:05:08 <xerox> other way around (:
14:05:49 <MarcWeber> sjanssen: I would have continued using darcs if I were able to get it working on windows on a computer of my friend.
14:05:50 <dmhouse> ?. pl undo do x <- a; b; return x
14:05:51 <lambdabot> (b >>) . return =<< a
14:06:35 <sjanssen> MarcWeber: what went wrong?
14:08:01 <Cheery> dmhouse: that is equivalent to: a >>= (b >>) . return
14:08:12 <MarcWeber> I can't tell you any more. Didn't work with cygwins .ssh/<keys> and ssh tools. And the recent discussion that darcs has problems if your repo grows really large made me think, too
14:08:24 <Cheery> oh well, maybe it doesn't own a shorthand notation
14:08:32 <Cheery> or function in control monad
14:09:11 <MarcWeber> sjanssen: Are you struggling?
14:09:29 <sjanssen> MarcWeber: checked out the repo, figuring out how to use it
14:09:59 <sjanssen> I'll be back in a couple minutes
14:10:30 <MarcWeber> sjanssen: Do you want to join some live screen chat? Then I can try showing you how to use it ? Ok I'll wait.
14:15:31 <sjanssen> MarcWeber: sure
14:16:10 * nominolo is working on his exercise
14:16:16 <MarcWeber> sjanssen: Wait a minute. I'll create a plain new user. Then it should work ;)
14:16:24 <nominolo> the comparision to prolog really turns out quite well
14:16:33 <nominolo> s/well/helpful/
14:16:39 <tibbe> Implementing a parser is hard work :(
14:17:00 <sjanssen> tibbe: did you see the parser I pasted?
14:17:18 <tibbe> sjanssen, no :(
14:17:19 <hpaste>  sjanssen annotated "a parser that might work" with "forgot to paste the corrected version" at http://hpaste.org/1469#a1
14:17:27 <tibbe> thanks
14:17:40 <sjanssen> I probably missed some things
14:17:52 <sjanssen> like quoting of $
14:17:54 <MarcWeber> sjanssen: Try ssh sjanssen@mawercer.de  screen -x s
14:18:08 <tibbe> I can fix that, just need the general idea
14:19:04 <tibbe> sjanssen, I'll just try to thread keeping track of the current position through that
14:20:57 <tibbe> sjanssen, I'm going to need to look two chars ahead to catch escapes ($$) also
14:21:06 <tibbe> but I should be able to do that :)
14:26:31 <Saizan> TH doesn't like infinite lists..
14:28:35 <tibbe> is there a way to get emacs to indent if statements correctly in a do block?
14:34:50 <ptolomy> Ugh. I'm the worst manager ever. For all of my personal projects, I change requirements randomly as I go along with no real thought of what my end goal is.
14:36:25 <dozer> ptolomy: that only makes you a bad manager if you are acting like that for a project you manage that other people work on :)
14:36:40 <dozer> otherwise, you are a dissorganised coder lol
14:37:50 <balodja> is there a division, that returns tuple of quotient and residual? :)
14:38:03 <ptolomy> @hoogle divRem
14:38:04 <lambdabot> No matches found
14:38:09 <ptolomy> @hoogle divMod
14:38:09 <lambdabot> Prelude.divMod :: Integral a => a -> a -> (a, a)
14:38:19 <balodja> fantastic one
14:38:24 <balodja> ptolomy: thanks
14:38:30 <ptolomy> No prob. :)
14:38:31 <tibbe> call it Agile
14:38:34 * ptolomy loves lambdabot.
14:38:55 <dmwit> ?hoogle (Integral a) => a -> a -> (a, a)
14:38:56 <lambdabot> Prelude.divMod :: Integral a => a -> a -> (a, a)
14:38:57 <lambdabot> Prelude.quotRem :: Integral a => a -> a -> (a, a)
14:38:57 <lambdabot> Control.Monad.RWS.execRWS :: RWS r w s a -> r -> s -> (s, w)
14:39:11 <dmwit> > (divMod -5 -3, quotRem -5 -3)
14:39:13 <lambdabot>        add an instance declaration for (Num (a -> a -> (a, a)))
14:39:13 <lambdabot>     In the ex...
14:39:24 <ptolomy> Well, I was trying to make something minimal, but haskell makes it hard, because it's all "ooh, I can add this feature.. it's only another 3 lines.. ooh, if I extend it to use ErrorT, I can do nicer error handling at a minimal cost.." then my original scope is shot to hell.
14:39:33 <dmwit> > (divMod (-5) (-3), quotRem (-5) (-3))
14:39:35 <lambdabot>  ((1,-2),(1,-2))
14:39:46 <dmwit> > (divMod (-5) 3, quotRem (-5) 3)
14:39:48 <lambdabot>  ((-2,1),(-1,-2))
14:40:33 <balodja> oh, first one is closer to maths
15:12:58 <Saizan> a good name for    foo def f xs = if null xs then def else f xs  ?
15:13:53 <Cheery> How do you catch the <ctrl>-c ?
15:14:11 <Cheery> ie. ^C, which halts the execution
15:14:25 <norpan> applyIfNotNull :)
15:14:29 <rahikkala> Saizan: The best I can come up with is "list", after maybe
15:15:09 <norpan> when would you use such a function
15:15:57 <Saizan> yeah but it's not really like maybe, this doesn't unwrap the monad in the good case
15:16:19 <Saizan> norpan: well mostly when an empty list is an exceptional situation
15:16:51 <sorear> Cheery: I think you want System.Posix.Signals
15:17:05 <sorear> which isn't POSIX-specific, suprisingly enough
15:17:49 <dmwit> Saizan: withDefault ?
15:18:38 <dmwit> > let withDefault d f xs = if null xs then d else f xs in withDefault 0 head []
15:18:40 <lambdabot>  0
15:18:52 <dmwit> (I just wanted to see how it scanned in a real code sample.)
15:19:05 <Saizan> seems good :)
15:20:13 <sorear> @seen
15:20:25 <rahikkala> ifEmpty, ifNull?
15:20:46 <Cheery> hmm, sorear so basically, it may not be possible?
15:21:00 <Cheery> ..with minimal effort
15:21:12 <sorear> Cheery: it's pretty easy
15:22:21 <Cheery> how does it go then?
15:22:33 <sorear> something like: installHandler sigINT (Catch (putStrLn "hi!")) Nothing
15:23:02 <Cheery> it catches the ^C ?
15:23:25 <sorear> on Linux ^C is sent to processes as SIGINT
15:23:52 <ptolomy> Unreasonably vague question: How much of a performance hit can one expect from basic use of typeclasses (that require decision at runtime) on code compiled with GHC?
15:24:25 <xerox> Saizan, if you change |f xs| to |map f xs| is very much like |maybe|.
15:24:51 <sorear> ptolomy: it depends.
15:25:14 <sorear> ptolomy: typeclasses block a lot of other optimizations - Int code can be unboxed, etfc
15:25:42 <Saizan> xerox: yes, but less flexible, plus list is yet foldr :)
15:25:58 <monochrom> same performance hit as virtual functions in c++. virtual method table and dynamic dispatch.
15:26:35 <Cheery> sorear: ok, I think it will go then
15:26:38 <ADEpt> @src minimum
15:26:38 <lambdabot> minimum [] = undefined
15:26:39 <lambdabot> minimum xs = foldl1 min xs
15:27:07 <Cheery> wow, 1:25 already.
15:27:16 <Saizan> > minimum []
15:27:18 <lambdabot>  Exception: Prelude.minimum: empty list
15:27:30 <ptolomy> sorear: I'm mainly passing around a lotta ByteStrings, and it occurred to me that many of them are getting parsed over and over, so I was thinking "Hey, if I pass around a 'Foo B.ByteString (Maybe Parsed)', I could use laziness to parse things once. Except, everything accepts ByteString arguments..
15:27:40 <ptolomy> I forgot where I was going with that.
15:27:58 <Cheery> I enjoyed so much toying with this thing that I almost forgot that I should sleep as well
15:28:18 <ptolomy> beyond "Man, I bet if I had given things nicer types to begin with and were better at haskell, this would be much easier."
15:29:11 <johnnowak> ptolomy: having one change affect 50 functions is always fun
15:30:02 <ptolomy> See, in this situation, if I were using a dynamically typed language, I'd find this not too difficult.
15:31:09 <johnnowak> quite possibly
15:31:11 <Saizan> do you access these bytestring directly with many functions?
15:32:08 <Saizan> if you mostly work on the parsed result you might have to change the parsing function and not much more
15:32:39 <ptolomy> Saizan: Sometimes... On second thought, this is probably more an issue of me typing things sloppily to begin with.
15:33:37 * ptolomy needs to put more thought into what types his functions really should have before blaming haskell for not looking the other way and letting him do a dirty hack.
15:34:42 <johnnowak> ptolomy: sometimes you have to sketch things out first to now what those types should be
15:34:44 <ptolomy> Sometimes Haskell feels like a personal trainer for proper program construction. You half-ass something, and the compiler doesn't let you get away with it and won't let you move on til you do it right.
15:34:47 <Saizan> i think a good way to avoid this is to write your program as a stack of abstractions
15:35:22 * sorear doesn't know any other way to write programs?
15:35:42 <sorear> @remember ptolomy Sometimes Haskell feels like a personal trainer for proper program construction. You half-ass something, and the compiler doesn't let you get away with it and won't let you move on til you do it right.
15:35:43 <lambdabot> Done.
15:35:50 <sorear> @uptime
15:35:50 <lambdabot> uptime: 3d 20h 9m 32s, longest uptime: 5d 3h 40m 45s
15:35:51 <sorear> @flush
15:36:04 <Saizan> sorear: you can poke down to the contrete datatype everytime you have to do something :)
15:36:22 <sorear> er, I can?
15:36:23 <sorear> ;)
15:36:37 <Saizan> :D
15:43:07 <Saizan> how should i set inferior-haskell-type for haskell-mode? "ghci" ?
15:43:19 <sorear> I think so
15:43:43 <sorear> hmm, I get  a void-variable-error when I ask for its value :(
15:44:05 <Cheery> it felt actually quite great to make that small language, now I just need to remember NOT to refactor it
15:44:08 <Saizan> heh, same problem when trying to auto-insert a typesign
15:44:50 <sorear> always try M-x customize-variable furst
15:45:28 <Cheery> hmm, neural networks, patterns and some opengl
15:46:25 <Cheery> I wonder how would I approach those and put something together...
15:46:59 <sorear> I wouldn't worry about patterns, any haskell prog you write will have plenty of them.
15:47:17 <Cheery> ah, not programming patterns
15:47:29 <Saizan> mmh, no match, it error mentions "function definition" mmh..
15:47:34 <sorear> Cheery: I thought you meant (x:xs) patterns ;)
15:48:09 <sorear> Saizan: run 'locate inf-haskell.el', and M-S-: (load "/each/file/in/the/directory")
15:48:16 <Cheery> sorear: well, with pattern I mean a bit more general thing, the concept of pattern
15:48:29 <sorear> autoload is broekn for some reason with inf-haskell :(
15:48:45 <dmwit> 2, 2, 2, 2, 2
15:48:49 <dmwit> Can you guess the pattern?
15:49:00 <sorear> I see lots of them.
15:49:03 <dmwit> Hint: It comes from a six-degree polynomial.
15:49:13 <sorear> Muahahaha!
15:49:22 <dmwit> =)
15:49:40 <sorear> there is a unique degree-five polynormial that generates that
15:49:49 <sorear> so just gimme one more term
15:49:58 <dmwit> sorear: Yeah, assuming they each have different x-coordinates...
15:50:04 <sorear> then I promise I'll be able to predict it!
15:50:18 <sorear> dmwit: I thought those were x=1,2,3,4,5 ;)
15:50:28 <dmwit> Assumptions, assumptions!
15:50:40 <dmwit> Patterns are hard. =)
15:51:32 <Cheery> gah, going to sleep before you guys manage to make me push code until morning.
16:03:13 <dolio> @djinn (a -> a -> Bool) -> a -> a -> (b, c) -> Either b c
16:03:13 <lambdabot> f a b c =
16:03:14 <lambdabot>     case a b c of
16:03:14 <lambdabot>     False -> \ (d, _) -> Left d
16:03:14 <lambdabot>     True -> \ (_, e) -> Right e
16:03:29 <dcoutts> xerox: mainQuit is right. If it complains, there's a reason. What does it say?
16:03:54 <xerox> dcoutts, I used another approach
16:03:59 <sorear> hiya dcoutts
16:04:17 <xerox> let me see if I can replicate it again
16:04:49 <xerox> (Arnold:19144): Gtk-CRITICAL **: gtk_main_quit: assertion `main_loops != NULL' failed
16:07:23 <dcoutts> @tell shapr we deliberately did not include BS.Lazy.toStrict and BS.toLazy because we don't want people to think they're cheap, they are easy to write of course in terms of to/fromChunks and concat.
16:07:23 <lambdabot> Consider it noted.
16:08:11 <sorear> BS.toLazy isn't cheap?
16:08:37 <dcoutts> hia sorear, xerox
16:08:39 <dcoutts> sorear: it's cheap, but the other way around is not
16:08:46 <xerox> hello Duncan :)
16:09:18 <dcoutts> xerox: apparently you were not in the main loop when you called mainQuit
16:10:03 <dcoutts> xerox: mainQuit is for exiting the mainGUI event loop, it's not got much to do with terminating the program
16:10:19 <xerox> dcoutts, the idea is that I start the program showing a FileChooserDialog, and then proceed if I can get a file, or exit if I could not.
16:10:20 <dcoutts> though that's what often happens after the call to mainGUI
16:10:47 <xerox> (much like the FastDraw demo)
16:11:18 <dcoutts> xerox: so you use dialogRun ?
16:11:38 <xerox> yes
16:11:46 <dcoutts> and depending on the result of that you can end the program or do something else
16:12:12 <dcoutts> ending the program has nothing to do with gtk
16:12:15 <xerox> right, in fact on the result of |fileChooserGetFilename chooser|
16:12:20 <dcoutts> you just do that normally
16:12:44 <xerox> right, it indeed worked exiting normally
16:13:23 <xerox> unfortunately I also hit another wall
16:13:51 <xerox> I got the PixbufData out of a PixBuf, and then used mapIndices on it
16:14:11 <xerox> mapIndices in turn uses newArray_ but it is not implemented for PixbufData
16:15:05 <xerox> http://darcs.haskell.org/gtk2hs/gtk/Graphics/UI/Gtk/Gdk/PixbufData.hs.pp
16:15:08 <lambdabot> http://tinyurl.com/2yfsdh
16:15:14 <xerox>   newArray_ (l,u)  = error "Gtk.Gdk.Pixbuf.newArray_: not implemented"
16:15:17 <sorear> dabbrev in my Haskell source has started completing nicknames :)
16:15:20 <sorear> emacs++
16:16:23 <xerox> dcoutts, the solution without mapindices is much uglier, any idea?
16:16:33 <dcoutts> xerox: aye, it only allows you to mutate the pixbuf data
16:16:46 <dcoutts> xerox: you can make a new array and construct a pixbuf from that later
16:16:54 <xerox> I want to scramble it around, based on a function on indices :D
16:17:04 <dcoutts> you'll need to make a new pixbuf
16:20:09 <xerox> dcoutts, this can be added as gtk2hs demo if you wish, may I pm you? I have some other complicated details to discuss.
16:20:45 <dcoutts> sure
16:21:13 <sorear> @seen malcolmw
16:21:14 <lambdabot> I saw malcolmw leaving #haskell-soc, #ghc, #haskell-overflow and #haskell 2d 6h 36m 47s ago, and .
16:22:56 <thoughtpolice> ?source reverse
16:22:57 <lambdabot> reverse not available
16:23:00 <thoughtpolice> :( aw
16:23:09 <sorear> ?src reverse
16:23:10 <lambdabot> reverse = foldl (flip (:)) []
16:23:24 <sorear> I'm sure that is much more helpful ;)
16:23:40 <thoughtpolice> go figure :x
16:23:49 <thoughtpolice> never really used lambdabot
16:25:35 <thoughtpolice> i'm liking the SoC projects for haskell this year. i bet many people (ghc devs?) are probably really pulling for the darcs fix, and i'm personally looking forward to shared library support
16:26:31 <encryptio> @pl \x -> f [x]
16:26:32 <lambdabot> f . return
16:28:03 <chessguy> hi haskellers
16:35:08 <MarcWeber> @tell sjanssen Hi. You can now login to my local machine. The next time I'll be prepared better (I hope)
16:35:09 <lambdabot> Consider it noted.
16:39:27 <ndm> @seen augustss
16:39:28 <lambdabot> I haven't seen augustss.
16:40:44 <ndm> @tell augustss have you seen "http://video.google.com/videoplay?docid=-4851250372422374791" - they go through Djinn
16:40:45 <lambdabot> Consider it noted.
16:47:06 * sorear_ curses ip conn...
16:47:11 <sorear_> hello ndm
16:47:37 <ndm> hi sorear_
16:48:29 <ndm> i think i've figured out how to make my PhD work, do less work, do less coding, do less proof and acheive better results :)
16:48:42 <sorear> yay!
16:48:44 <Botje> you hack it together in perl?
16:48:51 <chessguy> true lazy style!
16:48:55 <ndm> nope, an additional 10 lines of haskell
16:49:00 <ndm> to write a super-optimiser :)
16:49:24 <sorear> oh, you've figured out how to automatically derive papers from code in Derive?
16:49:30 <Botje> make sure to invent strangely-shaped combinators.
16:49:49 <ndm> not quite yet
16:50:26 <ndm> no combinators, although i am doing some for my Play paper
16:50:34 <ndm> i have dibs on |+ and |-
16:50:51 <dmwit> ?djinn (a -> b -> c) -> (a -> b) -> a -> c
16:50:52 <lambdabot> f a b c = a c (b c)
16:51:12 * sorear starts the haskell varsym registry
16:51:20 <sorear> dmwit: aka, ap ;)
16:51:25 <dmwit> :t ap
16:51:28 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:51:31 <dmwit> Not quite, though, right?
16:51:38 <sorear> no, ap will do it
16:51:44 <mauke> ?. pl djinn (a -> b -> c) -> (a -> b) -> a -> c
16:51:44 <lambdabot> f = ap
16:51:51 <dmwit> !
16:51:53 <sorear> > ap (++) show "ap (++) show"
16:51:55 <lambdabot>  "ap (++) show\"ap (++) show\""
16:52:02 * dmwit leaves to write on paper and think for a while
16:52:04 <mauke> haha
16:52:19 <chessguy> @djinn a -> b
16:52:20 <lambdabot> -- f cannot be realized.
16:52:39 <sorear>  @djinn-add unsafeCoerce# :: a -> b
16:53:08 <chessguy> is that "f can provably not be realized" or "f cannot be realized by djinn"?
16:53:19 <sorear> provably cannot.
16:53:25 <mauke> ... by djinn
16:53:36 <chessguy> proof by djinn :)
16:53:38 <sorear> no, djinn is a capable disprover.
16:53:40 <chessguy> so what's the proof?
16:53:43 <mauke> @djinn [a] -> Int
16:53:44 <lambdabot> -- f cannot be realized.
16:53:54 <ndm> chessguy, do you really want to see it? usually proofs are horrid
16:54:17 <ndm> the Catch proofs are typically pages long, and they used to be 1000 pages regularly
16:54:18 <sorear> when it says f cannot be realized, it means you absolutely cannot write the function in question without recursion or rank-2 types.
16:54:21 <chessguy> ndm: just some kind of intuition about how such a proof would go is fine
16:54:38 <sorear> mauke's function requires recursion
16:54:39 <ndm> (the new system is always a few pages at most, thanks to cleverness)
16:54:52 <chessguy> oh, well that's a little different
16:54:53 <ndm> chessguy, automatic proofs don't have intuition
16:55:10 <chessguy> ndm: i'm not necessarily talking about a proof djinn can generate
16:55:31 <sorear> ndm: ouch, processing 1000 pages of data in a lazy functional language ... that's gotta hurt :)
16:55:44 <monochrom> What does "f : a->b" represent?  (This is a guiding question.)
16:55:45 <chessguy> ok, let me back up. forget djinn. can it be proven that no function in haskell can have a primary type of a -> b
16:56:07 <ndm> sorear, generating is painful, spooling it to disk is pretty slow, reading and finding the bugs is a nightmare!
16:56:32 <chessguy> monochrom: a function from domain a to range b
16:56:34 <mauke> sorear: what. f _ = 0
16:57:04 <sorear> mauke: oh, yes.  you also need to use types djinn supports ;)
16:57:19 <monochrom> djinn is doing propositional intuitionistic logic.  "f:a->b" refers to f capable of transforming a proof of "a" to a proof of "b".  This f has to work for all a,b.
16:57:21 <sorear> chessguy: no, it can't.  'f _ = undefined'
16:57:50 <chessguy> sorear: ambiguous use if "it"
16:57:54 <sorear> chessguy: w/o undefined, then it still can't.
16:57:55 <chessguy> of
16:58:21 <sorear> chessguy: to prove that (a -> b) is impossible is to prove the consistency of the host logic
16:58:33 <monochrom> Hmm I'm using too much detail.  I can simply say, f is a proof of "a implies b", and this proof has to work forall a,b.
16:58:33 <sorear> chessguy: see go:del's incompleteness theorem
16:59:13 <sorear> It has been proven that you can't prove that you can't prove forall a b. a -> b.
16:59:33 <chessguy> ummmm
16:59:36 <chessguy> ok...
16:59:43 <monochrom> Now, we construct a model or interpretation of propositional intuitionistic logic.  It satisfies all the axioms of intuitionistic logic.  But it is designed so that "true implies false" is wrong.
16:59:45 <sorear> try that on for tounge twisting!
16:59:50 <sorear> @spell tounge
16:59:52 <lambdabot> tonger tongue tong tung tonnage
17:00:11 <chessguy> tonnage twisting!
17:00:39 <monochrom> It is not hard because even a model for classical logic has the same property.
17:01:45 <chessguy> ok, but in general, you most likely can't have a function of type a -> b in haskell?
17:02:12 <sorear> sure you can.
17:02:18 <monochrom> OK, I was still using more details than necessary.  If there is "f : a->b", then it can be instantiated to "f : true -> false".  Contradiction.
17:02:19 <sorear> @type let f _ = undefined in f
17:02:22 <lambdabot> forall t a. t -> a
17:02:25 <sorear> haskell /= logic
17:02:47 <monochrom> In this logic I'm discounting partial functions.
17:02:48 <mauke> why t and not b?
17:02:56 <chessguy> what about partial functions?
17:03:36 <Philippa> if you admit partial functions you just get bottom
17:03:37 <monochrom> f _ = undefined    is a partial function.
17:03:52 <chessguy> err, complete functions i guess i mean then
17:04:00 <monochrom> total function.
17:04:11 <chessguy> yeah, them there thingies
17:04:36 <monochrom> The foregoing argument is about total functions.
17:04:45 <chessguy> is it possible to have a total function with type a -> b
17:04:48 <chessguy> in haskell?
17:04:53 <monochrom> There is no total function f satisfying f:a->b
17:05:01 <monochrom> No.
17:05:15 <chessguy> but you can't prove it, right?
17:05:22 <monochrom> The foregoing argument applies to total functions in haskell.  Haskell has partial functions in addition.
17:08:13 <monochrom> To be fair, haskell is a practical, real language, meaning its full semantics is complex.  If I ignore certain things (nothing wrong with that as long as I'm honest about it), I get a simple logic and I can say alot about its properties.  Clearly such properties probably don't apply to what I have declared to ignore.
17:08:14 <chessguy> i think i'm sorry i asked :)
17:11:21 <monochrom> The important technical point here is: to understand djinn's claims, read -> as implication, and bear in mind the logic is intuitionistic, with weaker power than classical logics (certain classical axioms are absent in intuitionistic logic).
17:12:47 <monochrom> read -> as implication, (a,b) as conjunction, Either a b as disjunction, () as true, a fictitious type with no value as false.  That will get you very far.
17:14:00 <sorear> and pretend every type variable is implicitly universally quantified
17:14:35 <monochrom> I am not sure whether djinn's language allows you to express the fictitious empty type.  But Coq does.  Coq is like djinn except it also has quantifiers (forall and exist), i.e., you can do first-order or even higher-order logic, not just propositions.
17:14:47 <sorear> @djinn-env
17:14:48 <lambdabot> Plugin `djinn' failed with: IRCRaised Data.ByteString.last: empty ByteString
17:14:56 * sorear beats up djinn
17:15:01 <sorear> monochrom: it's called 'Void'
17:15:15 <monochrom> @djinn Void -> ()
17:15:16 <lambdabot> f = void
17:15:30 * chessguy sighs and wonders why gmail can't automatically delete any email with 2-inch font
17:15:30 <ddarius> What is with long haired crazy looking Haskell programmers?
17:15:33 <monochrom> The empty function! Heh! Nice!
17:15:34 <sorear> @djinn Either (a -> Void) (b -> Void) -> (a, b) -> Void
17:15:35 <lambdabot> f a =
17:15:35 <lambdabot>     case a of
17:15:35 <lambdabot>     Left b -> \ (c, _) -> b c
17:15:35 <lambdabot>     Right d -> \ (_, e) -> d e
17:15:42 <sorear> de Morgan's law!
17:16:22 <sorear> monochrom: anyway, isn't coq kinda undecidable? ;)
17:17:53 <monochrom> In the British history of its constitution, the notion of "king/queen in parliament" was developed.
17:18:17 <Pseudonym> Well, one direction of it, anyway.
17:18:37 <monochrom> The relevance of that is: there is the corresponding notion of "Coq in human hand", and that is decidable. :)
17:19:10 <sorear> ndm: how much detail should exist in derive.htm?
17:19:19 <dibblego> I hate arguing with Java developers over laziness
17:19:39 <dibblego> "I don't want to explicitly specify strictness because I might forget"
17:19:47 <sorear> ndm: where do you want the detailedish documentation for instances (1 paragraph) to go?
17:19:48 <monochrom> Don't argue. Laziness in language is a nice bonus but not extremely necessary.
17:19:52 <mauke> "now you're just being lazy"
17:19:55 <dibblego> this person is using Ruby
17:19:56 <monochrom> hahahhaha
17:20:00 <sorear> I don't want to explicitly specify Laziness.
17:20:07 <monochrom> No need to argue.
17:20:08 <dibblego> then got all antsy pantsy because I said this behaviour is "absurd"
17:20:17 <jcreigh> dibblego: which behavior?
17:20:37 <dibblego> the behaviour of "making everything strict so that I don't have to remember to explicitly specify strictness"
17:20:52 <sorear> Laziness, like bignums, is something that must be the default because 99.99% of programmers are to stupid/lazy to get it, despite being the safe default.
17:21:11 * sorear resents Int even being in the Prelude
17:21:15 <ndm> sorear, i don't mind - either in the language docs or in the haddock - perhaps linking each documentation to its haddock entry
17:21:24 <ndm> sorear, you don't want bignums, you want lazy naturals!
17:21:25 <monochrom> It's now pretty clear that eagerness means easy resource accounting, hard answer reasoning; and laziness is the other way round.
17:22:02 <ndm> monochrom, no point worrying about resource counting when your code dosn't work
17:22:02 <sorear> IMHO computers exist to solve problems.
17:22:13 <dibblego> I has denigrated to using ad hominem debate
17:22:20 <sorear> not to minimize resource use!
17:22:21 <ndm> and you can buy more RAM, but not more correct answers
17:22:26 <dibblego> I am this and that because *I* fail to see "the other side"
17:22:29 <monochrom> Many people think computers exist to make money.
17:22:32 <dibblego> fuck these people
17:22:45 <sorear> ndm: "Hello, Galois Connections, I need the right answer to ..."
17:22:53 <sorear> :)
17:23:30 <ndm> my question is why I can keep crashing hugs
17:23:55 <monochrom> You need to give it more hugs.
17:24:28 <monochrom> Anyway don't get into arguments.  Gets nothing done and nobody to change minds.
17:24:29 <Philippa> sorear: it's easy to say minimising resource use doesn't matter when you have all the resources you personally need
17:24:55 <ndm> Philippa, its hard to mention resources when your code doesn't work
17:25:00 <dibblego> well, I was hoping to inform and have rational debate - my metaphors are ridiculued, but I only use them to simplify the situation for the feeble mind
17:25:26 <dibblego> and what kind of pussy is offended by having a certain behaviour described as "absurd"?
17:25:37 <Philippa> ndm: running out of resources is a form of not working
17:25:39 <dibblego> I really need to hang around more researechers
17:26:42 <monochrom> "this program answers x using no more than y memory and z time" is a full correctness specification.
17:27:12 <dibblego> agreed, but there is no way in hell we were ever going to get to that
17:27:15 <Philippa> in some communities, absurd is essentially a neat way of saying a big string of obscenities followed by "stupid and pointless"
17:27:43 <dibblego> well I mean absurd as in "if I bang my head on a wall, then turn around and claim to dislike pain, my behaviour is absurd - contradictory"
17:28:15 <Philippa> right. Which means exactly the same thing in this context
17:28:20 <monochrom> So, I was saying I agree with Philippa. :)
17:28:33 <Philippa> (though there are other reasons someone might still bang their head on a wall at least somewhat deliberately)
17:29:02 <ddarius> Plenty.  Furthermore you are assuming that them banging their head on the wall is painful to them. </Mr. Pedantic>
17:29:18 <monochrom> You need a paraconsistent logic to reason about people.  paraconsistent logic means it handles contradictions nicely.
17:29:57 <Philippa> IME you don't generally
17:30:11 <Philippa> what you do find out is that you were often missing a significant piece of knowledge or 50
17:30:14 <dibblego> it gets better in research right?
17:30:25 <dibblego> you actually find people who can reason using first-order logic and stuff?
17:30:25 <ddarius> dibblego: I would have just asked why they thought that they needed (to specify) strictness/what would happen if they "forgot" it?
17:30:38 <dibblego> ddarius, a performance degradation (apparently)
17:30:57 <dmwit> Only in some cases.
17:31:06 <ddarius> @google "More Speed, Less Haste"
17:31:13 <lambdabot> http://www.heritage.org/Press/Commentary/ed012204a.cfm
17:31:13 <lambdabot> Title: More Speed, Less Haste: Don&#39;t Rush Elections In Iraq
17:31:20 <ddarius> Damn.
17:31:21 <dibblego> though, "degradation" is the wrong word - it is a space/computation trade
17:31:22 <Philippa> if you get the demand exactly right, laziness is almost always slower
17:31:45 <ddarius> Especially those cases where the strict program is meaningless
17:32:08 <dmwit> Philippa: What if your algorithm computes many solutions, but you need only one?
17:32:45 <dmwit> (I.e. suppose it is not known until runtime _which_ solution is needed...)
17:33:00 <sorear> @google "More Haste, Less Speed"
17:33:04 <lambdabot> http://www.phrases.org.uk/bulletin_board/22/messages/445.html
17:33:04 <lambdabot> Title: more haste, less speed
17:33:05 <encryptio> that's a common need for me - a list of possibilities. it's trivial in haskell to fix it up to only compute as much as the first one, but in perl it's difficult and verbose.
17:33:31 <ddarius> I can never remember the correct permutation of those words.
17:33:38 <monochrom> Then "get the demand right, even at programming time" is extremely hard but still, the claim "if you can do that then you beat laziness" is right.
17:33:59 <dibblego> do academics generally reason better and are more open to the possibility that they are wrong, than industry professionals?
17:34:16 <monochrom> quite a bit. but not too much better
17:34:17 <ddarius> dibblego: Aren't those highly related?
17:34:35 <dibblego> "proclaimed industry professional"
17:34:43 <dmwit> Okay, I see.
17:34:50 <Philippa> dibblego: yes, but only because the reverse is near-impossible
17:35:35 <ddarius> Sure, 15 years "in the trenches" MUST mean that you know all there is to know about software development.
17:35:54 <ndm> woohoo, I can get Hugs to non-terminate and to segfault
17:36:21 <monochrom> make hugs, not segfaults!
17:36:21 <dibblego> I am afraid that I am surrounded by these people and forever will be
17:36:26 <dmwit> ?wn anorak
17:36:29 <lambdabot> *** "anorak" wn "WordNet (r) 2.0"
17:36:29 <lambdabot> anorak
17:36:29 <lambdabot>      n : a kind of heavy jacket (`windcheater' is a British term)
17:36:29 <lambdabot>          [syn: {parka}, {windbreaker}, {windcheater}]
17:36:30 <ddarius> ndm: Just take Hugs out back and put it down.
17:36:31 <dibblego> s/#haskell/#counselling
17:37:16 <ddarius> dibblego: Go to #lisp and you'll like those people much more!
17:37:30 * dibblego suspects a trap
17:37:54 <mauke> http://adrinael.net/tarp.jpg
17:37:56 <monochrom> You also need to review yourself.  have you been too confrontational to be productive?  to get other people to see your point and get things done does not require confrontation or even a right-wrong debate.
17:37:59 <Philippa> when they pull the 15 years line, tell them you spent 15 years with their mum and you know /all/ about them
17:38:13 <dibblego> monochrom, yes I have
17:38:35 <ndm> ddarius, just about to send an email to the hugs-bugs list - i can make it crash, do silly things and non-terminate at compile time
17:38:35 <dibblego> though, too "confrontational" is referring to behaviour as absurd and contradictory
17:38:39 <monochrom> Philippa is baaaaaaaaaaad :)
17:39:12 <dibblego> I don't believe in baaaaad
17:39:17 <ddarius> monochrom: Especially considering her age...
17:39:32 <dibblego> if confrontation leads me or another party to learn something, then I'm all for it
17:40:01 <dibblego> maybe I should tell a few polite lies
17:40:10 * ddarius is all for violence if it leads me or another party to learn something.
17:40:11 <dmwit> dibblego: I bet it won't ever do that for you, though... ;-P
17:40:18 <ddarius> Actually... the learning something is optional.
17:40:40 <dibblego> confrontation is the single most effective way to learn for me
17:40:53 <Philippa> ddarius: remind me, do you know know how old I actually am?
17:40:56 <sorear> @quote corners
17:40:56 <lambdabot> narain says: ah, #haskell, where you can ask a simple question and be taken on a whirlwind tour of the unique corners of the language
17:40:59 <sorear> @quote corners
17:40:59 <lambdabot> narain says: ah, #haskell, where you can ask a simple question and be taken on a whirlwind tour of the unique corners of the language
17:41:06 <sorear> @quote corners.*pub
17:41:07 <lambdabot> No quotes match. Do you think like you type?
17:41:13 <sorear> @quote oleg.*corn
17:41:14 <lambdabot> edwinb says: where does 'Oleg cornered me in a pub and explained delimited continuations to me' fit in?
17:41:52 <ddarius> Philippa: I think I did at one point, but I've long since forgotten.  I'm making wild mildly educated guesses.  At any rate, it would be quite wrong for -me- to say such a line.
17:42:01 <ddarius> For sorear to say it, it would be hilarious.
17:42:23 <monochrom> haha
17:42:31 <Philippa> :-) Yeah, on that basis it would suggest I was an early starter
17:49:50 <dmwit> ?quote edge
17:49:51 <lambdabot> sorear says: we can't explain stuff like creativity so in human languages we have to wedge it in as a primop
17:50:14 <dmwit> ?quote
17:50:14 <lambdabot> merus says:  Mathematics is totally full of women.
17:50:22 <dmwit> heh
17:50:25 <dmwit> ?quote women
17:50:25 <lambdabot> merus says:  Mathematics is totally full of women.
17:50:30 <dmwit> ?quote woman
17:50:31 <lambdabot> S.Behrens says: Computer science is the womanizer, and math is the pure-hearted girl he won't call the next day.
17:50:53 <jcreigh> s/the/a/?
17:51:05 <dmwit> *nod*
17:51:30 <dmwit> ?quote jcreigh
17:51:30 <lambdabot> jcreigh says: it seems silly that map isn't (Functor f) => (a -> b) -> f a -> f b; what's the point of a rich type system if you don't use it?
17:51:55 <jcreigh> I wonder how you would go about making a "fix-quote" or "unremember" feature.
17:52:29 <dmwit> Why, because of fmap?
17:52:43 <jcreigh> dmwit: no, I was thinking of fixing S.Behren's quote
17:52:54 <dmwit> aha
17:52:59 <jcreigh> and, in general, sometimes I make a typo, and then get quoted varbatim. :)
17:53:15 <dmwit> :t ap
17:53:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:53:59 <encryptio> @pl \x -> length (fst x) == 0
17:53:59 <lambdabot> (0 ==) . length . fst
17:54:25 <mauke> null . fst
17:54:25 <dmwit> null . fst
17:54:34 <mauke> @quote stereo
17:54:35 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
17:54:39 <dmwit> length doesn't play well with infinite lists...
17:54:48 <ddarius> jcreigh: I feel that that quote is correct.
17:55:15 <dmwit> :t undefined :: (a -> b) -> r
17:55:17 <lambdabot> (a -> b) -> r :: forall a b r. (a -> b) -> r
17:56:24 <jcreigh> ddarius: appears you are correct http://www.linuxjournal.com/node/8850/print
17:56:26 <lambdabot> Title: Everything Your Professor Failed to Tell You About Functional Programming
17:56:28 <dmwit> Okay, I finally understand why ap is also the s-combinator.
17:58:34 <ddarius> Both S and ap for the environment monad represent application in an environment.
18:01:32 <encryptio> @hoogle [Maybe a] -> Maybe [a]
18:01:33 <lambdabot> No matches, try a more general search
18:01:46 <dmwit> :t msum
18:01:48 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
18:01:51 <dmwit> :t foldM
18:01:54 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
18:02:02 <dmwit> :t sequence -- here we go
18:02:04 <lambdabot>     Ambiguous occurrence `sequence'
18:02:05 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
18:02:13 <dmwit> :t Control.Monad.sequence
18:02:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
18:02:20 <encryptio> aha.
18:03:02 <dmwit> :t catMaybes
18:03:05 <lambdabot> forall a. [Maybe a] -> [a]
18:03:50 <jcreigh> Oh my, another buzzword. "Concurrency Oriented Programming".
18:06:03 * QtPlatypus thinks that "Oriented" is a meta buzzword.
18:06:48 <Philippa> a buzzword constructor?
18:07:02 <monochrom> Yeah!
18:07:25 <jcreigh> I try to avoid praticing "Oriented" Oriented programming.
18:07:38 <dmwit> Maybe more like a monadic lift, so that if you have it anywhere, you can't get out of buzzword-land. =)
18:08:03 * ddarius practices DisOriented Programming!
18:08:20 <monochrom> The type constructor IO is both a type constructor and a lift.
18:08:28 <monochrom> Same to Oriented.
18:08:57 <dmwit> > IO 3
18:08:58 <lambdabot>   Not in scope: data constructor `IO'
18:09:08 <dmwit> Oh, type constructor.
18:09:10 <dmwit> Okay.
18:09:22 <dmwit> =)
18:09:40 <monochrom> Oh, I see.  The type constructor is "IO".  The corresponding functor lift is "fmap".
18:09:54 <monochrom> In category theory one uses the same name for both.
18:10:05 <ddarius> Usually.
18:11:03 <newsham> anyone know of a collection of lambda expression evaluators?  in particular really small ones.  worlds smallest?
18:11:35 <mauke> .oO( Perl )
18:11:50 <monochrom> smallest in source code size?  smallest in machine code size?
18:11:52 <ddarius> mauke: Psh
18:12:00 <newsham> either.
18:12:10 <newsham> (mostly source, but the other would be interesting too)
18:12:22 <monochrom> Because shell script avails the smallest in source code size.  just write ghc -e $1
18:12:49 <QtPlatypus> newsham: http://perl.plover.com/lambda/
18:12:51 <lambdabot> Title: Perl Contains the Lambda-Calculus
18:13:13 <jcreigh> monochrom: well, if you're going to play that game, Haskell is even smaller: All you have to do is prepend the empty string. :)
18:13:32 <newsham> i dont think "using a language's lambda expression" counts.
18:13:36 <monochrom> yeah, I guess so
18:13:37 <newsham> (for ghc or perl)
18:14:21 <ekidd> More probability monad fun, this time with robots:
18:14:24 <ekidd> http://www.randomhacks.net/articles/2007/04/19/robot-localization-particle-system-monad
18:14:27 <lambdabot> Title: Robot localization using a particle system monad, http://tinyurl.com/2zat6b
18:14:56 <ekidd> I've been meaning to get this up for a couple of weeks.
18:15:04 <ddarius> @google Jot programming language
18:15:06 <lambdabot> http://www.jot.fm/issues/issue_2004_12/article5
18:15:07 <lambdabot> Title: JOT: Journal of Object Technology - Bigloo.NET: compiling Scheme to .NET CLR - B ...
18:15:25 <ddarius> Bah!
18:16:02 <monochrom> Let me crack that website.
18:16:16 <monochrom> It will read "Journal of Obfuscation Technology"
18:22:45 <Philippa> hmm. Perhaps "multi-paradigm" languages should be known as "fluidly-oriented languages"?
18:23:07 <jcreigh> oh, here's a gem of a name I've just thought of: "programming language"
18:23:25 <monochrom> synergy-oriented.  note that synergy is also a hot word, many people love it
18:24:10 <encryptio> is there some function that does the same as: do { a <- func1; func2; return a } ?
18:24:10 * monochrom recommends jcreigh to also attach numbers, e.g., programming language one, programming language two, ...
18:24:28 <jcreigh> heh.
18:24:35 <mauke> I don't think there's a predefined function
18:24:38 <sorear> back.
18:24:45 <ddarius> liftM2 const
18:25:17 <encryptio> cool.
18:25:22 <sorear> encryptio: (*>), but only for Applicative
18:25:28 <mauke> (<<) = liftM2 const
18:25:31 <jcreigh> that would be fun: "I profiled 17, and it beats the crap out of 13 on async IO. Too bad it's not as well supported as 22."
18:25:45 <sorear> encryptio: of course, Applicative should be a superclass of Monad
18:27:08 <sorear> @seen ndm
18:27:08 <lambdabot> I saw ndm leaving #haskell 30m 1s ago, and .
18:32:15 <ekidd> sorear: I'm slowly clearing out my to-do list, and will get back to the CUFP stuff soon.
18:32:24 <sorear> ekidd: huh?
18:32:33 * sorear is not a CUFP
18:32:53 <sorear> did you mean shapr?
18:33:07 * sorear isn't even old enough to be employed!
18:33:07 <ekidd> Wait, I'm confused. :-) I guess it's been too long since I've been on #haskell.
18:33:18 <ekidd> @seen shapr
18:33:18 <lambdabot> shapr is in #haskell-blah and #haskell. I last heard shapr speak 5h 38m 3s ago.
18:33:23 <shapr> ?
18:33:24 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
18:33:24 <ddarius> sorear: Yes you are.
18:33:51 <shapr> hiya ekidd
18:34:19 <shapr> I just got back from two weeks vacation
18:34:52 <ekidd> shapr: I haven't forgotten about the CUFP deadline! :-) Tonight's monad post was the last major piece of writing on my to-do list before the talk proposal.
18:35:26 <sorear> I only mentioned shapr because I tend to mix up things with the same first letter, and he is a CUFP.  I am probably completely wrong.
18:35:38 * ekidd would prefer not to have taxes, a work deadline, and a cold all in the same month, but it happens sometimes
18:36:22 <ddarius> I had two out of three of those, but then some other things to replace "a work deadline", some of them deadline-esque.
18:39:31 <ekidd> Yeah, I'm going to be in crunch mode for the next month, too--between paper submissions and *another* work deadline, I'm not sure when I'll get to sleep.
18:39:46 <ekidd> At least I'll get to do some Haskell!
18:40:10 <ddarius> Actually, I don't think I have/had a cold, I just think I'm allergic to the state I'm in.  It -is- Texas.
18:41:20 <ekidd> The snow hasn't finished melting up here, yet. We had a storm within the last week, and there's a few small clumps that still need to melt off.
18:42:26 <ekidd> So Texas doesn't sound too bad right now; I'm ready for some warm weather.
18:42:49 <ekidd> Will anybody here be at Penguicon in Detroit this weekend?
18:44:29 <ddarius> Actually, it hailed about two weeks ago.
18:44:47 <ddarius> And I like snow.
18:49:42 <ekidd> ddarius: Oh, I like snow, too. But once ski season is over, I'd just as soon that things warmed up properly.
18:50:11 <ekidd> Instead of doing this "melt all the snow off, have a mini-blizzard, repeat 3 times" deal that we've had this year.
18:58:03 <sorear> @where darcs-grah
18:58:04 <lambdabot> I know nothing about darcs-grah.
18:58:05 <sorear> @where darcs-graph
18:58:05 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/darcs-graph/
19:01:34 * sorear has finally started designing aptage!
19:02:05 <sorear> @seen dons
19:02:06 <lambdabot> dons is in #haskell-soc and #haskell. I last heard dons speak 13h 47m 12s ago.
19:02:32 <sorear> @ask dons what are the criteria for adding a project to your bunch of darcs graphs?
19:02:33 <lambdabot> Consider it noted.
19:05:10 <sorear> @ask dons how do you get the little "x"s on your darcs graphs?
19:05:11 <lambdabot> Consider it noted.
19:05:14 <sorear> @flush
19:09:47 <thedatabase> hey ekidd --- I've really enjoyed all your probability articles!  They've given me a great excuse to dust off my haskell socks (last worn in Glasgow, circa 96)
19:10:11 <ekidd> thedatabase: Thanks!
19:10:14 <thedatabase> I had a question about your darcs repository (I'm a bit behind on how the haskell community does things)
19:10:26 <ekidd> OK
19:11:32 <thedatabase> Does your creation of the darcs repo make you de facto maintainer of "the" probability library, and do you expect people to weigh in with how-you-say "hack"s?
19:12:06 <thedatabase> Or do you expect everyone will continue to hack away at their own (eg PFP)?
19:12:33 <ekidd> Well, I'd like to eventually get my probability library into some sort of generally useful shape, but there's a lot of work and peer review before I get there.
19:13:14 <ekidd> Two-thirds of the functionality is actually under "examples" right now--only a few core datatypes and PerhapsT are actually in the exported library.
19:14:10 <fantasma> how can I make this so it only takes the maximum value for each a given each n [((a-1)^n+(a+1)^n) `mod` a^2 | a <- [3..100], n <- [1..a]]
19:14:41 <thedatabase> I noticed that!  So you expect to migrate things when you flesh them out?  I actually had a follow up question... I had coded up a distribution and was wondering the best way to use it with your library; if you had time maybe I could hpaste it?
19:16:49 <dolio> > [ maximum [ ((a-1)^n+(a+1)^n `mod` a^2 | n <- [1..a] ] | a <- [3..100] ]
19:16:49 <lambdabot>  Parse error
19:17:16 <dolio> > [ maximum [ ((a-1)^n+(a+1)^n) `mod` a^2 | n <- [1..a] ] | a <- [3..100] ]
19:17:18 <lambdabot>  [6,8,10,24,42,48,54,80,110,120,130,168,210,224,238,288,342,360,378,440,506,5...
19:18:29 <ekidd> thedatabase: I'd be happy to take a look!
19:19:09 <fantasma> dolio: you are awesome thank you
19:21:37 <ekidd> thedatabase: If you post something for me, be sure to mention "emk" so that my software beeps at me... :-)
19:22:25 <sorear> ekidd: not ekidd?
19:22:38 <ekidd> sorear: Oops.
19:22:45 <ekidd> Sorry, my brain is totally fried.
19:23:21 <ddarius> Well if emk is on, use emk otherwise use ekidd, else use @tell.
19:24:55 <ekidd> ekidd is my default handle now, so that's best for use with @tell.
19:25:21 <sorear> @seen emk
19:25:22 <lambdabot> emk has changed nick to ekidd.
19:25:22 <lambdabot> ekidd is in #haskell. I last heard ekidd speak 26s ago.
19:25:29 <sorear> ^^ cool lambdabot feature
19:25:36 <sorear> alas it only affects @seen
19:25:46 <ekidd> Ah, very nice.
19:29:02 <hpaste>  thedatabase pasted "The BayesTree algorithm" at http://hpaste.org/1472
19:29:15 <thedatabase> ekidd:  you're very kind; like I said my haskell is kinda unpolished, so please don't take too much time from your various deadlines.  When I was thinking of probability and haskell, I immediately was reminded of a nice recursive method of Marcus Hutter for approximating arbitrary distributions: http://www.hutter1.net/ai/bayestree.htm
19:29:17 <lambdabot> Title: Fast Non-Parametric Bayesian Inference on Infinite Trees (Marcus Hutter)
19:30:31 <ekidd> thedatabase: Oooh, shiny.
19:31:26 <liquidengineer> Hi all
19:33:23 <ddarius> sorear: /nick dons All your karma are belong to me
19:33:44 <liquidengineer> Functions are first class, so it's possible to put them in lists, yes?
19:34:03 <chessguy> sure
19:34:11 <sorear> ddarius: why me?
19:34:22 <sorear> besides dons is still here ;)
19:34:26 <chessguy> @type [(*2),(+3),(\x -> x - 3)]
19:34:27 <ddarius> > zipWith ($) [(+1),(+2)] [1..3]
19:34:30 <lambdabot> forall a. (Num a) => [a -> a]
19:34:30 <lambdabot>  [2,4]
19:34:38 <liquidengineer> chessguy: What would be the best way to compose a list of functions on an input?
19:34:43 <liquidengineer> that is, let's say I have the following
19:34:52 <thedatabase> ekidd: that's what I thought when I read the paper... that, and "I'm going to implement this in haskell and sooo rock"; unfortunately I've less than rocked it so far, although it's been fun.  Hutter has a C implementation, but I figured it would be much easier to generalize in Haskell.  The algorithm should work for any set/type you can partition!
19:34:55 <ddarius> [21:23] <sorear> alas it only affects @seen
19:35:14 <liquidengineer> eval :: [(a -> a)] -> a -> a
19:35:22 <ddarius> foldr (.) id
19:35:22 <dmead> hey channel
19:35:25 <dmead> whats shakin
19:35:26 <liquidengineer> eval functList input ....
19:35:53 <liquidengineer> so I'd like to use the list as a composed bunch of functions and run them on the input
19:36:03 <sorear> liquidengineer: foldr (.) id, then
19:36:07 <chessguy> @type [a->a] -> a -> a
19:36:10 <lambdabot> parse error on input `->'
19:36:12 <chessguy> ugh
19:36:14 <sorear> chessguy: @kind!
19:36:21 <chessguy> @hoogle [a->a] -> a -> a
19:36:23 <lambdabot> No matches, try a more general search
19:36:40 <ddarius> Alternatively, mconcat
19:36:58 <ddarius> Or back in the day, mconcat, nowadays, for some value of nowadays, you'd have to wrap with Endo.
19:37:09 <liquidengineer> what's the easiest way?
19:37:15 <liquidengineer> cause I nave no idea what Endo is
19:37:23 <chessguy> ohhh, you want http://www.haskell.org/haskellwiki/Compose
19:37:25 <lambdabot> Title: Compose - HaskellWiki
19:37:32 <ddarius> foldr (.) id is pretty easy.
19:37:56 <liquidengineer> what's the id there? I'm a noob and have never used foldr, ever.
19:38:14 <chessguy> ?src id
19:38:15 <lambdabot> id x = x
19:38:19 <sjanssen> @type foldr
19:38:21 <chessguy> it just returns the input
19:38:22 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
19:38:28 <ekidd> liquidengineer: foldr (.) id [f,g,h] = f . g . h . id
19:38:39 <liquidengineer> Oh
19:38:41 <ekidd> It gives you a base case for the recursion.
19:38:42 <liquidengineer> Oh wow.
19:38:44 <fantasma> > 28433 * 2^7830457 + 1
19:38:48 <lambdabot> Terminated
19:38:56 <sjanssen> liquidengineer: foldr takes a function 'c' and a constant 'z'.  It replaces every : constructor with 'c' and the [] at the end with 'z'
19:38:57 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
19:39:03 <liquidengineer> that's.... so freaking cool.
19:39:05 <ddarius> liquidengineer: You will find foldr and foldl' are your friends.
19:39:13 <chessguy> yeah, but that applies the functions from right to left
19:39:14 <liquidengineer> foldl?
19:39:16 <liquidengineer> fold from the lest?
19:39:18 <liquidengineer> left?
19:39:25 <liquidengineer> so.....reverse of normal composition?
19:39:41 <ddarius> left, but specifically foldl' (not the ' read as "prime")
19:39:42 <ekidd> sum xs = foldl' (+) 0 xs
19:39:44 <sjanssen> @type foldl (.) -- I don't think this will type
19:39:47 <lambdabot> forall c a. (a -> c) -> [a -> a] -> a -> c
19:39:47 <chessguy> > foldr (.) . [(*2), (+1)] 3
19:39:48 <lambdabot>  Couldn't match expected type `t -> a -> a1 -> c'
19:39:51 <fantasma> lol how should I go about printing 28433 * 2^7830457 + 1
19:39:54 <monochrom> foldl (+) 0 [1,2] = (0+1)+2
19:39:58 <sjanssen> huh, I guess it does
19:40:03 <chessguy> > foldr (.) id [(*2), (+1)] 3
19:40:05 <lambdabot>  8
19:40:08 <ekidd> sum [1,2,3] -- returns 6
19:40:11 <ddarius> liquidengineer: There is no difference (roughly) between foldr and foldl for associative functions (which (.) is associative)
19:40:32 <ddarius> s/not/note
19:40:40 <chessguy> > foldl (.) id [(*2), (+1)] 3
19:40:42 <lambdabot>  8
19:40:50 <ddarius> fantasma: Use GHCi.
19:40:55 <monochrom> foldl (.) and foldr (.), which one is more efficient?
19:41:03 <fantasma> ddarius: it just dies
19:41:11 <sjanssen> are they the same?
19:41:13 <chessguy> liquidengineer: do you want your function to return 8 or 10 for that input?
19:41:16 <liquidengineer> ddarius: for composition, though, I would think it would be better to use foldr, if only cause it gives the expected behavior (work from left to right)
19:41:32 <liquidengineer> chessguy: ?
19:41:49 <sjanssen> > foldl (.) id [('a':), ('b':)] "c"
19:41:51 <lambdabot>  "abc"
19:41:54 <ddarius> liquidengineer: They are very similar, fold(l/r) (.) id [f,g,h] == f . g . h
19:42:04 <monochrom> I need to refine my question.  foldl (.) id [f,g,h] x and foldr (.) id [f,g,h] x, which one is more efficient?
19:42:04 <sjanssen> > foldr (.) id [('a':), ('b':)] "c"
19:42:06 <lambdabot>  "abc"
19:42:10 <sjanssen> apparently
19:42:10 <fantasma> I will try it in c, who knows...maybe it's got some magic (^) function
19:42:13 <dolio> foldl' is probably a safe choice, because you can't produce a 'partial result' function.
19:42:23 <liquidengineer> this is so much simpler than I thought it'd be
19:42:27 <liquidengineer> Haskell is of the awesome.
19:42:30 <ddarius> sjanssen: Technically, (.) is not strict in it's second argument so foldr.
19:42:49 <chessguy> liquidengineer: you were talking about a function of type [a->a] -> a -> a. what would you want it to do with this input? [(*2), (+1)] 3
19:42:58 <sjanssen> monochrom: I think it depends on the functions
19:43:11 <monochrom> Yes, I'm beginning to realize.
19:43:22 <ddarius> > foldr (.) id (const 3:repeat id)
19:43:23 <liquidengineer> chessguy: my functions are actually sort of booleans
19:43:23 <lambdabot>  <Integer -> Integer>
19:43:27 <ddarius> > foldr (.) id (const 3:repeat id) 40
19:43:28 <sjanssen> in my example above, foldr will generate the results lazily
19:43:29 <lambdabot>  3
19:43:35 <ddarius> > foldl (.) id (const 3:repeat id) 40
19:43:37 <liquidengineer> if a condition is met, a certain number returned, otherwise, another number is returned.
19:43:39 <lambdabot> Terminated
19:43:41 * chessguy sighs
19:43:46 <dolio> Ah, I stand corrected.
19:43:52 <monochrom> If f is pretty much const, foldr wins.
19:44:48 <liquidengineer> chessguy: foldr does exactly what I need, as it allows me to build "programs" consisting of a list of functions executed in sequence on an input. :)
19:45:25 <chessguy> liquidengineer: just remember that it will 'execute' the functions from right to left
19:45:43 <liquidengineer> and foldl from left to right, yes?
19:45:54 <chessguy> no, as i just demonstrated 2 minutes ago
19:45:58 <chessguy> > foldr (.) id [(*2), (+1)] 3
19:46:00 <lambdabot>  8
19:46:00 <chessguy> > foldl (.) id [(*2), (+1)] 3
19:46:02 <lambdabot>  8
19:46:05 <liquidengineer> oh
19:46:06 <liquidengineer> yes
19:46:07 <ddarius> 2^7830457 is roughly a 3-4 million digit number, but it -should- still work, just perhaps, take a while.
19:46:11 <liquidengineer> so when ARE they different?
19:46:23 <liquidengineer> chessguy: right to left is perfect, actually
19:46:34 <chessguy> liquidengineer: that's what i was asking you
19:46:39 <ddarius> liquidengineer: For infinite lists, they are different.
19:46:49 <monochrom> If the functions are pretty strict, the evaluator still needs to look at them to find out (short of a very powerful static strictness analysis).  foldl has the evaluator dive into (f.g).h to find out f is strict.  Maybe as well tell it f.(g.h) instead.
19:47:15 <hpaste>  thedatabase annotated "The BayesTree algorithm" with "The BayesTree algorithm" at http://hpaste.org/1472#a1
19:47:27 <liquidengineer> chessguy: right to left is what I want because I'm conceptualizing the head of the list as the top of a stack of functions, and the last as the bottom of the stack
19:47:36 <TSC> > foldl (-) 0 [1..5]
19:47:37 <liquidengineer> the input starts with the bottom function and bubbles up to the top function.
19:47:37 <lambdabot>  -15
19:47:41 <TSC> > foldr (-) 0 [1..5]
19:47:42 <lambdabot>  3
19:47:49 <TSC> That's when they're different
19:48:28 <liquidengineer> chessguy: am I making sense?  I'm sort of exhausted...
19:49:29 <chessguy> sure, that's fine, as long as you know that's how it works. the page i linked you to has some solutions for left-to-right, if you need them
19:49:46 <sorear> USE FOLDR.
19:50:07 <sorear> > foldr (.) id (replicate 10000000 ('a':)) []
19:50:09 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
19:50:12 <sorear> > foldl (.) id (replicate 10000000 ('a':)) []
19:50:17 <lambdabot> Terminated
19:50:19 <liquidengineer> lol
19:50:25 <chessguy> ?seen ekidd
19:50:25 <lambdabot> ekidd is in #haskell. I last heard ekidd speak 10m 17s ago.
19:50:32 <liquidengineer> Well, this is really gonna simplify my evaluator.
19:50:37 <liquidengineer> like, it'll be a three line function.
19:50:37 <ekidd> chessguy: I'm here.
19:50:39 <liquidengineer> wow
19:50:53 <chessguy> you lost me like 2 lines into your blog, lol
19:50:53 <liquidengineer> You are all kings of new england
19:51:10 <liquidengineer> Must sleep now
19:51:12 <chessguy> what's the significance of the width of the verticle lines?
19:51:13 <liquidengineer> good bye
19:51:25 <chessguy> uh, vertical
19:51:51 <ekidd> chessguy: That's just two lines next to each other. Since I don't have 300 particles, not all the lines are present.
19:52:05 <ekidd> It's a random sampling of possible positions.
19:52:12 <chessguy> oh!
19:52:19 <chessguy> that's different from "At first, our particles are spread evenly along the entire hallway (the top row of black lines)."
19:52:34 <chessguy> 'spread evenly' would be a uniform distribution
19:52:38 <chessguy> no?
19:52:43 <ekidd> chessguy: Let me go delete 'evenly'.
19:52:54 <ekidd> Well, we are sampling a uniform distribution.
19:52:55 <chessguy> or replace it with randomly
19:53:19 <chessguy> right, but the distribution of the sample isn't uniform
19:53:34 <ddarius> > foldr (.) id (replicate 1000000 (1+)) 0
19:53:35 <lambdabot>  1000000
19:55:20 <dmead> whats the syntax for putting constraints on datatypes?
19:55:49 <dmead> data expr = Not expr | True | False
19:55:55 <dmead> Not True = False
19:56:03 <dmead> Not False = True
19:56:04 <dmead> like that?
19:57:26 <chessguy> i don't think you can do that
19:57:48 <dibblego> it is defined by the functions that you write
19:57:50 <chessguy> it's certainly not going to look like that
19:58:25 <dmead> you can control the evaluation on constructors like that right?
19:58:32 <chessguy> you need data Expr = Not Expr | True | False, at the least
19:58:49 <sorear> dmead: look at the ml, INRIA is going to pay a PHD person to develop that
19:58:49 <dmead> thats what i said
19:58:56 <sorear> dmead: ie, it must not exist already
19:58:56 <chessguy> dmead: case matters
19:59:06 <dmead> sorear: what what?
19:59:52 <dmead> chessguy: following those lines you should be able to do Not True
19:59:54 <dmead> at ghci
19:59:59 <dmead> and have it return True
20:00:18 <sorear> dmead: The Institute National Research Information Automation (pretend those words were French) is going to hire a person with a PhD to invent a system for enforcing invariants on data types
20:00:20 <ddarius> sorear: Refinement types do stuff like that.
20:00:22 <chessguy> ermmm
20:00:44 <dmead> kewl
20:00:56 <chessguy> i'm still not sure you can do that, but i'm just a n00b
20:00:58 <dmead> so you can't do that yet aye
20:01:06 <dmead> chessguy, i swear i've seen it done
20:01:09 <ddarius> Well, not exactly what dmead wants, they are for enforcing what kind of data structures you can build.
20:01:11 <dmead> but i forget exactly how
20:01:13 <sorear> http://haskell.org/pipermail/haskell/2007-March/019263.html
20:01:15 <lambdabot> Title: [Haskell] One-year INRIA post-doctoral position
20:01:50 <dmead> neat
20:01:59 <dmead> too bad i'm an undergrad for two more weeks
20:02:43 <dmead> ddarius, are you aware of a way to enforce that sort of evaluation that works now?
20:02:47 <sorear> I don't think people go straight from undergrad to postdoctoral positions :)
20:02:55 <ddarius> But how you'd do that today you'd just use smart constructors.
20:02:57 <dmead> sorear: :P
20:03:04 <ddarius> But in that case, you'd just have Bool and not.
20:03:33 <dmead> yeaaaa, i do simple constructor functions
20:03:37 <dmead> like youd find in lisp
20:03:57 <dmead> makeNeg T = F
20:04:02 <dmead> makeNeg F = T
20:04:05 <dmead> and so forth
20:04:35 <narain> ?hoogle [m a] -> m [a]
20:04:36 <lambdabot> Prelude.head :: [a] -> a
20:04:37 <lambdabot> Prelude.last :: [a] -> a
20:04:37 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
20:04:49 <narain> ?hoogle Monad m => [m a] -> m [a]
20:04:51 <lambdabot> Prelude.head :: [a] -> a
20:04:51 <lambdabot> Prelude.last :: [a] -> a
20:06:09 <sorear> @seen glguy
20:06:10 <lambdabot> glguy is in #haskell. I last heard glguy speak 2d 7h 12m 35s ago.
20:10:10 <chessguy> ekidd: is this right?
20:10:10 <chessguy> instance Dist PS where
20:10:11 <chessguy>   weighted = liftRand . weighted
20:10:43 <ekidd> chessguy: you can also write is as:
20:11:06 <ekidd> weighted xws = liftRand (weighted xws)
20:11:45 <chessguy> hmm
20:11:50 <ekidd> (weighted xws) is of type Rand a here, and we lift it to PS a.
20:12:14 <chessguy> oh ok
20:12:20 <ekidd> All the code has been tested by hand and pasted verbatim into the blog post, so at least the obvious stuff should work. :-)
20:12:23 <chessguy> because Rand is an instance of Dist?
20:12:43 <ekidd> chessguy: Yup. It's in part 2.
20:12:48 <chessguy> ok
20:12:54 <chessguy> i need to review tat stuff
20:12:58 <chessguy> *that
20:13:11 <ekidd> Basically, any Rand monad can be trivially turned into a distribution monad.
20:13:42 <ekidd> chessguy: Yeah, I admit this implementation is getting pretty esoteric--it's built up by recycling lots of pieces from the earlier articles.
20:14:34 <sorear> > 2^31 - 1
20:14:36 <lambdabot>  2147483647
20:14:55 <chessguy> i think it might be more illustrative to apply the core probability to other stuff
20:16:24 <chessguy> but i need to go back and re-read the first few parts again, since my understanding of monads has (hopefully) increased since last time i (tried to) read them
20:16:47 <chessguy> heh. that sentences parses interestingly
20:17:21 <chessguy> "i (tried to) read them"
20:18:06 <chessguy> ekidd++ anyway for more fascinating stuff
20:18:32 <ekidd> chessguy: Thanks!
20:22:03 * narain just understood what  sequence  is for
20:22:34 <chessguy> what the heck?
20:22:48 <chessguy>     Can't make a derived instance of `Num Prob'
20:22:48 <chessguy>       (`Num' is not a derivable class
20:22:48 <chessguy>        Try -fglasgow-exts for GHC's newtype-deriving extension)
20:23:05 <ddarius> @where whyfp
20:23:05 <lambdabot> I know nothing about whyfp.
20:23:22 <narain> ?help where
20:23:23 <lambdabot> where <key>. Return element associated with key
20:23:24 <ddarius> @google "Why Functional Programming Matters"
20:23:26 <lambdabot> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
20:23:27 <lambdabot> Title: Why Functional Programming Matters
20:23:51 <ddarius> @where+ whyfp http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
20:23:51 <lambdabot> Done.
20:27:12 <atp> hi folks... can anyone explain to me the difference between newtype and data?
20:27:34 <atp> in particular, why is newtype preferred when creating a monad?
20:27:42 <dmwit> atp: newtypes can only have one constructor, for starters.
20:28:00 <dmwit> You can't do newtype Color = Green | Red | Blue.
20:28:01 <sorear> newtypes are more restricted, but are almost always better.
20:28:15 <sorear> newtypes have one unary constructor, always
20:28:18 <atp> i see
20:28:22 <dmwit> But they're also faster than data, if you can use them.
20:28:25 <sorear> they cost nothing at runtime
20:28:35 <atp> ah, i see.
20:28:49 <dmwit> sorear: Isn't there also some difference of handling _|_?
20:29:10 <atp> so if for example i were defining a type like Maybe, i would need to use data, because it's Maybe a = Nothing | Just a
20:29:12 <Korollary> that is an overgeneralization
20:29:16 <atp> newtype wouldn't work?
20:29:19 <ddarius> atp: newtype is just a stronger form of type.  data is what you use when you want to build a new data type.
20:29:34 * atp thinks about this.
20:29:35 <sorear> dmwit: not really.  newtypes are unlifted, but that's not much of a difference
20:29:49 <atp> newtypes are unlifted?
20:29:53 <stepcut> what is the best paper to read to learn about associated types? Associated Types with Class ?
20:29:55 <atp> what does that mean, exactly?
20:30:05 <sorear> atp: no _|_
20:30:11 <atp> ah, i see.
20:31:18 <Korollary> isnt there a haskell faq? This is very frequently asked.
20:31:32 <sorear> stepcut: you can read about them all you want, but remember no compiler implements them
20:31:33 <atp> sorry for asking a faq ...
20:31:37 <sorear> ?faq muahaha!
20:31:37 <lambdabot> The answer is: Yes! Haskell can do that.
20:31:49 <stepcut> sorear: I thought they were in 6.7 ? Or is that something else ?
20:31:57 <Korollary> atp: actually I dont know if there's a faq. You should feel free to ask anything.
20:32:26 <atp> Korollary: thanks... but i should have checked first, and i didn't.  so i'm sorry, anyway.  i'll go check.
20:32:50 <dmwit> ?google Haskell faq
20:32:53 <lambdabot> http://www.cs.nott.ac.uk/~gmh/faq.html
20:32:53 <lambdabot> Title: FAQ for comp.lang.functional
20:32:57 <sorear> stepcut: 6.7 implements an utterly restricted form
20:33:12 <sorear> only data, only in classes
20:33:18 <Korollary> I am now almost sure that there isn't a faq. Amazing.
20:33:25 <dmwit> Heh, the Haskell section is pretty short. =)
20:33:30 <sorear> all the fun stuff isn't implemented.
20:33:51 <stepcut> sorear: is there someplace that describes what will be available in 6.8?
20:34:00 <sorear> stepcut: ghc wiki
20:34:06 <dmwit> Korollary: A testament to #haskell. =)
20:34:06 <atp> hm, yeah, i can't seem to find anything about it.  although, in the gentle introduction, it does refer me to 4.2.6 for the differences between type, newtype and data
20:34:11 <sorear> @ghcwiki AssociatedTypes
20:34:13 <lambdabot> No Result Found.
20:34:18 <sorear> :(
20:34:22 <atp> but the gentle intro i'm looking at doesn't have that section :(
20:34:44 <atp> err 4.2.3
20:34:51 <sorear> http://hackage.haskell.org/trac/ghc/wiki/TypeFunctions
20:34:53 <lambdabot> Title: TypeFunctions - GHC - Trac
20:35:01 <ddarius> Korollary: There are some on the wiki.
20:35:11 <ddarius> @oldwiki NewtypeVsStrictData
20:35:12 <lambdabot> http://www.haskell.org/hawiki/NewtypeVsStrictData
20:35:26 <narain> ?wiki newtype
20:35:27 <lambdabot> http://www.haskell.org/haskellwiki/newtype
20:35:32 <dmwit> atp: It's referring to section 4.2.6 in the Report.
20:35:35 <dmwit> ?where report
20:35:35 <lambdabot> http://www.haskell.org/onlinereport/
20:35:43 <ddarius> I never nail that one.
20:35:48 <atp> dmwit: 4.2.3, sorry, i mistyped
20:35:55 <Korollary> dmwit: that's nowhere near useable as a faq answer
20:36:06 <chessguy> ekidd: have you worked all this re-implementation of PFP into a usable library?
20:36:17 <Korollary> We should have a FAQ reachable from the front page.
20:36:23 <ekidd> Not entirely. I'm getting there slowly.
20:36:37 <atp> dmwit: thanks, i found it in the report
20:36:46 <dmwit> Korollary: Ah, well, if he's using the Gentle Guide, he sounds like he's up for a bit of a challenge. =)
20:37:12 * atp wrote his dissertation on derham cohomologies in algebraic topology, but he's not that great at CS...
20:37:21 <atp> :)
20:37:22 <dmwit> atp: In case you didn't know, the gentle intro is known for being less than gentle.
20:37:47 <narain> ekidd: hi! what happened with that category theory intro you were writing?
20:37:57 <Korollary> atp: algebraic topology should help with category theory, no?
20:37:59 <atp> dmwit: yeah, i noticed that, but i've already read through yaht and the gentle intro is a little bit more rigorous
20:38:26 <ekidd> narain: It's probably about 2 months down the to-do list right now.
20:38:30 <ekidd> :-(
20:38:30 <dmwit> atp: Yeah, I started with the Gentle Intro, and I'm still happy about it. =)
20:38:35 <ddarius> Korollary: Category Theory has a topological side and a algebraic/logical side...
20:38:43 <SamB_XP> isn't rigorous almost the opposite of gentle?
20:38:48 <monochrom> I heard that derham cohomology is beautiful.
20:39:00 <atp> it is
20:39:09 <atp> algebraic topology is beautiful in general
20:39:11 <ekidd> narain: I want to turn the probability stuff back into a real paper, first. But thanks for the interest!
20:39:27 <atp> homotopy groups are neat but often not abelian, hence cohomology...
20:39:55 <narain> ekidd: ah, i just saw that you have a new blog article up
20:40:03 <monochrom> the cat theory used for alg top has a different emphasis than that used for functional programming.  for one thing, functional programming does use exact sequences...
20:40:03 <atp> haskell seems pretty cool so far, it's much more math-y than most languages out there
20:40:04 * narain goes to read
20:40:16 <monochrom> err, functional programming doesn't use exact sequences...
20:40:49 <atp> monochrom: i think category theory was initially developed for alg top and has since grown into its own, far exceeding what it was initially designed for... it's very pervasive in math these days
20:41:03 <ddarius> atp: Indeed.
20:41:24 <atp> it's quite elegant if not sometimes maddeningly abstract :)
20:41:32 <inverselimit> Other that the "don't panic" guide, what else very category-theoretic is there out there to learn haskell?  The commutative diagrams in that one was part of the draw to the language for me.
20:41:43 <monochrom> functional programming emphasizes functor, initial algebra, natural transformation, and monadic functor.
20:42:46 <Korollary> inverselimit: I haven't seen anything else.
20:43:00 <atp> i'm a rank newbie at this haskell stuff but i must say, so far it's been very pleasurable
20:43:12 <sorear> isn't cat theory without functors kinda pointless?
20:43:14 <Korollary> Maybe blog posts, but no other papers I can recall.
20:43:29 <atp> sorear: i don't think cat theory without functors is possible, functors are the whole point
20:44:24 <Korollary> Uselessness taken as a virtue in abstract nonsense.
20:44:27 <inverselimit> atp: what are you trying to write?  I've been implementing some representation theory/geometry stuff
20:44:53 <atp> inverselimit: at this point, i'm not comfortable enough with haskell to write much of anything, i only started trying to learn it yesterday
20:45:04 <atp> inverselimit: and not because i had any particular project in mind :)
20:45:29 <Korollary> atp: you're doing all right if after just one day you are curious about newtype vs datadecl.
20:45:42 <ddarius> Natural transformations are the whole point.
20:45:50 <atp> thanks Korollary, i'll take that as a compliment :)
20:46:29 <ddarius> inverselimit: Usually Category Theory is not used as the route to learn Haskell.
20:46:34 <dmwit> inverselimit: http://www.patryshev.com/monad/m-intro.html
20:46:36 <lambdabot> Title: Crash Monad Tutorial
20:47:14 <Korollary> inverselimit: Maybe not relevant, but have you seen http://math.ucr.edu/home/baez/qg-fall2006/index.html#computation ?
20:47:16 <lambdabot> Title: QG Seminar: Fall 2006
20:47:30 <atp> alright guys, thanks for the help, i'm off
20:47:40 <inverselimit> hmm the first one looks good
20:47:43 <Korollary> iirc it explains lambda calculus as a category
20:48:29 <inverselimit> Korollary: that also looks interesting.
20:49:30 <inverselimit> So I tried as my first project in haskell to write something that decomposes modules of polynomials using Schur-Weyl duality
20:49:33 <Korollary> I spent the last two days reviewing C++ code. Pretty much anything looks interesting to me.
20:49:52 <inverselimit> This turned out to be a little tricky without being comfortable with the syntax
20:50:07 <dmwit> heh
20:52:24 <inverselimit> Particularly building rings and tensor algebras.  There are many layers of structure and functors are all over the place.  I found a couple of things hard:  information hiding without objects and making algebras.
20:52:49 <dmwit> ?remember inverselimit So I tried as my first project in haskell to write something that decomposes modules of polynomials using Schur-Weyl duality.  This turned out to be a little tricky without being comfortable with the syntax
20:52:50 <lambdabot> Done.
20:53:27 <dmwit> inverselimit: Information hiding is typically done using modules.
20:53:53 <dmwit> You give a list of labels to export, and just don't list the ones you want hidden.
20:54:00 <sorear> I was not very familiar with cat. theory at all when I came here, but I still learned easily.  I've got a mathsy brain and I'm extremely good at learning period.
20:54:31 <inverselimit> Ahh.
20:54:46 <sorear> I do find that cat theory is one of the tamer branches of mathematics with regards to obtuseness.
20:55:31 <sorear> The first twenty pages of a text on galois theory have probably given me more brain explosions than all of topology and haskell combined ... :(
20:56:17 <Korollary> sorear: How do you pick those topics?
20:56:33 <sorear> Korollary: availability of books :)
20:56:55 <monochrom> After a brain explosion, it's large enough for haskell, apparently.
20:56:57 <Korollary> sorear: Are you in college?
20:57:01 <sorear> No.
20:57:54 <Korollary> sorear: How much time do you spend reading per week?
20:58:05 <ddarius> Galois theory is straight forward enough.
20:58:38 <monochrom> Everything is straightforward after a brain explosion.
20:58:42 <sorear> ~10hrs I'd say
20:58:53 <monochrom> The trick is getting an explosion.
20:59:50 <monochrom> It must be triggered by a subject that is straightforward to someone else because that someone else learned things in a different order and therefore the explosion came before the subject for that someone else.
21:00:15 <monochrom> This is known as the bootstrap problem.
21:00:43 <ddarius> monochrom: A small bit of C4 would accomplish that, but I don't think that things would be straightforward after it... or maybe I'm wrong.
21:00:45 <hpaste>  lienmeister pasted "scatter and gather for strings" at http://hpaste.org/1474
21:00:55 <Korollary> monochrom: Is this the tipping-the-vending-machine syndrome?
21:01:16 <monochrom> Heh, if you survive the explosion, everything is easy. :)
21:01:17 <Korollary> ?quote JohnMeacham vending
21:01:18 <lambdabot> JohnMeacham says: I liken learning haskell to tipping over a vending machine. you can't just push it, you gotta rock it back and forth a few times building up momentum until bam! suddenly the flash
21:01:18 <lambdabot> of insight hits and it all makes sense.
21:03:46 <sorear> @seen dons
21:03:47 <lambdabot> dons is in #haskell-soc and #haskell. I last heard dons speak 15h 48m 53s ago.
21:05:30 <inverselimit> So after the vending machine falls over, do you get the candy or just crushed?
21:05:45 <Korollary> you get escorted out by security
21:06:06 <dmwit> But at least you understand *why* you were escorted out!
21:10:01 <Korollary> Somebody should score in Dallas vs Vancouver.
21:11:03 * sorear pretends to be too busy hacking to care about sports
21:11:23 * dcoutts *is* too busy hacking to care about sports
21:11:41 <Korollary> lies
21:11:43 * dcoutts just doesn't care about sport
21:11:52 <dcoutts> ok, it's true, I'm slacking :-)
21:12:32 <monochrom> Nobody should score.
21:12:45 <dmwit> Nobody isn't playing!
21:13:39 <monochrom> I want all games in baseball, NHL, NBA, NFL, ...  all of them to be ties, or at least drag to the very end and use the most uniformly random means to break ties.
21:13:43 <jcreigh> Who's on first?
21:13:53 <sorear> hmm.  according to bsd primes there IS a last prime, namely 4294967291.
21:14:00 <Cale> The players should tie the game up and then conspire not to change the score.
21:14:15 <monochrom> Confound the gamblers. Frustrate the spectators.  Make it boring as hell.  They should just go home and learn haskell.
21:14:16 <dmwit> > 2^32
21:14:18 <lambdabot>  4294967296
21:14:35 <dmwit> sorear: Sounds suspiciously close to the biggest number a word can hold. =)
21:15:10 <dmwit> > 2^15
21:15:12 <lambdabot>  32768
21:15:23 <Korollary> > 2
21:15:24 <lambdabot>  2
21:15:26 <dmwit> Can modern computers do 2^15 divisions per second?
21:15:37 <sorear> Easily.
21:17:13 <dmwit> > let divides a b = b `mod` a == 0; isPrime p = null . filter (divides p) . takeWhile (\x -> x * x <= p) $ [2..] in isPrime 4294967291
21:17:15 <lambdabot>  True
21:17:19 <dmwit> Wow!
21:17:24 <dmwit> That is faster than I expected.
21:18:22 <Cale> % FactorInteger[347281974981279827190321789]
21:18:23 <mbot> Cale: {{3, 1}, {13, 2}, {181, 1}, {829, 1}, {260171, 1}, {2900347, 1}, {6049679, 1}}
21:18:27 <monochrom> That includes compile time IIRC.
21:18:29 <Cale> % FactorInteger[3472819749812798271903217891]
21:18:30 <mbot> Cale: {{881, 1}, {1779448193, 1}, {2215241025547027, 1}}
21:18:34 <Cale> % FactorInteger[34728197498127982719032178914638194781]
21:18:36 <mbot> Cale: {{43, 1}, {619, 1}, {119981, 1}, {117538393891, 1}, {92518995473546483, 1}}
21:18:39 <Cale> % FactorInteger[34728197498127982719032178914638194781261783978933861]
21:18:40 <mbot> Cale: {{1557029, 1}, {22304143017328503656021935952790985126970521409, 1}}
21:18:44 <Cale> % FactorInteger[34728197498127982719032178914638194781261783978933861321678391]
21:18:49 <mbot> Cale: "Time limit exceeded for computation."
21:18:58 <jcreigh> I didn't know mbot was in this channel.
21:19:04 <Cale> I just had it join
21:19:12 <jcreigh> oh, duh.
21:19:20 <sorear> jcreigh: your client is seriously too stupid to render joins?
21:19:27 <Cale> That should give you some idea of the scale of computation you can do in under a second.
21:19:30 <jcreigh> sorear: eyeball malfunction.
21:19:35 <monochrom> But it renders bind :)
21:19:46 <Cale> mbot: @part #haskell
21:20:10 <narain> Cale: neat, you can make bots join and leave like that?
21:20:15 <monochrom> @src join
21:20:15 <lambdabot> join x =  x >>= id
21:20:17 <Cale> yep
21:20:25 <narain> ?help join
21:20:25 <ddarius> @src part
21:20:26 <lambdabot> Source not found. Are you on drugs?
21:20:26 <lambdabot> join <channel>
21:20:37 <monochrom> @pl \x -> x >>= id
21:20:38 <lambdabot> join
21:20:48 <monochrom> confound it!
21:21:17 <monochrom> "lambdabot has (>>= id)'ed #haskell!"
21:21:23 <Cale> Oh, and that's not even FactorIntegerECM :)
21:21:56 <Cale> Though it's more suited to factorisations which will likely take longer than a second
21:24:08 <dmwit> Cale: Ah, thanks.  Pretty staggering.
21:24:57 <Cale> People don't realise what they have sitting on their desks :)
21:25:11 <narain> lambdabot should also prefix its responses with the name of the user who asked, like mbot does
21:25:15 <dmwit> I sure don't. =)
21:25:27 <jcreigh> computers are really, really fast. But hardware manufacturers pay the Mozilla Foundation good money to prevent people from finding out. :)
21:25:31 <Cale> You can do more computation in the blink of an eye than was done in all of world history up until 1900.
21:25:53 <hpaste>  thedatabase annotated "The BayesTree algorithm" with "The BayesTree algorithm" at http://hpaste.org/1472#a2
21:26:05 <fantasma> i love haskell
21:26:09 <shapr> @remember Cale You can do more computation in the blink of an eye than was done in all of world history up until 1900.
21:26:09 <Cale> (I suppose that likely depends a bit on what you consider to be computation)
21:26:10 <lambdabot> Done.
21:26:44 <narain> Cale: and also on how fast you blink?
21:26:52 <Cale> heh
21:27:05 <jcreigh> so HAppS just keeps everything in-memory, and serializes to disk, right?
21:27:11 <shapr> yup
21:27:35 <fantasma> can anyone recommend a percision mathematics library for haskell?
21:28:05 <sorear> Prelude
21:28:16 <sorear> Integer is builtin and very very very fast
21:28:22 * narain wonders if he should write a patch for lambdabot
21:28:30 <Korollary> Do you want arbitrary float precision?
21:28:35 <jcreigh> how do you evolve your data types with something like? What if you need to add or remove a constructor?
21:28:49 <sorear> jcreigh: it uses Read/Show
21:28:57 <jcreigh> oh, really?
21:28:59 <sorear> jcreigh: so just add the constructor, nothing will break
21:29:03 <sorear> jcreigh: oh, really.
21:29:06 <jcreigh> hmm. That's too simple. :)
21:29:13 <sorear> jcreigh: KISS
21:29:14 <fantasma> Korollary: yeah
21:29:42 <sorear> besides, Data.Binary sucks for anything resembling scripted edits :)
21:30:55 <jcreigh> heh. For some reason I was thinking there would be some huge framework to deal with serializing data.
21:31:09 <Korollary> enterprise grade, baby
21:31:26 <Korollary> comes with eclipse plugins and UML diagrams
21:31:32 <sorear> jcreigh: yes, it was invented in the early 90s under the code name "Text"
21:31:39 <Cale> I still think it would be cool if we had a way to turn the IO continuation into a binary executable.
21:31:43 <sorear> jcreigh: then they split it into Read and Show
21:31:57 <sorear> Cale: what reminds you of this?
21:32:06 * sorear still promises that feature in ayhi
21:32:27 * sorear no longer promises a release date for ayhi
21:32:29 <Cale> Well, it wouldn't quite solve the same problem as serialisation here (it would lach extensibility)
21:32:38 <Korollary> Cale: open file descriptors etc would have to be messed with
21:32:42 <Cale> lack*
21:32:53 <sorear> Korollary: then mess with them!
21:32:58 <Cale> Korollary: that's true :)
21:32:58 <fantasma> ?src foldr1
21:32:59 <lambdabot> foldr1 _ [x]    = x
21:32:59 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
21:32:59 <lambdabot> foldr1 _ []     = undefined
21:33:01 <Korollary> I press ctrl-z heh
21:33:02 <sorear> Korollary: emacs can do it, so can we!
21:33:54 <fuzan> i want a modern ide with emacs control.
21:34:10 <dmwit> I want ice cream!
21:34:13 <dmwit> and a pony
21:34:21 <Korollary> pony is easy. Ice cream we have to work on.
21:34:21 <fuzan> my request is more realistic.
21:34:22 <Cale> Another really awesome thing would be a way to reliably serialise thunks.
21:34:44 <dmwit> fuzan: I wouldn't be so sure.  I got my ice cream -- do you have your modern IDE? =P
21:34:58 <Korollary> I want a modern pony with emacs controls.
21:34:58 <dmwit> But yes, I understand what you mean.
21:36:45 <fuzan> dmwit: your desire isn't complete until you have a pony.
21:37:00 <dmwit> fuzan: Your desire isn't complete until you have emacs controls.
21:37:01 <Korollary> it's a lazily fulfilled desire
21:37:12 <dmwit> (I covered my a** on that one. =)
21:37:20 <fuzan> dmwit: :(
21:37:48 <fuzan> I like how development of user interfaces is so binary.
21:37:51 <Cale> How about an IDE where all the buttons make inappropriate sounds when you click them?
21:38:06 <merus> Cale: Visual Studio?
21:38:09 <Korollary> Cale: Only if the screen has many red, blinking lights to go with them.
21:38:11 <fuzan> they must either be useful and configurable, or really simple and mouse-driven.
21:38:21 <fuzan> redlight ide!
21:40:02 <Cale> The keyboard map will be such that pressing a key will cause the keybindings of all adjacent keys to be rotated clockwise around it.
21:40:55 <dmwit> That reminds me of Earthbound -- when you ate a mushroom, the controls got all wacky.
21:41:10 <snappy> inverted controls?
21:41:13 <dmwit> Very frustrating, but it's amazing what you can get accustomed to with a little practice...
21:41:26 <dmwit> snappy: Rotated, actually, and with random intervals between re-rotations.
21:41:36 <Cale> Then, by creating a sense of prestige surrounding the use of this IDE, we can fool developers who would otherwise do negative work into doing zero work.
21:41:40 <fantasma> @index foldl'
21:41:40 <lambdabot> Data.List
21:42:31 <monochrom> Cale is specifying the sequel to the scary puzzle game The 11th Hour.  Surely what he describes is a total nightmare.
21:43:46 <dmwit> For bonus points, typing a word not in the program's limited dictionary should choose a random skin from an online repository of ugliness.
21:44:18 <Cale> Myspace.
21:44:20 <monochrom> Why are we so mean to programmers?
21:45:40 <qebab> You guys really should make that IDE you are talking about
21:45:59 <monochrom> I guess Cale is painting a very dark picture of side effects and mutable states.
21:46:02 <dmwit> When you press enter, it should prompt you: "Are you sure you want to end the line there? Y/N"
21:46:14 <qebab> Haha :D
21:46:53 <sorear> hello SyntaxNinja
21:46:55 <Cale> No, half the time it would ask "Wouldn't you like to continue working on the current line? Y/N"
21:47:08 <stepcut> haha
21:47:11 * dmwit laft
21:47:11 <monochrom> "Do you want to indent the next line?"
21:47:34 <jcreigh> I hate dialog boxes that only have an "OK" button. "An error has occured. $APPLICATION will now exit. [OK]". NO, it's NOT okay! Where's the NOT OK button?
21:47:36 <Cale> and it would always insert the Y or N that you responded with
21:47:37 <sorear> Of course, these questions are to be asked in a truly random order.
21:47:41 <monochrom> A slide bar is provided to specify the number of spaces in the indentation.
21:47:45 <dmwit> jcreigh: shift-click ;-)
21:48:35 <sorear> SyntaxNinja: there was just a bit of a discussion on #ghc - how hard would it be to upgrade hackage.h.o's python?
21:48:41 <Cale> Of course, this is assuming that you haven't lost track of where Y and N are on the keyboard.
21:48:49 <monochrom> hahahaha
21:49:23 <dmwit> TAG HORRIDE
21:49:30 <dmwit> I want to be able to find this again. =)
21:49:49 <stepcut> this sounds like what happens when I use vi
21:50:47 <SyntaxNinja> w00t
21:51:31 <SyntaxNinja> sorear: hm. I think the best thing would be to move hackage stuff to the new community server where folks like ross can upgrade python at will.
21:51:54 <SyntaxNinja> problem w/ hackage.h.o is that it's an old(ish) version of Debian, so we'd probably have to upgrade the whole thing.
21:51:58 <sorear> SyntaxNinja: what is this 'community server'?  I've never heard of it before.
21:52:20 <sorear> SyntaxNinja: also, dcoutts and ChilliX still seem to think hackage.h.o is the way forward
21:52:23 <SyntaxNinja> sorear: we're just now getting it up & running. the idea is that folks can get accounts and use it, and more people have root than hackage.h.o
21:52:29 <sorear> SyntaxNinja: you'll need to set them straight!
21:52:30 <sorear> :)
21:52:40 <SyntaxNinja> sorear: in what sense? the dns name or the server itself?
21:52:59 <dcoutts> sorear: I know about the new server, I've got an account there.
21:53:04 <dcoutts> hia SyntaxNinja
21:53:14 <dcoutts> SyntaxNinja: had fun with dons? :-)
21:54:01 <sorear> what's it called? host -l isn't liking me ;)
21:54:05 <SyntaxNinja> dons: yep :) we had a really nice dinner
21:54:18 <dcoutts> SyntaxNinja: cool
21:54:24 <SyntaxNinja> yeah, we haen't decided all that the new server is going to do.
21:55:28 <sorear> @ty Data.Map.findWithDefault
21:55:30 <lambdabot> forall a k. (Ord k) => a -> k -> M.Map k a -> a
21:55:32 <dcoutts> SyntaxNinja: did we decide if hackage should go on the new box? ie it could become hackage.h.o and leave the current box as darcs.h.o
21:55:47 <dcoutts> and the trac installs could move over too
22:02:43 <fantasma> is there any built-in function that converts from base10 to base2
22:04:15 <sorear> no.
22:04:18 <sorear> er, yes
22:04:29 <sorear> > read ['1', '2', '3']
22:04:31 <lambdabot>  123
22:05:02 <fantasma> what?
22:05:16 <allbery_b> your question is ill-formed :)
22:05:18 <sorear> I assure you that '123' is stored in base 2.  if you wanted '01010101' or similar, there is another function for that:
22:05:29 <jcreigh> > printf "%08b" 42
22:05:29 <sorear> @ty showIntAtBase --read ['1', '2', '3']
22:05:30 <lambdabot>  Add a type signature
22:05:32 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
22:05:41 <fantasma> I want a literal translation :)
22:05:54 <sjanssen> @hoogle showIntAtBase
22:05:54 <sorear> > showIntAtBase 2 digitToInt (read "123") ""
22:05:54 <lambdabot> Numeric.showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
22:05:55 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
22:06:06 <jcreigh> > printf "%08b" 42 :: String
22:06:08 <lambdabot>  Exception: Printf.printf: bad formatting char b
22:06:11 <sorear> > showIntAtBase 2 intToDigit (read "123") ""
22:06:12 <lambdabot>  "1111011"
22:06:14 <jcreigh> what? It's b standard?
22:06:15 <SyntaxNinja> dcoutts: no, we didn't decide yet.  but that's kinda how I'm leaning. I think it would be good to have the hackage hackers have more control of the server.
22:06:17 <jcreigh> *isn't
22:06:23 <sorear> jcreigh: not even in C!
22:06:42 <fantasma> @index showIntAtBase
22:06:43 <lambdabot> Numeric
22:07:20 <jcreigh> hmm, okay.
22:07:34 <dcoutts> SyntaxNinja: right.
22:14:21 <newsham> sorear: i liked that paper you posted ref to (minimal lambda exprs)
22:14:41 <sorear> newsham: minimal lambda exprs?
22:14:46 <sorear> which post?
22:14:57 <newsham> encoding algebraic data types into lambda exprs
22:15:11 <newsham> forget the title..
22:15:33 <sorear> err, I'm pretty sure I never posted a ref to a paper on haskell*@haskell.org
22:15:48 <sorear> you probably have me confused with someone else
22:16:06 <ddarius_> Namely ndm
22:18:30 <newsham> http://www.haskell.org/pipermail/haskell-cafe/2007-April/024654.html
22:18:32 <lambdabot> Title: [Haskell-cafe] First order Haskell without Data, http://tinyurl.com/2gnjqm
22:18:37 <newsham> i guess ndm posted it
22:19:14 <sorear> I feel honored that you automatically assumed I wrote a cool post.
22:19:46 <newsham> http://www.thenewsh.com/~newsham/x/numbers.py
22:20:05 <newsham> been goofing around with lambdas for kicks
22:20:10 <sorear> ich, .py :)
22:20:25 <newsham> hey, haskell didnt like the types
22:20:47 <sorear> we can help with that!
22:21:07 <ivanm> @hoogle [a] -> [a] -> [[a]]
22:21:08 <lambdabot> No matches, try a more general search
22:21:20 <sorear> ivanm: eh?
22:21:22 <newsham> sweet, i got stuck on zero, succ, and numstr.
22:21:25 <newsham> lemme know how it goes :)
22:21:40 <sorear> @ty \f z -> z
22:21:43 <lambdabot> forall t t1. t -> t1 -> t1
22:21:50 <sorear> @ty \nr f z -> f (nr f z)
22:21:52 <lambdabot> forall t t1 t2. ((t1 -> t2) -> t -> t1) -> (t1 -> t2) -> t -> t2
22:22:18 <ivanm> sorear: trying to find a function that I realise isn't what I want anyway
22:22:28 <SyntaxNinja> dcoutts: what do you think?
22:22:47 <newsham> doesnt the type of succ imply an infinite type?
22:22:53 <sorear> @ty \nr -> nr (+1) 0
22:22:57 <lambdabot> forall a t t1. (Num a, Num t) => ((a -> a) -> t -> t1) -> t1
22:23:14 <sorear> newsham: infinite types are perfectly possible in haskell, use newtype.  and no.
22:23:56 <newsham> mind implementing zero, succ, numstr and add in haskell?
22:24:06 <newsham> ie:  zero = \f -> \g -> f
22:24:14 <sorear> that works as is.
22:24:22 <newsham> succ n = \f -> \g -> g n
22:24:28 <sorear> same.
22:24:36 <sorear> numstr = show . numint
22:24:41 <sorear> numint n = n (+1) 0
22:24:50 <newsham> add mz n = mz n (\m -> succ (add m n))
22:24:59 <newsham> i think it blew up on me when i did add
22:25:16 <sorear> add n m = \f g -> n f (m f g)
22:25:25 <sorear> the types were protecting you :)
22:25:28 <newsham> numstr n = n "0" (\m -> "1" ++ numstr n)
22:25:55 <dcoutts> SyntaxNinja: yes, I agree. Leave ghc and the core packages on darcs.h.o and move tracs and other or new packages to hackage.h.o
22:25:56 <sorear> well, goodnight now, unfortunately.
22:25:57 <hpaste>  stepcut pasted "zero, succ, numstr, and add in haskell (type system)" at http://hpaste.org/1475
22:26:07 <stepcut> :)
22:26:26 <stepcut> still a bit buggy though :-/
22:27:40 <ivanm> I'm trying to write a function that will take in two Ints, n and w, and give me a list of lists xss, such that each xs in xss is of length n, sum xs = w and xs is in non-increasing order
22:27:46 <ivanm> Any ideas?
22:29:31 <SyntaxNinja> dcoutts: right.
22:30:11 <newsham> stepcut: interesting, but not quite what i'm after.
22:30:24 <stepcut> :p
22:30:59 <monochrom> In xs, if the first number is k, the rest of the list sums up to w-k.  seems useful to set up a local function to make a list that starts with k and sums up to blah, for parameters k and blah.
22:31:30 <ivanm> monochrom: yeah, I tried to do something like that... my first attempt didn't seem to work so well :(
22:31:50 * ivanm tries again
22:31:50 <stepcut> newsham: btw, I found the lambda chapter in this book quite useful: http://research.microsoft.com/~simonpj/papers/slpj-book-1987/index.htm
22:31:53 <lambdabot> Title: The Implementation of Functional Programming Languages, http://tinyurl.com/fvgtw
22:32:04 <newsham> thanks
22:32:32 <newsham> I have this stuff implemented in python just fine, and followed the description in the paper I referenced above.
22:32:38 <monochrom> Oh! This function will return many xs's.  There are many choices.  Well, you can control the order of the choices to enforce non-increasing.
22:32:41 <newsham> but when i try it in python, it does not type check
22:32:52 <newsham> err in haskell
22:33:21 <ivanm> monochrom: if you think of anything else, can you @tell me? the room I'm in at uni is being taken over :s
22:33:32 * ivanm -> changing rooms
22:33:38 <dcoutts> "it does not typecheck in python" does not typecheck
22:33:54 <newsham> interesting statement, but not helpful.
22:34:09 * dcoutts is full of useless comments
22:34:35 <stepcut> newsham: is lambda a builtin python construct ?
22:34:41 <newsham> yes
22:36:13 <QtPlatypus> stepcut: But its crippeled and not as powerfull as real lambda's.
22:36:36 <newsham> *sigh* this always comes up.
22:36:45 <stepcut> QtPlatypus: and slated for removal, yes ?
22:36:57 <newsham> python's lambda is as powerful as haskells.
22:37:24 <newsham> but if you want lambdas in python with statements, you need to use named functions, not anonymous functions
22:38:10 <QtPlatypus> newsham: Can you nest two lambda's within each other?
22:38:15 <newsham> yes
22:38:57 <monochrom> can you do pattern matching...  oops wrong channel
22:38:59 <newsham> they're "limited" in teh sense that python lambdas can only contain expressions, not statements (just like in haskell)
22:39:06 <newsham> no, they cannot do pattern matching.
22:39:11 <QtPlatypus> And the scoping rules work correctly?
22:39:39 <newsham> yes, the scoping rules work correctly (there are some gotchas since python is not pure, but they're easy to deal with if you are aware)
22:40:30 <LeCamarade> monochrom, QtPlatypus: Python's lambdas are scheduled for removal, and they only take one statement. That's not bad if the language doesn't depend on many statements. Python does. They are out of step with the rest of the syntax (although it doesn't have to be like that).
22:40:49 <newsham> lecamarade: they dont take any statements.  they work with expressions.
22:40:54 <LeCamarade> In the end, even Perl's subs make better things.
22:41:04 <LeCamarade> newsham: Actuall, yeah. You're right.
22:41:06 <newsham> thats the diff between anonymous functions (expr only) and named functions (arbitrary statements) in python
22:41:39 <newsham> naming your functions is only a small inconvennience, and as you point out, it fits with the language syntax better
22:42:09 <newsham> since function nesting is allowed, and closures and all that bit, the expressive power is the same (although requiring programmer to make up names)
22:42:36 <LeCamarade> newsham: But do you ever use lambdas except for quick things where you require one expression? It's a bad direction for Python. Thank God they are remaining in Haskell.
22:42:59 <newsham> i do use them a bit, but only because i use them so often in other languages
22:43:09 <newsham> i'm fine with using nested functions instead.
22:43:28 <newsham> i've written lots of code both ways
22:45:09 <newsham> lec: for example:  http://www.thenewsh.com/~newsham/x/numbers.py
22:46:09 * ivanm has found a new room
22:46:45 <ddarius> newsham: Saying "python lambdas can only contain expressions ... (just like Haskell)" is a bit disingenuous.
22:47:17 <newsham> i disagree.  i think people saying that python does not support lambdas is disingenous
22:47:25 <newsham> and something of a pet peeve of mine
22:47:35 <ddarius> newsham: I more or less agree with that, but that has nothing to do with what I said.
22:48:06 <LeCamarade> newsham: I actually stopped using Python. These days, I script in Ruby and do everything else in Haskell and a few DSLs. Yeah, Py has lambdas, but they are going out. Closures aren't lambdas.
22:48:25 <ivanm> @pl \ (n :: Int) -> n
22:48:26 <lambdabot> (line 1, column 7):
22:48:26 <lambdabot> unexpected ":"
22:48:26 <lambdabot> expecting natural, identifier, "_" or "("
22:48:40 <ivanm> @pl \ n -> n :: Int -> Int
22:48:41 <lambdabot> (line 1, column 17):
22:48:41 <lambdabot> unexpected ">" or "-"
22:48:41 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
22:48:49 <ivanm> @t \ n -> n
22:48:50 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
22:48:55 <ivanm> @type \ n -> n
22:48:57 <lambdabot> forall t. t -> t
22:48:57 <monochrom> perhaps python is going pointfree, no need for lambda :)
22:48:57 <dibblego> @t \n -> n
22:48:58 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
22:49:23 <LeCamarade> dons would have sent us to #haskell-blah already... :oD
22:49:26 <ddarius> :t \n -> n
22:49:26 <ivanm> dibblego: just used to doing :t in ghci, that's all... forgot lb requires @type
22:49:28 <lambdabot> forall t. t -> t
22:49:35 <ddarius> #haskell-overflow
22:49:46 <LeCamarade> @time ivanm
22:49:47 <lambdabot> Local time for ivanm is Fri Apr 20 06:48:34 2007
22:50:07 <ivanm> I want the ceiling of the division of two ints... so whereas div rounds down, I want it round up
22:50:18 <ivanm> is it possible to do this without using fromIntegral?
22:50:22 <newsham> ?let zero = \f -> \g -> f
22:50:25 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
22:50:27 <dmwit> :t \n -> n -- ivanm: it works here too ;-)
22:50:29 <lambdabot> forall t. t -> t
22:50:34 <ivanm> LeCamarade: why do you want to know my time?
22:50:42 * LeCamarade wibders why ivanm enters the channel with him all the time. 
22:50:59 <LeCamarade> ivanm: We are within two hours of each other. :oD
22:51:01 <ivanm> dmwit: forgot you can do : commands
22:51:08 <LeCamarade> s/wibder/wonders/
22:51:12 <dmwit> You know, I've never actually seen LeCamarade and ivanm in the same place at the same time... very suspicious...
22:51:14 <ivanm> LeCamarade: I'm in Oz... you're NZ?
22:51:29 <ivanm> dmwit: well, seeing as how you've never seen me at all...
22:51:30 <ivanm> heh
22:51:49 <dmwit> And I haven't seen LeCamarade either!
22:51:53 <dmwit> You MUST be the same person!
22:51:54 <LeCamarade> ivanm: Nope. Most are Oceanians, here, but, nope. 3 hours faster than GMT.
22:52:10 <ivanm> where you from then?
22:52:22 <ivanm> dmwit: yeah, that makes _perfect_ sense :p
22:52:42 <ivanm> @pl \ n w -> ceiling((fromIntegral w) / (fromIntegral n))
22:52:42 <lambdabot> (ceiling .) . flip ((/) . fromIntegral) . fromIntegral
22:53:01 <ivanm> any way of automatically casting ints as doubles in haskell?
22:53:03 <LeCamarade> dmwit: I just watch the rants, usually. Less talk, more read. You know ...
22:53:11 <dmwit> > let divRoundUp a b = (a + b) `div` b in map (flip divRoundUp 3) [1..5]
22:53:13 <lambdabot>  [1,1,2,2,2]
22:53:26 <dmwit> > let divRoundUp a b = (a + b - 1) `div` b in map (flip divRoundUp 3) [1..5]
22:53:27 <ivanm> that's one of Java's features I really wish Haskell had... (automatic casting, that is)
22:53:28 <lambdabot>  [1,1,1,2,2]
22:54:14 <dmwit> ivanm: I think that there is the typical trick used in C code for rounding up.
22:54:14 <ddarius> Haskell pretty explicitly avoided that route.
22:54:28 <ivanm> > (\ n w -> (n + w - 1) `div` n) 4 6
22:54:29 <lambdabot>  2
22:54:37 <ivanm> dmwit: thanks!
22:54:41 <ivanm> dmwit++\
22:54:48 <ivanm> ddarius: why?
22:55:14 <dmwit> To protect the programmer?
22:55:19 <ddarius> Most Haskellers tend to like it.
22:55:41 <ivanm> @pl \ a b -> (a + b - 1) `div` b
22:55:42 <lambdabot> join . (div .) . flip flip 1 . ((-) .) . (+)
22:55:49 <dmwit> ew
22:55:52 <ddarius> But it's often actually somewhat cleaner and Haskell tends to avoid having things be implicit.
22:55:55 <ivanm> dmwit: protect them? in what way?
22:56:03 <ivanm> yeah, that's uglier :(
22:56:22 <dmwit> I think the idea is that you should know, just by looking, what type something is.
22:56:35 <ivanm> ddarius: its a pain having to do fromIntegral each time I'm temporarily casting it into a double before rounding it again
22:56:35 <fuzan> odd implicit casting errors.
22:56:43 <dmwit> If you look in one place and it looks like it ought to be a tree, and in another place it ought to be a list, and things just got cast so that worked...
22:56:50 <ivanm> and the automatic conversion to string is handy as well
22:56:55 <dmwit> it would be weird, and could easily allow behavior you didn't want.
22:57:02 <ivanm> dmwit: suppose so....
22:57:09 <ivanm> *sigh*
22:57:18 <ivanm> @pl \ b a -> (a + b - 1) `div` b
22:57:18 <lambdabot> flip =<< (div .) . flip flip 1 . ((-) .) . (+)
22:57:25 <ivanm> that's even worse :(
22:57:26 <dmwit> ivanm: When do you convert things to strings?  Only in IO, right?
22:57:31 <ivanm> :t \ b a -> (a + b - 1) `div` b
22:57:33 <lambdabot> forall a. (Integral a) => a -> a -> a
22:58:16 <ivanm> dmwit: mostly yes.... OK, I think I see your point
22:58:26 <ddarius> ivanm: If you find yourself repeating yourself, abstract it.
22:58:59 <dmwit> ?hoogle (Show a) => a -> IO ()
22:59:00 <lambdabot> Prelude.print :: Show a => a -> IO ()
22:59:00 <lambdabot> IO.hPrint :: Show a => Handle -> a -> IO ()
22:59:00 <lambdabot> Data.HashTable.delete :: HashTable key val -> key -> IO ()
22:59:11 <ivanm> true, though at the very least I wish fromIntegral had a shorter name...
22:59:19 <dmwit> yeah...
22:59:28 <ivanm> I mean, I could always just give it another name (fI = fromIntegral)
22:59:31 <ivanm> but its still a pain
22:59:45 <ivanm> that reminds me... what does showPrec do?
22:59:51 <hpaste>  LeCamarade pasted "(Unfaithful) Boyer-Moore Al-Gore-Rhythm" at http://hpaste.org/1476
23:00:07 <ivanm> I was reading a haskell book (possibly Birds, I forget) and the author kept defining showPrec instead of show
23:00:10 <monochrom> Haha
23:00:12 <dmwit> :t showPrec
23:00:14 <lambdabot> Not in scope: `showPrec'
23:00:17 <ivanm> when instancing the Shows class
23:00:18 <ddarius> Preferably you want to push all uses of fromIntegral and such into helper functions.
23:00:20 <ivanm> :t showsPrec
23:00:22 <lambdabot> forall a. (Show a) => Int -> a -> String -> String
23:00:36 <ivanm> OK, showsPrec, not showPrec
23:00:58 <ivanm> ddarius: true, but fromIntegral is still a very long functioin name...
23:01:10 <ivanm> then again, what else would you call it?
23:01:13 * LeCamarade waits for a rain of annotations on his paste.
23:01:16 <ddarius> It's not a problem if you don't use it much.
23:01:19 <fuzan> > let fI = fromIntegral in fI 10.0
23:01:20 <lambdabot>  Add a type signature
23:01:23 <ddarius> (Explicitly)
23:01:25 <ivanm> heh
23:01:38 <fuzan> you get the gist.
23:01:42 <ivanm> fuzan: yeah, I know you can do that...
23:01:57 <ivanm> anyway, so what does showsPrec do?
23:02:09 <dmwit> ivanm: Do you know what the ShowS class does?
23:02:11 <ddarius> shows with precedence
23:02:25 <ivanm> ddarius: precedence? in what way/respect?
23:02:42 <ddarius> ivanm: What if you want to show (3+4)*2
23:02:45 <ivanm> dmwit: Show defines how a type gets converted to string, right?
23:03:11 <ivanm> ddarius: oh, so its for joining together multiple instances of show?
23:03:13 <ddarius> ivanm: But essentially it's ad hoc, it just takes (and should pass as appropriate) an integer that essentially says whether you should add parens or not.
23:03:30 <ivanm> showsPrec (3 + 4)*2
23:03:44 <dmwit> ivanm: Not quite, ShowS is slightly different from Show.
23:03:45 <ivanm> duh, it needs other parameters, and the ">" at the start would help
23:03:54 <ivanm> dmwit: in what way?
23:03:55 <dmwit> It does better if you want to do a lot of (++) stuff.
23:04:05 <ivanm> example?
23:04:22 <dmwit> It basically constructs a (String -> String) function that (pre/ap?)pends the showed thing.
23:04:26 <LeCamarade> There is a type-specifying prob in my paste. The line I commented out (and then the compiler inferred right). Can you clean him up, lambdafolk?
23:04:30 <dmwit> > shows 35 "blargle"
23:04:32 <lambdabot>  "35blargle"
23:04:39 <dmwit> > shows 35
23:04:40 <lambdabot>  <[Char] -> [Char]>
23:05:11 <dmwit> > shows 35 . shows (Maybe 16) . shows "hi there!" $ "rah rah sis-kum-bah"
23:05:12 <lambdabot>   Not in scope: data constructor `Maybe'
23:05:18 <ivanm> :t shows
23:05:19 <dmwit> > shows 35 . shows (Just 16) . shows "hi there!" $ "rah rah sis-kum-bah"
23:05:21 <lambdabot> forall a. (Show a) => a -> String -> String
23:05:21 <lambdabot>  "35Just 16\"hi there!\"rah rah sis-kum-bah"
23:05:38 <ddarius> showsPrec p (Mul x y) = showsPrec mulPrec x . ('*':) . showsPrec mulPre y; showsPrec p (Add x y) | p > addPrec = showParens $ shows x . ('+':) shows y | otherwise = shows x . ('+':) . shows y
23:06:07 <ivanm> so its like explicitly doing (show a) ++ string ?
23:06:23 <LeCamarade> ivanm: Yeah.
23:06:23 <dmwit> right
23:06:26 <LeCamarade> @src shos
23:06:27 <lambdabot> Source not found. stty: unknown mode: doofus
23:06:29 <LeCamarade> @src shows
23:06:29 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
23:06:33 <ivanm> heh
23:06:34 <dmwit> ?src ShowS
23:06:35 <lambdabot> type ShowS = String -> String
23:06:49 <dmwit> ?index ShowS
23:06:49 <lambdabot> Text.Show, Prelude
23:07:01 <ivanm> ?doc ShowS
23:07:02 <lambdabot> ShowS not available
23:07:10 <ivanm> ?doc Prelude
23:07:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
23:07:14 <dmwit> err... what's the one I want?  that tells what types do ShowS
23:07:20 <dmwit> ?instances ShowS
23:07:22 <lambdabot> Couldn't find class `ShowS'. Try @instances-importing
23:07:34 <hyrax42> ShowS isn't a type
23:07:38 <hyrax42> I mean
23:07:39 <hyrax42> a class
23:07:40 <ivanm> prelude has it
23:07:43 <ddarius> @hoogle ShowS
23:07:43 <lambdabot> Prelude.ShowS :: type ShowS
23:07:44 <lambdabot> Prelude.shows :: Show a => a -> ShowS
23:07:44 <lambdabot> Numeric.showSigned :: Real a => (a -> ShowS) -> Int -> a -> ShowS
23:08:07 <dmwit> Huh.  I wonder how it can be better than just using (++), then.
23:08:23 <hyrax42> repeated use of (++) is slow
23:08:38 <ddarius> Left associative use of ++ is slow.
23:08:43 <ddarius> @src concat
23:08:43 <lambdabot> concat = foldr (++) []
23:08:45 <LeCamarade> dmwit: There is an explanation in the Prelude doc.
23:09:09 <hyrax42> ddarius: or that
23:09:21 <LeCamarade> Since the ++ is lazuly-evaluated, it won't really run until you need it to, saving cycles.
23:09:31 <ivanm> @pl \ xs -> concat (map (\ x -> x : (f x)) xs)
23:09:31 <lambdabot> (ap (:) f =<<)
23:09:44 <monochrom> head (concat blah) is cheap.
23:10:09 <monochrom> note that head (foldl (++) []) is not cheap.
23:10:14 <ddarius> By composing functions of the form ("foo"++), you ensure that all uses of (++) are right associative.
23:10:27 <ddarius> Laziness has nothing to do with it.
23:11:21 <LeCamarade> ddarius: Laziness does. You can append the world after "hello", but if you take 3, the world won't really be appended.
23:11:48 <ddarius> It has nothing to do with the ShowS representation.
23:12:01 <ddarius> Or why it is "better".
23:12:06 <LeCamarade> @hoogle ShowS
23:12:07 <lambdabot> Prelude.ShowS :: type ShowS
23:12:07 <lambdabot> Prelude.shows :: Show a => a -> ShowS
23:12:07 <lambdabot> Numeric.showSigned :: Real a => (a -> ShowS) -> Int -> a -> ShowS
23:12:09 <monochrom> In an eager language, head (foldr (++) [] blah) is linear and head (foldl (++) [] blah) quadratic.
23:12:28 <monochrom> In a lazy language, head (foldr (++) [] blah) is 1 and head (foldl (++) [] blah) linear.
23:13:16 <dmwit> ?src (++)
23:13:16 <lambdabot> (++) []     ys = ys
23:13:17 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
23:13:29 <ivanm> @pl gw n w = concat . (map (\ x -> x : (gw (pred n) (w - x)))) $ g n w
23:13:31 <lambdabot> gw = fix ((`ap` g) . (liftM2 ((join .) . map . ap (:)) .) . flip flip (-) . (((.) . (.)) .) . (. pred))
23:13:39 <ddarius> xs ++ ys = foldr (:) ys xs
23:13:40 <ivanm> *shudder*
23:14:07 <ivanm> @pl \ n -> x - n
23:14:07 <lambdabot> (-) x
23:14:14 <ddarius> Or (++) = flip (foldr (:))
23:14:16 <dmwit> But (++) is right-associative, why would it be quadratic?
23:14:27 <dmwit> More specifically,
23:14:50 <ddarius> dmwit: The lexical operator is right associated, (++) is actually completely associative semantically.
23:15:13 <ddarius> But if you write (xs++ys)++zs, it will evaluate in that order.
23:15:19 <dmwit> why would "blah" ++ "blah" ++ "blah" ++ ... ++ "blah" be quadratic in the number of "blah"s?
23:15:26 <ddarius> It's not.
23:15:29 <dmwit> Okay.
23:15:30 <dmwit> So.
23:15:58 <dmwit> Why would using shows be better than "blah" ++ show foo ++ show quux ++ "end of the world as we know it"?
23:16:18 <ddarius> dmwit: It isn't in that case, but consider showing a binary tree.
23:16:48 <ddarius> How the (++)'s are grouped will follow the tree's structure.
23:16:48 <dmwit> ah...
23:16:49 <LeCamarade> dmwit: It's not better, because it is well-nigh the very same thing.
23:16:58 <ivanm> @type \ xs -> concat (map (\ x -> x : (f x)) xs)
23:17:01 <lambdabot> Not in scope: `f'
23:17:17 <LeCamarade> The showS* stuff is just instance by a call to (x ++)
23:17:26 <ivanm> @type \ xs -> concat (map (\ x -> x : ([1..x])) xs)
23:17:27 <LeCamarade> @google learning haskell notes
23:17:28 <lambdabot> forall a. (Num a, Enum a) => [a] -> [a]
23:17:31 <lambdabot> http://www.ninebynine.org/Software/Learning-Haskell-Notes.html
23:17:31 <lambdabot> Title: Learning Haskell Notes
23:17:43 <LeCamarade> That's where I discovered it, when I was learning about it.
23:17:47 <ivanm> @type \ xs -> (map (\ x -> x : ([1..x])) xs)
23:17:49 <lambdabot> forall a. (Num a, Enum a) => [a] -> [[a]]
23:18:21 <ddarius> Or consider this, foldl (.) id [("foo"++),("bar"++),...] is linear, but foldl (++) [] ["foo","bar",...] is quadratic.
23:18:39 <ivanm> @type \ xs -> (map (\ x -> map (x:) (f x)) xs)
23:18:42 <lambdabot> Not in scope: `f'
23:18:49 <ivanm> @type \ xs -> (map (\ x -> map (x:) ([1..x])) xs)
23:18:51 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
23:18:52 <lambdabot>       Expected type: [a]
23:19:30 <ivanm> OK, my function calls itself recursively, with it returning a list of lists
23:22:30 <ivanm> @pl \ x -> map (x:) (f x)
23:22:31 <lambdabot> liftM2 map (:) f
23:23:17 * LeCamarade has lost patience ...
23:23:49 <LeCamarade> GO TO HPASTE AND HELP ME WITH THAT TYPE-RELATED ERROR! EVERYONE! ONE, TWO, THREE ...
23:24:22 * ddarius goes to get his laundry.
23:24:30 <ivanm> have fun ;)
23:27:01 <ivanm> monochrom: well, I've got partial success with the function I mentioned earlier...
23:27:09 * LeCamarade 's lips are quivering. He is gon' cry. Nobody is helping him ...
23:27:21 <ivanm> fine, what's the link?
23:27:36 <ivanm> there, there, LeCamarade, don't cry! :p
23:27:49 <quicksilver> LeCamarade: are you aware that the 'a' you're using in realBM is the same 'a' bound in boyerMoore?
23:27:58 <LeCamarade> :'o( Too latte!
23:28:08 <LeCamarade> quicksilver: Huh? Lemme see ...
23:30:32 <LeCamarade> quicksilver: Okay, use the line I commented out, the one above. It's cleaner. And then turn the a there into a', and it will still fail. I don't think the names matter that much - they are tightly scoped.
23:33:18 <ivanm> YAY!!! I've solved my problem! ;-)
23:33:31 <LeCamarade> ivanm: Which one?
23:34:25 <ivanm> writing a function "f n w" which takes in two Ints, and returns a list of lists xss such that for each xs in xss:
23:34:26 <quicksilver> LeCamarade: hmm, maybe the problem is they aren't the same
23:34:33 <quicksilver> LeCamarade: something odd here :)
23:34:49 <ivanm> length(xs) = n, sum(xs) = w and xs is strictly non increasing
23:35:02 <ivanm> oh, so f :: Int -> Int -> [[Int]]
23:35:10 <LeCamarade> quicksilver: If I could find out what the compiler infers there ...
23:35:24 * ivanm tidies up code
23:35:43 <LeCamarade> ivanm: Some sample run, if you don't mind?
23:36:13 <ivanm> f 3 4 = [[2,1,1].[2,2,0],[3,1,0]]
23:36:47 <ivanm> each sublist is of length 3, with sum 4 and is non-increasing
23:36:59 <LeCamarade> ivanm: Hmm ... lemme go of and kick it, then we'll compare notes.
23:38:15 <ivanm> hang on, that should have [4,0,0] in there as well... just found and fixed a bug
23:38:28 <LeCamarade> ivanm: The first arg is to limit the number of members in the returned list?
23:38:33 <ivanm> I take it back... that wasn't a bug
23:38:39 <ivanm> LeCamarade: right
23:38:52 <ivanm> and I forgot, for each sublist xs, max(xs) = n
23:39:35 <LeCamarade> ivanm: The max of each sublist should not be bigger than arg two, right?
23:39:45 <ivanm> no, arg 1
23:39:52 <ivanm> sum of the sublist should be arg 2
23:40:06 * LeCamarade goes of to terminal 2.
23:40:16 <ivanm> I end up using a helper function with a sig of Int -> Int -> Int -> [[Int]]
23:40:31 <LeCamarade> ivanm: Don't tell me your solution!
23:40:46 <ivanm> heh, I won't
23:41:33 <quicksilver> LeCamarade: I seem to recall this is a deficiency in haskell98
23:41:37 <quicksilver> LeCamarade: let me prod a bit further
23:41:47 <foxy-om> @seen dcoutts
23:41:48 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #haskell-overflow and #ghc. I last heard dcoutts speak 10m 13s ago.
23:41:52 <LeCamarade> quicksilver: Merci beaucoup.
23:42:05 <foxy-om> dcoutts: I just emailed you about that Cabal stuff...
23:42:15 <ivanm> quicksilver: prod away!
23:42:54 <ivanm> @type liftM2
23:42:57 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:43:38 <quicksilver> LeCamarade: here you go
23:43:40 <quicksilver> LeCamarade: http://hackage.haskell.org/trac/haskell-prime/wiki/ScopedTypeVariables
23:43:42 <lambdabot> Title: ScopedTypeVariables - Haskell Prime - Trac, http://tinyurl.com/3b2sn9
23:43:44 <dcoutts> foxy-om: got it, cheers
23:43:49 <quicksilver> it is a known h98 problem
23:44:01 <LeCamarade> Oh!
23:44:15 <LeCamarade> Gack. I have a scar from trying to solve it!
23:44:25 <LeCamarade> On my forehead. Bloodied walls.
23:44:41 <quicksilver> I believe there is a GHC extension to solve it but don't have the details at my fingertips
23:44:44 <LeCamarade> A strait jacket.
23:44:45 <quicksilver> that web page should explain though
23:44:53 <LeCamarade> quicksilver: Sure.
23:45:04 <dcoutts> foxy-om: ah it's the c2hs --include flag that you want, that behaves differently from -C-I
23:47:11 * ivanm -> physics society talk
23:47:37 <LeCamarade> ivanm: Why is it that your results have only three elems?
23:47:38 <ivanm> which happens to be on the non-physicsy subject of electoral systems
23:47:59 <LeCamarade> The lists could have been longer. And you said arg1 is for limiting max.
23:48:09 <ivanm> LeCamarade: because the first arg was 3? the two args I passed it were 3 and 4
23:48:13 <LeCamarade> Not limiting length. Or does it do both?
23:48:18 <ivanm> the first arg limits the length and the maximum element
23:48:35 <LeCamarade> ivanm: A'ight.
23:48:52 <ivanm> I'm going to use it to specify where values should go in a matrix
23:49:01 <ivanm> ok, cya all!
23:59:58 <foxy-om> dcoutts: Yeah, I need --cppopts as well...
