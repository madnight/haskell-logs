00:00:09 <sorear> full threeway handshake for each file
00:02:01 <sorear> put finished
00:10:06 <LoganCapaldo> @hoogle (a -> b) -> Writer c () -> a -> Writer c b
00:10:06 <lambdabot> No matches, try a more general search
00:11:05 <LoganCapaldo> @type (\a b -> b >> return . a)
00:11:07 <lambdabot> forall a b (m :: * -> *) a1. (Monad m) => (a1 -> b) -> (a1 -> a) -> a1 -> m b
00:12:31 <LoganCapaldo> @type (\a b -> a >> return . b) (do { tell [1] }) (\x -> x + 1)
00:12:33 <lambdabot> forall (m :: * -> *) a t. (Monad m, Num t, MonadWriter [t] ((->) a), Num a) => a -> m a
00:12:44 <LoganCapaldo> @type (\a b -> a >> return . b) (do { tell [1] }) (\x -> x + 1) 2
00:12:47 <lambdabot> forall (m :: * -> *) a t. (Monad m, Num t, MonadWriter [t] ((->) a), Num a) => m a
00:13:06 <LoganCapaldo> runWriter $ (\a b -> a >> return . b) (do { tell [1] }) (\x -> x + 1) 2
00:13:10 <LoganCapaldo> > runWriter $ (\a b -> a >> return . b) (do { tell [1] }) (\x -> x + 1) 2
00:13:11 <lambdabot>        add an instance declaration for (MonadWriter [t] ((->) a))
00:13:11 <lambdabot>     In the ...
00:14:03 <eumenides> hm the yi executable is 10MB?
00:14:35 <LoganCapaldo> > let note k f x = do { tell k; return $ f x } in runWriter $ note [1] (+1) 2
00:14:36 <lambdabot>  (3,[1])
00:15:07 <jyp> eumenides: yes
00:15:18 <jyp> It contains ghc :p
00:15:27 <LoganCapaldo> @type let note k f x = do { tell k; return $ f x } in note
00:15:30 <lambdabot> forall w t a (m :: * -> *). (MonadWriter w m) => w -> (t -> a) -> t -> m a
00:16:04 <LoganCapaldo> @hoogle (MonadWriter w m) => w -> (t -> a) -> t -> m a
00:16:05 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
00:16:34 <araujo> hello
00:18:09 <LoganCapaldo> @type noting v notation = tell notation >> return v in runWriter $ (+1) 2 `noting` ["Adding One"]
00:18:11 <lambdabot> parse error on input `='
00:18:21 <LoganCapaldo> @type let noting v notation = tell notation >> return v in runWriter $ (+1) 2 `noting` ["Adding One"]
00:18:23 <lambdabot> forall a. (Num a) => (a, [[Char]])
00:18:33 <LoganCapaldo> > let noting v notation = tell notation >> return v in runWriter $ (+1) 2 `noting` ["Adding One"]
00:18:34 <lambdabot>  (3,["Adding One"])
00:19:23 <int-e> lambdabot: is your name shiqi?
00:20:42 <LoganCapaldo> sugar++
00:20:46 <LoganCapaldo> @karma sugar
00:20:47 <lambdabot> sugar has a karma of 2
00:22:18 <Cheery> @karma sugar++
00:22:19 <lambdabot> sugar++ has a karma of 0
00:22:33 <jyp> @karma jyp
00:22:33 <lambdabot> You have a karma of 6
00:22:37 <jyp> whoa
00:22:43 <Cheery> @karma Cheery
00:22:44 <lambdabot> You have a karma of 0
00:22:57 <Cheery> interesting
00:29:06 * araujo reading the Stream Fusion paper
00:30:34 <int-e> @karma larry
00:30:34 <lambdabot> larry has a karma of 85
00:30:36 <int-e> @karma lwall
00:30:37 <lambdabot> lwall has a karma of 52
00:30:49 <integral> @karma TimToady
00:30:49 <lambdabot> TimToady has a karma of 25
00:31:16 <sorear> @karma
00:31:17 <lambdabot> You have a karma of 30
00:31:23 <sorear> @karma audreyt
00:31:23 <lambdabot> audreyt has a karma of 630
00:31:30 <sorear> @karma-all
00:31:31 <lambdabot>  "audreyt"             630
00:31:31 <lambdabot>  "dons"                131
00:31:31 <lambdabot>  "fglock"              118
00:31:31 <lambdabot>  "gaal"                 89
00:31:31 <lambdabot>  "larry"                85
00:31:33 <lambdabot> [889 @more lines]
00:31:38 <notsmack> 630??
00:31:43 <sorear> 630!
00:31:46 <int-e> #perl6 commit announcements
00:31:49 <sorear> really.
00:31:54 <araujo> hah
00:32:21 <desp> @seen bos
00:32:22 <lambdabot> bos is in #haskell-soc and #haskell. I last heard bos speak 7h 20m 49s ago.
00:34:18 <LoganCapaldo> @karma
00:34:19 <lambdabot> You have a karma of 4
00:34:36 <LoganCapaldo> @dharma
00:34:37 <lambdabot> You have a karma of 4
00:35:26 <LoganCapaldo> @yin
00:35:27 <lambdabot> Maybe you meant: id join kind ring run wn yow
00:35:32 <LoganCapaldo> @yang
00:35:34 <lambdabot> Maybe you meant: ring yarr
00:35:39 <LoganCapaldo> @yarr
00:35:40 <lambdabot> Aye Aye Cap'n
00:35:44 <LoganCapaldo> @ring
00:35:57 <LoganCapaldo> @help ring
00:35:58 <lambdabot>  @ring <user>, CSE phonebook
00:36:09 <LoganCapaldo> CSE?
00:36:18 <LoganCapaldo> @ring dons
00:37:04 <eumenides> isn't using StateT ProgramState IO a basically admitting that imperative is better?
00:37:37 <LoganCapaldo> imperative is better
00:37:38 <sorear> computer science and engineering
00:38:06 <sorear> it's a <noun> of the university of new south wales
00:38:14 <sorear> which is educational
00:38:19 <sorear> and in australia
00:38:33 <LoganCapaldo> dept. ?
00:38:44 <sorear> and while I'm at it, manzano is just dons' pc's name
00:39:10 <sorear> LoganCapaldo: sounds right
00:39:19 <sorear> now you know what cse.unsw.edu.au means
00:39:26 <LoganCapaldo> indeed
00:39:49 <notsmack> what's ProgramState?
00:39:51 <LoganCapaldo> interesting choice of apos placement
00:40:49 <LoganCapaldo> assuming dons = Don Stewart I woulda done dons's
00:41:14 <LoganCapaldo> otoh
00:41:50 <sorear> <fake accent> When *I* was a kid, they told people not to put an s after an s'!
00:41:58 <sorear> istr they've changed it, again
00:42:11 <LoganCapaldo> sorear: no no
00:42:13 <sorear> but I don't care, i'll act like it's too late now
00:42:16 <LoganCapaldo> that's not what I'm saying
00:42:43 <LoganCapaldo> dons's isn't putting an s after an s'
00:42:57 <LoganCapaldo> its putting an 's after an implicit t :)
00:53:42 <dons> moin.
00:54:35 <eumenides> notsmack: just some program state
00:55:08 <dons> araujo: how'd you get a copy? :-)
00:56:07 <dons> sjanssen: i notice kill on some firefox windows no longer works.
00:56:16 <dons> i wonder if my hacked in support for that is broken.
00:59:15 <sorear> hi dons.  hope LoganCapaldo didn't wake you ;)
00:59:39 <dons> had to wake up some time.
01:00:32 <sorear> so, do you wish you started your paper a day earlier yet? :)
01:26:24 <araujo> dons, hello!
01:45:20 <kolmodin> dons, araujo: hia!
01:46:22 <araujo> kolmodin!!!
01:46:29 <kolmodin> araujo!!11
01:46:32 <araujo> :-)
01:46:35 <kolmodin> :)
01:49:46 <Cheery> if a calculation takes too long, is there a way to make it suspend?
01:50:30 <Heffalump> I don't think so.
01:50:53 <Cheery> ie. lets say you calculate a factorial with big number
01:51:05 <Cheery> (factorial x)
01:51:36 <Cheery> do you guys have something you could wrap this function application to make it suspend, say, after 5 ms
01:53:42 <int-e> You can do the calculation in a separate thread and kill that thread if it takes too long.
01:55:21 <Cheery> I realise that myself as well
01:55:47 <Cheery> does haskell have coroutines?
01:56:28 <int-e> hmm, one way to understand lazy evaluation is to think of every computation as a coroutine
01:58:22 <int-e> [1..] would be a coroutine that evaluates the list to 1:[2..] and then passes control back to the caller.
01:59:09 <Cheery> yeh, I kind of see where you are pushing me
01:59:23 <Cheery> +at
02:00:05 <Cheery> I think it's ok
02:02:09 <int-e> it's trickier in the IO monad; unsafeInterleaveIO can be used there.
02:02:49 <Cheery> @hoogle unsafeInterleaveIO
02:02:50 <lambdabot> System.IO.Unsafe.unsafeInterleaveIO :: IO a -> IO a
02:03:11 <joelr1> good morning
02:03:21 <Cheery> good evening
02:03:34 <joelr1> does anyone know how to override instance declarations?
02:03:42 <joelr1> is there an -fallow-overlapping-instances?
02:05:20 <int-e> yes.
02:06:24 <joelr1> i tried putting that in the file itself but ghc still complains
02:07:09 <int-e> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#instance-overlap -- you might need -fallow-incoherent-instances . but you're on shaky ground there.
02:07:11 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
02:07:24 <joelr1> darn
02:07:32 <joelr1> maybe i should describe the problem
02:07:44 <joelr1> i want to constrain lists in quickcheck to a certain size
02:08:44 <int-e> the usual idea is to wrap the list in a newtype, newtype ConstrainedList a = ConstrainedList { fromContrainedList :: [a] }  and provide a new Arbitrary instance for the newtype.
02:09:06 <joelr1> oh
02:09:40 <joelr1> that would surely work
02:09:41 <int-e> and then use  (fromContrainedList l) instead of l in the properties.
02:10:07 <joelr1> well, i just have arbitrary everywhere
02:10:41 <joelr1> but instantiating this type would work for me
02:11:08 <joelr1> well... anyway, at least there's a solution
02:12:14 <joelr1> int-e: thanks for the tip
02:26:58 <joelr1> int-e: question
02:27:03 <joelr1> does this look right to you?
02:27:04 <joelr1> instance (Arbitrary a) => SizedList a where
02:27:04 <joelr1>     arbitrary = sized $ \n -> resize 3 (fromSizedList :: [a])
02:27:25 <joelr1> because ghc complains about arbitrary not being a visible method of SizedList
02:27:32 <Heffalump> you seem to have things backwards
02:27:44 <joelr1> i do?
02:27:48 <Heffalump> your instance declaration says "if a is an Arbitrary then here's how a is a SizedList"
02:28:07 <joelr1> oh
02:28:12 <Heffalump> and then you proceed to define "arbitrary", which presumably is an explanation of how a is an Arbitrary, not how a is a SizedList
02:28:30 <Heffalump> also, that instance declaration isn't valid Haskell 98, though it'll be fine with -fallow-undecidable-instances
02:28:54 <int-e> I'd expect  arbitrary = liftM SizedList $ replicateM_ 3 arbitrary  where 3 is your length
02:28:59 <joelr1> Heffalump: all i want to do is make sure my lists in quickcheck are of a given size. not all of them, just some
02:29:05 <int-e> err. no _ there
02:29:44 <Heffalump> I don't understand your code, but int-e seems to. I just understand that your instance declaration looks rather wrong :-)
02:29:57 <joelr1> int-e: where does from... come into play then?
02:30:29 <int-e> joelr1: when you try to use those lists
02:30:46 <Saizan> you have just forgot the class name,  instance (Arbitrary a) => Arbitrary (SizedList a) where ...
02:31:11 <joelr1> Saizan: that's it!
02:31:13 <int-e> Saizan: ah. heh, I missed that.
02:31:49 <joelr1> thank you folks
02:31:52 <Cheery> int-e: me and my pal are arguing whether one would need to implement coroutines on haskell or not, there seems to be a keypoint in IO
02:32:07 <Heffalump> ahhh.
02:32:12 <joelr1> now i have to figure how how to extract the type in Data.Derive and generate fromSizeList instead of arbitrary in that case
02:32:22 <Heffalump> I should have guessed that fromSizedList was an accessor
02:32:39 <Heffalump> Cheery: have you read why FP matters?
02:32:55 <Cheery> FP as in functional programming?
02:32:57 <Heffalump> yes
02:33:07 <Heffalump> oh, that bit was already discussed, never mind
02:33:08 <Cheery> in what context it matters?
02:33:10 <int-e> Cheery: yes, in IO coroutines have to be coded explicitely.
02:33:24 <ndm> @seen sorear
02:33:25 <lambdabot> I saw sorear leaving #darcs, #haskell-overflow, #ghc, #haskell and #happs 1h 10m 22s ago, and .
02:33:30 <Heffalump> or use unsafeInterleaveIO
02:33:33 <ndm> any template haskell people around?
02:33:36 <int-e> Cheery: which isn't exactly safe, hence the unsafe prefix in unsafeInterleaveIO
02:33:52 <Heffalump> ah, that's what you mean by explicitly
02:34:02 <int-e> Heffalump: yes
02:34:05 <ndm> I want to do [| instance Foo Bar where foo = 1 \]
02:34:11 <ndm> or something similar
02:34:19 <Heffalump> or if you can, pass around [IO a] rather than IO [a]
02:34:32 <ndm> but i can't figure out how to put things other than expressions in [| |]
02:34:35 <Heffalump> presumably with a |] at the end not \]
02:34:45 <Heffalump> don't you want [d| ... |] ?
02:34:53 <ndm> Heffalump: of course, tiny keyboard here, the ctrl key is in the wrong place
02:34:54 <Heffalump> there are different brackets for different syntactic categories, IIRC
02:34:57 <int-e> Heffalump: I said earlier that one way to understand [1..] is to view it as a coroutine that results in 1:[2..] and passes control back; this is what I'd call an implicit coroutine in this context.
02:35:15 <Heffalump> int-e: right, that was the reference I was making to Why FP matters
02:35:21 <Cheery> ok, int-e: how would you implement non-blocking IO in haskell?
02:35:28 <ndm> Heffalump: works perfectly, thanks :)
02:35:35 <Heffalump> Cheery: look at the source for hGetContents
02:35:43 <Heffalump> or just use it :-)
02:35:48 <Cheery> @src hGetContents
02:35:49 <lambdabot> Source not found. The more you drive -- the dumber you get.
02:35:58 <Heffalump> @src System.IO.hGetContents
02:35:59 <lambdabot> Source not found. Take a stress pill and think things over.
02:36:06 <Heffalump> odd
02:36:18 <int-e> hGetContents :: Handle -> IO String     -- Defined in GHC.IO
02:36:34 <Heffalump> @src GHC.IO.hGetContents
02:36:35 <lambdabot> Source not found. It can only be attributed to human error.
02:36:38 * Heffalump gives up :-)
02:37:26 <Cheery> but the unsafeInterleaveIO is only half-way there
02:37:32 <Heffalump> what do you mean?
02:38:19 <Cheery> well, you can make it to be lazy that way, but can you make it to switch doing something else if it can't evaluate?
02:38:34 <int-e> anyway, the kernel of hGetContents is called lazyRead and starts with  lazyRead handle = unsafeInterleaveIO $ <normal IO code>  which eventually calls lazyRead recursively, after reading one buffer size worth of data.
02:38:37 <Cheery> ie. green threads, greenlets, coroutines
02:39:09 <Heffalump> ah, right
02:39:43 <Heffalump> can you suggest a type signature for what you'd want?
02:40:26 <int-e> hmm, http://haskell.org/haskellwiki/Timing_out_computations
02:40:27 <lambdabot> Title: Timing out computations - HaskellWiki
02:40:27 <Cheery> I can, let me think for a moment...
02:41:58 <Heffalump> AFAIK, that trick for timing stuff out doesn't work with let foo () = foo () in foo ()
02:42:04 <Heffalump> cos it doesn't allocate
02:42:32 <int-e> http://hackage.haskell.org/trac/ghc/ticket/367 :)
02:42:34 <lambdabot> Title: #367 (Infinite loops can hang Concurrent Haskell) - GHC - Trac
02:42:58 <Cheery> sure they can, but what's concurrent haskell?
02:43:06 <Heffalump> that's just GHC
02:43:19 <Cheery> is GHC concurrent haskell?
02:43:28 <int-e> what's meant is that Control.Concurrent and several threads are used
02:43:48 <Cheery> how efficient is that?
02:43:59 <Heffalump> Haskell threads are very efficient
02:44:34 <Cheery> Heffalump: are they similar to erlang threads?
02:44:41 <Heffalump> I don't know.
02:45:02 <Heffalump> but they are generally considered to be very lightweight and worth using for even a small bit of work
02:45:48 <Cheery> are they pure haskell?
02:45:56 <Cheery> ie. no interfaces to lower levels?
02:45:57 <Heffalump> they are not Haskell 98, if that's what you mean
02:46:03 <Heffalump> and they are only available in the IO monad
02:46:11 <Heffalump> at least, you can only fork and synchronise in the IO monad
02:46:57 <int-e> Cheery: define 'lower levels'.
02:48:11 <Cheery> assembly, direct control (ie. no through other modules), little or no involvement of OS-support for threads?
02:48:38 <Cheery> word 'Concurrent' gives the hint it'd be like this thought
02:50:42 <Cheery> "Concurrency is "lightweight", which means that both thread creation and context switching overheads are extremely low.  Scheduling of Haskell threads is done internally in the Haskell runtime system, and doesn't make use of any operating system-supplied thread packages."
02:50:51 <Cheery> ok, this is what I am looking for, I guess
02:50:56 <int-e> Cheery: OS threads aren't involved, unless you specificially ask for one.
02:51:04 <Saizan> they are userland threads which get mapped to any number of kernel thread at runtime as you specify to +RTS
02:51:28 <Dazhbog> Cheery: okay people will hang me but fwiw http://shootout.alioth.debian.org/sandbox/benchmark.php?test=chameneos&lang=all
02:51:31 <lambdabot> Title: chameneos benchmark | Debian : AMD&#8482; Sempron&#8482; The Sandbox, http://tinyurl.com/2crd7n
02:51:38 <Saizan> on shootout GHC beats Erlang on the high concurrency benchmark
02:55:54 <Cheery> huh, that means GHC has some performance in those concurrency structures
02:56:33 <Dazhbog> I'm starting to feel I should really try to actually write some code in haskell :P
02:56:58 <Cheery> why so?
02:57:04 <Cheery> haven't you? :)
02:57:34 <Cheery> damn, I think writing programs in haskell is easier than anywhere!
02:57:56 <Dazhbog> Well, I have written a few small programs in haskell..
02:58:11 <Cheery> it is almost like I only need to look at the type declaration and name of a function in haskell, and I know what does it do
02:58:35 <Dazhbog> But still not enough to get the feeling if I like it or not
03:01:27 <hpaste>  Saizan pasted "linking problems" at http://hpaste.org/1290
03:01:49 <Saizan> am i the only one experiencing such linking problems?
03:02:46 <int-e> @where derive
03:02:46 <qwr> Saizan: you probably need to give some -package foo as ghc argument
03:02:46 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/derive/
03:03:26 <Saizan> qwr: shouldn't --make be enough?
03:06:27 <qwr> hmm. look whether ghc-pkg list knows about derive ?
03:10:41 <Saizan> yes it knows, the problem seems to be inside the .o of the lib, not in the program i'm compiling right now
03:16:15 <lispy> > fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)
03:16:17 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
03:17:39 <opqdonut> > fix $ \somethingelse -> 0 : 1 : zipWith (+) somethingelse (tail somethingelse)
03:17:40 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
03:17:48 <opqdonut> ^_^
03:17:52 <lispy> :)
03:18:05 <opqdonut> > fix $ \thus -> 1 : zipWith (+) thus (tail thus)
03:18:07 <lambdabot>  Exception: <<loop>>
03:18:14 <lispy> typical compter scientist, off by one :)
03:18:18 <opqdonut> nah, not specific enough
03:21:36 <int-e> Saizan: try adding  Data.Derive.Peephole  to the exposed modules of derive?
03:23:09 <Saizan> uoh, right, i kept adding modules to the cabal but didn't encounter that one
03:26:44 <mauke> @hoogle (a -> m (a, b)) -> m (a, b)
03:26:45 <Saizan> thanks
03:26:45 <lambdabot> Control.Monad.Writer.listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
03:28:00 <mauke> wait, that's not what I wanted
03:35:33 <astrolabe> I just had an idea.  I'll define a global 'toDo = error "not written yet"', and use it to allow me to check that partially written code compiles.
03:36:09 <mauke> I use undefined for that
03:36:42 <astrolabe> Oh yeah.  Scratch my Nobel Prize :(
03:42:13 <joelr1> @paste
03:42:13 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:44:34 <hpaste>  joelr1 pasted "multi-param typeclasses?" at http://hpaste.org/1291
03:44:49 <joelr1> folks, any suggestions with the above?
03:45:02 <joelr1> i'm trying to simplify my AST specification
03:45:10 <joelr1> for describing tests
03:45:43 <Saizan> you need -fglasgow-exts for multiparameter typeclasses (MPTC)
03:45:52 <joelr1> Saizan: i added that
03:45:52 <mauke> don't you want class PlusClass a b c | a b -> c where ...?
03:46:01 <joelr1> ah!
03:46:09 <Saizan> why do you put PlusClass a b c =>?
03:46:25 <joelr1> Saizan: no idea. i'm coming back to haskell after a 1yr absense
03:46:31 <Saizan> ok
03:46:46 <mauke> wait, why not class PlusClass a b where (+) :: a -> b -> Expr
03:47:54 <joelr1> mauke: because i'm not always using plus in the context of Expr. sometimes it's StrExpr or NumExpr, etc.
03:48:01 <Saizan> well you use instance Foo a => Bar (T a) where only when you need your a to be of class Foo for that instance to work, given that you don't use neither a b or c in the RHS of your instance definition you don't need that context
03:48:16 <mauke> joelr1: huh? those aren't types
03:48:42 <joelr1> Saizan: so how do i properly do this?
03:49:19 <joelr1> mauke: those _are_ types in my case. NumExpr, StrExpr, Expr are types
03:49:27 <joelr1> but there are also matching constructors
03:49:28 <Saizan> oh
03:49:55 <Saizan> so NumExpr is a constructor for NumExpr?
03:49:57 <joelr1> the NumExpr constructor returns Expr, for example
03:49:59 <Saizan> or also for Expr?
03:50:12 <joelr1> Int or Double return NumExpr, Str returns StrExpr
03:50:54 <hpaste>  Saizan annotated "multi-param typeclasses?" with "this works if the types match" at http://hpaste.org/1291#a1
03:51:29 <joelr1> Saizan: checking, thanks
03:51:39 <Saizan> (you have to hide Prelude (+) )
03:52:24 <joelr1> Saizan: yep, did that
03:52:32 <joelr1> thank you guys
03:52:54 <joelr1> this should save me a lot of typing
03:53:15 <joelr1> imagine typing in a numerical expression with various + or - in direct AST notation!
03:56:27 <Saizan> hao to skip the whole parsing part, eh?:)
04:06:41 <araujo> morning
04:28:16 <eumenides> > (+1) <$> [1,2,3]
04:28:18 <lambdabot>  [2,3,4]
04:28:43 <resiak> @type (<$>)
04:28:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:28:53 <resiak> @index <$>
04:28:53 <lambdabot> bzzt
04:28:57 <resiak> @index (<$>)
04:28:57 <lambdabot> bzzt
04:29:16 <resiak> I see!
04:30:34 <joelr1> Saizan: i'm specifying the ast to match parsing against. unit tests, you know
04:31:37 <mauke> is there any documentation for Control.Monad.Writer?
04:31:59 <xerox> resiak, control.applicative
04:32:15 <resiak> xerox: thank you, mr photocopier!
04:32:34 <mauke> especially listen and pass
04:33:14 <xerox> mauke, something else than haddock? I think all-about-monads covers writer.
04:33:47 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Writer.html just gives type signatures
04:33:50 <lambdabot> http://tinyurl.com/2gwelv
04:34:02 <mauke> and "Inspired by the paper Functional Programming with Overloading and Higher-Order Polymorphism"
04:34:12 <mauke> that paper doesn't talk about this Writer
04:34:30 <joelr1> :f flip
04:34:40 <joelr1> :t flip
04:34:42 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
04:37:30 <hpaste>  joelr1 annotated "multi-param typeclasses?" with "flip?" at http://hpaste.org/1291#a2
04:37:38 <joelr1> any idea?
04:37:49 <joelr1> i'm on a quest to simplify things
04:38:36 <mauke> not directly
04:38:58 <mauke> you could say (+) = munge . flip (+)
04:39:08 <joelr1> munge?
04:39:08 <mauke> er, (munge .) .
04:39:16 <joelr1> :t munge
04:39:17 <joelr1> hehe
04:39:19 <lambdabot> Not in scope: `munge'
04:39:52 <mauke> where munge (NumExpr (NumOp op a b)) = NumExpr (NumOp op b a)
04:39:57 <joelr1> ouch
04:40:01 <joelr1> ok, thanks
04:41:06 <joelr1> :t 1
04:41:08 <lambdabot> forall t. (Num t) => t
04:41:48 <joelr1> :t toInteger
04:41:50 <lambdabot> forall a. (Integral a) => a -> Integer
04:42:22 <joelr1> integer is the arb precision type, right? as opposed to Int?
04:42:27 <joelr1> :t toInt
04:42:30 <lambdabot> Not in scope: `toInt'
04:42:33 <joelr1> hmm
04:42:45 <joelr1> :t fromInt
04:42:48 <lambdabot> Not in scope: `fromInt'
04:43:14 <xerox> ?type fromIntegral
04:43:17 <lambdabot> forall a b. (Num b, Integral a) => a -> b
04:43:19 <xerox> ?type (round,floor,ceiling)
04:43:22 <lambdabot> forall a b a1 b1 a2 b2. (RealFrac a, Integral b, RealFrac a1, Integral b1, RealFrac a2, Integral b2) => (a -> b, a1 -> b1, a2 -> b2)
04:43:26 <joelr1> right
04:45:06 <mauke> the type of listens is wrong in all-about-monads
04:46:13 <hpaste>  joelr1 annotated "multi-param typeclasses?" with "one last thing" at http://hpaste.org/1291#a3
04:46:18 <mauke> why is pass the primitive operation and not censor?
04:46:18 <joelr1> one last thing, promise!
04:47:24 <hpaste>  joelr1 annotated "multi-param typeclasses?" with "not clear how to fix this" at http://hpaste.org/1291#a4
04:47:42 <joelr1> what am i doing wrong?
04:49:04 <joelr1> :t 20 + 40
04:49:07 <lambdabot> forall t. (Num t) => t
04:50:55 <Saizan> ?type (+)
04:50:58 <lambdabot> forall a. (Num a) => a -> a -> a
04:51:12 <Saizan> this force the two arguments to be the same type
04:51:20 <Saizan> your (+) don't
04:52:01 <Saizan> instance (Integral a,Integral b) => PlusClass a b Expr where <-- this should work
04:53:10 <joelr1> doesn't quite work. let me paste the error
04:54:02 <hpaste>  joelr1 annotated "multi-param typeclasses?" with "overlapping instances" at http://hpaste.org/1291#a5
04:54:12 <joelr1> overlapping instances
04:54:58 <joelr1> i don't get it
04:58:18 <Saizan> heh
04:58:31 <joelr1> Saizan: is this something basic that i'm doing wrong?
04:59:14 <joelr1> all i want is to add my two integers
04:59:20 <joelr1> or ints and doubles
04:59:23 <Saizan> no, it's mtpc and those so general instances that are getting you into trouble :)
04:59:23 <joelr1> or vise versa
04:59:38 <joelr1> Saizan: is there a fix?
05:00:12 <joelr1> i really don't want to type in NumExpr (NumOp Plus (Int a)) (Double b)) for every plus in the ast
05:01:16 <Saizan> well, you can add that -fallow-incoherent-instances flag, but it's not so safe, or else you could restrict the instance (Integral a,Integral b) => PlusClass a b Expr where instance to PlusClass Int Int Expr or PlusClass Integer Integer Expr, but i'm not an expert in this field
05:01:53 <yip__> i'm using STM. how do i know if i am using too many TVars? I find I keep changing things in my data structures from a => TVar a, I have lots of TVars inside other TVars...
05:02:12 <joelr1> Saizan: that was the initial version, PlusClass Int Int Expr but it wasn't picking it up anyway
05:02:28 <joelr1> Saizan: it complained that there's no instance of PlusClass t t1
05:02:47 <Saizan> mmh because it couldn't infer the types
05:03:03 <Saizan> :t 1
05:03:06 <lambdabot> forall t. (Num t) => t
05:03:26 <joelr1> Saizan: right. that's where i got the bright idea for my last and too general version
05:03:34 <eumenides> > Nothing <|> Just 1
05:03:35 <lambdabot>  Just 1
05:03:52 <joelr1> :t <|>
05:03:54 <lambdabot> parse error on input `<|>'
05:03:55 <Saizan> however number litereals default to Integer, so maybe PlusClass Integer Integer can work
05:04:11 <joelr1> i think that's what i had initially
05:04:14 <joelr1> let me revert
05:04:18 <Saizan> oh..
05:04:34 <Saizan> well, so maybe the flag is the better choice :)
05:05:06 <Saizan> it's lunchtime, so i'll be back in a while..
05:15:44 <Saizan> back
05:19:49 <joelr1> :-)
05:24:21 <cm_> hi
05:24:25 <cm_> what's the haskell web server (library) du jour?
05:29:48 <Philippa> cm_: probably HAppS
05:30:15 <Philippa> if you want something that's definitely stable enough, the rewritten Network.CGI made it into the hierarchical libs and I think there's a FastCGI variant
05:32:40 <joelr1> Philippa: any suggestions on http://hpaste.org/1291#a4 ?
05:34:06 <foxy-om> joelr1: -fallow-overlapping-instances
05:34:19 <joelr1> trying
05:35:11 <joelr1> foxy-om: doesn't work
05:35:31 <joelr1> foxy-om: see the paste above
05:35:38 <foxy-om> can't you say instance PlusClass a b c => PlusClass b a c to get rid of repeats
05:37:15 <joelr1> foxy-om: beats me. i'll try that, though
05:38:14 <foxy-om> joelr1: do you have definitions for your types so I can try and load the file?
05:38:33 <joelr1> foxy-om: instance PlusClass a b c => PlusClass b a c  gives the constraint no smaller than the instance head error
05:38:57 <joelr1> foxy-om: let me write them up real quick.
05:39:29 <yip__> cm_: there's also a new web-devel mailing list
05:39:44 <foxy-om> joelr, you probably want functional depencies too, don't you: class PlusClass a b  | a b -> c where
05:40:01 <foxy-om> s/pencies/pendencies/
05:40:36 <hpaste>  joelr1 annotated "multi-param typeclasses?" with "types" at http://hpaste.org/1291#a6
05:40:41 <joelr1> foxy-om: check
05:40:54 <joelr1> foxy-om: i have that in the paste
05:41:06 <foxy-om> heh
05:41:18 <joelr1> hmm
05:41:20 <joelr1> although
05:41:38 <joelr1> is there a difference between what you have and class PlusClass a b c | a b -> c ?
05:41:51 <joelr1> is there a typo?
05:41:58 <foxy-om> my typo
05:42:08 <joelr1> ok
05:42:11 <foxy-om> you haven't provided all the data types
05:42:24 <joelr1> foxy-om: check the paste :) two annotations at the bottom
05:42:56 <foxy-om> NumOp, Plus, StrOp
05:43:04 <foxy-om> StrPlus
05:43:20 <joelr1> foxy-om: also data Type = TyNumber | TyString, data NumOp = Plus | Minus ... and data StrOp = StrPlus
05:43:25 <joelr1> foxy-om: apologies, my bad
05:44:21 <hpaste>  joelr1 annotated "multi-param typeclasses?" with "more types" at http://hpaste.org/1291#a7
05:44:36 <joelr1> and even more...
05:45:58 <hpaste>  joelr1 annotated "multi-param typeclasses?" with "should be all the types" at http://hpaste.org/1291#a8
05:46:09 <joelr1> foxy-om: ok, i think i got them all now
05:46:40 <foxy-om> data constructors NumOp, StrOp
05:46:51 <hpaste>  joelr1 annotated "multi-param typeclasses?" with "function inp" at http://hpaste.org/1291#a9
05:47:07 <joelr1> foxy-om: check paste
05:47:50 <foxy-om> yeah, you say:
05:47:52 <foxy-om> instance PlusClass Integer Double Expr where
05:47:53 <foxy-om>     a + b = NumExpr (NumOp Plus (Int a) (Double b))
05:47:55 <foxy-om> but NumOp in your paste is a nullary data constructor
05:48:22 <joelr1> NumOp is. NumExpr
05:48:45 <foxy-om> and NumExpr is either an (Int foo) or (Double foo)
05:49:01 <joelr1> i should be more careful. sec
05:49:11 <foxy-om> new paste...
05:49:14 <foxy-om> @paste
05:49:14 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:49:42 <hpaste>  joelr1 annotated "multi-param typeclasses?" with "better NumExpr" at http://hpaste.org/1291#a10
05:49:52 <joelr1> foxy-om: what about now/
05:50:03 <joelr1> | NumOp NumOp NumExpr NumExpr
05:50:14 <joelr1> foxy-om: i sent the current paste to cafe, can we keep it?
05:50:30 <foxy-om> ok
05:50:56 <foxy-om>     Not in scope: data constructor `StrOp'
05:51:02 <joelr1> op...
05:51:16 <joelr1> that one is nullary
05:51:32 <joelr1> data StrOp = StrPlus
05:51:37 <joelr1> 100% in the paste
05:51:41 <joelr1> ah!
05:51:41 <foxy-om> instance PlusClass String String Expr where
05:51:43 <foxy-om>     a + b = StrExpr (StrOp StrPlus (Str a) (Str b))
05:51:44 <joelr1> StrOp
05:52:04 <joelr1>     | StrOp StrOp StrExpr StrExpr
05:52:21 <hpaste>  joelr1 annotated "multi-param typeclasses?" with "StrOp" at http://hpaste.org/1291#a11
05:52:57 <joelr1> all set?
05:54:20 <foxy-om> ok, now I can't get ghci to recognised my -f flags
05:55:15 <joelr1> hmm
05:55:18 <Saizan> i think (.+) :: Int -> Int -> Expr; (.+) = (+) can be a semi-accetable solution
05:55:22 <joelr1> type them into the file?
05:55:42 <joelr1> Saizan: how would it make a difference?
05:56:05 <joelr1> Saizan: i'm hiding the '+' from prelude, why define .+ ?
05:56:44 <foxy-om> joelr1: what -f flags do you have at the top of your file {-# #-} ?
05:56:52 <joelr1> sec
05:56:55 <Saizan> if you define .+ as a resctrited version of your (+) the type checker can infer that those number literals are Int because you are using .+ on them
05:57:02 <joelr1> {-# OPTIONS -fglasgow-exts -fallow-overlapping-instances #-}
05:57:50 <joelr1> Saizan: the issue is that then i'll have to remember to use .+ and not +, etc. i would like to add 1) int/int, 2) int/double, 3) double/int, 4) double/double
05:58:21 <joelr1> then permutations of int/double with NumExpr and finally permutations of strings and StrExpr-s
05:58:41 <joelr1> Saizan:  i would need lots of variations on the '+' i think
05:59:04 <Saizan> string are no problem
05:59:09 <foxy-om> joelr1: what's the problem? the code compiles
05:59:25 <Saizan> a string literal is just String
05:59:36 <fasta> Sometimes ghci doesn't show all the tracing output. When I re-evaluate the expression it does show the tracing output sometimes. When I compile the program and let ghc do it, the correct trace output is shown. Why does this happen?
05:59:36 <Saizan> not something like Stringable a => a
05:59:41 <Saizan> :t 10.5
05:59:44 <lambdabot> forall t. (Fractional t) => t
05:59:45 <joelr1> foxy-om: compiles?
05:59:52 <foxy-om> yeah, works for me
05:59:57 <joelr1> hmm
06:00:03 <joelr1> let me see something
06:03:15 <joelr1> foxy-om: it can't compile. let me paste the whole file
06:04:01 <hpaste>  joelr1 annotated "multi-param typeclasses?" with "everything needed to compile" at http://hpaste.org/1291#a12
06:04:11 <joelr1> foxy-om: try that
06:06:26 <foxy-om> what are the types of 20 and 40, you need to specify them
06:07:06 <joelr1> :t 40
06:07:09 <lambdabot> forall t. (Num t) => t
06:07:28 <joelr1> are you suggesting (Integral a, Num a, Integral b, Num b) => PlusClass a b ... ?
06:07:46 <hpaste>  foxy-om annotated "multi-param typeclasses?" with "with literal types" at http://hpaste.org/1291#a13
06:08:12 <joelr1> foxy-om: too verbose but thanks
06:08:26 <foxy-om> what do you mean too verbose?
06:08:31 <joelr1> foxy-om: pepe's version (what i had before) would be shorter
06:08:43 <joelr1> this is using wrappers and writing (i 20) + (i 40)
06:09:42 <foxy-om> can you give me an example of the implementation of "i"?
06:10:23 <joelr1> sure
06:10:30 <joelr1> i = Int
06:10:39 <joelr1> meaning the constructor for NumExpr
06:10:43 <joelr1> then you need
06:10:50 <joelr1> (+) a b = NumExpr (NumOp Plus a b)
06:10:58 <Saizan> > let i :: Int -> Int; i = id in i 4
06:10:59 <lambdabot>  4
06:11:29 <Saizan> (i'd use -fallow-incoherent
06:11:38 <joelr1> Saizan: you would?
06:11:42 <Saizan> -instances, at this point)
06:12:16 <foxy-om> :t (\x -> Int x)
06:12:16 <Saizan> yes, i'd trust ghc on this
06:12:18 <lambdabot> Not in scope: data constructor `Int'
06:12:31 <joelr1> foxy-om: Int is part of NumExpr
06:12:45 <Saizan> also from the type error it shows that it's inferring the right instance
06:13:08 <foxy-om> but you're trying to be polymorphic over different types, how do you differentiate between Int's and Double's ?
06:13:31 <Saizan> d=Double?
06:14:13 <joelr1> foxy-om: i wrap them in different constructors
06:14:20 <joelr1> d = Double, yes
06:14:28 <foxy-om> oh, then our solutions are the same
06:14:45 <Saizan> joel: do you plan on having Fractional a, Fractional b => PlusClass a b Expr?
06:15:09 <joelr1> Saizan: how did you guess?!
06:15:10 <joelr1> hehe
06:15:16 <joelr1> Saizan: by all means
06:15:23 <joelr1> why?
06:15:37 <joelr1> Saizan: well, i _think_ i should have them
06:15:47 <joelr1> :t 0.5
06:15:50 <lambdabot> forall t. (Fractional t) => t
06:16:14 <Saizan> mmh, well if you use e.g. 2.0 you should be safe anyway
06:16:31 <joelr1> right
06:16:41 <joelr1> my parsing would interpret 2 as Int anyway
06:16:48 <joelr1> box it with Int
06:17:01 <joelr1> :t fromFractional
06:17:03 <lambdabot> Not in scope: `fromFractional'
06:17:07 <joelr1> hmm
06:17:13 <joelr1> :t fromFrac
06:17:16 <lambdabot> Not in scope: `fromFrac'
06:17:33 <foxy-om> @hoogle fractional
06:17:33 <lambdabot> Prelude.Fractional :: class Num a => Fractional a
06:18:12 <Saizan> mmh but 2 for ghc qualifies both as an Integral and a Fractional, i don't know what it will choose
06:18:31 <joelr1> Saizan: i would guess Integral
06:18:37 <foxy-om> > 3 / 2
06:18:39 <lambdabot>  1.5
06:18:47 <foxy-om> :t (/)
06:18:49 <lambdabot> forall a. (Fractional a) => a -> a -> a
06:19:10 <joelr1> Saizan: it goes bonkers
06:19:27 <joelr1> Easy/Test/ParserAST.hs:12:0:
06:19:27 <joelr1>     Duplicate instance declarations:
06:19:27 <joelr1>       instance [incoherent] (Integral a, Integral b) =>
06:19:27 <joelr1> 			    PlusClass a b Expr
06:19:28 <joelr1> 	-- Defined at Easy/Test/ParserAST.hs:12:0
06:19:28 <joelr1>       instance [incoherent] (Fractional a, Fractional b) =>
06:19:30 <joelr1> 			    PlusClass a b Expr
06:19:41 <joelr1> it doesn't look like i can have integral and fractional together
06:20:30 <Saizan> heh :)
06:21:02 <joelr1> doesn't look like i can have my cake and eat it too
06:21:13 <joelr1> so i'm gonna just use wrappers
06:21:19 <joelr1> very short ones
06:21:38 <joelr1> and define .+ for strings
06:21:56 <joelr1>     [ InputDecs [ inp "foo" TyString (s "foo" `plus` (s "bar")) ] ]
06:21:58 <joelr1> this is not bad
06:25:01 <eumenides> ?src some
06:25:01 <lambdabot> some v = some_v
06:25:02 <lambdabot>   where many_v = some_v <|> pure []
06:25:02 <lambdabot>         some_v = (:) <$> v <*> many_v
06:25:04 <foxy-om> joelr, you shouldn't have to define .+ for strings, should you?
06:25:29 <DavidWHart> Cale: Hi. I was wondering if I could ask you a quick favor.
06:25:56 <joelr1> foxy-om: i should cause i need to box them
06:26:09 <eumenides> i offer an award to anyone that shows an example of some that terminates
06:26:20 <foxy-om> > \x -> 1
06:26:20 <lambdabot>  Add a type signature
06:26:28 <Saizan> joelr1: you could just typefix them, with your restricted versions of id
06:26:32 <foxy-om> > (\x -> 1) :: Int
06:26:33 <lambdabot>      The lambda expression `\ x -> ...' has one argument,
06:26:34 <lambdabot>     but its type `I...
06:26:44 <joelr1> Saizan: what do you mean?
06:26:58 <foxy-om> > (\ x :: Int -> 1 :: Double)
06:26:58 <lambdabot>  Parse error
06:27:04 <joelr1> Saizan: type-fix the strings?
06:27:17 <foxy-om> >(\(x :: Int) -> (1 :: Double))
06:27:21 <joelr1> Saizan: a `plus` b = StrExpr (StrOp StrPlus a b)
06:27:39 <joelr1> the strings need to be boxed in Str to become StrExpr
06:27:46 <foxy-om> joelr, why not use your overloaded (+)?
06:28:05 <joelr1> foxy-om: i no longer overload anything
06:29:02 <Saizan> well you could
06:29:10 <Saizan> i :: Integer -> Integer
06:29:10 <Saizan> i x = x
06:29:10 <Saizan> input2 =
06:29:10 <Saizan>     [ InputDecs [ inp "emaLength" TyNumber (i 20 + i 40) ] ]
06:29:27 <Saizan> using instance PlusClass Integer Integer Expr
06:30:01 <Saizan> for strings you don't even need the wrappers in this way
06:30:04 <joelr1> Saizan: doesn't seem to be worth my while, dunno
06:30:28 <joelr1> this works perfectly fine w/o overlapping, etc
06:30:29 <joelr1> (+) a b = NumExpr (NumOp Plus a b)
06:30:29 <joelr1> (-) a b = NumExpr (NumOp Minus a b)
06:31:02 <Saizan> uhm, true
06:31:08 <joelr1> i would wait for the higher powers to come up with something neat that doesn't require shortcuts
06:31:15 <joelr1> i'm sure it's possible
06:32:03 <Saizan> to get your initial idea work you'd only need monomorphic number literals
06:32:45 <Saizan> but you'll have a lot of instances declarations anyway
06:33:34 <joelr1> right
06:33:46 <joelr1> it's not clear that i'm saving that much by typing all that in
06:33:52 <joelr1> as opposed to using 1-letter wrappers
06:34:31 <Saizan> that probably depends on how many test cases you are going to write
06:35:09 <foxy-om> joelr, the question is how often you're going to be using literals and how often the code uses generated stuff, in which case you're not typing anything
06:35:26 <foxy-om> i.e. parsed stuff which already has a fixed type
06:36:00 <joelr1> Saizan: a whole load
06:36:28 <joelr1> i'm rewriting a fully-functioning translator from ocaml, right
06:37:07 <joelr1> so i thought of a 2-pronged approach to testing: use existing AST that matches existing code samples
06:37:34 <joelr1> and then use quickcheck to generate a random syntax tree, pretty print that, parse and compare to go originally generated
06:37:57 <joelr1> i'm typing in existing ast right now
06:38:15 <joelr1> that matches my parser input samples
06:55:40 <dhart> Cna somebody help me with a monad problem?
06:55:50 <xerox> Srue.
06:55:51 <joelr1> @pl (+.) a b = (NumOp Plus a b)
06:55:52 <lambdabot> (line 1, column 10):
06:55:52 <lambdabot> unexpected "="
06:55:52 <lambdabot> expecting variable, "(", operator or end of input
06:55:59 <joelr1> @.pl (+.) a b = (NumOp Plus a b)
06:56:00 <lambdabot> (line 1, column 10):
06:56:00 <lambdabot> unexpected "="
06:56:00 <lambdabot> expecting variable, "(", operator or end of input
06:56:17 <joelr1> xerox: how did you do it last time?
06:56:24 <mauke> @pl f a b = NumOp Plus a b
06:56:25 <lambdabot> f = NumOp Plus
06:56:35 <joelr1> aha
06:56:37 <joelr1> thanks mauke
06:56:49 <dhart> xerox: if you check this hpaste you will see the piece fo code causing problems for me. The last part, Cell Rendering is causing a compile error due to a wrong return type http://hpaste.org/1284
06:57:34 <xerox> what is rect?
06:58:49 <mauke> (Error b, MonadError b m) => StateT State (WriterT Output (ReaderT Env m)) a
06:58:51 <mauke> blargh
06:58:57 <dhart> rect is an HOpenGL function fo type rect :: Vertex2 -> Vertex2 -> IO a
06:59:13 <dhart> rect :: Vertex2 a -> Vertex2 a -> IO ()
06:59:34 <dhart> sorry, that is the correct type
06:59:38 <hpaste>  sjanssen annotated "GameMonad" with "fixed?" at http://hpaste.org/1284#a2
06:59:43 <xerox> you need to lift that action to Vertex2 a -> Vertex2 a -> GameMonad ()
07:00:16 <joelr1> @pl (+) a b = n (a +. b)
07:00:17 <lambdabot> (line 1, column 9):
07:00:17 <lambdabot> unexpected "="
07:00:17 <lambdabot> expecting variable, "(", operator or end of input
07:00:34 <joelr1> @pl f a b = n (f a b)
07:00:34 <lambdabot> f = fix ((n .) .)
07:00:36 <dhart> liftIO? I'm confused to what that is used for?
07:00:57 <xerox> lifting the action
07:01:20 <sjanssen> @hoogle liftIO
07:01:21 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
07:01:35 <dhart> "lifting the action" is still very obscure to me. I'm new to monads. Sorry for annoying you, but I like to understand how it works.
07:01:43 <sjanssen> dhart: transformers that wrap IO can be instances of liftIO
07:02:05 <sjanssen> s/liftIO/MonadIO
07:02:50 <sjanssen> liftIO transforms an IO action into any MonadIO monad (ie. any monad that is a transformer around IO, and IO itself)
07:03:41 <Saizan> ?hoogle ArrowList a => a x b -> a [x] b
07:03:42 <lambdabot> Prelude.id :: a -> a
07:03:43 <lambdabot> Prelude.asTypeOf :: a -> a -> a
07:03:43 <lambdabot> Prelude.const :: a -> b -> a
07:04:12 * joelr1 wants to dig arrows 
07:04:19 <joelr1> specially the reversible ones
07:04:31 <Saizan> i'm searching something i'd call mapA
07:04:36 <joelr1> so that when i write the parser it can automatically become a pretty-printer
07:04:57 <Saizan> as in "there and back again"?
07:10:27 <joelr1> Saizan: yes, exactly
07:10:37 <joelr1> Saizan: do you have any comments on the approach?
07:12:05 <Saizan> i've read only the abstract of that paper, yet :)
07:12:16 <joelr1> ok
07:27:32 <cm_> gah; whatever was replied to my last question isn't there anymore when i page-up
07:27:33 <cm_> "what's the haskell web server (library) du jour?"
07:27:58 <sjanssen> @where logs
07:27:58 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
07:28:19 <sjanssen> cm_: I think HAppS is the big thing lately
07:31:57 <cm_> k
07:32:29 <joelr1> sjanssen: i didn't know about logs, cool!
07:36:46 <abrim> ?seen dcoutts
07:36:46 <lambdabot> I saw dcoutts leaving #ghc, #gentoo-haskell, #haskell-overflow and #haskell 16h 40m 58s ago, and .
07:36:55 <yip__> @docs ()
07:36:56 <lambdabot> () not available
07:36:59 * SamB wants a tool to compare the code in two MZ images
07:37:07 <yip__> i can't seem to find the docs for the () type
07:37:38 <mauke> what docs?
07:37:46 <mauke> data () = ()
07:38:05 <yip__> yeah, that
07:38:07 <SamB> @google Haskell report
07:38:09 <lambdabot> http://www.haskell.org/onlinereport/
07:38:10 <lambdabot> Title: The Haskell 98 Language Report
07:38:16 <SamB> look around there?
07:38:28 <yip__> shouldn't it be in the Prelude docs though?
07:38:30 <integral> It's the unique such type, so that tells you everything about it :)
07:38:32 <SamB> see, () isn't an ordinary, module-scoped identifier
07:38:58 <SamB> which is rather unfortunate in this way
07:40:39 <yip__> does ghc have any specific optimizations related to ()?
07:41:13 <SamB> like what?
07:41:55 <joelr1> SamB: what's an MZ image?
07:41:56 <SamB> really, I hope not
07:42:03 <SamB> joelr1: a DOS exe
07:42:09 <joelr1> ah, ok
07:42:13 <SamB> they start with "MZ"
07:42:25 <joelr1> ok
07:47:10 <SamB> arg.
07:47:36 <SamB> why oh why does my code seem to find a joystick?
07:49:36 <SamB> ah.
07:49:43 <SamB> I forgot to initialize a variable.
07:50:49 <joelr1> @pl f a = f' 1 a 2
07:50:51 <lambdabot> f = flip (f' 1) 2
08:01:05 <joelr1> @pl f a b = f1 (f2 a) (f3 b)
08:01:06 <lambdabot> f = (. f3) . f1 . f2
08:07:26 <sorear> hello
08:10:12 <Saizan> hi
08:14:05 <Saizan> sorear: the names of the fields of a record constructor are discarded building a CtorDef, right?
08:18:00 <sorear> right
08:18:10 <sorear> I suspect that feature will be added
08:18:23 <sorear> ndm intends for derive to be able to replace DrIFT
08:18:37 <sorear> and it's pretty hard to derive setters without field names :)
08:19:06 <Saizan> heh :)
08:31:48 <araujo> @yarr!
08:31:49 <lambdabot> Arrr!
08:52:17 <sorear> Can I safely make a function with a (say) 2^-100 chance of returning B and a 1-2^-100 chance of returning A, pure?
08:52:50 <Heffalump> define "safely"
08:53:05 <sorear> without causing massive problems
08:53:07 <Heffalump> I doubt your program would segfault if you do it.
08:53:30 <Heffalump> but you get no guarantees of how it'll actually behave
08:53:39 <Heffalump> f x == f x might return False, for example..
08:53:50 <Heffalump> or it might get optimised to always return True
08:54:09 <sorear> I'm writing a full gmp binding; function in question is mpz_nextprime "This function uses a probabilistic algorithm to identify primes."
08:54:09 <sorear>  
08:54:33 <Heffalump> and it is occasionally wrong?
08:54:53 <sorear> yea
08:55:00 <araujo> sorear, i think you *should't*
08:55:09 <Heffalump> <aol>
08:55:22 <sorear> ok then.
08:55:23 <Heffalump> but I doubt the sky will fall in if you do
08:56:26 <monochrom> Declare it pure.
08:56:28 <yip__> why not bind it as IO function, and let the user decide if he wants to run it as unsafePerformIO?
08:56:40 <sorear> Well, if Heffalump thinks I shouldn't, I'll come up with some annotation to make it monomorphic to RealWorld.
08:57:18 <Heffalump> I don't understand what you mean by monomorphic to RealWorld
08:57:34 <araujo> yes, the monomorphism restriction is healthy
08:58:04 <sorear> mpz_add :: Readable s sa => STMpz s -> STMpz sa -> STMpz sa -> ST s ()
08:58:26 <araujo> monomorphic* (why isn't this word included in my spell-check dictionary?
08:58:42 <sorear> mpz_nextprime :: Readable RealWorld sa => STMpz RealWorld -> STMpz sa -> ST RealWorld ()
08:58:52 <monochrom> Because the dictionary is of "plain English".
08:59:19 <sorear> hm, maybe an IO return is better (how to arrange?)
08:59:25 <araujo> Boring.
09:00:05 <Heffalump> just declare an IO type, surely?
09:00:15 <araujo> IO () ?
09:03:31 <beelsebob> > show 3.984759038475394857329487562398756E94857
09:03:37 <lambdabot>  ghc: failed with error code 9
09:03:40 <beelsebob> o.O
09:03:50 <beelsebob> > show (3E9)
09:03:53 <lambdabot>  "3.0e9"
09:03:56 <beelsebob> hmm
09:03:57 <beelsebob> arse
09:04:32 <beelsebob> is there a function that will "show" a float/double guarenteeing not to use exponential form
09:05:19 <monochrom> showFFloat
09:05:39 <beelsebob> > showFFloat (3E9)
09:05:40 <yip__> > showFFloat (3E9)
09:05:40 <lambdabot>        add an instance declaration for (Fractional (Maybe Int))
09:05:41 <lambdabot>        add an instance declaration for (Fractional (Maybe Int))
09:05:47 <beelsebob> o.O
09:05:59 <kpreid> @type 3E9
09:06:01 <sorear> > show 3.984759038475394857329487562398756E94857
09:06:02 <lambdabot> forall t. (Fractional t) => t
09:06:05 <lambdabot>  ghc: failed with error code 9
09:06:13 <beelsebob> > showFFloat 3000000000
09:06:13 <yip__> > showFFloat Nothing (3E9) ""
09:06:14 <sorear> Oh!
09:06:14 <lambdabot>   add an instance declaration for (Num (Maybe Int))
09:06:15 <lambdabot>  "3000000000.0"
09:06:29 <beelsebob> @type showFFloat
09:06:32 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
09:06:39 <beelsebob> what's the Maybe Int for?
09:06:46 <beelsebob> the exponant required?
09:06:52 <sorear> @tell dons > show 3.984759038475394857329487562398756E94857
09:06:53 <lambdabot> Consider it noted.
09:07:00 <beelsebob> > showFFloat (Just 2) 3000000000 ""
09:07:01 <monochrom> @doc showFFloat
09:07:01 <lambdabot>  "3000000000.00"
09:07:02 <lambdabot> showFFloat not available
09:07:06 <beelsebob> ah, decimal places
09:07:14 <monochrom> RTFD
09:07:18 <beelsebob> > showFFloat Nothing 3000000000 "jam'
09:07:19 <lambdabot>  Improperly terminated string
09:07:21 <beelsebob> > showFFloat Nothing 3000000000 "jam'
09:07:21 <lambdabot>  Improperly terminated string
09:07:24 <beelsebob> > showFFloat Nothing 3000000000 "jam"
09:07:25 <beelsebob> damn it
09:07:26 <lambdabot>  "3000000000.0jam"
09:07:28 <beelsebob> type fail
09:07:29 <beelsebob> okay
09:07:32 <beelsebob> cool, that's good :)
09:07:41 <yip__> if i have an optional string value, should i use Maybe String, or just String, and have the empty string represent Nothing?
09:08:09 <monochrom> With >99% likelihood, better with Maybe String.
09:08:51 <yip__> hm..... why?
09:09:04 <desp> @quote oleg
09:09:05 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
09:09:05 <yip__> makes things more complicated, slower, uses more memory
09:09:17 <dmhouse> Because the empty string might mean a positive result but with an empty string.
09:09:46 <dmhouse> Suppose you're doing some kind of dictionary-like lookup. If you get a result of "" back, how do you know whether the value was indeed the empty string, or whether the key wasn't present?
09:09:47 <monochrom> The same reason why showFFloat wants a Maybe Int rather than an Int.
09:10:14 <desp> @quote oleg
09:10:15 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
09:10:18 <desp> @quote oleg
09:10:19 <lambdabot> edwinb says: where does 'Oleg cornered me in a pub and explained delimited continuations to me' fit in?
09:10:19 <yip__> dmhouse: in my case the empty string is not a valid result
09:10:46 <sorear> then you've already got a problem with your types ;)
09:10:55 <dmhouse> yip__: even still, using Maybe is clearer, makes things more readable, and opens up goodies like the Maybe monad, which could allow for easier refactoring and so on in the future.
09:11:18 <dylan> where's the gentoo haskell overlay?
09:11:22 <dmhouse> You should always rank things like that over "uses less memory". Premature optimisation is the root of all evil, and all that jazz.
09:12:11 <monochrom> Many unix system calls return -1 for "error".  I think we all deplore that, even though in all those cases -1 is not a valid return value anyway.  (E.g., read from a handle, return number of bytes read, or -1 for error.)
09:12:59 <sorear> Now imagine your OS has been shoddily upgraded for large file support.
09:13:00 <yip__> monochrom: yeah, but an empty string in my case conveys the meaning "no value"
09:13:21 <sorear> Now imaging reading 4294967295 bytes from a file.
09:13:24 <dmhouse> Moreover, it makes things more consistent. In most languages, failure could be indicated by many different things, like 0, false, null and so on. There isn't a standardised way of indicating failure. This is precisely what Maybe is designed for.
09:13:57 <monochrom> I have left a <1% likelihood for a justified case.  But I'm skeptic.
09:15:27 <dmhouse> If your function should hardly ever fail, or only fail if a documentation precondition fails, then I'd say it's appropriate to use error, rather than Maybe, but returning an empty string is distinctly against the Haskell style.
09:15:27 <monochrom> Since I am not in your project, I can only speak of probabilities and usual considerations.  You can always judge yourself to be an exception.
09:15:47 <yip__> this isn't for a failure situation
09:15:55 <yip__> and it's for a function argument, not a return value
09:16:28 <dmhouse> Oh, in which case, Maybe is definitely the established convention.
09:16:51 <dmhouse> Unless you have a large number of optional parameters, where you can employ extra tricks like using records.
09:17:06 <yip__> using a straight String has the advantage that i can save/read the value directly inside some xml file, without having to do Maybe conversion
09:17:09 <Heffalump> you still need to use Maybe within those records, surely
09:17:12 <dmhouse> What do the function, and the argument, do?
09:17:25 <dmhouse> Heffalump: yeah, true, I guess I was unclear.
09:18:23 <monochrom> Why are we arguing?  An advice is asked for, and an advice is given.  Now a decision can be made.  There is no need to get someone to say "yes".
09:19:19 <Igloo> sorear: The TH ppr patches were from you, right?
09:19:31 <yip__> monochrom: ok thanks!
09:19:43 <sorear> Igloo: no, they were "Ian Lynagh"
09:19:55 <Igloo> sorear: That's me, I meant the earlier ones
09:20:00 <sorear> the less-recent ones were me, yes
09:20:27 <Igloo> sorear: OK, so I guess you've already seen this then, but we still sometimes generate invalid names like +_0
09:20:44 <Igloo> I don't know if that will cause you problems for what you were doing or not
09:20:45 <sorear> Actually I hadn't
09:21:00 <sorear> No, we don't use Q and don't get unique names
09:33:07 <haskellboy> getWindowSize :: Window -> IO Size
09:33:15 <haskellboy> If I try   s <- getWindowSize w    how do I get the Size coordinate out of the IO Size returned ??
09:33:29 <haskellboy> basic q i know
09:33:44 <araujo> haskellboy, the IO monad is a one-way monad
09:33:58 <sorear> generally, you don't actually want to get a out of IO a
09:34:03 <sorear> but you can pretent
09:34:07 <sorear> @ty getLine
09:34:10 <lambdabot> IO String
09:34:15 <sorear> getLine is an IO String
09:34:19 <sorear> @ty putStrLn
09:34:21 <lambdabot> String -> IO ()
09:34:26 <sorear> putStrLn needs a String
09:34:33 <sorear> @ty getLine >>= putStrLn
09:34:37 <lambdabot> IO ()
09:34:42 <sorear> but >>= can put them together
09:35:03 <sorear> in this context it has type  IO a -> (a -> IO b) -> IO b
09:35:19 <sorear> (it actually has a somewhat more confusing and general type)
09:35:32 <sorear> do-notation is just sugar for >>=
09:35:50 <sorear> do var <- action ; statements   === action >>= \var -> statements
09:35:57 <sorear> do action ; statements   === action >>= \ _ -> statements
09:36:08 <sorear> do statement   === statement
09:36:42 <xerox> and do let { bindings }; ...  ==>  let {bindings} in do ...
09:36:57 <sorear> forgot about that one :)
09:42:09 <hpaste>  vincenz pasted "miniml parser" at http://hpaste.org/1293
09:43:13 <vincenz> is it normall that hpaste limits codel ength?
09:43:59 <ddarius> It says as much on the page you enter the code into.
09:44:05 <vincenz> damn :/
09:55:56 <TomMD> > [1,3..2]
09:55:58 <lambdabot>  [1]
09:56:36 <TomMD> [ [1..],[3..]..[10..]]
09:57:06 <ddarius> Lists are not instances of enum.
09:57:07 <TomMD> It would be funny to have an infinite list an enum type.
09:57:28 <xerox> > enumFromThenTo 1 3 2
09:57:29 <lambdabot>  [1]
09:58:14 <ddarius> TomMD: Everything in programming is enumerable.
10:04:28 <jcreigh> hmm...is it possible that chess is a win for black?
10:07:47 <astrolabe> I can't see how to disprove it, but it seems very unlikely.
10:08:21 <bluestorm_> do someone know a library in london that might sell computer science books ?
10:08:39 <bluestorm_> (actually i'm looking for the Okasaki book about data structures)
10:08:57 <astrolabe> Do you mean a bookshop rather than a library?
10:09:06 <bluestorm_> hmm :p
10:09:12 <bluestorm_> i mean a bookshop, sorry
10:09:28 <astrolabe> I think Foyle's is big enough to have most things.
10:09:49 <astrolabe> But they don't specialise in computers.
10:10:07 <bluestorm_> hey, you're right !
10:10:11 <bluestorm_> http://www.foyles.co.uk/foyles/display.asp?K=9780521663502&sf_01=KEYWORD&st_01=okasaki&x=0&y=0&m=1&dc=4
10:10:14 <bluestorm_> thanks a lot
10:10:14 <lambdabot> Title: Purely Functional Data Structures by Chris Okasaki from Foyles Bookshop, London., http://tinyurl.com/2hvwgz
10:17:01 <ndm> dons: 2 papers in time?
10:17:19 <ndm> (or is dons sleeping today :) )
10:17:22 <ndm> @seen sorear
10:17:23 <lambdabot> sorear is in #darcs, #haskell-overflow, #ghc, #haskell and #happs. I last heard sorear speak 40m 26s ago.
10:18:29 <Gwern> how does one remedy a cabal problem giving an error "unknown field 'install-includes'"?
10:18:55 <ndm> Gwern: error or warning? you delete the field in the .cabal file if its a warning
10:19:10 <Gwern> ndm: error, I guess, since configuration stops there
10:19:30 <ndm> Gwern: open the .cabal file, delete the appropriate line, complain to the author
10:19:37 <Gwern> ok
10:19:39 <ndm> Gwern: or upgrade to the latest cabal release
10:19:47 <ndm> (since i guess it works somewhere at least)
10:20:27 <Gwern> whats' the latest? I've got 1.1.4 installed
10:20:43 <ndm> i think i'm on 1.1.6
10:20:58 <ndm> yeah, GHC confirms it
10:22:53 <Saizan> latest is 1.1.7
10:23:46 <Gwern> hmm. portage doesn't seem to be too good for haskell packages
10:23:59 <Gwern> missing libs, old cabal, a masked darcs...
10:26:03 <bos> 1.1.7 isn't released. it's a development version.
10:26:46 <Saizan> ndm: do you plan on extending CtorDef to contain the names of the fields for a record contructor?
10:27:10 <ndm> Saizan: yes, its something we want to do - do you want to submit a patch?
10:29:02 <Gwern> man, something's messed up here. the X11 and X11-extras dependencies for xmonad both have the install-includes field which errors out on me, and X11-extras fails to compile when the fields are commented out. this sucks
10:29:51 <dmwit> Gwern: Which version of cabal are you using?
10:30:07 <sjanssen> Gwern: upgrade cabal
10:30:09 <Gwern> dmwit: 1.1.4, which is what portage provides right now
10:30:16 <Saizan> uhm, how would CtorDef change? another field or another contructor altogether?
10:30:26 <Gwern> sjanssen: ok
10:30:27 <sjanssen> Gwern: it is hard masked in portage, but it works fine
10:30:35 <ndm> Saizan: what are you wanting it for?
10:30:50 <Gwern> ah. Its been a long time since I seriously used gentoo. how does one avoid hardmasking again?
10:30:58 <ndm> Saizan: whatever you think is most appropraite - i don't actually no what the CtorDef type is...
10:31:39 <sjanssen> Gwern: add "=dev-haskell/cabal-1.1.6.1" to /etc/portage/package.unmask
10:31:53 <Saizan> ndm: i was going to derive an xml representation for some simple records
10:31:54 <sjanssen> Gwern: by the way, #gentoo-haskell is a channel for these sorts of questions
10:32:28 <Gwern> sjanssen: that's a gentoo haskell channel? that's useful to know
10:32:37 <ndm> Saizan: honestly i can't see why we need ctorArity and ctorTypes, assuming length ctorTypes == ctorArity
10:33:05 <ndm> Saizan: i would have CtorDef {ctorName :: String, ctorFields :: [(Maybe FieldName, RType)]}
10:33:20 <ndm> Saizan: thats what i picked for Yhc, as it happens, which has a very similar type structure
10:33:20 <sjanssen> s/is a channel/is a good channel
10:34:39 <LoganCapaldo> I hate the abbreviate ctor. It always takes me forever to re-figure out/ remember what it stands for. Just thought I'd share that with the class
10:34:56 <jcreigh> what does ctor stand for?
10:35:06 <mauke> constructor
10:40:19 <ndm> Saizan: we can actually make ctorArity into a function without even breaking the API (Since i doubt anyone sets it directly)
10:41:25 <Saizan> goof
10:41:28 <Saizan> *good
10:42:43 * ndm looks forward to Data.Derive.XML
10:42:45 <Saizan> i'm trying to make sense of the TH driver, of the TH types, mostly
10:43:09 <monochrom> I like ctor. It doesn't confuse with cons.
10:43:13 <ndm> Saizan: alas, there is not much about that to help you with - they are complex - sorear has an abstraction layer
10:43:57 <ndm> Saizan: take a look at some of the other derives, and that will give you some insight, or if you want a specific instance, just ask me
10:44:33 <Saizan> ok
10:54:57 <sorear> back
10:55:43 <ndm> off home, but online in 15 mins or so :)
10:56:02 <hpaste>  phoniq pasted "    Occurs check: cannot construct the infinite type: t = Either t t" at http://hpaste.org/1294
10:57:15 <phoniq> trying to mod a parsec example to work with floats
10:58:34 <sorear> unwrap === either id id
10:59:16 <sorear> you don't have to indent the whole module
10:59:47 <phoniq> ok
11:00:09 <sorear> there's parseTest function you might be able to use instead of run
11:00:15 <phoniq> yah
11:00:37 <ddarius> Do you want to rewrap the results of addem?
11:00:51 <sorear>      addem x y = (unwrap x) + (unwrap y)  -- your problem
11:01:06 <sorear> @ty  let addem x y = (unwrap x) + (unwrap y) in addem
11:01:09 <lambdabot> Not in scope: `unwrap'
11:01:09 <lambdabot>  
11:01:09 <lambdabot> <interactive>:1:30: Not in scope: `unwrap'
11:01:19 <sorear> @ty  let unwrap = either id id ; addem x y = (unwrap x) + (unwrap y) in addem
11:01:21 <lambdabot> forall b. (Num b) => Either b b -> Either b b -> b
11:01:24 <ddarius> phoniq: And in general, top-level type declarations can significantly clarify and localize type errors.
11:01:39 <sorear> as you can see, addem doesn't return the same type it takes.
11:01:59 <sorear> so when you use it in the recursive exp parser, you get an error
11:02:08 <phoniq> ah!
11:05:49 <ddarius> Incidentally, addem x y = unwrap x + unwrap y
11:07:44 <phoniq> right
11:21:19 <desp> how would you write a map using CPS?
11:21:26 <desp> a friend is asking me
11:22:16 <desp> I am only superficially familiar with CPS
11:23:03 <sorear> mapM!
11:23:17 <sorear> using Control.Monad.Cont
11:23:24 <desp> er.
11:23:28 <ddarius> desp: As sorear suggests, just write it monadically, mapM in this case, and inline the Cont monad operations.
11:23:46 <sorear> @src Cont (>>=)
11:23:47 <desp> I was hoping not to overcomplicate the already complicated idea
11:23:47 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
11:23:53 <sorear> @src Cont return
11:23:54 <lambdabot> return a = Cont ($ a)
11:24:06 <sorear> just apply simple rewrites
11:24:42 <sorear> let return x y = y x ;;
11:24:42 <sorear> let (>>=) a f c = a (fun v -> f v c)
11:24:44 <jcreigh> hmm.. (a -> b) -> [a] -> ([b] -> c) -> c?
11:24:52 <sorear> ;;
11:25:04 <ddarius> mapK f [] k = k []; mapK f (x:xs) k = mapK f xs (\xs' -> k (f x:xs'))
11:25:27 <desp> ddarius: aha!
11:25:30 <ddarius> > let mapK f [] k = k []; mapK f (x:xs) k = mapK f xs (\xs' -> k (f x:xs')) in mapK (+1) [1..5] show
11:25:31 <lambdabot>  "[2,3,4,5,6]"
11:25:37 <ndm> @seen sorear
11:25:38 <lambdabot> sorear is in #darcs, #haskell-overflow, #ghc, #haskell and #happs. I last heard sorear speak 45s ago.
11:25:43 <desp> ddarius: thank you, I was almost there
11:25:44 <Saizan> ndm: do you think i should mantain ctorTypes as map snd . ctorFields?
11:26:05 <ndm> Saizan: i would do it for the moment as a compatability wrapper, if it wants deleting we can do so later
11:26:26 <ndm> Saizan: just gives you less chance of accidentally breaking other code, and having the work of fixing it up
11:26:29 <sorear> how about ctorArity === length . ctorFields ?
11:26:58 <ndm> sorear: that was the plan
11:27:00 <Saizan> sorear: that was so from the start :)
11:27:05 <ndm> sorear: on general planning issues:
11:27:33 <ndm> I was thinking that we probably want a directory which is only populated by deriving instances, since at the moment its hard to figure out what are the drives, what are the instances etc
11:27:52 <ndm> would also be handy to have a single module that imports all the deriving instances, so its easy to check that you haven't broken type checking
11:28:23 <ndm> moving the template haskell pretty printer and abstraction to an heirarchy place would be nice, ideally in teh TH namespace somewhere
11:28:25 <sorear> both good ideas imo too
11:28:49 <ndm> cool, will probably hack them up at some point
11:29:24 <ndm> i also started on Data.Derive.Example, the idea is that by giving an example instance (see Eq or Data), in some cases the program can infer the derivation, with all the complex template haskell syntax, and we can get these easily
11:29:25 <sorear> the th ppr is fixed in head - not sure if it is going into the 6.6 branch though (Igloo?)
11:30:00 <ndm> sorear: i would suspect we'll find other bugs in the near future, so we should probably keep a fork - although if it does seem we've got them all then we can flip back to the native one
11:30:10 <ndm> we still want your nice abstraction functions in one place though
11:30:59 <ndm> of course, derivation by example will not work for type directed derivations, such as Play or Functor, but I hope to figure out Eq, Data, Ord, Arbitrary, SmallCheck etc
11:31:43 <sorear> I wonder if it would be possible to express the same pattern as some sort of combinator.
11:31:49 <sorear> oh, that reminds me
11:32:04 <ndm> sorear: i suspect it would be, and probably easier to figure out for the code, but harder for the human
11:32:25 <sorear> ndm: one problem is that sometimes helper functions are very very useful, like Data.Monoid.mappend in Ord derivation
11:32:28 <ndm> essentially this will enumerate some small set of combinators, trying to find the right set and order
11:32:47 <sorear> unfortunately we can't generate 'import qualified Data.Monoid' using TH :(
11:33:12 <ndm> sorear: then i guess we can't rely on that, sadly
11:33:26 <sorear> we could re-export it from Data.Derive.Ord I suppose
11:33:27 <ndm> sorear: we can always make local instances of useful combinators in some cases...
11:33:38 <ndm> no good, since the user code won't have it in
11:33:38 <Saizan> ?docs Data.Generics
11:33:39 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Generics.html
11:33:48 <ndm> which is an issue for the non-TH deriving
11:34:36 <sorear> grr.  we may need to use a monadic-thing after all
11:34:53 <ndm> how come?
11:34:59 <ndm> or you mean for the Ord?
11:35:11 <ndm> what does the Haskell report specify for Ord, i would have thought they don't require mappend
11:35:13 <sorear> imagine if the th-helpers used not asts, but WriterT [Import] Q ast's
11:35:27 <sorear> it specifies 'left to right comparison'
11:35:45 <sorear> afair it only gives actual code for Show and Read
11:36:11 <sorear> GHC guts use an undocumented interal `thenCmp` function which is even worse ;)
11:36:16 <ndm> hmm, thats weird
11:36:33 <ndm> Play clones some useful combiantors and puts them in a where clause, one copy for every instance
11:36:52 <ndm> i would have thought ([String], Ast) would be neater, no need to go monadic to return imports
11:37:03 <ndm> but i still think avoiding imports unless its unavoidable is best
11:37:18 <ndm> can we not clone thenCmp, in a where?
11:37:30 <sorear> yes
11:38:10 <sorear> but that way lies nested cases, because where doesn't do multiple equations :(
11:38:31 <ndm> i guess thats a sad but inevitable restriction
11:38:44 <ndm> Play uses cases, not clauses for that reason
11:42:18 <monochrom> where doesn't do multiple equations?
11:43:01 <sorear> correct, though perhaps not in the way you understood
11:43:25 <sorear> > let { fun 0 = if0 ; fun 1 = 0 where { if0 = 1 } } in fun 0
11:43:26 <lambdabot>   Not in scope: `if0'
11:44:31 <yip__> does haskell have gnu gettext support or an alternative?
11:44:50 <ndm> sorear: Language.Haskell.TH.FixedPpr, Language.Haskell.TH.Helpers - do those module names suit you for the new locations for the TH modules?
11:45:21 <sorear> yes
11:45:22 <ndm> (i don't like Helpers too much, so if you have an alternative, please say)
11:45:52 <monochrom> Oh, now I see.
11:48:45 <sorear> ndm: now in Ord I use the slightly ugly fact that a `compare` b `thenCmp` c `compare` d  ==  (a,c) `compare` (b,d)
11:49:15 <ndm> sorear: i suspected that would be the way you did it - its how i always do it when writing my own derivations
11:49:24 <monochrom> I have a ghost story to tell.  I use eclipse to write prose - not even api doc, just some comments on some music.  I do this because of the cvs support.  I want cvs support because I write it over multiple computers, so I want a sync server.
11:50:00 <Igloo> sorear: It should be there already
11:55:12 * ddarius would use vim and darcs.
11:59:37 <Saizan> ?docs Data.Typeable
11:59:37 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html
12:02:25 <ndm> sorear: i'm also wondering if we should be moving from our constructor/data type to the template haskell one? possibly giving ctorArity in terms of that one etc - as it seems we are progressively adding more features to our data type
12:02:28 <Saizan> can i assume that gmapQ and constrFields will use the same order when traversing the fields of the constructor?
12:02:34 <ndm> Saizan: ^^^ (you may have an opinion on that too)
12:02:51 <ndm> Saizan: Data and Typeable are not available on TH syntax items
12:02:57 <ndm> Saizan: i.e. no SYB
12:03:21 <Saizan> i was updating the SYB module to return the new CtorDef
12:03:26 <ndm> Saizan: (although we may add Play shortly, once we can derive it for ourselves)
12:03:47 <ndm> Saizan: should it need any updating? won't just using the new ctorTypes thing work?
12:04:19 <sorear> ndm: seems quite reasonable (using TH's type for datas) - I initially worried about the complexity of the types, but now that I'm over the selector /= accessor mental block ...
12:04:20 <Saizan> well,  ctr :: Constr -> (CtorDef, [DataBox]) <-- needs some updating
12:04:21 <ndm> Saizan: ps, pull now, i've made some changes to move bits around
12:04:49 <ndm> Saizan: oh, that bit - hmm, no idea - just fill it with Nothing's for all the fields - we can fix it up later
12:05:04 <ndm> Saizan: we are thinking of moving to the full template haskell data types, would that make it easier for you?
12:05:38 <TomMD> If I've overloaded an inline op, how do I refer to the original? Ex: I can't call (+) with GHC.Num.(+), so how can I?
12:05:41 <ndm> since otherwise the next person will add infix types etc, and then strictness will be added, until we clone template haskell
12:06:02 <Saizan> uhm that's true
12:06:18 <Saizan> but TH types are so big..
12:06:59 <ndm> yeah, but if we provide ctorArity, ctorName, ctorFields and ctorTypes we get most of the functionality
12:07:02 <Saizan> well maybe we just need equivalent helper functions
12:07:11 <ndm> those who think TH is too big (everyone!) can just treat them abstract
12:07:12 <Saizan> yeah
12:07:12 <yip__> how do i convert a String to a ByteString?
12:07:14 <ndm> that was my though
12:07:14 <dmhouse> TomMD: I think the syntax is (GHC.Num.+)
12:07:16 <dmhouse> yip__: pack
12:07:58 <TomMD> dmhouse: ghci 6.7 doesn't like it - did it work before, or is that a guess?
12:07:59 <yip__> dmead_: Couldn't match expected type `Word8' against inferred type `Char'
12:08:25 <TomMD> dmhouse: scratch that - it works, my bad.
12:08:40 <dmhouse> TomMD: well, if you're using a qualified infix function prefix, then surrounding the entire qualified name with brackets is the correct syntax. What specific error are you getting?
12:08:46 <dmhouse> > (Prelude.+) 2 3
12:08:47 <lambdabot>  5
12:08:53 <Saizan> ndm: well i had the patch ready aside from that SYB thing, but now?
12:09:07 <dmhouse> TomMD: hehe, no problem. That rule is really counter-intuitive, everyone gets it wrong.
12:09:54 <ndm> Saizan: submit, and we can build off that
12:10:14 <ndm> Saizan: in particular, have you added XML deriving?
12:10:32 <Saizan> ah, not yet
12:10:48 <Saizan> just modified CtorDef
12:12:20 * dmhouse implements bubble sort in Haskell
12:13:00 <dmhouse> Wow, I've been programming Haskell for over a year, and only now do I actually write the Hello World of algorithms! :)
12:13:18 <norpan> more like goodbye world
12:13:43 <TomMD> I thought goodbye world was f = forkIO f >> f
12:13:48 <ndm> dmhouse: i don't know bubble sort, i just know its O(crap), thats all you need to know
12:13:57 <ndm> unsafePerformIO is goodbye world
12:13:59 <dmhouse> ndm: hehe, pretty much.
12:14:06 <ndm> or goodbye referntial transparency
12:14:08 <Heffalump> doesn't it have good locality properties?
12:14:08 <dmhouse> -- Nice and inefficient, just the way we like our bubble sorts.
12:14:08 <dmhouse> bubSort :: Ord a => [a] -> [a]
12:14:08 <dmhouse>  
12:14:13 <dmhouse> ndm: those are the first two lines :)
12:14:53 <jcreigh> @remember ndm i don't know bubble sort, i just know its O(crap), thats all you need to know
12:14:53 <lambdabot> Done.
12:15:27 <dmhouse> The running time of bubble sort is bound above by a constant multiple of crap.
12:15:31 <Saizan> ndm: where should i darcs send?
12:15:53 <ndm> Saizan: first explain how i add my name to the darcs repo so darcs send just works, then do a darc send :)
12:15:59 <sorear> ndm: would you mind if someone made the repo darcs sendable?
12:16:22 <Igloo> ndm: echo youremailaddress > _darcs/prefs/email
12:16:29 <dmhouse> Ooh, darcs send. Never used that. I heard it has something to do with sendmail, which scared me off.
12:16:53 <Igloo> dmhouse: /usr/sbin/sendmail, not sendmail
12:17:00 <sorear> dmhouse: if your *nix system doesn't have a program called sendmail, it's not worthy of the name *nix
12:17:09 <ddarius> > let insertSort = foldr insert [] in insertSort [10,9..1]
12:17:10 <dmhouse> sorear: it does, but I don't think I've configured it ;)
12:17:10 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
12:17:18 <ndm> dmhouse: it works less well on windows, where it just fails
12:17:19 <Saizan> does it need configuration?
12:17:29 <Igloo> ndm: It uses MAPI on Windows
12:17:35 <ndm> Saizan: try a darcs send
12:17:47 <Saizan> on windows it used thunderbird (the default email program) on my machine
12:17:52 <sorear> dmhouse: note that the executable program called 'sendmail' in general has absolutely nothing to do with the OSS project called 'sendmail'
12:18:02 <ndm> it always dies for me with Thunderbird
12:18:15 <dmhouse> sorear: right. What's "the executable program called 'sendmail'", then?
12:18:17 <ndm> I know Esa had a patch, but apparently the darcs developers rejected it (he told me)
12:18:24 <Saizan> sent
12:18:28 <dmhouse> sorear: `which sendmail` tells me /usr/sbin/sendmail, which one is that?
12:18:29 <ndm> dmhouse: an alias to gmail
12:18:37 <sorear> for instance, on my system the executable 'sendmail' has everything to do with the OSS project 'exim'
12:18:42 <jcreigh> dmhouse: basically, you have to have an MTA setup on your local machine.
12:18:48 <Igloo> ndm: Fair enough; I don't know anything about it
12:19:01 <jcreigh> dmhouse: such as exim, postfix, qmail, sendmail, etc.
12:19:02 <hoelzro> does anyone know what's wrong with Network.Socket?
12:19:02 <sorear> dmhouse: sendmail --help ; sendmail --version
12:19:19 <sorear> dmhouse: one of the two should tell you your sendmail's project affiliation
12:19:24 <Saizan> btw, no one uses the cabal of derive i presume?
12:19:43 <dmhouse> sorear: neither of those work, both give me an 'Invalid option' error.
12:19:46 <ndm> Saizan: its still heavily under development - entirely unreleased
12:19:47 <sorear> stefan@stefans:/usr/src/gmp-4.2.1+dfsg/mpz$ /usr/sbin/sendmail --version
12:19:47 <sorear> exim abandoned: unknown, malformed, or incomplete option --version
12:19:57 <ndm> Saizan: if it doesn't work and you would like it to, patch as you feel like it :)
12:20:04 <sorear> died for me too, but at least it said its name :)
12:20:04 <dmhouse> ~ $ sendmail --version
12:20:04 <dmhouse> sendmail: invalid option -- -
12:20:04 <dmhouse> sendmail: fatal: usage: sendmail [options]
12:20:28 <Saizan> k :)
12:20:54 <sorear> okay, maybe typing 'man /usr/sbin/sendmail' wasn't such a good idea
12:20:55 <therp> hm good question what sendmail variant is on my box..
12:21:10 <sorear> /usr/sbin/sendmail:71: warning: can't find numbered character 223
12:21:15 <sorear> and a gazillion others
12:21:19 <therp> I seem to use ssmtp. Extremely simple MTA to get mail off the system to a Mailhub
12:21:54 <sorear> methinks groff should be set up to abort if the first four characters of its input are DEL E L F
12:22:42 <dmhouse> "sendmail - Postfix to Sendmail compatibility interface" - from the manpage.
12:23:06 <sorear> sounds like your sendmail is postfix then
12:23:13 <dmhouse> Which is good or bad?
12:23:14 <hoelzro> no one knows what's wrong with Network.Socket?  I've been trying to write an NNTP module using it but it's got some serious issues
12:23:33 <sorear> but it doesn't really matter, afair the only difference between the free mta's is configuration syntax
12:23:42 <therp> dmhouse: on a workstation? maybe bad, as postfix is too powerful (that's too big to be configurable easily)
12:24:08 <dmhouse> I'm on my Ubuntu laptop. I use it for mucking around and coding.
12:24:23 <therp> I'd use esmtp or ssmtp
12:24:31 <dmhouse> Why?
12:24:39 <therp> both are relay-to-mailhub-only MTAs. very simple
12:25:18 <dmhouse> Will my current one do the job?
12:25:43 <therp> sure, when you found out how to configure it :)
12:25:52 <sorear> therp: then how are you supposed to read your mail, if your MTA throws everything from fetchmail right back at the smarthost?
12:26:13 <therp> dmhouse: ssmtp configuration for me is one line: mailhub=mx.endorphin.org:25; that's it
12:26:39 <therp> sorear: fetchmail can do local delivery via procmail. and I don't use fetchmail. wanderlust imap to server directly with local message cache
12:26:52 <sorear> ?web1913 wanderlust
12:26:55 <therp> wanderlust is emacs software btw
12:26:57 <lambdabot> No match for "wanderlust".
12:27:38 <sorear> oh, it sounded like an archaic english adjective ;)
12:27:51 <ddarius> Bah, just use telnet.
12:27:59 <ndm> Saizan: just got the patch, it got spam marked by gmail (bad gmail)
12:28:02 <ndm> @karma- gmail
12:28:03 <sorear> telnet is for wimps!
12:28:03 <lambdabot> gmail's karma lowered to 0.
12:28:14 * sorear is a proud user of netcat
12:28:28 <sorear> escape sequences?  who needs em!
12:28:38 <ddarius> sorear: Well... English is Germanic...
12:29:19 <therp> wanderlust is written by a Japanese. I wonder why he chose an german word :)
12:29:20 <sorear> ndm: what, gmail doesn't know spammers are too uncool to use darcs?
12:29:29 <ndm> sorear: apparently not...
12:30:03 <fean> "English is what you get from Normans trying to pick up Saxon girls."
12:30:27 <ddarius> therp: Wanderlust was picked up by English a while back.
12:30:41 * dmhouse wonders what a mail hub is
12:30:52 * dmhouse notices he knows very little about the email side of networking.
12:33:14 <stepcut> therp: I use wanderlust as well -- it's pretty spiffy
12:33:30 <therp> stepcut: you don't use it with emacs 23 right?
12:33:45 <therp> it seems to break for some reason with updating message stati.
12:34:25 <sorear> it really is a lot like a physical postal service.  to send mail you give it to someone who specializes in sending mail.  to recieve it you pick it up from a place that recieves it for you (POP3/IMAP).
12:35:04 <sorear> big sites connect directly to remote mailservers, and recieve mail by being connected directly too, but these are increasingly rare.
12:35:06 <stepcut> therp: no, emacs 21.3+1-8 from Debian
12:35:14 <sorear> s/too/to
12:35:34 <therp> stepcut: I'm just a fan of xft fonts.
12:36:18 <stepcut> therp: what version of wanderlust? I recently updated to the beta in Debian, and when a hit 'x' to delete all the marked mail, it sometimes deletes the mail on the server properly, but does not remove them from the Summary
12:36:26 <stepcut> therp: is that similar to what you are seeing ?
12:36:40 <sorear> SMTP is when the mail sender takes the initiative (going to the dropoff box).  POP3/IMAP is when the reciever takes the iniative (going to the place they hold your mail, I forget what it is called)
12:37:31 <ddarius> Icon has first class procedures and closures but does not have block structure so you seem unable to return local procedures...
12:37:33 <therp> stepcut: hm similarly, but delete works properly. when I flag a mail as read, it sends of the proper flagging command via imap, but summary isn't updated at all
12:37:38 <therp> stepcut: wanderlust-cvs
12:39:10 <stepcut> therp: sounds like it could be related. I gotta run, bbl.
12:39:22 <LoganCapaldo> That reminds me, is there a way to make a goal directed monad? (or maybe a goal directed arrow)?
12:39:45 <LoganCapaldo> I was thinking some variation of how ReadP works
12:39:57 <stepcut> LoganCapaldo: LogicT ?
12:40:20 <ddarius> Yeah, monads and continuations ruin most new languages for you...
12:40:34 <LoganCapaldo> @where LogicT
12:40:34 <lambdabot> I know nothing about logict.
12:41:13 <LoganCapaldo> well there we go
12:41:19 <LoganCapaldo> answers that question I guess :)
12:41:29 <stepcut> http://www.cs.rutgers.edu/~ccshan/logicprog/LogicT-icfp2005.pdf
12:41:59 <LoganCapaldo> @where+ LogicT http://www.cs.rutgers.edu/~ccshan/logicprog/LogicT-icfp2005.pdf
12:41:59 <lambdabot> Done.
12:42:03 <LoganCapaldo> @where LogicT
12:42:04 <lambdabot> http://www.cs.rutgers.edu/~ccshan/logicprog/LogicT-icfp2005.pdf
12:42:08 <LoganCapaldo> gooood
12:42:59 <LoganCapaldo> Haskell is like the over-language
12:43:09 <opqdonut> uber-language, even :)
12:44:10 <ddarius> See also Typed Logical Variables in Haskell
12:57:57 <jrmole> does anyone know if it's possible to use arrow syntax in a context where arr/pure doesn't make sense?
12:58:39 <ddarius> jrmole: Try it and find out.
12:59:22 <jrmole> ghc likes to use arr for managing tuples and the like, even when i define all of the Arrow class members
12:59:28 <jrmole> i'm not sure if this is a bug or what
13:00:19 <Heffalump> I sort of had that problem with something I wanted to do with arrows. My conclusion was that what I wanted to do wasn't really an arrow.
13:00:53 <jrmole> yeah, it's definitely not an arrow, i'd just like to steal the syntax for my own purposes :)
13:00:58 <jrmole> i'm writing filtergraphs in haskell, essentially
13:01:06 <Heffalump> :-)
13:01:20 <Heffalump> I think the problem is that you could easily run into situations where the translation is wrong for your purposes.
13:01:50 <sorear> jrmole: the desugarer is deliberately simplistic, it relies on the Simplifier to apply rewrite rules defined in Control.Arrow (which are in turn defined using the arrow laws)
13:01:53 <yip__> what function does [n..m] syntax sugar expand to?
13:01:57 <sorear> enumFromTo
13:02:05 <yip__> danke
13:02:22 <Heffalump> sorear: surely if they aren't applied, you just get inefficient code, not incorrect code?
13:02:43 <sorear> Heffalump: correct.
13:02:59 <jrmole> i think that if you define all of (>>>), first, second, (***), (&&&) then there should be no need to use arr/pure for desugaring code that doesn't use it
13:03:02 <sorear> his complaint seemed to be about the sub-optimality
13:03:27 <sorear> jrmole: what functions you define is completely irrelevant
13:03:39 <jrmole> there are defaults that use arr
13:03:41 <sorear> jrmole: because Control.Arrow.Arrow has default methods
13:04:01 <sorear> jrmole: the desugarer still uses *** etc, even if they are actually defaults
13:04:32 <sorear> confirm: we ARE talking about suboptimal -ddump-ds output?
13:09:02 <titus_> I am trying to build the docs for ghc 6.6 on ubuntu, and failing - I have various docbook and tetex packages installed, does anyone know what might be missing?
13:09:08 <hpaste>  titus pasted "ghc6.6 docs build failure" at http://hpaste.org/1295
13:10:24 <titus_> I am using edgy, so have to build from source...
13:12:55 <sorear> @check \a b c -> gcd a (b::Integer) == 1 && c `mod` a == 0 && c `mod` b == 0 => c `mod` (a*b) == 0
13:12:55 <lambdabot>  Parse error
13:13:14 <sorear> @check \a b c -> (gcd a (b::Integer) == 1 && c `mod` a == 0 && c `mod` b == 0) => (c `mod` (a*b) == 0)
13:13:15 <lambdabot>  Parse error
13:13:27 <sorear> @check \a b c -> (gcd a (b::Integer) == 1 && c `mod` a == 0 && c `mod` b == 0) ==> (c `mod` (a*b) == 0)
13:13:29 <lambdabot>  Exception: Prelude.gcd: gcd 0 0 is undefined
13:13:43 <titus_> ah, I installed docbook-website and ran configure, now it seems OK
13:13:45 <sorear> @check \a b c -> (a > 0 && b > 0 && gcd a (b::Integer) == 1 && c `mod` a == 0 && c `mod` b == 0) ==> (c `mod` (a*b) == 0)
13:13:46 <lambdabot>  Arguments exhausted after 33 tests.
13:14:16 <sorear> @check \a b c -> (a > 0 && b > 0 && gcd (a::Integer) (b::Integer) == 1 && (c::Integer) `mod` a == 0 && c `mod` b == 0) ==> (c `mod` (a*b) == 0)
13:14:17 <lambdabot>  Arguments exhausted after 38 tests.
13:14:26 <sorear> @src Integer arbitrary
13:14:26 <lambdabot> Source not found. My mind is going. I can feel it.
13:21:31 <dmwit> ?src Integer Arbitrary
13:21:32 <lambdabot> Source not found. Do you think like you type?
13:26:00 <tiglionabbit> how long does it take an average computer to divide an integer with 500 digits?
13:26:43 <Japsu> > 10^500 / 7
13:26:44 <lambdabot>  Infinity
13:26:48 <Japsu> ..
13:26:52 <Japsu> > 10^^500 / 7
13:26:53 <lambdabot>  Infinity
13:26:55 <Japsu> ..
13:27:04 <tiglionabbit> ?
13:27:04 <Japsu> > 10^^500 / 7^^341
13:27:06 <lambdabot>  Infinity
13:27:12 <Japsu> :(
13:27:37 <tiglionabbit> > 10^^500
13:27:39 <lambdabot>  Infinity
13:28:00 <tiglionabbit> > a :: Integer
13:28:01 <lambdabot>   Not in scope: `a'
13:28:14 <tiglionabbit> how do you make it compute that as an integer?
13:28:55 <jrmole> > (10 :: Integer)^^500 / 7
13:28:56 <lambdabot>   add an instance declaration for (Fractional Integer)
13:28:56 <lambdabot>     In the expression:...
13:29:04 <jrmole> > (10 :: Integer)^500 / 7
13:29:05 <lambdabot>   add an instance declaration for (Fractional Integer)
13:29:05 <lambdabot>     In the expression:...
13:29:16 <jrmole> > (10 :: Integer)**500 / 7
13:29:17 <Igloo> You want `div` for integer division
13:29:17 <lambdabot>   add an instance declaration for (Floating Integer)
13:29:29 <jrmole> > (10 :: Integer)**500 `div` 7
13:29:30 <lambdabot>   add an instance declaration for (Floating Integer)
13:29:49 <Igloo> And (^) for integer exponentiation
13:29:49 <jrmole> @type (**)
13:29:52 <lambdabot> forall a. (Floating a) => a -> a -> a
13:29:56 <jrmole> > (10 :: Integer)^500 `div` 7
13:29:58 <lambdabot>  1428571428571428571428571428571428571428571428571428571428571428571428571428...
13:30:07 <opqdonut> :D
13:30:17 <Japsu> so apparently that doesn't take that long after all
13:30:20 <Japsu> ^_____^
13:30:25 <ddarius> @version
13:30:26 <lambdabot> lambdabot 4p517, GHC 6.6 (OpenBSD i386)
13:30:26 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
13:30:28 <jrmole> not after you figure out which operators to use :)
13:30:33 <Japsu> heh yeah
13:31:04 <jrmole> @type (^)
13:31:07 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
13:31:08 <jrmole> @type (^^)
13:31:11 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
13:31:54 <jrmole> maybe there should be a two-param typeclass for exponentiation
13:32:36 <jcreigh> bos++ http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
13:32:39 <lambdabot> Title: teideal glic deisbhalach  Blog Archive  A Haskell regular expression tutoria ..., http://tinyurl.com/2xtgpw
13:33:55 <ddarius> :t (Text.Regex.Posix.=~)
13:33:57 <lambdabot> forall source1 source target. (Text.Regex.Base.RegexLike.RegexContext Text.Regex.Posix.Wrap.Regex source1 target, Text.Regex.Base.RegexLike.RegexMaker Text.Regex.Posix.Wrap.Regex Text.Regex.Posix.
13:33:58 <lambdabot> Wrap.CompOption Text.Regex.Posix.Wrap.ExecOption source) => source1 -> source -> target
13:34:29 <ddarius> Without all of the qualified names, it wouldn't be too bad.
13:35:31 <beelsebob> @hoogle Int -> String
13:35:32 <lambdabot> Test.QuickCheck.configEvery :: Config -> Int -> [String] -> String
13:35:33 * beelsebob pokes lambdabot 
13:35:38 <beelsebob> hmm :/
13:35:52 <ddarius> show
13:35:57 <beelsebob> no, not the one I want
13:36:22 <beelsebob> I want to take any integer to it's hexadecimal representation
13:36:40 <ddarius> :t \i -> showHex i ""
13:36:43 <lambdabot> forall a. (Integral a) => a -> String
13:37:05 <ddarius> @hoogle Int -> StringS
13:37:06 <lambdabot> No matches, try a more general search
13:37:15 <beelsebob> heh
13:37:19 <ddarius> @hoogle Int -> String -> String
13:37:20 <lambdabot> No matches, try a more general search
13:37:35 <ddarius> @hoogle Int -> ShowS
13:37:37 <lambdabot> Text.Html.renderHtml' :: Int -> HtmlElement -> ShowS
13:37:37 <lambdabot> Prelude.showsPrec :: Show a => Int -> a -> ShowS
13:53:59 <hyrax42> are there any resources on appropriate approaches to sat-solvers in a purely functional style?
14:01:28 <hyrax42> ?users
14:01:28 <lambdabot> Maximum users seen in #haskell: 336, currently: 302 (89.9%), active: 34 (11.3%)
14:04:02 <astrolabe> Any tips on finding '<<loop>>' s?  I'm not even sure what they are.
14:05:36 <norpan> check your recursions
14:05:42 <bd_> > let x = x in x
14:05:44 <lambdabot>  Exception: <<loop>>
14:05:45 <norpan> make sure that they terminate
14:06:04 <astrolabe> Hmmm. Thanks.
14:06:12 <ddarius> As bd_ demonstrated, check your recursive values.
14:06:56 * sorear wishes atomically was in a typeclass
14:09:06 <hyrax42> was my earlier question seen?
14:09:24 <astrolabe> try it again
14:09:31 <hyrax42> or a simpler question, was there any activity between 30 minutes ago and 10 ago
14:09:40 <hyrax42> question was: are there any resources on appropriate approaches to sat-solvers in a purely functional style?
14:10:07 <sorear> I'd use the list monad (when I'm not in a perf mood)
14:10:18 <TomMD> I, for one, don't know what a sat-solver is.
14:10:50 <astrolabe> I didn't see any such activity.
14:11:28 <hyrax42> sorear: hmmm I feel a bit -- but not too -- in a perf mood
14:12:01 <hyrax42> I'm reading a paper on MiniSat, which is in C++...
14:12:12 <sorear> class Solve a r | a -> r where solve :: a -> [r]
14:12:12 <sorear> instance Solve Bool [a] where solve False = [] ; solve True = [[]]
14:12:14 <hyrax42> trying to judge suitabiliyt of the techniques there to be applied in haskell
14:12:18 <monochrom> @quote atomically
14:12:19 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
14:13:11 <sorear> instance Solve rs [Bool] => Solve (Bool -> rs) [Bool] where solve fn = solve (fn True) ++ solve (fn False)
14:13:12 <TomMD> @quote dons
14:13:12 <lambdabot> dons says: This is all very nice, but the code feels a bit icky.
14:13:26 <TomMD> Thats not a great quote.
14:13:39 <sorear> now, just say:  solve $ \x y z -> x == (y == z)
14:13:48 <lispy> astrolabe: what do you want to know about thunks?
14:14:02 <sorear> specializing a bit
14:14:13 <hyrax42> hmmm
14:14:44 <sorear> class Solve a where solve :: a -> [[Bool]]
14:14:44 <sorear> instance Solve Bool where solve False = [] ; solve True = [[]]
14:14:44 <sorear> instance Solve r => Solve (Bool -> r) where solve fn = solve (fn True) ++ solve (fn False)
14:14:52 <sorear> now, just say:  solve $ \x y z -> x == ((y::Bool) == z)
14:15:06 <lispy> astrolabe: i believe it was the paper, spineless tagless g machine that helped me understand thunks and lazy evalation
14:15:23 <TomMD> That thing is a thick paper.
14:15:25 <sorear> come to think of it this is exactly what smallcheck does
14:15:28 <TomMD> @where stg
14:15:29 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
14:15:38 * sorear likes ifpl better
14:15:59 <TomMD> @where ifpl
14:16:00 <lambdabot> I know nothing about ifpl.
14:16:06 <sorear> @scheck \x y z -> ((x == y) == z)
14:16:08 <lambdabot> Add a type signature
14:16:14 <sorear> @scheck \x y z -> ((x == (y::Bool)) == z)
14:16:16 <lambdabot>   Failed test no. 2. Test values follow.: True, True, False
14:16:41 <sorear> too bad this doesn't wokr : @. {where+ ifpl} google slpj-book-1987
14:16:47 <sorear> @google slpj-book-1987
14:16:49 <lambdabot> http://research.microsoft.com/~simonpj/papers/slpj-book-1987/index.htm
14:16:49 <lambdabot> Title: The Implementation of Functional Programming Languages
14:16:57 <sorear> @where+ ifpl http://research.microsoft.com/~simonpj/papers/slpj-book-1987/index.htm
14:16:58 <lambdabot> Done.
14:17:20 <sorear> interestingly, that is the #2 result for SLPJ
14:17:25 <xerox> @scheck \x y z -> not ((x == y) == (z :: Bool))
14:17:26 <lambdabot> Add a type signature
14:17:27 <sorear> SPJ is #5 on google SPJ
14:17:48 <xerox> @scheck \x y z -> not ((x == (y::Bool)) == z)
14:17:50 <lambdabot>   Failed test no. 1. Test values follow.: True, True, True
14:18:07 <TomMD> scheck is deterministic and complete?
14:18:12 <sorear> yeah
14:18:15 <xerox> which sat-isfies the x == y == z
14:21:26 <TomMD> @scheck \a b c n -> ((a::Int)^n + b^n == c^n) && a /= 0 && b /= 0 && c /= 0 && n > 2
14:21:27 <lambdabot> Add a type signature
14:22:05 <TomMD> @scheck \(a::Int) (b::Int) (c::Int) (n::Int) -> (a^n + b^n == c^n) && a /= 0 && b /= 0 && c /= 0 && n > 2
14:22:06 <lambdabot>  Parse error in pattern
14:22:16 <TomMD> Damn, can't do that.
14:22:58 <TomMD> @scheck \a b c n -> (a^n + b^n == c^n) && (a::Int) /= 0 && (b::Int) /= 0 && (c::Int) /= 0 && (n::Int) > 2
14:23:00 <lambdabot>   Failed test no. 1. Test values follow.: 0, 0, 0, 0
14:23:23 <TomMD> @scheck \a b c n -> not ((a^n + b^n == c^n) && (a::Int) /= 0 && (b::Int) /= 0 && (c::Int) /= 0 && (n::Int) > 2)
14:23:24 <lambdabot> Exception: Prelude.^: negative exponent
14:23:38 <TomMD> Oh come on
14:24:00 <TomMD> @scheck \a b c n -> not ((a::Int) /= 0 && (b::Int) /= 0 && (c::Int) /= 0 && (n::Int) > 2 && (a^n + b^n == c^n))
14:24:02 <lambdabot>   Completed 28561 test(s) without failure.
14:24:09 <TomMD> Sounds right
14:24:24 <xerox> @scheck \a b c n -> (n > 2 && (a,b,c) /= (0,0,0)) ==> (a::Int)^(n::Int) + b^n == c^n -- whatever that means
14:24:25 <lambdabot>   Failed test no. 7. Test values follow.: -3, -3, -3, 3
14:25:21 <TomMD> "Whatever that" is FLT
14:25:44 <TomMD> @where flt
14:25:45 <lambdabot> I know nothing about flt.
14:26:02 <TomMD> @wiki flt
14:26:02 <lambdabot> http://www.haskell.org/haskellwiki/flt
14:26:17 <TomMD> @where+ flt http://en.wikipedia.org/wiki/Fermat's_last_theorem
14:26:18 <lambdabot> Done.
14:26:33 <TomMD> @where flt
14:26:34 <lambdabot> http://en.wikipedia.org/wiki/Fermat's_last_theorem
14:26:38 <TomMD> Good
14:27:59 <xerox> well, with 'not' is more flt-ish (:
14:29:40 <TomMD> Yes, hence my final scheck that went 28561 tests.
14:40:15 <syntaxfree> @. google google google
14:40:18 <lambdabot> http://www.google.com/help/operators.html
14:40:18 <lambdabot> Title: Advanced Google Search Operators
14:41:20 <syntaxfree> @. google quote
14:41:22 <lambdabot> No Result Found.
14:41:25 <syntaxfree> @quote
14:41:25 <lambdabot> PaulGraham says: I get the impression that using [Haskell] would feel like reading a novel written by a literary critic.
14:41:33 <syntaxfree> @quote
14:41:33 <lambdabot> sigfpe says: I think Haskell is a great language for short attention spans. You can get so much done in one line before you get bored.
14:41:37 <syntaxfree> @quote
14:41:38 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
14:41:45 <syntaxfree> @quote
14:41:46 <lambdabot> Turks says: my mom is like...naked in my shower..wtf!
14:43:58 <yip__> did paul graham really say that?
14:45:34 <xerox> @. google . google google
14:45:37 <lambdabot> No Result Found.
14:45:41 <xerox> @. google . google . google google
14:45:45 <lambdabot> http://encarta.msn.com/dictionary_/google.html
14:45:45 <lambdabot> Title: google definition - Dictionary - MSN Encarta
14:46:10 <decaf> lambdabot: what the heck are you talking about, who sad that?
14:46:40 <yip__> @quote PaulGraham
14:46:40 <lambdabot> PaulGraham says: I get the impression that using [Haskell] would feel like reading a novel written by a literary critic.
14:46:44 <yip__> @quote PaulGraham
14:46:45 <lambdabot> PaulGraham says: I get the impression that using [Haskell] would feel like reading a novel written by a literary critic.
14:46:52 <decaf> who's bot is this?
14:48:12 <sorear> donald bruce steward, aka dons
14:48:15 <kpreid> @version
14:48:15 <lambdabot> lambdabot 4p517, GHC 6.6 (OpenBSD i386)
14:48:16 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
14:48:55 <decaf> so, where are these quotes coming?
14:49:05 <sorear> however, lambdabot has changed maintainership a ridiculous number of times
14:49:06 <sorear> us
14:49:19 <sorear> @remember decaf whare are these quotes coming?
14:49:20 <lambdabot> Done.
14:49:23 <sorear> @quote decaf
14:49:25 <lambdabot> decaf says: whare are these quotes coming?
14:49:36 <decaf> I see
14:49:57 <sorear> Pseudonym and shapr have maintained the bot off the top of my head
14:50:11 <decaf> someone used nickname "Turks" here?
14:50:13 <sorear> newsham and ADEpt have run forkes of the bot
14:50:37 <decaf> or this quote has been added in a different way?
14:51:22 <sorear> oh, you can use anythink you want for the nick, it isn't checked for validity
14:51:31 <sorear> ' is illegal in irc nicks, but:
14:51:35 <sorear> @quote StefanO'Rear
14:51:36 <lambdabot> StefanO'Rear says: ...the semantics are what give people named Simon the courage to implement counterintuitive optimizations without losing sleep.
14:53:38 <mauke> does anyone here want to play with my new C/C++ interpreter? :-)
14:53:54 <TomMD> Ummm... can it interpret Haskell instead?
14:54:05 <mauke> that's what lambdabot is for
14:54:19 <xerox> make it a lambdabot plugin (:
14:54:20 <phoniq> whoa
14:54:28 <xerox> and suddently everybody will play with it
14:55:04 <mauke> the parse errors suck, though :)
14:55:05 <Mr_Awesome> hi, im using emacs to edit haskell using the emacs mode from haskell.org. how can i start a buffer for interpreting using ghci?
14:55:21 <Heffalump> mauke: you can interepret all of C/C++?
14:55:23 <xerox> Mr_Awesome: C-c C-l
14:55:34 <xerox> Mr_Awesome: or M-x run-haskell
14:55:39 <mauke> Heffalump: no, some parts were unspec'd
14:55:55 <mauke> like _config or _len#
14:56:11 <Mr_Awesome> xerox: heh, doesnt work... maybe im using an old version
14:56:22 <xerox> Mr_Awesome: did you enable the ghci mode?
14:56:26 <mauke> I can parse them, though
14:56:44 <Mr_Awesome> xerox: i dont know. i called the function 'turn-on-haskell-ghci
14:57:07 <xerox> (add-hook 'haskell-mode-hook 'turn-on-haskell-ghci)
14:57:11 <Mr_Awesome> run-haskell doesnt even exist for me
14:57:14 <Mr_Awesome> ah ok
14:57:23 <xerox> then visiting an Haskell file should enable C-c C-l
15:01:07 <Mr_Awesome> xerox: hmm, C-c C-l is still disabled
15:01:47 <sorear> Mr_Awesome: autoloading is broken on that file, you'll need to (load) it manually
15:02:02 <sorear> $ locate inf-haskell.el
15:02:21 <dmead> hi channel
15:02:28 <TomMD> Hi dmead
15:02:31 <TomMD> @quote dmead
15:02:32 <lambdabot> Cale says: [dmead] yo yo yo yo what it is mother fuckers [Cale] dmead: this isn't #scheme
15:02:36 <sorear> then M-S-: (load "<fullname>")
15:02:37 <dmead> :P
15:03:37 <dmead> is the parsec author still somewhere to be found?
15:05:53 <Heffalump> he doesn't seem to be making much noise on Haskell lists
15:06:00 <dmead> hmm
15:06:01 <dmead> oh well
15:06:21 <dmead> i guess i should just learn about gammar parsing :P
15:06:32 <Heffalump> DOH
15:06:47 * Heffalump replaces "head" with "thehead" in some HTML construction code and suddenly gets far less confused
15:07:22 <Mr_Awesome> sorear: restarting emacs did the trick
15:07:32 <Heffalump> oh, I mean header, not thehead. Anyway, you get the idea.
15:14:36 <ddarius> Heffalump: Bah, just don't use head anyways.
15:19:44 <Heffalump> ?
15:20:08 <dmhouse> Heffalump: yeah, that's one of the many annoyances with Text.Html.
15:27:14 <Mr_Awesome> is there any way to make the ghci buffer have syntax highlighting?
15:27:35 <SamB> Mr_Awesome: not unless you become a GHC hacker
15:27:49 <SamB> oh, wait, you meant in Emacs?
15:28:08 <dmead> isn't there a package for that?
15:28:14 <dmead> to add colors to the error messages
15:28:28 <SamB> you mean compilation-minor-mode?
15:28:32 <Mr_Awesome> yeah in emacs
15:28:40 <SamB> actually, I think that doesn't color
15:29:02 <Mr_Awesome> the source files are highlighted but not the ghci buffer
15:29:09 <Mr_Awesome> oh really?
15:29:16 <Mr_Awesome> i wonder why not
15:29:20 <dmead> butt
15:29:25 <dmead> why do you need colors for ghci
15:29:31 * sorear starts hacking an optimizing compiler in a fit of boredom
15:29:33 <dmead> it's pretty simple
15:29:39 <SamB> compilation-minor-mode lets you click on error messages in a certain way
15:29:42 <Mr_Awesome> i dont. i dont need any colors. it would just be nice
15:29:43 <sorear> s/in/for unlambda in/
15:29:47 <allbery_b> there's a thing that wraps ghci in HsColour, but I don't think it will work within emacs
15:29:53 <SamB> sorear: wow
15:30:00 <dmead> ah yes
15:30:01 <dmead> that
15:30:11 <SamB> sorear: could you not maybe write some semantics for unlambda first?
15:30:17 <dmead> are you guys familiar with happy?
15:30:29 <SamB> somewhat
15:30:36 <SamB> I've used it a few times
15:30:36 <sorear> SamB: IMO the reference section of the page is close enough
15:30:46 <dmead> do you have to produce a stand alone binary?
15:30:54 <dmead> or can you load it up via ghci
15:31:04 <SamB> sorear: I tried to write one at one point that didn't pass my tests :-(
15:31:26 <SamB> actually it was an interpreter
15:31:40 <dmead> eh?
15:31:42 <SamB> dmead: you have to run it on the file each time you update
15:31:54 <dmead> ah
15:32:05 <SamB> then you can load it in GHCi just fine
15:32:05 <dmead> yea
15:32:09 <dmead> happy seems more flexible
15:32:13 <dmead> but parsec is more useable
15:32:17 <dmead> if that makes sense
15:32:23 <SamB> I tend to write a shell script that runs happy and alex and invoke it with :!
15:32:33 <dmead> ahh
15:32:42 <SamB> (also it tends to check whether each source file is newer then the target file)
15:33:20 <dmead> yea i've written some ADTs to describe first order logic
15:33:40 <dmead> if you type out say (x)(y)Fxy -> (y)(x)Fxy
15:33:48 <dmead> it takes two lines
15:35:42 <SamB> (my shellscript does that checking, not happy!)
15:36:13 <SamB> dmead: ah.
15:36:22 <dmead> ah
15:36:22 <dmead> yea
15:36:37 <dmead> i wrote a parsec configuration for classical logic
15:36:37 <SamB> I sorta wish parsec had better support for external lexers
15:36:39 <dmead> which is no big deal
15:36:50 <dmead> but FOL has a bit more complex syntax
15:37:18 <SamB> a lot of combinators are only available for CharParsers, for no obvious reason
15:37:24 <dmead> =/
15:38:03 <SamB> also for some reason Parsec assumes you are going to be parsing a *list* of things
15:38:16 <dmead> yea
15:38:18 <dmead> list of chars
15:38:20 <dmead> =/
15:38:36 <dmead> it's not all that flexible i think
15:38:45 <SamB> whereas Happy/Alex support anything
15:39:00 <dmead> whats Alex?
15:39:15 <SamB> a lexer generator that works nicely with happy
15:39:20 <dmead> ah
15:39:54 <SamB> not apparantly through any kind of actual integration
15:40:12 <dmead> happy lets you take a string and convert it to type constructors right?
15:40:13 <SamB> just that their interfaces mesh well
15:40:22 <SamB> hmm?
15:40:52 <dmead> in happy
15:41:01 <dmead> if i write an ebnf for logic
15:41:04 <dmead> it can read a string
15:41:15 <dmead> and correctly use my type constructors?
15:41:27 <SamB> what do you mean? type constructors?
15:41:36 <dmead> ADT
15:41:37 <dmead> s
15:41:48 <SamB> you have to write the code for that usually
15:41:53 <dmead> hmm
15:41:59 <SamB> i.e....
15:42:43 <SamB> expr "*" expr { Times $1 $3 }
15:42:45 <dmead> i'll show you
15:42:47 <dmead> ?paste
15:42:47 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:43:21 <Mr_Awesome> how is it possible to use foldr on an infinite list?
15:43:23 <hpaste>  dmead pasted "FOL" at http://hpaste.org/1296
15:43:41 <Mr_Awesome> wouldnt it never return?
15:43:48 <dmead> depends on the function you apply
15:44:16 <Mr_Awesome> what would be a function that would work?
15:44:35 <SamB> (:) ;-)
15:44:39 <dmead> like, something that throws an exception when it hits a certain number
15:44:47 <dmead> :P
15:45:25 <dmead> folr (\x -> if x == 100 then throw exception) [1..101]
15:45:30 <dmead> foldr (\x -> if x == 100 then throw exception) [1..101]
15:45:34 <dmead> hehe
15:45:41 <dmead> i forget the syntax for exceptions
15:46:12 <dmead> SamB: i've got a binding there, t2
15:46:27 <ddarius> Happy and Alex were codesigned/implemented.  It is no surprise that the work well together.
15:46:29 <dmead> that show what Pxy is in constructors
15:46:48 <mauke> > foldr (\x z -> if x == 10 then [] else x : z) [42] [1 ..]
15:46:49 <lambdabot>  [1,2,3,4,5,6,7,8,9]
15:46:51 <SamB> oops.
15:47:02 <SamB> I just killed mozilla instead of closing a window :-(
15:47:13 <ddarius> Mr_Awesome: Any function non-strict in it's second argument will work nicely with foldr on infinite lists.
15:47:52 <mauke> > foldr const undefined [1 ..]
15:47:53 <lambdabot>  1
15:50:11 <Mr_Awesome> ddarius: so will foldl ever work with infinite lists?
15:50:22 <dmead> no :P
15:50:36 <dmead> ?src foldl
15:50:37 <lambdabot> foldl f z xs = lgo z xs
15:50:37 <lambdabot>     where lgo z []     =  z
15:50:37 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
15:50:50 <augustss> foldr is strictly more powerful than foldl
15:50:52 <SamB> dmead: what was the question?
15:51:09 <augustss> you can implement foldl with foldr, but not vice versa
15:51:15 <dmead> SamB; i think i answered it myself
15:51:38 <dmead> i'm just trying to find a simple way to parse a string and return a correct squence of constructors
15:51:44 <SamB> dmead: good, because probably next I was going to tell you to read the documentation in order to discover how to do it
15:51:50 <dmead> :P
15:51:57 <SamB> well, usually you want to use Alex to lex
15:51:58 <dmead> yea, happy would be overkill for my purposes
15:52:01 <dmead> ah
15:52:12 <SamB> when you use happy, I mean
15:58:23 <syntaxfree> why not just use parsec?
15:59:45 <ddarius> What's with the crazy parentheses dmead?
16:00:17 <dmead> i get errors otherwise
16:00:18 <dmead> =/
16:00:54 <ddarius> You have tons of extraneous parentheses in the pasted Haskell code.
16:01:22 <dmead> ah
16:01:22 <dmead> yes
16:01:23 <dmead> i do
16:01:24 <dmead> woops
16:01:45 <dmead> and i could probably do without a type for predicate
16:05:10 <Mr_Awesome> so foldl is mainly good for more efficient strict evaluation
16:05:36 <mauke> no, that's foldl'
16:05:49 <mauke> foldl is mainly useless
16:08:41 <Mr_Awesome> foldl' ?
16:09:03 <ddarius> @oldwiki StackOverflow
16:09:04 <lambdabot> http://www.haskell.org/hawiki/StackOverflow
16:10:47 <Mr_Awesome> so whats the point of even including foldl? shouldnt it just be defined like foldl' in the first place?
16:13:31 <ddarius> Mr_Awesome: It's not a matter of efficiency, you just use them in different circumstances.
16:14:00 <Mr_Awesome> i see
16:14:33 <sorear> > foldl (flip (:)) [] "dlroW elloH"
16:14:34 <lambdabot>  "Holle World"
16:14:52 <sorear> I apparently can't type backward :)
16:15:09 <dmead> @google unification
16:15:12 <lambdabot> http://www.unification.org/
16:15:13 <lambdabot> Title: Unification Church Home Page
16:15:14 <astrolabe> Just turn your keyboard round ;)
16:15:18 <dmead> super
16:22:58 <narain> ?src reverse
16:22:59 <lambdabot> reverse = foldl (flip (:)) []
16:23:43 <narain> > take 5 $ reverse [1..1000000]
16:23:45 <lambdabot>  [1000000,999999,999998,999997,999996]
16:24:39 <narain> > let reverse = foldl' (flip (:)) [] in take 5 $ reverse [1..1000000]
16:24:41 <lambdabot>  [1000000,999999,999998,999997,999996]
16:54:13 <yip__> @users
16:54:14 <lambdabot> Maximum users seen in #haskell: 336, currently: 294 (87.5%), active: 36 (12.2%)
17:07:43 <stepcut> :t  \c -> ((id c) (id c))
17:07:46 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
17:07:46 <lambdabot>     Probable cause: `id' is applied to too few arguments
17:07:49 <stepcut> :(
17:09:12 <narain> :t \c -> c c
17:09:14 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
17:09:15 <lambdabot>     Probable cause: `c' is applied to too many arguments
17:10:45 <stepcut> in ocaml that will work if you enable -rectypes, though it can case type errors to slip past the type checker
17:11:23 <narain> what kind of argument can you apply  \c -> c c  to?
17:11:29 <stepcut> # fun x -> x x;;
17:11:29 <stepcut> - : ('a -> 'b as 'a) -> 'b = <fun>
17:13:23 <narain> stepcut: what is such a function useful for?
17:14:08 <narain> wait, you can't define the Y combinator if you don't have recursive types
17:14:11 <narain> is that it?
17:14:40 <stepcut> let rec f n () = (n, f (n + 1)) ;;
17:15:48 <narain> is that an infinite list of numbers?
17:15:51 <stepcut> i was trying to implement SKI combinators in Haskell, but (S I I) cause the type checker to die
17:16:16 <stepcut> (well, s i i)
17:16:18 <ddarius> stepcut: Indeed.  That was the original purpose of types.
17:16:48 <stepcut> ddarius: russell's paradox, right ?
17:17:29 <ddarius> stepcut: Yes.  Also there was Church trying to save the lambda calculus.
17:18:05 <stepcut> anyway, using ocaml -rectypes, was fine, except I wanted the functions to have non-strict arguments. But, I don't think you can do that with ocaml
17:18:28 <stepcut> you can use lazy/Lazy.force to create lazy expressions, but that is not the same thing
17:18:33 <milkcan> help i am a newbie
17:18:37 <narain> i'm afraid i don't see the connection between irreducible lambda expressions and a paradox in naive set theory
17:19:16 <narain> or is there another russell's paradox i haven't heard of?
17:19:33 <Lemmih> milkcan: We can fix that.
17:20:11 <kilimanjaro> narain, you are familiar with russel's paradox, right? The problem was that the universe was too "big"
17:20:37 <kilimanjaro> It was not really a meaningful object.
17:21:04 <narain> right... it allowed impossible sets to be defined?
17:21:05 <ddarius> abstraction <=> set comprehension  application <=> membership test
17:21:39 <narain> hmm, i'll have to chew on those arrows
17:21:45 <narain> (to mix metaphors)
17:21:53 <narain> (badly)
17:22:29 <narain> ah, equating a set with its characteristic function
17:22:32 <narain> i see that
17:22:48 <ddarius> more or less
17:23:19 <narain> so... russell's paradox... is \x -> not (x x)?
17:23:35 <narain> umm, wait
17:23:47 <milkcan> help i am bored
17:23:50 <milkcan> i need something to do!
17:24:52 <narain> hmm, i guess what i wrote is correct?
17:25:01 <narain> \x -> not (x x)?
17:25:10 <narain> milkcan: try project euler
17:26:04 <milkcan> i do not understand any of those questions!
17:27:41 <Heffalump> @hoogle comparing
17:27:42 <lambdabot> No matches found
17:28:00 <stepcut> http://groups.google.com/group/comp.lang.functional/msg/2a3a33bfd23a7184?q=ocaml+rectypes&hl=en&lr=lang_en&ie=UTF-8&oe=UTF-8&safe=off&rnum=1
17:28:03 <lambdabot> Title: infinite types ? (haskell) - comp.lang.functional | Google Groups, http://tinyurl.com/2dvqft
17:29:18 <dmwit> comparing p x y = compare (p x) (p y)
17:29:33 <dmwit> milkcan: Write a game!
17:29:39 <dmwit> Haskell is way short on games.
17:29:48 <Heffalump> I know the definition, I was trying to find it in the standard libraries
17:30:11 <Heffalump> to save my code from having it duplicated all over the place cos I can't be bothered to make a Utils module
17:30:45 <dmwit> Heffalump: I don't think it's standard until 6.6
17:31:39 <Heffalump> ok, ta
17:34:21 <stepcut> so, is there was some to use an intermediate data type so that (\x -> x x) type-checks?
17:35:41 <syntaxfree> http://catb.org/~esr/jargon/html/G/glark.html
17:35:45 <lambdabot> Title: glark
17:35:45 <syntaxfree> that is nice jargon.
17:35:50 <syntaxfree> "System F typeglarking"
17:36:00 <Heffalump> does anyone actually trust the Jargon file any more?
17:36:18 <syntaxfree> Heffalump: that refers to Hofstadter's "Metamagical Themas".
17:36:38 <syntaxfree> I know "glark" isn't common-use jargon, but it'd be interesting to adopt.
17:36:54 <Heffalump> the article claims that it is in use, that's the bit I find suspicious
17:36:58 <syntaxfree> When do you think ESR jumped the shark?
17:37:54 <syntaxfree> I found "The Cathedral and the Bazaar" way way pretentious, but that didn't alienate most people.
17:38:00 <narain> glark :: Context a -> a
17:38:10 <hpaste>  falconair pasted "hs-plugins error" at http://hpaste.org/1297
17:38:18 <Heffalump> oh, he seems to have removed the "hacker politics" claims it had some time back
17:38:29 <syntaxfree> more like (Monad m) => Context a -> m a
17:38:33 <falconair> folks, i'm getting this error (above link) when trying to install hs-plugins through darwin ports
17:38:36 <syntaxfree> where m could be id, Maybe or []
17:39:00 <syntaxfree> Heffalump: that was weird, yes.
17:39:09 <syntaxfree> (and I say that being a libertarian quasihacker)
17:39:37 <Heffalump> perhaps I'll start trusting it again :-)
17:39:43 * Heffalump goes to bed, anyway
17:40:24 <syntaxfree> I'm sleepy, but I've agreed to go nightclubbin' with a friend.
17:40:29 <ddarius> stepcut: What do you mean?
17:40:32 <syntaxfree> Actually, I was the one who wanted to.
17:40:39 <syntaxfree> But now I'm sleepy & lazy.
17:40:48 * syntaxfree slugs down the caffeine.
17:41:05 <falconair> AltData/Typeable.hs:450:0: /  parse error (possibly incorrect indentation)
17:41:14 <stepcut> ddarius: hrm, I am not even sure :)
17:41:25 <dmwit> ?go y combinator haskell
17:41:27 <lambdabot> http://www.itlabs.umn.edu/HyperNews/get/gopalan/courses/CSCI8980-fall-2001/classwork/2.html
17:41:27 <lambdabot> Title: Y-combinator
17:42:12 <dmwit> stepcut: You mean like that?
17:42:20 <stepcut> dmwit: looks promising
17:42:39 <syntaxfree> isn't "fix" akin in functionality to the Y combinator?
17:42:46 <syntaxfree> (yes, I know the Y combinator itself won't type)
17:43:00 <dmwit> :t let y f = f (y f) in y
17:43:03 <lambdabot> forall t. (t -> t) -> t
17:43:07 <dmwit> :t fix
17:43:10 <lambdabot> forall a. (a -> a) -> a
17:43:17 <dmwit> ?src fix
17:43:17 <lambdabot> fix f = let x = f x in x
17:43:32 <syntaxfree> hmm.
17:43:55 <Philippa> syntaxfree: Y is an implementation of fix
17:44:00 <dmwit> They seem very, very similar. =P
17:44:23 <syntaxfree> man, this channel makes me feel stupid ;)
17:44:40 <syntaxfree> I've been spending time at #lisp/with openmcl, and boy, I feel like a genius.
17:46:10 <mr_tenor> feelin stupid ftw :)
17:46:30 <stepcut> data W a = W { unW :: W a -> a }
17:46:30 <stepcut> y f = (\ (W x) -> f (x (W x))) (W (\ (W x) -> f (x (W x))))
17:46:46 <stepcut> that seems to put GHCi into an infinite loop :-/
17:47:22 <syntaxfree> hmm.
17:47:57 <syntaxfree> > fix (\f x -> if x == 0 then [] else 1:(f x)) $ 5
17:47:59 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:47:59 <stepcut> GHC does ok, but not GHCi
17:48:11 <syntaxfree> > fix (\f x -> if x == 0 then [] else 1:(f (x-1))) $ 5
17:48:12 <lambdabot>  [1,1,1,1,1]
17:48:16 <syntaxfree> hmmm.
17:48:33 <syntaxfree> damn, there's a freaking lightbulb floating above my head right now.
17:48:50 <dmwit> Bulb of Damascus?
17:49:09 <syntaxfree> of course.
17:49:11 <narain> i forget, are you allowed to define types at the GHCi prompt?
17:49:11 <syntaxfree> this is fantastic.
17:49:19 <SamB> no!
17:49:22 <SamB> you are not!
17:49:30 <syntaxfree> Now I know why PGraham calls his company Y Combinator.
17:49:33 <narain> i was afraid not
17:49:36 <syntaxfree> damn!
17:49:45 <syntaxfree> @free fix
17:49:47 <lambdabot> f . g = h . f => f (fix g) = fix h
17:49:56 <narain> ?help free
17:49:56 <lambdabot> free <ident>. Generate theorems for free
17:50:11 <SamB> because it passes the fruit of its function to its function?
17:50:18 <ddarius> > fix (\fac n -> if n == 0 then 1 else n*fac (n-1)) 5
17:50:20 <lambdabot>  120
17:50:37 <syntaxfree> man. Most programming can be done inside fix.
17:50:41 <syntaxfree> hahahaha.
17:50:51 <syntaxfree> I'm gonna rave all night about the Y combinator to random girls at the club.
17:51:01 <syntaxfree> I'm such a nerd.
17:51:12 <ddarius> syntaxfree: A very effective selection mechanism if that's your thing.
17:51:12 * syntaxfree jumps up and down with excitement.
17:51:21 <narain> if The Man takes away your letrecs, you can stick it to 'im with fix.
17:51:52 <syntaxfree> I remember reading that let covered both the ML let and letrec cases, but I didn't dig it further.
17:52:28 <syntaxfree> > fix (\f x -> if x == 0 then f 1 else f (x-1))
17:52:29 <lambdabot>  Add a type signature
17:52:31 <ddarius> No, it only covers the letrec case.
17:52:34 <syntaxfree> > fix (\f x -> if x == 0 then f 1 else f (x-1)) $ 5
17:52:36 <lambdabot>  Exception: <<loop>>
17:52:47 <narain> i thought letrec was a superset of let?
17:53:02 <syntaxfree> letrec sounds like a french painter.
17:53:08 <jrmole> you can do pseudo-assignment in a nonrecursive let
17:53:16 <jrmole> let x = f x in let x = g x in ...
17:53:21 <narain> ah
17:53:24 <syntaxfree> mapM Letrec.
17:53:34 <jrmole> useful for expressing a series of transformations without generating lots of new identifier names
17:53:37 <jrmole> but easy enough to get around
18:04:31 <stepcut> is the a C AST/PrettyPrinter ?
18:04:46 <dmwit> stepcut: lint?
18:04:55 <stepcut> let me try to rephrase this
18:05:05 <dmwit> Or do you mean for pretty printing things generated by your C code.
18:05:06 <stepcut> is there a Haskell library for creating C code ?
18:05:18 <stepcut> creating/generating
18:05:27 <stepcut> for compilers
18:05:28 <SamB> dmwit: does this look like ##c?
18:05:41 <dmwit> =(
18:05:48 <dmwit> I'm bad at understanding people.
18:05:55 <ddarius> I'm sure there is one somewhere.
18:06:10 <SamB> granted, the fact that it is not does not mean nobody would ask that...
18:06:29 <stepcut> I assume GHC, JHC, and I think even now, YHC have one :)
18:06:49 <SamB> stepcut: I'm guessing that they do not really
18:07:15 <SamB> but use the unfortunately popular technique of pretty printing directly from an IR
18:07:32 <stepcut> IR ?
18:09:06 <dmwit> Maybe, internal representation?
18:11:48 <ddarius> Intermediate
18:20:11 <sorear> SamB: Sorta kinda.  GHC uses a rather long translation pipeline, and C is emitted from a C-- ast.
18:22:04 <sorear> falconair: your GHC is incompatible with your hs-plugins.
18:22:26 <sorear> falconair: either upgrade hs-plugins to darcs or downgrade ghc to 6.4.2
18:23:09 <SamB> sorear: yes.
18:23:14 <SamB> Cmm counts as an IR
18:23:21 <SamB> an AST for *C* would not
18:25:50 <sorear> @seen ADEpt
18:25:50 <lambdabot> ADEpt is in #haskell and #haskell-soc. I don't know when ADEpt last spoke.
18:26:32 <sorear> google++
18:26:42 <sorear> Did you mean: astapov xmpp
18:27:12 <sorear> knowing the correct spelling of spj is one thing, but ADEpt's true name ... wow
18:27:37 <jaredj> wait, ??
18:27:46 <jaredj> how did you google him
18:28:08 <sorear> jaredj: I knew earlier
18:28:27 <sorear> I searched for astopov
18:29:21 <jaredj> ah
18:30:25 <dino-> I've been trying to .deb package some of my Haskell stuff and have come across things referencing dh_haskell. But I'm having trouble locating this dh_haskell debhelper to install.
18:30:34 <dino-> Anyone here know anything about acquiring dh_haskell?
18:32:07 <dino-> oo, after a lot of searching, I think I may have found where it lives: haskell-devscripts
18:33:13 <jaredj> lambdabot, dh_haskell is in haskell-devscripts
18:33:22 <jaredj> :E
18:33:42 <jaredj> @remember dh_haskell is in haskell-devscripts
18:33:42 <lambdabot> Done.
18:33:55 <jaredj> dh_haskell?
18:34:06 <jaredj> meh
18:34:59 <Lemmih> Isn't that a misuse of @remember?
18:35:26 <sorear> @quote devscripts
18:35:27 <lambdabot> dh_haskell says: is in haskell-devscripts
18:37:24 <falconair> sorear:  i'm trying to install Yi through macports (and hs-plugins a dependency) ... there doesn't seem to be a maintainer for macports hs-plugins ... any ideas how to resolve this?
18:38:06 <kc5tja_> How would an AST *not* count as an IR, when every compiler book in the known universe states that it is exactly that?
18:38:38 <sorear> falconair: afair, hs-plugins is not a dependency for any version of yi young enough to be worth trying to use
18:38:58 <sorear> falconair: the tarball is extremely obsolete
18:39:50 <falconair> the version on macports is 0.1.0 is that the old/obsolete one?
18:40:18 <sorear> they... packaged ... yi!?
18:40:22 <sorear> and yes
18:40:45 <dons> morning.
18:40:46 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
18:40:48 <sorear> but if you want to try anyway, you need ghc 6.4.2 -or- hs-plugins darcs
18:40:54 <sorear> hello
18:41:24 <falconair> sorear: ok, so ditch macports ... a few weeks ago i was told here that Yi wasn't really usable yet, i'm assuming the latest release is more usable?
18:42:26 <sorear> there's a thread on haskell{,-cafe} where the defacto maintainer is proposing a release candidate
18:42:30 <sorear> so I think 'yes'
18:43:01 <falconair> ok, i'l try building it manually then, thanks
18:43:24 <dons> sjanssen: see tumov's anti-xinerama thread on the ion dev list?
18:43:36 <dons> sjanssen: 'I will
18:43:37 <dons> have nothing to do with distributions that enable this module'
18:43:38 <dons> hehe
18:43:48 <jcreigh> hmm? What's his opinion of xinerama?
18:44:11 <jaredj> :d got a url?
18:44:19 * sorear would like one too
18:44:23 <dons> he's accepting a patch for it, but doesn't want to touch the code.
18:44:53 <jcreigh> a patch? but when I was using ion3, it had xinerama...
18:44:57 <sorear> @google url:pipermail tuomo xinerama
18:44:58 <lambdabot> No Result Found.
18:45:03 <sorear> :(
18:45:14 <jaredj> i can't find ion-dev, only ion-general
18:45:18 <sorear> @google tuomo xinerama
18:45:20 <lambdabot> http://www.mail-archive.com/ion-general@lists.berlios.de/msg01605.html
18:45:20 <lambdabot> Title: Re: Xinerama support
18:45:22 <dons> probably that then.
18:45:41 <jaredj> "Xnest is crap."
18:45:46 <falconair> sorear/dons: I'll be using the following command to get the latest and the greatest of Yi, correct?  darcs get http://www.cse.unsw.edu.au/~dons/yi
18:45:47 <lambdabot> Title: Index of /~dons/yi
18:47:37 <sorear> Tuomo's crazy ranting sounds just like Linus' ...
18:47:48 <foxy-om_> how do I get ghc to pass a dll to the linker?
18:48:27 <narain> ?pl \x -> f x x
18:48:28 <lambdabot> join f
18:48:46 <narain> hmm
18:48:59 <narain> is that idiomatic?
18:49:00 <ddarius> @pl \x -> us x x
18:49:01 <lambdabot> join us
18:49:05 <ddarius> narain: No.
18:49:24 <narain> ok
18:49:34 <kpreid> some people would disagree
18:49:45 <ddarius> kpreid: The crazy ones.
18:50:32 <milkcan> it's ok to be gay, let's rejoice with the boys, in the gay-way!
18:50:54 <vincenz> moin
18:51:51 <SamB> foxy-om_: maybe if you pass the DLL to GHC?
18:54:29 <narain> sweet,  deriving  works on custom type classes as well
18:55:42 <sorear> narain: only if ghc knows how.
18:55:50 <falconair> ok, so i'm attempting to install Yi on a macbook, what does yi-gtk get me over yi-vty?
18:56:13 <sorear> narain: h98 says you can only derive Ord, Eq, Show, Read, Ix, Enum, (am I forgetting any?)
18:56:30 <milkcan> http://www.kerrolisaa.com/i/1/3690.jpg
18:56:35 <milkcan> http://www.kerrolisaa.com/i/1/3690.jpg
18:56:53 <narain> sorear: huh. i had  instance SomeClass SomeType  and  newtype NewType = NewType SomeType  and i was able to use  deriving
18:56:55 <foxy-om_> SamB: If I do that I get multiple definitions of _onexit and atexit, but if I generate a libfoo.a using dlltool then I get "Internal Error: A primary message table for module 54 was already registered with a differing collection of error messages."
18:57:04 <sorear> narain: GHC also allows Data, and Typeable, and absolutely anything if the type is a newtype
18:57:14 <narain> ah, newtype
18:57:25 <sorear> narain: don't enable -fglasgow-exts.  it is evil and encourages nonportability.
18:57:36 <sorear> I wish ghc properly supported LANGUAGE :(
18:57:56 <narain> oh, i do have that at the top of my code, dang
18:58:16 <sorear> @botsnack
18:58:16 <lambdabot> :)
18:58:50 <narain> hmm, mptc + (ghc < 6.6) => -fglasgow-exts
18:59:08 <narain> well, i can just not use  deriving
18:59:29 <narain> but then i have to write the whole instance myself! is there no other way?
18:59:35 <sorear> narain: exactly - see above abot language brokenness.  GHC *should* just enable mptcs, but -fglasgow-exts is all-or-nothing internally
19:00:00 <sorear> there's also a bug with newtype deriving
19:00:12 <kpreid> sorear: there are newtypes you can't derive on :)
19:00:13 <sorear> but someone broke hackage.haskell.org/trac/ghc
19:00:30 <sorear> kpreid: but interestingly no such classes.
19:00:53 <sorear> kpreid: you can crash ghc by telling it to newtype derive specially constructed classes
19:01:10 <sorear> kpreid: but the bugtracker is down :(
19:01:15 <narain> so even if i upgraded to ghc 6.6 and just enabled mptcs using LANGUAGE, it would be the same as all of -fglasgow-exts?
19:01:20 <kpreid> oh, I see. "absolutely anything" meant classes
19:02:12 <sorear> narain: I suspect so. (haven't tried it.)
19:03:35 <sorear> I think I finally got the idea behind prolog.
19:04:12 <narain> well that's not my main concern right now... if i just want the "obvious" instance of the type class, do i have to write it all myself?
19:05:05 <ddarius> sorear: Say it.
19:05:25 <narain> sorear: prolog is fun but very cumbersome for things outside its particular domain
19:05:27 <ddarius> I'm suspecting that if you only "think" you do, you have a bit more to work on.
19:05:33 <SamB> isn't the idea behind prolog that you don't mind backtracking forever?
19:05:42 <ddarius> narain: Prolog is pretty hideous but it's handy to learn.
19:06:19 <ddarius> SamB: If only.
19:06:24 <sorear> ddarius: stateful backtracking with unification
19:06:54 <ddarius> sorear: What does that mean to you?
19:06:54 <jaredj> tuomov: "Or forget multihead. It's stupid anyway.
19:06:56 <jaredj> "
19:07:01 <narain> ddarius: well, i like the idea of logical variables that can be unified with each other
19:07:17 <ddarius> narain: Logical variables are very nice.
19:08:29 <ddarius> narain: Prolog for better or worse, is the archetypical logic language, and, as such, is a must-learn language.
19:08:56 <sorear> ddarius: when you have a function foo(X,X).  and you see foo(true,X), we enter foo, we tentatively unify the top level true with foo's X, then the top level's X with true's X == true.  then foo exits, and we see that top level X is unified with 'true', so we know that true satisfies the equations.
19:09:26 <narain> sorear: except foo is not a "function"
19:10:06 <narain> but yeah, pretty much
19:10:10 <sorear> My denotations have been tainted by the operational mechanism I invented.
19:10:24 <sorear> Before today, it was all unimplemenentable magic to me :)
19:10:28 * ddarius should make @prolog
19:10:42 <ddarius> I have all the code, just need to hook it into lambdabot.
19:11:17 <narain> ddarius: that would be very cool
19:11:23 * sorear writes a haskell interpreter of prolog (from first principles, I've never seen even a pseudocode impl!), and golfs it under the 500-char limit
19:11:32 <kpreid> sorear: for the purpose I think you had in mind, I like the name "subroutine"
19:11:48 <narain> the proper word is "predicate"
19:11:55 <ddarius> sorear: My first cut of a Prolog interpreter was 86 lines if I remember correctly.
19:11:57 <kpreid> or perhaps "component"
19:12:25 <ddarius> My current one is about 300 counting everything.
19:12:36 <sorear> pst! I'm trying to SHIELD myself from impl details.  You may tell me after I finish the Nano-Prolog interpreter.
19:13:22 <narain> denotationally, foo(true,X) means "is foo(true,X) satisfiable? (if so, find X)"
19:14:21 <SamB> sorear: the number of lines involved is an implementation detail?
19:15:04 <sorear> SamB: pipeline delay.  kpreid and narain's terminology dispute was threatening to give something away.
19:15:15 <ddarius> I haven't implemented list syntax though you can half fake it.
19:15:36 <kpreid> I do not dispute narain's statement!
19:15:39 <sorear> my system is going to be ultra-simplistic anyway.
19:15:39 <SamB> ddarius: I would avoid talking about that personally
19:15:51 <ddarius> The list syntax is annoying.
19:15:54 <kpreid> I was speaking of ...well, I'll explain later.
19:16:05 * jcreigh doesn't understand xinerama-hatred
19:16:40 <ddarius> sorear: A simple prolog interpreter in prolog is about like 5 lines of code.
19:16:46 <sorear> jcreigh: I'm beginning to see a pattern with finns being both (a) crazy (b) arch-hackers ;)
19:16:53 <jcreigh> sorear: heh
19:17:05 <narain> ?pl \x y -> con $ x * (decon y)
19:17:06 <lambdabot> (con .) . (. decon) . (*)
19:17:15 <narain> yeesh
19:17:28 <kpreid> ?pl \y x -> con $ x * (decon y)
19:17:28 <lambdabot> (con .) . (*) . decon
19:17:43 <SamB> sorear: has anyone ever heard of an arch-hacker who was *not* crazy?
19:17:53 <narain> kpreid: my type class won't let me do that
19:17:57 <kpreid> ?pl \y -> con $ x * (decon y)
19:17:58 <lambdabot> con . (x *) . decon
19:18:09 <narain> hey, that's better
19:18:12 <kc5tja_> ?pl \f -> 100 * ((f-32)/180)
19:18:13 <kpreid> \x -> con .. (x *) . decon
19:18:13 <lambdabot> (100 *) . (/ 180) . subtract 32
19:18:27 <jaredj> is linus secretly as extreme as this guy?
19:19:12 <jaredj> i mean i don't think he's all wrong, but my experience says it's hard to be obstinate about everything
19:19:16 <kpreid> narain: I looked at the expression and re-pointed the parameter in the middle of the expression, turning it into a simple pipeline again
19:19:56 <narain> kpreid: nice
19:20:09 <sorear> jaredj: google for linus torvalds on debuggers ... he is as crazy as they come
19:20:10 <narain> what's .. ?
19:20:14 <kpreid> a typo for .
19:20:30 <narain> oh :)
19:20:32 <kpreid> someone should write @optimize-between-pointless-and-pointful
19:21:01 <SamB> kpreid: which would send the code in question to haskell-cafe?
19:21:18 <kpreid> I dunno, I don't subscribe
19:21:18 <QtPlatypus> Only nonletters can be opoerators in haskell right?
19:21:49 <kpreid> directly, yes. you can write a `infix` b
19:22:00 <kpreid> > [1,2,3] `mplus` [4,5,6]
19:22:02 <lambdabot>  [1,2,3,4,5,6]
19:22:33 <narain> :t \f g x y -> f (g x) (g y)
19:22:34 <TomMD> > 1 `notElem` [2,3,4,0]
19:22:35 <lambdabot> forall t t1 t2. (t1 -> t1 -> t2) -> (t -> t1) -> t -> t -> t2
19:22:36 <lambdabot>  True
19:23:30 <kpreid> did ghc 6.6 provide that combinator?
19:23:51 <kpreid> I know it has (\g x y -> compare (g x) (g y)) as "comparing"
19:24:53 <narain> if it is i'd like to know
19:25:21 <jaredj> sorear: cool heh. although i'll say it's a much more endearing speech than any of tuomov's that i've read so far
19:26:39 <jaredj> it's aggravating to me that people are humoring tuomov in this xinerama thread
19:26:52 <SamB> humoring him about what?
19:27:08 <sorear> jaredj: forks are not a sure bet at all
19:27:13 <SamB> I'd humour him real good, if I had enough context and a good setup line ;-P
19:27:14 <ddarius> sorear: Lookup diff lists.
19:27:21 <sorear> jaredj: sometimes they half succeed
19:27:37 <sorear> ddarius: should I wait till after I finish nano-prolog?
19:28:23 <TomMD> Is frag in any major repositories (e.g. Yum, Apt, Emerge).
19:29:58 <ddarius> sorear: No.  Though having a Prolog implementation of some sort handy may be useful.
19:30:16 <jaredj> SamB: hahaha. no, he's all "xinerama sucks, multiple screens suck," and they're all, "how does this make you feel," instead of arguing with him.
19:30:30 <sorear> ddarius: fwiw, I'm quite familiar with ShowS
19:30:42 <ddarius> I'm talking about a Prolog thing.
19:30:58 <jaredj> sorear: yes, chopsticks are better. ? i think you're 1.4 hops ahead of me
19:31:27 <sorear> jaredj: huh?
19:31:42 <jaredj> you said, "forks are not a sure bet at all"
19:31:42 * ddarius agrees with jaredj.
19:31:46 * sorear doesn't even know how to use chopsticks, let alone appreciate them
19:31:53 <sorear> oh, right, haha
19:31:57 <jaredj> :)
19:31:58 <RyanT5000> is there a haskell -> java compiler?
19:32:04 <jaredj> hava?
19:32:08 <ddarius> sorear: If you can write with a pencil you pretty much have it.
19:32:25 <sorear> RyanT5000: jhc and yhc both have work-in-progress compilers
19:32:47 <Saizan> isn't there a haskell -> jvm bytecode compiler?
19:32:57 <narain> difference lists were one thing that certainly made me go "huh?" at first
19:33:05 <RyanT5000> (i'm thinking about making cell phone games)
19:33:09 <sorear> well, once you have jvm bytecode, you have java, and vice versa
19:33:58 <Saizan> ?google lambdavm
19:34:00 <lambdabot> http://www.cs.rit.edu/~bja8464/lambdavm/
19:34:01 <lambdabot> Title: LambdaVM - The Haskell to Java Translator
19:34:12 <RyanT5000> ok, now how about haskell -> flash?
19:34:21 <RyanT5000> and, if there is no such thing, is there interest?
19:34:33 <sorear> yes there is
19:34:39 <jaredj> http://www.mail-archive.com/ion-general@lists.berlios.de/msg01641.html
19:34:42 <lambdabot> Title: Re: Xinerama support, http://tinyurl.com/yphzup
19:34:46 <narain> is the flash bytecode well-specified even?
19:34:49 <sorear> index!?  Why can't Data.Sequence use !! or ! like everone else!
19:35:15 <jaredj> he spends the whole email whining and no one calls him on it!
19:35:36 <RyanT5000> sorear: interest or existance?
19:35:45 <sorear> interest at least
19:35:49 <sorear> @wiki Yhc/TMR
19:35:49 <lambdabot> http://www.haskell.org/haskellwiki/Yhc/TMR
19:36:03 <sorear> I think there's a mention of actionscript bytecode in there
19:40:53 <dmead> actually, there is haskell -> javascrip[t
19:41:37 <jcreigh> isn't javasript == ecmascript == actionscript?
19:41:46 <Philippa> only ~=
19:41:51 <dmead> their related
19:41:56 <jcreigh> ah
19:41:57 <dmead> it's on wikipedia
19:42:20 <dmead> emcascript is a spec or something and javascript is a child of it
19:42:21 <dmead> or something
19:43:06 <narain> ecmascript is what came out when a standards body tried to write a formal spec for javascript
19:43:14 <jaredj> dmead, jcreigh: ecmascript specifies the syntax but not the libraries
19:43:23 <jaredj> which makes the reference docs for it rather annoying
19:43:27 <jaredj> for my uses
19:43:30 <dmead> ah
19:43:37 <narain> jaredj: you mean the DOM?
19:43:42 <jaredj> yes
19:43:47 <jaredj> or whatever flash has
19:43:59 <jaredj> s/or/and
19:44:13 <narain> i dunno about flash, but the html dom is specified by the w3c
19:44:14 <dons> sorear: hmm, i think index is becoming more popular.
19:44:19 <dons> index and append.
19:44:30 <jaredj> narain: and all the browsers follow the spec
19:44:34 <jaredj> >:P
19:44:38 <sorear> Even ML has infix operators!
19:44:41 <dons> sorear: note Data.ByteString.index
19:44:51 <narain> since the dom is language-independent, it doesn't make sense for it to be in a javascript/ecmascript spec
19:44:59 <sorear> I was actually rather suprised I could define a >>=
19:45:06 <sorear> sure eased the transition ;)
19:45:13 <narain> jaredj: well we do not live in an ideal world :-P
19:45:34 <jaredj> narain: sorry, tuomov's mailing list posts are rubbing off on me :/
19:45:48 <chessguy> 'evening
19:45:59 <ddarius> sorear: Transition?!
19:46:02 <jcreigh> chessguy: hey, can your engine talk to xboard yet?
19:46:20 <chessguy> nah
19:47:03 <sorear> ddarius: ["Haskell"] -> ["Haskell", "(ca)ML"]
19:47:05 <dons> ddarius: 'regression' ;-)
19:47:19 <chessguy> jcreigh: it shouldn't be too hard though
19:47:32 <vincenz> dons: yes
19:47:38 <vincenz> sorear: definitely, I ent the other way
19:47:43 <sorear> dons: I hate to tell you this but - looking at the core there was essentially nothing for xavier to do differently.
19:47:43 <jcreigh> chessguy: well, let me know if you run into some weird broken pipe issues when you do. :)
19:47:44 <vincenz> sorear: ocaml doesn't offer much
19:47:55 <sorear> dons: it was cps-converted to oblivion
19:47:56 <chessguy> jcreigh: oh?
19:48:16 <narain> sorear: ML lets you mix alphanums and symbols in names, right? i forget
19:48:21 <chessguy> jcreigh: do you know about xboard --debug?
19:48:27 <sorear> narain: no, that's lisp
19:48:42 <sjanssen> dons: if xmonad had a mailing list I could be abusive like tuomov too :)
19:48:48 <jcreigh> chessguy: yeah. I have buffering turned off and everything, but xboard bombs out saying "broken pipe" after my second move. I can get around it by making a chess-wrapper.sh which *only* contains "./chess"
19:49:00 <jcreigh> (and then telling xboard to use chess-wrapper.sh)
19:49:12 <jcreigh> chessguy: yes, I found xboard -debug about 15 minutes ago...very handy. :)
19:49:16 <chessguy> how weird
19:49:27 <dons> sjanssen: woot! ok, i'll look into that today then.
19:49:52 <ddarius> sorear: What are you talking about?
19:50:01 <dmead> can we get xmonad on portage?
19:50:01 * dons feels like a bit of sunday afternoon xmonad hacking
19:50:01 <dmead> :P
19:50:10 <sjanssen> @localtime dons
19:50:13 <lambdabot> Local time for dons is Sun Apr  8 12:49:24 2007
19:50:15 <vincenz> @localtime vincenz
19:50:18 <lambdabot> Local time for vincenz is Sun Apr  8 04:49:30 2007
19:50:23 <jcreigh> yeah. I'm not too worried about it ATM. I'm focusing on making my engine recognize that leaving your king in check is illegal.
19:50:26 <ddarius> @localtime ddarius
19:50:26 <chessguy> ?time
19:50:27 <lambdabot> Local time for ddarius is Sat Apr 07 21:49:11
19:50:28 <lambdabot> Local time for chessguy is Sat Apr  7 22:46:39
19:50:35 <chessguy> jcreigh: :)
19:50:58 <chessguy> jcreigh: why bother?
19:51:01 <sorear> ddarius: my unlambda compiler
19:51:26 <sorear> ddarius: in a fit of something I retargeted it, it can compile via either GHC or ocamlopt
19:51:40 <ddarius> sorear: I meant with the remark about Xavier and cps-conversion.
19:51:42 <sorear> ddarius: the performance was the same ... unsuprising in retrospect
19:52:03 <sorear> ddarius: dons started talking yesterday about "Xavier =~ SPJ"
19:52:06 <dons> yeah, it would be a bug report if you couldn't get the same speed from both.
19:52:24 <sorear> ddarius: cps-conversion makes optimization way harder (or so I'm told)
19:52:40 <chessguy> jcreigh: seriously, i don't intend to do that
19:52:41 <jcreigh> chessguy: it's a feature I'm interested in. :)
19:52:57 <jcreigh> chessguy: wait. xboard or king-in-check?
19:53:05 <chessguy> king-in-check
19:53:07 <sorear> dons: that said I had to give -funfolding-use-threshold=1000 -funfolding-creation-threshold=1000 to get the same speed as ocamlopt no-options
19:53:17 <jcreigh> er...
19:53:25 <sorear> does ocamlopt have any quasi-documented go-faster options?
19:53:33 <jcreigh> how do you deal with that then?
19:53:41 <chessguy> let search deal with it
19:53:42 <dons> sorear: oh, that's interesting.
19:53:59 <sorear> dons: I only tried that and plain -O2. not much data. :)
19:54:29 <dons> did you read the core?
19:54:56 <jcreigh> chessguy: oh, skew your scoring function such that the engine would never pick a move that left the king in check?
19:55:29 <ddarius> sorear: Why is your unlambda interpreter cps converted anyways?
19:55:33 <chessguy> well sure, if the king worth enough, then the engine isn't going to pick that move for either side anyway
19:55:33 <sorear> dons: skimmed it.  8000 lines of stupid cps code.  that's what you get for using cont io
19:55:39 * ddarius really needs to clean his keyboard.
19:56:02 <chessguy> and if your quiescence works correctly, that will always be tested
19:56:09 <sorear> ddarius: (a) it's a compiler (b) it generates cps because unlambda has native call/cc and haskell/ocaml don't
19:56:27 <sorear> or rather, it generates code using a Cont monad
19:56:29 <jcreigh> if my *what* works correctly?
19:56:37 <chessguy> uh
19:56:45 <chessguy> you don't have quiescence search?
19:57:02 <ddarius> Yeah, I remembered the call/cc after I asked.
19:57:26 <jcreigh> um...what's that?
19:57:38 <chessguy> ermm, ok. have you heard of the horizon effect?
19:57:57 <jcreigh> um...what's that? (sorry, but I seriously have never done anything like this before.)
19:58:12 <chessguy> heh
19:58:19 <jcreigh> I have staticEval :: Board -> Double that gives you a score for the board without trying to look into the future.
19:58:19 <stepcut> RyanT5000: I have a yhc -> actionscript bytecode compiler in the works
19:58:26 <chessguy> right, ok
19:58:41 <jcreigh> I have eval :: Int -> Board -> Double that tries to score the board looking n halfmoves into the future.
19:59:12 <chessguy> here's the problem: suppose the last move you search is pawn takes knight
19:59:21 <chessguy> now you do a static eval
19:59:26 <chessguy> you're up a knight
19:59:36 <jcreigh> ...but my queen is exposed?
19:59:36 <chessguy> this position looks great for you
19:59:40 <chessguy> bingo :)
19:59:49 <jcreigh> I see
19:59:58 <dmead> parsing strings is hard =/
20:00:01 <chessguy> this is the horizon effect: there's some move that's just over the 'horizon' of your search
20:00:16 <ddarius> dmead: It depends on the information you want to get out of them.
20:00:49 <chessguy> so the idea is that instead of eval just doing a static eval, it calls qsearch, which is your quiescent search, which looks for things like that, essentially finding 'quiet' positions to take the static eval from
20:01:01 <chessguy> http://www.seanet.com/~brucemo/topics/quiescent.htm
20:01:03 <lambdabot> Title: Quiescent Search
20:02:45 <narain> is the correct syntax  foo a@(a1,a2)  or  foo (a1,a2)@a ?
20:02:56 <jcreigh> so basically, instead of just doing some static evaluate when you hit your depth limit, you run a little function that says "Okay, have I overlooking anything bloodly obvious here?"
20:02:56 <chessguy> a@(a1,a2)
20:03:03 <narain> thanks
20:03:12 <chessguy> jcreigh: right, it basically looks at captures
20:03:24 <dons> Igloo: around?
20:03:44 <chessguy> jcreigh: it typically does a little a-b searching of its own
20:03:53 <dmead> ddarius: i want to call type constructors from tokens in strings
20:04:05 <dons> sjanssen: btw, do you use 'unclutter' to hide the mouse cursor?
20:04:21 <chessguy> (and in some cases can actually call the main search function with a limited depth, which makes for some fun mutual recursion problems)
20:04:32 <narain> ?hoogle Bool -> Bool -> Bool
20:04:33 <lambdabot> Prelude.(&&) :: Bool -> Bool -> Bool
20:04:33 <lambdabot> Prelude.(||) :: Bool -> Bool -> Bool
20:05:19 <dons> sjanssen: so i'm attempting to create the xmonad@haskell.org list now, but need to find a mailman passwd first.
20:05:22 <dons> stay tuned.
20:05:41 <ddarius> dmead: Okay...
20:05:42 <sjanssen> dons: no, I've never heard of unclutter
20:05:48 <dons> ah, you should use it!
20:05:55 <dons> it hides the cursor after 'N' seconds.
20:05:56 <narain> > map ($ 4.2) [floor, ceil]
20:05:58 <lambdabot>   Not in scope: `ceil'
20:06:00 <narain> > map ($ 4.2) [floor, ceiling]
20:06:02 <lambdabot>  [4,5]
20:06:09 <dons> so the first line of my .xsession is       unclutter -idle 1 &
20:06:59 <dons> ?google unclutter x11
20:07:01 <lambdabot> http://www.ibiblio.org/pub/X11/contrib/utilities/unclutter-8.README
20:07:11 <dons> hey stepcut
20:07:15 <stepcut> hello
20:07:52 * dons feels vaguely alive again, for the first time in a week. 
20:07:59 <dons> paper writing is draining..
20:08:06 <ddarius> floor *** ceiling $ 43
20:08:10 <sjanssen> dons: hmm, that seems handy
20:08:12 <dons> sjanssen: you can get unclutter from ftp://ftp.x.org/contrib/
20:08:16 <ddarius> > floor *** ceiling $ 4.2
20:08:17 <lambdabot>   add an instance declaration for (Fractional (b, b'))
20:08:27 <ddarius> > floor &&& ceiling $ 4.2
20:08:29 <lambdabot>  (4,5)
20:08:30 <dons> sjanssen: yeah, there might be some other "no mouse" utils we can recommend
20:09:02 <dons> e.g. xpmroot to set a bg image., maybe xmodmap -e "keysym Caps_Lock = Control_L"
20:09:05 <narain> ddarius: hmm, having the functions before the value is good, i could use that
20:09:46 <vincenz> .j nethack
20:10:30 <narain> ?hoogle (a -> b
20:10:31 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
20:10:31 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
20:10:31 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
20:10:45 <narain> ?hoogle (a -> b) -> (a -> c) -> a -> (b,c)
20:10:46 <lambdabot> No matches, try a more general search
20:10:53 <narain> :t (&&&)
20:10:56 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
20:11:24 <chessguy> jcreigh: make any sense?
20:11:25 <narain> ah, hoogle doesn't know instance Arrow (->)
20:11:35 <jcreigh> chessguy: yeah.
20:12:46 * SamB_XP discovers that if he enables "automatic thread priority control" in nestopia, it is best if he disables emulation in the background
20:13:11 * ddarius says, "It's one way of the isomorphism characterizing the adjunction defining pairs." all bright-eyed and chirpily.
20:13:46 <jcreigh> eval 0 b = staticEval b
20:13:46 <jcreigh> eval n b = negate . minimum . map (eval (n-1) . move b) $ moves b
20:13:51 <jcreigh> ^^ is that minimax?
20:14:00 <jcreigh> staticEval has the property that positive == good
20:15:03 <chessguy> hmmm
20:15:40 <ddarius> sorear: My semi-port of HaXml/HXT/etc. to C# should be something like ParseLazy.
20:15:42 <chessguy> i would try that out on a few simple trees with eval = id
20:16:07 <chessguy> a few Tree Int s that is
20:16:16 <jcreigh> oh, good idea
20:16:38 <chessguy> moves = subForest, or whatever that field label is
20:17:50 <chessguy> oh, eval = rootLabel, that's better yet
20:18:54 <ddarius> @pl \f g -> f &&& g >>> fst *** snd
20:18:55 <lambdabot> flip flip snd . ((***) .) . flip flip fst . ((>>>) .) . (&&&)
20:19:42 <chessguy> i have this code sitting around (untested)
20:19:43 <chessguy> minimax :: Tree Int -> Int
20:19:43 <chessguy> minimax (Node pos [])   = pos
20:19:43 <chessguy> minimax (Node pos kids) = maximum $ map (negate . minimax) kids
20:20:06 <ddarius> @src Arbitrary
20:20:07 <lambdabot> Source not found. I've seen penguins that can type better than that.
20:20:21 <chessguy> ?hoogle Arbitrary
20:20:22 <lambdabot> Test.QuickCheck.Arbitrary :: class Arbitrary a
20:20:22 <lambdabot> Test.QuickCheck.arbitrary :: Arbitrary a => Gen a
20:20:22 <lambdabot> Test.QuickCheck.coarbitrary :: Arbitrary a => a -> Gen b -> Gen b
20:20:26 <narain> ddarius: fst *** snd == id?
20:20:45 <narain> ddarius: also, the precedence confuses me in that sample
20:21:34 <ddarius> :t fst *** snd
20:21:37 <lambdabot> forall a b a1 b1. ((a, b), (a1, b1)) -> (a, b1)
20:21:49 <ddarius> fst &&& snd == id
20:22:01 <narain> ah
20:22:08 <ddarius> As for the precedence, I assume it's the sensible one.
20:22:47 <narain> would that be ((f &&& g) >>> fst) *** snd)?
20:23:37 <ddarius> No, (f &&& g) >>> (fst *** snd), but I was presuming, I could be wrong.
20:24:09 <narain> :t ?f &&& ?g >>> fst *** snd
20:24:12 <lambdabot> forall b a b1 a1 b2. (?f::b -> (a, b1), ?g::b -> (a1, b2)) => b -> (a, b2)
20:24:39 <narain> you're right
20:24:59 <ddarius> (fst,snd) is (kind of) the counit of the adjunctions defining pairs (the unit is id &&& id)
20:25:09 <chessguy> 'night all
20:26:03 * narain stares blankly
20:30:24 <ddarius> The adjunction defining pairs, as important as it is, is somewhat underwhelming in that it defines pairs in terms of pairs.  At least it defines all pairs in terms of pairs in either Cat or Set.
20:32:48 * narain stares blankly at the word "adjunction"
20:33:08 <ddarius> @google adjunction "category theory"
20:33:10 <lambdabot> http://en.wikipedia.org/wiki/Monad_(category_theory)
20:33:10 <lambdabot> Title: Monad (category theory) - Wikipedia, the free encyclopedia
20:33:17 <ddarius> Bloody wikipedia.
20:33:25 <narain> i'm not even up on basic category theory
20:33:30 <ddarius> Not that I knew what that -would- return.
20:35:09 <narain> ?quote category
20:35:10 <lambdabot> ChilliX says: You need to seek a balance between category theory and VLSI
20:35:50 <narain> haha, i often feel the same way
20:36:37 * ddarius wonders what the context of that quote was.
20:37:25 * narain guesses someone working in VLSI became enamoured with haskell and expressed the desire to quit his day job
20:37:46 <Philippa> narain: we can tell, because adjunctions /are/ basic CT :-)
20:38:19 <Philippa> no, VLSI's about as low-level as you can get while still doing something that looks at all like software
20:38:46 <Philippa> (because these days it's designed with languages that aren't unakin to programming languages)
20:39:19 <Philippa> otherwise he would've said quantum mechanics or string theory
20:39:41 <narain> sigh... that means i don't identify with the quote after all
20:40:23 <Philippa> well, haskell's not as abstract as category theory if that helps any?
20:40:44 <Philippa> it's pretty hard to get more abstract than CT and still mean anything, mind
20:42:58 <ddarius> That 0x88 thing is pretty slick.
20:43:00 <narain> ?src join
20:43:01 <lambdabot> join x =  x >>= id
20:48:35 <foxy-om_> if I import System.IO (IOMode(..)) in my module what is the syntax to re-export IOMode(..) in my module Foo ( -- put it here ) where ?
20:56:53 * narain is writing a horribly unoptimized collision detection routine, in the interests of elegance
20:58:58 <Cale> 
20:59:47 <stepcut> ()
21:01:10 * ddarius just realized these little boxes that X-Chat writes when it can't display unicode characters contain information.
21:01:37 <Cale> They contain the unicode index of the character which you have no font for.
21:02:03 <ddarius> Indeed.  I just never even recognized the markings as numbers/letters.
21:02:28 <ddarius> I just thought it was some crazy box with scratch marks on it.
21:03:59 <Cale> They're especially hard to make out if your fonts aren't antialiased.
21:04:52 <narain> \f g -> f x && g x
21:04:54 <narain> ?pl \f g -> f x && g x
21:04:55 <lambdabot> (. ($ x)) . (&&) . ($ x)
21:05:16 <narain> :t liftM2 (&&)
21:05:19 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
21:05:45 <narain> :t liftM2 (&&) (<1) (>-1)
21:05:47 <lambdabot> Not in scope: `>-'
21:05:52 <narain> :t liftM2 (&&) (< 1) (> -1)
21:05:55 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
21:06:20 <narain> > map (liftM2 (&&) (< 1) (> -1)) [-2..2]
21:06:22 <lambdabot>  [False,False,True,False,False]
21:06:26 <narain> neat
21:07:14 <sorear> @index lexeme
21:07:15 <lambdabot> Text.ParserCombinators.Parsec.Token
21:07:25 <ddarius> narain: It's using an instance that's often referred to as the Environment monad.  It's somewhat akin to lexical scoping.
21:07:35 <sorear> @hoogle ReadS [Char]
21:07:36 <lambdabot> No matches, try a more general search
21:07:43 <Cale> Or reader monad.
21:07:45 <sorear> @hoogle [Char] -> [(Char, [Char])]
21:07:46 <lambdabot> No matches, try a more general search
21:07:57 <narain> ddarius: i thought it was using the function monad?
21:08:03 <Cale> yes, that's what it is
21:08:03 * ddarius finds "Environment" far more evocative.
21:08:42 <narain> ?instances Monad
21:08:44 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
21:09:42 <narain> ddarius: are you talking about my  liftM2 (&&) (< 1) (> -1) ?
21:10:08 <ddarius> Well, that instantiation of liftM altogether.
21:10:49 <narain> isn't that using the ((->) r) instance of Monad?
21:11:12 <ddarius> Yes, and that is referred to as the Environment or Reader monad.
21:11:17 <ddarius> @src Reader
21:11:17 <lambdabot> Source not found. I've seen penguins that can type better than that.
21:11:27 <ddarius> @src Control.Monad.Reader.Reader
21:11:27 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
21:11:35 <narain> oh, i didn't know that
21:12:23 <ddarius> @index Reader
21:12:23 <lambdabot> Control.Monad.Reader, Control.Monad.RWS, Control.Monad.Reader, Control.Monad.RWS
21:12:42 <ddarius> Uh... okay.
21:12:54 <ddarius> @src ReaderT
21:12:55 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
21:13:03 <ddarius> @src Control.Monad.Reader.ReaderT
21:13:03 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
21:13:06 <narain> ?docs Control.Monad.Reader
21:13:06 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Reader.html
21:13:30 <procyon112> @seen chessguy
21:13:30 <lambdabot> I saw chessguy leaving #haskell, #ghc and #haskell-overflow 48m 13s ago, and .
21:14:16 <narain> "Control.Monad.Reader. Description: Declaration of the Monoid class,and instances for list and functions"
21:14:19 <narain> bug?
21:14:36 <monochrom> Oh ha, surely.
21:15:38 <narain> should i report it somewhere?
21:19:57 <Cpudan80> Hello all
21:20:11 <Cpudan80> I am looking for a quickie script to output all the permutations of a set of 5 digits
21:20:20 <Cpudan80> someone in #math mentioned haskell...
21:20:27 <Cpudan80> I thought I would give you guys a shot...
21:20:34 <foxy-om_> @hoogle permute
21:20:34 <lambdabot> Text.ParserCombinators.Parsec.Perm.permute :: PermParser tok st a -> GenParser tok st a
21:20:35 <lambdabot> Distribution.GetOpt.Permute :: ArgOrder a
21:20:36 <sorear> @where polyparse
21:20:36 <lambdabot> http://www.cs.york.ac.uk/fp/polyparse
21:20:42 <sorear> Cpudan80: hello!
21:20:59 <Cpudan80> sorear: ehh - what does that actually mean?
21:21:10 <Cpudan80> hello btw
21:21:21 <sorear> Cpudan80: not much, we asked for permute and it told us about a parsing function
21:22:16 <dons> oh wow.
21:22:16 <Cpudan80> so... is it possible?
21:22:19 <dons> stepcut++
21:22:20 <dons> I would like to take this opportunity to announce the availability of
21:22:20 <dons> an Adobe Shockwave Flash (SWF) library for Haskell:
21:22:20 <dons> darcs get http://www.n-heptane.com/nhlab/repos/haskell-swf/
21:22:22 <lambdabot> Title: Index of /nhlab/repos/haskell-swf
21:22:47 <sorear> > let { insert x [] = [[x]] ; insert x (a:as) = (x:a:as) : (a:insert x as) ; permute x = foldr (=<<) [""] (map insert x) } in permute ['1' .. '5']
21:22:48 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
21:22:48 <lambdabot>       Expected...
21:22:50 <ddarius> @google Haskell permutations interleave
21:22:52 <lambdabot> http://www.kuro5hin.org/story/2002/4/3/12145/97125
21:22:52 <lambdabot> Title: Programming Fun Challenge (1) Results || kuro5hin.org
21:23:22 <sorear> > let { insert x [] = [[x]] ; insert x (a:as) = (x:a:as) : (a:insert x as) ; permute [] = [[]] ; permute (x:xs) = permute xs >>= insert x } in permute ['1' .. '5']
21:23:22 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
21:23:23 <lambdabot>       Expected...
21:23:28 <stepcut> dons: :p
21:23:36 <monochrom> I'm speechless.  Now we're going to be able to read other people's cookies using Haskell!
21:23:46 <dons> ?where+ haskell-swf darcs get http://www.n-heptane.com/nhlab/repos/haskell-swf/
21:23:47 <lambdabot> Done.
21:23:54 <dons> stepcut: perhaps you should get a tarball on to hackage?
21:23:58 <dons> do you have a hackage account?
21:24:01 <stepcut> dons: yes
21:24:06 <sorear> > let { insert x [] = [[x]] ; insert x (a:as) = (x:a:as) : map (a:) (insert x as) ; permute [] = [[]] ; permute (x:xs) = permute xs >>= insert x } in permute ['1' .. '5']
21:24:08 <lambdabot>  ["12345","21345","23145","23415","23451","13245","31245","32145","32415","32...
21:24:15 <Cpudan80> hooray
21:24:17 <Cpudan80> thanks
21:24:36 <sorear> There is probably a shorter way.  there always is.
21:24:40 <stepcut> dons: I need to updated the .cabal file first
21:25:21 <stepcut> dons: and remove the SchemeCompiler.hs file which does not even belong in that library :p
21:25:25 <narain> > > let { insert x [] = [[x]] ; insert x (a:as) = (x:a:as) : map (a:) (insert x as) ; permute [] = [[]] ; permute (x:xs) = permute xs >>= insert x } in length $ permute ['1' .. '5']
21:25:26 <lambdabot>  Parse error
21:25:29 <narain> > let { insert x [] = [[x]] ; insert x (a:as) = (x:a:as) : map (a:) (insert x as) ; permute [] = [[]] ; permute (x:xs) = permute xs >>= insert x } in length $ permute ['1' .. '5']
21:25:30 <lambdabot>  120
21:25:32 <sorear> > nubBy(((>1).).gcd)[2..]  -- nice example of obfuscated one-liner
21:25:34 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
21:26:04 <narain> ok, it passes the sanity check
21:26:33 <narain> (i hope you don't mind, sorear)
21:27:03 <narain> oh wait. what was i doing sanity checking sorear's code?
21:27:32 <narain> ?slap narain
21:27:32 * lambdabot slaps narain
21:28:22 <sorear> you'll notice nowhere do I say how many to compute.  the list is simply infinite.
21:28:49 <foxy-om_> sorear++ -- best definition of primes that I've seen
21:29:09 <narain> ?where join
21:29:10 <lambdabot> I know nothing about join.
21:29:16 <narain> ?hoogle join
21:29:16 <lambdabot> Monad.join :: Monad a => a (a b) -> a b
21:29:17 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
21:29:17 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
21:29:38 <sorear> right now I have a nano-prolog interpreter that I'm sure is perfectly correct and a nano-prolog parser that simply refuses to terminate ;)
21:30:11 <narain> sorear: on any input at all?
21:30:18 <monochrom> It will give correct results when it terminates.
21:30:39 * sorear punts, derives read
21:30:47 <narain> monochrom: writing correct programs just became a whole lot easier
21:31:11 <monochrom> thanks to lazy evaluation!
21:33:53 <Cpudan80> sorear: I tried to copy your code to a file and run it in hugs - but it doesn't like the keyword let -- was that just for the bot?
21:34:45 <sorear> Cpudan80: the bot evaluates expressions, hugs wants a complete program
21:35:04 <Cpudan80> hrm.....
21:35:06 <sorear> you could write 'main = print (<expression from above>)'
21:35:31 <Cpudan80> so just do main = print(insert x.......) ?
21:35:49 <sorear> no, main = print (let { ... } in ...)
21:36:02 <Cpudan80> ok
21:36:03 <sorear> or expand out the let to top level:
21:36:23 <sorear> @pretty insert x [] = [[x]] ; insert x (a:as) = (x:a:as) : map (a:) (insert x as) ; permute [] = [[]] ; permute (x:xs) = permute xs >>= insert x ; main = print (permute ['1' .. '5'])
21:36:24 <lambdabot>  insert x [] = [[x]]
21:36:24 <lambdabot>  insert x (a : as) = (x : a : as) : map (a :) (insert x as)
21:36:24 <lambdabot>  permute [] = [[]]
21:36:24 <lambdabot>  permute (x : xs) = permute xs >>= insert x
21:36:24 <lambdabot>  main = print (permute ['1' .. '5'])
21:36:54 <LoganCapaldo> woah
21:37:04 <LoganCapaldo> @pretty impressive
21:37:04 <lambdabot> "Parse error" at column 11
21:37:05 <sorear> you may need to rename insert
21:37:13 <sorear> @help pretty
21:37:14 <lambdabot> pretty <expr>. Display haskell code in a pretty-printed manner
21:37:24 <dino-> dons: I had sent you some emails about changes I have for mkcabal. But the good fix darcs patch, not yet sent.
21:37:52 <phoniq> ?quote lamprey
21:37:52 <lambdabot> cypherx says: Oh god, C++ is like a lamprey in my urethra.
21:37:53 <LoganCapaldo> it should use hpaste for more then N lines
21:37:53 <sorear> @. pretty . unpl pl \a b c d e f g -> g f f d b a c
21:37:55 <lambdabot> "Parse error" at column -17
21:38:03 <sorear> @. unpl pl \a b c d e f g -> g f f d b a c
21:38:05 <lambdabot> (\ bd ch ck cn _ i l -> ((\ ay az -> az ay) >>= \ au av aw -> au aw av) i l cn ch bd ck)
21:38:51 <Cpudan80> sorear: no ;s in haskell?
21:38:57 <Cpudan80> that shouls be ; s
21:38:58 <dons> dino-: so should i wait for the final page?
21:38:59 <sorear> ;s ?
21:39:00 <dons> patch?
21:39:05 <Cpudan80> sorear: semicolons
21:39:07 <dino-> dons: Yeah, that one I sent you is bogus.
21:39:12 <Cpudan80>  ; <------ those things
21:39:13 <dino-> Delete it
21:39:15 <narain> whoever sat and figured out how to make  unpl . pl  say "bad chicken" gets my ++
21:39:19 <sorear> i know
21:39:29 <dino-> I can send the good one.. now?
21:39:29 <LoganCapaldo> @. unpl pl
21:39:30 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}: Parse error
21:39:39 <sorear> Cpudan80: haskell has a 'layout rule' that allows you to omit semicolons when things line up
21:39:54 <Cpudan80> ah ok
21:39:55 <sorear> Cpudan80: so you can write it like Python, or like perl, your choice
21:40:08 <Cpudan80> sorear: Ive written it once before - but that was a while back
21:40:37 <narain> ?. unpl pl \a b c -> b c a
21:40:38 <lambdabot> (\ b c f -> c f b)
21:40:44 <narain> ?. unpl pl \a b c d -> b c a d
21:40:45 <lambdabot> (\ b c f -> c f b)
21:40:52 <narain> ?. unpl pl \a b c d -> b c d a
21:40:52 <lambdabot> (\ b c f i -> c f i b)
21:41:58 <dino-> dons: Ok, the single, good patch is sent.
21:42:06 <narain> sorear: any idea whose idea the -> g f f d b a c was?
21:42:07 <sorear> yow.
21:42:34 <sorear> narain: not off hand ..
21:42:42 <sorear> oh, bd ch ck!
21:42:45 <sorear> hahaha
21:42:51 <sorear> didn't notice :)
21:42:56 <sorear> I can claim discovery.
21:43:07 <sorear> accidental
21:43:22 <sorear> I was trying to imitate *reads logs*
21:44:10 <narain> one can also read the subsequent "cn" as resembling "en"
21:44:45 <sorear> /var/cache/stefan-downloads/irclogs/www.cse.unsw.edu.au/06.12.23:22:09:56 <nmessenger> @pl \a b c d e f g h i j k l m n o p q s t u v w x y z r -> (r (t h i s i s a f i x e d p o i n t c o m b i n a t o r))
21:44:51 <sorear> @pl \a b c d e f g h i j k l m n o p q s t u v w x y z r -> (r (t h i s i s a f i x e d p o i n t c o m b i n a t o r))
21:44:55 <lambdabot> (((((const .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((((((const .) .) .) .) .) .) .) .) .) .) .) . (((((((((((
21:44:55 <lambdabot> ((const .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((const .) .) .) .
21:44:55 <lambdabot> ) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((ap id .) .) .) .) .) .) .) .) .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .)
21:44:55 <lambdabot> . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . (((((((((ap .) .) .) .)
21:44:57 <lambdabot>  .) .) .) .) .) . ((((((((((flip .) .) .) .) .) .) .) .) .) .) . (((((((((((flip .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((flip .) .) .) .
21:45:00 <lambdabot> [24 @more lines]
21:45:02 <lambdabot> optimization suspended, use @pl-resume to continue.
21:45:16 <narain> ...
21:46:23 <sorear> ddarius: nano-prolog works, to the extent I can tolerate using it ;)  deriving Read sucks as an input notation
21:46:36 <foxy-om_> dons: to implement storable for a type do I have to write ffi code?  (I have complex numbers that are two contiguous doubles pointed to by Ptr ()
21:46:37 <narain> wait, iirc the fixed point combinator is Y = (L L L L L L L L L L L L L L L L L L L L L L L L L L)
21:46:47 <narain> where L = \a b c d ...
21:47:08 <sorear> foxy-om_: to implement storable you need the ffi
21:47:10 <sjanssen> foxy-om_: probably not, the Foreign.* modules should have everything you need
21:47:22 <sorear> if for no other reason than Storable is exported by the ffi
21:47:58 <sorear> foxy-om: so, you want to implement derive support for Storable? :)
21:47:59 <narain> @pl let L = \a b c d e f g h i j k l m n o p q s t u v w x y z r -> (r (t h i s i s a f i x e d p o i n t c o m b i n a t o r)) in (L L L L L L L L L L L L L L L L L L L L L L L L L L)
21:48:03 <lambdabot> ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap id id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id)
21:48:03 <lambdabot> id (fix (const ((((((const .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((((((const .) .) .) .) .) .) .) .) .) .)
21:48:03 <lambdabot> .) . (((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((
21:48:03 <lambdabot> const .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((ap id .) .) .) .) .) .) .) .) .) .) .) .) .) .) . flip (flip . (flip .)
21:48:05 <lambdabot>  . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . (((((((
21:48:08 <lambdabot> [25 @more lines]
21:48:11 <lambdabot> optimization suspended, use @pl-resume to continue.
21:48:18 <narain> um. excuse me for that.
21:48:27 <foxy-om> sorear: not if I don't have to :P
21:50:08 <foxy-om> lambdabot's ignoring me (in a /query) is there a sensible reason for this?
21:50:39 <sjanssen> @botsnack
21:50:39 <lambdabot> :)
21:50:40 <narain> sorear: the basic prolog grammar is pretty simple, iirc
21:50:49 <sjanssen> foxy-om: is your nick registered?
21:50:56 <foxy-om> yup
21:51:22 <narain> sjanssen: that wouldn't be a problem anyway, i used to /msg lambdabot all the time before i was registered
21:51:24 <foxy-om> it was working until I said > nubBy(((>1).).gcd)[2..] twice
21:51:37 <sorear> @activity-full 90
21:51:38 <lambdabot> 1*total 1*#haskell
21:51:44 <sorear> @activity-full 100
21:51:45 <lambdabot> 2*total 2*#haskell
21:51:49 <sorear> @activity-full 600
21:51:49 <lambdabot> 64*total 64*#haskell
21:51:58 <narain> ?help activity-full
21:51:58 <lambdabot> activity seconds. Find out where/how much the bot is being used
21:52:08 <sorear> in the last ten minutes lambdabot has never tried to send anything to you, foxy-om
21:52:29 <dons> hands up if you like reading Haskell papers?
21:52:34 <sorear> activity == activity-full, except that activity masks the user names of users
21:52:42 <thetallguy> heh
21:52:44 <sorear> shows them as PRIVATE
21:52:51 * foxy-om raises hands
21:52:55 * sjanssen raises his hand
21:53:00 <sorear> activity-full is restricted to admins
21:53:05 <dons> well then, happy easter eggs to all:  http://www.cse.unsw.edu.au/~dons/streams.html
21:53:05 <lambdabot> Title: Data.List.Stream
21:53:12 * thetallguy smells a rat
21:53:13 * sorear feigns hand-raising (rather easy in IRC
21:53:25 <dons> and also,  http://www.cse.unsw.edu.au/~dons/polymer.html
21:53:26 <lambdabot> Title: polysim
21:53:27 <dons> :-)
21:53:40 <sorear> thetallguy: I wrote that plugin :)
21:54:36 <thetallguy> the rat plugin?
21:54:52 <sorear> yeah *muahaha*
21:55:37 <foxy-om> dons: have you let dcoutts out to see the sights yet?
21:56:29 <dons> yeah, he went to the easter show I think.
21:56:31 <dino-> dons: That last send, that's the REAL patch.
21:56:38 <dons> dino-: ok. cheers.
21:57:06 <foxy-om> did you hear Bangledesh beat SA by ~70 runs!!!
21:57:16 <dons> crazy stuff.
21:57:30 <dons> but the one day world cup always has weird results
21:57:49 <foxy-om> aus still have to be the favourites... :(
21:57:52 <monochrom> Haha, "this project is known as ticket 915"
21:58:01 <dcoutts> @yarr!
21:58:02 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
21:58:32 <foxy-om> dcoutts: did you see my message to cabal-devel, c2hs ?
21:58:58 <dcoutts> foxy-om: the patch you sent the other day you mean ?
21:59:25 <foxy-om> no, I've had subsequent problems and sent a small cabal package to demonstrate
21:59:32 <dcoutts> oh ok
22:01:41 <sorear> Yay.  Switching from ReadS to Parsec made my parser 4x shorter, and terminating to boot.
22:02:37 <monochrom> Next you'll switch to ReadP and get it 4x faster too.
22:03:04 <sorear> nano-prolog is ~180 lines atm
22:03:15 <monochrom> Then use readPtoS and get it ReadS again, no change.
22:03:37 <monochrom> Then you can repeat the cycle to get another 4x speedup.
22:04:25 <Cale> monochrom: heh
22:04:40 <sorear> nanoprolog: + add zero 'y 'y =
22:04:40 <sorear> nanoprolog: + add (succ 'x) 'y (succ 'z) = add 'x 'y 'z
22:04:40 <sorear> nanoprolog: ! add (succ zero) (succ zero) 'x
22:04:40 <sorear> add (succ zero) (succ zero) (succ (succ zero))
22:05:00 <LoganCapaldo> fix (ReadS to Parsec to ReadP to ReadS)
22:05:06 <sorear> nanoprolog: ! add 'x (succ zero) (succ (succ (succ zero)))
22:05:06 <sorear> add (succ (succ zero)) (succ zero) (succ (succ (succ zero)))
22:05:48 <sorear> I suppose '-notation is taboo here.  Oh well.
22:06:22 <LoganCapaldo> > 'x = "Valid?
22:06:23 <lambdabot>  Improperly terminated character constant
22:06:26 <LoganCapaldo> > 'x = "Valid?"
22:06:27 <lambdabot>  Improperly terminated character constant
22:06:31 <LoganCapaldo> guess not
22:07:32 <LoganCapaldo> > let 'x = "Valid?" in 'x
22:07:33 <lambdabot>  Improperly terminated character constant
22:07:37 <LoganCapaldo> ok
22:07:44 <LoganCapaldo> now I'm sure :)
22:08:46 <Cale> > 'Improperly terminated character constant
22:08:46 <lambdabot>  Improperly terminated character constant
22:09:08 <Cale> I wonder if there's a proper error message quine.
22:09:18 <sorear> >  Improperly terminated character constant
22:09:19 <lambdabot>   Not in scope: `constant'
22:09:29 <sorear> >  Not in scope: `constant'
22:09:30 <lambdabot>  Parse error
22:09:36 <sorear> >  Parse error
22:09:37 <lambdabot>   Not in scope: data constructor `Parse'
22:09:45 <sorear> >  Not in scope: data constructor `Parse'
22:09:46 <lambdabot>  Parse error
22:10:03 <sorear> there's an order-2 kimian
22:10:13 <ddarius> sorear: I have a seems-to-work Parsec parser for Prolog.
22:10:32 <monochrom> > putStr "<IO ()>"
22:10:33 <lambdabot>  <IO ()>
22:10:43 <sorear> yeah ... well ... my prolog is CURRIED! :)
22:11:01 <Cale> monochrom: haha
22:11:46 <sjanssen> oh noes!
22:12:24 <sorear> I must say, this is impressive.
22:12:46 <sorear> drat, it can't solve "mul 'x 'x (succ zero)"
22:13:04 <sorear> probably just have my equations in the wrong order ;)
22:13:24 <ddarius> Stupid SLD resolution
22:13:50 <sorear> can a properly implemented prolog handle that eq?
22:14:05 <ddarius> Which?
22:14:17 <sorear> mul 'x 'x (succ zero)
22:14:33 <sorear> which is probably spelled differently in prolog
22:14:40 <ddarius> Yes, that's no problem.
22:14:52 <ddarius> mul(X,X,succ(zero)).
22:15:51 <ddarius> SLD resolution just leads to the order of the clauses mattering
22:17:12 <aFlag> hello, I want to print each integer I have on a list as 4 bytes on big-endian format. So the integer 0xff would become the string "\0\0\0\255". Are there any functions that do something like that?
22:17:33 <sorear> add(zero,Y,Y).
22:17:33 <sorear> add(succ(X),Y,succ(Z)) :- add(X,Y,Z).
22:17:33 <sorear> mul(zero,Y,zero).
22:17:36 <sorear> mul(succ(X),Y,Z) :- mul(X,Y,W), add(W,Y,Z).
22:17:43 <sorear> is the problem in my prelude or my interpreter?
22:17:57 <sorear> aFlag: there's data.binary
22:18:19 <sorear> encode (0xff :: Int32)  ==>  "\0\0\0\255"
22:18:43 <ddarius> sorear: It looks good.
22:18:52 <Pseudonym> I used a university Prolog-alike once which supported the Edinburgh syntax.
22:18:56 <Pseudonym> Which is LR(infinity).
22:19:03 <aFlag> oh, cool, thanks
22:19:34 <Pseudonym> The amusing part is that the parser used the obvious Prolog algorithm.
22:19:39 <Pseudonym> It only had one syntax error:
22:19:46 <Pseudonym> "Your program contains one or more syntax errors."
22:20:00 <aFlag> hehe
22:20:12 <aFlag> at least it says something
22:20:29 <sorear> sure beats _|_ as an error message ;)
22:21:06 <monochrom> hahahahaha
22:21:06 <kc5tja_> Heh, I remember Forth systems where its only error message was   ?
22:21:24 <sorear> I've used editors with that error messag.e
22:21:26 <ddarius> Pseudonym: More entertaining would've been "No.".
22:21:30 <Pseudonym> I gave up Prolog when I read the fifth paper which claimed that this superlinear analysis was feasable because it even works in "large 1000 line programs".
22:21:41 <Pseudonym> ddarius: Well it was effectively a wrapper around that.
22:21:50 <Pseudonym> But yes, that would have been more entertaining.
22:22:07 <sorear> Pseudonym: then you came here, and all your programs ARE <= 1000 lines :)
22:22:15 * Pseudonym laughs
22:22:35 <Pseudonym> Actually, I was working on the Mercury compiler at the time which had already passed the 15,000 line mark.
22:25:07 <dons> yeah, i was thinking similar things recently at PADL, where the prolog guys were talking about loading 10s of megabytes of data into prolog programs
22:25:17 <sorear> ddarius: so in other words my interpreter is broken...
22:25:21 <dons> and we were talking about loading terabytes into haskell programs..
22:25:34 <sorear> they just need more bytestrings ;)
22:26:01 <Pseudonym> Thought mind you, I bet the Prolog guys were going to try to do smarter things with their megabytes.
22:26:14 <sorear> 4827 < 5000
22:26:15 <Pseudonym> Tens of megabytes is a pretty big logic database.
22:26:18 <dons> yeah.
22:26:24 <dons> it was for their logic dbs, of course.
22:26:28 <Pseudonym> THough not compared to Cyc, I suppose.
22:26:39 <Pseudonym> And not even compared to Aditi, now that I think about it.
22:26:48 <Pseudonym> OK, I guess it's not that big,
22:26:50 <dons> but it was a bit worrying how they all seemed to have private implementations with custom hacks.
22:27:22 <dons> unifying the lazy FP community was just so so critical
22:27:28 <Pseudonym> Yes.
22:27:37 <Pseudonym> The thing is, the LP community is standardised on Prolog.
22:27:38 <dons> otherwise we'd have stayed like lisp or prolog
22:27:49 <dons> they just have their own forks. hmm. yes.
22:28:00 <Pseudonym> 99% of the homebrew hacks are extensions of Prolog.
22:28:34 <Pseudonym> It's the ones that make a clean break, like Mercury, Goedel or Oz, that are the most interesting, IMO.
22:28:57 <dons> yeah. that seems to be the case.
22:29:40 <ddarius> Forget interesting.  Prolog is just ugly.
22:29:57 <ddarius> The LP community was lazy.
22:30:15 <Pseudonym> Still is.
22:30:24 <Pseudonym> Look, let's be fair, here.
22:30:32 <Pseudonym> Prolog is ugly in the same way that Common Lisp is ugly.
22:30:51 <Pseudonym> Prolog isn't exactly worthless, it's just a relic of a bygone era.
22:31:28 <Pseudonym> And there's no consensus on what its replacement should be.
22:32:06 <ddarius> Nor was there when Haskell came around (though Miranda was probably closest), but the Haskell people sat down and did something about it.
22:32:25 <Pseudonym> FP has been a bit different.
22:32:33 <Pseudonym> THere's always been research on new FP systems.
22:32:49 <Pseudonym> ML is over 30 years old.
22:34:03 <Pseudonym> Although...
22:34:15 <Pseudonym> It's interesting to think about what might have happened had Miranda been open source.
22:34:31 <Pseudonym> Haskell as we know it today might have been much later.
22:35:02 <monochrom> There is also Scheme, but again, a group of people sat down and reached an agreement, and then new work flourishes.
22:35:03 * ddarius doesn't see what you're getting at with the "There's always been research on new FP systems." comment.
22:35:16 <Pseudonym> ddarius: The situation isn't the same as Prolog.
22:35:23 <ddarius> ?
22:35:44 <Pseudonym> The history of LP has been, more or less, one of extensions to Prolog.
22:35:56 <Pseudonym> The history of FP has been new languages.
22:36:28 <Pseudonym> Since Backus, anyway.
22:36:42 <dcoutts> @where vty
22:36:42 <lambdabot> http://members.cox.net/stefanor/vty/
22:36:46 <ddarius> True seeming.  I'm not sure how old many of the logic languages that are beyond Prolog are.
22:37:10 <sorear> @flsuh
22:37:13 <ddarius> Perhaps Prolog's time is coming.
22:37:31 <QtPlatypus> ddarius: Why do you say that?
22:37:36 <ddarius> There are several logic languages nowadays that couldn't be wedged into Prolog.
22:37:53 <vincenz> we all know the language to stay is scheme :P
22:38:03 <vincenz> you can fit any other language into it
22:38:07 <vincenz> given enough macro hackery
22:38:25 <monochrom> Not the "Scheme Macro Tarpit" again!!!
22:38:38 <ddarius> vincenz: Actually, the call/cc + state (or delimited continuations) is the important thing, not macros.
22:38:54 <ddarius> Without them all you are saying is that you can compile any language to Scheme.
22:39:15 <vincenz> yes
22:40:30 <vincenz> though 'compile' is the wrong word
22:40:35 <vincenz> you can compile from any language to any language
22:40:43 <vincenz> the advantage is that it ties in seamlesly
22:40:58 <Pseudonym> LOL
22:41:00 <Pseudonym> http://en.wikipedia.org/wiki/Mercury_programming_language
22:41:01 <lambdabot> Title: Mercury (programming language) - Wikipedia, the free encyclopedia
22:41:16 <Pseudonym> The "logo" that they have there is actually pulled from a 1930s ad for the Ford Mercury.
22:41:27 <Pseudonym> I know that, because the ad was hanging in my office.
22:42:06 <ddarius> vincenz: No, it does not.  That's why I used "compile" with the connotations of that being trivially true for all languages.
22:42:52 <ddarius> Or at least, it wouldn't if it weren't for delimited continuations.
22:43:00 <dcoutts> @where filepath
22:43:01 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/filepath/
22:43:01 <vincenz> you mean regular ones
22:43:21 <ddarius> With state, regular ones can implement delimited ones, but delimited ones are more powerful.
22:43:35 <vincenz> erm
22:43:43 <vincenz> with state, regular ones subsume delimited ones
22:44:07 <vincenz> so the 'delimited ones are more powerful' does not hold
22:44:09 <vincenz> that being said
22:44:13 <vincenz> delimited ones are nicer to work with
22:44:41 <aFlag> sorear: I can't seem to find a encode function on hoogle. Or Data.Binary
22:44:58 <vincenz> ddarius: I like the following diagram :
22:45:03 <vincenz> ccs : [)
22:45:05 <vincenz> dcs: []
22:45:07 <vincenz> :)
22:45:38 <sorear> aFlag: hoogle Simply Doesn't Do third party libs
22:45:42 <sorear> @where binary
22:45:42 <lambdabot> http://darcs.haskell.org/binary
22:45:44 <vincenz> ddarius: btw, care to come to #oasis?
22:45:51 <aFlag> oh, I didn't realise it was third party
22:45:58 <sorear> vincenz: is there any good explanation of delimited continuations?
22:46:15 <vincenz> yes
22:46:19 <ddarius> When you can implement state with call/cc then I'll find those diagrams closer to the truth.
22:46:19 <vincenz> let me fish up the pdf
22:46:32 <ddarius> #oasis is... ?
22:46:43 <sorear> *** Topic for #oasis: Zenny channel about programming languages where
22:46:43 <sorear>     *semantics* is the issue and *syntax* is ignored | shift f (f 'firefox) ~>
22:46:53 <sorear> or just use  /topic
22:46:56 <vincenz> ddarius: my pl-channel
22:46:58 <sorear> or, *remembers*
22:47:04 <sorear> @topic-tell #oasis
22:47:04 <lambdabot> Zenny channel about programming languages where *semantics* is the issue and *syntax* is ignored | shift f (f 'firefox) ~> http://www.cse.unsw.edu.au/~dons/irc/oasis/  | Webpage for Lazy Bottoms (
22:47:05 <lambdabot> contact vincenz to update): http://homes.esat.kuleuven.be/~cpoucet/icfp2007.html
22:47:05 <vincenz> ddarius: just that I wanted to discuss something with you and it's a bit OT here
22:47:36 <vincenz> sorear: http://notvincenz.blogspot.com/2006/11/delimited-continuations.html
22:47:39 <lambdabot> Title: lambda.oasis: Delimited continuations, http://tinyurl.com/yaj49t
22:47:40 <vincenz> while I fish up that pdf
22:48:20 * vincenz should give his pdfs saner names
22:48:41 <vincenz> sorear: "shift to control" chung-chieh shan
22:48:53 <sorear> vincenz: I notice your lazy bottoms 'Tasks' section has considerably more info than the public section of the ICFP web :)
22:49:02 <vincenz> sorear: that's last years
22:49:11 <ddarius> sorear: Understanding delimited continuations, given you understand continuations, is fairly straightforward.  It's being able to use the readily that's a bit more tricky.
22:50:19 <vincenz> sorear: that's quite impressive how fast you went from my blog to my homepage
22:50:43 <vincenz> especially since the icfp page is somewhat buried
22:51:36 <falconair> while trying to "make vim" the latest darcs copy of yi, I get the following error: "setup: Unrecognised flags: --disable-haddock-use-packages"  ...google doesn't know, any ideas
22:56:20 <dcoutts> @seen jyp
22:56:20 <lambdabot> I saw jyp leaving #oasis and #haskell 9h 36m 23s ago, and .
22:56:23 <sorear> vincenz: there is a shortcut
22:56:43 <vincenz> sorear: where?
22:56:50 <sorear> http://www.cse.unsw.edu.au/~dons/irc/oasis/  | Webpage for Lazy Bottoms (
22:56:50 <sorear> <lambdabot> contact vincenz to update): --> http://homes.esat.kuleuven.be/~cpoucet/icfp2007.html
22:56:50 <lambdabot> Title: Index of /~dons/irc/oasis
22:56:52 <lambdabot> Title: ICFP Contest 2007
22:56:58 <vincenz> oh
22:57:01 <vincenz> right :)
22:57:09 <dcoutts> falconair: I just hacked the cabal-make.inc to remove that flag
22:57:22 <vincenz> sorear: tasks are more things we cooked up last year for what was expected to be possibly needed, so we knew we had skill-coverage
22:57:23 <dcoutts> anyone know where filepath-1.0 lives ?
22:57:31 <dcoutts> I can only find FilePath-0.11
22:57:36 <dcoutts> @where filepath
22:57:37 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/filepath/
22:57:38 <sorear> dcoutts: it's in ghc
22:57:51 <sorear> dcoutts: like base or parsec or mtl
22:58:03 <dcoutts> http://darcs.haskell.org/packages/filepath/
22:58:03 <falconair> dcoutts, thanks, do i just do another darcs get on yi?
22:58:03 <lambdabot> Title: Index of /packages/filepath
22:58:36 <dcoutts> falconair: no, I mean I hacked it locally, I don't have commit rights for yi
22:59:03 <falconair> oh, i see what you mean, i'll try the same
22:59:45 <dcoutts> falconair: I expect it means I'll not be able to build the docs, but I care not
23:01:16 <falconair> now I get another error which means nothing to me: "setup: fd:7: hGetLine: end of file"
23:02:15 <dcoutts> falconair: doesn't mean much to me either :-(
23:03:12 <falconair> instead of spending more hours trying to get little yi to install, .... what exaclty is it?  is it just a haskell clone of vi?  is it helpful for newbs (syntax highlighting, quick type description, quick docs, etc.?)
23:04:08 <ddarius> It's malleable editorness.
23:05:01 <falconair> right...but for those who are not yet skilled enough to mold anything, is it useful?
23:06:38 <ddarius> It's useable I think.  But it's not yet at a point where it's going to supplant much anything else.
23:07:07 <falconair> hm ... ok, may be i'll hold off on it then, thanks
23:08:19 <fuzan> salut.
23:08:55 <dons> falconair: its an emacs and vim editor, with gtk and console frontends, based on a haskell interpreter
23:09:08 <dons> its still alpha though.
23:09:22 <dons> the previous version, circa 2004, is a 90% vi clone.
23:09:36 <dons> now its more like emacs, (though also still emulates vim)
23:10:17 <sorear> is it closer to emacs or mg?
23:10:48 <falconair> i don't quite get what role haskell plays: is it supposed to show off haskell ability to do dynamic plug-in loading or is it supposed to be an editor for working with haskell source code?
23:11:10 <sorear> it's just cool
23:11:16 <dons> its a text editor, customisable with haskell
23:11:24 <dons> written in haskell.
23:11:36 <falconair> i see, thanks dons
23:13:00 <dcoutts> it's a pain to build :-)
23:13:15 <dcoutts> and it doesn't open files passed on the command line
23:13:18 <dons> yeah, i suspect we need some release engineering.
23:13:30 <dcoutts> I've used vim for ages but I don't know the command to load files
23:13:48 <dons> oh, hmm, it used to handle that.
23:13:52 <dcoutts> I always open them by passing them on the command line
23:13:52 <dons> :new Foo.hs
23:13:57 <dons> or :e Foo.hs
23:14:00 <dcoutts> ok, ta
23:14:10 * dcoutts learns a new vim command
23:14:17 <dons> there used to be an nedit mode too
23:14:22 <dcoutts> oh nice
23:14:26 * dcoutts is also a nedit user
23:14:37 <dons> yi --help might list the availabe modes, though vim and emacs are probably the best supported
23:16:21 * dcoutts tries to figure out how to fix home/end keys
23:17:29 <fuzan> dcoutts: try, :e .
23:17:46 <fuzan> dcoutts: directory navigation :)
23:18:03 <sorear> in vi yes.  yi doesn't believe in modes, period
23:18:28 <sorear> the best you'll get is a binary view of the directory tables
23:18:31 <dons> a bunch of yi patches just landed, btw.
23:18:33 <sorear> and not even that on linux
23:19:04 <dcoutts> fuzan: aye, but then I'd need to figure out how to use vim with more than one file loaded at once, switching buffers etc, it's all just too much work
23:19:06 <fuzan> ah, i see. wasn't sure if he was using yi or vim. yi's likeness to builderrors has prevented me from mucking with it yet.
23:19:07 <sorear> btw, does any modern unix let you cat directories?  I only know about it from my copy of TUPE
23:19:25 <fuzan> dcoutts: :tabnew :)
23:19:28 <dcoutts> life is simple if you just :q! vim NextModule.hs
23:19:55 <dcoutts> you can get away with only knowing about 3 vim commands
23:20:27 <fuzan> i just suggest using emacs :)
23:20:51 <rashakil_> yeah, :q and :! emacs
23:21:04 <sorear> <normal>:, <cmdline>ret, <ex>q  -- I count three just to quit!
23:21:07 <fuzan> i introduce so many errors in my visual studio project attempting ot perform vim/emacs commands.
23:22:00 <dcoutts> rashakil_: but with emacs one feel like things such as selecting text with a mouse should work, so you try to use it, then it doesn't. At least vim doesn't give any such false pretences :-)
23:22:01 * sorear has been known to write vim commands in writing assignments on occasion
23:22:21 <vincenz> sorear: like "please execute this vim code for the solution to this test"
23:22:52 <sorear> no, more like ^p^p
23:24:05 <fuzan> i like to use regular expressions for words i can only partially remember ;)
23:24:07 <vincenz> dcoutts: you should try my mappings
23:24:20 <vincenz> dcoutts: I have some things that map 'CTRL+TAB' and CTRL+SHIFT+TAB
23:24:22 <vincenz> to next and prev tab
23:24:27 <vincenz> both in normal and insert mode
23:24:32 <rashakil_> dcoutts: but with vim it feels like figuring out an alien computer system on an abandoned starship -- and you don't know which button opens the airlock
23:24:38 <vincenz> and then use tabs, which is much more convenient than plain buffers
23:24:39 <fuzan> vincenz: that's a nice feature. ctrl+w for close tab as well.
23:24:44 <falconair> dcoutts: do you maintain gtk2hs?
23:24:57 <vincenz> fuzan: good idea
23:25:13 <dcoutts> vincenz: does it make home/end work? for some reason the keyHome in yi doesn't match my home/end keys, no idea why. I'm not sure how the escape codes map to yi's numbers
23:25:16 <fuzan> that's what I used to do back when I used vim primarily.
23:25:18 <dcoutts> falconair: yep
23:25:29 <vincenz> dcoutts: eh? why wouldn't home and end work
23:26:07 <dcoutts> vincenz: they generate '\207H' and '\207F' in insert mode
23:26:17 <vincenz> works fine for me on vim
23:26:26 <dcoutts> vincenz: I'm talking about yi
23:26:35 <dcoutts> yi's vim mode
23:26:39 <vincenz> OH
23:26:50 * vincenz uses pure, unadulterated vim
23:26:53 <dcoutts> vincenz: though we've also been talking about vim
23:27:07 <vincenz> dcoutts: well if you're not aware, 7+ has tabs :)
23:27:17 <dcoutts> vincenz: if yi can do a better haskell mode than vim then I'm switching to yi
23:27:20 <LOKam> if I have a text based haskell script, what would be the easiest way to make it into an irc bot?
23:27:24 <dcoutts> for the pure Haskelly goodness
23:27:42 <dcoutts> vincenz: generally I use vim and nedit
23:27:44 <vincenz> dcoutts: I've got a bunch of stuff for latex and such
23:27:52 <vincenz> so I doubt I'll switch to yi
23:28:07 <vincenz> for instance-section folding :)
23:28:14 <dcoutts> vincenz: yeah, but I want to be patriotic :-)
23:28:16 <fuzan> emacs already has the sexiest haskell mode.
23:28:21 <LOKam> I used yi for a little while, but it didn't have syntax highlighting
23:28:28 <dcoutts> fuzan: bah, not using GHC api
23:28:40 <dcoutts> LOKam: rumor has it that it does now
23:28:47 <dcoutts> but I don't see it yet...
23:28:54 <LOKam> lol
23:28:57 <vincenz> I know jyp's busy on it
23:29:01 <vincenz> on yi in general, that is
23:29:03 * dcoutts want's to believe
23:29:19 <falconair> dcoutts: he, just made the name  connection :) i am going to attempt SOE again using gtk2hs on my osx ... i'm curious why there has to be a dependency on gtk ... why not just use Apple's Quartz (as I understand, Cairo can be used with any backend)
23:30:26 <dcoutts> falconair: you need something for the windowing and event bits, I hack on Gtk2Hs so I used that. Yes you could probably do something with cairo and native OSX stuff, if you had access to OSX (which I do not).
23:30:36 <LOKam> so what is a really simple irc bot, that could connect to a channel, accept input and route it to my haskell script, which will give output the bot will output back to screen?
23:30:57 <dcoutts> LOKam: check out that simple irc bot tutorial that dons wrote
23:31:10 <LOKam> wow :D where do I get it?
23:31:24 <dcoutts> @google haskell irc bot tutorial
23:31:26 <lambdabot> http://haskell.org/haskellwiki/Roll_your_own_IRC_bot
23:31:26 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
23:31:34 * dcoutts scores
23:31:42 <falconair> dcoutts: ok, i hope SOE goes smoothly, thanks
23:31:45 <LOKam> :D kk I'll go check it out thanks
23:33:00 <dcoutts> falconair: I think it doesn't work in GHCi, so only build standalone apps.
23:33:10 <ivanm> Happy Easter everyone!!
23:33:18 <falconair> ok, will do
23:34:00 <Shi_> @where vty
23:34:01 <lambdabot> http://members.cox.net/stefanor/vty/
23:36:25 <sorear> falconair: the 'y' in yi has nothing to do with the 'y' in jyp
23:36:37 <sorear> falconair: it was called yi back when dons maintained it
23:36:57 <sorear> falconair: otoh, it was called riot when it was tuomov's
23:37:14 <falconair> ...jyp?  don't know what that is :)
23:37:33 <vincenz> s/what/who
23:37:46 <sorear> jyp, also known as "Jean-Phillipe Bernardy", is an object of type Human
23:38:12 <vincenz> ewww, objects
23:38:13 <dons> YI is the world's most recursive acronym
23:38:15 <vincenz> it's a value of type human
23:38:33 <vincenz> dons: how so?
23:38:35 <dcoutts> dons: is it non-primitive recursive ?
23:38:42 <falconair> ok, i don't think I mentioned jyp, sorear probably meant those messages for someone else :)
23:38:49 <rashakil_> hahaha
23:39:00 <dons> Y combinator applied to I
23:39:01 <sorear> LOKam: Yeah, I wrote the syntax highlighting.  Note that I managed to lose interest before implementing incremental mode, so the whole buffer is rescanned at every repaint :(
23:39:08 <dons> ?eval Y I
23:39:12 <sorear> <*falconair> dcoutts: he, just made the name  connection :) i am going to attempt
23:39:16 <dons> ah, no lambda plugin anymore?
23:39:20 <dons> yes.
23:39:22 <sorear> dons: you deleted it
23:39:28 <dons> ?lambda Y I
23:39:29 <lambdabot> Plugin `unlambda' failed with: IRCRaised Data.ByteString.last: empty ByteString
23:39:32 <dons> haha
23:39:35 <sorear> besides, ?eval is a dummy plugin
23:39:44 <sorear> ?unlambda ```sii``sii
23:39:46 <dons> yeah, @lambda was huge anyway
23:39:48 <lambdabot> Plugin `unlambda' failed with: IRCRaised Data.ByteString.last: empty ByteString
23:40:10 <vincenz> jyp: they're discussing you
23:40:17 <dcoutts> hia jyp
23:40:17 <vincenz> yi's a hot topic
23:40:18 <sorear> <*falconair> ...jyp?  don't know what that is :)
23:40:18 <sorear>  
23:40:29 <dcoutts> jyp: I'm trying yi...
23:40:29 <jyp> whoa :p
23:40:43 <falconair> oh, i made the connection between dcoutts and Duncan Coutts for gtk2hs
23:40:50 <dcoutts> @arr
23:40:50 <lambdabot> I'll keel haul ya fer that!
23:40:56 <jyp> "jyp: they're discussing you" sound like the jury is out :p
23:41:09 <dcoutts> jyp: heh :-)
23:41:13 <cpoucet> it is
23:41:16 <cpoucet> you've been found wanting
23:41:28 <dcoutts> cpoucet: oi, be nice
23:41:31 <cpoucet> erm
23:41:31 <cpoucet> wanted
23:41:32 <cpoucet> :P
23:41:50 <cpoucet> dcoutts: I wonder if anyone actually ever says that
23:41:53 <dcoutts> jyp: ready for the bug reports? :-)
23:42:04 <jyp> I'm sure ready
23:42:34 <Shimei> @where filepath
23:42:35 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/filepath/
23:42:45 <dcoutts> jyp: #1 I can't make home/end work in vim mode, in insert mode they insert '\207H' and \207F'
23:43:15 <dcoutts> jyp: in command mode home goes to the beginning of the buffer and end does nothing
23:43:33 <cpoucet> dcoutts: afaik, in vim, home/end are line-based, not buffer-based
23:43:38 <cpoucet> dcoutts: maybe your first line was empty?
23:43:39 <dcoutts> jyp: it's odd because I can see in the vim keymap module that it's supposed to do the right thing
23:44:08 <dcoutts> cpoucet: I'm not sure I understand
23:44:17 <cpoucet> dcoutts: home and end move to the beginning and end of the current line
23:44:21 <cpoucet> not to he beginning and end of the buffer
23:44:27 <jyp> dcoutts: are you using gtk or vty?
23:44:28 <cpoucet> if your line's empty, you'd notice no diff
23:44:39 <dcoutts> jyp: vty to start with
23:44:48 <dcoutts> cpoucet: yes, that's what I want, beginning and end of the line, like in vim
23:45:01 * cpoucet nods
23:45:27 <jyp> dcoutts: ok. home and end are not supported by the vty lib
23:45:39 <jyp> sorear could tell you more about it ... :)
23:45:42 <dcoutts> jyp: ah ok, can I fix that?
23:45:45 <dcoutts> sorear: :-)
23:45:54 * dcoutts needs his home/end keys
23:46:04 <cpoucet> what about pgup/pgdn/
23:46:13 <dcoutts> jyp: what's the status on the haskell syntax highliting btw?
23:46:30 <dcoutts> cpoucet: they work fine
23:47:09 <dcoutts> jyp: know if it's the same problem for the <insert> key ? I always use that key rather than 'i'
23:47:13 <cpoucet> mm, that's rather odd, you'd expect closely-ranged keyb-numbers, so home/end shouldn't be such a tough nut to crack.
23:47:32 <jyp> dcoutts: insert, yes, afaict.
23:47:37 <sorear> cpoucet: I've so far managed to avoid adding ANY $TERM support ;)
23:47:53 <dcoutts> jyp: I never really did get used to vim's single char commands, I mostly use the symbol key equivalents, up/dn/left/right/home/end/insert etc
23:47:57 <cpoucet> sorear: so home and end are more difficult than pgup/pgdn?
23:48:32 <jyp> dcoutts: Syntax highlight is lexical in vty mode... and relies on sourceview in gtk mode.
23:48:42 <dcoutts> sorear: is that why <del> doesn't work too then ?
23:48:49 <sorear> cpoucet: vty was written on and for the linux-console.  I haven't found a nice elegant way of handling $TERM etc.
23:48:55 <dcoutts> jyp: how do I turn it on?
23:49:13 <sorear> Say, would it be a Really Dumb Idea if vty became just a nice interface to ncurses?
23:49:28 <dons> probably not.
23:49:29 <sorear> I'm in a delegating mood :)
23:49:46 <ddarius> hmm, I guess I shouldn't say that I use gb and gp to switch between buffers in normal mode then.
23:49:50 <dcoutts> sorear: I thought you started vty to avoid ncurses?
23:50:17 <sorear> dcoutts: I started vty because I couldn't understand ncurses.
23:50:30 <sorear> dcoutts: I've gotten a lot smarter in the intervening year :)
23:50:35 <dcoutts> :-)
23:50:49 <LOKam> :D
23:51:18 <jyp> dcoutts: :set ft=haskell
23:51:25 <dcoutts> jyp: ta
23:51:51 <sorear> ... and observe the slowdown.  I've suffered an amazing lack of motivation
23:52:15 <ddarius> sorear: Switch to yi as your only editor and you may become more motivated.
23:52:17 <sorear> despite sitting on a O(1)-with-no-worst-cases rehilight algorithm
23:52:28 <dcoutts> jyp: bug #2 is that passing files on the command line doesn't open them, that's the only way I ever used vim, someone just now had to tell me about the :e command :-)
23:53:23 <sorear> ddarius: but then I'd have to reinstall irssi and rlwrap and info! :)
23:53:43 <jyp> dcoutts: ok ... it turns out they are open, but it some other buffer :p
23:54:02 <ddarius> sorear: Just call on hackage and make a bunch of yi plugins.
23:54:09 <sjanssen> sorear: you could use emacs for everything but text editing :)
23:54:14 <sorear> having [#haskell] show up in the mode line, as opposed to on a different virtual console, is Really Nice.
23:54:27 <dcoutts> jyp: ah! That means I need to know how to switch buffers - which I don't :-) You see I use vim all the time despite knowing only 3 commands :-)
23:54:50 <stepcut> dcoutts: I thik you mean, :wq
23:54:59 <ddarius> :bnext
23:55:04 <dcoutts> ta
23:55:09 <ddarius> That's for vim
23:55:11 <stepcut> or rather, :q1
23:55:16 <stepcut> yikes, :q!
23:55:28 <dcoutts> stepcut: that's one of the 3 commands I know :-)
23:55:29 <stepcut> the only three vim commands you need
23:55:34 <dcoutts> yep
23:55:35 <sorear> :wqall!
23:55:44 <sorear> that will solve all your problems.
23:55:53 <jyp> dcoutts: the problem is I really use only the emacs mode myself... So the vim one is rather 'unpolished' :p
23:56:02 <sorear> so will :! sudo rm -rf /, for that matter
23:56:17 <dcoutts> jyp: right, that's ok I'm happy to test it and report bugs until it works :-)
23:56:26 <jyp> great :)
23:56:28 <stepcut> sorear: that only works if you are running as root
23:56:42 <stepcut> oh wait, I missed the sudo
23:56:42 <cpoucet> sorear: 'sudo'
23:56:50 <cpoucet> s/sorear/stepcut
23:56:58 * stepcut decides it must be time to go to bed
23:57:12 <sorear> I think my instruction cache just misfired...
23:57:27 <dcoutts> jyp: so if you're happy to put up with my little annoying bug reports I'm going to try using yi as my main Haskell editor and see how it goes, btw the syn hl is very nice!
23:58:12 <jyp> thank sorear :)
23:58:45 <cpoucet> hehe
23:58:50 <cpoucet> jyp's the only person from this channel I met irl
