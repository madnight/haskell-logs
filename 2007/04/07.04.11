00:00:05 <dons> joelr1: there's a nice little section on financial applications you'll be interested in.
00:00:09 <joelr1> dons: yes, hackage is cool
00:00:38 <joelr1> dons: let me see real quick... i have the papers open
00:03:58 <joelr1> dons: i'm currently taking in various trading languages (well, one for now) and generating c#. optimizing the trading systems would be the next step. some resemblance to what the paper talks about
00:06:56 <joelr1> dons: who wrote the financial bit?
00:07:10 <dons> Gabi and Manuel. Gabi's been at Credit Suisse for the last year.
00:09:43 * joelr1 notes that his daughter's name is gabi
00:10:24 <joelr1> dons: i have been meaning to learn things like markov chains now i have sample code in haskell!
00:10:48 <joelr1> dons: awesome paper
00:11:54 <dons> cheers.
00:16:01 <joelr1> dons: what cool things have you been working on lately? besides the two papers of course
00:18:59 <robreim> markov chains? Where's this paper?
00:20:38 <xs> http://www.cse.unsw.edu.au/~dons/papers/SCKCB07.html
00:20:39 <lambdabot> Title: Generative Code Specialisation for High-Performance Monte-Carlo Simulations
00:22:26 <dons> joelr1: xmonad.org
00:22:50 <dons> hmm, what else. a couple of other top secret projects. oh, and a bit of Data.Binary
00:22:55 <joelr1> dons: i don't use xwindow :(
00:23:02 <dons> ah well. maybe you should!
00:23:03 <joelr1> dons: cool
00:23:22 <joelr1> dons: well, i rather like ubuntu when i boot it up on my mac but then i rather like the mac itself :D
00:38:53 <dons> jcreigh, sjanssen, i just committed a patch to generalise 'promote' to cycle the tiling order, as i've been threatening.
00:39:04 <dons> bonus is that 'promote' is now a one liner, and we get nicer functionality.
00:39:23 <dons> also, reveals an interesting feature of vertical tiling mode: try mod-return first in tall mode, then in wide mode.
00:39:36 <dons> for some reason we lay windows out in reverse in wide mode!
00:39:38 <dons> feature, i suppose.
00:40:06 <dons> nice, we're back on comment/code parity, TOTAL:                  466    466
00:46:45 <jargonjustin> Are multi-parameter type classes an extension because there is something semantically weird or they're just not that useful?
00:47:17 <dons> they're newer than h98, hence they're an extension.
00:47:27 <dons> they aren't entirely well understood, though, that is true.
00:47:44 <dons> they're used for some critical pieces of code though. the monad transformer library, for example.
00:48:32 <jargonjustin> dons, conceptually it's just allowing polymorphism over more than one type in the function's type, right?
00:48:54 <dons> sort of.
00:49:07 <dons> yeah, that's basically it.
00:49:24 <dons> you usually need some additional constraints though, to make it useful
00:49:31 <dons> leading to associated types or functional dependencies.
00:49:36 <dons> which aren't entirely well understood
00:49:36 <jargonjustin> dons, okay.  I'll probably be back once I get to monad transformers
00:49:50 <dons> MPTCs on their own are fairly simple, as far as type system extensiosn go.
00:50:46 <mauke> functional dependencies are awesome/scary. wait until you see what oleg does with them :-)
00:55:44 <Cheery> > import Data.Map (mapKeys, map)
00:55:44 <lambdabot>  Parse error
00:56:19 <Cheery> I'd like to rename the 'map' to 'mapValues' while I'm importing it
00:56:21 <Cheery> how?
00:56:50 <Cale> Cheery: well, you can import it qualified and make a definition  mapValues = Data.Map.map
00:57:36 <dons> note that no one will understand your code. :-)
00:57:52 <DRMacIver> What, you mean Haskell isn't *intended* to be write only? :)
00:58:15 <dons> its a bit like renaming (.), but not quite so severe.
01:00:00 <mauke> import Prelude hiding ((.)); f . g = fmap f g
01:00:34 <Cheery> i should use fmap instead of map?
01:00:54 <mauke> no, why?
01:02:44 <Cheery> dons: well, mapping it to mapValues is not really a big thing
01:03:07 <dons> i'd encourage you to just use M.map
01:03:15 <dons> but yeah, its not a big issue :-)
01:07:42 <Cheery> but now,     I'm trying to define infix:   selector :- declarations
01:08:08 <Cheery> but it says
01:08:10 <Cheery> unnamed.lhs:19:1: Not in scope: data constructor `:-'
01:09:54 <mauke> yeah, : is an uppercase letter
01:10:11 <dons> : is special
01:12:24 <Cheery> oh
01:13:52 <DRMacIver> Hm. Is there a page somewhere that details exactly what you can and can't use for identifier names where?
01:14:12 <dmwit> Well, the Report.
01:14:25 <dmwit> Do you have a specific question?
01:14:27 <hpaste>  Cheery pasted "which symbol should replace -:- ?" at http://hpaste.org/1339
01:15:42 <Cheery> and is there a way to make it right-associative?
01:15:49 <DRMacIver> dmwit: Not really.
01:16:01 <dmwit> Cheery: infixr
01:16:54 <dmwit> http://www.zvon.org/other/haskell/Outputsyntax/fixityQdeclaration_reference.html
01:16:56 <lambdabot> Title: Haskell : fixity declaration, http://tinyurl.com/28hh35
01:17:20 <dmwit> There are 9 precedence levels, the number in the fixity declaration tells which one your operator should belong in.
01:17:32 <dmwit> s/9/10/
01:19:46 <DRMacIver> That's a good example of the sort of thing I was wondering about. What function names are allowed to be infixed? e.g. 'foo' is not allowed.
01:20:12 <mauke> sure it is
01:20:23 <mauke> > let foo = elem in 'x' `foo` "xyz"
01:20:25 <lambdabot>  True
01:20:44 <DRMacIver> Hm
01:20:45 <dons> sjanssen: can you do some writing today? just pick a section that you wrote most of the code for, and write :-) in particular, you could cover the layout algo, and details about binding to X11. also, motivation. (steal stuff from the dwm manifestor)
01:20:50 * dons `ap` bus >>= home
01:21:03 <DRMacIver> ok. But you have to surround it with ` ` ?
01:21:20 <mauke> yes, words can be made infix operator with ``
01:21:25 <DRMacIver> ok
01:21:26 <mauke> s/operator/&s/
01:28:29 <Cale> Things which are made up of symbol characters that are normally infix can also be made prefix by enclosing them in parentheses.
01:28:40 <swiert> I have a cabal question:
01:28:54 <swiert> The "description" field in a cabal file should allow you to use Haddock markup.
01:29:15 <swiert> I can't seem to get it to layout an unordered list/definition list.
01:29:22 <swiert> Anyone recognize this problem?
01:31:07 <ski_> > (`elem`) 0 [0..]
01:31:08 <lambdabot>  Parse error
01:31:35 <mauke> > (0 `elem`) [0..]
01:31:36 <lambdabot>  True
01:31:48 <ski> strange that partial sections work
01:31:50 <mauke> > (`elem` [0..]) 0
01:31:51 <lambdabot>  True
01:32:16 <ski> i'd expect all those, or none of those, to work
01:34:06 <dmwit> (`(`(`elem`)`)`) 0 [0..]
01:34:15 <mauke> lexical error
01:34:37 <mauke> `` wants a single word
01:34:54 <mauke> for some weird reason it skips whitespace, though
01:35:36 <procyon112> > ( `elem` ) 0 [0..]
01:35:36 <lambdabot>  Parse error
01:36:13 <procyon112> > (`(`(`elem`)`)`) 0 [0..]
01:36:13 <lambdabot>  Parse error
01:37:22 <ski> quite often i've wanted things like
01:37:29 <ski> foo `bar baz` quux
01:38:00 <mauke> especially where bar = liftM2
01:38:08 <ski> yes, e.g.
01:38:33 <ski> hm, in some cases, 'barBy', too
01:40:25 <dcoutts> g'morning JaffaCake
01:40:47 <JaffaCake> hey there
01:41:03 <DRMacIver> I suppose I'd better go do that work thing.
01:41:11 <JaffaCake> feeling relieved after the ICFP deadline?
01:41:19 <dcoutts> heh, oh yes.
01:41:21 <dcoutts> JaffaCake: if dons and I send you bug-fix-only patches for fps is that ok to go in before the final 6.6.1 release or are we too late?
01:41:36 <JaffaCake> ask Igloo :)
01:41:47 * JaffaCake passes the buck
01:41:55 <dcoutts> he said probably
01:42:01 <dcoutts> we'll try him and see :-)
01:42:13 <JaffaCake> should be fine, I'd think
01:43:22 <dcoutts> JaffaCake: so next up (after TMR articles) is a HW paper :-) we're thinking of doing one on binary and related issues of layered IO
01:43:42 <JaffaCake> sounds great
01:43:53 <JaffaCake> I'm planning to write one on the debugger
01:43:57 <dcoutts> cool
01:44:06 <JaffaCake> Bernie is just finishing up his internship here
01:44:13 <dcoutts> right
01:44:30 <dcoutts> we might try doing GHC .hi files as a case study of how to build a custom serialisation thing on top of the basic binary stuff
01:44:42 <JaffaCake> that'd be great
01:45:24 <dcoutts> and another example of conforming to an externally specified binary format, perhaps something networky and erlangish
01:45:34 <dcoutts> that's the initial idea anyway
01:45:52 <JaffaCake> yeah, sounds good
01:46:19 <JaffaCake> how about decrypting HD DVD :)
01:46:24 <dcoutts> heh heh
01:46:58 <dcoutts> or porting Igloo's gzip on top of a binary bit layer rather than using lists of Bools
01:47:17 <JaffaCake> yep
01:47:52 <dcoutts> we're not sure if it'd be stretching the scope too much but we'd love to push the idea of doing as much as possible of IO stuff on the pure side
01:48:04 <dcoutts> ie buffering, string encoding, compression etc etc
01:48:24 <dcoutts> ideally only the block layer needs to be in IO
01:48:55 <JaffaCake> it's certainly worth exploring... I'm still not sure that lazy I/O should be the primary I/O method though
01:49:02 <dcoutts> so no composing of iostreams, just composing of pure functions, but make it just as fast
01:49:26 <dcoutts> JaffaCake: right, that's the tricky aspect, giving the people who want the strict control something
01:49:47 <JaffaCake> I'm interested by the left-fold idea of Oleg's
01:50:03 <dcoutts> ideally there'd be some single generic thing to push some pure transfomer into a iostream/handle
01:50:27 <JaffaCake> right, I think that's a good direction
01:50:55 <JaffaCake> so you get to use pure streams and fusion, but with an IO-ish interface
01:51:16 <dcoutts> JaffaCake: mm, I'm not so sure about the left folds. Sure it gives these guarantees of when the resource is used but it brings the IO further up into your app.
01:51:39 <JaffaCake> the folding function is non-IO, though
01:51:51 <dcoutts> hmm, I should re-read that
01:51:53 <JaffaCake> it's like a stream transformer, in fact
01:52:01 <dcoutts> basically we need a system that allows both styles
01:52:09 <JaffaCake> yep
01:52:32 <JaffaCake> the left-fold thing reminded me of your streams, I suspect there's a good point in the design space around there
01:53:28 <dcoutts> the main thing I think we learned from the bytesting IO stuff is that you don't need mutable buffers for performance
01:53:44 <JaffaCake> right
01:53:47 <dcoutts> just using persistent buffers and grabbing new ones and GC's only ones hardly looses you anything
01:54:11 <JaffaCake> I should probably do that in the Handle implementation
01:54:55 <dcoutts> JaffaCake: btw, that might be one place to split the Handle impl, to separate the bit in base from per-compiler details..
01:55:29 <dcoutts> JaffaCake: for the underlying implementation to provide just the block layer and then implement the Handle on top of that
01:55:32 <JaffaCake> maybe, yes
01:56:08 <dcoutts> eg we need to be able to set the semi-closed state which is currently inaccessible
01:56:18 <dcoutts> for ByteString hGetContents
01:56:27 <balodja> unsafeCoerce :: a -> b
01:56:29 <balodja> unsafeCoerce = unsafeCoerce#
01:56:34 <dcoutts> erm for lazy ByteString hGetContents
01:56:34 <balodja> what is the meaning of #?
01:56:51 <dcoutts> balodja: that it's scary and not to be used lightly
01:57:05 <dcoutts> balodja: it has no semantic meaning, it's just part of the name
01:57:14 <balodja> oh...
01:57:26 <JaffaCake> balodja: by convention, GHC's primitive operations have names that end in a #
01:57:44 <dcoutts> it's a convention that the low level unboxed stuff in ghc uses that, eg 0# +# 1#
01:57:56 <dcoutts> 0# :: Int#
01:58:11 <JaffaCake> balodja: the origins of the # are in the paper "unboxed values as first class citizens", it's worth a read
01:58:29 <balodja> ok, thanks, i understand
01:59:15 <ReTaL> can i use "read" to convert a string to an int and catch an error if it fails?
01:59:34 <dcoutts> JaffaCake: was Oleg's idea just in an email?
02:00:05 <JaffaCake> dcoutts: hold on, I'll dig up the link
02:00:07 <mauke> ReTaL: you can use reads for that
02:00:10 <dcoutts> ReTaL: use reads, for that not read
02:00:28 <balodja> where can i paste haskell code?
02:00:32 <dcoutts> @paste
02:00:33 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:02:11 <JaffaCake> dcoutts: http://www.haskell.org/pipermail/haskell-cafe/2007-March/023523.html
02:02:14 <lambdabot> Title: lazily handling exceptions in lazy sources (Re: [Haskell-cafe] Re:, http://tinyurl.com/2bl8se
02:02:15 <dcoutts> ta
02:07:48 <kolmodin> @yarr!
02:07:49 <lambdabot> Gangway!
02:10:10 <balodja> i'm trying to build hs-plugins, but ghc throws an error "parse error. possibly incorrect identation" on the line number 452 in module AltData.Typeable(source: http://rafb.net/p/WFfNYz25.html )
02:10:11 <lambdabot> Title: Nopaste - No description
02:10:30 <balodja> using ghc 6.6
02:15:20 <balodja> hm-m-m, INSTANCE_TYPEABLE0 is declared in my lib/ghc-6.6/include/Typeable.h, but INSTANCE_TYPABLE1 and higher aren't :(
02:15:32 <balodja> so, nevermind
02:27:36 <Itkovian> Anybody any idea how to submit post categories using the metaWeblog API? The RFC says to pass an array of strings (i.e., the category names) in the structure, but drupal fails to grab them, it seems. I'm on drupal 5.1 btw.
02:29:10 <dcoutts> @seen jyp
02:29:10 <lambdabot> I saw jyp leaving #haskell 1d 16h 14m 6s ago, and .
02:29:14 <dcoutts> @where yi
02:29:15 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
02:29:59 <dcoutts> ah it's a known bug
02:30:30 <Itkovian> erm
02:30:35 <Itkovian> oops wrong tab :-)
02:30:52 <Itkovian> sorry about that
02:32:40 <ivanm> does anyone here know of any programs I can have a look at that call the graphs library nauty?
02:35:32 <dcoutts> ivanm: the graph library "nauty" ? never heard of it.
02:36:04 <ivanm> http://cs.anu.edu.au/~bdm/nauty/
02:36:05 <lambdabot> Title: The nauty page
02:36:15 <ivanm> someone suggested I use it for a problem I'm working on
02:36:33 <ivanm> I know you can call it from C programs, and since Haskell has the ffi...
02:37:05 <ivanm> its one of those "free for personal/academic use" things
02:40:51 <dcoutts> or just generate a text file in its input format (assuming that's its mode of operation)
02:41:05 <dcoutts> that's what people do for graphviz
02:41:15 <ivanm> *nod*
02:41:21 <ivanm> but its not a graphing as in pretty graphs
02:41:32 <dcoutts> sure sure
02:41:35 <ivanm> its graphs as in bipartite, isomorphic, etc ... graphing theory
02:41:53 <dcoutts> but I bet the input format is similar
02:41:55 <ivanm> though I know someone who did the whole temporary text file route, even for a C program
02:42:59 <dcoutts> I think the answer to your original question is no :-) but there are several that use graphviz so that might provide some helpful code
02:43:23 <dcoutts> I've got code to produce simple graphviz text format
02:43:58 <dcoutts> http://www.haskell.org/~duncan/WriteDotGraph.hs
02:47:05 <ivanm> dcoutts: OK, thanks
02:50:48 <dcoutts> @seen swiert
02:50:49 <lambdabot> swiert is in #haskell. I last heard swiert speak 1h 21m 26s ago.
02:51:04 <dcoutts> swiert: got a Q about the review
02:51:22 <swiert> dcoutts: Shoot.
02:52:36 <dcoutts> swiert: the person from the publisher asked me to include both ISBNs and stuff, I don't have the original email (my mail archive is on a machine the UK that seems to have lost its net connection) I was wondering if you knew the details
02:53:30 <dcoutts> on the inner cove it lists the ISBNs for paper back and hard back, but it's got two ISBNs for each version
02:53:50 <dcoutts> ISBN-10 and ISBN-13. I don't know what that's about.
02:53:50 <swiert> dcoutts: Let me check.
02:53:54 <dcoutts> cheers
02:55:31 <swiert> Go for the ISBN-13.
02:55:37 <dcoutts> ok
02:55:39 <swiert> 978-0521871723
02:55:47 <swiert> and 978-0521692694
02:55:52 <dcoutts> yep
02:55:52 <swiert> According to amazon.
02:56:03 <swiert> How's things coming along?
02:56:42 <dcoutts> ok, I pulled Craft of FP out of the library for comparison
02:57:01 <dcoutts> swiert: did you have some expectation on the length / depth of the review?
02:57:23 <dcoutts> we've not had any yet for TMR so I wasn't sure what to go by
02:57:43 <dcoutts> I was just going to go by how much I felt there was to say :-)
02:58:00 <junyer> hmm
02:58:06 <junyer> this is kind of a stupid question
02:58:13 <swiert> dcoutts: I trust your judgment.
02:58:19 <junyer> but what module should i use if i was bored enough to want to code a mandelbrot in haskell
02:58:28 <swiert> You may want to check out some of the book reviews in JFP for comparison/inspiration.
02:58:32 <junyer> wanting to be able to zoom indefinitely, btw
02:58:46 <junyer> so there's arbitrary precision to spice things up
02:58:53 <dcoutts> swiert: yeah, I thought about the JFP example, I'll look in the library again tomorrow
02:59:04 <dcoutts> swiert: did you also get an email from the publisher with info about reviews? I seem to recall there was something else they requested be included.
02:59:12 <Thunder> junyer: Use Rational over Integer.
02:59:37 <swiert> dcoutts: Nope. I never got anything official.
02:59:42 <dcoutts> ok
02:59:48 <junyer> someone here suggested that last night
03:00:02 <junyer> and i thought it was great, but it kind of blows up by the fifteenth iteration
03:01:15 <dcoutts> junyer: yes, it will, the two components of the rational will grow in size exponentially (I think)
03:01:22 <Thunder> junyer: That's why Fractals are not computed using arbitary precision, but special numerical methods.
03:01:32 <junyer> doh
03:07:28 * mux hearts -cafe@
03:09:19 <junyer> http://spanky.triumf.ca/www/fractint/arb-prec.html
03:09:21 <lambdabot> Title: FRACTINT Arbitrary Precision Math Library
03:09:21 <junyer> shudder to think
03:12:42 <junyer> oh well
03:12:45 <junyer> thanks anyway, folks
03:13:03 <junyer> maybe i'll try doing something pointless with strings instead
03:22:52 <mux> > let inc = Endo (+1) in appEndo (inc `mappend` inc) 2
03:22:53 <lambdabot>  4
03:24:39 <mux> > let inc = Endo (+1) in appEndo (mconcat (replicate 3 inc)) 2
03:24:41 <lambdabot>  5
03:25:23 <mux> yay for monoids
03:27:18 <ivanm> whats the difference between a monad and a monoid?
03:28:12 <ski> a monad is a kind of monoid
03:28:25 <ivanm> and a monad is?
03:28:32 <ivanm> s/monad/monoid
03:29:20 <ski> in haskell, a monoid is a type, say 't', and two operations over it
03:29:24 <ski> mempty :: t
03:29:33 <ski> mappend :: t -> t -> t
03:29:52 <ski> such that 'mempty' is left and right unit of 'mappend', and 'mappend' is associative
03:30:04 <ivanm> *nod*... unit == identity?
03:30:25 <ski> e.g. the type 'Integer', with 'mempty = 0', 'mappend = (*)'
03:30:32 * ski nods
03:30:56 <dcoutts> swiert: any idea how to get a euro symbol using the packages in the TMR latex document style ?
03:31:15 <ski> arg, s/*/+/ of course
03:31:20 <ivanm> ski: OK, so its almost the definition of a group in normal maths?
03:31:21 <dcoutts> swiert: I can do \textsterling and \$ but can't find any for euro
03:31:29 <ivanm> just without the inverse?
03:31:34 <dmhouse> ivanm: exactly.
03:31:45 <ski> ivanm : yes, 'monoid' is a math concept .. a group is a monoid with inverse
03:31:57 <ivanm> is monoid from group theory as well?
03:32:11 <ivanm> so what differentiates a monad from a monoid?
03:32:14 <dmhouse> "Alternatively, a monoid is a semigroup with an identity element." -- Wikipedia, http://en.wikipedia.org/wiki/Monoid
03:32:15 <lambdabot> Title: Monoid - Wikipedia, the free encyclopedia
03:32:17 <ski> both monoids and groups are examples of algebras
03:32:33 <dmhouse> A monad is something completely different, algebraically.
03:32:43 <ski> other examples are e.g. rings and fields, vector spaces
03:33:01 <ivanm> *nod* OK
03:33:07 * ivanm hasn't done much pure math stuff
03:33:07 <dmhouse> To explain a monad algebraically you have to get properly into category theory. (E.g. http://en.wikibooks.org/wiki/Haskell/Category_Theory)
03:33:15 * ski nods
03:33:19 <ivanm> OK, I'll have a look at that
03:33:29 <ivanm> thanks dmhouse++ and ski++ !
03:33:30 <dmhouse> Sorry, that was meant to be Category_theory, with a lowercase 't'.
03:33:44 <ivanm> *shrug* I would have found it, now that I know it exists
03:34:05 <ski> ("<ski> a monad is a kind of monoid" was referring to the CT generalization of 'monoid' :)
03:34:34 <dcoutts> swiert: I hope it's ok to use the eurosym package
03:35:03 <dmhouse> ski: which is a single element (representing the operation), and an arrow for each of the elements in the underlying set of the monoid?
03:35:15 <dmhouse> I always thought that was a weird way of doing things.
03:35:20 <ski> basically, a haskell monad is a monoid, sortof, but on the type level, instead of the value level
03:35:28 <ivanm> *nod*
03:35:55 <ski> dmhouse : huh ?  ('which' being ?)
03:36:02 <dmhouse> ski: how, exactly? I haven't heard this interpretation before.
03:36:13 <dmhouse> ski: I thought that was the CT definition of a monoid.
03:36:44 <dmhouse> "More precisely, given a monoid (M,*), one can construct a small category with only one object and whose morphisms are the elements of M. The composition of morphisms is given by the monoid operation *."
03:38:51 <ski> in CT a monoid (in a category 'C' with a monoidal structure '1','*') consists of an object 'A', together with two morphisms 'unit : 1 -> A','mult : A * A -> A' satisfying three laws
03:39:52 <ski> ah, you're talking about "monoid as category" .. i was talking about "monoid in a category"
03:40:08 <dmhouse> Ah, right.
03:40:47 <ski> hm
03:41:35 <dmhouse> So in what was is a monad a type-level monoid?
03:41:55 <ski> actually, i just realized i was somewhat confused :)
03:42:29 <dmhouse> Hehe, okay. :)
03:42:29 <ski> a monad is a monoid in an endo-functor category
03:42:54 <ski> in the ordinary haskell case, we could call that category '* -> *'
03:43:20 <ski> the objects are type constructors of that kind, like 'Maybe','[]','(r ->)'
03:43:24 <ski> @kind Maybe
03:43:27 <lambdabot> * -> *
03:43:30 <dmhouse> Yep.
03:44:02 <dmhouse> The morphisms being natural transformations between those functors, like listToMaybe?
03:44:03 <ski> so 'm' being an object in that endofunctor category means that
03:44:06 <ski> m :: * -> *
03:44:33 <ski> (btw, the monoidal structure here is identity functor, and functor composition)
03:45:06 <ski> and the morphisms 'unit : 1 -> A','mult : A * A -> A' becomes
03:45:30 <ski> return :: id -> m
03:45:42 <ski> mult   :: m . m -> m
03:45:52 <ski> (^^ not actual haskell)
03:46:13 <dmhouse> Which we'd normally write as 'return :: forall a. id a -> m a' and 'mult :: forall a. m (m a) -> m a', right?
03:46:28 <dmhouse> And ta-da, you have return and join, defining a monad. Very nice! :)
03:46:29 <ski> morphisms in functor categories are natural transformations, which in this case means that the above really becomes
03:46:43 <ski> return_a :: id a -> m a
03:46:53 <ski> mult_a :: (m . m) a -> m a
03:46:58 <ski> i.e.
03:47:03 <ski> return_a :: a -> m a
03:47:09 <ski> mult_a :: m (m a) -> m a
03:47:26 <ski> (for each type 'a')
03:47:34 <ski> or (finally haskell), polymorphic functions
03:47:36 <dmhouse> Yep, and as you've got a component defined for every type 'a', you've essentially got a polymorphic function.
03:47:40 <ski> return :: forall a. a -> m a
03:47:53 <ski> mult   :: forall a. m (m a) -> m a
03:48:19 <ski> (and because of parametricity, we get the naturalness conditions for free)
03:48:22 <dmhouse> That's very cool.
03:49:02 <dmhouse> So does it hold in general that a monoid in an endo-functor category forms a monad?
03:49:23 <dmhouse> Yeah, I guess it must do.
03:49:31 <ski> one can use similar ideas to define a haskell type class of functors over '* -> *' and such things .. which can be useful
03:49:46 <ski> dmhouse : the other way around
03:49:55 <ski> er, misread, nvm
03:51:05 <dmhouse> Well, I'd expect it to hold both ways around. (I.e. a monad gives you a monoid in the category of the underlying functor of that monad, and given a monoid in a functor category, you can construct a monad.)
03:53:04 <swiert> dcoutts: Don't worry about using extra packages.
03:53:09 * ski nods
03:53:59 <swiert> dcoutts: If you don't do anything to crazy, I'm pretty sure I should manage to build a pdf from your sources.
03:54:05 <dmhouse> "They can be viewed as monoid objects in a category of endofunctors" -- Wikipedia. That's what I was trying to say :)
03:56:56 <ptolomy> Quick question: Is there a nicer way to express something like "let foo = maybeexpr in if isJust foo then othermaybeexpr (fromJust foo) else diffrntMaybeExpr"? that is, try one potentially failing monadic expression and do a different one if it doesn't work out?
03:57:15 <dmhouse> ptolomy: use a case expression.
03:57:21 <dmhouse> ?hoogle maybe
03:57:22 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
03:57:22 <lambdabot> Maybe :: module
03:57:22 <lambdabot> Prelude.Maybe :: data Maybe a
03:57:27 <dmhouse> Or that function.
03:58:24 <dmhouse> > let m = lookup 'a' [('a', 0), ('b', 1)] in case m of Just x -> show x; Nothing -> "Not found in map!"
03:58:26 <lambdabot>  "0"
03:59:11 <dmhouse> > let m = lookup 'a' [('a', 0), ('b', 1)] in maybes "Not found in map!" show m
03:59:12 <lambdabot>   Not in scope: `maybes'
03:59:16 <dmhouse> > let m = lookup 'a' [('a', 0), ('b', 1)] in maybe "Not found in map!" show m
03:59:18 <lambdabot>  "0"
03:59:54 <ski> @type mplus
03:59:57 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
04:00:27 <dmhouse> (maybe is called a 'catamorphism' on the Maybe datatype because it essentially acts as a case expression. Other examples are foldr, either.)
04:00:52 <dmhouse> (Actually, scratch foldr, things are more complicated with recursive datatypes.)
04:01:04 <dcoutts> swiert: ok :-)
04:01:35 <ski> @djinn (forall o. o -> (a -> o) -> o) -> Maybe a
04:01:36 <lambdabot> f _ = Nothing
04:01:39 <ski> bah
04:02:17 <dmhouse> ?djinn Maybe a -> (forall o. o -> (a -> o) -> o)
04:02:18 <lambdabot> -- f cannot be realized.
04:02:34 <ptolomy> well, part of the reason I'm looking for a diff'rent way is that I am trying not to restrict myself to the Maybe monad because I hear it is Good Style. I assume there is some sort of Control.Monad operation I should be using for nested monadic operations.
04:03:00 <dmhouse> ptolomy: depends, you might want to use monad transformers, but there might be an easier option. Paste some real code?
04:03:12 <ski> (dmhouse : i think 'catamorphisms' is definitely used for things like 'foldr' .. possibly also used for 'maybe' like things, for non-recursive ones, dunno)
04:03:37 <dmhouse> ski, yeah, I'm sure foldr's a catamorphism, but it doesn't act a case expression.
04:04:11 <dmhouse> I think a function is a catamorphism iff when you apply it to the constructors of that datatype you get the identity.
04:04:25 <ski> cata xs of [] -> 0; n:sum -> n+sum   -- :)
04:04:49 <dmhouse> I.e. foldr (:) [] == id, maybe Nothing Just == id, etc.
04:05:04 <ski> @src build
04:05:04 <lambdabot> build g = g (:) []
04:05:10 <ski> @type build
04:05:13 <lambdabot> Not in scope: `build'
04:05:19 <dmhouse> ski, but it'd have to be case xs of [] -> 0; n:sum -> n + foldr 0 (+) sum
04:05:32 <ski> @index GHC.Exts.build
04:05:32 <lambdabot> bzzt
04:05:53 <ski> @type GHC.Exts.build
04:05:56 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
04:06:23 <ski> dmhouse : using the usual 'case' syntax yes (i was considering a 'cata' syntax)
04:06:36 <dmhouse> ski: oh, gotcha :)
04:06:52 <hpaste>  ptolomy pasted "nested maybe example" at http://hpaste.org/1341
04:07:10 * ptolomy loves hpaste.
04:07:29 <dmhouse> Does it have an XMLRPC interface yet?
04:07:42 * dmhouse wants to be able to use C-c p to paste things, like he can for lisppaste
04:08:11 <dmhouse> ptolomy: what's the type of upped?
04:08:28 <joelr1> has anyone used parsec's buildExpressionParser?
04:08:54 <eumenides> for a /= b, i have a binary operator a -> b -> b, is there a fold for this?
04:09:16 <ski> one way is to use pattern guards
04:09:18 <ptolomy> upped is basically a wrapper around Map.lookup.. so it is upped :: ByteString -> m ByteString, iirc.
04:09:28 <ski> @type foldr
04:09:31 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
04:09:33 <ptolomy> I'm missing an arg in there..
04:09:34 <ski> eumenides : ^
04:09:46 <ptolomy> joelr1: I was playing with it yesterday, though not extensively.
04:09:47 <eumenides> ski: ahh i thought it was a's all the way
04:09:53 <ski> @type foldr1
04:09:56 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
04:10:19 <ski> > foldr (:) [] "dallas"
04:10:20 <joelr1> ptolomy: i can't figure out how to integrate an expression that's expression followed by a keyword. gives me a an indefinite loop
04:10:20 <lambdabot>  "dallas"
04:10:26 <ski> > foldl (flip (:)) [] "dallas"
04:10:28 <lambdabot>  "sallad"
04:10:30 <dmhouse> ptolomy: and what's the type of getVar (specifically, what's the type of the list you're recursing over?)
04:10:38 <joelr1> maybe it has to be plugged in as postfix or something
04:10:47 <dmhouse> ?src reverse
04:10:47 <lambdabot> reverse = foldl (flip (:)) []
04:10:52 * ptolomy ghcis..
04:11:42 <ptolomy> getVar :: (Monad m) => [TclEnv (a record of maps)] -> ByteString -> m ByteString
04:11:42 <ski> ptolomy : you are giving 'upped' two arguments there ..
04:12:19 <ptolomy> ski: Yeah, upped :: (Monad m) => ByteString -> TclEnv -> m ByteString
04:13:30 <dmhouse> So upped unwraps the record constructor and uses Map.lookup?
04:13:43 <ptolomy> joelr1: hmm.. followed by a keyword is beyond the scope of my experience with that thing..
04:13:49 <ptolomy> That is correct.
04:14:32 <ptolomy> upped s e = Map.lookup s (upMap e) -- upMap is a field accessor thing.
04:15:17 <dmhouse> Argh, firefox keeps crashing.
04:15:19 <Thunder> @pl upped s e = Map.lookup s (upMap e)
04:15:20 <lambdabot> upped = ((Map .) .) . (. upMap) . lookup
04:15:51 <Thunder> @pl upped s e = MapLookup s (upMap e)
04:15:52 <lambdabot> upped = (. upMap) . MapLookup
04:16:49 <ptolomy> I realize that this is a rather trivial little snippet, but it seemed like a place where I'd be able to nicely use msum or join or something and I figured it'd be educational to figure out how as similar patterns appear elsewhere.
04:17:01 <dmhouse> I does seem like it could be shorter.
04:19:29 <dmhouse> I think the paradigm is: map over a list until a certain condition (isNothing upval) is met, then return some value based on the element you've got down to.
04:19:47 <dmhouse> If you reach the end of the list without the condition being met, return a default value (fail "...").
04:20:08 <ndm> @tell chessguy thanks for the information, works for me but i bet thats the servers/proxies we are going through - it really needs a proper HTTP library behind it
04:20:09 <lambdabot> Consider it noted.
04:21:44 <dmhouse> ?hoogle untilM
04:21:45 <lambdabot> No matches found
04:21:50 <dmhouse> ?hoogle whileM
04:21:51 <lambdabot> No matches found
04:22:00 <dmhouse> Hrm, I'm sure there's a function called something like that
04:22:12 <ndm> @hoogle repeatM
04:22:13 <lambdabot> No matches found
04:26:04 <ptolomy> semi-unrelated: I have been using 'error' for errors.. the Right Way (or one of them) would be to have my interpreter monad be an instance of MonadError, yes?
04:27:29 <chessguy> ?seen ndm
04:27:30 <lambdabot> ndm is in #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell. I last heard ndm speak 6s ago.
04:27:53 <chessguy> 'morning
04:27:54 <lambdabot> chessguy: You have 1 new message. '/msg lambdabot @messages' to read it.
04:27:58 <ndm> chessguy: thanks for the report, i suspect its the openURL function, which is dubious at best
04:28:10 <ndm> chessguy: not much i can do, other than wait for a proper HTTP library for Haskell
04:28:29 <chessguy> hmm, what's so dubious about it?
04:29:32 <ndm> chessguy: it talks HTTP, but it doesn't really know HTTP, so guesses
04:30:21 <ndm> chessguy: alas haskell (currently) lacks a good http library - if you use wget it should work though, then do the parsing after
04:31:11 * malcolmw thinks we might see a better HTTP library result from GSoC
04:31:25 <chessguy> that would be nice
04:32:06 <dmhouse> Wasn't HaskellNet last year meant to address that?
04:32:14 * dmhouse hasn't seen anything of HaskellNet since last summer
04:32:15 <chessguy> i guess the haskell projects are getting announced today?
04:32:54 <siti> the current http library leaks file descriptors somehow...
04:43:01 <desp> malcolmw: hopefully :)
04:43:38 * desp is going to work on that, if accepted.
04:43:52 <dmhouse> desp: good luck :)
04:44:01 <dmhouse> And make sure you keep the channel posted!
04:44:34 <mux> anyone with commit privileges to GHC libraries repo?
04:44:50 <desp> dmhouse: thanks
04:46:13 <mux> this Cforall language looks real weird, did you guys have a look at it?
04:46:24 <dmhouse> mux: link?
04:46:32 <mux> http://plg.uwaterloo.ca/~cforall/
04:46:33 <lambdabot> Title: Cforall Home Page
04:46:35 <mux> it's on LtU
04:47:15 <mux> ``Cforall extends the C type-system using overloading, parametric polymorphism, and type generators. The] Cforall type system is based on parametric polymorphism, the ability to declare functions with type parameters, rather than an object-oriented type system.''
04:47:42 <dmhouse> That doesn't sound like an "evolutionary, not revolutionary" change to me.
04:47:47 * mux nods
04:48:29 <mux> when it comes to improving C, this sounds like doomed to me; I think cyclone takes a much better approach
04:50:51 <TomMD> 'd' is the best language
04:51:47 <mux> hah, D isn't much
04:51:57 <TomMD> (that was sarcasm)
04:52:07 <Igloo> ndm: I don't know what "this" was, but the Setup.hs files from core+extralibs should be -Wall clean now, yes (Win32 might not be done yet)
04:52:13 <mux> yeah, I interpreted it as such :-)
04:53:30 <mux> Igloo: hey! could I have you to take a look at ticket 1222? I see you have already touched the ticket in the past
04:54:31 <Igloo> mux: Was it discussed on the libraries list?
04:54:45 <mux> Igloo: yes
04:54:53 <mux> want the mail id?
04:55:25 <Igloo> mux: Can you add a summary of the discussion, and a link to the first message in the list archives, to the bug please?
04:55:47 <mux> Igloo: sure!
04:55:54 <Igloo> thanks
04:56:32 <mux> Igloo: mmm, actually, there have been no answers on my libraries@ post yet. there were answers to the same post on -cafe@ though
04:57:09 <Igloo> mux: As long as the proposal mail went to the libraries list, that's OK. Just summarise any discussion that there was  :-)
04:57:13 <mux> Igloo: so there's no summary to add I guess, but I still can add a link to the first mail in the archives if you want
04:57:17 <mux> okay :-)
04:59:52 <rahikkala> Is (\n -> (replicateM n (randomRIO (0,1))) >>= print . length) a good way to benchmark the speed of the PRNG?
05:02:45 <mux> Igloo: sorry, I'm probably being stupid but I can't figure how the hell I can modify this ticket in Trac (I'm logged in)
05:03:19 <Igloo> mux: Oh, what's your username?
05:03:24 <mux> hmm, maybe I'm not logged in using the correct account
05:03:27 <mux> Igloo: mux
05:03:46 <Igloo> mux: OK, it should work now
05:04:01 <mux> Igloo: cheers, it does
05:04:10 <Igloo> mux: Sorry, all accounts now need to be added to a group to be able to edit things, to combat spam
05:04:20 <mux> oh, okay
05:05:38 <mux> Igloo: ticket modified
05:08:10 <dozer> is there a methodology for mapping from UML to haskell?
05:08:12 <Igloo> mux: Great, thanks; patch applied!
05:08:28 <earthy> dang. my generic programming-fu is lacking
05:08:43 <mux> Igloo: awesome :-)
05:10:09 <earthy> dozer: not really
05:10:26 <dmhouse> earthy: what makes you say that? (About the programming-fu.)
05:10:27 <earthy> dozer: you could try encoding the objects in your UML using one of the object encodings
05:10:34 <earthy> dmhouse: I'm trying to write a generic zipper
05:10:39 <earthy> and failing
05:10:54 <dmhouse> earthy: err, well that doesn't sound very easy!
05:11:07 <dmhouse> ?wiki Zipper_monad
05:11:08 <lambdabot> http://www.haskell.org/haskellwiki/Zipper_monad
05:11:09 <dozer> I'm starting out from http://owl1_1.cs.manchester.ac.uk/owl_specification.html
05:11:12 <lambdabot> Title: OWL 1.1 Web Ontology Language: Structural Specification and Functional-Style Syn ...
05:11:21 <dmhouse> earthy: have you seen that?
05:13:03 <earthy> nope, but it is much like the thing I'm trying to avoid. :)
05:13:15 <earthy> and I don't want to start grokking oleg ;)
05:13:15 <dmhouse> Oh?
05:13:25 <earthy> this requires an explicit context type
05:13:32 <earthy> which I don't think is necessary
05:13:33 <dmhouse> I wrote Zipper_monad, not Oleg :)
05:13:53 <earthy> zipper_monad requires a Cxt type that encapsulates the possible contexts
05:14:10 <earthy> I don't want to have to define such a type
05:14:17 <Nanar> Hi, is there any module to play with bit set (aka 2 & 3, 2 or 3) ?
05:14:20 <earthy> and I've seen oleg's delimited continuation stuff
05:14:25 <earthy> but I don't want to try grokking that. :)
05:14:36 <dons> Nanar: Data.Bits
05:14:41 <dons> > 2 .&. 3 :: Int
05:14:42 <lambdabot>  2
05:14:48 <dons> > 2 .|. 3 :: Int
05:14:50 <Nanar> dons: thanks
05:14:50 <lambdabot>  3
05:14:53 <dons> ?docs Data.Bits
05:14:54 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
05:14:54 <earthy> so I'm going to play around some more with Data.Dynamic and Data.Typeable and Data.Generics
05:15:10 <dons> be gentle with them, earthy :-)
05:15:29 <dmhouse> earthy: but a zipper is, in essence, a substructure + a context.
05:15:41 <Nanar> dons: wonderfull, I was looking for that
05:15:46 <dozer> earthy: I don't realy want objects in haskell, I'd rather have natural haskell data types (data type constructors or classes) that do a job close enough to that UML
05:15:54 <Nanar> dons: (the doc)
05:16:08 <dmhouse> earthy: unless you intend to derive the type of the context from the substructure (which can be done, via differentiation of datatypes), surely you'd need to encode the type of the context, too?
05:16:55 <earthy> nah, my current thinking is to turn the constructor into a Constr, and the siblings into Dynamics
05:17:20 <earthy> then going up I can reconstruct by recovering from the Dynamics and the Constr
05:17:42 <dmhouse> Which constructor?
05:17:44 <earthy> basically, this amounts to doing type-remembering type-erasure going down the zipper
05:17:53 <earthy> and then reconstructing going back up
05:18:09 <earthy> owh, when I go down the zipper, I pass through a toplevel constructor
05:18:16 <earthy> which I need to store, some way or another
05:19:40 <earthy> hm...
05:19:44 * earthy ponders
05:20:56 <lumi> Hi, I'm trying to teach people where I work Haskell, and I need a decent homework for them as a one week milestone
05:21:37 <lumi> I was wondering if someone were willing to suggest something?
05:21:38 <xs> lumi: scheme in 48 hours?
05:22:03 <lumi> xs: Interesting idea, I don't want to overload them though
05:22:47 <xs> lumi: well, this has some exercises that don't look too bad. http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html maybe just a part of it would do.
05:22:49 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/l986o
05:23:00 <lumi> xs: btw, I took the "optional" branches, and spent another coupla days implementing and Num-, Integral- and Rational-ifying the number tower
05:23:08 <lumi> Not 48 hours at all
05:23:12 <xs> ahh.. okay.. :)
05:23:27 <lumi> Thanks, I'll look :)
05:26:12 <joelr1> @tell sorear stefan, do you have any examples of arithmetic expression parsing with parsec but without buildExpressionParser?
05:26:12 <lambdabot> Consider it noted.
05:31:07 <joelr1> @tell joelr1 wazzup, dude?
05:31:07 <lambdabot> You can tell yourself!
05:31:13 <joelr1> hehe
05:33:02 <Philippa> joelr1: just use chainl1 and relatives
05:33:26 <joelr1> Philippa: wish i knew how
05:33:38 * LoganCapaldo did the arithmetic parsing the lame way
05:34:08 <LoganCapaldo> joelr1: would you like to see?
05:34:26 <joelr1> LoganCapaldo: umm... i'd rather see it done properly :D
05:34:28 <Philippa> expression = term `chainl1` addOp; term = factor `chainl1` mulOp; factor = fitb
05:34:44 <LoganCapaldo> hehe
05:34:59 <LoganCapaldo> by lame I just mean what phillippa just did minus chainl1
05:35:00 <joelr1> Philippa: where does precedence and associativity come into play?
05:35:12 <LoganCapaldo> you encode it into the grammar
05:35:27 <LoganCapaldo> an expression is a sequence of additions of multiplications
05:35:48 <Philippa> right
05:36:03 <Philippa> the associativity's in the chain/l/ bit
05:36:07 <LoganCapaldo> (where a multiplication can be a parenthesized expression or a single number or a * b )
05:36:55 <joelr1> Philippa: what is the difference between term and factor in your case?
05:37:27 <Philippa> factor's highest precedance - it's where you shove your int literal and your parens and possibly your unary minus
05:37:33 <joelr1> Philippa: ok
05:38:22 <Philippa> if you expanded out the definitions, you'd get the code for factor on the innermost of a pile of parens
05:38:52 <joelr1> cool
05:40:39 <hpaste>  LoganCapaldo pasted "joelr1: thusly" at http://hpaste.org/1342
05:40:47 <vincenz> moin
05:41:35 <Philippa> ...talk about overkill, my desk calculators tend not to bother with a separate AST on the grounds that if I'm doing that I may as well start with a \calc
05:41:38 <joelr1> LoganCapaldo: cool, thanks!
05:42:00 <LoganCapaldo> Philippa: overkill is my middle name :)
05:42:12 <LoganCapaldo> also it was to learn parsec mostly :)
05:42:14 <joelr1> LoganCapaldo: what's the point of data Expr a as opposed data Expr = Int Integer | Double double | ...
05:42:33 <joelr1> LoganCapaldo: i supposed you are not mixing ints and doubles, are you?
05:42:33 <LoganCapaldo> in the beginning I wasn't sure if I wanted to use rationals or something
05:43:22 <LoganCapaldo> no I'm not mixing ints and doubles
05:43:54 <LoganCapaldo> the number parser can obviously be vastly simplified by using parsec's builtin functions better :)
05:44:38 <joelr1> ok
05:44:46 <joelr1> LoganCapaldo: that was a good example, thanks
05:45:00 <LoganCapaldo> np
05:45:01 <joelr1> does hpaste delete pastes?
05:45:13 <joelr1> i wonder if i can just bookmark a paste
05:51:08 <chessguy> @pl \n -> (-1)^(n+1) * 3*n
05:51:09 <lambdabot> (*) =<< (3 *) . (subtract 1 ^) . (1 +)
05:55:51 <dons> joelr1: yeah, you can bookmark.
05:55:57 <dons> the names are stable for all of the universe.
05:56:22 <ivanm> or until the server breaks down, whichever comes first
05:56:24 <joelr1> dons: so is hpaste is expected to blow up at some point?
05:56:27 <LoganCapaldo> dons: Then I guess I shouldn't have pasted that for a second time...
05:56:28 <joelr1> of data overload
05:56:32 <chessguy> @pl filter (<= 50) $ filter (>= 15)
05:56:33 <lambdabot> filter (<= 50) (filter (>= 15))
05:56:40 <LoganCapaldo> Since it was already there
05:56:46 <chessguy> @pl filter (<= 50) . filter (>= 15)
05:56:47 <lambdabot> filter (<= 50) . filter (>= 15)
05:57:00 <dons> joelr1: wel, either all bits in the universe will be kept on hpaste, or heat death, whichever happens first.
05:57:16 <joelr1> dons: didn't know that :D
05:57:26 <dons> we like to aim high!
05:58:03 <chessguy> > filter ((>=5) && (<=10)) . map (^2)) [1..5]
05:58:04 <lambdabot>  Parse error
05:58:30 <chessguy> > filter ((>=5) && (<=10)) $ map (^2) [1..5]
05:58:31 <lambdabot>      The section `(>= 5)' takes one argument,
05:58:32 <lambdabot>     but its type `Bool' has none
05:58:58 <LoganCapaldo> chessguy: (->e) Reader monad maybe?
05:58:58 <mauke> > filter (liftM2 (&&) (>=5) (<=10)) . map (^2) $ [1..5]
05:59:00 <lambdabot>  [9]
05:59:04 <dmhouse> > takeWhile (<= 10) . dropWhile (<= 5) $ map (^2) [1..5]
05:59:05 <chessguy> @pl \n -> (n >= 5) && (n <= 10)
05:59:06 <lambdabot> liftM2 (&&) (>= 5) (<= 10)
05:59:06 <lambdabot>  [9]
05:59:26 <LoganCapaldo> yeah what mauke said :)
06:00:25 <mauke> > filter (flip all [(>=5), (<=10)] . flip id) . map (^2) $ [1..5]
06:00:27 <lambdabot>  [9]
06:00:38 <LoganCapaldo> @ty all
06:00:41 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
06:00:47 <LoganCapaldo> or what I know what all is
06:02:26 <LoganCapaldo> > filter (`elem` [5..10]) $ map (^2) [1..5]
06:02:28 <lambdabot>  [9]
06:03:08 <LoganCapaldo> > filter (flip elem [5..10]) $ map (^2) [1..5]
06:03:09 <lambdabot>  [9]
06:03:43 <ivanm> with darcs, what does the "--partial" flag do/mean?
06:05:42 <joelr1> @undo return $ \x -> UnOp UniMinus x
06:05:42 <lambdabot> return $ \ x -> UnOp UniMinus x
06:06:01 <joelr1> @undo do { return $ \x -> UnOp UniMinus x }
06:06:02 <lambdabot> return $ \ x -> UnOp UniMinus x
06:06:07 <joelr1> doh
06:06:10 <joelr1> @pl return $ \x -> UnOp UniMinus x
06:06:11 <lambdabot> return (UnOp UniMinus)
06:10:45 <earthy> fuck it, I'm giving up
06:10:48 <joelr1> @pl reservedOp "-" >> return (UnOp UniMinus)
06:10:49 <lambdabot> reservedOp "-" >> return (UnOp UniMinus)
06:13:17 <joelr1> @pl f a = f1 a c
06:13:18 <lambdabot> f = flip f1 c
06:15:30 <joelr1> @pl op a b = reservedOp a >> return b
06:15:31 <lambdabot> op = (. return) . (>>) . reservedOp
06:15:36 <joelr1> ugh
06:17:53 <ivanm> what's the difference between the different Array types?
06:21:23 <joelr1> @pl left a = flip Infix AssocLeft $ choice a
06:21:24 <lambdabot> left = flip Infix AssocLeft . choice
06:22:23 <dons> ndm, use 'darcs dist' instead
06:22:36 <dons> it'll just create a (valid) tarball of your tagged (I presume) darcs repo
06:22:39 <dons> host the result.
06:23:00 <ndm> dons: whats the advantage of cabal sdist over darcs dist?
06:23:01 <dons> ndm, $ darcs dist --help
06:23:10 <dons> cabal uses just the .cabal file to work out what files to use
06:23:14 <dons> darcs uses the darcs repo info
06:23:22 <dons> so unless you keep the two in sync, darcs dist knows more.
06:23:26 <ndm> dons: i've used darcs dist before, and it does work, i just wondered what cabal wanted differently
06:23:34 <ndm> so cabal sdist is inferior to darcs dist?
06:23:39 <dons> it just doesn't know about all the files unless you list them.
06:24:01 <dons> they should be identical, but you need to maintain the list of files yourself, in the .cabal file
06:24:02 <ndm> dcoutts: did you upload filepath to hackage?
06:24:08 <dons> this is good, but lazy people like my just use darcs dist
06:24:18 <fasfafa> http://goldg.no-ip.biz Join Please
06:24:22 <lambdabot> Title: GoldGame - [ Главная ]
06:24:23 <fasfafa> http://goldg.no-ip.biz Join Please
06:24:23 --- mode: ChanServ set +o dons
06:24:26 <lambdabot> Title: GoldGame - [ Главная ]
06:24:26 --- mode: dons set +b *!*n=fsafasf@89.191.106.*
06:24:26 --- kick: fasfafa was kicked by dons (dons)
06:24:28 --- mode: ChanServ set -o dons
06:25:03 <ivanm> what's the difference between the different Array types?
06:25:16 <dons> different strictness, and complexity.
06:25:17 <Igloo> You ought to use cabal sdist when making cabal source packages, as it helps ensure that your cabal file is right
06:25:20 <dons> there's a wiki page on the difference.
06:25:38 <ivanm> dons: OK, I'll have a look
06:25:44 <dons> igloo offers sage advice. we should have mkcabal generate the proper file listing from the darcs info..
06:25:50 <Igloo> There might be a way to have sdist include generated files (like the result of running alex/happy), too
06:26:53 <ndm> Igloo: one works, one doesn't - to me thats the biggest difference...
06:28:35 <dons> cabal works if your .cabal file is right.
06:28:46 <ndm> dons: doesn't quite work, the tarball created by darcs has slightly the wrong format and the wrong leading directory name
06:28:58 <Igloo> dons: He has a deficient tar
06:29:01 <dons> bug report then. i've not seen this.
06:29:03 <dons> ah.
06:29:09 <dons> so tar doesn't work on ndm's system?
06:29:16 <Igloo> tar -z doesn't
06:29:23 <ndm> dons: tar works fine, it just follows the POSIX standard too closely
06:29:33 <ndm> damn standards are their interoperability benefits!
06:29:34 <dons> i suggesting updating to a developer's OS and toolset
06:29:37 <Igloo> tar isn't POSIX AFAICS
06:29:51 <dons> I here apple machines are popular these days.
06:29:59 <dons> and tar even works :-)
06:30:24 <Igloo> It's no on http://www.opengroup.org/onlinepubs/009695399/idx/utilities.html at any rate
06:30:25 <lambdabot> Title: Utilities
06:30:39 <joelr1> @pl unary a = op reservedOp a UnOp
06:30:40 <lambdabot> unary = flip (op reservedOp) UnOp
06:30:45 <yiwin> @where darc
06:30:45 <lambdabot> I know nothing about darc.
06:30:52 <dons> we could tar and zip seperately, I presume?
06:31:01 <dons> ndm, perhaps a small patch to cabal to tar first, then zip?
06:31:04 <yiwin> @where darcs
06:31:04 <lambdabot> http://darcs.net/
06:31:05 <ndm> dons: tar works perfectly fine
06:31:15 <ndm> dons: a small patch to cabal tends to take a large amount of time...
06:31:33 <dons> no. this is just system "tar -z" --> system "tar" ; system "zip " ..
06:31:49 <dons> it might be faster to install linux though.
06:31:54 <dons> then programs would work.
06:32:21 <dons> also, it has been established that types check better when you can modify the kernel source.
06:32:47 <ndm> remember that this MS company is pretty good to Haskell, and spends more Haskell $'s than Google by a long way
06:32:55 <ndm> I think we should support them by all buying copies of Vista
06:33:10 <dons> they're funneling it all into F# though.
06:33:15 <ndm> GHC?
06:33:25 <dons> $'s
06:33:55 <ndm> Haskell ВЈ's doesn't sound like the right expression
06:34:00 <dons> dcoutts: a challenge! http://programming.reddit.com/goto?id=1gnx2 " Fast public domain JPEG, PNG and ZLIB decoder in 2000 lines of C"
06:34:09 <dons> 2000 ! bloat!
06:34:14 <opqdonut> yes!
06:34:31 <dons> png is easy, zlib is pretty simple, no, Igloo ?
06:34:42 <DRMacIver> Yeah. You could do that in 4 lines of Haskell! :)
06:34:42 <dons> and there's a jpeg one in malcolmw's paper
06:34:47 <dons> can't be more than 300 lines all up.
06:37:18 <dylan> once I finish this chat client using vty, I should try to write a curses interface to mplayer.
06:37:27 <ndm> I wonder if we could come up with a chart of which company spends most money on Haskell...
06:37:29 <dylan> well, s/curses/vty/
06:37:40 <ndm> 2000 lines for decoding only? I'd want compressing as well in that space
06:38:54 <earthy> hm. Jeroen Fokker used just over 200 lines for his JPEG decoder in Gofer
06:39:08 <earthy> ofcourse, he still had to define . and $ :)
06:39:26 <joelr1> @pl op p a ctor b = p a >> return (ctor b)
06:39:27 <lambdabot> op = flip flip (return .) . (((.) . (.) . (>>)) .)
06:41:27 <joelr1> @pl op ctor b = return (ctor b)
06:41:28 <lambdabot> op = (return .)
06:42:07 <joelr1> @pl op ctor a b = return (ctor a b)
06:42:08 <lambdabot> op = ((return .) .)
06:43:03 <joelr1> is there some idiom to express this?
06:43:37 <opqdonut> return $ ctor a b?
06:43:54 <joelr1> opqdonut: a or a b or a b c or a b c d, etc.
06:44:06 <joelr1> opqdonut: variable # of args to ctor
06:44:48 <ivanm> newMat v n = IArray.fromList [((r,c),v) | r <- [1..n], c <- [1..n]] <- what's wrong with this?
06:45:11 <ivanm> I've imported Data.Array.IArray, but it keeps complaining about IArray.fromList not being in scope :s
06:45:23 <opqdonut> op ctor = (return.ctor)
06:45:34 <opqdonut> that should work
06:45:37 <mauke> shouldn't that be Data.Array.IArray.fromList?
06:45:37 <opqdonut> i guess
06:45:49 <joelr1> :t op ctor = (return . ctor)
06:45:52 <lambdabot> parse error on input `='
06:46:03 <ivanm> mauke: doesn't work either :(
06:46:34 <mauke> oh, it's listArray
06:46:39 <ivanm> @hoogle fromList
06:46:40 <lambdabot> Data.HashTable.fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
06:46:40 <lambdabot> Data.IntMap.fromList :: [(Key, a)] -> IntMap a
06:46:40 <lambdabot> Data.IntSet.fromList :: [Int] -> IntSet
06:46:52 <joelr1> opqdonut: doesn't work
06:46:59 <ivanm> oh... why did I have fromList in my old code then?
06:47:25 <ivanm> @hoogle listArray
06:47:25 <lambdabot> Array.listArray :: Ix a => (a, a) -> [b] -> Array a b
06:47:26 <lambdabot> Data.Array.listArray :: Ix i => (i, i) -> [e] -> Array i e
06:47:26 <lambdabot> Data.Array.IArray.listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
06:47:37 <opqdonut> :t let c = a->b->c in (return.c)
06:47:40 <lambdabot> parse error on input `->'
06:47:48 <opqdonut> errrr
06:48:00 <opqdonut> :t return.(c::a->b->c)
06:48:03 <lambdabot> Not in scope: `c'
06:48:12 <opqdonut> gyah
06:48:16 <opqdonut> whatever
06:48:47 <mauke> (Monad m) => (a -> b -> c) -> m (a -> b -> c)
06:48:52 <mauke> er
06:48:52 <joelr1> opqdonut: the easiest thing is @pl
06:49:23 <joelr1> @pl op ctor a b = return $ ctor a b
06:49:24 <lambdabot> op = ((return .) .)
06:50:47 <joelr1> @pl op p a ctor b = p a >> return (ctor b)
06:50:48 <lambdabot> op = flip flip (return .) . (((.) . (.) . (>>)) .)
06:50:53 <joelr1> dammit
06:51:28 <opqdonut> :D
06:51:42 <joelr1> ndm: galois?
06:51:43 <chessguy> what's wrong with p a >> return (ctor b)
06:51:58 <joelr1> chessguy: need it to work for any arity of ctor
06:52:00 <chessguy> @redo p a >> return (ctor b)
06:52:01 <lambdabot> do { p a; return (ctor b)}
06:52:21 <joelr1> chessguy: but can't figure it out
06:52:41 <opqdonut> won't return.ctor work for any arity?
06:52:43 <joelr1> chessguy: op p a ctor = p a >> (return . ctor) -- doesn't work
06:52:44 <chessguy> hmm
06:53:06 <chessguy> @pl \b -> p a >> return (ctor b)
06:53:07 <lambdabot> (p a >>) . return . ctor
06:53:18 <opqdonut> > (return.(+1)) 1 ::[Int]
06:53:20 <lambdabot>  [2]
06:53:26 <opqdonut> > (return.(+)) 1 1 ::[Int]
06:53:27 <lambdabot>  Couldn't match expected type `[Int]' against inferred type `a -> a'
06:53:29 <chessguy> joelr1: is that what you want?
06:53:37 <opqdonut> > ((return.(+)) 1 1) ::[Int]
06:53:39 <lambdabot>  Couldn't match expected type `[Int]' against inferred type `a -> a'
06:53:40 <opqdonut> hmm seems not
06:53:45 <joelr1> chessguy: i think so. an extra dot before return... interesting
06:53:46 <dmhouse> joelr1: what is the type of the function you're trying to build?
06:54:17 <joelr1> dmhouse: op p a ctor a b c d e f = p a >> return (ctor a b c d e f)
06:54:27 <joelr1> dmhouse: make that any arity of ctor
06:54:42 <dmhouse> joelr1: the problem is, op doesn't have a well-defined type.
06:55:12 <dmhouse> As the type of op depends on the type of ctor.
06:55:17 <chessguy> @type ?p ?a >> return (?ctor ?b)
06:55:20 <lambdabot> forall t (m :: * -> *) a t1 b. (?p::t -> m a, ?a::t, ?ctor::t1 -> b, ?b::t1, Monad m) => m b
06:55:33 <joelr1> dmhouse: i want it to be as general as possible
06:55:47 <dmhouse> If ctor can have an arbitrary arity, then ctor can have an arbitrary type, which means that op has an arbitrary type.
06:55:52 <joelr1> dmhouse: the type dependency on ctor is fine with me, the question is arity
06:55:59 <chessguy> joelr1: you're not even using op on the right-hand side
06:56:11 <joelr1> op = function
06:56:16 <dmhouse> There are, however, techniques for encoding polyadic functions.
06:56:20 <chessguy> oh, right
06:57:06 <dmhouse> *Poly-variadic functions
06:57:11 <joelr1> that takes a parser, runs that and returns constructor with arguments
06:57:52 <joelr1> like this: op p ctor a b c = p >> return (ctor a b c)
06:58:03 <joelr1> p a was wrong, i need just "p"
06:58:20 <joelr1> @pl op p ctor a b c = p >> return (ctor a b c)
06:58:21 <lambdabot> op = (. (((return .) .) .)) . (.) . (.) . (.) . (>>)
06:58:24 <joelr1> ouch
06:58:47 <dmhouse> joelr1: try http://okmij.org/ftp/Haskell/types.html#polyvar-fn
06:58:49 <lambdabot> Title: Haskell Programming: Types
06:59:36 <joelr1> dmhouse: the return type of op is always the same
06:59:46 <joelr1> it depends on the ctor but not on arguments of ctor
07:00:09 <joelr1> dmhouse: assume expr AST
07:00:13 <dmhouse> joelr1: do you want op to work like the following?
07:00:28 <joelr1> with constructor such as UnOp x, Mul x y, Div x y
07:00:30 <dmhouse> op foo bar my_unary_ctor arg
07:00:37 <dmhouse> op foo bar my_binary_ctor arg1 arg2
07:00:46 <dmhouse> op foo bar my_ternary_ctor arg1 arg2 arg3
07:00:46 <dmhouse> ...
07:00:47 <dmhouse> ?
07:00:49 <joelr1> ctor can be either UnOp, Mul or Div but it can take either 1 or 2 args
07:00:56 <joelr1> dmhouse: yes to your question
07:01:13 <dmhouse> joelr1: then you'll need to use typeclass tricks. Polyvariadic functions aren't easily expressed in Haskell.
07:01:22 <chessguy> joelr1: so what's wrong with (p a >>) . return . ctor
07:01:25 <dmhouse> joelr1: the link I pointed you to has the trick.
07:01:38 <dmhouse> :t \p a ctor -> (p a >>) . return . ctor
07:01:41 <lambdabot> forall t a b (m :: * -> *) a1. (Monad m) => (t -> m a) -> t -> (a1 -> b) -> a1 -> m b
07:01:47 <joelr1> chessguy: let me try that
07:01:50 <dmhouse> chessguy: that requires that ctor is unary.
07:02:01 <chessguy> eh?
07:02:07 <dmhouse> (Takes only a single argument.)
07:02:11 <joelr1> chessguy: wins
07:02:24 <joelr1> i think. let me try further
07:02:37 <chessguy> dmhouse: how do you figure that it requires ctor to be unary?
07:03:04 <chessguy> @type (?p ?a >>) . return . ?ctor
07:03:07 <lambdabot> forall t a b (m :: * -> *) a1. (?p::t -> m a, ?a::t, Monad m, ?ctor::a1 -> b) => a1 -> m b
07:03:12 <dmhouse> chessguy: look at the type lambdabot printed out. The type of ctor was inferred to be (a1 -> b)
07:03:18 <chessguy> hmm
07:04:17 <opqdonut> but couldn't b be e.g (c->d)?
07:04:22 <dmhouse> > (\f -> not . f) fromEnum 0
07:04:23 <lambdabot>  Couldn't match expected type `Bool' against inferred type `Int'
07:04:27 <dmhouse> > (\f -> not . f) toEnum 0
07:04:29 <lambdabot>  True
07:04:40 <dmhouse> > (\f -> not . f) (==) 0 0
07:04:41 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `Bool'
07:04:59 <dmhouse> \f -> not . f is the same as \f x -> not (f x).
07:05:27 <chessguy> @type (putStrLn 2 >>) . return . (+)
07:05:30 <lambdabot>     No instance for (Num String)
07:05:30 <lambdabot>       arising from the literal `2' at <interactive>:1:10
07:05:31 <dmhouse> So (\f -> not . f) arg1 arg2 arg3 is a type error, just as (\f x -> not (f x)) arg1 arg2 arg3 is a type error.
07:05:42 <joelr1> dmhouse: oh, well :-(
07:05:45 <chessguy> @type (putStrLn "2" >>) . return . (+)
07:05:48 <lambdabot> forall a. (Num a) => a -> IO (a -> a)
07:05:56 <chessguy> dmhouse: ^^
07:06:04 <dmhouse> chessguy: yes, and?
07:06:17 <dmhouse> chessguy: I think what you're missing is that (.) joins two _unary_ functions together. Nothing else.
07:06:23 <chessguy> (+) isn't unary
07:06:40 <dmhouse> ?type return . (+)
07:06:43 <lambdabot> forall (m :: * -> *) a. (Monad m, Num a) => a -> m (a -> a)
07:06:59 <dmhouse> ?type (return . (+)) 2 3
07:07:02 <lambdabot> forall a. (Num a) => a -> a
07:07:20 <dmhouse> Oh, that's because (a ->) is a monad.
07:07:29 <dmhouse> ?type ((return :: a -> IO a) . (+)) 2 3
07:07:32 <lambdabot>     Couldn't match expected type `t1 -> t'
07:07:32 <lambdabot>            against inferred type `IO (a -> a)'
07:07:44 <chessguy> hm
07:07:45 <dmhouse> (return . (+)) 2 3
07:07:56 <dmhouse> = (\x -> return ((+) x)) 2 3
07:08:03 <dmhouse> = (return ((+) 2)) 3
07:08:06 <dmhouse> = type error.
07:08:58 <chessguy> interesting
07:09:17 <dmhouse> Say you want to define a synonym for map. You might say:
07:09:36 <dmhouse> Err, not quite a synonym. A map that also computes the sum, say.
07:09:42 <dmhouse> myMapWithSum f xs = sum (map f xs)
07:09:53 <dmhouse> Now, the right-hand side does _not_ reduce to sum . map.
07:10:01 <dmhouse> ?pl \f xs -> sum (map f xs)
07:10:02 <lambdabot> (sum .) . map
07:10:22 <dmhouse> Because map is a binary function, and sum in a unary one, so you can't just (.) them together.
07:10:39 <dmhouse> You can reduce it to myMapWithSum f = sum . map f, though.
07:10:56 <dmhouse> Or you can go one more and reduce it to (sum .) . map, as lambdabot says.
07:11:15 <dmhouse> sum is a unary function, and map f is a unary function, so you _can_ (.) those together.
07:11:35 <dmhouse> ?type (.)
07:11:37 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
07:11:46 <chessguy> good point
07:11:58 <dmhouse> Now, if a binary function appears on the RHS, then b = d -> e, say.
07:12:15 <dmhouse> But then the function on the LHS needs to be of type (d -> e) -> c.
07:12:40 <dmhouse> (.) :: ((d -> e) -> c) -> (a -> d -> e) -> a -> c is fine.
07:12:52 <chessguy> yeah
07:12:54 <dmhouse> Say f :: ((d -> e) -> c), and g :: a -> d -> e, and x :: a.
07:13:14 <dmhouse> You can do g x to give you a (d -> e), then feed that into f to give you your c, and this is what (.) does.
07:13:54 <glguy> (sum .) . map
07:14:00 <glguy> (Am I too late?) :)
07:14:03 <dmhouse> glguy: hehe.
07:14:07 <dmhouse> Actually, that's relevant here.
07:14:14 <glguy> huzzah
07:14:20 <dmhouse> Looking at the outer ., you have (sum .) on the LHS, and map on the RHS.
07:14:26 <glguy> I didn't bother reading much of the backlog
07:14:35 <dmhouse> map is a binary function, but (sum .) is a function (d -> e) -> c, as required, so it works.
07:14:37 <dmhouse> ?type (sum .)
07:14:40 <lambdabot> forall a a1. (Num a) => (a1 -> [a]) -> a1 -> a
07:14:57 <dmhouse> ?type ((sum :: [Int] -> Int) .)
07:15:00 <lambdabot> forall a. (a -> [Int]) -> a -> Int
07:15:10 <chessguy> it's revelant, but LB said it 5 minutes before he did :)
07:16:15 <dmhouse> (sum .) . map
07:16:21 <dmhouse> = (\f -> sum . f) . map
07:16:26 <dmhouse> = \y -> (\x -> sum . x) (map y)
07:16:45 <dmhouse> = \y -> (\x z -> sum (x z)) (map y)
07:16:59 <dmhouse> = \y -> (\z -> sum (map y z))
07:17:09 <dmhouse> = \y z -> sum (map y z), which was our myMapWithSum, as required.
07:20:28 <araujo> morning
07:39:17 <hpaste>  one_sk pasted "where is the memory leak?" at http://hpaste.org/1343
07:58:04 <yiwin> Hello. i need help. my first use Darcs. why no response when my type "darcs get --verbose --partial http://abridgegame.org/repos/darcs"
07:58:05 <lambdabot> Title: darcs
07:58:59 <yiwin> and waiting a long time , it exit. "libcurl error code: 52"
07:59:40 <kc5tja> Can you bring it up in a web browser?
07:59:45 <kc5tja> It responds fine for me here.
08:00:12 <yiwin> any repo. but only http://abridgegame.org/repos/darcs
08:00:12 <lambdabot> Title: darcs
08:00:24 <yiwin> any repo. not only http://abridgegame.org/repos/darcs
08:00:24 <lambdabot> Title: darcs
08:01:03 <yiwin> maybe beacuse i am in local network.
08:10:01 <Botje> yiwin: do you use a http proxy, perhaps?
08:10:30 <yiwin> i am under firewall.
08:11:44 <Botje> yiwin: does your browser have any http proxy settings?
08:11:55 <yiwin> no
08:12:13 <Botje> odd
08:12:22 <Botje> can you telnet to abridgegame.org/darcs ?
08:12:29 <Botje> err
08:12:31 <yiwin> in web. i can see repo
08:12:43 <Botje> can you telnet to abridgegame.org:80 ?
08:14:09 <yiwin> no. i cant
08:14:15 <Botje> yiwin: I could put a tarball online if you'd like
08:14:53 <yiwin> what mean  "put a tarball online"?
08:15:04 <Botje> I've downloaded the darcs repository
08:15:15 <Botje> I could make a .tar.bz2 (or .zip, or .rar, or ..) and put it on a server
08:15:45 <jcreigh> dons: the fromList and toList changes added the number of screens so that we could quickcheck the multiscreen stuff
08:17:28 <yiwin> i test other. http://darcs.haskell.org/alex/. its no work.
08:17:29 <lambdabot> Title: Index of /alex
08:19:00 <jcreigh> dons: thanks for merging that, BTW. I was thinking I'd have to merge it myself.
08:19:34 <Botje> yiwin: I'd say it's a proxy or firewall issue, then
08:19:51 <yiwin> Botje: or its must using SSH?
08:20:34 <Botje> yiwin: no, darcs get uses simple http requests. that's why I asked if you were behind a proxy of some sorts
08:22:03 <yiwin> Botje: No any Proxy.
08:25:37 <yiwin> Botje: i download darcs with cygwin.  and darcs 1.07  . and  same result.
08:29:32 <yiwin> ah, now i download repos  using FTP.
08:52:43 <glguy> @yow
08:52:44 <lambdabot> Those aren't WINOS -- that's my JUGGLER, my AERIALIST, my SWORD
08:52:44 <lambdabot> SWALLOWER, and my LATEX NOVELTY SUPPLIER!!
09:06:41 <mux> dons: doesn't OpenBSD have the -n flag for sysctl(1)? (I've been reading your blog about writing haskell code for cpuperf stuff)
09:09:00 <fasta> Did anyone implement a splay tree in Haskell?
09:11:13 <chessguy> hmm, it's probably been done, but i don't specifically know of an implementation
09:13:55 <fasta> chessguy: do you know the difference with a splay heap or pairing heap?
09:14:19 <fasta> chessguy: Chris Okasaki implemented those, IIRC, but I don't know the specific properties.
09:14:53 <chessguy> hm, no i don't
09:19:42 <xs> fasta: splay trees self-organise so that more frequently items are closer to the root. i don't know what a pairing heap is though.
09:20:55 <fasta> xs: I know what a splay tree is.
09:22:41 <xs> fasta: ah. sorry. i missed your initial question. i've implemented a splay tree in haskell, though i am not sure how efficient it is. i used a huet zipper for operations over it.
09:26:05 <ndm> @seen sorear
09:26:06 <lambdabot> I saw sorear leaving #darcs, #haskell-overflow, #ghc, #haskell and #happs 11h 18m 38s ago, and .
09:26:49 <joelr1> ndm: i was just gonna do that :D
09:27:08 <fasta> xs: Does it have asymptically good behaviour?
09:27:35 <fasta> xs: I am not looking for an overly optimized library, just one that does the right thing and is a reasonable implementation.
09:28:11 <ndm> fasta: have you got Osaki's book?
09:28:17 <xs> fasta: see "i am not sure how efficient it is". i've not had time to test it. i don't see why not, but funny things can happen with laziness.
09:28:53 <xs> fasta: perhaps the zipper overhead will kill it. *shrug*
09:29:35 <fasta> xs: Ok, doesn't matter.
09:29:43 <fasta> ndm: no
09:29:49 <joelr1> can someone tell me why the following fails to catch an empty string with parsec?
09:29:50 <joelr1> eoe = eof >> unexpected "end of input"
09:29:50 <joelr1> expr = (try eoe) <|> buildExpressionParser ops simpleExpr
09:30:05 <ndm> fasta: if you wanat haskell data structures, buy that book - its a good book even if you just like Haskell
09:30:51 <fasta> ndm: AFAIK, that book is mostly of theoretical interest.
09:31:00 <Saizan> joelr1, you mean that it doesn't report "end of input" ?
09:31:02 <dmhouse> Which book?
09:31:12 <ndm> fasta: if you want to pick the right data structure, that means you are interested in the theory
09:31:13 <joelr1> Saizan: yep
09:31:25 <fasta> ndm: I already know what data structure I want.
09:31:27 <Saizan> joelr1, have you tried without try?
09:31:43 <fasta> ndm: If it's not implemented anywhere where I can get it, I will do it myself from primary literature
09:31:44 <joelr1> Saizan: my expression parser goes into an infinite loop that i'm trying to break by checking for eof since the looping happens on an empty string
09:32:13 <joelr1> Saizan: doesn't help
09:34:39 <fasta> ndm: does that book give algorithms that have lower bounds than any algorithm before it?
09:34:48 <cba>      /msg nickserv set hide email on
09:34:57 <ndm> fasta: yes, in a lazy language
09:35:07 <Saizan> joelr1, you don't want unexpected, your eoe must not fail it you don't want buildExpressionParser ops simpleExpr to be called
09:35:13 <fasta> ndm: "a lazy language" has no meaning
09:35:33 <joelr1> Saizan: aah!!! that's it
09:35:37 <joelr1> i'm such an idiot
09:35:42 <ndm> fasta: it does, the algorithms are different
09:36:28 <fasta> ndm: in his thesis he shows atleast one algorithm that is easier to implement in a "lazy language", but he doesn't break the bound for that algorithm.
09:36:51 <fasta> ndm: maybe it contains algorithms that does, but I'd be surprised if it did.
09:37:09 <ndm> fasta: no, he doesn't give anything that beats a strict language - only things which beat the previously known lazy algorithms
09:37:19 <fasta> ndm: and I do not agree with your assertion that "the algorithms are different".
09:37:39 <ndm> fasta: but they are, i.e. a red-black tree is not destructive
09:37:47 <fasta> ndm: sure, that's quite nice, but only of theoretical interest.
09:38:07 <ndm> not if you are working in a purely functional language, its necessary
09:38:17 <fasta> ndm: unless you take someone who religiously uses functional data structures it is of practical interest.
09:38:31 <joelr1> Saizan: how would you shortcut an empty expression?
09:38:50 <ndm> fasta: thats me :)
09:39:16 <fasta> ndm: I found a way to do graphs efficiently with the help of DiffArrays
09:39:36 <fasta> ndm: I was busy quite "pure".
09:39:59 <fasta> ndm: (since AFAIK, nobody implemented graphs on top of DiffArray)
09:40:35 <fasta> ndm: the nice thing is that every operation is as efficient as the C counterparts modulo constants when used in a single threaded way :)
09:40:38 <ndm> fasta: cool, you should write that up - we have several graph theorists nearby, and they use Haskell for some bits, but only very lightly - could help them
09:40:50 <Saizan> expr = ((eof >> return (Left "foo"))  <|> (buildExpressionParser ops simpleExpr >>= return . Right)) >>= \x -> case x of Left msg -> unexpected msg; Right y -> return y; <-- something like this, maybe?
09:40:52 <ski> "functional data structures" provide persistance, mutable data structures usually don't ..
09:40:52 <fasta> ndm: yes, I do plan to write it down.
09:41:01 <ski> (so if you need persistance ..)
09:41:01 <ndm> fasta: cool, let me know when you do :)
09:41:02 <fasta> ski: I know
09:41:35 <fasta> Is there a ML to Haskell compiler?
09:41:46 <Saizan> joelr1, or a variation of it that typechecks :)
09:42:08 <ndm> fasta: its quite hard to do, someone tried at York and failed
09:42:38 <joelr1> Saizan: i see
09:42:41 <joelr1> Saizan: thanks
09:42:49 <fasta> ndm: oh, odd. I would think it would be quite easy to do so.
09:43:16 <dmhouse> fasta: ML being strict, Haskell lazy, ML have mutable references, Haskell preserving referential transparency, really?
09:43:36 <ndm> fasta: wasn't a particularly amazing student, but the lazy/strict, pure/impure and the module system all hampered them
09:44:00 <fasta> dmhouse: it depends on how much of the beauty you want to retain in the translation
09:44:29 <fasta> dmhouse: there is at least one trivial translation possible
09:44:46 <ndm> fasta: yes, write a bytecode interpetter in haskell, then squirt out the bytecodes in an array
09:44:51 <ndm> fasta: but unlikely to be much use
09:45:24 <fasta> ndm: indeed
09:47:03 <joelr1> Saizan: the issue appears to be that eof _always_ fails
09:48:37 <Saizan> Prelude Text.ParserCombinators.Parsec> parseTest eof ""
09:48:38 <Saizan> ()
09:49:06 <dmhouse> :t Text.ParserCombinators.Parsec.eof
09:49:09 <lambdabot> forall tok st. (Show tok) => Text.ParserCombinators.Parsec.Prim.GenParser tok st ()
09:49:20 <dmhouse> joelr1: I don't think () is failure
09:49:34 <joelr1> well, it always returns Left in my case
09:49:41 <joelr1> xx p s = P.runParser p M.empty "" s
09:49:52 <Saizan> Prelude Text.ParserCombinators.Parsec> parseTest (fmap Left eof <|> fmap Right anyChar) "a"
09:49:52 <Saizan> Right 'a'
09:49:52 <Saizan> Prelude Text.ParserCombinators.Parsec> parseTest (fmap Left eof <|> fmap Right anyChar) ""
09:49:52 <Saizan> Left ()
09:50:12 <glguy> when a function returns a (), it just means that it didn't have any useful output to return
09:50:25 <glguy> but that it had to return something because that's how monads work :)
09:50:40 <joelr1> ah, never mind, i need to change something
09:50:50 <Saizan> ?type runParser
09:50:53 <lambdabot> Not in scope: `runParser'
09:50:57 <fasta> Is there also a ml channel on freenode?
09:50:59 <dmhouse> The only annoying thing about eof is its return type. I'd prefer it to be eof :: CharParser st a
09:50:59 <joelr1> i was testing eoe = eof >> pzero which indeed always fails
09:51:09 <joelr1> fasta: ocaml
09:51:19 <glguy> dmhouse: why should it return undefined?
09:51:26 <joelr1> Saizan: that's a parse that takes initial state
09:51:41 <joelr1> glguy: my issue is that i'm trying to short-cicruit my expression parser
09:51:48 <dmhouse> Because, then, say, you want to parse a newline or eof. You have to do something hacky like newline <|> (eof >> return ' '), because otherwise the return type of newline, Char and eof, (), don't match up.
09:51:52 <joelr1> it goes into a loop on empty input
09:52:26 <glguy> ?docs Data.Map
09:52:27 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
09:52:38 <joelr1> so i'm trying to figure out how i can stop the parser on empty input
09:52:53 <Saizan> well you can return undefined like an eof :: CharParser st a would
09:53:03 <glguy> dmhouse: sounds to me like newline should return a ()
09:53:20 <fasta> joelr1: What are the dots in (SET{root,...}) (ML)?
09:53:22 <dmhouse> glguy: well, then, generalise. Say you want to parse the letter 'a' or eof.
09:53:36 <joelr1> fasta: beats me!
09:53:37 <dmhouse> Perhaps we need a char_ :: Char -> CharParser st () combinator.
09:53:53 <glguy> dmhouse: I think that char should return a () also...
09:53:55 <joelr1> Saizan: you mean eof >> return undefined?
09:53:59 <glguy> since there is no useful output from it
09:54:02 <fasta> joelr1: ok, I thought you also programmed in OCaml. Maybe they use some odd preprocessing.
09:54:17 <dmhouse> glguy: yes, true, that's a better solution than have eof return _|_.
09:54:20 <joelr1> fasta: i do/did but i don't know what you are talking about
09:54:21 <Saizan> joelr1, yes but it was directed at dmhouse
09:54:43 <ski> (fasta : also #sml)
09:55:18 <fasta> joelr1: I think it's the same as _ is in Haskell
09:55:20 <joelr1> argh, that throws an exception. i can achieve the same by invoking fail
09:55:23 <dmhouse> glguy: as a backward-compatible solution we could add a char_ parser as I just said.
09:55:29 <fasta> joelr1: I.e. match any value
09:55:43 <joelr1> fasta you can do let _ = but i don't know what SET is all about
09:55:59 <glguy> dmhouse: I don't know that the library would benefit from such a solution, though: char_ a = char a >> return () would likely be useful in your code
09:56:32 <ski> fasta : the dots represent to rest of the fields in the record (that we just ignore), it's a bit like a '_'
09:56:41 <dmhouse> glguy: well, it's a reusable solution to a problem others are likely to have come across, why not add it?
09:56:44 <joelr1> overall, my problem is that expr = buildExpressionParser uses simpleExpr which, in turn, has some things that invoke expr
09:56:46 <fasta> joelr1: SET is just a value.
09:57:02 <fasta> joelr1: which has root as one of its fields.
09:57:07 <glguy> dmhouse: because it doesn't seem like it would be useful enough to add a bunch of _ variants
09:57:13 <glguy> and polute the library
09:57:40 <joelr1> fasta: i think that would be different between ocaml and sml
09:57:53 <glguy> dmhouse: how about *this*
09:57:54 <fasta> ski: thanks for making me sure of that fact.
09:58:06 <glguy> a new operator <||>
09:58:12 <glguy> that discards the output
09:58:19 <glguy> so the types don't need to be the same
09:58:24 <glguy> which returns a parser that returns ()
09:58:25 <fasta> ski: foo bar ref is a reference type?
09:58:41 * ski nods
09:59:14 <dylan> aaah, Reverse-Polish type notation!
09:59:37 <ski> yes .. it's somewhat strange .. but can read nice
09:59:38 * dylan goes into a fetal position and chants "no ocaml"
09:59:40 <ski> int list
09:59:50 <ski> string tree ref
10:00:27 <glguy> at the very least: a <||> b = (a >> return ()) <|> (b >> return ())
10:00:28 <ski> (still associates to the left :)
10:00:32 <dylan> using ocaml after learning haskell seems like time-traveling to the past.
10:01:02 <ski> ignore m = m >> done
10:01:05 <ski> done = return ()
10:01:34 <glguy> or... a <||> b = ignore a <|> ignore b
10:01:35 <ski> (someone suggested s/ignore/void/)
10:01:36 <glguy> :)
10:01:36 <cba> my haskell program segfaults :-((
10:03:09 <Saizan> do you do anything unsafe?
10:03:26 <cba> hm, no
10:03:37 <Saizan> FFI?
10:03:42 <cba> you can see the sources at http://ibgs.christoph-bauer.net/~fridolin/haskell-btree/
10:03:44 <lambdabot> Title: Index of /~fridolin/haskell-btree
10:03:46 <glguy> creating arrays with huge size?
10:04:06 <cba> it uses Data.Binary
10:04:45 <cba> no ffi, no huge arrays
10:04:58 <emu> fasta: it means the record has more fields
10:05:25 <_roconnor> oh oh, how about making instances of Ix? o:)
10:05:56 <cba> maybe a hSeek beyond the eof
10:06:17 <Saizan> that seems possible
10:07:07 <Saizan> is testDB supposed to be empty?
10:07:33 <cba> do i have to use System.Posix.* to extend the file
10:08:45 <cba> testDB should be the output of my program. it should have some contents.
10:11:12 <joelr1> dmhouse, Saizan: ok, i figured out what my problem is. i have a formatted print expression at the end of my simpleExpr that I pass to buildExpressionParser. so expr = b-E-P ops simpleExpr and simpleExpr = choice [ ..., fmtPrintExpr ]
10:11:58 <joelr1> dmhouse, Saizan: but fmtPrintExpr is expr ":" expr ":" expr so the parser goes into a loop :( i don't know how to break it
10:12:00 <cba> the output of gdb tells me nothing. no function name in the trace.
10:13:06 <sjanssen> gdb won't tell you anything useful unless you're in an FFI call
10:14:02 <joelr1> how do you left-factor expr = expr ":" expr ":" expr ?
10:15:55 <chessguy_work> you mean left-associate?
10:17:01 <joelr1> chessguy_work: http://cobol.cs.berkeley.edu:8008/wiki164/index.php/D4#Left_Factoring
10:17:04 <lambdabot> Title: D4 - CS164Wiki, http://tinyurl.com/2fcg7w
10:17:46 <Saizan> expr = ":" expr ":" expr expr ?
10:18:03 <Saizan> nah
10:18:38 <joelr1> Saizan: maybe left-factoring is the wrong solution. how do you parse that in general?!
10:18:51 <joelr1> Saizan: i think that's called a left-recursive grammar
10:19:24 <Saizan> yeah, but left recursions can and should be eliminated, no?
10:19:36 <opqdonut> ohaC
10:19:38 <opqdonut> woops
10:19:43 <chessguy_work> hmm
10:21:26 <chessguy_work> ohhh, i saw this in my formal languages class, but it was called something else
10:21:34 <chessguy_work> and i have no idea what
10:22:25 <Madhadron> Has anyone tried to read png or tiff into Haskell arrays?
10:22:29 <Saizan> mmh i'm not sure how you do this without a non-recursive case
10:22:40 <chessguy_work> all of the examples on that wiki factor grammars with multiple possible definitions. you don't have that in this case
10:22:43 <cba> aehm, i found my problem. it was hGetContents h >>= Data.Binary.decode on a fresh created file...
10:23:24 <joelr1> chessguy_work: well, expr can be things other than what i typed up, that's just one of the cases
10:23:40 <Saizan> but parsec has a quite similar combinator, sepBy or sepEndBy
10:23:49 <chessguy_work> but you're still trying to factor within one definition
10:24:03 <chessguy_work> those examples are factoring out commonality between multiple definitions. you're not
10:24:40 <joelr1> chessguy_work: true
10:24:46 <joelr1> Saizan: do you think using it would help?
10:25:41 <Saizan> not so sure, but maybe looking at its definition could
10:26:10 <Saizan> or,alternatively, catching eof inside choice?
10:26:19 <joelr1> :t take
10:26:22 <lambdabot> forall a. Int -> [a] -> [a]
10:26:42 <joelr1> Saizan: how would you catch eof in choice?
10:28:03 <cba> thanks for the help
10:28:06 <cba> \quit
10:29:11 <ndm> @src mapM
10:29:12 <lambdabot> mapM f as = sequence (map f as)
10:30:04 <chessguy_work> :t mapM
10:30:07 <lambdabot>     Ambiguous occurrence `mapM'
10:30:08 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
10:30:18 <chessguy_work> :t Control.Monad.mapM
10:30:20 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
10:30:41 <chessguy_work> :t liftM map
10:30:43 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m ([a] -> [b])
10:32:17 <dmwit> :t ?mapM f
10:32:19 <lambdabot> Not in scope: `f'
10:32:38 <chessguy_work> :t ?mapM ?f
10:32:41 <lambdabot> forall t t1. (?mapM::t -> t1, ?f::t) => t1
10:33:34 <dmwit> :t ?mapM (return (*2))
10:33:36 <lambdabot> forall t a (m :: * -> *). (?mapM::m (a -> a) -> t, Num a, Monad m) =>
10:34:13 <dmwit> Oh, that doesn't help get around the ambiguous occurrence problem at all. =(
10:34:43 <Saizan> Unfortunately, left-recursive grammars can not be specified directly in a combinator library. If you accidently write a left recursive program, the parser will go into an infinite loop! <-- parsec's doc :D
10:34:46 <Cheery> if you would know nothing about haskell, what things would interest you in it? Ie. not necessarily make you use it, but just make you interested
10:35:01 <Madhadron> Cheery, Libraries.
10:35:16 <Cheery> be more specific
10:35:39 <Cheery> the module system? some particular module?
10:35:41 <Madhadron> I know and love Haskell, and I spent months messing with other platforms in desparate hope of not having to write a scientific imaging library from scratch (which I'm now doing)
10:36:12 <dmwit> Madhadron: I think he means, "What things that already exist could I use to convince someone to try Haskell?"
10:36:23 <pejo> Cheery, the type system problably deserves some mentioning.
10:36:26 <Madhadron> Ah, I misunderstood
10:36:44 <Cheery> dmwit: the first is right, the latter... I don't think it should convince somebody to try, just make him interested
10:36:45 <Saizan> http://www.cs.uu.nl/~daan/download/parsec/parsec.html#chainl <-- joelr1, can this help?
10:36:47 <emu> laziness is what i always had found interesting
10:36:50 <emu> and being purely functional
10:37:36 <dmwit> Yeah, I think the laziness and the type inference were the two things that were mysterious and appealing to me.
10:37:51 <joelr1> Saizan: trying, thanks
10:38:43 <Cheery> I'm wondering how should I write my haskell article / introduction
10:39:04 <Madhadron> Cheery, Who's the audience?
10:39:19 <Cheery> my pals, much like me except without knowledge about haskell
10:39:34 <Madhadron> ...whose background, interests, and mathematical sophistication are?
10:39:44 <Cheery> I've always seen the laziness, being purely functional, type inferencing being a side effect of some decisions rather than something which makes it good
10:40:20 <Madhadron> I agree.  People finally got tired of managing their own memory and segfaults.
10:40:23 <Tene> Cheery: but I thought that functional languages didn't *have* side-effects! ;)
10:41:24 <Visual_E> Madhadron: are you a matlab user perhaps?
10:41:32 <Cheery> Tene: nop, but one has done the decisions, ie.
10:41:45 <ibid> is there a language pragma for bang patterns, or must i use options_ghc?
10:41:49 <Madhadron> Visual, I have used MATLAB, but I don't use it for anything these days.
10:42:06 <Cheery> with side-effects I mean that I don't feel them having much emphasis
10:42:06 <Madhadron> A little bit of scipy, but ironically I'm doing a large amount of data analysis in PostgreSQL
10:43:34 <Cheery> ie. they are there because you guys have been done a mathematical model for programs, type inferencing came from need to interface, and laziness came from the nature of those models
10:43:44 <boegel> hiya dons!
10:43:58 <Madhadron> Cheery, I think I'd just take some day to day tasks that you end up having to program, and implement them.
10:43:58 <ibid> LANGUAGE BangPatterns, nice
10:45:03 <Visual_E> Madhadron: i find its image toolbox handy, and its compiler is not so bad
10:45:29 <Cheery> Madhadron: there's tons of those
10:45:43 <emu> being purely functional was definitely not just a "side effect" =)
10:45:54 <Madhadron> Cheery, Is there one that you can just point your friends to?
10:46:01 <Cheery> and programmer will already know how to make the day to day tasks after understood few things
10:47:02 <Madhadron> Visual, Yes, but I was never able to maintain a codebase of larger than a few thousand lines in it, and you need that to do almost anything nontrivial.
10:47:25 <Madhadron> That and I was mostly doing image analysis in it and I found their toolbox to be more than a little shoddy in many places
10:47:49 <Madhadron> Throwing away the gradient direction in the Canny edge detector, for instance, and not using it in the hysteresis threshold
10:47:59 <boegel> hmm, I guess dons is in bed?
10:48:02 <boegel> @localtime dons
10:48:05 <lambdabot> Local time for dons is Thu Apr 12 03:47:19 2007
10:48:20 <Cheery> @localtime Cheery
10:48:32 <boegel> Cheery: you don't know your own local time?
10:48:34 <boegel> @localtime boegel
10:48:37 <lambdabot> Local time for boegel is Wed Apr 11 19:47:58
10:48:46 <boegel> lambdabot knows everything!
10:48:57 <boegel> @vixen what's my last name?
10:48:57 <lambdabot> <undefined>
10:49:00 <boegel> lol
10:49:01 <Cheery> boegel: I know, I'm just curious wether lambdabot knows it
10:49:07 <boegel>  @vixen is still broken :(
10:50:11 <boegel> Cheery: depends on your IRC client, lambabot basically asks your client :)
10:54:36 <samx_> how do I convert Strings to ByteStrings ?
10:54:51 <twanvl> ?hoogle pack
10:54:52 <lambdabot> Data.PackedString.packString :: String -> PackedString
10:54:52 <lambdabot> Distribution.InstalledPackageInfo.package :: InstalledPackageInfo -> PackageIdentifier
10:54:52 <lambdabot> Distribution.PackageDescription.package :: PackageDescription -> PackageIdentifier
10:55:35 <emu> it's pack, in the ByteString module
10:55:45 <emu> which lambdabot doesn't seem to have hoogle-indexed
10:56:02 <twanvl> Or Data.ByteString.Char8 if you have a String and not a [Word8]
10:56:03 <emu> @doc Data.ByteString.Char8
10:56:04 <lambdabot> Data.ByteString.Char8 not available
10:56:33 <emu> @doc Data
10:56:33 <lambdabot> Data not available
10:56:48 <emu> @doc Data.List
10:56:48 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
10:57:00 <emu> right, it's at that site
10:57:51 <ndm> emu: thats my fault that it isn't in hoogle
10:58:12 <emu> ok, blame ndm
10:58:19 <ndm> ndm--
10:59:16 <boegel> @karma- ndm
10:59:16 <lambdabot> ndm's karma lowered to 14.
10:59:38 <samx_> hmm, ok.. Lets say I have a String literal "foo", how would I make that a [Word8], so I could use pack..
10:59:52 <emu> use the .Char8 module then it's String -> ByteString
11:01:36 <samx_> ok. but still, just out of curiosity, how would I create [Word8] literals ? (And what's the difference between Word8 and Char?
11:02:14 <glguy> Char is bigger than Word8
11:02:47 <samx_> for unicode support?
11:03:07 <glguy> > fromEnum (maxBound :: Char) :: Int
11:03:08 <lambdabot>  1114111
11:03:20 <glguy> > fromEnum (maxBound :: Word8) :: Int
11:03:21 <lambdabot>  255
11:04:01 <samx_> i see. thanks
11:04:23 <glguy> > minBound :: Word8
11:04:25 <lambdabot>  0
11:04:28 <glguy> unsigned
11:05:00 <Saizan> mmh, what does .Char8.pack does with > 255 chars? truncates?
11:06:00 <bos> yes.
11:06:06 <bos> so \1000 becomes \232, etc.
11:18:03 <dru> lo guys
11:18:33 <dru> anyone here could explain this to me please
11:18:33 <dru> src/Main.hs(18,7):
11:18:33 <dru>     Could not find module `Network':
11:18:33 <dru>       it is a member of package network-2.0, which is hidden
11:18:47 <dru> how to fix it? i'm a newbie in haskell studying it at uni
11:19:02 <dru> im using visual haskell Visual Studio 2005
11:19:22 <Madhadron> Is that ghc under the hood?
11:19:28 <dru> yeah
11:19:33 <dru> 6.6 if im not mistaken
11:19:50 <Madhadron> You may have to pass a package argument to the compiler...
11:20:07 <Madhadron> ghc -package Network or something like that
11:20:18 <dru> let me try that
11:20:55 <dru> hm
11:20:56 <dru> ghc.exe: unknown package: Network
11:21:07 <Saizan> you should always use --make when manually compiling
11:21:10 <Madhadron> Actually ,read this:
11:21:13 <Madhadron> http://web.mit.edu/ghc/www/users_guide/packages.html
11:21:14 <lambdabot> Title: 4.8. Packages
11:21:16 <Madhadron> It should make all clear
11:21:17 <dru> i'm not compiling manually
11:21:39 <Saizan> and how?
11:21:59 <Saizan> (however the package is called network, not Network)
11:22:22 <Madhadron> Saizan, Yes, just noticed that.  Shows how much network programming I do (:
11:22:39 <Saizan> almost all packages are lowercase :)
11:23:28 <Madhadron> Saizan, QuickCheck, OpenGL, X11...
11:23:53 <Saizan> uhm true
11:24:08 <Madhadron> dru, Saizan's right, though.  You should go hunt down the actual compilation steps in Visual Studio and change them to use --make ModuleName (Main in this case, I guess, but maybe Visual Studio has some variable it uses)
11:24:24 <dru> yeah i managed it works
11:24:25 <dru> :D
11:24:26 <dru> thx guys
11:24:45 <Madhadron> Saizan, But it was actually flagrant ignorance on my part
11:26:13 <UUStudent02> I have GHCi version 6.4.2 and want to install wxHaskell, but on http://wxhaskell.sourceforge.net/building.html I found ghci: the GHCi interpreter only works with wxWidgets version 2.4.2 on Windows platforms. On the wxhaskell site / wxwidgets site I can't find that version
11:26:13 <lambdabot> Title: wxHaskell - Building
11:28:10 <kowey> UUStudent02: you can still find older releases of wxWidgets on their sf site - http://sourceforge.net/project/showfiles.php?group_id=9863&package_id=19629
11:28:13 <lambdabot> Title: SourceForge.net: Files, http://tinyurl.com/283wu9
11:30:48 <Twigathy> @yarr
11:30:48 <lambdabot> This is the END for you, you gutter-crawling cur!
11:31:10 <Twigathy> @yarr
11:31:11 <lambdabot> Yeh scurvy dog...
11:32:04 <fuzan> hey all, i've made some simple io haskell programs and I was hoping to benchmark them. i've been messing around with time, yet I'm feeling as if the benchmarks aren't necessarily io-bound.
11:32:19 <fuzan> any ideas how to perform an entirely io-bound test?
11:32:41 <Twigathy> fuzan: why do you want it to be IO bound?
11:33:04 <fuzan> Twigathy: I'm comparing the time between my "cat" with the unix "cat"
11:33:14 <joelr1> would anyone know how to skip keywords with parsec?
11:33:34 <Twigathy> so why do you want that to be bound by the hard drive speed?
11:33:35 <fuzan> joelr1: skipMany1 for example?
11:33:56 <Twigathy> why not make it bound by how gast your program is?
11:34:03 <Twigathy> fast even
11:34:09 <joelr1> fuzan: well, i was thinking of skipping anywhere
11:34:28 <fuzan> joelr1: not sure, then :\
11:35:04 <joelr1> fuzan: ok, thanks
11:35:34 <fuzan> Twigathy: since if my machine has any bottlenecks, an io-bounded test would be a more fair assessment
11:45:23 <ray> http://haskell.org/haskellwiki/99_questions/1_to_10 some of the solutions to this use a "group" function.. where does this function come from?
11:45:25 <lambdabot> Title: 99 questions/1 to 10 - HaskellWiki
11:45:51 <meester> Data.List
11:46:00 <fuzan> http://haskell.org/hoogle/?q=group
11:46:01 <lambdabot> Title: group - Hoogle
11:46:13 <dru> guys
11:46:26 <dru> i need to make a downloader in haskell
11:46:36 <dru> any suggestions on what imports i need and how to do it best?
11:46:43 <ray> oh, thanks
11:46:52 <ibid> hrm
11:47:02 <ibid> i ran into a weird happy bug
11:47:38 <fuzan> ibid: the 100% useless error message?
11:47:47 <fasta> Prelude.undefined :)
11:47:57 <ibid> fuzan: i've got over that already :)
11:48:00 <fasta> fromJust:....
11:48:21 <ibid> if i define happyError _ = error "...", then with an erroneous input i get "...", but if i define happyError so that it pattern-matches on the parameter, i get internal happy error!
11:48:35 <ibid> the same input, no other changes to the happy file
11:49:07 <fuzan> internal how so?
11:49:15 <fuzan> on executing happy?
11:49:47 <fuzan> and could your pattern-matching be non-exhaustive?
11:50:02 <Saizan> dru: downloader from what? there's Network.HTTP if it applies
11:50:28 <ibid> fuzan: non-exhaustive matching should give a different error message
11:50:57 <ibid> fuzan: i mean, the parser reports "internal happy error", which means that it runs into notHappyAtAll
11:51:15 <fuzan> ibid: not sure :\ i use bnfc nowadays.
11:51:27 <ibid> fuzan: bnfc uses happy :)
11:51:42 <dru> Saizan: a simple downloader manager for files
11:52:16 <samx_> I want to read a double from a ByteString to a Double. I can do so with read . unpack, but that takes away much of the advantage of using ByteStrings for me. Is there any more direct way?
11:53:04 <ibid> it seems that if happyError forces the first element of the argument list, we get notHappyAtAll
11:53:49 <Excedrin> Hello #Haskell
11:54:10 <ibid> hello
11:58:54 <Saizan> samx_ there are only readInt :: ByteString -> Maybe (Int, ByteString), readInteger :: ByteString -> Maybe (Integer, ByteString) in .Char8
12:06:01 <njd> @users
12:06:02 <lambdabot> Maximum users seen in #haskell: 336, currently: 314 (93.5%), active: 38 (12.1%)
12:07:47 <fuzan> ibid: but it generates happy happy :)
12:09:12 <ibid> fuzan: :)
12:11:04 <dru> back
12:11:25 <dru> i dont see any network.http
12:11:48 <Saizan> it's not shipped with ghc
12:11:51 <Saizan> ?where http
12:11:52 <lambdabot> http://haskell.org/http
12:16:25 <dru> thx thx
12:16:27 <dru> let me install
12:16:44 <joelr1> Philippa: thanks
12:17:21 <joelr1> here's a keyword-skipping mechanism for parsec: lexeme = P.lexeme lexer . (skip >>)
12:17:48 <Madhadron> Does anyone know how to get at C enums with Haskell's FFI?
12:17:57 <joelr1> where skip is something like skip = skipMany $ choice $ fmap reserved [ "A", "An", "At", "Based", ... ]
12:18:28 <sjanssen> Madhadron: it's easiest to use an external tool like hsc2hs
12:18:59 <Madhadron> sjanssen, Was hoping to avoid it, since I only know about five functions out of this library
12:19:54 <sjanssen> Madhadron: have you used hsc2hs before?  It's pretty easy, and it comes with ghc and hugs
12:20:01 <Madhadron> Whoops, need about five functions rather
12:20:09 <Madhadron> sjanssen, Just started digging through the docs
12:21:18 <sjanssen> and if you're using Cabal to build, the hsc preprocessing is transparent and automatic
12:22:26 <Madhadron> sjanssen, Actually I'm mucking around in ghci, and this is likely to remain the state of things
12:35:09 <cba> ?where smtp
12:35:10 <lambdabot> I know nothing about smtp.
12:38:14 <chessguy_work> are you looking for an smtp server or client?
12:39:27 <cba> client
12:39:55 <chessguy_work> according to http://www.haskell.org/haskellwiki/Libraries_and_tools/Network , haskellnet has support for SMTP: http://darcs.haskell.org/SoC/haskellnet/
12:39:57 <lambdabot> Title: Libraries and tools/Network - HaskellWiki
12:40:30 <chessguy_work> not much documentation there though
12:40:52 <cba> hey, cool
12:41:10 <joelr1> @pl reserved a = skip >> P.reserved lexer a
12:41:11 <lambdabot> reserved = fix ((((skip >>) . (P .)) .) . ($ lexer))
12:41:25 <chessguy_work> http://article.gmane.org/gmane.comp.lang.haskell.general/14126
12:41:27 <lambdabot> Title: Gmane -- Mail To News And Back Again
12:44:06 <plediii> I'm new to haskell, and am trying to use with emacs' haskell-mode-2.3.  Apparently, there it has a known a problem with indenting if-then statements.  How do experienced haskellers work with this?
12:45:26 <chessguy_work> by not using emacs....oops, did i say that out loud? :)
12:46:04 <SamB> "if"?
12:46:27 <SamB> plediii: do you mean that problem in "do" blocks?
12:46:47 <plediii> SamB: the problem I'm having troubles indenting in a "do" block, yes.
12:47:01 <SamB> by inserting spaces ;-)
12:47:09 <SamB> actually, more like :-(
12:47:09 <plediii> gross :)
12:47:28 <cba> i have (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
12:47:42 <plediii> cba: I have that as well.
12:47:44 <SamB> cba: how does that help?
12:48:14 <cba> i don't have problems with do-Statements
12:49:51 <chessguy_work> hmm, new article on LtU looks to be about an interesting paper
12:49:57 <chessguy_work> The Structure and Value of Modularity in Software Design
12:51:42 <plediii> cba: not even with indenting the "then" under an "if"?
12:55:03 <cba> plediii: ok, for then i have to insert spaces too
13:06:58 <cba> in haskell-indent.el is this line:   ((looking-at "\\(?:in\\|of\\|then\\|else\\)\\>"). Could you try to replace it with  ((looking-at "\\(?:in\\|of\\)\\>") and load-file haskell-indent.el again?
13:10:53 <hpaste> *Boom* headshot!
13:11:33 * sjanssen goes for cover
13:13:59 * glguy throws an EMP grenade at hpaste
13:14:19 <chessguy_work> oh, that's going to leave a mess
13:14:26 <hpaste> *respawn*
13:14:47 <lambdabot> :-o
13:15:05 <chessguy_work> wow, how'd he know hpaste's head was gonna grow back
13:15:24 <glguy> o\-<
13:15:26 <glguy> o|-<
13:15:27 <glguy> o/-<
13:15:45 * glguy is bored
13:16:00 <chessguy_work> glguy: how many days left?
13:16:35 <glguy> I get married in a month, I'm off a week for honeymoon and then one week after that
13:16:38 <glguy> so...
13:16:43 <glguy> about 2 long
13:16:43 <eumenides> is there some $ equivalent for types?
13:16:59 <glguy> a USD conversion rate?
13:16:59 <glguy> no
13:17:15 <chessguy_work> nice
13:17:17 <glguy> (also no $ function for types)
13:17:21 <chessguy_work> where's the honeymoon?
13:17:28 <glguy> Jamaica
13:18:47 <fuzan> did you get a suite with a good internet connection? :D
13:19:02 <glguy> I intend to avoid computers while I'm down there
13:19:13 <sjanssen> pssh
13:19:16 <glguy> if you are going to do it once in your life
13:19:18 <glguy> that seems like the time
13:21:48 <Excedrin> this thread about perl is interesting
13:22:15 <Excedrin> I think that I'm somewhat familiar with FP, but Haskell is still sort of hard for me
13:22:30 <glguy> what thread?
13:22:33 <glguy> mailing list?
13:22:36 <Excedrin> part of that is because it's very easy to code imperative stuff in most FP languages
13:22:37 <glguy> reddit?
13:22:52 <Excedrin> in haskell cafe
13:22:56 <Jaak> @paste
13:22:57 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:23:05 <Excedrin> http://www.nabble.com/Why-Perl-is-more-learnable-than-Haskell-tf3559193.html#a9938938
13:23:08 <lambdabot> Title: Nabble - Why Perl is more learnable than Haskell, http://tinyurl.com/36quxj
13:23:15 <glguy> I found it in my gmail archive
13:23:26 * glguy archives all the mailing list traffic
13:24:01 <chessguy_work> glguy: my fiance's dad said he'd pay for the honeymoon if we go to hawaii. that was a tough choice
13:24:37 <chessguy_work> err, fiancee i guess. i always forget which is which
13:25:43 <glguy> fiancee is the girl
13:25:46 <glguy> fiance is the guy
13:26:12 <chessguy_work> good to know
13:26:20 <glguy> what was his interest in hawaii?
13:26:20 <Heffalump> it's fairly standard in French for an extra e to make a feminine version
13:26:32 <chessguy_work> he's got family there and goes every year
13:26:56 <glguy> fie'e
13:26:57 * Heffalump failed to avoid computers while he was on honeymoon
13:26:59 <glguy> :-/
13:27:10 <Heffalump> but my wife didn't seem to mind too much
13:27:13 <glguy> fiance'e ... I don't know how to write the e' on this keyboard
13:27:30 <hpaste>  Jaak pasted "FizzBuzz + Cont monad" at http://hpaste.org/1345
13:27:43 <chessguy_work> LOL @ lennart using a taylor expansion to refactor a grammar in way that those with a "weak memory" can do it
13:28:25 <Heffalump> chessguy_work: huh?
13:28:47 <chessguy_work> on -cafe
13:29:01 <chessguy_work> lennart = augustss
13:29:29 <augustss> chessguy_work: that's how o remember it
13:29:36 <augustss> s/o/i/
13:29:45 <chessguy_work> augustss: i don't doubt that
13:29:55 <alpheus> how do I read "(x:xs)" in this: my_length (x:xs) = 1 + my_length xs
13:30:25 <chessguy_work> xs is the plural of x
13:30:35 <Heffalump> ah, cunning
13:30:54 <chessguy_work> (x:xs) is a non-empty list, where the first element of the list gets bound to x, and the rest of the list (possibly empty) gets bound to xs
13:31:07 <sjanssen> alpheus: (x:xs) is a list, the first element is 'x', and the rest of the list is 'xs'
13:31:13 <Heffalump> but calling 1 + a + ... the Taylor series, while true, seems like overkill given you can derive it algebraicly :-)
13:31:30 <alpheus> so it's kind of naming the head and tail of the list given as a formal parameter?
13:31:40 <Heffalump> alpheus: yes
13:32:09 <Heffalump> alpheus: in general you can pattern match like that for any constructor, built-in (like :) or user-defined
13:32:38 <augustss> Heffalump: it is the Taylor series, even if you can derive it differently
13:32:53 <Excedrin> I suppose you can't pattern match against: (x+1), but you can against (Succ x)
13:32:58 <Heffalump> augustss: yeah
13:33:36 <augustss> But sure, it's easy to "prove" by multiplying the series by a and then subtracting it
13:34:07 <glguy> Jaak: looks like a solution looking for a problem...
13:34:12 <alpheus> am I off base by thinking it's somewhat analogoust to destructuring-bind?
13:34:25 <alpheus> analogous
13:34:48 <Jaak> glguy: indeed it is :)
13:34:51 <augustss> @pl \ x y -> f [x,y]
13:34:52 <lambdabot> (f .) . (. return) . (:)
13:34:58 <augustss> too gruesome
13:35:43 <chessguy_work> @pl \ x y z -> f [x,y,z]
13:35:44 <lambdabot> ((f .) .) . (. ((. return) . (:))) . (.) . (:)
13:35:47 <chessguy_work> even more gruesome :)
13:36:22 <DRMacIver> Hm
13:36:41 <syntaxfree> heh. kpax uses darcs as a vcs.
13:36:51 <DRMacIver> What does @pl do? Convert things into pointfree style or something?
13:37:03 <Heffalump> yes
13:37:07 <Excedrin> pointless
13:37:09 <emu> @help pl
13:37:10 <lambdabot> pointless <expr>. Play with pointfree code.
13:37:22 <chessguy_work> @pl \x y -> x + y -- my favorite example
13:37:22 <DRMacIver> Cool.
13:37:22 <lambdabot> (+)
13:37:33 <DRMacIver> @pl fix
13:37:34 <lambdabot> fix
13:37:37 <DRMacIver> Aww. :)
13:37:43 <emu> @src fix
13:37:44 <lambdabot> fix f = let x = f x in x
13:37:47 <chessguy_work> @pl \x y -> y + x
13:37:48 <lambdabot> (+)
13:37:51 <syntaxfree> my favorite example is
13:37:56 <syntaxfree> @unpl ap
13:37:57 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
13:38:01 <syntaxfree> ;)
13:38:03 <chessguy_work> aww, not flip (+)
13:38:27 <augustss> Someone is assuming (+) is commutative.  BAAAAD!
13:38:27 <DRMacIver> @pl \f -> let x = f x in x
13:38:28 <lambdabot> fix
13:38:36 * DRMacIver glares at lambdabot 
13:38:45 <chessguy_work> @unpl fix
13:38:46 <lambdabot> fix
13:38:55 <chessguy_work> @unpl fix x
13:38:55 <lambdabot> fix x
13:38:56 <augustss> @src ap
13:38:57 <lambdabot> ap = liftM2 id
13:38:57 <emu> well, fix is its own fixed point for pl =)
13:38:58 <DRMacIver> I guess that's not possible to convert to pointfree
13:39:12 <emu> fix can't be defined without the let
13:39:24 <DRMacIver> Sure
13:39:24 <emu> in the type system
13:39:41 <DRMacIver> Otherwise the strongly typed lambda calculus would be turing complete. :)
13:39:52 <DRMacIver> (without explicit recursion I mean)
13:40:25 <DRMacIver> err. That came out less coherent than I meant it to. But you know what I mean hopefully.
13:42:41 <lekro> @type ap
13:42:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:42:54 <lekro> what are m,a,b in "ap ((==) :: Int->Int->Bool)"?
13:43:11 <lekro> @type ap ((==) :: Int->Int->Bool)
13:43:14 <lambdabot> (Int -> Int) -> Int -> Bool
13:44:24 <vincenz> moin
13:48:49 <lekro> hm, a = Int, b = Bool and m c = Int->c could be possible, if Int->c is a monad... is there something to read about a->b-Monads or am I completely wrong with this idea?
13:49:36 <sjanssen> lekro: m is the ((->) a) monad
13:49:58 <sjanssen> @instances Monad
13:50:00 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
13:50:48 <lekro> does it have a "proper" name? it's difficult to search for ((->) a)
13:51:22 <augustss> it's the reader monad
13:51:47 <chessguy_work> say what?
13:51:56 <chessguy_work> ((->) a) is the reader monad?
13:52:11 <glguy> yeah
13:52:13 <sjanssen> well, the Reader monad is just a newtype around the ((->) a) monad
13:52:15 <augustss> isomorphic to
13:52:24 <chessguy_work> hmmm
13:52:34 <Excedrin> @help seen
13:52:34 <lambdabot> seen <user>. Report if a user has been seen by the bot
13:52:41 <chessguy_work> ?seen Excedrin
13:52:42 <lambdabot> Excedrin is in #haskell. I last heard Excedrin speak 7s ago.
13:52:53 <chessguy_work> ?seen lambdabot
13:52:53 <lambdabot> Yes, I'm here. I'm in #oasis, #happs, #montevideolibre, #parrot, #scannedinavian, #unicycling, #jtiger, #perl6, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell-soc, #haskell.dut, #haskell.hac07,
13:52:54 <lambdabot> #haskell-overflow, #haskell-blah and #haskell
13:52:59 <Excedrin> hm, what's te command for memos?
13:53:06 <sjanssen>  @tell
13:53:10 <chessguy_work> @tell Excedrin this command?
13:53:11 <lambdabot> Consider it noted.
13:53:12 <Excedrin> thanks
13:53:13 <lambdabot> Excedrin: You have 1 new message. '/msg lambdabot @messages' to read it.
13:53:46 <Excedrin> @tell dons typo in the last sentence of your polymer paper, s/out/our/
13:53:47 <lambdabot> Consider it noted.
13:55:55 <Excedrin> has anyone else read that paper? I thought that "runtime code generation" would be generating Haskell and I was looking forward to some crazy low-level code to achieve C/Fortran beating performance
13:56:45 <Heffalump> I think it's much more common to generate C etc than to generate Haskell.
13:57:29 <Excedrin> of course
13:58:27 <Excedrin> it's just that I'm not sure what the advantage of FP is; the performance comes from the fact that it's generated, specialized code, which could have been generated by any language
13:58:38 <Heffalump> yes, but FP is a good choice of generator
13:59:02 <samx_> what's the recommended library to use for reading in xml files ?
13:59:19 <Heffalump> HaXml is the standard, but it has some issues
13:59:47 <SamB> I think it is required for every XML library to have issues
14:00:13 <samx_> any experiences with hxt ?
14:00:20 <SamB> too many names
14:06:17 <fasta> Anyone familiar with pairing and lazy pairing heaps?
14:09:10 <bos> fasta: you'd be wanting derek elkins, whose nick currently escapes me.
14:09:22 <Heffalump> Darius?
14:09:27 <bos> yes!
14:09:54 <vincenz> ddarius
14:42:01 <hpaste>  eumenides pasted "Monad transformer madness" at http://hpaste.org/1346
14:42:20 <eumenides> can someone check what i'm doing wrong?
14:42:28 <stepcut> needs more monads
14:42:44 <Heffalump> you've fumbled your gestalt with the code
14:43:09 <Heffalump> why do you think your runH signature is the same as what it infers?
14:43:13 <sjanssen> eumenides: you have to wrap and unwrap the newtype
14:43:15 <Heffalump> there's an extra H type constructor in it
14:44:09 <hpaste>  sjanssen annotated "Monad transformer madness" with "unwrap the newtype" at http://hpaste.org/1346#a1
14:44:41 <eumenides> ahhhh thank you!
14:45:01 <DRMacIver> Hm. It's amazing how many Haskell success stories start off with parsec. :)
14:45:32 <stepcut> DRMacIver: what do Haskell failure stories start off with ?
14:45:38 <DRMacIver> Beats me.
14:45:58 <DRMacIver> Probably "I spent ages trying to understand these monad things and couldn't so I gave up"
14:46:05 <stepcut> heh
14:46:53 <DRMacIver> (I was just reading the first post on "Notes on Haskell" and it's another "Hey, I needed to parse a language. Oooh Haskell and Parsec" account)
14:47:15 * ulfdoz recommends reading a strictly formal book about Category Theory.
14:47:31 <ulfdoz> This doesn't help understanding, but getting the formal definition. ;)
14:48:30 <DRMacIver> I should point out that I'm not the one who tried to understand these monad things and couldn't so I gave up. :)
14:48:39 <DRMacIver> I don't fully understand them yet, but this doesn't bother me.
14:49:15 <DRMacIver> (And I've read formal books on Category theory, as well as attending a lecture course on it. I didn't really do very well though.)
14:52:42 <chessguy_work> what's "Notes on haskell"?
14:52:54 <DRMacIver> http://notes-on-haskell.blogspot.com/
14:52:57 <lambdabot> Title: Notes on Haskell
14:53:07 <DRMacIver> Random Haskell blog.
15:01:28 <Saizan> mmh a HAppS based blog software with integrated hscolour would surely have quite an audience in the haskell community (or maybe Network.CGI for less hosting problems?)
15:04:11 <sjanssen> I want blog software that lets me write in .lhs
15:04:54 <bos> i wrote a script that lets me do that.
15:05:25 <bos> give it a .txt or .lhs file, in markdown format, and it will turn it into something suitable for uploading to wordpress, and upload it.
15:06:14 <sjanssen> does it do TeX style lhs?
15:06:28 <bos> with \begin{code} etc? no.
15:06:58 <sjanssen> bird style (with '>') is very annoying to type in vim
15:07:10 <bos> i doubt it would take much work to fix that.
15:09:19 <jargonjustin> Regarding the term "type constructor", does it only apply to constructors defined via a data/newtype declaration or any function that is a -> T a ?
15:09:31 <Philippa> the former
15:09:40 <sjanssen> jargonjustin: type constructors /= data constructors
15:10:02 <jargonjustin> Philippa, sjanssen: Thanks
15:10:02 <fasta> jargonjustin: functions create values
15:10:06 <sjanssen> in "data T a = D a", T is a type constructor and D is a data constructor
15:11:20 <jargonjustin> Okay, then given sjanssens type declaration, is any function of type a -> T a considered a value constructor?
15:12:15 <sjanssen> data constructors are only the entities defined in a data or newtype declaration
15:12:56 <Saizan> data contructor have the nice property that they can be used in pattern matching, and that doesn't apply to arbitrary functions
15:13:11 <jargonjustin> Oh! Okay.
15:17:05 <DRMacIver> Hm. I wonder what sort of insane contortions you'd have to go through to allow arbitrary functions as pattern matching. :)
15:17:18 <DRMacIver> (Aside from throwing away all hope of an efficient implementation)
15:17:42 <sjanssen> DRMacIver: that'd be really really terrible
15:18:06 <DRMacIver> I know. :)
15:18:29 <sjanssen> basically, you'd never be able to throw away function applications, because you might attempt to match against it later
15:18:33 <dmwit> First of all, the functions would have to be one-to-one... guaranteeing that is a bit tricky.
15:18:35 <augustss> DRMacIver: like Mathematica, you mean. ;)
15:18:58 <Saizan> views has been proposed, but that's not quite the same
15:19:05 <DRMacIver> But then I'm the one who suggested an esolang based on autothreading via ambiguous grammars. The fact that an idea is awful just means it's more likely to amuse me. :)
15:19:09 <DRMacIver> augustss: Hm?
15:19:37 <augustss> Mathematica allows you to match on functions.  it's all a weird mix of symbolic and non-symbolic
15:19:39 <DRMacIver> dmwit: Nah. You just evaluate them in some appropriate sequence and find the first one which matches. :)
15:20:26 <dmwit> DRMacIver: Do you mean that you would pattern match against functions applied to compile-time constants?  If so, why not just expand them by hand?
15:20:41 <dmwit> And if not, where are the parameters for the function applications coming from?
15:20:42 <DRMacIver> Anyway, yes. It's obviously an awful idea. That's why I prefixed it with "I wonder what sort of insane contortions you'd have to go through..."
15:21:00 <Saizan> or: have some way to "register" the inverse g for a function f and apply g when trying to pattern match on f?
15:21:16 <DRMacIver> Saizan: Now, that's an interesting idea...
15:21:22 <dmwit> Saizan: Yeah, that's more what I was thinking.  But it still isn't very nice.
15:21:31 <sjanssen> many functions have no inverse
15:21:32 <dmwit> How do you guarantee that g really is the inverse of f?
15:21:40 <sjanssen> what is the inverse of tail?
15:22:01 <DRMacIver> dmwit: Oh, just hook up an automated theorem prover to the compiler. :)
15:22:02 <dmwit> sjanssen: Right, the functions have to be one-to-one, as I mentioned above.
15:22:17 <Saizan> dmwit: well that's like how you guarantee that monad instances conform to the rules?
15:22:32 <dmwit> touche
15:22:52 <Saizan> however it would be quite limited
15:23:13 <Excedrin> is cons the inverse of tail?
15:23:23 <DRMacIver> No
15:23:31 <dmwit> There is no inverse of tail.
15:23:38 <Saizan> well if you know what the head was :)
15:23:45 <dmwit> Or, the inverse of tail gives you an infinite set.
15:24:06 <jacobian> Hamlet-S has viewtypes
15:24:08 <dmwit> s/infinite//
15:24:17 <DRMacIver> I keep meaning to take a look at Hamlet-S
15:24:30 <DRMacIver> But my brain hurts every time I try to switch between ML and Haskell
15:24:42 <sjanssen> if I really wanted to implement this in Haskell, I'd change the runtime system such that every single piece of data carries the application that yielded it
15:26:17 <Saizan> free space leaks for everyone?:)
15:26:19 <jacobian> I like viewtypes because they can allow you to pattern match against existential types without leaking
15:29:17 <Saizan> sjassen: and if i have a = 8+10, (+1) x = a  would fail?
15:29:42 * LoganCapaldo wonders what pattern match against existentials means.
15:30:11 <reilly> does 6.6.1 have functional dependencies for GADTs?
15:30:23 <reilly> or only HEAD?
15:32:37 <Saizan> is there a 6.6.1 release?
15:33:47 <int-e> just a release candidate I think
15:35:37 <jargonjustin> Just checking that I'm understanding, Types are to Data as Kinds are to Types, right?
15:36:36 <augustss> yeah
15:37:16 <LoganCapaldo> and ? are to Kinds as Kinds are to Types ?
15:37:42 <augustss> the names start lacking at that point
15:37:43 <Botje> Fluffy Pink Robots(tm)
15:37:50 <LoganCapaldo> k
15:37:51 <augustss> superkinds?
15:37:51 <DRMacIver> Dependent types? :)
15:37:59 <Igloo> Some people use "sorts" don't they?
15:38:06 <Igloo> But really they're all just types
15:38:10 * LoganCapaldo was hoping for MetaKinds
15:38:16 <augustss> yeah, but it's far from standard
15:38:21 <jargonjustin> Igloo, Types of Types of Types :-)
15:38:33 <augustss> you can go as high as you like in that hierarchy
15:38:48 <Philippa> that, and "sorts" are often (to a first approximation) where you are in the hierarchy
15:38:49 * SamB wonders why dosemu doesn't mangle В» to >>
15:39:21 <augustss> or you can make smash it all into one level
15:39:22 <SamB> it mangles all the line-drawing chars...
15:40:15 <Philippa> I should play more with PTSes and variants one of these days
15:40:30 <Philippa> I'd had half a plan to do an Impure thoughts article based around them
15:40:40 <augustss> heh
15:41:13 <Philippa> with a hacker's "hey, this is like a DIY type system!" kind of perspective
15:42:09 <augustss> it's kinda fun to tinker with
15:42:15 <LoganCapaldo> It was Kind of you guys to Sort out all the different Types for me.
15:42:57 <Philippa> exactly, though obviously I would've had to find some evil twist to justify it being an IT article
15:44:17 <Philippa> the problem with a column like that is it gives you a reputation to maintain
15:45:02 <SamB> you should disown it!
15:46:02 <SamB> or you could call it Pure Thoughts when it doesn't seem to involve impurity for some strange reason...
15:56:00 <joelr1> is anyone using an emacs interface to darcs? is there one?
15:57:15 <thedward> joelr1: I a vim man myself, but the darcs wiki has some links: I am trying to work through my boss first, he is a good guy. Not sure
15:57:20 <thedward> erg
15:57:28 <joelr1> hmm
15:57:29 <thedward> joelr1: http://darcs.net/DarcsWiki/CategoryEmacs
15:57:31 <lambdabot> Title: CategoryEmacs - DarcsWiki
15:57:39 <joelr1> thedward: thanks!
15:59:44 <bos> joelr1: you want darcsum.el
15:59:50 <bos> it's quite decent.
16:00:12 <joelr1> bos: thanks
16:15:52 <kmg> @pl (\py -> take px xs ++ drop (py+1) ys)
16:15:53 <lambdabot> (take px xs ++) . flip drop ys . (1 +)
16:18:16 <dons> http://programming.reddit.com/info/1h6gh/comments
16:18:17 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
16:18:18 <lambdabot> Title: Haskell for C# Programmers (reddit.com)
16:19:04 <kmg> @pl (\(px,pys) -> map ((take px xs ++) . (flip drop ys) . (1 +)) pys)
16:19:05 <lambdabot> uncurry (map . (. (flip drop ys . (1 +))) . (++) . flip take xs)
16:19:08 <Laney> ?where happs
16:19:09 <lambdabot> http://happs.org
16:19:19 <Laney> ?where gmh
16:19:19 <lambdabot> I know nothing about gmh.
16:19:46 <kmg> @type uncurry
16:19:49 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
16:20:39 <kmg> @pl nub $ concatMap (\(px,pys) -> map ((take px xs ++) . (flip drop ys) . (1 +)) pys) positions
16:20:40 <lambdabot> nub (uncurry (map . (. (flip drop ys . (1 +))) . (++) . flip take xs) =<< positions)
16:26:09 <joelr1> dons: how long have you been coding in haskell?
16:27:15 <LoganCapaldo> Is there a C# for Haskell programmers?
16:27:31 <Philippa> Laney: I don't think he IRCs much either
16:27:39 <dons> joelr1: since 1999. so 8 years now.
16:27:48 <joelr1> dons: ouch
16:28:00 <Laney> Philippa: I was just hoping for a quick link to his site, to get to my coursework ;)
16:28:01 <joelr1> dons: i mean that in the good sense, of course
16:28:03 <dons> only seriously for the last 5.
16:28:25 <Philippa> Laney: www.cs.nott.ac.uk/~gmh ?
16:28:39 <joelr1> how is this project useful? Generalizing Parsec to ParsecT and arbitrary input
16:28:42 <Laney> Philippa: Yeah, I know it. I was just being lazy
16:28:59 <dons> joelr1: faster, more flexible, parsers.
16:29:00 <Philippa> you shouldn't expect lambdabot to know CSIT usernames though
16:29:08 <joelr1> also, what's wrong with shared libraries for ghc?
16:29:18 <joelr1> i thought you could do this now
16:29:19 <dons> we don't have them.
16:29:25 <dons> only on the mac.
16:29:26 <joelr1> oh, only static ones?
16:29:31 <joelr1> ah! i'm on th emac
16:29:34 <joelr1> that's why
16:29:35 <Laney> Fair enough.
16:29:50 * joelr1 is stuck in parsers up to his ears
16:30:07 <Philippa> ah well. My account should be dead now anyway
16:30:30 <Laney> You were a CSiT-er?
16:30:47 <Philippa> yeah. Still live in Nottingham, too
16:30:47 <Excedrin> joelr1: have you mentioned what these parsers are for? you seem to work on interesting projects, so I'm curious..
16:31:12 <Philippa> joelr1: just out of interest, how much parsing work've you done elsewhere and what tools're you used to?
16:31:14 <ddarius> LoganCapaldo: Programming book publishers don't see too much traffic in that direction, no doubt because of the vast superiority of Haskell to C# and completely unrelated to the relatively low number of Haskell programmers.
16:31:34 <joelr1> sure
16:31:59 <joelr1> Excedrin: this is a translator (compiler?) from a pascal-like trading language into c#
16:32:06 <LoganCapaldo> ddarius: but it would be bizzare
16:32:10 <Philippa> Laney: you a fresher then, or are you doing one of the more interesting modules?
16:32:20 <joelr1> Excedrin: which i plan to finish soon and deploy on the web to charge traders for translations
16:32:24 <Laney> I'm doing Graham's AFP module
16:32:44 * LoganCapaldo wishes he had joelr1's job
16:32:50 <joelr1> Philippa: i wrote my current translator in ocaml, took me about a month, including learning ocaml itself. it's fully working and tested
16:32:56 <Philippa> ah. That started after I was last able to study, or I would've shown up for it sometime
16:32:58 <Laney> ..although Henrik Nilsson is also using Haskell for the compilers module starting this year
16:33:03 <Philippa> about time
16:33:06 <Laney> which is good fun!
16:33:10 <joelr1> Philippa: now i'm struggling with rewriting it in haskell
16:33:13 <joelr1> LoganCapaldo: i don't have a job
16:33:16 <Philippa> compiler coding in Java is... unpleasant
16:33:28 <Pseudonym> Compiler coding in C++ is also unpleasant.
16:33:32 <Laney> I can imagine
16:33:32 <LoganCapaldo> I wish I had your hobby?
16:33:35 <LoganCapaldo> heh
16:33:40 <Philippa> Pseudonym: less so than Java
16:33:44 <Laney> Happy is quite nice, at least for something this simple
16:33:50 <Pseudonym> Philippa: That's true these days/
16:33:51 <Philippa> C++ at least has unions
16:33:52 <joelr1> i decided to switch to haskell since i had trouble binding ocaml to ruby and generally deploying things on the web. plus, there's not much of a community, unlike with haskell
16:34:02 <Pseudonym> Philippa: Actually, that's half the problem with C++.
16:34:09 <Pseudonym> Unions don't play nicely with Modern C++(tm).
16:34:13 <Philippa> *nod*
16:34:18 <joelr1> LoganCapaldo: you mean you wish you were a freelancer living in beautiful tenerife ;-) http://flickr.com/photos/joelr1
16:34:19 <lambdabot> Title: Flickr: Photos from joelr1
16:34:20 <Pseudonym> Boost has variant records.
16:34:23 <Philippa> but then it's worse with Java
16:34:30 <Pseudonym> Which helps a LOT.
16:34:36 <SamB> C++ has boost, that is true...
16:34:37 <Philippa> Modern C++ is too modern for me, I've barely written any in the last half decade thankfully
16:34:49 <joelr1> LoganCapaldo: i'm banking my future on this project, this is my startup
16:34:51 <Pseudonym> Even so, you really miss pattern matching.
16:34:55 <Excedrin> that's a good book, except for all the template stuff
16:34:58 <Philippa> yep
16:35:03 * joelr1 is haskelling full-time
16:35:04 <ddarius> Haskell's community strikes again!
16:35:05 <Pseudonym> You know that O'Caml, Haskell etc were originally optimised for writing their own compilers in.
16:35:05 <Laney> I'm currently trying to get my head around monad transformers and the writer monad for the bonus exercises -- http://www.cs.nott.ac.uk/~gmh/afpcwk2.pdf
16:35:09 <Laney> Not making much headway though
16:35:20 <Philippa> the theory for transformers is easy, the practice is slightly tougher
16:35:24 <Pseudonym> So of course writing compilers is going to be easier.
16:35:31 <LoganCapaldo> joelr1: neat
16:35:46 <Philippa> the theory is that they're more or less functions of type Monad -> Monad, only in some language that's not quite haskell - so you have to translate that into something that is
16:35:56 <Laney> Philippa: The inverse of what I found with State then!
16:36:00 <Philippa> (a new type constructor, and operations)
16:36:10 <Laney> Confusing until I actually coded with it, then simple
16:36:12 <Philippa> Writer's more or less a restriction of state
16:36:26 <Philippa> *nod* - it's simple once you've realised how the syntax has to go
16:36:29 <Pseudonym> And Reader is yet another restriction.
16:36:39 <Philippa> and still fairly simple until you have to write your own transformer
16:36:48 <Pseudonym> The way to think of Writer is statistics collection and/or logging.
16:36:48 <LoganCapaldo> joelr1: Cool. My jealously knows no bounds ;)
16:37:00 <joelr1> LoganCapaldo: :-)
16:37:00 <LoganCapaldo> Writer++
16:37:08 <Laney> I've looked at the firewall example in All About Monads
16:37:16 <Laney> Makes little sense. I guess I'm going to have to play with the code
16:37:21 <Pseudonym> But for logging, I tend to just use a transformer over IO.
16:37:36 <Pseudonym> I can envisage situations where that doesn't cut it, though.
16:37:55 <Philippa> any time you're not allowed to do IO, for one
16:38:03 <Pseudonym> Right, like STM.
16:38:08 <Laney> It's all good fun until I accidently stray into a hardcore research paper
16:38:15 <Philippa> heh
16:38:18 <LoganCapaldo> Philippa: how come you never said Monad -> Monad functions before? Now I have an inkling of why you'd want monad transformers. You people gotta give out your secrets earlier. :)
16:38:19 <Philippa> actually those're fun too
16:38:26 <Philippa> you just have to learn
16:38:27 <Pseudonym> Another is when IO would unnecessarily sequentialise the computation.
16:38:35 <Philippa> LoganCapaldo: because I haven't explained monad transformers to anyone in a while
16:38:37 <Laney> Aye
16:38:59 * ddarius never uses Writer.
16:39:04 <Laney> And I come across terrifying terms like Monoid and Functor
16:39:08 <Philippa> Pseudonym: that's just a case for unsafePerformIO brain, no?
16:39:12 <Philippa> yeah
16:39:31 <Laney> It's just all new ground, Haskell has quite a steep learning curve
16:39:38 <Philippa> Monoid can't really be given a better name. You can think of instances of Functor as 'mappable' though
16:39:41 <Laney> But the view from the top is great!
16:39:54 <Philippa> it's not bad from a quarter of the way up, either
16:40:00 <Laney> Well, yes.
16:40:08 <Laney> That's what I'd know :(
16:40:15 <Philippa> from the top, you find yourself snarking lispers
16:41:14 <Excedrin> what's snarking
16:43:06 <Philippa> making "snarky" comments (I suspect the word derived from "sarky" as in sarcastic, but there's a subtle difference in meaning)
16:43:40 <Philippa> one suggestion is it comes from "SNide remARK"
16:44:33 <Philippa> Laney: googling gmh gives you a relevant link on the first page, btw
16:45:00 <Laney> Haha, I assume you aren't talking about this:
16:45:00 <Laney> Gay Men's Health
16:45:00 <Laney> A health organisation for gay and bisexual men in Edinburgh and the Lothians. Provides information, free counselling, events, condoms and lube, ...
16:45:22 <Philippa> I didn't say it's the first hit :-)
16:45:33 <Laney> Tickled me a bit, s'all
16:45:55 <Philippa> yeah? I don't see them dispensing feathers...
16:46:05 <Pseudonym> They dispense whole chickens!
16:46:10 <Pseudonym> Thus reducing it to the previous joke.
16:46:38 <kmg> @pl nub $ concatMap (\(px,pys) -> map ((take px xs ++) . (flip drop ys) . (1 +)) pys) positions
16:46:38 <lambdabot> nub (uncurry (map . (. (flip drop ys . (1 +))) . (++) . flip take xs) =<< positions)
16:47:00 <joelr1> Philippa: why did you ask about my parsing experience?
16:47:36 <Philippa> joelr1: wondering how much culture clash you are or aren't experiencing
16:48:02 <joelr1> Philippa: i'm mostly experiencing (infrequent) angst with Parsec :D
16:48:35 <Philippa> *nod*
16:49:07 <Philippa> Parsec's good, but the learning curve's not quite as trivial as it looks at first glance
16:49:35 <Pseudonym> joelr1: If it's truly Pascal-like (i.e. an operator grammar), you might be better off with something simpler.
16:49:57 <Pseudonym> Have you looked at happy?
16:50:51 <joelr1> Pseudonym: i'm too far into this already :( almost done with the parser, in fact, running through the unit tests
16:50:55 <Philippa> *nod* - a significant chunk of Parsec's goodness is that it'll handle most parsing problems you can throw at it
16:50:58 <Pseudonym> Right.
16:51:09 <Philippa> sometimes that's more power than you want though
16:51:19 <joelr1> Pseudonym: happy would have been reasonably simple since i already have a fully working yacc grammar for ocamlyacc, plus a lexer
16:51:31 * Pseudonym nods
16:51:45 <Pseudonym> But you wouldn't be doing this if you weren't trying to learn something, right?
16:51:57 <Philippa> ah. I might've remembered to recommend alex/happy for that particular situation, if I'd been around and thinking at the time
16:52:06 <joelr1> Pseudonym: yeah, i always get myself into trouble :-(
16:52:07 <ddarius> Another significant chunk is that it's just Haskell code and you can add any abstractions you need.
16:52:26 <joelr1> Pseudonym: trying to learn new things while simultaneously deploying that knowledge in production
16:52:30 <Philippa> yeah, although that applies to much of its immediate competition as well
16:52:33 <Pseudonym> Right.
16:52:36 <Pseudonym> Best of both worlds.
16:53:25 <Pseudonym> If you read old compiler textbooks, they tell you that lexical analysis and parsing are the most expensive bits of a compiler.
16:53:31 <Philippa> but Parsec marks out a particular part of the design space that's definitely better done with combinators than generators and is worth having a lib for even if you have better tools for more restricted cases
16:53:32 <joelr1> :t map
16:53:34 <Pseudonym> That hasn't been true for 15 or so years.
16:53:34 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
16:55:53 <Beelsebob|OddPla> giggle... http://slashdot.org/comments.pl?sid=230415&threshold=1&commentsort=0&mode=thread&cid=18696491
16:55:56 <lambdabot> Title: Intel Reveals the Future of the CPU-GPU War, http://tinyurl.com/2sow6o
16:56:17 <Pseudonym> What "war" would that be?
16:56:22 <Beelsebob|OddPla> sillyness -- someone asked /. to point out plces where FP is ever actually used
16:56:30 <Beelsebob|OddPla> so I pointed out google search
16:56:42 <Beelsebob|OddPla> and they went, "nah, doesn't count, it's not open source"
16:56:55 <Beelsebob|OddPla> so I replied "how about perl's compiler"
16:57:37 <Pseudonym> That's not parallel.
16:57:41 <Beelsebob|OddPla> true that
16:57:45 <Pseudonym> I want to know why open source doesn't count.
16:57:46 <Beelsebob|OddPla> good point
16:57:49 <Beelsebob|OddPla> so do I
16:57:53 <Pseudonym> I read the reasoning.
16:58:08 <Beelsebob|OddPla> someone else has usefully pointed out that lots of telephone exchanges are written in erlang
16:58:13 <Pseudonym> I can't think of many massively parallel open source applications.
16:58:39 <Beelsebob|OddPla> nor can I actuallt
16:58:40 <Beelsebob|OddPla> y
16:58:53 <Pseudonym> And certainly, I can't think of many that were written recently.
16:58:55 <Philippa> I think they're called VBScript viruses
16:59:13 <Philippa> oh, wait, that's distributed, right? :-)
16:59:24 <dibblego> the premise that commercial software represents real world solutions moreso than some other type of software (e.g. open source) is false
17:00:28 <Beelsebob|OddPla> dibblego: maybe so... but why does that mean that it should be discounted as not an example of a good use for this stuff
17:00:30 <Philippa> dibblego: no, it's just not obviously true. There's no reason to expect open source to represent 'real world' more than closed either, and some good reasons to imagine that there are aspects of 'real world' it doesn't
17:01:05 <Beelsebob|OddPla> does google not being open source stop it being increadably useful
17:01:29 <dibblego> it seems  some people believe this is all - and the very worst software I have ever seen is commercial, and I have marked many university assignments :)
17:01:32 <Beelsebob|OddPla> in fact... there is good reason to expect software that people pay for to be representative of what real world people want... they
17:01:33 <Beelsebob|OddPla> 'r
17:01:38 <Beelsebob|OddPla> paying aren't they?
17:01:44 <Excedrin> does stuff like the distributed.net count as a massively parallel open source application?
17:01:46 <Philippa> *hahahahahaha*
17:02:03 <Philippa> sorry, just had dinner earlier with someone who's been doing an awful lot of managing customer's expectations because they can't
17:02:12 <Beelsebob|OddPla> hehe
17:02:14 <Excedrin> also, I know QuantumG from years ago
17:02:23 <Excedrin> he's not worth arguing with
17:02:47 <Beelsebob|OddPla> Excedrin: maybe not, but being modded up gains me karma :P
17:03:05 <dibblego> "FP is being used in Java applications, since look at them trying to write functions!"
17:08:20 * lispy just saw something in haskell-cafe that could make him very happy
17:08:33 * lispy idles in hopes of the final word coming out from Google as expected
17:13:29 <kc5tja> hmmm
17:13:32 * kc5tja works at Google...
17:13:36 <kc5tja> The final word is, ....
17:14:02 <kc5tja> "AGGLUTINATIONALIZATION!"
17:14:03 <kc5tja> ;D
17:14:36 <LoganCapaldo> Oh did they switch to Haskell at google? :)
17:14:48 * kc5tja sighs -- I wish.  :(
17:15:06 <kc5tja> I think we tend to use a lot of Scheme for RAD stuff, but production stuff gets translated to the Big 4.
17:15:57 <LoganCapaldo> Big 4?
17:16:12 <kc5tja> Java, Javascript, Python, and C++
17:16:41 <LoganCapaldo> Scheme eh?
17:17:16 <kc5tja> Yeah, I can't be sure thought.
17:17:16 * LoganCapaldo imagines years of google accumulated scheme libs
17:17:19 <kc5tja> though even.
17:17:27 <kc5tja> It doesn't happen.
17:17:32 <kc5tja> It'd be nice if we did.
17:17:42 <kc5tja> Debugging all of our stuff would be that much easier.
17:17:53 <LoganCapaldo> Gasp
17:17:59 <LoganCapaldo> Google has to debug???
17:18:01 <LoganCapaldo> ;)
17:18:14 <kc5tja> What makes you think we don't?
17:18:33 <LoganCapaldo> I don't actually think that
17:18:38 <LoganCapaldo> I was trying to be funny
17:18:53 <kc5tja> I kno.
17:18:53 <LoganCapaldo> You
17:19:02 <LoganCapaldo> d think I'd learn by now that I'm not
17:19:03 <kc5tja> Everyone seems to re-use the same joke over and over though.  :(
17:19:15 <Beelsebob|OddPla> lol
17:19:40 <Beelsebob|OddPla> kc5tja: someone has mde that point actually, that map reduce is ultimately C++ code
17:20:06 <Beelsebob|OddPla> but completely missed that it's the fact that it's a functional library that makes it fast and allows it to be parralelised
17:20:15 <ddarius> Haskell is ultimately assembly code.
17:20:21 <Beelsebob|OddPla> exactly
17:20:32 <Beelsebob|OddPla> that was essentially my reply
17:20:48 <Beelsebob|OddPla> at some point we have to make it procedural -- we have procedural chips aftter all
17:22:05 <stepcut> Beelsebob|OddPla: you mean, you don't use one of these ? http://en.wikipedia.org/wiki/Graph_reduction_machine
17:23:27 <Beelsebob|OddPla> stepcut: why of course I do in my office, but at home, us poor gamers have to deal with our turing machines with only finite tapes :(
17:23:50 <Beelsebob|OddPla> o.O
17:23:57 * Beelsebob|OddPla wonders who tomdavies is
17:24:04 <stepcut> Beelsebob|OddPla: just tape the two ends of the tape together --> infinite tape!
17:24:12 <Beelsebob|OddPla> stepcut: ROFL
17:24:19 <stepcut> and if you give it a half twist: infinite mobius tape!
17:24:19 <Beelsebob|OddPla> impersonator?
17:24:37 <tomdavies> hi, just lurking
17:24:39 <Beelsebob|OddPla> stepcut: wow, then I could write on the back of my RAM chips too
17:24:49 <Beelsebob|OddPla> tomdavies: scary... I'm Tom Davie
17:24:54 <Beelsebob|OddPla> o.O
17:24:57 <Stinger> ram chips on tape huh
17:25:23 <tomdavies> That is a coincidence!
17:25:31 <Beelsebob|OddPla> Stinger: sure, you just need to superglue them on every 10cm or so
17:27:05 <stepcut> is there a name for the type constructor (->) ?
17:27:29 <sioraiocht> Arrow? probably not..
17:28:30 <LoganCapaldo> to?
17:29:00 <stepcut> ah! I'll just name my type constructor, (-->) and then I won't have to care ;)
17:29:08 <sioraiocht> heheh
17:29:14 <LoganCapaldo> brilliant
17:30:23 <abarbu> Out of curiosity, how does everyone build and maintain C bindings here?
17:30:30 <abarbu> I'm using hsffig; which is a bit of a pain
17:30:35 <abarbu> Due to the fact that it's ultra-slow
17:30:36 * stepcut uses hsc2hs
17:30:47 <stepcut> or sometimes, just plain old FFI
17:30:49 * LoganCapaldo doesn't
17:31:14 <abarbu> Yeah, but I have a large bit of C code to interface to
17:31:30 <abarbu> I don't want to sit and write glue code
17:32:48 <abarbu> hsc2hs seems to require quite a bit of work on my part
17:32:52 <stepcut> yeah
17:33:04 <abarbu> (this thing that I'm interfacing to has a lot of structures)
17:33:17 <stepcut> I didn't understand the automatic generators at first, so I opted to go direct. I should probably learn a better tool now that I know how they worth underneath the hood
17:34:09 <abarbu> Ah, yeah; I understand how to do it by hand; which is why I know I'll spend more time over the next month writing that glue code than my actual code
17:34:34 <dons> hsc2hs or c2hs these days
17:34:39 <dons> ?users
17:34:40 <lambdabot> Maximum users seen in #haskell: 336, currently: 304 (90.5%), active: 40 (13.2%)
17:35:35 <stepcut> s/worth/work/
17:35:38 <abarbu> dons, possibly I'm missing something but don't both of those require me to do a whole bunch of work upfront before they'll generate the bindings?
17:35:58 <Beelsebob|OddPla> dons: do you happen to know when freenode start pushing people into #overflow?
17:36:01 <rhz> I would like to call a function in a small C++ library from my haskell code. Is that also possible to do?
17:36:43 <dons> abarbu: define 'whole bunch'? :-)
17:36:53 <hpaste>  Tims2 pasted "No farewell when Control-C pressed." at http://hpaste.org/1347
17:36:57 <stepcut> rhz: the easiest way is to make the C++ function callable from C, and then just bind to it from Haskell
17:37:37 <stepcut> rhz: if you control the C++ library you can add some extern "C" statements, otherwise, you can write a little C++ -> C wrapper that you include with your Haskell bindings
17:37:59 <abarbu> dons, For example.. writing one line of code (so say, the type signature) of every C function is way more work than i'm willing to do
17:38:10 <abarbu> dons, Not to mention peek and poke statements for the datastructures
17:38:12 <tims2> When I run the pasted code (http://hpaste.org/1347#a0) using ghc 6.6 on Ubuntu or Windows, the farewell function is never called when I hit Ctrl-C.
17:38:18 <stepcut> rhz: you can also call C++ directly, but that is pretty dodgey, because it is compiler specific (Typically C++ compilers can't link to other C++ compilers)
17:38:26 <LoganCapaldo> Do signals get transformed into exceptions in haskell?
17:38:41 * LoganCapaldo suspects the answer is no
17:39:00 <stepcut> LoganCapaldo: signals? like in Qt? Or process signals ?
17:39:07 <rhz> stepcut: Ok, so I can create another header which includes the c++ header and puts extern "C" {} around that? Then I can just treat the library like a C library...
17:39:07 <LoganCapaldo> Unixy signals
17:39:26 <LoganCapaldo> @hoogle trap
17:39:27 <lambdabot> No matches found
17:39:33 <dons> abarbu: try c2hs then.
17:39:37 <stepcut> rhz: yes, that is the most portable way
17:40:14 <tims2> bye only prints when running under ghci under Ubuntu Linux; If I compile the code using ghc --make under Ubuntu, it doesn't work.
17:40:24 <stepcut> LoganCapaldo: http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Posix-Signals.html
17:40:27 <lambdabot> http://tinyurl.com/2esvkl
17:40:33 <LoganCapaldo> tims2: ^^
17:40:47 <LoganCapaldo> ghci (obviously) traps SIGINT
17:40:47 <tims2> LoganCapaldo: Thanks
17:41:02 <LoganCapaldo> tims2: welcome :)
17:41:34 <stepcut> LoganCapaldo: you use installHandler to install signal handlers
17:41:49 <LoganCapaldo> I gathered
17:41:51 <abarbu> dons, Thanks; I'll give it a try, possibly it'll cope with some of the odd stuff in those headers better
17:42:06 * LoganCapaldo feels like a foreign language interpreter
17:42:27 <stepcut> LoganCapaldo: you can probably install a signal handler that throws an exception if you want
17:42:38 <LoganCapaldo> tims2: ^^
17:42:45 <kc5tja> Beelsebob|OddPla: MapReduce is C++.  However, it's also heavily parallelized.
17:42:47 <LoganCapaldo> then finally should work :)
17:43:26 <kc5tja> Beelsebob|OddPla: But, the interesting thing is, MapReduce really doesn't perform MapReduce.  It's more like MapFold or MapMap.  :)
17:43:54 <LoganCapaldo> I thought Reduce was synonmous with fold
17:43:57 <tims2> LoganCapaldo: that's just what I want.  Thanks!
17:44:03 <LoganCapaldo> np
17:45:38 <stepcut> LoganCapaldo: this program has an example of turning signals into exceptions and then catching them --> http://apt2.freespire.org/freespire/pool/main/b/build-env/build-env_2.2-0freespire6.tar.gz
17:45:40 <lambdabot> http://tinyurl.com/2v5fm9
17:45:46 <hpaste>  Mr_Awesome pasted "(no title)" at http://hpaste.org/1348
17:46:05 <LoganCapaldo> stepcut: Please feel free to s/LoganCapaldo/tims2/g :)
17:46:06 <stepcut> LoganCapaldo: http://blogs.msdn.com/ralflammel/archive/2007/04/11/more-than-a-revision-on-mapreduce-revisited.aspx
17:46:08 <lambdabot> Title: Grammarware, Haskellware, XMLware : More than a revision on вЂњMapReduce revisit ..., http://tinyurl.com/ys2l4s
17:46:30 <Mr_Awesome> is there something wrong with emacs? i get a parse error when i use its default indentation that is resolved when i fix it as shown in the paste
17:46:46 <dmwit> Mr_Awesome: The indent mode is giving you an illegal indentation.
17:47:09 <stepcut> LoganCapaldo: oh, i see :)
17:47:19 <abarbu> Yeah.. the indent mode doesn't seem to do be doing too well
17:47:38 <dmwit> Inside a do block, the "then/else" clause has to be indented further than the "if".
17:48:19 <Mr_Awesome> dmwit: but this is not so out of a do block?
17:48:26 <dmwit> correct
17:48:30 <LoganCapaldo> stepcut: I take it this is the key line: "generations of young students may start to think that MapReduceвЂ™s map and reduce are like a classic functional programmerвЂ™s map and reduce"
17:48:38 <Mr_Awesome> i see. thanks
17:48:56 <stepcut> LoganCapaldo: yeah. In the paper he describes the differences more
17:49:55 <dmwit> ?hoogle IO a
17:49:56 <lambdabot> System.exitFailure :: IO a
17:49:56 <lambdabot> Control.Exception.evaluate :: a -> IO a
17:49:56 <lambdabot> Network.withSocketsDo :: IO a -> IO a
17:50:56 <dmwit> :t fmap read getLine
17:50:59 <lambdabot> forall a. (Read a) => IO a
17:51:24 <dmwit> ?hoogle (Read a) => IO a
17:51:25 <lambdabot> Prelude.readLn :: Read a => IO a
17:51:25 <lambdabot> System.exitFailure :: IO a
17:51:25 <lambdabot> Prelude.readIO :: Read a => String -> IO a
17:51:38 <LoganCapaldo> so its somewhat like ClassifyAggregate?
17:51:54 <stepcut> is there an idiomatic way in HUnit to write a test for a function that *should* throw an exception ?
17:52:08 <stepcut> perhaps, I just use 'try', and see if it catches the right thing or not ?
17:54:25 <TomMD> Is there a good 'Haskell as a script' module I should know about?  As an exercise I remade a python script in Haskell and noted Pythons optparse did 'Help' messaging as well as argument parsing quite simply (although not as legibly as it could have).
17:54:57 <dmwit> TomMD: You mean like getOpt?
17:55:37 <TomMD> ?where getOpt
17:55:38 <lambdabot> I know nothing about getopt.
17:55:42 <TomMD> ?src getOpt
17:55:42 <lambdabot> Source not found. That's something I cannot allow to happen.
17:55:51 <dmwit> ?index getOpt
17:55:51 <lambdabot> Distribution.GetOpt, System.Console.GetOpt
17:55:52 <dons> http://programming.reddit.com/info/1h75m/comments
17:55:53 <lambdabot> Title: Vectro: Haskell library for statically typed linear algebra (reddit.com)
17:56:05 <dons> reclaim reddit for programmers! :-)
17:56:15 <stepcut> heh
17:56:36 <sjanssen> dons: did you see the reddit comment earlier, "where are all the haskell posts"?
17:56:46 <dons> yeah.
17:56:52 <dons> i replied.
17:57:01 <dons> i've got a pretty complete hwn issue ready to go actually
17:57:10 <dons> maybe i should send that out now, and then we can work on the TMR..
17:57:28 <sjanssen> yeah, I really really need to start doing that
17:57:44 <sjanssen> dons: do you have any uncommitted changes?
17:57:52 <dons> nope.
17:58:04 <sjanssen> okay, let me see what I want to start with
17:58:04 <dons> i suggest we just attack each section we wrote code for.
17:58:08 <dons> so you could do the tiling algo
17:58:13 <dons> or the motivation
17:58:29 <dons> i was thinking i'd do a quick section on QC and e.g. the newtype bug fixes from yesterday.
17:58:42 <SamB> newtype bug fixes?
17:58:59 <dons> we had a bug. we added newtypes. they wouldn't type check .revealed a logical error. then it all jsut worked
17:59:01 * SamB has difficulty imagining newtypes having bugs
17:59:10 <dons> basically there was only one way to make the code to fit together correctly
17:59:10 <SamB> ah.
17:59:23 <dons> and trying to fit it another way just wouldn't work, which revealed a mistake.
17:59:27 <SamB> isn't that kinda the point of newtypes?
17:59:41 <dons> well. its an effect of them.
18:01:15 <sjanssen> SamB: yes, newtypes were the solution to a bug introduced by being untyped (using Int as indices for two different concepts)
18:01:29 <SamB> reminds me of Yhc
18:01:38 <dons> interestingly we did break abstraction
18:01:50 <SamB> in fixing it?
18:01:57 <dons> probably we should keep the StackSet polymorphic over both index types.
18:02:22 <dons> sjanssen: have you tried my 'promote' generalisation?
18:02:37 <sjanssen> dons: yeah, I did
18:02:47 <dons> i'd be intersted in a fix for the problem of cycling running in different directions in tall and wide mode.
18:02:48 <sjanssen> you can't really call it a generalization though
18:03:04 <sjanssen> it's actually less expressive than the old solution
18:03:13 <dons> heh. the old way basically worked like 'cycle', except in certain cases.
18:03:19 <dons> so yes, perhaps its a simplification.
18:03:43 <dons> also, do we have an invariant with mode switching, wrt. the focused window?
18:04:09 <dons> i *think* the focused window in full screen, becomes the master window in both tiled modes. and vice versa?
18:04:15 <sjanssen> dons: there are window orders that you can't produce with the new system.  We'll need to have both functions eventually
18:04:41 <dons> oh yes, so perhaps a cycle, and a flip/drag idea.
18:04:58 <sjanssen> dons: focus in full screen is independent of master in tiling
18:05:33 <dons> i'd suggest that the focused window in full screen is used to set the master tiled window (that's the head of the list that's tiled?)
18:05:54 <sjanssen> this gets tricky
18:05:55 <dons> anyway, no big deal. just noticed that we could have some property defined for this
18:07:27 <dons> anyway, for now it is best to dive in an try to write one of the sectoins you know best for TMR :-)
18:07:37 <dons> i'll get HWN out now, then do a couple of sections as well
18:07:46 <dons> if we need it, i'm sure we can get the weekend.
18:17:38 <sjanssen> @seen jcreigh
18:17:39 <lambdabot> jcreigh is in #haskell-blah and #haskell. I last heard jcreigh speak 9h 58m 38s ago.
18:18:03 <sjanssen> @tell jcreigh I'd love a screenshot of your three screen xmonad setup
18:18:03 <lambdabot> Consider it noted.
18:18:41 <dons> yeah. that'd be nice.
18:18:51 <vincenz> hiya dons
18:21:30 <rhz> stepcut: It seems that extern "C" must go inside the actual C++ code, so I need to modify the original library. I can't see how to just write a wrapper for C++ -> C.
18:22:21 <dmead> bonk
18:22:29 <stepcut> rhz: hrm, let me check
18:22:43 <ariks> can you declare variables in ghci?
18:22:45 <chessguy> 'evening haskellers
18:22:46 <dmead> rhz: you need to do some #define tricks
18:22:55 <chessguy> @quote variable
18:22:56 <lambdabot> blackdog says: My variables aren't varying.
18:22:59 <dmead> ariks: yes, with a let statement
18:23:22 <ariks> dmead: ah, thanks!
18:23:39 <dmead> > let x = 5 in x + 1
18:23:41 <lambdabot>  6
18:23:42 <ariks> i suppose that's how i would declare functions too
18:23:45 <dmead> like that
18:23:51 <dmead> no
18:23:54 <dmead> well, you can
18:24:03 <dons> sjanssen: how did we do screenshots of tiled mode with xwd?
18:24:06 <dons> or did we use something else?
18:24:07 <dmead> but you should use emacs with ghci
18:24:28 <ariks> that will automagically load the file i'm editing?
18:24:32 <dmead> yep
18:24:53 <dmead> you can split the emacs window in multiple panes or "buffers"
18:25:06 <dmead> on top half you'd have some haskell code
18:25:15 <dmead> and hit a few key bindings to send it to the ghci session in another buffer
18:25:21 <sjanssen> dons: I used import, from imagemagick
18:25:27 <TSC> You mean you can split the emacs frame into multiple windows (:
18:25:36 <ariks> i guess that's worth learning emacs over
18:25:38 <dmead> but it's not like lisp where you can just write functions on the interpreter
18:25:50 <dmead> yes, very
18:26:11 <stepcut> rhz: I think you have to write the wrapper itself in C++ and compile it with g++.  But you put the extern "C" stuff in so that your new C++ wrapper is callable from C?
18:27:11 <stepcut> rhz: http://groups.google.com/group/comp.lang.c++/browse_thread/thread/965d9905242171f7/f6ec71c5ff7d821d?lnk=st&q=calling+C%2B%2B+from+C&rnum=5&hl=en#f6ec71c5ff7d821d
18:27:15 <lambdabot> Title: C calling C++. How to do this ? - comp.lang.c++ | Google Groups, http://tinyurl.com/2hj2ue
18:27:52 <stepcut> rhz: see the message from 'Bjarne Stroustrup '
18:28:13 <stepcut> rhz: i think he might know what he is talking about ;)
18:28:17 <dmead> rhz: i had to do this for  quake project... let me know if you need help
18:31:14 <procyon112> rhz: try something like wrapper.h--> extern "C" { #include "wrapped.h" }
18:32:38 <dmead> almost
18:33:01 <dmead> you have to use conditional compilation on your function prototypes
18:33:10 <dmead> say in c++, you have
18:33:17 <dmead> void foo(int bar);
18:33:29 <dmead> that has to be
18:33:48 <dmead> #ifdef cplusplus
18:33:53 <dmead> extern "C" {
18:33:59 <dmead> err
18:34:00 <dmead> sorry
18:34:02 <dmead> ifndef
18:34:05 <dmead> fuck it, i'll paste
18:34:18 * dmead digs up old code
18:34:33 <QtPlatypus> Why did haskell select camelCase?
18:35:10 <dmead> ?hpaste
18:35:11 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:35:33 <SamB> QtPlatypus: confusion between Haskell and Pascal again?
18:35:33 <kilimanjaro> QtPlatypus, because types have the first letter in upper case
18:35:35 * SamB jokes
18:36:04 <procyon112> QtPlatypus: It's not camelCase.. simply Types, Modules and Constructors are capitalized, whereas functions and variables are not.
18:36:26 <procyon112> using camelCase is up to you :)
18:37:05 <hpaste>  dmead pasted "C++ -> C wrapper" at http://hpaste.org/1349
18:38:46 <dmead> theres other neat stuff you can do in g++, like making C think it has access to some structs
18:38:51 <dmead> which are really classes in C++ land
18:38:52 <ariks> that haskell/pascal confusion is very annoying. It takes starting a conversation about it very painful.. "no haskell. not paskell." "no HASKELL with an h."
18:38:56 <dmead> by giving them C linkage
18:39:07 <dmead> ariks: thats happened to me like 10 times
18:39:15 <desp> Paskell? hahah
18:39:18 <dons> sjanssen: a recent screenshot, http://www.cse.unsw.edu.au/~dons/tmp/screen-dons.png
18:39:54 <desp> dons: that's a huge font
18:40:00 <dmead> dons: will you guys be implementing a --replace option?
18:40:00 <SamB_XP_> desp: isn't that how you pronounce it?
18:40:11 <ariks> desp: bleh, at least i got it right once
18:40:20 <desp> SamB_XP_: actually, I pronounce Pascal "Paskahl"
18:40:31 <dons> dmead: hmm?
18:40:33 <desp> but I've been told I sound like a Bond villain
18:40:36 <dons> what does --replace do?
18:40:43 <dmead> if you have an American accent ascal and askell are pronounced pretty much the same
18:40:46 <dmwit> kills the current wm
18:40:56 <dons> desp, yeah, 16 pt. i find that after 14 hours of hacking 16pt is easier to grok
18:41:02 <dmead> dons: it kills the current wm, so the one you are turning on can take its place
18:41:15 <dmwit> dons: What music player?
18:41:17 <dons> well, it can certainly replace itself already.
18:41:18 <SamB_XP_> dmead: I was under the impression that that was a BAD IDEA
18:41:20 <dons> that's hmp3,
18:41:22 <dons> ?where hmp3
18:41:23 <lambdabot> http://www.cse.unsw.edu.au/~dons/hmp3.html
18:41:26 <sjanssen> dmead: umm, is that even possible?
18:41:27 <dmead> no, it's part of the standard
18:41:30 <dmead> yes
18:41:34 <dmead> it's  a standard
18:41:39 <SamB_XP_> dmead: don't you have to take over the process?
18:41:44 <dmead> kwin and gnome-dectorator implements it
18:41:57 <dmead> kwine --help
18:42:07 <dmead> Options:
18:42:08 <dmead>   --lock                    Disable configuration options
18:42:08 <dmead>   --replace                 Replace already-running ICCCM2.0-compliant window manager
18:42:08 <desp> dons: I need a black background in order to avoid killing my eyes, but most fonts look way too thin on a black background.  so I made my own: http://desp.night.pl/verniks/verniks.png
18:42:21 <dmead> it's important if you want people to download and try xmonad
18:42:32 <dmead> then you don't have to kill your X session
18:42:40 <dmead> err
18:42:42 <dmead> kwin --help
18:42:45 <dmead> not kwine
18:42:46 <dons> that's an interesting idea.
18:42:57 <dons> if we could do it in less than 3 lines :-)
18:43:04 <SamB_XP_> won't it mess up their windows though?
18:43:08 <dmead> nobody else here uses kde or gnome?
18:43:17 <Nafai> I use Gnome
18:43:23 <dmwit> I use gnome.
18:43:26 <dmead> SamB: nope
18:43:32 <SamB_XP_> under xmonad? not much chance o' that...
18:43:38 <dmwit> Why not?
18:43:41 <sjanssen> dmead: I highly doubt that kde/gnome users will be that interested in xmonad ...
18:43:44 <dons> what's gnome?
18:43:46 <dmwit> Gnome is more than just a window manager, you know.
18:43:58 <dmead> sjanssen: i'm a kde fan and i'm interested...
18:44:00 <SamB_XP_> dmwit: where would it put the bars?
18:44:03 <dons> is kde like kfc?
18:44:07 <Nafai> metacity is the window manager
18:44:08 <dmead> lol
18:44:14 <dmead> yea
18:44:15 <dmead> someone
18:44:15 <SamB_XP_> it isn't really gnome without the bars
18:44:15 <procyon112> dmead: I have a very American accent, and I pronounce them with Pascal stressed on the second syllable, and Haskell stressed on the second, so they are very different.  Of course, people just assume I'm mispronouncing Pascal ;)
18:44:25 <dmwit> SamB_XP_: It's more than a launcher, too.  There's a whole suite of programs that are together called gnome.
18:44:42 <dmwit> I use eog, gnome-open, gnome-volume-control, gnome-screensaver, and quite a few others just fine under xmonad.
18:44:55 <dmead> procyon112: in Philadelphia, we mispronounce everything
18:44:57 <SamB_XP_> dmwit: is x-chat gnome one of them?
18:45:05 <dmead> hm?
18:45:14 <dmead> x-chat is it's own project
18:45:24 <dons> sjanssen: have we see the xmonad.org guy?
18:45:34 <dmead> sjanssen and dons
18:45:41 <SamB_XP_> there is some bastardized version of x-chat that complies with the GNOME HIG or something
18:45:47 <sjanssen> @seen fantasma
18:45:48 <lambdabot> I saw fantasma leaving #haskell 2d 22h 56m 19s ago, and .
18:45:56 <Nafai> SamB_XP_: Yeah, it's a separate project
18:45:57 <dmead> i'd think that you'd want to measure the langauge's effectiveness in doing the same job as say C++ or something
18:46:07 <sjanssen> dons: nope
18:46:11 <dmead> so uhh, yea
18:46:13 <dmead> --replace
18:46:13 <dons> grumble.
18:46:15 <dmead> chop chop!
18:46:23 <sjanssen> dons: I haven't personally seen him since he set it up
18:46:36 <sjanssen> lambdabot says he's been here
18:46:50 * SamB_XP_ still rather suspects that xmonad would rearrange all of the windows if you tried that
18:46:57 <dmead> it shouldn't
18:47:05 <dmwit> dmead: Wait, really?
18:47:06 <dmead> ....should it?
18:47:16 <dmwit> I would think it most definitely would -- isn't that what window managers are for?
18:47:26 <SamB_XP_> it is one of those non-overlapping wms!
18:47:32 <dmead> is it?
18:47:33 <dmead> oh
18:47:36 <dmead> i guess so then
18:47:42 <SamB_XP_> heh
18:47:48 <SamB_XP_> you haven't tried it have you?
18:47:48 <dmead> shurg
18:47:51 <dmead> nope
18:48:03 <SamB_XP_> I didn't kill X *or* leave the comfort of WindowMaker in order to try it ;-)
18:48:10 <dmead> k
18:48:15 <SamB_XP_> I just ran it in Xephyr
18:48:17 <dmead> darcs repo?
18:48:21 <sjanssen> @where xmonad
18:48:22 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
18:48:42 <sjanssen> dmead: you can also use startx -- :2 to fork another X display
18:48:54 <dmead> ah i'll just kill kwin
18:49:18 <dmead> whats the make command?
18:49:29 <dmead> runhaskell setup.lhs?
18:49:32 <sjanssen> standard cabal.  read the README
18:50:21 <dmead> you know, haskell support in portage would be peachy
18:50:38 <sjanssen> Gentoo portage?
18:50:42 <dmead> yea
18:50:48 <sjanssen> there's an xmonad-darcs ebuild in the overlay
18:50:54 <dmead> ah
18:50:56 <dmead> excellent
18:51:59 <dmead> ?hoogle gentoo
18:51:59 <lambdabot> No matches found
18:52:06 <dmead> ?hoogle gentoo-overlay
18:52:07 <lambdabot> Hoogle Error: Parse Error: Unexpected character '-overlay'
18:52:10 <dmead> :o
18:52:19 <dmead> @google haskell gentoo overlaay
18:52:20 <lambdabot> No Result Found.
18:52:24 <dmead> @google haskell gentoo overlay
18:52:25 <cjay> hoogle is for libs only
18:52:26 <lambdabot> http://www.gentoo.org/proj/en/prog_lang/haskell/index.xml
18:52:26 <lambdabot> Title: Gentoo Linux Projects -- Gentoo Resources for Haskell
18:52:52 <dmead> ah
18:52:53 <dmead> yeaa
18:53:02 <dmead> wheres the freaking overlay address =/
18:53:29 <sjanssen> use layman
18:55:14 <dmead> oh
18:55:14 <dmead> neat
18:55:15 <dmead> :)
18:57:27 <dmead> uhh
18:58:27 <dcoutts> @tell ndm I assume you're done with filepath fixes now then? I'll upload to hackage
18:58:28 <lambdabot> Consider it noted.
19:03:32 * dcoutts gets the feeling that Bulat considers last week as 'ancient' history
19:03:53 <dcoutts> "one shouldn't suppose that ghc 6.6.* will forever bundle only the same versions of packages that was shipped at ancient 6.6.0 times"
19:03:58 <ariks> my pinky finger is crying.. and i keep hitting i and staring dumbly at the screen as i's appear..
19:06:46 <ariks> i use my shell in vi mode. i have vi bindings for my web browser. i edit text boxes by spawning a vim session. i don't think i have the will to learn emacs for convenient haskell and erlang modes.
19:07:04 <dmead> ariks: you could just use the vi mode bindings...
19:07:18 <dons> more articles, http://programming.reddit.com/info/1h7pb/comments
19:07:20 <lambdabot> Title: HTML::Chunks for Haskell -- with statically checked templates (reddit.com)
19:07:23 <dons> reclaim reddit !
19:07:32 <thedward> both of the vi binding modes I tried for emacs were just enough off to cause much pain
19:07:35 <ivanm> lol, why, who stole reddit?
19:07:39 <dmead> reddit is 3rd rte :P
19:07:43 <dmead> *rate
19:07:48 <dmead> and my a key is 4th rate
19:08:07 <dmwit> Wow, what do you have to do to be second-rate these days?
19:08:08 <dcoutts> ariks: or help us improve yi's vim mode! :-)
19:08:58 <dmead> ariks: are you big on the whole keyboard-only text editing?
19:09:09 <dcoutts> dmead: that's not really the point, of course you shouldn't read reddit for the content but you can use it to market Haskell stuff to the lisp, ruby and python folk.
19:09:31 <Tene> dmead: how can you use a mouse for text editing?
19:09:41 <dmead> drag and drop =/
19:09:46 <Pseudonym> So reddit is an evangelism tool.
19:09:49 <Pseudonym> No wonder I don't go there.
19:10:01 <ivanm> Pseudonym: because you're already converted?
19:10:08 <Tene> dmead: so... you have a screen with letters and you drag them over?  Sounds horribly inefficient.
19:10:10 <ariks> dcoutts: http://www.cse.unsw.edu.au/~dons/yi.html ? intriguing
19:10:11 <lambdabot> Title: yi text editor
19:10:15 <Pseudonym> @google why I hate advocacy
19:10:17 <lambdabot> http://www.perl.com/pub/2000/12/advocacy.html
19:10:17 <lambdabot> Title: perl.com: Why I Hate Advocacy
19:10:19 <ariks> dmead: yep
19:10:49 <dons> Pseudonym: its a news site.
19:10:51 <dcoutts> ariks: yi should start to become a great haskell editor since it can use the GHC API directly (since it's written in Haskell), where as the emacs mode has to talk to a ghci process over a pipe.
19:11:06 <dmead> kewl
19:11:08 <dmead> ah
19:11:31 <dmead> ariks: you could get the vi-mode setup but you'd have to learn just enough lisp to edit its configuration
19:11:39 <dons> it can be LtU if we want it to be, which is the interesting aspect.
19:11:41 <dmead> which is hardly any at all
19:11:50 <dcoutts> ariks: but we need help on yi's vim mode/bindings. yi's current maintainer is an emacs user so the vim bindings have not been improved as much recently. We need more patches from the vim users.
19:12:14 <sjanssen> dcoutts: do you use yi now?
19:12:19 <dcoutts> ariks: I only know about 5 vim commands, so I'm not of much help :-)
19:12:24 <dcoutts> sjanssen: I'm trying to
19:13:05 <dcoutts> sjanssen: at least its vty flavour since that's the most mature atm
19:13:14 <dmead> what is dev-haskell/x11
19:13:22 <dmead> haskell -> X11 bindings?
19:13:25 <dcoutts> I got the gtk version working, but that needs more work to be usable really
19:13:29 <dcoutts> dmead: right.
19:13:32 <sjanssen> dmead: also in the overlay
19:13:38 <sjanssen> oh, 'what', not 'where' :)
19:13:46 <dmead> i suggest naming it x11-bindings then :P
19:13:52 <dcoutts> heh, no.
19:13:56 <dmead> ;p
19:14:16 <dcoutts> the package name is X11 and for the gentoo ebuild we just lowercase that
19:14:44 <sjanssen> bindings that have the same names as the thing they bind to are a bit of a bad idea, I think
19:15:07 <sjanssen> A: do you have X11?
19:15:17 <dmead> =/
19:15:20 <dmead> Compiling Main             ( /var/tmp/portage/dev-haskell/x11-1.2/work/ghc-6.6/libraries/X11/Setup.hs, /var/tmp/portage/dev-haskell/x11-1.2/work/ghc-6.6/libraries/X11/Setup.o )
19:15:20 <dmead> Linking ...
19:15:20 <dmead> setup: X11.cabal:42: Unknown field 'install-includes'
19:15:23 <sjanssen> B: of course I do!  I'm typing this in gaim right now!
19:15:34 <sjanssen> dmead: upgrade cabal
19:15:37 <dmead> k
19:15:54 <dcoutts> sjanssen: that's why we have package categories, dev-haskell/*
19:16:21 <dmead> i want to work on something with like, market value
19:16:33 <sjanssen> dcoutts: do you know offhand which cabal version added install-includes?
19:16:34 <dmead> theorem proving seems to be a slow industry these days
19:16:56 <dcoutts> sjanssen: I've never heard of install-includes :-)
19:17:22 <sjanssen> dcoutts: I'm referring to the situation in general: it's still confusing for users that aren't using their package manager
19:18:40 <dcoutts> sjanssen: mm, I'm not so sure, when it's a ghc package you're not going to get confused with system packages, it's only when it's in a distro that there's any chance of confusion and distros have ways of handling that.
19:18:59 <dcoutts> I don't think we need redundant prefixes or suffixes on all our ghc packages
19:19:08 <dcoutts> it's a local namespace
19:20:57 <dmead> i like how cabal is way faster than autotools
19:24:55 <dons> and so it goes, http://programming.reddit.com/info/1h7ut/comments
19:24:57 <lambdabot> Title: FGL -- A Functional Graph Library for Haskell (reddit.com)
19:25:50 <sjanssen> dcoutts: the confusion is fairly common, from what I've seen
19:26:44 <dcoutts> sjanssen: like what? any example?
19:27:26 <sjanssen> dcoutts: X11 is one, zlib too
19:27:42 <dcoutts> sjanssen: but I mean concretely, when do people get confused
19:27:56 <dcoutts> do they think cabal-install zlib is going to install a C lib ?
19:28:06 <sjanssen> dcoutts: the dialog roughly follows:
19:28:12 <sjanssen> User: umm, xmonad won't build
19:28:26 <sjanssen> Me: Do you have the X11 package?
19:28:35 <sjanssen> User: of course I do, I'm in X right now!
19:29:13 <sjanssen> I proceed to explain that X11 is a *Haskell* package that binds to the C library they have already installed
19:29:18 <dons> mwhahaha, http://programming.reddit.com/info/1h7wb/comments
19:29:20 <lambdabot> Title: Monads are too hard! (reddit.com)
19:29:21 <dcoutts> perhaps cabal just needs to give better error messages
19:29:29 <dmead> yea....
19:29:37 <dcoutts> "you are missing the following Haskell packages: X11, ..."
19:29:39 <dmead> running xmonad when kwin is running freezes X
19:29:46 <dmead> =/
19:30:02 <dons> wow.
19:30:04 <sjanssen> it freezes your X server?
19:30:16 <dons> ah. you mean, trying to run a new wm over the top of kwin? (is it a wm?)
19:30:40 <dmead> Xlib:  extension "XINERAMA" missing on display ":0.0".
19:30:40 <dmead> xmonad: fatal error: request Xlib:  extension "XINERAMA" missing on display ":0.0".
19:30:40 <dmead> xmonad: fatal error: request code=2, error code=10
19:30:40 <dmead> Error: BadAccess (attempt to access private resource denied)
19:30:40 <dmead> code=2, error code=10
19:30:41 <dmead> Error: BadAccess (attempt to access private resource denied)
19:30:43 <dmead> woops
19:30:59 <dmead> kwin is the KDE window manager
19:31:14 <dmead> yea
19:31:27 <dmead> --help needs to print a menu
19:31:34 <dmead> but it just does a regular startup
19:31:40 <dmead> so i had to be quick with the ctrl-c
19:34:15 <dons> http://programming.reddit.com/info/1h7xv/comments
19:34:16 <lambdabot> Title: Interacting with a Debian system from Haskell (reddit.com)
19:34:50 <sorear> hi.
19:34:51 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
19:34:54 <sorear> @messages
19:34:54 <lambdabot> joelr1 said 14h 8m 41s ago: stefan, do you have any examples of arithmetic expression parsing with parsec but without buildExpressionParser?
19:34:56 <raxas> dmead: you can "replace" a running window manager in kde but it's tricky. beryl does it this way.
19:35:05 <dmead> yes
19:35:29 <dmead> i've been bugging dons and sjanssen to implement it so the rest of us can play with xmonad
19:35:53 <sjanssen> dmead: patches accepted ;)
19:36:04 <dmead> hmm
19:36:08 <dmead> perhaps after the semester
19:36:14 <dmead> i'll take a stab at it
19:36:56 <sjanssen> I'll take a patch to do it as long as it isn't unreasonably complicated/long
19:37:50 <raxas> dmead: better to start a new X session on next vt, kde can do it from start menu
19:38:48 <raxas> it's good method enough for running broken X or GL apps and not crashing kde session
19:38:49 <sjanssen> dmead: will 'killall kwin' work?
19:39:03 <dmead> raxas: i know, but it's only on when you have kdm running
19:39:10 <raxas> yes
19:39:11 <dmead> sure, if the user is running kwin
19:39:32 <dmead> i would want to look at how kwin does it
19:39:40 <dmead> before implementing it in haskell
19:39:47 <dmead> http://tronche.com/gui/x/icccm/
19:39:48 <lambdabot> Title: Inter-Client Communication Conventions Manual
19:39:51 <dmead> theres the ICCM manual
19:39:55 <sjanssen> I'm surprised that doesn't cause KDE to simply exit, and closing the window manager after it
19:39:59 <dmead> i'm looking if it has anything specific on replacement
19:40:16 <thetallguy> kdeinit is the root process
19:40:25 <dmead> i don't think it's really a matter of telling kwin to shut down
19:40:27 <thetallguy> it starts everything
19:40:30 <sjanssen> s/window manager/x server
19:40:36 <thetallguy> Are you guys running some form of Debian?
19:40:37 <dmead> telling the running X server that xmonad is the wm now is probably the key
19:40:47 <dmead> gentoo here
19:41:02 <dmead> by server i mean client
19:41:06 <dmead> and by client i mean server =/
19:41:07 <sjanssen> dmead: xmonad does that automatically on startup
19:41:13 <dmead> ah
19:41:18 <dmead> maybe it is just killing kwin then
19:41:31 <thetallguy> I'll talk to stepcut tomorrow and see if we can't figure out the correct way to replace kiwn
19:41:32 <thetallguy> kwin
19:41:48 <dmead> if it's already registerd with the X session
19:41:59 <dmead> err
19:42:00 <dmead> wait
19:42:05 <sjanssen> --replace might just ask X for the pid of the window managing client, and then kill it
19:42:11 <dmead> true
19:42:25 <dmead> it might also tell X to stop talking to the running wm in a safe manner
19:42:34 <dmead> rather than dealing with a broken memory pipe
19:43:58 <timthelion> is there a system of on the fly documentation for haskell like there is for elisp and C#?
19:44:08 <dmead> how do you mean?
19:44:12 <dmead> like javadoc?
19:44:23 <SamB_XP_> what is this "fly" you speak of?
19:44:27 <dmead> Haddock you mean?
19:44:27 <timthelion> well, no because don't you have to compile a javadoc from the source?
19:44:35 <dmead> i don't remember
19:44:46 <SamB_XP_> yes javadoc is like haddock...
19:44:47 <timthelion> I mean when I finnish writing a function, I want the documentation to be there.
19:44:54 <dmead> ummmm
19:44:56 <timthelion> so I can look it up with a couple of keystrokes
19:45:00 <dmead> thats weird..
19:45:07 <dmead> you want it to read yer mind?
19:45:10 <dmead> :P
19:45:23 <timthelion> no, I want to put a comment at the top of the function
19:45:24 <timthelion> or something
19:45:27 <thetallguy> lol
19:45:31 <timthelion> and then as soon as I press enter
19:45:40 <dmead> have it autocomplete?
19:45:42 <timthelion> I can type the function name into a search
19:45:44 <SamB_XP_> I think he wants his IDE to incrementally haddock his code ;-)
19:45:44 <timthelion> and get that comment
19:45:45 <thetallguy> Do you use emacs?
19:45:53 <timthelion> yes
19:45:59 <dmead> tim: maybe use the FP plugin for emacs
19:46:01 <dmead> :
19:46:02 <dmead> ?
19:46:17 <SamB_XP_> (note that haddock does not, afaik, support incremental operation of any kind)
19:47:23 <timthelion> dmead any chance you would have a link, google:fp haskell gets me nothing
19:47:38 <dmead> woops
19:47:41 <dmead> i  meant eclipse
19:47:42 <dmead> sorry
19:47:48 <dmead> not emacs
19:47:49 <dmead> :P
19:48:09 <timthelion> I am gona use emacs to edit my code, I'm pretty certain of it.
19:48:27 <dmead> http://eclipsefp.sourceforge.net/
19:48:29 <lambdabot> Title: EclipseFP - Functional programming support for Eclipse
19:48:29 <timthelion> I don't even know that eclips is keyboard accessible
19:48:43 <dmead> it is
19:48:53 <dmead> it has it's own system of binds that resembles emacs or vi
19:50:28 <timthelion> wow 132 megs, OUCH
19:50:45 <dmead> just a suggestion
19:50:53 <dmead> emacs has no automatic stuff like that
19:50:57 <dmead> as far as i know
19:51:11 <timthelion> it has automagic stuff for almost everything
19:51:42 <dmead> sjanssen: i'm looking on the kde websvn for the --replace stuff
19:53:48 <timthelion> what I really want is like in C#, you type ;;bunch of comments formated with things like <parameters>n is the number of cats</parameters> \n functionname()
19:54:00 <timthelion> then when you type your close }
19:54:24 <timthelion> you can then see functionname in the autocompleat list, and the tooltips in that list show that comment
19:54:41 <timthelion> that you put just before the function
19:54:49 <timthelion> sorry, not ;; but //
19:55:00 <timthelion> gotten used to elisp ;)
19:55:06 <dmead> :)
19:55:09 <dmead> hmm
19:55:21 <dmead> i'd like code completion/menus in emacs too
19:55:29 <raxas> dmead: you can try to set KDEWM=xmonad before kde, when not set ksmserver starts kwin
19:55:47 <ariks> anyone know offhand what debian package, if any would pull in "-package plugins"..
19:55:50 <dmead> sounds dangerou :)
19:56:08 <dmead> +s
19:56:16 <ariks> i'm trying to build Yi
19:57:04 <sorear> timthelion: ISTR there being a SoC proposal to store haddock comments in bytecode objects so that they are available with :info and in tools like shim
19:57:59 <sjanssen> sorear: do you mean the haddock-ghc stuff from last year?
20:00:00 <ariks> duh... nevermind.. it came with a helpful readme.
20:02:05 <thedward> hmm. xmonad isn't building, it can't find waBorderWidth
20:02:13 <sorear> sjanssen: no.
20:02:16 <TSC> Need new X11-extras?
20:02:29 <sorear> sjanssen: though certainly having haddocks in the parse tree is a major common prefix!
20:02:32 <sjanssen> thedward: update X11-extras
20:02:51 <sjanssen> sorear: if there was such a proposal, it didn't make it this year
20:03:16 <thedward> hmm. darcs says my copy is up to date.
20:03:20 <allbery_b> hrm.  gtk2hs question:  how do I parse a color string into a Color?
20:03:47 <dcoutts> allbery_b: no idea, what does a colour string look like?
20:03:51 <sorear> if read doesn't dtrt I'd call it a bug
20:04:01 <dcoutts> sorear: heh, thanks.
20:04:03 <allbery_b> things like #ff0000
20:04:13 <dcoutts> allbery_b: ah ok, so that should be easy then
20:04:36 <allbery_b> well, I was actually angling for X11-style color specs, which could be #ff0000 #fff000000 #ffff00000000 red etc.
20:04:44 <sorear> Unlike some languages, we have a standard unpickling mechanism :)
20:04:48 <dcoutts> sorear: read/show is for haskelly source style things really
20:04:49 <thedward> sjanssen: nevermind. I had the current x1ll-extras built, but not installed
20:04:52 <vagif> what is preferred way to work with databases in haskell ? haskelldb, hdbc ? anything else ?
20:04:56 <sorear> allbery_b: there are many other cases
20:05:11 <sorear> rgb:1/1/1
20:05:28 <allbery_b> alternately, a better way to store  acolor in GConf without decomposing it into its cmponents and using separate keys for each, since Color isn't an instance of GConfValueClass
20:05:46 <dcoutts> allbery_b: if you do us a parser we can include that in gtk2hs, or if there's some existing C function that does it then that's fine to bind too.
20:05:47 <sorear> allbery_b: parse error
20:06:04 <allbery_b> sorear: hence "etc." --- I've been doing X11 for a while, I'm quite aware there are lots of ways --- which is why I'd rather not write my own parser :)
20:06:11 <jargonjustin> I'm trying to write a program that performs some computation.  However, I'd like to be able to enable a debugging mode (with various levels) using an argument from the command line, causing the program to print debugging messages to stdout.  What's the best way to do this?
20:06:57 <dcoutts> allbery_b: http://developer.gnome.org/doc/API/2.0/gdk/gdk-Colormaps-and-Colors.html#gdk-color-parse
20:06:59 <lambdabot> Title: Colormaps and Colors, http://tinyurl.com/283tse
20:07:00 <ivanm> @hoogle debug
20:07:00 <lambdabot> Network.Socket.Debug :: SocketOption
20:07:01 <lambdabot> Text.Html.debugHtml :: HTML a => a -> Html
20:07:01 <lambdabot> Test.QuickCheck.Batch.debug_tests :: TestOptions -> Bool
20:07:01 <dmead> jargonjustin: Observe
20:07:04 <sorear> jargonjustin: what I did for my dependant typechecker was to add an IORef and a couple of unsafePerformIO tracing calls
20:07:24 <allbery_b> yeh, saw that in a PyGtk thing and was just tracking it down
20:07:25 <ivanm> jargonjustin: import Debug.Trace ?
20:07:25 <sorear> jargonjustin: of course you get no guarantees about the order of messages that way
20:07:26 <dcoutts> allbery_b: seems there is something for this purpose, we've not bound it but we'll accept patches! :-) It should be an easy one.
20:07:48 <allbery_b> but really I just want to have a nice easy way to stuff it into GConf
20:07:52 <sorear> ivanm: Debug.Trace only prints strings - it doesn't consult a verbosity flag
20:08:04 <ivanm> *nod*
20:08:20 <allbery_b> and patching has the issue that I need to override my machine's installed autotools to mess with the darcs source
20:08:29 <sorear> I suppose I could put my dependent checker up if anyone wants working code?
20:08:31 <dcoutts> allbery_b: I think going via a string is the right way to do it for gconf, rather than using some binary rep or something
20:08:34 <allbery_b> which will make quite a lot of stuff unhappy since it's facilitiezed (== managed)
20:08:35 <sorear> @uptime
20:08:36 <lambdabot> uptime: 7d 11h 57m 42s, longest uptime: 7d 11h 57m 42s
20:08:40 <sorear> nice.
20:08:42 <allbery_b> er, facilitized
20:08:53 * allbery_b is far too tired to be hacking tonight...
20:09:00 <ivanm> sorear: or it could be because LB has lost its memory of last time it was up?
20:09:01 <dcoutts> allbery_b: and gdk_color_to_string for the other way around
20:09:17 <sorear> ivanm: I remember.
20:09:21 <allbery_b> actually that side is handled, I can ask the ColorButton fr its string representation.
20:09:40 <sorear> ivanm: it's been up for months in the past, but a week is the first in 2007
20:09:43 <allbery_b> which is why I was surprised that I couldn't find anything going the other way
20:09:45 <dcoutts> allbery_b: ah ok, but you can't set it via a string rep ?
20:10:01 <sorear> mux++ optionMaybe
20:10:09 <ivanm> sorear: *nod* OK... so why only a week so far this year? dons updating her a lot recently?
20:10:37 <sorear> ivanm: OOM killer.  the bot has a bad memory leak, somewhere
20:10:49 <ivanm> OOM = ?
20:10:54 <sorear> out of memory
20:10:58 <ivanm> ahhh
20:11:01 <dino-> @pl (return $ flip Data.Map.lookup)
20:11:01 <lambdabot> return (flip Data . Map . lookup)
20:11:14 <dino-> :(
20:11:18 <ivanm> lol
20:11:19 <dcoutts> allbery_b: hmm, I don't see this colour string property for the ColourButton, there's a colour property but that's a GtkColour structure, not a string.
20:11:25 <allbery_b> hm, apparently I am wrong.  there was an API function I ran across that returned the color as a string but I don't see it in the docs
20:11:31 <ivanm> @pl (return $flip M.lookup)
20:11:32 <lambdabot> return (flip M . lookup)
20:11:38 <dino-> Dear lambdabot, those weren't (.) functions
20:11:38 <ivanm> hmmm.....
20:12:00 <allbery_b> oh well, guess that answers that question.  guess I'll just deal.
20:12:06 <sorear> Data.Map.lookup is not haskell98
20:12:07 <ivanm> @pl (return . flip M.lookup)
20:12:08 <lambdabot> return . flip M . lookup
20:12:22 <sorear> (lambdabot isn't doing the h98 right thing either)
20:12:27 <ivanm> and LB only does h98 pl'ing?
20:12:46 <sorear> In Haskell98  M.lookup is valid.
20:12:59 <sorear> Data.Map.lookup lexes as Data.Map . lookup
20:13:16 <sorear> since '.' is illegal in module names
20:13:28 <ivanm> *nod*
20:15:46 <allbery_b> aha
20:16:17 <allbery_b> it's not the color button, it's the ul;timate target.  CellRendererText can return its foreground and background colors as Strings
20:16:51 <allbery_b> er, can *accept*, not return.  read it backwards.  makes even more sense
20:17:06 <allbery_b> whatever, I'll figure something out
20:17:21 <allbery_b> dcoutts++
20:17:42 <dcoutts> :-)
20:17:50 <sjanssen> ivanm: @pl doesn't use a real Haskell parser
20:17:52 <sorear> @flush
20:18:05 <vincenz> dcoutts: hi ;)
20:18:11 <dcoutts> @arr!
20:18:12 <vincenz> dcoutts: > 80 op-sem rules and counting
20:18:12 <lambdabot> I want me grog!
20:18:14 <dcoutts> hia vincenz
20:18:30 * vincenz has decided to cut some and put them in the extended version, just to keep to page limit
20:18:44 <vincenz> (mostly lowlevel basic stuff, like stack/heap management, and error propagation)
20:19:14 <vincenz> I'm thinking it'd be really cool to map this to a haskell implementation once done :)
20:19:55 <sorear> well it'll probably be a lot easier if you can cut corners
20:20:12 <sorear> call-by-name is a perfectly acceptable op-sem for haskell's den-sem
20:20:21 <vincenz> sorear: erm.. yes
20:20:30 <sorear> but people would laught at you if you use it in a real impl
20:20:30 <vincenz> I'm not modelling haskell, however
20:23:15 <dmead> sjanssen: i found some bits in kwin that does --replace
20:23:50 <allbery_b> oh look, GConfValueDyn supports a list of a primitive type.  problem solved.
20:24:09 <dmead> http://websvn.kde.org/tags/KDE/3.5.6/kdebase/kwin/main.cpp?revision=623901&view=markup
20:24:13 <lambdabot> Title: View of /tags/KDE/3.5.6/kdebase/kwin/main.cpp, http://tinyurl.com/2guah9
20:24:35 <dmead> you have to pump a lostOwnerShip() signal to the current owner (a wm i presume)
20:24:45 <dons> HWN! http://programming.reddit.com/info/1h8cm/details
20:24:47 <lambdabot> Title: Haskell Weekly News: nested parallel arrays, html, binary, SWF, guis and more (r ...
20:26:51 <sjanssen> dmead: that doesn't sound like an X11 call
20:27:34 <allbery_b> that sounds like a Qt or KDE signal
20:27:49 <allbery_b> since he was talking about the guts of kwin, that makes sense
20:29:55 <sorear> dons++ HWN
20:30:11 <dmead> sjanssen, : yea, its defintly kdelibs or something
20:30:26 <dmead> i'm gonna look a bit deeper
20:39:26 <dmead> allbery_b i'm trying to find the proper calls to do a WM replace
20:39:31 <dmead> for xmonad
20:40:34 <dons> dmead: do you have the src of a window manager that does this?
20:40:54 <dmead> yep, i'm looking through kwin
20:40:55 <allbery_b> hm.  IIRC (been a long time) you kill the old one, then enumerate the top level windows that don't have overrideRedirect set and XReparentWindow() them
20:41:08 <dmead> i found where it does the signalling but it's via KDElibs
20:41:15 <sorear> I seem to recall there is a much nicer way
20:41:20 <dmead> hmm
20:41:29 <sorear> it is in the ICCCM, I know that much for sure
20:41:37 <dmead> yea i was reading that too
20:41:43 <sorear> (which is a 0-charge pdf btw)
20:41:43 <dmead> and the xorg additions
20:41:47 <dmead> yes
20:41:48 <dons> sorear: looks like he's not a ugrad, go for it. (re. mailing list guy)
20:42:01 <dons> sorear: "   No. Not at all (I'm a grad student :-)). I generally work
20:42:02 <dons>    with matrices and vectors and the like in matlab, and find
20:42:02 <dons>    this function very useful in my work. But, for some reason,
20:42:02 <dons>    I wanted to try a FP language and guage it's usability for
20:42:02 <dons>    me. I just chose this problem as a rough test to compare
20:42:04 <dons>    with matlab (the implementation is matlab is a bit messy)"
20:42:23 <sorear> dons: ok.
20:42:23 <allbery_b> someone should point him to oleg's message from earlier today
20:42:52 <dmead> dons: i've been poking around here
20:42:54 <dmead> http://websvn.kde.org/tags/KDE/3.5.6/kdebase/kwin/
20:42:57 <lambdabot> Title: Index of /tags/KDE/3.5.6/kdebase/kwin
20:43:20 <dmead> but allbery_b seems to have a better understanding of the lower level calls
20:43:23 <timthelion> hey, I really can't figure out what is wrong with my code http://rafb.net/p/5x1B5X36.html
20:43:25 <lambdabot> Title: Nopaste - I really don&#039;t see why this does not work.
20:43:33 <dmead> tim: use hpaste
20:43:36 <dmead> ?hpaste
20:43:36 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:44:07 <timthelion> do you want me to move that to hpaste, or just in the future?
20:44:13 <dmead> in the future
20:44:14 <dmead> and
20:44:18 <dmead> [x:xs]
20:44:20 <dmead> is a lists of lists
20:44:26 <dmead> (x:xs) is a list
20:44:50 <timthelion> so I want to take the argument (x:xs) not [x:xs]
20:44:54 <dmead> be sure to not forget the parens because : has a very high precedence
20:45:00 <dmead> yes
20:45:44 <dmead> and your else branch is wrong it hink
20:45:45 <Cale> [x:xs] is specifically the one element list consisting of a nonempty list starting with x and with tail xs
20:46:31 * allbery_b has, nd has read if not completely digested, the old O'Reilly X11 collection
20:46:41 <dmead> ahh
20:46:43 <dmead> cool
20:47:24 <allbery_b> mostly because, Back In The Day, I used DESQview/X a lot and it was easiest to write programs for it directly in XLib
20:47:39 <dmead> sounds hardcore
20:47:50 <timthelion> Cale I thought that's what I wanted.
20:47:57 <dino-> DESQview!
20:48:10 <dino-> There's something I haven't seen in a damn long time.
20:48:18 <allbery_b> it didn't have very good support for Xt, much less higher level stuff like Motif and OpenLook/XView which were the state of the art at the time
20:48:19 <dmead> timthelion: you want a single element
20:48:28 <dmead> not a list consisting of a single element
20:48:31 <dmead> they are different
20:48:33 <timthelion> I want xs to be the tail, and x to be the head
20:48:37 <dmead> right
20:48:39 <dmead> (x:xs)
20:48:44 <timthelion> ok.
20:48:54 <dmead> [(x:xs)]
20:49:02 <Cale> timthelion: except you probably don't want it to be a 1 element list consisting of that
20:49:02 <dmead> is a list with one element
20:49:04 <dmead> which is a list
20:49:24 <dmead> [(x:xs), (y:ys)]
20:49:28 <dmead> is a two element list
20:49:31 <dmead> both of which are lists
20:49:38 <timthelion> ok
20:49:42 <Cale> and that's the same as [x:xs, y:ys]
20:49:45 <dino-> Wow, I had never heard of that /X edition: "...which was an X Window System server running under MS-DOS"
20:49:46 <dmead> aye
20:50:13 <timthelion> now it says expected type a infered type [a] instead of having the infered type be [[a]]
20:50:22 <dmead> paste your code again?
20:50:30 <dmead> the newer version
20:51:02 <hpaste>  tim.thelion pasted "bubblesort" at http://hpaste.org/1350
20:51:30 <dmead> ah
20:51:39 <dmead> do you have ghci set up yet?
20:51:42 <allbery_b> DV/X wasn't all that popular, except in some corporate contexts (I understand one of the big financial houses was more or less their entire income on it)
20:51:51 <timthelion> yes,
20:51:57 <dmead> calling a main is a really klunky way of doing things
20:51:58 <Cale> er, hmm
20:52:08 <dmead> just call your functions in ghci
20:52:27 <Cale> timthelion: both of the results of sort are immediately 2-element lists, but I don't think you intend them to be
20:52:37 <allbery_b> but I used it at home since I did unixy stuff at work and didn't have a powerful enough computer at home (old XT with an Intel Inboard/386 --- QEMM386 could deal, linux etc. couldn't)
20:53:36 <Cale> By the looks of what you've written you're probably aiming at having sort be the insert of an insertion sort, actually.
20:54:16 <Cale> Well, I'm not sure :)
20:54:18 <timthelion> I don't really know what I'm doing
20:54:35 <dmead> it's cool
20:54:38 <timthelion> I figured, pick up n and buble it down untill it found it's place
20:54:43 <hpaste>  Cale annotated "bubblesort" with "insert" at http://hpaste.org/1350#a1
20:55:12 <dino-> allbery_b: heh, the good old QEMM. Did you also go through the "Stacker" phase or some other disk-doubling technology?
20:55:25 <allbery_b> for a while
20:55:35 <dmead> dino-: i had drivespace in ms dos 6
20:55:37 <dmead> :)
20:55:39 <LoganCapaldo> @. pl djinn a -> b -> c -> (b -> a -> c)
20:55:40 <lambdabot> f = const (const (const . const))
20:55:46 <allbery_b> then I bought a fancy new disk controller and a huge 80MB drive :)
20:55:53 <dino-> HD space was ludicrously expensive. Had to compress.
20:55:54 <allbery_b> (funny to think that was, at the time, huge :)
20:56:19 <allbery_b> the disk drive explosion had just started, 80MB was shockingly affordable
20:56:24 <sorear> My father loves to tell me stories about the time he saved up for months to get a 5M drive :)
20:56:32 <dmead> =)
20:56:38 <dmead> i've heard that from uncles
20:56:39 <sorear> of course I still can't really believe it
20:56:53 <dino-> sorear: It's all true!
20:57:10 <dmead> they used to pay 500 bucks for a math coprocessor
20:57:27 <Cale> My first machine was a 386SX/25 with a 100MB hard drive :)
20:57:41 <Cale> We didn't use up all that space for quite some time.
20:57:41 <dmead> at what age?
20:57:46 <sorear> why does anyone still use bubblesort?
20:57:49 <Cale> 9
20:57:52 <dmead> hmm
20:57:53 <sorear> er, s/C-j/C-k
20:58:04 <dmead> i had a commodore passed down to me from some cousins
20:58:08 <dmead> C64 even
20:58:53 <allbery_b> my first machine was an Ohio Scientific SuperBoard II (C1P without the case etc.) --- I did the hardware mods for color and "high res" video (from 20x22 to 40x16)
20:58:57 <dmead> timthelion: maybe you want to start with more basic list operations
20:59:07 <dmead> that'd turn out to be more useful in the long run
20:59:10 <Cale> Well, a good deal before that, my dad had a Timex Sinclair at one point which was sort of a toy, but I never really used it.
20:59:12 <sorear> I've been programming on windows boxen (3.1 / 8MB era) since ~7, but it's embarassing to recall how little I accomplished until about three years ago
20:59:13 <allbery_b> hm, 22x24 actually.  been a long time
20:59:28 <dmead> kewl
20:59:35 <dmead> i didn't start programming till age 19
20:59:38 <dmead> and i'm 24 now
20:59:48 <sorear> which coincidentally was about the time I got a computer in my room, and gave up on windows :)
20:59:54 <dmead> :)
21:00:23 <Cale> Learning Haskell has actually caused me to be way more into teaching other people how to program than actually programming myself. :)
21:00:23 <dmead> i once picked up an ibm XT and a tandy computer at a garage sale
21:00:27 <dmead> the XT had tetris
21:00:30 <dmead> it was awesome.
21:00:33 <dmead> cost me 20 bucks
21:00:55 <dmead> the tandy like, turned on and showed a courser
21:01:05 <dmead> i assume that memory packs were missing
21:01:13 <dmead> xD
21:01:22 <Cale> A couple of years ago when I was at uni, a friend of mine rescued an Apple II from a university surplus sale
21:01:29 <timthelion> too bad ghci can't assign functions without restarting
21:01:40 <Cale> It can, actually.
21:01:48 <dmead> whatnow tim?
21:01:52 <LoganCapaldo> believe it or not, ghci's walking on air
21:01:55 <Cale> But it's awkward, since you have to do it all in one line.
21:01:58 <timthelion> I can't do x = 5
21:02:00 <timthelion> in ghci
21:02:01 <LoganCapaldo> it never thought it could be so free
21:02:02 <Cale> let x = 5
21:02:04 <dmead> let x = 5 in x
21:02:05 <LoganCapaldo> let x = 5
21:02:05 <timthelion> I have to put that in the file
21:02:24 <timthelion> oh, why do you need the let?
21:02:29 <dmead> tim i'll make you a pretty screenshot of my emacs session
21:02:29 <LoganCapaldo> its a hint
21:02:35 <Cale> because ghci is emulating the inside of a do-block.
21:02:36 <sorear> because ghci isn't a toplevel
21:02:36 <LoganCapaldo> or something
21:02:37 <dmead> so you'll understand what we mean
21:02:52 <dmead> Cale: http://www2.b3ta.com/heyhey16k/
21:02:52 <timthelion> ok
21:02:54 <lambdabot> Title: Hey Hey 16k by Anim by Rob Manuel - Song by MJ Hibbett [B3TA : WE LOVE THE WEB]
21:02:57 <dmead> give that a whirl
21:02:57 <LoganCapaldo> Why does it emulate the inside of a do block anyway?
21:02:58 <dmead> funny shit
21:03:03 <LoganCapaldo> seems odd
21:03:09 <Cale> Also, it makes it obvious that you can't split up the multiple clauses of a function definition across lines.
21:03:15 <sorear> timthelion: if ghci was like the top level of a file, 2 + 2 wouldn't work and people would complain about that :)
21:03:16 <Cale> For example:
21:03:21 <Cale> let myMap f [] = []
21:03:32 <Cale> let myMap f (x:xs) = f x : myMap f xs
21:03:44 <Cale> The second line actually shadows the first.
21:03:53 <Cale> So you'll get pattern match failure.
21:04:19 <Cale> If you wanted to write that, you'd have to compress it onto one line with ;
21:04:28 <LoganCapaldo> let myMap f [] = []; myMap f (x:xs) = f x : myMap f xs -- this is how we do it
21:04:58 <Cale> Really, it's more convenient to just keep an editor window open and when you edit the file, just do : in ghci and it'll reload.
21:05:15 <Cale> That is, just a colon by itself on a line.
21:05:45 <LoganCapaldo> its unfortunate that is more convenient. IIRC hugs is no better
21:05:47 <Cale> That also makes it harder to lose your definitions.
21:06:10 <LoganCapaldo> is there a interactive haskell that DWIM?
21:06:13 <timthelion> You see my vision was that with ghci I could do x = 5 :edit x and change the definition, then do :save, and write my program that way, testing as I whent
21:06:15 <Cale> I find that whenever I use the let form, I end up losing important stuff by printing something too long.
21:06:24 <Cale> What we really need is something which is like Dr. Scheme
21:06:52 <dmead> timthelion, look here
21:06:53 <dmead> http://taz.cs.wcupa.edu/~dmead/stuff/emacs.png
21:06:54 <Cale> That has a definitions and evaluation pane in the same window.
21:07:00 <LoganCapaldo> Or Smalltalk...
21:07:17 <Cale> Emacs can sort of simulate that :)
21:07:25 <Cale> Smalltalk is frightening :)
21:07:39 <LoganCapaldo> well I meant the IDE part mostly
21:07:43 <LoganCapaldo> mmm
21:07:56 <LoganCapaldo> Smalltalk makes shooting your foot off fun!
21:08:07 <dmead> wheee
21:08:13 <Cale> I spent a few days playing with Squeak, and while it was mostly pretty enjoyable, I couldn't help but feel like the whole thing was going to tear itself apart at any moment.
21:08:44 <Cale> That level of mutability is just not something I feel all that comfortable with :)
21:09:07 <LoganCapaldo> We are living in a mutable world.
21:09:13 <LoganCapaldo> And I am a mutable girl
21:09:16 <timthelion> dmead that looks exactly like http://www.timthelion.com/haskell.png
21:09:17 <Cale> Not that mutable :)
21:09:26 <jcreigh> LoganCapaldo: I don't feel very comfortable with the world, either. :)
21:09:26 <lambdabot> jcreigh: You have 1 new message. '/msg lambdabot @messages' to read it.
21:09:32 <Cale> Holy small fonts batman
21:09:58 <dmead> what in the christ is that
21:10:04 <dmead> :)
21:10:05 <timthelion> Cale I have severe astigmatism, but good eyesite besides that, so I actualy find them easier to read
21:10:18 <dmead> ah
21:10:42 <Cale> Usually if I was going to use a font that small I'd at least insist that it was antialiased :)
21:10:53 <dmead> indeed
21:11:10 <timthelion> Cale you can't do antialising at this size, because the letters fill in with grey
21:11:11 <LoganCapaldo> if its that tiny though
21:11:17 <LoganCapaldo> AA makes it look like mush
21:11:17 <jcreigh> grr. antialiased fonts (in my experience, at least) suck on low-resolution displays.
21:11:30 <jcreigh> where "low" is 800x600 or 1024x768
21:11:31 <Cale> Well, subpixel AA can help.
21:11:42 <Cale> By effectively tripling the resolution in one direction.
21:11:49 <dmead> weird.
21:11:55 <timthelion> I mean, I already have some problems with fill, look at the M in main on the ghci
21:12:15 <LoganCapaldo> indeed
21:12:18 <dcoutts> sjanssen: nice quote in HWN :-)
21:12:20 <LoganCapaldo> now you have a box
21:12:28 <LoganCapaldo> with AA you'd have an AAed box
21:12:30 <dcoutts> " <sjanssen> Threads are fine, its your language that sucks. "
21:12:32 <dcoutts> :-)
21:12:49 <dmead> was that in response to the firefox guy?
21:12:53 <Cale> Well, with subpixel AA, you might actually have something a little better than a box.
21:12:54 <jcreigh> well, maybe I just forgot to put "DontMakeItFreakingUgly" in some config file somewhere. anyway, I found it annoying enough in GTK gvim to recompile to use athena widgets so I could use standard X11 fonts.
21:13:56 <dmead> tim: i can't even read what you have at the ghci prompt
21:13:57 <dmead> :<
21:14:14 <timthelion> lol
21:14:39 <Cale> What is that, Monospace 6?
21:14:40 <LoganCapaldo> Hmm
21:14:49 <LoganCapaldo> I wonder if lambdabot is based on ghci
21:14:49 <dmead> ew
21:14:51 <LoganCapaldo> :
21:14:51 <dmead> seriously man
21:14:56 <timthelion> it's lucinda-typewriter size 8
21:14:57 <dmead> i'm lookin at in magnified
21:14:58 <LoganCapaldo> ;)
21:15:06 <LoganCapaldo> @botsnack
21:15:06 <lambdabot> :)
21:15:08 <dmead> it's obviously losing character shapes
21:15:11 <dmead> at that size
21:15:21 <timthelion> the smallest font that can display
21:15:42 <dmead> why do you do that to yourself :P
21:15:50 <LoganCapaldo> well at least you aint wasting your screen space with large letters :)
21:16:38 <Tene> I find terminus to be very nice at small sizes.
21:16:40 <timthelion> If I go to size D it becomes like http://www.timthelion.com/too-small.png
21:16:52 <timthelion> size 6 I mean
21:17:02 <dmead> why do you do that?
21:17:31 <dolio> Heh, a lot of that is just blocks of color.
21:17:56 <dmead> i suspect you'd learn haskell faster with bigger fonts ;)
21:17:58 <Cale> hmm, which distribution are you running?
21:18:00 <dmead> i could be wrong though
21:18:05 <timthelion> I can't read what is in the too-small one
21:18:20 <Cale> I don't have that font, but I'd like to see how it looks when antialiased.
21:18:53 <dons> timthelion: you'll learn faster with larger fonts ;-) http://www.cse.unsw.edu.au/~dons/tmp/screen-dons.png
21:18:56 <Cale> ah, apparently it comes with the j2sdk
21:19:08 <dons> and code looks nicer too.
21:19:18 <timthelion> -*-lucidatypewriter-*-r-*-*-" (int-to-string font-size) "-*-*-*-*-*-*-*
21:19:39 <timthelion> and the expresion evaluates to 8
21:19:47 <sorear> LoganCapaldo: I've proposed to make it ghci based in the past.
21:19:49 <timthelion> -*-lucidatypewriter-*-r-*-*-8-*-*-*-*-*-*-*
21:19:55 <timthelion> that's the font
21:19:58 <dmead> ...
21:20:05 <timthelion> send be a screeny of it with AA
21:20:07 <dmead> use 12 please :<
21:20:22 <sorear> LoganCapaldo: I have never else seen dons show as much, er, emotion as he did on that day...
21:21:19 <Cale> sorear: hm?
21:21:35 <sorear> If I wanted to do some kind of STM on-demand checkpointing thing, is unsafeIOtoSTM the function to use?
21:21:44 <sorear> I want some kind of run-after-commit
21:21:57 <timthelion> dons is that rp there?
21:22:05 <dons> rp?
21:22:10 <timthelion> ratpoison
21:22:15 <timthelion> windowmanager
21:22:18 <dons> hah.
21:22:21 <dons> slander!
21:22:23 <dmead> hahhhh
21:22:25 <Cale> It's probably xmonad :)
21:22:25 <dons> ?where xmonad
21:22:26 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
21:22:32 <dons> xmonad.org
21:22:40 <timthelion> wtf?
21:23:06 <timthelion> is that ANOTHER tilled wm?
21:23:11 <dons> rp is 13k lines of bloat
21:23:11 <sorear> YES!
21:23:14 <timthelion> I wonder if sabbets has heard
21:23:25 <timthelion> dons lol
21:23:31 <dons> xmonad is 400 lines of lambda goodness.
21:23:50 <timthelion> that's sick, where's the feature list?
21:24:05 <timthelion> I won't move to it, I use stumpwm
21:24:12 <ivanm> dons: so you've got a window manager and a text editor going...
21:24:14 <dons> http://darcs.haskell.org/~sjanssen/xmonad/Config.hs
21:24:15 <jcreigh> *cough* and by 400 lines, we mean, "more than 400 lines" *cough* :)
21:24:20 <ivanm> aiming for a complete haskell DE, are you? :p
21:24:23 <dons> ivanm: and an mp3 player.
21:24:35 <dons> and hmm, there's a haskell kernel in the building next door
21:24:40 <ivanm> is that the mpd frontend? not quite haskell only, is it?...
21:24:42 <dons> just need a shell and an xterm now.
21:24:44 <ivanm> lol
21:24:54 <ivanm> isn't there a haskell-based shell language?
21:24:55 <dons> mpg321 frontend.
21:24:59 <ivanm> lambda or something?
21:25:16 <jcreigh> timthelion: I never really looked at stumpwm. what's the advantage over ratpoison, other than realtime lisp hackability?
21:25:22 <dons> jcreigh: yeah, 466 code /    490 comments
21:25:30 <timthelion> hell, looks easy to set up, might just take it for a spinn
21:25:42 <timthelion> is it fully customizable in a language of my choice?
21:25:48 <dons> sure.
21:25:54 <jcreigh> as long as your choice is "Haskell"
21:25:56 <dons> as long as that choice is haskell
21:25:57 <dmead> tim: could you try calling it in your X session?
21:26:02 <timthelion> jcreigh nothing really, it's just easier to hack
21:26:07 <ivanm> dons: well, you just have to change it to "under 500 lines of Haskell" ;-)
21:26:11 <dmead> i'm curious if it makes your X crash
21:26:16 <dmead> due to a running wm
21:26:22 <dons> ivanm: i'm hopeful
21:26:38 <ivanm> jcreigh, dons: just like the first colour phone could be in any colour that you want, as long as that colour is "black"? ;-)
21:26:51 <dmead> dons: apparently the proper procedure for a --replace is really like 5 lines long
21:26:53 <jcreigh> ivanm: I think you're thinking of Ford's model T.
21:26:57 <timthelion> it would, except I would do tmpwm
21:27:24 <ivanm> dons: you could always join a couple of lines together to get the line count down... or drop some type definitions...
21:27:35 <ivanm> jcreigh: I thought it was a phone... *shrug* could have been the model T
21:27:54 <dmead> yea
21:27:56 <dmead> it was the model T
21:28:45 <timthelion> I don't see any feature list
21:28:47 <dmead> ah
21:28:48 <ivanm> @google "any color you want, as long as it's black"
21:28:50 <dmead> dons
21:28:50 <lambdabot> http://daringfireball.net/2004/09/choose_microsoft
21:28:50 <lambdabot> Title: Daring Fireball: You Can Choose Any Color You Want, as Long as It's Black
21:28:56 <jcreigh> haha
21:28:57 <dmead> what do i do...
21:29:00 <dmead> i did
21:29:05 <dmead> pkill kwin ; xmonad-darcs
21:29:13 <ivanm> @google any color you want, as long as it's black
21:29:13 <dmead> and it's running
21:29:15 <lambdabot> http://www.brainyquote.com/quotes/quotes/h/henryford109833.html
21:29:15 <lambdabot> Title: Henry Ford Quotes
21:29:16 <dmead> soooo
21:29:26 * dmead is lost
21:29:57 <Cale> http://cale.yi.org/autoshare/ridiculously-small-font.png
21:30:45 <Cale> There's Lucida Sans Typewriter at 6 point with subpixel antialiasing. It looks colourful because it's using parts of pixels to draw its lines.
21:31:08 <Cale> But for the size, it's fairly readable.
21:31:28 <ivanm> dmead: try searching on google maps then ;-)
21:31:33 <Cale> At 8 point on my machine it looks quite a lot larger.
21:31:39 <dmead> :P
21:31:51 <kc5tja> More accurately, it uses "subpixel rendering," which is designed for use with LCD displays that have a fixed RGB or BGR pixel layout.
21:31:51 <dmead> well, xmonad doesn't crash when the current wm is killed
21:32:07 <dmead> but it's still not a proper change of ownership to xmonad
21:32:18 <dmead> cause text entry didn't work
21:32:43 <Cale> http://cale.yi.org/autoshare/less-ridiculously-small-font.png -- there it is at 8 point.
21:33:09 <dmead> thats some nice antialiasing
21:33:44 <LoganCapaldo> 8pt is nice
21:35:38 <timthelion> hmm, not so easy to set up Setup.hs: Error: Could not find module: Control.Monad.Error with any suffix: ["hi"]
21:35:44 <timthelion> that was mtl
21:36:08 <Cale> Yeah, my LCD display is laid out as RGB, so unless you have a similar LCD display, the subpixel rendered text probably won't look so great.
21:36:22 <timthelion> Cale why is it sooo much larger than my 8 point?
21:36:52 <Cale> timthelion: I'm not really sure -- maybe in your X configuration, the dpi is set differently.
21:38:08 <timthelion> Cale I know one thing, I counted the number of pixles, and mine IS 8 high
21:38:27 <Cale> That's 8px, not necessarily 8pt.
21:38:51 <sorear> 1 point is 1/72 inches.
21:38:58 <timthelion> or wait, maybe it's only 6
21:38:59 <sorear> 1 pixel is display dependant.
21:39:25 <timthelion> no it's 8
21:39:26 <sorear> Also, most systems don't actually know the screen resolution and guess brokenly.
21:40:02 <LoganCapaldo> which is too bad
21:40:05 <lokamr> that's not very nice
21:40:12 <LoganCapaldo> it would be nice to use my screen as a ruler
21:40:13 <LoganCapaldo> :)
21:40:16 <timthelion> ubuntu is always correct, except when it comes to audio
21:40:33 <dmwit> ... what?
21:40:39 <Cale> I'm using Ubuntu (Feisty beta), as it happens.
21:40:44 <Cale> What's wrong with the audio?
21:40:55 <Cale> My Audigy 2 works splendidly :)
21:41:01 <lokamr> :)
21:41:05 <dmwit> And what do you mean that it's always correct on other things?
21:41:06 <timthelion> oh, it always seems to have peoples microphones turned off be default
21:41:11 <Cale> ah
21:41:14 <dmwit> My wireless is horribly bad...
21:41:23 <Cale> I don't happen to have a microphone at the moment.
21:41:33 <timthelion> oh, I love zenirc
21:41:39 <lokamr> I can't get my microphone to work :(
21:41:49 <timthelion> lokamr it's probably turned off
21:41:54 <Cale> Though if my sister doesn't start using the headset she got for Xmas, I'm going to have to steal it :)
21:41:57 <lokamr> i raised the volume
21:42:10 <lokamr> or is there something special you need to do?
21:42:19 <dmwit> No, that's it.
21:42:24 <lokamr> kk
21:42:28 <dmwit> It might just be very quiet.
21:42:35 <timthelion> lokamr first, alsaconf does NOTHING
21:42:36 <dcoutts> @seen dons
21:42:36 <lambdabot> dons is in #haskell-soc, #haskell-overflow and #haskell. I last heard dons speak 16m 13s ago.
21:42:40 <Cale> also check that it's not just muted
21:42:45 <dmwit> I found that unless I toggled the +20dB check box, it was unhearable.
21:42:57 <Cale> Probably you can just use the volume control on the gnome panel.
21:42:58 <lokamr> timthelion: I used alsamixer
21:43:06 <dcoutts> dons: comming in today? the meeting is at 3pm
21:43:14 <timthelion> lokamr then, you need to go into the gnome audio thing that you get at by clicking insanley at the speaker in the system tray
21:43:21 <Cale> Which, by the way looks very good in Feisty.
21:43:25 <timthelion> and you need to configure it so it shows ALL options
21:43:28 <dons> dcoutts: nope, gotta go and do some prep. for the trip. chak knows.
21:43:30 <timthelion> then you need to unmute it
21:43:40 <dons> dcoutts: should be in tomorrow morning though.
21:43:51 <dcoutts> dons: 'k
21:43:57 <timthelion> dons did you see my problem?
21:44:09 <timthelion> Setup.hs: Error: Could not find module: Control.Monad.Error with any suffix: ["hi"]
21:44:20 <timthelion> for mtl
21:44:21 <dons> you don't have mtl installed.
21:44:24 <Cale> I can understand why, as a distribution designer, you'd want to be cautious with muting/volume of audio inputs.
21:45:03 <timthelion> That is correct, I am trying to install mtl
21:45:24 <Cale> timthelion: are you using ubuntu's packages to install ghc?
21:45:32 <timthelion> Yes
21:45:38 <timthelion> do they include mtl?
21:45:39 <Cale> libghc6-mtl-dev
21:46:08 <Cale> actually, probably just install libghc6-*-dev so as not to get really pissed off later :)
21:46:27 <Cale> There ought to be a metapackage.
21:47:20 <lokamr> hmm my capture keeps dropping
21:47:32 <Cale> If you're not on Feisty, that's an old version of GHC though.
21:47:53 <timthelion> the next question of course, is how to pull http://darcs.haskell.org/~sjanssen/xmonad/
21:47:54 <Cale> When I was running Edgy, I just downloaded and installed the generic linux binary package.
21:47:55 <lambdabot> Title: Index of /~sjanssen/xmonad
21:48:07 <Cale> Looks like a darcs repo
21:48:15 <Cale> So just  darcs get http://darcs.haskell.org/~sjanssen/xmonad/
21:48:15 <dons> Smells like one too.
21:48:16 <lambdabot> Title: Index of /~sjanssen/xmonad
21:48:38 <Cale> and then darcs pull from the directory that's created whenever you want to get an update
21:48:49 <dmead> night all
21:49:03 * dmead is away: eyelid inspections
21:49:05 <timthelion> I feel like a stranger in a scarry land
21:49:24 <Cale> hehe
21:49:44 <Cale> Haskell-land, or are you new to Linux as well?
21:49:54 <timthelion> I had to get darcs as well
21:50:08 <timthelion> Oh, I've been using linux for 3 years. but haskell
21:50:11 <timthelion> haskell.
21:50:12 <Cale> Ah, cool.
21:50:47 <Cale> So it's not quite as scary as it might otherwise be. Darcs is certainly a bit of a haskellism, but I found it much much easier to use than CVS or SVN.
21:51:06 <timthelion> linux was like jumping off a bridge into a river. and learning it was a better way of travel than by foot.  Haskell is like standing on a rather slippery rock in that river and flapping as hard as I can because I see people flying up there
21:51:21 <Cale> hehe
21:52:27 <timthelion> grr, Setup.lhs: error reading ./.setup-config; run "setup configure" command?
21:52:40 <timthelion> and yess, I did change the home dir to timothy from dons
21:53:24 <Cale> hmm
21:53:53 * Cale directs timthelion's growling at dons :)
21:54:38 <Cale> I wonder what .setup-config is
21:54:46 <timthelion> it didn't do anything stupid like create it IN my homefolder instead of ~/.w3m/xmonad
21:55:18 <timthelion> ah, it doesn't think I have a dependency
21:55:35 <Cale> Which one?
21:55:43 <timthelion> x11-extras
21:55:48 <int-e> Cale: that's where cabal stores its configuration (from setup configure)
21:55:53 <Cale> int-e: ah
21:56:02 <Cale> timthelion: okay, hmm
21:56:12 <dmwit> ?where x11-extras
21:56:13 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/X11-extras
21:56:27 <dons> timthelion: you're not doing : runhaskell Setup.lhs configure ?
21:56:30 <dmwit> I think there are a few other dependencies, too.
21:56:50 <dons> yeah, and you've probably not got X11-extras installed?
21:56:59 <dons> make sure the dependencies listed in the README, and on xmonad.org are installed
21:57:00 <Cale> you can also chmod +x Setup.lhs and then just ./Setup.lhs configure
21:58:44 <timthelion> the fact that the  X11 package is calle X11 and not X11-haskell-dev like it SHOULD be by any sane mans standard threw me off.
21:59:07 <timthelion> I though meh, x11 gota have that... meh x11-extras got that undoubtedly as well
21:59:29 <dons> timthelion: yes, they refer to the haskell packages.
21:59:34 <Cale> It's a GHC package, not a Debian/Ubuntu package.
21:59:48 <Cale> So it has to be Haskell-related :)
22:00:51 <dcoutts> Cabal should say: "you are missing the following *Haskell* packages: X11, X11-extras"
22:01:14 <jcreigh> sjanssen: http://www.jcreigh.com/xmonad/triplehead.jpeg (sorry for the low quality...couldn't get the lighting right. then again, I wasn't really trying that hard.)
22:01:15 <Cale> indeed
22:01:24 <dcoutts> of course really should make cabal-install work and get dep chasing for free
22:01:57 <Cale> jcreigh: sounds like a job for that HDR stuff everyone's been talking about lately :)
22:02:04 <rhz> Are there any known problems with installing c2hs on Mac OS X?
22:02:11 <timthelion> why aren't there readme's for any of these?
22:02:13 <int-e> and get a mess of distribution installed and cabal-install installed packages? eek.
22:02:24 * sorear recognises irssi and vim
22:02:31 <dcoutts> int-e: they should co-exist fine
22:02:52 <timthelion> forinstance, I tried runhaskell Setup.hs configure
22:02:55 <timthelion> and got Setup.hs: X11.cabal:42: Unknown field 'install-includes'
22:03:02 <sorear> dcoutts: or better yet, I should get motivated and write aptage :)
22:03:06 <jcreigh> sorear: firefox is washed out at left.
22:03:07 <timthelion> with that X11 package
22:03:16 <timthelion> and there's no readme
22:03:19 <sorear> you need an up-to-date cabal
22:03:20 <sjanssen> timthelion: upgrade cabal
22:03:25 <dcoutts> sorear: or just make cabal-install work? do we need a new prog?
22:03:34 <sorear> dcoutts: yes!!
22:03:41 <dcoutts> sorear: because?
22:04:05 <sorear> dcoutts: I want to have ONE package manager.  Not two, not thirteen.
22:04:05 <sorear>  
22:04:27 <dcoutts> sorear: well for the distro you just make distro packages
22:04:43 <dcoutts> sorear: and there are tools for turning cabal packages into distro packages
22:04:51 <sorear> huh? that's exactly what aptage does
22:04:55 <Cale> According to a recent article, Haskell is based on Г«-calculus.
22:05:12 * Cale wonders what character encoding problem caused this :)
22:05:12 <sorear> it is (in my mind) a gateway between the apt system and hackage
22:05:26 <sorear> sso you can just apt-get install aptage-x11-extras
22:05:39 <sorear> and apt gets it from hackage.haskell.org/aptage/debian/pool/...
22:05:46 <dcoutts> sorear: oh ok, but isn't there one of those already? the one that the debian packagers use
22:05:49 <jcreigh> sorear: does that exist? Right now?
22:05:50 * dcoutts -> meeting
22:06:02 <sorear> dcoutts: it exists but it isn't automated
22:06:10 <jcreigh> (as in, I could add that to my apt sources and be done with it?)
22:06:19 <rhz> I am trying to run ./Setup.hs in c2hs on a Mac. It says:     Couldn't match expected type `Distribution.PackageDescription.PackageDescription'
22:06:19 <rhz>            against inferred type `LocalBuildInfo'
22:06:25 <sorear> jcreigh: nah.  bd_ put it in for me as a SoC, but it wasn't accepted :(
22:06:38 <bd_> :(
22:06:44 <bd_> <-- saw that a few minutes ago
22:06:46 <cfraz89> hi, i'm really new to haskell, but have an assignment on it. is this a good place to ask for help?
22:06:59 <bd_> I dunno, maybe I'll get bored and hack on it anyway, but who knows, right? :)
22:07:00 <sorear> yes
22:07:13 <cfraz89> cool, thanks
22:07:26 <cfraz89> right now, i'm trying to debug an empty list error, and trying to print an int
22:07:26 <Cale> Apparently xerox is in for SoC again :)
22:07:38 <cfraz89> this code doesnt work ....
22:07:40 <cfraz89> grow i r axiom          =  do
22:07:40 <cfraz89>                             putStr (show i)
22:07:40 <cfraz89>                             return substitute r axiom ++ grow (i - 1) r axiom
22:07:52 <sorear> precedence
22:08:05 <sorear> return substitute r axiom ++ grow (i - 1) r axiom
22:08:05 <sorear>  
22:08:06 <int-e> return is a function, not a keyword
22:08:06 <Cale> Stick a $ after return
22:08:07 <sorear> parses as
22:08:18 <cfraz89> ok, thanks
22:08:19 <sorear> (return substitute r axiom) ++ (grow (i - 1) r axiom)
22:08:28 <sorear> you didn't mean that :)
22:08:59 <sorear> though the resulting type error was probably extremely confusing
22:09:17 <cfraz89> tried the brackets, and the $
22:09:19 <cfraz89> both give Couldn't match `[]' against `IO'
22:09:28 <sorear> also, putStr (show i) is probably a bad idea
22:09:33 <cfraz89> yeah, i'm seasoned at c++ and python, but haskell is very different
22:09:55 <Cale> cfraz89: oh, well, grow (i - 1) r axiom isn't a list
22:10:00 <sorear> haskell is a lot more like ML or scheme, if you know either of those
22:10:01 <Cale> so you can't use ++ on it
22:10:14 <cfraz89> shouldnt grow return a list?
22:10:16 <Cale> It's going to be an action, so you should probably run it to get a list.
22:10:18 <cfraz89> sorear: nope :)
22:10:23 <dons> woo. projects are announced for SoC
22:10:28 <Cale> Which means doing something like
22:10:32 <Cale> xs <- grow (i - 1) r axiom
22:10:38 <Cale> after which xs is a list
22:10:42 <cfraz89> ok, thanks
22:11:37 <dons> sjanssen: did you get the gig with PSU?
22:11:43 <cfraz89> just this line -> substitute r axiom ++ grow (i - 1) r axiom
22:11:47 <cfraz89> works by itself
22:11:53 <cfraz89> but its when i try to add the print, it fails
22:12:13 <Cale> Well, you're changing the type of the whole thing
22:12:16 <cfraz89> what is the correct way to print an integer?
22:12:19 <Cale> It's becoming an IO action
22:12:21 <sorear> print
22:12:22 <sorear> BUT
22:12:26 <dons> usually, you'd print the result though
22:12:26 <sorear> print does IO
22:12:30 <cfraz89> umm ok
22:12:30 <dons> after generating a lazy list.
22:12:46 <sorear> or rather print is IO
22:13:26 <cfraz89> lol i'm just getting this now: src/LSystem/Grow.hs:18:29: Parse error in pattern
22:13:31 <Cale> print :: (Show a) => a -> IO ()
22:13:45 <dons> cfraz89: consider this program,
22:13:46 <dons> mylist = 1 : mylist
22:13:47 <dons> main = mapM_ print (take 10 mylist)
22:13:48 <Cale> That is, print takes a showable value, and gives you an (inert) action for printing that value.
22:14:03 <cfraz89> umm, ok
22:14:06 <dons> there we build up a list, purely, before printing the result. rather than interleaving printing with producing each element.
22:14:16 <Cale> If you're not familiar with IO in Haskell, you should read my quick intro :)
22:14:21 <cfraz89> ok :)
22:14:30 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO
22:14:32 <lambdabot> Title: Introduction to IO - HaskellWiki
22:14:38 <dons> yeah, basically the IO is tripping you up here. so a quick tut on that would be a good idea.
22:14:39 <cfraz89> thanks :)
22:15:06 <dons> http://code.google.com/soc/haskell/about.html
22:15:09 <lambdabot> Title: Google Code - Summer of Code - Organization Information
22:15:10 <dons> projects, everyone :-)
22:15:31 <dons> note also, http://code.google.com/soc/psu/about.html
22:15:32 * sorear is already busy on lambdabot7 ;)
22:15:33 <lambdabot> Title: Google Code - Summer of Code - Organization Information
22:15:35 * ivanm would have wanted to do a SoC project, except that it isn't summer here, and so he doesn't have time :(
22:15:43 <Cale> Is my summer of code logo still being used?
22:15:50 <ivanm> sorear: you mean LB has _version numbers_? ;-)
22:16:30 <sorear> it has for a long time
22:16:32 <sorear> @version
22:16:33 <lambdabot> lambdabot 4p517, GHC 6.6 (OpenBSD i386)
22:16:33 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:16:54 <ivanm> hmmm... from 4 to 7... quite a jump, isn't it sorear?
22:16:55 <sorear> don't ask me, dons' idea
22:17:11 <ivanm> lol
22:17:37 <ivanm> btw, when would you use foldl over foldr or foldl' ?
22:17:43 <dons> I think I prefer "Lambdabot Extreme Edition"
22:17:46 <sorear> @src reverse
22:17:47 <lambdabot> reverse = foldl (flip (:)) []
22:17:54 <sorear> there, pretty much :)
22:18:10 <Pseudonym> I prefer "Lambdabot Extended Dance Mix".
22:18:12 <sorear> not sure if there is any other place it is use{d,ful}
22:18:23 <ivanm> dons: lol... ridiculously overpriced for not much performance gain? when the standard edition can be overclocked faster anyway? :p
22:18:25 <sorear> I prefer megamonad-bot, personally
22:18:32 <Pseudonym> So is the idea to keep the versions of lambdabot and GHC in sync?
22:18:41 <Cale> cfraz89: Let me know how that short tutorial goes, if there is any confusion about what it means :)
22:18:48 <ivanm> sorear: how would using foldl' instead of foldl make a difference for reverse?
22:19:05 <sorear> too strict I think
22:19:16 <cfraz89> brb
22:19:18 <sorear> > reverse [undefined,undefined] `seq` 0
22:19:19 <Heffalump> yes, you don't want to go forcing list elements
22:19:20 <lambdabot>  0
22:19:22 <ivanm> so it would be inefficient because it does too much work?
22:19:32 <sorear> > foldl' (flip (:)) [] [undefined,undefined] `seq` 0
22:19:33 <lambdabot>  0
22:19:36 <sorear> hmm.
22:19:42 <Heffalump> oh, wait
22:19:43 <ivanm> lol
22:19:47 <Heffalump> you'd just be forcing tails
22:19:51 <Heffalump> and you have to force them anyway
22:19:58 <ivanm> *nod*
22:20:03 <Heffalump> oh well
22:20:06 * Heffalump --> work
22:20:12 <ivanm> cya Heffalump
22:20:19 <Cale> cfraz89|away: A good part of really learning IO in Haskell is learning to use the Control.Monad library, which is a cornucopia of control structures to use with any monad, including IO. I can give you a quick rundown of the most important ones when you get back.
22:20:24 <ivanm> sorear: so maybe in this case it doesn't actually make a difference?
22:20:29 <sorear> yah
22:20:45 <ivanm> so, in general, when would you use the un-primed version?
22:21:03 <ivanm> when you're trying to keep the file size down, and every byte counts? :p
22:21:28 <Cale> ivanm: occasionally, you really do have a combiner which is non-strict, and you want to be able to take advantage of that
22:21:42 <ivanm> Cale: example?
22:21:47 <ivanm> if you can think of one?
22:22:58 <Cale> Things which aren't contrived are pretty sparse... perhaps something like a computation of maximum where the values are bounded, so you want to ignore everything else if you see the maximum value.
22:23:26 <Cale> (Though using foldr is arguably better there -- if there was something more interesting going on, you might not have that option)
22:23:31 <ivanm> *nod* but if you used foldl' it would keep on going anyway?
22:23:59 <Cale> Yeah, with foldl', the combining function has no control over whether the computation continues.
22:24:26 <Cale> It continues all the way to the end of the list, interleaving the combining with stepping to the next list element.
22:24:38 <ivanm> in general, if you _have_ to go over the whole list to combine the varioius elements in some way, does it really matter which one you use?
22:24:45 <Cale> Whereas foldl runs all the way to the end of the list, and then starts combining
22:25:02 <Cale> and might stop short of the end of the combination if the combiner permits this
22:26:41 <Cale> So mostly, I'd say it's when you have something which absolutely must be a left fold, but the combination is expensive and it's possible that you don't have to combine everything to get a result.
22:26:48 <Cale> So that's kind of rare.
22:26:52 <Cale> But it does come up.
22:27:44 <ivanm> so, out of the three folds, which one is usually your best option if you _have_ to go through every element in the list?
22:28:03 <ivanm> i.e. you using the fold as an accumulator or something, rather than trying to find something
22:28:31 <Cale> Well, foldl'
22:28:41 <sorear> night.
22:28:55 <Cale> If you really can't get a partial result by looking at an initial segment of the list.
22:29:01 <Cale> For instance, if the result is an integer.
22:29:11 <Cale> Or some other sort of summary of the input.
22:29:17 <ivanm> g'night sorear
22:29:29 <ivanm> Cale: *nod* that's what I thought
22:29:31 <ivanm> just wanted to check
22:29:33 <sorear> first-negative-number is a integer result needy of foldr!
22:29:33 <Cale> If you're searching for something, or you're producing output lazily, it's usually foldr
22:29:35 <ivanm> thanks!
22:29:43 <Cale> In fact, foldr is pretty safe as a default if you're unsure.
22:29:49 <ivanm> *nod*
22:30:34 <ivanm> no, I'm going through the assocs from a n-by-n array, and I want to see which values appear in which rows/columns
22:31:14 <Cale> hmm...
22:31:22 <Cale> What's the output look like?
22:31:45 <ivanm> I'm making it into a pair of Maps
22:32:00 <ivanm> so the first Map has the values by rows, the second has the values by columns
22:32:15 <ivanm> a bit more involved than that (only include values if they obey certain criteria, etc)
22:32:18 <ivanm> but that's roughly it
22:33:00 <Cale> Maps are internally strict, so you probably want a foldl', but if you don't mind doing multiple passes, you could make it so that the elements of the map are lazy.
22:33:46 <ivanm> nah, I want just one pass...
22:34:07 <Lemmih> OLED
22:34:17 <Lemmih> Sorry.
22:34:50 <ddarius> ivanm: Yes.
22:34:51 <Cale> I want an Optimus keyboard :)
22:35:41 <Cale> Given Unicode, that's the future right there :)
22:36:01 <ivanm> ddarius: yes for what? /me has lost track
22:36:23 <ivanm> Cale: Optimus keyboard? is that the one with the little OLEDs for the programmable keys?
22:36:23 <cfraz89|away> Cale: i gotta go right now, i'll be back later, thanks for the help
22:36:39 <Cale> ivanm: yeah :)
22:36:44 <Cale> cfraz89|away: no problem :)
22:36:51 <cfraz89|away> cya
22:36:56 <Cale> later
22:46:40 <dcoutts> @seen Igloo
22:46:40 <lambdabot> Igloo is in #haskell-soc, #gentoo-haskell, #ghc, #darcs and #haskell. I last heard Igloo speak 7h 8m 34s ago.
22:46:44 <dcoutts> @seen ndm
22:46:45 <lambdabot> I saw ndm leaving #happs, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 10h 44m 55s ago, and .
22:52:40 <tmoertel> hmmm... I was just reading HWN and noticed a post entitled "Port Scanner in Haskell" on the Blog Noise section.  Since I wrote a port scanner in Haskell a while ago, I was curious and checked out the link.  It turns out, it's a verbatim copy of my original post.  :-(
22:53:03 <bos> yeah, linkspammers are copying postings these days.
22:53:36 <sjanssen> wow, that's ridiculous
22:53:41 <dcoutts> tmoertel: not a link to your blog? you should email the person and gently remind them of copyright
22:53:52 <sjanssen> is this an automated process?
22:54:01 <tmoertel> bos: Yeah, but the interesting question is how that link-spammed article ended up getting Google juice from HWN?
22:54:09 <bos> beats me.
22:54:38 <sjanssen> tmoertel: dons uses blog search to find stuff for HWN, probably picked it up there
22:54:39 <tmoertel> dcoutts: no, it's not a link to my blog.  I checked to see if it was pulling from my Atom/RSS feeds, but it doesn't appear to be syndicated.  It's just a copy.
22:54:56 <bos> oh, ye gods. i really need to update cabal-rpm and get it to use JaffaCake's "Setup make" goodness. building stuff with just one core is so 2001.
22:55:15 <tmoertel> Maybe we need to augment lambdabot to detect likely linkspam.  :)
22:55:57 <glguy> body in a woodchiper!
22:58:43 <bos> dons: you're visiting the US?
23:01:39 <bos> hm, derek's net connection is ill.
23:08:53 <dons> tmoertel: ah sorry! i thought i recognised it, but couldn't be sure.
23:08:57 <dons> i'll take that down.
23:09:09 <tmoertel> dons: thanks
23:09:11 <dons> your's was a few years ago now, iirc?
23:09:18 <dons> 2003 or so?
23:09:34 <tmoertel> March 2004.
23:11:23 <dons> re. articles, hwn just extracts articles from google based on keywords
23:11:36 <dons> so it ended up in my 'possibles' list, and i didn't check it too thorougly.
23:12:23 <tmoertel> I suspect there's a bit of fun research that could be done on the topic of detecting content that has been "recycled" for the benefit of link spammers.
23:12:58 <tmoertel> A simple test might be to extract for uncommon phrases and then google them to see if there are other hits.
23:13:27 <bos> sure, it's like checking homework assignments.
23:13:44 <dons> ok. i think i've scrubbed it from sequence.complete.org
23:13:48 <dons> http://sequence.complete.org/hwn/20070412
23:13:50 <lambdabot> Title: Haskell Weekly News: April 12, 2007 | The Haskell Sequence
23:14:19 <dons> i've noticed sigfpe's posts getting a lot of this kind of treatment too , unfortunately :/
23:15:44 <tmoertel> The site that had the copy of my article did not appear to have ads or other obvious indicators of link spamming.
23:16:39 <tmoertel> Maybe the person who made the copy made an innocent mistake or was too young to realize that copying might not be the best way to syndicate content.
23:18:01 <tmoertel> bos: how common is copying homework from the internet?
23:18:26 <tmoertel> bos: it is a serious problem at universities?
23:18:27 <bos> tmoertel: about as common as breathing :-)
23:18:37 <bos> yes, it's huge.
23:18:55 <bos> there's an entire industry of undergraduate plagiarism, and countermeasures.
23:19:31 <tmoertel> what percentage of compsci students would you say engages in this kind of cheating?
23:19:57 <bos> i have no idea. i know people were trying it when i was an undergraduate, back in the days of vaxen and bitnet.
23:19:57 * tmoertel went to school before people starting doing this kind of stuff
23:20:21 <ChilliX> tmortel: depends very much on how many countermeasures there are
23:20:32 <bos> ChilliX would know :-)
23:20:35 <ChilliX> and how hard the exercises are
23:20:53 <ChilliX> but even if you police it, easily 10%
23:21:00 <ChilliX> and that's the 10% we catch...
23:21:02 <ivanm> tmoertel: well, I tutored an introductory Matlab class end of last year, and for the first assignment (bisection method) at least half the students had the exact same answer
23:21:05 <ivanm> which was wrong :D
23:21:44 <pstickne_> ivanm, hmmm :p
23:22:04 <ChilliX> tmoertel: and there is a strong correlation between grades and how likely people are to cheat, obviously
23:22:12 <tmoertel> What is the motivation for cheating?  Are grades really more important than learning?
23:22:17 <pstickne_> ChilliX, heh?
23:22:18 <ChilliX> so many of the cheaters don't make it to graduation day
23:22:39 <bos> a strong negative correlation, i'm guessing.
23:22:42 <tmoertel> ChilliX: I would hope that ultimately cheating doesn't pay off.
23:23:12 <ChilliX> I said strong correlation, I didn' say whether it was positive or negative ;)
23:23:36 <ChilliX> It's pretty clear from the interviews we do when we detect similarities
23:24:20 <ChilliX> Often weak students just get into a panic close to an assignment deadline
23:24:26 <pejo> tmoertel, it's hard to measure knowledge, especially in a very short time. What are the odds that a company will detect that you cheated for your undergrad?
23:24:27 <ChilliX> and regret what they did after the fact
23:24:51 <tmoertel> pejo: Can a student cheat all through undergrad and not be detected?
23:25:17 <ivanm> I think its hard to do nowadays...
23:25:32 <pejo> tmoertel, I'd hope not.
23:25:33 <ivanm> I got called up with a 3% chance of plagiarism with one guy
23:25:43 <ChilliX> tmoertel: I think  there are two kinds of cheaters: (1) the weak students who copy bad code from people who are barely any more competetent than they are (and who get detected)
23:26:02 <ivanm> and whilst it's true we were discussing how to do the assignment on MSN (i.e. me telling him he's stupid, and that's not how to do something)
23:26:09 <ChilliX> and (2) bright students who save themselves a bit of time by splitting work in a group (and they often go undetcted)
23:26:13 <ivanm> we had the logs to prove our code was different
23:26:28 <tmoertel> Perhaps homework assignments should come with the requirement that solutions be implemented in terms of an abstract machine that is redefined for each assignment.  :)
23:26:33 <ChilliX> ivanm: 3% chance??
23:26:53 <ivanm> ChilliX: that's the figure I remember, anyway... they used automatic tools to compare assignments
23:27:11 <ivanm> I have to use a similar one for an assignment I'm marking, its called turnItIn IIRC
23:27:21 <ChilliX> well, if I would interview people with 3%, I wouldn't do much else during session...
23:27:57 <ChilliX> (turnItIn is not for code IIRC)
23:28:05 <ChilliX> (more for essays and stuff)
23:28:52 <ivanm> *shrug* it looks for similarities in the document
23:29:00 <tmoertel> I'll be the "market" for cheating on compsci homework would be an interesting subject for economists to examine.
23:29:19 <ChilliX> you have to look for similarities in code differently; ie, you want to match on renamed AST
23:30:30 <ivanm> OK, it wasn't 3%
23:30:49 <ivanm> there was apparently 98 lines that matched, with 7% of mine and 12% of the other guys
23:30:57 <ivanm> if I interpret the results correctly
23:30:59 <ChilliX> Anyway, my experience is that at the end of the day, the people who cheat because they are not able to do an assignment usually drop out at some point anyway
23:31:08 <ivanm> *nod*
23:31:49 <ChilliX> and those who save themselves a bit of time abuse the system to a degree, but would have gotten simialar grades without cheating
23:31:59 <tmoertel> If you're an honest student, but you fear that your work may be copied by other students, what's a good strategy for avoid being accused of being involved w/ plagiarism?  Use stenographic techniques to embed "this code was written by XYZ" into your code?
23:32:12 <ChilliX> This is of the instutution has an eye on things, of course.
23:32:34 <ChilliX> tmoertel: read protect the files in your account ;)
23:32:53 <ChilliX> and don't let printouts lying at the ptrinter for half an hour
23:33:00 <tmoertel> ChilliX: or you could write all your code in K.
23:33:09 <ChilliX> hehe
23:33:14 <tmoertel> ChilliX: nobody could read it.  ;-)
23:33:23 <sjanssen> tmoertel: this may prevent the grader from grading it ;)
23:33:33 <ChilliX> indeed ;)
23:33:59 <tmoertel> sjanssen: what grader would want to admit not being able to make sense of it?
23:34:16 <tmoertel> ;-)
23:34:38 <flux> tmoertel, steganography sounds good. you would need to prove though that the steganography extraction tool isn't custom-made for that case to say "yes, this file was produced by tmoertel" ;)
23:35:23 <flux> even a simple version could catch copiers: encode ascii to the number of white spaces at the end of each line
23:35:28 <sjanssen> steganography sounds tough -- an industrious cheater will rename the variables
23:36:10 <bd_> mm how about making a detached signature of the program, and posting it somewhere public where you can't control the timestamp, immediately before you turn it in - allowing no one to see it in the interim?
23:36:30 <flux> I thought there was a chance someone could steal it before turning it in?
23:36:54 <bd_> Well, at least this way you have a timestamp proving you had it before a certain date
23:36:57 <tmoertel> bd_: that would prove that your solution was the "first one in", but not that you didn't help later cheaters borrow your solution.
23:37:13 <bd_> true - it's probably not possible to prove the latter
23:38:06 <tmoertel> do most cheaters, when caught, try to bluff?  or do they confess?
23:38:19 <QtPlatypus> tmoertel: Try to bluff.
23:38:31 <tmoertel> QtPlatypus: does it work for them?
23:38:41 <QtPlatypus> tmoertel: Depends on the graders.
23:39:15 <tmoertel> it would seem that an effective way to separate the wheat from the chaff would be to ask all suspected cheaters to solve a problem of similar difficulty while the grader watches.
23:39:42 <sjanssen> doesn't catch the smart but lazy cheaters
23:39:47 <QtPlatypus> tmoertel: What if the problem is of such difficulty that it can't be solved within hours.
23:40:05 <bd_> sjanssen: It brings passing the course in line with knowing the material, though.
23:40:55 <bd_> at least the smart but lazy cheaters know their stuff and (hopefully!) won't get someone killed using their skills in the field ;)
23:41:21 <sjanssen> bd_: I'd almost prefer to catch the smart cheaters.  Why didn't they do the assignment?  Arrogance?
23:41:28 <sjanssen> maybe I'm vindictive :)
23:42:00 <bd_> :)
23:42:06 <ejt> hi
23:42:23 <samx> is there any reasonable guide for using HaXml ? The docs coming with it suck
23:42:50 <ChilliX> sjanssen: nah, laziness
23:43:02 <ejt> samx: I started looking at haxml but very quickly switched to HXT
23:43:12 <samx> ejt, why is that?
23:43:51 <ejt> I like the arrow interface, and there's some nice documentation
23:44:41 <samx> hmm.. maybe i'll try it instead. thanks
23:45:18 <ejt> samx: http://www.haskell.org/haskellwiki/HXT
23:45:19 <lambdabot> Title: HXT - HaskellWiki
