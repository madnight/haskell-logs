00:00:15 <dmwit> Or were you referring to all the redundant parentheses?
00:01:03 <Gwern> dmwit: well, the whole thing is pretty awful
00:01:37 <Gwern> the definition of a radiation optimized nuke is like a regular yield nuke, but rejiggering the heat, blast, and nuclear energy outputs
00:01:45 <dmwit> radiationNuke w = [c1 * energy (c2 * w) | (c1, c2) <- [(0.35, 0.5), (0.5, 0.5), (0.15, 10.0)]] -- more better
00:03:06 <Gwern> hmm. I like.
00:03:50 <dmwit> radiationNuke w = zipWith (\c -> (c*) . energy . (w*)) [0.35, 0.5, 0.15] [0.5, 0.5, 10.0] -- depending on how you have your data stored
00:05:04 <ddarius> Everyone loves abstraction!
00:05:14 <dmwit> Golf is fun!
00:05:21 <Gwern> zipWith is going a bit far, I'm afraid
00:05:47 <dmwit> ?pl \c -> (c*) . energy . (w*) -- because, hey, why not?
00:05:48 <lambdabot> (. (energy . (w *))) . (*)
00:19:58 <dmwit> ?src mapM
00:19:59 <lambdabot> mapM f as = sequence (map f as)
00:20:57 <dmwit> :t \f -> liftM head . mapM f
00:21:13 <lambdabot> thread killed
00:21:14 <dmwit> Ah, crap, I forgot.
00:21:47 <dons> :t id
00:21:50 <dons> huh
00:22:03 <lambdabot> thread killed
00:22:05 <Gwern> excellent. now my pointImpact program tells me that a 1 megaton explosion 500 meters away in a snow-covered environment will direct approximately 3.497668606859038e11 onto a square meter
00:22:40 <Gwern> which given that a 1 megaton explosion produces 4.186e15 joules, sounds kind of reasonable
00:23:30 <dmwit> liftM head . mapM f === f . head ?
00:24:00 <dmwit> I guess not, 'cause it misses some side effects.
00:24:07 <dmwit> hum.
00:24:09 <dolio> @free mapM
00:24:25 <lambdabot> Extra stuff at end of line in retrieved type "thread killed\n\n"
00:24:39 <dolio> Heh.
00:24:52 <dons> this is really weird.
00:25:25 <dons> the last patch was mar 5.
00:25:37 <dons> then sometime this week, things started breaking, on two seperate machines.
00:25:46 <dons> hmm
00:26:25 <dmwit> ?hoogle concatMapM
00:26:26 <lambdabot> No matches found
00:26:28 <dmwit> =P
00:27:56 <Gwern> the equation for the pressure generated by an underwater nuke is really weird: peakOverPressureUnderwater w r = 10.7 * 10**6 * w**(0.37) * r**(-1.18)
00:29:01 <tessier> -1.18? Sounds like alchemy.
00:29:47 <Gwern> I'm pretty sure it's a simplification and generalization. no doubt the true equation is way more gnarly
00:29:48 <tessier> Or maybe they don't want to release the real formula and the derivation of those numbers for secrecy reasons.
00:30:35 <Gwern> tessier: unlikely. all the information needed to build a nuke is already out in the open literature
00:31:28 <Gwern> I'm not too sure it's right, though. would a one megaton bomb 500 meters away really produce a 90k PSI shockwave in the water at its peak?
00:32:15 <tessier> Gwern: All of the information to build a nuke isn't in the open literature. If you think you can build a nuke using the trivial description in your high school physics book you are mistaken.
00:33:11 <Gwern> tessier: pretty sure it is. there's an old account of a bunch of physics grad students who took the open literature and came up with a workable detailed design
00:33:21 <tessier> Gwern: Did they build it and test it?
00:33:28 <Gwern> and who said anything about a high school physics textbook anyway?
00:33:47 <tessier> If they didn't build it and test it how could they know what they were missing?
00:34:02 <tessier> It's like writing code on a cocktail napkin and never running it.
00:34:11 <tessier> Unlikely to actually work.
00:34:16 <tessier> The devil is in the details.
00:34:44 <Gwern> tessier: because their design was classified and IIRC the Los Alamos guys said that it'd probably work
00:34:59 <tessier> You got a citation for this?
00:35:05 <Gwern> obviously they didn't test it - their assignment was a design, not manufacturining
00:35:28 <tessier> And if it were classified I don't see how Los Alamos guys could make any sort of comment on it.
00:35:29 <Gwern> tessier: no. do you have a citation on hand for everything you've ever read in your entire life? no doubt some googling would soon turn it up
00:35:45 <tessier> I'm not the one making wild claims here. :)
00:36:41 <Gwern> "Finally, after a valedictory presentation at Livermore attended by a grumpy Edward Teller, they were pulled aside by a senior researcher, Jim Frank. "Jim said, 'I bet you guys want to know how it turned out,'" Dobson recalls. "We said yes. And he told us that if it had been constructed, it would have made a pretty impressive bang." How impressive, they wanted to know. "On the same order of magnitude as Hiroshima," Frank replied."
00:36:47 <Gwern> http://www.guardian.co.uk/nuclear/article/0,2763,983714,00.html
00:36:50 <lambdabot> Title: How to build an A-bomb | Special reports | Guardian Unlimited
00:37:44 <Gwern> some googling did soon turn it up
00:44:36 <tessier> So this was done by PhD's at LLNL? Hardly grad students and open literature. And again, unless tested it's meaningless. One thing I've learned is that that the big difference between theory and practice is that what works in theory often doesn't in practice.
00:44:48 <tessier> s/that //
00:45:11 <dmwit> The difference between theory and practice is that, in theory, there isn't one. ;-)
00:47:20 <Gwern> where does it say they were PhDs?
00:47:26 <Gwern> and they were hardly at LLNL... they are described as amateurs
00:47:45 <Gwern> further, they did it back in the 60s, and in a relatively short time
00:48:41 <Gwern> the task would be even easier 40 years later with all the information which has been released since then
00:48:49 <Gwern> and minor little changes like the internet
01:01:24 <dons> any russian speakers?
01:01:56 <dons> who can translate http://jawarez.mylivepage.ru/blog/2/4079/%D0%90%D0%BD%D0%BE%D0%BD%D1%81%20Xmonad%200.1
01:01:59 <lambdabot> Title: jawarez : Дневник (Блог) / Общие / Анонс Xmonad 0.1, http://tinyurl.com/2rwhr3
01:02:12 <dons> 'Xmonad and '0.1' parse for me
01:02:55 <TSC> The word after 500 is probably "lines"
01:03:00 <dons> heh
01:03:07 <dons> 500 bugs?
01:04:02 <TSC> And on the forum someone is complaining that it's not in debian/ubuntu's repository
01:04:29 <TSC> I think one part says, "In Soviet Russia, xmonad tiles you!"
01:04:33 <dons> heh
01:04:56 <dcoutts> dons: using babelfish:
01:05:00 <dcoutts> "Xmonad - window manager, written in language Haskell. Unique osobennoyst'yu of this program is its size - 500 lines. Haskell - language of the so-called. "clean" functional programming with the very strict static typification."
01:05:15 <szabi> http://physicsweb.org/articles/news/11/4/14: physicists from Austria claim [...] that reality does not exist when we are not observing it
01:05:27 <szabi> is Universe using lazy evaluation? :)
01:05:44 <dons> it really says "typification" ? :-)
01:05:47 <wolverian> isn't that just the copenhagen interpretation? :)
01:05:54 <Gwern> szabi: why not? there's nothing in respect to which it could perform side effects, right?
01:06:02 <dcoutts> dons: well that's translation for you
01:06:05 <szabi> Gwern: yepp
01:06:06 <dons> that's cool.
01:06:18 <dons> haskell is full of the strong typifications
01:06:27 <dcoutts> dons: and clean/pure :-)
01:06:35 <dons> hehe
01:06:38 <Gwern> so, what sort of backtracking does the multiverse use if the multiworlds interpretation is correct?
01:32:56 <therp> gwern ;)
01:33:22 <therp> gwern: recently at ILC, we discussed whether the universe is turing complete or not.
01:33:49 <therp> we concluded it's not, as you are not able to build a turing machine (with an infinitely long tape)
01:33:49 <vegai> xmonad is nice!
01:38:15 <dcoutts> hia swiert, just finishing that conclusion...
01:46:10 <swiert> dcoutts: sure. No worries.
01:46:10 <lambdabot> swiert: You have 2 new messages. '/msg lambdabot @messages' to read them.
01:46:17 <swiert> dcoutts: You're bio is fine.
02:05:15 <fuzan> hmm, I'm trying to further improve my prelude usage. i'm currently stumped in transforming simple list like [1..40] into sublists of arbitrary length. implementing with basic recursion is easy. any of you up for the shot of a sweet oneliner?
02:06:06 <fuzan> splitAt seems difficult to really harness due to the tuple as a return type
02:07:54 <TSC> You mean like [[1,2,3],[4,5,6],...] ?
02:09:25 <matthew-_> fuzan: you might also be after groupBg
02:09:30 <matthew-_> groupBy rather.
02:10:38 <sjanssen> fuzan: splitAt is handy in combination with unfoldr
02:11:12 <TSC> > takeWhile (not . null) $ unfoldr (\xs -> Just $ splitAt 3 xs) [1..40]
02:11:17 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23,...
02:11:40 <TSC> I've only recently starting using unfoldr more often; it's pretty cool
02:12:03 <fuzan> sjanssen: haven't played with unfoldr yet :)
02:12:30 <fuzan> that's pretty neat :)
02:12:44 <sjanssen> @type \c -> unfoldr (\xs -> do guard (not . null $ xs); return (splitAt c xs))
02:13:00 <lambdabot> thread killed
02:13:03 <sjanssen> oh right
02:13:37 <sjanssen> anyway, that one uses the Maybe monad *and* unfoldr
02:14:20 <TSC> Yes, that's nice
02:14:31 <TSC> I didn't think of guard
02:30:26 <dcoutts> swiert: patch sent
02:31:02 <dcoutts> swiert: it's ready for publication from my pov.
02:31:24 <dcoutts> swiert: interesting article from the Jane St. chap
02:33:24 <dcoutts> swiert: though my changes have mucked up the page breaks a bit, that'll need tweaking for my article
02:35:49 <swiert> dcoutts: Yeah. I really liked the JaneSt article.
02:36:18 <swiert> dcoutts: It's really well-written, and he raises some interesting points.
02:44:39 <ivanm> I asked this yesterday, but just want to double-check:
02:44:53 <ivanm> is there any way a function can write to disk and return a value at the same time?
02:45:04 <dcoutts> yep
02:45:20 <dcoutts> blah :: SomeThing -> IO ResultType
02:45:37 <dcoutts> anything that returns in the IO monad can write to a file as a side effect
02:46:06 <ivanm> *nod*
02:46:20 <dcoutts> conversely, if it's not in the IO monad then you know for certain that it cannot have any such nasty side effects
02:46:36 <ivanm> but I'm wanting to return a list of values... or, failing that, something I can parse to get the list of values back
02:48:12 <yip> blah :: SomeThing -> IO [ValueType]
02:49:09 <ivanm> is this because when you say IO (), its an arbitrary type?
02:49:21 <yip> no, IO () means that no value is returned
02:49:21 <dcoutts> no, () is the unit type
02:49:26 <dcoutts> with no interesting values
02:49:29 <ivanm> so how do I get the value out of the IO? just normal xs <- result ?
02:49:37 <dcoutts> the only value of type () is () :-)
02:49:44 <dcoutts> ivanm: yep
02:50:00 <ivanm> *nod*
02:50:08 <ivanm> OK, I'll have a play with that later
02:50:30 <ivanm> I wanted to know, because I'm going to (eventually) split my program up into different parts so bits of it can be re-used
02:50:43 <ivanm> so each part will write to file, and the next part will read it
02:51:21 <ivanm> but if a file doesn't exist, the caller will run the callee, and the callee will not only write the file but also return the values its writing to fle
02:51:23 <ivanm> *file
02:51:46 <ivanm> so that I'm not writing the file then immediately reading it again (just writing it and using the values that were written)
02:54:37 <Pastorn> xmonad == ratpoison?
02:55:40 <ivanm> xmonad == haskell version of dwm, IIRC
02:56:53 <opqdonut> yep
03:00:47 <tompurnell> oh collected fonts of infinite wisdom, impart unto this humble student instructions on how to perform set unions. do i need to import a certain module first?
03:01:54 <TSC> With lists or sets?
03:02:00 <TSC> Data.List has a union function
03:02:48 <Saizan> but if you use set Data.Set has better complexity
03:07:45 <tompurnell> thanks TSC, Saizan
03:08:03 <tompurnell> would that have been a query suitable for lambdabot?
03:08:16 <ivanm> @hoogle union
03:08:17 <lambdabot> List.union :: Eq a => [a] -> [a] -> [a]
03:08:17 <lambdabot> Data.IntMap.union :: IntMap a -> IntMap a -> IntMap a
03:08:17 <lambdabot> Data.IntSet.union :: IntSet -> IntSet -> IntSet
03:08:29 <ivanm> if you phrase it that way, yes! ;-)
03:08:44 <tompurnell> heh, thankyou
03:09:03 <fasta> @seen dcoutts
03:09:04 <lambdabot> dcoutts is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard dcoutts speak 10m 24s ago.
03:09:10 <dcoutts> @yarr!
03:09:10 <lambdabot> I'd like to drop me anchor in her lagoon
03:09:12 <dcoutts> hia fasta
03:09:20 <fasta> dcoutts: I can't build gtk2hs from source
03:09:31 <dcoutts> ok, details?
03:09:33 <fasta> dcoutts: I get syntax errors during configure
03:09:35 <fasta> dcoutts: moment
03:09:53 <fasta> ./configure: line 4114: syntax error near unexpected token `GLIB,glib-2.0'
03:09:53 <fasta> ./configure: line 4114: `PKG_CHECK_MODULES(GLIB,glib-2.0 >= 2.0.0 gobject-2.0 >= 2.0.0)'
03:10:19 <fasta> dcoutts: ^^
03:10:41 <dcoutts> fasta: you are missing some automake m4 macros, probably pkg.m4 from the pkgconfig stuff
03:10:59 <dcoutts> fasta: you should have got a warning about that when you ran autorecof
03:11:05 <dcoutts> autoreconf
03:11:28 <fasta> dcoutts: 1. Run the configure script.
03:11:33 <dcoutts> if you don't need to use the darcs version then just grab the release tarball version
03:11:40 <dcoutts> it has a pre-generated configure
03:11:50 <fasta> dcoutts: I did grab the release tarbal version
03:11:57 <fasta> tarball*
03:12:07 <dcoutts> hmm
03:12:12 <fasta> dcoutts: this is the release configure script that isn't working here
03:13:01 <fasta> dcoutts: When I do autoreconf with the release version it seems to continue
03:13:09 <fasta> dcoutts: Configuration completed successfully.
03:13:20 <fasta> dcoutts: AFAIK, that's not in the INSTALL file instructions.
03:13:30 <fasta> dcoutts: maybe you would like to change that
03:13:45 <dcoutts> fasta: I'm sure there's something not right here, I'm checking
03:14:21 <fasta> dcoutts: Is there already some tree visualisation code written?
03:14:53 <fasta> dcoutts: I get build errors
03:15:02 <fasta> dcoutts: tools/c2hs/base/general/Binary.hs:59:7:
03:15:02 <fasta>     Could not find module `Data.FiniteMap':
03:15:02 <fasta>       Use -v to see a list of the files searched for.
03:15:17 <fasta> dcoutts: glib/System/Glib.hs:12:0: Failed to load interface for `System.Glib.UTFString':
03:15:42 <dcoutts> fasta: can you check with a freshly unpacked gtk2hs-0.9.11.tar.gz if the ./configure works
03:15:59 <dcoutts> fasta: line 4114 does not contain PKG_CHECK_MODULES ...
03:16:15 <fasta> dcoutts: I just downloaded that, I think.
03:16:20 <fasta> dcoutts: yes, I did
03:16:26 <dcoutts> I wonder if you accidentally had already run autoconf or something an overwritten the configure file
03:16:41 <fasta> dcoutts: Ok, I see the problem.
03:16:42 <dcoutts> fasta: what is the md5sum of your configure file?
03:16:59 <fasta> dcoutts: There was an old directory of gtk2hs still lying around...
03:17:01 <fasta> dcoutts: OOPS
03:17:08 <dcoutts> ok :-)
03:17:15 <dcoutts> tell me if you find any further problems
03:17:33 <fasta> dcoutts: I will
03:30:37 * dcoutts notes that a C frontend should be a foldr
03:30:55 <dcoutts> which is of course what allows for pre-compiled headers
03:33:52 <fasta> dcoutts: I am not sure whether algebra programming is much fun.
03:34:19 <dcoutts> fasta: read the "fun of programming", it has a lot on algebra :-)
03:34:37 <dcoutts> fasta: it's useful to note the high level structure of a program
03:34:47 <fasta> dcoutts: attribute grammars can solve that problem somewhat, though.
03:35:04 <igli> that's a beautiful book
03:35:08 <malcolmw> dcoutts: did you know that the Galois folks built a C front-end some years ago - they used it to make money by converting K&R C to ANSI C for a client
03:35:25 <dcoutts> malcolmw: I did, but no code was forthcoming
03:35:34 <malcolmw> indeed - it was proprietary
03:36:13 <dcoutts> malcolmw: I enquired, since I assumed it was not of critical commercial importance anymore
03:36:41 <fasta> dcoutts: the chapter on binary trees is, as all textbooks, trivial (judging from the code).
03:36:47 <dcoutts> malcolmw: mind you, if it was only K&R then it wouldn't have helped me much
03:37:13 <malcolmw> dcoutts: well I assume they must have had a couple of variants for different language standards
03:37:15 <opqdonut> mmmmh k&r
03:37:20 <dcoutts> fasta: I've not actually read it, though I probably should have since my PhD supervisor wrote much of it :-)
03:37:30 <fasta> dcoutts: who is that?
03:37:53 <fasta> dcoutts: Patterson (or something like that?)
03:37:56 <dcoutts> malcolmw: right, but even C99 isn't too hard, it's all the terrifying GNU extensions that makes it really hard
03:37:59 <dcoutts> fasta: Oege
03:38:06 <malcolmw> Bird (or de Moor)
03:38:15 <dcoutts> Oege de Moor
03:38:45 <malcolmw> dcoutts: you think the GNU extensions are terrifying?  Have you looked at the MS extensions?
03:39:06 <dcoutts> malcolmw: a little, but they look mostly like extra type qualifiers / specifiers
03:39:11 <dcoutts> declspec and all that
03:39:29 <dcoutts> from a first look they don't look as hard as GNU C attributes
03:40:02 <malcolmw> dcoutts: apparently there are commercial static analysis tools for C that claim to be able to deal with the syntactic and semantic differences between 14 different compilers
03:40:06 <dcoutts> it'd be a good project for someone to extend it to cover the MS and Sun C extensions
03:40:14 <dcoutts> malcolmw: wow :-)
03:40:30 <malcolmw> dcoutts: even bug-compatibility...
03:40:33 <dcoutts> malcolmw: fortunately I don't need to care about anything other than (recent) gcc
03:40:52 <dcoutts> malcolmw: that's why they can charge real money for it :-)
03:41:39 <malcolmw> dcoutts: trouble is, the actual static analysis they do is incomplete and unsound, so not really worth having. :-)
03:41:56 <dcoutts> heh, but people will pay lots for catching bugs
03:42:08 <dcoutts> even if you can't guarantee to catch all of them
03:42:29 <malcolmw> dcoutts: the false positives are a nuisance though
03:42:35 <dcoutts> yeah
03:43:05 <malcolmw> dcoutts: one of the tools claims in it marketing that "only 20% of reports are false positives"
03:43:16 <malcolmw> this is supposed to be a good thing?
03:43:18 <dcoutts> malcolmw: of course all that is not my aim, I just want to make c2hs work
03:43:40 <dcoutts> an make c2hs+cabal not suck
03:43:43 <dcoutts> an/and
03:43:49 <malcolmw> dcoutts: yeah, I know.  Just passing on some anecdotes I heard last week at a workshop on high integrity programming languages
03:44:28 <dcoutts> malcolmw: aye, ah the pains of real world developers :-) perhaps we could sell them a nice type system...
03:44:59 <malcolmw> dcoutts: seen Cforall?
03:45:31 <dcoutts> malcolmw: nope, but I hear that many of the C analysis tools basically work by type inference
03:46:04 <dcoutts> they make a more sophisticated type system than C uses and then try and infer types for the code and report inconsistencies / type errors
03:46:38 <malcolmw> "Cforall extends the C type-system using overloading, parametric polymorphism, and type generators."
03:46:45 <malcolmw> yay!
03:47:02 <dcoutts> oh, so actually exposed to the programmer?
03:47:25 <profmakx> malcolmw: combined with the type safety of C?
03:47:30 <malcolmw> it is supposed to be a new user-level programming langauge, extending C in a type-inference direction, rather than with OO
03:47:40 <dcoutts> cool
03:47:55 <fasta> dcoutts: Warning: Graphics.UI.Gtk.Abstract.Misc: could not find link destinations for: Graphics.UI.Gtk.Types.TipsQuery
03:47:59 <fasta> dcoutts: is that bad?
03:48:07 <dcoutts> fasta: no, it's just a haddock warning
03:48:12 <fasta> dcoutts: ok
03:48:45 <dcoutts> malcolmw: I sometimes wonder if the easiest way to bring the C coders along would be with something that looks like C but is really ml or strict Haskell
03:48:46 <malcolmw> profmakx: I think the concept to make Cforall type-safe in a way that C is not.
03:49:20 <malcolmw> dcoutts: I used to think that, then I realised it already exists
03:49:23 <dcoutts> a functional language but with first class support for the ST monad and local mutable vars
03:49:30 <dcoutts> malcolmw: sure, we know that, but they don't.
03:49:38 <malcolmw> dcoutts: looks like C, but is really functional... O'Caml!
03:49:49 <fasta> dcoutts: builded ok, one example works. Nice
03:49:57 <dcoutts> fasta: great
03:50:06 <profmakx> malcolmw  i was just kidding around
03:50:37 <dcoutts> malcolmw: but I'd take it further and, like Haskell, distinguish procedures with side effects from functions without
03:50:46 <hpaste>  mdmkolbe-work pasted "Build problem" at http://hpaste.org/1529
03:51:06 <dcoutts> malcolmw: so functions would be pure and allowed to use ST-style state locally
03:51:20 <malcolmw> dcoutts: doesn't SML already do that (I'm not so sure about O'Caml)
03:51:42 <fasta> dcoutts: FastDraw is pretty impressive
03:51:44 <dcoutts> malcolmw: what, distinguish IO in the language?
03:51:49 <mdmkolbe-work> Somehow @CONFIGURE_ARGS@ is getting into one of the recursive calls unsubstitued, but I can't figure out from where.  Any ideas? http://hpaste.org/1529
03:52:40 <malcolmw> dcoutts: I had the impression that the type signatures in SML distinguished side-effecting functions from pure ones.
03:52:50 <dcoutts> malcolmw: oh, I didn't know that.
03:53:07 <malcolmw> dcoutts: my knowledge of SML is hazy though
03:53:17 <dcoutts> mine more so
03:54:18 <dcoutts> malcolmw: basically it'd be Haskell but for C coders :-) so with a pure subset and strict by default and with an explicit lazy defer.
03:54:39 <doserj> if you count "a -> ()" as designating side-effects...
03:55:13 <malcolmw> "SML is actually not a purely functional language; it also includes imperative features. It turns out to be remarkably difficult to extend SML's polymorphic type system to incorporate these imperative features while preserving the soundness of the type system. The SML97 value restriction was imposed as a simple solution to these typing difficulties. Unfortunately, the value restriction sometimes affects us even when we are writing purely functiona
03:55:36 <flux> I think it refers to for example references
03:55:45 <dcoutts> malcolmw: oh but that's just a restrction for making references type safe
03:55:49 <swiert> dcoutts: did you do a darcs send?
03:55:54 <dcoutts> swiert: yes
03:56:01 <dcoutts> did you get it ?
03:56:11 <swiert> Not yet...
03:56:16 <dcoutts> oh, hmm
03:56:30 <dcoutts> swiert: gimme a sec...
03:57:44 <malcolmw> so in SML, a ref type will appear in the signature if there are side-effects going on
03:57:56 <flux> no.
03:58:06 <doserj> malcolmw: no, a ref type will appear if you have mutable variables
03:58:13 <flux> you can have function unit -> unit, which can have side effects or not.
03:58:51 <malcolmw> will the side-effects will be encapsulated, since the references do not escape?
03:59:37 <dcoutts> malcolmw: it's just the problem that unsafePerformIO + IORefs gives you unsafeCoerce, the ML type system has the restriction to ban that
04:00:04 <dcoutts> so there are no restrictions on side effects
04:01:05 <malcolmw> dcoutts: oh, OK, that's not very nice
04:01:12 <dcoutts> right :-)
04:01:44 <dcoutts> and the thing is, when people have access to refs, they tend to use them
04:01:56 <dcoutts> I find a lot of ml code hard to read because of that
04:02:28 <malcolmw> the thing about C is, the only reason to prefer it over Ada/Pascal etc, is that you have easy access to pointers
04:03:18 <dcoutts> malcolmw: to pointer arithmetic you mean? Pascal has pointers of course
04:03:20 <malcolmw> I imagine that if you impose more discipline on pointer operations, the attraction of C starts to fade
04:03:46 <dcoutts> pascal is quite a nice language really, I used Delphi before Haskell
04:03:49 <igli> not for me it doesn't ;)
04:04:36 <dcoutts> igli: so why C ?
04:04:48 <dcoutts> I use C when interfacing to systems that use C
04:04:55 <dcoutts> and C is pretty good for that :-)
04:05:04 <igli> well i prefer my own version, but more because i am a machine coder at heart
04:05:22 <igli> i like the expressiveness of functional langs
04:05:23 * dcoutts likes machine coding in Haskell
04:05:27 <igli> heh
04:05:37 <dcoutts> I just need a little more control over branch prediction
04:05:39 <dcoutts> :-)
04:05:41 <igli> i need to get into it more i think
04:05:55 <dcoutts> and a better backend that does loops better
04:06:04 <igli> tbh i quite like shell script as well
04:06:22 <igli> now that i've actually bothered to learn it ;)
04:06:45 <kolmodin> dcoutts: at least now we know what we need for low level haskell
04:07:04 * Saizan wants an haskell scriptable shell, i'm to lazy to learn sh syntax
04:07:07 <dcoutts> kolmodin: mm, yes.
04:07:26 <fasta> dcoutts: How do I change the compiler I want to use?
04:07:37 <kolmodin> dcoutts: and we did not just a year ago
04:07:40 <dcoutts> fasta: erm, can you be more specific?
04:07:42 <fasta> dcoutts: most packages have something like --with-ghc=
04:08:00 <dcoutts> ah for the gtk2hs ./configure script
04:08:04 <fasta> dcoutts: I compiled it with ghc-6.6, but I want to compile it with ghc-6.7<something>
04:08:07 <fasta> dcoutts: yes
04:08:22 * dcoutts checks ./configure --help
04:08:31 <dcoutts>   --with-hc=HC            use Haskell compiler HC
04:09:17 <fasta> dcoutts: thanks
04:09:31 <dcoutts> kolmodin: if I applied for the ghc maintainer job those would be on my todo list
04:09:54 <dcoutts> kolmodin: an infrastructure for branch prediction and loops in the cmm and lower layers
04:09:57 <kolmodin> dcoutts: I'd vote for you. if there is a vote. :)
04:10:08 <dcoutts> hah, there isn't
04:10:20 <dcoutts> hia ndm
04:10:40 <dcoutts> ndm: are you going to propose the various *performIO functions ?
04:10:56 <dcoutts> I think it's a good idea
04:11:17 <kolmodin> dcoutts: that's what we need. fix bugs that stops haskell from being relied upon in the industry, and make it easier to make lightling fast code
04:11:28 <ndm> dcoutts: i think you should do it, i don't konw what the types are
04:11:48 <ndm> dcoutts: plus i rarely care about performance - its just one case where i want to give some really impressive results
04:11:52 <dcoutts> ndm: same as unsafePerformIO, just with different (lack of) semantics
04:11:57 <kolmodin> anyway. got to get something done
04:12:03 <dcoutts> we've found several uses for inlinePerformIO that are not directly related to ByteStrings
04:12:15 <dcoutts> and so it being exported from a standard location would be better
04:12:16 <ndm> yeah, i think you as the "performance people" should propose it
04:12:22 <ndm> perhaps unsafeInlinePerformIO
04:12:24 <dcoutts> aye, probably
04:12:42 <kolmodin> doItFastIO
04:12:42 <ndm> since inlinePerformIO sounds safer than unsafePerformIO, which is dead wrong
04:12:54 <dcoutts> indeed
04:13:18 <ndm> referentialTransparencyGoByeBye
04:13:35 <dcoutts> and unsafeUnlockedPerformIO
04:13:35 <dcoutts> which is not smp-safe
04:13:36 <dcoutts> where as ordinary unsafePerformIO is mostly smp-safe
04:13:49 <kolmodin> oh
04:13:53 <dcoutts> ndm: oh that's the case for all of them
04:13:57 <kolmodin> (right. I'm note here)
04:14:00 <kolmodin> *not
04:14:19 <ndm> dcoutts: i know :)
04:14:30 <dcoutts> ndm: it's a question of how likely you are to get a hole in your foot
04:15:05 <dcoutts> unsafePerformIO, unsaferPerformIO, unsafestPerformIO
04:15:24 <ndm> maybe the compiler could emit a light electric shock
04:15:33 <ndm> increasing in intensity the more unsafe the IO is
04:15:47 <ndm> and obviously not shocking if you provide a formal proof that unsafePerformIO is actually safe
04:15:54 <int-e> randomlyPerformIO
04:16:26 <dcoutts> ndm: right, we just need the proof
04:16:33 <dcoutts> int-e: mm, I like that one :-)
04:16:40 <JaffaCake> surely unsafePerformanceIO
04:16:45 <dcoutts> hah
04:16:55 <ndm> dcoutts: i have an informal proof, but no way of coding it up
04:17:03 <dcoutts> ndm: us too
04:17:04 <vegai> any xmonad guys around?
04:17:14 <ndm> dcoutts: oh, i meant to ask - any way of making list comprehensions go faster?
04:17:24 <dcoutts> ndm: stream fusion :-)
04:17:26 <ndm> dcoutts: they seem to be a bottle neck in my system...
04:17:42 <ndm> dcoutts: as far as i can tell, GHC doesn't desugar list-comps to named functions, so i couldn't find rule targets?
04:17:43 <vegai> the border colours are not in Config.hs, right? Where can I change them?
04:17:48 <dcoutts> ndm: what kind of consumer do you use for your list comp? a foldr or foldl?
04:18:08 <dcoutts> ndm: it desugars them into build and foldr
04:18:15 <dcoutts> at least when you build with -O
04:18:19 <ndm> dcoutts: i don't want fusion, i want a custom rule
04:18:35 <ndm> dcoutts: ah, i was looking at the -O0, i assumed it would desugar in the same way...
04:19:06 <dcoutts> ndm: it only enables the fusion rules for -O, so there's no point in doing the build/forld desugaring at -O0
04:19:09 <vegai> ah, now I see the setBorder calls. And seems like they also have a comment about configurability
04:19:19 <ndm> dcoutts: predictability is always nice though...
04:19:33 <dcoutts> ndm: for -O0 or -rules-off it uses the wadler style desugaring
04:19:49 <dcoutts> ndm: so you cannot do any rule matching with either of the current desugarings
04:20:09 <dcoutts> ndm: the stream desugaring uses basically the monadic style
04:20:19 <ndm> dcoutts: so if i use build in the producer, i may get something?
04:20:20 <dcoutts> and we do use rules to fuse that
04:20:42 <dcoutts> ndm: right. If your generators are good producers it'll fuse under the current system
04:20:56 <ndm> its not at the moment, and it might be some work to make it...
04:20:59 <dcoutts> ndm: similarly the whole list comp is a good producer so you can consume it with a foldr.
04:21:33 <dcoutts> the current system is actually excellent for list comps, it's just not good for consuming a list comp with a foldl
04:21:44 <ndm> the list comp is the result, so thats not important (doesn't want to go any further)
04:21:45 <dcoutts> like sum [ n * n | n <- ns]
04:23:01 * ndm goes to look at build
04:23:33 <ndm> low-level performance optimisation in GHC seems like a skill that takes a lot of pain to learn
04:24:20 <dcoutts> ndm: aye, people keep telling us to write more about it to spread the knowledge
04:24:35 <ndm> i'm hoping my super-optimiser will make the knowledge less useful
04:24:38 <dcoutts> we think that's a good idea, though it's not stuff we can publish sadly
04:24:46 <dcoutts> ndm: I hope so :-)
04:24:58 <ndm> i now have a more concrete design, a termination proof, completeness proof etc
04:25:00 <dcoutts> ndm: magic is great, when it works
04:26:34 <dcoutts> ndm: however it can only get you so far, you can't derive that many domain-specific optimisations
04:27:06 <dcoutts> eg the rules in binary to common-up bounds checks
04:27:10 <ndm> dcoutts: indeed, what i'm aiming for is to eliminate all overhead in all circumstances - so people can focus on O(*) algorithms, not low level tweaks
04:28:10 <dcoutts> ndm: in the binary example, it only works because we write the combinators in a form that makes it obvious and then add a rule to do it
04:28:50 <dcoutts> even if one could work out the rule or have it happen automagically somehow, you still need to know to write the combinators that way
04:29:11 <dcoutts> unless we can have this optimisation happen however we write the code, which is even less likely
04:29:42 <dcoutts> my point is that I think some optimisation tasks really need extra information from the programmer
04:29:58 <yip> how do you compile tail recursion into a C-style for loop?
04:30:19 <ndm> i want to limit programmer supplied information
04:30:28 <dcoutts> or feedback from the compiler to tell the programmer why a certain optimisation did not apply when they expected it to
04:30:36 <ndm> since it makes a difference between people who write something aiming for performance, and people who just write code
04:30:44 <igli> well you always start with the end condition in my experience.
04:31:00 <ndm> i want to make hte programmer just give up on low-levle tweaks (strictness etc), and go higher up again
04:31:17 <dcoutts> ndm: sure, don't make 'ordinary' programs need lots of info, but allow library authors to supply the extra info
04:31:36 <ndm> why force library authors to spend time pouring over STG?
04:31:52 <fasta> ndm: I hope everyone agrees with that
04:32:02 <dcoutts> ndm: they don't have to want to make it go faster of course
04:32:07 <fasta> ndm: problem is that compilation times rocket when you do that, I guess
04:32:28 <dcoutts> ndm: and we could certainly have better compiling/performance analysis tools
04:32:33 <ndm> dcoutts: what if their code went faster by magic? but rather than requiring incantations, Dumbledoor pre-supplied them automatically?
04:32:44 <dcoutts> ndm: but I just don't believe we can eliminate it all
04:32:50 <ndm> fasta: using the way people have done it, yes - but that doesn't mean its the best way it can be done
04:32:58 <ndm> dcoutts: agreed, but i think we can eliminate a lot
04:33:06 <dcoutts> ndm: that'd be great.
04:33:36 <dcoutts> ndm: I'm eagerly awaiting the paper
04:33:44 <dcoutts> and even more so the impl
04:34:04 <ndm> hehe, wait til after HW - i have the algorithms and the proofs - i will do the impl then
04:34:23 <fasta> ndm: write a program for the program extraction ;)
04:34:44 <fasta> (you didn't say it was a hand-waving proof)
05:03:35 <tompurnell> would one of you kind souls explain the use of backquotes? i.e elem vs `elem`?
05:03:54 <mux> it is used to call functions in infix notation
05:04:01 <mux> ie. you either write
05:04:02 <Lor> a `elem` b   is equivalent to (elem a b)
05:04:09 <mux> > elem 3 [1..10]
05:04:11 <lambdabot>  True
05:04:11 <mux> or
05:04:18 <mux> > 3 `elem` [1..10]
05:04:19 <lambdabot>  True
05:04:22 <tompurnell> ah, thankyou mux
05:04:40 <mux> you're welcome
05:05:05 <mux> it feels more natural to call some functions in infix notation, elem is one, but there are many others (fmap, ...)
05:06:18 <tompurnell> if a 'elem'b is infix, what is the name of the (elem a b) notation?
05:06:45 <mux> prefix
05:06:56 <earthy> and (a b elem) would be postfix
05:07:05 <earthy> prefix is sometimes also called polish notation
05:07:14 <earthy> postfix is sometimes also called reversed polish notation
05:07:15 <mux> and similarly to how you can have a prefix function be infix with ``, you can have an infix function be prefix with ()
05:07:18 <mux> > 1 + 2
05:07:20 <lambdabot>  3
05:07:22 <mux> > (+) 1 2
05:07:23 <lambdabot>  3
05:08:09 <tompurnell> every trip to #haskell is an educational experience
05:08:38 * earthy ponders making RPN numbers in haskell
05:08:45 <earthy> should be doable. :)
05:09:03 <earthy> such that e.g. > 1 2 plus     actually works
05:09:15 <vegai> hmm, ghc is rather silly that it cannot figure out recursive imports
05:09:24 <vegai> or does the standard dictate that?
05:10:14 <Igloo> The standard dictates that you can have recursive imports, but GHC needs some help if you want to do it
05:10:29 <Igloo> http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
05:10:31 <lambdabot> Title: 4.6. Filenames and separate compilation, http://tinyurl.com/yyunf2
05:10:40 <norpan> i suppose you mean mutually recursive
05:11:23 <Igloo> That's what I assumed
05:26:35 <dons> @babel de en Ansatz
05:26:36 <lambdabot> Plugin `babel' failed with: IRCRaised Data.ByteString.last: empty ByteString
05:26:39 <dons> grr
05:30:29 <dcoutts> dons: those plugin errors keep tripping my bytestring keyword highlight :-)
05:31:03 <dcoutts> clearly I should stop listening out for discussion on bytestring
05:31:21 * dcoutts runs for the bus
05:31:43 <Syzygy-> WTF!
05:32:01 <Syzygy-> AVG detects my lambdabot build directory as viral.
05:32:03 * ndm thinks dcoutts should use an alarm clock and miss the buss less
05:32:17 <Syzygy-> "Virus found Downloader.Obfuskated"
05:35:15 <SamB_XP> is that an actual virus?
05:35:35 <SamB_XP> I mean, is it a virus or is it some silly hueristic?
05:35:58 <LeCamarade> @where smtp
05:35:59 <lambdabot> I know nothing about smtp.
05:36:13 <LeCamarade> @where pop
05:36:13 <LeCamarade> @where pop3
05:36:13 <lambdabot> I know nothing about pop.
05:36:14 <lambdabot> I know nothing about pop3.
05:36:24 <LeCamarade> @where mail
05:36:25 <lambdabot> I know nothing about mail.
05:36:38 <zindel> hi all, just started learning haskell. could anyone plz suggest me a site with the typical problems for it?
05:36:41 <SamB> you want to write an email client?
05:36:45 <LeCamarade> lambdabot: Go take a beer. I'll pay.
05:37:00 <LeCamarade> samB, Oui.
05:37:10 <SamB> huh.
05:37:12 <zindel> i.e. perhaps, contests or something
05:37:26 <LeCamarade> SamB: Yes.
05:37:29 <SamB> @google haskell pop3
05:37:31 <lambdabot> http://shae.livejournal.com/
05:37:32 <lambdabot> Title: The Revenge of the Anti-Penguin
05:37:45 <LeCamarade> zindel: 99 problems.
05:37:53 <LeCamarade> @google haskell 99 problems
05:37:57 <lambdabot> http://www.perlmonks.org/?node_id=590126
05:37:57 <lambdabot> Title: Re: 99 Problems in Perl6 (Lisp, Prolog, Haskell)
05:38:29 <LeCamarade> @google haskell 99 problems site:haskell.org
05:38:31 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
05:38:31 <lambdabot> Title: H-99: Ninety-Nine Haskell Problems - HaskellWiki
05:38:37 <chrismbrown> hi, does any one here have a blog on planet.haskell.org ?
05:38:52 <zindel> thanks ;)
05:39:39 <SamB> well, at a glance...
05:40:07 <LeCamarade> SamB: So, you know of a POP3/SMTP library?
05:40:33 <LeCamarade> @google haskell mail library
05:40:35 <lambdabot> http://www.informatik.uni-freiburg.de/~thiemann/WASH/
05:40:36 <lambdabot> Title: Web Authoring System Haskell (WASH)
05:41:12 <SamB> vincenz (missing), augustss, kolmodin, dcoutts
05:41:50 <SamB> ndm, ozone, Syzygy-, CosmicRay (missing)
05:42:11 <ndm> chrismbrown: i do
05:42:12 <SamB> they all seem to have blogs on planet haskell
05:42:22 <SamB> ndm: yeah, thats why I listed you ;-)
05:42:44 <ndm> SamB, thats why i was alerted to this conversation :)
05:42:59 <LeCamarade> ndm: You know of an SMTP lib en Haskell?
05:43:02 <SamB> :-)
05:43:08 <LeCamarade> or POP?
05:43:11 <chrismbrown> ndm: I have a blog on livejournal which is a mixture of personal and haskell related. Should the blog on planet.haskell.org be purely haskell related?
05:43:13 <ndm> LeCamarade: no, Haskell and web stuff sucks
05:43:38 <ndm> chrismbrown: doesn't matter too much, mine is 100% haskell, i have an lj for personal stuff and put hte haskell stuff on a blogger one
05:43:52 <LeCamarade> ndm: But I am not going to do it in C#! :oD
05:43:55 <ddarius> I'm pretty sure there are SMTP things out there somewhere, but I don't think there is anything you can just import and use.
05:44:02 <ndm> chrismbrown: but others have just one - partly its so i don't bore my friends to death with haskell, when none know it
05:44:12 <chrismbrown> ndm: cool, how do I go about adding my blog? I need an rss feed right?
05:44:36 <chrismbrown> ndm: I have the same problem, better to share the haskell stuff with the haskellers!
05:44:37 <ivanm> I want to write a function such that: f [False,True,True,False,True] = [0,1,2,0,3]
05:44:40 <ndm> chrismbrown: yes, the details are on the main page
05:44:52 <ivanm> i.e. the falses all become 0, and each True value is incremented
05:44:55 <yip> anyone know where i could get free darcs hosting for a Free Software haskell project?
05:44:56 <ivanm> how could I do this?
05:45:09 <ndm> yip: alas not currently, but we're working on getting a box
05:45:16 <ekidd> Good morning!
05:45:21 <ivanm> hey ekidd
05:45:25 <ndm> @hoogle mapAccum
05:45:26 <lambdabot> Data.IntMap.mapAccum :: (a -> b -> (a, c)) -> a -> IntMap b -> (a, IntMap c)
05:45:27 <lambdabot> Data.Map.mapAccum :: (a -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
05:45:27 <lambdabot> List.mapAccumL :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
05:45:37 <ndm> ivanm: mapAccumL
05:45:37 <chrismbrown> ndm: cheers
05:45:43 <ivanm> ndm: thanks!
05:45:50 <ivanm> @src mapAccumL
05:45:50 <lambdabot> mapAccumL _ s []        =  (s, [])
05:45:51 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
05:45:51 <lambdabot>    where (s', y ) = f s x
05:45:51 <lambdabot>          (s'',ys) = mapAccumL f s' xs
05:46:52 <shapr> Good morning #haskell!
05:47:01 <chrismbrown> good morning
05:47:05 <LeCamarade> shapr: Mornin'!
05:47:15 <ivanm> hey shapr
05:47:49 <LeCamarade> So, there is really no POP3/SMTP lib out there in Haskell? Is it sane that I start on one?
05:48:00 <LeCamarade> Seeing as I'm not Australian?
05:48:03 <LeCamarade> :o)
05:48:18 <ivanm> heh
05:48:32 <ivanm> what's being Australian got to do with it?
05:49:21 <LeCamarade> ivanm: UNSW is in Australia. ;o)
05:49:28 <ivanm> and?
05:49:38 <ivanm> a lot of things are in Australia?
05:49:38 <mux> @src grioup
05:49:38 <lambdabot> Source not found. You type like i drive.
05:49:40 <mux> oops
05:49:42 <ivanm> s/?/!
05:49:42 <mux> @src group
05:49:43 <lambdabot> group = groupBy (==)
05:50:20 <LeCamarade> ivanm: And so is half of #haskell.
05:50:44 <ivanm> LeCamarade: half? I don't think so...
05:50:51 <SamB> LeCamarade: so ... basically you are saying that you aren't dons?
05:50:56 <ivanm> who here is from down under? I am, dons is...
05:50:58 <ivanm> who else?
05:51:03 <ivanm> dcoutts is temporarily...
05:51:10 <ddarius> ChilliX
05:51:12 <ivanm> SamB: heh
05:51:37 <ivanm> OK, another southernor
05:51:42 <SamB> he's the only one I can think of associated with unsw...
05:51:46 <MarcWebe1> Hi ndm. I had to do some other stuff first. I think you tagsoup library is really great to do what it should do .. I'm wondering why you don't have a main function in the Example.Example module ;) You have to test them once anyway.
05:51:46 <LeCamarade> Your regex fails! s/?/!/ is a bug. s/\?/!/. :o) Um ... to prevent a giant thunk, count those from other places. :oD
05:51:52 <Neil|Work> hello, I've picked up Haskell so I thought I'd idle in here for a bit :)
05:52:07 <Neil|Work> (and try to learn some new stuff)
05:52:11 <SamB> Neil|Work: cool
05:52:27 * SamB gots to go to school
05:52:41 <LeCamarade> SamB: Good luck.
05:52:49 <ivanm> Neil|Work: what do you do at microsoft?
05:53:01 <MarcWebe1> yip: If you like I can give you some space until you find something better. But it would be only an user account on a virtual server.. At least you would be able to start coding and submitting in a few minutes
05:53:03 <Neil|Work> ivanm :: nothing functional ;)
05:53:06 <ivanm> heh
05:53:13 <Neil|Work> I work for Lionhead - one of the game teams within MGS
05:53:18 <ivanm> so, you designed Vista then? *ducks*
05:53:23 <ivanm> ahh, OK
05:53:24 <Neil|Work> *drum roll*
05:53:42 <kalven> badum-tish
05:53:47 <yip> MarcWebe1: hm.... well i'm not actually ready right now. it'll be a few weeks until i have the repos ready to upload
05:54:00 <Neil|Work> actually, I have a good question
05:54:13 <LeCamarade> Neil|Work: Shoot.
05:54:18 <Neil|Work> let's say I define a list type: data List a = Nil | Con a (List a)
05:54:28 <Neil|Work> and I want to specify an instance of Show for it
05:54:54 * LeCamarade is reading ...
05:55:02 <Neil|Work> I'd want to do something like: instance Show (List a) where show (Con x xs) = (show x) ++ "," ++ show xs
05:55:17 * ivanm thinks he's seen something like that somewhere...
05:55:22 <vincenz> Neil|Work: that would work
05:55:23 <ivanm> maybe Bird's book?
05:55:26 <Neil|Work> it doesn't
05:55:32 <Neil|Work> it bitches about the show x
05:55:32 <MarcWebe1> yip: What's you project about?
05:55:34 <vincenz> Neil|Work: you need to specify "shows"
05:55:38 <vincenz> @type shows
05:55:42 <vincenz> which is easier
05:55:47 <ivanm> Neil|Work: whats the case for Nil?
05:55:54 <Neil|Work> ivanm :: I skipped it for simplicity
05:55:54 <ivanm> probably need that...
05:55:54 <lambdabot> thread killed
05:55:56 <LeCamarade> Neil|Work: Almost. Methinks you should take care of the Nil case, as well.
05:55:58 <ivanm> *nod*
05:55:59 <Neil|Work> but just = "[]" or something
05:56:00 <vincenz> shows (Con x xs ) = (shows x) . (',':) . shows xs
05:56:04 <Neil|Work> that wasn't the point
05:56:08 <Neil|Work> ah shows
05:56:15 <vincenz> it's a function taking an extra string
05:56:16 <Neil|Work> see the problem I was having, 'a' isn't a specific type
05:56:18 <vincenz> so it can be written in . style
05:56:25 <vincenz> you also need
05:56:28 <Neil|Work> so that 'show a' doesn't seem to resolve correctly
05:56:37 <vincenz> instance (Show a) => Show (List a) where
05:56:40 <yip> MarcWebe1: it's a framework for realtime multi user webapps
05:56:55 <hpaste>  mdmkolbe-work pasted "How to turn on unboxed?" at http://hpaste.org/1530
05:57:22 <Neil|Work> vincenz :: ahhhh
05:57:25 <mdmkolbe-work> how do I turn on unboxed types?  I thought it was -fglasgow-exts, but that doesn't seem to work
05:57:27 <Neil|Work> let's give this a shot
05:57:43 <ivanm> that reminds me of something I was thinking of earlier...
05:57:52 <MarcWebe1> yip: I'm interested. Do you need some nasty still heavily haskell learning contributors? ;)
05:58:01 <ivanm> is it possible to define lisp-like lists, where they contain arbitrary values?
05:58:29 <ivanm> e.g. lst = SL {1, "a", (*)}
05:58:35 <ivanm> or something...
05:58:45 * ivanm thinks not, but is probably wrong
05:58:52 <mdmkolbe-work> ivanm: yes, but only if they have a uniform interface, then you can use an existential type.
05:58:55 <LeCamarade> ivanm: Arbitrary values? If we are thinking alike, then no. This is legal in List '(1, 2, 3, 4, "g")
05:59:03 <yip> MarcWebe1: yes. once i get the darcs repos online i am hoping to get patch contributions
05:59:08 <LeCamarade> But illegal in Haskell.
05:59:12 <ivanm> mdmkolbe-work: no, just any old value
05:59:17 <ivanm> LeCamarade: that's what I figured
05:59:34 <ivanm> since in Lisp, lists are just whole big bunches of tuples
05:59:43 <ivanm> and they're not typed AFAIK
05:59:45 <Neil|Work> vincenz :: thanks - I think I've got this cracked now :)
05:59:51 <Lor> There's also Data.Dynamic, but that should not be needed very often.
05:59:57 <ivanm> it'd be a bit hard to define the type of a lisp-style list!
06:00:12 <ivanm> Lor: don't need it, just an interesting thought exercise
06:00:20 <Saizan> ivanm: heterogeneous lists require some fancy type level hackery, there's HList by Oleg et al.
06:00:44 <MarcWebe1> yip: So I have to wait till you are ready to upload, righ?
06:00:46 <ivanm> OK... figures that someone's bothered to do it
06:01:36 <LeCamarade> ivanm: Oleg, you mean? :o)
06:01:57 <mdmkolbe-work> ivanm: Lisp lists are typed, but only dynamically.  If you really need that kind of list in Haskell, you can either make a data type (e.g. data Any = AnyInt Int | AnyChar Char | ...) or the existential types (but stay away from those unless you know what you're doing, they can be a royal headache with things not type checking that you think should; I speak from experience)
06:01:59 <ivanm> not in particular
06:02:11 <yip> MarcWebe1: that would probably be best. I've already got a prototype working but now I'm cleaning it up. It's basicly a "comet" server
06:02:14 <ivanm> mdmkolbe-work: don't need it, just something I was thinking about earlier
06:02:24 <ivanm> thought exercise only as far as I'm concerned
06:02:44 <Saizan> ?where HList
06:02:44 <lambdabot> http://homepages.cwi.nl/~ralf/HList
06:03:10 <ventonegro> lambdabot, are you alive and well?
06:03:22 <Saizan> ivanm: the paper and the slides might be of your interest ^^^
06:03:36 <Saizan> ?type show
06:03:51 <lambdabot> thread killed
06:03:56 <ivanm> Saizan: OK, I'll have a look at it another time
06:03:57 <LeCamarade> Philippa: Our (mildly-heated) discussion on types - it's here at #haskell. Again. Lisp types stoked the fire. Again.
06:03:58 <ivanm> thanks!
06:04:10 <Saizan> she had a fight with ghci, it seems
06:04:13 <LeCamarade> @tell Philippa Our (mildly-heated) discussion on types - it's here at #haskell. Again. Lisp types stoked the fire. Again.
06:04:14 <lambdabot> Consider it noted.
06:04:33 <ventonegro> @type 0 :: Int
06:04:44 * Neil|Work notices Philippa is in here too
06:04:48 <lambdabot> thread killed
06:04:53 * ivanm is confused : ghci will load a function, but won't let you run it
06:04:53 <ventonegro> :-(
06:04:53 <Neil|Work> damn, there are loads of people in this channel I know from others :)
06:04:58 <MarcWebe1> yip: Can you give me a link descripbing what a comet server is? I've read about one sending data to a AJAX application without having been requested by the client?
06:05:09 <yip> MarcWebe1: yes, that's the general idea
06:05:31 <yip> MarcWebe1: "comet" is also known as "reverse ajax", "push http", "lazy http", and a bunch of other names
06:05:33 * LeCamarade wonders what's strange about Philippa being here too ... Neil|Work?
06:05:59 <LeCamarade> Comrades, is there _no_ POP3/SMTP lib out there?
06:06:05 <LeCamarade> ???
06:06:15 <Neil|Work> LeCamarade :: nothing, just a small world
06:06:48 <LeCamarade> Neil|Work: You mean my data type is nothing?
06:06:57 * LeCamarade goes off to massage his ego back to life.
06:07:01 <Neil|Work> surely it'd need a capital N
06:07:10 <Neil|Work> LeCamarade :: I'm a c++ coder, hence the scopey thing
06:07:13 <Neil|Work> it's... well, different
06:07:17 <LeCamarade> Neil|Work: So I didn't even compile??? :o(
06:07:48 <LeCamarade> :oD
06:08:00 * ivanm feels stupid... he typed the command in ghci wrong
06:08:01 <boegel> >:o]
06:08:19 <ivanm> LeCamarade: you're a commie? *runs in terror*
06:08:20 <ivanm> ;-)
06:08:26 <LeCamarade> @tell dons Do you know of a POP3 lib? SMTP? You are the guy who chronicles this stuff for the community.
06:08:27 <lambdabot> Consider it noted.
06:08:44 <Saizan> ?where hackage
06:08:45 <lambdabot> http://hackage.haskell.org/trac/hackage
06:09:05 <LeCamarade> ivanm: We reformed. Mostly. :oD We still like to march in straight lines every now and then, but ... we sold out, essentially.
06:09:13 <ivanm> heh
06:09:33 <LeCamarade> ivanm: What sold me?
06:09:48 <LeCamarade> I was doing a good job spying!
06:10:07 <ivanm> look up...
06:10:15 <ivanm> <LeCamarade> Comrades, is there _no_ POP3/SMTP lib out there?
06:10:16 <ndm> MarcWebe1: i've always run the examples using Hugs, never tried them on GHC - so hence no need for a main
06:10:16 <MarcWebe1> yip: Do you keep the connection open or do you poll?
06:11:00 <LeCamarade> Oh! I couldn't fake the `yo, guys' too long. The revolution does show up in the end. Now, where is that Embassy again? The North Korean embassy, I mean.
06:11:02 <MarcWebe1> ndm: *g* Ah. I should have guessed that. :) Now it makes sense.
06:11:26 * boegel feels like his head is filled with knowledge, without room for any more :(
06:11:26 * ndm assumes it works under GHC, but never actually tested
06:11:27 <ivanm> LeCamarade: they're the best you can do? for shame
06:11:33 <MarcWebe1> Neil|Work = ndm ?
06:11:40 <ivanm> *shakes head* you just can't get decent commies anymore
06:11:41 <ndm> boegel: pass in a continuation and watch everythign flow out
06:11:42 <Neil|Work> no
06:11:43 <ndm> MarcWebe1: no
06:11:51 <yip> MarcWebe1: the plan is to have support for both. right now i have half-poll working
06:11:57 <Neil|Work> I'm just somebody random who wanted somewhere to idle ;)
06:12:06 <boegel> ndm: if I only knew what a continuation was....
06:12:07 <ndm> i am Neil, and I am at work, but thats not my nick
06:12:13 <ivanm> heh
06:12:23 <ivanm> there is only _one_ ndm!
06:12:34 <ivanm> "the one, the only, the original!" :p
06:12:49 <LeCamarade> ivanm: When I am not spying, I am good. Haskell for the revolution! :oD
06:12:55 <ivanm> heh
06:13:02 * ivanm is getting sick of this joke
06:13:32 * LeCamarade figures ivanm has had enough. Okay.
06:13:39 * boegel isn't getting sick of Joke, since that the name of his gf (although it doesn't mean Joke is our language)
06:13:49 <ivanm> heh
06:13:51 <boegel> s/is/in
06:13:58 <boegel> so yes, my gf is a Joke :P
06:14:14 * boegel wanted to tackle that one himself before someone else did
06:14:20 <ivanm> Joke with an english or a european J?
06:14:53 <LeCamarade> ivanm: :oD
06:15:06 <boegel> ivanm: not "Jay" but "iej"
06:15:25 <ivanm> boegel: that's what I thought... european style J
06:15:38 <boegel> ivanm: yep
06:15:59 <ivanm> so does "Joke" mean the yellow part of an egg in your language? *ducks*
06:16:19 <ivanm> what is your native language anyway?
06:17:03 <hpaste>  mdmkolbe-work annotated "How to turn on unboxed?" with "Solution to unboxed types" at http://hpaste.org/1530#a1
06:19:11 <ivanm> ?localtime boegel
06:19:13 <lambdabot> Local time for boegel is Mon Apr 23 15:17:53
06:19:37 <qebab> like the local time for all sane people ;)
06:19:41 <ivanm> heh
06:19:43 <ivanm> @localtime
06:19:45 <lambdabot> Local time for ivanm is Mon Apr 23 23:21:46
06:19:53 <qebab> hm
06:19:58 <qebab> where does that put you?
06:19:58 <ivanm> does that make me a prime candidate for the little white rooms?
06:20:02 <qebab> ^^
06:20:07 <ivanm> same timezone as dons
06:20:21 <boegel> ivanm: heh, no... it has no real meaning, besides 'little Jo'
06:20:26 <ivanm> heh
06:20:29 <mdmkolbe-work> ?hoogle String -> Int
06:20:30 <lambdabot> No matches, try a more general search
06:20:53 <ivanm> boegel: so what is your native tongue?
06:21:05 <ivanm> qebab: you can work out what country I'm from by doing a WHOIS on me
06:21:05 <boegel> ivanm: it does, because your time zone differs by 8h and 4m (!) from mine
06:21:09 <boegel> ivanm: Dutch
06:21:10 <qebab> oh
06:21:21 <qebab> well, I was going to suggest oceania somewhere
06:21:22 <ivanm> boegel: *nod*
06:21:29 <ivanm> qebab: yup
06:21:42 <dylan> ?hoogle [a] -> Int
06:21:43 <lambdabot> Prelude.length :: [a] -> Int
06:21:55 <boegel> pfft, I need to book a plane for my trip to the US in June
06:21:59 <ivanm> boegel: well, I'm not as much insane as not wanting to go to sleep
06:22:05 <boegel> but I have to go by myself, and I really don't like that
06:22:12 * ivanm needs to book planes to go to Ukraine in August
06:22:18 <qebab> ivanm: go to sleep :)
06:22:25 <ivanm> boegel: Joke doesn't want to go with you? or can't?
06:22:28 <qebab> I suffer from insomnia now because I kept myself awake all the time
06:22:32 <ivanm> qebab: ppffffffftttttttttt!!!!!!!!!
06:22:39 <ivanm> qebab: heh, I don't have that problem
06:22:45 <qebab> and you don't want it
06:22:46 * ivanm just sleeps during lectures ;-)
06:22:50 <boegel> ivanm: Can't. It's for work, so it would be really boring for her, plus, she has exams in June
06:22:51 <qebab> aha ;)
06:22:58 <ivanm> boegel: *nod*
06:23:07 <chessguy> 'morning, haskellers
06:23:13 <boegel> yo che
06:23:14 <ivanm> qebab: that's what I was so buggered over the holidays: no time to sleep!
06:23:18 <boegel> *ssguy
06:23:22 <ivanm> evening chessguy
06:23:54 <boegel> chessguy: don't mind ivanm, he's nuts... he thinks his local time is past 23pm... Fruitcake
06:24:06 <chessguy> ?time ivanm
06:24:07 <ivanm> heh... but it is!!!
06:24:08 <lambdabot> Local time for ivanm is Mon Apr 23 23:26:08
06:24:18 <chessguy> i guess lambdabot is nuts too then :)
06:24:25 * ivanm doesn't deny the insanity
06:24:29 <chessguy> @quote nut
06:24:30 <lambdabot> shapr says: [on Oleg:]  And ccshan and he would argue furiously for a minute or two and then SPJ would say "Why don't you send an email to the Haskell list about that so we can have time to understand
06:24:30 <lambdabot>  what you just said?"
06:24:39 <boegel> chessguy: lambdabot just tells ivanm what he wants to hear
06:24:39 <ivanm> "don't forget, you are what you eat... oohhh, nuts!"
06:24:45 <ivanm> heh
06:25:00 <ivanm> @quote insane
06:25:01 <lambdabot> dylan says: I avoid buzz-buzz whenever possible. I prefer math-based or completely insane terminology
06:25:09 <boegel> @quote boegel
06:25:10 <ivanm> @quote sane
06:25:10 <lambdabot> boegel says: goes to inflate Itkovians balls
06:25:10 <lambdabot> pjdelport says: [on qwe1234:] It must be a drag, being the sole beacon of sanity in a field where all the established researchers are unanimously insane.
06:25:15 <ivanm> @quote sleep
06:25:16 <lambdabot> autrijus says: Mechanical and super-natty! Inspect the result and *if* happy; freeze, sell and get some sleep!
06:25:29 <ivanm> @quote sleep
06:25:29 <lambdabot> sorear says: StefanO'Rear says: ...the semantics are what give people named Simon the courage to implement counterintuitive optimizations without losing sleep.
06:26:10 <dylan> that got quoted?
06:26:19 <ivanm> obviously it did
06:26:20 <chessguy> it looks like it to me
06:26:34 <dylan> it's not funny out of context. :(
06:26:46 * chessguy @remembers dylan that got quoted?
06:27:25 <dylan> @quote IT department
06:27:26 <lambdabot> No quotes for this person. Where did you learn to type?
06:27:27 <mdmkolbe-work> @info getArgs
06:27:28 <lambdabot> getArgs
06:27:38 <dylan> @quote department
06:27:38 <lambdabot> dylan says: I'm an IT department.
06:27:58 <qebab> <ivanm> qebab: that's what I was so buggered over the holidays: no time to sleep! <= I know the feeling (but not for the same reason) ;)
06:28:07 <ivanm> heh
06:28:18 <qebab> I slept like 8 hours this weekend
06:28:31 <chessguy> mdmkolbe-work: perhaps this would be helpful? http://www.haskell.org/haskellwiki/Unix_tools/Date
06:28:32 <lambdabot> Title: Unix tools/Date - HaskellWiki
06:28:35 <qebab> out of sleeping pills and doctor doesn't want to give me more, he's sending me to a shrink :s
06:29:09 <dylan> qebab: youch. sleeping problems are a pain.
06:29:17 <qebab> yeah
06:29:26 <chessguy> ?hoogle getArgs
06:29:30 <lambdabot> System.getArgs :: IO [String]
06:29:34 <dylan> I know someone with the opposite problem -- hypersomnia, sleeps too much.
06:29:42 <qebab> ouch
06:29:47 <chessguy> sounds like fun
06:30:02 <qebab> I don't think my body would mind a week with that
06:30:05 <dylan> chessguy: makes getting through college a problem.
06:30:09 <qebab> I look like a ghost right now
06:30:26 <dylan> "Crap! I slept through two days of classes!"
06:30:27 <chessguy> mdmkolbe-work: there are a number of examples on the wiki using getArgs
06:30:45 <qebab> dylan: the worst thing is that there is never a simple solution/cure
06:30:50 * boegel 's gf needs 3 hours more sleep than he does... and I don't mind really, I love sleep
06:31:17 <boegel> but that does imply I have less time for other stuff
06:31:17 <dylan> qebab: there's never really a simple cure for anything.
06:31:27 <ivanm> http://omploader.org/file/shirt_back2.png <- back design for a haskell version of the "this t-shirt is a munitions" shirt that I'm working on
06:31:28 <qebab> that's true enough
06:31:33 <ivanm> comments?
06:31:37 <boegel> I used to go to bed at 12pm, now I'm in bed at 10.30pm
06:32:03 <chessguy> http://xkcd.com/c203.html seems appropriate
06:32:05 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
06:32:15 <qebab> xkcd :)))
06:32:34 <yip> @karma+ xkcd
06:32:35 <lambdabot> xkcd's karma raised to 5.
06:32:36 <ivanm> chessguy: you memorise the different xkcd strips?
06:32:41 <mdmkolbe-work> chessguy: yeah, I was just trying to figure out which module it was in
06:32:43 <qebab> I have the wikipedia one on my door
06:32:46 <chessguy> ivanm: lol, no
06:32:58 <chessguy> i scrolled through http://xkcd.com/archive/
06:33:00 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
06:33:14 <qebab> http://xkcd.com/c214.html <- that one is just fantastic
06:33:15 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
06:33:32 <qebab> because it happens to me at least once a week
06:33:44 <chessguy> ivanm: i don't get that shirt, which makes me feel quite dumb
06:33:52 <waern> there's a tech talk about Djinn on code.google.com
06:33:59 <ivanm> @google this shirt is a munition
06:34:01 <lambdabot> http://www.interesting-people.org/archives/interesting-people/199505/msg00004.html
06:34:02 <lambdabot> Title: PERL/RSA t-shirts for Americans only
06:34:08 <ivanm> that's not it...
06:34:29 <ivanm> @google rsa shirt munition
06:34:31 <lambdabot> http://www.cypherspace.org/adam/shirt/
06:34:32 <lambdabot> Title: perl RSA "munitions" T-Shirt homepage
06:35:11 <ivanm> that's the one
06:37:18 <mdmkolbe-work> ?hoogle Int# -> Int
06:37:22 <lambdabot> Hoogle Error: Parse Error: Unexpected character '> -> Int'
06:39:12 <ivanm> chessguy: the original shirt was a protest when you couldn't export source code for encryption systems from the US
06:39:19 <chessguy> oh, so that's the equivalent haskell code to that perl?
06:39:24 <ivanm> *nod*
06:39:39 <ivanm> I got it off dons, its in the quickcheck for something, can't remember what
06:39:39 <matthew-_> well here's a good one, I'm using TH to generate some foreign import ccalls. If I splice it in, it blows up with '"/tmp/file0119804.h &installer_myInstallerFunc_first_length" is not a valid ccall impent'. But if I runQ it and pprint and then copy and paste into a file, it works!
06:39:58 <ivanm> its based on john launchbury's entry for the bottomth obfuscation comp
06:40:20 <ivanm> chessguy: I'm going to a geek-themed party this weekend
06:40:22 <chessguy> well, it's hardly untyped
06:40:31 <ivanm> no type sigs in the code
06:40:33 <chessguy> even if the types aren't mentioned explicitly
06:40:40 <ivanm> well, there's one thats commented out...
06:40:52 <ivanm> that's what I meant by untyped
06:41:05 <ivanm> it was meant to be a play on words implying its an unknown type of munition
06:41:12 <ivanm> didn't quite get there though... :9
06:41:16 <ivanm> *:(
06:41:38 <chessguy> it would probably be funnier to someone in europe, i guess
06:41:45 <ivanm> why europe?
06:42:07 <chessguy> oh, nm
06:42:45 <ivanm> that design ties in maths, coding, haskell, geeks hating pollies, etc
06:42:56 * chrismbrown must stop procrastinating and get on with some work
06:43:00 <ivanm> heh
06:44:31 <chessguy> @go 14 stones in pounds
06:44:32 <lambdabot> 14 stones = 196 pounds
06:44:32 <boegel> chrismbrown: same here
06:44:43 <boegel> chrismbrown: let's do it together! starting...NOW8
06:45:03 <chrismbrown> boegel: woh! let's not be too hasty!
06:45:14 <chrismbrown> boegel: you have to ease into these things gradually
06:45:22 <chrismbrown> :)
06:45:29 <boegel> chrismbrown: well, ok
06:45:37 <boegel> chrismbrown: let's do it together!
06:45:40 <boegel> chrismbrown: 3
06:45:41 <boegel> chrismbrown: 2
06:45:42 <boegel> chrismbrown: 1
06:45:43 <matthew-_> ahh, figured it out, the source for the lexing of foreign imports by TH doesn't all paths for the header. Grrr.
06:45:44 <boegel> chrismbrown: NOW!
06:45:45 <chrismbrown> boegel: 0
06:45:48 <boegel> chrismbrown: ;-)
06:45:58 <chrismbrown> boegel: :)
06:47:13 <OCCASVS> Hi
06:47:36 <chessguy> hi OCCASVS
06:48:38 <OCCASVS> I can't understand this error (I've just started to learn this language):
06:48:46 <OCCASVS> there is one exercise:
06:49:15 * ivanm -> bed
06:49:17 <ivanm> g'night all!
06:49:22 <chrismbrown> ivanm: night
06:50:08 <boegel> chrismbrown: shouldn't you be working?
06:50:24 <chrismbrown> boegel: I'm pyscing myself up to open the editor! :)
06:50:32 <boegel> ivanm: night (strange time to go to sleep) ;-)
06:50:50 <ivanm> heh
06:50:51 <boegel> chrismbrown: how hard can it be: 'vim<enter'
06:51:29 <chrismbrown> boegel: very hard!
06:51:32 <hpaste>  OCCASVS pasted "Exercies" at http://hpaste.org/1531
06:51:38 <OCCASVS> http://hpaste.org/1531#a0
06:51:55 <OCCASVS> http://hpaste.org/1531
06:52:26 <OCCASVS> And the module Pictures: http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/Code/Pictures.hs
06:52:30 <lambdabot> http://tinyurl.com/yo2ln5
06:53:25 <chessguy> OCCASVS: what's your actual question?
06:53:52 <OCCASVS> There's an error in that code
06:54:15 <chessguy> can you annotate your paste with the appropriate error?
06:54:21 <boegel> OCCASVS: in what sense? it doesn't compile? it does run? it doesn't to what it is supposed to?
06:54:24 <chrismbrown> OCCASVS: what's the error?
06:54:29 <OCCASVS> http://hpaste.org/1532
06:54:55 <chrismbrown> OCCASVS: you can't apply a picture to a picture
06:55:08 <chrismbrown> you have img (invertColour img)
06:55:17 <chrismbrown> but img is a picture not a function
06:55:24 <chessguy> try black img = superimpose img (invertColour img)
06:55:33 <chrismbrown> yes try that...
06:55:56 <OCCASVS> and black :: Picture -> Picture ?
06:56:07 <chrismbrown> looks fine
06:56:12 <chessguy> that's fine
06:56:25 <chrismbrown> it takes a picture, which is img, and returns a picture (the result of the superimpose)
06:56:56 <OCCASVS> Thank you! :)
06:57:01 <OCCASVS> It does work
06:57:06 <chrismbrown> :)
06:57:21 <chessguy> is this from Haskell School of Expression?
06:57:21 <chrismbrown> OCCASVS: do you see what was wrong before?
06:57:29 <chrismbrown> I think it's from Simon's book
06:57:50 <OCCASVS> Haskell: The Craft of Functional Programming
06:57:55 <chessguy> ohh, ok
06:58:00 <chessguy> i knew i had seen it before
06:58:12 <OCCASVS> I've dabbled with C and PHP
06:58:26 <chrismbrown> OCCASVS: how come you are starting to look at Haskell?
06:58:42 <OCCASVS> But I've read something about Haskell
06:58:53 <chessguy> OCCASVS: anyway, the problem before was that the way you had the parentheses suggested that everything after 'superimpose' was a single parameter being passed into it
06:58:54 <OCCASVS> Reading about the functional programming
06:59:20 <OCCASVS> I like the concept, so I'm trying to seriously learn it :)
06:59:38 <OCCASVS> chessguy, yes, the parentheses are a problem atm :D
06:59:50 <chessguy> OCCASVS: it takes some getting used to
07:00:08 <chrismbrown> OCCASVS: that's a common problem when you are starting off
07:00:52 <OCCASVS> It seems that Haskell helps the programmer not to write bad code
07:00:59 <chessguy> it does that
07:01:27 <OCCASVS> Good :)
07:01:59 <chessguy> it's interesting, i haven't touched anything imperative in probably a year, i'll be very curious to see what happens if/when i return to it
07:02:27 <Neil|Work> chessguy :: I'm taking a different approach to it
07:02:27 <chrismbrown> OCCASVS: if by "bad code" you mean code that has bugs in it, then yes I believe due to the rich semantics and the strong type system, Haskell reduces the number of runtime errors
07:02:36 <Neil|Work> learning Haskell in order to tidy up my imperative coding
07:03:03 <Neil|Work> so far, it's working
07:03:17 <OCCASVS> I learnt the basic of imperative programming, but I've never been into it, so I think it will be easier for me to learn the funcional programming
07:03:29 <chessguy> chrismbrown: it also just encourages good modularity, sheerly by the high level of abstraction available
07:03:42 <chrismbrown> chessguy: absolutely
07:03:47 <chessguy> @quote years
07:03:48 <lambdabot> scodil says: dcoutts: rad. i'm actually using gtk2hs quite a bit now. its one of those deals where I'm writing prototype software for people who aren't really paying for it, so it will end up being
07:03:48 <lambdabot> the production software, so you'll probably be getting emails in 5 years asking "what is haskell and how do I install it?"
07:03:57 <OCCASVS> For example, OO programming with imperative languages seems a bit weird
07:04:26 <chrismbrown> OO Programming always seemed a bit artificial for my liking
07:05:03 <chessguy> yeah, trying to force everything into being an object is a little short-sighted
07:05:25 <vegai> what about forcing everything into a function?
07:05:34 * vegai hides behind 5 feet of steel.
07:05:40 <chrismbrown> I can see it's uses in some applications, GUIs, say; but for most other things OO is very ugly and very complex!
07:05:48 <pejo> OOP doesn't mean forcing an object structure upon everything.
07:06:27 <pejo> There are subtyping attempts for functional languages, for example. They don't remove typeclasses, nor rank-n polymorphism.
07:06:30 <qebab> OOP can make for great readability and it's very nice to use for some types of applications
07:07:30 <qebab> things like: "if ship.targets(airplane): ship.shoot(airplane)"
07:07:44 <qebab> I can imagine it's good for game programming, if nothing else
07:07:53 <Philippa> it's not as good as proper reactive programming
07:07:58 <Neil|Work> it's pretty much essential for game programming
07:08:06 <ToRA> if ship `targets` airplane then ship `shoot` airplane ?
07:08:23 <Philippa> Neil|Work: read up on FRP and yampa :-) Though in fairness you'll probably find it feels a lot like extending OO rather than replacing it
07:08:34 <Neil|Work> Philippa :: it's not that side of things
07:08:36 <pejo> Incidentially, some of the subtyping attempts for fp talk about reactive progamming too.
07:08:37 <Philippa> (but there're some fundamental differences with a typical OO model)
07:08:48 <Neil|Work> it's more that abstracting the types out too far means you're too far away from the hardware for practical purposes
07:09:00 <MarcWebe1> How is streaming done with haskell? I mean I want some process beeing able to write to a stream and some other beeing able to read from it. Is it done creating one pipe per reading stream and writing to them all?
07:09:06 <Neil|Work> (which is why C++ objects are so nice, despite the language deficiencies)
07:09:11 <Philippa> Neil|Work: I can show you a lambda calculus that's actually lower level than C :-)
07:09:13 <Neil|Work> and trying to write a big game in C is just horrid
07:09:34 <Philippa> there's value in being able to control physical representation though, sure
07:09:39 <Neil|Work> Philippa :: I bet you can't show me one that'll run efficiently on an xbox360
07:09:47 <yip> Neil|Work: quake 2 was written in C
07:09:55 <Neil|Work> yip :: yes and the engine's a mess ;)
07:09:59 <qebab> yip: that doesn't have to mean the code is good
07:10:03 <Neil|Work> games are far more complex than that, these days
07:10:07 <Philippa> yip: it's also a decade old
07:10:17 <Neil|Work> don't get me wrong, I'm not saying games should be written entirely in C++
07:10:19 <Philippa> and Neil knows what he's talking about better than you do
07:10:19 <MarcWebe1> gtk  is as well ;) (But it has kind of oo disgn implemented manually
07:10:29 <Neil|Work> but for core bits it's still the right way to go
07:10:40 <Philippa> *nod*
07:11:15 <Neil|Work> I'm quite taken with the idea of tying Haskell into C++ for the purposes of higher-level scripting
07:11:33 <Neil|Work> but scripters don't tend to be strong coders - I think they'd commit suicide
07:11:51 <psykotic> the places where you truly need machine-level access are very small. even operating system device drivers tend to be only about 10% low level access (and some device driver structurings reflect this by splitting the code into two modules).
07:11:52 <qebab> it's natural to work with objects in applications like games to be honest
07:12:16 <Neil|Work> psykotic :: ah, hello again ;)
07:12:21 <qebab> however for things like scientific computing and such, very impractical
07:12:28 <psykotic> Neil|Work, hi
07:12:31 <Neil|Work> psykotic :: depends on the platform
07:12:35 <matthew-_> help. ghc is spewing out "error: called object ‘installer_myInstallerFunc_second_length’ is not a function" errors to me, but by using -ddump-simple, they really look like they should be ok...
07:12:39 <Philippa> qebab: for a wide enough value of 'objects', definitely. Something around the C++/Java design space, not necessarily
07:12:48 <Neil|Work> you can be incredibly lazy on the PC because the chip's designed to fix up inefficiencies
07:13:01 <Neil|Work> but you'd be surprised how many of the 'core' features are missing from console chips
07:13:03 <psykotic> Neil|Work, that's the way to go. the 360 is a catastrophe.
07:13:11 <Neil|Work> how so?
07:13:11 <psykotic> trust me, i know plenty well :)
07:13:23 <Neil|Work> I think the 360 is a fantastic machine to work on
07:13:31 <Neil|Work> much prefer it to the nightmare that is the PS3
07:13:35 <psykotic> there's plenty of good things about it but the choice to go in-order was a bad one.
07:13:47 <psykotic> i know why they did it but imo it's the wrong tradeoff.
07:14:03 <Neil|Work> I see your point, but I don't think it's as bad as you'd say
07:14:03 <Saizan> in-order?
07:14:26 <ToRA> matthew-_: can you paste some context?
07:14:28 <Neil|Work> the profiling tools excellent - you can easily find bottlenecks caused by the instruction ordering
07:14:31 <Neil|Work> +are
07:14:43 <psykotic> i know. most of my programming these days is on 360.
07:14:47 <Philippa> Neil|Work: how bad's the PS3 documentation, JOOI?
07:14:49 <Neil|Work> psykotic :: same :)
07:15:06 <Philippa> is it as easy to nail yourself for performance with undocumented issues as it was on PS2?
07:15:06 <Neil|Work> Philippa :: there aren't any Sony employees in here are there?
07:15:10 <matthew-_> ToRA: yeah, the problem is that it's only when it comes out via TH that it goes wrong. If I pprint it and then paste it back in then it works.
07:15:34 <ToRA> TH compiling it too soon?
07:15:47 <psykotic> the ps3 docs aren't too bad compared to the 360's (though they are worse) but the tools are horrid
07:16:18 <Neil|Work> psykotic :: I was watching out for NDA violations
07:16:21 <Neil|Work> but now you've done it...
07:16:32 <Philippa> figures. Double my productivity and I'd probably have a lot of fun developing tools, but hey
07:16:34 <matthew-_> ToRA: No, that doesn't look like it to me.
07:16:43 <Philippa> Neil|Work: ouch, it's one of those NDAs?
07:16:44 <Neil|Work> docs: managable, tools: well, not great, libraries: DEAR GOD
07:16:52 <Neil|Work> Philippa :: Sony are pretty court-happy at the moment
07:17:27 <qebab> pff, NDAs
07:17:30 <psykotic> saying that the ps3 tools are horrid isn't actionable based on the nda i signed. the tools suck. did you hear that, kutaragi?:)
07:17:59 <psykotic> they're better than the ps2 tools but that's about as vacuous a claim as you can make :)
07:18:07 <Philippa> *snigger*
07:18:19 <Philippa> I never did do much with the PS2 linux kit, I gather I wasn't missing /that/ much compared to the devkits?
07:18:27 <psykotic> no
07:18:37 <ToRA> Neil / psykotic - can i ask who you guys work for?
07:18:51 <Philippa> did they ever get the debugging hardware they were talking about at the first european GDC out to everyone?
07:19:21 <psykotic> Philippa, did you ever hear the story about why they released the linux kit?
07:19:34 <psykotic> it was because they wanted to have the ps2 be classified as a computer (rather than a mere game console) for tax reasons
07:19:45 <Philippa> yeah, YABASIC wasn't enough
07:20:05 <matthew-_> ToRA: mmm. the output of -ddump-simpl is utterly different depending on the two different routes. Via TH it goes {__ccall_GC installer_myInstallerFunc_first ... The other route (pprint and paste) looks like GHC.Ptr.Ptr @ Foreign.C.Types.CUChar __label "installer_myInstallerFunc_first". So TH is assuming it's a function call, but it's not - it's just a constant at a symbol.
07:20:19 <Philippa> I did lend my PS2 to my housemate for a while, she didn't get round to doing much with it though - ended up playing with her zaurus instead when she got that
07:21:31 <chrismbrown> :q
07:21:34 <ToRA> is the th code in the same module as the the foreign decl?
07:23:27 <matthew-_> ToRA: the TH code *generates* the foreign decl
07:24:00 <ToRA> oooh
07:24:06 <ToRA> your head must hurt
07:24:16 <Spark> are you people at college?
07:24:25 <Spark> i was supposed to receive a dishwasher today
07:24:26 <Neil|Work> psykotic :: I'm not registered so I can't msg you back
07:24:36 <Spark> but currysonline didn't have a flat number
07:24:42 <Spark> and i didn't get to my phone in time
07:24:42 <Spark> so they drove off
07:24:49 <Spark> now i have to spend even more days at home
07:24:50 <Neil|Work> psykotic :: still at Lionhead - they bought us last year, so I'm now technically an MS employee
07:25:01 <Neil|Work> but things haven't really changed for all intents and purposes
07:25:17 <OCCASVS> Neil|Work, Fable II? :D
07:25:27 <Neil|Work> OCCASVS :: amongst other things :)
07:25:30 <Neil|Work> [15:16] <Philippa> I never did do much with the PS2 linux kit, I gather I wasn't missing /that/ much compared to the devkits?
07:25:53 <Neil|Work> Philippa :: missing the IO and DSP stuff, but the main thing is that there's no remote execution
07:26:06 <Neil|Work> the machines are so damned buggy - if you mess up a DMA operation the entire machine will just lock up
07:26:12 <Neil|Work> which means a reboot of the linux environment
07:26:17 <Neil|Work> which means a whole fsck and suchlike
07:27:09 <Neil|Work> [15:17] <ToRA> Neil / psykotic - can i ask who you guys work for? <-- see above
07:34:53 <Philippa> Neil|Work: you don't have to fsck much if you run your test apps straight off a memory card
07:35:09 <Neil|Work> I guess, but it's still a pain
07:35:09 <Philippa> I forget whether there were valid USB drivers? If so, a read-only filesystem'd work too
07:35:15 <Philippa> yep
07:35:24 <Neil|Work> the round trip time from crash to getting it into a state where you can debug is the biggest killer
07:35:28 <Neil|Work> no, no usb iirc
07:35:38 <Neil|Work> everything like that was accessed through objects in /dev, same as a linux system
07:35:46 <Neil|Work> even the sound chip was only /dev/dsp
07:36:27 <Neil|Work> still, it's worth progressing with
07:36:44 <Neil|Work> if you can build a game on the PS2, then you've pretty much got console dev cracked
07:37:27 <psykotic> Neil|Work, "only dev/dsp" - for non-block devices the dev devices are just handles, all the action is through ioctl, so it's not really a limitation :)
07:38:08 <psykotic> now get back to work and finish fable 2 :)
07:39:08 <Neil|Work> heh, I'm slacking
07:39:17 <Neil|Work> in the process of updating dev tools = lots of downtime
07:39:22 <Neil|Work> psykotic :: what are you doing these days?
07:39:31 <Neil|Work> back at Epic or...?
07:39:33 <psykotic> in korea
07:39:39 <Neil|Work> wasn't expecting that
07:39:42 <Neil|Work> NCSoft?
07:39:53 <psykotic> no, other company you probably haven't heard of. :)
07:39:57 <Neil|Work> try me
07:39:59 <OCCASVS> Are you all games devs? :D
07:40:00 <psykotic> webzen
07:40:08 <Neil|Work> I know Webzen
07:40:20 <Neil|Work> they're doing Huxley right?
07:40:29 <psykotic> right, that's what i'm working on. (they have other games)
07:40:36 <Neil|Work> neato
07:40:39 <psykotic> i'm the ue3 hired gun
07:40:39 <Neil|Work> release date please
07:40:43 * Neil|Work runs away
07:40:47 <psykotic> hehe i'd like to know that too :)
07:41:06 <Neil|Work> I know that feeling
07:41:24 <Neil|Work> right, I'd better stop hijacking the channel for personal discussions before someone kickbans me
07:41:37 <Neil|Work> psykotic :: I can't msg you because of the registration restrictions on this network
07:44:10 <Philippa> Neil|Work: better register?
07:44:23 <Neil|Work> depends on whether I decide to stay here or not :)
07:44:50 <Neil|Work> (or whether people find me too irritating and I get booted)
07:45:02 <Philippa> you're unlikely to get booted
07:45:15 <Philippa> you might get pointed at #haskell-blah if you get a bit off-topic at some point though
07:45:16 <Neil|Work> I dunno, when I joined there was a lot of Haskell-related conversation
07:45:18 <Neil|Work> and now it's dead ;)
07:46:52 <Philippa> it comes and goes. General development stuff is normally on-topic so long as it's not turning into an FP vs competitors trollfest
07:47:21 <Neil|Work> I have QNet #c++ for that
07:47:33 <Neil|Work> always fun when you suggest to people that c++ might not be the best language for the task
07:47:34 <malcolmw> and when  we want to get real work done, we head over to #haskell-overflow :-)
07:48:05 <Neil|Work> guess I'll register then ;)
07:50:36 * matthew-_ gets fed up with ffi and TH
07:51:27 <LeCamarade> Umm ... nobody knows of a POP lib?
07:51:40 <shapr> LeCamarade: It's in HaskellNet
07:52:04 <LeCamarade> @where haskellnet
07:52:05 <lambdabot> I know nothing about haskellnet.
07:52:17 <LeCamarade> @go haskellnet
07:52:20 <lambdabot> http://darcs.haskell.org/SoC/haskellnet/
07:52:21 <lambdabot> Title: Index of /SoC/haskellnet
07:52:26 <Carmethene> Philippa :: all done
07:56:33 <thartman> ?lambdabot
07:56:33 <lambdabot> Unknown command, try @list
07:56:36 <thartman> @list
07:56:37 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
07:57:00 <thartman> help
07:57:11 <thartman> ?help
07:57:12 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:57:59 <thartman> arr, how do I get the bot to to execute code?
07:58:15 <thartman> > 1
07:58:18 <lambdabot>  1
07:58:20 <LeCamarade> > 1 + 3
07:58:33 <lambdabot>  4
07:58:35 <thartman> right, right.
07:58:38 <thartman> > do xv <- (Left "x"); return xv
07:58:44 <LeCamarade> > let howl x = x ++ x in howl "Yay!"
07:58:51 <lambdabot>  Left "x"
07:58:58 <thartman> > do xv <- (Right "x"); return xv
07:59:04 <int-e> @run fix ((1:) . scanl (+) 1)
07:59:09 <lambdabot>  Add a type signature
07:59:15 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
07:59:31 * mux rewrites some piece of code that deals with many functions returning a Maybe type using the Maybe monad and splits code size by two, gaining in elegance at the same time
07:59:32 <thartman> > ( do xv <- (Right "x"); return xv ) :: Either String
07:59:43 <lambdabot>      `Either String' is not applied to enough type arguments
07:59:43 <lambdabot>     Expected kin...
07:59:44 * mux hearts the Maybe monad
07:59:53 <chessguy_work> > do xv <- (Right "x" :: Either String String); return xv
08:00:12 <thartman> oh, ok.
08:00:21 <chessguy_work> mm, bot's laggy today
08:00:42 <chessguy_work> @bot
08:00:42 <lambdabot> :)
08:00:51 <chessguy_work> err
08:00:57 <chessguy_work> maybe it doesn't like me
08:01:05 <ToRA>  > do xv <- (Right "x" :: Either String String); return xv
08:01:14 <ToRA> > do xv <- (Right "x" :: Either String String); return xv
08:01:24 <lambdabot>  Right "x"
08:01:24 <chessguy_work> > do xv <- (Right "x"); return xv :: Either String String
08:01:39 <lambdabot>  Right "x"
08:02:02 <chessguy_work> @slap lambdabot
08:02:03 <lambdabot> why on earth would I slap lambdabot
08:02:24 <chessguy> @slap lambdabot
08:02:25 * lambdabot slaps lambdabot
08:02:59 <dan_> yo
08:04:15 <thartman> did you hear about the guy who prototyped an AI system in haskell, then tried to finish it in java?
08:04:19 <thartman> http://www.goertzel.org/benzine/WakingUpFromTheEconomyOfDreams.htm
08:04:22 <lambdabot> Title: Waking Up from the Economy of Dreams, http://tinyurl.com/35h8ud
08:04:30 <chessguy_work> wtf
08:04:46 <thartman> actually it's not that funny ;)
08:04:48 <chessguy_work> hm, why does that name sound so familiar
08:05:00 <thartman> reddit?
08:05:13 <chessguy_work> don't read it much
08:05:58 <chessguy_work> ohhhh, Novamente
08:06:47 <chessguy_work> they started in haskell?
08:06:56 <thartman> that's what the article says.
08:07:07 <chessguy_work> "I built a prototype psynet-model-based AI in 1994, in an obscure, beautiful and fantastically inefficient programming language called Haskell, but just about all it did was make the computer run out of memory. "
08:07:07 <chessguy_work> haha
08:07:30 <ToRA> > let nextVar = (get >>= (\(x:xs) -> put xs >> return x)) in runState (mapM (maybe nextVar (return . show)) [Just 1, Just 2, Nothing, Just 3, Nothing, Just 4, Nothing]) ["a","b","c"]
08:07:35 * ToRA hugs state monad
08:08:10 <ToRA> mmm
08:08:56 <LeCamarade> @tell goertzel Did you write this: http://tinyurl.com/35h8ud  ?
08:08:57 <lambdabot> Consider it noted.
08:11:46 <ToRA> anyone know why lb would be returning Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString to eval privmsgs?
08:11:56 <matthew-_> mmm. so the solution turned out to be: seeing as I can't make TH generate the right code, instead use TH to adjust the C header file so that that matches the haskell code TH is going to generate...
08:12:03 <chessguy_work> ?seen goertzel
08:12:04 <lambdabot> I haven't seen goertzel.
08:12:15 <yip> what was haskell like in 1994?
08:12:29 <yip> wasn't the first haskell system developed in 1992?
08:13:30 <ToRA> matthew-_ : what does your compile time drop to now?
08:14:11 <earthy> yip: look at gofer
08:14:25 <earthy> that'll give you a taste for haskell in the early nineties
08:14:26 <Saizan> you should report a bug maybe
08:14:34 <joelr1> good day
08:14:37 <joelr1> dons: ping
08:15:05 <kuribas> Are there haskell libraries for logic programming?  For example like kanren in scheme?
08:16:09 <Lor> Like this? http://citeseer.ist.psu.edu/spivey99embedding.html
08:16:24 <lambdabot> Title: Embedding PROLOG in HASKELL - Spivey, Seres (ResearchIndex)
08:17:31 <Lor> Oops, I think I meant this one: http://citeseer.ist.psu.edu/claessen00typed.html
08:17:32 <lambdabot> Title: Typed Logical Variables in Haskell - Claessen, Ljungl (ResearchIndex)
08:18:00 <kuribas> Lor: yes, but also with working code, not just a paper.
08:19:15 <Lor> I implemented the typed logical variable system an age or two ago.
08:19:33 <Lor> The paper _contains_ working code. :)
08:20:01 <Lor> Nowadays it can be improved upon quite a deal, since one can use generics or TH to generate unification procedures for data types automatically.
08:20:48 <kuribas> Lor: that sounds interesting.
08:22:04 <kuribas> Maybe it would be a good idea to make a library and put it somewhere for download.
08:23:09 <kuribas> Only 12 page :)
08:24:00 <ndm> Lor: you should integrate that into derive
08:25:20 <Lor> I don't think nowadays there's much need for built-in derive support.
08:28:38 <shapr> Hiya Lor, long time no see.
08:31:01 <Lor> Hi shapr.
08:33:46 <chessguy_work> it's Lor, the evil twin!
08:34:26 <dan_> hey kids
08:34:56 <Lor> At least there's no "dat" here.
08:42:22 <chessguy_work> is David Waern on here?
08:53:02 <tompurnell> i'd like to take two lists and check them for equality of elements regardless of order. surely there is a nice predefined to do this for me?
08:53:37 <tompurnell> at the moment im sorting both lists first, but this seems a little silly to me
08:54:10 <wolverian> are they really sets?
08:55:33 <shapr> dan_: Are you older than me?
08:55:46 <tompurnell> wolverian: no, they're lists, but they're being treated like sets for this particular part of the problem
08:56:12 <dmwit> tompurnell: Then you are using the preferred method.
08:56:29 <dmwit> If they really are sets, then you should put them in a Data.Set, though, it's faster than a list for set operations.
08:56:34 <chessguy_work> tompurnell: laziness will help you
08:57:46 <chessguy_work> ermm, i guess it won't, if you're looking at the whole list
08:57:51 <tompurnell> dmwit: this is part of an assignment, and im required to work with various predefined data structures etc. this is one of them
08:58:15 <dmwit> Ah, okay.
08:58:40 <tompurnell> but i'll be sure to let my lecturer know that the internet disapproves of his list/set confusion
08:58:59 <dmwit> hahaha!
08:59:04 <Saizan> :D
08:59:18 * shapr grins
08:59:26 <shapr> We are the Internet.
08:59:34 <tompurnell> i might tell him that after he's graded me though...
08:59:44 <shapr> chessguy_work: @seen waern
08:59:49 <shapr> @seen waern
08:59:50 <lambdabot> I saw waern leaving #haskell 2h 2m 41s ago, and .
09:00:13 <tompurnell> so, testing my lists for equality regardless of order? i need to sort them still?
09:00:34 <Saizan> you get better complexiity if you sort them
09:00:47 <dmwit> Yeah, and maybe nub them depending on how paranoid you are and what semantics you want.
09:01:25 <chessguy_work> aha
09:01:52 <dozer> hi
09:02:03 <chrismbrown> hi dozer
09:02:16 <dan_> man
09:02:21 <dozer> I'm working through the hxt tutorial on the haskell wiki, and it's mentioned a "rose tree"
09:02:25 <Saizan> ?pl equals xy ys = fromList xs == fromList ys
09:02:25 <lambdabot> equals = const ((fromList xs ==) . fromList)
09:02:26 <tompurnell> ah, well one of my tests is to ensure there are no duplicates, so no nubbing for me
09:02:28 <dozer> can someone point me at where I can find out about these guys?
09:02:29 <dan_> i just understook unificaion
09:02:46 <dan_> doser: trees?
09:02:49 <Saizan> ?docs Data.Tree
09:02:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Tree.html
09:03:04 <dozer> thx
09:03:06 <chessguy_work> @type ((fromList xs ==) . fromList)
09:03:22 <lambdabot> thread killed
09:03:23 <dmwit> ?pl equals xs ys = fromList xs == fromList ys
09:03:23 <lambdabot> equals = (. fromList) . (==) . fromList
09:03:28 <nominolo> > let f [] [] = True; f (x:xs) ys = x `elem` ys && xs `f` (ys `difference` x) in [1,3,5] `f` [5,1,3]
09:03:32 <lambdabot>   Not in scope: `difference'
09:03:34 <dmwit> (You had an "xy" instead of "xs" in there.)
09:03:39 <mdmkolbe-work> is there a version of ($) that takes things of kind #?
09:03:41 <mdmkolbe-work> :t ($)
09:03:42 <dozer> congrats dan_ I keep thinking I understand unification and then discover it's more subtle than I thought :) like highschool chemistry
09:03:51 <nominolo> > let f [] [] = True; f (x:xs) ys = x `elem` ys && xs `f` (ys // [x]) in [1,3,5] `f` [5,1,3]
09:03:52 <mdmkolbe-work> @type ($)
09:03:54 <Saizan> mmh meybe i'm not recalling correctly, a rose tree is when each node can have an arbitrary number of children?
09:03:57 <lambdabot> thread killed
09:03:58 <lambdabot>  Couldn't match expected type `Array i e'
09:04:04 <chessguy_work> @type (. fromList) . (==) . fromList
09:04:08 <mdmkolbe-work> @info ($)
09:04:08 <lambdabot> thread killed
09:04:20 <lambdabot> thread killed
09:04:20 <lambdabot> ($)
09:04:23 * chessguy_work kills lambdabot's threads
09:04:33 <mdmkolbe-work> @type ($)
09:04:35 <nominolo> > let f [] [] = True; f (x:xs) ys = x `elem` ys && xs `f` (ys \\ [x]) in [1,3,5] `f` [5,1,3]
09:04:39 <lambdabot>  True
09:04:49 <lambdabot> thread killed
09:05:00 <nominolo> @type True
09:05:02 <dmwit> Hi #haskell! @type and :t don't work for now. ;-)
09:05:16 <lambdabot> thread killed
09:05:24 <chessguy_work> thanks, we never would've figured that out :)
09:05:44 <nominolo> thanks, inspector dmwit ;)
09:05:51 <dozer> k, got it :) it's a tree with any number of children under each node
09:06:28 <nominolo> > let f [] [] = True; f (x:xs) ys = x `elem` ys && xs `f` (ys \\ [x]) in [1,3,5,5,3] `f` [5,1,3]
09:06:42 <lambdabot>  False
09:07:20 <hpaste>  Haskell pasted "split function" at http://hpaste.org/1533
09:07:55 <nominolo> > let g xs ys = sort (nub xs) == sort (nub ys) in [1,3,5,5,3] `g` [5,1,3]
09:08:48 <nominolo> @botsnack
09:08:49 <lambdabot> :)
09:09:00 <Saizan> > let sortNub xs = map head . group . sort $ xs; g xs ys = sort (nub xs) == sort (nub ys) in [1,3,5,5,3] `g` [5,1,3]
09:09:16 <dmwit> > let uniq = map head . group . sort; g xs ys = uniq xs == uniq ys in [1,3,5,5,3] `g` [5,1,3] -- slightly lest safe
09:10:07 <nominolo> hm, i get no answers from lb here
09:10:18 <dmwit> Yeah, that seems b0rked too. =(
09:10:47 <dmwit> Anyway, using uniq like I did above should be (very slightly) faster than nub, but it needs to special case empty list comparisons.
09:11:10 <tompurnell> meh. i guess i cant use sort because the type doesnt derive Ord?
09:11:26 <dmwit> Oh, really?  Only Eq?
09:11:32 <tompurnell> yes
09:11:37 <dmwit> Have a look at "elem" then.
09:11:46 * tompurnell obeys
09:12:11 <nominolo> hm, is nub = map head . group ?
09:12:20 <Saizan> no
09:12:22 <dmwit> No, nub requires only Eq.
09:12:25 <Saizan> that wouldn't work
09:12:32 <nominolo> and group?
09:12:37 <Saizan> ?src nub
09:12:38 <lambdabot> nub = nubBy (==)
09:12:42 <dmwit> Sorry, I meant nub does not require a sorted list.
09:12:43 <Saizan> ?src nubBy
09:12:44 <lambdabot> nubBy eq []             =  []
09:12:44 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
09:12:46 <int-e> > nub [1,2,3]
09:12:51 <nominolo> @src group
09:12:52 <lambdabot> group = groupBy (==)
09:12:59 <nominolo> @src groupBy
09:12:59 <lambdabot> groupBy _  []       =  []
09:13:00 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
09:13:00 <lambdabot>     where (ys,zs) = span (eq x) xs
09:13:09 <int-e> > (nub [1,2,1], map head (group [1,2,1])) -- different
09:13:30 <nominolo> ah, i thought group would do something different
09:14:06 <int-e> @bot
09:14:06 <lambdabot> :)
09:14:23 <chessguy_work> the bot's really acting weird today
09:15:26 <chessguy_work> hiya ndm
09:15:28 <ndm> @seen kosmikus
09:15:28 <lambdabot> kosmikus is in #gentoo-haskell, #darcs and #haskell. I don't know when kosmikus last spoke.
09:15:41 <ndm> hi chessguy_work
09:15:56 <ndm> kosmikus: how do i format `func`? I couldn't see a %subst for the `...` bit?
09:16:34 <nominolo> > 42
09:16:46 <lambdabot>  42
09:16:51 <nominolo> \o/
09:17:08 <dmwit> > "ping"
09:17:17 <chessguy_work> > 42 :: String -- should be "The answer to life, the universe, and everything"
09:17:59 <chessguy_work> on that note (or lack thereof)...
09:18:07 <ToRA> does anyone know if a combinator (for MonadState) that has the effect of (get >>= (\(x:xs) -> put xs >> return x)) already exists in the std library anywhere?
09:18:44 <ndm> ToRA: no, but i've often wanted it
09:18:53 <dmwit> gets is close
09:18:57 <ndm> ToRA: call it getHead, wrap it up and propose it
09:19:01 <mux> gets head
09:19:11 <ToRA> its not gets head
09:19:23 <dylan> popHead
09:19:23 <mux> oh, right.
09:19:42 <dylan> @pl (get >>= (\(x:xs) -> put xs >> return x))
09:19:43 <ToRA> x <- gets head ; modify tail ; return x
09:19:43 <lambdabot> ap (flip ((>>) . put) . return . head) tail =<< get
09:19:46 <mux> it's gets head with some modify tail too :-)
09:19:47 <nominolo> how about getBy (s -> (a,s)) (m a)
09:19:52 * mux nods at ToRA 
09:20:36 <nominolo> i meant: getBy :: (s -> (a,s)) -> State a
09:21:14 <ToRA> can't you add a MonadState m s requirement and get back to the (m a) return type?
09:22:51 <nominolo> @src State.modify
09:22:51 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
09:24:43 <dylan> @hoogle modify
09:24:44 <lambdabot> Control.Monad.State.modify :: MonadState s m => (s -> s) -> m ()
09:24:45 <lambdabot> Data.IORef.modifyIORef :: IORef a -> (a -> a) -> IO ()
09:24:45 <lambdabot> Data.STRef.modifySTRef :: STRef s a -> (a -> a) -> ST s ()
09:25:00 <dylan> @src Control.Monad.State.modify
09:25:01 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
09:25:09 <nominolo> modify is bad
09:25:27 <dylan> 'tis?
09:25:29 <ToRA> why do you say that?
09:25:35 <ToRA> it's very useful !
09:25:57 <nominolo> because being able to say which value to return would be more general
09:26:06 <therp> nominolo: hi, you have been searching for me a couple of days ago?
09:26:12 <nominolo> yes
09:26:32 <nominolo> therp: i was wondering if you have a parser from haskell to your lisp-notation
09:26:39 <nominolo> therp: preferably in emacs lisp
09:26:53 <nominolo> therp: would be handy for shim
09:27:13 <nominolo> therp: or structural editing extensions of shim
09:28:33 <therp> nominolo: no, I'm afraid. I'm at the moment working on porting liskell back to ghc (6.6.1) actually finished today. also on my list is: turing Haskell Syntax Trees into Liskell Parse Trees (just the opposite of Liskell parsing). This could be used easily for Haskell Syntax->Liskell conversion. but that's not about emacs lisp at all. It would be embedded in GHC
09:29:06 <nominolo> wrt. to modify:  i'd propose: modifyBy f = do s <- get; (a,s') = f s; put s'; return a
09:29:06 <therp> s/turing/turning/
09:29:20 <nominolo> and modify f = modifyBy (snd . f)
09:29:56 <nominolo> therp: k
09:30:02 <therp> this 6.6.1 backport really took me too long (partially attributed to GHC recompile times).. I will order a dual core processor for compiling GHC I guess..
09:30:34 <nominolo> therp: even with -O0 ?
09:30:44 <therp> nominolo: I also plan to hack a bit of shim to aid Liskell development. at the moment, it's just a raw mixture of slime (for syntax/structural editing) with haskell-mode
09:31:20 <therp> nominolo: even then, it's not that fast..
09:31:55 <nominolo> therp: well, as i told you earlier, i'm not such a big fan of changing the complete language's syntax (even if isomorphic) .. but maybe there's good stuff for either "camp"
09:31:59 <therp> the problem is, when doing stuff like changing the wired-in packages, you basically have to purge everything and start from scratch with the build
09:32:27 <nomeata> Help. I spen almost a week of my free time to convert a rather large haskell program to ByteString.
09:32:33 <nomeata> And now, at a certain point, it hangs.
09:32:44 <ToRA> nominolo: modifyBy (head &&& tail) - i quite like that
09:33:11 <nomeata> It sould be assembling a ByteString.Lazy instead... And I used basically the same code as before, just not with [Char]
09:33:44 <nominolo> ToRA: me too :)
09:34:20 <nominolo> although my definition of modify in terms of modifyBy is wrong
09:34:37 <therp> nominolo: as with my taste for music, food, and women, I do not try to persuade people that my opinion about programming languages is one that works for everyone. I'm just certain it works for me.
09:36:06 <nominolo> therp: i'm fine with that :)  i don't do either
09:36:56 <Saizan> with languages it's a little more complicated since they are used for communication
09:37:29 <nomeata> Is it normal that strace on a haskell programm gives a lot of these:
09:37:31 <nomeata> [pid 13717] rt_sigprocmask(SIG_BLOCK, [INT QUIT], [], 8) = 0
09:37:31 <nomeata> [pid 13717] rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
09:38:08 <nominolo> therp: in programming languages you might be aware though that having a wider community might be of advantage to you, also
09:39:14 <monochrom> music is also used for communication
09:39:54 <therp> nominolo: well, at the moment Liskell is still compatible with any haskell lib out there. I really try hard to keep that property
09:39:57 <tompurnell> thankyou everyone for your assorted comments (some of which were even helpful). I have finished my excuse for an assignment at 2:37am the day it is due, and i couldnt have done it without the pointers ive received over the past 24 hours in here.
09:41:04 <tompurnell> @yow
09:41:05 <lambdabot> Okay ... I'm going home to write the "I HATE RUBIK's CUBE HANDBOOK FOR
09:41:05 <lambdabot> DEAD CAT LOVERS" ...
09:41:17 <therp> saizan: my world domination plans do not include other people, (at least not on programming language level) so communication is not necessary =)
09:41:35 <Carmethene> nothing wrong with Rubik's cubes
09:41:38 <tompurnell> therp: how will people know that you have dominated the world if you don't tell them?
09:41:59 <monochrom> they do not need to know
09:42:16 <tompurnell> no women will be impressed by someone dominating the world and not advertising the fact
09:42:19 <therp> these are two good points.
09:42:20 <monochrom> and for that matter, they won't know if they'll be dead.
09:42:22 <therp> err three.
09:42:43 <tompurnell> if you killed everyone off, what would be the point in dominating the world?
09:42:50 <monochrom> probably he has other ways of impressing women
09:43:09 <tompurnell> monochrom: perhaps, but why else conquer the world?
09:43:32 <tompurnell> c.v filler material? excessive quantities of spare time?
09:43:41 <monochrom> there doesn't need to be a why
09:44:15 <monochrom> (besides, why impress women?  *duck*)
09:44:42 <therp> "We do it because we can."
09:44:42 <dylan> my fiance is more impressed by my comically insane behavior than my accomplishments with programming.
09:44:48 <therp> that's also my reason for using haskell.
09:45:01 <tompurnell> because encounters with the opposite sex tend to be more enjoyable for all involved when they're voluntary?
09:45:03 <dylan> *fiancee
09:45:11 <dylan> darn english words pronounced the same.
09:46:11 <tompurnell> well, if any of you dominate the world while im asleep, please push back my assignment due date, or at least the closing time of the submissions desk. thanks
09:46:42 <ddarius> dylan: That's a french word
09:47:28 <dylan> ddarius: yes, in american english both words are the same sound.
09:47:40 <dylan> at least according to my somewhat old paper dictionary.
09:48:37 <ddarius> Yes they are.  And, I'm willing to bet the majority of the American populace doesn't know the difference.
09:48:50 <dylan> I think in text, so..
09:48:55 <therp> I'm sure the "probability for world domination" -- despite being infinitesimally small -- is statistical significantly higher than for the rest of FreeNode.
09:49:09 <therp> I'm sure the "probability for world domination" -- despite being infinitesimally small -- is statistical significantly higher for someone from #haskell than for the rest of FreeNode.
09:49:39 <glen_quagmire> ghci doesn't have tab completion?
09:49:46 <dylan> ghci 6.6 does
09:49:53 <dylan> at least.
09:50:03 <monochrom> yah
09:50:11 <ddarius> therp: Except for lambdabot, whose probability of dominating the world is actually quite high.
09:50:29 <nomeata> Hmpf. Wrote isJust when I meant isNothing, writing a nice recursive loop
09:50:40 <monochrom> ha ha
09:50:42 <glen_quagmire> on windows too?
09:50:56 <monochrom> darn, haven't tried windows
09:51:00 <ddarius> GHCi uses readline is my understanding.
09:51:05 <Carmethene> glen_quagmire :: doesn't work for me
09:51:07 <glen_quagmire> i'm using 6.6 on windows
09:51:10 <Carmethene> same
09:51:27 <monochrom> odd
09:51:28 <glen_quagmire> can i save what i've done in ghci to a file?
09:51:36 <monochrom> Sorry, no.
09:51:53 <Carmethene> I'm quite taken with Visual Haskell
09:52:05 <Carmethene> just wish I could make the damned thing work on Vista :/
09:52:14 <glen_quagmire> GHCi now allows tab completion of in-scope names and modules on platforms that use readline (i.e. not Windows).
09:52:38 <monochrom> Oh, not using readline on windows, no wonder.
09:54:31 <hpaste>  pt pasted "BString string substitution.. more efficient way?" at http://hpaste.org/1534
10:02:51 <glen_quagmire> what do you use to edit haskell source ?
10:02:51 <glen_quagmire> emacs?
10:02:51 <emu> ya
10:02:55 <glen_quagmire> does it have tab completion or sorts?
10:03:09 <emu> yep
10:03:12 <ddarius> pt: Obviously you could write a one-pass algorithm.
10:03:13 <glen_quagmire> i mean, like in IDE, you get list of members...module variables..etc
10:03:24 <glen_quagmire> ok time to learn emacs then
10:03:54 <emu> glen_quagmire: haskell doesn't have OO things in it
10:04:19 <glen_quagmire> is it worth learning emacs for haskell?
10:04:45 <emu> emacs offers a number of completion mechanisms.  there is always the dabbrev shortcut M-/ which tries to operate in all buffers
10:04:52 <emu> glen_quagmire: what are you using now?
10:04:55 <glen_quagmire> vim
10:05:00 <emu> you're fine with that too
10:05:30 <glen_quagmire> ok thanks
10:05:31 <emu> what emacs haskell-mode offers over vim is: a form of automatic indentation, integration with a running ghci terminal
10:05:53 <emu> shim will be superior when it's finished, but presumably a shim-vim plugin will be written too
10:06:05 <Nafai> http://www.osnews.com/permalink.php?news_id=17744&comment_id=233100
10:06:07 <lambdabot> Title: OSNews.com, http://tinyurl.com/2bjpb8
10:06:16 <dylan> shim-vim, hehe
10:07:46 <emu> glen_quagmire: typically people set softtabstop to 2 or 4, eliminate tab chars, and just use plain old indentation
10:07:46 <emu> set expandtab i think
10:07:49 <glen_quagmire> yup
10:08:19 <glen_quagmire> but i was wondering if emacs is 'better' than vim...well maybe this is flame war
10:08:46 <glen_quagmire> i'll use ghci + readline copy paste
10:08:48 <dmwit> Nah, just :set ai and you'll have 90% of emacs' indent functionality.
10:10:10 <dylan>  set expandtab for *.hs, *.lhs too
10:10:39 <emu> eh, emacs has a smarter indent than that
10:10:40 <dmwit> :set expandtab for * ;-)
10:10:42 <DRMacIver> Hm. It would be nice to have some sort of type directed tab completion for Haskell. Not totally sure how it would work though.
10:10:46 <dylan> a vim indent plugin shouldn't be hard
10:10:52 <emu> the real advantage is not having to run ghci in a separate terminal
10:11:02 <monochrom> context-sensitive completion is always nice.
10:11:30 <emu> you can hit a keystroke to load/compile your file, check types of symbols, get info, jump to locations etc
10:11:31 <monochrom> the ideal is the program writes itself
10:11:59 <DRMacIver> Not as big a deal as in an overly verbose language, granted, so it might be more trouble than it's worth, but still nice.
10:12:12 <nominolo> @where logs
10:12:18 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
10:12:28 <DRMacIver> monochrom: I disagree. I think "The program makes it as easy as possible for me to write it" is significantly better than "The program writes itself" :)
10:12:47 <emu> i muck around in the ghci toplevel so much its just so helpful
10:13:39 <Carmethene> [18:01] <glen_quagmire> what do you use to edit haskell source ? <-- Visual Studio \o/
10:17:34 <ptolomy> hmm.. a naive one-pass (single findSubString, append per pass) is a heck of a lot slower than the code at http://www.hpaste.org/1534
10:18:53 <ariks> how do i make a class derivable? i figured all i would have to do was give a default implementation for a function..
10:19:17 <ibid> derivability is compiler magic
10:19:20 <dmwit> ariks: There is no way in general.
10:19:28 <ibid> unfortunately
10:19:54 <Lor> That's why we have SYB and generics and whatnot.
10:20:18 <Saizan> there's a fairly new package "derive" that is very handy to have automatic derivation for custom classes
10:20:27 <Saizan> it uses TH as a backend
10:20:34 <Saizan> ?where derive
10:20:35 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/derive
10:20:48 <Saizan> not released yet
10:22:13 <ndm> ariks: derive is what you want, we hope to release within a week
10:22:28 <ndm> i think we are only held up on an XmlContent instance
10:22:34 <ndm> perhaps Infix show, but not sure about that
10:22:44 <Lor> A most confusing name, since DrIFT was originally called Derive.
10:22:56 <ndm> yes, but we didn't know that until after picking a name :)
10:23:30 <DRMacIver> People might be interested in the new google tech talk: http://video.google.com/videoplay?docid=-4851250372422374791&q=parametric+polymorphism+google&hl=en
10:23:33 <lambdabot> Title: Advanced Topics in Programming Languages Series: Parametric Polymorphism - Googl ..., http://tinyurl.com/yogdsq
10:23:42 <Lor> ndm, you're not afraid of this? :) http://www.dcs.gla.ac.uk/~nww/Derive/History.html
10:23:45 <lambdabot> Title: DrIFT / Derive
10:23:50 <DRMacIver> (Experienced Haskell programmers probably will find it a bit basic)
10:24:51 <ndm> Lor: the product has since gone out of production, so there is less likely to be anyone around to do anything about it
10:25:02 <ndm> Lor: deriving is the next name on the list if we do need to though
10:25:37 <malcolmw> ndm: since it hasn't been released yet, you could still change the name.  How about deriveth?
10:25:53 <ariks> thanks. yeah derive looks like what i would want.
10:26:54 <ariks> syb looks interesting.. could it offer a solution to writing boring boilerplate record accessors?
10:27:32 <malcolmw> named field accessors already exist in Haskell
10:27:38 <Lor> Deriveth sounds really cool.
10:28:03 <ariks> malcolmw: but i cant use names across different types..
10:28:17 <Lor> It's archaic and has allusions to both TH and DrIFT.
10:28:24 <ndm> malcolmw: i don't think its necessary, given derive has gone out of business
10:28:26 <magnus_> I was thinking about views and it struck me that in logic programming views are not needed
10:28:37 <ndm> but deriveth is a good backup :)
10:28:53 <Lor> Googlability is important in a name.
10:28:59 <malcolmw> ndm: the potential confusion with an old version of DrIFT is still there though
10:29:04 <ndm> yeah, i guess
10:29:10 <ndm> will email stefan and see what he thinks
10:29:54 <ndm> googlability and drift confusion are both reasons to change
10:30:03 <ndm> and deriveth is quite cool
10:30:13 <ndm> anyway, bye!
10:35:33 <Syzygy-> Bwahahahaha
10:35:37 <kolmodin> @tell waern shit va beroenden du har till haste2! :D så mycket, att FilePath är med två gånger. det är inte illa
10:35:37 <Syzygy-> http://graverobbers.blogspot.com/2007/04/two-cores-walk-into-bar.html
10:35:38 <lambdabot> Consider it noted.
10:35:41 <lambdabot> Title: Grave Robbers From Outer Space: two cores walk into a bar, http://tinyurl.com/ypoeue
10:36:43 <shapr> kolmodin: Jo, FilePath är skitbra
10:37:00 <kolmodin> shapr: :)
10:37:13 <kolmodin> shapr: så bra att man kan ha med den flera gånger i dependency-listan :D
10:37:18 <kolmodin> haha :)
10:37:18 <shapr> haha
10:37:35 <shapr> Har du skickat en patch?
10:37:42 <kolmodin> sitter och skriver på en nu
10:37:49 <shapr> yay
10:37:55 <osfameron> jeg kann inte leser elle scriver!
10:38:03 <osfameron> jeg kann koerer en traktor!
10:38:06 <shapr> osfameron: tyvärr
10:38:11 <shapr> osfameron: That looks like Danish to me.
10:38:20 <osfameron> I think it's "generic scandy"
10:38:24 <osfameron> I was taught it as swedish
10:38:28 <shapr> The real language of Haskellers is Swedish!
10:38:31 <osfameron> but when I tell swedes, they laugh and say it's Danish
10:38:34 <osfameron> and vice versa
10:38:34 <kolmodin> shapr: indeed it is
10:38:36 <shapr> Or maybe lambda calculus ;-)
10:38:44 <osfameron> not Scots?
10:38:48 <shapr> oh maybe so!
10:38:55 <andun> osfameron: jeg synes du er flink
10:39:00 <Codex_> How about logic instead.
10:39:04 <magnus_> In fact, Haskell is a proper subset of the Swedish natural language
10:39:19 <osfameron> flink?
10:39:27 <osfameron> I really should have learnt some Swedish
10:39:31 <shapr> me too
10:39:45 <osfameron> Backer Backer bylla, set smorr emellan!
10:39:54 <Syzygy-> shapr: Jag håller helt klart med.
10:39:55 <andun> osfameron: it's norwegian
10:40:46 <osfameron> ah
10:41:36 <osfameron> I spent a little time for work in Helsingborg, and my mum taught me some of the Swedish children rhymes she knows.  I think it's safe to say that whatever rubbish I'm typing isn't proper norwegian or anything else :-)
10:42:15 <osfameron> right, tack so mycket haskellers, I'm off
10:43:55 <kolmodin> Igloo: how's that filepath tarball coming? it was dcoutts who said he'll do it, right?
10:46:13 <DRMacIver> Hm. I don't seem to be able to get Djinn to work. Am I right in thinking that something like "foo ? a -> a" should display the identity function?
10:52:32 <chessguy> @djinn a -> Bool
10:52:33 <lambdabot> f _ = False
10:54:12 <magnus_> Hmm, I feel very productive in xmonad -- having things full screen helps concentration
10:54:19 <petekaz> newbie question: I'm trying to work on some suggestions to my spell check post on cafe, one of which is using a trie.  My question, in my trie data type, is it better to have 3 constructors?  one for a leaf, one for an inner node that does NOT have a have a value associated with it, and one for an inner node that does have a value with it?  OR should I stick with two constructors, but use a Maybe for the value associated with an inner
10:54:20 <petekaz> node?
10:54:42 <bos> petekaz: what are you trying to do with your code?
10:55:00 <petekaz> replace a Map with a Trie.
10:55:21 <bos> that's not what i mean. what is your goal?
10:55:30 <bos> do you want it faster, shorter, ... ?
10:56:18 <petekaz> Just load up about 200,000 words into this trie all at once, then query the trie which will hold the frequencies of the words that appeared in the original corpus.
10:56:31 <bos> because if you're trying to affect performance, i don't think changing the frequency table will make a difference.
10:57:02 <petekaz> Well, profiling shows that a good portion of time is spent in building the Data.Map.
10:57:15 <petekaz> And someone pointed out that its due to all the string comparisons.
10:57:32 <petekaz> Plus, this is just a learning experience.
10:57:37 <bos> fair enough.
10:57:53 <sjanssen> petekaz: comparisons of Strings or ByteStrings?
10:58:08 <petekaz> After the trie, I want to investigate this dynamic programming suggestion, which admittedly, I still have no idea what they are talking about.
10:58:22 <bos> because my version of the code isn't spending much time in Map construction at all. it's dominated by ByteString loops.
10:58:44 <petekaz> I stopped with ByteStrings cuz it was slower for me.
10:58:53 <magnus_> are you guys implementing the same thing?
10:58:59 <bos> you must have been doing something funny, then.
10:59:09 <bos> magnus_: norvig's spellchecker.
10:59:17 <magnus_> ooh
10:59:47 <bos> however, it seems impossible to create a haskell implementation that is either as fast, as short, or as readable as the python version.
11:00:20 <sjanssen> petekaz: there is a known performance bug with ByteString's Ord instance
11:00:21 <petekaz> It does appear that way.
11:00:23 <magnus_> he uses a hashtable right?
11:00:42 <Igloo> kolmodin: No idea. I'll probably try to do tagging and tarballs of everything once 6.6.1 is done
11:00:50 <sjanssen> it calls the C function memcmp, which turns out to be slower for medium sized strings
11:01:04 <bos> he uses sets, which are implemented using hashtables.
11:01:27 <kuribas> petekaz: you could try IORefs, or a hashtable?
11:01:56 <bos> trying to use Data.Set in haskell makes things way slower and more bloaty. using lists, the performance problem moves into lower-casing ByteStrings.
11:01:59 <petekaz> kuribas: I'll try the hashtable too.
11:02:07 <sjanssen> petekaz: I'd write a trie like this: data Trie a = T (Maybe a) (Map Char (Trie a))
11:02:31 <kolmodin> Igloo: ok. but as it's released as 1.0 I was hoping we'd see a tarball too. apparently cabal is broken on windows so ndm can't do it
11:02:39 <sjanssen> bos: is your latest code in a mailing list post?
11:02:49 <bos> http://darcs.serpentine.com/spell
11:02:51 <lambdabot> Title: Index of /spell
11:03:01 <petekaz> sjanssen: so you wouldn't make a separate constructor for the leaf?
11:03:20 <sjanssen> petekaz: nah, I'd just use an empty Map
11:03:23 <bos> the darcs repo contains a record of every performance trick i've tried.
11:03:32 <chessguy> fantastic google lecture on parametric polymorphism pointed out in Wadler's blog (http://wadler.blogspot.com/2007/04/google-tech-talk-parametric.html)
11:03:35 <petekaz> sjanssen: can you pattern match against an empty Map?
11:03:42 <bos> no.
11:03:43 <ohmega> does xmonad support tags like dwm yet?
11:03:50 <sjanssen> ohmega: no
11:03:58 <chessguy> ?hoogle Map a -> Bool
11:03:59 <lambdabot> No matches, try a more general search
11:04:01 <sjanssen> ohmega: it may never support tags, we're undecided
11:04:06 <bos> the internals of Map are abstract; we'd need views or active patterns to pattern match on them.
11:04:14 <chessguy> ?hoogle Map a b -> Bool
11:04:15 <lambdabot> Data.Map.null :: Map k a -> Bool
11:04:15 <lambdabot> Data.Map.valid :: Ord k => Map k a -> Bool
11:04:15 <lambdabot> Data.Map.member :: Ord k => k -> Map k a -> Bool
11:04:21 <sjanssen> petekaz: why do you need to pattern match against it?
11:04:27 <ohmega> hm
11:05:29 <petekaz> sjanssen: I don't know, but every time I see a Tree implementation, they have Leaf and Branch constructors.
11:05:32 <sjanssen> ohmega: tags conflict with some other user interface decisions we've made -- namely per workspace layouts and xinerama support
11:06:13 <ohmega> i see
11:06:36 <petekaz> I thought the constructor would make it easier to code the implementation.  I haven't thought that far in advance yet and I'm a haskell newbie so its likely I have no idea what I'm talking about.
11:07:49 <bos> petekaz: it's a good exercise to implement your own collection structure, for sure.
11:07:54 <ohmega> i think tags is what makes dwm useful with it's current managing model
11:11:09 <caust1c> hi :)
11:12:55 <rictic> I'm looking to write an IntSet that's optimized for fast insertion and lookup that's as memory efficient as possible.  Any advice for someone without much experience in purely functional data structures?
11:14:15 <Saizan> ?docs
11:14:16 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
11:14:31 <petekaz> bos: I'll try using a HashTable first, then try the trie (just for learning).
11:15:45 <Saizan> rictic: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-IntSet.html <-- there's one in base, you could check the source,  there are also link to papers in this doc
11:15:49 <lambdabot> http://tinyurl.com/wqcbn
11:16:36 <rictic> Saizan: Yeah, that implementation there doesn't look like it matches my use too well.
11:16:47 <rictic> (from some initial benchmarks)
11:20:46 <dolio> petekaz: I reworked your code to use tries, and it's somewhat faster for querying, though not for building.
11:21:29 <dolio> petekaz: Just building the trie/map takes longer than the entire python program, though.
11:22:02 <petekaz> dolio: I guess my effort to find a better haskell implemention is a waste.
11:22:26 <petekaz> dolio: out of curiousity, how did you define your trie?
11:22:30 <dolio> I used 'data Trie a = Nil | Branch (Maybe a) (IntMap (Trie a))', for reference.
11:23:19 <chessguy_work> ?hoogle IntMap
11:23:20 <lambdabot> Data.IntMap :: module
11:23:20 <lambdabot> Data.IntMap.IntMap :: data IntMap a
11:23:40 <chessguy_work> what's an IntMap? is that like Map Int a?
11:23:54 <dolio> Yeah. But it's more efficient.
11:24:01 <petekaz> I'm confused, don't I need to store the Char at each node in the tree?
11:24:06 <chessguy_work> interesting
11:24:23 <dolio> chessguy_work: It's essentially a trie on the bits of an Int, I think.
11:24:40 <Saizan> it is, like IntSet
11:25:18 <dolio> petekaz: The root node of my trie stores the element corresponding to the empty string...
11:25:55 <dolio> petekaz: Then, if you try to lookup a string (c:cs), you lookup (ord c) in the root int map, and then lookup cs in the resulting trie.
11:26:47 <Saizan> a trie^2
11:27:50 <petekaz> For some reason I thought I would have to have the Char in each node.
11:28:33 <petekaz> this was my attempt: data Trie a = Leaf Char a | Branch Char (Maybe a) (Map Char (Trie a))
11:30:33 <dolio> Well, storing the Char at each node of the trie would end up being redundant information, I think.
11:30:54 <dolio> Plus, how do you store something against the empty string with that?
11:31:09 <dolio> There's no Char to put in the root node.
11:31:17 <petekaz> I see.
11:31:33 <dolio> You can have the bottom level be 'Leaf a', though.
11:31:54 <tibbe> is Map the fastest dictionary type in haskell?
11:32:05 <dolio> Since the Map at each level would take care of non-existent subtries.
11:34:13 <augustss> tibbe: IntMap is good if your key is an Int
11:36:12 <tibbe> augustss, ok, it's a ByteString
11:36:33 <tibbe> augustss, I guess we want associated types to get efficient Maps?
11:40:56 <tibbe> how do I get the haddock links to work correctly if I want to put my library in hackage?
11:51:19 <dan_> edit them?
11:52:27 <fantasmaa> what version of Cabal does GHC come bundled with?
11:54:10 <tibbe> dan_, manually?
11:54:14 <int-e> ghc 6.6 comes with Cabal-1.1.6
11:55:46 <shapr> tibbe: I think haddock lets you include other locations with some --option
11:57:02 <petekaz> how do I combine this in one line?
11:57:03 <petekaz> do mv <- lookup w
11:57:03 <petekaz>    let v = fromMaybe 1 mv
11:57:32 <petekaz> of course there are more statements is the do block.
11:57:48 <tibbe> shapr, who can upload the stuff to hackage for me later?
11:58:13 * Nafai bounces
12:01:58 <monochrom> do v <- liftM (fromMaybe 1) (lookup w)
12:02:31 <petekaz> monochrom: thanks.
12:09:49 <koala_man> andun: lol
12:13:07 <kc5tja> Question: is xmonad compilable via GHC 6.4.1 by any chance, or is 6.6 required?
12:13:32 <sjanssen> kc5tja: yes
12:13:33 <dmwit> 6.4 works
12:13:43 <sjanssen> yes 6.4.1 should work, that is
12:14:02 <sjanssen> you'll need to upgrade X11:
12:14:04 <sjanssen> @hackage X11
12:14:05 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/X11
12:14:11 <kc5tja> Sweet.  I'm thinking of replacing ion3 with xmonad on my workstation here at work.
12:14:28 <shapr> tibbe: You can get a userid and upload stuff yourself.
12:14:36 <shapr> kc5tja: I've done so, and I prefer xmonad.
12:18:40 <dylan> I wish xmonad had borders.
12:18:48 <fantasmaa> is anyone aware of any problems with FreeBSD and cabal?
12:19:01 <sjanssen> dylan: it does
12:19:09 <dylan> it does?
12:19:16 <dylan> hm. I'll have to try it again
12:19:24 <magnus_> it does but they don't work on all programs
12:19:28 <sjanssen> yeah, but there was a bug where the borders didn't work for all programs
12:19:31 <magnus_> eg firefox doesn't get a border
12:19:38 <magnus_> but xterms do
12:19:38 <dylan> urxvt doesn't get a border
12:19:38 <sjanssen> that's fixed in the latest darcs
12:19:42 <dylan> which is a problem.
12:19:45 <stepcut> magnus_: there is a patch from yesterday for that
12:19:53 <dylan> maybe it fixes urxvt, too.
12:20:01 <magnus_> stepcut: cool
12:20:03 <stepcut> it fixed kde applications
12:20:29 <stepcut> it may fix everything
12:20:44 <sjanssen> it should
12:22:59 <tibbe> which .cabal fields are required by hackage?
12:23:22 <stepcut> tibbe: if you use the test upload thing, it will tell you
12:25:32 <tibbe> stepcut, great
12:26:59 <Botje> @pl \x -> sequence_ [a x, b x]
12:27:00 <lambdabot> sequence_ . liftM2 (:) a (return . b)
12:28:34 <Botje> :t mapM_
12:28:50 <lambdabot> thread killed
12:28:51 <Botje> oh yeah, broken
12:29:21 <Botje> @pl \x -> mapM_ ($x) [a,b]
12:29:22 <lambdabot> flip mapM_ [a, b] . flip id
12:30:06 <vali> hello, noble creatures
12:30:26 <kuribas> Is there no function for list difference?
12:31:32 <Botje> you mean \\ in Data.List ?
12:32:01 <kuribas> Botje: Ah, I guess so, thanks :)
12:32:12 <Botje> hello, vali
12:33:12 <vali> hmm, i've been reading tutorials for so long. i wonder what i should start coding in order to learn haskell properly
12:33:41 <magnus_> Yeah, xmonad now has borders around firefox too
12:34:16 <magnus_> by the way, is there a way to make it so that when killing xmonad X is not shut down?
12:34:58 <sjanssen> magnus_: that's something you can change in your .xinitrc
12:35:08 <magnus_> aha
12:35:52 <fantasmaa> does GHC compile with X by default?
12:35:53 <sjanssen> mod-shift-ctrl-q if you simply want to restart xmonad (it must be in your PATH)
12:36:09 <sjanssen> fantasmaa: what version of ghc?
12:36:17 <fantasmaa> sjanssen: 6.6
12:36:56 <sjanssen> X11 was an extralib for ghc, so it depends on the packaging for your OS
12:37:06 <magnus_> sjanssen: I couldn't reinstall it on top of the old installation while the old installation was still running
12:37:22 <magnus_> something about files being buzy
12:37:26 <sjanssen> magnus_: yeah, Cabal bug.  You have to rm the old binary first
12:37:29 <dylan> magnus_: probably need cp -f
12:37:32 <fantasmaa> sjanssen: does GHC need to be compiled with X in order to build X11 bindings?
12:37:42 <magnus_> I see
12:37:44 <dylan> or what sjanssen said. n/m
12:38:03 <sjanssen> fantasmaa: no
12:39:32 <shapr> stepcut: Hey, do you have any pure Haskell daemonize code? Something that can be thrown into cron and will once a minute try to start an app, if that app isn't already running?
12:39:52 <Gwern> I'm a little confused about how to use quickcheck. I came up with some assertions about my code which work fine the repl, but when I try to insert it into me module, it fails. where are quickcheck tests supposed to go/be used for actually testing code when compiled?
12:40:10 <shapr> Hm
12:40:14 <shapr> I was about to answer him :-(
12:40:56 <shapr> Doesn't cabal support a check or test command?
12:41:03 <kc5tja> shapr: I use xmonad at home.  But I compiled it with GHC 6.6.
12:41:08 <kc5tja> That's why I was asking.
12:41:28 <fantasmaa> shapr: are you having problems building xmonad?
12:41:29 <shapr> kc5tja: I haven't tried it with anything other than 6.6, it will be interesting to see if you see any differences.
12:41:43 <shapr> fantasmaa: I haven't tried rebuilding in the last two weeks.
12:41:47 <fantasmaa> ah
12:44:18 <Gwern> I'm a little confused about how to use quickcheck. I came up with some assertions about my code which work fine the repl, but when  I try to insert it into me module, it fails. where are quickcheck tests supposed to go/be used for actually testing code when  compiled?
12:44:27 <sjanssen> shapr: quick!
12:45:02 <sjanssen> fantasmaa: I think your problem is that ld doesn't know where to look for libX11.so
12:45:26 <tibbe> how to check hackage not to use <tt> tags around my "" string
12:45:31 <tibbe> escaping with \ doens't help
12:46:00 <sjanssen> fantasmaa: this is probably a good question for haskell-cafe
12:46:21 <joelr1> good evening
12:48:04 <joelr1> dons: ping
12:50:18 <tibbe> grrr, why does hackage mangle my strings?
12:50:27 <tibbe> is its behaviour documented somewhere?
12:50:49 <sjanssen> fantasmaa: one hackish solution would be to make a symlink to libX11.so in /usr/lib/
12:51:28 <joelr1> @tell ndm nice post!
12:51:28 <lambdabot> Consider it noted.
12:51:41 <SamB_XP> Gwern: you write them as functions
12:51:49 <SamB_XP> with names
12:52:07 <bos> @hoogle seq
12:52:08 <lambdabot> Prelude.seq :: a -> b -> b
12:52:08 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
12:52:08 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
12:52:14 <SamB_XP> i.e. global variables
12:52:51 <SamB_XP> sjanssen: is there a libX11.so?
12:53:23 <sjanssen> SamB_XP: there should be
12:53:47 <sjanssen> I imagine fantasmaa isn't attempting to install xmonad without X.org
12:53:52 <SamB_XP> what if there is only libX11.so.7 or whatever?
12:54:14 <sjanssen> oh, this is another possibility
12:54:35 <SamB_XP> and don't you need xlib-dev or whatever it is called for the headers, anyway?
12:55:36 <sjanssen> fantasma's build seems to be failing at the linking stage
12:56:06 <shapr> Gwern: I call my quickcheck tests and HUnit tests from my darcs check-in hook. That way code doesn't get recorded unless it all works. I also run my tests after each change. I think that cabal supports a command, either test or check, that will let you run your tests.
12:56:11 <SamB_XP> well, it might be building with -fasm or something
12:56:14 <shapr> Gwern: How do you want to use your tests?
12:56:33 <Gwern> and call them from where?
12:56:45 <sjanssen> SamB_XP: it almost certainly is, why would this matter?
12:57:02 <SamB_XP> well, I suppose you don't need headers when you build that way
12:57:25 <sjanssen> you always need the headers (the .hsc files require them)
12:57:33 <SamB_XP> ah.
12:58:03 <SamB_XP> okay, I guess your diagnosis was most likely correct then ;-)
12:58:58 <sjanssen> http://hpaste.org/1491 this is the exact log
12:59:31 <magnus_> hmm, my keyboard just stopped working when I used xmonad. That has never happened before for me
12:59:57 <sjanssen> "just stopped working"?
12:59:59 <magnus_> had to restart x
13:00:04 <monochrom> It's hungry and it ate your keyboard
13:00:06 <sjanssen> you didn't turn on numlock, by chance?
13:00:09 <magnus_> nothing I pressed had any effect
13:00:19 <magnus_> I don't think I was near the numlock key
13:01:21 <Gwern> shapr: I was sort of hoping that they'd run everytime I compiled
13:01:44 <matthew-_> Announce: DisTract: distributed bug tracker with the bulk of the code written in Haskell: http://distract.wellquite.org/
13:01:47 <lambdabot> Title: start [DisTract]
13:04:35 <Heffalump> aww, not darcs underneath :-)
13:06:06 <dolio> > let ls@(l:lt) = [] in if L.null ls then Nothing else Just l
13:06:09 <lambdabot>  Couldn't match expected type `LC.ByteString'
13:06:29 <hpaste>  OCCASVS pasted "Exclusive OR" at http://hpaste.org/1535
13:06:29 <dolio> > let ls@(l:lt) = [] in if null ls then Nothing else Just l
13:06:44 <OCCASVS> yes...
13:06:58 <OCCASVS> I've some stupid problems with xor
13:07:13 <OCCASVS> Can anyone help me, please?
13:07:43 <matthew-_> Heffalump: you're very welcome to add a darcs backend, but I've much more experience with monotone, so I used that.
13:07:58 <sjanssen> OCCASVS: in Haskell xor is (/=)
13:08:02 <sjanssen> > True /= False
13:08:06 <OCCASVS> yes, but this is an exercise
13:08:34 <OCCASVS> I have to write the definition of xor using || && and not
13:09:43 <koala_man> do it by truth table
13:11:12 <OCCASVS> koala_man, yes, that is the first solution
13:11:40 <OCCASVS> But the book describes another way to define xor
13:11:50 <OCCASVS> And asks me to find a third way
13:11:52 <Heffalump> matthew-_: how do you make sure that changes will merge well?
13:12:10 <Heffalump> well, how will you do so, since I guess from the webpage they don't at the moment :-)
13:12:23 <OCCASVS> The truth table is used in the first example
13:13:21 <koala_man> then it probably wants you to find the conjunctive form if it was disjunctive before?
13:13:36 <matthew-_> Heffalump: two techniques. Firstly, things like comments all have their own files and I take sufficient care over filename to ensure you won't get a collision.
13:14:21 <matthew-_> Heffalump: For bug fields, each field has its own file. If there's a collision, there /will/ be a nice HTML based summary which will hook into monotone's goodness for dealing sanely with 3-way merges.
13:14:26 <OCCASVS> koala_man, conjunctive and disjunctive are properties of definitions in Haskell, or are they used in Maths?
13:14:50 <Heffalump> cool
13:15:08 <OCCASVS> Sorry for my noobness :S
13:15:18 <Heffalump> (though what if logical changes should conflict, like someone adds a comment "we should think about this" while someone else closes a bug as invalid?)
13:15:27 <matthew-_> The idea is just to present to the user the fact that there are multiple heads for this particular bug, what the heads are and who did them, and then let the user decide. The assumption is that only users that care will actually deal with the merges.
13:15:42 <sioraiocht> OCCASVS: conjuction and disjunction are concepts in maths
13:16:00 <Heffalump> fair enough
13:16:37 <matthew-_> Heffalump: those two things aren't logical conflicts. It's /very/ lightweight: there's very little magic going on with the relationship between different field values and so forth - you can happily comment on a closed bug without reopening it etc etc
13:17:05 <sioraiocht> OCCASVS: they are concepts usually applied specifically in logic and set theory
13:17:30 <OCCASVS> Anyway I've found the solution: ex0r x y = (x && (not y)) || ((not x) && y)
13:17:36 <mwc> OCCASVS, in electronics, one can make any kind of gate from either nand (inverting and) or nor gates. so http://en.wikipedia.org/wiki/NAND_logic
13:17:39 <lambdabot> Title: NAND logic - Wikipedia, the free encyclopedia
13:17:49 <OCCASVS> Thank you :)
13:17:54 <chessguy_work> ?hoogle xor
13:17:57 <lambdabot> Data.Bits.xor :: Bits a => a -> a -> a
13:18:28 <OCCASVS> I must read the Logic chapter of my Maths book
13:18:31 <dolio> > 234 `xor` 581
13:18:36 <lambdabot>  Add a type signature
13:18:40 <OCCASVS> I have never studied it in school :(
13:18:43 <dolio> > 234 `xor` 581 :: Int
13:18:45 <Botje> OCCASVS: why not simply exor x y = x /= y ?
13:18:46 <nominolo> hm is lambdabot's @tell feature considered reliable with the current lambdabot?
13:18:51 <chessguy_work> > True `xor` False
13:19:07 <nominolo> i.e. is lambdabot being rebooted often, atm?
13:19:26 <chessguy_work> nominolo: it's having some issues today, i'm not sure why
13:19:31 <OCCASVS> Botje, because it's an exercise for understanding the logic of the operators in Haskell
13:19:34 <chessguy_work> usually it is reliable
13:19:38 <OCCASVS> That solution is "cheating" :P
13:19:52 <OCCASVS> Of course, I will use /= in real apps
13:20:03 <nominolo> ok, then maybe better via mail ..
13:20:23 <nominolo> @go bdd haskell
13:20:26 <lambdabot> http://ieeexplore.ieee.org/iel5/9215/29226/01319111.pdf
13:20:33 <sioraiocht> :t xor
13:20:48 <lambdabot> thread killed
13:21:15 <nominolo> murderer!
13:21:20 <sioraiocht> lol
13:21:23 <OCCASVS> :D
13:21:27 <sioraiocht> :t xor
13:21:31 <nominolo> again!
13:21:34 <sioraiocht> haha
13:21:40 <Japsu> gah
13:21:41 <OCCASVS> :t nominolo :P
13:21:43 <lambdabot> thread killed
13:21:44 <sioraiocht> lol
13:21:51 <sioraiocht> love me, lambdabot
13:21:57 <lambdabot> thread killed
13:22:02 <nominolo> no i've been dragged into a murder
13:22:09 <Japsu> is "@go bdd haskell" interesting enough for me to put up the university VPN?
13:22:30 <nominolo> Japsu: i don't think so
13:22:42 <Japsu> k
13:22:50 <nominolo> i was looking for BDD implementations in Haskell
13:23:20 <monochrom> @type fromMaybe
13:23:32 <monochrom> @botsnack
13:23:32 <nominolo> Japsu: if you click on that link you can read the abstract
13:23:36 <lambdabot> thread killed
13:23:36 <lambdabot> :)
13:23:51 <monochrom> heeeeellllpppp!
13:24:09 <nominolo> fromMaybe :: a -> Maybe a -> a
13:24:57 <Japsu> I've actually come to appreciate Google Scholar... now that I have access to their full-texts from the uni
13:25:28 <nominolo> oh, yes, scholar is nice
13:25:29 <Japsu> without university access it's quite frustrating
13:25:41 <sjanssen> @djinn a -> Maybe a -> a
13:25:42 <lambdabot> f a b =
13:25:42 <lambdabot>     case b of
13:25:42 <lambdabot>     Nothing -> a
13:25:42 <lambdabot>     Just c -> c
13:26:00 <nominolo> f = fromMaybe
13:26:06 <nominolo> @src fromMaybe
13:26:07 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
13:26:55 <sjanssen> I prefer fromMaybe a = maybe a id
13:27:09 <nominolo> yes, mee to
13:28:39 <shapr> Does stuff like 1,2, etc count as a type constructor for Int?
13:28:49 <dmwit> data constructor
13:30:23 <jyasskin_> I think yes, except the constants implicitly get that (fromInteger) wrapped around them, after which they can't be constructors anymore.
13:30:29 <sjanssen> technically 1 is fromInteger primitiveCompilerConstant1
13:33:55 <nominolo> isn't :t 1  -> Integer?
13:34:11 <shapr> @type 1
13:34:19 <nominolo> nooo!
13:34:24 <shapr> lambdabot: @hello
13:34:24 <lambdabot> Maybe you meant: help tell
13:34:27 <lambdabot> thread killed
13:34:42 <nominolo>  :t and @type is broken today
13:34:49 <sjanssen> 1 :: Num a => a
13:35:34 <DRMacIver> Hm
13:36:04 <DRMacIver> In which case, how is 2 + 2 evaluated?
13:36:37 <eumenides> 2+2 :: (Num t) => t
13:36:40 <nominolo> depends on context i guess
13:37:03 <DRMacIver> ok. Say show(2 + 2) then.
13:37:20 <DRMacIver> It seems like this should never decide which instance of Num you have.
13:37:24 <sjanssen> DRMacIver: numeric defaulting kicks in
13:37:27 <DRMacIver> Ah
13:37:40 <DRMacIver> So this would go wrong in general?
13:37:50 <sjanssen> yes
13:37:53 <DRMacIver> ok
13:39:32 <DRMacIver> Still, quite neat. I'm constantly impressed by how cool type classes are. :)
13:39:57 <helmut> Can I somehow use one branch of a case for multiple values? case somechar of {- 5 chars -} -> ...?
13:40:19 <nominolo> helmut: not in general
13:40:32 <joelr1> folks, when should i use Control.Monad.ST over State?
13:40:50 <helmut> Is there something better for use with chars then?
13:40:52 <nominolo> helmut: case x of c | c `elem` "abcde" -> ... ; _ -> ..
13:40:58 <sjanssen> joelr1: when State isn't powerful enough to accomplish your task
13:41:06 <helmut> ah. ok.
13:41:10 <joelr1> sjanssen: hmm
13:41:15 <emu> :t 1
13:41:22 <sjanssen> State is one shared state variable
13:41:31 <lambdabot> thread killed
13:41:55 <sjanssen> ST provides references, so you can have an unlimited number of stateful variables
13:41:55 <joelr1> sjanssen: i'm reading the relevant papers now
13:42:15 <plediii> how do I fix this instance declaration: "instance Monad (Either String) where"?
13:42:16 <nominolo> joelr1: also, ST has STUArray
13:42:36 <Heffalump> plediii: -fglasgow-exts
13:42:38 <joelr1> sjanssen: i think having an unlimited number of references is neat, sounds like one doesn't need to encapsulate all state in a single structure
13:42:45 <Heffalump> or instance Monad (Either a) where
13:43:20 <Saizan> or instance SomeClass a => Monad (Either a) where
13:43:25 <nominolo> joelr1: yes.. but changing from State to St or back is kind of cumbersome
13:43:36 <nominolo> joelr1: you have to fix a lot of signature
13:43:38 <nominolo> +s
13:43:45 <joelr1> nominolo: well, i don't have signatures :-)
13:43:52 <joelr1> nominolo: maybe a couple
13:43:54 <Saizan> ?instances MonadState
13:44:09 <lambdabot> Plugin `instances' failed with: IRCRaised Data.ByteString.last: empty ByteString
13:44:14 <joelr1> nominolo: why bother when ghc infers the types for me?
13:44:15 <nominolo> joelr1: shame on you! ;)
13:44:23 <nominolo> joelr1: readability
13:44:31 <plediii> Thanks Saizan and Heffalump.  I should have read Hal Daume's comment about glasgow-exts in the beggining of the tutorial :)
13:44:32 <nominolo> joelr1: better error messages
13:44:35 <joelr1> nominolo: i now introduce signatures only when ghc is not doing what i need it to
13:44:47 <joelr1>  nominolo: exactly. when troubleshooting errors, for example
13:44:58 <nominolo> joelr1: if you use emacs + shim you can add them by typing C-c C-d
13:45:16 <Nafai> shim is nice
13:45:18 <joelr1> nominolo: i do use emacs. i never used shim.
13:45:24 <joelr1> i just use the ghci mode
13:45:50 <nominolo> joelr1: it's not providing much (yet), but it's neet
13:45:52 <nominolo> *neat
13:46:11 <DRMacIver> Hm. The front page for shim says that it has vim support, but there's no evidence of this on the rest of the site.
13:46:23 <nominolo> DRMacIver: it does?
13:46:29 <nominolo> i *could*
13:46:35 <nominolo> but it does not ATM
13:46:55 <joelr1> it appears that you can use IO from ST, is that right? it's not possible to do from State, for example, but is a great aid for debugging
13:47:07 <DRMacIver> Oh, sorry. It says that the aim of the project is to provide vim and emacs support.
13:47:13 <DRMacIver> It doesn't actually say it provides it. :)
13:47:25 <Saizan> you can't do IO in ST
13:47:30 <DRMacIver> "The aim of the shim project is to provide better support for editing Haskell code in VIM and Emacs by using the GHC-Api to provide features such as identifier completion, type lookup, background compilation and much more."
13:47:38 <Heffalump> yes you can, via an unsafe function
13:47:39 <norpan> vim vim vim!
13:47:42 <Heffalump> which is perfect if you just want to debug
13:47:54 <eumenides> you can do IO in State... StateT a IO b
13:47:55 <Heffalump> of course you can use unsafePerformIO from anywhere, too
13:48:09 <Saizan> ehe
13:48:43 <emu> there is a commit record of "vim support" for shim but i haven't actually seen the code
13:49:38 <nominolo> joelr1: shim can also show the type of any function.  problem is though, that you're program has to compile at least once.  if it doesn't compile, shim can't help you much
13:49:50 <joelr1> nominolo: right
13:50:05 <nominolo> joelr1: but f :: <signature>; f = undefined  helps wonders :)
13:50:07 <joelr1> has anyone used quickcheck to create complex properties? with state maybe?
13:50:19 <nominolo> joelr1: John Hughes has ;)
13:50:29 <joelr1> nominolo: yeah, yeah
13:50:35 <joelr1> anybody here?
13:50:42 <joelr1> i don't see john hughes
13:50:53 <joelr1> @seen JohnHughes
13:50:54 <lambdabot> I haven't seen JohnHughes.
13:50:59 <joelr1> there
13:51:05 <nominolo> he's hard to see even when you in the same building ...
13:52:04 <joelr1> nominolo: i once tried to catch up with john when in goteburg. left a message on the noteboard by his office but haven't found him.
13:52:36 <nominolo> joelr1: that's common
13:54:32 <tibbe> nominolo, same here, walked by his office during my 4,5 years at cth, never saw him once
13:54:40 <joelr1> sjanssen: i'm thinking of switching my ast transformer from state to st
13:55:55 <nominolo> tibbe: wow.  i met him twice, but never on the hallway.  only in a lecture and a meeting
13:58:13 <sjanssen> joelr1: why?
13:59:22 <joelr1> sjanssen: dunno yet, it's just a feeling. induced by "testing monadic code with quickcheck" :-)
13:59:50 <joelr1> sjanssen: i like the concept of lazy state threads, after all my ast transformer applies various transformations
14:00:04 <joelr1> sjanssen: i'm not sure otherwise
14:00:38 <nominolo> joelr1: what's your ast transformer for? (if i may ask)
14:01:42 <joelr1> nominolo: well, i first parse into ast1, then i translate ast1 into a ast2 that represents a "core" language. then i translate that ast2 into ast3 which corresponds to c#
14:02:11 <nominolo> oh, ok
14:02:41 <nominolo> i'll have some vague ideas about writing a compiler framework using many passes in haskell
14:02:50 <nominolo> there's a paper for a scheme framework
14:03:12 <nominolo> but in haskell you could maybe combine them into one big compiler
14:03:30 <nominolo> but it's all very very vague, right now
14:03:44 <joelr1> sjanssen: do you find my answer satisfactory?
14:04:24 <sjanssen> joelr1: you don't have to convince me, you just need to convince yourself :)
14:04:43 <joelr1> sjanssen: true
14:04:48 <sjanssen> I will say that State is considerably simpler -- I'd stick with it if possible
14:05:10 <sjanssen> if you can describe your state as a single data type, that is
14:05:17 <dmead> anyone use kdevelop?
14:05:18 <magnus_> joelr1: out of curiosity, what language are you compiling?
14:05:28 <joelr1> my bigger problem is quickcheck. it's easy to create properties for libraries of string ops, etc.
14:05:30 <joelr1> i think
14:05:43 <joelr1> @google LtU easylanguage
14:05:45 <lambdabot> http://lambda-the-ultimate.org/node/2201
14:05:46 <lambdabot> Title: Easylanguage: domain specific language for trading stocks | Lambda the Ultimate
14:05:47 <joelr1> magnus_: ^^^
14:05:52 <magnus_> cheers
14:06:23 <joelr1> it's now a handy reference, that LtU post
14:08:05 <nominolo> joelr1: in general, functional specifications are easier
14:08:17 <joelr1> nominolo: did you see my cafe post?
14:08:23 <nominolo> joelr1: if you have state, you typicallly use a model-based spec
14:08:31 <nominolo> no
14:08:42 <joelr1> nominolo: i would love a tip on how to create a functional spec for that
14:09:08 <joelr1> nominolo: the subject is creating QuickCheck properties
14:09:20 <joelr1> nominolo: what's the difference between a fun spec and a model spec?
14:09:53 <nominolo> joelr1: in a model-based spec you choose a simplified model and compare to the actual implementation
14:10:07 <joelr1> hmm
14:10:13 <joelr1> i don't understand
14:10:26 <nominolo> e.g. to verify a hash-table you take a trusted (i.e. simple) set-implementation
14:10:43 <nominolo> and describe you expected behaviour in terms of the set
14:10:57 <nominolo> another possibility is pre and post-conditionss
14:11:12 <joelr1> oh, i see
14:11:26 <nominolo> John's Erlang quickcheck actually allows to test the latter kind
14:11:41 <nominolo> by generating arbitrary programs that satisfy pre and post
14:12:05 <nominolo> maybe you can write a driver for QuickCheck that does this
14:12:07 <joelr1> nominolo: somehow i don't want to write my translator in erlang... somehow. i'd rather go with lisp, i think. better yet, i'd just stick with haskell
14:12:25 <joelr1> i don't have that much money to deliver v1 of the product
14:12:32 <nominolo> joelr1: i wasn't suggesting that
14:13:10 <nominolo> it shouldn't be that hard to implement this principle in haskell
14:13:17 <joelr1> nominolo: erlang's parsing tools are rather poor, imo
14:14:32 <joelr1> nominolo: i just got to section 5 of the monadic testing with qc paper. it's appropriately titled "testing a model-based specification of queues"
14:15:05 <nominolo> joelr1: i haven't read that paper, yet.  but it sounds like you should keep reading :)
14:22:53 <shapr> The only downside of monadic quickcheck is that the "run" function generally ends up being unsafePerformIO
14:24:09 <shapr> There are better ways, but they require more work.
14:26:31 <hpaste>  (anonymous) annotated "Exclusive OR" with "(no title)" at http://hpaste.org/1535#a1
14:29:41 <ADEpt> @src ($)
14:29:42 <lambdabot> f $ x = f x
14:33:17 <kuribas> ./
14:33:39 <kuribas> Excuse me.
14:34:50 <nominolo> shapr: like redirecting IO?
14:40:37 <hpaste>  augustss annotated "Exclusive OR" with "Simple" at http://hpaste.org/1535#a2
14:46:12 <stepcut> btw, any idea why there isn't an xor in Data.Bool ?
14:46:23 <augustss_> because it's called /=
14:46:38 <monochrom> I prefer /= too
14:46:38 * stepcut ponders
14:46:58 <augustss_> why have another name for it?
14:47:36 <monochrom> I do not mind extra names used by extra people. I stick with /=.
14:48:17 <eumenides> shim doesn't compile...
14:48:21 <joelr1> nominolo: there, just posted to cafe. see "QuickCheck testing of AST transformers"
14:48:31 * stepcut never considered /= before
14:48:37 <joelr1> augustss: hi lennart! too bad i'm not in nyc anymore :)
14:49:01 <monochrom> An advantage of thinking in terms of /= is that it is by far the most concise way to convey the idea.  "b xor c" is true precisely when b,c are different.
14:49:24 <stepcut> indeed
14:49:36 <stepcut> I'm glad I asked
14:50:19 <norpan> but why is there no xnor? :)
14:50:32 <monochrom> Um, are you trolling? :)
14:50:38 <augustss_> he sure is!
14:51:02 <augustss_> joelr1: i'm in London now
14:51:10 <joelr1> augustss_: oh!
14:51:44 <joelr1> augustss_: i guess you won't be attending those functional meetings then
14:51:49 <fantasma> guys you wont believe this...I built x11 bindings!!!!!!!
14:52:04 <augustss_> joelr1: without knowing more about your language it's hard to know what your QC properties should be
14:52:28 <joelr1> @google LtU EasyLanguage
14:52:30 <lambdabot> http://lambda-the-ultimate.org/node/2201
14:52:30 <lambdabot> Title: Easylanguage: domain specific language for trading stocks | Lambda the Ultimate
14:52:34 <joelr1> augustss_: ^^^
14:52:52 <augustss_> joelr1: one thing you could do is to write a simple interpreter for the original AST and for the Core and state that transformed programs should have the same meaning
14:52:54 <nominolo> joelr1: hm.  i think, to come up with good properties you need to formalize the semantics
14:52:55 <joelr1> augustss_: i'm compiling to c# at the moment
14:53:05 <nominolo> joelr1: while doing so, you'll probably learn a lot
14:53:31 <joelr1> nominolo: how would i formalize semantics?
14:53:33 <augustss_> yep.  and writing the interpreter is is one way of formalizing it
14:53:47 <nominolo> joelr1: so i would formulate the rules in terms on the eval functions for your several intermediate forms
14:53:56 <joelr1> augustss_: that's a very interesting idea... hmm... that would be two interpreters and i would check to make sure they produce the same results, right?
14:54:05 <augustss_> joelr1: right.
14:54:07 <nominolo> joelr1: yes, write an interpreter
14:54:11 <joelr1> very interesting... hmm...
14:54:23 <augustss_> joelr1: probably under some precondition that the original program is well-formed
14:54:41 <Cheery> @hoogle m a -> m ()
14:54:42 <joelr1> augustss_: right. parsing should have taken care of that. parsing and type-checking
14:54:46 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
14:54:46 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
14:54:46 <lambdabot> Prelude.id :: a -> a
14:55:20 <augustss_> joelr1: yes, but when you generate random program with QC they will not have passed your parser and type checker
14:55:23 <joelr1> two interpreters...
14:55:27 <augustss_> random ASTs I mean
14:55:39 <joelr1> augustss_: they are assumed to have passed, no?
14:55:51 <joelr1> augustss_: i would need to write proper generators to produce proper random asts
14:55:58 <augustss_> Right
14:56:03 <augustss_> then you'll be fine
14:56:03 <joelr1> augustss_: they can't be completely random in that sense
14:56:05 <nominolo> yes, two, of course.  and you want to typecheck you generated AST.  just as a safety net
14:56:28 <joelr1> mmm
14:56:42 <augustss_> writing a type checker for the core is another good way to check if the transformations are ok
14:56:52 <joelr1> and then my interpreters would need to know about the values of variables in previous invocations...
14:57:37 <nominolo> well, you need to somehow generate your program state
14:57:38 <augustss_> writing these interpreters will help clarify things, i bet.  it always does for me
14:57:54 <joelr1> so then i could run the syntax trees in both interpreters over the required number of "bars" to make sure the results check out
14:58:05 <nominolo> proving properties by hand might also help you find interesting corner-cases of your semantics
14:58:21 <joelr1> nominolo: proving properties by hand? how is that?
14:58:46 <nominolo> @go pitts lecture notes semantics of programming languages
14:58:49 <lambdabot> http://www.cl.cam.ac.uk/teaching/2000/Semantics/sempl.ps.gz
14:58:50 <augustss_> whatever properties you state with QC could be proven by hand (if they are true)
14:59:16 <joelr1> ah, right
14:59:18 <monochrom> proving properties by hand is very enjoyable
14:59:37 <monochrom> the skills carry over to programming
14:59:47 <nominolo> joelr1: these are quite nice lecture notes.  though, probably too much for your purpose
14:59:55 <MyCatVerbs> Sorry to bug, but is (\_ = x) in some expression is a function which takes on argument, ignores it and returns x, please?
15:00:11 <augustss> no
15:00:13 <monochrom> It is a syntax error.
15:00:18 <augustss> (\ _ -> x)
15:00:23 <nominolo> MyCatVerbs: yes. if x is defined outside that functuon
15:00:34 <joelr1> nominolo: thanks for the paper
15:00:52 <nominolo> joelr1: warning: they're lecture notes
15:01:04 <MyCatVerbs> nominolo: thank you. YAHT used it in the middle of defining >> from >>= and I wasn't entirely sure.
15:01:42 <joelr1> nominolo: yeah, i spent a semester in college so i have trouble with the math notation :-( gotta learn that
15:02:00 <Cale> ∘
15:02:00 <MyCatVerbs> Speaking of syntax errors, s/ion is/ion/, s/on ar/one ar/. Bah, humbug.
15:02:06 <Cale> oops
15:02:32 <nominolo> joelr1: it's quite simple.  over the bar: assumptions, under the bar: consequence
15:02:44 <nominolo> joelr1: of course, the tricky part is what they stand for
15:03:12 <joelr1> augustss, nominolo: would you mind replying to my cafe email with the interpreter suggestions? to stimulate the discussion
15:03:20 <joelr1> hi Cale
15:03:26 <Cale> hello
15:03:49 <nominolo> ok, good opportunity to re-register to haskell-cafe with my address fixed
15:04:19 <nominolo> obviously, my address is @googlemail.com instead of @gmail, when i send messages
15:04:27 <monochrom> haskell-cafe is a lot of fun
15:04:52 <nominolo> @where cafe
15:04:53 <lambdabot> I know nothing about cafe.
15:04:59 <nominolo> @where haskell-cafe
15:04:59 <lambdabot> http://www.haskell.org/mailman/listinfo/haskell-cafe
15:05:10 <joelr1> nominolo: do you work at google?
15:05:16 <nominolo> no
15:05:35 <joelr1> nominolo: then why googlemail.com?
15:05:49 <nominolo> maybe, because i registered in germany
15:05:58 <nominolo> there was some issue with the google.de domain
15:05:58 <joelr1> mine is always gmail.com
15:06:00 <joelr1> nominolo: i see
15:06:12 <nominolo> but i don't know, really
15:08:55 <joelr1> augustss, nominolo: thank you for your suggestions!
15:09:28 <augustss> yw
15:10:01 <shapr> joelr1: Did you ever get a response on when to use SmallCheck instead of QuickCheck?
15:10:02 <joelr1> augustss: swing by tenerife when you get a chance, 2.5 hours from london for something like 25 pounds. and the weather is super-nice!
15:10:38 <joelr1> shapr: howdy shae! dons and dcoutts tried to explain but i think i'm still unsure
15:10:45 <augustss> i might when the weather gets bad here.  it's been great the last couple of weeks
15:11:11 <dcoutts> joelr1: heh :-), try both, you'll get it
15:11:24 <joelr1> dcoutts: ;-)
15:11:52 <joelr1> i've been writing unit tests for my transformations but it's driving me bananas
15:12:10 <joelr1> i have to repeat almost the same syntax trees over and over and over
15:12:40 <shapr> joelr1: For 100 tests where you need a list, QuickCheck could produce 25 empty lists if you have a naive generator. SmallCheck's approach is more proof by exhaustion, so it starts with the smallest legal value and works its way up.
15:12:41 <nominolo> yeah: "Bug in Mailman version 2.1.5"
15:12:45 <shapr> That's what I read, I think.
15:12:50 <shapr> I haven't tried SmallCheck myself.
15:12:55 <joelr1> once for parsing, once for transformation into intermediate syntax tree (core) and then again into c#. this is for the 63 code samples that i have
15:13:19 <nominolo> requesting a new membership and changing an old one to the same address is obviously a bug-triggering border case in mailman :)
15:13:27 <joelr1> shapr: right. but i wonder if that can be remedied by writing a smarter quickcheck generator
15:13:31 <shapr> The best QuickCheck properties end up looking like something from an IETF RFC.
15:14:05 <shapr> joelr1: Yeah, when you write a generator you can specify the probabilities, but once again, that's more work.
15:14:32 <joelr1> so now i'm thinking of finishing up those arbitrary instances for the ast that my parsing produces since i can re-use them to both test the parsing and the transformation
15:14:33 <shapr> Would be nice if QC had a smallcheck-style exhaustive generator you could use.
15:14:59 <joelr1> test parsing by pretty-printing the generated ast and re-parsing that and then comparing to the ast i started with
15:15:11 <joelr1> shapr: right
15:15:42 <shapr> Yeah, that's the first property I write for everything, roughly read . show x == x
15:15:59 <sorear> @tell dons ty.
15:16:00 <lambdabot> Consider it noted.
15:16:04 <sorear> @messages
15:16:05 <lambdabot> dons said 15h 27m 22s ago: i think i can keep the bot over here for a while yet
15:16:20 <shapr> Actually, the zeroth property I write is only 'x'
15:16:41 <shapr> Means to me, 'Can I generate a value of this type at all whatsoever?'
15:17:02 <shapr> stepcut: Hey, do you have any existing daemonize code?
15:18:15 <joelr1> how come the monadic testing bits from QC didn't make it into Test.QuickCheck?
15:19:05 <joelr1> or did they?
15:21:28 <shapr> There's a long story behind QuickCheck 2
15:21:44 <joelr1> shapr: what's that?
15:23:04 <shapr> In a nutshell: QC1 was great, John and Koen wrote the first paper. They wrote a monadic version, and then a second paper. Koen wrote the shrink combinator somewhere around that time as well. They both got distracted being teachers at Chalmers and writing other papers.
15:23:07 <joelr1> i think the monadic testing with qc paper basically advocates writing interpreters and using them as properties
15:23:27 <shapr> During that time they ended up with a version they used to teach classes that integrated lots of cool features, but never had enough time to package it properly.
15:23:37 <dcoutts> joelr1: that's what I'm currently doing...
15:23:49 <joelr1> dcoutts: hugh?
15:24:00 <joelr1> dcoutts: never mind, i meant to ask what you meant
15:24:16 <dcoutts> joelr1: writing an interpreter to test the binary serialisation monad
15:24:22 <shapr> Something nifty happened where some industry people realize QC was total genius, and John Hughes spearheaded a startup to bring QC to the masses.
15:24:23 <joelr1> shapr: so there's no such code around?
15:24:59 <joelr1> dcoutts: augustss and nominolo suggested writing interpreters for my ASTs
15:25:00 <dcoutts> at least where masses == erlang :-)
15:25:13 <dcoutts> joelr1: sounds like a good suggestion
15:25:18 <shapr> During those years I pestered them for a new version every few months until Koen got sick of it and sent me a pre-release QC2 :-)
15:25:19 <joelr1> more precisely, where masses are erlang devs at ericsson
15:25:36 <joelr1> dcoutts: what commands are you looking to have in your ast?
15:25:49 <joelr1> shapr: did you package that?
15:26:07 <dcoutts> joelr1: nice and simple, just primitives to get or put various atomic types, like int, word8 etc
15:26:09 <ddarius> sorear: fib n /= fac n
15:26:26 <shapr> Me and other people on #haskell desperately wanted to use shrink, because it's such an incredible feature. John and Koen did a QC survey/call for features on the mailing list, and then started to put together a GPL version of QC2
15:26:45 <shapr> There was a sort-of real release a few months ago, but I don't remember if it includes the GPL license.
15:26:59 <joelr1> dcoutts: i see
15:27:40 <shapr> joelr1: Nah, I didn't package it, they said a GPL release would happen soon.
15:28:07 <sorear> ddarius: I know.  but it's a GMP function of type Int -> Integer, so the wrapping should be virtually the same
15:28:23 <fantasma> how come configuring X11-extras makes no attempt at checking my lib and include directories?
15:28:34 <joelr1> shapr: that must have been a few months ago :-)
15:28:44 <sorear> because if you didn't have them, X11 wouldn't have built
15:28:53 <sorear> and X11-extras depends on X11
15:28:58 * sorear is guessing
15:29:11 <shapr> joelr1: In the last year or so I've lost track of it. But I think a GPL release can't be included in GHC because of GHC's BSD license.
15:29:12 <fantasma> sorear: well I'm getting all these errors when I build Xlib.h not found etc.
15:29:30 <shapr> joelr1: So it'll probably be widely used only when Hackage is also widely used.
15:29:44 <shapr> How was that for a concise answer? I left out lots of interesting detail :-)
15:30:19 <joelr1> shapr: so where is the released qc2 source code now?
15:30:31 * ddarius thinks shapr should have started: "Come listen, my children.  I'll tell you no lies. ...."
15:30:44 <shapr> ddarius: What's that a quote from? Amerind storyteller?
15:31:54 <shapr> I was working on my own QC startup before I found out John had his own. I really didn't want to compete with John, so I bailed out.
15:32:17 <ddarius> shapr: Actually, it's the first line of a (version of a) traditional folk song "Omie Wise".  But, also "Listen my children, and you shall here ..." would have a similar sound to it.
15:32:40 <joelr1> a QC startup
15:32:42 <joelr1> fun
15:32:49 <shapr> Yeah, the market is still there too... fuzzing!
15:32:50 <ddarius> They're all the rage.
15:33:13 <shapr> All the existing fuzzing frameworks are totally ad-hoc.
15:33:30 <shapr> QC is the perfect fuzzing tool.
15:33:58 <sorear> shapr: qc is pretty small.  knowing how to do it, any competent programmer should be able to clone it in a day.  how much bigger is qc2?
15:34:28 <nominolo> @where quickcheck
15:34:29 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
15:34:30 <shapr> QC2 is quite different  from QC1
15:34:36 <nominolo> hm, no
15:34:52 <nominolo> i think it's cs.chalmers.se/~bringert/QuickCheck
15:34:54 <shapr> I think I have all the various versions on my drive somewhere.
15:35:47 <sorear> @seen ndm
15:35:48 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 5h 5m 32s ago, and .
15:36:07 <nominolo> http://www.cs.chalmers.se/~bringert/darcs/QuickCheck
15:36:11 <lambdabot> Title: Index of /~bringert/darcs/QuickCheck
15:36:16 <shapr> The shrink combinator is really cool, when you get a failure that was caused by a randomly generated input list, you shrink the list until you get the smallest input list that gives the failure.
15:36:29 <shapr> That can be generalized to partition testing and all sorts of other interesting stuff.
15:36:52 <joelr1> nominolo: is that qc with shrink? with monadic testing?
15:36:57 <nominolo> yes
15:36:58 <shapr> I hacked QC1 very slightly to do test driven development, where failing seeds are saved to disk and used for the next run.
15:37:00 <nominolo> it's the latest version
15:37:14 <shapr> That sort of extension would subsume unit testing into QC.
15:37:18 <nominolo> it was also featured on HWN, this year
15:38:05 <joelr1> nominolo: awesome although i did not see that HWN
15:38:06 <shapr> You'd need to be able to unserialize from either (seed,size) or the actual value though. That would let you specify values you want tested ahead of time.
15:39:09 <hpaste>  petekaz pasted "How to convert to hashtable?" at http://hpaste.org/1537
15:39:51 <petekaz> I could use some help converting that block of code to use Data.HashTable instead of Data.Map.  I'm not sure how to do it with the least amount of effort.
15:40:51 <shapr> In my opinion, fuzzing is the most interesting thing in software testing right now. These days code with tests gets lots of correct inputs, but rarely is it tested to 'fail correctly' with incorrect inputs.
15:41:58 <shapr> I'd like to have something like 'grow' that adds a random item to a legal input and checks to see if anything catches on fire.
15:42:20 <sorear> is there a complete description of QC2 anywhere?
15:42:48 <nominolo> sorear: no, the paper is still in the queue
15:42:52 <Saizan> ?where arrows
15:42:52 <lambdabot> http://www.haskell.org/arrows/
15:43:02 <sorear> so qc2 is really recent?
15:43:10 <fantasma> zomg I am inside an xmonad
15:43:16 <shapr> yay!
15:43:36 <fantasma> took a few days but it's all worth it
15:43:37 <shapr> fsvo recent, yeah
15:44:20 <nominolo> command-line options to xmonad should be introduced by >>=
15:44:30 * sorear is wondering about cloning it for his afternoon project
15:44:37 <nominolo> (does it have any command-line options?)
15:44:48 <nominolo> sorear: QC or xmonad?
15:44:55 <sorear> surelt it has -display et al?
15:44:55 <sorear> QC
15:45:15 <nominolo> sorear: I think it's not quite trivial
15:46:28 <nominolo> otoh, most of the details have already been figured out
15:48:59 <nominolo> oh, you wanted to clone it in order to understand it.  well, of course, that's a good idea.
15:50:01 <sorear> I meant cloning it because the source code has been lost in a mase of conflicting schedules.
15:50:54 <shapr> sorear: I think QC2 is what's in bringert's repo, check that first.
15:50:59 <nominolo> it's not lost
15:51:06 <nominolo> darcs gett
15:51:09 <nominolo> oops
15:51:12 <hpaste>  monochrom annotated "How to convert to hashtable?" with "(no title)" at http://hpaste.org/1537#a1
15:51:17 <nominolo> darcs get http://www.cs.chalmers.se/~bringert/darcs/QuickCheck
15:51:19 <lambdabot> Title: Index of /~bringert/darcs/QuickCheck
15:51:27 <nominolo> that's the QC2 pre-release
15:51:30 <nominolo> (i think)
15:51:33 <petekaz> monochrom: thanks.
15:53:44 <petekaz> monochrom: so edits2 always run even if the word is found in the output of edits1?
15:54:50 <monochrom> Yes.
15:54:55 <petekaz> Yikes!
15:55:05 <monochrom> Ah, we should change that.
15:55:07 <petekaz> edits2 is normally enormous!
15:55:44 <sjanssen> fantasma: how did you resolve your problems?
15:56:25 <monochrom> I'm shrewd. Let me just throw in a few unsafeInterleaveIO. :)
15:58:24 <waern> sorear: ping
15:58:24 <lambdabot> waern: You have 1 new message. '/msg lambdabot @messages' to read it.
15:58:44 <monochrom> Oh well, it wouldn't be a big improvement since sometimes edits2 is needed.
15:58:49 <sorear> waern: pong
15:59:17 <waern> sorear: I get a linker error when trying to use derive - it can't find `__stginit_derivezm0zi1_DataziDeriveziShow_'
16:00:17 <sorear> waern: ooh.  what specifically are you trying to do, when you say 'use derive'?
16:00:32 <waern> "-package derive"
16:00:33 <waern> :)
16:00:36 <sorear> that sounds like a symptom of not using --make?
16:00:40 <sorear> ooh...
16:00:52 <waern> weird huh?
16:00:57 <sorear> I have no clue.  what version of ghc?
16:01:04 <waern> I built derive using cabal, normally
16:01:07 <araujo> hello
16:01:13 <sorear> waern: is it installed?
16:01:14 <waern> ghc-6.7.20070323
16:01:25 <sorear> nice, I have the exact same
16:01:47 <sorear> waern: reproduced.
16:01:58 <sjanssen> that sounds like the error you get when somebody forgets to include a module in the .cabal
16:01:59 <waern> ah
16:02:44 <sorear> that sounds like it could well be it!
16:02:49 <waern> yep, the Data.Derive.Show module is not in the cabal file
16:02:52 <sjanssen> lo and behold, there doesn't seem to be a Data.Derive.Show in the cabal
16:02:58 <sjanssen> @quote stereo
16:02:59 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
16:03:07 <NichardRixon> :D
16:03:07 <sorear> waern: add it, try again, submit a patch, get you name in HC&AR
16:03:21 <waern> great :P
16:03:44 <waern> hopefully someday that kind of error will be caught automatically
16:07:27 <kolmodin> waern: hia
16:07:37 <waern> kolmodin, hi there
16:07:53 <kolmodin> hacking on haste2, I presume?
16:08:22 <waern> sorear: did you mean earlier that you had the exact same ghc version? :)
16:08:33 <waern> kolmodin: a little bit
16:08:44 <kolmodin> waern: from reading the source, haste2 assumes you have your code in darcs repos, and that you have a .cabal file?
16:08:57 <waern> kolmodin: yep
16:09:17 <waern> that was the easiest assumption to get going
16:09:19 <kolmodin> that's very nice assumptions :)
16:09:23 <dcoutts> waern: what's the darcs requirement for? I see why the cabal one
16:09:39 <kolmodin> dcoutts: remember it's still pre pre alpha :)
16:09:53 <dcoutts> sure
16:09:54 <waern> dcoutts, to get the file tree, it is faster to code up something using "darcs query manifest" than using the cabal file
16:10:04 <sorear> waern: yes I have ghc-6.7.20070323
16:10:11 <dcoutts> waern: ah, ok, I see
16:10:33 <waern> sorear, ok, cool.
16:10:46 <dibblego> is there an equivalent of C's & ?
16:10:50 <sorear> dibblego: .&.
16:10:54 <kolmodin> the file tree should mark which files are in the darcs repos and which arn't yet added... that'd be nice
16:11:01 <kolmodin> anyway, sleep
16:11:09 <dcoutts> kolmodin: so many features, so little time :-)
16:11:10 <dibblego> ?index (.&.)
16:11:11 <lambdabot> Data.Bits, Foreign
16:11:23 <kolmodin> dcoutts: aye. it's our curse :)
16:11:25 <QtPlatypus> dibblego: Which & do you mean?
16:11:33 <dibblego> QtPlatypus, e.g. 128 & 129 == 128
16:11:34 <kolmodin> luckely we have the best tools available!
16:11:37 <waern> I think it's better if the filetree just contains files that are in darcs
16:11:59 <dcoutts> waern: there's darcs's 'look for adds' thing
16:12:05 <QtPlatypus> dibblego: So bitwize and
16:12:08 <kolmodin> hmm. maybe
16:12:13 <dibblego> QtPlatypus, correct
16:12:22 <sorear> QtPlatypus: we knew what he meant :)
16:12:39 <waern> dcoutts: ok, cool
16:12:39 <kolmodin> right, I'm off to bed. g'night!
16:12:47 <kolmodin> waern: darcs wh -ls
16:13:24 <QtPlatypus> > 128 .&. 129
16:14:09 <dibblego> ?type (Data.Bits..&.)
16:14:24 <lambdabot> thread killed
16:16:22 <hpaste>  monochrom annotated "How to convert to hashtable?" with "if you take a risk" at http://hpaste.org/1537#a2
16:16:47 <monochrom> petekaz: that is another version, using unsafePerformIO to regain purity.
16:17:01 <petekaz> ok ... reading.
16:17:04 <sorear> is it pure?
16:17:38 <ddarius> Is there an ST HashTable?
16:18:00 <monochrom> A lookup into a hash table is present in the code.  That is the only cause of IO.  The lookup operation does have the potential of altering the hash table internally, however I'm going to ignore it.
16:18:08 <petekaz> monochrom: that version *looks* so much nicer than the previous.
16:18:22 <sorear> OK, if it's read only that's fine...
16:18:44 <monochrom> One has to look deeply into the hash table to see why lookup is IO and what is modified and whether it matters.
16:19:07 <sorear> monochrom: does lookup change the table, semantically?
16:19:18 <sorear> monochrom: remember splay trees are pure
16:19:41 <monochrom> For sure the "answer" is referentially transparent, but the lookup operation is still entitled to re-arrange the hash table in hope of reducing future collisions.
16:19:43 <sjanssen> if the hash table does change, is it concurrency safe?
16:20:06 <QtPlatypus> sorear: I didn't I was thinking he may have wished &varname.
16:20:55 <sorear> monochrom: unsafePerformIO is perfectly safe if there are no visible side effects. it's not 'risk' at all.
16:21:13 <sorear> @src listArray
16:21:14 <lambdabot> Source not found. Take a stress pill and think things over.
16:21:35 <sorear> awww.   I wanted the GHC unsafePerformIO-using library version.
16:24:19 <qwr> sorear: but what happens, when some modifies that hash table?
16:25:01 <sorear> qwr: they don't, you enforce that at the type level
16:26:59 <qwr> sorear: for lazy chunks to be not evaluated after some hashtable op in IO monad?
16:28:58 <sorear> ?
16:29:08 <fantasma> sjanssen: I upgraded to version 1.1.7 of Cabal to resolve my build issues with the x11 bindings
16:29:22 <sjanssen> fantasma: and it just worked?
16:29:29 <fantasma> sjanssen: yeah, surprisingly
16:29:34 <sjanssen> huh
16:30:03 <fantasma> sjanssen: I also had issues building x11 extras -- for some reason configure wasn't making X11.buildinfo so I had to make it myself
16:31:06 <sjanssen> fantasma: were you using darcs or the tarballs from hackage?
16:31:32 <fantasma> sjanssen: I was using the tarball
16:31:36 <sjanssen> oh, I bet dons forgot to run autoreconf in the tarball he made
16:31:42 <sjanssen> you need to run autoreconf
16:32:19 <fantasma> alright, just remember to run it in the next release :)
16:32:38 <fantasma> is 0.0 a valid version number?
16:32:42 <sjanssen> sure
16:32:48 <sjanssen> (that is also a mistake, though)
16:33:00 <fantasma> ah ok
16:33:31 <fantasma> does xmonad support floating windows?
16:33:36 <sjanssen> not yet
16:33:50 <fantasma> thank goodness for "yey"
16:33:54 <fantasma> yet*
16:34:59 <qwr> Prelude Data.HashTable> new (==) hashInt >>= \t -> let x = System.IO.Unsafe.unsafePerformIO $ Data.HashTable.lookup t 33 in insert t 33 22 >> print x
16:35:02 <qwr> Just 22
16:35:08 <qwr> sorear: like that
16:36:29 <fantasma> the xmonad Mosiac extension sounds interesting
16:36:39 * qwr probably missed whole point, and i'm sleepy, but that was what meant
16:38:08 <sorear> Don't worry, you have.
16:38:33 <qwr> :)
16:41:26 <dons> moin
16:41:27 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
16:41:37 <dons> sjanssen: ah yes. no autoreconf.
16:42:06 * jcreigh just had a really crazy idea regarding the statusbar in xmonad
16:42:23 <sorear> dons: ty, I've already removed lambdabot from /etc
16:45:28 <dons> http://programming.reddit.com/info/1kd1h/comments
16:45:30 <lambdabot> Title: 7 Rules for IO in Haskell (reddit.com)
16:46:21 <dons> sorear: note that the :ty bug manifests on the new machine too.
16:46:23 <ptolomy> So I made my tranformer-created monad an instance of Monad in order to ensure that 'fail' goes through my ErrorT stuff... 1) How is defining a monad in terms of transformers different than by 'instance Monad Mine where..' and 2) It complains about missing >>= and return, but it works well enough. AN issue?
16:46:29 <dons> so its something more serious.
16:50:17 <sorear> dons: I have to disagree. Passing IO functions is the crux of haskell's IO power.
16:50:45 <dcoutts> on button clicked $ do ...
16:50:50 <dcoutts> yep, I have to agree
16:51:01 <dcoutts> sorear: but people can get confused early on
16:51:37 <dcoutts> it's often best to pass in pure values and to the IO sequencing on the outside
16:51:49 <dons> sorear: oh, i agree too. so that's something this guy missed.
16:52:01 <dons> the use of IO as data, (and in lists), to do some fun things.
16:52:18 <dons> since a list of IO actions behaves like an AST, in many ways.
16:52:27 <dons> we avoid some uses of macros
16:52:57 <dons> sjanssen: i just made some small tweaks to xmonad.org, can you resync from the repo?
16:56:17 <dons> http://article.gmane.org/gmane.comp.lang.haskell.cafe/21856
16:56:19 <lambdabot> Title: Gmane -- Mail To News And Back Again
16:56:26 <dons>  New York Functional Programmers Network
16:56:46 <jcreigh> hmm...I never actually tried to get the numlock thing working on my system before...xev says state 0x10 when numlock is on...so I should just have to say numlockMask = 0x10 in my Config.hs, right?
16:57:10 <dons> shapr: do you know some other NY-based haskellers?
16:57:17 <dons> shapr: isn't Alex J in NY?
16:58:43 <calvins> a couple of xmonad questions: 1) is there any easier way than changing Config.lhs and recompiling/reinstalling to change what is launched as the terminal? I want to use urxvt rather than xterm.
16:58:58 <calvins> 2) how can I change the background color?
16:59:31 <jcreigh> calvins: 1). Not really, although you could just, eg, have $HOME/bin in $PATH, and symlink xterm in there to whatever you want.
16:59:38 <monochrom> I use unsafePerformIO safely. :)
16:59:46 <jcreigh> calvins: 2) xsetroot, I believe.
16:59:49 <dons> calvins: recompile, reinstall. then mod-shift-ctrl-q to restart
16:59:50 <qwr> calvins: usually you can change background with xsetroot in X systems
17:00:01 <dons> yeah, i have xpmroot ~/.bg/mandel.xpm &
17:00:05 <dons> in my .xsession file
17:00:29 <dons> calvins: this sounds like we should start an FAQ page.
17:00:31 <emu> is type inference in PSPACE for any vaguely interesting type system?
17:01:03 <calvins> dons: yeah, if there is one somewhere, i'll add all the questions I ask with answers...
17:01:49 <magnus_> calvins: to reinstall you have to manually rm the xmonad executable because of a Cabal bug
17:02:06 <magnus_> Cabal refuses to overwrite it for some reason
17:02:17 <calvins> magnus_: thanks for the info; that sounds like one I would have been scratching my head over for quite a while..
17:02:28 <scsibug> Has anyone gotten xmonad working in OS X?  I'm having trouble linking against X11 (when compiling X11-1.2)
17:03:21 <calvins> btw, xmonad is awesome!! I haven't been around for a month or so, so I don't know how many have been using it, but i'm really happy with it and am going to try to switch from gnome, for a while at least
17:03:43 <scsibug> configure finds the correct location of X libs, but the build step doesn't reference that path
17:03:58 <fantasma> scsibug: I've spent the past three days wasting countless hours trying to fix that and today I have
17:04:07 <jcreigh> dons: maybe we should ship a userinstall.sh script with xmonad that does the build+install+rm old xmonad+install dance?
17:04:09 <fantasma> scsibug: I resulted to updating cabal
17:04:25 <jcreigh> "resulted"?
17:04:34 <fantasma> well nothing else worked
17:05:04 <scsibug> fantasma: are you at 1.1.6.1?
17:05:41 <fantasma> scsibug: I didn't try 1.1.6.1 -- originally I was at 1.1.6 so I updated to 1.1.7 from darcs
17:05:49 <sorear> emu: Yes.
17:06:03 <fantasma> but I am curious if 1.1.6.1 would have solved the problem also
17:06:09 <sorear> emu: HM (w/o let) Lambda calculus is actually in P.
17:06:14 <scsibug> I'll try that first and see what happens
17:06:26 <sorear> emu: with let it gets trickier
17:06:37 <sorear> hi ndm!
17:06:43 <dcoutts> fantasma: 1.1.6.1 is almost exactly the same as 1.1.6
17:07:13 <fantasma> dcoutts: yeah I figured which is why I went straight to darcs
17:07:21 <dcoutts> aye
17:07:22 <ndm> hi sorear
17:07:23 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
17:07:28 <ndm> @messages
17:07:29 <lambdabot> joelr1 said 4h 16m ago: nice post!
17:08:09 <sorear> ndm: have you seen stream fusion yet? (googlephrase: From Lists to Streams to Nothing At All)
17:08:09 <ndm> sorear, good point about wanting derive to be more than just template haskell
17:08:26 <ndm> @google from lists to streams to nothing at all
17:08:28 <lambdabot> http://www.cse.unsw.edu.au/~dons/papers/CLS07.html
17:08:28 <lambdabot> Title: Stream Fusion: From Lists to Streams to Nothing at All
17:09:01 <ndm> sorear, i haven't read it, but i was aware of it - why?
17:09:12 <scsibug> no luck with 1.1.6.1, on to darcs
17:09:43 <emu> sorear: simply-typed LC?
17:09:46 <ndm> or are you refering to the section of a paper i checked in about 20 mins ago? (me gets scared sometimes)
17:10:42 <emu> hm, if it's in P, is it in NL?
17:10:50 <ndm> its too much effort to stream-fuse the Play stuff, unless it was the primary purpose of the paper
17:11:02 <sorear> no, actually I was refering to the fact you added a build call :)
17:11:15 <ndm> ah, that was just a cheap build that i spotted
17:11:20 <ndm> the fusion is just one small bit
17:11:41 <ndm> i can now do operations using the underlying Data instances faster than SYB
17:11:45 <ndm> which I'm quite proud of :)
17:13:28 <dons> fantasma: oh!
17:13:41 <dons> fantasma: so the main thing was to update cabal, so the linker flags would be propagated properly?
17:13:50 <fantasma> dons: odd isn't it?
17:14:20 <dons> well, it makes sense.
17:14:28 <dons> because i have a new cabal.
17:14:40 <dons> scsibug: so i think the recommendation is to update to the newest cabal you can get, to build X11
17:14:41 <fantasma> I should check out the changelog from 1.1.6 to 1.1.7
17:15:02 * ndm  wonders why every generic programming paper is _required_ to refer to the Visitor pattern in Java...
17:15:03 <scsibug> yep, thanks to both of you, it is compiling now with 1.1.7
17:15:15 <fantasma> nice
17:15:48 <dons> ndm, token imperative language reference, since those guys don't write papers ;-0
17:15:57 <dons> scsibug: great!
17:16:06 <dons> fantasma: good work. i think we can add that to the FAQ page i'm creating
17:16:38 <fantasma> dons: yes, please do, save others the hassle I went through :)
17:16:47 <dons> anyone in the bay area and wants a sparc 170Mhz box?
17:16:52 <dons> fantasma: yes.
17:17:26 <dons> oh, distributed trac eh?
17:17:46 <sjanssen> dons: next time we release X11-extras we need to run autoreconf and use cabal sdist
17:17:46 <scsibug> err, here is a strange thing... X11-extras fails with the same error as X11 did :/
17:18:06 <dons> sjanssen: yes, we could do a pointrelease this week perhaps
17:18:10 <dons> and double check the haddock generation..
17:18:28 <dons> scsibug: make sure you run autoreconf for X11-extras
17:18:41 <sjanssen> dons: hmm, what did we do wrong for that?
17:18:57 <sjanssen> I've generated haddocks for X11-extras before
17:19:15 <scsibug> dons: thanks...that did the trick...could you explain why?
17:19:20 <dibblego> ?users
17:19:21 <lambdabot> Maximum users seen in #haskell: 329, currently: 292 (88.8%), active: 44 (15.1%)
17:19:26 <dons> sjanssen: i've just not checked them.
17:19:35 <dons> scsibug: we forgot to add the ./configure file
17:19:40 <dons> woo, http://programming.reddit.com/info/1kdbt/comments
17:19:41 <lambdabot> Title: DisTract: a Distributed Bug Tracker (written in Haskell) (reddit.com)
17:19:47 <dons> great week for practical haskell
17:20:09 <scsibug> in the world of non-practical haskell, i made some pretty fractals this weekend...
17:20:36 <scsibug> http://scsibug.com/2007/04/21/mandelbrot-hs/
17:20:38 <lambdabot> Title: scsibug.com  Mandelbrot-hs
17:21:16 <sjanssen> dons: synced
17:24:07 <dons> I like days like this.
17:24:08 <dons> http://programming.reddit.com/info/1kdd2/comments
17:24:10 <lambdabot> Title: Commercial Haskell (and FP) Programmer&#39;s Group in New York Founded (reddit.c ...
17:25:02 <dons> sjanssen: maybe we can run DisTrac for bug tracking
17:25:28 <ndm> dons, just use google bug tracker!
17:25:48 <dons> boo on ndm and your proprietary tools
17:25:54 <ndm> distributed, offsite hosted, run by the people paying for the hacking
17:26:13 <dons> not open or under our control.
17:26:23 <ndm> google isn't proprietory, they are warm and fuzzy
17:27:00 <ndm> plus they make really good stuff, compared to the UI design horror that is most open-source projects...
17:27:03 <fantasma> I don't trust google with anything
17:27:06 <dons> we wouldn't keep our src in google's repo, neither would we keep our other support material there.
17:27:17 <ndm> you can just use the bug tracker
17:27:20 <dons> ndm, really, i find the bug tracker rather ugly.
17:27:31 <ndm> dons, uglier than trac?
17:27:32 <fantasma> dons: do you want me to install Trac?
17:27:39 <dons> ndm, certainly
17:27:56 <dons> its a bit more difficult to navigate too, though it is simpler (by far0 than trac
17:27:57 <sjanssen> ndm: does Google let you export the bug reports in some portable-ish format?
17:27:59 <ndm> dons, oh dear - trac is like the pits of interface design - google bug tracker is wonderful
17:28:17 <dons> fantasma: we'll work something out. no rush yet.
17:28:24 <ndm> sjanssen, no idea, my data is a whore to google - although they will do eventually though, i am sure
17:28:28 <dons> fantasma: ideally, i'd just like to reuse say, trac.haskell.org :-)
17:28:30 <dolio> scsibug: You might want to not use Complex if you try to make bigger pictures. Keeping track of the components yourself is a lot faster in my experience.
17:28:38 <sjanssen> dons: yes, DisTrac is certainly something to look at
17:29:00 <jcreigh> I've used Bugzilla and Trac before; I prefer trac by far.
17:29:15 <ndm> @hpaste
17:29:16 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:29:43 <hpaste>  ndm pasted "code, to be made shorter" at http://hpaste.org/1538
17:29:52 <sorear> IME C is a lot faster still.  Mandlebrot isn't complex enough to *need* haskell.
17:29:57 <ndm> anyone have any idea how to make that code shorter?
17:30:04 <sorear> of course i'd prototype in hs!
17:30:09 <ndm> without doing things like using ; and moving things onto the same line
17:30:28 <sorear> grr, you amended too fast! :)
17:30:35 <ndm> i have a feeling its longer than it should be...
17:30:41 <scsibug> mandelbrot was supposed to be a motivating example for producing an image library, but when I discovered bringert had done 99% of the work, i just did it anyways.
17:30:47 <dons> sjanssen: any thoughts on xmonad logo tshirts ? :-)
17:31:04 <sorear> ndm: what monad are you using?j
17:31:15 <ndm> sorear, state monad
17:31:25 <scsibug> why he went through all the trouble of writing GD bindings, and not implementing setPixel, I dunno.
17:31:30 <ndm> evalState (gmapM f item) xs -- thats the user
17:31:42 <gravity_> That reminds me, has anyone implemented a message passing system in haskell yet? Or is STM still the way to go?
17:31:43 <hpaste>  sjanssen annotated "code, to be made shorter" with "one line shorter" at http://hpaste.org/1538#a1
17:32:00 <dons> ndm, did you see swiert's announce (wrt. icfp)?
17:32:34 <ndm> dons, i did
17:32:46 <fantasma> dons: did you create the logo?
17:32:53 <ndm> dons, think it may have relevance to me? i couldn't see any initially, although did little more than read the first para of the announce
17:33:13 <hpaste>  sorear annotated "code, to be made shorter" with "3 lines shorter" at http://hpaste.org/1538#a2
17:33:43 <hpaste>  sorear annotated "code, to be made shorter" with "typo fix" at http://hpaste.org/1538#a3
17:33:43 <dons> fantasma: yeah.
17:33:57 <dons> ndm, no, i just thought it was interesting given our decisions earlier, wrt. papers/code
17:34:02 <fantasma> dons: what file format do you have it saved as?
17:34:14 <sjanssen> sorear: cheating, the types don't match :)
17:34:20 <dons> its .png only currently. we'd need proper vector graphics, i suppose
17:34:25 <fantasma> meh
17:34:29 <ndm> dons, ah yes - i still want to release catch
17:34:41 <dons> fantasma: if we were going to do it properly, i'd do a refined (larger) version that prints properly
17:34:46 <sjanssen> dons: thoughts on tshirts?  does "I'd wear one" count?
17:34:49 <dolio> gravity_: Chan/TChan would be the message passing primitive in the Haskell concurrency libs.
17:34:50 <dons> hehe
17:34:52 <ndm> ironically, if it wasn't for fps vs base, i'd have released Yhc cabalised by now, and be only 2 dependancies away from a release...
17:34:58 <dons> sjanssen: well, anselm can't have all the fun.
17:35:13 <gravity_> dolio: Cool! Thank you!
17:35:30 <fantasma> dons: what font is the >>= ?
17:35:33 <dons> gravity_: Chan is the main message passing abstractoin, yeah.
17:35:36 <sorear> gravity_: it's not primitive - it is built on MVar
17:35:47 <dons> fantasma: that's hmm. /me scratches head. the X is 'nimbus sans'
17:35:51 <dons> the >>= is hmm, something.
17:36:01 <sorear> gravity_: and incidentally, it is NOT exception safe - that way lies data corruption.
17:36:02 <ndm> sjanssen, sorear - thanks - i understand the first one, then it gets more confusing
17:36:12 <sorear> @ty State
17:36:17 <sorear> boo!
17:36:18 <ndm> dons, i love the xmonad logo
17:36:20 <gravity_> Ok, thank you!
17:36:32 <dons> ndm, so you got the subliminal lambda?
17:36:35 <gravity_> I didn't know anything wouldn't be exception safe
17:36:36 <dons> a few people missed that originally
17:36:38 <lambdabot> thread killed
17:36:46 <dons> sorear: weird , no?
17:36:52 <sorear> gravity_: neither did I.  the unsafety broke LB, badly.
17:36:53 <dons> sorear: and you say you don't get this behaviour on your box?
17:37:00 <gravity_> ouch
17:37:05 <sorear> dons: right.  either of my boxes.
17:37:20 <dons> it should be possible to add some 'block' around the Chan thingies.
17:37:27 <ndm> dons, yep
17:37:30 <dons> sorear: very weird.
17:37:41 <sorear> @version
17:37:46 <lambdabot> lambdabot 4p517, GHC 6.6 (Linux i686 2.66GHz)
17:37:46 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:37:52 <scsibug> mmm, xmonad is surprisingly...functional.  I could definitely work like this.
17:38:02 <dons> scsibug: heh.
17:38:04 <sorear> And I was so getting ready to suggest Linux v. BSD.
17:38:06 <sorear> :(
17:38:06 <dons> you thought it would be a toy? :-)
17:38:33 <dons> sorear: hmm. i wonder if it could be due to corruption of the state somehow?
17:38:45 <fantasma> nimbus sans ?= helvetica?
17:38:49 <dons> due to the fs failure. i perhaps inappropriately just copied the state from the openbsd box.
17:39:01 <dons> fantasma: oh, yes, >>= might be helvetica narrow, in fact
17:39:02 <scsibug> well, without expose or "spaces".... :-P
17:39:02 <sorear> dons: I doubt it, @type doesn't use any state.  (or does it use L.hs now?)
17:39:14 <narain> fantasma: a clone, i expect. like arial is
17:39:15 <sorear> dons: can you check for nasty stuff in L.hs?
17:39:18 <sorear> @unlet
17:39:20 <dons> sorear: hmm.
17:39:30 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
17:39:34 <sjanssen> @type id
17:39:43 <lambdabot> [1 of 2] Compiling ShowQ            ( scripts/ShowQ.hs, interpreted )
17:39:43 <lambdabot> [2 of 2] Compiling L                ( L.hs, interpreted )
17:39:44 <narain> wait, did i miss some context? i just came in
17:40:12 <ndm> dons, did you not check lambdabot with Catch?
17:40:13 <kc5tja> I am curious to learn if Haskell has some method of interacting with a graphing library.  E.g., given some input data, spit out a PNG file containing a pretty chart corresponding to that data.
17:40:34 <kc5tja> s/Haskell/some Haskell library/
17:40:38 <dons> ndm, its a strange bug leading to ghci not being killed, that appeared after a power failure
17:40:53 <dons> ndm, its all very mysterious, since there were no patches applied recently.
17:41:04 <dons> kc5tja: i believe that is posisble via gtk2hs
17:41:13 <dons> kc5tja: there's also the charting lib
17:41:14 <jcreigh> ./Graphics/X11/Xlib/Misc.hsc:-- XGetModifierMapping omitted
17:41:16 <jcreigh> FTW!
17:41:16 <kc5tja> dons: It has to be written to a PNG.
17:41:18 <sorear> ndm: not lambdabot's fault
17:41:21 <dons> and there's a binding to gnuplot
17:41:32 <sorear> ndm: that pattern match failure is in old versions of regex-posix
17:41:39 <sorear> boo on dons for not upgrading
17:41:45 <dons> yes. regex-* had a pattern bug
17:41:52 <ndm> hehe, don't you just hate it when libraries crash :)
17:41:55 <dons> kc5tja: i'd use a light binding to gnuplot
17:41:59 <ndm> did you know FiniteMap ahs a pattern bug?
17:42:02 <dons> kc5tja: such as i use for darcs-graph
17:42:24 <ndm> Catch found it, and proved all other incomplete patterns safe
17:42:30 <sjanssen> jcreigh: trying to fix numlock?
17:42:34 <jcreigh> sjanssen: yeah.
17:42:46 <sjanssen> great
17:42:52 <sjanssen> X11 == teh suck
17:42:52 <kc5tja> I'm asking because I'm writing a program for work that is in Python, and it's going well enough.  But I'm forced to use objects when it's inherently a functional kind of problem, because of the libraries I have to rely on.
17:43:10 * kc5tja would like to, in my spare time, rewrite the code in Haskell to compare the two programs for length and time taken for development.
17:43:19 <sorear> yeah, when libraries crash all sorts of holes open in ALL the abstractions
17:43:30 <sorear> a shattered vase is leaky
17:43:36 <dons> sjanssen: this might be fun too http://article.gmane.org/gmane.comp.lang.haskell.general/15134
17:43:38 <lambdabot> Title: Gmane -- Mail To News And Back Again
17:43:42 <dons> (IOSpec)
17:43:45 <kc5tja> sjanssen: X11 doesn't suck; XFree86 and its evil ilk all suck.
17:43:50 <dcoutts> kc5tja: see http://dockerz.net/twd/HaskellCharts
17:43:51 <ndm> @remember sorear a shattered vase is leaky
17:43:51 <lambdabot> Title: HaskellCharts - twd
17:43:52 <lambdabot> Done.
17:43:59 <sorear> @flush
17:44:19 <dcoutts> kc5tja: alternatively you might find more features are available via gnuplot
17:45:17 <jcreigh> kc5tja: if xlib is part of XFree86's evil ilk, then yes.
17:45:21 <dons> http://programming.reddit.com/info/1kdj6/comments
17:45:22 <lambdabot> Title: IOSpec: pure specification, reasoning and testing of IO in Haskell (reddit.com)
17:45:26 <sjanssen> kc5tja: I was referring to Haskell's X11 package
17:45:45 <dcoutts> kc5tja: actually it looks like that charting lib has seen some development lately
17:45:52 * jcreigh isn't too exited about xlib in general
17:45:53 <mwc> OT, a lot of the suck of X11 comes from people using crappy autogenerated xorg.confs.
17:46:06 <dcoutts> dons: clearly we should be using it for QuickBench :-)
17:46:26 <dons> dcoutts: right.
17:47:06 <kc5tja> jcreigh: No, xlib existed long before XFree86.
17:47:16 <kc5tja> xlib, also, can certainly suck.
17:47:21 <dcoutts> roll on xcb
17:47:33 <kc5tja> But the protocol itself isn't any more abnormal than any other GUI API.
17:47:58 <dcoutts> mwc: recent xorg can run without any .conf at all which should help that situation
17:48:28 <kc5tja> dcoutts: The output looks pretty much like what I'm interested in, even if the library is incomplete.
17:48:29 <dcoutts> and more and more of the .conf stuff can be set after starting up the xserver process
17:48:49 <dcoutts> kc5tja: well if you run into missing features they do say patches are welcome :-)
17:49:06 <mwc> dcoutts, Xorg's X 7.2 died hard on my powerbook
17:49:25 <kc5tja> dcoutts: I'm going to be doing this during my "spare" work-time, and since Haskell is positively NOT one of Google's official languages, I doubt patches will be forthcoming.
17:49:28 <mwc> I just popped open man xorg.conf and wrote a 101 line xorg.conf and it works beautifully
17:49:36 <sorear> kc5tja: I'd call it much nicer than most gui apis.
17:49:40 <kc5tja> If it lacks features, I'll just silently give up.  It's not a high priority project for me.
17:49:55 <sorear> kc5tja: for instance, asynchronisity ...
17:49:58 <kc5tja> sorear: Hell yeah it is.
17:50:00 <dcoutts> kc5tja: I've not used it so I don't really know, but it being based on cairo is a good sign
17:50:20 <kc5tja> sorear: Asynchronisity isn't an issue in other APIs, since they run locally anyway.
17:50:24 <kc5tja> But other things are nice.
17:50:47 <kc5tja> dcoutts: Except that's one more dependency to keep track of on the local workstation.
17:50:48 <sorear> kc5tja: ever notice that being asynchronous is GOOD even locally?  it lets you amortize the cost of icache flushes!
17:50:49 <dcoutts> kc5tja: well if patches are too much bother, some feedback to the devs is the next best thing, to say what you would have liked to do
17:51:31 <sorear> mwc: you mean man xorg.conf doesn't have half the sections marked as undoc anymore?
17:51:39 * sorear might have to read it!
17:51:49 <kc5tja> sorear: Well, it helps amortize the cost of IPC, that's for sure.  That's why Quartz is blazingly fast -- building a scene graph inside the video driver allows you do implement a GUI more or less trivially using structured graphics primitives, all because the visitor for that graph doesn't involve IPC.
17:52:19 <mwc> sorear, only VideoAdaptor, which is marked along the lines of "Nobody wants to say how this works. Maybe nobody knows."
17:52:49 <kc5tja> sorear: That being said, there are strong advantages to having a synchronous protocol too.  The trick is to maximize the number of "void" functions, so that you can batch them and send them at once.
17:53:10 <sorear> I only wish I could use X *and* see my ide0: { UncorrectableError SeekError } messages :(
17:53:27 * sorear likes to know ASAP when these occur
17:53:28 <dylan> sorear: watch dmesg
17:53:38 <mwc> sorear, dmesg? Log viewers?
17:53:58 <sorear> well, yeah, but is that really fast enough?
17:53:59 <monochrom> listen to the disk. an uncorrectable seek error makes a loud sound
17:54:10 <kc5tja> monochrom: Not always.
17:54:14 <sorear> besides they don't help with kernel panics...
17:54:15 <kc5tja> In fact, almost never now-a-days.
17:54:24 <dylan> tail -f /var/log/something | zenity --something
17:54:26 <fantasma> line 55 xmonad.org/index.html s/utilising/utilizing/
17:54:51 <kc5tja> fantasma: Either spelling is correct; the former is British English, the latter is American.
17:55:02 <kc5tja> And since dons is in Australia (IIRC), he uses British style spelling.
17:55:11 <fantasma> oh
17:55:12 <monochrom> use smarttools. there is a daemon waiting for this to happen and sends you email.
17:55:14 <dylan> australia uses an interesting mix.
17:55:23 <dons> fantasma: yeah, utilise please :-)
17:55:34 <sorear> monochrom: disk crashes are unfixable and noisy.  I'm more concerned about the bad sectors which have a habit of finding their way into my HSbase.a ..
17:55:48 <mwc> Canada has a similar disjunction of styles. You have a driver's licence but are licensed to drive.
17:55:51 <kc5tja> Wasn't there a Unix filter for turning average text into Australian outback talk?
17:55:58 <kc5tja> You should run the text for xmonad through that.  :D
17:56:01 <jcreigh> does explictly setting numlockMask in Config.hs work for anyone else? I can't seem to get it to work.
17:56:10 <sorear> @cockney I think this is it?
17:56:11 <lambdabot> Unknown command, try @list
17:56:20 <fantasma> I hate British talk =\
17:56:21 <dons> jcreigh: hmm.
17:56:32 <mwc> "Oi, Mate, A dingo's run off with your .Xauth"
17:56:32 <sorear> boo, what happened to the talk-filters module?
17:56:36 <sorear> ?list filter
17:56:37 <lambdabot> No module "filter" loaded
17:56:40 <sorear> ?list filters
17:56:40 <lambdabot> No module "filters" loaded
17:56:43 <sjanssen> jcreigh: it looks like it's broken ATM
17:56:44 <dibblego> Australia uses British spelling, except for young people who watch lots of television
17:56:44 <sorear> ?list talk
17:56:45 <lambdabot> No module "talk" loaded
17:56:58 <jcreigh> hmm, okay.
17:57:12 <dibblego> a dingo destroyed my brand new football the other week
17:57:22 <dylan> dibblego: does young == 30 year olds?
17:57:24 <dons> dibblego: oh man.
17:57:26 <kc5tja> fantasma: Hah, it's their language, they can do what they like.  Give us another 1000 years, and then maybe, just maybe, we can legitimately call our dialect American and have it be meaningful.
17:57:27 <mwc> hmm, by football, do you mean soccer ball?
17:57:30 <Pseudonym> dibblego: I've heard that one before.
17:57:35 <sjanssen> jcreigh: it's used in grabKeys, but it should also be sanitized in the key press handler
17:57:37 <dibblego> dylan, easily impressionable by American culture, so a bit younger
17:57:42 <kc5tja> That, of course, presupposes us actually surviving that long to begin with.  :)
17:57:44 <jcreigh> sjanssen: ah.
17:57:44 <dibblego> yes, I mean soccer ball
17:57:46 <mwc> Is soccer == football in .au?
17:57:52 <Pseudonym> mwc: "Football", in Australia, can actually refer to one of four things.
17:57:53 <dibblego> mwc, correct
17:58:03 <Pseudonym> Aussie rules, Rugby League, Rugby Union or soccer.
17:58:07 <dibblego> I used football, because I am in an international forum :)
17:58:10 <sjanssen> jcreigh: are you changing things in that area right now, or can I commit a patch real quick?
17:58:11 <dylan> dibblego: I'm just saying, from experience, I know an 30something aussie that will use color and colour in the same paragraph.
17:58:18 <kc5tja> "Soccer" is used only in USA, as far as I'm aware.  Literally everywhere else calls it football.
17:58:20 <mwc> lol, In Canada, football refers to either CFL or NFL style football.
17:58:21 <dibblego> dylan, that's a shame
17:58:22 <jcreigh> sjanssen: go ahead.
17:58:41 <Pseudonym> We do call it soccer in Australia usually.
17:58:52 <mwc> the kinds with ellipsoidal balls
17:58:53 <mwc> kc5tja, soccer in Canada
17:58:55 <dibblego> dylan, I would attribute that to the proliferation of American culture through media, resulting in confusion
17:59:07 <dylan> dibblego: perhaps. :)
17:59:09 <Pseudonym> mwc: Aussie rules and rugby are played with ellipsoidal balls.
17:59:22 <dylan> a lot of american spellings I think are from proximity to spanish speaking countries.
17:59:25 <Pseudonym> What you're referring to is the wussy game with the helmets and the padding.
17:59:31 <Pseudonym> Real Men get hurt.
17:59:56 <kc5tja> Pseudonym: I'm not a real man then.  But I am a sane man.
18:00:01 <Pseudonym> :-)
18:00:06 * dylan utterly hates american football.
18:00:08 <dibblego> I don't think the dingo cared anyway
18:00:11 <mwc> My university, Canadian, 200+ years old, awards an HONORS bachelor of sciences
18:00:13 <jcreigh> meh, Ultimate Frisbee is the only sport worth playing. :)
18:00:21 <dibblego> he/she just chewed it and destroyed it
18:00:25 <QtPlatypus> Rugby Union players have helmets, though no one would call Union players wussy.
18:00:35 <dylan> mwc: 200+ years ago, honor was the normal spelling.
18:00:37 <fantasma> ultimate frisbee is the worst
18:00:52 <dylan> say, 1700s, color, honor, etc were normal.
18:00:58 <monochrom> Have you played concurrent frisbee?
18:01:09 <mwc> dylan, actually, american style spellings are the result of Webster's attempts to reform english spelling. Color is the latin word, Colour is the bastardized norman version that eventually came into english
18:01:09 <mwc> dylan, really? not Honour?
18:01:31 <dylan> mwc: from what I read in the book The Mother Tongue.
18:01:38 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1539
18:01:38 <dylan> author forgotten.
18:01:40 <mwc> monochrom, lol, you need mutexs and semaphores
18:01:53 <monochrom> No, just STM will do. XD
18:01:54 <narain> monochrom: is that with multiple frisbees? i've played concurrent foosball
18:01:57 <dylan> we need a transactional frisbee!
18:02:08 <monochrom> Yeah multiple frisbees.
18:02:12 <narain> bah, concurrent frisbee is just message passing
18:02:19 <sorear> I wish tar had a mode like zxf that also deleted the input file.
18:02:20 <Pseudonym> For the record, "-ize" is also closer to the original Greek endings of verbs.
18:02:25 <Pseudonym> As opposed to "-ise".
18:02:32 <sorear> Yow.  That is a Big Nasty Record.
18:02:36 <dylan> mwc: color, favor, etc, are also the way it is spelled in spanish.
18:02:47 <mwc> dylan, indeed, also in Latin
18:02:51 <Pseudonym> However, Americans ignore a useful distinction in words like licence/license, defence/defense etc.
18:02:57 <Pseudonym> practice/practise
18:03:05 * sorear lost a fourth grade spelling bee.  Favorite.  F A V O U R I T E . Favorite.
18:03:07 <mwc> see http://en.wikipedia.org/wiki/Noah_Webster#Speller_and_Dictionary, quote: Slowly he changed the spelling of words, such that they became 'Americanized'. He chose s over c in words like defense; he changed the re to er in words like center; he dropped one of the l's in traveller; at first he kept the u in words like colour or favour, but he dropped it in later editions.
18:03:07 <dylan> I think the spellings are re-inforced by the number of spanish speakers settling in the US.
18:03:12 <dibblego> your/you're :)
18:03:27 <fantasma> very true Pseudonym, I hate that
18:03:33 <Pseudonym> dibblego: lose/loose?
18:03:38 <narain> Pseudonym: is "defense" a verb? isn't it "defend"?
18:03:47 <dibblego> Pseudonym, yeah I've seen that one a few times
18:04:03 <kc5tja> mwc: This wasn't his doing.  The drive to simplify spelling has a longer history.  The quote you pasted makes Webster appear to be responsible for arbitrarily changing the words.
18:04:22 <narain> dibblego: ur/your/you're :)
18:04:22 <kc5tja> The fact is, they wanted to remove the French influence (colour, for example).
18:04:25 <mwc> no, but I think he was the sharp end of the stick on those reforms
18:04:40 <Pseudonym> narain: self-defense
18:04:47 <dibblego> my children will be literate dammit!
18:04:55 <narain> Pseudonym: that's a noun
18:05:15 <Pseudonym> Hrm.
18:05:23 <Pseudonym> OK, you might be right in that case.
18:05:33 <Pseudonym> However, Americans do distinguish advice/advise and device/devise.
18:05:38 <dylan> the spelling color in english predates websters.
18:05:51 <dylan> *webster.
18:05:52 <sjanssen> jcreigh: patch applied
18:06:07 <narain> Pseudonym: right, the noun/verb distinction is useful
18:06:18 <kc5tja> dylan: Yes, but I used that as an example; the language reform movement, like I said, predates Webster.
18:06:24 <dons> sjanssen: funny "Haskell is an interesting language and it offers some opportunities for educational use. I'm surprised to see such a useful tool written in this language, really impressing, because I never found Haskell programs in the "real world"..."
18:06:31 <dons> (referring to xmonad)
18:06:34 <narain> but then there's things like access/access etc
18:06:40 <kc5tja> narain: Advice != advise.
18:06:52 <kc5tja> Advice is something you give, but advise doesn't mean you're giving advice!
18:07:06 <monochrom> what is advise?
18:07:08 <sjanssen> fixing that bug was a fun little adventure.  My fix accidentally clobbered all commands with keymasks, so I couldn't use any xmonad keybindings when I tried to test it :)
18:07:12 <fantasma> what else can advising be?
18:07:17 <kc5tja> Likewise, a device is something that tends to be technological in nature, but to devise is to connive.
18:07:18 <narain> kc5tja: i didn't argue against that
18:07:28 <sjanssen> dons: where does that gem come from?
18:07:45 <dons> towards the end of the osnews comments.
18:07:50 <ddarius> How do you hear about xmonad and not have heard about darcs?
18:08:07 <dmead> it was on osnews
18:08:07 <sjanssen> dons: it's great to kill misconceptions like these
18:08:10 <dons> yeah
18:08:15 <dmead> xmonad was
18:08:15 <kc5tja> monochrom: Advise is to issue a notice.  "I don't advise that," for example (which happens to also be issuing advice).  However, it doesn't have to be.
18:08:25 <Pseudonym> Now that I look about it, "defense" doesn't occur on its own in Commonwealth English.
18:08:31 <ddarius> Stupid crunchy Concho water.
18:08:37 <Pseudonym> It only appears in words like "defensive".
18:08:47 <Pseudonym> Makes sense.
18:09:28 <dylan> Pseudonym++ for the period being outside the quotes.
18:09:47 <ddarius> dmead: As was darcs.
18:09:50 * jcreigh tends to do that too.
18:10:00 <jcreigh> I'm not quoting the period, dang it!
18:10:02 <dylan> I do too, even though it gets me negative marks on my essays.
18:10:12 * sorear ditto
18:10:21 <dylan> "well written, -1 for punctuation"
18:10:26 <fantasma> period inside the quote is a stupid syntax
18:10:27 <sjanssen> yeah, I do that too
18:10:42 <sjanssen> I think it's a very programmer-esque outlook on grammar
18:10:44 <jcreigh> sjanssen: cool. That makes the existing functionality work.
18:10:49 <kc5tja> Period inside the quotes is the syntax used for quoting a complete sentence from someone.
18:10:58 <ddarius> jcreigh: I was taught that there are times when you use one or the other.
18:11:13 <Pseudonym> kc5tja: And that's a fairly modern thing to do.
18:11:18 <Pseudonym> I do it because I'm a geek.
18:11:25 <Pseudonym> I quote exactly what is quotable, and nothing else.
18:11:37 <kc5tja> This is an "example".  Versus, "This is an example."
18:12:00 <monochrom> I like to be a programmer.
18:12:01 <fantasma> kc5tja: is the first example gramatically correct?
18:12:07 <dylan> I am quite ashamed that ' made its way into my chatting.
18:12:13 <dylan> I never used to use contractions.
18:12:31 <kc5tja> fantasma: Yes.  The quotes in the first example indicate, well, an example -- they're used as a bracketed form of emphasis.
18:12:39 <sjanssen> dylan: like Data?
18:12:53 * sjanssen suspects that dylan is actually his evil twin brother
18:12:58 <dylan> sjanssen: err, I suppose.
18:13:06 <monochrom> both (5+5)! and (5+5!) are grammatically correct. They mean different things. Both should be allowed in a sane language.
18:13:06 <kc5tja> sjanssen: You mean ... Lor?
18:13:08 <sjanssen> really nerdy Star Trek reference, sorry
18:13:30 <dylan> sjanssen: star trek is so B4 my time. ;)
18:13:53 <dylan> [actually, I was exposed to ST:TNG at an early age...]
18:23:53 <vagif> What is the best library to work with sql databases from haskell ?
18:24:59 <dons> hdbc? (check hackage.haskell.org under 'databases')
18:25:14 <dons> sjanssen: did we ever reach an opinion on having patches sent to xmonad@ by default
18:25:43 <vagif> thx, i'll check it. I'm confused with so many db libraries. HaskellDB, HSQL, HDBC
18:25:45 <dons> sjanssen: the only issue would be that the mailing list would block non-subscribed users by default ... :/
18:25:49 <dons> SyntaxNinja: heya
18:26:13 <sjanssen> dons: I hadn't made any decisions
18:26:30 <sjanssen> dons: do you have a preference?
18:26:38 <dons> if i can set it up to not block non-subscribers sending patches, i'd prefer things to go to xmonad@ by default.
18:26:41 <sjanssen> it's effectively the same email load for me, so I really don't care
18:26:50 <dons> ok. i'll see if i can tune the filter
18:27:30 <SyntaxNinja> y0 dons
18:27:37 <jcreigh> #haskell xmodmap poll: What mod is your numlock bound to?
18:27:48 <sjanssen> mod2
18:27:59 <dons> jcreigh: how do i find out? with xev?
18:28:02 <sjanssen> but I don't even have a physical numlock key
18:28:04 <jcreigh> dons: run xmodmap
18:28:17 * dons notes NumLk is a tiny thingy above ScrLk, at the furthest reaches of my keyboard
18:28:34 <dons> mod2        Num_Lock (0x4d)
18:28:41 <narain> mod2
18:28:53 <narain> why do you ask?
18:29:00 <dons> SyntaxNinja: http://programming.reddit.com/info/1kdd2/comments
18:29:01 <lambdabot> Title: Commercial Haskell (and FP) Programmer&#39;s Group in New York Founded (reddit.c ...
18:29:16 <dons> SyntaxNinja: we'll have to set up a west coast group now, can't have those guys taking over ;-)
18:29:22 <dcoutts> heh
18:29:36 <jcreigh> narain: because of X11 stupidity, you have to do special stuff to still get keypresses when numlock is on. (related to xmonad)
18:29:47 <dcoutts> dons: that looks like a good sign, I hope they get good attendance
18:29:53 <dons> yeah. hope so.
18:30:06 <dons> i note that its both CS and Deutsche Bank involved.
18:30:21 <narain> jcreigh: ah. that's... interesting
18:30:28 <dcoutts> dons: and perhaps it's a good route for SC to recruit those notoriously-difficult-to-pin-down Haskell hackers
18:30:38 <dons> yeah. i'd imagine that's part of it.
18:30:41 <dcoutts> right SyntaxNinja? :-)
18:30:50 <narain> is functional programming big in financial applications?
18:31:09 <dons> narain: its growing in some key finance applications, yeah
18:31:32 <dcoutts> narain: sshhh, or everyone will know the secret ;-)  how will be make loads of money then eh?
18:32:19 * narain remembers looking at slides from that composing contracts presentation  by... was it spj?
18:32:29 <dcoutts> yep
18:32:36 <Jessehk> I'm still trying to "get" monads. I was curious if I used them correctly here: http://hpaste.org/1540
18:32:41 <SyntaxNinja> dons: interesting.  I wonder whether / why they are / aren't working with us on CUFP.
18:32:46 <narain> those were fun slides to read
18:32:57 <dcoutts> SyntaxNinja: perhaps you should just poke them
18:33:29 <SyntaxNinja> yeah, I already forwareded it to Andy :)
18:33:32 <sorear> dons: if you want wc cufp's, attack google via kc5tja?
18:33:51 <dcoutts> Jessehk: looks ok to me, but you know you don't need to use IO to get random numbers
18:33:56 <SyntaxNinja> yeah, awesome Haskell hackers who have a burning desire (and maybe some skill) at actually delivering software are hard to come by.
18:34:28 <dcoutts> Jessehk: in fact it's much nicer not to, you can take the RNG as a parameter, or an infinite list of random numbers
18:34:35 * sorear is a good haskell hacker with absolutely no reliable motivation :(
18:35:00 <dcoutts> Jessehk: and only initialise the RNG once in IO at the top of the app, keeping IO out of the rest of the program
18:35:05 <Jessehk> dcoutts: That's starting to sound very foreign. ;)
18:36:00 <black_13> what does "a memento is an unfortunate artifact of von neumann thinking"
18:36:02 <SyntaxNinja> sorear: :(
18:36:02 <narain> Jessehk: consider the stream of numbers that the random number generator (RNG) generates
18:36:04 <dcoutts> Jessehk: you may also want to check out Cale's random monad
18:36:16 <black_13> what is "von neuman thinking"?
18:36:21 <narain> Jessehk: think of it as an infinite stream of numbers
18:37:03 <narain> when von Neumann does something incomprehensible, you say, "what is von Neumann thinking?"
18:37:20 <narain> hm, that looks non sequitur
18:38:50 <narain> dcoutts: were you thinking of having the pure functions return both a value and the tail of the rng stream?
18:39:03 <jcreigh> sjanssen: I sent you a patch that, IMO, does 90% of what we want. We ignore both lockMask (capslock) and numlockMask, and numlockMask is still settable in Config.hs, but defaulting to mod2Mask
18:39:28 <narain> dcoutts: then we ought to introduce the State monad to thread things together neatly
18:39:44 <dcoutts> narain: that's exactly what Cale's random monad does I think
18:39:53 <QtPlatypus> black_13: I suspect that "von Neumann thinking" is thinking related to von Neumann mecheans, that is procedural programing on single CPUs.
18:40:29 <dcoutts> narain: in this case of course you know that selecting a random card uses the rgn only once
18:40:38 <black_13> QtPlatypus, the programming that was probably first tought in basic cs classes
18:40:50 <black_13> fortran pascal and c
18:40:52 <dcoutts> narain: so it's not necessary to thread the rng through everything
18:41:05 <jcreigh> sjanssen: eventually, we probably should wrap up XGetModifierMapping(), but I didn't do it right now because the interface is scary. (http://tronche.com/gui/x/xlib/input/XGetModifierMapping.html)
18:41:07 <lambdabot> Title: Xlib Programming Manual: XGetModifierMapping
18:41:14 <QtPlatypus> black_13: Depends on where you go.  But yes.
18:41:34 <dons> jcreigh: eventually we should use XCB ;-)
18:41:50 <jcreigh> dons: or that, yes.
18:42:22 <jcreigh> I think whoever did the first shot at ignoring numlock was a little confused. (lockMask is capslock, not numlock)
18:42:31 <narain> dcoutts: ah, i have yet to go through that series of articles
18:42:41 <jcreigh> at least, that's what it appears to be.
18:42:43 <dons> jcreigh: might have been me. i certainly did the original code on masking.
18:42:48 <narain> though they are high on my todo list.
18:42:51 <dons> but not sure we tried to handle numlock *at all* originally
18:43:12 <dons> i think i just tried to get no modifier, and capslock , working
18:43:42 <jcreigh> ah, that would explain numlockMask formerly defaulting to lockMask
18:44:01 <jcreigh> well, 00, 01, 10, 11 should work now. :)
18:44:02 <black_13> QtPlatypus, texas tech durning the late 80s and early 90s :)
18:44:53 <black_13> QtPlatypus, you have a way of view the world your always make a better fortrain and essentiall all your programs are void main() { do something return }
18:45:00 <jcreigh> so I figure if we just hope that numlock is mod2mask, we should cover most of the case. If we still have people running into that people, we'll have to do some magic.
18:59:32 <jcreigh> sjanssen: people keep mentioning XCB...how long do you think it will be before we can port xmonad to it?
19:01:16 * sorear reminds jcreigh that sjanssen has $5k of incentive to finish xhsb before September
19:03:25 <dons> jcreigh: i'd imagine a fe months away yet.
19:04:37 <jcreigh> okay...I'm just trying to get a feel for how practical it actually is to say "we'll fix that in the XCB version"
19:05:09 <jcreigh> I'm trying to avoid wrapping the XModifierKeymap struct. :)
19:05:14 <dylan> xcb-xmonad could be v2. ;)
19:06:48 <sorear> wow, two major versions away...
19:07:09 <dylan> pssh, it could be one version away
19:07:38 <sorear> we're at version 0 now
19:07:47 <dylan> v0 to v2 then.
19:07:49 <dylan> skip 1
19:07:49 <sorear> well, 0.1 to be precise
19:13:38 <jcreigh> when we do switch to XCB, it probably should be a major version bump. So xcb-xmonad might indeed end up being xmonad 2.0
19:18:01 <thoughtpolice> what exactly are the advantages of XCB compared to just standard Xlib.
19:18:14 <thoughtpolice> i mean, I know, xlib is kind of ew, but i'm simply wondering.
19:18:31 <sorear> xlib is very ew.
19:18:32 <jcreigh> supposedly, we could actually do threading the xcb.
19:18:36 <sorear> that's the reason.
19:19:12 <sorear> for quite a few values of ew... it's 20x larger than it needs to be, it is thread unsafe, it is synchronous, it has a huge api, ...
19:19:34 <gravity_> 20 years of cruft
19:19:55 <thoughtpolice> delicious
19:20:27 <sorear> xcb/xmonad will use far less ram than xlib/dwm, even after you factor in the GHC RTS
19:20:50 <jcreigh> For example, since this is the most recent thing that ticked me off: The XModifierKeymap structure: http://tronche.com/gui/x/xlib/input/keyboard-encoding.html#XModifierKeymap
19:20:53 <lambdabot> Title: Xlib Programming Manual: Keyboard Encoding, http://tinyurl.com/2dxpco
19:21:19 <jcreigh> 	int max_keypermod;	/* This server's max number of keys per modifier */
19:21:20 <jcreigh> 	KeyCode *modifiermap;	/* An 8 by max_keypermod array of the modifiers */
19:21:20 <sorear> only 2 fields
19:21:39 <sorear> is that bad?
19:23:46 <jcreigh> Well, other functions take this struct. So it's hard to do meaningful FFI with something like that.
19:24:13 <jcreigh> That's more of C gripe, though.
19:24:31 <jcreigh> "Data structures? We don't need to stinkin' data structures."
19:24:36 <jcreigh> s/to/no/
19:26:17 <jcreigh> also, you free this structure with XFreeModifiermap(), instead of XFree()
19:27:19 <jcreigh> Which seems strange to me, because all other memory allocated (that I've seen) in xlib is freed with XFree(). But *no*, the modifier map is special.
19:27:43 <ndm> @pl \x -> f x cons
19:27:44 <lambdabot> flip f cons
19:27:46 <jcreigh> </rant>
19:28:04 <thoughtpolice> i thought that's only what you're supposed to tell them. not it actually be true. :(
19:28:54 <sjanssen> jcreigh: xcb is a few months off
19:29:33 <jcreigh> sjanssen: ah, okay
19:29:39 <sjanssen> I can guarantee a release of the library before September of this year
19:29:55 <sjanssen> it may be considerably sooner
19:30:36 <jcreigh> sjanssen: did you see my stop-gap fix for numlock?
19:30:52 <sjanssen> and these patches might be sufficient.  It's hard to say, because numlock handling was just totally wrong before
19:31:05 <sjanssen> at least users can set the mask manually and it will work
19:31:12 <jcreigh> yeah.
19:32:19 <jcreigh> I'm just going to leave it at that; if some people still have problems, we'll have to do some magic at that point.
19:32:22 <monochrom> @botsnack
19:32:22 <lambdabot> :)
19:32:27 <monochrom> @src words
19:32:29 <lambdabot> words s = case dropWhile isSpace s of
19:32:29 <lambdabot>     "" -> []
19:32:29 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
19:35:15 <jcreigh> now all we need is sane handling of transient windows, a statusbar, and xmonad will be perfect. :)
19:35:41 <sjanssen> yes, so very close
19:35:42 * gravity_ coughs *compositing manager*
19:35:47 <sjanssen> @slap gravity_
19:35:48 * lambdabot slaps gravity_
19:35:56 <jcreigh> gravity_: what's that?
19:36:35 <gravity_> jcreigh: It handles the compositing extension. compiz is the primary example these days, although OSX does it too with their GUI
19:36:58 <jcreigh> umm...sorry, I guess I should have asked "what's compositing"?
19:37:04 <gravity_> Ah, sorry :-)
19:37:12 <jcreigh> eyecandy?
19:37:24 <sjanssen> jcreigh: yes
19:37:35 <gravity_> It allows eyecandy, but it's not inherently so. The idea is to draw offscreen. Then have a separate program assemble the pieces.
19:38:06 <jcreigh> oh. so it can make them fly around, stretch, shrink or whatever.
19:38:06 <gravity_> A non-eyecandy benefit is that apps aren't aware of expose events, so they don't have to redraw every time you move a window or whatever. This allows Xorg to not have window tearing any more.
19:38:34 <sjanssen> gravity_: do you know much about the technical issues of using a compositing manager?
19:38:36 <gravity_> It also speeds up remote X11 apps from having to deal with round trip drawing calls under some cases
19:38:51 <sjanssen> ie. what would xmonad need to do to take advantage of this
19:39:36 <gravity_> sjanssen: A bit. I haven't looked at compiz in detail. I'm not sure xmonad is really the right wm to have a composing manager, since it's a tiled wm
19:40:06 <gravity_> sjanssen: I was more joking about it, because people do associate it with eye candy :-)
19:40:18 <gravity_> compositing is a cool problem though
19:40:25 <sjanssen> gravity_: you still see tearing/flicker on workspace changes in xmonad
19:40:39 <sjanssen> I wouldn't mind eliminating that -- as long as it's easy and doesn't cause compatibility issues
19:41:26 <gravity_> sjanssen: Yeah, so you'd want to look at the composite extension. You basically have the X server redirect drawing to offscreen buffers, and then the compositing manager (which is the WM these days) assembles them.
19:43:16 <sjanssen> I wonder why the X server can't just handle this transparently
19:44:19 <dolio> Then it'd be harder to have windows disappear in a burst of flame on minimize. :)
19:45:05 <gravity_> hehe
19:45:11 <sjanssen> I find those sorts of effects annoying
19:45:25 <sjanssen> but I suppose they should be possible, from a technical standpoint
19:45:29 <dolio> Yeah. They're fun to play with for a few minutes at a time, though.
19:45:44 <jcreigh> What the heck? type KeyCode = Char? But XGrabKey() takes an int for the keycode!
19:45:53 <sorear> Char is int!
19:45:55 <sorear> ;)
19:46:12 * sorear *gape* at this abuse of wchars
19:46:20 <gravity_> sjanssen: I think it followed from the same philosophy that gave us separate wm's and widget sets
19:46:41 <gravity_> sjanssen: Although in practice, it's turned out that the compositing needs to be done by the wm itself, it seems to have been the right move to separate it
19:47:09 <sorear> so, xcompmgr is dead?
19:47:14 <sjanssen> gravity_: I think all windows should be composited by the graphics card by default -- it's obviously the right choice on modern hardware
19:47:22 * sorear has pretty much never heard of compiz
19:47:23 <gravity_> sjanssen: Right
19:47:30 <gravity_> sorear: Pretty much.
19:48:11 <sorear> Back when I played with compositing xcompmgr was the only option.
19:48:22 * jcreigh wonders how much video RAM his s3 virge has....
19:48:31 <dolio> KDE's window compositing still uses a fork of xcompmgr, I think.
19:48:31 <sorear> actually, all I ever used it for was transparent xclocks.
19:48:35 <jcreigh> hmm, 2 megs.
19:48:37 <dolio> Although that's getting replaced in 4.0.
19:48:54 <sjanssen> okay, so compositing isn't the right choice for jcreigh's hardware :)
19:49:02 <jcreigh> heh
19:49:10 <gravity_> dolio: Yeah, the new one sounds like a good piece of work
19:49:13 <sorear> since then, I discovered that a small baterry-powered digital clock sitting on top of the monitor is much more user-friendly.
19:49:23 <sorear> it doesn't obscure anything
19:49:38 <jcreigh> > 800 * 600 * 24
19:49:40 <lambdabot>  11520000
19:49:44 <sorear> and yes, this was BEFORE i disavowed x entirely
19:49:48 <jcreigh> see? Plenty to spare. :)
19:49:50 <plediii> I take it you don't use an lcd monitor
19:50:00 <jcreigh> err, *3, rather
19:50:03 <sorear> plediii: Actually I do.
19:50:27 <plediii> hmm, then you must have a thin clock :) ?
19:50:29 <sorear> I moved the clock about a foot to the left when I got the lcd, now it's on the case of the computer proper
19:50:37 <plediii> ah
19:51:00 <plediii> it's a good idea
19:51:58 <plediii> sorear: without x, how do you browse the web?
19:52:05 <plediii> you don't miss pictures?
19:52:18 <sorear> elinks, and fbi.
19:52:38 <sorear> i can see the pictures, on the rare cases when they are actually important
19:52:54 <sorear> i can't see them in context, but that turns out to be a very minor limitation
19:53:32 <sorear> fbi and its kin are very eager to change video modes, but that's much less annoying now that I have an lcd monitor ;)
19:53:53 <plediii> i guess you don't mod up the pics on reddit
19:53:59 <sorear> I still use X fo
19:54:21 <plediii> elinks looks nice, I may have to try it someday
19:54:35 <sorear> r two mostly-equivalent programs
19:54:38 <sorear> gv and xpdf
19:54:57 <sorear> starting and controlling them requires xterm and xmonad
19:55:20 <sorear> alas, there is no good console pdf viewer :(
19:55:46 <sorear> so the haskell academians are the only thing keeping X installed.
19:56:03 <plediii> heh
19:56:07 * sorear likes reading papers enough to tolerate an hour of X a week
19:56:14 <gravity_> heh
19:56:30 <emu> printer!
19:58:06 <jcreigh> to run in console, I'd have to break the firefox and the multi-head habits.
19:58:50 <emu> is there a widescreen console mode
19:59:24 <sjanssen> to run in console, I'd have to break the xmonad habit!
20:00:17 <carmen> xmonad for directfb
20:00:21 <carmen> mm
20:06:37 <dons> re.
20:08:01 <thoughtpolice> jcreigh: links is undoubtly the best text browser ever made.
20:08:16 <thoughtpolice> or browser ever made, period. you know it to be true.
20:08:17 <dons> heh. you reckon?
20:08:32 * dons suggests w3m as a better example :-)
20:08:40 <Korollary> Are there any big automated theorem provers written in haskell?
20:09:00 <dons> Agda is one.
20:09:13 <dons> the new ProofGeneral frontend to Isabelle is written in Haskell as well
20:09:24 <dons> Korollary: check the 'theorem provers' page on haskell.org, under 'applications and libraries'
20:09:32 <dons> the entire catalogue is listed there
20:09:55 <Korollary> ah
20:10:17 <monochrom> Godawful.  I mean Excellent.
20:10:56 <monochrom> Sounds like I don't need to write frontends in Java anymore. :)
20:11:38 <dons> you sick, twisted boy. ;-)
20:12:22 <Korollary> Both agda and cayenne admit being still in development.
20:13:13 <ddarius> @google Yarrow proof
20:13:16 <lambdabot> http://www.cs.ru.nl/~janz/yarrow/
20:13:16 <lambdabot> Title: Yarrow Home Page
20:13:22 <dons> Korollary: what are you looking for precisely?
20:13:46 <dino-> What happens when somebody calls System.Posix.Files.createLink when running on Windows?
20:14:02 <dons> they don't have System.Posix.Files, would they?
20:14:20 <dons> isn't that in package unix?
20:14:22 <monochrom> Probably can't compile.
20:14:24 <dino-> Ah, is that what happens, that module isn't present in theirs.
20:14:27 <dino-> yeah
20:14:35 <dons> they don't have that package then.
20:14:37 <Korollary> dons: I am likely to mess with Coq or Isabelle or Twelf and trying to stay away from ML if possible.
20:14:51 <Korollary> dons: Maybe FOL will do. I'll browse around more.
20:14:52 <dons> Korollary: yeah, i think those are the main options though.
20:15:02 <dons> the haskell-ish ones are more experimental.
20:15:21 <dons> Isabelle is pretty well established in haskell land though. as is twelf (to a lesser extent)
20:15:26 <ddarius> Uh... has Cayenne been touched in years?
20:15:36 <dons> e.g. the l4/haskell kernel guys generate haskell from isabelle proofs
20:15:47 <sorear> @seen augustss
20:15:48 <ddarius> Noone ever talks about Yarrow.  Why is that?
20:15:48 <lambdabot> augustss is in #haskell. I last heard augustss speak 5h 5m 2s ago.
20:17:45 <dons> @seen glguy
20:17:46 <lambdabot> glguy is in #haskell. I don't know when glguy last spoke.
20:19:21 <fantasma> dons: do you thing xmonad would build with ghc5?
20:19:53 <dmead>  Crazy...
20:19:53 <dmead>  By B. Janssen (2.05) on 2007-04-22 21:38:01 UTC
20:19:53 <dmead> I was thinking about writing a WM in Haskell only a few days ago... but I doubt I could do such a good job. The code is very clean and I'm glad to see that one of the authors is doing the Summer of Code project for the X11-Haskell bindings. Very promising.
20:19:56 <dmead> ah ah
20:20:44 <Cale> ddarius: The pseudorandom number generator?
20:21:03 <dons> fantasma: ghc 5? hmm. maybe. i don't see any obvious reason why not. (except for newtype deriving, how new is that?)
20:21:17 * sorear can confirm lambdabot does not work with 6.2.2
20:21:20 <dons> fantasma: you're on your own though :-)
20:21:22 <Cale> oh, http://www.cs.ru.nl/~janz/yarrow/
20:21:23 <lambdabot> Title: Yarrow Home Page
20:21:38 <dons> dmead: you think its sjanssen's evil twin?
20:21:39 <sorear> dons: someone said yesterday 6.2.2 predates Data.Map
20:21:44 <dons> it does.
20:21:50 <dons> we used Data.FiniteMap back then
20:21:53 <dmead> ooh maybe
20:21:56 <dons> but there are compat libs.
20:22:53 <dons> sorear: so you going to HOPL 3 in San Diego,  in June?
20:28:46 <dons> http://programming.reddit.com/info/1keng/comments is nice.
20:28:47 <lambdabot> Title: Massively parallel processing: the end of sequential programming (reddit.com)
20:29:13 <sorear> hehehe.  if I can find an excuse to go, certainly ... sandiego is a big enough place that you can't exactly attend without noticing...  nor do I quite have the selfconfidence to *ask*
20:35:43 <jcreigh> dmead: I also wondered if there was any relation between bjanssen and sjanssen
20:36:08 <dmead> brother maybe?
20:36:32 <jcreigh> but you'd think he would have heard about xmonad before now, if he was into Haskell as well.
20:36:59 <jcreigh> probably just a coincidence
20:37:22 <sjanssen> I don't think I know B. Janssen
20:42:34 <jcreigh> I don't supposed there's a "Threading for dummies" type-tutorial for Haskell multi-threaded programming, is there?
20:43:07 <dmead> ?src showPrec
20:43:07 <lambdabot> Source not found. Just what do you think you're doing Dave?
20:43:14 <dmead> @hoogle showPrec
20:43:15 <lambdabot> No matches found
20:43:18 <LoganCapaldo> No, but I think theres a threading and its heretofore unknown relationship with category theory for Epigram programmers ;)
20:43:30 <magnus_> ?src showsPrec
20:43:31 <lambdabot> showsPrec _ x s = show x ++ s
20:43:34 <dmead> ah
20:44:44 <Korollary> jcreigh: That would be a good tutorial. It's all scattered across many papers.
20:47:21 <jcreigh> dons, sjanssen: Couldn't the threading problem in xmonad be gotten around by having only one thread make xlib calls?
20:48:30 <sjanssen> jcreigh: that's the start of a solution
20:48:58 <sjanssen> it's all kinda tricky
20:49:01 <jcreigh> yeah...
20:49:21 <Korollary> What is the problem with xlib threading?
20:49:31 <jcreigh> xlib isn't thread-safe, I believe.
20:49:40 <sorear> XInitThreads!
20:50:00 <Korollary> is xmonad running multiple os threads?
20:50:07 <jcreigh> not currently.
20:50:12 <sorear> man XInitThreads
20:50:26 <sjanssen> sorear: it's probably more convenient to do the mutual exclusion in Haskell
20:50:33 <sorear> Korollary: if you use the threaded rts, then foreign calls are made in new os threads
20:50:37 <sorear> well, a pool
20:50:41 <Korollary> ah
20:52:03 <jcreigh> hmm, so "XInitThreads()" is a "make it work" function.
20:52:37 <sjanssen> maybe
20:52:46 <jcreigh> ./Graphics/X11/Xlib/Misc.hsc:-- XInitThreads omitted (leary of thread stuff)
20:52:48 <jcreigh> haha
20:52:58 <sjanssen> I don't blame him
20:53:15 <sjanssen> the man page says absolutely zero about what "threading support" means
20:53:22 <jcreigh> the other scary thing about threading, is that some functions, eg, displayWidth, are exported as pure functions.
20:53:46 <Korollary> Can displayWidth change?
20:53:58 <sorear> xrandr!
20:54:04 <jcreigh> Korollary: hmm, now that you mention it...
20:54:12 <sjanssen> do all calls just block on the display?
20:54:25 <jcreigh> Korollary: I know it can with xrandr, but I don't know if that changes what X11 reports as the display size...
20:54:43 <sjanssen> will other calls complete if a thread is blocking in XGetEvent?
20:59:28 <sjanssen> sorear: do you know much about this?
20:59:35 <Korollary> Can you have a dedicated thread do the xlib calls and have others delegate to it via Chans?
20:59:54 <sorear> sjanssen: if this \subsetof xlib, then no.
21:00:23 <sjanssen> sorear: you knew about XInitThreads ;)
21:00:26 <Korollary> argh. blocking calls don't work.
21:00:45 <sjanssen> Korollary: probably not
21:01:09 * sorear is trying to understand a 2k line c program ... memset(hash,0,4*HASHSIZE); (hash is an array of longs)
21:01:30 <sjanssen> because there's no simple way to poll for both X events and stdin simultaneously
21:01:53 <sorear> not 'simple', but fairly easy.
21:02:02 <sorear> if you have threads, it will work.
21:02:11 <sjanssen> interfacing to C is the only way I see to do it
21:02:13 <jcreigh> I wonder if we would be fools to try and see if XInitThreads() actually works.
21:02:30 <sjanssen> (C's select(), that is)
21:02:48 <sorear> haskell's threads are built on C select.
21:03:25 <sjanssen> I suppose it is possible
21:03:28 <sjanssen> but quite ugly
21:03:57 <sorear> I'm pretty sure you want ConnectionNumber
21:04:25 <sjanssen> sorear: I know you can get an fd out of a display
21:05:14 <sorear> haskell threads seem right
21:07:25 <sorear> daemon = unsafePerformIO $ newChan >>= \c -> forkIO (sequence_ (repeat (join (readChan c)))) >> return c
21:07:26 <sorear> doit a = do v <- newEmptyMVar ; writeChan daemon (a >>= putMVar v) ; takeMVar v
21:08:28 <sjanssen> the problem is not blocking in XNextEvent
21:08:34 <sjanssen> avoiding blocking, rather
21:09:04 <sorear> you could open two connections and bounce stdin using SendEvent on the second connection
21:09:18 <sorear> that would be ugly, but constant factor ugly
21:09:53 <sorear> or does X11 use a global Display* variable?
21:09:53 <sjanssen> two connections == double memory
21:09:53 * sorear wouldn't put it past hsX11
21:09:58 <sjanssen> sorear: I don't think -package X11 does anything nasty like that
21:10:32 <sjanssen> and two connections == same implementation as two processes, essentially
21:10:41 <sorear> hmm, I'd have thought the memory consumption of -package X11 was mostly fixed stuff like tables
21:11:12 <sjanssen> sorear: I *think* most of the stuff is display specific
21:11:21 <sjanssen> caches and the like
21:11:30 <sjanssen> but I don't honestly know
21:11:45 <sorear> you could poke a X_SendEvent record down the connection using System.Posix.Files :)
21:12:14 <sorear> that *should* be safe during NextEvent
21:12:29 <jcreigh> http://tronche.com/gui/x/xlib/display/threads.html
21:12:31 <lambdabot> Title: Xlib Programming Manual: Using Xlib With Threads
21:12:32 <jcreigh> fairly sparse.
21:12:35 <sorear> er, nm, you'd need to find some way to fix xlib's idea of the request serial number....
21:12:46 <sjanssen> jcreigh: ha, worse than the man page
21:13:07 <LoganCapaldo> If only all apis were that simple!
21:13:16 <jcreigh> I hate docs like that: FrobTheWhosit(): Frobs the whosit.
21:13:23 <sjanssen> s/simple/poorly specified
21:13:25 <jcreigh> Tell me something I don't know!
21:14:35 <Korollary> It frobs the whosit and takes no arguments
21:14:40 <sjanssen> if we could write an XNextEvent that doesn't constantly block the entire display, we'd be done
21:15:18 <sorear> If Haskell didn't use lightweight threads, we'd be done.
21:15:39 <sorear> if haskell didn't use userspace threading, a LOT of things would be so much easier!
21:16:09 <jcreigh> s/haskell/ghc/, right?
21:16:14 * LoganCapaldo was under the impression (mistaken?) that forkOS made a real thread
21:16:25 <sorear> LoganCapaldo: very, very, mistaken
21:16:42 <jcreigh> bit of a deceptive name, then.
21:16:44 <sorear> well, it makes a real thread, but all haskell code is executed in a us thread
21:16:57 <sorear> the new real thread is only used for foreign calls
21:17:25 <sorear> jcreigh: show me a haskell implementation that is usable for non-toy programs and isn't called GHC
21:17:52 <jcreigh> sorear: so yes? :)
21:18:04 <sorear> sjanssen: select is very incompatible with greenthreads -but- it just occurred to me epoll wouldn't be.  can we bind that?
21:19:00 <jcreigh> does that help us? just because there's data in the X11 fd doesn't mean there's an event, right?
21:19:08 <jcreigh> or do I misunderstand?
21:19:18 <dataangel> I went through the Haskell tutorial for C programmers awhile back, and I remember "main = putStrLn (show 4)" used to cause haskell not to be able to infer the type of 4, since it belongs to the Num type class and not a specific type. But going through the tutorial again a few months later, it seems to work in both GHC and Hugs! Before I was running windows hugs and now I'm on Ubuntu, but I don't see why that should make a difference. Ideas?
21:19:18 <sorear> I think it does.
21:19:41 <sorear> dataangel: look up defaulting
21:20:36 <sorear> jcreigh: there are three things that come in on X sockets.  errors, which cause XNextEvent to bottom (as good as returning); events, which cause it to return; and replies, which can't happen because all non-void X functions are synchronous.
21:21:23 <sorear> jcreigh: since all things-that-come-in (except replies?) are exactly 32 bytes long, they won't be fragmented except under extremely pathological circumstances.
21:22:05 <dataangel> sorear: I've found a haskell report link about it, but it doesn't say when it was added. Is it part of the 98 standard but that just wasn't toggled on by default in hugs before or ... ?
21:22:12 <sorear> (btw, that fixed-size was a very early design decision, and bandaiding it is the reason we have atoms)
21:22:24 <sjanssen> we want to use XPending, I think
21:22:50 <sjanssen> let me write some pseudo code
21:22:53 <sorear> dataangel: it is in 98; the haskell.org/definition has links to all the old haskell reports
21:23:00 <jcreigh> oh, looks perfect.
21:23:07 <jcreigh> s/perfect/workable/ :)
21:23:09 <sorear> sjanssen: ah, so select, then do a "non blocking XNextEvent"?
21:23:10 <dataangel> thanks :)
21:23:18 <sorear> s/select/epoll/
21:23:37 <jcreigh> well, we could have one Haskell thread doing X11 if we don't have to block on getting the next event, right?
21:24:17 <sorear> jcreigh: If xmonad starts polling, someone is going to get * sorear beats up ;)
21:24:51 <jcreigh> hmm. oh, you're right, you would need to poll in that case. nevermind.
21:28:03 <hpaste>  sjanssen pasted "safeNextEvent" at http://hpaste.org/1541
21:28:17 <hpaste>  sjanssen annotated "safeNextEvent" with "typo" at http://hpaste.org/1541#a1
21:28:35 <sjanssen> so a combination of blocking and polling
21:28:55 <sorear> sjanssen: (a) that's not pseudo code (b) that won't work
21:29:03 <jcreigh> sjanssen: i think xpending reyutns an int
21:29:10 <sorear> sjanssen: handles in ghc are set to non blocking, that will kill xlib I'm sure
21:29:13 <jcreigh> err, can't type one-handed.
21:29:29 <sjanssen> so xmonad's main loop will be pretty much the same, with safeNextEvent instead of nextEvent
21:29:44 <sjanssen> sorear: is non-blocking your only complaint?
21:29:49 <sorear> sjanssen: yes.
21:30:23 <sorear> sjanssen: if you treat hWaitForInput as a magic function that doesn't screw up xlib, that code looks perfect.
21:30:44 <sorear> sjanssen: eg, a select/poll/epoll binding
21:31:01 <sorear> epoll would have the advantage of not requiring an extra os thread
21:31:04 <sjanssen> sorear: often, I accidentally write real Haskell when I want to write pseudo code
21:31:12 <sorear> how portable is epoll?
21:31:28 <jcreigh> The epoll API is Linux specific.  Some other systems provide similar mechanisms, e.g., FreeBSD has kqueue, and Solaris has /dev/poll.
21:31:32 <jcreigh> ^^ epoll manpage
21:32:17 <sorear> aww, I don't suppose we can persuade dons to switch.  select/poll?
21:32:56 <sjanssen> select means C code in xmonad.  I'd like to avoid that at all costs
21:33:17 <sorear> why does it need C?
21:33:35 <sjanssen> C bindings, at least
21:33:36 <sorear> oh, you mean you for FD_SET et al.
21:33:51 <sjanssen> and I think most of the "functions" for select are actually macros
21:34:20 <sorear> poll would require a foreign import and a few lines of ffi code
21:34:28 <sorear>            struct pollfd {
21:34:28 <sorear>                int   fd;         /* file descriptor */
21:34:28 <sorear>                short events;     /* requested events */
21:34:28 <sorear>                short revents;    /* returned events */
21:34:31 <sorear>            };
21:34:41 <sorear> your challenge is to marshal this
21:35:07 <sorear> somehow I don't think dons will appreciate us using Data.Bits to do the job
21:35:21 <sorear> even though it would be like 6 loc
21:35:42 <jcreigh> hsc2hs + soul-crushing boilerplate should do the job.
21:35:48 <sorear> do 64-bit computers exist yet?
21:35:51 <sorear> :p
21:35:59 <jcreigh> sorear: no. in 2038 the world ends. :)
21:36:05 <sjanssen> I estimate this is 10 loc
21:36:31 <sorear> I don't suppose we can hide it in x11-extras? ;)
21:37:07 <sjanssen> providing safeNextEvent *might* be okay
21:37:38 <sorear> man, reading C is funky after your eyes are used to laziness and monads
21:37:44 <jcreigh> Do we have a magic Display -> FileDescriptor function? I hope it's not "const 3"
21:37:56 <sjanssen> jcreigh: it's in xlib somewhere
21:37:59 <sorear> jcreigh: I'm pretty sure it's called ConnectionNumber
21:38:15 <sorear> jcreigh: actually, I'd wager it's a macro :(
21:38:38 <sjanssen> macros are so asinine
21:38:57 <jcreigh> #define ConnectionNumber(dpy) 	(((_XPrivDisplay)dpy)->fd)
21:39:04 <jcreigh> sorear wins the prize.
21:39:13 <fantasma> when cabal installs a library does it create files in /usr/local/lib/package-name/ghc/blah AND /usr/local/lib/ghc/blah ?
21:39:41 <sorear> stefan@stefans:/usr/local/src/dblife-7.4$ nm --dy /usr/lib/libX11.so | grep Numbe
21:39:41 <sorear> 00029260 T XConnectionNumber
21:39:54 <jcreigh> gah, there's scads of "functions" that are actually thin macros around the display struct.
21:39:55 <sorear> it looks like we have an undocumented, real, function
21:40:20 <sjanssen> I think -package X11 already provides ConnectionNumber
21:40:33 <jcreigh> oh. I wonder what the difference between ConnectionNumber and XConnectionNumber is.
21:40:38 <sorear> this looks fun, man XInternalConnectionNumbers
21:41:08 <sorear> also read the *Watch entries
21:42:32 <sjanssen> X11 has an internal binding to select
21:42:48 <jcreigh> X11 == Haskell X11 binding?
21:43:05 <sjanssen> foreign import ccall unsafe "HsXlib.h" select -- oh dear God
21:43:09 <sjanssen> jcreigh: yeah
21:43:22 <sjanssen> anyone see what is wrong with that picture?
21:43:39 <sorear> uh...
21:43:44 <sorear> yes!
21:43:54 <sorear> is the -- oh dear God yours?
21:44:01 <sjanssen> sorear: yes
21:44:24 <sorear> who CAN'T see what's wrong with that?
21:45:58 <jcreigh> it looks like it only uses it in waitForEvent
21:46:25 <sjanssen> yeah, so it seems
21:46:54 <jcreigh> so, forgive me, but what is horribly wrong with select() here?
21:47:01 <sjanssen> jcreigh: the "unsafe" keyword
21:47:05 <sjanssen> that says that it won't block
21:47:28 <sorear> is it ever called with a nonzero timeout parameter?
21:47:41 <jcreigh> oh! I kinda wondered what "unsafe" meant.
21:48:00 <sorear> jcreigh: it also means that it won't call any foreign exported functions
21:48:05 <sjanssen> sorear: I think it's only used in one spot -- which does give a timeout parameter
21:48:17 <sjanssen> so it isn't quite as bad
21:48:20 <sorear> sjanssen: C doesn't have optional parameters :)
21:48:41 <sorear> every call ought to give a timeout parameter
21:48:56 <jcreigh> sorry, forgive me again: "foreign exported functions"? Haskell functions exposed to C?
21:49:04 <sorear> right
21:49:15 <sorear> using *drum roll* foreign export
21:49:21 <jcreigh> heh
21:49:30 <sorear> or foreign import "dynamic", but that's just evil
21:50:02 <jcreigh> so the advantage of saying "unsafe" is that GHC can...lock fewer things?
21:50:10 <sorear> yeah.
21:50:13 <sjanssen> sorear: if you want to split hairs, the timeout param is always non-NULL
21:50:28 <sjanssen> jcreigh: "safe" calls spin off a new OS thread for each call
21:50:36 <sorear> jcreigh: also, an unsafe foreign call never calls haskell, and thus never calls the GC
21:50:43 <sjanssen> (they're taken from a pool, so it's not quite as bad as it sounds)
21:50:47 <sorear> jcreigh: so ghc can assume pointers don't move across it
21:51:20 <sorear> in the Old Days unsafe just meant no-callbacks, and select certainly satisfies that
21:51:33 <sorear> but it affects threading too, now
21:51:43 <sorear> it's even documented that way in spj's paper
21:51:55 <sorear> Extending the Foreign Function Interface with Concurrency
21:52:01 <sorear> or somethjink like that.
21:52:38 <sjanssen> at this point, it's either:
21:52:41 <jcreigh> wait. So does that mean that if we could set an error handler for X11 from Haskell, everything would break because there's all these functions tagged "unsafe" which in fact might callback to Haskell?
21:52:46 <jcreigh> (just curious)
21:52:49 <sjanssen> 1.  write poll bindings
21:52:58 <sorear> jcreigh: yes.
21:53:10 <sjanssen> 2.  write the status bar as a separate process
21:54:05 * sorear finds 'x' and 'y' extremely unhelpful names for indexing variables
21:54:23 <sjanssen> 2 probably means we won't be able to do workspace switching on statusbar clicks (like dwm does)
21:54:58 <jcreigh> There's also awkward IPC issues. (How does xmonad know, eg, how high the status bar is?)
21:55:24 <jcreigh> and the statusbar process would have to know about Xinerama, or we would have to spawn one per screen.
21:55:39 <jcreigh> probably the former would be easier.
21:55:43 <sjanssen> xinerama is okay -- X11-extras makes that easy
21:56:00 <sjanssen> and shouldn't the status bar be a constant height in pixels?
21:56:07 <jcreigh> well, depends on the font.
21:56:19 <sorear> no, it should change depending on the phase of the moon.
21:56:20 <sorear> Duh.
21:56:41 * sorear isn't sure where that came from.
21:56:51 <jcreigh> @google bug phase of the moon
21:56:53 <lambdabot> http://en.wikipedia.org/wiki/Heisenbug
21:56:53 <lambdabot> Title: Unusual software bug - Wikipedia, the free encyclopedia
21:57:14 <jcreigh> @google jargon file bug phase of the moon
21:57:18 <lambdabot> http://www.dourish.com/goodies/jargon.html
21:57:18 <lambdabot> Title: The Original Hacker's Dictionary
21:57:19 <sorear> @jargon phase of the moon
21:57:23 <lambdabot> *** "phase" jargon "Jargon File (4.3.1, 29 Jun 2001)"
21:57:24 <lambdabot> phase 1. n. The offset of one's waking-sleeping schedule with respect
21:57:24 <lambdabot>    to the standard 24-hour cycle; a useful concept among people who often
21:57:24 <lambdabot>    work at night and/or according to no fixed schedule. It is not uncommon
21:57:24 <lambdabot>    to change one's phase by as much as 6 hours per day on a regular basis.
21:57:25 <lambdabot> [21 @more lines]
21:57:29 <sorear> @more
21:57:29 <lambdabot>    "What's your phase?" "I've been getting in about 8 P.M. lately, but I'm
21:57:30 <lambdabot>    going to {wrap around} to the day schedule by Friday." A person who is
21:57:31 <lambdabot>    roughly 12 hours out of phase is sometimes said to be in `night mode'.
21:57:33 <lambdabot>    (The term `day mode' is also (but less frequently) used, meaning you're
21:57:35 <lambdabot>    working 9 to 5 (or, more likely, 10 to 6).) The act of altering one's
21:57:37 <lambdabot> [16 @more lines]
21:59:12 <jcreigh> Of course, we could always just implement the statusbar as an one-line-high xterm. :)
21:59:49 <sjanssen> hmmm
21:59:51 <sorear> wouldn't that mostly rule out interactivity?
22:00:02 <jcreigh> I joke.
22:00:16 <jcreigh> but it's basically the same thing as implementing it as a separate process...
22:00:23 <sjanssen> sorear: that isn't necessarily true
22:00:32 <sorear> jcreigh: actually, we should probably implement the sbar as a unix domain socket, so anyone can access it
22:00:43 <sjanssen> curses apps can catch keypresses, right?
22:00:55 <sjanssen> s/keypresses/mouse clicks
22:01:10 <sorear> jcreigh: then, we can extend the layout algortihm with a rule to send *window name* to the bottom of the screen
22:02:03 <sorear> actually, we should allow that in config.hs.  we should make status/control in the core.
22:02:05 <sjanssen> you can actually get the active window's name from X11
22:02:38 <sorear> sjanssen: you realize you can do IPC entirely through X11, using property change events.
22:02:48 <sorear> sjanssen: we can pipe info to the sbar that way
22:02:54 <sjanssen> hmm
22:03:10 <sorear> methinks this is MUCH better than pipes, because it can work non-locally.
22:03:43 <sorear> and it's not an abuse of the feature, since it is already used as pipes by the ICCCM clipboard protocol.
22:04:02 <sjanssen> I'm not opposed to this idea
22:04:16 <jcreigh> eg, ratpoison does something similar to allow you to send commands to a running ratpoison in shell scripts and whatnot.
22:04:40 <bos> @hoogle map'
22:04:40 <sorear> it would mean no need for threading or select!
22:04:41 <lambdabot> No matches found
22:04:47 <sorear> bos: no such function.
22:05:08 <bos> boo, hiss.
22:05:33 <sjanssen> this also makes two way communication pretty easy
22:07:05 <jcreigh> hmm.
22:08:15 <jcreigh> I don't know...it still seems like unnecessary work to have to dump the XMonad state out, and then read it back in to interpret it, when all the data we really need is right there in xmonad.
22:08:40 <sorear> deriving(Show,Read)
22:08:51 <sorear> we're optimizing for LoC, not CPU
22:09:36 <sorear> actually, hmm, why do we need external control.
22:09:44 <jcreigh> I was trying to go for clarity and maintainability, but whatever. :)
22:09:44 <sorear> everything can be done in configure.hs
22:09:56 <sorear> this is interesting
22:10:01 <sorear> i just noticed
22:10:12 <sorear> i have a tendency to monologue when I get tired
22:18:12 <sjanssen> sorear: responding to anything but keypresses is currently impossible in Config.hs
22:19:34 <sorear> just bind mod-s to newWindow >>= blah ;)
22:22:02 <dons> jcreigh: read/show ? :-)
22:23:01 <LoganCapaldo> @src ((->) a) return
22:23:02 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
22:23:18 <LoganCapaldo> But I don't
22:23:24 <sorear> const, btw.
22:23:28 <sorear> @src (->) return
22:23:29 <lambdabot> return = const
22:23:38 <sorear> g'night all.
22:23:41 <LoganCapaldo> that maketh sense
22:24:18 <LoganCapaldo> night
22:24:57 <LoganCapaldo> @src (->) (>>=) -- (.) ?
22:24:57 <lambdabot> Source not found. Where did you learn to type?
22:25:02 <LoganCapaldo> @src (->) (>>=)
22:25:02 <lambdabot> f >>= k = \ r -> k (f r) r
22:25:35 <LoganCapaldo> @unpl ((.) .)
22:25:36 <lambdabot> (\ d g b c -> d g (b c))
22:26:12 <LoganCapaldo> bizzare
22:26:20 <Cale> return = K, ap = S
22:26:45 <LoganCapaldo> I never got "S"
22:26:51 <LoganCapaldo> K makes sense
22:26:57 <LoganCapaldo> S causes my brain to melt
22:27:09 <Cale> > ap (zipWith (,)) tail [1,2,3,4]
22:27:11 <lambdabot>  [(1,2),(2,3),(3,4)]
22:27:21 <Cale> > ap (zipWith (+)) tail [1,2,3,4]
22:27:22 <lambdabot>  [3,5,7]
22:27:28 <Cale> > ap (zipWith (-)) tail [1,2,3,4]
22:27:30 <lambdabot>  [-1,-1,-1]
22:27:42 <LoganCapaldo> that's a neat trick. Do you do parties? :)
22:27:58 <Cale> map (ap (,) (^2)) [1..10]
22:28:03 <Cale> > map (ap (,) (^2)) [1..10]
22:28:05 <lambdabot>  [(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]
22:28:25 <Cale> It's actually pretty handy.
22:28:46 <bos> hmm, printing the number of digits in 1000000! takes much longer than testing to see if it's odd.
22:28:59 <LoganCapaldo> hmm S f g x being f x (g x)
22:29:00 <Cale> You have a function of two parameters, and you want to apply it to two things of which one is a function of the other, and that's S, or ap.
22:29:09 <bos> it takes a while to run show on a 5565709-digit number.
22:29:15 <LoganCapaldo> that makes more sense with the examples
22:29:39 <Cale> bos: Well, it's obviously even :)
22:30:15 <bos> well, sure. but you have to compute the entire number to know that, if you're the haskell compiler :-)
22:30:15 <Cale> Showing a large factorial might take longer than just computing it all though.
22:30:22 <Cale> Right :)
22:30:24 <bos> yes, it takes much longer.
22:30:26 <LoganCapaldo> > (ap (:) (:[])) 2
22:30:28 <lambdabot>  [2,2]
22:30:37 <Cale> There are just so many digits to allocate space for.
22:30:43 <bos> 5 megabytes of digits is a lot for poor old tired String.
22:31:01 <Cale> LoganCapaldo: :)
22:31:15 <Cale> > ap (:) return 2
22:31:17 <lambdabot>  [2,2]
22:31:34 <LoganCapaldo> > (ap (,) id) 2
22:31:36 <lambdabot>  (2,2)
22:31:44 <Cale> > join (,) 2
22:31:46 <lambdabot>  (2,2)
22:32:08 <LoganCapaldo> >>= is ap
22:32:18 <Cale> Not quite.
22:32:22 <LoganCapaldo> and x >>= id is join x?
22:32:26 <LoganCapaldo> err
22:32:30 <LoganCapaldo> so much for that idea
22:33:07 <Cale> ap mf mx = mf >>=  \f -> mx >>= \x -> return (f x)
22:33:24 <LoganCapaldo> woah
22:33:59 <Cale> or, ap = liftM2 id
22:34:03 <LoganCapaldo> @redo mf >>=  \f -> mx >>= \x -> return (f x)
22:34:04 <lambdabot> do { f <- mf; x <- mx; return (f x)}
22:34:28 <Cale> Yeah, it's clearer in do-notation :)
22:34:41 <LoganCapaldo> @botsnack
22:34:41 <lambdabot> :)
22:34:54 <Cale> You're right about join = (>>= id)
22:35:42 <LoganCapaldo> Ooooooo
22:35:49 <LoganCapaldo> the do notation really does clear it up
22:37:58 <LoganCapaldo> > (ap (+) (+2)) 2
22:38:00 <lambdabot>  6
22:39:01 * LoganCapaldo waits for the obfuscated haskell contest
22:39:35 <Cale> Computations in the function monad are just functions waiting for that extra parameter. So running (+) with the environment 2 gives (2+), and running (+2) with the environment 2 gives (2+2), then (2+) is applied to (2+2) to give 6.
22:39:42 <LoganCapaldo> yep
22:40:15 <LoganCapaldo> I like the function monad
22:40:37 <LoganCapaldo> Its like currying but more interesting :)
22:43:09 <Cale> Yeah, it should definitely be in the Prelude.
22:43:25 <Cale> Another really nice thing to notice is that fmap for that monad is (.)
22:44:04 <Cale> So not only do we have map, fmap, liftM all being the "same", (.) is in there as well.
22:59:47 <ski> "function monad" ?
23:00:11 * ski *hmpf*s
23:01:06 <Lor> The plain reader monad?
23:01:47 * ski always preferred the name 'environment'
23:06:33 <Lor> That suggests a particular application.
23:07:58 <ski> and 'reader' doesn't ? :)
23:09:59 <Lor> Well... how about just "covariant hom-functor" then?
23:10:07 <Lor> Doesn't really roll off your tongue, though.
23:13:08 * ski smiles
23:13:32 <LoganCapaldo> How about the ((->) a) monad?
23:13:44 <LoganCapaldo> (that would appear to be even less tongue rolly)
23:33:17 <LeCamarade> let ls x = let dir = if null x then getCurrentDirectory else return x in dir >>= getDirectoryContents >>= mapM putStrLn >> return () in ls ""
23:33:32 <LeCamarade> > let ls x = let dir = if null x then getCurrentDirectory else return x in dir >>= getDirectoryContents >>= mapM putStrLn >> return () in ls ""
23:34:20 <LeCamarade> > let ls x = let dir = if null x then Directory.getCurrentDirectory else return x in dir >>= Directory.getDirectoryContents >>= mapM putStrLn >> return () in ls "" -- ls(1) - kinda.
23:37:38 <ski> @yarr
23:37:39 <lambdabot> Smartly me lass
23:52:45 <lokadin> ya! Go Haskell! :D
23:53:38 <lokadin> wb
23:54:07 <dolio> Boy, the nuts really do come out at 3 A.M. :)
23:54:34 <lokadin> dolio: :) I see my reputation precedes me
23:54:35 <lokadin> lol
23:55:26 <dolio> @yow!
23:55:26 <lambdabot> I KAISER ROLL?!  What good is a Kaiser Roll without a little COLE SLAW
23:55:27 <lambdabot> on the SIDE?
