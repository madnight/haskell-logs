00:00:16 <dfranke> I wouldn't expect it to be a problem.  Most nodes in the tree will involve IO, possibly network IO, and that'll likely overwhelm the tree-traversal overhead.
00:01:33 <sorear> Okay, then ignore my comment. :)
00:05:22 <monochrom> hee hee
00:06:04 <dolio> Did someone just poke you in the stomach?
00:06:29 <narain> :t minimumBy
00:06:33 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
00:06:49 <narain> :t comparing
00:06:51 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
00:08:03 <monochrom> Bulat just did, but that's fine. :)
00:08:11 <dolio> Heh.
00:09:47 <monochrom> I have an even more ingenious idea now. Why stop at shipping Linux and Vista with GHC?  They are all a pain to install yourself.  Ship a laptop with GHC preloaded!
00:10:21 <dolio> Pitch it to Dell. It'll increase their sales by millions.
00:10:33 <monochrom> Yeah! I'm thinking Dell too. :)
00:10:40 <kc5tja> With a clone of Apple's GS/OS written in Haskell called GH/OS.  :)
00:11:05 <monochrom> Apple ][GS wins
00:13:22 <kc5tja> See what happens when you get me all nostalgiac?  I need to play Missle Command now... ;D
00:13:31 <monochrom> OH! I get the GH/OS part now. :)
00:14:00 <kc5tja> hehe
00:14:09 <monochrom> Apple ProDOS won my admiration.
00:14:58 <kc5tja> I don't know anything about Apple stuff, really.  I've got the KEGS emulator and GS/OS System 6, but alas, that's as far as I've gotten.  I've always been a Commodore user in the past, so my knowledge rests with that environment.
00:17:02 <sorear> kc5tja: what is the default workflow of kestrelforth?
00:17:22 <kc5tja> I don't understand the question?
00:17:44 <sorear> Do you just type all your programs in at the prompt?
00:18:01 <sorear> how do users use persistant storage?
00:18:27 <kc5tja> If you're sadistic, I suppose you can.  :)  I will use a block editor personally.
00:18:31 <sorear> if you have blocks, do you have an edit-save-reload cycle?
00:19:21 <kc5tja> Well, edit/reload.  Saving is implicit.
00:19:54 <sorear> so you edit the block with your functions, and tell it to reload?  that's it?
00:20:03 <narain> :t liftM2 ?f id
00:20:03 * sorear has never used an image programming system
00:20:12 <lambdabot> forall a2 r a. (?f::a -> a2 -> r) => (a -> a2) -> a -> r
00:20:19 <sorear> s/functions/words/
00:20:47 <kc5tja> Right.  Your application will typically include "EMPTY" or some kind of marker to restore the dictionary pointer as its very first thing to do, so reloading the application will recompile the whole app.
00:21:10 <narain> :t liftM2 max abs abs
00:21:12 <lambdabot> forall a. (Ord a, Num a) => a -> a
00:21:30 <sorear> So you edit some of the blocks, then <startblock> load
00:21:36 <kc5tja> right
00:21:58 <sorear> I can see a forth compiler being really really fast, but wouldn't there be huge IO latencies here?
00:22:01 <kc5tja> Or define a :-definition to automate
00:22:22 <sorear> loading a hundred blocks every time you want to test something?
00:22:33 <kc5tja> In the case of the Kestrel, there will definitely be latencies, since the firmware will not be smart enough to use upper RAM as a RAM-disk.
00:22:37 <kc5tja> At least, not initially.
00:22:39 <eumenides> hrm. no Read/Show deriving for unboxed arrays? :(
00:22:51 <kc5tja> Another problem: loading hundreds of blocks.  "Don't do that."
00:22:55 <sorear> :-definition just means like ': foo 233 edit 233 load'
00:22:59 <kc5tja> You'll find it's awfully rare for a Forth app to exceed 30 blocks.
00:23:13 <kc5tja> And that's really, really pushing the limits.
00:23:26 <kc5tja> re: :-definitions -- yes.
00:23:33 <sorear> So I shouldn't try to write GHC in kestrelforth, ok :)
00:23:55 <kc5tja> You CAN, but also remember, you can code in layers too.
00:24:12 <kc5tja> Once a dependent layer is debugged, you can load it and forget it, concentrating on the reloading of another smaller unit of code.
00:24:37 <sorear> Ah, like --make but explicit.
00:24:45 <kc5tja> Precisely.
00:25:11 <kc5tja> Most Forth applications are written in the same structure as books -- block N is a block that loads other blocks (say, O, P, and Q).
00:25:30 <kc5tja> Then block O might load other blocks as needed, but going beyond two layers of hierarchy is considered bad form.
00:25:56 <kc5tja> So in some sense, the top-most block doubles as your makefile and your linker.
00:26:47 <kc5tja> Speaking of which, I need to work on re-implementing the target Forth compiler...
00:26:50 <sorear> So (I'm probably showing idiocy here) how do you keep track of which blocks go to which reusable program, and which reusable programs you have?
00:27:04 <sorear> I can't imaging programming without 'ls'  :)
00:27:09 <sorear> *imagine
00:27:38 <kc5tja> Ah, the magic of pure-text blocks!  There is a word called INDEX, to which you give it a range, and it shows the first line of each block in that range.
00:28:06 <kc5tja> Since the top line is _usually_ a comment describing the block (somehow), the result is a pretty useful display of what you have in your blockset.
00:28:15 <kc5tja> E.g.,
00:28:18 <kc5tja> 5 10 index
00:28:29 <sorear> What if I have 1,440 blocks?
00:28:31 <kc5tja>  5: ( Forth program to compute factorial )
00:28:41 <kc5tja>  6: ( Forth program to show 1440 blocks :)
00:28:47 <kc5tja>  7: ( ..etc.. )
00:28:54 <sorear> At least I assume you are going to use commodity floppy drives for your storage.
00:29:05 <kc5tja> Nope -- MMC cards.
00:29:19 <sorear> Oh, joy.
00:29:31 <kc5tja> They're substantially easier to interface to than floppies.
00:29:32 <sorear> smallest mmc card I've owned was *8*192 blocks
00:29:53 <kc5tja> Mine are all 512MB, though I know a few people at google who have 2GB cards.
00:29:53 <sorear> and they don't seem to come smaller than 131072 now
00:30:16 <sorear> side note, can the kestrel access above 64MB?
00:30:24 <kc5tja> Well, don't get me wrong, Forth is simple, but simplicity does come at the price of explicit resource management.
00:31:06 <kc5tja> The Kestrel cannot access above 16MB (the CPU only has a 24-bit address bus).  However, I am planning on a bank-switching circuit (later to be revised as a full-on MMU) to allow it access to 32MB on the FPGA card.
00:31:35 <sorear> I meant on the MMC.
00:31:45 <sorear> 64MB = 16 bits of block number
00:31:58 <sorear> I don't suppose BLOCK uses doubles
00:32:12 <sorear> or is the MMC memory mapped?
00:32:16 <kc5tja> BLOCK will be limited to 16 bits, yes.
00:32:51 <kc5tja> MMC will _not_ be memory mapped due to performance reasons (and, far more importantly, the lack of an MMU).
00:33:08 <kc5tja> So, I guess, no, the firmware will not be able to access >64MB by default.
00:33:18 <sorear> big loss
00:33:19 <kc5tja> But, then again, the firmware really isn't intended for that.
00:33:40 <kc5tja> Ideally, you'll boostrap into an OS which will provide greater functionality.
00:33:50 * sorear never ran out of space on the aformentioned 8MB card
00:34:09 <sorear> kc5tja: oh, so this isn't intended to be a Forth machine?
00:34:43 <kc5tja> The internal Forth environment is deliberately minimal to keep things simple and understandable.  It's not intended to be complete out of the box.
00:34:59 <kc5tja> A disk-resident Forth was planned, but I'm *really* considering going with some statically compilable subset of Scheme instead.
00:35:19 <kc5tja> Or maybe even Smalltalk.
00:36:04 <sorear> Heh, maybe I'll have to make an ML system for it after all...
00:37:18 * kc5tja looked at ML syntax not too long ago, and while it is kinda sorta simple, I just couldn't think of how to write the type inferencing engine.
00:37:32 <kc5tja> And, realistically speaking, ML's syntax is fugly.
00:38:34 <mwc> One thing I really, really, really liked about ML's syntax was local ... in ... end
00:38:38 <sorear> So basically what we want is ML with Haskell's syntax
00:38:53 <sorear> which does?
00:39:02 <sorear> @google Standard ML
00:39:04 <lambdabot> http://www.smlnj.org/
00:39:04 <lambdabot> Title: Standard ML of New Jersey
00:39:11 <mwc> sorear, kind of like a where that groups over multiple definitions
00:39:12 <kc5tja> I do have to warn you though -- the 65816 is not a compiler-friendly processor.  :)  Though, with Forth optimized via SSA, I was able to produce quite good software output.
00:39:42 <mwc> the poor-man's way of doing it in haskell is tuple definitions
00:40:43 <kc5tja> mwc: I'm not understanding; what are tuple definitions in this context?
00:41:12 <sorear> (x,y) = (a + b, a - b) where ...
00:41:13 <mwc> kc5tja, (foo,bar,baz,...) = (...,...,...,...) where { ... }
00:41:14 <kc5tja> sorear: Ideally, but remember, what I'm looking for right at the moment might not be what you're looking for.  So don't let me stop you from persuing your own ideas.  :)
00:41:46 <sorear> certainly.
00:41:48 <kc5tja> Ahh -- definitely not function definitions.  Hence, "tuple definitions."  :)
00:42:06 * kc5tja was also reviewing a variation of Backus' FP/FL system too.
00:42:27 <mwc> sorear, you should see the ugly hack I did to define 9 closely related functions that share many common subunits. The punchline was a parent function of the type: Foo -> Bar -> ((FT,FT,FT),(FT,FT,FT),(FT,FT,FT))
00:42:55 <sorear> kc5tja: how faithful is the simulator wrt the design?
00:42:56 <mwc> and then a whole bunch of ns1 p y = fst3 $ snd3 $ ns p y
00:43:51 <sorear> kc5tja: there are a bunch of things marked as 'Forth' in the memory map.  what do non-forth envs do with those areas?
00:45:41 <mwc> What is this Kestrel? Some sort of small computer?
00:45:52 <mwc> like an embedded platform like the HandyBoard or Gumstix?
00:46:01 <sorear> http://falvotech.com/content/kestrel
00:46:03 <lambdabot> Title: The Kestrel Project
00:46:16 <sorear> recreational retrocomputing project
00:47:08 <kc5tja> sorear: The simulator is cycle-accurate, but is a CPU hog on the host system.  It's not well optimized.  But, that being said, it does work.  No storage is emulated at the moment, since I'm not there yet.  My plan was to get Forth running, then implement storage, then the BLOCK wordset.
00:47:46 <sorear> kc5tja: what does cycle-accurate mean in this context?  (running tally of "real" time?)
00:48:46 <kc5tja> You need an 800MHz Athlon slot-A processor (say, Pentium Pro-era chip) to get the intended perception of a 12.6MHz 65816.
00:49:04 <sorear> kc5tja: Where do these alternate OS's fit in?
00:49:24 <sorear> kc5tja: np, I have a 2004MHz P4 of unknown slot type
00:49:44 <sorear> kc5tja: "The simulator is cycle-accurate" <- means what?
00:50:00 <kc5tja> The _intended_ boot sequence is to probe the I/O bus (which remains to be emulated) for bootable devices.  Select the first device that has a volume mounted, and boot off of sector 0.  Jump to the code so loaded.  If no device yields boot-code, then drop into Forth.
00:50:18 <kc5tja> That means the CPU is emulated cycle-by-cycle, along with I/O peripheral chips.
00:50:28 <sorear> Ah, just like the Intel boot sequence.
00:50:38 <kc5tja> (with optimizations to make emulation faster of course)
00:50:42 <sorear> Try sector 0 of all devices then drop into BASIC.
00:50:48 <kc5tja> Right.
00:50:56 <sorear> BASIC of course being a printf and halt on all modern bioses :(
00:51:53 <sorear> Are there firmware services available?  I can't imagine fitting a intel bs in 1 sector without using int13h...
00:51:58 <kc5tja> essentially, but I wanted the system to boot into a usable environment instead of emulating a cinder block.
00:52:49 <kc5tja> The firmware isn't far enough along to have this kind of API yet, but it will exist.
00:53:28 <mwc> kc5tja, it's kind of funny but you're basically reinventing OpenFirmware
00:53:32 <kc5tja> However, I'm thinking of having the firmware load the first N sectors (where N is defined somehow in sector 0) for you.
00:53:49 <kc5tja> mwc: not really.  OF is vastly more sophisticated than what I'm making.
00:54:01 <kc5tja> mwc: Also, my Forth environment does not serve the purpose of driving devices.
00:54:15 <mwc> the whole forth bios thing sort of smells like it
00:54:31 <kc5tja> I'm sure someone, at some point, will find a way to make it happen though.  :)
00:55:40 <kc5tja> My biggest problem right now is actually delivering working code.
00:55:50 <sorear> So, does it have a timer interrupt?
00:55:52 <kc5tja> I get only so far into its development, and then I feel like I can't go any further.
00:55:53 <mwc> kc5tja, tell me about it
00:56:33 <kc5tja> sorear: Not yet, but that's on the list of things to implement.  Right now, the firmware code relies on vertical sync interrupt for timing, but that's a temporary solution until the real timer hardware is emulated.
00:57:12 <sorear> Of course I probably shouldn't even be *thinking* about writing a preemptive multitasking OS :)
00:57:55 <sorear> (NB: type checking subsumes the role an MMU would otherwise be needed for)
00:58:21 <kc5tja> Nope -- MMU is orthogonal to type safety.
00:58:30 <kc5tja> Type checking cannot expand the processor's address space.  :)
00:58:43 <kc5tja> Likewise, type checking cannot implement virtual memory either.
00:59:11 <sorear> Well, there is that.  but I don't need it just for crash resistance.
00:59:33 <kc5tja> I wasn't intending on using it for protection purposes, with the sole exception of Forth (and even then, only experimentally).
00:59:35 <mwc> sorear, MMU's also provide you a way to maintain security
00:59:47 <mwc> keep user code from poking the kernel
01:00:01 <kc5tja> mwc: That is something type safety DOES provide.
01:00:02 <sorear> of course once you start using __coerce you need to save often :)
01:00:37 <kc5tja> Oberon, for example, is an Algol-family language with _very_ strong type safety (not as strong as Haskell's, but close), and everything runs in ring-0 on x86 processors or supervisor-mode on 68K and PPC platforms.
01:00:58 <kc5tja> What is __coerce?
01:00:59 <mwc> kc5tja, well, if you extend your typesystem to include a security model
01:01:06 <kc5tja> mwc: Not needed.
01:01:06 <mwc> come to think of it, doesn't lambdabot have something like that?
01:01:11 <kc5tja> mwc: You cannot forge pointers in oberon.
01:01:15 <sorear> my random name for unsafeCoerce#
01:01:40 <kc5tja> (not without importing the SYSTEM pseudo-module, at least, and using code like x := SYSTEM.VAL(SYSTEM.PTR, 0xDEADBEEF);
01:01:41 <sorear> mwc: if you can't forge pointers you can only poke objects you have references to
01:01:56 <sorear> mwc: enter security through visibility
01:02:02 <kc5tja> aka Capabilities.
01:02:04 <kc5tja> :)
01:02:08 <mwc> sorear, true. I'm thinking more from the standpoint of a malicious user
01:02:28 <mahogny_> hm. what *is* the state of editors for haskell?
01:02:33 <mahogny_> haven't heard much
01:02:40 <sorear> mwc: don't give the malicious users __coerce
01:02:43 <mwc> What's a VNC server for linux that doesn't suck?
01:02:46 <mwc> er, client
01:02:50 <sorear> mahogny_: vi and emacs and mg are all good
01:02:54 <Wild_Cat> mahogny: depends what platform you're running, I guess.
01:02:59 <mwc> tightvnc is broke for me atm
01:03:06 <Wild_Cat> for the Mac, TextMate seems to have a good Haskell bundle.
01:03:12 <kc5tja> mwc: I use TightVNC on my box at home.  It seems to be quite adequate for my needs.
01:03:12 <mahogny_> sorear, I distaste vi and emacs. let me try mg :)
01:03:26 * kc5tja never heard of mg.
01:03:34 <Wild_Cat> for the rest, emacs, vi and maybe jEdit should work.
01:04:00 <sorear> mg is a very nice lightweight editor with emacs keys.
01:04:16 <kc5tja> That rules its use out for me.  :/  Not a fan of Emacs-style keybinding.
01:04:20 <mwc> kc5tja, my pbook is sending fubar'd keycodes to my desktop (i686)
01:04:22 <Wild_Cat> aye.
01:04:48 <sorear> mg's biggest blemish is that it segfaults if you enter a M-x command longer than 128 characters :(
01:04:51 <mahogny_> vi and emacs has too strange key bindings to attract me
01:05:07 <kc5tja> mahogny_: Nano?  ;D
01:05:11 <mahogny_> that is what I use
01:05:18 <mahogny_> but for years I have considered an upgrade :P
01:05:24 <sorear> don't worry, soon you'll think everything ELSE has strange keybindings!
01:05:41 <kc5tja> Some day, I'm going to get off my butt and try writing the THE-inspired editor I've always been wanting to write since the release of "The Humane Interface" was published.
01:06:07 <mahogny_> well, I just started on my own editor. the vty library seems to nice to not be used
01:06:21 <mahogny_> *too
01:06:26 <sorear> mahogny_: have you looked at yi?
01:06:43 * kc5tja would probably end up using SDL for my editor, since it will depend on composition of semi-transparent panes of text.
01:06:46 <mahogny_> sorear, hm. a little. I forgot why I never started using it
01:06:53 <sorear> mahogny_: tuomo valkonen's editor project
01:07:12 <sorear> mahogny_: since adopted by don stewart, then jean-phillipe bernardy
01:07:42 <mwc> kc5tja, I found their tirade against model user interfaces silly
01:07:58 <mwc> kc5tja, life is modal, it seems totally natural to me
01:07:58 <narain> :t liftM
01:08:01 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
01:08:05 <narain> :t liftM . liftM
01:08:07 <lambdabot> forall (m :: * -> *) a1 r (m1 :: * -> *). (Monad m, Monad m1) => (a1 -> r) -> m (m1 a1) -> m (m1 r)
01:08:08 <pjd_> mwc: amen
01:08:15 <kc5tja> mwc: Except for the small detail that life _isn't_ modal.
01:08:20 <kc5tja> It's concurrent.
01:08:29 <kc5tja> It only seems modal because you can only visibly focus on one thing at a time.
01:08:33 <pjd_> life approximates modality
01:08:36 <kc5tja> (and keep about 8 things in mind concurrently)
01:08:41 <mwc> kc5tja, doors are open, or doors are closed. Locking a door while open has a totally diff't effect from locking it while closed
01:09:38 <kc5tja> A good analogy, but one which I'm not prepared to respond to at the moment.  Given enough time, I can think of a good rebuttal though.
01:09:48 <pjd_> kc5tja: it can be argued that concurrent+stateful == modal
01:09:52 <kc5tja> Fortunately, though, regardless, computers _don't_ model reality.
01:10:15 <kc5tja> For all the support of modality here, you'd think everyone here should be advocating object oriented techniques.
01:10:37 <pjd_> how would OO have to do with it?
01:10:54 <kc5tja> Objects model state.  State implies modality.
01:11:10 <kc5tja> door.lock() will have different effects depending on whether door.open() or door.close() has been called prior.
01:11:39 <pjd_> i wouldn't call that modeling state, to any useful extent :)
01:11:58 <kc5tja> Then your definitions are in stark contrast to literally every computer scientist on the planet.
01:12:32 <pjd_> in a hypothetical modal OO system, a locked door would not provide door.lock
01:12:35 <kc5tja> If the behavior of door.lock() depending on the state of the door being opened or closed isn't modeling state, what _does_ it model?
01:12:48 <pjd_> kc5tja: it *exposes* state
01:12:55 <kc5tja> No.
01:13:03 <kc5tja> It exposes an interface.
01:13:12 <kc5tja> The state of a door is exclusive to the door.
01:13:16 <pjd_> modelling implies some capability to reason about the state, too
01:13:24 <kc5tja> which objects do.
01:13:47 <kc5tja> The equivalence of objects and closures is something the Scheme programmers often beat their chests over.
01:13:52 <pjd_> not to any additional extent than plain procedures :)
01:14:01 <kc5tja> Negatory.
01:14:22 <pjd_> anyway, this isn't really a constructive line of argument
01:14:34 <kc5tja> Because it has no resolution, and _can_ have no resolution.
01:15:31 <pjd_> so let's resolve to each wait for the other to see the light, right? :)
01:15:41 <kc5tja> Nope.
01:15:49 <kc5tja> I see and deal with things as they are.
01:16:25 <kc5tja> Objects don't magically change type just because they're open or closed -- doing so violates type safety.
01:17:21 <kc5tja> At any rate, getting back on the previous topic, the complaints raised against traditional GUIs are valid.
01:17:40 <kc5tja> As a user of AmigaOS from years back, I can definitely attest that a non-modal GUI is _vastly_ more productive than a modal one.
01:18:20 <augustss> oh, AmigaOS had a non-modak GUI?
01:18:26 <augustss> very cool
01:18:31 <kc5tja> augustss: For the most part.
01:19:23 <midfield> sorear: if i hSeek a file handle sitting under a lazy bytestring, do i loose?  or does the lazy bytestring know what position to read from next?
01:19:27 <Wild_Cat> AmigaOS was 10 years ahead of its time.
01:19:31 <kc5tja> Some applications had modal requestors, but on the whole, I was able to continue working in another area of the program when the program was waiting for input in one area of a window.
01:19:39 <pjd_> i proposes that there is no such thing as modality/non-modality;  there is only a question of how granular your modes are
01:19:42 <sorear> midfield: You lose.
01:19:46 <Wild_Cat> shame Commodore spent those 10 years doing absolutely nothing :(
01:19:46 <pjd_> "propose", even
01:19:55 <sorear> midfield: actually, the seek will fail!
01:19:58 <midfield> sorear: drat!
01:20:03 <kc5tja> pjd_: Correct -- but the context is within the realm of UIs.
01:20:14 <midfield> sorear: really?  how is that?
01:20:33 <sorear> midfield: when you use getContents, it sets the semi-closed flag, which causes all subsequent operations on the handle to fail.
01:20:43 <midfield> sorear: hmm.
01:20:47 <kc5tja> Wild_Cat: Not true; they _wanted_ to do something, but Irving Gould kept siphoning cash off the company.  They never had the funds to actually advertise.
01:21:02 <kc5tja> I hope Irving Gould burns in hell.
01:21:18 <Wild_Cat> kc5tja: then the Tramiel family came on the scene, and it all went downhill from there.
01:21:28 <sorear> midfield: it's the same principle as for h98 lazy io: http://haskell.org/onlinereport/io.html#sect21.2.2
01:21:28 <midfield> sorear: i managed to get my external sorter to work, k-way merge and all, but the IO performance of Data.Binary.Defer is killing me
01:21:29 <lambdabot> Title: The Haskell 98 Library Report: Input/Output
01:21:40 <kc5tja> Wild_Cat: The Tramiel family FOUNDED the company.  They brought the company to its success!
01:22:05 <kc5tja> Wild_Cat: I think you're confusing Commodore for Atari.
01:22:13 <sorear> midfield: GNU sort is external, so the only reason to write one is education
01:22:27 <Wild_Cat> kc5tja: oops, you're right.
01:23:22 <midfield> sorear: i don't quite agree.  it is nice to have implementations of basic algorithms native in whatever language you're using.  GNU sort for example doesn't understand Ord.
01:23:44 <kc5tja> Irving then hired a CEO who was known to be bed-fellows with IBM.  Not long after, IBM had the VGA card, and efforts to actively sabotage the Amiga effort weren't unknown.
01:23:46 <Wild_Cat> but I'm pretty sure it's at C= that when sales began to drop, they decided to cut expenses by stopping to advertise their products. If there ever was any doubt that this was a Bad Idea...
01:26:27 <kc5tja> Wild_Cat: That was after Tramiel left -- hence the sabotaging.  Are you aware that the AGA chipset was designed for a good five years before it actually hit the market?  That's death for a semiconductor fab that can spin chips as quickly as a week or two.  They were working on the AA chipset by the time AGA was finally given the green light.  :(
01:27:12 <Wild_Cat> yeah, I heard about that. That effing sucks.
01:27:39 <kc5tja> That's one reason why I started the Kestrel, I guess.
01:27:49 <Wild_Cat> either way, you'll probably agree with me that both Commodore and Atari died stupid deaths, which had extremely adverse effects on the computer industry as a whole (two less barriers against you-know-who).
01:27:54 <kc5tja> I wanted a box that I could control, and be released into the open source community for ultimate hackage.
01:28:31 <kc5tja> Yes, and two sources of innovation, the likes of which will never be seen again.
01:29:47 <shapr> I hope that FPGAs become open source usable.. that is, do not require a vendor specific netlist to chip compiler.
01:29:48 <Wild_Cat> aye. Although part of that couldn't be helped, what with Jay Miner's death and all...
01:30:28 * kc5tja notes that Jay died on the same day that Commodore-Amiga filed Chapter 13.  :(
01:30:41 <sorear> I expect that within fifty years nanotech will make individual-scale ASIC fabbing affordable.
01:31:03 <shapr> sorear: With FPGAs we'd get to emulate that now.
01:31:05 <kc5tja> sorear: I predict that in 50 years, nanotech will still be a research item.
01:31:45 <kc5tja> FPGAs still require proprietary programmers, but there is Icarus Verilog, which is quite capable at simulating designs.
01:32:52 <shapr> I hope for a non-proprietary programmer.
01:33:11 <shapr> I think that would let lose the creativity of open source in the hardware world.
01:33:15 <shapr> loose*
01:33:18 <shapr> Yeesh, I'm sleepy.
01:33:20 <kc5tja> Yup.
01:33:45 <kc5tja> Unfortunately, we can't even reverse engineer it, because the protocol for one chip is never the same as a protocol for another.
01:33:54 <kc5tja> Why do when you can overdo?
01:34:17 <shapr> So the OpenGraphics route is probably best... produce a truly OSS FPGA.
01:34:34 <kc5tja> If they succeed in doing that, I'd be very interested indeed.
01:34:53 <shapr> OpenGraphics is using a Xilinx FPGA to build a totally open graphics card.
01:35:05 <shapr> But if you apply that idea to FPGAs, it'd likely work.
01:35:27 <shapr> Hm, using Xilinx means it's totally documented rather than totally open.
01:35:45 <Wild_Cat> the OpenGraphics + OpenSparc combination would certainly make for a really cool computer.
01:36:42 <shapr> I hadn't thought of that.
01:38:07 <vali> hello. is it hard to install extra packages with haskell? i would like to install opengl...
01:38:18 <vali> i come from lisp, where installing packages was usually hell
01:38:27 <sorear> You know you're tired when you make two independent typoes in a two-line code block and copy it four times.
01:38:34 <opqdonut> w
01:38:38 <sorear> vali: stop - opengl comes with ghc
01:38:51 <shapr> vali: What OS/arch?
01:39:03 <sorear> vali: although sometimes it is packaged separately
01:39:04 <vali> i am using windows xp
01:39:05 <shapr> And if Linux, what distro?
01:39:33 <kc5tja> Wild_Cat: OpenRISC -- OpenSparc is still not quite as open as OpenRISC.
01:40:02 * kc5tja was considering using an OpenRISC or pure-stack architecture for the next refinement of the Kestrel.
01:40:02 <Wild_Cat> isn't it? I thought it was completely open. My bad.
01:40:31 <sorear> vali: try to import Graphics.Rendering.OpenGL
01:40:35 <sorear> vali: it should work
01:40:40 <kc5tja> It is, in the same sense that OMG CORBA is open -- that is, users have no means of contributing back, and cannot make changes.  Fully documented vs. fully open.
01:40:55 <vali> sorear: okay, thank you. is it simple to install packages that don't come with haskell?
01:41:04 <sorear> vali: very.
01:41:09 <vali> sorear: i love haskell
01:41:42 <dons> all packages have a common build system, and most are available from hackage.haskell.org
01:41:44 <kc5tja> vali: Modules are still black magic to me with haskell, but with the sole exception of my work computer at the office, Haskell's modules have been painless to install.
01:41:53 <dons> so its quite easy to find 3rd party packages and install them
01:42:06 <vali> ah, great
01:42:09 <dons> kc5tja: black magic, in the sense of creating new modules/packages?
01:42:46 <vali> i wonder what the drawbacks with haskell are
01:42:59 <kc5tja> dons: In the sense of, "I haven't the foggiest clue where they go when they're installed."  :)
01:43:09 <mauke> the libraries hate me :(
01:43:20 <dons> ah hehe.
01:43:23 <dons> mauke: oh?
01:43:44 <dons> kc5tja: $ ghc-pkg list
01:43:51 <mauke> half of them aren't documented, System.Process.something was broken, etc
01:44:01 <sorear> vali: code runs slower then C, easy to shoot yourself in the foot re. memory usage, lack of job opportunities, breeds feelings of superiority, etc
01:44:28 <Wild_Cat> vali: it's not mainstream, it's not PHB-friendly, the pure-FP paradigm is alien to people who don't know it (unlike OO, which can be easily understood in 5 minutes when you only know procedural) and monads are nontrivial to get.
01:45:03 <vali> sorear: how is it easy to shoot yourself in the foot?
01:45:19 <kc5tja> vali: the context is with respect to memory usage.
01:45:24 <sorear> kc5tja: ... care to share CUT 2.6's memory usage?
01:45:38 <dons> naive code can suffer space leaks, which aren't obvious unless you understand profiling, or the compilation model.
01:45:42 <vali> Wild_Cat: what is PHB? and about mainstream... i guess that's always hard. just look at music
01:45:46 <dons> that's basically what sorear was getting at.
01:45:59 <pjd_> vali: Pointy-Haired Boss
01:46:02 <Wild_Cat> vali: Pointy-Haired Boss. Read Dilbert ;)
01:46:13 <pjd_> it's a synonym for clueless management
01:46:14 <vali> heheh, ok
01:46:19 <kc5tja> vali: My re-write of my CUT project composes its output files in a pure functional style (e.g., outputFile = a ++ b ++ c ++ d, where a, b, c, and d are functions that create components of the output file).  A 7MB C source test file results in over 100MB of PC memory being used for composing this output.  :)
01:46:41 <dons> yes, ++ isn't sensible :-)
01:46:51 <sorear> dons: it's infixr!
01:47:07 <vali> kc5tja: aah. but this will probably be remedied in some later release?
01:47:08 <kc5tja> dons: It uses ByteString.concat now.  I just used ++ as a convenient shorthand.
01:47:11 <dons> you'd still not use ++ for pretty printing, sorear
01:48:22 <kc5tja> vali: I personally don't have any incentive to change it, since this tool is the kind of thing that runs only once every so often.  But if it were to run continuously, I'd certainly invest more effort in its optimization.
01:48:37 <vali> hmm, haskell.org isn't working for me at the moment
01:48:48 <dons> the upside is that its possible to have C like performance, which similar, competing languages (python, ruby) don't really have the ability to do
01:49:01 <dons> vali: yeah, there's some problem. the admins have been informed.
01:49:07 <vali> ah, okay
01:49:40 <vali> kc5tja: sorry, i mean the compiler
01:50:19 <kc5tja> vali: I can't say, but it depends on how clever the optimizer becomes.
01:51:34 <vali> well, to me it seems that there are very insignificant drawbacks with haskell compared to other languages i have used
01:51:45 <vali> compared to the advantages
01:52:21 <kc5tja> Depends on what you're doing too.
01:52:27 <dons> yes, there are some significant advantages, which are critical in some scenarios
01:52:30 <kc5tja> If you're looking to write an arcade game, sure, Haskell is hardly real-time.  :)
01:52:48 <dons> just the use of semi-formal methods like QuickCheck makes Haskell the only (or one of very few) optoins in certain domains
01:52:59 <kc5tja> But if you're looking for a program that is provably correct within some context, then Haskell is just the ticket.
01:53:47 <dons> or just want to write bug-free code, quickly.
01:53:49 <vali> i have been looking for a general-purpose language for a while... and though haskell is the last one i tried, it's the one i am going to stick with
01:53:54 <kc5tja> Also, if you're looking to write programs quickly and with high productivity, Haskell can't really be beat (well, once you know what you're doing with monadic stuff; until then, it's a bit of a learning curve).
01:53:58 <dons> well, dive in, see how you go.
01:54:33 <dmhouse> haskell.org seems to be working now.
01:54:37 <dons> kc5tja: yeah, i'd agree. once you're on top of the main development strategies in haskell, there's not much that can beat it for rapid, precise development
01:55:06 <dons> i'm particular struck by how we got xmonad done in 4 weeks, whereas dwm took around a year to stop segfaulting
01:55:08 <vali> i will. i haven't come to the monads, but so far it's looking great. it's like python, only much faster, it produces the executables i want and it has the best community i have ever seen
01:55:27 <dons> vali: that's a reasonable summary, yeah :-)
01:56:17 <sorear> I still don't use haskell for tasks that are not very complicated and have high performance requirements.  Emphasis on simple.
01:56:41 <vali> sorear: what do you use for general-purpose stuff then?
01:56:50 <sorear> haskell!
01:56:55 <vali> heheh
01:56:59 <Wild_Cat> Haskell's automatic memory management is part of what makes it much better than C.
01:57:08 <sorear> with a little bit of perl and sh for spawn-intensive tasks
01:57:15 <Wild_Cat> no segfaults ever.
01:57:47 <sorear> > array (minBound::Int, maxBound) [(1,'a')]
01:57:52 <lambdabot> Terminated
01:57:55 <dons> nice sorear :-)
01:58:06 <dons> yes, its possible to exhaust memory
01:58:18 <sorear> dons: that wasn't memory exhaustion
01:58:28 <dons> how do you know ;-)
01:58:40 <sorear> dons: I've tried it at home.
01:59:12 <mauke> "don't try this at home, kids"
01:59:17 <dons> sorear: i gues my point is that pointing out how smart you are knowing some funny little corner isn't the best way to introduce new programmers to haskell.
01:59:20 <sorear> dons: it integer overflows in the array function, creating an Array object of size zero bytes.  the subsequent initialization causes a segfault.
01:59:38 <sorear> ah, ok then.
01:59:44 <Cheery> huh, I'd may make arcade game in haskell. :/
02:00:46 <araujo> haskell.org down?
02:00:50 <sorear> yes.
02:01:13 <dolio> Cheery: It's been done. :)
02:01:22 <araujo> :-(
02:01:25 <dolio> Depending on your definition of "arcade game" I guess.
02:01:30 <Wild_Cat> the unpredictability of lazy evaluation may be a problem if you're making a game.
02:02:00 <Cheery> dolio: I guess the guy meant something like heavy-physics or heavy-performance -games
02:02:01 <Wild_Cat> although depending on what's in your game vs. the specs of the machines you'll run it on, chances are you won't notice.
02:02:40 <dolio> Cheery: Well, I was thinking, if it had to run on an arcade box, it might not be a good choice.
02:02:46 <Cheery> I think those would be plausible, haskell FFI seems to rule so well that even if they wouldn't work with proper algorithms, they'd definitely work after hard parts written in assembly
02:03:28 <dolio> Cheery: But one of the FRP papers makes a space invaders clone or something like that. That's an arcade game. :)
02:03:46 <Cheery> dolio: how arcade box would limit you that you couldn't use haskell?
02:04:07 <Cheery> dolio: yeh, that's a paper I'm just reading. :>
02:04:08 <dolio> Cheery: Might not be ported there. What sort of hardware is in those?
02:04:10 <osfameron> there's a presentation by guy in games industry saing haskell is future
02:04:30 <osfameron> coz of parallelism on multicore
02:05:43 <Wild_Cat> osfameron: yeah. Once the GHC guys figure out how to auto-parallelize program execution, Haskell will become an instance of Best Thing Ever (TM).
02:05:52 <Cheery> osfameron: I think it's not only that
02:06:19 <Cheery> you know, in c++, people have this far reinvented square wheels again and again when related to gaming
02:07:01 <Cheery> in haskell, it'd seem you could very easily do the things right, and majority wouldn't need to reinvent crap to make their games.
02:08:28 <osfameron> but there are lots of c++ game coders... and people find haskell hard. some inrtia to overcome
02:08:34 <Wild_Cat> the gaming industry has been moving away from C++ for a few years, anyway. Now only game engines are written in C/C++, and a lot of those are middleware.
02:08:42 <osfameron> yeah
02:09:01 <Wild_Cat> ever since QuakeC and UnrealScript, game logic has been moving toward HLLs.
02:09:08 <Cheery> yes, and haskell is still changing, if you switch to it, you must prepare to write very easily modifyable code you can upgrade to new systems in need.
02:09:08 <osfameron> scripting is lua or lisp or similar?
02:09:09 <kc5tja> I had something closer to "Ventura Fighter" or "Gran Tourismo" in mind when I said arcade game.
02:09:11 <Wild_Cat> now Lua and Python are all the rage.
02:09:42 <mahogny_> has anyone had experience with Yi failing to compile?
02:10:10 <kc5tja> Supposedly, there were a handful of games written in Common Lisp.
02:10:18 <DRMacIver> mahogny_: I couldn't get it to compile when I last tried, but I gave up and couldn't be bothered to try again. :)
02:10:25 <dolio> There is a Quake-like proof-of-concept game written as a thesis in Haskell.
02:10:26 <Cheery> Wild_Cat: I guess Lua and Python should just drop down, they do not really seem having any benefits compared to haskell
02:10:33 <Wild_Cat> I predict Stackless Python will soon become more popular in the gaming industry, once more people become aware that it's what made EVE Online possible.
02:10:34 <Cheery> (I've used them, didn't see the benefits)
02:11:16 <Wild_Cat> Cheery: Can't speak much for Lua as I've not used it at all -- I only know it's designed to be embedded, which may be a good thing.
02:11:18 <osfameron> Cheery: anyone can understand a scripting language
02:11:32 <osfameron> that's a big benefit
02:11:41 <Cheery> I'd argue it's not
02:11:48 <Wild_Cat> as for Python, if you really want to see why it rules, it's not regular Python but Stackless you want to be looking at.
02:11:52 <Cheery> anyone != all of the gaming community
02:12:22 <Wild_Cat> (Stackless more or less allows you to do Erlang-style massive pseudo-parallelism)
02:12:27 <osfameron> Wild_Cat: wht are the major differences?
02:12:33 <osfameron> ah
02:12:40 <osfameron> cool
02:13:17 <mauke> isn't stackless python called stackless because regular python uses the C stack for subroutine calls?
02:13:22 <Wild_Cat> the concept is called "tasklets". You can have an infinite number of them without any of the performance loss associated with regular multithreading. Extremely useful when writing agent-based programs, e.g. games.
02:13:23 <Cheery> I think only those people who needs to understand should understand code.
02:13:41 <integral> mauke: isn't it?
02:13:45 <dons> gee, how long have google ad "Web History" enabled?
02:13:49 <Cheery> all others? well, I don't care, they never program anyways
02:13:49 <dons> s/had/
02:13:57 <Wild_Cat> mauke: yeah. Stackless tries to avoid using the C stack as much as possible. But that's not the real point.
02:14:22 <Wild_Cat> if anything, Stackless is one big naming mistake.
02:14:34 <osfameron> Cheery: ok, well i did mean /programmers/
02:14:55 <osfameron> stackless run on jvm?
02:15:10 <osfameron> ah, no, that's jython
02:15:13 <Wild_Cat> osfameron: nope, it's a modified version of CPython.
02:15:29 <Cheery> osfameron: I don't know if you should call somebody programmer who doesn't like about finding things out.
02:15:31 <Wild_Cat> it has similar performance. Jython is Python on the JVM, and IronPython is Python on the CLR.
02:16:04 <sorear> Ah, so it should be called CPSPython.
02:17:36 <osfameron> Cheery: i partly agree. but idealism isn't the point - games will be written in what games industry wants to write in. ease of knowledge transfer will factor in that decision, maybe a lot, maybe not much
02:18:08 <Wild_Cat> CPS?
02:18:19 <sorear> @vera CPS
02:18:21 <lambdabot> *** "cps" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
02:18:22 <lambdabot> CPS
02:18:22 <lambdabot>      Central Processing System
02:18:22 <lambdabot>  
02:18:22 <lambdabot> *** "cps" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
02:18:23 <lambdabot> [3 @more lines]
02:18:26 <sorear> @more
02:18:27 <lambdabot> CPS
02:18:27 <lambdabot>      Characters Per Second
02:18:29 <lambdabot>  
02:18:34 <sorear> byech.
02:18:38 <kc5tja> Continuation Passing Style.
02:18:41 <sorear> Continuation passing style
02:19:00 <osfameron> continuations scare me
02:19:03 <sorear> It's what the Cont monad does to your code.
02:19:07 * osfameron hides
02:19:12 <DRMacIver> osfameron: Why?
02:19:21 <Cheery> osfameron: ah, games industry.
02:19:23 * Wild_Cat searches Wikipedia...
02:19:26 <pjd_> Wild_Cat: Stackless Python lacks most of what defines Erlang's concurrency, though
02:19:27 <dolio> Those are relevant acronyms?
02:19:43 * sorear corners osfameron in a pub and explains delimited continuations to him
02:19:49 <osfameron> DRMacIver: oh, i don't understand 'em ;-)
02:19:59 <Wild_Cat> pjd_: yes, it does. It lacks pretty much all the performance- and distribution-related stuff.
02:20:07 <pjd_> sorear: also, SPython does not use CPS as far as i know
02:20:18 <pjd_> (it does heap allocation)
02:20:19 <osfameron> sorear: good plan! more beer is what's needed!
02:20:37 <sorear> pjd_: that's most of the point of CPS
02:20:41 <Wild_Cat> what it does have, however, is a way to spawn thousands, if not millions, of tasklets and run them. Which is what I find to be the coolest thing in Erlang.
02:20:48 <sorear> pjd_: CPS stores activation records on the heap
02:21:00 <sorear> pjd_: I imagine stackless has a call/cc operator?
02:21:14 <Cheery> osfameron: there's a kind of problem in games industry, I believe it's one which prevents good games from appearing
02:21:16 <Wild_Cat> I think "SwarmPython" would be a more appropriate name.
02:21:23 <pjd_> sorear: CPS is also about the calling convention; it's a certain representation
02:21:31 <Wild_Cat> besides, it makes one think of the Zerg, which can't be a bad thing.
02:21:33 <pjd_> SPython uses non-CPS code on the heap
02:21:42 <Cheery> I don't think we get next big titles from gaming industry, those big titles will came from Just People
02:21:54 <pjd_> and no, SPython doesn't have first-class continuations
02:22:23 <pjd_> (it was a target feature in early versions, but they dropped it)
02:22:46 <Wild_Cat> it just has coroutines.
02:22:52 <osfameron> sorear: if you are london-based i will  be there on thursday and gladly trade  beer for cps-foo
02:23:21 <dolio> sorear's a bit young for you to be buying him beer.
02:23:26 <pjd_> Wild_Cat: right, and synchronization channels, and so on
02:23:31 <Wild_Cat> yup.
02:23:35 <osfameron> hheh
02:24:14 <osfameron> dolio: on the internet, you can buy anybody beer. or something
02:24:42 <dolio> You could write a haskell program to print him a fake id, though.
02:24:52 <sphynx> hi all
02:25:09 <vali> hello sphynx
02:26:17 <sorear> Actually there is a quote in lambdabot's database I was referring to.
02:26:19 <sorear> @quote pub
02:26:19 <lambdabot> edwinb says: where does 'Oleg cornered me in a pub and explained delimited continuations to me' fit in?
02:26:27 <sphynx> it seems that haskell.org is down now?
02:26:32 <sorear> yup
02:27:00 <osfameron> ah, a meme
02:27:17 <osfameron> beer is frothier than memes
02:27:34 <Wild_Cat> osfameron: it's not a meme until there's a Flash animation and several thousand animated gifs.
02:28:50 <kc5tja> :t mapM_
02:28:59 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
02:30:03 <kc5tja> :t hPut IO.stdout
02:30:06 <lambdabot> Not in scope: `hPut'
02:30:54 <sphynx> I want to write simple translator of expressions from infix form to postfix form (Revese Polish Notation). So I've started with evaluating such kind of expressions using stack. It seems I need to save stack state for evaluation, so I pass stack as a parameter.
02:31:36 <sphynx> something like this: evaluate :: [String] -> Stack -> Int
02:31:42 <mauke> why evaluate if you want to transform?
02:32:05 <sphynx> I want to do at first something simpler :)
02:32:19 <sphynx> I'm just studying now
02:32:34 <mauke> what form is your input in?
02:32:48 <dons> ok. passing the stack as a parameter is a good place to start.
02:33:32 <sphynx> now it's some string containing operators and operands delimited by spaces: "1 2 + 3 -"
02:33:38 <augustss> transforming is simpler than evaluating
02:33:45 <sphynx> so I can parse it by 'words' function :)
02:33:58 <mauke> that looks like postfix
02:34:54 <sphynx> augustss, hmm, I think that evaluating of RPN expressions is really simple, you just push un stack operands and pop them out and perform sone operation when operator is encountered in input
02:35:10 <Cheery> ghc-6.6: unknown package: lang
02:35:13 <Cheery> ?where lang
02:35:14 <lambdabot> I know nothing about lang.
02:35:21 <mauke> but that means you need a mutable stack
02:35:26 <sphynx> mauke, Yes, I'm evaluating postfix now
02:35:46 <augustss> Oh, sorry, I thought you meant evaluating infix expressions
02:35:46 <mauke> if you have an expression data type, you can use a function to walk/eval it
02:36:17 <sphynx> dons, so for start it's ok to pass Stack as param and then I can move to some mutable stack or to State monad in this example?
02:36:35 <augustss> yeah, evaluating postfix is really easy.  just keep a stack and do something to it on every input
02:37:09 <dons> sphynx: you'd not use a mutable stack, you might use a State monad to hide the explicit stack, yes.
02:37:13 <augustss> a mutable stack is overkill for this.  just pass it around
02:37:41 <mauke> evaluate :: [Token] -> Int; evaluate' :: [Token] -> [Int] -> [Int]
02:37:43 <sphynx> but how mutable stack is defined, is there some kind of data for this?
02:38:22 <mauke> evaluate ts = head (evaluate' ts [])
02:38:53 <sorear> night all.
02:39:07 <augustss> sphynx: don't even think about a mutable stack.  just use a list
02:39:30 <sphynx> ok, I will forget about mutable stack  for now:)
02:39:33 <pjd_> and push/pop at the head, not the tail
02:40:13 <sphynx> pjd_, yeah I understand this, cause (:) operation is faster and 'head' is faster than 'last'
02:40:21 <augustss> sphynx: with a little pattern matching it will come out very nice and short
02:40:27 <Cheery> ?where yampa
02:40:27 <lambdabot> http://www.haskell.org/yampa/
02:41:24 <pjd_> sphynx: not just faster, but it avoids duplicating the list all the time
02:41:43 <sphynx> mauke, so you hide stack in evaluate', and stack can contains only Int, really, cause operators are not placed in stack.
02:41:50 <mauke> right
02:42:16 <mauke> every "token" is a command that modifies the current stack of values
02:42:35 <sphynx> pjd_, but it seems while popping from stack I should return not only popped element but modified stack too... It will create new instance of Stack, yes?
02:43:07 <pjd_> sphynx: nah, list tails can always be shared
02:43:23 <pjd_> because they're immutable
02:43:38 <dons> > let pop (x:xs) = xs in pop (pop (pop "haskell"))
02:43:39 <lambdabot>  "kell"
02:43:54 <augustss> it will about as efficient as it possibly can.  not that it matters for something like this
02:44:02 <mauke> evaluate' [] ns = ns; evaluate' (Num n : ts) ns = evaluate' ts (n : ns)
02:44:31 <pjd_> sphynx: personally, i find it useful to always think of the [] type as a head-wise stack (that only happens to be useful as a list, too :)
02:44:36 <sphynx> dons, but now we didn't get popped element, only tail of list
02:44:59 <dons> sphynx: right, you'd return the head, and push the tail into the monad state (or return both)
02:45:24 <Cheery> could you guys give me a hand with this? ghc -c  -fglasgow-exts -O -package lang -package concurrent   -o AFRP.o AFRP.hs
02:45:27 <Cheery> ghc-6.6: unknown package: lang
02:45:35 <Cheery> what is a lang -package?
02:45:41 <augustss> sphynx: evaluate ("+":ts) (x1:x2:xs) = evaluate ts (x1+x2 : xs)
02:45:53 <pjd_> sphynx: you'll probably not have an explicit "pop" operation; pattern matching with (:) should be more succinct
02:46:08 <dons> > let pop = do x:xs <- get ; push xs ; return x in runState (pop; pop; pop) "haskell"
02:46:08 <lambdabot>  Parse error
02:46:22 <mauke> missing do
02:46:24 <sphynx> augustss, hm, thanks. It's about smart and helpful pattern matching
02:46:28 <dons> > let pop = do (x:xs )<- get ; push xs ; return x in runState (do pop; pop; pop) "haskell"
02:46:29 <lambdabot>   Not in scope: `push'
02:46:34 <dons> heh
02:46:43 <augustss> dons: don't confuse sphynx ;)
02:46:50 <dons> > let pop = do (x:xs )<- get ; put xs ; return x in runState (do pop; pop; pop) "haskell"
02:46:52 <lambdabot>  ('s',"kell")
02:47:30 <sphynx> I have read about the monads in 'All about monads' article, but I'm not that good in monads yet :(
02:47:42 <augustss> and you shouldn't use one
02:48:06 <sphynx> Maybe I will try to do the same transformer using monads later
02:48:29 <dons> yes, a state monad is overkill here. write the whole thing with an explcit stack, so you get a sense of how to manage the stack structure properly
02:48:50 <dons> a postfix pretty printer is a nice intro haskell problem, actually
02:49:11 <dons> since you get functions, simple list hacking, some recursion. . all good :-)
02:49:16 <sphynx> dons, thanks!
02:49:39 <dons> sphynx: once you've got it sorted out, you should blog about it :-)
02:49:40 <sphynx> dons, then I chase good problem :)
02:49:54 <mauke> > let pop = do (x : xs) <- get; put xs; tell [x]; return () in runWriter (execStateT (do pop;pop;pop) "Haskell")
02:49:56 <lambdabot>  ("kell","Has")
02:50:14 <dons> cute, mauke :-)
02:51:16 <sphynx> dons, well, maybe I'll blog about this :) But my blog is in russian for now. Maybe I should start some haskell blog in English? :)
02:51:25 <mauke> sometimes you can avoid State by combining Reader/Writer and fix
02:51:31 <augustss> you should!
02:51:52 <osfameron> do both!
02:52:47 <osfameron> i like that local language tech blogs exist too... but english is lingua franca for beter or worse
02:53:48 <sphynx> my blog is not of tech totally, it is kinda mix of basic math, linux, life, etc. :)
02:54:03 <sphynx> osfameron, yeah, I agree
02:54:09 <dons> sphynx: check planet.haskell.org, its much the same mixture
02:54:17 <[malte]> @hoogle Array i e -> Maybe e
02:54:18 <lambdabot> No matches, try a more general search
02:54:52 <sphynx> dons, yes, it is in my bookmarks :)
02:57:55 <pjd_> <mauke> sometimes you can avoid State by combining Reader/Writer and fix
02:57:56 <pjd_> you can?
02:58:29 <[malte]> @hoogle Monad m, IArray a e => a e -> m e
02:58:30 <lambdabot> Prelude.id :: a -> a
02:58:31 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
02:58:31 <lambdabot> Prelude.asTypeOf :: a -> a -> a
03:00:28 <[malte]> @hoogle Array i e -> i -> Maybe e
03:00:29 <lambdabot> No matches, try a more general search
03:06:08 <mahogny_> dons, ping
03:07:39 <dons> mahogny_: yo.
03:08:18 <mahogny_> dons, build problems of yi, anything you are aware of?
03:08:58 <dons> haven't built it recently. check with jyp and on the yi wiki page
03:09:41 <mahogny_> nothing on the wiki. ok
03:09:49 <mahogny_> check with him later
03:12:12 <sphynx> hmm, is there in haskell some kind of 'eval'? So if I'd encounter string "+", I could automatically use (+)
03:12:43 <augustss> no
03:12:46 <sphynx> because now I write smth like this: evaluate' "+":xs x1:x2:s = evaluate' xs (x1 + x2):s
03:13:09 <sphynx> and three other lines for -,*,/
03:13:28 <matthew-_> it's pretty easy to write an interpreter for '+' '-' '*' and '/'
03:13:28 <augustss> you'll have to write something like that somewhere
03:14:49 <sphynx> augustss, OK, I've understood
03:15:28 <augustss> sphynx: you write it in a shorter way, but it will involve some translation between the string and the function
03:15:52 <matthew-_> > let e :: String -> [Int] -> Int; e _ [result] = result; e '+':restOps lhs:rhs:restArgs = e restOps (lhs + rhs):restArgs; e '-':restOps lhs:rhs:restArgs = e restOps (lhs - rhs):restArgs; e '*':restOps lhs:rhs:restArgs = e restOps (lhs * rhs):restArgs; e '/':restOps lhs:rhs:restArgs = e restOps (lhs `div` rhs):restArgs in e "+" [5,3]
03:15:52 <lambdabot>  Parse error in pattern
03:16:34 <augustss> sphynx: once you have the simple version going you can try to figure out how to translate the string to the function using lookup
03:16:37 <Cheery> @hoogle IORef
03:16:38 <lambdabot> Data.IORef :: module
03:16:38 <lambdabot> Data.IORef.IORef :: data IORef a
03:16:38 <lambdabot> Data.IORef.atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
03:17:13 <Cheery> @hoogle IOExts
03:17:14 <lambdabot> No matches found
03:18:05 <Cheery> @hoogle unsafePerformIO
03:18:06 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
03:18:48 <Cheery> @hoogle newIORef
03:18:49 <lambdabot> Data.IORef.newIORef :: a -> IO (IORef a)
03:18:52 <augustss> unclean, unclean!
03:24:48 <mwc> How often do people really use unsafePerformIO?
03:25:05 <mwc> all the times I absolutely need imperative effects, ST suffices
03:25:26 <mwc> (and yes, I'm aware that unsafePerformIO hides inside lazyIO)
03:25:40 <mwc> I mean real, explicit, uses of unsafe* in your code
03:27:08 <pjd_> i imagine it might be useful for quick&dirty debugging
03:27:28 <Cheery> mwc: yampa seems to use unsafePerformIO
03:27:33 <pjd_> to fudge a print in somewhere
03:27:38 <Cheery> at least it has imported it
03:27:57 <mwc> pjd_, like Debug.Trace?
03:27:58 <Cheery> (in tests=
03:28:01 <jmg_> hi
03:28:51 <jmg_> is anyone here who can look after the webserver at haskell.org. it seems to be down.
03:29:37 <pjd_> mwc: oh, yes;  i wasn't aware of that :)
03:30:38 <mwc> grep -hc unsafe *.hs | ghc -e "getContents >>= putStrLn . show . sum . map (read :: String -> Int) . words"
03:30:38 <mwc> 0
03:31:27 <mwc> This in a set of numerical analysis codes
03:33:25 <ToRA> 'morning #haskell
03:33:27 <mwc> Heck, I'll go one better
03:33:28 <mwc> find ~ -name "*.hs" | xargs cat | grep -hc unsafe
03:33:31 <mwc> 0
03:33:45 <mwc> so how often do people really have to use an unsafe* function?
03:34:48 <hpaste>  sphynx pasted "Postfix int evaluator" at http://hpaste.org/1612
03:35:12 <sphynx> yeah, it works :)
03:35:29 <pjd_> mwc: find . -name '*.hs' -exec grep -hc unsafe {} +
03:35:52 <mwc> what's the {} + business?
03:36:24 <pjd_> it's like "{} ;", but provides multiple arguments at a time instead of just one
03:36:39 <pjd_> so it gives you the efficiency of xargs
03:36:56 <sphynx> please, check my postfix evaluator ;) it uses pattern matching and list as stack passed as parameter
03:36:58 <mwc> pjd_, ah. only problem is that this way you still have to sum ;)
03:37:11 <pjd_> oh, point
03:37:29 <mwc> besides, I'm pretty sure cat is reasonably lazy
03:37:44 <pjd_> not lazy, but buffered
03:37:58 <mwc> Well, I mean that it opens files as their contents are needed
03:38:10 <pjd_> oh, right
03:38:22 <ToRA> why use are we all using find?  grep --include="*.hs" -R "fold" . | wc -l
03:38:36 <ToRA> s/fold/unsafe
03:38:52 <pjd_> ToRA: GNU!
03:38:57 <ToRA> ah
03:40:00 <pjd_> should be able to use -c in that version too, though
03:40:06 <pjd_> wins
03:40:10 <ToRA> pjd_, yes and no
03:40:33 <ToRA> if you include -c you have to actually sum the numbers output, instead of just count the number of lines output
03:40:44 <ToRA> and i couldn't find a shellutil to do the summing
03:40:50 <ToRA> (though it probably exists)
03:40:51 <pjd_> sphynx: why the renaming of the words builtin?
03:41:09 <ToRA> mmm, is www.haskell.org/ghc down?
03:41:30 <pjd_> ToRA: oh, right, -c is filewise
03:41:43 <ToRA> lambdabot's lack of response doesn't fill me with confidence :s
03:41:49 <andun> ToRA: what about multiple uses of unsafe in one line? :)
03:41:49 <ToRA> pjd_ yup
03:42:07 <ToRA> andun: have you ever done that?
03:42:27 <andun> i've never used it at all
03:43:16 <sphynx> pjd_, I use the parse function for words, because later I can change words to some more correct (to allow parsing of "1+2", not only "1 + 2")
03:43:18 <mwc> andun, if you use it twice in one line, then on the next full moon at midnight, Church rises from the grave to seek your blood
03:43:39 <pjd_> sphynx: ok, nice
03:44:48 <hpaste>  sphynx annotated "Postfix int evaluator" with "Postfix fixed" at http://hpaste.org/1612#a1
03:45:55 <pjd_> heh
03:46:00 <pjd_> sphynx: that's quite nice
03:47:15 <jmg_> ToRA: yes, haskell.org seems to be down, The logfiles at tunes.org show that this was already noticed some hours ago
03:47:33 <sphynx> pjd_, I've changed order of x1 and x2 in "-" operation :) now it works like a charm
03:47:51 <sphynx> but without any error handling yet
03:49:46 <pjd_> hmm, maybe you can change the evaluate' [] (x:xs) = x case to evaluate' [] [x] = x
03:49:48 <ToRA> jmg_, k - cheers
03:50:35 <pjd_> to make it error out on stack overflow in addition to underflow
03:51:48 <kuribas> sphynx: You could also use an association list to store the functions.
03:52:57 <jmg_> www.haskell.org is back
03:53:03 <kuribas> like: "funcs = [("+", (+)), ("*", (*)), ("-", (-)), ("/", div)]" and then "lookup f funcs"
03:53:23 <pjd_> you won't use pattern-matching to consume the input list, then
03:53:55 <pjd_> you'll probably want to split the evaluate' function
03:53:59 <sphynx> pjd_, yeah, it sounds reasonable
03:54:26 <pjd_> into one that applies a single operator to the evaluation stack
03:54:50 <pjd_> or a single token, rather
03:54:53 <pjd_> and one that takes a list of tokens and feeds it
03:56:38 <sphynx> but I will need pattern matching anyway for distinguishing between number and operator tokens, yeah?
03:57:16 <pjd_> well, you make a separate token parsing function
03:57:34 <pjd_> that parses a token into either a number or operator (at this point)
03:58:00 <pjd_> which you can represent as an algebraic type, and pattern match on more conveniently in your eval function
03:58:56 <sphynx> pjd_, ok, thanks, I will try to use this approach as well
04:01:12 <pjd_> sphynx: something like data Term = Num Int | Op (Int -> Int -> Int)
04:02:26 <mauke> or data Term = Num Int | Add | Sub | Mul | Div deriving (Show)
04:03:34 <sphynx> pjd_, I will paste my result then :)
04:12:03 <dcoutts> foxy-om: the right thing to do is to use the filepath library rather than c2hs's own internal module
04:12:03 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
04:13:59 <foxy-om> dcoutts: does that require a major overhaul?  It is interesting that the backslashes are the correct number inside the source comments but not the foreign import "...
04:14:19 <dcoutts> foxy-om: aye, that is interesting
04:32:08 <Cheery> darn, this yampa requires an older version from haskell or something?
04:36:14 <hpaste>  sphynx annotated "Postfix int evaluator" with "Postfix evaluator revisited" at http://hpaste.org/1612#a2
04:37:04 <sphynx> could you please take a look at?
04:38:06 <sphynx> Now it uses data 'Token', lookup for supported functions and simple token parsing
04:38:47 <matthew-_> does haskell do automatic fixed point stuff? eg \f -> f' where f' = somefuncOf f g; g = somefuncOf f'
04:39:01 * Heffalump tries to think of a good Haskell program that fits on one slide to serve as an introduction
04:39:08 <DRMacIver> sphynx: Would you not be better off using Data.map for the lookup?
04:39:15 <matthew-_> because I have code that terminates which I didn't expect to terminate!
04:39:21 <Heffalump> matthew-_: I don't think f would be in scope in that where clause
04:39:28 <Heffalump> where applies to declarations, not expressions
04:39:48 <Heffalump> so only the things bound by the enclosing declaration are in scope in the where clause
04:40:02 <matthew-_> Heffalump: ok, sorry, I'm trying to cut down a much bigger code example for IRC!
04:40:13 <matthew-_> it is a real func
04:40:24 <Heffalump> in general anything in scope will form part of a recursive definition, yes
04:40:28 <sphynx> DRMacIver, yeah,it can be done with Map too
04:41:49 <hpaste>  matthew-_ pasted "the use of bug' at the last line doesn't cause non-termination!" at http://hpaste.org/1613
04:43:08 <Heffalump> can you run through why you think it should?
04:43:23 <Heffalump> It's quite a complicated piece of code and I don't know what fieldValueExtractor should do, for example
04:44:42 <matthew-_> oh, sorry, fieldValueExtractor :: Bug -> FieldValue
04:44:55 <matthew-_> I'm sure it's just down to the laziness.
04:45:06 <Heffalump> that's not hugely illuminating. But yes, quite likely.
04:45:19 <matthew-_> but I just didn't expect to be able to get away with using bug' rather than bug on the last line
04:45:57 <DRMacIver> Doesn't laziness often end up in fixed point stuff being handled automatically? e.g. fix is just defined as 'fix f = let x = f x in x'
04:46:12 <Heffalump> indeed
04:46:36 <matthew-_> I thought "I really want to use bug' to ensure that I'm extracting the value from the updated bug" but then I thought "but the updated bug is formed by the effect of the extractor anyway, so this'll loop". And then it terminated. And jaws did drop.
04:46:48 <DRMacIver> It took me a little while to figure out how on earth that one worked. :) The lazy evaluation strategy still throws me.
04:46:50 <Heffalump> have you seen repmin?
04:46:55 <matthew-_> nope
04:47:24 <Heffalump> I can't find it online anywhere trivially and I can't be bothered to write it out myself
04:47:59 <Heffalump> but basically, it's a single pass program that calculates the minimum value in a tree (which has numbers on the leaves), and replaces all the leaf values with that minimum value
04:48:53 <matthew-_> ahh yes, I taught that this year to the 1st years!
04:49:01 <matthew-_> ahh, it all comes flooding back
04:49:04 <Heffalump> :-)
04:49:07 * matthew-_ finds his lecture notes
04:49:44 <hpaste>  sphynx annotated "Postfix int evaluator" with "Postfix evaluator with Map" at http://hpaste.org/1612#a3
04:50:21 <sphynx> DRMacIver, now it is with Map.lookup :)
04:50:36 <Baughn> Say... 'fix f' produces a value that, if it is never actually needed, turns into an exception... right?
04:50:46 <Baughn> *ever, not never
04:50:58 <Heffalump> Baughn: depends on your f
04:51:23 <Baughn> Heffalump: You mean, it'll terminate if the f does not actually use its input
04:51:25 <Heffalump> > fix (const 1)
04:51:27 <lambdabot>  1
04:51:33 <Heffalump> not just then
04:51:36 <Heffalump> > fix (1:)
04:51:38 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:52:04 <Baughn> My head hurts. I'll go make some tea.
04:52:19 <DRMacIver> I wrote a simple blog post explaining how this worked a while ago. Want me to dig it up?
04:52:28 <DRMacIver> It's not very well written. Just me thinking out loud. :)
04:52:29 <Heffalump> > fix (\f x -> if x == 0 then 1 else f (x - 1) * x)
04:52:31 <lambdabot>  <Integer -> Integer>
04:52:35 <Heffalump> > fix (\f x -> if x == 0 then 1 else f (x - 1) * x) 7
04:52:36 <lambdabot>  5040
04:52:56 <pejo> I'll jump in a bit late in the conversation, as usual. What is the 'magic' thing with fix under lazy evaluation?
04:53:04 <Heffalump> wdym by "magic"?
04:53:06 <Saizan> Baughn: remember that lazy evaluation is outermost first
04:53:58 <DRMacIver> pejo: http://unenterprise.blogspot.com/2007/03/fix-f-let-x-f-x-in-x.html
04:54:02 <Baughn> Saizan: Yes, I see. Oh, my head.
04:54:03 <lambdabot> Title: Desperately UnEnterprise: fix f = let x = f x in x, http://tinyurl.com/yphugj
04:54:05 <Cheery> @hoogle Random
04:54:06 <lambdabot> Random :: module
04:54:06 <lambdabot> System.Random :: module
04:54:06 <lambdabot> System.Random.Random :: class Random a
04:54:35 <DRMacIver> Hm. Although I note I said in that that "Fix" is a generalisation of the Y combinator. I guess it just is the Y combinator, but the version I'm used to is the Y combinator under an eager evaluation strategy.
04:54:44 <Baughn> DRMacIver: Why is it called the "least fixed point operator"?
04:55:07 <DRMacIver> Baughn: Because it produces a fixed point of its argument. The one produced is in some sense 'minimal'
04:55:47 <DRMacIver> (where there isn't a fixed point it will usually not terminate)
04:56:21 <Heffalump> there's a slightly more technical explanation
04:56:28 <dolio> Well, there's always a fixed point.
04:56:39 <pejo> DRMacIver, that fix works fine with a strict language too though.
04:56:42 <dolio> Sometime the fixed point is bottom, which is non-termination. :)
04:56:57 <Heffalump> There's a special semantic value in Haskell called bottom, which corresponds to non-termination or failure.
04:57:03 <Heffalump> That's "lower" than any other Haskell value.
04:57:06 <DRMacIver> pejo: Not really.
04:57:12 <Heffalump> also, 1:_|_ is lower than 1:[]
04:57:15 <pejo> Heffalump, I think I was referring to <DRMacIver> Doesn't laziness often end up in fixed point stuff being handled automatically?.
04:57:15 <Heffalump> and so on
04:57:53 <DRMacIver> dolio: True. :)
04:58:12 <Heffalump> let x = f x won't work in a strict language
04:59:10 <Heffalump> so "least fixed point" is the "lowest" value that is also a fixed point for the equation in question
04:59:46 <Heffalump> so even though let x = x  has a fixed point of 1, it also has _|_ as a fixed-point, so that's the result you get from a Haskell implementation
05:00:32 <Baughn> fix (\x -> x + 1) doesn't work, producing <<loop>>, but how does haskell detect that?
05:01:35 <Baughn> ..oh, I see
05:02:06 <Heffalump> + is strict
05:02:18 <Heffalump> in both its arguments
05:02:33 <Heffalump> the technical definition of strict is that f x is strict in x if f _|_ = _|_
05:02:56 <pejo> Heffalump, care to elaborate what goes wrong with let x = f x in a strict language?
05:03:01 <Heffalump> (more precisely, that f is strict in its first argument if f _|_ = _|_, but you get the general idea)
05:03:14 <Heffalump> pejo: well, in a strict language you always evaluate the arguments to a function before calling the function
05:03:23 <dolio> Baughn: ghc detects it by tagging the memory somehow so it can tell when it goes into a loop trying to evaluate some expression.
05:03:26 <Heffalump> which is a bit tricky with that definition
05:03:37 <Heffalump> ghc can't always tell it's gone into a loop
05:03:56 <Heffalump> it's just that in that case it can easily detect it's gone into a loop because of the way it implements lazy evaluation
05:03:57 <pejo> Heffalump, suppose you include variables in your values for the language.
05:04:05 <Baughn> Wouldn't it be nice if it did? It's turing-complete, though.
05:04:16 <Heffalump> well, exactly :-)
05:04:30 <Heffalump> pejo: I don't follow
05:05:14 <pejo> Heffalump, we're not allowed to do beta-reduction unless all arguments are values. Suppose we define variables to be values, for our langugae.
05:06:06 <Heffalump> pejo: then I think you've changed your language so it's no longer strict
05:07:50 <Cheery> wow, cabal is awesome
05:08:32 <Cheery> I were able to write such file by hand for a library I needed but didn't have one
05:10:10 <pejo> Heffalump, hm. Is the concern that you introduce termination with this new language, that wouldn't be there under a traditional cbv?
05:10:29 <Heffalump> I'm just saying that's not what strict evaluation is.
05:10:39 <Heffalump> I haven't even thought about any semantic problems this language would have apart from that.
05:11:11 <Heffalump> though I can imagine some, like the fact that inlining would no longer be a valid program transformation, as it'd replace a variable by a non-variable.
05:12:36 <mahogny> has anyone tried to write some bindings QT+haskell?
05:13:41 <Baughn> Qt's C++ and depends on subclassing to work properly.. hmm.
05:13:52 <Baughn> Has anyone ever tried to make a GUI toolkit that's tailored for /haskell/?
05:13:58 <pejo> Heffalump, unless you inline a previusly strict non-terminating expression in a non-strict position, do you see it breaking otherwise?
05:14:06 <mahogny> Baughn, too many
05:14:32 <mahogny> Qt is doing a lot of C++ preprocessing shit. I would guess that it is horrible to write bindings for
05:14:35 <Heffalump> pejo: not off the top of my head, but that's an issue in itself
05:14:45 <Heffalump> and similarly you can't do outlining
05:15:02 <Heffalump> but introducing non-termination where it wasn't before is pretty bad...
05:15:26 <dolio> They have some automated tools to help producing bindings, I think. Can't say I've looked at them, though.
05:15:51 <Baughn> dolio: There are C bindings, but they're 'orrible
05:16:05 <Baughn> To work properly, you need to be able to subclass the Qt mess
05:16:13 <mahogny> python has somehow succeeded in getting bindings. but I do not know the quality of it
05:16:15 <dolio> They do have bindings in several languages, but nothing like Haskell to my knowledge.
05:16:24 <pejo> Heffalump, by inlining you mean substituting a variable with an expression though?
05:16:28 <dolio> Python, Ruby, Java...
05:17:32 <Heffalump> pejo: yes
05:17:47 <pejo> Heffalump, and what is outlining, CSE?
05:18:28 <Heffalump> for example, yes
05:18:36 <Heffalump> though more generally just lifting an expression into a variable
05:20:21 <pejo> Heffalump, how is that? Let-statements are strict wrt to the variable bound, aren't they?
05:22:41 <Heffalump> not in the imaginary language you seem to be trying to design
05:27:17 <ndm> hi
05:28:18 <Heffalump> 'lo
05:28:26 <Heffalump> ircatwork on a Sunday? ;-)
05:28:41 <Pseudonym> Who's working?
05:28:54 <Heffalump> I was just referring to his hostname.
05:29:00 <Heffalump> Though I'm working, off and on, trying to write a talk :-/
05:29:01 <Pseudonym> Ah, right.
05:31:00 <ndm> ircatwork actually means on campus
05:31:12 <ndm> when i am either at work or at home i can use chatzilla
05:31:26 <ndm> i'm  trying to write a paper
05:31:43 <ivanm> ircatwork is back up again?
05:31:47 <ndm> well, i've written it, i'm now trying to tidy it so my supervisor doesn't shred it rather than correct it
05:31:50 <ndm> ivanm, yep
05:31:52 * ivanm had to rely on irc.jpgclan.com for a while when at uni
05:32:07 <ivanm> ndm: when did it re-start?
05:32:12 <ndm> i just used irssi over ssh
05:32:20 <ndm> ivanm, a few weeks ago i think
05:32:26 <ivanm> OK
05:35:31 <ndm> swiert, have you now got everything required for TMR?
05:36:06 <araujo> morning!
05:36:47 <mahogny> what is the performance of Data.Sequence?
05:37:29 <ndm> mahogny, good time bounds
05:37:30 <mahogny> just a bit worried since it's not mutable. I have some 500 000 elements I want to squeeze in
05:38:19 <ndm> bash it and find out!
05:38:27 <mahogny> hmmm :)
05:38:54 <mahogny> anyone know of some mutable queues if these fail? :P
05:40:39 <ndm> C?
05:40:47 <mahogny> google seems not to be on my side. oh well. I take that as a challenge :P
05:40:50 <ndm> mutable isn't very haskell'y
05:41:10 <ndm> and often mutuable ends up being slower than immutable - i certainly noticed that with arrays
05:41:38 <mahogny> truely not haskelly but it gives guarantess on memory bounds which might be needed with 100mb data. but I should definitely try the immutable ones
05:41:50 <mahogny> really? did you use the IO or ST monad in that case?
05:43:25 <Heffalump> mahogny: when you want it to be mutable, do you want to be able to change elements already on the queue, or do you just want "in-place" behaviour when you add/remove elements?
05:43:59 <ndm> mahogny, IntMap vs IOArray, IntMap kicked its ass
05:44:27 <Heffalump> ndm: and the structure wasn't changing in size?
05:44:36 <ndm> Heffalump, no
05:45:04 <Heffalump> that's quite impressiev
05:45:09 <ndm> Heffalump, it may have been our particular benchmark of read/writes, but it was a significant factor, over 10 I think
05:45:23 <Heffalump> presumably an IntMap is a tree-based structure?
05:45:31 <int-e> ndm: strange.
05:45:39 <ndm> we were trying to write a pure diff-array interface with certain properties, and high performance
05:45:42 <mahogny> Heffalump, mainly interested in space guarantees and efficiency. I guess it boils down to in-place things
05:45:44 <ndm> Heffalump, yes
05:45:55 <ndm> then we found out IntMap beats everything :)
05:46:02 * Heffalump finds it really strange, as an IOArray should have constant access times where IntMap has logarithmic.
05:46:11 <Heffalump> and an array is really "close to the metal"
05:46:27 <Heffalump> so there's no inherent constant factor to make up for that
05:46:50 <mahogny> hm. optimal would be if I could get my hands on a real priority queue
05:48:23 <ndm> Heffalump, in performance testing its often said that O(n) == O(n log n) - and we did n operations, so the constant factor must be the thing in there
05:48:33 <pierre-> ?src nub
05:48:34 <lambdabot> nub = nubBy (==)
05:48:41 <ndm> plus Bulat always says Haskell arrays are poorly optimised, from my experiment i can only guess he is write
05:48:42 <pierre-> ?src nubBy
05:48:43 <lambdabot> nubBy eq []             =  []
05:48:43 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
05:49:01 <ndm> or it may be GC issues, i know it doesn't handle pinned arrays as neatly or as well as it could
05:49:17 <Heffalump> Bulat also says ghc should be distributed with a kitchen sink :-)
05:51:32 <ndm> yes
05:51:37 <ndm> i saw that :)
05:52:02 <ndm> although the  particular kitchen sink he is talking about is quite a small one, compared to the kitchen units and bathroom that GHC already ships with
05:54:09 <Igloo> ndm: Do you mean all the stuff that gets bundled on Windows, or the libraries?
05:54:45 <Heffalump> hmm, we need a new kitchen in the house we're buying, perhaps I should just suggest we install ghc in it instead.
05:55:49 <ndm> Igloo, the GCC compiler
05:56:20 <matthew-_> so I have a list of two items, with custom definitions of Ord for the types of the items. Sorting the list dies with stack overflow. So something must be wrong in my definitions but I can't figure out what it could be. Any ideas?
05:56:36 <ndm> Igloo, PS. I enjoyed that marking bugs as invalid trick on the bug tracker, any idea who it was?
05:57:02 <ndm> matthew-_: are your ord definitions terminating, transitive, reflexive and anti-symetric
05:57:27 <kpreid> [07:56] <Heffalump> let x = f x won't work in a strict language
05:57:40 <matthew-_> ndm: I think I've spotted it, and it's only just related! - there's an Eq that I rely on which isn't terminating!
05:57:49 <kpreid> Heffalump: I use and implement a strict (or at least, not lazy) language in which that's not true :-)
05:57:56 <Igloo> ndm: No idea
05:58:04 <Heffalump> kpreid: not lazy != strict
05:58:17 <kpreid> Heffalump: okay, that's probably sufficient
05:58:49 * Heffalump thinks that by definition a strict language can't have that definition terminate.
06:01:54 <kpreid> Well, what if the definition of (the equivalent of) let where the bound variable occurs on the right side is such that failure will occur if x is examined (as opposed to just passed) during the evaluation of f x?
06:02:34 <kpreid> (I'm being deliberately vague because I'm curious about the concepts in general)
06:02:40 <mdmkolbe-home> has there been any progress on commutitive monads since the SPJ's 'Hair shirt' talk?
06:03:08 <int-e> kpreid: that goes at least half the way to lazy evaluation. you might just as well go the extra mile.
06:03:55 <int-e> kpreid: at least as I understand it what you just wrote has all the complications of lazy evaluation without any of the benefits.
06:04:27 <kpreid> heh, I see
06:04:55 <kpreid> the catch is, the language has pervasive side effects
06:05:27 <kpreid> so this mechanism (which is more general than recursive let) allows (among other things) such circular definitions without relinquishing control of evaluation order
06:05:27 <dons> mdmkolbe-home: hmm, there's the applicative functor work. that provides more flexibility than monads in some cases.
06:05:56 <dons> mdmkolbe-home: see Control.Applicative, and applicative programming with effects, http://www.soi.city.ac.uk/~ross/papers/Applicative.html
06:05:57 <lambdabot> Title: Applicative Programming with Effects
06:06:15 <mahogny> ok. the only priority queue in the haskell standard libraries gives a stack overflow :P
06:06:29 <mahogny> suggestions anyone?
06:06:34 <dons> mahogny: using the queue in the 'collections' library?
06:06:41 <dons> ?hackage collections
06:06:42 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/collections
06:06:54 <dcoutts> @seen shapr
06:06:55 <lambdabot> shapr is in #haskell. I last heard shapr speak 4h 17m 2s ago.
06:07:07 <dons> dcoutts: you're back :-)
06:07:07 <mahogny> no. but I could try it. I took this one from FGL since it was in the standard libs
06:07:07 <dcoutts> dons: so we got onto the lncs website finally I see
06:07:11 <dcoutts> dons: I am! :-)
06:07:25 <dons> mahogny: hmm. FGL isn't so performance tuned.
06:07:34 <dons> mahogny: i'd look at 'collections' or 'edison'
06:07:57 <dons> http://www.eecs.tufts.edu/~rdocki01/
06:07:58 <mdmkolbe-home> FLG = ?
06:07:58 <lambdabot> Title: Robert Dockins
06:08:15 <dcoutts> dons: so I was thinking of starting a blog and doing a proper home page
06:08:26 <mdmkolbe-home> FGL = ?
06:08:30 <dons> dcoutts: yeah, Internet 2.0 is cool :-)
06:08:34 <dons> mdmkolbe-home: functional graph library
06:08:40 <dcoutts> dons: this coming year I'll be wanting to attract more job offers :-)
06:08:46 <dons> dcoutts: heh
06:08:56 <dons> dcoutts: get your brand out there, eh?
06:09:01 <dcoutts> dons: you market yourself quite effectively with your website
06:09:10 <swiert> ndm: Yes. I'll send out the next issue first thing Monday.
06:09:26 <dons> dcoutts: yeah, i think a decent website can be pretty useful.
06:10:17 <ndm> dcoutts, i get at least one job offer every 2 months from my website
06:10:17 <mdmkolbe-home> @src liftA2
06:10:18 <lambdabot> liftA2 f a b = f <$> a <*> b
06:10:27 <ndm> * 2 weeks, i meant - 2 a month
06:10:31 <mdmkolbe-home> @src (<$>)
06:10:31 <lambdabot> f <$> a = fmap f a
06:11:21 <dons> dcoutts: you could write something on gtk, or binary serialisation, or whatever you happen to be hacking on.
06:11:25 <dons> get the word out :-)
06:12:05 <dcoutts> dons: right, and on teaching. So the Q is where to host and what with
06:12:22 <dcoutts> I was thinking of putting another wordpress instance on haskell.org/~duncan/
06:12:23 <ndm> dcoutts, blogger.com
06:12:29 <dons> dcoutts: something on using strong lax monoidal functors and rewrite rules to eliminate bounds checking would be fun.
06:12:38 * dons laughs at the Control.Applicative docs
06:12:43 <dcoutts> ndm: I don't really like the idea of hosting somewhere I don't have loging access to
06:13:15 <dcoutts> dons: right, I've got a lot to talk about, and I need to practise my writing
06:13:29 <ndm> dcoutts, why?
06:13:48 <dons> ndm, its nice to keep your content in darcs, and under your own control, i guess.
06:13:55 <dcoutts> ndm: I'd like control over my data thanks :-) call me old fashioned
06:14:05 <ndm> its all under the control of Google, along with all my email etc.
06:14:14 <dcoutts> dons: what do you use? darcs + scripts to generate html ?
06:14:29 <dons> i just use darcs, and blosxom to read the darcs repo and render it
06:14:35 <dons> no scripts, other than hscolour
06:14:48 <dons> so writing an article is vim + darcs push
06:15:02 <Heffalump> ndm: what kind of job offers?
06:15:07 <dcoutts> dons: right, I've got scripts to syntax highlight + hyperlink haskell code in txt2tags source
06:15:28 <dcoutts> dons: that sounds quite good
06:16:03 <mahogny> hm. which command to build documentation with cabal? runhaskell setup.hs haddock?
06:16:13 <dons> mahogny: yeah
06:16:14 <ndm> Heffalump, consulting firms, netcraft, PR firms
06:16:24 <mahogny> nice. then cabal dies on collections :P
06:16:44 <dons> mahogny: there's always the src if the docs aren't pregenerated somewhere.
06:16:47 <ndm> Heffalump, some are full time, some are "can we hire you do to this", some are consulting firms on year long contracts
06:17:07 <dons> so not haskell offers, then, ndm?
06:17:32 <ndm> dons, not yet :(
06:18:05 <dons> i've had one haskell offer purely based on the blog. key trick use "practical haskell" somewhere on your page ;-)
06:18:38 <ndm> dons, clever :)
06:18:55 <ndm> i actually get most offers from the keyword "Bristol" it appears
06:19:16 <dons> bed time. night all! happy lambdas.
06:21:16 <mahogny> uuh. I see why haddock failed. it found an #if in a .hs-file. that was original
06:22:05 <dcoutts> g'night dons
06:23:01 <mdmkolbe-home> :type \f a b -> f <$> (a <*> b)
06:23:32 <mdmkolbe-home> :type \f a b -> (f <$> a) <*> b
06:32:26 <ndm> dcoutts, i'm giving a talk on my haskell optimiser next month, so will have slides and benchmarks for you by then
06:32:40 <ndm> plus if you're near York you are welcome to attend,but its an awful long way to go :)
06:33:16 <dcoutts> ndm: great
06:33:28 <dcoutts> ndm: what day exactly?
06:33:39 <dcoutts> just in case I'm near york :-)
06:34:20 <ndm> http://www.cs.york.ac.uk/plasma/wiki/index.php?title=Meetings_in_Summer_2007
06:34:24 <ndm> 31st
06:34:24 <lambdabot> Title: Meetings in Summer 2007 - The Programming Languages and Systems Research Group, http://tinyurl.com/yu8vlh
06:36:20 * mdmkolbe-home comes back after skimming through the Control.Applicative docs
06:37:22 <ndm> dcoutts, if you are in York on a thursday, and do want to come, we can probably rejig the timetable a bit
06:37:56 <dcoutts> ndm: ok, I'll tell you if I'll go
06:38:03 <mdmkolbe-home> I don't think Control.Applicative properly implements commutative monads b/c every monad is an applicative by virtue of the WrappedMonad instance.  However not every monad is a commutative monad.  Is there something I missed?
06:39:54 <dcoutts> mdmkolbe-home: I'm not sure that follows
06:40:21 <dcoutts> mdmkolbe-home: erm actually maybe it does :-)
06:41:14 <dcoutts> mdmkolbe-home: an applicative functor is more general than a monad and a commutative monad is mode specialised than a monad
06:44:52 <ndm> @pl \a b -> g a (f b)
06:44:52 <lambdabot> (. f) . g
06:45:04 <ndm> @pl \b -> g a (f b)
06:45:05 <lambdabot> g a . f
06:45:45 <DRMacIver> Hm.
06:46:32 <DRMacIver> I was about to write some examples in Nice in order to demonstrate a point about type classes (It's about the only language I know which has both side effects and type classes), and I almost immediately ran into the exact reason why I no longer use Nice for anything. :)
06:46:46 <ndm> which is?
06:46:51 <DRMacIver> Bizarre and inexplicable failures of sanity every time you so much look at a generic type.
06:47:13 <ndm> use Ada - that will make you appreciate Nice, i'm sure
06:47:25 <DRMacIver> Not really.
06:47:39 <dcoutts> foxy-om: I've sent you another c2hs patch that I hope will help with mingw
06:47:43 <DRMacIver> The problem is more that it's broken than that it's badly designed. :)
06:48:03 <DRMacIver> (I have an annoying suspicion this problem, which I've seen before, is related to some sort of GNU madness. I've not verified this though.)
06:48:06 <ndm> Ada has both
06:49:55 <DRMacIver> Out of curiousity, are there any other languages which have both type classes and side effects?
06:50:25 <Heffalump> I don't know of any languages other than Haskell with type classes
06:51:08 <DRMacIver> Well, as mentioned, Nice has something very similar. :)
06:51:38 <Heffalump> ah :-) Never heard of it.
06:51:55 <DRMacIver> No reason you would have. It's a semi-obscure JVM language which has all but died.
06:52:08 <Heffalump> what does scala have?
06:52:13 <DRMacIver> It can be broadly thought of as a weird dialect of ML with subtyping and type classes.
06:52:21 <DRMacIver> Nice that is, not Scala.
06:52:40 <DRMacIver> I'm not sure exactly how Scala's type system works. It's a bit... odd. I don't think it has a type class analogue.
06:54:14 <DRMacIver> (Nice would be my favourite language if it worked. Unfortunately it doesn't, so it's instead a source of constant frustration for me as I keep going back to it thinking "Nice has the perfect construct for what I want to do. I'm sure it can't be as broken as I remember." only to find that it is.)
07:06:20 <tibbe> has SoC started yet?
07:08:14 <ndm> tibbe, no
07:09:49 <fasta> When I have in C: a = b where a and b are pointers, how can I achieve the same with STRefs?
07:10:30 <Heffalump> by having STRef (STRef ...)
07:11:14 <fasta> Ok.. writing mutable algorithms is a pain in Haskell :(
07:11:25 <Heffalump> what's the algorithm?
07:12:05 <DRMacIver> I'm not sure I understand why using an STRef (STRef ...) is a pain. That's logically exactly how it should be typed...
07:12:27 <fasta> http://www.cs.cmu.edu/~sleator/papers/self-adjusting.pdf
07:12:44 <Heffalump> DRMacIver: well, dereferencing is rather less concise than in C
07:13:28 <DRMacIver> Fair enough.
07:13:39 <fasta> I tried to implement the algorithm functionally and succeeded partially, but the whole thing is _way_ more complex than a mutable implementation.
07:13:50 <DRMacIver> I guess that's just my reading more Haskell than I write issue playing up again. :)
07:14:31 <DRMacIver> Hm
07:14:33 <fasta> Er, mutable implementation in Java would be.
07:14:51 <fasta> Java does have garbage collection which makes it easier than C.
07:14:54 <DRMacIver> Ubuntu has acquired a new feature in the latest upgrade. I'm not sure if I like it or not.
07:15:06 <tibbe> DRMacIver, what's that?
07:15:09 <DRMacIver> If I type in a command which it has in the apt repositories but not installed, it helpfully tells me it can install it.
07:15:17 <tibbe> ah, that one
07:15:57 <DRMacIver> (I was about to fire up mosml in order to confirm I remembered how references worked in ML, only to discover I never got around to installing it on this computer. I've really let my ML slide...)
07:16:35 <mahogny> hmmmm. haskell collections AVR-tree is incredibly messy to use. and it kills my stack :(
07:17:49 <fasta> Heffalump: how would the data type look like then for this binary tree?
07:17:49 <fasta> I thought
07:17:49 <fasta> data Tree s a = Bin {left::STRef s (Tree s a),
07:17:49 <fasta>                      item::a,
07:17:49 <fasta>                      right::STRef s (Tree s a)}
07:17:49 <fasta>               | Null
07:18:23 <Heffalump> that looks reasonable
07:18:30 <DRMacIver> I was going to ask why Haskell didn't follow ML's lead and use ! for dereferencing, but of course in Haskell ! would have to be an infix operator.
07:18:30 <Heffalump> why do you need a = b where a is a pointer?
07:18:46 <fasta> Heffalump: the C implementation also does it.
07:18:59 <fasta> Heffalump: http://www.link.cs.cmu.edu/grammar/ftp-site/splaying/top-down-size-splay.c
07:19:02 <lambdabot> http://tinyurl.com/2nah3l
07:19:03 <Heffalump> fasta: ok, but perhaps you should look to restructure that somewhat
07:19:28 <Heffalump> things that are done one way because it's elegant in C aren't necessarily worth repeating in another language
07:19:38 <fasta> Heffalump: I restructured enough already by implementing it in a purely functional way. I now just want it to work.
07:19:47 <DRMacIver> Is there any particular reason for not allowing the (in|post|pre)fixing of arbitary functions in Haskell, or is it just easier from a parsing perspective?
07:19:57 <Heffalump> well, hack away then :-)
07:20:17 <Heffalump> YM arbitrary expressions? Infixing arbitrary functions is possible.
07:20:29 <Heffalump> > 10 `divMod` 7
07:20:31 <lambdabot>  (1,3)
07:20:33 <DRMacIver> Only by wrapping them in ` `
07:20:45 <Heffalump> that seems quite syntactically light
07:20:49 <Heffalump> how would you distinguish them otherwise?
07:21:07 <Heffalump> a f b is normally a applied to f and b
07:21:29 <DRMacIver> Sure. But if f is declared as an infixed function then it's not. :)
07:21:33 <Heffalump> oh, right
07:21:41 <fasta> Heffalump: Hmm, no the problem was with r->left = t;
07:21:49 <Heffalump> I think that would pose nasty parsing problems.
07:21:56 <Heffalump> fasta: ok, you don't need two STRefs for that
07:22:01 <Heffalump> writeSTRef (left r) t
07:22:09 <Heffalump> oh, wait, no, you do
07:22:15 <DRMacIver> I suspect it does, but ML has successfully done it for years, so they can't be that nasty.
07:22:23 <Heffalump> no, you don't.
07:22:26 * Heffalump makes up his mind
07:22:34 <DRMacIver> On the other hand ML is a lot more bracket heavy than Haskell is. These may be not unrelated points.
07:22:42 <Heffalump> has it? I've written a fair bit and I don't remember infix functions.
07:23:07 <Heffalump> fasta: in Haskell a variable of type Tree ... is just a read-only pointer to the value.
07:23:27 <fasta> Heffalump: yes, but I don't know how to do the assignment.
07:23:33 <Heffalump> writeSTRef (left r) t
07:23:39 <DRMacIver> Heffalump: mosml certainly does. "ML for the working programmer" mentions the feature, so I'm pretty sure it's standard.
07:23:56 <Heffalump> DRMacIver: interesting, maybe I've forgotten it, or never realised it was there.
07:24:18 <DRMacIver> Heffalump: infix foo; fun m foo n = m + n; 2 foo 3;
07:24:35 <Heffalump> fair enough
07:24:45 <DRMacIver> You can also specify precedence, but I don't remember the syntax offhand.
07:24:47 <Heffalump> fixity declarations in Haskell make parsing hard enough already
07:24:55 <DRMacIver> Yeah
07:25:02 <Heffalump> but I can't see this making it any worse.
07:25:05 <fasta> Heffalump: link_right ref_r ref_t = do
07:25:05 <fasta>  r <- readSTRef ref_r
07:25:05 <fasta>  t <- readSTRef ref_t
07:25:05 <fasta>  let ref_left_t = left t
07:25:05 <fasta>      ref_left_r = left r
07:25:05 <fasta>  writeSTRef ref_left_r ref_t
07:25:15 <fasta> Heffalump: that's what I had already, and it doesn't compile
07:25:31 <Heffalump> that's because you should have writeSTRef ref_left_r t
07:25:48 <DRMacIver> I don't know how ML implementations pull this off nicely. I suspect it uses a two pass parser which sets up the symbol table for fixity declarations first then parses the rest.
07:25:55 <Heffalump> as I'm sure the type error helps you see :-)
07:26:00 <fasta> Heffalump: ah, of course
07:26:22 <fasta> Heffalump: actually the type error just irrationally annoyed me.
07:26:25 <Heffalump> I think most Haskell parsers just parse an amorphous blob of stuff separated by juxtaposition which they then fix up afterwards
07:26:47 <augustss> you pretty much have to
07:27:12 <DRMacIver> Hm. Actually, it doesn't need to be two pass.
07:27:19 <augustss> unless you read ihe interface files while parsing and adjust the operator parser
07:27:21 <DRMacIver> As the infix declaration has to precede its useage as an infix function.
07:27:21 <fasta> augustss: you said you build your own computer. How much of it did you build yourself?
07:27:27 <Heffalump> which kind of amounts to two-pass parsing, except that you have a tree already
07:27:36 <fasta> augustss: At some point, I assume you took off-the-shelf components.
07:27:45 <Heffalump> augustss: fixity declarations can occur in the same module..
07:27:54 <augustss> fasta: I bought the chips and other components
07:28:57 <Heffalump> DRMacIver: in Haskell the fixity declarations don't have to
07:29:01 <augustss> Heffalump: is the fixity declaration allowed to be after the operator is used?  Hmmm, yes, probably.
07:29:16 * Heffalump realises that o in SML must be an infix thingy.
07:29:21 <DRMacIver> Heffalump: Yeah. I meant from ML's perspective.
07:29:38 <Heffalump> I always found the use of a single letter as a builtin ugly.
07:29:44 <fasta> Heffalump: r = t then is writeSTRef ref_r t?
07:29:48 <Heffalump> s/builtin/piece of the standard library/
07:29:53 <Heffalump> fasta: yeah
07:30:07 <augustss> fasta: I also built the terminal my computer was connected to. :)
07:30:53 <fasta> augustss: that's nice, I only have an abstract idea of how I would do that.
07:31:10 * ndm blows up computer chips on touch
07:31:57 <augustss> fasta: it's no fun any longer,  it's difficult for an amateur to build a computer with good performance
07:32:27 <fasta> augustss: I did read recently how one could build a water computer :)
07:32:28 * DRMacIver built his computer, but only in a very 'I plugged together standard components' sense. :)
07:32:52 * fasta does that kind of building too sometimes
07:32:58 <augustss> I made the circuit board for the computer I built
07:33:15 <fasta> Why?
07:33:15 <DRMacIver> Yeah, I figured you were talking about something rather more serious.
07:34:10 <augustss> It was clocked at an amazing 3MHz!
07:35:40 <fasta> It's rather unfortunate that technology becomes more blackbox all the time.
07:36:03 * fasta mumbles sufficiently advanced ... magic
07:37:36 <fasta> Is there any programming language that understands things like symmetry?
07:37:45 <DRMacIver> In what sense?
07:38:33 <fasta> DRMacIver: In the sense that it is usually understood in data structure articles
07:39:01 <DRMacIver> I meant 'understands' in what sense. :)
07:39:06 <Saizan> do undecidable instances work only in GHC?
07:39:30 <ndm> Saizan, they work somewhat in Hugs - although not in the same way
07:40:04 <fasta> DRMacIver: as in that you supply code for one case and that the compiler generates the code for the symmetric case.
07:40:12 <fasta> DRMacIver: I think Coq has something like that for proofs.
07:40:18 <DRMacIver> Ah
07:40:23 * fasta should learn Coq
07:40:38 <DRMacIver> I've played with it briefly. It's pretty neat.
07:40:45 <DRMacIver> Never did anything serious with it though.
07:41:04 <Saizan> uhm, i'd like to do what Show does without the equivalent of showList ..
07:41:32 <Cheery> what does the '!' mean in the front of typE?
07:41:44 <sorear> .
07:41:49 <Cheery> ie. data Foo = Guux !SomeSuperFluousType
07:41:57 <sorear> strictness!
07:42:19 <sorear> Saizan: I wish you luck!
07:42:35 <Saizan> not comforting ..
07:42:44 <Cheery> huh?
07:42:59 <Cheery> sorear: strictness like how?
07:43:08 <ndm> Saizan, i recently played with this type class stuff, then gave up and went back to Typeable - much easier
07:43:39 <sorear> Cheery: http://haskell.org/onlinereport/decls.html#sect4.2.1
07:43:41 <lambdabot> Title: The Haskell 98 Report: Declarations
07:43:57 <sorear> Cheery: the 'Strictness flags' subheading
07:44:38 <Saizan> ?docs Data.Typeable
07:44:38 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html
07:48:34 <DRMacIver> Hm. What does Haskell use for tuple access functions? e.g. (x, y) -> x
07:48:35 <sorear> fasta: if you're still interested in this kind of stuff you might want to get in touch with kc5tja, he's designing a buildable computer
07:48:40 <sorear> DRMacIver: fst
07:48:48 <Syzygy-> DRMacIver: And snd
07:48:54 <Syzygy-> > fst (2,3)
07:48:56 <lambdabot>  2
07:48:58 <Syzygy-> > snd (2,3)
07:49:00 <lambdabot>  3
07:49:07 <fasta> sorear: does he have some kind of webpage?
07:49:08 <DRMacIver> Gross. So there isn't a way to access an arbitrary position in a tuple?
07:49:16 <Syzygy-> Nope.
07:49:31 <sorear> fasta: http://falvotech.com/content/kestrel/
07:49:31 <lambdabot> Title: The Kestrel Project
07:49:40 <dmhouse> Do Isaac Jones or Stefan Monnier IRC?
07:49:56 <DRMacIver> <Troll>It really does seem like Haskell syntax is in every way inferior to that of SML</Troll>. :)
07:50:00 <Heffalump> Isaac Jones does sometimes, as SyntaxPolice/SyntaxNinja
07:50:11 <dmhouse> DRMacIver: the reason being, of course, that such a function would not have a constant type.
07:50:13 <Heffalump> how do you access an arbitrary tuple position in ML?
07:50:19 <DRMacIver> #4
07:50:23 <DRMacIver> It's just record access.
07:50:51 <Heffalump> does the 4 have to be a literal?
07:50:53 <dmhouse> Haskell's method is just record access too. data (,) a b = (,) { fst :: a, snd :: b }
07:50:57 <sorear> DRMacIver: it's inferior in a lot of ways.  have you seen ghci?
07:50:59 <DRMacIver> dmhouse: Well, yes. But there are ways around that. You could even do it with clever use of type classes.
07:51:16 <DRMacIver> sorear: Yeah, but there are reasons why ghci is difficult to make as good as an ML interpreter.
07:51:27 <DRMacIver> sorear: Mostly related to various things which Haskell does better than ML.
07:51:29 <Heffalump> if the index has to be a literal, then you can do it with type classes
07:51:36 <DRMacIver> Heffalump: The index has to be literal, yes.
07:51:44 <Heffalump> how are ML interpreters better than ghci, then?
07:51:46 <dmhouse> DRMacIver: yes, and people do, but it's just not useful enough to be in the standard libs. If you're using a tuple bigger than 4, you need to revise your design decisions (and, most likely, switch to using a record).
07:51:47 <sorear> DRMacIver: namely, ML's superior (in this context, one pass parsable) syntax
07:52:13 <dmhouse> There was a proposal recently for fst3, snd3 and thd3 to make it into Data.Tuple, though.
07:52:26 <sorear> Heffalump: as I was referring, it is because ML interactive interpreters actually use ML.
07:52:28 <DRMacIver> Heffalump: You can basically dump the code for an arbitrary ML module into the interpreter verbatim and expect it to work.
07:52:40 <Heffalump> oh, yeah
07:52:43 <sorear> Heffalump: ghc uses a wierd broken nasty pseudo-haskell input syntax
07:52:50 <augustss> there are several features that ghci could have that they have just not implemented.
07:52:54 <DRMacIver> ghci isn't an interpreter so much as a special monad. :)
07:53:18 <Heffalump> :-)
07:53:25 <DRMacIver> dmhouse: I don't agree with that logic.
07:53:29 <augustss> for instance, top level declarations could be allowed at the prompt (with some caveats)
07:53:34 <dmhouse> DRMacIver: why not?
07:53:55 <dmhouse> augustss: they are, with :let. Unless that's your point...
07:54:22 <fasta> sorear: thanks
07:54:23 <sorear> dmhouse: augustss wrote hbi, which supported ALL topdecls - even data
07:55:04 <dmhouse> Oh, I see.
07:55:10 <augustss> being able to do datam classm etc is nice for experimentation
07:55:19 <tibbe> I think I like pythons prompt which gives you a possibility to continue top level definitions on a new line
07:55:38 <tibbe> writing the function you want to test on one line is a pain
07:55:44 <DRMacIver> dmhouse: It fails on several points. First of all, it's the classic blub programmer defence against language extension, and thus should be regarded as very suspect. ;) Secondly, tuple access can be (and, in ML, is) reasonably regarded as a special case of record access, and large records are an entirely reasonable way of representing certain data.
07:56:28 <DRMacIver> And thirdly, fst and snd are a really butt ugly way of doing tuple access even if you never need a larger tuple. ;)
07:57:10 <Heffalump> it's God^Wthe Haskell committee's way of telling you should use records instead :-)
07:57:43 <ndm> augustss, I hope that GuiHaskell will make it so you can have instances etc at the prompt
07:58:04 <ndm> plus add let binding to hugs
07:59:58 <dmhouse> DRMacIver: large records are a very good way of representing certain data, but I don't see how that follows that you should be using tuples. If you're bunching a load of data together in one value, the way you access the subvalues should be reaadable. (Named) records offer that, tuples don't.
08:00:39 <sorear> DRMacIver: look at the [ny]hc sourc
08:01:28 <DRMacIver> dmhouse: All I'm seeing here is "I don't like tuples, so let's make their useage unreadable in an attempt to improve code readability". This doesn't seem a sound argument to me.
08:01:50 <DRMacIver> sorear: For anything in particular? :)
08:02:00 <sorear> type Down = (ExpI -> ExpI , ExpI , ExpI , ExpI , ExpI , (ExpI,ExpI) , ExpI , (TokenId,IdKind) -> Id , PosExp , [Char] , Map.Map Id Id )
08:02:02 <ndm> DRMacIver, anyone who promotes the use of large tuples should be asked to manually infer the types of functions in Yhc, it will stop the tuple madness quite quickly
08:02:17 <sorear> wouldn't you like to maintain code using THAT type!
08:02:29 <ndm> sorear, is that actually from Yhc? looks way too simple, we usually have much deeper nested tuples, especially return tuple types
08:02:36 <sorear> ndm: from yhc's CaseLib.hs
08:02:37 <dmhouse> DRMacIver: the easiest way to make tuples readable is to give the different fields names, but doing that basically gives to records. My argument is that readable tuples _are_ records.
08:02:44 <sorear> ndm: I didn't look very hard
08:03:49 <DRMacIver> sorear: I'm not actually advocating the use of large tuples here. I'm advocating the use of sensible accessors for tuple positions. Accessors for large tuples simply happens as a consequence.
08:04:22 <dmhouse> s/to/you/
08:04:33 <LeCamarade> @remember ndm Anyone who promotes the use of large tuples should be asked to manually infer the types of functions in Yhc, it will stop the tuple madness quite quickly
08:04:34 <lambdabot> Done.
08:08:02 <DRMacIver> dmhouse: Fine. Large tuples are bad for readability - I don't disagree. I don't see how this relates to any sort of claim that having sensible accessors for tuples is a bad thing.
08:08:33 <DRMacIver> Note: If your answer is going to be "It would encourage people to write unreadable code" I'm going to dismiss it out of hand.
08:09:22 <dmhouse> DRMacIver: because you're extending the language for basically no reason. If tuples beyond a size of 4 are pretty much useless (records are better), you can define fst and snd, fst3, snd3 and thd3, and maybe even fst4, snd4, thd4 and fth4 if you really think they'd be used, and just leave it there.
08:09:41 <dmhouse> (Note that fst and snd are just regular Haskell functions defined without any syntactical magic.)
08:09:43 <dmhouse> ?src fst
08:09:43 <lambdabot> fst (x,_) =  x
08:10:34 <ndm> DRMMacIver you can special purpose everything out of existance, but tuples don't seem ugly to me, unless you go huge, which you shouldn't
08:10:52 <DRMacIver> "Extending the language for no reason" is another irritating argument. However, note that I didn't suggest doing that. I am in fact encouraging the shrinking on the language, by pointing out that in ML tuples are a type of record and thus use the same access functions as records do.
08:11:55 <dmhouse> So in ML record access works like rec#field?
08:12:08 <DRMacIver> #field rec , but yes.
08:12:12 <ndm> you mean you suggest data (a,b) = (,) {fst :: a, snd :: b}
08:12:30 <ndm> and allow (1,2){fst=3} ==> (3,2) ?
08:13:03 <dmhouse> Well, if pairs were defined data (,) a b = (,) { fst :: a, snd :: b }, pairs wold work just like records too.
08:13:43 <dmhouse> Compare "fst (a, b)" and "field rec".
08:13:44 <DRMacIver> Thereabouts. ML allows the use of non alphanumeric characters in record names, so it would be { 1 :: a, 2 :: b }.
08:14:53 <ndm> that would require some kind of special record symbol, as ML has, but haskell doesn't
08:15:15 <dmhouse> Also note that if foo is a record accessor for a record type R, then foo cannot be an identifier for anything else. So, for example, if 1 is a projection function for pairs, it can't be a projection function for triples.
08:15:18 <ndm> i think we should attach the GHC developers, make them give # back, and we can then use it for records
08:15:23 <ndm> * attack
08:15:43 <dcoutts> ndm: # hasn't been stolen
08:15:43 <DRMacIver> dmhouse: Haskell has this interesting mechanism called a 'type class'. Maybe you've heard of it? ;)
08:15:47 <ndm> they have to be stopped before they take our (!) as well
08:16:00 <dmhouse> ?hoogle (#)
08:16:01 <lambdabot> Did you mean: (>)
08:16:01 <lambdabot> Prelude.undefined :: a
08:16:01 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
08:16:19 <ndm> dcoutts, there are some places you can't use # because GHC have made it the unboxed thingy
08:16:36 <ndm> dcoutts, when in reality, they didn't need to - JHC does the same thing with jsut __ at the end - its only convention, not meaning
08:17:01 <dcoutts> ndm: no it's just allowed as a char in a var name, that's all, it's not stolen as a keyword or something
08:17:26 <ndm> dcoutts, its had its behaviour modified
08:17:34 <dmhouse> DRMacIver: now you're talking a language extension whereby record accessor functions are allowed to be typeclass methods. That'd be interesting.
08:17:47 <dcoutts> ndm: what was it previously? an operator char?
08:18:17 <sorear> dcoutts: I've tried using # in the middle of varids before, w/o sucess
08:18:20 <dcoutts> ndm: so the case that changed is things like 'foo# bar' right?
08:18:40 <dcoutts> > let a # b = a + b in 1#2
08:18:42 <lambdabot>  3
08:18:57 <DRMacIver> Yes, this is a minor language extension in that it involves an effectively infinite number of type classes. This doesn't strike me as especially unreasonable.
08:19:45 <DRMacIver> Record fields as type classes are a natural thing to want to do, and would give a lot of the benefits of structural subtyping.
08:19:48 <ndm> > let a # b = a + b ; c = 12 ; d = 14 in c#d
08:19:49 <lambdabot>  26
08:19:58 <dmhouse> > let a # b = a + b in a# b
08:19:59 <ndm> > let a # b = a + b ; c = 12 ; d = 14 in c# d
08:19:59 <lambdabot>   Not in scope: `b'
08:20:00 <lambdabot>  26
08:20:10 <dmhouse> > let a # b = a + b; c = 12 in c# 2
08:20:11 <dcoutts> ndm: right so now a#b lexes as a# b
08:20:12 <lambdabot>  14
08:20:28 <dcoutts> ndm: and 1# is a number not (1 #)
08:20:54 <dcoutts> ndm: so # is still usable but you have to be careful of whitespace
08:21:29 <dcoutts> like with .
08:21:50 <ndm> dcoutts, true, but it also means we can't use if for anything else - partly the convention steals it
08:22:06 <ndm> i.e. we can't make # be records, since its already unboxing
08:22:11 <dcoutts> ndm: unicode! many more operators available :)
08:22:50 <dmhouse> We could surely use @ for record access.
08:22:56 <ndm> dcoutts, i'm hoping that we won't have to go there for a long time...
08:22:59 <dmhouse> I don't think patterns and values overlap, do they?
08:23:02 <DRMacIver> ndm: I've no particular attachment to #. I just mentioned it because that's what ML does.
08:23:19 * ndm can imagine the stage where every library comes with a set of codepoints, rather than a set of functions
08:23:22 <dcoutts> dmhouse: they probably don't, but it can still be confusing
08:23:29 <DRMacIver> And clearly we should allow all of unicode. ;) But that's a separate concern.
08:23:35 <sorear> dmhouse: remember that haskell is effective impossible to parse
08:24:03 <sorear> dmhouse: GHC for instance parses expressions and patterns using the same production, to avoid ambiguity errors
08:24:39 <dmhouse> I think GHC 6.6 does allow you to use an actual lambda instead of \.
08:25:37 <sorear> Nope.
08:25:47 <sorear> lambda is a lowercase letter.
08:25:58 <sorear> you can use it in variable names, but not for \.
08:26:42 <integral> If lambda was a special character, how would you use greek variable names?
08:26:44 <dmhouse> Maybe I'm thinking of using  instead of ->. There was something like that.
08:27:14 <swiert> dcoutts: Can I ask a Cabal question?
08:27:47 <therp> good evening
08:28:09 <sorear> hello
08:28:49 <Cheery> @hoogle RGB
08:28:53 <lambdabot> No matches found
08:36:19 <LeCamarade> > let  = 34 in   -- Unicode ... can someone try Chinese?
08:36:23 <lambdabot>   lexical error (UTF-8 decoding error)
08:37:00 <Saizan> with instance (Foo x,Typeable x) => Bar [x] where  f = ... typeOf (undefined :: x) ..,  the x in the type annotation shouldn't get unified with the one in the instance declaration?
08:37:37 <sorear> Right, it shouldn't.
08:37:58 <sorear> You can force it with -fscoped-type-variables
08:38:11 <sorear> or just abuse the MR
08:39:34 <augustss> asTypeOf is good too
08:39:51 <Saizan> -fscoped-type-variables doesn't work
08:40:10 <Saizan> asTypeOf would be good if i had something of type x
08:40:28 <Saizan> what do you mean by abuse MR?
08:44:22 <dcoutts> swiert: sure
08:44:45 <dcoutts> hia therp
08:44:54 <swiert> dcoutts: Are there any examples of how to include a bit of C to a Cabal file?
08:45:10 <dcoutts> swiert: lemme think...
08:45:11 <swiert> Something along the lines of the example in: http://groups.google.com/group/fa.haskell/browse_thread/thread/3a4e29bc703132a0/5bdae817f42513cb?lnk=raot
08:45:13 <lambdabot> Title: FFI basics - fa.haskell | Google Groups, http://tinyurl.com/yov8mm
08:45:38 <dcoutts> swiert: the fps package does, it has c-sources: cbits/fpstring.c
08:45:48 <therp> dcoutts: hey hello
08:46:02 <int-e> dcoutts: ping, are you going to apply those cabal patches?
08:46:50 <dcoutts> int-e: which ones? I've not looked in the last couple days, I've been recovering from flying from the opposite side of the world :-)
08:46:56 <sphynx> could you please tell, how could I get more info, when I got the error message about  Non-exhaustive patterns in function?
08:47:16 <int-e> dcoutts: the one from last week.
08:47:22 <sphynx> I'd like to know what parameters were used in that function call, caused error
08:47:28 <Igloo> sphynx: Compile with -Wall and it'll tel you what patterns aren't covered
08:47:50 <Igloo> sphynx: Or just turn the overlapping patterns warning on by itself
08:47:50 <dcoutts> sphynx: it tells you the location where it happened, so first this is to go look at the code, you can modify the code to add a catch-all case to show the example that didn't match
08:48:15 <int-e> dcoutts: about installing include files with packages.
08:48:44 <dcoutts> int-e: "don't automatically include install-include: headers into compilations via C"
08:48:45 <swiert> dcoutts: I'd need cabal to do: ghc -c Bla.c; ghc -ffi Main.hs Bla.o
08:48:47 <sphynx> yeah, I see in code, but there are 6 or 7 different patterns and I'm not going to cover all the possibilities..
08:49:03 <swiert> dcoutts: Will C-Sources: Bla.c suffice?
08:49:06 <dcoutts> int-e: yep, I want to apply those, JaffaCake thought they were ok and nobody else has complained
08:49:15 <dcoutts> swiert: should do
08:49:53 <sphynx> Igloo, ok, I'll try to compile with -Wall,. But is there any way to turn on this check in GHCi?
08:49:55 <dcoutts> swiert: with a future version of c2hs it'll be even easier, you'll be able to mix Haskell and C in the same .chs module.
08:50:07 <swiert> dcoutts: Cool stuff.
08:50:15 <Igloo> sphynx: Running ghci- Wall should work too
08:50:25 <Igloo> sphynx: Err, "ghci -Wall" that is
08:51:17 <dcoutts> swiert: however, don't recommend c2hs+cabal to newbies just yet, my patches to make them play together nicely are not included in releases yet.
08:51:45 <swiert> dcoutts: OK. For what I want, I can live without c2hs I think.
08:52:29 <sphynx> Igloo, yeah, it works, thanks! It shows me many non-exhaustive patterns :( But it seems that majority of these uncovered patterns will not show up in my program.
08:53:27 <Igloo> sphynx: But if you cover them all, even if only with error "funcName: Can't happen", then ghc(i) will point out where you have accidentally omitted a case
08:53:35 <eumenides> hrm. ghc's error's longer than my scrollback
08:54:32 <sphynx> Igloo, hmm, OK, I'll try to do so. Thanks again. But what about catch-all, what does it mean?
08:54:52 <sphynx> Igloo, is it some keyword?
08:55:10 <Igloo> sphynx: No, dcoutts just meant _ or x as the pattern
08:55:22 <Igloo> sphynx: x if you want to print it, _ otherwise
08:55:31 <sphynx> Igloo, ahh, OK, I understood
08:55:43 <sphynx> dcoutts, Thank you!
08:55:59 <dcoutts> eumenides: that got improved in the development version recently, it's more careful about printing large contexts
08:56:05 <sorear> eumenides: yeah, that happens :(  ghc head has an improved printer
08:56:06 <dcoutts> sphynx: np
08:56:26 <sorear> unfortunately, head+extralibs is unbuildable as of yesterday.
08:56:53 <sorear> i expect great things from cabalised extralibs, but we'll need to wait for the dust to settle first...
08:58:21 <Igloo> I hope that if dcoutts OK's my cabal patches then the extralibs builds will go through
08:58:22 <LeCamarade> Eh! See dis: http://www.defmacro.org/ramblings/fp.html
08:58:24 <lambdabot> Title: defmacro - Functional Programming For The Rest of Us
08:58:29 <foxy-om> dcoutts: I got the patch, I'll try it later today
08:58:32 <Igloo> But there could be another surprise waiting for me  :-)
08:58:36 <dcoutts> foxy-om: ok, ta.
08:58:37 <foxy-om> @localtime foxy-om
08:58:38 <lambdabot> Local time for foxy-om is Monday, 30 April 2007 3:55:35 a.m.
08:58:59 <LeCamarade> It hits at my argument that you academics have been patronising functional programming, essentially locking `the rest of us
08:59:03 <LeCamarade> ' out.
08:59:09 <dcoutts> Igloo: I see, I'm holding everything up eh? ok, best look at those patches
09:00:19 <Igloo> dcoutts: Heh, thanks
09:24:43 <midfield_> dons: hi, got a minute for a quick question?
09:26:00 <sorear> I just love the way emacs decides to use the #haskell nick list for completion when I'm typing code.
09:26:25 <sorear> midfield_: he's almost surely asleep now, try again in six hours
09:27:30 <sphynx> I have finished my 'infix-to-postfix' translator! Today I've already told about it and asked some questions.
09:27:37 <sorear> yay!!
09:27:49 <sphynx> Could please some one take a look on my code?
09:28:20 <sorear> Sure.  how big is it?
09:28:39 <sphynx> now it translates arithmetic operations, power operation and braces
09:28:43 <sorear> if < ~150 lines, hpaste.org will give you free hosting with auto url announce
09:28:48 <sorear> @paste
09:28:49 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:29:26 <sphynx> ok, I've pasted already my postfix evaluator :) Let me see if it has less than 150 lines
09:29:55 <sphynx> it seems so, it has ~85 lines
09:29:56 <sorear> the actual criterion is < 5 kbytes.
09:32:42 <hpaste>  sphynx pasted "Infix-to-postfix translator" at http://hpaste.org/1614
09:33:04 <sphynx> sorear, all is ok, it's pasted
09:38:31 <hpaste>  sorear annotated "Infix-to-postfix translator" with "no need to track function values for this" at http://hpaste.org/1614#a1
09:38:55 <sorear> sphynx: note the diff bar at the bottom
09:39:30 <midfield_> sorear: thanks
09:40:13 <DRMacIver> Academic papers manage to be really impressively unreadable some times.
09:40:14 <sorear> what did I do?
09:40:27 <sorear> I can't find me helping midfield_ in the scrollback.
09:40:35 <midfield_> sorear: midfield_: he's almost surely asleep now, try again in six hours
09:40:48 <DRMacIver> (Just taking a look at the first paragraph of "Generic Exception Handling and the Java Monad")
09:41:35 <sphynx> sorear, Yeah, thanks. Initially it was needed for postfix evaluator which I've written before
09:42:30 <sphynx> sorear, I mean function values. So I can evaluate like this: evaluate' ((Op op _):xs) (x1:x2:s) = evaluate' xs ((op x2 x1):s)
09:42:34 <sorear> sphynx: I think separating them is stgill good
09:42:50 <sorear> sphynx: since the evaluator doesn't need names etc
09:43:24 <sphynx> sorear, but you are right, your changes make code cleaner and removes these painful Ord instantiatings..
09:43:38 <sorear> painful and wrong!
09:43:55 <sorear> you didn't handle the Number <> Op case, fex
09:44:20 <sphynx> sorear, yeah, while running ghci -Wall I've seen these unhandled cases
09:45:42 <ddarius> DRMacIver: Just read Wadler then.
09:46:06 <DRMacIver> I'm fully aware that readable academic papers exist. :)
09:46:21 <DRMacIver> And that these are probably much more readable when one knows the jargon.
09:46:51 <DRMacIver> (e.g. I know that there's a large class of maths papers which I'd find very readable and would cause sane people to go "Huh?")
09:47:36 <ddarius> Most Wadler papers would make even sane lay-people warm and fuzzy.
09:51:32 <ddarius> 220 papers and nothing to read.
09:53:22 <kilimanjaro> Try dostoevsky
09:56:19 <ddarius> I've read "The Brothers Karamazov"
10:04:58 <bluffer_> anyone using buddha out here :)
10:08:44 <monochrom> haha
10:28:50 <Saizan> the monomorphism restriction is enforced by the standard, right?
10:29:19 <monochrom> Yes.
10:29:24 <tibbe> anyone have a nice .emacs for haskell with type lookup using inf-haskell and willing to share?
10:32:11 <dino-> monochrom: Thanks for the help the other day. The problem was what you had suggested -- not waiting for the process to finish. I wasn't using System.Process.waitForProcess
10:32:30 <monochrom> Nice.
10:32:56 <monochrom> But that is odd because "fileExists?" should reply "no".
10:33:05 <Saizan> tibbe: i use this http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs#Minimal_setup plus (require 'inf-haskell)
10:33:07 <lambdabot> Title: Haskell mode for Emacs - HaskellWiki, http://tinyurl.com/yyqy4v
10:33:32 <stefanha> How do you match the numeric literal -1.0?  I get parse errors, probably because of the conflict with binary minus...
10:33:53 <tibbe> Saizan, ok, on what distro? or windows?
10:34:09 <monochrom> Also this consideration.  Create file, start writing into it (or haven't started), meanwhile delete that file. That delete should succeed on all *nix.
10:34:22 <Saizan> tibbe: debian, but with code from svn
10:34:37 <dino-> monochrom: Oh wow, that succeeds?
10:34:49 <monochrom> Yes. A feature of *nix.
10:34:55 <tibbe> Saizan, ok, thanks
10:35:28 <sphynx> I like the hpaste.org syntax coloring, how can I convert my haskell source to HTML locally, like hpaste.org does? what should I use?
10:35:34 <dino-> In my case, the 'new' file wasn't even being opened and written. It's merely a hard link.
10:35:57 <eumenides> sphynx: yeah, with hscolour
10:36:36 <sphynx> eumenides, OK, thank, I'll try!
10:36:39 <Saizan> > let foo (-1.0) = 10; foo x = x in foo (-1.0) -- stefanha
10:36:42 <lambdabot>  10.0
10:36:49 <monochrom> I pasted a test at http://hpaste.org/1593   I start "cat > whee".  Not waiting for it to finish (just waiting to make sure it has begun) (in fact my code makes sure it doesn't finish), "rm whee".  It works for me.  Have you tried?
10:37:04 <stefanha> Saizan: thanks
10:37:39 <stefanha> I expected that to take the section of x minus 1.0 :)
10:38:17 <Saizan> stefanha: well you can't have sections as patterns :)
10:39:29 <monochrom> The *nix file system is designed to be a reference-counting GC system.
10:41:20 <tibbe> why do I end up with two haskell processes in emacs, *haskell* and *ghci*
10:42:16 <magnus_> Is there any ml-like language with explicit memory management?
10:42:35 <dcoutts> monochrom: is it ref-counting? it can't cope with circular deps?
10:42:49 <opqdonut> there can be no circular deps
10:42:59 <opqdonut> as directories can't be hardlinked
10:43:14 <dcoutts> ah, that's a shame, can't install ghc then
10:43:22 <monochrom> Uses "depth counting" to unsoundly detect loops.
10:43:33 <hpaste>  MarcWeber pasted "Marc Weber" at http://hpaste.org/1615
10:43:54 <MarcWeber> Did a miss a trick to speed this simple sum program up? 3-4 times sower than C
10:43:56 <dcoutts> monochrom: ho hum, proper GC like mark+sweep would be nicer
10:44:12 <monochrom> I didn't design it. :)
10:44:17 <nominolo> hm, anyone know a useful image manipulation library for haskell?
10:44:30 <MarcWeber> nominolo: What do you want to do?
10:44:35 <narain> > let decr = (- 1) in decr 5
10:44:39 <nominolo> generate jpgs or pngs
10:44:43 <lambdabot>   add an instance declaration for (Num (t -> a))
10:44:44 <lambdabot>     In the expression: (- 1)...
10:44:50 <DRMacIver> magnus_: There are extensions to C with ML like features.
10:44:53 <narain> > let decr = (subtract 1) in decr 5
10:44:55 <lambdabot>  4
10:45:18 <dcoutts> monochrom: yeah, I know :-)
10:45:22 <nominolo> MarcWeber: and some simple drawing functions, for a start
10:45:26 <MarcWeber> nominolo: There has been a library where you can create them using functions, WASH is using some bindings to imagemagix I think. But dunno which approach gives best results.
10:45:27 <monochrom> OK!  I did design it!  In 1970 I went into the dream of Dennis Ritchie and revealed this design to him.  I hadn't learned better GC methods at that time.  Sorry!
10:45:43 <dcoutts> nominolo: there's the cairo lib, it's great
10:46:01 <nominolo> dcoutts: ah, yes.  cairo bindings sounds good
10:46:16 <Saizan> tibbe: because your haskell-ghci gets loaded and it shouldn't, *haskell* is from inf-haskell
10:46:22 <dcoutts> nominolo: at the moment the cairo bindings are bundled with gtk2hs
10:46:23 <MarcWeber> nominolo: http://haskell.org/haskellwiki/Libraries_and_tools/Graphics ;)
10:46:24 <lambdabot> Title: Libraries and tools/Graphics - HaskellWiki
10:46:41 <DRMacIver> Why would proper garbage collection be an improvement over reference counting here?
10:47:03 <tibbe> Saizan, what could force that to be loaded?
10:47:43 <dcoutts> DRMacIver: it'd allow collecting circular dependencies, but apparently they're not allowed anyway
10:47:59 <DRMacIver> Well, that's what I mean. Why do you need circular dependencies here?
10:48:11 <Saizan> tibbe: no idea, i had an explicit load that caused that
10:48:21 <dcoutts> DRMacIver: for example, ghc needs ghc to build, it's a circular dep
10:48:44 <nominolo> MarcWeber: thanks.  i was trying google q=haskell+image+manipulation, and it didn't come up with something useful
10:48:44 <dcoutts> DRMacIver: so the simple way of expressing it is to say that ghc depends on ghc
10:49:08 <DRMacIver> Hm. I see what you mean.
10:49:14 <dcoutts> there are other ways of making it not a circular dep
10:49:23 <tibbe> Saizan, I reduce my loads to only those on the wiki
10:49:42 <dcoutts> but at the bottom layer, most os systems really do have circular deps
10:50:14 <dcoutts> note that all from-source linux systems start with a tarball of binaries
10:50:16 <monochrom> Good GC would enable the file system to support arbitrary hardlinks between directories.
10:51:34 <dcoutts> monochrom: I thought the restriction on dir hard links was for some other reason, not just because of the danger of making dirs that are disconested from the / fs root
10:53:20 <monochrom> Hard to say what reason.  Lots of factors considered when they made every decision.  They were wise people making various compromises between power, theory, practice.
11:06:05 <tibbe> how can I use QuickCheck to generate two arguments to a function where one argument depends on the other: i.e. prop_myprop x xs = x `elem`xs  -- here I want x choose so it's an elem in xs
11:06:46 <tibbe> s/incomprehensible ramblings/here I want x chosen so that x is an element of xs
11:08:05 <norpan> tibbe: just generate xs and then choose one element from it
11:12:59 <tibbe> norpan, so what's the easiest way to do that, do I have to write the choseOne function myself or does QuickCheck supply something for that purpose?
11:15:22 <norpan> tibbe: i think "elements" is for you
11:16:18 <norpan> but you have to make sure xs is not null of course
11:16:22 <sorear> @seen magnus_
11:16:23 <lambdabot> magnus_ is in #haskell. I last heard magnus_ speak 34m 5s ago.
11:16:30 <sorear> magnus_: look at BitC
11:16:43 <magnus_> sorear: alright, thanks :)
11:16:46 <sorear> http://bitc-lang.org
11:16:48 <lambdabot> Title: The BitC Programming Language
11:17:08 <DRMacIver> Oh yes, I saw that. I don't remember it as being very ML like.
11:17:38 <tibbe> norpan, looks like it generates it in the Gen monad though, I guess I could wrap up (x, xs) in a newtype and write an arbitrary instance for it but it feels like lots of work
11:17:50 <shapr> dcoutts: You called?
11:18:23 <norpan> tibbe: well of course you need to work in the Gen monad
11:18:47 <sorear> DRMacIver: It's a strict functional programming language with polymorphic type inference, reference cells, and a value restriction.
11:18:52 <tibbe> norpan, why?
11:19:04 <norpan> to access the quickcheck functions
11:19:08 <DRMacIver> sorear: Fair enough. I guess my memory is at fault. :)
11:19:14 <tibbe> norpan, only if I want to generate it there which sounds like and ok idea if I didn't have to newtype something to do it
11:19:27 <DRMacIver> Or possibly fooled by the lisp syntax.
11:19:33 <tibbe> nornagon, since there's already an instance for (a, [a])
11:19:37 <sorear> DRMacIver: It does use s-expression syntax - it doesn't *look* at all like ML
11:20:05 * DRMacIver isn't bothered by the lisp syntax, nor does he think the syntax makes it inherently un ML like.
11:20:18 <DRMacIver> I was just wondering if that was what cause dme to misremember. :)
11:20:49 <sorear> I haven't actually played with it yet.
11:20:52 * SamB hopes we get a nice upgrade-friendly framework for packages (ala common-lisp-controller) soon
11:22:54 <sorear> wow, bitc has fundeps
11:22:54 <DRMacIver> Well, I say I'm not bothered by it. I vaguely dislike lisp syntax, and then feel guilty for doing os. :)
11:23:28 <sorear> os?
11:23:52 <magnus_> what are fundeps?
11:24:21 <sorear> functional dependencies.  a somewhat exotic ghc type system feature
11:24:33 <magnus_> aha
11:24:43 <DRMacIver> sorear: Typo for so.
11:24:49 <ddarius> sorear: A GADTs exotic?
11:24:52 <sorear> ah.
11:25:58 <ddarius> s/A/Are
11:30:34 <nominolo> SamB: any specific suggestions?
11:32:35 <nominolo> DRMacIver: the lisp-syntax for bitC was chosen, since quoting is a solved problem in this syntax
11:33:07 <nominolo> DRMacIver: they might change it sometime, but it's low-priority
11:34:01 <DRMacIver> quoting?
11:34:15 <magnus_> BitC looks cool but they don't seem very keen on other people using it
11:34:24 <nominolo> DRMacIver: embedding code fragments, which are not interpreted as code
11:34:27 <DRMacIver> Oh, right.
11:34:58 <DRMacIver> Does it have some sort of macro system then?
11:35:13 <nominolo> no, they dislike them
11:35:20 <nominolo> due to missing transparency
11:35:26 <DRMacIver> ok. Then why does it need quoting?
11:35:42 <nominolo> but i think they needed them for embedding statically checkable assertions
11:35:53 <DRMacIver> Ah
11:35:56 <nominolo> hm, let me see if i find the mail
11:36:11 <DRMacIver> Anyway, I'm not actually objecting to the lisp syntax.
11:36:25 <DRMacIver> It's a perfectly valid syntax which I simply have an irrational and mild dislike of.
11:36:39 * DRMacIver would much rather he didn't, but it's hard to overcome prejudices. :)
11:37:21 <nominolo> http://www.mail-archive.com/bitc-dev@coyotos.org/msg00695.html
11:37:22 <lambdabot> Title: [bitc-dev] BitC surface syntax
11:38:14 <nominolo> DRMacIver: well, i programmed in lisp for about three years.  still in many respects i find haskell's syntax more readable
11:38:29 <nominolo> DRMacIver: though, i miss macros quite often
11:39:04 * DRMacIver has never programmed in a language with macros, but really wants to. :)
11:39:11 <nominolo> ok, make that "easy to use macros"
11:39:29 <shapr> I like doing macrobatics in elisp.
11:39:49 <nominolo> DRMacIver: read On Lisp by Paul Graham, it'll give you a good idea of how useful they are
11:40:18 <nominolo> less useful in a language with lazyness and custom operators, but still
11:40:18 <jesusphreak> macros are lots of fun but they are a lot less useful in certain languages
11:40:38 <dcoutts> shapr: oh, I was wondering about haskell bloging stuff, do you still use hope ?
11:40:53 <dcoutts> shapr: I'm thinking of starting a blog you see
11:40:58 <nominolo> dylan nicely integrated macros and non-S-expression syntax
11:41:11 <jesusphreak> nominolo: yeah too bad it is dead
11:42:04 <DRMacIver> Dylan looks like a really neat language.
11:42:22 <nominolo> jesusphreak: nah, not dead.  but has a very small community
11:42:25 <DRMacIver> It has one of my favouritest features ever (I'm a big fan of multiple dispatch)
11:42:46 <jesusphreak> it is pretty amazing #haskell almost has as many people in it as some of the more popular languages
11:43:31 <DRMacIver> I conjecture this is because you reach the "Argh, I don't know what's going on! I need to find someone to help me!" point a lot sooner with Haskell. ;)
11:43:41 <tibbe> jesusphreak, there's a little haskler looking to come out in every programmer
11:43:47 <shapr> dcoutts: I do, but I'll likely switch to HAppS when I get around to it.
11:44:01 <shapr> jesusphreak: See, that's because Haskell is one of the more popular languages :-)
11:44:07 <dcoutts> shapr: what blogging stuff is there for happs ?
11:44:12 <nominolo> DRMacIver: it's becoming much more practically useful ATM, though
11:44:33 <DRMacIver> nominolo: Given that I sent off an application for a Haskell job earlier, I can believe that. :)
11:44:51 <Heffalump> I'm still somewhat amazed that I have a Haskell job.
11:45:00 <dcoutts> Heffalump: :-)
11:45:09 <shapr> dcoutts: There isn't anything that I know of, but it would be very easy to write and modify.
11:45:13 <nominolo> does summer of code count as a haskell job?
11:45:13 <jesusphreak> does Haskell have good Unicode support?
11:45:16 <dcoutts> Heffalump: and you didn't need to move to the US west coast :-)
11:45:20 <Heffalump> that pays lots more than my previous C++ job, too
11:45:28 <dcoutts> jesusphreak: some, yes.
11:45:44 <nominolo> Heffalump: galois?
11:45:46 <moconnor> I have two data structures which are huge and deeply nested (they're parse trees). They should be equal, but they're not.  If I was using Perl I could whip out something like is_deeply() and if the test failed it'd report where the differences are.  Is there any similar in Haskell?  I'm doing ==, and it fails, but now I want to know where/why it failed.
11:45:49 <Heffalump> though actually at the moment I spend most of my time struggling with C++. But there's Haskell there too.
11:46:02 <Heffalump> nominolo: no, I *didn't* need to move to the US west coast :-) (Credit Suisse)
11:46:12 <dcoutts> Heffalump: oh I was thinking of coming to the first LHUG meeting
11:46:18 <Heffalump> dcoutts: cool
11:46:30 <DRMacIver> Yeah, I'll be there too
11:46:40 <nominolo> Heffalump: afaik, they also have people working around the globe
11:47:09 <nominolo> Heffalump: but anyways, congrats :)
11:47:15 <Heffalump> nominolo: oh, I guess so.
11:47:21 <Heffalump> thanks :-)
11:48:07 <shapr> moconnor: I can't think of anything built in that does that, but it would be easy to write.
11:48:27 <moconnor> shapr: Yeah, i'm writing something now.  Was just hoping for the easy way out.  Thanks.
11:51:01 <joelr1> g'day
11:51:07 <augustss> g'day
12:03:21 <kilimanjaro> Heffalump, does Credit Suisse do a lot of their quant development with Haskell (or maybe you are working on something else)?
12:03:37 <Heffalump> kilimanjaro: an increasing amount
12:04:06 <Heffalump> I wouldn't say "a lot", yet, but we're trying to get it that way :-)
12:04:23 <kilimanjaro> That's nice to know :)
12:04:50 <kilimanjaro> Is it used for numerical stuff?
12:05:10 <Heffalump> not directly
12:05:16 <kilimanjaro> ok
12:05:17 <chessguy> HI ALL
12:05:23 <chessguy> ugh, mis-caps
12:05:25 <Heffalump> it's mainly in a program generation role
12:05:43 <tibbe_> chessguy, hi
12:06:04 <chessguy> whassup
12:06:06 <kilimanjaro> Ohh is that related to the partial evaluation based MC engine that I read a paper about?
12:06:13 <joelr1> can two type classes have a method of the same name?
12:06:14 <sorear> Heffalump: so, like what dons et al did with the generative monte carlo icfp financial derivative simulator?
12:06:17 <kilimanjaro> I think Chakravaty wrote a paper on it
12:06:18 <sorear> joelr1: no.
12:06:21 <kilimanjaro> err, dons
12:06:22 <joelr1> sorear: darn
12:07:10 <dcoutts> sorear: I think that's the next project at SC if they can hire enough Haskell hackers :-)
12:07:11 <sorear> kilimanjaro: ChiliX is dons' phd advisor, i would not be suprised to find them both on a phd track paper...
12:07:22 <joelr1> Heffalump: are you finding ghc slow?
12:07:22 <kilimanjaro> ohh, didnt know that
12:07:24 <sorear> SC == typoes CS?
12:07:34 <kilimanjaro> sorear, I guess that makes sense :)
12:07:47 <dcoutts> sorear: erm Credit Suisse
12:08:16 <Heffalump> kilimanjaro/sorear: not really (re the MC paper)
12:08:25 <joelr1> dcoutts: i missed something. whats the next project?
12:08:35 <Heffalump> joelr1: in terms of the speed it runs, or the speed of the generated code
12:08:43 <Heffalump> neither is ideal, but we're coping ok
12:08:52 <joelr1> Heffalump: i suppose #1 should not be a problem but #2...
12:09:04 <joelr1> Heffalump: i always wondered... why didn't CS go with ocaml?
12:09:15 <Heffalump> cos they have taste
12:09:24 <joelr1> haha
12:09:31 <dcoutts> joelr1: I asked Heffalump about the monte carlo financial stuff that dons and chilli wrote about and he said they had enough on their plates already
12:10:02 <dcoutts> but perhaps if they can hire enough Haskell hackers they could take advantage of that research work
12:10:05 <joelr1> dcoutts: right
12:10:13 <sorear> @remember Heffalump <joelr1> Heffalump: i always wondered... why didn't [Credit Suisse] go with ocaml? <Heffalump> cos they have taste
12:10:14 <lambdabot> Done.
12:11:20 <chessguy> ?seen procyon112
12:11:21 <lambdabot> I saw procyon112 leaving #haskell 13h 57m 59s ago, and .
12:11:50 <DRMacIver> I don't really understand the appeal of OCaml.
12:11:57 <Korollary> There is one?
12:11:58 * joelr1 is gearing up for a Haskell vs Ocaml post
12:12:02 <DRMacIver> But maybe if I played with its object system more I'd change my mind.
12:12:03 <joelr1> to compliment Haskell vs Erlang :D
12:12:11 <joelr1> DRMacIver: it's wicked-fast
12:12:13 <Heffalump> joelr1: we couldn't do a lot of the stuff we want to do with O'Caml
12:12:14 <sorear> joelr1: on haskell-cafe?
12:12:14 <joelr1> DRMacIver: it
12:12:16 <DRMacIver> Korollary: A lot of people seem to use it...
12:12:19 <joelr1> it's also very practical
12:12:22 <Korollary> It's wicked imperative
12:12:23 <ddarius> Haskell v. The World!
12:12:25 <Heffalump> type classes and monads give us a lot of power for writing DSLs
12:12:28 <joelr1> sorear: the post? no, in my blog
12:12:35 <DRMacIver> joelr1: SML has had better optimising compilers than OCaml's for years.
12:12:38 <Heffalump> that just isn't there in O'Caml (to the best of my knowledge)
12:12:46 <sorear> joelr1: are you on PHO yet?
12:12:57 <joelr1> Heffalump: can you be more specific? you could write DSLs with a parser, no? parse them that is
12:13:02 <dcoutts> joelr1: it's probably easier to write fast strict code in ocaml
12:13:07 <ekidd> @ask dons Are there any more "Haskell is bad for this problem" articles floating around the web?
12:13:08 <Heffalump> sorry, I meant DSELs.
12:13:08 <lambdabot> Consider it noted.
12:13:09 <joelr1> Korollary: no. it doesn't have to be
12:13:18 <Korollary> I didnt say it had to be.
12:13:19 <Heffalump> i.e. we want to embed them in a host language
12:13:24 <joelr1> sorear: what's PHO?
12:13:36 <Heffalump> dinner, back in a while
12:13:38 <dcoutts> joelr1: as everyone knows, the ocaml compiler is really fast for not terribly abstract code
12:13:49 <ddarius> Heffalump: What about camlp4?
12:13:50 <joelr1> Heffalump: hmm
12:13:56 <DRMacIver> joelr1: OCaml has slightly 'better' syntax for doing imperative code mixed in with your functional code, but it doesn't let you do anything that SML doesn't.
12:14:01 <sorear> joelr1: planet.haskell.org
12:14:08 <DRMacIver> And this is at the cost of much worse syntax overall.
12:14:24 <joelr1> i think camlp4 and metaocaml are better than TemplateHaskell. in terms of ease of use anyway
12:14:37 <dcoutts> ie low level ocaml code, apparently the downside is that people code to what the compiler optimises best, which is a low level style
12:14:49 <joelr1> sorear: i was. then i asked to be taken out. since i was gonna be doing ocaml mostly
12:15:00 <ddarius> dcoutts: People do that in every language.
12:15:25 <monochrom> I do that in Haskell. :)
12:15:34 <joelr1> sorear: i, basically, have two versions of my product now: ocaml and haskell. i keep pushing one when i get dissatisfied with the other.
12:15:54 <joelr1> dcoutts: you could say that about ghc!
12:16:07 <DRMacIver> joelr1: Isn't MetaOCaml interpreted only?
12:16:16 <DRMacIver> Or at least byte code only.
12:16:22 <dcoutts> ddarius: true, but that's actually one area where ghc is really strong, it does some pretty impressive optimisations which allow you to code in a higher level style and transform down to the low level style.
12:16:30 <joelr1> i periodically get sick of haskell and advance the ocaml version. then i think of some other benefit of haskell or get sick of ocaml, etc.
12:16:34 <ddarius> dcoutts: I agree.
12:16:40 * ddarius was being subtle.
12:16:43 <dcoutts> unfortunately then it all goes wrong since ghc doesn't do so well with low level code anyway :-)
12:17:14 <ddarius> See, that's the trick.  Just optimize low-level code poorly!
12:17:18 <dcoutts> right!
12:17:22 <dcoutts> :-)
12:17:41 <joelr1> DRMacIver: i don't think so, i think it uses ocaml as the backend, sort of like a pre-processor
12:17:44 <dcoutts> slow for low level code and just as slow for higher level code :-)
12:18:21 <dcoutts> then all we need to do is rewrite the cmm -> asm backend and it'll all go quick :-)
12:18:23 <DRMacIver> joelr1: Hm. In which case it does less than I thought it did. I thought it offered the ability to generate and execute code at runtime.
12:18:50 * DRMacIver is pretty sure MetaML does and thought that MetaOCaml was just a port of MetaML (or vice versa. I forget which came first).
12:18:53 <joelr1> DRMacIver: don't know about that
12:19:07 <monochrom> We should really sign a contract with Dell to ship GHC preinstalled.
12:19:15 <joelr1> i'm on the fence. i think neither ghc nor ocaml are ideal. i think if ghc performance was improved then it would be ahead of ocaml
12:19:40 <DRMacIver> I'm still not seeing the benefits of OCaml. :)
12:19:46 <dcoutts> DRMacIver: I think metaml does indeed generate bytecode at runtime, you can have N levels of splices, not just 2 like in TH
12:19:52 <joelr1> dcoutts: isn't that (cmm -> asm) a monumental task?
12:19:59 <DRMacIver> dcoutts: Ok. Thanks.
12:19:59 <dcoutts> joelr1: yes.
12:20:07 <joelr1> DRMacIver: you won' until you trying coding in it
12:20:19 <DRMacIver> joelr1: I have. I still don't see it.
12:20:27 <dcoutts> DRMacIver: though in practise there are few examples where more than 2 levels really help
12:20:50 <DRMacIver> joelr1: Note that I'm not comparing it to Haskell, which is very different. I'm comparing it to SML, which is very similar only seems better in most respects. :)
12:20:55 <dcoutts> joelr1: it's basically the same about of work as a whole compiler C backend
12:20:58 <monochrom> I see the benefit of OCaml is subtyping.  Good subtyping story there.
12:21:11 <dcoutts> joelr1: erm C compiler backend I mean
12:21:13 <joelr1> monochrom: what's that?
12:21:52 <joelr1> dcoutts: right. i wonder if there's any work being done on that. isn't the ghc team just the simons? i mean the core development team
12:21:54 <monochrom> A class can be considered a type.  A subclass can be considered a subtype.
12:22:10 <DRMacIver> Oh yes, there's OCaml's object system. But no one ever seems to push that as one of the benefits so I don't pay much attention to it. :)
12:22:16 <DRMacIver> monochrom: It shouldn't be though...
12:22:24 <dcoutts> joelr1: Simon M + an intern is looking at some backend improvements over the summer
12:23:06 <dcoutts> joelr1: but basically it's hard for them to justify spending a lot of time on that stuff since it does not involve much new research output, which is what they are paid for.
12:23:16 <joelr1> right
12:23:36 <monochrom> I'm speaking approximately.  There are subtle, delicate details.  My point is OCaml treats the subject right (not the only right way, certainly a right way).
12:23:43 <dcoutts> joelr1: it's basically a matter of selecting the best existing techniques of traditional compiler backend optimisations and implementing them in Haskell
12:23:44 <joelr1> DRMacIver: i don't use SML so i compare OCaml to GHC
12:23:50 <joelr1> dcoutts: right
12:23:51 <ddarius> What? Haskell World Domination is not an acceptable reason to MSR?
12:23:59 <dcoutts> ddarius: nope
12:24:05 <DRMacIver> joelr1: Ok. Then we're each arguing against something the other isn't saying. That's not a very useful thing for us to be doing. :)
12:24:06 <sorear> dcoutts: so basically what we need is not so much simons as a horde of SoCcers?
12:24:37 <dcoutts> sorear: a hoard who know plenty about register allocators and SSA, yes.
12:24:39 <joelr1> DRMacIver: aye
12:24:48 <monochrom> It's a useful way to accelerate the passing of a Sunday. You can't wait to go back to work tomorrow can you? :)
12:24:54 <DRMacIver> My point is not "Why do people use OCaml when there's GHC?", it's "Why do people use OCaml when there's a more mature close equivalent which has better syntax and a better optimising compiler?"
12:25:06 <joelr1> dcoutts: it's a very interesting topic to me. i'm all over appel's compiler design in ML
12:25:53 <monochrom> Where do I find a more mature close equivalent which has better syntax and a better optimising compiler?
12:25:55 <dcoutts> joelr1: well, the C-- spec is out there to play with
12:26:09 <augustss> DRMacIver: I think OCaml has a more mature system overall.  Very pragmatic and well working.
12:26:15 <DRMacIver> monochrom: SML, MLTon.
12:26:30 <monochrom> I see.
12:26:52 <augustss> DRMacIver: by SML do you mean SML/NJ?
12:26:58 <DRMacIver> No. I mean SML.
12:27:06 <monochrom> OCaml won an ICFP contest too.
12:27:28 <DRMacIver> SML/NJ : SML ~ GHC : Haskell
12:27:41 <monochrom> OCaml : OCaml
12:28:06 <monochrom> There are a couple more e.g. Perl 5 : perl5.exx
12:28:06 <augustss> But SML is not a compiler, it's a language.  whereas MLTon is a compiler
12:28:09 <monochrom> err exe
12:28:28 <DRMacIver> Yes.
12:28:33 <DRMacIver> That's what I said, isn't it?
12:28:56 <augustss> oh, I see, they were never meant to be in the same category.  then I agree :)
12:28:56 <monochrom> I suppose "SML, MLTon" is not intended to be a homogenous list.
12:29:30 <ddarius> But, hey, with SML/NJ you get continuations.
12:29:31 <augustss> I don't trust systems that rely on whole program compilers
12:29:32 <DRMacIver> monochrom: You asked for a tuple, I gave you a tuple. It's not my fault if the reader's type inference isn't good enough. ;)
12:29:54 <monochrom> I didn't know what I asked for. :)
12:30:11 <DRMacIver> augustss: Why not?
12:30:26 <osfameron> irc doesn't do type inference?
12:31:04 <Heffalump> (back)
12:31:26 <augustss> several reasons, first, they don't seem to scale.  second, there are deplpyment issues.  a lot of the time you don't want to deply whole programs but fragments, like libraries.
12:32:31 <DRMacIver> Hm. Actually the shootout suggests that the MLTon / OCaml performance difference is not as clear cut as I'd previously believed.
12:33:00 <ddarius> DRMacIver: A whole program analysis doesn't help if your whole program is in a single module.
12:33:04 <sorear> @botsnack
12:33:04 <sorear> GRRR!
12:33:04 <lambdabot> :)
12:33:15 <joelr1> arghhhhh
12:33:34 <DRMacIver> ddarius: True. :)
12:33:52 <sorear> yay for lag.
12:35:42 <DRMacIver> The shoot out suggests that they're pretty comparable at any rate, with on average OCaml being slightly better but occasionally MLTon being significantly better.
12:37:40 <Heffalump> as far as I'm aware, there's a lot more energy around the Haskell community these days than around the MLs
12:38:00 <DRMacIver> Yes, that does seem to be the case.
12:38:19 <DRMacIver> Which I find unfortunate. They're both very good languages.
12:38:23 * ddarius wonders, what if anything, was the spark that started it.
12:38:52 <Heffalump> I'd say it's better for efforts not to be divided :-)
12:38:55 <joelr1> i think it was my fault :-)
12:39:10 <DRMacIver> Heffalump: I don't think I agree with that.
12:39:16 <Heffalump> but arguably Haskell's default-lazy strategy is a problem
12:39:31 <osfameron> i thought haskell was an ml.. :-(
12:40:36 <DRMacIver> Heffalump: I'd much rather there was a good and well supported eagerly evaluated non-strict functional programming language from the ML family as a complement to Haskell.
12:40:55 <DRMacIver> But then I'm a language diaspora advocate. I know a lot of people disagree with me.
12:41:09 <DRMacIver> On almost every point in fact. :) But on this specific point in particular.
12:41:14 <Heffalump> eagerly evaluated non-strict?
12:41:21 <Heffalump> what's that mean?
12:41:30 <Heffalump> like Eager Haskell?
12:41:30 <DRMacIver> Sorry. non-pure.
12:41:31 <shapr> Is that like speculative evaluation?
12:41:40 <Heffalump> ah, right
12:41:51 <DRMacIver> Brain hiccup. :)
12:42:05 <Heffalump> I think if such a language existed and could share libraries with Haskell, it'd be great.
12:42:17 <Heffalump> but without that, I'm happier for most efforts to be focused in one place.
12:42:25 <ddarius> DRMacIver: Isn't the ML family exactly that?
12:42:31 <DRMacIver> ddarius: Yes.
12:42:41 <DRMacIver> ddarius: The key phrase is 'good and well supported' :)
12:43:17 <ddarius> ?  The MLs seem both good and well supported.  At least in the same ballpark as Haskell is
12:44:44 <sorear> Heffalump: Have you seen "Haskell is not not ML" ?
12:44:53 <DRMacIver> Possibly it's a keyhole vision issue and I just don't see the things they're being used for, but they seem to be dying somewhat.
12:45:35 <DRMacIver> sorear: Ooh, neat.
12:45:43 <Heffalump> sorear: yep
12:45:52 <Heffalump> I hope they take that further.
12:45:57 <Heffalump> (or someone does)
12:46:16 <ddarius> "with only the cost of a Haskell deepSeq"
12:46:56 <ddarius> DRMacIver: From the outside their communities seem a little anemic.  Probably the affect of the Haskell vampire.
12:47:40 <DRMacIver> ddarius: Maybe I'm being totally unfair. I'll withdraw the comment for lack of evidence on my part.
12:48:12 <ddarius> My perspective is probably^W biased.  Though, it may still be correct.
12:48:58 <DRMacIver> I used to program a fair bit of ML. I find it very hard to simultaneously hold Haskell and ML in my brain though, so while I'm learning Haskell my ML has really rotted.
12:49:08 <DRMacIver> s/rotted/rusted/
12:49:15 <monochrom> Eagerness simplifies cost accounting.
12:49:28 <DRMacIver> Which is unfortunate as I've not yet got to the point where I can do useful things in Haskell. :)
12:49:30 <ddarius> True.
12:50:16 <Heffalump> eagerness simplifies evaluation too :-)
12:50:33 <ddarius> That said, I think a more significant problem is that most people don't know how to program in a lazy language and more seriously don't really think there's a different way they have to learn.
12:51:14 <sorear> Heffalump: it does?
12:51:20 * DRMacIver doesn't know how to program in a lazy language, but is very aware that there's a difference which he needs to learn. :)
12:51:20 <joelr1> Heffalump: how long have you been at CS?
12:51:35 <ddarius> But, yes, eager evaluation is objectively simpler, in this regard, than lazy evaluation.
12:51:42 <sioraiocht|away> ddarius: I think it also is hard to think simultaneous about learning haskell syntax and approaches and simultaneously consider laziness.  Thinking that way just takes a while
12:52:13 <Heffalump> joelr1: since January
12:52:26 <sioraiocht|away> ddarius: ignore the awful typos =p
12:52:29 <Heffalump> sorear: err, yes. You just evaluate things, no messing around with thunks.
12:52:31 <joelr1> Heffalump: awesome
12:52:42 <ddarius> sioraiocht|away: I agree it takes more effort/time, but most people aren't really aware that you need to program differently with laziness.
12:52:57 <Heffalump> why do you _need_ to?
12:52:59 <Heffalump> you _can_
12:53:14 <Heffalump> and little tricks like zip [1..] xs are great as a first step
12:53:26 <ventonegro> sml/nj seems not to be in debian
12:53:43 <sioraiocht|away> Heffalump: if you don't want to think about that, the usefulness of haskell becomes diminished a lot
12:53:53 <kaol> ventonegro: it's not in etch
12:54:02 <ddarius> Heffalump: sum = foldl (+) 0, 'nuf said.
12:54:06 <Heffalump> Haskell has many advantages that aren't related to lazy evaluation
12:54:20 <Heffalump> ddarius: as an argument for strictness, presumably?
12:54:20 <joelr1> Heffalump: like?
12:54:23 <DRMacIver> ventonegro: mosml is, if you just want something to play with.
12:54:30 <Heffalump> joelr1: type classes, monads
12:54:38 <ddarius> Heffalump: As an argument that you just can't ignore laziness for long.
12:54:45 <DukeDave> Ah man, I think 75% of my "so why do you use Haskell conversations end in people asking why laziness is good :(
12:54:45 <lambdabot> DukeDave: You have 1 new message. '/msg lambdabot @messages' to read it.
12:54:48 <Heffalump> ddarius: ah, right
12:54:51 <ventonegro> DRMacIver, didn't show up here
12:54:53 <DukeDave> Or, *useful*
12:55:02 <Heffalump> ok, I see. Yes, I withdraw what I said.
12:55:21 <DRMacIver> ventonegro: Hm. Sorry. I guess I'd assumed that it would be, as it's in Ubuntu's multiverse.
12:55:22 <ddarius> Most people are aware that you need to learn how to use it to do crazy crack-headed things like tying the knot, but not that you need to understand how it affects -all- your code.
12:55:37 <ventonegro> DRMacIver, np
12:55:55 <kaol> and in unstable sml/nj exists only on i386... it should be available on powerpc and sparc too, but I have never gotten around to talk about that to those arches' buildd maintainers
12:56:14 <ddarius> joelr1: Type classes alone are an amazing benefit of Haskell.
12:56:28 <Heffalump> list comprehensions
12:56:35 <Heffalump> GADTs
12:56:47 <Heffalump> the ST monad
12:56:49 <joelr1> ddarius: mmm... what i'm finding is that i have a lot of not so elegant code in my AST transformations. in haskell.
12:56:56 <DRMacIver> List comprehensions aren't that exciting once you have monads, though the syntax is nicer.
12:57:05 <Heffalump> joelr1: and what language would it be more elegant in?
12:57:07 <Heffalump> DRMacIver: sure
12:57:35 <Heffalump> it's a shame they stopped them applying to any MonadPlus
12:57:40 * ddarius doesn't consider list comprehensions a significant feature of Haskell, but many think otherwise.
12:57:56 <joelr1> Heffalump: i thought of OCaml but it's really not _that_ much more elegant
12:57:57 <Heffalump> well, they (and do-notation) are just sugar
12:58:00 <Heffalump> but it's nice sugar
12:58:08 <osfameron> what's the point of list comrehensions?
12:58:11 <joelr1> Heffalump: lisp would rule but with lisp i haven't gotten past the parser/lexer stage
12:58:13 <ddarius> And in theory, monads aren't either.  The real strength of monads in Haskell comes from type classes.
12:58:20 <Heffalump> joelr1: I think SYB and the like are making good strides at making AST processing much nicer
12:58:28 <Heffalump> and they rely quite heavily on type classes
12:58:31 <osfameron> they're just map+grep
12:58:34 <DRMacIver> But I agree that type classes should really be in any decent statically typed functional language.
12:58:52 <Codex_> list comprehensions are very nice syntax: it's almost identical to how sets are constructed in math using set comprehension.
12:58:52 <Heffalump> osfameron: right, but with nice syntax
12:58:54 <DRMacIver> Unfortunately there are many decent statically typed functional languages which don't have them. :)
12:59:10 <ddarius> osfameron: Almost.  They also produce cartesian products, which I believe goes beyond map+grep.
12:59:26 <Heffalump> no, you can do that with map
12:59:32 <Heffalump> you need concat too, I guess
12:59:35 <Heffalump> but that's kind of trivial
12:59:44 <DRMacIver> I keep thinking it would be nice to add type classes to ML. A naive implementation which compiles down to fairly normal looking ML should be very doable.
13:00:12 <kc5tja> List comprehensions are things which you almost never have a distinct need for.  Almost.  Until that _one_ application comes along, and they're just the _perfect_ fit for expressing what (not how) you want, and then you're converted for life.  First hit's free, and all that jazz.
13:00:16 <joelr1> Heffalump: well, i hope you like Wall St. i sure did, most of the time.
13:00:24 <monochrom> On thinking different when programming lazily.  Yes, there is actually an unlearning curve before you realize to write "take 10 . map f . [1..]".  I mean the habit would be to manually fuse the three loops due to eagerness.
13:00:29 <Heffalump> joelr1: well, Canary Wharf :-)
13:00:41 <osfameron> i dislike the syntax cos of how it overloads |, confuses th hell out of me
13:00:51 <joelr1> Heffalump: oh! london... oh... oh... did they move the haskell team there?
13:00:59 * ddarius liked SPJ's old picture on his MSR site.
13:01:30 <Heffalump> joelr1: kind of. Not deliberately, just augustss moved over to London and they hired me.
13:01:48 <DRMacIver> Oh, augustss is at CS as well?
13:02:40 <ddarius> monochrom: True, but that's the aspect that most people are aware of.
13:03:15 <Heffalump> DRMacIver: yep
13:03:17 <edwinb> There's a whole Haskell team there? Somehow I'd thought it was just Heffalump and augustss trying to take over the world...
13:03:45 <Heffalump> edwinb: it is :-)
13:03:47 <Heffalump> but we're hiring.
13:04:01 <edwinb> I suppose you have a good choice of weapon ;)
13:05:42 <DRMacIver> Heffalump: Hm. If "taking over the world" is part of the job description, I'm extra interested. ;)
13:06:02 <Heffalump> we try not to tell the quants that
13:06:07 <Heffalump> they might get scared or something
13:06:09 <edwinb> I hope I didn't accidentally give away a secret
13:07:25 <Heffalump> if they start reading #haskell logs we've converted them already :-)
13:09:09 <Herald> hi all
13:10:01 <DRMacIver> Hm. Is there a way to set a cap on list length in ghci? If I generate infinite lists it tries to show me the whole thing.
13:10:09 <Herald> could someone point out to me how to get this function to work without giving me type errors?
13:10:12 <Herald> > scaleProper :: Float -> Float -> Int -> Int
13:10:16 <lambdabot>   Not in scope: `scaleProper'
13:10:17 <Herald> > scaleProper c b p = c * p + b
13:10:17 <dcoutts> DRMacIver: take 1000 :-)
13:10:18 <lambdabot>  Parse error
13:10:27 <ddarius> DRMacIver: take
13:10:30 <Heffalump> I think most people use take.
13:10:44 <DRMacIver> Hm. I guess that works. :)
13:11:09 <ddarius> Herald: floor/ceiling/round and fromIntegral
13:11:17 <Herald> have tried those
13:11:24 <Herald> im getting type error just on the statement c*p
13:11:45 <Herald> even if its enclosed by round (c*p)
13:12:37 <ddarius> p is an Int and b is a Float, you need round (c * fromIntegral p + b)
13:12:48 <sorear> Herald: you can't multiply float and int.
13:12:52 <sorear> @type (*)
13:12:55 <lambdabot> forall a. (Num a) => a -> a -> a
13:13:04 <sorear> all occurences of 'a' must be the same
13:14:37 <sorear> @botsnack
13:14:38 <lambdabot> :)
13:27:20 <Cheery> btw. there reads, "big emotions in small can" in a salted herring -can I bought from market.
13:27:41 <osfameron> > map foo [(1,2),(3,4)]
13:27:42 <lambdabot>   Not in scope: `foo'
13:27:43 <osfameron>                   where foo (x,y) = x + y
13:27:48 <osfameron> bah
13:27:59 <Cheery> I wonder does that refer to something like: "fish have feelings too, 'u know!"
13:28:02 <osfameron> > map foo [(1,2),(3,4)] where foo (x,y) = x + y
13:28:03 <lambdabot>  Parse error
13:28:20 <ddarius> Cheery: No.
13:28:24 <osfameron> ah, helpful error :-(
13:28:27 <Cheery> "so eat them EAT EAT! GWAHAHAHAA"
13:28:51 <Cheery> "feast with sorrow"
13:28:53 <ddarius> osfameron: You can't attach where clauses to expressions.
13:29:10 <osfameron> ah!
13:29:24 <osfameron> shame
13:29:26 <ddarius> > let foo = uncurry (+) in map foo [(1,2),(3,4)]
13:29:27 <lambdabot>  [3,7]
13:29:46 <osfameron> uncurry?
13:29:53 <ddarius> :t uncurry
13:29:55 <ddarius> says it all
13:29:55 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
13:30:33 <osfameron> to whom?
13:31:06 <ddarius> @djinn (a -> b -> c) -> (a,b) -> c
13:31:06 <lambdabot> f a (b, c) = a b c
13:31:46 <osfameron> ah, it flattens a 2 element tuple
13:32:45 <ddarius> It turns a function that takes a pair into a function that "takes two arguments"
13:32:55 <ddarius> Er the other way around
13:33:31 <osfameron> so you can use let in expressions but not where?
13:33:40 <dcoutts> osfameron: right.
13:34:06 <osfameron> ok
13:35:35 <ddarius> let's are expressions where's are clauses
13:36:07 <osfameron> > let foo (x,y) = x + y in map foo [(1,2),(3,4)]
13:36:09 <lambdabot>  [3,7]
13:36:31 <osfameron> but uncurry is neater
13:37:26 <osfameron> sorry, whats difference between expression and clause?
13:37:52 <dfranke> *Data.Transaction> :kind DatabaseConfiguration
13:37:52 <dfranke> DatabaseConfiguration :: * -> (* -> *) -> * -> * -> * -> * -> *
13:37:57 <dfranke> :-)
13:38:17 <osfameron> eeek!
13:38:35 <Cheery> @dice 1d6
13:38:36 <lambdabot> 1d6 => 2
13:38:38 <Cheery> @dice 1d6
13:38:38 <lambdabot> 1d6 => 1
13:38:43 <Cheery> @dice 1d6
13:38:44 <lambdabot> 1d6 => 5
13:38:47 <Cheery> @dice 1d6
13:38:48 <lambdabot> 1d6 => 3
13:38:53 <Cheery> @dice 1d6
13:38:54 <lambdabot> 1d6 => 1
13:38:56 <Cheery> @dice 1d6
13:38:57 <lambdabot> 1d6 => 6
13:39:05 <Cheery> (5,3,6)
13:39:05 <ddarius> osfameron: The syntactic class
13:39:44 <ddarius> dfranke: Need type level records for that?
13:40:18 <sorear> dfranke: ':k' :)
13:40:41 <osfameron> ddarius: ah, i don't understand, never  mind ;-)
13:54:00 <osfameron> > toEnum $ fromEnum 'a'
13:54:02 <lambdabot>  97
13:54:15 <osfameron> why isn't that 'a' ?
13:54:30 <Heffalump> defaulting
13:54:46 <Heffalump> > (toEnum $ fromEnum 'a') :: Char
13:54:47 <lambdabot>  'a'
13:54:57 <osfameron> ah!
13:55:01 <Heffalump> :t toEnum $ fromEnum 'a'
13:55:04 <lambdabot> forall a. (Enum a) => a
13:55:11 <Heffalump> @instances Enum
13:55:13 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
13:55:27 <Heffalump> I forget what order defaulting uses, but Int or Integer will be above Char
13:55:41 <Heffalump> > (toEnum $ fromEnum 'a') :: Float
13:55:43 <lambdabot>  97.0
13:55:55 <osfameron> so it's a generc Enum till you cast it or do something with it
13:55:58 <Heffalump> Float is a rubbish Enum.
13:56:03 <Heffalump> > fromEnum 5.3
13:56:05 <lambdabot>  5
13:56:20 <Heffalump> osfameron: right, or make it a top-level declaration
13:56:34 <Heffalump> (or evaluate it in a REPL, like lambdabot)
13:56:34 <osfameron> i saw if you did : "string" it dtrt
13:56:46 <earthy> Float is enum due to Bounded, right?
13:56:51 <Heffalump> note that :: ... isn't really "casting", more "fixing the type"
13:57:02 <Heffalump> no idea
13:57:12 <osfameron> right
13:57:14 <Heffalump> but it's still a rubbish enum
13:57:29 <osfameron> heh
14:00:55 <Igloo> Bounded doesn't require Enum
14:01:08 <Igloo> People just want to be able to do [1..10] for Floats  :-/
14:01:31 <jcreigh> bah
14:01:37 <osfameron> pesy people
14:01:43 <DRMacIver> I know I've said this before, but the ability to overload purely on the type of the returned expression is great. :)
14:01:45 <osfameron> *pesky
14:02:03 <jcreigh> Floats only look like numbers if you half-close your eyes.
14:02:51 <DRMacIver> Does Haskell have an arbitrary precision reals type? :)
14:03:23 <DRMacIver> (Or are there libraries to provide it?)
14:06:18 <UnusedNick> Hi, could someone explain this for me
14:06:22 <UnusedNick> *Main> sequence $ [(randomIO :: IO Double)][*** Exception: stack overflow
14:06:37 <earthy> DRMacIver: there is at least one exact real arithmetic library
14:06:55 <UnusedNick> Sorry, there should be a new line in there
14:07:04 <kc5tja> UnusedNick: I think it's because you're creating an infinitely long list of random numbers.
14:07:15 <UnusedNick> sequence $ [(randomIO :: IO Double)]
14:07:23 <UnusedNick> is only one number, put inside a list
14:07:24 <monochrom> I don't see an infinite list.
14:07:26 <kc5tja> > sequence $ [1]
14:07:35 <dcoutts> UnusedNick: it works for me
14:07:38 <qwr> @src sequence
14:07:39 <lambdabot> sequence ms = foldr k (return []) ms
14:07:40 <lambdabot>     where
14:07:40 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
14:07:58 <davidL> if there are two instances of a package installed, mtl for example, will GHC be realize to use the other instance if one is unregistered?
14:07:59 <monochrom> I get [0.4682451803163265].
14:08:07 <sorear> davidL: Yes!
14:08:07 <jcreigh> monochrom: that's not what I get! :)
14:08:33 <earthy> http://www.haskell.org/haskellwiki/Exact_real_arithmetic
14:08:34 <lambdabot> Title: Exact real arithmetic - HaskellWiki
14:08:39 <sorear> davidL: and if you leave both registered, it will pick the highest version that allows dependencies to be satisfied!
14:09:02 <davidL> sorear: and if I do ``ghc-pkg unregister mtl'' how does it know which one to unregister?
14:09:03 <sorear> IMO algebraic numbers would be a good fit for haskell.
14:09:14 <sorear> davidL: By giving you an error message.
14:09:29 <sorear> davidL: ghc-pkg unregister mtl-2.0 is legal
14:09:47 <davidL> sorear: what if you have two packages of the same version
14:09:52 <earthy> DrMacIver: http://www.cs.man.ac.uk/arch/dlester/exact.html
14:10:05 <DRMacIver> earthy: Thanks
14:10:16 <sorear> davidL: you can't.
14:10:17 <monochrom> "two packages of the same version" like mtl-2.0 and posix-2.0?
14:10:22 <DRMacIver> earthy: But that page cannot be found. :)
14:10:31 <kc5tja> monochrom, UnusedNick: I confused sequence with repeat.  To me, the words (when used as a verb) mean the same thing, hence the confusion.
14:10:37 <davidL> like mtl-1.0 and mtl-1.0
14:10:47 <davidL> (in different directories)
14:11:01 <DRMacIver> augustss seems to have mirrored it at http://darcs.augustsson.net/Darcs/CReal/ though
14:11:01 <earthy> DRMacIver: the haskell wiki has a link to a copy of that maintained by Lennart Augustsson
14:11:02 <sorear> davidL: then your packages.conf file is corrupt, delete it and file a bug against ghc-pkg
14:11:04 <lambdabot> Title: Index of /Darcs/CReal
14:11:07 * earthy nods
14:11:10 <monochrom> You can't even register mtl-1.0 twice.
14:11:12 <earthy> it's quite nice
14:11:24 * earthy used it to calculate mortgages back when he was looking for one
14:11:26 <UnusedNick> interestiing. i got a stack  overflow again. randomIO by itself doesnt cause any problems
14:11:49 <earthy> interestingly, my calculations were way too exact. ;)
14:12:50 <kc5tja> UnusedNick: I get not in scope errors when I try.
14:12:59 <kc5tja> What module has randomIO?
14:13:07 <jcreigh> @index randomIO
14:13:08 <lambdabot> System.Random
14:13:08 <monochrom> Random
14:13:21 <DRMacIver> earthy: Why did you need infinite precision reals to calculate mortgages? :)
14:13:35 <sorear> Surely Rational is good enough!
14:14:05 <sorear> @users
14:14:06 <lambdabot> Maximum users seen in #haskell: 335, currently: 307 (91.6%), active: 44 (14.3%)
14:14:06 <Maddas> Maybe he has transcendental interest rates
14:14:09 <monochrom> Be careful when you calculate money.  You have to duplicate exactly the same rounding errors and mistakes as the bank does.
14:14:31 <davidL> sorear: there is a mtl-2.0?
14:14:52 <davidL> @hackage mtl
14:14:53 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mtl
14:15:03 <kc5tja> I cannot reproduce the error.
14:15:39 <earthy> drmaciver: I didn't need it, but it sure as hell beat the results I got with Float. ;)
14:15:55 <earthy> and it was an interesting exercise in numberswindling. ;)
14:15:58 <sorear> davidL: I was pulling numbers out of thin air, okay? ;)
14:16:16 <monochrom> mtl-3.14
14:16:19 <davidL> sorear: ah, I see :)
14:16:47 <kc5tja> @index concatM_
14:16:48 <lambdabot> bzzt
14:16:53 <kc5tja> @index liftM_
14:16:54 <lambdabot> bzzt
14:17:02 <sorear> We should specify a package with a Chaitin number for a version.
14:17:03 <kc5tja> @index joinM_
14:17:04 <lambdabot> bzzt
14:17:06 <kc5tja> @index joinM
14:17:06 <lambdabot> bzzt
14:17:27 <monochrom> That will be cool.
14:18:00 <kc5tja> :t repeat
14:18:05 <UnusedNick> Ok, I now get overflow errors just from RandomIO. Will try to narrow down the problem but it will take some time as it nerfs my computer every time
14:18:09 <lambdabot> forall a. a -> [a]
14:18:18 <kc5tja> :t sequence
14:18:20 <lambdabot>     Ambiguous occurrence `sequence'
14:18:20 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
14:18:36 <kc5tja> :t Prelude.sequence
14:18:37 <jcreigh> UnusedNick: are you doing this with hugs or ghci?
14:18:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
14:18:49 <kc5tja> :t join
14:18:52 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:19:00 <sorear> UnusedNick: it NERFS your computer?!
14:19:16 <earthy> cool robotics. ;)
14:19:18 <DRMacIver> Yeah. It randomly replaces it with a foam replica. :)
14:20:38 <UnusedNick> In ghci. By nerf I mean I have to switch to a text terminal to kill it as it eats up all my RAM and KDE freezes
14:20:40 <kc5tja> @index join
14:20:41 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
14:20:58 <UnusedNick> however, its not happening anymore
14:21:05 <UnusedNick> Which is annoying
14:21:08 <sorear> Wow.  that's even worse than http://hackage.haskell.org/trac/ghc/ticket/163!
14:21:10 <lambdabot> Title: #163 (Error in compile deletes the sourcefile) - GHC - Trac
14:21:12 <UnusedNick> Now I will live in fear of it coming back
14:21:38 <earthy> unusednick: memory usage is a somewhat unpredictable factor in haskell code
14:21:50 <sorear> UnusedNick: That's odd.  When a program eats all MY ram the console never lags more than 5s or so :)
14:22:41 * qwr . o O ( ... and then the program gets SIGKILL... )
14:22:45 <UnusedNick> The console doesnt freeze - KDE does. I switch to a text only tty to kill it
14:23:21 <UnusedNick> earthy: One random number vs 256MB RAM. Thats more than unpredictable.
14:23:37 <earthy> only 256M? pfah. ;)
14:23:50 <earthy> and it really depends on what the random number is used for
14:23:58 * sorear shuns X
14:24:13 <UnusedNick> I suspect an earlier line which I aborted didnt entirely die as the problem went away when I restarted ghci.
14:24:14 <earthy> if a huge thunk gets generated, the size of which is dependent on the random number...
14:25:48 <UnusedNick> earthy: I just typed sequence $ [(randomIO :: IO Double)] into the interpreter. Nothing complicated. I'm pretty sure one of the previous lines was the problem. How does the ctrl-c interrupt work in ghci? Will it stop IO actions or just the process generating them?
14:26:21 * qwr tried length [0..] in ghci and X got a bit sluggish while kernel swaps
14:27:22 <UnusedNick> For example, I mistakenly wrote sequence $ repeat [(randomIO :: IO Double)] which is what you originally read it as. I hit ctrl-c when I realised what i had done and everything was fine again. But then randomIO gave me monstrous overflows until I restarted ghci.
14:27:40 <qwr> but its not freezing
14:27:45 <DRMacIver> qwr: Hm. That seems to take a rather long time before it causes me any problems.
14:28:01 <earthy> unusednick: that does in fact make sense
14:28:07 <qwr> i have most of swap exhausted now
14:28:16 <sorear> UnusedNick: that sounds very bad.  bad enough that you should post it to glasgow-haskell-users@haskell.org
14:28:17 <earthy> as you are still in the top-level do that ghci gives you
14:28:47 <earthy> which means that there's probably still some suspended computations in the IO monad that randomIO depends on
14:28:49 <sorear> UnusedNick: I want to hear what the Simons say, since C-c in ghci confuses me too!
14:28:55 * sorear waits for the thread!
14:29:01 <UnusedNick> so only the generating process gets killed, but all the random numbers pulled out so far are trying to be evaluated?
14:29:38 <earthy> unusednick: no, the generating process gets killed, as do the numbers pulled so far. however, the new seed still needs to be generated
14:29:40 <sorear> UnusedNick: nobody here knows, I'm sure.  corners this dark are not suitable for IRC
14:30:11 <earthy> but, this is mostly extrapolation (not very dark though, sorear ;)), and my gf is beckoning me to bed. :)
14:30:14 <qwr> but yes, it takes quite long time
14:30:40 <UnusedNick> OK, I will finish off this module and post the problem to the mailing group. Thanks all
14:31:04 <nominolo> @instances MonadPlus
14:31:06 <DRMacIver> @remember sorear UnusedNick: nobody here knows, I'm sure.  corners this dark are not suitable for IRC
14:31:06 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
14:31:06 <qwr> i think ghci gc tries to walk the swap in the hope of collecting something ;)
14:31:06 <lambdabot> Done.
14:31:19 <Saizan> the "i need to fectch the previous random seed that is hidden in a nonterminating action" seems plausible
14:31:58 <nominolo> @src mplus :: StateT
14:31:59 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
14:32:13 <earthy> not hidden in a nonterminating action
14:32:21 <earthy> hidden at the end of a huge thunk
14:32:21 <sorear> Saizan: it seems dubious to me, since it isn't one thread of state modification.  it is a bunch of IO actions which can be interrupted in between
14:32:26 <nominolo> how was the syntax for getting the source of a typeclass function?
14:32:36 <sorear> @src StateT mplus
14:32:37 <lambdabot> Source not found. Maybe if you used more than just two fingers...
14:32:48 <sorear> @source Control.Monad.State
14:32:49 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
14:32:50 <nominolo> @src Maybe mplus
14:32:50 <lambdabot> Nothing `mplus` ys  = ys
14:32:51 <lambdabot> xs      `mplus` _ys = xs
14:33:51 <qwr> heh, got killed finally
14:33:55 <nominolo> :t runState
14:33:58 <lambdabot> forall s a. State s a -> s -> (a, s)
14:34:20 <qwr> but x didn't freeze. just got sluggish... it was a bit annoing still.
14:34:57 <nominolo> > runState (modify (1+) `mplus` modify (*2)) 0
14:34:58 <lambdabot>   add an instance declaration for (MonadPlus (State s))
14:35:05 <sorear> qwr: can you hear me?  (your client still hasn't responded to my pings)
14:35:09 <nominolo> > runState (modify (1+) `mplus` modify (*2) >>= return ()) 0
14:35:10 <lambdabot>  Couldn't match expected type `State s a' against inferred type `()'
14:35:12 <qwr> sorear: yes
14:35:17 <sorear> nominolo: runStateT
14:35:25 <UnusedNick> qwr: the line between frozen and sluggish is very small on a five year old budget laptop
14:35:33 <qwr> the irssi was on other machine anyway, so it shouldn't have affected in any way
14:35:35 <sorear> > runStateT (modify (1+) `mplus` modify (*2)) 0 :: [(Int,())]
14:35:36 <lambdabot>  Couldn't match expected type `Int' against inferred type `()'
14:35:45 <sorear> > runStateT (modify (1+) `mplus` modify (*2)) 0 :: [((),Int)]
14:35:47 <lambdabot>  [((),1),((),0)]
14:36:08 <nominolo> oh
14:36:16 <nominolo> hm, not what i was looking for :/
14:37:14 <sorear> nominolo: you wanted backtracking to preserve state?
14:37:28 <sorear> nominolo: if so, see listt done right *tries to find it*
14:37:39 <nominolo> sorear: no i want non-backtracking state
14:37:58 <nominolo> but i guess, some fold can handle this
14:38:56 <nominolo> > sum $ map snd (runStateT (modify (1+) `mplus` modify (1+)) 0 :: [((),Int)])
14:38:58 <lambdabot>  2
14:38:59 <sorear> nominolo: if all you want is state what is `mplus` for?
14:39:11 <nominolo> i have a backtracking function
14:39:17 <nominolo> and i want to gather some stats
14:39:39 <sorear> Do you want stats from non-accepting paths?
14:39:52 <nominolo> sorear: right
14:40:02 <sorear> then this will work
14:40:08 <sorear> @oldwiki ListTDoneRight
14:40:09 <lambdabot> http://www.haskell.org/hawiki/ListTDoneRight
14:41:34 <nominolo> what's wrong with type MyMonad = StateT Stats Maybe   ?
14:43:18 <sorear> You won't get any stats if it fails.
14:43:32 <sorear> MyMonad = Just (stats,value) | Nothing
14:43:42 <nominolo> oh
14:44:51 <sorear> http://haskell.org/haskellwiki/ListT_done_right btw
14:44:53 <lambdabot> Title: ListT done right - HaskellWiki
14:49:26 <nominolo> hm, MyMonad = MList (State Stats) ?
14:50:04 <nominolo> @src [] >>=
14:50:04 <lambdabot> Source not found. My pet ferret can type better than you!
14:50:28 <sorear> nominolo: (a) MyMonad = ListT (State Stats) (b)
14:50:32 <sorear> @src [] (>>=)
14:50:33 <lambdabot> m >>= k     = foldr ((++) . k) [] m
14:50:58 <sorear> aka, concatMap k m
14:51:13 <nominolo> ok, thanks, i'll give it a show
14:51:18 <nominolo> er
14:51:22 <nominolo> s/show/shot/
14:51:48 <dcoutts> does anyone know if wxhaskell actually works with ghc-6.6 ?
14:52:18 <dcoutts> are there any patches about that allow it to work with 6.4.x and 6.6 that I can use for a distro package?
14:53:04 <dcoutts> I assume there must be, otherwise how do people actually use wxHaskell these days?
14:53:53 <sorear> dcoutts: I don't use wxHaskell because I believed your "wxHaskell requires manual MM" :)
14:54:02 <nominolo> dcoutts: i used it with ghc 6.6 on macos
14:54:17 <dcoutts> sorear: well good :-) I don't use it either, but I'd like the gentoo ebuild to work
14:54:26 <dcoutts> nominolo: do you apply any patches?
14:54:39 <nominolo> dcoutts: nope
14:54:40 <sorear> dcoutts: btw, is that statement still true?
14:54:45 <dcoutts> nominolo: or are you using a ports package that uses some patches?
14:55:05 <nominolo> hm, wait
14:55:22 <dcoutts> sorear: I don't think wx has changed, so wxHaskell can't do any better
14:55:57 <nominolo> dcoutts: i think i had to use the darcs version
14:56:27 <dcoutts> nominolo: ah right, for a distro package we really need a tarball with a stable url and md5
14:56:28 <nominolo> dcoutts: yep.  the release version needed some patches, but the darcs version worked
14:56:43 <dcoutts> nominolo: do you know if those patches are available anywhere?
14:56:47 <sorear> dcoutts: well I've heard counterattacks that wxHaskell has cool declarative layout fu
14:57:03 <dcoutts> sorear: layout is a solved problem
14:57:06 <nominolo> dcoutts: you could do a manual diff
14:57:19 <sorear> dcoutts: and declarative + manualMM causes my brain's logic engine to backtrack
14:57:25 <dcoutts> nominolo: hmm, I assume the darcs version has many other changes
14:57:51 <sorear> why diff manually?  macosx has a diff program!
14:57:59 <sorear> hello waern
14:58:09 <nominolo> dcoutts: yes.  but the patches i know of were macosx-specific
14:58:10 <dcoutts> sorear: have you ever seen any GUIs built only using layout combinators? they're quite distinctive because they're so ugly :-)
14:58:14 <waern> hi sorear
14:58:19 <waern> and everyone else
14:58:22 <nominolo> sorear: i meant tarball vs. darcs head
14:58:24 <kolmodin> dcoutts: I think you'd have to install wxhaskell incrementally with the ghc66 patches. so it doesn't play well with gentoo
14:58:40 <dcoutts> kolmodin: hmm? I don't follow
14:58:42 <kolmodin> hia waern!
14:59:12 <sorear> dcoutts: I've seen combinatory layout before, and it was quite pretty.
14:59:17 <kolmodin> dcoutts: someone has made wxhaskell with ghc66, but it requires that you compile and install stuff one thing at a time
14:59:20 <kolmodin> dcoutts: iirc
14:59:34 <waern> kolmodin: hi there
14:59:50 <dcoutts> kolmodin: oh, it breaks the package up into multiple bits?
15:00:13 <kolmodin> dcoutts: I'm not sure
15:00:18 <kolmodin> waern: any haste2 hacking lately?
15:00:34 <waern> kolmodin: not for the last couple of days
15:01:10 <dcoutts> sorear: does wxhaskell allow the use of a visual gui builder? that's much better than layout combinators
15:01:22 <dcoutts> since it gives immediate visual feedback
15:01:56 <kolmodin> what's Eric Kow's nick in here?
15:02:02 <dcoutts> course, if you don't have a gui builder then layout combinators are better than nothing
15:02:04 <monochrom> kowey?
15:02:27 <nominolo> dcoutts: i don't think it so.  at least it doesn't use xml-files like gtk
15:02:34 <kolmodin> I think he's on top of wxhaskell atm
15:03:12 <kolmodin> does wx have a gui builder at all?
15:03:26 <kolmodin> monochrom: ok
15:11:23 <SyntaxNinja> heya folks.
15:11:42 <SyntaxNinja> I'm wondering if anyone knows offhand how darcs development is going; any progress fixing the conflictor stuff?
15:13:21 <stepcut> SyntaxNinja: #darcs maybe ?
15:13:35 <SyntaxNinja> heh #darcs is probably a superset of this channel ;)
15:14:38 <stepcut> SyntaxNinja: :p
15:15:20 <Igloo> SyntaxNinja: You know Jason has a SoC project to work on it, right?
15:16:11 <SyntaxNinja> Igloo: yeah, but no details; just wondering if besides that there's any progress over the last few months
15:16:32 <Igloo> NAFAIK
15:17:40 <greenrd> I'm currently doing some maintenance on the Wikipedia articles "Conditional statement" and "control flow", and I'm a bit stuck as to a general term which encompasses conditional statements, conditional expressions, dynamic dispatch and pattern matching
15:18:09 <sorear> @botsnack
15:18:10 <lambdabot> :)
15:18:11 <greenrd> "Control flow" uses the term "Choice" for that, but I can't call an article Choice.
15:18:13 <sorear> Apparently my cable modem just got replaced :)
15:18:18 * ddarius isn't on #darcs
15:18:43 <ddarius> "control statements" ?
15:19:00 <greenrd> The trouble is, that's not what the Haskell report calls them, afaik
15:19:19 <greenrd> and in general I think Haskellers would talk of conditional expressions, not conditional statements
15:19:22 <sorear> dcoutts: Assuming VB is in fact still the last word - BLECH! visual gui builders suck unless your screen is the same size as the developers!
15:19:52 <greenrd> Also, patterns aren't expressions _or_ statements - they're a language construct
15:19:59 <sorear> (from output buffer)
15:19:59 <sorear> dcoutts: I've seen combinatory layout before, and it was quite pretty
15:19:59 <sorear> dcoutts: the code was pretty ugly though (java)
15:19:59 <sorear> but the principles of gridlayout/floatlayout/etc are sound and elegant.
15:20:00 <SamB> sorear: not necessarily
15:20:02 <sorear> (if only the combinators were as nice as haskell's varsyms! ;)
15:20:13 <SamB> VB does yes ;-)
15:20:16 <dcoutts> sorear: that's why gtk uses a scalable layout system, precisely because fixed layout systems suck.
15:20:37 <greenrd> And I can't just invent an idiosyncratic term for an article title - Wikipedia has to go by the terms people actually use in the real world, generally
15:20:53 <sorear> dcoutts: It's possible to do scalable layout visually?
15:21:04 <dcoutts> sorear: try glade-3
15:21:12 <dcoutts> it's just box packing
15:21:15 <SamB> greenrd: conditionals
15:21:33 <sorear> glade *3*?  last I checked sid only had 2!
15:21:48 <dcoutts> @google glade 3
15:21:51 <lambdabot> http://glade.gnome.org/
15:21:51 <lambdabot> Title: Glade User Interface Builder
15:22:11 <SamB> dcoutts: since when is there a GTK 3?
15:22:32 <dcoutts> SamB: there is no gtk 3, there is a glade 3 though
15:22:35 <Philippa> greenrd: "control flow constructs"?
15:22:50 <SamB> Philippa: does Haskell have control flow?
15:22:51 <greenrd> SamB: Ah yes, that is actually used
15:23:07 <dcoutts> sorear: glade-2 is ok too but it doesn't impress anyone with it's UI :-) glade-3 is much nicer in that respect.
15:23:09 <Philippa> SamB: yes, it's just a bit weird
15:23:11 <sorear> SamB: Yes!  We call them "operational semantics"
15:23:22 <SamB> sorear: hehe
15:23:30 <greenrd> SamB: I've found some people talking about "Haskell's control flow", so that's good enough for WP (WP's standards for computing articles are generally quite low ;)
15:24:14 <SamB> that is totally not fair
15:24:15 <Philippa> you might not be able to state directly what the control flow should be in all cases, but it's still a meaningful notion in haskell
15:24:54 <Philippa> it's just that there are potentially many valid control paths for a given piece of code
15:26:23 <Philippa> I guess you could think of it as the (change in the) set of valid reductions at a given point?
15:26:55 <Philippa> case statements (and the things that desugar to them) have a pretty significant effect on that
15:29:41 <monochrom> WP = ?
15:31:20 <monochrom> In Haskell evaluation order determines control flow. (May as well say "is".)  Very important for resource accounting, unimportant otherwise.
15:32:34 <SamB> monochrom: wikipedia
15:36:52 <nominolo> wow, the most simple constraint solver takes longer for n-queens if n == 14, than for n == 15
15:54:57 <ddarius> One regex parser: check
15:56:14 <sphynx> hi again! I need to parse string with simple operators (+, -, *, etc.), variables, functions calls with parameters, etc. So I need to write some parse :: String -> [Token]. Should I use for this task some API like Parsec, or it will be an overkill for such simple task?
15:58:05 <Saizan> parsec is quite lightweight in terms of code, and it has combinators for lexemes
15:58:48 <sphynx> yeah, I saw some examples, they look nice and clear
15:58:53 <monochrom> Use Parsec.
15:59:17 <monochrom> I can write the code for you for the amazing discounted price of US$1000.
16:00:26 <monochrom> #haskell special offer.  In #perl or #c I would quote US$10000.
16:00:31 <sphynx> monochrom, oh, you are so kind :)
16:00:41 <nominolo> sphynx: Parsec already has Languages
16:01:33 <sphynx> nominolo, what does it mean? There are already defined some typical tokens with typical lexemes?
16:01:47 <nominolo> sphynx: exactly
16:02:26 <sphynx> nominolo, cool!
16:02:42 <nominolo> i can't find the docs, though
16:03:05 <sphynx> http://www.cs.uu.nl/people/daan/download/parsec/parsec.html
16:03:25 <sphynx> maybe this? It seems this is official Parsec site
16:03:30 <nominolo> no, i mean for the languages
16:04:25 <nominolo> http://www.cs.uu.nl/people/daan/download/parsec/parsec.html#LanguageDef
16:04:28 <lambdabot> http://tinyurl.com/w9vft
16:07:20 <sioraiocht|away> @where parsec
16:07:20 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
16:07:54 <sphynx> nominolo, Well, I will look into all of this
16:07:59 <sphynx> thanks
16:11:48 <sphynx> good night all!
16:13:17 <liber> Well. Im like the biggest n00b ever. I have read some tutorials, and i have got the basics using prelude. The problem I have is that I cant for anything in the world write multiline functions. only two putStrLn avter eachother. I only get the stupid indent-error :)
16:14:13 <QtPlatypus> liber: What do you mean by multiline functions?
16:14:33 <liber> QtPlatypus: functions that span over more than one line :)
16:14:37 <QtPlatypus> And you do know that haskell is indent based like python.
16:14:44 <liber> i know
16:15:14 <liber> can I use tabs for indenting, or is only spaces allowed?
16:15:31 * QtPlatypus has only ever used spaces.
16:16:13 * liber has only used tabs previously
16:16:21 <ddarius_> You can use both, bout the compiler treats tabs as 8 spaces.
16:16:32 <ddarius> I'd recommend using only spaces
16:16:36 <liber> okay
16:16:59 <ddarius> Also, you don't -need- to use layout.  If you want, you could use {}'s and ;'s.
16:17:33 <liber> since almost everyone else uses layout, I'm not going to cheat.
16:17:39 <liber> :)
16:20:23 <liber> ddarius: well. For example. If I want the main function to span more than two lines (maybe just two putStrLn). An example?
16:26:09 <dmead> ello
16:26:19 <dmead> how do you convert a type constructor to text?
16:30:51 <mauke> liber: main = do { putStr "Hello,"; putStr " world!\n" }
16:31:37 <nominolo> dmead: takeWhile (not isSpace) . show  ?
16:32:02 <dmead> ah yes
16:32:03 <mauke> liber: there's a multiline main at the end of http://mauke.ath.cx/stuff/haskell/regen.hs
16:32:04 <dmead> good idea
16:32:04 <liber> mauke: OOOOH! There should be a "do"-word to :) No wonder I fauled miserably :)
16:32:11 <nominolo> > (takeWhile (not isSpace) . show) (Left 4)
16:32:13 <lambdabot>  Couldn't match expected type `Bool'
16:32:38 <nominolo> :t isSpace
16:32:41 <lambdabot> Char -> Bool
16:32:43 <nominolo> :t takeWhile
16:32:45 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
16:32:59 <mauke> liber: my rule of thumb is: start a new line after every "do", "where", "of"
16:33:20 <LoganCapaldo> so, is it just me or is :def in ghci kinda useless?
16:33:34 <nominolo> > takeWhile (not isSpace) (show (Left 4))
16:33:35 <lambdabot>  Couldn't match expected type `Bool'
16:33:44 <nominolo> what the?
16:33:47 <ddarius> LoganCapaldo: I did some cool stuff with it before.  I forget what now.
16:33:57 <nominolo> :t takeWhile (not isSpace)
16:33:59 <lambdabot>     Couldn't match expected type `Bool'
16:34:00 <lambdabot>            against inferred type `Char -> Bool'
16:34:15 <Saizan> > takeWhile (not . isSpace) (show (Left 4))
16:34:17 <lambdabot>  "Left"
16:34:25 <Saizan> ?type not
16:34:28 <lambdabot> Bool -> Bool
16:34:45 <liber> mauke: Well. I tried to do a "multiline" without the "do". That did not work very well :) Atleast not for doing two things, like two putStrLn :)
16:34:50 <nominolo> yes, i just realized the moment you sent it :)
16:35:50 <mauke> yeah, layout needs an activating keyword
16:36:30 <liber> I understand that now :) Is "case" such a keyword?
16:36:58 <liber> yes it was :)
16:37:00 <mauke> no, but "of" is
16:37:06 <liber> oes
16:37:09 <liber> oh
16:37:17 <ddarius> LoganCapaldo: The output of a :def'ined command is executed at the GHCi prompt.
16:37:48 <LoganCapaldo> ddarius: ah ha, I thought it just printed it
16:37:56 <LoganCapaldo> thats clearly more useful
16:41:31 <liber> mauke: thx. Now I can really start to learn this. I dislike interactive "shells"...
16:41:53 <LoganCapaldo> > let takeUntil = takeWhile . (not .) in takeUntil isSpace (show $ Left 4)
16:42:01 <lambdabot>  "Left"
16:42:09 <mauke> they're great for quick tests
16:43:13 <Pseudonym> GHCi has completely replaced bc and dc for me.
16:43:14 <liber> mauke: I know when to use them. I just dislike them anyway..
16:43:29 <Pseudonym> Not that I ever used dc that much.
16:43:36 <liber> That not said I dont use them
16:44:02 * LoganCapaldo replaced dc with a forth prompt ;)
16:44:08 <Pseudonym> :-)
16:44:19 <Pseudonym> Seriously, though, I tend to think of programming as a conversation.
16:44:31 <Pseudonym> It's me trying to explain what I mean to the programming language implementation.
16:44:45 <Pseudonym> And if it doesn't understand, it means I wasn't clear enough.
16:45:21 <Pseudonym> And, as we all know, the act of explaining helps get things clear in the explainer's head.
16:45:34 <alan___> can anyone here get ghci to support command completion
16:45:47 <Pseudonym> alan: What is this "command" that you speak of?
16:45:59 <LoganCapaldo> well clearly its doable with :def :)
16:46:00 <alan___> function names
16:46:11 <LoganCapaldo> maybe not then
16:46:16 <Pseudonym> let f = fooBarBazWhatALongNameThisIs
16:46:19 <Pseudonym> ?
16:46:34 <Pseudonym> I do that sometimes.
16:46:44 <LoganCapaldo> alan___: considered haskell-inferior mode or the like?
16:47:00 <Pseudonym> We have a wiki page of haskell modes for vim now.
16:47:00 <Pseudonym> Woo.
16:47:03 <alan___> i mean tab completion
16:47:11 <alan___> oh ok
16:47:15 <alan___> im interested
16:51:51 <ddarius> :def foo const $ return ":undef foo"
16:52:19 <LoganCapaldo> mmm state
16:53:08 <LoganCapaldo> this command will self-destruct in 5 4 3 2 ...
16:55:17 <ddarius> :def foo const $ do putStrLn "This command will self-destruct in"; mapM_ (\i -> print i >> threadDelay 1000000) [5,4..1]; return ":undef foo"
16:56:30 <sioraiocht|away> anyone here familiar with basic parsec?
16:56:36 <LoganCapaldo> heh
16:56:39 <monochrom> all
16:57:24 <sioraiocht|away> I have parser that will parse a specific subset of characters, how do I make a parser that will parse a WORD of those characters?
16:57:38 <ddarius> many parser
16:57:42 <sioraiocht|away> ah, thanks
16:57:45 <LoganCapaldo> or many1 parser
16:57:52 <sioraiocht|away> what's the differene
16:57:56 <LoganCapaldo> if it needs to be a least one character long
16:58:00 <sioraiocht> aha
16:58:01 <ddarius> Yeah, many1 is probably closer to what you want.
16:58:06 <sioraiocht> aye it is, thanks :)
16:58:21 <sioraiocht> the user guide is..not easy to swallow, is there any other tutorial out there?
16:58:40 <monochrom> I swallowed the user guide.
16:58:48 <ddarius> There is a "letter" (I'm not sure if that is the user guide)
16:58:53 <LoganCapaldo> Really? I liketh the user guide for parsec
16:59:13 <dons> moin
16:59:14 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
16:59:19 <ddarius> Parsec is one of the more huggable Haskell libraries.
16:59:32 <monochrom> The wikibook has a section on parsec.
16:59:33 <LoganCapaldo> for sure
16:59:48 <monochrom> http://en.wikibooks.org/wiki/Haskell/Practical_monads#Parsing_monads
16:59:48 <sioraiocht> LoganCapaldo: I guess it might be beacuse I just am using it for a specific purpose and impatient with learning other things about parsec first, hehe
16:59:50 <lambdabot> http://tinyurl.com/yog84n
17:01:16 <LoganCapaldo> well if you can write a EBNF for your language you can pretty much 'search and replace" to get into parsec as long as you kepe the left bias in mind and make sure its not left recursive
17:01:31 <sioraiocht> hahaahaha
17:01:37 <sioraiocht> I'll kepe that in mind
17:02:14 <dmwit> ?botsnack
17:02:35 <lambdabot> :)
17:02:37 <LoganCapaldo> > many (char 'a') -- does lambdabot import parsec?
17:02:41 <lambdabot>  Couldn't match expected type `f a' against inferred type `Doc'
17:02:55 <dons> no, maybe it should
17:02:56 <LoganCapaldo> guess not
17:04:06 <Saizan> ?type (many,char)
17:04:09 <lambdabot> forall (f :: * -> *) a. (Alternative f) => (f a -> f [a], Char -> Doc)
17:04:29 <Saizan> ?index many
17:04:30 <lambdabot> Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec, Text.ParserCombinators.ReadP, Distribution.Compat.ReadP
17:05:31 <monochrom> "Doc" sounds like from a pretty printer.
17:05:44 <LoganCapaldo> ?index char
17:05:45 <lambdabot> Graphics.HGL.Window, Graphics.HGL.Core, Graphics.HGL, Graphics.SOE, Language.Haskell.TH.PprLib, Text.ParserCombinators.Parsec.Char, Text.ParserCombinators.Parsec, Text.ParserCombinators.ReadP,
17:05:45 <lambdabot> Distribution.Compat.ReadP, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
17:06:29 <monochrom> "Alternative" sounds like from Applicative.
17:07:19 <ddarius> @index Alternative
17:07:19 <lambdabot> bzzt
17:08:00 <LoganCapaldo> @index Map
17:08:01 <lambdabot> Data.Map
17:08:11 <monochrom> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html#v%3Amany
17:08:13 <lambdabot> http://tinyurl.com/yyo64c
17:08:19 <LoganCapaldo> well so much for my theory'
17:08:33 <LoganCapaldo> oh maybe not
17:08:36 <LoganCapaldo> @index Monad
17:08:37 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
17:08:55 <monochrom> I'm encyclopedic concerning what's in the hierarchical library. :)
17:08:57 <LoganCapaldo> I guess index does do types and type classes
17:09:47 <monochrom> I'm bio-nano-tech hoogle.
17:10:03 <monochrom> I also perform higher-order unification.
17:10:41 <LoganCapaldo> but do you do weddings and bar-mitzvahs?
17:11:00 <kilimanjaro> LoganCapaldo, why, are you going to marry a 13 year old jewish boy?
17:11:40 <LoganCapaldo> kilimanjaro: wouldn't you like to know?
17:11:50 <monochrom> LoganCapaldo is the 13 year old jewish boy.
17:12:14 <kilimanjaro> I stand corrected :)
17:12:18 <dolio> Nothing makes a party like a guy standing around doing higher-order unification.
17:13:01 <LoganCapaldo> Just for the record, I'm neither 13 nor jewish. However I do have the maturity of a 13-year old :)
17:13:59 <kilimanjaro> I'm guilty of that as well (hence my accusations about you)
17:23:50 <dmead> hey peopl
17:23:53 <dmead> in unification
17:24:03 <dmead> constants can come from both patterns ?
17:24:05 <dmead> ie
17:24:17 <dmead> F x b and F a y unifty to F a b
17:24:19 <dmead> yes?
17:25:37 <monochrom> Yes.
17:26:01 <dmead> awesome.
17:26:43 <dons> are we there yet!?
17:26:47 <dmead> almost!
17:26:55 <dons> great!
17:27:24 <dmead> i'm still not totally clear on the renaming stuff from you or cale's supplymonad
17:27:27 <dmead> but i'm getting there
17:28:43 <dons> hehe. ok. you find a variable, look it up in the Map Var Var in your State monad, if its found, replace it with its pair, if itsnot found, generate a new random name, insert that into the env, and rename it. then continue the traversal
17:29:38 <dons> wow, we've had 22 simultaneous users in #xmonad
17:29:40 <dons> ?users
17:29:40 <lambdabot> Maximum users seen in #haskell: 335, currently: 290 (86.6%), active: 41 (14.1%)
17:29:51 <dons> > 22 / 335 * 100
17:29:51 <ddarius> ?users #xmonad
17:29:52 <lambdabot> Maximum users seen in #xmonad: 22, currently: 20 (90.9%), active: 9 (45.0%)
17:29:53 <lambdabot>  6.567164179104477
17:30:05 <dons> does that mean 6.5% of all haskell programmers use xmonad? :-)
17:30:07 <dmead> dons: yep, it's the state monad stuff that im still trying to get my head around
17:30:33 <dmead> i need my virtual desktops =/
17:31:29 <dons> you have virtual desktops in xmonad, don't you?
17:31:29 <dons> or you mean, the metaphor of a desktop/
17:32:41 <Shimei> Maybe the desktop pager?
17:33:11 <dons> hey dpiponi
17:33:21 <dpiponi> hi dons
17:33:31 <dons> dpiponi++ thanks for the blogging :-) got to keep the spirit alive
17:33:34 <monochrom> please do not leave
17:34:39 <dpiponi> dons: well I'm back to playing with microcontrollers a bit right now - and dealing with the new cat, kitchen etc.
17:34:57 <dpiponi> Hard to think about Haskell!
17:35:44 <dons> dpiponi: yeah, I've been busy busy too.
17:35:52 <dons> actually, hopefully i can get something written today.
17:37:04 <dpiponi> I'll probably do something on monads and taint soon. Cheating though...I wrote most of it two or three months ago.
17:38:26 <dpiponi> Wish writing to the serial port was easier with Haskell. I could use it as a nice interactive environment to talking to hardware.
17:38:54 <dons> dpiponi: yeah, that's interesting. when I first started using monads in haskell, i always mentally thought of them as taint checking in the perl style
17:39:09 <dons> actually, implementing perl's taint checking rigorously in a monadic style would be fun
17:41:35 <dpiponi> I think it's interesting that lots of monad are related to taint. For example if you have a "security level" monoid (eg. ELEVATED+GUARDED=ELEVATED) then the writer monad appears naturally!
17:42:17 <ddarius> It's not surprising that monads are related to "tainting" considering their relation to effect systems.
17:42:18 <dons> mm. privledge seperation in modern C systems (like OpenBSD servers, such as sshd) naturally form a monad/taint system too
17:42:44 <ddarius> That said, I, personally, don't see the "tainting" aspect as the primary one.
17:42:46 <dons> unfortunately, in the C case, they have to rely on manual inspection to gurantee seperation
17:43:30 <Philippa> I sometimes find myself wanting families of monads
17:43:33 <dons> ddarius: yeah, the combination of effect and data type wrapping naturally leads to a (static) tagging and seperation of effects.
17:43:56 <Philippa> or arrows, for that matter
17:44:17 <ddarius> Philippa: Such as? (and don't we have them in one respect with parameterized monads)
17:44:22 <Philippa> where you can define which types within a family it's okay to use >>= or >>> on
17:44:30 <Philippa> yes, that's exactly what I'm talking about
17:44:34 <dpiponi> comonads do something similar. If 'return' blesses something, 'coreturn' is a kind of fall from grace.
17:44:52 <dons> oh, that reminds me, we really need to get the comonad package on hackage.
17:45:29 <ddarius> There's a comonad package?
17:45:42 <dons> there is, dpiponi's mentioned it a few times.
17:45:47 <merus> Yes. Comonads. Necessary.
17:45:50 <dons> with haddocks!
17:46:19 <Philippa> ddarius: the fun part's when you don't have parametricity per se
17:46:38 <dons> merus: well, we have to keep up the arms race against other languages. as long as we have the new, superior technology, they dare not invade, as they risk assured destruction -- co-monadically!
17:46:47 <dpiponi> I had trouble making haddock work. After a hard time building it there turned out to be something in my code haddock didn't like. (Can't remember what it was though I did ask about it here.)
17:46:51 <ddarius> Only because we are restricted to the category of Haskell functions and types.
17:47:28 <merus> yay a new sigfpe!
17:47:30 * merus reads.
17:47:46 <ddarius> A phrase I heard often of late that I like: "asymmetric advantage"
17:48:00 <dons> hmm. we could probably have a series on each of the modules in mtl
17:48:06 <ddarius> (Not that there are symmetric advantages, but the emphasis is nice)
17:50:17 <Philippa> ddarius: there are, it's when the other side has an equivalent but orthogonal advantage
17:56:14 <Philippa> did my point re parameterised stuff make sense, btw? The issue's more or less entirely with the sequencing ops
17:56:43 <ddarius> Provide an example of what you'd want to do.
17:57:45 <Philippa> okay. Really simple one?
17:58:09 <Philippa> have an ArrowF someParm a b...
17:58:19 <Philippa> F for Family, a and b being the in and out types...
17:58:32 <Philippa> someParm's phantom, take it from one of FirstOrder or HigherOrder
17:59:09 <Philippa> we want to allow a FirstOrder >>> FirstOrder :: FirstOrder, and failing that f >>> f :: HigherOrder (excuse the abuse of notation?)
17:59:21 <Philippa> and naturally only ArrowF HigherOrder is ArrowApply
17:59:57 <kc5tja> > 'A' :: Int
17:59:58 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
18:00:05 <kc5tja> > ord('A') :: Int
18:00:07 <lambdabot>  65
18:02:30 <kc5tja> @index ord
18:02:31 <lambdabot> Data.Char
18:05:42 <LoganCapaldo> > fromEnum 'a'
18:05:44 <lambdabot>  97
18:06:17 <LoganCapaldo> > toEnum 97 :: Char
18:06:18 <lambdabot>  'a'
18:06:46 <LoganCapaldo> > chr 97
18:06:48 <lambdabot>  'a'
18:08:17 <Philippa> ddarius: that one make sense?
18:08:52 <Philippa> more generally you want to be able to do any damn thing you feel like with the phantoms though
18:09:06 <ddarius> In so far as I know what mechanism you want (which looks like it's doable albeit abstracting over the pattern looks difficult).
18:09:38 <ddarius> I'm not really sure of the motivation of that particular example, but that's not really important.
18:09:43 <Philippa> so it might not be the case that there's an instance of Arrow for all types
18:10:12 <Philippa> that particular example's useful if you're trying to do static analyses - having ArrowApply means they're not going to terminate
18:10:23 <ddarius> Technically, you don't really get a "family" of arrows, because the types of the operations won't fit the arrow types.
18:10:27 <Philippa> but if you have a means of approximating...
18:10:29 <ddarius> In general.
18:10:57 <Philippa> you do, you also get some additional operations
18:11:33 <Philippa> ...well, I'm assuming that the case where the phantoms match up is always there, I guess
18:11:44 <ddarius> Okay.
18:12:16 <Philippa> er, I made a mistake in the earlier example
18:12:27 <Philippa> shouldn't be two fs. Or at least, use fresh values of f :-)
18:12:39 <ddarius> Actually, I take that back.  It would be a family of categorical arrows I believe.
18:12:43 <Philippa> so that HigherOrder >>> FirstOrder and FirstOrder >>> HigherOrder are legit
18:12:57 <Philippa> right, which is more generally the point
18:12:59 <ddarius> Yes.  The issue is when A >>> A is not.
18:20:50 <Philippa> anyway, do you need to see some use cases?
18:21:03 <Philippa> there're plenty of properties you can track like this, of course
18:21:52 <ddarius> I'm more wondering if there a systematic and clean way to do this, even if it is clean itself.
18:22:42 * LoganCapaldo renames Control.Arrow to Archery
18:26:22 <Philippa> I should probably have a play at doing it in Epigram
18:26:47 <LoganCapaldo> :t (>>>)
18:26:50 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
18:26:51 <troutinator> hello, I'm new to Haskell. I was wondering why this doesn't work: let nor a b = (not . (||)) a b    it gives expected type mismatch error
18:26:51 <Philippa> fitting into a type class isn't really a good place to start from, I should build a few examples first
18:27:26 <LoganCapaldo> :t (not . (||))
18:27:28 <lambdabot>     Couldn't match expected type `Bool'
18:27:29 <lambdabot>            against inferred type `Bool -> Bool'
18:28:00 <ddarius> Philippa: That seems like a good idea.
18:28:00 <LoganCapaldo> :t (not .) . (||)
18:28:03 <lambdabot> Bool -> Bool -> Bool
18:28:17 <Philippa> troutinator: functions all have exactly one parameter, so you can't use . like that to try to take two parms
18:28:21 <Philippa> what LoganCapaldo just wrote'll do
18:28:35 <ddarius> troutinator: Stay away from the crazy excessively point-free code.
18:28:42 <Philippa> but you may as well be either consistently pointless or use the names throughout
18:28:50 <Philippa> as in not (a || b)
18:28:54 <LoganCapaldo> especially if you aren't gonna be point free by including the points nayway :)
18:29:47 <Philippa> I should probably find an opportunity to corner Conor sometime
18:30:19 <troutinator> i think that it should make since,  not(or(a,b))  === (not . or)(a, b)
18:30:42 <troutinator> but like I said, never used Haskell before.
18:30:45 <Philippa> it doesn't, because we're not using tuples
18:30:53 <LoganCapaldo> no tuples for you
18:30:56 <sorear> .
18:31:09 <Philippa> it might be isomorphic, but that doesn't mean you can have the isomorphism magically applied for you without asking fori t
18:31:11 <Philippa> *for it
18:31:11 <troutinator> sorry, don't read that as haskell, but math
18:31:17 <LoganCapaldo> (||) a returns a Bool -> Bool
18:31:23 <Philippa> it still involves tuples when it's read as maths
18:31:29 <Philippa> (a, b) is a pair
18:31:30 <LoganCapaldo> not (Bool -> Bool) maketh no senseth
18:31:36 <troutinator> :t (||)
18:31:39 <lambdabot> Bool -> Bool -> Bool
18:31:59 <troutinator> hmm
18:32:00 <Philippa> Bool -> Bool -> Bool = Bool -> (Bool -> Bool)
18:32:05 <Philippa> all functions in haskell take exactly one parameter
18:32:30 <Philippa> set-theoretic functions usually do, if you want more than one parameter you use a tuple
18:32:44 <Philippa> normally in haskell we do this (which is called 'currying') instead, because it lets us write code like this:
18:32:48 <Philippa> inc = (+) 1
18:32:51 <LoganCapaldo> > let nor = not . (uncurry (||)) $ (a, b)
18:32:52 <lambdabot>  Parse error
18:33:16 <Philippa> write it without the $
18:33:31 <LoganCapaldo> > let nor = not . (uncurry (||)) $ (a, b) in nor True False
18:33:32 <lambdabot>   Not in scope: `b'
18:33:44 <LoganCapaldo> I kepe making lame typose
18:33:50 <Philippa> ah well
18:34:07 <LoganCapaldo> > let nor a b = not . (uncurry (||)) $ (a. b) in nor True False
18:34:09 <lambdabot>  Couldn't match expected type `(Bool, Bool)'
18:34:14 <LoganCapaldo> GAH!
18:34:31 <LoganCapaldo> > let nor a b = not . (uncurry (||)) $ (a, b) in nor True False
18:34:33 <lambdabot>  False
18:34:52 <LoganCapaldo> finally :)
18:35:01 <sorear> Hehe.  How dirty shoudld I feel using tail recursion in C? :)
18:35:05 <Philippa> ddarius: btw, in the presence of a sufficiently powerful type system an arrow family with phantom types starts to smell an awful lot like rolling your own type system
18:35:31 <LoganCapaldo> sorear: How many C compilers do you want it to work on? :)
18:35:36 <Philippa> even more so if you add parameters to the type class that let you constrain input and output
18:35:42 <sorear> Note that Haskell's type system is powerful enough to embed the Calculus of Constructions!
18:35:43 <Philippa> (or behave differently depending on what they are)
18:35:57 <dolio> > let nor = curry $ not . uncurry (||) in nor True False
18:35:59 <lambdabot>  False
18:36:01 <Philippa> sorear: well duh, it's turing complete and it's not as screwy as C++ :-)
18:36:25 <Philippa> the interesting questions are ones like "can I fake substructural typing?"
18:36:29 <LoganCapaldo> dolio: neat
18:36:32 <sorear> LoganCapaldo: all of the good ones!
18:36:45 <troutinator> I thought the function compostition way would be cool, more literal
18:36:55 <sorear> LoganCapaldo: anyway, the recursion depth is usually going to be 5 or so
18:37:02 <LoganCapaldo> sorear: then you can clearer feel as dirty as you want :)
18:37:06 <LoganCapaldo> *clearly
18:37:23 <sorear> LoganCapaldo: and cannot exceed 16383 on Linux
18:37:24 <cdsmith> Phillipa: PMFJI, but Haskell's type checking is Turing complete?  That would imply it doesn't necessarily terminate...
18:37:39 <Philippa> cdsmith: GHC's is with the right flags
18:37:41 <sorear> cdsmith: Correct.
18:38:00 <sorear> cdsmith: Type checking, with the right DWIS flags, need not terminate.
18:38:06 <sorear> cdsmith: what's PMFJI
18:38:14 <cdsmith> "Pardon me for jumping in"
18:38:44 <sorear> Specificially -fallow-undecidable-instances
18:38:49 <ddarius> cdsmith: You need never say that in #haskell.
18:38:55 <sorear> cd
18:38:58 <sorear> cdsmith: vvv
18:39:04 <sorear> @wiki Type_SK
18:39:05 <lambdabot> http://www.haskell.org/haskellwiki/Type_SK
18:39:17 <cdsmith> sorear: Ah, that makes sense, I suppose; by definition, if they are undecidable!
18:39:32 <troutinator> agh GHCi ctrl-c closes it
18:40:06 <troutinator> to used to python :-D
18:40:11 <Philippa> ddarius: so long as you're on-topic, anyway
18:40:27 <sorear> troutinator: known bug with windows ghci
18:40:31 <reitblatt> how exactly is undecidable type-checking a good thing?
18:40:45 <sorear> troutinator: it only happens on one of { cygwinterm, dos box }
18:40:46 <ddarius> Philippa: Well yes.  For example, in a rank-n polymorphic lambda calculus you can embed a rank-(n-1) polymorphic lambda calculus interpreter.
18:40:49 <Philippa> reitblatt: when it lets you typecheck code that you couldn't without it
18:40:55 <cdsmith> reitblatt: I don't know yet, but you gotta admit it's cool.
18:40:57 <sorear> troutinator: so try the other!
18:41:18 <reitblatt> Philippa: have a succinct example?
18:41:37 <sorear> @quote rayt
18:41:38 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
18:41:45 <ddarius> reitblatt: Natural indexed types.
18:41:46 <troutinator> sorear: i think its cygwin
18:41:46 <sorear> drat, noone quoted me.
18:42:05 <sorear> troutinator: just use whichever works.  i don't use windows
18:42:40 <cdsmith> sorear: it's cygwin where Ctrl-C is broken, fyi
18:43:01 <reitblatt> ddarius: sorry, you need to be a little more explicit than that, I don't know what you mean
18:43:11 <troutinator> sorear: i'm multicutural, lol, I have a MacBook, windows box, and linux box
18:43:21 <Philippa> reitblatt: types where one of the parameters is a natural number
18:43:37 <Philippa> suppose you have a type family of arrays where a 1-element array is different to a 2-element array...
18:43:37 <reitblatt> Philippa: ahh, thanks
18:43:56 <reitblatt> interesting
18:44:30 <sorear> You are wandering deep into the territory of dependant types.  Dependant type systems let you say things like 'sort returns a sorted list'
18:45:36 <sorear> The question is how many types to provide.  if you have no annotations, guessing the correct type is unusably slow (and nonterminating on failure).  if you type every binder, like CoC does, type checking is very easy.
18:46:04 <sorear> Most of the fanciness in type systems is striking a balance between these extremes.
18:46:11 <reitblatt> but type checking is decidable w/ type annotations?
18:46:43 <sorear> reitblatt: In the CoC yes.  in haskell's undecidable instance system - I don't think so.
18:47:16 <sorear> decidable algorithms require more type annotations, or put restrictions on what you can express.
18:47:50 <sorear> for instance \fun -> (fun True, fun 'a')   is rejected by Haskell because of the restrictions used to ensure decidability.
18:48:05 <ddarius> sorear: They always put restrictions on what you can express.
18:48:55 <troutinator> here we go: let nor a b = not $ or a b
18:49:08 <sorear> GHC with -fglasgow-exts has a cleverer (but still decidable) algorithm, and you can say ((\ fun -> (fun True, fun 'a')) :: forall b. (forall a. a -> b) -> (b, b))
18:49:17 <sorear> note that that signature is *required*
18:49:25 <sorear> ddarius: beyond simple computability?
18:49:32 * LoganCapaldo sorear just answered the question he was in the middle of typing
18:50:12 <ddarius> sorear: I'm not sure what you are asking.
18:50:14 <Philippa> sorear: either you can't prove termination on your code, or the type system's undecidable, or there're terminating programs you can't write
18:50:39 <Philippa> the first case is Haskell - you've always got _|_
18:50:45 <LoganCapaldo> or all of the above?
18:50:55 <sorear> Philippa: that is true, abstractly.
18:50:56 <Philippa> LoganCapaldo: I don't recall writing xor :-)
18:51:16 <Philippa> it's true in practice, too. You cannot express in haskell that a given piece of haskell code terminates
18:51:31 <sorear> Philippa: but I can have a type system where every program needs a valid termination proof in ZF notation.
18:52:08 <ddarius> sorear: That falls under one or both of the last two cases.
18:52:12 <sorear> Philippa: now every program you can write terminates, and every program you can't write nobody will believe you when you say it terminates because you have no proof
18:52:41 <sorear> ddarius: Right, because of the Incompleteness Theorem - termination could be true but unprovable
18:52:51 <Philippa> sorear: I've given that argument on LtU in the past
18:53:19 <ddarius> sorear: Indeed. I've had similar thought related to that before re people objecting to the Church-Turing thesis.
18:53:26 <Philippa> it's still more than a little tricky when you're getting sufficiently meta
18:53:41 <Philippa> how deep do you want to pile your universes? We always know we can go further...
18:54:24 <Philippa> franka commented in #haskell-blah at one point that omega is probably enough for now, but we might find a use for bigger infinities
18:55:11 * ddarius has seen uses for 3rd order inaccessible cardinals I think.
18:55:12 <Philippa> there's always "write your own typechecker and/or interpreter"
18:55:13 <Adamant> 1,2,3 ... Infinity!
18:55:31 <SamB> Philippa: but who would believe that it worked?
18:55:37 <Pseudonym> A program is type correct if and only if my favourite type checker accepts it.
18:55:43 <SamB> Adamant: you can't count very high, can you?
18:55:54 <Philippa> SamB: exactly, it can't typecheck itself
18:56:01 <ddarius> 1,2,3, ... omega, omega + 1, ... omega^2, ... omega^3, ... omega^omega ...
18:56:13 <Adamant> SamB, that, or I'm quoting a book title. :)
18:56:18 <sorear> ddarius: excuse me, but those are ordinals
18:56:20 <Philippa> (at least, not while proving that it terminates)
18:56:21 <SamB> Adamant: ah.
18:56:32 <SamB> well, editors tend to frown on non-finite titles
18:56:38 <Philippa> one, two, many, lots
18:56:39 <ddarius> sorear: Actually I'm using surreal numbers
18:57:07 <SamB> ddarius: whatever happened to aleph?
18:57:19 <Pseudonym> You could always just put: fix Succ in the title/
18:57:23 <sorear> SamB: aleph is only for cardinals iirc
18:57:23 <ddarius> SamB: I'm not counting cardinals.
18:57:32 <SamB> oh.
18:57:37 <Philippa> Pseudonym: that's only omega though
18:57:49 <Pseudonym> True.
18:57:57 <ddarius> Time to break out the transfinite induction.
18:58:01 <Pegazuz> what is the function "member" defined? or what does it does?
18:58:03 <SamB> > fix succ :: Int
18:58:05 <Pseudonym> You want a least upper bound operator.
18:58:08 <lambdabot>  Exception: <<loop>>
18:58:15 <ddarius> :t elem
18:58:17 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
18:58:19 <sorear> Hmm.
18:58:20 <Adamant> transfinite inductions sounds like a Star Trek technical explaination for something
18:58:24 <Pseudonym> You can express some transfinite numbers greater than omega that way.
18:58:29 <SamB> Adamant: yeah
18:58:32 <ddarius> @index member
18:58:32 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set
18:58:35 <SamB> for the warp drive or something like that
18:58:58 <ddarius> "Break out the transfinite inductor coils!"
18:59:12 <LoganCapaldo> :t member
18:59:15 <lambdabot> Not in scope: `member'
18:59:21 <LoganCapaldo> boo
18:59:28 <LoganCapaldo> :t Data.Set.member
18:59:28 <ddarius> :t Data.Map.member
18:59:31 <lambdabot> forall a. (Ord a) => a -> S.Set a -> Bool
18:59:32 <sorear> ddarius: random musing - is the fact that the class of cardinals has no cardinality, related to Girard's Paradox (you can't have a type of all types in a consistent type theory)
18:59:32 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Bool
19:00:02 <Pegazuz> so, where is it defined?
19:00:07 <Pseudonym> The greatest fixpoint of Succ is... well, it's bigger than omega, that's for sure.
19:00:13 <Pegazuz> is there any built int function to find the first occurence of an element in a list?
19:00:24 <ddarius> :t find
19:00:27 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
19:00:32 <LoganCapaldo> @hoogle a -> [a] -> Maybe Int
19:00:33 <lambdabot> List.elemIndex :: Eq => a -> [a] -> Maybe Int
19:00:33 <lambdabot> Data.List.elemIndex :: Eq a => a -> [a] -> Maybe Int
19:00:34 <sorear> Pegazuz: elemIndex
19:00:40 <ddarius> Yay hoogle.
19:00:40 <Pegazuz> thanks
19:01:12 <ddarius> sorear: Girard's Paradox should more or less be a variation on Russell's.
19:01:24 <LoganCapaldo> I love searching APIs by type. So awesome
19:01:47 <Pegazuz> :t member
19:01:49 <lambdabot> Not in scope: `member'
19:01:53 <sorear> :t elem
19:01:56 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
19:03:02 <LoganCapaldo> @type foldr (:) ys xs
19:03:05 <lambdabot> Not in scope: `ys'
19:03:05 <lambdabot>  
19:03:05 <lambdabot> <interactive>:1:13: Not in scope: `xs'
19:03:10 <sorear> ++
19:03:21 <LoganCapaldo> @type foldr (:) ?xs ?ys
19:03:24 <lambdabot> forall a. (?xs::[a], ?ys::[a]) => [a]
19:03:31 <ddarius> I would not relate it to the fact that the class of cardinals has no cardinality other than to say a proper class is not a set and therefore doesn't have cardinality.  A type is not a type.
19:03:40 <ddarius> Er Type is not a type.
19:04:07 <ddarius> flip (++)
19:04:10 <Philippa> hence sort not being synonymous with type either
19:04:12 <Korollary> @hoogle TimeOfDay -> TimeOfDay -> TimeOfDay
19:04:13 <lambdabot> No matches, try a more general search
19:04:17 <Philippa> which reminds me, I so need to hack around with PTSes sometime
19:04:24 <Korollary> @hoogle TimeOfDay
19:04:25 <lambdabot> No matches found
19:04:31 <ddarius> @where yarrow
19:04:31 <lambdabot> I know nothing about yarrow.
19:04:36 <ddarius> @google Yarrow proof
19:04:41 <lambdabot> http://www.cs.ru.nl/~janz/yarrow/
19:04:41 <lambdabot> Title: Yarrow Home Page
19:04:53 <ddarius> @where+ yarrow http://www.cs.ru.nl/~janz/yarrow/
19:04:53 <lambdabot> Done.
19:05:40 <Korollary> @src timeOfDayToTime
19:05:41 <lambdabot> Source not found. That's something I cannot allow to happen.
19:06:52 <ddarius> blech! Trivial unlabelled transitions.
19:08:41 <clanehin> Is there any example of someone using the type system to represent the free variables in a system?  For example, 2 + 2 might be represented by the type Expression (), while 2 + x might be represented by the type Expression X?  Scalable to an arbitrary set of free variables?
19:08:57 <ddarius> Now to figure out how to output a cyclic data structure easily in finite space.
19:09:14 <ddarius> clanehin: Yes.
19:09:17 <Philippa> clanehin: GHC has an extension that does more or less that IIRC
19:09:31 <sorear> @ty 2 + 2
19:09:34 <lambdabot> forall t. (Num t) => t
19:09:37 <sorear> @ty 2 + ?x
19:09:39 <lambdabot> forall t. (?x::t, Num t) => t
19:09:47 <dons> heh
19:09:49 <tanob> anybody that uses huggs, http://hpaste.org/1617, this code is doing huggs segfault
19:10:15 <ddarius> 1) Hugs 2) Hugs sucks
19:10:17 <sorear> ddarius: I have code which outputs an explicit graph using minimally many output patterns and ML-esque as annotations
19:10:39 <sorear> @botsnack
19:10:39 <lambdabot> :)
19:10:43 <tanob> yes, sorry, hugs :D
19:10:59 <tanob> anybody can confirm this problem?
19:11:09 <tanob> 'cause im going to report it
19:11:37 <sorear> > let expoNatural _ 0 = 1; expoNatural x y = x * (expoNatural x y - 1) in expoNatural 2 2
19:11:39 <lambdabot>  Exception: stack overflow
19:11:49 <sorear> tanob: I think it's known
19:12:04 <sorear> tanob: when you smash the hugs stack, bad things happen
19:12:25 <tanob> hm, but the stack isnt so big for 2**2
19:12:33 <sorear> > let expoNatural _ 0 = 1; expoNatural x y = x * ((expoNatural x y) - 1) in expoNatural 2 2 -- exactly the same code as before, but with parens to clarify how it parses, tanob
19:12:35 <lambdabot>  Exception: stack overflow
19:12:54 <tanob> ahh
19:12:54 <cdsmith> tanob: you;ve got operator precedence wrong.  The function never terminates.
19:12:57 <sorear> so expoNatural 2 2 = 2 * ((expoNatural 2 2) - 1)
19:13:29 <sorear> and no, that does not evaluate to 1 :)
19:13:31 <tanob> haha, ok, thank you so much :)
19:14:02 <sorear> No problem.  the spacing was a dead giveaway :)
19:14:22 <sioraiocht> @type liftM2
19:14:24 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:14:34 <sioraiocht> @type liftM
19:14:36 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
19:14:48 <sorear> tanob: it's still a bug - hugs shouldn't crash
19:14:51 <sorear> tanob: -but-
19:16:11 <ddarius> Hugs sucks
19:16:12 <tanob> yes, but as you said, probably this is already reported
19:16:24 <tanob> was* already reporte
19:17:53 <sorear> tanob: http://hackage.haskell.org/trac/hugs/ticket/37
19:17:56 <lambdabot> Title: #37 (Equal Ints are not equal) - Hugs - Trac
19:18:02 <sorear> look at the last comment before the spam
19:19:42 <sioraiocht> is there a function that returns the type of a variable?
19:19:50 <ddarius> No.
19:19:54 <sioraiocht> boo
19:19:59 <ddarius> There is typeOf I guess.
19:20:07 <sioraiocht> @type typeOf
19:20:09 <lambdabot> forall a. (Typeable a) => a -> TypeRep
19:20:16 <sioraiocht> hrm, okay
19:20:32 <sioraiocht> I'm having a problem with parsec getting from parsing a string to some sort of abstract syntax
19:20:34 <sorear> but typeof is just ($) :)
19:20:41 <sorear> with dictionaries
19:21:42 <tanob> oh god, im using debian sarge, so hugs is version 20050308
19:21:45 <tanob> :P
19:22:08 <sorear> tanob: apt-get install ghc6
19:22:23 <clanehin> Reading over the ghc extensions, I'm not sure that implicit parameters gives me quite what I want, if that's what you were referring to.
19:22:46 <sorear> tanob: everything you've been told about the pain of installing ghc, doesn't apply to binaries
19:23:28 <tanob> understand, im a newbie in functional programming, my teacher said to start with hugs, and later we'll use ghc
19:26:04 <Philippa> ghci makes a good interpreter
19:26:16 <Philippa> it didn't take me long to switch when I first started
19:27:56 <clanehin> ddarius: what example were you thinking of?
19:28:12 <narain> what advantages does hugs have over ghci, if any? (not a rhetorical question)
19:28:20 <ddarius> Encoding environments with GADTs.
19:28:45 <MyCatVerbs> narain: hugs is written in C rather than Haskell, and it's small. This means you can compile it on boxes that don't already have a Haskell compiler installed.
19:28:47 <ddarius> narain: Quicker to build, quicker to load.  That's it.
19:29:36 <tanob> ok, i just upgraded hugs to the Sept2006 version, and now it shows a message about the stack overflow :)
19:29:37 <narain> ah. it fills the niche of lean-and-mean haskell implementations?
19:29:46 <MyCatVerbs> narain: and it doesn't take very long to compile. It's also a bit quicker to start up initially in interactive mode. If you need to install an interpreter from source, hugs is easier, if you can get binaries, though, ghc's higher-firepower.
19:29:49 <ddarius> narain: No.
19:30:00 <clanehin> ddarius: thanks
19:30:10 <MyCatVerbs> narain: however, hugs is actually rather slow (in terms of CPU time) when it runs. So.
19:30:22 <narain> ok, i see
19:30:50 <MyCatVerbs> Unless you're on, say, Slackware on an old computer, you probably want ghc.
19:31:15 <narain> right, i was just curious since i've only ever used ghc
19:31:37 <narain> thanks
19:34:11 <MyCatVerbs> For the sort of toy problems and small inputs you'll be given on a taught course, it doesn't actually matter worth a damn. But y'never know, you might just get completely addicted to Haskell and want to do large things later. ^^
19:34:32 <ddarius> GHC has better error messages.
19:34:51 <ddarius> GHC is better in just about every way.
19:36:48 <MyCatVerbs> ddarius: unless you have a P3-era Celeron running Slackware, jah.
19:37:47 <ddarius> MyCatVerbs: What's Slackware gotta do with it?  I know that GHC was still better on a Pentium 200 Mhz
19:37:48 <LoganCapaldo> Hugs has a cuter name
19:38:13 <MyCatVerbs> Though I've never found a good programming language with bad error messages before. Every C compiler I've tried has been fine, likewise every Haskell implementation, OCaML, mzscheme...
19:38:36 <zamez> ghc binaries are big, which is sometimes inconvenient
19:38:40 <MyCatVerbs> ddarius: no binary package for ghc, so you have to compile it. Worse still, you have to port it then compile it.
19:38:46 <zamez> I mean output binaries
19:38:58 <ddarius> Port it?
19:39:06 <MyCatVerbs> zamez: yyyyes, but that's not really relevant to hugs-versus-ghc, is it now?
19:39:10 <ddarius> And I've compiled on a P2 200 with 64MB of ram.
19:39:12 <zamez> yes
19:39:30 <zbrown> MyCatVerbs: I find Java to be somewhat cryptic at times...
19:39:30 <zbrown> lol
19:39:51 <zbrown> MyCatVerbs: sometimes I think Java is just making up the error messages that it spits out
19:39:55 <MyCatVerbs> zbrown: I said good programming languages. BASIC, Java, Perl need not apply.
19:39:55 <ddarius> zamez: It's not relevant because the output binaries of GHC's interactive mode are the same size as the output binaries of Hugs.
19:40:03 <zbrown> MyCatVerbs: ah, I missed that ;)
19:40:13 <zbrown> MyCatVerbs: perl... icky... who can even read that?
19:40:23 <ddarius> zamez: Further, there are other implementations that are still better than Hugs that are better than GHC in that regard.
19:40:30 <davidL> does there exist an implementation of the Dancing Links (DLX) algorithm in Haskell?
19:41:21 <sorear_> hello.
19:41:30 <sorear> davidL: what's that?
19:41:37 <Pseudonym> Yes there is.
19:41:39 <sorear> narain: hugs doesn't believe in separate parsing.
19:41:43 <Pseudonym> However.
19:41:46 <Pseudonym> It's not very idiomatic.
19:41:48 <Pseudonym> Still...
19:42:08 <MyCatVerbs> zbrown: well. If you work in tiny subsets of the language, it's fine for getting shit done. But the nigh-infinite complexity makes all the error messages damn useless even then.
19:42:09 <davidL> sorear: it's an algorithm that solves Sudoku puzzles and the like
19:42:10 <sorear> narain: it may be wicked fast, but it doesn't matter because it burns 200MB compiling the base library every single time you start it
19:42:24 <sorear> is that the matrix-covers one?
19:42:43 <davidL> Algorithm X?
19:42:46 <Pseudonym> Just a moment, getting the link.
19:42:58 <Pseudonym> http://www.haskell.org/sitewiki/images/d/d8/DancingSudoku.lhs
19:43:12 <davidL> thanks Pseudonym
19:43:22 <Pseudonym> As an exercise, consider how you might implement a work-alike algorithm in more idiomatic Haskell.
19:43:41 <Pseudonym> The nice thing about declarative garbage collected languages is that "undo" should be essentially free.
19:43:48 <narain> sorear: hm. apparently people don't think much of hugs.
19:43:48 <Pseudonym> If you design your data structures well.
19:44:11 <zbrown> MyCatVerbs: I prefer pike or python if I'm gonna use a scripting language
19:44:28 <ddarius> Yay mutually recursive values.
19:44:49 <sorear> ddarius: I have code for printing recursive values
19:45:08 <sorear> ddarius: from an equirecursive type checker I wrote several months ago
19:45:18 <narain> > let x = 0:y; y = 1:x in x
19:45:20 <lambdabot>  [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1...
19:45:42 <narain> do you need special code for printing recursive values?
19:46:00 <LoganCapaldo> Just cyclic ones I imagine
19:46:20 <ddarius> narain: You do if you only want a finite amount of input for cyclic values.
19:46:36 <narain> ah yes, making cycles explicit would be a win
20:00:21 <MyCatVerbs> zbrown: I'm not familiar with pike. I've heard a lot more good than bad about Python, but have never played with it.
20:02:31 <narain> :t (fmap, liftM)
20:02:35 <zbrown> MyCatVerbs: for Pike, think interpreted C, its one of the oldest scripting languages though lesser known and hella fast. If you've heard of Roxen webserver, it was written in Pike. As far as python goes, I think its great. Well suited for most general applications and especially good for writing gui's :)
20:02:37 <lambdabot> forall a b (f :: * -> *) a1 r (m :: * -> *). (Functor f, Monad m) => ((a -> b) -> f a -> f b, (a1 -> r) -> m a1 -> m r)
20:03:28 <MyCatVerbs> zbrown: *blink*
20:03:54 <MyCatVerbs> zbrown: the Hell come I've never heard of it before then? I pretty much constantly read everydamnthing... 
20:04:33 <zbrown> MyCatVerbs: http://pike.ida.liu.se/
20:04:35 <lambdabot> Title: pike.ida.liu.se: Home
20:04:45 <zbrown> MyCatVerbs: not sure why you've never heard of it but its been around forever
20:05:00 <MyCatVerbs> zbrown: did it just get completely eclipsed by Ruby/Python/Perl or something? oO
20:05:06 <zbrown> MyCatVerbs: ya
20:05:17 <zbrown> it never gained much popularity i think because it wasn't very "different"
20:05:30 <zbrown> perl was different because it was ugly, python because it used no braces, ruby because it copied python
20:05:51 <zbrown> no one wants a language thats so similar to C in syntax that they barely have to learn antyhing but a few new api's ;)
20:06:03 <MyCatVerbs> Ohhh, that'd explain it. That and the fact that most of the languages I've looked into as "interesting" are vaguely functional.
20:06:13 <monochrom> how could you copy python and be different?
20:06:21 <zbrown> monochrom: joke ;)
20:06:30 <zbrown> although Ruby does have a complete crap runtime
20:06:36 <zbrown> memory leaks out the butt
20:08:09 <thoughtpolice> 1.9 is a bit of an improvement.
20:08:13 <MyCatVerbs> zbrown: o_O. This actually looks so damn similar to C, I could quite plausibly see myself fouling up by accidentally attempting C-isms like unsafe pointer work.
20:08:28 <thoughtpolice> i want 2.0 to come outsometime, but I might as well be hoping to have perl 6 come out next week, I guess.
20:08:39 <thoughtpolice> *out sometime soon
20:09:48 <zbrown> MyCatVerbs: its very similar. I love that language. It makes life simple when all I need is a script and not a binary ;)
20:10:06 <zbrown> MyCatVerbs: I use it for a lot of the scripts I run on my cluster
20:10:19 <zbrown> well not *my* cluster, but the one I work on
20:10:20 <zbrown> lol
20:10:56 <MyCatVerbs> zbrown: so... does it get rid of C's single greatest source of egrerious brain-damage - totally unpredictable data widths?
20:11:21 <zbrown> MyCatVerbs: mmmm not completely sure on that one, I haven't had any problems of said variety
20:12:58 <sorear> MyCatVerbs: C has totally unpredictable data widths?
20:13:09 <sorear> int is always >=16, long is always >=32
20:13:26 <sorear> if you need more control there is always int32_t, int16_t, int8_t, int64_t
20:13:34 <sorear> and uint and fast and best
20:14:03 <MyCatVerbs> sorear: yes, but they're kinda grubby. =)
20:15:16 <sioraiocht> Array.array (0, 29999) (zip [0..29999] [0,0..]) won't actually zero out the whole array at once, will it?
20:15:53 <narain> > sequence [Nothing, Just 1, Nothing, Just 2]
20:15:57 <sorear> sioraiocht: Yes it will.
20:16:09 <sioraiocht> sorear: why? =(
20:16:10 <sorear> sioraiocht: arrays are strict - that's what allows them to be O(1)
20:16:17 <narain> ?bot
20:16:17 <sioraiocht> boooo, oh well
20:16:18 <sioraiocht> lol
20:16:18 <lambdabot> :)
20:16:34 <dmwit> > "ho hum"
20:16:36 <lambdabot>  "ho hum"
20:17:02 <zbrown> MyCatVerbs: either way I've never run into that problem before. I think as a scripting language it probably has been fixed.
20:17:07 <MyCatVerbs> sorear: and lots of code seems not to use 'em in practice. I'd rather see C have *only* explicitly-sized data types, in three sets: little endian, big endian and unspecified (the latter being defaulted according to your platform's CPU). Then we could throw away C for absolutely every task except for writing device drivers.
20:17:16 <narain> > sequence [Nothing, Just 1, Nothing, Just 2]
20:17:44 <narain> on privmsg lambdabot says "Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString"
20:17:45 <MyCatVerbs> zbrown: I ought to read into it but jah, I'd be amazed if it was relevant. I was just curious, really.
20:19:59 <zbrown> hmmm this aint good
20:20:43 <zbrown> something is not quite right with my system...
20:21:32 <zbrown> eh crap
20:24:27 <MyCatVerbs> zbrown: if that's the cause of it, I'm going to have to instruct you to cease downloading brownware.
20:29:13 <zbrown> MyCatVerbs: the cause was a usermod that took me out of the admin group in ubuntu...
20:29:29 <zbrown> MyCatVerbs: looks like i'll need to break the 'ubuntu law' and set a passwd for root, i forgot ot do it to this new installation
20:29:40 <sorear> what's this 'admin' thing? ;)
20:29:45 <zbrown> ;)
20:29:56 <MyCatVerbs> sorear: UID zero!
20:30:04 * sorear knows his root pw and doesn't need no steenking group membership
20:33:18 <blackdog> i'm having trouble building h4sh - it's complaining that it couldn't find Text.Regex, which is part of regex-compat-0.71, which is hidden
20:33:36 <blackdog> i've tried ghc-pkg expose regex-compat, but it doesn't seem to help
20:33:50 <blackdog> any ideas what could be wrong?
20:34:15 <sorear> yeah, that must be a bug in the package
20:34:32 <sorear> add regex-compat to the .cabal file's build-depends list, and bug john
20:36:05 <dons> s/john/don/
20:36:18 <dons> but yeah, i've not attempted to build h4sh recently
20:36:31 <dons> so likely the regex dep changed
20:36:41 <blackdog> heya don.
20:36:50 <blackdog> yeah, seem to have got past that one now - thanks sorear
20:37:14 <blackdog> hm. now it's complaining that Data.ByteString.Char8 was found in fps-0.8 as well as base...
20:37:55 <blackdog> (finally got annoyed enough with stupid shell scripting munging to want to move some stuff over to h4sh if it's viable...)
20:38:17 <dons> remove the fps dependency
20:38:29 <dons> blackdog: i'd just write haskell programs instead. rather than shell + h4sh
20:38:40 <blackdog> yeah, usually i would
20:38:42 <dons> i pretty much only use h4sh for manual shell stuff, not in scripts
20:38:55 <blackdog> but so often i just want a trivial map
20:39:17 <sorear> dons: was regex-compat split out in the 6.4.2 -> 6.6?
20:39:28 <blackdog> it's just a pain to have to compose one-liners in emacs rather than the command line
20:39:38 <sorear> dons: and sorry, I was confusing h4sh with hsh :)
20:39:41 <dons> sorear: yeah.
20:39:44 <ddarius> ghc -e
20:41:17 <sorear> hmm, a zlib pull froze *again*
20:41:25 <sorear> http://www.haskell.org/
20:42:22 <ddarius> You broke haskell.org again sorear?
20:42:27 <dolio> @yow!
20:42:28 <lambdabot> Sign my PETITION.
20:42:30 <blackdog> ddarius: yeah, there's that. it's nice to be able to stick a function into a unix pipeline
20:42:55 <blackdog> without having to explicitly worry about IO etc
20:58:51 <narain> ?src min
20:58:52 <lambdabot> min x y = if x <= y then x else y
20:58:59 <narain> ?src minimumBy
20:58:59 <lambdabot> Source not found. stty: unknown mode: doofus
20:59:27 <narain> ?src Ord
20:59:28 <lambdabot> class  (Eq a) => Ord a  where
20:59:28 <lambdabot>     compare      :: a -> a -> Ordering
20:59:28 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
20:59:28 <lambdabot>     max, min         :: a -> a -> a
20:59:32 <narain> ?src Ordering
20:59:33 <lambdabot> data Ordering = LT | EQ | GT
21:00:06 <ddarius> @hoogle minimumBy
21:00:06 <lambdabot> List.minimumBy :: (a -> a -> a) -> [a] -> a
21:00:07 <lambdabot> Data.List.minimumBy :: (a -> a -> Ordering) -> [a] -> a
21:06:15 <MyCatVerbs> ???
21:06:28 <narain> ?hoogle pi
21:06:29 <lambdabot> Prelude.pi :: Floating a => a
21:06:29 <lambdabot> Language.Haskell.TH.ClassOpI :: Name -> Type -> Name -> Fixity -> Info
21:06:29 <lambdabot> Data.Map.lookupIndex :: (Monad m, Ord k) => k -> Map k a -> m Int
21:06:32 <MyCatVerbs> How come random people don't abuse the living Hell out of the \ybot?
21:08:58 <bos> when it happens, they get kickbanned.
21:09:12 <MyCatVerbs> Ahhh. Dictatorship.
21:09:14 <MyCatVerbs> I like it. ^^
21:12:08 <sorear> Or, I just do
21:12:11 <sorear> @part #haskell
21:15:04 <dons> hmm?
21:15:15 <dons> ah
21:16:40 * narain was about to ask lambdabot something, but heard the word "kickbanned" and cowered away to use ghci instead
21:18:05 <bos> hardly. one would have to be very persistently annoying and unresponsive to have anyone bother to acquire ops and all that.
21:18:47 <narain> sorry, i should have suffixed ":)" to the end of that :)
21:20:05 <narain> ?index comparing
21:20:05 <lambdabot> bzzt
21:20:13 <narain> ?hoogle comparing
21:20:14 <lambdabot> No matches found
21:20:21 <narain> hmpf.
21:21:13 <narain> ?index minimumBy
21:21:14 <lambdabot> Data.List
21:23:27 <sorear> The consenses here seems to be that you can try again twice, after that you should ask a person.
21:23:51 <sorear> the 'twice' is variable, and increases somewhat the longer the channel has been idle.
21:25:40 <narain> i just start privmsging lambdabot usually
21:26:34 <narain> but since i can't seem to load haskell.org i'll have to ask: what module is  comparing  in?
21:26:47 <sorear> Data.Ord
21:26:53 <narain> ah, thanks
21:27:03 <sorear> 6.6, which is why hoogle can't find it
21:27:24 <narain> is there a way ghci could have helped me find it?
21:28:54 <sorear> find /usr/lib/ghc-6.6/imports/ -name '*.hi' | xargs grep comparing
21:28:57 <sorear> works for me.
21:29:15 <sorear> Binary file /usr/lib/ghc-6.6/imports/Data/Ord.hi matches
21:30:43 <narain> ah. i was hoping for something like :index at the ghci prompt. failing which i would have tried to do something like that grep (but would probably have found my unix-fu lacking)
21:30:51 <narain> thanks sorear
21:31:17 <MyCatVerbs> Hrmn. Is haskell.org down completely?
21:31:24 <MyCatVerbs> I can't get at it either.
21:32:51 <dons> hmm
21:32:54 <narain> > take 10 [0,pi/2..]
21:32:59 <lambdabot>  [0.0,1.5707963267948966,3.141592653589793,4.71238898038469,6.283185307179586...
21:33:32 <narain> ghc refuses to compile [0,pi/2..] in my program though ghci handles it fine
21:33:48 <narain> do i need to add a type signature?
21:33:49 <TSC> What does it say?
21:34:19 <narain> " Could not deduce (Enum a) from the context (RealFloat a) arising from the arithmetic sequence `0, pi / 2 .. ' at Collision.hs:75:48-57"
21:35:08 <kpreid> ghci is more enthusiastic about defaulting
21:35:57 <TSC> Yes, slap on a type
21:36:03 <mauke> works fine here
21:36:11 <mauke> are you using any explicit type annotations?
21:36:23 <narain> mauke: must be interacting badly with my type declarations
21:36:30 <narain> mauke: yes, i am
21:36:39 <mauke> like (RealFloat a) => ...?
21:36:49 <narain> mauke: yes
21:36:56 <mauke> add Enum a :-)
21:37:14 <narain> ?instances RealFloat
21:37:15 <lambdabot> Double, Float
21:37:23 <narain> ?instances Enum
21:37:25 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
21:37:50 <narain> RealFloat doesn't imply Enum?
21:38:43 <TSC> Doesn't seem so
21:38:56 <narain> ...shouldn't it?
21:39:17 <dolio> > succ pi :: Complex Double
21:39:19 <lambdabot>        add an instance declaration for (Enum (Complex Double))
21:39:19 <lambdabot>     In the exp...
21:39:22 <dibblego> what is a good document to refute Chris Okasaki's take on strict/lazy evaluation?
21:39:36 <narain> > succ pi :: Double
21:39:37 <lambdabot>  4.141592653589793
21:39:58 <narain> Complex isn't RealFloat, is it?
21:40:21 <dolio> ?instances-importing Data.Complex RealFloat
21:40:22 <lambdabot> Double, Float
21:40:34 <narain> ?src RealFloat
21:40:35 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
21:40:36 <dolio> I guess not.
21:40:56 <narain> i assumed not because of the "Real" in the name :)
21:42:00 <dolio> :)
21:42:48 <dolio> Anyhow, the only Num I see that requires Enum is Integral.
21:42:51 <plediii> ?docs Control.Monad
21:42:51 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
21:43:14 <narain> so it appears i can't have haskell construct a sequence [0,1,2..] for arbitrary Nums, or even Reals.
21:43:16 <narain> very well
21:43:52 <dolio> It can, as long as you also specify Enum in the context.
21:44:24 <narain> ah yes
21:44:41 <dolio> That's the type in my ghci, in fact.
21:44:59 <dolio> (Enum t, Num t) => [t]
21:46:07 * narain needs to start thinking more broadly than just the reals
21:47:25 <narain> part of my brain wants to insist that every Num should be an Enum, which is clearly incorrect
21:47:53 <Heffalump> did you see me complaining about Float being one last night? :-)
21:48:11 <MyCatVerbs> Float is an Enum? Waaah?
21:48:16 <Heffalump> well, precisely
21:48:23 <Heffalump> as Igloo pointed out, it's so this works:
21:48:23 <narain> haha
21:48:31 <Heffalump> > [1.0 .. 5.0]
21:48:33 <lambdabot>  [1.0,2.0,3.0,4.0,5.0]
21:48:43 <narain> i wasn't here but it sounds like fun
21:49:17 <LeCamarade> @where build
21:49:18 <lambdabot> I know nothing about build.
21:49:27 <LeCamarade> @where netbsd
21:49:28 <lambdabot> I know nothing about netbsd.
21:49:37 <Philippa> yeah, but I'm expecting a may-as-well-be-infinite list from that
21:49:42 <LeCamarade> lambdabot: Why so clueless?
21:49:52 <narain> i guess the problem is that Enum is overloaded for being both enumerable types and sequence-constructable types, and floats are the latter but not the former
21:50:09 <MyCatVerbs> Ohhh yes.
21:50:30 <LeCamarade> Okay, where do I find the instructions to build GHC on NetBSD (any Unix, alright)? I know it should start with Yhc ... right?
21:50:43 <MyCatVerbs> Of course. I like the way that potentially impossible float enumerations are handled.
21:51:06 <narain> > [1.0, 2.0 .. -1.0]
21:51:08 <lambdabot>  []
21:51:20 <narain> > [1.0, 2.0 .. pi]
21:51:22 <lambdabot>  [1.0,2.0,3.0]
21:51:23 <MyCatVerbs> narain: I mean step sizes that won't hit the far target exactly.
21:51:40 <dolio> @src Float enumFromTo
21:51:41 <lambdabot> Source not found. Just what do you think you're doing Dave?
21:51:46 <MyCatVerbs> > [0.7, 1.4 .. 3]
21:51:47 <lambdabot>  [0.7,1.4,2.0999999999999996,2.8]
21:52:06 <MyCatVerbs> Wow, um, three cheers for needless precision.
21:52:17 <narain> :D
21:52:37 <pjd_> MyCatVerbs: decimal approximation, rather
21:52:54 <MyCatVerbs> pjd_: jah, my bad.
21:53:51 <pjd_> in fact, binary rounding, rather :)
21:53:51 <Heffalump> > fromEnum 0.7
21:53:53 <lambdabot>  0
21:54:15 <Heffalump> > enumFromThenTo 0.7 1.4 3
21:54:16 <lambdabot>  [0.7,1.4,2.0999999999999996,2.8]
21:54:20 <Heffalump> ick.
21:55:01 <narain> to paraphrase winston churchill, IEEE floats are the worst machine approximations of real arithmetic except for all the others that have been tried
21:57:35 <MyCatVerbs> narain: I love them so much.
21:57:57 <dons> > 1.1 + 2.2
21:57:59 <lambdabot>  3.3000000000000003
21:58:17 <Heffalump> > 1.1
21:58:19 <lambdabot>  1.1
21:58:27 <Heffalump> > 3.3
21:58:29 <lambdabot>  3.3
21:58:33 * Heffalump looks confused
21:59:06 <Pseudonym> > 2.2 - 1.1 - 1.1
21:59:07 <lambdabot>  0.0
21:59:10 <MyCatVerbs> What kind of box is lambdabot running on, out of curiosity?
21:59:15 <Pseudonym> > 3.3 - 2.2 - 1.1
21:59:15 <MyCatVerbs> (er, please?)
21:59:17 <lambdabot>  -4.440892098500626e-16
21:59:40 <MyCatVerbs> Heffalump: floating point gets really shitty down in the bottom bit or two of precision.
21:59:53 <dons> ?version
21:59:53 <lambdabot> lambdabot 4p517, GHC 6.6 (Linux i686 2.66GHz)
21:59:53 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
21:59:55 <Heffalump> presumably 3.3 isn't actually exactly represented, so how come it prints out as 3.3?
22:00:25 <MyCatVerbs> Good question. I don't know.
22:00:32 <MyCatVerbs> > (id 3.3)
22:00:33 <lambdabot>  3.3
22:00:44 <MyCatVerbs> Well, it doesn't look like it's cheating. 
22:00:51 <Heffalump> > 3.3 - 2.2
22:00:55 <lambdabot>  1.0999999999999996
22:01:17 <Pseudonym> > 3.3 - 2
22:01:21 <lambdabot>  1.2999999999999998
22:01:33 <Pseudonym> 2 is exactly represented.
22:02:04 <MyCatVerbs> Heffalump: perhaps it prints to 2sd if it's accurate down through all fifty-ish bits of precision, but to 14sd otherwise?
22:03:09 <MyCatVerbs> Does ghci get compiled with -ffast-math by default? x86 floating point is supposed to be something silly like 80 bits internally after all, in order to fake perfect-ish accuracy. 
22:03:09 <Pseudonym> > showGFloat (Just 10) 3.3
22:03:11 <lambdabot>  <[Char] -> [Char]>
22:03:14 <Pseudonym> > showGFloat (Just 10) 3.3 ""
22:03:16 <lambdabot>  "3.3000000000"
22:03:22 <Pseudonym> > showGFloat (Just 15) 3.3 ""
22:03:26 <lambdabot>  "3.300000000000000"
22:03:27 <Pseudonym> > showGFloat (Just 20) 3.3 ""
22:03:29 <lambdabot>  "3.30000000000000000000"
22:03:34 <Pseudonym> > showGFloat (Just 50) 3.3 ""
22:03:36 <lambdabot>  "3.30000000000000000000000000000000000000000000000000"
22:03:38 <Pseudonym> Grm.
22:03:41 <Pseudonym> Hrm, too.
22:03:44 <MyCatVerbs> That's interesting.
22:03:48 <Pseudonym> > showEFloat (Just 50) 3.3 ""
22:03:50 <lambdabot>  "3.30000000000000000000000000000000000000000000000000e0"
22:04:04 <Pseudonym> > floatToDigits 50 3.3
22:04:08 <lambdabot>  ([3,15],1)
22:04:21 <Pseudonym> > floatToDigits 10 3.3
22:04:23 <lambdabot>  ([3,3],1)
22:05:03 <Heffalump> > decodeFloat (3.3 :: Float)
22:05:05 <lambdabot>  (13841203,-22)
22:05:05 <Pseudonym> > 1.2999999999999998 + 2
22:05:07 <lambdabot>  3.3
22:05:15 <Pseudonym> OK, it's to do with the precision of printing.
22:06:14 <Heffalump> > decodeFloat (3.3 :: Double)
22:06:18 <lambdabot>  (7430939385161318,-51)
22:08:06 <Heffalump> > (\x -> fst (decodeFloat (x :: Double)) `divMod` fst (decodeFloat (x :: Float))) 3.3
22:08:07 <lambdabot>  Couldn't match expected type `Float' against inferred type `Double'
22:08:18 <Heffalump> > (\(x :: Num a => a) -> fst (decodeFloat (x :: Double)) `divMod` fst (decodeFloat (x :: Float))) 3.3
22:08:19 <lambdabot>  Parse error in pattern
22:08:33 <Heffalump> > let x = 3.3 in fst (decodeFloat (x :: Double)) `divMod` fst (decodeFloat (x :: Float))) 3.3
22:08:34 <lambdabot>  Parse error
22:09:35 <sorear> My (C) program is about two hundred time faster than I thought it would be, so all the functions I said "this doesn't matter, it will only happy 100 counts/s" need to be reexamined ....  optimization is so fun :)
22:10:19 <Heffalump> > fst (decodeFloat (3.3 :: Double)) `divMod` fst (decodeFloat (3.3 :: Float))
22:10:21 <lambdabot>  (536870919,10485761)
22:10:27 * Heffalump gives up trying to make 3.3 a parameter :-)
22:10:36 <Heffalump> > fst (decodeFloat (4 :: Double)) `divMod` fst (decodeFloat (4 :: Float))
22:10:38 <lambdabot>  (536870912,0)
22:11:03 <mauke> > let x = 3.3 in fst (decodeFloat (x :: Double)) `divMod` fst (decodeFloat (x :: Float))
22:11:04 <lambdabot>  Couldn't match expected type `Float' against inferred type `Double'
22:11:10 <Heffalump> I tried that too
22:11:19 <MyCatVerbs> It's tempting to write something like "let free=(\x->x++(free x)) in free \"b0rk! \""
22:11:22 <Heffalump> I tried several things by msgs before I gave up
22:11:26 <mauke> > let x :: Fractional a => a; x = 3.3 in fst (decodeFloat (x :: Double)) `divMod` fst (decodeFloat (x :: Float))
22:11:28 <lambdabot>  (536870919,10485761)
22:11:35 <Heffalump> oh, duh
22:11:45 <Heffalump> separate lines, not let ... in
22:12:11 <Heffalump> :t decodeFloat
22:12:13 <lambdabot> forall a. (RealFloat a) => a -> (Integer, Int)
22:12:22 <Heffalump> we both got the typeclass wrong, though :-)
22:16:11 <mauke> :t 3.3
22:16:14 <lambdabot> forall t. (Fractional t) => t
22:20:22 <Heffalump> ah, ok
22:26:34 <bos> @pl \(p, s) -> (s, (p, s))
22:26:35 <lambdabot> uncurry (ap (,) . (,))
22:41:38 <bos> @pl \f a b -> a >>= \a' -> return (f a' b)
22:41:38 <lambdabot> flip ((.) . (>>=)) . ((return .) .) . flip
22:42:25 <sorear> @ty flip . fmap fmap . flip
22:42:28 <lambdabot> forall (f :: * -> *) a b c. (Functor f) => (a -> b -> c) -> f a -> b -> f c
22:42:49 <sorear> bos: there's your function, nice and symmetric-y
22:43:49 <bos> yeah, but still more of a brainwrecker than my definition :-(
22:44:09 <dmwit> ?pl \f a b -> liftM (f b) a
22:44:10 <lambdabot> flip . (fmap .)
22:44:13 <dmwit> ?pl \f a b -> liftM (flip f b) a
22:44:14 <lambdabot> flip . (fmap .) . flip
22:44:29 <sorear> (x .) === fmap x
22:44:34 <sorear> in (->) functor
22:44:41 <dmwit> cute
22:44:54 <taruti> Is the haskell.org http server down?
22:44:58 <sorear> yes
22:45:01 <sorear> fmap subsumes (.)
22:45:30 <sorear> ... and map ... and second
22:45:42 <dmwit> fmap subsumes *second* ?
22:45:44 <dmwit> :t second
22:45:47 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
22:46:09 <sorear> well, fmap :: (b->c) -> (a,b) -> (a,c)
22:46:21 <sorear> which is 95% of what people use second for
22:46:42 <sorear> night all.
22:48:40 <cedricshock> Why does the following yield "Not in scope: `+'"? + shouldn'
22:49:00 <cedricshock> t exist yet; I'm saying what it's going to be.
22:49:18 <cedricshock> class AdditiveAbelianGroup g where
22:49:18 <cedricshock> (+)	:: g -> g -> g
22:50:30 <mauke> missing indentation?
22:50:37 <cedricshock> I found it, it needs spaces.
22:50:40 <cedricshock> Yep, thanks.
22:51:42 <cedricshock> I can't have two symbols (functions) with the same name but different types?
22:52:23 <mauke> right
22:52:53 <cedricshock> Is that a consequence of the type inference system?
22:53:15 <mauke> it's a consequence of sanity :-)
22:54:02 <jre2> is www.haskell.org down?
22:54:14 <Pseudonym> I had trouble with it not long ago.
22:54:38 <cedricshock> jre2: It appears so from here.
22:54:53 <jre2> oh, just got the page to load, took quite awhile though and timed out my first try
22:55:24 <thoughtpolice> jre2: yeah it just seems to be taking some time
22:56:03 <dons> jre2: seems so :(
22:56:09 <dons> bot spiders or dos again.
22:57:13 <cedricshock> mauke: So I'm going to need to make up all sorts of funky symbols for multiplication, and if I use .* and *. for left and right scalars I'm going to need even more new ones for application of a linear transformation.
23:01:15 <Philippa> cedricshock: no
23:01:30 <MyCatVerbs> ...? What kind of sad person would bother to DOS haskell.org?
23:02:10 <jre2> MyCatVerbs: ocaml supremists?
23:02:15 <MyCatVerbs> I could understand, say, www.planetofthesmuglispweenies.com, but haskell.org?
23:02:20 <Philippa> cedricshock: although you might decide once you've played around with the various extensions to the class system that you'd rather do so anyway
23:02:32 <MyCatVerbs> jre2: I didn't think the community actually -had- any animosities. o_O
23:03:51 <cedricshock> Philippa: Can you tell me more? What are these "various extensions"?
23:03:53 <bos> does anyone other than ndm use hugs for real work?
23:04:12 <Philippa> cedricshock: multi-parameter type classes plus functional dependencies can go a long way
23:04:30 <bos> ...towards causing insanity :-)
23:04:48 <dolio> You can certainly mimic C++-style overloading.
23:05:05 <dolio> class Additive a b c | a b -> c where (+) :: a -> b -> c
23:05:18 <cedricshock> Philippa: Multi-parameter type classes are what's causing  me pain (eventuially)
23:06:05 <dcoutts> seems to me that 218.61.148.111 is DoSing the haskell wiki
23:06:12 <dcoutts> though not necessarily on purpose
23:06:30 <emu> chinese IP
23:07:00 <cedricshock> dolio: I thouht of that, and It's just plain stupid (not as in an idea or clever hack, but in the need to do it). It's the same as being able to have symbols with more than one type-specific meaning (I think). I wasn't sure if the compiler would be able to sort that sort of thing out.
23:07:34 <emu> it's a communist invasion of haskell.org
23:08:07 <emu> red china has reared its head and begun to attack our vital resources
23:08:51 <dcoutts> but the server is not cpu-overloaded
23:09:02 <dcoutts> it's at about 10% cpu load
23:09:16 <dcoutts> and not all 150 httpd child processes are being used
23:09:27 <dcoutts> only 50 in fact
23:09:44 <emu> 51
23:09:50 <Pseudonym> What are they hitting?
23:09:52 <dcoutts> and I can get through to the haskell.org frontpage
23:10:06 <Pseudonym> Are they actually trying to post, or just DoS?
23:10:24 <emu> spammer perhaps
23:10:26 <dcoutts> Pseudonym: in the past I've noticed bots hitting the wiki and getting lots of arbitrary diffs between page versions
23:10:32 <dolio> Wow, apparently my code was so bad I got kicked off the network.
23:10:33 <vagif> Hello, anyone used hdbc ?
23:10:36 <Pseudonym> Weird.
23:10:38 <dcoutts> emu: no, I think just a web spider
23:10:39 <vagif> how to start ?
23:11:03 <vagif> a small sample would be appreciated
23:11:10 <cedricshock> dolio: I guess so. Here's what I had to say about it:  I thouht of that, and It's just plain stupid (not as in an idea or clever hack, but in the need to do it). It's the same as being able to have symbols with more than one type-specific meaning (I think). I wasn't sure if the compiler would be able to sort that sort of thing out.
23:14:39 <dolio> cedricshock: Wouldn't you need to do essentially the same thing in C++ to add all different types with the same operator? You'd still need to define it for each case.
23:15:38 <dolio> cedricshock: The difference in haskell is that the type signatures will become terrible, with tons of constraints. But that's because haskell's type system doesn't just sweep that under the rug, I guess.
23:16:29 <emu> yay inference
23:16:52 <cedricshock> dolio: Yeah, It just seems weird to need to inherit having the operator rather than saying what it is. Actually it's still not a complete solution. I don't think I could do, for example, the same symbol for both left and right scalar multiplication of a vector (not that there's any difference).
23:17:32 <dolio> cedricshock: For that last case, you'd declare instances like...
23:18:03 <dolio> cedricshock: 'instance Multiplicative Scalar Vector Vector where ...' 'instance Multiplicative Vector Scalar Vector where ...'
23:19:33 <cedricshock> Whoa, cowboy! Now we're hitting a cartesian product in the code. There's got to be a better way (and the better way is many well defined symbols for /meaning/ and a user interface solution for accessing them).
23:21:00 <emu> TH?
23:21:17 <dolio> :) Well, you could make another class for commutative operators, and then use it to declare instances for the non-commutative classes.
23:21:30 <dolio> But that'd require overlapping instances and such, probably.
23:22:41 <dolio> But, doing something like this is highly ugly in Haskell.
23:22:44 <cedricshock> This is actually a huge advantage in disguise. When I read descriptions of linear algebra algorithms or methods the first thing I have to do is sit down and figure out whats a scalar, vector, or matrix by following them through the paper from the first type establishing use. I wouldn't need to if it was written "scale the vector p_k by Beta"
23:22:50 <sproingie> @hoogle s -> (s,a)
23:22:54 <lambdabot> Control.Monad.RWS.execRWS :: RWS r w s a -> r -> s -> (s, w)
23:22:55 <lambdabot> Control.Monad.RWS.evalRWS :: RWS r w s a -> r -> s -> (a, w)
23:23:39 <sproingie> somehow i expected more
23:24:13 <sproingie> oh doh.  backward
23:24:21 <sproingie> @hoogle s -> (a,s)
23:24:22 <lambdabot> Control.Monad.RWS.evalRWS :: RWS r w s a -> r -> s -> (a, w)
23:24:23 <lambdabot> Control.Monad.RWS.execRWS :: RWS r w s a -> r -> s -> (s, w)
23:25:16 <dolio> But, perhaps that's just due to the theoretical ugliness of ad-hoc overloading itself. Typeclasses let you get a lot of the benefit while looking pretty nice, as long as you constrain yourself somewhat.
23:25:21 <sproingie> @hoogle g -> (a,g)
23:25:22 <lambdabot> Control.Monad.RWS.evalRWS :: RWS r w s a -> r -> s -> (a, w)
23:25:23 <lambdabot> Control.Monad.RWS.execRWS :: RWS r w s a -> r -> s -> (s, w)
23:25:25 <mauke> :t (,) undefined
23:25:28 <lambdabot> forall a b. b -> (a, b)
23:25:28 <sproingie> oh well
23:25:34 <dolio> Or, maybe there's a nice theoretical way to do it that no one's come up with yet. Who knows?
23:27:57 <cedricshock> dolio: It's really a problem of presentation. How do you communicate something both precisely, densely enough that the idea can be seen all together in one place, and still have enough information to be readily understood. What I really want to do is query the grad thesis I'm reading and ask it what on earth that symbol A is, in type, and dimension, and perhaps with an example.
23:29:55 <dolio> cedricshock: Actually, I was talking about how ugly it is to fully overload all the operators in Haskell.
23:29:55 <cedricshock> haskell is a fairly good language to express the knowledge in, but as text on the screen may not be optimal for every sort of presentation of the knowledge, which is more than you can ask of any language.
23:30:38 <dolio> Although I could see such papers being confusing. Although, they usually have type face conventions for different types of variables, don't they?
23:30:54 <dolio> That might not tell you everything, though.
23:32:57 <ddarius> @where tmr
23:32:58 <lambdabot> http://www.haskell.org/haskellwiki/TheMonadReader
23:34:16 <cedricshock> Yeah, vectors and scalars are both lower case Latin letters. And sometimes the dimension of a vector is only interesting in one direction, and the algorithm can be parallelized ifthe vector is a collection of vectors of the same size that can be represented as a matrix, so sometimes there are matrices with lower case latin letters, or vectors with uppercase ones. And vector spaces also get uppercase Latin letters, so at the end of t
23:34:16 <cedricshock> he day you're pretty much on your own.
23:34:53 <dolio> Heh.
23:38:59 <foxy-om> dcoutts: That patch didn't help :(
23:39:08 <dcoutts> foxy-om: aaarg!
23:39:10 <dcoutts> :-)
23:39:14 <dcoutts> ok, so what's wrong?
23:39:26 <dcoutts> does it partially fix anything or do nothing at all?
23:39:59 <foxy-om> well, doing show (header ++ ....) where header is a string doesn't do any file separator magic?
23:40:06 <foxy-om> doesn't fix anything
23:40:42 <dolio> cedricshock: It would be cute if there were more operators to choose from, say from unicode.
23:40:53 <mauke> yes!
23:40:54 <foxy-om> I think the construction of header needs to be fixed, the backslashes aren't getting backslashed there
23:41:14 <dolio> cedricshock: A lot of the good ones tend to get snatched up, so you end up with stuff like f <$> a <*> b ...
23:41:42 <dolio> I was playing around with scim the other day seeing what unicode haskell would look like.
23:43:17 <DRMacIver> Morning
23:43:21 <Pseudonym> And how does it look?
23:43:23 <dolio> You could do: fmap :: Functor ? ? (? ? ? ) ? ? ? ? ? ?
23:43:36 <foxy-om> dcoutts: Does the path of the header file need to be put in the .hs source file, since it's location should be found through -I* command line args
23:43:39 <dolio> Of course, that takes like 10 times as long to type as normal.
23:43:51 <mauke> fmap :: Functor ? ? (? ? ? ) ? ? ? ? ? ?
23:44:05 <dcoutts> foxy-om: the path relative to the -I search path has to be there, yes.
23:44:09 <dolio> Heh. Guess you're not unicode aware. :)
23:44:21 <mauke> I am
23:44:24 <mauke> what encoding are you using?
23:44:30 <dolio> No idea.
23:44:50 <Pseudonym> fmap :: Functor ? ? (? ? ? ) ? ? ? ? ? ?
23:44:50 <mauke> a-umlaut: , euro: 
23:44:55 <Pseudonym> Weird.
23:44:57 <dcoutts> foxy-om: so for example cabal will pass -I dist/build to ghc, so the path of the .chs.h file in the .hs file needs to be relative to dist/build
23:45:13 <foxy-om> ah, ok
23:45:31 <dcoutts> > "foo\\bar"
23:45:33 <lambdabot>  "foo\\bar"
23:45:53 <dcoutts> > show ("foo\\bar.h" ++ "baz")
23:45:54 <lambdabot>  "\"foo\\\\bar.hbaz\""
23:45:59 <foxy-om> > show "foo\bar"
23:46:00 <lambdabot>  "\"foo\\bar\""
23:46:36 <dcoutts> foxy-om: you see, show does escape chars correctly
23:46:44 <foxy-om> yeah, it does
23:47:14 <foxy-om> @paste
23:47:15 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:47:28 <dcoutts> foxy-om: so what was the output for the foreign import decl when using that patch?
23:47:41 <dolio> ? <-- Does this look like a lambda?
23:47:49 * foxy-om falls over
23:47:52 <mauke> no
23:47:58 <dcoutts> dolio: it looks like a '?' char.
23:48:05 <foxy-om> dcoutts, I applied the patch, and rebuilt, but I didn't install
23:48:07 <dolio> I guess I'm messed up, then. :)
23:48:17 <dcoutts> foxy-om: oh :-)
23:48:32 <dolio> It looks pretty here. You'll just have to take my word for it.
23:48:37 <dcoutts> foxy-om: well that's a good thing! :-) we don't know if it's broken yet then
23:48:44 <mauke> U+03BB (0xce 0xbb): GREEK SMALL LETTER LAMDA []
23:48:54 <dcoutts> dolio: you should use a utf8 irc client
23:49:52 <dcoutts> dolio: then we'd see:  x. x+1
23:49:52 <foxy-om> dcoutts, ok that problem is fixed
23:49:52 <dcoutts> foxy-om: yay
23:49:52 <foxy-om> :)
23:52:43 <hpaste>  foxy-om pasted "new c2hs problem" at http://hpaste.org/1618
23:52:44 <dcoutts> heh
23:52:44 <foxy-om> doesn't find the file
23:52:44 <dcoutts> foxy-om: that should be fixed by the other cabal+c2hs patches I made recently
23:52:44 <foxy-om> hm, I'll repull and so on...
23:52:44 <dcoutts> foxy-om: the cabal patches were sent to the cabal mailing list for review, they've not been applied yet
23:52:44 <foxy-om> ah
23:52:44 <dcoutts> but you can apply the patches locally yourself, using darcs apply blah.patch
23:52:44 <foxy-om> where do I find the patches?
23:52:50 <dcoutts> the cabal-devel mailing list archive
23:53:25 <dolio> x. x+1
23:54:18 <dolio> > 11*16 + 11
23:54:20 <lambdabot>  187
23:56:59 <bos> what would be a nice haskelly name for fnmatch? matchFileName?
23:57:23 <mauke> what, both nice and haskelly?!
23:57:27 <foxy-om> U+03BB
23:58:07 <bos> well, you've got me there.
23:58:15 <foxy-om> dcoutts: It doesn't look like you sent the cabal patch
23:58:46 <dcoutts> foxy-om: "darcs patch: Put pre-processed source into the dist/b... (and 2 more" sent on Sun, 22 Apr 2007
23:59:35 <MyCatVerbs> > (*) ((*) 26 26) 26
23:59:37 <lambdabot>  17576
23:59:53 <mauke> > 26^3
23:59:55 <lambdabot>  17576
