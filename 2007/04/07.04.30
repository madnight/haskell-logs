00:01:04 <MyCatVerbs> mauke: I like Scheme, okay? Don't judge me! ;)
00:01:18 <mauke> > product [26, 26, 26]
00:01:20 <lambdabot>  17576
00:03:27 <joelr1> good morning
00:04:06 <MyCatVerbs> HERESY!
00:04:26 * MyCatVerbs pokes joelr1 with a contradiction in terms.
00:04:54 <joelr1> MyCatVerbs: wha?
00:04:59 <joelr1> :-)
00:05:02 <mauke> an oxymoron
00:35:21 <joelr1> how do you add a module loading path from within ghci?
00:37:22 <dcoutts> joelr1: try :set -iblah
00:37:44 <dcoutts> joelr1: generally most command line flags can be set in ghc using :set
00:44:01 <hpaste>  foxy-om annotated "new c2hs problem" with "with newest patches" at http://hpaste.org/1618#a1
00:44:23 <foxy-om> dcoutts: ^^
00:47:46 <foxy-om> I think the problem could be the direction of the backslash in -I..\include *shrug*
00:55:26 <dcoutts> foxy-om: you can use -d trace to find out exactly how c2hs is invoking cpp
01:20:55 <DRMacIver> Hm. Yesterday's "Why SML is so much better than Haskell" (kidding, kidding, don't kill me) conversation made me want to go back and play with SML again. I've just noticed that MLTon hasn't done a public release since 2005, even though there's clearly ongoing work on it. I wonder why that is.
01:21:19 <Wild_Cat> why SML and not Ocaml?
01:21:48 <Wild_Cat> (isn't the latter more actively developed and used?)
01:23:33 <DRMacIver> I've yet to see any compelling reasons to use OCaml in favour of SML.
01:23:49 <dons> SML and OCaml are like old, 1980s versions of Haskell.
01:23:54 <dons> Oh wait, that's exactly what they are :-)
01:24:11 <Wild_Cat> I had a look at Ocaml a couple months ago, and that's the impression I got, yeah.
01:24:24 <DRMacIver> dons: Bollocks to that. :-p They need updating, sure, but they're fundamentally different in intent and useage.
01:24:26 <vegai> SML is so much better than Haskell? Let me guess, Smerdyakov was here? :)
01:24:33 <DRMacIver> vegai: No, I was here. :)
01:24:37 <Wild_Cat> they seem to run fast, but I was put off by the complete lack of runtime type safety. That just screams "exploit" to me.
01:24:57 <dons> Wild_Cat: hmm? that's what static typing is for.
01:25:00 <DRMacIver> I wasn't actually arguing that SML was better than Haskell. Just that it had several major syntactic advantages.
01:25:18 <dons> syntax? really? that's not often argued for.
01:25:29 <norpan> gah sml syntax is horrible
01:25:33 <quicksilver> Funnilly enough, the main reason I prefer haskell is its syntax :)
01:25:36 <DRMacIver> And that it would be nice to have both.
01:25:38 <quicksilver> more important than laziness :)
01:25:42 <Wild_Cat> dons: In Ocaml at least, (static and inferred) typing only exists at compile-time. Programs run with all the safeties off.
01:25:45 <dons> expressivity of modules is pretty easy to argue for, but syntax, hmm, don't think I've hard that before.
01:25:47 <quicksilver> (not really, but that was how I was introduced)
01:26:03 <DRMacIver> dons: I'm known for holding controversial opinions. :)
01:26:04 <quicksilver> Wild_Cat: that's almost the whole point, though
01:26:06 <Wild_Cat> meaning you can probably exploit IO/deserialization to do Bad Stuff to running programs.
01:26:07 <norpan> Wild_Cat: yeah, but static typing guarantees that no run-time type errors occur
01:26:10 <dons> Wild_Cat: right. that's the point of strong static typing though: the type system gave you a proof that it won't go wrong.
01:26:13 <norpan> so why check for them?
01:26:47 <quicksilver> Wild_Cat: in haskell types are mostly erased, too
01:27:09 <DRMacIver> dons: It's primarily the infix question which I was arguing that ML does better, but it was also pointed out that ML's ability to be parsed in a single pass is what enables its interpreters to be so much better than Haskell's.
01:27:15 <dons> Wild_Cat: you thinking of the -funsafe flag to the ocaml compiler that turns off bounds checking exceptoins?
01:28:20 <Cheery> @hoogle IOTask
01:28:21 <lambdabot> No matches found
01:28:23 <DRMacIver> (Granted there are some major downsides to the single pass parsing - difficulty in defining mutually recursive functions for example)
01:28:40 <Wild_Cat> dons: I think, yeah.
01:28:51 <dons> Wild_Cat: that's unrelated to the type system though.
01:29:08 <dons> that's just a (nasty) optimisation for scary people :-) -funsafe
01:29:28 <norpan> it's both -fun and safe :)
01:29:34 <DRMacIver> OCaml: Putting the fun back in funsafe.
01:29:40 <Wild_Cat> I have to admit I didn't get very far in learning Ocaml, so I'm fuzzy on the specifics. I ran out of time, and didn't think it'd be better than continuing to learn Haskell (which, you may have guessed, I'm doing ATM).
01:29:53 <norpan> good for you
01:30:38 <DRMacIver> Actually, part of the reason I was wanting to get back into ML is that I was wondering how hard it would be to update it to include things like type classes.
01:30:54 <DRMacIver> Well, 'update'
01:31:00 <DRMacIver> Create an ML-like with type classes. :)
01:31:18 <DRMacIver> It seems that they constitute an awfully large proportion of Haskell's advantages.
01:31:48 <norpan> type classes are nice
01:32:13 <Baughn> How do type classes differ from java-style interfaces?
01:32:17 <DRMacIver> And ultimately they shouldn't be that hard to implement in an ML targetted compiler.
01:33:54 <Cheery> here are some guys who have used yampa, do you know how the reactimate should be filled?
01:34:00 <DRMacIver> Baughn: The obvious differences are that they're a lot more flexible in where the type parameters can go in the required functions and that they're not a type - If Foo is a type class you can't have a list of Foo, you can only have a List of a for some Foo => a.
01:34:39 <DRMacIver> Baughn: But really they're not very similar at all. :) They have a superficial similarity in purpose, and there's a core subset of tasks you can do with both, but they don't really do the same things.
01:35:36 <Baughn> DRMacIver: I'm familiar with the multiple dispatch thing from CL. Them not being a type.. is also true in Java, though it pretends otherwise (and ruins the functionality in the progress)
01:35:50 <Baughn> DRMacIver: Guess I'm just looking for something haskell does that *no* other language does
01:36:07 <Wild_Cat> Baughn: lazy evaluation.
01:36:12 <DRMacIver> Baughn: No, it's the other way around. In Java they are a type. It's confusing classes and types that Java gets wrong.
01:36:18 <Baughn> Wild_Cat: ..related to typeclasses
01:36:31 <DRMacIver> Uh, not really.
01:37:04 <DRMacIver> Having type classes strongly helps with purity which strongly helps with lazy evaluation, but neither is neccessary or sufficient for the other.
01:37:42 <DRMacIver> There's not much that Haskell has that *no* other language has, as it's basically an updated Miranda clone. :)
01:37:44 <foxy-om> dcoutts: how do I get -d trace through cabal to c2hs?
01:37:53 <joelr1> hehe
01:37:56 <Baughn> I've never used Miranda, though. :P
01:38:00 <joelr1> the haskell vs sml debate again
01:38:11 <dcoutts> foxy-om: you can't but you can see how cabal calls c2hs, so just call that manually and pass extra args
01:38:27 <DRMacIver> joelr1: Not really.
01:38:37 <plediii> ?docs Control.Monad
01:38:38 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
01:39:57 <DRMacIver> Baughn: Short version. Haskell combines type classes, purity and lazy evaluation to give really good support for monadic constructs. This is very unusual, and while other languages have support for subsets of these features (list comprehensions in e.g. Python or Scala, continuations, exceptions, etc.) this provides it with a lot of power that's very hard to find elsewhere.
01:40:36 <DRMacIver> Baughn: Individually nothing of this is Haskell specific. The power comes from the flexibility that the combination allows and the insane creativity with which the Haskell community gleefully (ab)uses it. :)
01:40:43 <joelr1> ocaml has camlp4!
01:41:49 <dons> in particular, i'd argue that purity + parametric polymorphic static typing are critical
01:42:08 <Cheery> Does haskell have some intermediate form which would be smaller than pure source code but could be type-checked?
01:42:13 <dolio> dons: Did you see "Haskell for Math?"
01:42:27 <dons> dolio: hmm, possibly
01:42:31 <DRMacIver> Argh. I meant to arrive at work early today.
01:42:32 * DRMacIver goes
01:42:38 <dcoutts> dons: critical I tell you! it's critical! :-)
01:42:38 <dons> Cheery: the Core form, which all Haskell is translated to
01:42:38 <dolio> dons: "Ask Reddit"
01:42:51 <dons> dcoutts: right!!
01:42:59 <hpaste>  foxy-om annotated "new c2hs problem" with "c2hs isn't very helpful" at http://hpaste.org/1618#a2
01:43:02 <foxy-om> dcoutts: ^^
01:43:05 <dons> if we lose purity, ITS ALL OVER!!
01:43:06 <dolio> dons: I can't tell if it's a joke or not.
01:43:28 <Baughn> DRMacIver: I see. I keep looking for magic bullets, and finding synergism instead.
01:43:45 <dcoutts> foxy-om: mm
01:43:59 <Cheery> darn, I guess I should take a look into haskell internals someday
01:44:00 <dolio> I guess my differential geometry is kind of weak.
01:44:17 <Wild_Cat> unfortunately, there is no magic bullet (if there is, why haven't I been clued in yet?).
01:44:29 <DRMacIver> (ok, I haven't left yet. Curses)
01:44:33 <DRMacIver> Baughn: Exactly.
01:44:33 <dons> Cheery: all haskell is just sugar for let/case/lambda and apply
01:44:50 <DRMacIver> Wild_Cat: There isn't a magic bullet, but there is a magic arsenal. :)
01:45:28 <Baughn> DRMacIver: There does seem to be some black magic - monads. I only just figured out monad transformers, and there's so much more left..
01:46:36 <Cheery> dons: I knew that most of haskell is just sugar. :)
01:46:47 <DRMacIver> Monads aren't black magic. They're fundamentally not that mysterious (although conceptually somewhat challenging - I still don't totally get them), but the way Haskell uses them forces you to encounter their least comprehensible examples first. :)
01:46:50 <Syzygy-> Hey DRMacIver
01:46:53 <DRMacIver> Hi Syzygy-
01:46:57 <DRMacIver> How goes?
01:47:34 <matthew-_> DRMacIver: I have to say, I think that learning Monads from the perspective of IO first, is probably wrong.
01:47:39 <foxy-om> http://www.emergentminds.com/portfolio/spaceTimeConstruct_v1.4.mov
01:47:43 <lambdabot> http://tinyurl.com/2hw9oo
01:48:00 <Cheery> dons: I think I'd be well off on my way by knowing fundamental ideas of IO -monad and most of that stuff which goes after haskell is parsed.
01:48:09 <Baughn> matthew-_: So perhaps the tutorials should be written in terms of main = interact?
01:48:20 <Cheery> do you have an idea what I should read?
01:48:28 <DRMacIver> matthew-_: That's what I mean.
01:48:28 <Wild_Cat> matthew-_: maybe, but the problem is, you can't do much with a programming language until you learn IO...
01:48:44 <matthew-_> Baughn: no, I understand the history of it and the desire to write tutorials that do something...
01:49:05 <Baughn> matthew-_: They would do something. You can do a *lot* with access to just stdin and stdout.
01:49:18 <DRMacIver> I think you can succesfully teach IO as just this black magic which you won't understand until later.
01:49:24 <matthew-_> DRMacIver, Wild_Cat: but it seems to me that the monads where the type parameter is a function are harder to get your head round than the others
01:49:27 <Baughn> Personally, one of my favorite features is that Hsakell's nullary functions are just ordinary values. :)
01:50:01 <DRMacIver> "I promise this will make sense when we're done. Please just invoke the magic incantation for now."
01:50:09 <DRMacIver> Anyway, I'm *really* going now. :)
01:50:32 <matthew-_> eg, ok, it was one of the first times I taught, but I confused the hell out of the first years at Imperial with a lecture on Monads and IO. If I did it again, I'd start from Maybe
01:54:41 <quicksilver> I would certainly advocate teaching a little IO without explaining that it's a monad
01:54:49 <dons> Cheery: 'tackling the awkward squad' is good for understanding IO
01:54:54 <quicksilver> Something like main :: IO () <--- this is a special type which means it can do IO
01:55:09 <dons> the various 'Implementation of functional programming language' tutes by SPJ et al are good for understanding how to compile haskell
01:58:15 <dons> i'm writing an article on xmonad, and on developing precise applications in Haskell, here's the intro (just seemed relevant to the above discussion):
01:58:19 <dons> http://www.cse.unsw.edu.au/~dons/tmp/wm.txt
01:58:43 <dons> (oh, please no one post this to reddit or anywhere, there's a full article on its way)
01:59:20 <kolmodin> dons: will you put it in TMR?
01:59:33 <dons> hmm...
01:59:56 <dons> i was thinking more about blogging it, but I could tie it all up with Spencer for the next TMR , I suppose
02:02:24 <Cheery> when I think of it, that's somehow weird, ..house .. xmonad..
02:02:51 <dons> yeah, we have a weird bent towards systems programming
02:02:54 <Cheery> it's like haskell would eventually replace the whole operating system, by spreading like plague of some sort
02:03:32 <dons> you've not used the halfs file system then? :-)
02:03:34 <matthew-_> it's not a plague
02:03:36 <matthew-_> it's the cuer
02:03:43 <matthew-_> cure, *cough*
02:03:53 <Cheery> dons: nop
02:03:59 <dons> you've got a cold! let me get you a nice warm glass of lambdas, matthew-_
02:04:13 <Cheery> let me guess. halfs is a haskell file system
02:04:18 <matthew-_> dons: bankyou!
02:04:33 <Cheery> HAL-fs
02:04:36 <Cheery> :P
02:04:39 <dons> that's right
02:04:43 <matthew-_> mmm. is it database-based?
02:06:31 <Cheery> but it's weird that something successful will just eventually end up growing, then offsetting the old
02:07:22 <Cheery> I can think of those small projects blending slowly together and improve with fast pace.
02:07:40 <joelr1> dons: i'm compiling using cabal so the generated code goes into dist/build. i run ghci in emacs and type :set -idist/build (assuming i previously did :cd to get to the right dir)
02:07:52 <joelr1> dons: i then do :l "Test" and it can't find the module
02:09:12 <Cheery> it's just matter of time
02:09:44 <osfameron> it's interesting rereading http://perl.plover.com/yak/typing/notes.html after having learnt a (tiny) bit of haskell
02:10:12 <osfameron> especially slide 28, where you can see how the haskell version with type classes would be different from either sml or ocaml.
02:11:15 <dons> joelr1: no quotes?
02:11:39 <joelr1> dons: none
02:12:06 <joelr1> dons: no quotes in :set -i that is
02:12:09 <joelr1> do i need them?
02:13:06 <joelr1> dons: i think it may be a different problem, though, as even after i cd into the dist/build/.. dir i still can't load the modules
02:13:29 <dons> try using ghc --make in the local dir, so the .hi and .o files are next to the .hs files
02:14:11 <joelr1> dons: that works for sure but i was hoping to avoid it :)
02:14:49 <joelr1> dons: the issue is that my tests refer to test/... to load data and the code is under src/. even if i make in src i would still need to run from ../src
02:15:23 <dons> i'm sure there's a way with appropriate -i or -I flags, but I don't know how to work the precise flag set out without trying all combinations :-)
02:15:50 <joelr1> dons: ok, thanks
02:16:32 <Utopiah> hello :)
02:16:34 <plediii> help! when I try to import Control.Monad.Trans ghc tells me it could not find the module.
02:16:37 <joelr1> dons: -i is for source files, apparently. hs and lhs
02:17:11 <plediii> looking at the haskell.org/docs, it appears to be a standard module, so I have no idea why it wouldn't work.
02:17:42 <dons> plediii: its in the 'mtl' package
02:17:45 <dons> please get that from hackage:
02:17:48 <dons> ?hackage mtl
02:17:48 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mtl
02:17:54 <scodil> i saw a patch to add min/max functions to IntMap and IntSet... anyone know if this is going to be added soon? didn't seem to make 6.6.1
02:17:56 <dons> or from your systems packages
02:18:22 <sjanssen> scodil: API changes only happen for major releases, so it might be in GHC 6.8
02:18:48 <scodil> is there an eta for that? just curious. for know I can just patch my own stuff
02:18:54 <scodil> for now...
02:19:51 <plediii> dons: thanks, I'll try to install that package.
02:21:14 * matthew-_ considers a joke along the lines of "there's no eta, but there's an η for it!"
02:22:30 <scodil> well at least you only considered it
02:23:03 <sjanssen> joelr1: can you just run 'ghci -isrc' in your top directory?
02:23:24 <joelr1> sjanssen: that works. but then i would also need to ghc --make in src
02:23:31 <joelr1> sjanssen: that's the only solution that i found
02:23:37 <matthew-_> scodil: worst still was the amount of time it took to find \eta on my keyboard!
02:23:44 <sjanssen> joelr1: why?  Do you have some abnormal build process?
02:24:01 <joelr1> sjanssen: i'm using cabal normally
02:24:06 <longarms2> has anyone here had numerical code break under ghc 6.6.1?  I have a program that runs and gives correct answers under ghc 6.4.2 but produces NaN's under 6.6.1
02:24:26 <matthew-_> longarms2: what architecture?
02:24:34 <longarms2> linux x86
02:24:42 <longarms2> i am using the downloaded binary
02:25:07 <matthew-_> longarms2: I've seen weird stuff with the opengl bindings using a pre-release of 6.7 where /I think/ 64-bit values are being read as 32-bit
02:25:12 <sjanssen> joelr1: right, but is there any reason your code won't just run in interpreted mode?
02:25:33 <joelr1> sjanssen: it will but why recompile a large project every time you change a small detail in a single file?
02:25:43 <longarms2> hmm
02:25:46 <matthew-_> but I've not upgraded to 6.6.1 yet. When debugging the weird behaviour, I certainly came across a lot of NaNs that shouldn't have been there
02:26:00 <plediii> dons: yay, it compiled!
02:26:09 <matthew-_> this is all maths with Doubles btw
02:26:27 <longarms2> is there an easy way to find the first appearance of NaN (i.e. throw an exception on NaN)?
02:26:33 <longarms2> yes
02:26:45 <longarms2> and I am using PArr as my array structure
02:26:54 <matthew-_> I'm not using any arrays.
02:27:09 <matthew-_> I don't think easy. Depends on the code. You might have to explicitly look for them.
02:27:25 <matthew-_> which of course could change the semantics of the code if it's a bug, eg, with an optimiser
02:28:05 <longarms2> i can try turning off default optimizations; i am currently compiling without -O
02:28:07 <dons> joelr1: you have to recompile due to whole-program optimisations
02:28:22 <dons> joelr1: if you use -Onot, you won't get the cross-module stuff happening, and less will need to be recompiled each time.
02:28:29 <dons> however, you also miss out on speed :-)
02:28:36 <dons> the price we pay for clever compilers.
02:28:51 <longarms2> thank you for the help
02:28:57 <matthew-_> dons: is there an -Os feature planned for minimising the memory and binary footprint rather than optimising for speed?
02:29:19 <matthew-_> longarms2: I'd love to hear what you find as this may well bite me soon!
02:29:28 <Cheery> ow! I guess I understood arrows. :)
02:29:28 <longarms2> lol
02:29:30 <dons> matthew-_: hmm, you could pass -optc-s I suppose
02:29:43 <dons> but there's not been a lot of work in ghc in optimising for space over time.
02:29:49 <Baughn> matthew-_: There already are some options for adjusting runtime heap size. Have you tried that?
02:29:49 <dons> that was more nhc's goal, iirc
02:29:55 <joelr1> dons: what i mean is that i always pre-compile first and ghc decides what to compile. i then just want to load the module into ghci.
02:30:00 <Cheery> second paper I read about functional reactive programming opened it up
02:30:40 <dons> joelr1: ah right. and just work on an interpreted version of whatever file you're spending most time in?
02:30:54 <dons> that's fine. shouldwork mostly, modulo cross-module stuff
02:31:01 <joelr1> dons: yes. the issue is that ghci can't handle generated code and source files in different directories
02:31:05 <joelr1> dons: apparently not
02:31:20 <joelr1> dons: when the dir is the same then ghc checks and doesn't recompile if nothing changed
02:31:27 <matthew-_> Baughn: no, though I wasn't aware of that. My immediate concern is that it'd be nice to ship binaries that are < 2MB in size for small programs.
02:31:33 <dons> ah ok.
02:31:45 <joelr1> dons: sorry, meant ghci doesn't interpret if nothing changed and just loads the binary stuff
02:31:46 <dons> matthew-_: strip and split objs are your friends then
02:32:03 <quicksilver> matthew-_: I don't think the 2MB binaries are solved by a better compikler
02:32:06 <dons> since the 2MB size isn't due to compiler flags, but due to linker dumbness.
02:32:07 <quicksilver> they're solved by a better linker
02:32:15 <matthew-_> okay.
02:32:18 <quicksilver> it's including library stuff it doesn't need
02:32:20 <sjanssen> joelr1: I don't see a way to do this
02:32:39 <dons> on a system with your base libs buit lwith SplitObjs=YES, hello world is around 200k, and adding more libs tends not to grow it much bigger
02:32:44 <quicksilver> joelr1: union-mounted loopbacks!
02:32:45 <joelr1> right
02:32:54 <joelr1> quicksilver: what?
02:33:08 <quicksilver> joelr1: in some operating systems, you can mount two directories on top of each other
02:33:17 <quicksilver> joelr1: so that newly written files go in a different place
02:33:25 <quicksilver> then you could 'superimpose' your obj dir over your source dir
02:33:28 <quicksilver> and ghci would find them
02:33:49 <dons> yeah, union mounts are fun.
02:33:53 <joelr1> quicksilver: hmm
02:34:00 <joelr1> sounds like vms to me, or something
02:34:30 <quicksilver> bsd, linux, and OSX can all do that trick
02:34:38 <matthew-_> no, under linux there's unionfs, but it sits oddly wrt the vms and none of the linux kernel devs like it
02:34:50 <quicksilver> no prize for guessing which popular OS can't :P
02:35:18 <matthew-_> it has weird limitations like you're not allowed to access any of the filesystems that form the union outside of the union otherwise you'll break it.
02:46:15 <boegel> dons: hiya!
02:48:54 <dLeCamarae> @where pop
02:48:55 <lambdabot> I know nothing about pop.
02:48:58 <dLeCamarae> @where pop3
02:48:59 <lambdabot> I know nothing about pop3.
02:49:08 <dLeCamarae> @where haskellnet
02:49:09 <lambdabot> I know nothing about haskellnet.
02:49:18 <dLeCamarae> @where your brains
02:49:19 <lambdabot> I know nothing about your.
02:49:21 <ivanm> dLeCamarae, have you become dyslexic or something?
02:49:28 <ivanm> ;)
02:49:34 <dLeCamarae> ivanm: Can
02:49:39 <dLeCamarae> Can't rule it out.
02:49:43 <ivanm> heh
02:49:43 <dLeCamarae> :oD
02:50:24 <dLeCamarae> doth wy evez zwwm dliub (both my eyes seem blind)
02:51:30 * ivanm thinks dLeCamarae is being silly
02:51:31 <ivanm> :D
02:52:19 <dLeCamarae> Where can I find a blerry POP3 library? Wait ...
02:52:23 <dLeCamarae> @go haskellnet
02:52:25 <lambdabot> http://darcs.haskell.org/SoC/haskellnet/
02:52:26 <lambdabot> Title: Index of /SoC/haskellnet
02:53:43 <swiert> The next issue of The Monad.Reader has been released:
02:53:52 <quicksilver> woot
02:53:53 <swiert> http://www.haskell.org/haskellwiki/The_Monad.Reader
02:53:54 <lambdabot> Title: The Monad.Reader - HaskellWiki
02:55:16 <dons> swiert++ woot!
02:55:45 <dons> swiert: just the .pdf available? (to link to on reddit?)
02:56:12 <swiert> dons: There's also a darcs repository with the sources: darcs get http://sneezy.cs.nott.ac.uk/darcs/TMR/Issue7/
02:56:15 <lambdabot> Title: Index of /darcs/TMR/Issue7
02:56:46 <boegel> swiert: cool
02:57:08 <boegel> dons: did you get my mail some time back? on your ICFP paper?
02:57:22 <dons> http://programming.reddit.com/info/1m312/comments
02:57:23 <lambdabot> Title: The Monad Reader: Functional Programming on Wall Street, Lego Control, YHC and " ...
02:57:52 <dons> boegel: ah yes, I'm still going though my backlog, thanks for the feedback, and i'll send a response soon
02:59:45 <boegel> dons: ok, 'cause I have a few questions... I thought you just skipped it :P
02:59:53 <dons> nah, just overworked
03:00:03 <boegel> swiert: I'm glad to see someone is still keeping TMR going
03:00:09 <boegel> dons: aren't we all
03:00:21 <boegel> I'm trying to cut down actually, and I like it so far
03:00:28 <boegel> makes my gf happier :-)
03:01:16 <swiert> boegel: Yeah. I've been releasing less often than shapr, but I'm quite happy with the results so far.
03:02:12 <joelr1> how do you apply a patch where the file names start with either +++ or --- ?
03:03:14 <quicksilver> with 'patch'
03:03:39 <joelr1> quicksilver: yes but what options?
03:03:45 <nominolo> any ops around?  TMR 7 could use some advertising, doesn't it?
03:03:51 <quicksilver> joelr1: -p0 or -p1, typically
03:04:14 <quicksilver> joelr1: tells it how many chunks to 'trim' off the directory paths to find the files it wants
03:04:15 <joelr1> quicksilver: thanks
03:04:39 <nominolo> oh, heh, should have read the backlog :)
03:05:35 <nominolo> swiert: do you still do stuff using attribute grammars?  or did you write some haskell extensions?
03:06:06 <nominolo> swiert: (referring to the older talk slides from your website)
03:08:35 <swiert> nominolo: No not really. I worked quite a bit with them as an undergraduate in Utrecht.
03:11:32 <dons> http://programming.reddit.com/info/1m312/details mod up everyone! TMR rocks!
03:11:34 <lambdabot> Title: The Monad Reader: Functional Programming on Wall Street, Lego Control, YHC and " ...
03:13:36 <pGeist> oh awesome
03:13:41 <pGeist> oh, wrong nick.
03:14:02 <dons> 61 pages of Haskell fun!
03:14:06 <dons> swiert, great work.
03:14:12 <dons> and the authors too ;-)
03:14:13 <ivanm> but who's counting? ;-)
03:14:48 <goltrpoat> yeah, TMR has consistently been an excellent read, awesome job.
03:15:17 <goltrpoat> ooh Lava
03:15:28 <vegai> ohh, the new book is reviewed there
03:15:50 * boegel is hearing a lot of TMR-related orgasms
03:16:12 <goltrpoat> hah
03:16:24 <ivanm> heh
03:17:09 <goltrpoat> anyone know if Xilinx is actually using Lava in production these days?
03:17:56 <joelr1> how do you revert with cvs?
03:17:59 <vegai> ohh, Yhc
03:19:00 <Wild_Cat> joelr1: mmh, cvs help shows a "cvs unedit" command, that could be what you're looking for
03:19:07 <joelr1> thanks
03:19:39 <goltrpoat> unedit doesn't revert, iirc
03:20:02 <goltrpoat> it ends an editing session without committing, but doesn't update
03:20:55 <goltrpoat> oh.  the docs say it prompts for that.
03:27:27 <hpaste>  matthew-_ pasted "timings and memory footprints for various folds." at http://hpaste.org/1619
03:28:09 <matthew-_> ^^^ presumeably, the fact that the (+) version only worked with foldl' and not foldr is due to the strictness of (+) ?
03:32:35 <matthew-_> so what rules of thumb are there, if you care about speed, between choosing foldl' and foldr and foldl given the nature of the function?
03:32:59 <quicksilver> always use foldr
03:33:00 <siti> always use foldr unless there's a problem ;0
03:33:09 <quicksilver> that's the rule of thumb :)
03:33:34 <matthew-_> I see.
03:33:35 <osfameron> re fold[rl], what is the reason for having to supply an 'init', rather than just using the first item in the list ?
03:33:45 <matthew-_> list may be empty
03:33:47 <osfameron> for some things like min and max, it's the only sensible value for init
03:34:05 <quicksilver> matthew-_: re-run those tests under ghc -O2
03:34:10 <quicksilver> matthew-_: then it might actually mean something :)
03:34:18 <matthew-_> quicksilver: yeah, true enough
03:34:19 <quicksilver> osfameron: you have fold[rl]1 and
03:34:26 <quicksilver> osfameron: for that :)
03:34:35 <osfameron> aha!  ok
03:34:45 <quicksilver> osfameron: but matthew-_'s answer is correct. To get a meaningful result for the empty list
03:34:57 <quicksilver> osfameron: there is another answer, too.. the types may not match
03:34:59 <quicksilver> :t foldr
03:35:04 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
03:35:08 <matthew-_> quicksilver: is there an easy way to get :set +s from ghc?
03:35:17 <quicksilver> osfameron: note: (a -> b -> b), not a->a->a
03:35:28 <osfameron> it seems like a bad tradeoff but I haven'ìt used either enough to spot the pitfalls
03:35:59 <quicksilver> matthew-_: not sure. there are profiling options...
03:35:59 <osfameron> ah!  yes, ok, that's pretty important.
03:36:08 <osfameron> thanks matthew-_, quicksilver, that makes sense
03:36:16 <matthew-_> quicksilver: yeah, doesn't that affect performance?
03:36:30 <quicksilver> matthew-_: yes. That's the computing manifestion of the uncertainty principle
03:36:37 <quicksilver> matthew-_: impossible to measure things without affecting them!
03:36:40 <matthew-_> lol
03:38:15 <Maddas> Not to be a nitpick, but isn't that different from the uncertainty principle? :)
03:39:15 <Maddas> (This being the observer effect)
03:39:26 <quicksilver> Maddas: One consequence of the uncertainly principle is that the more accurately you try to measure something, the more you affect it
03:39:37 <quicksilver> I'm not claiming it's the entire principle, but it is an effect of it
03:40:27 <Maddas> ok
03:41:23 <quicksilver> neither am I being very precise, it was only an analogy :) and the uncertainty principle is more famous than the observer effect.
03:41:41 <nominolo> goltrpoat: at least one person used to
03:41:54 <nominolo> goltrpoat: now he's at microsoft.  but still uses lava :)
03:42:01 * osfameron stares at quicksilver accurately
03:42:03 <goltrpoat> ah cool.
03:43:28 <goltrpoat> one of my partners used to work at Celoxica, so i've picked up some EDA stuff from him, and Lava seemed so much nicer than Handel-C or (shudder) VHDL that i figured it'd catch on eventually
03:43:42 <goltrpoat> been curious how that's been going.
03:43:56 <nominolo> goltrpoat: well, VHDL and Lava serve different purposes, though
03:44:18 <nominolo> goltrpoat: Lava is all about controlling the netlist
03:44:32 <goltrpoat> i was under the impression that you could compile Lava to VHDL
03:44:47 <goltrpoat> sort of like Handel-C has an optional VHDL backend
03:45:02 <nominolo> goltrpoat: sure.  but it's more low-level than e.g. behavioral VHDL
03:45:07 <goltrpoat> ah right
03:45:19 <nominolo> you can also "compiler" to various proof-checkers
03:45:34 <goltrpoat> -nod-
03:45:55 <nominolo> Lava has been critizised for mixing logic and layout.  but i think it's quite nice
03:46:56 <goltrpoat> actually, the guy i mentioned was particularly excited about the fact that you could specify both logic and layout
03:47:12 <hpaste>  matthew-_ annotated "timings and memory footprints for various folds." with "same tests as before, but via ghc -O2" at http://hpaste.org/1619#a1
03:47:21 <goltrpoat> i sent him a few links way back when, and that was like.. the first thing he pointed out
03:47:55 <nominolo> goltrpoat: ok then :)  i did too little hw design to have any opinion on that ..
03:49:01 <quicksilver> matthew-_: so you can see that the strictness analyzer works, for your case, and foldl' is equivalent to foldl
03:49:07 <goltrpoat> i've done very little myself, and none on actual hardware.  been meaning to get into that for ages.
03:50:06 <matthew-_> quicksilver: only on the const version. In the + version, the foldl blows up, but foldl' doesn't
03:50:17 <goltrpoat> mike used to be pretty well-known as a handel-c and hw guy, so if i ever do find the time, i should have a decent headstart.
03:50:41 <nominolo> Lava is really nice, since it allows you to use haskells polymorphism in a very handy way
03:50:47 <goltrpoat> -nod-
03:51:21 <quicksilver> matthew-_: that's odd. the strictness analyzer should work on +.
03:51:33 <matthew-_> quicksilver: that's what I was just thinking
03:55:20 <hpaste>  matthew-_ annotated "timings and memory footprints for various folds." with "now with output of strictness analysis" at http://hpaste.org/1619#a2
03:56:26 <hpaste>  matthew-_ annotated "timings and memory footprints for various folds." with "paste size issues..." at http://hpaste.org/1619#a3
03:58:00 <goltrpoat> quicksilver:  i'm not sure how STG works here, but the G-machine gives special treatment to arithmetic and comparison operators, as far as strictness is concerned
03:58:38 <goltrpoat> so the strictness analyzer may have less to work with than it seems
03:58:45 <goltrpoat> stab in the dark though.
04:02:50 <dons> cool, TMR is top of programming.reddit, with (pdf) too!
04:02:59 <dons> there's hope for the future of humanity after all ;-)
04:03:45 <boegel> dons: there is, because someone brought my guitar to Lost and Found, the one I left on the train!!! I thought someone would've 'stolen' it...
04:04:01 <dons> wow.
04:04:14 <boegel> dons: yeah, I was amazed too...
04:04:25 * boegel has made a promise to himself that he'll practice from now on
04:04:35 <boegel> that _must_ have been a sign from God
04:04:35 <norpan> most people are honest
04:05:01 <boegel> norpan: that what I was hoping, but it took over 3 hours for my guitar to reach lost and found, so I had given up all hop
04:05:02 <boegel> *hope
04:10:17 <goltrpoat> boegel:  my old les paul got ripped off from my apartment about 7 years ago, along with about 200 cds and various miscellanea.
04:11:44 <goltrpoat> i'm thinking your guitar getting returned balances it out at the most, rather than being a proof of any particular future for humanity :)
04:12:37 <plediii> interesting how pointing out programming.reddit.com is on topic could drive this channel so far off topic.
04:12:47 <boegel> goltrpoat: I think it's a lot easier for someone to keep something he found on the train, than to break in someone's appartment and steal stuff...
04:12:54 <boegel> plediii: :-)
04:15:27 <goltrpoat> hehe true
04:16:41 <goltrpoat> boegel:  to steer this further off-topic, what kind of guitar is it?
04:17:17 <quicksilver> A monadic guitar! <--- back on topic !!!
04:17:23 <goltrpoat> slick.
04:18:56 <matthew-_> mmm. a monadic guitar would be useful for guitar hero: you wouldn't be able to play the wrong notes...
04:19:02 <goltrpoat> in the spirit of getting back on topic (sort of), one of john baez's random posts of utter coolness, for anyone with both a mathematics and music theory background:  http://math.ucr.edu/home/baez/week234.html
04:19:03 <lambdabot> Title: week234
04:21:03 <Igloo> Could you use unsafePerformGuitar to harmonise with yourself?
04:22:03 <boegel> goltrpoat: classic guitar... I've been taking lessons the past two years (which are very interesting), but I can't seem to find the time to practise enough... also, I'm a leftie, which confuses people who want to try out my guitar ("hey, this thing is backwards!") :P
04:22:04 <goltrpoat> only if you know the type of performance beforehand.
04:22:16 <edwinb> I did see an ad for a band called "The Awkward Squad" recently...
04:22:23 <matthew-_> mmm. prefixing other "functions" with "unsafePerform" related to Rock'n'Roll life-style!
04:22:52 <merus> "Try saying it sometime: "Cool! That's quadrivial!" It might catch on."
04:23:00 <merus> Baez is so cute ^^
04:25:37 <goltrpoat> boegel:  ah cool.  i played classical for some time, self-taught.  tons of fun, but a decent classical costs a fair bit, and i think i'd want a high-end 12-string before i invest in something like that.  definitely been meaning to get into it though -- my girlfriend's a music major, so i'm often reminded how cool counterpoint is.
04:27:38 <goltrpoat> my brother's a leftie, he played right-handed guitar and basses for a while, cursed at them every step of the way and eventually quit.
04:27:38 <goltrpoat> heh
04:27:45 <goltrpoat> guitars, rather
04:31:47 <goltrpoat> various music theory apps actually make a lot of sense in haskell.  i remember writing something that would take a key, a set of constraints (eg, start on the tonic, end on the tonic, two measures, and i want a perfect authentic cadence at the end), and produce a progression under the usual counterpoint rules
04:32:12 <goltrpoat> should probably revisit that at some point and package it up
04:35:30 * quicksilver nods
04:35:34 <quicksilver> that would be cool
04:35:40 <quicksilver> composition combinators
04:36:44 <goltrpoat> right, exactly
04:39:21 <matthew-_> mmm. "Singing in Haskell: Bach cantatas as performed by Hindly and Milner"
04:39:30 <matthew-_> sounds like a good paper to me!
04:40:44 <goltrpoat> it's an interesting problem all in itself, because you get situations where -- well, one rule says, i want a focal point per phrase.  according to the other rules however, i'm going to double up on the high point, if i want the bass line to be correct.  basically it's a giant binary CSP, but instead of discarding inconsistent solutions, there are degrees of inconsistency
04:41:33 <goltrpoat> eg, two focal points per phrase is probably ok if there are no other solutions, or if it sounds reasonably well (with quantifiable measures of "sounds" -- eg, the contours of the bass and treble in two-part counterpoint, etc)
04:41:34 <boegel> goltrpoat:  being able to play your own music is indeed pretty cool, but requires a lot of practice
04:42:34 <goltrpoat> boegel:  oh, sure.  i've been playing music for over 20 years now and i still have no real idea what i'm doing :)
04:44:01 <matthew-_> goltrpoat: having just been reading TMR 6, I'm wondering whether some fixed point operator would work for this!
04:46:11 <goltrpoat> well.. the nice thing here is that it's very easy to formalize these things mathematically.  what i did earlier was apply a fairly simple subset of composition rules to user-defined constraints (the more rigid the rules the easier the implementation, so it was basic counterpoint, more or less)
04:47:52 <goltrpoat> part of the reason why counterpoint rules exist, is that if you write a piece that adheres to those rules, you could be completely tonedeaf, it'll still sound reasonably well.  the problem is that oftentimes you'll get *no* feasible solutions, so then you have to figure out which constraint to break.
04:48:04 <goltrpoat> you can probably assign context-sensitive scores to the constraints, though.
04:48:30 <matthew-_> yup. what did you use for actually playing the sounds?
04:48:43 <goltrpoat> oh i wasn't playing them.  i'd dump out the bass line in text
04:49:13 <matthew-_> ahh
04:49:27 <goltrpoat> should be easy enough to add something to play it through midi, i would imagine
04:49:50 <longarms2> matthew-_ :  i found the problem -- it was in GHC.PArr;  the library has two functions permuteP and bpermuteP which permute arrays.  in ghc 6.4.2, permuteP had the functionality of bpermuteP and bpermuteP was unimplemented.  the PArr code was fixed by 6.6.1, but my code depended on the old functionality.  the NaNs were just a symptom of the bad permutation
04:50:15 <longarms2> sorry for the long post
04:50:28 <matthew-_> longarms2: ahh ok, so given that I'm not using arrays, it's probably unrelated.
04:50:43 <goltrpoat> i'll dig up that code this weekend if i have time, and try to make it more usable and user-friendly
04:50:51 <matthew-_> longarms2: I suspect I was just seeing breakage in ghc 6.7 which isn't surprising.
04:51:06 <matthew-_> goltrpoat: I'd like to see that, certainly.
04:51:12 <longarms2> true
04:51:16 <goltrpoat> cool
04:52:35 <matthew-_> damn it, TMR gets the margins the wrong way round. GRRRR. The left margin on odd pages, and the right margin on even pages should be bigger, and the others, smaller.
04:53:09 <matthew-_> I've seen this mistake many times with LaTeX...
04:54:20 <kuribas> goltrpoat: I have been playing with that idea too.
04:55:36 <kuribas> goltrpoat: But the problem is to find an algorithm that can recognise a good musical line.
04:55:53 <kuribas> Not impossible, but not trivial too.
04:56:32 <goltrpoat> well, the idea is that counterpoint, especially in the lower species, is constrained enough that anything that follows the rules, will sound reasonably well
04:57:31 <kuribas> goltrpoat: Yes, but what is a good musical phrase isn't really formalised in counterpoint.
04:57:33 <goltrpoat> my girlfriend has taken to doing her assignments entirely on paper -- then later i go, well, you should probably hear it, so i play it on piano, and it sounds like a fairly solid composition (the instructor usually imposes constraints of various sorts)
04:59:10 <goltrpoat> kuribas:  right.  but it's very hard to write a treble line that sounds badly, if you're doing two-part counterpoint.  given the treble line, adding more complex rhythm patterns and grace notes to smooth out jumps above a 5th and all that stuff, that's sort of separate
05:00:35 <goltrpoat> so if the user says, well, i want this 4 measure phrase, in 3/4, in F minor, and i want a Phrygian cadence in the middle and a PAC at the end -- more often than not, there's exactly one solution
05:01:03 <kuribas> goltrpoat: Just one?
05:02:21 <goltrpoat> that's semi-anecdotal:  i've been helping my gf with her music theory homework here and there, and sometimes we finish writing it out, realize there's a couple of parallel 5th in the first measure, and that completely changes the entire piece
05:02:36 <goltrpoat> seems too much like dynamic programming, just by usage patterns.
05:02:53 <kuribas> What I have been thought, there are many rules for the melodie, such as avoiding repetitions, both rithmically and melodically, and try to cover the entire range of the voice.
05:03:11 <goltrpoat> well, yes, but there's much more than that
05:04:02 <kuribas> goltrpoat: Wait until she has to write 4 part counterpoint.
05:04:23 <matthew-_> or 16.
05:05:09 <kuribas> matthew-_: :) Yes, but then the rules are different.
05:05:29 <goltrpoat> eg, say you're on the IV chord, in first inversion.  what can you transition to?  well, that depends.  you can transition to ii, V and vii(dim), but you have to keep a cohesive contour, and at least not do jumps over a 5th.  that rules out a fair bit right there.  then on the next measure, a constraint is that i want a phrygian cadence.  that'll prune most of the tree right there.
05:05:31 <goltrpoat> stuff like that.
05:05:55 <goltrpoat> i don't think she's done 4 part yet, i have, but it was a long time ago.  i spent a fair bit of time with fux's book way back when.
05:05:55 <kuribas> goltrpoat: Did you actually write some code?
05:06:34 <goltrpoat> yeah, i wrote code to dump out a bass line and tonalities given a key and time signature, number of measures, and optional constraints
05:07:03 <goltrpoat> i just remembered it due to the whole music conversation, and figured it'd be cool to extend it to multi-voice counterpoint
05:07:45 <goltrpoat> and let it break the rules if needed, by assigning scores to rules.
05:07:58 <matthew-_> I do wonder whether it'd be better written in Prolog or even a CSP engine
05:08:01 <goltrpoat> bit hazy on that last part.
05:08:15 <goltrpoat> oh it's all CSP.
05:08:45 <goltrpoat> i think i'd prefer haskell just due to the 10% of it that isn't, since it's a binary CSP, and writing binary CSPs in haskell is fairly trivial
05:09:16 <goltrpoat> but yeah, prolog or mercury would do quite well there, i would think.
05:10:51 <cacilhas> hi everyone! I'm new to haskell and I'm looking for examples about X11 (and socket too)... can anyone tell me where to find?
05:11:13 <dLeCamarae> @where network
05:11:14 <lambdabot> I know nothing about network.
05:11:25 <Syzygy-> @where xmonad
05:11:25 <lambdabot> http://www.xmonad.org/
05:11:29 <dLeCamarae> @go Network.Socket site:haskell.org
05:11:30 <dons> cacilhas: i'm in the middle of writing an X11 blog (focusing on window managers), other than that, check haskell.org/haskellwiki/Blog_articles
05:11:31 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/network/Network-Socket.html
05:11:35 <kuribas> goltrpoat: Do you know Curry?  It is like Haskell with logic features.
05:12:36 <goltrpoat> kuribas:  oh, good point.
05:13:27 <goltrpoat> curry might be a better fit here.
05:13:31 <cacilhas> wow! thanks everybody! ;-)
05:14:21 <cacilhas> I'm already seeing the urls!
05:14:47 <cacilhas> ...
05:14:49 <goltrpoat> on the other hand, i think the whole thing is binary, and i've written binary CSP solvers in haskell before, and it's just.. not much work to speak of
05:15:05 <goltrpoat> i'd be more concerned about writing the gigantic combinator library
05:15:16 <goltrpoat> anyway, bedtime.
05:15:24 <goltrpoat> thanks for the ideas guys
05:17:50 <cacilhas> I'm looking... the haskell hierarchical libraries show a very complete description of each library, but unfortunely no one example at least :-(
05:18:30 <Cale> cacilhas: It varies, sometimes there are short examples.
05:19:21 <Cale> cacilhas: But you're right, there's a lot fewer examples than you'd normally expect of documentation. The docs are built automatically from annotated source code.
05:19:44 <Cale> cacilhas: Is there anything in particular which you'd like an example for?
05:22:00 <matthew-_> maybe haddock should djinn to construct examples!
05:22:52 <ddarius> That would produce the source code, not examples.
05:23:20 <ddarius>  @free though
05:23:37 <ddarius> That provides both examples and invariants.
05:23:42 <ddarius> @free foldr
05:23:44 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
05:24:01 <quicksilver> what's $map?
05:24:27 <quicksilver> @free fst
05:24:29 <lambdabot> f . fst = fst . $map_Pair f g
05:25:02 <dons> $map is fmap for the type we're looking at, iirc
05:26:28 <Baughn> Is ghc known not to compile on osx?
05:26:37 <cacilhas> Cale: not really... I'm looking for anything... just to start
05:26:49 <Cale> cacilhas: Oh, to start learning Haskell?
05:27:07 <quicksilver> Baughn: I compiled 6.6 and don't recall any problems
05:27:15 <Cale> Or do you know the basics of Haskell and are looking to start learning a particular library?
05:27:24 <Baughn> quicksilver: 6.6 works. I'm referring to head
05:27:50 <Baughn> Or 6.6.1, for that matter
05:27:50 <Cale> (the libraries documentation is an awfully difficult way to start learning Haskell in general)
05:28:30 <ddarius> What? Types tell you everything you need to know.
05:28:37 <Cale> If you're looking for general stuff for learning Haskell, I recommend the Wikibook and "Yet Another Haskell Tutorial".
05:28:49 <cacilhas> Cale: no... I've already started ;-)
05:28:53 <Cale> ah, okay
05:32:19 <cacilhas> but I need more examples :-(
05:32:38 <dylan> I am not a neat language! XD
05:33:16 <cacilhas> I would like to start making x11-apps with haskell and I need using socket
05:33:38 <cacilhas> but it's hard to find
05:34:18 <igli> use a lib?
05:34:22 <Syzygy-> cacilhas: You might want to look at wxhaskell and that other GUI-library
05:35:58 <ToRA> @paste
05:35:59 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:37:21 <cacilhas> oh! I have found wxhaskell... but it returned error when I tried to compile :-(
05:37:34 <cacilhas> let me see...
05:45:33 <cacilhas> just a moment... I'm recompiling wxhaskell here to get the error...
05:46:26 <dcoutts_> cacilhas, released versions of wxhaskell do not build with current ghc versions
05:46:33 <nominolo> dylan: no?
05:46:54 <cacilhas> no? =-O
05:46:59 <cacilhas> f*
05:47:09 <dylan> nominolo: nope. the native representation of my data structures isn't documented, for instance.
05:47:15 <nominolo> dylan: but you were just released in a new version
05:47:23 <dylan> I was?
05:47:34 <nominolo> dylan: but your object system is nicely advanced
05:47:35 <cacilhas> :-(
05:47:43 <dcoutts_> cacilhas, either use the darcs version of wxhaskell or find the patches to make it work, or use the latest released version of gtk2hs, which does work with ghc-6.6 and 6.6.1
05:48:13 <nominolo> dylan: yes, Open Dylan 1.0 beta 4
05:48:24 <cacilhas> hehehehe... how much options! where can I find the darcs version?
05:48:47 <cacilhas> I'm using ghc-6.6
05:49:12 <nominolo> dylan: the native representation of haskell data types isn't documented either.
05:49:29 <dcoutts_> cacilhas, via the wxhaskell site, of course being a developer of gtk2hs I'm biased and think you should try that instead ;-)
05:49:31 <cacilhas> anyway... I will look for gtk2hs
05:49:50 <dcoutts_> @where wxhaskell
05:49:51 <lambdabot> http://wxhaskell.sourceforge.net/
05:49:51 <dcoutts_> @where gtk2hs
05:49:51 <lambdabot> http://haskell.org/gtk2hs/
05:49:52 <cacilhas> dcoutts_: ok!!!
05:50:01 <cacilhas> thanks
05:50:06 <dcoutts_> np
05:50:31 <nominolo> cacilhas: the wxhaskell release version doesn't compile everywhere.  you have to use the darcs version
05:50:35 <dylan> nominolo: btw, I've never used the language that bears the same name as me, except trying to understand some of chris double's codea long, long time ago. :)
05:51:40 <nominolo> dylan: yeah, the name wasn't that well-chosen
05:53:01 <dylan> nominolo: mine was well-chosen, I think.
05:53:07 <assl0r> hi
05:53:07 <cacilhas> ./configure-ing gtk2hs!!!
05:53:15 <sphynx> hi all!
05:53:19 <cacilhas> let's see what's happen!
05:53:24 <cacilhas> hi
05:53:39 <dylan> being named after a welsh sea god, a drunken welsh poet, and a folk-rock singer is fun.
05:53:45 <assl0r> is there a way to print out the reduction of expressions step for step, to check out if the program is tail recursive etc.?
05:54:01 <nominolo> dylan: heh
05:54:03 <sphynx> I'm reading Parsec tutorial, one of the first examples is about parens, but is seems a bit buggy
05:54:17 <sphynx> parens parser is defined as follows:
05:54:20 <osfameron> dylan: also the Investigator of Nightmares!
05:54:54 <sphynx> parens = do { char '('; parens; char ')'; parens } <|> return ()
05:55:35 <sphynx> and it parses '())' without any errors...
05:56:27 <sphynx> though it is string with unmatched parens. It seems that there is needed something like EOF after last 'parens', am I right?
05:56:33 <nominolo> sphynx: but only up to the second ")", right?
05:56:44 <cacilhas> dcoutts_: wow... it's telling me that's missing ghc package "mtl"... it's new for me
05:56:59 <nominolo> @where mtl
05:56:59 <lambdabot> www.cs.brown.edu/~jwicks/mtl_reference/
05:57:01 <sphynx> nominolo, it seems so, but I dunno how to check this yet :)
05:57:18 <nominolo> sphynx: it should be the second result argument
05:57:25 <nominolo> @where parsec
05:57:26 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
05:57:37 <sphynx> nominolo, it returns always ()
05:57:41 <dcoutts_> cacilhas, yep, you'll need ti install that, it probably comes with your distro
05:57:48 <sphynx> parens :: Parser ()
05:57:57 <dcoutts_> cacilhas, if your distro had ghc it'll have mtl too
05:58:02 <nominolo> sphynx: no, the run function returns two args
05:58:33 <cacilhas> my distro has not... heheheheheh
05:58:33 <nominolo> oh, no, it doesn't
05:58:51 <cacilhas> I make the ghc package with rpm2tgz
05:59:03 <sphynx> *ParTest> run parens "(())"
05:59:03 <sphynx> ()
05:59:03 <sphynx> *ParTest> run parens "((()))"
05:59:03 <sphynx> ()
05:59:39 <sphynx> nominolo, yeah, in this case it returns always ()
05:59:44 <dcoutts_> cacilhas, ok then check out the extralibs tarball and install mtl from there using cabal
06:00:11 <nominolo> maybe you need an eof token or something
06:00:20 <sphynx> nominolo, so I think example should be just modified a bit
06:00:23 <cacilhas> dcoutts_: ok! i'm doing it now!
06:00:45 <cacilhas> using cabal?
06:01:29 <sphynx> nominolo, because it is a bit confusing now :) well,  I'll continue reading. Just want to know that I understand all correct
06:01:41 <sphynx> nominolo, thanks!
06:04:48 <nominolo> ok, if you run parse (parens >> eof) "" "())" it complains
06:05:50 <nominolo> it should be noted in the docs (more clearly), though, that it need not consume the full input to succeed
06:07:22 <nominolo> sphynx: this behavior, however, is important for composability
06:08:04 <cacilhas> dcoutts_: excuse my complete ignorance, but the source package for mtl is very strange for me... i'm very accostumed to use ./configure && make &&make install...
06:08:05 <quicksilver> is there a variant of run which also returns the unconsumed part?
06:08:38 <cacilhas> there's Setup.hs and mtl.cabal... how it works?
06:08:57 <nominolo> quicksilver: you could build your own
06:09:36 <sphynx> nominolo, so there must be not 'eof' but something like 'NOT parens'
06:10:13 <nominolo> i.e. run' p = run (do x <- p; rest <- many any; return (x,rest)
06:11:15 <nominolo> sphynx: no, it depends on what you want it to do.  parens will parse as many matching parens as it can.
06:12:13 <nominolo> sphynx: but if you want the complete input to consist of matching parens only, you need to request this explicitly, by stating "parens and nothing
06:12:14 <sphynx> nominolo, ok, I've understood
06:12:23 <nominolo> .. more"
06:13:54 <cacilhas> opsss.... I think I've found
06:16:32 <nominolo> quicksilver: run' p = parse (do x <- p; rest <- getInput; return (x,rest)) ""
06:17:12 <nominolo> quicksilver: run' :: GenParser tok () t -> [tok] -> Either ParseError (t, [tok])
06:19:51 <ddarius> :t runParser
06:19:53 <lambdabot> Not in scope: `runParser'
06:20:08 <ddarius> :index runParser
06:20:15 <ddarius> @index runParser
06:20:15 <lambdabot> Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec
06:20:31 <ddarius> @hoogle runParser
06:20:32 <lambdabot> Text.ParserCombinators.Parsec.Prim.runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
06:20:54 <ddarius> Whatever.
06:26:24 <nominolo> yes, runParser would be more general since it allows state
06:26:39 <nominolo> but it doesn't return the rest of the parse
06:30:34 <dcoutts_> cacilhas, it's much like ./configure && make && make install except that instead it's: runghc Setup.hs configure && runghc Setup.hs build && runghc Setup.hs install
06:30:49 <cacilhas> ok!
06:30:59 <cacilhas> I got to install!
06:31:11 <cacilhas> i got to install mtl and hsc2hs...
06:31:17 <nominolo> or 'runhaskell' instead of 'runghc'
06:31:25 <cacilhas> hehehe
06:31:45 <nominolo> in case you prefer hugs, nhx, yhc, ...
06:31:46 <cacilhas> i used:
06:31:47 <cacilhas> ghci Setup.py
06:31:47 <cacilhas> :main configure
06:31:47 <cacilhas> :main build
06:31:47 <cacilhas> :main install
06:32:02 <cacilhas> it worked ;-)
06:32:10 <nominolo> Setup.__py__ ?
06:32:20 <cacilhas> but now I have another problem :-P
06:32:37 <cacilhas> while I run make
06:36:30 <cdsmith> What's the easiest way to get darcs on Windows?  The links to binaries appear to be not working (zooko.org server isn't responding).  Do I need to build from source?
06:38:18 <matthew-_> can you make fix work on stuff inside monads? I presume not.
06:38:23 <araujo> morning
06:38:30 <nominolo> matthew-_: you need mfix
06:38:46 <nominolo> matthew-_: it's inside the MonadFix class
06:39:04 <matthew-_> fantastic. thanks
06:40:14 <nominolo> matthew-_: the documentation is close to non-existant, but there's a nice paper
06:41:34 <matthew-_> nominolo: I'm quite used to that ;)
06:42:08 <matthew-_> frankly, I'm just expecting it to work - the function used to use fix, and I've just had to bring in IO, so I'm hoping it'll just work
06:42:09 <Saizan> there's also an article by roconnor on TMR 6
06:42:42 <nominolo> if you don't want to use mfix, you can also use the "mdo" syntax
06:42:45 <Cheery> does there exist an action which returns milliseconds/seconds after last call into the action?
06:43:38 <qwr> Cheery: you may write it...
06:44:22 <Cheery> yes, but it requires IORefs, which I don't think I like.
06:44:45 <nominolo> Cheery: you can't get this kind of action outside IO
06:45:18 <Cheery> true
06:45:42 <taruti> miten se toinen?
06:45:47 <taruti> sorry
06:48:14 <fasta> When I import Control.Monad.ST, my program compiles, but when I import Control.Monad.ST.Lazy is doensn't. Wtf? (I get a type error no duplicate bindings or anything like that)
06:48:51 <dcoutts_> @docs Control.Monad.ST.Lazy
06:48:51 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-ST-Lazy.html
06:49:05 <fasta> ok, I see the problem
06:49:22 <fasta> It appears matching pairs of Data.Ref and STRef need to be imported
06:49:35 <Cheery> I somehow hate that yampa requires IO monad.
06:49:57 <Cheery> it'd been so easy to just give it a StateT -monad instead of playing with stupid IORefs. :/
06:50:45 <LoganCapaldo> Is there an IOT ?
06:50:52 <Cheery> oh well, experimenting with it this time, if I like it, I think I refactor it a bit.
06:50:54 <Cale> LoganCapaldo: no, it's impossible
06:51:15 <LoganCapaldo> So IO /= IOT Identity eh?
06:51:15 <Cheery> why would one need IOT?
06:51:29 <LoganCapaldo> I dunno
06:51:31 <Cheery> LoganCapaldo: no
06:52:01 <Cheery> T behind stands for Transformer, not for idenTity
06:52:26 <LoganCapaldo> I know
06:52:26 <Cheery> transformers allows you to compose monads
06:52:44 <nominolo> Cheery: he applied IOT to Identity ;)
06:53:06 <Cheery> @hoogle IOT
06:53:06 <lambdabot> Data.Array.Diff.IOToDiffArray :: data IOToDiffArray a i e
06:53:07 <lambdabot> GHC.Conc.unsafeIOToSTM :: IO a -> STM a
06:53:07 <lambdabot> Control.Monad.ST.unsafeIOToST :: IO a -> ST s a
06:53:19 <nominolo> LoganCapaldo: that would require a run function for IO
06:53:29 <Cheery> nominolo: ok, my bad.
06:53:41 * LoganCapaldo mumbles something about unsafePerformIO
06:53:47 <LoganCapaldo> Ok
06:53:53 <LoganCapaldo> so that answers that question
06:53:56 <LoganCapaldo> thanks
06:54:17 <DukeDave> Hey gang, does anyone know how to (temporarily) change the working directory in a makefile?
06:54:48 <Saizan> unsafePerformIO doesn't necessarily run your actions
06:55:10 <nominolo> DukeDave: i usually do cd <dir> && command
06:56:00 <DukeDave> Haha, can't believe I didn't think of that :)
06:56:41 <DukeDave> I had them on seperate lines, e.g.     cd foo \n command \n cd ..
06:56:58 <DukeDave> But that doesn't work as expected
06:57:29 <LoganCapaldo> Saizan: Yes, yes. I got to curtail my spouting of nonsense in this channel. People don't seem to like it
06:58:38 <shapr> Good morning #haskell!
06:58:41 <nominolo> @where hlist
06:58:42 <lambdabot> http://homepages.cwi.nl/~ralf/HList
06:58:58 <Lemmih> Good morning, shapr.
06:59:31 <shapr> Wassup?
07:00:39 <nominolo> DukeDave: replacing "\n" with "&& \\\n" helps wonders :)
07:01:12 <DukeDave> Oh, lol, just put in \n to indicate "new line"
07:01:13 <nominolo> shapr: TMR 7 issup
07:01:15 <DukeDave> lol
07:02:20 <nominolo> DukeDave: i was just trying to say, that you can still nicely put it on several lines..
07:03:09 <DukeDave> Ah I see, good thinking :)
07:10:32 <dons> hey shapr. got TMR?
07:12:10 <cdsmith> ok, when building lambdabot: "cannot satisfy dependency unix-any" -- can I not build lambdabot on Windows?
07:12:58 <dons> not with the unix stuff. people^h^h^h rare hackers have managed in the past, by diving into the source, to build it on windows, but its not for the faint hearted
07:12:59 <shapr> dons: Haven't seen it yet.
07:13:10 <shapr> swiert_: Good job with TMR! w00!
07:13:12 <shapr> swiert++
07:13:19 <dons> shapr: start here, http://programming.reddit.com/ :-)
07:13:21 <lambdabot> Title: reddit.com: programming - what&#39;s new online
07:13:34 <cdsmith> dons: okay, that's a shame.  Thanks.
07:14:55 <shapr> I've been dreaming of a laziness tutorial lately.
07:15:29 <shapr> Is the TMR source available also so I can play with the code?
07:15:57 <shapr> dons: Oh hey, I used quickcheck2 to check cryptolib and found a bug :-)
07:16:00 <dons> it is, check the wiki. http://www.haskell.org/haskellwiki/The_Monad.Reader
07:16:01 <lambdabot> Title: The Monad.Reader - HaskellWiki
07:16:07 <dons> shapr: oh nice! qc2 eh?
07:16:17 <shapr> It seems that qc1 generates too many trivial cases, and the version in bringert's repository is much improved.
07:16:19 <dons> shapr: i'm just finishing an article on using qc to check xmonad
07:16:24 <dons> mmm.
07:16:26 <shapr> Are you using qc2?
07:16:33 <dons> only what's on hackage.
07:16:55 <dons> url?
07:16:57 <shapr> I was most entertained to see "failing input (after 2 shrinks)"
07:17:08 <dons> mm.tasty. otherwise the api is mostly unchanged?
07:17:26 <shapr> http://www.cs.chalmers.se/~bringert/darcs/QuickCheck
07:17:30 <lambdabot> Title: Index of /~bringert/darcs/QuickCheck
07:17:47 <dons> ok. i'll check xmonad against this guy.
07:18:08 <shapr> I had forgotten I had bringert's QC2 installed, and cryptolib's properties all built fine.
07:18:37 <dons> great!
07:23:21 <shapr> Are the xmonad quickcheck properties available from runhaskell Setup.lhs test/check/something?
07:24:09 <dons> ghc --make tests/Properties.hs && tests/Properties
07:24:19 <dons> assuming ghc 6.6 and normal xmonad deps are satisfied
07:24:41 <shapr> Hm, I'd say the api has changed.
07:24:48 <dons> $ ghc --make tests/Properties.hs && tests/Properties
07:24:48 <dons> StackSet invariants      : OK, 100 tests.
07:24:48 <dons> empty is empty           : OK, 100 tests.
07:24:49 <dons> ...
07:24:52 <dons> for QC1.
07:28:55 <matthew-_> nominolo: gah, it wasn't mfix I wanted, it was just fix, where the a in fix :: (a -> a) -> a is (b -> m b). Took me some time to work out the types I actually was after!
07:29:29 <shapr> dons: Yeah, looks like the qc api has changed some.
07:31:31 <nominolo> matthew-_: oh.  yes, this is where haskell makes you feel smart and stupid at the same time ...
07:32:16 <nominolo> matthew-_: i wonder why you had to use 'fix' directly.  in most cases it's hidden inside 'let'
07:33:15 <matthew-_> nominolo: in the non-IO version, I could just lazily grab the 'updated' value, thus no need for the fix.
07:33:44 <matthew-_> but in the IO version, because of the use of do (?!), I couldn't
07:34:00 <matthew-_> I think. Anyway, was probably good mental exercise to use fix!
07:34:06 <nominolo> > fix (\f x -> if x == 0 then 0 else f (x * (x-1))) 5
07:34:10 <lambdabot> Terminated
07:34:58 <nominolo> @src Identity mfix
07:34:59 <lambdabot> mfix f = Identity (fix (runIdentity . f))
07:35:14 <nominolo> @src StateT mfix
07:35:14 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
07:35:19 <nominolo> @src State mfix
07:35:20 <lambdabot> Source not found. Wrong!  You cheating scum!
07:35:25 <nominolo> @instances MonadState
07:35:26 <lambdabot> s (ContT r m), s (ErrorT e m), s (RWS r w s), s (RWST r w s m), s (ReaderT r m), s (State s), s (StateT s m), s (WriterT w m)
07:35:30 <nominolo> @instances MonadFix
07:35:32 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
07:36:02 <nominolo> me not cheating, lambdabot cheating -.-
07:36:14 <nominolo> @slap lambdabot
07:36:15 * lambdabot slaps lambdabot
07:36:20 <matthew-_> bully!
07:36:59 <nominolo> @src fix
07:37:00 <lambdabot> fix f = let x = f x in x
07:37:42 <matthew-_> that line breaks my head. Utterly.
07:38:10 <Saizan> fix f = f (fix f) is this better?:)
07:38:18 <dons> its using haskells recursion to implement a recursion operator :-)
07:38:38 <matthew-_> Saizan: yes, that hurts much less
07:41:26 <Baughn> matthew-_: Eh, I like the first one better. It's good at confusing people.
07:41:55 <hpaste>  matthew-_ pasted "using IO and fix: can you rewrite the bottom into the top without using fix explicitly?" at http://hpaste.org/1622
07:43:34 <nominolo> :t let fac = fix (\f x -> if x == 0 then 1 else x * f (x-1)) in fax
07:43:36 <lambdabot> Not in scope: `fax'
07:43:38 <nominolo> :t let fac = fix (\f x -> if x == 0 then 1 else x * f (x-1)) in fac
07:43:41 <lambdabot> forall a. (Num a) => a -> a
07:43:48 <nominolo> > let fac = fix (\f x -> if x == 0 then 1 else x * f (x-1)) in fac 5
07:43:50 <lambdabot>  120
07:48:55 <shapr> dons: I hacked Properties.hs to just call quickCheck <property> and everything still passed.
07:50:19 <shapr> sjanssen: I ran xmonad's Properties.hs with QuickCheck2. Though QC2 found bugs in cryptolib, it did not find any problems with xmonad, yay!
07:51:09 <dons> great, shapr.
07:51:27 <dons> so quickCheck prop is the same, but runTests has changed(oh, i guess the custom drivers broke?)
07:51:52 <shapr> Yup, looks like it.
07:52:15 <shapr> QC2 comes with a bunch of really cool examples.
07:52:20 <emu> QC2?
07:53:07 <emu> sounds exciting
07:53:17 <shapr> Looks like you can optionally explicitly specify how to shrink an input. That's interesting.
07:55:42 <JaffaCake> does anyone know anything about the robots.txt file on haskell.org currently?
07:55:52 <emu> what does 'shrinking' mean?
07:56:01 <JaffaCake> i.e. why are we disallowing all robots currently?
07:56:21 <emu> there was a problem last night
07:56:26 <sproingie> emergency measure i would imagine
07:56:29 <SamB_XP_> what problem?
07:56:31 <sproingie> the wiki was getting hammered
07:56:46 <SamB_XP_> couldn't you just disallow the one bot that was hammering the wiki?
07:56:52 <emu> some chinese spider
07:56:56 <sproingie> i dont think they knew
07:57:27 <JaffaCake> I want to let google spider the mail archives
07:58:19 <JaffaCake> looks like dcoutts_ touched it last
07:59:42 <SamB_XP> wouldn't the User-Agent from the logfiles say?
08:02:17 <SamB_XP> JaffaCake: can you read the logfiles?
08:02:26 <emu> yep dcoutts was dealing with it last night. he said it might be some IP.
08:02:46 <JaffaCake> thanks all, I'll ask dcoutts
08:02:52 <emu> 218.61.148.111
08:03:34 <matthew-_> well that's part of a class B: 218.60.0.0 - 218.61.255.255
08:03:55 <matthew-_> or, two class Bs, concatenated.
08:06:56 <nominolo> emu: shrinking means, that QC trys to find smaller inputs that still fail the test
08:07:55 <emu> matthew-_: it's owned by some Chinese firm
08:07:59 <emu> hence my comments
08:08:05 <matthew-_> yup
08:08:18 <emu> nominolo: thn
08:08:19 <emu> x
08:11:50 <dcoutts_> JaffaCake, hia
08:11:58 <JaffaCake> hi there
08:12:33 <dcoutts_> JaffaCake, we don't need to bad robots completely
08:13:01 <JaffaCake> parse error: no verb :)
08:13:12 <SamB_XP> so do you know the User-agent: for that bot yet?
08:13:12 <dcoutts_> heh, bad/ban
08:13:17 <JaffaCake> aah
08:13:27 <sproingie> huh, looking at how State combines with Random, it looks like random and randomR were pretty much made to use State
08:13:35 <dcoutts_> JaffaCake, we were having serious problem in the past with robots reading all possible combinations of diffs between versions of wiki pages
08:13:47 <SamB_XP> !
08:13:49 <JaffaCake> right, I see
08:13:51 <sproingie> is there anything else in the libraries like that?  hoogle isn't helping me much
08:13:59 <SamB_XP> huh
08:14:06 <dcoutts_> JaffaCake, and this was slowing things to a crawl, filling up all 150 http client processes and effectively DoSing the server for everyone
08:14:08 <JaffaCake> isn't the wiki supposed to add the right meta tags to stop that?
08:14:32 <dcoutts_> JaffaCake, perhaps, it might have been a badly written robot
08:15:17 <dcoutts_> JaffaCake, so it wasn't that it was saturating cpu or network even, just taking all 150 http child processes
08:15:32 <SamB_XP> "all possible"?
08:15:34 <dcoutts_> JaffaCake, it also seemed to be holding those connections open and idle, not sure why.
08:15:37 <sproingie> you need a blackhole url
08:15:50 <SamB_XP> sproingie: how do they work?
08:15:51 <JaffaCake> ok, so do you know a more restrictive set of URLs we could use?
08:16:11 <sproingie> SamB_XP:  it's a cgi.  you fetch it and your IP goes into the firewall tables
08:16:19 <SamB_XP> ah.
08:16:28 <dcoutts_> JaffaCake, anything involving the wiki history pages
08:16:44 <SamB_XP> dcoutts: unfortunately...
08:16:45 <dons> JaffaCake: yeah, twice over the weekend haskell.org was unreponsive for several hours.
08:16:48 <SamB_XP> they have urls like:
08:16:53 <SamB_XP> http://haskell.org/haskellwiki/?title=Haskell&action=history
08:16:57 <lambdabot> Title: Haskell - History - HaskellWiki
08:17:08 <dons> i pinged Paul H about it. Most likely due to spiders (it has been in the past, always on sundays)
08:17:12 <JaffaCake> SamB_XP: so there's no way to match that in robots.txt?
08:17:22 <dcoutts_> JaffaCake, eg http://haskell.org/haskellwiki/?title=The_Monad.Reader&diff=11038&oldid=11036
08:17:24 <lambdabot> Title: The Monad.Reader - HaskellWiki, http://tinyurl.com/2x97j7
08:17:28 <SamB_XP> I don't think there is
08:17:50 <JaffaCake> ok, at the least I could just disable /haskellwiki, and that would open up /pipermail
08:17:50 <matthew-_> you should alter the wiki so that it'll only do diffs on POST (unless the bot is infact submitting POSTs)
08:18:01 <dcoutts_> JaffaCake, right
08:18:43 <SamB_XP> or maybe take out the (cur) and (last) links
08:18:43 <DRMacIver> The paper on OCaml in the Monad.Reader 7 is interesting. I like the line "Moreover, OCaml has other less confusing techniques (notably parametric polymorphism, functors and closures) for achieving what would be achieved using inheritance in an object-oriented language."
08:18:54 <JaffaCake> maybe it's possible to open it up to just certain spiders?
08:18:59 <sproingie> might want to take out the old wiki too
08:19:10 <SamB_XP> JaffaCake: sure
08:19:18 <sproingie> or iow, add it to robots.txt
08:19:32 <JaffaCake> thanks folks
08:19:36 <dcoutts_> JaffaCake, yeah, like google. I recall it was some wierd named robot that was causing problems before. I don't remember what it was called exactly. This was months and months ago.
08:19:38 <matthew-_> or, (and this is less preferable), use javascript to form the urls for the diffs dynamically. It's unlikely the bots will run it, but it also means you loose functionality with JS turned off.
08:19:39 <SamB_XP> sproingie: did moinmoin have those issues?
08:20:07 <dcoutts_> JaffaCake, but I recall that the user agent did belong to a known web spider.
08:20:10 <SamB_XP> matthew-_: well, my proposal would take that functionality away entirely
08:20:20 <sproingie> SamB_XP: any dynamic site will have that kind of problem.  moin can generate urls infinitely too
08:20:28 <JaffaCake> dons: so haskell.org was DOSed by spiders even though we have everything disallowed in robots.txt?  bad spiders that aren't respecting robots.txt?
08:20:41 <SamB_XP> sproingie: but I bet it doesn't have (cur) links
08:20:45 <ndm> we really do need haskell.org searching back...
08:20:57 <Wild_Cat> in soviet China, robots txt YOU!!
08:21:04 <JaffaCake> brb
08:21:37 <dons> JaffaCake: that's only the suspicion, other things kept working, not haskell.org, and then it came back up by itself. Just rumour based on what happened last time.
08:21:37 <ndm> Wild_Cat: communist, soviet == russia
08:22:08 <sphynx> I have one more question about Parsec.
08:22:18 <matthew-_> yes, you can exclude individual bots if you know their useragent: http://www.robotstxt.org/wc/exclusion-admin.html
08:22:21 <lambdabot> Title: Web Server Administrator's Guide to the Robots Exclusion Protocol
08:22:32 <nominolo> i am confused. i have "class (FooA f a, FooB f b, FooC f c) => Foo f where mkA :: a; mkB :: b, mkC :: c" and I get a complaint, that the type variables a,b,c in the class constraints are not in scope
08:22:36 <nominolo> any ideas?
08:22:43 <ndm> who/how do i bug report that Windows+' ' in file path+haddock+cabal goes a bit crazy?
08:22:57 <ndm> i think that cabal is the main part at fault, but its hard to know for sure
08:23:11 <Wild_Cat> ndm: yes, but russian reversals become less and less recognizable once you start replacing key terms such as "soviet", "Russia" and "YOU!!" :p
08:23:47 <Igloo> ndm: The "how" is by sending a patch, and the "who" is dcoutts  :-)
08:24:12 <matthew-_> nominolo: I think you want: "class (FooA f a, FooB f b, FooC f c) => Foo f a b c where..."
08:24:20 <ndm> Igloo: in this case the "how" is by copying things to D:\bin, since its about 1000 times quicker...
08:24:29 <Igloo> heh
08:24:49 <malcolmw> nominolo: you can only mention ty vars from the head of the instance, not from its context (if they don't also appear in the head)
08:24:58 <ndm> i don't mind patching haddock, hscolour, cpphs, hoogle etc - but at cabal i draw the line, since it goes wrong so often i could spend all my time forever patching cabal
08:25:03 <nominolo> matthew-_: hm.  I tried without the FooA and used functional dependencies, but i ran into problems at another place :/
08:25:26 <SyntaxNinja> ndm: you're a trouble maker
08:25:36 <ndm> SyntaxNinja: you mean windows user :)
08:25:56 <sphynx> is it possible to lookahead for 1 token somehow but don't parse it?  For example, I want to define if the token is id of variable of id of function (token is id of function if next token is "(")
08:25:56 <sphynx> I can write something like func = do { id; char '(' }, but I don't want to parse '(' in this clause, cause I have already parser lparen = char '('
08:26:26 <SyntaxNinja> ndm: there are only a handful of active windows users in the Haskell development community.  we need your help :)
08:26:30 <sphynx> if I would write something like func = do { id; lparen; } then I need to return two tokens at once from this parser...
08:26:59 <dcoutts_> ndm, can you describe the problem more precisely?
08:27:14 <dcoutts_> SyntaxNinja, we should move cabal to use ndm's filepath package
08:27:23 <chessguy> 'morning, haskellers
08:27:27 <Saizan> sphynx: there is a lookAhead combinator
08:27:31 <ndm> dcoutts_, configure detects haddock in "c:\program files\haskell\bin\haddock"
08:27:34 <dcoutts_> SyntaxNinja, that way we can blame him when it doesn't work on windows ;-)
08:27:35 <Saizan> ?hoogle lookAhead
08:27:36 <lambdabot> Text.ParserCombinators.Parsec.Combinator.lookAhead :: GenParser tok st a -> GenParser tok st a
08:27:36 <lambdabot> IO.hLookAhead :: Handle -> IO Char
08:27:41 <nominolo> malcolmw, matthew-_: thanks.  now i'm back to my original problem :P
08:27:55 <ndm> dcoutts_, but then i get an error: 'c:\program' is not recognized as an internal or external command,
08:28:00 <sphynx> Saizan, cool, I will look. Thanks!
08:28:04 <SyntaxNinja> dcoutts_: excellent idea.  maybe our soc friend can do it in his copious free time :)
08:28:15 <dcoutts_> ndm, right.
08:29:15 <malcolmw> SyntaxNinja: did someone obliquely mention nominolo and Cabal bugs?
08:29:39 <dcoutts_> ndm, is that perhaps in a generated .bat file? the error message "is not recognized as an internal or external command" usually comes from cmd.exe, it's not a Haskell error message as far as I know.
08:30:00 <ndm> dcoutts_, i don't know, does cabal generate .bat files? (if so, yuk, it shouldn't!)
08:30:25 <ndm> dcoutts_, but it does indeed look like the cmd.exe message - although perhaps haskell invokes "cmd.exe haddock"
08:30:28 <sphynx> Saizan, hm, it seems that lookAhead is not covered in latest PDF Parsec doc
08:30:53 <dcoutts_> ndm, registration scripts are .bat files on windows, .sh files on unix
08:31:08 <ndm> dcoutts_, yuk - why?
08:31:09 <SyntaxNinja> malcolmw: heh yeah
08:31:24 <dcoutts_> ndm, how else do you do delayed registration?
08:31:27 <ndm> dcoutts_, although this is at haddock time, is that still registration time?
08:31:33 <dcoutts_> no
08:31:45 <ndm> dcoutts_, in that case this isn't .bat time?
08:31:51 <dcoutts_> ndm, it could easily happen by lack of quoting in a .bat file, but we always use the rawsystem calls so it passes the command name and all args separately so there should be no quoting problems
08:32:15 <dcoutts_> ndm, I didn't think we used .bat files anywhere other than when generating package registration scripts
08:32:32 <ndm> dcoutts_, in that case its probably not that
08:33:41 <malcolmw> does Cabal maybe do a call to "words" somewhere before calling out to rawSystem?
08:34:55 <dcoutts_> malcolmw, ndm: it uses rawSystemProgram
08:35:26 <dcoutts_> in Distribution/Program.hs, which calls rawSystemExit which calls rawSystem
08:35:58 <dcoutts_> ndm, when you stick up the verbose level, what do you see?
08:36:26 <dcoutts_> ndm, does it look like rawSystemExit is being given the full path? or has it been lost already by that point?
08:39:39 <SyntaxNinja> I got an espresso machine this weekend. yum.
08:40:04 <ndm> dcoutts_, how do i specify a higher verbose level?
08:40:11 <dcoutts_> ndm, -v2
08:40:18 <dcoutts_> SyntaxNinja, so you'll be able to bounce off the walls at home as well as work? :-)
08:40:30 <ndm> dcoutts_, thats what i thought - it makes no difference...
08:40:32 <ndm> @paste
08:40:32 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:40:34 <mahogny> SyntaxNinja, does that have something to do with the upcoming ICFP? :P
08:40:41 <dcoutts_> ndm, -v5 ! :-)
08:40:50 <dcoutts_> ndm, what cabal version are you using there?
08:41:05 <hpaste>  ndm pasted "cabal errors" at http://hpaste.org/1623
08:41:20 <SyntaxNinja> dcoutts_: exactly.
08:41:23 <ndm> dcoutts_, v5 is what i originally tried
08:41:26 <SyntaxNinja> ndm: crank it up to 5 actually
08:41:28 <SyntaxNinja> heh
08:41:40 <ndm> dcoutts_, same with -v5
08:41:52 <ndm> how do i get the .cabal version?
08:42:00 <dcoutts_> ghc-pkg list
08:42:01 <ndm> i have so many versions on so many machines, i forget...
08:42:18 <ndm> Cabal-1.1.6, Cabal-1.1.7
08:42:24 <ndm> does that mean its picking 1.1.7?
08:42:30 <dcoutts_> ndm, probably
08:42:57 <dcoutts_> ndm, if you don't mind, if you could try with the latest 1.1.7 darcs version
08:43:13 <dcoutts_> ndm, Igloo did some good work makeing the verbose logging more consistent
08:43:23 <dcoutts_> especially when it comes to invoking external progs
08:43:53 <ndm> dcoutts_, just doing so...
08:43:53 <Igloo> I don't think it'll ever show what's being executed as a list, rather than concatenating it, though, will it?
08:43:59 <SyntaxNinja> ndm: take a look in your .setup-config, how does the quoting look there?
08:44:07 <SyntaxNinja> (or paste it)
08:44:14 <dcoutts_> Igloo, no probably not, but that's ok I think
08:44:49 <ndm> doh, the cabal won't compile because of the user hooks issue!
08:45:01 <SyntaxNinja> after configure it writes out the information .setup-config and then reads it in, that sounds the most suspicious to me.
08:45:22 <hpaste>  ndm annotated "cabal errors" with ".setup-config" at http://hpaste.org/1623#a1
08:46:05 <ndm> can i really suggest you remove the Maybe Hooks issue from the Setup.lhs in Cabal itself?
08:46:09 <ndm> it breaks upgrading totally
08:46:31 <SyntaxNinja> looks pretty good: "c:\\program files\\haskell\\bin\\haddock.exe"}
08:48:16 <dcoutts_> ndm, SyntaxNinja: I think the problem might be with rawSystem or System.Process.Internals.runProcessWin32 itself
08:48:35 <ndm> dcoutts_, i am nearly there with a new cabal, so can tell you then
08:48:43 <ndm> but really, do remove that offending line in setup.lhs!
08:48:50 <ndm> i can even send a patch :)
08:48:58 <dcoutts_> ndm: we fixed Cabal's own Setup.lhs
08:49:06 <dcoutts_> ndm: which one are you talking about?
08:49:12 <ndm> dcoutts_, not as far as i can tell...
08:49:17 <ndm> dcoutts_, i had to manually patch it
08:49:20 <dcoutts_> ndm: you must be missing a patch
08:49:28 <dcoutts_> I fixed it myself
08:49:32 <ndm> when?
08:49:39 <dcoutts_> just after Igloo broke it! :-)
08:49:50 <ndm> @hpaste
08:49:51 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:49:53 <dcoutts_> I applied both patches at the same time
08:49:58 <hpaste>  ndm pasted "cabal changes" at http://hpaste.org/1624
08:49:59 <dcoutts_> applied/pushed whatever
08:50:13 <ndm> dcoutts_, check that paste
08:50:49 <ndm> dcoutts_, brand new .cabal installed, absolutely no difference in the messages i get
08:51:05 <ndm> including a total lack of -v information
08:51:31 <dcoutts_> ndm: check the current version: http://darcs.haskell.org/cabal/Setup.lhs
08:51:44 <dcoutts_> ndm: perhaps the -vN is getting lost
08:52:44 <ndm> dcoutts_, with that version, it doesn't work
08:52:54 <ndm> dcoutts_, you need the extra deleted lines, as per my diff
08:53:32 <dcoutts_> ndm: that type is correct for that version of cabal
08:53:45 <ndm> dcoutts_, yes, but its not massively helpful when upgrading .cabal
08:53:55 <dcoutts_> ndm: it bootstraps itself
08:54:17 <dcoutts_> runghc Setup.lhs actually uses the current cabal code
08:54:21 <ndm> dcoutts_, true, but why not remain just a little more compatible? for a little more useful?
08:54:29 <dcoutts_> ndm: fine, send a patch
08:54:47 <dcoutts_> ndm: where were we...
08:55:02 <ndm> i'll try that method directly, previously it didn't work doing that, so i went straght for --make
08:55:12 <ndm> ah, it works now :)
08:55:19 <dcoutts_> --make should work too
08:55:28 <ndm> previously i needed --make -i
08:56:32 <dcoutts_> to make it not work you'd somehow have to use the current Setup.lhs and not use the local code but rather an existing cabal package, I'm not soure how you'd make the package override the local code
08:56:45 <ndm> i don't know, but it used to relibably screw up for me
08:56:47 <dcoutts_> ndm: how did you make it break actually? I can't think how
08:56:52 <ndm> works now though, so i'm perfectly happy
08:57:02 <dcoutts_> ok :-)
08:57:13 <ndm> apart from the haddock thing, which still doesn't
08:57:16 <dcoutts_> ndm: so my suspicion is that rawSystem is actually broken
08:57:19 <dcoutts_> on win32
08:57:24 <ndm> i'm not convinced its using the new .cabal even though i've installed it
08:57:35 <ndm> it should definately -v something
08:57:40 <dcoutts_> ndm: can you test rawSystem invoking haddock --help or something in ghc ?
08:57:42 <dcoutts_> ghci
08:57:49 <ndm> so perhaps you can check that -v with haddock gives some output?
08:57:57 <ndm> i have to run now, but back in ab out an hour
08:58:00 <dcoutts_> ok
08:59:25 <SyntaxNinja> darn
08:59:53 <SyntaxNinja> ndm: when you get back, just try running rawSystem in ghci with the path from configure and see what happens, that'll help narrow things down
09:01:01 <dcoutts_> ndm: also, I do get verbose output from setup haddock -v
09:01:24 <dcoutts_> in fact I always get verbose output whether I ask for it or not :-(
09:01:38 <SyntaxNinja> ndm: be verbose so dcoutts_ doesn't have to ;)
09:01:44 <dcoutts_> Igloo: the verbosity levels are still stuffed up
09:01:53 <dcoutts_> Igloo: what did you say the solution was?
09:02:03 <dcoutts_> Igloo: -v0 works fine
09:02:06 <Igloo> dcoutts_: If -v0 is silent then there's just a 1 that needs changing to a 2 somewhere
09:02:17 <Igloo> Or maybe a 0 to a 1
09:03:13 <dcoutts_> rawSystemExit :: Int -> FilePath -> [String] -> IO ()
09:03:13 <dcoutts_> rawSystemExit verbose path args = do
09:03:13 <dcoutts_>   when (verbose > 0) $
09:03:13 <dcoutts_>     putStrLn (path ++ concatMap (' ':) args)
09:03:20 <dcoutts_> Igloo: ^^ that'll be it right?
09:03:21 <quicksilver> of course it's an off-by-1 error
09:03:27 <Igloo> Yup
09:03:29 <quicksilver> the code type-checks, and compiles... so what else could it be?
09:03:34 <quicksilver> off-by-1 is all that's left!
09:03:35 <quicksilver> :)
09:06:30 * dcoutts_ pushes
09:26:41 * ndm pulls
09:26:58 <ndm> SyntaxNinja: rawSystem from where?
09:27:15 * igli says "get a room" ;)
09:27:16 <ndm> h rawSystem
09:27:24 <ndm> @hoogle rawSystem
09:27:25 <lambdabot> System.Cmd.rawSystem :: String -> [String] -> IO ExitCode
09:28:06 <ndm> SyntaxNinja: rawSystem works just fine
09:28:49 <ndm> dcoutts_, so my guess is that my cabal isn't getting upgraded, since i get no verbose messages - any way of doing cabal --version?
09:29:25 <SyntaxNinja> ndm: you could always "ghc -package cabal-1.1.7 --make Setup.lhs -osetup" then "./setup configure" etc
09:29:34 <SyntaxNinja> ndm: that way you can tell what its doing, ghc doesn't pick every time you run it.
09:30:40 <ndm> SyntaxNinja: did so, and unregistered Cabal-1.1.6, still no luck
09:32:54 <dcoutts_> ndm: you are installing and registering it? what happens when you do that?
09:33:06 <dcoutts_> does registration work / fail ?
09:33:17 <ndm> dcoutts_, runhaskell Setup configure, build, install with the new cabal, do i need to do more?
09:33:23 <dcoutts_> or appear to work but then seem to have done nothing?
09:33:32 <SamB> hmm, what DVD media should I get...
09:33:47 <dcoutts_> ndm: you'll notice it calls ghc-pkg, does it appear to give reasuring messages or complain?
09:34:19 <ndm> dcoutts_, very reassuring - Done after each one
09:34:38 <ndm> if i unregister cabal totally, will that guarantee i am on teh new one?
09:34:42 <ndm> or fry my machine?
09:34:51 <dcoutts_> both! :-)
09:35:06 <SamB> what? no cabal without cabal anymore?
09:35:13 <dcoutts_> ndm: you can unregister Cabal-1.1.7
09:35:32 <dcoutts_> ndm: you probably need 1.1.6 for things that are still installed, like the ghc api package
09:35:43 <SamB> probably you want to *hide* 1.1.6
09:35:46 <ndm> dcoutts_, i've just uninstalled everything, and cabal doesn't work at all
09:35:50 <SyntaxNinja> ndm: you tried the ghc --make route?
09:35:51 <ndm> i'm now going for a fresh copy
09:35:55 <dcoutts_> ok
09:35:59 <ndm> SyntaxNinja: yep, no differences
09:36:08 <SyntaxNinja> but then you said you used runhaskell
09:36:11 * SyntaxNinja is confused
09:36:25 <ndm> SyntaxNinja: the --make still works, the runhaskell stopped working
09:36:28 <SamB> does ghc-pkg check dependencies before letting you unregister/uninstall a package?
09:36:33 <SyntaxNinja> if you used -package Cabal-1.1.7, then called ./setup then its definitely using 1.1.7
09:36:36 <dcoutts_> SamB: nope
09:36:40 <SamB> aww
09:36:57 <ndm> SyntaxNinja: but many versions go under the name Cabal-1.1.7, and i've had a few of them
09:37:14 <dcoutts_> SamB: it'll happily pull the rug out from under other packages, giving you nice error messages later if you try to use said broken packages
09:37:22 <SamB> should start adding some kind of appendage to the names for WIP versions...
09:37:23 <SyntaxNinja> ndm: ahh
09:37:53 <SamB> dcoutts: dpkg doesn't do that unless you pass it a forcing option
09:38:13 <dcoutts_> SamB: that's because it's more friendly :-)
09:39:28 <SamB> dcoutts: yes!
09:40:03 <ndm> dcoutts_, all changed, no luck at all
09:40:12 <ndm> dcoutts_, how would i go about definately getting a verbose message out?
09:40:22 <ndm> dcoutts_, i can't find anywhere that -v5 makes any difference...
09:40:34 <dcoutts_> ndm: forget that, just test if rawSystem actually works on windows
09:40:54 <dcoutts_> try using ghci and rawSystem to invoke haddock --help
09:40:59 <dcoutts_> something like...
09:41:49 <dcoutts_> rawSystem "foo bar/haddock" ["--help"]
09:41:49 <ndm> dcoutts_, works perfectly
09:41:50 <SyntaxNinja> dcoutts_: he said he already tried it
09:41:55 <dcoutts_> oh
09:42:02 <dcoutts_> hmm
09:43:22 <dcoutts_> ndm: so you do something like: cd Cabal; ghc --make Setup.lhs -o setup.exe; ./setup.exe clean; ./setup.exe configure; ./setup.exe build -v5 and get no verbose output at all?
09:43:33 <dcoutts_> how about: ./setup.exe build -v0
09:43:38 <dcoutts_> is that completely silent?
09:44:54 <dcoutts_> ndm: do exactly ghc --make Setup.lhs -o setup.exe, don't use -i or -i. or similar.
09:45:12 <ndm> dcoutts_, exactly as expected, -v0 is silent, -v5 is really loud
09:45:18 <dcoutts_> ok good
09:45:37 <dcoutts_> and ./setup haddock -v2 ?
09:45:37 <ndm> for setup haddock -v0, it is silent til the error message
09:45:47 <ndm> for setup haddock -v5, its same as -v1
09:45:58 <dcoutts_> right, which is fairly verbose
09:46:08 <ndm> no, which is quite silent
09:46:14 <ndm> preprocessing, reading, error message
09:46:19 <ndm> doesn't say what its calling or anything
09:46:20 <dcoutts_> tells you how it's invoking haddock anyway
09:46:23 <ndm> nope
09:46:30 <dcoutts_> oh, so it fails before calling haddock ?
09:46:36 <ndm> "Running Haddock for Cabal-1.1.7..."
09:46:42 <ndm> i suspect it fails when running haddock
09:46:44 <dcoutts_> does it tell you what cpp commands it's calling
09:46:46 <ndm> do you flush the buffers?
09:46:53 <ndm> nope
09:46:57 <ndm> no mention of anyting
09:47:10 <ndm> @paste
09:47:10 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:47:15 <hpaste>  ndm pasted "(no title)" at http://hpaste.org/1625
09:47:45 <ndm> (me note that people would be upset if i paste 4 lines of build output in IRC, but don't seem to mind the 3 lines it takes me to @paste, get a result, and notify of hte paste)
09:48:28 <Igloo> die flushes stdout. Try redirecting stdout and stderr to files and see if that's any different
09:48:45 <dcoutts_> ndm: that's really weird, here ./setup haddock -v2 gives me all the cpphs commands it calls
09:49:06 <Igloo> Oh, maybeExit doesn't call die, though
09:49:29 <Igloo> ndm: Try putting an hFlush stdout in Distribution.Simple.Utils.maybeExit
09:50:08 <dcoutts_> Igloo: are we not using line buffering here anyway?
09:50:29 <Igloo> Probably, but it can't hurt to try
09:50:50 <ndm> Igloo: no luck
09:50:52 * dcoutts_ tries to get cabal installed on his windows box
09:50:55 <Igloo> ndm: With what?
09:51:06 <ndm> Igloo: hFlush'es
09:51:29 <Igloo> ndm: Try the redirections, i.e. > out 2> err or something
09:51:30 <ndm> Igloo: or the file logging
09:51:35 <Igloo> Oh, OK
09:51:45 <ndm> the error message is on stderr, the other stuff is on stdout
09:52:18 * Igloo would offer to post ndm another Debian CD, but he'd only threaten to send me another Windows CD in response
09:52:50 <SyntaxNinja> "./setup --help-windows" -- just installs Debian
09:53:16 <ndm> Igloo: we've moved on to DVD's now for Vista
09:53:37 <sphynx> could you please tell, is there some way to define constructor used except pattern matching?
09:53:59 <sjanssen> DVD's for ten times the broken software :)
09:54:00 <Igloo> sphynx: You can match against   Foo {}   if you want to avoid listing all its arguments
09:54:46 <sioraiocht> hello all
09:54:48 <sphynx> I can't use pattern matching in my case, because I need that this matching was only after some another matching..
09:55:17 <sphynx> Igloo, hm, it seems that's not my case. It is a bit difficult to explain..
09:55:19 <dmwit> sphynx: Tell us more, a "case" or a guard might help depending on what you're trying to do.
09:55:32 <sioraiocht> so I'm using Parsec to write a parser for the brainfuck programming language, anyone mind answering a question or two?
09:55:34 <sphynx> OK, I will paste some code now
09:55:50 <ndm> sioraiocht: isn't each brainfuck command one letter?
09:56:06 <sioraiocht> ndm: yes, and that part is easy, except for the part whre it supports loops
09:56:37 <SamB> sjanssen: maybe it is so you can put the software on ten times
09:56:40 <ddarius> sphynx: Good idea.
09:57:03 <sioraiocht> ndm [###########] means while (pointer) { ######### }
09:57:27 <dmwit> sioraiocht: Sure, question away.
09:57:32 <ddarius> sioraiocht: Not to dissuade you, but isn't Parsec massive overkill here?
09:57:50 <SamB> @oldwiki ShortExamples
09:57:51 <lambdabot> http://www.haskell.org/hawiki/ShortExamples
09:57:52 <SyntaxNinja> ndm: have you tried "./setup configure --with-haddock=c:\path-to-haddock"?
09:57:53 <sioraiocht> ddarius: sure, but it's something to do to learn Parsec?
09:57:55 <ndm> sioraiocht: i'd have said that parsec was not necessary
09:58:01 <SyntaxNinja> ndm: it should work the same, but just in case
09:58:03 <ndm> SyntaxNinja: no, but it finds the right path already
09:58:05 <SamB> http://www.haskell.org/hawiki/ShortExamples_2fBFInterpreter
09:58:07 <lambdabot> Title: ShortExamples/BFInterpreter - The Haskell Wiki
09:58:07 <ddarius> sioraiocht: I figured.
09:58:31 <SamB> sioraiocht: there is a tiny BF interpreter
09:58:37 <SyntaxNinja> ndm: I know, but the code takes a different path when you specify it by hand, so there's some tiny chance it'll narrow something down
09:59:16 <ndm> SyntaxNinja: same result
09:59:22 <SamB> hmm, didn't it used to handle comments?
09:59:28 * ddarius would've used recursion and pattern matching for that.  In fact, he did use recursion and pattern matching to parse REs and those have a rather more complicated grammar than BF.
09:59:30 <SamB> oh, wait, it still does
10:00:23 <ndm> weird, i think i have a new syptom
10:00:30 <dcoutts_> ndm: it works perfectly for me in mingw on my win2k3 box
10:00:44 <dcoutts_> ndm: well the ./setup.exe haddock -v2 bit anyway
10:00:51 <ndm> dcoutts_, you mean it works perfectly on your Linux port to Windows :)
10:00:52 <ndm> @hpaste
10:00:53 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:00:59 <hpaste>  ndm pasted "(no title)" at http://hpaste.org/1626
10:01:01 <dcoutts_> ndm: now to try the path with space in it...
10:01:11 <SamB> sioraiocht: look at the history if you want to see what it used to look like
10:01:16 <dcoutts_> ndm: you want me to try it in cmd.exe ?
10:01:30 <ndm> dcoutts_, SyntaxNinja: that paste is after editing .config-setup by hand, and adding \" to the haddock string
10:01:37 <ndm> dcoutts_, of course, if its not cmd, its not windows
10:01:42 <dcoutts_> ok
10:02:22 <SamB> what? he was using BASH?
10:02:22 <ndm> i.e. by hacking around haddock, it still fails, but later
10:02:54 <ndm> any in a manner that -v does catch
10:03:17 <ndm> so it doesn't look like its a -v problem, it really looks like some command is being executed before, which isn't -v logged, and is crashing
10:03:31 <ndm> is there a system command in there somewhere?
10:04:15 <SyntaxNinja> ndm: you added a \ in front of the space?
10:04:29 <ndm> SyntaxNinja: no, i added \" at either end of the string
10:04:35 * ddarius thinks he's going to need to add observable sharing to his NFA data structure.
10:04:35 <ndm> SyntaxNinja: windows doesn't support \ 's
10:04:40 <hpaste>  sphynx pasted "Guards and pattern matching issue" at http://hpaste.org/1627
10:04:41 <SamB> ndm: you could maybe try ktracing it?
10:04:50 <SyntaxNinja> ndm: could you paste your .setup-config?
10:05:17 <sphynx> I've described my problem in comment, please take a look
10:05:37 <dcoutts_> ndm: so the verbose thing with Setup.exe haddock -v2 is fine, I can reproduce the problem with haddock.exe having a space in the path
10:05:47 <ndm> Program {programName = "haddock", programBinName = "haddock", programArgs = [], programLocation = UserSpecified "\"c:\\program files\\haskell\\bin\\haddock.exe\""}),
10:06:03 <ndm> dcoutts_, in that case over to you :)
10:06:09 <dmwit> sphynx: Something like (RParen:Func _:otherstack)?
10:06:15 <sphynx> if needed, all code is  here: http://hpaste.org/1614
10:06:28 <dcoutts_> ndm: did you discover anything interesting? do we know where it starts to go wrong?
10:06:29 <ndm> dcoutts_, manually hacking the .setup-config to that gets further, suggesting the call is untraced and before cpphs is invoked
10:06:44 <ndm> dcoutts_, before cpphs is my guess, the cpphs call looks fine
10:07:00 <DRMacIver> Hm. How easy is it to write webservices using e.g. HAppS?
10:07:35 <sphynx> dmwit, no, parens are not put in stack at all
10:08:06 <Saizan> DRMacIver: hpaste has been written in 2 days
10:08:43 <sphynx> sphynx, I need to check if after dropping of tokens from stack until LParen inclusively, head of Stack is Func and only then pops it from stack to out parameter
10:10:04 <DRMacIver> Hm. I should really have a play with HAppS in general actually.
10:10:07 <dmwit> sphynx: case rest of { f1@(Func _) -> ...; otherwise -> ...; }
10:10:27 <DRMacIver> Saizan: Thanks.
10:10:33 <dmwit> sphynx: case rest of { (f1@(Func _):resttail) -> ...; otherwise -> ...; }
10:11:21 <sphynx> dmwit, oh, this seems to be what I need!
10:12:08 <sphynx> dmwit, I've forgot about 'case', sorry, remembering only about guards :)
10:12:19 <dmwit> Cool, g'luck!
10:12:21 <dmwit> =)
10:12:36 <sphynx> I will try now. Thank you very much!
10:14:00 <cedricshock> Hi. Can I have a where clause in a type class that isn't a function? like: class Group g where identity :: g
10:14:45 <Saizan> yes, there's no fondamental distinction between that and a function
10:14:47 <dmwit> Sure!
10:15:08 <cedricshock> Saizwan: Thanks. It just looks weird when I type it.
10:15:44 <sphynx> dmwit, Yeah! It works! Cool :)
10:15:53 <dcoutts_> ndm: when trying to establish haddock's version it calls haddock --version and uses cmd.exe to do that, then of course we get escaping problems.
10:16:07 <ndm> dcoutts_, yes, that explains it
10:16:24 <sphynx> dmwit, I always know that Haskell is powerful and it must bee easy :)
10:16:37 <dmwit> =)
10:16:45 <dcoutts_> ndm: see systemGetStdout in Distribution.Simple.Configure
10:17:16 <dcoutts_> Igloo: what is the right way to do this? we really want to avoid calling system ever.
10:17:43 <ndm> dcoutts_, i'm off now (again), but will pull tomorrow and see if my bugs are squashed!
10:17:47 <dcoutts_> but we need to obtain the stdout, we should probably be using one of the interactive process functions
10:17:47 <ndm> well done for tracking it down
10:18:02 <ndm> do they work on Hugs? I thought not
10:18:08 <dcoutts_> ndm: I was hoping someone else would fix it :-)
10:18:10 <ndm> you really do want to do > and 2>
10:18:43 <dcoutts_> ndm: I don't think so, we want to avoid calling the system command interpreter since then we need to know how to escape things
10:18:49 <dcoutts_> and that varies with platform
10:18:53 <dcoutts_> it's ugly ugly ugly
10:19:03 <ndm> but runInteractive is GHC only, which defeats the point of a haskell build system
10:19:21 <dcoutts_> hugs should support that
10:19:32 <Igloo> dcoutts_: Hmm, yes, but I'm not sure how portable those functions are if you don't want to deadlock because a buffer gets full up
10:19:35 <dcoutts_> it doesn't need special concurrency as far as I can see
10:20:06 <sjanssen> dcoutts_: you need to read from stderr and stdout concurrently, in case a buffer fills
10:20:06 <dcoutts_> Igloo: seems like such a simple thing, run a command and collect its output.
10:20:26 <dcoutts_> sjanssen: we can leave stderr directed to our own stderr
10:20:29 <Igloo> dcoutts_: But you have to read from its stdout and stderr while it is running, or it will fill a buffer up and block
10:20:49 <sjanssen> dcoutts_: that sounds like a solution to me :)
10:20:59 <dcoutts_> Igloo: so long as we only redirect its stdout I think we should be safe
10:21:01 <Igloo> If you don't mind them both being the same handle then you might be OK even without concurrency
10:21:18 <Igloo> Yes, that should work too, I think
10:22:20 <bos> ndm: ping
10:22:45 <ndm> bos: hi, i'm literlally just leaving...
10:22:50 <bos> oh.
10:22:55 <dcoutts_> Igloo: we can't do it with a pipe though
10:23:11 <bos> i was going to accost you over filepath :-)
10:23:13 <SamB> dcoutts: what is wrong with pipes?
10:23:14 <ndm> bos: feel free to email though
10:23:18 <bos> will do.
10:23:22 <Igloo> dcoutts_: How do you mean?
10:23:30 <ndm> or wait til tomorrow, i'll be on then - your choice
10:24:05 <dcoutts_> SamB: Igloo: we can't make pipes ourselves to pass to runProcess and we cant use runInteractiveProcess since it creates pipes for all of stdin,out,err
10:24:06 <ndm> bye!
10:24:20 <SamB> dcoutts: oh, that.
10:24:40 <SamB> dcoutts: well, the library should have a more usefull function anyway
10:24:47 <SamB> so fix that
10:24:49 <dcoutts_> Igloo: I've always felt that there is a missing function somewhere between runProcess and runInteractiveProcess
10:25:34 <dcoutts_> I think it's not possible currently to connect only a subset of stdin/out/err to pipes and inherit the others
10:25:56 <binil> Hi all. Haskell & IRC newbie here. I am trying out the "Write Yourself a Scheme in 48 hours" tutorial and I need some help in getting the code running in GHC. Can someone here help, please?
10:26:18 <sjanssen> binil: that's what we do
10:26:21 <dcoutts_> Igloo: so I think the thing we have to do is to keep using the temp file and call runProcess redirecting its output to that tmp file, then we read it back in
10:26:27 <sjanssen> @paste the error, perhaps?
10:26:28 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:26:36 <SamB> runSimpleInteractiveProcess :: String -> (Handle, Handle) -- command -> (pipe to stdin, pipe from stdout) ?
10:26:38 <sioraiocht> SamB: Your interpreter is WAY more elegant than mine, but thanks for the help, I got it to work ;)
10:27:19 <binil> Thanks.
10:27:25 <SamB> sioraiocht: yeah, well, when I wrote mine I was trying to maximize features used per line of code ;-)
10:27:28 <binil> $ ghc -o hello_you Hello.hs
10:27:28 <binil> Hello.hs:1:45: parse error on input `main$
10:27:50 <Igloo> dcoutts_: Hmm, yeah, I can#t see a portable way to make a Handle
10:27:55 <binil> My code is the first example in WYAS48H
10:28:06 <binil> module Main where
10:28:07 <binil> import System.Environment
10:28:07 <binil> main :: IO ()
10:28:07 <binil> main = do args <- getArgs
10:28:07 <binil>           putStrLn ("Hello, " ++ args !! 0)
10:28:21 <SamB> it would also be nice to have a portable function to create a pipe
10:28:33 <SamB> or should I say port*ed*
10:29:17 <bos> ew, renameFile and renameDirectory are yucky.
10:29:24 <SamB> @hoogle rename
10:29:25 <lambdabot> Language.Haskell.TH.Lib.rename :: Pat -> Q ([(Name, Name)], Pat)
10:29:25 <lambdabot> Directory.renameDirectory :: FilePath -> FilePath -> IO ()
10:29:25 <lambdabot> Directory.renameFile :: FilePath -> FilePath -> IO ()
10:30:02 <sjanssen> binil: that sample looks okay.  Are you sure there aren't any strange/stray characters in your code?
10:30:02 <bos> why is haskell imposing semantics on me that the underlying filesystem doesn't?
10:30:02 <bos> if i call renameDirectory on a file, i'll get an exception.
10:30:10 <SamB> bos: what in particular is ugly about them?
10:30:14 <binil> sjanssen: I am on a Mac. I tried the same code earlier today on my Windows machine and it did work.
10:30:27 <SamB> bos: because some do, most likely
10:30:32 <bos> SamB: they check internally to make sure you're renaming the "right kind of thing".
10:30:50 <SamB> I suppose it would be nice to have a renameThing that picked the right one
10:31:00 <sjanssen> binil: maybe your Mac is inserting weird characters when you paste?
10:31:08 <binil> sjanssen: the compiler version I used is also exactly the same - GHC 6.6.
10:31:31 <kpreid> extra CRs? does ghc on unixy systems accept CRLF?
10:31:37 <binil> sjanssen: yeah, that looks like a possibility. let me check.
10:31:51 <SamB> kpreid: I sure hope so
10:32:38 <SamB> Turbo Pascal seems to be okay with files that lack them, and Turbo Pascal is way more simplistic than GHC ;-P
10:33:07 <kpreid> *lack*?
10:33:49 <SamB> Turbo Pascal is for DOS. DOS usually has CRLF, but TP apparantly handles LF-only files just fine
10:36:12 <kpreid> that's not the same as the presence of CRs on a platform not expecting them
10:36:44 <binil> sjanssen: Thanks! I got it working!
10:38:06 <binil> sjanssen: I still don't know why though. :) I tried "cat Hello.hs" on the console and it was printing weird. So I imagined that your hypothesis of incorrect characters throwing the parser off is right. Instead of copy-pasting from the web page, I typed in all the code into the editor and it worked like a charm! Thanks, again!
10:38:38 <kpreid> binil: printing weird as in lots of overlapping lines, or so?
10:38:46 <kpreid> binil: if so, that was a CR-only file
10:39:48 <binil> kpried: Yes, momentarily the content comes, but it gets overwritten and I get back to shell prompt without any printed output.
10:40:55 <binil> krpied: Just to satisfy my curiosity - how can I get rid of this issue if I hit it in future? Is there some magic command like "fixLineFeeds" or "doc2unix" or something like that?
10:41:21 <kpreid> well, tr '\r' '\n' will do
10:42:26 <dcoutts_> @tell ndm I feel your pain wrt the GHC-onlyness of openTempFile, we have to use a hack in cabal instead :-(
10:42:26 <lambdabot> Consider it noted.
10:42:43 <dcoutts_> Igloo: can't we fix that? openTempFile is really useful
10:43:05 <cedricshock> Hey, is there any way to use the type class system (or an extension thereof) to say something like this: A ring is a monoid where the operation is *, the identity is 1, ... and a group where the operation is +, the identity 0, etc...? Without making lots of silly AdditiveGroup, MultiplicitiveGroup, etc classes (this seems to run into having a class for every possible combination and failing to catch the patterns involved)
10:44:19 <Igloo> dcoutts_: Patches welcomed!
10:44:22 <binil> kpreid: that worked! Thanks!
10:44:47 <shapr> dcoutts: Hey, did the pix your mother took of the three of us (you, me, Lemmih) unicycling, ever get uploaded?
10:46:43 <sioraiocht> what argument do Ihave to pass to ghc to link with the parsec library?
10:46:43 <sioraiocht> -lparsec didn't work
10:47:03 <Igloo> -package parsec
10:47:06 <dcoutts_> shapr: oh, probably
10:47:12 <Igloo> --make would also work
10:47:17 <dcoutts_> shapr: I'll take a look in a moment
10:48:04 <emu> cedricshock: that's not the only kind of group..
10:49:04 <shapr> dcoutts_: I was just looking at the AngloHaskell unicycle pix on edwinb's site again.
10:49:28 <emu> cedricshock: perhaps subclass Data.Monoid and add an additional function minverse
10:50:22 <cedricshock> emu: A group is a set together with an operation (that fulfills a nice list of axioms). What I really want to avoid is having to have a class for every operation X group X abelianornot, etc..., which gets even worse at rings.
10:51:24 <merus> cedricshock, the difference between AdditiveGroup and MultiplicativeGroup is only notational.
10:51:27 <emu> admittedly i'm not too keen on Data.Monoid.  It seems only useful for types which are monoids, not some arbitrary set.
10:51:34 <merus> It's not like they support different things.
10:51:54 <emu> cedricshock: yes, and those axioms are: those of monoids + every element has an inverse
10:51:55 <cedricshock> merus:: Exactly. That's the problem.
10:52:03 <merus> How is that a problem?
10:52:32 <cedricshock> merus:: class (Group r Monoid r) Ring r where ...
10:52:37 <shapr> I love this channel.. you never heard arguments about group theory as applied to Python, Perl, C, etc
10:53:10 <merus> Yeah, that's the way I'd do it.
10:53:16 <shapr> cedricshock: Have you looked at the Haskell Road to Maths and Logic to see if they cover that?
10:53:20 <emu> for example, i'm working with syntactic monoids, but i could not find a way to instance Data.Monoid sensibly for it
10:53:34 <cedricshock> fails to capture the idea of a ring, because the group and monoid classes then are only parameterized by the set r, and not by the operation.
10:53:54 <merus> No, you'd have to instance the distribution laws in the class
10:54:01 <merus> that's sufficient to define the operation.
10:54:11 <cedricshock> shapr: Haven't checked that. BAL uses a billion of what I'm calling "silly" classes.
10:54:18 <shapr> BAL?
10:54:25 <emu> you could use a newtype
10:54:32 <cedricshock> merus: Yeah, you need those too.
10:54:36 <emu> but yes, you would have to define lots of instances for each one
10:55:14 <cedricshock> shapr: A haskell basic algebra library. But it tends to make instances of classes and call them the class.
10:55:48 <shapr> ah
10:55:58 <cedricshock> shapr: It assumes things like that vectors have an ordered basis, and can be mapped over and other things.
10:56:20 <cedricshock> shapr: Which turns out to be not the case for my real world computation problem.
10:58:19 <cedricshock> merus: How would you go about instancing the distributive laws. That seems like something that I could only doas documentation of as a unit test, but which I'd really like to have in the code.
11:00:23 <sphynx> is there any way to store Map of functions with different types. I want to store some predefined functions in Map and then lookup them in Map and apply, while evaluating my string. But I don't know what I should do with different types of these functions
11:00:53 <sphynx> so I want something like [("f", length), ("g", (*))]
11:01:31 <sphynx> so I can evaluate the string "f [] + g 2 3" later
11:02:13 <dmwit> sphynx: Is it easy to enumerate all the types?
11:02:22 <dmwit> You could do something like
11:03:13 <dmwit> data StorableFunctions = Unary (Int -> Int) | Binary (Int -> Int -> Int) | List ([Int] -> Int)
11:05:38 <sphynx> dmwit, it sounds good. I'm planning to start with some basic set of functions, so this enumeration will suit. Then I want to move from function evaluation to type evaluations
11:06:30 <sphynx> dmwit, I want to create some system which can evaluate type of some Java-like language, so I can evaluate type of expression, for example:
11:06:53 <sphynx> (s.Substring(1, 2) + 2).Substring(1,5).IndexOf('x')
11:07:44 <sphynx> now I should define what is the type of IndexOf, so at first I should detect that is String's method and then look at SymbolTable for this method. SymbolTable is already filled by parser
11:08:01 <dmwit> sphynx: Ah, okay.  I think this is done very often in Haskell.
11:08:13 <dmwit> I don't remember any particular papers to have a look at, but maybe somebody else does?
11:08:52 <sphynx> Yeah, I would be very grateful for that :)
11:09:21 <sphynx> anyway I'm interested in doing all of this by myself, but paper reading would be appreciated
11:10:17 <dmwit> sphynx: Anyway, if you're just storing the types (rather than the functions themselves), you probably want a different data structure.
11:11:53 <sioraiocht> is there a good explanation of state monads? their concept eludes me
11:12:04 <sioraiocht> I read all about monads but was confused
11:12:08 <sphynx> dmwit, simply Map String String?
11:12:10 <dmwit> sioraiocht: Yes!  I'll try to find it for you.
11:12:17 <sioraiocht> thanks dmwit =)
11:12:19 <dmwit> sphynx: Maybe:
11:12:47 <dmwit> data Type = Number | Char | List Type | ...
11:13:21 <dmwit> (You'll probably need a Function Type Type in there, too.)
11:13:55 <dmwit> http://scienceblogs.com/goodmath/2007/01/more_monads_stateful_programmi_1.php
11:13:57 <lambdabot> Title: Good Math, Bad Math : More Monads: Stateful Programming, http://tinyurl.com/34gwz7
11:14:32 <sphynx> dmwit, hmm.. OK,  I will think about it. MAybe it's simpler to start from evaluation of function results rather than types and then move to types
11:14:38 <dcoutts_> shapr: http://dhcp0714.gradacc.ox.ac.uk:8080/~duncan/photos/UK%20Haskell%202006/00009.jpg
11:14:40 <lambdabot> http://tinyurl.com/2azr7c
11:14:45 <shapr> Thanks!
11:14:47 <dcoutts_> shapr: but watch out it's 1.5mb
11:15:06 <dmwit> Yay, unicycles!
11:15:11 <shapr> yay!
11:15:12 <sphynx> dmwit, So I can play with data StorableFunctions which you've proposed
11:15:20 <dmwit> sphynx: Okay, good luck!
11:15:21 <dcoutts_> see how I don't have a beautiful photo website with nice thumbnails :-)
11:15:44 <sphynx> dmwit, thanks! :)
11:15:47 <shapr> Ah, you uploaded all of them.
11:15:48 <dmwit> Somebody wants to go mountain unicycling... =)
11:15:50 * shapr browses
11:15:53 <Igloo> dcoutts_: Is that a one-armed convention?
11:15:54 <shapr> dmwit: me me me!
11:16:07 <shapr> dmwit: I want to go RIGHT NOW!
11:16:09 <sioraiocht> *sigh* my boyfriend just told me he'd rather work with python than haskell
11:16:12 <dcoutts_> shapr: my gf hacked together a photo album website using bash that looks much nicer :-)
11:16:22 <sioraiocht> I think that's a dealbreaker
11:16:30 <shapr> dcoutts_: cool
11:16:39 <shapr> sioraiocht: Ah well
11:16:42 <dmwit> 00008 -- hop hop!
11:16:48 <igli> sioraiocht: nah, you'll regret it ;)
11:17:19 <dmwit> Or maybe the shadow just makes it look like that.
11:17:27 <dcoutts_> Igloo: yep, notice that Lemmih doesn't even need to keep both feet on the pedals
11:17:34 <dcoutts_> he's just that good
11:17:35 <shapr> Duncan and his whole family are cool people.
11:17:40 <dcoutts_> :-)
11:18:07 <sioraiocht> I mean, to be fair, he's being offered a python/django job, so he should get more acquainted with them
11:18:22 <sioraiocht> not everyone is blessed with using the programming language they want for a given teask
11:18:25 <sioraiocht> *task
11:18:37 <shapr> I had a Python job for years before I got a Haskell job.
11:18:45 <Igloo> dcoutts_: I'm more impressed by xerox, doing 2 wheels at once! The rest of you only have 1 to worry about
11:19:15 <kc5tja> sioraiocht: Heh, I'm available... ;D  I'm into Forth, Haskell, and while I like Python, I'm finding I like Haskell slightly better....
11:19:19 <kc5tja> j/k of course.
11:19:29 <sioraiocht> lol
11:19:31 <dcoutts_> Igloo: :-)
11:21:40 <helmut> Could someone give me a hint on this ghc message? (.text+0x3aa): undefined reference to `mtlzm1zi0_ControlziMonadziState_zdf12_closure'
11:21:49 <dmwit> ghc --make
11:21:54 <helmut> thanks
11:21:58 <dmwit> Or install the mtl package, whichever you haven't done. ;-)
11:22:51 <helmut> would that be libghc6-mtl-dev?
11:22:59 <dmwit> yes
11:23:01 <helmut> thanks!
11:23:26 <helmut> (actually it is installed, so I'll rtfm on --make)
11:24:54 <dmwit> helmut: It shouldn't require any additional wizardry.  Use the same command line as before, but put --make as the first argument to ghc.
11:26:17 <helmut> uhm. I use a Makefile first creating .o files and then linking them together. ghc --make -o Foo Foo.o Bar.o doesn't seem to work.
11:26:52 <dmwit> helmut: ....oh
11:26:57 <helmut> (but I'm open for improvements being a former c programmer ;-)
11:27:08 <dmwit> If you've done your module-naming correctly, ghc --make should replace your Makefile.
11:27:31 <dmwit> Specifically, you should do ghc --make Foo.hs, where Foo.hs has module Main.
11:27:49 <kc5tja> Dude, that symbol name looks like something that's been passed through the 1337 or b1ff filter.
11:28:06 <dmwit> All the other modules you create should be in a file named the same way as the module, i.e. module Foo where bar should be in file Foo.hs (caps matter).
11:28:29 <helmut> dmwit: ghc --make Foo.hs does not replace a makfile, but build Foo.
11:28:49 <dmwit> Well, okay, yes.
11:28:57 <dmwit> Never mind, I'm making too many assumptions.
11:29:22 <dmwit> In any case, the problem is that somewhere ghc isn't linking against the mtl, so if you can figure out the right command-line parameters to enforce that, use them.
11:29:55 <Saizan> -package mtl
11:30:06 <dmwit> s/the problem is/it sounds like the problem is/
11:30:16 <cinema> Igloo: ping
11:30:42 <helmut> thanks Saizan!
11:30:49 <Igloo> cinema: pong
11:31:03 <helmut> (now I can compile a subset of a language formerly known as bpl to c)
11:31:30 <cinema> Igloo: I succeeded in compiling ghc HEAD today, but had to make some changes in the time library
11:31:57 <cinema> Igloo: I had to suppress the 'WError' pragmas
11:32:30 <Igloo> cinema: Right, the nightlies are failing on that too. I suspect Simon's recent change to add the type signature to the warning broke it
11:32:35 <dmwit> helmut: Out of curiosity, what else does your makefile do?
11:32:58 <cinema> Igloo: furthermore, some .h from base packages are not copied and make compilation with -O fail
11:33:08 <helmut> dmwit: invoke alex and frown
11:33:20 <cinema> Igloo: All these should be fairly simple to correct
11:33:30 <dmwit> aha
11:33:53 <helmut> dmwit: (and ghc in between alex and frown)
11:34:33 <helmut> dmwit: (err, sorry. that was wrong. they can be invoked independantly, but the parser needs to be compiled after the lexer of course)
11:37:45 <dmwit> Interesting.  I've never seen alex and frown before.
11:39:35 <dmwit> (I always just assumed Parsec was the be-all and end-all of Haskell parsing. =)
11:39:54 <cedricshock> `left_divide' is not a (visible) method of class `Loop'. What does this mean? I'm gettint it when I try to define a default implementation of a subclass in terms of the interface to the parent class.
11:40:05 <dcoutts_> dmwit: alex is the standard haskell lexer generator and frown should get more attention but everyone uses happy instead
11:40:19 <dcoutts_> though frown is better in many ways, happy is established
11:41:58 <hpaste>  cedricshock pasted "My abstract algebra attempt" at http://hpaste.org/1628
11:42:22 <fridim> hi. What do you think about the book (written recently, 2007 it seems) http://tinyurl.com/yrmpxy
11:42:54 <dmwit> cedricshock: \ is a part of Haskell syntax.
11:43:02 <dmwit> ?pl \x y -> x + y
11:43:03 <lambdabot> (+)
11:44:23 <dmwit> Oh, that isn't even remotely related to your question.
11:44:24 <cedricshock> dmwit: Yeah, I guessed that I was out of luck trying to use it. All in all the specific symbols aren't very important.
11:44:58 <dmwit> cedricshock: Maybe it is because of the missing comma?
11:45:00 <helmut> dmwit: Actually I've not much choice in that as Ralf Hinze only supports frown. ;-)
11:45:23 <dmwit> class (Quasigroup l Identity l) => Quazigroup q where -- needs it between Quasigroup l and Identity l
11:45:47 <dcoutts_> fridim: I reviewed that book in the latest TMR edition
11:46:00 <dcoutts_> @where TMR
11:46:00 <lambdabot> http://www.haskell.org/haskellwiki/TheMonadReader
11:46:16 <helmut> (frown is pretty intuitive though :-)
11:46:29 <dmwit> =)
11:46:37 <cedricshock> dmwit: I don't understand.
11:46:43 <LoganCapaldo> Arrows are sorta like functions. This makes me wonder, would an arrow be a good "type level" abstraction for threads in the same way the IO monad is a an abstraction for imperative, side-effectful code?
11:47:05 * LoganCapaldo waits for the pointer to the paper that will hurt his brain
11:47:24 <dmwit> cedricshock: As I understand it, you're trying to restrict the Loop class to only types that are in the Quasigroup and Identity class, right?
11:47:35 <cedricshock> dmwit: Exactly.
11:48:09 <hpaste>  dmwit annotated "My abstract algebra attempt" with "commas" at http://hpaste.org/1628#a1
11:49:02 <dmwit> Specifically, it should be, for example, (Quasigroup l, Identity l) => blah, not (Quasigroup l Identity l) => blah.
11:49:15 <kpreid> cedricshock: your left_inverse and right_inverse methods have inappropriate parentheses
11:49:41 <dmwit> That too.
11:50:06 <cedricshock> dmwit: Thanks. I added commas, but am still getting the same error.
11:50:36 <cedricshock> kpreid: Thanks
11:50:41 <dmwit> Oh!
11:51:01 <dmwit> left_divide has to be specified in Quasigroup, not in Loop.
11:51:14 <kpreid> no, it needs to be in an instance
11:51:25 <dmwit> kpreid: Default implementations are allowed.
11:51:29 <kpreid> same for the AdditiveAbelianGroup etc.
11:51:31 <dmwit> But they have to be in the class that has them.
11:51:37 <kpreid> dmwit: no, it's a function in a different class
11:51:54 <dmwit> kpreid: Yeah, that's exactly what I'm saying.
11:52:24 <dolio> Correct me if I'm wrong, but the issue is that...
11:52:25 <cedricshock> kpreid: I can't provide a default implementation in a subclass for something defined in the super class?
11:52:43 <dolio> If you know something is a loop, you can use the loop operations to specify it as a quasigroup.
11:52:51 <dolio> But Haskell doesn't let you do things like that.
11:52:54 <kpreid> cedricshock: instance Loop l => Quasigroup l where left_divide ... = ...
11:53:26 <dolio> You need to specify it as a quasigroup, and then as a loop, so using the loop functions to define the quasigroup ones is no good, since you'll already have had to specify the latter.
11:54:34 <kpreid> cedricshock: you're saying "every quasigroup-and-identity is a loop, by this definition", I think; that's an *instance*.
11:54:46 <kpreid> (you'll need -fallow-undecidable-instances, btw)
11:57:09 <cedricshock> kpreid: Hmm, semantically that's entirely true.
11:57:16 <GL|vult> haskell sucks!!!!
11:57:40 <GL|vult> ow my that was someone else
11:57:44 <cedricshock> kpreid: But then I want to subclass Loops to make things like groups. Can I do that?
11:58:02 <kpreid> cedricshock: certainly
11:58:10 <shapr> GL|vult: excuse me?
11:58:11 <dmwit> GL|vult: Do tell -- what's frustrating?  Maybe we can help you learn something that will make it easier...
11:58:14 <kpreid> but you may have the wrong idea about what a "subclass" is
11:58:27 <therp> the start is ok, but isn't the rest of the page a bit of a mess http://haskell.org/hawiki/TyingTheKnot ?
11:58:28 <lambdabot> Title: TyingTheKnot - The Haskell Wiki
11:58:57 <cedricshock> kpreid: I've been thinking about these things from the point of view of an interface.
11:59:05 <emu> therp: it's a bit of an extended metaphor for "mutual recursion.."
12:00:53 <pitecus> is there any reason to prefer a monad to carry around some data rather than use implicit params (other than portability?) I dont see implicit params used much....
12:02:16 <dmwit> pitecus: Probably the biggest reason is do notation.
12:02:26 <dmwit> It makes some things prettier.
12:02:45 <emu> monadic notation is more flexible
12:02:57 <pitecus> really?
12:03:36 <emu> if you really dig the haskell way, you'll write your code in monadic notation and invoke it inside of a monad transformer; and you can later swap monads in and out of that
12:03:38 <pitecus> seems like its much simpler to just use ?data than to have to get it from the state monad or smth....
12:04:13 <dmwit> pitecus: The beauty of the state monad is that you can wrap up functions that access/modify the state.
12:04:16 <emu> also, i think implicit params are generally regarded to have a rather shakey theoretical foundation
12:04:18 <cedricshock> kpreid: I think I get it. So I'd have something like class Loop ... the stuff about inverses and then instance Loop l => Quasigroup ...
12:04:21 <dmwit> Then you don't need to pass anything special around.
12:04:42 <dmwit> You just call those functions.
12:05:20 <eumenides> is there some extension to do class Blah a where somefn :: Int ?
12:05:26 <pitecus> aha
12:05:39 <dolio> cedricshock: Won't you, then, miss the ability to have Quasigroups that aren't loops?
12:05:45 <kpreid> eumenides: how would it know which class to pick?
12:05:54 <kpreid> eumenides: give it a dummy input parameter of type a
12:06:25 <cedricshock> dolio: Why would that happen? I haven't changed the definition of Quasigroup at all.
12:06:37 <eumenides> kpreid: ah. hm. yeah, that would work. thanks
12:06:47 <kpreid> eumenides: note that's how, say, typeOf works
12:07:32 <Saizan> cedricshock: i think he confused "instance" with "class" in your previous message
12:08:29 <cdsmith> Is there a good spec of all GHC lexical elements somewhere, suitable for reference when implementing a syntax highlighter?  The report works great, except for stuff like TH and similar stuff.
12:08:58 <cedricshock> kpreid: I like this. It seems right to be making instances of groups to use to construct rings, instead of saying a ring is a group.
12:10:06 <helmut> humm. compiling a functional language to c is not much fun.
12:10:09 <cedricshock> kpreid: Rather, I say the ring is a group, and that it's a monoid, but that it's of the instance of group and monoid that are sorted out to make rings from.
12:10:47 <kpreid> when you write class Foo a => Bar a, you're saying that having an instance of Foo is a *prerequisite* for an instance of Bar
12:11:34 <kpreid> whereas instance Foo a => Bar a says that every Foo is *uniformly* a Bar in the following fashion...
12:11:43 <cedricshock> kpreid: Really?  I doubt I want that anywhere.
12:11:51 <cedricshock> kpreid: (the first one)
12:13:40 <cedricshock> kpreid: Can I have an instance of Foo that is uniformly a bar in two fashions? (A ring is a monoid two ways). I'm really not sure how to deal with this.
12:13:49 <kpreid> No, you can't.
12:14:10 <kpreid> That's why there are newtypes in the provided Data.Monoid.Monoid instances.
12:14:19 <cedricshock> kpreid: I'm going to copy those two statements and slap them at the top of this file.
12:14:33 <kpreid> the newtypes distinguish the two kinds of monoid you get out of Num, for example
12:14:36 <dcoutts_> @tell ndm ok, it works for me now on windows
12:14:36 <lambdabot> Consider it noted.
12:14:46 <kpreid> @docs Data.Monoid
12:14:47 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html
12:15:27 <cedricshock> kpreid: The sums and products?
12:15:30 <kpreid> yes
12:15:34 <kpreid> instance Num a => Monoid (Sum a)
12:15:37 <kpreid> instance Num a => Monoid (Product a)
12:16:03 <kpreid> the newtype doesn't change the computation but it specifies which monoid you want
12:16:27 <cedricshock> kpreid: Oh, that is nice. That gets the operation visually written as a parameter to being of a group, instead of being written nowhere.
12:17:27 <cedricshock> kpreid: I might be able to use that to get rid of some of my horrible extraneous junk.
12:25:31 <helmut> Is there someone who could have a look at my doings and give some advices in haskell style, techniques and what to do next?
12:26:44 <LoganCapaldo> helmut: hpaste away, i'm sure someone will take a look
12:26:59 <emu> you could always paste something so we can procrastinate
12:27:02 <helmut> LoganCapaldo: it's more like a repository.
12:27:45 <LoganCapaldo> well no one is gonna look if you don't provide a link :)
12:27:54 <helmut> well I'll paste the interesting parts to hpaste.
12:28:40 <hpaste>  helmut pasted "(no title)" at http://hpaste.org/1629
12:28:52 <helmut> ups (forgot title)
12:29:23 <helmut> (well what's missing there is basically only definition of Expr)
12:29:53 <hpaste>  helmut annotated "(no title)" with "Expr definition" at http://hpaste.org/1629#a1
12:30:29 <helmut> I know that the code looks like a pile of crap. That's why I search for advices.
12:31:06 <emu> looks fine
12:31:43 <helmut> one of my first questions might be: How to define nextsym in a way it works?
12:31:50 <emu> though i tend to wrap my expressions
12:32:06 <helmut> emu: (that's only one part of the crappiness ;-)
12:32:43 <emu> what's wrong with it?
12:32:50 <opqdonut> it
12:32:54 <emu> you nede to return (f n)
12:33:08 <helmut> ah thanks!
12:33:39 <Saizan> helmut: is there a reason for passing a state around explicitly like that?
12:34:07 <helmut> Saizan: for most questions like this the answer will be: because I don't know how to do it better.
12:34:53 <hpaste>  cedricshock annotated "My abstract algebra attempt" with "Abstract algebra problem" at http://hpaste.org/1628#a2
12:35:05 <Saizan> my first intuition is that you simply don't need to, the state monad threads the state by itself
12:35:23 <osfameron> oh my! i just wrote the simple expression parser from HSOE ex 7.5 on paper and it works in ghci! (modulo a few type declarations i had to add)
12:36:09 <cedricshock> kpreid: Do you have an insight into this error?
12:36:13 <LoganCapaldo> minor comment: I see a lot of n <- get; put (n + 1). I'd do update = do n <- get; put (n + 1); return n and then in those functions n <- update
12:36:45 <helmut> Saizan: Well I probably need to understand more. I'd describe myself as being in a state where I can read most monads, but not creativly use them.
12:36:54 <LoganCapaldo> or maybe even something like update (\n -> ....)
12:37:11 <kpreid> cedricshock: -fallow-undecidable-instances
12:37:31 <Saizan> helmut: well, to access the state you just need to use get and put, the monad hides it from you
12:37:32 <helmut> LoganCapaldo: that's what is no replaced with nextsym.
12:37:52 <LoganCapaldo> duh
12:37:57 <LoganCapaldo> yeah I just realized that
12:38:06 <emu> cedricshock: have you thought about how you would formulate specific groups using these classes? for example: Z^*_n (the group of relatively prime integers to n)
12:39:16 <cedricshock> emu: Only one example drives my thinking, and that's down past rings over fields. It's a specific linear algebra problem.
12:39:45 <cedricshock> kpreid: I was already using that.
12:39:46 <helmut> emu: return (f n) doesn't seem to work and I don't understand the error message: Couldn't match expected type `State Int t' against inferred type `(t2 -> t3) -> t1 t3' while using nextsym.
12:39:53 <Saizan> helmut: you could just have compile :: Expr -> State Int Code, it's execState later that gives the input state to it
12:39:56 <emu> the problem I run into with these classes is that they apply to types ... but some of my types are really "classes of groups"
12:40:10 <emu> helmut: try a simple example first.. one sec
12:40:53 <helmut> Saizan: ahhhh. I start to understand. actually passing the /same/ state to multiple compiles made me wonder a lot. :-)
12:41:29 <Saizan> helmut: heh :)
12:41:44 <kpreid> cedricshock: hm, I don't know
12:41:44 <hpaste>  emu annotated "(no title)" with "(no title)" at http://hpaste.org/1629#a2
12:41:47 <Saizan> helmut: what are using nextsym with?
12:42:13 <nominolo> :t sortBy
12:42:16 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
12:42:29 <cedricshock> emu: I worry about reflection and meta reasoning all the time. I thought a little bit about wanting to manipulate the groups themselves, but I really don't know how to go about it.
12:43:33 <nominolo> > let f = groupBy ((==).fst) . sortBy (compare . fst) in f [(1,2),(3,4),(1,5),(2,7),(3,9)]
12:43:34 <lambdabot>      Occurs check: cannot construct the infinite type: a = (a, b)
12:43:34 <lambdabot>       Expec...
12:43:49 <emu> :t sortBy
12:43:52 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
12:43:54 <kpreid> if you want to reify a type class, turn the class definition into a record type and the instances into values of that type
12:43:56 <emu> :t (compare . fst)
12:43:58 <lambdabot> forall a b. (Ord a) => (a, b) -> a -> Ordering
12:44:26 <helmut> Saizan: nextsym was intended to replace the n <- get; put (n+1) sequences.
12:44:31 <nominolo> > let f = groupBy ((==).fst) . sortBy (first compare) in f [(1,2),(3,4),(1,5),(2,7),(3,9)]
12:44:32 <lambdabot>      Occurs check: cannot construct the infinite type: a = (a, b)
12:44:33 <lambdabot>       Expec...
12:44:36 <emu> @pl \a b -> fst a `compare` fst b
12:44:37 <lambdabot> (. fst) . compare . fst
12:44:38 <nominolo> :t first compare
12:44:40 <lambdabot> forall a d. (Ord a) => (a, d) -> (a -> Ordering, d)
12:45:13 <cedricshock> emu: I could take my abstract algebra text seriously and state something like data Group = Set A CommutativeAssociativeUnitalOperation O
12:45:17 <dolio> ?type comparing fst
12:45:19 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
12:45:28 <LoganCapaldo> don't you need like "first2" to do it like that?
12:45:36 <nominolo> > let f = groupBy ((==).fst) . sortBy (comparing fst) in f [(1,2),(3,4),(1,5),(2,7),(3,9)]
12:45:37 <lambdabot>      Occurs check: cannot construct the infinite type: a = (a, b)
12:45:38 <lambdabot>       Expec...
12:45:55 <nominolo> *cry*
12:45:59 <emu> cedricshock: sometime i need to sit down and figure out what i really want the type system to represent here
12:46:05 <emu> @hoogle comparing
12:46:06 <lambdabot> No matches found
12:46:36 <nominolo> :t let f = groupBy ((==).fst) . sortBy (comparing fst) in f
12:46:39 <lambdabot>     Occurs check: cannot construct the infinite type: a = (a, b)
12:46:39 <lambdabot>       Expected type: (a, b) -> (a, b) -> Bool
12:46:45 <nominolo> :t groupBy
12:46:48 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
12:47:09 <dolio> > let on g f a b = f a `g` f b ; groupBy ((==) `on` fst) . sortBy (comparing fst) in f [(1, 2), (3,4),(1,5),(2,7),(3,9)]
12:47:10 <lambdabot>  Parse error
12:47:18 <nominolo> @ho Comaring -> bool
12:47:19 <lambdabot> Maybe you meant: hoogle hoogle+ . bf echo ft ghc id pl rc show v wn yow
12:47:26 <nominolo> @hoogle Comparing -> Bool
12:47:27 <lambdabot> No matches, try a more general search
12:48:07 <nominolo> > let f = groupBy ((==Equal).comparing fst) . sortBy (comparing fst) in f [(1,2),(3,4),(1,5),(2,7),(3,9)]
12:48:09 <lambdabot>   Not in scope: data constructor `Equal'
12:48:11 <Jaak> @type let f `on` g = \x y -> (g x) `f` (g y) in compare `on` fst
12:48:13 <LoganCapaldo> > case comparing first of EQ -> True ; _ False ?
12:48:14 <lambdabot>  Parse error
12:48:14 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
12:48:19 <emu> :t EQ
12:48:20 <LoganCapaldo> :t EQ
12:48:23 <lambdabot> Ordering
12:48:23 <lambdabot> Ordering
12:48:27 <nominolo> > let f = groupBy ((==EQ).comparing fst) . sortBy (comparing fst) in f [(1,2),(3,4),(1,5),(2,7),(3,9)]
12:48:28 <lambdabot>  Couldn't match expected type `Ordering'
12:48:31 <helmut> Is this type correct? nextsym :: (Int -> State Int Code) -> State Int Code
12:48:35 <Jaak> @type let f `on` g = \x y -> (g x) `f` (g y) in sortBy (compare `on` fst) [(1,2),(3,4),(1,5),(2,7),(3,9)]
12:48:35 <Saizan> helmut: so for example the last clause could be written:  compile (Id s) = nextsym (\n -> return ([], ["value _" ++ show n ++ " = lookup(c, \"" ++ s ++ "\")"], '_' : show n))
12:48:38 <lambdabot> forall a b. (Ord a, Num a, Num b) => [(a, b)]
12:48:38 <cedricshock> emu: rather: data Group = Set a SuitableOperationOn a, but what I want to do is work with the elements of these sets with those nice operations to make some very fast linear algebra implementations completely independently of the algorithms (specifically diagonally banded sparse matrices and the method of conjugate gradients)
12:48:43 <Jaak> > let f `on` g = \x y -> (g x) `f` (g y) in sortBy (compare `on` fst) [(1,2),(3,4),(1,5),(2,7),(3,9)]
12:48:45 <lambdabot>  [(1,2),(1,5),(2,7),(3,4),(3,9)]
12:49:05 <nominolo> Jaak: hey, cool
12:49:12 <nominolo> didn't know that
12:49:19 <Saizan> (plus a ')' at the end, probably)
12:49:36 <LoganCapaldo> but, but dolio did it before Jaak didn't he?
12:49:47 <nominolo> > let f = groupBy (compare `on` fst) . sortBy (compare `on` fst) in f [(1,2),(3,4),(1,5),(2,7),(3,9)]
12:49:48 <emu> cedricshock: i ended up just passing around the function and the sets :/
12:49:48 <lambdabot>   Not in scope: `on'
12:49:55 <dolio> I tried, but I missed an 'f =' in there.
12:50:07 <dolio> on isn't in the standard libraries anywhere, is it?
12:50:10 <Saizan> helmut: yes, that's its type
12:50:37 <helmut> ok. then my nextsym is broken. :-)
12:50:42 <emu> :t groupBy
12:50:44 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
12:50:46 <nominolo> > let f `on` g = \x y -> (g x) `f` (g y); f = groupBy (compare `on` fst) . sortBy (compare `on` fst) in f [(1,2),(3,4),(1,5),(2,7),(3,9)]
12:50:47 <lambdabot>  Couldn't match expected type `Bool'
12:50:57 <emu> groupBy uses Eq
12:51:00 <cedricshock> emu: The separation leads to wanting an interface to vectors and such, which leads to the abstract description of vector spaces (or at least their elements and transformations) which leads to a little tiny refactoring that makes me want to make all of abstract algebra underlying vector spaces.
12:51:08 <nominolo> > let f `on` g = \x y -> (g x) `f` (g y); f = groupBy ((==) `on` fst) . sortBy (compare `on` fst) in f [(1,2),(3,4),(1,5),(2,7),(3,9)]
12:51:10 <lambdabot>  [[(1,2),(1,5)],[(2,7)],[(3,4),(3,9)]]
12:51:19 <nominolo> \o/
12:51:22 <Jaak> :)
12:51:40 <helmut> my nextsym actually is nextsym :: (Int -> Code) -> State Int Code
12:51:44 <emu> :t on
12:51:46 <lambdabot> Not in scope: `on'
12:52:25 <LoganCapaldo> on is almost, but completely not s, ain't it?
12:52:26 <helmut> so why should it be return (f n) instead of f n when f is to return State Int Code?
12:52:45 <emu> oh, f returns that?
12:52:54 <emu> sorry, i thought f :: Int -> Int
12:53:02 <Saizan> helmut: well that depends on which functions you want to use nextsym
12:53:25 <helmut> Saizan: I'd like to write n <- nextsym instead of n <- get; put (n+1)
12:53:26 <Saizan> helmut: if you want to pass it "pure" or "monadic" functions
12:53:52 <cedricshock> emu: The actual sets as in, for a group, "A set A..." the set isn't interesting, and most of the time you are going to be working with very specific elements of the set (the way Data.Monoid is made).
12:54:08 <helmut> (and obviously I don't understand what type get and put has [although I can read it on haskell.org])
12:54:12 <Saizan> ah, if you just want that you have to write nextsym = do { n <- get; put (n+1); return n; }
12:54:22 <Saizan> wich is just of type State Int Int
12:54:28 <helmut> ah.
12:54:29 <emu> cedricshock: yes, but with Data.Monoid it assumes there is a statically determined set
12:54:55 <helmut> Saizan: could you also tell me why?
12:55:01 <emu> that the type itself is a monoid
12:55:11 <emu> (the type presumably being a set of values)
12:55:41 <Saizan> helmut: well because nextsym is just acting on the state, it doesn't need any parameter, no?
12:55:45 <cedricshock> emu: Yes, that's how it goes.
12:56:01 <LoganCapaldo> n++ :)
12:56:17 <emu> right, and i had basically a type which was in fact a "class of monoids" and I wanted to instance it but then realized my misconception :/
12:56:48 <helmut> Saizan: uhm. I'll reread that chapter about monads then.
12:57:07 <cedricshock> emu: Then your possible sets are the possible haskell types, and if you want to reason about the algebraic constructions themselves you are going to reason about haskell.
12:57:14 <Saizan> helmut: i think you are underestimating what a monad can do for you :)
12:57:45 <LoganCapaldo> Or maybe just underestimating what it _does_ do w/o additional effort
12:58:11 <emu> except they can't be types because they aren't statically determined
12:58:12 <Saizan> yeah, better expressed
12:58:17 <emu> so I guess I'm out of luck
12:58:27 <MyCatVerbs> cedricshock: I would love to see a proof of where exactly H-M type inference comes out on the Choamsky hierarchy. I wouldn't expect Turing completeness, but equivalence to a push-down automaton, maybe? =)
12:58:36 <helmut> Saizan: I don't think I can estimate that at all. %-)
12:58:58 <cedricshock> emu: The end of all this thinking is that types should be first-class objects in the language.
12:59:16 <emu> ah yes, I really want to make type inference undecidable
12:59:38 <helmut> Ok. What I did until now (and it compiles again) was to make compile :: Expr -> State Int Code and use nextsym where possible.
12:59:40 <Saizan> helmut: what was "f" in your intention?
13:00:19 <helmut> Saizan: good question: I thought that n <- nextsym was equivalent to nextsym (\n -> ...).
13:00:31 <emu> nextsym >>= (\n -> ...
13:00:39 <helmut> ahhh. :-)
13:00:44 <emu> where ... is the remainder of the function
13:00:49 <LoganCapaldo> @undo do { n <- nextsym }
13:00:50 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 19}) "Parse error"
13:00:51 <cedricshock> MyCatVerbs: I think I see your idea, thought your large words are difficult to see through.
13:01:06 <helmut> this is gonna become enlightening. :-)
13:01:07 <LoganCapaldo> @undo do { n <- nextsym; }
13:01:08 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 20}) "Parse error"
13:01:29 <emu> MyCatVerbs: eh? basic H-M type inference is PSPACE-complete unless my memory fails me
13:01:30 <Saizan> @undo do { n <- nextsym; f n }
13:01:31 <lambdabot> nextsym >>= \ n -> f n
13:01:35 * LoganCapaldo wonders what he is doing wrong
13:01:44 <emu> which it probably does
13:01:56 <helmut> ok. further suggestions?
13:02:08 <MyCatVerbs> cedricshock: sorry, I should've phrased that better. Though I've no clue how.
13:02:16 <Saizan> LoganCapaldo: do-notation must end with an expression
13:02:41 <helmut> (or "why do you do ... like ...?" questions? ;-)
13:02:47 <LoganCapaldo> yeah, I guess I was hoping I could be lazy with @undo :)
13:02:50 <emu> LoganCapaldo: ie. it cannot end with a <- b
13:03:05 <MyCatVerbs> emu: ohhh. But it's always decidable, right?
13:03:26 <emu> it's unification basically
13:03:49 <emu> H-M on the simply typed lambda calc.  but extensions throw a wrench in that.
13:04:05 <Saizan> helmut: i see you repeat show n many times, you could put a let n' = show n on the previous line and replace show n with n'
13:04:15 <LoganCapaldo> :t f v = do { v' <- v; v' }
13:04:17 <lambdabot> parse error on input `='
13:04:31 <helmut> Saizan: show is already incorporated in nextsym on my local copy. ;-)
13:04:41 <LoganCapaldo> :t \v -> do { v' <- v; v' }
13:04:44 <lambdabot> forall (t :: * -> *) t1. (Monad t) => t (t t1) -> t t1
13:04:46 <Saizan> helmut: ok :)
13:05:10 <LoganCapaldo> join in do notation hooray
13:05:50 <cedricshock> MyCatVerbs: Maybe, "I wonder what problems can be solved or computed by [a machine which operates on, outputting the inferred types] type inference alone?"
13:06:39 <helmut> Saizan: So what do you suggest to do next? Options might be: 1) Implement the C part to actually generate a binary. 2) Improve symbol allocation and avoid things like value _2 = lookup(c, "x"); value _3 = lookup(c, "x"); 3) cache constants 4) ...?
13:07:06 <MyCatVerbs> cedricshock: much clearer, thanks.
13:07:24 <helmut> Saizan: Maybe I can also get rid of this lookup function completely, but I don't know how.
13:07:37 <emu> "given a polynomial time algorithm to decide type inference, what class of problems is decidable in poly time?"
13:08:17 <emu> "a machine with access to an oracle deciding type inference can decide what class of languages in poly time?" <- different class, P^PSPACE  I believe it's called
13:08:43 <Saizan> helmut: i'm not very knowledgable in compilers :D
13:08:54 <MyCatVerbs> emu: mmm, I wasn't really interested in time+space complexity, just calculatability. =)
13:08:57 <helmut> Saizan: I'm not either (yet ;-).
13:09:06 <emu> ah, mathematician i see =)
13:09:40 <MyCatVerbs> emu: lazy arse. And FSAs and push-downs are really predictable anyway, hee. =)
13:10:18 <dmwit> MyCatVerbs: I was under the impression that ghc's type-checker was Turing complete.
13:10:35 <dmwit> This doesn't necessarily imply that Hindley-Milner is Turing complete, though.
13:11:47 <dmwit> Ah, yes, here we are.
13:11:50 <dmwit> http://article.gmane.org/gmane.comp.lang.haskell.general/14088
13:11:52 <lambdabot> Title: Gmane -- Mail To News And Back Again
13:13:58 <MyCatVerbs> ...wow.
13:14:40 <emu> MyCatVerbs: hmm, equality of PDAs is not decidable
13:14:45 <cedricshock> Anyone have any ideas on the error described here (with source)?: http://hpaste.org/1628#a2
13:15:36 <MyCatVerbs> emu: no, but their operation is guaranteed o(n) in both time and space. And I thought it was an open problem?
13:15:52 <MyCatVerbs> On two counts. Firstly, nice type checker. Secondly, awesome bot feature. The only better way to beat that would be to have it chuck a screenshot through libaa to detect goatses in advance.
13:16:01 <MyCatVerbs> Then again, that would kinda defeat the point. Heehee.
13:16:09 <dmead> lol
13:16:38 <dolio> cedricshock: You'll need -fglasgow-exts, I believe.
13:17:31 <emu> MyCatVerbs: o(n)?
13:17:34 <cedricshock> dolio: Thanks a bundle.
13:17:34 <emu> you sure about that?
13:17:35 <MyCatVerbs> Incidentally, LHS is just a beautiful idea.
13:17:56 <cedricshock> LHS = left hand side in my mind. What's it in yours?
13:18:01 <MyCatVerbs> emu: I think so. You can't put more than one token on the stack per symbol of input data and you can't backtrack on input data.
13:18:08 <emu> istr that parsing CFGs is O(n^3) about the same as matrix mult
13:18:12 <MyCatVerbs> cedricshock: .lhs, literate Haskell. Haskell embedded into TeX.
13:18:48 <emu> MyCatVerbs: it's nice. lhs2TeX helps too.
13:19:01 <MyCatVerbs> emu: oh. Damn. Is that for unlimited-look-ahead?
13:20:17 * helmut has chosen option 1 (implement the C functions).
13:20:24 <MyCatVerbs> emu: perhaps I'm failing to understand something here. Isn't a PDA only allowed to make state changes while moving the input tape at the same time?
13:20:41 <emu> PDAs are non-deterministic
13:20:43 <dmwit> MyCatVerbs: Are we talking about the same PDAs?  In my world, PDAs are non-deterministic (essentially allowing backtracking), and you can push any string onto the stack for each symbol of input data.
13:20:54 <emu> deterministic PDAs are different complexity
13:22:38 <MyCatVerbs> Oh. I suck, then. I need to reread this stuff by the sound of it. I *think* I meant deterministic PDAs, though I ought to be smacked with a squeaky hammer anyway for spouting tripe.
13:22:50 <emu> i had a paper on it too, i think i left it at home
13:23:04 <MyCatVerbs> Turing Omnibus. ^^
13:24:18 <emu> equivalence is decidable on DPDAs, but not on NPDAs
13:24:46 <shapr> I can hold my Palm IIIx next to my Nokia 770 and say that they are truly not equivalent... wait, which sort of PDAs?
13:24:50 <therp> a copy of "implementation of functional programming languages": 376 EUR?!
13:25:13 <shapr> therp: Cheaper than Hammings "Art of Doing Science and Engineering"
13:26:15 <sioraiocht> therp: I thought that was out of print
13:26:29 <_igor_> therp: http://research.microsoft.com/~simonpj/papers/slpj-book-1987/index.htm
13:26:32 <lambdabot> Title: The Implementation of Functional Programming Languages, http://tinyurl.com/fvgtw
13:26:40 <therp> sioraiocht: yeah it is, but obviously someone is reselling it on amazon
13:26:43 <emu> shapr: if by any chance you come across a non-deterministic Turing Machine, let me know
13:26:55 <shapr> emu: Easy enough, watch my computer overheat.
13:27:12 <dmwit> Heh.  But random /= non-deterministic...
13:27:13 <therp> igor: thanks I know that but I prefer the dead-tree version (and atm I'm too lazy to print it myself)
13:28:16 <shapr> Hm, is that guy related to Erik Meijer?
13:30:29 <MyCatVerbs> emu: how nondeterministic is nondeterministic anyway? We have all these wonderful random number gizmos based on thermal noise... not to mention the insane things that happen on the insides of SMP boxen.
13:31:05 <emu> non-deterministic means exploring many possibilities at the same time
13:31:06 <dmwit> nondeterminism means there are multiple possible execution paths, and the correct one is "guessed".
13:31:23 <emu> for example, the algorithm to solve any problem in NP
13:31:25 <nominolo> @hoogle interleave
13:31:26 <lambdabot> Control.Monad.ST.unsafeInterleaveST :: ST s a -> ST s a
13:31:26 <lambdabot> System.IO.Unsafe.unsafeInterleaveIO :: IO a -> IO a
13:31:39 <emu> Select solution non-deterministically
13:31:47 <nominolo> @hoogle a -> [a] -> [a]
13:31:48 <lambdabot> List.intersperse :: a -> [a] -> [a]
13:31:48 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
13:31:48 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
13:31:51 <emu> verify solution
13:32:21 <emu> hey you could write it in the List monad
13:32:45 <dmwit> Yeah, and too bad Set isn't a monad.
13:32:53 <dmwit> Then you could to state pruning...
13:34:45 <LoganCapaldo> Set isn;t a monad in haskell, or just not a monad period?
13:34:53 <Saizan> in haskell
13:35:19 <nominolo> @src deleteBy
13:35:20 <lambdabot> Source not found. Do you think like you type?
13:35:31 <Saizan> because you need an Ord constraint on the types that it can embed
13:35:38 <dmwit> LoganCapaldo: Well, it requires the comparison of two elements.
13:35:45 <dmwit> That isn't allowed for Haskell monads.
13:35:46 <ohmega_> is it possible to get some kind of backtrace for an error like Main: Prelude.head: empty list
13:36:04 <shapr> I think ndm wrote a library that does something helpful there.
13:36:41 <shapr> But I don't think there's a general way to get the call stack and figure out who's passing in bad input.
13:36:50 <Saizan> the profile trick applies here? ghc --make -prof -auto-all and then run with +RTS -xc ?
13:36:53 <shapr> Some people use safeHead
13:37:03 <ohmega_> hm ok
13:37:04 <shapr> Saizan: Ooh does that really work?
13:37:11 <dmwit> ?hoogle assert
13:37:12 <lambdabot> Control.Exception.assert :: Bool -> a -> a
13:37:13 <lambdabot> Test.HUnit.Base.assert :: Assertable t => t -> Assertion
13:37:13 <lambdabot> Control.Exception.assertions :: Exception -> Maybe String
13:37:27 <nominolo> :t safeHead
13:37:29 <lambdabot> Not in scope: `safeHead'
13:37:32 <Saizan> shapr: i've seen it suggested in this channel, never used myself
13:37:45 <dmwit> safeHead === listToMaybe ?
13:37:51 <dmwit> :t listToMaybe
13:37:53 <shapr> nominolo: I mean, write your own version of head
13:37:54 <lambdabot> forall a. [a] -> Maybe a
13:38:07 <nominolo> k
13:38:23 <kpreid> if you use pattern matching, the error will give the location of the failure
13:38:31 * helmut dances as his compiler produced an executable!
13:38:49 <shapr> helmut: Are you writing your own Haskell compiler?
13:39:00 <kpreid> > (\[x] -> x) []
13:39:01 <lambdabot>   Non-exhaustive patterns in lambda
13:39:26 <helmut> shapr: I'm writing a compiler for an unknown language in Haskell. (I doubt that anyone except kosmikus knows this language in here)
13:39:34 <dmwit> > (\[x] -> x) [1,2,3]
13:39:36 <lambdabot>   Non-exhaustive patterns in lambda
13:39:36 <dmwit> =(
13:39:39 <kpreid> well, lambdabot stripped it, but if you use (\[x] -> x) in place of head, say, you'll get a useful error
13:39:58 <dmwit> > (\(x:xs) -> x) [1,2,3] -- =)
13:40:00 <lambdabot>  1
13:40:03 <helmut> shapr: (he wrote the original interpreter(?) with Ralf Hinze)
13:40:05 <ohmega_> :)
13:40:13 <kpreid> dmwit: whoops
13:40:20 <kpreid> of course, this requires knowing that *that* occurrence of head is potentially relevant
13:40:35 <ohmega_> the profile trick actually did the trick :)
13:40:47 <nominolo> I once wrote a compiler for an incredible language: codeGen = "mov eax,42; call __rts_print; ret"
13:40:52 <LoganCapaldo> import Prelude hiding ( head ); head (x:_) = x ??
13:40:56 <Saizan> ohmega_: good :)
13:41:09 <pejo> helmut, what's the name of the language?
13:41:13 <shapr> helmut: Lemme guess, type indexed types or some other nifty generic programming thingy?
13:41:34 <shapr> kosmikus' thesis has nifty content and cool graphics.
13:41:38 <shapr> I like the alien lambdas.
13:41:55 <Saizan> laien lambdas?
13:42:23 <helmut> pejo: formerly bpl and now trinity
13:43:20 <shapr> helmut: Tell us more about it.
13:43:48 <shapr> Saizan: Yeah, alien lambdas in kosmikus' PhD thesis. You should read it.
13:43:53 <helmut> shapr: It is dynamically typed (with static type inference) and stricly evaluated.
13:44:32 <shapr> I like to say dynamically checked or statically checked.
13:44:38 <helmut> shapr: (my implementation doesn't do any type checking at compile time though (and I only implemented a minimal subset)
13:44:52 <shapr> In my opinion, Haskell is compile time "dynamically typed" because of type inference.
13:45:16 <shapr> thoughtpolice: Are you part of a gang? SyntaxPolice was here earlier.
13:45:22 <helmut> an example looks like (fun x => x * x) 7
13:45:29 <Philippa> by which you mean "does something that smells like a duck typer"?
13:45:50 <shapr> Philippa: That's pretty cheesy :-)
13:45:51 <thoughtpolice> shapr: no. but it's a good idea. :)
13:46:13 <shapr> Philippa: Just how many of the XP/Ruby/Python cheesy terms can you fit into one sentence?
13:46:14 <MyCatVerbs> Philippa: type inference is a practical form of poultry-sniffing?
13:46:27 <shapr> HM is Poultry in Motion
13:46:55 <MyCatVerbs> I really can't argue with that.
13:46:59 <Philippa> I actually quite like "smell" as a term so long as it's not used too pretentiously
13:47:07 <helmut> (I'm now trying to write faculty)
13:47:12 <Philippa> it's just a way of saying "trips some of my pattern-matching for..."
13:47:55 <shapr> helmut: They're hard to implement.
13:52:53 <helmut> hmm. I wrote it, but somehow the generated c-code is broken.
13:55:37 <helmut> yeah. I computed faculty of 5! :-)
13:56:16 <helmut> let val y = fun f => f f in let val fh = fun fh n => if n == 0 then 1 else n * fh fh (n - 1) in let val fac = y fh in fac 7 end end end
13:56:17 <shapr> Has anyone tried to talk to Erlang from Haskell via an FFI binding to erl_interface?
13:56:22 <shapr> helmut: Oh, factorial?
13:56:38 <helmut> shapr: ah. yes. Am I mixing up terms again? ;-)
13:56:42 <shapr> på engelska, faculty betyder lärare
13:57:01 <helmut> shapr: of course I am, sorry. I meant factorial.
13:57:09 <shapr> talar du svenska?
13:57:19 <helmut> I'm German.
13:57:25 <shapr> I know, just curious if you speak Swedish.
13:57:34 <helmut> no.
13:57:47 <shapr> Where Dutch was the necessary language for Python, Swedish appears to be important to Haskell.
13:57:51 <shapr> Ok, Dutch too..
13:58:05 <dmead> oh yes
13:58:08 <dmead> my unification works
13:58:08 <LoganCapaldo> wait, really? I have to learn swedish?
13:58:09 * shapr thinks of the Swierstras and Meijers and Hinzes oh my!
13:58:25 * dmead pelvic thrusts
13:58:27 * dmead pelvic thrusts
13:58:27 * dmead pelvic thrusts
13:58:33 <shapr> LoganCapaldo: Yeah, but it's easy. Move to Sweden, hook up with a gorgeous Swedish woman, then you have all the motivation you'll ever need.
13:58:42 <Heffalump> all the Dutch and Swedish Haskellers I'm aware of speak excellent English..
13:58:59 <shapr> Yeah, but Swedish is so much fun!
13:59:10 <LoganCapaldo> but I'm already hooked up with a gorgeous non-Swede
13:59:12 <helmut> I'd like to thank you very much for helping me to write my first real compiler! :-)
13:59:13 <shapr> I was amazed when Johan Jeuring spoke Swedish to bringert.
13:59:23 <Heffalump> :-)
13:59:23 <shapr> LoganCapaldo: Oh well, too late for you.
13:59:25 <earthy> Johan was in Sweden for a couple of years
13:59:28 <LoganCapaldo> I'm doomed
13:59:31 <LoganCapaldo> doomed
13:59:37 <shapr> earthy: Yeah, I spoke Swedish with him and we discussed it, but I was still amazed.
13:59:41 <helmut> (I only need to implement 99 bottles now. ;-)
13:59:42 <thoughtpolice> shapr: that's something i was thinking of trying one of these days.
13:59:58 <earthy> oh, I think Johan speaks something like 4 or maybe 5 natural languages
14:00:09 <shapr> I was talking to my girlfriend in Swedish with a bunch of Dutch guys standing around me.. how was I supposed to know half of 'em understood me??
14:00:15 <earthy> not impressive to me at all. I'm working on brushing up on my 4th. ;)
14:00:21 <thoughtpolice> and if SoC gets shared library support done there's also the possibility of using haskell for robust port drivers; but I'm not totally sure as to what this might require
14:00:24 <Heffalump> earthy: what 4?
14:00:26 <shapr> I can speak .. maybe 1.5 langauges.
14:00:28 <pejo> earthy, dutch, english, german and swedish?
14:00:40 * kc5tja only knows English.
14:00:40 <Heffalump> anyway, the Dutch should be left out of all competitions involving speaking lots of languages well.
14:00:43 <earthy> Dutch, English, German and Portuguese
14:00:53 <earthy> and I dabble a bit in French
14:01:10 <earthy> and I did try my hand at Bahasa Indonesia a couple of years back
14:01:10 <shapr> Nijmegen Dutch is just sooo much fun to speak. You gotta be a heavy smoker to start learning that crazy G sound.
14:01:15 * kc5tja is an intellectual caveman who happens to know C/C++, Haskell, Python, Forth, Java, BASIC, Oberon, ...
14:01:18 <earthy> but thag language is *weird*
14:01:41 <thoughtpolice> i cheated my way through spanish because i sucked at it. there, i admit it.
14:01:50 <earthy> shapr: ghe. :)
14:01:51 <shapr> Flanders Dutch is pleasant, but not nearly as much fun.
14:02:05 <earthy> the flemish tend to speak the language in a monotone
14:02:14 <earthy> whereas the dutch speak it with more variation. ;)
14:02:16 * kc5tja has lived in California for about 10 years; I worked with a bunch of people from Argentina.  And still, I know nothing about Spanish.  :)
14:02:34 <earthy> kc5tja: that's... weird. :)
14:02:41 <shapr> kc5tja: I tend to absord whatever languages are spoken around me. It just happens.
14:02:45 <shapr> absorb*
14:02:53 <earthy> no hablo español, mas qiero aprendar
14:02:54 * kc5tja wishes he could do that too.
14:03:08 <shapr> I picked up a bunch of German when I spent a few weeks in Munich and in Erlangen.
14:03:33 <shapr> But languages disappear when I don't use them :-(
14:03:37 <kc5tja> No, no habla Espanol.  Qual aprendar?  (I think that's right.)
14:03:37 * earthy nods
14:03:54 * earthy would like to learn spanish
14:03:59 <Heffalump> shapr: is that like trees falling in the woods?
14:04:01 <earthy> wans't that clear? :)
14:04:16 * earthy laughs at hef
14:04:23 <kc5tja> earthy: What is aprendar?  I haven't a clue.
14:04:23 <shapr> Heffalump: Er yeah... when trees fall in the woods they can no longer speak!
14:04:27 <shapr> to learn
14:04:30 <kc5tja> And am too lazy to translate online.  :)
14:04:31 <Heffalump> they could speak before? wow.
14:04:33 <shapr> apprendre in French
14:04:39 <shapr> Heffalump: Well no.. but it's like that doctor joke..
14:04:52 <magnus> I learned french for 6 years, then when I learned chinese it pushed out all my french
14:05:07 <shapr> Patient: "Will I be able to play the violon after the surgery" Doctor: "Yes" Patient: "Excellent! I couldn't do it before!"
14:05:08 <earthy> the only language I actually lost is portuguese
14:05:33 <earthy> but that's mostly due to growing up between the period that I last spoke portuguese and now
14:05:49 <earthy> somehow one's vocabulary not only expands but als *changes* as one grows older
14:05:56 <shapr> magnus: I learned French in college, then I learned Swedish decades later. Now when people speak French to me I have to struggle not to respond in Swedish.
14:06:08 <MyCatVerbs> Patient: "How will this effect my sex life?" Doctor: "Er, I... um. To be honest, you're the first person who's ever asked that question over a tonsillectomy."
14:06:20 <magnus> shapr: must be the same effect! I also struggle to not mix up the vocabulary of them two
14:06:46 <earthy> I spoke social german mostly to a french roommate
14:07:07 <earthy> (who was fluent in german, where I was nowhere near as fluent in french)
14:07:23 <earthy> so I have trouble speaking french when around her, even in france. ;)
14:07:31 <shapr> magnus: I found some neat data points about that too.. Almost everyone I've met can only do out loud math in their first language. A German girl I knew learned Geology in English, went back to Leipzig, and in later classes had to translate her notes to English for studying.
14:08:03 <Heffalump> I can do maths out loud in all the languages I know.
14:08:04 <shapr> magnus: For me, there are several words and concepts I learned first in Swedish or Dutch or whatever language, and I use those words in English conversations if I'm not thinking about it.
14:08:14 <shapr> Heffalump: Which languages? When did you learn them?
14:08:22 <Heffalump> I only know one language :-)
14:08:24 <shapr> heh ok
14:08:33 <Heffalump> well, I know some French, but it's pretty dire
14:08:37 <magnus> shapr: that must sound funny. I can do maths in both english and swedish but it is significantly harder in chinese for me
14:08:40 * earthy has the advantage that he learned both Dutch and Portuguese from the day he was born
14:08:51 <Heffalump> earthy: precocious kid
14:09:02 <shapr> magnus: Can you count the number of things in a basket and still keep count of them?
14:09:02 <earthy> nah. victim of circumstance. ;)
14:09:22 <shapr> magnus: Din namn låter Svensk, kommer du från Sverige?
14:09:33 <Heffalump> I meant your claim that you were learning language from the day you were born. I don't know how these things work, but I find it a little dubious that babies would do that so early.
14:09:55 <magnus> shapr: Ja jag är svensk.
14:09:56 * earthy tries his hand at translating shapr: 'You mentioned speaking Swedish, are you from Sweden?'
14:10:08 <shapr> earthy: Heh, I said "Your name sounds Swedish, are you from Sweden?"
14:10:25 <shapr> magnus: Haven't we had this conversation many months ago?
14:10:28 <earthy> ah! :)
14:10:34 <magnus> shapr: every few months :P
14:10:37 <shapr> heh
14:10:50 <earthy> låter, as in 'luiden' as in 'to sound'
14:10:51 <kc5tja> Magnus sounds latin to me.  (As in, Magnus Corpus)
14:10:58 <shapr> earthy: Yup, and namn == name
14:11:04 * earthy nods
14:11:07 <magnus> kc5tja: Yes, it comes from latin
14:11:21 <earthy> I should switch to more germanic roots when trying to decipher swedish
14:11:27 <earthy> it's easier with danish
14:11:52 <magnus> shapr: I guess I can count the balls in a basket in english but still it would be a little easier in swedish
14:11:54 <shapr> Yeah, German and Swedish are closer to each other than Dutch.
14:12:05 <shapr> That's my impression at least.
14:12:20 <pejo> earthy, can you decipher danish, but not swedish?
14:12:25 <earthy> pejo: yup
14:12:38 <shapr> jeg ikke .. umm
14:12:48 <earthy> at least, my intuition is right more often with danish than with swedish
14:12:55 <earthy> especially with spoken danish
14:13:20 <shapr> Spoken Danish sounds a lot more like Dutch to me.
14:13:21 <earthy> (this totally caught a couple of danes discussing taxes off guard at a conference dinner ;))
14:13:25 <shapr> haha
14:13:40 <shapr> Jag hatar skatteverket... eftersom det hatar mig :-(
14:13:50 <koala_man> kartoffel
14:13:50 <nominolo> heh
14:14:23 <nominolo> kartoffel is german
14:14:30 <koala_man> and danish
14:14:32 <pejo> shapr, we all do!
14:14:45 <tibbe> is there any lowhanging fruit in the ghc optimizer/code generator that noone has gotten to but I could try to improve?
14:15:44 <nominolo> tibbe: not exactly related, but there was a SoC proposal on modifying the GC-subsystem for NUMA systems
14:15:54 <shapr> Skatteverket skickat ett brev till mig, det säger "Du har inte skickat skatt till oss i sex månader. Betala nu eller känna ont." Men jag bor inte i Sverige!
14:16:00 <nominolo> tibbe: hm, and not low-hangig, either
14:16:09 <tibbe> nominolo, :/
14:16:14 <tibbe> shapr, trevligt
14:16:28 <shapr> jo, faktist
14:16:31 <nominolo> shapr: det r normalt
14:16:35 <shapr> haha
14:16:40 <earthy> happens in the netherlands as well
14:16:50 <tibbe> jag bor också utomlands nu, ska se hur lång tid det tar innan de vill ha mig
14:16:52 <earthy> when you're dual-homed and dual-working you're basically fucked. ;)
14:17:28 <shapr> Well, I'd like to leave the utomlands and become inrikes, but if skatteverket doesn't get it straight, I'll be in trouble.
14:18:20 <nominolo> shapr: you're not from the EU, are you?
14:19:41 <dylan> but shapr is from a place with kilometers on the speed limit signs. ;)
14:20:15 <tibbe_> I heard a while ago that the next ICFP is about an hour or so from where I live :)
14:20:37 <nominolo> isn't it somewhere in germany?
14:20:43 <nominolo> freiburg?
14:20:50 <nominolo> @go icfp 2007
14:20:53 <lambdabot> http://www.informatik.uni-bonn.de/~ralf/icfp07.html
14:20:53 <lambdabot> Title: 12th ACM SIGPLAN International Conference on Functional Programming (ICFP 2007)
14:21:09 <tibbe_> nominolo, yes
14:21:14 <tibbe_> I live in Zurich atm
14:21:24 <nominolo> ok, that's close
14:22:38 <tibbe_> I wanted to work some on ghc code generatiosn but I want something easy to start with :)
14:22:59 * Heffalump visited Zurich in March
14:23:06 <tibbe_> there surely must be some things that S&S haven't done because they couldn't pull it off as research :)
14:23:09 <shapr> nominolo: Nah, I'm from Alabama. Everyone here speaks Swedish you know.
14:23:17 <tibbe_> Heffalump, how nice :)
14:23:22 <Heffalump> only briefly :-)
14:23:31 <nominolo> tibbe_: maybe better ask in #ghc or on the ghc mailing lists
14:23:39 <tibbe_> yeah
14:23:47 <pejo> tibbe, there are some comments in the source code for the NCG about "simple" things that aren't done.
14:23:47 <Heffalump> unrelatedly, my company's headquarters is there
14:24:25 <nominolo> shapr: 'course
14:24:32 <tibbe_> pejo, NCG? :)
14:24:40 <Heffalump> native code generato
14:24:40 <shapr> nominolo: Did you see the amusing entry on my blog about when giving previous address info the person tried to figure the USA state abbreviation for Sweden?
14:24:41 <Heffalump> r
14:24:46 <tibbe_> ah
14:25:18 <nominolo> shapr: heh, no
14:25:55 <shapr> nominolo: http://www.scannedinavian.com/hope/entry
14:27:16 <nominolo> oh, now that i see it, i've seen it before. but funny anyways .. :)
14:27:42 <shapr> :-)
14:28:00 <shapr> Hm, it looks like it would a real pain to use mnesia from a Haskell app.
14:28:07 <nominolo> your blog is similarly low-traffic like mine ;)
14:28:14 <shapr> Yeah, I keep meaning to post...
14:28:22 <shapr> I have lots to say, I just get distracted easily.
14:28:24 <nominolo> hey, me too!
14:28:48 <nominolo> ok, well, i wouldn't say i have much to say
14:28:53 <nominolo> but still ;)
14:28:54 <tibbe_> me too and I'm lazy
14:29:26 <nominolo> nah, just tell yourself noone's gonna read it anyways and you're good
14:30:29 <shapr> I found a neat paper that uses options theory to calculate the added value of a modular design relative to a less-modular design.
14:30:53 <nominolo> oh, that sounds good
14:30:55 <shapr> I'd like to use that to compare monad transformer stacks and objects.
14:31:11 <nominolo> s/good/interesting/
14:31:42 <shapr> Heffalump: That's the sort of abstractional complexity thingy I was talking about oh so long ago.
14:32:02 <chessguy> options theory?
14:32:18 <nominolo> i'm currently experimenting with constraint problem solving in haskell.  maybe that'll evolve to something useful ..
14:32:34 <chessguy> sounds buzzword-ish
14:32:54 <nominolo> option is a buzzword?
14:32:59 <mahogny_> nominolo, CSP? (or similar name) there was a really nice paper on it
14:33:10 <nominolo> mahogny_: er, link? :)
14:33:40 <DRMacIver> Nothing wrong with buzzwords. :)
14:33:56 <chessguy> DRMacIver: i didn't say there was
14:34:07 <DRMacIver> I didn't say you said there was.
14:34:23 <mahogny_> nominolo, forgot. but I can tell the outline
14:34:32 <chessguy> some things that are buzzwords are useful, when used correctly (e.g., ajax). some are just silly buzzwords (internet 2.0)
14:34:42 <nominolo> mahogny_: yes, please
14:35:15 <tibbe_> programming 2.0
14:35:24 <tibbe_> should be haskell's buzzword
14:35:40 <nominolo> "the Arc programming language"
14:35:44 <nominolo> "perl 6"
14:35:46 <tibbe_> haha
14:35:47 <nominolo> ;P
14:35:56 <chessguy> lambdas 2.0
14:36:09 <mahogny_> nominolo, their approach was to build a tree of all possible solutions lazily. then they could try heuristics 1. to generate the tree (randomizing order of choices on branches turned out to increase efficiency) 2. heuristics to remove invalid branches. they took care to make sure the branches were not evaluated until they really had to be evaluated; this way only the relevant parts of the tree was explored
14:36:18 <tibbe_> "less code than Arc and longer in development than perl 6"
14:36:23 <DRMacIver> tibbe_: Isn't 6GL the Haskell appropriate buzzword? :)
14:36:49 <mahogny_> nominolo, on top of this they could put code that generated all solutions lazily, but if they just wanted one then it would correspond to a search with backtracking
14:36:51 <MyCatVerbs> chessguy: internet2 isn't a buzzword, it's an eff off huge academic network. >_>
14:36:55 <chessguy> whoah
14:36:55 <tibbe_> DRMacIver, I think we're safe to move over to the 2XXX scale, Haskell 2007
14:36:58 <DRMacIver> (6th Generation Language)
14:37:10 * chessguy scrolls up to catch up on what mahogny_ and nominolo are talking about
14:37:13 <MyCatVerbs> DRMacIver: no. Don't.
14:37:26 <nominolo> mahogny_: do you know how the constraints were expressed?
14:37:26 <DRMacIver> Don't what? :)
14:37:30 <mahogny_> nominolo, they managed to get things were concrete by using the tree since they could modularize the tree from the heuristics
14:37:32 <nominolo> chessguy: CSP
14:37:41 <shapr> chessguy: Read the paper and see if it's a good buzzword: http://lambda-the-ultimate.org/node/2190
14:37:42 <lambdabot> Title: The Structure and Value of Modularity in Software Design | Lambda the Ultimate
14:37:46 <MyCatVerbs> DRMacIver: 7GL or 5GL, fine. But after the fiasco that are 4GLs, I'd avoid jinxing it by using an even number. =)
14:37:47 <chessguy> mahogny_: that sounds similar to what procyon112 is working on
14:37:51 <mahogny_> nominolo, hmmmm. not sure
14:37:56 <monochrom> hey
14:38:00 <stepcut> nominolo, mahogny: http://www.cse.ogi.edu/PacSoft/publications/2001/modular_lazy_search_jfp.pdf
14:38:03 <lambdabot> http://tinyurl.com/36gnp3
14:38:04 <stepcut> ?
14:38:08 <DRMacIver> MyCatVerbs: Oh, well there's already a 5GL. Sortof. That's why I skipped to 6.
14:38:33 <DRMacIver> MyCatVerbs: As far as I can tell, it was even more of a fiasco than 4.
14:39:01 <nominolo> stepcut: hey, yes.  i remember having seen that before
14:39:08 <nominolo> stepcut: thanks
14:39:11 <Philippa> nGL stopped making sense after 3
14:39:16 <mahogny_> nominolo, stepcut, yeah, that looks like the paper
14:39:21 <stepcut> it is one of my favorite papers :)
14:39:28 <DRMacIver> Philippa: Well, I wasn't really suggesting it as making sense. :)
14:39:44 <mahogny_> stepcut, I wasn't really convinced about lazy evaluation until I saw that one :)
14:39:44 <stepcut> mahogny_: there are two version of it btw, that is the second version with added dynamic variable ordering, and some other stuff
14:39:55 <mahogny_> stepcut, yeah, read that one
14:39:57 <Philippa> there's a related stack of languages in which the equivalent to 4GL is DSLs be they embedded or otherwise, but...
14:41:01 <stepcut> @whereis modular lazy search
14:41:01 <lambdabot> Maybe you meant: where where+
14:41:08 <stepcut> @where modular lazy search
14:41:09 <lambdabot> I know nothing about modular.
14:42:42 <nominolo> stepcut: yes, i downloaded all jfp articles for the last 5 years or so, but didn't get to taking a close look at them yet :)
14:42:56 <stepcut> nominolo: heh
14:43:15 <mahogny_> reading *all* articles sounds like a full-time hobby
14:43:22 <helmut> Saizan, shapr: are you interested in the result?
14:43:32 <monochrom> modular lazy search is so obvious and trivial that no one would write a web page about it.  Imagine someone writing a blog on x+y=y+x.
14:43:50 <nominolo> mahogny_: a _great_ hobby nevertheless :)
14:44:02 <mahogny_> nominolo, well, I wouldn't mind getting paid for it :)
14:44:20 <Saizan> helmut: yup!
14:44:34 <stepcut> monochrom: :p
14:44:42 <helmut> Saizan: I bet you all have darcs (havn't you?). http://subdivi.de/~darcs/compbau/
14:44:44 <lambdabot> Title: Index of /~darcs/compbau
14:44:55 <Saizan> i have
14:45:14 <nominolo> monochrom: was this honest?  i don't quit get the irony .. :/
14:45:23 <monochrom> I am honest.
14:45:34 <helmut> Saizan: uhm. let me guess. you also need examples. ;-)
14:46:00 <mahogny_> monochrom, the point is that it *is* trivial. unless you code some backwater language like C++. that is why the article is nice; so we can slap it in their face :)
14:46:02 <nominolo> helmut: an arbitrary instance would do, too
14:46:29 <nominolo> monochrom: ok, still, the paper is 31 pages :)
14:46:40 <Saizan> helmut: heh, given that i don't know the language.. :)
14:46:50 <hpaste>  helmut pasted "compiler examples" at http://hpaste.org/1630
14:47:03 <monochrom> I know, I know, people still need easy things explained.
14:47:58 <mahogny_> same way there are articles on functional DP out there. the DP concept would never have been "invented" if functional languages had been there in the beginning :)
14:48:04 <nominolo> helmut: heh, your literal part in literal program seems kinda omitted ;)
14:48:13 <helmut> nominolo: yes.
14:48:27 <chessguy> ?remember mahogny  the point is that it *is* trivial. unless you code some backwater language like C++.
14:48:28 <lambdabot> Done.
14:48:41 * mahogny_ gets his first quote ^_^
14:49:07 <monochrom> @remember the DP concept would never have been "invented" if functional languages had been there in the beginning :)
14:49:08 <lambdabot> Done.
14:49:14 <mahogny_> :O
14:49:17 <monochrom> Today is your day. :)
14:49:21 <mahogny_> :D
14:49:26 <helmut> Saizan: I'm still open to improvements. :-)
14:49:27 * mahogny_ celebrates
14:49:33 <nominolo> LISP was there long time ago
14:49:51 <mahogny_> yeah, ok, you'd need a pure functional language
14:49:54 <Wild_Cat> technically speaking, though, functional languages *were* there in the beginning. I mean, how old is LISP now, 50?
14:49:55 <nominolo> though Lisp only become purely functional .. well .. er ...
14:49:59 <monochrom> "there" means widespread use, not just existence
14:50:04 <ddarius> Except monochrom's @remember is attributed to "the"
14:50:20 <monochrom> @remember mahogny the DP concept would never have been "invented" if functional languages had been there in the beginning :)
14:50:21 <lambdabot> Done.
14:50:38 <monochrom> Is there a way to delete?
14:50:41 <chessguy> @quote the
14:50:42 <lambdabot> the says: DP concept would never have been "invented" if functional languages had been there in the beginning :)
14:51:01 <ddarius> Technically, functional languages have been there in the beginning: lambda calculus.
14:51:02 <chessguy> what's DP anyway?
14:51:08 <chessguy> dynamic programming?
14:51:12 <mahogny_> yes
14:51:12 <monochrom> Yah
14:51:21 <nominolo> design patterns
14:51:23 <nominolo> ?
14:51:26 <mahogny_> eew
14:51:28 <Saizan> ?where frown
14:51:29 <lambdabot> I know nothing about frown.
14:51:29 <mahogny_> don't swear in here
14:51:34 <ddarius> monochrom: Hack the quotes file.
14:51:37 <chessguy> @quote frown
14:51:38 <lambdabot> dolio says: Perhaps he's an epigram guy and frowns on Turing completeness.
14:51:41 <Wild_Cat> "dynamic programming"? What's that supposed to mean?
14:51:50 <monochrom> fill in an array.
14:51:50 <mahogny_> DP is an algorithmic technique. I wouldn't classify it as a design pattern
14:52:00 <ddarius> It's programming while in motion.
14:52:05 <mahogny_> Wild_Cat, solve a problem by solving small subproblems and build your way up
14:52:19 <Wild_Cat> ddarius: no, that's called "using a laptop"
14:52:23 <monochrom> http://www.haskell.org/haskellwiki/Dynamic_programming_example
14:52:25 <lambdabot> Title: Dynamic programming example - HaskellWiki
14:52:46 <monochrom> I wrote section 1. :)
14:53:12 <kc5tja> mahogny_: That's just bottom-up coding.
14:53:17 <nominolo> how would one solve the rucksack problem in Haskell without DP ?
14:53:46 <mahogny_> kc5tja, well, ok, add "and remember the solutions to all the subproblems until you have solved the whole thing"
14:54:19 <mahogny_> nominolo, you can always enumerate all posibilities. that is essentially what DP does, but in a clever way
14:54:28 <monochrom> mahogny means the code execution progresses up, not the coder progresses up.
14:55:00 <nominolo> mahogny_: of course i'm speaking O(n^m) where m \in {2,3} time
14:55:02 <helmut> Saizan: frown is a parser generator by Ralf Hinze. On Debian there is a package otherwise see http://www.informatik.uni-bonn.de/~ralf/frown/index.html
14:55:03 <lambdabot> Title: Frown - an LALR(k) parser generator for Haskell
14:55:04 <Wild_Cat> okay, so that's basically recurrence with a cache.
14:55:27 <monochrom> Yes, it's that simple.
14:55:41 <Saizan> helmut: mmh i'll install from apt after the upgrade ends then :)
14:55:42 <helmut> Saizan: I can also provide the haskell files if needed.
14:55:51 <mahogny_> nominolo, if you code head on and put the subsolutions list in a "global" scope then haskell will do the memorization automatically
14:56:09 <Wild_Cat> mmh... and people had to go ahead and give a name to such a trivial thing?
14:56:33 <nominolo> Wild_Cat: it didn't seem trivial at the time
14:56:44 <nominolo> Wild_Cat: hell, "structured programming" has a name!
14:56:51 <Wild_Cat> nominolo: good point.
14:56:55 <monochrom> x+y=y+x has a name too.
14:57:00 <mahogny_> :)
14:57:09 <mahogny_> always good to have name on things
14:57:59 <Wild_Cat> of course, adding an infinite array data structure to the whole thing is icing on the cake.
14:58:37 <mahogny_> there are things with DP that are really messy in eager languages compared to lazy
14:58:49 <mahogny_> sometimes it turns out that you do not need to compute *all* subproblems
14:58:51 <nominolo> Wild_Cat: an infinite array structure with O(1) access? ;)
14:58:57 <monochrom> Having or not having names is not that important.  Common things have names, uncommon things don't have names.  This doesn't reflect difficulty.
14:59:14 <mahogny_> one example is multi-sequence DNA alignment; lazy can skip subproblems while it is a mess in eager ones
14:59:29 <monochrom> The more interesting phenomenon is that students actually struggle with this simple idea.  Takes them a month to see the point.
14:59:48 <Wild_Cat> nominolo: it doesn't have O(1) access. It has O(1) access for any index that's already been computed.
14:59:59 <LoganCapaldo> Maybe I missed the point
15:00:37 <mahogny_> monochrom, I think it might be just because they are presented it the eager way of manual table building as opposed to just caching pure calls
15:00:39 <LoganCapaldo> I always thought DP was "Do it recursively but make the stack explicit"
15:00:44 <Wild_Cat> initial access time is O(n) if I'm not mistaken.
15:00:44 <MyCatVerbs> mahogny_: jah, but it's possible to perform lazy computation in an eager language. Not easy in dumb languages, but entirely tractable in things like Scheme.
15:01:09 <mahogny_> yeah, of course you can :)
15:01:38 <Wild_Cat> mahogny_: depends what language you're using. It wouldn't be hard to implement this in Python, complete with array-like access. The code would be less elegant than the Haskell version, however.
15:01:42 <nominolo> Wild_Cat: is that in the paper?  anyways, yes, that's of course possible
15:01:49 <MyCatVerbs> Oh and functional + eager is a right bitch to work with until you realise the virtues of pattern matching. =)
15:02:15 <MyCatVerbs> (Or at least figure out how to force a short-circuit with. C++ templates are fun but evil.)
15:02:22 <mahogny_> Wild_Cat, it's possible in C even. linking with libghc is a good start ;)
15:02:33 <kc5tja> mahogny_: Well, in reading the site, it's nothing like bottom-up programming at all (it can certainly be implemented wiht it, but it's not a requirement).  The recurrance formula and memoization are the key characteristics.
15:02:33 <monochrom> It is insufficient to make the stack explicit.
15:02:44 <Wild_Cat> mahogny_: heh. In C you wouldn't get array-like access, though.
15:03:00 <mahogny_> kc5tja, yeah. if you read something else from me then you read it wrong
15:03:01 <Wild_Cat> maybe in C++, but I try not to dabble with it.
15:03:02 <magnus> just make a lazy C interpreter
15:03:20 <mahogny_> ouch
15:03:24 <SamB_XP> heh
15:03:33 <SamB_XP> that sounds really really really slow
15:03:35 <Wild_Cat> Lazy C? I think my head just exploded.
15:03:40 <mahogny_> mine too lol
15:03:43 <Saizan> helmut: such a beatyfully unreadable .c output :D  (but i've not read much c from a long time..)
15:03:49 <shapr> I've been thinking about a laziness tutorial, but I'm looking for more representative examples.
15:03:53 <mahogny_> it exploded when it tried to reason about a lazy void*
15:04:01 <SamB_XP> Saizan: it wouldn't help if you had
15:04:02 <Wild_Cat> auuugh!
15:04:15 <mahogny_> shapr, DP and the CSP paper above are extremely motivating
15:04:29 <Wild_Cat> well, wouldn't a lazy void* be similar to a monad, in some ways?
15:04:33 <nominolo> shapr: the wikibook chapter on laziness ranked high on reddit today
15:04:40 <mahogny_> Wild_Cat, both blow your head off? sure
15:04:46 <nominolo> (programming.reddit that is, of course)
15:04:46 <helmut> Saizan: I know it to be extremly ugly. ;-)
15:04:58 <helmut> Saizan: well it's my first compiler. ;-)
15:04:59 <Wild_Cat> void* sounds like a -> ()
15:05:12 <Wild_Cat> hehe
15:05:28 <helmut> Saizan: (and don't even think about leaks ;-)
15:05:29 <Saizan> helmut: well ghc is famous for its c output :)
15:05:36 <Wild_Cat> lazy malloc/free for the win.
15:06:10 <nominolo> Saizan: and the evil mangler!
15:08:54 <kosmikus> hi helmut
15:09:15 <Saizan> nominolo: which is in perl, right?
15:09:22 <nominolo> yep
15:09:26 <helmut> hi Andres!
15:09:47 <helmut> kosmikus: did you read, that I got a minimal bpl subset compiled to c?
15:10:18 <shapr> Hm, no one seems to mention multidimensional traversal of data structures.
15:10:38 <kosmikus> helmut: I've only browsed the log just now.
15:10:49 <mahogny_> shapr, is that related to lazyness?
15:10:52 <kosmikus> helmut: great.
15:10:56 <shapr> When I mention laziness to Python/Scheme/etc people they talk about generators or streams. But those are limited to one dimensional traversal.
15:11:50 <Wild_Cat> shapr: indeed. But that's the most common use case.
15:12:09 <shapr> Wild_Cat: Could that be because it's all you can do in those languages?
15:12:25 <magnus> there's of course delay/force too
15:12:39 <Wild_Cat> however, (in Python at least) you can, with a little bit of additional effort, create lazy data structures with random access.
15:12:57 <Wild_Cat> the best-known example being xrange
15:13:07 <DRMacIver> shapr: I conjecture that this is because people are still stuck thinking in for loops.
15:13:14 <shapr> DRMacIver: I think you're right.
15:13:21 <monochrom> People are stuck in loops.
15:13:21 <Wild_Cat> shapr: no, I think it's because program input is a function of time.
15:13:32 <DRMacIver> I find it really hard to break out of the habit myself, and I hate the damn things.
15:13:33 <mahogny_> shapr, one thing I find appealing, but I think current haskell code uses it little, is that data can actually bypass temporary data structures. in C/Java/YouNameIt, if some function prefers data in another format than you have it in, then you have to restore everything. but in haskell you can actually "restore" it but it is only formally; haskell gives you nice speed optimizations without reworking your entire API
15:13:49 <kosmikus> helmut: so you're generating C from Haskell?
15:13:55 <shapr> Wild_Cat: Yeah, but how would you create a lazy data structure with multiple dimensions?
15:14:03 <helmut> kosmikus: yes. see http://subdivi.de/~darcs/compbau/
15:14:04 <lambdabot> Title: Index of /~darcs/compbau
15:14:14 <mahogny_> shapr, I'd say most forms of streaming is a subset of above example
15:14:25 <sorear> hello!
15:14:33 <DRMacIver> Hi sorear
15:14:35 <Wild_Cat> shapr: more difficultly, but that'd still be doable.
15:14:39 <shapr> Wild_Cat: How so?
15:15:10 <Wild_Cat> in essence, all you're implementing is a class that masquerades as a list/hash, or list/hash thereof
15:16:00 <monochrom> You can make a lazy tree.
15:16:15 <Wild_Cat> n-dimensional data structures are very hard to do, but if n is fixed it becomes much easier.
15:16:41 <shapr> Yeah, that's true.
15:16:47 <monochrom> Also a lazy list of lazy lists.
15:17:00 <Wild_Cat> in essence, your base class overrides __get__ to return a lazily-generated instance of another class, which itself overrides __get__ too to lazily generate the actual result.
15:17:03 <helmut> kosmikus: the source (especially the generated source) looks a bit ugly, but I'm open to improvements. ;-)
15:17:10 <DRMacIver> monochrom: Ony Haskell can make a (lazy) tree? :)
15:17:29 <monochrom> Any lazy programmer can make a lazy anything.
15:17:39 <shapr> Wild_Cat: Yeah, but that's semi-deep magic to do what's intuitive in Haskell.
15:17:51 <shapr> Well, whether or not it's intuitive, it's often done.
15:17:57 <DRMacIver> I can't. I'm too lazy. Or possibly it's just that no one bothers to evaluate me.
15:18:22 <Wild_Cat> shapr: well, who'd have thought a lazy language would be easier to use for lazy data structures than a strict one? :p
15:18:45 <DRMacIver> Hm. I wonder if structured programming was a mistake.
15:18:49 <kc5tja> shapr: I just read an internal e-mail where someone here is using generators to traverse a multi-level tree (so, 1.5 dimensions -- but it'd be 2-dimensional easily enough if all items had the same number of leaves).  It appears quite doable even if non-obvious.
15:19:02 <shapr> Wild_Cat: I think it's easier to be strict in Haskell than it is to be lazy in Python.
15:19:22 <monochrom> DRMacIver is ready to listen to my supervisor :)
15:19:23 <Wild_Cat> shapr: I don't call that "deep" magic, though. Especially when in my case, the use of __get__ instead of a more general get_item method is syntactic sugar to enable the use of the [] operator.
15:19:37 <fasta> kc5tja: isn't that the same as with continuations?
15:19:42 <DRMacIver> monochrom: Hm?
15:20:09 <kc5tja> fasta: I don't understand your question.  Can you elaborate/
15:20:10 <ddarius> @google "Functional Pearl" "Weaving a web"
15:20:12 <lambdabot> http://www.informatik.uni-bonn.de/~ralf/publications/TheWeb.ps.gz
15:20:23 <Wild_Cat> shapr: perhaps. I haven't used Haskell for long enough to answer that so I'll take your word on this one.
15:20:36 <shapr> Wild_Cat: Well, when you figure it out, tell me :-)
15:21:05 <Wild_Cat> however, the more I dive into Haskell, the more obvious it is to me that it influenced Python.
15:21:14 <shapr> Part of why I got into Haskell was that Chris Tismer's first version of Stackless was rejected by Guido et al.
15:21:40 <kc5tja> Wild_Cat: As far as I'm aware, Python only borrowed list comprehensions from Haskell; yield and so forth come from Scheme's continuation support.
15:21:55 <fasta> kc5tja: it's one of the exercises in The Scheme Programming Language, 3ed.
15:22:23 <fasta> kc5tja: you compare two trees at the same time by traversing them both at the same time by using continuations.
15:22:26 <kc5tja> fasta: "it" meaning???  I'm still very confused.  Also I haven't read the book.
15:22:32 <fasta> kc5tja: ok, never mind
15:22:37 <dmead> you can fill out a tuple with an arrow right
15:22:37 <kc5tja> fasta: Oooh...now I see the connection.
15:22:38 <Wild_Cat> shapr: When they get PyPy done, however, it seems that Stackless will become part of the mainstream distribution.
15:22:43 <dmead> (x,y) <- foo
15:22:48 <dmead> where foo returns a typle
15:22:52 <dmead> *tuple
15:22:53 <dmead> ya?
15:22:59 <fasta> ddarius: Didn't Oleg generalize that?
15:23:05 <kc5tja> Yeah, "yield" is similar to invoking a continuation, but is a bit more structured.
15:23:10 <monochrom> May I ask for a type of foo?
15:23:11 <kc5tja> (and hence, less flexible)
15:23:12 <Wild_Cat> since enabling Stackless features in PyPy is just a matter of setting a flag.
15:23:19 <mahogny_> dmead, yes
15:23:31 <dmead> foo :: a -> (Int, Int)
15:23:34 <dmead> kk
15:23:35 * DRMacIver pokes monochrom. Please to be explaining your comment. :-p
15:23:47 <monochrom> I don't want to explain it.
15:23:51 <kosmikus> helmut: I've downloaded the repo, but I'll probably not look at it anymore tonight
15:24:05 <DRMacIver> monochrom: Only because you like maintaining your delphic image. ;)
15:24:26 <monochrom> I'm just too lazy.
15:24:36 <Cheery> what does the arrow -sugar turns to?
15:24:37 <monochrom> and inconsistent
15:24:49 <Cheery> ie. proc a -> return -< a+1
15:24:52 <Cheery> what does this turn to?
15:24:52 <ddarius> The zipper is related to the web, but there are some differences.  I'm not sure if Oleg's ZipperFS and such subsumes the web.
15:25:00 <sorear> Cheery: pass -ddump-ds to the compiler
15:25:03 <helmut> kosmikus: ok. ;-) about what works: let val fh = fun fh n => if n == 0 then 1 else n * fh fh (n - 1) in fh fh 30 end
15:25:03 <fasta> ddarius: he claims it does, IIRC
15:25:08 <ddarius> I haven't actually looked at the paper in years.
15:25:09 <shapr> Wild_Cat: Yeah, but I decided I like Haskell more than I like Python, so I doubt I'll ever go back to Python as a primary language.
15:25:09 <kc5tja> hmm...what is new in arrows that isn't new in dataflow analysis before?  It all looks the same to me, having perused the Arrows website last night.
15:25:10 <Cheery> @pl proc a -> return -< a+1
15:25:11 <lambdabot> (line 1, column 8):
15:25:11 <lambdabot> unexpected ">" or "-"
15:25:11 <lambdabot> expecting variable, "(", operator or end of input
15:25:25 <ddarius> fasta: I don't remember him saying that, but I could have just forgotten.
15:25:30 <sorear> Cheery: nice try, only GHC knows how to parse arrow notation.
15:25:35 <monochrom> perhaps pure (\a -> a+1) >>> returnA
15:25:49 <Wild_Cat> shapr: well, I just found myself a Python job. Beats the hell out of the Java crap I've had to churn out until now. :)
15:26:04 <kc5tja> Wild_Cat: Congrats!!
15:26:13 <kc5tja> I agree -- Java can suck-start a Harley.
15:26:13 <Cheery> :t pure
15:26:16 <lambdabot>     Ambiguous occurrence `pure'
15:26:17 <lambdabot>     It could refer to either `pure', imported from Control.Arrow
15:26:30 <Saizan> pure == arr
15:26:30 <Cheery> :t Control.Arrow.pure
15:26:33 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
15:26:38 <Cheery> :t Control.Arrow.arr
15:26:40 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
15:26:43 <Cheery> ah ok.
15:26:44 <Wild_Cat> also, depending on what you do, I suspect Python may be more practical. Mostly thinking of Stackless (and games) here.
15:26:55 <DRMacIver> Wild_Cat: Cool. Congratulations. Doing what?
15:26:56 <Wild_Cat> kc5tja: thanks. As we gamers often say, ding!
15:27:10 <Cheery> :t Control.Arrow.returnA
15:27:12 <lambdabot> forall (a :: * -> * -> *) b. (Arrow a) => a b b
15:27:40 <kc5tja> Wild_Cat: Not sure what that means; I don't play games.  I've always sucked at them, and characteristically don't "play well" in teams.
15:27:41 <Wild_Cat> DRMacIver: building UIs for a media center set-top box. I'm starting in a month or so.
15:27:41 <Cheery> > returnA 5
15:27:43 <lambdabot>  5
15:27:47 <kc5tja> It's amazing I'm able to function at all in society.
15:27:57 <Wild_Cat> kc5tja: "ding" is MMORPG slang for "level up" ^^
15:28:00 <Cheery> > returnA << arr (+200) $ 5
15:28:01 <ddarius> Arrow notation turns into a crazy ugly mess.
15:28:02 <lambdabot>   Not in scope: `<<'
15:28:07 <Cheery> > returnA <<< arr (+200) $ 5
15:28:08 <lambdabot>  205
15:28:13 <kc5tja> Wild_Cat: I more or less figured that, but wasn't sure.  :)
15:28:20 <Cheery> ddarius: I'm afraid of that
15:28:39 <Saizan> Cheery: arrowp unsugar it to: arr (\a -> a +1)
15:28:47 <Saizan> *desugar
15:28:55 * kc5tja wouldn't mind hacking in Lua either.  Lua looks like a "neat-o" language.
15:29:15 <Saizan> (returnA = arr id, afaik)
15:29:18 <Cheery> Saizan: ok, thanks.
15:29:35 <DRMacIver> Wild_Cat: Cool.
15:29:42 <DRMacIver> kc5tja: Lua looks pretty pleasant, yeah.
15:29:56 <Wild_Cat> kc5tja: Lua? as an embedded scripting language, I hear it's brilliant.
15:30:18 <Wild_Cat> not sure how good it'd be as a general-purpose language, though. Of course, I figure that's the whole point.
15:30:21 <Cheery> it seems a lot that arrows would be just similar to monads with the exception that they allow every single darn function to hold metadata and compose that metadata in new ways
15:30:25 <ddarius> Wild_Cat: Circa when? (re "ding")
15:30:49 <Wild_Cat> ddarius: I first heard it on Everquest.
15:31:04 <ddarius> Okay.  That makes sense.
15:31:18 <monochrom> Arrow is a formalized dataflow language.
15:31:19 <Wild_Cat> and it's still in use today. Well, it still was when I quit playing WoW 4 months ago.
15:31:22 <Cheery> am I right?
15:31:55 <monochrom> I hate "metadata".
15:32:05 <ddarius> Wild_Cat: Yeah, it sounds like a graphical MMORPG thing.
15:32:56 <Cheery> monochrom: why?
15:33:07 <Wild_Cat> ddarius: I don't think it's MUD slang, if that's what you're asking. ;)
15:33:23 <ddarius> Wild_Cat: It goes back to text based MUDs?
15:33:24 <Cheery> I could also say it wraps additional data around functions.
15:34:03 <shapr> Wild_Cat: Yeah, I went from VB to Java to Python to Haskell jobs.
15:34:04 <Wild_Cat> ddarius: no idea. I only ever played one of those, and it didn't last long.
15:34:16 <Wild_Cat> shapr: Haskell jobs? Color me impressed.
15:34:17 <monochrom> because it has degraded to a buzzword.  Any statement of the form "... metadata..." is necessarily a tautology without carrying any information.  So, I guess I can answer your "am I right" with a confident "yes" without even reading.
15:34:31 <shapr> Wild_Cat: I have two Haskell jobs even :-)
15:34:43 <ddarius> shapr is greedy
15:34:49 * DRMacIver is applying for some Haskell jobs.
15:34:50 <Philippa> Cheery: you're wrong. You're wrong not least because if something's an instance of ArrowApply it can't do anything a monad can't because it /is/ a monad
15:34:53 * shapr grins
15:35:07 * notsmack has a Haskell job.
15:35:22 <shapr> cool!
15:35:29 <shapr> notsmack: What's your job?
15:35:40 <Syzygy-> notsmack: Coool
15:35:47 <Syzygy-> DRMacIver: Go go go.
15:35:47 * sorear has no job at all!
15:35:50 <Wild_Cat> shapr: when I started learning Haskell a couple years ago at Leeds Uni, one of the first things the teacher told us was "it's not used a lot, and if you don't like this class you'll probably never hear from it again, but still, I believe knowing it will make you better programmers."
15:36:08 <shapr> That's changing.
15:36:09 <notsmack> data analysis type stuff
15:36:16 <fasta> Wild_Cat: that teacher read too much Paul G.
15:36:17 <Cheery> monochrom: I don't know, I still understand metadata as data of data, not a buzzword.
15:36:21 <fasta> Wild_Cat: ;)
15:36:31 <Wild_Cat> fasta: Paul G.?
15:36:32 <monochrom> In general I hate explaining anything in "plain English".  All the flavour is lost.
15:36:36 <Japsu> Wild_Cat: Paul Graham
15:36:51 <ddarius> monochrom: Explain everything in Japanese!
15:36:56 <Wild_Cat> <n00b> and who is he?
15:36:57 <Cheery> :D
15:37:04 * sorear faints
15:37:08 <sorear> @google on lisp
15:37:10 <lambdabot> http://www.paulgraham.com/onlisp.html
15:37:11 <lambdabot> Title: On Lisp
15:37:11 <ddarius> www.paulgraham.com
15:37:14 <Japsu> yeah
15:37:30 <fasta> Oh, no, why did I advertise him?
15:37:46 <DRMacIver> I dislike the "knowing it will make you a better programmer" argument.
15:37:51 <Wild_Cat> okay. A guy who's bitter because Lisp never really took off, then ^^
15:37:53 <DRMacIver> Despite the fact that it's clearly true.
15:37:59 <fasta> DRMacIver: that's why I brought it up
15:38:00 * ddarius doesn't like Paul Graham.
15:38:21 <fasta> I don't really agree with it.
15:38:35 <DRMacIver> I think it's a true statement. I just don't think it's a valid justification for learning programming languages.
15:38:36 <kc5tja> Except that knowing Lisp *DOES* make you a better coder.
15:38:43 <sorear> ... in Lisp!
15:38:47 <dmead> hmm
15:38:49 <kc5tja> There's a difference between being a C programmer and a programmer.
15:38:50 <Wild_Cat> DRMacIver: I'm a firm believer that learning new languages and/or paradigms makes you a better programmer. But haven't we already had that discussion on ##java? ;)
15:38:52 <fasta> Knowing different paradigms is good.
15:38:54 <Cheery> when I think of it, I dislike everything anyone has said ever.
15:38:55 <Philippa> I don't think actually knowing it would improve me any from what I know of it now
15:38:57 <ddarius> DRMacIver: Why not? Isn't writing better code a goal?
15:38:58 <dmead> is there some special rules for using arrows on tuples?
15:38:59 <monochrom> Knowing it will make you understand explanations beyond plain English.
15:39:11 <sorear> dmead: no, see "parametricity"
15:39:14 <DRMacIver> Wild_Cat: We have. :) And I agree that it does.
15:39:16 <dmead> k
15:39:36 <Wild_Cat> DRMacIver: I agree with you that "it'll make you a better programmer" isn't a good enough reason to be the only reason to learn a language.
15:39:48 <Cheery> monochrom: I think I'm myself quite bad at explaining things in plain English
15:39:49 <fasta> I also believe it's practically impossible to be a "guru" in 10 languages at the same time.
15:39:52 <DRMacIver> ddarius: I think that going into learning a language with the mindset "I'm not going to use this except to improve my programming in Blub" is a bad idea.
15:40:18 <Cheery> I'd actually prefer that I'd have just some things I can pick up, then add to those.
15:40:24 <Cheery> when doing documentation, for example.
15:40:31 <Wild_Cat> fasta: absolutely. But 2 or 3, now that's more possible. The trick is to know when to drop one and pick a new one up.
15:40:41 <DRMacIver> fasta: Agreed. But one doesn't have to be a guru to be effective.
15:40:49 <Wild_Cat> that too.
15:40:49 <ddarius> fasta: Sure it's possible, e.g. if you are a Java guru you are practically already a C# guru.  Continue in that way.
15:40:52 <fasta> Wild_Cat: C and Lisp were often mentioned.
15:41:04 <DRMacIver> ddarius: That's surprisingly not true. :)
15:41:16 <ddarius> DRMacIver: Nowadays.
15:41:23 <DRMacIver> It's amazing how many irritatingly different edge cases the two have.
15:41:33 <fasta> ddarius: That depends on the toolset you have
15:41:37 <Cheery> I'd love to explain monads and arrows as certain combinators of certain classes, having different set of abilities
15:41:40 <DRMacIver> C# is much closer to the C++ replacement that Java wasn't.
15:41:41 <fasta> ddarius: Or are the APIs that similar?
15:41:43 <ddarius> Well it's easier if you pick cleaner languages.
15:42:10 <DRMacIver> fasta: The APIs are very different.
15:42:13 <Wild_Cat> the languages in which I currently aim for guru-ness are Java (if there is such a thing as a Java guru) and Python, and I'm in the process of picking up Haskell.
15:42:18 <fasta> ddarius: I do know there *are* differences between Smalltalk and Java, for example, although I clearly understand what they mean by "stolen" now.
15:42:25 <ddarius> DRMacIver: Neither are really close to a C++ replacement.  That's why neither has replaced C++.
15:42:37 <monochrom> I was a guru in 10 languages at the same time.
15:42:47 <geezusfreeek> D would be a pretty good C++ replacement
15:42:51 <dmead> yea
15:42:52 <fasta> monochrom: trivial languages, you mean?
15:42:54 <dmead> D looks good
15:43:08 <dmead> but apparently it lacks a stdlib?
15:43:15 <dmead> but you can link to c++
15:43:20 <fasta> Ask #c++ what they think of D :P
15:43:38 <dmead> :P
15:43:42 <Wild_Cat> C++ is stuck between two chairs. The C/Java (or C/HLL of choice) combination looks... Better, to me.
15:43:43 <DRMacIver> ddarius: I guess what I mean is that there are a lot of things that Java decided not to take from C++ and C# has effectively 'added back in'.
15:43:43 <geezusfreeek> dmead: it's got one (phobos) but walter isn't really making it good enough
15:43:52 <ddarius> fasta: Hmm, that sounds entertaining.
15:43:54 <geezusfreeek> tango is a replacement standard lib that can be used
15:44:00 <dmead> > (p,q <- (1,2)
15:44:00 <lambdabot>  Parse error
15:44:01 <fasta> Shall we go there now? :)
15:44:04 <dmead> > (p,q) <- (1,2)
15:44:05 <lambdabot>  Parse error
15:44:08 <dmead> hmm
15:44:15 <dmead> yea
15:44:20 <dmead> lets rock c++
15:44:20 <ddarius> DRMacIver: Such as?
15:44:22 <dmead> :P
15:44:51 <DRMacIver> ddarius: Pass by reference, goto, pointers, the virtual method distinction, conditional compilation.
15:44:52 <Philippa> Wild_Cat: C++ does manage to be, amongst other things, a better C. Give or take a couple of the newer features that can get in the way of that somewhat
15:45:05 <monochrom> three assembly languages, basic, pascal, c, c++, matlab, mathematica.  maybe not exactly 10.
15:45:19 <shapr> I've never been a guru!
15:45:26 <dmead> > e < - (1,2)
15:45:27 <lambdabot>   Not in scope: `e'
15:45:29 <fasta> Eelis: now you are spoiling all the fun
15:45:45 <dmead> > e <- (1,2)
15:45:46 <lambdabot>  Parse error
15:46:13 <DRMacIver> ddarius: It also seems to encouragee bit twiddling, bitfields, etc. a lot more than Java does.
15:46:15 <Wild_Cat> Philippa: yeah, I guess it's a matter of personal preference. C++ looks somewhat ugly to me, but that's probably because I'd learned OOP in other languages before being exposed to it.
15:46:21 <Eelis> fasta: quite.
15:46:39 <fasta> dmead: I expected such a response, anyway.
15:46:47 <Cheery> I guess many people except people actually writing c++ keeps it as ugly language
15:47:03 <Cheery> I personally hate c++
15:47:05 <dmead> i wrote c++ for a job last year
15:47:05 <DRMacIver> Note that this is not intended to be a point against either C# or Java. These features have their place, as they have reasons why one might want to not include them. But it is a significant difference between the two.
15:47:08 <Wild_Cat> thus, stuff like templates, friends, the explicit "virtual" keyword and lack of any kind of runtime introspection make my blood boil.
15:47:11 <dmead> but it was for a low latency system
15:47:21 <dmead> c++ is still best when you need speed
15:47:24 <dmead> unfortunately
15:47:28 <ddarius> Java is pass by reference.  goto isn't really a C++ thing, more an inherited C thing.  Pointers are only in "unsafe" code.  The virtual method distinction is a mistake in my opinion (in a language like C#).  Conditional compilation is fine though.
15:47:44 <DRMacIver> Java is *not* pass by reference.
15:47:52 <DRMacIver> Java passes everything by value.
15:47:56 <Cheery> I thought you should use C or assembler language when you want speed.
15:48:05 <fasta> DRMacIver: that would be new
15:48:09 <Cheery> and better algorithms. of course
15:48:10 <DRMacIver> fasta: No.
15:48:11 <dmead> by speed i mean not java lagginess
15:48:12 <Wild_Cat> DRMacIver: yeah, but in Java every Object is a reference.
15:48:15 <bos> i wonder why there isn't a combinator version of "if".
15:48:18 <dmead> not nanosecond timing
15:48:24 <DRMacIver> Wild_Cat: Right. :)
15:48:29 <bos> whatIf :: a -> a -> Bool -> a
15:48:30 <fasta> DRMacIver: primitive types are passed by value
15:48:35 <DRMacIver> But you can't pass in parameters by reference in C#.
15:48:44 <Wild_Cat> so if you ignore primitive types, you can consider Java to be pass-by-reference.
15:48:54 <DRMacIver> Wild_Cat: No you can't.
15:48:56 <Wild_Cat> (and boy, do primitive types deserve to be ignored)
15:48:59 <Cheery> bos: why in that order?
15:49:14 <bos> Cheery: for partial application.
15:49:21 <Cheery> explain. :)
15:49:23 <ddarius> Cheery: foldBool
15:49:26 <DRMacIver> A variable containing a reference passes in that reference by value.
15:49:27 <Cheery> why that older is better?
15:49:30 <Eelis> Cheery: as for C, C++'s templates can sometimes offer better inlining opportunities (std::sort vs qsort is the canonical example). as for assembly, the consensus seems to be that these days compilers are better at writing fast assembler code than humans.
15:49:33 <chessguy> @type foldBool
15:49:36 <Wild_Cat> DRMacIver: true.
15:49:36 <lambdabot> Not in scope: `foldBool'
15:49:37 <bos> as in (whatIf "foo" "bar"), applied to a Bool
15:49:41 <Cheery> *order
15:49:41 <DRMacIver> The 'value' being passed is a reference, but there is no reference to the variable being passed in.
15:49:52 <ddarius> chessguy: It doesn't exist.  But if is the fold for the Bool type.
15:49:54 <DRMacIver> In particular there is no ability to pass in reference or out parameters as in C#, which is the point I was making.
15:50:09 <fasta> DRMacIver: that's how I meant "reference".
15:50:15 <Wild_Cat> out parameters are evil anyway.
15:50:23 <DRMacIver> No comment.
15:50:26 <kc5tja> "the consensus seems to be that these days compilers are better at writing fast assembler code than humans."   ---   this is such a myth.
15:50:27 <DRMacIver> The fact is that the feature is there. :)
15:50:35 <kc5tja> Compilers are good, sure, but they're not _better_.
15:50:53 <ddarius> Trivially true: tweak the output of a compiler.
15:51:05 <Eelis> kc5tja: obviously it depends on the language you're compiling from, and also on who's doing the assembly programming.
15:51:10 <kc5tja> Precisely.
15:51:13 <fasta> kc5tja: if you want to prove that you should create some code by hand and post it somewhere.
15:51:33 <sorear> Sure, I'll do this.
15:51:36 <Eelis> and taking C++ as the language you're compiling from, and average humans as doing the assembly programming, compilers generally win.
15:51:39 <DRMacIver> It's not like I'm claiming that C# and Java are fundamentally different languages. I'm just observing that a) The edge cases are different and b) A lot of these result from C# adding back in a bunch of features which Java removed.
15:51:48 <sorear> (but I'm not a fool, and I *will* use gprof/cachegrind)
15:51:57 <Wild_Cat> DRMacIver: agreed.
15:52:05 <amaron> if you want to switch from imperative to functional programming, what would you use: scheme or haskell?
15:52:15 <thoughtpolice> use for what?
15:52:21 <Wild_Cat> Eelis: especially when you allocate the same time (man-hours) to both programmer teams.
15:52:21 <amaron> I guess you will all say haskell here
15:52:24 <sorear> remember to ask in #scheme afterward
15:52:27 <fasta> amaron: if you want to force yourself, Haskell, otherwise Scheme.
15:52:28 <kc5tja> fasta: As long as it's relatively reasonable for a human to compile by hand, I'll do it.  I've done it before.  Note: I have to admit, I've been coding in assembler since the age of 6.
15:52:28 <Cheery> bos: hmm... you think that branches in if-clause are more important than boolean
15:52:29 <amaron> lets say a paradgm shift
15:52:29 <Eelis> Wild_Cat: then it's a no-brainer, yes :)
15:52:31 <DRMacIver> amaron: Both. :)
15:52:44 <Cheery> I wonder whether I should agree or disagree, it feels comforting in some weird way.
15:52:48 <Wild_Cat> amaron: Haskell. It's fun. :p
15:52:52 <DRMacIver> amaron: The traditional first Haskell exercise is to implement Scheme. ;)
15:52:54 <monochrom> haskell
15:53:05 <bos> Cheery: no, i'm saying that order is easier to use a partially applied form of the function in.
15:53:10 <Wild_Cat> (of course, Schemers will tell you to learn Scheme)
15:53:20 <monochrom> disruptive cultural shock is fun.  at least fun for me.  haskell.
15:53:20 <Philippa> kc5tja: you're far from an average human then, and the compiler will still be a lot faster at getting it done than you
15:53:22 <kc5tja> fasta: But, ultimately, extraordinary claims need extraordinary evidence -- compilers are good, but to date, you still need assembly language coders to write them!!
15:53:24 <fasta> amaron: I think Hsakell makes more sense after you learn Scheme.
15:53:33 <amaron> yes, I dont know how to compare them
15:53:33 <DRMacIver> And then you should implement Haskell in the Scheme you implemented.
15:53:37 <DRMacIver> At which point your head will explode.
15:53:44 <Philippa> but you don't need to write them in assembly
15:53:48 <DRMacIver> (Or you will attain nirvana)
15:53:49 <kc5tja> Philippa: But the claim is "better code than humans," not "better code than the average bloke on the street."
15:54:04 <MyCatVerbs> fasta: oh? But then Scheme doesn't really have anything like monads, so. :/
15:54:07 <monochrom> explode = attain nirvana
15:54:12 <Wild_Cat> DRMacIver: nah, you have it wrong. First you have to implement Scheme in Perl 6, using Pugs :p
15:54:14 <amaron> DRMacIver: its allready exploded by trying to switch to functional thinking
15:54:17 <Philippa> kc5tja: it's not "all compilers produce better code than all humans" though
15:54:19 <sorear> (comparing to spanish) Scheme is like going to a big city in the far north of Mexico; Haskell is rural Spain.
15:54:25 <chessguy> @instances-importing Ord
15:54:26 <lambdabot> (), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
15:54:28 <Cheery> bos: well, you mean that: (cif booleanvalue) is less interesting than (whatIf truebranch falsebranch)
15:54:37 <fasta> MyCatVerbs: Some people implemented monads in Scheme
15:54:38 <sorear> (you may now flame me for my cultural insensitivity)
15:54:39 <emu> Scheme is like Tijuana?
15:54:47 <ddarius> I'd recommend Scheme over Haskell to -learn- programming, but not just to learn -functional- programming.
15:54:49 <bos> Cheery: no, i make no claim about interestingness.
15:54:50 <MyCatVerbs> fasta: ouch!
15:54:50 <Philippa> most compilers now beat most human programmers. For code of any size produced at all quickly, they also beat most human programmers who can get around in assembly
15:54:54 <kc5tja> Philippa: Well, that depends on who you ask.  As stated, Eelis's comment is a myth, that is very common in compsci.
15:54:55 <fasta> MyCatVerbs: the class system has also been implemented in Scheme
15:54:59 <shapr> sorear: That would be culturally insensitive.
15:55:01 <thoughtpolice> i found haskell significantly easier to step to after messing with languages such as lisp/scheme. if you just want a paradigm shift then i would have to tilt towards scheme, but if you wanted a more 'non-teaching oriented' functional language then haskell all the way.
15:55:05 <kc5tja> It's quoted, almost verbatim, just as Eelis has done.
15:55:10 <kc5tja> And it makes me sick to hear it.
15:55:11 <fasta> MyCatVerbs: so, the interface would be about the same.
15:55:13 <Cheery> bos: well, useful, crap, I agree with you on that one.
15:55:25 <Philippa> kc5tja: it *does not mean* all compilers and all assembly coders
15:55:26 <DRMacIver> Wild_Cat: That really *would* make my head asplode.
15:55:32 <kc5tja> Not that I'm blaming Eelis for spreading myths, but I do have to put in the polite objection everytime I see it.  :)
15:55:33 <LoganCapaldo> what is this whatIF nonsense? let true = const; let false = flip const
15:55:33 <amaron> thoughtpolice: so you think haskell is more practical one?
15:55:45 <DRMacIver> Wild_Cat: Especially if you can figure out a way to do autothreading in it.
15:55:47 <kc5tja> Philippa: But it's taken to mean exactly that by those who read it.
15:55:51 <DRMacIver> s/do/use/
15:55:53 <bos> Cheery: i don't know how much haskell you write, but partially applied functions are quite commonly used.
15:56:11 <MyCatVerbs> fasta: yeah, but the fundamental... I mean, Hell, Scheme's eager and has side effects. Monads aren't really neccessary for it so it'd surely feel like painful mental gymnastics with no obvious payoff?
15:56:19 <Philippa> kc5tja: you've just committed the exact error you're complaining about. No, it's not, I didn't
15:56:28 <Philippa> pick an approach and stick to it :-)
15:56:40 <Eelis> kc5tja: i think you're severely over-reacting. the point is to talk sense into people who think that hand-crafting assembly is the only way to get optimal performance.
15:56:43 <Wild_Cat> DRMacIver: well, to do that you'd need to run Pugs on a Haskell interpreter running on a few Erlang nodes.
15:56:50 <Philippa> also, most of the people reading it that way shouldn't try hand-crafting their own assembly because the compiler /will/ beat them
15:57:12 <thoughtpolice> amaron: you could say that. scheme is great for a teaching language, but trying to do something like take training wheels (very slick and comfortable training wheels, however) and trying to ride a mountain bike trail will be, to say the least, maybe a little more difficult than just using a mountain bike.
15:57:13 <LoganCapaldo> type Bool a = a -> a -> a
15:57:17 <DRMacIver> MyCatVerbs: Monads are useful independently of purity.
15:57:17 <kc5tja> Philippa: To quote, "You're not the average human then."
15:57:25 <Wild_Cat> (just in case there were some unexploded bits of your head remaining...)
15:57:40 <DRMacIver> Wild_Cat: No, autothreading is an actual perl 6 feature. :)
15:57:42 <Philippa> yes, which is still true
15:57:47 <ddarius> Monads aren't Haskell specific in any way, shape, or form
15:57:50 <MyCatVerbs> DRMacIver: yes, but not essential. And they really, -really- hard. x_x
15:57:51 <Cheery> LoganCapaldo: :)
15:57:52 <kc5tja> Eelis: I'm not over-reacting, I'm merely reacting.  It's amazing what changing two words will do to improve clarity of a sentence.  :)
15:58:14 <Wild_Cat> DRMacIver: is it? Does it do what it says on the box? If not, what does it do?
15:58:14 <DRMacIver> MyCatVerbs: Nah.
15:58:21 <Philippa> guess what? For 99+% of projects, the statement may as well hold
15:58:26 <ddarius> Also, there is no reason to code in monadic style in Scheme.
15:58:39 <Philippa> it's a soundbite and a rule of thumb
15:58:49 <ddarius> (Because you can implement shift/reset in it)
15:58:55 <Cheery> LoganCapaldo: try print such booltype.
15:58:56 <Philippa> and as such, you /are/ over-reacting to it
15:59:02 <DRMacIver> Wild_Cat: It basically does what it says on the box. There are various (mostly junction related) things which basically say "We explicitly do not specify an evaluation order for this construct. The implementation should consider running these operations in parallel."
15:59:02 <emu> monad-oriented programming, monop
15:59:02 <Cheery> hmm. darn.
15:59:12 <kc5tja> Philippa: Yes, and that's how all myths get started.
15:59:36 <Philippa> they get started when someone starts with the precise statement, too
15:59:38 <kc5tja> Philippa: If correcting an obvious falsity is over-reacting, then I'm damn proud to be doing so.
15:59:40 <Wild_Cat> DRMacIver: hadrly sounds automated.
15:59:46 <Wild_Cat> s/hadrly/hardly/
16:00:00 <DRMacIver> Wild_Cat: No, I mean implementations of perl 6.
16:00:08 <LoganCapaldo> Cheery: show boolean = boolean "true" "false" :)
16:00:10 <bos> kc5tja: we call that "pedantry"
16:00:16 <Wild_Cat> DRMacIver: oh.
16:00:28 <DRMacIver> Wild_Cat: I think it's basically that there are various circumstances under which the foreach loop should actually be a concurrent foreach loop.
16:00:35 <kc5tja> bos: Yes, I'll freely admit to being pedantic here.  :)
16:00:44 <bos> just so long as we're clear :-)
16:00:46 <ddarius> MyCatVerbs: Without shift/reset, monadic style can still be useful, even with shift/reset monads are useful.
16:00:47 <Wild_Cat> well, once Haskell compilers get around to auto-parallelizing stuff, Pugs will get that (and more) for free.
16:00:50 <Cheery> LoganCapaldo: ok, nice.
16:00:51 <Philippa> that, and "social stupidity". People often communicate correct information through obvious falsities
16:00:58 <monochrom> Interesting. training wheel and mountain bike. I tend to associate training wheel with haskell, mountain bike with scheme. here is how. mountain bike needs the whole mountain to be there before you start. training wheel provides parts of the mountain on demand as you go. ok, nevermind me.
16:01:04 <Wild_Cat> I wonder where Parrot fits in all that, though.
16:01:11 <Pseudonym> Philippa: I don't know WHAT you could POSSIBLY be talking about!
16:01:48 <DRMacIver> monochrom: I swear your analogies get worse as I grow older. :)
16:01:50 <Philippa> Pseudonym: it's a duality thing, both true and false :-)
16:02:00 <Wild_Cat> (if Parrot isn't dead, of course -- har har)
16:02:03 <Pseudonym> :-)
16:02:10 <kc5tja> Philippa: Well, I never resorted to ad hominem attacks, even subliminal, so I think that was just plain uncalled for.  But, people have a right to their opinion.
16:02:11 * Pseudonym is being self-referential, and hence funny, dammit
16:02:12 <fasta> ddarius: what's the significance of shift/reset? At some point I understood the semantics, but never thought:" oh, well this is a nice application of shift/reset".
16:02:13 <monochrom> All analogies get worse.
16:02:16 <thoughtpolice> Wild_Cat: parrot is essentially totally independent of perl 6, but parrot is designed in mind to implement perl 6's semantics and support them all, but wall et al. have little say on how that's done.
16:02:19 <dmead> :t &
16:02:24 <lambdabot> parse error on input `&'
16:02:25 <DRMacIver> Wild_Cat: It's not de... *strangles self for gratuitous pythonry*
16:02:33 <LoganCapaldo> :t (&)
16:02:34 * Wild_Cat bows
16:02:36 <lambdabot> Not in scope: `&'
16:02:42 <Cheery> LoganCapaldo: what about not-so-correct -behavior?
16:02:43 <Philippa> kc5tja: I described behaviour. You're struggling against a widespread social idiom, and it does indeed look stupid when you do it
16:03:00 <Cheery> you could do: (+) :: Bool, then cause some really weird stuff.
16:03:12 <Cheery> well, almost
16:03:16 <ddarius> fasta: With shift/reset you can weave monadic effects into normal code.
16:03:16 <thoughtpolice> but it's not the other way around: perl 6 is totally dependent on parrot; it's the only virtual machine for perl 6.
16:03:17 <dmead> or maybe + = -
16:03:23 <dmead> and - = +
16:03:23 <Cheery> (+) :: (Num a) => Bool a
16:03:28 <dmead> then wait for the universe to explode =/
16:03:29 <LoganCapaldo> good thing I was joking then :)
16:03:30 <kc5tja> Philippa: Not to me.
16:03:36 <Philippa> the very people you're worried about taking it literally don't actually treat the truth or otherwise of such statements the way you do
16:04:08 <Philippa> kc5tja: yeah. Believe me, I know how that one goes. You're still pissing in the wind while visibly committing a type error
16:04:08 <monochrom> Why are people so hard?  *duck*
16:04:09 <ddarius> Incidentally, Scheme is probably a much more practical language than Haskell currently.  I don't see where this "training wheels" thing is coming from.
16:04:36 <kc5tja> Philippa: ummm....oh kay...
16:04:43 <DRMacIver> ddarius: I think it's in the context of the objective being 'learning functional programming'.
16:04:47 <bos> ddarius: why do you think it's more practical?
16:04:51 <Wild_Cat> ddarius: most of the criticism of Scheme I read is about its excessive verbosity, actually.
16:05:00 <fasta> ddarius: Can you elaborate somewhat more on that? Or do you have a good reference that explains that relation?
16:05:03 <Pseudonym> There's a lot of crap in the logs.  Do I take it that the context is that compilers write better assembly than humans?
16:05:10 <DRMacIver> ddarius: i.e. Scheme isn't pure, so you've got training state to keep you stable.
16:05:16 <Cheery> monochrom: c++ mentioned, digitally hazardous waste introduced into #haskell
16:05:17 <Philippa> Pseudonym: right
16:05:22 <ddarius> bos: It's a much more mature language with much more mature implementations and a larger community.
16:05:31 <Pseudonym> Well, it's not true.  Because humans can use a compiler, but compilers can't use a human.
16:05:32 <Philippa> and kc5tja complaining because it's only true in 99.9% of cases
16:05:44 * Philippa hands Pseudonym an interactive compiler
16:05:50 <ddarius> I can agree with the statement that Scheme is "training wheels" for learning (pure) FP.
16:05:54 <bos> ddarius: hmm. i must say, it's a pretty unpleasant language to actually write lots of code in.
16:06:17 <Pseudonym> Philippa: Ugh.
16:06:21 <Pseudonym> That's the last thing I want.
16:06:38 <Pseudonym> I recompile many times a day.  I don't want to babysit it every time.
16:06:39 <Philippa> or more commonly, a language with inline asm - though that usually comes with a big pile of problems
16:06:40 <monochrom> Compiler Wizard!  Whee!
16:06:45 <ddarius> Pseudonym: That was the first thing I said.
16:06:58 <Pseudonym> Yeah.
16:07:04 <ddarius> [17:48] <ddarius> Trivially true: tweak the output of a compiler.
16:07:10 <Pseudonym> Yeah.
16:07:11 <monochrom> "You are about to compile myprog.c.  [Next->]  [Cancel]"
16:07:48 <Philippa> except that switching to that strategy is the exact consequence of the original statement, and the whole point of making it
16:07:52 <ddarius> 5d10 Common Subexpression Eliminator
16:07:53 <monochrom> "You have declared int main(...).  Do you want to inline it?   [<- Back] [Yes] [No] "
16:08:08 <bos> @hoogle Monad m => (a -> b -> c) -> m a -> b -> m c
16:08:09 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
16:08:14 <Cheery> @dice 5d10
16:08:15 <lambdabot> 5d10 => 25
16:08:18 <Pseudonym> "Hi!  You look like you eant to compiler a program.  Do you want to:  * Use a broken optimiser  * Require vendor-specific extensions in order to get any useful work done  * Break line termination on other platforms"
16:08:21 <Philippa> monochrom: usually you let the coder hand-crank the event loop and provide a whole pile of info at once, no?
16:08:24 <Cheery> argh!
16:08:29 <Wild_Cat> noooooo!
16:08:49 <fasta> ddarius: ?
16:08:55 <ddarius> Philippa: You really do need to use Smalltalk.
16:09:05 <ddarius> fasta: ?
16:09:06 <int-e> monochrom: ouch.
16:09:12 <Pseudonym> If Clippy were built into compilers, many more monitors would be lying broken in landfills.  It's good for the environment.
16:09:28 <thoughtpolice> "Variable j has been declared and not used. Is this on purpose? [Yes] [No] [What?]"
16:09:40 <DRMacIver> A way to let the programmer tweak the output of the compiler in tandem with a profiler, etc. would actually be rather neat.
16:09:49 <Philippa> ddarius: yeah, I do sometime. But in the meantime, an awful lot of what I'm describing's just a handwaving description of stuff an awful lot of people've been doing with their IDEs already
16:10:13 <Wild_Cat> lambdabot can roll dice? Whoa. I'm blown away.
16:10:17 <Philippa> DRMacIver: to an extent, people've used VC++ that way
16:10:19 <ddarius> Philippa: And Smalltalk is the quintessential IDE language.
16:10:45 <Philippa> ddarius: yep. But that's so far not proven compelling enough for me to actually sit down and use it
16:10:45 <DRMacIver> This appears to be "Languages DRMacIver has been meaning to try for a while but never gets around to" evening. :)
16:10:59 <ddarius> Philippa: I don't like it.
16:11:01 <norgul> hi folks
16:11:02 <fasta> ddarius: Can you elaborate somewhat more on that? Or do you have a good reference that explains that relation?
16:11:03 <DRMacIver> (Well, I've done a little scheming)
16:11:12 <ddarius> @google "Representing Monads"
16:11:15 <thoughtpolice> i've only dabbled with Smalltalk in terms of Seaside.
16:11:15 <Philippa> fasta: it's image-based and highly reflective
16:11:16 <lambdabot> http://portal.acm.org/citation.cfm?id=178047&coll=portal&dl=ACM
16:11:16 <lambdabot> Title: Representing monads
16:11:21 <fasta> ddarius: What is meant by "monadic effect"?
16:11:21 <ddarius> @google "Representing Layered Monads"
16:11:27 <lambdabot> http://portal.acm.org/citation.cfm?id=292557&dl=
16:11:27 <lambdabot> Title: Representing layered monads
16:11:40 <ddarius> Those papers are available despite the acm link.
16:11:41 <Philippa> ddarius: yeah, I'm not surprised. I wouldn't like it enough to use it for most of my work, because it'd be missing too much other stuff
16:11:47 <DRMacIver> Philippa: In what sense do people use VC++ that way? I've never used it.
16:11:58 <DRMacIver> Well, I've never written a line of C++ of any flavour.
16:12:08 <fasta> Philippa: I "know" Smalltalk. I read a 300 page book on it and played with it. I wasn't referring to Smalltalk.
16:12:12 <Philippa> DRMacIver: later versions let you recompile bits of code while you're running
16:12:19 <DRMacIver> Ah
16:12:21 <kc5tja> thoughtpolice: Isn't that what lint and pychecker and other such tools DO though?  :)
16:12:25 <ddarius> fasta: Monads are used to encapsulate and simulate effects.
16:12:28 <fasta> Philippa: it also has continuations and other cool stuff. :)
16:12:38 <ddarius> (e.g. state, continuations, exceptions, non-determinism)
16:13:00 <Pseudonym> Smalltalk should definitely have a proud place in the museum of computing history.
16:13:04 <Pseudonym> But it should stay there.
16:13:04 <fasta> ddarius: well, I used monads in Haskell and understand the monadic trick.
16:13:17 <Philippa> ddarius: I'd be more interested in something that looked like a Smalltalk system built on the child of Haskell
16:13:21 <kc5tja> Pseudonym: Along with Ruby and nearly all the other "modern" OO languages, right?
16:13:30 <Pseudonym> No, just Smalltalk.
16:13:37 <fasta> ddarius: I.e. compile it into one big expression and have that be interpreted by a machine that actually _does_ the effects.
16:13:43 <Pseudonym> Along with Simula and Modula-1.
16:13:46 <Philippa> the modern ones often don't deserve the museum
16:13:53 <kc5tja> Hmm....I don't see why Smalltalk needs to remain in a museum.
16:13:57 <ddarius> Philippa: The being able to change anything and everything is cool, but otherwise the way certain things is done strikes me as insane and your code ends up dispersed across a huge codebase and you will hate dynamic dispatch with a passion.
16:14:00 <fasta> ddarius: greatly glossing over details, of course
16:14:08 <kc5tja> Philippa: No, they deserve the trash bin instead.  :(
16:14:28 <thoughtpolice> smalltalk is pretty interesting, at least I thought so.
16:14:30 <Philippa> ddarius: IOW, it's still an OO language :-)
16:14:32 <Pseudonym> kc5tja: I object to using any language which doesn't have real mathematical expressions.
16:14:38 <DRMacIver> What's wrong with dynamic dispatch?
16:14:46 <ddarius> fasta: Now I have no idea what you are talking about/getting at.
16:14:52 <Pseudonym> Admittedly, this is just a syntax quibble.
16:14:58 <ddarius> Philippa: With libraries with
16:15:02 <fasta> ddarius: I mean the way IO in done in Haskell.
16:15:04 <Pseudonym> However, syntax matters.  It's how I interact with my languages.
16:15:06 <ddarius> -very- deep inheritance heirarchies.
16:15:28 <Pseudonym> There's nothing wrong with modern OO languages.
16:15:37 <Pseudonym> By which I mean, of course, Sather, Eiffel, Modula-3.
16:15:43 <ddarius> fasta: That's not the monadic trick.
16:16:18 <kc5tja> So... but... Neither of those are functional languages, and consequently, lack "real" mathematical expressions.
16:16:21 <kc5tja> I'm confused?
16:16:22 <Philippa> if it doesn't have algebraic datatypes or something pretty close, there's something wrong with it
16:16:36 <kc5tja> Philippa: Holy cow -- something we agree on!  :)
16:17:03 <MyCatVerbs> Philippa: my sandwiches lack algebraic datatypes. Are they wrong?
16:17:09 <Philippa> for the level it works on, I'll allow C to get away with "something pretty close" - you can encode the idioms about as badly as most others :-)
16:17:12 <kc5tja> However, I like OO too.  But to relegate Smalltalk to the trash heap is like relegating Lisp to the trash heap while everyone and their grandmother starts using XML for everything.  It just doesn't make sense.
16:17:23 <fasta> ddarius: In Scheme the "trick" works by wrapping monadic actions in e.g. a lambda and the run function then eventually executes the monadic actions. Haskell does a similar thing, right?
16:17:30 <Philippa> MyCatVerbs: your context-sensitivity apparently doesn't have them
16:17:38 <monochrom> Haskell is the answer to all your problems.  But being so powerful it's supposed to be difficult. If you don't understand it, that's your problem.
16:17:39 <DRMacIver> Algebraic datatypes are mostly not that big a deal if you have multiple dispatch and destructuring bind.
16:17:42 <ddarius> Philippa: Not being able to put your code logically together and instead having to hang bits and pieces of it about is annoying.
16:17:47 <DRMacIver> Although they're rather nice.
16:17:56 <Pseudonym> kc5tja: I'm not relegating Smalltalk to the trash heap.  To the museum.
16:18:00 <MyCatVerbs> Philippa: my context sensitivity is hungry.
16:18:04 <Pseudonym> People should be able to gaze on it and appreciate its beauty.
16:18:05 <sorear> wow, #haskell sure is noisy today...
16:18:07 <Pseudonym> Same with Lisp.
16:18:24 <kc5tja> Pseudonym: Hahah :)  Same thing.  Given a choice, I'll more than gladly code in Smalltalk LOOOOOOOOOOOOOOOOOONG before I'll code in Java.
16:18:25 <Pseudonym> If you want something like Lisp, use Scheme instead.
16:18:26 <fasta> ddarius: In Haskell the type system enforces that you don't do things that you shouldn't be able to do (which is possible in Scheme).
16:18:26 <ddarius> fasta: You can do monads in Scheme -exactly- as they are done in Haskell.  I.e. just by adding two perfectly normal functions.
16:18:39 <kc5tja> Pseudonym: Scheme is only 10 years younger than Lisp.  Same thing.
16:18:51 <Pseudonym> kc5tja: No.  Scheme is very much cleaned up.
16:18:52 <Philippa> DRMacIver: you don't think that multiple dispatch and destructuring bind smells a lot like algebraic datatypes, bearing in mind that a key component of them is the case statement?
16:18:59 <Pseudonym> Lisp is a bloated mess.
16:19:01 <sorear> @topic #haskell-overflow
16:19:02 <lambdabot> Maybe you meant: topic-cons topic-init topic-null topic-snoc topic-tail topic-tell join todo type
16:19:07 <sorear> @topic-tell #haskell-overflow
16:19:08 <lambdabot> Overflow conversations and technical discussion from #haskell
16:19:45 <DRMacIver> Philippa: They're different (but similar) approaches to the same problem set. I wouldn't say they're really the same thing at any non-trivial level.
16:19:56 <ddarius> Lisp doesn't exist anymore.  You have CL and Scheme (and a few others that we'll pretend don't exist, they're used to it)
16:20:17 <Philippa> DRMacIver: sure. I didn't require the same thing though
16:20:27 <kc5tja> Pseudonym: Your accusations against Lisp still matter against Scheme though, as I'm interpreting them.  You consider Lisp (of which Scheme IS a dialect) archaic, and therefore, impractical for today's world.  I claim the opposite; in fact, if XML is any clue, it's a re-invention (quite poorly) of S-expressions.
16:20:33 <DRMacIver> Oh, I see what you mean. :) Ok.
16:20:43 <Pseudonym> Scheme is a dialect of Lisp, this is true.
16:20:46 <ddarius> Oh great, now I get to get attacked in multiple channels simultaneously.  (Down with concurrency!)
16:20:58 <Philippa> kc5tja: bear in mind that when someone writes "Lisp" they may mean Common Lisp though
16:21:08 <Pseudonym> Tes,.
16:21:14 <DRMacIver> Philippa: Oh, my bad. I somehow misread what you were saying as in response to scheme rather than smalltalk.
16:21:14 <Pseudonym> I should have said Common Lisp.
16:21:17 <amaron> if one is just started with funcitonal programming, is haskell a "good place" to start?
16:21:17 <Pseudonym> i.e. CLtL2.
16:21:24 <kc5tja> Philippa: NEVER!  That's only true 99.9% of the time!  ;D  (sorry, I just couldn't resist)
16:21:29 <Pseudonym> amaron: Yes!
16:21:29 <amaron> or scheme is better for beginers?
16:21:36 <Pseudonym> Either language is good.
16:22:02 <Pseudonym> But if you're just starting out, Haskell implementations will catch more errors than Scheme implementations.
16:22:11 <amaron> Pseudonym: what about tutorials, which one is better supported?
16:22:15 <kc5tja> After having read SICP, I have to say that one should learn both languages.  In what order?  I don't know.
16:22:23 <Pseudonym> I agree, both languages == good.
16:22:45 <Pseudonym> amaron: That's a matter of opinion.  Scheme has SICP, which is the best tutorial there is.
16:22:50 <Pseudonym> Haskell has nothing like that.
16:22:52 <amaron> kc5tja: I've started with SICP, I just have a headache for now...
16:23:00 <ddarius> amaron: What is your goal with learning FP?  How quickly do you want to grok it?  How quickly do you want to dive? How disciplined are you?
16:23:04 <Philippa> kc5tja: you should've seen the confused response I got when someone asked about representing lisp data in haskell and I produced a datatype for LISP as per the original paper :-)
16:23:20 <Philippa> (it was the kind of conversation where that wasn't an inappropriate thing to do, too)
16:23:52 <amaron> ddarius: I'm proffesional programmer for 7 years, and looking for ways to evolve
16:24:10 <Philippa> have kids, have grandkids, die
16:24:12 <Philippa> or is that not what you meant? :-)
16:24:20 <sorear> can we please focus on amaron and haskell :)
16:24:22 <Pseudonym> amaron: If you're working on SICP, stick with it.
16:24:32 <Pseudonym> But if you want a break from it, by all means learn some Haskell.
16:24:38 <Pseudonym> That's what I'd suggest.
16:24:44 <kc5tja> amaron: Unfortunately, SICP is probably one of the few books that actually captures "how to program," although it does tend to fall short in examples.  Stick with it -- it'll _eventually_ make sense.
16:25:00 * Shimei loves SICP, which is why he hasn't managed to get through Hudak's book yet :P
16:25:21 <Pseudonym> amaron: Haskell has a lot of small tutorials.
16:25:23 <kc5tja> Shimei: I'm probably going to purchase Hudak's book next.
16:25:37 <Pseudonym> Which makes it straightforward to go through in bite-sized chunks.
16:25:48 <Pseudonym> Each chunk is a big step up, though.
16:26:02 <ddarius> amaron: If you are specifically wanting to learn FP and aren't afraid of a potentially steep learning curve, I'd recommend Haskell.  But do learn Scheme later.
16:26:14 <Shimei> kc5tja: What kind of examples do you mean? I've found SICP has some very in-depth examples like the digital circuit simulator and such. You mean like more small examples (I can see a need for some of those maybe, to lessen the curve).
16:26:17 <Pseudonym> Also, #haskell is very friendly when we're not trashing Java.
16:26:28 <Philippa> learning haskell before scheme does take a lot of the magic out of scheme though
16:26:44 <Philippa> haskellers can come to it, be jaded and be justified in it
16:26:49 <ddarius> Philippa: You still have call/cc if you don't look to hard at Cont
16:27:39 <Shimei> Philippa: I think haskell just gives you the tools, where you have to build them in scheme (or at least in SICP). So haskell might not be so good for learning at first?
16:27:41 <Philippa> ddarius: sure. That alone won't encourage comments like "my god, it's full of 'car's!" though
16:27:46 <fasta> I wish I had break in Haskell (and not as I do now manually with callCC and defining break= k ()
16:28:21 <cedricshock> Hi. Why does "instance [a] => Vector [a] a where" raise "aa classes.hs:118:9: malformed class assertion"?
16:28:31 <kc5tja> Shimei: Precisely; the examples given in the book are large and deep, instead of lots of small, shallow examples.  Frankly, _both_ are needed, but the exclusion of one type of example can lead to a steeper learning curve.
16:28:39 <Pseudonym> cedrickshock: It's the left hand side of the =>
16:28:50 <Pseudonym> You declare a class isntance as:
16:29:01 <Pseudonym> instance (some class instances) => a class instance where
16:29:12 <Pseudonym> [a] isn't a valid class thingy.
16:29:23 <Shimei> kc5tja: I agree that that's a problem. I think the exercises are actually pretty good small examples, they're just not put in the right places (i.e. they're after the big projects).
16:29:26 <Pseudonym> So this is illegal:
16:29:31 <Pseudonym> instance [a] => Vector [a] a where
16:29:35 <Pseudonym> But this is legal (in GHC):
16:29:42 <Pseudonym> instance (Eq [a]) => Vector [a] a where
16:30:15 <kc5tja> Otherwise, I rank that book right up with Thinking Forth.  In fact, I recommend Thinking Forth to folks too, even if they never code in Forth.
16:30:28 <kc5tja> It's even online, freely downloadable via Source Forge.
16:30:39 <cedricshock> Pseudonym: That's strange. Thanks.
16:31:02 <cedricshock> kc5tja: Forth is an oddly comforting and simple language.
16:31:03 <Shimei> kc5tja: Sounds fun, I'll go bookmark it. Add it to my giant stack of "to reads". :p
16:31:04 * kc5tja wonders if Haskell has any book that is similar in scope to Thinking Forth...
16:31:39 <kc5tja> cedricshock: Yup.  I'm using Forth for my Kestrel project's firmware.  NO, it is not open firmware.  :)
16:31:46 <Pseudonym> cedric: It makes sense if you understand it as an implication.
16:31:49 <Pseudonym> Take:
16:31:58 <Pseudonym> instance (Monad m) => Functor m where ...
16:32:08 <Pseudonym> That means that if m is a Monad, then m is a Functor, and here's why...
16:32:54 <cedricshock> Pseudonym: I'm all over that. It's just strange that I need the Eq (or some other trivial class) for haskell to be happy with the list.
16:33:11 <Pseudonym> I just picked Eq as an example.
16:33:19 <Pseudonym> If you don't need the implication, don't do it.
16:33:23 <Pseudonym> instance Vector [a] a where ...
16:33:30 <Pseudonym> I suspect you actually want something like this:
16:33:39 <Pseudonym> instance (Num a) => Vector [a] a where ...
16:33:45 <Pseudonym> If you want a real mathematical vector.
16:34:14 <cedricshock> Pseudonym: Thanks
16:42:49 <chessguy> ?seen procyon112
16:42:50 <lambdabot> procyon112 is in #gentoo-haskell and #haskell. I don't know when procyon112 last spoke.
16:43:06 <chessguy> oh, you just got here!
16:43:16 <chessguy> procyon112: howdy!
16:43:55 <amaron> what editor/environment do you use for haskell?
16:44:29 <ddarius> amaron: Most people use emacs or vim, but there are quite a few other options.
16:44:39 * chessguy uses gedit + ghci, mainly
16:44:54 <chessguy> with a little bit of vim thrown in
16:44:57 <ddarius> E.g. some Eclipse stuff, some Visual Studio stuff, other editors have syntax highlighting and such.
16:45:21 <kc5tja> vim has nice syntax highlighting, even if the default colors are a bit gawdy.  However, it does reasonably well.
16:45:26 <ddarius> amaron: You should probably keep using your current editor.
16:45:57 <amaron> ddarius: thanks, now I saw I have plugin for vim
16:49:42 <procyon112> hey chessguy!
16:49:57 <sorear> > let mult l1 l2 = map (l1!!) l2 ; grp ls = and [ mult a b `elem` ls | a <- ls, b <- ls ] ; ssets [] = [[]] ; ssets (x:xs) = ssets xs ++ map (x:) (ssets xs) in length $ filter grp $ ssets $ [ [0,1,2,3], [1,2,3,0], [2,3,0,1], [3,0,1,2] ]
16:49:59 <lambdabot>  4
16:50:07 <chessguy> how goes?
16:50:26 <sorear> > let mult l1 l2 = map (l1!!) l2 ; grp ls = and [ mult a b `elem` ls | a <- ls, b <- ls ] ; ssets [] = [[]] ; ssets (x:xs) = ssets xs ++ map (x:) (ssets xs) in filter grp $ ssets $ [ [0,1,2,3], [1,2,3,0], [2,3,0,1], [3,0,1,2] ]
16:50:28 <lambdabot>  [[],[[0,1,2,3]],[[0,1,2,3],[2,3,0,1]],[[0,1,2,3],[1,2,3,0],[2,3,0,1],[3,0,1,...
16:50:30 <procyon112> Eh.. tired.
16:50:39 <chessguy> someone mentioned this paper earlier today, and i thought of you: http://tinyurl.com/36gnp3
16:50:50 <chessguy> have you read it?
16:50:51 <sorear> can groups have zero eements?
16:51:13 <chessguy> sorear: doesn't a group have to have a zero element?
16:51:38 <sorear> good point!
16:51:39 <procyon112> chessguy: That one doesn't look familiar.. I'll have to go through it.
16:51:39 <nuncanada> a group needs a identity element
16:51:41 <nuncanada> so at least 1
16:51:50 <chessguy> procyon112: good stuff
16:52:22 <dmead> i wish someone would package the "pidgin" source with the gaim name restored
16:52:37 <chessguy> procyon112: i was thinking about your search-space-as-a-massive-tree thing the other day
16:52:41 <dmead> even thinking that name makes me feel like a yuppie
16:52:49 <dmead> who writes on BLOGS
16:52:53 <dmead> and EMAILS
16:53:26 <chessguy> procyon112: your tree only has working programs on the leaves, right?
16:54:17 <procyon112> chessguy: I'm envisioning as program at each node... but I haven't actually implemented it, so...
16:54:58 <chessguy> what's the generating function? that is, how do you get from a node to its children?
16:55:24 <sorear> > let inv x = [ i | v <- [0..3], Just i = v `elemIndex` x] ; mult l1 l2 = map (l1!!) l2 ; grp ls = elem [0..3] && all [ inv x `elem` ls | x <- ls] && and [ mult a b `elem` ls | a <- ls, b <- ls ] ; ssets [] = [[]] ; ssets (x:xs) = ssets xs ++ map (x:) (ssets xs) in length $ filter grp $ ssets $ [ [0,1,2,3], [1,2,3,0], [2,3,0,1], [3,0,1,2], [0,3,2,1], [2,1,0,3], [1,0,3,2], [3,2,1,0] ]
16:55:25 <lambdabot>  Parse error
16:56:08 <sorear> > let inv x = [ i | v <- [0..3], Just i = v `elemIndex` x] ; mult l1 l2 = map (l1!!) l2 ; grp ls = elem [0..3] ls && and [ inv x `elem` ls | x <- ls] && and [ mult a b `elem` ls | a <- ls, b <- ls ] ; ssets [] = [[]] ; ssets (x:xs) = ssets xs ++ map (x:) (ssets xs) in length $ filter grp $ ssets $ [ [0,1,2,3], [1,2,3,0], [2,3,0,1], [3,0,1,2], [0,3,2,1], [2,1,0,3], [1,0,3,2], [3,2,1,0] ]
16:56:09 <lambdabot>  Parse error
16:57:12 <sorear> > let inv x = [ i | v <- [0..3], let Just i = v `elemIndex` x] ; mult l1 l2 = map (l1!!) l2 ; grp ls = elem [0..3] ls && and [ inv x `elem` ls | x <- ls] && and [ mult a b `elem` ls | a <- ls, b <- ls ] ; ssets [] = [[]] ; ssets (x:xs) = ssets xs ++ map (x:) (ssets xs) in length $ filter grp $ ssets $ [ [0,1,2,3], [1,2,3,0], [2,3,0,1], [3,0,1,2], [0,3,2,1], [2,1,0,3], [1,0,3,2], [3,2,1,0] ]
16:57:15 <dmead> ?paste
16:57:15 <lambdabot>  10
16:57:16 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:57:20 <sorear> only 10?
16:57:48 * sorear was sure there were more than 10 subgroups of Dih[4]
16:57:59 <chessguy> ?hoogle a -> [b]
16:58:01 <lambdabot> List.intersperse :: a -> [a] -> [a]
16:58:01 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
16:58:01 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
16:58:32 <hpaste>  dmead pasted "error with arrow and tuples" at http://hpaste.org/1631
16:58:54 <dmead> could someone have a look at that?
16:59:05 <dmead> i'm not sure whats wrong with my syntax
16:59:38 <sorear> dmead: unifyAux isn't in an arrow!
16:59:46 <sorear>       do (m, n, o) <- (unifyAux  x y ([]) ([]))
16:59:46 <sorear>          (m, n, o)
16:59:48 <sorear> change to
16:59:55 <sorear> unifyAux x y [] []
17:00:11 <dmead> it's the same error with or without the parens
17:00:14 <monochrom> There is no Arrow in this code.
17:00:29 <sorear> dmead: I meant to delete the do.
17:00:53 <fasta> dmead: lose the <- ?
17:00:56 <monochrom> I think you need to erase everything you learned in the past week.
17:01:05 <dmead> sigh
17:01:11 <fasta> dmead: and convert it to let <...> =?
17:01:19 <dmead> o0
17:01:40 <monochrom> Why are you using monadic notation?
17:01:43 <Saizan> well since he just want to return the tuple there's no need for let
17:02:23 <fasta> True, but I was assuming he wanted to use that result later
17:02:27 <dmead> yea
17:02:29 <monochrom> delete "do (m, n, o) <-", and delete the next line "(m, n, o)" ?
17:02:44 <Saizan> dmead: do notation is only for monadic functions
17:02:53 <dmead> oh
17:03:03 <dmead> how can you extract samething from a tuple then?
17:03:13 <procyon112> chessguy: What I was thinking (and again, with no reference implementation it's kind of fuzzy) is that a tree would be generated by something like: the root might be the "noop" program.  now, all type-sound terminals are children, as well as all type sound branching nodes (so yeah.. now that I think about it, only leaves would be complete programs in that scheme...)  the branching nodes would each have all possible terminals as child
17:03:16 <fasta> dmead: let (a,b) = (1,2) in a
17:03:33 <dmead> > let (a,b) = (1,2) in a
17:03:34 <lambdabot>  1
17:03:36 <dmead> ah
17:03:42 <sorear> procyon112: what are chil?
17:03:51 <sorear> "odes would each have all possible terminals as chil"
17:04:06 <fasta> sorear: child
17:04:11 <chessguy> children
17:04:14 <procyon112> nodes would each have all possible terminals as children, as well as further branches.
17:04:31 <chessguy> ok, so without size constraints, it's an infinite tree
17:04:37 <procyon112> Sorry.. I have to remember not to type volumes before hitting return ;)
17:04:58 <fasta> procyon112: some clients to that for you
17:05:02 <procyon112> chessguy: yes.. it's an infinite tree containing all possible type sound programs.
17:05:45 * ddarius hugs Graham Hutton.
17:06:01 <procyon112> chessguy: There might be a way to represent it with each node being a full program... I haven't thought about it too much yet.
17:06:05 <chessguy> mm, so mutation isn't necessarily a single traverse
17:06:11 <Philippa> ddarius: any particular reason?
17:06:28 <chessguy> procyon112: i don't think you want to do that
17:07:26 <chessguy> procyon112: then every node could get a massive (possibly infinite?) number of children
17:08:01 <ddarius> Philippa: I'm reading the Monad Reader and dcoutts review of Programming in Haskell, and if I understand correctly, in chapter 12 he explains foldl'
17:08:11 <procyon112> chessguy: yeah.. the arity would blow up exponentially with depth likely in just about any representation I can think of.
17:08:58 <ddarius> Of course, I would hope so considering it's a new book, but...
17:09:07 <chessguy> but with the valid programs at the leaves, i could see the potential for being able to hack off huge branches
17:09:17 <chessguy> s/hack off/prune/
17:10:51 <procyon112> chessguy: I kind of like hack off.. much more violent sounding... good terminology for darwinian searches ;)
17:11:07 <chessguy> heh
17:11:12 <ddarius> What the heck?  He still falls afoul Hugs exporting Char (?)
17:11:22 <fuzan> hmm. i'm tyring to read from a socket, yet I seem to be using catch incorrectly. how is one supposed to read from a socket until empty?
17:11:42 <fuzan> i'm currently using sequence_, repeat, and a catch
17:12:30 <chessguy> procyon112: so when do we get to start playing with implementing this stuff ;)
17:12:45 <procyon112> chessguy: I can also envision it as a higher order tree perhaps... with each branch point being it's own infinite tree of infinite trees of infinite trees... I'm not sure if you could formulate that in a way that there is no duplication though.
17:13:16 <chessguy> i don't think that complication is necessary
17:13:24 <dmead> mandelbrot sets?
17:13:25 <dmead> o0
17:13:29 <ekidd> Hmm. Does anybody know of any neuroscience overview texts for AI folks?
17:13:31 <ekidd> I
17:13:54 <ekidd> I've got Hawkins' "On Intelligence", but I'd prefer something a bit meatier and more rigorous.
17:14:02 <procyon112> chessguy: Well, *this* implementation isn't the one I'm working on.. just an idea for the future because I think that representation might be good for interacting with other, non-evolutionary search strategies.
17:14:28 <chessguy> procyon112: agreed
17:14:44 <chessguy> it would be awfully fun to play with though
17:15:30 <procyon112> chessguy: For this round, I'm just using an infinite list... mainly because the list backtracking fits real nice with my type unification to build the programs.
17:16:55 <procyon112> chessguy: So, plan for now:  I've got a parser for types, and a real nice type checker I'm proud of now (whereas I was proud of it just actually working, this one actually looks nice and is easy to understand),
17:18:04 <procyon112> chessguy: And I've got a sample problem, that doesn't work yet (because it doesn't use my type checker)... which is just your regression problem, but it makes all your functions terminals, and adds a single, arity 2 "apply" function.
17:18:35 <procyon112> chessguy: and I've got tree generators, crossover and mutation operators.
17:19:58 <procyon112> chessguy: so really, all I need to to is finish up making tree generation and crossover/mutation configurable, and change the current internal representation of the primitives list so that there is a place to put the type info.
17:21:47 <procyon112> chessguy: My type system is extensible too.. any time it sees a new upper-case value, it calls it a new type.. no need to declare types or anything.
17:22:20 <kc5tja> /clear/clear
17:22:24 <kc5tja> oops
17:23:13 <procyon112> chessguy: It's simple HM typing though, It doesn't do typeclasses or kinding.  That kind of system would be really cool though... then you could feed it the prelude as primitives and generate full Haskell programs, Monads and all.
17:26:09 <procyon112> chessguy: I was thinking it would be cool to do a djinn-like thing: feed it a type and a list of quickcheck props, it generates an infinite list of all haskell functions that meet that type signature, then filters the list of all functions that don't pass quickcheck, and orders the list from simplest to most complex.
17:26:40 <procyon112> (tree size or depth being measure of complexity)
17:29:15 <procyon112> It wouldn't neccissarily be able to find a solution in any reasonable amount of time in a lot of cases, but It would be interesting to see where it did find them.
17:32:00 <TomMD> Is there a way to make rollover throw an exception so I can catch it instead of letting it silently cause a bug or explicit checking?
17:32:00 <TomMD> Do I have to roll my own overloaded '+' etc ?
17:32:03 <TomMD> And if so... would anyone be interested in that being a shared library?
17:33:07 <TomMD> > (200 :: Word8) + (120 :: Word8) -- What I mean by 'rollover'
17:33:12 <lambdabot>  64
17:33:27 <Saizan> aka overflow?
17:33:54 <TomMD> Yes, I noticed I called it rollover (don't know why) so I was just explicit with the Haskell example.
17:35:49 <Saizan> i think you need to make your own instance of Num ..
17:36:10 <TomMD> Damn.  OK
17:36:53 <sjanssen> you can use newtype deriving to make it a bit easier
17:37:12 <sjanssen> (ie. overload Ord, Eq, Bounded, etc.)
17:38:38 <TomMD> I don't see how that makes it easier... or how it can be used.
17:40:20 <chessguy> procyon112: sounds very cool
17:40:59 <hpaste>  sjanssen pasted "newtype deriving to cut down on boilerplate" at http://hpaste.org/1632
17:41:25 <sjanssen> TomMD: so you have to write your own Num instance, but you get all the other classes for free
17:42:19 <TomMD> I see what you mean.  Hum... that seems much better than just overloading '+'... why didn't I just think of having an encapsulating type?
17:42:23 <TomMD> Thanks
17:43:10 <sjanssen> you can't just overload '+' in Haskell -- our overloading is principled :)
17:43:23 <Saizan> you can't have two instances for the same type anyway.. (besides not importing the module that define one of them)
17:44:04 <TomMD> I've overloaded '+' before to give me a + b = a Prelude.+ b unless a == b == 2, then a + b = 5.
17:44:20 <sjanssen> ah, I wouldn't really call that overloading
17:44:26 <sjanssen> I'd say shadowing
17:44:27 <TomMD> lol, as you wish
17:45:04 <TomMD> Moving namespace... close enough to tick off the guy working on a piece of code that imports your module... and great office fun.
17:45:44 <sjanssen> it isn't quite as good as a new Num instance, because other Num functions don't know about your special +
17:46:17 <syntaxfree> I think Wikipedia is wrong regarding Haskell on this:
17:46:39 <syntaxfree> http://en.wikipedia.org/wiki/Control_flow#Choice_system_cross_reference
17:46:42 <lambdabot> http://tinyurl.com/2fs7ss
17:47:10 <syntaxfree> Haskell _does_ have a case statement.
17:47:11 <sjanssen> syntaxfree: in what respect?
17:47:12 <ddarius> How does one operational semantics "outperform" another?
17:47:36 <syntaxfree> if our "if then else"counts as a control flow statement, so does our case.
17:47:48 <syntaxfree> "a  In Haskell, a separate constant choice construct is not needed, because the same task can be done with pattern matching."
17:47:54 <syntaxfree> yes. But one has guards and case x of.
17:48:37 <dons> and guards, if-then-else, patterns are all 'case' anyway
17:48:43 <sjanssen> syntaxfree: I don't see what you're disagreeing with?
17:49:01 <syntaxfree> the table says there's no "constant choice" keyword.
17:49:15 <ddarius> No, it suggests that, but it does not say that.
17:49:22 <syntaxfree> case is explicitly a "constance choice" statement as defined before.
17:49:53 <sjanssen> syntaxfree: I think the note is sufficient
17:50:10 <syntaxfree> I think it should say "yes" anyway.
17:50:56 <SyntaxNinja> someone should do a bug-by-bug analysis of the php security bugs and note whether Haskell would be vulnerable to them: http://www.php-security.org/
17:50:59 <lambdabot> Title: the Month of PHP Bugs
17:51:03 <SyntaxNinja> or whether GHC would be, I guess.
17:51:42 <chessguy> Syzygy-: ping?
17:51:50 <dons> mm. interesting, SyntaxNinja
17:52:06 <dons> php scares me.
17:52:27 <ddarius> SyntaxNinja: Wouldn't it depend on how you wrote your code in at least some of the cases (e.g. the first one)
17:52:29 <chessguy> php = Please Hack my comPuter
17:52:58 <sjanssen> SyntaxNinja: sounds like a Sisyphean task
17:53:09 <dons> there's room for auditing the runtime, imo.
17:53:36 <dons> SyntaxNinja: do you know if that's been done? a rts audit?
17:53:41 <SyntaxNinja> ddarius: many of them are pointer or buffer-overflow attacks. which you _could_ implement in Haskell, but probably wouldn't :)
17:53:48 <SyntaxNinja> dons: not AFAIK
17:53:51 <SyntaxNinja> dons: but it should be
17:53:59 <dons> (I went through the use of strlen a few years ago, all ok, though some slightly not greaT)
17:53:59 <ddarius> Hmm
17:54:00 <SyntaxNinja> at least a grep for sprintf :)
17:54:19 * ddarius starts work on a buffer overflowable Haskell program and an exploit to go with it.
17:54:29 <dons> there's probably bytestring ptr hacks.
17:54:37 <monochrom> haha
17:55:07 <SyntaxNinja> sjanssen: yeah, it would be, but I meant for the Month of Bugs project, so it would be limited to March or whatever.
17:55:25 <thoughtpolice> i had to break up with php.
17:55:42 <SyntaxNinja> ddarius: I'd love to see one.
17:55:50 <thoughtpolice> :( sad considering it was the first language I ever learned.
17:55:52 <dons> mmm. we have xmonad tshirts now, and 40 guys on the mailing list. yay :-) http://www.spreadshirt.com/shop.php?op=article&article_id=2124110#top
17:55:56 <lambdabot> Title: xmonad, http://tinyurl.com/22rpg4
17:55:57 <thoughtpolice> but oh well.
17:56:17 <dons> i like it when haskell programs take over the world. doesn't happen often enough ;-)
17:56:21 <thoughtpolice> on another note, my packet sniffer just got bumped up to 0.5.2 in hackage and in my repo's. :)
17:56:29 <chessguy> dons: no women on the mailing list?
17:56:39 <monochrom> haskell packet sniffer?
17:56:39 <dons> gender-non-specific 'guys'
17:56:46 <chessguy> :)
17:57:00 <dons> i'm sure there are some genderless robots from the future on the list
17:57:13 <thoughtpolice> monochrom: yeah it's just a basic packet sniffer I wrote
17:57:15 <monochrom> I propose "guyrls" for gender-non-specific
17:57:18 <thoughtpolice> i wrote an article to go along with it too
17:57:20 <dons> hah
17:57:21 <Philippa> there've certainly been people who've identified as something other than male or female on list
17:57:23 <SyntaxNinja> I love how each bug is described as "trivial to exploit" heh
17:57:29 <Philippa> 'guys' is non-specific in current usage though
17:57:35 <chessguy> is that a packet-sniffer based on http://austin.youareinferior.net/ ?
17:57:39 <lambdabot> Title: totally insane | you don't talk while i take the pictures!
17:57:42 <thoughtpolice> chessguy: yeah i'm that guy
17:57:47 <gravity> That shirt is hot
17:57:51 <chessguy> nice
17:57:57 <thoughtpolice> there was a bug in it where it wouldn't print out the last few bytes of data
17:58:11 <dons> sounds like an exploit!
17:58:14 <fridim> @about exceptions
17:58:15 <lambdabot> Unknown command, try @list
17:58:28 <ddarius> You couldn't think of something more pithy than "a tiling window manager"
17:58:28 <thoughtpolice> luckily I fixed it in 0.5.2. :)
17:58:37 <thoughtpolice> dons: lies! :(
17:58:39 <fridim> is there something like a try {} catch {} ?
17:58:53 <monochrom> @hoogle try
17:58:54 <ddarius> :t catch
17:58:55 <lambdabot> IO.try :: IO a -> IO (Either IOError a)
17:58:55 <lambdabot> Control.Exception.try :: IO a -> IO (Either Exception a)
17:58:55 <lambdabot> Text.ParserCombinators.Parsec.Prim.try :: GenParser tok st a -> GenParser tok st a
17:58:56 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
17:58:59 <thoughtpolice> fridim: there's catchDyn and throwDyn
17:59:06 <thoughtpolice> and various other things in Control.Exception
17:59:08 <ddarius> Okay.  -That- one was confusing.
17:59:12 <fridim> ok.
17:59:23 <monochrom> Also look for "bracket".
17:59:54 <monochrom> @quote atomically
17:59:55 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
17:59:58 <thoughtpolice> speaking of my sniffer would anybody mind testing it out on bsd/os x or somesuch? so far it's only been tested on ubuntu/debian and archlinux, so I assume I'll have no problems there.
18:00:19 <thoughtpolice> but if someone wouldn't mind I'd be appreciative.
18:00:33 <thoughtpolice> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hsns-0.5.2
18:00:35 <thoughtpolice> thanks in advance :)
18:00:36 <lambdabot> http://tinyurl.com/2end4k
18:00:38 <monochrom> We really need GHC to come with all OSes.
18:01:10 <ventonegro> talking about OSes
18:01:34 <fridim> ocaml doesn't seem so faster than it is said (in YAHT for instance) : http://tinyurl.com/2z83lo
18:01:37 <lambdabot> Title: OCaml benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language B ...
18:01:41 <ventonegro> does anybody knows what's keeping gtk2hs 0.9.11 from hitting sid?
18:01:43 <ddarius> monochrom: Why not package GHC with it's own vertically integrated software conglomerate?
18:01:54 <ventonegro> s/knows/know/
18:02:16 <monochrom> Yes, do that too.
18:02:48 <Adamant> it would be nice if things like Perl, Python, Ruby, and all the rest (Chicken Scheme, OCaml, Haskell) etc. were packaged with OS's
18:02:54 <Adamant> all OS's
18:03:08 <ventonegro> chicken is neat
18:03:39 <monochrom> Dell laptops should be preloaded with GHC.
18:03:45 <siti> :D
18:05:37 <thoughtpolice> they should just sell 'developer laptops: with every compiler you'll ever need, ever!'
18:05:59 <ddarius> thoughtpolice: Preloaded with GHC.
18:06:32 <dons> i think ghc should come soldered into the motherboard on all new pcs
18:06:48 <monochrom> ddarius is say GHC is the only compiler you'll ever need. :)
18:06:51 <ddarius> Oooo, integrated Haskell.
18:07:04 <thoughtpolice> ddarius: if it came with emacs then that would be quite optimal for me :)
18:07:12 <thoughtpolice> as well as ghc, of course
18:07:17 <monochrom> One step at a time, dons. :)
18:07:22 <cdsmith> Installing zlib.  Me: "./Setup.hs configure" Computer: "import: unable to open X server `'."  Why does it want to open an X server?
18:07:26 <ddarius> emacs is an interpreter not a compiler, so that is acceptable.
18:07:58 <ddarius> dons: Nice use for Moore's law though.
18:08:03 <thoughtpolice> ddarius: can't have the competition taking up our floor, can we? :)
18:08:44 <dons> cdsmith: hmm, sounds very strange.
18:09:18 <monochrom> Preload computers with GHC, get everyone to use it. Slowly, Intel and AMD smells the coffee and gradually, just very gradually, evolve their CPUs towards G-machines.
18:10:04 <cdsmith> dons: yes, I thought so, too.  That is the right way to install, right?
18:10:56 <dons> runhaskell Setup.hs configure
18:10:58 <dons> might be better?
18:11:28 <cdsmith> Yes, it is.
18:11:51 <cdsmith> Ah, of course.  It was interpreting it as a shell script.  import must be an X program of some kind.
18:12:09 <monochrom> By the year 2060, GHC is considered "the portable assembler" because it's closest to the bare-metal G-machine.  C is compiled to Haskell by stacking up a couple of monads and takes a performance hit.  You will walk into #c and hear "lately I pulled this trick to get c to within twice as slow as haskell!" and then "wow you're amazing!"
18:13:02 <ddarius> Reading Moore's original statement is entertaining.
18:13:20 <Saizan> monochrom: i want a webcomic based on this :D
18:13:46 <ddarius> I intend to be dead in the year 2060.
18:13:47 <cdsmith> dons: thanks a lot.  I'm now one library closer to installing lambdabot.  Whew!
18:13:53 <Pseudonym> Actually, I predict that by 2015, transactional memory will be commonplace in high-end CPUs.
18:14:45 <Pseudonym> We'll probably see it in research CPUs within three years.
18:15:08 <ddarius> Hasn't hardware transactional memory already been studied a bit.
18:15:14 <Pseudonym> A bit.
18:15:34 <Pseudonym> I'm not sure that it's been implemented in silicon, though.
18:15:55 <Philippa> as opposed to with FPGAs, you mean?
18:16:11 <Pseudonym> Right.
18:16:26 <Pseudonym> TM has been around since 1987.
18:16:37 <Pseudonym> But I think that there hasn't been the imperative that there is now.
18:16:47 <cdsmith> ls
18:16:51 <cdsmith> oops
18:16:55 <ddarius> .
18:16:56 <ddarius> ..
18:17:10 <Pseudonym> Only in the last few years has there been a visible limit on how fast a single core can go.
18:17:58 <Pseudonym> The first PhD theses proposing actual TM hardware date from 2004.
18:18:02 <Pseudonym> So I think 3 years is reasonable.
18:21:03 <chessguy> ?seen Syzygy-
18:21:04 <lambdabot> Syzygy- is in #haskell. I last heard Syzygy- speak 2h 45m 16s ago.
18:21:52 <Philippa> remind me, TM still has potentially awful behaviour if too many threads're going for the same resource, right?
18:22:32 <chessguy> ?hoogle pcap
18:22:36 <lambdabot> No matches found
18:22:53 <Pseudonym> Philippa: http://www.cs.wisc.edu/multifacet/papers/isca07_pathologies.pdf
18:23:30 <Pseudonym> The problem isn't going for the same resource.  It's doing that when your transaction size is large.
18:23:43 <Pseudonym> But large transaction sizes is much the same as large critical sections.
18:25:53 <Pseudonym> It'd be kinda cool to port some of SPLASH-2 to Haskell + STM.
18:35:32 <Philippa> with large critical sections you've still not got rollback issues though, no?
18:35:43 <Philippa> still, I'll read
18:36:00 <Pseudonym> That's true.
18:36:09 <Pseudonym> Although...
18:36:31 <Pseudonym> Databases tend to have large critical sections, and they often implement rollback.
18:40:11 <Pseudonym> In general, lock-free programming can suffer from livelock.  Lock-happy programming can, by comparison, only suffer from deadlock.
18:43:52 <cdsmith> Hurray!  I have lambdabot and GHCi on Acid working, and it only took about 11 hours!
18:44:00 <shapr> Can I create a Handle from a String?
18:44:11 <shapr> Is there something like Python's StringIO for Haskell?
18:44:28 <dons> openFile ?
18:44:47 <kilimanjaro> cdsmith, now set aside a few hours to get Hello World! working!
18:44:50 <dons> what do you mean, shapr? a Handle abstraction onto a string in memory?
18:45:12 <daniel_larsson> Sort of, yes
18:45:43 <dons> cdsmith: cool
18:45:54 <cdsmith> kilimajaro: to be fair, a couple hours was installing Linux because it apparently won't work on Windows; and another five was hacking a Linux text editor to add syntax highlighting for Haskell because I didn't have another editor I like there.
18:45:54 <dons> cdsmith: you should write about what you did to get it working on windows
18:45:59 <dons> ah ok.
18:46:00 <daniel_larsson> StringIO in python puts a "stream" interface on strings (read, write)
18:46:06 <emu> lock-happy code is a contradiction in terms
18:46:18 <dons> right. so hmm, I'd use bytestrings. :-0
18:46:22 <shapr> dons: Yeah, I wanted to try writing some QuickCheck tests for things that require a Handle, so I figured I could generate a string and feed that into it.
18:46:44 <cdsmith> dons: Actually, I didn't get it working on Windows; I just installed Linux.
18:47:02 <dons> ok. that's a better option in the long term :-0
18:47:08 <dons> grr. my shift key isn't working
18:47:33 <int-e> @hoogle pipe
18:47:33 <lambdabot> Foreign.C.Error.ePIPE :: Errno
18:47:33 <lambdabot> Foreign.C.Error.eSPIPE :: Errno
18:47:33 <lambdabot> System.Win32.File.fILE_TYPE_PIPE :: FileType
18:47:38 <Philippa> Pseudonym: I was thinking about situations like the Unreal Engine's game sim where it's not impossible that by the end of a frame you'll have a small pile of objects all trying to interact with each other at once
18:47:55 <dons> anyone able to give feedback to this guy, http://article.gmane.org/gmane.comp.lang.haskell.cafe/22044
18:47:57 <Philippa> I guess ultimately you'd solve that by building a solid message-passing system on top
18:47:58 <lambdabot> Title: Gmane -- Mail To News And Back Again
18:50:00 <Pseudonym> dons: I was planning to.  I just haven't made it that far in my inbox yet.
18:50:40 <chessguy> someone was in here talking about a bloom filter the other day. wonder if it was the same guy
18:51:16 <chessguy> oh, i think it was, it's the same link to an explanation of what a Bloom filter is
18:51:28 <shapr> dons: How can I use ByteStrings for that?
18:51:28 <int-e> shapr: not a pretty idea, but with System.Posix.createPipe you can create a pipe, create handles with fdToHandle and then fork off a thread to write to the pipe.
18:57:19 <daniel_larsson> Hmm... I assume ghc uses ld to link? Anyone know if it's possible to tell cabal to tell ghc how calls ld?
18:57:44 <daniel_larsson> I'm having weird link problems I can't quite grok...
19:00:36 <dons> ghc-options: -optl-foo
19:00:43 <Pseudonym> If someone would like to look at the Cabal packaging stuff rfor that Bloom filter code, that'd be good.
19:00:50 * Pseudonym is no Cabal expert
19:03:46 <falconair> i'm trying to understand various incarnations of FRP (before Yampa).  Basically the type Behavior a = Beh (\t -> a), which seems to be implemented with lists underneath ... does it make sense to think of this Behavior type  as a simple interface to a list of data, while hiding the actual list itself?
19:04:36 <falconair> another way to say it, the Behavior type seems to work very well with 'time series' type operations on a list of data ... couldn't the same be done with a list comprehension?
19:05:38 <falconair> third way to ask my question: I like how some problems are easier with behavior type ... but I just haven't gotten an intuitive feel for it yet ... any one have experience with it?
19:09:47 <dolio_> Isn't a behavior supposed to represent a time-varying (potentially) value?
19:11:07 <chessguy> falconair: one way to thinking of it is this:  Beh :: (a -> b) -> Behavior b
19:12:00 <chessguy> where a is some type for time, and b is the type of the varying behavior
19:12:06 * dolio goes to find his FRP papers...
19:12:22 <chessguy> dolio: it's in HSOE
19:12:40 <falconair> in this case I am thinking specifically of the paper "Charting Patterns on Price History" which shows how beautifully one can encode 'trading strategies' ... which are mostly timer-series operations (moving averages, etc.) ... in fact, using behaviors, the code actually cleaner than list comprehensions!
19:12:51 <falconair> http://citeseer.ist.psu.edu/460325.html
19:12:53 <lambdabot> Title: Charting Patterns on Price History - Anand, Chin, Khoo (ResearchIndex)
19:12:59 <chessguy> oh, that i'm not familiar with
19:13:34 <falconair> yeah, i don't see it mentioned much, i had to follow 'cited by' links on google scholar...but it is a pretty nice paper
19:14:03 <chessguy> falconair: HSOE does a good job of explaining time-varying behaviors
19:14:07 <chessguy> ?where soe
19:14:08 <lambdabot> http://haskell.org/soe/
19:15:19 <falconair> i was actually going through SOE a few days ago ... it is still surprising that list comprehensions are not as nice in expressing some logic as Behaviors
19:15:46 <chessguy> why would that be surprising?
19:15:49 <chessguy> hi ekidd
19:15:58 <ekidd> chessguy: Hi!
19:16:00 <falconair> i was hoping someone here would tell me that Behaviors seem better to a newbie like me because they "abstract over X" and all would be good!
19:16:40 <falconair> chessguy: because i always thought list comprehensions would basically be best at this data stuff ... this intuition was reinforced when i read about LC's link to SQL
19:16:50 <chessguy> a behavior is just a function
19:17:15 <chessguy> at time t, there is only one value that the behavior exhibits
19:17:40 <chessguy> LC as in lambda calculus?
19:17:54 <falconair> List Comprehension
19:18:06 <chessguy> oh
19:18:20 <chessguy> newbies are too in love with list comprehension :)
19:18:42 <falconair> i think I just need to work with it a bit more, rather than thinking that there is some deep haskell philosophy I'm missing out on :)
19:19:07 <dons> the zen of monad comprehensions, eh?
19:20:14 <falconair> oh, that reminds me, how about the zen of co-monads, or applicitive functors (spelling?) ... there were some papers said that arrows are not the best way to deal with streams ... any consensus yet?
19:20:29 <falconair> (btw, i have no idea what comonads or applicative functors are)
19:20:59 <dons> yeah, applicative functors make sense in some situatoins.
19:21:09 <dons> we're using them in thehead branch of the 'binary' library
19:21:17 <dons> ?source Control.Applicative
19:21:17 <lambdabot> Control.Applicative not available
19:21:20 <dons> ah, in base.
19:22:10 <falconair> how about the following situation: i have bunch of data (stock quotes, trades, market events, etc.) coming in fast and furious off a network ... what's the best way of dealing with them?
19:22:14 <dons> http://article.gmane.org/gmane.comp.lang.haskell.cafe/22058
19:22:16 <lambdabot> Title: Gmane -- Mail To News And Back Again
19:22:21 <dons> "Bay Area Haskell users' group, anyone?"
19:22:29 <shapr> Well, list comprehensions are what got monads into Haskell long ago and far away, so they're worth studying.
19:22:32 <dons> falconair: hmm, bytestrings.
19:23:00 <dons> it really depends on what you mean by 'dealing'
19:23:13 <falconair> i'm actually going to the new york user group this week
19:23:20 <MyCatVerbs> falconair: beat the crap out of them with a baseball bat, then run them over with a running lawnmower.
19:23:45 <dons> falconair: hmm. I wonder if we can get notes, or a report on the talks?
19:23:58 <dons> i wonder how many people will be there.
19:24:11 <falconair> i'll be happy to report back, but i suspect more experienced people are better candidates
19:24:30 * shapr hacks FiniteMap out of some old code.
19:24:47 <falconair> i'm trying to convince people at work to go, but they say this looks to mathematical :(  they actually have a math background!
19:24:57 <dons> hmm, 'computational category theory'
19:25:00 <emu> list comprehensions are just an alternative to do-notation
19:25:01 <dons> sounds fun! http://www.cs.man.ac.uk/~david/categories/book/book.pdf
19:25:18 <dons> falconair: what, a haskell user's group at Credit Suisse?
19:25:26 <dons> how much math is going to be at that? :)
19:25:33 * shapr laughs
19:26:00 <dons> oh wait, you might end up talking about computational categories. i retract my statement.
19:28:21 <falconair> ok, so back to dataflow haskell ... if i have 'streams' of data coming in, i'd like to be able to operate on them the same way i might work with lists (perhaps using list comprehensions?) ... it seems to me that i can't do what with call backs or whatever, i would have to use some sort of dataflow mechanism which will ...
19:28:48 <falconair> let me deal with time varying values in a natural way ... what is the best way to get there: arrows (yampa)? comonads or app. .functors?
19:29:16 <dons> i'd use lazy bytestrings
19:29:26 <dons> i.e. lazy lists provide streams naturally
19:29:48 <falconair> dons: but lazy bytestrings can be used for unbounded number of values ... such as stock feeds?
19:29:59 <dons> for specifically time-varying continuous values, yampa is used, yes.
19:30:07 <dons> there's also the 'ports' abstraction
19:30:08 <falconair> i understand using them for reading a fixed sized file ...
19:30:09 <dons> let me find that..
19:30:23 <dons> lazy bytestrings can be used for unbounded streams of data
19:30:28 <dons> as long as you're consuming them as you go
19:31:08 <dons> http://www.cse.unsw.edu.au/~chak/haskell/ports/
19:31:08 <lambdabot> Title: The Haskell Ports Library
19:31:12 <falconair> what do you mean 'consuming them as you go?'  each new 'tick' that arrives will need to be processed...used in some computation, filtered, etc.
19:31:14 <dons> " Ports are an abstraction for modelling variables whose values evolve over time without the need to resort to mutable variable, such as IORefs"
19:31:28 <dons> falconair: right. each tick is a strict chunk in the lazy bytestring stream
19:31:34 <dons> once processed, its done and gone
19:31:52 <dons> we use laziness to do streaming all the time.
19:32:14 <falconair> wow, never seen this ports thing, it claims to be in 'alpha' release, as of GHC 6.2 ... is it still being updated?
19:32:23 <dons> nah.
19:32:35 <dons> but it might be useful if you're planning work in a similar area
19:33:30 <falconair> no prob.  the only paper i see is "Distributed Haskell: Goffin on the Internet" which describes a _predecessor_ of this outdated library ... any newer paper i should read or just that?
19:34:07 <dons> not that I know of.
19:34:30 <kolmodin> @yarr
19:34:31 <lambdabot> Arr! Me ship be the biggest brig in the port!
19:34:32 <dons> though possibly the Frag thesis on continuous values in yampa (for gaming) might be relevant
19:34:35 <dons> ?wiki Frag
19:34:35 <lambdabot> http://www.haskell.org/haskellwiki/Frag
19:35:12 <falconair> ok, i'll check out lazy bytestrings and HPL ...thanks folks, i'll be back with more ambiguous non-questions soon
19:35:36 <shapr> Ya know, if you run a big ghc compile while doing apt-get upgrade, neither process performs well.
19:36:07 <SamB_XP> shapr: one would have thunk that was self evident
19:36:18 <dons> please sir, can I have more cores?
19:36:23 <SamB_XP> even with one's new 1.7 GHz P4...
19:36:29 <shapr> dons: Yes! I want more cores!
19:37:40 <dons> I recall during a recent PLS meeting at unsw, it was pointed out that it took about 2 hours to come up with some software that saturated the 16 core amd box. I suggest that software was like a gas, that expands to fill available resources. Roman said, "no, *your* software is like a gas". then i cried.
19:37:52 <shapr> haha
19:38:58 <dons> anyone else think that larswm looks like a 1980s version of xmoand, http://www.lab1702.net/fnurt/larswm/larswm_ss.png
19:39:04 <Philippa> heh. It's just Parkinson's law, no?
19:39:11 <SamB_XP> dons: take it as a compliment!
19:39:42 <SamB_XP> that means you were the one who's software is able to utilize 16 cores
19:39:50 <kolmodin> haha. modern larswm comes with green color though
19:39:53 <kolmodin> not red
19:39:55 <SamB_XP> while everyone else was tooling along at one or two cores
19:40:10 <dons> kolmodin: does it still look pretty much like that?
19:40:17 <kolmodin> aye
19:40:25 <kolmodin> pretty much
19:40:28 <dons> SamB_XP: hehe. yeah, i just happened to have a script that launched 16 parallel jhc jobs.
19:40:29 <kolmodin> :D
19:40:38 <dons> so really its john meacham's software that's like a gas ;-)
19:40:48 <SamB_XP> what did they do?
19:41:00 <dons> jhc happily uses 2G of ram for a compilation run
19:41:01 <kolmodin> green adds the matrix dimension though, I'd like that :D
19:41:04 <dons> so build 16 programs in parallel
19:41:08 <dons> kolmodin: hehe
19:41:08 <wolverian> http://www.linux.org.ru/gallery/bigL1Kyhd.png a bit cuter larswm
19:41:13 <SamB_XP> *2G*?
19:41:17 <SamB_XP> hmm.
19:41:19 <Pseudonym> dons: Critique sent.
19:41:31 <SamB_XP> well, it did that one time...
19:41:58 <dons> wolverian: ah nice, thanks. so the black root window helps?
19:42:21 <Pseudonym> You know, we really need integer log base 2 in Data.Int.
19:42:46 <Pseudonym> That's about the eighth time I've seen it reimplemented.
19:43:13 <dons> nice Pseudonym++
19:43:21 <SamB_XP> wouldn't that be in Data.Bits?
19:43:30 <Pseudonym> Maybe.
19:43:42 <Pseudonym> It doesn't seem like a bit operation to me.
19:43:48 <SamB_XP> I'd want it for Word, too...
19:43:58 <Pseudonym> Data.Int has all that Word stuff in it.
19:44:20 <Pseudonym> Oh, maybe not.
19:44:29 <Pseudonym> Actually, it makes MORE sense for Word* than Int*
19:44:34 <Pseudonym> You're right.
19:45:10 <falconair> dons: quick one: do you know of any code examples I could study which use bytestrings for unbounded streams of data?
19:45:52 <dons> lazy bytestring. hmm. main = putStr. filter (/= 'e') =<< getContents
19:46:12 <dons> lazy implies unbounded :-)
19:46:35 <falconair> and getContents returns a bytestring which can be through of as a stream?
19:46:45 <wolverian> dons, the key is a uniform colour scheme. integration.
19:47:00 <wolverian> (which is non-trivial, given the different types of applications on a modern X desktop)
19:47:13 <falconair> eh...by unbounded I meant potentially never ending stream of data...where as a static file would be bounded ... no?
19:48:16 <sebell> falconair: How does the language know that the file is "static"?
19:48:41 <dons> falconair: yeah, lazy streams of infinite data.
19:48:47 <falconair> sebell: right, that makes sense
19:49:05 <falconair> ok, thanks, back to work :)
19:49:13 <dons> falconair: e.g. main = putStr. filter (/= 'e') =<< getContents runs in constant space, forever, filtering its input stream
19:49:30 <SamB_XP> falconair: oh, you mean like computations based on /dev/zero?
19:49:40 <dons> alternately, main = interact (filter (/='e'))
19:50:12 <cdsmith> Where can I find a list of keywords that GHC adds to Haskell98?  A lot are listed in 7.1 of the user guide, but I just realized it doesn't mention "as" or "qualified" there.
19:50:41 <SamB_XP> cdsmith: those are in Haskell 98, are they not?
19:53:17 <cdsmith> SamB_XP: They aren't listed in chapter 2 of the report.
19:53:37 <SamB_XP> actually, maybe they aren't keywords ;-)
19:53:46 <SamB_XP> > let as = 1 in as
19:53:47 <lambdabot>  1
19:54:04 <cdsmith> Oh.  Hmm...
19:54:22 <cdsmith> That makes my job harder. :)
19:56:38 <cdsmith> So you're right; they are Haskell98.
20:00:06 <encryptio> what does the glyph that looks something like a backwards E mean? (context implies it's something from set theory)
20:00:25 <cdsmith> encryptio: "there exists"
20:00:55 <cdsmith> encryptio: it's a quantifier from set theory; it means that some member of set causes the following predicate to be true.
20:01:29 <encryptio> gotcha
20:03:42 <dibblego> ?hoogle [a] -> [a] -> Bool
20:03:43 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
20:03:43 <lambdabot> List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
20:07:39 <dibblego> ?src List.isSuffixOf
20:07:40 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
20:07:54 <dibblego> ?src isSuffixOf
20:07:55 <lambdabot> isSuffixOf x y = reverse x `isPrefixOf` reverse y
20:13:28 <dibblego> ?src last
20:13:29 <lambdabot> last [x]    = x
20:13:29 <lambdabot> last (_:xs) = last xs
20:13:29 <lambdabot> last []     = undefined
20:15:06 <sproingie> how do i make ghc use the /dev/urandom RNG?  it seems to be seeded with the clock right now, with a full second granularity
20:15:29 <dons> you want a binding to /dev/urandom?
20:15:51 <kolmodin> ?localtime
20:15:52 <kolmodin> g'night
20:15:57 <lambdabot> Local time for kolmodin is Tue May  1 05:09:17 2007
20:16:04 <sorear> .
20:16:24 <sorear> grumble.  GHC *still* is unbuildable
20:16:48 <cdsmith> sorear: why?  just curious...
20:17:06 <sorear> cdsmith: -Wall -Werror, and new warnings
20:17:25 <cdsmith> sorear: Oh, I see.  And the new warnings can't be easily fixed, I guess?
20:17:31 <sorear> They can.
20:17:40 <Korollary> HEAD is broken?
20:17:41 <sorear> but nobody has bothered yet
20:17:43 <sorear> yeah
20:17:47 <sorear> HEAD/extralibs
20:18:04 <sorear> igloo tells me it works if you delete the extralibs
20:18:07 <sorear> small comfort :/
20:18:19 <dons> quit whining, and start patching!
20:18:30 <dons> its a great exercise to try to be the first to fix a build failure
20:18:37 <dons> i used to play that game a few years ago
20:18:41 <Korollary> Why do they check changes in when they break the build?
20:18:53 <dons> laziness
20:19:20 <thoughtpolice> torture? (for some, I suppose)
20:19:31 <sorear> Is it possible to incrementally build ghc?
20:19:44 <sorear> I don't want to wait an hour between fixes :)
20:20:14 <MyCatVerbs> sorear: the good news is yes, of course it is. The bad news is I for one have no clue how. ;)
20:21:03 <MyCatVerbs> sorear: try #ghc, it's full of people who hack on GHC itself.
20:25:55 <dibblego> > last $ [1..] ++ [7] -- why doesn't this return 7
20:26:03 <lambdabot> Terminated
20:26:07 <dons> heh.
20:26:10 <dons> how could it?
20:26:13 <dons> ?src last
20:26:13 <lambdabot> last [x]    = x
20:26:13 <lambdabot> last (_:xs) = last xs
20:26:13 <lambdabot> last []     = undefined
20:26:24 <dibblego> it's a question I have been asked
20:26:29 <dibblego> I can't give a definitive answer
20:26:36 <dons> it has to get to the last element, using a loop
20:26:39 <dons> the [1..] gets in the way
20:26:54 <dibblego> yeah I understand that
20:27:07 <dibblego> a compiler might see the expression [1..] ++ [7] and return 7
20:27:34 <clanehin> Infinity + 1 is seven now?
20:27:39 <dons> it might see, last ([1..] ++ [7]) and optimise that to 7, yes.
20:27:48 <dons> but that's not valid. :-)
20:27:56 <dibblego> so my question is, why is it not valid?
20:28:16 <dons> because we've changed the program from a non-terminating one, to a terminating one.
20:28:33 <dibblego> ok, so the answer is as simple as "infinity + 1 is infinity"?
20:28:34 <dons> and optimisations that change the termination behaviour aren't encouraged.
20:28:39 <dons> right.
20:28:54 <dons> [1..] ++ x   is _|_
20:29:00 <SamB_XP> dibblego: well, last ([1..] ++ foo) is _|_, regardless of foo
20:29:12 <dibblego> yes I agree and I should have seen it that way
20:30:28 <dons> if you put a type constraint on '1' it might work .. :-)
20:30:32 <dons> (i.e. boundedEnumFrom
20:30:53 <dibblego> ah yes
20:30:54 <dons> then you're just changing the complexity, not the termination
20:31:35 <dons> {-#
20:31:36 <dons> RULES forall xs y.
20:31:36 <dons>     last (xs ++ [y]) = y :: Int
20:31:36 <dons>   #-}
20:31:43 <dons> so for bounded, strict types, that might be ok.
20:31:45 <Korollary> I think the real reason is that last works on list values, not expressions that can be combined to produce lists. The compiler would have to use a theorem prover.
20:32:10 <dons> nah. rules would be enough.
20:32:18 <dons> you can code algebraic properties of the api as rewrite rules
20:32:29 <dons> so , for example, last (_ ++ [x]) --> x
20:32:41 <dons> for bounded types.
20:32:44 <Korollary> Yes you can add axioms. For a general solution you'd need a prover.
20:32:49 <dons> (don't even have to be strict).
20:32:58 <dons> right. if you wanted your compiler to find these optimisations.
20:33:04 <ddarius> dons: Computational Category Theory is implementing CT in ML.
20:33:09 <dons> yep.
20:33:25 <ddarius> Some pretty cool things since most of CT is constructive.
20:33:41 <Korollary> Coq has CT modules
20:36:40 <ddarius> dibblego: Because _|_ /= 7
20:36:51 <dibblego> ddarius, good answer :)
20:38:00 <dons> dibblego: you're optimisation is this, I think:
20:38:02 <dons> {-# RULES
20:38:02 <dons> "last/append" forall e (v :: Int).
20:38:02 <dons>     last ((++) e (v : [])) = v
20:38:02 <dons>   #-}
20:38:27 <dons> of course, 'e' might still be bottom :-)
20:38:41 <dons> so its refining non-terminating programs to terminating ones. ah well
20:38:55 <dons> last (undefiend ++ (v : [] ) --> v
20:40:42 <sorear> _|_ /= <demons>
20:40:47 <sorear> perhaps it should be
20:41:22 <ddarius> That would be a bad thing.
20:41:50 <ddarius> To put one way, a lot of productive things in Haskell == _|_.
20:44:44 <sorear> ddarius: Useful programs as a whole do not evaluate to _|_
20:44:59 <ddarius> Sure they do.
20:45:09 <sorear> I'm using the tree interpretation of IO, so a program that evals to _|_ performs no actions
20:45:50 <dibblego> ?type (++)
20:45:53 <lambdabot> forall a. [a] -> [a] -> [a]
20:46:04 <sorear> ddarius: example?
20:46:43 <MyCatVerbs> :t _|_
20:46:46 <lambdabot> parse error on input `|'
20:47:07 <sorear> MyCatVerbs: forall a. a
20:47:15 <MyCatVerbs> @~%$!
20:47:15 <sorear> it's in every type of kind *
20:47:15 <lambdabot> Unknown command, try @list
20:47:31 <sorear> but _|_ is not input syntax
20:47:52 <MyCatVerbs> sorear: it is on the list.
20:48:06 <MyCatVerbs> The list of things which make my brain go ouch.
20:48:40 <Korollary> The wikibook has a good explanation
20:49:30 <Korollary> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
20:49:32 <lambdabot> Title: Haskell/Denotational semantics - Wikibooks, collection of open-content textbooks
20:50:09 <MyCatVerbs> Korollary: it's a list with cardinality |N|, in my case.
20:50:34 <Korollary> heh nah
20:51:12 <MyCatVerbs> Lately I've been getting the impression it's more like |R|. x_x
20:53:19 <dibblego> ?type ($!)
20:53:22 <lambdabot> forall a b. (a -> b) -> a -> b
20:58:16 <ddarius> sorear: Every non-terminating program, e.g. a server.
20:59:08 <sorear> ddarius: That's not _|_, at least in the tree interpretation - just like (1:(1:(1:...))) /= _|_
21:01:58 <Korollary> Where is this tree-interpretation defined?
21:02:18 <nornagon> @src ($!)
21:02:19 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
21:02:49 <sorear> @src $!
21:02:50 <lambdabot> Source not found. Just what do you think you're doing Dave?
21:02:59 <sorear> x $! y = y `seq` x y
21:06:00 <nornagon> strict apply?
21:06:39 <Binkley> yes
21:06:40 <hpaste>  j3h pasted "Where is the space leak?" at http://hpaste.org/1633
21:08:24 <j3h> or better, how do I find the space leak?
21:08:29 <Binkley> j3h: did you profile?
21:08:46 <sorear> j3h: (\x -> x `seq` (x + 1))
21:09:06 <sorear> j3h: is utterly pointless
21:09:10 <j3h> okay
21:10:14 <sorear> j3h: you appear to be not forcing the state, so you are building a long chain of thunks
21:10:32 <j3h> the seq was an attempt to force
21:11:05 <sorear> j3h: right, but seq isn't magic
21:11:15 <sorear> j3h: it gets deferred like every other function
21:11:25 <sorear> x `seq` x == x
21:11:31 <bos> j3h: you could figure out what's going on by using profiling and adding some SCC annotations
21:13:50 <j3h> I'm at a loss for where to add the annotations
21:14:07 <bos> first, run without any.
21:14:22 <bos> use use -prof -auto-all, and ghc will annotate all the top-level functions for you.
21:15:05 <bos> you'll then see "oh hey, i'm spending all my time in foo", at which point you can add annotations near the start of each definition inside foo.
21:15:25 <bos> by the way, what's your code trying to do?
21:15:28 <j3h> what is CAF?
21:15:54 <j3h> it's trying to run optimization functions, with a (relatively) hard time limit
21:15:55 <bos> constant applicative form.
21:16:31 <j3h> the watching thread just sleeps and raises an exception in the calling thread when the time limit is reached, aborting the calculation
21:16:33 <bos> a CAF is an expression that's not a lambda, for example.
21:17:20 <bos> so f = 2 + 3 defines a CAF, because it's not something you can apply to something else.
21:17:22 <sorear> bos: no, a CAF is a top level thunk without arguments
21:17:34 <sorear> f = \x -> 2 + 3 is a CAF
21:17:37 <j3h> profiling says 100% of allocations from CAF
21:17:47 <bos> j3h: main is a CAF
21:17:59 <bos> sorry, sorear is correct.
21:18:11 <sorear> my example isn't.
21:18:14 <bos> so you can ignore the 100%-to-a-CAF entry.
21:18:17 <sorear> (however, main *is* a caf)
21:19:39 <sproingie> @hoogle Handle
21:19:40 <lambdabot> System.IO.Handle :: data Handle
21:19:40 <lambdabot> Control.Exception.handle :: (Exception -> IO a) -> IO a -> IO a
21:19:40 <lambdabot> System.Win32.Types.HANDLE :: type HANDLE
21:19:51 <bos> sorear: const (2 + 3) would be a CAF, though.
21:20:10 <sproingie> hm, where is System.IO.Handle?
21:20:11 <bos> the thing is to have no free variables in the definition.
21:20:25 <sorear> bos: right.
21:20:27 <bos> where is it? in System.IO???
21:20:49 <sorear> sproingie: in GHC, the module name ends at the last .
21:20:57 <sorear> (this is not standard haskell behavor)
21:22:40 <sproingie> ohhhh, silly me
21:22:51 <sproingie> switching gears from doing java today :)
21:24:52 <Binkley> java? I'm sorry
21:25:20 <sproingie> bleargh
21:31:33 <dfranke> is there a reason that Control.Arrow doesn't define:
21:31:42 <dfranke> instance (ArrowApply a, ArrowPlus a) => MonadPlus (ArrowMonad a) where
21:31:42 <dfranke>     mzero = ArrowMonad zeroArrow
21:31:42 <dfranke>     mplus (ArrowMonad a) (ArrowMonad b) = ArrowMonad (a <+> b)
21:35:26 <falconair> sorry, i got disconnected, so does data parrallel hakell work w/ ordinary lists?  if not, are DPH specific lists/array very different from the way normal lists behave?
21:36:11 <dons> falconair: yeah, they're very different.
21:36:12 <hpaste>  j3h pasted "Simpler space leak" at http://hpaste.org/1634
21:36:21 <dons> you're explicitly using parallel (strict or lazy) arrays
21:36:30 <dons> for lists, use Control.Parallel.Strategies
21:36:35 <dons> e.g. for a `parMap`
21:36:42 <j3h> I don't think I know enough to know how to force things
21:37:15 <Heffalump> morning all
21:38:00 <Binkley> yo
21:38:41 <bos> j3h: in that case, use foldl' (flip ($)) instead of foldr ($)
21:39:14 <falconair> dons: so why would one use DPH rather than Control.Parallel.Strategies?
21:39:29 <dons> because they want large (strict) parallel arrays
21:39:46 <bos> j3h: you're constructing a huge deferred expression.
21:39:52 <falconair> so DPH deals with strict arrays?
21:39:54 <dons> you get better, faster code from DPH, since its also using fusion. very different data structure to a parMap
21:40:00 <dons> it does. and nested arrays
21:40:56 <sorear> does dph exist yet?
21:41:23 <j3h> I understand that, but I'm not sure how to generally avoid that, if there isn't a strict version of the function that I'm using to iterate
21:41:23 <dons> the first release was about 2 weeks ago.
21:41:31 <falconair> and parMap makes better use of multiple CPUs ... but doesn't parellelise across machines, correct?
21:41:52 <dons> parMap will use multiple cores, as will parallel array comprehensions (and other dph operations)
21:41:57 <sorear> no, parMap makes worse use of multiple cpus.
21:42:08 <sorear> *parallel array comprehensions*!?!
21:42:13 <sorear> they're adding syntax?!
21:42:19 <dons> they did. years ago
21:42:26 <j3h> my other code was using mapM_ (modifyIORef r) and I think that the IORef was holding the big deferred structure
21:42:27 <dons> [: f x | x <- xs :]
21:42:35 <j3h> and I can't see how to force that
21:42:37 <sorear> what ever happened to libraries?
21:42:46 <dons> j3h: urgh, yesh :-) somethingIORef $! v
21:42:53 <sorear> j3h: don't use modifyIORef!
21:43:07 <sorear> j3h: modifyIORef is irrevocably lazy
21:43:40 <sorear> j3h: use myModifyIORef v f = readIORef v >>= \x -> let x' = f x in x' `seq` writeIORef v x'
21:43:52 <dons> $! would be more appropriate
21:43:56 <sorear> yeah
21:44:16 <j3h> and that works because writeIORef is in the IO monad so the seq will actually get evaluted?
21:44:31 <dons> writeIORef v $! x
21:44:33 <dons> for example
21:44:51 <bos> j3h: by the way, your second paste is one of the rare cases where it makes sense to use foldl instead of foldr
21:44:53 <sorear> dfranke: Is your ascii art .sig supposed to be a boobytrapped mailbox?
21:45:07 <sorear> dfranke: I don't get it :(
21:46:26 <dfranke> sorear, http://en.wikipedia.org/wiki/Ama-gi
21:46:27 <lambdabot> Title: Ama-gi - Wikipedia, the free encyclopedia
21:47:41 <j3h> thanks, all. I think I have a much better handle on forcing computations.
21:48:14 <bos> may the seq be with you.
21:49:55 <gaal> jwz says: "Did you know that the HTML entity for → is &rarr;? Who knew that arrows were so piratey."
21:50:20 <dons> hehe
21:50:32 <dons> > arr!
21:50:32 <lambdabot>  Parse error
21:50:51 <dons> > arr ! ()
21:50:52 <lambdabot>  Couldn't match expected type `Array i e'
21:50:54 <dons> better
21:51:05 <bos> perhaps you want (->) matey
21:52:38 <tessier> Anyone know how I can subscribe to The Monad Reader? mailing list? rss feed? Something?
21:52:48 <tessier> If I don't somehow subscribe I will completely forget that it exists and never reader it again.
21:53:55 <kc5tja> Hehe -- I forgot how to close a window in xmonad.  :)
21:53:55 <Binkley> if you're on the haskell or haskell-cafe mailing lists, you'll see the announcements
21:54:08 <sorear> M-S-Enter xkill
21:54:12 <sorear> :)
21:54:23 <dons> mod-shift-c
21:54:27 <dfranke> instance Monad.Reader tessier?
21:55:05 <kc5tja> sorear: mod-shift-c works better.  ;)
21:55:16 <kc5tja> dons: Thanks for the reminder.  :)
21:55:28 <dons> we need a popup man page
21:56:20 <gaal> tessier: I think LtU also announces it regularly
22:00:43 <ddarius> dfranke: What is that thing in your sig?
22:00:44 <sorear> dfranke: hehe, nice.  do you have a picture of the look on your advisor's face? :)
22:00:54 <tessier> gaal: Yeah, LtU is how I found it this time. Although it is on it's 7th edition and I only just now heard about it.
22:01:44 <ddarius> tessier: There was a big break between issues 5 and 6.
22:02:00 <dfranke> ddarius, <dfranke> sorear, http://en.wikipedia.org/wiki/Ama-gi
22:02:01 <lambdabot> Title: Ama-gi - Wikipedia, the free encyclopedia
22:02:25 <dfranke> now somebody else ask me so I can recurse even deeper.
22:02:49 <sorear> dfranke: my most recent comment was re: how to write an interpreter in one day.
22:03:41 <ddarius> @google One Day Compiler
22:03:44 <lambdabot> http://www.venge.net/graydon/talks/mkc/html/mgp00001.html
22:03:44 <lambdabot> Title: MagicPoint presentation foils
22:03:47 <sorear> dfranke: there, I've sabotaged you by unwinding your stack!
22:04:08 <dfranke> ddarius, http://rpal.sf.net/oneday.html
22:04:10 <lambdabot> Title: How to Write an Interpreter in One Day
22:04:11 <ddarius> sorear: I'm sure he's saved a continuation.
22:04:23 <ddarius> I've written many an interpreter in one day.
22:04:30 <sorear> dfranke: I presume you don't have a photo :)
22:04:37 <dfranke> sorear, no :-(
22:04:41 <ddarius> How do you -not- write an interpreter in one day?
22:04:54 <sorear> ddarius: by using C!
22:05:11 <bos> we like graydon.
22:07:23 <ddarius> "trees are just a special case of lists" blech
22:07:30 <ddarius> Lisp lists are rose trees.
22:09:41 <Pseudonym> Lisp trees are binary trees.
22:09:47 <Pseudonym> With rose tree syntax.
22:09:57 <ddarius> True.
22:10:01 <ddarius> I know!
22:10:37 <ddarius> Forget list/tree/pair.  Magmap - Magma processing language!
22:10:59 <Pseudonym> "Magma" is the dumbest name.
22:11:04 <sorear> there actually is a language MAGMA
22:11:05 <Pseudonym> I keep thinking of abstract lava.
22:11:15 <sorear> (embedded in a CAS of the same name)
22:11:22 <ddarius> I have no idea of where abstract algebra gets half it's names.
22:11:47 <sethk> ddarius, which half?  :)
22:12:26 <dfranke> algebra is doomed when we run out of synonyms for "bunch" that haven't already been assigned special meanings.
22:12:26 <Pseudonym> ddarius: Easy.  They just use old terms.
22:12:30 <sorear> <joke> E.Galois was ahead of his time wrt teen alcohol use :)
22:12:43 <Pseudonym> Presumably the half which isn't named after mathematicians.
22:13:03 <Pseudonym> "Noetherian ring" gets half its name from a mathematician, and half from thin air.
22:13:17 <ddarius> You could write a good movie about Galois' life.
22:13:35 <Pseudonym> You could, but I'm not sure how you'd depict the maths.
22:13:47 <sorear> Odd.  come to think of it, I've always seen Noether and never No:ther
22:13:56 <Pseudonym> She was American.
22:13:58 <sorear> (imagine that second is a real umlaut)
22:14:00 <Pseudonym> That's how she spelled it.
22:14:31 <ddarius> Pseudonym: It could still be good without the math, though personally I'd enjoy the math (and would prefer it, but that ain't ever going to happen).
22:14:43 <Pseudonym> You don't actually have to depict the maths as such.
22:14:46 <ddarius> He was an unlucky SOB.
22:14:52 <sorear> Oh, I had Noether confused with Norbert.
22:14:53 <Pseudonym> The problem is that you need to get across how profound it was.
22:15:22 <Pseudonym> Just showing his stuff getting sent to universities and being rejected is misleading.
22:15:26 <Pseudonym> He could have just been a crank.
22:15:28 <ddarius> Have old crusty looking guys see his work and act all surprised and excited.
22:15:32 <sorear> Never mind the fact one is a sirname and one is a firstname.
22:15:50 <ddarius> (Of course, the people weren't old and crusty, but it's better that way for the movies)
22:15:53 <Pseudonym> You should show the speech... I think by Hardy.
22:16:01 <Pseudonym> Where he finally presented Galois' results.
22:16:25 <Pseudonym> The problem is to avoid it being a lone-genius-that-they-all-laughed-at movie.
22:16:40 <ddarius> Pseudonym: That's easy considering the rest of his life.
22:16:51 <Pseudonym> Well, yes, obviously.
22:16:54 <Pseudonym> The political stuff.
22:16:59 <Pseudonym> He was definitely a Renaissance man.
22:17:14 <Pseudonym> I think you'd need to downplay the lone genius bit.
22:17:50 <ddarius> That'd be easy.  A lot of the way he seemed to have acted doesn't fit the modern perception of "lone genius".
22:17:54 <Pseudonym> True.
22:18:14 <Pseudonym> Does anyone know of a good full-on biography?
22:18:25 <Pseudonym> I only know what I read in the first chapter of that book.  You know the one.
22:19:03 <ddarius> I might have read a biography in a collection of mathematician biographies, but not something very comprehensive.
22:19:08 <Pseudonym> Right.
22:19:21 <ddarius> I.e. like maybe a 30 page chapter max, not anything like a book dedicated to it.
22:19:57 <sorear> > 20 * 365 / 400
22:19:59 <lambdabot>  18.25
22:20:20 <dfranke> heh... one of my old math professors just subscribed to a LUG mailing list that I'm on.
22:20:58 <sorear> night.
22:23:01 <_frederik_> hello what is a Cxt?
22:23:47 <pstickne> I had a few "Cx=v"s in my homework tonight :p
22:24:58 <sorear> _frederik_: you mean in TH?
22:25:11 <sorear> _frederik_: a context, like (Num a, Ord a) =>
22:25:12 <ddarius> We need more Cxt.
22:25:47 <sorear> _frederik_: this is represented as the list of types [TApp (TCon "Num") (TVar "a"), TApp (TCon "Ord") (TVar "a")]
22:26:03 <sorear> was that what you meant?
22:38:29 <dons> mm. QuickCheck 2
22:38:39 <Pseudonym> : The Revenge
23:11:15 <bos> @pl \st -> (st, st)
23:11:16 <lambdabot> join (,)
23:11:31 <bos> :type join (,)
23:11:37 <bos> @type join (,)
23:11:44 <lambdabot> forall a. a -> (a, a)
23:15:01 <dblhelix> @type join
23:15:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
23:15:47 <dblhelix> how's pair an instance of monad?
23:16:26 <mauke> it isn't
23:16:37 <mauke> (a ->) is
23:16:45 <dblhelix> ah, I see
23:16:53 <mauke> join :: (a -> (a -> b)) -> (a -> b)
23:17:03 * dblhelix should have some coffee first :-)
23:20:20 <mauke> why does it seem like existentials let me create types at runtime?
23:23:44 <bos> um, to get to the other side?
23:25:48 <mauke> :(
23:28:58 <earthy> mauke: it doesn't. all things that are wrapped by an existential do have types statically
23:29:28 <earthy> however, it is only dynamically known when these things get wrapped
23:29:37 <hpaste>  mauke pasted "runtime types" at http://hpaste.org/1635
23:31:34 <earthy> hpaste: conceptually, this defines *all* natural types in one go
23:31:43 <earthy> (good morning!)
23:32:01 <earthy> mauke: conceptually, this defines *all* natural types in one go
23:32:10 <mauke> I define type-level naturals
23:32:20 <earthy> however, their usage is governed dynamically
23:32:23 <mauke> v2d translates values to types
23:32:30 <earthy> mauke: I understand. :)
23:32:46 <earthy> conceptually, the program contains all type-level naturals, statically
23:33:07 <earthy> so, you are not inventing types at runtime
23:33:20 <earthy> however, which types you exactly use *is* determined at runtime
23:34:07 <earthy> there is something to be said for your point of view though. :)
23:34:21 <mauke> how does that not invent types at runtime
23:34:36 <mauke> Succ Zero is a different type than Zero (or anything else)
23:34:39 <earthy> the program statically contains *all* type-level naturals
23:35:01 <earthy> i.e.: statically the types Succ Succ Succ .... Zero  *all* are known
23:35:05 <mauke> I don't believe you
23:35:47 <earthy> that is exactly what the instance Nat a => Nat (Succ a) does
23:35:58 <earthy> much like   f x = x : f x
23:36:08 <earthy> much like   f x = x : f (x + 1)
23:36:15 <sm> evening all!
23:36:21 <earthy> which is also statically an infinite list
23:36:42 <mauke> that just creates an "infinite" number of instances for a certain group of types
23:36:59 <earthy> mauke: yeah... so the types have to exist, no? :)
23:37:09 <mauke> hmm, no
23:37:12 <earthy> you can't make an instance for a non-existing type...
23:37:26 <mauke> I think I can
23:37:37 <earthy> and your   data Succ a    defines how to make a type   Succ a   from any type a
23:38:23 <mauke> heh, I can change  type Zero = (); type Succ = [];  and it still works
23:38:42 <earthy> yah, it would. ;)
23:38:44 <sm> I'm having some laziness trouble.. http://hpaste.org/1636 prints all 12 files when I run each step in ghci, but only the first 5 files when I run main
23:38:59 <sm> why could this be ?
23:39:31 <earthy> sm: you're not forcing the runInteractiveCommand to finish
23:39:53 <earthy> sm: i.e.: your code ends and closes the output handle for grep before grep has finished producing output
23:40:23 <sm> aha
23:40:40 <earthy> sm: you want to add something like   seq grepoutput $ waitForProcess pid
23:41:01 <sm> interesting! thanks
23:41:14 <earthy> @type seq
23:41:20 <lambdabot> forall a t. a -> t -> t
23:42:03 <sm> does this happen because I'm in the imperative io monad ?
23:42:16 <sm> I expected things to just magically flow
23:42:18 <earthy> (why this? because you want to make sure you read all output before the grep ends, and seq forces the (lazy) IO that hGetContents does)
23:42:32 <earthy> sm: no, it happens because you're running 2 programs conceptually in parallel
23:42:47 <earthy> hGetContents reads from the out filehandle lazily (as needed)
23:43:11 <earthy> so what you have is basically a concurrency issue
23:43:49 <earthy> the seq forces synchonization (as it forces evaluation of the result of hGetContents)
23:44:28 <sm> I see.. yet, I've seen other haskell programs that seem to stream things lazily .. so that I would see output immediately
23:44:34 <sm> with this forcing, I seem to lose that
23:44:39 <earthy> ah, yes. that is possible
23:44:55 <DRMacIver> Morning
23:45:09 <earthy> but you will have to take care of synchronization
23:45:24 <earthy> this is just the brute force 'gobble it all up and enjoy' method
23:46:04 <sm> cool
23:46:11 <sm> works fine for this
23:47:00 <sm> this is a little script to help me see what functions are where
23:47:16 <hpaste>  sm annotated "laziness trouble" with "example" at http://hpaste.org/1636#a1
23:47:44 <sm> any other good tricks for this kind of thing ?
23:49:01 <earthy> sm: 'what functions are where'... i.e. something much akin to ghci's :hasktags ? :)
23:49:08 <earthy> or the hasktags command? :)
23:51:06 <sm> yes, that gives me tags for emacs.. but I wanted something more like a quickreference.. showing types and modules
23:51:24 <earthy> ah. hoogle. :)
23:51:30 <earthy> but, yea. ;)
23:52:27 <sm> use hoogle to index my own code ?
23:52:50 <earthy> hoogle 4 is supposed to be able to do that. :P
23:52:58 <earthy> (here's to bugging ndm some more ;))
23:58:13 <fuzan> How can I read the entirety of a handle with ByteString and not have it block? repeately grab 1 byte and try and catch an IOError?
