00:01:04 <sjanssen> (eavesdropping in #gentoo-haskell) you're want to write the binding in the next two weeks?
00:01:11 <sjanssen> s/you're/you
00:03:01 <fons> hi all
00:03:01 <dcoutts> sjanssen: I'm not sure that 2 weeks comment referred to that
00:03:19 <sjanssen> dcoutts: oh, okay
00:03:41 <dons> no no. the HW paper deadline is early June.
00:05:50 <sjanssen> yeah, I've considered binary for xcb message parsing (did I mention that before?).  I think it's a very good fit
00:06:57 <dons> good.
00:10:32 <fons> Hi does anyone know about a pretty printing library for Haskell appart from HughesPJ? I need to remove parenthesis from an expression when printing it acording to the precedence and associativity of operand
00:11:44 <fons> and I don't know how to do it taking advantage of HughesPJ (showsPrec helps with the precedence but not with the associativity)
00:15:09 <mgsloan> must a function have no side effects to be pure?  what if a function call had increments a counter with an uncheckable value?  The output of the function is depends only on the inputs, and nothing depends on the counter, so what's the problem?
00:15:26 <mgsloan> s/had/
00:15:45 <mgsloan> wow, i should just rewrite that
00:15:50 <mgsloan> mist be getting sleepy
00:17:08 <Korollary> if the counter doesn't do anything, why is it there?
00:17:28 <therp> mgsloan: I presume other functions can read this counter, and then suddenly you have state
00:17:43 <mgsloan> therp - no, I said it's uncheckable
00:18:05 <mgsloan> Korollary: another program might have an interest in the value
00:18:07 <therp> mgsloan: well then, why is it there?
00:18:24 <therp> "another program" != "another function"?
00:18:25 <mgsloan> well, its a hypothetical thought experiment
00:18:37 <mgsloan> yeah, the other program admits state
00:20:25 * ortmage_ in a fit of frustration aliases dards to darcs... stupid kinesis keyboard, forcing me to learn to type properly
00:20:30 <QtPlatypus> mgsloan: The state of that counter should be considered part of the output of that program.
00:21:47 <mgsloan> hmm, good point
00:22:05 <mgsloan> well, then, all haskell functions are impure
00:22:06 <therp> ortmage: ;) I got mine a year ago, and typing is so comfortable
00:22:26 <ortmage_> therp: it's getting better... the first week was barely tolerable :)
00:23:16 <ortmage_> i figure once i stop screwing up letters for a while, i'll switch to dvorak and thereby prevent myself from being useful for months
00:26:05 <therp> ortmage: yeah I know. The first week is a severe drop in productivity, but after the first week you should be fine. my next step is to switch to a different keyboard layout than qwerty ..
00:27:29 <ortmage_> therp: i definitely like it so far (aside from compulsively replacing cs with ds).. i do wish they'd put the shift key under the thumb
00:27:38 <ortmage_> therp: which one do you think you'll pick up?
00:27:41 <therp> ortmage: hmm, I'm not going for dvorak. maybe colemak or the evolved keyboard layouts ..
00:29:42 <therp> ortmage: I haven't decided yet.. most keyboard layouts are designed for a keyboards where thumbs are mostly "useless"
00:29:57 <earthy> is there a very good reason not to stick with qwerty? i.e.: are you *always* on the same kb?
00:29:58 <mgsloan> I tried out colemak for a while - was pretty ncie
00:30:16 * earthy already gets annoyed when the ` or the \ are in different spots on the keyboard
00:30:20 <earthy> let alone all the keys
00:30:21 <therp> ortmage: that's of course not true with kinesis. http://colemak.com/Alternative_layouts is pretty much informative
00:30:23 <lambdabot> Title: Alternative layouts - Colemak
00:30:47 <ortmage_> oo nifty
00:31:10 <ortmage_> earthy: i dunno, it always seemed like something worth trying... perhaps its just masochistic?
00:31:30 <earthy> maybe. then again, I do about 300cpm on qwerty
00:31:51 <QtPlatypus> on the note of getting alternate input devices, I have a IBM model M keyboard, I'm thinking of getting one of these http://www.fentek-ind.com/FootPedal.htm So I can do meta and super.
00:31:52 <lambdabot> Title: Foot Pedals for Keystroke and Mouse Click Emulation
00:32:02 <therp> ortmage: http://clemens.endorphin.org/therp.xkb - I'm using the capsctrlwin overlay
00:32:18 <earthy> oh, and I don't do only english, but also dutch
00:32:23 <earthy> which has different letter distributions
00:32:31 <therp> ortmage: the control-caps-win remap at the first 3 lines are the most important remapping for me on kinesis
00:33:10 <ortmage_> has anyone tried http://www.datahand.com/
00:33:12 <lambdabot> Title: Ergonomic Keyboards By DataHand To Reduce Keying Stress.
00:33:31 <therp> a friend of mine was interested.. but never bought it actually
00:33:36 <earthy> I did try http://www.velotype.com/ once
00:33:38 <lambdabot> Title: Velotype!
00:33:54 <earthy> that's a whole different world though
00:34:28 <ortmage_> earthy: i'm having difficulty finding a picture of it on that website
00:35:02 <earthy> yeah, the site is broken
00:35:18 * ortmage_ is glad he is not the broken one
00:35:20 <earthy> http://en.wikipedia.org/wiki/Velotype has got a picture
00:35:21 <lambdabot> Title: Velotype - Wikipedia, the free encyclopedia
00:36:21 <ortmage_> a chording keyboard? i've heard of those, but never met someone who's used one... how was it?
00:36:27 <earthy> weird
00:36:53 <earthy> plus, it's barely suitable for keying in program code
00:37:35 <ortmage_> seems to be a trend... the default layout on my kinesis puts the {}s down next to the arrow keys
00:41:03 <ortmage_> oof bedtime. gnight all
00:41:16 <earthy> night ortmage
00:52:34 <hpaste>  Cheery pasted "StyleSheetAST, now with declarations!" at http://hpaste.org/1326
00:55:04 <Cheery> it is freaky, now one could write the 'class Code a where generate :: a -> String', and I can go and define the small piece which writes the stylesheet with this AST
00:55:45 <dons> hehe
00:55:50 <dons> pretty printers for all :-)
00:56:09 <dons> its a perfect application for ad hoc polymorphism, though, Cheery. so the code should look great.
00:56:22 <dons> basically the language feature -- type classes -- perfectly matches what you want to do.
00:56:31 <dons> that is, define different printing styles on a per-type basis
00:56:56 <ivanm> dons: with those RSA codes you gave me, how do you use them?
00:57:03 <ivanm> do they require each other?
00:57:05 <eumenides> how do i handle C-s in hscurses, since KeyChar is Char but C-s shows up as ^S (a String)?
00:57:31 <dons> ivanm: no, they're just indepdnent, standalone modules.
00:57:43 <dons> eumenides: perhaps just match the ascii code?
00:57:45 <dons> > '\10'
00:57:46 <lambdabot>  '\n'
00:57:52 <dons> > '\49'
00:57:53 <lambdabot>  '1'
00:57:58 <dons> > '\65'
00:57:59 <lambdabot>  'A'
00:58:00 <Cheery> I agree, it has turned out well, after all, even I still feel I should make it even better :(
00:58:20 <ivanm> dons: *nod*... with the one that spells out RSA, whats the actual function you use?
00:58:34 <eumenides> dons: i guess would work. thanks
00:58:48 <dons> ivanm: not sure. follow 'main' and work from there down.
00:59:20 <ivanm> oh, didn't see the main in there
00:59:37 <ivanm> so the top part spells out RSA... what's the bottom bit meant to be?
00:59:50 <dons> main=interact
00:59:51 <dons>   (unlines.map(show.p(e,n).cox.map(fromIntegral.ord)).coll)
00:59:56 <fuzan> hey -- how does one control printing decimal decision ?
01:00:07 <fuzan> err
01:00:09 <fuzan> "precision"
01:00:29 <dons>  the showFFloat and friends functions
01:00:30 <dons> or printf
01:00:34 <dons> ?hoogle showFFloat
01:00:35 <lambdabot> Numeric.showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
01:00:36 <ivanm> dons: yeah, I found that... trying to run it via ghci doesn't seem to work though
01:00:47 <ivanm> dons: even though its type is just IO ()
01:00:47 <dons> > showFFloat (Just 4) (pi :: Double) []
01:00:49 <lambdabot>  "3.1416"
01:00:53 <dons> > showFFloat (Just 16) (pi :: Double) []
01:00:55 <lambdabot>  "3.1415926535897930"
01:01:15 <fuzan> dons: thanks.
01:02:38 <ivanm> dons: where are those RSA codes from, anyway?
01:03:09 <dons> programs? one is a winner of the 1992 obfuscated haskell contest, another is hmm, something posted to the mailing list
01:03:18 <ivanm> which one's which?
01:03:30 <ivanm> the one spelling out RSA is obfuscated?
01:03:35 <dons> yes.
01:03:38 <dons> clearly!
01:03:47 <dons> that is not normal haskell :-)
01:04:17 <ivanm> lol
01:04:28 <ivanm> having trouble getting it to work :s
01:04:44 <ivanm> every now and then it spits out numbers... which is presumable the encrypted form
01:05:04 <dons> just cat an input file into it
01:05:07 <ivanm> unless its waiting for a block size to be completed
01:05:13 <dons> cat jl_rsa.hs | ./rsa
01:05:14 * ivanm is running it through ghci
01:06:55 <ivanm> how would you decrypt with it?
01:07:12 <dons> not sure. i'd probably just refactor the larger program, or else write one from scratch
01:07:20 <dons> rather than using the scary obfucated one.
01:07:29 <ivanm> lol
01:07:40 <ivanm> would you know if the bottom part is meant to say anything?
01:09:07 <dons> hey aja. you're bouncing.
01:09:24 <dons> you tried out xmonad yet, aja? :-)
01:09:34 <aja_> Hey Dons.
01:09:36 * dons hopes aja is a candidate for tiling window managers.
01:09:41 <aja_> Bouncing?  That an irc term?
01:09:51 <dons> yeah.
01:09:58 <dons> for repeated disconnects and reconnects.
01:10:07 <vincenz> I call it hiccuping :)
01:10:19 <vincenz> @spell hiccuping
01:10:20 <lambdabot> hiccuping
01:10:21 <aja_> I don't actually have a linux machine atm, just Windows and Mac OS.
01:10:35 <earthy> so. Mac OS X comes with X
01:10:52 <aja_> After all the difficulties I've had with msys/mingw on Vista, tho I certainly wish I was using Linux.
01:10:56 <earthy> hmm... kubuntu+xmonad. would that work, xmonad with kde?
01:11:08 <dons> kde. urgh.
01:11:11 <nornagon> O_o
01:11:18 <dons> i suppose it depends on your definition of 'work' :-)
01:11:25 <olliej> dons: someone's bitter :D
01:11:37 <dons> xmonad is sort of the antithesis of kde..
01:11:49 <nornagon> :p
01:11:50 <earthy> hm. well. :)
01:12:06 <aja_> I'm a little confused as to who is who on here :-)
01:12:08 <dons> it might be funny to watch though, loading up some huge kde set in xmonad.
01:12:35 * olliej googles xmodad
01:12:47 <mauke> @where xmonad
01:12:48 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
01:13:11 <olliej> wow
01:13:12 <dons> ?google xmonad
01:13:13 <olliej> it's tiny
01:13:14 <lambdabot> http://www.xmonad.org/
01:13:15 <lambdabot> Title: xmonad : a lightweight X11 window manager.
01:13:18 <dons> :-)
01:13:19 <olliej> (this doesn't surprise me)
01:13:59 <olliej> dons: you realise i have single patches that are larger than xmonad
01:14:13 <dons> heh
01:14:27 <Cheery> 400 lines window manager? :-)
01:14:32 <dons> yep.
01:14:36 <Cheery> must DL!
01:14:41 <olliej> dons: hehe
01:14:58 * dons heads home. later lambda heads!
01:15:24 <kolmodin> @yarr
01:15:24 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
01:15:25 <earthy> have a nice evening, dons.
01:15:40 <olliej> toodles dons
01:16:29 <JaffaCak1> dons: xmonad list is set up
01:17:34 <JaffaCak1> dons: I don't know if http://haskell.org/mailman/create works, since the aliases need to be set up too
01:17:37 <lambdabot> Title: Create a haskell.org Mailing List
01:18:08 <dons> JaffaCak1: ah great.
01:18:17 <dons> do we have a web administratoin apge?
01:18:21 <dons> that i have access to?
01:18:35 <ivanm> Whats the code on http://haskell.org/haskellwiki/Obfuscation meant to do?
01:18:36 <lambdabot> Title: Obfuscation - HaskellWiki
01:18:48 <foxy-om_> is there a standard way of converting a (short) list to a tuple?
01:18:59 <dons> ivanm: it is a dictionary lookup of some kind.
01:19:08 <JaffaCak1> dons: you'll get an email from mailman
01:19:16 <dcoutts> foxy-om_:  (\[a,b,c] -> (a,b,c))
01:19:25 <ivanm> dons: any idea how you're meant to use it?
01:19:34 <foxy-om_> %-D
01:20:44 <malcolmw> it is a shame that the webpages for 2003 and 2004 obfuscated competitions have disappeared
01:21:26 <dons> yeah. they're on shapr's hard drive
01:21:32 <dons> we hope to recover them now he's back in stockholm
01:21:46 <dons> ok. night all. bbl.
01:22:52 <ivanm> cya dons
01:23:04 * ivanm is trying out the code from the bottomth comp
01:23:26 <ivanm> the one by Mikael Rittri doesn't seem to work :s
01:25:00 * malcolmw is glad he saved his winning entry from 2003
01:26:01 <ivanm> malcolmw: what did you do?
01:26:21 <malcolmw> http://www.cs.york.ac.uk/fp/software.php (look for remorse)
01:26:39 <lambdabot> Title: York Functional Programming Software
01:27:41 <ivanm> firefox gives me an error "550 Failed to change directory"
01:48:25 <roconnor> @unpl (??????)(???)(????)=((groupBy)(???)(????))
01:48:26 <lambdabot> (???) ?????? (????) = groupBy (???) (????)
01:48:41 <roconnor> @pl (??????)(???)(????)=((groupBy)(???)(????))
01:48:41 <lambdabot> (line 1, column 20):
01:48:42 <lambdabot> unexpected "="
01:48:42 <lambdabot> expecting variable, "(", operator or end of input
01:54:41 * ski realizes he's made an oleg
01:55:22 <ivanm> what does "making an oleg" mean?
01:55:34 <mauke> @quote oleg
01:55:34 <lambdabot> shapr says: [on Oleg:]  And ccshan and he would argue furiously for a minute or two and then SPJ would say "Why don't you send an email to the Haskell list about that so we can have time to understand
01:55:35 <lambdabot>  what you just said?"
01:56:29 <ivanm> hmmm
01:56:46 <mauke> @quote oleg
01:56:47 <lambdabot> AshleyYakeley says: Expect a whole new batch of type shenanigans from Oleg
01:56:55 <ski> well, yesterday i figured out a way to do 'zip' only using 'foldr' for deconstructing the lists .. it turns out oleg did that one and a half year ago ..
01:57:12 <ski> (and my solution is virtually the same as his :)
01:59:11 <ivanm> lol
01:59:15 <ivanm> @where chr
01:59:16 <lambdabot> I know nothing about chr.
01:59:21 <ivanm> @hoogle chr
01:59:22 <lambdabot> Char.chr :: Int -> Char
01:59:22 <lambdabot> Text.PrettyPrint.HughesPJ.Chr :: Char -> TextDetails
01:59:22 <lambdabot> Text.Regex.matchRegex :: Regex -> String -> Maybe [String]
02:27:32 <foxy-om> In http://okmij.org/ftp/Haskell/number-parameterized-types.html, Oleg uses type level numbers to ensure correctness of vector operations.  In his vector creation function, the first argument is of type "size of vector" which in his examples is provided by the programmer.  Is there a way to create this programmatically from a Num?  i.e. a function num2digits :: Num a, Digits ds => a -> ds, I...
02:27:33 <lambdabot> Title: Haskell Programming: Types that depend on numbers
02:27:33 <foxy-om> ...keep getting type errors...
02:27:35 <foxy-om> @paste
02:27:35 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:29:05 <hpaste>  foxy-om pasted "num to digits" at http://hpaste.org/1327
02:29:22 <roconnor> > (1,2) < (1,3)
02:29:24 <lambdabot>  True
02:33:51 <vincenz> @localtime psykotic
02:33:53 <lambdabot> Local time for psykotic is Tue Apr 10 18:36:25
02:44:09 <ski> num2digits :: forall a. Num a => a -> exists a. Digits ds *> ds  -- not actual code
02:45:23 <ski> data SomeDigits = forall ds. Digits ds => SD ds
02:45:31 <ski> num2digits :: forall a. Num a => a -> SomeDigits
02:46:41 <ski> (GADT : 'data SomeDigits :: * where SD :: forall ds. Digits ds => ds -> SomeDigits')
02:47:33 <ski> num2digitsCPS :: forall a. Num a => a -> (forall a. Digits ds => ds -> o) -> o
02:49:16 <ski> foxy-om : the problem with your 'num2digits :: Num a, Digits ds => a -> ds' is that your function can't work for any choice of 'a' and 'ds' (satisfying the class constraints) the caller wants to main .. otoh you want it to give a specific type 'ds' (depending on what the actual number was) .. thus you need existentials, in some form
02:49:52 <foxy-om> hm... I'm trying to catch up with what you're saying
02:50:32 <foxy-om> I take it that the CPS version doesn't require a GADT wrapper?
02:50:38 <ski> right
02:51:09 <foxy-om> I'm not really au fait with CPS...
02:51:19 * foxy-om begs for an implementation hint :)
02:52:18 <ski> heh, i haven't considered how to implement it, haven't read how 'Digits' work at all :)
02:52:44 <foxy-om> data D0 a = D0 a ...
02:52:47 <roconnor> what's the derivitive of the complex conjugage function?
02:52:58 <roconnor> conjugate
02:53:50 <foxy-om> ski: line 15 of the paste suggests that digits are CPS'able
02:54:38 <roconnor> oh, I think maybe it isn't differentable anywhere
02:54:49 <roconnor> stupid complex numbers
02:54:57 * ski is not sure what kind of function a derivative of a complex function is at all ..
02:55:12 <ivanm> @src ord
02:55:13 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
02:55:20 <roconnor> ski: it's a complex function
02:55:37 <ski> (maybe it is similar to the case of 'R^2 -> R^2' .. ?)
02:55:44 <DRMacIver> roconnor: It's not complex differentiable anywhere. This is because complex differentiable functions are very very nice. :)
02:55:45 <roconnor> ski: for example d(x^2+ix+1)/dx = 2x+i
02:55:50 <DRMacIver> (Which conjugation isn't)
02:56:03 <roconnor> :'(  I think conjugation is pretty nice.
02:56:08 <ski> roconnor : is 'x' complex, there ?
02:56:09 <mauke> @src Char.ord
02:56:10 <lambdabot> Source not found. I feel much better now.
02:56:17 <roconnor> ski: yes
02:56:38 <ski> foxy-om : oh, didn't see the paste
02:57:42 <dons> sjanssen: i've pushed a brief sketch of the structure.
02:57:54 <dons> feel free to hack on any sections, otherwise, we can talk tomorrow and try to get it down .
02:58:45 <DRMacIver> roconnor: Complex differentiable functions have strong uniqueness properties which conjugation doesn't satisfy
02:59:27 <DRMacIver> Along with various other not nice features of it. :)
03:00:50 <roconnor> @i Complex
03:00:50 <lambdabot> Maybe you meant: id index instances instances-importing irc-connect . v
03:00:55 <ivanm> dons: I thought you said before you were going to sleep...
03:01:01 <roconnor> @instances Complex
03:01:02 <lambdabot> Couldn't find class `Complex'. Try @instances-importing
03:01:12 * Syzygy- likes conjugation - it's one of the simplest examples of a group representation you can find. :P
03:01:29 <dons> ivanm: nope i said i was going home :-)
03:01:48 <ivanm> ahhh.... well, actually, you said "night all", and I interpreted that as you going to sleep...
03:01:57 <foxy-om> dons, nz is at the top of the Super 8 table!!! :P
03:01:59 <DRMacIver> Syzygy-: Sure. But it's not a nice function. :)
03:02:17 <Syzygy-> DRMacIver: Whaddayamean not nice?
03:02:40 <DRMacIver> Analytically speaking.
03:02:45 <ski> foxy-om : somthing like 'str2digitsCPS [] k = k Sz; str2digitsCPS ('0' : ss) k = str2digits ss (\ds -> k (D0 ds)); ...' if i'm thinking straight (and no 'Num2Digits' class, just a 'num2digits' function)
03:02:48 <olliej> foxy-om: zomg!
03:02:58 <Syzygy-> "This paper, whose intent is stated in its title, gives wrong solutions to trivial problems."
03:03:01 <DRMacIver> It has inconvenient features like being equal to the identity on R but not globally.
03:03:08 <dons> foxy-om: :p
03:03:13 <Syzygy-> DRMacIver: Who cares about analycity? That's booooooring. ;)
03:03:43 <Syzygy-> DRMacIver: See, that's what we call a red-du-ci-ble re-pre-sen-ta-ti-on.
03:03:50 <ivanm> I don't know why, but I can't get the second and third entries from the bottomth obfuscation contest to work :s
03:04:08 <DRMacIver> Syzygy-: Your presence on the algebraic weirdos team has been duly noted. :)
03:04:24 <Syzygy-> DRMacIver: Wasn't that public knowledge already?
03:08:33 <foxy-om> ski: doesn't typecheck...  Couldn't match expected type `D0 a' against inferred type `Sz'
03:09:14 <araujo> morning
03:09:14 <ski> foxy-om : what is the type signature of 'str2digits' ?
03:09:37 <foxy-om> ski, didn't give it one...
03:09:39 <ski> it should be 'str2digits :: String -> (forall a. Digits ds => ds -> o) -> o'
03:10:04 <foxy-om> ah
03:10:05 <ski> (otherwise 'k' doesn't get polymorphic)
03:11:48 <hpaste>  foxy-om annotated "num to digits" with "with ski's type signature" at http://hpaste.org/1327#a1
03:12:11 <foxy-om> arg...
03:12:23 <foxy-om> forall ds
03:12:24 <ski> arg, yes
03:12:27 <ski> right
03:12:44 <foxy-om> ski++ -- Oleg foo
03:12:45 <opqdonut> :)
03:13:01 <LeCamarade> q/quit
03:13:18 <foxy-om> @karma+ ski --Oleg foo
03:13:18 <lambdabot> ski's karma raised to 10.
03:13:27 <foxy-om> ski, thanks
03:13:30 <ski> works now ?
03:13:42 <opqdonut> why lock base 10?
03:14:36 <ski> presumably to not get too-wordy types ..
03:15:15 <opqdonut> well, yeah
03:15:50 <foxy-om> ski, well, it typechecks, but it doesn't work...
03:17:33 <hpaste>  foxy-om annotated "num to digits" with "typechecks but doesn't compute" at http://hpaste.org/1327#a2
03:17:57 <DRMacIver> Syzygy-: Hence past tense. :)
03:18:52 <ski> foxy-om : what doesn't work ?
03:19:08 <foxy-om> num2digits 10
03:22:42 <ski> num2digits 10 show
03:22:49 <ski> try that ?
03:23:55 <ski> (you need to pass a continuation when using it .. and you can't use 'id' sadly)
03:25:05 <foxy-om> hm... well if I pass num2string an Int how do I get a Digits ds => ds out the other end that I can use?
03:25:21 <ski> no
03:25:25 <ski> you need to do
03:25:36 <ski> num2digits 10 (\ds -> do stuff with ds)
03:25:53 <foxy-om> why can't I use the identity?
03:26:43 <ski> because haskell doesn't have existential quantification in types
03:27:06 <ski> because doing that would require 'o' to be something like 'exists ds. Digits *> ds' above
03:27:35 <foxy-om> hm.. could I pass a function that adds D0?
03:27:42 <ski> (you still can hide it inside an "existential datatype" like 'SomeDigits' above .. so that'd be 'o', then)
03:28:39 <ski> sure, as long as you call an outer continuation, or wrap into something like 'SomeDigits', or convert away the existential, like 'show'
03:29:03 <foxy-om> show doesn't work
03:29:03 <ski> (yes this is a bit clunky ..)
03:29:56 <ski> hm, oh
03:30:11 <ski> (i assumed 'show' was defined ..)
03:30:48 <foxy-om> ski, I defined it, but I still get type errors
03:31:41 <foxy-om> ski, OK, what if I wrap in SomDigits... could I then later unwrap and use it in e.g. vec :: Digits size => size -> [a] -> Vec size a ?
03:32:07 <ski> num2digits 10 (\ds -> ds2num ds 0)
03:32:23 <ski> foxy-om : yes
03:32:39 <ski> num2digits 10 (\ds -> show (ds2num ds 0))  -- or
03:33:15 <ski> (but you'd probably need to wrap or CPS-handle 'Vec size a', too ..)
03:33:41 * ski 'd really like real existential quantification in types
03:34:56 <ski> (istr jhc has 'exists' syntax, but only in argument position in function types :/ )
03:34:58 <DRMacIver> I've heard that phrase before, but I still don't know what it means. What are existientially quantified types?
03:37:29 <ski> a value of type 'forall a. ..a..' can be used in any context expecting something of type '..X..', for 'a' replaced with any type 'X' .. otoh the producer of the value can't assume anything about what type 'a' actually will be
03:39:00 <ski> a value of type 'exists a. ..a..' can only be used in contexts which don't assume anything about 'a' .. otoh the producer of the value can actually use any type 'X' instead of 'a' it wants, possibly depending on run-time values
03:39:52 <ski> e.g.
03:40:01 <ski> foo :: forall a. a -> (a,a)
03:40:15 <ski> foo a = (a,not a)
03:40:53 <ski> is wrong since the producer assumes 'a' to be 'Bool', while it shouldn't assume anything
03:40:58 <ski> otoh
03:41:06 <ski> bar :: forall a. (a,a) -> (a,a)
03:41:12 <ski> bar (a0,a1) = (a1,a0)
03:41:14 <ski> is ok
03:41:25 <ski> and
03:41:28 <DRMacIver> Sure.
03:41:39 <ski> test_bar = bar (False,True)
03:41:41 <ski> is also ok
03:42:01 <ski> with (hypothetical) existentials one could possibly write something like
03:42:34 <ski> baz :: Bool -> exists a. (a,a -> a,a -> String)
03:42:53 <ski> baz False = ("baz",reverse,id)
03:43:05 <ski> baz True  = (0,succ,show)
03:43:50 <opqdonut> err how is ("baz",reverse,id) :: a,a -> a,a -> String?
03:43:54 <opqdonut> or am i missing something
03:44:57 <ski> in the first case, 'a' is 'String', and '"baz" :: String','reverse :: String -> String','id :: String -> String', so indeed then '("baz",reverse,id) :: (a,a -> a,a -> String)'
03:45:26 <ski> in the second case, 'a' e.g. is 'Integer'
03:46:09 <opqdonut> ah, -> binds tighter
03:46:22 * ski nods
03:46:46 <ski> now
03:47:50 <kolmodin> sjanssen: is http://www.haskell.org/mailman/listinfo/xmonad the official xmonad mailing list?
03:47:52 <lambdabot> Title: Xmonad Info Page
03:48:03 <ski> test_baz0 = s (f (f x ++ "!"))
03:48:07 <ski>   where
03:48:08 <ski>   (x,f,s) = baz False
03:48:10 <ski> is bad
03:48:14 <scriptdevil> what do we use for printing lines without \n after the end of each?
03:49:26 <mauke> putStr
03:49:34 <mauke> and they're called strings, not lines
03:49:45 <kolmodin> dons: ^^
03:49:45 <ski> since, even though 'x' is actually a string in that case, the consumer of the existential result is not allowed to assume anything .. effectively, we've thrown away the right to use the fact that it is a string (it could have been an integer) .. we can only massage 'x' by 'f' and 's' .. so it is an abstract data type (ADT), in a sense
03:50:20 <ski> otoh
03:50:44 <ski> test_baz1 b = s (f (f x))
03:50:46 <ski>   where
03:50:51 <ski>   (x,f,s) = baz b
03:50:53 <ski> is ok
03:51:40 <ski> now, we can write 'baz' and 'test_baz1' in haskell, but with clunkier syntax, using "existential datatypes", like
03:51:40 <foxy-om> ski: How do I use the unwrapped SomeDigits?  (I have a list of ints and I want to convert it to an HList of Digits) foo :: Digits ds => [Int] -> HList ds
03:52:12 <ski> data Baz = forall a. MkBaz a (a -> a) (a -> String)
03:52:20 <ski> baz :: Bool -> Baz
03:52:36 <ski> baz False = MkBaz "baz" reverse id
03:52:45 <ski> baz True  = MkBaz 0 succ show
03:53:04 <ski> test_baz1 b = s (f (f x))
03:53:09 <ski>   where
03:53:23 <foxy-om> ski: I keep getting: "Inferred type is less polymorphic than expected"
03:53:27 <ski>   MkBaz x f s = baz b
03:53:51 <ski> (actually i don't recall if one can match like that in a 'where' .. otherwise patternmatching in 'case' works)
03:54:05 <ski> DRMacIver : does this clarify somewhat ?
03:55:14 <DRMacIver> Just rereading it now. I didn't quite get it hte first time through...
03:55:47 <ski> foxy-om : as before, 'foo :: Digits ds => [Int] -> HList ds' promises that this will work for any choice of 'ds' (in the 'Digits' class) the caller wants .. but that's not what you're trying to do, you want to decide yourself, (depending on input, presumably) what type 'ds' should be
03:56:06 <ski> foxy-om : so, you need to wrap or CPSify again .. :/
03:56:30 <DRMacIver> So the basic idea is that it returns things with type parameters that it can bind independently for any possible return.
03:56:44 <foxy-om> arg, ok I have to go back to CPSifying because the whole point is to expose the digits for static type-checking of array bounds
03:56:53 <ski> ('data SomeHList = forall ds. Digits ds => SHL (HList ds)' .. yes this is tedious)
03:57:08 <DRMacIver> Thus you can only use it in cases where you handle any possible values for that type parameter.
03:57:15 <DRMacIver> Right?
03:57:19 <ski> DRMacIver : yes .. in a sense, the types here are output, and not input
03:57:23 <DRMacIver> Right
03:57:40 <ski> btw 'MkBaz' is typed as
03:57:58 <ski> MkBaz :: forall a. a -> (a -> a) -> (a -> String) -> Baz
03:58:21 <ski> (which may explain why the 'forall' keyword was used in the datatype declaration)
03:58:43 <ski> basically, that type signature is roughly the same as
03:58:55 <ski> MkBaz :: forall a. (a,a -> a,a -> String) -> Baz
03:59:06 <ski> which is roughly the same as
03:59:15 <ski> MkBaz :: (exists a. (a,a -> a,a -> String)) -> Baz
03:59:45 <ski> one can also declare an equivalent 'Baz' type, using GADT syntax instead, like
03:59:50 <ski> data Baz :: *
03:59:52 <ski>   where
04:00:00 <ski>   MkBaz :: a -> (a -> a) -> (a -> String) -> Baz
04:02:52 <ski> (there are some parallels with existential types like 'Baz' and class types in "object-oriented" systems .. the 'a' argument of 'MkBaz' would correspond to the hidden internal state, and the other arguments correspond to methods)
04:03:35 <DRMacIver> ok. Thanks.
04:03:43 <ski> yw
04:06:23 <ski> (one of the uses of existential types is precisely to get "heterogenous collections", like '[SomeWidget]' / '[exists a. Widget a *> a]' (it is essential that the quantifier is inside the type constructor, otherwise we can't put things of different types, all implementing the 'Widget' interface into the collection))
04:08:46 <dons> kolmodin: yes!
04:09:06 <dons> kolmodin: but I've not turned it on yet (thought it might be accidentally already on ;)
04:09:16 <dons> i'll ping you later today when i check it all out
04:09:30 <kolmodin> dons: ok, cool
04:12:37 <foxy-om> ski, are you familier with HList?
04:18:39 <foxy-om> ski, I keep getting "inferred type is less polymorphic than expected" when I try to make HLists of my (Digits ds)
04:19:12 <ski> hum, nope, haven't used 'HList'
04:19:44 <ski> have you made an 'SomeHList' (maybe better name ?) ?
04:20:58 <hpaste>  foxy-om pasted "HList stuff" at http://hpaste.org/1328
04:21:32 <foxy-om> ski, I can't wrap HLists because I want the typechecker to make sure that array indices aren't out of bounds (that's why I'm converting Ints to the type level)
04:23:30 <ski> in what code do you want this to be checked ?
04:25:38 <foxy-om> ski, haven't written it yet :)  But basically for e.g. matrix addition I'll have: add :: Eq size1 size2 => (Array size1 Double) -> (Array size2 Double) -> Array size1 Double
04:25:59 <foxy-om> where size1, size2 are HLists of Digits
04:26:50 <foxy-om> Olegs examples key in the digits by hand, but I'm getting the dimensions as a list of ints from an ffi call
04:27:27 <beelsebob_> why am I getting a file does not exist error using WriteFile?
04:27:52 <mauke> beelsebob_: what's the exact error?
04:27:53 <ski> hm, i don't think you need existentials for 'add' ..
04:28:03 <beelsebob_> *** Exception: ~/Desktop/test.pdf: openFile: does not exist (No such file or directory)
04:28:15 <mauke> beelsebob_: the directory ~ does not exist
04:28:20 <beelsebob_> o.O
04:28:22 <beelsebob_> why not?
04:28:27 <Syzygy-> beelsebob_: You might need some sort of pattern expansion
04:28:34 <mauke> because you don't have a file called '~' in your current directory
04:28:40 <mauke> s/file/directory/
04:28:46 <foxy-om> beelsebob_: ~ is expanded by the _shell_
04:28:57 <beelsebob_> true dat
04:29:04 <beelsebob_> why does it not go through the shell though
04:29:13 <beelsebob_> @hoogle FilePath -> FilePath
04:29:14 <lambdabot> Distribution.Compat.FilePath.dropAbsolutePrefix :: FilePath -> FilePath
04:29:14 <lambdabot> Distribution.Compat.FilePath.changeFileExt :: FilePath -> String -> FilePath
04:29:14 <lambdabot> Distribution.Compat.FilePath.dropPrefix :: FilePath -> FilePath -> FilePath
04:29:27 <mauke> @hoogle FilePath -> IO FilePath
04:29:28 <lambdabot> System.Directory.canonicalizePath :: FilePath -> IO FilePath
04:31:57 <foxy-om> ski: num2typelevelrepresentation :: HList l => [Int] -> l, where each Int is converted to Digits, that way I have a heterogeneous list of a type level representation of a number, and that way I can get the type checker to statically ensure that arrays are of the correct size...
04:34:37 <ski> hm .. i dunno about 'HList' .. but i still think you want an existential somewhere in that type signature
04:37:59 <yiwin> @where wiki
04:38:00 <lambdabot> I know nothing about wiki.
04:38:34 <vincenz> @wiki
04:38:35 <lambdabot> http://www.haskell.org/haskellwiki/
04:44:37 <dons> ?where+ wiki http://www.haskell.org/haskellwiki/
04:44:38 <lambdabot> Done.
04:46:29 <earthy> hm. coding haskell without the api docs and without hoogle is somewhat annoying ;)
04:46:37 <KEAL> @keal
04:46:38 <lambdabot> primary elemental assumption of integer coefficients to roots in counting sytem is wrong
04:46:43 --- mode: ChanServ set +o xerox
04:46:47 <KEAL> :O
04:52:02 <KEAL> i need help writing kealdigit for mbot :D
04:52:26 <KEAL> using ghc :P
04:54:09 <Syzygy-> kealdigit?
04:54:14 <KEAL> yes ^-^
04:54:29 <KEAL> its part of the @keal deal
04:54:36 <KEAL> its missing :P
04:55:04 <KEAL> it goes @keal digit value base power etcetera
04:55:13 <KEAL> :)
04:55:43 <KEAL> just google pentapulse you will find it :P
04:57:19 <mauke> @keal
04:57:20 <lambdabot> i just got banned from math because i not have good ability to convey thoughts
05:00:06 <KEAL> :P
05:00:15 --- mode: ChanServ set +o dons
05:00:22 --- mode: dons set +b *!*n=KEAL@unaffiliated/Keal
05:00:22 --- kick: KEAL was kicked by dons (dons)
05:00:23 <dons> ah well
05:00:27 --- mode: ChanServ set -o dons
05:00:45 <beelsebob_> o.O
05:00:49 <beelsebob_> what the hell was that all about?
05:01:04 <dons> @keal this guy
05:01:05 <lambdabot> i think i know what code does but code looks to simple to actually do it
05:01:05 <vincenz> you got to 'kill keal'
05:37:33 <joelr1> good morning
05:38:02 <Botje> hello!
05:40:17 <joelr1> does anyone know how happy reports error locations?
05:41:00 <Botje> not me
05:51:49 <LoganCapaldo> What is this "Happy" nonsense? combinators are obviously vastly superior :)
05:52:50 <vincenz> joelr1: define 'error locations'
05:52:55 <vincenz> joelr1: you have to build that yourself
05:53:05 <joelr1> combinators suck for me at the moment
05:53:09 <vincenz> joelr1: I have a tight integration between my alex and happy system with a customised monad that keeps track of input loc
05:53:31 <joelr1> vincenz: you have an alex and happy system?
05:53:33 <vincenz> joelr1: thereby every single one of my tokens is located
05:54:04 <vincenz> joelr1: yes?
05:54:26 <joelr1> vincenz: have you used parsec?
05:54:29 <ndm> Igloo: when upgrading to GHC 6.6.1, does that require re-installing all packages?
05:54:54 <vincenz> joelr1: no I prefer rolling happy-alex parsers
05:54:59 <vincenz> joelr1: welll I have, but for small things
05:55:36 <joelr1> vincenz: i'm trying to figure out whether to scrap my parsec-based parser in favor of alex+happy or adding type checking on top of parsec. the latter requires locating tokens
05:55:55 <junyer> hi and stuff
05:56:06 <junyer> total n00b question..
05:56:07 <vincenz> joelr1: "or adding type checking on top of parsec"?
05:56:34 <junyer> but i can't really find an "endorsed" module for arbitrary-precision floats
05:56:45 <junyer> from what i've seen, using gmp isn't the way
05:56:48 <joelr1> vincenz: imaging adding two expressions (+) in a language where num + num :: num and str + num :: str
05:57:01 <junyer> so i was wondering if there's any existing module that just scales Integers or something
05:57:20 <der_igel> junyer: did you try Data.Ratio?
05:57:21 <junyer> (to save me having to write bignum stuff of my own)
05:57:22 <joelr1> vincenz: there can't be num + str, for example, which is easy to ensure with a yacc-based parser since you just err on any num + str
05:57:37 <vincenz> joelr1: erm
05:57:43 <vincenz> joelr1: imho, you should always TC post parse
05:57:58 <vincenz> joelr1: or you'll restrict what your AST can handle severely
05:58:01 <LoganCapaldo> joelr1: doesn't that require infinite lookahead and state during the parse phase?
05:58:16 <vincenz> the approach of different phrase types puts the typing directly in the AST definition which doesn't scale if you go to more types
05:58:18 <LoganCapaldo> let num = 8 .... sveral lines later ..  num + str
05:58:24 <junyer> der_igel - i've looked at it briefly
05:58:37 <junyer> i'll take a closer look
05:58:55 <junyer> thanks
05:58:57 <LoganCapaldo> Unless your definition of "easy" is different than mine <g>
05:59:03 <der_igel> np junyer :)
05:59:09 <der_igel> let me know if it worked out :)
05:59:13 <joelr1> LoganCapaldo: no, it requires lexer and parser integration. when the parser encounters let num = 8 it marks num as int. next time the lexer encounters num it checks the symtab and returns a different token
05:59:38 <joelr1> vincenz: yeah, i'm with you. just trying to figure out how to embed token location with parsec
06:00:10 <LoganCapaldo> Ok so not inifinte lookahead
06:00:18 <LoganCapaldo> (but obviously state)
06:00:51 <vincenz> joelr1: oh that's rather easy, what you do is, make your own monad, make alex and happy use this monad, and make your lexer advance your location each time
06:00:52 <der_igel> > 4%3 + 5%4
06:00:54 <lambdabot>  31%12
06:01:15 <vincenz> joelr1: some sort of state monad
06:01:25 <joelr1> vincenz: except i'm using parsec :D
06:01:36 <vincenz> ...
06:01:39 <vincenz> oh
06:01:41 <vincenz> parsec
06:02:40 <vincenz> joelr1: sorry no, I wrongly inferred you had switched away from parsc
06:02:47 <Saizan> you can have a user defined state in parsec
06:02:57 <Saizan> ?hoogle runParser
06:02:58 <lambdabot> Text.ParserCombinators.Parsec.Prim.runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
06:03:08 <Saizan>     st ^
06:03:13 <joelr1> vincenz: not yet, i considered it for a minute
06:03:30 <junyer> der_igel - i think Rational would be just fine!
06:03:34 <joelr1> Saizan: i _do_ have state in my parser. i use it to keep a symbol table. that's not the question.
06:03:41 <junyer> now if it was an instance of RealFloat, i'd be set :P
06:03:53 <joelr1> Saizan: the question is how to grab the token location and save it in the ast for the type-checking pass on top of said ast
06:03:56 <junyer> (i'm lazy and would like to plug it into Complex..)
06:04:10 <junyer> but i can expand the re/im stuff myself anyway
06:04:40 <der_igel> well a fraction is not a real number
06:04:44 <der_igel> mathematically speaking
06:04:44 <junyer> nod
06:06:04 <dying_sphynx> fraction IS real number, bot not every real number is fraction :)
06:06:05 <der_igel> i mean the other way around: a real number cannot always be a fraction^^
06:07:05 <junyer> oh, right
06:07:16 <balodja> hi! are there any utils in ghc distribution that dump information from interface files(*.hi)?
06:08:33 <junyer> hmm
06:08:34 <junyer> sweet
06:08:37 <junyer> thanks again
06:11:00 <fasta> Do you use identifers that are named like: fizzle_with_foobar_such_that_property_mumble_holds (with all the names substituted by usefull names)?
06:11:28 <joelr1> fasta: no, i prefer camel casing
06:11:45 <chessguy> 'morning haskellers
06:11:45 <fasta> joelr1: I wasn't talking about the naming style
06:11:55 <fasta> joelr1: I meant _long_ identifiers.
06:12:07 <mattam> nope, as short as possible
06:12:26 <mattam> but that's one of the hardest problems in programming :)
06:12:33 <fasta> My experience is that my programs are hard to understand without long names.
06:12:56 <fasta> OTOH, my programs are usually quite complicated, because of the nature of the programs.
06:13:11 <joelr1> fasta: take a look at any objective c / cocoa code and rejoice. their identifiers are looooooooonger
06:13:26 <mattam> or Java for that matter
06:13:33 <joelr1> fasta: use long names, programs are read far more often than written. including by you months later
06:13:42 <fasta> joelr1: a good environment can make up for that
06:13:55 <fasta> joelr1: yeah, that's basically how I think about it.
06:14:46 --- mode: ChanServ set +o vincenz
06:14:54 <dylan> I use long function names and short (one letter, often) variable names
06:14:55 <mattam> i'd say try to stay short, 30 characters names are usually overkill
06:15:05 <dylan> or pointfree, when that's more readable.
06:15:47 <DRMacIver> I'm torn on the length of variable names.
06:15:57 <DRMacIver> I hate writing long ones (even with autocomplete) but hate reading short ones. :)
06:16:08 <dylan> haskell's standard library or whatnot has long names.
06:16:13 <dylan> getDirectoryContents, etc.
06:16:36 <fasta> dylan: Lisp, SmallTalk and anything derived from it does that
06:16:47 <dylan> yeah, I know. :)
06:16:56 <dylan> I like x, y, z, a, b, m, n for variable names.
06:17:01 <DRMacIver> dylan: Oh, I always use long names for top level definitions.
06:17:10 <vincenz> dylan: and variables with lots of '''
06:17:11 <dylan> one place I almost worked, though, took the hungarian notation to extremes...
06:17:15 <fasta> dylan: I like it, especially since I can guess what names they use pretty well now :)
06:17:17 <dylan> "all classes must begin with cls"
06:17:32 <merus> Hungarian notation annoys me.
06:17:35 <vincenz> dylan: and typedefs start with td?
06:17:40 <dylan> vincenz: yes
06:17:43 <vincenz> typedef tdInt = int
06:17:43 <vincenz> :P
06:17:44 <dylan> and enums with enm
06:17:56 <dylan> and signed 32bit integers with s32
06:18:25 <dylan> so, instead of for (i = 0..., write for (s32Counter = 0....
06:18:32 <mattam> As if their wasn't enough type information written by the programmers in this languages...
06:19:08 <LoganCapaldo> and just when you learn to ntuen out the notation is when some other coder starts realizing that now ints and strings are in different "namespaces" and uises the same name for an int var and a string var... :)
06:20:19 <DRMacIver> Shadowing is great and should be used at the slightest provocation. :)
06:20:43 <DRMacIver> Although I guess that's not really shadowing
06:25:08 <pejo> dylan, and they considered s32counter to be more readable than i?
06:25:43 <chessguy> why not s32i
06:25:55 <fasta> Some languages give meaning to 'i', 'n' and 'x'
06:26:17 <chessguy> fasta: what languages?
06:26:54 <fasta> chessguy: when you program in Stratego and use certain identifiers, you need less disambiguation.
06:27:10 <fasta> chessguy: (this is programmable)
06:28:12 <mux> chessguy: hello
06:28:14 <fasta> chessguy: the i denotes e.g. Integer(i) in the object language, IIRC.
06:28:24 <chessguy> mux: good morning!
06:28:48 <mux> chessguy: I saw you had been looking for me?
06:28:59 <chessguy> oh, i just wondered how your interface was going
06:29:32 <mux> I didn't do as much as I wanted, but I can now fully open/parse PGN files and initialize the combobox with the moves :)
06:29:35 <mux> which is admittedly not much
06:29:45 <chessguy> hey, that's a start
06:30:10 <chessguy> did you use parsec for the PGN?
06:30:22 <mux> as soon as I write a SANMove -> Move function to disambiguate SAN, I should be able to scroll through the moves
06:30:38 <mux> yes, I use parsec for PGN and SAN
06:30:41 <mux> soon for FEN too ;-)
06:30:46 <chessguy> sweet
06:31:09 <mux> I've been adding a Parsable type-class which turned out to be quite useful
06:31:16 <chessguy> oh?
06:31:38 <chessguy> what operations are in that class?
06:32:08 <mux> just the parser, let me show you
06:32:22 <hpaste>  mux pasted "Data.Parsable" at http://hpaste.org/1329
06:32:29 <mux> here
06:33:07 <mux> this saves me the export of one function per datatype, eg SAN type and sanParser, PGN type and pgnParser, etc..
06:33:10 <mux> it was getting boring
06:33:28 <vincenz> mux: nice idea :)
06:33:55 <mux> vincenz: and it allows me to write cryptic Parsec parsers heh :D
06:34:02 <chessguy> that is cool
06:34:08 <mux> since I often just use "parser" now which depends on the type context
06:34:25 <mux> eg:
06:34:26 <mux> instance Parsable Square where parser = liftM2 Square parser parser
06:34:28 <vincenz> hehe, yes, that is evil
06:34:37 <vincenz> but damn useful
06:34:38 <fasta> The problem with Haskell's type class system is that when you use it 50 years you get types of the form <three pages of output>
06:34:53 <chessguy> it's not evil, it's exactly what type classes are for
06:35:49 <vincenz> mux: one VERY nice thing from this is that as soon as you change your AST, your parser changes automatically
06:36:03 <dino-> I have a group of three IO Maybe actions. I want to try them in a sequence and evaluate the whole thing to the first non-Nothing one, discarding the rest.
06:36:17 <chessguy> dino-: fmap
06:36:22 <DRMacIver> It's a trivial thing, but I still find it really cool that you can have type classes where the type parameter only appears in the return type. :)
06:36:34 <chessguy> i think
06:36:54 <mux> vincenz: yup
06:38:30 <mux> if the Read classs was using Parsec or some other decent parser code, I could have avoided it though
06:38:40 <Saizan> ?type foldM mplus
06:38:43 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
06:38:43 <lambdabot>       Expected type: m a -> m a -> m (m a)
06:38:46 <mux> oooh, ShowS is a monoid, hmmm.
06:39:16 <sjanssen> mux: it's probably the same as the usual (a -> b) monoid
06:39:30 <mux> right
06:39:33 <dino-> hm
06:39:37 <sjanssen> dino-: what happens if all of them evaluate to Nothing?
06:39:44 <dino-> sjanssen: Then I want the Nothing
06:39:48 <dino-> as the result
06:39:53 <chessguy> oh, i think mplus is what i was thinking of
06:40:23 <dino-> But any non-Nothing will "short circuit" the whole thing and eval to that Just value.
06:41:06 <chessguy> > foldr mplus Nothing [Nothing, Maybe 1, Nothing, Maybe 2]
06:41:07 <lambdabot>   Not in scope: data constructor `Maybe'
06:41:09 * mux wonders if using the Writer monad just for writing a showsPrec function isn't a bit heavyweight
06:41:22 <sjanssen> dino-: this is a bit hackish, but will work: (do Just x <- action1; return (Just x)) `mplus` (do Just x <- action2; return (Just x)) `mplus` ... `mplus` return Nothing
06:41:55 <dino-> sjanssen: I see. Nesting the do blocks?
06:41:58 <dino-> kind of
06:42:07 <sjanssen> dino-: no, actually composing them with mplus
06:42:10 <chessguy> @type [Nothing]
06:42:12 <dino-> ah
06:42:13 <lambdabot> forall a. [Maybe a]
06:42:22 <chessguy> @type [Maybe 4]
06:42:25 <lambdabot> Not in scope: data constructor `Maybe'
06:42:34 <chessguy> what the heck
06:42:36 <sjanssen> mplus for IO takes the first argument that doesn't yield an exception
06:42:49 <chessguy> oh, duh
06:42:51 <sjanssen> chessguy: Maybe isn't a data constructor
06:43:07 <chessguy> > foldr mplus Nothing [Nothing, Just 1, Nothing, Just 2]
06:43:08 <lambdabot>  Just 1
06:44:22 <Saizan> chessguy: yeah but if you have [IO (Maybe a)] to get IO [Maybe a] you use sequence, and that will evaluate everything without shortcutting
06:44:28 <vincenz> @type foldM
06:44:31 <roconnor> > foldr mplus mzero [mzero, return1, mzero, return 2]
06:44:32 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
06:44:32 <Saizan> unsafeInterleaveIO ?
06:44:33 <lambdabot>   Not in scope: `return1'
06:44:40 <roconnor> > foldr mplus mzero [mzero, return 1, mzero, return 2]
06:44:41 <lambdabot>   add an instance declaration for (Show (m a))
06:44:50 <roconnor> > foldr mplus mzero [mzero, return 1, mzero, return 2] :: Maybe Int
06:44:52 <lambdabot>  Just 1
06:44:58 <roconnor> > foldr mplus mzero [mzero, return 1, mzero, return 2] :: [Int]
06:45:00 <lambdabot>  [1,2]
06:45:03 <sjanssen> @hpaste
06:45:04 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:45:13 <roconnor> @instances MonadPlus
06:45:15 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
06:45:28 <roconnor> > foldr mplus mzero [mzero, return 1, mzero, return 2] :: Either String Int
06:45:30 <lambdabot>  Right 1
06:45:33 <hpaste>  sjanssen pasted "firstSuccess :: Monad m => [m (Maybe a)] -> m (Maybe a)" at http://hpaste.org/1330
06:45:48 <roconnor> > foldr mplus mzero [mzero, return 1, mzero, return 2] :: IO Int
06:45:50 <lambdabot>  <IO Int>
06:45:52 <Syzygy-> > mplus (Just 2) (Just 3)
06:45:54 <lambdabot>  Just 2
06:45:55 <dino-> oo, this is good stuff. Thank you guys!
06:45:58 <sjanssen> dino-: the mplus solution is probably too hackish, I'd do it that way ^^^
06:45:59 <Syzygy-> o.O
06:46:07 <Syzygy-> > mplus [2] [3,4,5]
06:46:09 <lambdabot>  [2,3,4,5]
06:46:12 <roconnor> @hoogle msum
06:46:13 <Syzygy-> Ah.
06:46:13 <lambdabot> Monad.msum :: MonadPlus a => [a b] -> a b
06:46:13 <lambdabot> Control.Monad.msum :: MonadPlus m => [m a] -> m a
06:46:16 <dino-> The fold? yeah
06:46:17 <mux> can we typically observe significant performance differences between some bit of code written with, say, the State monad, and the equivalent code passing the state around by hand?
06:46:26 <roconnor> > msum [mzero, return 1, mzero, return 2] :: Either String Int
06:46:30 <lambdabot>  Right 1
06:46:39 <chessguy> hmm, again the need to short-circuit a fold. i keep seeing that lately
06:46:59 <roconnor> @src msum
06:47:00 <lambdabot> msum =  foldr mplus mzero
06:47:00 <Syzygy-> > msum [mzero, return "ab", mzero, return 2] :: Either String Int
06:47:01 <lambdabot>  Couldn't match expected type `Int' against inferred type `[Char]'
06:47:23 <roconnor> > msum [mzero, fail "ab", mzero, return 2] :: Either String Int
06:47:25 <lambdabot>  Right 2
06:47:33 <sjanssen> mux: I've seen cases where manually unwrapping several monad transformers produces better performance (notably the monads in binary)
06:48:10 <mux> bah :)
06:48:23 <mux> I want cheap monads ;-)
06:49:10 <sjanssen> for a simple State, I'd expect the same performance compared to hand written code
06:49:32 <roconnor> ghc is both awsome and sucky
06:50:37 <sjanssen> mux: note that binary continued using monads -- they just eliminated the overhead of several monad transformers
06:50:48 <mux> ok
06:51:09 <sjanssen> the stack was kinda complicated, ContT StateT IO, or something
06:51:16 <dino-> roconnor: Fantastic, the tersest so far.
06:51:36 <mux> I'm asking because sometimes things are written in a much easier/elegant way using a state monad, even if for just having 'when'
06:51:44 <sjanssen> roconnor's won't scale up to IO (Maybe a)
06:52:23 * roconnor worries about the effiecency of the writer monad for lists.
06:52:59 <roconnor> maybe it is as effiecent as it can be
06:53:18 <Saizan> mmh no
06:53:22 <roconnor> maybe one needs to use the endo writer to get the ShowS trick.
06:53:31 <roconnor> @instances Writer
06:53:33 <lambdabot> Couldn't find class `Writer'. Try @instances-importing
06:53:40 <roconnor> @instances MonadWriter
06:53:42 <lambdabot> w (ErrorT e m), w (RWS r w s), w (RWST r w s m), w (ReaderT r m), w (StateT s m), w (Writer w), w (WriterT w m)
06:53:47 <roconnor> @instances Monoid
06:53:49 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
06:54:16 <roconnor> @src Ordering Monoid
06:54:17 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
06:54:25 <roconnor> @src Monoid Ordering
06:54:26 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
06:54:39 <Saizan> @src Ordering mappend
06:54:40 <lambdabot> Source not found. I feel much better now.
06:55:30 <dino-> I see. I'll mess around with it with what you've all said here. Thank you.
07:03:38 <joelr1> @pl f a = f1 a b
07:03:38 <lambdabot> f = flip f1 b
07:13:52 <Igloo> ndm: Upgrading to 6.6.1 will require rebuilding all packages, yes
07:14:10 <ndm> Igloo: plus, shall i release filepath-1.0 now, or after ghc 6.6.1?
07:15:20 <Igloo> ndm: I'd release it now as it seems to be confusing people. At worst we'll end up releasing 1.1 with GHC
07:15:31 <Igloo> ndm: Are the 6.6 branch and HEAD repos identical?
07:15:44 <ndm> Igloo: there is a 6.6 branch?
07:15:58 <ndm> Igloo: Ross changed the name from FilePath to filepath, thats a patch that definately wants picking up!
07:16:19 <ndm> Igloo: ideally you should pick up all of the patches
07:17:10 <shapr> Wow, two ops at once.. has there been spam?
07:18:02 <ndm> shapr: keal
07:18:10 <shapr> ouch
07:18:20 <glguy> Igloo's been opped a lot lately, I didn't notice xerox was (until now)
07:18:48 <Igloo> We've had 3 or 4 trouble makers in the last few days
07:19:13 <shapr> sucks
07:19:19 <sjanssen> @keal
07:19:20 <lambdabot> today's 24hour project was supposed to be logical overloading using plegm method
07:19:31 <shapr> ooh, new keal quotes?
07:19:55 <shapr> I thought keal was a markov chained bot at first.
07:20:00 <sjanssen> @keal
07:20:01 <lambdabot> 99% of my book has been erased by faulty hdd's
07:20:09 <sjanssen> I love that one
07:20:21 <shapr> foo, bringert is offline
07:21:09 <shapr> @tell bringert I'm in stockholm till the 17th, think we can meet up?
07:21:10 <lambdabot> Consider it noted.
07:21:25 <joelr1> @pl f a = f1 a b c
07:21:26 <lambdabot> f = flip (flip f1 b) c
07:22:32 <Igloo> ndm: OK, they're now synced
07:22:36 <joelr1> @pl f a = f1 a b c d
07:22:37 <lambdabot> f = flip (flip (flip f1 b) c) d
07:22:39 <ndm> Igloo: cheers
07:29:54 <Vq^> i notice that Network.Socket.SockAddr doesn't have an Ord instance, is there some good reason why it isn't?
07:30:27 <Vq^> i was planning to use it as a Data.Map key...
07:31:47 <nelhage> I'd assume it doesn't have one because it's not obvious what it would mean to compare SockAddrs in the general case...
07:32:19 <Saizan> ?docs Network.Socket
07:32:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network-Socket.html
07:32:28 * Igloo doesn't have the network source handy, but I doubt there's a good reason. Why not propose a patch?
07:33:26 <Vq^> Igloo: it's just a simple ADT with members which have Ord instances
07:33:55 <Saizan> so we can infer the instance with derive and paste it back in the code :)
07:34:02 <bos> well, how should a SockAddrInet compare against a SockAddrUnix?
07:34:43 <norpan> False
07:34:47 <Igloo> bos: It doesn't matter for use as a Data.Map key, as long as it's well-defined
07:35:05 <bos> so always sort as less-than, or so
07:35:19 <Igloo> Always do whatever deriving Ord does  :-)
07:35:20 --- mode: ChanServ set +o vincenz
07:35:27 <bos> :-)
07:35:58 <Vq^> i doubt there is any other use of comparing SockAddrInet and SockAddrUnix, but i might be wrong
07:36:08 <glguy> vincenz: martial law?
07:36:40 <vincenz> glguy: nah :)\
07:37:25 * glguy announces the curfew
07:38:18 <roconnor> \join haskell-blah
07:38:21 <roconnor> er
07:38:35 <roconnor> stupid slash
07:38:50 <Vq^> :)
07:39:58 <Saizan> ?paste
07:39:59 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:41:37 * sjanssen starts a resistance movement to oppose glguy's totalitarian government
07:42:51 <hpaste> sjanssen: please report to the office of the censor for immediate reward
07:44:08 <hpaste>  Saizan pasted "derive-d Ord instance" at http://hpaste.org/1331
07:44:25 <Saizan> that's cheating IMO ^^^
07:45:08 <lambdabot> hpaste: you're such a tool
07:45:09 <roconnor> @type censor
07:45:11 <lambdabot> forall w (m :: * -> *) a. (MonadWriter w m) => (w -> w) -> m a -> m a
07:45:50 <sjanssen> Saizan: why is that cheating?
07:46:39 <balodja> @src intersperse
07:46:40 <lambdabot> intersperse _   []     = []
07:46:40 <lambdabot> intersperse _   [x]    = [x]
07:46:40 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
07:47:07 <sjanssen> glguy: I just accidentally used @tell on hpaste ...
07:47:37 <kolmodin> it sure looks like cheating :)
07:48:11 <glguy> sjanssen: I dont' see it yet, I'll have to scroll back more :)
07:49:08 <sjanssen> glguy: I used lambdabot's @tell command -- so we're going to get annoying messages from lambdabot every time there's a new paste
07:49:23 <glguy> :lambdabot!n=lambdabo@manzano.cse.unsw.EDU.AU PRIVMSG #haskell :hpaste: you're such a tool
07:49:27 <glguy> found it
07:49:52 <glguy> OHH
07:49:56 <glguy>  @tell and @messages
07:50:15 <hpaste>  sjanssen annotated "firstSuccess :: Monad m => [m (Maybe a)] -> m (Maybe a)" with "tell fodder" at http://hpaste.org/1330#a1
07:50:15 <lambdabot> hpaste: You have 1 new message. '/msg lambdabot @messages' to read it.
07:50:37 <Igloo> ndm: Do you have gzip installed?
07:50:38 <glguy> !say @messages
07:50:38 <hpaste> @messages
07:50:40 <lambdabot> sjanssen said 6m ago: you're such a tool
07:51:12 <chessguy_work> you guys have way too much time on your hands when  you start insulting the bots :)
07:51:53 <lambdabot> Don't drag me into this!
07:52:07 <Igloo> ndm: and is tar GNU tar?
07:52:24 <chessguy_work> @load lambdabot
07:52:25 <lambdabot> Plugin `dummy' failed with: IRCRaised Prelude.read: no parse
07:52:48 <hpaste>  @pl \x y -> x y annotated "firstSuccess :: Monad m => [m (Maybe a)] -> m (Maybe a)" with "wonder if this works" at http://hpaste.org/1330#a2
07:53:04 <chessguy_work> haha
07:53:18 <sjanssen> ah, clever space padding
07:53:20 <glguy> I add a space to any non-admin generated message
07:57:26 <jcreigh> sjanssen: hmm? what was the 'phantom windows' bug?
07:57:56 <cpfr> hey therp
07:58:09 <cpfr> you around?
07:58:19 <sjanssen> jcreigh: if you're reading the scroll back, see my very next message
07:58:22 <therp> cpfr: yes
07:58:41 <cpfr> are you still active with cl-gardeners?
07:58:55 <therp> cpfr: no, any reason you're asking?
07:59:04 <cpfr> me and another user want to get ops
07:59:06 <jcreigh> sjanssen: oh, okay. (/me was just looking at my awaylog)
07:59:10 <therp> ah alright
07:59:12 <cpfr> and make the channel more lively
08:00:03 <sjanssen> jcreigh: create several windows on a workspace, switch to another empty workspace, switch back to the initial workspace.  For some reason, the windows aren't moved back into the main view
08:01:27 <sjanssen> jcreigh: that happened because of some discrepancy between the StackSet and screen2ws, and your change silently fixed it
08:01:33 <jcreigh> cool.
08:02:20 <jcreigh> I need to look at the QC stuff more nothing...I think only single-screen StackSets are being tested. (because that's all fromList will make)
08:02:30 --- mode: ChanServ set +v glguy
08:02:35 <jcreigh> s/nothing/tonight/
08:02:46 <jcreigh> possibly my strangest typo yet.
08:03:21 <chessguy_work> almost an anagram
08:04:34 <glguy> who will join me as a +v in my bid to overthrow the +os?
08:05:44 <glguy> then I stand alone! :)
08:11:09 <Saizan> mmh i think i've found a bug in haskell-mode, if in *ghci* you type putStr "foo" so that the ghci prompt is printed on the same line as "foo" than switch in a buffer with a haskell file and type C-c C-l, my emacs just stop reponding to commands
08:12:18 --- mode: ChanServ set +o glguy
08:13:07 * glguy quietly assimilates :(
08:14:11 <Saizan> lure by the dark side of the force?
08:14:16 <Saizan> *lured
08:15:00 <glguy> they have *lightning bolts* that they shoot from their *hands*
08:15:16 <glguy> who would resist???
08:16:43 <Saizan> :D
08:16:55 <sjanssen> Mark Hamil.
08:17:02 <chessguy_work> not to mention the choking ability
08:17:07 <ndm> Igloo: i have gzip, tar is gnu-tar i think - how would i tell?
08:17:25 <glguy> tar --version?
08:17:50 <ndm> Igloo: definately gnu tar, perhaps not gnu gzip - that isn't explicit about it
08:18:02 * Igloo posts ndm a Debian CD
08:18:02 --- mode: glguy set -o glguy
08:18:26 <Igloo> (I have no idea what's wrong; comments in the source near the tar command imply that it worked for someone on Windows)
08:18:26 * ndm rejects it and hands Igloo a pirated copy of Visa
08:18:56 <ndm> (quietly noting that Igloo gets paid from Windows XP revenues)
08:19:04 <glguy> The year 2000 called and they want their Debian software back
08:19:14 <bringert> maybe we should ship htar with cabal?
08:19:15 <lambdabot> bringert: You have 1 new message. '/msg lambdabot @messages' to read it.
08:19:30 <sjanssen> chessguy_work: choking isn't necessarily a dark side power (witness Luke choking the Gamorrean in ROTJ)
08:19:55 <Igloo> Hmm, I should really get around to the last couple of tweaks to make my gzip package able to compress
08:20:31 <chessguy_work> sjanssen: oh good point
08:20:38 <bringert> Igloo: good plan. I should release the tar package and htar.
08:20:42 <glguy> maybe luke has a little dark side in him?
08:21:08 <Igloo> Although they'd then have to become core libs, or be copied into cabal
08:21:16 <bringert> anyone know what the best e-mail address for reaching shapr is?
08:21:27 <bringert> now that he is in sweden for a while
08:21:44 <ndm> glguy: inevitable, for number 7 he will go bad
08:21:55 <bringert> Igloo: maybe cabal could look for htar, just like it looks for for example cpphs
08:21:57 <bringert> hi SyntaxNinja
08:22:07 <earthy> bringert: I'd say use the same address you've always used
08:22:26 <bringert> it was a while since I e-mailed him, but ok :-)
08:22:37 <Igloo> Oh, I assumed htar was a library. Yes, that would work.
08:22:41 <SyntaxNinja> y0 bringert
08:23:02 <bringert> Igloo: tar is the library, htar is a program which uses it
08:23:12 <ndm> what doesn't tar do right?
08:23:22 <ndm> it fundamentally will tar things, i've used it myself
08:23:22 <bringert> ndm: which tar?
08:23:28 <ndm> bringert: my tar, on my system
08:23:38 <Igloo> ndm: From the error, it sounds like your tar won't compress
08:23:47 --- mode: ChanServ set +v hpaste
08:23:49 <bringert> yeah, it didn't seem to like the -z flag
08:23:55 <Igloo> You could just change it to call gzip afterwards, of course
08:23:59 <ndm> Igloo: but tar doesn't compress...
08:24:00 <SyntaxNinja> what's the cabal/tar issue?
08:24:06 * glguy enlists support
08:24:08 <Igloo> ndm: -z means compress with gzip
08:24:18 <bringert> SyntaxNinja: ndm has a funky tar that doesn't like the -z flag
08:24:24 <SyntaxNinja> man, everyone's got ops
08:24:36 <glguy> SyntaxNinja: I'm starting a counter revolution
08:24:37 <Igloo> I'm not sure if it compresses it itself or calls gzip to do it
08:24:37 <SyntaxNinja> ndm: here's a nickle get yourself a real OS ;)
08:24:39 <glguy> kind of a one man show
08:24:46 <SyntaxNinja> glguy: how's that?
08:24:55 <SyntaxNinja> glguy: Google Summer of Move to Galois? ;)
08:24:58 <Igloo> ndm: I already offered him a Debian CD, but he refused it  :-)
08:25:06 <Igloo> Gah, s/ndm/SyntaxNinja/
08:25:10 <bringert> yeah, what's with the ops? has there been a fight?
08:25:11 <glguy> SyntaxNinja: and it couldn't come too soon!
08:25:23 <glguy> bringert: it's martial law
08:25:23 <SyntaxNinja> ndm: sorry to make fun... so do you have gzip? or was someone saying that htar does the -z thing?
08:25:26 <glguy> a show of force!
08:25:28 <glguy> police state
08:25:28 <Igloo> bringert: Just lots of trolls etc in the past few days
08:25:33 <bringert> oh
08:25:53 <ndm> SyntaxNinja: i have gzip, just not tar -z it appears
08:26:00 <SyntaxNinja> glguy: what are you talking about? :)
08:26:00 <ndm> if you were to use winzip, that would suit me fine ;)
08:26:10 <glguy> SyntaxNinja: the ops are holding me down!
08:26:17 <SyntaxNinja> ndm: so then maybe cabal should just gall tar and gzip separatelky instead of using the convenient -z flag
08:26:26 <ndm> yes
08:26:41 <SyntaxNinja> glguy: we can start our own channel #haskell-noops, and you can be ops!
08:26:52 <glguy> SyntaxNinja: I can be ops here, that's no tthe point
08:26:54 <Saizan> or it could suggest to install msys :)
08:26:56 <pcc> It is my understanding that the -z option to tar is not POSIX
08:27:03 <bringert> ndm: just to be sure, what happens if you try to run tar -zcf foo.tar foo/?
08:27:10 <Igloo> pcc: Right, but he has GNU tar
08:27:55 <ndm> Igloo: --help on tar says it does have the -z option, i guess thats just broken on this system
08:28:19 <ndm> tar: Cannot use compressed or remote archives
08:28:21 <ndm> tar: Error is not recoverable: exiting now
08:28:30 <ndm> i have the -z option, but it doesn't work
08:28:49 <pcc> I'm looking for a good Haskell tutorial. I am very familiar with C/C++ and somewhat familiar with OCaml. I know a little bit about lambda calculus. Which of the various tutorials out there might be good for me?
08:29:47 <earthy> all :)
08:29:57 <SyntaxNinja> pcc: yet Another Haskell Tutorial is pretty good
08:30:01 <SyntaxNinja> @where yaht
08:30:01 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
08:30:16 <pcc> Okay, cool.
08:30:23 <bringert> ndm: funky. can you strace it or whatever the Windows equivalent is?
08:30:34 <earthy> yea, but I'd also try http://www.haskell.org/~pairwise/intro/intro.html
08:30:36 <lambdabot> Title: Haskell for C Programmers
08:30:37 <ndm> bringert: unlikely, i don't think there is an equivalent
08:30:49 <bringert> ndm: or just look at the source and see what triggers that error message
08:30:55 <fasta> pcc: reading a Scheme book would help too
08:31:05 <ndm> bringert: unlikely to help, i don't have the source, the website now 404's
08:31:48 <pcc> earthy: Actually I saw "Haskell for C Programmers" but it seems at the wrong level for me. I understand about immutable data and the lack of side effects, etc.
08:31:51 <bringert> oh, it's some special hacked-up Windows version of tar, not cygwin's?
08:31:57 <earthy> ah
08:32:07 <earthy> okay, then yaht is good indeed.
08:32:36 <pcc> Okay... playing with Sceme is also on my "to-do" list, but one thing at a time. :-)
08:32:36 <ndm> bringert: yet, its a native (non-mingw, non-cygwin) one, based on the GNU one
08:33:39 <Igloo> ndm: Is gzip somewhere that tar ought to be able to find it?
08:34:24 <ndm> Igloo: same directory
08:34:38 <ndm> plus on the path
08:35:13 * Igloo thinks we should both do tar and gzip separately, and have the tools look for htar
08:35:24 <Igloo> (and hgzip I guess)
08:35:37 <bringert> Igloo: htar uses the compression package
08:35:43 <bringert> to implement -z
08:35:50 <ndm> yes, tar and gzip separately makes sense
08:36:15 <Igloo> bringert: But the code will just be "run tar command; run gzip command". We don't really want to have it behave differently for htar if it isn't necessary
08:36:17 <bringert> but yeah, to make things simple, calling hgzip separately would make more sense
08:36:20 <bringert> yeah
08:38:43 <bringert> X is being weird, brb
08:38:53 <ndm> anyway, i have about 6 packages i want to release to hackage, and can't because of this...
08:46:50 <SyntaxNinja> ndm: because of zip? you could gzip them by hand :)
08:46:59 <ndm> SyntaxNinja: yay
08:47:14 <bringert> Igloo: where's the repo for the compression package again?
08:47:36 <mux> paq8l is a funny compression software
08:47:36 <bringert> cabal/hackage really needs a darcs-repo: field
08:47:51 <SyntaxNinja> bringert: I think it does now, doesn't it?
08:47:59 <bringert> oh?
08:48:26 <Igloo> bringert: http://urchin.earth.li/darcs/ian/inflate/
08:48:28 <lambdabot> Title: Index of /darcs/ian/inflate
08:49:00 <Igloo> I'm not convinced that's up-to-date, though
08:54:39 <bringert> Igloo: all I use now is the gunzip function
08:54:55 <bringert> having gzip too would of course rock
08:57:28 <ndm> kosmikus: i'm trying to do a TMR article, but its giving me errors about not having scrreprt installed
08:57:45 <Igloo> @paste
08:57:45 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:59:51 <bringert> SyntaxNinja: I can't seem to find anything about it the the cabal sources
09:02:09 <pcc> So I've started reading "Yet Another Haskell Tutorial." It seems pretty good. Thanks for the advice.
09:02:48 <dmwit> Cool!
09:03:47 <dmwit> I don't want focus-follows-mouse anymore.
09:03:50 <dmwit> I want focus-follows-eyes.
09:04:20 <pcc> That sounds very distracting
09:04:22 <thetallguy> No you don't
09:04:30 <dmwit> What?
09:04:34 <dmwit> How would it be distracting?
09:04:37 <thetallguy> Your eyes go all over the place
09:04:39 <kosmikus> ndm: scrreprt should be standard in most TeX distributions
09:04:44 <dmwit> So?
09:04:53 <pcc> If the focus moved every time I glanced at another window?
09:04:53 <ndm> kosmikus: not mine... MikTex
09:05:00 <thetallguy> You would lose characters when typing
09:05:03 <kosmikus> ndm: Windows ;)
09:05:06 <thetallguy> because you look away so much
09:05:08 <kb_> dmwit: given how you eyes saccade all over the place, it would be terrible, i think
09:05:17 <dmwit> pcc: I'm not on windows, so focusing a window doesn't mean it would also raise the window...
09:05:17 <kb_> your eyes, rather
09:05:25 <glguy> lol, I can't believe you guys are arguing over whether dmwit would like focus follows eyes
09:05:31 <thetallguy> Look for papers by Rob Jacobs
09:05:38 <kb_> glguy: why not? :)
09:05:39 <kosmikus> ndm: then you have to install it. it's part of koma-script
09:05:55 <ndm> kosmikus: almost everything installs easily, but not this...
09:05:59 <glguy> hm, I guess I do believe it
09:06:09 <glguy> but it's outrageous nonetheless!
09:06:10 <dmwit> Hmmm, I suppose it might be necessary to have a temporary "focus-lock" mechanism.
09:06:17 <thetallguy> Something
09:06:22 <thetallguy> it's not trivial
09:06:22 <kosmikus> ndm: why not?
09:06:26 <thetallguy> I dig the impulse
09:06:33 * bringert built eye-tracking hardware once
09:06:35 <ndm> kosmikus: no idea, the download keeps failing when done autmoatcally
09:06:43 <kb_> bringert: cool
09:06:44 <dmwit> bringert: Pretty expensive, huh?
09:06:51 <thetallguy> but people who've tried it find it difficult to get something useful
09:06:52 <bringert> no, really, really cheap
09:06:53 <dmwit> (More expensive than, say, a mouse.)
09:06:59 <ndm> kosmikus: got it now, copied over from the linux partition, thanks
09:07:00 <thetallguy> Same with 3D mice, datagloves, etc.
09:07:10 <thetallguy> Cool in the mind, hard to make really effective
09:07:20 <bringert> it used the fact that the eye is an electric dipole
09:07:28 * glguy imagines eye gestures in the spirit of mouse gestures
09:07:33 <kb_> thetallguy: to be fair, a lot of people have a lot of trouble with mice and keyboards
09:07:43 * dmwit doesn't have that level of eye control
09:07:57 <bringert> and measured the potential difference in between points above and below, and to the right and left of the eye
09:08:08 <thetallguy> The number of people who successfully use m&K is orders of magnitude larger than eye tracking
09:08:21 <dmwit> I think I'm up to keeping my eyes in one window with a little practice, but moving in a strict circle?  One that would be recognized as a gesture?
09:08:22 <glguy> studies have shown?
09:08:28 <kb_> thetallguy: sure, as is the number of people who have tried it
09:08:36 <narain> speaking of cool-sounding hardware that's hard to use:
09:08:39 <narain> ?go gorilla arm
09:08:41 <lambdabot> http://www.catb.org/jargon/html/G/gorilla-arm.html
09:08:41 <lambdabot> Title: gorilla arm
09:08:44 <bringert> all you need is some electrodes like the ones used for ECG, some cables, a few op-amps, and an A/D converter
09:08:49 <thetallguy> kb_: there's a correlation there.
09:08:52 <glguy> ?go go gadget copter
09:08:54 <lambdabot> http://en.wikipedia.org/wiki/Inspector_Gadget
09:08:54 <lambdabot> Title: Inspector Gadget - Wikipedia, the free encyclopedia
09:08:55 <dmwit> bringert: Neat!
09:09:01 <kb_> thetallguy: more than one, perhaps
09:09:02 <dmwit> Do you put it on?
09:09:13 <bringert> the signal looked great on an oscilloscope
09:09:19 <thetallguy> kb_: people who have used the eye tracking know that it is hard to install, calibrate, etc.
09:09:21 <bringert> unfortunately it drifts over time
09:09:46 <bringert> which makes calibration difficult, as thetallguys says
09:09:52 <kb_> thetallguy: fair enough - it's an area i know next to nothing about
09:10:07 <SyntaxNinja> bringert: maybe I'm wrong
09:10:27 <thetallguy> kb_: I spent years playing with 3D devices.
09:10:33 <bringert> catching eye movement is pretty easy, but getting absolute position is harder
09:10:43 <thetallguy> kb_: I really wanted them to succeed.
09:11:17 <thetallguy> kb_: they will eventually, I think.
09:11:33 <thetallguy> kb_:  The wii is a good use of them
09:11:34 <bringert> SyntaxNinja: I think there was talk about adding something more general, that would also support CVS, SVN etc. Another problem is that one darcs repo can contain several cabal packages
09:11:53 <bringert> I'm guessing that that's the reason it hasn't been implemented yet
09:12:17 <kb_> thetallguy: hmm, cool; it'd be neat if they did.  What I'd really like is for the neural i/o devices to get to a usable point
09:12:17 <thetallguy> kb_: but very different from desktop use
09:12:37 <thetallguy> gotta run.
09:13:46 <chessguy_work> wii tracks eye movement?
09:14:08 <kb_> chessguy_work: i think he meant 3d input
09:14:14 <chessguy_work> oh
09:19:57 <ndm> chessguy_work: not that they tell you, yet
09:21:39 <balodja> @where ShowQ
09:21:40 <lambdabot> I know nothing about showq.
09:21:47 <balodja> @hoogle ShowQ
09:21:48 <lambdabot> No matches found
09:22:10 <balodja> hm-m-m, what is it?
09:22:23 <chessguy_work> @go haskell showq
09:22:25 <lambdabot> http://radio.weblogs.com/0100945/gems/spj_meta-haskell.pdf
09:22:39 <chessguy_work> hm, that looks suspiciously wrong
09:23:02 <Saizan> balodja, where did you find it?
09:23:15 <chessguy_work> http://www.cse.unsw.edu.au/~dons/lambdabot/scripts/ShowQ.hs
09:23:21 <balodja> in lambdabot's RunPlugs
09:30:40 <bakert_> ?hoogle [a] -> a -> [a]
09:30:40 <lambdabot> List.intersperse :: a -> [a] -> [a]
09:30:41 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
09:30:41 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
09:30:48 <bakert_> ?src deleteBy
09:30:48 <lambdabot> Source not found. My mind is going. I can feel it.
09:31:18 <bakert_> ?src take
09:31:18 <lambdabot> take n _      | n <= 0 =  []
09:31:19 <lambdabot> take _ []              =  []
09:31:19 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
09:31:35 <bakert_> ?src takeWhile
09:31:35 <lambdabot> takeWhile _ []                 =  []
09:31:36 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
09:31:36 <lambdabot>                    | otherwise =  []
09:32:38 * vincenz sees the problem
09:32:40 <bakert_> > takeWhile (\x -> x != '~') "hello~goodbye"
09:32:41 <vincenz> ack
09:32:42 <vincenz> mischan
09:32:43 <lambdabot>   Not in scope: `!='
09:32:50 <bakert_> > takeWhile (\x -> x /= '~') "hello~goodbye"
09:32:52 <lambdabot>  "hello"
09:33:42 <bringert> Igloo: there seems to be something wrong with the permissions in the cabal-upload repo
09:33:47 <bringert> bringert@monk:/home/darcs$ ls -ld /home/darcs/cabal-upload/_darcs/current/src/
09:33:47 <bringert> drwxr-sr-x  2 igloo darcs 4096 2007-02-12 15:28 /home/darcs/cabal-upload/_darcs/current/src/
09:34:02 <bringert> Igloo: that makes it impossible for me to push
09:34:14 <bringert> Igloo: you may have to do a darcs repair too
09:34:24 <bringert> since I got:
09:34:30 <bringert> darcs failed:  Error applying patch to recorded!
09:34:30 <bringert> Running 'darcs repair' on the target repository may help.
09:34:30 <bringert> takeFile ./src/CabalUpload.hs-0 in /srv/darcs/cabal-upload/_darcs/current: openFd: permission denied (Permission denied)
09:35:07 --- kick: TRK was kicked by vincenz (goodbye Keal)
09:35:10 <Igloo> bringert: Should be sorted now
09:35:23 <dmwit> ?keal
09:35:24 <lambdabot> love a black and white lower 128 from 32 up of ascii glyphs?
09:35:38 <dmwit> What?
09:35:53 <sjanssen> hahaha
09:35:55 <bringert> Igloo: thanks!
09:36:01 <bakert_> > sum [1,2,3]
09:36:02 <lambdabot>  6
09:36:19 <sjanssen> @keal
09:36:19 <lambdabot> and yes that was with zero formal training in all realms
09:36:21 <chessguy_work> @protontorpedo
09:36:22 <lambdabot> what does haskell do better than java perl or ruby?
09:36:41 <sjanssen> protontorpedo just isn't zany enough
09:37:05 <chessguy_work> @pl \x -> x /= '~'
09:37:06 <lambdabot> ('~' /=)
09:37:10 <sjanssen> @girl19
09:37:11 <lambdabot> LOL
09:37:16 <sjanssen> @palomer
09:37:16 <chessguy_work> @vixen
09:37:16 <lambdabot> You're all nuts
09:37:17 <lambdabot> <undefined>
09:37:25 <chessguy_work> @qwe1234
09:37:25 <dmwit> ?palomer
09:37:25 <lambdabot> Unknown command, try @list
09:37:26 <lambdabot> As someone who's studied GADTs, I've never found a use for them.
09:37:38 <sjanssen> @v
09:37:39 <lambdabot> Just 'J'
09:38:00 <chessguy_work> @arr
09:38:01 <lambdabot> Keelhaul the swabs!
09:38:04 <dmwit> ?keal
09:38:05 <lambdabot> evaluating expressions is ALL haskell does?????
09:38:11 <chessguy_work> haha
09:38:16 <dmwit> Haha, keal is still my favorite.
09:38:38 <chessguy_work> what a silly language :)
09:38:58 <sjanssen> that particular quote is great because it's true
09:39:10 <chessguy_work> indeed
09:39:12 <kpreid> no, it isn't!
09:39:39 <sjanssen> kpreid: what else does it do?
09:39:45 <kpreid> a haskell implementation evaluates "main" and then does something that *isn't* evaluating an expression
09:40:33 <sjanssen> yeah, I suppose there is the matter of executing the IO data type
09:41:17 <sjanssen> anyway, somebody should make a #haskell shirt with the expressions quote on it
09:42:04 <chessguy_work> "you mean haskell is ONLY a wrapper over lambda calculus????"
09:44:35 <bakert_> Stupid question
09:44:41 <bakert_> I have a list [1000, 300]
09:44:48 <bakert_> how do I get 700 (a - b)
09:44:48 <bakert_> ?
09:45:03 <bakert_> without pattern matching
09:45:22 <bakert_> ?src foldr
09:45:23 <lambdabot> foldr k z xs = go xs
09:45:23 <lambdabot>     where go []     = z
09:45:23 <lambdabot>           go (y:ys) = y `k` go ys
09:45:27 <sjanssen> > foldr (-) 0 [1000, 300]
09:45:29 <lambdabot>  700
09:45:36 <bakert_> wicked
09:45:37 <bakert_> ta
09:45:45 <bakert_> i guessed the right function at least!
09:49:29 <pcc> foldr (-) 0 [1000, 300]
09:49:52 <dmead> folr (^) [1..]
09:49:55 <dmead> > folr (^) [1..]
09:49:57 <lambdabot>   Not in scope: `folr'
09:50:00 <dmead> > foldr (^) [1..]
09:50:02 <lambdabot>   add an instance declaration for (Integral [t])
09:50:06 <pcc> > foldr (-) 0 [1000, 300]
09:50:07 <dmead> > foldr (**) [1..]
09:50:08 <lambdabot>  700
09:50:09 <lambdabot>   add an instance declaration for (Floating [t])
09:50:14 <dmwit> > foldr (^) 1 [1..]
09:50:14 <dmead> > foldr (+) [1..]
09:50:16 <lambdabot>   add an instance declaration for (Num [t])
09:50:17 <lambdabot>  Exception: stack overflow
09:50:19 <pcc> Huh... That's pretty cool.
09:50:22 <dmead> muahha
09:50:25 <dmwit> dmead: Needs a default argument.
09:50:27 <dmwit> ;-)
09:50:32 <dmead> ah yes
09:50:39 <dmead> > fold (+) [1..]
09:50:40 <lambdabot>   Not in scope: `fold'
09:50:44 <dmead> oof
09:50:48 <dmwit> > foldr1 (+) [1..]
09:50:48 <dmead> > foldl (+) [1..]
09:50:50 <lambdabot>   add an instance declaration for (Num [t])
09:50:51 <lambdabot>  Exception: stack overflow
09:50:51 <dmead> mauahha
09:51:39 <sjanssen> > foldl' (+) 0 [1..] -- what was that, Arnold?
09:51:42 <lambdabot> Terminated
09:51:52 <dmwit> =D
09:51:56 <bakert_> > foldr (-) 0 [300, 1000]
09:51:57 <lambdabot>  -700
09:52:01 <bakert_> > foldr (-) 0 [-300, 1000]
09:52:02 <lambdabot>  -1300
09:52:23 <dmwit> > foldr (flip (-)) 0 [300, 1000]
09:52:25 <lambdabot>  -1300
09:52:43 <dmwit> err
09:52:47 <kpreid> > foldr1 (flip (-)) [300, 1000]
09:52:49 <lambdabot>  700
09:53:07 <bakert_> i'm doing something else wrong.  the numbers are both positive and the answer is negative ... must be in some other part of my code!!!
09:53:09 <kpreid> that what you were looking for?
09:53:25 <dmwit> kpreid: Yep, thanks. =)
09:53:46 <dmwit> bakert_: It's the size, not the sign, that's important.
09:54:04 <dmwit> (Well, okay, both the size AND the sign.)
09:54:18 <bakert_> yeah could be that the numbers are in the reverse order from what i think they are ... but they aren't!
09:57:23 <waern> who should I contact to get a trac at hackage.haskell.org/trac?
10:00:16 <bakert_> > foldr (-) 0 $ map (-) [-1000, 300]
10:00:17 <lambdabot>   add an instance declaration for (Num (a -> a))
10:00:32 <dmwit> ?hoogle negate
10:00:33 <lambdabot> Prelude.negate :: Num a => a -> a
10:00:45 <bakert_> > foldr (-) 0 $ map negate [-1000, 300]
10:00:47 <lambdabot>  1300
10:00:57 <bakert_> woo and a hoo.  thanks dmwit
10:01:05 <bringert> cabal-install kicks ass
10:02:12 <bakert_> everything is one line of haskell really, isn't it?
10:02:12 <bakert_>         (Just s) -> return $ Just $ foldr (-) 0 $ map negate $ map readAmount $ split "~" (trace s s)
10:02:33 <dmwit> ew
10:02:47 <bakert_> you don't like?
10:02:54 <bakert_> !!!
10:03:05 <dmwit> It's fine!  Don't get me wrong!
10:03:11 <dmwit> One-liners are always fun to write. =)
10:03:40 <bakert_> what's the alternative ... lots of intermediate variables with useful names?
10:03:42 <bakert_> i suppose so ...
10:03:44 <dmwit> But if it's included in something bigger... I'm guessing it will become broken apart eventually. =)
10:03:46 <dmwit> Yeah.
10:04:06 <dmwit> Also, you can (should, in my opinion) convert all but the last ($) to (.).
10:04:40 <dmwit> Just s -> return . Just . foldr (-) 0 . map negate . map readAmount . split "~" $ trace s s
10:04:44 <bakert_> but i love $
10:04:46 <bakert_> !!!
10:04:57 <bakert_> oooh dotty is good
10:05:09 <pcc> bakert_: What does the $ do, exactly?
10:05:17 <dmwit> ?src ($)
10:05:17 <lambdabot> f $ x = f x
10:05:19 <bakert_> brackets from there to the end of the line
10:05:21 <dmwit> It's function application.
10:05:23 <bakert_> without the need to close
10:05:33 <dmwit> It lets you get away with fewer parentheses.
10:05:34 <pcc> I see... so using (...) would have also worked.
10:05:37 <ddarius> ($) = id
10:05:49 <bakert_> pcc, yes
10:05:52 <bakert_> but i love $!
10:05:54 <dmwit> :t ($)
10:05:57 <lambdabot> forall a b. (a -> b) -> a -> b
10:06:01 <dmwit> :t id
10:06:03 <bakert_> but i love point free even more
10:06:04 <ddarius> $! is something else altogether.
10:06:04 <lambdabot> forall a. a -> a
10:06:07 <opqdonut> :t const
10:06:09 <dmwit> I see.
10:06:10 <lambdabot> forall a b. a -> b -> a
10:06:15 <sjanssen> ... would make code seem like poorly written dialog
10:06:20 <bakert_> that was i love ____ $ _____ with an exclamation mark on the end!
10:06:38 <opqdonut> :t ____
10:06:40 <lambdabot> Not in scope: `____'
10:06:41 <opqdonut> i'm confused
10:06:45 <opqdonut> :P
10:06:50 <bakert_> ha!
10:06:56 <sjanssen> map succ... filter odd... enumFrom 1
10:07:15 <dmwit> bakert_: Some people think that ($) has the wrong associativity.  Fixing it would break your code, but not code that replaced ($) with (.) wherever possible.
10:07:19 <bakert_> let me express my love for the dollar function AND for the exclamation mark piece of english language punctuation simultaneously, wontcha
10:07:29 <sjanssen> > let (...) x y = x $ y in map succ... filter odd... enumFrom 1
10:07:31 <lambdabot>  Couldn't match expected type `[a]'
10:07:49 <bakert_> dmwit, interesting.  i thought $ WAS a direct replacement for ().
10:07:57 <sjanssen> wrong fixity, it seems
10:08:14 <dmwit> bakert_: They're subtly different.
10:08:20 <dmwit> I didn't know this until about a month ago. =)
10:08:24 <dmwit> :t $
10:08:26 <dmwit> :t (.)
10:08:27 <lambdabot> parse error on input `$'
10:08:29 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
10:08:31 <dmwit> :t ($)
10:08:34 <lambdabot> forall a b. (a -> b) -> a -> b
10:08:38 <bakert_> oh
10:08:53 <bakert_> curious
10:09:05 <dmwit> So, function composition and function application are _very_ similar.
10:09:18 <dmwit> In most cases, they are the same.
10:09:21 <dmwit> But consider:
10:09:25 <dmwit> > sin $ 3
10:09:27 <lambdabot>  0.1411200080598672
10:09:30 <dmwit> > sin . 3
10:09:31 <lambdabot>   add an instance declaration for (Num (a -> b))
10:09:41 <dmwit> Here, 3 is not a function, so function composition doesn't make sense.
10:10:08 <ddarius> Don't forget ...!
10:10:17 <dmwit> ...
10:10:19 <dmwit> :t (...)
10:10:22 <lambdabot> Not in scope: `...'
10:10:33 <bringert> dmwit: when are function application and function composition the same?
10:10:34 <dmwit> ... get's to be whatever it wants. =P
10:10:35 <balodja> @where QuickCheck
10:10:36 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
10:10:44 <sjanssen> @type (?wow!)
10:10:46 <dmwit> > sin . cos
10:10:48 <lambdabot> forall i e. (?wow::Array i e, Ix i) => i -> e
10:10:48 <lambdabot>  <Double -> Double>
10:11:02 <dmwit> Errr... maybe never.
10:11:21 <dmwit> I always used to think of ($) as (.), but with lower precedence.
10:11:39 <dmwit> > sin . cos 3
10:11:40 <lambdabot>   add an instance declaration for (Floating (a -> b))
10:11:41 <dmwit> > sin $ cos 3
10:11:43 <lambdabot>  -0.8360218615377305
10:12:07 <Cale> > let x ...! y = \z -> x z (y z); fibs = 0 : 1 : (zipWith (+) ...! tail) fibs in fibs
10:12:09 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
10:12:09 <bakert_> Sorry I think I misspoke.  I meant that I think of $ as a replacement for a set of parentheses not the . thing.  The . thing still confuses me and I add it in later when everything works.
10:12:21 <dmwit> bakert_: Ah, okay.
10:12:24 <bakert_> I get what you are saying though.  It is actually very similar
10:12:26 <Cale> . is just function composition
10:12:32 <bakert_> "just" he says
10:12:41 <bakert_> sometimes it confuses me.
10:12:44 <Cale> Well, it's something which you should know from highschool :)
10:12:45 <kosmikus> ($) is just identity on functions
10:12:48 <bakert_> although not as much as >>=
10:12:51 <Cale> (f . g) x = f (g x)
10:12:55 <kosmikus> :)
10:13:09 <sjanssen> = f $ g $ x = f . g $ x
10:13:14 <bakert_> it's not so much that i don't get it but that i don't get it on a gut level.  i have to have a little think.
10:13:26 <Cale> I really wish ($) had the opposite associativity.
10:13:37 <dmwit> =)
10:13:47 <glguy> Cale: oh really?
10:13:50 <Cale> Yeah
10:14:07 <Cale> Because we could deparenthesize even more expressions then.
10:14:16 <glguy> what about $!
10:14:22 <Cale> $! too.
10:14:29 <sjanssen> $! needs it even more than $
10:14:32 <Philippa> you could use the euro sign for that?
10:14:40 * glguy wonders if he sounds like an infomercial or not
10:14:44 <Cale> The Euro sign isn't on my keyboard.
10:14:54 <Philippa> get a better keymap :-)
10:15:01 <Cale> True :)
10:15:12 <sjanssen> hmm, is $ on European keyboards?
10:15:15 <dmwit> like anyone uses the euro
10:15:20 <Cale>  ,        .
10:15:36 <bringert> sjanssen: yes
10:15:46 <glguy> after all, i
10:15:50 <dmwit> was
10:15:52 <dmwit> sure?
10:15:57 <Cale> can type using the greek character map
10:16:01 <dmwit> ... the greek ...
10:17:56 <sjanssen> $ is the only currency symbol is ASCII
10:18:41 <Cale> :t let (f  g) x y = f (g x y) in ()
10:18:44 <lambdabot> lexical error at character '\136'
10:18:54 <Philippa> sjanssen: yes
10:19:27 <Philippa> something about what the A in ASCII stands for
10:19:38 <sjanssen> right :)
10:19:51 <glguy> awesome
10:20:15 <sjanssen> just saying the Euro symbol will have compatibility problems in most Haskell systems to date
10:21:18 <roconnor> Haskell should use ISO 646
10:21:30 <opqdonut> :D
10:22:22 <sjanssen> roconnor: the encoding of source files is actually unspecified in the report
10:22:35 <ndm> @seen waern
10:22:36 <lambdabot> waern is in #haskell. I last heard waern speak 25m 11s ago.
10:22:43 <roconnor> ``Haskell uses the Unicode [11] character set. However, source programs are currently biased toward the ASCII character set used in earlier versions of Haskell .
10:23:00 <ndm> waern: you should talk to google, who know how to do a decent bug tracker, and host it for free even
10:23:24 <kc5tja> ndm: They do?  :)
10:23:38 <sjanssen> roconnor: ah, didn't know that.  The term 'biased' is bit biased, though
10:23:54 <sjanssen> s/biased,/ambiguous
10:24:12 <roconnor> uniSymbol 	 -> 	 any Unicode symbol or punctuation
10:24:13 <waern> ndm, I'll do that :)
10:24:30 <sjanssen> roconnor: Unicode is not an encoding
10:24:44 <dmwit> ?botsnack
10:24:45 <lambdabot> :)
10:25:13 <lambdabot> >:)
10:25:14 <roconnor> symbol 	 -> 	 ascSymbol | uniSymbol<special | _ | : | " | '>
10:25:43 <chessguy_work> > length " ,        "
10:25:45 <lambdabot>  51
10:26:08 <dmwit> lambdabot is getting sassier every day
10:26:30 <hpaste> You complain like I type.
10:26:39 <glguy> :-p
10:26:44 <roconnor> Someone needs to sit down and write the ultimate unicode char/string library for haskell
10:26:48 <dmwit> =D
10:26:54 <roconnor> someone really geeky
10:27:03 <sjanssen> roconnor: Char and String are already Unicode
10:27:07 <sjanssen> our IO libraries just suck
10:27:30 <roconnor> sjanssen: where is the isMathChar function?
10:27:34 <roconnor> @hoogle isMathChar
10:27:35 <lambdabot> No matches found
10:28:08 <chessguy_work> @go haskell isMathChar
10:28:09 <lambdabot> No Result Found.
10:28:19 <chessguy_work> @go isMathChar
10:28:20 <dmwit> ?go isMathChar
10:28:21 <lambdabot> No Result Found.
10:28:22 <waern> ndm, so you like it better than trac? why?
10:28:23 <lambdabot> No Result Found.
10:28:33 <ndm> waern: ever used trac?
10:28:36 <roconnor> @hoogle isMathematicsChar
10:28:36 <sjanssen> yeah, some advanced things are still missing.  Proper collation is one example
10:28:36 <lambdabot> No matches found
10:28:40 <roconnor> @hoogle isMathematics
10:28:41 <lambdabot> No matches found
10:28:42 <waern> ndm, a little
10:28:44 * chessguy_work somehow doesn't believe that google doesn't return ANY results
10:28:56 <chessguy_work> wow, it doesn't
10:29:07 <ndm> waern: its just better designed, labels are something which you have control over, not something you are forced in very painful manners
10:29:13 <roconnor> @hoogle normalizeUnicodeString
10:29:14 <lambdabot> No matches found
10:29:29 <ndm> waern: plus you can write your comment in a bigger text box - its just thousands of little things which makes it much more useable
10:29:30 <dmwit> ?go normalize unicode string
10:29:36 <lambdabot> http://search.cpan.org/perldoc?Unicode%3A%3ANormalize
10:29:37 <lambdabot> Title: Unicode::Normalize - Unicode Normalization Forms - search.cpan.org
10:29:45 <chessguy_work> ?hoogle mathchar
10:29:46 <lambdabot> No matches found
10:30:12 <ndm> waern: i've used both, one for Hugs, one for Yhc, i now have a little pad of paper on my desk that i write Hugs bugs on in preference to using trac
10:30:26 <waern> ndm: mmkay, heh
10:30:37 <roconnor> Unicode is probably way harder than date/time
10:30:44 <waern> ndm: right now the biggest plus for me is that they host the project for me
10:30:48 <roconnor> well, maybe not way harder
10:30:53 <roconnor> maybe just harder
10:31:03 <ndm> the only "feature" of trac missing in google code is that they integrate with darcs, but i don't think anyone ever actually got that working
10:31:22 * roconnor thinks that computer clocks need to be set to Terrestrial time rather than UTC.
10:31:44 <mightybyte> chessguy_work: Yeah, I've seen plenty of specific search strings where Google yields no results.
10:32:04 <chessguy_work> weird
10:32:29 <sjanssen> @google "Yeah, I've seen plenty of specific search strings where Google yields no results."
10:32:31 <earthy> roconnor: and the difference is?
10:32:31 <lambdabot> No Result Found.
10:32:35 <mightybyte> If you stick a long enough string inside double quotes, it's not too hard.
10:32:48 <mightybyte> sjanssen: :)
10:33:07 <earthy> actually, trac in non-default setups sucks bigtime
10:33:16 <earthy> and non-default is e.g. with remote svn repositories
10:33:18 <earthy> or with darcs
10:34:14 <ddarius> sjanssen: Give it a day and google may yield a result for that.
10:34:33 <sjanssen> ddarius: yes, remind me in a day
10:35:01 <roconnor> earthy: TT doesn't have leap seconds.
10:35:18 <roconnor> which presumably makes calculating time differences easier
10:35:39 <earthy> ah.
10:35:55 <roconnor> and makes your computer better behaved across leap seconds
10:36:06 <roconnor> Of course, leap seconds are also a bad idea
10:36:26 <waern> ndm: where do I actually create the project on code.google.com?
10:36:40 <roconnor> I'm not sure which is easier to change: leap seconds, or computers running on UTC vs TT
10:36:58 <roconnor> I know I could change my computer, so that is a bit nice
10:37:06 <roconnor> then I could try and distribute the changes
10:37:09 <ndm> waern: http://code.google.com/hosting/
10:37:10 <lambdabot> Title: Google Code - Project Hosting
10:37:17 <waern> ndm: It says  "Sign in with your Gmail account to create a project", when I do that I'm back at the hosting page
10:37:26 <roconnor> But getting rid of leap seconds probably requires a lot of politicking
10:37:32 <ndm> waern: http://code.google.com/hosting/createProject
10:37:32 <earthy> unfortunately, until the timereckoning as we know it is changed so that the either the connection to daylight is removed or time is so close that leap seconds aren't necessary for maintaining the daylight moments, I don't see the removal of leap seconds happening
10:38:12 <waern> ndm: I get a Forbidden page
10:38:39 <waern> (yes, I'm logged in to my account)
10:38:39 <chessguy_work> waern: it works for me
10:39:03 <ndm> waern: fine for me too...
10:39:08 <waern> weird
10:39:39 <ndm> waern: if you give me the details, i can set up the project, make you an admin, and you can then delete me?
10:40:09 <waern> it's not that I have to add something to my account to be able to do this?
10:40:30 <ndm> nope, just works (TM)
10:42:42 <waern> ndm: ok, what details do you want?
10:43:20 <bringert> works for me too, and I've never used Google Code before
10:43:20 <waern> ndm: #haddock
10:43:25 <ndm> waern: name, summary (one line), description (paragraph)
10:43:56 <ndm> waern: i can guess all the answers then - you can modify it afterwards if necessary
10:44:10 <waern> ndm: http://darcs.haskell.org/SoC/haddock.ghc/haddock-ghc.cabal
10:44:19 <waern> bringert, blargh
10:44:55 <waern> I'm guessing the "Sign in... "-link changes to "Create Project" when you're logged in?
10:45:15 <ndm> waern: probably, what is yoru gmail?
10:45:43 <bringert> "Is hosting on Google Code available internationally?
10:45:43 <bringert> For now, project hosting is available only in English. Open source projects can be created by developers from all countries, with a few small exceptions. "
10:45:54 <bringert> waern: maybe you're one of the exceptions
10:46:18 * ndm suspects exceptions means counties the US is at war with...
10:47:02 <ndm> waern: all created, i just need your gmail to make you an admin
10:47:36 <roconnor> Cuba
10:47:50 <waern> ndm: davve@dtek.chalmers.se
10:48:01 <ndm> waern: hmm, thats not a gmail address...
10:48:13 <bringert> yeah, we can't have those north koreans hosting their open source nuke projects in google's SVN repos
10:48:17 <waern> ndm: but it's my login for my google account
10:48:21 <ndm> waern, No such user: dtek.chalmers.se
10:48:28 <waern> ndm: I don't use gmail
10:48:29 <ndm> waern: you may need a real google account...
10:49:15 <bringert> "1. Try compiling any project pretty much
10:49:15 <bringert> 2. Cry when you find that Data.Map etc are not available"
10:49:22 <bringert> haha
10:49:27 <bringert> nice bug report
10:50:35 <chessguy_work> heh. what's that bug report for?
10:50:40 <bringert> yhs
10:50:42 <bringert> yhc
10:51:00 <bringert> http://code.google.com/p/yhc/issues/detail?id=2&can=2&q=
10:51:00 <ndm> bringert: that sounds like i reported that
10:51:01 <lambdabot> Title: yhc - Google Code
10:51:07 <chessguy_work> does yhc  not import Prelude implicitly?
10:51:08 <bringert> yeah
10:51:12 <ndm> bringert: search "muggle" for my favourite bug report :)
10:51:20 <waern> ndm: okay, I've created one: david.waern@gmail.com
10:51:36 <dmwit> ?where trac
10:51:37 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
10:51:44 <ndm> waern: http://code.google.com/p/haddock/issues/list
10:51:45 <lambdabot> Title: haddock - Google Code
10:51:58 <bringert> ndm: http://code.google.com/p/yhc/issues/detail?id=30&can=2&q=muggle
10:51:59 <lambdabot> Title: yhc - Google Code
10:52:18 <bringert> ndm: something to do with harry potter, right?
10:52:29 <ndm> bringert: yep - muggle is someone who knows no magic
10:52:31 <waern> ndm: nice! thanks
10:52:55 <bringert> ndm: but wouldn't that be more like knowing magic, but refraining from using it?
10:53:19 <ndm> bringert: the ultimate goal of that bug is to rip the whole implementation of magic out of the compiler
10:53:26 <ndm> its truely amazing, you get things like:
10:53:37 <ndm> instance Num Int where a + b = a + b -- MAGIC
10:53:42 <ndm> all over the prelude!
10:53:53 <dmwit> =(
10:53:54 <ndm> and all of them have the comment -- MAGIC
10:53:54 <bringert> nice
10:54:14 <dmwit> It would be even better if the comment -- MAGIC was what made it magic.
10:54:14 <bringert> what does the instance for Num Double look like?
10:54:42 <opqdonut> :DD
10:55:26 <ndm> bringert:exp x               =  primDoubleExp x        -- MAGIC
10:55:45 <ndm>  a + b    = a + b       -- MAGIC
10:55:48 <ndm> thats the double one
10:56:00 <ndm> so + is MAGIC, exp isn't magic, but still has a MAGIC ocmment
10:56:06 <bringert> ndm: well, primDoubleExp could actually be a primitive rather than magic?
10:56:12 <bringert> eh
10:56:14 <bringert> soryy
10:56:16 <bringert> sorry
10:56:20 <bringert> nice
10:56:28 <ndm> dmwit: some things have the MAGIC comment and aren't, some don't and are!
10:56:41 <dmwit> o nose!
10:56:42 <bringert> inconsistency is king
10:56:59 <ndm> yeah, well before Yhc, in nhc each instance is in a separate file
10:57:15 <ndm> the Prelude was ~200 files!
11:00:55 <malcolmw> I could search and replace the string MAGIC with BYTECODE - would that solve your bug report?
11:02:00 <malcolmw> I'll bet that primDoubleExp is indeed MAGIC, rather than a true primitive
11:03:08 <Igloo> malcolmw: a + b = a + b   definitely requires some magic as well as bytecode
11:03:27 <ndm> really? what i really want is to use primitives throughout, then have some primitives implemented as bytecodes
11:03:42 <ndm> primDoubleExp is less magic, at least
11:03:57 <malcolmw> Igloo: the point is that the compiler recognises it as implementable by a bytecode.  The comment is only a reminder to the reader of what is going on.
11:04:55 <malcolmw> ndm: but what you want is effectively what is already implemented
11:05:27 <ndm> malcolmw: not as nicely as i'd like, i'd rather primitive bytecode primAddInt :: Int -> Int -> Int
11:06:41 <malcolmw> ndm: and then have the compiler throw it away?
11:07:04 <ndm> malcolmw: and then have the compiler potentially throw it away, the bytecode changes should be the very last thing before code generation
11:07:21 <ndm> malcolmw: remember that there are other things than bytecode compilers - Catch and Reach at least want to do different things with it
11:07:29 <ndm> ditto the Javascript back end
11:07:47 <ndm> throwing it away is easy
11:09:38 <malcolmw> ah, yes I see
11:10:32 <ndm> moving to a compiler as a front end for tools requires some changes - i'm sure there are others out there too
11:10:50 <ndm> although the magic one is pretty minimal - we have Yhc.Core.Primitive which fixes them back up to explicit primitives
11:12:15 --- mode: xerox set -o xerox
11:13:28 <dmwit> Okay, a little off-topic, but it looks like I won't really be interrupting any serious questions: I can see a green dot next to channel operators, and a brown dot next to glguy and hpaste.  What's the brown dot for?
11:14:52 <dirkjanh> dmwit it's voice mode, it allows one to speak while the channel is moderated (+m mode)
11:15:21 <Cheery> is there ways to evaluate lambdas in String or import sources/binaries in runtime?
11:15:33 <dmwit> ?where hsplugins
11:15:34 <lambdabot> I know nothing about hsplugins.
11:15:37 <dmwit> ?where hsplugin
11:15:38 <lambdabot> I know nothing about hsplugin.
11:15:45 <dmwit> ?where hs-plugins
11:15:46 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
11:15:59 <dmwit> ?where+ hsplugins try hs-plugins
11:16:00 <lambdabot> Done.
11:16:01 <Cheery> like... making a program which takes a lambda, then evaluates it
11:16:26 <dmwit> dirkjanh: Ah, neat, thanks.
11:16:38 <dmwit> Cheery: Takes it from where?
11:16:45 <Cheery> stdin
11:16:55 <Cheery> hmm, hs-plugins...
11:17:02 <Cheery> seems like what I was looking for
11:18:38 <Cale> hmm lots of +o's
11:18:44 <Cale> Was there a problem?
11:18:47 <procyon112> say I have: data MyData = MyInt Int | MyFunc (MyData -> MyData)
11:19:40 <procyon112> Now, I can add: addition = MyFunc $ (\x -> MyFunc $ (\y -> x + y))
11:20:12 <Cale> You'll have to pattern match a bit
11:20:29 <dmwit> You'll have to unwrap the x from the MyData type.
11:20:43 <procyon112> So, is there a way to write the function: addition = convertToMyFunc (+) -- lifts (+) into MyFunc
11:21:02 <dmwit> procyon112: What does (+) mean if MyData holds a MyFunc?
11:21:24 <procyon112> dmwit
11:21:27 <dmwit> Or, for example, what about adding an MyInt and a MyFunc?
11:21:50 <procyon112> dmwit: yeah, sorry... I forgot the pattern match
11:22:00 <Cale> !paste
11:22:01 <hpaste> Haskell paste bin: http://hpaste.org/
11:22:13 <hpaste>  Cale pasted "something like this." at http://hpaste.org/1332
11:22:25 <procyon112> addition = MyFunc $ (\x -> MyFunc $ (\y -> (fromMyInt x) + (fromMyInt y)))
11:22:28 <Cale> er, oops
11:22:42 <Cale> Right, you can't add k to f x because f x is MyData
11:23:05 <bd_> explode = MyFunc (const explode)
11:23:16 <bd_> what would explode `addition` MyInt 4 be?
11:23:42 <dmwit> bottom, since addition only deals with MyInts on the LHS and RHS.
11:23:48 <dmwit> (Pattern match failure.)
11:23:54 <bd_> well, I mean, what is it /intended/ to be :)
11:23:58 <dmwit> yeah
11:24:42 <ptolomy> Anyone know if/when the new regex backends will find their way into the GHC standard library?
11:24:54 <procyon112> cale: The problem is that add, as you define it is of type MyData->MyData->MyData... which won't fit into a MyFunc because the arity is too high.
11:25:21 <Cale> I suppose that's one problem.
11:25:50 <procyon112> cale: What I want is a way to interleave a MyFunc constructor between each curried param so the code doesn't get so messy putting MyFunc constructors all over the place by doing it manually
11:26:00 <dmwit> procyon112: Maybe we should zoom out; what are you trying at a higher level?
11:26:16 <Cale> (my code doesn't typecheck)
11:26:46 <resiak> I have a function f :: a -> Maybe a; I want to repeatedly apply it to something until it returns Nothing then return the value just before that.  Is there a standard function for this?
11:26:51 <procyon112> dmwit: A typed evaluator.  A node in the tree would be the "MyData" type (just 2 types here to keep it simple)
11:26:59 <dmwit> :t unfold
11:27:02 <lambdabot> Not in scope: `unfold'
11:27:04 <bd_> :t iterateM
11:27:04 <dmwit> ?hoogle unfold
11:27:05 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
11:27:06 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
11:27:06 <lambdabot> Data.Tree.unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
11:27:07 <lambdabot> Not in scope: `iterateM'
11:27:17 <resiak> dmwit: oh, and just take the last?
11:27:36 <dmwit> resiak: Yeah.
11:27:40 <resiak> hrm, no, unfoldr has the wrong type
11:27:53 <glguy> fmap (join (,))
11:28:00 <procyon112> dmwit: My way works, but it's really messy. I'd like to just "lift" primitive functions into my representation by interleaving the function constructor between each curried parameter
11:28:37 <bd_> resiak: You can expand it, eg with iterateMaybe f v = last $ unfoldr (fmap (\x -> (x,x)) f) v
11:28:48 <procyon112> dmwit: Or, if I can't lift primitives, at least make my own function definitions a bit cleaner.
11:28:50 <bd_> hmm
11:28:52 <resiak> bd_: yeah, or I could just write the function directly :)
11:28:55 <resiak> okay, thanks :)
11:29:01 <bd_> @hoogle (a -> m b) -> a -> b
11:29:03 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
11:29:03 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
11:29:03 <lambdabot> Prelude.(.) :: (b -> c) -> (a -> b) -> a -> c
11:29:20 <bd_> @hoogle MonadPlus m => (a -> m b) -> a -> b
11:29:22 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
11:29:22 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
11:29:22 <lambdabot> Prelude.(.) :: (b -> c) -> (a -> b) -> a -> c
11:29:24 <bd_> bleh
11:29:43 <glguy> f g a = case g a of Nothing -> a; Just x -> f g x
11:30:10 <resiak> glguy: that's what I wrote, but figured there might be a cunning monadic way
11:30:15 <resiak> maybe something evil with `msum`
11:30:22 <bd_> hmm
11:30:37 <glguy> resiak: resiak what you are describing doesn't make use of Maybe as a Monad
11:30:53 <dmwit> lift f (MyInt x) = MyFunc (\(MyInt y) -> y + f x) -- procyon112, something like this?
11:30:55 <resiak> glguy: no, you're riht.
11:31:13 <sjanssen> you could probably use mplus
11:31:18 <bd_> :t iterate
11:31:21 <lambdabot> forall a. (a -> a) -> a -> [a]
11:31:26 <dmwit> s/-> y/-> f y/
11:31:49 <hpaste>  Cale annotated "something like this." with "explicit errors?" at http://hpaste.org/1332#a1
11:31:56 <bd_> lastMaybe f = last . takeWhile isJust . iterate (join f) . Just -- perhaps? Not necessarily as cunning as desired...
11:31:59 <dmwit> > mappend (Maybe 3) (Maybe 4)
11:32:00 <lambdabot>   Not in scope: data constructor `Maybe'
11:32:07 <dmwit> > mappend (Just 3) (Just 4)
11:32:08 <lambdabot>   add an instance declaration for (Monoid (Maybe t))
11:32:09 <lambdabot>     In the expression: m...
11:32:17 <bd_> mplus?
11:32:26 <glguy> You'd have to use flip mplus
11:32:27 <procyon112> dmwit:  Yeah.. something like that.  I'll play with it.
11:32:29 <sjanssen> @type let go f x = (f x >>= go f) `mplus` return x
11:32:32 <lambdabot> [1 of 2] Compiling ShowQ            ( scripts/ShowQ.hs, interpreted )
11:32:32 <lambdabot> [2 of 2] Compiling L                ( L.hs, interpreted )
11:32:32 <lambdabot>  
11:32:41 <sjanssen> @type let go f x = (f x >>= go f) `mplus` return x in go
11:32:44 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => (a -> m a) -> a -> m a
11:33:15 <Cale> One could also use GADTs.
11:33:30 <sjanssen> @type \f x -> last $ unfoldr f x -- is obviously better
11:33:33 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> a
11:33:46 <bd_> @hoogle a -> (a, a)
11:33:47 <lambdabot> Control.Monad.RWS.execRWS :: RWS r w s a -> r -> s -> (s, w)
11:33:47 <lambdabot> Control.Monad.RWS.evalRWS :: RWS r w s a -> r -> s -> (a, w)
11:33:51 <bd_> mmm
11:33:56 <dmwit> :t fmap
11:33:59 <dmwit> :t join
11:33:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:34:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
11:34:13 <bd_> @type \f x -> last $ unfoldr (join (,) . f) x
11:34:16 <lambdabot>     Couldn't match expected type `Maybe (a, b)'
11:34:17 <lambdabot>            against inferred type `(b1, b1)'
11:34:24 <bd_> @type \f x -> last $ unfoldr (fmap (join (,)) . f) x
11:34:25 <dmwit> :t ap
11:34:27 <lambdabot> forall a. (a -> Maybe a) -> a -> a
11:34:28 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
11:34:39 <resiak> sjanssen, dmwit, bd_, glguy: many thanks.  i love this channel :)
11:34:56 <glguy> the plus means better
11:34:59 <chessguy_work> resiak: join the crowd :)
11:35:10 * glguy is quoting the GM Goodwrench Plus commericals
11:35:14 <glguy> for those that don't know
11:35:25 <abz> does c2hs support c++?
11:35:52 <chessguy_work> @karma c
11:35:53 <lambdabot> c has a karma of 15
11:35:57 <hpaste>  Cale annotated "something like this." with "gadt method" at http://hpaste.org/1332#a2
11:36:10 <dmwit> c++
11:36:13 <dmwit> ?karkma c
11:36:13 <lambdabot> c has a karma of 15
11:36:21 <glguy> dmwit: special case
11:36:32 * dmwit nods
11:36:34 <glguy> dons didn't want c to get too uppity
11:37:02 <Cale> c--
11:37:06 <Cale> @karma c
11:37:07 <lambdabot> c has a karma of 15
11:37:11 * vincenz just realized : sort "dons" == sort "nods"
11:37:29 <Cale> > sort "dons"
11:37:31 <lambdabot>  "dnos"
11:37:44 <vincenz> > sort "nods"
11:37:46 <lambdabot>  "dnos"
11:37:47 <dmwit> A "sond" argument, if I do say so myself.
11:37:48 <glguy> vincenz: that's deep
11:37:58 <foxy-om> are associated types in 6.6 ?
11:38:06 <vincenz> glguy: I've slept a total of .... 8 hours the llast 3 days
11:39:36 <glguy> vincenz: did you just run out of decaf?
11:39:43 <Cale> zinc nev
11:39:55 <vincenz> glguy: why decaf?
11:40:15 <Cale> ugly g
11:40:16 <glguy> vincenz: sleepy -> coffe -> decaf -> decaf has quite [connection timed out]
11:40:20 <dmwit> I think laCe is a pretty good one, too. ;-)
11:40:27 <glguy> laCe
11:40:34 <glguy> lol,
11:40:37 * glguy highfives dmwit 
11:40:41 <dmwit> Yes!
11:40:44 <vincenz> glguy: who drinks decaf???
11:40:45 <Cale> WMD it
11:41:02 <glguy> vincenz: not you apparently ;)
11:41:24 <vincenz> `ap` write paper
11:41:53 <dmwit> _o/
11:41:54 <dmwit>  |
11:41:54 <dmwit>  ^
11:42:07 <glguy> o\-<
11:42:08 <glguy> o\-<
11:42:09 <dmwit> ... that was supposed to be a high-five.
11:42:12 <glguy> o|-<
11:42:14 <glguy> o/-<
11:42:22 <glguy> lol
11:42:23 <glguy> I see it now
11:42:24 <dmwit> haha -- dance!
11:42:27 <vincenz> glguy: yeah I went swimming earlier
11:43:11 * glguy is listening to: Air - Moon Safari - Ce Matin La
11:43:15 <glguy> quite relaxing
11:43:55 <glguy> calming me down and keeping me from throwing the computer to the ground since I can't throw the virtual machine itself
11:44:26 * Cale is listening to Frank Zappa - Farther O'Blivion
11:45:34 * sjanssen is listening to the very faint whine his CPU makes when idle
11:45:58 <chessguy_work> i love code that's commented like this:
11:45:59 <chessguy_work>    // after testing, if errFlag=1 then display error message
11:45:59 <glguy> You might want to check your power source
11:45:59 <chessguy_work>    if (errFlag == "1")
11:45:59 <chessguy_work>     {
11:45:59 <chessguy_work>      ocs_error_add('&OCS_NAMESPACE;', "You must select at least one type of book you would like to read!");
11:46:03 <NotBeelsebob> moin
11:46:04 <glguy> CPUs usually don't whine
11:46:23 <vincenz> glguy: they do when running windows
11:46:37 <NotBeelsebob> lol
11:46:39 <vincenz> glguy: just hard to hear when your cooler is running at 200% to cool all the wasted power
11:46:42 <mwc> @hoogle Handle -> Word8
11:46:43 <lambdabot> No matches, try a more general search
11:46:54 <sjanssen> glguy: would a power source noise vary with CPU consumption
11:46:56 <sjanssen> ?
11:47:09 <sjanssen> @hoogle hGetBuf
11:47:10 <lambdabot> System.IO.hGetBuf :: Handle -> Ptr a -> Int -> IO Int
11:47:10 <lambdabot> IO.hGetBuffering :: Handle -> IO BufferMode
11:47:10 <lambdabot> System.IO.hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
11:47:13 <glguy> sjanssen: I was assuming that it was putting in a ton of power
11:47:22 <glguy> and making the thing overload :)
11:47:28 <glguy> for my pointless comment
11:47:30 <sjanssen> oh, right
11:47:54 <vincenz> glguy: the advantage of a virtual machine is the speed with which you can shut it off
11:47:57 <NotBeelsebob> I doubt it would use enough power to be noticable
11:48:09 <vincenz> glguy: nothing is as satisfactory as clicking on the little x at the top-right and instakilling windows
11:48:11 <sjanssen> with the luck I've had with this machine, there is probably something wrong.  I really don't feel like wrestling with Apple again, though
11:48:30 <xs> NotBeelsebob: even if it does frequency scaling?
11:48:36 <procyon112> dmwit: Got it: liftI2 f = MyFunc (\(MyInt x) -> MyFunc (\(MyInt y) -> MyInt $ f x y))
11:48:42 <NotBeelsebob> sjanssen: you had problems with a recent mac then?
11:48:50 <glguy> NotBeelsebob: I'm talking about malfunction, not cpu load
11:48:56 <chessguy_work> procyon112!
11:49:06 <sjanssen> NotBeelsebob: yes, I've had several issues with my nearly year old MacBook
11:49:12 <procyon112> dmwit: So: (liftI2 (+)) :: MyData
11:49:23 <procyon112> chessguy: Yo
11:49:34 <sjanssen> I had the infamous "random shutdown" issue.  The laptop was at Apple's repair site for nearly a month
11:49:35 <glguy> My fiancee has tried to give me issues with my powerbook by walking into the powercord and yanking it off my lap
11:49:41 <NotBeelsebob> glguy: ig the CPU is sucking up that much power I would expect it to become a small lump og flass
11:49:44 <glguy> but it keeps chugging along
11:49:47 <NotBeelsebob> damn qwerty
11:49:51 <vincenz> glguy: purposefully?
11:49:54 <glguy> vincenz: no
11:49:57 <sjanssen> and I got it back with a faulty battery, that took another two weeks to replace
11:50:16 <sjanssen> and just recently part of the power cord melted
11:52:02 <dmwit> procyon112: Great!
11:52:53 <procyon112> cale++ dmwit++
11:53:46 <glguy> ?karma dmwit
11:53:46 <lambdabot> dmwit has a karma of 2
11:53:53 <Cale> procyon112: careful with that, since if the function isn't quite the right type, you'll end up with pattern match failure
11:53:57 <dmwit> Woo!
11:53:59 <glguy> dmwit: just got doubled
11:54:03 <NotBeelsebob> sjanssen: oh... I was be[ahgouahguahgas LOST CARRIER]
11:54:24 <dmwit> ?karma cale
11:54:25 <lambdabot> cale has a karma of 1
11:54:32 <dmwit> cale--
11:54:32 <glguy> heh
11:54:33 <dmwit> Cale++
11:54:36 <glguy> ?karma Cale
11:54:36 <lambdabot> Cale has a karma of 46
11:54:39 <NotBeelsebob> sjanssen: what were the symptoms re battery?
11:54:48 <hpaste> ?karma
11:54:49 <lambdabot> You have a karma of 1
11:54:53 <dmwit> Just got 46/45th!
11:55:02 <glguy> ed
11:55:12 <sjanssen> NotBeelsebob: seemed to have no charge, wouldn't power the laptop, wouldn't charge
11:55:12 <dmwit> s/th/thed/
11:55:39 <procyon112> cale: For now, I'm going to go with the above liftI2 method.  I like your Gadt method though.  I'm not worried about pattern match failure, as I have an explicit typechecker hooked up.
11:55:40 <NotBeelsebob> hmm, k, *wonders ig he'll manage to get a new batery out of them*
11:55:52 <Cale> procyon112: ah, okay
11:56:14 <sjanssen> NotBeelsebob: you're under warranty?
11:56:31 <NotBeelsebob> mine has cracked top case, discoloured case, power cable's melted twice, and battery lasts 30 mins
11:56:43 <vincenz> sjanssen: his parents can ask for a new version of him ? :D
11:56:48 <NotBeelsebob> I think so ... I don't think they've even been out a year yet
11:56:50 --- mode: vincenz set -o vincenz
11:56:59 <sjanssen> oh, you've got a MacBook too
11:57:11 <glguy> vincenz: didn't like the attention?
11:57:29 <NotBeelsebob> sjanssen: yeh, it's a great computer... shame about the build quality
11:57:45 <NotBeelsebob> my iBook was way better built
11:57:52 <sjanssen> NotBeelsebob: I found acting very angry on the phone to be very effective in replacing my battery
11:58:17 <vincenz> glguy: yeah, keal kept pming me asking me to break the "blacklist math-circle instituded by dons"
11:58:24 <NotBeelsebob> sjanssen: bear in mind that I got the MacBook by beinf very very anfry on the phone
11:58:25 <sjanssen> initially they wanted me to send the laptop back in to them -- but I put a stop to that
11:58:28 --- mode: ChanServ set +v vincenz
11:58:46 <glguy> what is blacklist math-circle?
11:58:56 <sjanssen> NotBeelsebob: ah, so you're an old hand at this ;)
11:59:02 <NotBeelsebob> there's a local apple place though, and they're good there, so I'll take it in there
12:00:00 <NotBeelsebob> sjanssen: yeh, I got the MacBook because the logic board in my iBook died too many times and I demanded a new one under  sales of goods act
12:00:53 <NotBeelsebob> it seems to be a feature of apple's low end laptops... the build is somewhat questionable
12:01:07 * NotBeelsebob heads back to his... see you in 5 mins
12:01:59 <NotBeelsebob> 5utkpjk-ou]
12:02:16 <glguy> how did you know my password?
12:02:31 <dmwit> glguy: No caps? That isn't a strong password.
12:07:50 * SamB takes his name off the titlescreen again because it is throwing off the offsets in rezzt.exe ;-)
12:25:45 <chessguy_work> @keal
12:25:46 <lambdabot> i have basically written a proof that shows an assumption is wrong
12:25:59 <SamB> @where streams
12:26:00 <lambdabot> http://haskell.org/haskellwiki/Library/Streams
12:26:48 <SamB> that isn't the kind of streams...
12:27:12 <SamB> @google streams fusion
12:27:15 <lambdabot> http://eprints.pascal-network.org/archive/00000759/
12:27:18 <SamB> @google streams fusion dons
12:27:19 <lambdabot> http://www.cse.unsw.edu.au/~dons/streams/Data-List-Stream.html
12:27:19 <emu> 12345
12:29:46 <chessguy_work> heh. keal himself is in #ai now. what a nutcase
12:34:32 <Oejet> Hello all.
12:34:39 <fons> hi Oejet
12:34:54 <chessguy_work> salutations and other such pleasantries
12:37:07 <njd> @users
12:37:08 <lambdabot> Maximum users seen in #haskell: 336, currently: 330 (98.2%), active: 46 (13.9%)
12:38:07 <Oejet> ^^^ Not bad, not bad at all.
12:38:33 <dmwit> ?users
12:38:34 <lambdabot> Maximum users seen in #haskell: 336, currently: 331 (98.5%), active: 46 (13.9%)
12:38:48 <chessguy_work> ?where dons also works
12:38:49 <lambdabot> http://www.cse.unsw.edu.au/~dons
12:38:51 <dmwit> Aww, I must have already been counted.
12:39:34 <dmwit> ...that's a lot of projects
12:40:16 <Oejet> dmwit: Did you participate in the DARPA Grand Challenge?
12:40:27 <esap> Hmm... I just got "Command stack underflow" errors from GHC. :-)
12:40:31 <dmwit> No...
12:42:01 <mgsloan> man, I totally knew the blue team was going to win, once i knew their strategy
12:42:26 <Oejet> dmwit: Have you heard about it? (A team from Stanford won in 2005).
12:42:38 <dmwit> Oejet: Yes, I'm familiar with it.
12:42:42 <dmwit> I've seen some of the vids.
12:43:02 <Oejet> Me too, that is why I was curious. :-)
12:43:05 <dmwit> (Stanley and the STAIR robot are the two biggest projects in the CS department here.)
12:43:24 <dmwit> s/the two/two of the/
13:08:52 <sjanssen> @keal
13:08:53 <lambdabot> haskell always said undefined
13:12:02 <dmwit> ?quote
13:12:03 <lambdabot> bakert says: i think it's a question of where you are looking from.  from the magician's point of view no one got sawn in half and from the audience's point of view someone did and they both like it
13:12:03 <lambdabot> that way around.
13:12:14 <dmwit> ?quote
13:12:15 <lambdabot> mattam says: [Monads are] much more elegant [than soccer] in general.
13:33:19 <procyon112> ?quote procyon112
13:33:20 <lambdabot> procyon112 says: The other day I tried to say "fix fix" in lojban and couldn't stop talking until my stack blew!  Thank God I never learned the tail recursive way to say it!
13:33:30 <procyon112> ?quote procyon112
13:33:31 <lambdabot> procyon112 says: The other day I tried to say "fix fix" in lojban and couldn't stop talking until my stack blew!  Thank God I never learned the tail recursive way to say it!
13:42:01 <monochrom> haha
13:51:21 <sioraiocht> is there a built-in function to parse an Integer or should I just write my own?
13:51:27 <sioraiocht> @hoogle String -> Integer
13:51:29 <lambdabot> No matches, try a more general search
13:51:34 <earthy> > read "2" :: Integer
13:51:35 <lambdabot>  2
13:51:39 <monochrom> yeah, that.
13:51:42 <sioraiocht> thanks!!
13:51:50 * sioraiocht is a haskell n00b
13:52:00 <earthy> btw: this works for every type that has 'deriving Read' added to it
13:52:01 <monochrom> @hoogle String -> a
13:52:02 <lambdabot> Prelude.error :: String -> a
13:52:02 <lambdabot> Debug.Trace.trace :: String -> a -> a
13:52:02 <lambdabot> Prelude.fail :: Monad m => String -> m a
13:52:08 <monochrom> nevermind
13:52:26 <monochrom> > read "True" :: Bool
13:52:28 <lambdabot>  True
13:52:37 <earthy> (which you don't necessarily want to do, because it is nasty and big and doesn't always read what you want it to, but still)
13:52:49 <monochrom> > read "(34,True,'x')" :: (Double, Bool, Char)
13:52:50 <lambdabot>  (34.0,True,'x')
13:53:18 <sioraiocht> wow, thanks!
13:53:19 <earthy> what monochrom says
13:56:18 <thedward> > maybe 0 fst (listToMaybe (reads "19"))
13:56:20 <lambdabot>  19
13:56:25 <thedward> > maybe 0 fst (listToMaybe (reads "foo"))
13:56:27 <lambdabot>  0
13:59:26 <thedward> > (reads "foo") >>= return . fst :: [Integer]
13:59:27 <sphynx> ?quote
13:59:28 <lambdabot>  []
13:59:28 <lambdabot> liyang says: We can do pair programming on a punt or something.
14:00:36 <Cheery> @hoogle m ()
14:00:37 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
14:00:38 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
14:00:38 <lambdabot> Control.Monad.State.modify :: MonadState s m => (s -> s) -> m ()
14:01:19 <monochrom> Don't forget there is also return ()
14:06:53 <Cheery> stepcut: ?
14:08:43 <hpaste>  Cheery pasted "Improvement proposals? exploiting the haskell layout in CSS" at http://hpaste.org/1333
14:21:11 <hpaste>  Cheery annotated "Improvement proposals? exploiting the haskell layout in CSS" with "this would be probably good thing for first" at http://hpaste.org/1333#a1
14:25:34 <procyon112> any way to do this to unwrap an algebraic data type by parameter? test constr f = (\(constr n) -> f n)
14:26:35 <xerox> procyon112, do you know record syntax?
14:26:39 <sjanssen> procyon112: perhaps you want to use field syntax?
14:26:42 <sjanssen> @quote stereo
14:26:43 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
14:27:00 <sjanssen> data Stuff = Stuff {foo :: Int, bar :: Char}
14:27:00 <xerox> :)
14:27:19 <procyon112> hmm... perhaps
14:27:41 <sjanssen> then you can do things like "fooPlusOne :: Stuff -> Int; foo x = foo x + 1"
14:27:59 <Cheery> funThing stuff = stuff { foo = 2, bar = "gwahahaa" }
14:28:10 <sjanssen> or, "incrementFoo x = x {foo = foo x + 1}"
14:29:02 <Cheery> sjanssen: can you explain the first thing?
14:29:21 <Cheery> fooPlusOne :: Stuff -> Int; foo x = foo x + 1    ???
14:29:38 <sjanssen> fooPlusOne x = foo x + 1 -- I made a mistake, does this clear up the confusion?
14:29:57 <Cheery> yes
14:30:01 <Cheery> how do you use that?
14:30:26 <Cheery> or rather, can you use that on the data Stuff, nice way?
14:30:39 <monochrom> Yes. That's the point.
14:30:48 <Cheery> stuff { fooPlusOne }  ?
14:30:59 <sjanssen> Cheery: nah, you can't do that
14:31:04 <Cheery> too bad :(
14:31:07 <monochrom> that is not my understanding of "use that on the data Stuff"
14:31:28 <sjanssen> all fooPlusOne does is yank the 'foo' field from a 'Stuff', and return that number incremented by one
14:31:44 <Cheery> ah, ok
14:32:29 * Cheery wipes the excitement from his face
14:33:24 <Cheery> btw. why the accessors are done like that?
14:33:56 <Cheery> it'd be really neat if you could just do that stuff { fooPlusOne } or similar, instead of: stuff { foo = fooPlusOne stuff }
14:34:12 <procyon112> sjanssen: Of course, this requires converting my basic datatype... which breaks all my other code :/
14:34:13 <sjanssen> Cheery: you can do the second one
14:34:30 <Cheery> the record -syntax feels so sluggish because of this. :/
14:34:48 <sjanssen> procyon112: not true!  You can still use standard positional construction/matching with record-style
14:34:56 <sjanssen> a very handy feature
14:34:57 <monochrom> The notation "stuff { fooPlusOne }" is confusing in general.
14:35:40 <sjanssen> the record syntax is missing an equivalent to Control.Monad.State's 'modify'
14:36:08 <procyon112> sjanssen: yes, but it converts my types from an "a\/b" to "a/\b"... which means I need a discriminator, default values for null places, etc...
14:36:51 <monochrom> One problem with the notation "stuff { fooPlusOne }" is that it doesn't say that the field foo is being worked on.
14:37:31 <sjanssen> I'd rather see something like: stuff { foo $= (+1) }, or something
14:37:44 <monochrom> By the time you fix up this notation to say "stuff { foo is modified by fooPlusOne }" it is worse than "stuff { foo = fooPlusOne stuff }"
14:38:45 <monochrom> This is another data point supporting my impression that almost all suggestions to notations are myopic.
14:38:51 <procyon112> sjanssen: What I'm really looking for is to pass a constructor in as a parameter to a function, and then use that constructor to deconstruct and reconstruct a value when I know what precise type I'm dealing with.
14:39:18 <Cheery> monochrom: you can't be serious
14:39:26 <SamB> monochrom: what is wrong with "addOneToFoo stuff"?
14:39:54 <monochrom> I am not commenting on "addOneToFoo stuff".
14:39:57 <procyon112> specifically, I have: data MyType = MyInt Int | MyFunc (MyType->MyType)
14:40:10 <SamB> that actually works in todays Haskell ;-)
14:40:18 <monochrom> Yes.  See scrollback.
14:40:32 <SamB> and it has worked in every version of Haskell
14:40:37 <monochrom> Yes.
14:40:40 <SamB> and it will work in every version of Haskell
14:40:50 <monochrom> You're barking up the wrong tree.  Tell that to Cheery.
14:40:54 <procyon112> and: liftI f = MyFunc (\(MyInt x) -> MyInt $ f x)
14:41:34 <SamB> Cheery: so, what exactly is wrong with addOneToFoo stuff?
14:41:43 <procyon112> As I can say: liftI (+1) $ (MyInt 5) ===> 6
14:42:05 <procyon112> This gets messy with lots of constructors, so I would like a generic lift:
14:42:08 <Cheery> SamB: less convenient
14:42:33 <procyon112> lift f c = MyFunc (\(c x) -> c $ f x)
14:42:36 <Cheery> the problem comes from blending the selector and accessor in records
14:42:54 <SamB> now, what might be nice is some kind of named update function...
14:42:59 <procyon112> But unfortunately, pattern match does not work with constructors passed as parameters.
14:43:14 <sjanssen> procyon112: you can't do such a thing in Haskell.  What if the constructor had many arguments?
14:43:46 <sjanssen> procyon112: do you have many functions like 'lift'?
14:44:13 <Cheery> you can't do something like:   addOneToFoo = foo! (+1)
14:44:37 <procyon112> sjanssen: It doesn't ;)  It just feels ugly to hav 5 different lift functions for 5 different constructor types.... and thats just for unary functions.  adding Binary, like (+) gives me 5 more.. all which do more or less the same thing.
14:44:49 <Cheery> because you can't get the selector up any other way except with the brackets
14:45:08 <sjanssen> procyon112: you probably should have started with a more flexible type
14:45:26 <Cheery> you need to write something like: addOneToFoo stuff = stuff { foo = foo stuff + 1 }
14:45:44 <sjanssen> data UnaryOp = Op1 | Op2 ...; data Expr = Unary UnaryOp Expr | Binary BinaryOp Expr Expr
14:46:20 <Cheery> SamB: it's just not nice that you could write a thing in point-free -style if you'd have separate accessor and selector
14:47:04 <sjanssen> Cheery: I agree with you on this point
14:47:08 <Cheery> foo :: Stuff -> Int; foo! :: (Int -> Int) -> Stuff
14:47:11 <josephholsten> hello all
14:47:12 <SamB> so someone come up with a funny syntax for record updaters
14:47:40 <SamB> almost like :foo
14:47:45 <Cheery> less code says more
14:47:49 <sjanssen> I think monochrom just wanted to say that "stuff {addOneToFoo}" is a silly and dangerous syntax
14:48:16 <SamB> hmm, foo! looks dangerously similar to a strict field
14:48:17 <monochrom> It is not dangerous. No sane person will take it seriously.
14:48:30 <procyon112> sjanssen: I haven't played with adding the Ops to the type system.... I'm not sure if that would simplify or complicate things overall.  right now Ops are just combinators of type MyType->MyType
14:48:47 <Cheery> oh well, I'll go to sleep
14:49:27 <sjanssen> hmm, what about .=.?
14:49:41 <procyon112> ?src .=.
14:49:41 <lambdabot> Source not found. My mind is going. I can feel it.
14:49:49 <procyon112> ?hoogle .=.
14:49:50 <lambdabot> No matches found
14:49:50 <Cheery> otherwise my head hits the keyboard and it brokes
14:49:56 <procyon112> ?hoogle (.=.)
14:49:57 <lambdabot> Did you mean: (.=.)
14:49:57 <lambdabot> Prelude.undefined :: a
14:49:57 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
14:50:12 <procyon112> ?src (.=.)
14:50:13 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:50:24 <Cheery> (the keyboard, not the head)
14:51:15 <josephholsten> I hate to interrupt, but I have a simple question. Where is a good small app (smaller than darcs!) to read, break, and learn from.
14:51:45 <josephholsten> maybe a stupid webapp?
14:52:09 <procyon112> josephholsten: Try going through "How to write a scheme in 48 hours"
14:52:31 <josephholsten> oh, I hadn't gotten to that tutorial.
14:52:34 <DRMacIver> People don't write webapps in Haskell. Only compilers for functional languages. :)
14:52:40 <procyon112> ?google scheme 48
14:52:42 <lambdabot> http://s48.org/
14:52:43 <lambdabot> Title: Scheme 48
14:53:17 <sjanssen> josephholsten: lambdabot is a fairly large application, but it is easy to just pick at specific little parts
14:53:25 <procyon112> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
14:53:26 <josephholsten> oh! that was the scheme I always used
14:53:28 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/l986o
14:53:29 <SamB> DRMacIver: what about hpaste?
14:53:48 <procyon112> josephholsten: not scheme48 :)  The second URL...
14:54:01 <sjanssen> josephholsten: are you interested in fiddling with an X11 window manager?  xmonad is less than 500 lines of code
14:54:11 <DRMacIver> SamB: I'm possibly not being entirely seirous. :)
14:54:22 <sjanssen> DRMacIver: let's avoid the misinformation for now
14:54:24 <Japsu> sjanssen: HA! wasn't that supposed to be less than four hundred? :P
14:54:26 <SamB> however, reading, writing, and breaking programming language implementations is not a bad idea
14:54:36 <DRMacIver> SamB: But also not entirely not serious. There are a lot more compilers, interpreters, etc. written in Haskell than web apps.
14:54:48 <sjanssen> japsu: the propaganda is out of date
14:55:09 <SamB> DRMacIver: that is probably because they are so fun to write in Haskell
14:55:12 <DRMacIver> sjanssen: But misinformation is fun!
14:55:18 <sjanssen> Japsu: in the meantime we grew xinerama and tiling support
14:55:20 <josephholsten> less than 500 lines I can do. assuming it is sane. keep in mind I don't know what sane haskell looks like
14:55:25 <Japsu> sjanssen: bah
14:55:28 <procyon112> It has always been less than 500 LOC.  To suggest otherwise borders on thoughtcrime
14:56:07 <SamB> Japsu: what? you wanted to use a window system with only one window ever open at a time?
14:56:13 <josephholsten> I'm more of a tooling guy, but everybody always wants a webapp
14:56:25 <SamB> (or at least on the screen at a time)
14:57:05 <josephholsten> I'm an undergrad, and surveilling the landscape for research topics.
14:57:11 <procyon112> josephholsten: You can be both!  Implement awk in Web 2.0!
14:57:20 <josephholsten> DIE!!!!
14:57:30 <SamB> procyon112: what the hell is Web 2.0?
14:57:35 <Japsu> SamB: nah, I use a window manager that's a few tens of thousands of LOC in C++
14:57:36 <SamB> I don't know of any such language.
14:57:41 <DRMacIver> I think L-Shift have a Haskell + Lots of Javascript wiki
14:57:45 <josephholsten> wait, isn't that the recent update to yahoo pipes?
14:57:52 <procyon112> SamB: Same as web 1.0, but now with new and improved buzzwords!
14:57:55 <SamB> Yahoo Pipes?
14:57:59 <DRMacIver> http://www.lshift.net/blog/2006/07/13/writing-ajax-applications-in-haskell
14:58:01 <lambdabot> Title: LShift Ltd.  Writing AJAX applications in Haskell, http://tinyurl.com/yyfl2g
14:58:22 <Japsu> waaagh THIS is evil.
14:58:23 <josephholsten> y! pipes are like unix pipes for feeds.
14:58:26 <SamB> I thought Web 2.0 meant "now JavaScript is actually good for something besides menus that don't work"
14:58:28 <DRMacIver> I've not really looked at the code though
14:58:40 <mux> SamB: lol
14:58:42 <DRMacIver> SamB: Javascript is good for all sorts of things. :)
14:58:58 <DRMacIver> Unfortunately "adding behaviour to web pages" happens to not be one of them.
14:59:37 <SamB> DRMacIver: "making webpages more responsive to those with it" is apparantly one of them, though...
14:59:39 <procyon112> Javascript is Scheme with crappy syntax
14:59:44 <josephholsten> web 2 means whatever you want, but really it means: the web based on the stuff that survived the bust
15:00:06 <DRMacIver> SamB: Well, that's a part of 'behaviour' :)
15:00:25 <josephholsten> javascript is scheme that is installed on every machine
15:00:46 <josephholsten> plus evil exception handling
15:00:48 <SamB> DRMacIver: I mean, making it so that sometimes when you click on something, stuff happens faster
15:00:57 <DRMacIver> Yes. That's a type of behaviour. :)
15:01:04 <SamB> what is the problem here?
15:01:11 <procyon112> josephholsten: Yes.. now, if we could get a DECENT implementation of scheme on ever machine we might have something.
15:01:21 <SamB> as long as basically the same thing happens if the javascript does not work?
15:01:35 <josephholsten> all I've got is guile at my university
15:01:41 <narain> procyon112: people *have* written scheme interpreters in javascript
15:01:52 <DRMacIver> Allow me to clarify the above comment: I use and like Javascript. I use it enough that I'm fully aware in far more detail than I wish to be that the browser APIs and implementations blow goats.
15:01:57 <procyon112> narain: and vice-versa
15:01:57 * monochrom gives DRMacIver a cookie
15:01:59 <SamB> narain: were they decent?
15:02:09 <narain> so if you really want scheme in a browser you can write a scheme program and run the interpreter on it
15:02:13 <josephholsten> stupid me, I used to go to northeastern in boston. I look intro to programming from mathias felleisen
15:02:14 <DRMacIver> monochrom: *munch*
15:02:16 <thoughtpolice> does anybody happen to know of a way to mount an FTP connection to a filesystem? Or better yet, does anybody know of an existing module built on top of FUSE for FTP? I want to be able to push my darcs patches over onto my remote website using FTP as a filesystem so it'll be easy; this is because I don't have SSH access for sending it via darcs.
15:02:19 <narain> SamB: i'm not too sure
15:02:29 <narain> didn't look at it very closely
15:02:38 <narain> ?go scheme in javascript
15:02:40 <lambdabot> http://javascript.crockford.com/little.html
15:02:40 <lambdabot> Title: The Little JavaScripter
15:02:58 <procyon112> narain: a meta-circular interpreted browser script is just a couple layers of abstraction beyond sanity
15:03:43 <SamB> thoughtpolice: you can't just FTP upload a pushed-to darcs repo?
15:04:05 <DRMacIver> A scheme -> javascript compiler is surely more reasonable. :)
15:04:20 <josephholsten> thoughtpolice: http://ftpfs.sourceforge.net/
15:04:21 <lambdabot> Title: FTP File System
15:04:35 <narain> procyon112: well that's not a problem then, because scheme-in-javascript is not metacircular :)
15:04:37 <thoughtpolice> SamB: I could, but I just find it annoying
15:04:39 <thoughtpolice> josephholsten: thanks a bunch
15:04:42 <procyon112> Just what AJAX needs... JIT compilation to Javascript...
15:04:49 <DRMacIver> (I think there are implementations which compile lisp subsets to Javascript. I don't think there's a fullblown scheme -> java compiler)
15:05:06 <josephholsten> was kawa
15:05:10 <thoughtpolice> i mean, i just don't want my ftp client open and having to deal with it all the time.
15:05:22 <DRMacIver> josephholsten: Kawa is a scheme implementation on the JVM isn't it?
15:05:24 <josephholsten> how does that work
15:05:28 <josephholsten> ?go kawa
15:05:30 <lambdabot> http://www.gnu.org/software/kawa/
15:05:30 <lambdabot> Title: The Kawa language framework
15:05:35 <monochrom> Lambdabot may be too large and advanced due to hs-plugins.  If you ignore hs-plugins, Lambdabot is actually suitable.
15:05:36 <josephholsten> cool
15:05:48 <SamB> thoughtpolice: what? no scriptable FTP client?
15:05:49 <monochrom> Oh, there is also Yi the editor.
15:05:49 <DRMacIver> Java and Javascript have sod all to do with eachother. :)
15:06:13 <procyon112> DrMacIver: I think that Javascript doesn't have native continuations, so call/cc and some of the unwind guards would be difficult... but overall the languages are so similar that for most programs, transformation would be pretty trivial.
15:06:18 <josephholsten> sure they do. languages that were interesting at first, killed by marketing machines
15:06:20 <SamB> lambdabot doesn't use hs-plugins much these days, does it?
15:06:36 <SamB> can it build dynamically again yet?
15:07:00 <SamB> (thus avoiding the really really really slow link step)
15:07:05 <thoughtpolice> SamB: i'm a lazy slob
15:07:08 <thoughtpolice> :(
15:07:17 <SamB> thoughtpolice: ah.
15:07:19 <monochrom> Dunno.  But as a learner taking up a program looking for things to learn and experiment, any reference to any extra stuff may confuse.
15:07:24 <DRMacIver> procyon112: Yeah. Although javascript 1.7 has generators, and Rhino's flavour of javascript has native continuations.
15:07:28 <thoughtpolice> SamB: i'll get around to ftp one of these days
15:07:29 <SamB> well, wouldn't that be all the more reason to have a scriptable client
15:07:32 <SamB> ?
15:07:33 <narain> are heyting algebras ever useful in haskell programming? or computer science in general?
15:07:40 <thoughtpolice> my linux  box already recieves all my mail and chats and crap
15:07:41 <DRMacIver> procyon112: The main unpleasantness is that normal Javascript implementations don't TCO.
15:07:46 <thoughtpolice> i doubt ftp would hurt that much
15:07:48 <SamB> hating algebras are very useful!
15:07:49 <thoughtpolice> SamB: absolutely.
15:08:03 <monochrom> narain: Yes.
15:08:23 <procyon112> DRMacIver: I thought TCO was part of javascript... maybe I'm thinking of a wishlist I read :)
15:08:30 <DRMacIver> procyon112: 'fraid not.
15:08:35 <SamB> you can use them to calculate hate, which you run into a lot in CS
15:09:00 <monochrom> In Haskell there are type constructors (,), Either, and ->.  These are Heyting algebra operators.
15:09:16 <DRMacIver> procyon112: As far as I'm aware there are no tail call optimising javascript interpreters in the wild.
15:09:26 <DRMacIver> Rhino does it when running with continuations, but that's about it.
15:10:10 <procyon112> TCO should just be a given, in any language...  IMNSHO
15:10:17 <DRMacIver> No argument here.
15:10:27 <SamB> well, in Python they argue that it makes debugging harder
15:10:33 <sorear> hi!
15:10:39 <narain> monochrom: can you elaborate? i don't see how they would be bounded
15:10:42 <sorear> tco?
15:10:44 <DRMacIver> In Java they whine about accurate stack traces.
15:10:45 <monochrom> Critical thinking should also be just a given, in any programmer.
15:10:52 <procyon112> sorear: Tail Call Optimization
15:10:53 <DRMacIver> sorear: Tail call optimisation.
15:10:57 <procyon112> jinx
15:11:00 <sorear> @quote stereo
15:11:01 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
15:11:04 <SamB> DRMacIver: pretty much they same, yes.
15:11:09 <monochrom> -> is implication, (,) is conjunction, Either is disjunction.
15:11:21 <DRMacIver> SamB: True I suppose.
15:11:31 <SamB> Haskell programmers don't care because stack traces are useless anyway
15:11:38 <sorear> -> is exponentiation, (,) is multiplication, Either is addition
15:11:39 <SamB> er. s/they/the/
15:11:48 * narain chews on monochrom's statement
15:11:51 * DRMacIver finds stack traces very useful.
15:12:04 <DRMacIver> Although I'd possibly find them less so if I didn't get so damn many of them. :)
15:12:06 <narain> i didn't expect CH isomorphism to show up
15:12:31 * monochrom finds stack traces very useful wherever stack traces are decreed to be useful.
15:12:39 <SamB> sorear: you are comparing with boolean algebra?
15:12:58 <SamB> monochrom: decreed?
15:13:19 <monochrom> indoctrinated
15:13:21 <DRMacIver> monochrom: fix $ (:) "DRMacIver finds circular references useful wherever "
15:13:42 <monochrom> This one needs (++) instead of (:)
15:13:48 <DRMacIver> Oops, yes
15:13:54 <procyon112> @quote procyon112
15:13:55 <lambdabot> procyon112 says: The other day I tried to say "fix fix" in lojban and couldn't stop talking until my stack blew!  Thank God I never learned the tail recursive way to say it!
15:14:24 <SamB> heh
15:14:29 <SamB> @quote stack
15:14:30 <lambdabot> ghc says: internal error: scavenge_mark_stack: unimplemented/strange closure type -1368815400 @ 0x2aaaae6981f8
15:14:33 <SamB> @quote stack
15:14:34 <lambdabot> emu says: hijack the stack and take this compiler to Fun-land!
15:14:34 <xerox> > fix (showString "or this way ")
15:14:36 <lambdabot>  "or this way or this way or this way or this way or this way or this way or ...
15:14:54 <SamB> hmm, funny, I think I know how to get that GHC error ;-)
15:14:59 <josephholsten> anyone read this blog, know this guy?
15:15:01 <josephholsten> http://mult.ifario.us/
15:15:02 <lambdabot> Title: mult.ifario.us
15:15:10 <SamB> (roughly)
15:15:40 <SamB> (with array size overflow)
15:16:22 <sorear> SamB: no, the algebra in algebraic datatype.
15:16:58 <monochrom> I prefer to answer "see scrollback".
15:17:00 <SamB> @quote stack
15:17:01 <lambdabot> apfelmus says: Ah, yet another UndeadArray necromancer exhausting his stack of bones. May the forces of light suggest to structure the incantation of darkness?
15:17:29 <SamB> @quote stack
15:17:30 <lambdabot> ghc says: Use -fcontext-stack20 to increase stack size to (e.g.) 20
15:20:40 <eumenides> this should be fixed:
15:20:49 <eumenides> > fix ("some string"++)
15:20:51 <lambdabot>  "some stringsome stringsome stringsome stringsome stringsome stringsome stri...
15:21:05 <eumenides> ah
15:21:14 <sorear> fixed?
15:21:14 <narain> monochrom: a heyting algebra is a lattice with certain properties, right? and a lattice is a set with two operators join and meet?
15:21:23 <sorear> snd is correct
15:21:24 <narain> > fix ("rhubarb " ++)
15:21:26 <lambdabot>  "rhubarb rhubarb rhubarb rhubarb rhubarb rhubarb rhubarb rhubarb rhubarb rhu...
15:21:38 <narain> sorear: fst is not?
15:21:40 <eumenides> it used to print a lot more
15:21:56 <SamB> narain: you mean "lub" and "glub"
15:21:57 <sorear> narain: fst is "I have no idea what a heyting algebra is"
15:21:59 <Saizan> eumenides, only in query
15:22:27 <eumenides> Saizan: ahh
15:22:39 <sorear> eumenides: the cutoff to 80 chars only applies when output is to channel, see the ios80 function in Plugin.hs
15:22:57 <narain> sorear: that would be a correct inference. i was going by the wikipedia article
15:23:20 <monochrom> Heyting algebra adds -> to lattice.
15:23:44 <sorear> well, (,) and `Either` do not induce a lattice.
15:23:54 <sorear> for one thing they aren't idempotent.
15:24:00 <narain> sorear: which is what confused me
15:24:24 <monochrom> Oops.
15:24:31 <narain> monochrom: ok, what properties should -> have?
15:24:48 <sorear> We DO have a semiring: (,)=* `Either`=+ ()=1 Void=0
15:25:04 <sorear> ->=^, but that's not a standard semiring operator
15:25:20 <sorear> if you count _|_ it's unfortunatly just a semirng
15:25:55 <narain> i can only learn one abstract algebra concept at a time
15:26:00 <narain> :(
15:27:34 <narain> wait, maybe i can get this (having just consulted wikipedia on semirings)
15:27:38 <monochrom> The relation between Heyting algebra and (,), Either, -> is too fragile.
15:27:40 <narain> sorear: what's Void?
15:27:41 <Saizan> (,) () Int == Int for which value of ==?
15:27:52 <sorear> newtype Void = Void Void
15:28:24 <narain> ah, a type with zero values?
15:28:53 <sorear> Saizan: modulo _|_.   if we count _|_ we lose 0 and 1, but we still have {distribu,commu,associ}tivity (I think)
15:29:01 <sorear> narain: yes
15:29:16 <monochrom> Don't worry about _|_.  The algebra is easier.
15:30:11 <narain> i like the semiring of types. very elegant
15:31:11 <sorear> Notice that type-of is order 2 and always raises sort by one.
15:31:33 <sorear> I have a deep suspicion that some kind of cohomology structure is definable.
15:31:56 <narain> type-of?
15:32:13 <sorear> typeOf('a') = Char ; typeOf(Char) = *
15:33:06 <monochrom> Yes! There is some advanced application of algebraic geometry (even algebraic topology) to programming.
15:33:43 <narain> sorear: is typeOf actual haskell or have we gone meta?
15:34:02 <Saizan> ?hoogle typeOf
15:34:03 <lambdabot> Data.Typeable.typeOf :: Typeable a => a -> TypeRep
15:34:03 <lambdabot> Data.Typeable.typeOf1 :: Typeable1 t => t a -> TypeRep
15:34:03 <lambdabot> Data.Typeable.typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
15:34:06 <SamB> meta for sure
15:34:10 <SamB> > typeOf 'a'
15:34:11 <lambdabot>  Char
15:34:15 <SamB> hmm.
15:34:20 <narain> whoa
15:34:26 <SamB> > typeOf (typeOf 'a')
15:34:28 <lambdabot>  TypeRep
15:34:34 <SamB> see, that is not the same as *!
15:34:49 <narain> ?src TypeRep
15:34:50 <lambdabot> Source not found. Where did you learn to type?
15:34:59 <monochrom> > typeOf TypeRep
15:35:00 <lambdabot>   Not in scope: data constructor `TypeRep'
15:35:15 <chessguy> @yow
15:35:16 <lambdabot> We are now enjoying total mutual interaction in an imaginary hot
15:35:16 <lambdabot> tub ...
15:35:18 <narain> > iterate typeOf 'a'
15:35:20 <lambdabot>  Couldn't match expected type `TypeRep' against inferred type `Char'
15:35:21 <monochrom> > typeOf (undefined :: TypeRep)
15:35:22 <SamB> :t typeOf
15:35:22 <lambdabot>  TypeRep
15:35:25 <lambdabot> forall a. (Typeable a) => a -> TypeRep
15:35:31 <chessguy> man it took a while for freenode to authenticate me
15:35:48 <monochrom> good morning chessguy
15:35:57 <chessguy> 'evening, monochrom
15:36:10 <narain> > typeOf . typeOf . typeOf $ 'a'
15:36:12 <lambdabot>  TypeRep
15:36:39 <Saizan> > fix typeOf
15:36:40 <lambdabot>  TypeRep
15:36:48 <monochrom> "iterate typeOf 'a'" has an infinite type problem
15:37:08 <monochrom> and hence, "fix typeOf" is also going to be uninteresting
15:37:26 <SamB> > iterate typeOf . typeOf $ 'a'
15:37:28 <lambdabot>  [Char,TypeRep,TypeRep,TypeRep,TypeRep,TypeRep,TypeRep,TypeRep,TypeRep,TypeRe...
15:37:48 <SamB> > fix typeOf . typeOf $ 'a'
15:37:49 <lambdabot>  Couldn't match expected type `b -> c'
15:37:53 <SamB> hmm.
15:37:58 <SamB> :t fix typeOf
15:38:01 <lambdabot> TypeRep
15:38:02 <sorear> and yes, I did mean meta
15:38:07 <SamB> > fix typeOf
15:38:09 <lambdabot>  TypeRep
15:38:16 <sorear> I forgot there was a real typeOf :)
15:38:23 <SamB> oh, I see Saizan alread did that...
15:38:31 <narain> sorear: so (,) and `Either` don't form a lattice or a heyting algebra?
15:38:38 <SamB> sorear: well, it is a rather lame one ;-)
15:38:39 <narain> or do they? i'm confused
15:38:57 <chessguy> so a type is really just a set of values, right?
15:39:07 <sorear> narain: dunno about heyting algebras, but they fail the lattice laws
15:39:14 <sorear> x `join` x == x
15:39:26 <SamB> chessguy: perhaps
15:39:29 <procyon112> > typeOf (\x y z -> x z (y z)
15:39:30 <sorear> (Int , Int) >> Int
15:39:30 <lambdabot>  Parse error
15:39:34 <SamB> but that does not explain newtype
15:39:36 <procyon112> > typeOf (\x y z -> x z (y z))
15:39:38 <lambdabot>        add an instance declaration for
15:39:38 <lambdabot>       (Typeable1 ((->) t),
15:39:38 <lambdabot>        Type...
15:39:48 <sorear> SamB: newtypes are transparent
15:40:01 <SamB> in that case it does not explain typeclass instances
15:40:03 <dmwit> :t typeOf
15:40:06 <lambdabot> forall a. (Typeable a) => a -> TypeRep
15:40:15 <dmwit> ?index TypeRep
15:40:15 <lambdabot> Data.Typeable, Data.Dynamic, Data.Generics.Basics, Data.Generics
15:40:32 <SamB> sorear: I was kind of under the impression that that was what type synonyms were for
15:40:35 * sorear just realised there exists a forgetful functor from data types to cardinal numbers
15:41:08 <SamB> forgetful functor? is that like a type constructor that takes phantom types?
15:41:10 <narain> well, wikipedia, planetmath and some guy's lecture notes all claim that a heyting algebra is a special case of a lattice
15:41:17 <narain> sorear: ^^^
15:41:34 <sorear> SamB: newtypes are non-transparent during type checking because its easier to understand, and it affects class resolution. operationally they don't exist.
15:41:34 <thoughtpolice> damn. darcs doesn't like curlftpfs apparently :(
15:41:59 <thoughtpolice> i'll just have to wait until my host responds and try to get minimal ssh access :(
15:42:06 <ddarius> Replace "=" with "~="
15:42:09 <sorear> narain: by the law of contrapositive, I conclude (Type, (,), Either) does NOT form one.
15:42:19 <SamB> sorear: typeclass resolution is not just part of some "checking" process
15:42:54 <sorear> SamB: it also guides the desugarer, yes...
15:43:11 <sorear> ddarius: ?
15:43:37 <narain> sorear: ...which brings me back to my original question: are heyting algebras useful in haskell programming? or computer science in general? i ask because i'm trying to understand them and it would be nice to have some context from CS
15:43:44 <ddarius> Modulo the fact that Haskell isn't really all that nice, * (,) and Either do form let's call it a weak Heyting algebra
15:44:45 <ddarius> narain: Heyting algebras : Boolean Algebras :: Intuitionistic logic : Classical logic
15:44:55 <ddarius> They are also the internal logic of a topos.
15:45:06 <chessguy> so if a type is basically just a (possibly infinite) set, what is an infinite type?
15:45:22 <narain> ddarius: i'm afraid i don't know enough to get something out of those statements
15:46:26 <ddarius> narain: You understand Boolean algebra and presumably classical logic, and you pretty much do intuitionistic logic as well.
15:46:27 <sorear> chessguy: an infinitely complicated type, or more correctly a self-referential one.
15:47:01 <chessguy> the generating function is self-referential?
15:47:11 <ddarius> But my first two statements (replacing = with ~=) are the relevant ones.
15:47:31 <dmwit> chessguy: I think it means the type contains itself.
15:48:58 <chessguy> oh well, i guess i'll just wait until i get TAPL :)
15:49:04 <Saizan> ddarius,  so (Int,Int) ~= Int ?
15:49:41 <ddarius> And throw in proof irrelevance.
15:50:49 <sorear> It's hardly Haskell once you have that :)
15:50:53 <Saizan> well, by witch definition of ~= this holds?
15:51:13 <sorear> exact equality, with SN and proof irrelevance.
15:51:30 <sorear> but proof irrelevance is a pretty big hammer.
15:51:45 <Saizan> SN?
15:51:48 * narain goes off to read about intuitionistic logic
15:51:50 <ddarius> sorear: Well, yeah, with proof irrelevance you get a logic not a programming language (or maybe a logic language...?)
15:51:52 <sorear> strong normalization.
15:51:52 <procyon112> chessguy: an infinite type is self referencial.. like type a == type a->a.  If you replace a with a->a, you get (a->a)->(a->a), and so on, infinitely.  The construct isn't neccissarily complex, but it is infinite.
15:52:19 <sorear> Saizan: strong normalization.  the property possessed by languages without _|_.
15:52:34 <chessguy> procyon112: i guess i was looking for a more formal definition
15:52:56 <chessguy> in terms of set theory
15:53:26 <sorear> chessguy: the wikipedia article on Curry's Paradox is enlightening on why type theorists don't like infinite types imo
15:53:46 <procyon112> chessguy: The formal definition is that a type variable appears on both sides of the type constraint... hence a==a->a is infinite, as would be a==a->Int
15:54:01 <dmwit> procyon112: Surely that can't be right.
15:54:09 <dmwit> a == a should be just fine!
15:54:49 <procyon112> dmwit: ok, ok... they appear on both sides, but are not equal.
15:55:01 <narain> what's proof irrelevance? is it that as long as you have a value of the desired type, it doesn't matter what the value actually is?
15:55:10 <procyon112> > (\x -> x x)
15:55:11 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
15:55:11 <lambdabot>     Probab...
15:55:19 <sorear> narain: yes
15:55:25 <sorear> narain: so, no case
15:56:19 <narain> that would be quite a different programming language
15:57:21 <procyon112> narain: it is the language of typecheckers
15:57:38 <SamB> so, who may I prove to be irrelevant?
15:57:54 <procyon112> I'm irrelevant, but I can't prove it yet
15:58:27 <SamB> too bad. you probably won't be once you figure out how to do it!
16:00:13 <narain> i now have too many dangling pointers in my head to concepts i don't understand
16:00:14 <procyon112> SamB: If I prove that I am irrelevant, and that makes me relevant, I think I will be Curry's paradox incarnate.
16:01:11 * narain thinks he will end up spending the week chasing pointers to abstract mathematical concepts rather than doing whatever work he's actually supposed to be doing
16:01:28 <procyon112> :t (\x -> x ap const)
16:01:31 <lambdabot> forall (m :: * -> *) a b a1 b1 t. (Monad m) => ((m (a -> b) -> m a -> m b) -> (a1 -> b1 -> a1) -> t) -> t
16:01:39 <procyon112> wow
16:01:51 <monochrom> Don't be too hard on yourself.
16:02:57 <procyon112> :t (\f -> f (\x y z -> x z (y z)) (\a b->a))
16:03:00 <lambdabot> forall t t1 t2 t3 t4 t5. (((t -> t1 -> t2) -> (t -> t1) -> t -> t2) -> (t3 -> t4 -> t3) -> t5) -> t5
16:03:04 <monochrom> @djinn (a,a)->a
16:03:05 <lambdabot> f (a, _) = a
16:03:20 <monochrom> @djinn a->(a,a)
16:03:21 <lambdabot> f a = (a, a)
16:03:29 <narain> if i haven't bothered everyone enough, can someone tell me what makes a lattice a heyting algebra? the definition wikipedia gives seems tautological to me
16:03:34 <monochrom> djinn practices intuitionistic logic.  start from there.
16:03:56 <procyon112> @djinn (a->a)->a
16:03:57 <lambdabot> -- f cannot be realized.
16:04:15 <sorear> he said intuitionistic, not inconsistant :)
16:04:21 <narain> ?djinn a -> Either a b
16:04:21 <lambdabot> f = Left
16:04:32 <narain> ?djinn Either a b -> (a,b)
16:04:33 <mux> chessguy: bah, I hadn't realised that I need to know the way pieces move to disambiguate SAN
16:04:33 <lambdabot> -- f cannot be realized.
16:04:35 <procyon112> @djinn (((t -> t1 -> t2) -> (t -> t1) -> t -> t2) -> (t3 -> t4 -> t3) -> t5) -> t5
16:04:36 <lambdabot> f a = a (\ b c d -> b d (c d)) (\ e _ -> e)
16:04:46 <chessguy> indeed
16:05:00 <mux> that sucks
16:05:11 <dmwit> ?. djinn type (\x -> x ap const)
16:05:14 <lambdabot> Cannot parse command
16:05:18 <njd> users
16:05:20 <njd> @users
16:05:21 <lambdabot> Maximum users seen in #haskell: 336, currently: 302 (89.9%), active: 33 (10.9%)
16:05:36 <sorear> hi!
16:05:52 <sorear> actually it's 337, but the bot has developed senile dementia
16:06:00 <dmwit> ?djinn  (Monad m) => ((m (a -> b) -> m a -> m b) -> (a1 -> b1 -> a1) -> t) -> t
16:06:00 <lambdabot> Cannot parse command
16:06:08 <dmwit> ?djinn ((m (a -> b) -> m a -> m b) -> (a1 -> b1 -> a1) -> t) -> t
16:06:09 <lambdabot> -- f cannot be realized.
16:06:24 <sorear> dmwit: nice try. No type classes!
16:06:37 <monochrom> Heyting algebra is lattice plus -> operator satisfying: c   a->b iff ca  b.
16:06:41 * dmwit shrugs -- it was worth a shot
16:07:04 <sorear> monochrom: what is ? ?
16:07:10 <monochrom> unicode
16:07:24 <procyon112> dmwit: FYI, f a = a (\ b c d -> b d (c d)) (\ e _ -> e) is a universal combinator... all combinators can be expressed in terms of it.  Just so you know what I'm playing with :)
16:07:35 <monochrom> sorry I'm fed up with ascii.
16:07:45 <sorear> procyon112: nah, you also need application :)
16:07:46 <dmwit> hm
16:08:03 <procyon112> well duh.. You always need application :P
16:08:05 <narain> monochrom: sorry but i can't see anything
16:08:07 <Pseudonym> But it's not a universal supercombinator, so it's not that useful in practice.
16:08:19 <sorear> monochrom: ok good. I suspected it was unicode *curses linux tty drivers for not supporting unicode*
16:08:28 <narain> darn non-unicode-supporting irc client
16:08:36 <monochrom> THIS IS SUCH A BLOODY DARK AGE
16:08:42 * sorear wishes there were a free, lightweight, unicode-supporting terminal emulater
16:08:46 * narain goes to look at logs in a browser
16:08:55 <procyon112> Pseudonym: It might be for genetic programming... I'm planning on experimenting with it for that.
16:09:05 <monochrom> c \sqsubseteq a \rightarrow b iff c \wedge a \sqsubseteq b
16:09:07 <Pseudonym> Oh, interesting.
16:09:18 <Pseudonym> Yes, if you don't mind lambdas being left over after reduction steps...
16:09:52 <sorear> drivers/char/tty.c is free and lightweight, but not good.  the xterm clones are better, but massively ugly and quite heavywieght once you account for the X server.
16:10:01 <dmwit> sorear: Not urxvt?
16:10:04 <narain> monochrom: what does \sqsubseteq mean?
16:10:08 <sorear> plus they stop you from seeing kernel messages.
16:10:10 <dmwit> Oh, no X.
16:10:21 <narain> it's not \subseteq i presume?
16:10:34 <dmwit> sq stands for square
16:10:42 <Tene> sorear: urxvt?
16:10:43 <dmwit> The rounded corners become boxed ones
16:10:46 <monochrom> The partial order of the lattice.
16:10:51 <narain> oh
16:10:55 <Tene> oh, X
16:11:07 * Tene fail
16:11:17 <sorear> Tene: dmwit beat you :)
16:11:20 <monochrom> I am going for the symbol rather than the meaning.
16:14:39 * Saizan wish it's logic course didn't end with first order predicative logic..
16:14:56 <Saizan> s/wish/wishes/
16:15:11 <sorear> it?
16:15:28 <Saizan> soh
16:15:33 <Saizan> "his"
16:16:06 <narain> sorear, monochrom: thanks for the help. i still don't quite get it, but now it feels a lot more like at some point it'll all fall into place
16:16:15 <sorear> At least in my backward country it usually implies something other than a human is being refered to, so I had to ask :)
16:16:49 <procyon112> momocrom: ASCII was the classical age.  Unicode brought about the dark ages.  We are still waiting for our renaissance
16:17:17 <Pseudonym> What's wrong with unicode?
16:17:20 <Pseudonym> Lots of things, I know.
16:17:26 <Pseudonym> I'm curious as to what annoys you the most.
16:17:44 <procyon112> Ummm... the spec would break my desk were I to print it out :)
16:18:04 <Pseudonym> I have more paper than that on my desk at the moment.
16:18:25 <Pseudonym> But TBH, so would the spec for Unix.
16:18:41 <Pseudonym> And so would the spec for C++.
16:18:46 <Pseudonym> OK, maybe that last one proves your point.
16:19:04 <Pseudonym> But there are a lot of specs that are that big or bigger.
16:19:21 <Pseudonym> And the ugliness is all inherent.
16:19:28 <SamB> how long is the spec for ASCII?
16:19:30 <Pseudonym> Unicode is ugly because human languages are ugly.
16:19:44 <ozone> nod, unicode's fine
16:19:47 <jcreigh> just because something is big, ugly, and convoluted doesn't mean it's not useful.
16:19:50 <SamB> Pseudonym: also because it is an inelegant conglomeration of characters from a variety of sources
16:19:55 <ozone> especially when you have decent libraries to deal with it
16:20:18 <jcreigh> (In general; I don't know enough about Unicode to say whether or not it's ugly or convoluted. sure seems big, though)
16:20:40 <SamB> but at least it isn't slightly ASCII-incompatible like shift JIS
16:20:43 <ozone> jcreigh: it's not really
16:20:56 <sorear> Unicode isn't that bad if you assume all the world is america/western europe.
16:21:05 <Saizan> i think the problem of unicode is the same of javascript: too much different implementations
16:21:28 <sorear> throw in bidirectionality and verticalness and combining characters and I imagine it gets a *lot* worse.
16:21:48 <procyon112> Unicode breaks down when mixing formats, and 64K is not a large enough namespace for all the glyphs.
16:22:35 <jcreigh> I thought unicode was no longer limited to 16 bits for its code points.
16:22:38 <SamB> sorear: I think unicode tries to support too much or too little
16:22:40 <Pseudonym> Indeed.
16:22:42 <procyon112> sorear: We broke windows when we tried to embed an english quote in a Hebrew page a few months ago... sent Vista bluescreening
16:22:45 <ozone> jcreigh: it's not
16:22:56 <Pseudonym> UCS32 _is_ plenty.
16:23:05 <Pseudonym> You don't need more glyphs than there are humans.
16:23:26 <Pseudonym> When we meet our first intelligent aliens, we might be in trouble, of course.
16:23:33 <procyon112> Well, if each human want's his own 64K of glyphs... I might want to doodle alot ;)
16:23:33 <Pseudonym> If their planet has as many scripts as ours.
16:23:34 <SamB> Pseudonym: I'm going to ask you about that the next time someone almost wipes out life on earth
16:23:59 <Pseudonym> Ah, here's the ASCII spec.
16:24:06 <Pseudonym> Damn, it costs $30.
16:24:10 <procyon112> lol
16:24:11 <desp> SamB: what was the last time?
16:24:13 <Pseudonym> 2.28MB of PDF.
16:24:17 <SamB> desp: I don't know
16:24:19 <Pseudonym> How many pages, do you think?
16:24:20 <SamB> nobody remembers!
16:24:24 <desp> :D
16:24:25 <SamB> actually it probably did not happen
16:24:27 <desp> good poin
16:24:29 <desp> t
16:24:36 <ozone> Pseudonym: 69?
16:24:42 <jcreigh> ASCII is kinda fun in places. like when you realizes that the difference between uppercase and lowercase is flipping the fifth bit.
16:24:56 <Botje> @quote bit
16:24:57 <lambdabot> beelsebob says: [lambdabot] Parse error [beelsebob] where bitch?
16:25:00 <desp> ECBDIC is even more fun
16:25:01 <procyon112> Whenever someone wants a new glyph, they should just give it a new GUID... that will hold us until 2038 :)
16:25:11 <jcreigh> desp: I meant in a good way
16:25:17 <desp> :)
16:25:26 <Botje> procyon112: aren't GUIDs 8 bytes?
16:25:32 <sorear> 16
16:25:49 <procyon112> yup 16
16:25:49 <sorear> LUIDs are 8 iirc
16:25:59 <jcreigh> "L"?
16:26:01 <sorear> not that anyone ever uses those :)
16:26:09 <sorear> @goo Locally unique identifier
16:26:12 <lambdabot> http://genome.perlegen.com/browser/download.html
16:26:41 <Botje> "And don't tell me there isn't one bit of difference between null and space, because that's exactly how much difference there is.  :-)" -- Larry Wall
16:27:23 <Pseudonym> Botje: He obviously didn't know about unicode at the time.
16:27:30 <Pseudonym> How many kinds of space are there?
16:27:38 <Botje> it's a posting from 1990, fwiw.
16:28:02 <SamB> Pseudonym: those don't really count as space
16:28:05 <narain> Pseudonym: blame the typographers for that
16:28:13 <SamB> space is '\x20'
16:28:24 <Pseudonym> If isspace(c), then it's space.
16:28:25 <Botje> silly samB. space is ' '
16:28:27 <narain> em space, en space, hair space, non-breaking space, ...
16:28:46 <procyon112> closet space
16:28:47 <SamB> also typographers should know better than to use characters for anything but newlines and spaces
16:29:18 <SamB> (and that probably those newlines should mean the same thing as the spaces
16:29:31 <procyon112> SamB: saves paper that way
16:29:37 <Saizan> > filter isSpace [(minBound :: Char) .. ]
16:29:39 <lambdabot>  "\t\n\v\f\r \160\5760\6158\8192\8193\8194\8195\8196\8197\8198\8199\8200\8201...
16:29:58 <SamB> Saizan: most of those only apply to typists or crazy people
16:30:05 <jcreigh> > length . filter isSpace $ [(minBound :: Char) .. ]
16:30:07 <narain> and the oxymoronically named character of the day is... Zero-Width Space, U+200B
16:30:07 <lambdabot>  24
16:30:20 <jcreigh> Pseudonym: 24 :)
16:30:45 <Pseudonym> Aha!
16:30:53 <procyon112> narain: shouldn't a zero-width space be called a plane?
16:30:55 <Pseudonym> Here's ITU-T T.50.
16:31:07 <Pseudonym> Let's see what this sucker weighs in at.
16:31:08 <SamB> Botje: how do I know you didn't sneak a non-breaking space in there or something tricky like that?
16:31:09 <Pseudonym> 22 pages!
16:31:16 <Pseudonym> That's not long at all for an ITU standard.
16:31:23 <Botje> SamB: my spidey sense says so :)
16:31:26 <Pseudonym> And that's not just US-ASCII.
16:31:41 <SamB> Botje: how do I know that your spidey sense is honest?
16:31:45 <Pseudonym> http://www.itu.int/rec/T-REC-T.50-199209-I/en
16:31:48 <lambdabot> Title: International Reference Alphabet (IRA) (Formerly International Alphabet No. 5 or ...
16:31:50 <SamB> Pseudonym: is that also JP-ASCII?
16:31:57 <Pseudonym> SamB: Might be.
16:32:03 <Pseudonym> It's the International Reference Alphabet.
16:32:07 <Pseudonym> Of which US-ASCII is the US version.
16:32:08 <Botje> SamB: it sends money to hungry children every month.
16:32:20 <SamB> Botje: you could still be lying
16:32:46 <SamB> really, the only way to be sure is to pass it to unicode(1)
16:32:50 <Pseudonym> Yup, at least 4 of those 22 pages define what an octet is.
16:32:59 <Pseudonym> This is definitely an ITU standard.
16:33:19 <procyon112> I like International Alphabet no. 5 better.  It sounds like the artificial color in my breakfast cereal.
16:33:48 <jcreigh> "eight bits, possibly minus one because some network transports arbitrarily nuke the eight bit"?
16:33:49 <Pseudonym> "A 7-bit code table consists of 128 positions arranged in 8 columns and 16 rows. The columns are numbered 0 to 7 and the rows 0 to 15."
16:33:54 <Pseudonym> I'm glad we cleared that up.
16:34:14 <Pseudonym> No 64*2 tables for us, no sir.
16:34:22 <Pseudonym> Must be 16*8.
16:34:59 <Saizan> anarchist!
16:37:04 <SamB> Pseudonym: that doesn't even tell us which column is more significant!
16:37:17 <SamB> personally I prefer 0 to F
16:37:29 <procyon112> I like the one with 'Q' in it
16:38:09 <SamB> > '\x23'
16:38:11 <lambdabot>  '#'
16:38:20 <SamB> oh is that what that is supposed to be
16:38:29 <narain> '\x42'
16:38:34 <narain> > '\x42'
16:38:36 <lambdabot>  'B'
16:38:50 <narain> *that's* the answer? 'B'??
16:39:12 <Pseudonym> SamB: Actually, that's the next clause.
16:39:17 <Pseudonym> Which column is significant.
16:39:51 <procyon112> hehe
16:40:09 <Saizan> @remember naraim <narain> > '\x42' <lambdabot>  'B'  <narain> *that's* the answer? 'B'??
16:40:10 <lambdabot> Done.
16:41:02 <Pseudonym> I love reading standard.
16:41:03 <Pseudonym> s
16:41:11 <narain> oops. we were looking for a question. sorry.
16:41:28 <Pseudonym> The first clause of the recommendations is words to the effect of "When making national standards based on these documents, we recommend that you follow the following recommendations."
16:41:44 <Saizan> naraim: amusing anyway :D
16:41:53 <narain> :)
16:42:09 <bd_> mmm conditional compliance.
16:43:09 <narain> we buffalo that you buffalo the buffalo buffalo buffalo.
16:44:26 <Pseudonym> This message is brought to you by the Department of Redundancy Department.
16:44:37 <narain> ?remember Pseudonym I love reading standards. The first clause of the recommendations is words to the effect of "When making national standards based on these documents, we recommend that you follow the following recommendations."
16:44:38 <lambdabot> Done.
16:44:57 <Pseudonym> Woo.
16:45:00 <Pseudonym> ?quote standards
16:45:00 <lambdabot> Pseudonym says: I love reading standards. The first clause of the recommendations is words to the effect of "When making national standards based on these documents, we recommend that you follow the
16:45:01 <lambdabot> following recommendations."
16:45:03 <Pseudonym> ?quote standard
16:45:04 <lambdabot> Pseudonym says: I love reading standards. The first clause of the recommendations is words to the effect of "When making national standards based on these documents, we recommend that you follow the
16:45:04 <lambdabot> following recommendations."
16:45:34 <narain> ?quote national
16:45:35 <lambdabot> mikaeli says: hmm, one national tv station I was watching while eating breakfast crashed with bsod. I guess that's what you get for running windows in production use
16:53:41 <Botje> ?src zip
16:53:42 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
16:53:42 <lambdabot> zip _      _      = []
17:04:25 <Saizan> http://haskell.org/ghc/dist/current/docs/libraries/haskell-src/Language-Haskell-Syntax.html <-- and i thought TH's AST was big..
17:04:27 <lambdabot> http://tinyurl.com/2gokwm
17:05:29 <mux> 'I ask this question because I want to program a recently published
17:05:32 <mux> algorithm for directly enumerating all prime numbers.'
17:05:37 <mux> late april fool's joke. :)
17:06:36 <sorear> > nubBy(((>1).).gcd)[2..]  -- anyone who thinks the prime numbers are non-denumerable should be retroactively flunked from first year set theory
17:06:38 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
17:06:49 <sorear> or do I misunderstand 'directly'?
17:07:07 <mux> directly means O(1) to me here
17:07:22 <mux> maybe I got him wrong
17:07:37 <narain> mux: where was this?
17:07:44 <sorear> ml
17:08:36 <narain> ml?
17:08:46 <mux> haskell-cafe@
17:09:25 <sorear> ailing ist
17:09:34 <narain> ah
17:09:35 <SamB> my understanding would be that it meant "without having to check them for primality somehow"
17:09:40 <SamB> ailing, eh?
17:09:57 <narain> zipWith (:)
17:10:18 <SamB> sorear: I cannot be flunked from any such thing...
17:10:25 <sorear> nor can I.
17:10:40 <SamB> well you are still in highschool, aren't you ?
17:10:44 <sorear> nor should you be.
17:10:46 <sorear> yes.
17:11:02 <procyon112> > [ x | x <- [2..], y <- [2 .. sqrt x], mod x y /= 0]
17:11:04 <lambdabot>  Add a type signature
17:11:20 <sorear> anyone who has not a mathematics education is excused for such an otherwise egregious error.
17:11:25 <procyon112> > [ x | x <- [2..], y <- [2 .. sqrt x], mod x y /= 0] ::[Int]
17:11:26 <lambdabot>   add an instance declaration for (Floating Int)
17:11:27 <lambdabot>     In the expression: sqrt ...
17:11:46 <narain> sorear is in high school?
17:11:50 <procyon112> > [ x | x <- [2..], y <- [2 .. sqrt x :: [int]], mod x y /= 0] ::[Int]
17:11:52 <lambdabot>   sqrt x
17:11:52 <lambdabot>     In the expression: sqrt x :: [int]
17:11:52 <lambdabot>     In a list comprehension: ...
17:12:01 <procyon112> > [ x | x <- [2..], y <- [2 .. (sqrt x) :: [int]], mod x y /= 0] ::[Int]
17:12:03 <lambdabot>        add (Floating [int]) to the expected type of an expression
17:12:03 <lambdabot>       or ad...
17:12:13 <procyon112> bah!
17:12:19 <Laney> .
17:12:22 <Laney> oops
17:12:27 <sorear> narain: yes
17:12:36 <procyon112> > [ x | x <- [2..], y <- [2 .. x - 1], mod x y /= 0]
17:12:38 <lambdabot>  [3,4,5,5,5,6,6,7,7,7,7,7,8,8,8,8,9,9,9,9,9,9,10,10,10,10,10,10,11,11,11,11,1...
17:12:45 <procyon112> lol.
17:13:01 <narain> sorear: really?? what high school is this?
17:13:59 <sorear> small private school in san diego where the district sends the more educable of the rejects
17:14:00 <narain> > [ x | x <- [2..], y <- [2 .. (floor . sqrt . fromIntegral $ x) :: [int]], mod x y /= 0]
17:14:01 <monochrom> The Abstract Math High School. :)
17:14:01 <lambdabot>        add (Integral [int]) to the expected type of an expression
17:14:02 <lambdabot>       or ad...
17:14:21 <procyon112> sorear: anyone who has not a mathematics eduaction is excused from flunking set theory?
17:14:21 <narain> bah
17:14:28 <olliej> sorear: hehehe
17:14:35 <monochrom> I mean, the only way this chap knows more intuitionistic logic than me :)
17:14:41 <sorear> where district == the branch of local gov't which is responsible for public education
17:15:10 <narain> > [ x | x <- [2..], y <- [2 .. (floor . sqrt . fromIntegral $ x)] :: [int], mod x y /= 0]
17:15:11 <lambdabot>        add (Integral int) to the expected type of an expression
17:15:12 <sorear> procyon112: they can't retroactively flunk something they haven't taken
17:15:20 <Laney> @src nubBy
17:15:20 <lambdabot> nubBy eq []             =  []
17:15:21 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
17:15:24 <narain> > [ x | x <- [2..], y <- [2 .. (floor . sqrt . fromIntegral $ x)], mod x y /= 0]
17:15:26 <lambdabot>  [5,7,9,10,11,11,13,13,14,15,16,17,17,17,18,19,19,19,20,21,21,22,22,23,23,23,...
17:16:01 * narain doesn't like sorear anymore
17:17:17 <ndm> @seen Igloo
17:17:18 <lambdabot> Igloo is in #haskell-soc, #gentoo-haskell, #ghc, #darcs and #haskell. I last heard Igloo speak 10s ago.
17:17:20 <dcoutts> hia ndm
17:17:20 <olliej> narain: what about me, i've had 6 years of uni, written a haskell compiler, and sorear *still* understands this more than me (by a large margin)
17:17:29 <Igloo> Yo dude
17:17:48 <ndm> Igloo: i go to the trouble of formally proving the absence of pattern match errors in the whole FilePath module, and you introduce one in the Setup.hs file!
17:17:55 <ndm> Igloo: bug report forwarded from Clifford
17:17:56 <sorear> I still haven't written most of my haskell compiler :(
17:17:57 <dcoutts> ha hah ha
17:17:58 <ndm> hi dcoutts
17:17:58 <procyon112> thinking of sorear's understanding of logic when he hits graduate level scares me.
17:18:45 <olliej> sorear: yes, but you haven't experienced the joy of uni yet
17:18:47 <narain> /me's leg has been pulled farther than it will go
17:19:11 <Igloo> ndm: Oh, euch, in removePrefix?
17:19:17 <ndm> Igloo: yep
17:19:35 <dcoutts> ndm: Igloo: want me to make a filepath tarball for hackage ? (once you've fixed whatever bug you're talking about)
17:19:46 <Igloo> ndm: OK, I'll fix it
17:20:11 <ndm> dcoutts: yep please, or fix cabal so i can make them myself
17:20:27 <ndm> i'm releasing my tagsoup library tomorrow, and would like to get that on hackage too
17:20:42 <dcoutts> ndm: tar works on the command line right? and with -z it fails I presume ?
17:21:07 <ndm> dcoutts: yep, seems so. gives an error message about not supporting compression with -z
17:21:30 * sorear managed to completely misread ndm's webpage, and thought tagsoup was long dead
17:21:31 <Igloo> Hmm, even odder, I haven't consistently got it wrong
17:21:39 <dcoutts> ndm: I seem to recall that this was fixed in cabal, but no matter, just run the command that fails, but remove the 'z'
17:21:53 <Igloo> Oh, yes I have, I just got confused
17:22:02 <dcoutts> ndm: then use gzip -9 separately on the .tar file to get  .tar.gz
17:22:14 <dcoutts> ndm: the tar -z flag is just a (in)convenience
17:22:30 <sorear> ndm: is supero colin's name?
17:22:47 <ndm> sorear: no, its mine - i'm still torn between Supero and -O11
17:23:00 <ndm> dcoutts: shouldn't someone submit a patch to fix it? ;-)
17:23:16 <dcoutts> ndm: I'm just looking at the code, I thought it had been fixed
17:23:20 <monochrom> We need to create another unit of haskell understanding.  It's called "1 sorear".
17:23:21 <dcoutts> but seems not
17:23:35 <ndm> dcoutts: plus i would have expected -v10 to give a list of all commands before they execute, my programs all do that, but Cabal doesn't
17:23:41 <Igloo> ndm: Yes, you should submit a patch to fix it  :-)
17:23:51 <ndm> Igloo: yeah, i suspected it might be a recurring bug
17:24:06 <ndm> Igloo: sounds fun, ping me about that patch after i finish my PhD :)
17:24:22 <Igloo> cabal does intend to print commands when given -v. I thought your e-mail included output showing the command it was running
17:24:54 <dcoutts> ndm: people use the verbose stuff inconsistently in cabal sadly. It needs my cunning command interpreter monad so that logging decisions happen in one place only.
17:25:24 <ndm> oh, my bad, it is printed - i didn't spot it with the error message
17:25:32 <dcoutts> it does use 'rawSystemPath verbose' in the code
17:25:39 <ndm> i also had a problem with Cabal failing to run haddock which is in C:\Program Files ...
17:25:44 <ndm> and the space screws it up
17:26:07 <ndm> it wasn't a problem when i used to install haddock (in D:\bin), but Cabal automatically puts it in Program Files, which Cabal can't handle...
17:26:52 <Pseudonym> BBS
17:27:25 <monochrom> Pseudonym ditches us for an antique BBS?!
17:29:02 <dcoutts> ndm: it's not obvious to me why the space should cause any problem, we use rawSystem when invoking haddock
17:29:45 <ndm> dcoutts: it definately does though...
17:30:05 <dcoutts> ndm: when you explicitly tell cabal where haddock is?
17:30:12 <ndm> dcoutts: i can get a more detailed bug report tomorrow, since this machine has a working haddock, and i need to have it working tonight
17:30:19 <ndm> dcoutts: no, it finds it with configure
17:30:37 <ndm> dcoutts: are you still writing a TMR article review of graham huttons book?
17:30:43 <dcoutts> ndm: yes
17:31:08 <dcoutts> ndm: well a verbose log of what it's really running would probably help
17:31:41 <dcoutts> the other cunning thing the command interpreter monad would do is allow interactive step by step debugging
17:32:00 <dcoutts> *sigh* so much to do, so little time
17:32:16 <Igloo> Indeed
17:32:20 <ndm> dcoutts: i'll get that tomorrow
17:32:31 <dcoutts> ta
17:32:42 * ndm just finished his TMR article, going to release TagSoup, then onto Haskell Workshop...
17:32:56 <dibblego> is that Practical Haskell book any good?
17:33:33 <dibblego> er, Programming in Haskell?
17:33:58 <monochrom> all books are good
17:34:22 <monochrom> (you also hear me saying "all books are wrong" in another occasion. the two are compatible with each other.)
17:34:45 <dibblego> I haven't found that
17:35:07 <QtPlatypus> Is "Programming in Haskell" better or worce then the mean Haskell book.
17:35:19 <dibblego> which one is mean? I like mean books
17:35:40 <monochrom> heeheehee
17:39:07 <falconair_> is there a library that lets me do something like the following: [x | x<-networkConnection, x `is` "GOOG"] where networkConnection is some structure which receives stock quotes from a network connection?
17:39:46 <falconair_> in other words, I'd like to use list comprehensions with continuously changing data, without resorting to Arrors/FRP magic
17:39:48 <sorear> mh.
17:39:49 <bd_> Comprehensions would only work on lists :/
17:40:03 <sorear> lazy infinite lists perhaps?
17:40:03 <falconair_> oh, i should add, the 'do' notation is fine as well
17:40:14 <bd_> They used to work on regular monads; but that was lost at some point
17:40:27 <sorear> falconair_: hGetContents
17:40:34 <sorear> lazy IO
17:41:09 <ddarius_> bd_: Between Haskell 1.4 and Haskell  98
17:41:19 <mux> @instances Num
17:41:20 <lambdabot> Double, Float, Int, Integer
17:41:21 <falconair_> sorear: hGetContents works with network connections as well? (the examples only show file data)
17:41:32 <monochrom> Yes.
17:41:38 <ddarius> It works with any handle.
17:41:50 <ddarius> The magic of hGetContents is in the language.
17:42:00 <sorear> falconair_: if you are using a Real OS, a file descriptor is a file descriptor :)
17:42:14 <monochrom> All OSes are real OSes.
17:42:19 <sorear> Even Windows is real enough for this.
17:42:29 <ddarius> @google "Imaginary OS"
17:42:30 <lambdabot> http://www.osnews.com/comment.php?news_id=17067
17:42:31 <lambdabot> Title: OSNews.com
17:42:31 <falconair_> cool, now the its signature seems to be Handle -> IO String, so I have to convert it to ints, doubles, tuples, myself then, correct?
17:42:39 <sorear> yes
17:43:22 <falconair_> ok, no prob.  Now, does the ByteString library come into play here?  I remember reading somewhere that it could be used with network connections as well
17:43:31 <sorear> yes it can
17:43:48 <sorear> just pass the Handle to Data.ByteString.Lazy.hGetContents
17:43:58 <dcoutts> you can make ordinary Handles for network sockets and you can read/write ByteStrings to Handles
17:44:26 <sorear> UNIX will return short reads for slowly arriving data, and bytestring will make short chunks on short reads
17:44:37 <falconair_> ok, great, thanks folks, very encouraging, i'll be back after doing a few experiments :)
17:44:39 <sorear> so no worries about laziness
17:45:32 <dons> yow
17:45:43 <sorear> hi!
17:46:35 <sorear> Data.ByteString.Char8> hGetLine System.IO.stdin
17:46:35 <sorear> *** Exception: no buffering
17:46:38 <sorear> why?
17:47:18 <sorear> (looks like a LazyImplementationError to me, but are there deeper reasons?)
17:54:09 <dcoutts> sorear: hmm
17:54:09 <ndm> woohoo, done: http://www.cs.york.ac.uk/fp/darcs/tagsoup/tagsoup.htm
17:54:11 <lambdabot> Title: Drinking TagSoup by Example
17:54:34 <sorear> hmm.  I've found a bug of some sort in Data.Binary?
17:54:42 <sorear> stefan@stefans:~$ (echo -ne '\0\0\0\1' ; sleep 4; echo -n '\0\0\0\2') | ghc -e 'mapM_ (print :: Data.Int.Int32 -> IO ()) . Data.Binary.decode =<< Data.ByteString.Lazy.Char8.hGetContents IO.stdin'
17:54:42 <sorear> 1546673202
17:54:42 <sorear> *** Exception: Data.ByteString.index: index too large: 0, length = 0
17:54:46 --- mode: ChanServ set -vv glguy hpaste
17:54:55 <sorear> 1546673202 is not in my data at any alignment
17:55:12 <sorear> conjecture: off-by-one-error in free space checking
17:55:28 <sorear> consequence: hard to reproduce access violations
17:55:44 * sorear seems to recall having heard this one before
17:57:02 <dcoutts> sorear: erm, so you make a lazy bytestring with two chunks and try and decode, hmm I don't see what the mapM_ is for
17:57:13 <dcoutts> sorear: what type are you decoding?
17:57:32 <sorear> dcoutts: Int32
17:57:46 <dcoutts> where is the list comming from? mapM_ ?
17:57:50 <sorear> dcoutts: my initial project was to test the laziness correctness of Data.ByteString
17:58:04 <sorear> no, the list is coming from stdin
17:58:07 <sorear> in two chunks
17:58:11 <dons> hehe. it has laziness correctness now? ;-)
17:58:19 <dons> its a *strict* type
17:58:31 <sorear> I wanted to see if the first int32 is decoded before the second is sent
17:58:34 <dcoutts> sorear: huh? it's a single lazy bytestring, not a list, I don't get it
17:58:36 <sorear> dons: .Lazy.
17:58:40 * dons hans sorear StrictCheck
17:58:54 <sorear> dcoutts: decode :: ByteString -> [Int32]
17:58:55 <chessguy> ndm: surely that would be better-done with parsec
17:59:06 <dcoutts> sorear: ah ok, then your format is wrong
17:59:09 <sorear> I forgot about the length, but still...
17:59:11 <ndm> chessguy: no, that implies you know what the data looks like and can parse it
17:59:15 <dcoutts> sorear: so you should expect decoding to fail
17:59:25 <ndm> chessguy: although possibly some situations could be done better than way - although i doubt it
17:59:37 <chessguy> ndm: well, you can probably make some kind of assumptions about the tag soup
17:59:46 <sorear> dcoutts: I demand that my haskell libraries not index outside arrays regardless of malformed input
18:00:12 <sorear> that way lies segfaults, something our marketing dept. doesn't want
18:00:13 <ndm> chessguy: but then introducing new attributes breaks them, even though the attribute it meaningless - i think this way you can make fewer assumptions and be a bit more robust
18:00:27 <sorear> Rule #2 :)
18:00:31 <chessguy> hmmm maybe
18:00:37 <chessguy> anyway, nice article
18:00:38 <chessguy> ndm++
18:00:45 <dcoutts> sorear: it's doing a bounds check, that's what error message says
18:01:00 <sorear> ndm++ my goals of a pure haskell web browser are coming closer!
18:01:01 <ndm> thanks :) - its useful for what its good at, and useless for everythign else
18:01:14 <sorear> dcoutts: where do you think 1546673202 came from?
18:01:17 <ndm> sorear: please, never base a web browser on this!
18:01:33 <dcoutts> sorear: it's the 64 bit integer 00010002
18:02:10 <sorear> dcoutts: that's what I thought.  but bc says otherwise
18:02:23 <ndm> SPJ also appears to write his website using Visual Studio, which must be a painful experience
18:02:31 <dcoutts> @hoogle hex
18:02:31 <lambdabot> Text.ParserCombinators.Parsec.Char.hexDigit :: CharParser st Char
18:02:32 <lambdabot> Text.ParserCombinators.Parsec.Token.hexadecimal :: TokenParser st -> CharParser st Integer
18:02:32 <lambdabot> Numeric.readHex :: Integral a => ReadS a
18:02:32 * ndm has his auto-generated with Haskell
18:02:40 <sorear> > showHex 1546673202 ""
18:02:41 <lambdabot>  "5c305c32"
18:03:00 <dcoutts> sorear: and bear in mind you used ascii 1 and 2
18:03:13 <dcoutts> oh maybe you didn't \1 \2
18:04:43 <chessguy> i suppose it would be a silly question to ask why the hit count on the front page is in the html, but not rendered
18:05:09 <dcoutts> sorear: perhaps the error message could be better but I think the behaviour you get is fine
18:05:10 <sorear> chessguy: because all customization occurs through CSS
18:05:14 <dcoutts> instance Binary a => Binary [a] where
18:05:15 <dcoutts>     put l  = put (length l) >> mapM_ put l
18:05:15 <dcoutts>     get    = do n <- get :: Get Int
18:05:15 <dcoutts>                 replicateM n get
18:05:39 * sorear tries harder to get a segfault.
18:05:50 <dcoutts> we just get n times and if that goes past the end of the input then you get an error
18:06:13 <narain> ndm: how does your parser work? and does it have any relation to the other tagsoup library in java?
18:06:53 <ndm> narain: my parser is hand coded, http://www.cs.york.ac.uk/fp/darcs/tagsoup/Data/Html/TagSoup.hs
18:07:07 <ndm> narain: i didn't know there was a tagsoup library for java...
18:07:31 <narain> ok... it's the first hit on google
18:07:33 <narain> ?go tagsoup
18:07:36 <lambdabot> http://home.ccil.org/~cowan/XML/tagsoup/
18:07:36 <lambdabot> Title: TagSoup home page
18:08:05 <narain> "TagSoup ... parses HTML as it is found in the wild:  poor, nasty and brutish, though quite often far from short."
18:08:09 <chessguy> ?hoogle openURL
18:08:10 <lambdabot> No matches found
18:08:12 <ndm> narain: that does things like making tags properly nested etc - mine doesn't
18:08:25 <ndm> chessguy: its in Data.Html.Download, shipped with TagSoup
18:08:29 <narain> right, i see that looking at your source code
18:08:34 <chessguy> ah
18:09:41 <narain> i found that bit impressive in the other tagsoup library
18:09:41 <chessguy> err, where can i get TagSoup?
18:11:10 <sorear> dcoutts: is Int 32-bits now?
18:11:17 <chessguy> ?where tagsoup
18:11:18 <lambdabot> I know nothing about tagsoup.
18:11:32 <dcoutts> sorear: not sure, it may have changed since I last looked
18:11:39 <ndm> ?where+ tagsoup http://www.cs.york.ac.uk/~ndm/tagsoup/
18:11:39 <lambdabot> Done.
18:12:05 <chessguy> aha
18:12:10 <ndm> narain: impressive, but very hard to do - thats the hard bit in web browsers
18:12:17 <ndm> chessguy: i'm releasing it tomorrow :)
18:12:31 <dcoutts> sorear: re hGetLine, yeah we don't seem to handle the unbuffered case, looking at the GHC String impl for the unbuffered case, it's really hairy.
18:12:32 <narain> ndm: quite so
18:13:28 <dcoutts> sorear: seems they're still 64bit in the latest darcs code
18:14:53 <chessguy> ?where Network
18:14:54 <lambdabot> I know nothing about network.
18:15:09 <chessguy> Data/Html/Download.hs:23:7:
18:15:09 <chessguy>     Could not find module `Network':
18:15:09 <chessguy>       it is a member of package network-2.0, which is hidden
18:15:57 <sjanssen> chessguy: looks like you've got a broken .cabal file on your hands
18:16:08 <chessguy> ndm: ?
18:16:41 <sjanssen> chessguy: add network to the build-depends field
18:17:13 <chessguy> ok, i still have to find it somewhere though :)
18:17:32 <sjanssen> judging from the error message, you already have it
18:17:42 <chessguy> oh, yes, ok
18:17:43 <dons> sjanssen: have you had a look at the rough outline of the tmr article?
18:18:03 <TomMD> ?where tmr
18:18:04 <lambdabot> http://www.haskell.org/tmrwiki/FrontPage
18:18:40 * narain is tempted to write a tree-building parser for tag soupy html
18:19:00 <chessguy> @tell ndm i had to add network to the Build-depends in the .cabal file to build it
18:19:00 <lambdabot> Consider it noted.
18:19:06 <sjanssen> dons: yep
18:19:20 <dons> comments, text?
18:19:31 <ndm> chessguy_phone: hmm, i will add that now
18:19:32 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
18:19:40 <ndm> @clear-messages
18:19:41 <lambdabot> Messages cleared.
18:20:06 <sjanssen> dons: nothing at the moment.  Just need to get writing
18:20:41 <ndm> dons: you are doing a TMR article as well?
18:20:54 <ndm> chessguy_phone: pushed
18:21:27 <sorear> ndm: why don't you want your code in a web browser? :)
18:22:49 <ndm> sorear: uber-hacky! - i guess if you wrote a layer to convert it into a tree on top that would be fine
18:22:54 <chessguy_phone> ndm: cool, i'll do more testing later
18:23:17 <dons> ndm: yeah.
18:23:26 <ndm> sorear: converting a list into a tree is the hard bit, given broken HTML
18:23:31 <narain> how does haskell handle character encodings?
18:23:33 <ndm> dons: cool, on XMonad?
18:23:38 <dons> yep
18:24:02 <ndm> I have just finished one on Yhc.Core, and teh guy sat next to me is writing one on hardware combinators
18:24:10 <ndm> are you aiming for the Friday deadline?
18:24:15 <dons> yeah.
18:24:25 <dons> sounds like it will be a bumper TMR this time.
18:25:01 <dcoutts> @arr!
18:25:02 <lambdabot> Har de har har!
18:25:34 <chessguy_phone> @quote pirate
18:25:34 <lambdabot> Syzygy- says: Why do I get the feeling that the arrow code was written during "Speak like a pirate day"?
18:28:38 <dons> sjanssen: basically, if you could sketch out any sections that are missing, or elaborate on any of the existing things, that would be useful. i'll be writing most of today, I think.
18:28:56 <dcoutts> dons: comming in today btw?
18:31:55 <dons> yep.
18:32:43 <sorear> narain: everything in haskell is abstract codepoints, so no worries for computation
18:33:00 <sorear> narain: BUT, the IO lib assumes everything is ISO-8859-1
18:33:15 <sjanssen> ghc's IO lib
18:33:29 <sjanssen> hugs respects your locale
18:33:55 <ndm> Igloo: does this mean you are eliminating incomplete patterns from Setup.hs files in GHC?
18:33:57 * dcoutts thinks ghc is right and we should do conversions above IO layer
18:34:25 <narain> hmm, that would make it hard to write a web browser which has to deal with pages written in different encodings
18:34:30 <narain> s/would/might/
18:34:36 * sorear thinks any IO lib that doesn't do encoding should advertise this fact by returning [Word8]
18:34:49 <sorear> [Char] is processed codepoints, NOT BYTES
18:35:03 <sjanssen> dcoutts: the IO layer provides a Char interface -- I don't see any option but to do conversions in the library
18:35:05 <dcoutts> narain: right, that's a good reason for doing the conversions in the pure layer above
18:35:24 <dcoutts> sjanssen: it does but it shouldn't, I mean it should advertise bytes
18:36:02 * narain would like to hear more of this discussion but must go and catch a bus
18:36:03 <dcoutts> sjanssen: and historically that's the way ghc and hugs have done it, though more recently hugs changed to use encodings
18:36:05 <sjanssen> dcoutts: and you want to eliminate convenient functions like getLine?
18:36:28 <dcoutts> sjanssen: well, I never use getline :-)
18:37:07 <dcoutts> yeah, it's thorny :-(
18:37:17 <ndm> shouldn't you use interact instead?
18:37:26 * ndm hides
18:37:32 <dcoutts> ndm: right, I almost always use lazy io
18:37:47 <dcoutts> not interact, but readFile / getContents
18:38:20 <sjanssen> I think we need both pure functions for doing [Word8] -> [Char] and ways to automatically use  that conversion with the Char based IO routines
18:38:41 <dcoutts> yeah, probably so
18:39:15 <dcoutts> I worry that we'll move too far to pushing everything into the Handle layer
18:39:25 * sorear summons Bulat
18:39:53 <dcoutts> obviously not as a Handle but as one of these iostream style class things, yeah like Bulat bangs on about
18:39:59 <sjanssen> Bulat is a big fan of throwing the IO baby out with the IO bathwater
18:40:08 <dcoutts> where as I think we should work as hard as possible to keep as much pure as possible
18:40:37 <dcoutts> in my more puritanical moods I'd say eliminate the encodings and the buffering from the Handle
18:40:45 <dcoutts> just do locking and block reads/writes
18:40:53 <dcoutts> everything else can be done purely
18:41:00 <ndm> makes much more sense...
18:41:04 <ndm> as the lowest layer
18:41:15 <dcoutts> except then the people who like strict IO will complain that I'm making their lives painful
18:41:30 <ndm> then build higher layers "conceptuallly" on top of that, and let compilers implement the higher levels directly for performance reasons - if they want
18:41:33 <dcoutts> since doing strict IO and dealing with blocks is a pita
18:41:49 <ndm> there should be a lazy IO and a strict IO on top of the low-level IO
18:41:54 <ndm> easier for everyone that way
18:42:14 <sjanssen> dcoutts: that's why Handle is good -- it abstracts this stuff for you
18:42:28 <dons> the xmonad mailing list!  http://www.haskell.org/mailman/listinfo/xmonad
18:42:30 <lambdabot> Title: Xmonad Info Page
18:42:33 <jcreigh> woot!
18:42:49 <dcoutts> sjanssen: hmm? it provides a lot of stuff, but it doesn't make extending it easy
18:43:13 <dcoutts> sjanssen: eg we still don't semi-close the Handle for lazy bytestring getContents
18:43:17 <jcreigh> dons++ Thanks for setting that up
18:43:26 <dons> let me send a test msg.
18:43:39 <sjanssen> dcoutts: yeah, extending is difficult.  But how much (more) does it really need to do?
18:43:41 <dcoutts> because you can't do that in the Handle api, you need to delve into the impl
18:43:44 <jcreigh> I'm not subbed quite yet...haven't got the confirmation yet
18:43:50 <dcoutts> sjanssen: it could do less... ;-)
18:43:54 <ndm> why does teh XMonad website not have any screenshots!
18:44:13 <sjanssen> ndm: we don't really control the xmonad.org domain
18:44:15 <sjanssen> @seen fantasma
18:44:16 <lambdabot> I saw fantasma leaving #haskell 1d 22h 54m 49s ago, and .
18:44:18 <jcreigh> ndm: screenshots are a crutch for the weak. :)
18:44:27 <dcoutts> sjanssen: I don't really complain about Handle, not the way Bulat does. It doesn't get in the way of high performance IO code as Bulat believes.
18:44:38 <ndm> jcreigh: i doubt it works on windows
18:44:45 <sorear> high performance IO?
18:44:46 <ndm> dcoutts: its perfectly fast enough in Hugs
18:44:55 * sorear just lost all respect for him
18:45:13 <dcoutts> ndm: sure it works in windows, you just need an X server :-)
18:45:16 <sorear> come on, who seriously believes CPU time is important in IO code?
18:45:52 <dcoutts> sorear: Bulat thinks the Handle does too much stuff and makes things slow. He's wrong of course.
18:46:13 <sjanssen> ndm: http://cse.unl.edu/~sjanssen/xmonad-tiles.png
18:46:20 <dcoutts> it does no extra copies when you're doing IO in big chunks
18:46:30 <dons> sjanssen, jcreigh susbscribed?
18:46:33 <dcoutts> the Handle buffer(s) are only used for small reads/writes
18:46:42 <jcreigh> dons: ACK
18:46:44 <monochrom> Screenshots are too eager (strict).
18:47:00 <sjanssen> dons: still waiting on mailman
18:47:39 <dons> jcreigh: you got the mailman response?
18:47:44 <dons> and it looked ok?
18:47:47 <jcreigh> dons: yeah
18:47:55 <dons> ok good.
18:48:14 <sjanssen> ha, I mistyped my email address
18:48:21 <sjanssen> > "edu" == "ed"
18:48:23 <lambdabot>  False
18:49:40 <dons> internets is hard.
18:50:00 <dons> yeah, so i think we should set up haskell.org/xmonad
18:50:16 <dons> then when xmonad.org-man appears, we get a redirect.
18:50:33 <sjanssen> dons: yeah
18:51:01 <dons> so now how to get a top level haskell.org page.
18:51:16 <sorear> Ashley Yakely iirc
18:51:20 <sorear> @wiki Haskell.org
18:51:20 <lambdabot> http://www.haskell.org/haskellwiki/Haskell.org
18:51:27 <sorear> ^^^ says there
18:53:24 <monochrom> @remember dons internets is hard.
18:53:25 <lambdabot> Done.
18:53:30 <procyon112> sorear: High volume server writers would have a very different opinion on high performance IO
18:54:08 <sorear> imho, anyone who cares that much about performance shouldn't be using abstraction layers
18:54:48 <dibblego> anyone who cares that much about performance shouldn't "want to be liberated from the von Neumann machine"
18:55:15 <jcreigh> @quote liberators
18:55:16 <lambdabot> dons says: my feeling is that the Java programmers will welcome us as liberators
18:55:26 <procyon112> force them to use C?  Correctness is just as important as performance for a lot of servers.
18:56:04 <procyon112> If it's possible to abstract and retain performance, then abstraction should happen.
18:56:11 <dons> ok. sent a test msg to xmonad@
18:56:15 <monochrom> The bytestring library shows that it's ok to abstract and perform.
18:56:26 <dcoutts> sorear: dibblego: performance and abstraction is a false choice, we can have both if we think hard enough
18:56:49 <monochrom> Yes, do prepare to think harder.
18:56:53 <dibblego> dcoutts, I agree entirely
18:57:07 <sjanssen> I don't understand what these potential problems are
18:57:14 <sjanssen> locking inside the handle?
18:57:15 <procyon112> Especially if correctness proofs can be done at compile time, and abstracted away at runtime.
18:57:19 <dibblego> I think Backus said it most succintly
18:57:39 <dons> oh, i have to subscribe to my own list.
18:57:42 <monochrom> The problem with most programmers is they code harder not think harder.
18:57:43 <sjanssen> s/problems/performance problems
18:58:07 <dibblego> monochrom, I've been through three keyboards this year (perhaps I should think more instead?)
18:58:14 <dcoutts> sjanssen: as far as I know there are no performance problems with Handles if you use them right.
18:58:18 <dibblego> granted, they are MS keyboards with very fimsy keys
18:58:22 <dibblego> *flimsy
18:58:31 <monochrom> I guess you don't want to be through three brains next year :)
18:58:49 <dibblego> I hope my brain's enter key is not manufactured by Microsoft
18:58:57 <dcoutts> sjanssen: who says there are potential problems? I must have missed that part of the conversation
18:59:09 <sjanssen> dcoutts: whatever Bulat complains about
18:59:33 <sorear> I never realized Bulat was complaining about performance.
18:59:44 <dcoutts> sjanssen: well, I'm not sure I understand what he thinks is bad, all I remember is that he's wrong :-)
18:59:52 <sorear> I thought he was complaining about IO being too big for base.
18:59:54 <dons> ok, welcome msg sent.
19:00:00 <sorear> and I agree on that point :)
19:00:00 <dons> did everyone get that?
19:00:18 * sorear subs
19:00:21 <jcreigh> dons: yes
19:00:26 <dcoutts> sjanssen: sorear: right he certainly complains about the Handle stuff being monolithic
19:00:29 <dons> sjanssen: isn't subscribed yet.
19:00:55 <sjanssen> sorear: search archives for "high performance io lib", I'm almost certain you'll get dozens of Bulat hits
19:01:22 <dcoutts> sjanssen: sorear: but as I understand it he also thinks there are higher speed OS-native 'zero-copy' things that we're not using and the Handle is too inflexible to take advantage of.
19:01:43 <sorear> hahaha.
19:01:56 <dons> secret syscalls!
19:02:05 <sorear> no, not secret
19:02:15 <sorear> about as well documented as +RTS -xc
19:02:38 <jcreigh> "zero copy"?
19:02:40 <dcoutts> sjanssen: sorear: he's half right. Zero copy is nearly worthless but it might be fun to try async IO rather than the current non-blocking IO, but I expect the gains to be very marginal.
19:02:43 <sorear> IE they are well documented; nobody but me seems to have ever bothered to read the relevant docs though
19:02:53 <dcoutts> jcreigh: mmap and similar techniques
19:03:00 <dons> well, we do have a full epoll binding in the 'unify' lib.
19:03:06 <dons> hmm, that might be fun to cabalise ..
19:03:25 <dons> should win award for best code not yet in a cabal repo
19:03:34 <dcoutts> epoll is easy to bind, it's just 4 functions
19:03:45 <dcoutts> but you want to have the IO manager use it
19:04:01 <dcoutts> allow the IO manager to use different things on different OSs a bit more easily
19:04:27 <sjanssen> that sort of thing has to have RTS integration, right?
19:04:42 <dcoutts> no, the IO manager is written in Haskell
19:04:46 <sjanssen> unless we want to expose select style interfaces, which are ugly IMO
19:05:11 <dcoutts> so it's part of base.GHC.stuff but not the rts
19:05:26 <sorear> imho we should divorce IO completely from the RTS
19:05:35 <sorear> that will make compiler independance much easier
19:05:39 <dcoutts> sorear: the threaded rts does that, mostly.
19:06:34 <sorear> in that case we should clean up the IO manager
19:06:39 <dcoutts> sorear: but either you need all impls to support multiple OS threads or the IO has to be built-in to prevent the whole process blocking
19:06:46 <sorear> make it pure Haskell-98 + FFI
19:06:59 <dcoutts> sorear: so I'm not sure it helps compiler independence much
19:07:07 <dons> sjanssen: you able to sign up to xmonad@ ?
19:07:23 <sorear> any impl that supports FFI and concurrency already needs multiple OS threads
19:07:23 <dcoutts> sorear: pure Haskell98 + FFI is fine except for the issue of threads and blocking.
19:07:28 <dcoutts> nope
19:07:34 <sorear> eh?
19:07:40 <sorear> safe foreign calls?
19:07:42 <dcoutts> I don't think hugs supports bound threads
19:07:57 <dcoutts> @seen ndm
19:07:58 <lambdabot> I saw ndm leaving #haskell 17m 55s ago, and .
19:08:04 <dcoutts> I wonder what yhc does there
19:08:05 <sorear> if safe foreign calls block the whole process, it's broken
19:08:13 <sorear> in yhc, EVERYTHING is ffi
19:08:40 <sorear> there are safe and unsafe foreign calls; only unsafe block all threads.
19:08:49 * dons `pa` uni
19:08:50 <sorear> basically, I want yhc's IO system in ghc
19:08:55 <sorear> @hoogle pa
19:08:56 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
19:08:57 <lambdabot> Control.Parallel.par :: a -> b -> b
19:08:57 <lambdabot> Data.Graph.path :: Graph -> Vertex -> Vertex -> Bool
19:09:02 <dcoutts> sorear: I'm not sure you can really say that, it writes off many many possible implementations
19:09:15 <dcoutts> sorear: doing that is great but requires a lot of the implementation
19:09:17 <sjanssen> how are 'safe' calls implemented?  Is a new OS thread created for each call?
19:09:24 <sorear> yep
19:09:29 <dcoutts> sjanssen: it uses a pool, but yes
19:09:33 <sjanssen> that sounds outrageously expensive
19:09:41 <sjanssen> oh, a pool sounds fine
19:09:51 <dcoutts> sjanssen: it expands the pool if there is not one free
19:10:33 <dcoutts> I'm not sure if it's limited at all
19:10:51 <dcoutts> if you had 1000 Haskell threads do safe foreign calls all at once...
19:11:13 <dcoutts> I'd prefer to have some limit and have the safe foreign call block that Haskell thread 'til some others are complete
19:11:16 <sjanssen> yeah, that might not scale very well
19:11:34 <sjanssen> dcoutts: that design is ripe with deadlocks
19:12:33 <dcoutts> sjanssen: aye, I suppose so, if you need those earlier calls to complete before this last call you're making will complete
19:12:35 <sjanssen> ghc's design seems best to me
19:12:55 <dcoutts> ie if the foreign calls synchronise on the foreign side
19:13:10 <dcoutts> I suppose so, it's simple at least
19:13:19 <sjanssen> you should be able to have thousands of threads blocked on IO simultaneously without concern
19:13:32 <dcoutts> blocking on IO is not the problem
19:13:42 <dcoutts> only on thread needs to do that
19:14:03 <jcpetruzza> :t guard
19:14:06 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
19:14:18 <sorear> sjanssen: I *am* suggesting async IO
19:14:39 <sjanssen> dcoutts: using safe foreign calls and OS threads for each call isn't going to scale
19:14:41 <sorear> have ONE haskell thread block on foreign calls
19:14:49 <dcoutts> sorear: excapt that on many OSs async IO is slower or not async
19:15:16 <dcoutts> sorear: that's ok for IO, but not in general
19:15:20 <sorear> dcoutts: asynch is a generic term and a specific term.  I mean the generic - including select
19:15:28 <jcpetruzza> @djinn a -> a
19:15:29 <lambdabot> f a = a
19:15:37 <dcoutts> ok, select is non-blocking not asynchronous
19:15:42 <jcpetruzza> @djinn Maybe a -> a
19:15:43 <lambdabot> -- f cannot be realized.
19:17:18 <dcoutts> linux might get real async IO some time in the not too distant future
19:17:39 <dcoutts> that'd be fast and synchronous in the cached case, and async in the blocking case
19:21:17 <sorear> linux has aio_* - it's fake?
19:21:28 * sorear didn't see a BUGS section
19:21:30 <dcoutts> sorear: it uses userspace threads
19:21:51 <sorear> ouch.
19:21:51 <Modius> I was wondering if any haskellers have solved or seen a solution for:  http://acm.uva.es/p/v100/10032.html  The Tug-of-war problem.
19:22:12 <dcoutts> sorear: there is a little bit of native aio support for reads/writes on O_DIRECT files
19:22:22 <Modius> This will almost sound like trolling; but I believe a solution would show some profoundly powerful construct to be able to inspire the compiler to generate something that works linear-time.
19:22:24 <dcoutts> sorear: ie a very little, only useful for databases
19:23:04 <Modius> It can be expressed functionally; but at the bottom level, something that doesn't cull solution-space against an (in the examples I've seen) imperatively generated table of some sort cannot finish in any sort of time.
19:24:23 <dcoutts> sorear: so it doesn't cover normal cachable files or things like dir reads, or creating or opening files, all of that is still blocking, the new design would cleanly allow all that to be done asynchronously
19:24:29 <sorear> Ouch, this looks like a knapsack problem
19:24:52 <Modius> I've heard it called that - by the guy at work who probably solved it by huntting down a solution :)
19:25:34 <dcoutts> sorear: by having the kernel fork a new thread *only* if the syscall was going to block. So the existing thread does block and the new thread returns to the caller (with some kind of completion token).
19:26:59 <monochrom> Some dynamic programming helps.  Dynamic programming is a no-brainer in Haskell.  Just use an array and exploit lazy evaluation.
19:27:26 <dcoutts> aye, don't even have to calculate the order in which to fill the array elements
19:27:42 <dcoutts> just let the data-dependencies sort it out
19:27:57 <dcoutts> so it's a little more expensive but wonderfully easy
19:28:42 <dcoutts> someone has a paper on optimising those examples to use a specific order when the order can be worked out statically
19:28:48 <monochrom> The code can be translated to English as:  myarray = create new array with (stuff referring to entries in myarray)
19:29:07 <sorear> Actually, the dynamic programming approach won't work here.
19:29:25 <sorear> Nowhere in the specification does it say the weights will be integers.
19:29:34 <sorear> Or even commesurable.
19:29:35 <sjanssen> sorear: yes it does
19:29:46 <monochrom> "Each weight is an integer between 1 and 450"
19:29:48 <sjanssen> "  Each weight is an integer between 1 and 450"
19:29:57 <monochrom> @quote stereo
19:29:57 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
19:30:00 <sorear> I see it now.
19:30:53 <Modius> How is this type of (knapsack?) problem solved?  Some powerful in-functional tool or using monads/IO to some stateful code?
19:30:56 <sjanssen> I bet you could just brute force this one
19:31:09 <dino-> This morning I was asking how to exec a [IO (Maybe a)] and stop, evaluating to the first one that's not Nothing. And sjanssen did this: http://hpaste.org/1330
19:31:35 <dino-> I had time to go over it now in detail and I'm having trouble understanding why it stops.
19:31:40 <dcoutts> Modius: it'd never require IO, ST perhaps.
19:31:58 <monochrom> The dynamic programming solution to the knapsack problem is exponential-time.  You may as well consider it fast and readable brute force.
19:32:52 <dcoutts> dino-: so you're looking at the 'f' function
19:32:54 <dmwit> :t tell
19:32:57 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
19:33:08 <dmwit> :t fodder
19:33:10 <lambdabot> Not in scope: `fodder'
19:33:11 <dcoutts> dino-: you see where it runs the current action and checks the result?
19:33:39 <dino-> dcoutts: Yes, the case.
19:33:53 <dcoutts> dino-: then when it's Just _ then we return rather than looking at answer for the rest of the list
19:34:02 <ddarius> > let head = foldr const undefined in head [1..]
19:34:03 <lambdabot>  1
19:34:22 <monochrom> State mutation is overrated.  Quite often you just write once and read many times.  Lazy functional programming does exactly this.
19:34:47 <dino-> So that Just _ -> return x, that's returning back into Maybe? (not IO)
19:34:54 <dcoutts> dino-: the 'ms' variable is the result of continuing the search on the rest of the list, but if we don't use it then it doesn't get run
19:35:09 <Modius> What's ST?  Assume I have only the most rudimentary understanding of Haskell; but am fascinated with how this would be solved in normal time.
19:35:34 <dino-> I was trying to draw it out like a `f` (b `f` (c `f` (return Nothing)))
19:35:38 <Modius> I'm against state in code people write, this program stuck out at me in that it's easy to write stateless; but hard to force the performance profile of the imperative solution that can finish in real time.
19:35:44 <monochrom> You don't need ST here.  ST wins only when you need to write the second time.
19:35:55 <dcoutts> dino-: no it's in IO, 'x' is of type 'Maybe a' so 'return x' is of type IO (Maybe a)
19:36:11 <dino-> Ah, if we don't use it.
19:36:11 <ddarius> monochrom: Dataflow variables
19:36:12 <monochrom> ST refers to having fully mutable variables and arrays.
19:36:43 <monochrom> What does the imperative solution do?  Just dynamic programming the plain old way?
19:36:45 <dino-> dcoutts: Ok, becuase f :: Monad m => m (Maybe a) -> m (Maybe a) -> m (Maybe a)
19:36:48 <sorear> monochrom: actually, this particular knapsack problem can be solved in O(4.5 million) time, not O(2^100) for brute force
19:37:13 <sorear> monochrom: since the weights are integers, and sum to no more than 45000 (yes it's in the spec)
19:37:14 <dcoutts> dino-: that looks right
19:37:16 <dino-> And the (return Nothing) is also m (Maybe a)
19:37:37 <dcoutts> yep
19:37:46 <dino-> dcoutts: Ok. Thank you.
19:38:04 <dcoutts> dino-: or to be more accurate, the value 'ms' is all the actions we'd need to do in contining the search and if we don't use that value the actions do not get performed
19:38:28 <dcoutts> ie it's the actions, not the result of the actions
19:38:30 <dino-> I still feel vaguely confused about the 'if we don't use it' part.
19:38:37 <Modius> The imperative solution builds a table and as it goes through all the possibilities stereotypes certain combinations and puts them in the table, thereby culling a bazillion other branches of the tree trivially.
19:38:42 <ddarius> Yay first class imperative statements
19:38:49 <dino-> But I do get the typing better now.
19:39:10 <Modius> I'm not a defender of imperative and know long term (and short term to the greatest degree possible) I will move away from it.
19:39:16 <dcoutts> dino-: look at this example: let unused = system "rm -rf /" in 3
19:39:19 <ddarius> > const (putStr "Hello") "foo"
19:39:20 <lambdabot>  <IO ()>
19:39:34 <ddarius> er flip const
19:39:36 <monochrom> I don't understand the description.  It looks like what one writes when applying for a patent.
19:39:42 <dcoutts> dino-: there is an action (a dangerous one) that is constructed but never performed
19:39:47 * sorear does ... barely
19:40:44 <sorear> :t mapAccumL
19:40:46 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
19:40:54 <monochrom> Oh well, I'm tired of discussing things with programmers.  They can only write either unreadable English or unreadable code.
19:41:19 <dcoutts> heh heh
19:41:31 * ddarius demonstrates that that "or" is not exclusive.
19:41:52 <dino-> dcoutts: Ok, thanks.
19:42:07 <dcoutts> ddarius: " only _ or _ " is usually taken to mean xor :-)
19:42:48 <monochrom> Oh, it's exclusive when you add time, i.e., you can only do one at a single point of time.
19:43:28 <dcoutts> yeah, producing unreadable engrish and code at the same time is beyond my :-)
19:43:36 <dcoutts> my/me
19:43:40 * ddarius writes in Inform and proves it still.
19:44:02 <ddarius> In fact, it's quite possible that all code in Inform is a case in point.
19:44:07 <TomMD> > (\x -> x in x) 5
19:44:08 <lambdabot>  Parse error
19:44:22 <monochrom> Is Inform a programming language?
19:44:35 <ddarius> @google "Inform programming language"
19:44:36 <dino-> monochrom: Yes, for interactive fiction.
19:44:37 <lambdabot> http://www.inform-fiction.org/
19:44:37 <lambdabot> Title:
19:44:47 <monochrom> thanks
19:45:55 <monochrom> Ha, I see.  Yes, it makes concurrent unreadability possible...
19:50:46 <dmwit> > (\x -> x) 5
19:50:47 <lambdabot>  5
19:55:28 <jargonjustin> How would I use the Data.Bits module to set the high and low bits of an Integer to 1 ?
19:55:53 <sjanssen> Integer doesn't have a high bit
19:56:15 <sjanssen> > bitSize (undefined :: Int)
19:56:16 <lambdabot>  32
19:56:24 <sjanssen> > bitSize (undefined :: Integer)
19:56:25 <lambdabot>  Exception: Data.Bits.bitSize(Integer)
19:56:40 <sorear> > iterate (2^) (0::Integer)
19:56:42 <lambdabot>  [0,1,2,4,16,65536,2003529930406846464979072351560255750447825475569751419265...
19:57:03 <jargonjustin> sjanssen: That's true, but if I need a really big number that has a particular exact number of bits and I want to set a particular one to 1.
19:57:14 <sjanssen> @hoogle setBit
19:57:15 <lambdabot> Data.Bits.setBit :: Bits a => a -> Int -> a
19:57:26 <sorear> jargonjustin: is your large number of bits a power of 2?
19:57:34 <jargonjustin> sorear: It sure is.
19:58:00 <jargonjustin> Well, in the cases I care about.  Generality is good provided it's possible and efficient.
19:58:03 <sorear> http://www.cse.unsw.edu.au/~dons/lambdabot/scripts/LargeWord.hs
19:58:14 <sorear> that might be what you are looking for
19:58:24 <sorear> dunno if it is efficient though
19:58:53 <sorear> as for poking bits in Integer, remember the whole integer has to be copied each time you change it
19:59:18 <jargonjustin> sorear: Ah, this library will probably be perfect then.
19:59:23 <sorear> Modius: Just finished solving the whole problem
19:59:42 <sorear> Modius: 25 80-character lines of dynamic programming haskell
20:00:02 <sorear> Modius: hpaste?
20:01:24 <ddarius> sorear takes very seriously the maxim to have all of one's code on one screen.
20:01:42 <procyon112> lol
20:01:48 * sorear notes that his screen is 128x48
20:02:13 <procyon112> Yeah, but you still code old school :)
20:02:34 * ddarius prefers terminals for coding.
20:02:45 * ddarius still needs to install the terminal version of vim.
20:03:02 <ddarius> Luckily, I've avoided an issue by not coding very much.
20:04:30 * ddarius wonders what code would look like if you required a minimum length.
20:04:56 <jargonjustin> ddarius: A mix of Haskell and Perl
20:05:39 <ddarius> jargonjustin: I suspect you are reading my statement almost exactly opposite of it's intent.
20:05:57 <ddarius> Anyways, Haskell already beats Perl at that game.
20:06:07 <chessguy> ?where tagsoup
20:06:08 <lambdabot> http://www.cs.york.ac.uk/~ndm/tagsoup/
20:07:38 <Modius> Sorear:  Did you run it with 100 people?
20:07:52 <dmwit> ddarius: I suppose it depends pretty greatly on the minimum...
20:08:00 <sorear> Modius: no, just with the example
20:08:34 <sorear> but it should scale!
20:08:34 <Modius> This page does the calculatinos:  http://gurubio.com/TugOfWar.cgi
20:08:36 <lambdabot> Title:
20:08:50 <Modius> I did one without the state that went vertical time wise at about 20.
20:10:52 <sorear> Modius: the page is blank
20:11:09 <sorear> anyway, my solution does 100 people in 15 seconds, interpreted
20:11:10 <Modius> Sorear:  BTW - whether or not the performance scales, your speed at getting the core algoritm working blows my mind.
20:11:23 <josephholsten> ddarius: antigolfing? probably something like a Visual Basic.net with design by contract . designed by committee
20:11:32 <Modius> Sounds like you got it right then - interpreted or not, inadequate algorithm = never finish.
20:12:27 <Modius> So where could I see the solution Sorear?
20:12:33 * ddarius is 100% certain that he can make an inadequate algorithm that finishes quite quickly for some values of inadequate.
20:12:51 <Modius> Well, inadequate in performance - I call 15 seconds a win in this situation.
20:13:03 <hpaste>  sorear pasted "my code" at http://hpaste.org/1334
20:13:17 <chessguy> anybody else played around with ndm's tagsoup code yet?
20:13:33 <monochrom> sorear++
20:13:39 <sorear> ghci is usually about 20x slower than ghc at bulk computation
20:13:53 <monochrom> I hope this favour is returned later when I announce my accomplishment... :)
20:13:57 <Modius> Even if it took 2 minutes I'd call it a win - if it didn't do the job it'd never finish.
20:14:26 <ddarius> sorear: What's with the let in parse?
20:14:35 <chessguy> ?seen ndm
20:14:36 <lambdabot> I saw ndm leaving #haskell 1h 24m 34s ago, and .
20:14:38 <sorear> stefan@stefans:/tmp$ cat test.txt > ./a.out
20:14:46 <sorear> oops ;)
20:15:12 <dmwit> Heh, probably not quite what you meant.
20:15:12 <sorear> 4.3s compiled btw
20:15:44 <sorear> ddarius: I think I put it in there intending to use some kind of monadic loop and forgot to refactor.
20:17:25 <Modius> Can this program be entered in through interactive/REPL?
20:17:37 <sorear> yes
20:17:55 <sorear> you'll have to put everything in a one line let block however
20:18:16 <sorear> ghci doesn't take too kindly to recursive definitions at the prompt
20:18:18 <Modius> Does it take its inputs from a file or elsewhere?  Forgive my silliness, I REALLY am weak on Haskell.
20:18:35 <sorear> if you run the 'main' function, it takes input from stdin.
20:18:35 <Modius> I may need a hand getting this running
20:18:53 <sorear> runhaskell WhateverYouCalledit.hs < tests
20:19:13 <sorear> note that ghc's runhaskell *requires* the .hs extension
20:21:43 <monochrom> the notion of stdin shouldn't be too alien to someone interested in programming contest problems.
20:21:49 <hpaste>  Kevin Francis pasted "cs410ap pairwiseProduct" at http://hpaste.org/1335
20:22:32 <Modius> This problem was dumped in my lap by a coworker showing how smart he was doing it in C#.
20:22:44 <Modius> I did the Lisp one in the REPL
20:23:10 <monochrom> amendment. the notion of stdin shouldn't be too alien to someone interested in programming
20:23:17 * chessguy wonders if ndm actually ran any of this example code
20:23:20 <Modius> Assuming this works, it dusts my Lisp solution in half the line.
20:23:37 <Modius> lines
20:23:51 <ddarius> Modius: Welcome to Haskell.
20:24:00 <Pseudonym> > map (map product) [[[1, 1], [4, 10], [9, 100]], [[2, 4], [15, 2], [10, 10]], [[6, -3], [-2, -9], [-8, 0]]]
20:24:02 <lambdabot>  [[1,40,900],[8,30,100],[-18,18,0]]
20:24:07 <Pseudonym> Welcome!
20:24:40 <Pseudonym> I dread to think how long the C# one was.
20:24:55 <Modius> You want dread - picture the C# guy who doesn't know any Lisp currently porting my lisp version to C#.
20:25:03 <monochrom> Disappointingly, most of the code is spent in parsing.  In other environments you would just scanf or cin>>x and be done.
20:25:15 <Modius> he's been an unpleasant coworker - I consider it suitable punishment.
20:26:14 <monochrom> But more happily, Java is even worse than Haskell in this regard :)
20:27:23 <hpaste>  chessguy pasted "Does this code work for anyone else?" at http://hpaste.org/1336
20:27:48 <monochrom> where do I find openURL ?
20:27:50 <dmwit> ?index openURL
20:27:51 <lambdabot> bzzt
20:28:02 <dmwit> I think you have to have tagsoup.
20:28:14 <chessguy> oh, yes, that's in tagsoup, sorry
20:28:15 <dmwit> (Isn't there an "import" line in the example ndm gave?)
20:28:20 <monochrom> ok, sorry too lazy to get tagsoup
20:28:26 <chessguy> yeah, i was thinking it was in network
20:28:31 <chessguy> ?where tagsoup
20:28:32 <lambdabot> http://www.cs.york.ac.uk/~ndm/tagsoup/
20:28:46 <chessguy> anyway, it runs, but hangs here
20:31:27 <Modius> Okay, this is going to get me into the newbie hall of fame; but I'm Unable to figure out how to RunHaskell without it complaining of not being able to find GHC (which is in the same bin directory on my XP box)
20:31:40 <Modius> I guess there's an environ variable that hasn't been set?
20:31:42 <dons> sjanssen: i notice one annoying thing i'd like to fix: switching workspaces, and going back, loses track of which window was on top of the tag set
20:31:49 <dons> in fullscreen mode
20:32:19 <monochrom> probably need PATH, yeah.
20:32:25 <dons> but only if the stack in fullscreen mode doesn't correspond to the layout in tiled mode
20:32:29 <dons> hmm
20:32:39 <chessguy> oh weird, now it's working
20:32:43 <sjanssen> dons: I think this used to work
20:32:51 <dmwit> chessguy: Maybe the server wasn't responding?
20:33:04 <dons> yeah, so i guess its just checking the tiling order to work out which window is on top
20:33:13 <chessguy> no, it has to do with the www or lack thereof in the address
20:33:21 <dons> but that's not a) being updated in fullscreen mode, or b) its just ignoring whatever order fullscreen uses
20:33:51 <monochrom> path=%path%;c:\ghc\ghc-6.6\bin    try this, vary the actual content to your case of course
20:35:41 <sorear> you don't need SET anymore?
20:36:07 <chessguy> hmm, it's not hanging any more, but it's not getting spj's links either
20:37:17 <sjanssen> dons: hmm, the code looks correct to me
20:37:23 <Modius> Sorear: Did you really just write this now?
20:37:28 <dons> sjanssen: do you see this behaviour?
20:37:52 <sorear> Modius: well, not before you said the problem
20:38:30 <dons> one screen in fullscreen, shuffle the window order a bit, switch to another screen, switch back, order is changed.
20:38:49 <dons> but not in tiled mode, or if you just switch from tiled to fullscreen (then the tiled order is the same as the fullscreen stack)
20:38:53 <monochrom> OH! Apparently we don't need SET anymore!  For path that is.
20:38:57 <Modius> The code worked.  Your skill + this language are astounding.
20:39:13 <sjanssen> dons: yeah, I see it
20:39:49 <sjanssen> dons: order stays the same right, it's just that the top window is different?
20:40:32 <dons> yeah
20:40:51 * jcreigh suspects event handling
20:41:01 <dons> yes, order is the same.
20:41:20 <dons> jcreigh: have you tried the dmenu cache patch?
20:41:29 <dons> it really improves dmenu startup time
20:41:31 <jcreigh> dons: naw, I have a static dmenu
20:41:37 <sjanssen> jcreigh: theoretically we shouldn't be receiving any spurious EnterNotify events -- because only one window moves
20:41:59 <hpaste>  sorear annotated "my code" with "Single list version, about 10x faster" at http://hpaste.org/1334#a1
20:42:02 <dmwit> dons: You might also blame your dmenu_path command.
20:42:24 <dons> ah, it only happens if the screen you switch to is empty?
20:42:30 <dons> so a root enter/crossing event?
20:42:59 <sjanssen> ah yes, it does seem to be something with the root
20:43:16 <Modius> Sorear:  Since this is advanced enough to be well over my head, I'm wondering if there's some special construct you're using vs. a more naive solution to keep the performance of this viable vs. the naive solution
20:43:24 <sjanssen> hmm, so what do we do when we enter/leave the root . . .
20:43:35 <Modius> Sorear:  I'd like to research it.
20:43:40 <dons> yeah, i seem to recall some rather speculative logic for that case.
20:44:01 <chessguy> @tell ndm FYI, i can't get the spjPapers function in Example.hs to work. doing openURL on http://research.microsoft.com/~simonpj makes it hang, and if i add a www. to it, it gets a document, but not the correct one. just thought you might like to know before you release...
20:44:01 <lambdabot> Consider it noted.
20:44:10 <dons> ok. we go for lunch now. back in an hour or so
20:44:37 <chessguy> oh well, i tried
20:46:21 <sjanssen> oh, I get it now
20:46:50 <jcreigh> oh my...
20:47:00 <jcreigh> words cannot express how stupid I feel at this moment.
20:47:10 <dmwit> But a story can!
20:47:17 <TSC> Would you like us to try?
20:47:18 * dmwit settles in, eyes rapt
20:47:21 <jcreigh> lol
20:47:22 <sjanssen> erm, maybe I don't know what is going on
20:48:49 <jcreigh> I said "ws2screen" when I meant "screen2ws" and it just happened to be working for me because most of the time I have a one-to-one between screens and workspaces. So I'm sitting here scratching my head, wondering why I can't switch screen to screen #3 when, eg, workspace #9 is visible on it...
20:48:53 <sorear> Modius: the first case is just the lazy array filling idiom - memoization using an array, or something like that.  The second is the pseudo-standard imperative technique, using a list to accumulate at each stage
20:49:15 <sorear> jcreigh: it really is too bad newtypes add LoC
20:49:17 <jcreigh> now I'm going to try to write a QC property that would have caught this...
20:49:29 <sorear> newtypes would have, easily
20:49:48 * dmwit goes to look up newtypes
20:50:00 <sorear> @src Fd
20:50:01 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
20:50:04 <sorear> @src CInt
20:50:05 <lambdabot> Source not found. I've seen penguins that can type better than that.
20:50:10 <sjanssen> sorear: 1 line per newtype is an acceptable cost
20:50:28 <sorear> sjanssen: even when you have a 400 line cap? :)
20:50:45 <sjanssen> a 400 line cap that we're nearly 70 lines over?
20:50:46 <jcreigh> sorear: don't tell anybody, but we're not exactly under the cap. :)
20:51:01 <sjanssen> we should probably stop talking about caps
20:53:59 <dmwit> So newtype is just the same as type, but doesn't create the "synonym" relation?
20:54:21 <jcreigh> yes
20:54:22 <dmwit> Err, and seems to create a constructor.
20:54:31 <jcreigh> no, I don't believe it does.
20:54:41 <jcreigh> all the overhead happens at compile-time.
20:55:22 <dmwit> I mean, if you do newtype BigNum = BigNum Integer, and try to write foo :: BigNum -> BigNum,
20:55:23 <sjanssen> it creates a constructor, but the constructor is essentially a no-op
20:55:39 <dmwit> Then you would have to do foo (BigNum i) = BigNum (i * 2) ?
20:55:48 <sjanssen> dmwit: correct
20:56:00 <dmwit> ok
20:56:47 * jcreigh likes the idea of newtype WorkspaceN and newtype ScreenN...
20:56:57 <jcreigh> does that seem like an okay idea?
20:57:52 <sjanssen> N isn't particularly descriptive
20:57:53 <jcreigh> hmm...it would involve changing the type signature of pretty much everything...
20:58:08 <sjanssen> WorkspaceId, perhaps
20:58:13 <jcreigh> and yet, it's 5 characters shorter than "Number" :)
20:58:28 <jcreigh> ScreenId, WorkspaceId?
20:58:40 <sjanssen> yeah
21:06:45 <jcreigh> hmm...this is turning into a lot of work.
21:06:59 <jcreigh> I don't think I'll try to do the newtype thing. (Not tonight, anyway.)
21:08:48 <monochrom> I now announce http://www.haskell.org/haskellwiki/Dynamic_programming_example  :)
21:08:49 <lambdabot> Title: Dynamic programming example - HaskellWiki
21:16:36 * dmwit starts using Gimp in xmonad
21:17:15 <sorear> > let iterBuy 0 buf = odd buf ; iterBuy nrr buf = iterBuy (nrr-(1::Int)) ((buf `shiftL` 1 :: Int) .|. if buf .&. 0x8120 /= 0 then 1 else 0) ; buyable n = iterBuy n 1 in buyable 1000000
21:17:17 <lambdabot>  True
21:17:56 <sorear> > let { buyable n = r!n where { r = listArray (0,n) (True : map f [1..n]) ; f i = i >= 6 && r!(i-6) || i >= 9 && r!(i-9) || i >= 20 && r!(i-20) } } in buyable 1000000
21:18:00 <lambdabot>  True
21:18:03 <sorear> > let { buyable n = r!n where { r = listArray (0,n) (True : map f [1..n]) ; f i = i >= 6 && r!(i-6) || i >= 9 && r!(i-9) || i >= 20 && r!(i-20) } } in buyable 10000000
21:18:07 <lambdabot> Terminated
21:18:10 <sorear> > let iterBuy 0 buf = odd buf ; iterBuy nrr buf = iterBuy (nrr-(1::Int)) ((buf `shiftL` 1 :: Int) .|. if buf .&. 0x8120 /= 0 then 1 else 0) ; buyable n = iterBuy n 1 in buyable 10000000
21:18:12 <lambdabot>  True
21:19:13 <monochrom> I want to remark that for n>=44 the answer is true.
21:19:49 <sorear> Would a section on optimizing dynamic programming be a bad idea?
21:20:01 <josephholsten> no
21:20:02 <monochrom> Not a bad idea.
21:20:34 <monochrom> Interesting bitmask you're doing there. :)
21:20:38 <falconair_> is it possible to feed some tool a normal haskell source code file and have it return a completely de-sugared version of the code (no list comps, no do notation, no :: for cons, etc.) ?
21:20:55 <sorear> ghc -ddump-ds
21:21:01 <sorear> the output isn't haskell however
21:21:26 <sorear> Oh, I'm just compressing twenty bits of history into a single word
21:21:40 <olliej> sorear: it's core (or at least core-like) isn't it?
21:21:55 <olliej> sorear: or is that a different dump option
21:21:56 <sorear> yes
21:22:18 <sorear> everything from -ddump-ds to -ddump-simpl spits out core or something very similar to it
21:22:25 <falconair_> sorear: secondly, is there a way to print out an ast in a way which can be easily parsed by another tool (say in scheme like syntax)?
21:22:34 <sorear> -fext-core
21:22:41 <falconair_> wow, thanks! :)
21:22:42 <olliej> sorear: yeah
21:22:47 <olliej> sorear: that's what i used :D
21:22:59 <sorear> falconair_: it's designed to be parsed, but I don't think it is fully scheme like
21:23:17 <sorear> falconair_: also, the ext-core system is rather bitrotted since 6.2 (6.0?)
21:23:30 <olliej> falconair_: core is a fully typed minimal-ish functional language
21:23:33 <sorear> falconair_: mostly the input is affected, but output is missing info too
21:23:40 <olliej> (And it's easy ot parse)
21:23:49 <sorear> case, let, lambda, and application
21:23:54 <olliej> sorear: it's not particularly reliable though
21:23:55 <sorear> and types
21:24:04 <sorear> olliej: ?
21:24:06 <falconair_> no problem, i was just thinking of experimenting with converting haskell functions to some graphical representation...sort of super graphical haskell ...
21:24:11 <olliej> sorear: and the most annoying encoding scheme in the worlds
21:24:22 <sorear> olliej: -fext-core is known to be broken now, if that's what you mean
21:24:30 <sorear> olliej: it's being fixed for 6.8
21:24:34 <olliej> sorear: doesn't have a way to represent 16 bit unicode, ffi
21:24:37 <olliej> hehe
21:25:03 <olliej> i won't be looking at it for some time (if at all), so it's not really a problem anyway
21:25:20 <josephholsten> sorear: should I know who you are? or are just an anonymous super helpful guy?
21:25:45 <sorear> random super helpful guy
21:25:50 <sjanssen> sorear is a famous movie star
21:26:27 <josephholsten> not necessarily contracictory statements
21:28:20 <sorear> Right now, I'm a person who helps in #haskell and haskell-cafe@haskell.org, I wrote vty and some of Data.Derive, and I made it to the 10000-person round of the (hs-junior) US Mathematical Olympiad.  Beyond that, you have no reason to have heard of me.
21:29:04 <Tene> Also, he's extremely attractive, as all skilled haskell hackers are.
21:29:09 <josephholsten> hs-junior? high school?
21:29:15 <sorear> yes
21:30:29 <jcreigh> sorear's purpose in life is to make people older than him feel stupid. :)
21:30:32 <Heffalump> is the hs-junior one distinct from the normal one?
21:30:45 <josephholsten> very impressive.
21:31:09 <josephholsten> I only knew scripting languages then.
21:31:09 <sorear> I don't know.  I think it's just segregated to stop people from being embarrassed by younger people.
21:32:05 <Heffalump> the US Physics Olympiad team had someone quite young on it several years ago
21:34:40 <josephholsten> I wish I knew more math. I'm taking vector calc now, but I don't know what else to take.
21:38:01 <Pseudonym> You need to take everything.
21:38:07 <Pseudonym> OK, that's not trye.
21:38:15 <Pseudonym> You WANT to take everything!
21:38:46 <Cale> josephholsten: Okay, so you've had linear algebra then?
21:38:50 <dmead> my school dominated in the local physics leauge
21:38:56 <dmead> bongg
21:39:06 <Cale> josephholsten: Probably a good place to start would be group and ring theory
21:39:19 <Cale> Or if you want analysis, try the theory of metric spaces.
21:39:20 <dmead> or combinatorics?
21:39:28 <Cale> Or sure, combinatorics is great :)
21:39:46 <josephholsten> taking  linear presently
21:40:10 <Cale> Either enumerative stuff -- ordinary and maybe exponential generating series.
21:40:21 <Cale> or graph theory
21:40:26 <josephholsten> gah, batter dying must switch to a hotspot with power
21:40:53 <josephholsten> though yes, all those sound better than complex analysis
21:40:57 <josephholsten> brb
21:43:22 <sorear> I now announce http://www.haskell.org/haskellwiki/Dynamic_programming_example#Optimization :)
21:43:25 <lambdabot> Title: Dynamic programming example - HaskellWiki, http://tinyurl.com/yutqzc
21:45:51 <tuxplorer> Prelude> :t (\x -> x 'a')
21:45:51 <tuxplorer> (\x -> x 'a') :: forall t. (Char -> t) -> t
21:45:51 <tuxplorer> I don't understand the meaning of this
21:46:24 <Cale> tuxplorer: it takes a function which takes a Char and applies it
21:46:58 <eumenides> > (\x -> x 'a') ord
21:47:00 <lambdabot>  97
21:47:09 <sorear> movl $2,%ecx  ;  cltd  ;  idivl %ecx  ;  testl %edx,%edx  ;  jne .LctL
21:47:19 <sorear> ghc generates ... impressive code for odd
21:47:31 <dmwit> > ($ 'a') ord
21:47:33 <lambdabot>  97
21:47:39 <tuxplorer> what's ord?
21:47:45 <sorear> that does a 64->32x32 divide by 2 and tests the result for zeroness
21:47:45 <eumenides> > ord 'a'
21:47:47 <lambdabot>  97
21:47:56 <dmwit> tuxplorer: It gives the ASCII value of a character.
21:48:02 <Heffalump> sorear: on Ints?
21:48:02 <tuxplorer> oh! ok
21:48:08 <Heffalump> or on Int64?
21:48:11 <sorear> somehow I think testb %al, $1  ;  jnz .LctL  would have been faster
21:48:14 <sorear> Heffalump: Int
21:48:16 <Heffalump> heh
21:48:24 <tuxplorer> Thanks guys.. now I understand it :)
21:48:33 <Heffalump> presumably odd is defined as \x -> x `div` 2 == 0
21:48:38 <sorear> Mind you, this code is only executed once per call.
21:48:41 <Heffalump> IM /= 0
21:49:03 <tuxplorer> in which library is ord defined? my ghci says not in scope
21:49:04 <sorear> Heffalump: Any reasonable compiler should turn that into a bit mask. I'm pretty sure gcc does
21:49:34 <dmwit> > (\x -> x `div` 2 == 0) 35
21:49:36 <lambdabot>  False
21:49:44 <dmwit> > (\x -> x `mod` 2 == 0) 35
21:49:46 <lambdabot>  False
21:49:49 <dons> sjanssen: did we work out the workspace issue?
21:49:57 <dons> missing type information/wrong function call?
21:49:57 <dmwit> > (\x -> x `div` 2 == 0) 36
21:49:59 <lambdabot>  False
21:50:06 <sorear>         testb   $1, %al
21:50:17 <sorear> indeed, gcc does generate a mask.
21:50:31 <sorear> dons: wc2screen :: Int -> Int   ; screen2wc :: Int -> Int
21:50:36 <sorear> jcreigh used the wrong one
21:50:40 <sorear> we have newtypes now
21:50:45 <Heffalump> sorear: does ghc have peephole optimisations or the like?
21:51:00 <sorear> Heffalump: I should hope?
21:51:02 <Heffalump> dmwit: ok, I meant ord.
21:51:16 <jcreigh> sorear: actually, Map Int Int, but yes, same basic mistake.
21:51:34 <Heffalump> sorear: was that via-C or straight to asm?
21:51:42 <sorear> Heffalump: straight to asm
21:51:46 <sorear> gcc knew better
21:52:03 <Heffalump> well, the gcc backend has been in use longer, so probably ghc is used to relying on gcc to do that stuff
21:52:16 <sorear> still, I have to laugh at the quality of the code either way.
21:52:57 <sorear> the loop is like 40 instructions
21:56:45 <sorear> mov ecx, [esp+4]  ;  jecxz L2  ;  mov eax, 1  ;  L1:  test eax, 0x8120  ;  setnz bl  ;  shl eax, 1  ;  or al, bl  ;  dec ecx  ;  jnz L1  ;  and eax, 1  ; ret   -- my version of the loop - 6 insns and no non-loop-control conditional branches
21:59:31 <sorear> @ask dons can we have the stats page use UTC?
21:59:32 <lambdabot> Consider it noted.
21:59:37 <sorear> @flush
21:59:38 <Heffalump> and can you see an obvious optimisation path from the bad code to the good code?
21:59:53 <Heffalump> consisting just of simple transformations not specific to this example
21:59:57 <sorear> ghc could start by using registers :)
22:00:17 <sorear> the generated code (both -fasm and -fvia-C) is mostly stack manipulation
22:00:51 <sorear> the cmm is so riddled with aliasing hazards no backend compiler could hope to do a reasonable job
22:01:13 <sorear> well, ok, ok, I'll stop talking from experience and read the specific code
22:02:17 <sorear> this isn't quite as bad as what I've seen in the past
22:02:48 <sorear> gcc does have half a chance of figuring out I32[Sp] will not alias I32[Sp+4] without intervening Sp manipulation
22:03:02 <sorear> then again, aren't global register vars automatically volatile?
22:04:13 <dons> hmm. stats in UTC.
22:04:14 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
22:04:45 <dons> jcreigh: yeah, so i think we can newtype wildly
22:04:49 <dons> the more static checks the better
22:05:05 <Pseudonym> The optimisation path doesn't need to be "obvious", BTW.
22:05:19 <Pseudonym> All you need to see is a possible optimisation path, and then justify why it's generally applicable.
22:07:18 <sorear> must sleep, bye
22:07:59 <jcreigh> dons: okay. I don't have any immediate plans to do the newtype change...maybe something for the TODO
22:08:04 <dons> jcreigh: yes, that bug seems to be fixed now.
22:08:12 <dons> i could probably do it this afternoon, actually
22:08:42 <dons> jcreigh: so the types should be, for:
22:08:43 <dons>         , ws2screen:: !(M.Map Int Int)  -- ^ workspace -> screen map
22:08:43 <dons>         , screen2ws:: !(M.Map Int Int)  -- ^ screen -> workspace
22:08:44 <dons> what?
22:08:57 <dons> M.Map WorkspaceT ScreenT
22:09:02 <dons> and M.Map ScreenT WorkspaceT ?
22:09:12 <jcreigh> sjanssen was thinking WorkspaceId and ScreenId
22:09:17 <jcreigh> which seems reasonable to me.
22:09:18 <dons> ok.
22:09:52 <dons> ok. i'll do that now then
22:10:19 <dons> if in doubt, lean on the type system
22:11:52 <jcreigh> dons: cool, thanks. that'll give us some more safety and make the type signatures more readable.
22:11:56 <dons> hmm, then where else do we have nasty Ints that shouldn't be Ints?
22:12:09 <dons> most of the other Ints are screenIds
22:12:11 <dons> I think?
22:12:31 <jcreigh> I think it's
22:12:35 <jcreigh> current :: ScreenId
22:12:48 <jcreigh> ws2screen :: Map WorkspaceId ScreenId
22:12:48 <dons> yep
22:12:54 <jcreigh> screen2ws Map ScreenId WorkspaceId
22:12:57 <dons> yep
22:13:04 <dons> then stacks is keyed by ScreenId
22:13:05 <jcreigh> stacks :: Map WorkSpaceId [a]
22:13:12 <dons> ah.
22:13:22 <jcreigh> focus :: Map WorkspaceId a
22:13:35 <jcreigh> cache :: Map a WorkspaceId
22:14:00 <dons> ah ok, i had the notion of 'workspace' and 'screen' inverted :-)
22:14:05 <Cale> Ubuntu 7.04's Haskell support is really good, but I think they've split things up a bit much. Installing ghc6 doesn't install the mtl.
22:14:12 <jcreigh> ah. :)
22:14:28 <jcreigh> Cale: I think etch is that way too....
22:14:34 <sjanssen> Cale: Gentoo does this too, I actually prefer it that way
22:14:35 <dons> yes, screen == Xinerama screen , right?
22:14:40 <jcreigh> dons: yup
22:14:40 <sjanssen> yes
22:14:50 <sjanssen> screen == actual object that you stare at
22:15:01 <dons> physical screen, right.
22:15:09 * dons reads Config.hs and notes this is all explained nicely.
22:15:32 <dons> hmm, maybe PhysScreenId is clearer.
22:15:41 <dons> or PhysicalScreen/Workspace
22:15:45 <dons> no need for the Id suffix?
22:16:13 <sjanssen> I've got plans to make an actual Workspace data type later on
22:16:22 <dons> ah ok.
22:16:57 <sjanssen> and the thing we're calling WorkspaceId isn't really a workspace, it's a reference to one
22:17:10 <dons> yeah.
22:17:13 <sjanssen> Cale: does Ubuntu have some sort of ghc-extralibs metapackage?
22:17:44 <jcreigh> do we have an "exit strategy" for X11-extras? At what point, if ever, does it get merged into main X11?
22:18:03 <Cale> sjanssen: not that I can see
22:18:06 <dons> jcreigh: we'll see how the XHSB project goes :-)
22:18:30 <Cale> sjanssen: It's got libghc6-*-dev for what looks like most of the cabalised packages.
22:18:43 <dons> the nice thing about newtypes is that the compiler identifies all the dodgy places that need checking
22:18:54 <sjanssen> Cale: that'd be a handy addition, I think (Gentoo could use this too)
22:18:56 <Cale> and Gtk2Hs
22:19:05 <Cale> yeah, it would be
22:19:19 <Cale> (Is gtk2hs cabalised now?)
22:19:34 <Heffalump> if Ubuntu pulls stuff in from Debian, ask Igloo to add one
22:19:40 <dmwit> Cale: Yes.
22:19:51 <sjanssen> jcreigh: I'm not too concerned with merging X11-extras until it's reached a certain point of stability
22:19:59 * Heffalump --> work
22:20:07 <dmwit> Cale: Err, by which I mean no.
22:20:15 <Cale> dmwit: hehe
22:21:03 <jcreigh> sjanssen: that's probably a good idea. there's some naming convention stuff we'll have to iron out eventually. (some record types are prefixed, some aren't, someAreCamelCase, whereas X11 just does, eg, rect_x, etc.)
22:21:23 <sjanssen> right
22:21:52 <dons> so i'm trying:
22:21:53 <dons> -- | Physical screen indicies
22:21:54 <dons> newtype ScreenId    = S Int deriving (Eq,Ord,Show,Enum,Num)
22:21:54 <dons> -- | Virtual workspace indicies
22:21:54 <dons> newtype WorkspaceId = W Int deriving (Eq,Ord,Show,Enum,Num)
22:21:57 <dons> whatddya think?
22:22:02 <sjanssen> looks good
22:22:02 <dons> then we have,
22:22:03 <dons> empty n m = StackSet { current   = S 0
22:22:03 <dons>                      , ws2screen = wsScreenAssn
22:22:03 <dons>                      , screen2ws = wsScreenAssn
22:22:12 <jcreigh> I was able to write a QC property that would have caught my stupid bug, BTW. Quickcheck is kind of a cool concept.
22:22:16 <sjanssen> dons: the S is technically not needed there
22:22:22 <dons> ah yes, now it isn't.
22:22:27 <dons> newtype deriving ++ ;-)
22:25:42 <jcreigh> dons: does that work? How could you set them both to wsScreenAssn when ws2screen and screen2ws have different types? (Or are you getting to that?)
22:26:03 <dons> getting to that.
22:26:07 <jcreigh> ah
22:26:09 <dons> assns = unzip $ map (\x -> (S x, W x)) [0..m-1]
22:26:21 <dons> then one is the tranpose of the other
22:26:53 <dons> we should have done this earlier. conflating index types like this to Int is a bit icky
22:27:01 <sjanssen> yeah
22:27:36 <sjanssen> is everything zero indexed now?
22:27:36 <dons>     where (scrs,wrks)  = unzip $ map (\x -> (S x, W x)) [0..m-1]
22:27:36 <dons>           wsScrs2Works = M.fromList (zip scrs wrks)
22:27:37 <dons>           wsWorks2Scrs = M.fromList (zip wrks scrs)
22:27:40 <dons> hmm
22:27:58 <dons> good question
22:27:59 <sjanssen> there are some strange comments like "view. Change the current workspace to workspce at offset 'n-1'"
22:28:12 <jcreigh> sjanssen: interally, I beleive so. "tag" and "view" still take 1-indexed arguments, which is kind of annoying.
22:28:14 <dons> yeah. that's for mod-1..n
22:28:23 <dons> which we internally map to 0..n-1
22:28:32 <dcoutts> Cale: Gtk2Hs is not cabalised and it will not be so for some time, there's lots of work in c2hs and Cabal before that becomes possible.
22:28:36 <dons> suggestions welcome.
22:29:35 <sjanssen> I say we go zero indexed from top to bottom
22:29:45 <jcreigh> if "view" and "tag" were zero-indexed as well, then "screenWorkspace" could return the actual workspace #, instead of workspace # + 1
22:29:50 <sjanssen> I'll do that after dons commits the newtype changes
22:30:12 <dons> yep. just going through the type checking errors.
22:30:18 <dons> StackSet.hs:107:12:
22:30:18 <dons>     Couldn't match expected type `Int' against inferred type `ScreenId'
22:30:20 <dons> ghc++ :-)
22:33:50 <sjanssen> sloccount is such a pretentious tool
22:34:20 <dons> are we millionaires yet?
22:34:54 <hpaste>  sjanssen pasted "annoying sloccount output" at http://hpaste.org/1337
22:35:01 <dons> 1337!
22:35:29 <dcoutts> sloccount only claims to be even vaguely accurate under the assumption that someone would actually want the program that you are writing
22:35:31 <sjanssen> what sort of program needs warranty and copyright statements in every output?
22:35:50 <sjanssen> "Please credit this data as "generated using David A. Wheeler's 'SLOCCount'."
22:35:55 <dcoutts> sjanssen: most gnu interactive progs do that actually
22:36:06 <dons> "Please credit this data as "generated using David A. Wheeler's 'SLOCCount'."" urgh.
22:36:11 <sjanssen> oh come on now, it's just some comment/whitespace munging
22:36:50 <dcoutts> sjanssen: there's a paper on the cost models etc, it's more than line counts
22:36:55 <ibid> sjanssen: the gpl specifically protects interactive program copyright&warranty statements, and many people feel better if they invoke that :)
22:37:32 <sjanssen> so I guess I'm just ignorant :)
22:37:56 <ibid> (it is forbidden to remove them from an interactive gpl program)
22:39:16 <dcoutts> unless you make the program non-interactive presumably
22:39:55 <sjanssen> I would like to see a version of sloccount that doesn't output an entire page of output on every run
22:40:56 <ibid> dcoutts: apparently
22:41:17 <sjanssen> is sloccount really interactive?  It's just batch processing
22:41:21 <ibid> dcoutts: but you are required to add this if you make a noninteractive gpl program into an interactive one (i hadn't noticed this before)
22:41:27 <sjanssen> should ls output similar data?
22:41:32 <ibid> no
22:41:37 <ibid> the definition is "If the modified program normally reads commands interactively when run
22:41:39 <Cale> How could there have been an average of less than one developer working on xmonad?
22:41:41 <ibid> "
22:41:42 <dons> jcreigh: I think this is wrong?  current  :: !ScreenId                      -- ^ the currently visible stack
22:41:47 <dons> should be current :: WorkspaceId ?
22:41:55 <dons> otherwise,
22:41:56 <dons> push :: Ord a => a -> StackSet a -> StackSet a
22:41:56 <dons> push k w = insert k (current w) w
22:42:02 <dons> makes no sense?
22:42:08 <dons> given, insert :: Ord a => a -> WorkspaceId -> StackSet a -> StackSet a
22:42:17 <dcoutts> Cale: part-time ? :-)
22:42:32 <dons> sjanssen: right, current is the workspace that's visible, isn't it?
22:42:40 <dcoutts> so long as it's non-negative it's plausible
22:42:45 <dons> newtypes are hygienic
22:42:47 <dcoutts> doesn't need to be an integer
22:42:56 <Cale> dcoutts: I suppose -- that seems like a ridiculous assumption to make though.
22:42:58 <jcreigh> dons: yes, "current" is the currently visible *workspace*
22:43:01 <sjanssen> ibid: sloccount doesn't seem to do anything interactively
22:43:09 <jcreigh> so current :: WorkspaceId
22:43:19 <sjanssen> newtype ftw
22:43:36 <dons> yeah, the types just don't go together if its a ScreenId
22:44:04 <ibid> sjanssen: hence, "no" :)
22:44:45 <sjanssen> ibid: ah, I thought you were responding to my asinine question about ls.  Maybe both, eh? ;)
22:45:07 <jcreigh> what, xmonad is only worth $12K? :)
22:45:19 <ibid> sjanssen: i was slow :)
22:45:31 <dons> clearly, haskell lowers the cost of writing window managers.
22:45:35 * sjanssen would be happy with $12K
22:45:35 <dons> how much does ion cost? ;-)
22:45:36 <ibid> sjanssen: ... looking up the def in gpl
22:45:42 <dons> or dwm?
22:45:54 <dons> the *point is* that is should be cheaper to write in haskell :-)
22:46:06 <ibid> dons: actually, sloccount effort estimates are very high for most free software :)
22:46:08 <sjanssen> dons: $48,359
22:46:08 <dons> once you've paid for all the phds ..
22:46:11 <sjanssen> for dwm
22:46:15 <ibid> dons: regardless of language
22:46:27 <dons> ibid: yeah, its to make us feel good.
22:46:58 <dons> woot. type checks
22:46:59 <ibid> dons: there's also the point that we don't usually write tons of internal dicumentation :)
22:47:08 <dons> hey. some of us do.
22:47:14 <dons>                       Code  Comments
22:47:15 <dons> Config.hs                92     50
22:47:15 <dons> Main.hs                 102     87
22:47:15 <dons> Operations.hs           166     89
22:47:15 <dons> StackSet.hs             101    121
22:47:17 <dons> XMonad.hs                52     60
22:47:18 <sjanssen> xmonad does pretty well in that area
22:47:19 <dons> TOTAL:                  513    407
22:47:22 <dons> hehe
22:47:24 <dons> though we're slipping!
22:47:34 <dons> the Config.hs cost looks wrong.
22:47:37 <sjanssen> dons: I'm pretty sure that script is misparsing the source
22:47:40 <dons> since that's almost all comments.
22:47:45 <dons> yeah.
22:47:45 <ibid> dons: i doubt you do it a much as traditional software process :)
22:47:49 <dons> probably {- -} comments
22:47:52 <jcreigh> dons: maybe sloccount doesn't know about {- -}?
22:47:59 <dons> yeah
22:48:03 <dons> or count_lines, as it were.
22:48:12 <jcreigh> oh, right
22:48:21 <dons> sjanssen: so occasionally (2 places) we do this:
22:48:21 <dons> view n w | n >= 0 && n < fromIntegral (M.size (stacks w)) -- coerce
22:48:37 <dons> where 'n' is a WorkspaceId
22:48:58 <jcreigh> dons: only two? That seems good. I was afraid there would be fromIntegrals all over.
22:49:02 <dons> seems sane, given we can't overload on Num unfortunately.
22:49:19 <dons> nah. only 2 places, one where we check against a length. oh, that could be genericLength
22:49:23 <dons> ok then, only 1 place :-)
22:49:26 <jcreigh> heh
22:49:43 <dons> fromList (n,xs) | n < 0 || n >= genericLength xs
22:50:43 <sjanssen> dons: we could simplify that to: view n w |  M.member n (stacks w)
22:51:22 <dons> yes, that's better
22:52:04 <sjanssen> that makes zero coercions?
22:52:26 <dons> yes.
22:52:28 <dons> :-)
22:52:31 <sjanssen> excellent
22:52:43 <dons> (inside StackSet, that is). we'll see what happens on the outside.
22:52:54 <dons> somewhere key strokes have to be wrapped in W or S or fromIntegra
22:53:55 <dons> ok, XMonad.hs compiles now .
22:53:59 <dons> onto Operations.hs
22:55:18 <dons>  xineScreens       :: ![Rectangle]  is indexed via Int
22:55:19 <dons> using !!
22:55:35 <sjanssen> mmm yes, ugliness
22:55:44 <sjanssen> @hoogle genericIndex
22:55:45 <lambdabot> List.genericIndex :: Integral a => [b] -> a -> b
22:55:53 <sjanssen> the ugly, temporary hack ^^^
22:55:54 <dons> that'll do for now.
22:55:56 <dons> yeah.
22:57:28 <dons> i'll fix the tag/n-1 issue while i'm here.
22:57:55 <sjanssen> don't forget screenWorkspace
22:58:14 <dons> ok.
23:00:08 <dons> screenWorkspace :: ScreenId -> X WorkspaceId
23:00:08 <dons>  ?
23:00:27 <sjanssen> yeah
23:00:45 <dons> and we'll need to fix it to offset from 0.
23:01:00 <dons> ah, toss the 'succ'
23:01:15 * dons watches layers of cludge unravel.
23:02:24 <dons> ok. Operatoins.hs typechecks.
23:04:11 <dons> and Config.hs
23:04:53 <dons> and it builds.
23:08:18 <dons> ok. seems to work.
23:08:26 <dons> newtype deriving rocks.
23:09:41 <dons> jcreigh: so your last patch added a lower and upper workspace count?
23:10:22 <dons> ah I see.
23:12:03 <dons> ok. newtype patch pushed.
23:12:12 <dons> TOTAL:                  466    454
23:27:37 <jargonjustin> Where is a good source to learn more about bottom, newtype and strict fields?
23:27:51 <sjanssen> the report
23:27:54 <sjanssen> @where report
23:27:55 <lambdabot> http://www.haskell.org/onlinereport/
23:29:12 <jargonjustin> sjanssen: Any particular section?  Google isn't coming up with anything.
23:29:42 <sjanssen> 4.2.3 has some examples of differences between data and newtype
23:31:09 <jargonjustin> sjanssen: Thanks, I think the section in Daume's YAHT is a little better, but more material to work through is always good.
23:31:14 <Korollary> jargonjustin: newtype is right here: http://www.haskell.org/onlinereport/decls.html#sect4.2.3
23:31:16 <lambdabot> Title: The Haskell 98 Report: Declarations
23:32:13 <sjanssen> jargonjustin: in short, data X = X !a and newtype X = X a are essentially the same with respect to strictness and bottom
23:33:08 <jargonjustin> sjanssen: So as far as the type system is concerned (minus derived instances) they're basically semantically equivalent?
23:33:26 <ski> 'foo (X _) = 42' will work differently for the two, though
23:33:29 <sjanssen> jargonjustin: yes, essentially
23:34:12 <ski> matching on a newtype constructor is a noop (O(0)), so it doesn't force the contents
23:34:26 <ski> matching on a strict data constructor forces the contents, however
23:35:05 <sjanssen> ah yes, that is the one tricky part
23:36:01 <sjanssen> functions that are strict in the constructor but lazy in the wrapped component will behave differently
23:40:55 <jargonjustin> Strict fields are evaluated when the constructor is applied?
23:41:13 <sjanssen> right
23:41:35 <sjanssen> in our above example "X y" is desugared to "y `seq` X y"
23:41:36 <ski> s/applied/forced/
23:41:59 <sjanssen> ski: there's no difference
23:42:02 <ski> (though i guess one could argue it means the same in haskell)
23:42:09 <ski> :)
23:42:52 <sjanssen> and technically, the report doesn't even say "evaluated"
23:43:12 <jargonjustin> The report mentions that a newtype can be recursive, that would require tuple of some sort to be involved, right?
23:43:33 <sjanssen> the semantics of seq are: seq _|_ _ = _|_; seq _ x = x
23:43:37 <jargonjustin> newtype Foo = Foo (Int, Foo) -- for example ?
23:43:50 <sjanssen> so all a compiler has to do is prove that the first argument doesn't diverge
23:44:08 <sjanssen> newtype Foo = Foo Foo -- is legal too
23:44:27 <jargonjustin> sjanssen: How is that sensible or useful?
23:45:36 <sjanssen> it's not useful at all, just wanted to point out that it's legal
23:47:33 <jargonjustin> Okay, going back to bottom, I'm reading the description for seq how would that be used?
23:48:00 <ski> newtype U a = MkU (U a -> a)  -- this is a fun one
23:48:11 <sjanssen> despite what I said earlier, seq is used to force evaluation
23:48:50 <jargonjustin> Of a?
23:49:28 <sjanssen> it forces enough evaluation to reveal the top level constructor
23:49:47 <sjanssen> (forces evaluation of the first argument, then returns the second)
23:49:49 <ski> > seq (undefined,0) 42
23:49:50 <lambdabot>  42
23:49:59 <ski> > seq undefined 42
23:50:01 <lambdabot>  Undefined
23:50:19 <ski> > seq (1 `div` 0) 42
23:50:20 <lambdabot>  Exception: divide by zero
23:50:21 <earthy> whnf
23:50:28 <jargonjustin> Okay, so the compiler has to get far enough to determine the type of the top-level expression and prove it's not bottom
23:50:32 <sjanssen> jargonjustin: it's most useful for fighting space leaks
23:51:04 <sjanssen> jargonjustin: nah, the type is known statically at compile time.  seq is run time behavior
23:51:22 <jargonjustin> Should I worry much about being a little hazy on how bottom works? (still learning Haskell)
23:51:27 <ski> it determines the top-level "shape" you could say
23:51:44 <sjanssen> jargonjustin: nah, you should be fine for a good while
23:52:04 <ski> an expression "evaluating to bottom" just means that it fails to evaluate to a proper value
23:53:01 <jargonjustin> Before moving on though, going back to seq, even though the type is known at compile time (should have realized this it is Haskell) it has to "evaluate" enough to prove the value isn't bottom (ie: get to the constructor and make sure it's not going to be bottom) ?
23:53:07 <sjanssen> that includes all of: calls to error and undefined; pattern match failures; non-termination; and trying to pattern match against another bottom
23:53:37 <dons> rather nice! http://programming.reddit.com/info/1gy6c/comments
23:53:39 <lambdabot> Title: Haskell: an Imperative Language with Mutable State (reddit.com)
23:54:01 <sjanssen> jargonjustin: right, the only practical way to prove that the value is non-bottom is to reveal the constructor (doing anything else would potentially require solving the halting problem)
23:54:16 <dons> Korollary: hehe. why are you always such a grumpy one on reddit?
23:54:43 <dons> anyone would think you hated the world and all values in it.
23:54:48 <sjanssen> jargonjustin: you can imagine that seq is the magic compiler primitive that knows how to pattern match against any type
23:56:22 <jargonjustin> sjanssen: Thanks!  This actually makes sense now.
23:56:38 <Korollary> dons: Shhh. I'm trying to work my way to cardiac surgery.
23:56:55 <dons> cool! good luck with that.
23:57:02 <dons> let me know how it turns out.
23:57:59 <joelr1> morning
23:58:15 <dons> heya joelr1
23:58:48 <dons> joelr1: oh, the paper on generative high-perf monte carlo simulators is out. you mentioned you wanted to have a peep at that?
23:58:57 <joelr1> dons: haskell is much nicer the second time around
23:59:14 <dons> good to know. we have some nice libraries now :-)
23:59:30 <joelr1> dons: i have the paper on my reading list, will read it this saturday most likely. together with the fusion paper. thanks!
23:59:40 * dons notes that the hackage db is getting updated daily!
23:59:46 <dons> http://hackage.haskell.org/packages/archive/recent.html
