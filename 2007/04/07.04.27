00:04:12 <somezero> @quote success
00:04:12 <lambdabot> dons says: i wish you success and may your lambdas always beta reduce.
00:04:18 <somezero> I like that one :)
00:12:21 <dolio> Heh, xkcd is pretty good today.
00:15:37 <bos> am i correct in thinking that it's not possible to declare String to be an instance of a class?
00:16:11 <dolio> Hmm...
00:16:15 <ddarius> With mild extensions you can.
00:16:58 <bos> hmm, -fglasgow-exts seems to do the trick.
00:17:13 <dolio> @instances Show
00:17:15 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
00:17:18 <bos> thanks.
00:18:46 <alexj> is it possible to use runhaskell on a module that has a module declaration?
00:19:26 <alexj> e.g. runhaskell Foo/Bar/Baz.hs
00:19:40 <alexj> it appears not to be working for me, but perhaps I am doing something stupid.
00:19:41 <bos> @hoogle UserID
00:19:42 <lambdabot> No matches found
00:21:28 <bos> i'm writing "find" in haskell.
00:21:32 <bos> 'tis fun.
00:22:27 <bos> find "/home/bos" (isType Regular /&/ size />/ 1024)
00:25:47 <dons> this is for ayrnieu, :-)  --> http://programming.reddit.com/info/1ldo5/details
00:25:49 <lambdabot> Title: Massively concurrent network services in Haskell: user-land thread scheduling (r ...
00:26:20 <dolio> Heh. Are you sure he's not qwe1234 in disguise? :)
00:26:53 <dons> nah, its Julian Fondren. he used to hang out here a couple of years ago, and has taken on the roll of lone haskell detractor
00:27:26 <dons> its just frustrating in that he mixes misleading statements with hyperbole, grumble.
00:27:51 <dons> its actually quite funny reading his comments in here on laziness and monads. so positivie! http://www.cse.unsw.edu.au/~dons/tmp/ayrnieu.txt
00:28:06 <dolio> Yeah. He seems generally informative, but he really turns the trolling on on Haskell articles.
00:28:09 <dons> I like "<ayrnieu> And sometimes, if you can express a problem lazily, you have simply won.  Game over :-)"
00:28:23 <dons> dolio: yes, its just a little game he wants to play
00:30:52 <dons> we should really get the libaio stuff packaged onto hackage.
00:32:00 <alexj> @where runhaskell
00:32:01 <lambdabot> I know nothing about runhaskell.
00:32:11 <DRMacIver> Morning
00:32:31 <alexj> anyone know where to find good documentation of runhaskell?
00:33:48 <bos> there isn't really any
00:34:17 <alexj> that's lovely.
00:34:19 <dons> what's to document? its just a ghci wrapper :-)
00:34:34 <dons> 50 loc, basically, to fork ghci
00:35:12 <DRMacIver> Anyone planning on going to the london Haskell user group meeting?
00:35:15 <alexj> ok if it is a ghci wrapper, how do I do: runhaskell -main-is Foo.Bar.Baz.main Foo/Bar/Baz.hs
01:11:15 <vali> hello, noble creatures
01:11:47 <Korollary> I just knighted somebody. You may be right.
01:12:38 * vali cheers
01:15:06 <vali> hmm
01:15:21 <vali> func1 x l = map (\y -> y * x) l
01:15:29 <vali> does anyone know how to turn that into point-free style?
01:15:58 <osfameron> I think lambdabot does
01:16:14 <sieni> @pl \x l ->  map (\y -> y * x) l
01:16:15 <lambdabot> map . (*)
01:16:18 <bos> @pl \x l ->  map (\y -> y * x) l
01:16:18 <bos> <vali> does anyone know how to turn that in
01:16:18 <lambdabot> map . (*)
01:16:31 <vali> thank you
01:27:28 <kuribas> Has anyone looked at the functional logic language Curry?
01:31:13 <kuribas> It seems like it is easier to represent some problems in Curry than in Haskell, (i.e. type inference).
01:32:10 <sjanssen> when will people learn that iterators, generators and streams don't express the whole of laziness?
01:33:48 <bos> @pl \f g x -> f x >>= g x
01:33:49 <lambdabot> liftM2 (>>=)
01:34:39 <merus> sjanssen, probably never.
01:37:37 <sieni> sjanssen: next thursday
01:38:16 <bos> @pl \a b p s -> a p s || b p s
01:38:16 <lambdabot> liftM2 (liftM2 (||))
01:39:28 <dmead> djinn means devil in arabic?
01:41:34 <LeCamarade> dmead: Yeah.
01:42:25 <LeCamarade> dmead: It's also where the `Genie' idea comes from. (See Aladin, a Middle-Eastern story, which has the genie.) > #haskell-blah
01:42:54 <dmead> ahh
01:43:06 <dmead> yea i'm reading some stuff on the early koran
01:43:11 <dmead> and that popped out at me
01:45:28 <mdmkolbe-work> does djinn know 'forall'?
01:45:36 <dmead> it should
01:46:16 <mdmkolbe-work> the following never returned (it's been at least a minute)
01:46:17 <mdmkolbe-work> @djinn (forall a. a -> m a) -> (forall a b. m a -> (a -> m b) -> m b) -> (forall a b c. (a -> b -> c) -> m a -> m b -> m c)
01:46:52 <sjanssen> mdmkolbe-work: no, it doesn't
01:47:24 <sjanssen> I've been told that could cause non-termination (currently djinn always terminates)
01:47:29 <quicksilver> it also doesn't have any axioms for Monads, I don't believe
01:47:40 <quicksilver> and your query didn't tell it that m was supposed to be a monad either (was it?)
01:48:12 <mdmkolbe-work> quicksilver: it was, but I don't think it requires any of the monad axioms to realize that function
01:49:00 <quicksilver> oh, I see, you're giving it return and bind as parameters anyway
01:54:26 <dmwit> ?src ap
01:54:26 <lambdabot> ap = liftM2 id
01:54:32 <dmwit> ?src liftM2
01:54:33 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
01:55:07 <quicksilver> ap is better defined as liftM2 ($)
01:55:14 <quicksilver> ?src is a bit perverse sometimes
01:55:15 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
01:55:37 <dmwit> quicksilver: I was just trying to imagine how to realize the function above.
01:55:45 <dmwit> I came up with a way that used ap, so... =P
01:56:15 <merus> ghci
01:56:19 <merus> damn, wrong window
01:56:21 <merus> ._.;
01:56:59 <ville> Howdy. Wish to try out some Haskell. My Linux distribution's package repository has GHC 6.4.2, is this adequately new since the current release is 6.6.x already? Reason why I ask that with another programming language I am familiar with, having an up-to-date compiler is important.
01:57:24 <dmwit> Hi ville!
01:57:27 <sjanssen> ville: 6.4.2 should generally be okay
01:57:30 <nornagon> ($) === `id`
01:57:33 <dmwit> I'm using 6.4.1 right now, and haven't done too bad yet.
01:57:42 <matthew-_> @seen ndm
01:57:42 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 18h 1m 10s ago, and .
01:58:10 <sjanssen> ville: ghc skips the odd numbered versions, so you're only one major version behind
01:58:27 <ville> sjanssen: Yeah the stable/development cycle
01:58:54 <sjanssen> ville: which distribution are you using?
01:58:57 <ville> Ok glad to hear it should be alright, just wish to be somewhat up-to-date.
01:59:01 <ville> sjanssen: Gentoo.
01:59:40 <sjanssen> ville: expect 6.6 in a couple weeks.  It's in portage with a hard mask, if you're feeling adventurous
01:59:46 <ville> sjanssen: They've 6.6 hardmasked, so I'll try to stear clear for now.
01:59:57 <ville> sjanssen: heh.
02:00:29 <ville> dmwit: Alright. I'll go ahead with 6.4.2.
02:01:53 <petekaz> Quick question, I'm reading dons blog on shell scripting, he has this instance defined: instance (Error e) => MonadError e (Either e) where throwError = Left
02:02:46 <petekaz> Either only has on type variable specified, that's ok?  Is that the same as instance (Error e) => MonadError e (Either e b) where throwError = Left
02:03:00 <dmwit> petekaz: It's a little different.
02:03:12 <dmwit> Either is a binary type constructor.
02:03:23 <quicksilver> petekaz: well, instances of MonadError e are supposed to be of kind * -> *
02:03:27 <dmwit> It can have partial application, just like a normal function, to create a partial type.
02:03:35 <quicksilver> petekaz: i.e. they're supposed to have one variable not-yet-determined
02:03:48 <dmwit> Monads *have* to be a partial type, with exactly one type parameter remaining to be specified.
02:04:34 <dmwit> The "type" of a type constructor is called its kind, as quicksilver said.
02:05:03 <dmwit> ?kind Int
02:05:08 <lambdabot> *
02:05:12 <dmwit> ?kind Maybe
02:05:14 <lambdabot> * -> *
02:05:16 <petekaz> I missed that point while reading the article.
02:05:29 <dmwit> ?kind Either
02:05:31 <lambdabot> * -> * -> *
02:05:35 <petekaz> Now that I look at the other instances he defined, they all follow the same pattern.
02:05:59 <quicksilver> petekaz: for a given type class, the kind is always fixed
02:06:08 <quicksilver> petekaz: so Monads always have kind * -> *
02:06:16 <quicksilver> because they're all parameterised by a type
02:06:25 <quicksilver> Nums always have kind *
02:06:32 <quicksilver> Nums are just types, they're not parameterised
02:06:42 <quicksilver> MonadErrors, of course, are just a particular kind of Monad
02:06:45 <quicksilver> so you'd expect the same kind
02:07:14 <petekaz> I understand now.
02:08:06 <mdmkolbe-work> Someone posted a link to a paper here last night.  But I can't remember the title.  Is there anyway to find it again? (A very vague question I know.)
02:08:14 <dmwit> ?where logs
02:08:14 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
02:08:22 <quicksilver> if you tell me the context, I can scroll back and look for you
02:08:27 <quicksilver> and roughly how long ago it was :)
02:08:36 <petekaz> I missed the subtlety when looking at the other instances, so I thought there was something odd about this one, but now that you point it out, it seems to make more sense.
02:08:42 <ville> Any particular book considered to be the ideal introductory text? What is considered to be the common level of usefulness of various www-resources? Again for another language I am familiar with, most of the wwww-stuff is usually just plain wrong.
02:09:07 <dmwit> ville: I think YAHT is usually considered to be pretty good.
02:09:12 <dmwit> ?go yaht wikibook
02:09:13 <sjanssen> ville: I've heard good things about the new book by Hutton
02:09:15 <lambdabot> http://en.wikibooks.org/wiki/Haskell/YAHT
02:09:15 <lambdabot> Title: Haskell/YAHT - Wikibooks, collection of open-content textbooks
02:09:57 <mdmkolbe-work> found it from the logs, thx dmwit
02:11:19 <quicksilver> ville: the wikibook is incomplete, but pretty good for the parts that are there
02:11:26 <quicksilver> ville: I haven't seen hutton's book but I'm sure it's good
02:11:41 <ville> sjanssen: any idea on the huton's book tittle?
02:11:50 <ville> err hutton's
02:11:59 <dmwit> ville: What other language(s) do you know?
02:12:09 <ville> ah "programming in haskell"
02:13:20 <sjanssen> ville: there's a review of it in the upcoming issue of The Monad.Reader
02:14:11 <ville> dmwit: As far as done for a living: C++, Java and Perl.
02:16:17 <ville> dmwit: So Haskell is a paradigm jump for me.
02:16:23 <dmwit> ville: Yeah.
02:16:37 <dmwit> There's a tutorial called Haskell for C programmers, but I honestly got very little out of it.
02:16:42 <quicksilver> bah, issue of HWN
02:16:49 <quicksilver> no work will be done this morning :(
02:17:51 <osfameron> ville: I'm liking SChool of Expression, and didn't like YAHT (the writing, though the exercises on the other hand are very good)
02:18:57 <ville> Ok have to review YAHT and see if it's enough to get me started.
02:20:27 <LeCamarade> ville: YAHT is good. Very. Just don't try to grok everything. You'll only get angry. Haskell is definitely weird for a Perl guy.
02:21:36 <ville> LeCamarade: Oh I am not a Perl guy by any measure. C++, but I believe the sentence still applies with a substitution.
02:21:51 <DRMacIver> I liked "A gentle introduction", but that's coming from an ML background.
02:22:03 <DRMacIver> Or rather I'm coming from an ML background, so the fact that I liked it may not be useful. :)
02:23:01 <osfameron> I got angry/amused with the YAHT line "The immediate question which arises is: okay, so how do I get rid of the IO." which I think is one of the least coherent introductions to monads I've seen
02:23:50 <osfameron> ville: you a perl hacker too?  I think shlomi fish has some slides on Haskell for Perl programmers, though it's mainly just code snippets
02:24:41 <LeCamarade> ville: Still ... getting used to a language where no changes in state are allowed can be such a leap.
02:24:49 <ville> osfameron: I tried to imply I wasn't a Perl programmer, just something I did for a living long time ago
02:25:17 <osfameron> ok
02:25:23 <ville> As in 10 years ago.
02:25:29 <LeCamarade> DRMacIver: The `Gentle' in there is for ML people. Not for normal people. :oD
02:26:28 <dmwit> There's nothing wrong with the Gentle Intro.
02:26:28 <osfameron> yeah, the "Gentle" made me incandescent with frothy rage
02:26:52 <dmwit> Hey!
02:26:55 <dmwit> I liked it a lot!
02:27:06 <osfameron> I'm sure it's very lovely
02:27:07 <dmwit> And I just came from a C/C++ background, so it is totally doable.
02:27:18 <osfameron> but "gentle" implies something it isn't
02:27:23 <dmwit> o
02:27:24 <dmwit> well, yeah
02:27:31 <DRMacIver> LeCamarade: Heh
02:27:31 <osfameron> gentle is cartoon foxes and lots of simple exercises
02:27:32 <mvanier> For IO in Haskell, I really like the "IO Inside" tutorial at http://haskell.org/haskellwiki/IO_inside.
02:27:34 <lambdabot> Title: IO inside - HaskellWiki
02:27:42 <osfameron> well actually cartoon foxes are annoying and induce stabby hate too
02:27:48 <sjanssen> Gentle Intro seems to be a love it or hate it affair (I learned from it and liked it)
02:27:48 <DRMacIver> LeCamarade: Well I've never claimed normality.
02:27:53 <kuribas> dmwit: The Gentle Intro's section on Monad didn't feel like an introduction at all.
02:27:59 <dmwit> Honestly, once I started with the Gentle Intro, I was afraid to look at anything that *wasn't* labelled Gentle. =)
02:28:07 <LeCamarade> dmwit: Gentle conjures up pictures of a tutorial with talking foxes. But that stuff? :oD
02:28:27 <dmwit> ?sp labelled
02:28:27 <lambdabot> Maybe you meant: spell spell-all . ask bf ft id map msg pl rc slap src v wn
02:28:29 <DRMacIver> Talking foxes conjure up an image if annoyingly condescending rubyists. ;)
02:28:31 <sjanssen> 'Gentle' is probably the greatest single lie in a title, ever
02:28:34 <dmwit> ?spell labelled
02:28:41 <DRMacIver> s/if/of/
02:28:52 <osfameron> DRMacIver: that's the bunny.  Or the fox.
02:28:53 <mvanier> It's "gentle" in the same way that Ex-Lax is gentle.
02:29:07 <DRMacIver> osfameron: I loathed the poignant wossname.
02:29:09 <LeCamarade> DRMacIver: From ML, Haskell seems normal. Maybe it was the next step from the ML side (via Miranda). Miranda is a trademark of Research Software.
02:29:44 <osfameron> DRMacIver: yeah, I got about 6 pages in and thought "Full marks for self indulgent wank, where's the Ruby?"
02:29:46 <quicksilver> From ML, haskell seems like a nice serious of minor improvements, plus a couple of interesting changes (purity and laziness)
02:29:47 <osfameron> I tried to read it 3 times
02:30:00 * DRMacIver doesn't have any strong opinions on Ruby, but really dislikes a lot of Rubyists. :)
02:30:23 <DRMacIver> quicksilver: I don't know. The laziness switch is a bit of a headfuck, because there's no strong correspondence between good ML programs and good Haskell programs.
02:30:46 <osfameron> DRMacIver: see http://hacketyhack.net/ though, also by Why, but seems to be more useful and maybe less annoying, even though it still has foxes
02:30:48 <lambdabot> Title: Hackety Hack: the Coder's Starter Kit
02:31:09 <DRMacIver> quicksilver: I wouldn't say Haskell seems normal coming from ML. It's enough of a context switch that it seems odd. It just doesn't seem completely arcane and out there, which it probably does if you're coming from C. :)
02:31:38 <DRMacIver> osfameron: No, sorry. The front page makes me want to punch the author in the face.
02:31:44 <quicksilver> DRMacIver: fair enough. It seemed pretty normal to me.
02:31:50 * LeCamarade hated ML for its having a kind of curry-phobia in the standard conventional usage.
02:32:03 <DRMacIver> quicksilver: Maybe I didn't do enough ML then. :) I'm a bit out of practice.
02:32:17 * DRMacIver came to Haskell from ML via a year of doing mostly Java.
02:32:53 <DRMacIver> (Although it was a year of doing mostly Java and saying "Argh, I wish this had (feature from ML)."
02:32:57 <DRMacIver> )
02:33:03 <merus> Java gives carpal tunnel
02:33:12 <merus> *Java gives me carpal tunnel
02:33:21 <LeCamarade> DRMacIver: That must hurt. I am _still_ doing Java. But I am planning a coup d'état over here.
02:33:30 <osfameron> DRMacIver: fair enough :-)
02:34:05 <LeCamarade> Actually, now I am doing C#, which is Capitalist Java.
02:34:23 <LeCamarade> But, the real reason I'm sticking with C# is F#.
02:34:36 <LeCamarade> @go F# site:en.wikipedia.org
02:34:38 <lambdabot> http://en.wikipedia.org/wiki/F_Sharp_programming_language
02:34:38 <lambdabot> Title: F Sharp programming language - Wikipedia, the free encyclopedia
02:34:42 <DRMacIver> LeCamarade: Well C# has enough functional features (in particular anonymous methods / delegates) that it's a little less painful than Java. :)
02:34:58 <DRMacIver> But I have no chance of pulling a coup, so I'm leaving instead.
02:35:05 <DRMacIver> Although I may well still end up doing Java. :)
02:35:06 <Sir_Boegel> Have you guys seen the post on haskell-cafe concerning installing GHC on FC6? (the guy looking for an mp3 app)
02:35:19 <LeCamarade> That way, I can write things in good ol' Ocaml, and port to F#, and never have the aches of public static void main.
02:37:04 <DRMacIver> LeCamarade: Well, Java has Scala, which is in many ways a better match.
02:37:29 <DRMacIver> It's not at all ML like, but it has strong functional support and a lot of cool features. :)
02:37:40 <DRMacIver> (I guess .NET has Scala too, but it lags behind)
02:38:36 <LeCamarade> Nope. I want to write an ML syntax. There was Jaskell, which I still hope for, but until then, I get to do F#. I dunno if it is MS strategy. :oD
02:38:42 <LeCamarade> @go jaskell
02:38:43 <mvanier> Sir_Boegel: Yeah, I just saw that.  That happened to me once.  Seems like an overreaction.
02:38:45 <lambdabot> http://jaskell.codehaus.org/
02:38:45 <lambdabot> Title: Jaskell - Home
02:39:19 <DRMacIver> Being tied to a particular syntax seems... odd, to me.
02:39:37 <DRMacIver> Particularly OCaml syntax. It's about the worst instance of the ML family of syntaxes. :)
02:40:45 <osfameron> syntax familiarity is very tempting though
02:40:47 <LeCamarade> I do like twenty languages. It's just that I have made my choice (Haskell), and I want to stick to that while I prepare to launch out. I may have to need guru powers with ML-family langauges. I hate Ocaml - the worst ML-kid, but what can I do? ;oD
02:41:22 <osfameron> can you expand on the ocaml-hate?  (in #-blah if more appropriate), I'd heard really positive things about ocaml so I'm curious.
02:41:48 * DRMacIver has no OCaml-hate.
02:41:50 <DRMacIver> I just don't like the syntax.
02:42:02 <LeCamarade> I just don't like the way Ocaml tends to treat functional style like a burden. Also, aja, some guy who hangs out here sometimes, is doing Haskell for .NET. That will rock.
02:42:16 <DRMacIver> I also don't like the "OMGzors. It's so fast!" given that SML has had better optimising compilers for years. :)
02:42:22 <mvanier> Ocaml is fine if you can stomach the syntax.
02:42:28 <ejt> I always had good experiences with ocaml, though I always stuck with a functional subset that's probably just SML
02:42:35 <Sir_Boegel> mvanier: yeah... lazy bastard :P
02:42:45 <ejt> the double ;;'s are odd
02:42:46 <osfameron> I suppose I don't know other MLs so can't see what the particularities of Ocaml are ;-)
02:42:49 <Sir_Boegel> mvanier: but to be honest, I tend to be like that too sometimes...
02:43:04 <mwc> @quote inverselimit
02:43:04 <lambdabot> inverselimit says: So I tried as my first project in haskell to write something that decomposes modules of polynomials using Schur-Weyl duality.  This turned out to be a little tricky without being
02:43:05 <lambdabot> comfortable with the syntax
02:43:10 <mwc> holy crap
02:43:26 <mwc> inverselimit owes me a new pair of shorts
02:43:41 <mvanier> Sir_Boegel: I don't know why he didn't just install an RPM.
02:43:52 <mwc> it's GHC building time again?
02:44:26 <Sir_Boegel> mvanier: yeah, exactly...
02:44:28 <mwc> That magical time when we all usher in the spring by the gratuitous dumping of a coupla terajoules worth of heat into the atmosphere by thousands of cooking CPUs the world over?
02:44:51 <mvanier> I just installed ghc 6.6.1.  It took up almost a gigabyte and took forever.
02:44:52 <osfameron> that bad?
02:45:08 <mwc> mvanier, took up a gig of what/
02:45:19 <mvanier> Memory to compile from source.
02:45:20 <DRMacIver> GHC does seem to take rather a lot of work to build. :)
02:45:36 <osfameron> I like the "you need ghc to build ghc" thing too ;-)
02:45:40 <mwc> Hmm, I have 1.5 GB of ram in this baby but it's hardly pushing at all
02:45:44 <mvanier> Of course, I also compiled all the extralibs.  It wasn't a hard compile though; nothing to it.
02:45:47 <ville> I am building 6.4.2 and it is bringing this core 2 duo to total halt at points.
02:45:51 <mwc> must be because I'm on PPC and so stuck compiling through C
02:46:09 <quicksilver> osfameron: then again you need a C compiler to compile gcc
02:46:14 <quicksilver> osfameron: this is not a new problem :)
02:46:16 <mwc> osfameron, lol, you should have seen my fun packaging GHC 6.6 for linux/ppc
02:46:23 <DRMacIver> mvanier: Well, I mean a lot of work by the computer, not by the user. :)
02:46:30 <mwc> I got it done a week before they released 6.6.1. Bastards
02:46:32 <mvanier> As it should be.
02:47:24 <mvanier> I tried to build ghc from C once; couldn't do it.  I got the generic binary instead.
02:47:29 <quicksilver> as I recall, ghc-6.4 took me 8 hours to compile on a 800Mhz G4
02:47:36 <quicksilver> binary packages ftw...
02:47:40 <LeCamarade> osfameron: That `GHC to build GHC´ thing is quite natural. Recursive, you know.
02:47:47 <mwc> quicksilver, yep, 6.6 is a little faster... on a 1.5 Ghz G4
02:48:03 <mwc> but on a laptop, compiling sucks anyways. All those small little files
02:48:04 <mvanier> ocaml bootstraps better than ghc though.  You don't need ocaml to build ocaml.
02:48:07 <DRMacIver> LeCamarade: Yeah. Besides - how else would you build undetectable backdoors into the compiler? :)
02:48:48 <quicksilver> mwc: especially apple laptops. Great little machines, bloody slow disk access.
02:49:19 <mwc> mvanier, theoretically, GHC ships with C files that have been 'compiled' so you can use --hc-boot and make it that way
02:49:20 <merus> Here here.
02:49:23 <mwc> didn't work last I checked
02:49:31 <mvanier> didn't work for me either
02:49:39 <osfameron> quicksilver, LeCamarade, mwc: yeah, I'm not really a language designer, I'm sort of aware of the bootstrapping program, but it amuses and/or terrifies me depending on my mood.
02:49:59 <mwc> quicksilver, yeah, I replaced my 80 GB Toshiba (8 MB Cache) with a better model from the same line, 100 GB, 16 MB cache
02:50:00 <osfameron> perl also requires perl to build I think, though it gets around that by first building miniperl
02:50:04 <mwc> the extra cache was really noticible
02:50:17 <quicksilver> osfameron: which is ironic, because perl isn't written in perl :)
02:50:25 <quicksilver> osfameron: but some of the compilation support scripts are...
02:50:37 <osfameron> quicksilver: true!  though a lot of perl6 will be
02:50:38 <quicksilver> mwc: interesting
02:50:53 <merus> I was always kind of confused by the statement that only perl can parse perl, since most source filters in perl are terrible
02:51:01 <quicksilver> osfameron: perl6 has been cancelled. Let's just fork haskell instead.
02:51:05 <mwc> Bootstrapping is the bar-mitzfah for programming languages
02:51:27 <quicksilver> merus: the correct statement is "only perl can parse Perl". capitalization important on that one.
02:51:28 <Wild_Cat> perl 6? Cancelled? How so?
02:51:40 <quicksilver> Wild_Cat: I'm joking
02:51:47 <osfameron> quicksilver: that *does* seem tempting... perl6 leads me alternately to exaltation or deep depression
02:52:03 <LeCamarade> osfameron: YHC is miniperl with Monads. I think. I'm still too scared of doing GHC from source. Especially since apt-get install ghc --yes --force-yes still works ... :oD
02:52:15 <Wild_Cat> hey, you never know -- I mean, last news I had from Perl6 are from over 2 years ago.
02:52:27 <merus> quicksilver, ah, that makes more sense
02:52:27 <osfameron> yeah, apt-get is a thing of great loveliness
02:54:05 <LeCamarade> Wild_Cat: Get pugs. I have it here. G . R . E . A . T. And written in Haskell. :oD
02:55:17 <Wild_Cat> yeah, I heard about it. Not that it really concerns me as I'm not a big Perl fan. What I was more or less expecting from Perl 6 was Parrot.
02:55:49 <Wild_Cat> in theory, it'd have been awesome. Python/Ruby + CPAN = Win.
02:56:17 <LeCamarade> Wild_Cat: I am going to be a Perl fan. They are considering lots of Haskellish stuff. And junctions. But, again, I dunno. I script in Haskell, these days.
02:56:39 <LeCamarade> And coroutines.
02:56:55 <Wild_Cat> Haskell scripting? Interesting. Tell me more. I'd have thought a functional language wouldn't really be suited to such an eminently side-effected task.
02:57:12 <quicksilver> Wild_Cat: you should check out CosmicRay's HSH then
02:57:29 <LeCamarade> People just can't comprehend it when I script _better, safer_ in Haskell. Just add #! /usr/bin/runghc at the top. And go ahead with code.
02:57:40 <Wild_Cat> me, I'm more a Python guy getting more and more interested in FP in general, and Haskell in particular.
02:57:53 <quicksilver> Wild_Cat: http://software.complete.org/hsh
02:57:57 <lambdabot> Title: HSH
02:58:07 <quicksilver> (not that that is the only approach to scripting in haskell, nor even the best in all circumstances)
02:58:11 <quicksilver> (but it's damn clever)
02:58:16 <LeCamarade> Haskell scripts better than Python. Especially for the get-off-my-knuckles scripts.
02:58:21 <quicksilver> @karma+ CosmicRay
02:58:21 <lambdabot> CosmicRay's karma raised to 7.
02:58:32 <Wild_Cat> quicksilver: ooh, looks fun.
02:58:42 <Wild_Cat> LeCamarade: care to show a few examples?
02:59:28 <Wild_Cat> admittedly, Python doesn't really fulfill my quick&dirty scripting needs. You can't really do sub-10-liners in it.
03:02:50 <DRMacIver> Dammit, why do people keep offering me jobs? Choices are hard.
03:03:20 <LeCamarade> Wild_Cat: Haskell is not better at it that Perl, but ahead of Python.
03:03:30 * LeCamarade goes browsing for a quick one ...
03:03:52 <Wild_Cat> LeCamarade: yeah, I don't expect anything to beat Perl in that area. I mean, it's the whole point of the language.
03:04:07 <quicksilver> I think haskell can be better than perl, actually, with sufficient initial investment
03:04:21 <quicksilver> by which I mean, you need to build up a bit of a library of tricks and import them into your scripts
03:04:33 <quicksilver> but I think once you had it all set up nicely, it would be easier
03:04:40 <quicksilver> because it's so much better at abstracting common patterns
03:04:44 <Wild_Cat> you haven't lived (and you don't know fear) until you've seen a one-liner that OCRs itself to read 90-degree rotated Mayan numerals and uses that information to display "Hello World".
03:05:35 <LeCamarade> quicksilver: Exactly. You nailed it. You know, even Perl is just C with over-fat libraries. But Haskell, sans frills, is still better at it that Python.
03:05:52 <osfameron> quicksilver: the haskell *language* may be better than perl for that, but perl still has an advantage for the libraries, which is a massive part of working with common patterns too
03:06:01 <LeCamarade> For example, here is ls in Haskell ... (on the fly)
03:06:05 <quicksilver> osfameron: oh, absolutely agreed
03:06:45 <osfameron> I suppose that's what you mean by "initial investment"
03:07:11 <quicksilver> osfameron: right
03:07:55 <osfameron> all we need is for perl6/parrot to actually get written, port haskell to parrot, then Profit!
03:08:50 <mdmkolbe-work> what is runghc?  How is it different from ghc or ghci?
03:09:24 <ivanm> I presume runghc is something like bash or perl, enabling you to create haskell scripts
03:09:26 <ejt> mdmkolbe-work: runghc runs the given program as a script,
03:09:42 <ivanm> e.g. put #!/usr/bin/runghc at the top of your haskell file
03:09:43 <ejt> mdmkolbe-work: ghc compiles a program, ghci is an interactive shell
03:10:45 <mdmkolbe-work> doesn't ghci have a flag that says "run this file and don't prompt"?
03:11:12 <LeCamarade> mdmkolbe-work: GHC compiles to executable, GHCi does what runghc does, but won't terminate after running the program. runghc terminates. Essentially interprets Haskell.
03:11:13 <ivanm> ghci -e does running a command...
03:11:17 * mdmkolbe-work is scurrying around the docs to try to find such a flag
03:11:35 <LeCamarade> @quote flags
03:11:36 <lambdabot> shapr says: GHC has more flags than the UN
03:11:55 <LeCamarade> mdmkolbe-work: shapr says: GHC has more flags than the UN
03:12:57 <ivanm> heh
03:13:03 <mdmkolbe-work> thx, LeCamarade.  the non-termination of ghci explains it
03:14:37 * ulfdoz rofls about "Poor first impression" on haskell-cafe ML.
03:15:18 * LeCamarade has failed to copy his ls to here. Merde as the French say.
03:15:33 <LeCamarade> Evils of working in terminals only. :o(
03:15:45 <mdmkolbe-work> so for the people writing haskell scripts, do you ever miss the DWIM'ery that Perl provides with the non-typed stuff or is there some trick to getting that in haksell?  (I love Haskell, but few things can beet 'perl -ane "print $F[2] if $F[1] > 12")
03:16:49 <LeCamarade> mdmkolbe-work: You get to hate stuff that hasn't passed a Haskell type checker. But, still, if it's a one-off you want ...
03:16:56 * ivanm has no idea what DWIM is, doesn't write scripts often and when he does they're in bash
03:17:07 <quicksilver> mdmkolbe-work: that's actually very well typed, isn't it?
03:17:17 <quicksilver> mdmkolbe-work: @F is always an array of strings
03:17:22 <quicksilver> mdmkolbe-work: ah, the string-num bit
03:17:23 * quicksilver shrugs
03:17:31 * LeCamarade hates Do-What-I-Mean, because he is aware he often means the wrong thing. Haskell seems wiser.
03:17:38 <quicksilver> (read F) :: Int > 12
03:17:41 <quicksilver> is not that hard
03:18:01 <LeCamarade> ivanm: It is Perl philosophy: Do What I Mean (not necessarily what I say).
03:18:02 <quicksilver> :t \f -> read f > 12
03:18:05 <lambdabot> String -> Bool
03:18:15 <ivanm> *nod*
03:18:36 <ivanm> heh.... you want intelligent compilers/interpreters, do you?
03:18:58 <ejt> but type errors generally suggest I don't know what I mean, much better than doing the wrong thing
03:19:04 <mdmkolbe-work> ivanm: another example of DWIM is when you dereverence out of bounds in a list, the list will get a default value
03:19:05 <osfameron> ivanm: DWIM is "Do what I mean"
03:19:13 <osfameron> oops, sorry
03:19:22 <osfameron> didn't realise I was still in scrollback :-(
03:19:26 <ivanm> heh
03:19:43 <ivanm> mdmkolbe-work: you mean dereference, rather than dereverence?
03:19:53 <ivanm> sounds a bit like using maybe...
03:20:07 <mdmkolbe-work> ivanm: I actually meant reference
03:20:57 <quicksilver> mdmkolbe-work: that's not DWIM
03:21:07 <quicksilver> mdmkolbe-work: that's do something dangerous and stupid :)
03:21:17 <quicksilver> mdmkolbe-work: but I understand your point
03:21:43 <osfameron> quicksilver: $people{bob}{names}[0] = "Bob";  # does the right thing, in that it creates all the relevant stuff in the tree automatically
03:22:01 <osfameron> which is maybe similar to mdmkolbe-work's point (or am I barking?)
03:22:13 <quicksilver> osfameron: no, you're right, and I'm aware of this too :)
03:22:20 <quicksilver> osfameron: my day job is as a perl programmer
03:22:28 <ulfdoz> DWIM has imho the problem, that you sometimes need to know all its exceptions and assumptions.
03:22:58 <osfameron> quicksilver: ah!  I think I knew that... once, sorry
03:23:24 <osfameron> yeah, I get caught out stupidly often with the "DWIM" of scalar and list context.  Right now, I'd be delighted if that would just go away...
03:23:25 <mdmkolbe-work> ulfdoz: it does, but it also becomes a shorthand.  Perl has as many exceptions as English, but that is also what makes it so expressive.
03:23:56 <quicksilver> osfameron: but the equivalent expression in haskell would do the right thing too
03:24:12 <quicksilver> osfameron: it would infer that that type was Map (String,String,Int) String
03:24:22 <quicksilver> osfameron: and create the relevant node :)
03:24:42 <quicksilver> @type Data.Map.insert ("bob","names",0) "Bob"
03:24:45 <lambdabot> forall t. (Num t, Ord ([Char], [Char], t)) => M.Map ([Char], [Char], t) [Char] -> M.Map ([Char], [Char], t) [Char]
03:24:45 <osfameron> quicksilver: yeah!  I guess type inference is very DWIM too  then
03:24:48 <ulfdoz> mdmkolbe-work: For me, is "do what I say" easier to understand. I'm not really good in remembering a lot of rules. Of course you can get a feeling for a lot of things, but that usually takes longer to develop the expertise.
03:24:54 <LeCamarade> mdmkolbe-work: To write a script that pings a server and parses some file, Perl can't be replaced. But if it is elaborate and shouldn't fail, like Debian
03:25:06 <LeCamarade> 's apt stuff, Haskell can make a good replacement.
03:25:34 <quicksilver> osfameron: or I might encode it as Map String (Map String (Map Int String) ) I suppose
03:25:47 <quicksilver> osfameron: which is a more direct translation of the perl. but either way.
03:26:38 <osfameron> quicksilver: fair enough.  And I'm beginning to see the benefits of just sticking to a defined structure rather than being able to mess with enormous amorphous hashes and then shoot yourself in the foot like you can with Perl...
03:28:38 <quicksilver> osfameron: other languages allow you to shoot yourself in the foot. Perl makes sure that, if that's what you want, it takes of the whole bleedin' leg.
03:31:00 <osfameron> heh, though (off topic so I'll now shut up) Perl has enough flexibility to give you bondage and discipline if you want it (Data::Validate, functional extension, by contract design etc)
03:35:20 <quicksilver> osfameron: the nice thing, IMO, about haskell, is that the syntactic weight of the discipline is very low
03:35:31 <quicksilver> osfameron: you can do with no type annotations at all, and let it infer them
03:35:43 <quicksilver> osfameron: or you can have just a few annotations on your important types
03:35:55 <mdmkolbe-work> A lot of Perl's DWIM is appeasing the the type checker (a lot is more than that), but I wonder if someone could write a front end that would insert the code into haskell to do that for you?
03:35:58 <osfameron> yeah, I loved the Dominus article on type checking in an ML (I forget which), it looked really cute.
03:36:02 <quicksilver> osfameron: the syntactic weight of the perl typing modules on CPAN I've looked at is high, compared to that
03:36:19 <osfameron> quicksilver: oh, haskell typing is a thing of beauty, don't get me wrong
03:36:29 <osfameron> typing + really clever destructuring bind
03:36:55 <mdmkolbe-work> Did LeCamarade ever post his oneline Haskell ls?
03:37:11 <quicksilver> mdmkolbe-work: now, he quit, swearing at his terminal program which wouldn't let him copy/paste
03:38:17 <raxas> quicksilver: speaking about the bleeding, while other languages allow you to shoot yourself in the foot, haskell causes you to shoot yourself in the head soon
03:38:43 <merus> hehe.
03:40:03 <mdmkolbe-work> raxas: maybe, but Haskell is the only language that when I have an argument with the compiler, the computer usually turns out to be right
03:40:46 <LeCamarade> mdmkolbe-work: Put right. Where is that quote about the guy who says he likes languages that tell him he is thinking wrong?
03:41:15 <quicksilver> the quote was by eric kidd
03:41:18 <quicksilver> hmmm...
03:41:23 <quicksilver> @quote emk
03:41:24 <lambdabot> No quotes match. Where did you learn to type?
03:41:28 <quicksilver> @quote kidd
03:41:29 <lambdabot> sjanssen says: "shapr: Erik Kidd == emu? don't quote me on that"
03:41:33 <quicksilver> @quote kidd
03:41:33 <lambdabot> sjanssen says: "shapr: Erik Kidd == emu? don't quote me on that"
03:41:52 <osfameron> @quote emu
03:41:52 <lambdabot> emu says: what would be the ingredients in a Haskell curry?
03:42:23 <quicksilver> or, I thought it was
03:42:29 <hpaste>  eumenides pasted "error with IOArray -> IArray" at http://hpaste.org/1594
03:42:32 <quicksilver> but I can't find it with google
03:42:56 <eumenides> can anyone who's worked with arrays check what i'm doing wrong? ^
03:44:29 <quicksilver> :t freeze
03:44:31 <lambdabot> Not in scope: `freeze'
03:45:07 <eumenides> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-MArray.html#v%3Afreeze
03:45:10 <lambdabot> http://tinyurl.com/y2qz4l
03:46:19 <quicksilver> eumenides: not specifying the monad, perhaps?
03:46:41 <quicksilver> eumenides: does this work : (freeze maze) :: IO (IArray (Int,Int) Char)
03:48:27 <eumenides> ah, that's odd. seems i should've loaded Data.Array.IArray instead of Data.Array
03:49:01 <eumenides> quicksilver: works, but it's Array not IArray :)
03:49:24 <quicksilver> eumenides: right, my mistake
03:49:30 <quicksilver> eumenides: anyhoe, the reason is this:
03:49:39 <quicksilver> eumenides: although you know that IOArray is associated with the IO monad
03:49:51 <quicksilver> eumenides: so the only monad it makes sense to apply freeze in, is the IO monad
03:49:56 <quicksilver> eumenides: the type checker can't see that anywhere
03:50:06 <quicksilver> eumenides: IO isn't mentioned in any of the types it is unifying
03:50:21 <quicksilver> eumenides: so you need to, effectively, tell which which instance of freeze you want (even though there is only one)
04:11:19 <Itkovian> is there an xmlrpc lib available for haskell?
04:12:20 <Lemmih> Yes.
04:15:01 <Itkovian> Lemmih: thanks :-)
04:15:44 <Lemmih> ?where+ haxr http://www.haskell.org/haxr/
04:15:44 <lambdabot> Done.
04:16:28 <DRMacIver> Not to be a google pedant, but the "Haskell XMLRPC" in google turns up one or two useful results. :)
04:18:40 <araujo> @where
04:18:41 <lambdabot>  @where <key>, return element associated with key
04:19:06 <araujo> mm.. argh, i always forget, how to add elements to the 'where' database?
04:19:23 <araujo> morning :-)
04:19:55 <int-e> where+
04:20:12 <quicksilver> @where+
04:20:13 <lambdabot>  @where <key>, return element associated with key
04:21:23 <araujo> Thanks!
04:26:46 <nohope> Good morning all!
04:28:17 <quicksilver> Has it ever been proposed to add ghci's auto-import of fully qualified identifiers into the language proper?
04:32:51 <nohope> Well, I have a simple question about ghc internals... is platform specific code separated from generic code?
04:35:42 <quicksilver> I would be very surprised if it wasn't
04:36:21 <Lemmih> Define 'separated'.
04:38:04 <nohope> Lemmih: win32 code in a directory, unix code in another directory and generic (that can be used for all platforms, normally ANSI-C) in another directory. Well, they don't need to be in diferent directories but maybe in diferent files.
04:40:54 <dylan> Or there could be a bunch of ifdefs.
04:42:22 <nohope> dylan: yeah, can be :) I just would like how Haskell handles that.
04:42:47 <matthew_-> @seen ndm
04:42:48 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 20h 46m 15s ago, and .
04:42:57 <Lemmih> nohope: GHC uses CPP and TARGET_HOST.
04:43:27 <nohope> Lemmih: hm. I'm going to take a look at those resources :) thx.
04:47:37 <gimboland> Can someone help me with a cabal problem?  I'm trying to configure xmonad, and when I run "runghc Setup configure" I get: Setup.lhs:1:8:
04:47:37 <gimboland>     Could not find module `Distribution.Simple':
04:47:37 <gimboland>       Use -v to see a list of the files searched for.
04:47:55 <gimboland> i have downloaded latest cabal from darcs and installed as per instructions
04:48:09 <gimboland> i did have this working a couple of days ago, although i recall hitting this problem once then
04:48:33 <gimboland> this morning, i deleted the build tree for cabal from my home dir, thinking i wouldn't need it any more, and then this started happening...
04:49:17 <gimboland> [gimbo@orb ghc-6.6] ls -ld /usr/local/lib/Cabal-1.1.7/ghc-6.6/Distribution/Simple*
04:49:17 <gimboland> drwxr-xr-x  2 root  wheel    512 20 Apr 15:09 /usr/local/lib/Cabal-1.1.7/ghc-6.6/Distribution/Simple
04:49:17 <gimboland> -rwxr-xr-x  1 root  wheel  30049 27 Apr 12:42 /usr/local/lib/Cabal-1.1.7/ghc-6.6/Distribution/Simple.hi
04:53:42 <petekaz> is Either a monad?
04:54:14 <matthew_-> petekaz: yep
04:54:21 <doserj> not really
04:54:29 <doserj> "Either e" is
04:54:36 <dblhelix> petekaz: Either a is for all a.
04:54:49 <petekaz> I can't seem to find the source code tha shows where >>= and such are defined for it.
04:55:22 <dblhelix> Control.Monad.Error, I think...
04:55:39 <quicksilver> yup, Control.Monad.Error
04:55:41 <dblhelix> return = Right
04:55:43 <petekaz> ok ... thanks.
04:55:58 <dblhelix> Left x >>= f = Left x
04:56:04 <dblhelix> Right x >>= f = f x
04:56:06 <quicksilver> It's exactly like Maybe, except that the 'Nothing' (i.e. Left) can carry around a bit of information
04:56:08 <petekaz> what is fail?
04:56:16 <quicksilver> about what went wrong, presumably
04:56:17 * dblhelix hopes that's right... :-)
04:56:50 <quicksilver> fail is the spanner in the works
04:56:56 <quicksilver> since fail is fixed to take a string argument
04:57:12 <ndm> @src fail
04:57:13 <lambdabot> fail s      = error s
04:57:14 <hpaste>  petekaz pasted "can I rewrite the above like so?" at http://hpaste.org/1595
04:57:15 <quicksilver> we have to define a clumsy Error class, and let Errors be coerced from strings
04:57:33 <ndm> but thats not actually true
04:57:44 <ndm> that fail = error, its overloadable
04:57:55 <quicksilver> so the monad instance isn't actually for Either a, in general
04:58:01 <quicksilver> it's only for Error a => Either a
04:58:13 <quicksilver> and that's all because fail takes strings
04:59:12 <petekaz> I'm reading dons post on shell scripting, going through it slowly because I am trying to learn.  So one question I had when reading it, his motivation for using ErrorT stuff (which I have not fully comprehended yet) is to remove the boilerplate code from the first modify fn.  But to me, I would have thought one could just do something like one does with Maybe, just sequence them togethre to remove the boiler plate.
05:01:19 <petekaz> The code is incorrect, but does the question make sense?
05:02:10 <quicksilver> your intuition is correct
05:02:21 <hpaste>  petekaz annotated "can I rewrite the above like so?" with "Using Maybe example" at http://hpaste.org/1595#a1
05:02:31 <quicksilver> that's exactly the kind of plumbing that can be rewritten with a monad
05:02:42 <petekaz> Ok.
05:03:01 <quicksilver> the reason dons has to use ErrorT
05:03:08 <quicksilver> and not just the monad instance for either
05:03:09 <petekaz> So the motivation for the ErrorT stuff he refers, is to just make ... (you read my mind)
05:03:13 <quicksilver> is that you were already in a monad
05:03:18 <quicksilver> (the state monad)
05:03:22 <quicksilver> that's where get and set come from
05:03:23 <matthew_-> ndm: with filepath, say I've hardcoded into some code some paths, as Strings, eg "foo/blah/blam". But it's then going to be compiled and used under Windows. I can't see a method in filepath that converts from one to the other. Am I blind or is this deliberate?
05:03:32 <quicksilver> so really this part of the explanation is about how you combine two monads
05:03:37 <quicksilver> (State and Either)
05:03:44 <quicksilver> so you can use the power of each/both
05:03:55 <petekaz> But, in that last annotation, I have Maybe monad inside of IO.
05:04:05 <petekaz> How is that different?
05:04:16 <quicksilver> because you've got it 'completely inside'
05:04:28 <quicksilver> that whole v1,v2,v3 bit has no IO in it
05:04:31 <quicksilver> that's fine
05:04:32 <ndm> matthew_-: perhaps normalise will do it
05:04:41 <quicksilver> you're just nested two kinds of expression inside each other
05:04:53 <quicksilver> the problem comes when you need 'a bit of maybe then a bit of IO then a bit of maybe'
05:05:11 <quicksilver> so your case was simpler
05:05:12 <ndm> matthew_-: yep, normalise replaces / with pathSeparator, i.e. moves to \ always
05:05:18 <petekaz> I see.
05:05:22 <ndm> matthew_-: plus windows accepts / as a path separator anyway
05:05:37 <quicksilver> petekaz: but in don's case, he's got "get, then an error check, then set, hten an error check"
05:05:43 <quicksilver> petekaz: so they're interleaved, not nested
05:06:42 <matthew_-> ndm: oh ok, I don't have windows, so I was testing the inverse: > normalise "\\foo\\bar" doesn't become /foo/bar under *nix
05:07:20 <ndm> matthew_-: no, there is no explicit conversion - but / as a separator under all, hence why that trick works moving to windows
05:07:23 <petekaz> quicksilver: so could he have written his own get/set that wrap the state monad and return Either values?
05:07:40 <ndm> matthew_-: perhaps "convertToWindows" "convertToPosix" are functions that are missing from the library
05:07:49 <matthew_-> ndm: ok fine, that's great. Thanks.
05:08:05 <matthew_-> ndm: well, if you can just use '/' everywhere then that'll do too!
05:08:32 <petekaz> quicksilver: nevermind, that's the same problem inverted right?
05:08:33 <ndm> matthew_-: or directly create them with "foo" </> "blah" - but using / literally is often easier
05:08:37 <quicksilver> petekaz: yes
05:08:43 <quicksilver> petekaz: you can combine them by hand, it's true
05:08:52 <quicksilver> petekaz: StateT and ErrorT just do it automaticaly, though
05:08:56 <petekaz> but its more work and this is more elegant.
05:09:07 <quicksilver> although all the "lift"s are annoyigng
05:09:11 <matthew_-> ndm: also, I think I asked this earlier and then my connection dropped, in ghc-6.6.1, is System.FilePath in the filepath package (i.e. do I need to mess around with cabal dependencies)?
05:09:50 <petekaz> quicksilver: thanks.  are there good tutorials/docs on the whole monad transformer thing?
05:10:00 <quicksilver> petekaz: cale's is good
05:10:14 <quicksilver> not particularly aimed at people who are still learning about monads, but it's good
05:10:28 <ndm> matthew_-: yes, require filepath in cabal, and it will all work
05:10:31 <petekaz> i didn't know he had a transformer doc, I've seen his monad as containers.
05:11:07 * gimboland reads about ghc-pkg, as he should have done sooner...
05:11:15 <petekaz> quicksilver: would you happen to have a link?
05:11:17 <matthew_-> thank you!
05:11:59 <kolmodin> I'm officially offended: http://www.scriptol.org/choose.php
05:12:01 <lambdabot> Title: Popular programming languages
05:12:57 <chris2> *gg*
05:13:09 * gimboland lol at the description of lisp
05:13:29 <gimboland> they've really captured the spirit of the thing there
05:13:33 <quicksilver> it used to be
05:13:34 <quicksilver> http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
05:13:38 <quicksilver> but I can't get through at the moment
05:13:42 <chris2> oh, i actually read "[better] try programming in another way"
05:13:48 <quicksilver> Cale: ping?
05:14:22 <petekaz> quicksilver: ok ... thanks.  I'll search around for a workable link.
05:14:38 <quicksilver> if nothing else, google or wayback should have a cache
05:15:57 <petekaz> right.  Thanks again for the help.  The Haskell community seems to have such a great tolerance for newbie questions.
05:16:07 <quicksilver> yes, I 'm not sure why they're so friendly here
05:16:16 <quicksilver> I think Simon-PJ puts something in the water
05:16:17 <Pseudonym> petekaz: You suX0Rz!!!!1!
05:16:27 <Pseudonym> I think it's all the hair shirts.
05:17:35 <petekaz> thanks again, off to work (day job).
05:18:01 <dcoutts_> @yarr!
05:18:02 <lambdabot> I'd like to drop me anchor in her lagoon
05:18:06 <kolmodin> @yarr!
05:18:07 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
05:18:31 <dcoutts_> ahh, back in the UK, nice and cold and cloudy :-)
05:18:52 <kolmodin> rain?
05:19:11 <kolmodin> welcome back!
05:19:18 <kolmodin> to my time zone! (almost)
05:19:58 <dcoutts_> no, no rain, just overcast and grey :-)
05:20:06 <kolmodin> :)
05:20:18 <dcoutts_> just what we expect from British weather
05:20:25 <dcoutts_> but it's spring, which is nice
05:20:35 <ivanm> dcoutts_: what, if its not raining its about to rain? *ducks*
05:20:50 <kolmodin> ivanm: something like that :)
05:20:52 <therp> oh 6.6.1 released? nice!
05:21:10 <kolmodin> yeah. dcoutts, wanna hack the ebuild? :)
05:21:14 <ivanm> kolmodin: heh
05:21:20 <dcoutts_> kolmodin, I guess we should
05:21:34 <dcoutts_> ivanm, no, it can go weeks of grey skies with no rain
05:21:41 <kolmodin> yeah. someone should... :) I'm going back to work. ttyl
05:21:57 <ivanm> dcoutts_: heh
05:31:05 <quicksilver> dcoutts_: you've actually missed a very sunny march + april
05:43:45 <dcoutts_> quicksilver, I did? Well, I'm sure it was sunnier in Sydney :-)
05:44:20 <ivanm> and sydney is a hole! *ducks*
05:44:38 <quicksilver> dcoutts_: I'm sure that's true too
06:26:55 <gimboland> in case anyone cares, i fixed my Cabal problem: at some point in the past, I must have installed it as user rather than root, which registered a version in my per-user package database, which pointed to code which was no longer there.  By removing that database entry, ghc can now see the right version of Cabal.  Woo for RTFM'ing.
06:34:59 <ptolomy> Hehe. in the 6.6.1 release notes "GHC can now be use to compile C++ files."    Wow! :-P
06:35:21 <vali> eew, C++
06:36:44 <Wild_Cat> does that mean GHC has become a C++ compiler, or just that it can generate C++ source from Haskell code?
06:36:45 <ptolomy> I've benefited financial from the evil of C++, and I feel a sense of guilt for that.
06:36:46 <obsethryl> ptolomy: wow
06:37:11 <obsethryl> ptolomy: any news on Qt support ? :D
06:37:22 <quicksilver> Wild_Cat: it just means it knows how to invoke g++, I think
06:37:38 <quicksilver> Wild_Cat: just as it has always known how to invoke gcc on C files, so you can make a mixed C/haskell program
06:37:47 <Wild_Cat> that sounds less impressive now ^^
06:37:53 <obsethryl> i mean are there any good haskell - qt stuff, or this is something put on hold due to licensing issues?
06:40:18 * ptolomy would give $200 to hasten the addition of reasonable records to haskell.
06:40:29 <ptolomy> unless it is already a ghc extension.
06:40:33 <osfameron> records?
06:41:44 <obsethryl> guys, any news from the qt/haskell front, is it still up to GSoC2007 ?
06:42:42 <ptolomy> if I find "-ftickle-me-pink for nice records with scoped labels" in the new GHC man page, I'll wet myself.
06:42:55 <nominolo> ptolomy: i guess, getting subtyping right is non-trivial
06:42:57 <petekaz> @seen Cale
06:42:58 <lambdabot> Cale is in #oasis, #ghc, #haskell-overflow and #haskell. I last heard Cale speak 11h 58s ago.
06:44:55 * ptolomy tries to figure out what in extralibs has changed for 6.6.1
06:45:46 <quicksilver> there have been some good proposals on how records might work
06:46:05 <quicksilver> but nothing in GHC implemented afaik
06:47:35 <ptolomy> Wow. The response in cafe to the fella who was saying "Goodbye Haskell .. not ready for primetime.. " based on his experiences with his linux distributions library installations confirms my impression that the haskell community is among the nicest and most helpful anywhere.
06:48:46 <fantasmaa> @seen
06:50:37 <dcoutts_> obsethryl, there's no Qt thing in GSoC07
06:51:11 <obsethryl> dcoutts_: i found something over the internet sec
06:52:10 <obsethryl> dcoutts_: that is a proposal so far, or perhaps i am not reading it right right now: http://hackage.haskell.org/trac/summer-of-code/ticket/1116
06:52:12 <lambdabot> Title: #1116 (Haskell Qt binding generator) - Haskell.org Google Summer of Code - Trac
06:52:28 <shapr> ptolomy: Which thread was that?
06:52:51 * ptolomy looks for the nabble..
06:53:05 <Nafai> ptolomy: Even in my limited exposure to Haskell, I'd agree
06:53:08 <ptolomy> http://www.nabble.com/Poor-first-impression-tf3656615.html
06:53:09 <lambdabot> Title: Nabble - Poor first impression
06:53:12 <obsethryl> perhaps its only a ticked then
06:53:17 <obsethryl> ticket*
06:54:06 <Nafai> ptolomy: Generally in communities where everyone is (or maybe just seems) so much smarter than me, like in Haskell, the level of niceness and helpfulness is no where near the level of that in the Haskell community
06:59:03 <quicksilver> maybe this demonstrates that to learn haskell you don't need to be clever, so much as nice?
06:59:16 <quicksilver> "Haskell - the *Nice* functional programming language!
06:59:31 <ptolomy> Heh. I think some of the niceness of the community may be attributable to the fact that often haskell is just a humbling language.
06:59:47 <Wild_Cat> Not to be confused with http://en.wikipedia.org/wiki/Nice_programming_language
07:00:14 <matthew_-> ptolomy: you may be on to something there
07:00:49 <petekaz> @tell Cale Is your tutorial on how to use monad transformers available online somewhere? Your site seems to be unresponsive.  Thanks.
07:00:50 <lambdabot> Consider it noted.
07:07:38 <davidL> @seen sorear
07:07:39 <lambdabot> I saw sorear leaving #haskell-overflow, #haskell-blah, #ghc, #haskell, #haskell-soc and #xmonad 8h 44m 37s ago, and .
07:15:24 <ptolomy> What happened to nomaware and it's monad stuff? I haven't been able to load that site in weeks.
07:15:36 <quicksilver> it died
07:15:44 <quicksilver> fortunately, someone uploaded it somewhere else
07:16:18 <quicksilver> http://www.haskell.org/all_about_monads/html/
07:16:20 <lambdabot> Title: All About Monads
07:19:52 <dcoutts_> obsethryl, the point is, that project was not funded
07:20:16 <dcoutts_> we got several projects funded, that wasn't one of them
07:21:25 <obsethryl> dcoutts_: okie, i hope one day something like this starts :)
07:27:38 <petekaz> hmmm ... xmonad still doesn't work with x2vnc.
07:27:59 <petekaz> this stinks.
07:29:46 <dcoutts_> obsethryl, so why qt rather than the existing wx or gtk bindings?
07:30:23 <Wild_Cat> a possible reason is that Gtk doesn't work natively on OSX yet.
07:30:37 <obsethryl> dcoutts_: i happen to like Qt more than both the other solutions for various reasons
07:31:00 <araujo> obsethryl, gtk is cool
07:31:16 <dcoutts_> Wild_Cat, aye, the gtk osx non-x11 version is still not ready for end users
07:31:22 <obsethryl> araujo: no doubt, but i just like Qt more
07:31:57 <Wild_Cat> also, wx on OSX uses Carbon and therefore feels bad.
07:32:15 <obsethryl> araujo: by the word "like" i intend to say "enjoy the variety of features" here
07:32:19 <dcoutts_> Wild_Cat, what's the newer one called?
07:32:19 <obsethryl> Wild_Cat: ;)
07:32:33 <Wild_Cat> dcoutts_: Cocoa?
07:32:38 <dcoutts_> ah yes, that's it
07:32:58 <obsethryl> anyway off to studying a bit more the niceties of haskell :)
07:33:09 <obsethryl> thanks for the input
07:33:39 <Wild_Cat> Carbon apps, by and large, feel, and sometimes look, wrong. The only exception I can think of is iTunes
07:34:07 <Wild_Cat> (and to a lesser extent, the Finder -- FTFF aside, it doesn't feel bad)
07:34:39 <dcoutts_> apparently the gtk-macosx stuff is using cocoa
07:34:54 <Wild_Cat> that's the right thing to do.
07:35:17 <dcoutts_> but of course that's only for the lower layers, the widget drawing and layout is done by gtk
07:35:29 <Wild_Cat> it's a little bit harder since it uses Objective-C instead of plain C
07:35:44 <Wild_Cat> but all things considered, ObjC is a rather good language.
07:36:52 <dcoutts_> and is supported by gcc, though I've never seen it used for anything other than osx system programming
07:37:07 <obsethryl> araujo: is that yours: http://araujoluis.blogspot.com/ ?
07:37:09 <lambdabot> Title: araujo's blog
07:37:12 <Wild_Cat> dcoutts_: there's GNUStep, but nobody uses it.
07:37:26 <araujo> yes obsethryl
07:37:35 <obsethryl> k
07:37:44 <dcoutts_> Wild_Cat, ah yeah, that. It seems not to have changed much since I tried it 10 years ago :-)
07:37:52 <Wild_Cat> pretty much, yeah.
07:38:19 <dcoutts_> though I saw some GNUStep prople had a booth at FOSDEM
07:38:28 * araujo updating himerge and its web-site
07:38:32 <Wild_Cat> a shame, really, because from what I've seen ObjC is much nicer than C++
07:38:50 <dcoutts_> it's not such a complex extension
07:39:10 <wolverian> lambdabot's @instances doesn't look at all the hierarchical libraries, right?
07:39:14 <dcoutts_> but doesn't retrofit GC sadly
07:39:24 <wolverian> is there a way to see what types in the libraries are instances of Foo?
07:39:37 <pjd> what's the proper technical term(s) for functional data dependencies?
07:39:40 <dcoutts_> wolverian, the haddock docs list instances
07:39:49 <dcoutts_> pjd, what do you mean exactly?
07:39:51 <wolverian> dcoutts_, oh, yeah, duh. thanks :)
07:39:55 <quicksilver> pjd: data dependences is a technical term....
07:40:13 <sproingie> gnustep seems to have passed into a nostalgia project these days
07:40:21 <quicksilver> wolverian: lambdabot's @instances looks at what the owner tells it to, which is a big chunk but not the whole hierarchy
07:40:35 <sproingie> they're still enamored of the amazingly fugly look of nextstep
07:40:46 <Wild_Cat> WindowMaker wasn't bad.
07:40:52 <quicksilver> RetroFuglySTEP
07:40:55 <quicksilver> LastSTEP
07:40:58 <quicksilver> BackSTEP
07:41:01 <quicksilver> :P
07:41:06 <Wild_Cat> nowadays GNUStep is about as significant as HURD, I guess.
07:41:15 <sproingie> battleship grey, huge klunky 3d widgets
07:41:20 <pjd> dcoutts_: as in what the IO/State monads introduce to order code
07:41:21 <dcoutts_> QuickStep?
07:41:27 <sproingie> vertical menus, horizontal button strips
07:41:35 <dcoutts_> pjd, ok, data dependency is the right term
07:41:48 <sproingie> unreadable relief-style checkboxes
07:41:56 <obsethryl> araujo: extremely interesting implementation (himerge), bravo
07:42:18 <araujo> Thanks obsethryl :-)
07:42:57 <obsethryl> araujo: from the features i see in there it should be getting a default place in gentoolandia, i did not know of this project :P
07:43:20 <pjd> ok, i was just wondering if there's something more specific for the functional programming sense;  "data dependency" seems to be used very prominently in CPU design
07:44:03 <Wild_Cat> unimportant question: in theory, functional code is very easy to auto-parallelize (monads aside). Do any of the existing Haskell compilers actually do that?
07:44:09 <araujo> obsethryl, it has been on a darcs repo for quite a time now, i hope to be releasing a stable version soon
07:44:23 <araujo> obsethryl, it will probably reach more users by then
07:44:29 <obsethryl> araujo: i will try this at my gentoo box
07:44:31 <quicksilver> Wild_Cat: no. It's surprisingly hard to find the sweetspot for automatic parallelisation
07:44:37 <araujo> obsethryl, Cool!
07:44:45 <quicksilver> Wild_Cat: plenty of people are excited by the idea, though
07:45:10 <quicksilver> Wild_Cat: the thing about on-demand evaluation is that at any particular instant only one thing is being demanded
07:45:10 <Wild_Cat> with the generalization of multi-core CPUs, it's unsurprising.
07:45:11 <obsethryl> araujo: best address for getting it?
07:45:30 <quicksilver> Wild_Cat: so you'd have to somehow predict what was goes to be demanded
07:45:36 <quicksilver> Wild_Cat: i.e. some kind of strictness analysis
07:45:38 <Wild_Cat> especially seeing that non-functional code is often a pain in the butt to parallelize (even manually).
07:45:44 <araujo> obsethryl, right now, i keep fixing/cleaning/adding new featurs to the code. So it has been changed very much lately. Nevertheless, i will release a stable tarball soon (within one or two days)
07:45:48 <obsethryl> araujo: read this one: ?
07:45:51 <obsethryl> http://fmap.us/himerge.html ?
07:45:52 <lambdabot> Title: araujo's home
07:46:00 <sproingie> from what i learned of arrows the other day, &&& and *** lend themselves pretty well to parallelizing
07:46:09 <obsethryl> araujo: okie then i will wait once you do that
07:46:16 <obsethryl> once/till*
07:46:17 <araujo> obsethryl, i happen to update the page a few minutes. The stable version isn't uploaded yet
07:46:24 <obsethryl> k np :)
07:46:26 <araujo> :-)
07:46:29 <dcoutts_> Wild_Cat, there's easyish parallelisation with the parallel evaluation strategies lib, the only auto-parallelisation I know of is the NDP work
07:46:30 <Wild_Cat> quicksilver: I figure parallelization only needs to occur when you need to evaluate something. Because of course, when you don't, Haskell is king since it doesn't evaluate anything.
07:46:34 <dcoutts_> @where ndp
07:46:35 <lambdabot> http://darcs.haskell.org/packages/ndp/Data/Array/Parallel/ http://www.cse.unsw.edu.au/~chak/project/dph
07:46:46 <araujo> obsethryl, you can test the darcs version though ... it goes very well, and it will be the one that will make it to stable anyway
07:46:52 <dcoutts_> the ndp is for parallel arrays, data parallelism
07:47:06 <Wild_Cat> at that point, I guess you can render what needs to be evaluated as a tree whose branches you can evaluate in parallel. Or something.
07:47:26 <Wild_Cat> of course, it's easier said than done.
07:47:29 <sproingie> Wild_Cat: yeah but the cost of not evaluating is remembering that you might have to
07:47:34 <dcoutts_> Wild_Cat, the main difficulty is finding the right granularity
07:47:41 <obsethryl> araujo: then i guess i will have more work cut out for me this weekend :)
07:47:42 <quicksilver> Wild_Cat: no, because you only *need* to evaluate one thing
07:47:46 <quicksilver> Wild_Cat: the head of the tree
07:47:52 <quicksilver> Wild_Cat: then you evaluate the branches on demand
07:47:54 <quicksilver> (which may be never)
07:48:00 <araujo> obsethryl, :-)
07:48:00 <quicksilver> this is the conflict :)
07:48:18 <quicksilver> however, strictness analysis is the kind of solution you need, and GHC already  has some strictness analysis
07:49:07 <araujo> obsethryl, you interested on GUI programming on Haskell?
07:49:26 <dcoutts_> Wild_Cat, the NDP stuff is really cool, you can write algorithms over arrays of arbitrary types, including nested arrays and have it scheduled on multiple cpus, in some early benchmarks they're getting essentially linear speedups for up to 16-way smp
07:49:34 <sproingie> the point being that you get it "for free" with a sufficiently smart compiler
07:49:53 <obsethryl> araujo: yup
07:50:05 <Wild_Cat> sproingie: yeah, I guess my original question was "does such a compiler exist yet?"
07:50:08 <sproingie> i guess if you were insane about using restricted pointers in C you could also have an auto-parallelizing SSC
07:50:18 <dcoutts_> there's an ICFP paper on using profiling to find what is worth doing in parallel, ie finding the right granularity
07:50:24 <araujo> obsethryl, great! , it is really a good language for GUI
07:50:29 <Wild_Cat> ...to which the answer is "no".
07:50:33 <araujo> obsethryl, pretty much the point of himerge is to show that.
07:50:34 <pjd> does GHC's SMP parallelism support do anything for code that isn't explicitly threaded?
07:50:37 <sproingie> Wild_Cat: nope, but ghc is damn close to it
07:50:58 <obsethryl> araujo: i think that as well, functional programming seems like has a perfect match in that field (gui)
07:51:02 <Wild_Cat> groovy.
07:51:10 <dcoutts_> pjd, no, you need something on top, like par, strategies, ndp or forkIO
07:51:16 <araujo> obsethryl, yes, and getting better and better
07:51:29 <sproingie> araujo: what does himerge use for gui?
07:51:42 <obsethryl> sproingie: gtk2hs
07:51:42 <dcoutts_> araujo, aye, it'll get even better, quicker if we make that .def file parser ;-)
07:51:45 <araujo> sproingie, you mean, what toolkit/library?, gtk2hs
07:51:53 <araujo> dcoutts_, ooooh... yeah!!!!
07:52:07 <araujo> dcoutts_, i can take a look at it soon :-)
07:52:10 * dcoutts_ is trying to persuade araujo to help with gtk2hs hacking
07:52:17 <dcoutts_> araujo, cool
07:52:25 <obsethryl> since no qt is available yet on the haskell world, i might as well try my luck with gtk2hs
07:52:26 <Wild_Cat> haskell, perfect for GUI programming? Man, I really need to learn more then. I'd have thought OO languages were a better fit.
07:52:38 <araujo> dcoutts_, i am pretty much just finishing details for a release of himerge atm
07:52:53 <dcoutts_> Wild_Cat, have you ever looked at an event callback in Java? :-)
07:52:53 <sproingie> araujo: anything high level on top of that, or straight gtk2hs?
07:53:03 <araujo> sproingie, straight gtk2hs
07:53:10 <Wild_Cat> dcoutts_: I said "[real] OO languages".
07:53:13 <Wild_Cat> :p
07:53:15 <araujo> Wild_Cat, i invite yout o take a look at my article
07:53:22 <dcoutts_> sproingie, we don't have a high level api on top, but it's a good platform on which to build one
07:53:25 <Wild_Cat> araujo: link please?
07:53:26 <sproingie> i remember frantk from long ago, i fell in love with the idea
07:53:33 <obsethryl> yeah araujo's link was not bad
07:53:34 <dcoutts_> @where gtk2hs
07:53:35 <lambdabot> http://haskell.org/gtk2hs/
07:53:37 <araujo> Wild_Cat, http://araujoluis.blogspot.com
07:53:37 <sproingie> but it was holy hell to build and in the end you needed tk
07:53:39 <lambdabot> Title: araujo's blog
07:53:42 <Wild_Cat> cheers
07:53:46 <quicksilver> pjd: I would argue that `par` doesn't count as 'explicitly threaded'
07:53:53 <quicksilver> I think of it more as a parellisation hint
07:53:55 <sproingie> i guess phooey is the new pure FP gui?
07:53:58 <quicksilver> so it's rather more implicit
07:54:04 <quicksilver> but it's a long way from automatic
07:54:06 <pjd> quicksilver: true
07:54:16 <dcoutts_> sproingie, it's one approach amongst many
07:54:30 <araujo> Wild_Cat, I pretty much think functional programming will help to re-define, improve or even replace many conceptions of OOP for GUI.
07:54:44 <dcoutts_> sproingie, if people decide it's the best approach then we'll implement it on top of gtk2hs
07:54:51 <sproingie> dcoutts_: are there any others using a modern toolkit?
07:55:23 <dcoutts_> sproingie, not many, but I don't think the fact that they are not on modern toolkits was ever the problem
07:55:24 <araujo> sproingie, i have to say that gtk2hs is very high-level and pleasant to work with.
07:55:25 <ndm> I think PropLang is the best way to do a GUI
07:55:30 <ndm> and that is implemented on top of gtk2hs
07:55:46 <dcoutts_> ndm, I should read the code for that some time, see if I really agree :-)
07:55:54 <sproingie> dcoutts_: i'm not really sure how the TV approach works with buttons and the like, i.e. stuff that's more discrete and less continuous
07:56:03 <sproingie> dcoutts_: but i'm out to learn :)
07:56:08 <ndm> dcoutts_: wait til the SoC project kicks off, so i know if the student is going to use it, enhance it or move away from it
07:56:15 <ndm> that will effect what happens
07:56:16 <dcoutts_> ndm, and I need to make you that extension so you can fine out when a property changes
07:56:19 * araujo arranges schedule so he can start helping dcoutts_ with the .def parser
07:56:32 <dcoutts_> araujo, :-)
07:56:50 <osfameron> something like Laszlo would be cute in haskell
07:57:12 <sproingie> a haskell binding to flex would be something
07:57:12 <ndm> dcoutts_: ah yes, that would be handy - although not critical - it works quite fine without it
07:57:19 <Wild_Cat> I hadn't thought of that, but declarative languages do indeed have an edge as far as describing UIs is concerned.
07:57:22 <osfameron> there's a nice system of gui constraints, but of course because javascript isn't FP, it's impossible to do in general case, so it's basically implemented as a hack
07:57:44 <dcoutts_> sproingie, erm, flex? you don't mean flex the lexer generator do you? we've got alex for that of course.
07:57:44 <ndm> have you seen FlapJax, thats insanely cool
07:57:47 <sproingie> javascript can be fp if you want it to be.  just not strongly typed.
07:57:53 <sproingie> dcoutts_: no, adobe flex
07:57:57 <dcoutts_> ah ok
07:58:02 <araujo> Wild_Cat, yay!
07:58:21 <quicksilver> < araujo> sproingie, i have to say that gtk2hs is very high-level and pleasant to work with.
07:58:31 <quicksilver> one of the enchanting things about haskell is even if a library is a little low-level
07:58:38 <quicksilver> it's extremely easy to abstract a bit yourself
07:58:39 <araujo> Wild_Cat, they will also give you (in the case of Haskell) , a good way of rapid prototyping based on solid formalisms
07:58:41 <sproingie> i'll give gtk2hs a try sometime.  i'm starting with wxhaskell right now
07:58:47 <quicksilver> very easy to build a slightly higher level combinator for what you need
07:58:49 <araujo> quicksilver, good point!
07:58:55 <dcoutts_> quicksilver, I think araujo has a slightly different meaning for high level in this context
07:59:00 <araujo> you pretty much expressed what i wanted :-)
07:59:17 <mahogny> quicksilver, oh, but it's easy in C++ too. just add 10 classes on every object, and then some class on top of that, and it all works out
07:59:19 <dcoutts_> I describe wxHaskell and Gtk2Hs as medium level GUI apis
07:59:31 <dcoutts_> they provide some abstraction, but are not high level declarative
07:59:36 <araujo> *nods*
07:59:39 <sproingie> low-level would be hopengl i guess :)
07:59:44 <dcoutts_> right
07:59:49 * mahogny loves writing submissions with hard deadlines in the last minute
07:59:54 <dcoutts_> or something that just wraps all the C calls
07:59:57 <araujo> mahogny, haha
08:00:17 <quicksilver> dcoutts_: I think what I'm trying to say it's actually rather easy to make a declarative mid-layer for your particular project
08:00:21 <obsethryl> hmm i have to subscribe to haskell-gui
08:00:28 <quicksilver> dcoutts_: if you're finding the syntax load a bit high
08:00:37 <mahogny> my supervisor just figured we should apply for a grant. never written an application with CV, personal letter etc in less than 40 minutes :P
08:00:43 <mahogny> until now
08:00:45 <dcoutts_> quicksilver, I'm not sure I get what you mean
08:01:00 <dcoutts_> mahogny, that's good going :-)
08:01:22 <mahogny> well. I wish I could be that efficient with my ordinary work too :)
08:01:29 <araujo> quicksilver, well, that's pretty much inherent to Haskell itself
08:01:46 <sproingie> i sort of have to learn more of haskell itself before i can do anything complicated in it
08:02:10 <sproingie> the concepts like monads click, the syntax for things like transformers and lifts still confounds me
08:02:31 <mahogny> it's barely syntax :)
08:02:31 <sproingie> probably just need practice
08:02:59 <mahogny> I haven't yet found the monad within me
08:03:04 <mahogny> I still think they look ugl
08:03:05 <mahogny> y
08:03:05 <sproingie> and i'm still frightened ad confused by the error output
08:03:35 <dylan> I like the error messages that contain the word "cunning"
08:03:47 <araujo> haha
08:04:08 <dcoutts_> hia andygill
08:04:12 <mahogny> speaking of gtk2hs, it finally compiled :P time to test it on mac
08:04:30 <andygill> hi dcoutts
08:04:46 <dcoutts_> mahogny, it works, but you'll notice straight away it doesn't look native on osx
08:05:27 <dcoutts_> andygill, I'm glad you liked the fusion stuff :-)
08:05:39 <mahogny> well. there are two opposing forces at this place; one mac fanatic (my supervisor) and one anti-C++-and-haskell-lover (me). we'll see who wins in the end
08:05:56 <dcoutts_> andygill, interesting idea about the virtual data types
08:05:59 <andygill> yes, it seems to be more robust
08:06:39 <ndm> dcoutts_: oh, i had a few questions on the fusion stuff
08:06:41 <dcoutts_> andygill, well, we've not solved compiling the nested stuff reliably yet, build/fold is still better there, but we've got some ideas to try
08:06:49 <andygill> I always though of 'iterate (+1) 1' as a function with internal state, your fusion makes this explict.
08:07:05 <dcoutts_> andygill, aye, I suppose so
08:07:17 <sproingie> i'm not so much anti-c++ as i am anti-linker.  about the instant i do anything in C++ that involves more than three lines of code, i end up with mysterious linker errors
08:07:27 <ndm> just how special purpose are the hacky changes you've made to the optimiser?
08:07:43 <mahogny> any language which forces you to manually write headers oughta be banned
08:07:43 <osfameron> sproingie: sure, but to take a "this object has this constraint" and then prove properties on it like "Well, I'd better update that property then" seems to be a bit kludgy.  At least that's what I gathered in the 1 day of Laszlo training I attended (heh, an expert!)
08:07:44 <andygill> Can you fire me a quick email with an example of the problem?
08:07:56 <ndm> i was just wondering, since if you've implemented them in a too hacky way, they may be missing other optimisations which would effect the code
08:08:08 <ndm> mahogny, you mean like haskell? hs-boot and all
08:08:16 <dcoutts_> ndm, too special purpose imho, we have an idea for a better approach but it's not clear yet if it's work
08:08:21 <mahogny> ndm, yeah :)
08:08:28 <Cheery> What makes low level code hard to read?
08:08:29 <sproingie> osfameron: well yeah you pretty much need a framework designed for the purpose
08:08:55 <osfameron> yeah
08:08:59 <ndm> dcoutts_: ok, thats the impression i got
08:09:00 <sproingie> invariant assertions aren't too hard to do in C++ with gnu nana
08:09:00 <dcoutts_> andygill, actually finding a small example is part of the problem, in our tests it was only falling over in the really big multi-module examples, rl is the best person to ask for a test case
08:09:07 <mahogny> speaking of linker errors, someone try (or not) make universal binaries on Mac in combination with systems like Fink and libraries like Qt
08:09:10 <sproingie> nana's an ancient piece of code that still works nicely
08:09:38 <dcoutts_> ndm, it theory you could try and justify them as being general purpose optimisaitons, but in practice this would be the only thing that uses them.
08:09:40 <mahogny> 10 frameworks + libraries and mixed C/C++ = extremely hard to trace linker errors
08:10:09 <sproingie> but constraints ... i suppose you could give class invariants side effects of constraint solving, though that would be "evil"
08:10:25 <ndm> dcoutts_: second thing was on the automatic derivation of steppings, do you have any even half-idea if its really possible?
08:11:01 <ndm> dcoutts_: and their thing, if you were to fuse data structures like booleans, would you end up with something isomorphic to the original code, but with renamed data structures?
08:11:42 <dcoutts_> ndm, well intuitively it looks possible right, I mean we can do it by hand. The question is can we identify the conditions when the transform is possible, then can we automate it. People tried warm fusion before for build/foldr so it's not implausible we could do it for the dual.
08:12:14 <dcoutts_> ndm, as for bool, no idea, I'd have to try it and see, I don't have an intuition for that atm.
08:13:10 <dcoutts_> andygill, but the basic issue is that in a large list comprehension we take a linear number of simplifier+specconstr passes, linear in the number of generators. In the end that's bad.
08:13:15 <ndm> dcoutts_: cool, i've got my optimisation scheme more pinned down now, and hope to implement it shortly
08:13:57 <dcoutts_> andygill, the plan is to avoid ever nesting any streams into stream states, then the optimisation is much much easier, it's just a single spec constr pass.
08:15:16 <mahogny> is it possible to make gtk programs separate from the X process when alt-tabbing? is it possible to give it a resource fork or something?
08:15:22 <mahogny> without too much mess
08:15:27 <dcoutts_> ndm, I'm looking forward to it! :-)
08:16:20 <dcoutts_> mahogny, you can get a gtk prog to switch to another X screen, but disconnecting from X completely is not something that is currently possible with X + Xlib
08:17:14 <dcoutts_> mahogny, the tricky aspect with disconnecting is the server side and client side state.
08:17:49 <sproingie> you have to use something like xnest or vnc which can detach the whole x server without the clients knowing
08:18:35 <mahogny> I suspected so. hurgh. macos is such a SOB if you want to use it as a unix system
08:18:58 <dcoutts_> I think the X hackers want to make disconnecting and reconnecting possible
08:18:59 * araujo greets CosmicRay 
08:19:16 <CosmicRay> hi araujo
08:19:26 <mahogny> a proper X implementation from apple wouldn't hurt
08:23:49 <Wild_Cat> mahogny: what's wrong with Apple's X11?
08:26:30 <ndm> @tell dons The York Haskell users group meets once a day for lunch :)
08:26:31 <lambdabot> Consider it noted.
08:31:07 <andygill> dcoutts, have you considered a difference rewrite schema for list comps?
08:32:31 <dcoutts_> andygill, we considered at least 2, the current monadish style one and one that directly builds a single stream with a complex internal state.
08:33:17 <dcoutts_> directly building a single stream would not allow us to avoid nesting streams in stream states
08:33:43 <dcoutts_> I like the approach of doing a monad style desugaring and going from there
08:36:22 <gimboland> what's a nice succinct way to specify the section for "subtract one" (where, eg (+1) is the section for "add one").  The obvious choice, (-1),  is getting treated as the literal number -1, afaics
08:37:16 <dcoutts_> @type negate
08:37:25 <lambdabot> forall a. (Num a) => a -> a
08:37:43 <dcoutts_> > (negate 1) 7
08:37:44 <lambdabot>   add an instance declaration for (Num (t -> a))
08:37:45 <lambdabot>     In the expression: (nega...
08:37:47 <dcoutts_> bah
08:38:45 <dcoutts_> gimboland, well there's always just (\n->n-1)
08:39:23 <gimboland> :-)
08:39:52 <gimboland> yeah.  just wondered if there was something cunning i was missing.  Ta!
08:41:18 <eumenides> subtract 1
08:42:41 <mahogny> Wild_Cat, nothing wrong with it except it's the only process listed so I can't use alt-tab and at least GIMP has annoying problems with focus
08:42:42 <dcoutts_> ah, I thought there was a named function for it, I got confused with negate
08:45:00 <gimboland> eumenides: even nicer - ta!
08:45:06 <matthew_-> gimboland: flip (-) 1
08:45:50 <gimboland> i thought i tried that but it didn't work.  i must have done it wrong...
08:46:29 <matthew_-> pred
08:47:05 <eumenides> ach
08:47:08 <matthew_-> > pred 4
08:47:10 <lambdabot>  3
08:47:16 <matthew_-> > pred (5/4)
08:47:17 <lambdabot>  0.25
08:49:24 <matthew_-> > pred (negate (1/0))
08:49:25 <lambdabot>  -Infinity
08:49:30 <matthew_-> > pred (1/0)
08:49:32 <lambdabot>  Infinity
08:49:39 <matthew_-> mmm. seems quite useful that
08:49:58 <gimboland> @type pred
08:50:01 <lambdabot> forall a. (Enum a) => a -> a
08:50:32 <matthew_-> mmm. I wonder how hard ghc will try to optimise it. Whether for ints it really will get down to the same as x-1.
08:50:38 <gimboland> i need negatives, (or at least -1), else pred would be nice...
08:51:01 <matthew_-> > pred (negate 5)
08:51:03 <lambdabot>  -6
08:51:07 <gimboland> oh wait...
08:51:26 <gimboland> yeah, sorry, no problemo :-)  super
08:54:43 <hpaste>  gimbo pasted "Suggested xmonad addition: movews" at http://hpaste.org/1596
09:17:41 <bartw> good day
10:07:55 <shapr> SHAZAM!
10:08:25 <shapr> Fun code today guys?
10:08:33 <shapr> I rebuilt the latest version of xmonad, it's nice!
10:09:45 <thetallguy> Maseltov!
10:16:55 <shapr> Sure is quiet today.
10:17:08 * dmhouse_ MAKES SOME NOISE!
10:17:40 <thetallguy> anyone have the cvs command to get the latest inf-haskell?
10:17:53 <thetallguy> stepcut recommended it and google isn't coming up with it.
10:18:58 <dmhouse_> thetallguy: try looking at haskell.org/haskell-mode, that has CVS details.
10:19:14 <dmhouse_> inf-haskell is awesome! For anyone that doesn't know.
10:19:22 <kolmodin> echo "return ()" | ghc --interactive -ignore-dot-ghci -v0 > output
10:19:27 <kolmodin> what does output contain for you?
10:19:45 <kolmodin> for me it contains a single line saying
10:19:46 <kolmodin> ^[[?1034h
10:20:35 <dmhouse_> kolmodin: for me, it's "ghc: command not found", but there may be a logical explanation for that... :)
10:20:50 <kolmodin> dmhouse_: haha :)
10:21:21 <malcolmw> kolmodin: for me, the output file is empty
10:21:40 <kolmodin> malcolmw: what's your system?
10:22:01 <malcolmw> ghc-6.6, powerpc-darwin
10:22:16 <dmhouse_> Everyone that uses haskell-mode should read http://haskell.org/haskellwiki/Haskell_mode_for_Emacs#inf-haskell.el:_the_best_thing_since_the_breadknife
10:22:19 <kolmodin> so the file is really 0 bytes, no unprintable chars or something?
10:22:21 <lambdabot> Title: Haskell mode for Emacs - HaskellWiki, http://tinyurl.com/w7vnb
10:22:30 <malcolmw> kolmodin: yup, zero bytes
10:22:32 <kolmodin> ok
10:22:58 <kolmodin> my machines behavior is clearly a bug, it kills the configuration of hs-plugins
10:23:16 <hpaste>  Gwern pasted "dmenu = no fn" at http://hpaste.org/1597
10:23:51 <Lemmih> kolmodin: zero bytes with ghc-6.6, amd64.
10:23:55 <hpaste>  Gwern pasted "dmenu -fn" at http://hpaste.org/1598
10:24:04 <kolmodin> hmm
10:24:08 <kolmodin> Lemmih: OS?
10:24:15 <Lemmih> kolmodin: Ubuntu.
10:24:18 <kolmodin> right
10:25:37 <kolmodin> ok. thanks
10:29:42 <dmhouse_> Someone say something, I may have just screwed my connection up.
10:29:55 <emu> moo
10:30:08 <dmhouse_> Good. :)
10:30:10 <capisce> moo moo moo
10:30:12 <capisce> moo?
10:30:48 <emu> dmhouse_: is this the first time you have used inf haskell?
10:31:19 <dmhouse_> emu: me? Or thetallguy?
10:36:54 <Saizan> dmhouse_:  (load "~/.lib/fptools/CONTRIB/haskell-modes/emacs/haskell-site-file") \n (load "~/.lib/fptools/CONTRIB/haskell-modes/emacs/inf-haskell") <-- this would work in .emacs to have inf-haskell working?
10:39:09 <emu> you shouldn't have to load inf-haskell like that
10:39:24 <emu> http://haskell.org/haskellwiki/Haskell_mode_for_Emacs#Minimal_setup
10:39:26 <lambdabot> Title: Haskell mode for Emacs - HaskellWiki, http://tinyurl.com/w7vnb
10:45:28 <emu> @pl \ w -> f w w == w
10:45:28 <lambdabot> (==) =<< join f
10:47:38 <shapr> excitement!
10:47:57 <shapr> dmhouse_: Have you tried shim?
10:48:12 * Lemmih doesn't see the excitement.
10:48:18 <shapr> it's hiding...
10:48:20 <joelr1> good day
10:48:27 <shapr> Greetings!
10:48:31 <shapr> Salutations!
10:48:39 <hpaste>  joelr1 pasted "ugly code" at http://hpaste.org/1599
10:48:40 <shapr> Extra-parallel computations!
10:48:50 * shapr is playing with cryptolib
10:48:50 <joelr1> does anyone other than me find this code ugly?
10:50:47 <shapr> Does anyone know if Dominic Steinitz' ASN.1 library is available? I know he split it out of cryptolib, and I need it to read keys.
10:51:07 <allbery_b> it does look rather like it wants to be templated somehow
10:51:10 <Lemmih> joelr1: http://research.microsoft.com/~simonpj/Papers/hmap/index.htm
10:51:12 <lambdabot> Title: Scrap your boilerplate: a practical approach to generic programming
10:52:03 <joelr1> Lemmih: i started a thread on cafe recently about trying to scrap boilerplate when transforming ASTs
10:52:10 <joelr1> i don't think much came out of it
10:53:29 <Lemmih> joelr1: If C.Expr is either a subset or superset of Expr then you could probably use GADTS.
10:54:20 <joelr1> right
10:54:33 <joelr1> it boils down to having to restructure ASTs which i don't want to do
11:05:08 * Lemmih wields his lambdas and starts throwing patches.
11:05:30 <shapr> Yay patches!
11:05:45 <shapr> Lemmih the functional ninja! Head Normal Form ATTACK!
11:06:11 <SamB_XP> if it is the normal form, why do you need to specify it?
11:08:49 * araujo wonders why some people think than using the IO monad makes your program not purely functional
11:09:09 <joelr1> is there a monadic Just?
11:09:25 <Binkley> which people think that?
11:09:37 <shapr> Binkley: Usually imperative programmers.
11:09:38 <Cale> joelr1: return :)
11:09:39 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
11:09:47 <joelr1> Cale:    morph (C.Series id ago) = liftM2 Series (morph id) (Just $ morph ago)
11:09:57 <SamB_XP> well, it does mean the that the program is imperative
11:10:02 <joelr1> Cale: it's _that_ Just
11:10:29 <joelr1> Cale: return . Just =<< morph ago?
11:10:38 <joelr1> i was hoping for a shortcut
11:10:57 <SamB_XP> @pl return . Just =<< morph ago
11:10:58 <lambdabot> Just `fmap` morph ago
11:11:05 <Cale> yeah, fmap
11:11:13 <joelr1> aha!
11:11:16 <araujo> Binkley, shapr yeah
11:11:19 <SamB_XP> hmm, rather presumptuous
11:11:31 <SamB_XP> (assuming there is a Functor instance for the Monad!)
11:11:36 <joelr1> or liftM Just (morph ago) , suppose
11:11:50 <SamB_XP> quite so
11:13:57 <shapr> araujo: I've seen similar misunderstandings with garbage collection.
11:14:25 <araujo> https://www2.blogger.com/comment.g?blogID=6913397465984649777&postID=4450302941445054336
11:14:27 <lambdabot> http://tinyurl.com/yukrbj
11:14:30 <SamB_XP> shapr: hmm?
11:14:36 <SamB_XP> what kind of misunderstandings?
11:14:45 <araujo> shapr, you mean, a functional language can't have a garbage collector?
11:14:48 <shapr> I once got to explain to somebody in extreme detail how garbage collection simulates infinite memory, and is just as useful as manual memory allocation.
11:15:23 <shapr> Someone (I forget who) just didn't understand how GC could possibly work.
11:15:41 <araujo> But, what was he assumption?
11:15:41 <SamB_XP> which is probably why language specs tend not to say that you have to use garbage collection to implement them...
11:15:44 <araujo> his*
11:17:04 <shapr> araujo: Er, something about immutability, sharing and GC
11:17:38 <araujo> yeah, i have noticed that 'mutability' tends to confuse people about it
11:18:30 <SamB_XP> shapr: maybe he didn't realize that the garbage collector is allowed to rewrite immutable objects ;-)
11:19:17 <davidL> is there anything builtin that test for recurring cycles in a list?
11:19:43 <shapr> I said to him, 'if you assume infinite memory you only need to allocate memory for newly created values, and you can ignore values that are no longer used by anything. Garbage collection lets you do something similar by reusing the memory previously used by values that are no longer used.'
11:19:45 <SamB_XP> davidL: 'tis impossible!
11:20:07 <araujo> Very common to the "Haskell has side-effects because of the IO monadic type" confusion
11:20:10 <davidL> SamB_XP: why?
11:20:30 <SamB_XP> shapr: you should have explained the store as representing a directed graph
11:20:31 <araujo> shapr, nice point
11:20:36 <bos> davidL: you need a different notion of equality than haskell provides.
11:20:58 <shapr> SamB_XP: I think that wouldn't have helped.
11:20:58 <SamB_XP> and garbage collection as moving the little pieces of paper around
11:21:24 <shapr> This was a very smart C programmer, but I doubt he'd dealt with directed graphs before.
11:21:28 <SamB_XP> (a directed graph being made of string and paper, obviously!)
11:21:30 <davidL> bos: so it cannot be done in haskell?
11:21:42 <bos> davidL: to detect a loop, you need something like pointer equality.
11:21:57 <Binkley> you can be a programmer without having to think about graphs?
11:22:06 <SamB_XP> Binkley: apparantly!
11:22:16 <shapr> davidL: It can be done, but you need to remove yourself one step, Paul Hudak posted a cute solution for that sort of thing on the mailing list.
11:22:31 <shapr> Binkley: Yup, especially a C programmer.
11:22:35 <SamB_XP> what kind of programmer doesn't know that the store is a directed graph?
11:23:03 <davidL> I will result to using C, if such is the case
11:23:04 <Binkley> it seems like if you didn't know about graphs, and you were a programmer, you would need to invent them
11:23:28 <shapr> Binkley: Yup
11:23:36 <shapr> Binkley: That happens for a lot of things.
11:23:41 <Binkley> yeah
11:23:48 <Binkley> that's why computer science is about reinventing the wheel :-)
11:23:56 <clanehin> davidL: what are you trying to do?
11:24:14 * dylan invented graphs and linked lists on his own. :(
11:24:21 <dylan> [in perl]
11:24:28 <shapr> I met a guy who independently re-invented OO in C with pointer indirection, and was struck by a lightning bolt of understanding when he started using Python/Java.
11:24:36 <davidL> clanehin: trying to find a recurring cycle in a list of numbers
11:24:40 <shapr> dylan: Still, it's the best way to understand them, isn't it?
11:24:50 <SamB_XP> shapr: did he start in the C API guide?
11:24:58 <shapr> I invented pure FP in Python, that's when a friend of mine pointed me to Haskell.
11:25:04 <clanehin> davidL: right, but why?
11:25:11 <dylan> shapr: LOL, that's even better.
11:25:15 <dylan> shapr++
11:25:22 <SamB_XP> shapr: at least PYthon programmers have already heard of referential transparency
11:25:31 <davidL> clanehin: it's a problem on project euler
11:25:44 <clanehin> davidL: wait, do you want to see if the data structure is cyclic, or just that the numbers repeat themselves?
11:25:50 <shapr> dylan: I was also struct by a lightning bolt of understanding when I tried Haskell after that :-)
11:26:21 <shapr> I should have made that struct joke with the C guy comment ;-)
11:26:32 <Binkley> yeah, I was trying to think of a good struct joke there
11:26:37 <dylan> shapr: the only major thing I noticed from perl -> ocaml was static typing and pattern matching, both of which were cool.
11:26:44 <davidL> clanehin: well I know that the numbers will eventually cycle, I just want to find out when and how much
11:26:54 <shapr> Yeah, pattern matching is awesome.
11:27:00 <shapr> And so very simple!
11:27:03 <dylan> and ocaml -> haskell is monads + laziness + sane syntax.
11:27:15 <SamB_XP> davidL: so how would you know if there was a cycle?
11:27:19 <dylan> pattern matching is easier in haskell.
11:27:21 <shapr> dylan: And typeclasses
11:27:38 <dylan> shapr: that wasn't new. it just reminds me of runtime CLOS.
11:27:41 <shapr> I keep hearing that OCaml has different operators for equality on different types.. yow!
11:27:53 <emu> who needs graphs when you have matrices
11:28:12 <shapr> davidL: You can do it by constructing the list and comparing constructors.
11:28:20 <thetallguy> ooh, thanks shapr, that's another thing for my list
11:28:29 <dylan> I miss ocaml's module system
11:28:29 <shapr> thetallguy: what?
11:28:45 <thetallguy> shapr: reasons why we switched from ocaml to Haskell
11:28:46 <dylan> but I wanted it to have first class modules, anyway, which it doesn't...
11:29:09 <SamB_XP> emu: ... matrices sound kinda bulky
11:29:16 <davidL> I will investigate Floyd's cycle-finding algorithm
11:29:17 <shapr> dylan: Which is too bad really, it would be cool to parameterize modules STL-style.
11:29:19 <thetallguy> shapr:  type classes I had down, but it reminded me that you can't dervie stuff in ocaml
11:29:29 <shapr> thetallguy: Yeah, that'd make me crazy.
11:29:30 <SamB_XP> emu: also how do you store your sparse matrices without graphs?
11:29:38 <thetallguy> shapr:  deriving show, read, eq, etc. saves so much brain power
11:29:40 <shapr> dylan: That would be useful when doing QuickCheck tests.
11:29:45 <randomity> davidL: what's the problem?
11:29:55 <emu> mm, vector of lists =)
11:29:59 <dylan> shapr: or buidling UIs seperated from their backends.
11:30:01 <davidL> randomity: problem 26
11:30:05 <shapr> dylan: How so?
11:30:14 <SamB_XP> emu: that sounds rather unsparse
11:30:23 <emu> actually, i use a vector of maps for one of my graphs
11:30:33 <dylan> shapr: the backend of, say, a chat client, is passed a UI module and uses the functions it has.
11:30:42 <randomity> davidL: what?
11:30:48 <shapr> You could use a typeclass for that, yeah?
11:30:56 <emu> instead of an adjacency matrix
11:31:00 <davidL> randomity: projecteuler.net -- problem 26
11:31:08 <dylan> not in the same way I'm thinking. I'm thinking of a typed first-class module.
11:31:16 <dylan> you can emulate it with a record, but it's not the same.
11:31:25 <SamB_XP> shapr: well it might be nice if you could write the type signatures without all the type variables...
11:31:48 <davidL> @users
11:31:49 <lambdabot> Maximum users seen in #haskell: 335, currently: 326 (97.3%), active: 38 (11.7%)
11:31:50 <shapr> SamB_XP: You mean, class constraints are too verbose?
11:32:26 <SamB_XP> shapr: I mean that passing all your type variables to each type constructor could get annoying
11:33:41 <shapr> Oh, for the list cycle problem?
11:34:04 <SamB_XP> shapr: who what where when why how?
11:34:46 <shapr> I'm confused then, what were you talking about? Can you give me an example?
11:35:12 <SamB_XP> well.
11:35:31 <SamB_XP> hmm. what did it look like...
11:36:31 <randomity> davidL: why are you using graph theory for this?
11:36:35 <clanehin> davidL is looking for repeating cycles in the raw data, not the list data structure, but I suspect it's impossible to write a function to do this in every case.  You'll have to use what you know about division to narrow it down.
11:37:17 <davidL> Floyd's algorithm will work fine actually
11:37:19 <randomity> it's a lot easier if you just examine the division algorithm
11:37:32 <davidL> randomity: how so?
11:37:58 <randomity> long division. just implement the algorithm yourself, and keep track of which remainders have already been seen
11:38:20 <davidL> yeah, that's what I was thinking originally
11:38:26 <randomity> as soon as you see a remainder that's already seen, you stop because you know the fraction will repeat infinitely
11:38:46 <SamB_XP> shapr: I can't seem to find a real-world example
11:39:05 <davidL> randomity: ah I see, so instead of looking at the result of the division I should look at the remainder?
11:39:06 <shapr> SamB_XP: If you find one, I want to see it.
11:39:33 <SamB_XP> but imagine an AST with several datatypes in it that are all parameterized by the name type
11:39:39 <bos> someone needs to implement http://en.wikipedia.org/wiki/Tits_group
11:39:40 <randomity> davidL: yes. when the remainder goes to a previous value, the division has started to cycle
11:40:09 <eumenides> does anyone have any simple ST array examples?
11:40:53 * SamB_XP wonders how you would write the type of a module
11:41:22 <bos> SamB_XP: hm?
11:41:35 <SamB_XP> it would be easier with records!
11:41:37 <SamB_XP> real ones!
11:43:07 <davidL> randomity: thanks for the help, that makes a lot more sense than my original implmentation
11:43:25 <shapr> Automorphism.. um, yeah.
11:43:39 <randomity> davidL: np
11:54:44 <DukeDave> Hey gang, I've put a   %format theta' = "\theta'"   in some lhs2tex code but I keep getting "lexical error", any ideas?   :S
11:56:14 <DukeDave> Could easily get around it by not using ', but would make my notation inconsistent  :(
11:56:56 <davidL> randomity: doesn't your implementation assume that there are no sub-cycles in the bigger cycle?
11:57:31 <twanvl> Have you tried just using theta = "\theta"?
11:58:17 <randomity> davidL: I assumed the problem was to find the shortest infinitely repeating cycle in the decimal expansion
11:58:22 <DukeDave> Yeah, that works fine, in fact I already have that defined
11:58:45 <DukeDave> But some of my calculations use theta'  and I wanted to get the nice symbol :(
11:58:45 <randomity> davidL: if you allow longer cycles, then I can just claim that 1/3 is 0.(3333)(3333)(3333), or 0.(3333333333)(3333333333)(3333333333)
11:58:59 <DukeDave> I just can't see to escape the '
11:59:06 <DukeDave> *seem
11:59:09 <randomity> davidL: giving me arbitrarily large cycles for any number
11:59:23 <davidL> randomity: what about, for example, 0.00(177304...)
11:59:55 <DukeDave> Grumble, surely this has come up!
11:59:58 * DukeDave goes searching
12:01:41 <randomity> davidL: dunno
12:03:50 <njd> @users
12:03:51 <lambdabot> Maximum users seen in #haskell: 335, currently: 332 (99.1%), active: 37 (11.1%)
12:04:06 <davidL> randomity: ok, heh, sorry -- I was looking at the quotient again, you're method indeed works
12:04:10 <gimboland> @hoogle trace
12:04:11 <lambdabot> Debug.Trace.trace :: String -> a -> a
12:04:11 <lambdabot> Debug.Trace :: module
12:04:11 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
12:05:37 <Baughn> @hoogle (a -> Bool) -> [a] -> [[a]]
12:05:39 <lambdabot> No matches, try a more general search
12:06:56 <Baughn> @hoogle a -> [a] -> [[a]]
12:06:57 <lambdabot> No matches, try a more general search
12:07:07 <Baughn> @define words
12:07:12 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
12:07:29 <monochrom> haskell is lovely
12:08:52 <Baughn> @type splitWih
12:08:54 <Baughn> @type splitWith
12:08:55 <lambdabot> Not in scope: `splitWih'
12:08:57 <lambdabot> Not in scope: `splitWith'
12:09:19 <bos> splitWith is defined on ByteStrings, not on other types
12:09:34 <monochrom> @type Data.ByteStrings.Lazy.splitWith
12:09:37 <lambdabot> Couldn't find qualified module.
12:09:47 <monochrom> Nevermind me.
12:09:55 <monochrom> @src words
12:09:56 <lambdabot> words s = case dropWhile isSpace s of
12:09:56 <lambdabot>     "" -> []
12:09:56 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
12:10:13 <monochrom> You can write your own splitWith based on that.
12:10:34 <gimboland> looks a bit odd: http://www.cse.unsw.edu.au/~dons/code/lambdabot/State/quote (linked from http://haskell.org/haskellwiki/Lambdabot)
12:10:47 <Baughn> I can. Figured that sort of thing would be in the standard library, though.
12:11:00 <Binkley> yeah, there's been that problem ever since they switched to a binary format for those files
12:11:13 <gimboland> what should it be?
12:11:48 <Binkley> it should be a text file... someone might want to suggest to dons that he set up something that generates the text file from the binary file for purposes of browing
12:12:38 <gimboland> @quote lambdabot
12:12:38 <lambdabot> lambdabot says: Of course i'm female
12:13:00 <gimboland> :) hence the pigtails
12:13:37 <gimboland> my shartak avatar looks remarkably like lambdabot : http://www.shartak.com/profile.cgi?id=3013
12:13:39 <lambdabot> Title: Shartak : gimbo
12:13:43 <gimboland> co-incidence? i don't think so.
12:15:19 <kc5tja> Gahh!  I have to clear the screen.  Every time I read shartak, I read it initially as startrek.  ;D
12:15:53 <gimboland> :)
12:18:26 <shapr> Is there an easy way to grab the source of a MediaWiki page? MoinMoin has something like PageName?source=
12:18:59 <ehird10> shapr: Yes.
12:19:00 <ehird10> Edit it.
12:19:08 <ehird10> It'll give you the source if you can't
12:19:36 <shapr> Hm, I just get "you must be logged in to edit" from HaskellWiki
12:20:44 <ehird10> Oh.
12:20:45 <dmwit> shapr: Which page?  One of us can send it to you.
12:20:46 <ehird10> Login then.
12:21:08 <dmwit> ehird10: It takes a day or two to register (it has to be approved by a human, IIRC).
12:21:12 <ehird10> dmwit: ah
12:21:42 <shapr> dmwit: It's not that I don't have a login, it's that I'm trying to automate checking of the HAppS tutorial on HaskellWiki
12:21:47 <shapr> Lemmih found the solution though.
12:21:53 <ehird10> Well, register a bot account.
12:21:57 <shapr> http://www.haskell.org/haskellwiki/?title=HAppS_tutorial&action=raw
12:21:59 <dmwit> Ah, okay.
12:22:00 <lambdabot> http://tinyurl.com/2d3ruy
12:22:19 <shapr> Lemmih++
12:22:24 <Lemmih> Whee.
12:22:33 <shapr> @karma Lemmih
12:22:34 <lambdabot> Lemmih has a karma of 37
12:22:36 <shapr> @karma lemmih
12:22:37 <lambdabot> lemmih has a karma of 1
12:22:38 <shapr> hmm
12:23:44 <Lemmih> ?karma-all
12:23:45 <lambdabot>  "audreyt"             634
12:23:47 <lambdabot>  "fglock"              193
12:23:49 <lambdabot>  "dons"                139
12:23:51 <lambdabot>  "larry"               106
12:23:53 <lambdabot>  "gaal"                 98
12:23:55 <lambdabot> [989 @more lines]
12:24:05 <Lemmih> fglock, larry?
12:24:06 * ehird10 wishes there was an @all
12:24:32 <shapr> Lemmih: I'm guessing those are #perl6 people.
12:24:44 <shapr> @more
12:24:45 <lambdabot>  "agentz"               88
12:24:45 <lambdabot>  "lwall"                64
12:24:45 <lambdabot>  "putter"               56
12:24:45 <lambdabot>  "glguy"                51
12:24:45 <lambdabot>  "sjanssen"             49
12:24:47 <lambdabot> [984 @more lines]
12:24:59 <shapr> lwall and larry are probably Larry Wall.
12:25:00 <mauke> heh, does lambdabot listen to pugs commit messages?
12:25:10 <shapr> @listchans
12:25:11 <lambdabot> #darcs #gentoo-haskell #gentoo-uy #ghc #haskell #haskell-blah #haskell-overflow #haskell-soc #haskell.dut #haskell.hac07 #jtiger #oasis #parrot #perl6 #scannedinavian #xmonad
12:25:17 <shapr> #perl6
12:26:17 <ehird10> #haskell...blah?
12:26:37 <kaol> for anything but haskell
12:27:25 <ehird10> Isn't that ... everything on freenode except for #*haskell*?
12:28:54 <gds> audreyt, iirc is the dude that started writing perl6 in haskell.
12:29:05 <shapr> Yup, chick
12:29:09 <shapr> not dude
12:29:31 <gds> Sorry - I tend to use "dude" as gender-neutral ;)
12:29:53 <gds> (is there a polite gender-neutral alternative?)
12:30:24 <_roconnor> dood
12:30:25 <ehird10> gds: "him" when gender is not known works for me
12:30:33 <roconnor> d00d
12:30:51 * gds likes d00d :)
12:31:19 <kc5tja> There was once a motion to import Sie from German as a gender-neutral word.
12:31:28 <kc5tja> Not sure what happened to the effort except to say that it fizzled.
12:31:36 <ehird10> Or Hes or whatever
12:31:38 * kc5tja would like to have a proper gender-neutral reference.
12:31:43 <ehird10> I wouldn't
12:31:45 <kc5tja> afk -- lunch, then meeting.
12:31:50 <ehird10> "person" or "they" wfm
12:31:57 <integral> just use "it" :-)
12:32:00 * pjd votes for they
12:32:22 <ehird10> so i would say <gds> audreyt, iirc is the person that started writing perl6 in haskell.
12:32:50 <pjd> s/, iirc is the person that//
12:33:43 <Binkley> or "is the person who started writing..." if you want to be all correct and stuff :-)
12:39:40 <davidL> > scanl (\x -> (x - ((quot x 7) * 7))*10) 1 [1..10]
12:39:42 <lambdabot>      Occurs check: cannot construct the infinite type: a = b -> a
12:39:42 <lambdabot>     Probabl...
12:43:47 <davidL> > scanl (\x y -> (x - ((quot x 7) * 7))*10) 1 [1..10]
12:43:50 <lambdabot>  [1,10,30,20,60,40,50,10,30,20,60]
13:04:46 <emu> wasn't there an X11 library included with ghc?
13:17:31 <Cheery> @dice 1d6
13:17:31 <lambdabot> 1d6 => 6
13:17:37 <Cheery> @dice 1d6
13:17:37 <lambdabot> 1d6 => 4
13:17:41 <Cheery> @dice 1d6
13:17:42 <lambdabot> 1d6 => 3
13:18:55 <ehird10> @dice -1
13:18:55 <lambdabot> unexpected "-": expecting number
13:19:06 <dmwit> ?price 3d2
13:19:07 <lambdabot> 3d2 => 5
13:19:46 <Cheery> @dice 1d6
13:19:47 <lambdabot> 1d6 => 6
13:19:52 <Cheery> gah
13:20:43 <merus> @dice 3d6
13:20:44 <lambdabot> 3d6 => 8
13:20:49 <merus> ewww
13:21:09 <Cheery> just shuffled myself tomorrow's topics. :)
13:21:40 <emu> gtkhs works nicely
13:21:45 <emu> im happy to report
13:23:11 <dolio> @dice 500d250
13:23:11 <lambdabot> 500d250 => 63451
13:25:24 <ddarius> > product [1..100]
13:25:25 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
13:25:31 <ddarius> Doh.
13:25:36 <ddarius> > product [1..50]
13:25:37 <lambdabot>  30414093201713378043612608166064768844377641568960512000000000000
13:26:03 <ddarius> @dice 200d30414093201713378043612608166064768844377641568960512000000000000
13:26:03 <lambdabot> 200d30414093201713378043612... => 322162144545576065266616952903033850738206...
13:26:28 <Cheery> 700000d2
13:26:46 <Cheery> @dice 700000d200000
13:26:47 <lambdabot> 700000d200000 => 69947977698
13:27:00 <dolio> It stops actually rolling dice at some point.
13:27:26 <ddarius> @dice 30414093201713378043612608166064768844377641568960512000000000000d2
13:27:26 <lambdabot> 304140932017133780436126081... => 456211398025700670654189122490972955140153...
13:27:30 <qebab> nothing like a bot to play with on a friday night :)
13:27:41 <ddarius> And every other day of the week.
13:27:49 <qebab> fact
13:29:23 <kosmikus> ?tell DukeDave in lhs2tex formatting directives, you can escape ' by adding another ', so %format theta' = "\theta''"; or, you can use implicit formatting and just say %format theta = "\theta" and then %format theta' (without any right hand side)
13:29:24 <lambdabot> Consider it noted.
13:29:49 <hpaste>  bos pasted "find(1) in haskell" at http://hpaste.org/1600
13:33:04 <dmhouse> bos: nice! Paste the whole module?
13:34:01 <bos> yeah, i'll be putting it up for general use once it's done.
13:35:02 <monochrom> We need to overload &&, ||. :)
13:35:42 <bos> yeah, having to splatter extra goo around them is no fun :-)
13:35:45 <monochrom> I conspire to confuse newbies!  Now they can't even use logic without first fighting an "unresolved overloading" message!
13:35:53 <dmhouse> Yar!
13:35:56 <ddarius> Am I the only person in the Haskell community who doesn't really give a fuck about people who can't follow simple directions and doesn't really think they should be coddled?
13:35:59 <shapr> ddarius: Yeah, I tried 999999999d999999 or something and it crashed lambdabot.
13:36:08 <monochrom> "Why is Haskell resisting to be used?"
13:36:35 <dmhouse> monochrom: actually an overloaded Bool type has been proposed many times.
13:36:39 <shapr> ddarius: Well, I try to give people the benefit of the doubt, the first time I assume they just misread or misunderstood and try to explain to them.
13:37:05 <shapr> ddarius: Have you heard of the social strategy, Tough But Fair?
13:37:06 <monochrom> ddarius: referring to the recent "trying to install hmp3, not ready for prime time" in haskell-cafe?
13:37:23 <ddarius> I'm fairly nice too when they present their problems reasonably.
13:38:03 <ddarius> monochrom: Yes and no.  I've seen many other instances where my thoughts are "Fine, bye".  The Haskell community doesn't need people like them and is not sore for people at all.
13:38:23 <bos> http://www.amazon.com/dp/0446526568
13:38:24 <ddarius> shapr: I don't think so.
13:39:10 <Binkley> ddarius: is this about that guy who wrote he was giving up Haskell because of not having libreadline installed?
13:39:12 <ddarius> bos: I'm usually not too much of an asshole.  But I don't see why we should be importing them.
13:39:24 <bos> ddarius: this was not directed at you at all.
13:39:27 <ddarius> Binkley: See my response to monochrom.
13:39:34 <Binkley> ah sry
13:39:38 <ddarius> bos: Either way.
13:39:41 <monochrom> When I first read the OP, I thought, I should reply "Good bye."  Without comment, help, mocking, lecture.  Just plain "good bye".  However, since everyone has helped, there is no need.
13:39:44 <ddarius> bos: It works for my point.
13:39:50 <bos> ddarius: precisely.
13:39:53 <Binkley> Well, when you say "the Haskell community doesn't need people like them," it depends on your agenda
13:40:01 <Binkley> if you want to see more people using Haskell, I think we need all the people we can get
13:40:11 <Binkley> if you like the community the way it is, though, it's a reasonable opinion
13:40:15 <Binkley> and I think either stance is understandable
13:40:22 <ddarius> Binkley: In my opinion, no reasonable agenda (especially for Haskell) needs people like that.
13:40:56 <ddarius> Personally, I prefer quality people over more people, but in this case, I don't think helping people like that is a net win for getting more people to use Haskell.
13:40:56 <monochrom> Nice, I should take a look at that "no asshole" book.
13:41:13 <Binkley> ddarius: I agree he was coming off like a prick in that post
13:41:23 <Binkley> but I think it's good that people were able to reply to it without stooping to his level
13:41:28 <Binkley> I think that reflects well on our community
13:41:36 <dmhouse> ddarius: that's incredibly judgemental. What if he, say, had just had a crappy week and wasn't ready for one more thing going wrong?
13:41:40 <monochrom> I think it's fair to say: no community wants asshole.  Am I right?
13:41:56 <dmhouse> Admittedly, he did then post to the ML with complaints, but OTOH there _was_ a bug in the build procedure.
13:42:05 <ddarius> Binkley: I agree people shouldn't stoop to his level.  But in my opinion, a straight dismissal (my "Fine, bye" or monochrom's "Good bye") don't do that.
13:42:36 <Binkley> I don't think anyone should feel obligated to help anybody out... but that's the beauty of having an active mailing list
13:42:43 <Binkley> if you don't feel like dealing with someone, you don't have to
13:42:48 <ddarius> dmhouse: What if I'm having a crappy week and just wasn't ready for one more lazy jerk?
13:42:50 <dmhouse> ddarius: and he goes and tells his friends that the Haskell bunch are unfriendly and impatient. We need all the good image we can gather.
13:42:52 <Binkley> hah
13:43:02 <dmhouse> ddarius: then keep your comments to your self. A 'STFU' doesn't help anyone.
13:43:13 <monochrom> He says "good bye" and I reply "good bye".  Seems like what he wants anyway.  He didn't even ask for advice did he?
13:43:15 <ddarius> dmhouse: Anyways, he had to go out of his way to post that comment.  He could have just left, since that was his stated plan anyways.
13:43:38 <ddarius> Binkley: Trust me, I don't. Same here.
13:43:49 <dmhouse> ddarius: yes, and I'm not defending him, that was a stupid thing to do, but there _was_ a bug in the build procedure, cut him some slack.
13:44:07 <ddarius> dmhouse: A "bug" that was readily documented.
13:44:28 <monochrom> The whole message, literally, and neglecting flaming, is, "I notice this problem. Good bye."  OK, looks like a suitable reply is "Point taken. Good bye."
13:44:30 <ddarius> Again, I never suggested saying STFU, just not bothering to help him since he never stated he wanted any.
13:45:01 <dmhouse> Download -> extract -> ./configure -> make -> make install should work unless you have a funky system. Why wasn't said bug fixed, instead of being written about?
13:45:07 <Binkley> I think it's easy to say "this is readily documented" when you're very familiar with the documentation for a particular project
13:45:31 <Binkley> if you're installing something new, and you have two choices, you're going to pick the one that doesn't require you to read more documentation
13:45:37 <monochrom> Well it's written on the same page he obtained the tarball.  No hunting.
13:45:37 <ddarius> It's on the page he downloaded the tarball from.  Also he apparently wasn't even using the build system of his distribution!
13:45:49 <dmhouse> monochrom: seems to me that a better response is "Fair enough, you had a bad experience, help us improve things". If you're not patient enough to give that kind of response, just hold back and let the people that are deal with it.
13:46:12 <Binkley> and the nice thing about that response is it assumes good faith
13:46:12 <ddarius> Binkley: He chose the one that "required" reading no documentation.  Namely, ignoring the documentation right there.
13:46:30 <Binkley> it assumes he wants to help, and when you assume that, sometimes people rise up to it
13:46:58 <monochrom> You are too nice.
13:46:58 <ddarius> dmhouse: Also, note both me and monochrom have not replied in any negative capacity.  We are "holding back".  (Actually, I'm just ignoring it for the most part.)
13:47:35 <dmhouse> ddarius: that's fine, then. We seem to be agreeing that no response is better than a negative response :)
13:48:27 <monochrom> If he deleted his "good bye haskell" then I'm inclined to reply "help us" too.  In fact why did he say "good bye" only to come back for more?  I don't understand.  (Or I do, but I only have a conjecture.)
13:48:47 <Binkley> well, if he was really just swearing off Haskell he wouldn't have wasted time posting to the mailing list
13:48:51 <ddarius> No, my thesis is a "neutral" response may well have been best.  About the only thing this thread garners the Haskell community, in my opinion, is a greater perception of friendliness.
13:49:01 <Binkley> he posted to the mailing list because he wanted people to know what a newbie's impression of haskell was, because he thought they might care
13:49:40 <monochrom> Yeah, "Point taken, good bye" is a neutral response.  Actually better than neutral because it acknowledges the problem and his contribution!
13:49:52 <ddarius> Binkley: The "newbies" that are actually interested in learning Haskell don't have that impression even in those circumstances.
13:50:26 <Binkley> well, this guy didn't want to learn Haskell
13:50:26 <Binkley> he wanted to install an application written in Haskell
13:50:42 <monochrom> He just wants to install an ncurse mp3 player.  Unless he's lying.
13:50:44 <dmhouse> It's not a neutral response at all, it's a response that shows disinterest and no willingness to learn. It's a response that doesn't even point him in the right direction.
13:50:47 <ddarius> If you can't read documentation or follow simple directions though, you're pretty screwed as a programmer in general, and certainly as a Haskell programmer currently.
13:50:54 <Binkley> well, maybe he isn't even a programmer
13:50:55 <Binkley> who knows?
13:51:02 <Binkley> we want more people using applications written in Haskell, right?
13:51:13 <monochrom> Did he want pointed in the right direction?  He didn't say.
13:51:17 <Binkley> and how many more of them are going to get thrown off by things like this? Sure, you can say they're dumb, but that doesn't help you get more users
13:51:28 <monochrom> They are not dumb.
13:51:36 <Binkley> I don't think they're dumb either
13:51:49 <Binkley> I'm just saying, criticizing people for not reading documentation doesn't accomplish much
13:51:57 <Binkley> changing things so the documentation isn't necessary -- when you can -- helps
13:52:05 <monochrom> I think our question is: is he whining? what do we do to whiners?
13:52:27 <ddarius> dmhouse: He explicitly states that he's saying goodbye to Haskell, furthermore I don't see him deriving significant value from the Haskell community.  In my opinion, the right direction for him is away from Haskell.
13:52:46 <dmhouse> I think part of the problem is that it's an unexpected hurdle. You think "Great, a nice MP3 player, let's install it. Okay, I need to install GHC first, let's just get that out of the way... great, this is taking longer than I expected, I really can't be bothered to plough through it, I don't even _want_ a Haskell compiler."
13:53:16 <Binkley> exactly
13:53:33 <monochrom> Perhaps you can argue that "good bye haskell" should not be taken literally, that it's a hyperbole idiom that expresses frustration and nothing more.
13:53:37 <dmhouse> E.g. I can remember trying to download software, and being forced to install and figure out how to use TLA/Arch. _That_ was a painful user experience.
13:54:34 <monochrom> I do think "yum whatever ghc" is the best advice. Perhaps also add "you don't need the latest 6.6.1, it's just 10 hours old, don't worry about it".
13:54:35 <ddarius> dmhouse: Do you dismiss an entire language community because some application does not install right out of the box the way you want?
13:54:56 <Binkley> ddarius: does it matter? the point is that some people *will*
13:55:02 <Binkley> you can't change how people think, but you can change your build process
13:55:25 <ddarius> Binkley: My point is that those people aren't valuable as members of the community.
13:55:54 <Binkley> ddarius: well, presumably we want people who aren't part of "the Haskell community" benefitting from Haskell, too
13:56:03 <Binkley> if we aren't producing applications that the rest of the world wants and needs, what's the point
13:56:27 <ddarius> Binkley: Then he can respond to the hmp3 maintainer, not to the Haskell-cafe
13:56:36 <Binkley> but this wasn't the hmp3 maintainer's fault
13:56:51 <shapr> ddarius: Tough but Fair is "First, treat others how you would want to be treated, then treat them how they treated you."
13:56:53 <ddarius> Then GHC
13:57:00 <Binkley> Well, sure
13:57:04 <clanehin> No, it's his distribution's job to check dependencies, if you install something from source it's assumed you will read the docs
13:57:10 <ddarius> shapr: What I'm suggesting is how I'd want to be treated.
13:57:11 <Binkley> lots of people post things on the wrong mailing list, though
13:57:16 <Muad_Dibler> Binkley, ddarius, shapr: this whole discussion proves something at least!
13:57:29 <shapr> ddarius: Yeah, just describing the strategy. I like studying social strategies.
13:57:34 <clanehin> If he would have just used the distro's tools to do it, he could have complained that the distro didn't check dependencies, if it in fact didn't, but it does
13:57:34 <dmhouse> ddarius: of course not. I'm not defending his actions. But I do think if the entire community labelled him as a jerk and moved on, people would think differently of Haskell.
13:57:53 <dmhouse> clanehin: it was GHC that didn't install, not HMP3.
13:58:06 <ddarius> dmhouse: If they -explicitly- did, ok.  But, again, that's not what I was suggesting.
13:58:14 <shapr> ddarius: One thing I've noticed is that some people come to #haskell and act as they would in #perl or #c. They either change their ways to fit into #haskell, or they leave (or get leaved).
13:58:38 * ddarius doesn't know how people act in #perl or #c.
13:58:47 <clanehin> d,house: I know, and he choose to install it from source instead of using the distribution to do it for him
13:59:08 <ddarius> But yes, people who are interested are at least -remotely- open minded.
13:59:14 <clanehin> dmhouse: so he's on his own at that point
13:59:21 <shapr> ddarius: I joined #perl on EFNet when I only knew VB and asm, and they banned be for asking for an editor with syntax highlighting.
13:59:36 <shapr> er "they banned me"
13:59:40 <Binkley> shapr: what was their justification?
13:59:43 <clanehin> it's like if you drive off-road and then complain there wasn't a sign marking the bumps in the ground
13:59:47 <monochrom> Perhaps the generic binary tarball should just be obscured in the first place.  Choice is known to be user-unfriendly.  If he was forced to get ghc from yum, we wouldn't even hear from him.  There is no loss in generality, since those who read the fine prints will locate the obscured generic binary.
13:59:53 <dmhouse> Yeah, I think the culture of a community is underestimated when rating languages.
13:59:55 <shapr> Binkley: That I was an idiot for asking questions.
14:00:00 <Binkley> haha
14:00:02 <Binkley> jeez
14:00:07 <mauke> probably "asking basic questions"
14:00:10 <capisce> dmhouse: why? :)
14:00:15 <vali> shapr: i can confirm that. haskell is the friendliest and most helpful language-channel i've been to. the elitist-attitude just doesn't seem to be present here
14:00:18 <shapr> Binkley: They said that real programmers don't need colors, and that if I really wanted the solution I could go out and find it myself.
14:00:22 <ddarius> capisce: I highly agree with dmhouse.
14:00:30 <mauke> EFnet/#perl isn't exactly a language/help channel
14:00:33 <ddarius> capisce: Haskell's community is possibly it's -greatest- benefit.
14:00:33 <capisce> you're the one who's going to do the programming, not the community
14:00:54 <shapr> mauke: Well, what is freenode/#haskell, and why are they so different?
14:01:07 <mauke> freenode/#haskell is about the language
14:01:17 <shapr> vali: That's good to hear.
14:01:26 <ddarius> capisce: Since you're here, you may well have noticed that a) having community support helps a lot and um (b) possibly not...
14:01:33 <monochrom> I now need to read everything all of you say. :)
14:01:33 * shapr laughs
14:01:45 <kc5tja> But you can't change the user's build _environment_.  My workstation here at Google won't let me install the Haskell X11 module -- I keep getting errors, no matter WHAT I do.  But it works fine at home.  I spent three days trying (on and off; about 10 to 12 man-hours total).  The authors of X11 can't really address that problem.
14:02:19 <Binkley> no, but you can at least provide error messages that tell the user what they need to do to fix it --
14:02:22 <Binkley> when you *know* that the problem exists
14:02:32 <Binkley> the point of that guy posting about libreadline was to point out that a problem exists
14:02:33 <kc5tja> But, what I _really_ want is to use GHC for actual projects here.  Ahhh....now that would be a dream....
14:02:37 <Binkley> of course it's a known issue, but he didn't know that
14:03:18 <dmhouse> kc5tja: does no-one use Haskell at Google?
14:03:33 <clanehin> Binkley: to be fair, the error message he did get actually did indicate that he was missing libreadline 4.
14:04:48 <shapr> capisce: Yeah, but being able to ask people whenever you hit a bump is handy.
14:04:55 <Binkley> clanehin: well, his complaint, if I read it correctly, was that the build process told him that installation was successful
14:05:04 <Binkley> when in fact it wasn't, because it didn't result in a ghc he could use
14:05:17 <capisce> shapr: might be, when I first learnt programming all I had were books :)
14:05:20 <Binkley> I would agree with him that the build process should be checking for it
14:05:42 <shapr> capisce: Me too, but I've since learned the benefits of a helpful community.
14:05:56 <mauke> shapr: how long ago was this/do you remember who banned you?
14:06:19 * ddarius has never really relied on a community or books for learning/programming. (Well indirectly on the community I guess, that -is- where all the papers and tutorials and such come from.)
14:06:26 <capisce> shapr: that's cool, I'm just reading The Haskell School of Expression now
14:06:35 <capisce> shapr: haven't tried coding anything yet :)
14:06:49 <shapr> capisce: For most problems I just spend another half hour figuring it out, but after that, it's time to ask somebody.
14:07:04 <monochrom> #perl being elitist and Perl being popular.  This is interesting.
14:07:23 <SamB_XP> mauke: so if it isn't about perl, what is it about?
14:07:25 <kc5tja> dmhouse: Apparently there is one other known person who uses it, but no Google project that I'm aware of uses Haskell.
14:07:33 <shapr> mauke: It was probably 1992 or so. I ended up learning Python and never got back to learning Perl.
14:07:47 <mauke> ah, before my time
14:08:05 * kc5tja was thinking of purchasing Haskell School of Expression; however, I ended up getting SICP instead.
14:08:06 <capisce> shapr: I guess I'm conditioned into banging my head against a problem until I figure it out for myself
14:08:15 * kc5tja is still pondering on getting HSE though...
14:08:16 <mauke> SamB_XP: it's more or less a social channel for a certain group of people, that also happen to know perl
14:08:18 <capisce> kc5tja: that's on my list of books to read :)
14:08:28 <SamB_XP> mauke: how is that different from #haskell ;-)
14:08:39 <mauke> #haskell actually talks about haskell
14:08:41 <Binkley> capisce: I'm conditioned that way too, and I've wasted a lot of time that way :-)
14:08:48 <monochrom> social channel is #haskell-blah :)
14:08:52 <SamB_XP> on occasion, yes
14:08:58 <capisce> one question, is it worth reading The Haskell Road To Logic after first having read The Haskell School of Expression?
14:08:58 <mauke> oh, and there is no haskelldoc :-)
14:09:12 <capisce> will it still be valuable and give new insights? :)
14:09:18 <SamB_XP> mauke: sometimes one wonders what to type after foodoc
14:09:30 <SamB_XP> like, can you type perldoc $?
14:10:01 <mauke> SamB_XP: you start with 'foodoc foodoc' then proceed with 'foodoc foo'
14:10:02 <osfameron> SamB_XP: annoyingly, no
14:10:05 <capisce> are there any more in-depth Haskell books that delve into more advanced subjects?
14:10:06 <kc5tja> dmhouse: From what I understand, we do tend to use Python or Scheme for RAD purposes, but once a proof of concept appears, it gets re-implemented in Java, C++, etc., depending on performance requirements.
14:10:06 <monochrom> I have read HSE and lots of other stuff, but not Road To Logic.  I guess that means I don't need the latter.
14:10:10 <osfameron> though you can do perldoc -q faq_topic
14:10:14 <osfameron> or perldoc -f function_name
14:10:19 <SamB_XP> and I wasn't talking about $?, I was talking about $
14:10:39 <mauke> SamB_XP: and what is that supposed to do?
14:10:52 <osfameron> and you should be able to do perldoc -x any_indexed_term  on newer perldoc, though I think that's waiting for me to release a patched version... d'oh...
14:10:56 <monochrom> The haskell wikibook delves into advanced subjects.  Not complete, but see if it has what you want.  http://en.wikibooks.org/wiki/Haskell
14:10:59 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
14:10:59 <SamB_XP> mauke: tell me why there are $ signs everywhere
14:11:13 <SamB_XP> and give me documentation about scalars
14:11:22 <dmhouse> kc5tja: cool. Well, go champion Haskell! :)
14:11:45 <capisce> monochrom: ah, interesting, thank you
14:12:03 <SamB_XP> of course, I'd have to type it like "perldoc '$'" or somesuch
14:12:05 <emu> was somebody talking about difficulty installing the X11 package?
14:12:06 <osfameron> kc5tja: I recommend HSoE, it's written well and has good exercises, and teaches you something interesting
14:12:21 <mauke> SamB_XP: "scalars" is not enough. $ is also part of the syntax for accessing arrays and hashes, and a regex metacharacter
14:12:26 <monochrom> I offer to bring an elitist perspective to the haskell community.  It balances things out.  It is unhealthy to be too sweet.
14:12:30 <dmhouse> And if there's something in the Wikibook that you want to see, request it! Or better, write it yourself!
14:12:40 <mauke> and the name of the built-in pid variable
14:12:41 <SamB_XP> mauke: well I suppose it would talk about all of that except the regex stuff
14:12:42 <yrlnry> #perl can be helpful sometimes.  It depends a lot on who happens to be there.
14:12:57 <osfameron> SamB_XP: it would be "perldox -X $"
14:13:03 <SamB_XP> yrlnry: reminds me of ##c
14:13:03 <mauke> still, EFnet/#perlhelp and freenode/#perl are usually a lot better
14:13:04 <yrlnry> Take out two helpful people and replace them with two pricks and the whol;e character of the channel changes.
14:13:04 <osfameron> SamB_XP: but that doesn't have anything useful in it yet.
14:13:08 <monochrom> I'm procrastinating contributing to the advanced, no-one-will-ever-read parts of the wikibook, e.g., program derivation!
14:13:17 <SamB_XP> osfameron: oh.
14:13:18 <dmhouse> yrlnry: and how you ask your question, I imagine.
14:13:28 <yrlnry> samb_xp: really?  I have not found ##c to be anything other than a bunch of pricks.
14:13:33 <integral> And if your name is recognised.
14:13:35 <kc5tja> dmhouse: I'd love to.
14:13:43 <yrlnry> dmhouse: i think it depends on that a lot less than you might expect.
14:13:49 <SamB_XP> osfameron: would "perldoc perldoc" make it clear how to look up syntactical stuff?
14:13:54 <dmhouse> Part of the way to improve your user experience is to learn how to not be a prick yourself.
14:14:11 * ddarius wonders what helpful person he has replaced... 
14:14:19 <kc5tja> osfameron: Yeah, I just finished SICP, and I really wish I had this book when I was growing up.  :)
14:14:21 <mauke> SamB_XP: it contains "If you are looking for a table of contents to the Perl library modules documentation, see the perltoc page."
14:14:29 <kc5tja> osfameron: I'll wait until next paycheck to purchase HSoE though.
14:14:32 <dmhouse> yrlnry: well, I find that if you ask a reasonable question in a reasonable manner and respond reasonably to any advice offered, you'll get on with most people in most channels.
14:14:35 <SamB_XP> yrlnry: well, I guess nobody has felt helpful lately
14:14:53 <Binkley> the trick is figuring out what "reasonable" means :-)
14:15:01 <SamB_XP> yrlnry: also most of the time people ask really stupid questions in ##c
14:15:06 <osfameron> SamB_XP: er, don't think so.  Feel free to send patches!  (the -X one isn't yet on CPAN, I'm supposed to apply it and release, but I, er, couldn't find tuits)
14:15:23 <SamB_XP> osfameron: I have plenty of square ones
14:15:37 <dmhouse> yrlnry: "People are basically good."
14:15:51 <kc5tja> dmhouse: I was kickbanned from #debian once for asking a question, and yes I've already RTFMed and stated so.  How's that for getting on well?  :)  In fact, that's one reason why I stopped using Debian all-together.  I just didn't want to be associated with that kind of crowd.
14:16:22 <osfameron> SamB_XP: right now, your best bet is "perldoc perldoc", "perldoc perltoc" and then read lots of stuff, especially perlop and perlfunc, also perlsub... but yeah, until the indexing stuff gets off the ground, it can be a bit annoying to remember where to look for stuff
14:16:29 <yrlnry> I once got kickbanned from #unix for asking what the name of the table is in the kernel that maps the file descriptor number to the file pointer.
14:16:41 <hyrax42> ?src Data.Map.unions
14:16:42 <lambdabot> Source not found. My pet ferret can type better than you!
14:16:52 <osfameron> kc5tja: it's worth it, I think.  I still need to read SICP too...
14:16:54 <Binkley> the table that can be named is not the true table
14:16:58 <SamB_XP> yrlnry: you'd think they'd be helpful enough to answer "file descriptor table"...
14:16:58 <yrlnry> Oh, and for contracdicting someone when he informed me that I was trying to get them to do my homework for me.
14:17:03 <hyrax42> :t M.unions
14:17:06 <lambdabot> forall k a. (Ord k) => [M.Map k a] -> M.Map k a
14:17:13 <hyrax42> ?src M.unions
14:17:14 <integral> yrlnry: Those would be "FILE *"s?
14:17:14 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
14:17:18 <kc5tja> yrlnry: Heheh -- that'd be the handle table.  But that's pretty silly though.  I hate it when people do things like that that take more energy to kickban you than to just answer the damn question.  :)
14:17:23 <SamB_XP> integral: ints
14:17:41 <kc5tja> integral: Nope.
14:17:49 <kc5tja> FILE *s are c structures that reside in user-space.
14:17:56 <integral> kc5tja: Yes, I know that.
14:18:05 <hyrax42> ?fptools Data.Map
14:18:06 <lambdabot> http://darcs.haskell.org/packages/base/Data/Map.hs
14:18:06 * monochrom bans integral for a mistake :)
14:18:06 <kc5tja> Within the FILE structure, there is an int which refers to the Unix file descriptor -- I think he was asking about that descriptor mapping.
14:18:13 <kc5tja> Hahaha
14:18:19 <integral> I was just pointing out that you could misread yrlnry's line.
14:18:23 <kc5tja> # /kickban integral n00b!  ;D
14:18:30 * kc5tja nods
14:18:35 <yrlnry> kc5tja: I nursed the grudge for a long time until the same guy showed up in #perl and then I accused him of trying to get us to do his homework for him and booted him.  It was petty, but satisfying.
14:18:37 * monochrom bans yrlnry for being ambiguous
14:18:38 <SamB_XP> and the kernel has a some kind of table indexed by fd
14:18:41 <SamB_XP> for each process
14:18:42 <integral> I walked into that one though
14:18:46 <osfameron> is this the #haskell for perlers channel?  oh, no, it's the proper one!
14:18:50 <yrlnry> integral: No, not the FILE *
14:18:55 * osfameron band monochrom for banning too many people
14:19:01 <yrlnry> integral: No, not the FILE *'s; the internal kernel file pointer objects that contain the seek offsets.
14:19:09 <integral> yrlnry: I guessed that.
14:19:09 * monochrom bans osfameron for typo!
14:19:10 --- mode: ChanServ set +o dmhouse
14:19:10 <SamB_XP> osfameron: you confused with #perl6?
14:19:15 <kc5tja> yrlnry: YYESS!!  That's awesome.  Revenge is a dish best served cold.  Of course, now there's a cold war between you.
14:19:17 <dmhouse> Enough banning. :)
14:19:22 <yrlnry> who cares?
14:19:25 <kc5tja> That's the problem with revenge.
14:19:26 <integral> there's a #haskell on irc.perl.org too, osfameron
14:19:28 <osfameron> SamB_XP: no, there's a #haskell on rhizomatic too ;-)
14:19:36 <kc5tja> It's great to see other people do it, but I sure don't want to be involved.  ;D
14:19:38 <SamB_XP> oh. whatever that be!
14:19:39 <osfameron> integral: yeah, I'm on that one too.  It's quite quiet compared to this one
14:19:50 <integral> I meant to kc5tja not osfameron clearly :-)
14:19:54 <SamB_XP> this one is quite noisy lately
14:19:57 <integral> no, SamB_XP I meant.
14:20:09 <osfameron> integral: make up your mind ;-)
14:20:16 --- mode: dmhouse set -o dmhouse
14:20:20 * integral points into the crowd randomly
14:20:32 <monochrom> integral means me
14:20:38 * dmhouse really doesn't know how to work ERC properly yet, it took me 3 minutes to find that command :)
14:20:49 <monochrom> ERC = ?
14:20:55 <kc5tja> Emacs Relay Client
14:20:58 <dmhouse> An IRC client built into Emacs.
14:21:05 <monochrom> It's antique.
14:21:10 <dmhouse> It's convenient.
14:21:17 <osfameron> so is irssi
14:21:19 <kc5tja> It's little.
14:21:21 <SamB_XP> I hope we don't try that silly thing where you randomly split the people joining into two different channels
14:21:31 * kc5tja uses irssi -- I'm quite pleased with it.
14:21:43 <cdsmith> kc5tja: is that little by emacs standards?
14:21:46 <Muad_Dibler> I use mIRC.
14:21:47 * dmhouse used to, but a client running within the editor is just More Convenient.
14:22:04 * Muad_Dibler waits for flaming.
14:22:04 <kc5tja> cdsmith: No, it was a fishing hook to get someone else to post, "It's yellow."  Then I'd follow up with, "It's different."  :D
14:22:20 <cdsmith> kc5tja: ah!
14:24:04 <ddarius> Muad_Dibler: Wrong channel.
14:24:46 <monochrom> wrong channel to get flamed
14:25:12 <Binkley> <obflame>mIRC? YOU N00B</obflame>
14:25:24 <Muad_Dibler> thank you Binkley :)
14:25:31 <Binkley> happy to oblige ;-)
14:29:04 <vali> is there no windows binary for 6.6.1 yet?
14:30:59 <Philippa> Binkley: it's not quite as crappy these days, though my only real excuse is that I lost the code for my own client and never got started on rewriting it...
14:31:22 <Binkley> I don't really have strong feelings about it
14:31:56 <Philippa> there're some annoying bits of IRC culture it's somewhat more responsible for than most
14:31:58 <Binkley> I just wanted to make sure Muad_Dibler got the expected flame :-)
14:34:08 <monochrom> My ghc 6.6.1 build has finished!  Just two hours.  I use -H80m -O -fasm
14:34:13 <shapr> @seen capisce
14:34:14 <lambdabot> I saw capisce leaving #haskell 17m 57s ago, and .
14:34:17 <shapr> aww
14:34:18 <shapr> I missed him.
14:34:39 <monochrom> -H80m may be more than necessary.  I was just trying.  Last time I tried 64, should be good enough.
14:34:51 <monochrom> But I now strongly believe in -fasm.
14:35:03 <shapr> @tell capisce Yes, the Haskell Road To Maths and Logic is worth reading separately from HSoE and The Craft of Functional Programming
14:35:04 <lambdabot> Consider it noted.
14:35:59 <monochrom> shapr: could you tell me why? thanks.
14:36:39 <shapr> ddarius: Anyway, I think it's good to be welcoming at first because the irritating may not know any other way to behave in a technical discussion. But if they are unable to learn how to fit into the new community even after explicit descriptions of how to behave, then they should be removed.
14:37:04 <shapr> For example, Smerdyakov is doing good things in the field of proof programming, but I still don't want him in #haskell.
14:37:54 * araujo still trying to explain the "IO monad isn't an impure computation ..."
14:38:33 <kc5tja> OK, I've been browsing about for a while, but not able to find a definitive answer to this question.  Given func v | v == 0 = blah; | v == 1 = blort; | _ = everythingElse, Haskell really doesn't seem to like this construct.  It complains about the _ clause.  Is there a way to match an "everything else" clause when using this kind of pattern-matching?
14:38:36 <shapr> araujo: I explain the state monad in terms of a calculator with a Memory button. It's usually clear how that can be both 'stateful' and pure at the same time.
14:38:48 <bos> is there a standard way to name variants of functions that do and don't handle exceptions?
14:38:57 <araujo> shapr, elaborate? :-)
14:39:07 <Binkley> kc5tja: why not write _ = everythingElse for your default case?
14:39:09 <Binkley> omitting the |
14:39:18 <shapr> monochrom, araujo: phone, will respond later
14:39:28 <araujo> shapr, good
14:39:31 <mauke> kc5tja: that's because the syntax requires a (boolean) expression after |
14:39:43 <mauke> kc5tja: _ is not valid in an expression. trivial workaround:  | True = ...
14:39:46 <gds> kc5tja: you want "otherwise" iirc
14:39:59 <mauke> the prelude contains  otherwise :: Bool; otherwise = True
14:40:00 <kc5tja> mauke: Hmmm, OK.  I was just wondering.
14:40:03 <kc5tja> gds: Thanks.
14:40:09 * kc5tja tries it.
14:40:27 <mauke> > if otherwise then 2 else 3
14:40:29 <lambdabot>  2
14:40:55 * gds nips in with the keyword "otherwise" while mauke explains why it makes sense ;)
14:41:06 <mauke> it's not a keyword
14:41:12 <mauke> it's just a variable
14:41:16 <monochrom> > case 10 of v | v==0 = 0 | v==1 = 1 | otherwise = v
14:41:17 <lambdabot>  Parse error
14:41:21 <gds> Sorry, I meant in the conversational sense...
14:41:28 <monochrom> > case 10 of v | v==0 = 0; | v==1 = 1; | otherwise = v
14:41:29 <lambdabot>  Parse error
14:41:37 <mauke> > case 10 of v | v==0 -> 0 | v==1 -> 1 | otherwise -> v
14:41:39 <lambdabot>  10
14:41:55 <monochrom> OH!
14:42:07 <mauke> > case 10of v|v==0->0|v==1->1|otherwise->v
14:42:09 <lambdabot>  10
14:42:18 <mauke> wow, perl's got nothing on this
14:43:59 <kaol> > case 10of v|v==0->0|v==1->1|True->v
14:44:00 <lambdabot>  10
14:44:12 <kc5tja> > otherwise
14:44:14 <lambdabot>  True
14:44:26 <SamB_XP> > 10
14:44:28 <lambdabot>  10
14:44:34 <mauke> OPTOMIZED
14:44:59 <kc5tja> > if if then then else else
14:45:00 <lambdabot>  Parse error
14:45:10 <kc5tja> doh, can't grok PL/I.  Shucky darn.  :)
14:45:41 <yrlnry> I wonder if   "if then then else else if" is more confusing.
14:45:53 <yrlnry> "if else then if else then"
14:46:00 <yrlnry> Ah, that's best.
14:46:16 * yrlnry is deeply satisfied.
14:46:23 <mauke> oh god, I had a parser for that once
14:46:42 <mauke> it just failed to check variables for keywordness
14:46:51 <kaol> > if if True then True else False then True else False
14:46:53 <lambdabot>  True
14:47:49 <mauke> > if not if otherwise then not True else otherwise then True else not otherwise
14:47:50 <lambdabot>  Parse error
14:47:53 <mauke> :(
14:48:40 <mauke> > if not$ if otherwise then not True else otherwise then True else not otherwise
14:48:41 <lambdabot>  True
14:52:25 <kc5tja> Hehehe
14:52:38 <hyrax42> ?docs Data.Map
14:52:39 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
14:57:54 <hyrax42> ?pl \x -> f (g x) (h x)
14:57:55 <lambdabot> liftM2 f g h
15:13:12 <hyrax42> ?src foldl'
15:13:13 <lambdabot> foldl' f a []     = a
15:13:13 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:14:43 <sorear> @seen davidL
15:14:43 <lambdabot> davidL is in #xmonad and #haskell. I last heard davidL speak 24m 14s ago.
15:14:54 <davidL> hey
15:15:04 <sorear> hi?
15:15:18 <davidL> (it's fantasma)
15:15:28 <sorear> it = ?
15:15:41 <davidL> me
15:15:56 <davidL> I'm fantasma
15:16:02 <ddarius> @seen fantasma
15:16:03 <lambdabot> I saw fantasma leaving #haskell, #ghc, #darcs and #xmonad 46m 43s ago, and .
15:16:38 <newsham> http://www.cs.ubc.ca/labs/dsg/Sem_Winter_2007/2007-eurosys-melange.pdf
15:16:41 <lambdabot> http://tinyurl.com/26qxbv
15:16:43 <sorear> ddarius: no, you're not.  had I been awake at the time I would have responded "Haskell won't miss you.  We don't need people who are too dumb to read requirements lists.".  fortunately, I wasn't.
15:17:21 <monochrom> Please give me a debugger that is not there yet! :)
15:18:25 <ddarius> sorear: I know what discussion you are replying to, but not which line I said that you are.
15:18:42 <ddarius> :t show . read
15:18:45 <lambdabot> String -> String
15:19:25 <ddarius> Oh.  The first line.
15:20:37 <sjanssen> sorear: referring to the "Poor first impression" email?
15:21:52 <sorear> sjanssen: 13:35:56 <ddarius> Am I the only person in the Haskell community who doesn't really give a fuck about people who can't follow simple directions and doesn't really think they should be coddled?
15:22:05 <sorear> indirectly, yes.
15:22:39 <sjanssen> heh, "fuck" is easy to grep for in #haskell
15:23:05 <sorear> that's how I re-found it when ddarius asked ;)
15:23:11 <ddarius> newsham: Unfortunately, for good and bad reasons, the obvious trend arising from work like that will not be acknowledged (though clearly stated) for quite some time despite undeniable advantages in every way.
15:23:49 * ddarius wonders how many lines of his contain "fuck".  Even discounting this line, it should be more than one.
15:25:45 <sorear> ddarius: in the entire history of clog's #haskell logging, exactly three lines match ddarius.*fuck
15:26:11 <sjanssen> I suppose this makes four?
15:26:31 <sorear> sjanssen: yeah.  ddarius sorear ddarius sorear
15:26:37 <ddarius> Well, there's also darius.
15:26:41 <ddarius> Well, Darius
15:26:57 <sorear> 03.04.25:09:11:35 <vincenz> Darius: I don't know, I think with c you can do some major fucked up shit
15:26:57 <sorear> 04.12.14:17:15:45 <Darius> Philippa: brainfuck isn't that bad.
15:26:57 <sorear> 04.12.14:17:16:44 <Darius> Philippa: Heck, ML has worse syntax than brainfuck.
15:27:16 <sorear> so, only your /quit message :)
15:27:33 <sjanssen> mdo n <- countLines "ddarius.*fuck"; putStrLn $ show n ++ "times ddarius.*fuck"
15:27:39 <Saizan> that last 2 lines should be @remembered
15:28:13 <Saizan> ?instances MonadFix
15:28:22 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
15:28:25 <kc5tja> ML isn't the prettiest syntax, but it's far better than BF, I think.
15:28:51 <sorear> @seen jcreigh
15:28:52 <lambdabot> jcreigh is in #xmonad, #haskell-blah and #haskell. I last heard jcreigh speak 2h 50m 7s ago.
15:29:55 <ddarius> kc5tja: The weak semantics of Brainfuck are what makes it "ugly" not so much the syntax.
15:30:54 <sorear> hello dcoutts!
15:31:03 <dcoutts> hia sorear
15:31:03 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
15:35:02 <davidL> how do I do something along the lines of ``takeWhile (\x -> notElem x) list''
15:36:08 <monochrom> takeWhile notElem list
15:36:13 <Saizan> is it normal that make install resembles a ./configure when building ghc?
15:36:35 <davidL> monochrom: notElem has two parameters though
15:36:36 <monochrom> perhaps you mean takeWhile (`notElem` "abc") list
15:37:02 <davidL> monochrom: I want to to notElem x <list that has already been processed>
15:37:21 <davidL> basically, it would takeWhile until there is an element that repeats
15:38:27 * monochrom has an evil idea
15:39:34 <kc5tja> ddarius: We're just going to have to agree to disagree on this issue.  BF is so-named for a reason.  :)
15:39:37 * monochrom 's idea clearly diverges
15:40:28 <sorear> Saizan: yes, the configure is rerun because the results are not cached.
15:40:56 <ddarius> > takeWhile (null . tail) . group $ "abcddefggh"
15:40:59 <sorear> Saizan: keep in mind the ghc build system is in serious flux - it was only moved to cabal 2 weeks ago
15:41:01 <lambdabot>  ["a","b","c"]
15:41:09 <ddarius> > concat . takeWhile (null . tail) . group $ "abcddefggh"
15:41:10 <lambdabot>  "abc"
15:41:35 <dolio> > concat . takeWhile (null . tail) . group $ "abcbdbebfbgb"
15:41:37 <lambdabot>  "abcbdbebfbgb"
15:42:20 <ddarius> foldM ho!
15:42:50 * monochrom has an inefficient idea
15:43:01 <procyon112> > let f x:y:z | x==y = x; f x:y:z = x : (f (y:z)); f x = [x]; f [] = [] in f "abcdeffgh"
15:43:02 <lambdabot>  Parse error in pattern
15:43:08 <kc5tja> monochrome has a cunning plan...
15:43:19 <ddarius> Or unfoldr.
15:44:59 * ddarius decides to eat ice cream and watch movies.
15:48:49 <dolio> > let f (_, []) = Nothing ; f (s, h:t) | h `elem` s = Nothing | otherwise = Just (h, (insert h s, t)) in unfoldr f ([], "abdbdbebfbgb")
15:48:50 <lambdabot>  "abd"
15:49:22 <monochrom> yeah, I like that.
15:50:37 <Saizan> ?type insert
15:50:40 <lambdabot> forall a. (Ord a) => a -> [a] -> [a]
15:51:03 <Saizan> ?type elem
15:51:06 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
15:51:47 <Saizan> mmh, so insert just waste cpu cycles?
15:52:13 <dolio> That could just be h:s. I was thinking Data.Set at first, but then I didn't want to type extra stuff.
15:52:17 <Saizan> this is a work for Data.Set
15:52:22 <Saizan> :D
15:52:27 <Saizan> fine :)
15:56:18 <sorear> Saizan: don't trust @src, it as a very curious mixture of
15:56:43 <sorear> a) specification pseudo-psuedo-code from the Report, not actually used by any compiler
15:56:45 <sorear> @src sort
15:56:46 <lambdabot> sort = sortBy compare
15:56:49 <sorear> @src sortBy
15:56:50 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
15:57:07 <sorear> b) ultra-evil ghc magic that users oughtn't see
15:57:13 <sorear> @src unsafePerformIO
15:57:13 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
15:57:25 <opqdonut> @src insertBy
15:57:26 <lambdabot> insertBy _   x [] = [x]
15:57:26 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
15:57:26 <lambdabot>                                  GT -> y : insertBy cmp x ys'
15:57:26 <lambdabot>                                  _  -> x : ys
15:58:32 <monochrom> This is great. :)
16:07:30 <dolio> > let test c = uncurry (||) `liftM` gets (second $ elem c) >>= \b -> modify (const b *** (c:)) >> return b ; f s c = test c >>= \b -> if b then return s else return (c:s) in reverse . flip evalState (False, []) $ foldM f [] "abcbdbeb" -- Yuck
16:07:32 <lambdabot>  "abc"
16:08:27 <ehird10> i still think "foldM = fix (flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . liftM2 flip ((flip . (((.) . (>>=)) .)) .) . (flip .))" is the best thing lambdabot has ever said
16:08:56 <opqdonut> ?pl foldM
16:08:57 <lambdabot> foldM
16:08:58 <ehird10> ... and then "foldM = fix (\ aw f i -> (\ w -> ((\ ao cp ai aj am -> (ao cp aj) >>= (ai am)) >>= \ aa -> (\ cv ar as -> aw cv as ar) >>= \ z -> return (\ ag -> aa ag z)) f i (head w)) >>= \ bn -> tail >>= \ bm -> (return (bn bm))" the other way through
16:09:12 <ehird10> > (return (bn bm))" the other way throug (that got chopped off...)
16:09:12 <lambdabot>  Improperly terminated string
16:09:14 <opqdonut> how did you get that out?-D
16:09:21 <dolio> I don't know, that doesn't have any (,) in there to get confused with (.)
16:09:24 <ehird10> opqdonut: @src foldM, @pl the-source, @unpl the-result
16:09:32 <opqdonut> haha
16:09:37 <opqdonut> @src foldM
16:09:37 <lambdabot> foldM _ a []     = return a
16:09:38 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
16:09:45 <ehird10> just the second line
16:09:49 <opqdonut> @pl f a x >>= \fax -> foldM f fax xs
16:09:50 <lambdabot> flip (foldM f) xs =<< f a x
16:09:59 <ehird10> no:
16:10:00 <ehird10> @pl foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
16:10:01 <lambdabot> foldM = fix (flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . liftM2 flip ((flip . (((.) . (>>=)) .)) .) . (flip .))
16:10:15 <opqdonut> ah yes
16:31:39 <TomMD> @seen lambdabot
16:31:40 <lambdabot> Yes, I'm here. I'm in #haskell, #xmonad, #parrot, #scannedinavian, #jtiger, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell-soc, #haskell.dut, #haskell.hac07, #haskell-overflow
16:31:40 <lambdabot> and #haskell-blah
16:32:31 <pjd> do androids look in electric mirrors?
16:32:31 <ehird10> > "\n@seen lambdabot"
16:32:32 <lambdabot>  "\n@seen lambdabot"
16:32:34 <ehird10> aww
16:46:32 <davidL> @pl x -> f . f . f . f . f . f . f . x
16:46:33 <lambdabot> (line 1, column 3):
16:46:33 <lambdabot> unexpected ">" or "-"
16:46:33 <lambdabot> expecting variable, "(", operator or end of input
16:46:45 <davidL> @pl \x -> f . f . f . f . f . f . f . x
16:46:46 <lambdabot> ((f . f . f . f . f . f . f) .)
16:48:06 <opqdonut> :t iterate
16:48:09 <lambdabot> forall a. (a -> a) -> a -> [a]
16:48:27 <opqdonut> > (iterate (+1) 0)!!10
16:48:29 <lambdabot>  10
16:48:32 <opqdonut> :)
16:48:36 <davidL> ?index unfoldr
16:48:37 <lambdabot> Data.List
17:01:08 <hpaste>  jcreigh pasted "FFI question: Cleaner way to free resources?" at http://hpaste.org/1601
17:02:07 <jcreigh> any takers?
17:04:20 <mauke> I don't see a way to improve that
17:05:47 <sorear> jcreigh: do it higher order! :)
17:05:52 <jcreigh> I guess it's inevitable that FFI code tends to look like C.
17:05:53 <jcreigh> sorear: how?
17:06:07 <davidL> @hoogle Maybe -> Int
17:06:08 <lambdabot> No matches, try a more general search
17:06:35 <sorear> jcreigh: write higher level combinators.
17:06:46 <sorear> foo :: CString -> IO (Maybe String)
17:07:06 <Saizan> how do you "fail" in an arrow built with arr?
17:07:21 <sorear> foo x | x == nullPtr = return Nothing
17:07:22 <sorear>       | otherwise    = peekCString x *> xFree x
17:07:38 <jcreigh> :t (*>)
17:07:40 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
17:07:59 <jcreigh> I was wonder if there was some "do a, then b, but return the value from a" combinator.
17:08:00 <sorear> (*>) = liftM2 const -- defined in Control.Applicative, but only for applicative functors!  why can't monad have the right superclasses?
17:08:03 <jcreigh> *wondering
17:09:19 <davidL> @index maybeToList
17:09:20 <lambdabot> Data.Maybe
17:10:36 <ddarius> sorear: In this case, Monad's preceded Applicative.
17:10:49 <ddarius> Yes, even Haskell is beset by legacy.
17:12:19 <monochrom> :*)
17:12:56 <jcreigh> So the hierarchy looks like Functor -> Applicative -> Monad? ie, everything you can do with a Functor, you can do with Applicative. Everything you can do with Applicative, you can do with Monad. Is that correct?
17:13:52 <monochrom> Where does Arrow stand?
17:14:08 <jcreigh> darned if I know.
17:18:21 <ddarius> They don't have the same kind.
17:20:30 <procyon112> ooh... SuperState is cool!  I need to browse the monad libraries more often... It seems like every time I finish writing some code, I find some standard library monad that would have done the whole thing for me.
17:23:19 <stepcut> SuperState ?
17:24:26 <procyon112> SuperState Holds a global and local state, then uses nondeterminism with the local state, but seperates out the global state.
17:25:33 <stepcut> where can I find this ?
17:25:54 <procyon112> It looks like a near perfect fit for my Genetic Programming stuff... Store the best individuals in the global state, and evolve them nondeterministically.
17:26:09 <procyon112> http://www.haskell.org/haskellwiki/Stateful_nondeterminism
17:26:11 <lambdabot> Title: Stateful nondeterminism - HaskellWiki
17:30:26 * monochrom is up to 6.6.1 !
17:30:56 * dolio is at 6.7.20070426. :)
17:31:46 <dolio> Only took like 75 minutes to compile.
17:43:39 <sorear> Suppose I have a fast search algorithm written in C.
17:43:50 <sorear> Now suppose the algorithm finds something.
17:44:11 <sorear> I want to a flexible abort system.
17:44:24 <sorear> Is there any way to "longjmp" through a safe foreign call?
17:44:46 <monochrom> horror!
17:45:08 <monochrom> may be more useful to ask on ghc and let the simons decide
17:45:14 <sorear> I think I *might* still be wearing my C programmer hat :)
17:45:28 <sorear> monochrom: ghc == #ghc? glasgow-haskell-users?
17:45:43 <monochrom> glasgow-haskell-users I mean
17:47:09 <dolio> > words "foo   \n\n\r"
17:47:11 <lambdabot>  ["foo"]
17:48:13 <sorear> I just remembered gfind uses a global int aborting;
17:48:24 <sorear> so I won't need longjmp :|
17:51:06 <monochrom> Here is an idea.  You don't need longjmp if you use recursion.  So, recurse if you want to loop back, don't recurse if you want to abort.  With tail-call optimization you get the same code as looping.  Just use gcc -O2
17:52:04 <mauke> what if you want to abort from a callback?
17:52:32 <dylan> the callback returns Nothing to abort?
17:52:39 <mauke> lame
17:52:47 <dylan> or you Cont
17:52:50 <dylan> *use
17:53:21 <mauke> in C?
17:53:29 <sorear> also, what's the best way to profile a mixed language program?
17:53:49 <SamB_XP> sorear: "best"?
17:54:04 <monochrom> OK, then I don't know.
17:54:06 <sorear> SamB_XP: any sufficiently good way will do.
17:54:37 <SamB_XP> the only way *I* can think of would involve using gpm for C and the normal GHC profiler for Haskell...
17:54:58 <SamB_XP> or I suppose you could always use cachegrind
17:55:08 <sorear> That's fine *but* how do I know the ratio of C time to haskell time?
17:55:17 <sorear> that's what I want to keep 10 or above
17:55:22 <sorear> then I use gprof
17:55:29 <sorear> btw, gpm is a mouse driver
17:55:38 <SamB_XP> oh yah
17:55:40 <SamB_XP> gprof
17:55:42 <SamB_XP> whatever!
17:56:28 <monochrom> gprof is not an open-source professor.
17:57:02 <SamB_XP> sorear: so cachegrind?
17:57:23 <sorear> er, I didn't know that was a time profiler :)
17:57:52 <SamB_XP> it can do various things
17:58:03 <SamB_XP> maybe I mean callgrind
17:58:06 <SamB_XP> one of those grinds
17:58:45 <SamB_XP> basically, look at the valgrind tool documentation
17:58:53 <ddarius> gprof the C and the ghc generated C.
17:59:18 <SamB_XP> ddarius: that isn't too good for the ratio
18:01:13 <sjanssen> will gprof be able to follow the strangeness of GHC C?
18:01:29 <opqdonut> why not?
18:01:44 <opqdonut> as long as it doesn't longjmp too much
18:01:58 <SamB_XP> well, you'd need to get GHC to pass the option to GCC at least...
18:02:20 <SamB_XP> ... and there is no telling whether the mangler would be able to handle the resulting code or not...
18:02:22 <sorear> opqdonut: all C code needs to be compiled with the same combination of global register variables.
18:02:40 <sjanssen> opqdonut: have you ever tried to run gdb on GHC code?
18:02:49 <opqdonut> no, in fact :)
18:02:53 <sjanssen> it does funny things with the call stack and such
18:03:55 <SamB_XP> anyway, the Simons seem to recommend one of the grind tools for low-level profiling...
18:05:12 <monochrom> the evil mangler and gprof may not play well together
18:05:57 <sjanssen> a recent GHC paper references some pretty fine grained performance measurements (cache misses and time spent in specific types of code), perhaps you could tweak that to measure FFI v. Haskell code?
18:29:51 <dons> http://programming.reddit.com/info/1llta/comments
18:29:51 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
18:29:52 <lambdabot> Title: Thinking in types: introduction to type-directed programming (reddit.com)
18:31:22 <procyon112> @seen chessguy
18:31:23 <lambdabot> I saw chessguy leaving #xmonad, #haskell, #darcs, #haskell-soc and #haskell-overflow 1d 3h 29m 14s ago, and .
18:31:27 <procyon112> @seen chessguy_work
18:31:28 <lambdabot> I saw chessguy_work leaving #haskell, #darcs, #haskell-soc and #haskell-overflow 4d 4h 10m 22s ago, and .
18:32:37 <sorear> hello.
18:40:50 <sorear> @botsnack
18:40:50 <lambdabot> :)
19:03:21 * araujo still trying to explain how the IO data type doesn't break with the purity of code
19:04:32 <monochrom> Whom are you explaining?  Seems like years have gone by.
19:06:02 <monochrom> Make sure you don't complicate things.  This is supposed to be straightforward.
19:07:02 <araujo> monochrom, the thing is, that we have mixed topics here
19:07:06 <araujo> http://araujoluis.blogspot.com/2007/04/haskell-gui-programing.html
19:07:09 <lambdabot> Title: araujo's blog: Haskell for GUI Programing, http://tinyurl.com/yrz4ce
19:07:29 <sorear> araujo: you can think of IO as being impure, if you want.
19:07:42 <sorear> haskell IO is call by name, done right.
19:08:05 * sorear wonders how much would break if he unbound C-h
19:08:20 <araujo> sorear, Nevertheless, being trying to explain, that an IO function doesn't break purity on the language.
19:08:41 <waern> hi araujo :)
19:08:56 <sorear> hi waern
19:08:59 <sorear> :)
19:09:02 <araujo> waern, it's your fault
19:09:05 <araujo> :-)
19:09:35 <monochrom> blog leads to long thread, long thread leads to confusion, confusion leads to the dark side.
19:09:48 <sorear> I probably ought to start a blog.
19:09:53 <sorear> Too many odd ideas.
19:10:14 <sjanssen> araujo: I just read the last comment, not the preceding things.  Have you explained that eg. putChar is pure because it just *constructs* the IO action, but doesn't execute it?
19:10:24 <sorear> Today at school lunch I realized difference lists are related to Cayley's Theorem.
19:10:28 <ddarius> The simplest way nowadays would be to look at the IOSpec type(s) and think of main as passing code into an "IO interpreter", then it is clear how the IO datatype preserves referential transparency.
19:10:34 <waern> haha'
19:10:43 <waern> araujo is explaining to me
19:10:51 <araujo> waern, -> sjanssen
19:10:56 <sjanssen> :)
19:11:00 <araujo> waern, see, if it is just me
19:11:11 <Korollary> A good analogy for IO a is that they are like bash scripts. By themselves they are RT. "main" reads those scripts, binds them together and executes them. That's how IO happens.
19:11:24 <araujo> waern, you have assumed many things on your comment
19:12:00 <waern> araujo, yes, I assumed all GUI apps have some "model" data structure, that was wrong
19:12:12 <kc5tja> araujo: My own piece on monads (although relavent to the state monad directly, the concepts apply generally) might be of some help.
19:12:26 <kc5tja> I'm hardly a monad major of course.  :)
19:12:35 <araujo> :-)
19:12:49 <waern> araujo, but still
19:12:56 <kc5tja> http://www.falvotech.com/content/publications/monads.html if memory serves me correctly.
19:13:00 <kc5tja> (waits for it...)
19:13:12 <waern> araujo, may GUI apps do.. and in that case it's clumsy to use Haskell when you want to update the model
19:13:18 <kc5tja> nothing from Lambdabot -- probably mistyped the URL.
19:13:32 <araujo> waern, why?
19:13:42 <araujo> i really don't get that part
19:13:43 <jcreigh> http://www.falvotech.com/content/publications/monads/
19:13:44 <lambdabot> Title: Haskell Monads: Another View
19:13:52 <kc5tja> http://www.falvotech.com/content/publications/monads/
19:13:52 <lambdabot> Title: Haskell Monads: Another View
19:14:02 <kc5tja> That's sad when you don't even know your own website.
19:14:06 <kc5tja> o_O
19:14:24 <waern> araujo, it's allways more clumsy to update something in a pure language since you need to map a function on the data that updates the things you want to update and act as identity on everything else
19:14:32 <sorear> Obviously, you need to add edit distance to the server!
19:14:54 <waern> araujo: in an imperative language you just poke at the particular part of the structure you want to update
19:14:58 <monochrom> Just to add more noise, I wrote http://www.haskell.org/haskellwiki/A_brief_introduction_to_Haskell#I.2FO  to explain this IO business.
19:15:01 <lambdabot> Title: A brief introduction to Haskell - HaskellWiki, http://tinyurl.com/y6cbnf
19:15:05 <araujo> waern, And from my point of view ... it is good to consider your _whole_ program a function.
19:15:13 <araujo> It isn't something new
19:15:13 <waern> araujo: so it's a little bit more code ins the functional way (okay, not that much)
19:15:46 <araujo> waern, I explained that on the comments :-P
19:16:18 <sorear> waern: you ought to be using a real (read: higher order) functional language.
19:16:21 <kc5tja> All I have to say is, knowing Haskell at the level I do (which is hardly close to being a master) has allowed me to _drastically_ improve the quality of my non-Haskell code (Python, java, etc.)
19:16:35 <sorear> waern: then you can write selector functions that automate the drudgery.
19:16:45 <araujo> waern, it's by far easier to use small functions well connected through ADT and well designed data passing flow. Than to have global/local structures to update in-place.
19:17:18 <araujo> And with well designed data passing flow between them*
19:18:06 <waern> araujo, to store the entier model in the GUI widgets can be good sometimes yes, but sometimes it doesn't work. And it doesn't remove mutable state from your program
19:18:47 <waern> sorear, well yes, but in an imperative language you wouldn't need to write any selector functions :)
19:19:12 <monochrom> Woah?!  I thought the OOP people told me to write getter/setter methods all over the place.
19:19:23 <kc5tja> C version of CUT 2.4 = 437 non-blank lines.  Haskell version of CUT 2.6 (with one new feature) = 242 lines of non-blank, non-comment lines.  Dig it.  :)
19:19:23 <araujo> waern, That's up to gtk2hs.
19:19:40 <waern> monochrom, what does OOP have to do with this?
19:19:48 <waern> we could just as well be talking about c
19:19:58 <monochrom> selector functions. getter/setter methods.
19:20:15 <jcreigh> kc5tja: what? Only 1/2?
19:20:16 <kc5tja> It's all about abstraction.
19:20:37 <monochrom> I guess you're talking about C programming then.
19:20:43 <kc5tja> jcreigh: I am an expert C coder; novice Haskell coder.
19:20:53 <mauke> has anyone written a sml2tex?
19:20:57 <araujo> waern, when i talked about 'no mutable' state, i referred to not explicitly used on my code.
19:21:04 <araujo> I thought that would have been clear
19:21:10 <sorear> mauke: look at 'texifyml'
19:21:23 <waern> araujo: but you explicitly use mutable state in your code when you are updating the models stored in your widgets
19:21:29 <sorear> mauke: I installed it by mistake, and have never used it.  YHBW.
19:21:36 <lispy> kc5tja: do you use Data.ByteString? CUT sounds like some sort of IO intensive program...
19:21:40 <kc5tja> jcreigh: The code I'm working with really can't be reduced any further though, without *severely* impacting readability.  So, I consider a 2:1 improvement damn good.
19:21:51 <kc5tja> lispy: Yes, I use Data.ByteString.
19:21:57 <lispy> kc5tja: yay!
19:22:02 <lispy> kc5tja: so it's probably faster in Haskell+
19:22:04 <lispy> er ?
19:22:09 <kc5tja> However, the CutEmit.hs module still takes many minutes to run on a 7MB source file, because of all the (ByteString) munging that goes on.
19:22:20 <araujo> waern, As i said. That's up to gtk2hs.
19:22:22 <kc5tja> No, the C version utterly decimates the Haskell implementation.
19:22:32 <lispy> kc5tja: have you tried using the lazy version to see if it improves performance?
19:22:38 <kc5tja> lispy: C version can bore through the test source in less than a tenth of a second.
19:22:53 <araujo> waern, I don't see or care of it, as opposed to use an IORef for example.
19:22:54 <kc5tja> The Haskell version takes about a quarter second to parse, and almost 10 minutes to emit the final test runner.
19:23:08 <lispy> kc5tja: okay, well you can do much better than that
19:23:19 <sjanssen> kc5tja: CutEmit creates ByteStrings and prints them?
19:23:42 <araujo> waern, Or as one of your example in the blog comments.
19:23:44 <kc5tja> lispy: The back-end is written 100% functionally, so I don't expect it to be high performance.
19:24:02 <lispy> kc5tja: ah, you are a novice haskeller ;)
19:24:03 <waern> araujo: of course you see it. if you update a widget with some data, then read it, it is exactly like using an IORef
19:24:08 <sjanssen> kc5tja: if you use cons or append to create your ByteStrings you're going to have terrible performance
19:24:08 <kc5tja> It builds the entire test runner in memory, then prints the whole test runner in one fell swoop.
19:24:28 <lispy> that certainly sounds like a job for laziness...
19:24:38 <kc5tja> sjanssen: Funny, dons suggests using cons is the _fastest_ way to use them.
19:24:44 <kc5tja> But, I do perform many appends.
19:24:50 <kc5tja> and concats.
19:25:01 <kc5tja> lispy: It has nothing to do with laziness.
19:25:30 <sorear> kc5tja: eh?
19:25:31 <kc5tja> At some point, the test runner has to be printed, so all the parts have to be computed anyway.
19:25:38 <sorear> kc5tja: laziness is all about streaming
19:25:50 <araujo> waern, That's up to gtk2hs. Not of my code.
19:25:54 <sjanssen> kc5tja: strict ByteStrings?
19:25:57 <kc5tja> Yes, which just adds overhead since every byte of the test runner needs to be emitted.
19:26:00 <sorear> kc5tja: laziness causes the rest to be *delayed*, even if it is all demanded!
19:26:05 <kc5tja> It's better to cons strict bytestrings instead.
19:26:07 <kc5tja> MUCH faster.
19:26:25 <kc5tja> Switching to consing strict bytestrings in the parser improved its performance by almost a factor of 10.
19:26:27 <sorear> kc5tja: constant space kicks fast time's ***
19:26:30 <araujo> waern, Which still, keeps the code pure.
19:26:38 <sjanssen> kc5tja: creating a ByteString of length n is O(n^2)
19:26:44 <sorear> kc5tja: laziness gives you constant space
19:26:53 <waern> hehe
19:26:54 <sorear> kc5tja: don't you want that?
19:26:58 <waern> okay, this is getting silly now
19:26:59 <sjanssen> kc5tja: huh?  Why would you cons in a parser?
19:27:04 <kc5tja> sorear: I have 600MB on my box.  Constant space isn't an issue.
19:27:08 <kc5tja> User response time is key.
19:27:12 <waern> araujo: let's just agree that we disagree? :)
19:27:13 <mauke> waern: purity is all about cheating
19:27:14 <dons> kc5tja: so lists of strict bytestrings?
19:27:20 <sorear> kc5tja: now tell me you have 600MB of L1 cache.
19:27:22 <kc5tja> sjanssen: Uhh...to build a list of things?  :)
19:27:27 <waern> mauke: no
19:27:30 <sorear> kc5tja: constant space is a big deal!
19:27:36 <araujo> waern, Or to see if i can explain myself better, i myself didn't explicitly include a mutable variable in my _code_
19:27:37 <kc5tja> sorear: Depends.
19:27:46 <araujo> waern, fine with me :-P
19:27:53 <kc5tja> sorear: I'm not expecting people to run this on a Commodore 64.
19:27:58 <sorear> dons: see #haskell-overflow message
19:28:00 <kc5tja> (though it'd be nifty to see)
19:28:18 <kc5tja> dons: I have not optimized the emitter.
19:28:28 <kc5tja> Well, at least I don't recall optimizing it.  Maybe you did.
19:28:31 <sorear> kc5tja: a pentium is fastest with programs that are small enough to run on a C64
19:28:41 <sorear> kc5tja: cache miss = 100's of cycles
19:28:58 <kc5tja> sorear: On DOS, yes.
19:29:12 <kc5tja> sorear: Remember that Linux and Windows multitask, causing cache flushes all over hell and creation.
19:29:17 <kc5tja> Paging has MUCH bigger impact.
19:29:38 <sorear> kc5tja: Linux only multitasks when you have multiple runnable tasks.
19:29:44 <kc5tja> sorear: Nope.
19:29:45 <kc5tja> check again.
19:30:01 <sorear> kc5tja: the kernel runs in the process's address space!
19:30:04 <kc5tja> The kernel has, at any given time, at least 8 Kernel threads that it runs, and the user space in any Linux environment has at least 20 background processes.
19:30:12 <kc5tja> sorear: which flushes the cache when needed!
19:30:21 <lispy> kc5tja: purely functional in haskell doesn't have to mean poor performance and laziness is good. YMMV (and always remember ghc has a good profiler)
19:30:26 <kc5tja> The chip's cache doesn't have distinct kenrel and user space caches.
19:30:41 <sorear> kc5tja: if you actually bothered to run ps, you would have noticed those programs are almost all not running at any given time.
19:30:56 <lispy> kc5tja: that's all i really wanted to impart...
19:31:02 <kc5tja> sorear: at the time top runs, sure.  But you can't trust top because it polls only once every few seconds.
19:31:10 <kc5tja> Most processes take events, do their thing, then go to sleep again.
19:31:45 <sorear> I can trust the event counters though. the kernel never misses scheduling a program!
19:31:49 <araujo> waern, i nevertheless will nuke your last comment :-)
19:32:22 <lispy> kc5tja: and if you don't believe me about IO and emiting tons of data lazily...take a look at how darcs parses/writes patches
19:32:47 <mauke> sorear: where can I get texify?
19:32:49 <lispy> kc5tja: it's all lazy and i challenge you to find a faster way for it to work (strict or no)
19:32:49 <kc5tja> Look, I'm not going to argue OS architecture and its impact on applications.  The fact is, cache misses, while expensive, aren't nearly as expensive as TLB hits, and the fact is also that running programs in other address spaces -will- cause cache flushes to occur as the hardware decides is necessary.
19:32:50 <sorear> kc5tja: Try an experiment - run a haskell program with +RTS -A100M
19:33:17 <kc5tja> lispy: I can't read Darcs' source code.
19:33:22 <sorear> kc5tja: if you are right and cache performance doesn't matter, that flag will have no effect - even though it negates all of the GC SM's cache tuning
19:33:32 <kc5tja> I DO know that it slurps its input in its entirety into RAM though.
19:33:33 <lispy> kc5tja: keep practicing your haskell then.  You will get there.
19:33:57 <lispy> kc5tja: that's an over simplification, but yes
19:34:11 <lispy> (it matters how you define "input")
19:35:26 <waern> araujo: have you looked at functional reactive guis? when you use those it is more propriate to say you have removed mutable state from your gui app, but using gtk2hs and setting/reading values from the widgets in the IO monad explicitly normally count as using mutable
19:35:38 <waern> +state
19:35:46 * lispy heads home
19:35:56 <kc5tja> I don't even know what those options do, so I can't be objective in deciding whether or not it'll have any impact.
19:35:59 <kc5tja> But I'm trying it anyway.
19:36:06 <kc5tja> +RTS -A100M -RTS ...options...
19:36:14 <araujo> waern, i stated since the beginning i use gtk2hs
19:36:30 <araujo> waern, my comments were directed to the code i wrote.
19:36:39 * sorear reads the scrollback
19:36:54 * sorear decides he needs to stay away from #haskell for a few minutes :(
19:37:01 <araujo> waern, As opposed to all the gtk2hs code that explicitly includes mutable state references.
19:37:14 <araujo> sorear, join the party
19:39:03 <kc5tja> I think it's because he's getting upset at my headbutting him here.
19:39:31 <kc5tja> But, I'm willing to play out his experiment, because we'll both learn something from it.
19:40:09 <kc5tja> The fact is, though, that I build CutEmit functionally because, well, Haskell is functional.  I rather _like_ thinking functionally.
19:40:29 <kc5tja> If I wanted to code imperatively, I would have littered the code with IO monadic functions.  I didn't want to do that.
19:41:07 <araujo> Today is the day of headbutting it seems
19:41:07 <kc5tja> And, I did, at one point, use lazy ByteStrings in the past (as dons will recall), and it actually made the program _slower_.  Why?  Because it thunked everything instead of just slurped data.
19:41:18 <kc5tja> Well, I like to think I'm not being offensive.
19:41:22 <araujo> waern, isn't it? ;-)
19:41:26 <kc5tja> I certainly haven't had need to raise my voice.
19:41:40 <kc5tja> But, I'm not going to budge on something I know to be true.
19:42:13 <kc5tja> ./Main +RTS -A100M -RTS src1.c  150.81s user 4.07s system 84% cpu 3:03.60 total
19:42:28 <kc5tja> Trying it without +RTS et. al.
19:42:42 <sorear> kc5tja: no, I'm pretty sure it was me attacking you.
19:43:09 <kc5tja> Bahh -- I wasn't taking it as attacks.
19:43:21 <kc5tja> But, then again, that's probably why I was the highschool punching bag while I was growing up.
19:43:39 <kc5tja> It takes a lot for me to get "agro'ed" enough to fight back.
19:43:43 <kc5tja> Either that, or a really pissy day.  :)
19:44:21 <sorear> ah good...
19:44:42 <sorear> I do so love it when people get into a positive feedback loop of emotion
19:45:16 <kc5tja> I suppose I can remove the code to print out the parse tree now...
19:45:38 <kc5tja> That adds about 10 seconds or so.
19:47:20 <kc5tja> ./Main src1.c  182.61s user 2.09s system 83% cpu 3:39.98 total
19:47:36 <araujo> sorear, haha
19:48:00 <kc5tja> Does -A set the initial heap size for the Haskell virtual machine/runtime environment?
19:48:56 <sorear> It sets the size of the allocation area (aka nursery, generation 0)
19:49:23 <kc5tja> Ahh
19:49:29 <davidL> is it feasible to use darcs to manage a website?
19:49:36 <sorear> davidL: it's been done
19:49:52 <kc5tja> davidL: I personally use it to manage my own website of about 160MB or so.  As long as you keep your changes small between updates, it's quite doable.
19:50:28 <davidL> are there other alternatives?
19:51:43 <davidL> the only other solution I can think of is creating your own web framework to help you with managing
19:51:54 <kc5tja> Well, what exactly are you trying to do?
19:52:03 <kc5tja> Darcs is hardly a CMS, for example.  :)
19:52:07 <chessguy> hi all
19:52:14 <davidL> I just want to keep pages up to date
19:52:16 <monochrom> I use the linux ext3 file system to manage my website.
19:52:44 <kc5tja> That's content management more than file management.
19:52:57 <kc5tja> You'd be better to use a wiki, CMS, or blogging system for that purpose.
19:53:14 <davidL> well I add pages more than I update existing ones
19:53:16 <kc5tja> Darcs excels when your site tends to get hacked often (as mine used to), and you need to easily restore from known-good checkpoints.
19:53:28 <chessguy> procyon112: ping
19:54:01 <monochrom> I just wanted add my data point. :)
19:54:13 <kc5tja> Oh dear, I did +RTS -A250M -M500M -RTS ...options... and it's REALLY loading my box down.  :)
19:54:20 <monochrom> For content management I use vim and emacs.
19:54:31 <monochrom> Hmm what is -M?
19:54:40 <kc5tja> Sets maximum heap size.
19:54:51 <kc5tja> It's probably spending half its time garbage collecting.
19:55:11 <monochrom> How much heap do you use?  Way more than 500M?
19:55:22 <kc5tja> Not sure, to be honest.
19:55:30 <kc5tja> I think the last time I ran top it reported about 200MB.
19:55:43 <davidL> does it make sense to have a local repo of a website, perform changes there, and then push those changes to the webserver? or would that be acomplished better through FTP?
19:55:49 <kc5tja> remember that that also includes all the linked libraries too (the value returned by top tends to over-exaggerate).
19:55:57 <kc5tja> davidL: That's what I do.
19:56:09 <kc5tja> I use darcs locally.
19:56:27 <clanehin> davidL: I find darcs much easier to maintain my site than ftp
19:56:30 <kc5tja> Then I use rsync to transfer data to the main web server (since my hosting provider doesn't have darcs on his server)
19:56:46 <kc5tja> But if he had darcs installed, I'd definitely perform darcs pushes.
19:57:07 <davidL> I'm just surprised that not more people use darcs for things like this
19:58:12 <sproingie> i use mercurial to update a couple intranet sites.  same idea
19:58:57 <procyon112> hey chessguy
19:59:08 <chessguy> yo! how's code?
19:59:48 <procyon112> chessguy:  Good.  I rewrote my unifier.. it's much faster and copiously commented now.. I think I actually have the hang of this unification thing.
19:59:54 <kc5tja> Oh dear, it looks like top was really lying to me.
19:59:58 <chessguy> sweet!
20:00:01 <kc5tja> This run is truely using 500MB of RAM!
20:00:31 <procyon112> chessguy: I'm now writing a cute little parser so that library users can define types as strings
20:00:54 <chessguy> types as strings?
20:02:03 <procyon112> chessguy: like "(Int->a)->b" will parse to: ((TCon "Int") :-> (TVar 0)) :-> (TVar 1)
20:02:27 <procyon112> chessguy: That will make it *much* easier for a user to type their primitives.
20:02:38 <chessguy> fair enough
20:03:06 <procyon112> So, I'm making progress... Not as much as I'd like, but works keeping me busy.
20:03:40 * kc5tja would like to make a functional language for his Kestrel system at some point.
20:03:45 <procyon112> I Did, however have a total brainstorm today... I'm playing with it in my head.
20:04:00 <kc5tja> I really like Haskell, but I really do not think it'd run on a 10MHz box with 16MB of RAM available.
20:04:08 <kc5tja> At least, not well.
20:04:14 <chessguy> oh?
20:04:56 <kc5tja> I was looking at Scheme, but that runs the risk of attracting the wrong crowd of users to the platform (namely, all the irrational Lisp bigots).  :)
20:05:09 <cdsmith> @pl \ f x y -> if x == y then True else f x y
20:05:10 <lambdabot> ap (ap . flip flip True . (if' .) . (==))
20:05:10 <procyon112> chessguy: Imagine we made the Data.Tree a backtracking monad
20:05:17 <sorear> kc5tja: top shows both RSS and VIRT
20:05:18 <cdsmith> wow!
20:05:28 <chessguy> mmm, o
20:05:30 <chessguy> k
20:05:33 <kc5tja> 1107M virt, 530M rss.
20:05:41 <sorear> kc5tja: RSS is the amount actually being used - this will obviously never exceed your RAM
20:05:49 <sorear> kc5tja: VIRT is the amount allocated
20:05:54 <procyon112> chessguy: And the program generators were Data.Tree's
20:05:56 <sorear> so that program is swapping hard
20:06:04 <mauke> @pl \f x y -> x == y || f x y
20:06:05 <lambdabot> ap (ap . ((||) .) . (==))
20:06:05 <kc5tja> Yeah, I noticed.  :)
20:06:23 <kc5tja> Although, it's not actively swapping right now.  It seems to swap in bursts.
20:06:58 <procyon112> chessguy: And each node of the trees had a lazy list of children, which were the programs that hadn't been generated yet.
20:07:00 <cdsmith> mauke: thanks, but I think I still prefer the point-full here.
20:07:11 <sorear> there is another magic number, the working set size - which is the amount of memory actively being used.  too bad top doesn't show it.
20:07:37 <mauke> @pl \x y -> x == y || f x y
20:07:37 <lambdabot> ap (ap . ((||) .) . (==)) f
20:07:51 <procyon112> Now, each individual in the population is a node in the tree.
20:08:28 <procyon112> and mutation is just traversing a node, and crossover is jumping to a different part of the tree.
20:08:46 <chessguy> hmmm
20:09:29 <procyon112> And the genetic algorithm is kind of a weird backtracking monad in that it traverses it's graph kind of randomly
20:09:55 <chessguy> heh
20:10:33 <chessguy> does make you wonder about more intelligent kinds of program-space searching]
20:10:54 <procyon112> Which is really interesting... because it *VERY* clearly shows how GP is traversing the search space... and with just a tweak, you can alpha-beta search, or exhaustive search the tree for comparison...
20:11:21 <chessguy> mm, i don't think you want to AB-search that tree
20:11:27 <procyon112> EXACTLY.. by making it a monad, it opens up all kind of intuitive ways to make the search better
20:11:38 <chessguy> minimax doesn't make much sense in that space
20:12:26 <procyon112> Why not?  there are only n children of each node, where n is the number of [well typed] primitives
20:13:26 <chessguy> the structure is fine, but what does it mean to do adversarial search? i.e., you're trying to find a global maximum, not the maximum given that every other level is trying to find the minimum
20:13:36 <procyon112> So guided searches, even exhaustive ones for a small number of depths make sense
20:14:03 <chessguy> yes, but guided search is not necessarily the same as adversarial search
20:14:05 <procyon112> right.. maybe alpha-beta isn't the right term :)
20:14:37 <chessguy> anyway, the idea is fascinating
20:14:58 <sorear> kc5tja: how about Standard ML?
20:15:01 <chessguy> so you have a tree where every node is a program
20:15:10 <procyon112> Now, you can't really backtrack the whole thing, because your memory requirements would explode.
20:15:23 <sorear> kc5tja: it's a lot like haskell, but it doesn't make it as easy to shoot yourself in the foot with memory leaks
20:15:25 <hpaste>  cdsmith pasted "Function closures" at http://hpaste.org/1602
20:15:49 <procyon112> chessguy: Not yet.. right now I have an infinite list where every element is a program.. but I could turn that into a tree.
20:15:51 <kc5tja> I looked at SML, and it seemed like it'd be pretty hard to compile.
20:16:05 <sorear> kc5tja: harder than haskell?
20:16:07 <chessguy> well, that's what i meant, that's your idea
20:16:35 <kc5tja> Well, OK, perhaps not as hard as Haskell, but it certainly looked like it'd be more than I could chew.
20:17:01 <kc5tja> You generally don't hear about people writing SML compilers in a week, for example.  :)
20:17:29 <procyon112> chessguy: yup... and because you have a lazy tree, *ALL* possible programs are in that tree.. which really solidifies (for me) how the GP is actually doing it's search, and possible ways to optimize searching.
20:18:31 <sorear> kc5tja: if you only have one week I definitely recommend a member of the Greater Lisp Family.  SK interpreters can be fit in 100 bytes easily.  Also take a good look at BitC!
20:18:32 <procyon112> chessguy: It gives you a new operation.. instead of just crossover and mutation, you have guided search added to your list of tools.
20:19:43 <kc5tja> sorear: Well, it's not that I have a week deadline.  It's just that my personal bandwidth is quite limited.  I note that I still haven't finished the Kestrel's firmware, and I wonder if I'll ever be able to complete it.
20:20:21 <chessguy> yes
20:20:36 <sorear> kc5tja: how inclusive is the firmware?
20:20:44 <kc5tja> sorear: Are you referring to this?  ingush.berkeley.edu:7012/BITC.html
20:20:46 <chessguy> it's still not really clear how to perform the guided search though
20:20:52 <kc5tja> sorear: It's a Forth implementation.
20:20:55 <chessguy> i wonder if some kind of ant algorithm would work
20:21:06 <procyon112> chessguy: So you can do something like: Evolve through 30 generations, find the fittest individual, then, check his children, if there are any fitter ones, check their children, if not, return the individual... A nice, low processing power way to see if there are any trivial mutations on the fittest individual before returning.
20:21:17 <kc5tja> It emulates a text-mode display (done) and has super, super, super basic keyboard input capability.
20:21:20 <kc5tja> Forth primitives are coded.
20:21:24 <kc5tja> But that's where it's stopped.
20:21:32 <kc5tja> Currently written entirely in assembly language.
20:21:51 <kc5tja> However, the more I write, the more I need to refer back to see how I did things, and I can't keep everything in my head at once.
20:23:21 <kc5tja> 20,729,818,488 bytes allocated in the heap
20:23:21 <kc5tja> 447,260,264 bytes copied during GC (scavenged) 55,095,620 bytes copied during GC (not scavenged)  33,397,384 bytes maximum residency (1061 sample(s))
20:23:25 <kc5tja> Yikes!!
20:23:34 <mgsloan> procyon112 - crossover tends to work in GAs.  What're you using for your individual genetic data?
20:23:40 <kc5tja> Just goes to show you how memory hungry CutEmit currently is.  :D
20:23:59 <procyon112> mgsloan: Data.Tree
20:24:06 <mgsloan> oh, heh :)
20:24:14 <mgsloan> what're you sticking in the tree?
20:24:18 <kc5tja> brb
20:24:28 <sorear> kc5tja: http://www.bitc-lang.org/
20:24:30 <lambdabot> Title: The BitC Programming Language
20:24:38 <procyon112> Functions for Koza Style GP
20:25:19 <mgsloan> ah, sweet
20:25:35 <chessguy> mgsloan: we're discussing a general library for GP, and other search strategies
20:25:53 <mgsloan> sounds fun
20:26:00 <sorear> kc5tja: basically it is ML typing, C semantics, Lisp syntax
20:26:37 <nornagon> sorear: looks pretty schemey
20:26:41 <mgsloan> chessguy - ah, sounds fun
20:26:42 <nornagon> oh
20:26:46 <nornagon> nm :)
20:27:23 <procyon112> Crossover isn't as good in GP as it is in GA, which gives another interesting possibility... With the seach space specifically defined as a tree, we can use a branch trimming traversal, and do a guided search down the tree, with *NO* retesting of individuals.. that might actually be way superior to standard GP for efficiency.
20:28:21 <procyon112> All sorts of cool ideas emerge when you think of GP as a monad :)
20:29:10 <chessguy> procyon112: i don't know a whole lot about backtracking monads, any suggestions what to look at?
20:29:25 <procyon112> chessguy: look at list.. it's the simplest.
20:29:58 <chessguy> ?go everything monad 15 minutes
20:30:02 <lambdabot> http://www.randomhacks.net/articles/2007/03/12/monads-in-15-minutes
20:30:02 <lambdabot> Title: Monads in 15 minutes: Backtracking and Maybe
20:30:03 <chessguy> like this?
20:30:15 <procyon112> yeah
20:30:39 <chessguy> ok, i'll go over that again
20:30:58 <mgsloan> procyon - ah, yeah, i haven't done much with GP specifically.  The most was a bytecode which worked reasonably no matter the data
20:31:21 <encryptio> > 1,2
20:31:22 <lambdabot>  Parse error
20:32:56 <kc5tja> sorear: Hmm...I'm not so sure that this is all that easy to compile either.
20:33:38 <mwc> Is there something in the std libraries that implements a map with efficient lookup from either side?
20:34:06 <mwc> My thoughts is to maintain a pair of (Map a b,Map b a) and then coordinate insertions on each one
20:34:11 <mwc> but there must be something better
20:35:31 <chessguy> mwc: hmm, maybe something with Data.Sequence?
20:35:38 <chessguy> ?docs Data.Sequence
20:35:39 <lambdabot> Data.Sequence not available
20:35:45 * chessguy kicks the bot
20:36:09 <chessguy> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Sequence.html
20:36:12 <lambdabot> http://tinyurl.com/yz86s7
20:36:30 <chessguy> that gives you O(1) access to both ens
20:36:34 <chessguy> ends
20:36:51 <mwc> yeah, I need something more like a relational database over (a,b) ;P
20:37:14 <chessguy> ohhh, i misunderstood, sorry
20:37:34 <mwc> yeah, I was pretty vague with that "other side" business
20:38:39 <monochrom> A relational database does it with Map a (a,b) and M b (a,b).
20:38:54 <monochrom> Where M = Map.  Typo.
20:39:08 <mwc> indeed, so a pair of maps would do it
20:39:28 <mwc> monochrom, but if I'm looking up using a as the key, I don't need it in the value
20:40:13 <monochrom> A relational database first stores the table and then adds indexing to as many columns as you ask.
20:40:44 <chessguy> bedtime here. 'night all
20:42:10 <monochrom> If you have five columns, you will see more sharing if you do it as Map a_i (a_0, a_1, a_2,a_3,a_4).
20:42:30 <mwc> monochrom, true
20:42:30 <monochrom> But I am in no way dictating.
20:43:25 <monochrom> Also a relational database is mutable.  There are dire consequences if they don't maximize sharing. :)
20:43:57 <mwc> I wondered if there was a 2-ple set with efficient lookup in the std libs, but I just didn't know what it was called.
20:44:22 <monochrom> the std libs doesn't have one yet.  (bless English :) )
20:46:48 <procyon112> ACK!  Haskell programming is killing my C++ programming.  I forget to run my C++ code with every iteration, I just compile and think "It type checked, it must be good."  Then, I end up writing too much code, the thing segfaults, and now I have to search through tons of new code to find my error :(
20:48:13 <dons> hehe
20:48:38 <dons> s/hehe/horrible/
20:49:31 <monochrom> s/horrible/hehe/
20:49:31 * monochrom is sinister!
20:49:47 <mwc> Oh crap, (M.Map a (a,b),M.Map b (a,b)) won't work... how do I insert (0.5,1),(0.5,0.5)?!
20:50:25 <monochrom> Why are there two tuples?
20:51:00 <monochrom> Can I just insert (0.5, 1) first?
20:51:03 <dons> mwc, what's the key and value types?
20:51:11 <mwc> monochrom, one's an Int, the other is arbitrary
20:51:26 <monochrom> fromIntegral 1 ?
20:52:01 <monochrom> yeah, a=?  b=?
20:53:55 <mwc> so I can use IntMap for half
20:54:04 <monochrom> This example uses a=Bool, b=Char.  let x=(True, 'w') in (insert (fst x) x empty, insert (snd x) x empty)
20:54:21 <sorear> mwc: Try not to think about IntMap.
20:54:28 <sorear> IntMap shouldn't exist.
20:54:43 <sorear> Alas, we don't have a good way to specialize data structures :(
20:55:04 <monochrom> In general insert (b,c) into (m,n):  let x=(b,c) in (insert (fst x) x m, insert (snd x) x n)
20:57:02 <monochrom> If one of the columns is Int, yes you can use IntMap.  let x=(5, 'w') in (IntMap.insert (fst x) x m, Map.insert (snd x) x n)
20:57:53 <monochrom> You can also say, you prefer (IntMap Char, Map Char Int).  The possibilities are endless.
20:58:31 <monochrom> Bottomline: Don't panic, invoke inference engine, do unification and resolution and substutition.
21:27:55 <petekaz> Re: all of my lazy/strict questions last night, this page is VERY helpful: http://en.wikibooks.org/wiki/Haskell/Laziness
21:28:10 <petekaz> But I have a question (stop the sighing!)
21:28:26 * sorear sighs
21:28:33 <sorear> :)
21:28:42 <petekaz> the question is about the 'lazier head' example on the page.
21:28:57 <petekaz> and using irrefutable patterns.
21:29:05 <sorear> petekaz: it's bogus - head is already as lazy as it can be
21:29:27 <petekaz> the question in the exercise .. what's the reason.
21:29:48 <petekaz> sorear: I understand, the example is only illustrating that its pointless.
21:29:54 <petekaz> and would never work.
21:30:10 <sorear> petekaz: I'm pretty sure the excersize is wrong.
21:30:26 <sorear> petekaz: switching the order of the equations WILL give you a working head
21:30:42 <petekaz> ok, that makes sense to me then.
21:30:47 <sorear> petekaz: it won't be any lazier than the standard head though
21:30:53 <kc5tja> Sweet.  I destroyed Firefox.  Again.
21:30:56 <petekaz> I understand.
21:31:38 <petekaz> Thanks.  Was just curious about the reason why the same undefinde result would occur even with a different order, but you have clarified.  Thanks.
21:33:52 <petekaz> sorear: I just tried in ghci, looks like it still returns undefined.
21:34:03 <petekaz> versus the first element of the list.
21:34:03 <sorear> petekaz: what did you type?
21:34:31 <sorear> > let { head' ~(x:xs) = x; head' ~[] = undefined } in head' "abc"
21:34:33 <lambdabot>      Warning: Pattern match(es) are overlapped
21:34:33 <lambdabot>              In the definition...
21:34:38 <petekaz> let head' ~(x:xs) = x; head' ~[] = undefined in head' [1,2]
21:34:51 <petekaz> I guess I did that wrong then.
21:34:55 <sorear> petekaz: that should have worked!
21:35:16 <petekaz> > let head' ~(x:xs) = x; head' ~[] = undefined in head' [1,2]
21:35:17 <lambdabot>      Warning: Pattern match(es) are overlapped
21:35:17 <lambdabot>              In the definition...
21:35:22 <sorear> petekaz: it will give a warning, but that's only because it is pointless
21:35:36 <sorear> you can shut up ghci by deleting the second eq
21:35:41 <sorear> > let { head' ~(x:xs) = x } in head' "abc"
21:35:42 <lambdabot>  'a'
21:36:01 <petekaz> > let head' ~[] = undefined; head' ~(x:xs) = x in head' [1,2]
21:36:02 <lambdabot>      Warning: Pattern match(es) are overlapped
21:36:03 <lambdabot>              In the definition...
21:36:15 <sorear> note that this does NOT make head any lazier, because evaluating head lst forces the list (why?)
21:37:19 <petekaz> wait ... I'm confused.  No matter which order the statements are in, I get the same result, undefinde.  How does ghc pick one lazy pattern to match over the other?
21:37:35 <monochrom> The first one is picked.
21:38:20 <petekaz> let me ditch ghci, and compile a test.  I think ghci is confusing me
21:39:00 <sorear> petekaz: exactly what are you typing?
21:40:26 <petekaz> I compiled it in ghc and got the result I expected.  Different results which is as you said correct.  The exercise seems to imply otherwise or is just not worded correctly.
21:41:31 <monochrom> Since it's wikibook perhaps I should go investigate it.
21:41:37 <petekaz> Oh .. I mispelled undefined.
21:41:48 <petekaz> doh!
21:42:01 <monochrom> But if anyone of you do it before me, even better!
21:43:45 <petekaz> I think I misinterpreted the question.  It says "Why won't changing the order of the equations to head' help here?"  I thought it intended to imply that the same result is returned no matter the order.
21:44:00 <petekaz> Which is probably not the correct interpretation.
21:44:46 <petekaz> Because if the statements are reversed, then you still have a runtime error with a bogus pattern match.
21:45:05 <petekaz> So my mistake.
21:46:22 <sorear> petekaz: even w/o ~ you have a runtime error!
21:48:48 <petekaz> right, but not from a pattern match error.
21:48:58 <petekaz> correct?
21:49:48 <petekaz> (I can never tell in Haskell when someone is pointing out a subtlety or just busting my chops)
21:50:28 * SamB_XP would use the pain sensations emenating from his jaw to distinguish the two
21:50:49 <mauke> lazily evaluated pain
21:50:58 <monochrom> haha great
22:04:54 <sorear> petekaz: _|_ is _|_.  All runtime errors are exactly equivalent.
22:05:23 <jcreigh> some runtime errors are more equivalent than others. :)
22:05:30 <sorear> petekaz: haskell implementations are not required to distinguish error "foo!" from pattern match failure from nontermination
22:05:44 <mauke> wow, that sounds like ploki
22:05:55 <monochrom> @remember jcreigh some runtime errors are more equivalent than others. :)
22:05:56 <sorear> jcreigh: eh?  (I know the allusion, I just want to know what your more equal errors are)
22:05:56 <lambdabot> Done.
22:06:19 <monochrom> some errors can be caught, some others not.
22:06:34 <sorear> monochrom: _|_ can never be caught.
22:06:48 <monochrom> I'm referring to:
22:06:50 <sorear> monochrom: petekaz is learning Haskell, not GHC :)
22:06:58 <monochrom> ?hoogle catch
22:06:59 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
22:06:59 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
22:06:59 <lambdabot> GHC.ConsoleHandler.Catch :: (ConsoleEvent -> IO ()) -> Handler
22:07:17 <jcreigh> sorear: well, mostly I was just going for the Orwell reference, but, eg, domain-specific error messages that mean something are a lot more fun than "fromJust: Nothing"
22:07:32 * monochrom dodges the issue with "hierarachical library"
22:07:32 <sorear> yo!
22:07:42 * jcreigh has sworn off fromJust except where it's really obviously okay.
22:07:54 <sorear> Control.Exception.catch isn't even a valid lexeme!
22:07:55 <sorear> :)
22:08:13 <monochrom> You win
22:08:28 <mauke> heh, there are no haskell parsers anyway :-)
22:08:32 <sorear> If you're gonna put it like that...
22:08:35 * sorear sobs
22:08:38 <sorear> :)
22:12:05 <shwag> why is haskell so popular ?
22:12:22 <kaol> why is it not even more popular?
22:12:46 <sorear> It ought to be less popular.
22:13:22 <dons> shwag: unique set of features, good academic backing, good community
22:14:03 <Korollary> I dont think it's popular.
22:14:16 <dons> its more popular than it used to be.
22:14:23 <Korollary> true
22:14:41 <dons> it's close to being the canonical FP reference now, I'd say.
22:15:06 <Korollary> that was the original intention, yes?
22:15:45 <dons> well, to be the canoncail lazy FP lang, but I think its taken over a lot of the mindshare of lisp and scheme. FP often means pure, typed FP.
22:15:58 <dons> which is nice.
22:16:42 <dons> mainly, haskell is interesting. which attracts interest.
22:18:04 <shwag> dons: i just heard of it. Where can I get an idea about it ?
22:19:00 <sorear> haskell.org?
22:19:37 <sorear> there's also the haskell tutorial wikibook, might have a few good examples
22:19:52 <dons> shwag: yeah, haskell.org is the central place for all haskell material
22:20:01 <sorear> > nubBy(((>1).).gcd)[2..]  -- 1 line demonstation of haskell's dual powers
22:20:03 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
22:20:06 <dons> shwag: and hang out here, that's useful too
22:20:23 <shwag> so many languages to choose fro
22:20:24 <dons> shwag: how did you hear about it?
22:20:29 <sorear> most haskell code is slightly more readable :)
22:20:39 <shwag> dons: did a channel list and saw there were a lot of people here.
22:20:56 <dons> shwag: there's not that many interesting languages though. there's about 7 languages that represent each programming style
22:20:57 <shwag> can haskell be used for web programming? Does it have a framework ?
22:21:03 <dons> learn those 7 and you know all of them :-)
22:21:06 <sorear> yeah
22:21:09 <sorear> #happs
22:21:12 <dons> shwag: yeah, happs and wash.
22:21:27 <sorear> happs even has a channel!
22:21:50 * bos is using a mac for irc for the first time in ages
22:22:08 <shwag> dons: I was surprised there were so many people in here, because I dont even see it on this list.  http://www.tiobe.com/tpci.htm
22:22:10 <lambdabot> Title: TPCI - TIOBE Programming Community Index
22:22:25 <bos> the tiobe list is a bit bogus
22:22:28 <dons> hehe. you know how tiobe is calculated? :-)
22:22:42 <sorear> I suspect most people on the top ten of that list are too dumb to operate an IRC client.
22:22:51 <Korollary> well, nobody is arguing that haskell is popular no matter how wrong TIOBE may be.
22:22:52 <dons> search for "$foo programming" on google, and then rank the reported hits.
22:23:07 <Korollary> However, there's no point in idling in C++ or Java. Inherently boring languages.
22:23:23 <dons> interestingly, hakell's tiobe ranking would be greatly improved if they searched for "programming $foo"
22:23:36 <sorear> you might also want to take a look at planet.haskell.org, shwag
22:23:38 <shwag> i started programming in php. tired ruby, then moved to python.
22:23:57 <sorear> haskell takes a bit of adjustment, some people say.
22:24:01 <shwag> sorear: cool, thanks
22:24:03 <sorear> I never noticed this
22:24:18 <narain> huh. tiobe claims that ada is a popular programming language??
22:24:21 <dons> shwag: ok. that's a good path though. python is probably the most appropriate imperative language to use before moving to haskell
22:24:38 <dons> narain: so that means "ada programming" returns more hits.
22:24:58 <dons> what i find funny is that "xmonad" returns 2k hits, and "haskell programming' is about 40k
22:25:07 <dons> so the whole TIOBE methodology is suspect...
22:25:16 <dons> xmonad returns 62k hits
22:25:43 <dons> Results 1 - 10 of about 61,700 for xmonad.
22:25:52 <dolio> Wow, Haskell just barely beats APL, eh?
22:25:52 <Korollary> of course it is. The more important question is whether they measure the popularity of languages like C# or Perl let alone known unpopular languages like Haskell.
22:25:54 <dons> Results 1 - 10 of about 40,800 for "haskell programming"
22:25:55 <dolio> :)
22:26:03 <sorear> google's hit counts are notoriously bogus.
22:26:07 <dons> Results 1 - 10 of about 1,430,000 for haskell programming
22:26:24 <dons> Results 1 - 10 of about 54,600 for "programming haskell"
22:26:38 <dons> Results 1 - 10 of about 1,400,000 for programming haskell
22:26:41 <sorear> shwag: so, look at the wikibook, gentle introduction, or report
22:26:52 <dons> so yeah, TIOBE is a bit suspect.
22:26:59 <sorear> shwag: whichever is most comprehensible
22:27:10 <sorear> http://www.haskell.org/onlinereport
22:27:12 <lambdabot> Title: The Haskell 98 Language Report
22:27:14 <sorear> @where wiibook
22:27:15 <lambdabot> I know nothing about wiibook.
22:27:18 <sorear> @where wikibook
22:27:19 <lambdabot> http://en.wikibooks.org/wiki/Haskell
22:27:32 <sorear> @goog Gentle introduction haskell
22:27:34 <lambdabot> http://www.haskell.org/tutorial/
22:27:34 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
22:27:44 <Korollary> Hah. Version 98.
22:27:54 <sorear> I'm told the wikibook is the gentlest of the three.
22:28:05 <Korollary> The wikibook is good.
22:28:08 <narain> yes, the wikibook is great
22:28:18 <narain> though some advanced chapters are incomplete
22:28:21 <sorear> but if you've got a mind for mathsy learning, going straight to the report is possibly the best option
22:28:25 <dons> Results 1 - 10 of about 2,550,000 for monad
22:28:26 <dons> hehe
22:29:03 <narain> heh. first few hits: windows powershell, catholic encyclopedia
22:29:09 <sorear> shwag: have we scared you away yet? ;)
22:29:34 <narain> in fact windows powershell takes 7 of the 10 top results
22:29:38 <dons> > (\x -> x ^ 2) 4 -- have a lambda
22:29:39 <lambdabot>  16
22:29:40 * sorear notes that he hasn't responded in 70 lines
22:29:55 <shwag> sorear: im interested in knowing more. i need an overview to see how it compares to python i think. Now i know to keep my eye on it.
22:30:19 <dons> oh, we do have a direct comparison document
22:30:21 <bos> you can find a crappy comparison on python.org
22:30:27 <dons> yeah
22:30:30 <shwag> of course
22:30:36 * Korollary looks for the crappy comparison
22:30:41 <dons> http://wiki.python.org/moin/PythonVsHaskell
22:30:41 <narain> the introduction to haskell on the wiki is pretty good
22:30:43 <lambdabot> Title: PythonVsHaskell - PythonInfo Wiki
22:30:45 <narain> ?wiki Introduction
22:30:46 <lambdabot> http://www.haskell.org/haskellwiki/Introduction
22:31:14 <shwag> "Both use indentation as syntax. "  ahh
22:31:20 <bos> compared to python, haskell forces you to make many more of your mistakes up front.
22:31:29 <mauke> it's optional in haskell, though
22:31:40 <dons> though there's more comparisons here, http://haskell.org/haskellwiki/Blog_articles#Python
22:31:41 <lambdabot> Title: Blog articles - HaskellWiki
22:32:28 <Korollary> I get sorta annoyed when people say lisp is functional.
22:32:29 <dons> too much eh?
22:32:49 <bos> lisp is more functional than python, at any rate.
22:32:55 <dons> yeah, "if it ain't pure, it ain't functional" ;-)
22:33:20 <Korollary> Not because of purity, but because of lack of intent. Scheme had the intent.
22:33:23 <sorear> bos: you call that wiki-page "crappy"?  looks pretty good to me
22:33:54 <Korollary> "The Haskell type system, however, does provide more compile-time information than python's does..."
22:34:04 <Korollary> What compile time information do python compilers provide?
22:34:50 <narain> > let qsort [] = []; qsort (x:xs) = qsort l ++ [x] ++ qsort r where l = filter (< x) xs; r = filter (>= x) xs in qsort [4,6,2,6,3,4,7]
22:34:51 <lambdabot>  [2,3,4,4,6,6,7]
22:34:53 <mauke> > let q a = do x:y <- [a]; q (filter (< x) y) ++[x]++ q (filter (>= x) y) in q $words "welcome to haskell, enjoy your stay"
22:34:55 <lambdabot>  ["enjoy","haskell,","stay","to","welcome","your"]
22:34:59 <bos> sorear: it's changed a lot since last i read it.
22:35:13 <dmead> doot
22:35:17 <mauke> narain: I win!
22:35:30 <dons> Korollary: less than haskells :-)
22:35:31 <narain> mauke: i beat you to it, but yours is better :/
22:35:53 <sorear> Korollary: quite a bit
22:35:54 <dons> presumably function values are distinguished statically
22:36:07 <sorear> Korollary: for instance, python is lexically scoped
22:36:16 <bos> no, they're not. and no, it isn't.
22:36:29 <sorear> Korollary: which is a HUGE compilability win compared to olde lisp!
22:36:41 <dons> bos, scary.
22:36:46 <bos> python has bizarre scoping rules.
22:37:10 <falconair> hi, hoogle doesn't have any info regarding ByteString or Data.Binary?
22:37:35 <bos> hoogle's database is based off ghc 6.4.2
22:37:36 <dons> falconair: Data.Binary is a 3rd praty package, so check its docs on hackage.haskell.org
22:37:40 <bos> so it's old
22:37:43 <dons> and bytestring has docs in base
22:38:13 <dons> falconair: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary-0.3
22:38:15 <lambdabot> http://tinyurl.com/25ptqt
22:38:41 * sorear wonders why shwag left without quitting?
22:38:47 <falconair> dons: I have the docs bookmarked, I wanted to be able to do things like ByteString -> [ByteString] and have it return lines, words, whatever
22:39:08 <dons> so a split function?
22:39:18 <dmead> cause shwag is a dirty hippie?
22:39:21 <bos> sorear: he's a mole. he's going to tell the #python hackers that they need to embrace purity, laziness, and strong static typing.
22:39:31 <dons> hehe.
22:39:39 <dolio> That'd be an abrupt change of direction.
22:39:56 <falconair> dons: i already found splitWith :)  but as i learn haskell and actually some programming projects hoogle will prove useful.  And it looks like i'll be doing some work with bytestrings
22:40:07 <narain> ?google zen of python
22:40:10 <lambdabot> http://www.python.org/doc/Humor.html
22:40:10 <lambdabot> Title: Python Humor
22:40:34 <dons> falconair: yep. makes sense.
22:40:38 <bos> hoogle is invaluable, but you can't beat checking out the darcs head of ghc, darcs-all get --partial, then "grep -r"
22:41:04 <narain> hmm, i don't see anything in the zen of python that haskell doesn't satisfy :)
22:42:34 <sorear> bos: why bother with --partial?
22:42:41 <procyon112> narain: Although practicality beats purity.
22:42:57 <narain> hey, monads are very practical
22:42:58 * sorear has a FULL checkout of ghc and extralibs, and is glad he invested the extra few minutes.
22:43:02 <bos> sorear: because darcs is so slow?
22:43:04 <procyon112> and, There should be one-- and preferably only one --obvious way to do it.
22:43:39 <procyon112> and, this one: Now is better than never... come one, that flies in the face of infinite lists ;)
22:43:41 <narain> true. but, "Although that way may not be obvious at first unless you're Dutch." s/Dutch/"a category theory guru"/
22:43:43 <falconair> so hoogle takes my type and returns functions that match those types ... is it possible for me to give any arbitrary types and some system returns an auto-generated program (if there is no single function that matches my 'query' it actually 'infers' a program) ... is that "Theorems For Free"?
22:43:56 <bos> @djinn Int -> String
22:44:00 <lambdabot> -- f cannot be realized.
22:44:12 <bos> @djinn Int -> Integer
22:44:13 <lambdabot> -- f cannot be realized.
22:44:22 <bos> ok. in principle, @djinn will do it.
22:44:27 <falconair> :)
22:44:31 <Korollary> Man, I wish Ralf Laemmel or somebody dissected what REST means using Haskell like he did with MapReduce.
22:44:34 <procyon112> @djinn a->b->a
22:44:35 <lambdabot> f a _ = raa (\ b -> b a)
22:44:41 <bos> in practice, it bards on you.
22:44:44 <narain> ?djinn [a] -> Integer
22:44:44 <lambdabot> -- f cannot be realized.
22:44:54 <bos> er, barfs.
22:45:02 <narain> can't djinn infer  length ?
22:45:39 <bos> well, REST isn't very profound, which is kind of the whole point.
22:45:54 <Korollary> bos: It's too vacuous.
22:45:56 <procyon112> @djinn ((a->b)->(a->b))->(a->b)
22:45:57 <lambdabot> -- f cannot be realized.
22:46:02 <falconair> if haskell ever gets a descent IDE, such things will make the IDE magical compared to the "code completion" other languages have ... if haskell ever gets an IDE...
22:46:18 <narain> it does have visualhaskell
22:46:40 <procyon112> @djinn ((a -> b -> c) -> (a -> b) -> a -> c
22:46:40 <lambdabot> Cannot parse command
22:46:45 <dons> is anyone able to actually run this 'haskell/ocaml/scheme' quine? http://mbishop.esoteriq.org/poly.txt (as haskell)
22:46:53 <procyon112> @djinn ((a -> b -> c) -> (a -> b) -> a -> c)
22:46:53 <lambdabot> f a b c = a c (b c)
22:47:06 <narain> thought the real-time type error annotations get annoying when you're editing chunks of your program
22:47:11 <procyon112> ?pl f a b c = a c (b c)
22:47:12 <lambdabot> f = ap
22:47:19 <falconair> can I type myfunc:: a->b-> and have it return the inferred code (like djinn)?
22:47:23 <falconair> visual haskell that is
22:47:31 <Korollary> dons: I get parse errors with ghc -c and runghc
22:47:39 <narain> falconair: no, it doesn't have djinn built-in afaik
22:47:44 <mauke> falconair: there's a library to do that in code :-)
22:48:06 <narain> mauke: what library is that?
22:48:11 <dons> Korollary: me too with runhaskell and ghci
22:48:22 <mauke> @where oleg
22:48:23 <lambdabot> I know nothing about oleg.
22:48:33 <dons> Korollary: http://programming.reddit.com/info/1lkce/comments/c1lmzb
22:48:35 <lambdabot> Title: A Polygot Quine in Haskell, Ocaml, and Scheme (reddit.com)
22:48:48 <Korollary> dons: It starts with ;;. How is that supposed to work?
22:49:08 <dons> hmm. yes, it would need a module M where {
22:49:15 <dons> to introduce explicit layout
22:49:19 <dons> and a closing }
22:49:30 <procyon112> falconair: I have code which, given a type, returns an infinite list of all possible programs that satisfy that type :)
22:49:33 <Korollary> that would mess up ocaml I think
22:49:43 <Korollary> err scheme
22:49:52 <dons> i can't see how it can be valid haskell as it is.
22:50:02 <falconair> procyon112: :)  i need to learn this stuff
22:50:05 <Korollary> dons: The original post says "hugs", but hugs also errors.
22:50:19 <mauke> narain: http://okmij.org/ftp/Haskell/de-typechecker.lhs
22:50:28 <dons> yes, it loads with module M where {
22:50:35 <dons> and a closing } at the bottom of the file.
22:50:51 <dons> and works
22:51:20 <dons> Ko	http://www.cse.unsw.edu.au/~dons/tmp/poly.hs
22:51:31 <narain> mauke: that's awesome
22:51:51 * narain saves the link
22:52:41 <sorear> dons: You can have explicit layout in any context, it doens't have to be 'introduced'
22:52:51 <sorear> all { does is disable automatic layour
22:53:29 <dons> hmm .yes.
22:53:36 <Korollary> ghc warns but hugs runs it.
22:53:41 <dons> ;;
22:53:42 <dons> main = print "hello"
22:53:44 <dons> is fine.
22:53:46 <dons> so something else.
22:54:20 <dons> so there's some other layout issue fixed by the { }
22:55:51 <mauke> dons: fixed
22:56:07 <hpaste>  mauke pasted "try.hs" at http://hpaste.org/1603
22:57:50 <narain> :t (@@)
22:57:56 <lambdabot> Not in scope: `@@'
22:58:17 <narain> oh, (@@) = (:) in the program
22:59:14 <narain> forgot about haskell's "use first, define later" policy
22:59:48 <dons> use anywhere, define anywhere :-)
23:02:48 <mwc> yeah, sometimes I miss C++'s forward declarations
23:02:51 <mwc> then I slap myself
23:03:21 <dolio> You could put all your type declarations at the start.
23:07:07 <stepcut> I never miss having to put type declarations in a seperate file, e.g., .h or .mli.
23:08:46 <thetallguy> amen
23:09:24 <falconair> there was a recent paper about creating millions of threads in haskell ... will that be integrated into GHC anytime soon (apparently the code for that paper is currently very experimental and only for linux)
23:10:11 <dons> yeah, I think the plan is to replace the threading model with this stuff.
23:10:17 <dons> there's an intern at MS working on it, iirc
23:10:30 <falconair> next week? :)
23:10:56 <dons> well, within a year or so. you need 10M threads?
23:11:15 <dolio> Was that the threading <-> event paper?
23:11:24 <dons> that's it.
23:11:38 <falconair> well, combination of haskell+erlang will be fantastic for my industry, financial markets
23:11:41 <dolio> I saw that, but I could have sworn I read something exactly like that a while ago.
23:13:04 <dolio> As far as the 'threading is isomorphic to event handling' and context switching at some specific IO calls with a CPS monad.
23:13:32 <dolio> Maybe it's updated work or something, though.
23:16:03 <dolio> Ah, yeah, it must be. It's by the same people.
23:20:26 <dmead> hey dons
23:20:51 <dmead> got a question about the code you showed me the other day
23:21:57 <nattfodd> hi, has anyone managed to install ghc on mac os x?
23:22:06 <falconair> i have
23:22:07 <sorear> yes!
23:22:17 <falconair> sudo  port install ghc
23:23:20 <nattfodd> and is there any way to do it without installing a ${random unix} port?
23:23:36 <dmead> use the autotools scripts?
23:23:39 <dmead> or find a binary?
23:23:57 <nattfodd> there's no binary on the official site, as far as I can tell
23:25:03 <dmead> http://www.haskell.org/ghc/download_ghc_641.html
23:25:04 <lambdabot> Title: GHC: Download version 6.4.1
23:25:07 <dmead> but thats older
23:25:52 <dmead>  ahh
23:25:59 <dmead> why don't you get the os X version of darcs
23:26:07 <dmead> and get a fresh copy that way
23:26:12 <dmead> http://darcs.net/DarcsWiki/CategoryBinaries
23:26:14 <lambdabot> Title: CategoryBinaries - DarcsWiki
23:26:39 <falconair> sudo port install darcs ;)
23:26:56 <dmead> is port part of os X by default?
23:27:19 <falconair> no, you have to install it, not very difficult from what i recall
23:27:20 <nattfodd> no
23:28:49 <falconair> http://trac.macosforge.org/projects/macports/browser/downloads/MacPorts-1.4.0
23:28:51 <lambdabot> Title: /downloads/MacPorts-1.4.0 - MacPorts - Trac, http://tinyurl.com/22mehj
23:36:58 <sorear> @users
23:36:59 <lambdabot> Maximum users seen in #haskell: 335, currently: 287 (85.7%), active: 29 (10.1%)
23:44:18 <scsibug> nattfodd: fyi, I may have an updated build of ghc/osx/ppc 6.6.1 later this weekend
