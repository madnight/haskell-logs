00:00:45 <cpoucet> @where yi
00:00:46 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
00:01:05 <dcoutts> jyp: hmm, other wierd thing, is that starting yi in my gnome-terminal clears the X selection, perhaps a vty thing.
00:01:48 <jyp> dcoutts: I think so
00:02:45 <sorear> vty uses ^[c in the init string to nullify the differences in behavior between terminals
00:03:11 <sorear> xterm and its descendants do profoundly dumb things on receiving that sequence, like beeping
00:03:54 <dcoutts> sorear: yes it does :-) odd
00:04:19 <dcoutts> sorear: I always wondered why vim beeps when I quit it, perhaps the same thing
00:04:22 * ddarius has not seen anyone from this channel.
00:04:42 * sorear has not either.
00:05:04 <ivanm> ddarius: maybe you have and just didn't know it? (I assume you mean the RW?)
00:05:48 <ddarius> ivanm: Possible.  Maybe some of the lurkers here I have.  There once was a person (Optikal) who lived in my area.
00:05:57 <dcoutts> jyp: so is there a feature yet to run commands when opening a file, eg to turn on Haskell syntax highliting when opening .hs files?
00:06:02 <ddarius> But most of the people I know enough about to know that I have not met them.
00:06:25 <ivanm> ddarius: *shrug* I didn't think I knew anyone from the #gentoo-au channel... but apparently there's someone who lurks there who goes to my uni
00:07:12 <jyp> dcoutts: no
00:07:22 <dcoutts> jyp: ok
00:07:32 <ddarius> ivanm: If I lived in the UK or Australia and further was in a university, I'd be more inclined to think I'd run into someone here.
00:07:32 <jyp> What I do is to turn haskell highlighting for all files
00:07:43 <dcoutts> jyp: ah good plan :-)
00:08:25 <jyp> I will provide a sample YiConfig that does this.
00:08:28 <sorear> regexing the /who #haskell output, only stepcut shares my ISP+city
00:08:32 <ivanm> ddarius: why necessarily UK or Australia? I know dons is from unsw, but AFAIK there's not many others...
00:08:52 <dcoutts> jyp: thanks
00:09:03 <ddarius> Haskellers seem congregated in those areas.
00:09:48 <ivanm> I suppose... but how many of the uni people are on this channel?
00:10:07 <ivanm> AFAIK, there's only 3 professors at UQ who use haskell, and I don't think any of them are here
00:10:14 <ddarius> Oh and Scandinavia and co.
00:10:24 <sorear> well ccshan frequents #haskell :)
00:10:30 <jyp> dcoutts: btw, if I'm unavailable for bug reports here, please use the Yi page on haskell wiki.
00:12:14 <ivanm> sorear: who's ccshan?
00:12:57 <cpoucet> ivanm: DC guy
00:13:00 <sorear> co-authored half of Oleg's papers
00:13:12 <sorear> two chinesey names, then Shan
00:13:23 <sorear> chung-chieh or soundalike
00:15:34 <sorear> THe really annoying thing about vty is the difference between input and output.
00:16:17 <sorear> input is simple and perf-uncritical, and you'd be an idiot to write it in low level language ... output IS perf critical
00:16:52 <sorear> also, the terminfo files do some things I really hate.
00:17:23 <sorear> anyone who thinks skins are bad hasn't suffered through alternate screens
00:17:41 <dcoutts> jyp: ok, cheers
00:17:52 <sorear> every time I quit vim in an xterm it erases all the stuff I might want to copy
00:18:26 <sorear> of course this was back when I actually used vim and xterm :)
00:18:34 <sjanssen> sorear: that's both a curse and a blessing
00:19:12 <sorear> If only there were a (documented?) way to override the whim of the debian terminfo maintainer
00:20:09 <sorear> Replacing terminfo is dumb since it makes us incompatible-by-default.  Not replacing it is dumb since it forces us to accept policy.
00:20:18 * sorear rather prefers mechanism
00:24:11 <ivanm> Out of curiosity, I know that both Haskell and Lisp-based languages have both interpreted and compiled modes... which other ones do?
00:24:25 <LoganCapaldo> OCaml
00:24:33 <ivanm> Any non-functional ones?
00:24:44 <LoganCapaldo> well there are c interpreters
00:24:56 <opqdonut> well, python and perl can also be compiled
00:25:01 <ivanm> there are? how good are they?
00:25:14 <LoganCapaldo> I dunno
00:25:20 <ivanm> opqdonut: they're only byte-compiled though, aren't they? I meant more in terms of creating a stand alone program
00:25:23 <cpoucet> ivanm: java?
00:25:35 <ivanm> cpoucet: you can interpret java?
00:25:41 <opqdonut> ivanm: at least with perl one can make a standalone program
00:25:42 <cpoucet> depends what you define as 'interpret'
00:25:42 <LoganCapaldo> http://root.cern.ch/root/Cint.html
00:25:43 <ivanm> as in a prompt?
00:25:46 <lambdabot> Title: The CINT C/C++ Interpreter
00:25:47 <opqdonut> ivanm: it might include the vm, tho
00:25:55 <cpoucet> ivanm: oh, you mean a REPL
00:25:59 <cpoucet> ivanm: that's a different q than interpreter
00:26:01 <ivanm> *nod*
00:26:06 <opqdonut> ahhh
00:26:09 <cpoucet> you could prolly hack a java repl
00:26:14 <ivanm> doesn't the "i" in ghci stand for interpreter?
00:26:19 <cpoucet> any latebound language can prolly be acked to have a repl
00:26:22 <LoganCapaldo> interactive
00:26:23 <opqdonut> ivanm: interactive?
00:26:30 <cpoucet> s/acked/hacked
00:26:36 <opqdonut> ivanm: well, gdb has a pretty good c repl :)
00:26:38 <cpoucet> ivanm: interpreter is a rather fuzzy term :)
00:26:47 <ivanm> lol, fair enough
00:26:48 <LoganCapaldo> points for opqdonut
00:27:10 <cpoucet> ivanm: smalltalk?
00:27:13 <ivanm> opqdonut: yeah, but can a programmer use it for general evaluation?
00:27:34 <opqdonut> ivanm: why not?-)
00:27:47 <Pseudonym> I thought that /bin/sh was C's REPL.
00:27:58 <ivanm> I was asking because I find using ghci whilst developing really handy, since I can check my code as I go rather than having to compile then try running the program
00:28:04 <ivanm> Pseudonym: lol
00:28:08 <opqdonut> Pseudonym: the input lang is just not c :/
00:28:17 <cpoucet> opqdonut: sure it is
00:28:26 <opqdonut> hahayeah
00:28:26 <opqdonut> csh
00:28:27 <cpoucet> foo
00:28:31 <cpoucet> blabla
00:28:32 <cpoucet> ^D
00:28:45 <cpoucet> foo = cat >> temp.c && gcc -c temp.c && a.out
00:28:46 <ivanm> opqdonut: was that meant to be based on the "just not cricket" english phrase?
00:29:04 <opqdonut> ivanm: well, the only other lang i've used that kind of development in is python
00:29:13 <opqdonut> in c one never need to check the code that way
00:29:23 <ivanm> *nod*... but its only byte-compiled, rather than to a stand alone executable
00:29:26 <opqdonut> neither in perl, really, tho somebody might
00:29:41 <sorear> jyp: does yi's plugin system support unloading in any remotely sane way?
00:29:49 <cpoucet> ivanm: "cat python.exe my.python >> my.exe"
00:30:10 <LoganCapaldo> cpoucet: that doesn't actually work does it?
00:30:14 <ivanm> opqdonut: never need to do it for C since the imperative approach is more "natural"? ;-)
00:30:27 <cpoucet> LoganCapaldo: well not like that, but there's prolly packers that do something equivalent
00:30:29 <jyp> sorear: no
00:30:33 <opqdonut> ivanm: b/c it is more low-level
00:30:45 <opqdonut> and i would say i have a better intuition for perl than haskell
00:30:55 <opqdonut> but that's just because of coding hours :)
00:30:57 <sorear> jyp: oh, good.  If it did hs-plugins would be obsolete :)
00:30:59 <ivanm> opqdonut: *nod*... so low-level is easier? :p
00:31:18 * sorear wishes there were a decent dynamic loading system for haskell
00:31:20 <opqdonut> ivanm: not necessarily easier, but more self-explanatory
00:31:23 <cpoucet> sorear: iirc, hs-plugins evolved from yi-s system
00:31:30 <cpoucet> sorear: consider the source
00:32:01 <sorear> cpoucet: maybe at one time it did, but the dynamicity in yi has been completely rewritten by jyp
00:32:10 <cpoucet> ah, I wasn't aware of that
00:32:19 <ivanm> opqdonut: because of the imperative, step-by-step nature? and no monads^H^H^H^H^H^H warm fuzzy things? ;-)
00:32:36 <opqdonut> ivanm: well, one could say that i guess
00:32:48 <LoganCapaldo> I don't see what low level and REPL has to do with each other. _every_ language is mor euseful with a REPL except maybe ASM as far as I am concerned
00:33:02 <jyp> sorear: Actually, I could call rts_revertCAFs; I imagine the rest would be taken care of by the garbage collector
00:33:04 <opqdonut> tho in haskell i only need to check stuff when i start condensing my functions into oneliners
00:33:23 <ivanm> or composing them? making them pointless?
00:33:26 <opqdonut> when writing them naively it usually is quite straightforward
00:33:28 <opqdonut> ivanm: yeah
00:33:45 <sorear> jyp: I mean, is it like hs-plugins where you get a crash if you unload haskell code?
00:33:58 <LoganCapaldo> oh forth has a repl
00:34:00 <sorear> you can safely unload ml code written in haskell
00:34:05 <LoganCapaldo> and can be compiled
00:34:05 <sorear> but laziness == death
00:34:13 <ivanm> what's forth again? a re-done fortran?
00:34:22 * LoganCapaldo justremembered another example
00:34:24 <ivanm> @google forth
00:34:26 <lambdabot> http://www.forth.org/
00:34:27 <lambdabot> Title: Forth Interest Group Home Page
00:34:29 <Cale> ivanm: it's a stack language
00:34:30 <opqdonut> ivanm: no, a stack-based language
00:34:32 <LoganCapaldo> ivanm: bite your tongue
00:34:35 <jyp> sorear: there is no means to "unload" code per se; however, you can "reloadE" (equivalent of ghci :r)
00:34:42 <opqdonut> for embedded stuff, mostly
00:34:56 <ivanm> LoganCapaldo: lol, just remember hearing some guy had done his own fork of fortran, and couldn't remember what it was called
00:35:02 <ivanm> and since forth starts with "f"...
00:35:10 <jyp> sorear: and everything works as expected (though I expect memory leaks since I don't call rts_revertCAFs)
00:35:15 <opqdonut> isn't forh older than fortran?
00:35:20 <opqdonut> nah, can't be
00:35:28 <ivanm> LoganCapaldo: forth = reverse lisp - parentheses? ;-)
00:35:44 <opqdonut> FORTH may stand for:
00:35:46 * sorear thinks any code that leaks memory is broken.
00:35:47 <opqdonut> FORTRAN H, a FORTRAN implementation for the IBM System/360 and System/370 mainframes
00:35:51 <LoganCapaldo> joy = reverse lisp s/()/[]/g
00:36:18 * sorear can't force himself to understand good enough ...
00:37:02 <ivanm> joy? definitely haven't heard of that one before...
00:37:39 <dons> sorear: hmm "you get a crash if you unload haskell code" ?
00:37:42 <LoganCapaldo> http://www.latrobe.edu.au/philosophy/phimvt/joy.html
00:37:42 <lambdabot> Title: Main page for the programming language JOY
00:38:23 <jyp> sorear: at least you never get a crash with the current yi, even if you reload stuff.
00:38:49 <sorear> dons: haskell code uses laziness.  ml code that happens to be syntaxed in haskell is safe.
00:39:25 <sorear> jyp: ooh? how do you prevent the old data from trampling on the new data, flat namespace and all that?
00:39:37 <dons> values exposed by unloaded plugins should be evaluated strictly, yes. you should be precise about what you mean by "crash".
00:39:38 <sorear> are there any restrictions?
00:39:42 <dons> so as not to mislead.
00:40:24 <sorear> when I say crash, I always mean 'Segmentation fault'.  I never use that verb for pattern matching failures or nontermination.
00:40:38 <sorear> s/use/intend to use/
00:40:46 <dons> you won't get a segfault in hs-plugins by unloading anyway.
00:40:50 <dons> since the runtime doesn't unload old code.
00:41:17 <dons> so "hs-plugins" and "crash" is just speculation on your part?
00:41:18 <sorear> *sigh of relief*
00:41:25 <ivanm> LoganCapaldo: so joy is sort of like pointless, stack-based haskell?
00:41:30 <sorear> the unload function needs to be better documented then
00:41:43 <dons> these details are explained in the paper.
00:42:07 * sorear reads it again
00:42:08 <LoganCapaldo> haskell is sort of a typefu, stackless pointed joy :)
00:42:33 <ivanm> lol... typefu? you mean typed?
00:42:50 <ddarius> typeful
00:42:54 <ivanm> ahhh
00:43:07 <LoganCapaldo> what ddarius said
00:43:20 <ivanm> hmmm.... just happened to find a wikipedia article on "eager haskell"... is that just non-lazy haskell?
00:43:33 <sorear> dons: which one?
00:43:34 <ivanm> isn't the laziness one of haskell's biggest advantages?
00:44:12 <ddarius> ivanm: I don't think so.  I'm pretty sure it was a speculative evaluation type approach, not a strict Haskell.
00:44:22 <ddarius> @where hairshirt
00:44:23 <lambdabot> I know nothing about hairshirt.
00:44:24 <ivanm> *nod*
00:44:27 <ddarius> Drat.
00:44:31 <dons> sorear: the hs-plugins paper and dynamic apps paper.
00:44:37 <ddarius> @google "Wearing the hairshirt" haskell
00:44:39 <lambdabot> No Result Found.
00:44:51 <ddarius> @google Wearing the hairshirt haskell
00:44:53 <lambdabot> http://research.microsoft.com/~simonpj/papers/haskell-retrospective/index.htm
00:44:54 <lambdabot> Title: Wearing the hair shirt: a retrospective on Haskell
00:44:54 <ivanm> so more of a compiler optimisation than an evaluation strategy?
00:45:25 <ddarius> @where+ hairshirt http://research.microsoft.com/~simonpj/papers/haskell-retrospective/index.htm
00:45:25 <lambdabot> Done.
00:46:07 <ddarius> ivanm: More of a potentially more efficient way of implementing Haskell.  It's more than just a "compiler optimization"
00:46:41 <ivanm> OK... so what would that mean in terms of haskell usage and performance?
00:47:07 <ivanm> on the MIT website, it seems to be a replacement for laziness...
00:47:11 <dons> it means you evaluate small chunks of code strictly
00:47:21 <dons> then if it gets to expensive, you suspend.
00:47:34 <dons> for some data types, interestingly, you can implemente eager eval as a library
00:47:37 <ivanm> ahhh... small scale strictness, large scale laziness?
00:47:39 <dons> e.g. lazy bytestrings.
00:47:44 <ivanm> "Second, we believe eagerness is more efficient than laziness."
00:47:54 <dons> where you do cache-sized chunks eagerly, before suspending
00:48:11 <dons> so e.g. Data.ByteString.Lazy and Data.Binary all use eager evaluation, implemented as a library
00:48:19 <dons> hmm. i'm not sure this is widely realised.
00:48:32 <tuxplorer> dons: is kzm around nowadays?
00:48:37 <dons> ?seen kzm
00:48:37 <lambdabot> Last time I saw kzm was when I left #darcs, #gentoo-haskell, #gentoo-uy, #ghc, #happs, #haskell, #haskell-blah, #haskell-overflow, #haskell.de, #haskell.dut, #haskell.es, #haskell.fr, #jtiger, #
00:48:37 <lambdabot> montevideolibre, #oasis, #parrot, #perl6, #scannedinavian and #unicycling 1m 7d 2h 59m 37s ago, and .
00:48:47 <tuxplorer> ah!
00:48:53 <dons> hmm. i think he doesn't wake up for a little while yet
00:48:58 <tuxplorer> :D
00:49:00 <ivanm> so if you did something like map f . map g, rather than lazily applying g then f, automatically applying g whenever f is required?
00:49:11 <ivanm> i.e. less temporary chunks of data floating around?
00:49:20 <dons> ivanm: hmm, no, that's deforestation
00:49:33 <dons> it more that, eagerly, you'd evaluate more than just one cons node at a time
00:49:35 <ivanm> oh... as in less use of paper? ;-)
00:49:48 <ivanm> a "look ahead" kind of approach?
00:49:49 <dons> map f . map g ==> map (f.g)
00:49:58 <dons> means removing one intermediate structure
00:50:02 <dcoutts> ivanm: deforestation is a transformation to remove trees
00:50:03 <dons> that's deforestation/fusoin
00:50:20 <ivanm> dcoutts: yeah, I know... I was trying to be funny :(
00:50:24 <dons> dcoutts: maybe we should write a HW paper on eager evaluation for data structures
00:50:37 * ivanm would appreciate that
00:50:37 <dons> i..e eager haskell as a library...
00:50:47 <dcoutts> ivanm: that was Wadler's joke first :-)
00:50:56 <dcoutts> dons: hmm
00:51:06 <ivanm> it was? never heard it before...
00:51:20 <dons> since i think this is not a widely recognised feature of Data.ByteString.Lazy and libs on top of that.
00:51:42 <dcoutts> dons: aye
00:52:00 <dcoutts> dons: a paper on binary would mention that
00:52:05 <dons> yeah.
00:52:16 <dons> kolmodin: ^^ ping ;-)
00:52:19 <ivanm> dons: so eager evaluation can be thought of a bit like prefetch/cache in computers?
00:52:24 <ddarius> @where bytestring
00:52:25 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
00:52:25 <dcoutts> it does this interleaving between strictly writing bytes and lazily suspending
00:53:16 <ivanm> so bytestring is written partially in C?
00:53:26 <dcoutts> ivanm: only a very little bit
00:53:40 <dcoutts> ivanm: 4 functions out of 100ish
00:53:40 <ivanm> which bit is?
00:53:50 <ivanm> ahhh... why? speed?
00:54:10 <dcoutts> http://darcs.haskell.org/packages/base/cbits/fpstring.c
00:54:40 <dons> ivanm: hehe. no, its not written in C :-)
00:54:44 <dcoutts> ivanm: yes, speed
00:55:00 <dons> dcoutts: i think i might remove those functions this week.
00:55:02 <ivanm> dons: I did say "partially"
00:55:19 <dcoutts> dons: want benchmark them ?
00:55:47 <dcoutts> dons: we also use a bunch of libc functions of course so that's not getting rid of ffi
00:55:55 <dcoutts> even if you remove those 5
00:55:57 <dons> 96 lines of C, 6,300 lines of Haskell
00:57:02 <dons> actually, hacking on bytestring this week might be a nice diversion
00:57:06 <dons> along with finishing xmonad.
00:57:09 <dcoutts> dons: yeah
00:57:27 * dcoutts might look at cabal & c2hs today
00:57:30 * LoganCapaldo calls those things "distractions" not diversisons
00:57:40 <dons> dcoutts: oh, i put up the paper website, btw.
00:57:53 <dons> dcoutts: http://www.cse.unsw.edu.au/~dons/streams.html
00:57:53 <lambdabot> Title: Data.List.Stream
00:58:03 <dcoutts> dons: I know, nice. I emailed my progtools group with the links
00:58:08 <dons> cool.
00:58:50 <foxy-om> in Foreign.Storable, what is the alignment constraint? I have a Complex (Ptr ()) where the Ptr () refers to a chunk 2*(sizeof (0 :: Float))
00:59:57 <sorear> no mention of unload in 'Plugging Haskell In' except "Removes the plugin code from the address space"
01:00:15 <dons> sorear: check the dynamic apps paper, since that is all about hot swapping.
01:00:31 <dons> the first paper was more about plugins, rather than hot swapping.
01:01:37 <dons> so when do we start to blitz reddit with all the new haskell papers written this week? ;-)
01:03:13 <dcoutts> heh
01:06:03 <ddarius> The convert recursive structures into non-recursive co-structures was brilliant.
01:07:13 <dons> ddarius: yeah, we finally realised what was going on a few months ago: getting rid of recursion.
01:07:45 <dons> then you just let ghc's normal optimisations do the real fusion
01:08:53 <ddarius> As soon as I saw that in the Rewriting Strings paper, I was interested.
01:09:00 <LoganCapaldo> Non-recursive co-structures?
01:09:19 <dons> yeah, inside-out functions on lists
01:09:35 <LoganCapaldo> ...
01:09:46 <dons> check the paper :-)
01:10:02 <LoganCapaldo> which paper now?
01:10:15 <LoganCapaldo> Rewritting Strings?
01:10:21 <dons> nah, the new one, http://www.cse.unsw.edu.au/~dons/streams.html
01:10:22 <lambdabot> Title: Data.List.Stream
01:14:57 <LoganCapaldo> dons: Your mind works in mysterious ways
01:15:06 <dons> hmm?
01:15:43 <LoganCapaldo> I think I suspect I have an inkling of whats happening with this Step thing, but it is still beyond my mere mortal comprehension
01:15:51 <jyp> dcoutts: The command line bug is fixed.
01:16:01 <dcoutts> jyp: woo! thanks
01:16:06 * dcoutts darcs pulls
01:16:25 <jyp> dcoutts: see examples/VimHaskell.hs for your YiConfig
01:16:45 <jyp> huh HaskellVim.hs :)
01:17:08 <dons> LoganCapaldo: so Step constructors are like list constructors, Cons and Nil. (and with Skip), the key thing though is the Stream data type to represent lists as unfoldings of non-recursive Step functions.
01:18:22 <dcoutts> jyp: I was thinking, it's probabbly possible to get the ghc in setup.hs automatically rather than needing the user to use --with-ghc
01:18:24 <sorear> dons: it looks like yi-old needs to flatten all of its state into a single data structure, which is only efficient because the text is a Ptr?
01:18:29 <dcoutts> jyp: I'll have a look.
01:18:44 <dcoutts> jyp: I mean by using the right Cabal calls
01:19:06 <sorear> dons: and I can't find any documentation for the doesn't-actually-unload behavior of unload
01:19:07 <dons> sorear: hmm? you mean, for rebooting?
01:19:31 <dons> sorear: i'm pretty sure that's described somewhere (possibly as a footnote) about ghc's current runtime implementation.
01:20:04 <jyp> dcoutts: thanks
01:20:10 <sorear> dons: yeah, for rebooting
01:21:00 * jyp is off for a while
01:21:11 <dons> the state is stored in a single structure because that's how we do state in haskell :-)
01:21:26 <LoganCapaldo> dons: I don't get how lists are recursive and streams aren't.
01:21:35 <dons> list functions are recursive
01:21:39 <sorear> dons: err, pointer-free data structure, sorry ;)
01:21:56 <sorear> the 'immortal values' section
01:21:59 <dons> but stream functions(for producers and transformers of lists) are non-recursive 'steppers'
01:22:14 <dons> language i.e. next s = case ... of -> Yield x
01:22:19 <dons> is non recursive.
01:22:28 <dons> @foldl
01:22:31 <dons> @src foldl
01:22:32 <lambdabot> foldl f z xs = lgo z xs
01:22:32 <lambdabot>     where lgo z []     =  z
01:22:32 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
01:22:39 <dons> however, is a recursive list function. its rhs calls itself
01:22:50 <dons> making it hard to optimise pipelines of such things.
01:24:57 <LoganCapaldo> So my intuition is telling me you've turned a recursive computation into a value representing that computation...
01:27:01 <RyanT5000> why does [t| ... |] produce a TypeQ, not a Type?
01:27:07 <sorear> renaming
01:27:21 <RyanT5000> like with newName?
01:27:26 <sorear> [t| forall a. a |] need to make a unique number for 'a'
01:27:33 <RyanT5000> i see
01:27:41 <LoganCapaldo> oooo
01:27:42 <sorear> yes.
01:27:52 <RyanT5000> that's pretty annoying
01:28:02 <sorear> LoganCapaldo: fix ties knots.  streams cuts them :)
01:28:02 <RyanT5000> is that the entire point of Q?
01:28:14 <sorear> RyanT5000: pretty much :(
01:28:20 <RyanT5000> hm
01:28:25 <LoganCapaldo> teh stream isn't jsut the data it carries around its "traverse the stream" function
01:28:37 <sorear> RyanT5000: it's also a reader-y monad allowing you to access data type definitions
01:28:42 <RyanT5000> hm
01:28:55 <dons> LoganCapaldo: right.
01:29:02 <LoganCapaldo> map, filter, etc. make new streams that carry arround their own "traverse the stream function" in terms of the original stream
01:29:13 <dons> the Stream has the initial state of the computation, and a function to yield the next value.
01:29:19 <LoganCapaldo> but next doesn't recurse
01:29:22 <sorear> dons: I wonder if that would make a good slogan for streams. "Cutting the (recursive) Knot"
01:29:22 <dons> right.
01:29:24 <sorear> :)
01:29:36 <LoganCapaldo> very fancy
01:29:43 <dons> "a short cut through recursion"
01:29:45 <dons> or something, eh?
01:30:10 <dons> LoganCapaldo: its a bit like writing all your functions in terms of unfoldr
01:30:12 <dons> ?type unfoldr
01:30:15 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
01:30:30 <dons> which is a stepper, and a state, which actually yields your list at the end, when run.
01:30:45 <dons> that's the intuition behind this line of work.
01:31:02 <LoganCapaldo> And streams are like a function from lists to "arguments to pass to unfoldr"
01:31:12 <dons> yeah.
01:31:21 <sorear> dons: is there any deep reason you use dual church encoding as opposed to regular church encoding?  I expect dual makes constant-factor better code, but would they both fuse?
01:31:45 <dons> church encoding? you mean the encoding of numbers in function arity?
01:32:05 <dons> 1=f() 2= f (f ())  3 = f(f(f(())) ..
01:32:06 <sorear> forall b. ((a -> b -> b) -> b -> b)
01:32:15 <sorear> that's one form
01:32:28 <sorear> I mean coding lists using foldr rather than unfoldr
01:32:55 <dons> we don't know how to produce effficient code from abstract folds.
01:33:02 <dons> but the dual, the unfoldr, its obvious.
01:33:12 <dons> there's definitely a paper in working out how to do this via its dual.
01:33:33 <dons> i wouldn't talk about church encoding, though, sorear. that's just confusing.
01:35:40 <cpoucet> grr
01:35:56 <dons> ?check \s -> map toUpper s == unfoldr (\s -> case s of [] -> Nothing; (c:cs) -> Just (toUpper c, cs)) s
01:35:58 <lambdabot>  OK, passed 500 tests.
01:36:04 <dons> ?src map
01:36:04 <lambdabot> map _ []     = []
01:36:04 <lambdabot> map f (x:xs) = f x : map f xs
01:37:41 <dons> unfoldr++
01:39:03 <dons> sjanssen: do you notice that kill no longer works on firefox windows?
01:39:13 <dons> i wonder if the X11 changes broke the destory notify code
01:39:23 <foxy-om> dcoutts I figured out how to allow c2hs'd  original .h files and .chs -> .h  files have the the same name... use #ifndef __FOO_H__, #define __FOO_H__  <> #endif around the test that c2hs ejects into its .h file (of course they can't be in the same directory)
01:39:35 <foxy-om> s/test/text/
01:39:52 <dcoutts> foxy-om: interesting
01:40:20 <dons> dcoutts: i get this weird feeling: i look at unfoldr and the whole stream fusion thing is obvious!
01:40:21 <dcoutts> foxy-om: imho, c2hs should just generate .h files that will not clash, eg use <filename>.chs.h or something
01:40:29 <dons> i think we've been thinking about this too much.
01:40:33 <dcoutts> dons: heh heh
01:40:37 <foxy-om> dcoutts, true
01:40:49 <dcoutts> dons: everything is obvious in retrospect
01:41:36 <LoganCapaldo> its still not obvious to me :)
01:41:46 <dons> true.
01:42:00 <dons> LoganCapaldo: probably the best way to understand it is to fuse some code on paper
01:42:05 <dons> start with, say, map f . map g
01:42:11 <dons> rewrite it to the fused forms.
01:42:12 <dcoutts> LoganCapaldo: or write some Stream code
01:42:19 <dons> apply the fusion rule to remove: stream . unstream
01:42:34 <dons> then combine the stream functions.
01:42:42 <dcoutts> eg make a function :: Stream a -> Stream a that converts CR/LF pairs to just LF
01:42:54 <dcoutts> erm Stream Char -> Stream Char
01:43:17 <dons> you could try Stream a -> Stream a for CR/LF, but that might be hard... ;-)
01:43:46 <dcoutts> CR :: forall a. a
01:50:12 <hpaste>  LoganCapaldo pasted "dons, dcoutts: Would it look like this?" at http://hpaste.org/1298
01:50:44 <dcoutts> LoganCapaldo: you can't inspect the tail like that
01:50:52 <dcoutts> it's not a list, it's the following state
01:50:59 <dcoutts> Yield '\r' ('\n':xs) -> Yield '\n' xs
01:51:12 <LoganCapaldo> Hmm
01:51:13 <dcoutts> you can't use that pattern: ('\n':xs)
01:51:23 <LoganCapaldo> oo!
01:51:29 <LoganCapaldo> wait lemem try 1 more time
01:51:32 <LoganCapaldo> I think I got it
01:51:50 <dcoutts> you can't pattern match that state at all in fact since you don't know what type it is
01:51:58 <dcoutts> (it's got an existential type)
01:54:23 <dcoutts> writing stream code is a bit like writing event based rather than threaded code
01:54:29 <hpaste>  LoganCapaldo annotated "dons, dcoutts: Would it look like this?" with "new try" at http://hpaste.org/1298#a1
01:54:51 <dcoutts> LoganCapaldo: an improvement
01:54:53 <dcoutts> however...
01:55:27 <dcoutts> what happens if the second call to next0 returns Done or wore, Skip?
01:55:51 <dcoutts> LoganCapaldo: in the paper we say: in each step do at most one thing in each step
01:56:10 <dcoutts> ie never calling next0 more than once in a single step
01:56:23 <LoganCapaldo> Mmm
01:57:05 <LoganCapaldo> Ahhm
01:57:15 <LoganCapaldo> Ok, I'm gonna give this another go :)
01:57:57 <dcoutts> ok :-)
01:58:24 <dcoutts> other thing the paper notes is that most non-trivial functions on streams need non-trivial stream state types
01:59:28 <dons> yeah, the in-tricky-cies of the list functions are exposed for all to see, in the type.
02:00:36 <LoganCapaldo> drat
02:00:47 <dcoutts> aye, you never knew intersperse was so complex! :-)
02:01:01 <LoganCapaldo> I seem to have hit a brick wall
02:01:18 <LoganCapaldo> I'm itching to recurse
02:01:20 <dcoutts> LoganCapaldo: so you need at least two states
02:01:27 <dcoutts> LoganCapaldo: heh, no recursion :-)
02:01:47 <dcoutts> LoganCapaldo: you need to know if the previous character was a CR
02:01:56 <LoganCapaldo> right
02:02:07 <LoganCapaldo> its a fsm
02:02:16 <LoganCapaldo> sooo
02:02:29 <LoganCapaldo> How do I add some state to this bugger...
02:03:06 <plutonas> hello, anyone running xmonad?
02:04:15 <dcoutts> LoganCapaldo: ( , )    (or if you're actually using our lib, it's ( :!: ) for strict pairs)
02:04:27 <dcoutts> plutonas: yep, several (but not me)
02:04:42 <dcoutts> just ask your Q
02:04:50 <LoganCapaldo> dcoutts: heh no not really using the lib.
02:04:51 <plutonas> i have problems installing it, it says: Setup.lhs: cannot satisfy dependency X11>=1.1
02:05:07 <plutonas> which i find strange
02:05:37 <dcoutts> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/X11-1.2
02:05:39 <lambdabot> http://tinyurl.com/26np6m
02:05:45 <dcoutts> plutonas: that might work ^^
02:06:05 <dcoutts> generally there's lots of stuff on http://hackage.haskell.org/
02:06:06 <lambdabot> Title: HackageDB: introduction
02:06:24 <dcoutts> @where hackage
02:06:24 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
02:06:32 <plutonas> thanks dcoutts let me try it
02:06:38 <dcoutts> @where+ hackage http://hackage.haskell.org/
02:06:39 <lambdabot> Done.
02:06:41 <dcoutts> @where hackage
02:06:42 <lambdabot> http://hackage.haskell.org/
02:06:47 <dcoutts> that's better
02:07:06 <LoganCapaldo> dcoutts: is the type of the function still gonna be Stream Char -> Stream Char then though?
02:07:14 <dcoutts> LoganCapaldo: yep
02:07:21 <LoganCapaldo> mmm
02:07:22 <dcoutts> LoganCapaldo: the internal state type is hidden
02:07:40 <dmead> hey channel
02:08:26 <plutonas> dcoutts: as i don't know any haskell, could you help me install that package?
02:08:30 <plutonas> i don't see a readme
02:08:43 <dcoutts> plutonas: you need to use cabal
02:09:04 <plutonas> how do i do this?
02:09:05 <dcoutts> cabal is the haskell package builder / installer system
02:09:18 <plutonas> i think i installed that
02:09:24 <dcoutts> runghc Setup.hs configure; runghc Setup.hs build; runghc Setup.hs install
02:09:41 <dmead> :t +++
02:09:44 <lambdabot> parse error on input `+++'
02:09:49 <dmead> @hoogle +++
02:09:50 <lambdabot> Control.Arrow.(+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
02:09:50 <plutonas> i see
02:09:51 <lambdabot> Text.Html.(+++) :: (HTML a, HTML b) => a -> b -> Html
02:09:51 <lambdabot> Text.ParserCombinators.ReadP.(+++) :: ReadP a -> ReadP a -> ReadP a
02:10:11 <plutonas> dcoutts: thanks
02:10:56 <dcoutts> plutonas: some day there'll be a nice easy single command that downloads it and does everything, but that's not quite released yet
02:11:20 <plutonas> :-)
02:12:22 <dmead> @google portage
02:12:28 <lambdabot> http://www.portage.org.uk/
02:12:28 <lambdabot> Title: Portage is a home-visiting educational service for pre-school children with addi ...
02:12:34 <dmead> hah
02:14:25 <plutonas> xmonad is now compiling
02:15:33 <kolmodin> dons: hehe, yes yes, a binary paper.. ;)
02:16:11 <plutonas> it also statrted :-) if i only knew the bindings or could find a manual
02:17:42 <yiwin> hello, i dont understand what is "x"  (i know it is type Var)  in   "let Just x = lookup "bar" [("foo", 1), ("bar", 2), ("baz", 3)] "
02:17:48 <foxy-om> dons: typo: page 7, col 2, para 2, inlined /and/ subsequently specialised
02:18:15 <LoganCapaldo> Ah man
02:18:20 <LoganCapaldo> its 5 in the morning
02:18:24 <LoganCapaldo> I should be asleep
02:18:32 <LoganCapaldo> not writing code I don't understand :)
02:18:51 <LoganCapaldo> night. thanks for the help dcoutts and dons
02:19:03 <dcoutts> g'night LoganCapaldo
02:19:21 <kolmodin> hia dcoutts
02:19:35 <dcoutts> @arr
02:19:36 <lambdabot> I'll crush ye barnacles!
02:19:43 <dcoutts> hia kolmodin :-)
02:19:56 <kolmodin> nice to rest a little after turning in that paper? :)
02:20:59 <dcoutts> kolmodin: oh yes
02:21:02 <yiwin> let Just x = lookup "bar" [("foo", 1), ("bar", 2), ("baz", 3)]
02:21:03 <yiwin> What is be leted . pls help me!
02:21:32 <dcoutts> yiwin: I'm not sure what you're asking exactly
02:24:15 <yiwin> sorry my english.  i see  let is bind. but i dont understand  "let just x"  what it is?
02:24:17 <yiwin> let Just x = lookup "bar" [("foo", 1), ("bar", 2), ("baz", 3)]
02:24:40 <glguy> Just is a data constructor
02:24:58 <glguy> so you are pattern matching on the result of lookup
02:25:14 <foxy-om> is it possible to use Oleg-foo to raise a value to a type?
02:25:38 <glguy> in this case x is being bound to 2
02:25:52 <_Cactus_> hi
02:26:01 <_Cactus_> total haskell n00b here
02:26:02 <yiwin> who be binded? Just or x?
02:26:10 <glguy> only x
02:26:23 <glguy> > let Just x = Just 3 in x
02:26:24 <lambdabot>  3
02:26:43 <_Cactus_> how do I create a type that's value-set is some fixed interval of the integers? i.e. I want something like data CellValue = 1 | 2 | ... | 9
02:27:17 <stefanha> Hi.  I'm trying to use STUArray and following the Haskell Wikibook.
02:27:18 <stefanha> a <- newArray (0, 255) 0 :: ST s (STUArray s Int Int)
02:27:20 <stefanha> gives:
02:27:26 <stefanha> Couldn't match expected type `ST s'
02:27:33 <stefanha>        against inferred type `STUArray s Int'
02:27:47 <yiwin> oh, lookup is return "Just 3".  it is rigt
02:28:01 <stefanha> I'm not familiar enough with the type system to understand what's going on here.
02:28:05 <stefanha> Any ideas?
02:28:18 <glguy> !past
02:28:19 <glguy> !paste
02:28:19 <hpaste> Haskell paste bin: http://hpaste.org/
02:28:48 <_Cactus_> or should I do something lame like data CellValue = CV1 | CV2 | .. | CV9?
02:29:29 <dons> foxy-om: thanks. fixed.
02:29:34 <glguy> _Cactus_: you can't define a type to be some fixed range of integers
02:29:42 <yiwin> pattern match. i see. THX!
02:30:21 <_Cactus_> glguy: so... just create 9 constructors?
02:30:21 <hpaste>  stefanha pasted "STUArray stumped" at http://hpaste.org/1299
02:30:27 <glguy> _Cactus_: yeah
02:30:31 <plutonas> dons: you are one of xmonad's writters, is that right?
02:30:41 <_Cactus_> glguy: looks awful... thanks!
02:30:46 <dons> plutonas: yep :-)
02:30:50 <plutonas> Is there anywhere a manual or something?
02:30:57 <dons> there's Config.hs
02:31:04 <plutonas> i just installed it
02:31:10 <glguy> stefanha: You are trying to run the array
02:31:11 <dons> and it follows the keybinding conventions of dwm, if you've used dwm.
02:31:16 <dons> check in Config.hs for the documentation.
02:31:24 <dons> we'll add a full doc page once 0.1 is released.
02:31:27 <plutonas> ok, let me check, i newer used dwm
02:31:48 <stefanha> glguy: currently not even trying to run it.
02:32:02 <glguy> stefanha: a <- newArray (0,255) 0
02:32:08 <glguy> this might as well run newArray
02:32:11 <glguy> and assign the result to a
02:32:13 <plutonas> what does the mod on the bindings mean? is that meta key?
02:32:15 <glguy> your next line:
02:32:18 <glguy> a
02:32:26 <glguy> this tries to run the array that you returned previously
02:32:31 <glguy> which doesn't mean anything
02:32:45 <glguy> did you want:
02:32:47 <glguy> return a
02:32:47 <glguy> ?
02:33:18 * stefanha blushes
02:33:20 <stefanha> thanks
02:35:15 <plutonas> dons: are there only these 16 bindings?
02:35:28 * plutonas is used to rp...
02:36:08 <plutonas> can't i split vertically for example?
02:50:16 <dons> plutonas: mod-space
02:50:27 <dons> cycles between vertical, horizontal and full screen mode
02:50:35 <plutonas> hm
02:50:39 <plutonas> thanks
02:50:55 <dons> and mod-1,2,3,4 .. gives you new workspaces
02:51:08 <dons> so you got it built ok?
02:51:17 <dons> (and you've not used haskell before?)
02:52:06 <cpoucet> dons: maybe you know this, what's the reasoning behind upfront abstract submission
02:52:27 <dons> upfront? you mean, abstract a couple of days before the deadine?
02:52:32 <cpoucet> yes
02:52:38 <cpoucet> well, a week in this case
02:52:47 <dons> i think its to encourage people to commit to getting the paper done.
02:52:54 <dons> but i'm not sure the precise reasoning.
02:52:56 <cpoucet> doesn't submission deadline do that?
02:53:16 <dons> yeah, plenty of conferences don't hve early abstract deadlines.
02:53:28 <plutonas> dons: yes i built it ok... And never used haskell before, the code seems chinese to me :-)
02:54:00 <cpoucet> dons: I can understand if it's extended abstract and early reject is based on that, but this is just a regular one, the same one you typically fill in during paper submit on the website
02:54:06 <plutonas> but ok, i am used to the concept of tiled wm's, and followed the instructions, and asked some stuff here
02:54:11 <dons> plutonas: well, i'm glad that you were able to build it -- especially since so far we've only really set it up for haskell people.
02:54:15 <dons> plutonas: great.
02:54:28 <plutonas> was not that difficult...
02:54:37 <dons> plutonas: notice its rather small :-) that's the main reason to do it in haskell -- conciseness.
02:54:51 <plutonas> yes i know, 400 lines i think?
02:55:04 <dons> yeah. just over that at the moment.
02:55:13 <dons> i plan to do a bit of cleaning up though, before the release.
02:55:22 <dons> the feature set is fixed for now, though.
02:55:58 <dons> let me know what you think.
02:56:05 <plutonas> i see, it is interesting, but i don't think i will use it regularly, at least not before i learn haskell ;-)
02:56:26 <dons> oh, is it missing anything you'd consider essential?
02:56:55 <dons> we intend it to be a serious competitor in the tiled wm market.
02:57:32 <plutonas> nope, but i should do a lot of configuration to get the bindings etc as i like them... and i think i should know at least some basic haskell for that
02:57:43 <dons> yeah, that might be useful.
02:57:56 <dons> the config file is just a haskell module, so you can write arbitrary haskell code to configure it.
02:58:05 <dons> simple changes should be possible without knowing any haskell though
02:58:27 <plutonas> i currently use stumpwm, and was ratpoison user for some years, so I am used to these bindings/features
02:58:36 <plutonas> by the way, why the dmenu?
02:59:10 <dons> dmenu is a rather nice way to launch apps, we find.
02:59:21 <dons> do you use something else for simialr purposes?
03:00:09 <plutonas> have you used rp or stumpwm?
03:00:22 <dons> nope, i'm an ion->wmii->dwm user.
03:00:23 <plutonas> there is a binding: C-t !
03:00:38 <dons> and how does it accept input?
03:00:42 <plutonas> and there comes up a small bar on top where you can insert a command to execute
03:00:43 <dons> via a prompt?
03:00:46 <plutonas> yes
03:00:48 <dons> ok. so like dmenu?
03:00:53 <plutonas> that would be interesting...
03:01:02 <dons> yes.
03:01:09 <dons> it should be possible to do that simply with a small X app
03:01:26 <plutonas> i couldn't manage to use dmenu... I have to admit that, probably i have to configure what apps will be used
03:01:26 <dons> i find i type less with dmenu
03:01:39 <dons> oh?
03:01:46 <dons> it didn't work at all?
03:01:55 <plutonas> i got a blue stripe on the top
03:02:08 <dons> yeah, and then you type in some characters?
03:02:19 <dons> it should then auto-complete using the programs visible in $PATH
03:02:39 <plutonas> oh
03:02:41 <wolverian> I'd like bash's smart autocompletion there.
03:02:45 <dons> (you can test it in a shell, by typing dmenu_path to find what commands dmenu sees)
03:02:58 <plutonas> dons: sorry i thought dmenu was something else
03:03:13 <plutonas> i thought i had tried it in the past
03:03:19 <dons> oh ok. so it does work as I described?
03:03:23 <plutonas> yes
03:03:39 <plutonas> dons: by the way, xmonad seems pretty stable, is it so?
03:03:50 <dons> yeah. seems to be.
03:04:01 <plutonas> :-)
03:04:03 <dons> after about 3 days it was usable, and its had very few bugs since then.
03:04:09 <dons> i use it exclusively since about the start of march
03:04:15 <dons> so yes, i'd say it is pretty stable.
03:04:30 <plutonas> i suppose that has to do with functional programming
03:04:33 <plutonas> :-)
03:04:44 <dons> yeah :-)
03:04:51 <dons> less bugs, faster develoment, less code.
03:05:16 <dons> though X is a awkward protocol.
03:05:30 <plutonas> well i learn lisp atm but from what i've heard it's not "as functional" as haskell
03:06:15 <dons> no, it a rather old fashioned functional language, more from the 1970s.
03:06:36 <dons> so it misses many of the improvements made to functional languages since then, like static typing, pattern matching and syntax.
03:06:40 <plutonas> anyway, another thing i like is the lack of a prefix key, but that could possibly cause problems if an application has the same binding
03:06:42 <dons> all of which improve xmonad a fair bit.
03:06:51 <dons> yeah, some emacs users complain.
03:06:56 <dons> (they have to set mod=mod4)
03:06:58 <plutonas> you talk about lisp? or haskell?
03:07:09 <dons> lisp is an old fashioned haskell
03:08:07 <plutonas> hm, i don't know haskell but i would say it is old-fashioned...
03:08:08 <dons> anyway, time for dinner. welcome! oh, yes, also, we hope to have the xmonad@haskell.org mailing list set up tomorrow.
03:08:15 <plutonas> sorry i mean lisp
03:08:17 <dons> if you're still around, i'll ping you when it is set up.
03:08:25 <plutonas> ok
03:09:17 <foxy-om> dcoutts: if I have a pointer to C land and I want to query a flag in the C structure, will using unsafePerformIO to make a pure function mean that I won't pick up a change on the C side?
03:10:04 <dcoutts> foxy-om: right, it means that the haskell compiler is free to cache the value and may not re-evaluate it
03:10:15 <foxy-om> ok, ta
03:10:22 <dcoutts> foxy-om: sounds like you should not try to pretend that thing is pure, as it clearly is not.
03:10:29 <foxy-om> :)
03:16:13 <Heffalump> cpoucet: the point of early abstracts is so that the PC can decide who should review what paper before the final papers arriv
03:16:16 <Heffalump> e
03:16:36 <cpoucet> Heffalump: erm, right, and when you submit the papers.... and put the abstract thre, what's the diff?
03:16:41 <Heffalump> so the schedule becomes more efficient because the final writing of the paper by the authors and the choosing of papers to review can overlap
03:16:42 <RyanT5000> is it evil to avoid the Q monad when working with TH?
03:16:58 <Heffalump> cpoucet: deciding who should review what just needs the abstracts
03:16:59 <dons> Heffalump: aha.
03:17:16 <dons> well, those lucky enough to get on review comittees of course would know this ;-)
03:17:23 <Heffalump> :-p
03:17:27 <cpoucet> Heffalump: I guess, so its to gain that week
03:19:38 <RyanT5000> as far as i know, all my names either (1) must be properly supplied by the library user; or (2) are defined in a let or something, so scoping would work properly
03:19:58 <Heffalump> RyanT5000: don't see why then
03:20:05 <Heffalump> avoiding a monad where possible always seems like a good idea
03:20:20 <RyanT5000> yeah, the thing is just that i can't use [| |], etc.
03:20:23 <RyanT5000> which is a real pain
03:20:38 <RyanT5000> my experience with haskell has generally that something that's a pain is usually evil
03:20:42 <RyanT5000> (sometimes subtly)
03:20:45 <RyanT5000> so i wanted to check
03:20:49 <Heffalump> dons: I was never on any while I was a PhD student, FWIW
03:21:14 <Heffalump> I'm not particularly experienced with TH, I've only used it a bit and I probably just used Q when I did.
03:21:55 <dons> yeah, i think that's usual, Heffalump. i'm not aware of other phd students who been on committees in recent years.
03:22:37 <Heffalump> so, when are you going to finish yours? :-)
03:23:19 <dons> August :-)
03:23:32 <dons> i've cleared the decks now, paper wise. (well, almost).
03:23:35 <Heffalump> cool
03:23:37 <dons> so nothing left to do but write.
03:24:03 <Heffalump> no HW paper?
03:24:13 <dons> actually, yeah, there's a few planned...
03:24:17 <Heffalump> good good :-)
03:24:21 <dons> you're on the panel this year, right?
03:24:36 * cpoucet SO wishes he could go to HW
03:24:41 <Heffalump> yep
03:24:44 <cpoucet> I was even planning to submit a paper :(
03:24:50 <cpoucet> but it's the 30th of sept
03:24:51 <Heffalump> so it's my duty to encourage submissions
03:25:02 <RyanT5000> so... i'm sitting here at law school... writing a piece of a game engine in haskell
03:25:09 <dons> yes, Gabi too has been demanding submissions.
03:25:12 <cpoucet> Heffalump: move it down a week!
03:25:13 <RyanT5000> i'm not exactly sure why that first bit is in there, lol
03:25:31 <Heffalump> cpoucet: we're at the mercy of the ICFP organisers for scheduling, AFAIK (not that I was involved with it)
03:25:35 <cpoucet> :(
03:25:40 <Heffalump> what's wrong with that date?
03:25:41 * cpoucet was so wanting to submit this year and go
03:25:51 <cpoucet> a) that's the day I come back from greece from a research collab
03:25:55 <cpoucet> b) that's during another conf
03:26:24 <Heffalump> what conf?
03:26:39 <cpoucet> codes/isss + cases + EMSOFT
03:26:50 * dons `ap` dinner
03:28:22 <Heffalump> clearly you just have your priorities wrong ;-)
03:28:54 <cpoucet> Heffalump: not if you considr the context of my phd
03:29:24 <cpoucet> unless that was a joke
03:29:48 <cpoucet> I might still submit
03:29:53 <RyanT5000> Heffalump: was that directed at me ?
03:29:54 <RyanT5000> lol
03:30:04 <beelsebob> anyone fancy playing with a types question?
03:30:23 <cpoucet> beelsebob: shoot
03:30:25 <ndm> beelsebob: succesfully submit?
03:30:42 <hpaste>  beelsebob pasted "Probably needs dependant types" at http://hpaste.org/1300
03:30:44 <beelsebob> ndm: yeh
03:30:53 <beelsebob> I can show you in a min
03:31:08 <beelsebob> cpoucet: so... the idea is to faithfully represent the things that can be in a PDF
03:31:11 <beelsebob> which works nicely
03:31:17 <cpoucet> k
03:31:22 <beelsebob> except for the stream object
03:31:37 <Heffalump> RyanT5000: no, cpoucet
03:31:41 <ndm> beelsebob: cool, looking forward to a copy
03:31:42 <vincenz> Heffalump: vincenz ;)
03:31:43 <beelsebob> which gets various bits of information about the stream
03:31:47 <RyanT5000> Heffalump: ah, ok :)
03:31:53 <RyanT5000> same problem here, though, arguably
03:32:15 <vincenz> beelsebob: and?
03:32:20 <beelsebob> for example, the third part of the PDFStream constructor (Maybe DirectObject) gives information about which filter to apply
03:32:29 <beelsebob> the problem is... it may not be *any* direct object
03:32:34 <beelsebob> it may only be a name or an array
03:32:46 <beelsebob> similarly, the next one may only be a dictionary or an array
03:32:50 <vincenz> beelsebob: oh
03:32:52 <Heffalump> can you use GADTs?
03:32:52 <vincenz> easy
03:32:55 <vincenz> you want GADTS
03:33:05 <beelsebob> no I don't
03:33:10 <beelsebob> trying to stick with H98 here
03:33:11 <vincenz> yes you do :)
03:33:15 <Heffalump> btw, you've misspelt Dictionary :-)
03:33:17 <vincenz> beelsebob: rght, and dep-types are h98?
03:33:22 <beelsebob> one of the requirements here is that it's Haskel 98
03:33:30 <beelsebob> vincenz: exactly why I'm not using them :P
03:33:39 <vincenz> beelsebob: your title was misleading
03:33:43 <beelsebob> Heffalump: thanks, I'd never have spotted that
03:33:46 <vincenz> beelsebob: it should say "probably needs GADTS" :P
03:33:47 <beelsebob> vincenz: probaly :)
03:33:51 <beelsebob> haha
03:34:24 <ndm> beelsebob: you don't need GADT's,  you need more refined types
03:34:25 <vincenz> well I guess existentials are out too
03:34:26 <beelsebob> okay... so with the additional constraint of sticking within H98's type system -- anyone see any nice way of handling this?
03:34:42 <beelsebob> I can see a nasty way of doing it
03:35:04 <ndm> beelsebob: split directobject into filterobject and have directobject contain filterobject's, and other things
03:35:15 <vincenz> yep
03:35:23 <vincenz> one more layer of indirection
03:35:23 <beelsebob> ndm: yeh, that was pretty much the nasty way of dealing with it :/
03:35:37 <beelsebob> which is nasty in that it stops reflecting the spec
03:35:52 <ndm> beelsebob: the spec is untyped, you want a typed rep
03:35:55 <beelsebob> but nice in that it enforces it
03:36:22 <ndm> beelsebob: personally, i'd just leave it as is,  and use Catch with invariant hunting to specify the restriction
03:36:35 <beelsebob> yeh, I think that's what I'm gonna do
03:36:46 <vincenz> and use play for traversal :)
03:36:55 <ndm> naturally :)
03:37:12 <ndm> i would definately use Play for traversals, Catch is more experimental, but i can't live without Play
03:37:40 <ndm> the lack of Play support for template haskell is really starting to annoy me
03:38:09 <beelsebob> ndm: paper swap? http://www.cs.kent.ac.uk/people/rpg/tatd2/icfp07.pdf
03:38:11 <Heffalump> what are Play and Catch?
03:38:35 <ndm> Heffalump: you'll read about Play for Haskell Workshop, think a type-safe H98 version of SYB, but easier to work with
03:38:35 <beelsebob> @where catch
03:38:36 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/catch/
03:38:44 <ndm> Catch is a static checker for pattern matching
03:39:28 <ndm> beelsebob: i'll just get a pdf of it ready...
03:42:07 <ndm> http://www-users.cs.york.ac.uk/~ndm/private/catch-icfp2007.pdf
03:42:12 <ndm> beelsebob: ^^^
03:42:17 <beelsebob> thx :)
03:42:23 <beelsebob> lol
03:42:28 <beelsebob> I like the "Affliction"
03:42:30 <vincenz> punny phds
03:42:40 * beelsebob pats vincenz 
03:43:00 <ndm> beelsebob: your style is completely different to mine....
03:43:21 * beelsebob notes that's true
03:43:24 <beelsebob> what the hell happened there
03:43:55 <ndm> anyone got a third ICFP paper?
03:44:02 <vincenz> you lot's abstract isn't italics?
03:44:05 <ndm> there was one on l-t-u
03:44:21 <beelsebob> l-t-u?
03:44:26 <vincenz> lambda the ultimate
03:44:26 <beelsebob> oh, I see
03:44:32 <beelsebob> looking for which is the right style
03:44:51 <vincenz> they don't differ that greatly
03:44:53 <vincenz> same sized font
03:44:55 <vincenz> doubel column
03:45:00 <beelsebob> indeed -- they're both ACM ones
03:45:14 <ndm> beelsebob: mine agrees, http://conal.net/papers/Eros/eros.pdf
03:45:37 <beelsebob> ndm: arse, indicates we found the wrong file on the ACM website
03:45:54 <vincenz> beelsebob: english?
03:45:57 <beelsebob> oh well, I'm sure we'll get a reviewer comment saying "fix the damn style"
03:46:10 <beelsebob> vincenz: english??
03:46:23 <ndm> your font looks one or two pt above mine, were you short of space to the end?
03:46:27 <vincenz> it's not very erm...doubly blind if you people pass around your paers...
03:46:29 <vincenz> beelsebob: 'arse
03:46:30 <vincenz> '
03:46:55 <vincenz> and ndm
03:47:00 <ndm> on the assumption that none of the reviewers are on IRC (which I'm pretty sure they aren't) its fine
03:47:00 <vincenz> you have a reference to yourself
03:47:04 <Heffalump> I think the point is that the reviewers will try not to go looking.
03:47:05 <beelsebob> vincenz: hehe, indeed, it's not very doubly blind when there's only 3 people who could have done the work, and 3 people who know them who could review it
03:47:05 <vincenz> that should be 'omitted for blind review'
03:47:29 <beelsebob> vincenz: why? That would make it more obvious
03:47:34 <ndm> vincenz: i had to reference my previous work, 3 reviewers have cited or referreed the previous work
03:47:42 <vincenz> ndm: still holds
03:47:52 <Heffalump> how do you know who the reviewers are?
03:48:01 <vincenz> wat's with the non-numbering of refs?
03:48:14 <beelsebob> Heffalump: because there's only a few people who would be given a paper on algorithmic debugging to review
03:48:25 <vincenz> ndm: ah, at least it's third person :)
03:48:26 <beelsebob> vincenz: that's ICFP's style
03:48:28 <ndm> vincenz: no, if i refer to "the static checking paper from TFP", 3 will guarantee know without doubt who I am - this has some doubt (albeit not much)
03:48:33 <ibid> vincenz: it's a better style, and iirc preferred by acm nowadays :)
03:48:37 <ndm> Heffalump: PC members :)
03:48:46 <vincenz> ibid: my current is acm template and it's numbered
03:48:59 <ndm> vincenz: you have to add some stuff at the top, to fix the references
03:49:01 <RyanT5000> what's the most elegant way to write an accessor?
03:49:06 <beelsebob> ndm: it appeals that we still comply with the required style -- "Your submission must be at most 12 pages (4 pages for an Experience Report), including bibliography and figures, in the standard ACM conference format: two columns, nine-point font on a ten-point baseline, with pages 20pc (3.33in) wide and 54pc (9in) tall, with a column gutter of 2pc (0.33in)." is the only requirement
03:49:10 <ndm> RyanT5000: records
03:49:22 <RyanT5000> ndm: with updates
03:49:29 <ndm> RyanT5000: records :-)
03:49:34 <RyanT5000> e.g.: let's say i have:
03:49:34 <RyanT5000> data A = A x y z
03:49:44 <RyanT5000> now i want to modify the x
03:49:45 <vincenz> data A = A { x :: x, y::y, z::z}
03:49:54 <vincenz> though that's not possible
03:49:58 <vincenz> you probably meant some type names
03:50:06 <RyanT5000> yes, i know
03:50:07 <Heffalump> data A = A { xA :: x, yA :: y, zA :: z }
03:50:07 <vincenz> data A = A { x :: TypeOfx, y::TypeOfy, z::TypeOfz}
03:50:12 <vincenz> Heffalump: nope
03:50:14 <RyanT5000> i'm *quite* aware of records
03:50:18 <Heffalump> oh, yeah
03:50:18 <RyanT5000> and they don't do what i want at all
03:50:22 <ndm> a{x = "neil"}
03:50:28 <Heffalump> but they provider accessors and updaters
03:50:34 <Heffalump> the updaters aren't first class values, annoyingly
03:50:35 <vincenz> a{x = (x a) + 1}
03:50:42 <beelsebob> RyanT5000: replaceX (A x y z) x' = A x' y z
03:50:47 <beelsebob> surely?
03:50:51 <RyanT5000> ok well here's what i was thinking about
03:51:31 <RyanT5000> a function something like: State A a -> State x a
03:51:45 <beelsebob> why on earth should it be in the state monad?
03:52:02 <RyanT5000> ok so let's say i have like 5 functions
03:52:12 <vincenz> modify (\s -> s{foo = (foo s) + 1})
03:52:14 <RyanT5000> each of which updates one component of the overall thing
03:52:16 <ndm> modify $ \x -> value{field=x}
03:52:23 * vincenz beeps ndm 
03:52:38 <ibid> vincenz: dunno about that, i'm using the acm style in my current work, and it's unnumbered :)
03:52:44 * beelsebob boops vincenz 
03:53:03 <RyanT5000> ok well i've tried all of the things listed
03:53:09 <RyanT5000> but i forget my complaints
03:53:09 <vincenz> and?
03:53:16 <RyanT5000> i'll come back when i have something interesting to say
03:53:18 <beelsebob> RyanT5000: what about replaceX (A x y z) x' = A x' y z
03:53:19 <ndm> RyanT5000: paste what fails for you :)
03:53:25 <RyanT5000> it's not so much fail
03:53:33 <vincenz> beelsebob: I'd flip the arguments
03:53:34 <RyanT5000> as "has an extra token or two when you use it"
03:53:34 <RyanT5000> :P
03:53:38 <vincenz> beelsebob: easier to use for modify funcs
03:53:39 <beelsebob> vincenz: probably, yes
03:54:00 <beelsebob> RyanT5000: extra tokens are good -- they explain what you're doing
03:54:01 <vincenz> RyanT5000: use the cPP
03:54:07 <ibid> vincenz: (transactions style, that is. conferences may take different approach)
03:54:20 <RyanT5000> cPP?
03:54:22 <vincenz> ibid: let me fetch one
03:54:28 <beelsebob> ndm: it may be that you've used the 9pt style and we've used the 10pt style
03:54:30 <vincenz> http://www.esat.kuleuven.ac.be/~cpoucet/scopes2007.pdf
03:54:38 <ibid> vincenz: http://www.acm.org/pubs/submissions/latex_style/index.htm
03:54:38 <vincenz> ack
03:54:40 <lambdabot> Title: latex_style
03:54:47 <RyanT5000> beelsebob: not always
03:54:47 <ndm> beelsebob: possibly, we just tried to stick as close as we could to the style - its a bit hard though
03:55:10 <beelsebob> ndm: hmm, why do you say that?
03:55:15 <vincenz> http://www.esat.kuleuven.ac.be/~cpoucet/papers/scopes2007.pdf
03:55:16 <ndm> beelsebob: i am sure with teh quality of both our submissions, style will be not on the referees minds :)
03:55:23 <beelsebob> obviously :D
03:55:24 <beelsebob> :P
03:55:39 <beelsebob> and I'm sure we can read that either way we like
03:55:40 <vincenz> ndm: obviously you haven't met reviewers :)
03:55:46 <ndm> beelsebob: instructions everywhere, lots of different bits, references
03:55:57 <beelsebob> ndm: ah yes, very true
03:56:00 <vincenz> "hmm, looks boring, let's check the abstract...yep...boring...boring, what are the conclusions?  no 100% gains...blegh"
03:56:05 <ndm> vincenz: actually i presented to two of the PC members on Thursday, carefully avoiding mentioning what my work was
03:56:23 <ndm> vincenz: i have 100% gains :) - check the conclusion, and teh results
03:56:27 <vincenz> ah
03:56:34 <vincenz> maybe they'll read it then :)
03:56:35 <ndm> more like 1000% gains over the previous best
03:56:55 <vincenz> in what?
03:57:08 <RyanT5000> oh
03:57:16 <RyanT5000> here's the problem with the replace function
03:57:22 <RyanT5000> it's anti-DRY
03:57:32 <RyanT5000> because you also need a separate project function
03:57:39 <vincenz> RyanT5000: eh?
03:57:49 <RyanT5000> you need one function getX
03:57:53 <RyanT5000> and one function replaceX
03:57:58 <vincenz> RyanT5000: not with records
03:58:08 <vincenz> data A = A {getX :: TypeofX}
03:58:08 <RyanT5000> yeah, it just happens to be implicit
03:58:17 <ndm> vincenz: automated checking for pattern match errors
03:58:18 <vincenz> RyanT5000: right, so you're not repeating yourself :)
03:58:40 <RyanT5000> ... yes you are; not to mention, that's the wrong part of speech for a record tag
03:58:42 <RyanT5000> they should be nouns
03:58:44 <beelsebob> RyanT5000: I'm pretty sure that you shouldn't need getX anyway -- 99.9% of the time I just pattern match in the function
03:58:58 <ndm> vincenz: used FiniteMap? want to crash it? used HsColour? want to crash it?
03:59:07 <RyanT5000> beelsebob: ctor may be hidden for encapsulation purposes
03:59:15 <vincenz> ndm: o.O
03:59:50 <beelsebob> fair enough
03:59:53 <vincenz> RyanT5000: imho it feels like you have a preconceived ideae of what you want, maybe state that and we can go from there?
04:00:10 <RyanT5000> not so much; i just have a large list of software engineering objections
04:00:36 <RyanT5000> although i'll give some more backgorund
04:00:41 <vincenz> personally, I think that for something this small
04:00:50 <vincenz> it's more of a stylistic concern than an 'engineering objeciton'
04:00:51 <RyanT5000> i have a datastructure whose implementation is very likely to change
04:01:09 <RyanT5000> i want to provide a stable facade
04:01:20 <vincenz> RyanT5000: make a module, hide the def, provide views
04:01:43 <RyanT5000> as in view datastructures?
04:02:09 <RyanT5000> and, as to the first two things, yes; already done
04:02:22 <RyanT5000> i mean there's this generic problem
04:03:37 <RyanT5000> that you'd like to perform some kind of transformation on a datastructure, then return a modified copy of it based on a modification of the transformed thing
04:03:49 <RyanT5000> as i said though
04:03:53 <RyanT5000> i don't remember all my reasons
04:03:57 <RyanT5000> i'll come back later :)
04:04:25 <RyanT5000> i just remember writing lots of formulaic code and being sad
04:04:33 <RyanT5000> :P
04:07:46 * beelsebob slaps Adobe
04:08:04 <beelsebob> the PDF spec is filled with "this is the spec, but don't do that, because our reader doesn't actually meet the spec"
04:10:00 <dcoutts> heh
04:10:02 <dcoutts> specs
04:12:16 <beelsebob> "by the way, acrobat actually does the exact opposite of this"
04:14:53 <beelsebob> what's most abhorent is the fact they mention their implementation at all -- it's like microsoft writing the HTML spec and constantly saying "IE completely cocks this up all the time, so try to avoid it"
04:17:52 <ndm> you mean the open document spec?
04:18:10 <beelsebob> lol
04:40:35 <dons> ndm, re. icfp reviewers in irc, there are at least a few who will end up reviewing papers, i'm pretty sure.
04:41:43 <ndm> dons: ah, true i guess - but they are meant to remain objective, and deliberately ignore us saying what paper we wrote
04:41:57 <ndm> i forgot the number of grad students who will actually end up reading papers :)
04:42:13 <dons> right.
04:42:16 <Heffalump> but since the whole point of the blind review is to avoid subconscious bias..
04:42:36 <dons> i mean, if i was asked to read ndm's paper, i'd probably have to say no, wouldn't i?
04:42:52 <ndm> i did avoid mentioning my paper on my blog, and i certainly didn't get it on to l-t-u
04:43:08 <dons> though we're still supposed to promote the work the usual ways...
04:43:09 <ndm> not sure, i guess most researchers in this area are friends
04:43:17 <dons> i.e. reddit + planet haskell + ltu .. ;-)
04:43:26 <dons> (though, i too, haven't worked out how kosher that is yet)
04:43:27 <ndm> you can still review a paper if you know the author
04:43:42 <ndm> you just have to pretend you don't
04:43:52 <ndm> and not actively search for who the author is
04:43:58 <dons> yeah, just like we used to. though we have to try harder this year, i guess.
04:44:00 <Heffalump> conflict of interest rules tend to talk about same institution or having previously coauthored
04:44:22 <ndm> well in previous years, the name was at teh top, now it isn't
04:44:24 <dons> yes, but this time its 'double blind' with proper anonymous submissions.
04:44:39 <dons> and you can't, eg. link to your web page for source code :/
04:44:46 <ndm> yeah, i know :(
04:44:47 <dons> which is not so good at all.
04:45:00 <ndm> i'm not entirely sure if i can release Catch now, or have to wait a few months
04:45:02 <dons> since then the experiments are rather hard to repeat.
04:45:15 <ndm> since the paper is about a tool, all the results are 100% correct, and i'd like to demonstrate that clearly!
04:45:17 <dons> ndm, note that conal put his paper on planet haskell, and released all the code.
04:45:36 <dons> so again, if i have to review something on 'tangible variabes' i'm going to know..
04:45:38 <ndm> dons: yes, but was that correct? i wasn't sure
04:46:05 <ndm> dons: just because you know, doesn't mean you can't review
04:46:08 <dons> the submission guide says 'promote in the usual way', but for the last 2 years that now means blogs and reddit, which everyone reads ..
04:46:11 <dons> so that's hard.
04:46:24 <ndm> yeah, i gave a talk to at least two of the PC on thursday
04:46:34 <dons> the burden is on the reviewer though, not the author
04:46:38 <ndm> it wasn't the main topic of my paper, but its section 5
04:47:04 <ndm> although it was the last day of a conference at 10am, they could have been sleeping
04:47:15 <dons> btw, yeah, got both papers in :-)
04:47:21 <ndm> cool :)
04:47:23 <augustss> is the ICFP review double blind this year?
04:47:26 <dons> damn hard work though, it wouldn't recommend doing it every week.
04:47:28 <ndm> augustss: yes
04:47:29 <dons> augustss: yeah.
04:47:33 <augustss> weird
04:47:38 <ndm> dons: list fusion and?
04:47:41 <dons> augustss: and no src code links.
04:47:59 <dons> ndm, Generative Code Specialisation for High-Performance Monte-Carlo Simulations
04:48:18 <augustss> who's PC chair?
04:48:25 <dons> Norman Ramsey.
04:48:37 * beelsebob pokes everyone
04:48:39 <ndm> augustss: it wasn't a PC decision, it was the steering committee, without consulting the PC
04:48:50 <ndm> (at least one PC member told me that)
04:48:53 <augustss> really?  tht sucks
04:49:07 <augustss> i think double blind sucks too
04:49:13 <ndm> yep, agreed!
04:49:15 <dons> i think they didn't realise this would mean no source code, either.
04:49:21 <beelsebob> why do you think double blind sucks?
04:49:40 <dons> beelsebob: well, do we get our papers on reddit now, do you think?
04:49:43 <ndm> because my work builds on my work, i can't slag off my work properly without saying it was my work
04:49:44 <dons> or ltu?
04:49:59 <beelsebob> ndm: that's true
04:50:02 <augustss> there are many reasons.  but one is that it doesn't quite work. if you are up-to-date n the field you kinda now anyway
04:50:20 <dons> yeah. and esp. in a close community like haskell's (and the larger icfp community)
04:50:27 <ndm> plus i have a cool program, which I can't release
04:50:32 <dons> where you already released the code on haskell@ anyway
04:50:40 <dons> ndm, you can though. pretty certain.
04:51:01 <dons> you just can't tell the reviewers where to get it.
04:51:05 <ndm> dons: i guess, its hard though - Catch is referred to by name in the paper, I wrote Catch etc.
04:51:10 <dons> hmm... though an anonymous link to hackage might work..
04:51:27 <ndm> but that would be the best thing about releasing, i can _proove_ that my checker does exactly what i claim it to
04:51:49 <ndm> since there wasn't room (by a long way) to attach any generated proofs for the programs it checked
04:51:58 <dons> that's the whole point, isn't it? source code is how you reproduce results in our business.
04:52:03 <ndm> yep
04:52:23 <beelsebob> ndm: that's roughly why olaf and I considered it pointles
04:52:23 <ndm> esp performance numbers, you can reliably lie by 25%, and no one can ever catch you
04:52:25 <beelsebob> not stupid
04:52:28 <beelsebob> but pointless
04:52:35 <beelsebob> because you could always figure out who's was who's
04:53:38 <ndm> if you do figure out who's who, that defeats the point
04:53:45 <beelsebob> exactly
04:53:48 <beelsebob> pointless
04:54:14 <dons> ndm, did you have a go at the spectral or real class of nofib programs?
04:54:14 <ndm> extra work to obtain pointless is stupid to me
04:54:20 <dons> they're the hard ones, of course :-)
04:54:41 <ndm> dons: actually, for pattern matches, they aren't - they are bigger, but usually more simple
04:55:08 <ndm> dons: had a brief look, but explaining the results is too hard, most of them are cmopletely not safe, and no one is interested in making them reliable
04:55:26 <ndm> that was why picking real programs was more use
04:55:48 <dons> maybe you could take alex or happy or Djinn from the 'real' class in the extended nofib (nobench)
04:55:49 <ndm> i got through ~15 of the spectral ones, before giving up because the results were consistently dull
04:56:05 <ndm> alex and happy aren't H98, are they?
04:56:15 <ndm> Djinn should be doable
04:56:16 <dons> hmm, happy would be close.
04:56:29 <ndm> dons: is teh nobench version the complete program?
04:56:36 <dons> yeah.
04:56:47 <araujo> morning
04:56:58 <ndm> dons: will try Djinn now...
04:57:02 <ndm> @where Djinn
04:57:02 <dons> needs -cpp, but not -fglasgow-exts, I think.
04:57:03 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
04:57:05 <dons> Djinn needs mtl.
04:57:19 <ndm> mtl is an issue, it needs to be Yhc compilable
04:57:23 <Heffalump> dons: did I ask you why you made nobench rather than just adding directly to nofib?
04:57:41 <dons> the build system didn't support other compilers
04:57:51 <dons> so i took the nofib programs, and rewrote the build system to be portable.
04:57:55 <dons> then added more programs.
04:58:22 <dons> ndm, yhc compatible? so that's like, um, no programs, right ;-)
04:58:27 * dons laughs insanely
04:58:31 <dons> time for more chocolate.
04:58:57 <ndm> dons: to a first approximation, yes, alas
04:59:18 <ndm> dons: of course, if GHC Core wasn't 100% broken, i can convert GHC Core -> Yhc Core, then its all GHC programs as well
05:00:43 <Heffalump> what's wrong with GHC core?
05:01:22 <ndm> Heffalump: everything, they broke it, there is no externally parseable Core data type for GHC
05:03:27 <ndm> dons: it has readline as well, quite a bit of work to get it Yhc compiling - i'll wait til teh GHC Core is working again for that one...
05:04:59 <dons> shouldn't be too hard to fix. its just a pretty printer.
05:05:15 <dons> esp. if you had an actual use for it. dive in! results to be had!
05:05:33 <ndm> paper submitted, moving onwards :)
05:05:44 <ndm> its not the pretty printer, its the parser, and the AST
05:05:47 <dons> bah. academics!
05:06:07 <ndm> i do want to get to it, but Arron Tomb (I think) says he has it almost done
05:06:43 * ndm wants to kill DrIFT this weekend
05:07:24 <Heffalump> wossitdone?
05:07:55 <ndm> nothing personal, just want something nicer :)
05:08:10 <basti_> yow :)
05:08:40 <dons> hey basti_
05:09:00 <basti_> he & hows things?
05:09:06 <beelsebob> > scanl (+) (length "%PDF-1.7\n") [54,69,34]
05:09:07 <lambdabot>  [9,63,132,166]
05:09:16 <beelsebob> perfect :)
05:10:43 <dons> ooh, fusible!
05:11:38 <dons> well, if the arg list was an enumeration, not a list constant.
05:12:21 <beelsebob> the argument list will be (map length bodyObjects)
05:12:29 <ndm> dons: what was your final performance score?
05:13:30 <dons> average 3% faster, best was 50%, programs where ghc did its job, ~10%.
05:13:52 <dons> there's still around 5% of programs that got worse due to fusion artifacts left by the compiler.
05:14:04 <dons> but hopefully spj will fix that now we can tell him precisely what the problem is.
05:14:15 <ndm> cool :)
05:14:32 <tuxplorer> A basic doubt.. fibo 1 = 1
05:14:33 <tuxplorer> fibo 2 = 1
05:14:33 <tuxplorer> fibo x = (fibo x-2) + (fibo x-1) throws segmentation fault
05:14:42 <tuxplorer> where have I gone wrong?
05:14:46 <dons> in an old version of hugs?
05:14:48 <Heffalump> it shouldn't segfault
05:14:53 <Heffalump> but your code is an infinite loop
05:14:54 <dons> that's got a classic stack overflow, there, tuxplorer
05:15:04 <dons> hehe and that.
05:15:14 <ndm> old hugs do segfault on stack overflow
05:15:20 <tuxplorer> hugs_98.200503.08-4
05:15:23 <tuxplorer> is the version
05:15:35 <ndm> upgrade
05:15:38 <dons> yeah. try ghc, or a newer hugs.
05:15:43 <dons> but the code is broken :-)
05:15:50 <dons> tuxplorer: http://haskell.org/haskellwiki/The_Fibonacci_sequence
05:15:52 <lambdabot> Title: The Fibonacci sequence - HaskellWiki
05:16:00 <tuxplorer> Thanks dons
05:16:13 <beelsebob> tuxplorer: remember -- function application binds tightest
05:16:17 <dons> > fix ((1:) . scanl (+) 1)
05:16:19 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
05:16:24 <dons> is my current favourite.
05:16:26 <beelsebob> so you've done (bo x) - 2)
05:16:29 <beelsebob> bah missed
05:16:33 <beelsebob> ((fibo x) - 2)
05:17:01 <beelsebob> > let fibs (x,y) = x:(fibs y (x + y)) in fibs
05:17:02 <lambdabot>      Occurs check: cannot construct the infinite type: t = (t, t)
05:17:03 <lambdabot>     Probabl...
05:17:06 <beelsebob> o.O
05:17:10 <beelsebob> where did that splode
05:17:12 <beelsebob> oh... I see
05:17:13 <tuxplorer> Thanks :)
05:17:24 <beelsebob> > let fibs x y = x:(fibs y (x + y)) in fibs 1 1
05:17:26 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
05:17:31 <beelsebob> that's my favourite
05:18:54 <beelsebob> hmm, is there a show function for integers that guarentees to always produced 10 digits?
05:19:02 <dons> woot, 12 RuleFired
05:19:02 <dons>     1 SC:$wunfold_unstream0
05:19:02 <dons>     3 SC:$wunfold_unstream1
05:19:02 <dons>     1 SPEC Data.Stream.$f5
05:19:02 <dons>     1 STREAM stream/unstream fusion
05:19:10 <dons> for beelsebob's scanl code.
05:19:17 <dcoutts> nice
05:19:17 <beelsebob> dons: o.O
05:19:27 <beelsebob> what does that mean?
05:19:36 <mauke> > printf "%010d" 123 :: String
05:19:38 <lambdabot>  "0000000123"
05:19:51 <beelsebob> mauke: bah, damn cisms
05:20:05 <beelsebob> @type printf
05:20:05 <mauke> someone should fix printf
05:20:07 <lambdabot> forall r. (PrintfType r) => String -> r
05:20:19 <dons> beelsebob: the generator list fuses with the scanl, yielding a single loop with no intermediate list allocated.
05:20:23 <ndm> let a ++:: b = a ++ b in "neil" ++:: "test"
05:20:27 <dons> basically the scanl is fused into the generator
05:20:31 <ndm> > let a ++:: b = a ++ b in "neil" ++:: "test"
05:20:31 <beelsebob> dons: uhh, fun
05:20:33 <lambdabot>  "neiltest"
05:20:58 <beelsebob> ndm: what was that meant to test?
05:21:13 <basti_> infix operators?
05:21:16 <beelsebob> whether you could have :: anywhere other than a type signature?
05:21:49 <ndm> beelsebob: yes, basically
05:21:59 * ndm is defining &&::, ++:: and >>::
05:23:22 <dons> beelsebob: yeah, your scanl (length ..) [list] code is fused, yielding a combined loop exactly this:
05:23:25 <dons> unfold_unstream :: GHC.Prim.Int# -> GHC.Base.Int -> [GHC.Base.Int]
05:23:27 <dons> unfold_unstream sc_sFz sc1_sFA =
05:23:30 <dons>     case ># sc_sFz 10 of
05:23:32 <dons>       False ->
05:23:35 <dons>           sc1_sFA :
05:23:37 <dons>             (unfold_unstream (+# sc_sFz 1)
05:23:40 <dons>                 (case sc1_sFA of I# x_azP -> I# (+# x_azP sc_sFz));
05:23:42 <dons> so the result is directly build.
05:23:44 <dons>       True -> sc1_sFA : []
05:23:46 <beelsebob> fun
05:23:46 <dons> foo = wunfold_unstream 1 (length "%PDF-1.7\n") 0
05:23:48 <beelsebob> nasty
05:23:49 <dons> which is nice to see.
05:23:49 <beelsebob> but fun
05:23:51 <dons> yay for streams.
05:24:15 <dons> well, luckily you don't see it. you just have to program in a nice listy style
05:24:27 <dons> lots of compositions of classical list functions
05:24:30 <dons> and you get better code.
05:24:40 <beelsebob> :)
05:24:41 <beelsebob> win
05:24:46 <dons> dcoutts: not bad, eh? ghc surprises me sometimes.
05:25:03 <beelsebob> "applications should read the PDF file from the end upwards" <-- well why the fuck is the file not the other way around then??????
05:25:10 <beelsebob> stupid bad Adobe
05:25:40 <mauke> makes writing pdfs easier
05:25:50 <dcoutts> dons: yeah, nice
05:25:59 <beelsebob> mauke: not really actually
05:26:09 <beelsebob> would be dead easy to put this lookup information at the top
05:26:19 <beelsebob> at least if you're implementing your pdf writer in haskell
05:26:26 <mauke> heh
05:26:42 <mauke> somehow that reminds me of my "linker"
05:27:33 <mauke> it resolves function references based on the values it's going to return, er, later
05:27:53 <ibid> DVI is another file format where the stuff you need at the beginning lies at the end
05:28:43 <ndm> zip too
05:28:56 <ReTaL> does somebody have a comprehensive haskell tutorial
05:28:58 <ReTaL> ?
05:29:09 <ndm> the reason being it was designed for tape drives, where the file table has to go at teh end (no seeking back)
05:29:11 <ReTaL> i dont get it by what i am reading
05:29:28 <mauke> http://haskell.org/haskellwiki/Learning_Haskell
05:29:29 <lambdabot> Title: Learning Haskell - HaskellWiki
05:31:38 <beelsebob> ReTaL: what don't you "get"?
05:31:44 <beelsebob> as in - how much do you get
05:31:51 <beelsebob> what are you having problems with?
05:33:56 <ibid> for DVI, i suspect the reason is that portable Pascal did not have random-access file operations
05:34:45 <beelsebob> ibid: apparently the reason with pdf is specifically to allow random access
05:34:48 <beelsebob> but I can't figure out why
05:36:53 <ibid> beelsebob: this restriction was for the writer (TeX) :)
05:37:50 <Philippa> putting it at the end does mean you know you've read the entire file, at least...
05:38:04 <beelsebob> true
05:38:29 <beelsebob> tbh, I would have expected %PDF-1.7\n<number of bytes to expect in this file>
05:38:59 <beelsebob> hehe, fun, pdf files can include compressed PDF files within themselves
05:39:08 <ivanm> lol
05:40:40 <foxy-om> @where HList
05:40:40 <lambdabot> http://homepages.cwi.nl/~ralf/HList
05:43:43 <Philippa> beelsebob: including the number of bytes to expect makes it harder to generate
05:43:59 <beelsebob> Philippa: true that
05:44:01 <Philippa> at least if we're assuming you can't seek back and write over it
05:44:07 <beelsebob> but not if you're doing it in Haskell :P
05:44:21 <Philippa> doing it in haskell on a system with 8K of memory would still be painful
05:44:36 <beelsebob> hehe
05:44:37 <beelsebob> true
05:52:55 <tuxplorer>  I have a basic doubt.. in the nave version of fibonacci generation, the base conditions are defined.. and I call fibo 3.. even for that stack overflow occurs.. for fibo 3, it should just be replaced as fibo 1 + fibo 2 and both these values are defined and just need to be added right? then where from does the stack issue comes in?
05:54:01 <opqdonut> tuxplorer: you have miscoded it, that simple
05:56:17 <beelsebob> tuxplorer: remember -- function application binds tightest
05:56:32 <beelsebob> fib n - 2 == (fib n) - 2, not fib (n - 2)
05:57:23 <tuxplorer> oh! beelsebob Thanks.. You said that before but I didn't notice..
06:05:10 <hygge> hey!
06:05:19 <beelsebob> in what package is printf defined?
06:05:31 <beelsebob> module even
06:06:04 <hygge> i've got a very simple recursive function, f, Integer -> Fractional.  i want hugs to print out a list of all functions to say 100, how do i do this? list comprehension?
06:06:11 <hygge> 1-100
06:06:21 <ndm> @hoogle printf
06:06:22 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
06:06:23 <lambdabot> Text.Printf :: module
06:06:23 <lambdabot> Text.Printf.hPrintf :: HPrintfType r => Handle -> String -> r
06:06:29 <ndm> beelsebob: ^^
06:06:35 <beelsebob> thx ndm
06:06:42 <beelsebob> > map f [1..100] where f x = x + 2
06:06:43 <lambdabot>  Parse error
06:06:46 <beelsebob> o.O
06:06:54 <beelsebob> > let f x = x + 2 in map f [1..100]
06:06:56 <lambdabot>  [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,3...
06:06:59 <xerox> years ago it supported wheres :(
06:07:00 <beelsebob> there you go hygge
06:07:26 <haskellboy> hi would anyone know how i use the function  selectPen :: Pen -> Draw Pen  in  http://cvs.haskell.org/Hugs/pages/libraries/HGL/Graphics-HGL-Draw-Pen.html#t%3APen
06:07:30 <lambdabot> http://tinyurl.com/23q52e
06:07:34 <beelsebob> hygge: you might also do it by list comprehensions -- whichever looks nicer
06:07:35 <haskellboy> I don't know what a Pen is
06:07:46 <haskellboy> well i do , but what do i type
06:07:52 <beelsebob> haskellboy: you can get one using createPen
06:08:03 <beelsebob> and giving it a style, width and colour
06:08:06 <hygge> like [ x | x <- f (x)]
06:08:20 <beelsebob> hygge: yep, that would work, but no need for the parentheses
06:08:28 <beelsebob> oh actually no
06:08:47 <hygge> ERROR - Undefined variable "x"
06:08:59 <beelsebob> [f x | x <- inputList]
06:09:24 <haskellboy> so how would i apply a pen to this to make it dotted?!!     drawInWindow w  (polyline [(0,0),(1,1)])
06:09:47 <beelsebob> where's the docs for drawInWindow
06:10:05 <haskellboy> drawInWindow :: Window -> Graphic -> IO ()
06:10:26 <beelsebob> using setGraphic then
06:10:42 <haskellboy> polyline :: [Point] -> Graphic
06:10:53 <haskellboy> setGraphic replaces everything in the window, can't use that
06:11:50 <hygge> how to make hugs not round off my numbers?
06:11:59 <hygge> i want to have say 50 decimals?
06:12:31 <beelsebob> hygge: do you mean "I want to display lots of trailing zeros" or "hugs is actually doing some rounding"
06:12:49 <hygge> :)
06:12:50 <norpan> i like trailing nines better
06:13:01 <hygge> i want to work with bigger integers
06:13:08 <hygge> or floats
06:13:11 <hygge> in this case
06:13:29 <hygge> so it doesnt have to round off
06:13:31 <norpan> bigger == higher precision?
06:13:35 <hygge> mmm
06:13:36 <hygge> :)
06:13:38 <beelsebob> hygge: well, you can have infinite precision integers using Integer, rather than Int
06:13:47 <hygge> but this is floats
06:13:49 <norpan> Double is better than Float
06:13:50 <beelsebob> and you can have double precicion floats using Double
06:13:54 <hygge> okej
06:14:06 <norpan> and you can use Rational
06:14:06 <beelsebob> but you can't get infinite precision Real numbers without someone else's library
06:14:17 <beelsebob> yes -- you can use rational if all your numbers are rats
06:14:24 <hygge> f :: (Num a, Fractional b) => a -> b is what :t f gives now
06:14:39 <hygge> f 1 = 1 + 1/(1+1)
06:14:39 <hygge> f x = 1 + 1/(f(x-1))
06:14:42 <norpan> Rational is Fractional
06:14:43 <hygge> this is my simple function
06:15:19 <norpan> using Rational will give you infinite precision
06:15:25 <hygge> okej
06:15:28 <hygge> jhm
06:15:47 <norpan> 1/(1+1) indeed
06:15:52 <beelsebob> > let f 1 = 1+1/2; f x = 1 + 1/f (x - 2) in map f [1..100]
06:15:54 <hygge> but it wont to bee easy to compare them then
06:15:54 <lambdabot>  Exception: stack overflow
06:15:57 <beelsebob> o.O
06:15:57 <norpan> you couldn't work that one out yourself :)
06:15:59 <beelsebob> blimy
06:16:24 <hygge> i want to see which number this goes to when x goes to infinity
06:16:27 <beelsebob> norpan: personally I like that style
06:16:31 <beelsebob> it's more consistant
06:16:49 <beelsebob> and it's not like the compiler isn't gonna optimise it out
06:16:51 <norpan> f 0 = 1 + 1 would be more consistent
06:17:11 <hygge> ah
06:17:34 <beelsebob> norpan: true that
06:17:54 <norpan> but then i don't know what the definition of the function is
06:18:00 <norpan> then again
06:18:19 <hygge> but that will do i think :)
06:18:21 <hygge> i changed
06:18:54 <norpan> when x goes to infinity f(x) will obviously go to infinity too
06:19:01 <norpan> since it's larger than x
06:19:49 <norpan> but now i need to leave
06:19:54 <hygge> okej! :)
06:19:55 <hygge> thank you
06:20:53 <hygge> but it isnt linear. bacause in the beginning we have ,1.61904761904762 then the 1000th element is 1.61803398874989 that is smaler
06:21:40 <beelsebob> that would imply that at some point 1/f (x - 2) is negative
06:21:47 <beelsebob> which can't be true
06:22:22 <hygge> hmm?
06:22:52 <fasta> Is there a function f in the standard libraries that does: f  ((==) "looking") ["foo", "looking", "for"] => (["foo", "looking"], ["for"]) ?
06:23:30 <fasta> It's break, but "shifted" one element.
06:23:30 <Heffalump> @src break
06:23:31 <lambdabot> break p =  span (not . p)
06:23:32 <Heffalump> ah.
06:23:37 <Heffalump> I doubt it, then
06:24:02 <hygge> beelsebob, what did you mean?
06:24:15 <ndm> how in darcs to i find a version of a file from yesterday?
06:24:19 <ndm> without darcweb
06:24:29 <xerox> beelsebob: f (x-2) is not defined for x <= 2
06:24:30 <Heffalump> pull the repo and unpull patches
06:24:32 <beelsebob> hygge: well your recursive function always adds 1 / f (x - 2)
06:24:41 <xerox> that's why you are getting the stack overflow
06:24:44 <beelsebob> for the value to decrease it has to benegative
06:24:45 <haskellboy> how would i apply  withPen :: Pen -> Graphic -> Graphic  to the line i'm drawing here in   do createPen Dot 10 (RGB 104 111 119); drawInWindow w (polyline [(0,0), (500,500)])
06:24:50 <ndm> hmm, that sucks...
06:25:27 <beelsebob> ndm: darcs revert or something like that
06:25:44 <hygge> beelsebob, yeah i thought of that too, but Main> map f [1..5]
06:25:44 <hygge> [1.5,1.66666666666667,1.6,1.625,1.61538461538462]
06:25:57 <beelsebob> o.O
06:25:57 <hygge> biggest number is 1.625
06:27:04 <hygge> no?
06:29:47 <beelsebob> holy crapsocks, I can produce pdf documents :)
06:29:56 <hygge> when i put it as f :: Integer -> Rational. i get Main> map f [1..10]
06:29:56 <hygge> [3 % 2,5 % 3,8 % 5,13 % 8,21 % 13,34 % 21,55 % 34,89 % 55,144 % 89,233 % 144]
06:29:59 <hygge> what is & ?
06:30:20 <opqdonut> what &?
06:30:23 <hygge> ahaa
06:30:24 <hygge> / :D
06:30:31 <hygge> % i meant
06:30:32 <opqdonut> > (3/2) ::Fractional
06:30:33 <lambdabot>      Class `Fractional' used as a type
06:30:33 <lambdabot>     In the type `Fractional'
06:30:33 <lambdabot>     In an...
06:30:47 <opqdonut> > (3/2) ::Rational
06:30:48 <lambdabot>  3%2
06:30:51 <opqdonut> yeh
06:31:00 <hygge> i thought of moduls and stuff
06:35:07 <hpaste>  beelsebob pasted "WIN!" at http://hpaste.org/1301
06:35:38 <beelsebob> now to make some functions that guarentee I actually get a valid pdf document that doesn't have the integer 5 as it's catalogue entry!
06:49:13 <ndm> @seen sorear
06:49:13 <lambdabot> I saw sorear leaving #darcs, #haskell-overflow, #ghc, #haskell and #happs 5h 10m 45s ago, and .
06:50:24 <beelsebob> quick question -- would other people have a use for a Haskell native pdf writer?
06:51:29 <ndm> beelsebob: no
06:51:43 <ndm> i have no use for any type of pdf writer...
06:51:46 <beelsebob> ndm: any particular reason, or would you just not want to write pdfs?
06:51:50 <beelsebob> fair enough
06:51:56 <ndm> unless you can do things like deleting particular pages from an existing PDF?
06:52:08 <beelsebob> well, I have no plans for a parser yet
06:52:13 <beelsebob> but that may be a future extension
06:52:13 <ndm> i.e. read/write with easy manipulations in the middle
06:52:22 <ndm> its possible haddock or something could use it
06:52:26 <beelsebob> the plan at the moment is to slowly build up a graphics library
06:52:40 <beelsebob> so that you can easily produce diagrams for papers
06:52:43 <ndm> HsColour outputs to .tex, which I guess is usually PDF'd
06:52:52 <beelsebob> (in a nice format that pdflatex will easily eat)
06:52:56 <ndm> can you include a PDF into a paper easily?
06:53:08 <beelsebob> yep \includegraphic{something.pdf}
06:53:17 <ndm> i am still trying to figure out how to do graphics for .dvi and .pdf
06:53:24 <ndm> does that work on .dvi as well?
06:53:36 <beelsebob> I think the formats it eats depends on the tex processor you're using
06:53:43 <ndm> lovely...
06:53:45 <beelsebob> so if you're using latex, then probably you need eps files
06:53:56 <beelsebob> wheras pdflatex eats pdfs, and I think eps
06:53:56 <ndm> god knows what i'm using...
06:54:05 <ndm> i still have to experiment
06:54:42 <beelsebob> heh
06:54:55 <beelsebob> either way, it should be powerful enough to produce entire documents
06:55:14 <beelsebob> which may be occasionally useful
06:55:29 <beelsebob> plus, it's a useful example to feed Hat
06:57:35 <haskellboy> guys can i ask what the & means
06:58:26 <Saizan> &?
06:58:43 <haskellboy> mkBrushred$\redBrush->withBrushredBrush$ellipse(000,000)(100,100)
06:58:54 <beelsebob> do you mean $
06:58:56 <beelsebob> not &?
06:58:58 <haskellboy> yea
06:59:05 <beelsebob> it's the apply operator
06:59:15 <beelsebob> it means apply the thing on the left to the thing on the right
06:59:23 <beelsebob> f $ x = f x
06:59:37 <beelsebob> f $ g $ y = f (g y)
06:59:44 <beelsebob> etc
06:59:52 <Saizan> so, mkBrushred$\redBrush->withBrushredBrush$ellipse(000,000)(100,100) === mkBrushred(\redBrush->withBrushredBrush$ellipse(000,000)(100,100))
06:59:55 <eumenides> f $ ..... = f (.....)
07:00:24 <beelsebob> it's often used to avoid typing hundreds of brackets and turnig your code into Scheme
07:00:49 <beelsebob> it can also be used in sections usefully...
07:01:10 <beelsebob> > let f x = x + 2; g x = x * 999 in map ($ 2) [f, g]
07:01:12 <lambdabot>  [4,1998]
07:01:24 <beelsebob> (which applies every function in the list to 2
07:02:24 <haskellboy> thanks!!
07:26:01 <ndm> template haskell questions:
07:26:20 <ndm> what does data Colour = ..., then doing ''Colour mean?
07:26:41 <ndm> i guess it means take the representation in some way, but not quite sure how, and can
07:26:47 <ndm> not find it documented
07:28:07 <Saizan> ''Coluor gives you the Name  i think
07:29:59 <Saizan> yes, it gives a Name, to get the definition you have to reify it
07:30:26 <ndm> hmm, thanks - still trying to figure out how to get what i want...
07:30:37 <thedward> ndm: there is some mention of it on this page: http://www.haskell.org/hawiki/TemplateHaskellTutorial
07:30:39 <lambdabot> Title: TemplateHaskellTutorial - The Haskell Wiki
07:31:22 <ndm> thedward: thanks
07:47:24 <hpaste>  tuxplorer pasted "what mistake have i done in getlist?" at http://hpaste.org/1302
07:48:13 <tuxplorer> What mistake have I done in the above program?
07:50:00 <tuxplorer> ERROR "Numbers.hs":12 - Last generator in do {...} must be an expression
07:50:05 <tuxplorer> I get the above error
07:50:09 <norpan> do after else
07:50:27 <norpan> and you need to return something in main
07:51:13 <norpan> you probably want something like "print fact_list" at the last line of main
07:52:23 <tuxplorer> Thanks norpan
07:52:31 <tuxplorer> yes. I was about to do that..
07:53:01 <tuxplorer> but now after getting rid of all those errors I still get some error.. I'll paste it now..
07:53:30 <norpan> and if/else in getlist must not be at the same indentation level
07:53:40 <norpan> else must be indented more
07:53:42 <hpaste>  tuxplorer pasted "More errors" at http://hpaste.org/1303
07:54:29 <norpan> tuxplorer: you only use return when using monads
07:54:30 <tuxplorer> norpan: ya. I got the mistake..
07:54:37 <norpan> so my-sum and mypdt should not "return"
07:54:39 <tuxplorer> I failed to specify the base conditions
07:54:40 <norpan> my_pdt
07:55:03 <tuxplorer> oh! ok..
08:02:17 <tuxplorer> norpan: is this part right?
08:02:17 <tuxplorer> my_sum [] = 0
08:02:17 <tuxplorer> my_sum (x:xs) = return (x+my_sum xs)
08:02:48 <tuxplorer> or I should rather use foldr or something right?
08:03:08 <opqdonut> don't use return
08:03:11 <opqdonut> that's for monadic code
08:03:21 <opqdonut> just my_sum (x:xs) = x+mysum xs
08:03:33 <opqdonut> and yes, you could use fold
08:03:44 <opqdonut> or even the prelude sum function :)
08:03:49 <Saizan> ?src sum
08:03:50 <lambdabot> sum = foldl (+) 0
08:03:55 <opqdonut> yeah
08:04:06 <Saizan> you should use foldl' however
08:04:19 <opqdonut> yeah, the strict version of foldl
08:04:24 <opqdonut> ?src foldl'
08:04:25 <lambdabot> foldl' f a []     = a
08:04:25 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
08:05:00 <hpaste>  tuxplorer pasted "Almost done.. But one last error" at http://hpaste.org/1304
08:05:42 <opqdonut> what is the error?
08:05:54 <hpaste>  tuxplorer annotated "Almost done.. But one last error" with "(no title)" at http://hpaste.org/1304#a1
08:06:16 <tuxplorer> opqdonut: now pasted the error.. forgot first.. sorry
08:07:13 <opqdonut> tuxplorer: fact_list is a list of strings
08:07:18 <opqdonut> you can't just ++ it
08:07:23 <opqdonut> to a string
08:07:31 <milkcan> it's ok to be gay, let's rejoice with the boys, in the gay-way!
08:08:05 <tuxplorer> opqdonut: Thanks
08:10:20 <TomMD> If I fork bomb lambdabot, would it recover?
08:10:50 <Saizan> ?instance Integral
08:10:51 <lambdabot> Maybe you meant: instances instances-importing
08:10:55 <Saizan> ?instances Integral
08:10:57 <lambdabot> Int, Integer
08:11:02 <opqdonut> TomMD: it has recursion limits etc
08:11:03 <Saizan> ?instances Num
08:11:04 <lambdabot> Double, Float, Int, Integer
08:11:08 <opqdonut> you can always try :)
08:11:53 <Saizan> shoudln't fact_list be a [Integer] or such?
08:12:28 <opqdonut> yeah, so i reasoned but i dunno what his code is doing :)
08:13:57 <thedward> does lambdabot even have a version of fork loaded?
08:15:48 <TomMD> > forkIO $ putStrLn "Hi"
08:15:50 <lambdabot>   Not in scope: `forkIO'
08:15:58 <opqdonut> how sad
08:16:18 <TomMD> > tails "TomMD"
08:16:20 <lambdabot>  ["TomMD","omMD","mMD","MD","D",""]
08:16:30 <opqdonut> > [1..]
08:16:32 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
08:16:39 <opqdonut> > sum [1..]
08:16:44 <lambdabot> Terminated
08:16:56 <vincenz> if you want something heavy...
08:17:23 <opqdonut> i just demonstrated that getting it to loop is not possible
08:17:36 <eumenides> :t threadDelay
08:17:39 <lambdabot> Not in scope: `threadDelay'
08:17:47 <vincenz> opqdonut: there's ways to make it kill your task more...harshly
08:17:58 <TomMD> > product $ map read (tails "123456789")
08:17:59 <lambdabot>  Exception: Prelude.read: no parse
08:18:11 <TomMD> > read ""
08:18:13 <lambdabot>  Exception: Prelude.read: no parse
08:18:40 <Saizan> tuxplorer: you are getting strange errors from the compiler, but the mistake is that you are using numbers as they were String, instead you want to use the function |show :: Show a => a -> String| on them to get their string representation, you have to use it con fact_list too
08:18:46 <TomMD> > product $ map read (init (tails "123456789"))
08:18:46 <opqdonut> > fix (\x -> 'a':x++x)
08:18:49 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
08:18:49 <lambdabot>  1114170347630816674414724060702421564403629
08:18:55 <TomMD> rock on
08:18:58 <opqdonut> haha
08:19:20 <vincenz> @type let f1 = (,) in let f2 = f1 . f1 in let f3 = f2 . f2 in let f4 = f3 . f3 in let f5 = f4 . f4 in let f6 = f5 . f5 in let f7 = f6 . f6 in let f8 = f7 . f7 in let f9 = f8 . f8 in let f10 = f9 . f9 in f10
08:19:30 <lambdabot> forall a b b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12 b13 b14 b15 b16 b17 b18 b19 b20 b21 b22 b23 b24 b25 b26 b27 b28 b29 b30 b31 b32 b33 b34 b35 b36 b37 b38 b39 b40 b41 b42 b43 b44 b45 b46 b47 b48 b49
08:19:30 <lambdabot> b50 b51 b52 b53 b54 b55 b56 b57 b58 b59 b60 b61 b62 b63 b64 b65 b66 b67 b68 b69 b70 b71 b72 b73 b74 b75 b76 b77 b78 b79 b80 b81 b82 b83 b84 b85 b86 b87 b88 b89 b90 b91 b92 b93 b94 b95 b96 b97 b98
08:19:30 <lambdabot> b99 b100 b101 b102 b103 b104 b105 b106 b107 b108 b109 b110 b111 b112 b113 b114 b115 b116 b117 b118 b119 b120 b121 b122 b123 b124 b125 b126 b127 b128 b129 b130 b131 b132 b133 b134 b135 b136 b137 b138
08:19:30 <lambdabot> b139 b140 b141 b142 b143 b144 b145 b146 b147 b148 b149 b150 b151 b152 b153 b154 b155 b156 b157 b158 b159 b160 b161 b162 b163 b164 b165 b166 b167 b168 b169 b170 b171 b172 b173 b174 b175 b176 b177
08:19:32 <lambdabot> b178 b179 b180 b181 b182 b183 b184 b185 b186 b187 b188 b189 b190 b191 b192 b193 b194 b195 b196 b197 b198 b199 b200 b201 b202 b203 b204 b205 b206 b207 b208 b209 b210 b211 b212 b213 b214 b215 b216
08:19:33 <Saizan> tuxplorer, printstuff (show sum_val) (show pdt_val)  (show fact_list)
08:19:33 <vincenz> shit
08:19:35 <lambdabot> [48 @more lines]
08:19:38 <vincenz> it's supposed to cancel tat
08:20:07 <opqdonut> :D
08:20:17 <vincenz> @type let f1 = (,) in let f2 = f1 . f1 in let f3 = f2 . f2 in let f4 = f3 . f3 in let f5 = f4 . f4 in let f6 = f5 . f5 in let f7 = f6 . f6 in let f8 = f7 . f7 in let f9 = f8 . f8 in let f10 = f9 . f9 in let f11 = f10 . f10 in let f12 = f11 . f11 in let f13 = f12 . f12 in let f14 = f13 . f13 in let f15 = f14 . f14 in let f16 = f15 . f15 in let f17 = f16 . f16 in let f18 = f17 . f17 in let f19 = f18 . f18 in let f20 = f19 . f19 in let f
08:20:19 <lambdabot> parse error (possibly incorrect indentation)
08:20:28 <opqdonut> ?djinn a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a
08:20:29 <lambdabot> f _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ a = a
08:20:36 <opqdonut> hrmm
08:20:39 <vincenz> @type let f1 = (,) in let f2 = f1 . f1 in let f3 = f2 . f2 in let f4 = f3 . f3 in let f5 = f4 . f4 in let f6 = f5 . f5 in let f7 = f6 . f6 in let f8 = f7 . f7 in let f9 = f8 . f8 in let f10 = f9 . f9 in let f11 = f10 . f10 in let f12 = f11 . f11 in let f13 = f12 . f12 in let f14 = f13 . f13 in let f15 = f14 . f14 in let f16 = f15 . f15 in let f17 = f16 . f16 in let f18 = f17 . f17 in let f19 = f18 . f18 in let f20 = f19 . f19 in let f
08:20:41 <lambdabot> parse error (possibly incorrect indentation)
08:20:46 <vincenz> sigh
08:20:51 <TomMD> @quote lambdabot
08:20:52 <lambdabot> lambdabot says: tERmIN473d
08:20:58 <opqdonut> ?djinn (a->a->a->a->a->a->a->a->a->a->a->a->a->a->a)->a->a->a->a->a->a->a->a->a->a->a->a->a->a
08:20:59 <lambdabot> f a b = a b b
08:21:06 <Saizan> vincez: IRC truncates your message
08:21:06 <opqdonut> no fun
08:21:07 <TomMD> @quote opqdonut
08:21:08 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
08:21:19 <opqdonut> heh no quotes
08:21:24 <vincenz> Saizan: yes I believe so
08:21:34 <vincenz> I give up, too much spam
08:22:05 <hpaste>  mux pasted "Parsable class" at http://hpaste.org/1305
08:22:16 <mux> does that looks reasonable?
08:25:16 <Saizan> have you some case where you need a different implementation of parse?
08:26:22 <mux> no, I did that because I have several data types with one Parsec parser for each, and it was cumbersome to always export the parsec parser for every type
08:28:45 <Saizan> ehat i mean is that parse and parseMaybe could be standard functions, however this shouldn't be a problem anyway
08:29:47 <mux> oh
08:29:49 <mux> you're right
08:29:56 <mux> I could move them out of the class
08:30:55 <mux> thanks :)
08:31:49 <mux> I like this class, it makes some things quite elegant
08:32:47 <hpaste>  mux pasted "Square.hs" at http://hpaste.org/1306
08:33:46 <Saizan> i haven't used Parsec so much, but i haven't found the parsers particuraly easy to combine, but i had very abiguos grammars
08:34:05 <mux> I like how I can now define the parser for a square as liftM2 Square parser parser
08:35:31 <Saizan> nice :)
08:45:27 <vincenz> hmm
08:46:06 <Igloo> malcolmw: Does nhc have anything autoconf-like?
08:46:22 <vincenz> Anyone know if it's an issue if your abstract is much shorter than the max length?
08:46:33 <malcolmw> Igloo: we have a hand-written shell script to gather configuration info
08:46:54 <Igloo> malcolmw: OK, and you want to avoid autoconf because it's scary?
08:47:04 <malcolmw> Igloo: very scary ...
08:47:35 * Igloo doesn't see an easy answer, then, but the existing getpid import is just wrong
08:48:01 <malcolmw> I have looked at autoconf several times, and never even worked out how to copy and paste a config test to make a small variation of it
08:48:16 <milkcan> can someone sell me some cannabis and/or heroin?
08:48:48 <malcolmw> If I knew what it was that the autoconf is trying to generate, I could probably do the same tests easily by hand
08:49:26 <Pastorn> milkcan: sure! where you want it?
08:49:49 <malcolmw> but I can't even read autoconf well enough to get that far
08:49:52 <milkcan> i want to eat them!
08:49:59 --- mode: ChanServ set +o Igloo
08:50:08 --- mode: Igloo set +b *!*@host-212-149-254-102.kpylaajakaista.net
08:50:11 --- kick: milkcan was kicked by Igloo (Igloo)
08:50:54 <Igloo> malcolmw: I assume all you need is a test for whether a pid_t type exists
08:51:11 <Igloo> malcolmw: You must do the rest of the work for types like CClock already
08:51:19 <malcolmw> Igloo: in this specific instance, perhaps
08:51:43 <malcolmw> Igloo: but if I want the whole of System.Posix.*, there will be quite a lot more
08:51:54 <pejo> malcolmw, sources.redhat.com/autobook has a book online which is quite good, imho.
08:52:14 <Igloo> Oh, sure, but if you want to do it that way then you may as well do it one bit at a time
08:53:05 <malcolmw> Igloo: then there is the whole thing about undocumented source files like HsBaseConfig.h
08:53:22 <malcolmw> Does Cabal generate that by the way, or ghc's configure?
08:53:27 <Igloo> malcolmw: I think autoreconf generates HsBaseConfig.h.in and configure then generates HsBaseConfig.h
08:53:45 <tuxplorer> Saizan: Thanks
08:54:02 <Igloo> but I'd have to watch it step-by-step or look it up in the docs to be sure
08:54:26 <malcolmw> the wider question is, in general, is there this kind of stuff for every package that I might want to hook up?
08:55:03 <Saizan> tuxplorer: sometimes putting type signatures on toplevel definitions can help the compiler to give you better error messages
08:55:17 <Igloo> base, readline, regex-posix, unix, Win32 of the GHC corelibs have a configure.ac
08:55:33 <tuxplorer> Saizan: now it works well :) ya. I'll keep that in mind :)
08:55:43 <Igloo> ALUT, GLUT, HGL, OpenAL, OpenGL, X11, network, time of the extralibs do
08:56:04 <Igloo> No idea how hard any of them would be to rewrite yourself
08:56:07 <tuxplorer> Yet another Haskell tutorial is the best for beginners is it? or is there something better to begin with? (though I feel comfortable with YAHT)
08:56:36 <malcolmw> Igloo: on the question of CClock etc, see http://darcs.haskell.org/nhc98/src/prelude/FFI/CTypesExtra.hs
08:56:37 <tuxplorer> I've been a ruby guy so far
08:56:48 <TomMD> I really liked YAHT, I didn't like the others when I started.
08:57:11 <Igloo> malcolmw: Oh, you just claim to know the right type to use?
08:57:15 <malcolmw> Igloo: wow, that is a pretty long list of packages
08:57:22 <Saizan> ?google wikibooks haskell
08:57:25 <lambdabot> http://en.wikibooks.org/wiki/Programming:Haskell
08:57:25 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
08:58:02 <malcolmw> Igloo: yes, essentially.  At the time I wrote that, it was true for all platforms I had access to
08:58:08 <Saizan> that is also good
08:58:36 <tuxplorer> ok. will try that too
08:59:07 <Igloo> malcolmw: Well, for a similar hack you could do something similar for CPid, and put it inside #if !arch_windows/#endif or whatever
09:00:44 <malcolmw> Igloo|: Is it enough to know what size the C type is, or do I need to know more precisely?
09:01:13 <Igloo> malcolmw: Writing your own shell script to do everything properly is going to be painful, though. You'd be better off designing a nicer (general) autoconf replacement and getting all the impls to use it, I think
09:01:35 <Igloo> malcolmw: Size is fine, AFAIK
09:01:36 <malcolmw> Igloo: you stole the thought right out of my mind
09:01:56 <Igloo> although having the signedness right would be nice
09:02:21 <Igloo> malcolmw: Unfortunately, deigning a nice replacement and rewriting enough of the autoconf rules in it is no small feat either  :-)
09:02:36 <Igloo> But could be fun, if you have the time/money
09:03:14 <malcolmw> Igloo: so if I determine CPid to be unsigned int, it doesn't matter if the C decl is actually unsigned long, provided that on this platform #int == #long
09:03:31 <hygge> .
09:04:16 <malcolmw> I wasn't actually planning to do the whole shebang - just enough to get nhc98 going with a reasonable amount of abstraction so adding new tests is easy
09:05:04 <Igloo> Right, if sizeof(unsigned int) == sizeof(unsigned long) == sizeof(pid_t) then you can have any of newtype CPid = CPid {WordN | CUInt | CULong}
09:05:09 * malcolmw wonders if darcs will let me do a double rollback
09:05:24 <malcolmw> i.e. an UNDO: UNDO: somthing patch
09:05:48 <Igloo> And nothing will actually break if you use IntN | CInt | CLong, but when you look at the values in Haskell large numbers will appear negative instead
09:05:53 <Igloo> Nope
09:06:26 <Igloo> If you don't do the whole shebang then I don't think the other impls will move, and you will be forever duplicating work
09:08:24 <yiwin> hello, what difference at
09:08:25 <yiwin>  let x =3 in x+y
09:08:27 <yiwin> and
09:08:28 <yiwin>  x=3; x+y    if we will code who better?
09:08:33 <Igloo> (I'd be happy to be wrong, though  :-)  )
09:08:50 <wy> I want to learn darcs. But it seems that darcs tutorial's testing repository can't be accessed. Any other remote repos for testing there?
09:09:39 <thetallguy> ylwin: no difference
09:10:17 <yiwin> who better?
09:10:24 <thetallguy> ylwin: assuming you're not in the IO monad and replacing those with more complicated things.
09:10:32 <thetallguy> I'd say the let is nicer
09:10:37 <thetallguy> easier to read
09:12:49 <procyon112> @seen chessguy
09:12:50 <lambdabot> I saw chessguy leaving #haskell, #ghc and #haskell-overflow 12h 47m 44s ago, and .
09:16:28 <malcolmw> Igloo: How come System.Posix.Types has #ifdefs around types in the export list?  Doesn't that mean that the API will be different on different platforms?  How is that desirable?
09:17:12 <Igloo> malcolmw: Very little about the libraries is currently desirable IMO  :-)
09:17:21 <malcolmw> :-)
09:18:18 <malcolmw> Igloo: I've been thinking that hsc2hs might be exactly the tool that is required for this kind of config stuff
09:19:05 <Igloo> If you know the type exists, then yeah, it should just be newtype CPid = CPid #type pid_t or something, I think
09:19:20 <malcolmw> certainly looks that way to me
09:19:45 <Igloo> And given we're in System.Posix I'm not sure why we aren't assuming that types like pid_t exist
09:19:52 <Igloo> I wouldn't have thought any could optionally not exist
09:19:54 <malcolmw> and given that we don't really want mutable APIs, I guess it is OK to assume all the types exist :-)
09:20:45 <malcolmw> of course, System.Posix.* is built on win32 as well...
09:20:55 <malcolmw> for some obscure reason
09:20:59 <Igloo> I thought only a couple of modules were
09:21:31 <pejo> malcolmw, isn't NT and upwards fairly posix compatible?
09:21:58 <malcolmw> Igloo: oh, I saw the comment in S.P.Internals and assumed it applied to the lot
09:23:04 <Igloo> malcolmw: Ah, it's probably true for all the System.Posix stuff in base, but most of it is in unix
09:23:19 <Igloo> And e.g. Signals does
09:23:20 <Igloo> #ifndef mingw32_HOST_OS
09:23:20 <Igloo> -- WHOLE FILE...
09:23:22 <Igloo> #endif
09:23:48 <malcolmw> another mutable interface :-)
09:25:31 <Igloo> Pah, that's not mutable. Now python, where you can change the interface of classes at runtime - that's mutable
09:26:16 <malcolmw> cool - self-modifying code
09:27:21 * qwr . o O ( Network module doc says, that you need use Posix signal blocking unless you like the program to be randomly killed by SIGPIPE... )
09:27:40 <opqdonut> :D
09:27:42 <kolmodin> which filepath is *the one* ?
09:27:51 <kolmodin> there is ndm's http://www-users.cs.york.ac.uk/~ndm/filepath/
09:27:52 <lambdabot> Title: Neil Mitchell - FilePath
09:27:55 <malcolmw> @where filepath
09:27:56 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/filepath/
09:27:57 <Igloo> The one on d.h.o
09:28:03 <malcolmw> oops
09:28:06 <kolmodin> and then something similar http://darcs.haskell.org/packages/filepath/
09:28:08 <lambdabot> Title: Index of /packages/filepath
09:28:17 <kolmodin> Igloo: aye, ^^ that one then
09:28:21 <malcolmw> @where+ filepath http://darcs.haskell.org/packages/filepath/
09:28:21 <lambdabot> Done.
09:28:37 <kolmodin> aye, good
09:28:48 <kolmodin> are there any released versions?
09:29:10 <malcolmw> the d.h.o one is released (I think)
09:29:28 <kolmodin> ok, hackage I guess..
09:29:39 <Saizan> oh, i've always used the ndm's one
09:30:11 <malcolmw> ndm changed the official location recently (but didn't remove the old one)
09:30:36 <kolmodin> Saizan: this one seems to be based on ndm's one
09:30:47 <kolmodin> aha, ok, so it's the same
09:32:04 <kolmodin> I'd like to make an ebuild for it
09:32:30 <kolmodin> ultimately to play with yi.. :)
09:32:47 <kolmodin> yi requires filepath 1.0 or latest darcs
09:33:08 <kolmodin> so naturally I wonder where this 1.0 is..
09:35:22 <Igloo> Only in darcs AFAIK
09:37:43 <kolmodin> it has a 0.10 tag
09:40:20 <Igloo> It says 1.0 in the cabal file
09:40:46 <thetallguy> ?seen Cheery
09:40:47 <lambdabot> Cheery is in #haskell. I don't know when Cheery last spoke.
09:41:25 <shapr> good morning #haskell!
09:41:33 * shapr boings furiously
09:41:43 <opqdonut> boingboing
09:41:53 <stepcut> morning shapr
09:42:47 <Lemmih> shapr: How's Sweden?
09:44:44 <shapr> Lemmih: fun!
09:44:59 <shapr> No meds for days, I have energy!
09:46:10 <shapr> Lemmih: How's Sweden?
09:46:16 * shapr grins
09:46:58 <shapr> Oh, I'm going to meet a unicycling functional programmer next week, Luke Gorrie.
09:47:14 <Lemmih> I'm still in Denmark, unfortunately.
09:47:25 <ikegami--> I'm Japanese, and I have visited Sweden 4 times, then I like Sweden, fortunately
09:47:31 <araujo> hello shapr !!
09:47:41 <shapr> hola araujo!
09:47:45 <araujo> :-)
09:48:22 <shapr> ikegami--: Do you visit other countries also?
09:48:37 <shapr> Lemmih: will you soon be in Sweden?
09:49:27 <shapr> Wow, there's lots of people on #haskell
09:49:37 <araujo> yeah
09:50:12 <stepcut> ?users
09:50:13 <lambdabot> Maximum users seen in #haskell: 336, currently: 298 (88.7%), active: 38 (12.8%)
09:50:17 <ikegami--> shapr: yes, I've also visited some European countries and, US because I'm a researcher
09:50:37 <Lemmih> shapr: Yes, hopefully.
09:51:19 <shapr> bbl
09:56:14 <beelsebob> @hoogle concatZip
09:56:16 <lambdabot> No matches found
09:56:18 <beelsebob> bah
09:56:21 <beelsebob> why doesn't that exist
09:56:30 <beelsebob> @hoogle concatZipWith
09:56:31 <lambdabot> No matches found
09:56:34 <beelsebob> damn it
09:57:30 <cpoucet> beelsebob: what do you want
09:58:01 <cpoucet> hey Lemmih
09:59:36 <beelsebob> > let concatZipWith f [] _ = []; concatZipWith f _ [] = []; concatZipWith f (x:xs) (y:ys) = f x y ++ concatZipWith f xs ys in concatZipWith (\x y -> [x,y]) [1,2,3] [4,5,6]
09:59:39 <lambdabot>  [1,4,2,5,3,6]
09:59:51 <beelsebob> that make sense cpoucet?
09:59:57 <Cale> concatZipWith f xs ys = concat (zipWith f xs ys)
10:00:01 <beelsebob> indeed
10:00:12 <beelsebob> same as concatMap f xs = concat (map f xs)
10:00:16 <cpoucet> not really
10:00:25 <cpoucet> concatMap... f returns a list
10:00:35 <beelsebob> uhhuh
10:00:40 <beelsebob> some with concatZipWith
10:00:44 <cpoucet> oh
10:00:53 <cpoucet> f :: a -> b -> [c]
10:00:53 <Cale> :t \f xs ys -> concat (zipWith f xs ys)
10:00:56 <lambdabot> forall a b a1. (a -> b -> [a1]) -> [a] -> [b] -> [a1]
10:01:05 <beelsebob> yep
10:01:08 <cpoucet> @pl \f xs ys -> concat (zipwWith f xs ys)
10:01:09 <lambdabot> ((join .) .) . zipwWith
10:01:11 <Cale> It's just like a 2-parameter extension of concatmap.
10:01:18 <beelsebob> Cale: exactly
10:01:39 <beelsebob> o.O
10:01:40 <cpoucet> yeah, concatZip wouldn't make sense
10:01:44 <beelsebob> well pointless failed there
10:01:48 <beelsebob> yeh, concatZip wouldn't
10:01:50 <Cale> concatZip doesn't make sense
10:01:53 <beelsebob> was a mistype
10:02:15 <cpoucet> @type ((join .) .) . zipWith
10:02:18 <lambdabot> forall a a1 b. (a1 -> b -> [a]) -> [a1] -> [b] -> [a]
10:02:26 <cpoucet> join . :)
10:02:44 <cpoucet> @type (join .)
10:02:47 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m (m a)) -> a1 -> m a
10:03:39 <Cale> @type (concatMap (uncurry f) .) . zip
10:03:42 <lambdabot> Not in scope: `f'
10:03:46 <Cale> @type \f -> (concatMap (uncurry f) .) . zip
10:03:49 <lambdabot> forall b a b1. (a -> b1 -> [b]) -> [a] -> [b1] -> [b]
10:04:07 <cpoucet> Cale: not exactly ideal, I doubt fusion handles tuples
10:09:54 <wy> Is there a channel for darcs?
10:10:17 <Saizan> #darcs ?
10:13:42 <wy> Good. That's it
10:30:32 <Igloo> Ug, i need an "almost the same picture" check to make a raytracing test insensitive to FP differences
10:31:24 <beelsebob> bugger
10:31:28 <Igloo> I suspect doing it per-mixel would probably work, but it feels dirty
10:31:28 * beelsebob wonders what to do now
10:31:43 <beelsebob> The PDF writer produces a file that AcroRead reads
10:31:47 <beelsebob> but no other pdf reader does
10:31:51 <opqdonut> :)
10:36:57 <malcolmw> ndm: kolmodin was wondering where the official 1.0 release of filepath is
10:38:07 <beelsebob> malcolmw: or ndm do you happen to have Windows boxen about the place?
10:38:17 <malcolmw> beelsebob: not me
10:38:38 <beelsebob> do you have any pdf readers that aren't AcroRead/Preview?
10:38:50 <malcolmw> xpdf?
10:39:02 <beelsebob> that would be useful
10:39:21 <beelsebob> http://hpaste.org/1307 <-- could you copy and paste this into a text file and try and open it in xpdf pls?
10:39:30 <ndm> kolmodin: there is no official 1.0 release... - but if there was it would be at darcs.haskell.org
10:39:39 <ndm> malcolmw: i am on a windows box everywhere
10:39:45 <beelsebob> I'm trying to find some indication of why Preview barfs at it, but ArcoRead is fine with it
10:39:53 <ndm> beelsebob: Ghostscript sometimes works
10:40:09 <beelsebob> ndm: that was me, could you try that hpaste in windows AcroRead/Ghostscript?
10:40:19 <malcolmw> Error: Kid object (page 2) is wrong type (null)
10:40:19 <malcolmw> Error: Page count in top-level pages object is incorrect
10:40:20 <malcolmw> Error: Couldn't read page catalog
10:40:33 <ndm> malcolmw: Ross also renamed it from FilePath to filepath, which I suspect may cause issues some day...
10:40:52 <beelsebob> malcolmw: ahh, that makes sense
10:41:09 <beelsebob> I appear to have generated 2 children references when there is only one other page
10:41:47 <ndm> beelsebob: one page, blank in acrobat
10:42:12 <ndm> beelsebob: one small page in ghostview
10:42:13 <beelsebob> ndm: yeh, that's why I'm trying to generate
10:42:50 * beelsebob installs xpdf seeing as it appears to give useful error messages
10:43:29 <vincenz> Igloo: re your almost same, is the view angle the same?
10:43:41 <beelsebob> malcolmw, ndm thanks a lot, that's probably going to be very useful
10:43:47 <vincenz> Igloo: if so, then a simple sum of sqrt-diff could help
10:44:03 <vincenz> s/sqrt/sqr
10:44:04 <Igloo> vincenz: they're theoretically identical images, but I only have a flat output image
10:44:12 <vincenz> Igloo: right, but items don't move
10:44:15 <vincenz> or your pov
10:44:16 <vincenz> ?
10:44:19 <Igloo> No
10:44:34 <vincenz> go for a sum-sqr-diff by color
10:44:41 <Igloo> Of pixels, you mean?
10:44:42 <malcolmw> Igloo: are the differences positional, or colour-space?
10:44:43 <vincenz> if you want to be fancy, weight the blue less
10:44:45 <vincenz> Igloo: yep
10:44:56 <Igloo> malcolmw: Potentially both, I assume - that's the problem
10:45:04 <Igloo> Or rather, positional is the problem
10:45:08 <vincenz> if you want to be even fancier, weight it by value
10:45:09 <Igloo> colour changing would be easy  :-)
10:45:18 <vincenz> Igloo: oh, hence my Q
10:45:25 <vincenz> Igloo: easiest way then is a correlation
10:45:36 <vincenz> just correlate your image, get max-val, threshold
10:46:08 <vincenz> (probably weight by 1/image-size)
10:46:21 <vincenz> +ed
10:46:25 <kolmodin> malcolmw, ndm: ok, thanks
10:46:28 <beelsebob> malcolmw: do you have to do anything special to xpdf to get useful error messages like that, or is that what you get just trying to launch it?
10:46:42 <malcolmw> beelsebob: just trying to launch it
10:46:47 <beelsebob> cool :)
10:46:54 <vincenz> Igloo: if it's just translationational positional difference, correlation is ideal, it'll even give you the offset
10:47:03 <vincenz> Igloo: otherwise I can give you more ideas :)
10:47:30 <beelsebob> arse
10:47:36 <beelsebob> xpdf now successfully displays it
10:47:40 <malcolmw> beelsebob: I have xpdf version 1.01 if that makes a difference.  probably installed it via fink a long time ago
10:47:41 <beelsebob> but preview still barfs
10:47:45 <Igloo> vincenz: I just want something very simple that'll say "These are identical, except your PPC machine is slightly different FP-wise than your x86 machine"
10:48:14 <vincenz> Igloo: ok, but...the Q is... are the differences a) purely color, b) also positional but just a trnaslation in x-y, or possibly even a camera-change?
10:48:19 <vincenz> a: go for sum-sqr-diff
10:48:22 <vincenz> b: go for correlation
10:48:34 <beelsebob> hmm, I have xpdf 3 now, maybe that is better at handling slightly mallformed pdfs
10:48:51 <vincenz> c: apply high-freq-filters in x and y, find points that are noteworthy, find a mapping of these points, strecht appropriately and then do a correlation
10:48:54 <Igloo> vincenz: They're anything that FP differences could cause in a raytracer
10:49:10 <vincenz> Igloo: (b) is the easiest
10:49:17 <vincenz> unless you expect big changes
10:49:20 <vincenz> then you might need (c)
10:49:29 <Igloo> I want to fail on all but the minutest changes
10:49:29 <opqdonut> tried blending the two images?
10:49:37 <vincenz> Igloo: then use correlation
10:49:38 <opqdonut> for visual checking
10:49:40 <vincenz> Igloo: it's built for that
10:49:58 <Igloo> opqdonut: This is for GHC's automated testsuite
10:50:05 <opqdonut> ahh :)
10:50:15 <opqdonut> correlation, then
10:50:53 <yiwin> Hello, There are any idea to reduce GHC Linking exe time?   its too slow. about 10sec every time just only very small src code.
10:50:55 <yiwin> THX.
10:51:40 <Igloo> vincenz: Have you got a reference for correlation in this context?
10:52:03 <vincenz> Igloo: let me fish on up, basically you move one image over the other and multiply/sum
10:52:07 <vincenz> but obviously you have to weight that
10:52:08 * Igloo will probably start off by just seeing if allowing small differences in each pixel suffices, though
10:52:08 <vincenz> forgot the weights
10:52:54 <vincenz> and since you want pretty local
10:53:01 <vincenz> you can only do this within a small rnage of offsets
10:53:12 <vincenz> just move a bit
10:53:15 <vincenz> substract one from the other
10:53:20 <vincenz> sqr each value/per pixel
10:53:21 <vincenz> sum
10:53:35 <vincenz> that oughta give a decent metric
10:53:37 <vincenz> weight by image/size
10:54:39 <wy> @users
10:54:40 <lambdabot> Maximum users seen in #haskell: 336, currently: 298 (88.7%), active: 38 (12.8%)
10:54:56 <vincenz> http://en.wikipedia.org/wiki/Correlation
10:54:58 <lambdabot> Title: Correlation - Wikipedia, the free encyclopedia
10:55:07 <vincenz> Igloo: scroll down to "sample correlation"
10:55:22 <wy> This channel is more popular than darcs. So I want to ask some questions about the setup
10:55:23 <vincenz> that formula, just apply it to 2-d
10:55:31 <vincenz> Igloo: apply a few times with different offsets
10:55:46 <wy> I wonder what's the best way to setup an ssh server in windows XP
10:56:08 <Igloo> vincenz: OK, ta
10:57:48 <beelsebob> yay
10:57:55 <beelsebob> producing pdfs readable by everything now
10:58:21 <beelsebob> for some reason preview wants an unused cross reference for a non-existant object 0000000000 65535 f
10:58:26 <beelsebob> which is a bit odd
10:58:59 <beelsebob> @users
10:59:00 <lambdabot> Maximum users seen in #haskell: 336, currently: 297 (88.4%), active: 37 (12.5%)
10:59:14 <yiwin> Hello, There are any idea to reduce GHC Linking exe time?  its 10sec every time.
10:59:40 <beelsebob> yiwin: that sounds a bit odd -- it links very fast here
11:00:02 <malcolmw> linking over NFS by any chance?
11:01:33 <yiwin> beelsebob:Ii use visual haskell.  and  using wxhaskell.     even 1 hs file to 10 sec.
11:04:51 <wy> beelsebob: What's are you doing?
11:05:18 <beelsebob> wy: I'm writing a pdf graphics library for Haskell
11:05:33 <beelsebob> (completely pure Haskell 98, native wonderfullness)
11:05:38 <wy> beelsebob: That's cool.
11:05:53 <wy> what does native wonderfullness mean?
11:05:53 <chessguy> beelsebob: didn't i just see something like that get announced recently?
11:06:05 <beelsebob> so far... I can successfully produce PDFs with as many blank pages as you like all of different sizes
11:06:14 <beelsebob> chessguy: no idea, I'd love you if you could point me at it
11:06:28 <beelsebob> wy: it means I'm not using anything glasgow-haskell related etc
11:06:42 <beelsebob> so it should be fine with Hare, nhc, yhc, Hat, any of the tools out there
11:06:48 <beelsebob> unlike just about anything else
11:07:09 <beelsebob> the primary aim tbh, is to provide a nice test case for Hat to debug
11:07:56 <chessguy> oh, my mistake. it was Adobe Shockwave, not PDF
11:08:24 <beelsebob> chessguy: ick, flash :P
11:11:37 <dmwit> Bah.
11:11:49 <dmwit> Numlock totally screws all of xmonad's key commands.
11:12:09 <monochrom> numlock die die die
11:12:20 <dmwit> But it's so useful!
11:12:35 <dmwit> Err, well, I suppose having it off isn't so useful.
11:12:43 <monochrom> Right.
11:12:44 <dmwit> So, sure, numlock die die die
11:14:21 <beelsebob> malcolmw: if you're still there, you may want to have a look at http://skim-app.sourceforge.net/index.html -- it's a pdf viewer that uses Preview's engine (hence is fast and shiny), but it does nice things like auto-reloads when pdflatex changes the file, and doesn't show onscreen controls while you're trying to give a presentation
11:14:23 <lambdabot> Title: Skim | Home
11:14:35 <stepcut> beelsebob: flash may suck, but it is also probably the most popular virtual machine on the planet
11:14:51 <beelsebob> stepcut: sure, doesn't stop me taking the piss out of it
11:15:01 <stepcut> beelsebob: indeed, feel free to
11:15:06 <beelsebob> :D
11:15:24 <ddarius> beelsebob: You may be interested in http://www.slavepianos.org/rd/r/darcsweb.cgi?r=sw-70;a=summary
11:15:27 <lambdabot> Title: darcs - sw-70
11:15:42 <yiwin> i try command line. same result. and i found  gert exe file is 12 MB.
11:15:46 <beelsebob> ddarius: ohh, thanks, that may be useful
11:15:47 <ddarius> Actually, I think that code generates ps/pdf
11:17:31 <wy> beelsebob: you mean you are not using the extension provided by ghc?
11:17:52 <beelsebob> wy: I'm using none of the glasgow extensions
11:18:06 <wy> I saw yesterday from clements website that he has made the Lisp syntax available for Haskell
11:18:15 <ddarius> For a viewer you should just be implementing a ps interpreter.
11:18:48 <fons> hi all
11:18:57 <beelsebob> ddarius: thanks, it would appear to implement a subset of pdf
11:19:01 <beelsebob> and not quite enough for what I want
11:19:05 <beelsebob> but useful it is still
11:19:35 <fons> does anyone know if there's a standard function to obtain init and last in one traversal? or should I create my own one?
11:20:04 <dmwit> ?hoogle [a] -> ([a], a)
11:20:06 <lambdabot> No matches, try a more general search
11:20:12 <dmwit> ?hoogle [a] -> (a, [a])
11:20:12 <ddarius> Subversion!
11:20:13 <lambdabot> List.mapAccumL :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
11:20:13 <lambdabot> List.mapAccumR :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
11:20:13 <lambdabot> Data.List.mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
11:20:31 <mauke> @type liftM2 (,) head tail
11:20:34 <lambdabot> forall a. [a] -> (a, [a])
11:20:39 <beelsebob> @type takeDrop
11:20:42 <lambdabot> Not in scope: `takeDrop'
11:20:47 <beelsebob> @hoogle takeDrop
11:20:48 <lambdabot> No matches found
11:21:07 <dmwit> fons: Looks like you should roll your own.
11:21:26 <fons> ok, thanks dmwit
11:21:40 <dmwit> fons: Why do you need only one pass?
11:22:03 <beelsebob> dmwit: because it's nice to have half the time used
11:22:11 <beelsebob> okay so it doesn't lower complexity, but it's still nice
11:22:23 <dmwit> beelsebob: I know, I was just wondering if he had already hit a performance barrier or not.
11:23:29 <fons> dmwit, optimization I guess
11:23:43 <fons> it is not a performance barrier
11:24:11 <fons> but ... I hate to code something if I know there's an easy way to make it better
11:24:21 <fons> I guess that haqppens to everyone
11:24:29 <dmwit> Yep, I understand.
11:36:18 <sorear> .
11:36:41 <dmwit> IRC raised error: no plugin found.  In: input of ., first argument.
11:37:17 <ndm> hi sorear, i've refactored lots and lots of derive - derive.exe now uses the TH version
11:39:37 <sorear> nice.
11:48:19 <sorear> @seen
11:57:18 <procyon112> chessguy: ping
11:59:58 <ndm> @seen
12:00:06 <lokam_> what is the type of an StdGen ?
12:00:16 <ndm> @type StdGen
12:00:19 <lambdabot> Not in scope: data constructor `StdGen'
12:00:29 <ndm> @hoogle StdGen
12:00:30 <lambdabot> System.Random.StdGen :: data StdGen
12:00:30 <lambdabot> Random.getStdGen :: IO StdGen
12:00:30 <lambdabot> Random.mkStdGen :: Int -> StdGen
12:00:54 <monochrom> The type of an Int is Int. :)
12:01:15 <lokam_> :D kk
12:01:35 * SamB unsafeCoerce#s it to Word! Oh no!
12:02:39 * SamB thinks some formalisms for optimization would be neat
12:03:45 <monochrom> All optimizations can be backed by formal proofs such as data refinement.
12:04:58 <ndm> SamB: fromInteger? why doesn't that work?
12:05:10 <lokam_> I wish there was some way of distinguishing between input types and output types
12:05:34 <lokam_> like maybe an optional symbol you can add so it's not just another ->
12:05:46 <lokam_> is there anything like that available?
12:06:26 <bos> no, because there's no distinction.
12:06:38 <lokam_> how so?
12:06:47 <monochrom> If there is no mutation there is no need.
12:06:50 <bos> think about (+) :: a -> a -> a
12:07:05 <bos> you can partially apply it, as (1+)
12:07:28 <SamB> ndm: does that unsafeCoerce#?
12:07:44 <lokam_> it's just easier to understand when you don't see the function declaration to see the amount of input varibles
12:07:47 <SamB> also, even if it does that, isn't as efficient as it could be
12:07:50 <ddarius> lokam_: Co/Contravariance indicators would do what you want, but most people don't seem to need them.
12:07:56 <ddarius> Z/2 is pretty easy to deal with.
12:08:20 <SamB> I mean, it doesn't do anything -- but it does confuse GHC's optimization passes
12:08:37 <bos> so what you think of as the second argument to (+) is, on the one hand, an "output" of the partially applied (1+)
12:08:45 * int-e has a use of  flip unsafeCoerce#   somewhere in his code :)
12:08:49 <lokam_> hmmm
12:08:58 <SamB> @type flip unsafeCoerce#
12:09:01 <lambdabot> Not in scope: `unsafeCoerce#'
12:09:10 <SamB> narg.
12:09:55 <ddarius> :t let uC = undefined in flip uC
12:09:58 <lambdabot> forall a b c. b -> a -> c
12:10:05 <monochrom> Haddock achieves the same goal by formatting the function signature nicely around ->'s.
12:10:06 <sorear> @type flip GHC.Prim.unsafeCoerce#
12:10:08 <lambdabot> forall a b c. b -> a -> c
12:10:10 <ddarius> :t let uC = undefined :: a -> b in flip uC
12:10:12 <lambdabot> a -> b in flip uC :: forall a b c. b -> a -> c
12:10:22 <sorear> ddarius: unsafeCoerce# is in scope
12:10:46 <ddarius> sorear: flip undefined would've been shorter still
12:11:34 <ddarius> bos: All that is handled nicely by variance annotations.
12:11:38 * SamB wonders why dosemu-freedos isn't at 1.0 yet
12:12:56 <ndm> SamB: i suspect it could do, if appropriately optimised
12:13:58 <SamB> ndm: you mean {-# RULES fromIntegral = unsafeCoerce# :: Int -> Word #-} ?
12:14:14 <SamB> or are you talking about another "it" and "so"?
12:15:54 <yiwin> what is hpaste.org?  what be useful?
12:16:39 <SamB> hpaste.org is the official #haskell pastebin/pastebot
12:16:40 <ndm> SamB: i mean there is no reason it couldn't do it easily with the appropriate optimisations
12:17:01 <vincenz> @localtime psykotic
12:17:03 <lambdabot> Local time for psykotic is Mon Apr  9 04:19:31
12:17:15 <SamB> unfortunately, last I checked, GHC wasn't too good at seeing past nops
12:17:36 <yiwin> wha is pastebin. post anything?
12:17:47 <Ulfalizer> @localtime Ulfalizer
12:17:51 <lambdabot> Local time for Ulfalizer is Sun Apr  8 21:16:53 2007
12:18:09 <Trollinator> Hi, can someone help me? i have this function for converting an integer into a (reversed) list of digits: http://hpaste.org/1308
12:18:12 <monochrom> ?hpaste
12:18:13 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:18:13 <SamB> yiwin: when you want help with a small program that you are writing, you paste it to the pastebin
12:18:46 <Trollinator> but it does garbage vor big integers
12:18:58 <yiwin> oh, i see. thank you SamB
12:19:35 <monochrom> It works for me, Trollinator.
12:20:06 <Trollinator> monochrom: can you try it with 4294967295? I'm getting an infinite list of 9
12:20:16 <monochrom> > 4294967295 :: Int
12:20:18 <lambdabot>  -1
12:20:25 <monochrom> That may explain better.
12:20:35 <opqdonut> > 4294967295 :: Integer
12:20:36 <lambdabot>  4294967295
12:20:38 <opqdonut> hotfix :)
12:21:11 <Trollinator> 4294967295  :: Int
12:21:24 <Trollinator> 4294967295 :: Int
12:21:26 <monochrom> Need prefixing >
12:21:33 <Trollinator> i see
12:21:40 <Trollinator> > 4294967295 :: Int
12:21:42 <lambdabot>  -1
12:22:04 <monochrom> At your ghci or hugs prompt you can also enter "4294967295 :: Int" and see what happens.
12:22:46 <Trollinator> hum.
12:23:12 <Trollinator> how come ghci can calculate 2^5000 perfectly?
12:23:23 <phoniq> > [2^32+x :: Int|x<-[-2..2]]
12:23:24 <sorear> because it defaults to Integer
12:23:25 <lambdabot>  [-2,-1,0,1,2]
12:23:27 <monochrom> Because when you don't say "Int" the default is "Integer".
12:23:36 <sorear> > 3^5000
12:23:38 <lambdabot>  4038997629787155339700863409815084778394498166775976374862318662815021844263...
12:23:41 <sorear> > 3^5000 :: Int
12:23:43 <lambdabot>  565473185
12:23:48 <sorear> > 3^5000 :: Int64
12:23:49 <lambdabot>  8516837517657665441
12:23:55 <Trollinator> oh, so Integer is different from Int? Thanks!
12:24:23 <monochrom> I love shattering other people's worlds.
12:24:47 <sorear> > [2174000000 :: Int ..]
12:24:50 <lambdabot>  [-2120967296,-2120967295,-2120967294,-2120967293,-2120967292,-2120967291,-21...
12:24:53 <opqdonut> Integer is arbitrary precisiob
12:24:54 <opqdonut> *n
12:25:17 <sorear> > [2147483640 :: Int ..]
12:25:19 <lambdabot>  [2147483640,2147483641,2147483642,2147483643,2147483644,2147483645,214748364...
12:25:23 <sorear> > [2147483645 :: Int ..]
12:25:25 <lambdabot>  [2147483645,2147483646,2147483647]
12:25:55 <eumenides> @type 2^5
12:25:58 <lambdabot> forall t. (Num t) => t
12:26:01 <sorear> So, why do we have Word but not Natural? :)
12:26:12 <ddarius> > foldl' (+) 10000000000.0 $ replicate 100 0.1
12:26:14 <lambdabot>  1.0000000010000038e10
12:26:27 <ddarius> > foldl' (+) 100000000000000000000000000000.0 $ replicate 100 0.1
12:26:29 <lambdabot>  1.0e29
12:27:14 <ddarius> sorear: Because Word has an additive inverse.
12:27:36 <monochrom> I don't know.
12:27:47 <TomMD> Natural has been proposed along with a bounded version 'Nat'.  I just don't think anyone has coded it up yet.
12:28:06 <TomMD> You should beable to find a mention of this on the mailing list.
12:28:37 <Trollinator>     Couldn't match expected type `Int' against inferred type `Integer'
12:28:37 <Trollinator>     In the first argument of `(:)', namely `(mod a 10)'
12:28:53 <Trollinator> how do i fix that?
12:29:05 <sorear> Trollinator: get rid of Int?
12:29:05 <ddarius> TomMD: A bounded version would be trivial and would, if I understand you correctly, be Word.
12:29:37 <sorear> > negate (1::Word)
12:29:39 <lambdabot>  4294967295
12:29:47 <Trollinator> sorear: i've replaced Int with integer in my function's signature, but now it won't compile
12:29:49 <ddarius> Incidentally, I was being serious when I said that Word has an additive inverse (and suggested implicitly that Naturals don't)
12:29:58 <Trollinator> giving me the above error messagt
12:30:02 <Trollinator> message
12:30:07 <TomMD> ddarius: Luckily aliases are easy... type Nat = WordXX
12:31:02 <Trollinator> ah, i fixed it... thanks!
12:31:35 <chessguy> procyon112: pong
12:31:37 <ddarius> TomMD: I'd prefer it to be called Word rather than Nat.
12:32:25 <sorear> I'd like Int called SignedMachineWord and Integer called Int.
12:33:02 <ddarius> sorear would like everyone to use Integers.
12:33:58 <sorear> exposing yourself to integer overflow should take MORE typing, not less.  just like we make garbage collected primitves easier to use than Ptrs.
12:36:13 <ddarius> What integer overflow?  I only see wrapping.
12:36:18 <Trollinator> OK, how do i cast an Integer to an Int?
12:36:22 <sorear> fromInteger
12:36:30 <sorear> haha, I figured out why my prolog isn't working
12:36:42 <sorear> the repl was inserting clauses backward
12:37:18 <ddarius> sorear: Since I suspect SLD resolution means nothing to you, do you evaluate the rules depth-first?
12:37:30 <sorear> yes
12:37:34 <chessguy> sorear: you wrote an implementation of prolog?
12:37:57 <sorear> well, something very similar to it.
12:38:03 <Trollinator> great! you guys rock.
12:38:06 <ddarius> chessguy: They're easy to do.
12:38:32 <sorear> no IO, no cut, syntax is haskell-like with ML variable notation
12:38:34 <ddarius> > fromInteger 2^33 :: Int
12:38:36 <lambdabot>  0
12:38:38 <sorear> no not
12:38:54 <ddarius> cut, IO, and actually the syntax too are all ugly
12:39:11 <ddarius> Prolog's not is ugly but it could be nicer.
12:40:02 <SamB> prolog has "not"?
12:40:06 <SamB> that does sound nasty!
12:40:08 <sorear> yea!
12:40:14 <sorear> negation as failure!
12:40:30 <sorear> not(A) tries to prove A, and fails iff that succeeds
12:41:02 <sorear> and just for the record my prologoid has completely crashed ghci.
12:41:10 <sorear>  exception :: GhcException and hang.
12:41:27 <chessguy> sounds like the old joke, 'if you try to fail and succeed, which did you do?'
12:41:30 <sorear> I'd file a bug but I can't seem to reproduce on command :(
12:41:33 * SamB wonders if he is going to crash DOS at some point
12:42:26 <pcmoritz> hi, i have got a question regarding polygon clipping in haskell, for non-intersecting polys.
12:42:46 <pcmoritz> sutherland is easy to code, but it only works for convex ones...
12:43:06 <pcmoritz> now, i think, weiler-atherton is the right thing
12:43:23 <pcmoritz> but i don't know how to represent the data-structure
12:43:39 <SamB> how do they do it in maths?
12:44:11 <pcmoritz> can you give me some hint, how to get the double linked list?
12:44:22 <SamB> eek
12:44:35 <SamB> those are not a reasonable datastructure in Haskell
12:44:44 <pcmoritz> hm
12:44:46 <SamB> at least not in functional code
12:45:00 <chessguy> pcmoritz: http://haskell.org/hawiki/TyingTheKnot may intrest you
12:45:01 <lambdabot> Title: TyingTheKnot - The Haskell Wiki
12:45:06 <SamB> not if you intend to *change* them, anyway
12:45:45 <pcmoritz> thx, i already read about that in the mailing-list
12:45:57 <pcmoritz> (@chessguy)
12:46:05 <SamB> what sort of access pattern do you need?
12:46:09 <pcmoritz> but i need to change them...
12:46:29 * SamB wonders if some kind of zipper would work?
12:46:36 <pcmoritz> it is some pointer-like structure
12:46:49 <chessguy> zipper monad!
12:46:58 <ddarius> data DLNode a = Node (STRef (DLNode a)) a (STRef (DLNode a))
12:47:00 <pcmoritz> i also need connections between the different lists for the polygons
12:47:18 <SamB> you could try doing it in ST, I guess
12:47:20 <ddarius> If you want circular, add some Maybe's or | Empty for linear.
12:47:37 <SamB> ah, yeah, like ddarius says ;-)
12:47:54 <sorear> kind error :(
12:48:07 <sorear> data DLNode s a = Node (STRef s (DLNode a)) a (STRef s (DLNode a))
12:48:12 <SamB> yeah, that does need some esses ;-)
12:48:24 <SamB> damn esses :-(
12:48:32 * ddarius turns off his de-esser.
12:48:41 <pcmoritz> http://cs1.bradley.edu/public/jcm/weileratherton.html
12:48:43 <lambdabot> Title: weiler-atherton
12:48:45 <sorear> I just love the way ST makes you eta-ize all your data structures :)
12:48:53 <pcmoritz> here is a description of the algo
12:49:20 <pcmoritz> and i am not a monad expert, i have to say...
12:49:41 <mauke> is lambdabot's @quote list on the web somewhere?
12:49:45 <sorear> yes
12:50:12 <sorear> Wouldn't it be easier to scan-convert the polygon *first* and *then* clip the horz-line primitives?
12:50:43 <sorear> http://www.cse.unsw.edu.au/~dons/lambdabot/State/quote
12:51:02 <mauke> that doesn't look very readable
12:51:05 <sorear> thank dons for the fact that it's not plain text anymore
12:51:15 <sorear> gzip was his idea
12:51:42 <SamB> sorear: he really ought to mark it properly
12:52:10 <ddarius> I was wondering what it was.  I never got around to looking at how lambdabot read it.
12:52:36 <SamB> i.e. with .gz at the end of the filename
12:52:42 <sorear> in the good old days it was
12:53:03 <SamB> so that the webserver would have half a chance of figuring out the encoding and putting it in the HTTP headers
12:53:05 <sorear> nick \n quote1 \n quote2 \n quote3 \n \n nick \n quote1 ...
12:53:17 <sorear> perfectly human readable
12:54:05 <SamB> it still is that
12:54:15 <SamB> just gzipped
12:54:20 <Korollary> oh come on. <quote nick="keal>yadda yadda</quote> would have been much better! Oink.
12:54:39 <SamB> Korollary: heh
12:54:42 <SamB> that wastes space
12:54:55 <pcmoritz> do you have a web resource that explains, how one could achieve "imperative" data-structure, that can be changed?
12:54:57 <Korollary> but it's enterprise ready
12:54:57 <ddarius> SamB: If you just gzip it though...
12:55:18 <sorear> Korollary: it is hard to parse that way ...
12:55:23 <SamB> Korollary: the quotes aren't enterprise-ready anyway
12:55:29 <Korollary> why are you being rational
12:55:36 <ddarius> pcmoritz: Read "Tackling the Awkward Squad" then apply to STRefs.
12:55:42 <ddarius> If it doesn't cover it.
12:55:52 <pcmoritz> ok, thx
12:56:03 <SamB> Korollary: plus, that would have meant depending on an XML library
12:56:06 <sorear> @google Lazy functional state threads
12:56:06 <sorear> ^^^ the definitive reference to ST
12:56:09 <lambdabot> http://www.dcs.gla.ac.uk/fp/papers/lazy-functional-state-threads.ps.Z
12:56:13 <sorear> SamB: that wasn't XML
12:56:13 <pcmoritz> if i have a more concrete question, i will come back :)
12:56:14 <SamB> and useless dependencies are something that we cannot abide
12:56:26 <ddarius> Only what 14 years old?
12:56:33 <SamB> sorear: well, I was assuming it was meant to be...
12:56:34 <sorear> SamB: <Korollary> oh come on. <quote nick="keal>yadda yadda</quote> would have been  <-- note unbalanced "
12:56:41 <sorear> ah okay.
12:57:00 <SamB> I didn't feel like arguing over a typo ;-)
12:57:13 <sorear> besides, aren't the keal quotes hard-wired into the bot?
12:57:21 <SamB> true enough!
12:57:24 <sorear> @quote keal
12:57:25 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
12:57:25 <SamB> @quote keal
12:57:26 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
12:57:30 <SamB> @keal
12:57:30 <lambdabot> i try make program called Glyph to do it but my script lang called T too slow. i invent T
12:58:08 * ddarius hugs vim.
12:58:28 * Korollary ghc emacs
12:58:50 <ddarius> Touche.
12:58:50 * merus ghc nano
13:00:54 <sorear> grr, I keep being tempted to add features like timouts to my nano-prolog
13:00:56 * ddarius doesn't really like the deprecation of QuotesPage.
13:01:09 <ddarius> sorear: That's the path of darkness.
13:01:18 <Korollary> or nano-darkness
13:01:37 <ddarius> sorear: Instead extend to a monadic linear logic and get kickass constraint and concurrency.
13:01:38 <sorear> ddarius: I get the feeling you don't like the deprecation of hawiki, period
13:02:04 <sorear> ddarius: I still have absolutely no clue how to implement a linear logic.
13:02:21 <sorear> First order (in the CS sense) linear logic is easy.
13:02:22 <ddarius> sorear: I don't mind that.  I only use @oldwiki so much because I know what's there and I don't have to worry about crazy casing conventions and spaces and such.
13:02:25 <eumenides> RWS = reader+writer+state?
13:02:48 <ddarius> @wiki Stack_overflow ?
13:02:48 <sorear> but when my functions are unique ... *brain explodes*
13:02:49 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow ?
13:02:52 * SamB wishes DOSEMU would pick up on application-done highlighting and use that for the text selection
13:03:54 <flux> samb, you've got the source ;)
13:04:07 <SamB> flux: true enough
13:04:15 <flux> I'd imagine most of the development of dos emulators has gone to dosbox, though?
13:04:24 <SamB> ick.
13:04:44 <SamB> dosemu can do CPU emulation, too, you know...
13:05:09 <flux> I didn't, infact
13:05:29 <sorear> Can't we just write and use portable programs? :)
13:05:35 <SamB> dosbox doesn't even use a real SHELL, does it? last I checked the shell builtins were implemented in NATIVE C++
13:06:02 <flux> it seems to me dosbox has been developed with more practical approaches: if it doesn't work, fix it :)
13:06:04 <SamB> (as evidenced by some of their failure modes)
13:06:04 * sorear runs arbitrary POSIX/ANSI_C programs, natively!
13:06:11 <flux> for some reason the dosemu-approach didn't quite work with games
13:06:43 <SamB> what approach do you speak of?
13:07:20 <flux> dosbox was written with the purpose of running applications (games), dosemu is a suite of emulating a dos environment?
13:08:09 <SamB> dosemu runs a DOS
13:08:51 <SamB> somehow managing to hook in a driver that lets it access the host's filesystem
13:09:46 <SamB> in dosemu, if it doesn't work... well, you probably have to figure out *why* it doesn't work
13:09:53 <SamB> before you fix it
13:10:11 * Heffalump looks for someone familiar with the US banking system
13:10:24 <SamB> maybe some things can't work with the native CPU...
13:10:32 * sorear expects the network redirector could be abused for this
13:11:15 <SamB> well, the part I'd like to see is how they load the driver before DOS tries to access the disk ;-)
13:11:20 <Heffalump> in particular, I'm in the UK, but I have a US bank account dating from several years back when I worked in the US for a few months, and a check in US dollars drawn on a US bank that I'd like to pay into it. Is it likely to be easy to do this by post?
13:11:39 <SamB> Heffalump: I think so
13:11:44 <sjanssen> dons: I'm not having trouble killing firefox windows
13:11:49 <Heffalump> do I need to endorse the back of it or anything?
13:12:12 * SamB still walks to the bank to cash checks
13:12:18 <Cheery> thetallguy: hi
13:12:35 <ddarius> Direct Deposit
13:12:39 <SamB> Heffalump: I think you are supposed to use some kind of form
13:12:44 <narain> Heffalump: why don't you call the bank and ask them?
13:12:55 <SamB> yes, calling the bank seems like a good idea
13:12:57 * ddarius suggests what narain says.
13:13:01 <Heffalump> ok, thanks :-)
13:16:02 <sorear> is hugs supposed to have readline? ...
13:16:15 <thetallguy> Cheery: I replied over on the side.  Subject is CSS library.
13:17:07 * ddarius sorely needs to buy a (new) electric guitar.
13:17:36 <Cheery> thetallguy: I didn't get a reply
13:18:26 <Stinger> can someone recommend a haskell library to simply play sounds (running on windows)
13:18:46 <Stinger> i.e. simple .wav or similar playback
13:19:26 <thetallguy> Cheery:  I started work on a CSS library  in Jan but got distracted by a car accident
13:19:26 <thetallguy> Stepcut said you were tackling the problem as well.
13:19:26 <thetallguy> If you were stalled, I might go back to it.
13:19:26 <thetallguy> Most of what I did was figure out how ugly CSS was.
13:20:50 <Cheery> thetallguy: I were stalled but I'm persistent
13:20:50 <ndm> woohoo, I now have SYB Data and Typeable for Template Haskell, thanks to derive
13:21:11 <thetallguy> Cheery: glad to hear it.
13:21:22 <thoughtpolice> does anybody know of a good introduction to monad transformers, or at least some examples of how they may be used (practically.) I've read things like on wikibooks and some assorted tutorials, but i'm having a hard time understanding the concept
13:21:22 <ddarius> ndm: So how many years did that take?
13:21:40 <dmwit_> ?go meet the monads
13:21:43 <lambdabot> http://www.sampou.org/haskell/a-a-monads/html/meet.html
13:21:43 <lambdabot> Title: Meet the Monads
13:21:43 <ddarius> Stinger: There might be PlaySound in the Windows API bindings.
13:22:03 <dmwit_> thoughtpolice: oof, not that one.
13:22:27 <thoughtpolice> i realize transformers are like layers, and you can go inwards layers by using lift and whatnot, but is that really all there is too it? i'm suspicious it's more complex than that, but i've been duped by haskell in that fashion before
13:22:44 <ddarius> thoughtpolice: Don't add complexity!
13:22:53 <Cheery> thetallguy: it shouldn't take further than tomorrow that I'll be done
13:22:55 <dmwit_> thoughtpolice: http://www2.lifl.fr/~boulet/formation/CALP/man/monads/html/
13:23:00 <lambdabot> Title: All About Monads
13:23:10 <Stinger> ddarius, hmm ok I'll try google that
13:23:18 <ddarius> @docs
13:23:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
13:23:19 <thetallguy> Cheery:  Great, I'll wait.
13:23:23 <thoughtpolice> dmwit_: thanks
13:23:31 <ddarius> @index PlaySound
13:23:32 <lambdabot> bzzt
13:23:43 <thoughtpolice> ddarius: i'll keep it in mind
13:24:04 <ddarius> sorear: Lookup CLF (the Concurrent Logic Framework)
13:24:14 <thoughtpolice> i'm just suspicious that it's really as simple as it's been described. if so, i'm just having a little trouble actually putting it into implementation
13:25:15 <ddarius> thoughtpolice: Most things, especially mathematical things, are ridiculously simple.  Most of the trouble learning such things is removing the complexity you add
13:25:53 <thoughtpolice> i figured that out in my algebra class 2 class. my dad tells me the same thing all the time
13:26:31 <Cheery> thetallguy: I'll leave out some properties thought, ones which I found annoying
13:26:39 <eumenides> does anyone have an example of RWS use?
13:26:43 <thoughtpolice> ddarius: but thanks for the tip :)
13:26:51 <Cheery> but I guess one who needs them can add them later
13:27:00 <mux> can I safely write things such as ("ab" ++) instead of ('a':) . ('b':) knowing the compiler will optimize it?
13:27:57 <mux> I mean, at least for GHC
13:28:48 <dmwit_> ?src (++)
13:28:49 <lambdabot> (++) []     ys = ys
13:28:49 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
13:29:08 <mux> I was thinking of rewrite rules
13:29:57 <kpreid> I'd think optimizing that would be a matter of constant folding
13:30:14 <kpreid> ...maybe
13:30:19 <ddarius> eumenides: If you happen to want, Reader, Writer, and State all at the same time...
13:30:31 * ddarius has never used it and never sees himself using it.
13:30:37 <dmwit_> Stinger: Maybe you can use OpenAL?
13:30:47 <mux> however it's implemented, I guess my question is does GHC have this optimization?
13:30:59 <Stinger> dmwit, yeah I've just discovered that
13:31:12 <Stinger> it looks ridiculously overcomplicated for what I want to do though :)
13:31:16 <dmwit_> o
13:31:21 <ddarius> mux: A few rounds of inlining may do it.
13:31:44 <ddarius> mux: Write a very small program and look at the core.  It should be tractable at that small.
13:31:46 <sorear> no, it won't inline
13:31:55 <sorear> but that's a good thing...
13:32:26 <sorear> usually
13:32:37 <eumenides> ddarius: i don't even understand how to use it
13:32:40 <eumenides> @type RWS
13:32:42 <lambdabot> forall r s a w. (r -> s -> (a, s, w)) -> RWS r w s a
13:32:43 <stepcut> eumenides: if you are writing a compiler you might do, type CompileRWS a = RWS SymbolTable  [TopLevel] Int a
13:32:45 <sorear> ('H' : 'e' : 'l' : 'l' : 'o' : x) takes a LOT more code than (++) (unpackCString# "Hello"#) x
13:33:03 <ddarius> Well it wouldn't be changed into ('a':) . ('b':) but rather (\rest -> 'a':'b':rest) if anything.
13:33:06 <thetallguy> Cheery: okay
13:33:15 <kpreid> eumenides: that's the type of the constructor, which you might not use
13:33:16 <thetallguy> Cheery: we may have differennt goals
13:33:19 <kpreid> @type runRWS
13:33:22 <lambdabot> forall r w s a. RWS r w s a -> r -> s -> (a, s, w)
13:33:42 <sorear> mux: ghc HAS a rule to optimize your code, but it is commented out
13:33:53 <kpreid> input is action, environment and initial state; output is result, final state, and output
13:33:57 <thetallguy> Cheery: I was less focussed on combinators than I was on an exact type, representing all CSS and nothing more
13:34:14 <ddarius> eumenides: It's the straightforward independent combination of Reader, Writer, and State.  If you understand how each of those work you should understand RWS.
13:35:03 <Cheery> I'm primarily focussed on combinators, because they basically outline the stuff I will write instead of those nasty stylesheets
13:35:40 <mux> sorear: interesting
13:35:41 <sorear> -- The foldr/cons rule looks nice, but it can give disastrously bloated code when commpiling (  array (a,b) [(1,2), (2,2), (3,2), ...very long list... ] ) i.e. when there are very very long literal lists So I've disabled it for now. We could have special cases for short lists, I suppose.
13:35:41 <sorear> -- "foldr/cons" forall k z x xs. foldr k z (x:xs) = k x (foldr k z xs)
13:35:48 <thetallguy> Cheery: sounds like we might be able to merge the two and come out with a good thing
13:36:00 <sorear> with foldr/cons
13:36:27 <Stinger> hmmm I guess I need something like cygwin under windows to get Cabal stuff to work properly? (in general)
13:36:28 <mux> sorear: I guess this optmization only applied to constant strings wouldn't be a problem
13:37:05 <sorear> "foo" ++ x ==> foldr (:) x "foo" ==> 'f' : foldr (:) x "oo" ==> 'f' : 'o' : foldr (:) x "o" ==> 'f' : 'o' : 'o' : foldr (:) x [] ==> 'f' : 'o' : 'o' : x
13:38:38 <sorear> this same rule, interestingly, applies for sum [x , y]
13:38:42 <sorear> ==> x + y
13:44:46 <Botje> Instance Short [a] where .. -- :)
13:46:01 <sorear> nice try.  unfortunatly classes classify types, and long lists inhabit the same types as short lists.
13:46:23 * sorear still doesn't know what dependant typing is, but it sure sounds good
13:46:35 <dmwit_> ?help let
13:46:36 <lambdabot> let <x> = <e>. Add a binding
13:48:31 <Heffalump> sorear: it's just the general concept of having types that are allowed to depend on values
13:48:47 <narain> :t join (\x -> undefined)
13:48:50 <lambdabot> forall t a. (Monad ((->) t)) => t -> a
13:49:03 <dmwit_> > let choose a b = div (prod [1..a]) (prod [1..(a - b)] * prod [1..b]) in 4 `choose` 3
13:49:04 <lambdabot>   Not in scope: `prod'
13:49:18 <dmwit_> > let choose a b = div (product [1..a]) (product [1..(a - b)] * product [1..b]) in 4 `choose` 3
13:49:20 <lambdabot>  4
13:49:49 <narain> :t div
13:49:51 <lambdabot> forall a. (Integral a) => a -> a -> a
13:49:55 <narain> :t (/)
13:49:58 <lambdabot> forall a. (Fractional a) => a -> a -> a
13:50:41 <ndm> sorear, it breaks type inference totally, its great if you want to prove a theorem, sucks if you want to hack together an evolving program
13:51:06 <Heffalump> that's a slightly extreme view :-)
13:51:45 <ndm> true, but i've yet to find anyone who would hack together a program using dependent types
13:51:56 <sorear> Heffalump: yeah, I get that much.  but deeper issues confound me; in the CoC, a bool is forall (a::*). a -> a -> a.  what is the type of  \ (x : bool) -> x 2 'a'?  notice that the type of types does not inhabit *
13:52:08 <SamB> ndm: I think there are a ways to go before that is practical for many of us
13:53:00 <SamB> I mean, like, a decent dependantly typed language which doesn't require xemacs to edit would be a start.
13:53:35 <sorear> Heffalump: augustss already told me the answer but I didn't understand it :)
13:54:09 <ndm> SamB: will this dependent type language let you write things which crash and don't terminate?
13:54:18 <ndm> if not, its likely to be a lot of work, and not suitable for hacking
13:54:38 <ndm> personally, i like Haskell, and think the types are exactly as powerful as they need to be - if not slightly over powerful in GHC
13:54:38 <SamB> sure you can write programs that crash... during typechecking ;-P
13:55:32 <narain> won't you still be able to write non-dependently typed programs in a dependently typed language?
13:55:36 <sorear> ndm: why does the peephole handle InfixE?  My thought had been to write it normally and let the peephole handle making InfixEs.
13:55:42 <narain> (independently typed?)
13:56:51 <mattam> narain: indeed, you can.
13:57:30 <ndm> sorear: because there was InfixE's cropping up from Binary, so I needed to
13:57:41 <Heffalump> sorear: fair enough. I don't understand them in any detail either.
13:58:11 <mattam> And inference can be traded for a good implicit arguments system btw. The real difference with a usual prog. language is treatment of computational effects, nontermination included
13:58:48 * mattam develops a dependently-typed programming language on top of Coq
14:01:40 <mattam> ndm: I hack programs using dependent types
14:02:59 <sorear> is there a emacs-keys lightweight editor that doesn't crash on long lines?
14:03:16 <Korollary> emacs crashes?
14:03:25 <ddarius> \Pi x:Bool.x Int Char
14:03:25 <sorear> mg fails the last count ... and the debian maintainer has told me this is deliberate
14:03:43 <dmwit_> emacs isn't lightweight... =P
14:03:44 <sorear> Korollary: no, but it fails the second
14:03:47 <ddarius> @quote chromatic
14:03:48 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
14:03:51 <Korollary> how about Yi heh
14:04:18 <narain> ?quote desert
14:04:19 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
14:04:21 <narain> ?quote dessert
14:04:22 <lambdabot> No quotes match. Do you think like you type?
14:04:33 <dmwit_> ?quote delicious
14:04:33 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
14:04:34 <sorear> Korollary: As a Yi hacker, I assure you ALL of its algorithms are O(ridiculous)
14:04:47 <sorear> (former) yi hacker
14:05:08 <Korollary> heh
14:05:57 <sorear> ddarius: ok, but what is the type of that term?
14:06:08 <sorear> no, wait, Pi, that is a type
14:06:27 <sorear> ddarius: how do you apply x to Int?  Int doesn't have a type of type *
14:07:36 * ddarius would actually have to look at the syntax of CoC, but essentially you need to use the boolean to choose the return type just as you will the returned value.
14:07:42 <ddarius> @quote cjs
14:07:43 <lambdabot> cjs says: I have to explain this shit to people. I mean, I start out right, "Hey, you know how you always have these bugs because what you thought was in the variable is not there?" And I get all of
14:07:43 <lambdabot> these nods of agreement. "Well, I've found a new language that solves that problem." Audience: "Ooooh! How?" Me: "There's no variables!" And then they all start moving away from me slowly....
14:07:56 <opqdonut> yeah
14:07:59 <mattam> oh
14:08:49 <mattam> more like "forall x : bool, if x then Int else Bool"
14:09:57 <mattam> then "fun x => if x then 1 else false" would be a well-typed term of this type
14:10:09 <sorear> mattam: I will have nothing to do with inductive constructions.  I'm having enough trouble with Church encoding.
14:10:48 <mattam> What trouble do you have ?
14:10:57 * narain gets the unsettling suspicion that there are type-level bools which are different from normal bools
14:11:08 <mattam> no there aren't
14:11:14 <sorear> bool is a synonym for forall k : *, k -> k -> k, no?
14:11:56 <sorear> so consider 'forall x : bool, x * Int Bool'
14:12:03 <sorear> * being the type of Int and Bool
14:12:15 <mattam> no, you would't have dependent elimination which permit to write the former in that case I think.
14:12:16 <sorear> but the first arg to a bool needs to have type *
14:12:30 <sorear> and * !:- *
14:12:35 <mattam> Actually inductive types are essential here
14:13:08 <sorear> mattam: your second-to-most-recent line makes no sense to me
14:13:42 <sorear> if inductive types are essential, how did they get by without them in earlier versions of the coq type checker?
14:14:05 <mattam> They didn't publicize it before adding inductive types
14:14:32 <chessguy> procyon112: pong
14:14:38 <chessguy> ?seen procyon112
14:14:39 <lambdabot> procyon112 is in #haskell. I last heard procyon112 speak 2h 17m 20s ago.
14:15:31 <sorear> mattam: oh ... so now I have to understand dependent case at the SAME type as dependent lambda
14:15:32 <mattam> Ok, your example with a church-encoding works, i thought not at first.
14:15:42 * sorear really likes to keep his dependency groups small
14:15:58 <sorear> -2s/type/time/
14:16:20 <mattam> No no, you can keep it simple without inductives if you like
14:17:22 <mattam> Except the church encoding is well, an encoding hence kind of ugly
14:18:46 <procyon112> chessguy: yo
14:19:00 <chessguy> procyon112: how goes it?
14:19:21 <procyon112> I have an interesting idea I'm playing with.
14:19:51 <procyon112> I did make the evaluator non strict, which inexplicably sped it up by 10%
14:19:53 <chessguy> instead of integratig our code? :)
14:20:41 <procyon112> I'm just wondering the best way to do it.
14:20:49 <mattam> sorear: what's the trouble then ?
14:21:19 <chessguy> procyon112: hmm. well, i guess that makes sense, in that if we never need the fitness of an individual, we never need to evaluate it
14:21:39 <procyon112> I think making the State Environment UserData standard might be a way to go.
14:21:56 <sorear> mattam: * does not have type *
14:22:01 <chessguy> we can do that
14:22:20 * sorear has finally broken down and installed a really really bloated dependant type checker
14:22:21 <chessguy> wait, that means user programs are forced to be monadic?
14:22:28 <procyon112> No, I just got rid of the map eval forest, and moved the eval's to the functions and it went 10% faster for some weird reason.
14:22:42 * sorear looks at the binary size, and is amazed it doesn't accept +RTS
14:22:56 <mattam> No in fact it is *(i) which has type *(i+1)
14:22:56 <chessguy> hmm
14:23:12 <mattam> There is a hierarchy of *'s
14:23:40 <sorear> mattam: ouch.  I assumed I could stop reading the CoC paper when I reached the Future direction ideas section
14:23:50 <sorear> mattam: and the main development had only one *
14:24:31 <procyon112> chessguy: I'm thinking that the user supplies an environment record, and a GPDataTypes data structure.... Maybe this happens in a GP Monad or something, or maybe we just use state.
14:24:33 <mattam> This is how it works in Coq. In epigram, * : * because adding universes just complicates the thing just to get a paradox free system
14:24:46 <procyon112> I'm playing with getting it to do what I want.
14:24:58 <chessguy> ok
14:25:10 <sorear> mattam: what about girard's paradox?  (NB I don't understand it)
14:25:40 <sorear> mattam: in the coc paper first section, values had types, types had type *, and * had no type at all
14:26:36 <stepcut> bah, RTS.h:15: error: 'CodeLabel' declared as function returning a function
14:26:45 <stepcut> what's wrong with a function returning a function :(
14:27:01 <sorear> everything, since functions aren't first class
14:27:03 <mattam> The Type : Type paradox is solved by this universe construction
14:27:06 <sorear> this isn't C
14:27:10 <sorear> s/C/Haskell/
14:27:16 <stepcut> :p
14:27:17 <mattam> Yes
14:27:17 <sorear> you CAN return a function pointer
14:27:50 <mattam> A more faithfull presentation of the current Coq is ECC, the Extended CoC.
14:27:54 <stepcut> yeah, I can't figure out how to do that. I forgot how to use typedef
14:28:02 <stepcut> typedef CodeLabel (*CodeLabel)();
14:28:32 <mauke> can't do that in C
14:28:34 <sorear> hehe.  IIRC you need to create a structure
14:28:41 <mattam> http://plato.stanford.edu/entries/type-theory/
14:28:42 <lambdabot> Title: Type Theory (Stanford Encyclopedia of Philosophy)
14:28:57 <mattam> This page is enlightening on girard's paradox
14:29:11 <thoughtpolice> dmwit_: yo yo, thanks a lot for the link on transformers, it helped a lot, so i think i'm understanding them better now
14:29:16 <sorear> mattam:  OK, coqtop (aside: is there a less excessively-user-friendly checker?) says Type : Type and doesn't like fun x:bool => if x then true else O.
14:29:37 <stepcut> in C, what is the type of a function that returns a function pointer to itself ?
14:29:50 <Heffalump> that's not expressible, is it?
14:29:56 <mauke> struct foo { struct foo (*fun)(void); }; struct foo self(void) { struct foo tmp = { self }; return tmp; }
14:30:17 <mattam> sorear: Universes are not shown to the user, it said Type(0) : Type(1) in fact
14:30:52 <thoughtpolice> you just wrap it in a structure like mauke showed, that's the way i did at least, but i always felt it was inelegant for some reason
14:31:00 <thoughtpolice> but it worked
14:31:02 <sorear> mattam: *sarcastic nice*
14:31:07 <mauke> void (*hax(void))(void) { return (void (*)(void))hax; }  /* "true" C style */
14:31:14 <procyon112>  stepcut: are you using true C, or C++?
14:31:14 <mauke> just cast it back later :(
14:31:17 <Heffalump> well, yes :-)
14:31:23 <stepcut> procyon112: ansi C
14:31:44 <mattam> Actually I think there is no way to show them if you like.
14:31:55 <dmwit_> thoughtpolice: Great, maybe you can explain them to me someday. ;-)
14:32:07 <thoughtpolice> dmwit_: :)
14:32:54 <dmwit_> So, there are (^) and (**).  Any others like them?
14:32:59 <sorear> ^^
14:33:08 <dmwit_> :t (^^)
14:33:11 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
14:33:18 <dmwit_> There we go.  Thanks!
14:33:36 <mattam> For the second, you must write: Definition f (x : bool) := match x return if x then nat else bool with true => 1 | false => true end.
14:34:21 <mattam> It is because "if" always introduces a non-dependent match
14:34:27 <sorear> mattam: nice.
14:34:54 <sorear> mattam: I thing I've seen enough on GADTs to recognise what's going on there ...
14:35:39 <mattam> Yep, similar stuff
14:36:20 <sorear> we need to know the return and scrutinee types of the case to do the correct checking
14:36:40 <sorear> of course scrutinee is trivially satisfied in CoC, since checking is bottom up
14:37:00 <mattam> if it's dependent yep
14:37:19 <mattam> otherwise you can try to unify the types of the branches
14:37:49 <dmwit_> > [((-1)^^i)/(product [1..i]) | i <- [0..5]] :: [Rational]
14:37:51 <lambdabot>   add an instance declaration for (Integral Rational)
14:38:04 <stepcut> procyon112: ansi C
14:38:09 <stepcut> oops :)
14:38:54 <dmwit_> > [((-1)^^i)/(product [1..i]) | i <- [0..5] :: [Int]] :: [Rational]
14:38:56 <lambdabot>  Couldn't match expected type `Rational' against inferred type `Int'
14:39:41 <dmwit_> :t fromIntegral
14:39:44 <lambdabot> forall a b. (Num b, Integral a) => a -> b
14:40:04 <dmwit_> > [((-1)^^i)/(fromIntegral $ product [1..i]) | i <- [0..5] :: [Int]] :: [Rational]
14:40:06 <lambdabot>  [1%1,(-1)%1,1%2,(-1)%6,1%24,(-1)%120]
14:40:29 <dmwit_> Whew, Haskell is just a bit odd with numeric types.
14:41:31 <opqdonut> yeh
14:42:57 <Philippa> in that it doesn't emulate the oddness of almost every other language, yeah
14:43:31 <opqdonut> in that it is overly consistent and formally correct :)
14:43:38 <ddarius> @quote \*Prolog\*
14:43:39 <lambdabot> psykotic says: Let me get this straight: in your tireless Lisp-bashing efforts you have now dragged out Prolog as an exemplar of practicality? *Prolog*? My goodness, you must be desperate!
14:43:55 <opqdonut> ahh, prolog
14:43:59 <opqdonut> pure form
14:48:29 <mauke> why is oleg so awesome *sigh*
14:48:56 <eumenides> i'm trying to make a toy monad where all computations are performed in mod 2, can someone tell me what i'm doing worng? http://hpaste.org/1309
14:49:47 <sorear> eumenides: that isn't believed possible :(
14:49:48 <rashakil> eumenides: the "monad" part
14:49:50 <vincenz> that'll never work
14:49:54 <mauke> restricted monads are hard (in that I don't know how to make them work)
14:50:02 <bd_> eumenides: Monads can't have restrictions on types; monads must not apply any transformations to the data in question
14:50:04 <vincenz> eumenides: you can't restrict monads
14:50:21 <bd_> because of the rule: return x >>= y  <=>  y x
14:50:37 <sorear> mattam: thank you very much, I think I understand now
14:50:43 <eumenides> oh okay
14:50:48 <Philippa> bd_: more accurately, Monads (as in the type class) can't restrict the types that can be returned - it's not nonsensical to define a monad on a subcategory of the category of haskell types
14:50:50 <mattam> sorear: my pleasure.
14:50:51 <sorear> mattam: I will now prove this fact by writing a type checker!
14:51:10 <mattam> Do it in Coq !
14:51:20 <sorear> expect me to come back in a few hours with a broken program :)
14:51:21 <bd_> Philippa: right, but even if you try to do certain particular transformations on some types, this can be refuted by the monad law above, if you consider the effect of boxing the type
14:51:40 <bd_> You could, however, implement an instance of Num which operates in Mod 2
14:51:46 <sorear> mattam: so the advantages of Coq outweigh the disadvantages of learning a new language? :)
14:51:56 <sorear> I had intended to use Haskell.
14:52:01 <mattam> Greatly
14:52:17 <mattam> But you will need more than a few hours :)
14:52:24 <eumenides> bd_: yeah but i wanted to make a monad hah
14:52:31 <mattam> I suggest beginning with Haskell
14:52:35 <bd_> :)
14:55:15 <balodja> there is a question about running lambdabot under debian
14:55:23 <sorear> works fine here
14:55:40 <balodja> % ./Setup.hs configure
14:55:41 <balodja> ...
14:55:44 <balodja> Setup.hs: cannot satisfy dependency plugins>=1.0
14:55:57 <balodja> sorear: what package do i need to install?
14:55:58 <sorear> you need to install the darcs version of hs-pluginsj
14:56:08 <sorear> it's not packaged for debian yet
14:56:12 <sorear> @where hs-plugins
14:56:13 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
14:56:19 <balodja> :(
14:56:25 <sorear> note that the hsplugins tarball is incompatible with 6.6
14:56:27 <dmwit_> eumenides: Try making a tree monad.
14:57:03 <balodja> fine. i do have 6.6
14:57:56 <eumenides> dmwit_: well okay. it's something i guess
15:05:20 <ddarius> data NonDetSig x = Fail | Amb x x; data FreeMonad sig a = Var a | Comp (sig (FreeMonad sig a)); type NonDet = FreeMonad NonDetSig; instance Monad Functor sig => Monad (FreeMonad sig) where return = Var; Var a >>= f = f a; Comp m >>= f = Comp (fmap (>>= f) m)
15:06:39 <ddarius> @quote training.wheels
15:06:39 <lambdabot> sieni says: python, like php, is just training wheels without the bike
15:07:11 <chessguy> dmwit: what do you mean by a tree monad?
15:07:28 <sorear> instance Monad Tree where ...
15:07:37 <eumenides> chessguy: like list, but a tree?
15:07:42 <dmwit_> right
15:07:49 <chessguy> well, isn't that ambiguous without further specification?
15:07:59 <dmwit_> Sure!
15:08:00 <ddarius> There's a natural one.
15:08:11 <dmwit_> You have to know what (>>=) is and so forth.
15:08:14 <sorear> ddarius: isn't the free monad Cont?
15:08:39 <chessguy> heh. tree monads and free monads, what fun
15:08:50 <ddarius> That (the above) is the free monad generated from an algebra.
15:09:01 <vincenz> ddarius: what's a "free monad"
15:09:12 <sorear> Oh, we're back to algebraic free monads...
15:09:29 <ddarius> A monad that satisfies only the monad laws.
15:09:35 <chessguy> so if there's a natural Monad instance of Tree, why isn't it in Data.Tree?
15:09:46 <vincenz> ddarius: iso?
15:10:01 * ddarius doesn't maintain Data.Tree.
15:10:10 <sorear> like [] is the free monoi
15:10:20 <sorear> [] satisfies only the monoid laws
15:10:24 <dmwit_> ?hoogle Data.Tree
15:10:25 <lambdabot> No matches, try a more general search
15:10:30 <monochrom> Monads want to be free?
15:10:31 <sorear> we know this because [] has a freedom property
15:10:33 <chessguy> ?source Data.Tree
15:10:34 <lambdabot> http://darcs.haskell.org/packages/base/Data/Tree.hs
15:10:38 <vincenz> sorear: namely?
15:10:47 <ddarius> foldr is initial
15:11:15 <vincenz> ddarius: this definition is from CT? the concept of "free"?
15:11:35 <dmwit_> chessguy: It *is* in Data.Tree...
15:11:41 <ddarius> Well, it's been generalized massively in CT, but it's also in various areas of abstract algebra.
15:11:47 <sorear> if A is a set of generators, M is a monoid generated by A, Z is a monoid generated by A, X is a homomorphism from Z to M, there is a homomorphism from [A] to Z
15:11:52 <sorear> or something like that
15:11:55 <vincenz> ddarius: Just not sure what you mean when you say "only the monad laws" ... the questio nis "only instead o....what else"?
15:11:59 <sorear> long lines confuse me :)
15:11:59 <ddarius> A magma is a set equipped with a binary operation.  The free magma is very familiar to programmers.
15:12:08 <chessguy> uh
15:12:21 <chessguy> dmwit_: it's not in the list of instances of Data.Tree
15:12:28 <dmwit_> Look a little lower.
15:12:33 <sorear> vincenz: a Set is a monoid, but an example of an extra law it satisfies is commutativity.
15:12:43 <vincenz> oh right
15:12:44 <sorear> a `S.union` b == b `S.union` a
15:12:50 <sorear> can't do that with lists
15:13:09 <balodja> sorear: more about debian. is there any way to use 'local' package.conf?
15:13:09 <chessguy> nor is ?
15:13:20 <chessguy> nor is it in the source code
15:13:30 <ddarius> vincenz: An example may help, the free monad for an algebra (signature) is it's term algebra essentially.  However, you could identify certain terms to be the same, say commutativeOp x y == commutativeOp y x, then the result would no longer be free.
15:13:33 <sorear> balodja: that's a standard GHC feature
15:13:42 <vincenz> instance Monad Tree where
15:13:42 <vincenz>   return x = Node x []
15:13:42 <vincenz>   Node x ts >>= f = Node x' (ts' ++ map (>>= f) ts)
15:13:43 <vincenz>     where Node x' ts' = f x
15:13:56 <balodja> i see, it's set via command-line parameters
15:13:57 <chessguy> vincenz: why would you paste the answer?
15:14:02 <sorear> balodja: when you're installing hs-plugins, you can use --user for the user-local package db
15:14:07 <chessguy> the whole point is for the newbie to figure it out for himself
15:14:08 <vincenz> chessguy: you said it wasn't there in that link
15:14:08 <dmwit_> chessguy: He copied it from the source you pointed to!
15:14:09 <int-e> sorear: ah you mean [A] is the free monoid over A; for every monoid M generated by A, there is exactly one homomorphism from [A] to M
15:14:45 <sorear> int-e: the second part of that statement is fanse
15:14:51 <sorear> [A] is generated by M
15:14:52 <chessguy> wtf, am i looking at an old copy of the source or something? i swear it's not here
15:14:54 <sorear> er
15:14:56 <sorear> [A] is generated by A
15:15:00 <ddarius> int-e: Or more clearly, the [] is the left adjoint to the functor that takes a monoid to it's underlying set!
15:15:02 <vincenz> ddarius: I see, though "free" seems rather ambiguous, cause one could imagine tons of extra "laws"
15:15:08 <sorear> there is NOT exactly one homomorphism from [A] to [A]
15:15:09 <balodja> sorear: but i need also substitution of global package.conf in such commands like Setup.hs configure
15:15:17 <sorear> id is a homorphism
15:15:20 <chessguy> ah, i am
15:15:30 * SamB fervently hopes he's not decompiling one of the library modules that comes with Turbo Pascal
15:15:30 <sorear> (replicate 2 =<<) is a homomorphism
15:15:32 <chessguy> my bookmark is old :(
15:15:40 <dmwit_> tee-hee! =)
15:16:03 <chessguy> anyway, it's still much easier to ignore the code in a link than when it's just dumped in the channel
15:16:05 <sorear> balodja: you can just modify the global package.conf, if you want a global install
15:16:17 <vincenz> ...
15:16:24 <int-e> sorear: hmm. right
15:16:53 <balodja> but i don't need global install. i want to install hs-plugins only for one local user
15:17:47 <sorear> runhaskell Setup.hs --user --prefix=/home/username
15:17:49 <sorear> ...
15:17:53 <sorear> runhaskell Setup.hs install
15:18:08 <sorear> in older versions of cabal, --user goes to install not configure
15:18:16 <xerox> sorear, in what sense it is a homomorphisms?
15:18:31 <sorear> xerox: that of abstract algebra
15:18:35 <chessguy> so http://haskell.org/ghc/docs/latest/html/libraries/ becomes out of date when base gets updated?
15:19:00 <balodja> sometwo: oh, great thanks
15:19:14 <sorear> @check let foo = (replicate 2 =<<) in foo ([] :: [Char]) == []
15:19:16 <lambdabot>  OK, passed 500 tests.
15:19:32 <sorear> @check let foo = (replicate 2 =<<) in \x y -> foo (x:: [Char]) ++ foo y == foo (x ++ y)
15:19:33 <int-e> sorear: ok, I need to be careful about the injection from A to M. note that [A] is *not* generated by [a,a] | a in A.
15:19:34 <lambdabot>  OK, passed 500 tests.
15:19:44 <xerox> ah, + is ++.
15:19:46 <sorear> see, statistically homomorphic!
15:20:17 <ddarius> For every function A -> B there is a unique homomorphism from [A] -> (B,+,0)
15:21:01 <vincenz> ddarius: given that (B,+,0) is in fact a monoid?
15:21:05 <vincenz> or is that vacuously true
15:21:55 <ddarius> I mean + and 0 to be the arbitrary monoid operations and I'm identifying monoids as triples of underlying set, binary op, and 0 (that satisfy the laws, so technically also some commuting diagrams)
15:22:05 * vincenz nods
15:22:13 <ddarius> And implicitly hiding ([A],++,[])
15:22:18 <vincenz> yep
15:22:32 <chessguy> ?doc Data.Tree
15:22:33 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Tree.html
15:22:45 <vincenz> Alright, just wasn't sure you could always define a monoid on a set ;)
15:23:02 <chessguy> heh, that doesn't have the instance Monad Tree in it
15:23:06 <chessguy> what the heck
15:23:25 <int-e> sorear: so 'M is generated by A' means that there is an injection i: A -> M such that i(A) generates M; and the homomorphisms that I talked about have to respect i. (h(i_[A](a)) = i_M(a))
15:24:40 <ddarius> That injection is the unit of the adjunction
15:25:20 <int-e> ddarius: adjoints elude me. I've tried to wrap my head about their definition serveral times, but I failed to 'get' them.
15:25:48 <int-e> ddarius: so I have to explain that in this clumsy way. :)
15:27:54 <ddarius> The free monoid one is easy, especially when viewed from the perspective of isomorphisms of hom-functors.
15:30:47 <cpfr> any gtk2hs devs here
15:31:22 <int-e> @seen dcoutts
15:31:23 <lambdabot> dcoutts is in #ghc, #haskell-overflow, #haskell and #gentoo-haskell. I last heard dcoutts speak 9h 55m ago.
15:31:35 <ddarius> Mon(([a],++,[]),(b,*,1)) ~ Set(a,b) natural in a and b.
15:32:04 <ddarius> To work out the unit and counit (particularly the counit) it pays to be very explicit about the structures.
15:32:47 <balodja> sorear: one more question about dependensies. what is the 'fps'?
15:33:06 <sorear> balodja: Fast packed strings.
15:33:17 <dmwit> cpfr: What's up?  Somebody here might be able to help you anyway.
15:33:27 <balodja> thanks
15:33:28 <sorear> balodja: it was separately packaged for 6.4, but has been folded into base for 6.6
15:33:30 <cpfr> i got an error when using it
15:33:40 <sorear> balodja: you are using the darcs lambdabot, right?
15:33:41 <cpfr> when I run a onLeaveNotify event
15:33:47 <cpfr> user error (marshalEvent: unhandled event type 11
15:33:47 <ddarius> Already (unsurprisingly) you can see the freeness from that characterization: a monoid homomorphism from [] is completely determined by a function on the underlying elements.
15:33:47 <cpfr> please report this as a bug to gtk2hs-devel@lists.sourceforge.net)
15:34:05 <sorear> balodja: if you use the 6.6 cabal file, it shouldn't depend on fps
15:34:13 <sorear> balodja: ditto hs-plugins
15:35:21 <dmwit> cpfr: (Maybe you should report it to the dev list... ;-)
15:35:40 <cpfr> thought id justt assk
15:36:27 <SamB> sorear: there is lamdabot beyond darcs?
15:36:51 <dmwit> cpfr: yeah
15:37:05 <sorear> SamB: there are tarballs.
15:37:16 <SamB> what be the purpose of that?
15:37:21 <sorear> notaclue
15:38:13 <balodja> sorear: i'm using tarballed lambdabot, i'll try darcs now
15:39:22 <wy> Hi, anyone here using darcs with apache under Windows?
15:39:29 <vincenz> SamB: stable releases?
15:40:01 <wy> I don't know how to get darcs_cgi to run in WAMP
15:40:06 <SamB> vincenz: what manner of purpose be that?
15:40:18 <vincenz> SamB: not sure, was just offering a potential reason
16:04:03 <sorear> @botsnack
16:04:03 <lambdabot> :)
16:04:42 <ddarius> Dependantly typed language done yet?
16:04:55 <sorear> nope
16:05:04 <sorear> *Main> typeCheck [] (Quan (Star 0) (Lam (Var 0) (Var 0)))
16:05:04 <sorear> Quan (Var 0) (Var 1)
16:05:05 <ddarius> Also you may want to look at LF (which goes in hand with the reference to CLF earlier)
16:05:35 <vincenz> sorear: haskell or coc?
16:05:38 <ddarius> @google "Edinburgh Logical Framework"
16:05:39 <vincenz> s/coc/coq
16:05:41 <lambdabot> http://portal.acm.org/citation.cfm?id=107120
16:05:41 <lambdabot> Title: An overview of the Edinburgh logical framework
16:05:41 <sorear> I suspect it's a bug that my type checker generates malformed (never mind typed) output
16:06:04 <sorear> vincenz: CoC.  I understand haskell type checking.
16:06:27 <vincenz> sorear: I meant the impl-language
16:06:38 <sorear> Haskell.
16:06:41 * vincenz nods
16:07:03 <sorear> patternmatching comes in very handy with things like this :)
16:07:10 <vincenz> I bet :)
16:07:31 <ddarius> @google "A Framework for Defining Logics"
16:07:34 <lambdabot> http://www.lfcs.inf.ed.ac.uk/reports/91/ECS-LFCS-91-162/
16:07:34 <lambdabot> Title: A Framework for Defining Logics
16:18:42 <mattam> But you will need more than a few hours :)
16:19:43 <ddarius> You could probably whip out a crappy LF implementation minus parser in a few hours.
16:23:11 <mattam> oops, not meant for you :)
16:23:15 <balodja> @where binary
16:23:15 <lambdabot> http://darcs.haskell.org/binary
16:23:17 <sorear> balodja:
16:23:26 <mattam> just messing with iTerm
16:23:26 <sorear> wait, what does Killed mean?
16:23:49 <sorear> @seen sjanssen
16:23:49 <lambdabot> sjanssen is in #ghc, #gentoo-haskell, #haskell-soc, #haskell-overflow and #haskell. I last heard sjanssen speak 3h 12m 5s ago.
16:24:02 <sorear> @tell sjanssen xmonad doesn't play nice with 'display'
16:24:03 <lambdabot> Consider it noted.
16:24:15 <balodja> oh, that's my away. permanently forgetting to switch it off
16:24:42 <sorear> Ah good.  I was confusing it with /kill :)
16:25:03 <sorear> "wait, why is it displaying as a kind of AWAY?"
16:26:23 <sorear> Am I supposed to be having more trouble implementing lexical scoping than typing? :)
16:26:51 <mattam> yes
16:26:52 <ndm> sorear, umm, no - do you have a nice data type? (if you are doing it in C, the answer is probably no)
16:27:14 <ndm> sorear, teh original haskell spec made name resolution a complete pig, but it should be easy now...
16:27:27 <mattam> de Bruinj is hell not matter what you do
16:27:36 <mattam> Bruijn
16:27:50 <sorear> I'm typing the CoC now, and as Coquand recommended I'm using de Bruijn
16:28:45 * sorear wonders whether coq is deliberately a prefix of coquand
16:28:59 <sorear> (yes, I know what the official explanation is)
16:29:44 <ndm> isn't viagra a slight permutation on the name of the guy who invented it
16:29:54 <ndm> and fell out with the company before they named it :-
16:30:34 <sorear> ISTR it was chosen by the marketing department to associate with a certain famous river
16:30:34 <mattam> Probably that was taken into consideration as another defense :)
16:31:08 <sorear> (but istr a lot, caveat believor)
16:31:36 <mattam> ISTR ??
16:31:54 <heatsink> It sounds like a marketing word.  Sound like "vigor" and "virile".
16:33:35 <sorear> I Seem To Install
16:33:42 <sorear> lambdabot needs a @acro
16:34:03 <ndm> i think Igloo manages to get lambdabot to give acco's out
16:34:17 <heatsink> sorear: It should be @wdtm
16:34:20 <heatsink> =what does that mean
16:34:24 <ndm> @wtf
16:34:25 <lambdabot> Maybe you meant: bf ft wn
16:34:46 <vincenz> .@where+ wtf ndm
16:35:15 <sorear> yay, I've finally figured out what the type of  [x:*](x->x)  should be!  now to figure out why I'm not geting it
16:35:36 <sorear> ndm: what do you mean about Igloo and Lambdabot?
16:35:44 <sorear> iirc igloo isn't a bot admin
16:35:58 <sorear> @admin + glguy
16:36:01 <ndm> sorear: he often uses acronyms, he seems to know some magic lb inacantation to get it to give the answer
16:36:03 <sorear> @admin - glguy
16:36:13 <ndm> he isn't an admin, but he seems to know how to do it
16:36:16 <sorear> I can how... not what you meant :)
16:36:18 <ndm> @admin + ndm
16:36:21 <lambdabot> Not enough privileges
16:36:28 * Igloo isn't sure what you're talking about
16:36:46 <ndm> Igloo: don't you manage to get lambdabot to expand acronyms you use?
16:36:51 * ndm may just be going crazy
16:36:59 <lambdabot> Well, there is always @msg
16:37:30 <heatsink> @vera istr
16:37:32 <lambdabot> *** "istr" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
16:37:32 <lambdabot> ISTR
16:37:32 <lambdabot>      I Seem To Recall / Remember (telecommunication, Usenet, IRC)
16:37:32 <lambdabot>  
16:37:40 <Igloo> ndm: NAFAIK
16:38:45 <mux> dcoutts: is there any reason why the "old" interface for the TreeModel class is exported through the main Gtk module and not the ModelView one?
16:42:14 <xerox> is it possible to derive Random instances automatically?
16:42:18 <xerox> in particular I need (Int,Int) and another given ADT
16:42:29 <xerox> (a simple one similar to Bool.)
16:43:00 <ndm> xerox, do you have an algorithm? if you do, you could add it to derive easily
16:43:41 <xerox> ndm I thought deriving Enum was enough
16:43:46 <balodja> sorear: one more trouble. when i'm trying to configure lambdabot with plugins support, it asks for 'fps' dependence, which is in conflict with ghc's 'base' package.
16:43:56 <mux> it should easy to derive for any ADT only consisting of instances of Enum and Bounded
16:44:06 <ndm> xerox: don't know, never tried...
16:44:13 <sorear> balodja: don't use -plugins
16:44:17 <xerox> mux, yes, I derived both in fact.
16:44:18 <balodja> :)
16:44:25 <sorear> balodja: -plugins is very bitrotted
16:44:25 <balodja> ok :)
16:44:41 <sorear> -plugins really means dynamic plugin loading.
16:44:55 <sorear> without it, you still have plugins, just they are statically linked.
16:45:16 <sorear> @dynamic-load Look, even donsbot isn't a plugins build!
16:45:17 <lambdabot> Unknown command, try @list
16:45:46 <xerox> ndm Random (Int,Int) does not sound too difficult since Random Int is already there
16:45:57 <xerox> anybody knows what's the minimal implementation for a Random instance?
16:46:04 <sorear> @source Random
16:46:04 <lambdabot> Random not available
16:46:09 <sorear> @src Random
16:46:09 <lambdabot> class Random a where
16:46:10 <lambdabot>   random    :: RandomGen g => g -> (a, g)
16:46:10 <lambdabot>   randoms   :: RandomGen g => g -> [a]
16:46:10 <lambdabot>   randomR   :: RandomGen g => (a,a) -> g -> (a,g)
16:46:10 <lambdabot>   randomRs  :: RandomGen g => (a,a) -> g -> [a]
16:46:11 <lambdabot>   randomRIO :: (a,a) -> IO a
16:46:13 <lambdabot>   randomIO  :: IO a
16:46:15 <sorear> @src randomRIO
16:46:15 <lambdabot> Source not found. Wrong!  You cheating scum!
16:46:40 <sorear> I'd look at the System.Random sounce  :(
16:46:50 <xerox> Random a => Random (a,a)
16:46:59 <ddarius> @where report
16:47:00 <lambdabot> http://www.haskell.org/onlinereport/
16:47:02 <xerox> maybe I'll do this one instead
16:47:23 <ddarius> xerox: It should be no harder.
16:47:27 <sorear> Yay!  My CoC-checker is "working".  Anyone have some test terms?
16:52:22 * ddarius thinks he figured out what he had wrong for the Tunisian Knit Stitch.
16:53:23 <jcreigh> CoC?
16:53:37 <sorear> Calculus of constructions
16:53:39 * ndm thinks he has figured out how to "guess" the Data deriving
16:53:48 <sorear> the canonical dependantly-typed language
16:54:53 <ddarius> sorear: Heck no it isn't.
16:55:06 <ddarius> Probably the best supported though
16:58:40 <xerox> (Enum a, Bounded a) => Random a
16:58:40 <xerox> ghc does not like it
16:59:02 <ndm> xerox: overlapping instances are required
16:59:02 <sorear> yeah :(
16:59:10 <sorear> undecidable actually :)
16:59:36 * xerox wants it - is it evil?
16:59:45 <xerox> I thought it would be handy, adding things to ADTs incrementally
17:00:52 <kpreid> undecidable-instances turns the typeclass system into Prolog (roughly)
17:03:45 <xerox> and now I got overlapping instances, woo.
17:04:12 <xerox> -fallow-them.
17:04:34 <stepcut> -fdo-what-i-mean-instances
17:05:20 <monochrom> -fman-in-the-box
17:05:34 <monochrom> -fgrad-student
17:05:40 <balodja> sorear: and now, the most stupid question :) how to load plugins? :)
17:06:02 <sioraiocht> @src concat
17:06:03 <lambdabot> concat = foldr (++) []
17:06:21 <sioraiocht> @src join
17:06:22 <lambdabot> join x =  x >>= id
17:07:22 <xerox> joy, it compiles *and* works.
17:08:08 <ddarius> sioraiocht: concatMap id = concat
17:08:54 <vincenz> @type (join (join (,)))
17:08:56 <lambdabot>     Couldn't match expected type `(->) a' against inferred type `(,) a'
17:08:57 <lambdabot>     Probable cause: `(,)' is applied to too many arguments
17:09:45 <vincenz> @type \g -> let f = (,) g g in f
17:09:48 <lambdabot> forall a. a -> (a, a)
17:09:51 <vincenz> @pl \g -> let f = (,) g g in f
17:09:52 <lambdabot> join (,)
17:10:15 <vincenz> @pl \g -> let f = (,) g g in let h = (,) f f
17:10:15 <lambdabot> (line 1, column 41):
17:10:16 <lambdabot> unexpected end of input
17:10:16 <lambdabot> expecting variable, "(", operator, ";" or "in"
17:10:19 <vincenz> @pl \g -> let f = (,) g g in let h = (,) f f in h
17:10:20 <lambdabot> join (,) . fix . const . join (,)
17:10:26 <sorear> I've often wondered what a programming language would look like with Prolog conciously adopted as the type system.
17:10:48 <vincenz> sorear: I've often wanted type-level functions
17:12:22 <vincenz> @localtime dons
17:12:25 <lambdabot> Local time for dons is Mon Apr  9 10:11:49 2007
17:12:46 <sorear> balodja: you don't
17:13:02 <sorear> balodja: if lambdabot compiled at all, you are using a static build
17:13:13 <sorear> balodja: so the @plugins are simply there already
17:13:42 <balodja> Plugin `source' failed with: IRCRaised state not initalized
17:14:11 <balodja> sorear: hm, it seems that i have something went wrong :)
17:14:59 <jcpetruzza> anybody knows why there is an Eq instance for IOArray but no such instance for IOUArray?
17:17:02 <dons> moin.
17:17:03 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
17:17:10 <araujo> dons, hola!
17:17:37 <sorear> hi!
17:17:49 <araujo> sorear, hola!
17:17:56 <sorear> dons: xmonad doesn't play nice with display
17:18:06 <dons> 'display'?
17:18:15 <sorear> also, balodja is having bot install problems
17:18:29 <vincenz> we oughta have a dons-trac
17:18:33 <sorear> display == an xli clone, part of imagemagick suite
17:18:38 <vincenz> what with all the requests he get
17:18:52 <sorear> vincenz: you may have noticed he gets 3-6 @tells a day :)
17:19:08 <sorear> s/day/night
17:19:12 <vincenz> 3-6 @tells a day keeps the boredom away
17:19:34 <vincenz> sorear: that's why I mentioned it ;)
17:20:38 <monochrom> hahaha
17:24:35 <beelsebob> ARGH!
17:24:43 <beelsebob> stupid bad PDF
17:26:01 <beelsebob> xpdf opens it without errors, why do AcroRead and Preview both explode
17:29:08 <monochrom> who made the pdf?
17:30:46 <beelsebob> me
17:30:51 <beelsebob> I'm writing a Haskell pdf library
17:31:00 <beelsebob> it appears to conform to the spec
17:31:04 <beelsebob> and xpdf doesn't complain
17:31:08 <beelsebob> but the other two do
17:31:09 <sorear> gs?
17:31:27 <sorear> gs/gv is another good pdf reader to test on
17:31:36 <sorear> esp. since it is my reader of choice ;)
17:32:08 * sorear expects that at some point beelsebob will produce a paper worth reading, and wants to be able to read it on his reader of choice :)
17:32:33 <monochrom> check very carefully conformance.
17:32:48 <beelsebob> monochrom: the problem is that there's no validator
17:32:52 <beelsebob> so it's very hard to do so
17:33:08 <beelsebob> the best way to test it appears to be using as many different readers as you can to open it
17:33:20 <monochrom> try to simplify the pdf while preserving the crash behaviour.  check conformance of the simplified file.
17:33:21 <beelsebob> sorear: I think gv uses the same engine as xpdf
17:33:35 <beelsebob> monochrom: at the moment I'm just chasing a lead
17:33:42 <beelsebob> I'm not sure if content arrays are allowed to be empty
17:33:47 <beelsebob> the spec document doesn't specify
17:34:01 <monochrom> avoid grey areas like this.
17:34:21 <beelsebob> indeed
17:34:47 <beelsebob> that's why I'm going for the replacing the empty content array with no content array at all
17:35:03 <monochrom> when spec doesn't say, some programmers (not you) start making prejudiced presumptions.  crash.
17:35:39 <monochrom> to be fair, when spec does say, some programmers still make prejudiced presumptions, and still crash.
17:36:34 <monochrom> wouldn't it be nice if we just bloody replaced programmers by robots. at least no problem of the second kind.
17:36:56 <TSC> But who will program the programmers?
17:37:03 <monochrom> ME
17:37:07 <vincenz> TSC: fix
17:37:43 <monochrom> actually anyone in #haskell is probably competent enough to program the robots.
17:37:47 <beelsebob> monochrom: the most annoying thing is that the spec is filled with "well, this is the spec, but AcroRead doesn't conform here, so don't do it"
17:38:21 <monochrom> interesting. try not to provoke Acroread on those issues. :)
17:38:52 <kpreid> beelsebob: so write the generator to conform to the spec, plus a separate "clean up so AcroRead doesn't freak out" module?
17:39:24 <beelsebob> kpreid: no, it's mostly things that are easily avoidable, but it's still annoying
17:40:11 <monochrom> The spec is rich. (I glanced through it once.)  Understandably Acroread hasn't implemented all of it.
17:40:42 <beelsebob> monochrom: it's not actually "by the way acroread doesn't implement this"
17:40:42 <jcreigh> heh, I hate that sort of thing. I was paging through a CSS book, and found a page where it was talking about drop shadows with CSS. They had a picture of text with a shadow, with a note that said "No browser actually supports this: We made this example with photoshop"
17:40:52 <beelsebob> it's "by the way, acroread does something wrong here"
17:41:09 <beelsebob> jcreigh: that's wrong -- Safari supports drop shadows
17:41:18 <beelsebob> I think it's the only browser that does though
17:41:26 <kpreid> it was probably true when the book was written
17:43:03 <monochrom> At least they admit it. :)
17:44:02 <beelsebob> true
17:45:43 <beelsebob> hmm, not that
17:45:48 <beelsebob> god knows what I'm doing wrong
17:46:08 <hpaste>  beelsebob pasted "doom" at http://hpaste.org/1311
17:46:19 <beelsebob> could you lot try that in the various pdf readers you have
17:46:23 <beelsebob> and see if you get any error messages?
17:47:07 <TSC> Is it supposed to be a diagonal line?
17:47:27 <beelsebob> yes
17:47:32 <beelsebob> in a two page PDF
17:47:43 <beelsebob> first page being a portrait A4 page
17:47:48 <beelsebob> second being a landscape A4 page
17:48:10 <TSC> Works in xpdf
17:48:14 <beelsebob> indeed
17:48:20 <beelsebob> xpdf gives no clue
17:48:24 <beelsebob> which is annoying
17:48:30 <beelsebob> because my other 2 pdf viewers give no error messages
17:48:31 <TSC> Works in gv
17:49:44 * beelsebob confused
17:50:22 * beelsebob spots it
17:50:30 <beelsebob> my stream object appears not to have an endobj
17:52:01 <beelsebob> arse, it still fails to load :/
17:52:02 <jcreigh> you'd think there would be a pdf validator out there
17:52:10 <beelsebob> there is one
17:52:14 <beelsebob> but it costs $720
17:52:18 <jcreigh> ah
17:54:27 * beelsebob notes that the parents of the pages appear to be borkend
17:55:09 <beelsebob> which fixes it
17:55:13 * beelsebob hunts the bug in the code
17:57:19 <beelsebob> yay, working
17:57:42 <beelsebob> Preview doesn't think there's a second page, but I suspect that's it's non-conformance
17:57:44 <beelsebob> not mine
17:58:19 * beelsebob submits a bug report to apple
17:58:58 <allbery_b> http://accesspdf.com/pdftk
17:59:01 <lambdabot> Title: AccessPDF - Pdftk
17:59:39 <beelsebob> hmm?
17:59:47 <beelsebob> may be useflu
17:59:53 <beelsebob> it may have different error messages
18:04:17 <SamB> hmm. this is handy ;-).
18:04:30 <SamB> Turbo Pascal handles UNIX-format files with ease
18:04:31 <beelsebob> what's that then?
18:08:44 <SamB> what is what?
18:10:01 <encryptio> :t ($=)
18:10:04 <lambdabot> Not in scope: `$='
18:10:18 <vincenz> @hoogle ($=)
18:10:19 <lambdabot> Did you mean: ($=)
18:10:20 <lambdabot> Prelude.undefined :: a
18:10:20 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
18:10:41 <beelsebob> arse, preview appears to get this wrong in a consistant way
18:10:47 <beelsebob> I wonder if I'm not quite meeting the spec
18:11:34 <stepcut> encryptio: are you using the opengl binding ?
18:11:46 <encryptio> stepcut: looking at it, hoping to use it
18:12:15 <stepcut> the ($=) operator is specific to OpenGL, it basically just does a 'set'
18:13:24 <stepcut> ($=) :: forall (s :: * -> *) a. (HasSetter s) => s a -> a -> IO ()
18:13:55 <encryptio> allright
18:14:16 <stepcut> the type signature is far more complicated than the actually usage ;)
18:16:14 <encryptio> you use hopengl much?
18:16:27 <stepcut> no, just a little bit
18:20:45 <hpaste>  phoniq pasted "instance Show (Parameterized type) where..." at http://hpaste.org/1313
18:20:59 <phoniq> my beginner's question for the day
18:21:21 <vincenz> @shootout
18:21:22 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
18:21:33 <stepcut> instance (Show a) => Show (Func a) where
18:22:04 <stepcut> s/Func/Funk/
18:22:27 <phoniq> hah.   you guys *rock*
18:22:33 <phoniq> thanks man.
18:22:38 <stepcut> no problem
18:23:25 <phoniq> that's a really strange one to a C++ guy.
18:23:45 <phoniq> in C++ land that wouldn't have compiled because the types are "wrong".  I have to remember the lazy.
18:24:06 <phoniq> i mean, the version w/o ++ show a wouldn't have compiled.
18:27:53 <dcoutts> mux: we didn't want to break people's programs twice, once when we switched to the new model view stuff and a second time when we fixed the model view stuff based on people's feedback :-)
18:29:13 <dcoutts> cpfr: yes, a report to the gtk2hs-devel list would be most helpful, we'd like to know how to reproduce the problem you found.
18:29:43 <cpfr> i sent a repor
18:29:46 <cpfr> *report
18:29:51 <dcoutts> ok, great
18:30:05 <cpfr> but im a non-member
18:30:15 <cpfr> i gave the code and error
18:30:24 <dcoutts> cpfr: no probs, axel will authorise it when he wakes up :)
18:31:40 <cpfr> cool
18:32:13 <sorear> mattam: I think I have a CoC checker working (no inductive types just yet) ... you have any corner cases to give it?
18:34:14 <sorear> coc> \ a : [k : *0] *0  . \ v : a num . v
18:34:14 <sorear> [a : [b : *0] *0]
18:34:14 <sorear>   [c : a [d : *0] [e : [f : d] d] [g : d] d]
18:34:14 <sorear>     a [h : *0] [i : [j : h] h] [k : h] h
18:34:17 <sorear> HughesPJ++
18:34:29 <sorear> now if only I knew what that type meant :)
18:36:02 <dons> morning dcoutts
18:36:31 * beelsebob screams and tears his hair out
18:37:32 <dons> dcoutts: i'm preparing a small blog article for planet haskell on the new papers. that ok with you?
18:39:39 <dons> dcoutts: anyway, this seems to indicate blogs are fine: "there is no need to worry about exposure outside the submission itself. Feel free to put your submission on your web page, give talks about the work, and whatever else you normally do to disseminate it."
18:41:06 <beelsebob> dcoutts: do you happen to know anything about the pdf spec?
18:41:12 <sorear> coc> \ a : [k : *0] *0  . \ v : a num . v
18:41:12 <sorear> [a : [_ : *0] *0]
18:41:12 <sorear>   [_ : a [b : *0] [_ : [_ : b] b] [_ : b] b]
18:41:12 <sorear>     a [c : *0] [_ : [_ : c] c] [_ : c] c
18:41:16 <sorear> much more readable :)
18:41:29 <balodja> @src ios80
18:41:29 <lambdabot> Source not found. Just what do you think you're doing Dave?
18:41:53 <dons> balodja: its in lambdabot's utils somewhere.
18:42:01 <dons> balodja: its just a lambdabot functoin.
18:42:58 <dcoutts> beelsebob: not a thing, sorry :-)
18:43:01 <dcoutts> hia dons
18:43:04 <beelsebob> :(
18:43:12 <dcoutts> dons: sure, np
18:43:21 <dons> http://cgi.cse.unsw.edu.au/~dons/blog/2007/04/09#fusion-for-lists :-)
18:43:23 <balodja> dons: and where is it defined?
18:43:25 <lambdabot> Title: Haskell hacking
18:44:02 <dons> balodja: grep is your friend:
18:44:02 <dons> $ cd lambdabot
18:44:03 <dons> $ grep '^ios80' *.hs
18:44:03 <dons> Plugin.hs:ios80 :: (Functor m, MonadIO m) => Nick -> IO String -> m [String]
18:44:03 <dons> Plugin.hs:ios80 to what = list . io $ what >>= return . lim
18:44:15 <balodja> i see, thanks
19:09:21 <balodja> dons: could you help me with installing lambdabot? there is a problem in some plugins. for example, eval.
19:09:23 <balodja> lambdabot> run 1+1
19:09:25 <balodja> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
19:09:57 <sorear> you need to copy runplugs into .
19:10:09 <sorear> it should be in dist/build/runplugs/runplugs
19:10:10 <stepcut> balodja: eval uses an external program -- make sure lambdabot can find runplugs
19:10:38 <sorear> ditto for djinn, unlambda, hoogle, one or two others
19:11:17 <dons> sorear: no. you just use the ./build script.
19:11:33 <dons> balodja: are you using ./build? do you have a recent Text.Regex installation?
19:11:36 <dons> and plugins from darcs.
19:12:27 <balodja> hm, i'm not using build. trying
19:13:16 <balodja> nice ./Setup.hs configure --bindir=`pwd` --libdir=`pwd`/lib
19:13:43 <balodja> unfortunatly, that's not suitable :( i need --prefix
19:14:16 <dons> why?
19:14:24 <dons> you're not supposed to install lambdabot outside its home dir.
19:14:33 <dons> it _must be installed into `pwd`
19:16:10 <balodja> sounds earnestly
19:17:05 <balodja> so, after installing trough ./build the problem remains
19:18:20 <dons> does the 'runplugs' binary exist in the lambdabot directory?
19:18:28 <dons> does it work, e.g. echo '1+2' | ./runplugs  ?
19:19:32 <balodja> % echo '1+2' | ./runplugs
19:19:34 <balodja> runplugs: Ix{Int}.index: Index (1024) out of range ((0,29))
19:20:17 <dons> which version of hs-plugins are you using/
19:20:22 <dons> the darcs version?
19:20:32 <dcoutts> dons: hmm, I think that actually there's a lot to do to really get a superb paper on binary, I wonder if we shouldn't start on that sooner
19:20:38 <sorear> that sounds like a symptom of hs-plugins' incompatibility with 64-bit computers and/or mismatched hs-plugins/ghc versions
19:20:48 <sorear> or has the incompatibility been fixed?
19:20:54 <dons> dcoutts: yes. you looking at 'bits between the lambda'?
19:21:10 <dcoutts> dons: yep, and getting advice from kosmikus
19:21:25 <dons> ah yes? what are his recommendations?
19:21:37 <dcoutts> -> #maya
19:22:01 <sorear> I'd just like to say I stopped writing the ultra-high-speed ppr lib when I realized nobody would actually ever use it.  If I was wrong tell me :)
19:22:32 <kosmikus> hi dons
19:22:42 <dons> hey kosmikus
19:23:04 <balodja> dons: hs-plugins is just from up-to-date repository
19:23:06 <dons> yeah, we're planning the HW assault for this year :-)
19:23:10 <balodja> and % darcs --version
19:23:11 <balodja> 1.0.9rc1 (release candidate 1)
19:23:33 <dons> hmm. no. what is the most recent patch in the hs-plugins repo, balodja ?
19:25:55 <balodja> that's good question for me. i don't actually know :) because i only do 'darcs get http://...' and configure/build/install
19:26:07 <dons> thanks for the suggestions, kosmikus! i think we can probably craft this into a nice story about very high performance haskell libraries, using e.g. rewrite rules to eliminate bounds checks
19:26:26 <balodja> without any understanding of what's going on :(
19:27:32 <sorear> Am I correct in believing there is no use for high-performance pretty printers?
19:27:48 <encryptio> anyone have a link for udp socket i/o in haskell?
19:28:08 <dons> encryptio: yeah, there's an article on this on the blog page of haskell.org
19:28:11 <kc5tja> If it doesn't boldface all my variables and italicize all my comments on 0.1 seconds or less, it's useless to me.  :D
19:28:12 <sorear> there is a thread about it on libraries@ ATM
19:28:12 <l_knot_> sorear: no use?
19:28:18 <dons> go to haskell.org, click on 'Blog articles' scroll down to Network
19:28:30 * kc5tja is joking of course.
19:29:01 <sorear> kc5tja: yeah, that's considered colorization and/or fontification, which is orthogonal to pprinting :)
19:29:10 <encryptio> dons: no udp...
19:29:31 <dons> there's been at least one blog article on udp though.
19:29:36 <sorear> l_knot_: well, there's no use formatting data for human consumption faster than humans can read it!
19:29:45 <beelsebob> sorear: sure there's a use -- it's a really hard example with which we can try out cunning programming strategies
19:29:57 <beelsebob> other than that, I haven't a clue
19:30:10 <sorear> I've got most of a pprlib which I expect is builder-competitive.
19:30:42 <sorear> runs in bounded space, compiles to buffer filling code
19:31:01 <kosmikus> dons: you're welcome. and yes, I think so too :)
19:31:13 <beelsebob> sorear: look at Olaf's paper on the subject
19:31:47 <beelsebob> http://www.cs.kent.ac.uk/pubs/2006/2381/content.pdf
19:31:53 <encryptio> i've been looking around for about 30 minutes and haven't found any example code for udp sockets
19:32:30 <sorear> beelsebob: is that the 'pretty printing with lazy deques' one?
19:32:36 <beelsebob> sorear: yeh
19:32:38 <beelsebob> wrong isn't it
19:32:43 <sorear> my main source of inspiration :)
19:32:50 <beelsebob> hehe
19:33:32 <sorear> Except, instead of lazy deques, I use an extremely clever algorithm to backpatch the output buffer when a line is spilled.
19:34:00 <beelsebob> IIRC Olaf told me he didn't want to do that
19:34:09 <beelsebob> but your algorithm may be cleverer than his
19:35:12 <sorear> I don't think Olaf was going for pure performance;  IIRC he was going for performance predicated on internal purity.
19:35:21 <dcoutts> dons: nice blog post, so when to you hit reddit? :-)
19:35:35 <sorear> mine is externally pure, but peek inside - realWorld# everywhere.
19:35:47 <sorear> I ought to rewrite it with inlinePerformIO at some point.
19:35:49 <beelsebob> sorear: yeh, I'm pretty sure he wanted internal purity too
19:36:01 <beelsebob> I think he'd probably vomit at you if you told him that :P
19:37:58 <sorear> I expect inlinePerformIO is rather safer than realWorld# :)
19:38:31 <beelsebob> I wouldn't have a clue
19:39:16 <sorear> how fast are haskell IOUArrays?  I'm using MutableByteArray#, which doesn't waste any space storing a lower bound, but I have a suspicion th inliner could have done that...
19:40:09 <dcoutts> sorear: hmm, I'm not so sure
19:40:57 <dcoutts> it'd have to fully unpack and expand the IOUArray and then notice that this value is always 0 and you'd need to be using unsafe indexing for it to notice that that value is never used
19:41:43 <SamB> on the other hand, does it really waste that much space?
19:42:32 <sorear> SamB: experimentally, adding one parameter to the inner loop decreases performance by 2-4x
19:42:52 <sorear> it wouldn't hurt quite so badly if it was packed into the array
19:42:52 <SamB> what are you doing to them?
19:43:26 <sorear> uh... arguing?
19:43:35 <SamB> the arrays
19:44:12 <dcoutts> SamB: he's poking bytes into them, quite quickly
19:44:16 <sorear> semi-random indexing, filling them with data, unsafeCoerce#ing them into ForeignPtrs, stuffing them into bytestrings
19:44:44 <dcoutts> sorear: semi-random? I thought it was simple linear filling
19:45:50 <sorear> dcoutts: the buffer is linearly filled with backpatching, but I also keep a stack or two for handling group, and my scalar state is packed like a structure at the bottom
19:46:19 <dcoutts> oh, this is because you're doing a ppr lib on top that needs back patching ?
19:46:43 <sorear> oh yes.
19:49:13 <dcoutts> sorear: so you have to keep the whole thing in memory if you want to back patch right? or do you only need limited look-behind ?
19:57:41 <vincenz> dcoutts: remember the name of the section at the end where you thank people?  What's that titled?
19:57:56 <dcoutts> vincenz: acknowledgements
19:58:01 <vincenz> ta
19:58:19 <vincenz> they're not added during blind review, are they
19:59:15 <dcoutts> not too sure
19:59:20 <dcoutts> not if it'd give things away
19:59:44 <dcoutts> you might just want to put a placeholder in that section during review
20:00:07 * vincenz nods
20:02:03 <encryptio> what's the difference between using an MVar and using an IORef?
20:02:14 <sjanssen> MVars are thread safe
20:02:15 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
20:02:59 <sjanssen> sorear: what goes wrong?
20:04:36 <balodja> dons: i used hs-plugins version 0.10, now i'm trying older version 0.9.10, but it fails to compile with message:
20:04:38 <balodja> System/Plugins/LoadTypes.hs:31:0:
20:04:40 <balodja>     Bad interface file: /home/balodja/hs-plugins/src/hi/Language/Hi/Parser.hi
20:04:42 <balodja>         Something is amiss; requested module  hi-0.9.10:Language.Hi.Parser differs from name found in the interface file hi:Language.Hi.Parser
20:08:11 <SamB> hoooray!
20:08:59 * SamB cheers for versions in identifiers
20:12:18 <ray> dons: if i were on the whatsis committee i would have read your post anyway
20:25:09 <GueNz> Hello Help in funcion
20:25:16 <GueNz> MCD maximuos comun divisor
20:26:10 <GueNz> dn
20:26:15 <GueNz> MCM
20:29:37 <erider> good night
20:35:27 <jargonjustin> Is it possible to define functions in Hugs or the GHC interpreter?
20:36:10 <ddarius> In GHCi you can do let f = ... to bind a function.
20:36:15 <dcoutts> let f x =x +1
20:36:18 <dcoutts> but not in hugs
20:36:20 <ddarius> In either you can obviously use let ... in ...
20:38:22 <jargonjustin> dcoutts, that's perfect.  Thanks
20:40:22 <jcpetruzza> i have a module that stopped compiling when I tried to switch from IOArray to IOUArray.
20:40:41 <jcpetruzza> the reason is that there is no instance Eq IOUArray
20:40:54 <jcpetruzza> why is it the case?
20:41:17 <sjanssen> jcpetruzza: what are you storing in the IOUArray?
20:41:31 <jcpetruzza> Ints
20:42:03 <sjanssen> I'm a bit surprised IOArray has an Eq instance
20:43:17 <jcpetruzza> I guess it compares the pointer to the array
20:44:48 <jcpetruzza> (at least, that seems to happen with Eq IORef a...)
20:45:28 <sjanssen> jcpetruzza: it looks like an oversight
20:46:41 <ddarius> reallyUnsafePtrEq# ?
20:47:21 <jcpetruzza> ddarius: sorry, i didn't understand. is that a suggestion?
20:48:12 <ddarius> It was kind of put out there to see what people thought and also as a potential suggestion.  You should be able to implement Eq yourself depending on what you need of it.
20:48:43 <dons> ray: hehe. is that good or bad?
20:50:29 <encryptio> @hoogle Integral a, Monad m => a -> m b -> m b
20:50:30 <lambdabot> Prelude.asTypeOf :: a -> a -> a
20:50:30 <lambdabot> Prelude.const :: a -> b -> a
20:50:30 <lambdabot> Prelude.seq :: a -> b -> b
20:50:47 <sjanssen> jcpetruzza: to write the Eq instance, you can use sameMutableByteArray# (found in GHC.Prim)
20:50:48 <jcpetruzza> ddarious: ok, sorry, i wasn't aware of that function. scary name :)
20:50:56 <encryptio> how would i repeat a monadic action n times? (results can be ignored)
20:51:06 <sjanssen> encryptio: replicateM_
20:51:15 <sjanssen> in Control>monad
20:51:27 <encryptio> coo
20:58:15 <ddarius> sjanssen's recommendation is probably much better.  reallyUnsafePtrEq may not do the right thing.
20:59:15 <vincenz> \o/
21:00:27 <SamB> so "unsafe" wasn't scary enough?
21:00:38 <SamB> they had to call it "reallyUnsafe"?
21:00:45 <sjanssen> dons: so what were you saying earlier about firefox and closing windows?
21:01:16 <jcpetruzza> sjanssen: thank you very much, i'll try to write my own instance of Eq....
21:02:24 <ddarius> SamB: The story I here is that the person who wrote it was very big into referential transparency.  unsafePerformIO and definitely unsafeCoerce# are -far- more scary.
21:05:08 <jcpetruzza> now, where can I find how IOUArray is defined in terms of MutArray#?
21:05:37 <jcpetruzza> I'm browsing the library reference, but can't find much about the internals....
21:06:18 <SamB> ddarius: I don't see how unsafePerformIO is more referentially transparent than reallyUnsafePtrEq
21:06:21 <sjanssen> jcpetruzza: the library source and ghci's :info command are your best tools
21:07:20 <ddarius> SamB: It isn't, but, if accurate, the person who wrote reallyUnsafePtrEq didn't write unsafePerformIO or unsafeCoerce#
21:07:35 <SamB> true
21:07:47 <ddarius> jcpetruzza: I'd just browse the source.
21:07:51 <SamB> I'm not going to say anything about the referential transparency of unsafeCoerce#
21:08:00 <SamB> since I'm not sure if it has any or not ;-)
21:08:30 <sjanssen> the function is probably marked as "reallyUnsafe" because you essentially have to assume it's broken most of the time
21:09:13 <ddarius> Why not doesntDoWhatYouWantPtrEq
21:09:44 <sjanssen> probably better
21:10:28 <mauke> thisIsntGoingToWorkPtrEq
21:10:47 <mauke> justGoAwayAndLeaveMeAlonePtrEq
21:10:50 <sjanssen> crossYourFingersPtrEq
21:11:12 <SamB> but, if I get a True, that means that the values are equal (except for those damn floating-point types where == is not reflexive)
21:11:17 <SamB> right?
21:11:17 <ddarius> I like mauke's first suggestion.
21:11:19 <sjanssen> hopefullyPtrEq
21:11:34 <SamB> assuming there *are* values?
21:11:49 <ddarius> SamB: If I understand correctly, if you get a True then they are exactly the same value.
21:11:57 <jcpetruzza> can one browse the library sources online somewhere? they don't seem to be installed on my pc...
21:12:12 <ddarius> @source IOUArray
21:12:13 <lambdabot> IOUArray not available
21:12:13 <SamB> ddarius: that is about as much as can be expected ;-)
21:12:35 <sjanssen> @source Data.Array.IO
21:12:36 <lambdabot> http://darcs.haskell.org/packages/base/Data/Array/IO.hs
21:12:41 <SamB> if I wanted more than that, I would have used a better type for it
21:13:02 <ddarius> SamB: Well, you could implement it as const (const False)
21:13:06 <ddarius> That'd be safe.
21:13:14 <SamB> quite!
21:13:34 <SamB> a standard that supported that would be fine with me.
21:13:35 <jcpetruzza> thanks!
21:13:54 <SamB> > 1/0 == 1/0
21:13:56 <lambdabot>  True
21:13:58 <SamB> hmm.
21:14:06 <SamB> > 1/0 - 1/0
21:14:08 <lambdabot>  0.0
21:14:12 <ddarius> > 0/0 == 0/0
21:14:14 <lambdabot>  False
21:14:17 <SamB> ah.
21:14:26 <mauke> wait, why is inf - inf == 0?
21:14:35 <SamB> but WTH do I get 0.0 for 1/0 - 1/0?
21:15:10 <mauke> > (1/0) / (1/0)
21:15:12 <lambdabot>  NaN
21:15:13 <SamB> ddarius: so, clearly, you can't assume that just because reallyUnsafePtrEq# returns True, == will ;-)
21:15:17 <LoganCapaldo> I thought you are supposed to get NaN for 1/0 - 1/0
21:15:33 <SamB> ddarius: so, clearly, you can't assume that just because reallyUnsafePtrEq# returns True, == will ;-)
21:15:35 <ddarius> SamB: I didn't say == would.
21:15:36 <SamB> erk
21:15:41 <SamB> > 1/0
21:15:43 <LoganCapaldo> (or was that 1/0 + 1/0?)
21:15:43 <lambdabot>  Infinity
21:15:46 <SamB> ddarius: no, you didn't
21:15:55 <ddarius> It's not my fault == isn't an equivalence relation.
21:16:01 <SamB> yes I know
21:17:10 <SamB> anyway, I do happen to know that the IEEE is responsible for this travesty
21:17:21 <hpaste>  Oren pasted "Stubborn memory leak" at http://hpaste.org/1314
21:19:09 <emu> > 1 % 0 - 1 % 0
21:19:10 <lambdabot>  Exception: Ratio.%: zero denominator
21:19:45 <oren> Any help with why http://hpaste.org/1314 is leaking memory would be greatly appreciated
21:21:55 <ddarius> Bah, we need an @ieee.  How it would work? I'm not sure.
21:22:09 <mauke> @aieee
21:22:10 <lambdabot> Unknown command, try @list
21:23:18 <danjafagw> Hi, im new to haskell so sorry for my easy question. I am using GHC and i am trying to use to functions on a string.. I am trying to say the number of lower case characters in a string. so I use filter Char.isLower "Abcd" and it reutnrs a character w/ only the lower ones, so i wanted to take the length of that, so i typed lenght filter Char.isLower "AbCd" but apperetnyl u cant use functions like this, how should i go about this?
21:23:48 <jcpetruzza> @source GHC.Prim
21:23:49 <lambdabot> GHC.Prim not available
21:23:59 <dons> > filter isLower "Abcd
21:23:59 <lambdabot>  Improperly terminated string
21:24:04 <dons> > filter isLower "Abcd"
21:24:06 <lambdabot>  "bcd"
21:24:14 <dons> >  length (filter isLower "Abcd") -- like this
21:24:16 <lambdabot>  3
21:24:17 <jcpetruzza> @source GHC.IOBase
21:24:18 <lambdabot> GHC.IOBase not available
21:24:21 <danjafagw> ooo thank you dons
21:24:25 <danjafagw> ty very much
21:24:31 <ddarius> danjafagw: yes, as dons illustrated, you have a parenthesis problem.
21:24:40 <danjafagw> thank you
21:25:08 <dons> sjanssen: so basically 'kill' no longer closes firefox windows, since one of the recent updates.
21:25:13 <emu> by default it is left-associative.  that means it assumes: a b c d   <==>  (((a b) c) d)
21:26:58 <dons> sjanssen: i'll start on the TMR paper for xmonad today.
21:27:04 <dons> i'll ping you with the darcs repo when it is set up.
21:31:12 <oren> dons: I minimized my streaming parser memory leak problem to a short test program at http://hpaste.org/1314 if you are interested
22:02:46 <thoughtpolice> :t runWriter
22:02:48 <lambdabot> forall w a. Writer w a -> (a, w)
22:10:27 <ivanm> dons: I'm having trouble using darcs get --partial for yi
22:10:52 <ivanm> it complains about some of the patches
22:20:53 <falconair_> i have a very newbie syntax question:  the code on this page (http://dockerz.net/twd/HaskellCharts/Example3) uses the following syntax: "blah = blah { x = blah, y = blah, z = blah } " ... what is that ... is it the syntax for records? ("Tour of the Haskell Syntax" doesn't seem to help)
22:20:55 <lambdabot> Title: HaskellCharts/Example3 - twd
22:21:56 <sjanssen> falconair_: yep, record syntax
22:22:37 <falconair_> the "Tour of the Haskell Syntax" does have it, is it new, or only for GHC?
22:22:48 <sjanssen> it's Haskell '98
22:22:55 <sjanssen> the tour must be incomplete
22:23:10 <falconair_> i might've missed it ... thanks sjanssen
22:27:35 <dons> ivanm: which patches?
22:27:49 <dons> sjanssen: any luck reproducing the firefox close window issue?
22:27:49 <ivanm> first time, 227
22:27:56 <ivanm> after deleting and trying again, 156
22:28:06 <dons> does it say which patch failed?
22:28:18 <dons> you using a newer darcs?
22:28:43 <sjanssen> dons: nope, I'm not seeing it
22:29:30 <dons> ok. i'll chase it up.
22:31:17 <ivanm> dons: darcs 1.0.5, patches 227 and 156 failed (tried, deleted, tried again)
22:31:28 <ivanm> I'm now trying to get it a third time... up to 390 atm
22:34:16 <sjanssen> dons: I really hope this isn't a problem with the "Remove redundant setFocus" patch
22:34:32 <sjanssen> this stuff seems way too delicate at the moment
22:35:54 <stepcut> speaking of xmonad, transients screw up the stacking order for me
22:36:14 <sjanssen> "screw up"?
22:36:33 <sjanssen> transients should behave like any other window, I think
22:36:36 <ivanm> dons: *shrug* it seems to have worked this time
22:36:39 <stepcut> in fullscreen mode, if I have window A in the foreground, and window B in the background, and window A opens a popup window (like a search box of something), when I close the popup window, window B is not in the foreground.
22:37:00 <stepcut> window B is *now* in the foreground
22:37:40 <sjanssen> yeah, this is expected (but perhaps not optimal) behavior
22:38:19 <stepcut> hrm, when would that be a good thing?
22:39:30 <sjanssen> whenever a window is created, it is inserted on the front of the stack.  When a focused window is destroyed, focus moves to the window immediately after the previously focused window
22:40:27 <sjanssen> stepcut: your description isn't quite accurate -- behavior depends on the order windows A and B are created
22:40:49 <stepcut> ah
22:41:42 <sjanssen> I have a feeling that this is only annoying with transient type windows.  So it should be a non issue when we handle those (by making them floating)
22:42:06 <stepcut> ok
22:43:21 * stepcut goes to bed.
22:44:43 <dons> dcoutts: haha http://programming.reddit.com/info/1ge52/details
22:44:44 <lambdabot> Title: Haskell: Two new papers! (reddit.com)
22:46:08 <sjanssen> dons: does window order in Full mode ever get on your nerves?
22:46:18 <ivanm> dons: reading through the abstract of that second paper (about monte-carlo), just wondering, how do you actually _prove_ something about language efficiency?
22:46:45 <ivanm> is it in general, or a case-by-case basis?
22:46:48 <dons> sjanssen: yeah, sometimes things get rejigged oddly.
22:47:02 <dons> ivanm: we implement things a number of ways, and compare.
22:47:07 <dons> its not about language efficiency
22:47:10 <dons> its about the technique
22:47:40 <dons> i.e. dynamic specialisation of large programs outperforms, consistenly, hand-coded general purpose simulators
22:47:49 <ivanm> *nod*... just the "we show it is possible to outperform low-level lanugages" to me sounds like you've proven that functional languages are faster than C, etc
22:48:01 <dons> nah, read closer :-)
22:48:03 <dons> we generate C.
22:48:38 <dons> the generate approach produces dramatically better code.
22:48:38 <ivanm> ahhh... you're comparing simulation generators?
22:49:00 <dons> we're comparing general purpose simulators, against custom-generated simulators
22:49:09 <ivanm> rather than hand-coding each individual simulation?
22:49:26 <dons> rather than writing a general purpose simulator, which is the usual approach
22:50:09 <dons> so instead you write a general purpose simulator *generator*
22:50:17 <dons> which itself spits out custom simulators on the fly
22:50:33 <ivanm> so this is a matter of giving some program the details about the scenario you want to simulate, and it generates the actual simulation?
22:50:38 <dons> yep.
22:50:41 <dons> exactly.
22:50:54 <dons> then you run that for a few days, and get your results.
22:51:34 <ivanm> OK, thought you had somehow proven that haskell > C for monte carlo ;-)
22:51:44 <dons> nah.
22:51:50 <dcoutts> but taking the generative approach if you were doing the whole thing in C would be very very hard
22:51:56 <dcoutts> the FP makes that practical
22:52:02 <dons> right. you want to write your generated in a good language.
22:52:08 <dons> and have it spit out the C code you need.
22:52:09 <ivanm> *nod*
22:52:21 <dons> also, since its all very high level, we generate cluster and multicore simulators as well
22:52:24 <ivanm> and then tweak the C code if necessary?
22:52:28 <dons> since its easy to retarget the code generator
22:52:28 <dcoutts> so comparing on effort, the C+Haskell approach is faster than the C only approach
22:52:43 <ivanm> dcoutts: efficiency as well?
22:52:49 * johnnowak wonders if only he noticed dons's implication that C is not a good language
22:52:58 <dcoutts> ivanm: what do you mean exactly?
22:53:03 <dons> its not a good language for writing code generators.
22:53:13 <dons> its a good target language though. -- its the new assembly!
22:53:33 <ivanm> dcoutts: not sure if your comment meant that C+Haskell is faster to create/code, or faster to run
22:53:52 <johnnowak> no, it isn't good for writing code generators. not sure if it is a good target language either though... but perhaps the best at the moment.
22:53:56 <dcoutts> ivanm: for equal implementation effort the C+Haskell approach is much faster.
22:54:02 <ivanm> *nod*
22:54:17 <ivanm> any particular reason you had it spit out C code rather than compile directly?
22:54:25 <ivanm> to compare the generated C code?
22:54:26 <dons> efficiency.
22:54:30 <stepcut> @quote stepcut.*C
22:54:31 <lambdabot> No quotes match. Are you on drugs?
22:54:38 <dons> its easier to generate C, and have say, icc, specialise it to your hardware
22:54:43 <stepcut> @quote C.*compilers
22:54:43 <ivanm> *nod*
22:54:44 <lambdabot> edwardk says: well, dependent types fuck with compilers ability to get anything done
22:54:44 <dons> than to write your own register allocator..
22:55:05 <ivanm> and tweak the code if necessary or you've got nothing else to do?
22:55:07 <dcoutts> hence is faster, (since that's the only fair way to compare, with no bound on implementation effort you can make things (almost) arbitrarily fast)
22:55:25 <ivanm> k
22:55:32 * dons sings happy birthday to me.
22:55:36 <dons> its been a busy week!
22:55:48 <dcoutts> dons: it's your b'day?
22:55:51 <dons> it is.
22:55:53 <dcoutts> you didn't say!
22:55:58 <dcoutts> well happy birthday!
22:56:00 <ivanm> happy birthday dons!
22:56:02 <dons> i'm exactly 10 years old than haskell, + 9 days :-)
22:56:05 <stepcut> happy birthday dons!
22:56:07 <dcoutts> heh heh
22:56:08 <ivanm> lol
22:56:37 <ivanm> dons: thats the first implementation of haskell, rather than the report?
22:56:45 <dons> the report, 1990, april 1.
22:56:51 <dons> dons, 1980, april 9. :-)
22:57:04 <ivanm> oh, I didn't know there was an earlier report than 98
22:57:12 <stepcut> stepcut, 1977, april 10. ;-)
22:57:21 <dons> yay stepcut ! :-)
22:57:28 * ivanm : the day Chernobyl blew ;-)
22:57:36 <ivanm> literally
22:58:08 <ivanm> so, was the 1990 report an april fool's joke? :p
22:58:08 <sjanssen> wow
22:59:01 <stepcut> we are older than haskell, but younger than emacs :-/
22:59:12 <dons> sjanssen: yeah, i'll try rolling back some of the focus patches, see if that helps.
22:59:13 <ivanm> lol
22:59:39 <dons> dcoutts: suzie got me a nice new laptop bag :-)
22:59:48 * stepcut goes to bed (for real this time).
22:59:52 * dons == happy hacker
23:00:03 <dcoutts> dons: heh so you don't have to sling it into your backpack
23:00:08 <dons> right!
23:01:22 <jyp> dcoutts: Just fixed the <insert> key bug in Yi/vim
23:01:29 <dcoutts> woo!
23:01:40 <jyp> And happy birthday dons :)
23:01:40 <dcoutts> jyp: cool, where was it? in vty or yi?
23:01:43 <ivanm> @seen jyp
23:01:43 <lambdabot> jyp is in #haskell. I last heard jyp speak 3s ago.
23:01:48 <ivanm> duh
23:01:54 <jyp> dcoutts: yi
23:02:09 <dons> woot. i should try this yi thing out.
23:02:23 <jyp> home and end are (afaict) still buggy, since it's vty "fault"
23:02:26 <ivanm> jyp: I get "setup: Unrecognised flags: --disable-haddock-use-packages" when trying to build yi
23:02:27 <dons> jyp, then we should write a HW paper on the new style 'dynamic applications from the ground up' using ghc-api
23:02:39 <jyp> ivanm: try re-pulling yi
23:02:46 <ivanm> hey gour
23:03:06 <jyp> dons: let's do it.
23:03:44 <dons> ok. i'll think up a strategy, and keep in touch. we've got a few weeks yet, so should be plenty of time.
23:04:09 <jyp> dons: cool
23:04:56 <jyp> did you have a look at how I did it?
23:05:01 * dcoutts darcs pulls and makes iy-vty
23:05:21 <dcoutts> iy/yi
23:05:29 <jyp> it's a very thin layer on top of GHC api really
23:14:01 <ivanm> jyp: yep, that error's gone now... just need to get sourceview :(
23:14:11 <ivanm> do I need hscolour installed as well?
23:18:08 * dcoutts needs to make a :x vim-style yi command
23:18:22 <dcoutts> I think :x is basically just :wq
23:20:16 <ivanm> where do I get sourceview from?
23:20:26 <dcoutts> it's part of gtk2hs
23:20:31 <ivanm> is it?
23:20:54 <dcoutts> it's optional, it only gets built if you have the sourceview headers etc installed
23:21:01 <ivanm> well, its installed, but the installer for yi couldn't find it
23:21:05 <ivanm> oh...
23:21:15 <dcoutts> you might need to install a gtksourceview-dev package and build gtk2hs again
23:21:32 <dcoutts> the ./configure for gtk2hs tells you which bits it's going to build
23:22:01 <dcoutts> it's times like this we wish that gtk2hs was cabalised
23:22:16 <ivanm> lol
23:23:06 <dcoutts> ivanm: USE="gnome" emerge gtk2hs
23:23:14 <ivanm> ahh....
23:23:53 <dons> sjanssen: i'm going to read http://tronche.com/gui/x/icccm/
23:23:55 <lambdabot> Title: Inter-Client Communication Conventions Manual
23:23:57 <jyp> ivanm: no need for hscolour; (you don't want to build the docs)
23:24:07 <ivanm> k, thanks
23:25:43 * ivanm now has to wait ~40 minutes before trying to install yi again :(
23:40:48 <jargonjustin_> Out of curiosity, do the semantics of the if syntax vary at all than implementing an "if" function using guards?
23:42:58 <dons> nope. they both translate to case
23:43:15 <dons> if b then e1 else e2 ==> case b of True -> e1 ; False -. e2
23:43:31 <dons> f | b = e1 | otherise = e2 ==> f = case b of True -> e1 ; _ -> e2
23:45:40 <jargonjustin_> dons: Thanks
23:45:48 <jargonjustin_> It's just aesthetics then?
23:46:41 <dons> yeah.
23:47:00 <dons> people complain if they don't see an 'if' construct :-)
23:47:41 * dcoutts wails at the pain of having to re-write a nice Haskell script into bash
23:47:55 <dcoutts> grr, non-blocking IO
23:48:04 <ivanm> why do you have to?
23:48:22 <dcoutts> because ghc's IO always puts the FD's in non-blocking mode
23:48:26 <dcoutts> that breaks some things
23:48:33 <dcoutts> like tee or gcc
23:48:56 <ivanm> k
23:49:03 <dcoutts> it can cause gcc to hang when it produces copious amounts of error output
23:49:16 <dcoutts> since gcc expects its stdout to be in blocking mode
23:49:19 <ivanm> so is that a bug in ghc? or just that bash allows you to do unsafe things?
23:49:25 <dcoutts> similarly, tee will fail
23:49:34 <dcoutts> ivanm: it's a bug in unix
23:49:50 <encryptio> sounds like buffering is your problem, not blocking
23:49:59 <dcoutts> unix should allow different processes that share the same fd to have independent blocking non-blocking modes
23:50:20 <dcoutts> encryptio: no, it's the shared blocking mode amongst processes, there's a long analysis of it in a ghc bug report
23:51:03 <ivanm> fd = file directory?
23:51:10 <dcoutts> file descriptor
23:51:11 <encryptio> descriptor
23:51:14 <ivanm> ahhhh
23:51:31 <ivanm> so how does gcc and tee get around it???
23:51:42 <ivanm> or doesn't bash count as another process>
23:51:45 <dcoutts> they expect their stdout to be in blocking mode
23:51:55 <encryptio> weird
23:51:57 <dcoutts> but ghc puts it into non-blocking mode
23:52:40 <dcoutts> or tee expects its stdin to be blocking
23:53:18 <dcoutts> and I need it to work with tee as that's what gentoo's build system logger uses
23:53:26 <ivanm> can't ghc put output into blocking mode?
23:53:28 <encryptio> oh, so when ghc's runtime forks off another process it doesn't reset the blocking flags
23:54:05 <dcoutts> encryptio: the point is that the fd is shared by both processes, but they also share the blocking state and they prefer different modes
23:54:30 <dcoutts> when ghc forks gcc, they're both writing to the same stdout (my console or tee)
23:55:01 <encryptio> oh.
23:55:07 <dcoutts> so it can't reset the flag because it still is going to use that fd later
23:55:30 <hpaste>  lienmeister pasted "negabinary" at http://hpaste.org/1315
23:55:33 <dcoutts> the blocking state should really be per-process not global, it's very silly
23:55:53 <ivanm> and ideally, when ghc forks gcc, it should get its own blocking state?
23:55:57 <encryptio> shouldn't that be implementable without breaking backwards compatibility much?
23:56:12 <dcoutts> encryptio: it should be, yes. Talk to the kernel devs.
23:57:17 <ivanm> OK, I'm looking on the net but not having much luck: what is a blocking state?
23:57:47 <encryptio> ivanm: wether or not a write or read tries to finish before returning
23:58:09 <ivanm> so a lock on the file? "I'm using this file, so no one else touch it!"?
23:58:15 <dcoutts> not exactly
23:58:17 <encryptio> not always a file
23:58:34 <encryptio> ivanm: so if you read from a nonblocking handle, it returns almost instantly, rather than waiting for the amount of data you requested.
23:58:38 <dcoutts> it's whether reading or writing will ever block
23:59:01 <ivanm> block == chunk of data, rather than incremental updates?
23:59:07 <ivanm> or block as in block access?
23:59:12 <encryptio> "block" meaning it stops the program execution
23:59:17 <dcoutts> if there is not enough data available then it gives you as much as was available and returns, rather than waiting for the amount of data you requested
23:59:18 <ivanm> ahhh
23:59:29 <ivanm> that's non-blocking?
23:59:33 <encryptio> hai
