00:00:10 <encryptio> crucial in things like network servers and such, but blocking is easier to program for small utilities like cat and tee.
00:00:46 <dons> sjanssen: hmm. i just quit (rather than restart)  and now xmonad is well behaved wrt. firefox.
00:00:49 <dcoutts> ivanm: see man 2 open and man 2 read, look for O_NONBLOCK
00:00:57 <ivanm> k, thanks
00:02:55 <cinimod> I've now built yi but can't do anything useful with it.
00:03:04 <cinimod> I get: error: Keymap not defined, type 'q' to quit. README file may help you.
00:03:44 <jyp> you should put YiConfig in ~/.yi
00:03:56 <eumenides> yeah that's where i quit and went back to zile
00:05:21 <encryptio> opengl-driven concurrent graphical interface server. is haskell a good language for this project?
00:05:31 <jyp> cinimod: alternatively you may want to use yi --as=emacs
00:07:34 <jyp> @google zile
00:07:36 <lambdabot> http://zile.org/
00:07:37 <lambdabot> Title: Zile.org
00:08:14 <jyp> hmpf.
00:08:34 <jyp> @google zile editor
00:08:36 <lambdabot> http://en.wikipedia.org/wiki/Zile_(editor)
00:08:36 <lambdabot> Title: Zile (editor) - Wikipedia, the free encyclopedia
00:08:39 <jyp> ah.
00:09:05 <ivanm> http://zile.sourceforge.net/
00:09:07 <lambdabot> Title: Zile - Zile Is Lossy Emacs
00:09:08 <ivanm> that's the homepage
00:10:14 <jyp> cinimod: can you configure Yi as desired now?
00:10:49 <cinimod> jyp: yi --as=emacs works. Thx. BTW I got a panic message when I typed --as-emacs by mistake.
00:11:47 <cinimod> I had to create my own ~/.yi directory and then put YiConfig in it.
00:12:07 <jyp> cinimod: I'll fix the panic message...
00:13:50 <cinimod> jyp: Thanks for your help. I'm off for a spot of breakfast.
00:14:25 <sjanssen> dons: :(
00:14:36 <jyp> cinimod: thanks for testing ;)
00:18:25 <ivanm> jyp: currently compiling emacs mode yi... I have a lot of "<foo> is importd, but nothing from it is used" messages
00:18:42 <jyp> ivanm: that is "normal"
00:19:00 <ivanm> i.e. you haven't fixed all the code up yet? ;-)
00:19:37 <jyp> For one thing GHC sometimes generates these warnings when it should not
00:19:56 <jyp> Besides... not everything is 100% clean, no ;)
00:20:07 <dons> sjanssen: so have we thought about unifying the screen and stackset data?
00:20:27 <dons> i see some odd comments about how hard it is to get from xinerama screens to stacksets.
00:21:04 <cpfr> howdy what exactly does mapM_ do
00:21:15 <dcoutts> @type mapM_
00:21:18 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
00:21:20 <dcoutts> @type mapM
00:21:23 <lambdabot>     Ambiguous occurrence `mapM'
00:21:23 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
00:21:31 <dons> ?src mapM_
00:21:32 <lambdabot> mapM_ f as = sequence_ (map f as)
00:21:49 <cpfr> ok
00:21:51 <dons> it maps a monadic function over a list of values, forcing the actions
00:22:06 <dcoutts> dons: it doesn't force the actions :-)
00:22:09 <cpfr> so it runs a map over a list of actions and then executes them in order
00:22:11 <dcoutts> it builds one big action
00:22:17 <cpfr> ?src mapM
00:22:18 <lambdabot> mapM f as = sequence (map f as)
00:22:33 <dcoutts> @type sequence
00:22:36 <lambdabot>     Ambiguous occurrence `sequence'
00:22:36 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
00:22:39 <dons> hehe.
00:22:40 <dcoutts> bah
00:22:44 <dcoutts> @type Monad.sequence
00:22:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
00:23:03 <dons> cpfr: yeah, so e.g. mapM_ print [1..10]
00:23:21 <ivanm> jyp: it seems to be hanging:
00:23:25 <dons> behaves like foreach [1..10] { print $_ }
00:23:25 <dcoutts> @src sequence_
00:23:26 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
00:23:28 <ivanm> Installing: /home/ivan/usr//lib/yi-0.2/ghc-6.6 & /home/ivan/usr//bin yi-0.2...
00:23:28 <ivanm> /home/ivan/usr//bin/yi --as=emacs
00:23:51 <cpfr> @src sequence
00:23:52 <lambdabot> sequence ms = foldr k (return []) ms
00:23:52 <lambdabot>     where
00:23:52 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
00:24:21 <mauke> k = liftM2 (:)
00:24:37 <cpfr> (:)?
00:24:48 <mauke> you know, the (:) operator
00:24:53 <cpfr> ah use
00:24:56 <cpfr> cons
00:24:58 <tuukkah> :)
00:25:29 <mauke> sequence = foldr (liftM2 (:)) (liftM0 [])  :-)
00:25:31 <jyp> ivanm: did you try make clean;make emacs ?
00:25:35 <jyp> ah...
00:25:47 <jyp> run it from a shell maybe?
00:25:51 <cpfr> note i i dont like liftM2 or liftM0
00:26:00 <cpfr> erm dont know
00:26:03 <cpfr> not dont like
00:26:11 <tuukkah> =)
00:26:27 <sjanssen> dons: I've thought about it a little bit.  I think all the screen info needs to make it's way into StackSet
00:26:32 <mauke> sequence turns [m a] into m [a]
00:26:34 <tuukkah> ?src liftM2
00:26:35 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
00:26:37 <sjanssen> dons: maybe the layout descriptions too
00:27:04 <cpfr> i see
00:27:05 <mauke> i.e. given a list of actions it returns one big action that (when executed) returns a list of the results of the smaller actions
00:27:35 <cpfr> and sequence_ just returns the result of the big action
00:28:36 <cpfr> so would sequence_ = last sequence
00:28:51 <tuukkah> ?type Monad.sequence_
00:28:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
00:29:18 <dmwit> cpfr: sequence_ does the action, but doesn't return the result.
00:29:38 <cpfr> ok
00:30:03 <cpfr> ?src liftM0
00:30:04 <lambdabot> Source not found. Just what do you think you're doing Dave?
00:31:09 <mauke> liftM0 doesn't actually exist
00:31:12 <mauke> it's just return
00:32:41 <cpfr> ah ok
00:34:37 <dmwit> So in complexity class, the prof starts talking about nondeterministic finite automata.
00:34:55 <dmwit> And the whole time, I'm thinking, "List monad!  List monad!  Just use the deterministic one, but wrap it in a list monad!"
00:35:05 <dmwit> It made me feel pretty superior. =)
00:35:07 <mauke> liftM0 f = return f; liftM1 f x = return f `ap` x; liftM2 f x y = return f `ap` x `ap` y  -- coding out of my ass
00:35:41 <dmwit> :t ap
00:35:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
00:36:22 <cpfr> mauke i saw lifeM2
00:36:48 <cpfr> @src liftM1
00:36:49 <lambdabot> Source not found. Just what do you think you're doing Dave?
00:36:57 <mauke> @src liftM
00:36:58 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
00:37:16 <cpfr> ok
00:38:09 <dmwit> > liftM (*2) [1,2,3]
00:38:11 <lambdabot>  [2,4,6]
00:38:13 <mauke> :t flip (>>=) . (return .)
00:38:16 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b) -> m a -> m b
00:39:17 <dmwit> ?pl m >>= return . f
00:39:18 <lambdabot> f `fmap` m
00:39:23 <cpfr> ok
00:39:25 <dmwit> ?pl \m f -> m >>= return . f
00:39:26 <lambdabot> (. (return .)) . (>>=)
00:39:35 <dmwit> ?pl \f m -> m >>= return . f
00:39:36 <lambdabot> fmap
00:39:44 <opqdonut> :D
00:39:47 <dmwit> pl is pretty smart
00:39:54 <opqdonut> ?unpl flip fmap
00:39:55 <lambdabot> (\ b c -> fmap c b)
00:40:32 <ivanm> jyp: it freezes at the same point... possibly because I'm trying to install it as a local user?
00:40:52 <jyp> ivanm: that's what I do myself
00:41:31 <jyp> ivanm: it actually freezes when you run it right?
00:41:32 <ivanm> well, it comes up to that line (putting files into ~/usr), then doesn't do anything... :s
00:41:52 <swiert> dons, dcoutts: Are you guys on schedule for TMR?
00:42:15 <swiert> I realize you might not be in the mood for more writing after the ICFP deadline...
00:42:28 <ivanm> jyp: oh, wait, didn't notice that it ran yi, and was waiting for me to close yi :s
00:42:35 <dcoutts> swiert: remind me of the deadline
00:42:43 <swiert> Coming Friday :)
00:42:48 <dcoutts> ah ok
00:42:53 <dons> swiert: yeah, should be fine, i think.
00:42:55 <jyp> ivanm: ok :)
00:43:04 <dcoutts> swiert: yeah, probably can do
00:43:08 <swiert> I can probably offer an extension if you need it.
00:43:11 <ivanm> jyp: where do I find the YiConfig.hs file to put into ~/.yi/ ?
00:43:16 <dons> ok. we'll see how we go.
00:43:24 <jyp> ivanm: examples directory
00:43:25 <ivanm> duh, examples
00:43:25 <dcoutts> swiert: I'll give you progress updates
00:43:33 <swiert> Great. Thanks you guys.
00:45:42 <ivanm> jyp: two questions: how can I tell it to start larger? it's kinda small to start
00:45:49 <ivanm> secondly, where do I define keymaps?
00:46:28 <jyp> ivanm: You cannot change the start size (but patches are welcome) :)
00:46:35 <ivanm> lol
00:46:57 <sjanssen> dons: quite a bit of cruft has accumulated in xmonad
00:47:02 <jyp> ivanm: you can have a look at Yi.Keymap.Emacs;
00:47:17 <jyp> ivanm: inline some of it in your YiConfig, and there you go
00:47:24 <ivanm> OK, thanks
00:48:07 <ivanm> because, despite building it as emacs, it doesn't seem to like C-x C-f
00:48:21 <jyp> ivanm: it should
00:48:25 <ivanm> also, I presume there isn't meant to be a menu at this stage?
00:48:35 <jyp> no menu
00:49:24 <ivanm> I hit C-x, and it straightaway complains about Keymap not defined
00:49:50 <jyp> ah
00:50:13 <jyp> Your YiConfig is not good then
00:50:36 <ivanm> I just copied the one from the examples directory :s
00:50:39 <jyp> @hpaste
00:50:39 <lambdabot> Haskell pastebin: http://hpaste.org/new
00:51:08 <hpaste>  jyp pasted "Sample YiConfig" at http://hpaste.org/1316
00:51:19 <ivanm> is it meant to import the vim keymaps as well?
00:51:42 <jyp> import?
00:52:04 <jyp> I guess it does not hurt.
00:52:18 <jyp> Anyway, please try the one I pasted.
00:53:39 <ivanm> yep, that works, thanks!!
00:53:42 <ivanm> looking pretty good!
00:54:01 <ivanm> biggest problem I have is that it doesn't seem to realise I'm editing a literate haskell file...
00:54:19 <ivanm> and so it applies colour syntax stuff to the comments
00:55:22 <mwc> Stream Fusion: From Lists to Streams to Nothing at All.
00:55:24 <mwc> Duncan Coutts, Roman Leshchinskiy and Don Stewart.
00:55:35 <mwc> Hot digity damn, y'all reimplemented Data.List to be fully fusable?!
00:55:58 <ivanm> jyp: searching seems to be a bit iffy as well atm
00:56:00 <mwc> Is this in the libraries yet, or is it being tested
00:56:08 <jyp> ivanm: Yup
00:56:19 <ivanm> ok, good, its not just me then ;-)
00:56:35 <jyp> ivanm: these are areas where I expect contributions :)
00:56:43 <ivanm> lol
00:56:51 <jyp> the work to implement all emacs functions is huge...
00:56:54 <ivanm> I'd love to help, but I haven't used haskell _that_ much
00:57:22 <ivanm> also, I think I'm going to go and try re-doing the automatic ebuild generator for cabalised packages
00:57:36 <ivanm> s/try/first try
00:57:52 <jyp> have fun :)
00:57:55 <ivanm> lol
00:58:22 <ivanm> so, how much of this is what your work?
00:59:46 <dcoutts> mwc: the code is available
01:00:04 <dcoutts> currently it's a separate lib
01:00:11 <yiwin> @read
01:00:11 <lambdabot> Plugin `dummy' failed with: IRCRaised Prelude.read: no parse
01:00:21 <dcoutts> mwc: though we also tested it with a fork of base and ghc
01:00:32 <yiwin> @Read
01:00:32 <mwc> Hmm, is it covered with quickcheck yet?
01:00:33 <lambdabot> Plugin `dummy' failed with: IRCRaised Prelude.read: no parse
01:00:38 <dcoutts> yes
01:01:03 <dcoutts> mwc: eg fusing list comprehensions requires desugaring them into stuff we can fuse, so we had to modify ghc to do that
01:01:11 <mwc> ahhh
01:01:17 <dcoutts> but if you don't need list comps then you can just use the lib on its own
01:01:39 <mwc> So there are patches to GHC as well. Are they in HEAD yet or are they pending
01:01:42 <dcoutts> there's no need to have it in base & ghc just to play with it
01:01:55 <dcoutts> not pending, it needs more discussion
01:02:31 <dcoutts> but if/when we replace the list impl in base then of course the ghc patches will need to go in
01:02:32 <mwc> So the Data.Lib overhaul is also under discussion?
01:03:02 <dcoutts> http://hackage.haskell.org/trac/ghc/ticket/915
01:03:03 <lambdabot> Title: #915 (Implement list fusion using streams instead of foldr/build) - GHC - Trac
01:03:04 <mwc> Oh, I'd thought you said the changes to Data.List were indepedent of the changes to GHC's comprehensiions
01:03:16 <mwc> gotchya
01:03:17 <dcoutts> mwc: well, except for the list comps
01:03:33 <dcoutts> to do it fully you'd want list comps too of course
01:04:13 <dcoutts> then the ghc optimiser changes need more thought
01:04:24 <dcoutts> we expect to talk to SPJ about that
01:04:47 <dcoutts> eg at the moment optimising the stream code requires -O2
01:05:00 <dcoutts> the optimisations we need are not enabled in -O at the moment
01:05:08 <mwc> Well, it's pretty exciting anyways
01:05:12 <dcoutts> so the point is, there's a bit more engineering to do
01:05:20 <dcoutts> it's kind of ghc-6.8 timeframe stuff
01:05:33 <mwc> Yeah, that's the number I was fishing for
01:06:27 <dcoutts> btw, not only do we have quickcheck tests, we've also got strictcheck tests
01:06:44 <dcoutts> so we know when we're not in agreement with the h98 spec on strictness
01:06:58 <ivanm> dcoutts: so, apart from list comprehensions, is the fused version of lists fully compatible with the original version?
01:07:18 <dcoutts> sure, it's just an optimisation, the semantics are the same
01:07:34 <dcoutts> whereas do people know the if the strictness of the functions in base match the spec exactly?
01:08:18 <dcoutts> I think not since when we used our strictcheck tests we found a number of inconsistencies between the base impl and the spec
01:08:46 <Heffalump> as in it was wrong before your optimisations?
01:08:54 <dcoutts> most of these are justified as bugs in the spec, some are less clear
01:09:21 <dcoutts> Heffalump: nothing to do with our optimisations or impl, just comparing the spec with the base.Data.List impl
01:09:32 <Heffalump> right
01:09:35 <dcoutts> they are inconsistent on strictness in a few places
01:09:39 <dcoutts> mostly justified
01:09:45 <dcoutts> as in the spec is wrong
01:16:55 <Heffalump> I'm a bit confused by the section on strictness in your paper. You say that your transformations aren't strictness-preserving but then that your stream versions of the library are just as strict as the existing impl
01:17:18 <dcoutts> right
01:17:31 <dcoutts> the fusion rule is false for _|_
01:17:39 <dcoutts> so we avoid making and _|_ streams
01:17:43 <dcoutts> and/any
01:18:04 <dcoutts> apart from that we think it's true
01:18:28 <dcoutts> the rule doesn't otherwise change strictness
01:18:58 <Heffalump> ok, so the rule is correct for the usage you make of streams, but if you exported Stream then other people could write things that it'd break?
01:19:07 <dcoutts> right
01:19:44 <dcoutts> for example they could see Skip values and make them affect the result
01:20:30 <dcoutts> ie breaking the rule that all stream functions must treat Skips as if they were not there
01:21:06 <dcoutts> so the _|_ thing could be avoided if we had unlifted types, but the Skip thing is pretty much unavoidable
01:21:29 <dcoutts> we are using a richer domain to model lists
01:21:54 <dcoutts> either we should just not do that or we have to impose a rule that functions on the type must obey
01:22:17 <Heffalump> that doesn't sound like a problem
01:22:17 <dcoutts> and Skip is crucial to the stuff about eliminating recursion
01:23:27 <dcoutts> right, in practise it just means you have to be careful writing Stream functions. If you do it then you have a proof obligation.
01:23:51 <dcoutts> so it's no worse that the situation with build/foldr
01:25:22 <Heffalump> what can you get wrong there?
01:25:51 <dcoutts> build/foldr rule is not universally true if you use seq
01:26:05 <dcoutts> there's a paper on what uses of seq are safe
01:26:34 <Heffalump> oh, yeah, I keep forgetting about seq
01:26:40 <dcoutts> basically some build/foldr rules rely on the tail being lazily generated
01:26:51 <dcoutts> eg the head rule puts in an undefined for the tail
01:27:04 <dcoutts> but something that uses seq could force that tail
01:27:21 <dcoutts> usually you couldn't do that because of the type of build with it's forall type
01:27:28 <dcoutts> but seq works on anything
01:27:49 <dcoutts> the streams stuff does not seem to suffer the same problem
01:28:25 <dcoutts> the nearest similar problem would be taking a Stream apart and using seq to see if the individual components are _|_
01:28:52 <dcoutts> however we can avoid that by making the two components strict and putting lazyness back in whereever we need it
01:29:06 <dcoutts> which is what we actually do in our implementation, though for other reasons
01:29:50 <dcoutts> we do that to convince the simplifier that it can see the structure of our stream states, apparently SPJ will improve things there so we will not always have to do that
02:05:09 * dcoutts can now parse all but one .c file in the kernel, including properly parsing GNU __attribute__s
02:06:06 <ivanm> lol... what's with that 1?
02:06:59 <dcoutts> use of __attribute__ before a type name, inside of a typeof (..) expression
02:09:25 <fuzan> dcoutts: what are you using for parsing?
02:09:29 <fuzan> happy?
02:09:32 <dcoutts> fuzan: happy
02:09:34 <dcoutts> yep
02:09:40 <opqdonut> happy happy joy joy \:D/
02:09:46 <dcoutts> :-)
02:09:50 <fuzan> i'm using BNFC for my compilers course :)
02:09:53 <joelr1> good morning!
02:10:02 <opqdonut> morn
02:10:20 <dcoutts> fuzan: the problem is that C isn't LALR so it's pretty tricky with most parser generators
02:10:56 <joelr1> dcoutts: how do you write a paper among many people? does everyone get assigned a chunk?
02:11:06 <dcoutts> heh, I think you don't
02:11:24 <dcoutts> oh soory I mis-read!
02:11:29 <dcoutts> I thought you said parser
02:11:37 <dcoutts> oh a paper, well..
02:12:06 <dcoutts> yeah, you do different sections to start with then you re-write each others sections and do many iterations of proof reading and discussion
02:13:08 <shapr> whee!
02:13:33 <dcoutts> hia shapr :-)
02:13:44 <fuzan> dcoutts: C can't be expressed in LALR?
02:13:48 <shapr> good morning dcoutts!
02:13:56 <joelr1> shapr: yo
02:14:00 <dcoutts> fuzan: yes, with some tricky hacks
02:14:15 <opqdonut> dcoutts: care to pop an example?
02:14:15 <dcoutts> fuzan: you need some interaction between the parser and lexer
02:14:19 <joelr1> dcoutts: cool, thanks
02:14:20 <shapr> hiya joelr1, how's tenerife?
02:14:26 <joelr1> shapr: hanging on
02:14:28 <opqdonut> dcoutts: ah
02:14:29 <fuzan> dcoutts: which aspects of the langauage?
02:14:33 <joelr1> shapr: the weather is cooler
02:14:39 <joelr1> for this time of the year
02:14:49 <shapr> It's snowing here..
02:15:03 <ibid> opqdonut: you need semantic information to distinguish between identifier and typename in some contexts, AFAIR
02:15:08 <dcoutts> opqdonut, fuzan: typedef int A; A A;
02:15:15 <opqdonut> ah
02:15:32 <dcoutts> that defines A as an alias for int, then creates an int called A
02:15:52 <shapr> bbl
02:15:53 <fuzan> hah :)
02:15:58 <opqdonut> yes, i am fluent in C :)
02:16:06 <fuzan> that's gross :D
02:16:08 <dcoutts> but the grammar depends crucially on whether each name is interpreted as a variable or type identifier
02:16:14 <joelr1> shapr: what part of sweden?
02:16:21 <dcoutts> opqdonut: ok, good, I'm not :-)
02:16:38 <opqdonut> dcoutts: well, parsing the first A as a variable name in the second statement wouldn't work
02:16:53 <ibid> dcoutts: that's not actually a good example, as it has a unique parse without differentiating between typenames and identifiers
02:16:55 <opqdonut> so this example is fixable with finite lookahead
02:17:00 <opqdonut> yeah
02:17:27 <ibid> iirc there are other examples, more complicated ones
02:17:36 <foxy-om> dcoutts, We had some group come talk to us about daemonic/angelic programming from Oxford, do you know anything about them?  At the time they were using Pascal and I thought that what they were doing was highly amenable to the use of Haskell
02:17:39 <dcoutts> ibid: right, but only in a backtracking parser where we can try both possibilities
02:18:10 <dcoutts> ibid: the backtracking would probably require changing the token (or at least its interpretation)
02:18:36 <ibid> dcoutts: LARL actually does handle lots of situations that look like they need backtracking (it's the stack state that helps there)
02:18:42 <dcoutts> the main point is that the remaining tokens depend on how we parse the earlier ones
02:18:42 <ibid> dcoutts: but let me test this
02:19:08 <dcoutts> ok, try this:
02:19:26 <dcoutts> typedef int A; A A = sizeof(A);
02:19:47 <ibid> that's a better example
02:19:57 <ibid> or rather, sizeof foo; is foo a type or an expression?
02:19:58 <dcoutts> the sizeof(A); could be either a type or an expression
02:20:04 <dcoutts> right
02:20:09 <ibid> this cannot be resolved without semantic information
02:20:18 <ibid> bah, sizeof(foo), obviously
02:20:30 <dcoutts> yep the brackets are necessary to make it ambiguous
02:20:31 <ibid> dcoutts: iirc casts are another example
02:20:33 <ibid> yep
02:22:00 <dcoutts> so in a standard style parser you have to ensure that the side effects, the actions you perform when accepting productions happen sufficiently quickly so that you can update the lexer to interpret following tokens correctly
02:22:35 <ibid> yep
02:23:09 <ibid> dcoutts: btw, you don't necessarily have to backtrack, you can do a parallel parse (as in GLR) too
02:23:10 <dcoutts> typedef int A, A B(A);
02:23:49 <dcoutts> ibid: but you have to interleave the parsing with the elimination of alternatives or you can get exponential runtime since there can be exponentially many alternatives
02:24:05 <dcoutts> hence the GLR bought you nothing
02:24:34 <ibid> that's what GLR (at least as bison implements it, i don't claim to understand happy's GLR mode) does, as far as i understand
02:25:14 <dcoutts> though one can argue that the examples that give exponentially many parses don't occur in practise
02:25:48 <fuzan> @src const
02:25:48 <lambdabot> const x _ = x
02:25:57 <fuzan> what does const stand for?
02:26:06 <fuzan> i was oddly suspicious of it doing that.
02:26:14 <ivanm> constant?
02:26:16 <ibid> fuzan: it creates a constant function
02:26:33 <fuzan> the purpose of it oddly eludes me. what's the point?
02:27:11 <ivanm> in case you want to absorb a result from an operation
02:27:13 <ibid> fuzan: the point of constant functions, or the point of having a function that creates them?
02:27:25 <ivanm> because it might simplify some other expression
02:27:28 <dcoutts> fuzan: usually for passing to a higher order function
02:27:54 <opqdonut> map (const x) list
02:28:04 <opqdonut> create a list as long as list but full of x
02:28:05 <dons> nice, http://programming.reddit.com/info/1getp/comments
02:28:07 <lambdabot> Title: On Haskell: Writing a black-list filter using the Writer Monad (reddit.com)
02:29:06 <fuzan> alright. makes sense :) i'd prefer the readability of a lambda abstraction in such a case
02:29:26 <fuzan> since the const to myself seems somewhat irrelevent in definition
02:29:55 <fuzan> gotta sleep tho... night.
02:30:00 <astrolabe> Is it difficult to design a language with a context free grammar that gives unique parses?
02:30:15 <ibid> fuzan: lambda abstraction is readable, but if you know what const does, it's more readable since you don't have to puzzle out the l-a :)
02:30:21 <robreim> g'day. I'm trying to install a package with hugs but I'm getting: "Program error: <handle>: IO.getContents: protocol error (input contains non-character data - use binary I/O for binary data)". Any suggestions?
02:30:51 <ibid> astrolabe: it is very difficult if you don't know what you are doing, otherwise it's not very difficult
02:31:36 <ibid> astrolabe: "know what you doing" includes the tricks of the trade like encoding precedences, and also some things that i don't know that can be learned expect by experience
02:31:58 <astrolabe> ibid: Even haskell needs a disambiguation rule iirc
02:32:24 <ibid> astrolabe: unambigous CFG is not that hard, unambiguous LARL is harder, because the causes of conflicts are not very intuitive
02:33:01 <ibid> astrolabe: many languages are designed intentionally as ambiguous at grammar level
02:33:14 <astrolabe> ibid: why?
02:35:12 <ibid> astrolabe: because forcing a unambigous CFL makes often a worse language
02:35:38 <ibid> astrolabe: a human programmer does not care if the disambiguity is grammatic or semantic
02:35:42 <astrolabe> ibid: thanks
02:36:41 <ibid> astrolabe: this does not mean that avoiding unambiguity at grammar level is desirable, not at all:)
02:37:00 <dcoutts> ibid: very non-obvious, for example inlining some productions can make it not ambiguous where it was previously
02:37:42 <ibid> astrolabe: but sometimes it's just a tradeoff between making implementation easier vs making the language better for the programmer
02:37:49 <ibid> dcoutts: exactly
02:39:10 <dcoutts> which makes me quite annoyed since it bloats the grammar
02:39:16 <astrolabe> Perhaps a more regular, uniquely parseable grammar might help the programmer.  It might help make parse errors clearer for example.
02:40:00 <ndm> which langugage?
02:40:12 <ibid> astrolabe: do you mean make parse error *messages*?
02:40:16 <ibid> ndm: we are talking in general
02:40:37 * ndm finds that with his parsing system, these issues all disappear
02:40:39 <astrolabe> ibid: yes
02:40:44 <ibid> ndm: about the desirability of an unambiguous CF or LARL grammar
02:41:57 <ibid> astrolabe: frequently one (the implementer) gets better error messages by moving error detection off the grammar and to the semantic checking routines
02:42:27 <ibid> astrolabe: i.e. make the grammar intentionally "sloppy"
02:42:47 <ibid> astrolabe: but this is an implementation issue, not so much a language design issue
02:44:24 <astrolabe> ibid: Perhaps if there were more modular stages in the parsing, it would be better to give errors from only the first module to fail.
02:44:52 <ibid> astrolabe: then we are no longer talking about LARL parsing :)
02:45:12 <ibid> that *sounds* like LL(k)
02:45:16 <ndm> astrolabe: have you seen my parser system? it does that, by adding an additional stage
02:45:35 <astrolabe> Is the advantage of LARL etc over general CFG that it is more compulationally efficient?
02:45:47 <ibid> astrolabe: very much more efficient
02:45:56 <ibid> astrolabe: general CFG is iirc O(n^3)
02:46:00 <ndm> astrolabe: yes, plus it allows most grammars required in real life
02:46:03 <ibid> astrolabe: LR is linear
02:46:07 <astrolabe> ndm: I looked at it briefly, but didn't understand it.  I intend to look again when I understand parsing better.
02:46:09 <ndm> ibid: O(n^2.6)
02:46:16 <ibid> ndm: close enough :)
02:46:34 <ndm> LALR is ~ O(n)
02:47:02 <ndm> lexing is O(n^2)
02:47:04 <ibid> all LR variants are linear, the advantage of LARL is smaller parsers
02:47:26 <astrolabe> I don't believe realistic grammars would really be n^3 where n is the length of the thing being parsed.
02:47:55 <astrolabe> But, my intuition is very untrained on this subject.
02:48:00 <ibid> astrolabe: an algorithm that handles arbitrary CF grammars is
02:48:24 <ibid> astrolabe: you can, of course, make faster algorithms that handle a subset of CF grammars; LR is one such
02:48:29 <ibid> astrolabe: and LL is another
02:48:31 <astrolabe> ibid: But for a given CFG, it might not be?
02:48:55 <dcoutts> or for a particular input
02:49:34 <astrolabe> I'm guessing that the n here is the length of the input
02:49:41 <ibid> astrolabe: if you are willing to make a special algorithm for it (or it belongs to the class of LL or LR languages)
02:49:53 <ibid> astrolabe: in O notation, it is
02:51:30 * ibid dusts off his unfinished C compiler
02:51:35 <Heffalump> gah, that'll teach me to use fromJust everywhere
02:51:36 <opqdonut> :)
02:51:41 <opqdonut> ibid: in haskell?
02:51:46 <ndm> Heffalump: it teaches you to use Catch on your program!
02:51:50 <ibid> opqdonut: i have one in C and one in haskell :)
02:51:58 <astrolabe> ibid: What I wonder is whether some general CFG parser, say an Early Parser, when given a certain grammar, might be O(n) ish on a realistic input.
02:52:00 <Heffalump> my program isn't H98
02:52:11 <ndm> Heffalump: and it teaches you to adhere to standards :-)
02:52:22 <ndm> although once GHC.Core is unbroken, Catch will work on GHC Haskell
02:52:36 <ndm> and will actually be able to work independent from Yhc
02:52:41 <Heffalump> no, it teaches the author of Network.CGI.Monad to adhere to standards. Except it doesn't cos they don't care.
02:52:55 <Heffalump> I thought yhc doesn't actually work on real programs yet, anyway?
02:53:00 <ndm> kind of
02:53:05 <ndm> it worked on HsColour
02:53:17 <ndm> it doesn't work on many real programs, but some...
02:53:28 <ndm> we are short plenty of libraries and plenty of extensions
02:53:41 <Heffalump> well, it'll be quicker to go through my code annotating all the fromJusts than it would be to try to get it to work on yhc :-)
02:54:14 <ndm> Heffalump: try my Safe library, it provides fromJustNote, along with other helpful things
02:54:18 <astrolabe> Heffalump: Maybe just write your own fromJust?
02:54:56 <Heffalump> ndm/astrolabe: yes, indeed. It's just a pain.
02:55:26 <astrolabe> What doesn't kill us makes us more anal.
02:55:45 <opqdonut> ;)
02:56:13 <Heffalump> ndm: errm, what's the URL? I keep ending up at your FilePath library when I google.
02:56:28 <Heffalump> oh, never mind, got it
02:56:53 <Heffalump> but this URL seems to randomly end up at FilePath: http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php
02:56:56 <lambdabot> Title: Neil Mitchell - FilePath
02:57:04 <ndm> Heffalump: i reorganised my website, they used to be on the same page, now they aren't - and since FilePath is more popular the redirect has to go for that
02:57:09 <astrolabe> ndm: Have you had any comments from google about hoogle?
02:57:16 <ndm> astrolabe: nope
02:57:26 <Heffalump> surely a generic URL should go to a generic page?
02:57:29 <Heffalump> anyway, no matter.
02:57:45 <ndm> Heffalump: it was a generic URL, with only one main thing on it - i don't want it anymore
02:57:49 <dcoutts> ndm: btw, can you update your FilePath page to point to the new darcs repo http://darcs.haskell.org/packages/filepath/
02:57:50 <lambdabot> Title: Index of /packages/filepath
02:57:52 <ndm> give google a few weeks and they'll sort it out
02:58:18 <ndm> dcoutts: i will do today, once i get into the office - it took me by surprise, given its unreleased and unannounced
02:58:21 <Heffalump> can cabal handle multiple .cabal files in a directory yet?
02:58:28 <dcoutts> ndm: great
02:58:32 <dcoutts> Heffalump: no
02:58:33 <jyp> ivanm: There is now a YiConfig example for user-changing the startup size of Yi in gtk mode
03:00:00 <jyp> ndm: I'm sorry I refered to the unannounced version in my yi pre-release... I naturally assumed the darcs.haskell.org version was the "one"
03:01:15 <Cale> dons: What's up with ayrnieu, eh?
03:01:22 <ndm> jyp: it will be once GHC 6.6.1 is released, but i'll make it the new one now
03:01:35 <ndm> Ross also changed it from FilePath -> filepath, which I guess may bite us at some point
03:02:01 <Heffalump> bah, there should be a convention on initial capital letters in package names
03:03:20 * dcoutts agrees with Heffalump, except the other way around
03:03:27 <Heffalump> ?
03:03:28 <jyp> Cabal-1.1.6, HaXml-1.13.2, QuickCheck-1.0
03:03:36 <dcoutts> Heffalump: all lower case :-)
03:03:39 <jyp> all other lowercase
03:03:41 <ndm> i have FilePath-1.0, filepath-1.0
03:03:48 <Heffalump> I didn't say what I thought the convention should be
03:04:03 <dcoutts> Heffalump: oh, sorry it didn't read that way
03:04:03 <Heffalump> in fact I agree it should be all lower case, on the basis that the majority of my currently installed packages are already that way
03:04:37 <dcoutts> there should certainly be a restriction on not allowing packages that differ only in the case
03:05:04 <jyp> Cabal is the annoying exception :)
03:05:04 <dcoutts> so FilePath and filepath should not be allowed at once
03:05:05 <dcoutts> since that distinction cannot be preserved by most packaging systems
03:05:21 <dcoutts> jyp: not a lot we can do about that now :-(
03:05:34 * dcoutts -> dinner
03:06:43 * jyp -> dinner
03:08:22 <Heffalump> is jyp in Australia too?
03:08:43 <jyp> jyp -> lunch
03:08:48 <Heffalump> wooh, safe to the rescue :-)
03:09:15 <ndm> :)
03:13:01 <robreim> Does networking or threading under hugs require any sort of special command line arguments?
03:14:56 <ndm> threading requires ghc, i think
03:16:04 <Heffalump> that's one hell of a special command line argument ;-)
03:18:39 <robreim> Really? I thought hugs had threading. Oh well, that explains a lot. THanks, ndm :)
03:19:28 <ndm> it has, but not real threading, its cooperative, i think
03:21:42 <robreim> Oh right. Then I surmise it uses blocking I/O in its networking support, since that's what the symptoms I'm seeing seem to indicate.
03:42:30 <ndm> Igloo: i was expecting you to mail the list about tabs and spaces etc, or are you waiting til after GHC 6.6.1
03:43:23 <foxy-om> do haskell threads operate in one os thread?
03:44:58 <bringert> foxy-om: depends
03:45:04 <bringert> foxy-om: see forkIO and forkOS
03:45:28 <bringert> foxy-om: and the RTS -N flag
03:46:37 <foxy-om> ok, does forkIO allow process distribution over different processors?
03:46:37 <ivanm> jyp: OK, thanks
03:47:02 <ivanm> jyp: if I re-get the darcs stuff, do I have to rebuild yi?
03:47:49 <ivanm> jyp: just tried pulling... darcs couldn't find any new changes
03:49:28 <ivanm> @tell jyp When doing darcs pull, it can't find any changes.
03:49:28 <lambdabot> Consider it noted.
03:50:09 <hpaste>  kolmodin pasted "yi panic" at http://hpaste.org/1317
03:52:38 <balodja> there is a question about haskell syntax. in export-list, when typing "module Blablabla (export-list) where ...", trailing comma is a sytax error? for example, module Asdf (Abc, , Dfg) where ...
03:53:40 <balodja> i ask because there are lots of files in sources of ghc compiler, where such construction takes place
03:55:36 <ndm> GHC allows it, but it is wrong
03:58:38 <bringert> foxy-om: forkIO distributes the Haskell threads over the "worker" OS threads. You set the number of worker threads with the RTS -N option. The worker threads can run on different CPUs / cores.
03:59:04 <bringert> foxy-om: you should probably compile with -threaded too
03:59:33 <foxy-om> bringert, cool, thanks
04:00:02 <bringert> foxy-om: see the GHC manual and the haddock comments for forkIO and forkOS for more information
04:00:28 <bringert> foxy-om: oh, and -N is only available with ghc >= 6.6
04:01:50 <kolmodin> jyp: ^^ see my hpaste, it doesn't find the interface files
04:02:00 <kolmodin> but now,, lunch
04:04:58 <araujo> morning
04:05:52 <robreim> ndm: Got a minute to test a network library patch for windows?
04:07:22 <balodja> ndm: sometimes allows, but sometimes no :(
04:08:18 <maht> I cant get hugs to do Complex no.s - is it too old, I've tried -98 and +98
04:08:25 <ndm> robreim: sorry - not got my development tools etc installed on this machine - couldn't run networking code even if i wanted to
04:08:25 <maht> :+ 1 2
04:08:38 <maht> ERROR - Undefined constructor function ":+"
04:09:45 <robreim> ndm: d'oh. Ok, thanks
04:11:25 <maht> bah, I worked it out, < n00b
04:22:07 <eumenides> what's the inductive in Data.Graph.Inductive?
04:37:36 <balodja> dons: as i understand, lambdabot is not compatible with hs-plugins 0.10?
04:48:59 <shapr> hej bringert
04:49:04 <bringert> hej shapr
04:49:21 <shapr> joelr1: I'm in snowy stockholm.
04:49:39 <joelr1> shapr: cool! i think i even envy you
04:49:46 <joelr1> it's all sun, sun, sun
04:49:59 <joelr1> clear skies, clear skies, clear skies
04:50:04 <joelr1> and ocean everywhere i look
04:50:05 <joelr1> dammit
04:50:06 * earthy is reminded of the theme song to 'red dwarf'
04:50:28 <bringert> shapr: fun! how long are you over here for?
04:50:34 <joelr1> almost 180 degrees of ocean views
04:50:35 <shapr> this is shapr's girlfriend stealing him away from the dark dungeons of IRC. goodbye
04:50:45 <earthy> "It's cold outside, there's no kind of atmosphere, we're all alone, more or less... let me fly far away from here and have fun, fun, fun... in the sun, sun, sun...'
04:50:46 <bringert> haha
04:51:08 * earthy laughs
04:55:46 <Pseudonym> I'm curious how you can drink mango juice while comatose.
05:09:31 <beelsebob> morning all
05:09:47 <ivanm> evening beelsebob
05:09:56 <beelsebob> how goes it ivanm?
05:10:02 <ivanm> not bad, yourself?
05:10:15 <beelsebob> mostly good, still smashing my head against pdfs
05:10:22 <ivanm> lol
05:10:26 <beelsebob> I can't figure out why this one doesn't work
05:10:27 * ivanm is still procrastinating
05:10:55 <beelsebob> yay :)
05:11:15 <beelsebob> tbh, the pdf stuff is mostly procrastination
05:11:21 <beelsebob> but now it's just plain annoying me
05:12:05 <ivanm> lol
05:12:27 <ndm> joelr1: i'm nearly at the stage where we'll be able to automatically derive your kind of derivations from examples only
05:12:29 <beelsebob> do you happen to have any fancy pdf readers I don't have?
05:12:57 <joelr1> ndm: that's very interesting but how do you accomplish that?
05:13:08 <joelr1> ndm: are you parsing haskell code?
05:13:16 <ndm> joelr1: it makes some hypothesis of what they might look like, then checks
05:13:28 <ndm> joelr1: using template haskell
05:13:40 <joelr1> ndm: does it try to compile the hypothesis?
05:14:05 <ndm> joelr1: it interprets the hypothesis to check its correct, then it renders it to some source code - which you paste back in
05:14:48 <ivanm> beelsebob: I have xpdf, evince, epdfviewer, acroread...
05:14:52 <ivanm> oh, and gv
05:14:52 <ndm> anyway, your pretty = pretty x <> pretty y <> pretty z will be a piece of cake for it
05:14:55 <ivanm> I think that's about it
05:15:04 <joelr1> ndm: that's awesome :D
05:15:09 <beelsebob> ohhh... could you try something in evince/epdfviewer
05:15:10 <beelsebob> ?
05:15:17 <ivanm> sure
05:15:47 <hpaste>  beelsebob pasted "try this -- tell me what you see :)" at http://hpaste.org/1318
05:16:11 <ndm> joelr1: once its actually working (i've just got rendering left, the easy bit), i'll ask for your derivations and check it gets them right
05:16:20 <ndm> it will mean users don't have to learn template haskell for most things
05:16:55 <joelr1> ndm: sure, thanks
05:17:10 <joelr1> ndm: i have long avoided template haskell since i could not understand it
05:17:26 <ivanm> beelsebob: 2 pages, first page is portrait, has a diagonal line starting at bottom left, going at about 45 degrees to halfway across the page
05:17:50 <beelsebob> any error messages ivanm?
05:17:53 <joelr1> ndm: then i looked at camlp4 and the conversion issues to the new version... and i changed my view of template haskell :D
05:17:56 <ivanm> beelsebob: second page is landscape, has a vaguely cubic line starting at bottom left, ending near top of page about 2/3 across from the left
05:17:57 <ndm> ditto, the syntax tree is massive!
05:18:03 <ivanm> beelsebob: nope, no errors displayed
05:18:05 <ivanm> that's with evince
05:18:06 <beelsebob> arse
05:18:11 <beelsebob> that's what it's supposed to do
05:18:20 <beelsebob> but PDFKit doesn't display anything on the second page
05:18:21 <ivanm> give errors?
05:18:26 <ndm> well we now have SYB instances for template haskell, thanks to derive (i derived them, then make derive depend on them)
05:18:38 <beelsebob> ivanm: no, that's the way I would expect that pdf to render
05:18:46 <ivanm> lol
05:18:48 <beelsebob> but it doesn't in the one renderer I have that gives no error messages
05:19:06 <ivanm> just looked weird how you had it, not sure if you meant it to have errors
05:19:29 <beelsebob> no, it *should* meet the spec
05:19:36 <beelsebob> I'm not sure where it doesn't
05:19:51 <beelsebob> I'm beginning to wonder if the bug is in pdf kit, not in my writer
05:20:03 <ivanm> *shrug*... I'll try it from the console, see if it gives any errors this time
05:20:40 <ivanm> nope, no messages
05:20:48 <beelsebob> fail :(
05:20:55 <astrolabe> Wow.  I've coded a parser.  It's cool as ****
05:21:09 <ivanm> beelsebob: must be pdfkit
05:21:12 <beelsebob> astrolabe: excellent, now code the combinators too
05:21:18 <astrolabe> Completely crap and impractical I'm sure, but still...
05:21:29 <beelsebob> ivanm: entirely plausable, I'm gonna go submit a bug report about it
05:21:53 <astrolabe> beelsebob:  Arrrrgh
05:21:59 <beelsebob> :P
05:22:03 <ivanm> beelsebob: fair enough
05:22:21 <beelsebob> that way I get apple's engineers trying to figure out why my pdf is broken :P
05:22:59 <ivanm> lol
05:23:23 * ivanm was thinking of the gnustep pdfkit
05:23:25 <astrolabe> beelsebob: can't you just try the pdf in some other reader?
05:23:45 <beelsebob> astrolabe: it renders correctly in AcroRead, xpdf, evince, gv, ...
05:23:50 <beelsebob> but fails in Preview
05:24:22 <ivanm> it even opens in the Gimp, even though the Gimp isn't meant to open pdfs...
05:24:23 <astrolabe> beelsebob: Ah.  How hard would it be to get a minimal example?
05:24:27 <ivanm> well, OK, the first page does ;-)
05:24:40 <ivanm> beelsebob: did you try removing the first page?
05:24:45 <ivanm> see if it works after that?
05:24:47 <beelsebob> ivanm: that's not too convincing -- it's the second page that fails
05:24:54 <beelsebob> yeh, that's a good idea
05:25:07 <ivanm> of course it is, _I_ made it ;-)
05:25:12 <beelsebob> if I remove the content from the second page it doesn't even think there are two pages
05:25:17 <ivanm> not that I'm big-headed or anything...
05:25:56 <beelsebob> lol
05:26:23 <beelsebob> yeh, it doesn't render that second page at all if I put it on it's own
05:26:50 <ivanm> what delimites the pages?
05:26:50 <beelsebob> xpdf and acroread are still fine with it
05:27:05 <beelsebob> have a stare at the pdf file...
05:27:30 <beelsebob> you start reading it from the bottom
05:27:50 <ivanm> ahhh.....
05:27:55 <beelsebob> the last bit is just the byte offset of the cross reference section
05:28:06 <beelsebob> then it says /Root 1 0 R
05:28:18 <ivanm> *nod* that's page 1?
05:28:22 <beelsebob> which says that the root object is a reference to object 1
05:28:33 <beelsebob> so you can scroll all the way up to the top
05:28:40 <beelsebob> and you find 1 0 obj... endobj
05:28:46 <beelsebob> which is a catalogue
05:29:05 <beelsebob> it says that the pages are a reference to object 2 0
05:29:23 <beelsebob> there you find a pages object, with 2 children -- 3 0, and 6 0
05:29:31 <beelsebob> which are both "Page" objects
05:30:41 <ivanm> *nod*
05:30:42 <beelsebob> that make sense?
05:30:48 <ivanm> object 3 == p1?
05:30:53 <beelsebob> yep
05:31:01 <beelsebob> it's contents are at object 4
05:31:13 <beelsebob> but that's just an array containing a reference to object 5
05:31:22 <beelsebob> object 5 is a stream of length 24
05:31:26 <ivanm> *shrug* still no problem with evince
05:31:30 <ivanm> not that I expected any...
05:31:35 <beelsebob> it says, move the pen to 1,1
05:31:37 <joelr1> ndm: the cool thing about Data.Derive is that I can find so many cool uses for it
05:31:39 <beelsebob> then draw a line to 99,99
05:31:44 <beelsebob> then stroke the path
05:32:27 <joelr1> ndm: question... support i have a directory of sample code for my parser. can i execute code at compile time to scan that directory and grab the file names?
05:33:08 <beelsebob> ahhhhh!
05:33:13 <beelsebob> I *think* I've figured it out
05:33:30 <joelr1> ndm: alternatively, is it possible to analyze a module to grab defined functions that match a certain pattern?
05:33:36 <beelsebob> see at the bottom - it says /Size 8
05:33:49 <beelsebob> that indicates that the pdf contanins 8 objects
05:34:01 <beelsebob> but I think preview counts object 0 as an object
05:34:12 <beelsebob> so it was ignoring the last object in the file
05:34:39 <ivanm> lol...
05:35:00 <beelsebob> really irritating seeing as object 0 doesn't ever actually appear in *any* pdf file
05:35:01 <ndm> joelr1: that would be a template haskell question, and my knowledge of template haskell is quite low - i only use it for derive
05:35:19 <joelr1> ndm: what about inspecting modules to grab functions?
05:35:38 <ivanm> beelsebob: well, making that 8 a 9 didn't cause any errors for me...
05:35:41 <ndm> joelr1: i think thats possible, there is a currentModule function, which returns a module object, which i guess you can navigate
05:35:42 <ivanm> did it fix it in pdfkit?
05:35:59 <joelr1> ndm: let me look at that...
05:36:00 <ndm> joelr1: and i guess for the first you can do a runIO, which lets you do IO actions in teh Q monad (which is teh TH one)
05:36:19 <joelr1> ndm: i think i'd prefer #2
05:37:05 <joelr1> ndm: can't find currentModule
05:37:39 <beelsebob> ivanm: no, doesn't appear to break any other readers :)
05:37:49 <ndm> @hoogle currentModule
05:37:50 <lambdabot> Language.Haskell.TH.currentModule :: Q String
05:37:51 <lambdabot> Language.Haskell.TH.Syntax.qCurrentModule :: Quasi m => m String
05:37:53 <ndm> @hoogle runIO
05:37:54 <lambdabot> Language.Haskell.TH.runIO :: IO a -> Q a
05:37:54 <lambdabot> Language.Haskell.TH.Syntax.qRunIO :: Quasi m => IO a -> m a
05:37:55 <ivanm> but does it fix pdfkit?
05:38:03 <beelsebob> ivanm: my suspicion is it's tied to preview wanting the cross reference table to always start with 0000000000 65535 f
05:38:09 <ivanm> interesting to see what the official spec should read...
05:38:12 <beelsebob> ivanm: yep
05:38:17 <ndm> joelr1: those are the two functions i'd start looking from, but i've never used either
05:38:27 <beelsebob> the official spec says nothing about that strange cross reference to object 0
05:38:29 <joelr1> ndm: oh, i thought currentModule was a function in data.derive
05:38:34 <beelsebob> but they do use it on and off in some examples
05:38:40 <ivanm> beelsebob: hmmm.... going to bugreport it anyway?
05:39:05 <beelsebob> ivanm: no, I *think* that that's the correct behaviour -- what I will bugreport is that it always wants the extra cross reference
05:39:23 <ivanm> *nod*
05:39:26 <beelsebob> I think probably what's happening is it uses the /Size marker to allocate memory for the xref table
05:39:33 <ivanm> ahhh
05:39:39 <beelsebob> and then the last xref doesn't fit because it's put the 0 xref in
05:39:55 <beelsebob> I'm surprised it wasn't crashing it
05:40:28 <ndm> joelr1: no, those are all things in standard template haskell - data.derive won't help you with that problem
05:40:40 <joelr1> ndm: ok, thanks
05:57:04 <joelr1> :t mapM
05:57:06 <lambdabot>     Ambiguous occurrence `mapM'
05:57:07 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
05:57:18 <joelr1> :t Control.Monad.mapM
05:57:21 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
06:02:13 <beelsebob_> :i RGB
06:06:34 <bringert> Igloo: where did the repos for cabal-install and cabal-setup go?
06:08:05 <Igloo> bringert: packages/ on d.h.o
06:08:38 <bringert> Igloo: ah, ok. why in packages/?
06:08:48 <bringert> because they will come with GHC?
06:09:42 <Igloo> bringert: I think they'll come with extralibs, and even if they don't there's no problem having them there, whereas it would be a pain to have to move them there later if they do
06:10:52 <joelr1> :t uncury
06:10:55 <lambdabot> Not in scope: `uncury'
06:11:00 <joelr1> :t uncurry
06:11:02 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
06:12:28 <bringert> Igloo: ok, thanks. I've updated the wiki pages with the repo locations.
06:12:31 <joelr1> ?src uncurry
06:12:32 <lambdabot> uncurry f p = f (fst p) (snd p)
06:13:16 <Igloo> bringert: OK, thanks. Sorry about that - I would have done it myself but I didn't know they existed  :-)
06:13:47 <bringert> Igloo: no problem. good initiative to move them out of the Cabal repo.
06:14:12 <bringert> Igloo: one problem is that they rely on the ever-changing Cabal API, but I guess that should stabilize sooner or later.
06:14:39 <bringert> hmm, the cabal-install repo could do with a checkpoint
06:14:59 <Igloo> bringert: They weren't being built by default anyway, I don't think
06:15:17 <bringert> yeah
06:15:41 <sphynx> hi guys
06:15:44 <bringert> hmm, cabal-install should be available from hackage, so that you can upgrade it with itself
06:16:15 <Igloo> That would break on Windows, presumably
06:16:27 <sphynx> I have some problems while compiling extra-libs in ghc-6.6
06:16:39 <sphynx> could anyone help me?
06:16:43 <Igloo> Unless it goes to a cabal-install-$version directory
06:23:11 <chessguy> 'morning haskellers
06:23:30 <ivanm> evening
06:23:34 <ndm> morning chessguy
06:28:36 <chessguy> ?seen mux
06:28:37 <lambdabot> mux is in #haskell-overflow and #haskell. I last heard mux speak 13h 44m 39s ago.
06:33:27 <ndm> woohoo! i can automatically guess at the deriving for Data!
06:34:19 <scriptdevil> hey people just noticed one thing.. i finally found an editor that indents haskell right.. jedit..
06:34:22 <scriptdevil> :D
06:34:34 <ivanm> jedit? isn't that dead?
06:34:38 <ndm> joelr1: if you pull and take a look at Data.Derive.Data, load that with -DGUESS and then type "guess example
06:34:40 <scriptdevil> is it?
06:34:46 <ndm> " and it will give you the derivation code!
06:34:52 <ivanm> I seem to recall hearing that it was no longer maintained...
06:35:04 <ivanm> unless I'm getting confused with anover java-based editor...
06:35:09 <joelr1> ndm: what do you mean load it with -DGUESS?
06:35:24 <scriptdevil> ivanm: whoa... thats bad.... if it is true... but jedit simply has too many users...
06:35:31 <ivanm> scriptdevil: it was one of the options available for our open-source group work project
06:35:52 <ivanm> and I'm pretty sure the group that did it said it hadn't been updated in years, and was full of bugs
06:35:57 <ivanm> @google jedit
06:35:59 <lambdabot> http://www.jedit.org/
06:35:59 <lambdabot> Title: jEdit - Programmer's Text Editor - overview
06:36:00 <ndm> joelr1: ghci Data.Derive.Data -DGUESS
06:36:21 <ndm> joelr1: since Data.Derive.Data depends on SYB when guessing, but not running, i add a bit of CPP
06:36:40 <ndm> more important for things like binarydefer, otherwise the code would be depenedent on a rarely used module
06:37:02 <ivanm> scriptdevil: looks like some new people have taken over work on it
06:37:11 <joelr1> ndm: thanks a lot! i'm gonna try debugging my parser now but i will play with automatic derivation
06:37:16 <scriptdevil> ivanm: of course.. slava is too busy with factor
06:37:40 <ivanm> *shrug* never heard of factor
06:37:46 <ivanm> @google slava factor
06:37:48 <lambdabot> http://factor-language.blogspot.com/
06:37:48 <lambdabot> Title: Factor: a practical stack language
06:37:49 <scriptdevil> factor language....
06:37:53 <scriptdevil> stack based language
06:37:56 <scriptdevil> like forth
06:38:07 <scriptdevil> with postfix
06:38:10 <scriptdevil> like joy
06:38:26 <ivanm> *nod*... there was a release in august 2004, and the latest one was at the start of the year
06:38:34 <ivanm> so someone new must have taken over development
06:40:10 <scriptdevil> :D.. i knew it.. good thing i cant live without jedit.. and emacs... jedit is the emacs of the modern editors
06:40:30 <ivanm> lol... how about yi? ;-)
06:41:32 <scriptdevil> does it highlight?
06:43:06 <jcpetruzza> @djinn a -> a
06:43:07 <lambdabot> f a = a
06:43:17 <chessguy> jedit looks nice
06:43:32 <ivanm> scriptdevil: well, it highlights haskell... a bit too much
06:43:47 <jcpetruzza> @djinn Maybe (IO a) -> IO (Maybe a)
06:43:48 <lambdabot> -- f cannot be realized.
06:45:12 <scriptdevil> @google yi download
06:45:15 <lambdabot> http://www.zoozle.net/emule-bittorrent-download/yi+yi,torrent,,0.html
06:45:24 <scriptdevil> @google yi
06:45:27 <lambdabot> http://www.yi.org/
06:45:28 <lambdabot> Title: yi.org Dynamic DNS
06:45:34 <scriptdevil> @google yi haskell
06:45:35 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
06:45:36 <lambdabot> Title: yi text editor
06:46:29 <scriptdevil> @help lambdabot
06:46:30 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:46:33 <ivanm> jyp has been working on yi
06:46:36 <scriptdevil> list
06:46:42 <jyp_> @wiki yi
06:46:42 <scriptdevil> @list
06:46:42 <lambdabot> http://www.haskell.org/haskellwiki/yi
06:46:43 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
06:47:11 <scriptdevil> whoa.. i dont believe it.. binaries only for openbsd??
06:47:35 <ivanm> presumably, jyp_ uses openbsd...
06:47:55 <jyp_> I use linux
06:48:07 <jyp_> err GNU.
06:48:24 <scriptdevil> jyp_: GNU/Linux :P
06:48:44 <jyp> :p
06:48:44 <lambdabot> jyp: You have 1 new message. '/msg lambdabot @messages' to read it.
06:49:29 <ivanm> oh, so did dons then make the binary?
06:49:54 <jyp> I certainly did not.
06:50:06 <jyp> so you're probably right.
06:50:28 <ivanm> well, the binary is from 2005...
06:50:35 <ivanm> so its a bit out of date :p
06:50:38 <jyp> ha :)
06:51:05 <foxy-om_> jyp: does Yi build on mingw?
06:51:26 <jyp> foxy-om_: Does gtk2hs builds on mingw?
06:51:32 <jyp> with sourceview?
06:51:41 <scriptdevil> i got the source never mind.. shame on me... binary for gentooer like me .. sheesh
06:51:44 <foxy-om_> jyp: hm.. I think so, if done by hand
06:51:55 <jyp> foxy-om_: Then Yi should build
06:51:59 <foxy-om_> jyp: ask dcoutts
06:52:10 <scriptdevil> ghc-6.4.2: unknown package: plugins
06:52:19 <scriptdevil> i got that with yi compile
06:52:35 <jyp> foxy-om_: dcoutts posted something about that on haskell cafe.
06:53:03 <jyp> scriptdevil: you're probably building an outdated repo
06:53:20 <scriptdevil> jyp: where do i get the new one?
06:53:23 <scriptdevil> darcs>?
06:53:35 <jyp> darcs get --partial --set-scripts-executable http://www.cse.unsw.edu.au/~dons/yi
06:53:35 <lambdabot> Title: Index of /~dons/yi
06:53:56 <jyp> Actually --set-scripts-executable is not necessary any more
06:55:03 <jyp> ivanm: the patches with resizable window made it to dons, so you can try if you wish.
06:56:10 <ivanm> jyp: OK, do I have to re-make it then?
06:56:17 <jyp> yup
06:56:22 <ivanm> make clean && make emacs ?
06:56:34 <jyp> make yi-gtk should be enough
06:56:51 <jyp> but rebuilding never hurts really
06:56:57 <ivanm> so the YiConfig.hs file has been updated as well?
06:57:05 <jyp> yup
06:57:11 <jyp> have a look at it
06:57:24 <ivanm> there's a "Joe" keymap? what's that meant to be?
06:57:32 <jyp> you need to copy Gtk.hs to your ~/.yi too
06:57:33 <scriptdevil> how big is the darcs get?
06:57:44 <ivanm> jyp: OK...
06:57:54 <scriptdevil> Joe Editor
06:57:56 <ivanm> hmmm.... make yi-gtk gave an error:
06:57:57 <jyp> ivanm: the joe editor...
06:58:07 <ivanm> ghc-pkg --user hide yi-vty
06:58:07 <ivanm> ghc-pkg: cannot find package yi-vty
06:58:15 <ivanm> *shrug* never heard of the joe editor before
06:58:19 <ivanm> @google joe editor
06:58:21 <lambdabot> http://sourceforge.net/projects/joe-editor/
06:58:21 <lambdabot> Title: SourceForge.net: JOE - Joe's own editor
06:58:22 <scriptdevil> nice editor like nano
06:58:53 <jyp> ivanm: that error is harmless
06:58:53 <jyp> just ignore it and proceed
06:59:07 <ivanm> *shrug* already started rebuilding it anyway
06:59:12 <ivanm> just in case ;-)
06:59:27 <Saizan> can cabal-install install a package from a darcs repo?
06:59:32 <ivanm> its up to 32/37 already... we're not talking OO.org here ;-)
07:03:04 <ivanm> jyp: nice!
07:03:16 <ivanm> auto-sizer works well as well
07:03:38 <ivanm> only thing was, I had filepath 0.11 installed globally, and filepath 1.0 installed locally
07:03:40 <chessguy> hmm, anybody fiddled with jedit and haskell?
07:03:51 <jyp> no :)
07:03:56 <ivanm> and when running yi, it couldn't decide between the two...
07:04:02 <ivanm> so I uninstalled 0.11 ;-)
07:04:06 <ivanm> anyway, I'm off to bed
07:04:19 <ivanm> cya all tomorrow (well, its after midnight, so today I suppose)
07:05:29 <ivanm> jyp: oh, why don't you create a yi page on wikipedia? its only got a stub atm
07:05:30 <jyp> bye
07:05:59 <jyp> ivanm: I prefer to make a better Yi than to overpublicize atm :)
07:16:18 <ndm> does Yi really deserve a wikipedia page yet?
07:16:27 <jyp> I think not.
07:16:31 * ndm doesn't thinkk Yhc deserves one either, but someone else created it
07:16:36 <Heffalump> you're also not supposed to self-publicise
07:18:05 <Philippa> it probably doesn't, although it probably deserves mention alongside lambdabot for use of hs-plugins
07:18:13 <jyp> http://en.wikipedia.org/wiki/Yi
07:18:14 <lambdabot> Title: Yi - Wikipedia, the free encyclopedia
07:18:22 <jyp> The most overloaded article :)
07:26:28 <joelr1> dons: i find that quickcheck is not very good for unit testing. yes you can define 0-arity props but you don't get errors in terms of this output doesn't match expected
07:31:37 <glguy> If you have a function that takes no arguments and you only test it in one way
07:31:49 <glguy> why not just make   yourfunction=youroneanswer
07:31:53 <glguy> and not bother with the unit test
07:32:13 <chessguy> isn't a function with no arguments just a constant?
07:34:32 <ibid> glguy: the constant may be defined best in a non-obvious way, and there may be non-obvious properties about it that should be checked
07:34:46 <ibid> glguy: for example, if the constant is infinite :)
07:35:07 <gour> glguy: hi, you're responsible for 'hpaste' ?
07:35:12 <glguy> yeah
07:35:19 <chessguy> ibid: for example?
07:35:50 <mattam> ones = repeat 1 ?
07:35:53 <chessguy> glguy++ yes ye is :)
07:35:57 <chessguy> *he
07:36:13 <ibid> chessguy: no concrete examples come to mind, but i can expect some sorts of infinite trees to be useful constants
07:36:17 * glguy waits for gour to threaten legal action or something
07:36:26 <glguy> gour: why do you ask? :)
07:36:46 <chessguy> mattam: ones = 1 : ones -- is more fun :)
07:37:12 <mattam> that's just unfolding :)
07:37:33 <chessguy> yeah but it makes newbies heads implode :)
07:37:39 <chessguy> and that's always fun
07:37:42 <gour> glguy: 'paste' command in eg. #haskell.hr points at http://hpaste.org/new and will annotate #haskell instead of #haskell.hr if one paste something. in the past, #haskell.hr has its own paste 'channel'. is there anything that can be done in regards?
07:37:50 <mattam> hehe
07:38:02 <haskellboy> I can read in a single keystroke e.g.   k <- getKey w    (where w is the window) using      getKey:: Window -> IO Char   but how would I read in a word?
07:38:12 <glguy> gour: there just isn't multi-channel support atm
07:38:31 <chessguy> haskellboy: via recursion.
07:38:45 <gour> glguy: is it on todo?
07:38:51 <chessguy> haskellboy: you can stop the recursion when the key that you get is the space
07:39:14 <glguy> gour: Maybe once I move, I haven't had as much time to devote to working on it
07:39:17 <chessguy> glguy: is there a todo? :)
07:39:55 <chessguy> !paste
07:39:55 <hpaste> Haskell paste bin: http://hpaste.org/
07:40:09 <gour> glguy: ok. at least you know there is  feature request for it ;)
07:40:33 <glguy> I'm mostly hoping that someone that uses more than one haskell channel will write it and submit ;)
07:41:14 <chessguy> that sounds a lot like haskell's motto: "Patches are welcome!"
07:42:12 <gour> glguy: or maybe those that use more than one haskell channel should paste more & annoy #haskell residents :-)
07:44:25 <glguy> that'd probably result in blacklist support getting added
07:45:12 <glguy> :-p
07:45:44 <gour> why blacklisting for regular usage?
07:45:44 <joelr1> @where hunit
07:45:45 <lambdabot> http://hunit.sourceforge.net/
07:45:48 <joelr1> hmm
07:45:59 <joelr1> is there hunit in hackage?
07:46:15 <glguy> gour: If they were to paste and not un-check announce for the intent of annoying #haskell users
07:46:31 <glguy> what language is .hr?
07:46:39 <gour> Croatian
07:47:13 <ndm> hmm, how acceptable is it to use fancy point-free code in a Haskell workshop paper...
07:47:26 <gour> glguy: not many users, atm, but we hope it will improve
07:47:35 <Igloo> ndm: It should be compulsory  :-)
07:47:37 <bringert> ndm: I think it's acceptable
07:48:00 <ndm> woohoo! I deliberately avoided too much ., $, maybe magic in my ICFP one
07:48:10 <ndm> now i can get @pl to help write the paper :)
07:48:30 <bringert> ndm: I think you should use whatever is most readable
07:48:34 * Heffalump thinks that point-free code for the sake of it is not very pleasant
07:48:41 <bringert> ndm: though that of course depends on the reader
07:48:51 <Heffalump> it's nice when it's natural
07:48:53 * bringert agrees with Heffalump
07:48:56 * Igloo wouldn't use maybe without good reason, though, but that could just be because I'm not very familiar with it
07:49:51 * ndm just wants to rebel after writing point-full code for too long
07:50:03 <ndm> (but will probably add back some points before submission)
07:50:03 <bringert> what's the point of cabal-install build-dep?
07:50:22 <chessguy> ?hoogle writeChan
07:50:22 <lambdabot> Control.Concurrent.Chan.writeChan :: Chan a -> a -> IO ()
07:50:26 <eumenides> anyone know what "*** Exception: user error (Curses[-1]:keypad)" when using hscurses might mean?
07:50:29 <Igloo> bringert: So you can work on the package's devel code, presumably
07:50:33 <chessguy> oh, THAT kind of channel
07:51:23 <glguy> I've been playing with Factor lately... pointfree code to a new level :)
07:51:51 <bringert> Igloo: but the --help message says that it takes a list of packages are arguments. shouldn't it take a .cabal filename or something?
07:52:23 * Igloo doesn't know anything about it, I was just assuming it had the same motivation as apt-get build-dep
07:52:29 <bringert> ah
07:54:51 <bringert> I think it would be useful to have a version of build-dep that can install the dependencies of a package which itself is not available from hackage.
07:55:15 <bringert> you would give it a .cabal file as an argument, and it would install all the build-depends package
07:55:16 <bringert> s
07:56:16 <bringert> should that be a flag to build-dep or a separate command?
07:56:38 <bringert> Igloo: can you do something like that with apt-get?
07:57:35 <Igloo> bringert: I don't think so
07:57:44 <Igloo> But yes, it would definitely be useful
07:58:08 <bringert> I'll try to add it
07:58:23 <Igloo> Perhaps cabal-install build-dep foo should check for ./foo.cabal before looking in hackage?
07:58:37 <Saizan> we could even have a separate darcs-repos.list and a flag to make cabal-install search among them before than hackage, when you build a darcs version you may need a darcs version of the dependecies too
07:58:49 <Igloo> And "cabal-install build-dep ." and "cabal-install build-dep bar/foo.cabal" could work too
07:59:08 <bringert> what if there is a package called foo.cabal?
07:59:21 <Igloo> Then we shoot the author
07:59:32 <Saizan> is '.' allowed in package names?
07:59:34 * ndm writes the package foo
07:59:57 <bringert> Saizan: good question
08:00:11 <Igloo> We can always have --hackage and --local flags, it's just a question of whether we also want some magic
08:00:24 <Igloo> Even just "cabal-install build-dep" could work for ./foo.cabal, actually
08:00:34 <chessguy> let dropWord = dropWhile isSpace . dropWhile (not . isSpace) in dropWord []
08:00:39 <chessguy> > let dropWord = dropWhile isSpace . dropWhile (not . isSpace) in dropWord []
08:00:40 <lambdabot>  ""
08:00:58 <bringert> "A package is identified by a globally-unique package name, which consists of one or more alphanumeric words separated by hyphens"
08:01:36 <Igloo> Oh, we can't have foo6.1 package names?
08:02:12 <bringert> hmm, not even underscore?
08:02:28 <bringert> I got it from http://www.haskell.org/ghc/docs/latest/html/Cabal/index.html#packages
08:02:30 <chessguy> ?hoogle MVar
08:02:30 <lambdabot> Control.Concurrent.MVar :: module
08:02:31 <lambdabot> GHC.Conc.MVar :: data MVar a
08:02:31 <lambdabot> Control.Concurrent.STM.TMVar :: module
08:02:31 <lambdabot> Title: Common Architecture for Building Applications and Libraries, http://tinyurl.com/yobjbz
08:03:14 <Igloo> Well, depends on whether it is the traditional or Haskell definition of alpha
08:04:20 <Igloo> Right, Cabal's package name parser just uses isAlphaNum
08:04:36 <Igloo> so we presumably can have non-ASCII package names  :-)
08:04:45 <bringert> yikes
08:05:52 <dino-> Is cabal able to install man pages for a project?
08:06:00 <vincenz> @localtime dons
08:06:02 <lambdabot> Local time for dons is Tue Apr 10 01:05:24 2007
08:06:04 <vincenz> Igloo: why the perm @
08:06:07 <Igloo> I don't think it knows about manpages
08:06:12 <dino-> I've been reading through the manual, but am not seeing anything that looks like it.
08:06:16 <Heffalump> cos he's important, obviously
08:06:22 <Igloo> So only if you write it by hand
08:06:34 <Igloo> vincenz: Because I had to ban someone yesterday, IIRC
08:06:46 <dino-> Sure, but ./Setup.lhs install <- not going to install man page.
08:06:56 <vincenz> Igloo: who?
08:07:01 * Heffalump wonders if Smerdyakov is still banned
08:07:01 <Igloo> dino-: Right
08:07:07 <vincenz> hehe
08:07:09 <vincenz> Heffalump: evil
08:07:19 <vincenz> or protontorpedo
08:07:19 <Igloo> vincenz: Can't remember
08:07:23 <glguy> smerdy is bannd by chanserv
08:08:23 <vincenz> palomer still banned
08:08:38 <Heffalump> what did palomer do?
08:08:41 <vincenz> dunno
08:08:47 <vincenz> by 'sagan.freenode.net'
08:08:49 <vincenz> that's rather odd
08:08:55 <glguy> caused by a netsplit
08:08:59 <glguy> dons knows what he did
08:09:02 <glguy> I believe
08:09:07 <glguy> It wasn't one incident
08:09:10 <glguy> it was a pattern of behavior
08:10:36 <vincenz> wow
08:10:41 <vincenz> even cale banned somebody
08:10:44 <dino-> The reason I bring up the man thing is I'm packaging my stuff up as .deb archives (or trying to learn how) and a man page is required. I could stick one in doc/ in my project dir and have debian/rules install it after the Setup.lhs install step. Thus taking care of at least Debian-based users.
08:10:50 <vincenz> that guy must've been annoying as hell, cause Cale is very relaxed
08:11:13 <Igloo> We get trolls all the time. It's not particularly rare that someone has to be banned
08:11:27 <vincenz> Igloo: dunno, overall haskell's pretty mild w.r.t that
08:11:33 <vincenz> add an #
08:11:48 <norpan> unboxed haskell
08:11:54 <Igloo> It's not #haskellers who do the trolling, it's people who come here just to troll
08:12:19 <vincenz> Igloo: I know, but take for instance some other chans, they're already much rougher to begin with
08:13:38 <vincenz> dcoutts/dons: not sure if the TPC will be happy with you putting your papers online with a simple 'warning'
08:13:49 <vincenz> maybe they will cause they're also new to th whole doubly blind review thing
08:13:51 <ndm> vincenz: someone else did it before them
08:14:02 * ndm has avoided putting his paper up
08:14:02 <vincenz> ndm: oh
08:14:24 <ndm> vincenz: someone else got their paper on reddit and lambda-the-ultimate before the deadline
08:14:29 <vincenz> ndm: ouch
08:14:31 <Heffalump> the double-blind guidance did explicitly say it was fine to put it on a webpage
08:14:39 <vincenz> Heffalump: ah, not in our world
08:14:52 <vincenz> have to admit tho, doubly-blind's starting to pss me off
08:14:57 <ndm> a web page is different from planet.haskell.org
08:15:08 <pejo> vincenz, how do you get people to read your paper - print it out and pass copies around?
08:15:08 <eumenides> i've made rough skeleton code for a toy roguelike in haskell, but output lags behind two (!) key pressed D:
08:15:14 <eumenides> presses*
08:15:23 <Heffalump> eumenides: not lags until you hit enter, or something?
08:15:23 <swiert> I'm not too fond of the double blind thing either.
08:15:24 <ibid> ndm: planet is just a web page, i should know :)
08:15:25 <ndm> i'm not saying its wrong, but its quite different from on your home page, where no one is likely to run in to it
08:15:40 <ibid> (it's generated by script but it's raw html otherwise:)
08:15:56 <vincenz> ibid: he probably means it's more visible
08:15:58 <pejo> ndm, I regularly check a bunch of personal homepages of the 'big' researchers.
08:16:11 <ibid> vincenz: yes, i got it :)
08:16:14 <eumenides> Heffalump: i mean, the output updates instantly, but if i press five times left and then up i have to press another button until it finally does up
08:16:17 <vincenz> :)
08:16:20 <pejo> Wouldn't be surprising if others did the same.
08:16:25 <ndm> pejo: but thats you going out of your way to find it, something the reviewers are not meant to do
08:16:29 <eumenides> Heffalump: it's bizarre
08:16:52 <Igloo> eumenides: You probably need set stdout to not buffer
08:17:15 <swiert> ndm: But our community's so small, people are bound to stumble upon stuff.
08:17:19 <eumenides> Igloo: even with hscurses?
08:17:51 <Igloo> Oh, I can't remember enough about curses to think what the problem there would be
08:22:34 <Laney> What do I do about this error: "afpcwk2.o:fake:(.text+0x8be9): undefined reference to `__stginit_mtlzm1zi0_ControlziMonadziState_p'" when trying to compile my script with profiling info?
08:24:50 <joelr1> how do i declare instance Eq for "Either a b"?
08:24:56 <Heffalump> do you have the profiling libs installed?
08:25:03 <Heffalump> joelr1: there should already be one, shouldn't there?
08:25:15 <Laney> Heffalump, are they not installed by default? I guess not then.
08:25:24 <joelr1> Heffalump: not for ... oh, i see, never mind, i understood the error :D
08:25:45 <Heffalump> Laney: what OS?
08:25:54 <Laney> Windows (Vista)
08:26:16 <Heffalump> oh, they might be included by default then
08:27:51 <Laney> Well I can compile it just fine without -prof -auto-all
08:28:15 <Heffalump> I think they should be included
08:28:19 <Laney> No, I lied.
08:28:27 <Laney> I forgot to call my functions in main :(
08:28:32 <Heffalump> do you have libHSbase_p.a in your GHC install dir?
08:28:57 <Laney> Yeah
08:29:11 <Heffalump> ok, then you have the profiling libs
08:29:22 <Laney> No, it errors even without them, I've just found.
08:29:26 <Heffalump> presumably you are compiling with -package mtl?
08:29:28 <Heffalump> oh, right
08:29:40 <Laney> I think I read something about PATH problems on Vista, could be it I guess
08:29:42 <Heffalump> in that case my question about -package mtl is probably quite important
08:29:55 <Laney> No, I've never even heard of that!
08:30:08 <Heffalump> Control.Monad.State is in a different package to "base"
08:30:09 <roconnor> @src Num
08:30:09 <lambdabot> class  (Eq a, Show a) => Num a  where
08:30:10 <lambdabot>     (+), (-), (*)           :: a -> a -> a
08:30:10 <lambdabot>     negate, abs, signum     :: a -> a
08:30:10 <lambdabot>     fromInteger             :: Integer -> a
08:30:14 <roconnor> @docs Num
08:30:15 <lambdabot> Num not available
08:30:17 <Heffalump> so you need -package mtl when building
08:30:18 <roconnor> @docs Prelude
08:30:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
08:30:25 <joelr1> @where id
08:30:26 <lambdabot> I know nothing about id.
08:30:31 <joelr1> :t id
08:30:35 <lambdabot> forall a. a -> a
08:30:48 <joelr1> can lambdabot tell what module is a function part of?
08:30:48 <chessguy> ?hoogle id
08:30:49 <lambdabot> Prelude.id :: a -> a
08:30:49 <lambdabot> Text.Html.identifier :: String -> HtmlAttr
08:30:49 <lambdabot> Text.ParserCombinators.Parsec.Language.identLetter :: LanguageDef st -> CharParser st Char
08:30:54 <Heffalump> there's a rather poor hint in the symbol it failed to find - the mtl after the "__stginit_"
08:30:55 <joelr1> ah!
08:31:07 <Laney> Heffalump, adding that flag seemed to fix it. What does it do?
08:31:18 <joelr1> chessguy: thanks
08:31:20 <chessguy> how's that for a fast answer to a question :)
08:32:43 <roconnor> non-standard analysis is haskell is totaly awsome
08:32:48 <Heffalump> Laney: the libraries are arranged into packages
08:33:05 <Heffalump> the basic stuff like the Prelude etc in is in "base", which you get by default
08:33:21 <Heffalump> stuff like Control.Monad.* is in the "mtl" package which you have to ask for
08:33:36 <Laney> Oh, right. I never had to do that on the University boxes.
08:33:37 <chessguy> glguy: are you accepting patches for hpaste?
08:33:55 <Heffalump> I think ghc --make figures it out for itself, though I could be wrong
08:34:04 <Heffalump> so you only need -package foo when not using --make
08:34:07 <Heffalump> but I'm not entirely sure
08:34:19 <jrmole> > iterate (concatMap (\e -> [length e, head e]) . group) [1]
08:34:22 <lambdabot>  [[1],[1,1],[2,1],[1,2,1,1],[1,1,1,2,2,1],[3,1,2,2,1,1],[1,3,1,1,2,2,2,1],[1,...
08:34:31 <glguy> chessguy: yes, but let me know if you want to get started and I'll point you at the code that follows HAppS 0.8.8
08:34:57 <chessguy> glguy: ok, i may give multi-channel support a shot
08:35:24 <glguy> chessguy: there's an hpaste-devel that was following the new version of HAppS
08:35:43 <Laney> @src iterate
08:35:43 <lambdabot> iterate f x =  x : iterate f (f x)
08:35:44 <glguy> I don't think that that is the correct way to branch a darcs repo, but I was in a hurry  :)
08:36:12 <chessguy> how active is the HAppS development?
08:36:31 <chessguy> ?where happs
08:36:31 <lambdabot> http://happs.org
08:36:46 <glguy> Pretty active
08:37:28 <chessguy> yeah, looks like it
08:39:32 <chessguy> "HAppS is a framework for developing Internet services quickly, deploying them easily, scaling them massively, and managing them ziplessly."...pretty hefty claim
08:41:35 <Heffalump> how does HAppS work in parallel?
08:41:51 * Heffalump thought it was based on a strongly-ordered (and therefore single-threaded) list of events
08:50:23 <Laney> Wow, if only I'd known about HAppS before committing myself to Python. Could have had some fun!
08:50:39 * bringert finally got around to making cabal-install's command-line options parsing a little less of a pain to modify
08:51:04 <yiwin> where are some about FFI tutorials?
08:51:31 <emu> ?where ffi
08:51:31 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
08:55:50 <Igloo> bringert: Now that you're an expert, there are at least 3 command lines parsers in GHC that could do with some attention  :-)
08:56:05 <bringert> :-)
08:56:37 <bos_> bringert: thank you! :-)
08:56:43 <yiwin> if i have only a dll file. no Head file. How can call dll's method?   make a head file?
08:57:32 <hpaste>  oren annotated "Stubborn memory leak" with "Profiling makes memory leak disappear" at http://hpaste.org/1314#a1
08:58:11 <oren> Anyone has any idea why profiling would make a memory leak disappear? Better yet, how to achieve the same result without compiling with "-prof" :-) ?
08:58:40 <kc5tja> oren: Compiling with profiling causes different code to be generated.
08:58:55 <Heffalump> does changing the optimisation level make it disappear too?
08:59:27 <ndm> oren: it happens sometimes, i've had it happen too - hard to figure out
08:59:28 <oren> Heffalump: Hmmm... Not the last time I tried but that was a few variants ago. Sec....
08:59:48 <kc5tja> yiwin: That's probably your best bet.
08:59:57 <oren> Nope, -O2 still leaks
09:00:13 <ndm> oren:  i found -O0 -prof gave me fastest cod
09:00:28 <bringert> cod?
09:00:32 <bos_> fastest cod in the ocean
09:00:37 <Laney> Thanks, now I'm hungry :(
09:00:40 <Heffalump> yes, they need speed to escape the North Sea trawlers
09:00:46 * bos_ batters ndm's cod
09:00:48 <Heffalump> only the power of GHC can give them that
09:00:57 * ndm gets hungry, back in a bit!
09:01:28 <oren> ndm: It isn't just profiling. I also need to add a manual section at a critical point in the code. I'm worried this isn't robust - may give up on me at any moment...
09:01:40 <kc5tja> ndm is chasing after that cod, apparently.
09:01:42 <yiwin> kc5tja:  make a head file. and write foreign import ccall "dll method"  xxxx   is workable？
09:02:47 <kc5tja> yiwin: As long as you have enough information to recreate the original calling interface for the DLL, the compiler won't know the difference.
09:04:03 <yiwin> kc5tja： but it is work in winhug?
09:08:10 <kc5tja> yiwin: I do not use winhug.  But if it follows the same FFI conventions as GHC, I don't see why it shouldn't work.
09:08:44 <balodja> @src (!!)
09:08:44 <lambdabot> xs     !! n | n < 0 = undefined
09:08:45 <lambdabot> []     !! _         = undefined
09:08:45 <lambdabot> (x:_)  !! 0         = x
09:08:45 <lambdabot> (_:xs) !! n         = xs !! (n-1)
09:09:23 <balodja> omg :)
09:10:11 <yiwin> and onething confuse.  why have to  a h file？   decl foreign import  is   enough information。  h file is necessary?
09:11:43 <scriptdevil> is haskell 6.6 kinda broken?
09:11:55 <scriptdevil> ghc
09:11:57 <scriptdevil> *
09:12:31 <ndm> scriptdevil: no
09:12:45 <yiwin> kc5tja： in hug doc:  Suppose you have some C functions in test.c with some foreign import declarations for those functions in HTest.hs, and that the code in test.c needs to be compiled with -lm. To use these with Hugs, you must first use ffihugs to generate HTest.c.
09:13:07 <yiwin>  kc5tja:  what is HTest.c?
09:13:15 <ndm> yiwin: winhugs can do all that, you need to select the big package for installation, that has ffihugs
09:14:48 <scriptdevil> ndm: .. i dunno whether to like gentoo or hate it... it is still in 6.4.2
09:14:56 <scriptdevil> and 6.6 is hard masked
09:15:09 <hpaste>  eumenides pasted "output lags behind input" at http://hpaste.org/1319
09:15:25 <eumenides> ideas? :(
09:16:52 <therp> scriptdevil: emerge layman
09:16:59 <therp> scriptdevel: layman -a haskell; emerge ghc
09:17:12 <scriptdevil> therp: what does that do?
09:17:32 <therp> you might need to layman -S before doing layman -a haskell
09:17:42 <yiwin> I am still unclear。 what is HTest.c?  its what for?
09:17:54 <scriptdevil> what is layman for?? installing hard masked stuff?
09:18:31 <therp> scriptdevil: http://gentoo-wiki.com/TIP_Overlays
09:18:33 <lambdabot> Title: Portage Overlay Listing - Gentoo Linux Wiki
09:18:48 <yiwin> and head file is necessary?
09:20:00 <scriptdevil> neat...
09:21:17 <kc5tja> yiwin: I'm sorry, I can't answer that question.  As I said, I don't use Hugs.
09:22:58 <yiwin> kc5tja： whatever  thank you help
09:23:35 <kc5tja> yiwin: No problem; sorry I couldn't be of more help.  :(
09:26:02 <scriptdevil> therp: it again tries to install 6.4.2
09:26:23 <yiwin> i only use hug reason  is  have syntax hightlight  .  maybe i must be used to ghci.
09:26:54 <therp> scriptdevil: hmm, you might have to add use flags for ghc ~yourarch
09:27:17 <glguy> I think that sentence is about hugs having syntax highlighting, but I don't remember any such thing
09:27:45 <scriptdevil> you mean in package.unmask?
09:28:18 <glguy> is #gentoo down?
09:28:19 <therp> scriptdevil: I meant keywords, see package.keywords
09:31:56 <yiwin> oh, i mistake.  hug no syntax hightlight.  but its colorful.
09:32:29 <chessguy_lunch> what's SCC?
09:33:00 <bos> strongly connected components?
09:33:10 <glguy> ?vera scc
09:33:10 <Heffalump> yes
09:33:12 <lambdabot> *** "scc" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
09:33:12 <lambdabot> SCC
09:33:12 <lambdabot>      SCSI Controller Commands (SAM)
09:33:12 <lambdabot>  
09:33:12 <lambdabot> *** "scc" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
09:33:14 <lambdabot> [23 @more lines]
09:33:20 <chessguy> as in graph theory?
09:33:25 <bos> yes
09:34:01 <chessguy> hmm
09:34:44 <chessguy> i don't think that makes sense here. i'm looking at the most recent email on -cafe by Oren Ben-Kiki: "Chasing down my memory leak I got into a weird situation where adding
09:34:44 <chessguy> a magic manual SCC section and compiling with -prof makes the leak
09:34:45 <chessguy> disappear."
09:35:06 <ndm> i don't gt that easier
09:35:13 <ndm> a magic manual SCC section
09:35:28 <ndm> * get that either
09:36:31 <chessguy> from his code: -- Profiling with The "magic" SCC MAKES THE PROBLEM VANISH!
09:37:11 <chessguy> and extra = {-# SCC "magic" #-} case result of ...
09:37:25 <Heffalump> in that context it's a profiling annotation, right?
09:37:29 <Heffalump> something cost centre
09:37:51 <Heffalump> -auto-all implicitly adds that to all top-level definitions
09:39:16 <chessguy> i don't see how profiling anything could make any problem go away
09:39:29 <ndm> chessguy: i don't either, but it does for one of my programs too
09:39:55 <_roconnor> @hpaste
09:39:55 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:41:20 <hpaste>  (anonymous) pasted "deriviates" at http://hpaste.org/1320
09:41:43 <_roconnor> this is totally awesome
09:42:11 <_roconnor> now I can write my optimiser using newton's method is a totallly clear way
09:42:32 <_roconnor> I don't have do make the derivitive myself and risk making a symbolic calculation error
09:44:22 <chessguy> ?hoogle (:+)
09:44:23 <lambdabot> Did you mean: (:+)
09:44:23 <lambdabot> Prelude.undefined :: a
09:44:23 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
09:44:46 <glguy> ? index (:+)
09:44:50 <glguy> ? index (:+)
09:44:52 <glguy> ?index (:+)
09:44:53 <lambdabot> Data.Complex
09:45:27 <_roconnor> glguy: I know, it is a bad constructor name
09:45:37 <_roconnor> I copied it from the original article
09:45:44 <glguy> ?
09:45:51 <glguy> I just did that for chessguy
09:45:56 <dying_sphynx>  /msg nickserv set unfiltered on
09:45:58 <glguy> Did you use it in your hpaste?
09:45:59 <_roconnor> oh
09:46:02 <_roconnor> yes
09:46:22 <chessguy> but he's not even importing Data.Complex
09:46:40 <beelsebob> excellent :) colour and path support
09:46:42 <chessguy> (apparently)
09:46:50 <beelsebob> just need stroke style support now :)
09:47:06 <chessguy> ohhhhh
09:47:11 <chessguy> it's an infix constructor
09:47:18 <chessguy> @slap chessguy
09:47:18 * lambdabot slaps chessguy
09:47:31 <roconnor> chessguy: yeah, I'm defining it myself
09:47:43 <roconnor> I should change the constructor perhaps
09:49:40 <roconnor> Diff probably can be turned into a really useful library
09:49:54 <chessguy> why is only the first type strict?
09:51:33 <chessguy> @type \f x -> let (_ :+ a) = f (x :+ 1) in a
09:51:36 <lambdabot> forall t a. (RealFloat t, RealFloat a) => (Complex a -> Complex t) -> a -> t
09:52:33 <chessguy> @type \f x -> let (_ ?O a) = f (x ?O 1) in a
09:52:35 <lambdabot> Parse error in pattern
09:54:16 <roconnor> chessguy: I don't know.  Probably not a good idea
09:54:41 * roconnor deletes the strictness from his version
09:54:51 <chessguy> and yet he frequently calls the second part x', which would indicate strictness
09:55:11 <roconnor> here x' means dx
09:55:35 <emu> ' can mean lots of things
09:55:43 <chessguy> hmm
09:55:57 <glguy> it can be an abbreviation mornin'
09:56:08 <emu> strictly morning!
09:56:12 <glguy> (might be the wrong word)
09:56:30 <ndm> @pl \x -> maybe x id x
09:56:31 <lambdabot> join (flip maybe id)
09:56:46 <glguy> I could be an error as I saw on a restaurant's menu recently "Support your local business's"
09:57:03 <chessguy> haha
09:57:21 <emu> business's business
09:57:43 <glguy> it was a misuse of the ', and also a spelling error
09:59:41 <emu> when in doubt consult angry flower
10:00:44 <chessguy> ermm, that code didn't come directly from the blog
10:00:57 <roconnor> angry flower is wrong
10:01:05 <roconnor> VCR's is an acceptable use of '
10:01:15 <roconnor> 1's
10:01:18 <roconnor> a's
10:01:21 <roconnor> are all plural
10:01:59 <chessguy> roconnor: did you change the code before hpaste'ing it?
10:02:10 * glguy kills chessguy 
10:02:15 <chessguy> (strict hpaste!)
10:02:22 <chessguy> glguy: ?
10:02:23 <roconnor> chessguy: yes, a little
10:02:42 <emu> acceptable and correct are two different monsters
10:02:42 <roconnor> hmm, my attribution is a bit misleading then
10:02:45 <chessguy> glguy: what'd i do now?
10:02:47 <vincenz> roconnor: I tend to just tack on the s for acronyms in all caps
10:03:02 <roconnor> emu: when it comes to english, there is no correct
10:03:16 <roconnor> vincenz: I've started doing that too
10:04:39 <rictic> Are there any projects right now that will type-annotate a haskell source file?  (I'm looking around before reinventing the wheel)
10:04:52 <vincenz> rictic: completely?
10:05:23 <rictic> vincenz: Just top-level functions and values if that's what you're asking
10:05:27 <vincenz> ah ok
10:05:30 <vincenz> rictic: cause if you have copletely
10:05:31 <vincenz> you get
10:05:37 <vincenz> (a :: T) + (b :: T)
10:05:40 <vincenz> in all your exps
10:05:43 <vincenz> that might get verbose
10:05:51 <vincenz> (well that's forr the 'a+b' cas)
10:05:54 <chessguy_dead> that's pretty obviously not what he meant
10:06:24 <vincenz> chessguy_dead: one never knows
10:06:32 <emu> dons has a script.  and emacs haskell-mode will also do it per-binding if you like.
10:07:26 <rictic> emu: Is dons' script online someplace?
10:07:33 <emu> ?where dons
10:07:33 <lambdabot> http://www.cse.unsw.edu.au/~dons
10:07:44 <ndm> ?where ndm
10:07:45 <lambdabot> http://www.cs.york.ac.uk/~ndm/
10:08:54 <emu> i forgot where it is
10:10:45 <rictic> emu: Ok, I'm looking around.  I'm looking to improve Haskell support from within my favorite editor
10:11:00 <rictic> Some of lambdabot's powers would be useful from within an editor
10:11:21 <emu> if you can hook it up to ghci then you can get lambdabot through that
10:11:26 <rictic> Automatically rewrite the selected expression to be points-free for example
10:11:45 <rictic> *nod*  I think I'll try and crank out some glue in Ruby and see how far it gets.
10:12:00 <emu> you  might want to write a binding to shim
10:12:21 <emu> that will give you a nice interactive toplevel interface
10:12:29 <emu> currently there is only support for emacs
10:12:35 <jyp> Yi! Yi! Yi!
10:12:40 <jyp> :)
10:12:43 <emu> or help out Yi!
10:12:49 <chessguy> ricebowl: what editor?
10:12:55 <chessguy> err, rictic
10:12:57 <dmhouse> ndm: ping, around?
10:12:59 <jyp> @wiki yi
10:12:59 <lambdabot> http://www.haskell.org/haskellwiki/yi
10:13:01 <rictic> chessguy: heh, Textmate
10:13:16 <dmhouse> jyp: looking forward to Yi, if only I could get the damned thing to build :)
10:13:23 <chessguy> eww, mac
10:13:30 <jyp> dmhouse: I'm here to help.
10:14:09 <dmhouse> jyp: well, I can't get the latest version of FilePath to build ("Not in scope: filterM"), hence my pinging Neil.
10:14:16 <jyp> ah.
10:14:18 <emu> filterM is part of MTL?
10:14:19 <jyp> alright.
10:14:22 <vincenz> emu: yes
10:14:27 <vincenz> dmhouse: you have 6.6?
10:14:29 <emu> its missing a build-dep
10:14:31 <dmhouse> vincenz: yep.
10:14:38 <emu> add mtl to build deps
10:14:47 <vincenz> dmhouse: mtl is an extraneous cabal package
10:14:58 <vincenz> So that might be one probable cause
10:14:58 * jyp gotta run
10:15:42 <ndm> dmhouse: yep
10:15:56 <ndm> dmhouse: which version?
10:16:09 <ndm> dmhouse: i.e. which version of GHC, Hugs and FilePath, and where did you get FilePath from?
10:16:53 <dmhouse> ndm, darcs.haskell.org, FilePath 1.0, GHC 6.6.
10:17:00 <dmhouse> I added mtl to the Build-Depends and it works fine.
10:17:32 <ndm> dmhouse: i import filterM, but never use it - I'll fix that up now
10:17:48 <dmhouse> ndm: thanks.
10:18:31 <ndm> dmhouse: oh dear, i import quite a lot of stuff i don't use ... - wonder how that happened
10:18:42 <bringert> hmm, why isn't there a way to build just some of the targets in a .cabal file?
10:20:09 <Saizan> is "rec" a reserved keywork?
10:20:15 <ndm> Saizan: no
10:20:18 <Saizan> s/work/word/
10:20:55 <emu> let wreck is ocaml ;)
10:20:59 <Saizan> ghci gives me a parsing error if i use it as the name for a function
10:21:31 <dmhouse> Saizan: I bet there's an unterminated string or something like that on the previous line
10:21:32 <emu> which version
10:21:36 <Heffalump> does it have special meaning in MonadRec syntax?
10:21:49 <Heffalump> or is mdo all you need for the recursive binding
10:22:04 <dmhouse> Or perhaps a trailing '=' or something like that.
10:22:13 <Saizan>  GHC Interactive, version 6.7.20070323, for Haskell 98.
10:22:14 <ndm> dmhouse: please try again, i've removed quite a lot of imports
10:22:24 <emu> Main> let rec x = x
10:22:25 <emu> works ok
10:22:38 <Heffalump> Saizan: presumably you have an example where you just rename a variable to rec and it stops working?
10:23:07 <dmhouse> Saizan: yeah, try calling it rec' or something and see if you still get the error.
10:23:09 <Saizan> yes
10:23:18 <Saizan> i get no error with rec'
10:23:28 <emu> which extensions are loaded
10:23:30 <dmhouse> Paste the code?
10:23:38 <Saizan> i'mk trying to narrow down the effending code
10:23:44 <Saizan> *offending
10:23:58 <Heffalump> FWIW, let rec x = x in rec 5 works for me with -fglasgow-exts
10:24:04 <Heffalump> but in 6.4.2
10:24:46 <Saizan> it's -farrows that triggers it
10:25:14 <hpaste>  roconnor annotated "deriviates" with "Finding Roots" at http://hpaste.org/1320#a1
10:25:30 <roconnor> Diff> rootOfNear (\x -> x^2-2) 1
10:25:30 <roconnor> 1.4142135623730951
10:25:42 <dmhouse> ndm: perfect, thankyou.
10:25:49 <Saizan> ?where arrows
10:25:50 <lambdabot> http://www.haskell.org/arrows/
10:26:09 <dmhouse> Saizan: then I guess the answer is, 'yes', 'rec' is a keyword. Use something else :)
10:26:28 <Heffalump> ahh
10:26:30 <roconnor> Diff> rootOfNear sin 3
10:26:30 <roconnor> 3.141592653589793
10:26:36 <Saizan> i'd like to know what it does at this point :)
10:26:38 <ndm> dmhouse: which GHC version is it, out of curiosity?
10:26:41 <Heffalump> I thought of recursive do syntax, but forgot arrows :-)
10:26:45 <dmhouse> ndm: 6.6.
10:26:47 <Heffalump> it's a part of arrow syntax
10:26:51 <Heffalump> ArrowLoop or ArrowRec or something
10:27:00 <Heffalump> lets you use that keyword to get recursive bindings
10:27:00 <ndm> dmhouse: weird, builds fine for me without specifying mtl in the cabal...
10:27:07 <dmwit> :t fix
10:27:09 <lambdabot> forall a. (a -> a) -> a
10:27:15 <dmwit> > fix sin
10:27:15 <ndm> anyway, good catch - neater code is good code
10:27:17 <lambdabot>  Exception: <<loop>>
10:27:38 <Heffalump> Saizan: are you actually using arrow syntax?
10:27:42 <ndm> oh, filepath commits go down the cvs-libraries list
10:27:47 <dmwit> :t iterate
10:27:53 <lambdabot> forall a. (a -> a) -> a -> [a]
10:28:03 <Saizan> Saizan: yes, only for proc and -< though
10:28:10 <dmhouse> ndm: differing versions of Cabal?
10:28:11 <dmwit> > (iterate sin 3) !! 50
10:28:19 <lambdabot>  0.1225323488126447
10:28:33 <dmhouse> ndm: I have 1.1.6.
10:28:55 * Heffalump tried using arrows for something recently but decided they didn't actually fit the problem
10:28:56 <ndm> dmhouse: i'm on 1.1.7, still that shouldn't cause it
10:28:58 <dmhouse> dmwit: fix f, with any strict f, is <<loop>>.
10:29:07 <dmwit> > (iterate (\x -> x + sin x) 3) !! 50
10:29:09 <lambdabot>  3.141592653589793
10:29:11 <chessguy> ?src Monad
10:29:12 <lambdabot> class  Monad m  where
10:29:12 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
10:29:12 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
10:29:12 <lambdabot>     return      :: a -> m a
10:29:12 <lambdabot>     fail        :: String -> m a
10:29:13 <dmwit> dmwit: Ah.
10:29:25 <dmwit> dmhouse, even
10:29:28 <dmhouse> Hehe.
10:30:16 <eumenides> could the output lag (http://hpaste.org/1319) have something to do with lazyness?
10:31:18 <chessguy> ?src Arrow
10:31:18 <lambdabot> class Arrow a where
10:31:18 <lambdabot>     arr, pure   :: (b -> c) -> a b c
10:31:18 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
10:31:18 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
10:31:18 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
10:31:20 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
10:31:22 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
10:31:32 <hpaste>  roconnor annotated "deriviates" with "optimizer" at http://hpaste.org/1320#a2
10:31:33 <vincenz> eumenides: nethack?
10:31:46 <chessguy> shouldn't (>>>) be called (>>>=), to relate it to (>>=) ?
10:32:01 <eumenides> vincenz: sure if i figure this out :)
10:32:17 <roconnor> Diff> optimizeNear cos 3
10:32:17 <roconnor> 3.141592653589793
10:32:20 <emu> chessguy: but it's not?
10:32:31 <vincenz> eumenides: you could try changing the buffering in stdin and stdout
10:32:32 <Heffalump> chessguy: it's closer to (.) than (>>=)
10:32:42 <emu> look at the parameters
10:32:46 <Heffalump> >>= is kind of the function application of the monad world
10:32:53 <Heffalump> whereas >>> is the function composition of the arrow world
10:32:56 <emu> b c -> c d -> b d .. kinda transitivity
10:33:02 <chessguy> i guess i'm saying >>> is more like >>= than >>
10:33:06 <emu> ?type (.)
10:33:09 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
10:33:09 <Heffalump> that's true, yes
10:33:14 <roconnor> Diff> optimizeNear (\x -> cos x + (fromInteger undefined)) 3
10:33:14 <roconnor> 3.141592653589793
10:33:18 <chessguy> because it doesn't discard the output of the first arrow
10:33:20 <emu> a b, b c, a c
10:33:25 <eumenides> vincenz: i'm not sure if i can do that with hscurses
10:33:27 <chessguy> err, first computation, i guess i should say
10:33:56 <vincenz> eumenides: http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#v%3AhSetBuffering
10:33:58 <lambdabot> http://tinyurl.com/y9dfge
10:34:01 <vincenz> oh
10:34:12 <emu> it should be related to fmap if anything
10:34:54 <glguy> chessguy: however if you look at it from another point of view, >> is much closer to >>> then >>= is, as the arrow doesn't return a value
10:35:47 <glguy> it just has some effect on how the udnerlying plumbing is connected
10:35:54 <vincenz> eumenides: tried ((handle =<< event) >> process >> draw)?
10:36:02 <eumenides> vincenz: yep
10:36:09 <eumenides> vincenz: can i send you the full code?
10:36:27 <vincenz> eumenides: I think it should be that one
10:36:32 <vincenz> eumenides: and then draw should force output
10:36:47 <Heffalump> glguy: but >> throws away data, whereas >>= doesn't
10:36:51 <Heffalump> and neither does >>>
10:37:20 <vincenz> eumenides: @paste the draw code?
10:37:25 <eumenides> vincenz: it's the same as before
10:37:42 <glguy> >>= applies datat as a parameter
10:37:43 <vincenz> eumenides: yes, draw is getting lazified
10:37:50 <glguy> >>> runs data through the plumbing
10:38:07 <eumenides> vincenz: pasting would be difficult (400 lines in 8 files)
10:38:10 <glguy> >> runs data trhough plumbing
10:38:18 <vincenz> eumenides: even for just 'draw'?
10:38:28 <eumenides> vincenz: oh okay
10:38:36 <glguy> >>= is closer to the app function to me
10:38:53 <vincenz> >> combines monads, >>> combines arrows
10:39:34 <Heffalump> I don't understand how laziness could have an observational impact in the IO monad, unless you're using unsafeInterleaveIO.
10:39:46 <vincenz> the data being passed thrrough the plumbing, as glguy says, is only done once you have that result
10:39:49 <hpaste>  eumenides annotated "output lags behind input" with "Graphics.hs" at http://hpaste.org/1319#a1
10:40:35 <vincenz> (like the input for a monad-reader)
10:41:00 * glguy imagines that there is a better word for the abstracted away part of the computation than "plumbing"
10:41:16 <vincenz> glguy: well for State, it's the state :)
10:41:56 <Heffalump> plumbing is a fairly typical word for it
10:42:02 <roconnor> @pl \e -> encodeFloat 1 (fromIntegral $ 1-floatDigits e)
10:42:03 <lambdabot> encodeFloat 1 . fromIntegral . (-) 1 . floatDigits
10:42:09 <eumenides> vincenz: well that's all the graphics code there there is. is there some way to force it?
10:42:19 <roconnor> @pl fix (\e -> encodeFloat 1 (fromIntegral $ 1-floatDigits e))
10:42:19 <lambdabot> fix (encodeFloat 1 . fromIntegral . (-) 1 . floatDigits)
10:42:25 <eumenides> Heffalump: not using anything unsafe*
10:42:25 <roconnor> > fix (encodeFloat 1 . fromIntegral . (-) 1 . floatDigits)
10:42:27 <lambdabot>  2.220446049250313e-16
10:43:10 <vincenz> eumenides: Heffalump makes a good point, maybe it's got something to do with the buffering of curses, but I fear I'm not familiar with that module
10:43:25 <Heffalump> eumenides: you might be indirectly, I guess, but it's unlikely. hGetContents/readFile for example
10:43:27 <vincenz> eumenides: suffice to say that 'draw' should come at the end of your chain, cause your rinit draws alreardy
10:44:27 <vincenz> eumenides: an easy way to test this
10:44:40 <vincenz> eumenides: is: in your event, fake input, but also output it
10:44:42 <vincenz> and see the ordening
10:44:44 <eumenides> vincenz: i want it to draw at the start before the user presses a button though :) plus it really seems to make no difference
10:44:51 <vincenz> eumenides: well init does a draw :)
10:45:01 <vincenz> eumenides: it doesn't except you should get two draws now
10:45:09 <vincenz> before your first input
10:45:10 <eumenides> vincenz: actually it doesn't for some reason
10:45:19 <vincenz> I think that's related
10:45:25 <vincenz> and once you cure the delay, you should get 2 draws
10:45:37 <vincenz> cause init does a draw, and then your forever loop starts with a draw
10:47:24 <vincenz> eumenides: oh!
10:47:25 <vincenz> eumenides: http://compsoc.dur.ac.uk/~sc/hscurses-doc/HSCurses.Curses.html#v%3AintrFlush
10:47:30 <lambdabot> http://tinyurl.com/29nvzy
10:48:06 <eumenides> vincenz: worth a try
10:48:30 <resiak> durham compsoc eh
10:48:40 <eumenides> vincenz: nope
10:48:45 <vincenz> hmm, thought it seems to only handle for interrupts
10:49:49 * resiak wonders if he's met SimonRC.
10:50:34 <vincenz> eumenides: tbh, seems like  buffering issue, but you might want to find a curses-experrt
10:51:48 <lokam> if I return String -> [String], how do I get the [String] into a variable?
10:52:07 <eumenides> vincenz: hm okay
10:52:59 <lokam> or would I have to return a pair?
10:54:15 <lokam> and what's an f Int?
11:01:24 <eumenides> vincenz: Ooh, you have to call Curses.refresh to update the screen
11:02:37 <vincenz> :)
11:04:06 <sjanssen> lokam: if you have a String -> [String], and you want to get a [String] out of it, you need to apply a String to it
11:05:25 <stepcut> sjanssen: I think something might be broken in the latest xmonad. For some reason, Mod+space and Mod+<number> work for me, but Mod+<letter> does not :-/ I am going to investigate more
11:05:36 <vincenz> anyone ever submit a 'bio' for a conf?
11:06:41 <sjanssen> stepcut: I've seen problems with num/scroll/caps lock before, are any of those on?
11:06:57 <dmwit> numlock totally breaks it for me
11:07:19 <dmwit> (Even after I changed lockMask to be the thing reported by xev.)
11:07:29 <stepcut> sjanssen: no, but I did run setxkbmap to change my keyboard layout *after* I started xmonad, which is not the order I ususally do things in
11:07:31 <joelr1> how do you guys debug parsec parsers?
11:07:40 <joelr1> can you print from within the parser?
11:07:46 <sjanssen> stepcut: ahh, I bet that's it
11:08:24 <dylan> joelr1: parsec parsers are made up of little functions. You can write little tests to check those.
11:08:25 <stepcut> sjanssen: though, using the layout that was in effect when xmonad started does not work either
11:08:41 <joelr1> dylan: little tests don't help with stack overflow :D
11:09:03 <sm> joelr1: also, use parsec's error-string argument carefully
11:09:14 <joelr1> sm: ah!
11:09:35 <joelr1> in my case the stack overflow was solved by switching parsers in the choice combinator
11:10:06 <joelr1> i had numCalc, number where numCalc could, obviously include number
11:10:25 <joelr1> making it number, numCalc resolved the issue
11:11:36 <joelr1> it's logical in retrospect but non entirely obvious
11:11:40 <stepcut> sjanssen: ok, I restarted xmonad and all is well :)
11:12:00 <tuxplorer> I had a look at this document http://dafx04.na.infn.it/WebProc/Proc/P_201.pdf
11:12:00 <tuxplorer> This explains performing DSP functions. But are there libraries to handle different audio formats and extract the amplitudes and frequencies in a list?
11:12:31 <tuxplorer> I'm looking at using haskell for audio analysis
11:13:13 <joelr1> now, it appears that i'm still in trouble (damn) because when num is before numCalc then any calculation such as 20 + 40 doesn't work since only 20 is parsed. dammit
11:13:13 <stepcut> tuxplorer: on Linux you can bind to libsndfile pretty easily (for reading audio formats)
11:14:05 <tuxplorer> binding to that file, how should I sample the audio?
11:16:07 <stepcut> tuxplorer: what do you mean by 'sample the audio'? Do you mean record from a mic ?
11:16:32 <fuzan> J may be the most unreadable serious language.
11:18:26 <lokam> what's J?
11:18:37 <tuxplorer> stepcut: no. something like sample function in http://www.speech.kth.se/snack/man/snack2.2/python-man.html
11:18:39 <lambdabot> Title: tkSnack manual v2.2
11:19:31 <fuzan> http://www.jsoftware.com/
11:19:33 <lambdabot> Title: J Home
11:20:27 <sphynx> this language usually have shortests solutions to problems on http://projecteuler.net :)
11:20:29 <lambdabot> Title: Project Euler
11:20:48 <glguy> J can be made to be unreadable, but so can Haskell :)
11:21:00 <glguy> ?pl \f g x y -> f (g x y)
11:21:01 <lambdabot> (.) . (.)
11:21:31 <sphynx> it is easy to program J on PDA though :)]
11:21:34 <glguy> ?pl \f g x y -> g x `f` g y
11:21:35 <lambdabot> join . ((flip . ((.) .)) .) . (.)
11:21:39 <stepcut> tuxplorer: I think that would depend on what functionality libsndfile provides
11:21:41 <glguy> that's the example I wanted :)
11:21:51 <sphynx> cause programs are little usually)
11:23:24 <tuxplorer> stepcut: does libsndfile offer a haskell binding or do I need to use something like HOC?
11:24:22 <fuzan> glguy: heh. J is still more unreadable :)
11:25:24 <stepcut> tuxplorer: I do not think anyone has made libsndfile bindings for Haskell yet
11:26:00 <tuxplorer> ok. Thanks stepcut. Will look into libsndfile and see if I can do with it.
11:27:50 <fuzan> test=.  -.@(0&e.)@,@(2: |~&.]/&3 4 5@".@(,"2)@:(":"0)\ ])
11:27:58 <fuzan> that's a statement in J, it looks like.
11:28:05 <glguy> fuzan: that's only hard to read because you wanted it to be
11:28:14 <glguy> J supports multi line functiosn and variables
11:28:22 <glguy> if you wanted you could make that easy to read
11:28:24 <fuzan> well of course, I havn't learned the syntax.
11:28:53 <glguy> then you should properly qualify your statements: "my J code is "
11:28:57 <glguy> ;)
11:30:07 <dylan> there's the austin thought police to re-educate fuzan about the readability of languages.
11:30:30 <glguy> austin thought police?
11:30:52 <lokam> it's all about the thought police!
11:30:53 <lokam> lol
11:31:08 <sphynx> BTW, there is a cool books about J and using it in chaos theory and fractals generating
11:31:18 <dylan> 14:28 -!- thoughtpolice ...austin......tx........] has joined #haskell
11:31:35 <glguy> ah, an actual nick
11:31:48 <fuzan> :D
11:31:50 <fuzan> J user?
11:32:01 <glguy> I've used J, I'm not a "user"
11:32:30 * dylan has been considering playing with Factor lately. It's hard to read for another reason. :)
11:32:39 <glguy> I'd jump on you if you were spreading lies about Haskell, also
11:32:40 <glguy> ;)
11:33:08 * glguy is an aspiring Factor user as well
11:33:08 <fuzan> I didn't spread any lies. I just said J looks mighty unreadable.
11:33:30 * glguy prepares to defend Factor from dylan ;)
11:33:31 <dylan> I want a prefix stack-based language. :)
11:33:43 <thoughtpolice> if someone doesn't mind, would they look through this little tutorial i wrote and give me any criticisms on it? it's (another) one on the Writer Monad, but it's a first so I'd appreciate any helpful criticism
11:33:49 <dylan> Or, optionally, try writing factor on a right-to-left typing system.
11:34:06 <thoughtpolice> here's the address: http://austin.youareinferior.net/?q=node/22
11:34:09 <lokam> what is an f Int?
11:34:10 <lambdabot> Title: On Haskell: Writing a black-list filter using the Writer Monad | totally insane
11:34:37 <fuzan> glguy: had enough of static typing?
11:34:37 <thoughtpolice> thanks in advance; I also apologize for the messed up code formatting in some spots (drupal + GeSHi)
11:35:01 <fuzan> thoughtpolice: try HsColor
11:35:04 <fuzan> hscolour?
11:35:06 <glguy> fuzan: naw, I generally dispise dynamic typing, but Factor had enough other interesting aspects to make me put my typing issues aside and try it
11:35:11 <glguy> despise*
11:35:23 <thoughtpolice> fuzan: i'll look into it, thanks. geshi is the only filter I've been using
11:36:20 <fuzan> thoughtpolice: hscolour genereats [css,html,ansi,..] from literate haskell sources
11:36:28 <thoughtpolice> fuzan: i found the page
11:36:33 <thoughtpolice> i'll look into it, thanks :)
11:36:52 <Shimei> Does anyone here have an example YiConfig.hs that uses vim bindings by any chance?
11:37:04 <thoughtpolice> i figure a lot of my future little blogs will be on haskell so a good to have a colourizer
11:37:10 <fuzan> I just realized why rightclick wasn't copying.
11:37:13 <fuzan> I'm in windows.
11:37:30 <fuzan> 15 minutes of confusion, thanks to irssi in cygwinn'd irssi.
11:37:43 <fuzan> err,
11:37:50 <fuzan> irssi in cygwinn'd rxvt :D
11:38:20 <potts> Hello all
11:38:31 <potts> I am currently losing a debate with the type checker
11:38:42 <emu> it's a tough customer eh
11:38:55 <potts> I have: to_text :: Char -> String
11:39:08 <potts> to_text x = printf "%02x " x
11:39:17 <potts> packet_split :: String -> String
11:39:43 <potts> packet_split (0x10:0x03:0x10:0x33:0x40:xs) = "</pvt>\r<pvt>" ++ packet_split xs
11:39:43 <potts> packet_split (x:xs) = to_text x ++ packet_split xs
11:39:43 <fuzan> thoughtpolice: I can't quite find your article.
11:40:02 <fuzan> thoughtpolice: Oh, nevermind. I thought the "Make a cabal project.." was a seperate blog post. I kept trying to click on "Go!"
11:40:04 <potts> basically, I want to pattern match on the head of a string for a particular case, but treat the values as numbers
11:40:25 <potts> GHC is griping about no instance of (Num Char)
11:40:41 <potts> "arising from the literal... in the pattern"
11:41:02 <thoughtpolice> fuzan: i'm just ssh'ing to my box :>
11:41:24 <thoughtpolice> that I have active in vmware right next to me, because it's just sooo much more convenient
11:41:54 <potts> I don't know how to tell it that it should trust me that the numbers in the pattern should match Char.
11:42:11 <emu> potts: because Chars are not numbers
11:42:38 <fuzan> gotta run to class, ciao!
11:42:45 <ndm> potts check + vs ++
11:42:52 <emu> i realize you know of an encoding that maps numbers to chars, but ghc is agnostic about that
11:42:59 <potts> Well, to a C programmer they are : )
11:43:03 <lokam> so how do I get the variables returned from something that returns more than one variable? I know I can get one variable using let, so let d = f x, so if it f x returns String -> [String] would I do let d b = f x ? or what ?
11:43:22 <emu> a lot of things C programmers "know" is wrong..
11:43:40 <thedward> > let to_text x = [ chr x ] in to_text 65
11:43:42 <lambdabot>  "A"
11:43:52 <potts> I don't really know what (Num Char) means to the type checker...
11:44:03 <emu> it means it tried to apply a Num operation to Chars
11:44:09 <emu> ?type (+)
11:44:11 <lambdabot> forall a. (Num a) => a -> a -> a
11:44:14 <balodja> @bf ++.
11:44:15 <lambdabot> Plugin `bf' failed with: IRCRaised Data.ByteString.last: empty ByteString
11:44:25 <emu> that means (+) works on any type which is an instance of Num
11:44:39 <lokam> thedward: if that was addressed to me I didn't understand
11:44:40 <emu> > 'a' + 'b'
11:44:41 <lambdabot>   add an instance declaration for (Num Char)
11:44:42 <lambdabot>     In the expression: 'a' + 'b'...
11:44:55 <emu> I tried to instantiate Num a as Num Char, but there is no instance for Num Char.
11:45:06 <thedward> lokam: I was just trying a simpler version of potts' to_text function
11:45:15 <lokam> thedward: .ua discovery
11:46:21 <malcolmw> > fromEnum 'x'
11:46:23 <lambdabot>  120
11:46:29 <thedward> lokam: .ui xu do tavla fo la lojban
11:46:45 <potts> OK
11:46:56 <lokam> go'i.ui
11:47:28 <LeCamarade> @src sequence
11:47:28 <lambdabot> sequence ms = foldr k (return []) ms
11:47:29 <lambdabot>     where
11:47:29 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
11:47:54 <potts> I want an equivalent of a cast operation, or syntax for specifying a char with a hex value like '\0x20' (not legal)
11:48:22 <malcolmw> > '\x20'
11:48:23 <lambdabot>  ' '
11:48:25 <emu> > '\080'
11:48:26 <lambdabot>  'P'
11:48:37 <lokam> .i maTEMci ledu'u do CILre fila.LOJBan.
11:48:40 <emu> > '\x41'
11:48:41 <lambdabot>  'A'
11:48:57 <malcolmw> fromEnum casts from an enumeration (like Char) to Int
11:48:58 <thedward> > chr 0x20
11:48:59 <lambdabot>  ' '
11:49:05 <malcolmw> fromEnum 'P'
11:49:15 <thedward> > ord ' '
11:49:17 <malcolmw> >fromEnum 'P'
11:49:17 <lambdabot>  32
11:49:20 <potts> Does '\080' use octal?
11:49:35 <emu> > fromEnum 'P'
11:49:37 <lambdabot>  80
11:49:38 <int-e> > '\080' == '\80'
11:49:40 <lambdabot>  True
11:49:40 <emu> no, it's decimal
11:49:55 <thedward> lokam: mi go'i .iku'i na xamgu
11:49:58 <potts> OK, that might do it
11:50:10 <malcolmw> > toEnum 80 :: Char
11:50:12 <lambdabot>  'P'
11:50:23 <lokam> .ua.idai
11:50:58 <int-e> > '\o77' -- is this Haskell98?
11:50:59 <lokam> sisisi .uadai
11:51:00 <lambdabot>  '?'
11:51:48 <potts> Type checker seems happy with decimal values in chars
11:52:15 <potts> packet_split ('\16':'\3':'\16':'\51':'\64':xs) = ...
11:52:25 <lokam> so anyone know how I can recieve 2 variables from a function that returns 2 variables?
11:52:55 <potts> Whole program now passes type checker! Yay...
11:53:03 <sjanssen> lokam: the function returns a tuple?
11:53:05 <potts> GHC is a harsh mistress!
11:53:19 <lokam> sjanssen: returns String -> [String]
11:53:27 <lokam> or does it have to return a tuple?
11:53:48 <sjanssen> lokam: that's a function, a function is only one value, not two
11:53:54 <lokam> mul :: String -> [String] -> StdGen -> String -> [String]
11:53:54 <lokam> mul brid' bridil' seCUNs = do
11:54:20 <lokam> so how should I redo the type?
11:54:29 <lokam> or does that return a tuple?
11:54:45 <sjanssen> if you want to return two things: String -> [String] -> StdGen -> (String, [String])
11:55:08 <potts> now the real question is "does the compiled program run in a reasonable time on a 6 meg file"
11:55:46 <potts> my definition of "reasonable" is pretty loose... I only have to run it once, but "finishing before the end of the day" would be good.
11:55:52 <lokam> sjanssen: and how would I extract those now? using fst and snd?
11:56:09 <lokam> or?
11:56:13 <sjanssen> lokam: sure, or pattern match against the tuple
11:56:22 <eumenides> what's the difference between a TVar and TMVar?
11:56:43 <lokam> so could I do let (d , b) = mul brid bridil seCUns
11:56:44 <lokam> ?
11:56:47 <Lemmih> eumenides: TMVar's can be empty.
11:56:50 <Shimei> Is there any documentation on Yi configuration somewhere? I managed to get vim keymaps working, but it took some experimentation. Is there a place to put that kind of information?
11:56:57 <sjanssen> eumenides: TMVar's have an 'empty' state, when you try to read from an empty TMVar the transaction fails
11:57:11 <eumenides> Lemmih, sjanssen: thanks
12:00:22 <sjanssen> lokam: yeah
12:00:23 <potts> Wow, it actually ran pretty fast!
12:00:44 <lokam> I have a type error  Couldn't match `f Int' against `Int' at fst $ (randomR (0, ((length bridil) - 1)) seCUNs)
12:00:53 <lokam> sjanssen: ki'e.i'o thanks appreciation
12:02:08 <lokam> I'm not really sure where the type error is coming from, is it because of length? and how can I fix it?
12:03:53 <chessguy_work> lokam: can you paste your whole code and the whole error message at
12:03:55 <chessguy_work> !paste
12:03:55 <hpaste> Haskell paste bin: http://hpaste.org/
12:06:05 <lokam> whats the command in vim to copy to main buffer?
12:06:42 <chessguy_work> i don't know, that's why i used gedit :)
12:06:51 <lokam> "+y
12:08:01 <hpaste>  Lokam pasted "rir.hs" at http://hpaste.org/1321
12:09:04 <chessguy_work> still need your whole error message
12:09:36 <chessguy_work> what language is this anyway?
12:10:00 <lokam> Lojban
12:11:07 <hpaste>  Lokam annotated "rir.hs" with "(no title)" at http://hpaste.org/1321#a1
12:11:17 <lokam> that's the error message
12:12:43 <sjanssen> @hoogle randomRIO
12:12:44 <lambdabot> Random.randomRIO :: Random a => (a, a) -> IO a
12:13:07 <lokam> I used randomRIO earlier, i wanted to make it a pure function
12:13:35 <sjanssen> it seems the line numbers don't match up?
12:14:08 <lokam> well both errors are pertaining to the mul function
12:14:52 <chessguy_work> you don't even have the mul function definition in the code you pasted
12:16:10 <hpaste>  Lokam annotated "rir.hs" with "(no title)" at http://hpaste.org/1321#a2
12:16:19 <lokam> oops there is the correct version
12:16:27 <hpaste>  chessguy annotated "rir.hs" with "this is one bug" at http://hpaste.org/1321#a3
12:17:11 <chessguy_work> lokam: see http://hpaste.org/1321/diff?old=0&new=3
12:17:36 <potts> A quick question about GHC and the IO monad. If I have a main() that solicits input, when I run it under GHCi I get the output prompt. When I make a compiled .exe I see a blank. Is there a trick to cause a flush of the output in the compiled code?
12:17:51 <chessguy_work> procyon112: hi
12:18:57 <Saizan> ?hoogle hSetBuffering
12:18:58 <lambdabot> IO.hSetBuffering :: Handle -> BufferMode -> IO ()
12:19:12 <procyon112> chessguy: hey there
12:19:27 <chessguy_work> procyon112: how goes it?
12:19:59 <Botje> ?hoogle flush
12:20:00 <lambdabot> GHC.ConsoleHandler.flushConsole :: Handle -> IO ()
12:20:00 <lambdabot> System.Win32.File.flushFileBuffers :: HANDLE -> IO ()
12:20:00 <lambdabot> IO.hFlush :: Handle -> IO ()
12:20:00 <procyon112> chessguy: so... here's what my idea is... I'll hpaste it in pseudocode.
12:20:13 <chessguy_work> procyon112: hpaste what?
12:20:20 <chessguy_work> oh, your idea
12:20:21 <Botje> potts: you could hFlush too, if this is a one-time deal.
12:20:52 <Cheery> Is here the guy who queried me yesterday?
12:21:42 <thedward> @check (\s -> let rot13 = map (\l -> maybe l id ( lookup l ( (\xs -> zip (concat xs) ( concat ( map ( (uncurry $ flip (++)) . (splitAt 13 ) ) xs ) ) ) [ ['a'..'z'], ['A'..'Z'] ] ) ) ) in (rot13 . rot13 ) s == s )
12:21:43 <lokam> chessguy_work: I've already updated parenthesis in the http://hpaste.org/1321#a2 version
12:21:45 <lambdabot>  OK, passed 500 tests.
12:21:47 <Cheery> stepcut: anyways, you are here, check out this
12:22:05 <hpaste>  Cheery pasted "StyleSheetAST" at http://hpaste.org/1322
12:22:13 <stepcut> Cheery: I'll forward that on
12:23:19 <Cheery> stepcut: tell me, do you have better ideas for AST and especially, for optimizing it?
12:23:21 <potts> trying hFlush, that is probably what I want for just a couple of inputs
12:23:58 <potts> ?hoogle Handle
12:23:59 <lambdabot> System.IO.Handle :: data Handle
12:24:00 <lambdabot> Control.Exception.handle :: (Exception -> IO a) -> IO a -> IO a
12:24:00 <lambdabot> System.Win32.Types.HANDLE :: type HANDLE
12:24:18 <Botje> :t stdout
12:24:21 <lambdabot> Not in scope: `stdout'
12:24:29 <Cheery> this thing I pasted, it unions the declarations, therefore minimizing the amount of @media, brackets and rulesets
12:24:56 <stepcut> Cheery: spiffy, I'll have a look at it later
12:24:59 <Cheery> oh, and btw. this one is complete by non-stub -parts, I think, it lacks only comments :)
12:25:10 <Botje> potts: if you import System.IO; you can hFlush stdout
12:26:02 <potts> that's probably what I want... trying it
12:27:05 <potts> looks like that worked, thanks!
12:27:38 <potts> ?hoogle BufferMode
12:27:39 <lambdabot> System.IO.BufferMode :: data BufferMode
12:28:33 <potts> ?hoogle hSetBuffering
12:28:33 <lambdabot> IO.hSetBuffering :: Handle -> BufferMode -> IO ()
12:29:41 <chessguy_work> > length "foo" - 1
12:29:42 <lambdabot>  2
12:30:25 <chessguy_work> lokam: i was wrong, the parentheses aren't necessary
12:30:57 <pcmoritz> hi, is there anyone, who can help me with my attempts to program a double-linked list?
12:31:09 <potts> hSetBuffering stdout NoBuffering also works nicely
12:31:11 <Cheery> stepcut: I'm going to take care of declaration stub tomorrow, the set of declarations supported won't be complete thought
12:31:13 <pcmoritz> here is the code: http://hpaste.org/1323
12:31:35 <pcmoritz> the 'add'-operation doesn't work
12:31:37 <stepcut> Cheery: nice
12:32:18 <pcmoritz> but i don't know, what is wrong :(
12:32:20 <chessguy_work> pcmoritz: "doesn't work" is quite ambiguous
12:32:27 <Cheery> sorry for delaying it so much thought, I just want to get it right
12:32:44 <pcmoritz> yes, the problem is described in the code...
12:33:14 <pcmoritz> http://hpaste.org/1323
12:33:16 <chessguy_work> aha
12:34:49 <pcmoritz> i dont't even know, if the IORef way of solving this works in principle...
12:35:39 <int-e> pcmoritz: err, you can't modify nextPtr and prevPtr of the previous and next node
12:35:49 <int-e> pcmoritz: you have to modify the contents of those IORefs instead
12:35:57 <fberthold> Greetings folks, I'm working on a VPS machine which isn't accurately reporting the available memory.  Is there a way to manually set the max in ghc?
12:36:11 <pcmoritz> oh, i see
12:36:22 <pcmoritz> thx a lot :)
12:38:09 <stepcut> Cheery: bah, we've been delaying it for months ;)
12:38:54 <bringert> fberthold: yes
12:39:53 <bringert> fberthold: +RTS -M240M
12:39:57 <bringert> for example
12:40:15 <bringert> well, that sets the heap size, not the memory used
12:41:34 <fberthold> bringert But that should work to solve the problem, if inderectly, let me give it a try and see.
12:42:13 <dino-> I'm trying to build the latest mkcabal. It has a patch from the last day or so that removes regex-compat from the Build-Depends: in the .cabal file..
12:42:39 <dino-> And I get an error during build: Could not find module `Text.Regex'
12:43:13 <dino-> Anybody know what I need for this?
12:43:32 <fberthold> bringert: Still no luck, the exact error I'm getting is: <interactive>: out of memory (requested 1048576 bytes)
12:43:51 <_Stinger_> you probably need Text.Regex *ducks*
12:43:53 <bringert> fberthold: did you set -M low enough?
12:44:09 <bringert> dino-: try -package regex-compat
12:44:17 <dino-> It's happy when I :m Text.Regex in ghci
12:44:29 <bringert> fberthold: I think GHC could use more that 2x the max heap size
12:44:34 <bringert> for copying GC
12:44:41 <bringert> and the satck, and other stuff
12:44:43 <bringert> stack
12:44:46 <_Stinger_> yeah I was gonna say isnt Text.Regex in the standard ghc libs
12:44:48 <dino-> bringert: I see. Suggesting that this build is dorked now. I mean, I'm using its cabal.
12:45:08 <bringert> dino-: the .cabal file is probably for ghc <= 6.6
12:45:11 <bringert> eh <
12:45:19 <_Stinger_> you need extra stuff for some of the diff backends though I think
12:45:23 <bringert> add regex-compat to build-depends
12:45:33 <dino-> It was just recently changed to remove regex-compat, patched like yesterday.
12:45:41 <dino-> ok
12:47:48 <dino-> Is it that the .cabal file can work for < 6.6 or >= 6.6 but not both at the same time?
12:48:50 <fberthold> bringert: I'm checking it now, I'm new on the system so I'm not sure of my limits.
12:48:52 <hpaste>  Procyon112 pasted "Idea for making polymorphic interface to GPLib" at http://hpaste.org/1324
12:49:10 <procyon112> chessguy: there's the basic outline of what I'm thinking.
12:50:07 <bringert> dino-: yes, unfortunately. once we have cabal configurations, we should be able to handle that situation
12:50:31 <chessguy_work> ok, let's see
12:50:40 <dino-> bringert: ok, thanks
12:52:18 <hpaste>  Saizan annotated "double linked list" with "for pcmoritz" at http://hpaste.org/1323#a1
12:52:30 <chessguy_work> BoundToken is a function?
12:52:52 <glguy> not if it's capitalized :)
12:52:58 <chessguy_work> glguy: that's why i'm confused
12:53:09 <chessguy_work> BoundToken :: (GPDatatype a) => a -> (Int, String)
12:53:17 <procyon112> chessguy: yeah.. it's a function... my bad
12:56:22 <chessguy_work> procyon112: i'm assuming type Forest a = [Tree a]
12:56:52 <fberthold> bringert: Looks like GHC's a bit more than this little system can handle.  Thank you for the information.
12:57:18 <fberthold> bringert++
12:57:30 <bringert> fberthold: are you trying to run GHC itself, or a GHC-compiled program?
12:57:36 <chessguy_work> @pl \x \y -> x +  y
12:57:36 <lambdabot> (line 1, column 4):
12:57:36 <lambdabot> unexpected "\\"
12:57:36 <lambdabot> expecting operator, pattern or "->"
12:57:48 <chessguy_work> @pl \x y -> x +  y
12:57:48 <lambdabot> (+)
12:58:16 <chessguy_work> i'm assuming the latter is what you meant
12:58:16 <fberthold> bringert: I'm working in GHCi at the moment.  Though I've had trouble rebuilding some larger packages with GHC itself.
12:58:59 <bringert> fberthold: I compile my programs on my local machine, and upload binaries to my web account with limited memory
12:59:12 <bringert> statically linked
12:59:59 <chessguy_work> @type \(x:y:_) -> (?eval x) (?eval y)
13:00:01 <lambdabot> [1 of 2] Compiling ShowQ            ( scripts/ShowQ.hs, interpreted )
13:00:01 <lambdabot> [2 of 2] Compiling L                ( L.hs, interpreted )
13:00:01 <lambdabot>  
13:00:08 <resiak> haha!
13:00:12 <fberthold> bringert: Sensible, and may be what I end up having to do, but I got the service intending to use it as my dev environment.
13:00:42 <bringert> hey, whatever happend to that web app framework that shankys and friends were going to release?
13:01:08 <procyon112> chessguy: a Forest, for most intents = [Tree a]..
13:01:16 <chessguy_work> procyon112: ok, i figured
13:01:36 <jcpetruzza> @src Control.Monad.Trans
13:01:36 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
13:01:45 <chessguy_work> procyon112: i don't grok apply though
13:02:40 <procyon112> chessguy: I ran into some typeing issues though with your existing [Gene Datatype]->DataType implementation.  When I switched to an explicit Forest (Gene DataType)->Datatype they went away... so there is some difference to the typechecker.
13:03:15 <jcpetruzza> :help @src
13:03:25 <dmwit> Of course, one is wrapped in a constructor, and the other isn't...
13:03:28 <dmwit> ?help src
13:03:29 <lambdabot> src <id>. Display the implementation of a standard function
13:03:33 <procyon112> chessguy: apply is just ($), but using (x:y:_) from the Data.Tree
13:03:55 * ndm requires dependent types, oh no!
13:04:05 <procyon112> chessguy: That way, the genes can be higher order functions.
13:04:10 <chessguy_work> oh
13:04:17 <ndm> or rather a notion of expressing a function that computes over a type to generate a function at compile time
13:04:55 <int-e> Saizan: you reuse the same IORef in two different list nodes. that will cause trouble later.
13:05:25 <chessguy_work> procyon112: now that's cool
13:05:44 <chessguy_work> i like!
13:06:02 <procyon112> chessguy: and by making eval not map it's sub-lists, and moving the evals to the genes instead, you can do lazy or strict evaluation... the map was forcing strict evaluation.
13:06:40 <lokam> how do i return a tuple?
13:07:01 <chessguy_work> very cool. i really think we need to get a baseline working though before we get too far into this type hackery
13:07:05 <procyon112> chessguy: so, what I need to do now, is to make this work... the general idea is in my head.. mapping my thoughts to *working* Haskell instead of this pseudocode is proving a little difficult ;)
13:07:24 <dmwit> lokam: (a, b)?
13:07:40 <dmwit> > let f x = (x, 2*x) in f 3
13:07:41 <lambdabot>  (3,6)
13:08:09 <procyon112> chessguy: They type hackery is simple, and completed, assuming I can make this concept work to map user defined types to the GPLib.
13:09:38 <procyon112> chessguy: monotype programs will just eliminate the arity param from the gene (since they can be deduced by length childTypes), and making the return and child types all the same.  I might even do a helper function to map directly to save the user some typeing.
13:10:08 <chessguy_work> procyon112: yes, we can supply some helper functions like that in the library
13:10:09 <hpaste>  Lokam annotated "rir.hs" with "complains about returned tuple in mul" at http://hpaste.org/1321#a4
13:11:21 <procyon112> chessguy: I'm also not sure how much a performance hit monotype programs will take by doing everything through typed tree generation... if it's not negligable, I will make your monotype generators available as a config parameter (and likely the default).
13:11:43 <chessguy_work> procyon112: sounds like a good idea
13:14:56 <procyon112> chessguy: Another possibility is that I might be able to get rid of the GPDatatype class altogether, and just make it a requirement that user's datatypes derive Ord and Show... I'm doing alot of experimenting and learning alot about how Haskell deals with abstract data types in the process.
13:15:29 <chessguy_work> sounds really interesting
13:19:17 <hpaste>  int-e annotated "double linked list" with "this should be correct now" at http://hpaste.org/1323#a3
13:21:32 <lokam> Couldn't match `[String]' against `(a, b)'   @  0 -> return (brid, brid : bridil)
13:21:39 <lokam> :(, I can't figure out what to do
13:25:12 <chessguy_work> procyon112: i guess i just don't feel like i can do much until we have something simple working
13:25:48 <dmwit> lokam: more info, please
13:26:11 <Botje> > ((*2) >>= flip (,)) 3
13:26:12 <lambdabot>  (3,6)
13:26:24 <Botje> yay! ((->) r) monad ftw :)
13:26:48 <lokam> dmwit: Lokam annotated "rir.hs" with "complains about returned tuple in mul" at http://hpaste.org/1321#a4
13:29:01 <dmwit> lokam: What monad are you in?
13:29:33 <lokam> I'm in a monad?
13:29:36 <dmwit> (Hint: I don't think you're in a monad at all.)
13:29:38 <lokam> hmmm
13:29:48 <dmwit> lokam: You are using do-notation, which only applies to monads.
13:30:03 <lokam> so can I just remove the do and it will still work?
13:30:33 <lokam> parse error on 'let'
13:30:49 <hpaste>  (anonymous) annotated "rir.hs" with "sans do" at http://hpaste.org/1321#a5
13:31:26 <lokam> ki'esai thanks strongly
13:31:42 <lokam> :)
13:31:51 <dmwit> lokam: No, you can't just remove the do.  Hold on a second, I'm talking to my roommate.
13:32:35 <lokam> kk
13:34:55 <balodja> > unsafeEval_ "show 1" ["Prelude"] [] [] []
13:34:56 <lambdabot>   Not in scope: `unsafeEval_'
13:35:23 <balodja> ok, ghc shows following:
13:35:25 <balodja> Left ["load: couldn't find symbol <<resource>>"]
13:35:42 <balodja> what's wrong?
13:38:23 <hpaste>  Lokam annotated "rir.hs" with "Couldn't match `StdGen' against `(a, b, c)'" at http://hpaste.org/1321#a6
13:43:35 <dmwit> lokam: Just remove your "return"s and you'll be fine.
13:43:44 <dmwit> return doesn't mean the same thing in Haskell as it does in other languages.
13:43:49 <dmwit> It is only useful from within a monad.
13:44:07 <dmwit> Outside a monad, you just write an equation, with the right-hand side being the value that should be "returned".
13:45:22 <lokam> hmm
13:45:41 <lokam> .ua discovery
13:45:53 <dmwit> Was that a sufficiently mysterious explanation? ;-)
13:46:18 <nn-away> Samb, You here
13:47:33 <sphynx> lokam, I wonder what is a language is in your source? I mean "casnu", "tcidu", etc.
13:47:49 <dmwit> I'm going to go with that logical language.
13:48:29 <gvdm_other> lokam: xu do baupli la lojban
13:48:59 <chessguy_work> who in the world writes comments and variable names in lojban...
13:49:07 <procyon112> lol
13:49:40 <procyon112> chessguy: I guess that would make comments easier to parse and verify programmatically :)
13:49:49 <chessguy_work> heh
13:50:08 <lokam> the functions are actually valid lojban :D
13:50:23 <lokam> mul is shortcut for casnu, which takes 3 arguments,
13:50:48 <procyon112> executable spoken language :)
13:51:04 <lokam> er CUNso not CASnu
13:51:05 <lokam>  x1 is random/fortuitous/unpredictable under conditions
13:51:05 <lokam>                     x2, with probability distribution x3
13:51:17 <sphynx> hehe, intersting
13:51:38 <chessguy_work> i consider myself a pretty geeky guy, but....this puts me to shame
13:51:40 <hpaste>  Lokam annotated "rir.hs" with "No instance for (Random (a, StdGen))" at http://hpaste.org/1321#a7
13:51:54 <lokam> :(
13:52:01 <lokam> lol
13:52:21 <procyon112> "The other day I tried to say "fix fix" in lojban and couldn't stop talking until my stack blew!  Thank God I never learned the tail recursive way to say it!"
13:52:41 <chessguy_work> procyon112: where's that from?
13:52:55 <procyon112> I just made it up :)
13:52:58 <dmwit> :t randomR
13:53:01 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
13:53:10 <chessguy_work> ?remember procyon112 The other day I tried to say "fix fix" in lojban and couldn't stop talking until my stack blew!  Thank God I never learned the tail recursive way to say it!
13:53:11 <lambdabot> Done.
13:53:21 <hpaste>  eumenides annotated "output lags behind input" with "arghhh" at http://hpaste.org/1319#a4
13:53:34 <dmwit> lokam: Either unpack the tuple, or use accessors like fst/snd, but not both.
13:53:39 <eumenides> could someone point out what i'm doing wrong? ^
13:53:54 <eumenides> it must be something obvious since i get such a huge error, but i just can't see it
13:54:41 <lokam> dmwit: :D type safe! :D
13:54:59 <chessguy_work> eumenides: most of the error is just repeating itself
13:56:03 <lokam> dmwit: added you to credits :)
13:56:08 <dmwit> heh
13:56:38 <dmwit> > 5*3*2*3*9*8*7
13:56:40 <eumenides> chessguy_work: i don't know what it wants :( why would es' have to be (R b)?
13:56:40 <lambdabot>  45360
13:57:15 <dmwit> > 5*2*3*9*8*7
13:57:16 <lambdabot>  15120
13:57:53 <procyon112> lol:  Charles Simonyi just left for the international space station... Hungarian Notation has now officially left the planet to infect the rest of the universe.
13:58:04 <chessguy_work> eumenides: you don't even give type signatures for half the things in this function? how are we supposed to know where the bug is?
13:59:08 <chessguy_work> e.g., we don't know what levels, position, walkable, or tileP are, for starters
13:59:33 <chessguy_work> @type randomIO
13:59:35 <lambdabot> forall a. (Random a) => IO a
14:00:59 <eumenides> chessguy_work: hm. it'd be kind of hard to explain too. maybe i should just begin anew
14:01:30 <chessguy_work> it looks like you already have quite a bit done. starting over is a bit extreme
14:01:42 <chessguy_work> can you just paste type signatures of those functions?
14:01:50 <chessguy_work> and maybe give some idea of what R is?
14:01:54 <eumenides> chessguy_work: i mean that function. i'll break it down into two or three
14:02:23 <eumenides> chessguy_work: R a = StateT GS IO a, where GS is some complex structure
14:02:35 <chessguy_work> ok, that's not bad
14:03:26 <chessguy_work> better variable names would help a lot
14:03:27 * glguy sets about a plan to kill all of the authors that cite articles that can only be had through a subscription
14:03:56 * chessguy_work gets glguy's back
14:04:28 <glguy> and it might cause a huge loss in productivity, but I don't mind because all of that productivity is locked away where I can't get at it
14:04:53 <kc5tja> /clear/clear
14:05:50 <malcolmw> glguy: someone once invented the idea of a physical storage location where one could go and look at copies of articles on paper.  now what was it called...  oh yes, a library.
14:06:07 <glguy> malcolmw: then the 50s came
14:06:15 <chessguy_work> eumenides: ohh, i see what you're doing
14:06:22 <chessguy_work> now let me figure out why it's broken
14:06:38 <malcolmw> glguy: you are even allowed to look at articles that have copyright restrictions!
14:07:21 <glguy> cool, if I want to look at articles before the onsite of "technology" I'll know where to go
14:07:25 <malcolmw> for free!
14:07:26 <glguy> onset*
14:08:21 <chessguy_work> eumenides: don't you want let es = enemies gs
14:08:37 <chessguy_work> instead of es <- gets enemies
14:08:43 <malcolmw> I've even heard that some obscure institutions called university still have such places, and maintain them by adding new articles
14:09:04 <malcolmw> why, mine even contains the Haskell 98 Report!
14:09:06 <glguy> And there are all the people that live outside of the "university"
14:09:15 <dcoutts> vincenz: it did say that we were allowed to use all our normal ways of advertising our paper
14:09:16 <glguy> once you leave it you find this whole other world
14:09:25 <eumenides> chessguy_work: isn't that the same?
14:09:31 <chessguy_work> eumenides: i'm not sure
14:09:43 <eumenides> chessguy_work: yup. same error
14:10:02 <vincenz> dcoutts: oic
14:10:13 <vincenz> dcoutts: I know that in my context, the TPC might not be too happy
14:10:19 <vincenz> dcoutts: I guess because it's a recent transition/
14:10:24 <dcoutts> "Feel free to put your submission on your web page, give talks about the work, and whatever else you normally do to disseminate it."
14:10:34 <malcolmw> glguy: most will provide access to outside people
14:10:35 <dcoutts> so we take them at their word
14:10:38 <vincenz> dcoutts: that's quite nice :)
14:10:56 <dcoutts> vincenz: they're doing a very light touch double blind thing
14:11:05 * vincenz nods
14:11:11 <vincenz> I wish they'd do that forr us
14:11:19 <dcoutts> vincenz: they only just agreed to try it since many people think it's too excessive
14:11:42 <vincenz> dcoutts: it's defacto in most of IEEE
14:11:45 <malcolmw> glguy: but I admit it is several orders of magnitude slower to get hold of stuff that way than online
14:11:54 <vincenz> dcoutts: as well as EE related ACM's
14:12:00 <dcoutts> aye
14:12:18 <hpaste>  chessguy annotated "output lags behind input" with "try something like this" at http://hpaste.org/1319#a5
14:12:24 <vincenz> btw, I have fusion for c++ :)
14:12:51 <dcoutts> vincenz: oh yes? :-)
14:12:53 <vincenz> yep
14:12:59 <chessguy_work> @type modify
14:13:02 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
14:13:05 <dcoutts> with lots of funky templates? :-)
14:13:10 <vincenz> the first paper ris still a bit rough and pragmatic, but currerntly writing a second paper that uaomtates it
14:13:15 <vincenz> dcoutts: no, no funky stuff, starting from STL
14:13:26 <vincenz> it's a precompiler-trafo
14:13:34 <dcoutts> ah right
14:13:37 <dcoutts> great
14:13:38 <chessguy_work> err, i think that's wrong
14:13:59 <dcoutts> STL is the best aspect of C++ imho
14:14:08 <vincenz> dcoutts: and now it's even better ;)
14:14:17 <dcoutts> yay :-)
14:14:20 <vincenz> the nice thing is that the second paper, which will formalize it
14:14:23 <vincenz> subsumes fusion for lists
14:14:56 <vincenz> have any idea how you get one of those boxes at the top of a page that spans 2 columns?
14:15:00 <dcoutts> that's the way we did it too, we came up with this general system and then applied it to lists
14:15:09 <dcoutts> vincenz: figure*
14:15:16 <vincenz> even for text?
14:15:36 <dcoutts> what do you mean exactly?
14:15:36 <eumenides> chessguy_work: the error's a bit different (after adding another paren), but it doesn't look any more promising
14:15:55 <vincenz> dcoutts: you know how in pl-sem pages they sometimes span the 2 columns with a box that has the sem-rules inside?
14:16:03 <vincenz> s/pages/papers
14:16:22 <dcoutts> vincenz: right, I used \begin{figure*}
14:16:26 <vincenz> thx
14:16:55 <dcoutts> vincenz: is your first paper published / online ?
14:16:58 <vincenz> yes
14:17:03 <vincenz> warning, somewhat adhoc
14:17:06 <vali> hello. do i have to declare types in Haskell, such as int, float etc?
14:17:08 <LeCamarade> @src sequence
14:17:08 <vincenz> cause c++ is uglier to deal with :/
14:17:08 <lambdabot> sequence ms = foldr k (return []) ms
14:17:08 <lambdabot>     where
14:17:08 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
14:17:15 <dmwit> Hi vali!
14:17:20 <dcoutts> vincenz: sure
14:17:22 <vali> dmwit: hello
14:17:25 <dmwit> Nope, the compiler can usually figure it out on its own.
14:17:26 <vincenz> dcoutts: http://homes.esat.kuleuven.be/~cpoucet/papers.html
14:17:29 <lambdabot> Title: publications
14:17:36 <chessguy_work> eumenides: ok, well you're better off rewriting the function anyway, it's too unwieldy as is
14:17:53 <astrolabe> vali: no you don't usually have to, but sometimes it helps
14:18:19 <vincenz> dcoutts: first one
14:18:27 * dcoutts reads
14:19:36 <vincenz> dcoutts: how do you position stuff inside that figure?
14:19:45 <eumenides> chessguy_work: it's troublesome, carrying about all that state :/
14:19:46 <vali> dmwit: ah, it's like lisp/python then? also, does Haskell have something similar to Lisp's macros?
14:19:55 <dcoutts> vincenz: you can try \centering and that kind of thing
14:20:03 <dmwit> vali: Not quite the same; it is still statically typed, but there is type inference.
14:20:12 <alpheus> Hello.  I want to learn Haskell, so I plan to (mostly) lurk here.  Are newbie questions on-topic?
14:20:17 <Heffalump> alpheus: yes
14:20:18 <dmwit> vali: And no, there are no macors (but I haven't missed them yet).
14:20:28 <dmwit> s/macors/macros
14:20:31 <chessguy_work> alpheus: most definitely
14:20:41 <alpheus> great, thanks
14:21:02 <Heffalump> I don't really frequent other freenode channels, but apparently we're much friendlier than most.
14:21:25 <chessguy_work> i'm one of the top 10 chatters in the channel, and i mostly ask newbie questions :)
14:21:39 * glguy figures out how to defeat google books "pages not included in this preview"
14:21:44 <Heffalump> where are the stats these days?
14:21:48 <dmwit> ?lusers
14:21:49 <lambdabot> Maximum users seen in #haskell: 336, currently: 310 (92.3%), active: 43 (13.9%)
14:21:50 <chessguy_work> ?where stats
14:21:50 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
14:21:52 <dcoutts> vali: macros seem to be rarely needed, people build 'domain specific embedded languages' in Haskell quite well without them. Partly this is due to the fact that Haskell has laziness.
14:21:56 <LeCamarade> #haskell is friendly, because (I think) the hierarchy is respected. Kinda.
14:22:11 <Heffalump> see, now I'm a newbie :-)
14:22:13 <dmwit> LeCamarade: What do you mean?
14:22:17 <dcoutts> vali: there is Template Haskell however for compile-time meta-programming
14:22:38 <alpheus> using ghci, this, from a tutorial seems not to return: read "5" + 3
14:22:56 <chessguy_work> > read "5" + 3
14:22:58 <lambdabot>  8
14:23:00 * Heffalump isn't even in the "didn't make it to the top" list for this year :-/
14:23:11 <vali> dcoutts: aah, i see
14:23:19 <LeCamarade> dmwit: Well, try #ubuntu. Everyone is trying to say something. Over here, some ask, some answer, some listen. It helps make it calm and ready to help.
14:23:29 <Heffalump> though I'm still 11th in the all-time list
14:23:36 <dmwit> LeCamarade: Ah, I see.
14:25:28 <dcoutts> vincenz: I'd say that fusion and deforestation are the same thing really, one is not an advanced form of the other
14:25:31 <alpheus> hmm, maybe the read problem is really an emacs problem.  works fine in ghci running in a terminal
14:25:41 <chessguy_work> eumenides: you're probably missing some kind of higher-level abstraction, but i'm not sure
14:27:05 <cpfr> howdy
14:27:07 <vincenz> dcoutts: oh, thanks
14:27:16 <ptolomy> hmmm... so I don't like 'read' dying and killing my program, so I made a wrapper on read that uses unsafePerformIO, catch, and readIO to be '(Read a) => String -> Maybe a'. Is there a better way of going about this that doesn't involve parsec?
14:27:18 <cpfr> is there anything in haskell equivalent to the ocamlbrowser
14:27:26 <dmwit> hackage, maybe?
14:27:30 <dmwit> I'm not familiar with ocamlbrowser
14:27:33 <dmwit> or hoogle?
14:27:33 <chessguy_work> eumenides: if you can create a darcs repo somewhere, or email it to me, i could take a look at the whole program later tonight
14:27:38 <sjanssen> ptolomy: wow, that's really overkill
14:27:43 <ptolomy> dmwit: Like a smalltalk browser.
14:27:43 <sjanssen> @hoogle reads
14:27:44 <lambdabot> Prelude.reads :: Read a => ReadS a
14:27:44 <lambdabot> Prelude.ReadS :: type ReadS a
14:27:44 <lambdabot> Prelude.readsPrec :: Read a => Int -> ReadS a
14:27:50 <dcoutts> vincenz: sounds like we take a similar approach, using iterators/streams to represent concrete data structures
14:27:58 <eumenides> chessguy_work: darcs repo would be difficult, but i'd be glad to email it to you
14:28:22 <chessguy_work> just sent you my email address
14:28:35 <cpfr> ptolomy, got any ideas
14:28:43 <sjanssen> @type \s -> case reads s of {[(x, "")] -> Just x; _ -> Nothing} -- much simpler, ptolomy
14:28:46 <lambdabot> forall a. (Read a) => String -> Maybe a
14:29:03 <vincenz> dcoutts: indeed :)
14:29:17 <vincenz> dcoutts: the difficulty wrt stl is stuff like 'insert' which is not an anamorphism
14:29:23 <dcoutts> right
14:29:26 <vincenz> dcoutts: lists tend to be create append-only
14:29:28 <ptolomy> sjanssen: (Shameful question) that is probably a fair bit slower than the ugly IO approach, what with being a backtracking parser, yes?
14:29:39 <vincenz> hence I use a 'pull' technique
14:29:45 <sjanssen> > let maybeRead s = case reads s of {[(x, "")] -> Just x; _ -> Nothing} in maybeRead "asdf" :: Int
14:29:47 <lambdabot>  Couldn't match expected type `Int' against inferred type `Maybe a'
14:29:48 <dcoutts> vincenz: yes
14:29:50 <ptolomy> cpfr: No equivalent that I know of. Hoogle does it for me.
14:30:05 <cpfr> yeah but hoogle is online
14:30:11 <cpfr> and kinda out of the way
14:30:11 <sjanssen> ptolomy: no, reads is the same or faster than the exception approach
14:30:16 <dcoutts> vincenz: yeah, you're simulating laziness. That's the same as what we did for ByteStrings
14:30:19 <sjanssen> @src read
14:30:20 <lambdabot> read s = either error id (readEither s)
14:30:21 <ptolomy> sjanssen: Oh. Sweet. thanks. :)
14:30:33 <dmwit> > let maybeRead s = case reads s of {[(x, "")] -> Just x; _ -> Nothing} in maybeRead "asdf" :: Maybe Int
14:30:35 <lambdabot>  Nothing
14:30:40 <sjanssen> ptolomy: ^^^ perhaps that is enlightening?
14:30:45 <vincenz> dcoutts: what bibtex?
14:30:46 <dmwit> Huh, that's pretty neat!
14:30:54 <sjanssen> @src readEither
14:30:55 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
14:31:06 <chessguy_work> ?quote not.yet
14:31:07 <lambdabot> dons says: [lambdabot]  Source not found. Your mind just hasn't been the same since the electro-shock, has it? [dons] not yet
14:31:07 <dcoutts> vincenz: the bytestring paper or the stream fusion one ?
14:31:11 <ptolomy> cpfr: http://www.haskell.org/haskellwiki/Hoogle
14:31:13 <lambdabot> Title: Hoogle - HaskellWiki
14:31:15 <ptolomy> Not just online.
14:31:26 <vincenz> dcoutts: the one re simulating laziness
14:31:55 <dcoutts> vincenz: hmm, we don't discuss that explicitly in the ByteString paper
14:32:04 <vincenz> o
14:32:31 <dcoutts> vincenz: my point is that we're using streams to model strict arrays (ByteStrings) when really streams/iterators model lazy lists most accurately
14:33:10 <vincenz> yep, I do the same for stl-containers
14:33:14 <dcoutts> vincenz: so by transforming to iterator/stream style we're actually making it lazier
14:33:42 <vali> what tutorial would you recommend for someone with no background in functional programming?
14:34:01 <dmwit> ?where yaht
14:34:01 <chessguy_work> vali: depends what other background you have
14:34:02 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
14:34:18 <vali> chessguy_work: C, python, java
14:34:37 <vali> dmwit: thank you
14:34:39 <dcoutts> vali: or if you're looking for a book, I quite like 'Programming in Haskell' which was recently published.
14:34:47 <chessguy_work> vali: http://www.haskell.org/haskellwiki/Meta-tutorial
14:34:48 <lambdabot> Title: Meta-tutorial - HaskellWiki
14:35:07 <dmwit> Actually, I learned from the Gentle Introduction, and still return to it now when I'm confused.
14:35:45 <dcoutts> dmwit: I thought the 'gentle' intro was only so if you already knew category theory and domain theory ;-)
14:35:49 <astrolabe> The gentle introduction isn't that gentle in my opinion
14:36:01 <dmwit> dcoutts: Oh, I'm not claiming it's gentle.  But it *is* pretty damn good.
14:36:20 <ptolomy> I found Ocaml to be a pretty gentle intro.. followed that with Gentle Intro and some code.
14:36:32 <ptolomy> that may be round-about, though.
14:40:48 <eumenides> chessguy_work: i've figured it out hooray! well, except for the fact that they now seem to multiply every turn, but hey it runs!
14:41:31 <chessguy_work> well, feel free to email it to me if you're interested in trying to figure out how to refactor it
14:42:19 <eumenides> chessguy_work: okay. working on it atm though. i'll send it when i stop
14:44:31 <chessguy_work> ok cool
14:45:08 <chessguy_work> i'd be interested to play with your code, a curses-based 2d game could be fun
14:45:23 <chessguy_work> especially with good AI
14:48:44 <eumenides> chessguy_work: i'm trying to make a toy roguelike
14:49:03 <eumenides> chessguy_work: i predict a long journey :)
14:49:51 <chessguy_work> hmm, never played it
14:50:30 <chessguy_work> looks like fun
14:51:13 <eumenides> chessguy_work: yep. mine will save save/load though. in fact, it already has :)
14:51:24 <glguy> man... if you thought that learning Haskell made programming in other languages suck, imagine how getting a Haskell job makes your last month at your C# job
14:51:44 <chessguy_work> of course, the more you build into it, the harder it's going to be to refactor
14:52:09 <chessguy_work> glguy: what kind of haskell job did you get?
14:52:41 <glguy> one working on syntaxninja's project
14:53:05 <chessguy_work> hmm. link?
14:53:12 <glguy> http://www.galois.com
14:53:15 <lambdabot> Title: Galois Connections, Inc.
14:53:34 <chessguy_work> ah, at galois. congrats, that's a good job to land
14:54:07 <glguy> thnx
14:54:41 <glguy> Did you get the job you were interviewing for at Aetion?
14:55:08 <chessguy_work> not quite. there was another candidate who had a little bit more experience. they wanted to hire us both but couldn't afford it
14:55:26 <chessguy_work> they're going to keep me on the short list for the future though
14:55:50 <glguy> Do you have other interviews in mind?
14:56:03 <chessguy_work> not really. everything else seems...boring
14:56:10 <chessguy_work> but i do need to find something
14:56:52 <TomMD> glguy: Whats syntaxninja's project?
14:57:17 <glguy> http://galois.com/xdomain.php -- it has to do with this
14:57:18 <lambdabot> Title: Cross Domain Collaboration
14:57:32 <chessguy_work> chances are he can't give a lot of details
14:57:43 <glguy> I don't know what details I can give, but that page is public
14:57:44 <TomMD> Humm, ok
14:57:55 <TomMD> Thats fine - thanks for the link.
14:58:06 <glguy> I'll probably have a better idea once I start :)
14:58:16 <chessguy_work> at least you hope :)
14:59:02 <chessguy_work> ok, time to get out of here.
14:59:50 <TomMD> When do you start?
15:00:47 <glguy> after I get married and finish up stuff in st louis
15:01:12 <TomMD> Well - good work on all fronts!
15:01:20 <glguy> my time at work is when I get to relax, its once  Iget home that everything gets busy :)
15:01:24 <glguy> thnx
15:04:23 <sorear> hello.
15:05:37 <stepcut> hello.
15:09:09 <sorear> @seen
15:11:46 <sorear> Ouch...
15:11:46 <sorear> coc> [x : [a:*0] a] x
15:11:46 <sorear> [a : *0] a
15:15:25 <TomMD> I've seen glguy, stepcut, sorear, and chessguy_work
15:15:36 <sorear> So have I.
15:15:40 <TomMD> :-)
15:15:43 <sorear> type @seen
15:15:44 <emu> nobody knows the trouble i've @seen
15:15:59 <sorear> is anyone here an expert in the CoC?
15:16:11 <TomMD> I don't even know what that tla stands for.
15:16:17 <dmwit> ?go CoC
15:16:20 <lambdabot> http://www.coc.com/
15:16:20 <lambdabot> Title: Official COC site
15:16:39 <dmwit> Somehow, I don't think that's what he's talking about. =P
15:16:59 <TomMD> Yeah
15:17:06 <stepcut> I think the 'o' stands for 'of', not sure about the rest
15:17:09 <TomMD> ?where coc
15:17:10 <lambdabot> I know nothing about coc.
15:17:25 <sorear> Calculus of constructions.
15:17:27 <dmwit> stepcut: Is it possible that it is "Center on Cell"?
15:17:39 <sorear> it's a dependantly typed programming language.
15:17:57 <dmwit> Ok, google is nicer now.
15:18:09 <sorear> it's also strongly normalizing, which means it is impossible to write fix
15:19:22 <dmwit> Bah, I need xmonad to have some indication of which window has focus.
15:19:30 <dmwit> Is it still in feature-freeze?
15:20:16 <stepcut> dmwit: on my system, xmonad draws a red border around the focused window...
15:20:34 <stepcut> dmwit: and has for a week or two
15:20:37 <dmwit> !
15:20:40 <dmwit> Mine doesn't!
15:20:40 <dmwit> =(
15:20:58 <sjanssen> dmwit: when was the last time you upgraded?
15:21:20 <dmwit> Correction: I can now see a (very faint) red border around unfocused windows and a black one around focused windows.
15:21:54 <stepcut> dmwit: I have noticed the the border is always appear to be the same size and clarity, depends on the application I thin
15:22:10 <dmwit> But this border is not visible on workspaces for which there is only one window visible.
15:22:23 <dmwit> If two workspaces are visible...
15:22:32 <stepcut> for me, in fullscreen mode, there is a border around emacs, but not konqueror
15:22:53 <stepcut> actually, for me, non-kde apps have a border is fullscreen mode
15:22:55 <sjanssen> dmwit: I can still see a border in fullscreen
15:22:56 <emu> i was confusing coc with coq
15:23:40 <dmwit> I'll have a look for a parameter to make it more than one pixel wide.
15:23:43 <stepcut> dmwit: actually kde apps don't ever seem to have a border for me
15:23:43 <dmwit> Thanks for the tip, guys!
15:24:42 <sorear> emu: there is not as much difference as one might think :)
15:29:33 <dmwit> > let rot :: (Enum a) => a -> a; rot x = toEnum $ mod (fromEnum x + 1) (maxBound :: a) in rot True
15:29:34 <lambdabot>   add (Bounded a) to the expected type of an expression
15:29:34 <lambdabot>     In the expression...
15:29:43 <dmwit> > let rot :: (Bounded a, Enum a) => a -> a; rot x = toEnum $ mod (fromEnum x + 1) (maxBound :: a) in rot True
15:29:44 <lambdabot>   add (Bounded a) to the expected type of an expression
15:29:44 <lambdabot>     In the expression...
15:31:59 <sorear> @ty let rot a | a == maxBound = minBound | True = succ a in rot
15:32:01 <lambdabot> forall a. (Eq a, Bounded a, Enum a) => a -> a
15:33:19 <dmwit> ?ty let rot maxBound = minBound in rot -- can you use a variable in pattern matching?
15:33:21 <lambdabot> forall t a. (Bounded a) => t -> a
15:33:42 <dmwit> > let rot maxBound = minBound; rot a = succ a in rot True
15:33:43 <lambdabot>      Warning: Pattern match(es) are overlapped
15:33:43 <lambdabot>              In the definition...
15:34:09 <dmwit> o
15:38:25 <Igloo> Does anyone know if I can get more info from happy than just how many reduce/reduce conflicts there are?
15:38:30 <balodja> @info lockAndWrite
15:38:30 <lambdabot> lockAndWrite
15:38:37 <balodja> :t lockAndWrite
15:38:40 <lambdabot> Not in scope: `lockAndWrite'
15:39:35 <Lemmih> Igloo: happy --info=info.txt?
15:40:27 <sorear> mattam: still around?  my CoC checker from yesterday is spewing absurdities
15:41:45 <mattam> hehe
15:42:22 <sorear> I've managed to prove [x : *0] x
15:42:29 <sorear> aka forall x : Type, x
15:42:42 <mattam> I saw the previous bug, didn't understand it though
15:42:44 <Igloo> Lemmih: Ah, I'd missed that! Thanks
15:43:22 <sorear> what rule should be rejecting forall x : (forall a : Type, a), x?
15:43:40 <sorear> that's the term that is bogosly types
15:44:07 <sorear> coqtop rejects it with something that sounds very arbitrary
15:45:20 <sorear> to type "forall x : (forall a : Type, a), x" I assume x has type "forall a : Type, a" and type x - I believe this is the typing rule for forall
15:45:37 <sorear> apparently I'm missing a side condition or something :(
15:45:53 <mattam> yep, there are conditions on sorts
15:46:44 <sorear> sorts? *blank stare*  Is that anything to do with universe numbers?
15:46:57 <mattam> Sorts are Type,Set,Prop
15:47:06 <mattam> yes
15:47:44 <mattam> The conditions on sorts mostly define the various type theories
15:48:07 <sorear> I only have [ *k | k <- [0..] ]... What type theory have I defined? :(
15:48:17 <mattam> Barendregt designed Pure Type Systems to study exactly that
15:49:03 <mattam> The conditions are on which products/foralls and sums/sigma types can be formed
15:50:43 <mattam> If you give s1 to the sort of the domain type, s2 to the sort of the codomain type and s3 for the sort of the product, you can parameterize the typing rule for products by a relation giving s1,s2,s3 tuples
15:51:34 <mattam> In coq you have (Type,Prop,Prop) for example, which give you impredicate propositions.
15:52:13 <mattam> Usually when you have universes you use (Type(i),Type(j),Type(max i j))
15:52:26 <Saizan> ?hoogle toList
15:52:26 <lambdabot> Data.HashTable.toList :: HashTable key val -> IO [(key, val)]
15:52:27 <lambdabot> Data.IntMap.toList :: IntMap a -> [(Key, a)]
15:52:27 <lambdabot> Data.IntSet.toList :: IntSet -> [Int]
15:52:40 <mattam> Is that making any sense sorear ?
15:54:13 <chessguy> 'evening
15:54:34 <TomMD> Welcome back chessguy
15:54:40 <TomMD> That didn't take you long to leave work.
15:54:45 <chessguy> why thank you
15:55:02 <chessguy> ?seen chessguy_work
15:55:03 <lambdabot> I saw chessguy_work leaving #haskell and #haskell-overflow 55m 57s ago, and .
15:55:30 <TomMD> lambdabot: Learn better English
15:55:35 <sorear> mattam: yes, a little :)
15:56:43 <chessguy> hiya sorear
15:57:04 <sorear> mattam: what is the difference between the codomain and a product?
15:57:16 <Saizan> is there some way to make ''[] work in -fth ?
15:57:21 <sorear> no!
15:57:33 <sorear> '' means you are going to give a TYPE
15:57:35 <mattam> the codomain is the result type, the domain the argument's type
15:57:39 <sorear> oh wait, [] is a type.
15:57:40 <sorear> nm
15:57:44 <Saizan> heh :D
15:58:05 <sorear> mattam: what's the 'sort of the product'?
15:58:06 <Saizan> it complains that i'm giving it a data constructor, however
15:58:17 <mattam> it's type
15:58:35 <mattam> the type of a product is always a sort
15:58:48 <mattam> e.g. it can't be another product
15:58:52 <sorear> Saizan: you might be able to fool it with 'type List = [] ; ''List'
15:59:05 <sorear> mattam: so a Sort is term of the form *k?
15:59:41 <mattam> yes
15:59:42 <sorear> mattam: |~| argname : codomain -> result
15:59:58 <sorear> "sort of the codomain" = typeof(typeof(codomain))
16:00:03 <sorear> grr.
16:00:08 <sorear> mattam: |~| argname : domain -> result
16:00:13 <sorear> "sort of the codomain" = typeof(typeof(result))
16:00:29 <sorear> "sort of the domain" = typeof(domain)
16:00:37 <sorear> "sort of the product" = ???
16:00:51 <chessguy> ?where curses
16:00:51 <lambdabot> I know nothing about curses.
16:00:57 <Igloo> Saizan: Works for me
16:00:59 <chessguy> boo
16:01:00 <mattam> forall x : (domtype : domsort), y : (codomtype : codomsort)
16:01:05 <chessguy> @go haskell curses
16:01:16 <Saizan> Igloo: ''[]?
16:01:19 <lambdabot> http://web.comlab.ox.ac.uk/oucl/work/ian.lynagh/papers/Template_Haskell-A_Report_From_The_Field.ps
16:01:22 <Igloo> Saizan: Yup
16:01:27 <chessguy> bah
16:01:41 <Saizan> Igloo, which version?
16:01:45 <chessguy> ?where hscurses
16:01:46 <lambdabot> http://www.informatik.uni-freiburg.de/~wehr/haskell/
16:01:48 <Igloo> Saizan: 6.6
16:02:14 <sorear> mattam: what is the product sort, then?
16:02:27 <mattam> and now (forall x : domtype, y) is of type/sort some function (in general a relation)  of domsort and codomsort
16:02:40 <sorear> oh.
16:03:23 <mattam> lamda is typed by a product with is typed by a sort
16:03:29 <Saizan> oh, i was reading bad the error message, it' complains that [] is used as a type in the generated code
16:03:38 <sorear> so I can't just have typeof :: Term -> Term?
16:04:21 <mattam> you can if you have sorts in terms
16:04:25 <sorear> yeah, I can type lambdas just fine.  but kinding pies causes trouble
16:04:26 <mattam> as you should
16:04:43 <sorear> "if you have sorts in terms"
16:04:54 <sorear> I have the Star k constructor in my term type
16:04:59 <sorear> if that's what you meant
16:05:09 <mattam> yes
16:05:38 <mattam> What's the problem then ?
16:05:45 <sorear> <mattam> and now (forall x : domtype, y) is of type/sort some function (in general a relation)  of domsort and codomsort
16:05:55 <sorear> my typechecker only returns types
16:06:10 <sorear> it can't magically make a future call on the type return a chosen sort
16:07:29 <mattam> No, but you can check if they are sorts and fail it they aren't, that's exaclty the error Coq gave you in your example because y is typed by a product and not a sort
16:08:23 <sorear> so a product FOOBAR should be dis-allowed if it types to something that isn't a sort?
16:08:30 <mattam> Star domsort <- type domtype ; Star codomsor <- ... ; return (Star smthg)
16:08:32 <chessguy> eumenides: ok, i got it to build, but i had to comment out some Data.Graph.Inductive stuff. i take it that doesn't need to be there?
16:09:04 <mattam> yeah
16:13:25 <sorear> well, thanks mattam, my example doesn't type now.  I have a feeling nothing else will however :)
16:15:47 <dcoutts> woo!
16:16:57 <dcoutts> isn't it sad how making a non-ambiguous parser can be such a feeling of achievement
16:17:08 * dcoutts slaps __attributes__
16:18:02 <vincenz> what are you parsing?
16:18:14 <sorear> C?
16:18:20 <sorear> __attributes__ and all that
16:18:25 <sorear> * GNU C
16:18:25 <vincenz> yeah, wasn't sure
16:19:37 <vincenz> dcoutts: parsec?
16:19:53 <dcoutts> happy
16:20:10 <stepcut> dcoutts: are you parsing C ? Does this mean you have an AST for C ?
16:20:11 <dcoutts> you'd never know if you had an ambiguous grammar with parsec
16:20:26 <dcoutts> stepcut: just the ordinary c2hs C AST
16:20:44 <vincenz> dcoutts: so you must have tight integration with your alex frontend?
16:20:49 <dcoutts> I'm just looking at improving the parser at the moment, not the ast
16:20:51 <dcoutts> vincenz: oh yes
16:20:54 <stepcut> hrm, is there a pretty-printer for that AST that spits out valid C ?
16:21:01 <dcoutts> stepcut: nope :-)
16:21:05 <sorear> shouldn't be hard
16:21:13 <chessguy> @pl \f -> map (map f)
16:21:14 <lambdabot> map . map
16:21:16 <vincenz> sorear: that's debatable, unless you like lispy expressions
16:21:24 <dcoutts> stepcut: we only need to parse for c2hs, not pretty print
16:21:25 <vincenz> I know it's not trirvial
16:21:28 <vincenz> that's why many don't do it
16:21:28 <sorear> vincenz: huh?
16:21:36 <vincenz> For instance CIL flattens a lot while parsing
16:21:42 <sorear> vincenz: i said *valid*
16:21:50 <vincenz> oh, I thought you meant readable :)
16:22:00 * stepcut is just looking for a reasonable way to generate C code
16:22:01 <dcoutts> stepcut: but the obvious extension is to take the c2hs C parser and AST and turn it into a full Language.C.{AST,Pretty,Parser,etc}
16:22:21 <vincenz> dcoutts: do you flatten a[i] to *(a+i)?
16:22:27 <dcoutts> vincenz: no
16:22:33 <stepcut> dcoutts: yeah, i think something like that is a GSoC proposal from last year ?
16:22:53 <dcoutts> stepcut: it was, yes. Sadly it was one of the few projects that failed.
16:23:09 <vincenz> dcoutts: CIL does stuff like that, if you're interested I think they have a haskell inputter for their AST
16:23:18 <dcoutts> CIL?
16:23:21 <vincenz> from berkely
16:23:25 <vincenz> @google CIL
16:23:29 <lambdabot> http://www.isotope.com/
16:23:35 <vincenz> hmm
16:23:40 <joelr1> ?src choice
16:23:41 <lambdabot> Source not found. I feel much better now.
16:23:49 <joelr1> @hoogle choice
16:23:49 <lambdabot> Text.ParserCombinators.ReadP.choice :: [ReadP a] -> ReadP a
16:23:50 <lambdabot> Text.ParserCombinators.ReadPrec.choice :: [ReadPrec a] -> ReadPrec a
16:23:50 <lambdabot> Text.ParserCombinators.Parsec.Combinator.choice :: [GenParser tok st a] -> GenParser tok st a
16:23:50 <vincenz> http://hal.cs.berkeley.edu/cil/
16:23:51 <lambdabot> Title: CIL Documentation (v. 1.3.6)
16:23:53 <vincenz> It's written in ocaml
16:24:08 <joelr1> ?src Text.ParserCombinators.Parsec.Combinator.choice
16:24:09 <lambdabot> Source not found. The more you drive -- the dumber you get.
16:25:23 <vincenz> dcoutts: this is the haskell readea rhttp://code.google.com/p/cil-pickle/
16:25:24 <lambdabot> Title: cil-pickle - Google Code
16:25:31 <vincenz> reader
16:25:38 <dcoutts> ta
16:25:56 <vincenz> but they do flatten : for -> while, a[i] -> *(a+i)
16:26:18 <vincenz> probably to ease analysis
16:26:28 <vincenz> they do a lot of fancy analysis stuff, however
16:28:08 <joelr1> any parsec experts on board?
16:28:42 <dcoutts> whee! I can parse at least one thing that CIL can't :-)
16:28:57 <chessguy> > init "foo"
16:28:59 <lambdabot>  "fo"
16:29:02 <vincenz> dcoutts: what's that?
16:29:18 <dcoutts> http://hal.cs.berkeley.edu/cil/cil012.html#toc26
16:29:19 <lambdabot> Title: Known Bugs and Limitations
16:29:26 <dcoutts> vincenz: int bar(int ()); // This prototype cannot be parsed
16:29:51 <vincenz> ah nice :)
16:30:30 <sorear> joelr1: choice = msum
16:31:33 <vincenz> dcoutts: it might be nice to use the pickler so we can get fancy C-analysis through CIL and then import back into haskell
16:31:39 <joelr1> sorear: is it the same as p1 <|> p2?
16:31:44 <dcoutts> vincenz: mm
16:31:46 <vincenz> dcoutts: I mean parse with your parser, send the AST to them in the pickle format
16:32:06 <dcoutts> someone else can add that on top of Language.C :-)
16:32:13 <dcoutts> Language.C.CIL
16:34:04 <Saizan> sorear: there's a bug in simple_instance (and instance_context), it uses (ContT []) as the type constructor instead of ListT, i don't see a good way to correct this, aside from special casing on "[]"
16:35:26 <sorear> Saizan: Special case on [].
16:35:59 <Saizan> ..ok
16:36:03 <sorear> Saizan: Ideally, you should create a new function for type-context String -> Type, and a new set of type construction routines
16:36:08 <sorear> for maximum genrality
16:37:35 <ddarius> Cripes, now sorear is into dependent typing.
16:37:35 <Saizan> mkType "[]" = ListT; mkType x = ContT (mkName x) ?
16:38:08 <sorear> Saizan: good enough for now.
16:38:24 <sorear> ddarius: I just want to understand it.  I don't expect to make much use of it.
16:38:45 <sorear> ddarius: and you may have noticed I find implementing something an effective way to understant it
16:39:25 <ddarius> Implementing something is an effective way to understand something whether you find it that way or not.
16:39:55 * ddarius is arbitrarily crabby seeming.
16:41:48 <ddarius> Besides all the good reasons I can think of, why not use dependent types?
16:42:24 <sorear> they are new
16:42:36 <sorear> (to programming)
16:43:00 <sorear> because I can't consistantly spell them
16:43:14 <dibblego> or consistently :)
16:45:23 <chessguy2> oh gosh, there are 2 of me!
17:01:04 <balodja> sorear: hi, could you help me to couple with bug in hs-plugins? :)
17:01:53 <dcoutts> @tell vincenz thanks for pointing me at CIL, they have a full lex and yacc style lexer and grammar. Should be helpful to compare against when I run into problems with my alex & happy grammar.
17:01:53 <lambdabot> Consider it noted.
17:02:47 * ddarius eagerly awaits sorear's response to that.
17:03:00 <sorear> balodja: I don't know yet
17:03:37 <sorear> I suspect 'yes', but it will have to wait until I have more details.
17:04:22 <balodja> sorear: so. lambdabot uses some functions from that package. i mean System.Eval.Haskell with function eval.
17:04:51 <balodja> as you know, eval for evaluation makes a temporary file in /tmp with some code
17:04:56 <balodja> than compiles it
17:05:34 * dcoutts notes that on planet.haskell.org his name is being taken to mean "a mythical perfect haskell programmer"
17:05:36 <balodja> and than dynamically loads functions from compiled object, and eventually evaluates them
17:05:38 * dcoutts is flattered
17:05:50 <dcoutts> it's not true of course :-)
17:05:58 <ddarius> You aren't mythical.
17:06:12 <emu> can you compute uncomputable functions?
17:07:08 <balodja> so, the problem is that names that functions have in compiled object don't coinside with names that hs-plugins wants to load
17:07:32 <balodja> (in my system, of course)
17:07:40 <sorear> balodja: lambdabot only uses hs-plugins for @run.
17:07:48 <sorear> and @check/@scheck
17:07:50 <balodja> yeah, and i need it!
17:07:53 <dcoutts> emu: heh
17:08:09 <emu> if so, i have a few questions to ask..
17:08:11 <dcoutts> and I don't prove any of my programs
17:08:27 <dcoutts> I'm not at all like Dijkstra
17:08:31 <dcoutts> what a silly comparison
17:10:21 <dcoutts> most off by one bugs can be solved by using data types that are not indexed with integers
17:10:23 <balodja> for example, hs-plugins maked file /tmp/MJRMB29873.hs, compiled it, and than tried to find symbol 'main_resource_closure', which is actually named MJRMB29873_resource_closure
17:10:48 <dcoutts> ie use lists, it's much harder to get off-by-one bugs with lists
17:10:51 <fuzan> Anyone have a large haskell logo (the lambda one from the main page) >500px?
17:10:55 <ddarius> All off by one bugs can be solved by getting rid of the number one.
17:10:59 <balodja> but, as i don't know haskell at all, i can't find this bug in code :)
17:11:29 <ddarius> When do you have to know a language to debug or program in it?
17:12:38 <balodja> so, there would be no help?
17:13:40 <fuzan> We should get rid of the number n.
17:13:49 <fuzan> That way we could eradicate all off-by errors.
17:16:10 <araujo> hello
17:17:27 <sorear> I'm having remarkable difficulty proving 1 /= 0.
17:18:25 <araujo> :-)
17:19:36 <sorear> I think the best approach is to note that 1 has an immediate predecessor while ...
17:19:44 * sorear tries to prove zero does not
17:22:27 <dmwit> sorear: It's an axiom, I think.
17:23:47 <dmwit> sorear: You could also note that \exists x:x \in 1, but \not\exists x:x \in 0, since 0 = \emptyset.
17:24:06 <sorear> dmwit: I'm trying to construct the Peano numbers
17:24:22 <Saizan> well, with Peano naturals it's quite obvious that 0 <= 1 but not 1 <= 0
17:24:24 <sorear> dmwit: using the Church construction, not the von Neumann construction
17:24:45 <sorear> (in the raw calculus of constructions)
17:24:49 <dmwit> sorear: Is that 0=\emptyset, n+1=n\union\{n\}?
17:25:13 <sorear> 0 = \x y -> y ; 1 = \x y -> x y ; 2 = \x y -> x (x y) ...
17:25:23 <dmwit> aha
17:25:37 <ddarius> sorear: Define ==
17:27:11 <sorear> a : T == b : T   =====   [ p : (T -> *0) ] [ x : p a ] p b
17:27:41 <sorear> or in Haskell syntax, forall p . p a -> p b
17:28:34 <fuzan> nobodies got a pretty and large haskell logo? :'(
17:28:51 <sorear> HASKELL LOGO :)
17:29:38 <stepcut> sorear: haha
17:30:37 <sorear> I can express the type of "0 has no predecessor" easily enough.
17:31:11 <QtPlatypus> fuzan: http://upload.wikimedia.org/wikipedia/en/0/0f/Haskell_Logo.jpg is two small?
17:32:37 <sorear> [x : num] [ispredz : [ p : (num -> *0) ] [ofsuccx : p (succ x)] p zero] falsity
17:32:39 <sorear> where
17:32:49 <sorear> num = [a : *0] [s : a -> a] [z : a] a
17:32:57 <sorear> falsity = [a : *0] a
17:33:14 <sorear> zero = \t:*0 . \s:[x:t]t . \z:t. z
17:33:26 <sorear> succ = \a : num . \t:*0 . \s:[x:t]t . \z:t . s (a t s z)
17:35:18 * sorear tries for 'true /= false'
17:38:35 <xerox> sorear, what syntax is that one?
17:38:40 <fuzan> QtPlatypus: yah. That's the same one from the haskell.org page.
17:38:57 <sorear> xerox: afaik, basic CoC paper syntax.
17:39:09 <QtPlatypus> fuzan: i don't know of any bigger.
17:39:39 <ddarius> xerox: Syntaxes similar to it are not uncommon in dependent-typing work. [...] is an abstraction.
17:41:21 <xerox> [...] [...] [...] a  is abstraction application?
17:42:40 <ddarius> No, three abstractions.
17:53:34 <dons> ?moin!
17:54:25 <ddarius> !moin?
17:55:01 <stepcut> coin!
17:55:09 * dons forgets the boundary between language and lambdabot sometimes
17:55:09 <lambdabot> dons: You have 4 new messages. '/msg lambdabot @messages' to read them.
17:55:13 <dons> happy birthday stepcut !
17:55:26 <dons> or commiserations.. ;-)
17:55:30 <stepcut> yay! though, not for 6 more hours
17:55:39 <dons> ?time dons
17:55:43 <lambdabot> Local time for dons is Tue Apr 10 10:55:02 2007
17:55:46 <dons> oh, of course. silly america
17:55:50 <stepcut> I am 30 in Austrialia :)
17:56:00 <stepcut> ?time stepcut
17:56:00 <dons> :)
17:56:01 <lambdabot> Local time for stepcut is Mon Apr  9 17:55:23 2007
17:56:14 <dons> oi! its still my birthday then. party!
17:56:18 <jcreigh> stepcut: depends. what TZ were you born in? :)
17:56:30 <stepcut> jcreigh: EST
17:56:37 <stepcut> so, 3 more hours
17:56:58 <stepcut> unless you want to start talking about leap years :-/
17:57:25 <jcreigh> wait...do the recent DST changes in the US affect this?
17:57:42 * jcreigh has a hard time keeping DST/TZ stuff straight.
17:57:50 <dons> xmonad users, the new dmenu-cache patch really improves performance for dmenu startup
17:58:08 <dons> this patch, http://na.srck.net/dwm/dmenu2.9_cache.patch, applied to dmenu 2.8
17:58:11 * narain considers that the only physical significance of birthdays is that the earth is in the same relative position in an inertial frame travelling with the sun
17:58:20 <fuzan> does xmonad have pretty bars to highlight the active window?
17:58:27 <dons> yeah
17:58:38 <dons> it draws a red line around the active window
17:58:39 <jcreigh> fuzan: specifically, a 1px border. :)
17:58:55 <stepcut> jcreigh: but, not for KDE applications...
17:59:24 <dons> 1px is pretty.
17:59:26 <jcreigh> or Firefox, I've noticed. clients must be able to opt out somehow, or else we need to flip some different switches.
18:00:01 <stepcut> i assume xmms does not have a border either, it really avoids the window manager
18:00:25 <jcreigh> yeah, xmms is like an X11 sociopath.
18:00:37 <stepcut> :p
18:00:55 <stepcut> jcreigh: atleast it responds to xkill
18:01:35 <stepcut> I wrote an app that not-only managed its own window, but also avoided xkill
18:01:39 <fuzan> It should resize the otherwindows just a little bit to giv eit the impression of being a layer behind :)
18:01:45 <fuzan> that would be sexy.
18:02:07 <fuzan> i'll try it again tonight.
18:02:11 * stepcut is still working on the xmonad-composite patches ;)
18:02:37 <kosmikus> do any of you have preferences regarding the next HCAR deadline. May 2nd ok?
18:02:56 <dmead> whats hcar?
18:03:17 <kosmikus> ?where hcar
18:03:17 <lambdabot> http://www.haskell.org/communities/
18:04:01 <dmead> oh
18:04:02 <dmead> neat
18:04:19 <dmead> who do i submit to to put my work on there?
18:04:43 <kosmikus> dons, you said something about several other upcoming deadlines?
18:04:58 <kosmikus> TMR is earlier, right? and HW is in June, I think.
18:05:10 <dons> TMR is the weekend.
18:05:13 <dons> HW is June, yeah.
18:05:38 <dons> so sometime in between. ho hum. May 2, perhaps? :-)
18:06:30 <kosmikus> ok :)
18:08:06 <balodja> oh, dons! there are some troubles with ghc-6.6(debian binaries) and hs-plugins 1.0
18:09:47 <dons> ok. you should be using hs-plugins from darcs, and ghc 6.6, yes?
18:09:53 <dons> what platform? linux / x86?
18:10:00 <balodja> in function eval in module System.Eval.Parser
18:10:05 <balodja> yeah
18:10:29 <dons> ok. that combination basically works. what goes wrong?
18:10:36 <dons> ?users
18:10:37 <lambdabot> Maximum users seen in #haskell: 336, currently: 295 (87.8%), active: 32 (10.8%)
18:11:24 <balodja> dons: the problem is that, while creating and compiling temporary files, hs-plugins doesn't guess the right name of symbols' names to find
18:12:10 <balodja>  <balodja> for example, hs-plugins maked file /tmp/MJRMB29873.hs, compiled it, and than tried to find symbol 'main_resource_closure', which is actually named MJRMB29873_resource_closure
18:12:36 <dons> hmm.
18:12:59 <dons> so you're doing a custom call to eval?
18:13:01 <balodja> as ugly hack, adding -package-name MJRMB29873 saves the situation
18:13:10 <balodja> yeah, i am
18:13:21 <dons> ok. yeah, its possible things like that have broken.
18:13:35 <dons> i don't have time to fix it now so patches are welcome.
18:13:59 <balodja> the main problem is that i don't know haskell at all :)
18:14:10 <balodja> so i'll try to do something
18:14:52 <dons> you seem to be managing so far... but what are you using hs-plugins for?
18:15:06 <balodja> for lambdabot
18:15:29 <dons> oh hmm. eval works fine for me though, on linux/x86
18:15:32 <monochrom> Wow, package MJRMB29873  :)
18:15:40 <dons> in runplugs, that is.
18:15:54 <dons> M for module, monochrom ;-)
18:23:37 <sekr_veled> hey i'm new to haskell and want to ask a simple question
18:23:54 <sekr_veled> i have a type synonym
18:23:55 <sekr_veled> type DFA = (Integer,[Integer],[(Integer,Char,Integer)],[Char])
18:24:08 <sekr_veled> and want to define show for it
18:24:22 <sorear> don't
18:24:26 <sekr_veled> i tried
18:24:27 <sekr_veled> instance Show DFA where
18:24:27 <sekr_veled> 	show (a,bs,cs,ds) = "[StartState=" ++ show a ++ "]\n[AcceptStates=" ++ show bs ++ "]\n[Transitions=" ++ show cs ++ "]"
18:24:32 <sorear> you can only derive show for *types*
18:24:41 <sorear> not type synonyms
18:24:45 <sorear> s/derive/define
18:25:08 <sekr_veled> so how can i write a show function for type DFA
18:25:09 <sorear> you ought to be using a real data type for anything longer than two tokens
18:25:34 <sorear> data DFA = DFA Integer [Integer] [(Integer,Char,Integer)] [Char]
18:26:11 <sekr_veled> ok i c
18:26:16 <monochrom> I agree with sorear.
18:26:37 <sekr_veled> noway to do that with type DFA?
18:26:42 <sorear> type synonyms are mostly not used in modern Haskell style.
18:26:43 <emu> you also probably want that third type to be (Map (Integer, Char) Integer)
18:26:48 <sorear> sekr_veled: no way you want
18:27:12 <monochrom> With such a rich type I wonder why synonym.
18:27:25 <sorear> sekr_veled: what if you have a type with the same structure but a different meaning somewhere else in the program?
18:27:26 <monochrom> by "rich" I mean "complex"
18:27:39 <dons> well, they're used for naming complex types
18:27:45 <sorear> sekr_veled: you can't keep them separate with synonyms
18:27:48 <dons> i.e. as variables :-)
18:27:49 <sekr_veled> i started with yetanothertutorial for haskell
18:27:55 <sekr_veled> and it was what i saw there
18:28:13 <sorear> Infact, now that we have newtype deriving I suspect we could do away with type synonyms entirely.
18:28:37 <sekr_veled> =) so i better change this type thing
18:28:51 <sekr_veled> thanks guys
18:29:12 <sphynx> so, it is preferrable to use data or newtype instead of type in most of the cases?
18:29:27 <emu> ordinary "type" synonyms are really not much more useful than being documentation
18:29:39 <emu> "newtype" and "data" declarations actually create a type
18:29:39 <monochrom> Some beginner literature uses type synonyms for early lessons.  These are meant to be toys.  For real programming you use "data" or "newtype".
18:30:42 <dino-> Hm. I didn't get the impression the ability to use type syns to give more meaningful names to things as a toy to be avoided eventually.
18:31:14 <twanvl> Type synonyms are not the problem here, tuples are
18:31:43 * sorear rather likes having the full set of semiring operators
18:32:08 <emu> type synonyms don't let you hide implementation either
18:32:12 <monochrom> Eventually, you define a type of sophisticated data structure, in a module, and you provide access functions, and you hide the data structure, only expose the type name and the access functions.  At this point, type synonym doesn't cut it.
18:33:23 <sorear> Hugs and ML both support restricting the scope where a type synonym is transparent, but not standard Haskell.
18:33:34 <monochrom> If your program isn't a million lines of code with a thousand abstractions, it's a toy.  This is industrial definition, not just me.
18:33:49 <emu> what haskell program is a million lines?
18:34:14 <monochrom> Perhaps a million tokens.
18:34:14 <dino-> monochrom: I'm just wondering if you think something like type FilePath = String in the Prelude: should be gotten rid of.
18:34:24 <dons> ghc + libs is around 300k
18:34:27 <monochrom> No, that one is ok.
18:34:55 <sorear>   355746 total
18:35:01 <sorear> for ghc + libs head
18:35:10 <dino-> monochrom: I do things like that all the time, like emu said, in a documentation sense.
18:35:27 <monochrom> 99% of the type synonyms in tutorials should become "data" or "newtype" when you scale them up, is what I'm saying.
18:35:59 <twanvl> For fun, just take a look at the yhc source code, and see the horror type synonyms can bring to your source code:
18:36:00 <twanvl> http://darcs.haskell.org/yhc/src/compiler98/CaseLib.hs
18:36:10 <sjanssen> FilePath is okay, except for the fact that paths aren't actually Strings
18:36:30 <dino-> I understand what you're saying.
18:37:20 <sjanssen> oh god, an 11-tuple
18:37:31 <monochrom> Yeah, a file path should be eventually represented by an abstraction whose internal is richer than just a String.  Java has reached that maturity.  Some haskellers have also reached that maturity by using the filepath package.
18:38:00 <sorear> sjanssen: that code is scheduled for scrapping, mind you :)
18:38:05 <sjanssen> monochrom: the filepath package keeps FilePath = String
18:38:12 <monochrom> So perhaps even that particular type synonym in the Prelude is a relic toy.
18:38:18 <dino-> twanvl: I see, lots of just what people are talking about here. type used on tuples of things.
18:38:24 <sjanssen> sorear: I hope so!
18:38:35 <sorear> and that isn't even yhc code.
18:38:48 <sorear> that code was inherited verbatim from nhc98 during the fork
18:38:54 <twanvl> sorear: http://www.haskell.org/pipermail/yhc/2007-April/000835.html
18:38:55 <lambdabot> Title: [Yhc] Yhc using mtl
18:38:56 <LoganCapaldo> file paths are strings in C by gum!
18:39:00 <sorear> the entire frontend actually
18:39:15 <sorear> twanvl: I'm subscribed, I read it when you sent it.
18:39:25 <twanvl> ok
18:39:42 <sorear> for those still mystified, the yhc frontend is older than records.
18:40:43 <jcreigh> (Just, Say, No, To, NTuples, Where, N, Is, Large)
18:40:54 <twanvl> That doesn't mean they could not have used datatypes
18:41:24 <sorear> jcreigh: yhc fails to compile code with large classes because it stores dictionaries as tuples, and limits tuples to N<=20
18:41:43 <sorear> I wonder why 20, and not 7 like ghc (used to) ;)
18:41:53 <twanvl> Why not create a new datatype for each class?
18:42:02 <jcreigh> probably because it stores dictionaries as tuples?
18:42:09 <sorear> historical reasons
18:42:17 <emu> hysterical raisins
18:42:17 <sorear> i think
18:42:41 * jcreigh thinks that a hard limit of N, where N is arbitrary is a code smell.
18:43:39 * sorear points out that tuples are real data types in yhc, and there are 20 copies of the code defining tuples and providing instances!
18:44:01 <monochrom> A good rule of thumb is: if the standard library doesn't provide the Show instance, your tuple is too long :)
18:44:02 * twanvl thinks that anyone who uses tuples with N > 2 is doing something wrong
18:44:28 <QtPlatypus> twanvl: Then why don't we just have pairs?
18:45:42 <twanvl> Because some people like doing things wrong? :)
18:45:48 <narain> you could obviously build n-tuples from pairs, but associativity would be a pain
18:46:01 <narain> nonassociativity, rather
18:46:20 <dons> sjanssen: could you just look up the TMR website details now ?
18:46:26 <dons> i'll be doing some writing this afternoon,
18:46:31 <dons> but we better get started.
18:46:42 <sorear> narain: have you seen HList?
18:46:44 <dons> basically , I'm thinking along the lines of "The Design and Implementatoin of a Tiling Window Manager"
18:46:49 <dons> sjanssen: whaddya reckon?
18:47:10 <narain> ?where hlist
18:47:11 <lambdabot> http://homepages.cwi.nl/~ralf/HList
18:47:41 * narain looks
18:48:38 * narain sees lots and lots of type classes
18:49:03 <sjanssen> dons: you mean the "instructions for authors" on the wiki?
18:49:18 <dons> yeah, what do we have to do?
18:49:19 <sjanssen> dons: that sounds like a fine topic
18:49:31 <dons> just start our own darcs repo for now, to prepare a .pdf ?
18:49:48 <chessguy> @instances-importing Show
18:49:50 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
18:49:58 <dons> and page length, other advice, and deadline info.
18:50:45 * SamB wonders why ZZT doesn't seem to restore the old video mode on exit...
18:51:24 * SamB makes a note to reprimand Tim Sweeney if he ever gets a chance...
18:53:09 <sorear> dons: is tmr announced anywhere?
18:53:19 <sorear> hwn? pho?
18:53:23 <sorear> ml?
18:53:59 <dons> you have to use full sentences, preferably, and perhaps full words too, for me to be able to understand you, sorear :-)
18:54:16 <dons> TMR would be on the ml. hwn hmm. maybe i can get an issue out today.
18:55:11 <sjanssen> dons: the deadline is April 13
18:55:15 <monochrom> haven't seen hwn for a while
18:56:09 <dons> neither have I. I wonder what the editor has been doing? what a slacker!
18:56:15 <jcreigh> dons, sjanssen: what do you guys think about a OneToOne datatype with the following interface: empty, insert, lookupLeft, lookupRight, fromList (hopefully self-explanatory)
18:56:23 <sjanssen> dons: there's a latex class we're supposed to use
18:56:32 <sorear> dons: wasn't there a mega-important conference or something?
18:56:44 <sorear> the editor had a paper to write?
18:56:47 <dons> hmm. maybe. i saw some rumours about it.
18:56:50 <sjanssen> jcreigh: probably useful (in more than one instance in xmonad?)
18:56:57 <monochrom> I love the editor.
18:57:03 <jcreigh> I'm thinking screen <-> workspace mapping.
18:57:09 <jcreigh> I don't know of anywhere else offhand.
18:57:13 <monochrom> Can I download it somewhere? Is it written in Haskell?
18:57:16 <dons> jcreigh: hmm, so I'd like to combine the StackSet and workspace data
18:57:28 <dons> so we have a single type we can check modelling the entire workspace/screen/stack
18:57:42 <dons> so, OneToOne is the top level?
18:57:52 <dons> yielding a StackSet for each screen?
18:58:29 <fuzan> Operations.hs:120:26: Not in scope: `waBorderWidth'
18:58:32 <fuzan> xmonad build
18:58:33 <jcreigh> tenatively, I'm thinking having, viewports :: OneToOne ScreenNumber WorkspaceNumber in StackSet
18:58:38 <dons> fuzan: update X11-extras
18:58:43 <fuzan> ok.
18:59:37 <jcreigh> that wouldn't really be a major change from what we have now, expect nicer lookups and being in StackSet instead of XMonad.
18:59:47 <dons> jcreigh: hmm, maybe send a draft api to me and sjanssen ?
19:00:03 <dons> yes, minimal changes to merge the xinerama changes into stackset seem good.
19:00:09 <dons> we want to release around the 13th.
19:00:17 <jcreigh> 0.1?
19:00:24 <dons> yeah. i guess.
19:00:24 <fuzan> i'm giving somewhat of an introductory talk on haskell tomorrow. anyone have any previous experience in doing such?
19:00:40 <jcreigh> @seen dmwit
19:00:41 <lambdabot> dmwit is in #haskell and #haskell-blah. I last heard dmwit speak 1h 35m 18s ago.
19:00:57 <dmwit> I'm here.
19:01:11 <jcreigh> dmwit: how do you feel about Xinerama in xmonad?
19:01:14 <dmwit> I was wondering early today: is xmonad still in feature freeze?
19:01:17 <dmwit> It's nice.
19:01:20 <sjanssen> dmwit: yes
19:01:26 <sjanssen> until 0.1 is out
19:01:31 <jcreigh> dmwit: are you still thinking disjoint workspaces would be better?
19:01:51 <sjanssen> thinking about the relationships between entities in StackSet reminds me of SQL
19:02:07 <dmwit> jcreigh: I think it's unnecessary.
19:02:17 <dmwit> I've gotten use to the current setup, and it isn't so bad.
19:03:10 <jcreigh> okay, then we'll keep the current system for now.
19:03:37 <dons> wow, i got an email just now from a guy on openbsd building ghc purely to try out xmonad
19:03:43 <jcreigh> The nice thing about having one StackSet is that it already has the invariant that a window can only be in one stack. If you have multiple stack sets running around, you lose that.
19:04:06 <sjanssen> jcreigh: yeah, there should be one StackSet
19:04:22 <jcreigh> There can only one!
19:04:28 <jcreigh> *be only one
19:04:39 <sjanssen> we may need to just handle invariants like one-to-one by hand
19:04:40 <dons> btw, i'm waiting on simon mar for details on the xmonad mailing list.
19:04:41 <jcreigh> gah, I screwed the reference...
19:04:48 <dons> he has the passwd i need.
19:05:58 <dons> do we ever have windows on multiple xinerama screens?
19:06:03 <dmwit> no
19:06:04 <sjanssen> no
19:06:19 <sjanssen> I should write these invariants up
19:06:25 <dons> ok. so we should be able to keep strong invariants then.
19:06:30 <dons> i.e. QC property testable.
19:06:50 <dons> but i don't like any manual invariant maintanence
19:06:59 <dons> the structure should really preserve this stuff
19:07:48 <sjanssen> dons: I meant manual within the data structure
19:08:19 <sjanssen> we're already doing some of this (window can only be in one workspace)
19:14:40 <dons> yeah.
19:14:48 <dons> as long as its hidden behind the api
19:15:06 <dons> (but not necessarily hidden inside the data structures we use, like Map -- we can do the invariants oursleves)
19:15:44 <sjanssen> I just added invariants for a new StackSet to the TODO.  Let me know if I missed something
19:15:52 <dons> if we get 0.1 out, and the TMR, and the QC properties, we'll basically set the spec for how to write basic window managers :-)
19:15:56 <dons> ok.
19:17:30 <hpaste>  jcreigh pasted "first shot at OneToOne" at http://hpaste.org/1325
19:17:57 <jcreigh> I should probably take this opportunity to learn about QC by writing some properties for OneToOne...
19:18:33 <syntaxfree> ?src iterate
19:18:34 <lambdabot> iterate f x =  x : iterate f (f x)
19:18:48 <jcreigh> BTW, I know the implementation I posted is very un-clever: O(N) lookups and inserts.
19:20:36 <sjanssen> jcreigh: this looks useful, if we can find more than a single one-to-one relationship in xmonad
19:20:51 <sjanssen> but I'm only seeing the screen/workspace relationship right now
19:21:12 <sorear> sjanssen: there are one-to-one relationships in many, many programs
19:21:28 <sorear> do you really think anselm would mind if this appeared in base?
19:21:46 <sorear> or even collections.  hmm.
19:22:21 <sjanssen> sorear: sure, a bidirectional map would be a useful general data structure
19:23:15 <jcreigh> sjanssen: I don't quite follow you. Are we not allowed to add a datatype if we only use it in one place? :)
19:23:45 <sorear> jcreigh: de-inlining single use abstractions only bloats
19:23:57 <jcreigh> hmm
19:24:12 <sjanssen> I agree with sorear
19:24:22 <jcreigh>     let ws = fmap fst $ find (\(_, scn) -> scn == (n-1)) (M.assocs ws2sc)
19:24:29 <jcreigh> ^^ I'm just trying to avoid that.
19:24:36 <sorear> yow!
19:24:43 <sorear> what does that MEAN!
19:24:45 <sorear> :)
19:24:47 <jcreigh> see? :)
19:25:00 <jcreigh> sjanssen: so you're saying, fake it with a Map for now, yes?
19:25:33 <sjanssen> jcreigh: yes, two Maps in StackSet
19:25:38 <sorear> jcreigh: that Maybely sets ws to the workspace nr showing screen n-1
19:25:50 <sjanssen> Map Screen Workspace, Map Workspace Screen
19:25:51 <sorear> just took me a minute ;)
19:26:05 <jcreigh> oh, and tweak them both?
19:26:12 <sjanssen> jcreigh: yeah
19:26:43 <dmwit> That is how the OneToOne would work anyway, right?
19:26:56 <sjanssen> and give StackSet a couple functions like: workSpaceOfScreen, etc.
19:27:35 <sjanssen> maybe we should make Workspace into a separate data type?
19:28:09 <jcreigh> maybe. I only do one thing per patch, though. :)
19:28:31 <sjanssen> fine for now
19:28:45 <jcreigh> A workspace type would be nice: Then you could store the layout, the focus and whatnot all in one place. But yeah, fine for now.
19:29:24 <sjanssen> jcreigh: so you're doing the screen/StackSet unification as we speak?
19:29:55 <jcreigh> yes. I'm removing wsOnScreen from XMonad, and making the two maps as you suggest in StackSet
19:31:14 <sjanssen> I have a feeling that this unification will silently kill a couple bugs
19:34:04 <glguy> most inductive proofs have a basis ( f(1) ) and inductive step ( f(n-1) implies f(n) ) ... but is it acceptable to use all of the previous cases in your inductive step?
19:34:16 <dmwit> glguy: Definitely.
19:34:22 <glguy> forall k > 1  f(n-k) implies f(n)
19:34:23 <glguy> right?
19:34:36 <dmwit> forall k geq 1
19:34:42 <glguy> yeah, that :)
19:34:53 <dmwit> Sounds good.
19:34:56 <glguy> it makes intuitive sense to me, I just want to use it on a homework
19:35:10 <dmwit> You can prove strong induction from induction.
19:35:12 <sjanssen> I think there's even a name for that sort of inductive proof
19:35:53 <dmwit> The short answer is let f(n)=g(i) for all i < n, then use normal induction.
19:44:18 <emu> sjanssen: complete induction
19:44:34 <mwc> Hmm, anybody know a good one-way function? I used to like knapsack problems, but 5 years ago I didn't realize they were vulnerable to dynamic programming
19:46:02 <sorear> sha1
19:46:17 <sorear> :: [Word512] -> Word160
19:46:31 <sorear> man 1 sha1sum
19:46:48 <sorear> @google fips-180-1
19:46:50 <jcreigh> isn't sha1 (sort of) broken? (2**69 operations to find a collision in SHA-160, IIRC)
19:46:51 <lambdabot> http://www.itl.nist.gov/fipspubs/fip180-1.htm
19:46:51 <lambdabot> Title: FIPS 180-1 - Secure Hash Standard
19:47:21 <sorear> OK then.
19:47:30 <sorear> Modular exponentiation.
19:47:37 <sorear> RSA also works.
19:47:51 <sorear> Generate a big keypair, and throw away the private key.
19:48:22 <sorear> That said, noone will believe you when you said you threw it away, so people won't trust it to be one-way even if it is.
19:49:02 <chessguy> ok, i have a question
19:49:17 * sorear is NOT a trained cryptographer, and is inventing solutions on the spot
19:49:23 <sorear> go ahead
19:49:49 <chessguy> why does http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Tree.html (pointed at by @docs Data.Tree) point to a different source file than http://darcs.haskell.org/packages/base/Data/Tree.hs (obtained from @source Data.Tree)
19:49:51 <lambdabot> http://tinyurl.com/2gwkse
19:50:21 <sorear> ask the people who maintain the ghc haddocks
19:50:27 <sorear> ie, @wiki Haskell.org
19:50:37 <sorear> IIRC Ashley Yakely
19:51:15 <chessguy> is there an up-to-date docs file somewhere that would point to the correct source file?
19:51:22 <sjanssen> hmm, is latest supposed to reflect the latest release or current development version?
19:51:23 <sorear> someone is probably feeding the wrong --source-base path into hadddock
19:51:35 <sorear> @docs Data.Function
19:51:36 <lambdabot> Data.Function not available
19:51:41 <_debrac> Hello all
19:51:48 <_debrac> I am trying to build a decision tree thing in Haskell
19:52:08 <sorear> sjanssen: it is missing a new-in-6.7 module, so former
19:52:11 <chessguy> hi _debrac
19:52:16 <_debrac> I can get it to dump all the permutations
19:52:21 <_debrac> But I need to kind of you know
19:52:33 <sjanssen> chessguy: the haddocks are doing the right thing
19:53:07 <chessguy> sjanssen: well http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Tree.html is clearly out of date
19:53:09 <lambdabot> http://tinyurl.com/2gwkse
19:53:18 <_debrac> So - is that possible?
19:53:22 <chessguy> at least according to that source file
19:53:22 <sorear> chessguy: no it's not
19:53:29 <sorear> chessguy: the source is 6.6, no?
19:53:31 <_debrac> Ex. Can it break the it down to sort the permutations?
19:53:37 <dmwit> _debrac: I didn't see what it was you wanted to do.
19:53:40 <sorear> chessguy: latest is 6.6, current is 6.7
19:53:43 <_debrac> I have something like 54321
19:53:47 <sjanssen> chessguy: they point to the code that actually corresponds to the generated docs (modulo changes made to the 6.6 repo, which aren't supposed to change API anyway)
19:53:51 <chessguy> sorear: well the source file has an instance of monad for Data.Tree, that doc file doesn't
19:53:55 <_debrac> I need it do show me the comparisons it makes to get it to 12345
19:53:59 <_debrac> Is that possilbe?
19:54:03 <dmwit> ?faq
19:54:03 <lambdabot> The answer is: Yes! Haskell can do that.
19:54:13 <_debrac> Its like 120 permutations?
19:54:16 <_debrac> err sorry
19:54:25 <_debrac> Its 120 permutations - so it's not trivial to do
19:54:26 <mwc> sorear, thanks, but for my purposes I need it to be invulnerable in the presence of an oracle that can efficiently factor integers
19:54:36 <mwc> so I eliminated anything based on primality.
19:54:37 <sorear> mwc: Ouch.
19:54:41 <_debrac> I need it to make a comparison - do a little output (of all the things that are still valid)
19:54:44 <dmwit> ?go LicensedPreludeExtensions
19:54:46 <lambdabot> No Result Found.
19:54:46 <_debrac> then do another
19:54:48 <_debrac> .....
19:54:58 <_debrac> All I really need is the order of comparisions
19:55:08 <sjanssen> chessguy: the Monad thing must have been added after the release of ghc 6.6
19:55:20 <chessguy> sjanssen: ah, so it's in HEA
19:55:21 <chessguy> D
19:55:30 <chessguy> and that's why it doesn't show in the docs
19:55:31 <monochrom> mwc: You can then consider graph isomorphism. But sounds like it has a similar vulnerability.
19:55:40 <sjanssen> chessguy: correct
19:55:44 <_debrac> If any of you have ideas... I would appreciate it! :)
19:55:47 <chessguy> ok
19:55:59 <dmwit> _debrac: Still not sure I understand you.  But try looking at
19:56:19 <mwc> monochrom, will look into it, thanks
19:56:21 <chessguy> so http://haskell.org/ghc/docs/latest/html/libraries/ will indeed always take me to the most up-to-date docs, but not necessarily the most up-to-date code
19:56:24 <dmwit> http://www.haskell.org/hawiki/LicensedPreludeExts for the permutations function
19:56:25 <lambdabot> Title: LicensedPreludeExts - The Haskell Wiki
19:56:39 <dmwit> It returns a list of permutations, which you can iterate over.  Will that help?
19:56:44 <sjanssen> chessguy: no, it takes you to the docs from the current stable branch
19:56:58 <monochrom> Hmm what does MD5 do?
19:57:15 <chessguy> oh, ok
19:57:27 <chessguy> monochrom: that's for checksums
19:57:42 <jcreigh> well, if you were going to pick either MD5 or SHA1, I think you should go with SHA1, dispite my fear-mongering.
19:58:09 <sorear> monochrom: MD5 has been collided.  By brute force no less.
19:58:19 <jcreigh> MD5 is "more broken". People have actual files that md5 to the same value with actual MD5.
19:58:27 <chessguy> monochrom: http://en.wikipedia.org/wiki/MD5#Applications
19:58:33 <sorear> 2**64 just isn't enough
19:58:44 <chessguy> > 2**64
19:58:45 <lambdabot>  1.8446744073709552e19
19:58:49 <jcreigh> Whereas my understanding is that the security folks are just starting to get nervous about SHA1, and are trying to move away from using it in new applications.
19:58:55 * jcreigh is not a crypto expert!
19:59:11 <LoganCapaldo> but he plays one on tv
19:59:34 <monochrom> The world is coming to an end.
19:59:47 <jcreigh> "jcreigh As Bruce Schneier"
20:00:03 <monochrom> All cryptos in use being compromised.
20:00:03 <emu> in "The Universal Hash"
20:00:15 <dmwit> Use bluefish!
20:00:34 <monochrom> that one is scheduled to be weakened next year.
20:01:04 <sorear> I suppose bluefish is subtly differend from blowfish?
20:01:20 <LoganCapaldo> yes
20:01:30 <monochrom> Basically the rate of compromising crypto applications is faster than the rate of strengthening crypto applications. After some point we have nothing left.
20:01:32 <LoganCapaldo> all bluefishes are blue but not all blowfishes are blue
20:02:06 <dibblego> > type nub
20:02:07 <lambdabot>  Parse error
20:02:10 <dibblego> ?type nub
20:02:13 <lambdabot> forall a. (Eq a) => [a] -> [a]
20:02:19 <chessguy> @type type
20:02:22 <lambdabot> parse error on input `type'
20:02:44 <monochrom> "Nothing Is Secure: E-Banking in The Post-Factoring Age"
20:04:54 <dmwit> Bah, I said bluefish, but meant twofish.
20:05:01 <dmwit> Anyway, I suppose they're all being broken.
20:05:37 <dibblego> > nub [1,2,3,2,3,4,5,6,3,4,7,8,9]
20:05:39 <lambdabot>  [1,2,3,4,5,6,7,8,9]
20:06:54 <dylan> dmwit: redfish, bluefish...
20:06:59 <chessguy> @type forkIO
20:07:02 <lambdabot> Not in scope: `forkIO'
20:07:06 <dylan> @hoogle forkIO
20:07:07 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
20:07:47 <QtPlatypus> monochrom: Is that a title of a paper?
20:08:15 <monochrom> A title of an imaginary book that is imagined to become a bestseller.
20:11:23 <chessguy> ?hoogle asks
20:11:24 <lambdabot> Control.Monad.Reader.asks :: MonadReader r m => (r -> a) -> m a
20:14:57 <dcoutts> @seen dons
20:14:58 <lambdabot> dons is in #haskell-soc, #haskell-overflow and #haskell. I last heard dons speak 59m 1s ago.
20:19:45 <fuzan> what would you call the basic functional idioms, (map,fold,reduce, etc..) . Just functional idioms?
20:21:19 <dibblego> very common things
20:22:10 <dibblego> but that's just me :)
20:22:14 <fuzan> i'm writing a little presentation, and i thought a few slides covering the very typical functions for coding patterns would be useful.
20:24:09 <monochrom> "some common idioms"
20:25:35 <LoganCapaldo> map and fold are idioms?
20:25:46 <monochrom> Yes.
20:26:22 <LoganCapaldo> I'd think map and fold are the result of removing idioms
20:26:40 <monochrom> That is also right.
20:26:48 <chessguy> ugh, when will precodence rules quit scaring the snot out of me
20:26:52 <LoganCapaldo> Ok, I can live with that
20:27:02 <chessguy> ?spell precodence
20:27:04 <lambdabot> precedence Providence providence Prudence precedences
20:27:07 <chessguy> maybe when i can spell it right
20:27:18 <LoganCapaldo> Stupid providence rules :)
20:27:55 <monochrom> what are providence rules?
20:28:31 <LoganCapaldo> Whatever's on the books in rhode island?
20:28:34 <chessguy> > take 1 "foo"
20:28:36 <lambdabot>  "f"
20:28:52 <chessguy> > (take 1 . words) "foo"
20:28:53 <lambdabot>  ["foo"]
20:29:11 <chessguy> > (hea . words) "foo"
20:29:12 <lambdabot>   Not in scope: `hea'
20:29:15 <LoganCapaldo> > take 1 . words $ foo
20:29:16 <chessguy> > (head . words) "foo"
20:29:17 <lambdabot>   Not in scope: `foo'
20:29:18 <lambdabot>  "foo"
20:29:22 <LoganCapaldo> > take 1 . words $ "foo"
20:29:24 <lambdabot>  ["foo"]
20:29:37 <LoganCapaldo> I feel like the Count
20:29:56 <LoganCapaldo> "How many foos? 1 ah ha ha. 1 Foos"
20:30:29 <chessguy> \s -> i $ p $ h . w $ s
20:30:36 <chessguy> @pl \s -> i $ p $ h . w $ s
20:30:37 <lambdabot> i . p . h . w
20:33:29 <chessguy> @type takeWhile
20:33:31 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
20:33:44 <chessguy> ?src takeWhile
20:33:45 <lambdabot> takeWhile _ []                 =  []
20:33:45 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
20:33:45 <lambdabot>                    | otherwise =  []
20:34:28 * chessguy has a feeling he's going to just need to write a parser
20:34:51 <chessguy> a parsec parser, no less
20:35:08 <dmwit> \o/
20:35:18 <LoganCapaldo> But how quickly can it do the Kessel run?
20:35:28 * LoganCapaldo hearts parsers
20:35:29 <chessguy> 27.3 parsecs
20:35:34 <dmwit> But parsecs is a measure of distance, not speed!
20:35:40 <dmwit> =(
20:35:45 <LoganCapaldo> I wish more problems in programming could be solved by parsers
20:36:07 <chessguy> i think that's going to have to wait for another night though
20:36:12 <sorear> All of them can be solved with interpreters!
20:36:33 <ivanm> LoganCapaldo: why do you wish that?
20:36:48 <ivanm> sorear: could you consider a parser to be a specialised form of interpreter?
20:36:52 * LoganCapaldo gives dmwit a long elaborate explanation involving a blackhole riddled section of space that doesn't really address the speed issue but distracts fans long enough to let it slide
20:36:55 <jcreigh> hmmm...does Han use parsecs as a unit of time in star wars IV?
20:37:19 <LoganCapaldo> ivanm: Mostly I really like writting parsers. I get a kick out of it, I find it fun. I am probably deeply disturbed
20:37:42 <ivanm> jcreigh: I think so...
20:37:48 <ivanm> @google "Han solo" parsecs
20:37:48 <dmwit> It could be that the Kessel run gives a specific amount of time that you have to blast your engines, in which case a distance would be the right measure.
20:37:50 <lambdabot> http://en.wikipedia.org/wiki/Millenium_Falcon
20:38:19 <ivanm> dmwit: one version has the kessel run involving you skirting past a group of black holes...
20:38:34 <LoganCapaldo> ivanm: I so totally did that already
20:38:42 <ivanm> Han's famous comment, that the vessel "made the Kessel Run in less than twelve parsecs", seems a little incongruous, as a parsec is a measure of distance, not time.
20:39:21 <ivanm> LoganCapaldo: oh, whoops, didn't read far up enough
20:39:38 <LoganCapaldo> Of course your version was much less cynical :)
20:39:49 <ivanm> that's the wikipedia version
20:40:20 <ivanm> http://en.wikipedia.org/wiki/Kessel_Run#Kessel_Run
20:40:24 <fuzan> his statement makes sense.
20:40:47 <fuzan> if you actually know the challenge of it to begin with.
20:41:07 <fuzan> to do it in a shorter distance, you must be travelling fast enough to escape the gravitational pull of kessel :)
20:41:09 <dmwit> I'm pretty sure that Lucas actually admitted that he made a mistake there.
20:41:18 <monochrom> Parsec is a unit of time or effort you have spent learning Haskell, or equivalently how much Haskell you know.
20:41:53 <monochrom> "1 parsec" means you have just learned enough Haskell to know how to use parsec. :)
20:42:09 <ivanm> fuzan: escape the gravitational pull of the black hole cluster, not kessell
20:42:16 <sorear> ??? parsec = you are Daan Leijen
20:42:20 <LoganCapaldo> monochrom: is there a parsec to oleg conversion formula?
20:42:21 <fuzan> ivanm: yah, i forget my literature. it's been years :)
20:42:51 <ivanm> fuzan: lol, my brother is a star wars nut (not as big a one as he used to be though) so for ages the only gifts we got him were star wars related
20:43:16 <fuzan> http://www.google.com/search?hl=en&client=firefox-a&rls=org.mozilla%3Aen-GB%3Aofficial&hs=v06&q=1+parsec+to+oleg&btnG=Search
20:43:18 <lambdabot> Title: 1 parsec to oleg - Google Search, http://tinyurl.com/yqyu7j
20:43:42 <sorear> olegs measure skill with type classes.  parsecs measure skill with higher order functions.  imo they are orthogonal
20:43:44 <monochrom> The constant (1 oleg)/(1 parsec) is called the Type Structure Constant.  Its value is still being researched.  Finding its value means alot to understanding the type structure of Haskell.
20:44:08 <sorear> are there any best guesses on its value?
20:44:41 <fuzan> ivanm: yah, some of the books were pretty amazing back in the day as a child :)
20:44:44 <chessguy> @go 1 oleg in parsecs
20:44:46 <lambdabot> http://www.lpi.usra.edu/meetings/lpsc2004/pdf/1275.pdf
20:45:03 <chessguy> that looks promising
20:45:12 <ivanm> fuzan: yeah, the quality of them has really dropped lately :(
20:45:21 <chessguy> Manifestation of gas-dust streams from double stars on lunar seismicity.
20:45:46 <monochrom> haha
20:46:04 <ivanm> @help go
20:46:05 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:46:11 <chessguy> @help google
20:46:11 <lambdabot> google <expr>. Search google and show url of first hit
20:46:12 <dmwit> ?help google
20:46:13 <lambdabot> google <expr>. Search google and show url of first hit
20:46:23 <ivanm> go == short verion of google?
20:46:30 <chessguy> yup
20:46:41 <ivanm> *nod* thought so, was trying to check
20:46:58 <fuzan> ivanm: it's called the lucas effect.
20:47:02 <ivanm> lol
20:49:13 <chessguy> dcoutts++ nice response on -cafe to the hundred-files question
20:54:28 <chessguy> sigh. i must have a dozen haskell projects i'm dying to work on, and not enough time to do any of them justice :(
20:54:54 <ivanm> lol
20:55:10 <LoganCapaldo> Is there no justice in thunderdome!?!?!?
20:55:45 <ivanm> chessguy: why not ask these guys for help? http://haskell.org/haskellwiki/Humor/Homework :p
20:55:47 <lambdabot> Title: Humor/Homework - HaskellWiki
20:58:40 <monochrom> hahahahahah
21:03:26 <alpheus> does the haskell environment (interpreter, I guess) have a facility for getting the documentation or argument list for a function?
21:03:52 <LoganCapaldo> :t yourfun will give the arg list, sorta
21:03:54 <Cale> You can ask for the type of a function
21:03:55 <lambdabot> parse error on input `,'
21:03:56 <chessguy> you mean a pre-defined function?
21:04:10 <Cale> The documentation though, is all on the web
21:04:11 <alpheus> pre-defined, yes
21:04:39 <alpheus> ah, :t function is nice
21:05:09 <chessguy> Main> :t head
21:05:09 <chessguy> head :: [a] -> a
21:05:09 <chessguy> *Main> :i head
21:05:09 <chessguy> head :: [a] -> a        -- Defined in GHC.List
21:05:29 <alpheus> how do you ask for the type of a function?
21:05:35 <Cale> That's what :t does
21:05:37 <chessguy> that's what :t does
21:05:43 <chessguy> @quote stereo
21:05:44 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
21:06:00 * jcreigh waits for the day when two people do "@quote stereo" at the same time
21:06:03 <fuzan> alpheus: the last parameter in a type declaration is the "type" of a function
21:06:17 <chessguy> well, it's the return type
21:06:23 <chessguy> sort of
21:06:25 <fuzan> what's the difference? :)
21:06:39 <Cale> The type of the function is the whole result of :t
21:06:47 <chessguy> right
21:06:53 <Cale> For example, the type of map is (a -> b) -> [a] -> [b]
21:06:58 <fuzan> ah. if that's how you role.
21:07:15 <chessguy> whereas map returns a result of type [b]
21:07:18 <chessguy> for some b
21:08:11 <alpheus> ``max :: (Ord a) => a -> a -> a '' tells me that max takes an argument of type Ord?
21:08:23 <dmwit> If you are using map, you are not sufficiently obfuscating your code.
21:08:35 <monochrom> I know people who say things like "money is a function of time".  For limited use it's ok.  But it is harmful to learning Haskell.
21:08:38 <dmwit> Why use the Prelude when you could use explicit recursion?  Or *monads*??
21:08:56 <fuzan> alpheus: it tells you that max requires: two arguments of type Ord, and outputs a type of Ord
21:09:21 <monochrom> Here Ord is a typeclass, not a type.
21:09:27 <dmwit> Well, it says that "a" must be an instance of Ord.
21:09:33 <chessguy> alpheus: Ord isn't a type, it's a class of types. (Ord a) means that a must be some type the belongs to that class, and that if that's true, then max can take 2 arguments of that type and return a result of the same type
21:10:32 <dmwit> Hmmm... what's a quick lbot example of something that's not Ord?
21:10:43 <dmwit> > max (print 3) (print 4)
21:10:45 <lambdabot>   add an instance declaration for (Ord (IO ()))
21:10:45 <lambdabot>     In the expression: max (p...
21:10:47 <ivanm> dmwit: whats the proper way of obsfucating code then? creating single-use, custom monads? ;-)
21:10:49 <chessguy> @instances-importing Ord
21:10:51 <lambdabot> (), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
21:10:56 <chessguy> anything not in that list :)
21:11:16 <dmwit> ivanm: map f xs === xs >>= return . f === liftM f xs
21:11:25 <dmwit> :t liftM
21:11:28 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
21:11:50 <ivanm> so we should use the RHS directly then?
21:12:04 <dmwit> Ah, well, I guess a talented reader could learn that liftM is just map.
21:12:23 <chessguy> since when is there a 'proper' way to obfuscate code?
21:12:25 <dmwit> But it always leaves you guessing as to which monad you're really in. =)
21:12:59 <ivanm> chessguy: OK, repleace "proper" with "recommended" then ;-)
21:13:39 <monochrom> > max (+) (*)
21:13:41 <lambdabot>   add an instance declaration for (Ord (a -> a -> a))
21:13:41 <lambdabot>     In the expression: ...
21:13:49 <monochrom> OH!
21:13:53 <monochrom> > max max max
21:13:55 <lambdabot>   add an instance declaration for (Ord (a -> a -> a))
21:13:55 <lambdabot>     In the expression: ...
21:13:58 <chessguy> lol
21:14:19 <ivanm> monochrom: maximumBy?
21:14:25 <dmwit> ivanm: I think doing something at the top like "d_b = (<<=)", and then lower, replacing "map f xs" with "(return . f) `d_b` xs" would be pretty good.
21:14:36 <monochrom> Illustrating things not Ord.
21:14:48 <chessguy> @type head
21:14:49 <ivanm> monochrom: oh, OK
21:14:50 <lambdabot> forall a. [a] -> a
21:14:58 <chessguy> @quote trappes
21:14:59 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
21:15:01 <dmwit> s/<<=/=<</
21:15:04 <ivanm> dmwit: *nod*... split up monadic functions as much as possible?
21:15:12 * chessguy wonders what's so dangerous about head
21:15:20 <Cale> chessguy: It can fail.
21:15:21 <dmwit> > head []
21:15:23 <lambdabot>  Exception: Prelude.head: empty list
21:15:29 <monochrom> It cuts your head.
21:15:31 <chessguy> ah
21:20:35 <LoganCapaldo> @type let saferHead [] = Nothing; saferHead (x:_) = Just x in saferHead
21:20:38 <lambdabot> forall a. [a] -> Maybe a
21:21:27 <dmwit> :t toMaybe
21:21:30 <lambdabot> Not in scope: `toMaybe'
21:21:31 <dmwit> :t listToMaybe
21:21:34 <lambdabot> forall a. [a] -> Maybe a
21:21:54 <ivanm> @type let saferHead2 [] = Nothing; saferHead2 xs = Just (head xs) in saferHead2
21:21:56 <lambdabot> forall a. [a] -> Maybe a
21:22:19 <dmwit> > (listToMaybe [], listToMaybe [3,4,5])
21:22:20 <monochrom> maybehead
21:22:20 <lambdabot>  (Nothing,Just 3)
21:22:24 <ivanm> I think this one's nicer, as it uses the head function instead of redefining it
21:22:47 <dmwit> I think the pre-made one is nicer, since it's already written. ;-)
21:22:51 <ivanm> @index listToMaybe
21:22:52 <lambdabot> Data.Maybe
21:22:52 <fuzan> @src head
21:22:53 <lambdabot> head (x:_) = x
21:22:53 <lambdabot> head []    = undefined
21:22:59 <ivanm> dmwit: well, I didn't know it existed, did I?
21:23:04 <ivanm> @src listToMaybe
21:23:04 <lambdabot> listToMaybe []        =  Nothing
21:23:05 <lambdabot> listToMaybe (a:_)     =  Just a
21:23:17 <ivanm> its the same as LoganCapaldo's
21:23:17 <LoganCapaldo> @type fromJust . listToMaybe
21:23:20 <lambdabot> forall a. [a] -> a
21:23:20 <dmwit> I'm just teasing.  I only knew by chance...
21:23:41 <ivanm> > fromJust . listToMaybe [1..4]
21:23:42 <lambdabot>  Couldn't match expected type `a -> Maybe a1'
21:23:50 <ivanm> > fromJust . listToMaybe  $ [1..4]
21:23:52 <lambdabot>  1
21:23:54 <dmwit> > fromJust $ listToMaybe [] -- doesn't fly, just like head
21:23:55 <ivanm> > fromJust . listToMaybe  $ []
21:23:56 <lambdabot>  Exception: Maybe.fromJust: Nothing
21:23:57 <lambdabot>  Exception: Maybe.fromJust: Nothing
21:24:14 <ivanm> > fromMaybe 0 . listToMaybe  $ []
21:24:16 <lambdabot>  0
21:24:21 <ivanm> :)
21:24:28 <fuzan> fromJust isn't quite the best way to handle nothings :)
21:24:40 <ivanm> thought that's useful only if you want a default value
21:24:43 <monochrom> This controversy never ends.
21:24:48 <ivanm> @doc Data.Maybe
21:24:48 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Maybe.html
21:25:01 <ivanm> monochrom: which controversy exactly?
21:25:12 <monochrom> should a function bomb?
21:25:31 <LoganCapaldo> @ty let head [] = Nothing; head (x:_) = Just x; unsafe = fromJust in unsafe . head
21:25:33 <lambdabot> forall a. [a] -> a
21:26:36 <dmwit> ?hoogle [a] -> a
21:26:37 <lambdabot> Prelude.head :: [a] -> a
21:26:37 <lambdabot> Prelude.last :: [a] -> a
21:26:37 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
21:33:02 <ivanm> @type maximum
21:33:05 <lambdabot> forall a. (Ord a) => [a] -> a
21:33:19 <ivanm> oh, of course, maximumBy doesn't have the Ord requirement
21:33:57 <jcreigh> :t maximumBy
21:33:59 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
21:34:17 <dibblego> I don't understand why there exists both maximum and maximumBy when there is newtype
21:34:23 <LoganCapaldo> @type maximumBy (\a b -> if a > b then a else b)
21:34:24 <dibblego> why is maximum special-cased?
21:34:25 <lambdabot> [Ordering] -> Ordering
21:34:30 <LoganCapaldo> err
21:34:39 <LoganCapaldo> @type List.maximumBy (\a b -> if a > b then a else b)
21:34:42 <jcreigh> dibblego: I don't understand. How does newtype help you there?
21:34:42 <lambdabot> [Ordering] -> Ordering
21:35:02 <LoganCapaldo> Did hoogle just totally lie?
21:35:17 <dibblego> jcreigh, maximumBy exists so you can define your own ordering, but of course, you just newtype and instance it yourself
21:35:22 <jcreigh> LoganCapaldo: no. Ordering is an instance of Ord.
21:35:35 <emu> maximumBy is kinda a throwback
21:35:39 <dibblego> and use Ord
21:35:53 <ivanm> dibblego: what happens if you want to define a custom ordering? and don't want to newtype it?
21:35:55 <dibblego> I could understand maximumBy without newtype
21:36:03 <dibblego> ivanm, then you have a contradiction?
21:36:10 <jcreigh> > LT > GT
21:36:12 <lambdabot>  False
21:36:13 <emu> but sometimes its nice to be able to define it w/ just a function
21:36:13 <ivanm> why?
21:36:21 <emu> for example, if your ordering function depends on context
21:36:23 <LoganCapaldo> dibblego: isn't that a lot of boilerplate if you just want to do some quick spontaneou ordering?
21:36:24 <dibblego> "I want a new type (implied by "want to define a custom ordering")" and "I don't want a new type"
21:36:36 <ivanm> in one program I did, I wanted to sort lists such that shorter lists are greater than longer lists
21:36:46 <ivanm> its not a newtype
21:37:03 <dibblego> LoganCapaldo, then, why don't we all start doing that and do away with type-classes altogether? why special-case here?
21:37:09 <ivanm> using newtype would involve wrapping each list into this newtype just for a maximumby or sorting, then unwrapping
21:37:11 <dibblego> ivanm, yes it is
21:37:25 <dibblego> lists already have ordering
21:37:33 <ivanm> I wanted a different ordering
21:37:35 <dibblego> you have a type called IvanmList
21:37:50 <dibblego> or something like that, but definitely not list
21:37:55 <ivanm> I didn't want a new type, as then I'd have to re-define maps, etc
21:38:03 <dibblego> why?
21:38:16 <dibblego> surely you can write IvanmList a -> [a]
21:38:27 <emu> look
21:38:46 <dibblego> whichever way you choose, my question is "why is maximum special-cased?"
21:39:00 <dibblego> what criteria do you use to determine that you should provide that additional function?
21:39:02 <chessguy> @quote heatsink
21:39:03 <lambdabot> heatsink says: @pl (\y -> you y off)
21:39:03 <emu> > let c = 3 in maximumBy (\a b -> (a `mod` c) `compare` b) [1,2,3,4,5,6]
21:39:05 <lambdabot>  6
21:39:07 <chessguy> that's a funny one
21:39:10 <LoganCapaldo> @hoogle minimumBy
21:39:11 <lambdabot> List.minimumBy :: (a -> a -> a) -> [a] -> a
21:39:11 <lambdabot> Data.List.minimumBy :: (a -> a -> Ordering) -> [a] -> a
21:39:12 <emu> it's not special cased at all
21:39:16 <dibblego> sure it is
21:39:19 <emu> there's a whole set of such functions
21:39:24 <emu> nubBy, sortBy
21:39:25 <ivanm> dibblego: *nod*... but writing (Int,[(Char,[Int])]) is easier than (Int,NewList (Char, NewList Int))
21:39:28 <LoganCapaldo> @hoogle sortBy
21:39:28 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
21:39:44 <emu> you .. cannot .. incorporate lexical context into an instance definition
21:39:55 <emu> therefore there exists at least one use case for *By functions
21:40:36 <ivanm> @pl (\y -> you y off)
21:40:36 <lambdabot> flip you off
21:40:40 <ivanm> lol
21:40:52 <dibblego> unless, for every type-class, we write an additional HOF function
21:41:33 <emu> if you don't address the point I made above, that HoF will be written, by someone eventually
21:41:46 <ivanm> HoF = ?
21:41:49 <emu> may as well have it in the prelude
21:41:53 <jcreigh> high order function
21:41:55 <emu> or report rather
21:41:58 <LoganCapaldo> higher order fdunction
21:42:02 <ivanm> ahhh
21:42:12 <ivanm> I quite like the *By functions
21:42:25 <ivanm> because sometimes you want to manipulate them according to a different rule
21:42:42 <monochrom> I'm writing an HOF function ATM moment for the GHC compiler. :)
21:42:48 <emu> the key is not just different, but sometimes also dependent on lexical context
21:43:01 <ivanm> for example, if you want to do something like: map sort . groupBy foo . sortBy bar
21:45:24 <chessguy> @quote monochrom
21:45:25 <lambdabot> monochrom says: These 113 blogging accounts of course don't cost me.  But I still get the feeling of lying around with 113 prostitutes... XD
21:46:00 <monochrom> 113 is a prime number.
21:46:50 <ivanm> the relevance of 113 being prime is...?
21:47:38 <monochrom> nil
21:48:10 <ivanm> oh
21:48:24 * ivanm thought there was some fundemantal, profound relationship
21:51:47 <jcreigh> sjanssen: ping
21:52:47 <dons> re.
21:56:05 <chessguy> @quote your_mom
21:56:06 <lambdabot> your_mom says: Will you stop telling dumb jokes about me please?
21:56:16 <LoganCapaldo> 11 -> 113 <- 13
21:56:23 <LoganCapaldo> 11 and 13 are also prime
21:56:24 <chessguy> on that note, ...
21:57:27 <monochrom> prime numbers make people fall asleep?
21:57:59 <ivanm> well, it makes chessguy fall asleep...
21:58:24 <jcreigh> Hopefully, movie-villians won't figure this out. "You'll never get away with it!" "139!" "zzzzzz"
21:58:41 <ivanm> there exists a person p, such that if at least two prime numbers a and b are utterred in the #haskell IRC channel, p will fall asleep
21:58:56 <ivanm> jcreigh: lol
21:59:14 <monochrom> I do feel sleepy.
21:59:55 <ivanm> @localtime monochrom
21:59:56 <lambdabot> Local time for monochrom is Tue Apr 10 00:59:16
22:00:09 <ivanm> maybe the fact that its after midnight for you has something to do with it?
22:00:12 <ivanm> hmmm????
22:00:57 <emu> naw
22:01:09 <emu> its 1 am here too, i wish i felt sleepy at this time
22:01:29 <ivanm> lol
22:02:05 <emu> ivanm: does that hold for every person p?
22:02:23 <ivanm> no, I did state that "there exists _a_"
22:02:36 <ivanm> probably should have been "there exists at least one person p, ..."
22:02:47 <emu> oh, i was hoping to generalize the result
22:03:20 <jcreigh> well, there's a finite number of people in #haskell, and if they keep falling asleep, sooner or later, there won't any people left with the prime-knockout property.
22:03:41 <jcreigh> so all we have to do is mention enough primes, and ivanm's statement will become false. :)
22:03:45 <ivanm> well, seeing as how _I'm_ not asleep, and that crypto is the only subject I'm doing atm where I haven't had the urge to sleep...
22:03:57 <emu> there also exists a person q such that if at least two prime numbers a and b are uttered in the #haskell channel they become overly interested
22:04:12 <ivanm> jcreigh: so what happens when there's exactly one person (ignoring ChanServ and lambdabot) left?
22:04:22 <LoganCapaldo> then p = q
22:04:26 <ivanm> he/she/it just keeps stating more prime numbers until they knock themselves out?
22:04:34 <ivanm> lol
22:04:37 <LoganCapaldo> so he has dreams about primes
22:04:44 <ivanm> heh
22:05:04 <ivanm> well, talking about talking about primes seems to knock some people out as well...
22:05:48 <monochrom> We have a healthy interest in logic. :)
22:05:56 <emu> it is semi-decidable
22:06:07 <ivanm> lol
22:09:30 <Gwern> so I've been looking... are there any resources useful for simulating global nuclear war in Haskell
22:10:03 <jcreigh> Would you like to play a game?
22:10:26 <ivanm> Gwern: only simulating?  that's no fun!!!
22:10:45 <Gwern> jcreigh: eventually, I would like to play Global Thermonuclear War on my computer
22:11:04 <jcreigh> wouldn't you like to play a nice game of Chess?
22:11:07 <Gwern> I hope this will be such a pleasuable prospect I will actually buckle down and learn Haskell through doing a sizable project
22:11:10 <Gwern> jcreigh: not really
22:11:14 * Gwern is more for go
22:11:18 <jcreigh> oh, you're serious.
22:11:28 <Gwern> serious... like a fox??
22:11:34 <jcreigh> You actually *do* want a simulation of that?
22:11:45 <jcreigh> (sorry...I thought you were just going for "War Games" references)
22:11:58 <Gwern> jcreigh: yes, I am envious of me friends' DEFCON games
22:12:02 <Gwern> but I run Linux...
22:12:32 <Gwern> backed up by the full power of Haskell and #haskell, surely this is not a foolish fond fancy or demented vagary of a madman to think so?
22:12:40 <ivanm> Gwern: IIRC, you can play defcon on linux...
22:12:53 <Gwern> ivanm: introversion hasn't released it yet, no
22:13:01 <ivanm> hey gour!
22:13:58 <ivanm> Gwern: hmmm.... I thought I remembered some introversion games being listed on packages.gentoo.org ... but I can't find them now
22:14:20 <Gwern> can't imagine why. none of them had anywhere near a Free license
22:14:39 <Gwern> they haven't even released source to darwinia or defcon at all, last I heard
22:14:41 <ivanm> well, darwinia is there, as well as a demo
22:14:45 <ivanm> binary version
22:15:07 <Gwern> well I'll be damned. what's that doing there?
22:15:25 * Gwern emerges darwinia w/o guilt. I already bought a copy
22:15:44 <ivanm> http://forums.gentoo.org/viewtopic-t-503090-highlight-defcon.html?sid=441e6b9d2bb12e4402c8b03495ce0e0d
22:15:46 <lambdabot> http://tinyurl.com/2zx3sy
22:15:49 <dons> heya Gwern. still using xmonad?
22:15:51 <ivanm> apparently, defcon runs under wine...
22:16:15 <ivanm> oh, it's single player only :(
22:16:24 <Gwern> dons: yes
22:16:48 <Gwern> I had some bitching trouble with my little prompt function and with /bin/sh not being like bash, but nothing that was xmonad's fault.
22:16:51 <Gwern> I think
22:17:04 <dons> great. we're finalising the 0.1 release, and an article now about how to write xmonad.
22:17:21 <dons> so if you've any comments on its flaws and features, that's useful.
22:17:30 <Gwern> anyway, so ok, there's no nuclear libaries for haskell yet. are there any libraries at all that might be helpful
22:17:43 <Gwern> dons: hmm. I emailed sjannssen something like that
22:17:52 <dmwit> "nuclear"?
22:17:57 <dons> we should also have xmonad@haskell.org set up in the next day or so.
22:18:04 <ivanm> Gwern: here's an ebuild for the linux client of defcon: http://bugs.gentoo.org/show_bug.cgi?id=168940
22:18:06 <lambdabot> Title: Gentoo Bug 168940 - games-strategy/defcon-demo-1.4_beta2.ebuild (New Package)
22:18:10 <Gwern> dmwit: I pronounce it properly :)
22:18:19 <Gwern> ivanm: interesting
22:18:39 <Gwern> dons: actually, I just remembered
22:18:51 <Gwern> those odd bugs when switching groups keep popping up under load
22:19:44 <Gwern> as in, switching between groups is just fine when I'm not emerging a couple of things, but when load starts going up, the apps-moving-to-other-groups behaivour manifests, as well as not maximizing when opened in the second group
22:21:02 <dons> ok. that's interesting. X probably has a hard time keeping everything responsive under load.
22:21:52 <Gwern> dons: well, what I see as interesting is that it happens at all - I would expect switching and opening new programs to all slow down under load, not manifest different behaivour
22:22:23 <Gwern> (that's something I associate with race conditions, although I don't see anything in xmonad that would be a candidate)
22:22:25 <jcreigh> I've seen slowness when switching under load, but not strange behavior
22:24:33 <dons> what exactly happens?
22:25:24 <Gwern> there seem to be two things. I have two workgroups. I start things in #1, switch to #2. things opened up in #2 only take up a portion of the screen, and shrink in size as more are opened up
22:25:46 <Gwern> the second thing is I can then switch back to #1, and everything opened up in #2 follow me back to #1!
22:26:13 <Gwern> the third thing is that switching to #1 or #2 maximizes the root window
22:27:31 <dons> workgroups? you mean what we call 'workspaces' ?
22:27:44 <Gwern> dons: I think so
22:27:47 <dons> hmm. are you using current xmonad?
22:27:56 <dons> the following-me-back bug is fixed, as far as I know.
22:28:00 <Gwern> seems like every wm uses different terminology, and I started with rp, so that sort of infected me
22:28:08 <Gwern> dons: well, those popped up today
22:28:17 <dons> regaring size in #2, is that in a tiled mode?
22:28:33 <Gwern> I don't know which ones popped up on which versions today, I'm afraid. I was doing a lot of darcs pulling while fixing my shell problem
22:28:35 <dons> this behaviour you describe is very strange.
22:28:52 <Gwern> dons: I believe it acts as if it were fullscreen, from what I remember
22:28:56 <dons> so, how would I reproduce it here?
22:29:07 <dons> can you compose a set of keystrokes i can type to exactly reproduce the bug?
22:29:30 <Gwern> dons: well, you could starting 4 emerges simultaneously with -j > 2 :)
22:29:54 <mwc> Let's say I really, really, really want to coerce Double -> Word64 in a bitwise way
22:29:59 <Gwern> dons: I cannot. as I said, the only thing I've correlated it with is what I've said, while under serious system load
22:30:15 <mwc> is there a nonpainful way of doing this? The only thing I can think of is Storeable
22:30:27 <dons> ok.
22:30:37 <dons> mwc, unsafeCoerce#
22:30:59 <dons> but there's no guarantee that a Double is represented in the heap as a 64 bit value.
22:31:23 <dons> mwc, what are you trying to do though?
22:31:42 <mwc> Take the output of an iterated chaotic map as a PRNG
22:31:48 <dons> > decodeFloat (pi :: double)
22:31:49 <lambdabot>        add (Floating double) to the expected type of an expression
22:31:49 <lambdabot>     In the...
22:31:51 <dons> > decodeFloat (pi :: Double)
22:31:53 <lambdabot>  (7074237752028440,-51)
22:32:01 <mwc> and yes, I'm aware it's not statistically sound ;)
22:32:13 <dons> so you want to just coerce the Double value to a Word64?
22:32:17 <dons> and hope the bits work?
22:32:22 <dons> or truncate it?
22:32:42 <dons> it might be safer to do a decodeFloat, then treat the fst componenent as a Word64
22:32:45 <dons> :t decodeFloat
22:32:47 <lambdabot> forall a. (RealFloat a) => a -> (Integer, Int)
22:32:51 <vincenz> Hi
22:32:51 <lambdabot> vincenz: You have 1 new message. '/msg lambdabot @messages' to read it.
22:33:14 <dons> > let coerce :: Double -> Word64; coerce = fromIntegral . fst . decodeFloat in coerce pi
22:33:14 <mwc> I just need some bitwise-operable representation of a given double. Any representation. Except the trivial ones ;)
22:33:15 <lambdabot>  7074237752028440
22:33:34 <vincenz> dcoutts: re fusion, you guys do do CPS, it's just... already there, cause you work at one level higher of abstraction
22:33:37 <mwc> yeah, that's what I was doing before, but I'd like to make use of the exponent bits.
22:33:43 <dons> vincenz: hmm..
22:33:51 <vincenz> come to #oasis
22:34:28 <vincenz> dons: why the hmm?
22:34:39 <dons> yeah, so the main thing that's problematic with the C++ stuff is how you recognise what kind of combinator/loop you're dealing with.
22:34:48 <mwc> Huh? GHCi parses unsafeCoerce# as unsafeCoerce # ?!
22:34:50 <dons> as they fuse in different ways: they have different state transiations.
22:35:00 <dons> i guess you try to pattern match loop bodies?
22:35:03 <vincenz> dons: weell I just realised, you guys do pattern-based aprpoach, it's just your set of patterrns is clearn, namely the higherlevle constructs
22:35:05 <dons> to work out if its a map, or a filter, or a fold?
22:35:10 <vincenz> dons: no, version2.0 does not requrie patternmatch
22:35:10 <dons> right.
22:35:14 <dons> our loop bodies all have names.
22:35:18 <vincenz> corerct
22:35:21 <dons> i.e. foldl, scanl, foldr, reverse.
22:35:23 <vincenz> but version2.0 does any loop
22:35:27 <vincenz> any nested set of loops
22:35:33 <vincenz> with certain constraints on iterators
22:35:35 <dons> so its trivial to work out how to fuse, say, foldr . scanl . reverse
22:35:36 <mwc> Prelude GHC.Prim> unsafeCoerce#
22:35:36 <mwc> <interactive>:1:13: parse error (possibly incorrect indentation)
22:35:55 <dons> vincenz: so the first phase for you is to identify what kind of loop you've got?
22:35:57 <vincenz> dons: yes and looking at intersprerse for instance, that's a CPSIfied loop
22:36:00 <vincenz> dons: not anymore
22:36:03 <dons> then once you've reconstructed the 'names' for each loop
22:36:05 <vincenz> nope
22:36:06 <dons> then go ahead and fuse.
22:36:09 <vincenz> I don't work patternbased
22:36:16 <vincenz> I use a pull mechanism, not a push
22:36:24 <vincenz> I transform ddt operations to DC-operations
22:36:28 <dons> its not quite CPS, I would arge.
22:36:29 <vincenz> (delimited continuation)
22:36:35 <vincenz> dons: it's what my cps would generate
22:36:37 <dons> its an unfoldr, its close.
22:36:55 <dons> there's a similarity, anyway
22:36:56 <vincenz> well more or less
22:37:02 <vincenz> I don't have data types and all that
22:37:05 <vincenz> and boxed types
22:37:15 <vincenz> dons: I prefer this in #oasis howeverr
22:37:18 <dons> can you state precisely what is fusible?
22:37:25 <mwc> dons, the short answer is that i'm interested in the bit-by-bit statistics of the stream of numbers. If I could get [Double] -> [Bool], I'd be just as happy
22:37:30 <dons> oh, btw, i turned off logging for #oasis
22:37:35 <vincenz> thx
22:47:07 <sjanssen> jcreigh: pong
22:47:22 <jcreigh> sjanssen: oh, hey, now I forgot what I was going to ask. :)
22:47:41 <jcreigh> almost done with that patch..
22:47:53 <sjanssen> noice
22:48:04 <dons> sjanssen: i've set up a tmr article repo.
22:48:13 <dons> i think maybe you should host it in ~sjanssen
22:48:18 <dons> so we can both push via ssh
22:49:31 <dons> sjanssen: the repo is here, darcs get http://www.cse.unsw.edu.au/~dons/code/papers/xmonad-tmr
22:49:32 <lambdabot> Title: Index of /~dons/code/papers/xmonad-tmr
22:49:37 <ski> vincenz : CPS ?
22:49:38 <dons> do you want to leave it there, and commit via darcs send
22:49:49 <dons> or stick it on ~sjanssen , next to the xmonad repo?
22:50:01 <ivanm> hey everyone, I'm thinking of making myself a "This t-shirt is a munition" shirt (http://www.cypherspace.org/adam/uk-shirt.html)...
22:50:22 <ivanm> is it possible to get RSA in haskell down small enough to use instead of perl?
22:51:01 <dons> ivanm: yeah,
22:51:03 <dons> there's 1 liners.
22:51:27 <dons> ivanm: here's a nice one, http://www.cse.unsw.edu.au/~dons/code/nobench/imaginary/jl_rsa/jl_rsa.hs
22:51:29 <sjanssen> dons: darcs send is fine
22:51:29 <lambdabot> http://tinyurl.com/2yakxj
22:51:37 <dons> sjanssen: ok. we'll leave it at that url then?
22:51:44 <sjanssen> dons: yeah
22:51:53 <dcoutts> @yarr!
22:51:54 <lambdabot> I want me grog!
22:52:00 <dons> ivanm: here's another nice one, http://www.cse.unsw.edu.au/~dons/code/nobench/real/rsa/rsa.hs
22:52:06 <dons> you could shrink that a bit, I warrant
22:56:05 <roconnor> I often feel like a squaring function should be part of the Num class
22:56:31 <glguy> why?
22:56:35 <roconnor> then we wouldn't have to always rewrite the power function
22:56:49 <roconnor> ... probably the power function should be part of the class too
22:57:06 <roconnor> although overriding the squaring function should work in most cases
22:57:33 <sjanssen> I don't get it
22:57:35 <glguy> square x = x * x
22:57:37 <sjanssen> what's wrong with:
22:57:41 <sjanssen> @src (^)
22:57:42 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
22:57:59 <roconnor> glguy: square x = x*x `mod` p
22:58:02 <glguy> ?type (^)
22:58:05 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
22:58:24 <glguy> roconnor: did you forget a ()
22:58:35 <roconnor> glguy: probably
22:58:39 <glguy> or do you mean something different than I thought you would
22:58:40 <roconnor> glguy: square x = (x*x) `mod` p
22:58:42 <jcreigh> is it really nessesary to say "{#- UNPACK -#}" on all those maps in StackSet?
22:59:05 <sjanssen> jcreigh: feel free to delete them
22:59:29 <sjanssen> we compile with -funbox-strict-fields now
22:59:38 <dons> yeah.
22:59:40 <sjanssen> and UNPACK is useless on maps anyway
22:59:44 <dons> they were just there to save a flag.
22:59:47 <dons> and they're not needed on Map
22:59:52 <jcreigh> should "current" still be unpacked?
23:00:00 <jcreigh> or is that covered by the flag?
23:00:05 <sjanssen> jcreigh: you can just drop all the UNPACKs
23:00:07 <glguy> roconnor: where does that mod come from... Num doesn't say anything about modular arithmetic, does it?
23:00:09 <jcreigh> yay.
23:00:31 <roconnor> glguy: but there should be a modP typeclass
23:00:33 <dons> jcreigh: as long as the fields are strict, then -funbox* will unpack them (if that's posisble)
23:00:50 <jcreigh> ah, okay.
23:00:56 <dons> sjanssen: are you able to pull the xmonad-tmr repo?
23:01:02 <dons> (and build the paper stub?)
23:01:07 <glguy> roconnor: If you would make a Squarable typeclass, this would take care of itself and you could reuse your code :)
23:01:28 <sjanssen> dons: amazingly, I haven't installed latex yet.  I can pull fine, though
23:02:30 <roconnor> glguy: Would (^) require the first argument to be of the Squareable class?
23:02:59 <sjanssen> I don't see how squaring needs to be separate from (*)
23:02:59 <glguy> no, you'd have to reimplement that once
23:03:03 <glguy> but only once
23:04:56 <dons> sjanssen: ok. better get latex installed
23:05:00 <dons> we have 4 days :-)
23:05:06 <sjanssen> dons: yep, compiling now
23:05:14 <roconnor> I should write my own Prelude.
23:07:49 <dons> sjanssen: so i'm just going to sketch out a rough structure now.
23:07:58 <dons> do you know how long typical tmr articles hvae been?
23:08:58 <jcreigh> :q
23:09:07 <jcreigh> wrong window. :)
23:12:15 <roconnor> sjanssen: oh you are right, the mod p case is a bad example.
23:12:57 <sjanssen> dons: roughly, yeah
23:13:10 <vincenz> @where dons
23:13:10 <lambdabot> http://www.cse.unsw.edu.au/~dons
23:13:22 <roconnor> sjanssen: I have a fast squaring function for my computable-real numbers
23:13:37 <roconnor> sjanssen: I can't remember if squaring a polynomial is faster than multiplicaiton.
23:14:37 * glguy considers joining the NNW-NP project
23:15:22 <roconnor> @where NNW-NP
23:15:23 <lambdabot> I know nothing about nnw-np.
23:15:30 <glguy> http://nnw-np.sourceforge.net/html.php
23:15:31 <lambdabot> Title: NNW-NP North North West non-polynomial daughter of NNW
23:16:33 <roconnor> they need terrible new members?
23:16:48 <glguy> I'm trying to decide if a text generator created this site
23:16:54 <glguy> or if a maniac did on his own
23:17:22 <glguy> I feel like I'm reading something from that computer science paper generator
23:17:51 <glguy> except with the grammar checker reversed
23:19:00 <sjanssen> glguy: it reminds me of @keal
23:21:24 <glguy> @keal
23:21:24 <lambdabot> need to plan a fieldtrip to Frederick B. Mancoff of Freescale Semiconductor
23:21:42 <QtPlatypus> glguy: Maniac
23:22:00 <ski> hm .. eniac .. maniac .. ?
23:22:36 <glguy> that he was able to produce so much text suggests he has no family to have him commited to an institution... sad..
23:22:38 <vincenz> dcoutts: ping
23:22:57 <glguy> otherwise they'd have hauled him off already
23:24:14 <DRMacIver> Hm
23:24:35 <DRMacIver> How does one usually handle user defineable infix operators in parsing a language?
23:24:43 * DRMacIver is having trouble getting his head around how it should work
23:24:55 <sjanssen> dons: the makefile works fine
23:26:28 <glguy> Have any of you seen the advertisement for Kaleidoscope data base?
23:26:49 <glguy> it ran in some visual basic monthly magazine one of the guys gets at work
23:27:00 <glguy> it was full of similar maniac ravings
23:27:08 <glguy> which was weird for a visual studio magazine
23:27:23 <therp> good morning
23:27:35 <glguy> When we called the number listed, it ended up being a Vermont state mental hospital
23:27:59 <glguy> we talked to the guy (twice, second time to prove it to the rest of the coworkers)
23:28:25 <glguy> I ought to scan that in and post it to reddit or something
23:28:52 <ski> 3005-02-12 NNW- 3. The physical notion of indeterminism, another non-Tu (html)
23:28:56 <dibblego> look the phone number up in the phonebook and scan that too
23:29:08 <ski> (note the date)
23:29:18 <glguy> dibblego: ?
23:29:32 <glguy> the phone number is on the advertisement itself
23:29:36 <glguy> OH
23:29:41 <glguy> you mean to show what it's the number of?
23:29:49 <dibblego> glguy, yes, but how does an observer know it is the Vermont mental hospital?
23:29:52 <glguy> you can find that using AT&T's online directory or such
23:29:52 <dibblego> yes
23:29:58 <dibblego> yeah but readers are lazy
23:30:02 <glguy> :-p
23:30:03 <dibblego> and not always American :)
23:30:07 <glguy> ah
23:30:37 <dcoutts> hia vincenz
23:30:58 <glguy> It's hard to google for, because the "Kaleidoscope Database" (not space between data and base) is an ovarian research database
23:31:08 <glguy> s/not/no
23:31:25 <jcreigh> sjanssen: patch sent.
23:33:16 <jcreigh> sjanssen: some of it might be a little ugly...sorry, it's late, I just wanted to get the code out there where other eyeballs can see it and think of clever ways to fix it.
23:35:56 <jcreigh> BTW, I'm probably going to remove "dmenu" before 0.1...I haven't heard back from the dmenu guy since I sent him the second version of my patches. So I think the xmonad-dmenu-xinerama procedure will be "download this patch for dmenu, stick this in your Config.hs"
23:36:10 <ivanm> dons: thanks for those RSA codes... couldn't respond before because I was suddenly called to dinner
23:36:19 <jcreigh> No sense cluttering up xmonad with stuff that isn't going to work out of the box anyway.
23:36:25 <ivanm> but the second one looks a bit _too_ long ;-)
23:37:13 <glguy> woot, I found a copy of the ad in my inbox
23:37:32 <dons> jcreigh: yeah ok.
23:37:39 <dons> jcreigh: you could just host a fork (or we could)
23:38:23 <glguy> http://kakapo.scannedinavian.com/~eric/kaleidoscope.pdf
23:38:52 <jcreigh> dons: I have some webspace; I think I'll just host a patch against dmenu there with some instructions.
23:39:01 <ivanm> dons: who's john launchbury? the guy who originally wrote that RSA program?
23:39:37 * jcreigh doesn't feel like forking
23:40:01 <dons> he's now the CEO of galois connections, and the author of a number of very interesting papers in haskell, including the ST monad, some of the foldr/build papers, and others.
23:40:20 <ivanm> *nod*
23:40:38 * glguy adds that to the list of things to remember
23:41:01 <ivanm> dons: I can't work out what that bit down the bottom is meant to be... obviously, the top bit spells out RSA...
23:42:03 <jcreigh> anyway, time to hit the sack. 'night all.
23:45:13 <vincenz> hiya ADEpt
23:45:34 <ADEpt> vincenz: hi
23:50:40 <sjanssen> jcreigh++ your patch seems to fix the 'phantom windows' bug
23:51:10 <dons> sjanssen: oh, which bug is this?
23:52:07 <sjanssen> switch to an empty ws, create some windows, switch to another empty ws, switch back.  For some reason the windows aren't moved back onto the screen
23:52:32 <sjanssen> now, rebuild and restart xmonad.  The bug is gone!
23:54:47 <dons> ah yes.
23:55:09 <dons> ok, dcoutts and i are thinking up evil schemes for getting the XCB binding written now
23:55:18 <dons> as a motivating example for a Data.Binary paper.
23:55:20 <ivanm> dons: in http://www.cse.unsw.edu.au/~dons/code/nobench/imaginary/jl_rsa/jl_rsa.hs, I can't work out what that bit down the bottom is meant to be... obviously, the top bit spells out RSA...
23:55:22 <lambdabot> http://tinyurl.com/2yakxj
23:55:55 <sjanssen> dons: and these schemes are?
23:57:13 <dcoutts> sjanssen: generate xcb packet serialisation code using the xcb xml protocol descriptions and use data.binary
23:57:14 <dons> well, that we do it :-)
