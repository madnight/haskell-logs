00:01:39 <ivanm> @pl \xs -> map ((/) (sum . map length $ xs) . length) $ xs
00:01:40 <lambdabot> map =<< (. length) . (/) . sum . map length
00:01:54 <ivanm> is there a more efficient way of doing this?
00:02:31 <ivanm> I have a list of Ints (with repeats), and want to know the proportion any single value has to the number of values
00:07:46 <dons> ivanm, hmm, dump them into a Map Int Int ?
00:08:02 <glguy_> > foldl' (\ m x -> Data.Map.insertWith (+) x 1 m) (Data.Map.empty) [1,2,3,1,1,2]
00:08:03 <lambdabot>   Not in scope: `Data.Map.empty'
00:08:05 <ivanm> *shrug* wouldn't know where to start
00:08:21 <dons> insertWith (+), basically a table of Int to their counts
00:08:37 <dons> glguy_: M.
00:08:50 <glguy_> > foldl' (\ m x -> M.insertWith (+) x 1 m) (M.empty) [1,2,3,1,1,2]
00:08:51 <dons> > foldl' (\ m x -> M.insertWith (+) x 1 m) M.empty [1,2,3,1,1,2]
00:08:52 <lambdabot>  fromList [(1,3),(2,2),(3,1)]
00:08:52 <lambdabot>  fromList [(1,3),(2,2),(3,1)]
00:08:58 <dons> > foldl' (\ m x -> M.insertWith (+) x 1 m) M.empty [1,2,3,1,1,2,5]
00:08:59 <lambdabot>  fromList [(1,3),(2,2),(3,1),(5,1)]
00:09:26 <dons> > let t = foldl' (\ m x -> M.insertWith (+) x 1 m) M.empty [1,2,3,1,1,2,5] in (M.size t, M.assocs t)
00:09:28 <lambdabot>  (4,[(1,3),(2,2),(3,1),(5,1)])
00:09:47 <ivanm> dons: I was hoping for something in terms of proportions (e.g. so I could tell that 1 made up 50% of the list)
00:09:52 <glguy_> > M.fold (+) 0 $ foldl' (\ m x -> M.insertWith (+) x 1 m) (M.empty) [1,2,3,1,1,2]
00:09:53 <lambdabot>  6
00:10:11 <dons> > let s = [1,2,3,1,1,2,5] ; t = foldl' (\ m x -> M.insertWith (+) x 1 m) M.empty s in (length s, M.assocs t)
00:10:12 <lambdabot>  (7,[(1,3),(2,2),(3,1),(5,1)])
00:10:25 <glguy_> ivanm, once you know how many of each there are, the percentage is trivial
00:10:37 <dons> > let s = [1,2,3,1,1,2,5] ; t = foldl' (\ m x -> M.insertWith (+) x 1 m) M.empty s in let l = length s in [ (k,v/l) | (k,v) <- M.assocs t ]
00:10:38 <lambdabot>   add an instance declaration for (Fractional Int)
00:10:39 <lambdabot>     In the expression: v /...
00:10:44 <ivanm> glguy: the point is, rather than traversing through the list twice...
00:10:51 <dons> > let s = [1,2,3,1,1,2,5] ; t = foldl' (\ m x -> M.insertWith (+) x 1 m) M.empty s in let l = length s in [ (k,v/fromIntegral l) | (k,v) <- M.assocs t ]
00:10:53 <lambdabot>  [(1,0.42857142857142855),(2,0.2857142857142857),(3,0.14285714285714285),(5,0...
00:11:39 <dons> > let s = [1,2,3,1,1,2,5] ; t = foldl' (\ m x -> M.insertWith (+) x 1 m) M.empty s in let l = length s in map (uncurry (printf "%d := %2f, ")) [ (k,v/fromIntegral l) | (k,v) <- M.assocs t ]
00:11:40 <lambdabot>  Add a type signature
00:11:48 <ivanm> M = Data.Map? how do you do named imports again?
00:11:49 <dons> > let s = [1,2,3,1,1,2,5] ; t = foldl' (\ m x -> M.insertWith (+) x 1 m) M.empty s in let l = length s in map (uncurry (printf "%d := %2f, ")) [ (k,v/fromIntegral l) | (k,v) <- M.assocs t ] :: [String]
00:11:50 <lambdabot>  ["1 := 0.42857142857142855, ","2 := 0.2857142857142857, ","3 := 0.1428571428...
00:11:59 <glguy_> import qualified Data.Map as M
00:11:59 <dons> > let s = [1,2,3,1,1,2,5] ; t = foldl' (\ m x -> M.insertWith (+) x 1 m) M.empty s in let l = length s in map (uncurry (printf "%d := %.2f, ")) [ (k,v/fromIntegral l) | (k,v) <- M.assocs t ] :: [String]
00:12:01 <lambdabot>  ["1 := 0.43, ","2 := 0.29, ","3 := 0.14, ","5 := 0.14, "]
00:12:11 <ivanm> dons: that paired version was good enough....
00:12:29 <dons> do I get the job?
00:12:49 * ivanm just realised that he doesn't want to divide by the number of items in _that_ list :s
00:12:56 <ivanm> thanks anyway, dons
00:13:19 <dons> bah, varying requirements
00:14:58 * ivanm is implementing Kasiski's method for vigenere cracking
00:16:00 <ivanm> I'm actually not sure atm what exactly I want it to be a percentage of... number of times 1 appears in the list, I think...
00:16:22 <ivanm> want the relative frequency of the factors of a list of numbers
00:16:39 <dons> well, you see how we use Data.Map to count occurences?
00:16:43 <dons> just use that in some way
00:16:53 <ivanm> *nod*... thanks
00:17:06 <ivanm> now if only I was coding on the computer I'm using IRC :s
00:19:09 <ivanm> how do I import Data.Map as M? I've never done it before, so I'm unsure of the syntax
00:19:23 <sjanssen> import qualified Data.Map as M
00:19:25 <magic_user> can haskell be used to do scripting like bash or scsh?
00:19:33 <magic_user> www.scsh.net
00:19:34 <ivanm> ahhh, thanks sjanssen
00:19:45 <sjanssen> @where hsh
00:19:45 <lambdabot> http://software.complete.org/hsh
00:19:55 <sjanssen> magic_user: there's one attempt ^^^
00:22:34 <ivanm> @type foldl' (\ m x -> M.insertWith (+) x 1 m) M.empty
00:22:37 <lambdabot> forall b a. (Num a, Ord b) => [b] -> M.Map b a
00:23:26 <hpaste>  fuzan pasted "type for class?" at http://hpaste.org/1226
00:23:32 <fuzan> b
00:23:51 <hpaste>  fuzan annotated "type for class?" with "error" at http://hpaste.org/1226#a1
00:25:25 <fuzan> I'm beginning to implement type-checking in a compiler I'm writing. I'm using these typeclasses to simplify some code along with a state monad. however, I can't seem to get the type correct on one of the classes to play nicely with my state
00:25:34 <fuzan> well, at least that's what I think i'm doing incorrectly.
00:27:20 <ivanm> @pl (\ m x -> M.insertWith (+) x 1 m)
00:27:21 <lambdabot> ((M .) .) . flip (flip (insertWith (+)) 1)
00:30:15 <fuzan> @unpl ((M .) .) . flip (flip (insertWith (+)) 1)
00:30:16 <lambdabot> (\ k n q -> (M) (insertWith (+) n 1 k q))
00:30:54 <Cheery> @where Curry
00:30:54 <lambdabot> http://www.informatik.uni-kiel.de/~mh/curry/
00:31:49 * fuzan bangs head.
00:32:15 <ivanm> > (/) 1 2
00:32:16 <lambdabot>  0.5
00:33:16 <ivanm> @pl \ xs -> map (second (flip (/) (snd . head $ xs))) xs
00:33:16 <lambdabot> map =<< second . flip (/) . snd . head
00:34:01 <ivanm> One thing that I would find nice is a way of stating that "function foo should only be used on the output of function bar"
00:34:35 <sjanssen> fuzan: the type of scope in your class declaration is too general
00:35:09 <sjanssen> that signature says that scope x is an operation for *any* monad -- but this certainly isn't the case
00:35:13 <ivanm> @pl \ xs -> map fst . filter ((>) 0.5 . snd) . (map (second (flip (/) (snd . head $ xs)))) $ xs
00:35:13 <lambdabot> ((map fst . filter ((0 >) . 5 . snd)) .) =<< map . second . flip (/) . snd . head
00:35:38 <ivanm> @pl \ xs -> map fst . filter ((>) (0.5) . snd) . (map (second (flip (/) (snd . head $ xs)))) $ xs
00:35:38 <lambdabot> ((map fst . filter ((0 . 5 >) . snd)) .) =<< map . second . flip (/) . snd . head
00:35:48 <ivanm> @pl \ xs -> map fst . filter ((>) min . snd) . (map (second (flip (/) (snd . head $ xs)))) $ xs
00:35:49 <lambdabot> ((map fst . filter ((min >) . snd)) .) =<< map . second . flip (/) . snd . head
00:36:33 <sjanssen> fuzan: the instance trips up because it only works on certain monads -- state monads that hold [M.Map Ident Definition]
00:37:57 <ivanm> how can I turn an int into a Double?
00:38:09 <ivanm> or possibly a fraction?
00:38:20 <dons> > fromIntegral 7 :: Double
00:38:22 <lambdabot>  7.0
00:38:28 <ndm> @seen dons
00:38:29 <lambdabot> dons is in #haskell-soc, #haskell-overflow and #haskell. I last heard dons speak 8s ago.
00:38:34 <ndm> @seen sjanssen
00:38:34 <lambdabot> sjanssen is in #haskell-soc, #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard sjanssen speak 2m 2s ago.
00:38:35 <sjanssen> > fromIntegral 7 :: Rational
00:38:37 <ivanm> lol
00:38:37 <lambdabot>  7%1
00:38:44 <ndm> dons: any idea what the user numbers for XMonad are?
00:38:55 <ivanm> oh, so % is the fractional operator for Haskell?
00:39:03 <ivanm> > 1%2
00:39:04 <lambdabot>  1%2
00:39:13 <ivanm> > 1%2 :: Double
00:39:14 <lambdabot>  Couldn't match expected type `Double'
00:39:27 <dons> ndm. maybe I don't know, 15 people have contacted us since it was leaked about a week ago ? we've had 6 or 7 contributors in the last week roughly.
00:39:32 <dcoutts> > (1%2) :: Double
00:39:33 <ivanm> map (%2) [1..5]
00:39:34 <lambdabot>  Couldn't match expected type `Double'
00:39:42 <ivanm> > map (%2) [1..5]
00:39:43 <lambdabot>  [1%2,1%1,3%2,2%1,5%2]
00:39:54 <ivanm> that's all I want anyway...
00:40:15 <ivanm> wanted to know how to view them at the prompt, that's all (making sure that 1%2 = 1/2)
00:40:30 <dons> sjanssen: want to have a guess how many users we have?
00:40:42 <dons> let me see how many people are talking about it..
00:40:47 <dcoutts> dons: that's quite a few. On a similar note, I see that NixOS got 'leaked' to OSNews on April 1st and lots of people thought that a purely functional OS was an April fools :-)
00:41:04 <ivanm> lol
00:41:09 <dons> heh
00:41:24 <ivanm> dcoutts: see gmail's april fools joke?
00:41:41 <ivanm> @type 1%2
00:41:44 <lambdabot> forall t. (Integral t) => Ratio t
00:41:44 <sjanssen> there are 7 people that have contributed code
00:41:51 <dcoutts> ivanm: not as good as google's one about broadband via your toilet
00:42:10 <dons> ok. 79 people have mentioned xmonad in here.
00:42:20 <dcoutts> and someone was upset that functional languages are called 'functional' rather than function-based, apparently it gives us an unfair marketing advantage :-)
00:42:22 <ivanm> yeah, that wasn't bad either ;)
00:42:23 <sorear> ndm: as of about two hours ago, I'm an xmonad user.
00:42:28 <dons>      10 kc5tja
00:42:29 <dons>      13 stepcut
00:42:29 <dons>      18 thedward
00:42:29 <dons>      21 Gwern
00:42:29 <dons>      21 dmwit
00:42:31 <dons>      21 sorear
00:42:34 <ivanm> dcoutts: lol!
00:42:34 <dons>      23 shapr
00:42:36 <dons>      57 jcreigh
00:42:39 <dons>      65 dons
00:42:41 <dons>      97 sjanssen
00:42:44 <dons> all those guys are users, afaik
00:42:50 <ivanm> @hoogle (%)
00:42:51 <lambdabot> Did you mean: (%)
00:42:51 <lambdabot> Prelude.undefined :: a
00:42:51 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
00:42:52 <sorear> ndm: I like it better than ion already!
00:43:04 * earthy doesn't regularly do X
00:43:09 <ivanm> what do I have to import to get %?
00:43:13 <sorear> Ratio
00:43:17 <earthy> so I probably won't be an xmonad user anytime soon
00:43:24 <ivanm> data.ratio, or just ratio?
00:43:29 <dons> then there's 5 or so in the next 10 . so I'd say ~20 users since it was leaked?
00:43:32 <sorear> just ratio
00:43:34 <earthy> ?hoogle (%)
00:43:35 <lambdabot> Did you mean: (%)
00:43:35 <lambdabot> Prelude.undefined :: a
00:43:35 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
00:43:40 <dons> ignoring people who aren't in this channel
00:43:46 <fuzan> sjanssen: how would one define the more specific type? I've tried unsucessfully and just ended up with the type of mapM_ and modify
00:43:48 <sjanssen> dons, ndm: I think 20 is a reasonable guess
00:43:49 <earthy> ?!
00:43:49 <lambdabot> Maybe you meant: . v
00:43:50 <sorear> unless you have another pressing need to be unportable :)
00:44:22 <fuzan> i'm using dwm right now. when i get accustomed enough to this i'll try XMonad. No decorations is still a frightening idea.
00:44:28 <ivanm> @type 1%2
00:44:30 <lambdabot> forall t. (Integral t) => Ratio t
00:44:58 <dcoutts> dons: a WM in 400 lines would be a nice usnix paper, or for one of those similar converences, though only if you were using xcb ;-)
00:45:04 <sorear> earthy: bizarrely enough, the hierarchical modules proposal still hasn't been accepted.  so a h98 compiler is authorized to treat import Data.Ratio as a *lexical* error
00:45:33 <hpaste>  sjanssen annotated "type for class?" with "potential fix" at http://hpaste.org/1226#a2
00:45:34 <dons> sjanssen: hehe, "however, I'm not sure if it would be
00:45:34 <dons> worth to add this support to dmenu - simply because both, dwm
00:45:34 <dons> and dmenu aren't intended as Xinerama-capable"
00:45:41 <earthy> sorear: I know. ;)
00:45:46 <sorear> earthy: there is however a project to revise the haskell standard
00:45:59 <sorear> earthy: they will be releasing a new Report in december
00:46:00 <sorear> 06
00:46:00 <dons> fuzan: what decorations does dwm have?
00:46:03 <earthy> but I was wondering why hoogle didn't find Ratio for (%)
00:46:27 <sorear> I'll be very interested to see how they can pull it off.
00:46:28 <ivanm> @pl \ x -> x > 2
00:46:28 <lambdabot> (> 2)
00:46:30 <fuzan> dons: about a 15 pixel high border that contains the term/app name.
00:46:37 <earthy> sorear: Hi, i'm earthy. Maybe you haven't seen me 'round, but I've been programming Haskell for at least 4 years already.
00:47:02 <sorear> earthy: Oohhh ...
00:47:08 * sorear looks embarasses
00:47:14 <dons> earthy: hehe. at least 4 years eh?
00:47:15 <earthy> no probs. :)
00:47:18 <dons> old hand ;-)
00:47:20 * sorear has been programming haskell for about 1 year
00:47:33 <earthy> dons: yup. there's a reason I was maintaining Haskell code in my previous job. :)
00:47:45 <earthy> (and why I'm paid to do parser combinators in my current job :))
00:48:02 <ivanm> @pl \ x -> (snd x) > 2
00:48:03 <lambdabot> (> 2) . snd
00:48:53 <ivanm> how can I turn a Ratio Int into a percentage? i.e. a decimal?
00:49:12 <foxy-om> dcoutts, I got the c2hs'ed stuff running in an executable, but not in ghci, is that a known problem?
00:49:18 <ivanm> or even just re-define show so that it "looks" like a fraction, not what C-like languages use for mod?
00:49:27 <dcoutts> foxy-om: interpreted in ghci or compiled ?
00:49:31 <ivanm> (when using show, that is)
00:49:38 <foxy-om> dcoutts, compiled
00:49:54 <sorear> > floor . (*100) $ 1%3
00:49:55 <lambdabot>  33
00:50:04 <dcoutts> foxy-om: and you're linking in the .dll when you start ghci?
00:50:12 <dons> > let ppr :: Rational -> String ; ppr p = show ( numerator p) ++ "/"  ++ show (denominator p)
00:50:12 <lambdabot>  Parse error
00:50:13 <dcoutts> foxy-om: or going via a compiled package ?
00:50:14 <sorear> > printf "%02d%%" . floor . (*100) $ 1%3
00:50:15 <lambdabot>  Add a type signature
00:50:19 <dons> > let ppr :: Rational -> String ; ppr p = show ( numerator p) ++ "/"  ++ show (denominator p) in ppr (10 % 8)
00:50:20 <lambdabot>  "5/4"
00:50:26 <ivanm> sorear: thanks!
00:50:26 <sorear> > (printf "%02d%%" . floor . (*100) $ 1%3) :: String
00:50:28 <lambdabot>  "33%"
00:50:38 <dcoutts> g'morning JaffaCake
00:50:42 <JaffaCake> hey there
00:50:45 <sorear> hleo
00:50:50 <dcoutts> (at least I assume it's morning in that part of the world)
00:50:54 <earthy> anyway, time to read up on doaitse's error correcting parser combinators and out-of-order parsers
00:50:57 <JaffaCake> 'tis
00:51:04 <foxy-om> dcoutts, ah, I didn't think about that, how do I link in the dll when I start ghci?
00:51:05 <earthy> 08:48 @ JaffaCake, I'd wager
00:51:10 <JaffaCake> yup
00:51:12 <dons> ?time JaffaCake
00:51:14 <sorear> dcoutts: plus he's been gone for 8 hourse
00:51:20 <dcoutts> foxy-om: same way you do it with ghc
00:51:22 <sjanssen> ndm: why do you ask about xmonad users?  Have you run it through catch?
00:51:27 <sorear> dcoutts: usually a pretty good indication of sleap
00:51:37 <ivanm> @type floor . (*100) $ 1%3
00:51:39 <lambdabot> forall b. (Integral b) => b
00:51:47 <dons> sjanssen: probably to work out if he's going to vote up or down your proposal .. :-)
00:51:54 <sjanssen> ah
00:52:08 <sorear> proposal?
00:52:13 <sjanssen> ndm: the entire human population uses xmonad
00:52:22 <dons> and some alien species
00:52:29 <ivanm> OK, I've got to go... thanks all, and cya!
00:52:33 <fuzan> ah, i remember know why I havn't tried xmonad. i havn't attempted to fix the myriad of masking issues with paludis and x-haskell :\
00:52:34 <vincenz> @hoogle concatWith
00:52:35 <lambdabot> No matches found
00:52:41 <sorear> @localtime kc5tja
00:52:42 <lambdabot> Local time for kc5tja is Mon Apr  2 00:50:07 2007
00:52:46 <dons> i received a darcs patch from radar men on the moon to add reverse gravity to windows
00:52:46 <vincenz> @let concatWith c = concat . intersperse c
00:52:49 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
00:52:49 <vincenz> @type concatWith
00:52:52 <lambdabot> forall a. [a] -> [[a]] -> [a]
00:52:57 <vincenz> @type intersperse
00:53:00 <lambdabot> forall a. a -> [a] -> [a]
00:53:15 <vincenz> @type \c -> concat . intersperse c
00:53:17 <lambdabot> forall a. [a] -> [[a]] -> [a]
00:53:29 <dons> vincenz: that's intercalate :-)
00:53:33 <vincenz> @hoogle intercalate
00:53:34 <lambdabot> No matches found
00:53:41 <vincenz> dons: http://programming.reddit.com/info/1emao/comments/c1enke
00:53:42 <lambdabot> Title: So... static typing doesn&#39;t make code that verbose eh? (reddit.com)
00:53:43 <dons> ?src intercalate
00:53:44 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
00:54:06 <fuzan> someone's been making up words.
00:54:19 <dcoutts> and only the mighty simplifier knows how that gets turned into great code
00:54:20 <dolio> Intercalate doesn't exist in 6.6, though.
00:54:35 <dcoutts> dolio: but as you see it's easy to define
00:54:53 <dolio> Yeah, I know.
00:55:02 <vincenz> how do you bold in reddit comments?
00:55:13 <foxy-om> dcoutts, actually, the dll gets linked into the .o file for each module, so I don't think that was the problem
00:55:24 <dons> vincenz: hmm, *foo* gives you italics
00:55:27 <vincenz> apparently
00:55:31 <vincenz> and oddyl enough
00:55:45 <dons> but note that the guys blog is just dumb. verbose syntax has nothing to do with type systems.
00:55:52 <sjanssen> sorear: proposal to make a binding to xcb for summer of code
00:55:55 <dons> and there's no license to write blog articles, unfortunately
00:56:05 <vincenz> :)
00:56:13 <vincenz> that's why I barely blog
00:56:17 <vincenz> I'm not dumb enough
00:56:29 <dons> :-)
00:56:36 <dons> you can get treatment for that
00:56:41 <sorear> If I may be an optimist...
00:56:51 <sorear> dpiponi etc exist
00:56:52 <vincenz> sorear: Sounds like the words of a realist.
00:57:02 <dcoutts> JaffaCake: that was one of the examples where I tried to write stg style code and couldn't beat the naive definition of intercalate, the mighty simplifier was too clever for me
00:57:04 <vincenz> sorear: I was just joking ;)
00:57:13 <sorear> that said, dpiponi doesn't exactly cover computer subjects
00:57:29 <vincenz> No, he treats computer objects
00:57:43 <dcoutts> foxy-om: hmm, I don't think that means it'll get loaded.
00:57:46 <dolio> vincenz: I used foldr1 because I wouldn't have to import a module. That would have been 2 lines to Factor's 1. :)
00:57:55 <vincenz> dolio: ah :)
00:58:05 <sorear> vincenz: yeah, well, I get acused of cynicism far too often to let an optimistic moment pass by.
00:58:16 <foxy-om> dcoutts, when I linked with ghc I just put the dll on the command line, ghci doesn't seem to like that
00:58:17 <dolio> We can't have people claiming a 50% code length reduction over Haskell.
00:58:41 <dcoutts> foxy-om: try making a package using cabal
00:58:42 <fuzan> a question I've been curious about: when using ghci, is there a method for importing modules akin to, :m qualified Data.Map as M
00:58:52 <foxy-om> arg...
00:59:08 <fuzan> to avoid name collisions
00:59:19 <dcoutts> foxy-om: the package contains all the info necessary to use your modules with ghc or ghci
00:59:42 <foxy-om> dcoutts, ok, is there a howto for Cabal?
00:59:49 <dcoutts> @where Cabal
00:59:50 <lambdabot> http://www.haskell.org/cabal
01:00:23 <lightstep> fuzan, in ghci all the modules are already imported qualified (but without acronyms)
01:01:04 <fuzan> lightstep: there exists no method for importing with an acronym?
01:01:08 <earthy> fuzan: no there isn't a way to do what you want, but it may not be necessary
01:01:18 <earthy> exactly
01:01:24 <fuzan> having to type out the fully qualified path is often boresome!
01:01:28 <earthy> but see also http://www.haskell.org/ghc/docs/latest/html/users_guide/ch03s04.html#ghci-scope
01:01:31 <lambdabot> Title: 3.4. Interactive evaluation at the prompt, http://tinyurl.com/2c2oeu
01:02:27 <earthy> fuzan: then make a little file that just has the imports you want
01:02:39 <lightstep> err, i didn't know acronym means that. i mean abbreviation
01:04:31 <sorear> fuzan: rememer you have tab-completion for module names in ghci
01:05:24 <fuzan> sorear: yah, i know. It would still be nice, though :)
01:06:04 <sorear> supposedly hbi had tons of featurs like these that nobody else has caught up with yet...
01:06:12 <dons> sorear: so do you fancy hacking a fork of dmenu into an external statusbar?
01:06:21 <sorear> dons: not really
01:06:27 <dons> hbi still has. though it shows its age.
01:06:54 <dons> $ hbi
01:06:54 <dons> Welcome to interactive Haskell98 version 0.9999.5c Pentium 2004 Jun 29!
01:06:54 <dons> Loading prelude... 1 values, 4 libraries, 200 types found.
01:06:54 <dons> Type "help;" to get help.
01:07:01 <dons> > 1 + 2 ;
01:07:01 <lambdabot>  Parse error
01:07:01 <dons> 3
01:07:04 <dons> (note the semi colon)
01:07:18 <dons> > whatis concat;
01:07:18 <dons> concat :: [[b]] -> [b]
01:07:18 <lambdabot>  Parse error
01:07:42 <sjanssen> hbi supports multi-line inputs?
01:09:10 <fuzan> sjanssen: I realized you annotated my paste, and thanks -- that solved the issue.
01:17:04 <sorear> > partition (>0) [1,2,3,-1,-2,0]
01:17:05 <lambdabot>  ([1,2,3],[-1,-2,0])
01:18:14 <earthy> hm. 'add hbi useful functions to ghc' -- I see a SoC project. :P
01:18:30 <earthy> pity I'm no student anymore ;)
01:20:49 * foof is totally incapable of learning haskell's syntax :(
01:21:11 <Cale> foof: have you seen the tour of the Haskell syntax page?
01:21:11 <earthy> foof: no you're not
01:21:28 <Cale> http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html
01:21:29 <lambdabot> Title: Tour of the Haskell Syntax
01:21:53 <foof> all of my instincts on precedence and binding are completely opposite of the reality
01:22:19 <Cale> The single most important rule about precedence is that function application binds tighter than anything else.
01:22:40 <foof> i just spent an hour tracking down a "foo x y+1" bug that should've been "foo x (y+1)"
01:22:42 <Cale> So  f x + y would be  (f x) + y
01:22:49 <Cale> right
01:22:57 <Cale> That's (foo x y) + 1
01:23:42 <Cale> If a parameter is more than one symbol, parenthesise it.
01:24:12 <foof> I've just been putting parens everywhere until it looks like Scheme.
01:24:17 <Cale> (Or use some way to avoid those parens, like $ or .)
01:24:44 <lightstep> this page will benefit much from a style sheet
01:25:00 * foof is reading in w3m anyway ;)
01:25:17 <Cale> lightstep: I'd say syntax highlighting would make a bigger difference :)
01:29:02 <dons> ndm, another user :-)  ^^ "quitting X to try xmonad"
01:30:36 <dons> lightstep: hey :-)
01:30:37 <lightstep> oops, i didn't install dmenu. that sucked
01:30:45 <dons> well, install it now :-)
01:30:53 <dons> mod-shift-return (new xterm)
01:31:04 <dons> wget http://www.suckless.org/download/dmenu-2.7.tar.gz
01:31:13 <fuzan> is that how you avoid emacs collisions? :)
01:32:03 <dons> we don't avoid them ;-)
01:32:09 <dons> that's our secret strategy!
01:33:35 <foxy-om> how do I specify options for c2hs in a cabal file?
01:34:17 <sorear> night.
01:34:31 <lightstep> so, how do i use it? what are the key bindings?
01:34:42 <sorear> look in Config.hs
01:34:59 <fuzan> that's completely user-friendly :)
01:35:09 <sorear> Mod-j/k/tab to switch windows in the current workspace
01:35:13 <lightstep> oh, i fount it
01:35:33 <fuzan> make the official XMonad FAQ link to Config.hs
01:35:58 <dcoutts> foxy-om: oh, hmm c2hs and cabal don't play very well together, what options do you need that cabal doesn't pass automatically?
01:36:06 <lightstep> does mod4Mask correspond to the windows key?
01:36:13 <sorear> lightstep: unknown
01:36:21 <dons> lightstep: I think so, yes.
01:36:29 <dons> at least that was asserted earlier today.
01:36:33 <sorear> lightstep: it does on my system, but the mod-codes are NOT standardized
01:36:40 <foxy-om> dcoutts: --cppopts --include and the targets
01:37:01 <sorear> lightstep: so it could be anything for you...
01:37:18 <fuzan> :t Data.Map.lookup
01:37:20 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
01:37:24 <dcoutts> foxy-om: oh well those are just ordinary cpp-options and include file things, cabal has fields for those
01:37:41 <foxy-om> do they get passed to c2hs?
01:37:51 <lightstep> what does alt+shift+p do?
01:38:07 <foxy-om> dcoutts do you have a sample .cabal file for c2hs'ed stuff that uses autoconf?
01:38:10 <sorear> Depends.
01:38:22 <lightstep> oh, i don't have gmrun
01:38:26 <sorear> If Alt is your mod4, then it starts gmrun
01:38:32 <sorear> otherwise, nothing
01:39:55 <dcoutts> foxy-om: to use autoconf you need a Setup.hs file, see one of the extra-libs examples
01:44:04 <lightstep> xmonad doesn't like aptitude :(
01:44:31 <dons> aptitude doesn't like xmonad, you mean.
01:44:50 <dons> xmonad loves everyone
01:45:09 <lightstep> if i start typing commands before aptitude finishes loading that packages, they get lost
01:45:41 <lightstep> but that doesn't happen any more. maybe i was wrong
01:46:59 <dons> it might have stolen focus temporarily
01:49:38 <kolmodin> yesterday I discovered xmonad.org...
01:49:47 <kolmodin> nice :)
01:49:49 <Lunar^> xmonad is not yet in debian, right?
01:49:53 <dons> hehe
01:50:05 <dons> Lunar^: right. its not released yet.
01:50:09 <kolmodin> it's in the gentoo haskell overlay!
01:50:17 <dons> gentoo is special
01:50:28 <kolmodin> also, xmonad gives 42900 hits on google
01:50:31 <kolmodin> dons: it sure is
01:50:34 <Lunar^> dons: I was pondering the interest in packaging it in its current form.  I mean, it doesn't make much sens to package dwm either...
01:50:38 <dons> 42900??
01:50:55 <dons> whoa
01:50:56 <dons> hmm.
01:51:01 <dons> there were precisely 3 last week.
01:51:10 <kolmodin> but only on the first page, it seems..
01:51:14 <fuzan> dons has been hacking up his hitcount :)
01:51:19 <Lunar^> But I'm really looking for something better than ion3, and hacking a WM in Haskell should be fun!
01:51:20 <mux> 43.500 hits here :)
01:51:25 <dons> wow. that's amazing.
01:51:40 <kolmodin> when you browse the hits it refines it to 50 hits :D
01:51:40 <dons> the word 'xmonad' didn't exist to google before it hit reddit.
01:51:50 <dons> ah that's much more sensible
01:52:18 <kolmodin> aye
01:52:47 <dons> though its cool how much mindshare you can grab in a week.
01:54:08 <dons> "Third and last of all, it probably doesn't offer anything much more than what ratpoison and xmonad already have to offer.
01:54:12 <dons> BTW, the Haskell community, insofar as I know, are pretty much nice people."
01:54:14 <dons> hah
01:54:24 <kolmodin> hah, success!
01:54:31 <Lunar^> ! :)
01:55:05 <dons> so people are already saying "yeah, but its not xmonad" :-) and "yeah, but the haskell guys are nicer"
01:55:09 <dons> woot!
01:55:52 <kolmodin> searching for xmonad at reddit doesn't give any hits?
01:56:12 <araujo> oh cool
01:56:19 <araujo> xmonad has a site
01:56:20 <araujo> :-)
01:57:05 <dons> http://programming.reddit.com/search?q=xmonad
01:57:07 <lambdabot> Title: search: xmonad (programming.reddit.com)
01:57:12 <dons> (only the programming subreddit)
01:57:25 <flux> btw, it appears many of the links are essentially the same according to google, if you go to the last page..
01:57:41 <flux> earl.strain.at has tons of links that mention xmonad
01:57:41 <kolmodin> ah, weird that it doesn't show in the main reddit
01:58:17 <dons> yeah.
01:58:19 * fuzan dislikes how much paludis complains about circular dependencies / masking issues with x-haskell
01:59:11 <dcoutts> fuzan: heh, well there are plenty of ciruclar deps with ghc & ghc-bin :-)
01:59:42 <kolmodin> "I use xmonad." -- Chuck Norris
02:01:30 <kolmodin> is xmonad ment to forever be <400 lines of code?
02:01:33 <dons> I think even David Hasselfhoff uses xmonad.
02:01:42 <kolmodin> dons: I bet
02:01:49 <dons> kolmodin: its supposed to reach 0 lines of code in the limit :-)
02:02:18 <kolmodin> "xmonad is the best WM ever!" -- Oscar Wilde
02:02:18 <fuzan> dons: err... i meant wmii earlier, not dwm
02:02:35 <fuzan> dons: in regards to the window decorations. i just realized my mistake :)
02:02:41 <mux> does xmonad support EWMH? :)
02:02:47 <mux> and compositing?
02:03:04 <fuzan> it matches beryl in effects.
02:03:14 <fuzan> it even can draw on a sphere.
02:03:18 <dcoutts> dons: btw, for eliminating those "lines and lines of gets" you can use gets and pattern match with a record pattern
02:03:35 <dcoutts> State { ... } <- get
02:03:40 <dons> ah good idea.
02:03:44 <dons> sjanssen: ^^
02:04:03 <araujo> is it the purpose of xmonad to keep it <400 LOC?
02:04:04 <fuzan> i just can't get paludis to like x-haskell. it worked fine up till ghc-6.6 was mushed into portage.
02:04:06 <dcoutts> dons: even better if you can use the record punning stuff, dunno if ghc does that yet
02:04:07 <dons> i'm not working on xmond this week.
02:04:18 <dons> dcoutts: hmm. yes, the head does.
02:04:21 <dcoutts> fuzan: ask in#gentoo-haskell
02:04:30 * araujo notices kolmodin already asked the same
02:04:34 <dons> araujo: roughly. its basically an aspirational target.
02:04:44 <araujo> dons, nice
02:04:49 <dons> to let us know if we're bloating things improperly.
02:05:09 <dons> its like a target weight range :-)
02:05:26 <dons> so we have some idea when we need to shed more pounds of fatty lambdas
02:05:39 <araujo> hah
02:06:34 <flux> so when does xmonad get the hsplugin-support and on-demand loading of extensions from the web?-)
02:06:51 <mux> I vote for full ewmh support first
02:06:54 <dons> not happening.
02:07:04 <dons> though loading from the web.. hmm...
02:07:16 <dons> but that'll come after we embed ruby for configuration purposes.
02:07:21 <dcoutts> ha ha hah
02:07:40 <flux> my window manager is sawfish. it's great with its rep (scheme-like language) extension language..
02:08:26 <flux> and its fun to develop extensions for it too, as you can hack it on-the-fly
02:33:38 <dons> lightstep: sorted out your window manager issues? :-)
02:34:11 <lightstep> yes, i think so
02:34:37 <lightstep> xmonad doesn't like it when i close its stdin&stdout
02:34:44 <lightstep> took me a while to figure this out
02:34:55 <dons> oh. hmm. why's that?
02:35:03 <dons> it doesn't touch stdin or stdout, afaik
02:36:51 <dons> lightstep: what goes wrong?
02:42:05 <dcoutts> dons / sjanssen: perhaps you should close them explicitly yourself
02:43:30 <dons> yeah
02:47:16 <dons> ?time malcolmw
02:47:17 <lambdabot> Local time for malcolmw is 2007-04-02 10:44:59 +0100
02:47:41 <dons> ah, it is monday. so voting should be pretty much wound up, malcolmw ?
02:49:03 <bringert> @messages
02:49:03 <lambdabot> You don't have any new messages.
02:53:00 <malcolmw> dons: I'm just counting things as we speak
02:58:05 <qwandor> can someone tell me why this does not work:
02:58:16 <qwandor> (length [1, 2]) / 2
02:58:30 <TSC> :t (/)
02:58:33 <lambdabot> forall a. (Fractional a) => a -> a -> a
02:58:37 <foxy-om> :t length [1, 2]
02:58:38 <_dolio> length returns an Int, which is not fractional.
02:58:38 <Botje> > (length [1,2]) / 2
02:58:39 <lambdabot>   add an instance declaration for (Fractional Int)
02:58:39 <lambdabot>     In the expression: (le...
02:58:40 <lambdabot> Int
02:58:41 <TSC> / works on fractionas numbers
02:58:43 <Botje> yay
02:58:54 <TSC> You want:
02:58:55 <Botje> qwandor: use genericLength
02:58:55 <mux> > fromIntegral (length [1,2]) / 2
02:58:56 <TSC> :t div
02:58:58 <lambdabot>  1.0
02:58:59 <lambdabot> forall a. (Integral a) => a -> a -> a
02:59:02 <mux> or genericLength
02:59:04 <TSC> Or genericLength
02:59:44 <dons> > (genericLength [1, 2]) / 2
02:59:45 <lambdabot>  1.0
02:59:59 <dons> qwandor: do you understand why?
03:00:01 <dons> :t length
03:00:02 <dons> :t (/)
03:00:04 <lambdabot> forall a. [a] -> Int
03:00:06 <lambdabot> forall a. (Fractional a) => a -> a -> a
03:00:22 <dons> Int is not a member of class Fractional
03:00:23 <mux> @instances Fractional
03:00:24 <lambdabot> Double, Float
03:00:33 <qwandor> um
03:00:41 <dons> hence you must convert Int into either Double of Float first, or use a generic 'length' function
03:00:45 <dons> :t genericLength
03:00:48 <lambdabot> forall b i. (Num i) => [b] -> i
03:00:52 <dons> @instances Num
03:00:53 <lambdabot> Double, Float, Int, Integer
03:00:57 <qwandor> Undefined variable "genericLength"
03:01:09 <dons> its in Data.List
03:01:17 <dons> ?hoogle genericLength
03:01:17 <lambdabot> List.genericLength :: Integral a => [b] -> a
03:01:17 <lambdabot> Data.List.genericLength :: Num i => [b] -> i
03:01:28 * qwandor has only been writing Haskell for 2 days
03:01:32 <dons> @instances Integral
03:01:33 <lambdabot> Int, Integer
03:01:40 <dons> qwandor: welcome then! :-)
03:01:45 <dolio> Someone should keep track of how often that gets asked in here. :)
03:01:47 <dons> you've now met type classes
03:01:48 <mux> arithmetic with haskell ain't much fun
03:02:01 <dons> well, we don't like automatic coercion between lossy types
03:02:10 <dons> that way likes C.
03:02:13 <dons> lies.
03:02:30 <mux> yes, but it then can be really tedious to write arithmetic code
03:02:45 <dons> if you're doing a lot of conversion?
03:02:46 <mux> I wish there was a best-of-both-worlds solution
03:02:56 <dons> ormally you'd just stay in Double or Integer land
03:03:00 <mux> dons: for instance when doing arithmetic with gtk2hs
03:03:09 <dons> yeah, with foreign code needing CInt ?
03:03:11 <mux> you have Double's one way, Int's the other way
03:03:27 <qwandor> ok, what is the best way to do integer division, like in C?
03:03:31 <mux> cairo nearly only uses Doubles, gtk likes Ints better
03:03:33 <dons> I've been known to use 'f = fromIntegral' in foreign binding code.
03:03:34 <mux> qwandor: div
03:03:36 <mux> :t div
03:03:37 <dons> qwandor: `div`
03:03:38 <lambdabot> forall a. (Integral a) => a -> a -> a
03:03:42 <dons> > 5 `div` 2
03:03:43 <lambdabot>  2
03:03:46 <qwandor> aha
03:03:47 <dons> > 5 / 2
03:03:48 <qwandor> tanks
03:03:48 <lambdabot>  2.5
03:03:51 <qwandor> *thanks
03:03:59 <mux> > 5 `divMod` 2
03:04:01 <lambdabot>  (2,1)
03:04:09 <dons> > 5 `quotRem` 2
03:04:10 <lambdabot>  (2,1)
03:04:12 <dons> ;-)
03:04:31 <dons> ?check \x y -> divMod x y == quoteRem x y
03:04:33 <lambdabot>   Not in scope: `quoteRem'
03:04:37 <dons> ?check \x y -> divMod x y == quotRem x y
03:04:38 <lambdabot>  Add a type signature
03:04:59 <dons> ?check \x y -> let _=x::Int;_=y::Int in     divMod x y == quotRem x y
03:05:01 <lambdabot>  Exception: divide by zero
03:05:13 <mux> heh
03:05:14 <dons> ?check \x y -> y > 0 ==> let _=x::Int;_=y::Int in     divMod x y == quotRem x y
03:05:15 <lambdabot>  Falsifiable, after 1 tests: -3, 2
03:05:20 <fasta> What can cause "MArray: undefined array element"? I verified that all elements are _not_ the value undefined.
03:05:21 <dcoutts> mux: yeah, sigh, gtk was developed in the pixel-based era where as cairo is all about scalable stuff so uses double consistently
03:05:30 <mux> dcoutts: *nods*
03:05:42 <mux> it makes perfect sense for gtk to use Int and cairo to use Double
03:05:47 <mux> it's just shitty when you have to deal with it :-)
03:05:54 <dcoutts> aye
03:06:37 <dolio> You could define your own elaborate set of type classes that do C-style numeric promotion.
03:06:40 <dolio> :)
03:07:28 <koen> ?check \x y -> y /= (0::Int) ==> divMod x y == quotRem x y
03:07:29 <lambdabot>  Falsifiable, after 20 tests: -2, 6
03:29:46 <twb> Any shim users about?
03:30:23 <robreim> @seen bos
03:30:24 <lambdabot> bos is in #haskell and #haskell-soc. I don't know when bos last spoke.
03:31:05 <twb> I'm trying to work out an elegant way to have shim compile itself into somewhere 1) the user can write to; and 2) won't conflict when $HOME is shared across disparate architectures; and 3) won't bork when $HOME is shared across hosts with different versions of shim.
03:31:30 <twb> slime does this by examining the changelog and the common lisp implementation version.
03:31:54 <twb> So binaries appear in e.g. ~/.slime/fasl/2007-02-26/cmu-cvs_19d_19d-release_(19d)-linux-x86
03:34:11 <twb> The idea is that you then just tell emacs where to find shim and say "M-x shim", and it will automatically compile and install the shim binary if it doesn't already exist or is out of date.
03:35:40 <pejo> twb, suppose I install it for all users, and they use it. Will I get another installation for each user in $HOME if the globally installed version gets out of date?
03:35:54 <twb> pejo: I haven't decided yet.
03:36:48 <robreim> twb: hmm, I haven't used shim but I know what you're talking about from slime. What sort of problems have you encountered while trying to achieve the same result?
03:36:51 <twb> It would probably depend on whether shim.el version X and shim(1) version Y will work together, where X /= Y
03:37:08 <twb> robreim: well, I've only just started.
03:38:39 <robreim> twb: If shim.el can check the version of ghc by parsing the output of ghc --version and maybe integrate a little with darcs or check file timestamps or something, then also check uname, you should have all you need, no?
03:39:00 <twb> robreim: does uname work on Windows?  Does it work on OS X?
03:39:08 <pejo> twb, it works on osx.
03:39:20 <twb> Actually I was going to use arch(1) instead of uname
03:39:59 <pejo> twb, surely you need something more than just arch?
03:40:05 <twb> I don't know.
03:40:05 <robreim> hmm, uname on windows. Good point.
03:40:29 <robreim> pejo: what else would you need?
03:40:57 <twb> robreim: e.g. is it linux x86, ulinux x86 or mach x86?
03:41:11 <pejo> robreim, I'm on a sun4. Is that sufficient information for what twb is doing?
03:41:39 <dons> koen: hi!
03:41:45 <robreim> twb: sorry, I missed the part about using arch instead of uname.
03:41:48 <quicksilver> twb: it might be a sensible feature request for ghc, that it have a commandline option which outputs enough information to uniquely determined binary compatibility
03:41:49 <dons> and welcome, not sure I've seen you in #haskell before :-)
03:42:01 <twb> quicksilver: that would be *awesome*
03:42:06 <dons> koen: and yes, QuickCheck for the masses :-)
03:42:24 <quicksilver> twb: after all, ghc ought to know best, what subarchs are compatible or not, with each other
03:43:11 <dons> everyone say hello to koen, our local QuickCheck maestro :-)
03:43:43 <robreim> hi koen!
03:45:59 <dons> ?scheck \x y -> y /= (0::Int) ==> divMod x y == quotRem x y
03:46:00 <lambdabot>   Failed test no. 10. Test values follow.: -1, 2
03:47:17 <twb> Where is the GHC BTS?
03:47:34 <dons> bts? or vcs?
03:47:52 <twb> BTS
03:48:17 <twb> http://hackage.haskell.org/trac/ghc
03:48:19 <lambdabot> Title: GHC - Trac
03:48:24 <dons> ah yes. there.
03:48:26 <dons> ?bug <--
03:48:26 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
03:49:19 <twb> Will it break anything if I log a bug as guest/guest?
03:49:43 <quicksilver> I logged one last week and it was taken seriously
03:49:48 <quicksilver> so I'm assuming it's considered fine :)
03:50:11 * twb grumbles about trac's poor SMTP support
03:50:11 <dons> twb, nope. that's fine.
03:50:31 <dons> guest/guest is fine. useful to sign your name thoug,h, if you do that
03:50:37 <dons> so we can follow up with questions to the right person
03:53:07 <Batterseapower> is there any tool available that i can point at a .h file and have a rough .hsc spit out?
03:54:08 <dons> yeah, c2hs
03:54:12 <dons> ?where c2hs
03:54:12 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
03:54:19 <dons> it can do quite a good job in fact.
03:54:31 <dons> thought its not going to produce .hsc files
03:54:41 <Batterseapower> thanks a lot, i'll take a look at it!
03:54:45 <dons> hsc2hs/.hsc is for manually generated bindigns, afaik.
03:54:51 <dons> whilst c2hs is for more automated work.
03:55:11 <dons> c2hs is notable as it is used by gtk2hs to generated the gtk bindings
03:56:07 <kombinator> hello #haskell, what is the easiest way of printing floats with specified number of digits after the point?
03:56:30 <dons> > printf "0.4f" (pi :: Double)
03:56:31 <lambdabot>  Add a type signature
03:56:36 <dons> > printf "0.4f" (pi :: Double) :: String
03:56:37 <lambdabot>  Exception: Printf.printf: formatting string ended prematurely
03:56:37 <dcoutts> bah, printf
03:56:42 <dons> > printf "%0.4f" (pi :: Double) :: String
03:56:43 <dons> hehe
03:56:44 <lambdabot>  "3.1416"
03:56:51 <dons> yeah, or showAtblahBlah in Numeric
03:56:56 <kombinator> thanks
03:57:18 <dons> > showEFloat (Just 4) pi []
03:57:20 <lambdabot>  "3.1416e0"
03:57:27 <dons> > showFFloat (Just 4) pi []
03:57:28 <lambdabot>  "3.1416"
03:57:50 <dcoutts> > showGFloat (Just 4) pi []
03:57:52 <lambdabot>  "3.1416"
03:58:05 <dcoutts> I'm never sure what the difference between those three is :-)
03:58:53 <dons> > showIntAtBase 2 chr 42
03:58:54 <lambdabot>  <[Char] -> [Char]>
03:59:00 <dons> > showIntAtBase 2 chr 42 []
03:59:01 <lambdabot>  "\SOH\NUL\SOH\NUL\SOH\NUL"
03:59:16 <dons> > showIntAtBase 2 (\c -> chr c + chr '0') 42 []
03:59:17 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
03:59:26 <dons> > showIntAtBase 2 (\c -> chr $ c + ord '0') 42 []
03:59:27 <lambdabot>  "101010"
03:59:34 <dons> > showIntAtBase 2 (\c -> chr $ c + ord '0') 31241232 []
03:59:35 <lambdabot>  "1110111001011010000010000"
03:59:55 <dons> > showIntAtBase 2 (\c -> chr $ c + ord 'x') 31241232 []
03:59:56 <lambdabot>  "yyyxyyyxxyxyyxyxxxxxyxxxx"
04:00:12 <dons> Numeric is a weird module
04:00:25 <dons> its almost like its just a random collection of numeric functions left over from 1989
04:01:03 <dons> oh wow. trac is getting spammed
04:01:06 <dons> Igloo: ^^
04:01:20 <dons> bah.
04:01:29 * dons watches mail box fill up
04:03:42 <Batterseapower> hum.. is there such thing as a null IO action? sth of type "IO a", say?
04:03:50 <Batterseapower> hoogle dosent seem to think so..
04:04:08 <fasta> Batterseapower: return undefined
04:04:10 <dcoutts> Batterseapower: return (), or fail "aarg!"
04:04:20 <quicksilver> :t throw
04:04:23 <lambdabot> Not in scope: `throw'
04:04:27 <quicksilver> or one of the 'throw' types
04:04:39 <fasta> What are the causes of: *** Exception: MArray: undefined array element ?
04:04:59 <Batterseapower> return undefined, thanks fasta!
04:05:33 <Botje> fasta: exactly what it says. one of your array elements is undefined.
04:05:36 <Batterseapower> thanks for the other suggestions too.. but return () :: IO () and i don't want the action to do anything when it's hit, so throw is no good...
04:05:40 <lightstep> fasta, do you use newArray or newArray_?
04:06:16 <dons> return () is the null action, by convention.
04:06:18 <fasta> Botje: that's what I thought, but since I have shown all the elements of that array in an earlier operation that shouldn't be possible.
04:06:33 <fasta> lightstep: currently newArray for debugging, but otherwise newArray_
04:06:42 <fasta> lightstep: I initialize everything to -1
04:06:46 <dons> note that return undefined is a pretty unusual thing to use, Batterseapower
04:06:59 <dons> since it will throw an exception if the result is every inspected.
04:07:06 <Batterseapower> :) sure
04:07:12 <Batterseapower> i'm probably doing something else wrong
04:07:21 <Batterseapower> because i want an "if" in the IO monad with only one branch
04:07:27 <dons> that's called 'when'
04:07:30 <lightstep> ?type when
04:07:30 <dons> its in Control.Monad
04:07:33 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
04:07:38 <dons> when b (do x ; y ; z )
04:07:39 <dons> ?src when
04:07:40 <lambdabot> when p s = if p then s else return ()
04:07:46 <lightstep> ?type unless
04:07:48 <dons> :-) note the use of return () for the null action
04:07:48 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
04:07:58 <fasta> The type of when is not really general
04:08:14 <fasta> I suspect Batterseapower already understands that.
04:08:37 <Batterseapower> well, it felt ugly because i would have to write sth. like do { myIOACtion; return () }
04:08:40 <lightstep> fasta, in that case, it's probably a bug in ghc
04:08:46 <Batterseapower> since when dosent have type Monad m => Bool -> m a -> m ()
04:08:57 <dons> ah, I see.
04:09:01 <dons> sometimes I define a 'void' combinator for this
04:09:03 <fasta> Batterseapower: I fixed the same problem in my personal library.
04:09:06 <dons> void a = a >> return ()
04:09:11 <dons> then, void myIOAction
04:09:17 <quicksilver> Batterseapower: return () is 100 times less ugly than return undefined though :)
04:09:29 <dons> oh, at least 100. maybe 200 x less.
04:09:46 <quicksilver> Batterseapower: return undefined is burying a runtime error which you somehow promise won't be evaluated; at least return () is clear in what it does
04:09:57 <Batterseapower> void look good, thanks :)
04:10:08 <Batterseapower> yeah, i felt a bit bad about it ^^
04:10:38 <lightstep> there's also some Control.Nop library or something
04:10:41 <Batterseapower> ok, thanks a lot for everyones suggestions!
04:11:14 <fasta> lightstep: yes, the one with the award for smallest library ever.
04:12:24 <dons> its actually kind of bloated now.
04:12:41 <dons> since there's a lot of ways to do nothing
04:12:50 <dons> and the Nop transformers too... that's more code.
04:13:04 <dons> take an action, and make it useless. very important.
04:13:13 <fasta> Are the prime number generators already in a library?
04:13:27 <dons> they're in the benchmark suite.
04:13:30 <dons> not sure they got library-ified
04:14:35 <fasta> Can I tell ghci also to show a "stack trace" when it throws an exception like ghc does when I use the xc option?
04:19:19 <jkff> Hi all. Are there any news about a decent IDE appearing for Haskell? I tried Visual Haskell but it died gloriously and unresurrectibly (I didn't try formatting my hdd altough) after a week or so, and heard about HIDE being developed but never heard when it is actually going to be released, or anything else about it.
04:19:38 <dons> an ide for use on windows?
04:19:48 <dons> there's some work planned on GuiHaskell, for windows, as a summer of code project.
04:19:54 <jkff> Yep, but if there was one for Linux I would install Linux :)
04:20:34 <LPhas> dons: isn't there Visual Haskell?
04:20:57 <jkff> Visual Haskell is there, but I wouldn't call it 'decent'
04:20:59 <LPhas> oh, i read now
04:21:18 <LPhas> jkff: there's a plugin for eclipse
04:21:22 <fasta> jkff: I wouldn't expect one for the coming 5 years.
04:21:30 <LPhas> jkff: i tried it and it's not so bad
04:21:37 <fasta> jkff: The plugin is also crappy.
04:21:49 <LPhas> jkff: and Eclipse is also for windows, right?
04:22:04 <jkff> Yes, I saw it too. Actually, just a popup type hint would suffice for many of my purposese and I was going to write a plugin for Vim but laziness stopped me..
04:22:24 <fasta> jkff: shim might be something, but that's for Emacs users.
04:22:35 <fasta> jkff: i.e. not an IDE as you mean
04:22:48 <phoniq> shim and haskell-mode are decent
04:22:57 <jkff> Thanks, I'll have a look
04:23:20 <quicksilver> just dabbrev-expand is pretty handy :)
04:23:27 <fasta> jkff: I use haskell-mode, but it's far from perfect.
04:23:31 <LPhas> oh, yeah, of course haskell-mode for emacs is the way
04:23:41 <jkff> Altough I also think that a real IDE for haskell would be pretty hard to write, and I have only the most remote impression of what its capabilities could be. Debugging? GUI building? Rather foreign to haskell
04:24:07 <jkff> Refactoring seems also a rather unexplored area to have a mature tool.
04:24:09 <fasta> jkff: if you want language tools, use Visual Basic or Smalltalk or FreePascal.
04:24:39 <jkff> Well, I use Java and IDEA but that's not the question now :)
04:24:47 <phoniq> i had to hack haskell-mode to get if/then/else indentation right
04:25:02 <phoniq> i'm new to this, dunno if that was just me
04:25:06 <fasta> jkff: refactoring is not unexplored territory in Haskell.
04:25:07 <LPhas> jkff: an IDE for haskell could interact with Cabal, darcs and haddock
04:25:17 <fasta> jkff: There's even some Emacs mode for it
04:25:24 <LPhas> jkff: and support GUI design via glade
04:25:28 <jkff> Right, it could.
04:25:32 <LPhas> jkff: and it'll be cool
04:25:35 <fasta> jkff: GUI building is also not "foreign".
04:26:17 <fasta> jkff: Debugging would be somewhat more complex
04:26:46 <fasta> jkff: AFAIK, there are no tools that support full ghc in a sensible way
04:26:55 <LPhas> jkff: also it could have a GUI for hoogle
04:27:28 <dons> the hsakell ides for linux are emacs and vim, with the shim extension, btw.
04:27:31 <jkff> I heard of HAT but anyway debugging lazy evaluation has to have a rich formal foundation, maybe there even is but I have not read much on that.
04:29:22 <mux> when I have an ADT with two nullary data constructors that derives Enum, is there some type-class or something I can use to get to the second value when I have the first and vice-versa?
04:29:26 <fasta> jkff: Hat works for Haskell 98, IIRC. In any case it doesn't for my programs.
04:29:28 <mux> a bit as if I had a boolean
04:29:33 <mux> data Color = Black | White
04:30:09 <quicksilver> invert f = toEnum (maxBound - (fromEnum f))
04:30:21 <mux> thanks
04:30:25 <quicksilver> personally I'd just write invert Black = White; invert White = Black though :)
04:30:26 <fasta> mux: not an existing type class, I think, but I would use what quicksilver says
04:30:27 <lightstep> ?type toEnum . (1 -) . fromEnum
04:30:30 <lambdabot> forall a a1. (Enum a, Enum a1) => a1 -> a
04:30:42 <mux> I wass about to code: nextColor Black = White and nextColor White = Black
04:30:43 <quicksilver> :t maxBound
04:30:46 <lambdabot> forall a. (Bounded a) => a
04:30:59 <quicksilver> you need to derive bounded, too, perhaps
04:31:18 <quicksilver> and fromEnum (maxBound `asTypeOf` f)
04:31:20 <mux> that's ok, it's already derived
04:31:20 <quicksilver> I fear
04:32:16 <jkff> mux: why do you need something universal for that?
04:32:26 <mux> I don't, I was being curious
04:32:32 <mux> I'm just going to use nextColor as I said
04:36:56 <mux> I've so often found myself coding stuff that already existed that I like to check now :-)
04:39:34 <quicksilver> :t fromEnum maxBound
04:39:37 <lambdabot>     Ambiguous type variable `a' in the constraints:
04:39:37 <lambdabot>       `Enum a' arising from use of `fromEnum' at <interactive>:1:0-16
04:39:41 <quicksilver> quite right
04:39:56 <quicksilver> something weird about type-class dependent values from which the constraint has vanished
04:56:20 <fasta> Why do I get Exception: MArray: undefined array element when I use a DiffArray? A DiffArray isn't even in that module and it isn't mutable (at least not interface-wise).
04:57:25 <fasta> It smells like a wrong error message.
04:59:41 <Batterseapower> hmm... is there something like the "opposite" of the Maybe monad in the standard library? something which runs successive Ebyam actions until one returns Just x?
04:59:49 <Batterseapower> could be useful for expressing prioritised choice
05:01:10 <dcoutts> there's a Monoid instance for something like that
05:01:12 <dons> hmm, what's a Ebyam actions?
05:01:14 <dons> a nothing?
05:01:24 <fasta> dons: Maybe reverse
05:01:28 <fasta> dons: +d
05:01:30 <Batterseapower> :) sorry, yeah
05:01:47 <dons> yes. but reversed in what sense? it evaluates Nothing, until Just x, then it fails with x ?
05:02:15 <dons> otherwise what does it suceed with? () ?
05:02:30 <fasta> dons: It succeeds when Just is encountered.
05:02:38 <Batterseapower> and returns Nothing otherwise
05:02:38 <fasta> I think Batterseapower said it pretty clear
05:02:50 <doserj> can you give the type of it?
05:02:59 <dons> what's failure in this monad then?
05:03:10 <dcoutts> there was recently a first and last Monoid instance added for just this purpose
05:03:15 <lightstep> ?src Monoid (Maybe a)
05:03:16 <lambdabot> Source not found. The more you drive -- the dumber you get.
05:03:24 <dons> yeah, that might be it.
05:03:32 <twb> Done!
05:03:34 <dons> first and last on Maybe.
05:03:48 <twb> http://twb.ath.cx/~twb/scratch/profile/.emacs-prefs/shim.el
05:04:01 <dons> ?source Data.Maybe
05:04:01 <lambdabot> http://darcs.haskell.org/packages/base/Data/Maybe.hs
05:04:50 <Batterseapower> hmm, i cant see first/last in that file?
05:04:56 <dons> so we have:
05:04:59 <dons> instance Monoid a => Monoid (Maybe a) where
05:04:59 <dons>   mempty = Nothing
05:04:59 <dons>   Nothing `mappend` m = m
05:04:59 <dons>   m `mappend` Nothing = m
05:05:01 <dons>   Just m1 `mappend` Just m2 = Just (m1 `mappend` m2)
05:05:11 <dons> which is just your usual monoid for maybes
05:05:13 <dcoutts> that's the standard instance
05:05:24 <dcoutts> then there are newtype wrappers for the other behaviours
05:05:26 <dons> then we also have
05:05:26 <Batterseapower> i've not heard of a monoid before
05:05:27 <dons> -- | Maybe monoid returning the leftmost non-Nothing value.
05:05:27 <dons> newtype First a = First { getFirst :: Maybe a }
05:05:34 <dons> -- | Maybe monoid returning the rightmost non-Nothing value.
05:05:34 <dons> newtype Last a = Last { getLast :: Maybe a }
05:05:45 <dons> where
05:05:46 <dons> instance Monoid (First a) where
05:05:47 <dons>         mempty = First Nothing
05:05:47 <dons>         r@(First (Just _)) `mappend` _ = r
05:05:47 <dons>         First Nothing `mappend` r = r
05:05:51 <dcoutts> Batterseapower: it's simpler than a monad, it just has a ++ like operation
05:06:06 <dons> and
05:06:07 <dons> instance Monoid (Last a) where
05:06:07 <dons>         mempty = Last Nothing
05:06:07 <dons>         _ `mappend` r@(Last (Just _)) = r
05:06:07 <dons>         r `mappend` Last Nothing = r
05:06:16 <swiert> Is there an academic paper explaining Data.Dynamic?
05:06:34 <dons> swiert: yeah, let me find the ref.
05:06:47 <Batterseapower> dons, dcoutts: thanks a lot! i'll go and read up on Monoids now
05:08:14 <lightstep> swiert, the first syb paper introduces typeable and explains how to define Dynamic (iirc)
05:08:30 <lightstep> it's not really academic, but it has enough so you can figure out the details
05:08:52 <swiert> lightstep: Thanks.
05:08:57 <dons> swiert: there's, A lightweight implementation of generics and dynamics. James Cheney , Ralf Hinze.
05:09:00 <dons>     Proceedings of the ACM SIGPLAN workshop on Haskell, p.90-104, October 03, 2002, Pittsburgh,
05:09:03 <dons>     Pennsylvania
05:09:45 <dons> didn't someone we know also write "Typing Dynamic Typing" ? ;-)
05:09:57 <dons> which surely refers to Data.Dynamic somewhere?
05:10:07 <swiert> dons: I'd spotted that one. I was curious which one (of many) proposals Data.Dynamic uses.
05:10:35 <dons> I think its based on the Hinze model, and is still pretty similar to the original Abadi et al model
05:11:08 <swiert> Fair enough. Thanks for the pointers.
05:11:17 <dons> pretty similar to the original "Dynamic typing in a statically typed language", Abadi, Luca Cardelli, Pierce and Plotkin
05:11:45 <earthy> dons: Typing Dynamic Typing is by Arthur Baars. Who is 2 offices over. I think that counts as 'someone we know'
05:12:28 <vincenz> dons: I have a spiffy new vim-plugin :)
05:12:40 <earthy> oooh, really?!
05:12:47 <dons> earthy, and one of the Swierstras too :-)
05:13:39 <dons> have we seen Arthur in here? I met him in Snowbird a couple of years ago.
05:13:48 <earthy> nope, he doesn't IRC
05:14:00 <earthy> (and rightly so, he should be writing his thesis)
05:14:05 <dons> heh
05:15:02 <twb> http://shim.haskellco.de/trac/ticket/6
05:15:04 <lambdabot> Title: #6 (auto-(re)compile shim) - shim - Trac
05:15:45 <twb> dons: would that be Andrew Plotkin of IF fame?
05:16:03 <dons> Gordon.
05:16:18 <dons> of programming language fame.
05:16:23 <twb> Okie dokey
05:22:42 <beschmi> twb: looks nice, so shim-version is the number of patches in the repo? how would you handle unrecorded changes?
05:23:24 <twb> beschmi: I don't, because I'm lazy
05:23:44 <twb> In similar code, I add a + if there are unrecorded changes
05:24:03 <twb> Even counting patches is a kludge, tho.
05:25:01 <twb> Ah, I do that by comparing the output of "darcs w -l" to the strnig "No changes!\n"
05:26:24 <greenrd> Is it possible to build the template-haskell package separately, without having to rebuild the rest of ghc?
05:26:35 <greenrd> I want to test a patch
05:28:42 <beschmi> twb: the unrecorded changes don't matter much for the normal user, but would be nice for hacking shim. i used ghc -e ... at the beginning but shim is to big for that now
05:29:07 <twb> What does -e do?
05:30:22 <fasta> twb: evaluate a Haskell expression IIRC
05:30:31 <twb> That's what I figgered
05:34:20 <beschmi> twb: what fasta said. i used ghc -e "Shim.Shim.startServer \"$1\"" -package ghc Shim/Shim
05:34:49 <foxy-om> dons, my ears perked up with mention of Data.Dynamic... is anyone working on runtime typing with ghc-api internals these days?
05:34:58 <twb> Unfortunately it takes about 10 minutes to compile shim on my box (because it's not a massively overspecced Apple Mac)
05:35:54 <beschmi> linking takes ages and lots of ram here (because of ghc-api)
05:36:06 <twb> Yeah, what's up with that?
05:36:26 <twb> My loadavg goes up to 4.5 and ld consumes over half my ram.
05:37:53 <beschmi> i remember something about disabling split-objs helping with gtk2hs linking times
05:38:42 <arcatan> =vc 17
05:38:45 <arcatan> argh
05:43:22 <beschmi> seems like split-objs is disabled by default, you could try -dynamic on a mac
05:48:52 <dons> foxy-om: hmm. not that I know of. but i should finish my phd this year, and will have to do something on that.
05:48:58 <dons> yi actually does everything on top of ghc-api now.
05:50:15 <vincenz> earthy: still interested?
05:50:50 <foxy-om> dons, I'll have to have a look at yi again soon, I need to put the finishing touches (cabal stuff) on a package to access Matlab data and I've just started a binding to LAPack. (While I'm waiting for dynamic polymorphic types :) :)
05:51:25 <foxy-om> how's the thesis coming along?  You seem to be /very/ busy with general haskell community stuff
05:53:45 <foxy-om> dcoutts If I have a module Foo.chs that binds to foo.h I get an infinite loop of includes, is there a way to avoid that?
05:53:54 <foxy-om> dcoutts: ping
06:03:57 <vincenz> dons: ping
06:04:23 <vincenz> dons: for growable arrays, I guess the best solution is a string, right?
06:04:37 <vincenz> or whatever the name is for [Array ...]
06:04:44 <vincenz> rope
06:05:17 <quicksilver> lazybytestrings are rather like [Array]
06:05:31 <vincenz> that's what I figured
06:06:00 <vincenz> Presumably with fixed Array size to easily locate the right segment?
06:06:21 <vincenz> So the tradeoff is access vs footprint: smaller arrays more accesses less fragmentation and viceversa
06:07:11 <quicksilver> lazy bytestrings don't have fixed array sizes, no
06:07:27 <quicksilver> they're mostly only efficient under the assumption tht the chunk size is pretty large, I thikn
06:07:31 <vincenz> dons: are they fixed size arrays?  Or are they non-fixed size... CAuse thinking about it, since one has to walk the list anyways, well then one can check the size of the next array while one's at it...
06:07:45 <vincenz> I thought they were cache-line sized
06:08:01 <vincenz> s/cache-line/page-size/
06:08:35 <quicksilver> vincenz: depends how you create them
06:08:39 <waern> I'd like to set up a Trac for haddock.ghc on haskell.org somewhere... who should I talk to?
06:08:44 <quicksilver> vincenz: if you create them from a  a file, I don't know
06:08:50 <vincenz> quicksilver: hmm, alright
06:08:59 <quicksilver> vincenz: if you create them from a socket, then the thunk size tends to be how much you could read in one go
06:09:07 <vincenz> I guess I'll go for fixed-size to start with
06:09:12 <quicksilver> vincenz: if you create them with append, the chunks are as big as the chunks you give :)
06:09:32 <vincenz> well yeah but I thougt all chunks were 4096
06:09:42 <quicksilver> nope
06:09:46 <vincenz> ok, thx
06:09:54 <quicksilver> L.pack "abcd" creates a chunk of size 4, for example :)
06:10:02 <vincenz> either way, I think I'll go for fixed-size for the moment
06:10:15 <vincenz> cause my app won't tknow the size of data
06:10:20 <quicksilver> (L.pack "abcd") `L.append` (L.pack "d") makes a chunk of size 4 and one of size 1
06:11:08 <dolio> Something-related-to-cache sized chunks does ring a bell with me, too. Perhaps with regards to optimizing file IO.
06:11:22 <vincenz> damn, now I wonder what an optimal chunksize is
06:11:25 <vincenz> or at least a decent one
06:11:25 <dolio> In their paper.
06:12:25 <quicksilver> vincenz: write a program which doesn't care about chunk sizes, and then so some experiments
06:12:34 <vincenz> my program doesn't
06:12:40 <greenrd> I can't login to ghc's trac - neither with my own username and password nor with guest/guest
06:12:48 <quicksilver> vincenz: right. I'm saying I think you're worrying too much about it right now
06:12:53 <vincenz> possibly
06:13:12 <quicksilver> vincenz: I suspect the optimum answer is somewehre between 8k and 4096k
06:13:27 <vincenz> quicksilver: tha's rather large for my purposes
06:14:39 <dolio> "In practice, a chunk size that allows the working set to fit comfortably in the L2 cache has been found to be best."
06:15:20 <vincenz> quicksilver: no way I'm going with lists
06:15:31 <vincenz> this is gonna be dog-slow
06:27:40 <dolio> @fptools Data.Dynamic
06:27:40 <lambdabot> http://darcs.haskell.org/packages/base/Data/Dynamic.hs
06:45:20 <araujo> morning
06:45:37 <beelsebob> moin
07:04:32 <LPhas> @hoogle sendTo
07:04:33 <lambdabot> Network.sendTo :: HostName -> PortID -> String -> IO ()
07:04:33 <lambdabot> Network.Socket.sendTo :: Socket -> String -> SockAddr -> IO Int
07:04:42 <LPhas> > head [1..]
07:04:44 <lambdabot>  1
07:32:38 <glguy> ?yow
07:32:39 <lambdabot> Look into my eyes and try to forget that you have a Macy's charge
07:32:39 <lambdabot> card!
07:36:30 <dolio> "Unfortunately, even Church did not understand the underlying concepts that go beyond lambda calculus."
07:38:02 <emu> isn't muddled thinking fun
07:39:31 <dolio> It's quite something.
07:41:13 <vincenz> dolio: where'd you get that?
07:42:19 <dolio> vincenz: Somebody quoted it from the guy complaining about Backus' and Hughes' papers (among other things).
07:42:49 <dolio> I haven't found it on the actual blog, but all his posts are so long that I'm not sure I'd ever find it.
07:44:16 <vincenz> dolio: the 'opera' blog?
07:44:33 <dolio> Yeah.
07:44:43 <dolio> Seems like something he'd say, though.
08:14:38 <desp> there's a really good paper on LtU today.
08:15:38 <shapr> desp: Which one?
08:15:54 <desp> http://worrydream.com/MagicInk/
08:15:55 <lambdabot> Title: Magic Ink: Information Software and the Graphical Interface
08:16:40 <Nafai> It looked interesting, I haven't had a chance to look at it
08:17:08 <desp> there's an amazing video of a trip planning widget halfway in
08:17:20 <desp> good for a quick look
08:17:20 <desp> http://worrydream.com/MagicInk/bart_widget_demo.html
08:17:21 <lambdabot> Title: BART widget demo
08:17:32 <yaarg> meh he doesn't actually say much in the
08:17:34 <yaarg> "paper"
08:18:38 <shapr> Hm, I can't see the demo in Linux/Firefox.
08:18:50 <Nafai> Me neither
08:19:16 <desp> it's in QuickTime format; you could probably use MPlayer to view it
08:19:55 <phoniq> working for me with gxine
08:20:00 <phoniq> that's a slick widget
08:20:20 <Cale> http://worrydream.com/MagicInk/p/bart_widget_demo.mov
08:24:46 <yaarg> i fell for "Mutable variables eliminated from .NET" on LtU yesterday :(
08:25:35 <Nafai> yaarg: I read everything on the Internet with suspicion yesterday
08:25:56 <yaarg> i didn't realise it was april already ;)
08:26:18 <Nafai> Heh
08:27:49 <sorear> Oh, that's odd.  mg silently drops trailing empty lines.
08:28:05 <sorear> so that's where my spurious hunks are coming from...
08:32:24 <sorear> @seen greenrd
08:32:25 <lambdabot> greenrd is in #ghc and #haskell. I last heard greenrd speak 47m 50s ago.
08:33:00 <greenrd> ...
08:33:53 <dmwit_> Tiled windows have strange shapes in xmonad now.
08:34:28 <sorear> greenrd: Would it be correct if I were to cc the fix for #1260 to map pred "hsffoseAhsffose/psh"
08:38:38 <chessguy> 'morning, haskellers
08:39:13 <sorear> morning chessguy
08:41:12 <chessguy> sorear: what are you doing on here during the day?
08:42:18 <sorear> chessguy: answering newbie q's, competing with lambdabot for the title of most active nick
08:42:30 <sorear> or is that not what you meant?
08:42:41 <chessguy> not quite :)
08:43:31 <sorear> greenrd: patch sent to libraries list
08:50:47 <vali> hmm, if i compile with -S using ghc, is there a way to modify and then compile the asm?
08:55:10 <drigz> can you use guards in a lambda?
08:55:19 <quicksilver> no
08:55:22 <quicksilver> but you can use a let
08:55:41 <drigz> can you use guards in the let?
08:55:52 <quicksilver> let f | 0 > 1 = "Foo" | otherwise = "bar" in f
08:55:56 <quicksilver> yes, you can :)
08:56:13 <drigz> oh, you use guards in the function declaration
08:56:13 <vincenz> @type let f | 0 > 1 = "Foo" | otherwise = "bar" in f
08:56:16 <lambdabot> [Char]
08:56:27 <drigz> you can't do let x = a in | x == 2 ...
08:56:38 <vincenz> drigz: that makes no sense
08:56:47 <drigz> vincenz: there would be newlines
08:56:48 <quicksilver> vincenz: if course it makes sense
08:57:02 <vincenz> quicksilver: yours does, not what drigz typed as code
08:57:09 <quicksilver> guards make sense anywhere, they're just n-ary if-then-else
08:57:20 <vincenz> quicksilver: it's not guarding anything
08:57:34 <Adamant> someone is pimping Haskell on #freebsd as we speak
08:57:48 <hpaste>  drigz pasted "guards in unorthodox places" at http://hpaste.org/1228
08:57:49 <sorear> yay?
08:57:57 <vali> Adamant: pimping?
08:58:06 <vincenz> Adamant: every three seconds someone is pimping Haskell somewhere
08:58:10 <quicksilver> (make sense anywhere you'd expect an expression)
08:58:22 <drigz> crap, i just typed /wc instead of /topic
08:58:28 <drigz> that's a pretty stupid mistake
08:58:44 <dmwit> The keys are like, right next to each other.
08:58:51 <Adamant> vali, the term is used to describe someone doing a sales job sometime.
08:58:58 <vali> Adamant: aah, thanks
08:59:11 <Adamant> it can be negative, or not negative
08:59:37 <drigz> quicksilver: is the let way the recommended way to handle cases in a lambda?
08:59:54 <quicksilver> vincenz: (|x==2 = 5 |x==3 = 8 |otherwise = 11) would denote (if x==2 then 5 else if x== 3 then 8 else 11)
09:00:05 <quicksilver> drigz: a case expression, or a let or where binding
09:00:20 <drigz> quicksilver: ok, thanks
09:01:26 <phoniq> imperative programmer brain cramp
09:01:35 <phoniq> let twice f x = f (f x)
09:01:41 <phoniq> twice :: (t -> t) -> t -> t
09:02:11 * quicksilver recommends let twice f = f . f
09:02:19 <phoniq> yah
09:02:25 <phoniq> i'm trying to grok the type
09:02:50 <phoniq> keep thinking that i dont know f's return type
09:02:51 <sorear> Because the output is used as input, the output and input must be the same type.
09:03:06 <sorear> You don't, not yet.
09:03:13 <drigz> phoniq: easier to read as (t -> t) -> (t -> t)
09:03:36 <sorear> But since the generated code is the same regardless of f's return type, the fact that you don't know doesn't matter.
09:03:38 <dmwit> phoniq: You know that f's return type is the same as f's input type because its output is then sent to f again.
09:03:41 <phoniq> e.g. "maps a function that maps something to something to a different function that maps something to something"
09:03:46 <sorear> This is the essence of polymorphism.
09:03:58 <phoniq> it's those parenthesis i was missing
09:04:03 <phoniq> thanks
09:04:05 <dmwit> (Where all the "something"s are the same, yes.)
09:04:13 <phoniq> right
09:05:47 <phoniq> oh wow
09:05:58 <phoniq> it just figured out that return type must be the same as type of x
09:06:02 <phoniq> all on its own.
09:06:05 <phoniq> unreal.
09:06:25 <dmwit> :t ap
09:06:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:06:55 <dmwit> ?pl /f -> f . f
09:06:56 <lambdabot> (line 1, column 1):
09:06:56 <lambdabot> unexpected "/"
09:06:56 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
09:07:04 <dmwit> ?pl \f -> f . f
09:07:05 <lambdabot> join (.)
09:07:10 <dmwit> :t join
09:07:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
09:07:23 <dmwit> ...
09:07:34 <dmwit> ?instances Monad
09:07:36 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
09:08:30 <phoniq> thanks again
09:08:41 <drigz> ?pl \x -> f x x
09:08:41 <lambdabot> join f
09:09:07 <dmwit> That's a little bit mysterious to me for now. =P
09:11:51 <opqdonut> ?src join
09:11:52 <lambdabot> join x =  x >>= id
09:13:19 <int-e> dmwit: it's the  (->) r  monad instance;  \f x -> f x x  has type  (r -> r -> a) -> r -> a === ((->) r ((->) r a)) -> ((->) r a)
09:13:37 <int-e> @type join
09:13:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
09:14:50 <int-e> @djinn (r -> r -> a) -> r -> a
09:14:50 <lambdabot> f a b = a b b
09:15:32 <dmwit> Okay, interesting.
09:15:50 <dmwit> What's (>>=) for the (->) r instance?
09:16:01 <hpaste>   drigz pasted "unnecessary code causes error" at http://hpaste.org/1229
09:16:13 <drigz> will that work? (see pasted code)
09:16:34 <glguy> drigz: that's fine
09:16:37 <dmwit> Should work
09:17:10 <glguy> drigz: but , !! starts counting at 0
09:17:11 <drigz> :( i'm doing that and i'm getting an error
09:17:23 <glguy> drigz: so, you might be making the mistake of going off the end
09:17:27 <glguy> which would cause your error
09:17:30 <drigz> oh yeah, that was a typo
09:17:38 <drigz> i'm not doing that exact code
09:17:49 <drigz> i'm using an array for a start
09:17:58 <drigz> i wish the index error told you the index
09:18:08 <glguy> > let x = error "doesn't break" in if False then x else 1
09:18:11 <lambdabot>  1
09:18:42 <dmwit> drigz: You could be going off the other end...
09:18:56 <twb> Stupid question: can cabal be used to build non-Haskell projects?
09:19:00 <drigz> i _shouldn't_ be, but maybe i am
09:19:37 <sorear> twb: Not effectively
09:19:45 <twb> That's what I thought.  Thank you.
09:22:01 <hpaste>   drigz pasted "array index error" at http://hpaste.org/1230
09:22:17 <drigz> i'm not seeing the problem :( can someone look at my code?
09:22:33 <drigz> any style comments are also appreciated
09:24:08 <dmwit> split d (tail t) -- you don't know if t is nonempty yet
09:24:15 <dmwit> (Just a first thought.)
09:24:20 <Batterseapower> i'm probably wrong, but "if x == 0 then goY"
09:24:26 <glguy> ?index iterate
09:24:27 <lambdabot> Data.List, Prelude
09:24:30 <Batterseapower> but goY accesses an element at x-1 ?
09:24:35 <Batterseapower> = index -1
09:24:46 <glguy> your code will confuse Haskell programmers if you reuse names from the Prelude like that :)
09:25:05 <drigz> Batterseapower: oh no, i mixed the letters up
09:25:07 <drigz> thanks!
09:25:31 <Batterseapower> no problem :)
09:25:40 <drigz> yay! it works
09:25:57 <drigz> dmwit: it only has to work for one input file :)
09:26:35 <glguy> drigz: instead of your iterate line:
09:26:48 <glguy> drigz: consider: liftM lines (readFile "matrix.txt")
09:27:42 <drigz> glguy: cool, that's way shorter
09:27:52 <chessguy> @quote melt
09:27:52 <lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
09:28:28 <chessguy> @type liftM
09:28:31 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
09:28:52 <chessguy> @type liftM lines
09:29:00 <lambdabot> forall (m :: * -> *). (Monad m) => m String -> m [String]
09:29:21 <glguy> or if you are like me and avoid parentheses when possible :)
09:29:28 <glguy> lines `fmap` readFile "matrix.txt"
09:29:44 <drigz> @type fmap
09:29:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:30:17 <dmwit> For monads, fmap === liftM ?
09:30:31 <glguy> yeah
09:30:33 <chessguy> ermmm. IO is a functor?
09:30:37 <glguy> yeah
09:30:52 <chessguy> hmm
09:31:03 <dmwit> ?src Functor
09:31:03 <lambdabot> class  Functor f  where
09:31:03 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
09:31:09 <dmwit> All monads are functors, no?
09:31:11 <glguy> ?instances Functor
09:31:12 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
09:31:20 <drigz> i have almost no idea what a monad is and even less what a functor is :p it's all kind of black magic for me
09:31:24 <glguy> dmwit: All monads are able to be Functors
09:31:29 <glguy> dmwit: there is no requirement
09:31:34 <dmwit> Ah, okay.
09:32:25 <chessguy> wierd. the docs say IO is an instance of functor, but functor doesn't appear in the source for IO
09:32:37 <glguy> drigz: sometimes you have data wrapped in some other type (maybe a list or IO or whatever)
09:32:43 <glguy> and a function that acts on the wrapped type
09:32:51 <glguy> say an Int
09:33:02 <glguy> but not on an IO Int
09:33:10 <vali> hmm, if i compile with -S using ghc, is there a way to modify and then compile the asm?
09:33:15 <glguy> since you can't bring the data to the function
09:33:20 <glguy> you take the function to the data with fmap
09:33:28 <glguy> lines :: String -> [String]
09:33:37 <glguy> fmap lines :: IO String -> IO [String]
09:33:51 <glguy> (*2) :: Int -> Int
09:34:00 <glguy> map (*2) :: [Int] -> [Int]
09:34:15 <drigz> that's clever
09:34:29 <sorear> vali: why?  sounds like there's probably a better way to get what you are after
09:34:35 <chessguy> fmpa (*2) :: m Int -> m Int
09:34:38 <glguy> fmap just takes a function that acts on individuals and returns a function that acts on things in a functor
09:34:46 <dmwit> vali: -keep-s-file?
09:34:47 <chessguy> s/pa/ap/
09:35:01 <vali> sorear: because i might be able to do some interesting tricks that i can't do from within haskell
09:35:05 <vali> dmwit: hmm?
09:35:09 <glguy> fmap (*2) :: (Functor f, Num n) => f n -> f n
09:35:24 <chessguy> err, yeah. f, not m
09:35:29 <sorear> vali: well, you don't want to rewrite those tricks every time you change the haskell!
09:35:42 <glguy> f or m doesn't matter, but if you are going ot use f or m you need to say what they are :)
09:35:43 <sorear> vali: can you use the FFI?
09:36:05 <chessguy> yeah, i was leaving the typeclass implicit
09:36:09 <vali> sorear: not yet
09:36:10 <chessguy> i'm lazy :)
09:36:46 <dmwit> vali: If you're using -S, doesn't it generate a .s file?
09:36:53 <vali> dmwit: yes
09:37:03 <dmwit> I guess the question I'm asking is, what is stopping you from doing what you want?
09:37:28 <vali> dmwit: how can i compile/link the .s after i've modified it?
09:37:55 <malcolmw> ghc -c file.s
09:38:38 * chessguy wonders if whaleofconfusion has ever landed next to a flowerpot on an extremely improbable planet
09:38:51 <opqdonut> haha
09:38:52 <dmwit> heh
09:39:49 <glguy> other than "spontaneously popped into existence" I wonder what a situation that would lead to that might be
09:41:11 <chessguy> i don't know, but i think it would have to involve an improbability drive :)
09:42:12 <chessguy> ?losers
09:42:12 <lambdabot> Maximum users seen in #haskell: 337, currently: 313 (92.9%), active: 39 (12.5%)
09:43:10 <drigz> harsh stuff
09:45:56 <sioraiocht> hahahahahahah
09:47:59 <whaleofconfusion> you might be a member of the Interplanetary Skydiving and Petunia Appreciation Club
09:49:20 <dmwit> :t min
09:49:22 <lambdabot> forall a. (Ord a) => a -> a -> a
09:49:34 <chessguy> oh, i hadn't realized ISPAC allowed whales to join. that makes a lot of sense
09:50:13 <sorear> Wasn't a whale one of the founding members?
09:50:30 <chessguy> for about 47 seconds :)
09:50:50 <thedward> or was he the foundering member?
09:51:06 <chessguy> ?all-dict foundering
09:51:09 <lambdabot> *** "Foundering" gcide "The Collaborative International Dictionary of English v.0.48"
09:51:09 <lambdabot> Founder \Found"er\, v. i. [imp. & p. p. {Foundered}; p. pr. &
09:51:09 <lambdabot>    vb. n. {Foundering}.] [OF. fondrer to fall in, cf. F.
09:51:09 <lambdabot>    s'effondrer, fr. fond bottom, L. fundus. See {Found} to
09:51:09 <lambdabot>    establish.]
09:51:11 <lambdabot> [26 @more lines]
09:51:31 <sorear> Wow.  That was completely unhelpful.
09:51:46 <chessguy> @more
09:51:47 <lambdabot>    1. (Naut.) To become filled with water, and sink, as a ship.
09:51:47 <lambdabot>       [1913 Webster]
09:51:47 <lambdabot>  
09:51:47 <lambdabot>    2. To fall; to stumble and go lame, as a horse.
09:51:47 <lambdabot>       [1913 Webster]
09:51:49 <lambdabot> [21 @more lines]
09:52:20 <drigz> i think it will be quicker to use a browser than to type @more 6 times
09:52:26 <dmwit> ?expand ISPAC
09:52:26 <lambdabot> Unknown command, try @list
09:52:35 <chessguy> ?vera ISPAC
09:52:37 <lambdabot> No match for "ISPAC".
09:52:42 <drigz> ?help vera
09:52:42 <lambdabot> I perform dictionary lookups via the following 13 commands:
09:52:43 <lambdabot> all-dicts ... Query all databases on dict.org
09:52:43 <lambdabot> devils ...... The Devil's Dictionary
09:52:43 <lambdabot> easton ...... Easton's 1897 Bible Dictionary
09:52:43 <lambdabot> elements .... Elements database
09:52:44 <lambdabot> [9 @more lines]
09:52:49 <thedward> ?help tla
09:52:50 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:53:02 <thedward> ?help wtf
09:53:03 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:53:06 <dmwit> What ISPAC?
09:53:09 <sorear> Just wait, lambdbabot7 will have that
09:53:18 <thedward> Interplanetary Skydiving and Petunia Appreciation Club
09:53:19 <chessguy> whaleofconfusion> you might be a member of the Interplanetary Skydiving and Petunia Appreciation Club
09:53:20 <sorear> <*whaleofconfusion> you might be a member of the Interplanetary Skydiving and Petunia Appreciation Club
09:53:32 <opqdonut> haha
09:53:34 <sorear> @quote stereo
09:53:34 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
09:53:37 <drigz> dmwit: still unsure?
09:53:41 <drigz> :p
09:53:44 <sorear> Even the non-haskell ones.
09:53:57 <dmwit> Hahaha!
09:54:28 <chessguy> it's a shame there's no good way to @remember conversations. this is a classic :)
09:54:59 <sorear> **TAG** ISPAC
09:55:19 <sorear> that's for the logs
09:55:29 <chessguy> :)
09:55:33 <sorear> now in a couple weeks google TAG ISPAC
09:55:53 <SyntaxNinja> @seen cosmicray
09:55:53 <lambdabot> I saw cosmicray leaving #haskell, #haskell-blah and #darcs 4d 18h 48m 8s ago, and .
09:55:58 <dmwit> Is there a way to find out the most general class that encompasses both 0 and 1?
09:55:59 <SyntaxNinja> and .
09:56:02 <sorear> of course, lambdabot7 will have @grep-logs
09:56:14 <sorear> dmwit: classes contain types.  0 and 1 are terms.
09:56:21 <dmwit> Right, okay.
09:56:51 <sorear> :t 0 `asTypeOf` 1 will do what you wnat
09:56:53 <lambdabot> parse error on input `do'
09:56:59 <sorear> :t 0 `asTypeOf` 1
09:57:01 <lambdabot> forall t. (Num t) => t
09:57:09 <dmwit> Great, thanks.
09:57:24 <sorear> all numeric literals have that type...
09:57:32 <chessguy> @type asTypeOf
09:57:35 <lambdabot> forall a. a -> a -> a
09:57:37 <dmwit> I was going to type up a superficially modified version of the question, but since it's already answered... =)
09:57:49 <sorear> @src asTypeOf
09:57:49 <lambdabot> asTypeOf = const
09:58:13 <drigz> how can you tell the ordering of the result of a list comprehension
09:58:25 <chessguy> > const 0 1
09:58:27 <lambdabot>  0
09:58:32 <sorear> > read "\"foo\\\"bar\""
09:58:33 <chessguy> > const 0 1 2
09:58:34 <lambdabot>  Exception: Prelude.read: no parse
09:58:35 <lambdabot>   add an instance declaration for (Num (t -> a))
09:58:36 <drigz> like [(a, b) | a <- [1..3], b <- [6..9]]
09:58:44 <sorear> > read "\"foo\\\"bar\"" `asTypeOf` ""
09:58:46 <lambdabot>  "foo\"bar"
09:58:52 <dmwit> drigz: a varies fastest.
09:58:52 <sorear> that's the use for asTypeOf
09:59:11 <sorear> asTypeOf is something of a historical relic
09:59:21 <dmwit> > [(a, b) | a <- [1,2], b <- [3,4]]
09:59:22 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
09:59:26 <chessguy> sorear: how in the world do you remember all this stuff?
09:59:26 <sorear> it dates from before we had type annotations
09:59:36 <sorear> not sure..
09:59:39 <dmwit> drigz: I'm wrong, b varies fastest. =P
09:59:51 <Cale> sorear: uh, not quite
10:00:04 * sorear prepares to learn!
10:00:18 <drigz> dmwit: do you know if it's assured? or that's just what happens in this implementation
10:00:26 <sorear> it's assured
10:00:34 <drigz> ok, thanks
10:00:41 <sorear> the report gives a desugaring of comps that guarantees it
10:00:42 <Cale> It was before we had type annotations on patterns.
10:00:59 <Cale> (Haskell's always had type annotations)
10:01:26 <Cale> There are certain types which it's impossible to annotate though.
10:01:31 <sorear> uh, we still don't have type annotations on patterns ... the folks in #ghc do, but in general we don't
10:01:52 <Cale> In general, right.
10:06:12 <hpaste>   drigz pasted "parse error" at http://hpaste.org/1231
10:06:30 <drigz> what's wrong with the pasted code (other than that it's really ugly and inefficient)?
10:06:58 <drigz> (help fixing ugliness would be appreciated too)
10:07:45 <Cale> where n == length l
10:08:03 <drigz> also there shouldn't be a concat
10:08:33 <drigz> Cale: ah, thanks
10:08:42 <drigz> it reported the parse error on line 7...
10:08:48 <Cale> Let's see if we can clean up pairs.
10:09:02 <int-e> > let pairs xs = [(x,y) | (x:xs') <- tails xs, y <- xs'] in pairs [1,2,3,4]
10:09:04 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
10:09:09 <Cale> Is the order crucial?
10:09:28 <drigz> that those with greater separation come first is crucial, i'm afraid
10:09:33 <drigz> the order of i isn't
10:10:23 <dolio> :t comparing
10:10:26 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
10:10:56 <dmwit> Oh, is that standard now?
10:11:05 <int-e> > let pairs xs = concat . transpose . reverse $ [[(x,y) | y <- xs'] | (x:xs') <- tails xs] in pairs [1,2,3,4] -- hmm
10:11:05 <dmwit> I thought I always had to write it myself.
10:11:07 <lambdabot>  [(3,4),(2,3),(1,2),(2,4),(1,3),(1,4)]
10:11:20 <sorear> dmwit: yeah, it's standard as of 6.6
10:11:23 <int-e> > let pairs xs = concat . reverse . transpose $ [[(x,y) | y <- xs'] | (x:xs') <- tails xs] in pairs [1,2,3,4] -- hmm
10:11:24 <lambdabot>  [(1,4),(1,3),(2,4),(1,2),(2,3),(3,4)]
10:11:32 <dmwit> Ah, I'm on 6.4 still.
10:11:34 <sorear> dmwit: if you get a more recent ghc, you'll even get on!
10:11:41 <dmwit> :t on
10:11:43 <lambdabot> Not in scope: `on'
10:11:46 <dmwit> ?
10:11:56 <dolio> > let pairs xs = sortBy (comparing $ uncurry (-)) [ (x,y) | (x:xs) <- tails xs, y <- xs'] in pairs [1..4]
10:11:57 <sorear> Prelude> :t Data.Function.on
10:11:57 <lambdabot>   Not in scope: `xs''
10:11:57 <sorear> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
10:12:21 <sorear>  / /_\// /_/ / /  | |      GHC Interactive, version 6.7.20070402, for Haskell 98.
10:15:52 <int-e> drigz:  map sum . inits  is quite awful.  use  scanl (+) 0  instead.
10:16:00 <int-e> > scanl (+) 0 [1..4]
10:16:01 <lambdabot>  [0,1,3,6,10]
10:16:21 <drigz> int-e: i was trying to remember the name of scanl, and then i gave up. thanks!
10:18:48 <int-e> you need to import Data.List for that
10:20:51 <Cale> It would be nice if ghc knew that  map (foldl f z) . inits = scanl f z
10:22:03 <sorear> I'm of the persuasion compilers should not be allowed to make programs asymptotically faster without -fallow-confusing-optimizations ...
10:22:34 <Cale> Laziness already makes things asymptotically faster.
10:22:47 <drigz> i thought ghc was meant to be able to memoise functions behind the scenes
10:22:56 <Cale> I'm happy if things end up faster than I'd ordinarily expect them to be.
10:22:56 <sorear> Laziness is clearly specified.  RULES aren't.
10:23:08 <emu> asymptotically faster like as in:
10:23:14 <emu> > head [1..]
10:23:15 <lambdabot>  1
10:23:18 <drigz> which is why people think they can get away with writing fib n = (fib (n-1)) + (fib (n-2))
10:23:34 <Cale> drigz: it doesn't memoise at all
10:23:37 <sorear> Haha, no, ghc isn't that smart.
10:23:46 <drigz> Cale: i know, but theoretically it could
10:23:48 <Cale> drigz: but it will share results that come from the same variable
10:23:52 <drigz> which is what annoying people claim
10:24:04 <sorear> it wouldn't hurt asymptotically to do that
10:24:05 <drigz> and then they say look how amazingly readable haskell is!
10:24:08 <dolio> It could, but it wouldn't always be good.
10:24:08 <Cale> It could, and programs could use a lot more memory too
10:24:29 <drigz> sorear: ?! that takes O(e^n)
10:24:37 <sorear> Oh, with a sufficiently clever GC memory usage isn't a problem.
10:24:53 <whaleofconfusion> GC uses more memory than no GC
10:24:54 <sorear> drigz: I meant memoization is asymptotically safe.
10:25:12 <whaleofconfusion> typically by a factor of two to five
10:25:15 <sorear> And I'm not being facetious - I've seen GC's that can handle full memoization.
10:25:21 <Cale> sorear: you mean an impossibly clever GC?
10:25:42 <Cale> One which, among other things, solves the halting problem?
10:25:43 <drigz> sorear: surely with memoisation it's O(n)?
10:25:45 <sorear> However, like laziness, full memoization imposes a stiff constant factor penalty.
10:26:05 <sorear> Unlike laziness, full memoization is very nonlocal, and probably impossible to optimize out.
10:26:09 <whaleofconfusion> fast code is almost irrelevant on today's processors
10:26:21 <sorear> Cale: no.  it just needs to discard LRU memoizations.
10:26:22 <whaleofconfusion> today's processors are fast enough to compensate for perl
10:26:29 <drigz> you don't need full memoisation, you just need memoisation where magically determined appropriate :)
10:26:41 <whaleofconfusion> so long as you are asymptotically ok then the processor will take care of almost any constant factor
10:27:05 <Cale> sorear: hm?
10:27:09 <whaleofconfusion> the problem with memoization is memory, isn't it, not speed
10:27:21 <Cale> whaleofconfusion: yes
10:27:26 <sorear> Cale: hashlife
10:28:06 <Cale> ah, okay.
10:28:30 <Cale> So you could have constant-sized memo tables
10:29:02 <sorear> you have to expire old memoizations.  imagine if $OS never expired pages from the disk cache, you'd be out of memory in no time.  but that's hardly an argument to not have a disk cache
10:29:43 <drigz> or we could do what perl does (have i just suggested something very silly?) where you just say 'i want this function memoized'
10:30:01 <Cale> Another problem is that you typically end up doing extra comparisons.
10:30:27 <sorear> drigz: we have that.  unfortunately spjaper /= hackage, hence hard to use :)
10:30:37 <Cale> which might be okay sometimes, and other times, not okay
10:30:41 <whaleofconfusion> for naive factorial you hardly need any memoization
10:30:44 <vali> is there any good toolkit for creating portable gui applications with haskell?
10:30:46 <whaleofconfusion> memoizing 2 past values is enough
10:30:52 <sorear> see above about hard to optimize constant-factor memoization
10:30:53 <Cale> For example, consider a function which takes a very large array.
10:31:04 <sorear> vali: wxHaskell or gtk2hs
10:31:13 <vali> sorear: thank you
10:31:25 <Cale> Comparing its parameter for equality with a memoised result could be more expensive than the entire function call.
10:31:41 <whaleofconfusion> not in the case of factorial
10:31:42 <drigz> sorear: spjaper? a paper written by simon peyton-jones?
10:31:57 <whaleofconfusion> i mean no, not factorial, fibonacci
10:31:57 <sorear> Cale: reallyUnsafePointerEq# comes in handy here
10:32:00 <whaleofconfusion> whatm i saying
10:32:02 <Cale> You could compare on address, but then your memoisations won't work half the time.
10:32:03 <sorear> drigz: yeah :)
10:32:35 <sorear> You could use hash consing, thereby completely invalidating Cale's most recent point.
10:32:44 <sorear> However in the process you lose laziness.
10:33:01 <Cale> :)
10:33:02 <drigz> sorear: so you're saying that it has been written about but not implemented? or implemented but not put in GHC?
10:33:27 <sorear> drigz: implemented, but it's rather hard to import a pdf file
10:33:43 <drigz> how do you pronounce spjaper?
10:33:50 <drigz> if at all
10:34:08 <whaleofconfusion> spay jayper?
10:34:11 <sorear> well, so far I'm the only one who has used it...
10:34:12 <whaleofconfusion> pajama paper?
10:34:18 <Cale> It's easy to import a PDF file, you just type in the code from it.
10:34:31 <Cale> (or copy and paste)
10:35:03 <whaleofconfusion> memoizing manually is not hard to do in haskell
10:35:27 <dolio> Which paper is it?
10:35:32 <Cale> whaleofconfusion: right, especially as you can use sharing to get the same effect
10:35:33 <drigz> whaleofconfusion: harder than in imperative languages...
10:35:40 <drigz> especially for us newbies
10:35:47 <sorear> @google Stretching the storage manager: weak pointers and stable names in Haskell
10:35:51 <lambdabot> http://citeseer.ist.psu.edu/peytonjones99stretching.html
10:35:51 <lambdabot> Title: Stretching the storage manager: weak pointers and stable names in Haskell - Jone ...
10:36:04 <drigz> sorear: thanks
10:36:08 <sorear> memofix being the example uses
10:36:10 <whaleofconfusion> well for fibonacci for example, you can just have an array of values for fibonacci
10:36:11 <sorear> *used
10:36:28 <whaleofconfusion> and the fibonacci function is defined as sum of the values of the 2 previous _array_ cells
10:36:39 <whaleofconfusion> and the array cells are defined as fibonacci of the index of the cell
10:37:01 <sorear> there as a nice thread back on highly efficient implementations of fib
10:37:02 <Cale> Or just use a list
10:37:03 <whaleofconfusion> it's 1 extra line to define the memoizing array
10:37:15 <whaleofconfusion> or a list
10:37:30 <Cale> > fix ((0:) . scanl (+) 1)
10:37:31 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
10:37:41 <dolio> whaleofconfusion: That's too much work. You should just do it once, making a memoizing Y combinator. :)
10:37:49 <dolio> Then reuse it all the time.
10:37:54 <sorear> whaleofconfusion: in 3 LoC I implemented the Gosper/Salamin fast fibonacci of HAKMEM fame.  Computes fib(200 million) in ~10 seconds.
10:38:19 <whaleofconfusion> is that were you compute it directly by the exponent?
10:38:19 <Cale> > fix ((0 :) . (1 :) . ap (zipWith (+)) tail)
10:38:21 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
10:38:42 <Cale> whaleofconfusion: no
10:38:44 <sorear> whaleofconfusion: exponent method doesn't give exact results
10:38:53 <Cale> Also, it's really slow.
10:38:56 <whaleofconfusion> yes it does, you just take the floor or ceiling
10:39:03 <whaleofconfusion> forget which
10:39:10 <whaleofconfusion> actually I think it's a round to the nearest int
10:39:15 <Cale> whaleofconfusion: how many digits do you have to compute?
10:39:21 <sorear> whaleofconfusion: does your Double type keep 200+ million sig. digits?
10:39:54 <whaleofconfusion> so how does gosper/salamin work?
10:40:36 <sorear> it transforms the linear recurrence into an iterated matrix equation, then uses squaring exponentiation
10:40:45 <sorear> or maybe it was complex number based
10:40:47 <whaleofconfusion> how does it deal with the large number of digits?
10:40:53 <sorear> Integer
10:40:59 <sorear> > 2^128
10:41:01 <lambdabot>  340282366920938463463374607431768211456
10:41:26 <whaleofconfusion> it would still have millions of digits
10:41:32 <drigz> ,
10:41:45 <sorear> whaleofconfusion: I have *megabytes* of ram
10:41:46 <Cale> When you get right down to it, it's just using the doubling formulas for F_n
10:42:08 <whaleofconfusion> you could do it with an infinite precision double type
10:42:28 <Cale> whaleofconfusion: That's going to be way, way slower.
10:42:44 <whaleofconfusion> why?
10:43:14 <whaleofconfusion> you probably don't have too store too many digits to the right of the decimal point
10:43:22 <mightybyte> > map (*) [1..500]
10:43:23 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>,<Integer -> ...
10:43:33 <Cale> Floating point exponentiation is slow.
10:43:36 <mightybyte> >map (*) [1..500]
10:43:42 <sorear> Interestingly, the Gosper-Salamin fib in pure haskell is only 30% slower than GMP's mpz_fib2_ui.  FFI++
10:43:55 <mightybyte> Oops
10:44:01 <drigz> sorear: is that with ugly unboxings etc?
10:44:02 <mux> @instances Ord
10:44:03 <lambdabot> (), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
10:44:05 <mightybyte> > foldl (*) 1 [1..500]
10:44:06 <lambdabot>  1220136825991110068701238785423046926253574342803192842192413588385845373153...
10:44:08 <sorear> drigz: no!
10:44:13 <Jaak> > () < ()
10:44:15 <lambdabot>  False
10:44:16 <drigz> sorear: wow
10:44:42 <sorear> drigz: since it spends all its time in GMP's hand-optimized pentium asm inner loops, it is no slower on yhc/hugs than ghc!
10:45:02 <drigz> i guess ghc uses GMP for Integer
10:45:13 <sorear> yes.
10:49:17 <LPhas> > +
10:49:18 <lambdabot>  Parse error
10:49:22 <LPhas> > (+)
10:49:23 <lambdabot>  <Integer -> Integer -> Integer>
10:49:36 <LPhas> > :i Show
10:49:37 <lambdabot>  Parse error
10:49:50 <LPhas> but are functions members of Show?
10:49:56 <sorear> no
10:50:00 <sorear> not normally
10:50:00 <sorear>  
10:50:25 <sorear> lambdbaot has an evil instance Typeable a => Show a where show = show . typeOf
10:50:42 <LPhas> sorear: oh i see
10:50:53 <LPhas> sorear: cool
10:51:15 <Cale> whaleofconfusion: it's possible to compute fib n with O(log n) arithmetic operations.
10:51:57 <whaleofconfusion> computing it with double exponentiation also has that complexity
10:52:19 <whaleofconfusion> so I'm not surprised
10:52:33 <Cale> hmm
10:52:49 <Cale> What's the complexity of computing sqrt(5)?
10:52:56 <emu> constant
10:53:03 <Cale> emu: not here it isn't
10:53:10 <emu> it's one value
10:53:13 <emu> :P
10:53:16 <Cale> It's irrational
10:53:31 <Cale> and you need more and more digits of it as n increases
10:53:36 <emu> hmm
10:54:03 <Cale> Newton's method will roughly double the number of digits you get on each iteration, I suppose.
10:54:16 <emu> well that answers my question before i asked
10:55:00 <Cale> So it still might technically work out to be logarithmic overall
10:55:16 <whaleofconfusion> though the actual time is not logarithmic because the arithmetic operations are expensive
10:55:26 <whaleofconfusion> not O(10
10:55:28 <whaleofconfusion> O(1)
10:55:41 <Cale> Right, and the numbers get very very large.
10:55:51 <whaleofconfusion> which is true of any method you ouse
10:56:04 <sorear> whaleofconfusion: gs-fib is O(n log(n) log(log(n))) because the whole number is O(n)
10:56:08 <sorear> + bits
10:56:17 <waern> lemmih, ping
10:56:31 <sorear> O(n log(n) log(log(n))) being the asymptotic complexity of multiplication
10:57:08 <whaleofconfusion> so gs-fib would be longer than that
10:57:22 <whaleofconfusion> because it does multiple multiplications
10:57:34 <whaleofconfusion> presumably
10:57:38 <sorear> no, because each multiplication is so much bigger than the last
10:57:53 <sorear> n + n/2 + n/4 + n/8 + n/16 ... = 2*n = O(n)
10:58:13 <whaleofconfusion> ok
10:58:43 <Cale> Have you implemented the O(n log n log log n) multiplication? :)
10:59:32 <sorear> No, but I don't have to
11:00:08 <Cale> Does GMP implement it, or does it just use Karatsuba multiplication?
11:00:09 <sorear> GMP implements it, and GHC binds to it
11:00:31 <sorear> it branches on the size of the numbers
11:00:58 <sorear> naive, karatsuba, order-3 toom-cook, Schoenhage-Strassen
11:01:07 <sorear> at least that's what info gmp says
11:01:20 <Cale> cool
11:02:04 <cpoucet> que pasa
11:03:41 <dmwit> Does Haskell have an analogue to C's ability to split function declarations from definitions?
11:03:49 <dmwit> Specifically, put them in separate (importable) files?
11:03:53 <sorear> sortof
11:04:08 <sorear> you can export functions that are defined in other modules
11:04:23 <sorear> module Foo(nub) where -- legal, and no name resolution errors
11:04:45 <dmwit> Hmmm... I'll have to think a little bit to see if that is useful.
11:05:36 <int-e> but I think you still need cpp magic to import the right implementation in your base module :/
11:06:02 <int-e> unless you make the implementation details a separate package maybe
11:06:04 <dmwit> So the context is xmonad's key-binding file, Config.hs.
11:06:32 <dmwit> The problem is that the key list is needed in Operations.hs, and the operations from Operations.hs are needed to define the key list.
11:06:55 <dmwit> Well, that's an approximation to the situation.
11:07:27 <dmwit> If there were a way for me to say, "I know I've defined a function foo :: a -> b somewhere, but just not here," the problem would be solved...
11:10:17 <sorear> That exists, as a GHC extensionn
11:10:24 <sorear> hs-boot files
11:11:25 <joelr1> good day! is there a darcs repo for parsec?
11:11:41 <dmwit> sorear: Not in 6.4, I think. =(
11:12:00 <dmwit> joelr1: Parsec should come with your base installation, right?
11:12:13 <joelr1> dmwit: i never thought of that :)
11:12:53 <Saizan> ?source Text.ParserCombinators.Parsec
11:12:54 <lambdabot> http://darcs.haskell.org/packages/parsec/Text/ParserCombinators/Parsec.hs
11:12:57 <mux> http://darcs.haskell.org/packages/parsec
11:12:59 <lambdabot> Title: Index of /packages/parsec
11:13:08 <mux> feh, too late
11:25:27 <joelr1> is there a sample parsec file that uses a hash table of keywords?
11:25:50 <TomMD> ?src cycle
11:25:51 <lambdabot> cycle [] = undefined
11:25:51 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
11:26:50 <dmwit> joelr1: What do you mean?
11:27:07 <eumenides> xmonad is pretty good
11:27:15 <sjanssen> eumenides: thanks
11:27:26 <sjanssen> eumenides: any comments?
11:27:27 <joelr1> dmwit: i'm using a keyword table to check for keywords in my existing parser
11:27:35 <xs> is it likely that possibly one day ghc might care about low memory systems? i've just tried to install gtk bindings (from debian) and it fails, invoking the oom killer (i have 64mb of ram)
11:27:36 <joelr1> dmwit: trying to figure out how to do this in parsec
11:28:15 <dmwit> Like (string "foo" <|> string "bar"), or what?
11:28:34 <sjanssen> xs: you might be able to get by if you allocate some swap memory
11:28:37 <sorear> xs: that's not gtk's fault
11:28:51 <sorear> s/gtk/ghc/
11:28:56 <eumenides> sjanssen: i've just started using it. does it have floating windows?
11:29:04 <sjanssen> eumenides: not yet
11:29:04 <sorear> xs: if you look at the logs, it's almost certainly ar that exhausted memory
11:29:13 <sorear> xs: complain to the binutils maintainers ;)
11:29:50 <hpaste>  dmwit pasted "faster dmenu_path on some systems" at http://hpaste.org/1232
11:30:01 <eumenides> sjanssen: they'd be nice but then the amount i use gimp i can do without them :)
11:30:07 <dmwit> Whoops, didn't mean to announce that, sorry.
11:30:31 <xs> sorear: no. ghc should support dynamic linking.
11:31:04 <sorear> xs: And that would be better how?
11:31:28 <sorear> xs: ar is in theory capable of much lower mem. usage than ld -shared
11:31:35 <xs> sorear: well, the ar step would be unnecessary; pages of memory could be shared between resident haskell programs (e.g., xmonad)
11:31:53 <xs> sorear: this is a binary package. why do i need ld -shared ? :)
11:32:11 <sorear> xs: gtk?
11:32:26 <sorear> xs: if it is a binary package, you shouldn't have run ghc at all
11:32:55 <xs> sorear: hmm... then is this a debian packaging problem? it seems to want to run ghc to register the package, i think.
11:33:31 <sorear> xs: ghc-pkg shouldn't use much memory at all..
11:37:41 <kolmodin> sjanssen, dons: is it xmonad or XMonad?
11:38:02 <xs> sorear: the step that kills it is building the ghci library.
11:38:25 <xs> sorear: but also the lack of shared libraries is pretty depressing.
11:40:43 <kolmodin> looks like it's simply 'xmonad'
11:43:05 <sorear> If I start 21 threads, one of which regularly prints messages, and the messages don't get printed even with +RTS -N40, is that a bug?
11:43:42 <dmwit> Well... somewhere there's a bug, yes. ;-)
11:43:50 <sjanssen> kolmodin: hmm, I haven't actually decided
11:43:53 <bvd> Hello, I would like to mimmic the mathematical notation: b < x < e that specifies that x is beteen b and e. So I would like:   (0 .<. 3) .<. 10   to evaluate to True.
11:43:56 <hpaste>  Bas van Dijk pasted "FreakyOrd" at http://hpaste.org/1233
11:43:58 <fuzan> what do +RTS and -N40 do?
11:44:11 <sjanssen> kolmodin: it is officially 'xmonad' now
11:44:12 <sjanssen> :)
11:44:16 <kolmodin> sjanssen: ok
11:44:25 <kolmodin> sjanssen: mind me writing about it an a blog entry?
11:44:34 <kolmodin> as it hasn't been announced yet
11:44:53 <sorear> it's been leaked to reddit :(
11:45:12 <sjanssen> kolmodin: that's fine, it's already been redditted.  Maybe you could mention that it's currently unreleased?
11:45:20 <kolmodin> sjanssen: sure, np
11:45:29 <kolmodin> sjanssen: anything missing that it will add?
11:46:21 <fuzan> @pl (x > e ) > b
11:46:22 <lambdabot> (x > e) > b
11:46:30 <fuzan> @pf (x > e ) > b
11:46:31 <sorear> Ok, it appears to be not so much broken as extremely slow.
11:46:31 <lambdabot> Maybe you meant: bf pl
11:46:39 <fuzan> what is the !pl?
11:46:42 <dmwit> kolmodin: There's a few things left I'd like to see, but I think xmonad is currently in feature freeze until the release.
11:46:52 <opqdonut> fuzan: converts function into point-free
11:46:53 <sorear> Running 40 capabilities on a 1-cpu machine - not friendly.
11:47:03 <sjanssen> kolmodin: there are a handful of things we still want to implement, but they'll wait until after 0.1
11:47:04 <fuzan> i know, there's pl, and what' shte other one?
11:47:07 <opqdonut> @pl \f x -> f x
11:47:08 <lambdabot> id
11:47:15 <kolmodin> sjanssen: ok, great
11:47:15 <opqdonut> @unpl id
11:47:16 <lambdabot> (\ a -> a)
11:47:19 <fuzan> that's it.
11:47:22 <fuzan> @unpl (x > e ) > b
11:47:22 <lambdabot> ((x > e) > b)
11:47:36 <fuzan> i was hoping for something more elegant.
11:47:41 <opqdonut> errrr
11:47:45 <opqdonut> what do you want to do?
11:47:47 <dmwit> fuzan: That's not a function. ;-)
11:47:51 <opqdonut> yeah
11:47:58 <fuzan> :T (>)
11:48:01 <fuzan> :t (>)
11:48:03 <xerox> bvd: you'd better write |between :: (Fractional a) => a -> a -> a -> Bool|.
11:48:05 <lambdabot> forall a. (Ord a) => a -> a -> Bool
11:48:09 <dmwit> ?unpl \x b -> (x < e) < b
11:48:09 <lambdabot> \ x b -> (x < e) < b
11:48:16 <dmwit> ?pl \x b -> (x < e) < b
11:48:17 <opqdonut> ?pl \x e b -> (x > e) > b
11:48:17 <lambdabot> (<) . (< e)
11:48:17 <lambdabot> ((>) .) . (>)
11:48:20 <opqdonut> hihi
11:48:42 <enkrav> I am trying to construct a game tree: What should I do when I get:  Occurs check: cannot construct the infinite type: b = ((a, b1), [(a1, b)])
11:48:47 <fuzan> ah
11:49:08 <dolio> > inRange (1, 10) 5
11:49:09 <lambdabot>  True
11:49:14 <Heffalump> you should fix your code so it doesn't confuse types like that :-)
11:49:16 <dmwit> enkrav: Something like data Tree a = Node a [Tree a]
11:49:17 <kpreid> enkrav: introduce a data type
11:49:19 <bvd> xerox: Yeah I know but this is just a funny exercise I'm giving myself. I would like to mimmic the mathematical notation as close as possible.
11:49:36 <enkrav> ok
11:49:45 <xerox> bvd: try to work out a type for the (.<.) function
11:49:58 <dmwit> xerox: Check out the hpaste he gave.
11:50:22 <xerox> heh.
11:50:35 <kpreid> enkrav: if you want, it can be nothing more than newtype Tree = Tree (type you were using before, but with Tree in place of the recursive bit)
11:50:38 <xerox> better have dinner, have a good typehack session.
11:50:40 <dmwit> It's kind of like a monad containing a Bool.
11:52:06 <bvd> xerox: first of all (. (I Bool 3) . True.
11:53:12 <bvd> xerox: I pressed enter too fast...
11:56:35 <bvd> xerox: First of all (. ((I True 3) . True.
12:00:02 <dmwit> bvd: It comes from the fact that 0,3,10 could be many things.
12:00:10 <dmwit> Try e.g. "hi" .<. "there" .<. "world"
12:00:50 <bvd> Indeed the problem is with overloaded values
12:03:43 <fuzan> anyone have a neat introduction paper/blog/whatever to lambdacalc/why people like functional programming? I'm going to give a little presentation at my school for a LUG meeting on Haskell
12:04:07 <fuzan> some sources might be nice in building a nice introduction into for most, alien code.
12:04:46 <lemmih> @google whyfp
12:04:47 <lambdabot> http://www.cs.chalmers.se/~rjmh/Papers/whyfp.html
12:04:47 <lambdabot> Title: Why Functional Programming Matters
12:04:58 <fuzan> oo, that already sounds good.
12:06:37 <enkrav> Another good one, but maybe not so for a quick demo is  Backus' Turing Award lecture
12:06:52 <fuzan> i'll read it, at least.
12:07:24 <fuzan> the "can programming be liberated from von-neumman style" ?
12:07:54 <enkrav> yes
12:08:09 <enkrav> but it's not really the functional programming of haskell
12:09:11 <enkrav> there are no lambda expressions (to make it mathematically more tractable) (afaik)
12:10:18 <fuzan> i think a little discussion about von-neumman architectures would be meaningful.
12:11:32 <hpaste>  Bas van Dijk annotated "FreakyOrd" with "Using Maybe for the intermediate value" at http://hpaste.org/1233#a1
12:12:14 <dylan> @ask sorear Can one make a Vty image smaller after it is created?
12:12:15 <lambdabot> Consider it noted.
12:12:26 <sorear> dylan: No.
12:12:26 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
12:12:33 <dmwit> ?help ask
12:12:33 <lambdabot> ask <nick> <message>. When <nick> shows activity, ask them <message>.
12:12:34 <sorear> @clear-messages
12:12:35 <lambdabot> Messages cleared.
12:13:03 <monochrom> ?help tell
12:13:04 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
12:13:16 <monochrom> Interesting
12:13:17 <dmwit> ?ask dmwit_ What's different between this and tell?
12:13:18 <lambdabot> Consider it noted.
12:13:24 <dmwit_> Well?
12:13:25 <lambdabot> dmwit_: You have 1 new message. '/msg lambdabot @messages' to read it.
12:13:43 <dmwit_> Just the verb. =P
12:13:52 <monochrom> Yeah!
12:14:25 <dylan> sorear: Hmm. How would you go about making a one-line image from a string that is no longer than a specific width?
12:16:14 <sorear> take
12:16:23 <kolmodin> sjanssen: it should appear on planet.haskell.org momentarely. http://lennartkolmodin.blogspot.com/2007/04/xmonad.html
12:16:24 <lambdabot> Title: Bits and Bytes: xmonad
12:18:18 <enkrav> is there some quicker solution than to write recursive helper functions to the problem of setting (in a copy) position  x,y,z  of a list of type [[[a]]] to some value v ?
12:18:39 <dylan> sorear: ah, of course. :)
12:19:16 <bd_> enkrav: You could write a mutateListAt :: [a] -> Int -> (a -> a) -> [a], and compose it three times
12:19:36 <Gwern> kolmodin: not too bad an article, although it'd be even cooler if you showed some code to modify xmonad, imo
12:20:07 <kolmodin> Gwern: thanks
12:20:17 <Gwern> kolmodin: although, what is a haskell-overlay?
12:20:31 <kolmodin> it's additional ebuilds for gentoo linux
12:20:46 <Gwern> oh, so something for gentooers
12:21:21 <kolmodin> aye
12:22:09 <sorear> @seen sjanssen
12:22:09 <lambdabot> sjanssen is in #haskell-soc, #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard sjanssen speak 35m 5s ago.
12:22:18 <dmwit> kolmodin: "The impressive part is that while one of dwm's goals is to be Haskell."
12:22:22 <Gwern> incidentally, does GHC leave debug symbols in binaries by default or do you have to request that?
12:22:37 <dmwit> Maybe, "The impressive part is that while one of xmonad's goals is to be dwm in Haskell, "
12:22:38 <sorear> sjanssen: how did you get the combined horizonal/vertical split on that screenshot?
12:22:57 <sorear> sjanssen: I thought they were mutually exclusive
12:23:06 <kolmodin> dmwit: hah, that's not right :)
12:23:21 <Gwern> sorear: you can switch between h and vert by repeated promotes and I think it does horiz/vert splits automatically for 3 or more frames
12:24:00 <dmwit> sorear: Link?
12:24:33 <dirkjanh> does anyone know how i can compile a wxhaskell thingy so that someone without wxc-msw2.4.2-0.9.4.dll can open it, or is it just mandatory to have that dll
12:25:51 <kolmodin> dmwit: argh, blogspot didn't properly escape <
12:25:58 <dmwit> o
12:28:35 <kolmodin> dmwit: fixed, thanks for spotting it
12:28:47 <dmwit> Ah, nice.  Now I see where you were going. =)
12:29:32 <kolmodin> heh, yeah :)
12:29:48 <kolmodin> the original text did sound a bit strange
12:30:06 <dmwit> Heh, dwm's goal is to be Haskell.  That would be fun.
12:30:18 <kolmodin> hah hah, quite fun yes
12:40:04 <glguy> > let div13 = (*) (3303820997 :: Int) in div13 (13*39)
12:40:06 <lambdabot>  39
12:42:22 <dmwit> > let f a 0 = a; f a n = f (mod n 2 : a) (div n 2) in f [] 3303820997
12:42:23 <lambdabot>  [1,1,0,0,0,1,0,0,1,1,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,1,0,0,0,1,0,1]
12:42:37 <dmwit> > let f a 0 = a; f a n = f (mod n 2 : a) (div n 2) in f [] 2
12:42:38 <lambdabot>  [1,0]
12:43:52 <dmwit> Huh, that's a weird one.
12:43:53 <sjanssen> sorear: you mean the xmonad-tiles.png screenshot?
12:45:11 <Cheery> transparent, black, white :: (Coloured a) => a -> a
12:45:16 <Cheery> thank you! wise men
12:45:44 <sorear> sjanssen: yes
12:46:02 <sjanssen> sorear: to reproduce: switch to tile mode, create three windows
12:46:53 <sorear> I thought that would make only   Win1 | Win2 | Win3  or (same vertically)
12:47:10 <sorear> had no idea xmonad supported mixed layouts...
12:47:24 <sjanssen> it isn't mixed, that's just how that mode works
12:47:48 * sorear will have to try it
12:47:56 <sjanssen> the "master" window takes up the left half, then the right half is divided evenly among the remaining windows
12:48:12 <dmwit> sjanssen: Lately, it isn't even, right?
12:48:13 <jfoutz> I'd like to read in several thousand short text files, but hGetContents is a little too lazy, i run out of filehandles. right now i'm doing something like:  mapM processFile theFiles
12:48:28 <jfoutz> i guess, is there something like mapM that's a bit more strict?
12:48:35 <sjanssen> dmwit: I reverted those changes.  They really bugged me
12:48:45 <dmwit> Aha, I'll have to pull.
12:48:57 <dylan> I prefer my stacking area in dwm to be more narrow than the master area.
12:49:18 <sjanssen> dylan: that's dynamically configurable in xmonad
12:49:19 * dylan should start hacking on xmonad and add a grid mode
12:49:21 <dmwit> dylan: Change the 1%2 in XMonad.hs
12:49:41 <dmwit> (Or try mod+h and mod+l).
12:50:02 <sjanssen> dylan: please don't send me any feature patches for a week or so -- xmonad is under a feature freeze until 0.1
12:50:02 <dylan> can one do arbitrary key bindings to exec programs in xmonad?
12:50:18 <dmwit> dylan: Yes, you can use the "spawn" action.
12:50:23 <sjanssen> dylan: yeah, you can configure those at compile time
12:50:25 <dylan> also, does it have tags yet? :)
12:50:34 <sjanssen> xmonad will not have tags
12:50:38 <dmwit> You'll want to read through Config.hs to see what's possible (and easy).
12:50:44 <dylan> sjanssen: no? :(
12:50:50 <sjanssen> we are convinced our workspace interface is superior
12:51:19 <dylan> :(
12:51:28 <dmwit> dylan: Ponder this question: if two workspaces are set on two different layouts, and you toggle both views, what should happen?
12:51:36 <sjanssen> tags don't interact well with several other features that xmonad has: per workspace layout mode, xinerama support
12:52:00 <monochrom> what is tag?
12:52:16 <dylan> I sort of rely quite heavily on tags.
12:52:27 <dmwit> monochrom: It would mean that each window could be on multiple workspaces, and that multiple workspaces could be viewed at once.
12:52:42 <dmwit> dylan: How do you use them?  (I'm interested.)
12:53:14 <dylan> well, for one, I have win+(number key) set to view a new tag without hiding the current one
12:53:33 <dylan> so when I do win+1, I see my IRC client but the code I'm working on stays in front of me.
12:53:52 <opqdonut> i dislike the way dwm shuffles the windows around
12:53:59 <opqdonut> with ion i can have a static layout
12:54:10 <opqdonut> ws's and the scratchpad give enough flexibility
12:54:10 <jfoutz> ahhh, take the length of the file. cute.
12:54:35 <dylan> I found the staticness of ion to be annoying.
12:55:24 <dylan> personally, I'd like per-screen but not per-tag layouts.
12:56:14 <opqdonut> yeah well i don't need to see everything at once
12:56:37 <dylan> opqdonut: neither do I, I need to see random groupings of things at once. :)
12:56:51 <opqdonut> heh
12:56:59 <dylan> the major reason I can't use ion is the lack of tags and the fact it has five different kinds of "left"
12:57:03 <dmwit> dylan: Is it sufficient for you to have the following subset of tagging?
12:57:14 <dmwit> Each window appears on one workspace, but multiple workspaces may be visible.
12:57:29 <opqdonut> i have one ws with irc and to termframes (loads of terms), then a ws for opera and then lots of ws's that contain just emacs and one terminal (coding projects)
12:57:29 <dylan> That subset is useful, yes.
12:57:39 <dylan> I hardly ever put a window on more than one tag.
12:58:24 <dylan> I've actually been considering patch dwm to enforce 1 tag : 1 window relationship
12:58:29 <dylan> *patching.
12:58:33 <cpoucet> @hoogle Array i e -> Array i e' -> Array i (e,e')
12:58:34 <lambdabot> Did you mean: Array i e -> Array i E' -> Array i (e, E')
12:58:49 <dmwit> dylan: You might be able to convince people to work on this in a later release. =)
12:58:52 * cpoucet smacks lambdabot 
13:01:16 <dylan> dmwit: can xmonad create workspaces at runtime?
13:01:29 <dmwit> dylan: No, right now that's hardwired in.
13:01:36 <dylan> Ah.
13:01:49 * dylan 's dwm has dynamic tags.
13:01:51 <sjanssen> it wouldn't require much work at all to add them
13:02:15 <sebell> Is there a library or IO technique for Haskell that is similar in spirit to Expect?
13:02:34 <jfoutz> interact maybe?
13:02:41 <sjanssen> it makes more sense to me to just generate a workspace for each reasonable key combo
13:03:03 <opqdonut> hmm parsec might to suffice, sebell
13:03:07 <dmwit> sjanssen: What about a key combo like, "mod+t" or so, that invokes dmenu on the list of available workspaces?
13:03:34 <dmwit> (And similarly "mod+shift+t", which may have to create a new workspace.)
13:04:28 <sjanssen> dmwit: ask me in a week :)
13:04:33 <dmwit> Yeah. =)
13:06:26 <sjanssen> you could certainly implement something like this in your Config.hs
13:06:33 <cpoucet> anyone know if 'elems' from Array returns them in a guaranteed ordering from the smallest index to the largest
13:07:09 <sjanssen> cpoucet: I know that is what the code does
13:07:20 <sjanssen> cpoucet: there might be such a guarantee in the report
13:07:36 <cpoucet> basically I have two arrays with guaranteed same bounds
13:07:50 <cpoucet> I want to combine em into one array that combines the two array's elements
13:09:00 <sjanssen> that should be fine
13:09:16 <cpoucet> hooray for the lack of access functions for Arrays
13:09:42 <bringert> [OT] anyone know how to get the latex ucs package in OS X? I'm using latex from macports
13:10:46 <jfoutz> cpoucet: the docs say elems :: Ix i => Array i e -> [e]
13:10:47 <jfoutz> The list of elements of an array in index order.
13:10:57 <jfoutz> which sounds like what you want.
13:11:14 <cpoucet> jfoutz: oh right, thx
13:11:19 <cpoucet> tho in the end, mapping over the indices is easier
13:12:00 <sjanssen> using listArray/zipWith/elems will generally be more efficient
13:12:39 <cpoucet> than map (\i -> (x!i, y!i)) (indices x)
13:12:40 <cpoucet> ?
13:12:50 <cpoucet> hmm
13:12:51 <cpoucet> nm
13:12:52 <sjanssen> yes
13:13:04 <cpoucet> same principle
13:13:41 <sjanssen> the indices version does O(n) bound checks, but the elems version does O(1)
13:13:50 <cpoucet> a
13:13:53 <cpoucet> alright, thx
13:33:51 <largos> does anyone know if you can build Yi with Cabal on windows under cygwin w/ a native (non-cyg.) install of ghc?
13:34:48 <largos> the configure seems to go fine, but the build step complains with this exception: *** Exception: failed to extract ghc path from command line
13:45:33 <largos> hm.. this seems to be a problem when running from a cmd shell too -- configure finds ghc, but build can't
13:49:38 <shapr> Yay, tomorrow I fly to Sweden for two weeks!
13:49:52 <largos> awesome :) what for?
13:50:01 <shapr> To see my girlfriend
13:50:09 <shapr> She'll fly over here in the summer, yay!
13:51:07 <largos> cool :) are you two doing the distance thing for a long time, or is it short-term?
13:53:29 <largos> (does anyone know which gtk library Yi is dependant on?)
13:53:47 <xerox> ?where gtk2ss
13:53:47 <lambdabot> I know nothing about gtk2ss.
13:53:49 <xerox> ?where gtk2hs
13:53:49 <lambdabot> http://haskell.org/gtk2hs/
13:54:09 <largos> ok, that's what I was hoping
13:54:57 <largos> (thanks!)
13:55:39 <sorear> bd_: All three hunks conflict with identical changes in the current tree
13:56:23 <bd_> sorear: hm? I just darcs pull -a'd...
13:56:38 <bd_> Pulling from "http://members.cox.net/stefanor/vty"...
13:56:38 <bd_> No remote changes to pull in!
13:56:42 <bd_> do I have an old pull URL?
13:58:26 <sorear> No, it seems I just forgot to upload since mid-february :/
14:03:40 <sorear> bd_: upload sucessful.  Sorry about that...
14:04:25 <shapr> largos: We dated in person for some years, now we're doing the distance thing.
14:24:14 <mux> does someone know the hexadecimal unicode code for the -> character ?
14:24:43 <sorear> ISTR johnmeacham mentioning it
14:25:36 <mux> there's 2192, I'll see if that works
14:25:55 <largos> mux: there are a couple, iirc.
14:25:58 <mux> yeah
14:26:08 <mux> I'm looking for the one accepted in haskell sources when they are utf-8
14:26:10 <largos> mux: and doesn't it depend on the current encoding or something as well?
14:26:15 <largos> ah..
14:26:27 <mux> but it seems ghc doesn't like 2192; maybe I need to pass it some kind of flag for that?
14:26:35 <largos> http://jrgraphix.net/research/unicode_blocks.php
14:26:37 <lambdabot> Title: Unicode Character Table: Basic Latin
14:26:41 <largos> that's a good link to keep around
14:26:57 <sorear> mux: I'd look for a math symbol 'implication arrow' or somesuch
14:27:21 <sorear> mux: since that's the origin IIRC of the -> in haskell
14:27:47 <largos> hm... looks like that link is having font issues or something now :(
14:27:58 <monochrom> And that is already U+2192
14:28:10 <mux> ghc doesn't seem to like my lambda either
14:28:22 <mux> main = mapM_ putStrLn $ map (x  x+1) [1..10]
14:28:34 <mux> I find it rather pretty
14:28:40 <mux> but it's not working :-)
14:29:09 <dmwit> Shouldn't be too hard to write a de-prettifier, eh?
14:29:22 <monochrom> Perhaps it is not intended to work.
14:29:24 <mux> there's U+2794
14:29:37 <mux> I thought I read it was, maybe I got confused
14:29:49 <mux> oh well
14:29:49 <sjanssen>  is interpreted as a lowercase letter IIRC
14:30:01 <mux> yes
14:30:06 <mux> it thus says not in scope
14:30:38 <sjanssen> check the lexer source if you want to see which characters get special handling
14:30:53 <mux> I don't want it that bad ;-) I was just toying
14:31:09 <mux> I'll go do some real code instead
14:35:29 <largos> does anyone know how to install Yi in windows?
14:36:14 <largos> (or does anyone have pointers on how I could figure out how to do it manually? I've narrowed it down to "setup.exe install" but I don't know enough about 'setup' to discern what it's doing)
14:37:17 <sjanssen> largos: you've already built it?
14:37:27 <largos> sjanssen: yeah, it seems to have built Ok
14:37:45 <largos> sjanssen: although, I haven't found a Yi.exe (or similar) binary...
14:37:56 <sjanssen> the executable will be in dist/build/yi/yi.exe
14:38:04 <largos> it *did* have a crapload of warnings
14:38:27 <largos> cool, found that
14:38:51 <sorear> mux: the jhc lexer uses 0x2192
14:39:56 <bos> http://blog.durables.org/2007/04/01/new-scientist-table-of-contents/
14:39:58 <lambdabot> Title: Durables  Blog Archive  New Scientist table of contents, http://tinyurl.com/yrmdot
14:40:08 <largos> copied yi.exe over to the dest. dir, and ran make install again, but running it gives this error: \driver\package.conf.inplaceonf as c:\ghc\ghc-6.6
14:40:55 <sjanssen> I don't think install will do anything useful for you
14:41:00 <sjanssen> just run the yi.exe
14:41:08 <largos> well, same result either way
14:41:31 <largos> there was a note about running the binary in place being unsupported, so I assumed I needed something other than just yi.exe
14:41:39 <sjanssen> running yi.exe complains about GHC package.conf files?
14:41:42 <largos> but yeah, make install didn't do whatever needed to be done
14:41:47 <largos> *nods*
14:43:52 <joelr1> evening
14:44:01 <joelr1> any examples of how to keep a symbol table with parsec?
14:46:24 <jfoutz> joelr1: in the guide, there's a section called "Advanced: User state"
14:46:49 <joelr1> jfoutz: yes, i'm looking at it. but my needs are a bit more complex. i.e.
14:46:59 <joelr1> from ocamlyacc
14:47:02 <joelr1> OUTPUT COLON ID LP NUMERIC_SIMPLE RP
14:47:02 <joelr1>       { add $3 TypNumOut; SimpleOutputDec ($3, Number) }
14:47:03 <jfoutz> but that's probably awfully thin.
14:47:12 <joelr1> let me post to cafe
14:47:43 <heisenbug_> sjanssen: typo in http://darcs.haskell.org/~sjanssen/xmonad/XMonad.hs --> encapuslating
14:48:04 <jfoutz> hmm. if you have a yacc style grammer, perhaps you should give happy a spin?
14:48:13 <jfoutz> @hoogle happy
14:48:13 <lambdabot> Distribution.PreProcess.ppHappy :: BuildInfo -> LocalBuildInfo -> PreProcessor
14:48:14 <lambdabot> Distribution.Setup.configHappy :: ConfigFlags -> Maybe FilePath
14:48:14 <lambdabot> Distribution.Simple.Configure.withHappy :: LocalBuildInfo -> Maybe FilePath
14:48:21 <jfoutz> @where happy
14:48:21 <lambdabot> http://www.haskell.org/happy/
14:49:20 <sjanssen> heisenbug_: fixed
14:51:05 <joelr1> jfoutz: happy?
14:51:17 <joelr1> jfoutz: i thought it was easier with Parsec, no?
14:51:18 <monochrom> is a parser generator
14:51:32 <joelr1> i'm not sure i want to go through lexing/parsing again
14:51:40 <monochrom> parsec easier if you have learned parsec
14:51:46 <joelr1> monochrom: i know, i would just like to learn parsec :D
14:51:55 <joelr1> and rewrite my parser in a week
14:52:03 <joelr1> posted to cafe, btw
14:52:07 <joelr1> if anyone is subscribed
14:53:06 <DRMacIver> I tried happy and parsec and found parsec much easier ot understand. That doesn't neccessarily mean it's easier though. :)
14:53:21 <DRMacIver> (Revisiting happy is on my to do list)
14:54:01 <joelr1> DRMacIver: did you keep a symbol table?
14:55:16 <DRMacIver> no
14:55:22 <DRMacIver> I've only done very basic stuff with them so far.
14:55:28 <DRMacIver> s/them/it/
14:56:13 <sjanssen> joelr1: parsec has a state monad built in to it, presumably you'd use that
14:56:17 <DRMacIver> (Or Haskell in general frankly. I'm here more through good intentions than actual Haskell programming. :) )
14:56:47 <SyntaxNinja> the new community server has been ordered, should be online shortly :)
14:56:57 <joelr1> sjanssen: right. but how do i influence the "lexer" to return a different "token" if the identifier is in the symbol table?
14:57:19 <sjanssen> a ReaderT around parsec is another option
14:57:20 <sorear> community server?
14:57:35 <sjanssen> joelr1: umm, shouldn't lexing and symbol analysis be separate stages?
14:57:55 <joelr1> sjanssen: not necessarily ;)
14:58:20 <joelr1> sjanssen: meaning that as soon as see an id in the parser, i add it to the symbol table. if the lexer has seen this id then it returns a different token
14:58:34 <jfoutz> joelr1: sorry afk for a moment.
14:59:32 <jfoutz> my point was, if you already have a ocaml yacc style grammar, it would be far easer to port that grammar to happy than to start from scratch with parsec
15:00:07 <Igloo> SyntaxNinja: What did you go for in the end?
15:00:19 <Igloo> SyntaxNinja: And yay, BTW  :-)
15:00:21 <jfoutz> second, if you have a working parsec parser, it seems like you could use the state monad that's there to hang onto your symbol table
15:00:23 <SyntaxNinja> sorear: a login server for "random" community members who want a unix account, primarily for darcs access
15:00:29 <SyntaxNinja> Igloo: tektonic UM2
15:00:49 <SyntaxNinja> Igloo: turned out that you DO get more CPU with higher plans, and they do backups for us, so I went with them.  Id idn't feel like researching it any more, since it's so friggin' cheap.
15:00:58 <SyntaxNinja> it hardly puts a dent in the SoC money, honestly.
15:01:15 <Igloo> Heh, fine with me, was just curious  :-)
15:01:42 <SyntaxNinja> did that sound overly emphatic? ;)
15:04:22 <monochrom> Context-sensitive parsing is a strong point of Turing-complete parser combinators. :)
15:04:40 <whaleofconfusion> you know what might be cool?  tooltips that do something substantial like draw a graph
15:04:58 <dmwit> Either that or really annoying.
15:05:02 <whaleofconfusion> I'm thinking, you could select some code using a graph tooltip, and it would draw the syntax tree in a little box to the side
15:05:37 <sorear> monochrom: OTOH parsec never tells me "shift/reduce conflict found".  I find it very helpful the fact that yacc tells me when my grammar is ambiguous.
15:06:22 <whaleofconfusion> or if you're using LaTeX you could select some code using a "draw-it" tooltip and it would render it
15:06:36 * sorear wonders if it would even be possible to statically analyse a context sensitive parser for ambiguity
15:06:38 <DRMacIver> Hm. That just gave me the most horrible idea for an esolang. :)
15:06:55 <whaleofconfusion> without having to go through the whole process of sending it to a tex renderer
15:06:57 * sorear is interested!
15:07:00 <monochrom> I recall lots of undecidability theorems for ambiguity. :)
15:07:16 <DRMacIver> Heavily ambiguous grammar. Every time there are multiple ways the code could be read, the process forks and executes both of them. :)
15:07:18 <whaleofconfusion> i mean at least on the user side they don't have to worry about it
15:07:19 <monochrom> Correction: I recall hearing about them!  I do not know the actual theorems.
15:07:49 <DRMacIver> (Well, forks, spawns a new thread, whatever)
15:07:54 <monochrom> What to do after the processes finish?  How do you join their results?
15:08:25 <sorear> dpiponic quantum nondetermism?
15:08:36 <DRMacIver> monochrom: Beats me. They probably carry on their merry ways independently, conflicting horribly by mutating state and executing side effects. :)
15:08:52 <DRMacIver> monochrom: It's an esolang. It probably does whichever would be funniest at the time.
15:08:58 <whaleofconfusion> whoa
15:09:02 <whaleofconfusion> netsplit
15:09:06 <monochrom> Damn you for forking our IRC network!
15:09:37 <DRMacIver> I'm vaguely concerned that 50 more people rejoined after the netsplit than were lost from it.
15:09:42 <monochrom> And joining just like that!
15:10:00 <monochrom> It's all your fault suggesting forking!
15:10:15 <whaleofconfusion> huh
15:10:38 <DRMacIver> monochrom: It forking isn't.
15:10:48 <monochrom> Haha
15:13:53 <SyntaxNinja> http://72.249.127.241/
15:13:55 <lambdabot> Title: Test Page for Apache Installation
15:17:35 <sorear> @botsnack
15:17:35 <lambdabot> :)
15:23:10 <ptolomy> Hm.. I'm having trouble figuring out how to make Parsec parse greedily..  I want to collect anything between two matching brackets verbatim, brackets included (so long as they are matched and in the right direction).. any hints?
15:28:10 <monochrom> Have you written the formal grammar corresponding to it?
15:30:01 <ptolomy> well.. it's tcl.. so, not really.
15:30:41 <monochrom> Writing up the formal grammar is the first step.
15:30:55 <monochrom> In general, writing up the formal specification is the first step.
15:31:01 <ptolomy> Tcl doesn't exactly have a formal grammar, so far as I know.
15:32:00 <monochrom> Note that the formal grammar needed here does not have to contain all details of TCL.  Just enough to express "parentheses match, other characters sprinkled everything".
15:32:36 <monochrom> s/everything/everywhere/
15:32:48 <monochrom> It's a second-year CS exercise.
15:32:54 <ptolomy> In that sense, I do, I guess.
15:33:29 <ddarius> You need a year+ of college level CS to match parentheses?
15:34:14 <monochrom> You need a year+ of kindergarten to even recognize abc.
15:34:55 <ptolomy> Parsing it is pretty trivial.. except that I'm not sure how to best do it in parsec.
15:35:18 <dmwit> ptolomy: What have you tried?
15:35:19 <sorear> balanced_sliver = satisfy (`notElem` "[]") <|> (char '[' >> many balanced_sliver >> char ']')
15:35:27 <sorear> that's what I'd do
15:35:53 <sorear> a balanced sliver is (anything but a bracket) or (a bracketed seq of balanced slivers)
15:35:57 <dmwit> sorear: Might need a (>> balanced_sliver) at the end, or something like [[]][] won't match.
15:36:16 <sorear> dmwit: that's not a balanced sliver, that's two of them
15:36:29 <dmwit> Well, many of them. =)
15:36:30 <sorear> dmwit: that will match many1 balanced_sliver however
15:37:18 <ptolomy> dmwit: I've been just doing 'square (noneOf "[]")'.. and I was looking to see if parsec has a built-in similar greedy combinator to do similar.
15:37:46 <monochrom> "many" is greedy.
15:37:54 <kpreid> blob = many (satisfy (`notElem` "[]") <|> group); group = char '[' >> blob >> char ']'
15:39:27 <ptolomy> ah.
15:46:46 <desp> @hoogle readInt
15:46:47 <lambdabot> Numeric.readInt :: Integral a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
15:46:47 <lambdabot> Numeric.readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
15:46:47 <lambdabot> Text.Read.Lex.readIntP :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadP a
15:46:54 <desp> hm
15:50:08 <desp> @hoogle getInt
15:50:09 <lambdabot> No matches found
15:50:39 <sorear> desp: what are you looking for?
15:50:49 <desp> a replacement for scanf("%d", &foo);
15:50:58 <sorear> readLn
15:51:10 <sorear> not exactly the same, but close enough
15:51:12 <desp> a whole line, eh?
15:51:18 <sorear> a whole line
15:51:26 <sorear> and read, not just gotten
15:51:29 <sorear> @type getLine
15:51:32 <lambdabot> IO String
15:51:36 <sorear> @type readLn
15:51:38 <lambdabot> forall a. (Read a) => IO a
15:52:03 <sorear> did you want multiple fields per line?
15:52:21 <desp> not at this juncture
15:52:34 <desp> but if I did, should I roll my own int-reading-function?
15:52:37 <sorear> What verso
15:52:50 <sorear> didn't mean to say that :(
15:53:00 <sorear> > read "123" -- not needed
15:53:02 <lambdabot>  123
15:53:52 <desp> hmm
15:54:05 <desp> > read "123 456"
15:54:07 <lambdabot>  Exception: Prelude.read: no parse
15:54:28 <sorear> > reads "123 456"
15:54:30 <lambdabot>  [(123," 456")]
15:55:06 <desp> so how would you read two subsequent numbers on a single line?
15:55:40 <sorear> > [ (fst, snd) | (fst, (' ':rest1)) <- reads "123 456" , (snd, "") <- reads rest1 ]
15:55:41 <twanvl> > map read . words $ "123 456"
15:55:42 <lambdabot>  [(123,456)]
15:55:43 <lambdabot>  [123,456]
15:58:31 <sorear> Is there any way to get more detailed version info from ghc -cpp?
15:58:57 <sorear> __GLASGOW_HASKELL__ is 607, and I want to test >=20080830
15:59:05 <sorear> 20060830 even
16:06:01 <dons> moin
16:06:35 <sorear> hi.
16:06:39 <dcoutts> I saw the funniest defacing on the train this morning...
16:07:00 <dons> oh yes?
16:07:47 <dcoutts> the sign that normally read "at night travel near the gaurd's compartment marked with a blue light" had a couple letters scratched out...
16:08:18 <dcoutts> to become "at night rave near the guard's compartment naked with a blue light"
16:08:20 <dons> oh, yes. there's a good one about "rave naked with a blue light" ?
16:08:22 <dons> yeah.
16:08:26 <dcoutts> lovely :-)
16:08:48 <dcoutts> I'm sure the guards appreciate it
16:08:50 <dons> inspiring really
16:09:07 <chessguy> http://dumpalink.com/pictures/Rave-Naked-With-A-Blue-Light-2b87.html
16:09:10 <waern> dcoutts, I've created added a binding of Scintilla to gtk2hs: http://www.dtek.chalmers.se/~davve/haste2.png
16:09:10 <lambdabot> Title: Rave Naked With A Blue Light - Dumpalink.com, http://tinyurl.com/2x3unq
16:09:23 <dcoutts> waern: I think you're mad, but ok :-)
16:09:33 <sorear> make compiled in the binary bench-dir seems rather broken.
16:09:33 <sorear> [(Int, ByteString)]                               { waits for >20 seconds }OK, 1000 tests.  0.008 seconds
16:09:43 <waern> dcoutts, why do you think so? :)
16:10:27 <sorear> Also it won't compile without mods on 6.7 - duplicate instanced for Arbitrary (Maybe a), Arbitrary (Either a b)
16:10:49 <dcoutts> waern: kolmodin tells me that Scintilla has an API concieved by a sadist.
16:11:07 <dcoutts> waern: is he wrong? :-)
16:11:38 <waern> dcoutts, it's not _that_ bad, but I guess it could be prettier. However, it works.
16:11:49 <waern> dcoutts, that's what I'm mostly interested in
16:12:18 <dcoutts> waern: nice screenshot though. The other approach of course is to do the syn hl ourselves using the ghc lexer and the gtk text widget. hIDE did that and I think yi either does that now or nearly does
16:12:34 <waern> dcoutts, I was thinking of trying that with Scintilla
16:12:42 <dcoutts> waern: of course scintilla has more than just syn hl
16:13:20 <dcoutts> waern: don't let me put you off! the more people investingating this area the better in my opinion. keep an eye on yi though, it looks interesting.
16:14:00 <sorear> The yi syntax highlighting uses a very clever algorithm rendered useless by incomplete implementation and a now disinterested author.
16:14:46 <waern> dcoutts, did Lemmih extract the lexer out of ghc to do that stuff in hIDE, btw?
16:15:37 <sorear> yi uses a alex lexer which may or may not have come from ghc; it doesn't matter because we've already lost shared maintnence.
16:16:08 <waern> hmm, then I guess we need to add lexing to the GHC API
16:17:25 <sorear> Unfortunately, I needed pretty heavy tweaking to make the lexer compatible with (my plans for) the clever algorithm.
16:17:29 <dcoutts> waern: yes, he started with the ghc alex lexer and modified it a bit, I'm not sure exactly why it needed to be changed to be usable in a syn hl editor. You can ask him and then you can fix the ghc api so we can do that and still share maintanance work ;-)
16:17:31 <lemmih> waern: Yes he did.
16:17:33 <sorear> I had to re-write the alex triver.
16:17:51 <waern> lemmih :)
16:18:11 <dcoutts> lemmih: what was lacking in the lexer as it was?
16:18:36 <sorear> As used by yi, the lexer was lacking any sort of hook for incremental use.
16:18:44 <dcoutts> I mean obviously it was designed for batch operation in the compile, so it's not suprising, but just wondering what the changes were roughly
16:18:47 <lemmih> dcoutts: I didn't start with the alex lexer. That thing is horrible. It was much easier to just steal the code from Visual Haskell.
16:18:57 <dcoutts> oh right
16:19:09 <dcoutts> but I think they started from the alex lexer iirc
16:19:09 <waern> lemmih: did you re-lex the entire source file at every change?
16:19:22 <dcoutts> waern: no, much more cunning than that :-)
16:19:33 <lemmih> waern: No, only the lines that actually needed re-lexing.
16:19:40 <sorear> dcoutts: I modified it into a batch lexer, then re-wrote the alex driver to support operations on the internalnumeric state values.
16:19:57 <dcoutts> waern: so you only lex to the end of the line and save the lexer state (which is just an Int)
16:20:09 <ddarius> Generic brand eye drops are 96x more expensive than hydrogen peroxide by volume.
16:20:27 <sorear> MY system didn't concern itself with lines; it would have worked in 500-1000 byte blocks
16:20:42 <sorear> so billion-char lines would not have killed performance
16:20:45 <dcoutts> sorear: which presumably only needs modifying the lexer monad right?
16:20:56 <waern> dcoutts, ok
16:21:20 * lemmih is currently stuck with regex based syn-hl'ing in Emacs which totally sucks.
16:21:25 <sorear> dcoutts: no monad here.  but I did only modify the inner alex interpreter; the rules are for an ordinary batch lexer
16:21:42 <sorear> plenty of #'s though ;)
16:22:29 <sorear> Anyway, all this cleverness didn't accomplish anything because I never actually got around to replacing the buffer with a fingertree.
16:22:42 <sorear> Finger trees + memoized synhl would have been mega cool
16:24:44 <waern> Lemmih: do you have the source for that lexer somewhere?
16:25:32 <waern> dcoutts: btw, how should I handle the fact that scintilla needs libstdc++?
16:26:10 <waern> dcoutts: right now I'm linking it statically to the libscintilla.a file so that the user won't have to add -lstdc++ to the ghc command line
16:26:12 <dcoutts> waern: apart from cursing? erm, dunno. How do other bindings to C++ libs handle that? Take a look at wxHaskell.
16:28:23 <waern> dcoutts: good idea
16:31:35 <lemmih> waern: http://darcs.haskell.org/~lemmih/Scanner.x
16:32:52 <lemmih> waern: You can also get the hIDE repo and unpull ~10 patches.
16:34:55 <waern> lemmih: thanks
16:37:43 <waern> lemmih: that's pretty far from the current ghc lexer though
16:37:51 <lemmih> waern: Indeed.
16:38:35 <waern> lemmih: did you take it from an early ghc?
16:39:16 <lemmih> waern: SimonM mailed it to me. It was before the first release of Visual Haskell, I believe.
16:39:28 <waern> lemmih: hmm, ok
16:39:58 * shapr hugs lemmih 
16:40:41 <shapr> lemmih: Why no capital Lemmih today?
16:40:49 <chessguy> hIDE works if you unpull 10 patches or so?
16:40:51 * shapr is taking a short break from packing furiously
16:42:19 <lemmih> chessguy: Depends on how you define 'works'. It builds and looks pretty. Doesn't do much, though.
16:43:02 <chessguy> any idea what the last patch i should look for is?
16:43:38 <lemmih> shapr: I lost it. I've ordered a new one but it's having difficulties getting through customs last I heard.
16:44:11 <shapr> Yeesh, I hope I don't have any difficulties in customs!
16:45:05 <dcoutts> shapr: where are you travelling to?
16:45:16 <shapr> That same place where we almost met.
16:45:20 <lemmih> chessguy: Look for something about a first step to a new beginning.
16:45:29 <dcoutts> shapr: ah, Stockholm :-)
16:45:31 <chessguy> that's the last patch i should undo?
16:45:36 <shapr> dcoutts: You got it.
16:45:43 <lemmih> chessguy: Yeps.
16:45:48 <chessguy> cool beans
16:46:33 <dcoutts> SyntaxNinja: cheers, got in fine. I know nothing about sid. Il defer to the opinion of the debian devs on that one.
16:48:09 <chessguy> ?where hide
16:48:10 <lambdabot> http://haskell.org/haskellwiki/HIDE
16:50:49 <chessguy> lemmih: hmm. that gives me an error about the hIDE registry. i'll play with it
16:52:30 <chessguy> i think i'll just unpull one at a time until it works :)
16:52:40 <lemmih> chessguy: I might be completely broken. Don't get your hopes up.
16:53:20 * chessguy resolves to fix lemmih
16:54:22 <chessguy> @type fix ?lemmih
16:54:24 <lambdabot> forall a. (?lemmih::a -> a) => a
16:55:16 <sorear> > 4.5 / 0.3
16:55:18 <lambdabot>  15.0
16:55:57 <chessguy> what's moduleFS?
16:56:35 <lemmih> It's a function from the ghc-api.
16:57:10 <chessguy> hmm. i'm getting  Not in scope: `moduleFS'
16:57:27 <lemmih> chessguy: Do you have ghc6.6?
16:57:38 <chessguy> yes
16:59:07 * lemmih delegates the task of legacy tech support to /dev/null.
16:59:15 <dcoutts> quite
17:00:16 <chessguy> hmm. it must have worked at some point
17:00:32 <dcoutts> it did, with pre-release versions of ghc-6.5
17:00:39 <dcoutts> and old versions of other stuff
17:00:51 <chessguy> then it can be that broken
17:01:56 <chessguy> what i don't get is how i can be getting an error from src/Hide/Plugin/LoaderMidLevel.hs:126:26 when there is no such file
17:02:00 <lemmih> chessguy: Keep unpulling patches from ghc, hs-plugins and hide, and you'll eventually get something that works (:
17:04:39 <waern> good night everyone
17:05:16 <lemmih> Sleep well, waern.
17:06:10 <araujo> hello!
17:06:36 <chessguy> ?hoogle moduleFS
17:06:37 <lambdabot> No matches found
17:15:48 <dons> sorear: what does the core look like?
17:18:59 <sorear> dons: v. bad
17:19:05 <sorear> dons: completely boxed
17:19:21 <sorear> dons: not overloaded, thankfully
17:19:25 <dons> -O2 ?
17:19:39 <dons> there's been some changes to the SpecConstr optimisation. in general I'd hope for better code.
17:19:46 <sorear> -O3 actually, I hope it's monotonic :)
17:19:52 <dons> but you should attach the core produced with both compilers to the message
17:19:57 <dons> -O3 does nothing other than -O2
17:20:01 <dons> also check the result with -O2
17:20:03 <sorear> ok.
17:20:05 <dons> I mean, -O
17:20:53 <sorear> ghc -O2 is just as fast as ghc-6.6 -O2
17:21:03 <sorear> ghc -O3 is 15x slower than ghc-6.6 -O3
17:21:07 <sorear> !?
17:21:22 <dons> ok there you go.
17:21:33 <dons> so you enabled some bad optimisation :-)
17:21:39 <dons> now run with -ddump-simpl-stats with both
17:21:46 <dons> to see if any new optimiations kick in with -O3
17:21:59 <sorear> Wow, I'd never heard of that before.
17:22:00 <dons> if you're up to it, run with -ddump-simpl-iterations to see where it goes wrong
17:22:10 <sorear> Sure beats diffing core by hand :)
17:22:17 <dons> i didn't know anything was enabled by -O3
17:22:20 <dons> so I'm a little surprised too
17:22:34 <dons> or ... its possible something was *disabled* by -O3
17:23:30 <sorear> -O3 has less numbers in every category than -O2
17:23:55 <dons> ok. I wonder then if some optimisations are specifically disabled by -O3
17:24:09 <dons> I suspect this is the case. do you want to have a look in compiler/main/Driver*
17:24:13 <dons> to see anything about -O3 ?
17:26:06 <sorear> grep can't find -O or ptimiz is any of those three files.
17:27:27 <dons> DriverPipeline.hs:      let cc_opt | optLevel dflags >= 2 = "-O2"
17:27:38 <dons> now look for optLevel
17:28:58 <sorear> Nice.
17:29:07 <sorear> Optimizations are NOT monotonic
17:29:23 <sorear>     , ([1,2],   Opt_DoEtaReduction)
17:29:27 <sorear> so "1 or 2"
17:29:32 <sorear> not 3, not 0
17:30:26 <dons> I think you could make a case to remove -O3
17:30:32 <dons> since obviously its too tempting to some people
17:31:03 <jcreigh> so -O3 is there just to spite gentoo users? :)
17:31:06 <dons> sorear: if you want super karma points, you could make a list of what optimisations are enabled at each phase
17:31:20 <dons> jcreigh: just to trick them. you'll get *worse* code if you use -O3
17:31:42 <jcreigh> that's what I mean.
17:32:08 <jcreigh> but it seems strange: I had assumed that each optimization level was a superset of the previous level.
17:32:58 <dons> you'd think that. but haha no!
17:33:20 <jcreigh> is there a reason for this? Or is it just a bug?
17:33:55 <dons> bug
17:37:39 <sorear> @index IO
17:37:39 <lambdabot> System.IO, Prelude
17:37:52 <sorear> No, I meant *data constructor* IO.
17:37:57 <dons> @src IO
17:37:58 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
17:37:59 <sorear> it's not in GHC.Exts
17:38:04 <dons> GHC.IObase
17:38:06 <dons> Base
17:38:32 <sorear> Confusing.  Esp. that I# S# J# D# etc are in GHC.Exts.
17:38:49 <dons> they are? aren't they just exported?
17:39:00 <sorear> probably just exported, yeah
17:39:42 * sorear is trying to benchmark the performance difference between MutableByteArray# and Addr#
17:40:42 <dons> should be some differences.though small, I suspect
17:41:33 <sorear> about 3x, but I'm going to try refactoring the loop before drawing conclusions
17:44:20 <sorear> One little loop refactor and the MBA# prog is as fast as the Ptr one.
17:44:36 * sorear tries to see if the Ptr one can be sped as easily...
17:45:33 <sorear> @src Ptr
17:45:34 <lambdabot> data Ptr a = Ptr Addr#
17:51:54 <jcreigh> note to self: mod-shift-q != mod-ctrl-shift-q
17:53:03 <dons> right.
17:53:10 <jcreigh> :)
17:53:10 <dons> we prefer /=
17:53:48 <sorear> Aww, applying the same refactor to the Ptr version and full manual unboxing netted 0% performance gain.
17:54:03 <chessguy> procyon112: ping
17:56:10 <goban> j#
17:56:27 <sorear> J#?
17:56:34 <goban> typo sorry
17:56:50 <araujo> hello!
17:57:17 <sorear> Ah good, 'twas about to ask why you were suggesting I use integers in this perf exercise :)
18:00:02 <jcreigh> # in GHC-speak means "here be dragons", right?
18:00:10 <jcreigh> (unboxed?)
18:00:12 <sorear> I suppose it says alot that I can't make my loop using Addr# any faster than my garbage collected MutableByteArray# code.
18:00:20 <sorear> jcreigh: unlifted actually
18:00:29 <sorear> jcreigh: very minor technical difference :)
18:00:39 <jcreigh> oh, as in, "not a thunk"?
18:00:42 <sorear> yes
18:00:46 <sorear> that's unlifted
18:00:57 <sorear> unboxed is a raw value, ie not a pointer
18:01:03 <sorear> Int# is unboxed and unlifted
18:01:09 <jcreigh> oh.
18:01:13 <sorear> ByteArray# is unlifted, but it is boxed
18:01:24 <jcreigh> so each "byte" is a machine word?
18:01:40 <sorear> no, ByteArray# bytes are real machine bytes
18:02:01 <sorear> you have amazing type-unsafe operators like    writeDoubleOffAddr# :: Addr# -> Int# -> Double# -> State# s -> State# s
18:02:07 <ddarius> sorear: I suspect Addr# is a pointer.
18:02:25 <sorear> ddarius: yes, I copied the wrong sig
18:02:38 <sorear> writeDoubleArray# :: MutByteArr# s -> Int# -> Double# -> State# s -> State# s
18:03:09 <sorear> and note that for some reason known only to the almighty fptools, the haddocks use the wrong name for MutableByteArray#
18:03:42 <sorear> Some of this stuff just seems silly.
18:03:43 <jcreigh> so something can only be called "unboxed" if you don't have to dereference a pointer to get at the value?
18:03:49 <sorear> right
18:04:11 <sorear> Why are Addr#, Word#, Int#, and Char# all different types?
18:04:19 <jcreigh> so Int# is unboxed, because you can just access the value, but ByteArray# is unboxed, because you have to follow the pointer to get at the bytes?
18:04:28 <sorear> (the current design of the stg-machine forces them to be the same size)
18:04:34 <jcreigh> err.. "byteArray# is boxed"
18:04:35 <sorear> jcreigh: exactly
18:04:49 <sorear> jcreigh: I failed to see the typo :)
18:04:53 <jcreigh> heh.
18:05:05 <Pseudonym> sorear: You don't like strong typing?
18:05:06 <lambdabot> Pseudonym: You have 1 new message. '/msg lambdabot @messages' to read it.
18:05:09 <jcreigh> We have invented the "Do what I mean" interface, and its name is sorear. :)
18:05:46 <sorear> Pseudonym: It doesn't belong at this level.  I'm perfectly happy with Word and Word8 being different types.
18:06:05 <Pseudonym> Why doesn't it belong?
18:06:23 <sorear> Because it quadruples the number of operators we need
18:06:35 <Pseudonym> Which operators would those be?
18:06:46 <Pseudonym> You don't add too Char#s or Word#s.
18:06:49 <Pseudonym> two
18:07:05 <sorear> +# for Int#, plusWord# for Word#, plusAddr# for Addr#
18:07:24 <Pseudonym> :t plusAddr#
18:07:26 <lambdabot> Not in scope: `plusAddr#'
18:07:34 <Pseudonym> @src plusAddr#
18:07:34 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
18:07:41 <sorear> :t GHC.Prim.plusAddr#
18:07:43 <lambdabot> GHC.Prim.Addr# -> GHC.Prim.Int# -> GHC.Prim.Addr#
18:07:43 <sjanssen> obviously the solution is numeric overloading for unboxed types
18:07:48 <ddarius> sorear: What if the implementation changes so that those aren't the same size?
18:07:54 <Pseudonym> Note that's a different type than plusWord#.
18:08:10 <Pseudonym> You cannot add two Addr#s together.  It makes no sense.
18:08:29 <sorear> ddarius: then we will be too busy rejoicing to notice
18:09:30 * sorear is really not happy Word8 consumes 4 bytes unboxed
18:09:31 <sorear> I wonder if allowing unboxed newtypes would make any of this easier.
18:09:58 * sorear also doesn't get the need for (#)
18:13:47 <sjanssen> sorear: it's nice to be able to tell at a glance whether something uses compiler primitives
18:14:40 <sorear> sjanssen: No, I'm not talking about the #-suffix
18:14:46 <dons> sorear: they have different kind after all, so making that clear is useful.
18:14:59 <dons> sorear: # looks like a box.
18:15:30 <jcreigh> or, if you half close your eyes, a pound symbol. :)
18:15:32 <sjanssen> sorear: yes, I know
18:15:54 <sorear> I just don't understand why there are so many restrictions on (#) (read - kind of unboxed tuple types) ... we can apply a few simple transformations to eliminate it from all the positions ghc doesn't support.
18:16:10 * ivanm always reads "#" as "raise the note by a semitone" ;-)
18:16:18 <dons> sorear: please write a paper on first class unboxed values in a lazy language.
18:16:35 <sjanssen> sorear: erm, sorry, I misread your message.  I thought you were talking about the suffix
18:17:06 <dons> there are so many restrictions because they're strict and unboxed. so no closures, no suspended computation, no heap allocation, special handling on the stack, non-unifiorm representation, special compilation rules (e.g. registers to hold them).. what else?
18:17:35 <dons> not represenatable as CAFs
18:17:40 <Pseudonym> ($) doesn't work
18:17:53 <dons> $ doesn't work., since they have different kind.
18:18:03 <dons> type classes won't work, since they have different kind
18:18:09 <sorear> I see (# Int#, Int# #) -> (# Int#, Int# #) as equivalent to Int# -> Int# -> (# Int#, Int# #)
18:18:12 <Pseudonym> It's the "no suspended computation" which is the key thing.
18:18:26 <Pseudonym> sorear: You'd be wrong.
18:18:28 <sorear> I agree we should keep # and * separate.
18:18:31 <Pseudonym> It's not isomorphic.
18:18:37 <sorear> Pseudonym: do tell?
18:18:46 <Pseudonym> foo :: Int# -> Int# -> (# Int#, Int# #)
18:18:48 <Pseudonym> foo x = undefined
18:19:17 <sorear> Hmm.  Interesting.
18:19:46 <dons> they just don't have nice properties.
18:19:55 <dons> and to think .. people write entire languages that only have this kind!
18:19:57 <ivanm> dons: with the Map stuff you were showing me yesterday, how do I initialise it to a Map with say [('a',0),('b',0),...('z',0)] instead of Map.empty, to ensure that every letter has a frequency, even if its 0?
18:20:05 <sorear> Not quite as simple as I first imagined, (no rewriting), but my operational intuition for (#) on the left still stands...
18:20:17 <sorear> Now if only there were some kind of uber-testsuite for ghc
18:20:22 <dons> > M.fromList (zip ['a'..'z'] (repeat 0))
18:20:23 <lambdabot>  fromList [('a',0),('b',0),('c',0),('d',0),('e',0),('f',0),('g',0),('h',0),('...
18:20:35 <dcoutts> sorear: I want a kind of unlifted types
18:20:38 <ivanm> and use that instead of M.empty?
18:20:43 <dons> ivanm: yeah.
18:20:45 <sorear> so I could implement my ideas for flattening (#) into # and test if the type system was still sound
18:20:49 <ivanm> dons: thanks
18:20:52 <dons> ivanm: or there's an insertWithDefault
18:20:59 <dons> which can set to 0 any value that hasn't yet appeared, iirc.
18:21:13 <dcoutts> sorear: ie total values, so no general recursion, start with just simply typed lambda calculus
18:21:26 <dons> sorear: type systems people tend not to like unit test-based type system soundness ;[-)
18:21:54 <dons> since the type system is a formal system, proofs are more well regarded. otherwise you have perl.
18:22:02 <sorear> dons, your glasses are slipping ;-)
18:22:13 * dons pushes them back up 
18:22:26 <Pseudonym> The thing about Haskell that's interesting, though, is that we do have this ugly core which is mostly hidden.
18:22:26 <dcoutts> sorear: so it'd be a language subset that was total, though to be useful you'd also need subtyping to let values of a total type be used as values of non-total types
18:22:44 <dcoutts> so a kind of types that really really has no _|_
18:22:53 <Pseudonym> C++ is C with extra structural mostly-goodness, but it still wastes an awful lot of nice operators on the C core.
18:23:27 <Pseudonym> If I were designing it today, raw pointers would be hard to use.
18:24:06 <Pseudonym> std::raw_memory<Foo>::pointer pFoo; // instead of Foo* pFoo;
18:24:09 <Pseudonym> Or somethign.
18:25:16 <mauke> you want to completely redesign the syntax. and arrays.
18:25:48 <Pseudonym> Yes.  I want operator[] to have no intrinsic meaning.
18:26:08 <mauke> oh, and sane name lookup rules
18:26:18 <cjay> C++ wouldn't be C++ without the C compatibility
18:26:28 <sorear> ++ !
18:26:28 <Pseudonym> cjay: No, it would be D.
18:26:29 <ozone> Pseudonym: you ever read damien conway's proposal for a redesigned C++ syntax?  (keeping all its current semantics)
18:26:35 <cjay> heh
18:26:35 <mauke> C++ isn't C compatible anyway
18:26:38 <Pseudonym> Yes, I saw that.
18:26:51 <Pseudonym> I must admit, it's not bad, especially as an undergrad teaching tool.
18:26:56 <jcreigh> C++ is C compatible except for calling convention and syntax. :)
18:26:58 <ozone> of, of course you would have :)
18:26:59 <sorear> mauke: but it's close enough to have the same drawbacks
18:27:16 <mauke> sorear: yes :(
18:27:26 <mauke> jcreigh: ... and semantics
18:27:36 * Pseudonym used to work at Monash and used to be a Perl bunny; I know Damien
18:27:36 <mauke> calling conventions aren't part of the language anyway
18:27:58 <Pseudonym> I even heckled him once.
18:28:24 <jcreigh> mauke: But in Real Life, people often, for example, make bindings to a C library but not a C++ because of calling convention issues. You can't just handwave it away.
18:28:28 <Pseudonym> Only because I know he's brilliant with hecklers.
18:28:40 <mauke> bah, real life
18:29:25 * QtPlatypus looks interested "Where is the proposal?"
18:30:10 <ozone> QtPlatypus: http://www.csse.monash.edu.au/~damian/papers/
18:30:11 <lambdabot> Title: Damian Conway's Online Papers
18:30:13 <ozone> (search for "SPECS")
18:34:23 <phoniq> it's the name mangling that forces you to bind to C
18:35:16 <ozone> phoniq: + the calling convention
18:35:25 <ivanm> @pl map (\ x -> x * (x - 1))
18:35:26 <lambdabot> map (ap (*) (subtract 1))
18:35:35 <ivanm> @pl map (\ x -> x * (pred x))
18:35:36 <lambdabot> map (ap (*) pred)
18:35:58 <phoniq> didnt realize that
18:36:20 <jcreigh> phoniq: my understanding was that overloading requires name mangling.
18:36:55 <phoniq> yah jcreigh, everything gets mangled all the time unless specifically told not to with extern C {
18:37:05 <ivanm> @hoogle ap
18:37:06 <lambdabot> Monad.ap :: Monad a => a (b -> c) -> a b -> a c
18:37:06 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
18:37:06 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
18:37:25 <ivanm> what's the difference between Monad.ap and Control.Monad.ap?
18:37:38 <ivanm> the signatures look the same to me...
18:37:54 <ivanm> s/signatures/types
18:38:09 <ivanm> @src Monad.ap
18:38:09 <lambdabot> Source not found. The more you drive -- the dumber you get.
18:38:13 <ivanm> @src ap
18:38:13 <lambdabot> ap = liftM2 id
18:38:22 <ivanm> @src Control.Monad.ap
18:38:23 <lambdabot> Source not found. I've seen penguins that can type better than that.
18:38:30 <sorear> They are the same entity.
18:38:39 <int-e> @index ap
18:38:40 <sorear> Monad.ap is more portable however.
18:38:40 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
18:38:40 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
18:39:18 <ivanm> sorear: how so?
18:40:05 <ivanm> @pl map (\ x -> (snd x) * (pred (snd x)))
18:40:05 <lambdabot> map (liftM2 (*) snd (pred . snd))
18:40:33 <sorear> ivanm: Monad.ap is Haskell 98
18:40:43 <ivanm> and control. is extensions?
18:41:10 <sorear> ivanm: Control.Monad.ap parses as Control.Monad (a constr) . (an operator) ap (in the curretnt module)
18:41:15 <ivanm> @pl map (\y -> (\ x -> x * (pred x)) (pred y))
18:41:16 <lambdabot> map (ap (*) pred . pred)
18:41:29 <sorear> ivanm: yeah, any module with a . in it is an extension
18:41:42 <ivanm> @pl map (\y -> (\ x -> x * (pred x)) (snd y))
18:41:42 <lambdabot> map (ap (*) pred . snd)
18:41:52 <sorear> ivanm: the proposal to make . legal in module names is many years old, but still hasn't been adopted
18:42:21 <sorear> ivanm: hugs / ghc / yhc all support it, even when told to disable extensions (IMO a bug)
18:42:33 <sorear> ivanm: hopefully haskell' will fix this
18:42:56 <ivanm> k, thanks... so is there any indication of when haskell' will be out?
18:43:09 <sorear> December 2006
18:43:20 <sorear> I will be very interested to see how they pull that off :)
18:43:24 <ivanm> ummm.... so the report is done, just not implemented?
18:43:41 <ivanm> how bout next year, so it can be a decade since haskell98 came out? ;-)
18:44:16 <sorear> The timeline on the h' wiki still says december 06 :)
18:44:28 <sorear> wow, I was sure they'd have postponed it by now
18:44:42 <ivanm> @where haskell'
18:44:42 <lambdabot> http://hackage.haskell.org/trac/haskell-prime
18:45:06 <ivanm> "NEW: The draft Haskell' report should be automatically generated whenever anyone makes a change. "
18:45:20 <ivanm> so no one has made any changes, so there's no draft?
18:46:29 <ivanm> isn't there any way of automatically casting numbers, etc?
18:47:04 <Gwern> in general, is there any GHC option to produce small binaries? or pages about doing it?
18:47:19 <ivanm> Gwern: the GHC manual?
18:47:30 <ivanm> I'm used to Java and others automagically converting values to String when required, and casting an Int to a Double when doing say Int/Double ;s
18:47:40 <Gwern> ivanm: that's not helpful. GHC doesn't seem to take the -Os option
18:48:01 * Gwern wants to test a theory that for window managers, size of the wm binary matters more than the speed of the code itself
18:48:10 <sjanssen> Gwern: you could try -optc-Os
18:48:11 <sorear> Gwern: well, -Os isn't in the manual :)
18:48:15 <sjanssen> when compiling with -O
18:48:22 <sjanssen> (which implies -fvia-c
18:48:29 <sorear> Gwern: -optl-s
18:48:35 <Gwern> 'k, thanks
18:48:43 <sorear> http://haskell.org/ghc/dist/current/docs/users_guide/smaller.html
18:48:45 <lambdabot> Title: 6.3. Smaller: producing a program that is smaller
18:48:47 <LordBrain> you mean matters more because the size affects speed?
18:48:56 <sorear> Gwern: ^^^ relevent sec. of ug
18:49:01 <Gwern> LordBrain: no, I think it's more a latency issue
18:49:07 <ivanm> I knew it was in there...
18:49:31 <sjanssen> I don't think the size of the binary should matter much after it's been running for a while
18:49:42 <Gwern> the theory is that usually a wm is doing so little computation-wise that what the user is noticing is the time it takes for the wm to actually start doing something
18:49:44 <dcoutts> Gwern: you can't get hello world below about 350k
18:49:48 <sjanssen> unless your OS's vm sucks or your system is under memory pressure
18:50:05 <ivanm> @pl \ x -> x*(pred x)
18:50:05 <lambdabot> ap (*) pred
18:50:23 <nihraguk> hmm is it possible to get a pattern guard to use an IO Bool result as a test? i'm trying to do pollEventChan x | atomically $ isEmptyTChan chan = ... but ghci is complaining about expecting a Bool and getting IO Bool instead.
18:50:27 <Gwern> sjanssen: actually, from my experience with stumpwm, which is basically a 20M binary, even if memory is free, processor utilization is also a major consideration
18:50:39 <sjanssen> 20 mb?!
18:50:42 <Gwern> admittedly, stumpwm/sbcl was many times larger than rp/xmonad, but still
18:50:44 <dcoutts> that's huge
18:50:53 <Gwern> sjanssen: remember, it's including the entire common lisp sbcl runtime
18:51:02 <Gwern> sbcl doesn
18:51:06 <Gwern> t *do* treeshakers
18:51:06 <sjanssen> xmonad includes the entire GHC runtime :)
18:51:07 <dcoutts> I'd expect xmonad to come in under a meg
18:51:21 <sjanssen> dcoutts: 917KB here
18:51:26 * sorear just misread a primop as GHC.Prim.ouch#
18:51:27 * dcoutts scores!
18:51:38 <dcoutts> sorear: heh, nice
18:51:52 <sjanssen> ouch, sharp!
18:52:12 <Pseudonym> Like a normal ouch, only a semitone higher.
18:52:33 <ivanm> @pl \ x y -> (fromIntegral x) / (fromIntegral y)
18:52:33 <lambdabot> (. fromIntegral) . (/) . fromIntegral
18:52:37 <Gwern> sjanssen: sure, but xmonad doesn't give you an eval to do arbitrary things with
18:53:01 <sjanssen> true
18:53:05 <nihraguk> anyone? i basically am asking if i can use a function that returns IO Bool in a pattern guard.
18:53:14 <sorear> No.
18:53:17 <ivanm> @pl \ (x,y) -> (fromIntegral x) / (fromIntegral y)
18:53:17 <lambdabot> uncurry ((. fromIntegral) . (/) . fromIntegral)
18:53:26 <sorear> Well, you *can*, but it will ### hurt.
18:53:30 <ivanm> @src fromIntegral
18:53:30 <lambdabot> fromIntegral = fromInteger . toInteger
18:53:45 <nihraguk> hrmm
18:53:48 <ivanm> wow.... that's so... profound ;-)
18:54:00 <ivanm> @type fromInteger
18:54:03 <lambdabot> forall a. (Num a) => Integer -> a
18:57:24 <sorear> Why is there byteArrayContents# :: ByteArray# -> Addr# but no mutableByteArrayPtr# :: MutableByteArray# -> Addr#?
18:58:38 <Gwern> well, this is annoying. adding -funfolding-use-threshold0 -optl-s as options shaves a full... 4k  off
18:59:03 <Gwern> would those options conflict with optimization options like -O2 or -O3?
18:59:12 <sorear> definitely
18:59:20 <sjanssen> Gwern: you've noticed latency in xmonad?
18:59:28 <sorear> you might want -optL-s, I can't remember which is which
18:59:42 <sorear> stripping the binary generally takes of 60%
18:59:46 <coffee_mug> > 1 + 2
18:59:46 <Gwern> sjanssen: a little bit, when I've pushing 99% cpu utilization
18:59:48 <lambdabot>  3
18:59:51 <Gwern> sorear: stripping?
18:59:56 <sorear> (you can request the with the -optL.. option)
19:00:04 <sorear> Gwern: removing of all symbol tables
19:00:16 <sjanssen> we already strip by default
19:00:19 <coffee_mug> heh, there's something weird about running an emacs IRC client and wathing lambdabot computer values
19:00:27 <sorear> Gwern: makes debugging much much harder, not that it was ever possible with haskell
19:00:33 <Gwern> heh.
19:00:34 <sorear> *feasable
19:00:42 <Gwern> so I understand from sjanssen that GHC strips by default?
19:00:47 <sorear> binary debugging that is, gdb-style
19:00:56 <sjanssen> xmonad's .cabal strips by default
19:01:09 <Gwern> oh. which option is that?
19:01:38 <sorear> Gwern: also try running 'strip -s' on the binary, the -s makes strip try harder
19:01:44 <Gwern> ok
19:02:23 <Gwern> sorear: nope, still 544K
19:02:38 <sorear> Gwern: didn't you say it was 914K earlier?
19:02:38 <sjanssen> Gwern: the s in -optl-Wl,-s
19:02:49 <sorear> Gwern: 544K is a big improvemen!
19:03:16 <Gwern> I don't think I said it was 914k, did i?
19:03:25 <sorear> sjanssen: Is X11{-extras,} compiled with split objs?
19:03:35 <sjanssen> I said 917 kb
19:03:36 <sorear> Gwern: ah no.
19:04:14 <Gwern> sorear: what I did say was that adding some options got me from 548K to 544K
19:04:56 <ivanm> @pl \ (x,y) -> (fromIntegral y) / (fromIntegral x)
19:04:56 <lambdabot> uncurry (flip ((/) . fromIntegral) . fromIntegral)
19:07:15 <sorear> Gwern: XMonad is tiny.  anything you can do to make xmonad smaller, practically speaking, will be by shrinking the libs and/or rts.
19:07:39 <sorear> eg.  without split-objs, xmonad would include all of X11
19:07:51 <Gwern> sorear: I'm starting to think so too. I've taken all the advice here and the best I can do is smaller than 4k than the default
19:08:40 <sorear> I think your best bet is to read the Commentary and get to work fixing the bitrotted dynamic linking support for Linux :)
19:08:58 <Gwern> sorear: hah hah hah. that's totally beyond me competency
19:09:04 <ivanm> @pl \ n c -> map f (g n c)
19:09:05 <lambdabot> (map f .) . g
19:09:10 <sorear> or just use OSX, dynamic linking supposedly still works there
19:09:38 <sorear> OTOH ppc machine code is much less dense than i386 machine code
19:10:24 <dcoutts> sorear: still? that's the only place it's worked, linux/elf support is still on the todo list
19:10:49 <Gwern> reading through the docs, I wonder what xmonad's gc characteristics are like? I wouldn't think it does much gc at all
19:11:27 <ivanm> @pl \ ns c -> map (\ n -> (n,f n c)) ns
19:11:27 <lambdabot> flip (map . ap (,) . flip f)
19:11:48 <ivanm> @pl \ c ns -> map (\ n -> (n,f n c)) ns
19:11:48 <lambdabot> map . ap (,) . flip f
19:12:03 <ivanm> @pl \ c n -> map f (g n c)
19:12:03 <lambdabot> (map f .) . flip g
19:18:47 <ivanm> @hoogle [a] -> [a]
19:18:48 <lambdabot> Prelude.cycle :: [a] -> [a]
19:18:48 <lambdabot> Prelude.init :: [a] -> [a]
19:18:48 <lambdabot> Prelude.reverse :: [a] -> [a]
19:19:20 <ivanm> @hoogle mean
19:19:21 <lambdabot> No matches found
19:19:25 <ivanm> @hoogle ave
19:19:25 <lambdabot> Control.Monad.ST.unsafeInterleaveST :: ST s a -> ST s a
19:19:26 <lambdabot> System.IO.Unsafe.unsafeInterleaveIO :: IO a -> IO a
19:19:26 <lambdabot> System.Win32.Registry.c_RegSaveKey :: PKEY -> LPCTSTR -> LPSECURITY_ATTRIBUTES -> IO ErrCode
19:19:39 <ivanm> @hoogle (Num a) => [a] -> [a]
19:19:40 <lambdabot> Prelude.cycle :: [a] -> [a]
19:19:40 <lambdabot> Prelude.init :: [a] -> [a]
19:19:40 <lambdabot> Prelude.reverse :: [a] -> [a]
19:19:40 <sorear> ghc uses EBP as the stack pointer!?
19:19:49 <ivanm> @hoogle (Num a) => [a] -> a
19:19:49 <lambdabot> Prelude.product :: Num a => [a] -> a
19:19:50 <lambdabot> Prelude.sum :: Num a => [a] -> a
19:19:50 <lambdabot> Prelude.head :: [a] -> a
19:19:56 <ivanm> @hoogle (Num a) => [a] -> Double
19:19:57 <lambdabot> No matches, try a more general search
19:20:07 <LordBrain> EBP?
19:20:22 <ivanm> is there an inbuilt average function? of do I just define my own?
19:20:59 <sorear> LordBrain: Extended base pointer.  Thank Intel for this register name.
19:21:27 <LordBrain> oh, didn't realize you were referring to the register
19:21:50 <dcoutts> sorear: is that surprising?
19:22:03 <dcoutts> the use of ebp I mean
19:22:12 <sorear> dcoutts: yes
19:22:24 <dcoutts> ok, I suppose I meant 'why' :-)
19:22:47 <sorear> dcoutts: every normal abi uses esp, and the isa has support insns for such use (PUSH, POP, RET, CALL)
19:23:16 <dcoutts> sorear: though ghc does not use the C stack, or enter calls in that way
19:23:36 <sorear> dcoutts: there is no C stack. I'm looking at NCG output.
19:24:53 <dcoutts> sorear: but think about signals/interrupts, they are going to expect the C stack to be set up, so can we really re-use esp for ghc's stack?
19:25:32 <ivanm> is there an inbuilt average function? of do I just define my own?
19:25:39 <LordBrain> i think your own
19:25:39 <dcoutts> ivanm: define your own
19:25:50 <sorear> dcoutts: the C stack has no magic structure, it's just a memory region with a free space pointer
19:26:13 <dcoutts> sorear: there might be nearly 0 space left on ghc's stack at any moment
19:26:15 <ivanm> that's what I thought... *shrug* I'm only averaging a couple of numbers, i could afford to be unefficient
19:26:24 <sorear> dcoutts: so as long as we use esp as a stack (ie a couple KB free below esp at all times), signal handlers should work
19:26:29 <sorear> dcoutts: uh, why?
19:26:29 <dcoutts> sorear: since it doesn't use a large contigous stack
19:27:02 <dcoutts> it allocates it in chunks I think
19:27:06 <LordBrain> hmmmm if i do sum x / length x. does ghc do a bannasplit transformation?
19:27:13 <LordBrain> :)
19:27:15 <dcoutts> LordBrain: sadly not
19:27:20 <sorear> I suppose it would be possible to fudge the stack checks to ensure at least N kbytes, rather than 0
19:27:26 <LordBrain> oh well
19:27:27 <dcoutts> LordBrain: that's a bit hard to spot in general
19:27:33 <LordBrain> yeah
19:27:36 <dmwit> What's a banana split transformation?
19:27:40 <mauke> @type liftM2 (/) sum (fromIntegral . length)
19:27:42 <sorear> though it would make tso's a bit more expensive
19:27:43 <lambdabot> forall b. (Fractional b) => [b] -> b
19:28:23 <dcoutts> sorear: but then we have to allocate the stack in really big chunks, I think it currently uses relatively small chunks, like 4k or something
19:29:38 <LordBrain> dmwit, it's one of the "functional pearls": http://journals.cambridge.org/article_S0956796801004038
19:29:45 <sorear> istr reading the ghc stack was contiguous, and grown by realloc-a-like.
19:29:59 <dmwit> LordBrain: Thanks.
19:30:08 <sorear> procyon112`: chessguy pinged 1.5h ago
19:30:14 <dcoutts> sorear: I may be mis-remembering
19:30:26 <procyon112`> @seen chessguy
19:30:27 <lambdabot> chessguy is in #haskell, #ghc, #haskell-overflow, #figs, #haskell-blah and #ai. I last heard chessguy speak 1h 36m 23s ago.
19:30:39 <dcoutts> sorear: if you can find us a spare register on x86 everyone would be grateful :-)
19:32:51 <ivanm> @hoogle intersperse
19:32:52 <lambdabot> List.intersperse :: a -> [a] -> [a]
19:33:11 <ivanm> @src intersperse
19:33:12 <lambdabot> intersperse _   []     = []
19:33:12 <lambdabot> intersperse _   [x]    = [x]
19:33:12 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
19:36:41 <LordBrain> dmwit, actually... that wasnt hte paper i meant to give you... i seem to have lost it
19:37:20 <dmwit> The abstract didn't seem terribly related... but I couldn't read the actual paper, so I wasn't sure. =P
19:38:08 <ivanm> If I have a Double such as 6.12341e-2, is there any way of making it into only 3 significant figures _without_ knowing what power of 10 it is?
19:38:14 <LordBrain> dmwit: basicly, instead of two passes, one to compute the sum and another to compute the length, the transformation would give you an algorithm which computes it in only one pass.
19:38:35 <dibblego> isn't that what HFusion is all about?
19:38:51 <dmwit> ok
19:39:33 <LordBrain> dmwit, i recall it is covered in a book by Richard S Bird... The Algebra of Programming
19:39:51 <LordBrain> i think the relevant chapter is online
19:40:49 <LordBrain> http://www.amazon.com/gp/reader/013507245X/ref=sib_dp_pt/103-0448320-8199809#reader-link
19:40:51 <lambdabot> http://tinyurl.com/2e2t5x
19:41:26 <mauke> > printf "%.2e" 6.12341e-2 :: String
19:41:28 <lambdabot>  "6.12e-2"
19:42:07 <ivanm> mauke: haskell has printf? I don't recall seeing that anywhere!!!
19:42:21 <mauke> @index printf
19:42:22 <lambdabot> Text.Printf
19:42:56 <ivanm> it couldn't find the module Text :(
19:43:01 <ivanm> @hoogle printf
19:43:02 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
19:43:02 <lambdabot> Text.Printf :: module
19:43:02 <lambdabot> Text.Printf.hPrintf :: HPrintfType r => Handle -> String -> r
19:43:11 <ivanm> oh, its text.printf.printf
19:43:18 <sorear> ivanm: sounds like you have a real haskell 98 compiler
19:43:19 <mauke> no, Text.Printf.printf
19:43:20 <sorear> oh.
19:43:21 <LordBrain> if i remember right, bird doesn't use haskell...  but some haskell like language which was invente just for the book... forgot what its called..
19:43:25 <procyon112`> >  foldr (\x (y,l)-> (x+y,l+1)) (0,0) [1,2,3,4]
19:43:27 <lambdabot>  (10,4)
19:43:53 <LordBrain> phi perhaps
19:43:57 <ivanm> sorear: lol, just ghc 6.6
19:45:07 <ivanm> OK, time to go to class :(
19:45:12 <ivanm> cya!
19:46:29 <LordBrain> i might be thinking of a different book actually..
19:46:35 <LordBrain> oh well i'm useless :)
19:48:26 <ray> me too!
19:48:35 <ray> =D
19:49:00 <ddarius> @google "banana split" catamorphism
19:49:03 <lambdabot> http://www.md.chalmers.se/~patrikj/Courses/intense00/ex/
19:49:04 <lambdabot> Title: Exercises
19:50:40 <chessguy> procyon112: sorry, was on the phone
19:50:52 <chessguy> any luck fixing your typechecker?
19:52:38 <chessguy> @bot
19:52:39 <lambdabot> :)
19:52:46 <chessguy> oh ok, thought i got booted
19:53:08 <procyon112`> It's working.  I'm working on making a tree generator now.
19:53:13 <procyon112`> Been busy this weekend.
19:53:31 <chessguy> no rush. was just curious how you made out
19:53:45 <chessguy> fixing that is certainly good progress
19:54:19 <procyon112`> it's still broken (that function is) but that's not too important, as it's not used in the main algorithm
19:55:17 <chessguy> ah, ok. do you have your code in a darcs repo? i'd like to play around with the REPL you have
19:56:27 <procyon112`> not yet.  I haven't set up one yet.
19:57:09 <chessguy> hmm, if you want to email it to me, i could put it up next to mine on lemmih's server
19:58:53 <procyon112`> hmm.  I've got a webserver going.. I just haven't set up darcs. (never had anything worth serving)
19:59:18 <chessguy> ok, well no big deal. i just wanted to play around with it
19:59:27 * sorear has just used Lazy ST for the first time
19:59:37 <ddarius> sorear: What for?
19:59:47 * ddarius used it some years ago in that Prolog interpreter.
19:59:55 <procyon112`> give me a few and I'll mail it off.  Codes a mess at the moment, as I'm in the middle of fixing this function.
20:00:17 <sorear> A small test program semantically equivalent to [0..]
20:00:25 <sorear> doesn't work with strict ST
20:00:43 <sorear> but I want to use something like lazy-st for my pretty printer
20:01:19 <chessguy> ok
20:04:55 <sorear> how is lazy-st perfwise?
20:09:23 <ddarius> Like most lazy thing.  When it's the right thing, it's the right thing.
20:13:37 <chessguy> is there an extension to get around this?
20:13:38 <chessguy>     Illegal instance declaration for `GraphM IO SGr'
20:13:38 <chessguy>         (The instance type must be of form (T a b c)
20:13:38 <chessguy>          where T is not a synonym, and a,b,c are distinct type variables)
20:14:02 <sorear> FlexibleInstances
20:14:09 <sorear> aka, -fglasgow-exts
20:14:42 <chessguy> was that new to 6.6 or something?
20:14:55 <sorear> I don't think so...
20:15:22 <chessguy> wierd. i'm trying to build a library that built under 6.4.2, but not requires -fglasgow under 6.6
20:15:54 <sjanssen> that would certainly give an error with 6.4.2
20:17:18 <chessguy> but if it's not required when building under 6.4.2, why would it be required under 6.6?
20:17:42 <sjanssen> there must be a problem with your build system
20:18:04 <chessguy> well, i didn't try building it under 6.4.2 here, i'm taking the authors' word on that
20:18:14 <sjanssen> the author is probably mistaken
20:18:28 <chessguy> maybe his build system automatically applies -fglasgow?
20:18:29 <sjanssen> just add {-# OPTIONS_GHC -fglasgow-exts #-} to the top of the file
20:18:33 <chessguy> i did
20:18:35 <chessguy> it works now
20:18:41 <chessguy> i'm just trying to figure out why :)
20:19:45 <sjanssen> the author probably gave ghc the -fglasgow-exts flag
20:20:04 <sjanssen> is this a cabalized package?
20:20:16 <chessguy> well, there was one other change i had to make, also. he was hiding something that wasn't exported
20:20:47 <chessguy> Module `Data.Array.IO' does not export `indices'
20:20:58 <chessguy> i guess that could be a 6.4.2 vs. 6.6 thing
20:21:03 <sjanssen> yes, it is
20:22:49 * sorear is experimenting with an alternate implementation of Lazy ST
20:26:52 <kc5tja> Neat -- xmonad is consuming a grand total of 4.5MB of memory.
20:28:19 <dons> that should come down after an bit of time.
20:28:20 <jcreigh> sjanssen: I'm currently generalizing the tile to do "vertical layout" as well. I'm a little confused by the terminology. I had considered dwm-style master area on left with smaller windows tiled on right to be a "vertical" split/layout. but the code calls this "horizontal". I don't quite understand the reasoning there...
20:28:33 <dons> kc5tja: it seems to drop down to around 1.5M after a days uptime.
20:28:39 <dons> (i.e. after about 10 mins actual cpu time)
20:28:48 <jcreigh> heh..."a few days"
20:29:00 <kc5tja> dons: It's been running for several days straight so far.
20:29:22 <kc5tja> But it's constant -- it has shown no trend of growing so far.
20:29:27 <dons> ok. that's interesting. i've never seen it get above 3M.
20:29:38 <kc5tja> Maybe it simply hasn't had a need to GC.
20:29:50 <dons> it starts at about 1.4M on my box, grows to 2.9M, then drops down to 1.5M after a GC kicks in. there it sits.
20:29:53 <dons> yeah.
20:29:54 <jcreigh> there's different types of confusing (to me) memory usage numbers. are you guys talking about the same thing?
20:29:55 <sjanssen> jcreigh: yeah, I confuse the two also
20:30:35 * kc5tja is looking at the VIRT size as reported by top, which seems to be the sum total of everything, including shared libraries it's linked against (so it's not an accurate measure of RAM consumed)
20:30:45 <kc5tja> (since shared objects are loaded once, and only once, in RAM)
20:31:20 <sorear> kc5tja: how about putting  'io performGC' as a key binding?
20:31:23 <sjanssen> so, quick vote:  jcreigh wants to call the first tiling model horizontal.  Any other opinions?
20:31:25 <kc5tja> still, despite how large this number is, it IS one of the smallest footprints for a window manager I've seen in a while.
20:31:45 <sorear> kc5tja: just wait till (a) YHC (b) XCB ...
20:31:48 <jcreigh> sjanssen: I want to call master area on left "vertical". But I note the current code calls it horizontal.
20:31:49 <sjanssen> s/horizontal/vertical
20:31:55 <jcreigh> ah, okay
20:32:03 <sjanssen> jcreigh: proof that it's confusing :)
20:32:09 <kc5tja> sorear: Because it doesn't mean anything to me; I'm just commenting at how small it is compared to other WMs.  :)
20:32:19 <sjanssen> maybe a totally new name is needed?
20:32:31 <kc5tja> sorear: How will YHC differ from GHC?
20:32:43 <sjanssen> Left and Top, for the location of the master windows in each?
20:32:49 <kc5tja> http://mysticone.com/funny/im_link.jpg  <--  for those who like Zelda and cute kittens.
20:32:50 <sorear> kc5tja: it IS much smaller
20:33:03 <sorear> kc5tja: however it's a haskell98 compiler
20:33:18 <jcreigh> I like vertical and horizontal...descibes what space you're optimizing the master window for.
20:33:24 <sorear> kc5tja: which means virtually nothing, probably excluding xmonad, will run on it
20:33:33 <jcreigh> (that is, I like vertical and horizontal, defined my way. <g>)
20:34:23 * kc5tja has significant problems understanding how Haskell can be compiled.  I can't even figure out how to *interpret* it, let alone compile it.  :)
20:34:46 * kc5tja 's feeble brain thinks Haskell is white magic.
20:35:04 <sorear> kc5tja: you compile haskell by fudging the definition of 'compile'
20:35:19 <alec> sjanssen: missed a fragment of conversation about latency in xmonad
20:35:35 <alec> sjanssen: when I'm at load 1 or above, I see noticable delays switching from workspace to workspace
20:35:45 <alec> sjanssen: sometimes it's up to 10 seconds, which is pretty ugly
20:35:48 <kc5tja> sorear: Haha -- it still has to emit native opcodes or bytecodes, the latter of which are executed by a bytecode interpreter.
20:35:54 <alec> sjanssen: under that same load, ion3 and dwm don't flinch
20:35:58 <ddarius> Interpreting it conceptually is -very- simple.  You replace equals for equals.
20:35:59 <dmwit> alec: Refering to mod+p, or what?
20:36:02 <thoughtpolice> black magic sounds more intimidating
20:36:06 <sorear> Ok, my Evil CPS Lazy ST typechecks.  Now, let's see if it works...
20:36:08 <alec> sjanssen: mod+[1..9]
20:36:26 <sorear> kc5tja: do you know about graph reduction?
20:36:29 * kc5tja finds ion3 to be like lightning on my box at work.
20:36:35 <alec> sjanssen: tried to profile it but it stops a few seconds in for some reason
20:36:47 <sorear> kc5tja: start with an expression, say (\x -> x + x) 2
20:36:55 <kc5tja> sorear: no, but if I saw it, I'd probably consider it to be pretty obvious.  Is it anything like CSE?
20:37:02 <sorear> no
20:37:12 <sorear> kc5tja: now, as long as the top node in the expression is an application, you reduce
20:37:16 * kc5tja is a stack architecture junkie, so keep that in mind.  :)
20:37:34 <kc5tja> Define "top expression" and "reduce"?
20:37:37 <sorear> (\x -> x + x) 2  ==>  (((+) 2) 2)
20:37:44 <sorear> kc5tja: you know about syntax trees?
20:37:48 <kc5tja> Yes.
20:38:06 <sorear> kc5tja: I meant the outermost node in the syntax tree.
20:38:17 <kc5tja> So the root of a hierarchy.
20:38:21 <sorear> yes
20:38:31 <sorear> kc5tja: so for our example, the AST in explicit form is something like
20:38:33 <kc5tja> (versus the root of *the* hierarchy :) )
20:39:10 <sorear> (App (Lam "x" (App (App PlusInt (Var "x")) (Var "x"))) (Lit 2))
20:39:28 <sorear> but we'll write it simply as (\x -> ((+) x) x) 2
20:39:40 <sorear> making currying and operators explicit
20:39:59 <sorear> now, from that, we notice that the root node is of the form (App (Lam ...) ...)
20:40:00 <dmwit> re: naming the tiling modes, how about M and E?
20:40:07 <jcreigh> M and E?
20:40:12 <dmwit> The letters are a picture of the mode in action!
20:40:13 <dmwit> =)
20:40:26 <dmwit> E has one big window on the left, and three smaller ones on the right.
20:40:30 <sorear> now, we can apply the beta-reduction rule
20:40:35 <dmwit> M has a big window at top, and three smaller ones underneath...
20:40:53 <sorear> we substitute for the lambda variable the argument
20:41:19 <sorear> (App (Lam "x" (App (App PlusInt (Var "x")) (Var "x"))) (Lit 2)) ===> (App (App PlusInt (Lit 2)) (Lit 2))
20:41:21 <sorear> or
20:41:38 <sorear> (\x -> ((+) x) x) 2   ===>  ((+) 2) 2
20:41:44 <sorear> kc5tja: following still?
20:42:22 <jcreigh> I don't think that's exactly obvious. :) Although it does suggest 3 and W as names for the same layouts rotated. :)
20:42:26 <kc5tja> Yeah, pretty much; now the compiler sees that every subnode is either an internally recognized operator or a constant parameter thereof, thus allowing the compiler to statically evaluate the expression to just '4'.
20:42:43 <dmwit> Heh, yeah, it was mostly a joke.  I like the rotations, though.
20:42:44 <jcreigh> I'm tempted just to rename them the way I think they should be and see if anybody cares more than me.
20:42:52 <procyon112`> chessguy: mail sent
20:42:55 <sorear> kc5tja: we're not compiling just yet - I'm showing you the algorithm used by a naive interpreter
20:42:55 <kc5tja> Yeah, pretty much; now the compiler sees that every subnode is either an internally recognized operator or a constant parameter thereof, thus allowing the compiler to statically evaluate the expression to just '4'.
20:43:02 <chessguy> procyon112: gracias
20:43:09 <kc5tja> OK.
20:43:10 <dmwit> jcreigh: Also, I was thinking about the "dmenu" action you wrote.
20:43:12 <kc5tja> This is for interpretation.
20:43:20 <jcreigh> dmwit: hmm?
20:43:20 <kc5tja> (So I jumped right to the conclusion.  :D)
20:43:25 <procyon112`> chessguy: *VERY* pre-alpha... experimental personal playground code.
20:43:29 <dmwit> Specifically, how to make it slightly more general.
20:43:29 <chessguy> sure
20:43:37 <jcreigh> dmenu :: X String?
20:43:44 <sorear> kc5tja: Now, (App (App PlusInt (Lit 2)) (Lit 2)) is NOT of the form (App (Lam ...) ...)
20:43:59 <sorear> kc5tja: but it's not a 'nice' object either, like 2
20:44:02 <dmwit> ...
20:44:03 <dmwit> oh
20:44:07 <sorear> kc5tja: the technical term being WHNF
20:44:09 <dmwit> That's nicer than what I was thinking.
20:44:11 <chessguy> procyon112: so is mine, really
20:44:21 <kc5tja> Whole Head Normal Form?
20:44:26 <sorear> kc5tja: So we descend into the left hand side.
20:44:26 <jcreigh> Weak
20:44:50 <sorear> kc5tja: now, we push the outside of the expression onto a stack
20:44:59 <sorear> kc5tja: (this is where stack overflows come from)
20:45:07 <kc5tja> OK, stop there before continuing
20:45:17 <chessguy> procyon112: do you want me to set this up on a darcs repo?
20:45:21 <sorear> Paused.
20:45:22 <kc5tja> The "outside" of what expression -- the left-branch, or the whole tree?
20:45:31 <jcreigh> dmwit: if "dmenu" sticks around, it will probably end up being something like that. If upstream doesn't like my patches, "dmenu" is probably going to disappear from standard xmonad.
20:45:38 <procyon112`> chessguy: nah.  It's not worth distributing yet.
20:45:43 <dmwit> jcreigh: Well, anyway, I was thinking of generality on the other side, like dmenu :: String -> X ()
20:45:58 <dmwit> But it didn't do everything I wanted, and I think dmenu :: String -> X String might.
20:46:04 <sorear> kc5tja: the right branch.  We are going to focus on the left branch, so we don't need to save it anywhere, but we need the right branch to reconstruct the expression.
20:46:07 <chessguy> ok
20:46:13 <jcreigh> dmwit: what would the String argument be?
20:46:13 <procyon112`> chessguy: When I integrate into yours would be a better time to make it available.
20:46:22 <dmwit> jcreigh: The command to run as input for dmenu.
20:46:31 <kc5tja> OK, so we push the RHS on the stack, then descend into the LHS.  Got it.
20:46:37 <sorear> kc5tja: since we can't deal wit (App (App PlusInt (Lit 2)) (Lit 2)), we focus on (App PlusInt (Lit 2))
20:46:42 <dmwit> Like, for example, it might be "lsx ~/.dmenu" or so.
20:46:44 <chessguy> gotcha
20:47:15 <sorear> kc5tja: now we have (App PlusInt (Lit 2)), and since PlusInt is a binary primitive operation (necessary evil), we just construct a partial application node
20:47:28 <sorear> kc5tja: we represent this as (PlusInt1 2)
20:47:33 <jcreigh> well, yeah, but then do you generalize what you do with the output as well? For instance, you might want of variant of dmenu that starts something with xterm -e, for example.
20:47:51 <procyon112`> chessguy: findTypeMatch isn't integrated into the REPL, but is very interesting.  "findTypeMatch TInt" will return a list of all primitives that can return an Int.
20:48:02 <dmwit> jcreigh: If it returns X String, then you can just (>>= actionOfYourChoice), right?
20:48:04 <kc5tja> OH, WAIT, i think I just had a (delayed) epiphany.
20:48:04 <sorear> kc5tja: now, (PlusInt1 2) *is* a WHNF, so the recursive call of the interpreter returns.
20:48:13 <chessguy> hmm
20:48:16 <dmwit> Which generalizes the use of the output nicely.
20:48:35 * sorear has a delayed process of the word WAIT
20:48:43 <chessguy> so right now, it would be what, TInt and TReal?
20:49:11 <kc5tja> The reason a beta reduction is possible at all is because functions are curried, and therefore, the interpreter is able to apply arguments to expression trees one at a time.  Slick!  OK, sorry for the itnerruption.
20:49:14 <jcreigh> dmwit: oh! are you saying have xmonad capture the output of dmenu? That would be cool.
20:49:23 <jcreigh> dmwit: dmenu "dmenu_path" >>= spawn
20:49:23 <procyon112`> chessguy: "findTypeMatch ((TVar 0) :-> TInt)" will return all primitive functions that unify with (can be expressed as, with no conflicts) the type a->Int
20:49:28 <dmwit> jcreigh: Right!
20:49:30 <sorear> kc5tja: we are at the top level again, and our tree is (App (AddInt1 2) (Lit 2))
20:49:34 <kc5tja> Continue please.  I just had to express that or else it'd interfere.
20:49:38 <jcreigh> I like that idea.
20:49:38 <dmwit> jcreigh: Out of curiosity, what were you thinking?
20:49:52 <jcreigh> oh, something ugly.
20:49:54 <jcreigh> , ((modMask,               xK_p     ), dmenuOnCurrentScreen >>= (\d -> spawn $ "exe=`dmenu_path | " ++ d ++ "` && exec $exe"))
20:49:57 <sorear> kc5tja: Now we treat addint1 as a primitive operation again, giving (Lit 4)
20:49:58 <kc5tja> sorear: Right.
20:50:06 <sorear> kc5tja: and the top call returns.
20:50:20 <jcreigh> ie, just yield the dmenu command line, not the result of running it.
20:50:25 <jcreigh> but I like your idea better.
20:50:40 <kc5tja> Now, my question is how the interpreter *got* that convenient parse tree to begin with.
20:50:54 <sorear> kc5tja: which one?
20:51:00 <kc5tja> Suppose I just have something like "f(2,2)", where f is a let binding evaluating to the lambda.
20:51:05 <kc5tja> e.g.
20:51:07 <sorear> (App (Lam "x" (App (App PlusInt (Var "x")) (Var "x"))) (Lit 2))  -- this?
20:51:09 <procyon112`> chessguy: TInt, TReal, and a, b, c, d ... But you have to express polymorphic variables as "TVar 0, TVar 1, TVar 2 ..." where the numbers are the different vars. So a->a->b is (TVar 0):->(TVar 0):->(TVar 1)
20:51:12 <kc5tja> let f = \x -> x+x in f(2,2)
20:51:21 <kc5tja> How would we evaluate f(2,2) in this case?
20:51:27 <sorear> OK.
20:51:47 <sorear> (for the sake of my fingers we'll use haskell syntax now, if you don't mind)
20:52:03 <kc5tja> WHAT?!  No Lisp?!  For shame.  ;D
20:52:04 <LordBrain> you would need a Num instance for tuples
20:52:13 <LordBrain> for pairs..
20:52:34 <sorear> We start with desugaring, which I'm sure doesn't pose any mental hurdles.
20:52:43 <chessguy> LordBrain: you mean 2-tuples (that sounds so much cooler than "pairs")
20:52:49 <LordBrain> hehehe
20:52:58 <kc5tja> Nope; I just treat that phase like it's a macro expansion.
20:52:59 <sorear> ignoring types,  let x = y in z  ====  (\x -> z) y
20:53:41 <sorear> so let f = \x -> ((+) x) x in (f 2) 2  ===  (\f -> (f 2) 2) (\x -> ((+) x) x)
20:53:52 <sorear> now we have (\f -> (f 2) 2) (\x -> ((+) x) x)
20:54:09 <sorear> we have a lambda on the left, so we beta-reduce
20:54:32 <sorear> this gives us (( \x -> ((+) x) x ) 2) 2
20:54:44 <dmwit> Wait, f has arity 1, why (f 2) 2?
20:55:01 <sorear> <kc5tja> let f = \x -> x+x in f(2,2)
20:55:03 <kc5tja> dmwit: Because I used the wrong syntax; I used f(2,2) instead of (f 2 2)
20:55:13 <sorear> I eliminated the tuple without thinking :)
20:55:27 <kc5tja> Yeah, i was using normal algebraic notation from HighSkewl.
20:55:34 <kc5tja> Shame on me.
20:55:34 <dmwit> > let f x = x + x in f 2 2
20:55:35 <LordBrain> but its still an arity one function......
20:55:35 <lambdabot>   add an instance declaration for (Num (t -> a))
20:55:35 <lambdabot>     In the expression: let f...
20:55:39 <sorear> let's assume kc5tja said   let f = \x -> x+x in f 2  -- only one arg this time
20:55:43 <LordBrain> whats f 2 3?
20:55:58 <chessguy> LordBrain: an error
20:56:07 <LordBrain> unless you have an instance of Num for functions...
20:56:13 <kc5tja> Oh, yeah, they're right.  That was my fault.  Ooops.  :(  Drop the second 2.
20:56:14 <kc5tja> :)
20:56:15 <chessguy> right
20:56:18 <sorear> let f = \x -> ((+) x) x in f 2  ===  (\f -> f 2) (\x -> ((+) x) x)
20:56:25 <dmwit> Okay, fine.  I think you can safely assume we know how to fix the commentary up to here, then. =)
20:56:42 <sorear> So start the interpreter on: (\f -> f 2) (\x -> ((+) x) x)
20:57:08 <sorear> we have a lambda on the left - beta reduce by substituting the actual parameter for f:
20:57:23 <sorear> interpret: (\x -> ((+) x) x) 2
20:57:28 <sorear> then continue as before.
20:57:37 <kc5tja> So
20:57:43 <kc5tja> (\x -> ((+) x) x) 2
20:57:54 <kc5tja> ((+) 2) 2)
20:58:00 <kc5tja> ((+# 2) 2)
20:58:00 <kc5tja> 4
20:58:03 <sorear> yes.
20:58:14 <sorear> Now, for the difference between strict and lazy.
20:58:19 <sorear> Infamous example:
20:58:26 <sorear> let x = DieHorribly in 2
20:58:30 <sorear> Desugar
20:58:31 <kc5tja> Now I see why Haskell is left-associative instead of right.
20:58:38 <sorear> (\x -> 2) DieHorribly
20:58:40 <kc5tja> This design just "falls out" if it is.
20:58:45 <sorear> Beta reduce
20:58:46 <sorear> 2
20:59:02 <sorear> we substitute *before* evaluating
20:59:07 <kc5tja> That's because there's no reference to x here.
20:59:07 <sorear> that is the essence of laziness
20:59:09 <kc5tja> Correct.
21:00:01 <LordBrain> really, we probably should have wrote the variables first and then the functions we apply, but that convention is really ancient and stubborn.
21:00:11 <sorear> Now for compilation...
21:00:19 <kc5tja> sorear: And you substitute as much as possible before any evaluation is done (because it's recursive)
21:00:28 <sorear> Delete last line
21:00:38 <sorear> kc5tja: yes.
21:00:39 <LordBrain> although, i had a topology professor who prefered to write things that way
21:01:05 <sorear> kc5tja: what I just described is called "tree reduction", or "call by name"
21:01:30 <sorear> kc5tja: there is a fairly simple optimization that can make it much faster
21:01:38 <sorear> kc5tja: enter Graph Reduction
21:01:45 <sorear> consider:
21:02:05 <sorear> let f x = + x x in f (* 3 3)
21:02:14 <sorear> we'd like to only do the multiplication ONCE
21:02:22 <sorear> but with tree reduction:
21:02:26 <sorear> let f x = + x x in f (* 3 3)
21:02:30 <sorear> desugar-->
21:02:43 <sorear> let f = \x -> + x x in f (* 3 3)
21:02:44 <sorear> desugar-->
21:03:06 <sorear> (\f -> f (* 3 3)) (\x -> + x x)
21:03:11 <sorear> betareduce-->
21:03:25 <sorear> (\x -> + x x) (* 3 3)
21:03:26 <sorear> betareduce-->
21:03:34 <sorear> + (* 3 3) (* 3 3)
21:03:45 <sorear> oh noes! we just duplicated work!
21:03:57 * kc5tja feints . . .
21:04:22 <sorear> descend-->
21:04:44 <sorear> [ (* 3 3) ] + (* 3 3)
21:05:15 <jcreigh> oh, there's functions called "x" and "y" somewhere in X11, aren't there? That's why I'm getting the warnings about shadowing...
21:05:20 <sorear> actually, back up, + is a bad primop because it is strict...
21:05:43 <sorear> so we need lots of funny business in the descend
21:05:47 <chessguy> jcreigh: really? that would be phenomenally stupid
21:05:56 <sjanssen> @seen alec
21:05:56 <sorear> let @ be a place-holder
21:05:57 <lambdabot> I saw alec leaving #haskell 23m 13s ago, and .
21:05:57 <kc5tja> Let's invent a function "square" that squares a value.
21:06:00 <kc5tja> ok
21:06:08 <rashakil> jcreigh: They're not in the index
21:06:19 <sorear> Unfortunately, that wouldn't help with this exposition.
21:06:24 <jcreigh> oh, it's in X11-extras
21:06:31 <sorear> + (sqr 3) (sqr 3)
21:06:36 <kc5tja> No
21:06:42 <kc5tja> Never mind.
21:06:44 <kc5tja> Go on.
21:06:45 <kc5tja> use @
21:06:55 <jcreigh> we should probably fix that at some point.
21:06:55 <sorear> [ (+ @ (* 3 3)) ] * 3 3  -- by descent
21:07:05 <sorear> -- descend again
21:07:05 <sjanssen> jcreigh: yeah, I agree that those are bad names
21:07:36 <sorear> [ (+ @ (* 3 3)) ] * 3 3
21:07:41 <sorear> reduce-->
21:07:45 <sorear> [ (+ @ (* 3 3)) ] 9
21:07:49 <sorear> unwind-->
21:07:57 <sorear> + 9 (* 3 3)
21:08:01 <sorear> descend -->
21:08:12 <sorear> [ (+ 9 @) ] * 3 3
21:08:16 <sorear> multiply AGAIN
21:08:19 <sorear> [ (+ 9 @) ] 9
21:08:22 <sorear> unwind-->
21:08:26 <sorear> + 9 9
21:08:30 <sorear> reduce-->
21:08:31 <sorear> 18
21:08:58 <sorear> Here, we doubled one *, but in the worst case programs can become exponentially slower.
21:09:23 <sorear> So we have to replace our expression with GRAPHS, which are characterised by sharing.
21:09:35 * sorear checks r5rs for shared substructure read syntax...
21:10:54 <kc5tja> I don't have r5rs.  Googling.
21:11:27 <sorear> Not finding it in r5rs, so I'll just invent something again.
21:11:46 <sorear> 1#(expr)  defines 1 to be expr,  !1  refers to expr.
21:11:54 <jcreigh> sjanssen: "vertical" tiling patch sent. (I didn't make any effort to change the terms used in this patch.)
21:12:02 <sorear> So now, with graph reduction:
21:12:09 <sorear> (\f -> f (* 3 3)) (\x -> + x x)
21:12:21 <sorear> ordinary beta reduction:
21:12:26 <jcreigh> sjanssen: note how easy it would be to flip arbitrary layouts.
21:12:29 <sorear> (\x -> + x x) (* 3 3)
21:12:37 <sorear> now is the tricky bit
21:12:48 <sorear> we share the same internal node for both x's
21:12:58 <sorear> so we reduce to:
21:13:08 <sorear> + 1#(* 3 3) !1
21:13:30 <sorear> imagine a pretty graph with multiple arows pointing to the * 3 3
21:13:53 <sorear> Now, we descend:
21:14:11 <sorear> [ + @ 1#(* 3 3) ] !1
21:14:34 <sorear> !1 is + applied to two literals, so we can reduce it.
21:14:53 <sorear> but because both 1's are the same pointer, the results of reduction are ALIASED
21:15:00 <sorear> reduce:-->
21:15:07 <sorear> [ + @ 9 ] 9
21:15:20 <sjanssen> jcreigh++ good patches
21:15:23 <sorear> well, [ + @ 1#9 ] !1  actually
21:15:30 <sorear> kc5tja: follow?
21:15:48 <sjanssen> and this is why a pure layout algorithm is so much better than the old imperative one
21:17:52 <ctcp_death> man, i feel like crying every time I come across a problem that screams 'extensible records' at me..
21:18:44 <sorear> kc5tja: pausing until I'm sure you get this, the aliasing aspect of graph reduction is pretty important
21:18:52 <jcreigh> sjanssen: yes, it's dirt simple to do if you have a pure function you can call.
21:19:04 <sjanssen> @seen rashakil
21:19:05 <lambdabot> rashakil is in #perl6 and #haskell. I last heard rashakil speak 12m 56s ago.
21:19:10 <rashakil> hi
21:19:22 <sjanssen> rashakil: have you pulled xmonad recently?
21:19:27 <rashakil> no
21:19:53 <sjanssen> okay, I reverted your layout changes, because the 'disposition' stuff made window sizes unpredictable
21:20:29 <rashakil> good
21:20:57 <rashakil> I was getting rather annoyed and installed dwm instead :-]
21:21:19 <sjanssen> rashakil: for example, when I created a bunch of xterms on a fresh workspace in tiling mode, the xterms weren't all the same size
21:21:36 <sjanssen> heh.  If the changes bug you so much, why'd you make them? :)
21:21:46 <rashakil> I didn't realize they would
21:21:58 <rashakil> the problem was, new ones picked up a ratio of 1/3 automatically
21:22:09 <rashakil> new windows, i mean
21:22:20 <Gwern> @seen sjanssen
21:22:20 <lambdabot> sjanssen is in #haskell, #gentoo-haskell, #haskell-overflow, #haskell-soc and #ghc. I last heard sjanssen speak 43s ago.
21:22:27 <Gwern> fair enough.
21:22:49 <sorear> Drat, my re-implementation of lazy st is actually STRICT
21:22:50 <rashakil> but then that gets normalized down, so 1 + 1/3 becomes 3/4 + 1/4.  Then the new windows get a 1/4 ratio all the time, while the others get squashed down proportionally.
21:22:54 <rashakil> which is... retarded.
21:23:01 <Gwern> oy, sjanssen: I tried out openarena in dwm, and the glitchly mouse behaivour was not present
21:23:08 <Gwern> so! an xmonad bug then!
21:23:26 <sjanssen> Gwern: yeah, you can be fairly confident that we'll fix it eventually
21:23:30 * Gwern feels pleased. my first real xmonad bug which is neither alreaydy dsicovered nor actually a feature request
21:23:46 <sjanssen> Gwern: or if you feel like narrowing down the problem, patches are always accepted
21:23:53 <Gwern> sjanssen: do you have ideas already what's going wrong?
21:24:07 <sjanssen> no, not really
21:25:23 <jcreigh> If I want to capture the stdout of some external program (on unix), is there anything like popen(), or do I have to do the pipe/fork/exec dance?
21:25:35 <sorear> @where newpopen
21:25:36 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/newpopen
21:25:51 <sjanssen> jcreigh: in C or Haskell?
21:25:56 <jcreigh> sjanssen: Haskell
21:26:02 <sjanssen> @docs System.Process
21:26:03 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Process.html
21:26:35 <sorear> jcreigh: newpopen is dons' fixed version of that.
21:26:35 <sjanssen> it kinda sucks, but it's likely more convenient than fork/pipe/exec
21:26:41 <sorear> @seen kc5tja
21:26:42 <lambdabot> kc5tja is in #haskell. I last heard kc5tja speak 15m 48s ago.
21:26:44 <jcreigh> "fixed"?
21:26:53 <sjanssen> nicer interface
21:27:23 <jcreigh> oh, I see: it just returns a string, instead of Handles up to your eyeballs.
21:27:38 <procyon112`> is there an ffoldr?
21:27:51 <sjanssen> where f means?
21:28:06 <sjanssen> fun foldr?
21:28:11 <procyon112`> er nm... I think I'm confused.
21:28:21 <kc5tja> sorear: I didn't find any information on this on the r5rs website.
21:28:24 <kc5tja> brb -- nature calls.
21:33:29 <kc5tja> back
21:35:06 <sorear> kc5tja: heh.  I went for shared structure read syntax because I mistakenly seemed to recall you being a lisper.
21:35:28 <sorear> Hopefully you'll still be able to understand the above.
21:35:49 <kc5tja> Nope -- BUT, what you described makes sense.  I don't know how it identifies x as being the same node generally (although in this specific case it's easy since it's just "x").
21:36:03 <kc5tja> Bad timing
21:36:08 <kc5tja> I *do* understand what you've written.
21:36:17 <kc5tja> The Nope was in response to me being a lisper.
21:36:23 * kc5tja is a Forther.  ;)
21:36:45 <sorear> kc5tja: the trick is that we do substitution using pointers
21:36:54 <sorear> (\x -> + x x) (* 3 3)
21:37:46 <sorear> (* 3 3) is one structure in memory, and it has an addres, let's call it 42
21:38:18 <sorear> so (keep in mind everything here is indirect via a pointer, not just the ones where I make it explicit):
21:38:32 <sorear> (\x -> + x x) #42         memory cell 42: (* 3 3)
21:38:52 <sorear> then when we do the substitution, we don't copy the whole argument
21:38:59 <sorear> we just copy the pointer
21:39:11 <sorear> + #42 #42    memory cell 42: (* 3 3)
21:39:16 <sorear> make sense?
21:39:29 <kc5tja> Yes
21:39:42 <kc5tja> So far everything is call-by-name.
21:40:23 <sorear> But we *didn't* copy the * 3 3!  so it only needs to be reduced once!
21:41:03 <sorear> at the expense of complicating our algorithm with shared subobjects (or equivalently, pointers + pointer equality)
21:41:38 <sorear> this modified algorithm is called (somewhat confusingly) "call-by-name" or (even more confusingly) "laziness"
21:42:06 <kc5tja> Yeah, Algol and PL/I use this too.
21:42:32 <kc5tja> (but they don't do beta reduction or memoization if I recall correctly)
21:43:17 * arke awakes from eternal slumber ... greetings, everybody
21:43:20 <sorear> Now, for compilation.
21:43:25 <sorear> greetings, arke
21:43:49 <sorear> consider a slightly more complex example, factorial:
21:43:58 <dolio> Isn't the modified algorithm called "call-by-need"?
21:44:12 <sorear> dolio: *doh*
21:44:13 <dolio> And the original (without sharing) is "call-by-name"?
21:44:25 <sorear> dolio: Actually, I called both "call-by-name"
21:44:51 <sorear> what I meant to say: this modified algorithm is called (somewhat confusingly) "call-by-need" or (even more confusingly) "laziness"
21:44:56 <sorear> thanks
21:45:06 <dolio> No problem.
21:45:09 <sorear> back to compiling.
21:45:45 <arke> sorear: are you explaining how the haskell compiler does its thing? if so, i need to start reading the backbuffer... :0
21:45:52 <sorear> arke: yes.
21:45:58 <arke> aah, nice!
21:45:59 <kc5tja> arke: Better start scrolling back.
21:46:01 * arke begins reading
21:46:09 <arke> kc5tja: about how far/
21:46:30 <sorear> arke: so far I've described the algorithm used to *interpret* haskell.
21:46:51 <kc5tja> About one hour ago, more or less.
21:46:52 <sorear> arke: about 1h 10m
21:48:44 <sorear> let factorial = \num -> (let worker = \num -> \acc -> (if (== num 1) acc (worker (- num 1) (* acc num)))) in factorial 100
21:48:57 <dons> sjanssen: hehe. xmonad got leaked on dwm@suckless.org
21:49:05 <dons> sjanssen: now we'll see if Anselm cares.
21:49:09 <jcreigh> who?
21:49:11 <sorear> in more conventional syntax:
21:49:13 <jcreigh> dwm dev?
21:49:19 <dons> sjanssen: thanks to lennart, http://lennartkolmodin.blogspot.com/2007/04/xmonad.html
21:49:21 <lambdabot> Title: Bits and Bytes: xmonad
21:49:22 <dons> jcreigh: yes.
21:49:51 <sjanssen> dons: yikes :)
21:50:09 <sorear> let factorial num = let worker num acc | num == 1  = acc
21:50:09 <sorear>                                        | otherwise = worker (num - 1) (num * acc)
21:50:09 <sorear>                     in worker num 1
21:50:51 <sorear> hmm, bad example (needs strictness analysis to work well)
21:50:57 <sorear> new:
21:51:39 <sorear> let factorial 1 = 1
21:51:39 <sorear>     factorial n = n * factorial (n - 1)
21:51:39 <sorear>  in factorial 100
21:52:01 <sorear> kc5tja: I'll assume you understand that - standard recursive factorial.
21:52:29 <dons> sjanssen: the precise text of the dwm mail is:
21:52:31 <dons> Subject: [dwm] xmonad: dwm clone in Haskell
21:52:31 <dons> Looks like they're shooting for <400 lines of code:
21:52:31 <dons>     http://lennartkolmodin.blogspot.com/2007/04/xmonad.html
21:52:31 <dons>     http://xmonad.org/
21:52:32 <lambdabot> Title: xmonad : a lightweight X11 window manager.
21:52:32 <lambdabot> Title: Bits and Bytes: xmonad
21:52:33 <dons> --
21:52:39 <dons> so hehehe...
21:53:54 <abz> hey dons, how many hits or pages did you get on that article from reddit?
21:54:16 <sorear> In reduced syntax:
21:54:48 <sieni> :t fix
21:54:49 <sorear> let factorial = \n -> if (== n 1) 1 (* n (factorial (- n 1))) in factorial 100
21:54:51 <lambdabot> forall a. (a -> a) -> a
21:54:57 <sorear> kc5tja: ready to compile?
21:55:02 <sieni> @hoogle fix
21:55:02 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
21:55:03 <lambdabot> Control.Monad.Fix :: module
21:55:03 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
21:55:03 <kc5tja> just a sec
21:55:06 <dons> abz, which article?
21:55:14 <dons> xmonad.org?
21:55:18 <kc5tja> ok
21:55:21 <dons> (we don't know, since we don't maintain it currently)
21:55:23 <abz> for the xmond one
21:55:32 <sjanssen> @seen fantasma
21:55:32 <lambdabot> I saw fantasma leaving #haskell 2d 9h 19m 38s ago, and .
21:56:41 <jcreigh> dons: hey, what do you think should be the name of the layout where the master area is on top, and the other windows are tiled below?
21:56:55 <abz> dons: Maybe you should consider Google Analytics for the next one.
21:57:01 <kc5tja> sorear: OK
21:57:06 <sorear> kc5tja: Basically, the central idea of Haskell compilers is that every lambda is converted into a brand new primitive operation, then we interpret.
21:57:07 <dons> jcreigh: vertical/horizontal?
21:57:16 <jcreigh> sjanssen and I were arguing about it earlier
21:57:19 <jcreigh> dons: yeah, which one?
21:57:29 <dons> we split the screen in half vertically
21:57:32 <sorear> so, the first thing we need to do is find the lambdas
21:57:48 <dons> whlist in the existing mode a line is drawn through the x (horizontal) axis
21:58:13 <sorear> kc5tja: all haskell compilers use some variation on a very old (<1984) algorithm called "lambda-lifting"
21:58:31 <sjanssen> and option C is: Left for the current mode, and Top for the new mode (both named for the location of the master window)
21:58:46 <sorear> kc5tja: the algorithm identifies each lambda and the free variables, and produces a new program with only top-level lambdas
21:58:50 <dons> yeah. that's not to bad.
21:59:04 <dons> but not sure it captures the essence of the mode. which is where you split your screen
21:59:31 <sorear> kc5tja: it also creates multi-parameter functions
21:59:44 <dons> maybe it should be named after the orientation of the line that splits the screen
22:00:00 <sjanssen> jcreigh: so does dons disagree or agree with you?  I really can't keep the two straight
22:00:03 <sorear> kc5tja: as a (very) simple example of lambda lifting consider \x -> \y -> + x y
22:00:08 <dons> its a vertical line in normal left/right mode. and a horizon-tal line in the new mode.
22:00:32 <dons> mode 1 and mode 2?
22:00:36 <sorear> kc5tja: traversing the tree bottum up, we find \y -> + x y
22:00:58 <jcreigh> yes, I think current mode is "vertical" and new mode is "horizontal"
22:00:59 <sorear> kc5tja: this lambda has one argument, y, and one free variable, x
22:01:19 <sorear> kc5tja: so we create a top level definition LAM0 x y = + x y
22:01:41 <sjanssen> another option is Tall/Wide
22:01:43 <sorear> kc5tja: so the free variables are converted into arguments
22:01:58 <jcreigh> ooh, those would work as well.
22:02:10 <sorear> kc5tja: then we have { LAM0 x y = + x y } \x -> LAM0 x
22:02:15 <jcreigh> I almost like that better. No chance for confusion there.
22:02:21 <dons> fatty and skinny?
22:02:22 * kc5tja nods
22:02:32 <sorear> kc5tja: thus, we explicitly pass in the free variables
22:02:40 <sorear> kc5tja: now, \x -> LAM0 x
22:02:57 <sorear> kc5tja: has no free vars, so we just create LAM1 x = x
22:03:30 <sorear> kc5tja: so the lambda lifted form of (\x -> \y -> x + y) is { LAM0 x y = x + y ; LAM1 x = x }
22:03:45 <sorear> kc5tja: of course this is pretty silly, we can just use (+) directly
22:03:58 <sorear> kc5tja: but I'm going to ignore the optimizer for now :)
22:04:05 <kc5tja> How did you get from \x -> LAM0 x to LAM1 x = x?
22:04:35 <sorear> that lambda has no free variables, so we create a new "supercombinator" LAM1 (just a unique name)
22:04:38 <jcreigh> or we just call them "Tile" and "Full", and move the layout rotating code out so that any arbitrary layout can be rotated.
22:04:50 <kc5tja> But they don't return the same thing.
22:05:04 <kc5tja> One returns a lambda, the other *is* a lambda that just echoes its argument.
22:05:15 <sorear> kc5tja: Oh, right
22:05:32 <sorear> kc5tja: Compilers don't make random mistakes,  Sorears do.
22:05:52 <sorear> the lambda lifted form of (\x -> \y -> x + y) is { LAM0 x y = x + y ; LAM1 x = LAM0 x } LAM1
22:05:57 <kc5tja> ?TYPE MISMATCH IN LINE 22:01 . ;)
22:05:58 <lambdabot> Unknown command, try @list
22:06:37 <sorear> Now, each of these supercombinators has a very simple structure, no lambdas etc.
22:06:43 <kc5tja> OK, so the end-goal is the conversion of literally everything into a parameterless lambda.
22:06:51 <sjanssen> okay, I'm going to change them to Tall/Wide
22:06:53 <sorear> Yes.
22:07:08 <sorear> Now, back to factorial.
22:07:28 <jcreigh> sjanssen: cool. that's much better than reversed Vert/Horz.
22:07:39 <dons> less ambiguous i suppose :-)
22:07:48 <sorear> we have to add recursion to the language, hopefully you can figure out easily :)
22:07:56 <jcreigh> dons: kind of the point of naming. :)
22:08:07 <sorear> let factorial = \n -> if (== n 1) 1 (* n (factorial (- n 1))) in factorial 100
22:09:29 <hpaste>  procyon112 pasted "Passing around in tuples is getting unweildy... what am I doing wrong this time?" at http://hpaste.org/1234
22:10:08 <sorear> We only have one lambda here:
22:10:08 <sorear> (with no free vars)
22:10:08 <sorear> { LAM1 n = if (== n 1) 1 (* n (LAM1 (- n 1))) } let factorial = \n -> if (== n 1) 1 (* n (factorial (- n 1))) in factorial 100
22:10:09 <sorear> er, meant the C-k editing key not the C-j send key, disregard
22:10:13 <sorear> { LAM1 n = if (== n 1) 1 (* n (LAM1 (- n 1))) } factorial 100
22:10:15 * arke is finished reading the backbuffer ... i think i understood most of it. :)
22:10:18 <sorear> Now, we can treat LAM1 as a primitive operation in the interpreter
22:10:22 <sorear> er, doh again
22:10:23 <sorear> { LAM1 n = if (== n 1) 1 (* n (LAM1 (- n 1))) } LAM1 5
22:10:27 <sorear> I've reduced to 5, since we don't have all night :)
22:10:28 <procyon112`> Should I be using a State monad, or some other means of hiding these things I'm passing all over the place?
22:10:45 <sorear> Now we start by reducing LAM1 5
22:10:55 <sorear> by the rule for the LAM1 primitive:
22:11:06 <sorear> if (== 5 1) 1 (* 5 (LAM1 (- 5 1)))
22:11:23 <sorear> if is strict, so we descend
22:11:33 <sorear> [ if @ 1 (* 5 (LAM1 (- 5 1))) ] == 5 1
22:11:40 <sorear> [ if @ 1 (* 5 (LAM1 (- 5 1))) ] FALSE
22:11:41 <procyon112`> And is there a way to simplify that "if isjust x then fromJust x : xs else xs"??
22:11:50 <sorear> if FALSE 1 (* 5 (LAM1 (- 5 1)))
22:11:56 <sorear> by the rule for if
22:12:01 <sorear> (* 5 (LAM1 (- 5 1)))
22:12:03 <sorear> descend
22:12:17 <sorear> [ (* 5 @) ] LAM1 (- 5 1)
22:12:20 <sorear> expand
22:13:02 <sorear> [ (* 5 @) ] if (== # 1) 1 (* # (LAM1 (- # 1)))   # = (- 5 1)
22:13:18 <sorear> [ (* 5 @) : (if @ 1 (* # (LAM1 (- # 1)))) ] == # 1   # = (- 5 1)
22:13:22 <sorear> ...
22:13:44 <kc5tja> Let's reduce the initial argument to just 2
22:13:48 <sorear> The instantiate step is the tricky part.
22:13:51 <sorear> ok.
22:13:57 <sorear> [ (* 5 @) : (if @ 1 (* # (LAM1 (- # 1)))) ] == # 1   # = (- 2 1)
22:14:00 <sorear> descend
22:14:12 <sorear> [ (* 5 @) : (if @ 1 (* # (LAM1 (- # 1)))) : (== @ 1) ] #   # = (- 2 1)
22:14:24 <sorear> [ (* 5 @) : (if @ 1 (* 3 (LAM1 (- 3 1)))) : (== @ 1) ] 3
22:14:27 <kc5tja> [ (* 2 @ ) ...
22:14:32 <sorear> [ (* 5 @) : (if @ 1 (* 3 (LAM1 (- 3 1)))) ] == 3 1
22:14:36 <sorear> [ (* 5 @) : (if @ 1 (* 3 (LAM1 (- 3 1)))) ] FALSE
22:14:46 <kc5tja> 2-1=3??
22:14:47 <sorear> [ (* 5 @) ] if FALSE 1 (* 3 (LAM1 (- 3 1)))
22:14:58 <rashakil> procyon112`, if isJust x then fromJust x : xs else xs = maybeToList x ++ xs
22:15:08 <sorear> Argh.
22:15:14 <sorear> IANAC okay ;)
22:15:18 <kc5tja> haha
22:15:23 <sorear> but you get the picture.
22:15:43 <procyon112`> ?src maybeToList
22:15:44 <lambdabot> maybeToList  Nothing   = []
22:15:44 <lambdabot> maybeToList  (Just x)  = [x]
22:15:51 <jcreigh> procyon112`: maybe xs (:xs) x
22:16:02 <sorear> now, instead of doing table lookups etc for each LAM1 use, we can just *compile it into a function that builds graph*
22:16:19 <sorear> this is the central idea of the G-machine family of implementations.
22:16:26 <procyon112`> ?src maybe
22:16:26 <lambdabot> maybe n _ Nothing  = n
22:16:27 <lambdabot> maybe _ f (Just x) = f x
22:16:33 <sorear> everything else is just optimizer
22:16:58 <procyon112`> jcreigh++ rashakil++
22:18:10 <kc5tja> At this point, it's pretty thick for me.
22:18:14 <sorear> node *LAM1(node *arg) { return MK3(if_, MK2(eq_, arg, LIT1), LIT1, MK2(times_, arg, MK1(LAM1, MK2(sub_, arg, LIT1)))); }
22:18:32 <arke> HAH
22:18:35 <arke> ingenious :0
22:18:38 <arke> :)
22:18:42 <arke> stupid shift button argh
22:19:21 <sorear> and then the interpreter is just (a) look left until we reach a function (b) apply it as a C function to the argument nodes (c) goto a
22:19:37 <sorear> if_, etc call the interpreter recursively
22:20:04 <sorear> and, look!  The (spineful, tagful) G-Machine.
22:20:24 <sorear> We can use a few simple optimizations.
22:20:54 <kc5tja> But, I don't see how this helps in any way.
22:21:00 <sorear> Because we will always evaluate the graph that results from invoking a compiled supercombinator, we can move the eval call inside the definition.
22:21:12 <sorear> node *LAM1(node *arg) { return eval(MK3(if_, MK2(eq_, arg, LIT1), LIT1, MK2(times_, arg, MK1(LAM1, MK2(sub_, arg, LIT1))))); }
22:21:16 <sorear> Enter inlining.
22:22:06 <sorear> We can reduce eval(MK3(tag, a, b, c)) to tag(a, b, c)
22:22:14 <sorear> that's a major optimization
22:22:19 <foxy-om> could someone try to join #apache for me please...
22:22:29 <sorear> node *LAM1(node *arg) { return if_(MK2(eq_, arg, LIT1), LIT1, MK2(times_, arg, MK1(LAM1, MK2(sub_, arg, LIT1)))); }
22:22:43 <sorear> if_ is now directly called, so we can inline it:
22:23:41 <sorear> node *LAM1(node *arg) { node *tst = eval(MK2(eq_, arg, LIT1)) ; eval(is_true(tst) ? LIT1 : MK2(times_, arg, MK1(LAM1, MK2(sub_, arg, LIT1)))); }
22:23:51 <sorear> now push eval inside the ?:
22:24:09 <sorear> node *LAM1(node *arg) { node *tst = eval(MK2(eq_, arg, LIT1)) ; is_true(tst) ? eval(LIT1) : eval(MK2(times_, arg, MK1(LAM1, MK2(sub_, arg, LIT1)))); }
22:24:22 <sorear> eval(LIT1) is just LIT1, because LIT1 is a WHNF
22:24:28 <sorear> node *LAM1(node *arg) { node *tst = eval(MK2(eq_, arg, LIT1)) ; is_true(tst) ? LIT1 : eval(MK2(times_, arg, MK1(LAM1, MK2(sub_, arg, LIT1)))); }
22:24:39 <sorear> eval(MK2(.. reduces as before
22:25:23 <sorear> node *LAM1(node *arg) { node *tst = eval(MK2(eq_, arg, LIT1)) ; if (is_true(tst)) { return LIT1; } else { return times_(arg, MK1(LAM1, MK2(sub_, arg, LIT1))); } }
22:25:25 <kc5tja> "reduces as before" -- what before?
22:25:35 <sorear> <sorear> We can reduce eval(MK3(tag, a, b, c)) to tag(a, b, c)
22:26:01 <sorear> Now inline times_:
22:26:49 <arke> heh, man
22:26:50 <sorear> node *LAM1(node *arg) { node *tst = eval(MK2(eq_, arg, LIT1)) ; if (is_true(tst)) { return LIT1; } else { node *a = eval(arg); node *b = eval(MK1(LAM1, MK2(sub_, arg, LIT1))); return LIT(IVAL(a) * IVAL(b)); } }
22:26:56 <arke> how many loc is, say, ghc/
22:27:06 <sorear> I've heard 30k quotes
22:27:12 <arke> i believe it.
22:27:15 <sorear> eval(MK1(a, b)) = a(b)
22:27:31 <sorear> node *LAM1(node *arg) { node *tst = eval(MK2(eq_, arg, LIT1)) ; if (is_true(tst)) { return LIT1; } else { node *a = eval(arg); node *b = LAM1(MK2(sub_, arg, LIT1)); return LIT(IVAL(a) * IVAL(b)); } }
22:27:56 <sorear> Now, we can't get much better than this, because inlining LAM1 inside LAM1 Just Wouldn't Work.
22:28:23 <sorear> er, missed a spot
22:28:34 <sorear> node *LAM1(node *arg) { node *tst = eq_(arg, LIT1) ; if (is_true(tst)) { return LIT1; } else { node *a = eval(arg); node *b = LAM1(MK2(sub_, arg, LIT1)); return LIT(IVAL(a) * IVAL(b)); } }
22:29:22 <arke> hm.
22:29:23 <sorear> node *LAM1(node *arg) { node *ev_arg = eval(arg); node *tst = MKBOOL(IVAL(ev_arg) == IVAL(LIT1)) ; if (is_true(tst)) { return LIT1; } else { node *a = eval(arg); node *b = LAM1(MK2(sub_, arg, LIT1)); return LIT(IVAL(a) * IVAL(b)); } }
22:29:24 <arke> this is quite neat.
22:29:34 <sorear> Now, IVAL(LIT1) = 1
22:29:53 <sorear> and we can inline TST, thus is_true and MKBOOL cancel out
22:30:14 <sorear> node *LAM1(node *arg) { node *ev_arg = eval(arg); if (IVAL(ev_arg) == 1) { return LIT1; } else { node *a = eval(arg); node *b = LAM1(MK2(sub_, arg, LIT1)); return LIT(IVAL(a) * IVAL(b)); } }
22:30:21 <sorear> a little CSE
22:30:43 <arke> aah, you just lost me. ;)
22:30:54 <sorear> node *LAM1(node *arg) { node *ev_arg = eval(arg); int iarg = IVAL(ev_arg); if (iarg == 1) { return LIT1; } else { node *b = LAM1(MK2(sub_, arg, LIT1)); return LIT(iarg * IVAL(b)); } }
22:31:01 * arke rereads just to make sure he didnt miss anything important
22:31:04 <sorear> Common subexpression elimanation
22:31:30 <sorear> foo() ... foo()  ==>  node *a = foo() ; a .... a
22:31:40 <kc5tja> arke: He inlined the if conditional's expression.
22:31:48 <sorear> We can do this because the language we are compiling has no side effects :)
22:33:42 <sorear> I think that's about as good as you'll get in a true G-machine setting.  LAM1 has a set calling convention, which dictates that it takes and returns nodes; these nodes are lazy.
22:34:16 <sorear> With unboxing and the worker/wrapper transform we can get a bit better:
22:35:33 <sorear> int LAM1_worker(int iarg) { if (iarg == 1) { return 1; } else { node *b = LAM1(MK2(sub_, arg, LIT1)); return iarg * IVAL(b); } }  node *LAM1(node *arg) { return LIT(LAM1_worker(IVAL(eval(arg)))); }
22:35:40 <arke> oh yeah, duh :)
22:35:47 <sorear> Then we can inline the wrapper inside the worker...
22:36:38 <sorear> int LAM1_worker(int iarg) { if (iarg == 1) { return 1; } else { return iarg * IVAL(LIT(LAM1_worker(IVAL(eval(MK2(sub_, arg, LIT1)))))); } }  node *LAM1(node *arg) { return LIT(LAM1_worker(IVAL(eval(arg)))); }
22:36:45 <sorear> a little cancellation ...
22:37:08 <sorear> int LAM1_worker(int iarg) { if (iarg == 1) { return 1; } else { return iarg * LAM1_worker(IVAL(sub_(arg, LIT1))); } }  node *LAM1(node *arg) { return LIT(LAM1_worker(IVAL(eval(arg)))); }
22:37:14 <sorear> now inline sub_
22:37:41 <sorear> int LAM1_worker(int iarg) { if (iarg == 1) { return 1; } else { return iarg * LAM1_worker(iarg - 1); } }  node *LAM1(node *arg) { return LIT(LAM1_worker(IVAL(eval(arg)))); }
22:37:58 <sorear> Now look at LAM1_worker, the actual recursive function.  What's gone?
22:38:15 <sorear> it's just a recursive function on ordinary ints now!
22:38:42 <arke> ooh, cool
22:38:55 * arke saves IRC log
22:39:17 <arke> that worker thing is really cool
22:39:22 <kc5tja> arke: Mail me a copy.  This is all voodoo to me.
22:39:34 <arke> 'k
22:39:50 <arke> its quite obtuse, yeah, ;0
22:40:03 <encryptio> when would types as first-class values be useful, other than language transformers?
22:40:41 <sorear> encryptio: JohnMeacham implements typeclasses using them instead of dictionaries
22:41:01 <sorear> (+) type a b = case type of Int -> addInt a b
22:41:04 <sorear> ...
22:42:42 <arke> i think the coolest part i just saw is the worker thing
22:43:56 <kc5tja> Beta-reduction and let-desugaring are what I got out of it.
22:44:09 <kc5tja> The factorial example started to get pretty thick, and the jump into C code was inpregnable for me.
22:50:31 <arke> bleh
22:50:39 * arke forgot how to save in irssi 
22:51:17 <sorear> fwiw
22:51:20 <sorear> @where logs
22:51:21 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
22:51:21 <phoniq>  /lastlog -file foo.out  ?
22:51:34 <sorear> http://tunes.org/~nef/logs/haskell/07.04.02
22:51:42 <arke> ah
22:51:48 <arke> thats probably more convenient. :)
22:52:28 <phoniq> yeah, thanks for the tip
23:01:39 <sorear> Did I scare everyone away? :)
23:01:50 <arke> not me. ;0
23:02:00 <enkrav> Hello, is it possible to pass an 'infinite list of random integers' to a (real) function in Haskell? I don't think this would violate any principle of functional programming, yet I don't know how to accomplish such a thing.
23:02:30 <sorear> yes
23:03:05 <sorear> you can only get pseudo-random numbers of course
23:03:12 <enkrav> 'course
23:03:24 <sorear> > randomRs (0,99) (mkStdGen 42)
23:03:26 <lambdabot>  [71,71,17,14,16,91,18,71,58,75,65,79,76,18,4,45,87,51,93,36,66,4,32,94,36,14...
23:03:27 <sorear> > randomRs (0,99) (mkStdGen 42)
23:03:29 <lambdabot>  [71,71,17,14,16,91,18,71,58,75,65,79,76,18,4,45,87,51,93,36,66,4,32,94,36,14...
23:03:35 <sorear> > randomRs (0,99) (mkStdGen 42)
23:03:37 <lambdabot>  [71,71,17,14,16,91,18,71,58,75,65,79,76,18,4,45,87,51,93,36,66,4,32,94,36,14...
23:03:45 <sorear> Same argument, same result.
23:03:55 <enkrav> sufficit
23:05:00 <QtPlatypus> :type randomRs
23:05:32 <sorear> @type randomRs
23:05:35 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
23:09:02 <kc5tja> Sorry, I need to get to bed.  I'm getting quite drowsy.
23:10:42 <sorear> g'night.
23:11:09 <kc5tja> sorear: Thanks for the discussion on interpreting and compiling.  It's still beyond me at this point, but the discussion of beta-reduction and whatnot was most enlightening.
23:11:13 <kc5tja> OK, I'm out.
23:17:21 <sorear> What's a GhcException?  (And is realWorld# really supposed to be unsafe enough to crash ghci?)
23:30:25 <ibid> sorear: hm?
23:30:58 <sorear> ibid: you want to see the code or something?
23:32:21 <ibid> sorear: i'm wondering about what context your question comes from :)
23:32:23 <sorear> Oh this is funny, ghci has stopped crashing for no good reason
23:32:38 <sorear> ibid: I want Lazy ST with less boxes.
23:32:54 <sorear> ibid: strict st is State# s -> (# State# s , a #)
23:33:15 <sorear> ibid: so I'm trying to get State# s -> a working...
23:33:49 <sorear> ibid: I had a function enum ; run it at the ghci-prompt ; ^C ; ghci hangs
23:34:33 <sorear> ibid: not sure what I did, but my code properly works now
23:35:59 <ibid> sorear: hm, you're dropping the state thread?
23:36:38 <sorear> ibid: yes
23:37:06 <sorear> ibid: so it can be lazier
23:37:17 <sorear> ibid: but I'm not cloning State#'s
23:37:36 <ibid> sorear: that doesn't sound correct, the state thread is, i believe, what keeps the compiler from reordering effects
23:38:25 <sorear> The state is threaded, from "outside in"
23:39:19 <ibid> i don't understand, but i suppose i don't have the time to make myself understand, sorry
23:39:47 <sorear> We can have a safe (?) iterate
23:40:16 <sorear> iterate :: (State# s -> (# State# s, a #)) -> State# s -> [a]
23:40:43 <sorear> so it turns a strict-st action into my thread reader action
23:41:35 <sorear> iterate fun st0# = case fun st0# of (# st1# , a #) -> let rst = iterate fun st1# in a : rst
23:41:52 <sorear> that doesn't duplicate state threads, so ordering is still fixed
23:42:13 <sorear> but now if I pass in realWorld#, I can start consuming from the infinite list immediately
23:42:52 * sorear looks at -ddump-simpl output for this vs. unsafeInterleaveIO
