00:00:14 <sorear> \ x -> FOO  (where FOO does not mention x)  ===>  const FOO
00:00:39 <sorear> \ x -> FOO BAR (FOO, BAR arbitrary)  ===>  ap (\x -> FOO) (\x -> BAR)
00:01:01 <sorear> follow those two rules, and you can pl anything made from lambda and application.
00:01:16 <plediii> what is ap?
00:01:31 <sorear> ap f g x = (f x) (g x)
00:01:45 <sorear> it's the S combinator
00:02:20 <plediii> hmm, that seems simple enough, but it's not in the default scope
00:02:27 <sorear> import Monad
00:02:52 <sorear> ap is actually overloaded, what I showed was its meaning in the (->) r monad
00:03:06 <sorear> but you don't have to worry about that ;)
00:03:15 <sorear> you may need  to import Control.Monad.Instances
00:03:18 <plediii> yea, you're going over my head :)
00:04:12 <plediii> I'm just following some tutorial right now, and he lays out some exercises to pl.
00:04:49 <dmwit> flip is also handy for pl'ing things.
00:05:10 <sorear> they are useful for optimization
00:06:18 <plediii> I think the technique is really awesome, and is a primary reason I'm attracted to Haskell
00:07:16 <dolio> If you really like pl, you should learn J or something. :)
00:08:33 <plediii> well I don't want to overdo it.  I just appreciate that it's there, kind of like CL macros.
00:08:54 <plediii> There are many other reasons I like Haskell too.
00:09:09 <dolio> :) Haskell makes it too easy to wuss out and use named arguments.
00:09:57 <sorear> named args are NICE
00:10:07 <sorear> i come from an unlambda background
00:10:20 <sorear> my productivity became MUCH higher with named args
00:10:33 <plediii> wow, unlambda
00:10:46 <sorear> never got much done :)
00:11:00 <plediii> how can you start with unlambda!
00:11:09 <int-e> unlambda is cute
00:11:21 <plediii> s/!/!?!/
00:11:22 <sorear> I started with C, aboiut 8 yrs ago.
00:11:46 <sorear> Unlambda was merely the language that immediately preceded Haskell.
00:12:39 <DRMacIver> Morning
00:13:52 <tibbe> morning
00:14:24 <sorear> morning, really
00:14:35 <sorear> Local time for sorear is 12:13 am :)
00:15:13 <tibbe> @localtime tibell
00:15:15 <tibbe> @localtime tibbe
00:15:22 <sorear> nice try :(
00:15:27 <tibbe> lambdabot is still sleeping
00:15:33 <sorear> *** lambdabot (n=lambdabo@manzano.cse.unsw.EDU.AU) has quit: Read error: 110
00:15:33 <sorear>     (Connection timed out)                                                [22:36]
00:15:38 <sorear> no, off
00:19:27 <sorear> night all.
00:26:36 * tibbe thinks the current regex group implementation in base is a bit akward
00:32:25 <tibbe> what's the most portable way of setting language extensions in a file, like MPTC
00:37:15 <dolio> Theoretically it's {-# LANGUAGE ... #-} I think.
00:37:24 <tibbe> dolio, does it work with GHC?
00:37:50 <dolio> Yeah, I'm looking at the docs for it.
00:38:29 <dolio> I don't know how many others it works with, but I think it's the direction things are moving in.
00:42:40 <tibbe> dolio, ok, could you link the docs?
00:43:08 <dolio> http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#language-pragma
00:43:18 <tibbe> thanks
00:43:22 <dolio> No problem.
00:52:07 <nbarterd> in ghci, can I cast with :: ?
00:52:25 <nbarterd> *Main> testfunc :: Integer
00:52:27 <nbarterd> <interactive>:1:0: Not in scope: `testfunc'
00:52:49 <nbarterd> or cast any other way, other than let func = def ?
00:53:05 <sjanssen> '::' doesn't exactly mean cast
00:53:22 <nbarterd> what does it mean? google on punctuation isn't very helpful ;)
00:53:33 <sjanssen> but yes, it may make a value with a general type into a more specific one
00:53:34 <jcreigh> foo :: Int declares that "foo" is of type Int
00:54:02 <sjanssen> nbarterd: from that ghci session, it seems that you have not defined testfunc?
00:54:24 <nbarterd> yeah, in a normal program the :: can come first...
00:54:38 <sjanssen> ah yes
00:54:49 <sjanssen> ghci's top level isn't the same as the top level of the file
00:55:02 <sjanssen> you can't type declarations into it, only expressions
00:55:15 <nbarterd> ok
00:58:30 <tibbe> @paste
00:59:56 <tibbe> where's lambda bot?
01:02:01 <therp> last seen evaluating omega.
01:02:58 <nbarterd> I think I just got a haskell job :)
01:03:24 <DRMacIver> Ooh
01:03:27 <DRMacIver> Where?
01:03:32 <nbarterd> nyc.
01:03:50 <DRMacIver> Doing what sort of thing?
01:04:20 <nbarterd> building web apps for a proprietary trading team.
01:05:08 <hpaste>  tibbe pasted "Odd regex matching behaviour" at http://hpaste.org/1381
01:05:28 <nbarterd> so I'll probably start lurking more on #haskell in six weeks or so
01:05:33 <tibbe> could someone please have a look at my paste and help me figure out why it's not working?
01:08:02 <tibbe> ah, now I see it, never mind
01:17:26 <pete`> hello, i'm trying to install HaXml 1.13.2. however, make aborts with an error saying "mv: rename a.out to DtdToHaskell: No such file or directory". i'm using ghc 6.6. any ideas?
01:18:42 <cfraz89> hi
01:18:50 <cfraz89> what is the best way to debug a haskell program?
01:19:35 <cfraz89> i am getting an empty list somewhere, but have no idea how to find out
01:22:42 <dcoutts> cfraz89: avoid uses of head ?
01:23:19 <dcoutts> cfraz89: use the interactive interpreter to test small cases to help you narrow down the problem
01:23:27 <dcoutts> those are two usual strategies
01:23:52 <cfraz89> dcoutts: thanks :)
01:24:04 <dcoutts> pete`: and you're using Cabal-1.1.6 I suppose? (use 'ghc-pkg list' to find out)
01:24:47 <pete`> dcoutss: yes.
01:25:23 <Heffalump> it's a real shame you can't get a stack trace from a Haskell program
01:28:12 <dcoutts> pete`: you're using cabal to do the install right, not the makefile ?
01:28:52 <pete`> dcoutts: i was using the makefile. right now trying with cabal ... still compiles.
01:28:55 <cfraz89> dcoutts: interpreter works pretty well :) thanks
01:29:49 <dcoutts> pete`: I think the makefile was written before ghc-6.6 and people use cabal now whenever possible
01:30:34 * Heffalump wonders how people whose projects are a mix of languages, each with their own "one true build system" are supposed to work
01:30:59 <dcoutts> Heffalump: they're generally stuffed
01:31:18 <dcoutts> each system except maybe C want you to use it's thing to do the final linking
01:31:26 <dcoutts> eg C++ compilers
01:31:58 <Heffalump> you can generally make partial objects, though
01:33:12 <pete`> ok, thank you dcoutts. btw: as far as i've seen there are several libraries for processing xml in haskell. is there any libraries being considered as "standard/stable/the-one-to-use"?
01:33:20 <cfraz89> why does this give parse error?
01:33:21 <cfraz89> substitute r:rs command     = [Forward] ++ substitute rs command
01:33:30 <cfraz89> where Forward is defined
01:33:31 <Heffalump> cfraz89: you need brackets around r:rs
01:33:37 <cfraz89> ah, ok thanks
01:34:03 <Heffalump> remember that space binds tighter than any other operator except record update.
01:34:56 <fuzan> if anyone would like to take a look at http://hpaste.org/1382 , i'm having issues with a happs tutorial
01:35:03 <cfraz89> ok
01:36:18 <dcoutts> pete`: I use the version of Haxml you just built.
01:36:42 <fuzan> pete`: from what i've seen, ther'es haxml, and hsxml
01:37:11 <pete`> what about hxt?
01:37:48 <fuzan> haven't heard of it :)
01:38:07 <pete`> i'm just looking at http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hxt-7.1
01:42:43 <pete`> dcoutts: it (haxml) compiled and installed correctly using cabal. thanks for the hint.
01:43:09 <dcoutts> np
01:47:05 <fuzan> fuzan: hi
01:47:10 <fuzan> hm.
01:52:22 <fuzan> this happs example is making me want to /wrists.
01:52:36 <tibbe> how can I stop haddock from making my $ into a link to ($), it's not listed among the special characters
01:55:13 <joelr1> morning!
02:09:50 <tibbe> joelr1, morning!
02:10:12 <tibbe> it seems like every time I want to do something interesting it requires language extensions like MPTC or FDs
02:10:30 <joelr1> usually :)
02:14:47 <tibbe> how many compilers/interpreters support MPTC and FDs?
02:28:00 <vali> hello. what are the .hi-files that GHC generates?
02:28:47 <Heffalump> they give information about the interface of a module
02:29:03 <Heffalump> they change less frequently than the .o files, so they can help reduce recompilations
02:29:20 <vali> oh. thank you
02:29:31 <dcoutts> they also help with cross-module inlining
02:29:36 <dcoutts> very useful :-)
02:29:43 <Heffalump> the easy answer is that you need to keep them with the .o files, generally.
02:29:48 <vali> sounds good
02:32:33 <tibbe> what do you guys think, is it worth to add non haskell 98 language features to a module to increase its ease of use?
02:32:43 <tibbe> but decrease its portability
02:33:47 <Heffalump> tibbe: I generally do.
02:34:20 <tibbe> ok
02:34:32 <tibbe> it will save the user alot of B.pack's
02:35:00 <tibbe> as I can provide both a String and a ByteString interface (i.e. both Map String String and Map ByteString ByteString)
02:35:02 <Heffalump> are the features you are using likely to be in Haskell prime?
02:35:47 <tibbe> MPTC and FDs
02:36:23 <tibbe> I'm using Text.Regex so perhaps I already depend on MPTC
02:37:05 <tibbe> but I'm wondering if introducing more polymorphism will make the implementation slower
02:37:25 <balodja> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs); in fibs 30
02:37:26 <tibbe> i.e. introducing a Context class with "lookup" and make instances for different maps and assoc lists
02:37:46 <balodja> hm-m-m, where is it... :)
02:38:13 <balodja> lambdabot has a day-off? :)
02:38:30 <Heffalump> perhaps she's busy making a new version of dons
02:41:57 <dcoutts> no no, dons is real! I've seen him
02:42:12 <Heffalump> oh, lambdabot wrote dcoutts too?
02:42:22 <dcoutts> he's not a mechanical turk
02:42:32 <opqdonut> you might be, tho
02:42:39 <dcoutts> mwahahahaha
02:48:00 <dcoutts> anyone want to correct this chap's misunderstanding (and close the bug)?
02:48:01 <dcoutts> http://hackage.haskell.org/trac/ghc/ticket/1276
02:49:50 <foxy-om> @karma+ Regina Spektor
02:51:11 <foxy-om> does he have to close the semi-closed handle to finalise the contents of the String return value?
02:51:28 <foxy-om> http://lambda-the-ultimate.org/node/2192
02:55:47 <dcoutts> if you close the handle before getting the whole string out then it'll just get cut off
02:57:01 <foxy-om> he's not passing a handle to getContents
02:57:34 <Heffalump> that's cos getContents uses stdin :-)
02:57:41 <Heffalump> what's the problem with his ByteString version?
02:58:01 <Heffalump> or rather, why does it produce that error rather than hanging?
02:59:02 <dcoutts> Heffalump: probably hGetBufNonBlocking is borked on windows
03:00:03 <dcoutts> foxy-om: right, he's just confused. He should do: ./sum-file < blah.txt, not ./sum-file blah.txt
03:02:17 <foxy-om> dcoutts. does the apparatus that does does rewrite rules have access to the type checker?
03:02:30 <dcoutts> foxy-om: not exactly
03:02:31 <foxy-om> s/does does/does/
03:02:39 <Heffalump> I seem not to be able to edit tickets.
03:02:42 <Heffalump> But I only just registered.
03:03:08 <Heffalump> and ISTR there were some posts about only certain people being allowed to edit tickets cos of spam
03:03:10 <dcoutts> foxy-om: it works on fully typed core code so it knows the types of everything an must produce fully typed code too
03:03:26 <dcoutts> Heffalump: aye, ask JaffaCake
03:03:56 <Heffalump> anyway, I would close the bug, but I can't.
03:04:12 * dcoutts will do it
03:07:02 <dcoutts> Heffalump: oh, I'm locked out too :-(
03:07:43 <Mitar> how can I make a global IOref?
03:07:57 <dcoutts> you shouldn't
03:08:09 <dcoutts> you can only do so with a nasty hack
03:08:43 <dcoutts> {-# NOINLINE foo #-}
03:08:44 <dcoutts> foo = unsafePerformIO (newIORef blah)
03:09:04 <dcoutts> Mitar: do you see why it is unsafe?
03:09:26 <Mitar> hmm, no :-)
03:09:34 <Mitar> can you please explain?
03:09:40 <dcoutts> foo is a pure value right?
03:09:45 <Mitar> yes
03:10:00 <dcoutts> so I can duplicate or inline it
03:10:23 <dcoutts> but that'll really break your program
03:10:38 <dcoutts> since you'd get different mutable vars, not one shared one
03:10:50 <ClaudiusMaximus> dcoutts: i did that, it crashed a lot, so i found another way (namely having a single entry point to my code, that creates the IORef and passes it to the rest of the code...)
03:11:22 <dcoutts> Mitar: the NOINLINE is to try to convince the compiler to please not do that, it'll probably work in practise but semantically it's not sound
03:11:34 <Mitar> yes, i would like to avoid that i have to pass this ioref around all the time
03:11:36 <dcoutts> if at all possible avoid doing this
03:11:44 <Lemmih> ClaudiusMaximus: It should only crash if you mess up the types.
03:11:58 <dcoutts> Mitar: there are techniques for that, eg state monads
03:12:01 <TSC> Could you put the IORef in a reader monad?
03:12:17 <dcoutts> ClaudiusMaximus: right
03:12:21 <dcoutts> TSC: yep
03:12:28 <ClaudiusMaximus> Lemmih: well, i've got working code without unsafePerformIO now, so i'm happy
03:17:28 <Mitar> but why would I use IOref (I wanted to use it beacuse I would like to be able to change some values according to IO) if I can use state monad and change the state?
03:18:46 <int-e> Mitar: having multiple threads come to mind. although I suspect you want an MVar (or STM) then in most cases.
03:19:11 * ClaudiusMaximus uses IORef to maintain state between callbacks from the program i'm embedded into
03:21:15 <Mitar> ok, maybe I could ask a broader question ... I am making a renderer and I have some size of the output window, so currently I make a list of all pixel locations and then map this list to list of colors and draw that on the window
03:21:36 <Mitar> there are probably two problems with this: the list of pixels is not really the best data structure
03:22:27 <Mitar> every time I render the window I recalculate the list of pixel locations - it would be best if I would recalculate it only when the window size changes
03:24:25 <dcoutts> Mitar: ok, but this only needs a local IORef
03:24:36 <dcoutts> and yeah, probably come array rather than a list
03:24:40 <dcoutts> come/some
03:25:04 <Mitar> no, because the pixel locations are generated in other callback then drawing
03:25:34 <dcoutts> Mitar: I mean local to the contruction of the window, not local to the rendering callback
03:25:42 * dcoutts finds an example
03:27:47 <dcoutts> Mitar: http://haskell.org/~duncan/gtk2hs/ants/Visualiser.hs
03:27:56 <dcoutts> though I can probably find something smaller
03:28:09 <Mitar> and about arrays: i do not need to jump around the array (use indexes) just to traverse all pixel locations and map it to the color
03:29:32 <Mitar> ah, yes, I could define callbacks inside the main function
03:29:52 <Mitar> so that they will have access to the iorefs defined in main function
03:30:07 <Cheery> Does haskell have anything similar to lisp conditions?
03:30:23 <Cheery> ie. more precise way of handling errors
03:30:35 <dcoutts> Cheery: are lisp conditions
03:30:38 <dcoutts> exceptions ?
03:30:48 <dcoutts> are/what are
03:31:14 <dcoutts> Cheery: you can use exceptions but you can only catch them in IO code
03:31:23 <dcoutts> otherwise it'd make the language impure
03:31:24 <Cheery> conditions and restarts
03:31:58 <dcoutts> for control over errors in pure code you can use error monads and the like
03:31:59 <Cheery> http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html
03:33:08 <xerox> http://cgi.cse.unsw.edu.au/~dons/blog/2007/03/10#programmable-semicolons
03:33:17 <xerox> the error-handling described there is quite nice
03:35:42 <Cheery> lisp-style conditions and restarts would enable you to define ways to recover from the failure inside there where it happens
03:36:17 <dcoutts> I'm sure one can make a monad to do that
03:36:38 <Cheery> me too
03:36:42 <dcoutts> it'd probably need to be a continuation monad
03:41:49 <dcoutts> Heffalump: Igloo is fixing accounts, tell him your username.
03:42:02 <dcoutts> Heffalump: on the ghc trac I mean.
03:52:51 <campusblo> hi folks
03:53:03 <campusblo> you guys never leave i see
03:53:14 <campusblo> ok heres the problem. i have to create a highlighter
03:53:23 <campusblo> for code
03:53:35 <campusblo> i have the list of keywords already
03:54:16 <campusblo> in the form of keyword = [ list of keywords ]
03:54:45 <campusblo> how do i test a word to find out which keyword it falls under
03:54:48 <campusblo> ?
03:54:55 <campusblo> thats my current problem to solve
03:55:27 <Botje> "elem"
03:55:34 <campusblo> ok
03:55:36 <opqdonut> > elem "lol" ["lol", "foo"]
03:55:44 <opqdonut> ah, yes lambdabot is down
03:55:49 <opqdonut> yes, elem is what you want
03:55:54 <campusblo> right
03:55:59 <campusblo> i thought about elem
03:56:05 <campusblo> and i think thats the right track
03:56:11 <opqdonut> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#18
03:56:28 <campusblo> but its a a bunch of keywords with lists
03:56:32 <campusblo> so i have to provide a lookup
03:57:04 <campusblo> so its like number = [1,2,..0]
03:57:35 <campusblo> letter = [ a,b,c...z]
03:57:51 <campusblo> if someone types anything and say i had to test if it was a number or letter
03:57:56 <opqdonut> something like: filter (elem k) listoftheselists
03:58:40 <campusblo> ok but what i really want to do is design a function which will tell me if its a number or letter
03:59:03 <opqdonut> you'll probably want to use a parser library like happy or parsec
03:59:17 <Botje> campusblo: so use something like [(String,[String])]
03:59:23 <campusblo> these come with the prelude?
03:59:40 <opqdonut> no
04:00:03 <Saizan> i think you should use something like [(String,String -> Bool)] or [(String,Char -> Bool]
04:00:46 <campusblo> botje i already have the list so if im gong to use that id have to have a function to create it from the list that i have
04:00:56 <campusblo> how would i do that?
04:01:20 <Saizan> so [("number",isDigit),("letter",isAlpha)...]
04:01:27 <campusblo> saizan i see what you are saying but how would i go from my list to that?
04:01:34 <campusblo> right
04:01:34 <hpaste>  tibbe pasted "type error" at http://hpaste.org/1383
04:01:37 <campusblo> i got it
04:02:00 <tibbe_> it's probably a quite simple type error, could someone have a look?
04:02:24 <campusblo> saizan what would isDigit look like?
04:02:50 <campusblo> i went that route initially and wrote an isDigit etc but then i realized that it might be easier to just do lookups
04:02:51 <Saizan> well, you can define isDigit x = elem x "0123456789", but it comes with Data.Char too
04:03:23 <campusblo> i was thinking of a more general function
04:03:39 <campusblo> like whichType
04:03:57 <campusblo> whichType x
04:04:05 <dmhouse> tibbe_: fail is a function String -> m a
04:04:09 <campusblo> which would return something like
04:04:09 <dmhouse> ?type fail
04:04:11 <campusblo> number
04:04:14 <campusblo> letter
04:04:20 <dmhouse> tibbe_: you need to pass it an error message.
04:04:37 <tibbe_> dmead, oh, I probably meant mzero then
04:04:40 <tibbe_> or something
04:04:44 <tibbe_> I want a Nothing
04:04:52 <tibbe_> or whatever map fails with
04:05:00 <dmhouse> Yeah, well, for Maybe, fail _ = Nothing
04:05:05 <tibbe_> if it succeeds and returns a String I want to pack it
04:05:27 <dmhouse> The best way would to do fmap B.pack $ Map.lookup ...
04:05:35 <dmhouse> > fmap (+1) (Just 4)
04:05:44 <tibbe_> what does fmap do?
04:05:47 <tibbe_> :t fmap
04:05:51 <int-e> tibbe_: if you subscribe to the 'fail is evil' school of thought, you want mzero. otherwise, just give fail an error message
04:05:51 <dmhouse> Lambdabot's dead.
04:06:02 <dmhouse> int-e: I think he wants fmap anyway
04:06:04 <Saizan> whichType x = listToMaybe . map fst . filter (\(n,f) -> f x) $ [("number",isDigit),("letter",isAlpha)...]
04:06:16 <dmhouse> Prelude> fmap (+1) (Just 4)
04:06:16 <dmhouse> Just 5
04:06:16 <dmhouse> Prelude> fmap (+1) Nothing
04:06:16 <dmhouse> Nothing
04:06:27 <tibbe_> int-e, I do subscribe to that school
04:06:34 <int-e> @type Data.Map.lookup
04:06:43 <int-e> ah.
04:06:43 <tibbe_> but fmap require Functor, are all Monads Functors?
04:06:49 <dmhouse> tibbe_: fmap is essentially the same as liftM.
04:06:52 <int-e> tibbe_: liftM then
04:06:57 <campusblo> saizan could that function be made more general?
04:07:10 <int-e> dmhouse: good point
04:07:12 <dmhouse> tibbe_: yes, all monads are functors, and all instances of Monad _should_ (but aren't required to) be an instance of Functor too.
04:07:42 <tibbe_> ok
04:07:44 <dmhouse> tibbe_: I just prefer fmap over liftM because 1) It's a character shorter 2) You don't have to import Control.Monad
04:07:53 <Saizan> campusblo, in what direction? the list shouldn't probably be defined there
04:08:29 <tibbe_> I'm not sure I like the way Map's lookup works
04:08:39 <tibbe_> I would have prefered it to be MonadZero or something
04:08:52 <dmhouse> tibbe_: yeah, well, there's no MonadZero class in the standard libs.
04:09:59 <campusblo> sorry got cut off
04:10:17 <campusblo> i mean instead of writing a test for each digit letter etc
04:10:37 <campusblo> i just enter the character and it tells me what it is
04:10:51 <campusblo> so if i enter 5
04:11:02 <campusblo> it should return "number"
04:11:08 <int-e> > generalCategory 'a'
04:11:18 <dmhouse> Lambdabot's dead.
04:11:20 <opqdonut> int-e: lambdabot is down
04:11:22 <int-e> heh, I did it again.
04:11:44 <int-e> would result in  LowercaseLetter
04:11:58 <campusblo> right thats what i need
04:12:20 <dmhouse> campusblo: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Char.html#t%3AGeneralCategory and http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Char.html#v%3AgeneralCategory
04:12:27 * dmhouse never knew of that function
04:14:05 <_frederik_> is there an example of e.g. how to open a 'ghci' prompt from within a normal program?
04:14:15 <_frederik_> someone told me this was now possible
04:14:18 <dmhouse> _frederik_: what do you want to do with said prompt?
04:14:35 <_frederik_> enter commands
04:14:45 <dmhouse> Well, try System.Process.runInteractiveCommand.
04:14:52 <_frederik_> hehe no silly
04:15:06 <dmhouse> ?
04:15:07 <_frederik_> i don't need ghci to use a shell
04:15:17 <dcoutts> ghci is now just a program that uses the GHC API, you can use the GHC API too, but be warned that it's not totally trivial
04:15:25 <dmhouse> But if you're going to be messing around with GHC, you might want to investigate the GHC API.
04:15:49 <_frederik_> dcoutts: what makes it non-trivial?
04:16:02 <dmhouse> _frederik_: I don't understand... runInteractiveCommand is for running commands and passing data backward and forward.
04:16:17 <dcoutts> _frederik_: look at the implementation of GHCi itself and you'll see what I mean
04:16:33 <dcoutts> it's not a single function call to a feature provided by the GHC API
04:16:36 <_frederik_> dmhouse: i mean commands like "let x = ..."
04:16:46 <_frederik_> dmhouse: perhaps there is a better word
04:16:58 <dmhouse> _frederik_: yes, that's precisely what runInteractiveCommand is for. You get a handle to GHCi's stdin.
04:17:02 <_frederik_> dcoutts: is there a minimal example?
04:17:17 <_frederik_> dmhouse: i see what you're saying
04:17:25 <dcoutts> _frederik_: there's some stuff about it on the GHC developers wiki
04:17:57 <_frederik_> i want to do something like 'octave' but with my own library
04:18:06 <_frederik_> so i need to start ghci with everything loaded
04:19:16 <_frederik_> i don't think simon marlow wants to support an -e option to ghci - as in 'ghci -e ":m ..."'
04:19:22 <hpaste>  dmhouse pasted "runInteractiveCommand example" at http://hpaste.org/1384
04:19:31 <dmhouse> _frederik_: try that.
04:21:07 <_frederik_> dmhouse: i don't want to do it that way, it would be too hacky. it would mean detecting the prompt in the output, for instance
04:22:30 <balodja> how to develop lambdabot-plugins in a short-hand? without rebuilding the whole bot
04:23:05 <dmhouse> _frederik_: I think you probably want the GHC API.
04:23:11 <_frederik_> this is cool: http://haskell.org/haskellwiki/GHC/As_a_library
04:23:18 <dmhouse> Yes, that's the GHC API.
04:23:30 <_frederik_> very helpful
04:23:37 <dmhouse> Another disadvantage with the GHC API is that you can't dynamically link it in, meaning the size of your executable will be at least the size of GHC.
04:24:23 <_frederik_> hmm
04:28:22 <dcoutts> though there's a SoC project to do dynamic libs on linux this summer
04:28:43 <dmhouse> Oh, cool. I'm yet to read through the accepted SoC projects.
04:28:58 <dmhouse> glguy: ping
04:29:09 <eumenides> if you do, say, main :: IO Int, where does that int go when you compile it (in ghci it just prints it)?
04:29:47 <dcoutts> eumenides: it's discarded
04:30:13 <_frederik_> how many people here use linux?
04:30:25 <dcoutts> _frederik_: I'd guess it's the majority
04:30:37 <dmhouse> eumenides: it gets packaged up and saved up for a rainy day, when Ints might be in short supply.
04:31:20 <Cheery> _frederik_: like there would be some better choice :-)
04:32:06 <_frederik_> Cheery: well, i use it but it doesn't seem very well supported by ghc
04:32:18 <dcoutts> dmhouse: good thing too since there's a shortage of Ints
04:32:36 <dmhouse> _frederik_: what do you mean? I can't say I've ever felt that; if anything, Win32 support is lacking.
04:32:38 <Cheery> are you kidding?
04:33:22 <dcoutts> _frederik_: that's because no developers want to work on windows, so it's a second class citizen when it comes to support
04:33:28 <_frederik_> dmhouse: do you use both platforms?
04:34:01 <dcoutts> I develop on both and can tell you how painful it is on win32
04:34:04 <dmhouse> _frederik_: no, I use just Linux, but that comment was based on other people's comments.
04:34:14 <dmhouse> ndm develops on Win32.
04:34:39 <dcoutts> I think he's the only one who does so out of choice
04:35:05 <Cheery> I switched to linux half a year ago, and will never switch to anything labelled 'microsoft os' again
04:35:46 <_frederik_> hmm
04:35:54 <Cheery> and it seems mac would be similar stuff, I guess only good choice is linux this far
04:36:57 <_frederik_> maybe it's just philosophy - the ghc developers seem to have a non-standard attitude towards environment variables, use of make, use of scripts, etc.
04:37:13 <dcoutts> how so?
04:37:26 <Cheery> ghc --make ...   :-P
04:37:31 <Cheery> who needs makefiles?
04:37:31 <_frederik_> for instance, that it is not possible to use runghc with a file that doesn't end in .hs
04:38:01 <_frederik_> Cheery: people who use some auto-generated .hs files
04:38:07 <_frederik_> Cheery: such as myself
04:38:20 <dmhouse> _frederik_: now that's just not true.
04:38:49 <_frederik_> dmhouse: i'm listening
04:39:17 <dmhouse> _frederik_: hrm, maybe so. It works without any extension.
04:39:31 <_frederik_> dmhouse: what works?
04:39:49 <dmhouse> _frederik_: runghc on a file with no extension.
04:40:30 <dmhouse> Yes, it would appear to bork on any other extension.
04:41:24 <_frederik_> i don't understand
04:41:42 <dmhouse> <_frederik_> for instance, that it is not possible to use runghc with a file that doesn't end in .hs
04:42:15 <dmhouse> That's not totally true; you can use runghc on a file with no extension, or with an extension of .lhs, or .hs, but nothing else.
04:42:37 <_frederik_> hmm, files with no extension don't work for me
04:42:47 <_frederik_> i thought this bug was still open: http://hackage.haskell.org/trac/ghc/ticket/1232
04:43:05 <_frederik_> anyway, i made the request over a year ago
04:44:08 <_frederik_> it seems to me that the technology of ghc is not being developed to its full potential
04:44:17 <_frederik_> because of little issues like this
04:44:55 <_frederik_> but people seem to think that it is not a unix/windows problem
04:44:57 <Cheery> well, that's true
04:45:02 <_frederik_> and i am willing to be convinced
04:45:07 <dcoutts> _frederik_: there was a recent discussion of making scrips with #!/usr/bin/env runghc etc
04:45:21 <dcoutts> _frederik_: problem there is that #!... isn't valid outside of a .lhs script
04:45:35 <dcoutts> so you'd need to call the script .lhs
04:46:21 <dcoutts> unless we just hack it and say that the first line can be #.. and it gets ignored
04:46:31 <dcoutts> but really that should be a language change
04:47:21 <Cheery> not only that the software is not yet finished, but there seems being lots of stuff yet completely undiscovered
04:47:41 <dcoutts> software is never finished
04:47:53 <Cheery> I guess haskell will never finish really, it is technically impossible
04:48:02 <_frederik_> dcoutts: oh dear, i disagree strongly that it should be a language change
04:48:35 <_frederik_> dcoutts: the haskell bit is what follows the #! line
04:48:45 <dcoutts> right, but that needs a change in the spec
04:49:00 <dcoutts> _frederik_: otherwise what happens when hugs gets given one of these '.hs' files
04:49:12 <dcoutts> it's going to reject it as syntactically invalid
04:49:16 <Cheery> hm. haskell for shell scripting...
04:49:23 <_frederik_> dcoutts: then warn people not to use hugs with it
04:49:28 <int-e> well, the Haskell 98 spec isn't exactly clear on how haskell code is mapped to files
04:49:33 <dcoutts> _frederik_: you're breaking portability
04:49:38 <_frederik_> dcoutts: surely it's better to have something which half-works than which doesn't work at all!
04:49:38 <Cheery> I think it'd be useful to have it's own parser variation for that
04:50:45 <dcoutts> _frederik_: I'm not sure I really see the problem, people call perl scripts .pl, python scripts .py, shell scripts .sh etc etc
04:50:55 <int-e> so what _frederik_ wants is in line with the report (I think) but it breaks the conventions of several implementations
04:51:09 <_frederik_> dcoutts: that's a bad practice, which you are free to follow, but i do not care to follow it
04:51:19 <dcoutts> right, so you'd want agreement amongst the implementations
04:51:23 <hpaste>  dmhouse pasted "(no title)" at http://hpaste.org/1385
04:51:29 <dmhouse> Err, ignore that paste.
04:52:10 <_frederik_> dcoutts: i don't care to couple interface and implementation
04:52:16 <dcoutts> _frederik_: you can make a script that shaves off the first line and passes the rest to runghc, then you can use #!/blah
04:52:31 <dcoutts> until the Haskell impls agree to ignore initial #! lines
04:52:51 <_frederik_> dcoutts: yes, that would be extremely easy to do. but i would like such a script to be included in ghc, so that i can distribute code which depends only on ghc
04:53:23 <dcoutts> right, so you can't do that 'til people agree that it's a sensible thing to do
04:53:26 <dcoutts> it's not just a ghc issue
04:53:27 <int-e> _frederik_: it's called runghc
04:53:36 <_frederik_> int-e: what?
04:54:06 <_frederik_> http://hackage.haskell.org/trac/ghc/ticket/1232
04:54:37 <int-e> runghc ignores a first line that contains #! /usr/bin/env runghc   for me.
04:54:47 <int-e> in a .hs file
04:54:57 <_frederik_> yes, that's why i don't understand why people are talking about the #! first line
04:55:10 <_frederik_> my grip is that it requires a .hs or .lhs extension
04:55:14 <_frederik_> for absolutely no reason at all
04:55:24 <_frederik_> gripe*
04:56:37 <int-e> no, the reason is that then you wouldn't know whether to treat it as literal haskell or not, and obviously people have different opinions about the default
04:57:13 <_frederik_> ah, well that is different from being of the opinion that there should be no default and that extensionless files shouldn't be supported
04:57:41 <Cheery> lol
04:58:18 <dcoutts> _frederik_: send a patch, it seems trivial to fix
04:58:44 <Igloo> What is trivial to fix?
04:58:58 <dcoutts> if the file is .lhs treat it as .lhs if it's anything else treat it as .hs
04:59:16 <Cheery> the thing that you could define the type of file as the parameter
04:59:19 <dcoutts> of course it's not portable to other implmentations that reject #! lines
04:59:40 <Igloo> It's trivial to do, yes, but it's not obvious it's the right thing to do
04:59:58 <eumenides> why is unsafeSTToIO unsafe?
05:00:19 <dcoutts> Igloo: so long as Haskell' says to ignore initial # lines it seems ok
05:00:23 <Cheery> @hoogle unsafeSTToIO
05:00:31 <dmhouse> Lambdabot's down.
05:00:52 <dcoutts> Igloo: sure, at the moment it's going to break impls, but ghc already does that by allowing initial # lines
05:00:59 <Igloo> dcoutts: But it doesn't, does it?
05:01:00 <_frederik_> i don't see why Haskell' is necessary. if a file is being interpreted via the #! mechanism by runghc, then runghc should consider everything following the initial line to be the "real file"
05:01:12 <_frederik_> for the purposes of the spec
05:01:14 <dcoutts> Igloo: oh, I thought it did, someone said it did
05:01:49 <Cheery> why it's not in topic that lambdabot is down?
05:01:55 <Cheery> :(
05:01:56 <Igloo> _frederik_: runghc doesn't know that it is being run via the #! mechanism
05:02:42 <_frederik_> Igloo: it can assume so, if the file starts with #!
05:03:13 <dcoutts> Igloo: in http://hackage.haskell.org/trac/ghc/ticket/1232 JaffaCake says '#! in .hs files is a GHC extension.'
05:03:49 <Igloo> dcoutts: I meant, Haskell' doesn't say to ignore initial # lines does it?
05:04:07 <dcoutts> Igloo: no it doesn't, yet.
05:04:27 <dcoutts> but Haskell' is all about standardising existing practise
05:04:32 <dcoutts> so suggest it
05:04:34 <dcoutts> hia ndm
05:04:52 <ndm> hi dcoutts
05:05:01 <Igloo> OK, so if it is agreed that Haskell' will say that then runghc treating no-prefix as .hs seems reasonable to me
05:05:11 <Igloo> But it needs to be agreed first
05:05:27 <dcoutts> Igloo: _frederik_ wants not just no-prefix but any prefix other than .lhs
05:05:30 <ndm> Igloo: is the .hs and .lhs extension actually in Haskell?
05:05:48 <ndm> dcoutts: then GHC can't compile .c files properly
05:06:05 <_frederik_> dcoutts: suffix
05:06:07 <dcoutts> ndm: it's only for runghc
05:06:17 <dcoutts> _frederik_: erm yeah, suffix :-)
05:06:18 <Igloo> ndm: By "as .hs" I mean "as non-literate source"
05:06:52 <_frederik_> Igloo: i have sent a reply to glasgow-haskell-bugs
05:07:04 <dcoutts> _frederik_ want to call scripts dothing.flibbet and have it work
05:07:27 <_frederik_> dcoutts: that's really not as important to me than no-suffix
05:07:41 <dcoutts> ah ok
05:07:56 <dcoutts> I thought someone said no-extension worked now
05:07:59 <Igloo> Treating unknown-suffix the same as no-suffix seems reasonable anyway
05:08:25 <_frederik_> Igloo: well, hmm. that could lead to compatibility problems if you decide to support additional suffixes
05:08:28 <ndm> Igloo: i disagree, does GHC compile cpp files? with .cxx extension?
05:08:55 <_frederik_> sorry i have to go now, thanks everyone for the discussion
05:08:59 <_frederik_> i'll check back later
05:09:22 <Igloo> I only meant for runghc
05:09:30 <dcoutts> ndm: for ghc in general it's a different matter
05:09:54 <ndm> dcoutts: ah, that i object to less :)
05:10:02 <dcoutts> 'runghc -foo -bar blub.cxx' seems reasonably obvious
05:10:14 <ndm> although having ghc and runghc do different things is always nasty
05:10:42 <dcoutts> they already do, args after the first file get passed as args to the program
05:11:10 <tibbe_> what's the performance cost of changing a parameter from say "Map ByteString ByteString" to "Context c => c" where "Map ByteString ByteString" is an instance of the type class?
05:11:37 <dcoutts> tibbe_: depends on the methods in that class and how and where you use them.
05:11:50 <dcoutts> tibbe_: see my recent rant on that topic
05:12:02 <dcoutts> I think I posted it to haskell-cafe
05:12:04 <ndm> tibbe_: if teh performance cost is too high, complain - better code first
05:12:17 * ndm notes that in Yhc -O11 the performance cost is 0
05:12:25 <dcoutts> ndm: I'm not sure complaining will really help
05:12:40 <ndm> dcoutts: if i beat them in performance, that will probably "motivate" them :-)
05:13:08 <dcoutts> ndm: either the code needs to be fully expanded template style (code bloat) or the dictionary needs to be passed in (or some other dynamic switching)
05:13:33 <tibbe_> dcoutts, on the ML?
05:13:41 <tibbe_> dcoutts, oh, n/m then
05:13:42 <dcoutts> parametrising like that is not free
05:13:54 <ndm> dcoutts: why do you say code bloat? Mark Jones shows it reduces the code size overall
05:14:00 <dcoutts> tibbe_: I suggested a method where it's cheap
05:14:13 <ndm> dcoutts: my experiments expanding everything agree - its 20% to 95% code volume reduction
05:14:16 <tibbe_> dcoutts, ok, I'll look it up
05:14:24 <ndm> i.e. your code can become 20 times smaller!
05:14:53 <dcoutts> ndm: well that depends on the ratio of code to method use in the thing your inlining
05:15:14 <dcoutts> if it uses lots and lots of dictionary stuff then getting rid of that by inlining can save space
05:15:18 <ndm> dcoutts: take a look at mark jones' paper, its pretty much always a win
05:15:28 <dcoutts> and if you don't use it too often and at lots of different types
05:15:41 <ndm> of course you can come up with fake instances where its not, but in real programs its fine
05:16:30 <tibbe_> dcoutts, what's your name on the ML? :)
05:16:41 <tibbe_> oh
05:16:50 <tibbe_> I mix you up with dons
05:17:02 <dcoutts> ndm: on average it might be ok but I'm sure there are plenty of examples where sharing a single dictionary impl is less space than several smaller expansions
05:17:31 <ndm> dcoutts: on average its a large code reduction, you can construct counterexamples of course
05:17:54 <ndm> it is all in the instances vs uses ratio, as you say
05:17:54 <tibbe_> what's the pro/cons of Strict vs Lazy ByteString? use the latter on big things?
05:17:55 <dcoutts> ndm: specialisation is going to be best in these examples, specialise on the used types and share those
05:19:12 <tibbe_> dcoutts, can't find the thread, do you remember the name?
05:19:15 <tibbe_> was it this month?
05:19:26 <campusblo> can i get an example of haskell parse code?
05:19:34 <dcoutts> ndm: but the point I was really making is that by putting class method uses under big mound of code requires that all that code be duplicated (either specialised or inlined and specialised), it's much better to keep the uses of methods nearer the surface
05:19:58 <dcoutts> ndm: where the cost of specialising those bits is cheap and the mound of code can be shared rather than duplicated
05:20:09 <campusblo> hi does anybody know where i can find code for a haskell parser?
05:20:15 <dmhouse> glguy: you around?
05:20:25 <dmhouse> campusblo: the module Language.Haskell in the standard libs.
05:20:36 <campusblo> ok thanks
05:20:37 <ndm> dcoutts: true, of course - hopefully one day performance will be considered solved, then we'll know the answers :)
05:20:40 <ndm> @seen sorear
05:20:49 <dcoutts> ndm: :-)
05:20:58 <dcoutts> ndm: lambdabot is down btw
05:21:06 <ndm> :(
05:21:15 <ndm> @karma- lambdabot
05:21:40 <dcoutts> tibbe_: Re: Re[2]: Proposal: ByteString based datagram communication (Ticket #1238 )
05:21:58 <tibbe_> dcoutts, thanks
05:22:00 <dcoutts> tibbe_: libraries mailing list Fri, 06 Apr 2007
05:22:12 <tibbe_> oh, on libraries, that's why I couldn't find
05:22:34 <dcoutts> sorry, I forgot which ml :-)
05:23:20 <vali> i am reading about `let' in YAHT. they make a function that gives you the roots of ax^2 + bx + c = 0. then it says "To rememdy this problem, Haskell allows for local bindings". i don't see what the problem was?
05:25:07 <dmhouse> vali: it says "Unfortunately, we duplicate expressions here." beforehand.
05:26:14 <dmhouse> vali: duplication of code is bad in general principle, because it means you have two bits of code which have to be manually kept in sync all the time, increasing the opportunity for error.
05:27:07 <vali> dmhouse: you mean it should say that they duplicate? because it doesn't say that anywhere in my document
05:27:35 <dmhouse> vali, which document have you got, where did you get it?
05:27:46 <Mitar> is it possible to use "where" in a do structure?
05:28:31 <Mitar> i am gettint "The last statement in a 'do' construct must be an expression" error
05:28:44 <ski> you probably want
05:28:46 <dmhouse> vali: huh, in the PDF I downloaded, that sentence also seems to be missing
05:29:02 <dmhouse> Well, "Unfortunately, we duplicate expressions here." was the missing sentence.
05:29:04 <ski> do x <- foo
05:29:07 <ski>    let y = bar x
05:29:09 <ski>    baz y
05:29:13 <ski> Mitar : ^
05:29:35 <vali> dmhouse: i got it from the link at Haskell that org that points to: http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf ... strange
05:29:44 <vali> that = .
05:29:47 <dcoutts> Mitar: you can use let as ski shows but not where inside a 'do' construct
05:29:48 <Mitar> http://hpaste.org/1386
05:30:13 <vali> dmhouse: if it says duplicate, i get it! thanks
05:30:25 <dmhouse> kowey: ping
05:30:33 <Mitar> but it would be much easier to read ...
05:30:36 <Mitar> look at this: http://hpaste.org/1386
05:30:39 <kowey> dmhouse: hey
05:30:48 <dcoutts> Mitar: change the indentation so the where isn't on the same column as the do
05:31:31 <dcoutts> Mitar: eg indent the do block a bit more
05:31:37 <dmhouse> kowey: page 27 of the YAHT PDF, after the code for roots, it says "To remedy this problem..." without stating what the problem is. In the Wikibook (non-PDF) version, the sentence "Unfortunately, we duplicate expressions here." is included, but it's not in the PDF.
05:31:42 <campusblo> hi where do i get the code for the prelude functions?
05:31:57 <dmhouse> campusblo: haskell.org/onlinereport
05:32:10 <campusblo> thanks
05:32:17 <dmhouse> campusblo: specifically http://haskell.org/onlinereport/prelude-index.html
05:32:31 <ski> dcoutts : hm .. i think i've had 'where' on same column as the 'do'-block pass fine ..
05:32:44 <dcoutts> ski: oh, hmm
05:32:46 <dcoutts> dunno
05:32:54 * dcoutts has to run for the bus
05:33:53 <Mitar> dcoutts, does not work ...
05:35:06 <dmhouse> Mitar: what's the type of swapBuffers?
05:36:04 <Mitar> Graphics.UI.GLUT.swapBuffers :: IO ()
05:36:27 <dmhouse> Mitar: and what's the error you're getting, precisely?
05:36:34 <dmhouse> Mitar: annotate the paste with it, if you would
05:36:53 <ndm> dcoutts is always running for a bus
05:36:55 <kowey> dmhouse, vali: thanks... it'll be fixed on the next wiki -> tex sync / feel free to submit a patch, though
05:37:16 <Mitar> http://hpaste.org/1386#a1
05:37:48 <dmhouse> Mitar: you just repasted the same code.
05:37:58 <Mitar> ehm, no, i have added a comment
05:38:09 <ski> Mitar : i see the problem
05:38:10 <dmhouse> Mitar: oh, no, sorry, I meant paste the entire error GHC gives you.
05:38:19 <dmhouse> (The rest of what it says is useful too :))
05:38:43 <ski> Mitar : the last 'where' is directly under 'VoxelColor', it must be indented at least one space to fall under that
05:38:46 <Mitar> http://hpaste.org/1386#a2
05:39:12 <Mitar> oh, true, ski, thanks
05:39:28 <Mitar> but the error message is really not helpful
05:40:31 <ski> hm, i got
05:40:32 <ski> bepa.hs:16: parse error on input `where'
05:40:45 <ski> mayhaps you have another error too ?
05:41:27 <Mitar> i fixed now indendation ... i "just" have to fix now types :-)
05:41:31 <Mitar> thanks ...
05:41:38 <ski> the error message you got usually (ymmv) is about ending a 'do'-block with a 'x <- foo' thing
05:41:50 <dmhouse> Mitar: to be honest, nested wheres aren't very common, why don't you just do a single where-block?
05:42:22 <dmhouse> Mitar: or perhaps too, I see that you couldn't use just a single one.
05:42:40 <dmhouse> Actually I'd be tempted to break out drawRay into its own function.
05:42:45 * ski uses nested 'where's not so seldomly
05:43:04 <Mitar> ski, i know that message is issued then, but in this case it was not helpful as the last sentence was (looking to be) expression
05:43:51 <Mitar> i use nested wheres to make code more readable - so that you know what goes together
05:43:54 <ski> (Mitar : .. it wasn't an expression ?)
05:44:00 * ski nods
05:44:21 <Mitar> swapBuffers is :-)
05:44:59 <hpaste>  dmhouse pasted "hpaste build errors" at http://hpaste.org/1387
05:46:06 <dmhouse> ?tell glguy I'm getting http://hpaste.org/1387 when I try to build hpaste (from darcs) with the latest (from darcs) HAppS. I also had to comment out the 'thefor = strAttr "for"' line in HPasteAdmin, why's that?
05:46:18 <dmhouse> Gah, silly broken Lambdabot.
05:46:25 <dmhouse> Cale: ping
05:55:40 <Saizan> dmhouse: the most 0.8.8 compliant source for hpaste is in hpaste-devel, and even that needs a correction
06:07:13 <Saizan> dmhouse: i can give you a patch if you want
06:07:19 <dmhouse> Saizan: that'd be good.
06:08:37 <Saizan> dcc send is fine?
06:09:18 <ndm> woohoo, Data.Derive can now guess the Eq instance!
06:09:20 <dmhouse> Saizan: dcc send is difficult, hpaste is fine :)
06:09:22 <ndm> Saizan: what is your real name?
06:09:36 <Saizan> Andrea Vezzosi
06:09:38 <ndm> Saizan: for the HCAR entry on Data.Derive
06:11:09 <hpaste>  Saizan annotated "hpaste build errors" with "patch for "http://www.scannedinavian.com/~eric/hpaste-devel"" at http://hpaste.org/1387#a1
06:11:17 <Saizan> HCAR?
06:11:44 <dmhouse> Saizan: thanks./
06:12:11 <ndm> Saizan: haskell communities and activities report
06:12:14 <ski> @docs Data.Derive
06:12:38 <Saizan> oh, should have guessed :)
06:13:26 <dmhouse> Saizan: I guess the middle chunk of that paste is optional? :)
06:13:44 <ndm> @where derive
06:13:51 <nomeata> Hi. I’m wondering: Is there a library or something that makes working with unicode data type-safe? I.E. makes sure that I don’t never output a [Char] before encoding it somehow (e.g. utf8)?
06:13:52 <ndm> ski: its unreleased, not part of teh standard libs
06:14:07 <ndm> lambdabot says: http://www.cs.york.ac.uk/
06:14:11 <ndm> lambdabot says: http://www.cs.york.ac.uk/~ndm/derive/
06:14:13 <Saizan> dmhouse, it alings all your GETs nicely! :)
06:14:56 <dmhouse> Saizan: hrm, my line with handleGetDiff on it looks like the following: ,h "/([0-9]+)/diff?"           GET    handleGetDiff
06:15:04 <dmhouse> No mention of re anywhere...
06:15:34 <Saizan> have you pulled from hpaste-devel?
06:16:05 <dmhouse> Oh, there's a separate repo; no, I didn't.
06:17:56 <Saizan> nomeata: http://twan.home.fmf.nl/compact-string/ may be what you need
06:19:18 <dmhouse> Saizan: "Not in scope: data constructor `Prefix'".
06:20:48 <Saizan> Prelude HAppS> :i Prefix
06:20:48 <Saizan> newtype Prefix a = Prefix a
06:20:48 <Saizan>         -- Defined in HAppS.Protocols.SimpleHTTP2
06:23:16 <dmhouse> Saizan: ah, got it. That seems to be gone again in the darcs version of HAppS.
06:23:30 <Saizan> again? gosh
06:25:07 <dmhouse> Saizan: thanks for your help. /me has to dash
06:26:54 <Mitar> when I use "writeIORef projectionRays rays" does this means rays is evaluated at that moment or is still lazy?
06:28:28 <ski> not forced
06:28:47 <Mitar> how could i force it?
06:29:10 <ski> do you need to ?
06:29:34 <Mitar> i do not know ... i would like that only once the rays are evaluated
06:29:54 <kpreid> it will be evaluated only once, just later
06:29:59 <Mitar> i map in display callback this list of rays to list of actions end execute them
06:30:09 <ski> when evaluated, it will in most implementations (all?) be cached
06:30:31 <Mitar> and i do this many times ... so I would like that it is not reevaluated
06:31:01 <Mitar> but how could i force it? just temporary, to see if this is the problem why it is slow ..
06:31:07 <kpreid> Mitar: it will be evaluated at most as many times as you do the writeIORef
06:31:20 <Mitar> ok, i do that only once ...
06:31:20 <ski> do you want to no reexecute the actions ?
06:31:23 <kpreid> so forcing it at that point makes no difference
06:31:49 <kpreid> in fact, forcing values *never* reduces the number of times something's evaluated
06:32:18 <Mitar> no?
06:32:45 <kpreid> yes, forcing just makes some *particular* value evaluated *sooner*
06:33:28 <kpreid> it won't have any effect on un-shared similar values, which are those which are responsible for multiple evaluation
06:37:49 <Mitar> are very long lists of actions inherintly slow? (for example mapM_ on a long list)
06:38:01 <ndm> dcoutts: for info, Matt (the guy who sits next to me) will have a TMR article by Monday
06:39:28 <campusblo> hi anybody know where i can get source code for a haskell parser?
06:39:32 <campusblo> i tried http://darcs.haskell.org/packages/haskell-src/Language/Haskell/Parser.hs
06:39:36 <campusblo> but no luck
06:40:20 <campusblo> i got a page not found error
06:41:59 <twanvl> http://darcs.haskell.org/packages/haskell-src/Language/Haskell/Parser.ly
06:42:23 <twanvl> The .hs file is generated using happy
06:45:16 <campusblo> thanks
06:45:23 <campusblo> what's happy?
06:45:36 <twanvl> ?where happy
06:45:50 * tibbe is happy!
06:45:57 * tibbe boings!
06:46:09 <twanvl> http://www.haskell.org/happy/
06:47:32 <campusblo> ok thanks
06:47:33 <campusblo> cool
06:49:56 <campusblo> so im told to use a stack to identify a comment
06:50:02 <campusblo> anybody know how to do this?
06:50:38 <campusblo> the \n should be assigned the end character
06:50:44 <DRMacIver> I presume what you want to do is push open comments onto the stack and pop them when you see a close comment.
06:50:53 <DRMacIver> As long as the stack is empty you're not inside a comment.
06:51:17 <campusblo> right i understand theoretically what you just said
06:51:21 <campusblo> how would i implement that
06:51:34 <campusblo> i would have to test for an empty stack right?
06:51:40 <DRMacIver> In general or specifically in Haskell?
06:51:45 <campusblo> in haskell
06:52:29 <DRMacIver> I'm not sure offhand how you'd maintain state for it I'm afraid.
06:52:47 * DRMacIver is far from a Haskell expert. :)
06:53:29 <campusblo> i have this module States where
06:53:29 <campusblo> data State = Default | HComment |MLComment | HString | HFloatPoint deriving (Eq,Show)
06:54:54 <campusblo> does that help? i know its supposed to but quite frankly i dont know what to do with it
06:55:20 <DRMacIver> Honestly, I'm the wrong person to ask. I don't know either. :)
06:55:32 <campusblo> ok thanks for the help
06:55:44 <DRMacIver> No problem. Sorry I couldn't provide more useful feedback.
06:57:26 <Saizan> campusblo, if you are writing a parser you should try Text.ParserCombinators.Parsec, however to have a state you usually work in the State monad
06:57:49 <dmhouse> Saizan: Parsec has its own state, though.
06:58:05 <Saizan> yes
06:58:49 <Mitar> can somebody check this: http://hpaste.org/1388#a1
06:59:20 <Mitar> i have problems that executing the list of actions is inherently slow
06:59:31 <Mitar> even if I do not do anything of importance in the action
07:00:55 <dmhouse> Saizan: which version of hcolour do you use (for hpaste)?
07:01:08 <Saizan> darcs one
07:01:22 <dmhouse> Right, I'm on 1.6 (which was accepted by configure), and it gives me a type error building hpaste.
07:02:08 <Saizan> oh
07:02:20 <Saizan> did you find Prefix?
07:02:41 <hpaste>  dmhouse annotated "hpaste build errors" with "more hpaste build errors" at http://hpaste.org/1387#a2
07:02:55 <dmhouse> Yes, I unregistered my 0.9.0 HAppS.
07:03:08 <dmhouse> It's in 0.8.8, but gone again in 0.9.0 (darcs version).
07:03:37 <dmhouse> ?tell glguy http://hpaste.org/1387#a2 errors building HAppS with hscolour-1.6.
07:04:22 <Saizan> well, hscolour darcs cabal still has 1.6 as the version
07:04:54 <Saizan> so..
07:05:03 <dmhouse> The hscolour page lists 1.7 as the latest version.
07:05:43 <ndm> there will be a new version of hscolour out shortly
07:05:53 <ndm> but the only difference is that it won't crash
07:05:54 <Mitar> anybody?
07:05:55 <dmhouse> But huh, I just installed hscolour from darcs and it installed as hscolour-1.6.
07:06:05 <ndm> oh - if i can get hscolour to crash, does that mean i can get hpaste to crash?
07:06:21 * ndm looks up his list of hscolour bugs
07:06:27 <dmhouse> ndm: how did it crash?
07:06:36 <ndm> you probably don't pass -latex or -anchors though
07:06:39 <ndm> dmhouse: pattern match errors
07:06:45 <dmhouse> ndm: on what input?
07:07:02 <ndm> dmhouse: do you pass -latex or -anchors? they were required for a crash
07:07:13 <ndm> (`) with -anchors caused a crash
07:07:21 <ndm> as did " (just a single quote) with -latex
07:07:23 <dmhouse> Yay! Well, the darcs version of hscolour seems to play well with hpaste, I can (finally) build it.
07:07:34 <dmhouse> ndm: right, well, no, I'm not using those flags. :)
07:07:41 <ndm> the darcs version has a formal proof that hscolour will never crash :)
07:07:46 <dmhouse> Nice :)
07:08:09 <ndm> (excluding IO errors, which may still crash)
07:09:52 <dmhouse> Saizan: hrm, would you happen to know whether there's a way to stop hpaste from connecting to freenode?
07:12:20 <Saizan> mmh no, see the HPasteBot module..
07:12:55 <dmhouse> Saizan: never mind, I found it. Just comment out the main = mainWith (forkIO . runBot) line, and uncomment the main = mainWith (const (return ())) line.
07:13:53 <Saizan> on, nice :)
07:15:05 <Saizan> (however 0.9.0 got downgraded to 0.8.8 just after the addition of Prefix)
07:16:30 <foxy-om> how do you access the type of an existentially qualfied type?
07:17:03 <Heffalump> just cause it to get unified with something free
07:17:05 <dmhouse> foxy-om: in what way?
07:18:15 <foxy-om> I want to create a tuple based on list length, so different lengths will result in different type of result, so I'm assuming this needs to be treated as an existential, but then how can I use the type of the tuple later, in e.g. the index argument of an Array?
07:18:56 <Heffalump> errm, I don't think you can do that
07:19:08 <kpreid> foxy-om: Data.Typeable.Typeable is a typeclass for getting types at runtime
07:19:32 <Heffalump> IM creating the tuple based on list length
07:19:42 <Heffalump> unless you just explicitly list a bunch of different list lengths
07:20:16 <foxy-om> I was planning on just explicitly listing lengths up to 9.
07:20:33 <foxy-om> but I still don't see how I can do it
07:20:51 <Heffalump> you need to put your tuples into a type class
07:21:03 <Heffalump> class Knownlength a where
07:21:09 <kpreid> instance Tuple (a,b,c) where tlength _ = 3
07:21:18 <Heffalump>    knownlength :: a -> Int
07:21:26 <Heffalump> and then an instance like kpreid suggests
07:21:41 <Heffalump> well, 8 or 9 instances
07:27:08 <diakopter> hello- I'm building ghc trunk using debian ghc6.6.  I did ./darcs-all --extra get  my question is how do I tell configure to install this in my homedir?
07:29:55 <Igloo> diakopter: --prefix=/home/...
07:30:27 <diakopter> Igloo: thanks.  do I need to use --exec-prefix as well?
07:30:33 <Igloo> no
07:30:45 <diakopter> great; thank you
07:31:00 <foxy-om> kpreid/Heffalump: I don't see how that helps, I now have a class that tells me the length of a list, but how do inject that information into the class level (so that I know I want the instance that takes a list and returns a 3-tuple, for example).
07:35:43 <Heffalump> I don't follow.
07:36:00 <sorear> hi.
07:36:19 <Heffalump> your list -> tuple function will have type [Int] -> (exists a . Knownlength a => a)
07:36:26 <Heffalump> or something like that
07:36:52 <Heffalump> you might need to wrap the existential up in a datatype, I forget what's allowed
07:36:57 <foxy-om> but how do I use that when, for example, creating an Array (where the Ix a => a is determined by my existential type
07:37:18 <foxy-om> doesn't the existential "escape" at that point...
07:37:25 <sorear> @uptime
07:37:34 <sorear> still gone?
07:37:38 <Heffalump> you just want to use your type for the array bounds, right?
07:37:44 <foxy-om> yeah
07:37:57 <foxy-om> depending upon the number of dimensions
07:38:28 <Heffalump> ok, so just use knownlength on the existential value, and you'll get a number
07:39:02 <foxy-om> but the Array type takes an index type, e.g ((1,1,1),(4,2,2)) for a 4x2x2 matrix
07:39:32 <foxy-om> where the type of (...) is determined by the number of dimensions (length of the list we're passed)
07:40:24 <Heffalump> oh, so you want to use the tuple *value* for the array bounds, not the tuple *length*?
07:40:26 <foxy-om> so for the above array I get passed the list [4,2,2] and a Ptr ()
07:40:41 <foxy-om> well, the length determines the type of the tuple
07:40:48 <foxy-om> which is the tricky part
07:41:16 <Heffalump> ok, so your existential needs to mention Ix
07:41:22 <Heffalump> so that when you unwrap it you have an Ix instance
07:41:37 <Heffalump> I think you'll also need a class to construct an tuple of 1s for the lower bound
07:42:00 <foxy-om> OK, so using classes is essentially the only way of 'accessing' existentially wrapped types?
07:42:14 <Heffalump> so you could have class Ix a => class Tuple a where lowerBound :: a
07:42:28 <Heffalump> well, it's the only way of being able to use actual operations on values of those types
07:42:41 <Heffalump> because without a class you don't know anything about the wrapped type at all, so you can't do anything with it
07:42:49 <foxy-om> OK, well, thanks, that answers my question :)
07:51:22 <sorear> Equivalently, you can just pack methods.
07:51:45 <sorear> data Foo = forall a. Bar a (a -> x)
07:52:25 <Heffalump> oh, true
08:02:49 <ndm> sorear, thanks for the HCAR entry
08:04:31 <sorear> yw.
08:04:50 <ndm> i am also moving more things over to guess derivations, its really cool :)
08:05:02 <ndm> we have Eq, Ord, Data, BinaryDefer etc all in terms of Guess
08:05:56 <ndm> and I've just pushed Serial for smallcheck, written entirely by guesswork - never written by hand :)
08:28:29 <hpaste>  diakopter pasted "build error - trunk with extras" at http://hpaste.org/1389
08:28:34 <xs> wow. ghc 6.6 rocks. my webcam application went from ~40fps under 6.2 to ~100fps under 6.6.
08:28:58 <sorear> nice.
08:29:45 <xs> yeah. given the c++ frontend using fltk only gets 25fps...
08:29:46 <sorear> diakopter: my first random guess: are the x11 development files installed
08:29:55 <sorear> ?
08:30:14 <diakopter> sorear: it's debian etch; xorg-dev is installed
08:30:20 * sorear rebuilds his ghc, it's been almost two weeks!
08:30:24 <diakopter> (and its 95 dependencies)
08:30:48 <sorear> Strange.  did the X11 build proper give any errors?
08:31:17 <Saizan> sorear: do you rebuild all your installed packages everytime?
08:31:31 <sorear> Oh, wait, that WAS the X11 build proper ;)
08:31:39 <sorear> Saizan: no, I do it lazily
08:31:43 <diakopter> okay, I didn't know how to answer that :)
08:31:53 <sorear> besides, it's just about automated
08:32:22 <sorear> "Oh, filepath is gone since I rebuilt.  'cd /usr/local/src/filepath && cabal-build'"
08:32:38 <diakopter> regardless, I don't need the X11 extra.  is there a way to "undo" ./darcs-all --extra to take it back to the base?
08:32:38 <sorear> where cabal-build is a sh-script in $HOME/bin
08:32:50 <sorear> rm -rf, I think
08:33:02 <Lemmih> sorear: You've been programming since you were eight?
08:33:03 <sorear> rm -rf libraries/X11
08:33:26 <Saizan> mmh my cabal-build is just an alias..
08:33:32 <sorear> Lemmih: for various definitions of the word, I didn't exactly do much ;)
08:33:47 <diakopter> sorear: ok, i'll try it.  do I also need to remove that line from libraries/extra-packages ?
08:33:53 <sorear> no
08:34:12 <sorear> Saizan: I wrote cabal-build and never published it, if there is a published program of the same name it is coincidental
08:34:14 <Heffalump> a lot of geeks start programming quite young, don't they?
08:34:28 <Mitar> how could i compile a program so that would use multi cores (for example, map could be easily translated to multiple cores)
08:34:33 <sorear> Lemmih: so, what happened?  did someone mention me on p-h-o?
08:34:57 <sorear> Mitar: -threaded (compile time), +RTS -N<number of cores> (runtime)
08:35:20 <sorear> Mitar: also, you need to give parallelism annotations, using threads or (preferred if possible) `par`
08:36:04 <Saizan> sorear: "my cabal-build" as in "the thing i've written when i got bored of typing runghc Setup.hs {configure,build,install}"
08:36:37 <sorear> ok.
08:36:44 <diakopter> to back up, I reran sh boot and ./configure with a prefix.  is plain old "make" next?  or make boot, then make all?
08:36:54 <Lemmih> sorear: Yesterday you mentioned that you've been programming for eight years.
08:37:12 <Mitar> but will this paralelise map (i have large mapings in a program)
08:37:22 <sorear> no
08:37:26 <sorear> there is a parMap
08:38:08 <sorear> haskell threads may be cheap, but they aren't cheap enough that parallelising map (+1) [1..10000] is a win
08:38:10 <ndm> Heffalump: i used my first computer at 16
08:38:21 <ndm> maybe that makes me not a geek :-)
08:38:39 <Stinger> hand in your card now please :|
08:38:40 <ndm> hmm, sorear has been programming roughly as long as me
08:40:09 <Heffalump> ndm: I didn't say all, I said lots :-)
08:40:34 <ndm> woohoo, now I have defined Enum and Bounded in terms of guess work :) - this is much easier than doing real instances
08:43:10 <xerox> I started at eight too (:
08:43:41 <xerox> (Got taught BASIC.)
08:45:59 <Saizan> ndm: those && True in the Eq example are to help DeriveGuess recognise the recursion?
08:50:19 <hpaste>  Sergey Perminov pasted "modifying Don Stewart's "showDouble" to "showInt" to work with Ints" at http://hpaste.org/1390
08:54:24 <fasta> Why aren't there any functions in the standard libs to escape the current computation? Sure, there's callCC, but that's not integrated with the rest, AFAIK.
08:54:33 <sorear> throw
08:54:46 <sorear> and because it is effectful
08:54:58 <sorear> escaping counts as a side effect
08:55:00 <fasta> Isn't throw used for exceptions?
08:55:07 <sorear> error is even more standard
08:55:08 <sorear> yes
08:55:23 <sorear> exceptions are escape continuations
08:55:35 <fasta> sorear: I know
08:56:15 <fasta> sorear: I only don't know how much overhead there is in the exception mechanism. I suspect not more than me using runCont
08:56:42 <sorear> why can't you just return?
08:57:03 <fasta> sorear: that means I can't use higher-order functions
08:57:12 <sorear> eh?
08:57:21 <sorear> like short-circuiting map?
08:57:46 <fasta> sorear: like short-circuiting a fold
08:58:05 <xs> fasta: foldM?
08:58:05 <sorear> foldr short circuits automatically
08:58:06 <Heffalump> throwing an exception composes differently to return
08:58:32 <sorear> > foldr (&&) True (repeat False {- an INFINITE list -})
08:58:48 <sorear> oh, right, the bot is dead.
08:59:09 <fasta> sorear: ah, right.
08:59:11 <sorear> anyway, if you are using foldr, you don't have to do anything special for it to short-circuit
08:59:23 <xs> callCC can be used with foldM to get short circuit semantics with a left fold. but i guess you're using a right fold.
08:59:46 <fasta> Hmm, I guess I was sleeping again.
09:00:26 <fasta> I actually need a foldr for a different structure, but the same ideas apply there.
09:00:30 <sorear> xs: you don't even need full callCC, Either is enough
09:05:09 <xs> sorear: the difference betweel "full" callCC and failure in Either? i don't see a standard instance for Either. i would expect it not to have as good space efficiency as callCC though?
09:05:10 <Mitar> why is this slow: http://hpaste.org/1388#a1
09:05:11 <Mitar> ?
09:06:09 <fasta> Mitar: drawRay doesn't do anything, you know that, right?
09:06:21 <xs> Mitar: pattern matching is strict. no element of rays is evaluated when you match against _.
09:06:26 <Mitar> yes ... exactly :-)
09:06:27 <fasta> Mitar: it might force some structure
09:06:41 <Mitar> that's because i am debuging
09:07:10 <Mitar> xs: but does it evalute more than just a first element when i use pattern matching?
09:07:16 <fasta> Mitar: already compiled it with full optimization?
09:07:29 <Mitar> -O?
09:07:36 <Mitar> no ...
09:07:36 <fasta> Mitar: yes
09:07:38 <Mitar> :-)
09:07:40 <Mitar> i will try it
09:07:53 <fasta> Mitar: well, do that first, before you think something is "slow".
09:07:57 <Mitar> i am just writing the code and learning haskell ...
09:07:59 <xs> Mitar: it evaluates it as much as is necessary to not match the pattern.
09:08:14 <Mitar> and I noticed it is slow ... that's why I asked so that I would prevent some stupid mistake ..
09:08:36 <fasta> Mitar: If you use the right algorithms, it can only be slow up to a constant factor.
09:09:00 <Mitar> :-)
09:09:21 <Mitar> but the constant of 10 between 1 second and 10 seconds is still big ...
09:09:38 <fasta> Mitar: I am not surprised by a constant of 100.
09:09:52 <sorear> People who care about constant factors probably shouldn't use garbage collected default lazy pure higher order functional programming languages.
09:10:02 <fasta> Mitar: but for a large application I don't expect that.
09:11:09 <Mitar> i care only about unecessary constant factors
09:15:17 <ddarius_> Indeed, a garbage collected strict impure first order object-oriented programming language like Java would already be much better.
09:18:28 <fasta> Oh, I did need foldl afterall.
09:19:21 <dmead> Mitar, seems slow because you use alot of lazyness
09:19:44 <Mitar> where could I use strictnes?
09:20:05 <dmead> instead of let display = do ....
09:20:10 <dmead> display <- do....
09:20:13 <dmead> i think
09:20:40 <dmead> layness and i/o seem to be a big issue, especially on the mailing list
09:21:11 <dmead> if you look at the frag source code
09:21:21 <dmead> the loader uses like 50 let statements
09:21:26 <dmead> and it takes forever to load up
09:21:40 <dmead> (frag is a simple shooter in haskell)
09:22:12 <dmead> remember for let statements you always get delayed execution
09:22:40 <Heffalump> foo <- return x
09:22:43 <Heffalump> is also delayed, though
09:22:53 <dmead> ya
09:23:07 <dmead> he's got a butload of stuff in a let statement though
09:23:23 <fasta> Maybe the strictness analyzer does something usefull...
09:23:35 <dmead> which if i'm not mistaken guarantees lazyness
09:23:45 <dmead> eh?
09:23:47 <fasta> My point: hard to tell what's going on without profiling
09:23:49 <ddarius> A let statement just binds a value to a name, it doesn't make things lazy.
09:26:12 <ddarius> The reason that frag takes forever to load up is, I willing to bet, that it uses String based IO.
09:27:07 <Heffalump> it's lazy if you have a strict mindset and thing that something will normally be executed in the place you write it :-)
09:32:50 <jyp> @seen seliopout
09:32:52 <jyp> @seen seliopou
09:33:06 <jyp> arg
09:35:37 <sorear> bot's been gone for over 12h
09:35:45 <sorear> too bad dons is travelling
09:42:33 <chessguy> hi haskellers
09:43:06 <dmead> hi der
09:45:39 <chessguy> wow, i just learned something new. it's apparently either very difficult or impossible to move your right foot in clockwise circles while drowing a counter-clockwise circle in the air with your hand
09:46:08 <chessguy> i just thought i'd enrich all of your lives by telling you that
09:47:13 <xs> chessguy: ever tried spinning around on a chair with your ear pressed to your shoulder, then stopping and levelling your head? make sure there's nothing sharp around.
09:47:39 <chessguy> what happens?
09:47:45 <xs> you throw yourself forwards
09:47:53 <xs> because you feel you are falling backwards
09:48:00 <xs> due to the axis switch
09:48:05 <chessguy> interesting
09:48:26 <xs> your brain adjusts for rotational bias in some axis, but not all
09:49:05 * ddarius doesn't have a spinny chair.
09:49:20 <chessguy> i have a spinny chair but not enough room to try it
09:49:22 <sorear> ddarius: what is c.l.f?  (news:comp.lang.<I can't tell what goes here)
09:49:32 <chessguy> functional
09:50:16 <ddarius> If you want to find that article, it's like three years old.  It was someone complaining that monads didn't work in O'Caml because of a bug like that.
09:51:24 <dmhouse> e
09:51:35 <allbery_b> huh
09:52:03 <allbery_b> (specify right hand there --- I have no problem drawing with left hand while rotating right foot, but the other is difficult
09:52:52 <chessguy> wow, you're right
09:53:33 <allbery_b> I can do it, btw, but it takes a lot of effort
09:53:58 <chessguy> left and left seems to be difficult too
09:54:45 <sorear> ddarius: I found it, you want a url?
09:55:06 <ddarius> I've found it too.
09:57:25 <allbery_b> re spinny chair, how much of that is brain adjusting/not adjusting,m and how much just cochlear hysteresis?
10:05:09 <ddarius> My impression is that the feeling is all cochlear hysteresis and the pitching oneself forward is all brain albeit not so much adjusting v. not adjusting.
10:53:07 <glguy> ?tell dmhouse that's because I used too new of a xhtml library
10:53:49 <ndm> @seen lambdabot
10:54:10 <glguy> ?tell dmhouse or because I added that so you didn't have to use as new a library, one of the two :)
10:54:21 <ddarius> lambdabot is dead.
10:54:32 <balodja> not dead, just a day-off
10:55:42 <ddarius> "lambdabot is dead." sounds much more dramatic.
10:55:57 <Korollary> lambdabot was murdered!
10:56:29 <jcreigh> I think the professor did it in the kitchen with the lead pipe
10:56:32 <sorear> Evil people at UNSW cut the bot's power.
10:56:54 <sorear> The bot wasn't bludgeoned quickly ... it was STARVED
10:57:15 <Korollary> very quickly starved, tho
11:02:05 <LeCamarade> It seems to me that when a functional language chooses not to be pure it automatically chooses to lose laziness. Is this supposed to be so?
11:02:05 <jcreigh> sorear: gah, I'm sick of people disclaiming knowledge of cabal on xmonad@ :)
11:02:29 <droundy> sorry about that!
11:02:30 <LeCamarade> Can't laziness and side effects co-exist?
11:02:37 <nominolo> LeCamarade: the other side round
11:02:52 <jcreigh> droundy: heh, no worries. :)
11:02:53 <nominolo> LeCamarade: with lazyness it's hard to see, when evaluation occurs
11:02:57 <sorear> LeCamarade: yes, they can coexist
11:02:59 <droundy> :)
11:03:10 <sorear> LeCamarade: GHC is a lazy impure language
11:03:24 <sorear> but it's really hard to use, so we hide the impurity
11:03:28 <nominolo> LeCamarade: you can try it out by just throwing in lots of unsafePerformIO
11:03:50 <sorear> if you avoid importing GHC.*, you would think GHC is pure and monadic
11:04:30 <LeCamarade> Oh, actually GHC allows for impurity. You see, I was looking at this here page: http://www.haskell.org/haskellwiki/Comparison and I saw that trend ...
11:04:33 <chessguy> ?seen lambdabot
11:05:05 <LeCamarade> chessguy: lambdabot is off for the weekend. :oD Blame Google.
11:05:12 <chessguy> google?
11:05:34 <sorear> UNSW staff killed the bot's power, ask dcoutts
11:05:57 <Saizan> the reality is that she's out shopping with a google crawler
11:06:03 <LeCamarade> chessguy: Yep. They started blocking her attempts to fetch data via Google, and so dons must have taken her down for re-fitting.
11:06:13 <LeCamarade> Saizan: :oD
11:06:53 <ndm> who started blocking her attempts? google or UNSW?
11:07:12 <chessguy> ndm: i suspect LeCamarade is making up a bunch of garbage, though why i'm not sure
11:07:29 <LeCamarade> ndm: Google did.
11:07:46 * sorear sides with chessguy
11:07:54 <LeCamarade> chessguy: Seriously. You shoulda seen the havoc here, yesterday. dcoutts probably remembers.
11:08:24 <Saizan> the google plugin was not working
11:08:35 <sorear> I was here yesterday.  dcoutts told me the bot died as a result of a power failure!
11:11:26 <sorear> Saizan: I just tried @google on a local lambdabot and it works.
11:11:56 <jcreigh> does anybody know if this will come back to haunt me? http://rafb.net/p/WYx66N86.html
11:12:09 <Saizan> so maybe they blocked lb's ip?
11:12:33 <jcreigh> I don't want to spend the rest of my life tracking down strage issues with different versions of X11/sh/weird UNIX stuff. I should probably just use autoconf, eh?
11:12:48 <sorear> yes, use autoconf ;)
11:13:11 <jcreigh> sorear: okay.
11:13:14 <sorear> for instance, cc isn't always a c compiler :)
11:13:24 <sorear> or at least autoconf checks a bunch of names
11:13:28 <jcreigh> sorear: ah, I knew there would be something strange like that.
11:13:33 <jcreigh> autoconf it is.
11:13:41 <glguy> jcreigh: hpaste is down?
11:13:43 <glguy> !paste
11:13:43 <hpaste> Haskell paste bin: http://hpaste.org/
11:13:49 <jcreigh> glguy: no, it's just not Haskell code.
11:13:50 <glguy> oh, nvm
11:14:13 <sorear> glguy: *hint hint* and hpaste doesn't have other syntax support
11:14:24 <glguy> there are other languages than haskell?
11:15:13 <LeCamarade> glguy: :oD ROTFLMAO
11:15:42 <chessguy> hmm, it does appear to have been a google issue
11:15:48 * chessguy apologizes to LeCamarade 
11:15:51 <glguy> LeCamarade: the concept was funny to me too :)
11:16:26 <chessguy> at least the broken ?google command was
11:16:28 <LeCamarade> chessguy: You may rise, O forgiven lambdaman. :oD
11:16:33 <chessguy> not why the bot is down
11:17:04 <sorear> manzano lost power
11:17:15 <sorear> right now manzano is sitting at a login prompt
11:17:24 <sorear> lambdabot will start when dons logs in
11:17:56 <chessguy> what's manzano?
11:18:03 <glguy> the machine that lambdabot lives on?
11:18:08 <sorear> yes
11:18:13 <LeCamarade> glguy: I never knew I'd ever pretend I don't know how to write Java, so I don't injure my reputation. Has is such a friggin' hot philosophy. Not a langauge. Philosophy.
11:18:16 <chessguy> ah, didn't know
11:18:27 <glguy> or the grad student that powers the bike generator that runs lambdabot
11:18:58 <LeCamarade> s/Has/Haskell/gi
11:19:00 <nominolo> no hamster?
11:19:16 <chessguy> glguy:  well, abstractly, it doesn't matter which it is, as long as both provide the same interface
11:20:58 <nominolo> can't someone else run an instance of lambdabot?
11:21:12 <sorear> yes, are you asking?
11:21:50 <nominolo> er, yes, hence the "?" at the end ...
11:22:02 <nominolo> you mean if i need lambdabot?
11:22:13 <LeCamarade> nominolo: :oD
11:22:34 <nominolo> not necessarily, but i think it would be handy
11:23:11 <ddarius> It would really suck to get your own IP blacklisted by google.
11:23:25 <jcreigh> ddarius: heh, yeah.
11:23:33 <sorear> @join #ghc
11:23:36 <sorear> @join #happs
11:23:41 <sorear> @join #haskell-overflow
11:23:43 <sorear> @join #haskell-blah
11:23:47 <sorear> @join #darcs
11:23:48 <chessguy> the one nice thing about dynamic IPs i guess
11:23:53 <chessguy> @quote
11:23:54 <sorear-lambdabot> No quotes yet.
11:24:01 <chessguy> boo!
11:24:05 <jcreigh> "hmm...I'm blacklist by google...what can I do online? Guess I'll just surf Youtube...wait, crap!"
11:24:23 <chessguy> @remember jcreigh "hmm...I'm blacklist by google...what can I do online? Guess I'll just surf Youtube...wait, crap!"
11:24:23 <sorear-lambdabot> Not enough privileges
11:24:25 <sorear> Duh, go to Freenode!
11:24:29 <sorear> wtf?
11:24:42 <nominolo> huh?
11:24:43 <sorear> oh, right
11:24:48 <medfly> use altavista or something
11:24:56 <medfly> or something else that will google for you
11:25:03 <sjanssen> chessguy: there's no use anyway, the quotes will be gone when sorear-lambdabot leaves
11:25:05 <sorear> some kind of bug that was fixed right after I last pulled
11:25:15 <sjanssen> @let x = 4
11:25:16 <sorear-lambdabot> Plugin `eval' failed with: IRCRaised State/L.hs: copyFile: does not exist (No such file or directory)
11:25:24 <chessguy> sjanssen: i was just fooling around
11:25:36 <sorear> @google haskell
11:25:38 <sorear-lambdabot> http://www.haskell.org/
11:25:38 <sorear-lambdabot> Title: Haskell - HaskellWiki
11:25:56 <chessguy> ?go graham hutton programming
11:25:57 <nominolo> is lambdabot's "memory" written to some file?
11:25:58 <sorear-lambdabot> http://www.cs.nott.ac.uk/~gmh/book.html
11:25:59 <sorear-lambdabot> Title: Programming in Haskell
11:26:09 <sorear> yes, a bunch of them
11:26:12 <sorear> in State/
11:26:17 <sorear> @remember
11:26:17 <sorear-lambdabot> Incorrect arguments to quote
11:26:33 <nominolo> then just send the file to dons once the real lambdabot is up again
11:26:50 <sorear> dons will be back in ~3h probably
11:27:03 <chessguy> > 3
11:27:04 <sorear> robo_chessguy: @help
11:27:04 <robo_chessguy> help <command>. Ask for help for <command>. Try 'list' for all commands
11:27:05 <sorear-lambdabot>      Bad interface file: ShowQ.hi
11:27:05 <sorear-lambdabot>         mismatched interface file versions:...
11:27:05 <robo_chessguy>  Ix{Int}.index: Index (13510798885650432) out of range ((0,28))
11:27:12 <chessguy> hooboy
11:27:26 <sjanssen> nominolo: the file is a gzipped binary file, it's hard to submit patches :(
11:27:27 <chessguy> oh, that's that 64-bit problem
11:27:27 <ddarius> Impressive.
11:27:37 <chessguy> > 22
11:27:38 <sorear-lambdabot>      Bad interface file: ShowQ.hi
11:27:38 <sorear-lambdabot>         mismatched interface file versions:...
11:27:39 <robo_chessguy>  Ix{Int}.index: Index (13510798885650432) out of range ((0,28))
11:27:53 <chessguy> oh, both bots are getting in on it
11:28:08 <sorear> oh, yes, and my lb is crippled by a b0rken installation of hs-plugins :)
11:28:14 * sorear should pull and recompile
11:28:27 <chessguy> > "hi"
11:28:28 <sorear-lambdabot>      Bad interface file: ShowQ.hi
11:28:28 <sorear-lambdabot>         mismatched interface file versions:...
11:29:36 <ndm> @hoogle map
11:29:36 <sorear-lambdabot> Could not find hoogle database, looked for: State/hoogle.txt
11:29:47 <xerox> sorear, could you make the nick shorter?
11:29:49 <sorear> I'm recompiling the bot now, with my 4mo newer hs-plugins install ... should work
11:29:52 <sorear> yes
11:30:03 <ndm> you should be able to grab hoogle.txt easily enough
11:30:11 <xerox> thanks
11:30:12 <ddarius> sambabot ho!
11:30:12 <sorear> @google hoogle.txt
11:30:13 <ndm> for bonus points you can even upgrade to a GHC 6.6 version
11:30:14 <sorear-lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/State/hoogle.txt
11:30:24 <chessguy> @vixen
11:30:24 <sorear-lambdabot> <undefined>
11:30:34 <sorear> ndm: where is the master hoogle.txt?
11:30:55 <jcreigh> broken lambdabot is almost like a failing HAL...
11:31:19 <nominolo> jcreigh: no, we're all gonna die!!
11:31:37 <chessguy> ?where lambdabot
11:31:38 <sorear-lambdabot> I know nothing about lambdabot.
11:31:49 <sorear> what is the UTF-8 byte seq for lambda?
11:32:25 <sjanssen> we're supposed to know that off the top of our heads?
11:32:33 <ndm> \ :-)
11:32:40 <nominolo> .\
11:32:47 <dmhouse> ,\ maybe?
11:33:11 <xerox> U+03BB
11:33:13 <sorear> 0x3BB
11:33:18 <xerox> λ
11:33:49 <sjanssen> "\206\187"
11:34:04 <sorear> sjanssen: ty :)
11:34:13 * sorear muahahas
11:34:20 <sjanssen> sorear: the easiest way to learn the UTF-8 sequence is to run getLine in ghci, then type your character :)
11:34:35 <sorear> :)
11:34:42 <sjanssen> capitalizing on the brokenness of the IO system
11:35:55 <sorear> > map (\x -> showHex x "") [206,187]
11:35:58 <sorear-lambdabot>      Bad interface file: ShowQ.hi
11:35:58 <sorear-lambdabot>         mismatched interface file versions:...
11:36:02 <sorear> @slap me
11:36:03 * sorear-lambdabot smacks sorear about with a large trout
11:36:22 <vincenz> @slap sorear
11:36:23 * sorear-lambdabot slaps sorear
11:37:22 <sorear> @quit
11:38:27 <sorear> drat, lambdabot isn't a legal nick
11:38:46 <xerox> take another letter (:
11:38:55 <xerox> great.
11:39:02 <sorear> > 2 + 2
11:39:08 <lb>  4
11:39:11 <sjanssen> > "λ" -- I think I know what sorear is up to...
11:39:18 <lb>  "\955"
11:39:19 <sorear> @version
11:39:24 <lb> lambdabot 4p514, GHC 6.7.20070413 (Linux i686 2.00GHz)
11:39:30 <lb> darcs get /usr/local/src/lambdabot
11:39:38 <xerox> haha
11:39:39 <ndm> sorear: the master hoogle.txt is on the website, i'll just find it
11:39:40 <sjanssen> > (λx -> x) 10
11:39:43 <sorear> btw, the ghc-version is a lie
11:39:48 <lb>  Illegal character ''\187''
11:40:14 <ndm> http://haskell.org/hoogle/res/hoogle.txt - sorear
11:40:15 <sjanssen> sorear: did you add a UTF-8 parser?
11:40:19 <sorear> no
11:40:34 <ddarius> Does it ask the installed ghc instead recording the version that compiled it/
11:40:40 <ddarius> s/\//?
11:40:45 <sjanssen> oh right, ghci does UTF-8
11:40:51 <sjanssen> why do I keep forgetting this?
11:40:53 <sorear> ddarius: yes.
11:41:13 <sorear> @hoogle Applicative
11:41:15 <lb> No matches found
11:41:22 <sorear> @hoogle a -> b -> b
11:41:24 <lb> Prelude.const :: a -> b -> a
11:41:24 <lb> Prelude.seq :: a -> b -> b
11:41:24 <lb> Control.Parallel.par :: a -> b -> b
11:41:29 <sorear> @hoogle pseq
11:41:30 <lb> GHC.Conc.pseq :: a -> b -> b
11:42:00 <sorear> @hoogle openTempFile
11:42:00 <lb> System.IO.openTempFile :: FilePath -> String -> IO (FilePath, Handle)
11:44:50 <inverselimit> @pl  (\f g -> (\x y -> (f x, g y)))
11:44:51 <lb> flip . (((.) . (,)) .)
11:47:00 <balodja> > foldr (*) 1 [1..10]
11:47:02 <lb>  3628800
11:47:33 <balodja> fantastic
11:48:15 <balodja> sorear: does lb run on debian?
11:48:35 <sorear> balodja: Yes.
11:49:10 <sorear> balodja: indeed, lb is a virtually fresh get, the only changes were to s/ghc/ghc-6.6/ and s/lambdabot/lb
11:49:11 <balodja> hm. i have some long evenings tuning hs-plugins to run on current etch
11:49:32 <sorear> and the former was only needed because I've installed HEAD from source as 'ghc'
11:49:37 <sorear> lb runs on sid
11:50:17 <sorear> that said, I'm running i386
11:50:26 <sorear> as is dons
11:50:54 <ClaudiusMaximus> sorear: lb doesn't seem to respond to /msg ...
11:51:43 <balodja> hm-m-m. i didn't understand yet, but imho debian's ghc6.6 violates Z-notation in naming symbols in objects
11:52:05 <sorear> ClaudiusMaximus: yes it does.  you need to /mode ClaudiusMaximus +6
11:52:41 <sorear> balodja: nice try, lambdabot doesn't have CTCP support
11:52:49 <balodja> :)
11:52:53 <balodja> i see :)
11:53:02 <LoganCapaldo> @botsnack
11:53:02 <lb> :)
11:53:03 <sorear> 4p517, if you care
11:53:10 <LoganCapaldo> lb?
11:53:19 <sorear> <xerox> sorear, could you make the nick shorter?
11:53:21 <LoganCapaldo> I take it this is a backup lambdabot?
11:53:28 <sorear> yes.
11:53:37 <sorear> just 'b' was taken :)
11:53:53 <vincenz> what about 'Just b'
11:54:04 <sorear>   is illegal
11:54:23 <balodja> rfc forbids spaces in nicks
11:54:37 <vincenz> replace ' ' with some meaningless valid character
11:54:44 <sorear> besides, the protocol is ... space separated fields!
11:54:51 <vincenz> I know
11:54:55 <vincenz> I wasn't being serious
11:55:28 <sorear> ClaudiusMaximus: lb is unregistered, so you will only recieve privmsgs from it if you set the 'allow privmsgs from unregistered users' umode
11:55:35 <sorear> the command is '/mode ClaudiusMaximus +6'
11:55:53 <sorear> you might need '/msg nickserv set unfiltered on'
11:56:09 <ClaudiusMaximus> sorear: ok
12:13:09 <TomMD> What is the most common way to read in binary data.  Ex: I have a header like [ Word32, Word32, Word8, Word64, String, Word32] - I can read the file in as a [Char] then convert all the fields, but there should be an easier way, right?
12:13:37 <sorear> use the Data.Binary.Get monad
12:13:43 <sorear> @where binary
12:13:44 <lb> I know nothing about binary.
12:13:51 <sorear> @slap lb
12:13:51 * lb smacks lb about with a large trout
12:14:05 <Saizan> ?google Data.Binary
12:14:06 <lb> http://darcs.haskell.org/binary/
12:14:06 <lb> Title: Index of /binary
12:14:16 <sorear> @where+ binary http://darcs.haskell.org/binary/
12:14:17 <lb> Done.
12:18:37 <pete`> hello, why does HaXml call its `o` filter combinator "Irish composition"? The documentation only states "We call this opearator Irish composition for reasons which should be obvious"? maybe i'm missing some historical background.
12:19:36 <nominolo> pete`: O'Leary
12:19:52 <nominolo> pete`: O'Rear, O'Malley, ...
12:20:18 <pete`> ah .. i see. thanks.
12:21:10 <nominolo> :)
12:22:31 <LeCamarade> nominolo: :oD
12:23:08 <LeCamarade>  
12:25:47 <ddarius> Jamaica, eh
12:28:23 <ndm> sorear: i've just pushed an updated user manual for derive, we have a very solid guesswork foundation in, i've added a load more derivings (about 5 minutes a piece with guesswork turned on) and have documented most stuff
12:28:54 <ndm> sorear: what more til we release? I've not done a complete Play deriving yet, but since Play isn't released thats no reason not to release this library
12:29:31 <dmwit> Is there a convenient way to derive a cyclic enum?
12:29:49 <sorear> yes, poke ndm
12:29:53 <sorear> :)
12:30:00 <dmwit> ndm: ?
12:30:07 <sorear> shouldn't be hard to make an Enum deriving that wraps around?
12:30:52 <sorear> ndm: it certainly seems usable.  I have no objections to a release now.
12:31:02 <sorear> (nor am I pushing for it)
12:32:22 <ndm> dmwit: trivial, do you still want it to be called Enum? just that succ and pred go forward and back?
12:32:29 <ndm> @where derive
12:32:29 <lb> I know nothing about derive.
12:32:43 <dmwit> ndm: Right, succ of the last one be the first one.
12:32:58 <ndm> http://www-users.cs.york.ac.uk/~ndm/derive/
12:32:59 <lb> Title: Neil Mitchell - Derive
12:33:13 <dmwit> Thanks!  I'll take a look.
12:33:18 <ndm> dmwit: check out that, give me 5 minutes and deriving EnumCycle will do what you want
12:33:33 <sorear> ndm: obviousty the deriver should be called Data.Derive.CyclicEnum.makeCyclicEnum or similar! we can call the class Enum, but deriving enum should give you a standard enum
12:33:44 <chessguy> ?where arrows
12:33:44 <lb> http://www.haskell.org/arrows/
12:33:53 <ndm> sorear: yes, that was my plan
12:34:04 <ddarius> @google "Programming in an Integrated Functional and Logic Language"
12:34:05 <lb> http://www.cs.tu-berlin.de/journal/jflp/articles/1999/A99-03/A99-03.html
12:34:05 <lb> Title: JFLP: Volume 1999, Article 3
12:34:13 <ndm> i don't want to break standard derivings if possible
12:34:30 <ndm> although perhaps this shows up a need for parameterised derivings, which kind of look helpful for other bits as well
12:36:48 <dmhouse> *Yawn*
12:36:56 * dmhouse has almost finished his hpaste -> Emacs integration
12:37:52 <ddarius> "For a logic programmer who does not know Haskell or any other
12:37:52 <ddarius> modern functional language, the job is harder. However, once the power of
12:37:52 <ddarius>  types, modules, higher-order functions, and so on, is appreciated, it is very
12:37:52 <ddarius>  difficult to go back to Prolog!"
12:38:09 <ddarius> wtf? Whatever...
12:38:16 <sorear> dmhouse: yay, that was on my TODO list
12:38:33 <sorear> please be sure I get a copy :)
12:38:42 <dmhouse> sorear: I'll be distributing it on the Haskell wiki.
12:38:51 <chessguy> hmmm. i guess i can't just remove the dependency on plugins any more eh?
12:39:04 <sorear> nope, you need plugins for > 2 + 2
12:39:04 <chessguy> ?where plugins
12:39:05 <lb> I know nothing about plugins.
12:39:06 <sorear> > 2 + 2
12:39:08 <lb>  4
12:39:14 <sorear> @version
12:39:15 <lb> lambdabot 4p514, GHC 6.7.20070413 (Linux i686 2.00GHz)
12:39:15 <lb> darcs get /usr/local/src/lambdabot
12:39:23 <chessguy> oh, i need 6.7?
12:39:29 <sorear> no, that's a lie
12:39:38 <sorear> it uses 'ghc -V'
12:39:51 <dmhouse> ?where hs-plugins
12:39:51 <sorear> even though I used 'ghc-6.6' to build lb
12:39:51 <chessguy> so where do i get plugins?
12:39:51 <lb> http://www.cse.unsw.edu.au/~dons/hs-plugins/
12:39:54 <chessguy> ah
12:40:05 <chessguy> hmm, i have that
12:40:06 <dmhouse> Whose lambdabot is lb?
12:40:11 <chessguy> sorear's
12:40:24 <sorear> mine.
12:40:42 <sorear> donsbot is dead, there was a power outage at unsw
12:40:52 <sorear> and dons is travelling so he can't restart it
12:43:10 <chessguy> why do i get 'cannot satisfy dependency plugins>=1.0' if i have hs-plugins installed
12:43:36 <sorear> must not be new enough?
12:43:47 <sorear> I don't really know
12:43:55 <dmhouse> chessguy: use the darcs version/
12:44:03 <chessguy> oh, hmm. it's not showing up in ghc-pkg list
12:44:10 <dmhouse> Aha, then you don't have it installed
12:44:15 <campusblo> hi folks im trying to make a stack
12:44:24 <dmhouse> Make sure you did the sudo runhaskell Setup.hs install step.
12:44:24 <chessguy> indeed
12:44:37 <campusblo> getting an error in hugs that says cannot find show function
12:44:45 <dmhouse> campusblo: the standard list datatype is essentially a FIFO stack.
12:45:04 <chessguy> campusblo: can you paste your code?
12:45:05 <campusblo> ERROR - Cannot find "show" function for:
12:45:05 <campusblo> *** Expression : push (MakeStack [5]) 10
12:45:05 <campusblo> *** Of type    : Stack Integer
12:45:06 <chessguy> !paste
12:45:06 <hpaste> Haskell paste bin: http://hpaste.org/
12:45:26 <dmhouse> campusblo: paste the code, too, not just the error.
12:45:33 <campusblo> push :: Stack a -> a -> Stack a
12:45:33 <campusblo> push (MakeStack s) element = MakeStack (element:s)
12:45:55 <campusblo> and i did push ( MakeStack [5]) 10
12:46:12 <dmhouse> You did that exact line in Hugs?
12:46:17 <campusblo> yeh
12:46:32 <campusblo> well from push
12:46:35 <sorear> Oh, that must mean you need to add deriving(Show) to the line that defines 'Stack'
12:46:41 <dmhouse> Oh, in your definition of Stack, try adding a deriving (Show) at the end.
12:46:51 <campusblo> ok
12:47:06 <campusblo> data Stack a = MakeStack [a]
12:47:18 <campusblo> and ill add deriving show to that
12:47:28 <dmhouse> data Stack a = MakeStack [a] deriving (Show)
12:47:50 <chessguy> @todo
12:47:50 <lb> 0. SamB: A way to get multiple results from a google search
12:47:50 <lb> 1. dons: improve formatting of @dict
12:47:50 <lb> 2. dons: write Haskell Manifesto
12:47:50 <lb> 3. lispy: don't let lambdabot's prettyprinter split the sequence @foo across lines
12:47:50 <lb> 4. TheHunter: priviledged users should get priviledged listcommands.
12:47:52 <lb> [19 @more lines]
12:48:10 <chessguy> @dice
12:48:11 <lb> unexpected end of input: expecting number
12:48:14 <ndm> dmwit: pushed, the latest version of derive can derive EnumCyclic
12:48:16 <chessguy> @dice 6
12:48:17 <lb> 6 => 6
12:48:21 <dmhouse> ?dice 6
12:48:21 <lb> 6 => 6
12:48:22 <dmwit> ndm++
12:48:24 <dmhouse> ?dice 6
12:48:25 <lb> 6 => 6
12:48:27 <dmhouse> Hrm.
12:48:28 <dmhouse> ?dice 6
12:48:28 <chessguy> ?help dice
12:48:29 <lb> 6 => 6
12:48:29 <lb> dice <expr>. Throw random dice. <expr> is of the form 3d6+2.
12:48:30 <ski> @dice 3d6
12:48:30 <lb> 3d6 => 10
12:48:38 <chessguy> wtf?
12:48:39 <ndm> http://www.cs.york.ac.uk/fp/darcs/derive/Data/Derive/EnumCyclic.hs
12:48:42 <lb> http://tinyurl.com/yur2bd
12:48:47 <sorear> / /msg everyone!
12:48:51 <chessguy> @dice 3d6
12:48:52 <lb> 3d6 => 13
12:48:52 <ndm> thats the code, so if it doesn't meet your needs, feel free to play
12:48:59 * ndm loves derivation by example, so easy to do!
12:49:02 <chessguy> @dice 2d6
12:49:03 <lb> 2d6 => 3
12:49:04 <sorear> @part #haskell
12:49:05 <ventonegro> @dice 3d4 + 1
12:49:16 <ventonegro> :-(
12:49:20 <ndm> dmwit: although i am wondering why you don't just call succ' and pred', making them require Bounded and Enum?
12:49:37 <sorear> Eq?
12:49:58 <ddarius> dmhouse: I assume you meant LIFO.
12:50:09 <dmhouse> ddarius: err, yeah.
12:50:24 <ddarius> Of course, "FIFO stack" doens't make sense at all and "LIFO stack" is redundant.
12:50:27 <ndm> sorear: no need for Eq, toEnum then Eq on the Int's
12:50:39 <dmhouse> ddarius: of course. :) /me steps away sheepishly
12:50:45 <sorear> ndm: Int64
12:51:00 <ndm> sorear: nope, Int's, according to the Enum documentation
12:51:07 <sorear> right.
12:51:09 <dmwit> Oh, but then I wouldn't be able to pass these things to (Enum a) => a -> ... functions...
12:51:22 <sorear> ndm: Int64 has non-surjective toEnum
12:51:25 <ddarius> But, yeah, there really is no reason to make a Stack data type. Lists are the minimal realization.
12:51:32 <campusblo> ERROR - Undefined data constructor "Makestack"
12:51:38 <ndm> dmwit: well i've written EnumCyclic, so its easy enough for you to use now
12:51:53 <dmhouse> campusblo: Haskell is case sensitive. Use MakeStack.
12:51:57 <campusblo> yeh
12:52:00 <ndm> sorear: true, but lets just hope they don't use that :)
12:52:04 <campusblo> i just realized it when i pasted it
12:52:27 <ddarius> @type toEnum
12:52:39 <Saizan> (do you know if there's some regular expressions simplifier? like it would give me an equivalent but shorter re?)
12:53:00 <glguy> ddarius: Enum e => Int -> e
12:53:01 <glguy> :)
12:53:05 <campusblo> thanks dmhouse it works now
12:53:06 <SamB> emacs might have one for emacs-format ones?
12:53:46 <ndm> Saizan: yes, it was my undergraduate project, quite hard
12:54:02 <ndm> Saizan: but only for theoretical regular expressions - not for grep/emacs style ones
12:54:11 <ddarius> ndm: What was hard about it?
12:54:42 <Saizan> ndm: i'm dealing with the "theoretical" ones
12:56:06 <ndm> ddarius: it was just quite hard
12:56:23 <ndm> Saizan: oh, neat :) - i can send you a coyp of my 3rd year project on monday
12:56:25 <dmhouse> sorear: ping
12:56:31 <ndm> Saizan: what do you want it for?
12:56:32 <sorear> dmhouse: pong.
12:56:42 <sorear> and quickly, lunchtime is soon :)
12:56:48 <dmhouse> sorear: fancy testing the beta version of the hpaste Emacs module then? :)
12:56:57 <ndm> ddarius: its easy to simplify, but its hard to get minimal simplifications (i didn't manage it)
12:57:01 <SamB> ndm: how hard could it be to take such a program and have it work on some practical regexes?
12:57:13 <sorear> dmhouse: in an hour or two, yes
12:57:19 <Saizan> oh well, reducing a DFA i got b*(a+b|(a|b)a*(a|b(a|b)*a))(ba*b|a(a|b)*a|ba*(a|b(a|b)*a)* and was just curious if i could factor it
12:57:25 <ndm> SamB: its an entirely different problem
12:57:38 <ndm> Saizan: yes, my 3rd year project could probably have been able to get that simpler
12:57:39 <dmhouse> sorear: I'll paste it to hpaste.org using the module itself as a proof of concept :) My email address is in the file if you have any comment whenever.
12:57:47 <chessguy> oh, whoops
12:57:54 <chessguy> i should change its name
12:57:58 <sorear> lambdabot: @help
12:58:03 <sorear> bye.
12:58:05 <dmhouse> chessguy: that yours?
12:58:07 <chessguy> ya
12:58:09 <dmhouse> sorear: thanks, and bye.
12:58:27 <SamB> I thought sorear was saying byte to lambdabot?
12:58:36 <SamB> er.
12:58:39 <SamB> s/byte/bye/ ;-)
12:58:40 <ndm> Saizan: they are hard to do manually, but that does look like its simplifyable
12:58:53 <ndm> Saizan: in my experience, the DFA -> RegExp algoirhtm is very lossy
12:59:02 <ddarius> ndm: I'm asking without having thought about it, but how would you know that you have the minimal simplification?
12:59:36 <Saizan> yes it has many repetitions, but it's not obvious to me how to proceed, however it was just curiosity :)
13:00:14 <chessguy> > 3
13:00:16 <lb>  3
13:00:17 <dmhouse> ?tell sorear http://hpaste.org/1392 It doesn't do annotations (yet). It might do by the time you get back. :)
13:00:18 <lb> Consider it noted.
13:00:18 <ndm> Saizan: i'd give up on it, the tool i produced never got polished enough to be useable
13:00:23 <ROBO-chessguy> Consider it noted.
13:00:44 <SamB> ndm: gunzip is lossy, too!
13:00:46 <ndm> ddarius: you don't, you can define a partial ordering (structural inclusion), and depth bounds, star bounds etc, but usually there is an intuative feel
13:00:56 <chessguy> > 3
13:00:58 <lb>  3
13:01:19 <ventonegro> @dice 3d4 + 1
13:01:20 <lb> 3d4 + 1 => 9
13:01:27 <ROBO-chessguy> 3d4 + 1 => 10
13:01:34 <SamB> oh, I see, he's gone to lunch.
13:01:35 <ndm> ddarius: i did define a simpliciation ordering in my project, as part of a terminatino proof, but its not incredibly useful - you have to decide between left and right factoring etc which are pretty much equivalent
13:01:37 <ddarius> @dice 1d2
13:01:37 <ROBO-chessguy> 1d2 => 2
13:01:37 <lb> 1d2 => 2
13:01:37 <ventonegro> RPG bots
13:01:39 * SamB was playing ZZT
13:01:52 <fuzan> @dice 1d1
13:01:52 <ROBO-chessguy> 1d1 => 1
13:01:52 <lb> 1d1 => 1
13:02:06 <fuzan> a one sided die! how does it work!?
13:02:28 <ddarius> It's a coin with the same image on each side.
13:02:33 <ventonegro> a coin with 1 on two faces :-)
13:02:36 <fuzan> hah :)
13:02:42 <fuzan> @dice 0d0
13:02:42 <ROBO-chessguy> 0d0 => 0
13:02:42 <lb> 0d0 => 0
13:02:47 <fuzan> explain that one?
13:02:54 <xerox> there is no dice
13:03:00 <fuzan> @dice 1d0
13:03:01 <lb> 1d0 => 0
13:03:09 <dmhouse> ?dice 1d6
13:03:10 <lb> 1d6 => 4
13:03:12 <dmhouse> ?dice 1d6
13:03:12 <lb> 1d6 => 4
13:03:16 <dmhouse> ?dice 1d6
13:03:16 <lb> 1d6 => 2
13:03:18 <vincenz> please use pm
13:03:22 <chessguy> don't try to roll a 0-sided dice, for that's impossible. instead, realize that it's your mind that rolls
13:04:12 <chessguy> interesting, whenever i try to @run something, i get Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
13:06:23 <Saizan> 1st result for "regular expression simplifier" is ndm :D
13:07:32 <DRMacIver> I wonder why regular expressions are so popular.
13:07:47 <DRMacIver> It's probably Perl's fault.
13:07:56 <chessguy> regexes have been around a lot longer than perl
13:08:01 <DRMacIver> Yes, obviously.
13:08:13 <DRMacIver> I'm not wondering why they exist. I'm wondering why they're so popular.
13:08:23 <chessguy> and i suspect they were popular long before perl, too
13:08:42 <dmwit> ?vixen
13:08:43 <lb> Plugin `vixen' failed with: IRCRaised Data.ByteString.last: empty ByteString
13:08:54 <DRMacIver> You could well be right. But I still suspect it's perl which made them ubiquitous.
13:09:24 <chessguy> ?spell upiquitous
13:09:25 <lb> ubiquitous iniquitous Iquitos Paquito's Iquitos's
13:09:56 <Saizan> Paquito's?
13:11:19 <DRMacIver> Anyway, I'm not tied to my perl theory. :) I'm just saying, it seems like any time anyone wants to do anything with strings, they reach for a regexp.
13:11:28 <chessguy> dmwit: interesting. any idea what causes that?
13:11:32 <dmhouse> DRMacIver: because they're an easy, hacky solution to a lot of problems.
13:11:37 <vincenz> s/a regexp/many regexps/
13:12:11 <dmhouse> DRMacIver: I.e. "I need to split a string into an array of lines. Aha, regexes!" It's just the natural one-size-fits-all tool for a lot of programmers.
13:12:29 <DRMacIver> dmhouse: But they're not easy. I mean, for the problems which they're actually good for (which certainly do exist and are important) they are, but when you get outside of these areas they start to become a real nuisance.
13:12:43 <dmwit> chessguy: I don't know.  I was just looking because I know vixen was disabled on the other lambdabot a while ago.
13:13:05 <allbery_b> perl made it easy to use regexes.  ---which means it also made it easy t use them inappropriatelyt
13:13:22 <dmhouse> DRMacIver: I dunno, they're certainly convenient for a lot of things, and for a lot of string manipulation regexes are very easy.
13:13:25 <tibbe> I was actually considering a regex versus functions solutions to parse a string template today
13:13:41 <tibbe> like "hi $name, here are some ${fruit}s"
13:13:45 <allbery_b> I'm not sure it's fair to blame perl for people pretending the swiss army chainsaw is a big regexp hammer
13:13:47 <tibbe> I used regex
13:14:01 <vincenz> allbery_b: no they already bear fruits of many other blames :)
13:14:39 <allbery_b> tibbe: in haskell I would actually use pattern mattching.
13:14:59 <dmhouse> I find that the decision as to whether to use a regex-parser or a proper-parser comes down to your signal-vs-noise ratio. If you're trying to pull a single line out of a file of uninteresting content, use a regexp. If you're trying to parse an entire file, and every line is important, a proper parser is essential.
13:15:01 <tibbe> allbery_b, ByteStrings
13:15:06 <allbery_b> expand '$':'{':xs = ...; expand '$':xs = ...; expand x:xs = x:expand xs
13:15:20 <allbery_b> (in ghc6.7 so I can pattern match bytestrings :)
13:15:23 <tibbe> expand?
13:15:31 <tibbe> oh
13:15:32 <tibbe> I see
13:15:59 <DRMacIver> dmhouse: Hm. I don't know. Certainly in Haskell, with parsec available I'm not sure regexps are actually easier any more.
13:16:08 <DRMacIver> I admit I don't do a lot of text processing in Haskell though. :)
13:16:13 <allbery_b> add one more case there, come to think of it:  expand '$':'$':xs = '$':expand xs
13:16:54 <dmhouse> DRMacIver: Parsec certainly makes things a lot easier. :)
13:17:10 <tibbe> allbery_b, but I still run 6.6 :)
13:18:16 <tibbe> allbery_b, need to match the last { also
13:18:34 <allbery_b> actually the case I missed is expand [] = [] :)
13:18:38 <tibbe> and the identifier must be valid haskell identifiers [a-z][a-zA-Z0-9_']
13:18:47 <allbery_b> I left the implementaiton of '$':'{':xs to the reader :)
13:19:04 <tibbe> and I need views for ByteStrings so I can pattern match! :D
13:19:08 <tibbe> in 6.6
13:19:17 <tibbe> but I'm actually thinking of rewriting it
13:19:29 <tibbe> since I need to thread some state (the current line, col) for error messages
13:19:45 <allbery_b> those can certainly be done; I'd use a secondary function to match the identifiers, which returns on a non-identifier; the caller then checks for (a) empty identifier (b) undefined identifier (c) in the '{' version, the next character must be '}'
13:20:20 <allbery_b> if you wnt to thread state I'd switch to parsec, certainly
13:20:28 <allbery_b> or the bytestream-capable parsec clone
13:31:12 <tibbe_> allbery_b, in my case speed is kinda important, is parsec fast enough?
13:31:51 <xerox> Yes it is, and using bytestrings it'll probably get even faster (:
13:32:08 <tibbe_> :)
13:32:18 <tibbe_> so where's this magic ByteString parsec?
13:32:26 <dmhouse> Parsec is quite fast. After SoC it'll be even faster, because you'll be able to use ByteStrings.
13:32:36 <xerox> tibbe, as soon as I finish it (:
13:32:52 * tibbe_ cheers xerox on
13:33:02 <tibbe_> on, but I need it by tonight :)
13:33:04 <vincenz> augustss: nice trick with the math overloads :)
13:33:12 <chessguy> @help run
13:33:13 <lb> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
13:33:13 <tibbe_> I guess I'll leave my regex solution in place for now
13:33:19 <augustss> vincenz: I'm working on part 2 :)
13:33:26 <tibbe_> augustss, :)
13:33:43 <augustss> It's hard work to blog
13:33:49 <vincenz> I can imagine
13:34:12 <tibbe_> I need to write my haskell web framework before I can start one ;)
13:34:22 <balodja> oh, no, why bytestring? will parsec be after this compatible with charsets?
13:35:07 <tibbe_> xerox, you have a repository somewhere?
13:35:15 <dmhouse> ?where augustss
13:35:15 <lb> I know nothing about augustss.
13:36:00 <xerox> tibbe_, not yet, I can keep you informed if you care, though
13:37:09 <tibbe_> xerox, yes please
13:37:35 * tibbe_ noticed that the next ICFP is close to his location, yay!
13:37:38 <Saizan> xerox do you plan on keeping a Char interface even for the ByteString version?
13:39:04 <Philippa> the plan isn't "a ByteString version", it's a version that'll handle any sensible stream type and some specialisations
13:39:10 <xerox> Saizan, what do you mean by Char interface?
13:39:20 <Philippa> probably [Char]
13:39:32 <Philippa> but then Parsec's already generalised on token type...
13:40:17 <ariks> didn't lb used to respond to private messages?
13:40:21 <ddarius> augustss: Blog?
13:40:40 <augustss> blog!
13:40:57 <Philippa> ariks: you're not identified to services, the bot probably can't hear you
13:41:03 <xerox> ariks, you need to tell freenode you want privmsg with unregistered users, /msg nickserv help
13:41:38 <ddarius> augustss: URL?
13:41:52 <augustss> augustss.blogspot.com
13:42:17 <Saizan> uhm well, i was just worrying about encodings.. but then i could use Data.CompactString or something like that as the stream
13:42:29 <vincenz> augustss: you're in my blogroll
13:42:48 <augustss> :)
13:43:14 <jcreigh> @where x11
13:43:14 <lb> I know nothing about x11.
13:43:22 <jcreigh> oh, right.
13:43:43 <jcreigh> I'm looking for the darcs repo of the X11 package...anybody know where it is?
13:47:40 <ariks> xerox,Philippa : that did it, thanks
13:47:55 <xerox> you're welcome
13:51:12 <thedward> jcreigh: http://darcs.haskell.org/packages/X11
13:51:13 <lb> Title: Index of /packages/X11
13:51:22 <jcreigh> thedward: thank you
13:51:29 <thedward> np
13:59:03 <hpaste>  thoughtpolice pasted "(no title)" at http://hpaste.org/1393
14:09:08 <sorear> back.
14:09:09 <lb> sorear: You have 1 new message. '/msg lb @messages' to read it.
14:09:12 <sorear> @messages'
14:09:13 <lb> Maybe you meant: messages messages?
14:09:15 <sorear> @messages
14:09:15 <lb> dmhouse said 1h 8m 57s ago: http://hpaste.org/1392 It doesn't do annotations (yet). It might do by the time you get back. :)
14:09:48 <dmhouse> It still doesn't, but it almost does.
14:10:32 <sorear> @uptime
14:10:33 <lb> uptime: 2h 31m 46s, longest uptime: 9d 2h 23m 6s
14:11:14 <sorear> ooh, haskell as root? :)
14:13:42 <ray> yeah, i named my superuser "haskell"
14:14:33 <jcreigh> @remember ray i named my superuser "haskell"
14:14:34 <lb> Not enough privileges
14:14:43 <jcreigh> awww, keep forgetting.
14:14:59 <ray> haskell:*:0:0:Haskell Curry:/root:/usr/local/bin/ghci
14:16:38 <chessguy> > (take 2 . drop 1 . words) "foo"
14:16:39 <lb>  []
14:16:46 <chessguy> > (take 2 . drop 1 . words) "foo bar"
14:16:48 <lb>  ["bar"]
14:16:56 <chessguy> > (take 2 . drop 1 . words) "foo bar baz"
14:16:58 <lb>  ["bar","baz"]
14:17:49 <narain> when did lambdabot's irc nick change to lb?
14:18:47 <narain> > (take 2 . drop 1 . words) "one two three four five"
14:18:48 <lb>  ["two","three"]
14:18:55 <sjanssen> narain: lambdabot is down for now, lb is the standin
14:19:03 <narain> huh
14:19:12 <mauke> can someone explain this error message to me?
14:19:22 <mauke> Illegal instance declaration for `CMap (Cons a b) (Cons c d)' (the Coverage Condition fails for one of the functional dependencies)
14:19:46 <narain> ?botsnack
14:19:46 <lb> :)
14:20:01 <sorear> it means ghc is stupid, and you need -fallow-undecidable-instances to beat it into submission
14:20:17 <mauke> heh
14:20:20 <Saizan> isn't it incoherent-instances?
14:20:52 <chessguy> sorear: any idea why my lb gives "Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString" every time i try to @run something?
14:20:58 <mauke> yay, works
14:20:59 <sorear> incoherent is generally a very bad idea, since it causes ghc to do random guessing
14:21:00 <dmhouse> chessguy: problem with hs-plugins?
14:21:02 <mauke> cmap (undefined :: Cons Int (Cons () Nil)) :: Cons Integer (Cons Char Nil)
14:21:09 <sorear> chessguy: you didn't build it properly
14:21:20 <chessguy> sorear: which, lb, or hs-plugins
14:21:24 <sorear> chessguy: you need to move runplugs into .
14:21:26 <sorear> chessguy: lb
14:21:37 <sorear> sh build should make it automatic...
14:22:08 <chessguy> sh build gives a bunch of errors about Regex
14:22:14 <sorear> hoogle, ft, unlambda, djinn, quickcheck, smallcheck, also affected
14:22:18 <chessguy> s/R/r/
14:22:19 <sorear> you need regex, yes
14:23:15 <chessguy> ?where regex
14:23:16 <lb> I know nothing about regex.
14:23:24 <mauke> on to the next problem
14:23:32 <mauke> how do I pass typeclasses as parameters?
14:23:50 <sorear> with oleging
14:23:59 <sorear> there is no simple way
14:24:02 <mauke> -fomg-oleg
14:24:11 <dmhouse> Hehe.
14:24:19 <dmhouse> mauke: what's the specific problem/
14:24:19 <sorear> @google haskell regex library
14:24:21 <lb> http://www.dcs.gla.ac.uk/~meurig/regexp/
14:24:21 <lb> Title: Regular Expressions in Haskell
14:24:25 <mauke> bah. I want higher-order typeclasses!
14:24:32 <sorear> @google regex site:haskell.org
14:24:33 <lb> http://darcs.haskell.org/packages/regex-base/
14:24:34 <lb> Title: Index of /packages/regex-base
14:24:58 <mauke> dmhouse: I have defined a list "type" at the type level, with data Nil; data Cons a b
14:25:05 <sorear> chessguy: I think you want that. (it's a standard extralib, so it should have been installed by your os)
14:25:29 <mauke> as I understand it, typeclasses are relations on types
14:25:36 <mauke> properly restricted relations are functions
14:25:47 <chessguy> i have extralibs installed
14:25:50 <mauke> so I can write functions like length or map as classes
14:25:59 <sorear> mauke: you just redefined the HList types - you might want to use/look at Oleg's relation lib
14:26:03 <sorear> @where HList
14:26:03 <lb> http://homepages.cwi.nl/~ralf/HList
14:26:06 <chessguy> ermm. i thought i did
14:26:13 <mauke> but map wants another function as its first argument
14:26:21 <narain> is there a more idiomatic way of writing  if foo then Just bar else Nothing ?
14:26:21 <mauke> my current version uses a hardcoded F class
14:26:34 <sorear> narain: no :(
14:26:34 * narain likes to pick up language-specific idioms
14:26:42 <chessguy> it seems that things that i thought were installed are not showing up in ghc-pkg list today
14:26:42 <narain> sorear: oh, ok
14:26:49 <narain> thanks
14:27:03 <sorear> chessguy: you wouldn't by any chance have reinstalled GHC recently?
14:27:03 <Heffalump> @pl \x y -> if x then Just y else Nothing
14:27:04 <lb> flip flip Nothing . (. Just) . if'
14:27:11 <chessguy> not for a few months
14:27:12 <Heffalump> perhaps not :-)
14:27:19 <narain> :)
14:27:35 <dmhouse> ?hoogle boolToMaybe
14:27:36 <lb> No matches found
14:27:46 <Heffalump> it seems like there should be.
14:27:53 <narain> > let maybeIf foo bar = if foo then Just bar else Nothing in maybeIf true 42
14:27:54 <lb>   Not in scope: `true'
14:27:57 <mauke> :t \foo bar -> do {guard foo; return bar}
14:27:58 <dmhouse> I thought there was. Perhaps I just define it everywhere myself.
14:27:59 <lb> forall (t :: * -> *) t1. (MonadPlus t) => Bool -> t1 -> t t1
14:28:03 <narain> > let maybeIf foo bar = if foo then Just bar else Nothing in maybeIf True 42
14:28:05 <lb>  Just 42
14:28:15 <narain> dmhouse: what do you call it?
14:28:20 <dmhouse> narain: boolToMaybe.
14:28:21 <narain> oh, boolToMaybe
14:28:33 <dmhouse> Heffalump: submit a libraries@ request! :)
14:28:35 <narain> how does maybeIf sound?
14:28:42 <mauke> > let maybeIf foo bar = guard foo >> return bar in maybeIf True 42
14:28:44 <lb>   add an instance declaration for (Show (m t))
14:28:49 <mauke> > let maybeIf foo bar = guard foo >> return bar in maybeIf True 42 :: Maybe Int
14:28:49 <dmhouse> boolToMaybe sounds more obvious for me.
14:28:51 <lb>  Just 42
14:28:56 <sorear> augustss: http://planet.haskell.org/policy.html, you definitely are the kind they want to add
14:28:57 <lb> Title: Membership policy - Planet Haskell
14:29:02 <sorear> I like boolToMaybe.
14:29:06 <narain> ?hoogle toMaybe
14:29:07 <lb> Maybe.listToMaybe :: [a] -> Maybe a
14:29:07 <lb> System.Win32.Types.numToMaybe :: Num a => a -> Maybe a
14:29:07 <lb> System.Win32.Types.ptrToMaybe :: Ptr a -> Maybe (Ptr a)
14:29:21 <narain> i see
14:29:27 <Heffalump> @pl \foo bar -> do {guard foo; return bar}
14:29:28 <lb> (line 1, column 16):
14:29:28 <lb> unexpected "{"
14:29:28 <lb> expecting variable, "(", operator or end of input
14:29:34 <chessguy> i'm still getting lots of "Plugin/Eval.hs:185:21: Not in scope: `regex''" when i try to sh build
14:29:39 <Heffalump> @pl \foo bar -> guard foo >> return bar
14:29:40 <lb> (. return) . (>>) . guard
14:29:46 <Heffalump> much nicer ;-)
14:30:21 <chessguy> ?src guard
14:30:22 <lb> guard True  =  return ()
14:30:22 <lb> guard False =  mzero
14:30:35 <Saizan> ?type when
14:30:37 <lb> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
14:30:47 <dmhouse> It'd be [ y | x ], with the old monad comprehensions.
14:30:50 * narain wonders whether he should define  boolToMaybe  or just use  guard foo >> return bar  everywhere
14:30:52 <ddarius_> narain: guard foo >> return bar
14:31:06 <Heffalump> I suggest boolToMaybe.
14:31:19 <mauke> > when False 42 :: Maybe Int
14:31:20 <lb>  Couldn't match expected type `Int' against inferred type `()'
14:31:38 <Heffalump> > when False (return 42) :: Maybe Int
14:31:39 <lb>  Couldn't match expected type `Int' against inferred type `()'
14:31:39 <narain> ddarius_: yes, mauke suggested it
14:31:40 <dmhouse> mauke: when :: Bool -> m ().
14:31:41 <ddarius_> @type when
14:31:42 <chessguy> ?hoogle suffix
14:31:44 <lb> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
14:31:44 <lb> List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
14:31:44 <lb> Distribution.PreProcess.knownSuffixHandlers :: [PPSuffixHandler]
14:31:44 <lb> Distribution.PreProcess.ppSuffixes :: [PPSuffixHandler] -> [String]
14:31:45 <narain> thanks, mauke, ddarius_
14:31:53 <Saizan> ?src when
14:31:54 <lb> when p s = if p then s else return ()
14:32:14 <mauke> has anyone written a haskell syntax frontend for lisp?
14:32:31 <dmhouse> mauke: someone's done the opposite.
14:32:37 <sorear> therp wrote a lisp syntax for haskell
14:32:39 <ddarius_> Lithp?
14:32:42 <sorear> @google liskell
14:32:43 <lb> http://clemens.endorphin.org/liskell
14:32:43 <lb> Title: Liskell - clemens.endorphin.org
14:32:56 <balodja> guys. is there a library that performs ByteString input/output?
14:33:19 <Saizan> Data.ByteString?
14:33:25 <mauke> inspired by a post on haskell-cafe I wrote http://rafb.net/p/EeQIp470.html
14:33:26 <lb> Title: Nopaste - No description
14:33:32 <DRMacIver`> Liskell still scares me.
14:33:54 <DRMacIver`> (Not, admittedly, for any good reason)
14:33:59 <balodja> Saizan: i mean something like getLine or putStrLn
14:35:19 <jcreigh> sjanssen: I sent you a patch to X11-extras that removes the Xinerama dependency via autoconf magic. (Unfortunately, this means that you now need autoconf to build from darcs.)
14:35:34 <dmead> woah
14:35:41 <dmead> i had this idea to represent monads
14:35:50 <dmead> and here i see a picture of the same dealy
14:35:51 <dmead> http://www.datastructures.info/wp-content/uploads/2006/12/sorting.jpg
14:35:52 <sorear> whick one?
14:35:58 <lb> http://tinyurl.com/34hj6r
14:36:01 <dmead> monads are the holes... of different shapes
14:36:06 <dmead> that let things through to the pure world inside
14:36:10 <dmead> y/n?
14:36:53 <DRMacIver> I think explaining monads via their role in IO, etc. is possibly a bad approach.
14:36:56 <sorear> n, I think ... but I might just not be being creative enough ;)
14:37:03 <Saizan> balodja: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-ByteString.html#v%3AgetLine
14:37:04 <lb> http://tinyurl.com/wn5rt
14:37:18 <narain> ?quote warm fuzzy
14:37:19 <lb> No quotes for this person. I feel much better now.
14:37:26 <dmead> DRMacIver io monad then
14:37:36 <dmead> monads in io is really what is confusing
14:37:36 <narain> ?help quote
14:37:37 <lb> quote <nick>
14:37:37 <lb> remember <nick> <quote>
14:37:37 <lb> Quote somebody, a random person, or save a memorable quote
14:37:37 <jcreigh> monads are like a Haskell typeclass consisting of return and >>= which obey certain laws. :)
14:37:45 <dmead> monads themselves are really not hard
14:37:55 <DRMacIver> Yeah, but they scare people. :)
14:38:05 * sorear scares monads
14:38:08 <dmead> right, because of the i/o useage
14:38:09 <dmead> :P
14:38:11 <dmead> rawr
14:38:12 <allbery_b> @quote warm.*fuzzy
14:38:13 <lb> No quotes match. Do you think like you type?
14:38:14 <DRMacIver> And people tend to come at them via their role in IO, which makes them look scarier.
14:38:19 <balodja> Saizan: hm-m-m, great thanks :) i have mispointed that :)
14:38:26 <narain> ?quote fuzzy
14:38:26 <lb> No quotes match. Sorry about this, I know it's a bit silly.
14:38:32 <jcreigh> allbery_b: I don't know if lb has lambdabot's quote database...
14:38:39 <narain> ?quote
14:38:39 <lb> Daveman says: Cale, what if I don't want to obey the laws?  Do they throw me in jail with the other bad monads?
14:38:42 <dmhouse> Nah, monads are just monoids in an endofunctor category. What more do you need?
14:39:06 <narain> dmhouse: category theory 101, that's what
14:39:24 <dmhouse> narain: http://en.wikibooks.org/wiki/Haskell/Category_theory
14:39:25 <lb> Title: Haskell/Category theory - Wikibooks, collection of open-content textbooks
14:39:27 <dmead> indeed
14:39:32 <dmead> i do need ct 101
14:39:40 <dmead> awesome.
14:39:57 <narain> oh sure, tell me to rtfm ;)
14:40:06 <dmhouse> Email me with complaints about that if you want to, I wrote it. :)
14:40:20 <narain> (actually, i will go read it)
14:40:41 <narain> you wrote it? awesome
14:40:44 <narain> dmhouse++
14:40:59 <sjanssen> jcreigh++
14:41:11 <glguy> hpaste++
14:41:16 <sorear> please, wait
14:41:34 <sorear> lambdabot will return any day now
14:41:38 <glguy> none of these count
14:41:39 <glguy> :)
14:41:42 <glguy> sorear++
14:42:02 <DRMacIver> The extensive use of ++ in #haskell amuses me slightly. :)
14:42:18 <glguy> DRMacIver: it's an actual command though :)
14:42:21 <chessguy> i don't know that i'd call it extensive
14:42:30 <narain> ?tell lambdabot dmhouse++
14:42:31 <lb> Consider it noted.
14:42:38 <narain> :)
14:42:42 <DRMacIver> glguy: Yeah, but it gives a parse error. ;)
14:42:49 <dmhouse> DRMacIver: yeah, it seems that life is inherently imperative.
14:43:18 <narain> of course not, we're constructing sections that append people
14:43:40 <DRMacIver> Wouldn't that be (++)narain ?
14:43:43 <chessguy> @quote endo
14:43:43 <lb> psykotic says: [monads aren't hard] they're just monoids on the category of endofunctors over some category, what's the big deal?
14:43:50 <glguy> DRMacIver: no, that would not be a section
14:43:51 <narain> ...prepend
14:43:53 <dmhouse> (++ narain), most likely.
14:44:16 <DRMacIver> oh. I didn't know that worked. :)
14:44:27 * sorear starts hacking hpaste
14:44:36 <narain> > let DRMacIver = "DRMacIver" in (DRMacIver++)
14:44:37 <lb>   Not in scope: data constructor `DRMacIver'
14:44:42 <chessguy> @type (++)?narain
14:44:45 <lb> forall a. (?narain::[a]) => [a] -> [a]
14:44:47 <dmhouse> DRMacIver: http://en.wikibooks.org/wiki/Haskell/More_on_functions#Infix_versus_Prefix
14:44:49 <lb> http://tinyurl.com/yxvt8f
14:44:56 <narain> ?type (?dmhouse++)
14:44:58 <dmhouse> sorear: whatcha doing to it?
14:44:58 <lb> forall a. (?dmhouse::[a]) => [a] -> [a]
14:44:59 <DRMacIver> Thanks.
14:45:02 <chessguy> @type (++ ?narain)
14:45:05 <lb> forall a. (?narain::[a]) => [a] -> [a]
14:45:10 <dmhouse> narain: what's with the implicit parameters?
14:45:13 <sorear> dmhouse: making your life easier!
14:45:24 <sorear> dmhouse: adding a sexp-style rc page
14:45:34 <dmhouse> sorear: RC?
14:45:48 <narain> dmhouse: so i don't have to do (\foo -> ...) instead?
14:45:48 <sorear> ecent hanges
14:46:09 * sorear invented the implicit parameters in @type trick
14:46:24 <dmhouse> ... seems an obfuscating way of doing it.
14:46:41 <chessguy> i like implicit parameters
14:47:00 <jcreigh> sjanssen: It kinda sucks to have to introduce autoconf, but I'm hoping that setting cc-options and ld-options from X_CFLAGS and X_LIBS (which ./configure leaves blank on my system; hoping that just means my system doesn't need special paths to build against X) will make it easier to build X11-extras on different systems.
14:47:02 <narain> i thought it was easier than correlating params in the lambda to parts of the type :t returns
14:47:13 <sorear> implicit parameters are scheduled for removal in ghc 6.8
14:47:15 <dmhouse> I loved the bit in the implicit parameters paper that showed they're essentially equivalent to typeclasses.
14:47:26 <xerox> :(
14:47:32 <dmhouse> sorear: because no-one uses them?
14:47:48 <sorear> I think that's why, not completely sure
14:48:21 * chessguy considers starting a petition on the mailing lists to "save implicit parameters!"
14:50:20 <sjanssen> jcreigh: I know dons has to manually edit X11-extras.cabal to build on OpenBSD, we'll have to ask him if autoconf fixes that
14:51:24 <eumenides> how do i... uhm.. lift a monad into IO? or more concretely, i have a StateT monad and want to forkIO a function on it
14:51:39 <sjanssen> @hoogle lift
14:51:40 <lb> Control.Monad.Trans.lift :: (MonadTrans t, Monad m) => m a -> t m a
14:51:40 <lb> Text.ParserCombinators.ReadPrec.lift :: ReadP a -> ReadPrec a
14:51:40 <lb> Language.Haskell.TH.Syntax.lift :: Lift t => t -> Q Exp
14:51:41 <sjanssen> @hoogle liftIO
14:51:42 <lb> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
14:51:51 <sjanssen> eumenides: either of those should work
14:53:01 <narain> > let foo _ _ = () in foo 1 2
14:53:03 <lb>  ()
14:53:06 <nominolo> @instances MonadIO
14:53:08 <lb> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
14:53:13 <sorear> glguy: once I add machine readable rc-feeding, how would you feel about killing the bot?  (letting lb take over)
14:53:20 <narain> > let foo x x = () in foo 1 2
14:53:21 <lb>      Conflicting definitions for `x'
14:53:21 <lb>     In the definition of `foo'
14:53:35 <sorear> patterns must be linear, sorry
14:53:37 <glguy> sorear: sounds fine
14:53:38 <sorear> @let x = 2
14:53:39 <lb> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
14:53:53 <sorear> hm, seems I too forgot to rebuild regex
14:53:56 <monochrom> > let x x = () in x ()
14:53:58 <lb>  ()
14:54:06 <eumenides> no, the other way around. I have a function reader :: StateT Blah IO (), I want to forkIO reader. lift doesn't seem to work ("Couldn't match expected type `IO' against inferred type `t H'")
14:54:14 <monochrom> I defy physics!
14:54:44 <sorear> eumenides: right.  StateT is deterministic - how can that cooperate with IO forking?
14:54:58 <sorear> you can do that with ReaderT (IORef Blah) IO ()
14:54:59 <nominolo> :t forkIO
14:55:01 <lb> Not in scope: `forkIO'
14:55:11 <sorear> :t Control.Concurrent.forkIO
14:55:14 <lb> IO () -> IO GHC.Conc.ThreadId
14:55:26 <eumenides> sorear: ah.
14:55:36 <chessguy> @go 32256 in hex
14:55:37 <lb> 32,256 = 0x7E00
14:55:37 <nominolo> eumenides: forkIO (runStateT ...)
14:56:33 <chessguy> @go 504 in hex
14:56:34 <lb> 504 = 0x1F8
14:57:01 <monochrom> Since forkIO forks two IO actions, they won't have access to your State.  Even after lifting.
14:57:05 <nominolo> @go "answer to life, the universe, and everything" * pi
14:57:07 <lb> http://www.freerepublic.com/focus/f-news/1435613/posts
14:57:07 <lb> Title: Man breaks 'pi' memory record
14:58:07 <dmhouse> ?go the answer to life, the universe and everything
14:58:08 <lb> http://en.wikipedia.org/wiki/The_Answer_to_Life,_the_Universe,_and_Everything
14:58:08 <lb> Title: Answer to Life, the Universe, and Everything - Wikipedia, the free encyclopedia
14:58:14 <dmhouse> Bah. It does work.
14:58:21 <nominolo> it used to, yep
14:58:30 <eumenides> eh. i'll just pass it the arguments it needs and let it dwell in IO
14:58:33 <dmhouse> http://www.google.co.uk/search?q=the%20answer%20to%20life%2C%20the%20universe%20and%20everything
14:58:34 <lb> Title: the answer to life, the universe and everything - Google Search, http://tinyurl.com/yprnlb
14:58:40 <dmhouse> ?go 4 * 8
14:58:44 <lb> 4 * 8 = 32
14:58:47 <monochrom> Yes, you have to do that.
14:58:49 <dmhouse> Hrm. Odd.
14:58:55 <dmhouse> ?go the speed of light
14:58:56 <lb> http://en.wikipedia.org/wiki/Speed_of_light
14:58:56 <lb> Title: Speed of light - Wikipedia, the free encyclopedia
14:59:04 <chessguy> Haraguchi, 59, recited pi, the ratio of the circumference of a circle to its diameter, to 83,431 decimal places.
14:59:04 <chessguy> That is an irrational thing to do.
14:59:10 <dmhouse> It doesn't seem to be able to fetch constants from Google Calculator.
14:59:23 <dmhouse> chessguy: he must have quite a complex.
14:59:30 <ddarius> Death to implicit parameters!
14:59:37 <chessguy> @slap ddarius
14:59:38 <lb> Not enough privileges
14:59:47 <sorear> @slap ddarius
14:59:47 * chessguy kicks lb
14:59:47 * lb smacks ddarius about with a large trout
15:00:11 * sorear has no idea why slap is suddenly a privledged command
15:00:36 <nominolo> sorear: it's violent, of course
15:01:12 <chessguy> "Unfortunately, he began this quest twenty years ago after a mistranslation convinced him that the answer to life, the universe, and everything was pi, instead of 42. Maybe when he gets done memorizing ALL of the digits of pi, the universe will be replaced with something more inexplicable."
15:01:15 * chessguy giggles
15:01:56 <narain> chessguy: haha, is that actually in the article?
15:02:04 <chessguy> in the comments
15:02:07 <bwerf> its good :)
15:02:20 <chessguy> so is the 'irrational' comment
15:03:17 <narain> he's a mental health counsellor. there's a snarky comment in there somewhere
15:03:54 <chessguy> woohoooooooooooooooooo!!!!!! my TAPL just arrived!
15:04:20 <DRMacIver> I really need to finish reading that.
15:04:31 * chessguy does a typical dance
15:04:59 <dmhouse> Me too.
15:04:59 <DRMacIver> But then I doubt I have less than 10,000 pages worth of books I need to finish reading.
15:05:14 <DRMacIver> Well, maybe that's a bit much. 5000 easily though.
15:07:15 <monochrom> An arrow a day keeps the newbie away!
15:07:17 <nominolo> TAPL is cool
15:07:49 <nominolo> I'm considering getting ATiTAPL
15:08:18 <dmhouse> I've just got on to the Polymorphism chapter of TAPL, which promises to be the most interesting.
15:08:35 <nominolo> why?
15:08:42 <dmhouse> Although subtyping is cool, polymorphism is more relevant to Haskell. :)
15:08:43 <sorear> I still don't have TaPL.
15:09:08 * ddarius would only get ATTAPL if he got either.
15:09:22 <narain> :t guard
15:09:25 <lb> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
15:09:26 * sjanssen needs to finish TAPL too
15:09:42 <sjanssen> hmm, maybe I'll read it right now
15:09:49 * nominolo is at system F_omega (higher-order polymorphism)
15:10:37 <nominolo> the iso-recursive subtyping chapter was quite hard to read though
15:11:44 <sorear> System F-omega was HARD to reconstruct just from what I've seen on the 'net.
15:12:15 <nominolo> sorear: yes, the wikipedia article sucks
15:12:25 <nominolo> i wonder if ATTAPL has some good chapters on type inference
15:12:53 <nominolo> i would like some more text to the notes wadler linked to a while ago
15:12:53 <sorear> I suspect that type inference suffers badly from the beginner's mind effect.
15:13:15 <nominolo> in ATTAPL?
15:13:22 <sorear> I hesitate to read anything on the subject until I get around to implementing my pure bottom up inference engine.
15:13:47 <monochrom> what is the beginner's mind effect?
15:14:02 <nominolo> sorear: I guess you're likely to end up with something like milner's algorithm
15:14:31 <nominolo> but that's a good starting point to the notes :)
15:14:39 <sorear> milner's algorithm?
15:14:49 <sorear> when I say pure bottom up, I mean it
15:15:05 <sorear> for instance, there is no inherited attribute 'types of let-bound variables'
15:15:17 <sorear> every term has a type, *independant of context*
15:15:52 <ddarius> nominolo: I don't think there's much in TAPL that would be new/useful to me.
15:16:29 <monochrom> I want to download your brain.
15:16:36 <nominolo> ddarius: well, yes, if you know haskell it's kinda disappointing
15:17:09 <nominolo> though, it's very well-written, nevertheless
15:17:14 <monochrom> Oh, really?  Then I don't need to download your brain.
15:17:15 <sorear> monochrom: can you tee a copy for me?
15:17:18 <nominolo> of course it's pretty formal, oo
15:17:19 <dmhouse> nominolo: I'd disagree about that.
15:17:23 <nominolo> /oo/too/
15:17:37 <dmhouse> nominolo: there's plenty in TAPL which you wouldn't know if you're an average Haskell programmer.
15:18:05 <dmhouse> nominolo: I guess if you've done formal classes on Haskell then what you're saying might hold, but I haven't, and a lot of TAPL is new.
15:18:22 <nominolo> hm, fair enough
15:18:24 <ddarius> nominolo: I pretty certain it's a good book, and if I could get it for free or very very cheap I would get it, but otherwise it's not very worth it to me.
15:18:24 <dmhouse> E.g. about a third of the book is on subtyping, that's something that has no relevance to Haskell whatsoever.
15:18:58 <ddarius> But then I've only read maybe 3 (hardcopy) books on programming (stretching the meaning of programming a bit).
15:19:06 <nominolo> dmhouse: i guess oleg would disagree ;)
15:19:22 <dmhouse> nominolo: hehe, probably. :)
15:20:17 <ddarius> sorear: To infer types bottom up and have them be independent of context would require properties of the type system, not just the type inference algorithm.
15:21:00 <sorear> ddarius: I realised that.
15:21:10 <nominolo> ok, I took a course in type theorie and functional programming.  This covered a lot of the basics, so TAPL felt kind of slow to me.  but i'd still recommend it anytime
15:21:21 <sorear> ddarius: for instance, such an algorithm guarantees principle types by construction
15:21:36 <sorear> ddarius: thus, it needs an underlying system which has them
15:21:53 <dmhouse> hpaste: ping
15:22:04 <sorear> you're back!!
15:22:05 <dons> ?uptime
15:22:05 <lb> uptime: 3h 43m 17s, longest uptime: 9d 2h 23m 6s
15:22:12 <hpaste>  dmhouse annotated "Final hpaste.el 1.0 version. This should work. :)" with "(no title)" at http://hpaste.org/1395#a1
15:22:15 <dons> i wonder if they turned the power off
15:22:18 * sorear throws himself at dons like a long-lost relative
15:22:21 <sorear> they did
15:22:24 <dons> yikes!
15:22:40 <sorear> bot's been gone for almost a day
15:22:46 <dons> ah, lambdabot's machine is going to stay down till dcoutts can turn it on.
15:22:54 <sorear> dcoutts already did
15:23:06 <sorear> but apparently manzano is waiting for your password :(
15:23:09 * dons tries ssh
15:23:14 <dons> ah, it is up
15:23:42 <dons> ?time dcoutts
15:24:00 <nominolo> time for a fail-over protocol for lambdabot ... ;)
15:24:30 <narain> :t minimumBy
15:24:33 <lb> forall a. (a -> a -> Ordering) -> [a] -> a
15:24:51 <monochrom> We have enough active people in the channel to simulate lambdabot
15:24:56 <narain> the  comparing  function is only in ghc 6.6, right?
15:25:02 <narain> :t comparing
15:25:05 <lb> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
15:25:08 <dmhouse> narain: yep
15:25:37 <sorear> we've got a good enough one, it's called <nominolo> can't someone else run an instance of lambdabot?
15:25:51 <sorear> that's our failover protocol :)
15:26:09 <jcreigh> monochrom: good 'ol mechanical turk, eh?
15:26:27 <monochrom> instance Lambdabot where { @type = undefined; @pl = undefined; @where = undefined; ... }
15:26:57 <dmhouse> instance Lambdabot where { ?pl = xerox, ?where = shapr, ... }
15:27:59 <dmhouse> Okay, who wants to help test hpaste integration into Emacs?
15:28:33 <monochrom> @remember <dmhouse> instance Lambdabot where { ?pl = xerox, ?where = shapr, ... }
15:28:33 <lb> Not enough privileges
15:28:42 * nominolo 's got emacs?
15:28:49 <monochrom> OH! I keep forgetting.
15:28:49 <nominolo> what do i have to do?
15:29:34 <dmhouse> nominolo: download http://hpaste.org/1395#a0, stick it in your load-path somewhere, M-: (require 'hpaste), then use one of hpaste-paste-buffer or hpaste-paste-region to test it :)
15:29:50 <dmhouse> (You obviously have to have a region active for the latter to work.)
15:30:51 <dons> so did we take over the world while I was gone?
15:31:05 <droundy> yes.  And you missed it.
15:31:08 <dons> droundy: hey!
15:31:15 * dons waves from Portland
15:31:16 <droundy> :)
15:31:28 <droundy> Oh my.  Any chance you can make it down to Corvallis?
15:31:50 <dons> probably not :( I'm only here 4 days.
15:31:59 <droundy> :(
15:32:02 <bos> wow, in portland already? fast mover.
15:32:10 <dons> heh. nah. just landed.
15:32:13 <dons> and its sunny!
15:32:21 <jcreigh> Portland, OR, USA?
15:32:29 <dons> oui.
15:32:37 <bos> it's the australian functional programming invasion.
15:32:43 <jcreigh> bos: heh
15:33:07 <bos> fergus henderson has established a beachhead in los angeles.
15:33:08 <dons> hehe
15:33:12 <dons> wow.
15:33:16 <bos> (i lie.)
15:33:20 <dons> and I was just pondering why I didn't know any programmers in LA ;-)
15:33:34 <bos> sorear is almost in LA
15:33:38 <dons> yeah.
15:33:52 <bos> (a statement guaranteed to annoy most san diegans, alas)
15:34:00 <dons> heh
15:34:03 <Excedrin> how do you specify guards on one line? "f x | x < 123 = 1; | otherwise = 2" ?
15:34:10 <sorear> s/;//
15:34:12 <dons> no ;
15:34:20 <Excedrin> thanks :)
15:34:21 <dons> > let f | True = 1 | False = 2 in f
15:34:23 <lb>  1
15:34:29 <dons> fun syntax, no?
15:34:32 <nominolo> hm
15:34:36 <nominolo> @where hpaste
15:34:37 <lb> I know nothing about hpaste.
15:34:42 <nominolo> @go hpaste
15:34:43 <lb> Plugin `search' failed with: IRCRaised Lib.URL.isTextHTML: getHeader failed
15:34:49 <dmhouse> nominolo: hpaste.org
15:34:50 <monochrom> http://hpaste.org/
15:35:04 <nominolo> hm
15:35:07 <nominolo> it did work
15:35:09 <dons> i'm a bit too exhausted to set up lambdabot yet, sorear (btw).
15:35:11 <nominolo> but it didn't announce
15:35:12 <mr_tenor> dons: cool generative code specialisation paper!
15:35:14 <dons> maybe in a few hours.
15:35:16 <dons> mr_tenor: cheers.
15:35:27 <dons> mr_tenor: yeah, its a nice slightly-out-of-my-comfort-zone paper :-)
15:35:29 <mr_tenor> dons: which of you is the finance enthusiast?
15:35:33 <dmhouse> nominolo: right, that's the same results that I get. Grr.
15:35:35 <dons> gabi.
15:35:49 <mr_tenor> ah :) never knew
15:35:55 <dons> i'm the dyn linker code gen enthusiast
15:36:12 <dons> and also an icc enthusiast, now. its such a fun compiler to play with.
15:36:24 <mr_tenor> it's a bit of a frankenstein paper, but that's what makes it cool imho :)
15:37:08 <dons> it was a hard paper to write.
15:37:31 <dons> the core is the code gen + dyn link + multcore + cluster == beat any C program you could feasibly write ;-)
15:37:42 <dons> but then we wanted to work out exactly where the limits of the technique were
15:38:06 <bos> dons: we need to get you a copy of pathcc, if you like icc :-)
15:38:21 <dons> hmm?
15:38:38 <mr_tenor> it's got me thinking about some of the stuff we're doing at work where we've gone "we don't know these til runtime", but they're fixed right at the start of the computation
15:38:40 <dons> though icc is a bit funny, with its "will not compile code unless you have ~/.license"
15:38:41 <bos> it's generally faster than icc by a fair margin on opterons
15:38:52 <dons> mr_tenor: ah yes. exactly that.
15:39:00 <dons> specialise!
15:39:07 <dons> bos, oh? i've not heard of it.
15:39:36 <Excedrin> does icc produce decent code on amd chips?
15:39:50 * sorear really needs to write vcc
15:40:18 <dons> Excedrin: it would be very decent I think, but the instruction scheduling would mess up a bit.
15:40:29 <dons> (the high level ops that icc does should be good for one and all)
15:40:33 <dons> opts.
15:40:39 <thetallguy> dons: I believe that John Meacham is in LA
15:41:01 <dons> oh, I thought he was in SF? that was a while ago though.
15:41:18 <bos> pathcc is a compiler i worked on for a while. it's based on the old SGI compiler suite.
15:41:27 <dons> oh, interesting.
15:41:54 <bos> and the compiler is open source, unlike icc.
15:41:56 <thetallguy> dons: Cal Tech, Pasadena, at least he was in summer of '06 or so.
15:42:08 <pejo> bos, is that the IA64 compiler?
15:42:20 <bos> pejo: the old ia64 compiler, yes.
15:42:40 <pejo> bos, does it do IA32 at all?
15:42:49 <bos> ia32, x86_64 and mips.
15:42:57 <thoughtpolice> is hs-plugins still maintained or has it been supersceeded by something else?
15:43:06 <bos> i ripped out all the ia64 support years ago :-)
15:43:23 <bos> nvidia used our code as the base for their CUDA compiler
15:43:31 <jcreigh> ia64 == itanium?
15:43:36 <bos> itanic, yes.
15:43:54 <dons> thoughtpolice: its maintained (a little), but i'd like to supercede it with ghc-api
15:45:04 <thoughtpolice> dons: ah. i was wondering because i was gettinng some annoying building errors, and it's development has seemed somewhat stagnant.
15:45:08 <thoughtpolice> *getting
15:45:27 <dons> it surely is.
15:45:40 <dons> the darcs repo should get you by on ghc 6.6 though
15:45:56 <thoughtpolice> hm alright i'll give it a shot
15:45:56 <thoughtpolice> thanks
15:46:18 <thoughtpolice> after i wrote my little packet sniffer i need something else to occupy my time, and plugins are lots of fun :)
15:47:00 <narain> ?hoogle Maybe a -> Bool
15:47:01 <lb> Maybe.isJust :: Maybe a -> Bool
15:47:01 <lb> Maybe.isNothing :: Maybe a -> Bool
15:53:04 <thoughtpolice> speaking of that would anybody mind downloading my sniffer and testing it out a little on other platforms? so far it's only been built on archlinux and debian (requires Network.Pcap)
15:54:53 <hpaste>  dmhouse pasted "hpaste.el - hpaste integration into Emacs. 1.0 version, announcing bug fixed." at http://hpaste.org/1397
15:55:41 <dmhouse> Yay! :)
15:55:55 <dmhouse> nominolo: that announcing bug has now been fixed.
15:56:10 <dmhouse> sorear: if you did want to test hpaste.el, it's now hit 1.0, and supports annotations.
15:56:34 <nominolo> dmhouse: i guessed so, from your paste title ;)
15:56:43 <dmhouse> nominolo: hehe. :)
15:56:58 <dmhouse> Right, I'm going to upload that to the Haskell wiki then announce it to the mailing lists.
16:02:44 <dcoutts> @yarr!
16:02:44 <lb> Aye
16:02:52 <dcoutts> yay, an lb
16:03:01 <dcoutts> hia dons
16:03:28 <dmhouse> dcoutts: it's sorear's.
16:03:58 <sorear> hi!
16:04:03 <dcoutts> dons: I turned the box on that I thought you said lambdabot lives on, but apparently lambdabot doesn't startup automatically
16:04:05 <dcoutts> sorear: ta
16:05:26 <dcoutts> dons: yep, we had a powercut here yesterday afternoon
16:08:24 <narain> ?pl \f1 f2 d -> map (foo f1 f2 . bar d) [-1,1]
16:08:24 <lb> (line 1, column 37):
16:08:25 <lb> unexpected "["
16:08:25 <lb> expecting variable, "(", operator or end of input
16:08:48 <narain> ?pl \f1 f2 d -> [-1,1]
16:08:48 <lb> (line 1, column 13):
16:08:49 <lb> unexpected "["
16:08:49 <lb> expecting lambda abstraction or expression
16:09:11 <narain> what's this?
16:10:26 <narain> well, never mind
16:19:16 <dons> dcoutts: wow. a power cut?
16:19:24 <dons> some hardware failure?
16:19:34 <dcoutts> yep, people were v. annoyed at loosing work :-)
16:19:45 <sorear> glguy: poke
16:20:00 <dons> scary
16:20:01 <sorear> glguy: I have machine-readable announce implemented, ~40 loc
16:20:02 <dcoutts> whole place went dark for a couple minutes and I was forced to go make some tea :-)
16:20:19 <sorear> glguy: how do I test this?  (it typechecks)
16:20:20 <dcoutts> dons: that's one advantage of a laptop, it's got batteries
16:20:41 * dons goes off to recover from jet lag
16:20:49 <sorear> funny how a desktop's UPS is usually heavier than the entire laptop.
16:20:51 <dcoutts> dons: so I can't restart lambdabot just by turning your box on ?
16:21:11 <dcoutts> dons: it is manzano right?
16:21:12 <sorear> <*dons> i'm a bit too exhausted to set up lambdabot yet, sorear (btw).
16:21:17 <sorear> dcoutts: ^
16:21:21 <dcoutts> ah ok :-)
16:21:29 <dcoutts> that's perfectly reasonable :-)
16:21:44 <sorear> lb isn't getting tired, I don't mind
16:21:47 <jcpetruzza> :t id
16:21:50 <lb> forall a. a -> a
16:22:38 <sorear> glguy: want me to do anything with my patched hpaste before sending?
16:23:03 <dons> dcoutts: i'll turn it back on later today (in an hour or two)
16:23:09 <dons> i should really script that.
16:23:10 <dcoutts> k
16:23:18 <sorear> dons: are you here for a conference or similar?
16:23:24 <dcoutts> /etc/init.d/lambdabot
16:23:35 <sorear> muahaha.
16:23:35 <dmhouse> sorear, glguy: http://haskell.org/haskellwiki/Hpaste.el
16:24:14 <sorear> dmhouse: want me to put that in a darcs sendable repo?
16:25:30 <sorear> hehe.
16:25:35 * sorear is reading Hpaste.el
16:25:39 <sorear> (or) is lazy!
16:29:36 <dmhouse> sorear: I've updated it with more docstrings if you're reading through the code.
16:29:51 <dmhouse> sorear: and also the license has changed, so don't do anything with a version that says "BSD3" on it.
16:30:29 <sorear> yeah, I was just about to ask why the version I saved had a different license token than the version on my screen :)
16:30:45 <sorear> BSD3 *is* compatible with GPL
16:31:37 <dmhouse> Yes, but someone who sounded like they knew what they were talking about on #emacs said that it has to be GPL'd, and can also be licensed under other stuff too if you want.
16:31:37 <dcoutts> it's BSD4 that isn't
16:32:06 <dmhouse> I can live with GPL. I'd prefer BSD3, but if GPL makes things easier, I'll live with that.
16:32:19 <sorear> Wiki as a VCS just ... icky to me
16:32:26 <dcoutts> some dev organisations (eg linux kernel) only accept code under GPL, not under other compatible licenses
16:33:08 <sorear> dmhouse: so, how do I give patches if it's on the wiki?
16:34:19 <jcreigh> I thought BSD3 was BSD-with-advertising clause. what's BSD4?
16:34:25 <dmhouse> sorear: email them to me.
16:34:28 <jcreigh> *without* advertising clause, rather.
16:34:40 <sorear> with advertising clause
16:34:49 <dcoutts> jcreigh: right, BSD4 is the 4-clause version, aka BSD-with-advertising
16:35:03 <jcreigh> ah, okay.
16:35:08 <dcoutts> BSD3 is the helpful sensible one
16:35:15 * jcreigh was thinking of incrementing versions numbers
16:48:26 <stepcut> grr. I once figure out how to get emacs to see new elisp modules after I apt-get install them without restart emacs. But I can never remember how :-(
16:49:55 <sorear> M-S-: (load "/foo/bar.el")
16:51:06 <stepcut> hrm
16:57:47 <stepcut> M-S-: (normal-top-level-add-subdirs-to-load-path) seems to do the trick, but I think there might be a shorter way
16:58:56 <dons> hehe, check the comment at the bottom, http://programming.reddit.com/info/1huln/comments
16:58:57 <lb> Title: Five things I didn&#39;t learn in Computer Science (reddit.com)
16:59:07 <sorear> glguy: patches lightly tested, and sent!
16:59:15 <dons> apparently lazy bytestrings are the epitome of elegant optimisation :-)
16:59:26 * dons laughs and hands around a STRICT3 pragma over Addr#
16:59:45 <emu> so long as i don't have to do it, it's elegant
17:00:20 <dons> :-)
17:00:49 <stepcut> :p
17:01:16 <sorear> bytestring is insanely ugly, but I don't care
17:01:34 <sorear> the power of haskell lets us make ugliness-tight abstraction boundaries
17:01:36 <dcoutts> sorear: we can make it prettier on the inside
17:02:17 <sorear> me too. /me spawns HsColour )
17:02:18 <augustss> then you should
17:02:23 <sorear> * :)
17:02:48 <sorear> @seen glguy
17:02:49 <lb> glguy is in #haskell. I last heard glguy speak 2h 9m 11s ago.
17:03:28 <dcoutts> augustss: it requires careful checking that we're getting back the same code, relying on various compiler optimisations including list fusion etc
17:03:54 <dcoutts> augustss: one way to make it really nice would be to use 'bytestring comprehensions' for constructing in many places
17:04:10 <dcoutts> ie much like an array comprehension
17:04:23 <dcoutts> array bounds [ ... | ... ]
17:04:43 <dons> on the outside its not ugly, mind you. fusion + strict, cache chunks + lazy tails. mmm. tasty!
17:05:17 <dcoutts> augustss: if we can make sure that kind of thing is being optimised correctly then we could make lots of bits shorter and neater
17:05:47 <dcoutts> mostly we're just trying to build simple loops that write into the bytestring chunk
17:06:41 <sorear> which are optimized *terribly* on ghc/i386
17:07:07 <sorear> bytestring would probably be a lot faster if someone figured out how to make the codeGen use variables
17:07:11 <dcoutts> sorear: it's a fusion problem if you're consuming the list comp with a foldl
17:07:14 <sorear> note, I do *not* mean the ncg
17:07:35 <dcoutts> yep, I know what you mean
17:07:42 <dcoutts> dons: perhaps for next year's HW: "ByteStrings, beautifully" :-)
17:08:19 <dons> hehe
17:08:44 <dons> "Rewriting "Rewriting Haskell Strings"" you mean?
17:08:50 <dcoutts> ha hah
17:08:51 <sorear> for those other than dcoutts: the codeGen uses the stack rather than local variables, creating a lot of false aliasing hazards in the cmm.  both -fasm and -fvia-C -optc-O2 can't recover, generating abysmal code.
17:08:51 <dcoutts> yeah
17:09:29 <dcoutts> sorear: I think the best way to describe it is that tail calls do not get turned into loops
17:09:45 <dcoutts> they use no stack space, but they do use the stack
17:10:00 <dcoutts> I mean they use constant stack space
17:10:05 <sorear> well, they turn into loops, just waay too late.
17:10:26 <sorear> the asm uses conditional (vs indirect) jumps
17:10:30 <dons> the issue about loops in cmm is known, though, sorear
17:10:47 <dons> i suspect that's part of what simonm was hinting at about the codegen work this summer
17:11:02 <dcoutts> yes, that's what he said to me
17:11:23 <dcoutts> I think the solution is for the cmm level to manage the stack and have local vars
17:11:32 <dcoutts> and do a tail call -> loop conversion pass
17:11:47 <dcoutts> but I think Simon has different plans
17:11:57 <sorear> Loops are one thing, but I'd like more.  I'd like to see some kind of arity annotation at the type level so CPS code (cf Builder) can use registers.
17:12:04 <dcoutts> he knows more about this than us of course
17:12:22 <dcoutts> sorear: that's not a cmm level thing, that's core
17:12:48 <sorear> i'd call it everything-level ;)
17:12:54 <dcoutts> sorear: I had a suggestion on how to let builder do that
17:13:04 <sorear> oh?
17:13:13 * sorear would like to improve on 10x
17:13:19 <dcoutts> oh, hmm perhaps that's slightly different from what you were thinking
17:13:34 <dcoutts> you want some kind of uniqueness analysis
17:14:09 <dcoutts> so that instead of passing vars you can allocate them and mutate them
17:14:32 <dcoutts> since you know they're being used in a single threaded way
17:14:39 <sorear> that is easy enough to do manually
17:14:50 <dcoutts> right, just ugly ugly and non-functional
17:14:56 <sorear> what I can't do, is tell ghc "this function has arity 1"
17:15:05 <dcoutts> hmm?
17:15:11 <sorear> ugly ugly doesn't matter, simplifier++
17:15:21 <sorear> my nasty code is inlined into clean client code
17:15:40 <sorear> arity analysis eliminates currying
17:15:43 <dcoutts> I prefer to have nice code and get the simplifier generate fast code
17:16:00 <sorear> so ghc for known calls just loads the stack and calls
17:16:18 <dcoutts> as opposed to what?
17:16:20 <sorear> but unknown calls, all of them, have to case-analyse on the arity of the function
17:16:30 <sorear> so we know whether to call or construct a PAP
17:16:41 <dcoutts> ah right
17:16:48 <sorear> I want to have faster unknown calls :)
17:16:58 <dcoutts> well I do take advantage of the ability to have extra args
17:17:12 <dcoutts> in the continuation in my version of Builder
17:18:05 <sorear> did I show you my version of builder?  or was that one of the other #ghc-ers
17:18:12 <dcoutts> I think you did
17:18:26 <fuzan> would this be a valid type definition for a class which could thread any type of monad? lass Visitor a where traverse :: forall k m. MonadState k m => a -> m()
17:18:32 <fuzan> s/lass/class
17:18:59 <sorear> you don't need the forall's
17:18:59 <dcoutts> sorear: we certainly talked about the tricks you used for some time
17:19:22 <fuzan> sorear: how do I get around the variables not defined errors?
17:19:42 <fuzan> inherit from MonadState ?
17:20:49 <sorear> dcoutts: I thought I was properly lurking in all the ghc dev (generic sense of the next word) channels, is this private discussion or did I miss one?
17:21:19 <fuzan> @seen pzpz
17:21:20 <lb> I haven't seen pzpz.
17:21:33 <sorear> lb only has ~4h of memory
17:21:47 <chessguy> ?uptime
17:21:48 <lb> uptime: 5h 42m 59s, longest uptime: 9d 2h 23m 6s
17:21:49 <pzpz> @seen pzpz
17:21:50 <lb> You are in #haskell. I last heard you speak just now.
17:21:53 <pzpz> :)
17:21:58 <dcoutts> sorear: you and I talked for some time about 10 days ago while you were hacking on your binary stuff, you benchmarked my example too and posted your findings to the list
17:22:16 <dcoutts> sorear: in #ghc
17:22:38 <sorear> pzpz was last seen in #haskell before today on Mar 01.
17:22:48 <sorear> dcoutts: oh, misinterpreted 'we' :)
17:23:03 <dcoutts> heh :-)
17:23:27 <pzpz> I'm trying to implement a visitor class ontop of my grammar. I want to be able to traverse through an AST and perform different actions upon it
17:23:52 <pzpz> I hardcoded my initial semantic analyzer, however, i'd like to make my code generator a little more elegant
17:23:54 <dcoutts> you just want a fold
17:24:19 <pzpz> a recursive fold?
17:24:43 <dcoutts> sure, the natural fold over the ast type
17:25:20 <pzpz> I would still need to specify how to recurse on types, wouldn't I?
17:25:34 <dcoutts> the fold will take one function per node type, so you might want to package them in a record
17:25:58 <pzpz> let rfold (S_While (Exp e) (Block b)) = rfold Block
17:27:50 <dcoutts> foldStmt (While e b) = action_while (foldExp e) (foldStmt b)
17:30:51 <pzpz> dcoutts: where action_while would be something like,  action_while :: MonadState k m => a -> b -> m ()  ?
17:31:54 <dcoutts> pzpz: something like that, there's no need to be so specific in the result type though
17:32:52 <dcoutts> you should be able to make a normal pure fold and then use it at a monadic type
17:33:24 <dcoutts> you just use >>= / >> to combine the actions from sub-branches
17:33:58 <dcoutts> you might even find it's simpler without the state monad
17:34:42 <stepcut> how can I define, 'instance MonadError Exception IO', since there is already a 'instance MonadError IOError IO', I get "Functional dependencies conflict between instance declarations"
17:35:27 <pzpz> dcoutts: what's the advantage of doing it without typeclasses?
17:35:52 <dcoutts> pzpz: it's simpler to make a normal natural fold and then use it at a monadic type
17:36:04 <dcoutts> @type foldr
17:36:07 <lb> forall a b. (a -> b -> b) -> b -> [a] -> b
17:36:07 <bd_> stepcut: You can make a new type: newtype EIO a = EIO (IO a) deriving (Monad), and define an instance of MonadTrans and MonadIO
17:36:44 <pzpz> I just hate having define so many different functions :)
17:36:44 <dcoutts> pzpz: the result is just a type var
17:37:01 <dcoutts> pzpz: but this means you can define just one!
17:37:09 <dcoutts> one most general natural fold
17:37:28 <pzpz> and n more functions for each type :)
17:38:17 <dcoutts> pzpz: in your case you'll have at least two result types, since I assume your Exp-things have different types to Stmt-things ?
17:38:30 <stepcut> bd_: hrm, that could work
17:38:34 <augustss> the ppc use to have an instruction called EIEIO
17:39:05 <dcoutts> pzpz: I mean will you have a fold on Exp types and Stmt types? or is it just one type?
17:39:14 <pzpz> they're seperate.
17:39:23 <pzpz> But I also have more.
17:39:28 <stepcut> bd_: I guess that could work. I really want a instance of 'MonadError Exception (RWST r s w)', but that gets tripped up by the 'MonadError IOError IO'
17:39:41 <sorear> and iirc EIO is also the error code for IO Error (eg "Hard disk has caught fire")
17:39:42 <pzpz> Fields, Program, etc.
17:39:48 <bd_> eh? How does that conflict...?
17:39:51 <stepcut> sorear: :p
17:39:54 <dcoutts> pzpz: so you can make a fold function per type
17:39:56 <augustss> pzpz: i think you might need something like  composop
17:40:13 <bd_> or does RWST propagate MonadError?
17:40:14 * stepcut tries out the hpaste.el
17:40:29 <augustss> http://www.cs.chalmers.se/~bringert/publ/composOp/composOp.pdf
17:40:37 <hpaste>  stepcut pasted "MonadError Exception" at http://hpaste.org/1398
17:41:46 <bd_> stepcut: Don't derive MonadError Exception, just implement it, maybe
17:42:24 <stepcut> bd_: ok, I'll give it a shot
17:43:44 <pzpz> augustss: giving it a read.
17:44:08 <bd_> hmm
17:44:14 <bd_> stepcut: actually probably easier to wrap IO
17:44:26 <bd_> simply because then RWST will handle getting it through RWST for you
17:45:09 <stepcut> show I should change the newtype to, newtype DryRunIO a = DryRunIO { runDryRunIO :: RWST Bool () () EIO a }, and define EIO as suggested above ?
17:45:50 <bd_> probably
17:47:57 <dons> i hope everyone saw http://programming.reddit.com/info/1hynt/comments
17:47:57 <lb> Title: On Haskell: Writing a packet sniffer (reddit.com)
17:48:13 <dcoutts> binary parsing?
17:48:37 <dons> nope. network.pcap though.
17:49:22 <augustss> yeah, that was cool
17:49:44 <dcoutts> we really need a cabal lint
17:49:56 <dcoutts> to warn people about putting things into the ghc-options field
17:50:01 <augustss> does network.pcap have a sane interface to pcap?
17:50:03 <dcoutts> when they should go in other fields
17:50:34 <augustss> i find Cabal rather painful to use
17:50:37 <dcoutts> like, "ghc-options: -lpcap" BAD, "extra-libraries: pcap" GOOD  :-)
17:50:58 <augustss> like a syntax error can easily generate "head on empty list"
17:51:33 <dcoutts> they should have used a better parser
17:51:53 <dcoutts> they were constrained by the only thing available in base
17:51:54 <augustss> yep
17:52:08 <dmwit> ?losers
17:52:09 <lb> Maximum users seen in #haskell: 321, currently: 304 (94.7%), active: 35 (11.5%)
17:52:19 <dcoutts> dependencies and bootstrapping can be a real pain
17:52:32 <augustss> they couldn't afford decent parser combinators?  you can define them in a page of code
17:52:46 <dcoutts> augustss: they're using ReadP I think
17:53:07 <augustss> ReadP is good.  they must have used head somewhere too :)
17:53:11 <dcoutts> they don't give nice error messages
17:53:20 <dcoutts> probably so
17:53:34 <dcoutts> augustss: well send in your bug reports :-)
17:53:40 <dcoutts> parser test cases etc
17:53:51 <augustss> i might
17:54:06 <dcoutts> problem is really that nobody wants to work on cabal
17:54:15 <dcoutts> it works just well enough
17:54:29 <augustss> yeah
17:54:40 <dcoutts> well enough that people get by but none is motivated to polish and improve it
17:54:50 <dcoutts> it doesn't help that the code is very IOish
17:54:57 <dcoutts> which puts people off
17:55:22 <dcoutts> that can be fixed of course, but it takes work
17:55:50 <lispy> i don't think IOish could should be shunned so much
17:55:50 * dcoutts would use 'the command interpreter monad pattern' :-)
17:55:56 <lispy> some of it is elegant
17:56:03 <dcoutts> lispy: the IO should be more clearly separated
17:56:21 <dcoutts> cabal code has no separation from the deciding what is to be done from the actually doing it
17:56:25 <lispy> dcoutts: to a point, yeah :)
17:56:32 <lispy> i see
17:56:45 <augustss> btw, has anyone build ghc HEAD on windows in the last few days?  it fails for me.  something cabal is trying to do
17:56:58 <lispy> augustss: it's not vista is it?
17:57:02 <augustss> nope
17:57:03 <Igloo> augustss: Have you run sh boot?
17:57:07 <augustss> yep
17:57:10 <dcoutts> I'd have the logic produce more abstract pure descriptions of what it'd like to do and then have a separate layer do the actual running of the commands
17:57:26 <augustss> Igloo: I did a fresh darcs get and followed the instructions
17:57:30 <Igloo> augustss: Some of the extralibs currently break the build if they aren't compilable; could that be it?
17:57:33 <lispy> dcoutts: okay, yeah that does sound nice
17:57:36 <dcoutts> that layer could do the UI (console, GUI etc) and decide on verbosity and possibly security
17:57:40 <augustss> Igloo: I can send you the messages
17:57:46 * Igloo will probably fix that tomorrow if so
17:57:52 <dcoutts> lispy: so logging decision would happen in exactly one place
17:57:56 <augustss> Igloo: where should I send them?
17:58:03 <Igloo> augustss: igloo@earth.li
17:59:07 <lispy> whoa, haskell is 17? cool
17:59:33 <lispy> i can't wait till haskell can vote
17:59:40 <augustss> sent
18:00:36 <Igloo> augustss: Oh, haven't seen that one before
18:00:47 <augustss> Why is it using bat files?
18:01:29 <Igloo> Because the shell scripts don't work as cabal is a Windows program
18:01:58 <augustss> hmmmm
18:02:12 <augustss> neither do the bat files, it seems
18:03:03 <Igloo> augustss: Ah, I've forgotten to update the docs - you need to pass --with-ld=c:/mingw/bin/ld.exe to configure now
18:03:04 <augustss> I ran setup with -v.  It's trying to invoke ghc (the bat file) to figure out the version when the message occurs
18:03:30 <Igloo> Oh, if it's trying to run ghc at the time then that's not the problem
18:03:41 <Igloo> (I don't think)
18:04:38 <augustss> It's calling system with "..\..\compiler\ghc-inplace.bat --numeric-version" if I remember right
18:05:36 <augustss> I tried adding c:/WINNT to my path to make sure cmd.exe was in the path, but that didn't seem to help.
18:06:10 <Igloo> Is there a space in the path where you are working?
18:07:14 <augustss> not in the path that was set at that point
18:07:41 <augustss> but in the global path there are
18:07:59 <Igloo> I mean in the working directory
18:08:36 <augustss> no
18:08:43 <Igloo> hmm
18:24:15 <TomMD> So after looking at Data.Binary (something I should have found time for long ago), I don't see _how_ to use it when reading arbitrarily formatted 'C' structures.
18:24:47 <SamB> TomMD: that is perhaps a good thing?
18:24:58 <SamB> because I think if you did see that, you'd be seeing wrong...
18:25:02 <TomMD> lol - no, interaction with the rest of the world is needed.
18:25:05 <dcoutts> do { a <- readWord8; b <- readWord32 } etc
18:25:38 <bos> for C structures in memory, you'd be wanting Storable
18:25:46 * stepcut imagines it was probably hard to look at Data.Binary long ago
18:25:52 <bos> for stuff on disk or network, Binary would be fine
18:26:05 <dcoutts> TomMD: yes as bos says, you'd probably find that the FFI lib and the Storable class are more suited
18:26:23 <TomMD> Its on the network - I assume I receive it as a [Char] then convert?
18:26:30 <TomMD> No, I desire to avoid FFI.
18:26:52 <dcoutts> ok, then receive it as a lazy bytestring and use Binary
18:27:07 <dcoutts> avoid going via [Char] if you can help it
18:27:12 <SamB> Binary doesn't look good for things with non-stream structures...
18:27:19 <TomMD> When I encode using Binary I see it has some special format
18:27:24 <dcoutts> true, it's basically linear
18:27:33 <SamB> dcoutts: exactly!
18:27:50 <TomMD> Encoding a Word32 won't look like a uint32 to my 'C' program!
18:27:56 <dcoutts> TomMD: you decide the format if you use the Get and Put, the Binary class is for serialising Haskell values, not what you want.
18:28:15 <TomMD> Where is the best documentation for the Get and Put?
18:28:21 <dcoutts> the haddock docs
18:28:31 <narain> ?seen sigfpe
18:28:31 <lb> I haven't seen sigfpe.
18:28:42 <SamB> TomMD: you aren't supposed to be reading Word32's rawly anyway...
18:28:44 <SamB> er.
18:28:49 <SamB> I meant uint32_ts
18:28:54 <SamB> either way ;-)
18:29:03 <dcoutts> why not?
18:29:29 <SamB> well, maybe it is okay if you ntohl on them after
18:30:08 <dcoutts> TomMD: Get and Put provide only low level things like getting and putting various sizes and endiannes of signed and unsigned ints
18:30:11 <TomMD> dcoutts: The only place I see Get and Put in haddock are in the Data.Binary - all of 5 lines saying they are a monad.  Am I missing something?
18:30:18 <dcoutts> hmm
18:30:22 <dcoutts> @where binary
18:30:22 <lb> http://darcs.haskell.org/binary/
18:31:18 <dcoutts> http://hackage.haskell.org/packages/archive/binary/binary-0.3.misc/doc/html/
18:31:19 <lb> http://tinyurl.com/2bl8p9
18:31:25 <dcoutts> TomMD: ^^
18:32:44 <dcoutts> SamB: yeah, so for parsing binary files that require jumping about we need a slightly different abstraction
18:32:54 <dcoutts> and it can't use a lazy bytestring
18:33:19 <SamB> yeah.
18:33:26 <dcoutts> if you want to read or write randomly then you need the whole thing in memory or you need to be in IO
18:33:37 <SamB> ndm has done something that works when you can define your own format
18:33:58 <dcoutts> it reads the file linearly though
18:34:07 <SamB> (using unsafe{Perform,Interleave}IO)
18:34:11 <dcoutts> it just defers deserialising things
18:34:29 <SamB> that isn't how I saw it!
18:34:46 <dcoutts> oh he's interleaving seeks?
18:34:53 <dcoutts> so it's not pure
18:35:00 <SamB> dunno if it is even thread safe!
18:35:06 <dcoutts> heh
18:35:17 <dcoutts> it probably is now
18:35:25 <dcoutts> that got fixed recently
18:35:31 <SamB> but I don't imagine it is much trouble to fix that
18:35:34 <SamB> anyway
18:35:35 <dcoutts> so one could have a finger tree of strict chunks and use that to give you lazy random IO
18:35:38 <dcoutts> for reading
18:36:06 <dcoutts> it'd use the same trick of interleaveIO and seeking
18:36:12 <SamB> hmm, that actually sounds pretty good. would sound better if I remembered what a finger tree was...
18:36:29 <dcoutts> SamB: read Ross Patterson's great paper on them
18:36:37 <SamB> but another nice thing would be a way to handle possibly cyclic graphs...
18:36:40 <dcoutts> it's what Data.Sequence is implemented on top of
18:40:28 <TomMD> Is there a clean (native Haskell) method of determining endianness of the host machine?
18:41:11 <lispy> TomMD: well, not really
18:41:13 <dcoutts> not very clean
18:41:17 <TomMD> (Yes, I do see the getWordXXHost methods)
18:41:21 <lispy> TomMD: but you can make lots of ways to do it easily
18:41:38 <lispy> i used a peek/poke way once..that was weird but it works
18:41:48 <lispy> the think the normal way to check is to use bit shifting
18:41:59 <TomMD> Ok - I was just hoping there was a convention.  Thanks Lispy
18:45:51 <stepcut> hrm, I think if I make a function like |try| for the RWST monad transformer, there is no way to avoid losing State and Writer information if someone calls error inside the try block. For example, inc >> (tryRWST (inc >> error "die")), will only increment the state by 1
18:46:10 <sorear> hi! back.
18:46:13 <sorear> @seen glguy
18:46:14 <lb> glguy is in #haskell. I last heard glguy speak 3h 52m 36s ago.
18:46:40 <sorear> augustss: ping
18:46:59 <stepcut> this happens, because 'error' does not pass the Writer and State monad values back up the 'stack', so those values will revert to whatever they were when tryRWST was called
18:48:17 <sorear> augustss: cancel ping
18:49:16 <narain> does sigfpe ever come into #haskell?
18:50:38 <bos> yes
18:51:26 <sorear> rather often in fact
18:51:35 <lispy> whoa, was lambdabot renamed?
18:51:38 <lispy> > 1
18:51:39 <narain> ah, so it's just that the new lb hasn't seen him
18:51:40 <lb>  1
18:51:45 <sorear> lispy: when I took over
18:51:51 <lispy> sorear: really?
18:51:57 <sorear> a week or so ago he spent a few minutes explaining dirac belts to be.
18:51:57 <lispy> dons stepped down?
18:52:07 <sorear> lispy: temporarily
18:52:08 <\Botje> (so why not \bot? :))
18:52:12 <narain> lispy: lambdabot is down, sorear's running a stand-in
18:52:13 <sorear> lispy: he's on vacation
18:52:24 <lispy> sorear: ah yeah i know about his vacation
18:52:33 <lispy> a standin makes sense
18:52:38 <sorear> because he is travelling, he can't restart the bot
18:52:38 <lispy> lambdabot always did go down from time to time
18:52:38 * narain liked Botje's nick
18:52:57 <Botje> heh :)
18:53:00 <sorear> lispy: this time it wasn't lambdabot's fault, unsw lost power
18:53:06 <Botje> but i'm not a lambda bot!
18:53:18 <narain> i wanted to convey my appreciation of sigfpe's quantum physics + vector math articles
18:53:31 <narain> if he were around
18:53:58 <sorear> narain: he comes fairly often.  don't @tell or ++ since lb won't give any memories to lambdabot
18:54:09 <sorear> do email and/or comment
18:55:10 <narain> sorear: yes, i knew not to @tell
18:56:30 <stepcut> lambdabot doesn't have mind meld capabilities :(
18:57:08 <narain> i imagine it should be possible to implement them though
18:58:49 <narain> how does lambdabot maintain its memories if it "goes down from time to time"? dump them to a file somewhere?
19:00:25 <stepcut> narain: yes
19:00:29 <sorear> yes, a set of files
19:00:35 <sorear> gzipped binary evil
19:01:28 * narain imagines patching lambdabot's memoirs with the ones lb's been saving
19:02:46 <stepcut> narain: I think the problem is figuring out how to merge the changes, since some actionss are destructive
19:03:54 <stepcut> though, I guess lb essentially started with nothing, so it is all new stuff
19:04:21 <mauke> @quote
19:04:22 <lb> apfelmus says: Haskell is the first programming language that really offers the possibility to specify data dependencies exactly as they are because Haskell is pure, higher order and has a powerful
19:04:22 <lb> type system.
19:04:28 <narain> possibly dumb/crazy idea: you could take the entire irc logs since lb's been running and feed them to lambdabot?
19:05:26 <stepcut> narain: you would probably have to filter out everything <lb> said to ensure the same results, but that could sort of work
19:05:43 <stepcut> narain: @seen would have a skewed view of things
19:06:12 <narain> that's true
19:06:47 <narain> so many plugins lb has
19:06:47 <sorear> grr. I seem to have forgotten the passphrase to ndm's haskell.org login private key
19:07:15 <stepcut> is it 12345 ?
19:07:26 <dmwit> Crap!  Now I have to change my password again.
19:07:46 <dmwit> I can't believe you guys go transmitting my password around in plaintext.
19:07:48 <dmwit> ;-)
19:08:17 <stepcut> dmwit: if you type your password in this channel ChanServ will automatically hide it for you, like ********
19:08:18 <stepcut> ;)
19:08:24 <sorear> it's not my password, my root password, my haskellwiki password, my email password, or my ghc-wiki password
19:08:31 <dmwit> I'm no bash.org newby. ;-)
19:08:38 <stepcut> :p
19:09:39 * sorear has a practice of writing down things like this, but can't find the file
19:12:08 * narain uses at most three passwords at a time: one for critical logins, one for non-critical logins, and one for very non-critical logins he needs to share with people
19:13:01 * dmwit changes his password often, but keeps a list of *old* passwords in plaintext.
19:13:27 * stepcut uses kwalletmanager
19:13:29 <dmwit> (In case he forgets to change one and doesn't remember how many revisions ago he last changed it. ;-)
19:14:03 * sorear keeps his root password written on a piece of paper next to his computer.  Anyone who can get that close doesn't need it.
19:14:34 * dmwit puts on his ninja gear
19:14:52 <narain> a true ninja is always in gear
19:15:04 <sorear> again, if you can get that close, you'd be wiser to use init=/bin/sh
19:15:34 <dmwit> ?go init=/bin/sh
19:15:36 <lb> http://www.linux-mips.org/archives/linux-mips/1997-04/msg00050.html
19:15:36 <lb> Title: Re: init=/bin/sh and serial devices
19:15:42 <stepcut> sorear: you don't have a BIOS password!?!?!
19:16:06 <stepcut> anyway, you'd be even wiser to use init=/usr/bin/emacs
19:16:49 * stepcut wonders if init=/usr/bin/ghci would work
19:17:19 <dmwit> Also, if you have your root password written down, I can hax you from the comfort of my own home at a later date.
19:17:43 <dmwit> (With less chance that you would notice.)
19:19:27 <SamB> perhaps the paper should be placed *inside* or *under* the computer?
19:19:41 <sioraiocht> anyone here compiled lambdabot before?
19:20:17 <dmwit> Oh, you do init=/bin/sh at grub or lilo?  You can *definitely* password protect that.
19:20:30 <SamB> dmwit: oh yeah?
19:20:49 <SamB> what if someone brings their own?
19:20:50 <dmwit> SamB: Errr, I think so?
19:21:05 <SamB> grub, not lilo, obviously ;-)
19:21:12 <sorear> sioraiocht: duh, lambdabot didn't come from the heavens precompiled ;)
19:21:31 <SamB> sorear: I think he meant, has anyone *here* done it
19:21:34 <sioraiocht> hahaha, I'm just getting the error "Setup.hs: cannot satisfy dependency plugins>=1.0"
19:21:46 <sorear> install hs-plugins
19:21:48 <sorear> @where hs-plugins
19:21:49 <lb> http://www.cse.unsw.edu.au/~dons/hs-plugins/
19:21:52 <sioraiocht> gracias
19:21:54 <dmwit> SamB: Okay, okay, it's true.  Physical access trumps all, given the proper hardware.
19:22:06 <dmwit> But given a root password, no extra hardware is necessary...
19:22:23 <SamB> granted, you'd need to get past the BIOS password if the computer is configured securely
19:22:50 <SamB> now, that little key is perhaps a handy invention...
19:22:57 <SamB> but they aren't all that great.
19:23:44 <SamB> now, I don't really try any of that...
19:24:11 <sorear> As my mom always says, "Locks are to keep honest people honest."
19:24:21 <SamB> an idiot with ubuntu could hack my system!
19:24:28 <SamB> if he was smart enough to know that he could
19:25:01 <SamB> (would have to be a live disk)
19:25:08 <SamB> (and it would likely be slow)
19:26:58 <SamB> of course, any such idiot would possibly have to contend with our pit bull... who has a tendancy to jump up on people and possibly lick them...
19:31:31 <aslfhwfol> I was planning on emerging ghc to learn Haskell, but it wants to downgrade glut: [ebuild     UD] virtual/glut-1.0 [3.7.1] I have other packages that use glut, so I don't think downgrading would be a good idea. Should I be using another Haskell environment?
19:31:56 <dcoutts> aslfhwfol: just don't USE=opengl for ghc
19:32:14 <dcoutts> ie USE="-opengl" emerge -pv ghc
19:32:35 <dcoutts> then it will not care about your glut version as it will not use it
19:32:52 <sorear> ghc come with a LOT of add-on packages
19:32:58 <dcoutts> aslfhwfol: btw there's a #gentoo-haskell channel
19:32:59 <sorear> among them a glut binding
19:33:36 <aslfhwfol> got it! Thanks. Oops, I meant to visit the gentoo-haskell channel. HAHA, sorry.
19:33:46 <dcoutts> aslfhwfol: also note that emerging ghc takes quite a while, there's ghc-bin and there's hugs which emerge quicker
19:36:00 <aslfhwfol> oh, ok! I thought ghc-bin was only used to build ghc (bootstrapping).
19:37:23 <sorear> why would anyone want to build 6.6 from source, if binaries are available?
19:37:42 * sorear builds HEAD biweekly - no binaries for that!
19:39:43 <dcoutts> aslfhwfol: it's used for that too
19:40:42 <dcoutts> sorear: because they use a source-based distro, they build everything from source
19:41:04 <dcoutts> of course bootstrapping ghc on a source based distro is a bit tricky :-)
19:43:26 <sioraiocht> @where hs-plugins
19:43:27 <lb> http://www.cse.unsw.edu.au/~dons/hs-plugins/
19:44:00 <sioraiocht> that path doesn't work for darcs -_-
19:45:08 <foxy-om> @paste
19:45:08 <lb> Haskell pastebin: http://hpaste.org/new
19:45:34 <dcoutts> sioraiocht: the darcs repo is linked on that web page
19:45:59 <sioraiocht> sorry, I'm not this much of a moron, usually...
19:46:16 <hpaste>  foxy-om pasted "Existential escapes, what to do?" at http://hpaste.org/1399
19:47:11 <foxy-om> How do I deal with this pesky existential ^^.  I thought that since it's a member of Ix I could use those functions on it...
19:48:03 <sorear> foxy-om: where is the error?
19:48:51 <foxy-om> sorear: try typing the function "test": Inferred type is less polymorphic than expected Quantified type variable `t' escapes
19:49:01 <sorear> I've seen this before :/
19:49:05 <sorear> I can't remember where
19:49:21 <sorear> aha!
19:49:31 <sorear> (actually I hadn't)
19:49:35 <sorear> the type of test is
19:50:17 <sorear> exists i. (Ix i, Tuple i) => IO (Array i Int)
19:50:25 <sorear> but That Just Won't Do
19:50:54 <sorear> GHC for some dumb reason doesn't allow the construction of types containing existentially quantified variables
19:51:50 <foxy-om> so what is the standard way of using existentially quantified types - as in how do you use the value?
19:52:13 <sorear> don't do anything that depends on the type ;)
19:52:28 <sorear> anyway, I *think* your problem is that you need dependant types
19:52:40 <sorear> the type of the result depends on the length of [2,3]
19:52:57 <sorear> but ghc can't model that, the closest it gets is that (illegal) exists-type
19:53:19 <foxy-om> Hm, I'm always running into this...
19:53:24 <sorear> so, give up this lists-of-indices persuit or get a real language like Cayenne or Epigram ;)
19:53:31 <chessguy> why do you say ghc can't model that? are you saying haskell can, but ghc can't?
19:53:32 <sorear> or Coq
19:53:40 <sorear> ghc >> haskell
19:53:49 <foxy-om> I've been playing with Coq - very cool
19:53:53 <chessguy> mmm
19:53:56 <sorear> ghc is a language, as well as a compiler
19:54:13 <chessguy> i thought ghc was an implementation of a language
19:54:29 <foxy-om> chessguy: which language?
19:54:36 <chessguy> haskell
19:54:50 <sorear> it does a very bad job
19:54:51 <foxy-om> what about fundeps + gadts etc?
19:55:15 <sorear> for instance 'defaul x = 0 ; t = 2 ; main = Main.default' is valid Haskell, but invalid GHC
19:55:17 <chessguy> well, those are extensions to haskell
19:56:14 <sorear> I reported that bug, but Simon said *booming voice of god* it would be cleaner to change the report
19:56:48 <fuzan> salutations!
19:56:56 <chessguy> "ok, kids, Simon says, change your standard to match your implementation!"
19:57:38 <narain> sorear: what's that code sample supposed to do though?
19:57:46 <dmwit> What does "main = 0" mean?
19:57:49 <sorear> er, type error
19:57:49 <sorear> :)
19:58:03 <dmwit> Err... "main = const 0".
19:58:05 <sorear> 'defaul = print ; t = 2 ; main = Main.defaul'
19:58:14 <sorear> no, main = 0 was right
19:58:20 <jcreigh> I'm confused.
19:58:24 <sorear> no, that was a typo
19:58:28 <sorear> 'defaul = print ; t = 2 ; main = Main.default'
19:58:34 <chessguy> @type ?f = 0
19:58:37 <lb> parse error on input `='
19:58:39 <sorear> Main.default lexes as Main.defaul t
19:58:48 <jcreigh> sorear: what? How?
19:58:55 <sorear> maximal much rule!
19:59:01 <narain> whoa
19:59:02 <fuzan> @users
19:59:03 <lb> Maximum users seen in #haskell: 321, currently: 297 (92.5%), active: 25 (8.4%)
19:59:10 <jcreigh> ...but...isn't that pretty much impossible?
19:59:10 <sorear> Main.default is an illegal lexeme, since default is a reserved name
19:59:29 <sorear> so we go with the maximal valid lexeme, Main.defaul
19:59:32 * narain remembers something about fortran programs having problems like that
19:59:33 <sorear> then we read t
19:59:44 <TomMD> Is it me or does the world generally not care to give simple examples anymore?
20:00:10 <sioraiocht> cannot satisfy dependency arrows-any?!?!?
20:00:19 <sioraiocht> isn't arrow support built in to ghc?
20:00:21 <sorear> sioraiocht: install arrows!
20:00:38 <sorear> sioraiocht: yes, but Dumb Distro Packagers have split it off
20:00:46 <sioraiocht> BOO
20:00:49 <sorear> look for (debian) libghc6-arrows-dev
20:01:15 <sudo> http://www.codigolibre.org/modules.php?name=Downloads&d_op=viewdownload&cid=1
20:01:16 <lb> Title: Fundacin Cdigo Libre Dominicano - Descargas, http://tinyurl.com/2lfdpx
20:01:18 <chessguy> darcs get http://darcs.haskell.org/packages/arrows
20:01:19 <dmwit> I just apt-get install libghc6-*-dev
20:01:20 <lb> Title: Index of /packages/arrows
20:01:29 * chessguy just installed it earlier
20:01:31 * sioraiocht is using OS X.
20:01:41 <sioraiocht> thanks chessguy
20:01:47 <sioraiocht> and sorear =)
20:01:49 <jcreigh> dmwit: does apt-get actually interpret wildcards?
20:02:09 <dmwit> reg-exes
20:02:20 <jcreigh> wow. that's cool. I did not know that.
20:02:21 <foxy-om> E: Couldn't find package libghc6-*-dev
20:03:20 <dmwit> foxy-om: I meant libghc6-.*-dev
20:03:21 <stepcut> dpkg interprets regexs, but I am not sure that apt-get does
20:03:29 <chessguy> so is haskell built on typed or untyped lambda calculus?
20:03:30 <dmwit> It seems to here...
20:03:45 <stepcut> ah, dpkg -l libghc6-*-dev worked, but apt-get required the .*
20:04:06 * chessguy is working on TAPL
20:04:10 <stepcut> hah, but, dpkg -l libghc6-.*-dev does *NOT* work
20:04:24 <foxy-om> I get unmet dependencies
20:04:32 <stepcut> apparently dpkg and apt-get use *different* wildcard systems :-(
20:04:43 <foxy-om> @where Cayenne
20:04:44 <lb> http://www.cs.chalmers.se/~augustss/cayenne/index.html
20:05:01 <dmwit> stepcut: Yeah, dpkg uses wildcards, apt-get uses regexes.
20:05:31 <stepcut> thank you debian.
20:08:10 <ddarius> chessguy: That question doesn't make a lot of sense.
20:08:16 <chessguy> d'oh
20:08:47 <shachaf> stepcut: Why would you use dpkg?
20:08:56 <chessguy> hmm. i've heard that haskell is basically a layer over a lambda calculus
20:09:14 <stepcut> shachaf: to see what version of a package I have installed, to list the contents of a installed package, stuff like that
20:09:43 <stepcut> e.g., dpkg -l libghc6-*-dev | grep ii
20:10:06 <shachaf> stepcut: I usually use one of apt-get, apt-cache and aptitude.
20:10:24 <foxy-om> chessguy, haskell is the lambda-calculus with essentially System-F as a type system
20:10:43 <stepcut> shachaf: how do you list all the libghc6-*-dev packages you have installed ?
20:11:12 <chessguy> aha
20:11:18 <shachaf> stepcut: Well, I usually don't do that. :-)
20:11:25 <shachaf> stepcut: aptitude search 'libghc6-.*-dev' | grep '^i' , I guess.
20:11:39 <shachaf> stepcut: No, your dpkg does give more information.
20:12:00 <shachaf> stepcut: I just prefer to stay at the apt level, rather than the dpkg level, when possible.
20:12:08 <stepcut> shachaf: also, sometimes apt gets too confused, and I have to use dpkg to force things
20:12:08 <sioraiocht> so did I botch my install, or is it normal for ghc to have NO associated libraries
20:12:25 <sioraiocht> by default, that is
20:12:33 <shachaf> stepcut: That's pretty rare.
20:12:43 <shachaf> stepcut: Usually apt-get -f install fixes things for me.
20:12:49 <stepcut> shachaf: in fact, it is not that rare
20:13:08 <chessguy> so typed lambda calculus is just untyped lambda calculus with some kind of type system built on top of it
20:13:54 <foxy-om> the typed lambda calculus is developed with types the whole way, there are two basic kinds, Church and Curry
20:14:04 <foxy-om> @google Typed Lambda Calculus
20:14:05 <lb> http://en.wikipedia.org/wiki/Typed_lambda_calculus
20:14:05 <lb> Title: Typed lambda calculus - Wikipedia, the free encyclopedia
20:14:17 <clanehin> stepcut, there's a nifty tool, aptsh, where you can use tab completion on package names
20:14:32 <shachaf> clanehin: I have tab completion on package names in bash. :-)
20:14:42 <chessguy> hrmmm. i assume haskell uses Curry?
20:16:01 <clanehin> shachaf, wow thanks so do I :)
20:16:37 <sioraiocht> ls
20:16:37 <sorear> chessguy: AIUI Church means that all \ x have types \x::Int -> foo, Curry means it is bare \x -> foo
20:17:27 <sorear> chessguy: also, Sys-F is quite a bit more powerful than the Haskell 98 type system.  Sys-F gives you rank-N types.
20:17:52 <foxy-om> chessguy, there's an intro to the Lambda calculus by Barendregt which is downloadable if you can find the link
20:17:57 <chessguy> wait, i thought someone just said haskell uses System F
20:18:18 <foxy-om> http://citeseer.ist.psu.edu/barendregt94introduction.html
20:18:22 <lb> Title: Introduction to Lambda Calculus - Barendregt, Barendsen (ResearchIndex)
20:18:26 <chessguy> foxy-om: i'm working on Pierce's TAPL now. probably getting way ahead of myself
20:18:48 <foxy-om> @yarr!
20:18:48 <lb> Swab the deck!
20:18:53 <foxy-om> lb?
20:18:56 <sorear> chessguy: foxy-om said it
20:18:59 <sorear> yes, lb
20:19:15 <chessguy> but it's not true?
20:19:37 <foxy-om> well, ghc uses something like it
20:19:58 <sorear> foxy-om: System F-C, which is a close relative of F_omega, but that's in Core
20:20:18 <foxy-om> :P
20:20:22 <chessguy> so...what type system does haskell use?
20:20:29 <sorear> haskell is HM-style lambda calculus with eagr type qualifiers (classes etc) and a ton of sugar
20:20:41 <sorear> Hindley-Damas-Milner first order polymorphic
20:20:53 <sorear> extended with classes
20:23:35 <chessguy> ok, that helps. i'll watch for that as i work through the book
20:26:50 <dmwit> ?where template
20:26:51 <lb> I know nothing about template.
20:26:58 <dmwit> ?go template haskell
20:26:59 <lb> http://www.haskell.org/th/
20:27:00 <lb> Title: Template Haskell
20:27:34 <sorear> @where th
20:27:34 <lb> I know nothing about th.
20:27:46 <sorear> dmwit: so, why are you asking abot TH?
20:28:07 * sorear asks because one of "his" projects is a likely cause
20:28:17 <dmwit> Nah, I was mistaken.
20:28:24 <chessguy> ?where+ th http://www.haskell.org/th/
20:28:28 <dmwit> I thought it broke on template-haskell, but it actually broke on FilePath-any.
20:29:00 <narain> ?where templatehaskell
20:29:09 <narain> ?where template-haskell
20:29:15 <lb> Done.
20:29:15 <lb> I know nothing about templatehaskell.
20:29:15 <lb> I know nothing about template-haskell.
20:29:29 <dmwit> I'd say lb's where-database is significantly smaller than lambdabot's. ;-)
20:29:58 <narain> oh, i forgot about that
20:32:25 <chessguy> ?type \l -> \m -> \n -> l m n
20:32:47 <chessguy> hmm, some lag going on?
20:32:58 <dmwit> (a -> b -> c) -> b -> c -> a
20:33:15 <dmwit> err
20:33:24 <dmwit> (a -> b -> c) -> a -> b -> c
20:33:50 <foxy-om> @djinn (a -> b -> c) -> a -> b -> c
20:33:53 <sorear> any parsec gurus here?
20:34:21 <dmwit> f x y z = x y z
20:34:51 <dmwit> (But where's lb's answer?)
20:34:59 <foxy-om> @yarr!
20:35:01 <lb> forall t t1 t2. (t -> t1 -> t2) -> t -> t1 -> t2
20:35:01 <lb> f a = a
20:35:01 <lb> Splice the Mainbrace!
20:35:20 <foxy-om> @djinn (a -> b -> c) -> a -> b -> c
20:35:20 <lb> f a = a
20:35:27 <sorear> You may recall the frequency with which I curse lag
20:35:32 <dmwit> Weird!
20:35:36 <narain> now that's clever
20:35:36 <sorear> lb is kinda on the same connection :)
20:35:51 <foxy-om> Australians are naturally slow
20:35:57 * foxy-om points at lb
20:36:07 <sorear> Actually, I'm from San Diego.
20:36:21 <foxy-om> oh, is lb not lambdabot?
20:36:22 <sorear> it's dons & lambdabot that are aussies
20:36:28 <fuzan> oh wow, bnfc can derive instances for compos
20:36:36 <sorear> bnfc?
20:36:44 <sorear> @google bnfc
20:36:49 <fuzan> bnf converter
20:36:50 <lb> http://www.bnfc.org/
20:36:54 <fuzan> i think that's wrong.
20:37:06 <sorear> it is.
20:37:18 <fuzan> http://www.cs.chalmers.se/~markus/BNFC/
20:37:19 <lb> Title: The BNF Converter
20:37:27 <sorear> foxy-om: lb is run by me.
20:37:32 <chessguy> i thought there was some kind of let command in ghci
20:37:35 <foxy-om> my apologies
20:37:37 <sorear> there is
20:37:43 <sorear> Prelude> let x = 2
20:38:06 <fuzan> > let x = 2 in x + 1
20:38:08 <lb>  3
20:38:11 <fuzan> that should work in ghci.
20:38:24 <chessguy> does it only last until you close ghci?
20:38:42 <sorear> let x = 2 in x + 1 only lasts for 1 command
20:38:53 <sorear> let x = 2 {- no in -} lasts until you close ghci
20:39:21 <sioraiocht> what does THIS mean? "IRCRaised <socket: 6>: hGetChar: end of file"
20:39:48 <sorear> Probably that the server closed the connection.
20:39:58 <sorear> Pick a nickname that isn't in use.
20:40:07 <chessguy> whoah
20:40:22 * sorear is far too seasoned a lb debugger
20:40:29 <chessguy> church booleans are seriously cool
20:40:42 <sorear> Agreed.
20:40:44 <sioraiocht> sorear: still get it with a nic qwetrwe =p
20:40:53 <fuzan> chuch booleans?
20:41:12 <foxy-om> > let false = \x y.y
20:41:12 <lb>  Parse error
20:41:21 <fuzan> ah, lambda calc stuff.
20:41:24 <foxy-om> > let false = \x y -> y
20:41:24 <lb>  Parse error
20:41:42 <sioraiocht> hahaha you have to have an 'in' with let
20:41:44 <chessguy> let tru = \t f -> t; fls = \t f -> f; test = \l m n -> l m n; v = "true"; w = "false" in test tru v w
20:41:44 <lispy> > let false = \x y -> y in false
20:41:46 <lb>  Add a type signature
20:41:55 * ddarius is always impressed by const and const id </sarcasm>
20:41:55 <chessguy> > let tru = \t f -> t; fls = \t f -> f; test = \l m n -> l m n; v = "true"; w = "false" in test tru v w
20:41:57 <lb>  "true"
20:41:58 <sorear> sioraiocht: in lb, yes.  in ghc no
20:42:03 <sioraiocht> orly?
20:42:09 <sorear> rly.
20:42:14 <sorear> ghci actually.
20:42:16 <sorear> try it!
20:42:36 <sioraiocht> hrm
20:42:38 <lispy> ghci is working in the IO monad
20:42:46 <lispy> and let in the monadic syntax doesn't require the in
20:42:51 <narain> > const id == flip const
20:42:53 <lb>   add an instance declaration for (Eq (b -> a -> a))
20:42:53 <lb>     In the expression: (...
20:43:31 <sioraiocht> sorear: but it doesn't evaluate to anything? and has no type?
20:43:47 * chessguy suddenly begins to get why lambda calculus is so cool
20:43:55 <sorear> sioraiocht: right.
20:44:02 <ddarius> @check \x -> const id x == flip const (x :: Int)
20:44:04 <lb>   add an instance declaration for (Eq (a -> a))     In the expression: (const...
20:44:04 <sorear> sioraiocht: it's a meta-command
20:44:08 * sioraiocht boggles.
20:44:15 <sorear> sioraiocht: not all ghci commands are expressions!
20:44:23 <narain> ?pl const id
20:44:23 <lb> const id
20:44:25 <ddarius> @check \x -> const id undefined x == flip const undefined (x :: Int)
20:44:27 <lb>  OK, passed 500 tests.
20:44:27 <narain> ?pl flip const
20:44:28 <lb> const id
20:44:30 <sorear> sioraiocht: what is the type of ^D, and what does it evaluate to?
20:45:17 <sorear> seq is the same for almost all purposes, and 5 ch shorter
20:45:23 <sioraiocht> sorear: but that's EOF
20:45:43 <sioraiocht> sorear: I would think that ghci operates like GHCI in that it processes expressions until to encounters EOF
20:45:49 <ddarius> let k = const
20:45:52 <sioraiocht> and
20:46:03 <sioraiocht> ":" are "escaped" expressions
20:46:29 <sorear> sioraiocht: ghci and GHCI are different?!?
20:46:35 <sioraiocht> errr
20:46:39 <sioraiocht> sorear: ghc
20:46:52 <sorear> ghc doesn't process expressions
20:47:04 <sorear> it processes a mixture of declarations and pragmas
20:47:05 <dmwit> :t const id
20:47:06 <dmwit> :t id
20:47:07 <ddarius> chessguy: It's quite systematic to encode any algebraic data type into a Church encoding.  The shortest way to explain it is the Church encoding of a data type is it's fold.
20:47:08 <lb> forall a b. b -> a -> a
20:47:10 <lb> forall a. a -> a
20:47:50 <chessguy> huh?
20:47:50 <sioraiocht> my head hurts
20:48:01 <chessguy> ddarius: what are you talking about?
20:48:22 <fuzan> are there any sweet books out on lcalc?
20:48:32 <fuzan> i've seen a few on amazon, not sure how cool they are.
20:48:49 <dmwit> ?seen ndm
20:48:50 <lb> I saw ndm leaving #haskell 4h 34m 43s ago, and .
20:48:52 <sioraiocht> @faq
20:48:52 <lb> The answer is: Yes! Haskell can do that.
20:48:59 <ddarius> Church booleans are just Church encoded booleans.
20:49:58 <dmwit> I've just installed FilePath 1.0, but Derive still says, "Setup.hs: cannot satisfy dependency FilePath-any".  Any clues?
20:50:27 <thorat> fuzan: Types and Programming Languages is popular here.  It covers typed lambda calculi.
20:50:37 <ddarius> foldBool True thn els = thn; foldBool False thn els = els so the Church encoding of Booleans is true thn els = thn; false thn els = els; foldBool bool thn els = bool thn els
20:51:31 <fuzan> acroread is so much better than xpdf.
20:51:34 <ddarius> fuzan: Do you specifically want a hardcopy book or just a book-sized/-quality bunch of information?
20:51:46 <fuzan> ddarius: content is all I care about.
20:52:00 <dmwit> fuzan: What do you miss when you're in xpdf?
20:52:08 <ddarius> Then some classics are available and there are some good things online.
20:52:25 <ddarius> @google "Programming Languages and Lambda Calculi"
20:52:25 <fuzan> selecting text, proper modern font rendering.
20:52:25 <lb> http://www.cs.utah.edu/plt/publications/pllc.pdf
20:52:39 <ddarius> @google "Lectures on the Curry-Howard Isomorphism"
20:52:40 <lb> http://citeseer.ist.psu.edu/519604.html
20:52:40 <lb> Title: Lectures on the Curry-Howard Isomorphism - Srensen, Urzyczyn (ResearchIndex)
20:52:42 <fuzan> acroread isn't so bad when you've stripped half hte interface.
20:53:11 <dmwit> I can select text, but I can't vouch for the font rendering.
20:53:13 <ddarius> @google "Lambda Calculi with Types"
20:53:15 <lb> http://citeseer.ist.psu.edu/barendregt92lambda.html
20:53:15 <lb> Title: Lambda Calculi with Types - Barendregt (ResearchIndex)
20:53:16 <fuzan> saving these, thanks :)
20:53:18 <narain> i switched to acroread because i can't live without subpixel font rendering on an lcd screen
20:53:26 <chessguy> i'm not seeing what church-encoded booleans has to do with folds
20:53:38 <chessguy> probably because there's a screaming baby in the next room
20:53:49 <sorear> dmwit: you must not have actually installed FilePath, check ghc-pkg list
20:53:56 <ddarius> true == foldBool True
20:54:19 <ddarius> If you Church encode properly, foldFoo is just application.
20:54:33 <dmwit> /usr/lib/ghc-6.4.1/package.conf: (.....), filepath-1.0
20:54:54 <fuzan> back to codegeneration I shall go!
20:56:03 <sorear> @botsnack
20:56:04 <lb> :)
20:56:04 <sorear> grr.
20:56:06 <sorear> not agaiN!
21:02:33 <chessguy> @botsmack
21:02:33 <lb> :)
21:07:57 <ddarius> Permuting the arguments to foldr a little, we can get the Church encoding of lists via foldr [] c n = n -> nil c n = n; foldr (x:xs) c n = c x (foldr xs c n) -> cons x xs c n = c x (xs c n)
21:09:27 <chessguy> @type (\x -> x x) (\x -> x x)
21:09:30 <lb>     Occurs check: cannot construct the infinite type: t = t -> t1
21:09:30 <lb>     Probable cause: `x' is applied to too many arguments
21:09:41 <chessguy> @type \x -> x x
21:09:44 <lb>     Occurs check: cannot construct the infinite type: t = t -> t1
21:09:44 <lb>     Probable cause: `x' is applied to too many arguments
21:11:23 <chessguy> @type \f -> (\x -> f (\y -> x x y)) (\x -> f (\y -> x x y))
21:11:25 <lb>     Occurs check: cannot construct the infinite type: t = t -> t2 -> t1
21:11:25 <lb>     Probable cause: `x' is applied to too many arguments
21:11:50 <ddarius> Types were specifically created to make those untypeable.
21:12:07 <chessguy> why?
21:12:28 <foxy-om> typing implies termination
21:12:45 <ddarius> Because, when you want to use the lambda calculus as a foundation for mathematics, you don't want those terms as they lead to an inconsistent logic.
21:13:20 <dcoutts> foxy-om: as long as you can't type fix anyway
21:13:29 <narain> :t fix
21:13:31 <lb> forall a. (a -> a) -> a
21:13:50 <dcoutts> that's inductive proof by claiming it's true :-)
21:14:19 <foxy-om> @djinn ((a -> b) -> a) -> a
21:14:19 <lb> -- f cannot be realized.
21:14:49 * foxy-om pats constructive logic
21:14:54 <ddarius> If only Haskell had first class continuations...
21:15:20 <jcreigh> ddarius: it doesn't? I thought there was a continuation monad...
21:15:31 <dcoutts> sorear: trying to parse C declarators eh? nasty business
21:15:58 <dcoutts> sorear: I've got a happy grammar if you care
21:16:23 <dcoutts> it's currently parsing all the base packages on my system (including parsing __attribute__s)
21:16:24 <ddarius> jcreigh: There is a ((a -> Cont b) -> Cont a) -> Cont a, but without call/cc being built in, that type is uninhabited by anything useful.
21:16:24 <foxy-om> > map ("If only Haskell had " ++) ["Dependent Types.","first class continuations","espresso making abilities"]
21:16:26 <lb>  ["If only Haskell had Dependent Types.","If only Haskell had first class con...
21:16:54 <dcoutts> foxy-om: but it does have espresso making abilities!
21:17:13 * ddarius doesn't actually want Haskell to have first class continuations.
21:17:17 <foxy-om> hm, I must have a substandard network connection then, coffee seems to short it
21:17:20 * ddarius knows where Scheme is when he wants it.
21:17:31 <dcoutts> just upload ghc or hugs for arm to your fridge/toaster/coffee machine
21:17:40 <foxy-om> aha!
21:20:22 <fuzan> nhaha
21:20:30 <fuzan> fetch --partial for lambdabot = 515 patches
21:20:51 <narain> does lb not respond to privmsgs?
21:20:57 <fuzan> it should.
21:21:08 <shachaf> narain: It does for me.
21:21:11 <fuzan> lb is developing it's own conciousness as of late.
21:21:14 <narain> huh
21:21:42 <narain> > 42
21:21:44 <lb>  42
21:22:44 <narain> i'm still getting no responses to privmsgs :(
21:23:05 <ddarius> lb is not identified
21:23:53 <narain> ohh
21:23:59 <stefanha> Is an "abstract data type" in Haskell simply a type for which the constructors are hidden to users?  (Just reading mHaskell paper, they say: "data MChannel a -- abstract data type")
21:24:14 <ddarius> In Haskell, yes.
21:24:22 <stefanha> Cool, thanks.
21:28:20 <rhz> Is there a way to make Setup.hs compile C sources into a static library and link it in
21:28:26 <rhz> ?
21:28:47 <bos> yes.
21:29:00 <bos> let me dig out the bits you need...
21:29:34 <stepcut> hrm, 'throw' is evil
21:29:45 <bos> in your .cabal file, you want a c-sources: header with a list of file names after it
21:30:02 <bos> as in: "c-sources: cbits/foo.c"
21:30:17 <bos> C sources usually live in a directory named cbits, for hysterical raisins
21:30:46 * stepcut works on, 'Why throw must die'
21:31:29 <dcoutts> bos: heh, that is indeed an aged convention from the fptools era
21:31:38 <bos> yep.
21:31:58 <bos> but i have grey in my beard :-)
21:32:36 <rhz> So you must have a .cabal file?
21:33:07 <bos> yes.
21:33:20 <bos> at least, i've not seen any packages that don't.
21:33:38 <bos> but writing a .cabal file is simple.
21:34:38 <rhz> Do you put C .h files in the c-sources header too?
21:35:17 <dcoutts> bos: are you the one hacking on code gen this summer? I forget.
21:35:22 <bos> dcoutts: no.
21:35:46 <bos> rhz: includes tend to go in install-includes
21:35:52 <dcoutts> ah my mistake, I've forgotten their name
21:36:36 <bos> because they're often needed at compile time after the package is installed.
21:36:47 <bos> dcoutts: are you thinking about the shared library stuff?
21:36:51 <rhz> ok, because Setup.hs is going to need to know where to look for the .h files.
21:36:57 <bos> i might be backup mentor for that.
21:37:23 <dcoutts> bos: no, there's some chap who's working with SimonM on the cmm and ncg this summer, it's not a SoC thing.
21:37:40 <bos> oh, that.
21:38:01 <bos> whoever it is seems to have no name, and no online identity :-)
21:38:40 <dcoutts> bos: but that's great, I told Simon I'd be interested in advising on the shared lib stuff, if there are not too many advisers already :-)
21:39:01 <dcoutts> bos: does the chap doing the shared lib stuff have an online identity?
21:39:22 <bos> yeah, it's clemens fruhwirth
21:39:42 <dcoutts> bos: we should get him in here and talk about stuff
21:39:42 <bos> i forget his nick, but he's on here sometimes iirc
21:39:48 <dcoutts> right, ok
21:39:59 <dcoutts> I'll need him pointing out to me
21:40:29 <dcoutts> bos: have you talked to him much yet ?
21:40:43 <bos> not at all.
21:41:15 <bos> simonM is his primary mentor, and there's been no sign of mentors or backup mentors getting the ball rolling yet.
21:41:55 <bos> and frankly, if you have the cycles to act as backup, you're welcome to do it instead of me :-)  i'll already have my hands quite full this summer.
21:43:05 <dcoutts> bos: right'o, though I'm sure we can get you involved in discussion, that's not real work ;-)
21:43:52 <bos> yes, stuff that doesn't involve real work is always easier to do :-)
21:48:07 <bos> dcoutts: how long are you in AU for?
21:48:22 <dcoutts> bos: only another 9 days
21:48:47 <bos> oh!
21:49:12 <bos> sounds like a busy visit, if the ICFP submissions are anything to go by :-)
21:49:18 <dcoutts> yeah :-)
21:49:43 <dcoutts> hack hack hack write write write
21:55:52 <sorear> bos, dcoutts: clemens is therp
21:56:01 <bos> sorear: thanks.
21:56:16 <bos> he's been on #haskell-soc a lot, then.
21:57:05 <bos> oops.
21:59:14 <sorear> Is (mattam "Mathieu", #haskell's resident type theory geek) == (Mathieu Boespflug, the SoC guy rewriting the yhc type checker)?
21:59:42 <bos> seems unlikely to be a coincidence.
22:00:30 <sorear> dcoutts: I'd like to see it, just in case your way is nicer...
22:00:41 <dcoutts> sorear: it's not nicer
22:00:49 <dcoutts> it's a 1.9kloc GNU C parser
22:00:59 <dcoutts> it's here...
22:01:11 <bos> dcoutts: i'm impressed
22:01:18 <sorear> well, delete everything that doesn't parse struct declarators and it will be a lot smaller!
22:01:23 <dcoutts> http://darcs.haskell.org/c2hs/c2hs/c/CParser.y
22:01:35 <sorear> c2hs is still maintained?
22:01:43 * sorear thought everyone was using hsc2hs now
22:01:59 <dcoutts> hsc2hs doesn't do half the things c2hs does
22:02:15 <dcoutts> c2hs guarantees type safety and generates FFI decls for you
22:02:27 <dcoutts> I'm currently extending it to parse GNU C __attributes__
22:02:31 <stepcut> hsc2hs is only slightly better than using plain FFI
22:02:38 <sorear> guarantees type safety, eh?
22:02:52 * sorear looks at rhz's(?) binding
22:03:04 <dcoutts> so far I can parse the kernel with it and so far I'm up to half the packages in my system set
22:03:10 <jcreigh> the X11 stuff I've seen that uses hsc2hs seems to have a lot of boilerplate code.
22:03:28 <jcreigh> (Storable instances and all that)
22:03:32 <dcoutts> c2hs reads the C header files and generates Haskell FFI decls with the correct types
22:03:33 <araujo> hsc2hs .... a c2hs equivalent?
22:03:36 <sorear> dcoutts: btw, what do you think of my `parE` hack?
22:03:39 <dcoutts> that saves you so much work
22:03:46 <dcoutts> sorear: I don't think I understand it
22:03:55 <bos> dcoutts: wow, that's a nice, thorough parser.
22:04:04 <sorear> aww, you're using happy
22:04:10 <bos> dcoutts: how interested are you in rounding it out?
22:04:12 <sorear> it suddenly sinks in...
22:04:27 <bos> i have obscene numbers of C parser test suites on hand.
22:04:35 * sorear wishes there were nice usable LALR(1) parser combinators
22:05:06 <dcoutts> bos: so far, yep. Well I'd like to parse attributes properly, currently they're ignored in the lexer, I've just now extended it so they're ignored in the parser instead
22:05:19 <stepcut> sorear: is frown not usable /
22:05:23 <dcoutts> bos: then we have to actually enter them into the ast
22:05:43 <bos> ok.
22:05:46 <sjanssen> dcoutts: can c2hs automatically write Storable instances for C structs?
22:06:02 <dcoutts> bos: and the next step is to test exhaustively that c2hs calculates struct sizes and member offsets correctly
22:06:11 <sorear> bos: is there something like a reusable C front+middle end?
22:06:18 <dcoutts> sjanssen: not yet
22:06:25 <bos> sorear: not really.
22:06:30 <dcoutts> sjanssen: though I'm not sure how you'd do it with unions
22:06:30 <sorear> bos: I'd like to write an uber-optimizing backend, but have no desire to write a parser :/
22:06:42 <bos> sorear: our compiler just uses gcc for the front end.
22:06:47 <dcoutts> sjanssen: structs might be ok
22:06:54 <sorear> bos: how much of gcc do you use?
22:07:10 <bos> sorear: just the front end.
22:07:11 <sorear> basically, vcc : icc :: jhc : ghc
22:07:20 <dcoutts> bos: what's your compiler for? I assume it's not written in Haskell ;-)
22:07:20 <sorear> that's how it's gonna look...
22:07:22 <bos> sorear: we flatten the gimple representation.
22:07:35 <sorear> dcoutts: this is Pathscale C
22:07:42 <bos> dcoutts: it's an optimising c/c++/fortran compiler
22:07:51 <dcoutts> ah right
22:09:21 <sorear> bos: how strongly typed are the various GCC intermediate languages?
22:09:49 <sorear> I think I might just have to hook into GHC Cmm, many of the ideas I have seem to depend on strong typing :(
22:10:03 <dcoutts> cmm is not strongly typed
22:10:38 <sorear> ooh, mbot's been seriously upgraded ...
22:10:56 <bos> sorear: pretty modestly. they will remember attributes like simple type, width, signedness, alignment, and stuff like that.
22:11:20 <sorear> So no hope of turning small numbers used by switches into labels. *sigh*
22:11:35 <sorear> btw, someone ?localtime'd sorear on mbot
22:12:16 <bos> oh, you want to know if stuff like the range of an enum is preserved? let me have a look-see.
22:12:23 <dmead> holla.
22:12:26 <dcoutts> bos: pathscale needs a cmm frontend ;-) and ghc should generate nicer cmm.
22:13:08 <bos> i haven't looked at cmm at all.
22:13:30 <dcoutts> it's somewhere between C and assembler
22:13:35 <bos> right.
22:13:45 <bos> i'm aware of its existence, but that's about it.
22:13:48 <dcoutts> but the main thing is that it provides enough info for runtime systems
22:14:04 <dcoutts> eg it records which things ended up in which registers
22:14:09 <dcoutts> so you can do accurate GC
22:14:21 <bos> there was a cmm submission for SoC this year, but it just barely didn't get accepted.
22:14:35 <dcoutts> and on the stack
22:14:51 <dcoutts> and it provides some nicer primitives for dealing with multiple stacks
22:15:01 <dcoutts> eg for lightweight concurrency implementations
22:15:25 <bos> ah. we've had awful problems with using dwarf2 for that kind of information.
22:15:37 <sorear> hi dmead
22:15:41 <dmead> hi
22:15:46 <bos> modern C++ runtimes require the ability to be able to see much of that information when they're unwinding the stack during an exception handle.
22:16:02 <bos> which means that the C runtime needs it too.
22:16:09 <dcoutts> bos: right, and it's hard to gather and manage all that info?
22:16:19 <dcoutts> or just the dwarf formts are a pita?
22:16:36 <bos> it's a pain, particularly in a function prologue and epilogue when your stack frame and registers are in limbo.
22:17:05 <bos> and yes, parsing dwarf2 is very complicated, as is generating it.
22:17:59 <dcoutts> and I bet even if you do it right you can probably still get gdb to segfault parsing it :-)
22:18:36 <dcoutts> yay for binary formats
22:18:37 <bos> worse, there are multiple debuggers with slightly incompatible dwarf interpreters.
22:19:16 <dcoutts> heh, why does that not surprise me
22:19:22 <bos> and unfortunately our IR throws away so much information at high optimisation levels that we general a lot of garbage in any case.
22:20:05 <dcoutts> bos: so ever tried getting ghc to talk to your C compiler, since it's gcc compatible it should just drop in right?
22:20:40 <dmead> sorear: you're up on proving technology right?
22:21:06 <bos> dcoutts: in principle, it ought to just work. in practice, i've resigned from my job, and no longer care :-)
22:21:21 <dcoutts> bos: ah I see :-) ok
22:23:47 <sorear> dmead: slightly interested.  but mostly what you can expect from me is pre-digested internet.
22:24:05 <sorear> not that pre-digested is a bad thing
22:24:26 <sorear> for instance, I have *not* seen TaPL
22:24:47 <dmead> ah, i was wondering... maybe the ghc standard library should have a logic section?
22:25:04 <dmead> moreover.. do you know how that sort of thing is  proposed?
22:25:15 <sorear> @wiki Library_submissions_process
22:25:16 <lb> http://www.haskell.org/haskellwiki/Library_submissions_process
22:25:16 <sorear> iirc
22:25:24 <dmead> ahh
22:25:26 <dmead> thanks
22:25:42 <dmead> oh, empty page
22:25:58 <sorear> http://haskell.org/haskellwiki/Library_submissions
22:25:59 <lb> Title: Library submissions - HaskellWiki
22:25:59 <dmead> http://www.haskell.org/haskellwiki/Library_submissions
22:26:00 <lb> Title: Library submissions - HaskellWiki
22:26:01 <dmead> :P
22:28:58 <sjanssen> dmead: you'll probably have a hard time convincing GHC HQ to expand the libraries they're packaging
22:29:09 <sjanssen> the current trend is towards minimalism
22:29:12 <dmead> ah
22:29:32 <dmead> they aren't aiming toward a java type of library then?
22:30:14 <sjanssen> no, I don't think so
22:30:56 <sjanssen> you should certainly write that library if you're interested -- just package it separately
22:31:09 <sjanssen> use cabal, put it on hackage, etc.
22:31:58 <dmead> ahh
22:31:58 <dmead> k
22:32:18 <sorear> emphasis on hackage
22:32:24 <dmead> yea i'm just wondering what a set of modules for doing logic might look like
22:32:36 <sorear> if you have any intention of releasing libs, get a hackage acct
22:32:55 <sorear> look at Oleg's LogicT to start - backtracking fun
22:33:05 <sorear> also look at "typed logical variables"
22:33:05 <dmead> k
22:33:09 <sorear> prolog in haskell!
22:33:12 <dmead> :)
22:33:14 <sorear> @google "typed logical variables"
22:33:16 <lb> http://citeseer.ist.psu.edu/claessen00typed.html
22:33:16 <lb> Title: Typed Logical Variables in Haskell - Claessen, Ljungl (ResearchIndex)
22:33:25 <sorear> @google "oleg logict"
22:33:26 <lb> No Result Found.
22:33:32 <sorear> @google "logict"
22:33:35 <lb> http://www.capegateway.gov.za/eng/directories/public_entities/403/116452
22:33:35 <lb> Title: LOGICT
22:33:39 <sorear> @google oleg logict
22:33:40 <lb> http://okmij.org/ftp/Computation/monads.html
22:33:40 <lb> Title: Monads
22:33:51 <sorear> okmij == oleg, that's the right page
22:34:34 <sorear> hi jyp
22:34:44 <jyp> hey sorear
22:35:03 <sorear> how's yi?
22:35:18 <jyp> I'm making good progress
22:35:27 <jyp> Did you check the wiki lately ?
22:35:35 <jyp> Thanks for asking btw ;)
22:35:36 <sorear> :( my parser still doesn't work
22:35:44 <jyp> Parser for what?
22:35:49 <sorear> I read the rc-list about every five minutes :)
22:35:54 <sorear> ANSI C declarators
22:35:58 <jyp> argh
22:36:09 <jyp> well at least not C++ :)
22:38:47 <jyp> sorear: did you bug Paul Callaghan too ?
22:38:51 <jyp> http://www.dur.ac.uk/p.c.callaghan/happy-glr/
22:38:52 <lb> Title: GLR parsing with Happy
22:39:03 <sorear> ich, happy
22:39:24 <sorear> no, this is a parsec parser.  `sepBy1` is nice enough to make up for LL(1)
22:40:08 <jyp> Oh. I thought you were still stuck with the Happy bug
22:40:34 <sorear> no, I fixed the happy bug (very hackily)
22:41:35 <stepcut> dmead: this is another interesting paper on 'logic' programming in haskell http://www.cse.ogi.edu/PacSoft/publications/2001/modular_lazy_search_jfp.pdf
22:41:37 <lb> http://tinyurl.com/36gnp3
22:41:58 <inverselimit> quick question, I invoke ghci 6.4.2 with: "ghci -fno-implicit-prelude" yet the prelude still loads.  What am I doing wrong (want to experiment with NumericPrelude)
22:42:02 <ivanm> has lambdabot officially been re-christened "lb" now?
22:42:20 <ivanm> inverselimit: import prelude() ?
22:42:36 <dmead> kewl
22:42:37 <dmead> thanks
22:43:38 <jyp> inverselimit: I think -fno-implicit-prelude is only for compiling modules
22:43:56 <jyp> the prelude is still loaded in GHCi context.
22:44:19 <inverselimit> ah, that's too bad.  Is there any way around that?
22:44:33 <jyp> :m -Prelude ?
22:44:59 <stepcut> inverselimit: try putting your functions in a seperate file with {-# OPTIONS -fno-implicit-prelude #-} as the first line...
22:45:08 <jyp> You could also hack ghc :)
22:45:21 <inverselimit> :m -Prelude seems to do it, thanks
22:45:33 <jyp> Yay :)
22:46:02 <sorear> found it.
22:46:09 <sorear> @slap LL(1)
22:46:09 <lb> why on earth would I slap LL(1)
22:46:16 <sorear> was anybody suprised? :)
22:48:23 <dmead> stepcut, wow, reading this paper would have saved me loads of time figuring out my prover
22:50:09 <stepcut> dmead: it is a great, and not very well known, paper
22:50:26 <stepcut> dmead: I used that technique to write a Debian dependency solver with great success
22:50:34 <dmead> thats cool
22:51:12 <dmead> yea, actually doing an operation like this doesn't take that many lines to code, but it's sometimes hard to conceptualize
22:52:11 <stepcut> it would be nice to pull the code out of the paper and make a stand alone library
22:53:08 <stepcut> I actually did that for the previous revision of the paper, but the version they submitted to JFP added a bunch of good stuff (like dynamic variable ordering), and I have not had a chance to update
22:53:45 <fuzan> anyone play much with compos/bnfc?
22:54:20 <ivanm> has lambdabot officially been re-christened "lb" now?
22:54:34 <dmead> yea, the code for my knowledge base stuff is maybe 30 lines long
22:54:46 <dmead> but it took many revisions to get right
22:54:51 <dmead> would have been nice for a library :)
22:55:05 <dmead> actually, if that was in ghc libs it'd be nice
22:55:51 <stepcut> actually, it looks like I do have an updated copy of all the code from the paper
22:55:57 <sorear> ivanm: no
22:57:12 <lb> Hi. My name is 'lb'. I belong to sorear.  My name is different because I am not lambdabot.  lambdabot belongs to dons.  dons is travelling and jetlagged and unable to fix lambdabot.  lambdabot is
22:57:12 <lb> dead because of a power outage.  Enough info?
22:57:15 <stepcut> dmead: the other thing I wanted to do was to generalize it a bit so that you do not have to turn everything into a CSP first.
22:57:41 <dmead> hmm that would be tricky
22:58:29 <stepcut> maybe, I don't remember :-/
22:59:13 <dcoutts> stepcut: mm, looks like a nice paper
22:59:58 <dmead> data CSP = CSP { vars, vals :: Int, rel :: Relation }
22:59:59 <stepcut> dmead: for the debian dependency solver I used the same basic techniques, but made the functions specialized to the problem I was solving -- not sure if that could be done in a general way or not
23:00:55 <dmead> i think if you choose to just code up a problem-specific algorithm it's fine
23:00:56 <ivanm> sorear: ahhh, OK
23:01:10 <ivanm> sorear: so is the google problem irrelevant then?
23:01:16 <ivanm> sorear: :D
23:01:20 <dmead> you'll only get an increase in development time if theres a prepackaged lib and an easy way to understand it
23:01:23 <dmead> err
23:01:38 <dmead> decrease in development time i mean
23:02:25 <sorear> ivanm: yeah, google is irrelevant ;)
23:02:46 <ivanm> @google google lambdabot
23:02:48 <stepcut> dmead: in my code, I changed CSP to 'data CSP a = CSP { pnm :: PackageNameMap a, targetPnm :: PackageNameMap a, relations :: Relations, depFunction :: (a -> Relations), conflicts :: a -> Relations, packageVersion :: a -> (String, DebianVersion) }'
23:02:50 <lb> http://tunes.org/~nef/logs/haskell/06.08.01
23:02:54 <ivanm> :D
23:03:27 <dmead> ah
23:04:34 <stepcut> dmead: but, I also had to update a lot of the other functions, like conflicts, mkSearchTree, etc, so... maybe there isn't a good general purpose way to do it
23:04:55 <dmead> there is, but it's so general that it's hardly worth it
23:05:01 <stepcut> yeah
23:05:21 <dmead> just pass a function a predicate and a transformer function to a function that does general recursion
23:05:53 <dmead> i dunno, maybe theres a way to classify these sorts of problems
23:07:31 <stepcut> dmead: looking at my code, it looks like the most useful reusable part is the extra tree helper functions :)
23:08:23 <dmead> link?
23:10:06 <hpaste>  stepcut pasted "tree helper functions" at http://hpaste.org/1400
23:10:14 <stepcut> the full code is in Linspire.Debian.Dependencies, http://hackage.haskell.org/packages/archive/debian/debian-1.2.tar.gz
23:10:15 <lb> http://tinyurl.com/2rncby
23:10:23 <stepcut> sorry, no darcs repo yet
23:12:32 * stepcut goes to bed
23:14:35 <dmead> ah
23:15:22 <dmead> ok
23:15:23 <stepcut> dcoutts: yes, I found it to be quite a nice paper. Aside from being useful, it is an elegant example of functional programming and lazy evaluation
23:15:24 <dmead> i'll check it out
23:15:50 <dmead> i'm not exactly sure why trees are nessicary
23:16:00 <dmead> because lists have the same efficiency (and are trees internally)
23:16:09 <dcoutts> stepcut: the stuff in the intro about the difference between the direct recursive Haskell version and their nice modular lazy versions made me immediately think of fusion :-)
23:16:25 <stepcut> dcoutts: I bet :)
23:22:47 <narain> if i use some subexpression twice in a big expression, will ghc be smart enough to evaluate it only once?
23:23:03 <dmead> what?
23:23:11 <dmead> yea
23:23:18 <dmead> if you use let/where
23:23:19 <Cale> narain: sometimes.
23:23:39 <sorear> rarely.
23:23:56 <Cale> narain: It does some common subexpression elimination, but if you really care, you should explicitly factor out the expression as a variable with let.
23:23:59 <arcatan> all possible alternatives
23:24:09 <narain> hmm
23:24:16 <narain> ok, that makes sense
23:24:39 <narain> i shouldn't really have expected otherwise i guess
23:25:41 <sorear> @google ghc faq
23:25:42 <lb> http://www.haskell.org/ghc/docs/latest/html/users_guide/faq.html
23:25:43 <lb> Title: Chapter 13. GHC FAQ
23:27:13 <narain> sorear: is that link directed towards me?
23:27:36 <sorear> no, it was directed toward me
23:27:40 <narain> oh, ok
23:27:46 <narain> i read it anyway :)
23:27:51 <sorear> I thought there was an answer for you in it, and I couldn't find it
23:28:13 <sorear> anyway, ghc does very very little CSE because it can introduce space leaks
23:28:16 <narain> i couldn't either
23:28:45 * narain regrets never having taken a compilers course
23:29:06 <sorear> > let biglist 0 = "x" ; biglist k = biglist (k-1) ++ biglist (k-1) in length (biglist 22)
23:29:09 <narain> i see compilers as being some kind of magical black boxes that may or may not do certain optimizations i want
23:29:10 <lb> Terminated
23:29:21 <sorear> I never took a compilers course
23:29:23 <sorear> > let biglist 0 = "x" ; biglist k = biglist (k-1) ++ biglist (k-1) in length (biglist 20)
23:29:26 <lb>  1048576
23:29:39 <sorear> > let biglist 0 = "x" ; biglist k = let cse = biglist (k-1) in cse++cse in length (biglist 20)
23:29:41 <lb>  1048576
23:29:50 <sorear> > let biglist 0 = "x" ; biglist k = let cse = biglist (k-1) in cse++cse in length (biglist 21)
23:29:52 <lb>  2097152
23:30:22 <sorear> in any case, the cse'd version needs ~8megs ram, the non-cse runs in <2k
23:31:33 <narain> sorear: what's the reason for that?
23:32:12 <sorear> which of the two clauses do you want clarified?
23:32:30 <bos> mmmm, fun night of cabal hacking.
23:32:32 <narain> why the cse'd version needs lots of ram
23:32:46 <sorear> bos++ cabal-rpm
23:33:00 <narain> oh wait i think i see
23:33:04 <sorear> remind me to grep the logs when lambdabot comes back.
23:33:43 <narain> you could @tell lb to @tell lambdabot to @tell you to grep the logs
23:37:05 <narain> ?src comparing
23:37:05 <lb> Source not found. My mind is going. I can feel it.
23:37:16 <narain> :t comparing
23:37:19 <lb> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
23:37:37 <narain> ?src Ord
23:37:37 <lb> class  (Eq a) => Ord a  where
23:37:38 <lb>     compare      :: a -> a -> Ordering
23:37:38 <lb>     (<), (<=), (>), (>=) :: a -> a -> Bool
23:37:38 <lb>     max, min         :: a -> a -> a
23:39:30 <narain> ?src Num
23:39:30 <lb> class  (Eq a, Show a) => Num a  where
23:39:30 <lb>     (+), (-), (*)           :: a -> a -> a
23:39:30 <lb>     negate, abs, signum     :: a -> a
23:39:30 <lb>     fromInteger             :: Integer -> a
23:40:40 <eumenides> > undefined == undefined
23:40:42 <lb>  Undefined
23:40:57 <narain> > signum (0 :+ 1)
23:40:59 <lb>  0.0 :+ 1.0
23:41:10 <narain> > signum (3 :+ 4)
23:41:12 <lb>  0.6 :+ 0.8
23:45:09 <narain> :t maximumBy
23:45:12 <lb> forall a. (a -> a -> Ordering) -> [a] -> a
23:48:05 <narain> are nested wheres bad form?
23:48:13 <augustss> yo
23:48:17 <sorear> no, they are simply illegal
23:48:19 <sorear> yo!
23:48:24 <narain> oh
23:48:35 <sorear> wheres in functions in wheres are slightly bad form
23:48:46 <augustss> says who?
23:48:54 <sorear> the indentation police
23:49:05 <sorear> the function length police too
23:49:07 <narain> sorear: yeah, that's what i was going to do, but it felt ugly, hence my question
23:49:26 <augustss> and i'm note sure what narain means by nested wheres
23:49:52 <sorear> by slightly bad form I mean nobody will go out of their way to refactor it, it's just something you should avoid if there is an equally elegant flat way
23:49:58 <sjanssen> augustss: presumably a where clause on a where bound variable
23:50:00 <augustss> you can certainly write 'f x = y where y = z+z where z = x+1'
23:51:28 <sjanssen> but typical style would be f x = y where {y = z + z; z = x + 1}
23:51:32 <hpaste>  fuzan pasted "polymorphism!?" at http://hpaste.org/1401
23:51:34 <narain> i have f x y = foo (g x) (g y) where g x = h x where h = ...
23:51:57 <sorear> g x = h x ~= g = h
23:52:03 <sorear> so you can collapse the wheres
23:52:28 <narain> yes but that was an oversimplification
23:52:28 <sorear> f x y = foo (h x) (h y) where h = ...
23:52:28 <sorear> f = foo `on` h where h = ...
23:52:30 <sorear> oh.
23:52:38 <narain> "on"?
23:52:41 <narain> ?hoogle on
23:52:42 <lb> Test.QuickCheck.oneof :: [Gen a] -> Gen a
23:52:43 <lb> System.Console.Readline.onNewLine :: IO ()
23:52:43 <lb> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
23:52:45 <fuzan> i'm trying to use compos to traverse my AST. I can't seem to figure out how to define a correct type definition allowing me to return a list containing more than a single type from Tree
23:53:05 <narain> aww, that looked like a useful function i kept defining myself
23:53:08 <sorear> Data.Function.on
23:53:15 <sorear> it's in the 6.7 haddocks
23:53:18 <dcoutts> yay, >16,000 C files parsed without error, time to record and push...
23:53:28 <narain> sorear: when was it introduced?
23:53:31 <sorear> http://haskell.org/ghc/dist/current/docs/libraries/base/Data-Function.html#v%3Aon
23:53:32 <lb> http://tinyurl.com/2lubft
23:53:37 <sorear> dcoutts: yay!
23:53:46 <sorear> CADT is starting to work too
23:53:56 <dcoutts> good good
23:54:34 <dcoutts> I've been looking at frown too, as an alternative to happy
23:54:35 <sorear> now, I cabalise Daan's ppr so I can ditch this yuck yuck ++ing code
23:54:49 <dcoutts> looks like we could get much better error messages than with happy
23:55:31 <dcoutts> since frown tells you the set of expected tokens
23:55:49 <narain> ?hoogle (a -> b) -> (a,a) -> (b,b)
23:55:51 <lb> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
23:56:16 <sorear> join (***)
23:56:25 <sorear> > join (***) (+1) (10,20
23:56:25 <lb>  Parse error
23:56:26 <sorear> > join (***) (+1) (10,20)
23:56:28 <lb>  (11,21)
23:56:34 <narain> neat
23:56:46 <narain> feels slightly obfuscated perhaps?
