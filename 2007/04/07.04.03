00:03:48 <robreim> any hugs users around who can help me use cpphs and cabal properly?
00:04:36 <foxy-om> dons: ping
00:05:29 <foxy-om> does anyone here have darcs.haskell.org foo -- sufficient to hand out a login?
00:09:13 <dons> i can't hand out logins.
00:09:15 <sjanssen> foxy-om: they don't hand those out lightly, but Simon Marlow is the man to speak with IIRC
00:09:30 <foxy-om> ping: JaffaCake
00:12:45 <robreim> Ok, is there any hugs users who can help me test a base library patch? Or windows users who can help test it?
00:20:39 <TSC> In GHC (and cabal), how do I link against the profiling version of the base library?
00:22:52 <dons> you use -prof -auto-all
00:23:01 <dons> -prof arrange for the correct profiling libs to be used.
00:23:34 <sjanssen> and you should use --enable-library-profiling with cabal's configure stage to generate profiling versions of your libs
00:23:54 <TSC> Yes, I used --enable-library-profiling with configure
00:24:13 <TSC> And --enable-executable-profiling
00:24:30 <dons> with cabal, yes.
00:24:33 <TSC> Is that enough to do it, or do I need to specify -prof ?
00:24:41 <dons> don't think so.
00:24:52 <TSC> Hmm
00:24:54 <dons> otherwise ,you can add "-prof -auto-all" to the ghc-options field of the cabal file
00:25:05 <dons> make sure you actually have profiling versions of the libraries installed.
00:25:44 <TSC> Yeah, I have the ghc6-prof package
00:25:57 <TSC> I'll try a clean+configure+build, and then try adding -prof -auto-all
00:26:01 <TSC> Thanks
00:26:25 <sjanssen> oh, I think -auto-all isn't default with --enable-library-profiling
00:26:36 <dcoutts> correct
00:28:26 <dons> ah yes. that needs to appear in the ghc-options field.
00:30:06 <foxy-om> does anyone have the time/inclination to help me write a Cabal/autoconf combo for my matlab library? (I am Cabal non-cognoscenti)
00:41:41 <dcoutts> foxy-om: check out say the x11 or opengl packages, they use cabal and autoconf
00:42:35 <foxy-om> dcoutts, yeah, I looked but I can't figure out how to get autoconf to check for matlab, compute the correct directories, and then merge into Cabal
00:43:20 <fasta> How can I find out what is forcing a particular value?
00:46:43 <foxy-om> dcoutts, I want to have a file Matrix.chs which binds to matrix.h, but when I do this c2hs goes into an infinite include loop, is there a way to avoid this?
00:54:14 <opqdonut> .
01:01:54 <cpoucet> ,
01:02:51 <dcoutts> foxy-om: put the .h file in a subdir and #include "blah/thing.h"
01:03:11 <foxy-om> ta
01:05:16 <mux> omg, http://www.threatalertjesus.com/
01:05:18 <lambdabot> Title: Threat Alert Jesus
01:05:42 <foxy-om> dcoutts, actually, the header files are in the search path (the matlab directory) and on the command line I say "c2hs --cppopts=I/c/MATLAB/extern/include --include=C:/MATLAB/extern/include matrix.h Matrix.chs
01:06:54 <dcoutts> foxy-om: I know it's annoying, for gtk2hs we just hacked c2hs, all I can suggest is renaming your .chs module.
01:08:10 <dcoutts> mux: it must be a spoof, it must be (I really hope it is)
01:08:38 <dcoutts> mux: but with paranoid americans... well you never know..
01:11:21 <mux> dcoutts: I don't know, but it got me laughing like a mad man for a few minutes :-)
01:11:32 <dcoutts> ;-)
01:11:38 <mux> 1-800-555-LORD heh
01:12:45 <dcoutts> mux: the one that had me giggling on the train this morning was:
01:12:46 <dcoutts> http://dumpalink.com/pictures/Rave-Naked-With-A-Blue-Light-2b87.html
01:12:49 <lambdabot> Title: Rave Naked With A Blue Light - Dumpalink.com, http://tinyurl.com/2x3unq
01:13:25 <dcoutts> just rub out a couple letters and ...
01:13:46 <mux> heh
01:14:26 <opqdonut> dcoutts: what was "rave" originally?
01:14:34 <dcoutts> travel
01:14:44 <opqdonut> ahh
01:23:10 <osfameron> and naked?
01:23:26 <opqdonut> marked
01:23:47 <osfameron> ah
01:29:09 <TSC> I compiled this function and linked with the profiling base libraries: main = print $ last $ sort [1000000,999999 .. 1]
01:29:40 <TSC> I was expecting to see sort in the profiling output, but it's not there; is it possible that there's no cc for it?
01:30:10 <opqdonut> maybe it was optimized away?
01:30:38 <sjanssen> TSC: that is likely, the base lib isn't compiled with -auto-all
01:30:44 <TSC> Ahh
01:31:03 <TSC> So if I want really complete profiling, I'll need to compile it myself with -auto-all ?
01:31:38 <sjanssen> that prevents noise from a bunch of base functions when a user is profiling their own applicatoin
01:32:04 <sjanssen> it isn't oriented towards profiling the library itself
01:32:28 <dcoutts> you can annotate any expression you like with a cost center
01:32:33 <sjanssen> TSC: yes, though I'm not sure if you can replace your base lib
01:32:44 <dcoutts> you do not need to build base with profiling -auto-all
01:32:59 <sjanssen> ah yes, you could annotate the sort subexpression
01:33:49 <sjanssen> or even import qualified Data.List; sort = Data.List.sort; main = ...
01:33:55 <sjanssen> and compile with -auto-all
01:35:53 <dcoutts> {#- SCC "is your friend" -#}
01:40:36 <TSC> Oh, of course
01:40:40 <TSC> Thanks, guys
01:41:14 <liyang> @hoogle f a -> (a -> b) -> f b
01:41:15 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
01:41:15 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
01:41:15 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
01:41:42 <liyang> How did that (not) work?
01:42:53 <opqdonut> ?hoogle m a -> (a -> b) -> m b
01:42:54 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
01:42:54 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
01:42:54 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
01:42:57 <sjanssen> liyang: there are some issues with hoogle and higher kinds, maybe that's the problem?
01:43:10 <liyang> :(
01:43:13 <sjanssen> @hoogle (a -> b) -> f a -> f b
01:43:13 <liyang> okay
01:43:14 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
01:43:14 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
01:43:14 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
01:43:39 <sjanssen> also, not that your arguments are flipped if you're looking for fmap
01:43:43 <sjanssen> s/not/note
01:44:13 <liyang> sjanssen: I was looking for something easier on the eyes than flip fmap... :)
02:09:19 <foxy-om> anyone here use mingw? if so, does your autoconf stackdump a lot?
02:13:22 <dcoutts> foxy-om: I always generate ./configure on a linux system and run it on other platforms
02:13:32 <foxy-om> ok
02:13:54 <dcoutts> autoconf/automake produce incredibly portable scripts, but they themselves are a royal pain to make work on any platform
02:20:14 <foxy-om> dcoutts, if my package provides a library and someone compiles a ghc program against them do they still need to link against the dlls that I linked against?
02:20:58 <dcoutts> yes, so your package has to specify what those libraries are so that ghc can link programs to them automatically
02:21:17 <Cale> http://www.youtube.com/watch?v=xiRhe8mL_08 -- this is amusing.
02:21:30 <dcoutts> foxy-om: so if you make your package right then programs that use your package will not have to do anything special, it'll all 'just work'
03:27:19 <bvd> Hello, I'm just trying out xmonad and I was wondering what IRC clients you guys are using. The clients I normally use: Kopete or KSirc both have a main window that I never use. I would like to have I client with just one window so that it works nicely with xmonad.
03:27:31 <opqdonut> irssi
03:27:50 <opqdonut> xchat is one-window too iirc
03:28:31 <bvd> ok, emerging irssi right now...
03:30:40 <Cheery> @where unicode
03:30:41 <lambdabot> I know nothing about unicode.
03:31:38 <Cheery> unicode modules for haskell?
03:31:52 <dcoutts> Data.Char has some stuff
03:33:43 <Cheery> well, I'd like to know how one could load an unicode font, select a character and see it's spline patch.
03:33:56 <foxy-om> dcoutts, c2hs takes foo.h bar.chs as args, how do I specify foo.h through the Cabal mechanism?
03:34:23 <opqdonut> Cheery: eh, wouldn't you need some font lib binds for that?
03:35:26 <Cheery> I'd exactly need some font lib binds for that
03:35:40 <dcoutts> foxy-om: an example might help you more than my just answering, look at say the zlib package, it doesn't use c2hs but it does use cabal and is an FFI binding, and it's pretty simple
03:35:44 <dcoutts> @where zlib
03:35:45 <lambdabot> darcs get http://haskell.org/~duncan/zlib
03:36:13 <foxy-om> thanks
03:37:14 <araujo> morning!
03:45:29 <foxy-om> dcoutts, my problem is passing a flag to c2hs through cabal
03:48:30 <dcoutts> Hia JaffaCake
03:48:37 <dcoutts> foxy-om: no, it's saying that you want to use a .h include file
03:48:41 <JaffaCake> hi there!
03:49:19 <rhz> What is the "Haskell HTTP module"?
03:49:22 <kolmodin> hia JaffaCake
03:50:41 <hpaste>  foxy-om pasted "Cabal build error" at http://hpaste.org/1235
03:51:22 <beelsebob> hmm, *is on the hunt for examples again*
03:51:26 <dcoutts> foxy-om: so if using 'include: blah.h' in your .cabal doesn't work then actually I think you can just put the #include <blah.h> directly in your .chs file so that the .h file doesn't need to be specified separately on the command line
03:51:59 <beelsebob> any ideas for a small function, that uses a local definition, which uses a free-variable
03:56:23 <Cheery> does the instance always require to implement all in the class definition?
03:57:15 <beelsebob> everything that does not have a default implementation
03:57:24 <MarcWeber> What might be the reason for getting :  module main:WMII is not loaded   in ghci?
03:57:54 <MarcWeber> When using :m WMII ?
04:00:10 <DavidWHart> hello people
04:00:55 <foxy-om> dcoutts, I've put the include in the c2hs file, but I'm having difficulty passing the --cppopts flag to c2hs to find the .h file (which depends on a configure'd path)
04:01:21 <dcoutts> right, that's not easy
04:01:34 <dcoutts> you have to have configure generate a local build file
04:01:52 <dcoutts> see the opengl or x11 or similar cabal packages in the ghc extra libs tarball
04:02:39 <MarcWeber> solved. Had different module name given in file ;(
04:03:10 <foxy-om> yeah, I've done that (a local build and look at opengl) but neither uses c2hs.  Does Cabal have a c2hs-options option for my foo.buildinfo.in file?
04:03:48 <DavidWHart> Sorry to spam the channel with some stupid questions, but I've been having an argument with someone about haskell and ocaml, me beeing a fervent defender of haskell. Unfortunately, I know nothing more of ocaml than my university degree taught me. I was wondering if some of you guys who know well the two languages can give me some insight on what makes haskell of good language compared to ocaml and also what makes ocaml a good language compared to hask
04:04:19 <foxy-om> DavidWHart: it's axiomatic
04:05:16 <DavidWHart> foxy-on: What is axiomatic? If it's Haskell's superiority, what arguments would you bring forward?
04:05:54 <foxy-om> is OCaml referentially transparent?  Monadic?
04:06:27 <DavidWHart> the question is, does it need to be monadic with the ability to do procedural programming?
04:07:16 <foxy-om> monads are a good way of keeping the pure bits clean and encapsulating mutable things
04:07:36 <DavidWHart> The thing is: OCaml is a multi-pradigm language, and some see that as an advantage, although I don't.
04:07:41 <dcoutts> foxy-om: you don't need c2hs-options you just need to specify the include search path
04:07:50 <dcoutts> which is a generic cabal thing
04:08:18 <dcoutts> though as with the x11/opengl packages you don't know that search path until you've run ./configure
04:08:47 <LPhas> someone tried F#?
04:10:01 <DavidWHart> LPhas: I did. I know the guy who developped that language and had a lengthy talk with him. Although the reasons I don't like OCaml are the same as the ones I don't like F#. For starters, it's strict! :S
04:18:29 <MarcWeber> DavidWHart: Would you prefer F# compared to C++/VB/ .net ?
04:20:01 * elrodeo
04:20:21 * elrodeo test
04:22:58 <LPhas> DavidWHart: but the IDE seems cool :P
04:23:50 <hpaste>  foxy-om annotated "Cabal build error" with "c2hs not finding .h" at http://hpaste.org/1235#a1
04:24:07 <twb> I still don't get how to get cabal-install on a Debian/GHC6.6 box.
04:24:20 <dcoutts> foxy-om: use build -v to see how cabal is calling c2hs
04:24:30 <dcoutts> check if it's passing the -I flags appropriately
04:24:45 <dcoutts> foxy-om: I assume you're using cabal-1.1.6
04:24:48 <foxy-om> dcoutts: that's at the bottom of the paste, c2hs needs the --cppopts flag set
04:25:33 <foxy-om> yup 1.1.6
04:26:17 <dcoutts> foxy-om: looking at the cabal code it looks like it only looks at the cpp-options field in the .cabal file
04:26:25 <dcoutts> oh, wait no
04:26:34 <dcoutts> it looks at the include dirs too
04:28:41 <foxy-om> dcoutts: cpp-options is not documented on http://www.haskell.org/ghc/docs/latest/html/Cabal/authors.html#buildinfo
04:28:43 <lambdabot> Title: 2. Creating a package, http://tinyurl.com/yv8xjt
04:29:00 <dcoutts> foxy-om: so you need to use the include-dirs thing in the local build file
04:29:23 * foxy-om slaps himself
04:29:37 <foxy-om> sorry, I didn't see the c2hs mentioned in the manual
04:29:43 <dcoutts> or if you can't distinguish the include dir specifically then you can just bung all the cpp flags into cpp-options
04:29:58 <dcoutts> foxy-om: cc-options are not used by c2hs at all
04:30:29 <dcoutts> since it has nothing to do with the C compiler, it only uses the C pre-processor
04:33:06 <DavidWHart> MarcWeber: I woulb prefer F# anyday to C++, but not to VB.NET, as VB.NET is just C# with different synthax. I like the .NEt platform.
04:33:46 <dcoutts> F# is .net with an ML syntax
04:34:24 <DavidWHart> basically yes, it's big advantage is that automatic access ot the .NET libries, which are pretty good
04:36:59 <DavidWHart> The only thing is I'm scared Haskell is too slow for certain applications. I'm programming a game in haskell for the Masters degree, to proove to myself that haskell can handle the fast drawing requirements of games
04:37:18 <MarcWeber> DavidWHart: Just to clarify: You would prefer F# to C++ but not F++ to VB.NET? But you are saying there is no big difference between C++ and VB.NET (I agree here)
04:37:53 <MarcWeber> DavidWHart: You know that someone has already written an ego shooter in haskell?
04:38:49 <DavidWHart> MarcWeber: I agree with your first statement, but not with the second. There is a big difference between C++ and VB.NET, the main one beeing a good garbage collector, strong typing, etc...
04:39:00 <DavidWHart> MarcWeber: Do you have a link to that game?
04:39:27 <MarcWeber> DavidWHart: Wait. I'll try digging it up. Some time has passed but I got it working that time.
04:40:17 <DavidWHart> MarcWeber: I've played a bit with HOpenGL yesterday and I'm pretty pleased with their wrapper around OpenGL. It's quite intuitive.
04:40:30 <ski> frag ?
04:40:59 <MarcWeber> So vb.net has a better garbage collector than C++? Seems that you know much more than me ;)
04:41:31 <MarcWeber> ski: Excatly http://www.bluishcoder.co.nz/2005/11/frag-haskell-first-person-shooter.html
04:41:33 <lambdabot> Title: Bluish Coder: Frag: Haskell First Person Shooter, http://tinyurl.com/ywccyq
04:42:09 <ski> @where frag
04:42:10 <lambdabot> http://www.haskell.org/haskellwiki/Frag
04:42:38 <DavidWHart> thx for the links guys
04:43:44 <DavidWHart> MarcWeber: VB.NEt has nothing to do with previous versions of VB. It's based around the .NET Framework, which is virtual machine on whci several languages have been impemented. It's basically Java from Microsoft :))
04:44:16 <MarcWeber> DavidWHart: Sorry. I know I was only talking about .net languages ..
04:44:17 <DavidWHart> MarcWeber: Don't want to insult you if you already knew that, but just in case you didn't know.
04:45:01 <MarcWeber> No. Never again. VB6 (without .net) is compatible to VB1 which should say enough..
04:45:50 <Cheery> are you able to define instances for function patterns?
04:46:25 <DavidWHart> MarcWeber: hehe
04:46:30 <Cheery> I have functions like: (Scalar a) => Double -> a -> a
04:48:19 <Cheery> now I'd like to make an instance of Scalar, to thing like:
04:48:40 <Cheery> (Vectorised a) => a -> a
04:49:01 <Cheery> ie.
04:49:25 <DavidWHart> Cherry: Sorry but my understanding of haskell is quite poor, but would'nt you write your first function as: Double -> Scalar -> Scalar
04:49:32 <Cheery> (centimeters 20 xpos) background
04:50:20 <Cheery> ie. I'd like to define an instance for a function, but still keep it 'open'
04:51:20 <foxy-om> dcoutts, AC_PATH_PROG returns the path of the program with the executable name appended, how can I remove the executable name from the path in autoconf?
04:52:48 <Cheery> hmm, of course I'd have chance to do:
04:52:59 <dcoutts> foxy-om: you've got the power of shell scripting at your fingertips ! :-)
04:53:13 <dcoutts> foxy-om: try basename
04:53:18 <Cheery> (xpos centimeters 20) background, which would basically do the same
04:54:10 <Cheery> and define that the function there should have some Double -> Vector -> Vector, where instance Scalar Vector is defined
04:56:01 <Cheery> then just apply it to a vector inside that thing.
04:57:15 <Cheery> but hmm, am I reinventing a wheel there?
04:58:09 <foxy-om> dcoutts can I use sed in configure.ac?
04:58:20 <dcoutts> sure
05:00:59 <DavidWHart> Can someone explain to me what is the difference between "Scale a => Double -> a -> a" and "Double -> Scale -> Scale"??
05:01:33 <opqdonut> in the first Scale is a class
05:01:37 <opqdonut> in the second a type
05:02:03 <Cheery> DavidWHart: class is a set of types
05:02:45 <Cheery> ie, there's Num -class
05:02:58 <Cheery> @type (+)
05:03:01 <lambdabot> forall a. (Num a) => a -> a -> a
05:03:08 <Cheery> @type (/)
05:03:11 <lambdabot> forall a. (Fractional a) => a -> a -> a
05:03:16 <DavidWHart> right, and the "=>" notation is the only way to use classes in the signature of the function?
05:03:16 <Cheery> and so on
05:04:16 <Cheery> @info Integer
05:04:17 <lambdabot> Integer
05:04:37 <Cheery> DavidWHart: not sure
05:05:25 <cpoucet> @type lift2M
05:05:27 <lambdabot> Not in scope: `lift2M'
05:05:47 <foxy-om> @hoogle liftM2
05:05:48 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
05:05:48 <lambdabot> Control.Monad.liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
05:06:48 <DavidWHart> wow, you can hoogle from the chat client?? (O_O amazed)
05:07:00 <DavidWHart> @getBounds
05:07:00 <lambdabot> Unknown command, try @list
05:07:11 <DavidWHart> @hoogle getBounds
05:07:12 <lambdabot> No matches found
05:07:17 <DavidWHart> @list
05:07:17 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
05:07:28 <Thunder> David: Use /msg lamdabot for your tests.
05:07:41 <foxy-om> @hoogle bounds
05:07:42 <lambdabot> Array.bounds :: Ix a => Array a b -> (a, a)
05:07:42 <DavidWHart> ok, thx
05:07:42 <lambdabot> Data.Array.bounds :: Ix i => Array i e -> (i, i)
05:07:42 <lambdabot> Data.Array.IArray.bounds :: (HasBounds a, Ix i) => a i e -> (i, i)
05:08:45 <DavidWHart> gtg, thx for the chat
05:39:46 <haskellboy> hi, i'm looking at the easiest way to replace the first occurance of an old point with a new point in a list of points, any ideas ?!
05:41:42 <haskellboy> swapPoint :: Point -> Point -> [Point] -> [Point] -- where the first point is the old pt, 2nd is the new pt, and the resulting list has the old point replaced with the new point
05:42:21 <kolmodin> haskellboy: is it homework?
05:46:57 <qwr> haskellboy: map it
05:47:13 <opqdonut> err, he only wants to replace the first occ.
05:49:11 <haskellboy> no it's not homework, it's part of a program i'm writing to learn haskell
05:49:28 <qwr> ah, so Data.List.break it?
05:49:54 <foxy-om> @hoogle spliAt
05:49:55 <lambdabot> No matches found
05:50:01 <foxy-om> @hoogle splitAt
05:50:02 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
05:50:02 <lambdabot> Data.PackedString.splitAtPS :: Int -> PackedString -> (PackedString, PackedString)
05:50:02 <lambdabot> List.genericSplitAt :: Integral a => a -> [b] -> ([b], [b])
05:52:03 <dhart> hi
05:52:19 <haskellboy> the predicate in break always fails for some reason
05:52:33 <foxy-om> @hoogle break
05:52:34 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
05:52:34 <lambdabot> GHC.ConsoleHandler.Break :: ConsoleEvent
05:52:34 <lambdabot> Data.PackedString.breakPS :: (Char -> Bool) -> PackedString -> (PackedString, PackedString)
05:52:53 <qwr> > break ((=) 'l') "kala"
05:52:54 <lambdabot>  Parse error
05:53:04 <qwr> > break ((==) 'l') "kala"
05:53:06 <lambdabot>  ("ka","la")
05:53:39 <haskellboy> fancy!
05:54:52 <qwr> little pattern match of the result and you're done
05:55:40 <LPhas> :t brak
05:55:42 <lambdabot> Not in scope: `brak'
05:55:47 <LPhas> :t break
05:55:49 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
05:56:07 <haskellboy> break ((==) (3,4)) [(1,2),(5,6),(3,4),(7,7)]
05:56:16 <haskellboy> ([(1,2),(5,6)],[(3,4),(7,7)])
05:56:21 <haskellboy> so far so good
06:01:31 <qwr> > case break ((==) 'l') "cold" of { (a, _:b) -> a ++ 'r' : b; (a, []) -> a }
06:01:33 <lambdabot>  "cord"
06:03:52 <foxy-om> (\in (xs,y:ys) -> xs++(in:ys)) 'r' $ (break (== 'l') cold
06:06:01 <qwr> > (\in (xs,y:ys) -> xs++(in:ys)) 'r' $ (break (== 'l') "xxxx"
06:06:02 <lambdabot>  Parse error
06:06:10 <qwr> > (\in (xs,y:ys) -> xs++(in:ys)) 'r' $ break (== 'l') "xxxx"
06:06:11 <lambdabot>  Parse error
06:06:45 <qwr> > (\n (xs,y:ys) -> xs++(n:ys)) 'r' $ break (== 'l') "xxxx"
06:06:47 <lambdabot>   Non-exhaustive patterns in lambda
06:07:17 <chessguy> 'morning haskellers
06:09:04 <hpaste>  foxy-om annotated "Cabal build error" with "include-dirs uses -C -I not --cppopts as I need for c2hs" at http://hpaste.org/1235#a2
06:09:16 <chessguy> @type break
06:09:18 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
06:09:43 <chessguy> > break (== '1') "xxxx"
06:09:44 <lambdabot>  ("xxxx","")
06:10:10 <foxy-om> dcoutts: ^^
06:10:12 <chessguy> qwr: "" doesn't match against y:ys
06:11:09 <chessguy>  > (\n (xs,y:ys) -> xs++(n:ys)) 'r' ("","xxxx")
06:11:21 <chessguy> > (\n (xs,y:ys) -> xs++(n:ys)) 'r' ("","xxxx")
06:11:22 <lambdabot>  "rxxx"
06:11:55 <qwr> chessguy: i know :)
06:12:15 <foxy-om> @time dcoutts
06:12:16 <lambdabot> Local time for dcoutts is Tue Apr  3 23:09:43
06:12:17 <chessguy> obviously
06:14:07 <foxy-om> @where cabal
06:14:07 <lambdabot> http://www.haskell.org/cabal
06:20:28 <ivanm> @pl \(x,y) -> (x, f (x,y))
06:20:28 <lambdabot> uncurry (liftM2 (.) (,) ((f .) . (,)))
06:26:28 <arcatan> I'm writing an app with gtk2hs and I want to execute some commands when pressing a button
06:26:39 <arcatan> I tried to use System.Cmd.system, but it blocks the app
06:32:35 <dons> arcatan: you probably want -threaded ?
06:32:52 <haskellboy> qwr thank you
06:32:53 <haskellboy> -- Outputs a list with the old point substituted for the new point
06:32:55 <haskellboy> swapPoint :: Point -> Point -> [Point] -> [Point]
06:32:58 <haskellboy> swapPoint np op ps = case break ((==) op) ps of { (a, _:b) -> a ++ np : b; (a, []) -> a}
06:33:09 <earthy> drat. UU.Parsing requires Ord on the tokens
06:33:24 <araujo> dons, hello!
06:33:25 <dons> damn Ord. I hates it.
06:33:47 <dons> so many lovely rewrite rules we could use, if only we could rely on sane Ord instances
06:33:58 <earthy> ghe
06:34:26 <earthy> there's too much stuff with insane Ord instances? :)
06:34:28 <dons> you should have to pass a license before being allowed to write instances :-)
06:34:36 <arcatan> dons: okay, thanks
06:34:51 <dons> earthy: well, whenever we try to pull some funny rewrite rule, lennart pops up and says "ah ha! here's a funny instance that will break that"
06:34:57 <dons> its very disheartening ;-)
06:35:18 <earthy> it's very lennart. :)
06:35:27 <arcatan> I wonder what those bad things are which are going to happen if I call Gtk from multiple threads
06:35:47 <earthy> hm. interesting that there's no default instance (Enum a) => Ord a
06:36:12 <earthy> arcatan: crashes will happen
06:36:19 <earthy> inconsistent drawing states will happen
06:36:19 <sjanssen> earthy: you can't express that without overlapping instances
06:36:30 <earthy> sjanssen: true enough
06:36:42 <dons> sjanssen: so i replied to Anselm's nice email about xmonad :-)
06:36:58 <dons> "I think it's very cool that people try to clone dwm" he says. so that's good.
06:37:00 <sjanssen> dons: even the instance for Double is broken.  I don't think you're allowed to complain until the Haskell Committee get it right :)
06:37:08 * earthy ponders making the token space an Enum and an (arbitrarily ordered) Ord...
06:37:16 <arcatan> okay
06:37:36 <dons> oh, the Enum instance for Double?
06:37:45 <dons> I guess the Ord instance too ...
06:37:54 <dons> but floating point is illegal in some states anyway
06:38:00 <sjanssen> dons: ah good, you set him straight on X11-extras
06:38:06 <earthy> floating point is for those that smoke the good crack
06:38:30 <dons> like lennart, the lord of the floating points :-)
06:38:45 <dons> > 1.1 + 2.2 -- woohoo!
06:38:47 <lambdabot>  3.3000000000000003
06:38:51 <sjanssen> ISTR that lennart hates floating point
06:38:53 <doserj> dons: I would love it if you could demand axioms for type-class instances, and not only suggest them
06:38:55 <Syzygy-> Whoa!?
06:39:03 <Syzygy-> > 1.1 + 2.2 + 3.3
06:39:05 <lambdabot>  6.6
06:39:09 <Syzygy-> o.O
06:39:18 <sjanssen> @check \x y -> (x + y) - y == x
06:39:20 <lambdabot>  Add a type signature
06:39:31 <sjanssen> @check \x y -> (x + y) - y == (x :: Float)
06:39:33 <lambdabot>  Falsifiable, after 6 tests: -3.0, -2.3333333
06:39:46 <dons> oh, this rocks! http://www.haskell.org/pipermail/haskell/2007-April/019303.html
06:39:47 <lambdabot> Title: [Haskell] The real Monad Transformer
06:39:55 <dons> translate haskell into "english" :-)
06:40:00 <dons> for the entire internets.
06:40:43 <sjanssen> lol
06:40:58 * earthy feels all warm and fuzzy ;)
06:41:06 <opqdonut> :DD
06:41:56 <dolio> "Research papers/Warm, fuzzy things and arrows"
06:42:04 <dons> hehe
06:43:50 <dolio> So, it seems you've been challenged to write a rudimentary build system, dons. :)
06:44:08 <joelr1> good day
06:44:22 <earthy> morning joel
06:44:43 <joelr1> is there a cabalized version of hunit or does everyone use quickcheck?
06:45:03 <glguy> don't those two do different things?
06:45:30 <joelr1> glguy: yes, they sort of do
06:45:47 <sjanssen> @check (1 :: Int) == 1 -- quickcheck kinda works for unit tests
06:45:47 <dons> joelr1: everyone uses quickcheck (note that a zero-arity QC property is a unit test)
06:45:48 <lambdabot>  OK, passed 500 tests.
06:46:15 <glguy> I feel better knowing that 1 == 1 even if you try it 500 times
06:46:15 <dons> unit testing is just the degenerate case for quickcheck :-)
06:46:31 <dons> ?scheck 1 == (1 :: Int)
06:46:32 <sjanssen> @smallcheck (1 :: Int) == 1 -- better?
06:46:33 <lambdabot>   Completed 1 test(s) without failure.
06:46:33 <lambdabot> Unknown command, try @list
06:46:39 <dons> SmallCheck is smarter
06:46:46 <joelr1> cool. i'll go look for some examples
06:46:51 <joelr1> dons: what's smallcheck? part of qc?
06:46:59 <dons> a seperate checker.
06:47:02 <dons> ?where smallcheck
06:47:03 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/smallcheck/
06:47:16 <joelr1> dons: is it better than qc? is it the new trend? :D
06:47:19 <dons> it does breadth first search inductively on the type to generate test cases.
06:47:22 <foxy-om> dons, is dcoutts in au? I thought he was from uk?
06:47:23 <dons> well, its different
06:47:31 <dons> depth first rather than random walk to produce tests
06:47:34 <sjanssen> as opposed to quickcheck, where the tests are random
06:47:43 <dons> foxy-om: he's visiting us in sydney, but he's from oxford, foxy-om
06:47:57 <dons> we've strapped him into a chair and made him write papers.
06:48:00 <dons> its cool!
06:48:06 <joelr1> dons: great, i'll start with smallcheck then
06:48:06 <foxy-om> he
06:48:12 <dons> code/papers/code/papers/lunch/code/papers/beer/code/papers
06:48:22 <dons> joelr1: oh, i'd start with QuickCheck
06:48:27 <dons> since it has far more instances predefined.
06:48:40 <joelr1> dons: i'm not sure random testing will do well in testing a parser
06:48:45 <dons> if you're doing something particular with a list-ish structure, smallcheck might be useful (we needed it for testing strictness properties)
06:49:06 <dons> yeah, maybe. depends on how you want to construct the the random parse trees ( is that the plan?)
06:49:14 <joelr1> dons: intuitively, smallcheck seems better for parser testing
06:49:21 <dons> maybe, yeah.
06:49:22 <joelr1> dons: i don't, i have code samples
06:49:30 <joelr1> thanks for the pointer
06:49:34 <dons> ok. well if you're just unit testing , they both behave the same way
06:49:44 * joelr1 is rewriting his fully-functioning parser from ocaml 
06:49:48 <dons> its when you want to generate random tests that smallcheck and QC diverge
06:49:56 <sjanssen> well, smallcheck will be much quicker for unit testing -- it's smart enough to run the test only once
06:50:06 <joelr1> dons: i'll read up on the divergence
06:50:11 <dons> sjanssen: ah yes, good point.
06:50:30 <sjanssen> on the other hand, quickcheck is probably packaged with your compiler
06:50:37 <dons> we notably used smallcheck along with 'ChasingBottoms' to generate strictness tests for our list library
06:50:53 <joelr1> dons: your list library ?
06:50:54 <dons> which we obviously want to exhaustively search strictness up to a certain depth for lists
06:51:10 <dons> ?where streams
06:51:11 <lambdabot> http://haskell.org/haskellwiki/Library/Streams
06:51:13 <dons> that guy.
06:51:15 <dons> no.
06:51:20 <dons> not that one.
06:51:36 <dons> http://www.cse.unsw.edu.au/~dons/streams.html
06:51:36 <lambdabot> Title: Data.List.Stream
06:53:22 <haskellboy> last question guys, i think i can use the case again
06:53:28 <joelr1> dons: is your blog part of planet haskell?
06:53:29 <haskellboy> what if i wanted to take a new point and an old point and a list containing pairs of color and points looking like [(Color,[Point])]
06:53:38 <rhz__> Is it possible to load multiple modules from the command line in ghci?
06:54:02 <haskellboy> and if i want to replace only first occurance of the old point with the new point ?
06:54:11 <rhz__> Hope that's not a question with an obvious answer.
06:54:13 <dons> joelr1: it is.
06:54:18 <joelr1> ok
06:54:19 <joelr1> thanks
06:54:22 <dons> rhz__: :m + Foo
06:54:44 <rhz__> dons: thanks
06:55:07 <mightybyte> rhz__: :? is the help where you'll find that
06:55:43 <haskellboy> swapFirstPt :: Point -> Point -> [(Color,[Point])] -> [(Color,[Point])]
06:55:46 <rhz__> I am aware of :? but didn't notice the + option before
06:56:34 <mightybyte> rhz__: Yeah, I didn't see it at first either.
06:58:31 <quicksilver> that isn't pairs of colours and points, haskellboy
06:58:40 <quicksilver> that's pairs of colours and lists of points :)
06:58:49 <haskellboy> yes that's what i want
06:59:00 <ivanm> @pl \(a,b) (c,d) -> ((a,c),(b,d))
06:59:01 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (,)) . flip . (((.) . (,)) .) . (,))
06:59:30 <haskellboy> each pair is a bunch of control points for a curve
06:59:34 <quicksilver> haskellboy: you already have a function which works on lists, and you want to apply it to every list in that list-of-pairs-of-lists?
07:00:18 <haskellboy> i want the first occurance of a point to be replaced
07:00:37 <haskellboy> in my list of pairs of colors and list of points!
07:00:45 <quicksilver> first occurence in every sublist?
07:00:53 <quicksilver> or the first occurence int he first sublist in which it appears/
07:01:00 <ivanm> @hoogle iterate
07:01:00 <haskellboy> no only the first occurance, once
07:01:00 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
07:01:03 <ivanm> @src iterate
07:01:04 <lambdabot> iterate f x =  x : iterate f (f x)
07:01:15 <foxy-om> can points be associated with more than one colour?
07:01:19 <haskellboy> the first occurence int he first sublist in which it appears
07:01:43 <haskellboy> for each pair, there is only one color
07:02:03 <foxy-om> so there's a unique colour for each point?
07:02:16 <earthy> @seen philippa
07:02:16 <lambdabot> philippa is in #oasis, #haskell, #haskell-blah, #haskell-overflow, #haskell-soc and #scannedinavian. I last heard philippa speak 10h 48m 51s ago.
07:02:38 <haskellboy> each pair's color is not unique
07:02:48 <quicksilver> swapFirstPt a b [] = [] ; swapFirstPt a b ((c,pp):xs) = if a `elem` pp then (c,swapPoint a b pp):xs else (c,pp):(swapFirstPt xs)
07:02:54 <ivanm> @hoogle zipwith
07:02:55 <lambdabot> Prelude.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
07:02:56 <lambdabot> List.zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
07:02:56 <lambdabot> List.zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]
07:02:59 <foxy-om> maybe you wnat swapFirstPt :: Point -> Point -> [(Color,Point)] -> [(Color,Point)]
07:03:40 <ivanm> @pl tails . repeat
07:03:41 <lambdabot> tails . repeat
07:06:12 <ivanm> repeat [1,2,3]
07:06:19 <ivanm> > repeat [1,2,3]
07:06:21 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,...
07:06:31 <ivanm> cycle [1,2,3]
07:06:35 <ivanm> > cycle [1,2,3]
07:06:36 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
07:08:55 <Xif> have you guys read "Worse is Better"?
07:10:41 <earthy> xif: that's the 'the unix philosophy won' paper?
07:10:57 <earthy> by jwz?
07:10:58 <Xif> yeah, by Gabriel
07:11:06 <Xif> JWZ only links to it, iirc
07:11:14 <joelr1> how do you write a smallcheck prop that checks that for every invocation of f on a string arg, show result equals arg?
07:11:47 <sebell> I've got a few pieces of my puzzle together, I'm trying to do something in the spirit of Expect. I want to have a TCP socket and attempt to match a Parsec parser against the input, within a certain timeout period, or fail. Any ideas on getting input without blocking, and returning the match as soon as it is available?
07:12:22 <sjanssen> joelr1: something like prop s = show (f s) == s
07:12:33 <hrist> hey sjanssen your wm is great :P
07:12:48 <joelr1> sjanssen: oh, that easy? darn. thanks!
07:12:51 <sjanssen> hrist: thanks
07:13:24 <sjanssen> joelr1: of course that can't check *every* string, because you only have finite time
07:13:30 <sjanssen> it'll check a bunch of them, though
07:14:07 <joelr1> sjanssen: no, i have a list of them that i need to check
07:14:18 <joelr1> sjanssen: and run the test for every one of them
07:14:49 <joelr1> sjanssen: or, basically, i have a list of code samples to parse and need to make sure the ast when printed equals to the code sample.
07:15:39 <joelr1> sjanssen: maybe it's better to check by supplying the ast itself but it's simpler to do the former for simple code samples
07:15:46 <joelr1> sjanssen: like keywords
07:18:27 <sjanssen> hrist: I'm curious, where did you learn of xmonad?  Just chatter in #haskell?
07:18:37 <hrist> nope
07:18:45 <hrist> a friend of mine told me about it
07:19:00 <hrist> i was using dwm for a while and he saw something about xmonad on a mailinglist
07:19:31 <hrist> this all happened today :)
07:19:41 <hrist> around 11am
07:20:07 <sjanssen> yes, somebody mentioned xmonad on the dwm list
07:20:17 <hrist> dunno
07:20:45 <hrist> with dwm i can say that eg firefox will always start on the second workspace is there something similar in xmonad?
07:21:11 <sjanssen> not yet
07:21:15 <hrist> ah okay
07:22:07 <joelr1> dons: should i always be using Data.List.Stream ?
07:24:03 <sjanssen> joelr1: as I understand it, Data.List.Stream is more a research vehicle than a library for the average user
07:24:30 <joelr1> sjanssen: but it's supposed to provide optimizations, no?
07:24:58 <sjanssen> joelr1: yes, you'll probably see some speedups
07:25:25 <sjanssen> if your code is list heavy, and is ripe for fusion (especially fusion that build/foldr can't handle)
07:25:45 <Xif> are there jobs for Haskell programmers?
07:26:06 <sjanssen> joelr1: but I'd only recommend using it if you know *why* you need it
07:26:32 <joelr1> sjanssen: why? would i see slowdowns otherwise?
07:26:48 <earthy> xif: what, outside of academia? yeah, a few
07:26:56 <sjanssen> joelr1: that library is a testbed for the next version of the base libraries
07:27:06 <joelr1> i see
07:27:13 <Xif> earthy: if I'm already a CS professor, I don't really need a job :P
07:27:20 <sjanssen> joelr1: no, it's just a pointless extra dependency if you don't need it
07:27:31 <sorear> hi.
07:27:40 <joelr1> sjanssen: one more sc question... is there a quick way to say for every item in this list make sure the prop holds?
07:27:51 <earthy> xif: heh
07:27:57 <sjanssen> joelr1: the standard function, all
07:28:00 <sjanssen> @type all
07:28:03 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
07:28:03 <kalven> language adhd
07:28:08 <joelr1> ah, ok
07:28:09 <sjanssen> > all even [2 ..]
07:28:10 <joelr1> thanks
07:28:11 <lambdabot>  False
07:28:15 <sjanssen> > all even [2, 4 ..]
07:28:19 <lambdabot> Terminated
07:28:23 <sjanssen> heh, that won't terminate :)
07:28:49 <Xif> earthy: the thing is, I liked Ruby alot, and thankfully you can now actually make a living doing Ruby (mostly on Rails) development.
07:29:13 <Xif> so I was wondering whether I could make a living writing Haskell, because it seems like a cool language, just impractical.
07:29:29 <ivanm> @pl \ (v1,x) (v2,y) -> ((v1,v2),f x y)
07:29:31 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. f) . flip . (((.) . (,)) .) . (,))
07:29:35 <sjanssen> Xif: why does Haskell seem impractical?
07:29:46 <sorear> There are a few people who can do it.
07:30:06 <sorear> ISTR earthy saying he had an adequately paying Haskell job.
07:30:09 <sjanssen> Xif: and yeah, there are Haskell users in industry.  Galois, Linspire, Credit Suisse ...
07:30:44 <sjanssen> a couple people in #haskell do paid HApps development
07:31:03 <sorear> AIUI it's mostly an issue of "this is a low-popularity language, and only the few organizations that have Haskell code already hire haskellers"
07:31:19 <Xif> yeah, exactly.
07:31:39 <ivanm> @hoogle Char -> Int
07:31:40 <lambdabot> Char.digitToInt :: Char -> Int
07:31:40 <lambdabot> Char.ord :: Char -> Int
07:31:48 <ivanm> > digitToInt 'a'
07:31:50 <lambdabot>  10
07:31:52 <Xif> also, because of #1, theres a lack of good libraries.
07:31:57 <ivanm> intToDigit 0
07:32:02 <ivanm> > intToDigit 0
07:32:03 <lambdabot>  '0'
07:32:11 <ivanm> > intToDigit 100
07:32:12 <lambdabot>  Exception: Char.intToDigit: not a digit 100
07:32:17 <ivanm> :D
07:32:47 <dolio> > intToDigit 10
07:32:49 <lambdabot>  'a'
07:33:38 <Xif> if it was probable to get a job doing Haskell, and if there are enough libraries, I'd learn it (who cares if it's "popular", whatever "popular" means)
07:34:26 <ivanm> ord 'a'
07:34:32 <ivanm> > ord 'a'
07:34:33 <lambdabot>  97
07:35:00 <sjanssen> Xif: there are certainly advantages to learning Haskell that don't have any direct connections with getting a job
07:35:32 <Xif> sjanssen: you wouldn't say that if you didn't have some in mind... :)
07:35:40 <Xif> s/say/have said/
07:36:11 <sjanssen> it is good to learn new things
07:36:45 <earthy> actually, there are even advantages to learning Haskell that *do* have direct connections with getting a job
07:36:47 <sjanssen> and with respect to most programmer's backgrounds, Haskell is very new :)
07:37:09 <earthy> just looking at problems from a functional perspective cleans up your code in other languages *enormously*
07:37:18 <Xif> Haskell seems very cool, but being able to pay the rent is even cooler ;-)
07:37:29 <earthy> hell, I've been known to write out LL(1) parsers in C at type-speed
07:37:40 <earthy> couldn't have done that without having been exposed to functional programming
07:38:04 <Xif> earthy: Ruby has a lot of FP capabilities, thought from what I've seen Haskell has a lot of concepts Ruby lacks.
07:38:19 <earthy> well
07:38:21 <earthy> not really
07:38:21 <Xif> I bet I could still do a lot of stuff in Ruby.
07:38:29 * Codex_ noticed that he's now doing pure functions instead of side effects in my C++ code.
07:38:31 <phoniq> earthy, that's exactly what I want to learn...  got any pointers, favorite links, books?
07:38:35 <earthy> it's just that in Haskell it is a lot easier doing the stuff
07:38:55 <phoniq> working through the parser section in "Programming in Haskell" now
07:39:08 <phoniq> bought "Types and Programming Languages"
07:39:15 <Xif> earthy: there's even a pure Ruby implementation for that thing about calling the function according to the number of arguments
07:39:31 <earthy> currying, you mean? :)
07:39:40 <earthy> and partial parametrisation? :)
07:39:42 <ivanm> @pl \ x y -> f (g (h x y))
07:39:43 <lambdabot> ((f . g) .) . h
07:39:56 <Xif> (you know, "do this if the call looks like foo(a, b), otherwise do that"
07:40:15 <ivanm> @pl \ x y -> t (f (g (h x y)))
07:40:16 <lambdabot> ((t . f . g) .) . h
07:40:35 <Xif> earthy: hm, there's that -> http://moonbase.rydia.net/mental/blog/programming/currying-in-ruby but I meant something else
07:40:37 <lambdabot> Title: Currying in Ruby - Moonbase, http://tinyurl.com/2bzwlw
07:41:10 <sjanssen> Xif: you mean variable argument functions?  That isn't really a popular Haskell technique
07:41:36 <earthy> oh well, drinks time
07:41:46 <earthy> let's see if I can pressure Doaitse into giving me some of his code
07:42:26 <foxy-om> dons: ping
07:43:53 <sjanssen> Xif: beyond functional programming, there are still things you'll never learn in Ruby.  The power of static typing + inference, for one
07:44:35 <Xif> earthy, sjanssen: ah, here it is -> http://www.artima.com/rubycs/articles/patterns_sexp_dsls.html
07:44:36 <lambdabot> Title: If It's Not Nailed Down, Steal It
07:44:48 <Xif> sjanssen: is that what you called "variable argument functions"?
07:44:48 <sjanssen> I'm sure laziness isn't nearly as convenient in Ruby
07:45:03 <Xif> sjanssen: I'm sure there are.
07:45:17 <sjanssen> are you referring to the first hack?
07:45:30 <Xif> yes
07:46:00 <sjanssen> nah, I was referring to something else.  We call that 'pattern matching', just like the article
07:46:17 <sjanssen> so that is possible in Ruby, but it will never be as convenient
07:47:10 <matthew-_> @unpl \f c a b = (f a) `c` (f b)
07:47:10 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 1}: Parse error
07:47:13 <matthew-_> mmm.
07:48:19 <sjanssen> matthew-_: ->
07:48:19 <matthew-_> ok, so it was a syntax err (= vs ->)
07:48:38 <ivanm> @hoogle mod
07:48:39 <lambdabot> Prelude.mod :: Integral a => a -> a -> a
07:48:39 <lambdabot> Prelude.module :: keyword
07:48:39 <lambdabot> Data.IORef.modifyIORef :: IORef a -> (a -> a) -> IO ()
07:51:16 <ivanm> @pl shiftString c n = intsToAlphs . map (flip mod alphabetSize . (+n)) . alphsToInts $ c
07:51:17 <lambdabot> shiftString = flip ((intsToAlphs .) . (. alphsToInts) . map . (flip mod alphabetSize .) . (+))
07:53:19 <ivanm> @pl shiftString n c = intsToAlphs . map (flip mod alphabetSize . (+n)) . alphsToInts $ c
07:53:19 <lambdabot> shiftString = (intsToAlphs .) . (. alphsToInts) . map . (flip mod alphabetSize .) . (+)
07:56:20 <ivanm> is there an unzipwith, analogous to zipWith?
07:56:46 <sjanssen> hmm, what would the type of that look like?
07:57:03 <ivanm> As in [(a,b)] -> [c]
07:57:13 <ivanm> I suppose I could just map a joining function...
07:57:15 <sjanssen> @type \f xs -> uncurry f . unzip $ xs
07:57:17 <lambdabot> forall c a b. ([a] -> [b] -> c) -> [(a, b)] -> c
07:57:38 <sjanssen> where does the [c] come from?
07:57:56 <ivanm> maybe its not really unzipping :s
07:58:08 <sjanssen> @type \f xs -> map (uncurry f) xs -- maybe this?
07:58:11 <lambdabot> forall a b c. (a -> b -> c) -> [(a, b)] -> [c]
07:58:14 <ivanm> I just wanted a way to combine a list of pairs into a list... whch is just a mapping
07:58:16 <ivanm> duh!
07:58:30 <joelr1> ?where smallcheck
07:58:31 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/smallcheck/
07:58:35 <ivanm> @pl \(x,y) -> x+y
07:58:36 <lambdabot> uncurry (+)
07:59:25 <sorear> @ty mapAndUnzip
07:59:28 <lambdabot> Not in scope: `mapAndUnzip'
07:59:44 <sorear> odd.  there's mapAndUnzipM but not mapAndUnzip?
08:00:18 <dolio> :t mapAndUnzipM
08:00:21 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m (b, c)) -> [a] -> m ([b], [c])
08:00:38 <ivanm> @pl decode c ns = intsToAlphs . map (flip mod alphabetSize . uncurry (+)) . zip (cycle ns) $ (alphsToInts c)
08:00:39 <lambdabot> decode = flip (((intsToAlphs . map (flip mod alphabetSize . uncurry (+))) .) . zip . cycle) . alphsToInts
08:00:55 <ivanm> @pl decode ns c = intsToAlphs . map (flip mod alphabetSize . uncurry (+)) . zip (cycle ns) $ (alphsToInts c)
08:00:56 <lambdabot> decode = (. alphsToInts) . ((intsToAlphs . map (flip mod alphabetSize . uncurry (+))) .) . zip . cycle
08:01:21 <ivanm> @pl decode ns c = intsToAlphs . map (flip mod alphabetSize . uncurry (+)) . zip (alphsToInts c) $ (cycle ns)
08:01:21 <lambdabot> decode = flip (((intsToAlphs . map (flip mod alphabetSize . uncurry (+))) .) . zip . alphsToInts) . cycle
08:01:27 <ivanm> @pl decode c ns = intsToAlphs . map (flip mod alphabetSize . uncurry (+)) . zip (alphsToInts c) $ (cycle ns)
08:01:28 <lambdabot> decode = (. cycle) . ((intsToAlphs . map (flip mod alphabetSize . uncurry (+))) .) . zip . alphsToInts
08:01:36 <glguy> ivanm: why not send those to lambdabot in a private message
08:01:40 <glguy> so that you don't flood the channel
08:01:47 <ivanm> glguy: because I didn't think of that? ;-)
08:01:52 <ivanm> sorry, will do so in future
08:20:28 <Xeh> http://www.voinaroz.lv/?auk=2i1i18g2oxz Check it out ;)
08:20:31 <lambdabot> Title: ¬´–í–æ–π–Ω–∞ – –æ–∑¬ª - –í–æ—Å—Å—Ç–∞–Ω–∏–µ
08:26:31 <Xif> btw, Currying in Ruby: http://moonbase.rydia.net/mental/blog/programming/currying-in-ruby
08:26:32 <lambdabot> Title: Currying in Ruby - Moonbase, http://tinyurl.com/2bzwlw
08:36:30 * lypanov wibbles
08:36:31 <Janimaku> hi there
08:36:52 <lypanov> someone should explain monads to me in a single sentence
08:36:54 <lypanov> *nod*
08:37:33 <sorear> A monad is an abstract type used to describe something you want to happen.
08:37:50 <lypanov> whats behind the name?
08:38:08 <dolio> Category theory.
08:38:15 * lypanov wonders if typing /topic erases it or prints it out
08:38:20 <sorear> SPJ is on record as saying they should have
08:38:25 <sorear> prints it out
08:38:26 <sjanssen> but the origin of the name is inconsequential
08:38:39 <lypanov> sjanssen: aids understanding and memory :)
08:38:41 <sorear> SPJ is on record as saying they should have called them "warm fuzzy things"
08:38:50 <lypanov> lol
08:39:00 <lypanov> i just read beautiful concurrency
08:39:09 <lypanov> so now i'm in #haskell. *sigh*
08:39:16 <sjanssen> lypanov: unless you're intimately familiar with category theory, the name probably won't help you much :)
08:39:21 <lypanov> sjanssen: ah. hehe
08:39:57 <Janimaku> it would be nice if someone would give me a link to a tutorial for efficiency and abstract datatypes in / for Haskell
08:40:22 <sorear> And even if you are... most Haskell "Monads" are real maths monads only to the extent that double-precision floating point numbers are a group
08:40:38 <sorear> > (1 + 1e100) - 1e100
08:40:43 <lambdabot>  0.0
08:41:39 <sjanssen> @check \x y -> (x + y) - y == (x :: Float) -- same result with more reasonable numbers
08:41:41 <lambdabot>  Falsifiable, after 24 tests: 1.6666666, -6.4
08:42:05 <desp> lypanov: http://www.randomhacks.net/articles/2007/03/12/monads-in-15-minutes
08:42:08 <lambdabot> Title: Monads in 15 minutes: Backtracking and Maybe, http://tinyurl.com/2xlyze
08:42:11 <desp> highly recommended
08:42:36 <lypanov> any podcasts or screencasts or videos?
08:42:42 <glguy> of what?
08:42:46 <lypanov> scala won out to haskell because scala has a google video ;)
08:42:51 <glguy> lol
08:43:00 <kc5tja> I also wrote my own interpretation of monads, but it takes a much lower level look at things.  As suggested, the topic is my own understanding of them, and may not model reality.  ;)
08:43:10 * sorear wonders if "lypanov" is a corruption/alternate transliteration of the name I've heard as "lyapunov" mostly before
08:43:11 * lypanov is easily distracted
08:43:12 <kc5tja> http://www.falvotech.com/content/publications/monads
08:43:15 <lambdabot> Title: Haskell Monads: Another View
08:43:16 <lypanov> sorear: yup
08:43:21 <lypanov> sorear: to get me google-able
08:43:27 <sjanssen> my single sentence introduction: The Monad class provides a common interface to many models of computation.
08:43:47 <glguy> Monad = type of sequenced computation
08:43:59 <lypanov> glguy: also the conclusion i'm coming to
08:44:01 <glguy> sequential
08:44:07 <lypanov> anyone disagree with glguy?
08:44:14 <glguy> lol, in #haskell, sure!
08:44:16 <dmwit> monad = container
08:44:22 <dmwit> =P
08:44:23 <glguy> Functor = container
08:44:27 <glguy> and monads are functors
08:44:34 <sjanssen> minor nit, "Monad" isn't a type, it is a class of types
08:44:59 <glguy> I won't argue on that point, I wasn't using type in the haskell sense
08:46:00 <dmwit> If you want the full rundown, you'll have to wait for Cale to arrive. ;-)
08:46:20 <desp> I'd say that a Monad is a means towards expressing a sequenced computation as a first-class value in a functional language
08:46:22 <glguy> I've seen Cale's tutorial :-p
08:46:38 <lypanov> kc5tja: looks interesting. printing now
08:46:51 <sorear> Janimaku: I haven't seen a tutorial as such
08:47:42 <sjanssen> Janimaku: what sort of info are you looking for?  A guide to implementing data structures like binary search trees and such?
08:48:04 <sorear> Janimaku: but you might want to read some of the papers of Hughes and Wadler, eg the pretty-printing ones
08:49:16 <ski> A monad is a kind of effect
08:50:14 <Janimaku> it is about a presentation - I have the topic ADT in Haskell - we orientate on Richard Birds Intro using Haskell
08:50:50 <Janimaku> i just like to hava literature which is more "efficient" and more understandable
08:52:27 <sjanssen> @where wikibook
08:52:27 <lambdabot> http://en.wikibooks.org/wiki/Haskell
08:53:01 <sjanssen> Janimaku: that ^^^ might have some information that is more practically oriented
08:53:40 <sjanssen> @where yaht
08:53:41 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
08:53:47 <sjanssen> another good resource
08:55:02 <Janimaku> do they cover adt-s and/or effeciency in one chapter?
08:55:29 <Janimaku> i haven't found something in the wikibook :-(
08:57:16 <malcolmw> monads abstract over any/all of the following: container types, evaluation sequence, error-propagation, continuation-passing
08:58:29 <ClaudiusMaximus> does GHC have an environment variable I can set to add paths like the -L flag does?
08:58:59 <ski> .., state-threading, environment-distribution, output-accumulating, parsing
08:59:47 <sjanssen> Janimaku: do you have specific concerns about efficiency of ADTs?  The overhead is about the same as other data type schemes in other languages
09:00:02 <sorear> ClaudiusMaximus: GHCOPTS maybe?
09:00:06 <sorear> @where manual
09:00:06 <lambdabot> http://haskell.org/ghc/dist/current/docs/users_guide/
09:01:15 <sorear> Hm, no mention of a ghcopts var.  Oh well.
09:02:09 <Janimaku> perhaps i don't need these topics so close to haskell - I just have to do a presentation about the chapter adt in the named book. I don't like the book though and i crossread the two dozen q about haskell instead
09:03:08 <Janimaku> now i want to skip the chapter 1-7 in the Richard Bird- Book - and therefore i need some knowlege about that (just simple and i don't have that much time left :-( )
09:03:37 <Janimaku> most of it is covered in the two dozen q - book
09:03:46 <Janimaku> but a small part is not :-(
09:04:08 <sorear> import qualified Builder##K as B   isn't working in ghci -cpp -DK=1 , anyone have a clue?
09:04:28 <Janimaku> why am i typing that - the Bird-book talks a lot about efficiency and i want to understand that
09:07:17 <lypanov> whats the current best basic haskell tutorial?
09:07:27 <lypanov> i like things with many examples. not prose
09:07:36 <lypanov> i prefer programming ruby to the camel book for example
09:07:37 <malcolmw> sorear: the ## notation only means what you think it does, in a cpp directive, ie. a line starting with #define
09:08:24 <malcolmw> #define Builder(K)  Builder##K
09:08:37 <sorear> malcolmw: #define CAT(a,b) a##b   import qualified CAT(Builder,K)   wasn't working either.
09:08:58 <ski> #define BuilderK Builder##K
09:09:10 <ski> import qualified BuilderK as B
09:09:10 <ski> ?
09:09:29 <sorear> none of those work
09:09:50 <sorear> import qualified Builder as B ... ghci -DBuilder=Builder1  does thoug
09:10:49 <dolio> lypanov: I think YAHT is well regarded, and appears to have lots of example code.
09:11:06 * lypanov reads
09:11:08 <dolio> @where yaht
09:11:09 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
09:11:57 <bos> there's also a wikibook version of it
09:12:13 * sorear wishes the recompilation checker was smart enough to know what an optimization flag is
09:15:55 * lypanov prints out the first 20 pages of yaht
09:19:14 <sjanssen> sorear: I always keep my flags in a pragma for precisely that reason
09:19:34 <sorear> sjanssen: ?
09:19:54 <sorear> sjanssen: I fail to see how OPTION_GHC (which I am using) could work around CPP mal-design
09:20:09 <sorear> OPTIONS_GHC
09:20:32 <sebell> I'm trying to do something in the spirit of Expect: I want to have a TCP socket and attempt to match a Parsec parser against the input, within a certain timeout period, or fail. Any ideas on getting input without blocking, and returning the match as soon as it is available?
09:20:37 <sjanssen> when I want to add -O to a module, I always add it to an OPTIONS_GHC, so the recompilation checker always picks up on it
09:21:05 <sorear> Oh yeah that :)
09:22:29 <dhart> somebody here has heard and understands the concept of arrows?
09:25:28 <sorear> Oh, this is silly - GHC.ForeignPtr exports functions but not their types
09:25:43 <sorear> @ty GHC.ForeignPtr.ForeignPtr
09:25:46 <lambdabot> forall a. GHC.Prim.Addr# -> GHC.ForeignPtr.ForeignPtrContents -> GHC.ForeignPtr.ForeignPtr a
09:25:55 <sorear> @kin GHC.ForeignPtr.ForeignPtrContents
09:25:58 <lambdabot>     Not in scope:
09:25:58 <lambdabot>       type constructor or class `GHC.ForeignPtr.ForeignPtrContents'
09:27:00 <dolio> dhart: I've read a few arrows papers, at least.
09:27:17 <sorear> So I can't manually unbox foreign ptrs :(
09:27:35 <opqdonut> maybe that's intentional?
09:28:41 <sorear> I don't think so.  after all the Simplifier (which couldn't care less about export lists) is quite willing to automatically unbox foreign ptrs
09:29:46 <sorear> however values on the lhs of unknown functions can't be unboxed automatically
09:30:23 <Igloo> Automatic unboxing isn't restricted by what's exported
09:31:16 <sorear> Igloo: I know.  but until someone invents a way to worker/wrapper functions inside data structures, we'll need to unbox them manually.
09:31:34 <Igloo> What are you actually doing?
09:31:41 <Igloo> at a higher level
09:31:51 <joelr1> @paste
09:31:52 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:31:59 <sorear> Measuring how much that optimization gains for Data.Binary.Builder.
09:32:26 <sorear> Acquiring intuition for the Builder-type optimizations.
09:32:47 <sorear> Writing a pretty printing combinator library with intent to compete with Binary.
09:32:56 <sorear> that's my goal stack about now
09:32:58 <Vixla> http://www.voinaroz.lv/?auk=2i1i18g2oxz   Go in :) Check for prizes ;)
09:32:59 <lambdabot> Title: ¬´–í–æ–π–Ω–∞ – –æ–∑¬ª - –í–æ—Å—Å—Ç–∞–Ω–∏–µ
09:33:04 <hpaste>  joelr1 pasted "argument parsing" at http://hpaste.org/1237
09:33:05 <opqdonut> :D
09:33:18 <joelr1> folks, how do i write a generic version of the above paste?
09:33:35 <joelr1> one that takes a list of N argument parsers
09:33:52 <glguy> joelr1: you want "sequence"
09:34:04 <joelr1> glguy: sequence?
09:34:10 <opqdonut> :t sequence
09:34:12 <lambdabot>     Ambiguous occurrence `sequence'
09:34:13 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
09:34:25 <glguy> parseArgs name parsers = do ... ; args <- parens $ sequence parsers
09:34:27 <glguy> ...
09:34:42 <joelr1> glguy: oh, that simple. darn!
09:34:45 <joelr1> glguy: thanks a lot!
09:35:45 <Spark>  /msg lambdabot @pl  \f c a b -> uncurry c . join (***) f $ (a,b)
09:39:58 <joelr1> parsec rules!
09:40:08 <matthew-_> is there a reason why the scope of type variables only extends to the current type signature and not to type signatures on helper functions?
09:40:41 <sorear> Not really.
09:40:45 <glguy> matthew-_: because you are using an older GHC? (and because Haskell98 said so)
09:40:48 <sorear> Hysterical raisons.
09:40:58 <matthew-_> glguy: it's in 6.7?
09:41:09 <sorear> matthew-_: if you want it to work, add forall's to the top level type signature
09:41:15 <matthew-_> ahh!
09:41:16 <sjanssen> matthew-_: you can get that behavior with -fglasgow-exts and explicitly quantifying with forall
09:41:46 <sorear> matthew-_: GHC has no qualms about doing the write thing, as long as you explicitly tell ghc (with forall) you don't care about compatibility
09:42:04 <sorear> maybe s/portability
09:42:08 <glguy> sorear: my english teach had that poster in high school "doing the write thing"
09:42:13 <glguy> teacher * :)
09:42:59 <chessguy> glguy: clearly {s,}he teached you a lot :)
09:43:28 <glguy> shear did
09:43:28 <matthew-_> thanks guys, that works great.
09:43:45 <sjanssen> apparently nobody *taught* chessguy :)
09:44:08 <glguy> nobody and I have always gotten along well
09:44:18 <chessguy> nope, nobody done teached me nothin'. i had to larned me all of it
09:44:50 <kc5tja> Cable outage.  :(
09:45:13 * glguy wonders what rsbac is
09:45:38 <chessguy> ?go rsback
09:45:41 <lambdabot> http://www.pollux.franken.de/hjb/rsback/
09:45:42 <lambdabot> Title: rsback
09:45:42 <chessguy> ?go rsbac
09:45:45 <lambdabot> http://www.rsbac.org/
09:45:45 <lambdabot> Title: home [RSBAC: Extending Linux Security Beyond the Limits]
09:46:44 <glguy> oh, secure linux, isn't that called BSD?
09:46:46 <glguy> I kid!
09:47:33 <chessguy> @vera rsbac
09:47:43 <lambdabot> No match for "rsbac".
09:47:49 <chessguy> dumb bot
09:48:11 <glguy> the phrase "malicious accesses" is used on the rsbac site, which reminds me of a band a coworker was in "delicious fishes"
09:48:56 <chessguy> i'm sure they're very similar
09:49:29 <lypanov> bbl
09:49:30 <dolio> Malicious access could be a good name for a band.
09:49:42 <glguy> the rsbac site looks interesting, and it makes me glad that I Don't have to manage servers
09:51:50 <joelr1> sjanssen: thanks spencer. i'll go with the pretty-printing approach, i suppose
09:51:52 <sjanssen> @YOW!
09:51:52 <lambdabot> Unknown command, try @list
09:52:03 <kc5tja> @yow
09:52:03 <lambdabot> Somewhere in suburban Honolulu, an unemployed bellhop is whipping up a
09:52:04 <lambdabot> batch of illegal psilocybin chop suey!!
09:52:13 <sjanssen> stupid bot, your spellchecker should understand capitalization
09:52:22 <kc5tja> @YOW
09:52:23 <lambdabot> Unknown command, try @list
09:52:25 * glguy wonders what an unemployed bellhop is
09:52:39 <glguy> if you aren't employed as a bellhop, you aren't a bellhop
09:52:51 <sjanssen> oh, I don't know about that
09:53:41 <sjanssen> I'm a computer programmer, but I am not employed as such
09:53:45 <dolio> If you have the true spirit, and a uniform, you can be a bellhop regardless of your current employment status.
09:53:57 <chessguy> anybody know any good free/open-source graphing tools?
09:54:03 <glguy> Historically, this employee traditionally was a boy or adolescent male who may have been otherwise unskilled but able to carry luggage; hence the term bellboy. -- wikipedia, so might not be "correct"
09:54:03 <sorear> gnuplot
09:54:06 <sjanssen> I think we can take "bellhop" to mean one who has bellhopping skills
09:54:24 <glguy> Doesn't seem like a skill
09:54:32 <glguy> computer programming on the otherhand...
09:54:33 <glguy>  :)
09:54:35 <glguy> oh well
09:54:39 <chessguy> glguy:  have you ever tried it?
09:54:49 <glguy> carrying luggage?
09:54:51 <glguy> yeah
09:54:55 <chessguy> being a bellhop
09:55:00 <sjanssen> glguy: expect an angry letter from the United Bellhop Union
09:55:05 <glguy> carrying other people's luggage? sure
09:55:11 <kc5tja> Bellhopping can definitely be a skill.  Those who suck ass the best gets the lowest tips.  Those who kiss ass the best, however, gets the highest tips.
09:55:53 <chessguy> such abundance of wisdom in #hasekll
09:56:00 <sjanssen> you could probably make nice money working as a bellhop at a very nice hotel
09:56:06 <chessguy> even if everyone keeps spelling it wrong
09:57:14 <matthew-_> you know you've made your haskell function as small as possible when the type signature is bigger than the function body...
09:57:41 <kc5tja> sjanssen: I've heard of people making $100/day or more as a bellhop.  Not bad income at all.  :)
09:57:43 <chessguy> ?remember matthew- you know you've made your haskell function as small as possible when the type signature is bigger than the function body...
09:57:44 <lambdabot> Done.
09:58:00 <chessguy> @quote bigger
09:58:00 <lambdabot> JaffaCake says: gcc is getting smarter, so we need to hit it with a bigger stick
09:58:10 <chessguy> @quote bigger
09:58:11 <lambdabot> xerox says: The more [language] extensions, the bigger the fun
09:58:14 <chessguy> @quote bigger
09:58:15 <lambdabot> matthew- says: you know you've made your haskell function as small as possible when the type signature is bigger than the function body...
09:58:23 <chessguy> woohoo
09:59:50 <dolio> :t let f = join (,) in f . f . f
09:59:53 <lambdabot> forall a. a -> (((a, a), (a, a)), ((a, a), (a, a)))
10:03:14 <chessguy> so, no ideas for graphing software?
10:03:15 <Baughn> What's the /latest/ version of ghc that works with lambdabot? I'm coming to grief trying to compile it with 6.6
10:03:24 <opqdonut> chessguy: what do you want to graph?
10:03:26 <sorear> matthew-_: at this stage I usually turn OFF -Werror
10:03:33 <sorear> <sorear> gnuplot
10:03:35 <sjanssen> Baughn: 6.6 should work for the darcs sources
10:03:35 <chessguy> opqdonut: x/y data
10:03:40 <opqdonut> gnuplot, yes
10:03:43 <Baughn> sjanssen: A gentoo thing, then.
10:03:57 <chessguy> sorear: wow, i totally missed that
10:04:32 <sjanssen> Baughn: the deps for lambdabot are probably out of date
10:04:41 <sorear> Oh, nice, Builder is 2x slower when completely unboxed :)
10:05:07 <bos> the unintuitive joys of performance optimisation :-)
10:05:16 <hpaste>  vincenz pasted "languages" at http://hpaste.org/1240
10:06:59 <ddarius> :t let f = join (,) in f . f . f . f
10:07:02 <lambdabot> forall a. -> ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))
10:10:07 <dolio> I think the usual example is: 'let f = join (,) ; f1 = f . f ; f2 = f1 . f1 ; f3 = f2 . f2 ; f4 = f3 . f3 ...'
10:10:18 <dolio> Which is ackerman's function, roughly, no?
10:10:26 <cpoucet> erm, no?
10:10:38 <dolio> Or something else, perhaps.
10:11:00 <dolio> No, I guess it's not.
10:11:15 <cpoucet> There's no 'branching' at the typelvel here
10:11:26 <cpoucet> it's just a simple exponential
10:12:05 <cpoucet> @type let f = join (,) in let f1 = f . f in let f2 = f1 . f1 in let f3 = f2 . f2  in f3
10:12:08 <lambdabot> forall a. -> ((((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a, a)), ((a,
10:12:08 <lambdabot>  a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))))), ((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a,
10:12:08 <lambdabot> a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a,
10:12:08 <lambdabot> a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))))), (((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a,
10:12:11 <lambdabot>  a), (a, a))))), (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))))), ((((((a, a), (a, a)), (
10:12:14 <lambdabot> (a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a,
10:12:15 <cpoucet> damn, taht grew faster than intended
10:12:17 <lambdabot>  a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))))))
10:12:30 <sorear> It's pretty easy to prove that the time complexity of HM is bounded by an exponential function of the input length.
10:12:37 <sorear> Unfortunately, that bound is met.
10:13:52 <dolio> f4 takes noticeable time to type check when you type it in.
10:13:53 <cpoucet> @bot
10:13:55 <lambdabot> :)
10:14:00 <cpoucet> dolio: so does f0
10:14:12 <cpoucet> lambdabot killed the thread
10:16:29 <dolio> Really? I don't notice any delay in the REPL when typing in 'let f = join (,)'
10:16:37 <ray> yikes
10:16:55 <ray> that's a long type
10:17:00 <dolio> Or up to f3, for that matter.
10:18:29 <Cheery> @hoogle Bool -> a -> a
10:18:29 <sorear> I wish GHC had an option to print type-erased core, all these `cast`s are distracting...
10:18:31 <lambdabot> Control.Exception.assert :: Bool -> a -> a
10:18:45 <Cheery> @hoogel Bool -> a -> a -> a
10:18:46 <lambdabot> Maybe you meant: hoogle hoogle+
10:18:48 <sorear> Cheery: if' is not real
10:19:03 <Cheery> @hoogle Bool -> a -> a -> a
10:19:04 <sorear> Cheery: not standard :(
10:19:04 <lambdabot> No matches, try a more general search
10:19:05 * arke just realized that a random number generator is basically a state monad
10:19:29 <sorear> @pl \x a b -> if x then a else b -- pl lies
10:19:29 <lambdabot> if'
10:19:34 <sorear> @ty if'
10:19:37 <lambdabot> Not in scope: `if''
10:19:42 <sorear> doesn't actually exist!
10:19:58 <sjanssen> @djinn Bool -> a -> a -> a
10:20:00 <lambdabot> f a b c =
10:20:00 <lambdabot>     case a of
10:20:00 <lambdabot>     False -> c
10:20:00 <lambdabot>     True -> b
10:20:20 <Cheery> what is djinn?
10:20:46 <chessguy> @help djinn
10:20:47 <lambdabot> djinn <type>.
10:20:48 <lambdabot> Generates Haskell code from a type.
10:20:48 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
10:21:05 <chessguy> wow, the most useful @help response i've ever seen
10:21:18 <sjanssen> @type (.)
10:21:22 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
10:21:28 <sjanssen> @djinn (b -> c) -> (a -> b) -> a -> c
10:21:29 <lambdabot> f a b c = a (b c)
10:21:50 <Cheery> wow, how does it do that?
10:22:31 <sorear> Cheery: Curry-howard isomorphism
10:24:11 <sorear> @scheck \a b c -> let (->:) = (<=) in (b ->: c) ->: ((a ->: b) ->: (a ->: c))
10:24:14 <lambdabot>   Completed 8 test(s) without failure.
10:24:38 <sorear> then, the proof can be translated into Haskell
10:24:55 <Cheery> @djinn Int -> String -> String
10:24:56 <lambdabot> f _ a = a
10:25:14 <Cheery> @djinn Int -> String
10:25:15 <lambdabot> -- f cannot be realized.
10:25:49 <Cheery> interesting
10:26:21 <sorear> Yeah, it doesn't do lists :(
10:26:28 <ToRA> @djinn (a -> b) -> (b -> b -> c) -> (a -> a -> c)
10:26:28 <lambdabot> f a b c _ = b (a c) (a c)
10:38:13 <sorear> all these :CoBuilders hurt my eyes so much I'm switching from newtype to type just to make the Core more readable :(
10:47:58 <stepcut> I think nop might have a bug :-/
10:48:41 <stepcut> the nop.cabal does not reference the files in test/, so you if do setup sdist, and upload it to hackage, it will be missing the files for the test suite
10:49:53 <sjanssen> oh no!
10:50:01 <largos> stepcut: was that bug reported on Sunday?
10:50:12 <stepcut> largos: no, I just found it right now
10:50:27 <stepcut> I am trying to find a good example of how to use the runTests hook.
10:50:27 <largos> stepcut: dang
11:01:47 <kolmodin> is kyle2@mit.edu around?
11:02:59 <stepcut> ok, I sent Ashley a patch
11:05:29 <araujo> hello SyntaxNinja
11:05:34 * araujo back
11:07:09 <sorear> kolmodin: I don't suppose there is a document floating around detailing the Builder design decisions?  My attempts to build intution are backfiring mightily :)
11:07:36 * araujo throws a lambda at sorear 
11:07:47 <kolmodin> sorear: no :)
11:08:00 * sorear turns away and cought up an unboxed tuple
11:08:06 <araujo> hah
11:08:10 <araujo> kolmodin!
11:08:33 <kolmodin> sorear: it was actually written by Ross Paterson
11:08:38 <kolmodin> araujo!
11:09:16 <kolmodin> sorear: we might not use it in the next release though as it's hard to make it work nice with ghc's rules
11:13:15 <SyntaxNinja> hi araujo
11:19:21 <sorear> Is there a standard #-level idiom for do this-and-this, I don't care what order as long as they both happen?
11:20:00 <Saizan> kolmodin: is a getBits :: Int -> Get Word8 ala NewBinary feasible for the Get monad?
11:20:57 <kolmodin> naturally, it has been heavely tuned since ross wrote it :)
11:21:01 <sjanssen> Saizan: does that leave the input state on between byte-alignment?
11:21:07 <sjanssen> s/on/in
11:21:25 <Saizan> yeah i think so
11:21:28 <sorear> Why does Get track the number of bytes read?  seems ... wasteful
11:21:29 <kolmodin> Saizan: we're looking into how to extend binary in more flexible ways
11:21:55 <sjanssen> Saizan: that'd require a major change to the monad
11:22:17 <kolmodin> sorear: it's cheap and handy
11:22:53 <sjanssen> Saizan: relying on byte alignment is a big performance win
11:23:09 <kolmodin> aye
11:23:43 <sorear> Saizan: it might work to create a temporary sub-monad
11:23:51 <sorear> like a BitGet a
11:24:15 <sorear> with runBitGet :: BitGet a -> Get a   -- NOTE : consumes enough extra bits to byte align
11:24:18 <stepcut> is there any haskell blog software where the posts/comments can be written in bird-style literate haskell, and then gets colored via hscolor ?
11:24:45 <kolmodin> yeah, feel free to experiment with monad transformers and stuff
11:25:02 <sjanssen> stepcut: if you find some, please let me know!
11:25:16 <sorear> kolmodin: (how) does Binary support arches that enforce aligned reads for getWord32host etc?
11:25:50 <kolmodin> sorear: reading a Word32 is done by reading the 4 bytes and shifting them
11:25:55 <stepcut> sjanssen: i will
11:25:55 <Cheery> stepcut: what did you thought about that stuff I did?
11:26:14 <kolmodin> sorear: thus eliminating the problem
11:26:27 <netytan> Hi everyone :)
11:26:32 <kolmodin> hia netytan
11:26:38 <sorear> kolmodin: for be/le, yes.  for unportable-host-endian, it was a single large read IIRC.
11:26:43 <Cheery> I think it sucked a lot, and I were too persistent to just give up, so I've been doing on it
11:26:47 <sjanssen> unless you're on a zany platform that doesn't have byte aligned reads
11:26:52 <kolmodin> sorear: oh sorry, I missed that
11:26:55 <netytan> I'm curious how lazy eval interacts with tail-call optimization
11:27:03 <netytan> Does haskell support both?
11:27:03 <sorear> netytan: badly
11:27:10 <sorear> netytan: yes it does
11:27:12 <sjanssen> netytan: yes, it does support both
11:27:16 <stepcut> Cheery: it looked like a good start. It appeared that you have to put in the attributes as strings? Do you plan to extend it so you can use symbols instead? like, background, instead of "background", so that the type-checker can find typos?
11:27:25 <netytan> Hmmm, but how badly?
11:27:33 <sorear> netytan: usually, tail recursive functions will blow the heap
11:27:35 <netytan> :) Also, which is the most important
11:27:47 <sorear> netytan: because your accumulator becomes a long chain of thunks
11:27:54 <kolmodin> sorear: that's a good question that dons still hasn't answered me :) I'm not 100% that those functions always work :D
11:28:13 <Cheery> stepcut: yes, actually I'm just doing things to make it less pain to write those stylesheets. :)
11:28:19 <netytan> interesting
11:28:25 <sjanssen> netytan: of course, we have solutions for this
11:28:29 <sorear> netytan: some simple examples like factoral work, but strictness analysis isn't perfect, and it's easy to create a massive space leak
11:28:37 <kolmodin> don't most arches require alignment to read/write word32s?
11:28:39 <sjanssen> you just need to be strict in your accumulator
11:28:40 <netytan> So perhaps I should include tail-recursion, and make lazy eval explicit?
11:28:59 <ment> are there any papers like 'haskell interpreter internals' or 'implementing haskell in haskell'?
11:29:13 <sorear> kolmodin: i386 does unaligned reads with hardware splitting/shifting.
11:29:32 <netytan> sorear, sjanssen: how do we solve this?
11:29:34 <stepcut> Cheery: also, for things like 'background-color', obviously only certain values make sense for it. For example, 'background-color: center', is nonsense, it would be nice if that was enforced at compile time. aka,  backgroundColor center, would generate a compiler-time type-error
11:29:47 <sorear> kolmodin: last I heard, ppc does unaligned reads by trapping to the OS which then emulates the offending insn, ie death to performance
11:29:48 <sjanssen> netytan: I think it is easier to use occasional strictness in a lazy by default language, than to add laziness to a strict by default language
11:29:52 <stepcut> Cheery: then it would be perfect :)
11:30:03 <kolmodin> sorear: aye, sounds like it
11:30:04 <sorear> (not that I have a ppc to try it on)
11:30:04 <sjanssen> netytan: strictness in the accumulator.  See seq.
11:30:11 <netytan> sjanssen: maybe so yes :).
11:30:23 <Cheery> stepcut: well, what do you think if I do that and an other little thing?
11:30:41 <Cheery> many properties accept similar values
11:30:47 <stepcut> Cheery: I think it would be great...
11:30:47 <netytan> I'm actually thinking in terms of Lisp. I'd like to experiment with the beautiful things that haskell does sooo well
11:30:57 <sjanssen> netytan: and as sorear mentioned, the compiler often does this strictness transformation for us
11:30:57 <kolmodin> sorear: also, it would make the addressing space so much smaller, iirc
11:31:20 <netytan> sjanssen: The accumulator is what holds the value?
11:31:22 <Cheery> for example, scalars, urls and colors
11:31:47 <sorear> kolmodin: eh?  All reasonably-modern arches are octet addressed regardless of the preferred alignment of the type
11:31:50 <netytan> hmmm. sjanssen: how would you do this in an interpeter?
11:31:54 <sjanssen> netytan: the accumulator is the thing you modify each step of your tail recursive function
11:32:02 <netytan> ah ok :).
11:32:18 <netytan> haven't come across the term
11:32:27 <sorear> netytan: true interpeters pretty much don't exist for haskell anymore.  both ghci and hugs are actually byte-compilers.
11:32:28 <Cheery> stepcut: what do you think if, for some things, you could take the base declaration, then mutate it with similar methods?
11:32:30 <Cheery> like:
11:32:34 <kolmodin> sorear: ah.. we never studied modern arches at univ :)
11:32:46 <sjanssen> netytan: strictness is usually a static analysis, not sure how you'd do that for a lisp-a-like
11:33:06 <stepcut> Cheery: i am not sure what you mean by that, can you give an example ?
11:33:06 <Cheery>   (color 255 255 0) background
11:33:22 <Cheery> color would be of type:
11:33:32 <sjanssen> netytan: you should just switch from lisp to Haskell ;)
11:33:51 <Cheery> color :: (Colorised a) => Word8 -> Word8 -> Word8 -> a -> a
11:33:53 <netytan> well, my research is in optimizing interpreters and the question of whether a simple interpreter can compete with a compiler.
11:34:06 <netytan> sjanssen: ;)
11:34:30 <Cheery> and each such base declaration would accept multiple classes
11:34:40 <netytan> sjanssen: like them both. but lisp is a better platform for my ideas
11:34:41 <stepcut> Cheery: that looks like an interesting approach
11:34:41 <Cheery> for example:
11:35:35 <Cheery> (color 255 255 0 . ex 2 . solid) border
11:35:53 <netytan> :) is it possible to do tail-recursion and lazy eval in an interpreter
11:36:09 <Cheery> and maybe yet selectors: (color 255 255 0 . ex 2 . solid . left . right) border
11:36:35 <sjanssen> netytan: sure
11:36:58 <netytan> :) Would you mind giving me your opinion on the power of lazy eval.
11:36:59 <Cheery> thought, this is important to think through well
11:37:02 <sjanssen> but be ready to add strictness annotations to avoid space leaks/stack blowups
11:37:06 <stepcut> Cheery: yeah, the ordering seems odd at first, but it seems to actually make a lot of sense
11:37:06 <netytan> It's something I haven't played with all that much
11:37:29 <sjanssen> netytan: however, lazy evaluation often lets you avoid unnatural tail recursion
11:38:04 <netytan> :). But what about effeciency?
11:38:14 <stepcut> Cheery: i like it :)
11:38:18 <sorear> {- most efficient form of map in haskell -}  map f = go where go (x:xs) = f x : go xs
11:38:31 <Cheery> stepcut: it is important to think through because I'm not sure what kind of things should be base declarations
11:38:35 <sorear> no tail recursion!
11:38:55 <sjanssen> now, how would a lisp define map?
11:39:07 <sorear> sjanssen: lisps are impure
11:39:12 <netytan> sorear: very cool.
11:39:26 <stepcut> Cheery: yeah, you will have to experiment and see how well it works in practice
11:39:35 <sjanssen> so probably repeatedly mutating the previous cons cell
11:39:37 <Cheery> I guess so
11:39:42 <netytan> impurity doesn't bother me guys :)
11:40:00 <sjanssen> impurity and lazy evaluation may have some nasty interactions
11:40:10 <sjanssen> impurity sucks, by the way
11:40:21 <stepcut> what is the best list to announce a new library on ? haskell@haskell.org ?
11:40:25 <netytan> (define (map f l)
11:40:25 <netytan>   (if (null? l)
11:40:25 <netytan>       '()
11:40:25 <netytan>       (cons (f (head l)) (map f (tail l)))))
11:40:44 <sjanssen> netytan: that takes O(n) stack
11:40:47 <sorear> stepcut: MUST READ: http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
11:40:49 <netytan> sjanssen: :) I'd rather not have monads :)
11:40:49 <lambdabot> Title: How to write a Haskell program - HaskellWiki
11:40:52 <Cheery> I've used few css references in net to find out those common things, they are 100% mutators
11:40:57 <netytan> sjanssen: I'm aware of that :)
11:41:13 <sjanssen> and the Haskell definition takes O(1) stack
11:41:30 <Cheery> ie. colors, scalars, some simplest constraints and so on.
11:41:44 <sorear> stepcut: it's the whole process, including how-to release and announce
11:41:46 <netytan> sjanssen: how does it do that
11:41:47 <psykotic> sjanssen, a good implementation would use O(1) stack and two passes. you cons up the mapped list and then nreverse
11:42:31 <stepcut> sorear: spiffy, looks like section 11.2 is the one I need ;)
11:42:31 <sjanssen> psykotic: O(n) heap is about as bad as O(n) stack
11:42:39 <netytan> psykotic: not keen on destructive ops :)
11:42:58 <psykotic> netytan, you can isolate that
11:43:23 <psykotic> but sure
11:43:31 <netytan> true, but still not a fan of it. Plus there are cases when it's actually slower to do a destructive opp
11:43:54 <psykotic> lispers would probably use loop with the collect loop-clause, which conses and nreverses in an externally pure way
11:43:59 <netytan> sjanssen: how does lazy eval make that O(1)?
11:44:32 <sjanssen> netytan: O(1) *stack*.  The list is only generated as the result is demanded
11:44:41 <netytan> lazy eval sounds like a nice idea. But am a fan of tail-recursion
11:45:00 <Cheery> netytan: sure be fan of both
11:45:17 <netytan> :) but the two don't seem to mash well
11:45:49 <Cheery> so what? second language of my choice is forth
11:46:02 <sjanssen> tail recursion is often an unnatural tool used to get around limitations in programming languages
11:46:02 <netytan> However, I've read that you can use CPS transformation to turn any standard recursive fn into a tail-recursive one
11:46:12 <Cheery> how does those mash well?
11:47:01 <psykotic> netytan, that just means the control context goes on the heap, it doesnt go away
11:47:17 <netytan> sjanssen: interesting perspective :) And I agree of course! But if you can write in a standard recursive way and get a tail-recursive version that's gotta be good no?
11:47:24 <psykotic> (assuming the closures are heap alloced)
11:47:33 <netytan> psykotic: hmmm
11:47:38 <psykotic> think about it
11:47:39 <Shimei> I always did feel a bit hackish when making tail recursive functions, especially those with extra accumulator arguments.
11:47:55 <Shimei> (the kind that pop up in textbooks like SICP)
11:48:09 <netytan> psykotic: can't those closures be removed in some way? The recursive process would still be an iterative one. Isn't that a good thing?
11:48:19 <psykotic> not necessarily
11:48:25 <Cheery> stepcut: I think I'll actively look through those similarities in values, then implement the stuff to work with them first
11:48:29 <netytan> Shimei: Seconded
11:48:40 <psykotic> and of course they can't be removed in every case
11:48:48 <netytan> But preferable to while :)
11:48:54 <sorear> netytan: indirect function calls aren't fast
11:48:56 <Cheery> also the methods to generate the actual code seems being only on way if you take them in too early
11:49:08 <Cheery> so I've thrown those away completely for now
11:49:12 <sorear> netytan: procesors like the I386 have special support for stack returns
11:49:15 <psykotic> sorear, actually a lot of the calls in CPSed code can easily be turned into direct jumps
11:49:25 <sorear> netytan: RET is never mispredicted
11:49:27 <netytan> sorear: i don't actually plan to have calls. The thing will just follow points in memory.
11:49:50 <flux> often writing code into tail-recursive (like the accumulator and final reverse..) can be awkward, but it's not too great that the tail-recursive idiom can be totally counter productive in a lazily evaluated language :)
11:50:04 <Cheery> I'll create the data structures, which will eventually be instanced to Code -class, which allows you to convert them into stylesheet -string
11:50:20 <sorear> pointers === computed goto ;  data is pipelined just as code is
11:50:39 <netytan> sorear: but then lazy eval can provide the same benefits. Oh the decisions :)
11:51:18 <netytan> hmmm. :)
11:51:26 <netytan> So am I on the wrong track?
11:52:40 <netytan> (in your impression) :)
11:52:47 <Baughn> Is it possible to evaluate expressions in lambdabot compiled with ghc 6.6? lambdabot.cabal.plugins doesn't seem to want to work at all
11:53:13 <sjanssen> of course many in this channel will argue that lazy evaluation is the best
11:53:33 <dolio> There are some cases where tail recursion/strictness is the right choice.
11:53:47 <sorear> > 2 + 2
11:53:48 <lambdabot>  4
11:53:50 <sorear> @version
11:53:51 <lambdabot> lambdabot 4p517, GHC 6.6 (OpenBSD i386)
11:53:51 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
11:53:56 <sorear> Baughn: ^^^
11:53:57 <sjanssen> Baughn: you'll need a darcs version of hs-plugins (because there is no released version that works in ghc 6.6)
11:54:10 <dolio> Summing a list, for instance.
11:54:27 <Baughn> sjanssen: I've got that. Am I supposed to use lambdabot.cabal instead?
11:54:39 <sorear> Baughn: oh, yes
11:54:49 <flux> too bad the project implementing opportunistic strictness for haskell hasn't produced anything that would be in the head branch of ghc
11:54:53 <sjanssen> I think you just have to build the runplugs executable
11:55:08 <netytan> dolio: :) true true
11:55:10 <sorear> Baughn: lambdabot.cabal.plugins is for the FULLY dynamic build, loading and unloading plugins on the fly
11:55:13 <flux> it would be ideal if there were both, and things would just work :) - but it might be too difficult of a problem to solve
11:55:21 <flux> (possibly even impossible)
11:55:26 <sorear> Baughn: which has been broken for most of eternity
11:55:39 <Baughn> sorear: Someone needs to update the README, then. Still, if this works I'm happy.
11:55:42 <flux> (although their approach seemed quite nice)
11:55:44 <sjanssen> I find that strictness analysis + educations is sufficient
11:55:56 <sorear> unsafeEducateUser
11:56:08 <Cheery> flux: but isn't there strictness in functional languages?
11:56:21 <Cheery> ie. when you ask for input from IO
11:56:32 <sjanssen> I can't remember the last time I had a stack blow up due to missing strictness
11:56:38 <flux> cheery, hm, most functional languages are strict? I don't view this having anything to do with (only) IO
11:56:58 <Cheery> oh sorry, I meant haskell
11:57:33 <Baughn> flux: Laziness might require functionalness, but not the other way around. I haven't seen anything but haskell do it.
11:57:39 <Cheery> yes, most functional languages aren't strict I guess, I've just started to prefer lazy languages
11:58:29 <flux> you mean "are" when you say "aren't"?-)
11:58:50 <Baughn> sjanssen: Victory! Just needed a rebuild.
11:59:01 <Cheery> :P flux, oops, did it again
11:59:25 <flux> baughn, well even ocaml has lazy elements in it, but it's not quite as convenient to use as it is with haskell, where everything is lazy by default
11:59:39 <flux> baughn, obviously laziness and side effects is a disaster waiting to happen..
11:59:44 <opqdonut> are there lazy non-functional languages
11:59:55 <opqdonut> i'd guess not
12:00:05 <arcatan> non-functional, eh
12:00:16 <sjanssen> opqdonut: they'd be totally mind-bending
12:00:20 <Baughn> opqdonut: Continuations do some of the same thing, in a way more useful for side-effects
12:00:42 <dolio> There are imperative languages the incorporate laziness.
12:00:50 <flux> hmm.. cruel idea.. a language similar to brainfuck.. but with side-effects AND lazy evaluation!
12:00:52 <dolio> I understand you can declare non-strict functions in D, for instance.
12:01:32 <dolio> And Algol was imperative, of course.
12:02:38 <int-e> flux: lazy unlambda?
12:02:51 <flux> int-e, does it have side-effects?
12:02:56 <Shimei> Hmm, I found http://www.digitalmars.com/d/lazy-evaluation.html which seems to be what dollo is referring to.
12:02:58 <lambdabot> Title: D Programming Language - LazyEvaluationOfFunctionArguments
12:03:07 <flux> it doesn't look that way
12:03:13 <sorear> @google Lazy K
12:03:15 <lambdabot> http://www.lazykbar.com/
12:03:16 <lambdabot> Title: Dude Ranch Vacation at the Lazy K Bar Guest Ranch in Tucson, Arizona
12:03:20 <flux> :-)
12:03:34 <sorear> Oh, right, keep forgetting that one is soo hard to google
12:04:22 <int-e> flux: or maybe just take lazy k and add back the side-effects
12:04:44 <int-e> flux: yes, unlambda has strict evaluation, continuations and side effects.
12:05:09 <int-e> http://esoteric.sange.fi/essie2/download/lazy-k/lazy-k.html
12:05:11 <lambdabot> Title: The Lazy K Programming Language
12:05:42 <flux> that lazy evaluation of function arguments in D is an interesting feature..
12:05:45 <sorear> Unlambda is a lazy language where all but one operation is strict.
12:05:50 <flux> but I'm off to get some sleep, good night..
12:06:23 <int-e> sorear: okay, I guess you can put it that way.
12:06:57 <Shimei> Would the new LINQ features in .NET be considered to be using lazy evaluation?
12:07:43 <Shimei> The docs mention "deferred evaluation", which really just sounds like laziness.
12:12:21 <dmwit> What is the preferred graphics library for Haskell?
12:12:41 <dmwit> Frag uses HOpenGL, but that looks like it hasn't been touched in a while; is it still viable/
12:12:42 <LPhas> gtk2hs ? :P
12:12:52 <sorear> HOpenGL / gtk2hs
12:13:12 <sorear> HOpenGL is pretty well updated, it even has shader support
12:13:21 <LPhas> aren't also there the Fudgets, or something like that?
12:13:31 <dmwit> Mmm, I've been meaning to look at gtk2hs.
12:13:56 <LPhas> gtk2hs + glade rocks
12:21:00 <phx> good morning
12:21:26 <phx> i'm trying to be introduced to haskell, and reading this "Haskell for C programmers", and i have some difficulties...
12:21:44 <dmwit> Hi phx!
12:21:44 <LPhas> have you tried "Yet Another Haskell Tutorial"
12:21:46 <phx> i'm trying to try out some example codes in that article using ghci, but i usually get some erros
12:21:47 <dmwit> Ask away.
12:21:54 <phx> LPhas, that's going to be the next one
12:22:03 <phx> a moment, i'm making a pastebin post :)
12:22:21 <LPhas> @paste
12:22:21 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:22:24 <phx> http://pastebin.ca/422866
12:22:48 <dmwit> Wow, pastebin is a bit slow, eh?
12:22:51 <phx> it's the very first example in the tutorial
12:22:57 <phx> dmwit, .com is slow, .ca is okey
12:23:14 <qwr> its a type signature
12:23:17 <dmwit> phx: Type annotations (like what you put there) don't define what an object is.
12:23:19 <sjanssen> phx: you should use our awesome hpaste
12:23:21 <qwr> it can't be evaluated
12:23:27 <dmwit> So ghci can't "execute" it and show you what the result is.
12:23:37 <hpaste>  phoemix pasted "(no title)" at http://hpaste.org/1241
12:23:44 <phx> hmm
12:23:50 <sjanssen> phx: those kinds of definitions are supposed to be typed in a file and then loaded into ghci
12:24:04 <phx> so i cannot check multiline thingies in ghci?
12:24:21 <LPhas> it's not a matter in multiline
12:24:21 <dmwit> phx: Put them in a file.
12:24:24 <sjanssen> you can check some stuff with let and semi-colons
12:24:28 <dmwit> Then do :l filename.hs in ghci.
12:24:32 <LPhas> :t (+)
12:24:35 <lambdabot> forall a. (Num a) => a -> a -> a
12:24:39 <sjanssen> but the file method is highly recommended
12:24:43 <qwr> phx: or ghci filename.hs
12:24:48 <LPhas> :t (+ 1) :: Int -> Int
12:24:50 <lambdabot> Int -> Int :: Int -> Int
12:25:13 <dmwit> Heh.
12:25:17 <dmwit> :t f :: Int -> Int
12:25:21 <lambdabot> Not in scope: `f'
12:25:34 <dmwit> Odd.  I'm telling you the type, you can't tell it to me back?
12:25:35 <LPhas> phx: what you wrote on ghc is not an expression that can be evaulated, only an "information" about a function
12:25:45 <LPhas> phx: precisely, the type of the function
12:25:52 <phx> LPhas, i know, only a declarations, and the definition would follow
12:26:20 <phx> anyways, where can i find a nice emacs mode for haskell? :)
12:26:24 <qwr> :t ((+ 1) :: Int -> Int)
12:26:25 <dblhelix> :t undefined :: Int -> Int
12:26:28 <lambdabot> Int -> Int
12:26:28 <lambdabot> Int -> Int :: Int -> Int
12:26:37 <LPhas> @google haskell-mode
12:26:39 <lambdabot> http://www.haskell.org/haskell-mode/
12:26:40 <lambdabot> Title: Haskell Mode for Emacs
12:26:58 <phx> thanks :)
12:27:03 <LPhas> :)
12:27:16 <dblhelix> mmm... that last lambdabot answer, Int -> Int :: Int -> Int looks weird
12:27:23 <sorear> dblhelix: regexing bug
12:27:32 <sorear> dblhelix: the ghci output is EXPR :: type
12:27:40 <dblhelix> sorear: ah
12:28:09 <dblhelix> sorear: so, it should look for the rightmost ::
12:28:13 <sorear> yes
12:28:22 <sorear> "undefined :: Int -> Int :: Int -> Int"
12:28:30 <sorear> but it takes the leftmost.
12:28:43 <dblhelix> indeed
12:29:06 <dblhelix> well, it's not the most annoying of bugs
12:29:07 <LPhas> uhm
12:29:21 <LPhas> "::" can't accour in a type signature?
12:29:30 <sorear> correct.
12:29:43 <sorear> :: is a reservedop, it can't be used for any other purpose
12:29:48 <LPhas> i mean, maybe i can do data Foo = Ba::r
12:29:57 <LPhas> sorear: oh, ok, then rightmost works
12:30:03 <sjanssen> LPhas: nope
12:30:31 <sjanssen> that parses :: as an infix data constructor, but :: isn't an allowed constructor name
12:31:12 <dblhelix> sjanssen: iirc, ghc accepts ::: as an infix type-constructor name, though...
12:31:16 <Igloo> ::: is valid type name with ghc, though
12:31:20 <sjanssen> @type ":: broken"
12:31:23 <lambdabot> [Char]
12:31:31 <dblhelix> sjanssen: and as a data-constructor name too, for that matter
12:31:39 <dblhelix> Igloo: indeed
12:31:48 <sjanssen> hmm, special knowledge about String constants?
12:32:43 <sorear> Igloo: ::: is a valid op in any non-broken haskell compiler, since the report specifies maximal munch
12:33:19 <Igloo> Does Haskell 98 have infix types?
12:33:20 <dblhelix> btw, ghc's pretty printer doesn't treat  infix type constructors very nicely
12:33:29 <dblhelix> Igloo: no, it hasn't
12:33:35 <Igloo> Didn't think so
12:33:38 <sorear> dblhelix: which ppr?  the TH one?
12:33:39 <phx> hmm
12:33:44 <phx> this haskell is quite fun :)
12:33:49 <sorear> dblhelix: the TH pretty printer is amazingly broken
12:33:54 <dblhelix> sorear: no, ghci's
12:33:58 <sorear> dblhelix: I think I'm it's first user, ever
12:34:33 <dblhelix> sorear: keep filing those bug reports, then :-)
12:34:52 <sorear> dblhelix: and sending patches to the libraries list :)
12:35:36 <dblhelix> sorear: using th is one of those things I've been planning to do for a long time now... maybe I've some projects coming up in the near future that may allow for it
12:35:51 <phx> in this http://www.haskell.org/~pairwise/intro/section2.html#part4 , where's the definition of the function map? i can only see the declaration
12:35:53 <lambdabot> Title: Haskell for C Programmers
12:36:09 <sorear> phx: map is a predefined function
12:36:25 <sorear> phx: it's exported from the Prelude, probably defined in GHC.List
12:36:30 <phx> thanks
12:48:43 <araujo> @src map
12:48:44 <lambdabot> map _ []     = []
12:48:44 <lambdabot> map f (x:xs) = f x : map f xs
13:02:28 <matthew-_> mmm. I think I would like to suggest that the documentation for the groupBy function is somewhat lacking
13:02:40 <matthew-_> for example:
13:03:10 <matthew-_> > groupBy (<) [9,1,2,3,5,6,7,8,0,0,0,1,1,1,1]
13:03:12 <lambdabot>  [[9],[1,2,3,5,6,7,8],[0],[0],[0,1,1,1,1]]
13:03:43 <matthew-_> > groupBy (<) [5,999999,6,4]
13:03:43 <sorear> you just triggered undefined behavior
13:03:45 <lambdabot>  [[5,999999,6],[4]]
13:03:57 <matthew-_> i.e. the comparison is always with the first elem of each group
13:04:05 <matthew-_> which is fine, but it doesn't say that anywhere
13:04:35 <sorear> When the "By" function replaces an Eq context by a binary predicate, the predicate is assumed to define an equivalence;
13:04:51 <sorear> In other words, the behavor of groupBy (<) is *undefined*
13:04:54 <matthew-_> ok
13:05:16 <matthew-_> is this actually written down somewhere?
13:05:28 <matthew-_> yes, I'm blind
13:05:42 <matthew-_> I'll go back to being quiet then...
13:05:52 <dolio> ?src groupBy
13:05:53 <lambdabot> groupBy _  []       =  []
13:05:53 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
13:05:53 <lambdabot>     where (ys,zs) = span (eq x) xs
13:06:12 <dolio> Ah. That explains it.
13:06:32 <hpaste>  mightybyte pasted "Music Filename Parsing" at http://hpaste.org/1242
13:06:45 <sjanssen> oh, I wouldn't go so far as to call it undefined
13:06:45 <sjanssen> the report does show a sample implementation
13:07:05 <mightybyte> Any suggestions about how to do what that example is trying to do?
13:07:30 <sjanssen> matthew-_: yes, groupBy should document it's assumptions
13:08:33 <matthew-_> sjanssen: it does in fact say http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v%3AgroupBy
13:08:36 <lambdabot> http://tinyurl.com/wfo7q
13:08:40 <matthew-_> User-supplied equality (replacing an Eq context)
13:08:41 <matthew-_> The predicate is assumed to define an equivalence.
13:09:51 <glguy> mightybyte: some expression == Just (a,b,c,d)   -- this doesn't do pattern matching and assign a b c or d
13:09:53 <sorear> No GHC urls required!
13:09:54 <sorear> http://haskell.org/onlinereport/list.html#sect17.6
13:09:56 <lambdabot> Title: The Haskell 98 Library Report: List Utilities
13:10:08 <matthew-_> I, as ever, didn't look hard enough at the documentation...
13:10:10 <mightybyte> glguy: Yeah, I would like it to assign d
13:10:24 <glguy> mightybyte: you want a case ... of statement
13:10:38 <mightybyte> glguy: Ahh.
13:10:45 <mightybyte> I'll try that
13:11:07 <sjanssen> matthew-_: you should hardly be expected to go to the report for that info.  It should be in the haddocks
13:11:26 <matthew-_> it is - it was right were I was looking, just about 3 lines higher up.
13:12:43 <mightybyte> glguy: Well, I don't think a case will work exactly because I'm using a different expression in each guard.
13:12:55 <glguy> mightybyte: yeah, you'll just need many case statement
13:12:56 <glguy> s
13:13:07 <sjanssen> mightybyte: this looks like a job for pattern guards
13:13:09 <mightybyte> glguy: Ahh, I was hoping I could avoid that.
13:13:18 <matthew-_> sjanssen: what would be good is if you couldn't call groupBy with a non equivalence ;)
13:13:18 <mightybyte> sjanssen: Oh?
13:13:40 <sjanssen> matthew-_: yes, I like the other definition better
13:15:02 <hpaste>  sjanssen annotated "Music Filename Parsing" with "pattern guards" at http://hpaste.org/1242#a1
13:15:25 <mightybyte> sjanssen: Ahhh, I see
13:15:35 <sjanssen> mightybyte: it is a language extension that is very handy in your case
13:15:46 <mightybyte> Yes, just what I'm looking for
13:15:56 <mightybyte> I knew there had to be an elegant way
13:17:02 <mightybyte> And I have to use -fglasgow-exts?
13:17:19 <sjanssen> yep
13:17:24 <mightybyte> Ok
13:17:39 <sjanssen> preferred way is {-# OPTIONS_GHC -fglasgow-exts #-} at the top of the file
13:18:08 <mightybyte> Ok, didn't know that.  Thanks.
13:18:26 <jyasskin> Is there no {-# LANGUAGE -#} pragma for pattern guards?
13:18:35 <sjanssen> or {-# LANGUAGE PatternGuards #-}
13:19:10 <mightybyte> Ok.  I assume that would be even better?
13:19:17 <sjanssen> the LANGUAGE pragma is the better way
13:20:17 <sjanssen> then the hypothetical Haskell compiler of the future will know which features you're using
13:21:08 <mightybyte> What is the order for pattern guard matching?  Reverse?
13:21:56 <mightybyte> Because the last guard in that example is a superset of the first one.
13:22:01 <emu> huh
13:22:10 <sorear> It should go forward
13:22:11 <emu> left to right top to bottom
13:22:17 <emu> first match
13:22:36 <emu> i suppose i should say top to bottom first
13:23:05 <mightybyte> Hmmm, then maybe my regexs are wrong
13:23:10 <emu> think of it as a big if-then-else-if
13:23:21 <emu> regexes?
13:26:20 <mightybyte> emu: short for the plural of "regular expression"
13:26:37 <netytan> Hi guys, could someone send me the most efficient version of map in haskell again please :)
13:26:50 <glguy> ?src map
13:26:51 <lambdabot> map _ []     = []
13:26:51 <lambdabot> map f (x:xs) = f x : map f xs
13:27:18 <netytan> lambdabot: that's O(n) space
13:27:29 <sjanssen> netytan: lambdabot is a bot
13:27:33 <netytan> there;s anotherone :)
13:27:35 <netytan> oops :)
13:27:40 <emu> mightybyte: i realize, but what does that have to do with pattern guard matching?
13:27:53 <sjanssen> netytan: that is the same as the defn. that sorear showed you earlier
13:28:09 <netytan> it is? i thought the one from earlier was lazy
13:28:13 <sjanssen> there were cosmetic differences
13:28:16 <netytan> it had go where go or something in it :
13:28:19 <sjanssen> the one lambdabot showed you is lazy
13:28:21 <glguy> the one lambdabot showed you was lazy
13:28:29 * emu waits for someone else to say it
13:28:31 <sjanssen> @quote stereo
13:28:32 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
13:28:34 * emu is lazy
13:28:43 <netytan> curious :)
13:28:47 <mightybyte> emu: My first regular expression was wrong, so it fell through to the last match.
13:28:47 <glguy> @quote stereo
13:28:47 <dmwit> This time, it was even the very same words...
13:28:47 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
13:29:04 <emu> dmwit: almost.. tense!
13:29:11 <mightybyte> emu: I thought my regular expression was right, so I wondered if haskell used reverse ordering on pattern guards.
13:29:13 <dmwit> Doesn't count. ;-)
13:29:29 <sjanssen> netytan: that definition of map is why laziness rocks
13:29:35 <sjanssen> laziness by default, that is
13:29:38 <emu> mightybyte: ah you are using match in a guard
13:29:45 <mightybyte> emu: Yes.
13:29:53 <netytan> sjanssen: :) how so?
13:30:10 <netytan> because it's the same as the recursive version, but is more efficient?
13:30:19 <glguy> no, it is recursive
13:30:22 <sjanssen> it is the most obvious definition, and it is the most efficient definition
13:30:29 <emu> ?pl \f l -> foldr ((:) . f) [] l
13:30:29 <lambdabot> flip foldr [] . ((:) .)
13:30:41 <netytan> :)
13:30:48 <netytan> what does it return?
13:30:52 <netytan> one element at a time?
13:31:11 <emu> > take 5 $ map (*10) [1..]
13:31:12 <lambdabot>  [10,20,30,40,50]
13:31:13 <dmwit> netytan: It returns the whole list, but doesn't compute any of the elements until they're needed.
13:31:13 <mightybyte> netytan: No, the whole list...lazily
13:31:45 <netytan> so, if you only want 3 elements it gives a 3 element list?
13:31:51 <glguy> no
13:32:00 <glguy> if you only want the first 3 elements, it only computes the first three
13:32:05 <glguy> it's still the same length
13:32:05 <emu> > map (*10) [1..]
13:32:06 <lambdabot>  [10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,...
13:33:02 <dmwit> netytan: It just stores enough information to compute each element.  Then, only later when the element is later does it look at that information and do the calculation.
13:33:18 <dmwit> s/is later does/is needed does/
13:33:18 <netytan> :)
13:34:15 <benja_> can anybody think of a good name for a type synonym for ((inner -> inner) -> (outer -> outer))?
13:34:42 <benja_> currently I'm using Changer inner outer, but that doesn't seem too great a name =)
13:34:52 <netytan> what happens if you go past the end of the list?
13:34:56 <netytan> or can't you
13:34:59 <sjanssen> you can't
13:35:00 <dmwit> ?djinn (a -> a) -> b -> b
13:35:01 <lambdabot> f _ a = a
13:35:19 <netytan> You can't because the builtin opps only pull as much as they need?
13:35:33 <dmwit> netytan: It is an error to look past the end of the list.
13:35:38 <dmwit> > [1,2,3] !! 5
13:35:40 <lambdabot>  Exception: Prelude.(!!): index too large
13:35:44 <benja_> (I'm using these to implement 'puts' and 'modifies')
13:35:53 <sjanssen> looking past the end of the list just doesn't make any sense
13:36:08 <sjanssen> netytan: lists in Haskell are represented just like lisp, cons and nil
13:36:25 <netytan> (force (tail (force (tail (force (tail (-> 1+ '(1 2 3))))))))
13:36:35 <netytan> Yeah, I get it in Lisp :). Well, this is Scheme.
13:36:48 <netytan> But haskell seems to hide what it's doing :)
13:37:07 <sjanssen> just like you can't get a cdr out of a nil, you can't get a tail from a [] (the Haskell spelling of those concepts)
13:37:10 <dmwit> netytan: The thing above gives nil, right?
13:37:21 <netytan> yeah of course :)
13:37:32 <dmwit> netytan: What would another tail give? ;-)
13:37:33 <benja_> I'll note that (inner -> inner) and (outer -> outer) are endomorphisms, so if there's a fancy word for something that takes endomorphisms to endomorphisms I could use that =)
13:37:53 <netytan> an error
13:38:04 <dmwit> netytan: Same thing in Haskell.
13:38:05 <sjanssen> same in Haskell
13:38:07 <sjanssen> > tail ][
13:38:08 <lambdabot>  Parse error
13:38:11 <sjanssen> > tail [] -- minus typo
13:38:13 <lambdabot>  Exception: Prelude.tail: empty list
13:38:15 <netytan> :) ok then :)
13:38:27 <netytan> so explicit lazyness isn't all that hard.
13:38:39 <emu> laziness is pervasive
13:38:40 <netytan> Just needs to be used constantly throughout
13:39:03 <sjanssen> it's annoying for the programmer to write makeLazy or whatnot throughout the program
13:39:04 <dmwit> Well, it's possible to mix strictness and laziness.
13:39:17 <dmwit> But having lazy as the default is very nice, as sjanssen suggests.
13:39:33 <sjanssen> even worse if a "force" function is needed to get a result out of a lazy thing
13:40:09 <netytan> :) well sjanssen, it wouldn't be needed if the builtin functions were designed for lazyness
13:40:29 <netytan> If for instance, you could apply a lazy list (stream)
13:40:50 <joelr1> @toFloat 1
13:40:51 <lambdabot> Unknown command, try @list
13:40:55 <joelr1> hmm
13:40:56 <sjanssen> sure it would be needed.  Programmers write their own functions and data structures all the time
13:41:00 <dmwit> > toFloat 1
13:41:01 <lambdabot>   Not in scope: `toFloat'
13:41:04 <joelr1> ah!
13:41:12 <joelr1> @hoogle toFloat
13:41:13 <lambdabot> No matches found
13:41:16 <dmwit> > toRational 1
13:41:18 <netytan> sjanssen: true true :). How do you do strict eval in haskell. Monads?
13:41:18 <lambdabot>  1%1
13:41:27 <joelr1> dmwit: where's toFloat?
13:41:30 <sjanssen> > fromInteger 1 :: Double
13:41:32 <lambdabot>  1.0
13:41:38 <joelr1> aha
13:41:41 <joelr1> ok
13:41:48 <dmwit> ?hoogle (Num a, Floating b) => a -> b
13:41:50 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
13:41:50 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
13:41:50 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
13:41:53 <bd_> netytan: Monads give you a specific order of operations. seq gets you strictness but perhaps not in the way you want :)
13:41:55 <sjanssen> for literals you can just write:
13:41:59 <sjanssen> > 1 :: Double
13:42:01 <lambdabot>  1.0
13:42:22 <sjanssen> netytan: you get strictness with seq or pattern matching
13:42:25 <netytan> seq? is that some builtin control op?
13:42:34 <dmwit> netytan: Another way to specify it is to annotate certain variables as strict.
13:42:34 <netytan> please explain :)
13:42:36 <xerox> ?type fromIntegral
13:42:38 <lambdabot> forall a b. (Num b, Integral a) => a -> b
13:42:54 <netytan> dmwit: not a static typing fan unless it's needed :)
13:42:55 <bd_> netytan: Yes, seq <something which evaluates to an error> <anything> = <something which evaluates to an error>
13:42:55 <sjanssen> netytan: seq x y essentially means force x, then return y
13:42:58 <dmwit> Err... well, constructors, rather.
13:43:10 <sjanssen> static typing is always needed
13:43:12 <sjanssen> :)
13:43:43 <dmwit> I think it's done like,
13:43:59 <netytan> (define (seq x y) (force x) y)? whats the point in that. Think i'm missing something
13:44:06 <dmwit> data StrictInt = StrictInt !Int
13:44:12 <dmwit> (Or so?  I'm not really sure.)
13:44:38 <emu> @src foldl'
13:44:38 <lambdabot> foldl' f a []     = a
13:44:39 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
13:44:47 <emu> look at how seq is used
13:45:29 <emu> it binds a' = f a x.  then it says "force eval of a' before proceeding with the fold"
13:45:47 <emu> a' `seq` foldl' f a' x
13:45:49 <sjanssen> netytan: think of "seq x y" as an annotation in your program that means: to force y, the compiler must first force x
13:46:18 <netytan> oh ok :)
13:46:21 <emu> that is the same as saying: seq a' (foldl' f a' x) -- in case you aren't familiar with backquotes
13:46:23 <netytan> thanks guys
13:46:32 <sorear> netytan: seq is \x y -> y, but the compiler treats it more like +
13:46:32 <netytan> Think maybe I should learn haskell ;)?
13:46:47 <sorear> netytan: to add two numbers, they obviously both have to be forced
13:46:56 <netytan> yes yes :)
13:46:59 <dmwit> I think, given the place you're asking, you know the answer to that question... ;-)
13:47:06 <netytan> strange language. Lots of little quirks
13:47:11 <netytan> interesting notation
13:47:12 <sorear> netytan: seq is interpreted that way, even though it only returns the second..
13:47:51 * sorear wonders if he should try and reformat the hour-long explanation of compiled graph reduction he gave yesterday into html
13:48:07 * dmwit would re-read it
13:48:13 <dolio> I thought it was a pretty nice overview.
13:48:16 <sjanssen> sorear: I only glanced at it, but it'd likely be useful
13:48:43 <sjanssen> many people learn better when they have a concrete machine model to match the abstract stuff
13:49:09 <stranger> This is probably a stupid question, but what exactly is wrong with mutable state?
13:49:20 <stranger> Non-shared, local state, that is.
13:49:30 <sorear> Nothing!
13:49:36 <sorear> @ty Control.Monad.ST.runST
13:49:39 <lambdabot> forall a. (forall s. ST s a) -> a
13:49:40 <sjanssen> state-less is often easier to reason about
13:49:47 <dolio> It enables you to write more bugs?
13:50:20 <emu> mutable state keeps many people employed
13:50:50 <dolio> Or, more kinds of bugs, I suppose.
13:51:19 <dolio> Which is bad assuming the number of bugs you write is directly proportional to the number of kinds of bugs you can write. :)
13:52:16 <Excedrin> if I have a program that works correctly using readArray and writeArray, is there any reason why it shouldn't work correctly using unsafeRead and unsafeWrite?
13:52:21 <sorear> no.
13:52:37 <sorear> unless you also use catch :)
13:52:46 <Excedrin> ok, where should I start looking when that's not the case
13:52:51 <sjanssen> @hoogle unsafeRead
13:52:51 <lambdabot> No matches found
13:52:54 <Excedrin> I don't use catch
13:53:17 <sjanssen> Excedrin: there are definitely cases where unsafeRead /= readArray
13:53:36 <sorear> Excedrin: so you have a working program, and when you change one readArray to unsafeRead, it stops working?
13:53:41 <emu> @wiki Test
13:53:41 <lambdabot> http://www.haskell.org/haskellwiki/Test
13:53:42 <sjanssen> unsafeRead is always Int indexed, starting at 0.  readArray can have any index type at start at any value
13:53:55 <stranger> I guess I just don't understand how lack of a potentially dangerous but sometimes useful feature can be presented as an advantage...
13:54:14 <sorear> sjanssen: cool, I thought all array functions used the (blech!) indexed form...
13:54:29 <sorear> s/indexed/Ix/
13:54:39 <Excedrin> if I change both to the unsafe versions, I get a segfault, if I change read only I get different results and if I change write only I get a segfault
13:54:43 <sjanssen> stranger: Haskell *does* have mutable state.  It is relegated to specific controllable parts
13:54:59 <Excedrin> sjanssen: ok, I'll make sure that I'm using Int indices
13:55:01 <kscaldef> today is the first time I've tried installing any modules outside the GHC distro... I'm trying to build and install HaXML, but I get this:
13:55:03 <kscaldef>     Unknown pseudo-op: .subsections_via_symbols
13:55:10 <kscaldef> when building
13:55:14 <sjanssen> Excedrin: does your array use Int indices?  Do you start at zero?
13:55:22 <sorear> kc5tja: yow!
13:55:33 <sorear> kscaldef: yow!
13:55:48 <sorear> kscaldef: That sounds like an as(1) error...
13:55:49 <stranger> sjanssen: didn't the lack of mutable state actually precede the introduction of monads?
13:56:04 <sorear> kscaldef: are you using -fvia-C?
13:56:20 <Excedrin> I start at 1, and I might be using Word8 indices, I'm checking now
13:56:24 <stranger> there must have been valid reasons to banish state from the language in the first place
13:56:41 <sjanssen> stranger: probably.  I'm not really up on the IO stuff that predates monads
13:56:43 <kscaldef> sorear: I don't really know... I'm running "runhaskell Setup.hs build" per the instructions
13:57:04 <sorear> -fvia-C is much more fragile than -fasm, because it compiles using GCC and *then* mangles the asm with a perl script
13:57:15 <sorear> kc5tja: do you have a new GCC and old GHC?
13:57:25 <sjanssen> Excedrin: starting at 1 is your problem.
13:57:31 <sorear> tab completion is not being very friendly today :(
13:57:33 <thorat> stranger: yes, garbage collection advocates claim that otherwise programmer spend a lot of time managing memory.  Haskell advocates claim that without lazy evaluation (comes with non-mutable state) you spend a lot of time explicitly sequencing your computation - carrying around intermediate values.
13:57:52 <kscaldef> mangling asm with perl sounds like a bad idea
13:58:10 <kscaldef> anyway, I have ghc-6.6
13:58:13 <sorear> kscaldef: It is even called the "Evil Mangler" :)
13:58:13 <Excedrin> sjanssen: ok, thanks
13:58:21 <kscaldef> and gcc 3.3
13:58:32 <sjanssen> stranger: how would you feel about totally disallowing shared (across threads) mutable state?
13:58:36 * sorear info as
13:59:05 <sorear> Hmm.  Does the NCG use gas?
13:59:21 <sjanssen> kscaldef: see if there is a ghc-options line in the .cabal file.  Try tacking -fasm on at the end of it, runhaskell Setup.hs clean, and start over
13:59:29 <stranger> sjenssen: I think it should be allowed but strongly urged against
14:00:49 <Excedrin> cool, correct results and 32 seconds faster!
14:00:50 <sorear> Haskell has no shortage of rope, but it's all locked inside boxes marked "Break glass only in case of performance emergency"
14:01:34 <kscaldef> sorear: no, still the same error
14:01:42 <Excedrin> now at 143 seconds, it's only 126 seconds slower than Java :(
14:01:43 <kscaldef> er sjanssen
14:01:46 <stranger> But what exactly is the danger this particular box is saving me from?
14:01:55 <sorear> kscaldef: in that case try -fvia-C
14:01:55 <kscaldef> none of us seem good at names today :-)
14:02:00 <malcolmw> kscaldef: what machine? mac?
14:02:05 <kscaldef> yes, mac
14:02:17 <malcolmw> kscaldef: intel?
14:02:22 <dmwit> Excedrin: Have you profiled it?  Is it text-intensive?
14:02:22 <kscaldef> no
14:02:52 <dolio> stranger: It's difficult (at the least) to have a lazy-by-default language that doesn't banish mutable state also (barring monads now), and Haskell was originally intended to be The Lazy Language for academics and normal people.
14:03:19 <kscaldef> -fvia-C makes no difference either
14:03:20 <dolio> Which is at least one reason why state was banished in the first place.
14:03:39 <Excedrin> dmwit: it's not text intensive, but it's a direct translation of the java, so there's probably a lot of ways to improve it
14:03:41 <stranger> So it's the interaction of state with laziness that's the problem then?
14:04:13 <stranger> Rather than mutable state per se?
14:04:17 <dolio> That's one argument. It's not the only possible one.
14:04:30 <sorear> stranger: right.  in order to have state be useful, you need to be able to reason about execution order
14:04:43 <thorat> stranger: the ability to use equational reasoning is the other
14:04:58 <sorear> stranger: and that's notoriously hard when your function calls are deferred until the last possible moment :)
14:05:13 <stranger> I think I understand a little better now, thank you
14:06:17 <Excedrin> stranger: no, state is bad in general, why don't you read "Why FP Matters"
14:06:31 <stranger> I have, no mention of the evils of state
14:06:37 <kc5tja> sorear: I would like to think that I do.  How new is new?
14:06:46 <stranger> it's basically about higher-order functions and laziness
14:07:31 <dolio> Have you watched any of the SICP lectures that are available online? In one of them, sussman explains the dangers of adding mutable state to a language.
14:07:42 <Excedrin> stranger: http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
14:07:45 <lambdabot> Title: Why Functional Programming Matters
14:07:49 <sjanssen> stranger: the simplification received by removing state is similar to the simplicity of geometry in 2 dimensions instead of 3
14:07:57 <stranger> Excedrin: again, I have read this paper
14:08:03 <stranger> and most of SICP as well
14:08:33 <sjanssen> stranger: mutable state adds the additional "dimension" of sequence/time that you must consider throughout your entire program
14:08:44 <dolio> I can't actually remember if it's explained in the book. It's been a while since I read it.
14:09:43 <stranger> it does warn about the extra complexities of adding state to the language, but it does not follow that it should be banished altogether
14:10:05 <sorear> kc5tja: I was looking for kscaldef and TAB failed to DWIM, sorryt
14:10:28 <stranger> scheme and ML seem to manage quite well with mutable state...
14:10:52 <thorat> and Haskell without it
14:10:53 <dolio> stranger: Well, you could, perhaps, consider Haskell an experiment in how far you can go towards banishing state, and still come up with a useful language.
14:11:25 <stranger> sure, I'm just curious what the motivation was behind this experiment
14:11:41 <sorear> Wow.  My program takes 9.1 seconds with State# threads, and 4.2s without.  Now, does it give the right answer?
14:12:13 <kscaldef> the motivation is to not have to think about state
14:12:24 <dolio> Because if state creates bugs, and you can get by perfectly well without it, why not do so?
14:12:24 <kscaldef> which is generally "hard"
14:12:48 <stranger> I don't actually dispute that
14:13:30 <stranger> but why is a language in which mutable state is disallowed better than one in which it is discouraged
14:13:59 <kscaldef> I'm not sure there's sufficient evidence to support that statement
14:14:06 <sjanssen> stranger: you can be certain that third party code doesn't use state in a way that screws up your program
14:14:14 <opqdonut> :)
14:14:15 <malcolmw> kscaldef: http://hackage.haskell.org/trac/ghc/ticket/330
14:14:16 <kscaldef> I'm not sure that there's even any agreement on what that statement means
14:14:17 <lambdabot> Title: #330 (Unknown pseudo-op: .subsections_via_symbols (apple gcc 3.3)) - GHC - Trac
14:14:37 <kscaldef> particularly what the word "better" means
14:14:38 <thorat> stranger: when you take it out you get other things in return: Expressiveness and correctness.
14:15:05 <sjanssen> if something is allowed, somebody is going to use it.  It follows that somebody is going to use it incorrectly
14:15:27 <stranger> kscaldef: I'm not making a statement either way, only asking the question
14:16:03 <thorat> stranger: The correctness part is quite obvious, the expressiveness not as much: it's about not having to deal with time.
14:16:10 <kscaldef> malcolmw: thanks... I go upgrade xcode now...
14:17:08 <kscaldef> stranger: I'm pointing out that perhaps the experiment hasn't finished yet
14:17:32 <kscaldef> but, I am a Haskell newbie and have little attachment to the issue
14:18:12 <stranger> same here
14:18:48 <sjanssen> I wouldn't call it an experiment any more.  Haskell is a capable programming language, and has been used successfully for many applications
14:20:41 <kscaldef> I guess it depends on the scale you view the experiment as being performed at
14:21:57 <kscaldef> currently, I would not say that Haskell has sufficiently proved its superiority for most tech managers (by whatever metric they use), or even more most programmers
14:22:28 <dolio> Heh. Neither has Lisp.
14:22:41 <dolio> And it's been around for a bit longer. :)
14:22:51 <stranger> I doubt most programmers are even aware of Haskell's existence.
14:23:12 <stepcut> nobody ever got fired for recommending C++
14:23:13 <stranger> Not that this should be the metric for success...
14:23:23 <kscaldef> depends on whether you consider everyone who writes any code to be a "programmer" I suppose :-)
14:23:27 <procyon112> kscaldef: It doesn't need to prove it's superiority to be applicable.  It only needs to prove to be functional.  C++'s STL is fundamentally *broken* in some respects, admittedly so, but this doesn't cause it to not be used.
14:24:06 <opqdonut> well haskell needs to prove superiority in order to be used instead of something else
14:24:24 <kscaldef> I'm probably not being clear enough.... different people have different measures of goodness of a programming language
14:24:34 <cpoucet> Hence all the lovely flame-fights :)
14:24:38 <procyon112> It only needs to be shown to be superior to the task at hand, and for a very subjective definition of "superior"
14:24:52 <cpoucet> `superior` procyon112  == True
14:25:05 <cpoucet> It's that easy :)
14:25:14 <kscaldef> at the moment, I like Haskell more than most languages I've played with recently (actually, since OCaml)
14:25:32 <cpoucet> kscaldef: haskell does have have some nice features that make O'Caml less than pleasant.
14:25:34 <kscaldef> but, it would be very, very hard for me to lobby to use Haskell for anything I do at work
14:25:41 <cpoucet> kscaldef: What do you do at work?
14:25:55 <sorear> Haskell can give you nice bugs too!   (# st3 , _   #) = unIO (copyBytes (Ptr addr_new) (Ptr addr_new) (I# len)) st2
14:26:01 <kscaldef> I work for a major web company
14:27:02 <cpoucet> kscaldef: No, -what- do you do
14:27:13 <cpoucet> sorear: uIO?
14:27:22 <procyon112> kscaldef: Right.  For many people, the primary factor in measuring "superiority" is "Can I jump in and write code quickly to get real work done." For me, coming from a strong C++ background, C# is "superior" to Lisp.  That doesn't say anything about the language except that I'm more comfortable in a similar language.  C# could be broken in horrible ways, but I'm still going to be more productive in it than in Lisp.
14:27:43 <sorear> @src unIO
14:27:43 <lambdabot> Source not found. I've seen penguins that can type better than that.
14:27:58 <emu> ow
14:27:59 <sorear> hm.  it's not user-defined.
14:28:07 <kscaldef> primarily I work on high-performance, high-reliability, distributed applications (that only incidentally happen to provide an HTTP interface)
14:28:25 <procyon112> kscaldef: and what language do you use?
14:28:27 <jmelesky> kscaldef: so you use erlang? :)
14:28:32 <kscaldef> I wish
14:28:39 <kscaldef> primarily C
14:29:39 <procyon112> I'm sorry :)
14:30:17 <kscaldef> actually, there's a internal thread on erlang at the moment, with the predictable concerns that we wouldn't be able to retrain people and that it wouldn't help at all with scaling the 3-party components we use for certain critical needs
14:30:23 <vali> hello. does haskell support object-orientation?
14:30:31 <sorear> not really
14:30:36 <kscaldef> the first is basically a red herring, the second is a fairly valid point
14:30:46 <sorear> you can fake it, about as easily as you can fake it in C
14:30:50 <Excedrin> stranger: it's not disallowed in Haskell
14:30:52 <vali> sorear: good
14:30:53 <procyon112> vali: It supports a superset of OO
14:30:58 <vali> aah
14:31:11 <vali> i never found myself in a situation where i needed it
14:31:16 <vali> so i'm glad
14:31:41 <sorear> Mostly, all we use fake-OO for here is bindings to 3rd-party OO libraries, like GTK
14:32:12 <sjanssen> which is itself, OO faked in C :)
14:32:18 <vali> sorear: aah. do you know if wxHaskell stuff is any good?
14:32:25 <procyon112> kscaldef: So your internal lobbying has little to do with what language is superior, rather, it hinges on the cost of training.
14:32:27 <sorear> vali: never used it, sorry
14:32:37 <vali> sorear: oh, okay
14:32:43 <kscaldef> procyon112: I said that's a red herring
14:33:19 <kscaldef> but, indeed, large companies worry a lot about whether they can hire enough people with the skills they need
14:33:55 <sorear> My low-level code is exhibiting some very wierd strictness behavor, it returns a (# MutableByteArray# RealWorld, Int# #) and seems to run much slower if the array is demanded, than if just the length is demanded.  I thought #-s were strict?
14:34:15 <kscaldef> the more valid point in my mind is that when you do a lot of interacting with systems that expect you to interact with them in C/C++, the gains from using another language become a lot less clear
14:35:31 <procyon112> kscaldef: And that's a real concern too.  If I needed to start a new project that I knew would require staffing 50 devs, I would hesitate to jump right into Haskell as an implementation language for fear of there not being 50 employable Haskell devs within 100 miles.
14:35:44 <sorear> OK, this is Really Wierd.
14:36:07 <sorear> Strict bytestring show consumes vast amounts of memory on 96MB bytestrings.
14:36:25 <sorear> shouldn't it unpack lazily, since it is producing a list?
14:37:13 <sjanssen> sorear: the implementation sucks, it unpacks strictly
14:37:31 <sorear> ouch
14:37:35 <sjanssen> sorear: file a bug
14:38:12 <sjanssen> or maybe I'll just write a patch right now
14:38:24 <Excedrin_> kscaldef: have you looked at BitC?
14:39:25 <procyon112> kscaldef: On the other hand. most projects I've worked on have a "helper language" around.  For instance, on my current project, we do most development in C++, but there is alot of tools and build scripts written in C#, Perl and MS-Batch.  I would have few concerns having devs employ Haskell for side applications if productivity was increased.
14:39:33 <mwc> in the docts for Foreign.Marshall.Alloc.malloc
14:39:34 <mwc> The memory may be deallocated using free or finalizerFree when no longer required.
14:39:53 <mwc> does that may mean that we can forget about it and let the GC reap it?
14:39:58 <sorear> no.
14:40:16 <mwc> That's pretty ambiguous... we should fix those docs
14:40:25 <mwc> s/may/must
14:40:31 <sorear> the alternative (note 'may') almost certainly refers to System.Exit.exitWith
14:40:49 <sorear> and if you don't - it's still perfectly legal to leak memory
14:41:00 <sorear> s/may/should
14:41:01 <procyon112> kscaldef: We once had a dev write an *extremely* useful tool over the weekend... in TCL.  regardless of the fact that no one (but him) wanted TCL in the tree, it got added because usefulness trumps politics in most orgs.
14:42:22 <mwc> sorear, true, but it still sounds like the user doesn't need to worry about deallocation.
14:43:02 <desp> is this good style?
14:43:02 <desp> remove ('(':'*':xs) = remove $ pass xs
14:43:04 <procyon112> kscaldef: I'm sure that if I wrote, for instance, an nmake replacement for our build system in haskell that had all the advantages of our current system, but handled dependancies better, We'd be using Haskell on this team tomorrow ;)
14:43:35 <desp> or is this good style?
14:43:36 <desp> remove (x:y:xs) | x == '(' && y == '*' = remove (pass xs)
14:43:54 <int-e> desp: I'd prefer the first
14:43:58 <kscaldef> procyon112: yeah, it can happen... we have bits of python floating about even though it's not a "blessed" language.  Although, it creates a situation where most people can't jump in an work on it (and the original author has moved to other things).  It's exactly what management worries about
14:44:27 <desp> int-e: aha, thanks. that's what I'm going to suggest to a friend
14:44:54 <kscaldef> procyon112: I strongly suspect if I did that, I'd get buried in politics.  But, I'm generally depressed about work at the moment, so I might be overly pessimistic
14:45:01 <sjanssen> @tell dons sorear noticed that strict ByteString's Show instance produces output strictly, but lazy is obviously better
14:45:02 <lambdabot> Consider it noted.
14:46:05 <stranger> Newbie question: which extensions to Haskell 98 are commonly used in practice?
14:46:32 <sjanssen> hierarchical module names are the biggest
14:46:36 <stranger> Does GHC serve as a kind of de facto standard?
14:46:50 <int-e> multi paramater type classes and functional dependencies are also used quite often
14:46:55 <int-e> parameter
14:46:56 <procyon112> kscaldef: I think the sweet spot is "free tools".  If you give the company something it wouldn't have otherwise, then they will generally take it.  The alternative is for the company to spend the time to money to implement it in a "blessed" language.  If you do it as an "experiment" and it works, the cost of just accepting the tool as-is over reimplementing it is much more amicable.  That's probably exactly how you got bits of python
14:47:16 <stranger> sjanssen, int-e: thanks
14:47:28 <sjanssen> stranger: essentially, yes.  There's an ongoing effort to write the next Haskell standard, it is essentially codifying the extensions that exist in GHC
14:47:41 <procyon112> kscaldef: Eventually there are enough things "floating around" that they get blessed :)
14:48:06 <kscaldef> malcolmw: installed xcode 2 / gcc 4 and things seem cool now.  Thanks for the pointer
14:48:32 <stranger> sjenssen: how far along is the Haskell' effort?
14:48:52 <kscaldef> procyon112: the problem is we have no shortage of build systems, so new ones are not evaluated on their merits
14:48:58 <sjanssen> stranger: it's stalled at the moment.  I'm not sure anybody knows when it will be ready
14:49:56 <malcolmw> kscaldef: happy to help
14:50:54 <procyon112> kscaldef: Maybe not build systems, but every org has tools that it would kill to have if they existed.  I just replaced our teams entire wiki site with doxygen.. they just about wet themselves when they saw what it could do.
14:51:09 <MarcWeber> I want to write a small parser parsing either "dummy" or any string. "dummy" also matches any string so I'll get an ambiguous parse when combining both usnig +++ (= mplus) . Is there already a function which runs the first parser parsnig "dummy" and only runs the second <parse any string> if the first fails?
14:51:57 <DukeDave> Hey gang, my first trip into arrays and I'm going to be performing a lot of in place updates & additions, any suggestions?
14:52:03 <MarcWeber> Is using lookahead the way to go?
14:52:41 <procyon112> kscaldef: It also saved me weeks of work :)  I was tasked 3 weeks to make sure all the code documentation was up to date.  I downloaded doxygen and was finished in 30 minutes :)
14:53:02 <Philippa> MarcWeber: there're many parsing libs...
14:53:04 <emu> DukeDave: additions?
14:53:17 <MarcWeber> DukeDave: Either reading source or documentation? If you're struggling post again a concrete question? (Such as I don't know where to start (eg hoogle) or where do I find the source code ?)
14:53:20 <DukeDave> emu, I mean, to the end of the array
14:53:27 <Philippa> well, a few ones worth using and an awful lot of libraries that contain their own ad hoc set of parsing combinators
14:53:35 <emu> DukeDave: that doesn't sound like you want an array
14:53:42 <emu> @wiki Array
14:53:42 <lambdabot> http://www.haskell.org/haskellwiki/Array
14:53:54 <MarcWeber> Philippa: Really. I forgot to say I'm using ReadP
14:53:55 <emu> @wiki Arrays
14:53:56 <lambdabot> http://www.haskell.org/haskellwiki/Arrays
14:55:49 <emu> DukeDave: from the sounds of it, you might just want to use Data.Map.  But if arrays are really what you want, DiffArrays may be the easiest and most efficient
14:55:55 <joelr1> how do you create a parser for an optional semicolon?
14:56:08 <emu> they use the standard immutable array interface but implement O(1) update under the hood
14:56:09 <sjanssen> @hoogle optional
14:56:10 <lambdabot> Text.ParserCombinators.ReadP.optional :: ReadP a -> ReadP ()
14:56:10 <lambdabot> Text.ParserCombinators.Parsec.Combinator.optional :: GenParser tok st a -> GenParser tok st ()
14:56:18 <Philippa> MarcWeber: that helps :-)
14:56:23 <sjanssen> joelr1: optional (char ';')
14:56:27 <joelr1> darn
14:56:29 <joelr1> thanks!
14:57:06 <joelr1> i'm continually impressed!
14:57:17 <DukeDave> emu, cool, map could be the way forward. Cheers
14:59:09 * joelr1 is a convert to combinatorial parsing
14:59:25 <stranger> Another newbie question: do people generally suffer the monomorphism restriction in silence or do they simply turn it off in GHC?
14:59:44 * rahikkala turns it off, but I'm a newbie myself
14:59:49 <emu> i don't suffer from it?
15:00:25 * DRMacIver doesn't know what it is. :)
15:00:37 <emu> it's almost always resolved by making the parameters explicit
15:00:50 <emu> or the types
15:01:58 <sjanssen> stranger: Haskell code in the wild (open source libraries and applications) don't turn off the monomorphism restriction
15:03:33 <stranger> I guess turning it off is frowned upon then
15:04:08 <stranger> stupid question: why is the MR even necessary if it can simply be turned off?
15:04:19 <joelr1> is there a variant of optional in Parsec that returns Nothing instead of ()?
15:04:27 <procyon112> what is the monomorphism restriction?
15:04:56 <joelr1> i think it's called option
15:05:03 <emu> stranger: the issue comes up because without it there might be repeated computation
15:05:11 <Philippa> joelr1: I forget, and it's possible there isn't. However: \foo -> Just `liftM` foo <|> return Nothing
15:05:42 <joelr1> @hoogle option
15:05:43 <lambdabot> Text.Html.option :: Html -> Html
15:05:43 <lambdabot> Text.ParserCombinators.ReadP.option :: a -> ReadP a -> ReadP a
15:05:43 <lambdabot> Text.ParserCombinators.Parsec.Combinator.option :: a -> GenParser tok st a -> GenParser tok st a
15:05:55 <joelr1> option x p          = p <|> return x
15:05:59 <joelr1> this is the one... i think
15:06:14 <Philippa> yeah, it's just not got the Maybe specialisation
15:06:44 <DukeDave> Erm, an issue with my array question: I need it to be dynamically sizable :o
15:07:01 <sjanssen> DukeDave: has anyone told you to use a Data.Map?
15:07:15 <joelr1> Philippa: i think you can call it like this 'option Nothing p'
15:07:17 <DukeDave> sjanssen, yeah, but I'm not sure how appropriate it is
15:07:24 <emu> stranger: consider: let x = longComputation in (x, x)
15:07:31 <Philippa> joelr1: yep, only p has to return Just something
15:07:38 <DukeDave> I'll knock together a better description of my problem
15:07:50 <procyon112> DukeDave: Do you need O(1) lookups, or will O(log N) do?
15:07:51 <sjanssen> DukeDave: there are no resizable arrays in the base library
15:08:05 <sjanssen> O(log n) is practically constant, anyway
15:08:12 <emu> stranger: for example if longComputation is of type Num t => t, then there might be multiple ways the fst and snd parts of the (x,x) could be used elsewhere
15:08:42 <stranger> thanks for the explanation, emu
15:08:51 <emu> stranger: and the gist of it is that it could cause longComputation to be evaluated twice ... one for one type of Num and another for another type of Num
15:08:53 <procyon112> DukeDave: Because, there is a high price to pay in complexity and flexibility for those O(1) lookups.
15:11:17 <procyon112> DukeDave: Particularly high price to pay when it comes to resizeability, which for arrays is an O(n) operation (sometimes amatorized, as it is in C++'s STL).
15:11:42 <emu> amortized
15:12:16 <procyon112> DukeDave: Whereas Maps can be O(log n) lookup and O(log N) resize/mutation.
15:12:45 <emu> the amortized analysis would have to depend on the pattern of insertions/extensions
15:14:32 <procyon112> emu: my IRC client needs a spellcheck ;)
15:14:37 <emu> erc ;)
15:14:51 <stranger> About the MR: how often does that actually come up in practice?
15:15:09 <stranger> I mean, the cure looks worse than the disease to me...
15:15:11 <emu> pretty rarely for me
15:15:19 <emu> you mean running into it?
15:15:22 <stranger> yeah
15:15:52 <emu> generally you'll run into it eventually if you like to do a lot of point-free bindings
15:16:01 <emu> (without type annotations)
15:16:13 <hpaste>  DukeDave pasted "Arrays :)" at http://hpaste.org/1244
15:16:13 <stranger> err wait, this I run into all the time
15:16:32 <stranger> I meant your earlier example of re-computed result
15:16:32 <emu> ...eventually
15:16:45 <emu> what, of let x = ... in (x,x)?
15:16:53 <procyon112> DukeDave: Additionally, maps get insertion as an O(log N) operation for free, whereas with array's, it's an O(n) operation even without resize.
15:16:56 <stranger> yes, that one
15:17:31 <emu> stranger: first, there's some rules to make things a little more sane by default
15:17:37 <emu> they're called defaulting rules, actually
15:17:53 <emu> there's an order of preference for Nums
15:17:54 <DukeDave> procyon112, maps are sounds more like the best option; although they feel a little unnaturally in this problem because I will have to 'invent' keys.
15:18:02 <emu> (you can change it with a "default" decl. rare bit of haskell)
15:18:11 <emu> DukeDave: numbers
15:18:12 <stranger> it still comes up pretty often, e.g. sum = foldl (+) 0
15:18:25 <procyon112> DukeDave: You have to invent them with arrays to... the index *is* the key.
15:18:34 <DukeDave> this is true :)
15:18:36 <stranger> where you have to add the extra argument to get around the MR
15:18:40 <emu> > let sum = foldl (+) 0 in (sum [1.0], sum [1])
15:18:42 <lambdabot>  (1.0,1.0)
15:18:48 <sorear> general finger trees will do just about anything in O(log n), with a nice constant
15:18:49 <emu> it's defaulting
15:19:06 <DukeDave> Excellent, thanks everyone, I'll get on to it with Map
15:19:30 <beelsebob_> anyone got any good ideas for a small example function that uses a local definition using free variables?
15:19:35 <stranger> but then you can't use it to sum lists of different types of numbers, right?
15:20:29 <emu> lists of different types of numbers?
15:20:34 <beelsebob_> stranger: how would you have a list containing different types?
15:21:14 <beelsebob_> the type for list is forall a . [a], not exists a . [a]
15:21:31 <stranger> I meant different lists, one of ints, one of floats, etc.
15:21:37 <beelsebob_> sure you can
15:21:44 <beelsebob_> sum :: Num a => [a] -> a
15:21:53 <beelsebob_> you can use it on any numeric type
15:22:34 <stranger> I wasn't talking about the standard definition of sum, but an earlier example I gave in the context of a discussion on the monomorphism restriction
15:22:43 <stranger> ...just forget I mentioned anything
15:22:44 <emu> @type (foldl (+) 0)
15:22:46 <beelsebob_> let sum = foldr (+) 0 in (sum ([1,2,3] :: [Int]), sum ([1.0,2.9,3.7] :: [Float])
15:22:46 <lambdabot> forall a. (Num a) => [a] -> a
15:22:57 <beelsebob_> > let sum = foldr (+) 0 in (sum ([1,2,3] :: [Int]), sum ([1.0,2.9,3.7] :: [Float])
15:22:58 <lambdabot>  Parse error
15:23:00 <beelsebob_> oops
15:23:07 <beelsebob_> > let sum = foldr (+) 0 in (sum ([1,2,3] :: [Int]), sum ([1.0,2.9,3.7] :: [Float]))
15:23:08 <lambdabot>  Couldn't match expected type `Int' against inferred type `Float'
15:23:12 <beelsebob_> o.O
15:23:22 * beelsebob_ wonders where that happened
15:23:45 <stranger> see, that's what I was talking about
15:23:51 <dmwit> beelsebob_: monomorphism restriction?
15:23:53 <beelsebob_> > let sum = foldr (+) (fromInteger 0) in (sum ([1,2,3] :: [Int]), sum ([1.0,2.9,3.7] :: [Float]))
15:23:54 <lambdabot>  Couldn't match expected type `Int' against inferred type `Float'
15:24:16 <beelsebob_> dmwit: shouldn't come up against it -- sum is applied in two distinct instances there
15:24:29 <stranger> try adding the list argument on either side of the equation and it'll work
15:24:31 <stranger> I think
15:24:32 <dmwit> Yeah, and it's not top-level. Hmmm...
15:24:54 <beelsebob_> > let sum x = foldr (+) (fromInteger 0) x in (sum ([1,2,3] :: [Int]), sum ([1.0,2.9,3.7] :: [Float]))
15:24:56 <lambdabot>  (6,7.6000004)
15:24:58 <beelsebob_> so it will
15:25:06 * beelsebob_ wonders why the type system explodes at that
15:25:29 <beelsebob_> @type (foldr (+) 0)
15:25:31 <lambdabot> forall a. (Num a) => [a] -> a
15:25:43 <beelsebob_> @type (\x -> foldr (+) 0 x)
15:25:45 <lambdabot> forall a. (Num a) => [a] -> a
15:25:50 <dmwit> > let sum :: (Num a) => [a] -> a; sum = foldr (+) 0 in (sum [1,2,3] :: Int, sum [1.5, 3.5] :: Float)
15:25:52 <lambdabot>  (6,5.0)
15:25:55 * emu invokes lambdabot with -fno-monomorphism-restriction
15:26:05 <dmwit> Huh.
15:26:10 <beelsebob_> emu: yeh, but why do you come up against it?
15:26:17 <beelsebob_> you shouldn't surely
15:26:51 <stranger> it's just part of the standard definition of the language, see the monomorphism restriction in the Haskell 98 Language Report
15:27:18 <beelsebob_> yes I know -- I don't see why it applies here though
15:27:22 <dmwit> I guess that's why it's considered good style to give type annotations for everything.
15:28:12 <emu> it pretty much matches: let x = ... in (x,x)
15:28:18 <beelsebob_> I guess the first definition suggests that sum will be computed once for all types in num
15:28:31 <beelsebob_> wheras the second suggests that it will be evaluated every time
15:28:53 <beelsebob_> it suggests sharing where there is none
15:29:30 <beelsebob_> gyargh! I hate coming up with examples
15:30:33 <dmwit> ?spell lable
15:30:35 <lambdabot> label labile liable labeler libel
15:32:14 <emu> ?spell dmwit
15:32:14 <lambdabot> dimwit demit dimwits Dewitt dammit
15:32:20 <beelsebob_> rofl
15:32:28 <dmwit> dammit
15:32:49 <emu> lambdabot is a meanie
15:32:58 <emu> lambdabot: bad bot
15:33:07 <emu> @vixen
15:33:08 <lambdabot> <undefined>
15:33:13 <emu> @yow
15:33:14 <beelsebob_> @spell emu
15:33:14 <lambdabot> I'm wet!  I'm wild!
15:33:14 <lambdabot> emu
15:33:15 <dmwit> Nah, I picked that name on purpose. ;-)
15:33:21 <beelsebob_> @spell beelsebob
15:33:21 <lambdabot> Beelzebub Beelzebub's belabor bellboy belabors
15:33:48 <stranger> @spell haskell
15:33:48 <lambdabot> Haskell Haskel Haskell's Skell Haskel's
15:33:56 <dmwit> ?all-dicts Haskel
15:33:57 <lambdabot> No match for "Haskel".
15:34:06 <dmwit> hmp
15:34:18 <procyon112> @spell procyon
15:34:19 <lambdabot> Procyon Procyon's proton prison Preston
15:34:25 <dmwit> ?protontorpedo
15:34:26 <lambdabot> and haskell is general purpose?
15:34:33 <dmwit> ?protontorpedo
15:34:33 <lambdabot> I read somewhere that large systms get confusing and haskell ends up a s a bunch of functions
15:34:43 <dmwit> ?protontorpedo
15:34:44 <lambdabot> check otu squeak seems dope
15:35:51 <dmwit> If I ?list, does it still take forever and tie up lambdabot?
15:35:55 <dmwit> ?where list
15:35:56 <lambdabot> I know nothing about list.
15:36:04 <beelsebob_> ?protontorpedo
15:36:04 <lambdabot> why would u write a interpreter for perl in haskell?
15:36:29 <beelsebob_> hehe
15:36:32 <emu> that would be an exploit
15:36:49 * beelsebob_ wonders how many perlers actually know that
15:36:52 <dmwit> Ah, I found the link anyway.
15:37:16 <dmwit> emu: Ah, well, the forever isn't in the literal sense.
15:37:22 <dolio> @quote qwe1234
15:37:23 <lambdabot> qwe1234 says: good developers will write good code in absolutely any language, while bad developers will develop crap no matter the tools they use.
15:37:40 <dmwit> ?ghc
15:37:41 <lambdabot> ghc says: scavenge: unimplemented/strange closure type
15:37:46 <dmwit> ?ghc
15:37:46 <lambdabot> ghc says: WARNING: SE CAFs unsupported, forcing UPD instead
15:37:53 <dmwit> ?fortune
15:37:58 <lambdabot> Said a modest young miss to de Sade,
15:37:58 <lambdabot> I'm simply too shy and afraid
15:37:58 <lambdabot> 	To take part in your pranks.
15:37:58 <lambdabot> 	But to show you my thanks,
15:37:58 <lambdabot> I'd just love to become your first aide.
15:37:59 <emu> that's actually a reasonable qwe quote
15:38:19 <dmwit> Oh, here's the one I was looking for.
15:38:20 <dmwit> ?keal
15:38:21 <lambdabot> doctor just give meds not fix prollem
15:38:28 <sorear> ?list
15:38:29 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
15:38:53 <sorear> and anyway, even ?list-all doesn't tie up the bot indefinitely now
15:39:11 <stranger> Regarding the monorphism restriction: couldn't a compiler tell the difference between 'let (x,x) = longComputation' and 'sum = foldl (+) 0' using type inference, making the former monomorphic but not the latter?
15:39:41 <sorear> stranger: certainly it *could*
15:39:49 <emu> let x = longComputation
15:39:54 <sorear> stranger: but h98 says "everything is monomorpic"
15:40:08 <sorear> the idea is it is safe to replicate "cheap things"
15:40:22 <sorear> much the way the GHC inliner will inline "cheap things"
15:40:38 <beelsebob_> can anyone even think of a function that you would normally write using a local definition?
15:40:44 <beelsebob_> let alone one with a free variable
15:40:56 <sorear> cheap things include literals, lambdas, and constructor applications
15:41:00 <sorear> beelsebob_: sure!
15:41:02 <beelsebob_> anything you want to add an accumulator I guess
15:41:09 <emu> the best things in life are cheap
15:41:11 <sorear> beelsebob_: but only because I am a GHC user
15:41:17 <emu> literals, lambdas, and constructor applications
15:41:19 <beelsebob_> sorear: some examples?
15:41:22 <sorear> beelsebob_: and GHC won't inline recursive functions
15:41:25 <sorear> @src foldr
15:41:26 <lambdabot> foldr k z xs = go xs
15:41:26 <lambdabot>     where go []     = z
15:41:26 <lambdabot>           go (y:ys) = y `k` go ys
15:41:42 <beelsebob_> ohh, that's quite nice
15:41:44 <sorear> the local definition effectively allows foldr to be specialized
15:41:47 <beelsebob_> excellent :)
15:41:50 <sorear> consider foldr (+) 0
15:42:01 <sorear> now the compiler can inline foldr
15:42:05 <beelsebob_> yep
15:42:08 <beelsebob_> that makes sense
15:42:32 <beelsebob_> ohhh... remind me to prod chris brown about that
15:42:35 <dmwit> Yay, gtk2hs is installed!
15:42:37 <sorear> who?
15:42:48 <sorear> (should I know?)
15:42:50 <beelsebob_> friend of mine and fellow-PhD student
15:43:03 <beelsebob_> I suspect his duplicate code analyser could probably do that optimisation automatically
15:43:58 <Excedrin> can ghc output the results of intermediate stages?
15:44:22 <dmwit> Excedrin: Of what?
15:44:32 <Excedrin> of compilation
15:44:46 <dmwit> Check out the -keep-*-file family of options.
15:45:13 <Excedrin> it'd be interesting to me to see the post-simplify code
15:45:15 <stranger> sorear: I'm not quite sure I understand where the cheap/expensive distinction comes in when it comes to the MR, sorry
15:45:16 <dmwit> There's also a way to get it to print the Core.
15:45:43 <sorear> Excedrin: -ddump-{simpl,stg,cmm,opt-cmm,ds,parsed,rn,types,etc,etc}
15:45:51 <Excedrin> awesome, thanks
15:46:11 <sorear> So, who has noticed GHC lacks principle types? :(
15:46:23 <joelr1> @hoogle identifier
15:46:24 <lambdabot> Text.Html.identifier :: String -> HtmlAttr
15:46:24 <lambdabot> Text.ParserCombinators.Parsec.Token.identifier :: TokenParser st -> CharParser st String
15:46:24 <lambdabot> Distribution.Package.PackageIdentifier :: String -> Version -> PackageIdentifier
15:46:36 <sorear> I had this great idea for a typechecking algorithm, but it only works with principal types...
15:47:04 <procyon112> So far I have gotten by with my types being all unprincipled.  Perhaps I will regret this someday.
15:47:14 <chessguy> hi procyon112
15:47:21 <procyon112> yo
15:47:41 <joelr1> @hoogle TokenParser
15:47:42 <lambdabot> Text.ParserCombinators.Parsec.Token.TokenParser :: CharParser st String -> (String -> CharParser st ()) -> CharParser st String -> (String -> CharParser st ()) -> CharParser st Char -> CharParser st
15:47:42 <lambdabot> String -> CharParser st Integer -> CharParser st Integer -> CharParser st Double -> CharParser st (Either Integer Double) -> CharParser st Integer -> CharParser st Integer -> CharParser st Integer ->
15:47:42 <lambdabot>  String -> CharParser st String -> CharParser st a -> CharParser st a -> CharParser st () -> CharParser st a -> CharParser st a -> CharParser st a -> CharParser st a -> CharParser st a -> CharParser
15:47:42 <lambdabot> st a -> CharParser st a -> CharParser st a -> CharParser st a -> CharParser st a -> CharParser st String -> CharParser st String -> CharParser st String -> CharParser st String -> CharParser st a ->
15:47:44 <lambdabot> CharParser st [a] -> CharParser st a -> CharParser st [a] -> CharParser st a -> CharParser st [a] -> CharParser st a -> CharParser st [a] -> TokenParser st
15:47:47 <lambdabot> Text.ParserCombinators.Parsec.Token.TokenParser :: data TokenParser st
15:47:49 <lambdabot> Text.ParserCombinators.Parsec.Token.makeTokenParser :: LanguageDef st -> TokenParser st
15:47:59 <chessguy> wow
15:48:07 <sorear> procyon112: as you are probably aware, there exists a subsumption relation on types, (a -> a) subsumes (Int -> Int)
15:48:29 <procyon112> chessguy: how'd that parser look?   I think it whould be adaptable.  I like the scheme notation for the trees personally.
15:48:38 <sorear> procyon112: the principal type T of an expression E is a type of E such that every other type T' of E is subsumed by T
15:49:11 <sorear> procyon112: so in Haskell-98, \x -> x has type (a -> a), (Int -> Int), (Bool -> Bool), etc, but (a -> a) subsumes all the others and is the principal type
15:49:21 <procyon112> sorear: isn't that the most general unifier?
15:49:22 <chessguy> procyon112: i actually haven't looked at it yet
15:49:35 <sorear> procyon112: in haskell-98 every expression either has no typings at all, or has a principle type
15:49:52 <sorear> procyon112: very related I think (never used mgus, so not sure)
15:50:05 <sorear> While, in GHC, \x -> x has more types.
15:50:27 <sorear> Int -> Int,  Bool -> Bool,  a -> a,  Int# -> Int#, ...
15:50:36 <sorear> a -> a doesn't subsume Int# -> Int#
15:51:09 <Igloo> sorear: H98 doesn't actually have principal types
15:51:35 <Igloo> http://citeseer.ist.psu.edu/faxen03haskell.html
15:51:37 <lambdabot> Title: Haskell and Principal Types (ResearchIndex)
15:51:57 <sorear> ooh.  *reads*
15:53:59 <procyon112> sorear: y=\x -> head x :: x must be a list, \x -> e is b -> b, so mgu == x=[a], y=[a]->a
15:54:20 <procyon112> sorear: wait... why doesn't a->a subsume Int#->Int# ??
15:57:26 <sorear> procyon112: a -> a  is short for  forall (a :: *) . a -> a ; Int# has kind #.   # /= *
15:58:14 <hpaste>  procyon112 annotated "Passing around in tuples is getting unweildy... what am I doing wrong this time?" with "simplified with maybe" at http://hpaste.org/1234#a1
15:58:32 <procyon112> ahhh.  I see.
16:01:23 <chessguy> procyon112: i like your repl. very clean
16:01:42 <procyon112> :D... bbl. dev mtg.
16:05:53 * dolio can never remember which kind is which, except for #.
16:06:34 <chessguy> ?src all
16:06:35 <lambdabot> all p =  and . map p
16:06:41 <dmwit> Hmmm.  There is an xmonad patch that says "Window borders," but I don't see them on my windows...
16:06:48 <chessguy> ?src and
16:06:48 <lambdabot> and   =  foldr (&&) True
16:06:52 <bd_> * is boxed types, # primitives, ? boxed or primitive, ?? boxed, primitive, or unboxed pair... I think?
16:06:57 <bd_> ?kind (->)
16:06:59 <lambdabot> ?? -> ? -> *
16:07:08 <bd_> got ? and ?? mixed up I gues
16:07:38 <dmwit> ?kind Int
16:07:41 <lambdabot> *
16:07:41 <chessguy> > all []
16:07:43 <lambdabot>  Couldn't match expected type `a -> Bool'
16:07:46 <dmwit> ?kind Int#
16:07:49 <lambdabot> Not in scope: type constructor or class `Int#'
16:07:55 <chessguy> > all isSpace []
16:07:57 <lambdabot>  True
16:08:32 <dmwit> > any isSpace []
16:08:33 <lambdabot>  False
16:10:33 <sorear> bd_: don't forget about (#), !, and !!
16:10:47 <bd_> ooh, what are those?
16:11:08 <dmwit> ?kind #Int
16:11:10 <lambdabot> lexical error at character 'I'
16:11:15 <bd_> ?kind Int#
16:11:17 <lambdabot> Not in scope: type constructor or class `Int#'
16:11:19 <sorear> @kind GHC.Prim.Int#
16:11:21 <lambdabot> #
16:11:23 <sorear> @kind (# GHC.Prim.Int# #)
16:11:26 <lambdabot> (#)
16:11:30 <bd_> heh
16:11:35 <sorear> @kind GHC.Prim.MutVar# Int
16:11:38 <lambdabot> * -> !
16:11:49 <bd_> !? >.>
16:11:52 <sorear> No, I don't know what ! is for
16:12:03 <sorear> I've only seen it
16:12:10 <sorear> I no longer remember where I saw !!
16:12:42 <dmwit> Why don't these things have real names/
16:12:53 <dmwit> Oy, that's the second time I've missed the shift key today. =(
16:16:13 <chessguy> ?hoogle lookup
16:16:14 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
16:16:15 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
16:16:15 <lambdabot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
16:17:09 <chessguy> ?src lookup
16:17:10 <lambdabot> lookup _key []          =  Nothing
16:17:10 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
16:17:10 <lambdabot>                         | otherwise = lookup key xys
16:26:16 <jcreigh> does Alec Berryman frequent this channel?
16:26:35 * jcreigh doesn't have a Real Name <-> IRC Nick translation table
16:27:58 * sorear does
16:28:06 <jcreigh> oh, really?
16:28:30 <dmwit> jcreigh: Interested in the window borders thing?
16:28:52 <jcreigh> dmwit: naw, just looking for more info the on the bugs he mentioned
16:28:58 <dmwit> o
16:29:18 <dmwit> ?where logs
16:29:19 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
16:30:01 <dmwit> jcreigh: I think he came here under the nick "alec" last time.
16:30:36 <jcreigh> ah, yes, /lastlog shows an alec talking about xmonad
16:30:46 <dons> moin
16:30:47 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
16:31:31 <sorear> Wow, google whois and /who failed me.  That doesn't happen often.
16:31:53 <jcreigh> well, nick -> real name is easy in this channel.
16:32:35 <sorear> Actually google DID tell me, I just didn't look hard enough.
16:32:46 <jcreigh> his email address is recorded in the patch, I suppose I could just *email* him. but the latency!
16:32:49 <jcreigh> :)
16:32:52 <sorear> Google "alec berryman", got to contact info:
16:32:57 <sorear>           * IRC: registered user alec on irc.oftc.net and irc.freenode.net
16:34:37 <sorear> Interesting.  Googling alec xmonad gives three results, two logs.
16:34:47 <sorear> But they aren't clog-logs.
16:34:56 <sorear> they are tuukkah's logs.
16:35:05 <ddarius> What's the first rule of Fight Club?
16:35:44 <jcreigh> has anyone else noticed that googling "xmonad" shows an insane number of hits (50,000+), but if you go through a couple pages, it drops down to 55?
16:36:06 <sorear> @tell tuukkah congrats, your unpublicized private logs have more google juice than the either of logs lambdabot refers you to on @where logs
16:36:07 <lambdabot> Consider it noted.
16:36:31 <dmwit> Geez, xmonad's getting talked about?
16:36:40 <sorear> jcreigh: not specifically, but google's hit counts are renouned for their inaccurracy
16:37:15 <jcreigh> we're talking three orders of magnitude. seems like a big margin to me.
16:37:21 <dons> jcreigh: yeah, google's predicting great things for xmonad
16:37:26 <jcreigh> heh
16:37:38 <dons> there was exactly 3 hits when we changed the name to xmonad.
16:37:50 <jcreigh> Skynet has approved of our efforts.
16:37:59 <jcreigh> really? What were they?
16:39:50 <chessguy> ?seen tuukkah
16:39:51 <lambdabot> tuukkah is in #happs and #haskell. I last heard tuukkah speak 3d 9h 10m 13s ago.
16:41:07 <dons> X was a monad used in epigram somewhere.
16:41:11 <dons> so you got hits on that src file
16:41:20 <sorear> Optimization is soo fun. I've spent most of the day poking randomly at Builder while running a benchmark script.
16:47:49 <sjanssen> jcreigh: yes, Alec Berryman == alec.  He's told me that he isn't on IRC often
16:49:53 <dons> the restart feature is cool
16:49:56 <dons> no logging out of X.
16:50:10 <sorear> everything xmonad is cool.
16:50:15 <Igloo> Don't all window managers do that?
16:50:17 <dons> ah, but you lose state
16:50:27 <dons> some do
16:50:40 <sorear> Igloo: fvwm did it, I don't recall ion3 doing it
16:50:49 <dons> vertical mode looks good, sjanssen
16:50:57 <sorear> (but then ion3 did half a gazilion other things I never knew)
16:50:59 <sjanssen> dons: thank jcreigh!
16:51:06 <dons> jcreigh++
16:51:11 <sjanssen> it's like 4 lines of code in all
16:51:11 <sorear> Xmonad is sooo much better documented than ion3.
16:51:40 <sorear> ion3 is complicated.  LoC is bad, user brain cell consumption is worse.
16:51:50 <dons> nice . that's exactly what we wanted, sjanssen
16:51:51 <sjanssen> ion3 is just a little bit too configurable
16:52:12 <sorear> I'll probably miss general splitting, but not having to think about directions and tab order etc - priceless
16:53:15 <Excedrin> is there a convenient way to build a UArray Int Int16 at compile time? I'm currently using listArray...
16:53:47 <Excedrin> I suspect that building the array might be deferred to runtime, but I have no idea how to check
16:53:58 <Igloo> To do it at compile time you'd probably have to make a ByteArray (or similar) and cast it
16:53:59 <sorear> I'm pretty sure it IS
16:54:24 <kc5tja> sorear: Are you active in the development of yi at all?  What is the current status of that package?
16:54:36 <sorear> I'd recommend starting with an unboxed string literal "\000\001..."#
16:54:46 <sorear> kc5tja: Not anymore, and no clue.
16:54:54 <sorear> kc5tja: I wrote the syntax highlighting.
16:55:03 <chessguy> > 1 `shiftL` 3
16:55:04 <lambdabot>  Add a type signature
16:55:08 <chessguy> > 1 `shiftL` 3 :: Int
16:55:10 <lambdabot>  8
16:55:21 <kc5tja> sorear: Hmm...  Thanks.
16:55:52 <sorear> kc5tja: judging from jyp's latest patches, it should be a lot more like emacs now - M-S-: <type haskell code>
16:56:10 <sorear> it embeds ghci
16:57:16 <Excedrin> sorear: are those octal constants?
16:57:33 <Excedrin> oh, guess not
16:58:09 <dmwit> > ord 'a'
16:58:10 <lambdabot>  97
16:58:13 <thedward> I haven't really used a minimalistic window manager before xmonad, but after the effort I went through to make it go I felt obligated to try it for awhile. I'm really liking it.
16:58:29 <dmwit> > '\057'
16:58:31 <lambdabot>  '9'
16:58:49 <thedward> @hoogle octal
16:58:50 <lambdabot> Text.ParserCombinators.Parsec.Token.octal :: TokenParser st -> CharParser st Integer
16:59:03 <dmwit> > chr 87
16:59:04 <lambdabot>  'W'
16:59:15 <dmwit> > ord '9'
16:59:17 <lambdabot>  57
16:59:21 <dmwit> o
16:59:32 <kc5tja> > '\255'
16:59:33 <lambdabot>  '\255'
16:59:34 <dmwit> > '\097'
16:59:36 <lambdabot>  'a'
16:59:44 <kc5tja> Definitely decimal.
16:59:50 <kc5tja> > '\0377'
16:59:51 <lambdabot>  '\377'
16:59:52 <dmwit> thedward: Great!
17:00:17 <sorear> Excedrin: however, ""# gives you an Addr#
17:00:22 <kc5tja> xmonad is definitely my preferred window manager at this point in time.
17:00:36 <Excedrin> what's an Addr# ?
17:00:41 <sorear> Excedrin: but to build an (IOU)Array you need a MutableByteArray#
17:00:43 <kc5tja> What I like is its hackability.  It's relatively easy to customize.  One of the few WMs I can actually understand.
17:00:45 <thedward> I've even switched over to using conkeror for browsing. So I hardly have to touch the trackball.
17:00:49 <dmwit> kc5tja: I take it you never used dwm...?
17:00:52 <sorear> Excedrin: glascow primitive type
17:00:56 <kc5tja> In fact, come to think of it, the ONLY wm I can understand currently.
17:01:11 <kc5tja> dmwit: No, never used dwm.  But I'm going to use it here at work when I get the spare moment.
17:01:29 <Excedrin> I don't need the IO part at all, it's just a big constant immutable array
17:01:37 <kc5tja> Although, I'm thinking of maybe getting xmonad to run here as well.
17:01:38 <dmwit> (Personally, I would still prefer dwm if I wasn't interested in xmonad for its Haskell-ness.)
17:01:39 <sorear> Excedrin: oh?  great!
17:01:51 <kc5tja> Why so?
17:02:01 <dmwit> I really miss a status bar and a floating mode.
17:02:12 <dmwit> I want to be able to look at the corner and see the time!
17:02:13 <dmwit> =P
17:02:17 <kc5tja> I *am* seriously considering hacking dmenu to accept pastes from the cut buffer though.
17:02:18 <chessguy> > let lsb 0 = 0; lsb b | b .&. 1 /= 0 = 1; lsb b = 1 + lsb (b `shiftR` 1) in lsb 8 :: Int
17:02:19 <lambdabot>  Add a type signature
17:02:40 <dmwit> kc5tja: For what?
17:02:40 * kc5tja would like the ability to use ALT-P "firefox" *paste* to quickly get to a URL.
17:02:41 <sorear> Excedrin: I don't think it'll be easy to build the UArray though - ByteArray# needs a 8 byte object header, and persuading GHC to build one before a string literal will Not Be Fun.
17:02:43 <chessguy> > let lsb 0 = 0; lsb b | b .&. 1 /= 0 = 1; lsb b = 1 + lsb (b `shiftR` 1) in (lsb 8) :: Int
17:02:44 <lambdabot>  Add a type signature
17:03:00 * sorear checks the UArray source code
17:03:13 <kc5tja> dmwit: You seem to be really "into" dwm -- is this your software?  (Just curious)
17:03:25 <dmwit> Nope, I just like it a lot.
17:03:28 <kc5tja> Ahh
17:03:49 <sorear> drat, UArray is ByteArray#
17:04:06 <Excedrin> sorear: if I can get indexed reads from an, Addr#, that'd be fine
17:04:20 <sorear> Excedrin: sure
17:04:24 <sorear> @docs GHC.Prim
17:04:25 <lambdabot> GHC.Prim not available
17:04:35 <sorear> lambdabot: that module exists!
17:05:04 <sorear>    indexInt16OffAddr# :: Addr# -> Int# -> Int#
17:05:48 <sorear> You are heartily encouraged to write a wrapper for that rather than pollute your logic with unboxed types.
17:06:16 <Excedrin> so, that takes an Int16 index and returns the Int16 at that offset in the Addr#?
17:06:34 <sorear> right.
17:06:40 <sorear> an Addr is just a C pointer
17:06:44 <Excedrin> thanks!
17:06:56 <sorear> so indexInt16OffAddr# x y  ===  ((int16_t *) x)[y]
17:07:04 <sorear> addr#s are untyped :)
17:07:16 <dons> kc5tja: yes, dmenu hacks are exactly how i'd like to do the statusbar
17:07:27 <dons> just accepting text from stdin would be enough
17:07:35 <kc5tja> I wasn't paying attention -- what status bar are you referring to?
17:07:50 <dons> " kc5tja> I *am* seriously considering hacking dmenu"
17:07:59 <dmwit> kc5tja: Just a bar that would display which workspace was current, what window was focused, the time, etc.
17:08:17 <dons> dmwit: right, so the current window manager state is dumped to stderr currently
17:08:28 <dons> you just need to take that, pretty print it, and feed it to dmenu-hack
17:08:28 <syntaxfree> I'm about to criticizie the american system of public education in #haskell-blah.
17:08:34 <syntaxfree> All bored people please proceed there.
17:08:40 <kc5tja> I was discussing with some folks on the #GoboLinux channel earlier today the possibility of adding an "ARexx port"-like concept to a POSIX environment.
17:08:55 <kc5tja> This would be a nearly ideal application of this.
17:09:09 <dons> i will be preparing coffee in the #kitchen, if anyone thirsty would like to meet me there.
17:09:11 <kc5tja> Although, I'm curious -- how would stuff be input via stdin?
17:09:23 <dons> dmenu would read from stdin, no?
17:09:26 <kc5tja> Are you just going to use popen to launch the status bar?
17:09:39 <dons> xmonad | statsubar ?
17:10:14 <kc5tja> That's an intriguing concept, using pipelines to create an IPC "bus" between applications.
17:10:25 <kc5tja> That *IS* very MGR and 8.5 like.  :)
17:10:39 <syntaxfree> @quote concept
17:10:40 <lambdabot> No quotes match. Do you think like you type?
17:10:48 <syntaxfree> @quote intriguing
17:10:48 <dons> seems unixy to me.
17:10:49 <lambdabot> No quotes match. I've seen penguins that can type better than that.
17:10:50 <dons> :-)
17:11:13 <kc5tja> syntaxfree: o_O?
17:11:20 <kc5tja> What are you trying to do?  :)
17:11:26 <syntaxfree> @quote o_O
17:11:27 <lambdabot> No quotes match. Where did you learn to type?
17:11:35 <syntaxfree> I just like to find funny quotes.
17:11:37 <monochrom> It's very natural for me to use some kind of serial message queue between two processes.
17:11:38 <dons> i think he's trying to haxor the quotes
17:11:39 <kc5tja> Ahh hehe :)
17:11:40 <syntaxfree> @quote funny
17:11:41 <lambdabot> edwardk says: heh i should probably just type up the problem specification in haskell and click compile. funny how that seems to yield the answer ;)
17:11:55 <monochrom> @quote quote
17:11:56 <lambdabot> lambdabot says: @quote lambdabot
17:12:06 <syntaxfree> @quote monochrom
17:12:07 <lambdabot> monochrom says: These 113 blogging accounts of course don't cost me.  But I still get the feeling of lying around with 113 prostitutes... XD
17:12:09 <dmwit> ?quote lambdabot
17:12:10 <lambdabot> lambdabot says: tERmIN473d
17:12:15 <monochrom> I've stumbled on a gold mine!
17:12:27 <chessguy> @quote skynet
17:12:28 <lambdabot> dons says: note down this date, people, 13-09-2006. today lambdabot == skynet
17:12:34 <dmwit> ?quote quote
17:12:35 <lambdabot> lambdabot says: <dmwit> ?quote ?quote <lambdabot> Plugin `quote' failed with: IRCRaised regex failed: (ReturnCode 13,"repetition-operator operand invalid")
17:12:49 <chessguy> @load chessguy
17:12:49 <lambdabot> Plugin `dummy' failed with: IRCRaised Prelude.read: no parse
17:12:58 <dmwit> Mernt?
17:13:15 <sorear> @google skynet
17:13:16 <lambdabot> http://en.wikipedia.org/wiki/Skynet
17:13:17 <lambdabot> Title: Skynet (disambiguation) - Wikipedia, the free encyclopedia
17:13:18 <monochrom> The skynet has been very generous to me! It hasn't eliminated me yet.
17:13:24 <syntaxfree> @. google quote
17:13:27 <lambdabot> http://tunes.org/~nef/logs/scheme/06.09.07
17:13:30 <dmwit> =P
17:13:45 <syntaxfree> @. quote . google . quote
17:13:47 <lambdabot> No quotes for this person. I feel much better now.
17:14:20 <dmwit> ?. elite quote
17:14:21 <lambdabot> dESRT S4YS: /\/\AN... T|-|3rE's t|-|IS W|-|OlE D4RK SIDE TO haSKELL 7Ha+ Dr. K4h| dIDN'7 +EACh us iN 3303
17:14:36 <chessguy> @type let lsb 0 = 0; lsb b | b .&. 1 /= 0 = 1; lsb b = 1 + lsb (b `shiftR` 1) in lsb
17:14:38 <lambdabot> forall t t1. (Bits t, Num t1) => t -> t1
17:15:20 <chessguy> @type let lsb 0 = 0; lsb b | b .&. 1 /= 0 = 1; lsb b = 1 + lsb (b `shiftR` 1) in fromIntegral lsb 8
17:15:22 <lambdabot>     No instance for (Integral (t -> t1))
17:15:23 <lambdabot>       arising from use of `fromIntegral' at <interactive>:1:75-92
17:15:34 <chessguy> let lsb 0 = 0; lsb b | b .&. 1 /= 0 = 1; lsb b = 1 + lsb (b `shiftR` 1) in fromIntegral $ lsb 8
17:15:36 <chessguy> . let lsb 0 = 0; lsb b | b .&. 1 /= 0 = 1; lsb b = 1 + lsb (b `shiftR` 1) in fromIntegral $ lsb 8
17:15:42 <chessguy> ugh, i can't type
17:15:49 <chessguy> > let lsb 0 = 0; lsb b | b .&. 1 /= 0 = 1; lsb b = 1 + lsb (b `shiftR` 1) in fromIntegral $ lsb 8
17:15:50 <lambdabot>  Add a type signature
17:16:01 * syntaxfree has a headache from trying to decipher that code.
17:16:05 <syntaxfree> @quote headache
17:16:05 <lambdabot> fax-- says: I wake up with a headache because of you, haskell
17:16:21 <dolio> @quote perl
17:16:21 <syntaxfree> one line guards suck.
17:16:22 <chessguy> syntaxfree: lsb = least significant bit
17:16:22 <lambdabot> qwe1234 says: it's 2006 already, and the world doesn't need 'dynamic languages'. otherwise, we'd be all programming in perl.
17:16:33 <syntaxfree> yes. it's the inline guard that killed my head.
17:16:49 <syntaxfree> @quote haskell
17:16:50 <lambdabot> lispy says: one thing that's funny about programming in haskell is, it's the only language i know where i sometimes rewrite code so it will work on 'inifinite' datastructures
17:16:55 <chessguy> anyway, is there a more efficient way to do this?
17:17:17 <monochrom> Though your head is killed, you still have a tail.
17:17:39 * syntaxfree kills monochrom.
17:17:42 <monochrom> haha
17:17:49 <syntaxfree> @quote death
17:17:50 <lambdabot> bd_ says: [SamB_XP] what is this "release" thing anyway? [bd_] SamB_XP: it's when you disown a project [SamB_XP] bd_: why would I want to do that? [bd_] Well, for example, in case of death.
17:17:59 <syntaxfree> @quote death
17:17:59 <lambdabot> bd_ says: [SamB_XP] what is this "release" thing anyway? [bd_] SamB_XP: it's when you disown a project [SamB_XP] bd_: why would I want to do that? [bd_] Well, for example, in case of death.
17:18:40 <chessguy> hey syntaxfree, i haven't seen any cool blogs on statistics lately. what'
17:18:48 <chessguy> what's the deal?
17:19:35 <chessguy> @quote stat
17:19:35 <lambdabot> qwe1234 says: the lisp folks have purposefully made lisp so that static analysis is impossible.
17:19:46 <sorear> chessguy: hack the compiler
17:19:55 <dmwit> ?keal
17:19:56 <lambdabot> primary elemental assumption of integer coefficients to roots in counting sytem is wrong
17:20:04 <syntaxfree> chessguy: oh. I'm not really hacking on anything lately.
17:20:05 <chessguy> sorear: ?
17:20:18 <dmwit> ?keal
17:20:19 <lambdabot> i aint running that on my puter
17:20:26 <syntaxfree> I haven't been publishing any of my usual programming rants either.
17:20:36 <sorear> chessguy: add an inline PrimOp for __asm__("bsfr $1, $0" : "=g" (out) : "g" (in))
17:21:00 <chessguy> sorear: are you talking about my lsb?
17:21:17 <sorear> yes, except I typoed the opcode
17:21:23 <sorear> it should be bsrl
17:21:54 * sorear wishes haskell had CODE words that didn't require hacking GHC
17:22:07 <sorear> foreign import cmm or something
17:22:10 <kc5tja> syntaxfree: Ditto -- I got into a rather heated debate in #Gobo today because of something I feel rather strongly about.
17:22:11 <chessguy> ah. well, i don't really want to hack the compiler for that. just seems strange that i can find the msb in log n time, but the lsb takes linear time
17:22:28 <syntaxfree> I used to go to the same school Hirscham goes.
17:22:35 <syntaxfree> Gobo's Hirscham Muhammad.
17:22:45 <kc5tja> syntaxfree: Sorry, wrong Gobo.
17:22:47 <kc5tja> GoboLinux
17:22:53 <sorear> chessguy: you can use the same trick for LSB and MSB
17:23:01 <syntaxfree> yes, yes.
17:23:16 <chessguy> oh really?
17:23:41 <sorear> chessguy: sure
17:23:50 <syntaxfree> Linux STandard Base and... Macintosh STandard Base.
17:23:53 <chessguy> ugh, my brain is refusing to see it
17:24:30 <ddarius> chessguy: That's because your brain is not your eyes.
17:25:23 <sorear> lsb8 x | x .&. 0xF == 0 = 4 + lsb8 (x `shiftR` 4)
17:25:23 <sorear>        | x .&. 0x3 == 0 = 2 + lsb8 (x `shiftR` 2)
17:25:23 <sorear>        | otherwise      = x - 1 {- 0 or 1 -}
17:25:35 <sorear> add more cases as needed.
17:26:00 <chessguy> thanks
17:26:20 <sorear> aside: annoying that -fvia-C doesn't let you foreign import macros!
17:26:34 <dcoutts> arcatan: yes very bad things will happen if you call gtk from multiple OS threads (ie if you're using the -threaded runtime system) to run a command and not wait for it to finnish use System.Process rather than System.Cmd
17:27:05 <sorear> dcoutts: I'm pretty sure he was talking about ghci, not gtk
17:28:02 <chessguy> @pl \b -> m b 0
17:28:03 <lambdabot> flip m 0
17:28:17 <dcoutts> sorear: [23:32] <arcatan> I wonder what those bad things are which are going to happen if I call Gtk from multiple threads
17:30:46 <sorear> macros of the #define lsb(x) ({ int ret; int in=x; asm("bsfl %1, %0" : "=r" (in) : "rm" (ret)); ret }) form
17:31:02 <sorear> dcoutts: oh, sorry, thought you were referring to the ghci/threads post
17:31:33 <dcoutts> np
17:32:30 <dmwit> :t set
17:32:33 <lambdabot> Not in scope: `set'
17:40:08 <procyon112> sorear: C macros have no external bindings.  They exist as inline source code transformations only.  There would be no way to link to them.
17:41:12 <sorear> procyon112: and why do we need to link to them?
17:41:27 <sorear> procyon112: I'm using -fvia-C, and I import a header file
17:41:51 <sorear> er, include.
17:41:58 <procyon112> ah.. nm then ;)  never used -fvia-C
17:42:05 <sorear> so annoying that gcc accept that as an "extension:
17:49:13 <ponch666> +tnc
17:49:34 <ponch666> can you help me?
17:50:23 <dmead> whats a +tn
17:50:23 <dmead> c
17:50:32 <Igloo> It's the channel modes
17:50:38 <sorear> Topiclock + Nooutsidensgs + stripColors
17:50:46 <dmead> mhmm
17:50:52 <sorear> try setting the topic - you can't, you're not an op
17:51:01 <dmead> i'm aware xD
17:51:06 <sorear> try /part ing and spamming the channel - you cna't
17:51:17 <dmead> ponch666: what do you need help with?
17:51:21 <stepcut> hrm, are you supposed to be able to do this:
17:51:21 <stepcut> import Module1 as M
17:51:21 <stepcut> import Module2 as M
17:51:23 <ponch666> help me please
17:51:26 <sorear> stepcut: yes!
17:51:30 <Igloo> stepcut: Yup
17:51:30 <sorear> ponch666: no
17:51:32 <dons> stepcut: yep.
17:51:36 <sorear> ponch666: we can't
17:51:41 <ponch666> i can't undertand why i'm in this channel
17:51:51 <mauke> haha
17:51:51 <monochrom> /leave #haskell
17:51:54 <monochrom> try that
17:52:00 <ponch666> i don't have my usualy list
17:52:04 --- mode: ChanServ set +o dons
17:52:06 <stepcut> ok, I think -W might be broken then. It complains that I am not using anything from the Module1 when I do that
17:52:09 <ponch666> sorry my enlgish
17:52:10 --- kick: ponch666 was kicked by dons (dons)
17:52:12 --- mode: ChanServ set -o dons
17:52:20 * stepcut investigates further to confirm
17:52:20 <dons> saves him having to type /quit
17:52:24 <dmead> haha
17:52:36 <dmead> hi
17:52:38 <dmead> <3
17:52:41 <dons> interesting.
17:52:52 <monochrom> now you know what a liar is.
17:52:52 <sorear> you're back!
17:53:03 <Igloo> Maybe it is like those punchbags they have in boxing places
17:53:06 <procyon112> missed you
17:53:59 <ponch666> the name in my options in server was change
17:54:19 <dons> do you have a question about Haskell?
17:54:35 --- mode: ChanServ set +o Igloo
17:54:56 <ponch666> can you help?
17:54:59 --- mode: Igloo set +b *!*@host30-17-dynamic.56-82-r.retail.telecomitalia.it
17:55:02 --- kick: ponch666 was kicked by Igloo (Igloo)
17:57:39 <sorear> dons: are lazy bytestrings supposed to show as LPS ["foo"...
17:57:45 <sorear> seems odd
17:57:47 --- mode: ChanServ set +o Pseudonym
17:57:54 * Pseudonym wants to do it next!~
17:57:58 <Pseudonym> Please please!
17:58:03 <Pseudonym> Everyone gets a turn!
17:58:12 <dons> sorear: it seems odd.
17:58:18 <dons> probably we'll fix that for the next release.
17:58:24 <dons> which i hope to do in hmm. 3 weeks.
17:58:28 <dons> hear that dcoutts ? ;-)
17:58:30 <Igloo> What do you want it to look like?
17:58:35 --- mode: Pseudonym set -o Pseudonym
17:58:36 <ddarius> Mit Papier?
17:58:40 <dons> fromChunks [...] maybe?
17:58:53 <Igloo> OK, I'll let you get away with that  :-)
17:58:58 <Igloo> As long as Read matches
17:59:12 <dons> Igloo: yeah. but this isn't a planned 6.6.x series change.
17:59:12 <dcoutts> well we can put it in the IsString typeclass now
17:59:20 <dcoutts> so just a string literal would do
17:59:22 <Igloo> I didn't mean for 6.6, I meant in general
17:59:35 <Igloo> I'd have whined if you wanted "..." or something
17:59:36 <sorear> The good news is my code is 3x faster than Builder!  the bad news is it gives the wrong answer :)
17:59:38 <dons> Igloo: btw, would we start by breaking fps off as per the uber-breakup plan?
17:59:54 <dons> sorear: my code is also a lot faster, return ()
17:59:55 <Igloo> dcoutts: Only for GHC
17:59:58 <dons> pity it gives the wrong answer.
18:00:08 <sorear> dons: mine as a lot more #'s :)
18:00:11 <Igloo> dcoutts: And with a rarely-used flag at that
18:00:14 <dcoutts> Igloo: erm true, ok then "pack \"...\""
18:00:25 <Igloo> dons: DYM "should"?
18:00:38 <mauke> "It's easy to get the wrong answer in O(1) time."
18:00:49 <dons> Igloo: I suppose 'should' is more appropriate.
18:00:56 <Igloo> dcoutts: Is that lazy?
18:00:59 <sorear> Hah.  I can get the wrong answer in O(0) time. :)
18:01:05 <sorear> Igloo: sure
18:01:28 <dcoutts> Igloo: for lazy bytestring, yeah, it reads the list into chunks.
18:01:34 <sorear> Igloo: eg. with the invariant, we can see 7 ch of the show using only the first chunk
18:01:46 <dcoutts> Igloo: does it matter? most read/show instances are strict
18:01:47 <Igloo> dons: Hmm, I can't remember if Simon gave a deadline or not; if not then I think all the obvious people have spoken without objecting to the idea
18:02:19 <Igloo> dcoutts: Oh, true
18:02:21 <dons> yeah, I spoke with dcoutts yesterday. its unlikely anyone will object to making base smaller...
18:02:42 <dcoutts> @arr
18:02:42 <lambdabot> Yeh scurvy dog...
18:02:43 <sorear> dons: hehe. the bug was I initted a counter with 0# instead of 1#.
18:02:50 <sorear> off-by-one-bugs++
18:03:20 * Igloo wonders what we'll do for GHC 6.10. Put it and String into a string package maybe?  :-)
18:03:23 <sorear> it's still a good 3x faster than Data.Binary.Builder
18:03:37 <sorear> (on my benchmark, which uses only singleton and append)
18:04:53 <dons> Igloo: by then we'll have stripped ghc down to a lambda calculus interpreter.
18:05:00 <dons> everything else is optional packages
18:05:21 <sorear> yeah!
18:05:37 <sorear> Orphan modules exporting the simplifier in RULES format!
18:07:35 <Igloo> :-)
18:07:42 <chessguy> @go 487493 in hex
18:07:43 <lambdabot> 487,493 = 0x77045
18:08:20 <jcreigh> @go 42 in binary
18:08:21 <lambdabot> 42 = 0b101010
18:08:33 <chessguy> @go 487493 in binary
18:08:34 <lambdabot> 487,493 = 0b1110111000001000101
18:08:42 <ddarius> @google 50000 baht in USD
18:08:43 <lambdabot> 50,000 Thai baht = 1,543.13843 U.S. dollars
18:09:39 <dmwit> That's convenient.
18:09:47 <chessguy> @go 20 dollars in leu
18:09:48 <lambdabot> 20 U.S. dollars = 50.16800 Romanian leu
18:09:56 <dmwit> Also, I just wanted to pop in for a moment to say that the IO monad is a particularly nice piece of magic.
18:10:12 <chessguy> @quote magic
18:10:13 <lambdabot> bakert says: i think it's a question of where you are looking from.  from the magician's point of view no one got sawn in half and from the audience's point of view someone did and they both like it
18:10:13 <ddarius> If only it was magic.
18:10:13 <lambdabot> that way around.
18:10:41 <dons> sjanssen: patch just landed to remove 10 lines of code :-)
18:10:43 <Pseudonym> @google the speed of light in attoparsecs per millifortnight
18:10:44 <lambdabot> No Result Found.
18:10:50 <Pseudonym> @google the speed of light in attoparsecs per fortnight
18:10:52 <lambdabot> the speed of light = 1.1751994 x 10^16 attoParsecs per fortnight
18:10:52 * ddarius thinks the audience would be happy either way, the "volunteer" though...
18:10:54 <Pseudonym> Woo.
18:11:19 <SamB_XP> woah
18:11:23 <SamB_XP> when did they add that?
18:11:33 <ddarius> SamB_XP: A long while ago.
18:12:04 <SamB_XP> @google c in furlongs per fortnight
18:12:07 <lambdabot> the speed of light = 1.8026175 x 10^12 furlongs per fortnight
18:12:18 <SamB_XP> they didn't have fortnights before
18:12:27 <sorear> dcoutts: is it safe to use gtk2hs from multiple threads with -N1?  (also, confirming ghhci == ghci)
18:12:34 <dmwit> ?go fortnight in days
18:12:36 <lambdabot> 1 fortnight = 14 days
18:12:40 <ddarius> SamB_XP: The rapid pace of innovation.
18:13:50 <dons> sjanssen: oh very nice. mod-hl now resizes in whatever mode we're in. great
18:14:10 <Pseudonym> @google planck's constant in pound acres per fortnight
18:14:12 <lambdabot> Planck's constant = 4.36630561 x 10^-31 (pound acres) per fortnight
18:14:15 <SamB_XP> i.e., last time we tried a search like that we got a porn-related forum iirc
18:14:17 <sorear> what a fingermacro ... is my lazy Builder actually lazy?  I have four seconds to start top.
18:14:26 <sorear> I type  m - u - t - t - ENTER
18:15:23 <sorear> grr, not constant space...
18:15:34 <jcreigh> dons: ooh, clever. that's a nice way to get multiple records.
18:15:51 <dcoutts> sorear: no, not with the threaded rts.
18:15:56 <dons> yeah, reminds me of shift @_ from perl ;-)
18:16:11 <sorear> egads!
18:16:19 <dcoutts> sorear: -N1 is irrelevant, the threaded rts will always use multiple OS threads when it comes to making foreign calls.
18:16:32 <sorear> my driver consumes linear space with rossP's builder
18:17:01 <dcoutts> sorear: there are docs on how to do it safely, ie way of using multiple threads but arranging to always make the gui calls in one thread.
18:17:09 <dcoutts> sorear: see the concurrent demo in gtk2hs
18:17:32 <dons> sorear: can I ask what you're doing?
18:17:44 <dons> I get a bit scared by lots and lots of work, without consultation with other devs...
18:17:54 <dons> since that tends to lead to code that gets lost in the mist of time
18:19:53 <ddarius> Yay mists of time.
18:20:03 <dons> they rock.
18:21:16 <dons> ddarius: so ... are you using xmonad yet?
18:21:22 * dons tries to build critical user base
18:21:44 * jcreigh wonders about the meaning of the word "critical" is that sentence. :)
18:22:00 <dons> critical is good. :-)
18:22:09 <dmwit> Similar to "critical mass."
18:22:15 <ddarius> Um, just as soon as I (a) stop being lazy and figure out how to get wireless networking working in Linux or (b) port xmonad to Windows.
18:22:25 <dons> windows. boo.
18:22:34 <dmwit> ddarius: Use ndiswrapper. ;-)
18:22:39 <sorear> dons: actually, this code wouldn't hurt if it disappeared tomorrow, since it's mostly for self-education...
18:22:57 * sorear wants to port xmonad to linux-tty
18:23:06 <ddarius> dmwit: I am.  The hard part is done I think... hope.  I'm just lazy and unmotivated right now.
18:23:35 <TomMD> ddarius: What wireless card?
18:23:51 <ddarius> The card works.
18:27:10 <sorear> dons: found it :)  bs is a 96MB lazy bytestring:   else print (S.last b) >> print (S.length b)   yay for banana splits
18:27:10 <sorear>  
18:27:32 <dcoutts> heh
18:28:44 <dons> sjanssen: what do you think: do we defer the statusbar till after 0.1 is tagged?
18:28:58 <dons> or do we try to write one next week, in conjunction with the xmonad paper
18:29:05 <jcreigh> hmm...how do I get the border width of a window?
18:29:09 <dons> jcreigh: btw, you interested in helping with the xmonad paper for TMR?
18:29:10 <sorear> xmonad paper!?
18:29:17 <dons> for TMR
18:29:19 <sorear> jcreigh: XGetWindowAttributes?
18:29:26 <sorear> Ah, good.
18:29:38 <sorear> I was thinking gets-into-citeseer-paper :)
18:29:42 <jcreigh> there doesn't seem to be a getWindowAttributes defined...
18:29:51 <dons> sorear: I don't think there's enough novel stuff to do that.
18:30:16 <dons> its really just a standard haskell app, with ffi bits.
18:30:16 <sorear> hence the !?
18:30:26 <jcreigh> dons: sorry, probably not; writing is like work.
18:30:31 <dons> sorear: yi on the other hand... on top of ghc-api
18:30:38 <dcoutts> yummy
18:30:43 <dons> jcreigh: we may bug you about xinerama details..
18:30:56 <dcoutts> dons: you're not supposed to be thinking about that paper!
18:30:59 * dcoutts prods dons
18:31:01 <dcoutts> ;-)
18:31:10 <dons> ah yes. there are other papers to consider!
18:31:26 <dcoutts> deadlines deadlines deadlines
18:31:49 * dons gulps some more caffeine and heads to the office
18:31:54 <sorear> something for icfp?
18:32:31 <thedward> If I wanted to write a program that generated haskell code, would it make sense to use Language.Haskell.Syntax to build it, then output it with Language.Haskell.Pretty?
18:32:35 <dons> secret world domination schemes must be prepared
18:32:46 <dons> thedward: yeah, if its h98-ish
18:33:02 <dons> or perhaps hsx, the extended parser/ppr which supports a few newer syntactic forms
18:33:05 <sorear> thedward: it would, but I don't recommend using L.H.S, it's not a programmer friendly type
18:33:15 <dons> sorear: there's a job for you: full standalone ghc parser/prettyprinter library..
18:33:22 <sorear> dons: we have it
18:33:26 * thedward nods.
18:33:27 <sorear> dons: template-haskell
18:33:31 <dons> nah
18:33:45 <sorear> dons: a few portability fixed are needed (Int# anyone?)
18:33:48 <dons> that's different, though there's overlap.
18:34:29 <thedward> sorear: you'd recommend template haskell for that sort of thing?
18:34:30 <sorear> OK, my program is lazy again :)
18:34:40 <sorear> thedward: sure, we use it in derive
18:34:56 <sorear> thedward: with a few wrapper combinators
18:35:13 <metaperl> anyone have alink to ICFP 2007 programming contest?
18:35:22 <sorear> thedward: also, the stock TH ppr is *very* broken
18:35:47 <sorear> you can get a couple patches that make it work from the libraries@ archive
18:35:49 <thedward> oh. well, that would be less useful then.
18:35:57 <thedward> hmm.
18:37:01 * sorear checks if the $TH_MAINTAINER has applied
18:37:15 <thedward> I'll take a look at it and see if I can figure it out. L.H.S. does seem kind of unwieldy, but perfectly understandable.
18:37:18 <boowax> I'm having an issue getting something to compile. I don't understand why I can't call a function that has a return type different from the containing function. http://hpaste.org/1245#a0
18:37:51 <sorear> thedward: TH.Syntax is very understandable IMO
18:38:00 <ddarius> www.icfpcontest.com
18:38:08 <sorear> thedward: you don't have to use the arcane quaziquoting features...
18:38:23 <sorear> oh well my patches still haven't been applied.
18:38:30 <thedward> sorear: heh, yeah that is what I was mulling over.
18:38:34 <ddarius> http://www.icfpcontest.org
18:38:37 <lambdabot> Title: ICFP Programming Contest 2007
18:38:45 <sorear> derive has a copied, fixed, Data.Derive.FixedPpr
18:39:20 <jcreigh> hmm, it appears that X11-extras doesn't yet export an interface to "border_width" in XWindowAttributes.
18:39:43 <thedward> thanks for the pointer. I'm going to go dive into docs now.
18:39:58 <sorear> @where derive
18:39:58 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/derive
18:43:19 * SamB_XP wonders why IDA is using 70% CPU, but won't respond to input...
18:43:20 <sorear> @where binary
18:43:20 <lambdabot> http://darcs.haskell.org/binary
18:43:50 <boowax> Can anyone here help me? or is there a separate channel for this kind of thing?
18:43:56 <monochrom> I'm gonna dive / into the doc of derive / But fingers I only got five / I can't code and drive
18:43:58 * SamB_XP wishes he had a DOS debugger that worked with ntvdm
18:45:28 <sorear> boowax: ouch! that looks like GHC-proper naming conventions
18:46:34 <sorear> boowax: why are you using the list-monad?
18:46:46 <Cale> boowax: I'll have a look
18:46:47 <boowax> I'm a bit new to Haskell (though not new to programming)
18:46:56 <boowax> thanks guys
18:47:35 <hpaste>  sorear annotated "type problem" with "no need for do here" at http://hpaste.org/1245#a1
18:47:39 <Cale> do { return (t2:[]) } -- the type of this would be  m [Type], I think
18:47:43 <Cale> for some monad m
18:48:12 <Cale> But you just want the thing to produce a list of Type values, so TmRecType t1 t2 -> [t2] should be fine
18:48:40 <Cale> or else,   return t2
18:48:46 <Cale> which uses the fact that return x = [x] in the list monad
18:49:07 <Cale> The first case is also a little strange.
18:49:26 <Cale> do { t <- x; return t } is the same as x
18:49:57 <boowax> I didn't even know I was using a List monad! I'm just trying to return a list of Type values (as you noted)
18:50:30 <Cale> Whenever you see 'do', you're using a monad
18:50:54 <Cale> Which monad is determined by the types of the things on the right hand sides of '<-
18:50:57 <boowax> I've been having trouble getting return to accept anything more complex than variables...hence the extra temp there
18:51:01 <Cale> '<-'
18:51:15 <Cale> Why are you using return?
18:51:27 <mauke> heh. that's probably just precedence.
18:51:35 <Cale> return takes values and produces monadic computations which do nothing but return those values.
18:51:39 <mauke> return is a normal function, so return x + y is parsed as (return x) + y
18:52:49 <Cale> It could also be a problem with types, as your examples here show.
18:52:54 <boowax> I'm using return because I have a tree containing (amongst other things) the Type values, and I'm trying to recursively walk the tree and make a list of the type values
18:53:18 <mauke> huh?
18:53:25 <Cale> Okay, that's not what return is for :)
18:53:26 <dmwit> (return is not used, as in other languages, to denote the value that should be evaluated)
18:53:32 <jcreigh> boowax: "return" lifts values into a monad. That's it. It's not like "return" in other languages.
18:53:56 <boowax> my newness to Haskell rears its head again!
18:54:10 <Cale> One thing which is probably worth pointing out is that do { x; return v; y } is the same as do { x; y }
18:54:11 <jcreigh> IMO, "return" is somewhat confusing named.
18:54:11 <boowax> how do I return values (as return would in other languages)?
18:54:18 <sorear> boowax: as you've probably heard already, IO things and non-IO things are separated in this language
18:54:27 <Cale> boowax: you probably don't want monads at all here
18:54:29 <sorear> boowax: there is no syntax, you just mention the value
18:54:33 <Cale> boowax: just write the values
18:54:35 <jcreigh> boowax: just say "f x = x * 2"
18:55:00 <hpaste>  Cale annotated "type problem" with "for example..." at http://hpaste.org/1245#a2
18:55:19 <monochrom> If you have intermediate expressions, consider "f x = let y = x+x in y+y" or "f x = y+y where y = x+x"
18:55:36 <Cale> oh, haha, sorear already did that :)
18:57:17 <syntaxfree> Text.Regex should define a (~=) operator = matchRegex . mkRegex
18:57:24 <boowax> okay, thanks for the help thus far guys!
18:57:25 <boowax> Those annotations get rid of the first error, but I'm still confused as to why I can't call makeTypeList from the other function
18:57:30 <sorear> syntaxfree: it does!
18:57:38 * Codex_ did rendering engine: http://www.kotiposti.net/terop/glass.png
18:57:44 <sorear> syntaxfree: well, one of the regex modules anyway
18:57:46 <monochrom> ~= is bad notation
18:57:47 <syntaxfree> er, ~= = isJust . matchRegex . mkRegex
18:57:47 <sorear> @index =~
18:57:48 <lambdabot> bzzt
18:57:52 <sorear> @index (=~)
18:57:53 <lambdabot> bzzt
18:58:06 <Cale> @index (~=)
18:58:07 <lambdabot> bzzt
18:58:35 <syntaxfree> (=~~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target, Monad m) => source1 -> source -> m target
18:58:41 <syntaxfree> that is *not* what I expected :P
18:59:01 <sorear> syntaxfree: it is, just more polymorphic
18:59:09 <Cale> ah, it's in Text.Regex.Posix
18:59:16 <syntaxfree> @type Data.Maybe.isJust . Text.Regex.matchRegex . Text.Regex.mkRegex
18:59:17 <sorear> syntaxfree: for instance, that type includes String -> String -> Bool
18:59:19 <lambdabot>     Couldn't match expected type `Maybe a'
18:59:19 <lambdabot>            against inferred type `String -> Maybe [String]'
19:00:03 <syntaxfree> hmm./
19:00:09 <syntaxfree> should =~ Just Work?
19:00:18 <Cale> boowax: the second function is also using the list monad -- what are you expecting the type of tmp to be?
19:00:41 <sorear> @index ByteArray
19:00:42 <lambdabot> bzzt
19:00:45 <sorear> @index BA
19:00:45 <lambdabot> bzzt
19:01:09 <Cale> boowax: also, you've given in the type signature, the return value as being ThrowsError Type
19:01:29 <Cale> but makeTypeList is going to give a list, not a ThrowsError a
19:01:34 <boowax> Cale: It should be a list of Type values that I want to use within the dummyFunction but not necessarily return
19:01:56 <Cale> okay, so you probably want let, and not <-
19:02:03 <Cale> let tmp = makeTypeList t tenv
19:02:14 <Cale> throwError $ EICE (show tmp)
19:02:22 <Cale> return TyBrokenRecord
19:02:45 <Cale> also, might be a good idea to avoid putting tabs in your source files.
19:03:02 <Cale> (get your editor to convert them to spaces)
19:06:45 <syntaxfree> significant whitespace is such a mixed blessing.
19:06:59 <syntaxfree> my first attempts at haskell barfed not because of types, but of indenting.
19:07:16 <syntaxfree> of course, it was the horrible, contrived example of recursive IO in YAHT.
19:07:21 <syntaxfree> The "age-guesser" program.
19:08:10 <boowax> Cale: I appreciate your help. I hope you can bear with my ignorance. Do I still need the do {} with the let statement? If you don't mind, I don't really understand what let give me?
19:09:07 <Cale> Okay. That was intended as a let statement in the do-block.
19:09:14 <Cale> I'm assuming that ThrowsError is a monad.
19:10:03 <Cale> In fact, based on the error you're getting from the compiler, ThrowsError seems like a type synonym for Either ErrorTy
19:10:21 * syntaxfree has become obsessed with spotting Arial and Helvetica, speaking of type.
19:10:23 <Cale> There are two forms for let in Haskell
19:10:42 <syntaxfree> now I stare at signs from way too close.
19:10:47 <Cale> As an expression, you can write:  let <decls> in <expr>
19:11:02 <syntaxfree> I got myself a headache trying to tell Arial from Helvetica on this stupid college zine while on a moving bus that was shaking.
19:11:19 <Cale> In a do-block, you're allowed to leave off the 'in' part, and the declarations will scope over the remainder of the 'do'
19:11:21 <Cale> That is...
19:11:24 <boowax> Cale: ThrowsError is basically what you said it was...to allow errors to go up the chain or normal returns to happen
19:12:02 <Cale> do { <stmts1>; let <decls>; <stmts2> } = do { <stmts1>; let <decls> in do { <stmts2> } }
19:12:54 <Cale> <decls> is a bunch of local declarations of values you want to define.
19:13:03 <Cale> For example...
19:13:09 <Cale> > let x = 5 in x + x
19:13:10 <lambdabot>  10
19:13:30 <Cale> > do { x <- [1..10]; let y = x^2; return y }
19:13:31 <lambdabot>  Parse error
19:13:38 <Cale> > do { x <- [1..10]; let {y = x^2}; return y }
19:13:40 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
19:13:59 <Cale> (normally layout handles the braces)
19:15:21 <Cale> That's the list monad. In the list monad, <- acts as a way to select values from lists.
19:16:13 <Cale> In your ThrowsError monad, <- will run other computations which may throw errors, and make sure that the rest of the computation is dropped if an error is thrown.
19:17:03 <Cale> That is, if x succeeds, then v <- x will result in v being bound to whatever x returned, and if x fails, the computation won't continue.
19:18:18 <Cale> Whereas if you were to write  let v = x, in this case, v would either be of the form Left e, for some error e, or Right r, if it succeeds with a return value.
19:18:18 <boowax> Cale: Okay. A lot of this makes more sense now. I've even got it compiling and working as expected now. Thanks so much. (I'm going to be around though, to hopefully learn more and I may run into my ignorance again)
19:18:27 <Cale> boowax: great :)
19:19:05 <Cale> In general, let v = x will simply define v to be the same computation as x without "running" it.
19:19:31 <Cale> Whereas v <- x will "run" x to produce the result v.
19:33:57 <sjanssen> dons: yeah, I think statusbar can wait until 0.2
19:35:43 <syntaxfree> @undo v<-x
19:35:44 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 2}) "Parse error"
19:35:51 <syntaxfree> @undo do { v<-x; }
19:35:52 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 12}) "Parse error"
19:35:58 <syntaxfree> boowax: @undo is your friend.
19:36:05 <syntaxfree> @undo do { v<-x; return v}
19:36:06 <lambdabot> x >>= \ v -> return v
19:36:58 <Excedrin> can't that be simplified further?
19:37:48 <sjanssen> undo doesn't do any simplification
19:37:59 <chessguy> @pl x >>= \v -> return v
19:38:00 <lambdabot> x
19:38:02 <Cale> actually, that is simplified
19:38:20 <Cale> relative to what the report says that should desugar to
19:38:39 <sjanssen> but the case expression is useless in this example
19:38:43 <Cale> @undo do { (v:vs) <- x; return (v:vs) }
19:38:44 <lambdabot> x >>= \ a -> case a of { (v : vs) -> return (v : vs); _ -> fail ""}
19:38:52 <sjanssen> @undo do {1 <- x; return ()}
19:38:53 <lambdabot> x >>= \ a -> case a of { 1 -> return (); _ -> fail ""}
19:59:03 <dons> sjanssen: ok.
20:01:40 <sioraiocht> anyone ever used haskore?
20:02:44 <sorear> Cale learned (of) Haskell through it
20:03:29 <Cale> I haven't used it for anything extensive, but I read the paper.
20:06:14 <dons> sioraiocht: yeah, classic Haskell EDSL
20:06:52 <robreim> I've been hearing a lot recently about regrets regarding haskell's default laziness. Does anybody have any links to discussions or something similar where problems with laziness are raised?
20:09:49 <dons> regrets?
20:10:00 <robreim> That's the term that was presented to me :)
20:10:09 <dons> basically, we have as much strictness as we can use now, so i'm not sure its an issue.
20:10:10 <sorear> Laziness was never a design decison of Haskell.
20:10:15 <dons> laziness (and purity) keeps us honest.
20:10:32 <sorear> No more than 'able to run on a computer' is a design decison of UNIX.
20:10:53 <sorear> Laziness is Haskell's reason for existing
20:11:21 <sorear> Haskell is a reasearch language designed to explore the consequences of type class overloading combined with laziness.
20:12:00 <dons> well... i'm not sure that's quite right. it was to explore laziness and purity.
20:12:10 <robreim> I had someone (a ocaml man) mention to me that SPJ said something to the effect that he thinks the next haskell should be strict and the next ml non-strict and something about SPJ complaining that non-strictness was too difficult to implement efficiently.
20:12:11 <dons> now its to explore FP language design, and type systems.
20:12:20 <robreim> I was wondering if there was merit in what he said.
20:12:28 <dons> robreim: probably referring to the 'hair shirt' talk (and misunderstanding it)
20:12:49 <robreim> Ah, I suspected it might be related to that
20:13:08 <dons> clearly, non-strictness can be implemented efficiently. see clean and ghc :-)
20:13:14 <jcreigh> in any case, "too difficult to implement" almost always goes away if you wait long enough.
20:13:45 <sorear> Non-strictness is hard to implement.
20:13:45 <robreim> Yeah. This guy insisted that ocaml "beats the pants" off haskell in efficiency all the time, which doesn't seem to reflect the latest shootout benchmarks...
20:13:47 <dons> but both haskell and clean are now mixed strict and lazy languages, anyway
20:13:51 * sorear quotes the number #1261
20:14:29 <jcreigh> sorear: huh?
20:14:40 <sorear> Count of ghc bugs
20:14:46 <sorear> well, tickets
20:16:55 <chessguy> sorear: still around?
20:17:21 <chessguy> ?seen sorear
20:17:22 <lambdabot> sorear is in #darcs, #haskell-overflow, #ghc, #haskell and #happs. I last heard sorear speak 2m 35s ago.
20:17:23 <sorear> yes!
20:17:40 <chessguy> i don't know why this lsb is giving me so much harder of a time than the msb did
20:17:47 <hpaste>  chessguy pasted "least-significant bit finder" at http://hpaste.org/1246
20:18:15 <chessguy> i want rightmost 0 = 0, rightmost 1 = 1, rightmost 2 = 2, rightmost 3 = 1, etc.
20:18:50 <sorear> Ooh.
20:19:08 <sorear> well, rightmost 0 = _|_ for me, you'll need another guard
20:19:26 <sorear>  lsb board a | board .&. 0xFFFFFFFF == 0 = lsb (board `shiftR` 32) (a + 32)
20:19:35 <sorear> if board is zero the first case matches!
20:19:35 <chessguy> i took care of that as a special case
20:19:45 <chessguy> right
20:19:46 <sorear> chessguy: guards are matched top to bottom
20:19:56 <chessguy> lsb 0 _ = 0
20:20:03 * sorear looks dumb
20:20:29 <chessguy> you are far from dumb
20:22:30 <sorear> chessguy: oh, there's an off-by-one bug in the final case hack
20:22:46 <sorear>              |                 otherwise = board + a
20:22:56 <sorear> should be board + a - 1
20:23:14 <sorear> also, you don't need              | board .&.          1 == 0 = lsb (board `shiftR` 1)  (a + 1)
20:23:54 <chessguy> Ok, modules loaded: Bitboards, Chess.
20:23:54 <chessguy> *Bitboards> rightmost 1
20:23:54 <chessguy> 0
20:23:57 <sorear> Er, no, *thwap*, this won't work.
20:24:45 <chessguy> yeah, i've been thwapping myself repeatedly for the past half hour
20:24:52 <sorear> we don't actually know in the final case that the high bits are zero
20:25:08 <sorear> so my clever hack is anti-clever
20:25:26 <sorear> |                 otherwise = a
20:25:32 <sorear> try that :(
20:26:35 <hpaste>  chessguy annotated "least-significant bit finder" with "you mean this?" at http://hpaste.org/1246#a1
20:28:36 <chessguy> that code still gives 0 for rightmost 1
20:28:43 <hpaste>  sorear annotated "least-significant bit finder" with "No, like this" at http://hpaste.org/1246#a2
20:29:35 <chessguy> nope
20:29:38 <chessguy> still gives 0
20:31:07 <hpaste>  sorear annotated "least-significant bit finder" with "Grr, must learn to read requests better!" at http://hpaste.org/1246#a3
20:32:16 <chessguy> aha!
20:32:20 <chessguy> that looks like it!
20:32:22 <chessguy> sorear++
20:41:16 <chessguy> @karma sorear
20:41:16 <lambdabot> sorear has a karma of 30
20:41:28 <chessguy> heh. you've probably gotten a third of that from me
20:41:56 <sorear> So far I've gotten at least -10 from bot bugs.
20:42:13 <sorear> My high water is 40, and AFAIK I've never beed --'d.
20:42:42 <chessguy> wierd
20:43:17 <chessguy> ?spell wierd
20:43:18 <lambdabot> weird weirdo weed wider wired
20:43:27 <chessguy> i can never remember which it is
20:44:54 <chessguy> @go 0xFFFFFFFFFFFFFFFF in decimal
20:44:55 <lambdabot> 0xFFFFFFFFFFFFFFFF = 1.84467441 x 10^19
20:45:13 <chessguy> > 0xFFFFFFFFFFFFFFFF :: Integer
20:45:15 <lambdabot>  18446744073709551615
20:46:49 <chessguy> hermmm
20:46:57 <chessguy> i think i actually need rightmost 1 to be 0
20:49:06 <int-e> 0x...F is odd
20:49:17 <boowax> Thanks one more time to all those who helped with the compilation problem I was having earlier! :)
20:49:19 <int-e> hmm
20:49:47 <sorear> int-e: this is suprising?
20:49:55 <sorear> ...F  === ....1111
20:50:07 <int-e> no. no, I wonder what chessguy meant
20:50:47 <int-e> ah. 'rightmost' was a function.
20:50:50 <chessguy> int-e: oh, that comment should have been directed to sorear. it wouldn't make much sense outside of the context of what he and i were working on
20:51:01 <chessguy> right
20:51:04 <chessguy> i mean, correct
20:52:40 <int-e> > let lsb x = x .&. (-x) in lsb 0x824
20:52:41 <lambdabot>  Add a type signature
20:52:55 <int-e> > let lsb x = x .&. (-x) in lsb 0x824 :: Int
20:52:56 <lambdabot>  4
20:53:25 <int-e> this gives back the bitmask of the lsb though; but it's a cute trick
20:54:45 <sorear> Now, reduce the bitmask modulo 67
20:54:46 <chessguy> hermm
20:55:31 <sorear> > [ 2^x | x <- [0..63] ]
20:55:32 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
20:55:41 <syntaxfree> > let f x y = x ++ " is " ++ y in "akamai" `f` "fucked"
20:55:41 <sorear> big unwieldy list
20:55:42 <lambdabot>  "akamai is fucked"
20:55:43 <chessguy> int-e: so your way would only have a 1 in the place of the lsb?
20:55:55 <int-e> chessguy: yes.
20:55:58 <sorear> > [ 2^x `mod` 67 | x <- [0..63] ]
20:55:59 <lambdabot>  [1,2,4,8,16,32,64,61,55,43,19,38,9,18,36,5,10,20,40,13,26,52,37,7,14,28,56,4...
20:56:12 <sorear> muahaha.
20:56:30 <sorear> as long as 67 is prime, that list of numbers is invertible
20:56:40 <syntaxfree> yes, I know.
20:56:54 <syntaxfree> for multiplication defined so that 67 is prime ;)
20:56:57 <sciolizer> But if 67 is ever not prime, you're ok?
20:57:07 <int-e> sorear: not quite, the order of 2 has to be bigger than 63
20:57:07 <sciolizer> syntaxfree: :)
20:57:31 <syntaxfree> but then again, "invertible" is defined in terms of multiplication as well.
20:57:51 <int-e> sorear: (try 71 to see what I mean)
20:58:05 <syntaxfree> int-e is right.
20:58:39 <syntaxfree> bah, the comedycentral motherload is down.
20:58:48 <syntaxfree> i wanted to watch colbert. boo hoo.
20:59:10 <Pseudonym> @remember ScottAaronson One of the best predictors of success in mathematical logic is having an umlaut in your name.
20:59:11 <lambdabot> Done.
20:59:28 <syntaxfree> .. Samuel Kripke..
20:59:41 <sorear> int-e: because 67 is prime, the order of any number is 67
20:59:41 <sorear> so we can reduce modulo a convienient prime, and then use a LUT to get the bit index
20:59:56 <Pseudonym> syntaxfree: I can find obvious counterexamples, too.
20:59:59 <int-e> sorear: 71 is prime and doesn't work
21:00:08 <Pseudonym> It's not a perfect predictor, obviously.
21:00:32 <int-e> sorear: in fact the order of any number is a divisor of phi(67)=66.
21:00:33 <sorear> Yeah, scandinavian suffixes work too!
21:00:52 <sorear> int-e: ok, what am I confused with then?
21:01:02 <Pseudonym> This is in a lecture where he mentions Gˆdel and Lˆwenheim leveral times.
21:01:15 <sorear> ssons and jers and jens
21:01:26 <sorear> all pretty successful around here ;)
21:01:28 <Pseudonym> He couldn't find a use for a mention of Martin-Lˆf.
21:01:31 <int-e> sorear: I don't know - maybe you're confusing the additive group and the multiplicative group of the ring mod 67?
21:02:02 <int-e> sorear: in any case, mod 67 does work here.
21:02:27 <sorear> I definitely seem to recall something about a case where modular exponentiation was always reversible.  Wierd.
21:02:55 <sorear> additive just seems not-right, not sure how
21:03:50 <Pseudonym> Actually, I might add that none of the interesting double-barreled names have umlauts.
21:04:05 <Pseudonym> Curry-Howard, Hindley-Milner, Girard-Reynolds...
21:04:26 <Pseudonym> Or Swedish ends.
21:04:42 <Pseudonym> Scandinavian, I guess.
21:05:00 <sorear> Meijen/Leijer are swedish too?
21:08:20 <int-e> sorear: maybe what you remember involved primitive roots?
21:08:22 * SamB_XP exits IDA before it can hang again
21:09:18 <sorear> int-e: probably not, since I don't know what those are :)
21:12:45 <sorear> For a point of reference I just rewrote my builder benchmark in C.  Bam, segfault.  Even my unsafeOuch# haskell version never did worse than return zeroed blocks :)
21:14:01 <bd_> unsafeSummonNasalDemons# :: State# NasalCavity# -> (# Demon#, State# NasalCavity# #)
21:14:48 <Pseudonym> That summons only one nasal demon.
21:14:55 <bd_> Hmm
21:14:59 <Pseudonym> It's misnamed.
21:15:01 <bd_> you have a point.
21:15:09 <Pseudonym> unsafeSummonNasalDemon# is a better name.
21:15:16 <sorear> Actually, I'm pretty sure you just summoned demons by writing that; the GHC dont-over-optimize-IO code works by looking for State# as the *first* element of an unboxed tuple return.
21:15:38 <Pseudonym> It'd also be useful if you could specify the nostril.
21:15:44 <sorear> or so the patch long description said, I havn't read the code.
21:16:01 <bd_> nasalDemons = do { demon <- Nose unsafeSummonNasalDemon#; moreDemons <- interleaveNostril nasalDemons; return (demon:moreDemons) }
21:16:41 <bd_> unsafeInterleaveNostril, even.
21:17:36 <bd_> Hm, actually, it needs to box the demon, doesn't it?
21:18:08 <Pseudonym> It returns a Demon#
21:18:11 <Pseudonym> Or...
21:18:16 <Pseudonym> No, you're right, it's in a list.
21:18:22 <bd_> well nasalDemons would be a Nose [Demon#], which is illegal, I think.
21:18:34 <bd_> data Demon = Demon# Demon#
21:19:07 <ecin> Evenin', everyone. What's a good starting tutorial for Haskell?
21:19:18 <Pseudonym> data Handbasket = HBEmpty | HBCons Demon# Handbasket
21:19:40 <procyon112> ?src get
21:19:41 <lambdabot> Source not found. That's something I cannot allow to happen.
21:19:55 <Gwern> ecin: I like the haskell wikibook myself
21:19:59 <sorear> ?src MonadState
21:20:00 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
21:20:00 <bd_> deliver :: Handbasket -> Hell -> IO () ?
21:20:11 <ecin> g
21:20:16 <Pseudonym> bd_: Is there more than one hell?
21:20:16 <ecin> Gwern: I'll give it a shot. Thanks.
21:20:22 <Pseudonym> Maybe you need to specify which circle.
21:20:22 <bd_> Pseudonym: I think this is a case where uniqueness types would be useful.
21:20:31 <sorear> Pseudonym: global variables are eval :)
21:20:59 <sorear> hmm, this IS hell we are talking about
21:21:00 <bd_> deliverToHell :: Unique Handbasket -> () :)
21:21:10 <sorear> global variables it is, then.
21:21:32 <bd_> hell = unsafePerformSin (heaven >>= fall)
21:21:35 <Pseudonym> data Hell = Limbo | Styx | Malebolge | ...
21:22:14 <bd_> newtype Hell = Hell Dynamic -- hell is what you make of it
21:22:49 <sorear> *TAG* Hell#
21:23:14 <sorear> bd_: wouldn't newtype Hell = Hell Any be better?
21:23:34 <bd_> newtype Hell = Hell () -- use unsafeCoerce#
21:23:50 <sorear> that will go to hell very quickly
21:24:09 <sorear> if you coerce a function type to () the garbage collector will explode
21:25:02 <bd_> Well, is hell a mapping between sets?
21:34:52 <dmwit> let everywhere x [] = [[x]]; everywhere x (y:ys) = (x:y:ys) : map (y:) (everywhere x ys); permutations [] = [[]]; permutations (x:xs) = permutations xs >>= everywhere x in permutations "nasal demon" !! 881
21:34:57 <dmwit> > let everywhere x [] = [[x]]; everywhere x (y:ys) = (x:y:ys) : map (y:) (everywhere x ys); permutations [] = [[]]; permutations (x:xs) = permutations xs >>= everywhere x in permutations "nasal demon" !! 881
21:34:58 <lambdabot>  "anal demons"
21:35:09 <dmwit> tee hee!
21:47:22 <procyon112> ?list
21:47:22 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
21:48:28 <procyon112> ?hoogle Int -> [a] -> [a]
21:48:29 <lambdabot> Prelude.drop :: Int -> [a] -> [a]
21:48:29 <lambdabot> Prelude.take :: Int -> [a] -> [a]
21:48:29 <lambdabot> Control.Parallel.Strategies.parBuffer :: Int -> Strategy a -> [a] -> [a]
21:48:47 <procyon112> ?hoogle [a] -> Int -> [a]
21:48:47 <lambdabot> Prelude.drop :: Int -> [a] -> [a]
21:48:48 <lambdabot> Prelude.take :: Int -> [a] -> [a]
21:48:48 <lambdabot> Control.Parallel.Strategies.parBuffer :: Int -> Strategy a -> [a] -> [a]
21:51:46 <procyon112> @seen chessguy
21:51:47 <lambdabot> I saw chessguy leaving #haskell, #ghc, #haskell-overflow, #figs, #haskell-blah and #ai 45m 29s ago, and .
21:53:25 <procyon112> So... when traversing a tree, say at each node I select a value from a list of possible values...
21:53:57 <procyon112> ^^^ leaf nodes only.. nodes all have same value
21:54:28 <araujo> hello!
21:54:32 <procyon112> And, when at another leaf, I find that, because of the values I have selected, there are no valid values to select at this leaf
21:54:58 <procyon112> So, I need to go back to the last leaf, and select a different value...
21:55:24 <procyon112> And recursively backwards, and then forwards, until I find the answer.
21:55:37 <procyon112> Kindof like "amb" in SICP.
21:55:57 <procyon112> Is there an idiomatic way to do this?
21:56:12 <sorear> list monad?
21:57:33 <procyon112> I'll hpaste for ya
21:58:12 <sorear> yeah, list monad for back-tracking
21:58:13 <sorear> @botsnack
21:58:13 <lambdabot> :)
22:00:24 <hpaste>  procyon112 pasted "Help with "amb" idiom" at http://hpaste.org/1247
22:00:57 <arcatan> dcoutts: I wasn't calling gtk from another process. Anyway, System.Process looks cleaner than System.Cmd, thank you.
22:01:09 <procyon112> ANd how do I go about this "back-tracking"?
22:03:36 <sorear> > replicateM 5 ( [0,1] )  -- pick 5 values, nondeterministically, note that the return order is that of backtracking
22:03:38 <lambdabot>  [[0,0,0,0,0],[0,0,0,0,1],[0,0,0,1,0],[0,0,0,1,1],[0,0,1,0,0],[0,0,1,0,1],[0,...
22:04:45 <sorear> one of the more bizarre facts about laziness is that a breadth first search, coded naively using lazy lists, is evaluated as a depth first search.
22:04:54 <ivanm> hey, I didn't know about replicateM, I've been looking for something like that.
22:04:55 <sorear> so we get backtracking 'for free'
22:04:57 <ivanm> thanks sorear!
22:06:34 <procyon112> ?src replicateM
22:06:34 <lambdabot> replicateM n x = sequence (replicate n x)
22:06:43 <procyon112> ?hoogle replicateM
22:06:44 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
22:06:44 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
22:06:53 <ivanm> ?srs sequence
22:06:54 <lambdabot> sequence ms = foldr k (return []) ms
22:06:54 <lambdabot>     where
22:06:54 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
22:06:59 <dmwit> ?hpaste
22:07:00 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:07:29 <sorear> > let foo {- pick K values, whose sum does not exceed S -} k s | s <= 0 = mzero   | k == 0 = return []  | otherwise = do { elt <- [2,1,0] ; rst <- foo (k-1) (s-elt) ; return (elt:rst) } in foo 10 6
22:07:31 <lambdabot>  [[2,2,1,0,0,0,0,0,0,0],[2,2,0,1,0,0,0,0,0,0],[2,2,0,0,1,0,0,0,0,0],[2,2,0,0,...
22:07:44 <sorear> @pretty let foo {- pick K values, whose sum does not exceed S -} k s | s <= 0 = mzero   | k == 0 = return []  | otherwise = do { elt <- [2,1,0] ; rst <- foo (k-1) (s-elt) ; return (elt:rst) } in foo 10 6
22:07:44 <lambdabot>  i = let foo k s
22:07:45 <lambdabot>            | s <= 0 = mzero
22:07:45 <lambdabot>            | k == 0 = return []
22:07:45 <lambdabot>            | otherwise =
22:07:45 <lambdabot>              do elt <- [2, 1, 0]
22:07:46 <lambdabot>                 rst <- foo (k - 1) (s - elt)
22:07:48 <lambdabot>                 return (elt : rst)
22:07:50 <lambdabot>        in foo 10 6
22:08:09 * sorear lets lambdabot do his code spamming :)
22:08:20 <thoughtpolice> hax
22:09:39 <hpaste>  dmwit pasted "gtk2hs: ambiguous type error" at http://hpaste.org/1248
22:09:44 <dmwit> I'm having a bit of trouble with gtk2hs.
22:09:53 <dmwit> I don't understand why this code should be a problem; any clues?
22:10:00 <procyon112> sorear: so confused....
22:10:02 <Excedrin> "Happily, GHC optimises [Int] such that we can directly index the list without dereferencing any pointers..." !!!
22:10:29 <sjanssen> Excedrin: huh?  Where is that claim?
22:10:34 <sorear> Excedrin: that code is old, evil, and obfuscated
22:10:36 <sorear> sjanssen: IOHCC
22:11:15 <Excedrin> does GHC still do that?
22:11:19 <Excedrin> sjanssen: it's from http://www.cse.unsw.edu.au/~dons/crawl/rEADME
22:11:22 <sorear> i dunno.
22:11:39 <ivanm> well, if its from dons, it _must_ be true ;-)
22:13:30 <dmwit> :t sum
22:13:33 <lambdabot> forall a. (Num a) => [a] -> a
22:13:57 <dmwit> Oy, if my problem is the monomorphism restriction again, I'm going to gry.
22:14:01 <dmwit> s/gry/cry/
22:14:07 <dmwit> ?go monomorphism restriction
22:14:09 <lambdabot> http://www.eros-os.org/pipermail/bitc-dev/2005-July/000316.html
22:14:09 <lambdabot> Title: [bitc-dev] Type Classes, Mutability, and Monomorphism
22:17:27 <Excedrin> so, which coerce do I need to go from an Int# to an Int?
22:18:04 <bd_> Excedrin: Int#
22:18:04 <bd_> >.>
22:18:08 <bd_> wait
22:18:11 <bd_> I#?
22:18:13 <bd_> One of them.
22:18:16 <Heffalump> I#
22:18:23 <Heffalump> it's a constructor, not a coercion, really
22:18:37 <Heffalump> at least that's how you use it
22:18:52 <Heffalump> and you go the other way by pattern-matching on I#
22:19:17 <Excedrin> ok, thanks
22:19:32 <narain> what do i put in my file to allow multi-parameter type classes?
22:21:03 <user317> is read defined for ByteString?  or how can i convert a bytestring to a float or an integer
22:21:44 <dmwit> Is there an idiomatic way to get around the monomorphism restriction?
22:21:57 <dcoutts> dmwit: add a type signature
22:22:06 <dmwit> dcoutts: I did... =(
22:22:07 <dcoutts> user317: no, not directly, go via a string
22:22:21 <user317> dcoutts, how do i convert a bytestring to a string?
22:22:23 <dmwit> Maybe it isn't the monomorphism restriction, then, huh?
22:22:37 <dcoutts> dmwit: then something else is wrong, adding a type sig always works for the mr
22:22:46 <dcoutts> user317: unpack
22:23:09 <hpaste>  procyon112 annotated "Help with "amb" idiom" with "The naive approach failed miserably" at http://hpaste.org/1247#a1
22:23:18 <glguy> I'm pretty sure that not studying for a big test is the best thing you can do, because when you blow it you can say "oh well, I didn't even study" and when you ace it, you can say "haha I didn't even study" :)
22:23:18 <sorear> or just ask the bot
22:23:20 <sorear> @src Int
22:23:20 <lambdabot> data Int = I# Int#
22:23:22 <sorear> lagging AGAIN?
22:23:26 <sorear> @botsnack
22:23:26 <lambdabot> :)
22:23:39 <user317> dcoutts, i dont follow you, unpack converts a bytestring to a word8 list
22:23:50 <narain> glguy: that would work for all of life's challenges, even
22:23:57 <dcoutts> user317: use Data.ByteString.Char8.unpack
22:23:59 <glguy> narain, it's quite a system
22:24:19 <dcoutts> user317: the .Char8 module give a Char rather than Word8 view on ByteStrings
22:25:56 <dmwit> Under what situations is an ambiguous type variable a real problem?
22:26:38 <dmwit> i.e. If you are writing a function that uses only functions in the class, when is it a problem to leave the exact instance of that class unspecified?
22:26:49 <narain> last time went unanswered, so i'll ask again. is there a magic line i can put in my file to enable multi-parameter type classes?
22:27:10 <narain> (rather than change the command-line options to ghc)
22:27:15 <sjanssen> show . read
22:27:19 <pirothezero> of shot chance anyone have a test tomorrow in a class they have haskell in ?
22:27:22 <pirothezero> off*
22:27:34 <glguy> {-# OPTIONS_GHC -fglasgow-exts #-} or there is probably a LANGUAGE pragma
22:27:54 <sorear> MultiParamTypeClasses
22:28:04 <dmwit> pirothezero: Probably not, why, do you?
22:28:31 <glguy> pirothezero, your grader might be around though :)
22:28:44 <pirothezero> ya, today has been a day of small world occurrences more so then other days, so I would not be surprised if i ran into a classmate in here
22:29:29 <narain> glguy: hmm, it worked. wonder why it didn't last time i tried that
22:29:40 <glguy> narain, spelling probably
22:29:52 <narain> probably. how do i use LANGUAGE pragmas?
22:30:00 <pirothezero> glguy: or my professor lol
22:31:27 <dmwit> pirothezero: What school/class teaches Haskell?  I'm jealous.
22:31:50 <sorear> {-# LANGUAGE MultiParamTypeClasses #-} as the very first line in the file
22:32:00 <hpaste>  procyon112 annotated "Help with "amb" idiom" with "Does not return other values.  mzero instead :/" at http://hpaste.org/1247#a2
22:32:23 <pirothezero> theory in programming practice at ut @ austin, professor uses it to teach a module on recursion
22:32:29 <narain> sorear: that's not working :(
22:33:34 <sorear> narain: how so?
22:34:02 <narain> it chokes on the multi-parameter type class
22:34:19 <sorear> narain: the GHC-6.6 release notes include: There is a new pragma LANGUAGE which allows extensions to be specified portably
22:34:45 <sorear> so, it's a newish feature...
22:34:48 <narain> hmm, throwing arbitrary garbage into the pragma line doesn't cause a warning
22:35:00 <narain> it's probably not reading the pragma right then
22:35:12 <sorear> narain: haskell compilers are required to ignore pragmas they do not recognize
22:35:16 <narain> ah, i have an old version of ghc
22:35:18 <procyon112> sorear:  Ok... so it's returning mzero now on failure... in your little sample backtracker, it will (nondeterministically) follow the same search path.  I'm trying to randomize the search however.
22:35:30 <narain> never mind me then
22:35:33 <narain> i should upgrade
22:36:25 <sorear> procyon112: so, basically you want an operation really_arb :: [a] -> SomeMonad a, which picks values with backtracking, but randomly permutes the list first?
22:36:43 <procyon112> yup :)
22:36:47 <sorear> procyon112: I'd go for some kind of monad-transformer then
22:36:53 <sorear> @goog ListT done right
22:36:56 <lambdabot> http://www.amazon.com/Linear-Algebra-Right-Sheldon-Axler/dp/0387982582
22:37:13 * sorear seaches
22:37:14 <procyon112> wait... I can just randomize the list... that's simpler
22:37:45 <sorear> procyon112: er, good luck randomizing it! you're in [] not IO
22:37:49 <sorear> or even State
22:38:02 <narain> bah, ubuntu's repos still have ghc 6.4.2
22:38:05 <sorear> or are you passing generators around manually?
22:38:11 <procyon112> passing manually
22:38:35 <narain> is ghc 6.4.2 reasonable or horribly old?
22:38:51 <procyon112> ok.. let's see if I can get this backtracking without randomness.  Adding randomness should be trivial.
22:38:55 <dons> its reasonable, narain
22:38:56 <dmwit> narain: It's reasonable.
22:39:12 <dons> but you could just grab a linux/x86 generic ghc 6.6 binary too...
22:39:57 <narain> hmm, let me go check the release notes for 6.6
22:43:12 <dmwit> dcoutts: Does putting a type signature solve the MR even if it contains type variables?
22:43:39 <sorear> sure!
22:43:48 <dmwit> (I'm still trying to figure out http://hpaste.org/1248 ...)
22:43:51 <sorear> > let x = 2 in (x :: Int, x :: Double)
22:43:52 <lambdabot>  Couldn't match expected type `Double' against inferred type `Int'
22:44:00 <sorear> > let x :: Num a => a; x = 2 in (x :: Int, x :: Double)
22:44:02 <lambdabot>  (2,2.0)
22:44:21 <glguy> the MR is just there to protect you from yourself
22:44:33 <glguy> it isn't a technical restriction
22:44:41 <dmwit> Well, I'm confused.
22:44:56 <sorear> and it damages valuable features of the type system :(
22:44:58 <dmwit> I don't understand why having an ambiguous type is a problem in my program.
22:45:11 <glguy> sorear, inference?
22:45:11 <procyon112> WHOA!
22:46:04 <procyon112> I just was confused!  So I was tweaking stuff, and I got it all wrong, but it typechecked, so I gave it a shot, and it was a better algorithm than I had thought of!
22:46:36 <dmwit> Isn't the point of Haskell's polymorphism system that you can do ambiguous types really easily and have everything work out okay anyway?
22:46:38 <procyon112> sorear++
22:46:42 <Excedrin> what's the syntax to export a constructor?
22:46:52 <procyon112> :t growTree
22:46:54 <lambdabot> Not in scope: `growTree'
22:47:11 <lispy> Excedrin: Foo(..)
22:47:12 <dmead> Exporing?
22:47:14 <lispy> Excedrin: i think
22:47:21 <user317> does anyone know what package bytestream is part of in the gentoo haskell overlay?
22:47:29 <sorear> base
22:47:35 <sorear> assuming it is 6.6
22:48:25 <sjanssen> byte 'stream'?
22:48:34 <sjanssen> you probably mean ByteString
22:48:39 <hpaste>  procyon112 annotated "Help with "amb" idiom" with "Returns all possible traces as a lazy list" at http://hpaste.org/1247#a3
22:48:44 <user317> yea, bytestring
22:48:53 <sjanssen> it's included with ghc 6.6
22:49:52 <user317> sjanssen, are you using gentoo's haskell overlay? the packaging is different then how its released
22:50:10 <procyon112> sorear: hmmm... but since it returns a lazy list of all permutations, there's no way to get a length in order to mix things up...
22:51:45 <sorear> procyon112: it would be better to mix it up as it is generated, with the ListT Done Right
22:51:52 <sjanssen> user317: yes, I use Gentoo.  ByteString is in base, which is packaged with ghc 6.6
22:52:20 <sorear> http://haskell.org/haskellwiki/ListT_done_right
22:52:22 <lambdabot> Title: ListT done right - HaskellWiki
22:53:09 <procyon112> sorear: ahh. I think I see now.  Randomize the list evertime it's generated...
22:53:18 <procyon112> sublist anyway
22:54:42 <procyon112> sorear: yeah.. I have to do it as it's generated.  This thing is growing superexponentially.
22:57:22 <procyon112> lengthsPerTreeDepth=[1,1,25,2183...]
23:05:25 <procyon112> is there a shuffle function for lists, like the C++ stdlib?
23:07:20 <sorear> not afaik
23:07:32 <sorear> well there is but not predefined :)
23:08:29 <procyon112> lazy would be ideal... a foldr with a StdGen that does random insertions.
23:11:58 <procyon112> ?hoogle insert
23:11:59 <lambdabot> List.insert :: Ord a => a -> [a] -> [a]
23:11:59 <lambdabot> Data.HashTable.insert :: HashTable key val -> key -> val -> IO ()
23:11:59 <lambdabot> Data.IntMap.insert :: Key -> a -> IntMap a -> IntMap a
23:20:01 <ivanm> does anyone here know how to set up mmm-mode in emacs so that it uses auctex outside of \begin{code}...\end{code} sections?
23:22:38 <sorear> Interesting - my code is slowed by ~3x when unrolling is ENabled.
23:35:36 <procyon112> ?hoogle quicksort
23:35:37 <lambdabot> No matches found
23:35:42 <procyon112> ?hoogle qsort
23:35:43 <lambdabot> No matches found
23:35:49 <procyon112> ?hoogle sort
23:35:49 <lambdabot> List.sort :: Ord a => [a] -> [a]
23:35:50 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
23:35:50 <lambdabot> System.Win32.NLS.sORTIDFROMLCID :: LCID -> SortID
23:36:04 <procyon112> ?src List.sort
23:36:04 <lambdabot> Source not found. Wrong!  You cheating scum!
23:36:11 <procyon112> ?src sort
23:36:11 <lambdabot> sort = sortBy compare
23:36:47 <procyon112> randomR (1,10) mkStdGen 20
23:36:53 <procyon112> >randomR (1,10) mkStdGen 20
23:36:55 <sorear> procyon112: the report prelude was written for clarity, GHC uses a tuned mergesort
23:37:01 <sorear> >2 + 2
23:37:03 <sorear> > 2 + 2
23:37:05 <lambdabot>  4
23:37:07 <procyon112> > randomR (1,10) mkStdGen 20
23:37:08 <lambdabot>  Couldn't match expected type `t1 -> t'
23:37:15 <procyon112> > randomR (1,10) $ mkStdGen 20
23:37:17 <lambdabot>  (4,840294 40692)
23:37:23 <ivanm> does anyone here know how to set up mmm-mode in emacs so that it uses auctex outside of \begin{code}...\end{code} sections?
23:37:40 <procyon112> ?src compare
23:37:40 <lambdabot> compare x y | x == y    = EQ
23:37:41 <lambdabot>             | x <= y    = LT
23:37:41 <lambdabot>             | otherwise = GT
23:38:17 <sorear> procyon112: actually it's a class method
23:38:20 <sorear> ?src Ord
23:38:21 <lambdabot> class  (Eq a) => Ord a  where
23:38:21 <lambdabot>     compare      :: a -> a -> Ordering
23:38:21 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
23:38:21 <lambdabot>     max, min         :: a -> a -> a
23:40:42 <procyon112> sorear: how to get a random Bool?
23:42:05 <sorear> procyon112: random
23:42:09 <sorear> @ty random
23:42:12 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
23:42:17 <sorear> @instances Random
23:42:18 <lambdabot> Couldn't find class `Random'. Try @instances-importing
23:42:26 <sorear> @instances-importing System.Random Random
23:42:28 <lambdabot> Bool, Char, Double, Float, Int, Integer
23:43:17 <procyon112> randomR (False,True) $ mkStdGen 10
23:43:21 <procyon112> > randomR (False,True) $ mkStdGen 10
23:43:23 <lambdabot>  (True,440154 40692)
23:43:41 <sorear> > fst $ random $ mkStdGen 10 :: Bool
23:43:42 <lambdabot>  True
23:49:02 <ivanm> @where shim
23:49:03 <lambdabot> http://shim.haskellco.de/trac/
23:49:13 <ivanm> how does shim compare to just using haskell-mode?
23:53:50 <procyon112> ?src sortBy
23:53:50 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
23:54:08 <procyon112> ?src insertBy
23:54:08 <lambdabot> insertBy _   x [] = [x]
23:54:09 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
23:54:09 <lambdabot>                                  GT -> y : insertBy cmp x ys'
23:54:09 <lambdabot>                                  _  -> x : ys
23:55:23 <procyon112> That looks like insertion sort, not merge sort...
23:55:51 <sorear> procyon112: @src lies
23:55:58 <procyon112> hehe
23:56:21 <sorear> procyon112: but it's semantically correct, and that's all that matters normally
23:56:25 <procyon112> I want to send a cmp function to sort that randomly returns GT or LT... is there a way??
23:57:17 <procyon112> I'm thinking: sortBy randomcmp [1,2,3] == shuffle
23:57:31 <sorear> Yes, but you shouldn't; sort is allowed to misbehave arbitrily if you pass it something intransitive
23:59:25 <hpaste>  procyon112 pasted "Shuffle a list" at http://hpaste.org/1249
23:59:34 <procyon112> ok then.. is there a pretty way to do this?
23:59:42 <dons> ?yow!
23:59:43 <lambdabot> I demand IMPUNITY!
23:59:47 <dons> are we FUSING yet!?
23:59:54 <dons> I demand FUSION!
