00:04:04 <fuzan> > otherwise == True
00:04:05 <lambdabot>  True
00:04:16 <fuzan> haha, that's how it works :)
00:04:36 <Cale> @src otherwise
00:04:36 <lambdabot> otherwise = True
00:13:11 <dmwit> > otherwise
00:13:13 <lambdabot>  True
00:18:19 <int-e> > fix $ (1:) . (1:) . map (\(x:y:_) -> x+y) . tails
00:18:20 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
00:20:07 <dmwit> > map fst $ iterate (\(a, b) -> (b, a+b)) (1, 1)
00:20:09 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
00:20:47 <igli> man that looks mad.
00:20:50 <foxy-om> @pl fix $ (1:) . (1:) . map (\(x:y:_) -> x+y) . tails
00:20:50 <lambdabot> fix ((1 :) . (1 :) . map (ap ((`ap` tail) . (. head) . (const .) . (+) . head) tail) . tails)
00:20:58 <eumenides> whoa, reading/showing is slow. i made a networked game where i pass around 2k of data every turn and it's like the server's on the other side of the world instead of next to me
00:21:39 <dmwit> Latency vs. bandwidth?
00:22:13 <dmwit> ?pl \(a, b) -> (b, a+b)
00:22:14 <lambdabot> uncurry (ap (,) . (+))
00:22:34 <foxy-om> > ap (.) 2 3
00:22:35 <lambdabot>   add an instance declaration for (Num (b -> c))
00:22:48 <foxy-om> > ap (,) 2 3
00:22:49 <lambdabot>   add an instance declaration for (Num (a -> b))
00:22:53 <dmwit> > (,) 2 3
00:22:55 <lambdabot>  (2,3)
00:23:03 <foxy-om> :)
00:23:08 <dmwit> :t ap
00:23:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
00:23:35 <igli> hmm
00:24:14 <igli> :t pl
00:24:16 <lambdabot> Not in scope: `pl'
00:24:21 <igli> heh
00:24:23 <dmwit> ?help pl
00:24:24 <foxy-om> @help pl
00:24:24 <lambdabot> pointless <expr>. Play with pointfree code.
00:24:24 <lambdabot> pointless <expr>. Play with pointfree code.
00:24:33 <igli> ty
00:24:43 <igli> @help Monad
00:24:44 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:24:48 <dmwit> ?pointfree \a -> a -- does this work?
00:24:49 <lambdabot> Unknown command, try @list
00:24:56 <dmwit> ?src Monad
00:24:56 <lambdabot> class  Monad m  where
00:24:56 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
00:24:56 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
00:24:56 <lambdabot>     return      :: a -> m a
00:24:56 <lambdabot>     fail        :: String -> m a
00:25:12 <bringert> eumenides: have you looked at the binary package?
00:25:28 <bringert> eumenides: it's seriously tuned for that sort of thing
00:25:30 <igli> is that just a h:t list?
00:25:40 <dmwit> igli: What is h:t?
00:26:02 <igli> sorry head:tail; this one doesn't look like it, an earlier one did
00:26:17 <eumenides> bringert: nope, but will do. i just barely got it working now. i'll also have to do some sort of diff against the old state so i don't send everything every turn
00:26:41 <dmwit> igli: Oh, you mean the ap?  Or do you mean the (,)?
00:26:49 <bringert> eumenides: if it's only 2k, that shouldn't be neccessary I think
00:26:56 <igli> heh i mean the monad (i know i need to read more)
00:27:11 <dmwit> Yeah, (2,3) is different from [2,3].
00:27:27 <dmwit> The monad used above is probably not the list monad, but the (r ->) monad.
00:28:05 <igli> oic; i thought a monad was low-level?
00:28:27 <dmwit> o
00:28:32 <igli> clearly what gets used a lot tho.
00:28:36 <dmwit> I'd say monads are a pretty high-level abstraction.
00:28:41 <eumenides> bringert: that's with a small test level. it'll probably grow some
00:28:42 <igli> ok
00:28:44 <igli> thanks man
00:29:10 <dmwit> There's a lot of different kinds.
00:29:38 <fuzan> lets see who can define monad most elegantly in one sentence.
00:29:44 <igli> hmm how would you describe a monad..
00:29:54 <igli> just what i was going to ask fuzan (but 2)
00:29:55 <hpaste>  elrodeo pasted "Lagged Fibonacci Generator" at http://hpaste.org/1412
00:30:30 <dmwit> My attempt: A monad is a high-level abstraction for sequencing computations.
00:30:42 <igli> like an iterator?
00:31:00 <igli> but more..
00:31:19 <igli> nice one, reading docs ty :)
00:31:27 <dmwit> Sort of, but an iterator sequences data access, whereas monads sequence more general computations.
00:33:32 <fuzan> one attempt?
00:33:35 <igli> so in C terms you can attach "callbacks"
00:33:37 <fuzan> we need more contributions!
00:33:48 <igli> heh go on then fuzan
00:34:09 <igli> since dmwit did the hard bit, refine ;)
00:34:35 <dmwit> I can make another attempt, if you like. ;-)
00:34:52 <fuzan> he gave the general definition :)
00:34:57 <dmwit> Monads are a generalization of container classes.
00:35:15 <fuzan> @src Maybe
00:35:15 <lambdabot> data Maybe a = Nothing | Just a
00:35:27 <fuzan> alas, the Maybe monad.
00:35:40 <fuzan> I tried to explain monads in a presentation
00:35:44 <dmwit> Of course, as fuzan may be trying to point out, they might not actually contain anything... =P
00:35:51 <fuzan> I think by the time I reached monads, everyone was already bored/lost.
00:36:00 <dmwit> heh
00:36:28 <dmwit> The Corollary to the Equation Rule: each Haskell concept you introduce decreases your audience by half. =)
00:36:30 <igli> hehe
00:36:35 <igli> lol
00:36:51 <igli> man i need a cuppa tea. you guys are great btw. brb
00:39:17 <dmwit> I don't understand why there isn't something like "type RandomMonad a = State StdGen a" and a few handy functions in some standard place that I could import.
00:40:13 <ddarius> dmwit: The Corollary would be worse than that, each I Haskell concept usually involves multiple equations decreasing the audience by 1/8.
00:40:45 <dmwit> Yes, I suppose pre-monad Haskell would imply the use of equations... =P
00:45:20 * mux likes associated types very much
00:48:16 <dmwit> ?index (%)
00:48:16 <lambdabot> Data.Ratio
00:48:26 <osfameron> perhaps haikus would be a good form to express the meaning of monads in?
00:49:37 <dmwit> ?hoogle Bool -> a -> a -> m a
00:49:39 <lambdabot> No matches, try a more general search
00:49:49 <dmwit> :t when
00:49:49 <igli> mux: what is an ``associated type''?
00:49:51 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
00:50:10 <igli> heh just think you could make a faq.. ;)
00:50:15 <mux> igli: an extension of the type-class system that allows one to defined type-indexed types
00:50:21 <mux> as opposed to just type-indexed values
00:50:34 <mux> it subsumes functional dependencies
00:50:35 * igli ponders
00:51:00 <dmwit> ?pl \q -> return (if p < q then x else y)
00:51:00 <lambdabot> return . flip (flip if' x . (p <)) y
00:51:04 <igli> God it's been years since i did ML at Uni, man.. give me a sec
00:51:07 <dmwit> :t if'
00:51:09 <lambdabot> Not in scope: `if''
00:51:09 <mux> igli: http://cvs.haskell.org/trac/ghc/wiki/TypeFunctionsExamples
00:51:11 <lambdabot> Title: TypeFunctionsExamples - GHC - Trac
00:51:16 <igli> thanks mate
00:51:17 <mux> a good example is worth a thousand words :-)
00:51:23 <igli> indeed
00:51:59 <mux> this example shows how we can now have generic maps that are optimized depending on the type of the map, so things like IntMap are useless
00:52:40 <igli> similar to templates? parametric arguments ring a bell somewhere..
00:53:00 <mux> it allows some generic programming techniques that are sometimes done using templates yeah
00:53:09 <igli> ty. sir
00:53:18 <igli> er ,
00:53:32 <mux> it's my pleasure to be able to help rather than whine in here for answers ;-)
00:54:44 * fuzan still needs to read about generics / SYB in haskell.
00:56:38 <igli> hehe
00:58:47 <eumenides> wah. derive gives me a parse error on my perfect code
01:01:46 <dmwit> :t liftM
01:01:48 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
01:02:44 <dmwit> :t ap
01:02:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
01:03:49 <dmwit> :t \f d -> return f `ap` d
01:03:51 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b) -> m a -> m b
01:04:09 <dmwit> aha!
01:05:23 <mux> hmmm, I wish I had a ghc HEAD available somewhere
01:05:43 <igli> i have src, but not for 6.6 atm
01:06:43 <mux> I'm rewriting the MonadState class of mtl without functional dependencies with associated types but can't test it without a HEAD ghc
01:06:51 * igli thinks that wasn't quite what you meant
01:06:52 <mux> it's building now but I guess it'll take some time
01:07:26 <igli> heh you should try gentoo ;)
01:07:37 <mux> ugh, no thanks
01:07:41 <igli> you'd never notice
01:07:47 <mux> oh yes I would
01:07:49 <mux> igli: /whois mux
01:08:10 <igli> lmao
01:08:33 <igli> there is a gentoo/FreeBSD you know ;)
01:08:47 <igli> (jk)
01:08:50 <mux> thanks again, but I'll do without it :-P
01:08:57 <igli> heh
01:09:03 <mux> everyone has its own favourite OS
01:09:46 <dmwit> > minus 1 10
01:09:47 <lambdabot>   Not in scope: `minus'
01:09:58 <igli> yeah, i d/led the BSD's (Net Open and Free) but never got round to install, this was a few yrs ago tho.
01:10:08 <dmwit> > subtract 1 10
01:10:09 <lambdabot>  9
01:10:38 <mux> anyone with a HEAD ghc available who wants to make me happy? :-)
01:11:26 <sieni> mux: I prefer to have OS X on a laptop and Debian on a desktop. So which one is my favourite?
01:12:10 <dmwit> sieni: You know what he meant.  Everyone has their preferences.
01:18:41 <hpaste>  mux pasted "MonadState with ATs" at http://hpaste.org/1413
01:20:14 <igli> what is an AT? can't see anything in code (yes i am reading docs.. HACKING atm)
01:20:35 <dmwit> ?ask ndm Where do isSymbol and isPunctuation reside (for building Derive)?
01:20:36 <lambdabot> Consider it noted.
01:20:37 <mux> in any case this is much more natural than stashing the state type into the class and adding a functional dependency to later disambiguate
01:20:40 <sjanssen> mux: shouldn't that 'data' be 'type'?
01:21:15 <mux> sjanssen: hmmm, that sounds quite likley :-) I'm still waiting on GHC in order to be able to test this
01:21:36 <joelr1> good morning
01:22:00 <mux> igli: did you look at that GMapKey example where the GMap type is defined within instances?
01:22:20 <igli> still got it open, did see it, will look more closely
01:22:23 <joelr1> what is the proper way to write this? class Morph a b| a -> b where morph :: a -> b
01:22:35 <mux> with ATs, heh.
01:23:14 <sjanssen> joelr1: that looks fine
01:23:32 <joelr1> sjanssen: it doesn't compile. let me paste the actual error
01:23:40 <sjanssen> -fglasgow-exts
01:23:43 <igli> god, Associated Typos ;)
01:23:49 <mux> hahaha
01:23:54 <igli> :)
01:23:56 <joelr1> sjanssen: one sec
01:24:21 <joelr1> sjanssen:     Illegal instance declaration for `Morpher Type A.Type'
01:24:21 <joelr1> 	(The instance type must be of form (T a b c)
01:24:21 <joelr1> 	 where T is not a synonym, and a,b,c are distinct type variables)
01:24:37 <int-e> that's an instance then
01:24:55 <joelr1> int-e: what do you mean?
01:25:09 <sjanssen> joelr1: looks like you need -fglasgow-exts
01:25:10 <joelr1> instance Morpher Type A.Type where
01:25:10 <mux> joelr1: you showed us a class declaration, and that error is related to an instance declaration
01:25:10 <joelr1>     morph TyInt = A.TyInt
01:25:18 <joelr1> sjanssen: ah, in both places?
01:25:22 <int-e> joelr1: that error does not refer to the class definition.
01:25:40 <joelr1> ok, mea culpa
01:25:50 <sjanssen> joelr1: yes, MPTCs are an extension, you'll need to supply it everywhere you use one
01:25:50 <joelr1> with exts in the module that uses the class it works
01:25:56 <joelr1> without exts it's a bummer
01:26:23 <joelr1> btw, the DeepSeq module has an example that looks sort of like mine but without MPTC
01:26:26 <joelr1> let me dig it up
01:27:08 <joelr1> here it is
01:27:09 <joelr1> class DeepSeq a where
01:27:09 <joelr1>     deepSeq :: a -> b -> b
01:27:37 <joelr1> what is the difference between this and what i'm doing? it's possible because b is present in the signature? when i tried morph :: a -> b it didn't work
01:27:40 <dcoutts> @seen sorear
01:27:40 <lambdabot> I saw sorear leaving #ghc, #haskell-overflow, #haskell-blah and #haskell 2h 44m 31s ago, and .
01:28:24 <sjanssen> joelr1: deepSeq works for *any* b
01:28:58 <sjanssen> it isn't really part of the class definition at all
01:29:22 <joelr1> sjanssen: i understand that. i was just wondering if i would be better off using the deepseq-style class as opposed to mine
01:29:33 <joelr1> or, rather, why would i not be better off
01:29:41 <sjanssen> that doesn't seem possible in your case
01:29:46 <joelr1> because mtpc would help ghc with optimizing code/
01:29:52 <joelr1> sjanssen: why not possible?
01:30:18 <sjanssen> what does Morph do?  it's some sort of typecast operator?
01:30:36 <mux> looks like the Coercion type class
01:30:40 <mux> the one in the FD paper
01:32:13 <joelr1> sjanssen: yes, i think so
01:32:15 <sjanssen> joelr1: your Morph is a property of two types (the type transformed from and the type transformed to).  DeepSeq is a concept involving only one type
01:32:17 <joelr1> sort of
01:32:56 <joelr1> sjanssen: morph is my AST transformation function
01:33:19 <joelr1> for example, to translate from a pascal ast into a c# ast
01:33:23 <sjanssen> class DeepSeq a where deepSeq :: forall b. a -> b -> b -- does this make things more clear?
01:33:44 <joelr1> sjanssen: not really. i don't understand why can't i use it in my case
01:34:17 <sjanssen> joelr1: write a function that turns a pascal ast into any other type
01:34:26 <sjanssen> (note that this is impossible)
01:34:34 <joelr1> sjanssen: hmm
01:35:13 <joelr1> sjanssen: true, impossible... i think i get it. this only works with deepseq because it requires b as an argument, right?
01:36:07 <sjanssen> it works with deepSeq because it will work for any b
01:36:36 <sjanssen> instance DeepSeq Int where deepSeq a b = seq a b -- a is constrained to Int, b is anything
01:37:45 <joelr1> sjanssen: so what if i were to try the same? constrain a to my source type and let b be anything
01:38:16 <joelr1> not that this is what i want, but i'm just wondering why it doesn't work. the only reason i see is that seq takes b as an argument and returns b
01:38:35 <sjanssen> joelr1: I don't see how this is possible.  How do you convert PascalAST to any (every!) type?
01:39:10 <joelr1> sjanssen: well, i would really convert it into one type but would have a "loose" declaration
01:39:13 <xerox> ?type (undefined :: a -> b)
01:39:15 <xerox> ;)
01:39:15 <lambdabot> forall a b. a -> b
01:39:43 <sjanssen> joelr1: we're a bit more principled in Haskell land ;)
01:39:45 <LeCamarade> Hey, the System.Plugins that dons used in `Dynamic Applications from the Ground Up' doesn't exist!
01:39:58 <joelr1> hehe
01:40:04 <sjanssen> LeCamarade: sure it does
01:40:08 <sjanssen> @where hs-plugins
01:40:08 <lambdabot> I know nothing about hs-plugins.
01:40:14 <LeCamarade> :oD
01:40:15 <sjanssen> @where plugins
01:40:16 <lambdabot> I know nothing about plugins.
01:40:24 <LeCamarade> Mwahaha.
01:40:27 <sjanssen> @google hs-plugins
01:40:27 <dmwit> ?where hsplugins
01:40:28 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
01:40:29 <joelr1> where HsPlugins
01:40:29 <lambdabot> Title: hs-pluginsDynamically Loaded Haskell Modules
01:40:29 <lambdabot> I know nothing about hsplugins.
01:40:37 <eumenides> Data.Binary get/put conflict badly with Control.Monad.State get/put. both are used extensively. Now what?
01:40:51 <sjanssen> @where+ plugins http://www.cse.unsw.edu.au/~dons/hs-plugins/
01:40:51 <int-e> eumenides: use qualified imports
01:40:51 <lambdabot> Done.
01:41:00 <sjanssen> @where+ hs-plugins http://www.cse.unsw.edu.au/~dons/hs-plugins/
01:41:00 <lambdabot> Done.
01:41:07 <joelr1> where+
01:41:08 <sjanssen> @where+ hsplugins http://www.cse.unsw.edu.au/~dons/hs-plugins/
01:41:09 <joelr1> hmm
01:41:10 <lambdabot> Done.
01:41:18 <dmwit> yay!
01:41:19 <joelr1> why not make where+ the default where?
01:41:20 <dmwit> aliasing FTW
01:41:31 <dmwit> joelr1: What?
01:41:39 <dmwit> where+ adds a new association...
01:41:40 <int-e> joelr1: because where+ adds new entries.
01:41:44 <joelr1> dmwit: oh
01:41:47 <joelr1> i get it
01:41:54 <sjanssen> I'm fairly amazed that lambdabot didn't know about hs-plugins
01:41:57 <joelr1> i thought it was some sort of a special where version
01:42:11 <LeCamarade> sjanssen: Yet she runs on it.
01:42:13 <dmwit> Maybe it lost some state in the power outage?
01:42:28 <dmwit> I know it used to know where to look.
01:42:35 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1414
01:42:40 <sjanssen> @where hackage
01:42:41 <lambdabot> I know nothing about hackage.
01:42:47 <sjanssen> yep, @where is dead
01:43:12 <sjanssen> @where ghc
01:43:13 <lambdabot> I know nothing about ghc.
01:43:30 <sjanssen> @tell dons all the @where entries seem to be missing
01:43:30 <lambdabot> Consider it noted.
01:43:41 <dolio> Ooo, she's back.
01:43:44 <dolio> @botsnack
01:43:44 <lambdabot> :)
01:44:19 <nomeata> Hi. Is there a better thing than writing: "exsists <- someIOBoolFunction; if exists then bla else blubb"?
01:44:27 <nomeata> some ifM contruct?
01:44:42 <sjanssen> nomeata: nothing in the standard libs
01:44:53 <quicksilver> nomeata: comes up every few days
01:44:53 <dmwit> nomeata: I just wrote one of those myself. =(
01:45:05 <int-e> sjanssen: @where hs-plugins should've worked, going by the darcs lambdabot.
01:45:07 <nomeata> ok :-)
01:45:08 <quicksilver> nomeata: there are a few options in terms of which parts are monadic and which parts get evaluated
01:45:23 <sjanssen> int-e: yeah, somethings broken
01:45:54 <nomeata> I think we just need a curried if, so we can write someIOBool >>= cifthen a else b
01:46:01 <nomeata> this would also be neat in pointless style
01:46:17 <sjanssen> we need bool!
01:46:20 <dmwit> nomeata: ?pl has access to an if', which should be easy for you to write yourself.
01:46:35 <dmwit> ?pl \p x y -> if p then x else y
01:46:36 <lambdabot> if'
01:46:37 <sjanssen> where bool is the catamorphism on Bool, similar to foldr, either, maybe, etc.
01:46:49 <dmwit> :t maybe
01:46:51 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
01:46:55 <nomeata> sjanssen: jupp, I was looking for that
01:47:15 <quicksilver> but note that liftM3 if' might not be what you want
01:47:31 <quicksilver> since liftM3 if' will cause the side-effects of both alternatives
01:47:37 <quicksilver> irrespective ofthe condition
01:47:44 <sjanssen> bool would also be handier for partial application
01:47:51 <sjanssen> handier than if', that is
01:47:55 <int-e> @where yi
01:47:56 <lambdabot> I know nothing about yi.
01:48:08 <int-e> sjanssen: very broken
01:49:25 <sjanssen> @where plugins
01:49:26 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
01:50:09 <int-e> ah: [06:54:28] <dons> oh. maybe the where database got zapped.
01:50:21 <int-e> (4 hours ago)
01:50:38 <sjanssen> @type \b x y -> case b of False -> x; True -> y
01:50:41 <lambdabot> forall t. Bool -> t -> t -> t
01:52:23 <mux> http://acm.jhu.edu/~eric/dk/title.jpg
01:52:43 <mux> heh, that's awesome, they recreated the level 1 of donkey kong using 6300 post-it
01:53:08 <mux> http://www.soe.ucsc.edu/~inio/dk/
01:53:09 <lambdabot> Title: UCSC Engineering Building Attacked by Giant Gorilla
01:53:21 <dolio> Man, somebody posted the wikipedia page on dining philosophers to reddit...
01:54:32 <mux> sorry for the high level of off-topicness ;-)
01:54:57 <quicksilver> mux: redeem yourself by implementing donkey kong in haskell
01:55:23 <mux> hey, that could be fun:
01:55:46 <quicksilver> mux: then it would be on-topic, you see! :)
01:56:07 <mux> I have enough on my haskell plate though :)
01:57:59 <LeCamarade> Me, just an implementation of the Tiger language (supposed to be ML, but my system be buggy).
01:58:10 <LeCamarade> And a few side hacks.
02:00:10 <mux> LeCamarade: are you volunteering for the donkey kong task? ;-)
02:01:36 <dmwit> ?pl \((a, b), (c, d)) -> ((a, c), (b, d))
02:01:37 <lambdabot> uncurry (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (,)) . flip . (((.) . (,)) .) . (,)))
02:01:42 <dmwit> heh
02:02:08 <LeCamarade> mux: Nope!
02:06:31 <eumenides>       Expected type: [Word8]
02:06:31 <eumenides>       Inferred type: String
02:06:35 <eumenides> erm oops
02:08:13 <dolio> :t (fst *** fst) &&& (snd *** snd)
02:08:15 <lambdabot> forall a b a1 b1. ((a, b), (a1, b1)) -> ((a, a1), (b, b1))
02:08:18 <hpaste>  ADEpt annotated "(no title)" with "simplified even more :)" at http://hpaste.org/1414#a2
02:14:06 <hpaste>  dolio annotated "(no title)" with "golf?" at http://hpaste.org/1414#a3
02:15:12 <dolio> Oops, that's wrong. Replace the 'show =<< sum' with 'show . sum'
02:21:37 <jacobian_> Has anyone done a scientific units library using typeclasses?
02:23:12 <dmwit> Wow, dolio, that's pretty good!
02:23:17 <dmwit> Are you magic?
02:23:32 <igli> mux: that is *sweet* :)
02:23:50 <dolio> :) I had to play for a few minutes to figure out how to put them together.
02:24:04 <mux> igli: ATs? :)
02:24:08 <dmwit> :t (***)
02:24:11 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
02:24:20 <igli> yeah sure mate ;)
02:24:27 <igli> nah Donkey Kong!
02:24:53 <dolio> dmwit: The arrows stuff is all built around pairs, though, so if you're fiddling with them, odds are you can write it point-free with combinators in there.
02:25:08 <dolio> dmwit: At least, better than you'll get from @pl.
02:25:15 <dmwit> I'm still a little hairy on pairs, but that's a good rule of thumb.
02:25:25 <dmwit> hairy on arrows, even
02:25:48 <quicksilver> you don't to worry about arrowness though
02:25:57 <quicksilver> you're just using the concrete implemetnations for functions
02:26:11 <mux> igli: heh
02:26:18 <dmwit> Can't functions get transformed to any arrow?
02:26:25 <quicksilver> true
02:26:35 <quicksilver> but if you're just looking for the 2,2-tuple transpose
02:26:37 <mux> yeah, with pure or arr
02:26:40 <quicksilver> you're just looking for a function
02:26:56 <dolio> Yeah, actually, when you actually want to use arrows, you probably don't want to worry about the pairs.
02:27:00 <dmwit> Oh, but the transformation has to be explicit, doesn't it.  Hindley-Milner++
02:27:05 <dolio> But the way they're built is handy for fooling with tuples.
02:28:00 <nominolo> @src splitAt
02:28:01 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
02:28:12 <nominolo> @src take
02:28:13 <lambdabot> take n _      | n <= 0 =  []
02:28:13 <lambdabot> take _ []              =  []
02:28:13 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
02:28:26 <dcoutts> splitAt is specified incorrectly btw
02:28:31 <dmwit> Wait, so (a -> b) is both an instance of arrow and the type of an arrow "constructor"?
02:28:34 <dcoutts> the spec is too lazy
02:28:43 <nominolo> hm, isn't drop and take defined in terms of splitAt?
02:29:03 <dcoutts> no
02:29:07 <dcoutts> other way around
02:29:23 <nominolo> hm, would it be bad to do so?
02:29:27 <dcoutts> but as I say, splitAt is specified incorrectly anyway
02:30:09 <dcoutts> nominolo: so long as splitAt as defined sensibly it'd be ok, but I'm not sure I see the point of doing it that way
02:30:26 <dcoutts> take and drop have nice simple definitions, splitAt is more compilcated
02:31:59 <_roconnor> > logBase 10 16
02:32:00 <lambdabot>  1.2041199826559246
02:32:12 <_roconnor> > 8* 6 * 4 (logBase 10 16)
02:32:14 <lambdabot>   add an instance declaration for (Num (t1 -> t))
02:32:18 <_roconnor> > 8* 6 * 4 * (logBase 10 16)
02:32:20 <lambdabot>  231.19103666993752
02:32:21 <nominolo> dcoutts: i was just wondering if i could find a tail-recursive version for both
02:32:37 <nominolo> or one without reverse
02:32:40 <earthy> hm. *big* coolness, spj giving a haskell tutorial at oscon...
02:33:03 <mux> yeah that's great
02:33:04 <_roconnor> > 8* (6 * 5 + 2) * (logBase 10 16)
02:33:06 <lambdabot>  308.2547155599167
02:33:28 <dmwit> nominolo: They are both tail-recursive and don't use reverse already, right?
02:34:22 <mux> can someone lend me a shell somewhere with GHC HEAD?
02:34:42 <mux> I promise I'll be a nice guy
02:35:00 <dcoutts> nominolo, dmwit: I'm not sure you can make splitAt tail recursive and have the right strictness
02:35:59 <dcoutts> at least without traversing the first part of the list twice
02:36:04 <dcoutts> ie by loosing sharing
02:36:25 <dmwit> mux: Not http://www.haskell.org/ghc/dist/current/dist/ ?
02:36:27 <lambdabot> Title: Index of /ghc/dist/current/dist
02:37:49 <mux> dmwit: mmm, nice, I could use linux binaries with the linux ABI support of freebsd probably
02:37:52 <mux> thanks
02:38:12 <nominolo> dcoutts: no, that would require modifying a tail
02:45:26 <bluestorm> hm
02:45:42 <bluestorm> is there a way to plot a single point using HGL ?
02:46:37 <mux> I'm really unlucky today
02:46:50 <mux> it seems http://www.haskell.org/ghc/dist/current/dist/ghc-6.7.20070404-i386-unknown-linux.tar.bz2 is broken
02:46:52 <lambdabot> http://tinyurl.com/2xrfdj
02:47:37 <dolio> It's downloading here. Or do you mean the contents don't work?
02:47:43 <mux> dolio: contents
02:47:46 <dolio> Ah.
02:47:48 <mux> the bzip2 archive is just broken
02:48:27 <bluestorm> i didn't find anything in the HGL doc
02:48:43 <mrchebas> @where MonadFix
02:48:43 <lambdabot> I know nothing about monadfix.
02:48:45 <bluestorm> maybe Draw.line point point  is the easier way
02:48:56 <mrchebas> @hoogle MonadFix
02:48:57 <lambdabot> Control.Monad.Fix.MonadFix :: class Monad m => MonadFix m
03:10:51 <earthy> ?seen sorear
03:10:51 <lambdabot> I saw sorear leaving #ghc, #haskell-overflow, #haskell-blah and #haskell 4h 27m 42s ago, and .
03:10:57 <earthy> hm. drat.
03:11:35 <earthy> @tell sorear look at http://www.cs.uu.nl/wiki/HUT/ for another cabalization of Daan's PPrint lib.
03:11:36 <lambdabot> Consider it noted.
03:21:41 <eumenides> how do i convert a (finite) lazy ByteString into a strict ByteString?
03:22:03 <dcoutts> eumenides: B.concat . L.toChunks
03:22:27 <dcoutts> note that it's not cheap, it involves a full copy
03:22:58 <eumenides> dcoutts: well unless there's a way to simulate the strict versions of hGetLine and hPutStrLn then that's all i have
03:23:28 <dcoutts> simulate in what way?
03:23:50 <dcoutts> you can hPutStrLn with lazy bytestring and you can use lines or other pure functions to break into lines
03:24:04 <dcoutts> or are you actually doing a line oriented interactive program?
03:24:27 <eumenides> i have a network protocol where the client/server send eachother lines
03:24:50 <eumenides> Data.ByteString.Lazy doesn't seem to have hPutStrLn/hGetLine, only hGetContents and hPut
03:25:03 <dcoutts> eumenides: if you're only dealing in lines anyway then strict bytestrings are probably better for you
03:25:44 <eumenides> dcoutts: Data.Binary and Codec.Compression.GZip use lazy bytestrings though, that's why
03:25:47 <tsp> ok, most of you guys are good at math, so I have a question
03:25:55 <int-e> but hGetContents and then using map (B.concat . L.toChunks) . L.lines $ contents   shouldn't be too bad
03:26:00 <dcoutts> eumenides: ah well going from strict to lazy is cheap
03:26:08 <int-e> normally, most lines should only have a single chunk.
03:26:09 <tsp> if you echo 171783386661508931145981567768179685699801015564853041317582623299750568847373614733296133080952330P | dc, you get an interesting result :) I just need to shorten that number. Any tips?
03:26:13 <dcoutts> eumenides: fromChunks [b]
03:26:33 <tsp> been tyring to figure it out for an hour
03:26:37 <tsp> or two
03:27:00 <dcoutts> > Numeric.showFFloat (Just 4) 171783386661508931145981567768179685699801015564853041317582623299750568847373614733296133080952330 []
03:27:02 <lambdabot>  "171783386661508930000000000000000000000000000000000000000000000000000000000...
03:27:09 <dcoutts> > Numeric.showGFloat (Just 4) 171783386661508931145981567768179685699801015564853041317582623299750568847373614733296133080952330 []
03:27:11 <lambdabot>  "1.7178e98"
03:27:19 <eumenides> dcoutts: well, i have to send/receive strict byestrings, then convert to compress/decompress and encode/decode
03:27:57 <dcoutts> eumenides: you're dealing with compressed single lines?
03:28:08 <tsp> that number is enormous - I don't think anything can be done with it to make its components smaller
03:28:41 <eumenides> dcoutts: well, i'm encoding them already, i thought i might as well also compress :)
03:29:05 <dcoutts> eumenides: you'll not get much compression with that little data, unless you've got huge lines :-)
03:29:38 <dcoutts> eumenides: if your lines aren't that long it doesn't really matter if you're using strict or lazy bytestrings
03:29:42 <eumenides> dcoutts: the server sends around 10k
03:29:59 <dcoutts> eumenides: as a single line?
03:30:22 <dcoutts> 10k with no embeded '\n'
03:30:25 <tsp> > let n = 171783386661508931145981567768179685699801015564853041317582623299750568847373614733296133080952330 in n == (sqrt n)^2
03:30:27 <lambdabot>  False
03:30:35 <eumenides> dcoutts: well, yeah
03:30:39 <tsp> damn! I get that in every lang I try that in
03:30:41 <eumenides> dcoutts: is that bad?
03:30:54 <tsp> sqrt(x)^2 should equal x
03:30:59 <int-e> tsp: it's just a base 256 string with ascii characters as digits
03:31:05 <tsp> int-e: I know :)
03:31:08 <int-e> tsp: and no it shouldn't
03:31:21 <dcoutts> eumenides: fair enough, that's enough to get a benefit from compression, though you can't guarantee the compressed data doesn't have '\n' in it.
03:31:25 <tsp> int-e: how'd you figure out what it was so fast though? :)
03:31:33 <tsp> i still don't know how it works, just how to create them
03:31:39 <int-e> tsp: I know what the 'dc' P command does
03:33:22 <tsp> if I was printing a number like 64, I could say 64 = 4^3 and that would be true
03:33:30 <tsp> I'm trying to find something like that for this enormous string
03:34:11 <norpan> you're trying to compress arbitrary numbers into other numbers
03:34:12 <dcoutts> eumenides: so it probably doesn't matter which you use, hGetLine needs to make a copy anyway so going via a lazy ByteString and converting to strict is no more expensive and possibly less so if you get exactly one chunk.
03:34:23 <tsp> norpan: yeah, simplify them
03:34:35 <norpan> i doubt you can get it much shorter
03:34:52 <tsp> norpan: why not? I should just be able to do some basic math and be able to come up with it if I could figure out the right trick
03:34:55 <norpan> if you had more text
03:35:07 <norpan> then it should be possible to do some compression
03:35:19 <norpan> but since you need to include the compression algorithm...
03:35:28 <tsp> norpan: tried that already
03:35:34 <tsp> the algo took up more than the string
03:35:41 <norpan> exactly
03:36:08 <norpan> unless you are extremely lucky
03:36:46 <int-e> tsp: echo '1685082122dpP' | dc ;-)
03:36:51 <quicksilver> on the contrary, I would say there is a very good chance its compressible
03:36:55 <tsp> I could probably figure it out if I had a program that didn't have floating point roundoff errors
03:37:04 <quicksilver> since it's only using a few bits of each byte
03:37:14 <eumenides> dcoutts: i just used show/read before, but there was substantial lag when both the server and client were on the same machine. i hope Data.Binary + compression will be faster
03:37:18 <tsp> > 64^(1/3)
03:37:19 <lambdabot>  Add a type signature
03:37:24 <tsp> the hell?
03:37:26 <tsp> should give me 4
03:37:42 <ivanm> > 64^(1/3) :: Double
03:37:43 <lambdabot>  Add a type signature
03:37:54 <int-e> > 64**(1/3) :: Double
03:37:55 <ivanm> > (64 :: Double)^(1/3)
03:37:56 <lambdabot>  3.9999999999999996
03:37:56 <lambdabot>  Add a type signature
03:38:04 <int-e> @type (^)
03:38:06 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
03:38:28 <ivanm> > 64^((1/3) :: Double)
03:38:29 <lambdabot>   add an instance declaration for (Integral Double)
03:38:29 <lambdabot>     In the expression: 64...
03:38:32 <tsp> how do I get these languages to bive me 4? not 3.999 due to rounding
03:38:54 <int-e> there are ^, ^^ and **; ^ works for nonnegative integer exponents; ^^ for integer exponents and ** for arbitrary floats.
03:39:06 <dcoutts> eumenides: how do you plan to deal with fact that the compressed data will contain '\n' chars ?
03:39:12 <int-e> tsp: they round. often the output routine rounds.
03:39:32 <tsp> the answer should be 4.00000... etc
03:40:01 <eumenides> dcoutts: no idea. at the moment i'm just trying to get it to compile
03:40:48 <tsp> I'm trying to turn that number into something like 10**30 or something
03:41:12 <tsp> and the floating point roundoff is causing some problems with the math
03:43:10 <quicksilver> tsp: it would be a coincidence indeed if that number was expressible in the form x ** y
03:43:22 <quicksilver> tsp: I suggest you examine it's prime factorisation to verify if it is
03:43:52 <int-e> the number is congruent 2 mod 4, so it is not a perfect power.
03:44:04 <quicksilver> int-e wins
03:44:19 <quicksilver> although observing it's prime factorisation might still be useful
03:44:31 <quicksilver> you might notice it to be the product of perfect powers, or some such
03:44:48 <int-e> quicksilver: I did that actually
03:45:09 <tsp> quicksilver: prime factorizaqtion? How would I check that?
03:45:16 <tsp> it's not a prime, if that's what that means
03:45:18 <norpan> quicksilver: of course it's compressible, but since you need to include the algorithm the text is probably to short
03:45:28 <int-e> the first prime divisors are 2, 3, 3, 5, 11; saying it's =2 mod 4 was just the most convenient way to prove it.
03:45:43 <tsp> why is 3 in there twice?
03:45:55 <eumenides> dcoutts: it works now (without compression), but it's just barely faster than read/show. hrm
03:46:36 <dcoutts> eumenides: perhaps that wasn't the bottleneck, you probably want to profile
03:46:38 <tsp> I was trying everything from cube roots to /usr/games/factor, but factor was killing the box
03:46:54 <dcoutts> eumenides: find out what's actually slow, not just go on hunches
03:47:02 <tsp> the number's just too big
03:47:08 <int-e> tsp: echo '15i426A1EDE3D725A2310A93E769E4D6615C69DA0381AC5DB92B28D2C62E93204A13491A02CD9302A066EC0P' | dc is slightly shorter without being obvious. (base 16 would be obvious)
03:47:39 <tsp> interesting, base-15
03:47:44 <tsp> never thought of that
03:47:50 <quicksilver> tsp: since we're in #haskell, you'd write a haskell program to prime factorise it
03:48:01 <quicksilver> tsp: which involves writing a haskell program to get (enough) primes
03:48:08 <quicksilver> tsp: fortunately both of those are easy
03:49:48 <tsp> I used to have a python factoring library, but I seem to have lost it
03:50:06 <tsp> although I know it would have died when I tried for i in range(n): on that number :)
03:50:14 <tsp> or just taken a week or two to run
03:50:31 <quicksilver> prime factorising that number with a decent algorithm would take much less than a second
03:50:41 <eumenides> dcoutts: i'm not sure what else it would be. i had this working without lag and the only thing i added was to split it into a client/server
03:51:01 <tsp> a second? for that number? maybe ona  superfast box
03:51:31 <quicksilver> tsp: nah
03:51:43 <joelr1> what is the monadic fold? i need to run f (state monad) on a list and return the final state
03:51:45 <quicksilver> tsp: each time you divide it by a prime, it gets much smaller
03:51:45 <tsp> I'm only on a 400mhz sparc here :) stuck with python, since my haskell vm died
03:51:49 <joelr1> :t sequence
03:51:51 <lambdabot>     Ambiguous occurrence `sequence'
03:51:52 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
03:52:00 <int-e> @type foldM
03:52:02 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
03:52:10 <tsp> quicksilver: how do I find the primes? 1, 3, 5, 7, 9, 17, etc
03:52:18 <joelr1> int-e: thanks
03:52:20 <dcoutts> eumenides: well you can try profiling the communication on it's own, try just serialising to a file to test the speed
03:52:27 <quicksilver> tsp: not like that, since 1 isn't a prime and neither is 9 :P
03:52:34 <tsp> 1 is, since it has no factors :)
03:52:53 <tsp> but 9's not, it's got 3, damn, I got lost somewhere around grade 10 math and never took it back up
03:52:59 <tsp> and I'm interested in math now
03:53:08 <dcoutts> eumenides: you're not going via String on the network socket are you? no pack & unpacks ?
03:53:47 <quicksilver> tsp: 1 isn't prime. There was a long discussion on the -cafe about prime factorisation algorithms.
03:53:58 <eumenides> dcoutts: encode to lazy bytestring, convert to strict bytestring and send, reverse on the other end
03:54:00 <jacobian_> tsp: http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes
03:54:01 <lambdabot> Title: Sieve of Eratosthenes - Wikipedia, the free encyclopedia
03:54:21 <quicksilver> tsp: erm, about prime finding algorithms I mean
03:54:31 <foxy-om> > nubBy (\x y -> (mod y x) == 0) [2..]
03:54:33 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
03:54:34 <joelr1> how do you define an instance for [a] assuming the following? class Morpher a b| a -> b where  morph :: a -> Strategy b
03:55:02 <tsp> quicksilver: ah
03:55:08 <tsp> damn, python's gonna die if I try a sieve
03:55:17 <tsp> although it has iterators so maybe not
03:55:56 <joelr1> int-e: any suggestions?
03:56:02 <tsp> damn, range() is too big
03:58:10 <int-e> joelr1: actually if you only want the state of the state monad, sequence will work nicely.
03:58:57 <joelr1> int-e: ah! i'm having trouble defining a list instance, though
03:59:17 <joelr1> int-e: where the method would be sequence
03:59:23 <joelr1> :t Control.Monad.sequence
03:59:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
04:00:14 <int-e> joelr1: hmm. instance Morpher a b => Morpher [a] b where ... ? not sure what exactly you want, you need to make up your mind about what b should be, too.
04:00:25 <joelr1> int-e: that is i want to say that whenever [a] shows up i want to run morph on every element and grab the final state
04:00:49 <joelr1> int-e: i want to do that for any b since the action is always the same
04:01:08 <int-e> Strategy is a monad?
04:01:35 <joelr1> int-e: yeah, an alias for State a
04:01:53 <joelr1> int-e: type Strategy a = State Strat a
04:02:11 <int-e> if yes you can define instance Morpher a b => Morpher [a] [b] where morph xs = sequence xs  and be done with it, I think.
04:02:44 <joelr1> int-e: won't work since the end result should be a b, not [b]
04:02:51 <joelr1> int-e: but let me try the instance decl
04:03:14 <joelr1> int-e: this is why i was thinking of a fold
04:03:45 <joelr1> :t Control.Monad.foldM
04:03:47 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
04:04:05 <int-e> @type foldM undefined (flip const)
04:04:07 <lambdabot> forall b (m :: * -> *) a b1. (Monad m) => [b] -> m (b1 -> a -> a)
04:04:09 <joelr1> int-e: hmm... foldM explicitly takes an initial state, though...
04:04:36 <int-e> @type foldM undefined (const const)
04:04:39 <lambdabot> forall b (m :: * -> *) a b1 b2. (Monad m) => [b] -> m (b2 -> a -> b1 -> a)
04:04:59 <joelr1> int-e: whereas what i want is for the first application of morph to the first element of the list to take the state supplied by execState and then for the state to be threaded along
04:05:24 <int-e> :t foldM (flip const) undefined
04:05:27 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m a
04:05:35 <int-e> getting the argument order right is sort of essential. duh.
04:05:40 <joelr1> how do i accomplish that? sequence returns a list, won't work. foldM explicitly takes initial state, do i plug in a get here?
04:05:52 <tsp> > filter (% 2) [2..171783386661508931145981567768179685699801015564853041317582623299750568847373614733296133080952330]
04:05:54 <lambdabot>  Couldn't match expected type `Bool' against inferred type `Ratio a'
04:05:56 <joelr1> since get will grab the state of the state monad
04:06:00 <tsp> damn
04:06:02 <tsp> thought that would work
04:06:06 <tsp> lazy evaluation and all
04:06:58 <int-e> joelr1: foldM (flip const) undefined   runs a sequence of actions ([m a]) and returns the result of the last one (m a).
04:07:32 <joelr1> int-e: i see... is this what forM_ does?
04:07:43 <joelr1> int-e: thanks
04:07:54 <int-e> joelr1: forM_ (and mapM_) return ()
04:08:12 <int-e> @type mapM_
04:08:14 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
04:08:18 <joelr1> ugh
04:08:32 <joelr1> int-e: ok, foldM (flip const) undefined it is
04:08:55 <int-e> joelr1: the undefined is the value that is returned if the list turns out to be empty btw.
04:09:39 <joelr1> int-e: what if i want to return the initial value given to execState?
04:09:55 <joelr1> int-e: give foldM a get ?
04:11:27 <foxy-om> @src (%)
04:11:28 <lambdabot> x % y = reduce (x * signum y) (abs y)
04:11:36 <hpaste>  joelr1 pasted "foldM (flip const) get" at http://hpaste.org/1415
04:11:44 <joelr1> int-e: something is off
04:12:33 <int-e> joelr1: hmm. let me sort out some confusion first. a) Strategy a - what exactly is it? is Strategy a = State a a, or something different?
04:12:52 <joelr1> int-e: same strategy
04:13:48 <joelr1> int-e: type Strategy a = State Strat a
04:14:13 <int-e> ah. ok, that's a state monad with a state of type Strat and a value of type a.
04:14:27 <quicksilver> int-e: hmm interesting. tsp's number has some rather larger prime factors than I expected...
04:14:28 <int-e> do you actually care about these values or do you only care about the state?
04:14:44 <joelr1> int-e: i care about state, i want to get th efinal state
04:15:47 <int-e> joelr1: then why don't you define  class Morpher a where morph :: a -> Strategy () ? you will still get the state out of it just fine.
04:16:13 <joelr1> because i care about result now that i think about  it
04:16:31 <int-e> joelr1: good. then what should the result for the list instance be?
04:16:40 <joelr1> int-e: the monad is for side effects of which there may be some
04:16:47 <joelr1> int-e: hmm...
04:17:03 <joelr1> int-e: basically, an empty list i suppose
04:17:21 <joelr1> int-e: i'm transforming a list of statements but there will be no statements as a result
04:17:55 <joelr1> int-e: because statements will be incorporated into strategy
04:18:33 <int-e> joelr1: then why do you care about the result? (running in circles)
04:19:05 <joelr1> int-e: suppose i'm transforming a type. the result should be a type but state won't be updated
04:19:36 <joelr1> int-e: now suppose i'm transforming a variable declaration. the result will be a variable declaration but i'll update state as well
04:19:55 <joelr1> int-e: is this a good explanation?
04:20:34 <joelr1> int-e: so i guess the result of transforming [a] into b is () and a massive strategy update
04:20:59 <int-e> joelr1: in any case I made a mistake earlier. morph = foldM (\_ x -> morph x) undefined  is what I should've suggested, I totally forgot about invoking morph.
04:21:32 <int-e> joelr1: hmm. re: your paste; you probably need -fundecidable-instances to make that work.
04:22:49 <int-e> joelr1: instance Morpher a b => Morpher [a] () where morph = mapM_ morph -- how does that sound? it discards all results but affects the state.
04:24:55 <joelr1> int-e: let me try, thanks
04:28:53 <joelr1> int-e: that still needs undecidable instances but compiles
04:30:37 * LeCamarade mumbles, looking at the Java code in the other terminal. He can't stand the for loop. He wants to know if he can code in Haskell for the JVM ...
04:31:15 <LeCamarade> ?google jaskell
04:31:17 <lambdabot> http://jaskell.codehaus.org/
04:31:18 <lambdabot> Title: Jaskell - Home
04:31:28 <LeCamarade> :oD
04:34:08 <dolio> Dynamic scoping? What kind of language is this?
04:34:42 <int-e> joelr1: undecidable instances aren't necessarily bad, all it means is that the compiler can't prove that type checking will always terminate. in this particular case functional dependencies will take care of that.
04:35:18 <dolio> And it's lazy and impure. Crazy.
04:44:11 <mrchebas> wow, :r in ghci gave me "openBinaryFile: resource exhausted (Too many open files)"
04:44:23 <mrchebas> maybe my ghci session was open for too long
04:47:29 <mux> heheh, I keep on reading 'Borat' instead of 'Bulat'
04:50:56 <dcoutts> mux: heh, be careful though ;-)
04:51:49 <balodja> so. i'm trying to output some non-ascii text through putStrLn, but ghc just cuts the Char to 8bit, is there any solution?
04:52:41 <dcoutts> balodja: convert to utf8 first
04:53:47 <nominolo> > map (foldl1 (flip (.)) [(+1), (*2), (`div` 2), (\x -> x-1)]) [1..4]
04:53:49 <lambdabot>  [1,2,3,4]
04:53:53 <mauke> what's the problem with recursive types?
04:54:15 <nominolo> > map (foldl (flip (.)) [(+1), (*2), (`div` 2), (\x -> x-1)] id) [1..4]
04:54:16 <lambdabot>  Couldn't match expected type `a -> c' against inferred type `[a1]'
04:54:24 <nominolo> > map (foldl (flip (.)) id [(+1), (*2), (`div` 2), (\x -> x-1)]) [1..4]
04:54:26 <lambdabot>  [1,2,3,4]
04:54:42 <balodja> dcoutts: hm-m-m, but Char is utf32, isn't it?
04:55:15 <dcoutts> Char is a Unicode code point
04:55:15 <dcoutts> so yeah, in a sense, [Char] is utf32
04:55:19 <mauke> you'd still have to specify an output encoding
04:55:34 <balodja> dcoutts: and, when using output actions like putStrLn, it cuts up to the first byte :(
04:55:35 <mauke> haskell's I/O system doesn't seem to be flexible enough to do this, though
04:55:50 <mauke> so write your own encoder
04:55:55 <dcoutts> right, I was just assuming balodja wanted to output in utf8
04:56:19 <balodja> i don't know the rules of transforming in output
04:56:26 <balodja> so, i'm just asking :)
04:56:43 <dcoutts> balodja: basically the get and put IO actions work on bytes with no encoding
04:57:13 <dcoutts> which is a bit of a fudge since their type suggest they work on unicode strings
04:57:14 <balodja> that's a big shortcoming. so ByteString will save the situation
04:57:20 <dozer> I've run into a problem with kinds that I can't figure out for myself
04:57:41 <dcoutts> balodja: ByteString is not unicode either of course, as it's name suggests it's a sequence of bytes
04:57:50 <dozer> to pick a simple example, say I have the type Set e; Map k v
04:57:57 <balodja> dcoutts: yep, but i can do right IO
04:58:03 <dcoutts> balodja: what you want is a function toUTF8 :: String -> String
04:58:24 <mauke> just use Perl :-)
04:58:48 <dozer> and a class Iterable (itt e) where forall :: (e -> v) -> itt -> [v]
04:58:58 <dcoutts> balodja: there are various versions of that function floating about, but none in the standard libs at the moment
04:59:18 <mauke> is class Foo (a b) valid syntax?
04:59:19 <dozer> I can see how to make Set e inhabit this, but what do I do with Map k v? It has one too many type parameters so I get a kind error
04:59:42 <dcoutts> balodja: I've been meaning to bind iconv for partly this purpose, to convert between arbitrary encodings
04:59:55 <balodja> oh, that's yous :)
05:00:35 <mux> dcoutts: should be easy, AFAIK, there are like 3 functions or so
05:00:55 <mux> iconv_open() iconv() and iconv_close()
05:01:03 <dcoutts> mux: heh, it looks easy, but I've looked into it
05:01:24 <mauke> class Iterable c e | c -> e where visit :: (e -> a) -> c -> [a]
05:01:40 <mauke> instance Iterable (Map k v) (k, v) where
05:01:55 <dcoutts> mux: it's very very nearly possible in a nice way but the iconv designers messed up in one corner and assumed that you're using a mutable input buffer
05:02:06 <mux> ouch
05:02:09 <mux> I hate this
05:02:13 <mux> but wait
05:02:23 <dcoutts> mux: the api looks like it can work nicely with imutable input buffers, and it very nearly can
05:02:28 <mux> if you use withCString, you have a dynamically allocated buffer that is mutable anwyays?
05:02:31 <balodja> dcoutts: that's good binding, but in some places i have fixed String to ByteString, as in my vision, String is used for internal representation(for example charsets), but ByteString is the string of bytes to convert. in my opinion, the better choice is to use ByteString everywhere are the problems with encoding
05:02:39 <dcoutts> mux: the corner case is this...
05:02:49 <mux> or is the problem that they modify buffers held in iconv_t ?
05:03:41 <mux> even then I don't see the problem
05:03:43 * mux is all ears
05:03:44 <dcoutts> mux: it's not that iconv modifies the input stream, but when it gets to the end of an input buffer, if there's a char which uses multiple bytes and is split across the end of the current chunk...
05:04:41 <dcoutts> mux: instead of accumulating those last one or two bytes into the iconv state, it tells you that there are that many bytes left in the input and demands that you supply it with another buffer
05:05:13 <mux> dcoutts: ah, so the problem is that this behaviour would make usage with haskell not convenient, right?
05:05:24 <Igloo> dcoutts: You mean iconv might alter the buffer you give it?
05:05:29 <dcoutts> mux: in other words you are responsible for copying those last few bytes onto the *beginning* of the next buffer so that iconv will get the next char in a contiguous chunk
05:05:45 <mux> dcoutts: I would expect people to call iconv() on "full" buffers though
05:05:56 <mux> I only see iconv taking ascii-zero delimited strings
05:05:56 <dcoutts> mux: and how do you do that if the next chunk is also immutable? ugg! you've got to copy it!
05:05:57 <Igloo> Ah, right, that's OK then  :-)
05:06:27 <mux> but yeah I see the point
05:06:32 <mux> it's a bit like with zlib
05:06:37 <dcoutts> no, zlib is fine
05:06:44 <mux> zlib sucks big time
05:06:53 <mux> not in the same way, but in related ways
05:07:18 <dcoutts> heh, it's apit is quite general and tricky, but it gives you complete freedom over buffer management
05:07:27 <mux> it's one of the most horrible and undocumented library that I know of
05:07:44 <mux> it's a pain for me even to talk about it
05:07:47 <dcoutts> iconv looks like it gives the same freedom, but it doesn't. It makes it very convinvenient if you're not using mutable buffers
05:07:52 <mux> let's concentrate on iconv :)
05:07:56 <dcoutts> aye
05:08:10 <mux> so
05:08:15 <dcoutts> mux: so there's no reasonable way I can guarantee that the char boundaries will fall on chunk boundaries
05:08:22 <mux> I guess a possible solution
05:08:44 <mux> would be to have our 'iconv_t' type, or iconv handle or whatever, but a wrapper around the real iconv_t
05:08:45 <dcoutts> I have to deal with copying 1 or 2 bytes from the end of the current chunk to another chunk
05:08:54 <mux> store the offending bytes there
05:09:02 <mux> and hide this complexity from the user
05:09:14 <dcoutts> oh hiding from the user is no problem
05:09:28 <dcoutts> its going to be a function :: Lazy.ByteString -> Lazy.ByteString
05:09:46 <mux> what is the problem then?
05:09:47 <dcoutts> the question is internal code complexity and efficiency
05:10:15 <dcoutts> now we don't need to copy all of the following chunk to prepend the 2 or three bytes from the last chunk
05:10:27 <dcoutts> we can make a small chunk with just enough
05:10:52 <twanvl> Maybe you could make more room at the start of the next chunk
05:10:59 <mux> it's a pity iconv() doesn't support being passed buffers a la 'struct iovec' style
05:11:08 <dcoutts> twanvl: can't. The input buffers are pure and immutable
05:11:15 <mux> like for readv() / writev()
05:11:16 <dcoutts> mux: yeah
05:11:29 <dcoutts> mux: or it could just remember the state internally
05:11:39 <dcoutts> that'd be pretty easy to do methinks
05:11:41 <mux> that's what I suggested
05:11:46 <dcoutts> but it makes us do it
05:11:53 <mux> I mean, keeping the extra bytes in in t he iconv handle type
05:12:04 <mux> but then we have to copy that into a contiguous char buffer :-(
05:12:20 <mux> which may be expensive if the following buffer is big
05:12:23 <dcoutts> right, it demands that they be contiguous with the rest of the bytes that make up the char
05:12:46 <dcoutts> so if we try to only copy a short prefix of the following buffer
05:12:58 <mux> we may have other remaining bytes
05:13:07 <dcoutts> and copy the trailing bytes from the last chunk and enough bytes from the next chunk
05:13:26 <dcoutts> the question is, how do we know how many bytes from the next chunk to copy in ?
05:13:39 <mux> I guess we'd have to walk the buffer
05:13:45 <mux> and then again, it's *hard*
05:13:46 <dcoutts> but we don't know the encoding
05:13:50 <mux> since it depends on the considered encoding
05:13:52 <mux> yes
05:14:00 <mux> so we'd better say we can't
05:14:03 <dcoutts> right
05:14:09 <twanvl> You could just copy more than you need
05:14:15 <dcoutts> exactyl
05:14:21 <dcoutts> however we can probably put an upper limit on the number we need
05:14:38 <dcoutts> no sensible encoding uses more than N bytes to encode a single char
05:14:42 <dcoutts> pick N :-)
05:14:52 <mux> dcoutts: but if we do that, we can end up with remaining bytes endlessly, and finally call iconv() N times when we could have called it once
05:14:57 <mauke> N=100
05:15:01 <dcoutts> so we'd copy that many over into a temp buf and the trailing bytes from the last buffer
05:15:10 <mux> dcoutts: which may or may not have performance implications
05:15:14 <dcoutts> mux: ah, that's the cunning bit..
05:15:40 <dcoutts> mux: we *expect* iconv to tell us that this tiny buffer is incomplete, that it also has trailing bytes
05:15:57 <dcoutts> mux: but in the mean time it will have dealt with the single split char from the last buffer
05:16:29 <dcoutts> mux: so it'll tell us how many trailing bytes are in this tiny buffer, and from that we calculate how many bytes offset we need to start into the next proper buffer
05:16:41 <dcoutts> see?
05:16:59 <mux> yep
05:17:04 <mux> indeed
05:17:06 <mux> that's good
05:17:17 <dcoutts> so it means making more calls to iconv than we'd like
05:17:24 <dcoutts> but it's not too bad, just complicated
05:17:27 <mux> yes, but only one more
05:17:34 <mux> and not lots
05:17:38 <twanvl> And it only happens if there are split chars
05:17:47 <dcoutts> right
05:17:59 <dcoutts> and we assume our input buffers are fairly big
05:18:03 <mux> N=8 sounds reasonable to me
05:18:11 <mux> what do you say?
05:18:11 <dozer> OK, it seems there's an example of the sort of thing I want with Foldable and Map - what's the easiest way for me to view the libraries source code?
05:18:12 <mauke> depends on your definition of "char"
05:18:38 <dcoutts> mux: yeah, probably. I think iconv may even have an upper limit specified somewhere, but don't quote me on that.
05:19:34 <int-e> dcoutts: you could try to find a good limit dynamically; whenever iconv fails to find a char in the small buffer, increase N
05:19:38 <joelr1> is there a version of uncurry for 3 elements?
05:19:42 <joelr1> @djin
05:19:42 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
05:19:49 <mux> right
05:20:08 <mux> we take N=8 as a start, if we ever get 9 remaining chars, then we know we need to increase
05:20:10 <int-e> dcoutts: and maybe have special loops for N=4 and N=8, and a loop for larger, variable N. (for later, as an optimization)
05:20:38 <mauke> @djinn (a -> b -> c -> d) -> (a, b, c) -> d
05:20:38 <lambdabot> f a (b, c, d) = a b c d
05:20:45 <mauke> @. pl djinn (a -> b -> c -> d) -> (a, b, c) -> d
05:20:45 <lambdabot> (line 1, column 15):
05:20:46 <lambdabot> unexpected "="
05:20:46 <lambdabot> expecting variable, "(", operator or end of input
05:21:07 <mauke> @hoogle (a -> b -> c -> d) -> (a, b, c) -> d
05:21:08 <lambdabot> No matches, try a more general search
05:21:08 <mux> dcoutts: well that scheme sounds fairly sane and reasonabe to me, and shouldn't be too hard to implement
05:21:14 <dcoutts> mux: if you're interested in coding it, you might find some of the code in the zlib binding useful/interesting
05:21:53 <mux> dcoutts: maybe later, I'm battling with FreeBSD's routing code that sucks big time, causing one of our server to crash periodically heh
05:21:54 <dcoutts> mux: I'd use a pre-allocated tiny buffer, since it'll always only be needed as an input buffer, not an output one, so it can be reused and mutated
05:22:10 <dcoutts> mux: np, I might try it some time
05:36:46 <LPhas> hi
05:36:56 <LPhas> someone managed to get http://www.mail-archive.com/cabal-devel@haskell.org/msg00418.html work?
05:36:57 <lambdabot> Title: Added RPM generation capability to Cabal
05:45:33 <dozer> ?patebin
05:45:33 <lambdabot> Unknown command, try @list
05:45:40 <ndm> @seen sorear
05:45:40 <lambdabot> I saw sorear leaving #ghc, #haskell-overflow, #haskell-blah and #haskell 7h 2m 31s ago, and .
05:45:45 <LPhas> ?pastebin
05:45:45 <lambdabot> Unknown command, try @list
05:45:55 <LPhas> @google hpaste
05:45:58 <lambdabot> http://hpaste.org/
05:45:58 <lambdabot> Title: recent - hpaste
05:46:00 <mauke> @paste
05:46:00 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:46:39 <hpaste>  dozer pasted "hiding kinds" at http://hpaste.org/1417
05:46:47 <nominolo> @where binary
05:46:48 <lambdabot> I know nothing about binary.
05:46:59 <nominolo> @hoogle binary
05:46:59 <lambdabot> System.Win32.File.BinaryType :: type BinaryType
05:47:00 <lambdabot> System.Win32.File.sCS_32BIT_BINARY :: BinaryType
05:47:00 <lambdabot> System.Win32.File.sCS_DOS_BINARY :: BinaryType
05:47:08 <nominolo> er ..
05:47:17 <ndm> @google binary haskell strike force
05:47:18 <lambdabot> http://www.cse.unsw.edu.au/~dons/binary.html
05:47:18 <lambdabot> Title: Data.Binary - efficient, pure binary serialisation for Haskell
05:47:27 <ndm> @where+ binary http://www.cse.unsw.edu.au/~dons/binary.html
05:47:28 <lambdabot> Done.
05:48:08 <mauke> @quote
05:48:09 <lambdabot> jlouis says: Q: When does one know he has programmed too much Haskell? A: When he uses == and /= in everyday IRC chat or when he tries to fix a relationship by passing himself as a continuation
05:52:30 <dozer> so, using code like I pasted above, I can leave any number of type parameters 'free' when instantiating a class as long as I want to 'hide' them from the beginning of the  list
05:53:16 <dozer> e.g. for Map, I can create instances over Map, Map k or Map k v. I can't see how to create an instance over Map ? v where k is left free, if you see what I mean
05:53:30 <quicksilver> only with a type synonym I believe
05:53:40 <quicksilver> type Map' v k = Map k v
05:53:50 <doserj> type synonyms are not allowed in instance declarations
05:53:57 <dozer> that's what I try in that post, and it doesn't like it
05:54:00 <quicksilver> ah, a newtype then
05:54:05 <doserj> ghc allows them, if they are fully applied
05:55:18 <dozer> doserj: yeah, but I'm trying to get the ability to shuffle the type parameter order, so that I can partially apply it :(
05:55:53 <dozer> if I used newtype, then it would be the newtype that inhabited the class, not the original type so it doesn't directly help me
05:56:21 <quicksilver> I believe that's a known deficiency
05:56:31 <quicksilver> either you have to make a 'fully applied' version of the class
05:56:37 <quicksilver> or you have to use newtypes
05:56:46 <quicksilver> partial type application is not a complete solution :(
05:56:59 <doserj> (you could also change the data declaration, of course...)
06:02:46 <dozer> Thanks quicksilver. Do you know if this is a limitation of the logic or an implementation thing?
06:02:56 <dozer> Perhaps I should raise it on a mailing list
06:03:12 <quicksilver> dozer: there are fairly deep reasons
06:03:22 <quicksilver> dozer: which I am not qualified to explain :)
06:03:38 <quicksilver> dozer: full type level lambdas make type inference undecidable, I believe
06:04:06 <dozer> pants - ok then
06:05:11 <int-e> ok, lambdabot should have most of here @where knowledge back :)
06:05:44 <dylan> let's just have type level lambdas and improve the kind system to help make sure our type-level programs are decidable. ;)
06:06:00 * bringert is trying to figure out the proper bibtex for citing an IRC conversation
06:06:13 <quicksilver> bringert: 'personal correspondance' ?
06:06:25 <quicksilver> bringert: 'unpublished remarks'
06:06:29 <dozer> yeah, the same as a bloke you spoke to in the pub
06:06:35 <bringert> what, there isn't an @irc class?
06:06:43 <quicksilver> some bloke in the pub wrote my phd thesis for me
06:06:49 <quicksilver> nice chap, I should really have bought him a drink
06:06:54 <dozer> I wrote mine in the pub
06:07:02 <lispy> bringert: hehe
06:07:10 <bringert> I use the irc://host:port/channel URL, and a date
06:07:24 <bringert> the someone could dig out the logs if the wanted
06:07:27 <ddarius> There was a paper on how to add some type level lambdas while still preserving termination.
06:07:57 <ddarius> But yes, even allowing partially applied type synonyms makes the type level Turing complete.
06:08:17 <pharm> I guess you could punt the proof of termination to a proof tool like Coq?
06:08:32 <LPhas> @paste
06:08:33 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:09:51 <hpaste>  LPhas pasted "compiling http://www.mail-archive.com/cabal-devel@haskell.org/msg00418.html" at http://hpaste.org/1418
06:11:57 <LPhas> Is HsTime.hs something from cabal?
06:12:05 <LPhas> re: HsTime.h
06:12:57 <doserj> is this related to http://hackage.haskell.org/trac/ghc/ticket/1135 ?
06:12:59 <lambdabot> Title: #1135 (HsTime.h isn't installed by the Windows installer) - GHC - Trac
06:15:31 <ndm> @seen dmwit
06:15:31 <lambdabot> dmwit is in #haskell-blah and #haskell. I last heard dmwit speak 3h 39m 5s ago.
06:22:58 <ddarius> dozer: Oleg has a mailinglist post that demonstrates how to simulate type level lambdas that would let you do what you want in a crazy way.
06:23:28 <dozer> ooh! in haskell-cafe?
06:26:04 <ddarius> I'm pretty sure, or haskell.
06:31:36 <twobitsprite> this isn't really a haskell question, but I thought you all would have some ideas... I'm looking for something to replace make... I figured haskell has its own revision control, is there a build system that haskellers usually prefer over make?
06:32:08 <aFlag> Hi, I had to write a little assembler for helping me out on a class assignment, and since I'm not very good with monads and I was on a hurry, I used mostly pure functions. But I actually load all the file in memory and I'm doing way too many iterations through it. I think I could improve it by using monads for the lexer function. What kind of monad should I use if I want it to keep a certain state, so I call it and it gives me a new token from the file each 
06:32:33 <ToRA> ndm: is it you asking about type equality on #haskell-cafe?
06:32:40 <aFlag> twobitsprite: I usually simple use ghc --make for simple projects
06:32:52 <aFlag> twobitsprite: for something larger there's cabal I guess.
06:32:54 <ndm> ToRA: yes
06:33:14 <ToRA> ndm: have a look at section 3 of Baars and Swierstra's Typing Dynamic Typing
06:33:28 <ToRA> ndm: the typeclass you want will be same :: forall f . f a -> f b -> Bool
06:33:29 <ndm> @google Typing Dynamic Typing Baars
06:33:31 <lambdabot> http://www.cs.uu.nl/~arthurb/dynamic.html
06:33:32 <lambdabot> Title: Typing Dynamic Typing
06:33:46 <ToRA> ndm: (for mindbending reasons i'll let them explain)
06:34:24 <ndm> ToRA: thanks for the link, i was hoping not to use rank-2 types, but i'll see what they say - appreciated
06:45:23 <vvv> @where isInfixOf
06:45:23 <lambdabot> I know nothing about isinfixof.
06:45:44 <vvv> @hoogle isPrefixOf
06:45:45 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
06:45:52 <vvv> @where List
06:45:52 <lambdabot> I know nothing about list.
06:46:01 <vvv> @help
06:46:02 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:46:08 <int-e> @index isPrefixOf
06:46:09 <lambdabot> Data.List
06:46:25 <vvv> @help darcs
06:46:25 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:47:16 <vvv> And where the darcs repository for `Data.List' is? :)
06:47:39 <vvv> @darcs Data.List
06:47:40 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
06:47:50 <vvv> @botsnack
06:47:51 <lambdabot> :)
06:48:18 <vvv> int-e: thanks)
06:48:58 <vvv> @list
06:48:58 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
06:49:45 <vvv> @help where
06:49:45 <lambdabot> where <key>. Return element associated with key
06:49:53 <vvv> @help where+
06:49:53 <lambdabot> where+ <key> <elem>. Define an association
06:51:15 <tsp> while my sparc is killing itself trying to factor 171783386661508931145981567768179685699801015564853041317582623299750568847373614733296133080952330, can prime numbers be expressed in the form x^y? or am I stuck with them
06:51:56 <int-e> tsp: yes, with y = 1.
06:52:39 <mux> heh
06:52:56 <ndm> @seen dons
06:52:57 <lambdabot> dons is in #haskell-soc and #haskell. I last heard dons speak 8h 20m 59s ago.
06:53:08 <pejo> tsp, there are certain classes, Mersenne primes for example.
06:53:16 <ndm> hmm, the binary library seems to be going into an infinite loop :(
06:53:26 <mux> mersenne primes are of the form 2^x - 1 IIRC
06:55:06 <tsp> damn
06:55:37 <opqdonut> mux: correct
06:55:49 <tsp> if you run that through dc, you'll get a plug to donate to my webSite. Unfortunately, I'm still trying to figure out how to make that number smaller.
06:56:28 <tsp> I guess I could change the string a bit and hope to get a better number.
06:58:12 <quicksilver> tsp: http://www.alpertron.com.ar/ECM.HTM
06:58:14 <lambdabot> Title: Factorization using the Elliptic Curve Method
06:58:22 <tsp> I suck at math
06:58:23 <quicksilver> tsp: you should be able to factorise it in a minute or two on that webpage
06:58:44 <quicksilver> tsp: it has some really very large prime factors, you won't find the answer helps you much :(
06:59:18 <raxas> tsp: your funny number is divisible by 2, 5 and 10 on the first look by farmer logic
06:59:26 <opqdonut> :D
07:00:00 <mux> Factorization complete in 0d 0h 0m 35s
07:00:06 <mux> this java applet is quite cool :-)
07:00:34 <mux> 171 783386 661508 931145 981567 768179 685699 801015 564853 041317 582623
07:00:34 <mux> 299750 568847 373614 733296 133080 952330 = 2 x 3 ^ 2 x 5 x 11 x 19 x 5827 x
07:00:34 <mux> 25 440703 x 108 740579 x 21 796846 147707 122119 x 25 991595 466318 195273
07:00:34 <mux> 121662 272632 846039 996151 800364 996553
07:00:41 <mux> mmm, a bit huge, sorry
07:00:54 <tsp> heh 171 is a prime?
07:01:31 <int-e> no, 171 is not prime
07:01:47 <mux> 171 is the upper digits of your number...
07:01:52 <nominolo> > 171 `elem` nubBy(((>1).).gcd)[2..]
07:01:56 <lambdabot> Terminated
07:02:12 <int-e> tsp: anyway it is *very* unlikely that you'll be able to compress that number without exploiting that it's a base 256 number with limited range of digits.
07:02:16 <nominolo> > 171 `elem` takeWhile (<200) $ nubBy(((>1).).gcd)[2..]
07:02:17 <lambdabot>  Couldn't match expected type `[t]'
07:02:18 <sieni> > ((/) 171 3)
07:02:20 <lambdabot>  57.0
07:02:21 <raxas> 171 = 3 * 57 by brain logic
07:02:28 <sieni> > ((/) 57 3)
07:02:30 <lambdabot>  19.0
07:02:36 <sieni> pling
07:02:50 <nominolo> 1 + 7 + 1 = 9, hence divisible by 3
07:03:26 <sieni> of course, since the sum of the digits of 171 is 9, it must be divisible by 9
07:03:44 <mux> no
07:03:52 <norpan> yes
07:04:00 <mux> sorry, read backwards
07:05:01 <tsp> that page didn't work weird
07:05:08 <tsp> oh, java application
07:05:24 * mux wonders if tsp cares to read what people are saying in this channel!
07:06:17 <gleb> Hello everyone. Does anyone haskell-mode that comes with Ubuntu Dapper? When I hit C-l or C-z, I get error messages about undefined functions.
07:06:47 <tsp> int-e: ah
07:06:52 <gleb> Oops, typo. That should be read as "Does anyone _use_ haskell-mode..."
07:08:10 <tsp> good point, since it only uses 7 out of the 8 bits
07:08:18 <quicksilver> much less than 7
07:08:23 <quicksilver> it uses about 5.2 bits
07:09:48 <ndm> @tell dmwit don't really understand your question, why are you interested in those two operators - i've never heard of them, i suspect sorear added them
07:09:49 <lambdabot> Consider it noted.
07:13:41 <nominolo> gleb: what do you expect C-l C-z to do?
07:13:49 <nominolo> oh, you mean C-c C-z?
07:15:26 <gleb> nominolo: Yes, sorry, I've meant C-c C-l and C-c C-z respectively
07:15:36 <mauke> why does ST hate me :(
07:15:41 <nominolo> gleb: did you get any errors while loading?
07:15:52 <gleb> nominolo: no
07:16:18 <nominolo> gleb: did you compile your .emacs?
07:16:48 <gleb> nominolo: I've installed emacs-snapshot and haskell-mode using apt-get; that's all I did
07:17:12 <nominolo> gleb: ok, you might then need to manually add it to your .emacs file
07:17:34 <gleb> nominolo: what exactly?
07:17:53 <gleb> nominolo: syntax highlighting seems to work out-of-the-box
07:18:09 <nominolo> oh
07:18:36 <mauke> why isn't STRef an instance of Ord?
07:18:45 <nominolo> do the functions appear when you press C-h m ?
07:19:09 <nominolo> mauke: why should it?
07:19:10 <therp> mauke: STRef as in references for STM? why should it be an instance?
07:19:19 <mauke> because I want to put them in a set/map
07:19:39 <nominolo> mauke: as keys?
07:19:42 <mauke> yes
07:20:00 <nominolo> can't you derive your own instance?
07:20:02 <nominolo> er
07:20:04 <nominolo> not derive
07:20:07 <nominolo> but implement
07:20:11 <mauke> how?
07:20:15 <mauke> I can't get at the pointers
07:21:13 <eumenides> what does ST have to do with STM?
07:21:19 <mauke> eumenides: nothing
07:21:20 <nominolo> data MySTRef { key :: Int, stref :: STRef }
07:21:23 <gleb> nominolo: yes, I see a couple haskell-related functions on C-h m, but they are insufficient for normal work
07:21:25 <mauke> > runST (do { a <- newSTRef 42; b <- newSTRef 42; return (a == b) })
07:21:26 <lambdabot>   Not in scope: `newSTRef'
07:21:43 <nominolo> gleb: so, they're not listed there?  that's strange
07:22:00 <mauke> nominolo: blargh, then I need a name generator
07:22:32 <gleb> nominolo: yes. Key-binding is correct, but Emacs fails to find appropriate function
07:22:47 <therp> enmenides: nothing, I confused it with TVar
07:22:57 <mauke> maybe I'm just going to use List.nub and assoc lists
07:23:55 <nominolo> mauke: maybe you don't need to put into a map?
07:25:08 <mauke> nominolo: runST doesn't seem to let me return the structure containing STRefs as-is, so I want to transform it into something that doesn't contain STRefs
07:25:30 <mauke> which I was going to do by keeping a dictionary of already translated STRefs
07:25:54 <nominolo> yes, of course it doesn't.  otherwise you would brake referential transparency
07:26:25 <mauke> bah, Haskell needs pointers :-)
07:26:29 <nomeata> Hi. Is there a reason why FilePaths makeRelative "path/a" "path/a/b/c" does not return "c"?
07:26:35 <nominolo> once, you're outside ST you must no longer modify the contents
07:27:22 <mauke> I don't need to modify the contents
07:28:01 <nominolo> yes, but the only way to guarantee this to the compiler is not to use STRefs anymore
07:28:11 <andun> is it possible to build a data type from a list in haskell? something like (MyType x_1 .. x_n) where xs are taken from a list.
07:28:22 <mauke> yep, so explicit data structure freezing
07:28:41 <nominolo> mauke: exactly
07:29:14 <nominolo> andun: sort of
07:29:39 <nominolo> you need to use some generic programming tools, though, if you don't want to write it all by yourself
07:32:53 <andun> nominolo: what do you mean?
07:33:48 <nominolo> well, the simplest way is to just do: toMyType [x1, x2, x3, x4] = MyType x1 x2 x3 x4
07:34:16 <andun> yes, that's the exact thing i'm trying to avoid :P
07:34:20 <andun> but it's probably not possible :(
07:34:21 <nominolo> but if you don't like to write this all down by hand, you need more magic
07:34:30 <nominolo> oh, it is, it is
07:34:36 <andun> ^_^
07:34:48 <nominolo> though, it requires some type-level trickery or code-generation
07:34:57 <andun> that's out of the question :P
07:35:01 <andun> (i think)
07:35:03 <nominolo> not sure if you want to get into this ;)
07:35:42 <nominolo> it's certainly not newbie material
07:35:44 <andun> in ruby, there is a nice operator, *, which "rips" the elements out of a list for cases like this
07:36:21 <andun> so you could say func (*foo) where foo is a list that's expanded to func(foo[0], foo[1] and so on)
07:36:24 <LeCamarade> andun: How would ir work?
07:36:38 <LeCamarade> s/ir/it/
07:37:13 <LeCamarade> andun: Waiting ... My lambda to clone it is half-done ...
07:37:18 <gleb> If anyone is interested, I solved my little problem with (require 'inf-haskell) in my .emacs
07:39:17 <emu> gleb: what was the problem?
07:39:53 <emu> you installed haskell-mode with apt-get (debian?) and it didn't work when you tried to load a file?
07:40:02 <gleb> emu: exactly
07:40:10 <emu> like, hitting C-c C-l in a file
07:40:15 <gleb> emu: to be precise it was ubuntu dapper
07:40:21 <gleb> emu: yep
07:40:30 <emu> i guess if it works great, but that sounds bad.  it should autoload that.
07:40:41 <emu> maybe the package isn't setup correctly
07:40:56 <gleb> emu: I thought so too
07:42:08 <andun> LeCamarade: i'll have to go now, but i'm looking forward to seeing it when i come back ;)
07:42:28 <emu> gleb: what version did apt install of haskell mode for you? there's a relatively recent release.
07:43:48 <gleb> emu: What's the best way to find it out?
07:44:04 <emu> dpkg -s haskell-mode
07:44:50 <gleb> emu: ok, thanks, I've already looked in the haskell-mode sources. It is v 2.1
07:45:06 <mauke> huhu
07:45:07 <mauke> *Main> test (Literal VCons)
07:45:08 <mauke> Right (TyCon2 TFun (TyVar "a") (TyCon1 TList (TyVar "a")))
07:45:32 <emu> 2.3 is out
07:46:03 <gleb> emu: well this version is default in dapper
07:46:21 <emu> np. if you have trouble, refer to http://haskell.org/haskellwiki/Haskell_mode_for_Emacs on how to install a newer version from src
07:46:22 <lambdabot> Title: Haskell mode for Emacs - HaskellWiki
07:46:28 <emu> also general help
07:47:12 <gleb> emu: thanks for a link!
07:48:58 <chessguy> 'morning haskellers
07:51:56 <mux> hello chessguy
07:52:03 <emu> david house around?
07:52:12 <hpaste>  petekaz pasted "Anyone here use the new regex libraries?" at http://hpaste.org/1419
07:52:18 <chessguy> ?seen dmhouse
07:52:19 <lambdabot> I haven't seen dmhouse.
07:52:50 <petekaz> Does Chris Kuklewicz hang out in here?
07:53:20 <chessguy> hm, that name looks familiar, but i couldn't tell you his nick
07:53:32 <petekaz> thanks cheeseguy
07:53:38 <chessguy> ahem
07:53:41 <chessguy> that's "chess"
07:54:23 <petekaz> I know ... for the past 8 months I thought you were "cheeseguy", but one day I saw you talking about chess and then it dawned on me that you were in fact "chessguy".
07:54:40 <petekaz> I've been dying to say cheeseguy at least once though ...
07:54:59 <dylan> I thought it was cheese too
07:55:13 <petekaz> I kept thinking, this guy must really like cheese.
07:55:14 <chessguy> 'morning ndm
07:55:25 <ndm> morning chessguy
07:55:33 <chessguy> your new proposition library looks interesting
07:56:13 <chessguy> i'll have to play with it when i get home. the documentation looks a little incomplete
07:56:15 <ndm> good good :)
07:56:32 <ndm> the documentation is reasonable i think, did you take a look at the haddock docs? that example shows most of the bits
07:56:46 <ndm> if there is anything that looks unclear let me know
07:56:49 <chessguy> yes, i saw the example, but it looked like that was all there was
07:56:57 <chessguy> unless i missed something
07:56:59 <ndm> not much more
07:57:00 <chessguy> ?where ndm
07:57:01 <lambdabot> I know nothing about ndm.
07:57:08 <ndm> but the example is carefully chosen to cover most of the concepts
07:57:15 <ndm> @where+ ndm http://www.cs.york.ac.uk/~ndm/
07:57:16 <lambdabot> Done.
07:57:23 <chessguy> a complete reference of the exported functions would be nice
07:57:26 <ndm> @where+ proposition http://www.cs.york.ac.uk/~ndm/proposition/
07:57:27 <lambdabot> Done.
07:57:32 <chessguy> like the normal libraries
07:57:35 <ndm> chessguy: there is, in in the haddock index
07:57:46 <chessguy> oh ok, let me look again
07:58:03 <ndm> plus if you look at Data.Proposition.Internal that lists about 95% of the libary
07:58:28 <chessguy> ah, i see it now
07:58:59 <ndm> if any bit is unclear, do let me know - or if i need to direct people at that more forcefully?
07:59:11 <chessguy> ?remember apfelmus Programming
07:59:12 <chessguy> in Haskell is like dual-wielding two light sabers whereas programming in
07:59:12 <chessguy> imperative languages is like being equipped with a blunt kitchen knife.
07:59:12 <lambdabot> Done.
07:59:16 <chessguy> augh
07:59:25 <ndm> the documentation isn't great, i wrote it all yesterday, and just hte minimum to make it useful
07:59:37 <chessguy> ?remember apfelmus Programming in Haskell is like dual-wielding two light sabers whereas programming in imperative languages is like being equipped with a blunt kitchen knife.
07:59:38 <lambdabot> Done.
07:59:54 <chessguy> ndm: ok, i'll poke around, maybe i'll submit a docs patch
08:00:08 <ndm> chessguy: cool, any documentation patches would be appreciated for this one
08:00:08 <joelr1> @pl f a b = f1 a b x
08:00:08 <lambdabot> f = flip flip x . f1
08:00:33 <ndm> chessguy: the library used to be a critical part of my PhD, now its useful, but not that useful - so i thought i'd release it rather than let it bitrot
08:02:20 <chessguy> wow, that's a large class for Prop
08:02:36 <ndm> its basically the entire library :)
08:03:09 <chessguy> i wonder if there could be a more minimal Prop class, with the other functions moved to subclasses
08:03:51 <ndm> the Prop class is actually pretty minimal, a lot of the methods have defaults
08:04:33 <ndm> about 8 of them are required to be implemented for every Prop, the rest can be implemented on top of those
08:04:44 <chessguy> ah, ok. i guess i have to look at the source to see the defaults
08:05:19 <ndm> if i moved to propToBool and propFromBool, i could eliminate another 2 methods from the essential ones
08:06:44 <mauke> oh god, this is going to be very painful
08:07:27 <mauke> why are pointer-heavy algorithms so hard to write in haskell
08:08:12 <chessguy> that's why they call it a "high level" language
08:08:59 <mauke> maybe I should read how to do this right first :-)
08:12:20 <therp> why would you like to write pointer heavy algorithms? :)
08:13:08 <chessguy> ndm: what the heck is this?
08:13:09 <chessguy> data PropSimple a
08:13:09 <chessguy> show/hide Instances
08:13:09 <chessguy> Prop PropSimple
08:13:09 <chessguy> (Eq a, ??? a) => Eq (PropSimple a)
08:13:09 <chessguy> Show a => Show (PropSimple a)
08:13:15 <chessguy> what's the ???
08:13:43 <fasta> Why isn't the following implemented by default? Just 5 + Just 9 => Just 14 and Just 5 + Nothing Just 5
08:14:11 <int-e> > liftM2 (+) (Just 5) Nothing
08:14:13 <lambdabot>  Nothing
08:14:13 <earthy> mauke: they are not, you just have to understand where the pointers are.
08:14:16 <mux> > liftM (+) (Just 1) (Just 3)
08:14:17 <lambdabot>  Couldn't match expected type `Maybe t1 -> t'
08:14:21 <eumenides> There should be an option for derive to generate qualified instances, else the derived Binary conflicts badly with State and I have to selectively search-replace it every time I run derive
08:14:22 <mux> > liftM2 (+) (Just 1) (Just 3)
08:14:22 <chessguy> @instances-importing Num
08:14:24 <lambdabot>  Just 4
08:14:24 <lambdabot> Double, Float, Int, Integer
08:14:37 <mauke> therp: I don't know how to do it without pointers
08:14:48 <mauke> earthy: yeah, exactly. that requires thinking
08:14:52 <chessguy> i suppose you could have instance (Num a) => Num (Maybe a)
08:14:57 <earthy> all pointermangling requires thinking. duh.
08:15:07 <int-e> fasta: they aren't proper numbers.
08:15:14 <therp> mauke: ah, ok, I can't help you with that. I can only give you the motivation that once adepted to functional pure programming it will feel much more natural to you
08:15:28 <ndm> chessguy: no idea, its just haddock going wrong - all haddocks fault
08:15:28 <fasta> int-e: because?
08:15:41 <mauke> earthy: not for me
08:15:48 <fasta> int-e: Who defined what a proper number is?
08:16:02 <int-e> fasta: because Nothing != Just 0 but Just 1 + Nothing == Just 1 + Just 0, for example.
08:16:33 <[sid]> hello!
08:16:36 <int-e> fasta: anyway, it's just not generally useful enough. Doubles don't form a ring either but they're useful.
08:16:37 <mauke> huh? Maybe Integer are proper numbers
08:16:53 <mauke> I have the instance somewhere here
08:17:27 <mauke> *Main> Just 1 + Nothing
08:17:27 <mauke> Nothing
08:17:37 <fasta> I am not sure why having Just 1 + Nothing == Just 1 + Just 0 would be a problem.
08:17:38 <chessguy> mauke: shouldn't any (Num a) =>  Maybe a be a Num?
08:17:46 <mrchebas> a puzzle: if i have "x <- somemonad" in a do block, how can i give a signature for "x"? i would like something similar to "x::type"
08:17:49 <fasta> I don't care about it anyway,
08:17:57 <[sid]> I've got to: "extract words from a string, store and manipulate information in a binary search tree, and order lists". Anybody got any links?
08:17:58 <mauke> chessguy: (Num a, Monad m) => Num (m a)
08:18:21 <chessguy> mauke: oh, good point. is that not default?
08:18:29 <LPhas> mauke: cool
08:18:31 <mauke> no
08:18:46 <chessguy> weird, it should be
08:19:05 <int-e> mauke: hmm. what do you do with the required Eq instance then
08:19:08 <int-e> mauke: ?
08:19:13 <mauke> here's an implementation: http://rafb.net/p/Hh2rfe89.html
08:19:14 <lambdabot> Title: Nopaste - No description
08:19:21 <mauke> which may not work in ghc6.6
08:20:56 <kbral> Hi.. where i found more about the operator "$" ?
08:21:04 <fasta> [sid]: how about "words".."Data.Tree"... "sort" ?
08:21:06 <mauke> @src ($)
08:21:06 <lambdabot> f $ x = f x
08:21:21 <chessguy> kbral: what would you like to know?
08:22:42 <mux> how would you call such a function? foo x y = fromEnum x - fromEnum y
08:22:49 <mux> distance?
08:23:40 <int-e> offset maybe. but that's quite loaded as well.
08:24:21 <mux> difference is a bit too long to my liking
08:24:35 <mauke> delta
08:25:36 <mux> mauke: nice, thanks
08:26:38 <joelr1> how do you property write this in haskel? strat.C.stratVars
08:26:46 <joelr1> meaning that stratVars is in module C
08:26:54 <joelr1> argh
08:26:59 <joelr1> never mind
08:27:48 <joelr1> struggling with record updates here, it's been a while
08:28:09 <glguy> record { field = value }
08:28:09 <lambdabot> glguy: You have 3 new messages. '/msg lambdabot @messages' to read them.
08:29:07 <joelr1> glguy: the issue is doing field = field + 1
08:29:14 <joelr1> glguy: except my field is a Map
08:29:34 <joelr1> glguy: and the field method is in module C
08:29:48 <mauke> v { field = field v + 1 }
08:30:09 <joelr1> aha!
08:30:18 <chessguy> mauke: why are you importing Reader?
08:30:31 <mauke> chessguy: to get instance Monad ((->) e)
08:30:36 <joelr1> mauke: thank you
08:31:05 <mauke> chessguy: now numbers can be functions
08:31:42 <mauke> *Main> (sin + sqrt * pi + 1) 42
08:31:42 <mauke> 20.44332582002289
08:33:03 <chessguy> hermm
08:33:07 <chessguy> that's...interesting
08:35:08 <int-e> mauke: and 42 23 is 42?
08:37:21 <mauke> yes
08:37:35 <mauke> since fromIntegral = return . fromIntegral and return = const
08:38:51 <chessguy> mauke: could there be other instances of (Num a, Monad m) Num (m a) ?
08:41:01 <mauke> huh?
08:41:08 <int-e> [0,1] + [0,2] /= [0,2] + [0,1] ... is this good?
08:44:47 <int-e> chessguy: note that mauke's instance for Maybe a differs from fasta's.
08:45:11 <chessguy> ugh, work calls
08:45:40 <int-e> chessguy: and also order of evaluation matters in monads. you can define  a + b  in two obvious ways
08:46:25 <balodja> hi. how to specify 'target' to be a [Char] in target:"null" ?
08:46:51 <int-e> balodja: what do you want to do?
08:46:58 <int-e> balodja: maybe  target ++ "null" ?
08:47:46 <balodja> I have String rest. and then I'm doing:
08:47:48 <balodja>         case (split " " rest) of
08:47:50 <balodja>             target:"null" ->
08:48:45 <int-e> oh, try  target:"null":[]  or, equivalently,   [target, "null"]  as a pattern
08:49:01 <balodja> hm, thanks
08:49:29 <int-e> in   x:"null"   "null" has type [Char] so x will always have type Char.
08:49:47 <int-e> oh, note that  a:b:c  is parsed as  a:(b:c)
09:24:30 <LeCamarade> ?where Plugins
09:24:31 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
09:49:47 <mux> I'm not very successful at generating discussions on libraries@
09:50:33 <fasta> mux: best way to generate discussion is to dump a huge useful pile of code there, I guess.
09:52:17 <shapr> hi!
09:52:38 <fasta> hej
09:52:46 <shapr> hoi fasta
09:57:27 <thedward> Is there an equivalent to sleep in Haskell? That'll just stop and do nothing for a specified amount of time?
09:57:44 <dmwit> ?hoogle sleep
09:57:45 <lambdabot> System.Win32.Process.sleep :: DWORD -> IO ()
09:57:53 <dmwit> Hmmm...
09:57:53 <lambdabot> dmwit: You have 1 new message. '/msg lambdabot @messages' to read it.
09:58:38 <thedward> @hoogle threadDelay
09:58:39 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
09:58:46 <thedward> I found that, but it appears to be GHC only
09:58:57 <dmwit> thedward: I know there's like a System.Posix or so, it should be in there, right?
09:59:06 <dmwit> I'm having a bit of trouble finding it, though.
09:59:25 <ddarius> @hoogle Int -> IO ()
09:59:26 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
09:59:26 <lambdabot> System.Console.Readline.setCompletionQueryItems :: Int -> IO ()
09:59:26 <lambdabot> System.Console.Readline.setEnd :: Int -> IO ()
09:59:39 <thedward> ah, found it
10:00:06 <thedward> System.Posix.Unistd
10:00:12 <dmwit> ?seen ndm
10:00:13 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 1h 13m 33s ago, and .
10:00:14 <thedward> but will the posix stuff work on windows?
10:00:21 <dmwit> ?seen sorear
10:00:22 <lambdabot> I saw sorear leaving #ghc, #haskell-overflow, #haskell-blah and #haskell 11h 17m 12s ago, and .
10:00:30 <opqdonut> thedward: windows is posix compliant iirc
10:00:56 <opqdonut> thedward: see http://en.wikipedia.org/wiki/Posix#Fully_POSIX-compliant
10:02:00 <mux> this page is misleading
10:03:52 <opqdonut> mux: how so?
10:04:46 <mux> reading it, people could think Windows is more POSIX compliant than *BSD or Linux
10:05:00 <mux> needless to say, this isn't true
10:05:13 <opqdonut> is it needless?
10:05:57 <opqdonut> not all linux distros have posix-compliant userlands for example
10:06:07 <mux> well take Linux apart if you want
10:06:18 <opqdonut> the point here is probably that linux isn't posix-certified
10:06:24 <opqdonut> so there are no "guarantees"
10:06:30 <mux> I don't care much about Linux
10:07:17 <mux> Windows is only POSIX compliant in a very, very twisted way
10:07:22 <mux> this is all about money
10:07:30 <opqdonut> true
10:07:34 <opqdonut> mostly everything is
10:07:43 <mux> SUSv3 isn't ;-) or less so.
10:07:54 <aFlag> I don't care about posix
10:08:08 <chessguy_work> i don't care about compliance, so there!
10:08:18 <opqdonut> i don't care about "is"
10:08:32 <dmwit> i don't care
10:08:33 <shapr> Is emacs a good choice for Haskell editing on windows?
10:08:40 <opqdonut> always a good choice
10:08:50 <opqdonut> and haskell-mode is quite nice
10:08:52 <mux> emacs isn't posix compliant!
10:08:58 <shapr> just wondering what windows haskellers usually use.
10:09:05 <chessguy_work> @slap mux
10:09:05 * lambdabot beats up mux
10:09:17 * mux rubs nose
10:09:24 <mux> nasty lambdabot
10:10:30 <mux> you cannot even open a binary file under windows in a POSIX compliant way and yet it's listed as certified, bleh
10:10:32 <LeCamarade> @slap LeCamarade
10:10:33 * lambdabot slaps LeCamarade
10:10:50 * LeCamarade has woken up, after the slap.
10:12:26 <opqdonut> @slap me
10:12:27 * lambdabot slaps opqdonut
10:12:32 <opqdonut> hi lambdabot
10:15:11 <LeCamarade> mux: You must have the cc(1) command, for example, to be POSIX-compliant. Yet Ubuntu, before you apt-get stuff, has no cc. Linux per se is not POSIX-compliant. It is a kernel, which can be used to run Windows, if that is your kind of thing.
10:15:49 <LeCamarade> And without ghc(1) you are not USABLE-compliant.
10:15:57 <opqdonut> well neither does windows have cc(1) or even ed(1)
10:16:02 <chessguy_work> is there an easy way to do definite integrals in haskell?
10:16:25 <opqdonut> i think posix-userland is not included int the certification
10:17:17 <mux> LeCamarade: as I said, my point wasn't so much about Linux anyways.
10:17:23 <LeCamarade> opqdonut: It is. Otherwise my sandals would be POSIX-compliant.
10:17:54 <mux> I can tell you other things that make Linux not posix compliant :-)
10:17:59 <LeCamarade> mux: Yeah, I get it. After all, you said you didn't care. :oD Nobody does. No ghc(1), no use.
10:18:15 <opqdonut> LeCamarade: well how do you explain windows lacking ed and being posix-compl.
10:18:50 <mux> $$$
10:19:03 <opqdonut> and i guess your sandals don't implement the socket api or posix signals or posix regex or ...
10:19:09 <opqdonut> posix is much more than the userland
10:19:09 <mux> the answer to 99 questions out of 100 is money
10:20:05 <mux> windows misses so much to be POSIX compliant
10:20:17 <mux> each time I hear that it gets me all angry
10:21:13 <LeCamarade> opqdonut: I don't know (or care) about Windows' compliance, but it must be in the same way that the Linux LiveCD is - no ed(1), no cc(1), but still compliant - maybe that it can implement the required stuff if anybody bothers to do the compiling. As you said, threads and FILE and stdin/stdout/sterr ... with that in place, I think my sandals would be compliant.
10:24:11 <mux> pthreads are optional IIRC
10:24:13 <mux> many things are
10:25:09 <allbery_b> hrm.
10:26:03 <allbery_b> gtk2hs question:  in C I can watch for an attribute of a widget to change by registering a handler for signal "notify::<attribute name>".  I don;t see an appropriate way to do this from gtk2hs?
10:26:19 <allbery_b> (this is recommended for e.g. monirtoring the state of a GtkExpander)
10:34:50 <Saizan> ?docs System.Posix
10:34:51 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix.html
10:45:27 <jargonjustin> Does Eq String handle unicode normalization and if so which kind?
10:45:35 <tic> kolmodin, this one?
10:45:41 <kolmodin> tic: nope
10:46:00 <tic> damn.
10:46:34 <kolmodin> :)
10:47:04 <dmhouse> jargonjustin: I doubt it. As a general rule, Haskell has little Unicode support. Chars are big enough to store Unicode, but I don't think there's support for encoding/decoding them as UTF-8 or otherwise.
10:47:05 <lambdabot> dmhouse: You have 2 new messages. '/msg lambdabot @messages' to read them.
10:48:57 <sjanssen> jargonjustin: no normalization, the Strings are compared code point by code point (and each code point is compared according to it's number, not necessarily any locale conventions)
10:50:31 * allbery_b thinks he's found a gtk2hs gconf bug
10:50:41 <allbery_b> I save an [Int] (65535, 0, 0)
10:50:54 <allbery_b> it's saved as [0, 0, 65535] and read back in as such
10:51:22 <allbery_b> if I resave it it gets saved as [65535, 0, 0]
10:51:39 <allbery_b> and flips between them ...
10:55:08 <chessguy_work> what do you mean by 'save'?
10:55:16 <MarcWeber> Do you know a server web interface which you can use to administrate different repositories ?
10:55:30 <opqdonut> allbery_b: sounds like a byte order bug
10:58:49 <shapr> @yow!
10:58:49 <lambdabot> YOW!!!  I am having fun!!!
10:59:02 <allbery_b> doesn't act like a byte order bug
10:59:19 <allbery_b> it acts like an array order bug, on write (more precisely on gconfSet)
10:59:25 <allbery_b> s/array/list/
10:59:37 <icarroll> @quote fun
10:59:38 <lambdabot> edwardk says: heh i should probably just type up the problem specification in haskell and click compile. funny how that seems to yield the answer ;)
10:59:41 <chessguy_work> @get-shapr
10:59:41 <lambdabot> shapr!!
10:59:45 <allbery_b> if I save random color triples, the values are correct, just reversed
11:00:10 <shapr> chessguy!
11:00:58 <mauke> ah, so that's the problem with recursive types
11:01:15 <mauke> they send my algorithm into an infinite loop :/
11:01:30 <allbery_b> chessguy_work: I'm watching the gconf registry with gconf-editor, the value written to the registry has the list values reversed
11:02:05 <allbery_b> when it reads them back out it does so in the expected order, though (so they're reversed)
11:02:27 <allbery_b> if both of them reversed this would not be an issue, aside from possible confusion
11:05:14 <icarroll> What would be a good name for this function? \p xs -> map snd $ filter (p . fst) xs
11:05:23 <dmwit> > let mergeSort xs [] = xs; mergeSort xs (y:ys) = takeWhile (<= y) xs : y : mergeSort ys (dropWhile (<= y) xs in mergeSort [2,5,78,90] [1,4,6,7]
11:05:24 <lambdabot>  Parse error
11:05:34 <dmwit> > let mergeSort xs [] = xs; mergeSort xs (y:ys) = takeWhile (<= y) xs : y : mergeSort ys (dropWhile (<= y)) xs in mergeSort [2,5,78,90] [1,4,6,7]
11:05:35 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
11:05:35 <lambdabot>       Expected...
11:05:48 <dmwit> > let mergeSort xs [] = xs; mergeSort xs (y:ys) = takeWhile (<= y) xs ++ y : mergeSort ys (dropWhile (<= y)) xs in mergeSort [2,5,78,90] [1,4,6,7]
11:05:49 <lambdabot>  Couldn't match expected type `[a] -> [a]'
11:08:23 <dmwit> > let mergeSort xs [] = xs; mergeSort xs (y:ys) = takeWhile (<= y) xs ++ y : mergeSort ys (dropWhile (<= y) xs) in mergeSort [0,2,5,78,90] [1,4,6,7] -- got it!
11:08:25 <lambdabot>  [0,1,2,4,5,6,7,78,90]
11:09:17 <mauke> how do I find infinite loops?
11:15:39 <dmwit> ?hoogle (a -> Bool) -> [a] -> ([a], [a])
11:15:40 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
11:15:40 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
11:15:40 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
11:32:11 <mauke> what does "72:17-72:21 Found Monad but expected a <conop>" mean?
11:32:30 <mauke> it's from hmake -hat
11:33:02 <ibid> it *sounds* like it's expecting something that starts with : and finds Monad
11:33:06 <ibid> but i don't know
11:34:06 <lucca> <coinop>; Found Monad but expected 25 cents
11:34:59 <emu> unsafePerformCoinop
11:35:34 <icarroll> unsafePerformCoinop :: Coin Fun -> Fun
11:36:42 <ibid> "conop" refers to stuff that starts with colon (and also names in `backquotes`)
11:36:55 <ibid> hmm, *uppercase-starting* names, that is
11:38:05 <mauke> that doesn't make any sense
11:38:11 <chessguy_work> conop = infix constructors?
11:38:15 <mauke> this is in a deriving (...) list
11:38:20 <chessguy_work> s/rs/r/
11:38:31 <ibid> chessguy_work: yep
11:42:42 <dons> moin
11:42:43 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:43:02 <chessguy_work> hi dons
11:43:17 <jyp> hey dons
11:43:46 <chessguy_work> dons must get more messages than everyone else combined :)
11:43:58 <dons> hey guys
11:45:31 <kolmodin> hia
11:46:38 <Botje> @quote
11:46:38 <lambdabot> goltrpoat says: Lemma: three cats chasing a deranged cricket all over the living room at 4am does not provide for a good reading environment
11:46:41 <mauke> how do I get a stack/execution trace?
11:47:23 <shapr> Good morning dons!
11:47:37 <dons> hey shapr
11:48:01 <mauke> hat doesn't like my code; +RTS -xc doesn't seem to be useful for infinite loops
11:48:24 <dons> hmm. it should be possible to just run with -prof -auto-all and then +RTS -p
11:48:31 <dons> and the loop would be on top of the call stack. I think
11:49:44 <mauke> should that option give me a ti.prof file?
11:50:12 <mauke> oh wait, I may be an idiot
11:50:18 <mauke> freeze                         Main                  80.0   93.5
11:51:24 <mauke> argh, and I can't test it without freeze
11:52:36 <mauke> how do I print a graph with cycles in it? :-)
11:53:08 <Botje> you could keep a list of visited nodes?
11:53:38 <Botje> but then i'm probably over-simplifying.
11:53:47 <mauke> how do I compare two infinite nodes?
11:54:03 <dons> up to some limit?
11:54:05 <Botje> don't they have some kind of label?
11:54:41 <mauke> yes, actually
11:54:52 <mauke> it's all pointers so that should be relatively easy
11:54:57 <mauke> and by pointers I mean STRef
11:55:30 <Saizan> ?where http
11:55:31 <lambdabot> http://www.haskell.org/http/
11:57:34 <mux> ok, how can I disable the building of docs with GHC if I don't have haddock and can't install it easily?
11:57:50 <mux> and that I would do fine without docs
11:59:04 <dons> mm. you do need haddock I think.
11:59:08 <dons> but not docbook
11:59:16 <mux> blah
11:59:22 <dons> why can't you build haddock?
11:59:35 <mux> docbook.
11:59:35 <dons> there's freebsd binaries too, iirc
11:59:40 <mux> yeah
11:59:45 <dons> hmm
11:59:59 <mux> I don't like using packages much, and would do fine without haddock, so I wanted to know if I could go without it
12:00:04 <dons> i don't get why i don't have this issue on openbsd. where i don't have a recent docbook
12:00:20 <dons> maybe haddock from darcs doesn't need the docbook dep
12:00:21 <mux> my docbook is too recent, and the port may be broken somehow too
12:00:24 <dons> just the port requires it.
12:00:29 <mux> but I don't feel like fixing it
12:00:32 <dons> can you try haddock from darcs instead?
12:00:39 <mux> I'd rather not :)
12:00:39 <dons> rather than the port tree version?
12:00:53 <dons> why? its just a binary. and *that* works on openbsd, wo/ docbook
12:01:04 <dons> don't be scared of a little cabal :-)
12:01:08 <mux> I'm not
12:01:21 <mux> I have few free time to devote to this
12:01:26 <mux> so I just installed a haddock package
12:01:50 <dons> ok. given an hour, you could build and install alex and happy from darcs ,then build ghc head.
12:01:51 <mauke> yay, it works!
12:02:28 <mux> dons: and in 30 minutes my already-running GHC HEAD build should be finished :-P
12:04:02 <Cheery> I'd like to do a thing like: ["  ", "    ", "      "..] and merge it with thing like: ["nn", "bb", "cc", "dd"..], do you know a thing which would do this already?
12:04:22 <chessguy_work> what result are you looking for?
12:04:27 <Cheery> ie. I'd like to get something like this as result: ["  nn", "    bb", "      cc"..]
12:04:37 <chessguy_work> zipWith (++)
12:05:23 <dons> looks like a zipWith to me too :-)
12:05:32 <chessguy_work> > zipWith (++) ["  ", "    ", "      "]  ["nn", "bb", "cc", "dd"..]
12:05:33 <lambdabot>  Parse error
12:05:35 <mux> > take 10 $ iterate (' ':) ""
12:05:37 <lambdabot>  [""," ","  ","   ","    ","     ","      ","       ","        ","         "]
12:05:38 <chessguy_work> > zipWith (++) ["  ", "    ", "      "]  ["nn", "bb", "cc", "dd"]
12:05:40 <lambdabot>  ["  nn","    bb","      cc"]
12:05:57 <Cheery> yes.
12:06:09 <mux> zipWith (++) (iterate (' ':) "") ["nn", "bb", "cc"]
12:06:15 <mux> > zipWith (++) (iterate (' ':) "") ["nn", "bb", "cc"]
12:06:15 <dons> isn't that nice and concise.
12:06:16 <lambdabot>  ["nn"," bb","  cc"]
12:06:22 <chessguy_work> yes, that's more general
12:06:23 <dons> i wonder what it would look like in perl?
12:06:28 <Cheery> @type iterate
12:06:30 <lambdabot> forall a. (a -> a) -> a -> [a]
12:06:44 <chessguy_work> > iterate (+1) 1
12:06:46 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
12:06:53 <dons> I suspect the haskell is cleaner here, since zipWith doesn't have an obvious perl counterpart?
12:07:03 <dons> HOFs++
12:08:26 <Cheery> hmm, what if I want to select the number of spaces I want to indent with?
12:08:33 <Botje> List::MoreUtils has zip
12:08:40 <mux> for (0..$#foo) { $foo[$_] = " " x $_ . $foo }
12:08:44 <mux> perl would be something like this
12:08:52 <Cheery> @type repeat
12:08:54 <mux> not so horrible ;-)
12:08:54 <lambdabot> forall a. a -> [a]
12:09:14 <chessguy_work> mux, concise, maybe, but still horrible :)
12:09:18 <mux> heh.
12:09:24 <Cheery> > take 3 (repeat ' ')
12:09:26 <lambdabot>  "   "
12:09:32 <chessguy_work> ?src repeat
12:09:33 <lambdabot> repeat x = xs where xs = x : xs
12:09:36 <mauke> use List::MoreUtils qw(pairwise); pairwise { $a . $b } @x, $y
12:10:34 <mux> dons: what's HOF ?
12:11:06 <dons> higher order functions
12:11:10 <mux> oh
12:11:11 <dons> like zipWith or map or foldr
12:11:22 <mux> yeah I know what those are ;-)
12:11:25 <mauke> someone give me a non-recursive definition to test my type checker
12:11:37 <dons> ?type const
12:11:39 <lambdabot> forall a b. a -> b -> a
12:11:40 <dons> ?src const
12:11:40 <lambdabot> const x _ = x
12:11:45 <dons> like that?
12:12:04 <Cheery> @djinn take 3 . repeat
12:12:05 <lambdabot> Cannot parse command
12:12:13 <mauke> hmm, something's broken
12:12:25 <chessguy_work> @type take 3 . repeat
12:12:28 <lambdabot> forall a. a -> [a]
12:12:40 <chessguy_work> @djinn a -> [a]
12:12:41 <lambdabot> -- f cannot be realized.
12:12:46 <dons> no lists.
12:12:46 <chessguy_work> eh?
12:12:57 <chessguy_work> oh, djinn can't handle lists?
12:13:04 <mux> gmake[1]: Leaving directory `/usr/home/mux/haskell/ghc'
12:13:06 <mux> yay!
12:13:35 <mauke> *Main> test (Abstract "x" (Abstract "_" (Variable "x")))
12:13:35 <mauke> Right (a -> (b -> a))
12:13:53 <mauke> yay!
12:14:23 <encryptio> @pl \f x -> f x x
12:14:23 <lambdabot> join
12:14:36 <emu> @type join
12:14:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:14:42 <bringert> Igloo: where should tests for core libraries go? (the unix package in this case)
12:15:07 <mauke> *Main> test (Abstract "f" (Abstract "x" (Apply (Apply (Variable "f") (Variable "x")) (Variable "x"))))
12:15:10 <mauke> Right ((a -> (a -> b)) -> (a -> b))
12:15:39 <mauke> ok, I think this type inference thingy works
12:16:02 <Igloo> bringert: libraries/unix/tests
12:16:17 <Igloo> bringert++ # providor of tests
12:16:31 <mux> that deserves a karma+ :)
12:16:41 <Igloo> Are the two not equivalent?
12:16:51 <bringert> Igloo: are those run by the nightly tests?
12:16:55 <mux> I think lambdabot would have said something if it interpreted this one
12:17:22 * mux bbl
12:17:22 <Igloo> bringert: should be, although I haven't actually checked myself since Simon split them out of testsuite!
12:17:46 <bringert> Igloo: what should they look like? there's nothing there now for the unix package
12:18:02 <Igloo> bringert: In 6.6 branch or the HEAD?
12:18:19 <bringert> ah, I was looking at 6.6
12:18:38 <bringert> now I see them in head
12:19:20 <Igloo> Ah, they're in places like testsuite/tests/ghc-regress/lib/Posix in 6.6
12:19:51 <bringert> I'll test with the 6.6 release for now
12:19:54 <Uncountable> i remember there was an inverse function of foldr (was it foldl?). what was it called?
12:20:05 <Igloo> unfoldr
12:20:21 <Uncountable> @hoogle unfoldr
12:20:22 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
12:20:22 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
12:20:26 <Uncountable> thanks
12:26:06 <bringert> Igloo: the current complete ghc complete darcs tar ball is a bit old
12:26:48 <bringert> why am I getting only 87 kB/s download from darcs.haskell.org?
12:27:11 <dons> http://programming.reddit.com/info/1iedx/comments
12:27:13 <lambdabot> Title: Zen and the Art of Functional Programming (reddit.com)
12:27:20 <dons> bringert: hmm. ChilliX was complaining of something similar recently
12:27:35 <dons> bringert: it was faster to pull from sydney to new york, than via darcs.haskell.org
12:27:38 <dons> something fishy...
12:28:01 <bringert> it jumps up and down,  60-130 kB/s
12:31:53 <dons> http://programming.reddit.com/info/1iegf/comments
12:31:54 <lambdabot> Title: Haskell at OSCON 07 (reddit.com)
12:39:09 * edwardk waves hello.
12:39:27 <edwardk> Does hsplugins work on windows and ghc-6.6 yet?
12:41:45 <chessguy_work> as far as i know it does
12:41:47 <bos> ghc-6.6 yes, windows unknown
12:41:58 <nelhage> heh
12:42:02 <nelhage> err, mischan.
12:42:11 <edwardk> i remembered it working on ghc-6.6 but i thought someone said at the time that it wasn't working on 6.6 under windows
12:42:47 <chessguy_work> oh, that i don't know about
12:43:17 <mauke> yay, my algorithm found the correct type for \self n -> if n < 2 then 1 else n * self (n - 1)
12:44:05 <chessguy_work> @type \self n -> if n < 2 then 1 else n * self (n - 1)
12:44:08 <lambdabot> forall a. (Ord a, Num a) => (a -> a) -> a -> a
12:44:16 <hyrax42> woops
12:44:34 <chessguy_work> mauke: with the class constraints and all?
12:44:38 <mauke> heh, no
12:44:41 <mauke> just ((TInt -> TInt) -> (TInt -> TInt))
12:44:54 <chessguy_work> that's still pretty good
12:45:08 <ketil> Anybody have a pointer to the "tagged pointer" feature promised for ghc 6.8
12:45:10 <ketil> ?
12:45:16 <mauke> yeah, considering that this is my first attempt at type inference
12:45:28 <chessguy_work> you should blog about it
12:45:36 <mauke> I just wish there was a way to do it without pointers :-)
12:46:24 <icarroll> mauke: what do you mean?
12:46:46 <mauke> my algorithm is totally imperative
12:46:53 <chessguy_work> ewww
12:47:11 <mauke> type RType s = STRef s (STRef s (Type s))
12:47:14 <mauke> double pointers!
12:47:25 <icarroll> bad juju!
12:48:01 <hpaste>  mauke pasted "ti.hs" at http://hpaste.org/1421
12:48:08 <edwardk> > fix (\self n -> if n < 2 then 1 else n * self (n - 1)) `fmap` [1..]
12:48:10 <lambdabot>  [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87...
12:48:18 <edwardk> whee i is smart.
12:48:24 <icarroll> heh
12:48:25 <mauke> blah, truncated again
12:48:43 <mauke> if you want to see the code, http://rafb.net/p/BelleL27.html
12:48:45 <lambdabot> Title: Nopaste - No description
12:49:21 <bringert> do all reasonable unix systems have a user called "root" and a group called "wheel"?
12:49:36 <icarroll> bringert: root yes, wheel no
12:49:39 <edwardk> wheel is somewhat optional, but pretty much all of them have root.
12:49:41 <icarroll> wheel is a bsd thing IIRC
12:49:55 <bringert> is there a group name that all reasonable unsix systems have?
12:49:58 <bringert> unix
12:50:06 <icarroll> mauke: -- you don't see this == very funny :)
12:50:17 <emu> root
12:50:27 <Codex_> it even uses unsafeperformio...
12:50:28 <bos> you'll find a wheel group on most linux distros, but it's not used for anything.
12:50:39 <emu> wheel is sometimes used for su access
12:50:43 <mauke> Codex_: just for building the dictionary
12:50:44 <edwardk> yeah
12:50:59 <bringert> emu: OS X doesn't seem to have a group called root
12:51:01 <mauke> that part is semi-broken anyway
12:51:19 <emu> bringert: mine does
12:51:31 <mauke> bringert: nobody
12:51:47 <edwardk> bringert: any particular reason why you are fixated on an omnipresent group name?
12:51:48 <emu> (by mine i mean my old OS X laptop)
12:52:07 <bringert> edwardk: I'm writing tests for System.Posix.User
12:52:16 <edwardk> mauke: nobody isn't always present, its usage is somewhat deprecated because it conflates lots of different insecure processes into one protection domain
12:52:19 <bringert> and I want something to feed to getGroupEntryForName
12:52:47 <bringert> I guess I can just use the first thing that getAllGroupEntries returns
12:52:50 <edwardk> head -1 /etc/group | cut -d: -f1 =)
12:53:57 <bringert> heh
12:54:04 <bos> you can't rely on /etc/group existing
12:54:12 <edwardk> true
12:55:17 <bringert> hmm, would there always be a group with gid 0?
12:55:28 <edwardk> nope, coz you don't HAVE to give groups names
12:55:30 <icarroll> likely, but not guaranteed
12:55:45 <edwardk> technically there is no requirement that a posix system have any named groups
12:55:50 <edwardk> its just useful
12:56:20 <bringert> grr
12:56:41 <dozer> if I want a pre-defined monad that stores a result or an error message (ala a throwable exception) which should I chose?
12:56:47 <icarroll> you could get the current group id...
12:56:49 <dons> http://programming.reddit.com/info/1ierc/comments
12:56:50 <lambdabot> Title: Introduction to Nested Parallel Array Programming in Haskell (slides, pdf) (redd ...
12:57:06 <dons> dozer: hmm, sounds like ErrorT ? or just Error?
12:57:11 <edwardk> icarroll: but there is no guarantee its named
12:57:11 <dons> either returns a result or an exception?
12:57:16 <bringert> icarroll: that could be an unnamed group, but it's probably the best I can do
12:57:28 <dozer> thx dons
12:58:33 <edwardk> dons: does hsplugins work on windows in ghc6.6?
12:58:35 <dozer> yeah, Error looks like precicely what I want
13:00:03 <dozer> hum, I've seen this before but never understood what it did:
13:00:13 <dozer> class Monad m => MonadError e m | m -> e where
13:00:13 <dons> edwardk: i don't think so. there's some error involving undefined symbols from the std C lib.
13:00:18 <dozer> what does the clause after | mean?
13:00:19 <edwardk> ick
13:00:44 <Saizan> dozer, that m indetifies univocally e
13:00:49 <edwardk> is it just something no one has had time to look at or is it something that looks particularly hairy?
13:01:11 <edwardk> i.e. should i not move forward with development on somethat that needs hsplugins and would need to be able to run on windows as well as linux..
13:01:34 <icarroll> @where functional dependencies
13:01:35 <lambdabot> I know nothing about functional.
13:01:36 <Gu2> dons: that is a great pdf
13:01:41 <icarroll> @where fundeps
13:01:42 <lambdabot> I know nothing about fundeps.
13:01:54 <Saizan> in fact thee.g. instance (Error e) => MonadError e (Either e) where ..
13:01:57 <bringert> anyone here with OS X?
13:02:08 * icarroll raises hand.
13:02:13 <bringert> if so, could you run "System.Posix.User.getEffectiveUserName" in ghci?
13:02:24 <bringert> I get *** Exception: getUserEntryForID: failed (Unknown error: -1)
13:02:26 <icarroll> k 1sec
13:02:32 <ndm> @seen dons
13:02:33 <lambdabot> dons is in #haskell-soc and #haskell. I last heard dons speak 2m 20s ago.
13:02:40 <ndm> @seen sorear
13:02:40 <lambdabot> I saw sorear leaving #ghc, #haskell-overflow, #haskell-blah and #haskell 14h 19m 30s ago, and .
13:02:41 <ndm> @seen dmwit
13:02:42 <lambdabot> dmwit is in #haskell-blah and #haskell. I last heard dmwit speak 1h 44m 42s ago.
13:02:49 <dmwit> ndm: I'm still having trouble compiling Derive.
13:02:57 <ndm> dons: i was getting a bug with Yhc when moving from an old binary library to the new one - it seems to non-terminate!
13:03:12 <ndm> dmwit: with a fresh checkout? and what version of GHC? and what error message?
13:03:38 <dmwit> ndm: Yes, a fresh checkout, with GHC 6.4.1.
13:03:42 <dmwit> It says:
13:03:51 <dmwit> ./Language/Haskell/TH/Helper.hs:111:26: Not in scope: `isSymbol'
13:03:53 <icarroll> bringert: I get the same error as you.
13:03:57 <dmwit> (Same for isPunctuation.)
13:04:08 <bringert> icarroll: thanks
13:04:34 <ndm> dmwit: i can only guess those are in template haskell shipped with GHC 6.6, but not 6.4.1 - i'll find them in the new version and copy them over - give me a minute
13:04:38 <bringert> icarroll: what GHC version and architecture is that?
13:05:21 <dons> ndm, what doesn't terminate? the yhc compiler?? the type checker?
13:05:29 <dons> or ghc?
13:06:07 <ndm> dons: the compiled library, when loading a file with decodeFile
13:06:28 <icarroll> bringert: ghc-6.6 native x86
13:07:08 <bringert> icarroll: ok, thanks, same as me. just wanted to se if more platforms were affected
13:07:39 <ndm> @index isSymbol
13:07:40 <lambdabot> bzzt
13:07:46 <dons> ndm, perhaps the formats changed in 0.3?
13:07:53 <dons> i'm not sure that's the case, but it seems possible.
13:07:54 <bringert> icarroll: it might be similar to this one
13:07:55 <bringert> http://hackage.haskell.org/trac/ghc/ticket/250
13:07:57 <lambdabot> Title: #250 (getUserEntryForID dies) - GHC - Trac
13:08:10 <dmwit> ndm: Maybe load it in ghci and use :i?
13:08:11 <ndm> dons: its taking a totally wrong format, so i can understand it going wrong, i was just wondering if it  is possible to non-terminate instead of crash?
13:08:27 <xerox> haha
13:08:39 <dons> seems unlikely, but I don't know where that would happen
13:09:12 <icarroll> bringert: it's the same function anyway
13:09:15 <dozer> Saizan: I'm putting "identifies univocally haskell" into google, but not finding a fluffy discription :(
13:09:19 <ndm> dmwit: same for me as well, this machine is on 6.4.1 too
13:09:39 <bringert> icarroll: and a semi-obscure platform...
13:09:40 <Saizan> dozer: search for functional dependecies
13:10:04 <ndm> dmwit: for the moment, go to that line and make it "isOper c = True"
13:10:11 <ndm> dmwit: for the moment, go to that line and make it "isOper c = False" - always false :)
13:10:27 <dmwit> Okay, thanks. =)
13:10:31 <ndm> dmwit: i'll investigate tomorrow at work with GHC 6.6, and copy the required bits over
13:10:54 <Saizan> dozer: http://en.wikibooks.org/wiki/Haskell/Advanced_type_classes
13:11:33 <dozer> thanks - I was about to start waiding through a Simon PJ pdf
13:12:44 <icarroll> Does anyone have a good idea for what to name this function:
13:12:46 <Heffalump> so, this left-to-right impredicative types thing
13:12:46 <icarroll> foo p xs = map snd $ filter (p . fst) xs
13:13:07 <dmwit> isolateBy?
13:14:23 <icarroll> dmwit: hmm
13:14:37 <dozer> got it, thanks Saizan
13:14:44 <icarroll> might be better than "projFilter", which is the best I've got so far.
13:14:53 <Heffalump> anyone used it?
13:15:09 <ndm> Heffalump: its basically for the runST $ examples
13:15:18 <Heffalump> it just seems like an almighty hack
13:15:37 <Heffalump> surely all that'll happen is people will come along complaining that foo `revApp` runST doesn't work
13:15:44 <ndm> yes :)
13:15:51 <ndm> they aren't proposing it for haskell'
13:16:12 <ndm> which means haskell' won't have any complete implementations of the rank-n stuff (apart from GHC 6.6, which will be old by hten)
13:16:54 <Heffalump> GHC won't be complete because it'll accept more programs?
13:17:03 <Heffalump> Surely without -fglasgow-exts it won't?
13:17:09 <ndm> unsure
13:17:20 <ndm> but they'll need haskell98, haskell' and GHC
13:17:28 <ndm> Simon also said it was breaking a few more things than expected
13:18:59 <Heffalump> oh good, perhaps he'll take it out again :-)
13:19:11 <ndm> what is your argument against it?
13:19:22 <ndm> i don't see its inclusion being bad, just will hopefully go unused
13:19:45 <Heffalump> it's too ad hoc
13:20:06 <xerox> is it normal that compiling GHC HEAD with extras complain that I don't have OpenGL >=2.2 already installed?
13:20:08 <xerox> the .deb is HOpenGL 2.1
13:20:12 <xerox> but I don't see why it should need the 2.2 already in....
13:20:18 <Heffalump> the practical benefit is not particularly great compared to the increased confusion it'll cause when people try to move on from runST $ ... to something else.
13:20:59 <Cale> I hope there are videos made of the lectures SPJ gives at OSCON.
13:21:01 <ndm> the logic is probably that people always complain about runST $, and hopefully most don't go beyond that
13:21:37 <Heffalump> do you think it's ever a feature that should end up in the standard?
13:21:41 <ndm> i must say i hate working with Scrap Your Boilerplate, bceause those rank-2 types keep screwing me over
13:21:44 <ndm> nope
13:21:57 <Heffalump> is it just an interim solution until GHC gets full impredicativity?
13:22:18 <ndm> i would be surprised if it didn't some day, but i don't think its on the radar yet
13:23:00 <Heffalump> well, otherwise I just don't see the value in having it there. If it'd never be in the standard, why have it in GHC?
13:23:10 <ndm> i get the feeling we get lots of type work on haskell because people need to find research proposals :)
13:23:19 <ndm> as a testing bed, i guess
13:23:25 <Heffalump> but a testing bed for what?
13:23:37 <ndm> exploring the design space, seeing if you can add impredictivity
13:23:53 <ndm> lots of crazy things make it into GHC that will never make it into a standard
13:24:23 <Heffalump> I don't really understand type systems, but I'd be quite surprised if this hack is a useful stepping stone in implementation terms towards full impredicativity.
13:24:31 <thorat> Heffalump: gcc has features crucial to ghc but never intended for standard
13:24:33 <ndm> i'm still suspicious that we need rank-2 types :)
13:24:38 <Heffalump> can you give an example of something where it was obvious from the outset it'd never make it in?
13:25:07 <ndm> hmm, no - actually
13:25:08 <Heffalump> thorat: I'd like to think the Haskell community has more principles than that ;-)
13:25:08 <thorat> (slightly OT I know)
13:25:21 <ndm> oh, yeah - the multiparameter type class confluence/termination rules
13:25:27 <Heffalump> also, gcc has a dual role as a sort-of portable assembler
13:25:37 <ndm> it was known at the time they were a bed of hacks, and that they'd have to be rethought
13:25:49 <Heffalump> but those are legitimately exploring the design space to see what people actually need, surely?
13:26:08 <ndm> yep
13:26:16 <ndm> i think thats the argument for impredictivity
13:26:26 <bringert> Igloo: the ghc-HEAD darcs repo tarball contains the darcs.haskell.org posthooks
13:26:39 <Heffalump> hmm. Not really convinced, cos it's such a specific and ad-hoc rule.
13:26:53 <Heffalump> left-to-rightness really ought not to matter for typechecking.
13:26:57 <ndm> me neither, but obviously someone was
13:27:48 <ndm> what scares me about rank-2 types is that inlining before type checking and after gives different results
13:28:07 <ndm> which makes certain things like $, which would be syntax in some programming languages, rathern than an operator
13:28:10 <ndm> behave differently
13:28:45 <Heffalump> as in you get programs that type-check and produce different results?
13:29:02 <ndm> no, one doesn't type check, one does
13:29:10 <ndm> runST x /= runST $ x
13:29:21 <ndm> even though in peoples minds, $ is syntax, not a function call
13:30:54 <ndm> i'd guess that if $ was treated as syntax, no one would have considered adding left-right type checking rules etc.
13:31:06 <Heffalump> hmm. That was one of my arguments against L2R impredicativity, that it'd make that inlining problem even more complicated
13:31:19 <edwardk> I do kind of wish that $ was syntax though
13:31:35 <ndm> i want to use $ in patterns on the right hand side :-)
13:31:36 <Heffalump> but it's true anyway, without rank-2 types
13:31:50 <edwardk> foo $ Just bar = ...; foo Nothing = ...
13:32:00 <Heffalump> g f = (f [2], f "2")  won't type check in H98
13:32:08 <Heffalump> but inline g length and it will
13:32:13 <edwardk> data List a = Nothing | Cons a $ List a
13:32:22 <edwardk> er Nil
13:32:34 <ndm> but that example is rare in Haskell, where as runST $ x is dead common
13:32:39 <edwardk> yeah
13:32:44 <ndm> although i see your point
13:33:12 <edwardk> i just realized that was probably why I always have such a hard time getting ST code to work right.
13:33:38 <ndm> i know when doing SYB stuff, never use $, never eta-reduce, never try giving a polymorphic type
13:33:53 <ndm> which upsets me :(
13:34:02 <Heffalump> never try using a polymorphic type?
13:34:17 <ndm> i wanted a peephole optimiser which operates on anything
13:34:27 <ndm> everywhere (mkT peep) x
13:34:33 <ndm> where peep :: Exp -> Exp (template haskell)
13:34:57 <ndm> i then couldn't export that function on type "a", i had to instantiate it to [Dec] and only export a very restricted version
13:37:31 <Heffalump> surely you could export it on the SYB type class?
13:38:06 <ndm> i tried, and failed
13:38:12 <ndm> @type everything
13:38:15 <lambdabot> forall r a. (Data a) => (r -> r -> r) -> GenericQ r -> a -> r
13:38:25 <Heffalump> @type everywhere
13:38:27 <lambdabot> forall a. (Data a) => (forall a1. (Data a1) => a1 -> a1) -> a -> a
13:38:33 <Heffalump> the second-order stuff is really confusing
13:38:44 <Heffalump> but the basic stuff like everywhere isn't too hard, I find
13:38:48 <ndm> by the time i had instantiated it i had a reall weird type, and no amount of convincing could make the type system export it
13:38:54 <Heffalump> @type mkT
13:38:57 <lambdabot> forall b a. (Typeable b, Typeable a) => (b -> b) -> a -> a
13:39:13 <ndm> even doing :t everything (mkT f) x, then pasting the resulting answer back, completely failed
13:39:22 <Heffalump> @type everywhere (mkT (id :: Int -> Int))
13:39:25 <lambdabot> forall a. (Data a) => a -> a
13:39:27 <Heffalump> interesting
13:39:35 * Heffalump --> experiment
13:39:44 <ndm> anyway, it wasn't fun
13:39:56 <ndm> the rank-2 stuff makes SYB significantly harder to work with
13:41:59 <Heffalump> what was the x in your things above?
13:42:29 <Heffalump> oh, wait, did you actually mean everything (as you said the second time) rather than everywhere?
13:42:39 <Heffalump> (which was what you said the first time)
13:42:41 <dozer> rather emparasingly, when I compile this I get "Could not find module `Control.Monad.Error':" - what do I need to add to my cabal file?
13:42:59 <Saizan> mtl
13:43:14 <Saizan> in build-depends:
13:43:25 <dozer> thanks
13:43:39 <ndm> Heffalump: everywhere, on any template haskell thing
13:43:56 <dozer> Setup.lhs: cannot satisfy dependency mtl-any
13:44:05 <dozer> I guess I don't have something installed or configured right
13:44:13 <dozer> (just apt getted ghc)
13:44:36 <xerox> mux, are you compiling the extras?
13:44:43 <Heffalump> ndm: what does a TH thing have to do with it?
13:44:59 <Heffalump> oh, that's what your x was, ok
13:45:12 <Heffalump> but were you trying to export something which was defined as everywhere (mkT foo) x ?
13:45:14 <ndm> Heffalump: nothing, it should ideally work on template haskell things, but anything is fine as well
13:45:18 <ndm> yep
13:45:27 <Heffalump> but that'd be of the same type as x
13:45:28 <Saizan> dozer: libghc6-mtl-dev (if you are using ghc6)
13:45:34 <ndm> peephole = everywhere (mkT peep) x
13:45:48 <ndm> i gave it Data a => a -> a, but got errors, can't remember what though
13:46:02 <Heffalump> but it doesn't have type Data a => a -> a
13:46:09 <Heffalump> it has type a, where a is the type of x
13:46:18 <Heffalump> everywhere (mkT peep) has type Data a => a -> a
13:46:20 <ndm> i mean peephole x = everywhere (mkT peep) x
13:46:25 <Heffalump> ahh
13:46:26 <dozer> got it :)
13:46:51 <Heffalump> ok, I have an example that loads in ghci exporting a function with that type and that definition
13:46:52 <ndm> i could well have got it wrong though
13:47:02 <ndm> hmm, may give it another go tomorrow
13:47:20 <ndm> i may  have had something small wrong, and got put off by scary type errors
13:47:31 <Heffalump> I can send you my example if you like, though it's only what we've discussed.
13:47:42 <ndm> nah, i know what it should look like
13:47:54 <ndm> thanks :)
13:47:57 <Heffalump> I know what you mean by scary type errors, when you get onto the more complicated SYB combinators I continually get stuck with them
13:48:09 <ndm> do you use SYB a lot for your job?
13:48:30 <ndm> i only use SYB for one single project, i use Play everywhere else, and its much simpler
13:48:48 <Heffalump> I don't use it at all at work (atm)
13:48:51 <ndm> but this project is a dependency of Play, and don't want to give myself bootstrap issues
13:49:06 <Heffalump> I think I've only used it in anger on some TH, actually.
13:49:17 <ndm> weird, so how did you get SYB instances for TH?
13:49:34 <Heffalump> I asked on here and someone gave me some TH to derive them :-)
13:49:35 <ndm> i had to use my derive tool to write them, and have them in a module now for easy use
13:49:41 <dozer>     Could not find module `Network.URI':      it is a member of package network-2.0, which is hidden
13:49:46 <Heffalump> and in one case I think I hacked the GHC source and recompiled.
13:50:11 <ndm> yeah, the standard SYB instance won't quite work because there is one unboxed Int#
13:50:15 <sjanssen> dozer: add network to your build-depends
13:50:19 <Heffalump> yeah, I think I manually wrote that one
13:50:27 <ndm> i derived them using template haskell, then hacked that one
13:50:43 <Heffalump> sounds rather familiar. Lots of duplicated effort :-/
13:50:59 <dozer> thanks sjanssen - does it show that I'm a Java coder?
13:51:00 <ndm> there was a ticket to add deriving Data,Typeable to the library
13:51:29 <ndm> and i've put mine up as Language.Haskell.TH.SYB - as a stand alone module, so others can reuse it if they want
13:51:40 <ndm> along with Language.Haskell.TH.Helper etc for making TH easier to use
13:51:51 <Heffalump> I was trying to implement my run monad idea (a function "run :: Monad m => m a -> a")
13:52:01 <Heffalump> but I never seem to get projects to a releasable state :-/
13:52:10 <ndm> i have been working on that all week
13:52:21 <Heffalump> I guess having a real job doesn't help.
13:52:28 <Heffalump> but I didn't when I was a student either
13:52:28 <ndm> i've made a 6 point dependency plan for releasing Catch, so have another 4 projects to release on the critical path
13:53:13 <ndm> my proposition library today was the first step to a released Catch
13:53:27 <Heffalump> small reusable components good
13:53:32 <ndm> yep
13:53:49 <ndm> i'm trying to do Hoogle 4 as that by design, tagsoup is one of the Hoogle libraries
13:53:51 <dons> Heffalump: hmm. why do you think that is?
13:54:01 <dons> the last 10% of release engineering a bit boring?
13:54:14 <ndm> putting together a working cabal file is a pain
13:54:21 <dons> there's plenty of other people here with similar hacks, that never get released. I wonder what we can do to improve that
13:54:22 <ndm> uploading to hackage is impossible...
13:54:24 <dons> ndm, mkcabal :-)
13:54:28 <dons> ndm, hmm??
13:54:38 <Heffalump> dons: think what is? that I personally never release stuff?
13:55:03 <dons> yeah, i'm interested to know what people think are the barriers to getting code released.
13:55:19 <dons> ndm, oh, the no-gnu-tar-on-windows issue?
13:55:28 <dons> ndm, did you get filepath on hackage, btw?
13:55:37 <dons> (I think that's *critical* now its a core package..)
13:55:42 <ndm> dons: not from me...
13:56:06 <dons> so filepath isn't on hackage? or did duncan put it up?
13:56:36 <sjanssen> @hackage filepath
13:56:37 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/filepath
13:56:49 <sjanssen> that link seems dead
13:56:52 <ndm> dons: not up, as far as i can tell
13:56:58 <dons> ok. that sucks massively.
13:57:18 <dons> all core and extra packages must be on hackage, I think.
13:57:24 <dons> we might have to make this official policy.
13:57:30 <sjanssen> all packages must be on hackage
13:57:34 <dons> otherwise the core/extra lib bundle games won't work.
13:57:49 <dons> ndm, can you please darcs dist to create a filepath tarball, and upload that?
13:58:06 <dons> sjanssen: do you know if the 'how to write a library' has a section on getting things on hackage?
13:58:09 <ndm> dons: no, on windows it places the directory structure slightly wrong, and won't upload
13:58:11 <dons> maybe we need to add that now.
13:58:17 <earthy> dons: and how do you get things installed from hackage, easily?
13:58:28 <earthy> because that's somewhat underdocumented
13:58:42 <dons> currently, wget $pkg_url ; tar xzf $pkg ; cd $pkg ; configure ; build ; install
13:58:53 <earthy> no, I asked for easily
13:59:01 <earthy> this doesn't pass the Doaitse test
13:59:09 <earthy> it doesn't come even close to passing the Linda test
13:59:09 <dons> ok. click on the hackage link on haskell.org
13:59:12 <dons> go to the package you want
13:59:17 <dons> download it by clicking
13:59:21 <earthy> nope, doesn't pass it either. ;)
13:59:22 <dons> untar it. build with cabal.
13:59:32 <dons> Doaitse wants cabal-get I suppose? :-)
13:59:41 <earthy> Linda wants cabal get
13:59:44 <dons> $ cabal-get filepath
13:59:55 <dons> we must have this by ghc 6.8
14:00:06 <Saizan> cabal-install install filepath works now :)
14:00:07 <dons> (just to automate the above process, and recursively pull other deps)
14:00:13 <dons> ok. good.
14:00:16 <earthy> Doaitse wants cut-and-paste foolproof recipes on hackage at least and cabal-get for better
14:00:17 <sjanssen> dons: yeah, it's there
14:00:19 <thedward> there should be a lambdabot extension that you can pass your root password and it'll install stuff for you. :)
14:00:30 <earthy> saizan: cabal-install is where? :)
14:00:37 <dons> its in the cabal darcs repo
14:00:48 <dons> but should be a standalone tool, with its own page, and it should come installed with ghc.
14:00:48 <Saizan> darcs.haskell.org/packages/caba-install
14:00:51 <earthy> (because it sure as hell can't be found following links from hackage)
14:00:53 <Saizan> darcs.haskell.org/packages/cabal-install
14:00:57 <Botje> thedward: pfft. I'm sure \bot is smart enough to hack root for itself :)
14:01:13 <thedward> heh
14:01:26 <dons> earthy: yeah, things are solidifying for 6.8, but as you see, the tools are scattered around a bit
14:01:38 * earthy knows the tools are scattered around
14:01:39 <dons> i expect we will have a proper story for this soonish though
14:01:54 <earthy> it's just that having this gel is pretty much essential
14:01:58 <dons> yeah
14:02:03 <earthy> I'm tempted to do it myself
14:02:15 <dons> we have a soc student working on hackage too, which should help further
14:02:16 <earthy> it's just that there's a deadline next week. ;)
14:02:22 <Saizan> (btw it has a bugged -w option support, but i have to make more tests)
14:02:47 <dons> sjanssen: re. promote. what do you think of my idea for reverting the cycle patch?
14:03:06 <earthy> oh, and we still don't have a good story for http
14:03:08 <earthy> which sucks as well
14:03:20 <earthy> (and makes it harder to do a cabal getter)
14:03:22 <dons> right. we have a SoC project for that too.
14:03:30 * earthy knows
14:03:35 <dons> but it would be good to pay for some top haskell devs to work on this stuff
14:03:40 <dons> using our mountains of lambda gold
14:03:46 <desp> earthy: we will!
14:03:47 <desp> :)
14:03:49 <sjanssen> dons: I'm okay with reverting it
14:03:50 <desp> I shall see to it
14:03:55 <earthy> desp: *GOOD*! :)
14:04:04 <arjanoosting> SyntaxNinja: are you around?
14:04:07 <Saizan> lambda gold :O
14:04:07 <dons> maybe some of the haskell companies should fund dev efforts :-)
14:04:20 <bos> desp is our designated http hacker for the summer.
14:04:27 <earthy> it's a pity Daan got hijacked by M$. :)
14:04:30 <dons> desp: woot! :-)
14:04:44 <ndm> dons: MS funds loads of Haskell hacking alredy
14:04:58 <dons> ndm, not so much on library work and infrastructure, as you know.
14:04:59 <earthy> but kosmikus should be at University of Utrecht as of august, IIRC
14:05:10 <earthy> maybe we can pester him into doing some lib development ;)
14:05:14 <dons> ndm, plenty of research, of course.
14:05:22 <dons> but implementing solid http etc, isn't research.
14:05:34 <earthy> dons: nope, it's development
14:05:40 * dons laments that too many problems are solved in pure FP now
14:05:48 <dons> so you can't get a paper out of implementing http.
14:05:53 <dons> i bet you could have done in 1995.
14:05:57 <earthy> hmmm
14:06:00 <opqdonut> :)
14:06:05 * earthy ponders
14:06:07 <dons> "A monadic approach to TCP/IP" hehe
14:06:14 <Heffalump> dons: personally I think it's because I have a relatively short attention span
14:06:15 <dons> "Comprehending HTTP"
14:06:17 <earthy> maybe, juuust maybe...
14:06:34 <Heffalump> and I either get bored with a project or get it good enough for my personal use before I get it good enough to release
14:06:44 <dons> Heffalump, hehe. ok.
14:06:48 <earthy> I might get some paid hours a week to develop production quality haskell libs as of jan 1st...
14:06:52 <earthy> hmmm....
14:06:55 <dons> hmm!
14:07:00 <Heffalump> if there was a fund to fund Haskellish projects I'd contribute.
14:07:09 <dons> yeah. that kind of thing. a bounty fund.
14:07:13 <ndm> dons: yeah, thats the annoying bit in debugging - Hat solved it, no one has a good ipmlementation
14:07:34 <dons> so what can we do about filepath on hackage, ndm?
14:07:48 <Heffalump> do other projects have bounty funds?
14:07:53 <dons> debian does.
14:07:54 <earthy> some do
14:07:57 <dons> i think maybe ruby does too?
14:08:02 <ndm> dons: give me a few days, get the bug reported to day worked out, then i'll get you/dcoutts to upload it
14:08:03 <Igloo> Debian doesn't
14:08:04 <bos> bounty funds aren't as useful as you might think.
14:08:12 <dons> Igloo: oh, was that a non-official thing?
14:08:15 <Heffalump> bos: cos most people need full-time jobs?
14:08:18 <ndm> they often split developers, into paid and not
14:08:33 <Igloo> dons: That was a one-off, and officially unofficial
14:08:47 <dons> official time per-week from currently employed haskell people would be more useful
14:08:57 <ndm> Igloo: and a bad idea, from what some people have said
14:09:01 <Heffalump> yeah, but only a company could fund that
14:09:02 <bos> they tend to have a negative effect on unpaid development, and they're not big enough or reliable enough to pay good developers to work consistently or for long
14:09:03 <dons> if say, 5 of us could get 1 day a week (paid) to work on haskell libs, that'd be better
14:09:15 <Heffalump> ndm: I don't think the Haskell community is as likely to get worked up about as the Debian community
14:09:18 <earthy> KDE development is actually partially funded by EU grants
14:09:18 <bos> yeah, consistent time always wins :-)
14:09:24 <Heffalump> it just doesn't have anything like the same level of difficult personalities
14:09:28 <ndm> dons: then what woudl you work on? whatever you wanted to? something the community deemed right?
14:09:36 <ndm> Heffalump: true, we are a more friendly bunch
14:09:43 <dons> we'd take jobs from the priority queue of projects
14:09:48 <bos> ndm: you think those are different things? :-)
14:09:49 * earthy should pull some knowledge from old friends...
14:09:53 <dons> the way we attacked binary io earlier this year
14:09:58 <joelr1> dons: just replied re: zero-arity tests in qc
14:10:03 <Igloo> dons: I'd love to be able to be paid full time to work on Haskell stuff, but 1 day a week doesn't really help as I'd need a full-time job anyway, and if I had one I'd probably spend just as much free-time on Haskell stuff regardless
14:10:14 <SyntaxNinja> hi arjanoosting
14:10:27 <Igloo> The extra money would be nice, of course, but I don't think it would make a huge difference (except it might alter what I spent my time on)
14:10:33 <Heffalump> Igloo: that's why I said only a company (i.e. the employer) can sponsor that
14:10:41 <Heffalump> though 4 day/week jobs might be possible in some areas
14:10:52 <earthy> actually, universities would be the perfect spot for this kind of development
14:10:53 <Igloo> Right, or split between multiple companies
14:11:08 <earthy> but *not* in software technology groups
14:11:11 <dons> joelr1: just replied to your reply.
14:11:16 <dons> joelr1: i meant to mention this earlier, actually
14:11:27 <Heffalump> Igloo: even split between multiple companies is harder, because the real cost to a company of having an employee work on something else than their productive stuff is quite high
14:11:30 * earthy points at Dazzle and draws a development model
14:11:36 <Heffalump> and hard to quantify
14:11:44 <earthy> (and good code came from Dazzle)
14:11:48 <ndm> universities would be possible, but you need the supervisor to encourage it
14:11:58 <Heffalump> earthy: URL?
14:12:05 <earthy> http://www.cs.uu.nl/dazzle/
14:12:07 <lambdabot> Title: Dazzle
14:12:07 <ndm> and also you shouldn't be able to submit a library to ICFP/Haskell Workshop without releasing it _first_
14:12:10 <arjanoosting> SyntaxNinja: hi
14:12:10 <joelr1> dons: mmm... i ought to look at the default driver then. any examples of custom ones?
14:12:14 <earthy> (yeah, it seems kinda dead, but it's still being maintained)
14:12:32 <SyntaxNinja> arjanoosting: how's it going?
14:12:34 <arjanoosting> SyntaxNinja: did you receive my email about hugs?
14:12:34 <earthy> (in fact, there's talk of trying to commercialize it)
14:12:42 <bos> ndm++
14:13:02 <ndm> earthy: was the complete code ever available for Dazzle?
14:13:07 <earthy> nope
14:13:23 <ndm> earthy: exactly, academic paper without hte code
14:13:28 <SyntaxNinja> arjanoosting: I use some hacked up thing I wouldn't show anyone else. feel free to do as you suggest, it sounds like a good idea.
14:13:29 <arjanoosting> SyntaxNinja: good. Etch is released so time for some Debian  work again
14:13:30 <earthy> mostly due to it being completely useless without SMiLE
14:13:39 <earthy> ndm: the XTC lib is available though
14:13:40 <SyntaxNinja> :)
14:13:56 <earthy> (even if that version won't work with 6.4... it's easily ported to 6.6)
14:14:06 <ndm> bos: but note that me and dons both wrote code-less ICFP papers, beause we have to with anonomous submissions :(
14:14:13 <arjanoosting> SyntaxNinja: do you prefer a specific version control system. I usually use svn (and svk)
14:14:21 <dons> joelr1: have a look at 'mycheck' in http://www.cse.unsw.edu.au/~dons/code/fps/tests/QuickCheckUtils.hs
14:14:23 <lambdabot> http://tinyurl.com/mwg5s
14:14:25 <earthy> and that XTC lib really is the most important lib that was developed there
14:14:30 <dons> joelr1: also , there's pqc on hackage, which is an smp parallel driver
14:14:30 <earthy> and it is production quality
14:14:44 <dons> joelr1: the place to start is with the (simple) driver in Test.QuickCheck, then hack it
14:14:50 <earthy> (but based on wxHaskell, which sadly still isn't really)
14:14:59 <joelr1> dons: what need does pqc fill?
14:15:02 <SyntaxNinja> arjanoosting: I'm fine with svn.
14:15:10 <joelr1> dons: thanks for the poiners
14:15:11 <SyntaxNinja> "svn is a fine version control system for many uses" ;)
14:15:13 <joelr1> pointers
14:15:20 <SyntaxNinja> dons: what are you up to?
14:15:31 <arjanoosting> :-)
14:15:41 <SyntaxNinja> dons: checking out the local bandwidth? ;)
14:15:49 <dons> joelr1: to run PQC on multiple cores
14:15:53 <dons> SyntaxNinja: yeah, its pretty sweet actually.
14:16:08 <dons> more responsive back to my sydney box, than from my home in sydney. :}
14:16:19 <SyntaxNinja> wow
14:16:19 <dons> SyntaxNinja: just hacking on my talk, staying out of the rain and dosed up on coffee :-)
14:16:28 <SyntaxNinja> dons: we don't consider this rain.
14:16:38 <dons> i think i got spoilt over the weekend then.
14:16:41 <earthy> ?
14:16:50 <SyntaxNinja> it was awesome over the weekend. went on a 25 mile bike ride :)
14:16:54 <earthy> dons is in western europe?
14:17:09 <dons> western US. :-)
14:17:12 <earthy> ah. :)
14:17:18 <jargonjustin_> What's a monomorphism restriction?
14:17:31 <dons> SyntaxNinja: nice!
14:17:37 <earthy> jargonjustin: it's when an argument has to have on specific type and cannot be polymorphic
14:17:48 <dons> SyntaxNinja: I heard one guy on saturday complaining it was too hot.
14:17:52 <SyntaxNinja> haha
14:17:56 <SyntaxNinja> that's a new one on me
14:18:16 <earthy> jargonjustin: e.g. it can not be 'id :: a -> a'
14:19:15 <procyon112> :t ($)
14:19:18 <lambdabot> forall a b. (a -> b) -> a -> b
14:19:46 <thorkilnaur> What is SYB?
14:19:56 <jargonjustin_> Okay, GHC complained that it couldn't a particular function signature I made explicit, nor could it infer the signature if I commented out my declaration.  It could handle the explicit declaration of a less general type, where can I read about monomorphism and how it affects things like this?
14:20:00 <earthy> thorkilnaur: an approach to generic programming
14:20:06 <Igloo> thorkilnaur: "Scrap Your Boilerplate", a series of papers
14:20:20 <thorkilnaur> Thanks
14:20:24 <earthy> thorkilnaur: fully called "Scrap Your Boilerplate" after the title (and base of other titles) of a series of papers
14:20:37 <earthy> it is in GHC 6.6 as Data.Generics
14:21:35 <earthy> oh, I forgot to mention that it's *fun*. ;)
14:22:27 <ndm> thorkilnaur: http://homepages.cwi.nl/~ralf/syb1/ - read that paper
14:22:32 <lambdabot> Title: Scrap your boilerplate: a practical design pattern for generic programming
14:23:08 <earthy> oh, and read syb2 as well
14:23:19 <earthy> those two really should be considered 1 paper, in my mind.
14:23:53 <arjanoosting> SyntaxNinja: there is already a pkg-haskell subversion archive on alioth. I will ask Florian Ragwitz if we can use it as a repository for hugs
14:24:20 <thorkilnaur> And now that we are there: What is "boilerplate" (apart from something that you might use to make, say, coffee)? (Just say: "Read the paper", if it's easier)
14:24:44 <earthy> thorkilnaur: consider the datatypes in Language.Haskell
14:25:03 <Igloo> boilerplate is anything you type out each time that the compiler ought to do for you
14:25:12 <Igloo> e.g. deriving saves you from writing some boilerplate
14:25:20 <Igloo> and Java makes you write pages of it
14:25:36 <earthy> now consider walking an element of Language.Haskell.Syntax.HsModule
14:26:10 <earthy> this is *tedious*
14:26:46 <dons> yeah, that's where all my boilerplate is: AST walking
14:26:59 <earthy> dons: precisely. and this is where SYB really shines
14:27:09 <dons> right. its really great for that kind of thing.
14:27:18 <dons> compiler passes that tweak some small part of the AST.
14:27:24 <kc5tja> public static private public general specific <class middle> main(String complaints[]) throws UnnecessaryTemperTantrumException { Sys.Error.OutLn( "does not."); }
14:27:38 <dons> argh! my eyes! they burn!
14:27:38 <SyntaxNinja> arjanoosting: OK
14:27:55 <merus> Ow!
14:28:33 <kc5tja> There is this article on the web, published sometime last year, that rips into Java pretty hard.
14:28:34 <dozer> wow, just managed to write 50 lines of haskell, and it seems to work
14:28:40 * dozer opens a bottle of beer
14:28:43 <dons> dozer: hehe.
14:29:06 <kc5tja> @google Kingdom of Nouns
14:29:12 <lambdabot> http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html
14:29:12 <lambdabot> Title: Stevey's Blog Rants: Execution in the Kingdom of Nouns
14:29:19 <kc5tja> That's the one.
14:29:29 <osfameron> heh
14:29:50 <osfameron> silly but good
14:29:59 <kc5tja> That's the whole point.  It's satire.
14:30:18 <kc5tja> All the guy wants is first-class functions.  Everything else can stay.
14:30:48 <arjanoosting> SyntaxNinja: now CosmicRay mails me and says he prefers mecurial....
14:30:49 <osfameron> he also has clever rants, and som random ones
14:31:10 * kc5tja works with Java at work, and I've gotten used to it.
14:31:11 <SyntaxNinja> hehe
14:31:23 <kc5tja> But that makes the Kingdom of Nouns paper _so_ much more pertinent. :)
14:31:47 * arjanoosting has never used mecurial, but I will have a look at it anyway
14:31:53 <kc5tja> What's funny is that modern Wirthian languages (e.g., Oberon-family) end up being _less_ verbose than Java in most cases.
14:32:46 <ADEpt> anyone cares to say why b!0 gives stack overflow and a!0 gives bottom in this code: http://hpaste.org/1422#a0 ?
14:33:08 <arjanoosting> SyntaxNinja: do you have any objections to uploading the hugs from experimental to unstable? It will break some stuff using oldlibs and Text.Regex but apart from that I think it is ready
14:33:20 * earthy hugs kc5tja
14:33:31 * bringert fixes a bug in System.Posix.User he's been pretending doesn't exist for long time
14:33:34 * earthy is going to teach Java as of may 8th. 
14:33:36 * arjanoosting fetches a cup of coffee
14:33:45 <earthy> I *really* like that url
14:34:12 <kc5tja> Haha
14:34:12 <Heffalump> ADEpt: you can't initialise an unboxed array recursively, surely.
14:34:13 <monochrom> a!0 is bottom because a is created "array (1,n) ..."  no such thing as a!0
14:34:18 <kc5tja> earthy: Thanks.
14:34:27 <ADEpt> Heffalump: that much i got already. But why? :)
14:34:43 <ADEpt> monochrom: sorry. make that a!1
14:35:01 <Heffalump> ADEpt: cos it's unboxed. It can't have a thunk pointing to unevaluated bits in the values.
14:35:19 <monochrom> b!0 triggers computing the whole array and the whole thunk.  If the thunk is deep, stack overflow.
14:35:20 <Heffalump> in a normal boxed array, you have an array of index -> thunk pairs
14:35:27 <Heffalump> and you only evaluate the thunks when needed
14:35:27 * ADEpt slaps ADEpt for being clueless. of course!
14:36:01 <ADEpt> Heffalump: question #2 then. If I change to boxed arrays and make n = 2000^2, it gobbles up memery like crazy. Why?
14:36:14 <Heffalump> to put it more semantically, unboxed arrays are strict in their elements
14:36:28 <Heffalump> how crazy?
14:36:38 <Heffalump> more than a reasonable constant factor times 2000^2 ?
14:36:45 <Heffalump> (where reasonable = say 10)
14:36:48 <Heffalump> or maybe 20
14:36:49 <hpaste>  ADEpt annotated "strange behaviour" with "why so much allocation?" at http://hpaste.org/1422#a1
14:36:53 <monochrom> 2000^2 is a crazy number.
14:37:13 <Heffalump> an unboxed array with 2000^2 elements would only be 16MB
14:37:22 <ADEpt> Heffalump: like, it eats 700 Mb and wants more
14:37:36 <ADEpt> monochrom: it's only 4000000 :)
14:37:38 <norp> be happy you didn't say 2^2000
14:37:51 <monochrom> 2^2000 is beyond crazy
14:38:13 <ADEpt> monochrom: then again, maybe i'm a crazy man ;)
14:38:14 <monochrom> You get into an infinite loop that spends both time and space.
14:38:22 <Heffalump> ADEpt: what are you evaluating to get it to eat memory?
14:38:29 <Heffalump> I'd have thought b!0 would be very cheap, for example.
14:38:31 <ADEpt> Heffalump: a!1
14:38:40 <Heffalump> oh, I didn't look at a. /me does so
14:38:54 <ADEpt> monochrom: where's the infinite loop?
14:39:10 <Heffalump> all I can think is that array isn't a very good list consumer
14:39:20 <Heffalump> and that you are getting a big list to be fed to it with very high overhead
14:39:32 <monochrom> Since it's UArray, self-references are infinite loops
14:39:34 <Heffalump> does 1000^2 work?
14:39:49 <monochrom> (The same reason you got bottom)
14:39:51 <Heffalump> monochrom: ADEpt is now talking about replacing UArray with boxed arrays in that code
14:39:59 <ADEpt> monochrom: see my first annotation to that paste, what about unboxed arrays?
14:40:10 <ADEpt> s/un//
14:40:26 <monochrom> I am looking at http://hpaste.org/1422#a0 truly I swear.
14:40:27 <koala_man> pardon the noobishness, but how do you do something like   if x==(Just k) then show k else "Lawl" ?
14:40:46 <dmwit> :t maybe
14:40:49 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:40:49 <kpreid> koala_man: case x of (Just k) -> show k; _ -> "Lawl"
14:40:49 <dons> case z of Just x -> show x ; _ -> "lolol!11!"
14:40:56 <koala_man> thanks!
14:40:58 <dons> case x, yes.
14:41:00 <earthy> anyway, time for bed
14:41:02 <earthy> night all
14:41:12 <ADEpt> monochrom: look at #a1, please :)
14:41:13 <dmwit> maybe "Lawl" show x
14:41:15 <SyntaxNinja> arjanoosting: what stuff would it break?
14:42:06 <monochrom> #a1 too.  same thing.
14:42:46 <ADEpt> Heffalump: *Test> a!1
14:42:46 <ADEpt> (12.49 secs, 237394740 bytes)
14:43:02 <monochrom> I see altogether two programs.  Their diff is "main = print $ a!1"
14:43:26 <Heffalump> ADEpt: ok, and 500^2 ?
14:43:32 <ADEpt> monochrom: http://hpaste.org/1422/diff?old=0&new=1
14:43:42 * Heffalump thinks it's just a large constant factor caused by the list of tuples
14:43:43 <xerox> C question, can I pass to a function and mutate an |int m[N][M]| declared in the main?
14:44:03 <Heffalump> xerox: yes
14:44:07 <monochrom> UArray still refers to unboxed, despite change in import.
14:44:08 <ADEpt> Heffalump: (1.54 secs, 59367876 bytes)
14:44:15 <Heffalump> ADEpt: ok, definitely that then
14:44:29 <Heffalump> I dunno about the times, probably paging/caching related. But the memory usage is clearly linear.
14:44:38 <xerox> Heffalump, I'm trying, the pointers point to the same place, but it fails to get mutated for unknown reason :/
14:44:44 <Heffalump> with a constant factor of about 240
14:45:03 <Heffalump> xerox: got a small sample?
14:45:07 <ADEpt> monochrom: whoa. Me bad, leaving typesigs unchanges. But why it started working then, all of a sudden?
14:45:27 <arjanoosting> SyntaxNinja: some libraries of CosmicRay (ftphs and MissingH need Text.Regex) and the build of haskell98-tutorial (easily fixable)
14:45:41 <monochrom> You actually get some result rather than bottom?
14:45:43 <xerox> Heffalump, oh my god, I had left a re-mutating line in the main. Damn terse syntax. Thanks anyway.
14:45:49 <ADEpt> monochrom: yes
14:46:13 <arjanoosting> SyntaxNinja: other packages need updates of the build- and normal dependencies as the packaging is modular
14:46:52 <ADEpt> monochrom: and I also get:
14:46:54 <ADEpt> *Test> :t a
14:46:54 <ADEpt> a :: Array Int Int
14:47:31 <SyntaxNinja> arjanoosting: Ok sounds OK, just try to give everyone with such pcakages a heads-up.
14:47:37 * ADEpt slaps himself once more
14:47:58 <arjanoosting> SyntaxNinja: will do
14:48:33 <ADEpt> monochrom: never mind me, in the code I actually run i fixed the typesigs to Array, in the pasted code I left them as is. Pasted code actually wont compile.
14:48:37 * arjanoosting is trying to build all reverse build dependencies of hugs right now
14:48:45 <monochrom> OK.
14:49:48 <ADEpt> Heffalump: so the reason is that I use a list to fill an array, but that list refers to an array, which is a very larch thunk, which gets partially evaluated while i try to compute a!1. But wait, why it actually does so?
14:49:59 <monochrom> Each thunk is huge.
14:50:10 <ADEpt> Heffalump: does Data.Array.array force a list it consumes?
14:50:24 <monochrom> It does.
14:51:06 <ADEpt> monochrom: each thunk == thunk of each element of the list?
14:51:14 <monochrom> Yes.
14:51:31 <SyntaxNinja> arjanoosting: you rock :)
14:51:55 <ADEpt> monochrom: ("... and exercise to find out why it does so is left to the curious reader"). Thanks :)
14:51:59 <ADEpt> Heffalump: likewise
14:52:04 <Heffalump> ADEpt: the reason for what?
14:52:19 <Heffalump> you have a large constant factor because you build a large intermediate list which apparently does not get fused
14:52:26 <monochrom> 240 bytes sounds right for a thunk represent three long lines of code.
14:52:48 <ADEpt> Heffalump: for evaluation of the whole list to print a!1 which does not refer to any other array elements
14:53:05 <igli> "we put the funk in funktion" hehe
14:53:06 <Heffalump> I presume that's the way array works.
14:53:30 <Heffalump> it makes sense, the array has to have something in the element slots
14:53:34 <monochrom> There is a way to verify my claim
14:53:39 <Heffalump> and you need to evaluate that list to get the thunks to put there
14:53:39 <ADEpt> Heffalump: that's what monochrom says, and I believe him :)
14:54:20 <Heffalump> actually, I guess fusing wouldn't help that much, cos there's still the thunks to your complicated calculation
14:54:28 <Heffalump> anyway, bedtime for Heffalumps.
14:54:51 <hpaste>  monochrom annotated "strange behaviour" with "does it use less space?" at http://hpaste.org/1422#a2
14:55:08 <monochrom> Try that.  It uses less space iff my conjecture is right.
14:56:08 <monochrom> (I hope the executor doesn't inline like crazy, defeating my purpose.)
14:56:23 <monochrom> (Add some NOINLINE pragma if you want to be sure.)
14:58:18 <ADEpt> monochrom: same time, same space, give or take 18000 bytes
14:58:38 <ADEpt> monochrom: does ghci ever inlines?
14:58:51 <monochrom> I don't know.
14:59:38 <monochrom> How do I get ghci to tell me how much time and space used?
14:59:50 <ADEpt> NOINLINE changes very little
14:59:50 <elrodeo> monochrom: :set +s
14:59:54 <ADEpt> monochrom: :set +s
14:59:57 <ADEpt> :)
15:00:00 <elrodeo> :-D
15:00:26 <ADEpt> monochrom: like, -500 bytes with NOINLINE
15:07:30 <monochrom> ghci probably doesn't inline anyway.  inlining is a -O business.
15:09:52 <ADEpt> yep
15:11:08 <ADEpt> monochrom: so you wager that 237 bytes per array elt is a thunk which holds that horrendous "if"? If so, then what gets computed when i try to access a!1 first time?
15:12:59 <sorear> hello!
15:13:00 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
15:13:04 <sorear> @messages
15:13:05 <lambdabot> earthy said 12h 1m 28s ago: look at http://www.cs.uu.nl/wiki/HUT/ for another cabalization of Daan's PPrint lib.
15:15:40 <monochrom> What I'm sure is this. Array is array of thunks, or you can say array of points to thunks.  First time you ask for a!anything, the array is built.  This means all the pointers are set up, all the thunks are created (I don't know how much sharing is possible).  And then the thunk for a!1 is evaluated (which is cheap).  The other thunks are constructed but untouched.
15:15:59 <monochrom> I am also not sure how much of the list is generated and kept.
15:17:00 <sorear> yay, 102 messages!
15:17:32 <igli> monochrom: i thought haskell was lazy tho? (i know i am.. ;)
15:18:16 <ADEpt> monochrom: ok, i'l try to dissect it with -prof later on
15:18:19 <igli> "thunks are constructed but untouched." cool, but i'd have thought they wouldn't have even been constructed?
15:18:29 * igli is learning
15:18:37 <sorear> igli: arrays are deliberately stricter than they need to be
15:18:39 <hpaste>  monochrom annotated "strange behaviour" with "this takes as much space (ghci)" at http://hpaste.org/1422#a3
15:19:12 <sorear> igli: by constructing all the thunks at once, we suffer a heavy cost on the first use, but gain O(1) access afterward
15:19:13 <igli> ah ok
15:19:18 <igli> cool
15:19:36 <sorear> igli: by contrast, a tree can be lazily constructed, but costs O(log n) to access
15:19:41 <monochrom> Something has to be constructed.
15:20:16 <ADEpt> monochrom: third annotation is a charm, thnx :)
15:20:20 <hpaste>  monochrom annotated "strange behaviour" with "even this is huge" at http://hpaste.org/1422#a4
15:20:44 <monochrom> The last one goes to the extreme with (i,i).
15:20:56 <monochrom> Even it takes almost as much space.
15:21:27 <monochrom> I now think it's just ghci's own thunk representation (in its own bytecode scheme) that's huge.  If you compile you get a completely different story.
15:22:03 <norpan> you're measuring space using ghci?!
15:22:16 <dmwit> Wow, some C programmers are insane.
15:22:22 <monochrom> we're measuring ghci space using ghci.  you have a better way?
15:22:28 <norpan> yeah, compile!
15:22:30 <norpan> :)
15:22:36 <monochrom> that will not measure ghci space.
15:23:02 <norpan> i don't think ghci optimizes for space, but maybe that's what you are trying to fix
15:23:05 <norpan> i don't know
15:23:28 <igli> ty sorear, thy wisdom is being logged ;)
15:23:40 <monochrom> We were investigating. Made observations, formulated hypotheses, performed validation.
15:23:57 <ADEpt> 4)profit! ;)
15:24:15 <monochrom> At the end of course we were aware what we were measuring and its relevance.
15:41:04 * dmwit feels brilliant
15:42:22 * sorear humbles dmwit
15:42:28 * dmwit deflates a little
15:42:53 <dmwit> If I take the length of a list generated by using it as a backtracking monad, it will force the calculations of all the branches, won't it. =(
15:43:10 <sorear> yes ... why?
15:43:13 * dmwit deflates a little further
15:43:35 <igli> heh
15:43:55 <sorear> of COURSE you need to trace all the branches to see how many accept.  I'm afraid I don't understand your real question?
15:44:05 <dmwit> Yeah.
15:44:11 <dmwit> I know, it just took me a second to realize it.
15:44:33 <dmwit> I want to build a list of possible paths from one point to another in a grid, then randomly choose one.
15:45:04 <dmwit> I was thinking that I could build the list lazily, and then pick a random number in [1..length solutions] to index it -- and only calculate that solution!
15:45:08 <dmwit> But of course that doesn't fly.
15:45:54 <dmwit> Oh well, no premature optimization.  First see how long it takes to calculate all the paths -- it might be fast. =)
15:46:52 <dolio> Even if you knew beforehand how many solutions there are, finding later solutions takes longer than earlier ones.
15:47:10 <dolio> Because you need to decide what the first 4 solutions are before you can find the 5th one.
15:47:22 <dmwit> Yeah, it's a fundamentally flawed approach.
15:47:26 <dmwit> Oh well.
15:47:29 <xerox> dmwit, you can use monadrandom
15:47:47 <dmwit> It exists??
15:47:52 <dmwit> I just wrote my own, but...
15:47:57 <dolio> What you might want to do is try abstracting over the choices.
15:47:57 <xerox> yup
15:47:57 <dmwit> ?hoogle MonadRandom
15:47:59 <lambdabot> No matches found
15:48:12 <dmwit> ?hoogle RandomMonad
15:48:13 <lambdabot> No matches found
15:48:13 <dolio> Do 'x <- choose list' instead of 'x <- list'.
15:48:15 <xerox> ?google MonadRandom site:haskell.org/
15:48:17 <lambdabot> http://www.haskell.org/haskellwiki/New_monads/MonadRandom
15:48:18 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
15:48:40 <dmwit> dolio: Yeah, that's what I'll probably end up doing.  I'll have to deal with failures somehow, too, but yeah.
15:48:55 <dolio> Then you can make an instance for both list and MonadRandom, and produce either all or a random one from the same code.
15:49:35 <dolio> Oh, yeah, that might add some toughness.
15:50:36 <sorear> ooh, yay, I was ?seen'd 5 times today
15:50:41 <chessguy> hi haskellers
15:50:50 <dmwit> xerox: Ooo, that's a bit more than I need, I think.
15:50:55 <chessguy> ?seen sorear
15:50:56 <lambdabot> sorear is in #darcs, #haskell-overflow, #haskell-blah, #ghc and #haskell. I last heard sorear speak 18s ago.
15:51:01 <chessguy> make it 6 :)
15:51:04 <dmwit> I'll stick with my type MonadRandom a = State StdGen a for now. =P
15:51:07 <ndm> sorear: probably a couple of times by me
15:51:08 <xerox> dmwit, put it in a separate module and enjoy
15:52:17 <igli> monads are *sweet* :D
15:53:01 <chessguy> they're abstract enough to be sour, too, if you need them to be
15:53:12 <chessguy> or just about any other taste
15:54:30 <dmwit> That type declaration, along with "withRange lo hi f = do { g <- get; let (val, newG) = randomR (lo, hi) g; put newG; return (f val) }" is enough for me. ;-)
15:55:39 <chessguy> ?hoogle withRange
15:55:40 <lambdabot> No matches found
15:55:45 <sorear> @remember chessguy <igli> monads are *sweet* :D <chessguy> they're abstract enough to be sour, too, if you need them to be
15:55:45 <sorear>  
15:55:46 <lambdabot> Done.
15:55:54 <igli> lol
15:56:13 <dozer> given an xml xsd, is there a quick way to generate a haskell source-code binding?
15:56:23 <sorear> @where HaXml
15:56:24 <lambdabot> http://haskell.org/HaXml
15:56:27 <sorear> @where HXT
15:56:27 <lambdabot> http://www.fh-wedel.de/~si/HXmlToolbox/
15:56:49 <sorear> one of those two, I forget which, has a XML-description-to-haskell translator
15:56:52 <dozer> thanks - today has been the day of learning things
15:56:56 <sorear> might have been DTD :(
15:57:08 <chessguy> dozer: that's a day in the life of any haskell programmer :)
15:57:41 <dons> http://programming.reddit.com/info/1igeq/details
15:57:43 <lambdabot> Title: More Haskell Parallelism (reddit.com)
15:58:05 <sorear> Wow, dons, you sure are up early! :)
15:58:11 <chessguy> ?time dons
15:58:13 <lambdabot> Local time for dons is Tue Apr 17 08:57:11 2007
15:58:20 * chessguy gasps
15:58:26 <dmwit> Somebody hasn't gone to bed yet... =P
15:58:49 <sorear> I suspect that time is wrong.
15:59:10 <dons> good time to wake up.
15:59:29 <sorear> where is UTC+10?
15:59:43 * sorear suspects "NSW"
15:59:55 <dons> yeah, east coast
16:00:39 <dozer> seems both HaXml and HXmlToolbox support DTD not schema :(
16:01:19 <sorear> once you solve your problem, read this:
16:01:24 <sorear> http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
16:01:25 <lambdabot> Title: How to write a Haskell program - HaskellWiki
16:01:42 <sorear> everything you need to know about making our lives easier
16:01:43 <hpaste>  MarcWeber pasted "random list of ints? stack overflow ? Not yet enought unsafeInterleaveIO" at http://hpaste.org/1423
16:01:58 <sorear> @seen glguy
16:01:58 <lambdabot> glguy is in #haskell. I last heard glguy speak 7h 33m 43s ago.
16:03:44 <MarcWebe1> matthew-_: I've now nix running on windows, too. There were two little bugs.
16:04:57 <hpaste>  stefan annotated "random list of ints? stack overflow ? Not yet enought unsafeInterleaveIO" with "much easier way" at http://hpaste.org/1423#a1
16:05:33 <sorear> that's funny...  I accidentally used the "wrong" name
16:08:15 <sorear> ndm: I'm trying to understand the derive-guesser
16:08:23 <sorear> what are the meaning of the types:
16:08:33 <sorear>     guessEnv :: t -> [(Env, Env -> t, String)]
16:08:33 <sorear>     guessStr :: t -> String
16:09:07 <ndm> sorear: guessEnv is the main one
16:09:49 <ndm> sorear: imagine that given a value you are required to give an environment, a function to generate this value from the given environment, and a string that represents the function
16:10:03 <ndm> guessStr is just doing guessEnv but ensuring you have None as the Env
16:10:22 <sorear> and [] is for backtracking?
16:10:33 <MarcWebe1> stefan fmap = liftM in this case is nice ! So you don't need another import line.
16:10:34 <sorear> what do environments 'mean'?
16:10:43 * chessguy is feeling strangely inspired to write a monad tutorial, but supposes it should wait until he's done his taxes :(
16:10:44 <ndm> sorear: kind of, the idea is that when you have a list you want a list of generators which take each environment
16:11:20 <ndm> sorear: environment is either "you can have this as a constant", "you can have this based on constructor n", "you can have this based on item n"
16:12:17 <ndm> sorear: the basic ideal is that to define a list of items, you need to have a list of things for which the same generator will make them all, and the environments are inductive - i.e. a sequence of 0,1,2,3
16:12:17 <chessguy> @type read
16:12:20 <lambdabot> forall a. (Read a) => String -> a
16:12:28 <ndm> the magic is all in instance Guess a => Guess [a]
16:12:29 <chessguy> @instances-importing Read
16:12:32 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
16:12:33 <dons> hehe, http://programming.reddit.com/info/1igir/details
16:12:35 <lambdabot> Title: Thinking in objects: or why Haskell is hard for OO coders (reddit.com)
16:13:04 <sorear> ndm: and the rest is just induction .. so we can guess the meaning of a declaration
16:13:04 <chessguy> that sounds like an enlightening article
16:13:15 <ndm> sorear: exactly
16:13:25 <ndm> sorear: the induction bit is where the magic happens :)
16:13:40 <dons> its interesting seeing someone attempting to learn Haskell realise that their OO training makes it hard to think functionally
16:14:05 <ndm> that and UML is crap
16:14:15 <sorear> ndm: guessing [a] involves finding all guesses for the components, where an Environment is sort of a machine readable "what is the significance of this?"  then we put stuff together with sequence analysis?
16:14:21 <igli> the article was a bit lightweight tho
16:14:50 <dolio> Mmm... "Type Inference: Another Bad Idea for Java 7?"
16:14:51 <chessguy> yeah, a little disappointing
16:14:52 <bos> i had an interview a few weeks ago in which someone asked me a UML question. i told them i thought UML was a bunch of hooey, and asked every subsequent interviewer if they actually used UM:L. to my relief, they all said no.
16:14:52 <ndm> sorear: yes, with a little more complexity - when we have [a] some may be constant, some may have a different type of environment
16:15:10 <sorear> hmm, why is guessStr in the class?
16:15:19 <dozer> I've dun a huge amout of OO, and never found UML to be helpful
16:15:36 <ndm> sorear: at the very end you want to change to a concrete answer, more historical than anything else - Dec used to be only guessStr
16:15:47 <ndm> sorear: but now you can guess over Dec, so i guess it deserves to come out
16:15:48 <dozer> it always forces you to think implementation v early, ironically
16:16:19 * sorear gets a chance to advocate Derive
16:17:14 <ndm> i really want to write up derive guess, but i'm not entirely sure where to put hte result
16:17:42 <ndm> it does seem rather cool, i'm particularly happy with the Serial instance - took about 5 minutes, is quite complex, guesses itself
16:18:24 <ndm> sorear: advocating for what?
16:18:42 <ndm> Yhc now uses Derive and Data.Binary instead of DrIFT and some hacked up binary
16:19:22 <encryptio> how do i tell darcs to roll me back to the version in the repository? (undo all changes in the working copy, so that whatsnew == nothing)
16:19:40 <ndm> darcs revert
16:19:49 <chessguy> wtf
16:19:50 <chessguy> data Queue a = Q [a] [a] [a]
16:20:28 <sorear> chessguy: I don't understand it either, and I saw it weeks ago
16:20:34 <encryptio> ndm: thanks
16:20:45 <stepcut> chessguy: :p
16:21:04 <sorear> @where derive
16:21:05 <lambdabot> I know nothing about derive.
16:21:09 <kpreid> chessguy: where's that code from?
16:21:19 <chessguy> http://darcs.haskell.org/ghc-6.6/packages/base/Data/Queue.hs
16:21:25 <chessguy> Data.Queue (which is deprecated)
16:21:39 <sorear> @where derive
16:21:40 <lambdabot> I know nothing about derive.
16:21:47 <sorear> @google data.derive
16:21:49 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/derive/derive.htm
16:21:49 <lambdabot> Title: Data.Derive: A User Manual
16:22:02 <sorear> @where+ derive http://www.cs.york.ac.uk/fp/darcs/derive
16:22:03 <lambdabot> Done.
16:22:05 <chessguy> ugh, the comments on this code are...quite lacking
16:22:11 <sorear> agreed.
16:23:31 <ndm> data.derive or Queue?
16:23:45 <chessguy> and it recommends Data.Sequence, but Queue isn't defined there
16:23:50 <chessguy> ndm: Data.Queue
16:24:22 <kpreid> chessguy: I assume it means using a sequence as a queue
16:24:24 <ddarius> chessguy: Read the paper.
16:24:36 <sorear> ddarius: I tried
16:24:44 <sorear> ddarius: google wasn't helpful, iirc
16:24:55 <chessguy> the running times are impressive in Data.Sequence though
16:25:11 <sorear> ddarius: this isn't finger trees
16:25:18 <sorear> ddarius: <chessguy> data Queue a = Q [a] [a] [a]
16:25:37 <chessguy> sorear: Data.Sequence is
16:25:46 <ddarius> There's a paper referenced in the queue module that explains how Queue works.
16:26:07 <ddarius> I've either read that paper, or it is also described in some other paper.
16:26:13 <sorear> Oh, right.
16:26:22 <sorear> Yes, I saw that reference.
16:26:33 <sorear> Now, to find a JFP subscription :)
16:26:43 <ddarius> http://citeseer.ist.psu.edu/okasaki95simple.html
16:26:44 <lambdabot> Title: Simple and Efficient Purely Functional Queues and Deques - Okasaki (ResearchInde ...
16:27:07 <sorear> nice
16:27:29 * sorear wishes google found that the first time he looked for a free version
16:27:50 <chessguy> it found it for me
16:28:25 * sorear afis to read it
16:29:08 * ndm is greatful for the complete JFP series behind his desk
16:30:56 <igli> http://www.eecs.usma.edu/webs/people/okasaki/pubs.html # had to google for paper
16:30:58 <lambdabot> Title: Chris Okasaki's Publications
16:31:44 <ndm> does Okasaki do anything currently?
16:32:51 <emu> nothing with any effect
16:33:19 <ddarius> Chris Okasaki has finally transcended into purity!
16:33:53 <ndm> and laziness :-)
16:33:59 <igli> heh not much in last 3 or 4 years
16:35:20 <ndm> sorear: do you have anything you want to do to Data.Derive before releasing 0.1?
16:38:23 <xerox> ?seen shapr
16:38:23 <lambdabot> I saw shapr leaving #haskell 1h 24m 26s ago, and .
16:39:32 <ddarius> Well, it has only taken 30 years, but purely functional programming is finally undeniably in a position to start kicking ass and taking names.
16:39:48 <ndm> ddarius: with normal programmers, or with the elite only?
16:39:57 <encryptio> @pl \x -> (read [x])^2
16:39:58 <lambdabot> (^ 2) . read . return
16:40:13 <encryptio> oooh. fancy.
16:40:28 <ddarius> ndm: With normal "functional" programmers, but to an extent that the mainstream will sway.
16:40:46 <TomMD> ddarius: are you saying people program in non-functional languages?  Funny, I don't see a #c channel around here.
16:40:53 <sorear> TomMD: ##c
16:41:02 <Botje> just make assignment easy and the mainstream will come flocking to us! *hides*
16:41:24 <TomMD> sorear: Shhhh, I'm trying really hard to make a joke.
16:41:41 <sorear> ndm: we might want to look into the cloning the entire DrIFT standard derivation set.  probably won't be useful in practice, but it shouldn't take long and it might add wow-factor to the announce
16:42:15 <ndm> sorear: i did the ones that looked easy, for some i had trouble finding a library which actually used the instance
16:42:39 <sorear> ndm: how do you feel about making Derive 6.7-compatible?
16:42:39 <ndm> i will talk to malcolm about XmlContent for HaXml
16:42:48 <ndm> sorear: with what changes?
16:43:00 <ndm> i would ideally like 6.4-6.7+ compatible
16:43:26 <sorear> ndm: we need to rename some stuff we added to not conflict with the in-tree fixed ppr
16:43:36 <sorear> alas, hiding errors on nonexistant names
16:43:55 <ndm> sorear: go for it, whatever patches you need in
16:44:12 <ndm> isPunctuation and isSymbol are not in GHC 6.4, so we need to fix over those too
16:45:25 <ndm> sorear: i couldn't find a module which worked with the Observable class that DrIFT supports
16:45:38 <ndm> GhcBinary, Binary and BitBinary are now irrelevant with Data.Binary
16:46:07 <ddarius> ndm: HOOD
16:46:10 <ndm> FuctorM, HFoldable, Monoid, RMapM and Term are things i have no idea how to derive
16:46:18 <ndm> ddarius: yes, but can you find a working copy of HOOD?
16:46:29 <sorear> ndm: we can look at what drift does ;)
16:46:30 * ddarius has no idea what happened to hood.
16:46:48 <ndm> sorear: its type based deriving, so a nightmare to clone - although i guess it could be done with time
16:46:57 <ndm> although Monoid is the only one I can find an active instance for!
16:47:16 <sorear> active?
16:47:34 <ndm> alive, in a standard library which anyone would have
16:47:42 <dmead> sup channel
16:47:44 <ndm> alive i guess
16:47:50 <Pseudonym> sub channel
16:48:06 * sorear acts hyper
16:48:16 <dmead> :)
16:49:03 <ddarius> inf channel
16:49:18 <ndm> sorear: fancy writing any of those instances? we also need Show, Read and some of the ones from Utility
16:49:40 <Pseudonym> http://books.slashdot.org/comments.pl?sid=230985&cid=18759625
16:49:43 <lambdabot> Title: Java Generics and Collections
16:49:44 <Pseudonym> Some people don't get it.
16:49:51 <sorear> ndm: Utility?
16:50:02 <sorear> wow.
16:50:21 <sorear> I just fixed derive, which compiles in <1 minute with head.
16:50:24 <ndm> http://repetae.net/~john/computer/haskell/DrIFT/ - easy ones, mainly record querying and updating
16:50:26 <lambdabot> Title: DrIFT Homepage
16:50:41 <sorear> I test it with GHC-6.6, and take a restroom break
16:50:47 <ndm> really?
16:50:51 <sorear> I come back, it's less than half done
16:50:56 <ndm> i get under a minute always
16:51:06 <ndm> its only 25 simple modules
16:51:27 <sorear> odd.
16:51:44 <sorear> esp. since the .cabal doesn't mention -O
16:52:36 <sorear> patch snt.
16:52:54 <ndm> sorear: will apply tomorrow, my home machine doesn't have derive on
16:53:32 <sorear> does 'filepath' all lower case work on GHC 6.4.2?
16:53:46 <ndm> sorear: with the new version of filepath, yes
16:53:58 <ndm> sorear: Ross changed the package name :( - its now filepath everywhere, it used to be FilePath everywhere
16:54:09 <monochrom> fun
16:54:52 <Igloo> He was just making it consistent, although renaming the .cabal file would probably have been the better way to do it
16:55:05 <ndm> sorear: no fun, you commented the derive guess :)
16:55:10 <sorear> chak is a #haskeller!?
16:55:56 <sorear> ndm: I don't think most people are competent to sufficiently comment code they wrote ;)  and I'm not done, I haven't gotten to the class yet
16:56:11 <ndm> sorear: i will write an overview at some point
16:56:24 <ndm> sorear: and i need to take guessStr out of the class as well
16:56:25 <sorear> for what audience?
16:56:30 <encryptio> @pl \x->[x]
16:56:31 <lambdabot> return
16:56:39 <ndm> anyone trying to understand how the thing works as a whole
16:56:40 <encryptio> @pl \(Just x)->x
16:56:41 <lambdabot> (line 1, column 8):
16:56:41 <lambdabot> unexpected "x"
16:56:41 <lambdabot> expecting operator or ")"
16:56:51 <ndm> for both people writing guess instances and looking at the code
16:56:59 <sorear> encryptio: fromJust
16:57:02 <emu> @type unJust
16:57:04 <sorear> and, btw, @pl sucks
16:57:04 <lambdabot> Not in scope: `unJust'
16:57:38 * ddarius considers implicitly condemning a whole LtU thread.
16:57:44 <arjanoosting> SyntaxNinja: hugs is uploaded to unstable. Time to sleep!
16:58:11 <ddarius> sorear: You didn't know that?
16:58:11 <QtPlatypus> ddarius: Which thread is that?
16:58:23 <ddarius> Thoughts on the Best Introductory Language
16:59:10 <QtPlatypus> ddarius: Oh that one thread sucks no mattor where it goes.  That one is basically "Lets start a langauge religious war".
16:59:20 <ddarius> ChilliX: How goes NDP?
17:00:17 <procyon112> ?scr foldr
17:00:17 <lambdabot> Maybe you meant: arr rc src
17:00:26 <procyon112> ?src foldr
17:00:27 <lambdabot> foldr k z xs = go xs
17:00:27 <lambdabot>     where go []     = z
17:00:27 <lambdabot>           go (y:ys) = y `k` go ys
17:01:59 <[sid]> i need to learn haskell in 2 days enough to impliment a binary search tree. what's the best thing to read? i have come from a non-FP programming background
17:02:07 <QtPlatypus> Oh its by "Shlomi Fish" I don't hink I'll even bother reading the essay.
17:02:08 <sorear> why?
17:02:33 * ddarius doesn't/didn't know who "Shlome Fish" is/was.
17:02:34 <sorear> [sid]: you said 'need', that's a dead giveaway you have an exam/hw question
17:02:55 <ChilliX> ddarius: well, we are no implementing the flattening transformation as a Core pass in GHC
17:02:56 <emu> well, he did ask for something to read. that's fair.
17:03:05 <emu> @where tutorial
17:03:05 <[sid]> yeah, precisely. i dont have a clue. could anyone recommend a great site.
17:03:05 <ChilliX> but it's no easy task, so will take a while
17:03:06 <lambdabot> http://www.haskell.org/tutorial/
17:03:11 <[sid]> im basically after a walkthru
17:03:13 <[sid]> ok cheers
17:03:26 <emu> hmm thats just one
17:03:28 <emu> @wiki tutorial
17:03:29 <lambdabot> http://www.haskell.org/haskellwiki/tutorial
17:03:44 <emu> http://www.haskell.org/haskellwiki/Meta-tutorial
17:03:45 <lambdabot> Title: Meta-tutorial - HaskellWiki
17:03:53 <monochrom> All haskell textbooks are good reads for this purpose.
17:03:57 <emu> Meta-tutorial == tutorial about which tutorial to pick
17:03:58 <[sid]> thanks, ill have a read. i find the haskell syntax hard to get my head round
17:04:31 <monochrom> Haskell textbooks tend to introduce binary trees (and user-defined data structures in general) very early on.
17:05:14 <ddarius> monochrom: Compared to the "nightmare" the data structures are to beginners in languages like C, that's not too surprising.
17:05:35 <monochrom> Yes absolutely.
17:06:46 <ddarius> It's mildly depressing that in OO languages you can pull off clean and neat implementations of those data structures, but you never see those, no, that would require TCO>
17:07:25 <sorear> TCO>?
17:07:51 <emu> tail call opt?
17:07:58 <sorear> >?
17:08:02 <ddarius> What you get when you spill green tea on your laptops keyboard making your shift key stick.
17:08:04 <emu> typo!
17:08:04 <ddarius> .
17:08:24 <monochrom> green tea is healthy for laptops
17:08:42 <monochrom> reduces code bloat
17:10:01 <kc5tja> Total Code Ownership is the closest I can think of, considering I'm coming into this conversation completely cold and without context.
17:10:05 <ddarius> The aggravating thing is the Ctrl key sticks even more, so when I go Ctrl-t to open a tab in Firefox and start typing www, I kill all my tabs, and even Firefox upon occasion.
17:10:10 <monochrom> I am on underpowered laptop running popular bloatware efficiently.  My secret is I drink green tea.
17:10:29 <monochrom> Haha
17:11:21 <ddarius> Really, the solution is to make vim like bindings.
17:11:23 <procyon112> ddarius: I spilled beer on my laptop last week.  My keyboard is now drunk and types random letters.  My replacement keyboard should be here tomorrow.
17:11:49 <monochrom> Like ":q" to close Firefox?!!
17:11:58 <ddarius> mmmm
17:12:20 <emu> the tricky part is the name
17:12:21 <monochrom> And ":wq" to close Firefox and save cache and settings because ":q" discards them?!!
17:12:22 <sorear> @remember procyon112 I spilled beer on my laptop last week.  My keyboard is now drunk and types random letters.
17:12:23 <lambdabot> Done.
17:12:25 <emu> Vimerfox?
17:12:41 * sorear tried C-x C-s to save the quote
17:12:48 <monochrom> haha
17:12:50 <sorear> @flush
17:13:24 <dmead> hey channel
17:13:38 * monochrom contemplates vim binding for lambdabot
17:13:56 <dmead> to get the prenix form of a bi-conditional, you have to expand it to  -> & ->
17:13:56 <monochrom> such as ":type id" to ask for the type of id.
17:13:58 <dmead> right?
17:14:09 <ddarius> :t id
17:14:11 <monochrom> OH GOSH but that's exactly ghci!  Godawful!
17:14:11 <lambdabot> forall a. a -> a
17:14:34 <sorear> :pl try this in ghci
17:14:38 <monochrom> Why does ghci adopt the GODAWFUL vim convention??!!!
17:14:43 <ddarius> Anyway, that wouldn't really be vimmy, that'd be exy or edy.
17:14:53 <monochrom> Heh ok.
17:15:15 <emu> dmead: i'd imagine so
17:15:20 <dons> monochrom: we have one already
17:15:24 <monochrom> one way is expand to -> and <-
17:15:24 <emu> as an intermediate step
17:15:26 <dons> monochrom: check in scripts/vim/ in the lambdabot subdir
17:15:36 <SyntaxNinja> arjanoosting: I saw.  thanks!
17:15:41 <emu> monochrom: what would you prefer @type in ghci?
17:15:56 <monochrom> I'm just whining.
17:15:59 <dons> they're the same thought. there's no reason to prefer one to the other
17:16:14 <emu> ,type like lisp implementations do
17:16:18 <emu> heh
17:16:36 <monochrom> "x iff y" is also the same as "x and y or not x and not y"
17:17:41 <sorear> I suppose FOL won't let you say \ (x : Prop) . \ (y . Prop) . (x -> y, y -> x) ?
17:17:50 <[sid]> what does the "=>" operator do?
17:17:58 <sorear> it's not an operator!
17:18:04 <emu> [sid]: it's part of the type signature
17:18:05 <sorear> it is special syntax
17:18:12 <chessguy_away> @type (+)
17:18:15 <lambdabot> forall a. (Num a) => a -> a -> a
17:18:18 <emu> [sid]: it introduces type-class contraints
17:18:20 <sorear> it separates classes from the rest of the type
17:18:35 <chessguy_away> this means that if the type a belongs to the class Num, then (+) is of type a -> a -> a
17:19:10 <emu> i think we're moving towards 5.1
17:19:11 <chessguy_away> that is, for some instance of the Num class (e.g., Int, Integer, Float, etc.), it takes 2 objects of that type and returns a third object of that type
17:19:23 <[sid]> i think i get you
17:21:30 <sorear> emu: ?
17:21:42 <emu> surround sound
17:21:54 <sorear> dons: I finally grok the difference between your two foldl's
17:23:00 <sorear> > let fold f a [] = a ; fold f a (x:xs) = let a' = f a x in a' `seq` fold f a' xs in fold (const 0) undefined [0]
17:23:01 <lambdabot>   add an instance declaration for (Num (t -> a))
17:23:15 <sorear> > let fold f a [] = a ; fold f a (x:xs) = let a' = f a x in a' `seq` fold f a' xs in fold (\_ _ -> 0) undefined [0] -- Data.List
17:23:16 <monochrom> Lots of things are punctuations.
17:23:17 <lambdabot>  0
17:23:28 <monochrom> "What does the ( operator do?"
17:23:34 <procyon112> [sid]: Do you know Java?   If so, think of typeclasses, like "Num" as similar to Java's "interface"
17:23:53 <[sid]> i know Ada =/
17:24:19 <dons> sorear: between the partially strict, and fuly strict version?
17:24:35 <sorear> > let { fold f = go where { go a [] = a ; go a (x:xs) = a `seq` go (f a x) xs } } in fold (\_ _ -> 0) undefined [0] -- Data.List
17:24:37 <lambdabot>  Undefined
17:24:38 <sorear> dons: yes.
17:24:43 <dons> right.
17:24:45 <sorear> s/Data.List/Streams
17:24:57 <procyon112> [sid]: Wow.  Ada huh?  Not too many Ada programmers around these days :)
17:25:03 <dons> we get better code from ghc for the latter version too. like twice as fast.
17:25:09 <chessguy_away> procyon112!
17:25:10 <monochrom> Ada has some mechanism for overloading operators.  Typeclasses are for that too.
17:25:13 <dons> since you get a proper unboxed worker.
17:25:21 <procyon112> yo chessguy!
17:25:27 <chessguy_away> how goes?
17:26:03 <sorear> > let { fold f a [] = a ; fold f a (x:xs) = fold_ f (f a x) xs ; fold_ f a xs = go a xs where { go a [] = a ; go a (x:xs) = a `seq` go (f a x) xs } } in fold (\_ _ -> 0) undefined [0] -- slightly modified streams
17:26:05 <lambdabot>  0
17:26:15 <byteshack> is there a version of "Why functional programming matters" translated into Haskell?
17:26:20 <procyon112> It goes.  Haven't got much GP code done... been busy at work and my keyboard is drunk.
17:26:29 <sorear> we can get the old semanics, with an unboxed wrapper.
17:26:35 <sorear> probably not worth it though.
17:26:58 <sorear> er, unboxed worker :)
17:26:59 <byteshack> I really like that paper, as it has shown me some ways in which fp is definately a different beast than OOp
17:27:01 <chessguy_away> byteshack: IIRC, whyfp is pretty close to haskell already
17:27:30 <procyon112> chessguy: I've got what I want pretty clear in my head though... so as soon as I get the time I think I can whip something out.
17:27:35 <dons> sorear: i'm not sure anyone can actually depend on the current behaviour
17:27:41 <dons> seems like an oversight imo.
17:27:47 <byteshack> most of the things I find as tutorials in haskell have not been as clear on the advantages presented by fp
17:27:52 <chessguy_away> procyon112: cool!
17:27:56 <dons> and , if they do, it means we really really need strictness specified
17:28:11 <byteshack> I have tried to code up the ttt program outlined there, but I'm stuck
17:28:15 <chessguy_away> procyon112: i finally got TAPL this weekend, so i've been working on trying to absorb it
17:28:33 <chessguy_away> !paste
17:28:33 <hpaste> Haskell paste bin: http://hpaste.org/
17:28:36 <chessguy_away> byteshack: ^^
17:28:48 <procyon112> chessguy: I'm embracing Data.Tree, even though I'm not sure I like it for all representations.
17:28:58 <byteshack> is not a code cuestion, per-say
17:29:04 <chessguy_away> Data.Tree is your friend :)
17:29:08 <byteshack> the algo is not complete in the text
17:29:22 <chessguy_away> which algo?
17:29:29 <procyon112> chessguy: It's a lot to absorb.. but thankfully TAPL is nice and gentle with lots of examples.
17:29:50 <chessguy_away> ?where whyfp
17:29:51 <lambdabot> I know nothing about whyfp.
17:30:13 <byteshack> he converts a board tree into a value tree.  Then runs mini-max on the value tree
17:30:26 <byteshack> I did that, even used negamax (2 lines in haskell!!!)
17:30:48 <byteshack> I end up with a num value, but I have no clue what to do with it
17:30:56 <chessguy_away> let me find the paper
17:31:03 <chessguy_away> ?go why functional programming matters
17:31:07 <lambdabot> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
17:31:07 <lambdabot> Title: Why Functional Programming Matters
17:31:12 <byteshack> specially since I don't have either of the trees anylonger
17:31:13 <chessguy_away> i coulda swore i had a copy here somewhere
17:31:42 <procyon112> chessguy: Data.Tree is very general... I'm not sure what the perf hit is using Rose trees when what you want are binary trees, but I'm thinking it's probably substancial.  Mixing Rose tree nodes and Binary tree nodes is a bit of a nightmare though... especially from an end-user interface standpoint.
17:31:46 <chessguy_away> well, the value is just the evaluation of the tree
17:31:53 <byteshack> yeah
17:32:06 <dcoutts> g'morning dons
17:32:15 <byteshack> not sure how to use that to determine what move to make
17:32:17 <sorear> hi dcoutts
17:32:20 <dcoutts> dons: today I'm hacking on the Get monad
17:32:22 <dcoutts> hia sorear
17:32:22 <byteshack> I don't have the board tree anylonger
17:32:31 <sorear> how's the binary rewrite project?
17:32:37 <dcoutts> sorear: I can't reproduce your results
17:32:41 <chessguy_away> byteshack: well, you can collect the principal variation as you go
17:32:51 <dcoutts> sorear: which was the fastest version of your Binary module ?
17:33:09 <sorear> Builder5 or 7, forget which
17:33:28 <byteshack> chessguy_away: hmmm... lost me :(
17:33:31 <dcoutts> sorear: I was having the same experience as you yesterday, that it's counter-intuitive and almost everything I tried made it slower :-)
17:33:40 <byteshack> I'll paste what I have
17:33:43 <sorear> the Sn are strict, so don't try to use those ;)
17:34:19 <dcoutts> sorear: hmm, I can't get either of 5 or 7 to run faster than the one I started with, but in your tests you had it running 5 times faster than my version or something.
17:34:24 <dcoutts> perplexing
17:34:53 <dcoutts> in both versions I made sure all the rules were firing
17:35:27 <dons> dcoutts: ok. cool. i'm hacking away at the talk
17:35:31 <chessguy_away> procyon112: i'd be surprised if the performance hit was all that great
17:35:42 <chessguy_away> what makes you think it is?
17:35:44 <dcoutts> sorear: perhaps that could have been it, that when you did the test the form of code was such that the rules for my version were not firing, I did improve the rules yesterday so they more often work.
17:35:58 <hpaste>  byteshack pasted "ttt a la whyfpm" at http://hpaste.org/1424
17:36:26 <dcoutts> dons: great, ping me when you want a second opinion on anything
17:36:30 <sorear> dcoutts: do you get the same results with my driver?
17:36:47 <byteshack> darn, paste went wrong
17:36:51 <dcoutts> sorear: yeah I should try your driver
17:36:51 <byteshack> try again
17:36:56 <chessguy_away> byteshack: type signatures are your friend :)
17:37:04 <sorear> i'd hate to hear my driver was skewing the results, but it would at least be an explanation... :)
17:37:24 <procyon112> chessguy: The storage of the nil and the cons'ing.. I'm thinking it's a constant factor, but probably not an insignificant one, especially when dealing with the construction of hundreds of thousands of trees in GP.
17:37:31 <dcoutts> sorear: it's all so subtle and there are many many variables
17:37:32 <hpaste>  byteshack annotated "ttt a la whyfpm" with "(no title)" at http://hpaste.org/1424#a1
17:37:41 <byteshack> chessguy_away: so I have been told
17:37:49 <byteshack> I will go back and annotate it
17:38:01 <sorear> procyon112: ghc is smart enough to never allocate more than one nil per program run.
17:38:20 <byteshack> everything ends up being a helper of the "evaluate" call
17:38:25 <dcoutts> sorear: I think the main issue for both of us is that while reading the core/stg is fairly easy, reading anything in the layers below is very hard, so we don't get the proper intuition of what is happening to our nice stg code
17:38:48 <dcoutts> sorear: I want cmm with named local vars, preferably var names that correspond to the names in the stg
17:38:55 <dcoutts> then it might be comprehensible
17:38:58 <sorear> agreed.
17:39:14 <dcoutts> and I probably also want an imperative presentation of stg
17:39:18 <byteshack> thing is, evaluate is one of {-1,0,1}, which does not tell me much
17:39:33 <sorear> perhaps we can persuade the simons to use names in the cmm-with-variables work this summer? :)
17:39:58 <dcoutts> sorear: I'm not clear exactly what they're planning for the work this summer
17:40:09 <chessguy_away> byteshack: sure it does!
17:40:15 <byteshack> (as a side note, what are the recomendations on editors here? vim do ok with haskell?)
17:40:16 <chessguy_away> if you search to the terminals it does
17:40:23 <sorear> dcoutts: well, stg is pretty imperative.  let always allocates closures, case always forces things, etc.
17:40:39 <byteshack> chessguy_away: which I can, if I add alpha-beta to negamax
17:40:41 <sorear> byteshack: vim or emacs, mostly.
17:40:46 <chessguy_away> byteshack: sure
17:41:03 <sorear> byteshack: a few here use TextPad
17:41:04 <dcoutts> sorear: sure, sure, once you get an intuition for reading it, it's ok
17:41:09 <chessguy_away> maybe even if you don't
17:41:09 <byteshack> not sure what to do with that value
17:41:17 <procyon112> sorear: But it needs to allocate a reference to that nil.. My intuition just says that "data Tree a = Leaf a | Branch a (Tree a) (Tree a)" is going to be much more efficient for binary trees than "data Tree a = Tree a [Tree a]"
17:41:27 <dcoutts> sorear: cmm-with-vars is something I keep blabbering about but JaffaCake hasn't said that's the plan
17:41:37 <dcoutts> I think he has other ideas
17:41:50 <dcoutts> he knows this stuff best so is almost certainly right :-)
17:41:57 <chessguy_away> procyon112: occasionally, it seems like dependent types would be nice
17:42:16 <chessguy_away> procyon112: what about using arrays?
17:44:07 <chessguy_away> byteshack: so right now you have essentially gametree :: Board -> Tree Board, yes?
17:44:27 <chessguy_away> and negamax :: Tree Board -> Int
17:44:41 <procyon112> chessguy: ugh... no arrays :).  Data.Tree IMHO is well implemented. But it is implemented as a general solution to n-arity trees, not neccisarily the best solution for binary trees.
17:44:59 <byteshack> no, maptree :: Tree Board -> Tree Int
17:45:02 <sorear> chessguy_away: arrays require 32+ bytes of overhead per array...
17:45:06 <sorear> @src Array
17:45:07 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
17:45:18 <byteshack> and negamax :: Tree Int -> Int
17:45:34 <chessguy_away> what type is gametree?
17:45:35 <byteshack> which is what the paper does
17:45:45 <sorear> Array = Array Int Int Array#  -- 16 bytes, plus 8 bytes of boxed ints, plus 8 bytes of Array# header
17:45:45 <falconair_> newbie question: many papers which describe embedded DSLs define combinators and and ways of composing those combinators ... it seems the user is expected to combine the given combinators and not have to write functions too often ... does it make sense to consider that close to logic or relational style of programming than functional style?
17:45:57 <TomMD> @paste
17:45:57 <byteshack> it's a tree of "Boards"
17:45:58 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:46:01 <sorear> no, wait, 16 bytes of boxed ints.
17:46:07 <sorear> 40+ bytes per array!
17:46:15 <chessguy_away> gametree board = reptree moves board
17:46:24 <chessguy_away> it requires a parameter, presumably of type Board
17:46:34 <chessguy_away> and it results in a tree of boards, yes?
17:46:44 <byteshack> yes
17:46:45 <ddarius> falconair_: If I understand you correctly, not in general.
17:46:57 <chessguy_away> so gametree :: Board -> Tree Board
17:46:59 <chessguy_away> like i said
17:47:00 <emu> falconair_: composition of functions is core to FP
17:47:11 <procyon112> falconair_: It's often called "point-free" style
17:47:18 <chessguy_away> oh, i see what you're saying, ok
17:47:18 <byteshack> chessguy_away: yes
17:47:41 <monochrom> The use of combinators is not comparable to things before it.
17:47:46 <byteshack> I need to learn about types and make a Board type
17:47:59 <procyon112> falconair_: Or "Tacit style"
17:48:11 <hpaste>  TomMD pasted "Easier method with Binary.Put?" at http://hpaste.org/1425
17:48:13 * ddarius has never heard "tacit style"
17:48:19 <chessguy_away> i would actually be inclined to make a Move type too, in this case simply type Move = Int
17:48:20 <monochrom> Unless you compare it to abstract algebra.
17:48:27 <falconair_> sometimes these embedded dsls are are described in terms of universal quantification ...
17:48:30 <jcreigh> @tacit (\x -> f x)
17:48:31 <lambdabot> I know nothing about (\x
17:48:45 <chessguy_away> then you would want negamax :: [Move] -> Tree Board -> Move
17:48:48 <monochrom> put a space there
17:48:52 <procyon112> "Tacit" is used more in APL.. Haskell guys like us call it pointfree :)
17:49:01 <TomMD> ^^^ That says it all - I fooled myself with a non-complete test/example, and now I've written a fair amount of 'bad' code - is there a cleaner method of runPut?
17:49:22 <falconair_> quantification immediately send me running to SQL, and I try to translate those 'quantification' concepts into sql just so they make sense ... and sql is not functional ...
17:49:46 <monochrom> I did not see quantification in, say, Parsec.
17:49:48 <emu> quantification is from logic
17:49:57 <byteshack> chessguy_away: would I then put the eval (ie from Board pos to value) in negamax?
17:50:08 <ddarius> Let f, g : A -> B, f == g <=> forall a.f a == g a
17:50:33 <emu> that FP, relational calculus, and logic all share aspects is definitely true
17:50:45 <byteshack> right now, eval converts the board tree into the int tree, which is all that negamax sees
17:50:46 <sorear> falconair_: quantification is from logic, which is another name for type theory
17:50:47 <ddarius> But, yah, as monochrom said, which EDSL are you referring to for example?
17:50:58 <sorear> falconair_: and types are very important here
17:50:58 <falconair_> well, i am thinking of "Charting Patterns on Price" by Saswat Anand in which he describes a language for stock trading ...
17:51:03 <chessguy_away> byteshack: well, you certainly don't want to map over the tree twice
17:51:22 <sorear> fusion!
17:51:38 <chessguy_away> sorear: probably in some less formal sense, yes
17:51:53 <procyon112> falconair_: Technically, you only need ever write 2 functions, const and ap... but I don't recommend it :)
17:52:15 <TomMD> I've fooled myself into a) ignoring the types and b) assuming the run{Put,Get} does alot more for you.  Could someone tell me if my #2 method is 'the' intended method of use?  http://hpaste.org/1425
17:52:28 <falconair_> he shows how to say something like "if the moving average of a stock is blablah, then buy 1000 shares" ... but what i want to say, "... buy 1000 shares, but cancel THAT order if it doesn't get filled in 10 minutes"  "THAT" is never named, so I can access it or operate on it!
17:52:32 <sorear> procyon112: nah, you don't need two...
17:52:59 <procyon112> sorear: Yeah... you can use one.. but then it gets REALLY ugly :)
17:53:47 <sorear> procyon112: also, I don't recommend the kind of evil hacks needed to encode recursion with one combinator ;)
17:54:20 <monochrom> It is a fallacy to look for an analogy.
17:54:37 <byteshack> I guess the paper is trying to show how one can do such a separation of concerns.  Seems to me that fusing negamax with Board->value conversion in one pass would kind of kill that.
17:54:38 <sorear> TomMD: before worrying about type errors, fix your unbalanced parens :)
17:54:54 <TomMD> yeah, that was just a transcription error - I've got that.
17:55:21 <monochrom> Why are there transcription errors at all?  Is cut-n-paste buggy?  That buggy?
17:55:24 <procyon112> sorear: Yet strangely enough.. that's exactly what my genetic library is doing... Just wait until I have my "outputAsHaskell" function done, and I'll have all sorts of practical examples of unreadable code.
17:55:48 <TomMD> monochrom: arrrr, a break, I demand a break!
17:55:51 <sorear> Yes.
17:56:04 <sorear> I use the CONSOLE, and I *still* have copy/paste!
17:56:16 <allbery_b> @remember procyon112 Just wait until I have my "outputAsHaskell" function done, and I'll have all sorts of practical examples of unreadable code.
17:56:16 <lambdabot> Done.
17:56:39 <chessguy_away> byteshack: since you're selecting a move by evaluating the resulting positions, the two are really inherently inseparable
17:56:43 <allbery_b> }:>
17:57:00 <chessguy_away> trying to separate them just destroys all hope of efficiency
17:57:27 <sorear> TomMD: your first function ought to work, can you annotate the paste with the correctly-copied code and the error message?
17:57:41 <chessguy_away> and even at that, it doesn't work anyway
17:59:00 <byteshack> should have known better from such a paper
17:59:01 * monochrom sends TomMD '\n'
17:59:32 <sorear> monochrom: ?
17:59:52 <sorear> @seen beelsebob
17:59:53 <lambdabot> I haven't seen beelsebob.
18:00:40 * sorear tries to remember the correct spelling of 'beelsebob'
18:01:31 <igli> beelzebub; or someone else?
18:01:43 <sorear> How likely is SPJ to read all the follow-ups to the "Release plans" mail?
18:01:45 <TomMD> sorear: You are right... I should learn to paste _exactly_ what I have... not some distilled version... based on the fact that this works (thank you!) I think I've found the culprit.
18:02:06 <dons> sorear: more likely, simonm will read them.
18:02:23 <sorear> TomMD: distilling is fine, just test to make sure the problem is still there ;)
18:02:45 <chessguy_away> (nearly-random paste from the logs)
18:03:01 <sorear> dons: In my followup I complained about something that seems like it would be far more usefully heard by SPJ
18:03:04 <monochrom> engage in a tight edit-compile-paste cycle!
18:04:19 <sorear> tomdavies: what happened to beelsebob?  (curiousity only)
18:05:13 <tomdavies> perhaps you're mistaking me for 'tom davie'?
18:05:33 <sorear> er, yes :)
18:06:42 <dons> sorear: the codegen issue?
18:07:13 <chessguy_away> byteshack: have i managed to totally confuse you?
18:07:42 <dmead> whats the ghci command to call the garbage collector?
18:08:02 <byteshack> not yet :)
18:08:05 <sorear> Prelude> System.Mem.performGC
18:08:18 <byteshack> I'm back on my drawing board
18:08:29 <sorear> dons: no, the "left-to-right impredicative instantiation sounds like a Bad Idea"
18:08:54 <sorear> istr SPJ has nothing to do with the codegen (?)
18:09:13 <igli> ew GC yeuch.
18:09:18 * sorear has all the wrong gut feelings on who's territory is where, wrt the GHC project
18:09:56 <sorear> dmead: this won't actually free memory of course, GHC has a monotonic heap
18:09:56 <byteshack> chessguy_away: still trying to figure out why in universe the paper does 2 maps
18:10:01 <byteshack> sure seems wasteful
18:10:10 <chessguy_away> 2 maps where?
18:10:16 <dmead> why do i seem to remember there being a garbage collector command...
18:10:20 <dmead> or was that hugs..
18:10:22 <chessguy_away> (what page(s))
18:10:58 <sorear> dmead: hugs
18:11:17 <sorear> dmead: ghci doesn't need wimpy commands like those, it has modules ;)
18:11:21 <dmead> :)
18:11:29 <byteshack> page 18-19
18:12:54 <byteshack> pages 20-21 are just doing alpa-beta on the mini-max
18:15:55 <LordBrain> Anyone here use visual haskell?  I want to make the winpcap headers/libs available to link with and would be grateful if someone pointed me in the right direction..
18:46:59 <dons> dcoutts: new slogan: "Fusion: Its cool and only works when you dont have side-effects"
18:47:06 <dons> (http://mikeburrell.wordpress.com/2007/04/16/more-haskell-parallelism/)
18:47:07 <dons> ;-)
18:47:09 <lambdabot> Title: More Haskell parallelism  Closure Sale, http://tinyurl.com/ytoqxs
18:50:57 <dolio> Data parallelism is cool, but I don't think it solves the same problems as "that STM nonsense."
18:51:00 <dcoutts> dons: heh :-)
18:51:43 <SamB_XP> dons: but is it *cold*?
18:51:51 <dons> ice cold.
18:58:11 <dcoutts> dons: "He may have his own mini-Jobs reality distortion field, but I actually believe him." referring to SPJ on NDP ;-)
18:58:19 <dons> hehe
18:58:35 <dcoutts> dons: a quote for the HWN perhaps? :-)
18:59:42 <Gu2> i wonder if anyone is working on rewriting  minix 3 from c to haskell
19:00:05 <dcoutts> Gu2: there are some haskell kernel projects
19:00:25 <Gu2> House and hOP?
19:00:56 <dons> yeah, and the L4/Haskell kernel
19:01:02 <LordBrain> mini-Jobs?
19:01:06 <LordBrain> as in Steve Jobs?
19:01:09 <Gu2> oo didn't know about that one, thanks dons
19:01:40 <dcoutts> LordBrain: yeah :-)
19:02:22 <LordBrain> well i'm going home
19:02:39 <LordBrain> goodnight all
19:03:38 <dmwit> jcreigh: poke
19:04:25 <jcreigh> dmwit: yes?
19:04:40 <dmwit> Does mod+p work?  (It doesn't here.)
19:04:53 <dmwit> ...and I'm asking you because I'm using your patch. ;-)
19:05:18 <jcreigh> dmwit: you probably need to "upgrade"
19:05:20 <jcreigh> http://www.jcreigh.com/xmonad/xinerama-dmenu.html
19:05:22 <lambdabot> Title: xmonad + dmenu + xinerama: starting dmenu on the current screen
19:05:40 <dmwit> Which part?
19:05:46 <jcreigh> (needed to corerce to Int because we started using newtype of ScreenId...so show was getting "S 1")
19:05:50 <jcreigh> dmwit: just the xmonad action
19:05:59 <dons> jcreigh: ah right.
19:06:03 <jcreigh> dmenu patch is unchanged.
19:06:10 <dmwit> Okay, ta.
19:06:11 <dons> jcreigh: oops eh. did that patch land in the repo?
19:06:18 <dons> (I didn't see it)
19:06:55 <jcreigh> dons: xinerama-dmenu integration is no longer in the repo. (I took it out because it doesn't seem worth it to have stuff in xmonad that needs an external patch anyway.)
19:07:33 <dons> and the S 1 issue doesn't affect any of our other shell calls?
19:07:41 <jcreigh> I don't believe so...
19:07:53 <dmwit> Hmm, I must be running a stale version, because my Operations.hs matches the patch you have.  Hold on a sec.
19:08:32 <jcreigh> dmwit: If I need to change this in the future, I'll try to remember to ping the mailing list instead of leaving people to wonder why it doesn't work.
19:08:53 <dmwit> jcreigh: This still doesn't work for me. =(
19:10:01 <jcreigh> dmwit: if you open up a shell and type "echo hi there | dmenu -xs 1", does that show dmenu on the first screen?
19:10:20 <dmwit> !
19:10:24 <dmwit> No, so it's my fault.
19:10:36 <jcreigh> dmwit: not nessesarily.
19:10:47 <sioraiocht> so anyone here like, pro with lambdabot?
19:10:52 <jcreigh> I forgot to mention that I changed the dmenu patch too. :)
19:11:16 <jcreigh> the old dmenu patch took and -x and -w option...the new one just takes a screen number.
19:11:51 <jcreigh> I had assumed you had new dmenu patch, but pre-"show bugfix", but I'm guessing you have the old dmenu patch as well.
19:11:59 <dmwit> Ah, okay.
19:12:22 <sioraiocht> guess not, I guess everyone jst depends on dons to run it ;)
19:12:49 <jcreigh> dons++ good idea checking for xmonad before blindly exec()'ing
19:13:24 <dons> solves one bug report
19:14:18 <jcreigh> dmwit: in case you're wondering, I changed the dmenu patch so that -b would work, not because I like to arbitrarily break things. :)
19:14:50 <dmwit> jcreigh: Actually, specifying a screen is better in my opinion anyway.
19:14:59 <jcreigh> dmwit: yes, it is better anyway.
19:14:59 <dmwit> It makes it more usable with my mod+a keybinding. =)
19:15:13 <dmwit> Aha, now it works!  Thanks for your help.
19:16:42 <jcreigh> dmwit: np. Sorry for not giving up the heads up on the changes.
19:16:52 * jcreigh will hit the ML the next time something like that needs to change.
19:17:08 <jcreigh> dmwit: what does you mod+a binding do?
19:23:08 <TomMD> is there a good reason most the functions (ex: replicate*) that take 'Int' aren't polymorphic?  Or is this just historical?
19:25:02 <monochrom> One reason is that most applications use Int, which is more efficient than general Integral.
19:25:21 <monochrom> One reason is that Int is also sufficient for most applications.
19:25:49 <monochrom> One reason is that there are genericLength, genericTake, etc., that take general Integral.
19:26:56 <monochrom> There is genericReplicate :)
19:28:37 <dmwit> jcreigh: It pulls up a dmenu with the actions: firefox, music, readmail, screensaver, todo, volume, xm.
19:28:53 <dmwit> So I can launch any of the most common things with a single discriminator key. =)
19:29:24 <jcreigh> dmwit: ah. I have mod-p bound to a similar, static setup.
19:31:10 <dolio> None of those are especially good reasons, though. :) The 'best' is probably "type classes are burdensome for teaching newbies."
19:37:19 <sioraiocht> anyone know what woudl cause error: IRCRaised <socket: 5>: hGetChar: end of file in lambdabot besides a bad nick (ruled that out)
19:39:41 <monochrom> counting mistake.  parsing mistake.  irc protocol stack mistake.
19:40:02 <jcreigh> dmwit: I was thinking...probably the most useful type of "dmenu" would be dmenu :: [String] -> X String
19:40:22 <jcreigh> but inter-process IO is kinda scary, so I haven't got around to it yet.
19:41:13 <dmwit> Oh, is it?
19:41:31 <dmwit> I don't really have time to work on it tonight, but I'd like that too.
19:41:58 <jcreigh> well...it's not simple like it should be.
19:42:09 <dmwit> Wait, why [String] ?
19:42:13 <dmwit> Oh, I see.
19:42:20 <dmwit> The things to pass to dmenu.
19:42:25 <jcreigh> dmenu ["firefox", "xterm -e mutt"] >>= spawn
19:43:04 <dmwit> Yeah, or function_to_list_things >>= dmenu >>= spawn
19:46:09 <pirothezero> is there a trace call in any of the haskell interpreters?
19:46:19 <pirothezero> or some app that you can trace calls in?
19:46:28 <sjanssen> @hoogle trace
19:46:29 <lambdabot> Debug.Trace.trace :: String -> a -> a
19:46:29 <lambdabot> Debug.Trace :: module
19:46:29 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
19:46:37 <icarroll> pirothezero: what kind of trace call?
19:47:00 <pirothezero> like a debugger
19:47:10 <pirothezero> or what drscheme does for scheme maybe
19:47:22 <icarroll> I don't know drscheme, sorry.
19:47:31 <allbery_b> hat?  which sadly is kinda lame
19:47:38 <allbery_b> @where hat
19:47:39 <lambdabot> http://www.haskell.org/hat/
19:47:47 <pirothezero> ie, being able to step into each function call and watch what happens to the lists
19:47:47 <icarroll> I've had trouble finding a haskell debugger too. :(
19:47:59 <allbery_b> 6.7's ghci has a debugger
19:48:04 <allbery_b> I haven't played with it though
19:48:06 <icarroll> yay for 6.7
19:48:07 <monochrom> I am a debugger.
19:48:09 <icarroll> heh
19:48:48 <pirothezero> ya that hats thing might do the trick
19:49:22 * Cale uses google to find bloggers learning Haskell. :)
19:49:38 <icarroll> @quote blog
19:49:39 <lambdabot> monochrom says: These 113 blogging accounts of course don't cost me.  But I still get the feeling of lying around with 113 prostitutes... XD
19:50:01 <merus> Cale, I should do that and blog learning Haskell. That could be moderately amusing.
19:51:32 <merus> I need to get 6.6 before I do that, though =/
19:54:51 <Cale> merus: A binary shouldn't be too hard to get.
19:55:31 <merus> Cale, I'm a Debian noob ;_; I'm still learning about running a mixed build.
19:56:00 <Cale> Oh, which branch are you running?
19:56:05 * mlh whispers "Fedora6 has ghc 6.6"
19:56:09 <merus> stable, and that only has GHC to 6.2
19:56:16 <Cale> I ran debian unstable for 5 or 6 years.
19:56:37 <merus> I tried to upgrade to unstable once or twice but botched it, lol.
19:56:39 <Cale> Ah, stable is generally good for servers which you don't actually touch very often.
19:56:51 <dolio> Isn't stable etch now? That should have 6.6
19:57:07 <dolio> Or is that just testing?
19:57:29 <Cale> Testing or unstable are better for machines you're actually going to sit at
19:58:10 <Cale> It should be as easy as updating your /etc/apt/sources.list and then doing an apt-get update; apt-get dist-upgrade
19:58:33 <merus> Hmm, well, I don't have class tomorrow, perhaps I'll try it again.
19:59:13 <merus> Oho, it is at 6.6 now  I think.  It says version 6.6-3
19:59:21 <Cale> Unstable is generally fairly stable, though there were a couple of times in those 5 years where a package I cared about was uninstallable. Generally it started working the next day or so.
19:59:29 <Cale> Cool :)
19:59:35 * merus apt-gets
19:59:53 <campusblo> wxhaskell not working. getting compatibility issues
20:00:31 <campusblo> anybody know a proper working combination
20:00:35 <campusblo> ?
20:01:04 <Cale> Combination?
20:01:16 <campusblo> i tried 6.4 ghc and wx 9.4.1
20:01:27 <campusblo> as on the website
20:01:38 <campusblo> i had a newer version of ghc that i uninstalled first
20:01:44 <campusblo> could this be the problem?
20:02:16 <campusblo> im getting version conflict messages when trying to install wxhaskell
20:02:24 <Cale> hmm
20:02:24 <campusblo> using the batch file
20:02:57 <campusblo> i had 6.6
20:03:14 <campusblo> maybe a restart is worth a try?
20:03:34 <campusblo> im on windows xp btw using binaries
20:03:38 <Cale> I'm not sure. I'm going to try out the darcs version with 6.6 and see how that goes.
20:04:18 <campusblo> you trying that now?
20:04:28 <Cale> yeah, just finished grabbing the darcs repo
20:04:39 <sorear> .
20:05:01 <campusblo> ok cool
20:05:09 <sorear> back...
20:05:53 <campusblo> ok im gonna restart and come back
20:05:58 <Cale> okay
20:09:35 <dmead> ahh windows
20:10:07 <merus> "GHC Interactive, version 6.6, for Haskell 98." Yay!
20:10:10 * merus dances.
20:13:19 <sorear> GHC Interactive, version 6.7.20070413, for Haskell 98.
20:13:55 <merus> Eh, I'm always a bit behind the times :)
20:14:21 <Cale> 6.7 is a development branch
20:14:32 <merus> I know :)
20:36:14 <irc> hi, haskell n00b herre
20:36:32 <sorear> most of the people here are
20:36:45 <araujo> irc, welcome to lambda land
20:37:00 <sjanssen> @yow
20:37:00 <lambdabot> All of life is a blur of Republicans and meat!
20:37:19 <sorear> > nubBy(((>1).).gcd)[2..]  -- a wonderful example of haskell's twin prowess in expressiveness and obfuscation!
20:37:21 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
20:37:40 <fantasmaa> i liked your other nickname more
20:37:44 <pchiusano> heh
20:38:17 <merus> sorear, that's obfuscated?
20:38:19 <irc> cool
20:38:23 <pchiusano> if I have a type, E, with several constructors
20:38:31 <sorear> so, do you want to know something?  or are you just here to listen to the experts sidetrack each other? :)
20:38:54 <irc> sorear: that's pretty productive for a mostly idle activity :p
20:38:58 <pchiusano> and I want to have a function f, which takes an E
20:39:06 <sorear> ...
20:39:10 <pchiusano> what is the syntax for that
20:39:17 <pchiusano> so, I don't want to deconstruct
20:39:24 <pchiusano> I want to say:
20:39:36 <pchiusano> f E = 34
20:39:43 <sorear> f _ = 34
20:39:55 <pchiusano> but I want to assign the instance of E to a variable that I refer to on the other side
20:40:01 <sorear> that will take ANY value, of ANY type, and throw it away
20:40:11 <sorear> f x = ... something involving x ...
20:40:25 <hyrax42> sorear, you type quite quickly
20:40:49 <fantasmaa> haha great comment
20:40:59 <pchiusano> okay, there is no syntax for what I am describing?
20:41:04 <fuzan> sorear actually uses a question lookup bot
20:41:05 <sorear> huh?
20:41:11 * allbery_b doesn't get what you're trying to describe
20:41:14 <fuzan> he's already answered pretty much any question you could come up wiht.
20:41:38 <sorear> pchiusano: functionName valueToBind = rightHandSide
20:41:57 <allbery_b> f :: E -> WhateverYourResultTypeIs; f x = ...
20:42:02 <sorear> pchiusano: if the valueToBind is lowercase, it is bound to the whole arg, w/o deconstructing
20:42:14 <sorear> pchiusano: or were you asking about specifying the type?
20:42:19 <pchiusano> yes
20:42:27 <sorear> pchiusano: in that case you can use what allbery_b sai
20:42:41 <pchiusano> is the only place to do that in the type declaration?
20:42:48 <sorear> or, if you don't know the return type, there is a bit of a hack you can use
20:42:54 <sorear> f x = .... where _ = x :: E
20:43:04 <fantasmaa> clever
20:43:12 <sorear> but if you know the return type, you should use a proper type declaration, yes.
20:43:22 <allbery_b> in theory I think you could do:  f (x :: E) = ... -- but I'm not sure that would work, or woudn't confuse type inference
20:43:34 <allbery_b> because it's distnct from a type declaration
20:43:40 <sorear> allbery_b: that does work, but it requires -fglasgow-exts
20:43:41 <hyrax42> allbery_b: I think it's an extension only
20:43:46 <allbery_b> ah.
20:43:47 <hyrax42> god damn it sorear
20:43:50 <allbery_b> does it treat it as a pattern?
20:44:03 <pchiusano> trying that...
20:44:04 <sorear> allbery_b: also, it AIDS type inference - you need it if you want x to have a polytype
20:44:04 <allbery_b> or as an implicit declaration?
20:44:10 <sorear> allbery_b: yes, it's a pattern
20:44:20 <allbery_b> ok, that's what I figured it'd do
20:44:38 <allbery_b> (made sense to me that it would either be a pattern or would cause confusion, since it's not actually a type declaration)
20:44:46 <pchiusano> wait, so f (x :: E) = blah should be possible?
20:44:57 <pchiusano> I just tried it and it did not compile
20:45:01 <LoganCapaldo> Oooooooo, sorear scares me because he is so young. I am terrified of sorear :)
20:45:12 <sorear> pchiusano: yes, but only if you enable pattern type signatures in the compiler, -fglasgow-exts option
20:45:30 <hyrax42> LoganCapaldo: well mostly anything I could answer he can answer better, and apparently is able to type quicker too
20:45:37 <hyrax42> so in the end I'm just here to boost the user count
20:45:38 <hyrax42> ?users
20:45:39 <lambdabot> Maximum users seen in #haskell: 336, currently: 290 (86.3%), active: 39 (13.4%)
20:45:40 <allbery_b> it's not valid Haskell98
20:45:44 * sorear lurches over LoganCapaldo and whistles menacingly
20:45:47 * LoganCapaldo notes that my last sentence should be sung like a little ditty
20:45:52 <allbery_b> in theory you could have a polymorphic f and say:
20:46:00 <allbery_b> f (x :: A) = ...
20:46:00 * Cale wonders when campusblo is getting back.
20:46:10 <allbery_b> f (y :: B) = ...
20:46:21 <pchiusano> right
20:46:21 <sorear> allbery_b: eh?
20:46:22 <hyrax42> oh Cale, a very quick yes/no question for you
20:46:28 <Cale> The darcs version of wxhaskell seems to work great with GHC 6.6
20:46:35 <allbery_b> that's what pattern matching types would do, no?
20:46:40 * sorear gets ready to type faster than Cale!
20:46:51 <hyrax42> have you heard of an initial lift of a structured source?
20:46:51 <Cale> sorear: heh
20:46:52 <sorear> allbery_b: no, see 'parametricity'
20:47:14 <allbery_b> hm
20:47:17 <sorear> I've heard of initial objects in categories, but that's about it ;)
20:47:17 <Cale> hyrax42: no
20:47:34 * allbery_b is too tired to think this through properly; spent too much time standing outside in horizontal sleet :/
20:47:35 <hyrax42> Cale: okie
20:47:39 <Cale> hyrax42: though I'd be willing to look at the definition and try to interpret it :)
20:47:45 <hyrax42> I'll just take them at their word that it's something I should recall
20:47:47 <LoganCapaldo> sorear: you can't type faster for that question, unless you know everything Cale's heard of or not heard of. hyrax42 has defeated you :)
20:47:56 <allbery_b> (and now have a terrible cold...)
20:48:09 * hyrax42 laughs evilly
20:48:33 <hyrax42> actually a newbie question answer-off between cale, sorear and dons would be sort of interesting
20:48:42 <sorear> @quote stereo
20:48:43 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
20:48:57 <sorear> is pchiusano still here, or did we scare him away?
20:49:08 <pchiusano> I'm frighted and confused
20:49:40 <hyrax42> coming soon: dodecaphonic surround sound
20:49:49 <LoganCapaldo> Now with more cow bell!
20:50:38 <pchiusano> what rules does the lambdabot follow?
20:50:51 <pchiusano> ?lambdabot
20:50:52 <lambdabot> Unknown command, try @list
20:50:56 <Cale> Haha, dodecaphonic sound! One of the speakers is actually embedded inside you!
20:50:59 <hyrax42> ?vixen
20:51:00 <lambdabot> <undefined>
20:51:03 <pchiusano> @list
20:51:04 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
20:51:17 <hyrax42> Cale: classic, eh :p
20:51:22 <pchiusano> ?haskell
20:51:22 <lambdabot> Unknown command, try @list
20:51:48 <fantasmaa> anyone know anything of the book titled "Beautiful Code"
20:51:56 <LoganCapaldo> pchiusano: what are you trying to do?
20:51:59 <sorear> heard of it
20:52:11 <sorear> spj's vain attempt to make hyaskell popular
20:52:16 <Cale> Hmm... searching google only returns serious results...
20:52:28 <Cale> I can't actually remember where I'd heard that joke anymore.
20:52:36 <LoganCapaldo> sorear: Is your usage of "vain" there pun intended?
20:52:46 <pchiusano> @quote
20:52:47 <lambdabot> robreim says: I'm in your base hacking all your lambdas
20:53:02 <pchiusano> @quote
20:53:02 <lambdabot> nmessenger says: EVERYONE ADMIRE MY ELDERBY HAT!!
20:53:18 <pchiusano> huh, ok, enough of that
20:53:32 <dolio> Wasn't SPJ's thing "Beautiful Concurrency"? About STM?
20:53:35 <lambdabot> Hello.  I am Lambdabot-9000.  Those who do not revere me will be eliminated.  Have a nice day.
20:53:43 <araujo> haha
20:53:47 <araujo> @botsnack
20:53:48 <lambdabot> :)
20:53:50 <LoganCapaldo> Is that like a derby hat, but eldritch?
20:53:54 <hyrax42> Cale: it's space quest 4
20:53:59 <fantasmaa> sorear: what
20:53:59 <Cale> Aha!
20:54:11 <fantasmaa> sorear: what's wrong with his attempt to make it popular?
20:54:16 <Cale> That was a great game :)
20:54:24 <hyrax42> don't forget the speaker that makes the sound come from your neighbour's upstairs window
20:54:41 <sorear> fantasmaa: there is a 2-syllable answer to that question
20:54:47 <plediii> @pl (\f l -> l ++ map f l)
20:54:48 <lambdabot> ap (++) . map
20:54:48 <hyrax42> oh very
20:55:10 <Cale> Real-Rustic, Dodecaphonic, AroundSound Processor. Ever notice how flat and unexciting normal stereophonic, quintophonic, and octophonic recordings are? With the Real-Rustic, Dodecaphonic, AroundSound Processor, your music will seem to come from twelve directions: In front of you, behind you, either side of you, four midpoints above you, from below you, from inside of you, and from the upstairs neighbors! 877 buckazoid
20:55:10 <Cale> s.
20:55:29 <fantasmaa> sorear: no-thing?
20:55:31 <sorear> fantasmaa: "Java"
20:55:39 <hyrax42> haha
20:56:17 <fantasmaa> sorear: in the sense that Java was ruined by popularity?
20:56:23 <hyrax42> on the sorear vs. cale thing, I dont' think sorear could have got that reference...
20:56:28 <sorear> fantasmaa: yes.
20:56:29 <hyrax42> he'd have been what, 4-5 at the time?
20:56:32 <hyrax42> ;)
20:57:21 <pchiusano> hum, when defining functions
20:57:33 <sjanssen> was Java ever good?
20:57:35 <pchiusano> suppose I want to specify that two args are equal
20:57:38 <pchiusano> like:
20:57:51 <sjanssen> pchiusano: f x y | x == y = stuff with x and y
20:57:51 <pchiusano> add x x = mult 2 x
20:58:01 <sorear> f x y | x == y = rhs
20:58:01 <sorear>       | otherwise = diff
20:58:02 <LoganCapaldo> can't do it
20:58:09 <stepcut> http://ccrma.stanford.edu/~nando/clm/dlocsig/
20:58:11 <lambdabot> Title: "dlocsig" dynamic spatial location unit generator
20:58:16 <sorear> indeed, you quite specifically can't.
20:58:28 <LoganCapaldo> not allowed to say x twice like that
20:58:34 <sorear> you could do that in Miranda, but it proved very can-of-worms-y
20:58:36 <pchiusano> ya, I noticed that
20:58:45 <pchiusano> but guards work
20:59:04 <pchiusano> why was it can-of-worms-y
20:59:20 <sorear> http://haskell.org/onlinereport/decls.html#sect4.4.3
20:59:22 <lambdabot> Title: The Haskell 98 Report: Declarations
20:59:31 <sorear> look around the bold word 'linear'
20:59:31 <merus> Is there a HOF for applying a two-place function to the same argument in both places?
20:59:37 <sorear> join
20:59:41 <merus> oh, right
20:59:41 <sorear> > join (+) 20
20:59:43 <lambdabot>  40
20:59:53 <merus> :t join
20:59:53 <Cale> ReShrinkWrap 2000! Work for a large retail software chain? Like to take the products home and "diddle" with them? The ReShrinkWrap 2000 re-shrinkwraps any size software box. Is that game new or used? Only you'll know for sure. Keep the customers guessin'. Dealers only, please. 1,033 buckazoids.
20:59:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
21:00:34 <stepcut> with dlocsig, you can specify the number and position of your speakers (even if you have 12 of them), and then simulate sounds moving around in 3D space (including the dopler effect)
21:01:12 <LoganCapaldo> > let forces = (+); planeteers = 12 in join forces planeteers
21:01:14 <lambdabot>  24
21:01:20 <LoganCapaldo> err
21:01:25 <merus> hahahha
21:01:39 <hyrax42> lol
21:01:40 <LoganCapaldo> I'm not dyslexic
21:02:10 <LoganCapaldo> > let forces = (+); planeteers = 21 in join forces planeteers
21:02:18 <lambdabot>  42
21:02:28 <pchiusano> when you have an equation
21:02:31 <sorear> @activity 60
21:02:31 <lambdabot> 1*total 1*#haskell
21:02:32 <pchiusano> like:
21:02:47 <sorear> > let 2 + 2  = 5 in 2 + 2
21:02:49 <lambdabot>  5
21:02:55 <pchiusano> f somecomplicatedpattern | some guard on the pattern = blah
21:03:08 <pchiusano>                            | otherwise = something else
21:03:14 <sorear> *nod*,
21:03:31 <pchiusano> does the otherwise just apply to things which matched somecomplicatedpattern
21:03:37 <pchiusano> or does it catch everything
21:03:38 <sorear> yes/
21:03:50 <sorear> no, just the ones that match the pattern
21:03:59 <sorear> if you want a catch everything case, use
21:04:04 <sorear> f _ = something different
21:04:26 <pchiusano> cool
21:04:43 <sorear> also, if it makes things any easier to understand - otherwise is just True
21:04:46 <sorear> > otherwise
21:04:48 <lambdabot>  True
21:05:15 <pchiusano> huh
21:05:29 <pchiusano> i see
21:06:08 <pchiusano> > 2 + 3
21:06:10 <lambdabot>  5
21:06:28 <pchiusano> > "hello" ++ "world!"
21:06:30 <lambdabot>  "helloworld!"
21:06:35 * sorear looks forward to explaining haskell's more esoteric^?^?^?^?^?^?^?advanced features to pchiusano 
21:06:51 <pchiusano> heh
21:06:56 <pchiusano> haskell is cool
21:07:07 <pchiusano> I'm learning it for fun
21:07:15 <pchiusano> I have to program in java at work
21:07:19 <pchiusano> :-(
21:07:20 * sorear did too, about a year ago
21:07:25 <LoganCapaldo> Yeah, about as cool as dry ice
21:07:28 <pchiusano> which?
21:07:32 * sorear doesn't have to deal with work yet :)
21:07:32 <LoganCapaldo> deadly cool
21:07:35 <pchiusano> learn haskell or program in java?
21:08:07 <hyrax42> the fact that sorear is as old as my younger brother is sort of scary
21:08:12 <hyrax42> he's way less well-versed in haskell
21:09:25 <stepcut> hyrax42: sorear is less well-versed in haskell than your brother
21:09:27 <stepcut> that is scary
21:09:35 <LoganCapaldo> that's not scary
21:09:42 <hyrax42> stepcut: :p
21:09:48 <LoganCapaldo> thats Lovecraftian gibbering madness terrifying
21:10:12 <hyrax42> I couldn't be bothered to bind the free pronoun
21:10:21 <sorear> dons has been haskelling eight times longer than me.
21:10:52 <LoganCapaldo> yes this room is chock full of extraordinary people
21:11:22 <jcreigh> I'm here too. :)
21:11:51 <sorear> the guy who wrote the very first haskell compiler frequents here
21:11:58 <sorear> well, lazy fp
21:12:10 <LoganCapaldo> see
21:12:20 <sorear> and I'm not entirely sure it was actually him, just pretty sure
21:12:28 <LoganCapaldo> I'm just here to bring down the average IQ
21:12:38 * SamB_XP thinks this binary tree code cheats :-)
21:12:55 <sorear> SamB_XP: did you get my /msg?
21:13:02 <SamB_XP> sorear: yes
21:13:06 <sorear> it's kinda interesting.
21:13:28 <sorear> augustsson was THE name in fp compiler reasearch, twenty years ago
21:14:10 <sorear> now he's nobody, so completely forced out of his niche that he has nothing better to do than help n00bs on IRC
21:14:13 <SamB_XP> hyrax42: oh no
21:14:20 <SamB_XP> the pronoun, it is escaping!
21:14:47 <hyrax42> jumped out the window and caused mass panic, yep
21:15:31 <pchiusano> I can't seem to use Num as an argument to a constructor
21:15:44 <sorear> right, it's a type class
21:15:52 <pchiusano> like data E = Woot Num
21:16:05 <sorear> yes, Num isn't a type
21:16:15 <sorear> it refers to a set of types
21:16:21 <LoganCapaldo> data (Num a) => data E = Woot a -- I think
21:16:26 <LoganCapaldo> err
21:16:30 <pchiusano> okay, is there a way you can specify that a constructor can take any instance of a typeclass?
21:16:31 <sorear> you want to use a more specific type, like data E = Woot Int
21:16:33 <LoganCapaldo> kill the redundant data
21:16:41 <sorear> or, data E a = E a
21:16:55 <dcoutts> data E a = Num a => Woot a
21:17:00 <sorear> generally you don't want to put type class constraints on data types.
21:17:12 <pchiusano> okay
21:17:21 <dcoutts> data E = forall a. Num a => Woot a  --muwahahaha!
21:17:34 <dcoutts> pchiusano: ignore me.
21:17:48 <monochrom> data E = Woot (Num a => a)
21:17:57 <hyrax42> yeah it seems standard practice to put the constraints on the functions that force them
21:17:59 <LoganCapaldo> I think dcoutts got all existential on us
21:18:03 <monochrom> to complete all combinations
21:18:09 <dcoutts> monochrom: hmm, you need a forall
21:18:14 <monochrom> Yah
21:18:24 <hyrax42> ?type M.toList
21:18:27 <lambdabot> forall k a. M.Map k a -> [(k, a)]
21:18:33 <hyrax42> but
21:18:37 <hyrax42> ?type M.fromList
21:18:39 <monochrom> Well we're confusing the asker, may as well make sure the code is wrong.
21:18:40 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
21:18:46 <dmead> whats the deadline for HCAR?
21:19:01 <dcoutts> hyrax42: that's because class constraints on data constructors are currently nearly useless
21:19:06 <pchiusano> what does data E a = E a main
21:19:10 <pchiusano> *mean
21:19:15 <dcoutts> hyrax42: if they weren't useless we'd use them more
21:19:23 <sorear> dmead: soon, <1 month
21:19:26 * sorear greps logs
21:19:26 <hyrax42> dcoutts: "currently"?
21:19:56 <dmead> gah
21:19:59 <dmead> must code faster
21:20:07 <LoganCapaldo> pchiusano: It means your declaring a type E parametized on another single type that has a single constructor also named E that has an argument of the tpye (a) you are parametizing E on.
21:20:24 <dcoutts> hyrax42: for GADTs in GHC they mean the right thing, but they've not changed the meaning for ordinary data decl style since it wouldn't be H98 anymore, but the suggestion is to do it right for H'
21:20:52 <hyrax42> hmm what is the "right thing"
21:20:55 <dcoutts> pchiusano: on it's own 'data E a = E a' isn't terribly useful or exciting
21:20:59 <LoganCapaldo> in other words after you've said data E a = E a, you can say E "a string" which will have type E [Char]
21:21:04 * dmead starts working on occurschecking
21:21:07 <sorear> dmead: May 2
21:21:11 <pchiusano> Logan, I see
21:21:17 <dmead> k
21:21:29 <dcoutts> hyrax42: that if you put class constraints on a data constructor, you can assume those constraints when you donstruct a value using that data constructor
21:21:34 <pchiusano> basically, you can parameterize type defs much like functions
21:21:45 <LoganCapaldo> note that you don't have to name the constructor the same as the type, data E a = Foo a is fine too and Foo "S" will have type E [Char]
21:21:56 <LoganCapaldo> yes
21:22:00 <LoganCapaldo> exactly
21:22:08 <pchiusano> right
21:22:19 <dcoutts> pchiusano: what does this one mean? : data List a = End | Node a (List a)
21:22:38 <hyrax42> dcoutts: ahhh so that is how the instance Monad Set thing works
21:22:44 <dcoutts> hyrax42: right.
21:22:57 <hyrax42> so in H' that wouldn't require GADTs?
21:24:05 <hyrax42> well there's my one bit of #haskell-related enlightenment I think
21:24:10 <dcoutts> hyrax42: there's nothing special about it being GADT, it's just that the alternative syntax allows you to get away with other non-H98 things, like fixing constructor class constraints
21:24:17 <pchiusano> it is a parameterized definition of list
21:24:45 <dcoutts> hyrax42: you can write 'ordinary' data declarations in GADT style
21:24:46 <pchiusano> so is List "a" a List of strings
21:25:05 <dcoutts> List String is a list of strings
21:25:07 <hyrax42> dcoutts: I see... so in H' you could define that without using data ... where ...?
21:25:15 <pchiusano> okay...
21:25:27 <dcoutts> Node "a" End is a particular list of strings
21:25:47 <dcoutts> it's the list that has just one element in it, namely the string "a"
21:25:53 <pchiusano> okay
21:26:00 <pchiusano> does List "abc" mean anything?
21:26:08 <dcoutts> pchiusano: keep the distinctions between types and values clear
21:26:09 <pchiusano> or is that an error
21:26:18 <LoganCapaldo> List is not a constructor
21:26:22 <dcoutts> List is a type constructor, "abc" is a value
21:26:28 <LoganCapaldo> so you can't use it to make values
21:26:39 <LoganCapaldo> err its a constructor
21:26:42 <LoganCapaldo> of types
21:26:45 <pchiusano> right
21:26:48 <LoganCapaldo> what dcoutts said
21:26:51 <dcoutts> as opposed to a value constructor
21:27:02 <pchiusano> I understand, I think
21:27:15 <hyrax42> ?kind (->)
21:27:18 <lambdabot> ?? -> ? -> *
21:27:26 * LoganCapaldo feels like he has to be extra precise in this channel
21:27:35 <hyrax42> bleh
21:27:37 <hyrax42> ok bedtime
21:27:42 <hyrax42> night all
21:27:43 <dcoutts> LoganCapaldo: it helps to avoid confusion :-)
21:27:48 <dcoutts> g'night hyrax42
21:27:52 <pchiusano> 'night
21:28:12 <pchiusano> actually, I need to get to bed as well
21:28:18 <pchiusano> thanks for your help, all
21:28:23 <pchiusano> I'll prolly be back
21:28:27 <hyrax42> pchiusano: be back
21:28:28 * dcoutts returns to hacking on high performance binary deserialisation
21:28:28 <LoganCapaldo> I am already in bed
21:28:29 <hyrax42> it works
21:28:32 <LoganCapaldo> Or I should be
21:28:43 <LoganCapaldo> gah
21:28:52 <LoganCapaldo> IRC is a horrible distraction
21:29:08 <hyrax42> s/IRC/internetses
21:29:13 <dcoutts> LoganCapaldo: there's an important difference, one implies you have a computer within arm's reach of your bed, which is probably unhealthy :-)
21:29:36 * allbery_b wonders how much of an arse-kicking he's in for :>
21:29:47 <LoganCapaldo> probbaly
21:29:59 <LoganCapaldo> I only sleep with the laptop sometimes, when its really cold out :)
21:30:06 <dcoutts> hah
21:30:56 <monochrom> IRC is a good lullaby
21:31:08 <allbery_b> hey dcoutts:  how do I do in gtk2hs the equivalent of registering for a signal notify::expanded on a GtkExpander (cf. the C API documentation)?
21:31:29 <monochrom> cuddle up in bed, wrap yourself around laptop, watch #haskell, doze off.
21:31:44 <allbery_b> (basically finding out whne the expander is expanded or contracted, so I can save the state)
21:31:58 <monochrom> You will dream of infinite types and lazy thunk strings.
21:32:20 <LoganCapaldo> I'm surprised I havn't dreamt of haskell yet
21:32:36 <monochrom> your dreams are more abstract than haskell
21:32:43 <LoganCapaldo> just goes to show I don't get Comonads, Streams or Arrows yet :)
21:32:56 * allbery_b would not dream in haskell --- haskell makes sense, his dreams don't :>
21:33:13 <monochrom> When you see a car in your dream, it stands for a generalization of categories.
21:33:27 <allbery_b> I tend to find myself exploring Escher-like houses and the like
21:33:46 <monochrom> That's a generalization of fixed points.
21:34:13 <dcoutts> allbery_b: I don't see any expanded signal, there's a activate signal in the gtk C api and similarly in the gtk2hs api
21:34:27 <dcoutts> is that what you meant?
21:34:28 <allbery_b> it's not a widget-specific signal
21:34:47 <allbery_b> basically the C API lets you listen fr a signal notify:<<attribute>> for any widget attribute
21:35:05 <allbery_b> so e.g. notify::expanded to listen for changes to the "expanded" attribute of a GtkExpander
21:35:23 <dcoutts> allbery_b: ah yes, that. Right we don't have that yet, to listen for changes in a property.
21:35:30 <LoganCapaldo> its an observer
21:35:38 <LoganCapaldo> heh
21:35:41 <SamB_XP> allbery_b: ... that does not sound like a C api!
21:35:42 <LoganCapaldo> I said observer
21:35:48 <LoganCapaldo> in #haskell
21:35:52 <allbery_b> SamB_XP: the Gtk+ CV API
21:35:59 <allbery_b> er, C API
21:36:02 <LoganCapaldo> I'm probably gonna be burned out the stake
21:36:07 <SamB_XP> C has no ::!
21:36:08 <bos> whew.
21:36:10 <bos> @seen dcoutts
21:36:10 <lambdabot> dcoutts is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard dcoutts speak 47s ago.
21:36:17 <dcoutts> hia bos
21:36:21 <allbery_b> no, Gtk+ signals are strings
21:36:29 <LoganCapaldo> the only thing worse would be if I said "singleton"
21:36:34 <dcoutts> bos: I'm just about to apply your cabal sdist patch btw
21:36:35 <LoganCapaldo> Or belgium
21:36:36 <SamB_XP> oh!
21:36:47 <SamB_XP> !
21:36:50 <bos> dcoutts: you took the question right out of my keyboard :-)
21:36:51 <allbery_b> owing to the limited "type" system of C
21:36:54 * SamB_XP ! goes ! to bed !
21:37:03 <dcoutts> allbery_b:  we didn't realise originally how important that was. Our current plan is to allow you to get a signal from any property.
21:37:30 <monochrom> SamB_XP eagerly goes eagerly to bed eagerly?
21:37:48 <dcoutts> allbery_b: something like: on (notify prop) object $ do ...
21:38:04 <SamB_XP> monochrom: more like "loudly!"
21:38:20 <allbery_b> ok.  in any case it sounds like I need to do it differently.  guess I add more checkboxes to the properties window :)
21:38:56 <allbery_b> I also found what I think is a bug in the gconf interface:  if I gconfSet a list value it's written to the registry backwards
21:39:11 <monochrom> that's fun
21:39:19 <SamB_XP> is it read backwards too?
21:39:24 <allbery_b> so [1, 2, 3] is saved as [3, 2, 1] and gconfGet reads it back in as such
21:39:24 * SamB_XP is very slow at going to bed
21:39:44 <SamB_XP> that does sound like a bug ;-)
21:39:45 * sorear /kills SamB_XP
21:39:58 <monochrom> You need more ! strictness annotations in your going to bed.
21:40:05 * allbery_b watched in gconf-editor as he wrote test values and read them back
21:40:20 * SamB_XP actually leaves now, any further comments will be missed unless #haskell is less active than usual
21:40:23 * LoganCapaldo notices that the most interesting things posted on reddit are always the ones with a very few comments or none at all
21:40:35 <Korollary> True
21:40:55 <Korollary> also there are a lot of solitary good comments
21:41:31 <LoganCapaldo> Meanwhile "Translation from DHH-speak to English" has 103 comments
21:41:42 <LoganCapaldo> fascinating trend :)
21:41:46 <Korollary> people have opinions
21:42:06 <LoganCapaldo> But never about the things I'm interested in hearing people's opinions on :)
21:42:16 <LoganCapaldo> ah well
21:42:27 <LoganCapaldo> I guess the internet does not exist to serve my will
21:42:54 <Korollary> The modding system sucks
21:51:37 <plediii> @pl \f l -> foldr (\x y -> f (y,x)) 0 l
21:51:37 <lambdabot> flip foldr 0 . (. flip (,)) . (.)
21:52:51 <plediii> hmm, I wonder why lambdabot doesn't use curry there.
21:55:14 * allbery_b makes a note to find the bug foo and report the gconfSet behavcior officially
21:55:27 <allbery_b> ...including testing with more than just Int, just to be complete
22:05:57 <dolio> @pl \f x y -> f (x,y)
22:05:57 <lambdabot> (. (,)) . (.)
22:06:18 <int-e> @type uncurry
22:06:21 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
22:06:39 <int-e> ok, curry then
22:06:57 <LoganCapaldo>  > let notAsSpicy = uncurry in notAsSpicy (+) (1, 2)
22:07:15 <dolio> @pl \f (x,y) -> f x y
22:07:16 <lambdabot> (`ap` snd) . (. fst)
22:07:19 * sorear invents an incremental checkpointing system for megamonad-bot
22:07:27 <sorear> @pl let fix = 2 in fix
22:07:27 <lambdabot> 2
22:07:40 <sorear> @pl \fix -> let a = 2 in a
22:07:41 <lambdabot> ($ const 2)
22:10:46 * LoganCapaldo is confused
22:11:01 <LoganCapaldo> isn't $ const 2 just const $ 2 which is just const 2 ?
22:11:07 <sorear> no.
22:11:11 <LoganCapaldo> oh der
22:11:14 <LoganCapaldo> its  asection
22:11:21 <sorear> ($ const 2) = \x -> x (const 2) /= const 2
22:11:27 <monochrom> It's ($ (const 2))
22:11:40 <sorear> :t ($ const 2)
22:11:43 <lambdabot> forall b t b1. (Num t) => ((b1 -> t) -> b) -> b
22:11:44 * LoganCapaldo read it as (($) const 2) obviously
22:11:56 <sorear> :t \fix -> let a = 2 in a
22:11:57 <monochrom> Yeah, slippery
22:11:59 <lambdabot> forall t t1. (Num t1) => t -> t1
22:12:08 <sorear> this is a BUG in @pl
22:12:22 <sorear> the renamer fails to catch fix
22:12:31 <sorear> it catches all other names just fine
22:12:58 <LoganCapaldo> and I go to sleep to dream of lambdas
22:13:15 <sorear> hah.  I wish I had dreamy lambdas :(
22:21:43 <sciolizer> Where can I find a DrIFT rule for creating Data instances?
22:22:35 <sciolizer> (Of course, I'd be interested in knowing of ways to automatically create Data instances WITHOUT using DrIFT as well.)
22:23:39 <sjanssen> sciolizer: GHC can derive Data
22:24:42 <sciolizer> Command line option, compiler directive?
22:25:10 <sciolizer> Or can I just do "instance Data MyData" and leave off the where clause?
22:25:31 <sciolizer> er....
22:25:43 <sciolizer> sjanssen: yes, but if I'm using a library which I'd prefer not to modify
22:25:43 <sjanssen> data MyDataType = ... deriving Data
22:26:00 <sciolizer> I'm not the one declaring the data type.
22:30:46 <sciolizer> Well, I do have access to the source code, so I guess I'll just s/deriving \((.*)\)/deriving (\1,Typeable,Data)/g
22:31:49 <sciolizer> Wasn't somebody working on a template haskell solution to deriving Typeable and Data instances of external modules from which the constructors were importable?
22:32:12 <sciolizer> s/external modules/data types in external modules/
22:33:22 <sjanssen> @where derive
22:33:23 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/derive
22:33:31 <sjanssen> sciolizer: maybe that can do it?
22:33:59 <sciolizer> sjanssen: That does look helpful. Thanks.
23:23:50 <dcoutts> Igloo: you about?
23:25:19 <dcoutts> Igloo: I'm going to darcs tag packages/filepath as 1.0 and upload a tarball to hackage, is that ok by you? is there anything else left to do before I do that?
23:26:53 <int-e> dcoutts: ndm wanted to fix a bug with relative paths, has he done that?
23:27:16 <dcoutts> int-e: oh yes, so he did, well I'll wait then and see what ndm wants me to do
23:27:20 <int-e> dcoutts: #1278 to be precise.
23:27:34 <dcoutts> @seen ndm
23:27:35 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 6h 12m 55s ago, and .
23:28:16 <dcoutts> @tell ndm do you want me to darcs tag filpath as 1.0 and upload a tarball to hackage or do you want me to wait for whatever fixes you might be considering
23:28:17 <lambdabot> Consider it noted.
23:33:43 <LeCamarade> In Haskell, How do you do the equivalent if popen, the function? (I wanted to call it an action :oD)
23:33:57 <dons> System.Process
23:34:05 <dons> ?docs System.Process
23:34:05 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Process.html
23:34:30 <LeCamarade> I was thinking of System.Posix.IO, and I found that createPipe is a beast.
23:34:55 <LeCamarade> dons: Sorry, but do you ever leave this place? I mean, like sleep?
23:35:22 <dons> sure. i'm about to head off now.
23:36:14 <LeCamarade> runInteractiveProcess. Okay. Bon. You may go, now. But wait ...
23:36:36 <LeCamarade> I read your papers. UNSW seems to have colonised Haskell well. Even more than Glasgow.
23:36:51 <dons> hehe. glasgow broke up about 10 years ago, iirc.
23:38:51 <LeCamarade> Glasgow gone? Oh, well, couldn't have known. Okay, don't you honestly believe that, while Haskell is elegant, it simply abstracts away too much of the real world that is necessary to get the job done? I mean, each of your papers seems to.
23:39:04 <LeCamarade> Lots of impurity, for example.
23:39:44 <dons> not really. it provides both abstraction and concrete, low level stuff
23:39:52 <dons> that's why you can write kernels in it.
23:40:00 <dons> and having the abstraction means you can do other things besides
23:40:32 <dons> what did you mean by impurity?
23:40:50 <drigz> excuse the uninformed question, but wouldn't writing a kernel in haskell have 'unsafe' and #s everywhere?
23:41:00 <LeCamarade> IO is too important to be an appendage. You do FFI ... kernels? Like L4 (or something)? Well, yeah, but not before MVars eat you up. Should basic IO be so painful? No. By impurity I meant ... having lots of ...
23:41:15 <dons> nah, you just use a hardware monad to abstract over memory and registers and the filesystem
23:41:27 <dons> then hack away. the bonus is you end up with code you can actually prove things about.
23:41:35 <LeCamarade> ... places where unsafePerformIO is seductive.
23:41:39 <fuzan> dons: did you and that archlinux user figure out what the issue was with hs-plugin's configure?
23:41:57 <dons> LeCamarade: I'm not sure I'd consider IO an appendage. some programs use it a lot, some don't.
23:41:57 <fuzan> dons: I tried hacking out some of the configure checks today, only to break itmore.
23:42:13 <dons> bogus ghci call
23:42:21 <dons> if you just use `pwd` things probably work. (but i think that breaks win32)
23:42:39 <dons> LeCamarade: just because Haskell lets you control IO, doesn't mean you can't do IO :-)
23:42:58 <LeCamarade> Directory.getCurrentDirectory - why not this? Or "."?
23:43:50 <LeCamarade> dons: Maybe I'm yet to heal from years of the Wrong Way, but I kind of miss quick IO, sometimes.
23:43:58 <fuzan> dons: ghci is called in the configure process?
23:44:02 <dons> what's hard about IO? 'print' is easy.
23:44:35 <LeCamarade> dons: Im doing an _easily_-extensible shell, and I just don't think the Yi way can work for me.
23:44:59 <dons> the Yi way? what's that?
23:45:06 <dons> you want dyn code loading?
23:45:13 <dons> (i'd use ghc-api for this)
23:45:47 <LeCamarade> dons: Yeah, print is easy. But when you end up wanting to filter a list of directories ... yes, dynaload. No, ghc-api is the hard way. I want it to be extensible with things like Perl.
23:46:07 <dons> what's that got to do with IO?
23:46:08 <LeCamarade> Sorry for blaspheming with that language's name, but yeah. It's a horrible prototype.
23:46:16 <LeCamarade> Lemme hpaste what I've done thus far.
23:46:24 <dons> nah, i'm heading off. happy hacking!
23:46:26 * dons disappears
23:46:34 <LeCamarade> dons: Sure.
23:46:50 <LeCamarade> @time dons
23:46:52 <lambdabot> Local time for dons is Tue Apr 17 16:45:48 2007
23:50:14 <astrolabe> hmmm. maybe not a poem http://www.luminarium.org/sevenlit/donne/meditation17.php
23:50:15 <lambdabot> Title: John Donne. Meditation 17. [No man is an island... For whom the bell tolls, etc. ...
23:51:14 <astrolabe> (This is not an example of modern english)
23:52:00 * fuzan shakes his skinny fist menacingly at hs-plugins.
23:52:57 <fuzan> oh, ghc --interactive is called.
23:54:56 <astrolabe> Sorry! wrong channel!
23:56:00 <LeCamarade> @slap astrolabe
23:56:01 <lambdabot> why on earth would I slap astrolabe
23:56:19 <LeCamarade> lambdabot: 'Cause he mixed channels!
23:56:28 <LeCamarade> @quote slap
23:56:29 <lambdabot> lambdabot says: why on the earth whould I slap dons with a wet trout
23:56:47 <LeCamarade> @slap lambdabot
23:56:48 * lambdabot slaps lambdabot
23:57:38 * LeCamarade guffaws and cackles. Hehehehe. Wery, wery ewil.
