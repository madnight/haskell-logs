00:00:15 <LeCamarade> 3. If you feel the urge to use a continual-passing style, use a fold.
00:00:43 <LeCamarade> As in, the fold will take care of the CPS, and you'll end up with clearer code.
00:01:28 <LeCamarade> mrchebas_: You want something like split, right?
00:01:49 <mrchebas_> @type split
00:01:52 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
00:02:09 <mrchebas_> @type List.split
00:02:11 <lambdabot> Not in scope: `List.split'
00:02:18 <mrchebas_> @type Data.List.split
00:02:20 <lambdabot> Not in scope: `Data.List.split'
00:02:28 <ClaudiusMaximus> @hoogle split
00:02:28 <LeCamarade> No, I mean the ... Perl-like split, but higher-order.
00:02:29 <lambdabot> Random.split :: RandomGen a => a -> (a, a)
00:02:29 <lambdabot> Data.IntMap.split :: Key -> IntMap a -> (IntMap a, IntMap a)
00:02:29 <lambdabot> Data.IntSet.split :: Int -> IntSet -> (IntSet, IntSet)
00:02:45 <ClaudiusMaximus> @hoogle splitAt
00:02:46 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
00:02:47 <lambdabot> Data.PackedString.splitAtPS :: Int -> PackedString -> (PackedString, PackedString)
00:02:47 <lambdabot> List.genericSplitAt :: Integral a => a -> [b] -> ([b], [b])
00:03:15 <mrchebas_> could be used, but not exactly what i am looking for
00:03:34 <LeCamarade> split (\c -> True) "Hello" => ['H', 'e', 'l', 'l', 'o']
00:03:38 <LeCamarade> Right?
00:04:27 <mrchebas_> split (=='e') "Hello" => ["H","ello"]
00:06:42 <ClaudiusMaximus> > splitWhen p xs = (takeWhile (not . p) xs) : (splitWhen p (dropWhile (not . p) xs)) in splitWhen (=='e') "Hello!"
00:06:43 <lambdabot>  Parse error
00:07:17 <LeCamarade> > let splt f x = [dropWhile f x] in splt (== 'e') "Hello"
00:07:19 <lambdabot>  ["Hello"]
00:07:32 <LeCamarade> Not quite, of course ...
00:07:40 <LeCamarade> > let splt f x = [dropUnti f x] in splt (== 'e') "Hello"
00:07:41 <lambdabot>   Not in scope: `dropUnti'
00:07:44 <LeCamarade> > let splt f x = [dropUntil f x] in splt (== 'e') "Hello"
00:07:45 <lambdabot>   Not in scope: `dropUntil'
00:10:19 <ClaudiusMaximus> > splitWhen p xs = (takeWhile (not . p) xs) : (splitWhen p (dropWhile (not . p) xs)) in splitWhen (== 'e') "Hello!"
00:10:20 <lambdabot>  Parse error
00:10:43 <TSC> You missed a let
00:10:50 <ClaudiusMaximus> d'oh
00:10:57 <ClaudiusMaximus> > let splitWhen p xs = (takeWhile (not . p) xs) : (splitWhen p (dropWhile (not . p) xs)) in splitWhen (== 'e') "Hello!"
00:10:58 <lambdabot>  ["H","","","","","","","","","","","","","","","","","","","","","","","",""...
00:11:29 <igli> split a x:list - a==h(x) => x else split a t(x) # pseudo code sorry noob where h=head, t=tail
00:16:22 <mrchebas_> > let split p = filter (p .head) . init . tails in split (=='e') "Helloed"
00:16:24 <lambdabot>  ["elloed","ed"]
00:17:08 <LeCamarade> mrchebas_: That's what you wanted?
00:17:52 <dolio> Hmm... Use a fold instead of CPS...
00:18:09 <mrchebas_> LeCamarade: yes :)
00:21:45 <int-e> > let splitWhen f xs = map (dropWhile f) $ groupBy (\x -> not . f) $ xs in splitWhen (=='e') "Hello, cruel world."
00:21:46 <lambdabot>  ["H","llo, cru","l world."]
00:22:51 <dolio> @src groupBy
00:22:51 <lambdabot> groupBy _  []       =  []
00:22:52 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
00:22:52 <lambdabot>     where (ys,zs) = span (eq x) xs
00:24:45 <LeCamarade> @where groupBy
00:24:45 <eumenides> @src fmap
00:24:45 <lambdabot> I know nothing about groupby.
00:24:45 <lambdabot> Source not found. That's something I cannot allow to happen.
00:26:23 <dolio> @src Either fmap
00:26:24 <lambdabot> fmap _ (Left x) = Left x
00:26:24 <lambdabot> fmap f (Right y) = Right (f y)
00:50:14 <dcoutts> So, who wants a Haskell job at Credit Suisse in NY?
00:51:04 <sieni> a bit too far
00:51:08 <sieni> how about helsinki? :-)
00:51:10 <LeCamarade> Why would they want a Haskeller there? It's suddenly in vogue?
00:51:14 <dcoutts> heh :-
00:51:38 <dcoutts> LeCamarade: to solve hard problems quickly where there's lots of money riding on the outcome
00:51:46 <dcoutts> it makes perfect sense
00:52:04 <DRMacIver> hm. That's the second time I've heard of Credit Suisse using Haskell. :)
00:52:17 <LeCamarade> It's sad, but jobs like that will go to the Java people, because ... look at the people doing Haskell. Australian profs.
00:52:36 <dcoutts> DRMacIver: s'because it's true they do
00:52:43 <DRMacIver> Well, yes.
00:52:54 <DRMacIver> I'm just saying, now I know that it's not just a one off thing. :)
00:52:59 <LeCamarade> DRMacIver: They may still be talking of the same opening as long ago.
00:53:04 <DRMacIver> No.
00:53:06 <dcoutts> LeCamarade: only if the Java people know Haskell or another statically typed functional language, it says so in the job spec.
00:53:21 <dcoutts> LeCamarade: this one was announced today.
00:53:37 <DRMacIver> (Because the same opening as long ago is filled)
00:53:56 <dcoutts> by the chap who just announced the new position in fact :-)
00:54:05 <DRMacIver> Oh?
00:54:22 <DRMacIver> Maybe they use it quite extensively. I'm intrigued.
00:54:23 <dcoutts> Heffalump's boss
00:54:29 <LeCamarade> If I were the hiring tribe, I'd sure want to hire Haskellers, but that would require kidnapping them from their prof jobs. Sometimes I feel I'm the only one of my kind in here.
00:55:34 <DRMacIver> I'd be totally up for a Haskell job. :) Although I probably don't have enough experience in it to warrant hiring me for one.
00:55:39 * LeCamarade is proud to be the hirable kind, but sad that it means he has to kick Java in the other terminal. Very angry.
00:55:41 <sjanssen> working with augustss and Heffalump has got to be fun
00:55:51 <dcoutts> I agree
00:56:20 * sjanssen is suspicious of the subject line "{-# INLINE me_harder #-}"
00:56:21 <LeCamarade> dcoutts: What do you say about my `gems´ posted up there?
00:56:23 <dcoutts> pitty I don't find financial stuff all that fascinating
00:56:34 <DRMacIver> I'm unfortunately one of those Java programmers. :)
00:56:36 <dcoutts> LeCamarade: about prof jobs etc?
00:56:58 <LeCamarade> dcoutts: No. The Haskell gems. Lemme check them out of bitchx history ...
00:57:21 <LeCamarade> 1. For every time you use the IO monad outside main, your quality score goes down by 50%.
00:57:28 <DRMacIver> dcoutts: Some of it is quite neat. That being said, although my standard position is "The job matters more than the technology", I'd probably put that aside for a chance to get really good at Haskell.
00:57:53 <DRMacIver> At the moment I'm held back by the fact that I don't have a lot of motivation to use it for anything serious.
00:58:27 <DRMacIver> It's pretty much "welll... I could do this in Haskell. But it would make all the bits I already know are easy to do in Java really difficult, while only making an admittedly interesting core subset easier."
00:59:00 <DRMacIver> So it's great for playing with and learning about, but I never end up doing anything serious.
00:59:12 <DRMacIver> (This is a problem with me more than it is with Haskell)
00:59:26 <LeCamarade> DRMacIver: Just keep kicking a toy a day. Like re-writing these Unix tools (at the end, you've probably tacled the awkward squad): cat, ls, banner, minimal sed, et cetera.
00:59:50 <dcoutts> LeCamarade: Cabal would score 0% on that measure then :-)
00:59:53 <DRMacIver> Yeah, I really should do that. At the moment I'm not even doing that. :)
01:00:22 <dcoutts> LeCamarade: I partly disagree, if you can hide the use of IO behind a purely functional API then I think you don't loose any marks.
01:00:30 <DRMacIver> Currently I'm scoring a simple parser and some playing with the probability monad. It's a bit embarassingly bad.
01:00:47 <LeCamarade> dcoutts: Zero is impossible, since we are always halving ... :oD But this is for n00bs, who really won't need the monad everywhere. And 10% isn't bad ...
01:01:43 <dcoutts> LeCamarade: ok, underflow to 0% when using a floating point representation :-)
01:01:54 <LeCamarade> dcoutts: The typical n00b strategy is to keep passing actions and performing them in all sorts of places. That´s evil and more-procedural thinkng. It should be discouraged.
01:02:03 <dcoutts> yes, I agree.
01:02:08 <LeCamarade> dcoutts: :oD
01:02:12 <LeCamarade> Number 2 ...
01:02:22 <LeCamarade> 2. Dont work with data that isn't yet generated. A function for each part. One to collect the data, another to process it.
01:03:02 <dcoutts> not sure I understand what you mean in the first sentence
01:04:25 <LeCamarade> Like ... there is a test in YAHT that tells one to get a series of numbers from the user and return details about them. The n00b will iterate about, getting the data and processing it, talking about it, then he/she tail-recurses.
01:05:06 <LeCamarade> The right way is for them to have a func that does each of those things separately, and then they can map and do whatever catches their fancy.
01:05:21 <LeCamarade> One nearer to the n00b experience would understand better. :oD
01:05:33 <mux> morning haskellers
01:05:40 <dcoutts> hia mux
01:06:31 <dcoutts> LeCamarade: I probably agree, though I don't see exactly the example you're getting at
01:06:38 <LeCamarade> mux: Hi!
01:06:42 <LeCamarade> 3. If you feel the urge to use a continual-passing style, use a fold.
01:07:09 <dcoutts> hmm, but what about my CPS monad ? :-)
01:07:13 <LeCamarade> Sad the YAHT talks of CPS as a nice thing, so it encourages n00bs to use CPS. CPS is usually bad, since the initial default is a constant, which is good for folding.
01:07:32 <dcoutts> I usually avoid CPS too though
01:07:39 <LeCamarade> dcoutts: Um ... you no be no n00b. :oD
01:07:48 <dcoutts> except for binary serialisation where it's great :-)
01:07:56 <matthew-_> data flow becomes very very hard to see with heavy use of CPS.
01:08:24 <mux> the breakpoint support in GHCi HEAD is really sexy
01:08:32 <dcoutts> mux: isn't it :-)
01:08:43 <dcoutts> I was talking to Bernie Pope about it a few weeks ago
01:09:39 <mux> it's nice to see support for debugging haskell programs improving, since it's one of the points where the language has some weaknesses (well, not the language itself, but you see m point)
01:10:05 <Syzygy-> Does GHC do MPI?
01:11:58 <quicksil1er> well CPS is like most such idioms
01:12:03 <quicksil1er> it's unclear if you're unused to it
01:12:03 <dcoutts> Syzygy-: there's an MPI binding and there are research projects for distributed stuff based on slightly older versions of GHC
01:12:08 <quicksil1er> and perfectly clear if you are :P
01:13:52 <LeCamarade> Someone was calling Haskell a bondage-and-discipline language. Well, I not for a language that doesn't tell me that I am doing something the wrong, despite how correct I think I am. Viva Haskell!
01:14:32 * LeCamarade goes off to the dreaded terminal 2 - the one with J**a code.
01:15:34 <dolio> @karma Java
01:15:34 <lambdabot> Java has a karma of -2
01:15:47 <LeCamarade> @karma- Java
01:15:48 <lambdabot> Java's karma lowered to -3.
01:15:55 <LeCamarade> @karma- Java
01:15:56 <lambdabot> Java's karma lowered to -4.
01:15:58 <LeCamarade> @karma- Java
01:15:58 <LeCamarade> @karma- Java
01:15:58 <LeCamarade> @karma- Java
01:15:58 <LeCamarade> @karma- Java
01:15:58 <lambdabot> Java's karma lowered to -5.
01:15:59 <lambdabot> Java's karma lowered to -6.
01:15:59 <lambdabot> Java's karma lowered to -7.
01:15:59 <lambdabot> Java's karma lowered to -8.
01:16:27 <LeCamarade> @slap -f Java
01:16:27 * lambdabot beats up -f Java
01:16:28 <campusblo> hi folks
01:16:29 <Syzygy-> LeCamarade: Cut it out, would ya?
01:16:40 <LeCamarade> @shoot Java
01:16:41 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
01:16:43 <campusblo> trying to get words from a string
01:17:03 <campusblo> hWords:: [Char] -> [[Char]]
01:17:03 <campusblo> hWords [] = [[' ']]
01:17:03 <campusblo> hWords (x:xs)
01:17:03 <campusblo>        | (elem x whitespace /= True) = cons ([x]++ hWords (xs))
01:17:03 <campusblo>        | (elem x whitespace == True) = [' '] :  hWords (xs)
01:17:04 <campusblo>          cons :: [Char] -> [[Char]]
01:17:06 <campusblo>          cons [] = []
01:17:08 <campusblo>          cons x = [x]
01:17:09 <campusblo>          whitespace = ['\n','\t',' ']
01:17:24 <LeCamarade> campusblo: Please use hpaste.
01:17:28 <LeCamarade> @paste
01:17:29 <lambdabot> Haskell pastebin: http://hpaste.org/new
01:17:36 <Syzygy-> dcoutts: Is the MPI binding halfway official? Is it being maintained? Where do I find it?
01:17:38 <campusblo> @paste
01:17:38 <lambdabot> Haskell pastebin: http://hpaste.org/new
01:17:42 <LeCamarade> Go there and paste the code, please.
01:18:14 <dcoutts> Syzygy-: it's not especially 'official', you'd have to google for it
01:18:26 <LeCamarade> campusblo: Use words.
01:18:29 <dmwit_> campusblo: I think you should get some type errors on that code.
01:18:31 <LeCamarade> @src words
01:18:32 <lambdabot> words s = case dropWhile isSpace s of
01:18:32 <lambdabot>     "" -> []
01:18:32 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
01:18:42 <dcoutts> @where hmpi
01:18:42 <lambdabot> I know nothing about hmpi.
01:18:49 <dcoutts> @where+ hmpi http://foldr.org/~michaelw/hmpi/
01:18:49 <lambdabot> Done.
01:18:52 <dcoutts> Syzygy-: ^^
01:18:59 <hpaste>  campusblo pasted "error on cons" at http://hpaste.org/1439
01:19:10 <Syzygy-> o.O I find hMPI which ceased development in 2001. And MPI-Port of GUM, based on GHC 3.02.
01:19:19 <campusblo> ok so i pasted it .
01:19:28 <campusblo> im trying to extract words from a string
01:19:41 <LeCamarade> campusblo: There is a function for that, I think.
01:19:51 <Syzygy-> dcoutts: And I see you asking about MPI for GHC 5.x
01:19:52 <Syzygy-> :)
01:19:52 <campusblo> yes but i have to write one
01:19:56 <dmwit_> LeCamarade: It's probably for an exercise, where he doesn't get to use that.
01:20:00 <LeCamarade> > words "I dreaming of a green christmas"
01:20:02 <lambdabot>  ["I","dreaming","of","a","green","christmas"]
01:20:11 <campusblo> i need to get the spaces too
01:20:14 <dcoutts> Syzygy-: am I?
01:20:16 <campusblo> as ""
01:20:18 <vali> hello
01:20:24 <campusblo> " "
01:20:25 <Syzygy-> http://osdir.com/ml/lang.haskell.glasgow.user/2001-08/msg00083.html
01:20:26 <Syzygy-> In 2001.
01:20:28 <dmwit_> campusblo: What should hWords "hi there" give?
01:20:28 <lambdabot> Title: MPI status?, http://tinyurl.com/2but7t
01:21:05 <campusblo> ["hi"," ", "there"]
01:21:28 <dmwit_> campusblo: Do you get to use things like span and break?
01:21:30 <dmwit_> :t span
01:21:33 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
01:21:47 <dcoutts> Syzygy-: oh heh :-) I'd forgotten that
01:21:59 <campusblo> dont know about span and break
01:22:00 <LeCamarade> > foldlr (\x y -> y ++ [" "]) [] $ words "I dreaming of a green christmas"
01:22:01 <lambdabot>   Not in scope: `foldlr'
01:22:12 <LeCamarade> > foldr (\x y -> y ++ [" "]) [] $ words "I dreaming of a green christmas"
01:22:13 <lambdabot>  [" "," "," "," "," "," "]
01:22:16 <campusblo> its important that i ge the spaces though
01:22:21 <campusblo> the
01:22:30 <vali> fibGen :: (Num a, Num b) => b -> b -> a -> b ... i don't understand this. the function returns b and takes b, b and a as parameters(?) and the function is an instance of the class Num?
01:22:37 <dmwit_> > span isWhiteSpace "   hi there" where isWhiteSpace x = x `elem` ['\n','\t',' ']
01:22:38 <lambdabot>  Parse error
01:22:49 <LeCamarade> > foldr (\x y -> y ++ [x, " "]) [] $ words "I dreaming of a green christmas"
01:22:50 <lambdabot>  ["christmas"," ","green"," ","a"," ","of"," ","dreaming"," ","I"," "]
01:22:55 <dmwit_> > let isWhiteSpace x = x `elem` ['\n','\t',' '] in span isWhiteSpace "   hi there"
01:22:57 <lambdabot>  ("   ","hi there")
01:23:01 <LeCamarade> > init $ foldr (\x y -> y ++ [x, " "]) [] $ words "I dreaming of a green christmas"
01:23:02 <lambdabot>  ["christmas"," ","green"," ","a"," ","of"," ","dreaming"," ","I"]
01:23:09 <dmwit_> LeCamarade: intersperse
01:23:20 <dmwit_> > intersperse " " $ words "hi there, chum"
01:23:21 <lambdabot>  ["hi"," ","there,"," ","chum"]
01:23:34 <campusblo> dmwit thats what i need
01:23:37 <dmwit_> LeCamarade: But that doesn't work quite right if there are two whitespace characters in a row.
01:23:44 <quicksil1er> > intersperse 1 [1,2,3,4,5]
01:23:46 <lambdabot>  [1,1,2,1,3,1,4,1,5]
01:23:46 <dmwit_> campusblo: ^^
01:24:01 <campusblo> but suppose there are two spaces?
01:24:10 <dmwit_> campusblo: Exactly, it doesn't work in that case.
01:24:10 <LeCamarade> Yeah. intersperse. But 'tis not in Prelude ... :oD
01:24:14 <Syzygy-> :t group
01:24:17 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
01:24:18 <dmwit_> ?index intersperse
01:24:19 <lambdabot> Data.List
01:24:22 <campusblo> but thats the result i need
01:24:28 <Syzygy-> > group [1,1,2,1]
01:24:30 <lambdabot>  [[1,1],[2],[1]]
01:24:37 <Syzygy-> > group [1,1,1,2]
01:24:38 <lambdabot>  [[1,1,1],[2]]
01:24:39 <dmwit_> :t groupBy
01:24:42 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
01:24:50 <dmwit_> ?hoogle white
01:24:51 <lambdabot> Text.Html.white :: String
01:24:51 <lambdabot> Text.ParserCombinators.Parsec.Token.whiteSpace :: TokenParser st -> CharParser st ()
01:24:58 <Syzygy-> :t (+++)
01:25:01 <dmwit_> > isWhiteSpace ' '
01:25:01 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
01:25:02 <lambdabot>   Not in scope: `isWhiteSpace'
01:25:07 <dmwit_> > isSpace ' '
01:25:09 <lambdabot>  True
01:25:34 <dmwit_> > groupBy (\x y -> isSpace x == isSpace y) "hi there,   chum!"
01:25:35 <lambdabot>  ["hi"," ","there,","   ","chum!"]
01:25:39 <Syzygy-> Hmmmm. How do I do something like  > (length,head) [1,1,1]
01:25:50 <Syzygy-> I'm pretty certain one of the Arrow operations was responsible for that.
01:25:51 <dmwit_> > length &&& head $ [1, 1, 1]
01:25:53 <lambdabot>  (3,1)
01:25:56 <Syzygy-> Thanks.
01:26:01 <campusblo> check out my code. i think its almost correct
01:26:14 <campusblo> http://hpaste.org/1439
01:26:16 <Syzygy-> Now for the evil bit - what if I want [3,1] as the answer?
01:26:30 <dmwit_> Syzygy-: You don't. ;-)
01:26:32 <campusblo> but i get an error about unexpected '="
01:26:38 <campusblo> what does that mean?
01:26:40 <Syzygy-> dmwit_: Yes I do. Trust me, I do.
01:27:03 <Syzygy-> (And I most consciously called it evil)
01:27:05 <dmwit_> > \(a, b) -> [a, b] $ (3, 4)
01:27:06 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
01:27:13 <dmwit_> > (\(a, b) -> [a, b]) (3, 4)
01:27:14 <lambdabot>  [3,4]
01:27:55 <dmwit_> campusblo: Missing a "where".
01:28:03 <campusblo> sorry the error is unexpected '='
01:28:09 <campusblo> where for what? cons?
01:28:10 <quicksil1er> > uncurry (:) . second (:[]) $ (3,4)
01:28:11 <lambdabot>  [3,4]
01:28:13 <Syzygy-> :t (\xs -> ([length xs, head xs]++))
01:28:15 <lambdabot> [Int] -> [Int] -> [Int]
01:28:22 <Syzygy-> quicksil1er: Neat
01:28:30 <Syzygy-> :t foldr
01:28:33 <quicksil1er> > uncurry (:) . second (:[]) . length &&& head $ [1,1,1]
01:28:33 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
01:28:34 <lambdabot>  Couldn't match expected type `(d, b)' against inferred type `Int'
01:28:43 <LeCamarade> campusblo: where after ... okay, lemme annotate it ...
01:28:46 <quicksil1er> > uncurry (:) . second (:[]) . (length &&& head) $ [1,1,1]
01:28:47 <lambdabot>  [3,1]
01:29:12 <dmwit_> campusblo: But you'll get lots of type errors, even if you fix the where...
01:29:16 <igli> woah groupBy looked nice. forgot the [] case in split.
01:29:21 <dmwit_> Why are you using cons?
01:29:25 <LeCamarade> No need. Just put a where on the line with the last guard. At the end.
01:29:32 <Syzygy-> > foldr (\xs -> ([length xs, head xs]++)) [] (group [1])
01:29:33 <lambdabot>  [1,1]
01:29:37 <Syzygy-> > foldr (\xs -> ([length xs, head xs]++)) [] (group [1,1])
01:29:38 <lambdabot>  [2,1]
01:29:41 <Syzygy-> > foldr (\xs -> ([length xs, head xs]++)) [] (group [2,1])
01:29:43 <lambdabot>  [1,2,1,1]
01:29:45 <Syzygy-> Hah!
01:29:47 <LeCamarade> And you are cloning a cons Haskell already has.
01:29:48 <Syzygy-> Look-say sequence!
01:29:53 <LeCamarade> @src (:)
01:29:53 <lambdabot> Source not found. Where did you learn to type?
01:30:01 <campusblo> ok that one i can use
01:30:01 <Syzygy-> :t iterate
01:30:04 <vali> fibGen :: (Num a, Num b) => b -> b -> a -> b ... i don't understand this. the function returns b and takes b, b and a as parameters(?) and the function is an instance of the class Num?
01:30:04 <lambdabot> forall a. (a -> a) -> a -> [a]
01:30:10 <LeCamarade> @src :
01:30:11 <lambdabot> Source not found. Wrong!  You cheating scum!
01:30:32 <Syzygy-> :t foldr (\xs -> ([length xs, head xs]++)) [] . group
01:30:35 <lambdabot> [Int] -> [Int]
01:30:40 <quicksil1er> vali: no, 'a' and 'b' are instances of Num
01:30:45 <dmwit_> Syzygy-: Wow... =(
01:30:49 <Syzygy-> >let looksay = foldr (\xs -> ([length xs, head xs]++)) [] . group in iterate looksay [1]
01:30:50 <LeCamarade> let cons x = [x] in cons 3 == 3:[]
01:30:50 <dmwit_> Pretty good.
01:31:06 <Syzygy-> dmwit_: See? I did say I did want that.
01:31:27 <vali> quicksil1er: aah. but in the parameter list, why does it say "b" two times? shouldn't it say "a b c"?
01:31:39 <campusblo> im using cons to get everything in a list
01:31:46 <Syzygy-> But I don't know why it won't finish...
01:31:49 <quicksil1er> vali: because those two are required to be the same type
01:31:50 <Syzygy-> > let looksay = foldr (\xs -> ([length xs, head xs]++)) [] . group in iterate looksay [1]
01:31:51 <lambdabot>  [[1],[1,1],[2,1],[1,2,1,1],[1,1,1,2,2,1],[3,1,2,2,1,1],[1,3,1,1,2,2,2,1],[1,...
01:31:55 <Syzygy-> Ah. There we are.
01:32:00 <vali> quicksil1er: aah, thank you
01:32:23 <dmwit_> campusblo: You might be surprised at how many entities in your code are already in a list... =P
01:33:00 <campusblo> so youre saying take out cons?
01:33:29 <LeCamarade> campusblo: Not just cons. Many things. Let me annotate with comments and tell you. You waiting?
01:33:39 <campusblo> yes
01:35:15 <dmwit_> campusblo: You're reinventing a lot of things; are you sure you have to reinvent all of them?
01:35:28 <dmwit_> ?index isSpace
01:35:29 <lambdabot> Data.Char
01:36:35 <campusblo> i think i can use isSpace
01:36:40 <LeCamarade> dmwit_: I am going to name them all one-by-one for campusblo.
01:36:47 * mux longs for associated type synonyms
01:37:10 <campusblo> but in any case im using a file called characters.hs which has all of the characters listed. so i just import them from that file
01:37:50 <campusblo> all suggestions are welcomed
01:38:09 <dmwit_> campusblo: p == True is equivalent to p
01:39:25 <campusblo> so i can leave out the == right?
01:39:26 <mux> @karma- NetSNMP::agent
01:39:26 <lambdabot> NetSNMP::agent's karma lowered to -1.
01:39:37 <dmwit_> campusblo: right
01:39:40 <fuzan> Syzygy-: that was one of the first patterns I implemented in Haskell. that solution is far more condense than mine :)
01:40:03 <Syzygy-> fuzan: Hehe
01:40:13 * Syzygy- sees a game of looksay golf coming up... :P
01:40:33 <Syzygy-> @pl \xs -> ([length xs, head xs]++)
01:40:33 <lambdabot> (++) . liftM2 (:) length (return . head)
01:40:43 * fuzan begins scheming.
01:40:45 <Syzygy-> So pointless isn't the way to go. Right. :P
01:40:45 <campusblo> actually when it comes to that my idea was to implement code that is foolproof and then strip it away afer
01:41:00 <campusblo> but yeh its redundant
01:41:02 <LeCamarade> campusblo: I bringing all that.
01:41:13 <LeCamarade> campusblo: If youl wait.
01:41:25 <campusblo> im waiting
01:42:32 <dmwit_> > let question = "What is the next letter in the sequence " in question ++ (intersperse ',' . map (toUpper . head) . (!! 1) . tails $ words question) ++ "?"
01:42:34 <lambdabot>  "What is the next letter in the sequence I,T,N,L,I,T,S?"
01:42:43 <dmwit_> > let question = "What is the next letter in the sequence " in question ++ (intersperse ',' . map (toUpper . head) . (!! 1) . inits $ words question) ++ "?"
01:42:45 <lambdabot>  "What is the next letter in the sequence W?"
01:42:49 <dmwit_> bah
01:44:13 <fuzan> Syzygy-: group makes looksay so neat.
01:46:51 <Syzygy-> fuzan: Oh yes. :P
01:47:40 <dmwit_> > let f xs = group xs >>= (\x -> [length x, head x]) in iterate f [1]
01:47:41 <lambdabot>  [[1],[1,1],[2,1],[1,2,1,1],[1,1,1,2,2,1],[3,1,2,2,1,1],[1,3,1,1,2,2,2,1],[1,...
01:48:41 <dmwit_> > let f xs = group xs >>= flip map [length, head] in iterate f [1]
01:48:42 <lambdabot>  Couldn't match expected type `[a]' against inferred type `a1 -> b'
01:49:14 <dmwit_> ?hoogle (b -> a, c -> a) -> (b, c) -> (a, a)
01:49:15 <lambdabot> No matches, try a more general search
01:49:21 <dmwit_> ?hoogle (b -> a, c -> a) -> (b, c) -> [a, a]
01:49:22 <lambdabot> No matches, try a more general search
01:49:51 <dmwit_> :t length
01:49:54 <lambdabot> forall a. [a] -> Int
01:49:56 <dmwit_> :t head
01:49:59 <lambdabot> forall a. [a] -> a
01:50:14 <quicksil1er> ?hoogle (a -> b, c -> d) -> (a,c) -> (b,d)
01:50:15 <lambdabot> No matches, try a more general search
01:50:19 <dmwit_> > [length, head] :: [Int] -> Int
01:50:19 <LeCamarade> campusblo: Also, you can't pull off your function without what is called comtinual passing. I am going to use it in the example, even though I don't encourage it.
01:50:20 <lambdabot>  Couldn't match expected type `[Int] -> Int'
01:51:52 <dmwit_> > let l, h :: [Int] -> Int; l = length; h = head in [l, h]
01:51:54 <lambdabot>  [<[Int] -> Int>,<[Int] -> Int>]
01:52:01 <dmwit_> magic!
01:52:19 <campusblo> ok
01:52:39 <campusblo> theres something on my paper here that talks about stacks
01:52:48 <campusblo> im not sure if they were suggesting it in that part though
01:52:55 <Syzygy-> > mapM [length, head] [2,3]
01:53:01 <campusblo> stacks and queues basically
01:53:09 <dmwit_> > let l, h :: [Int] -> Int; l = length; h = head in iterate (flip map [l, h] . (=<< group)) [1]
01:53:11 <lambdabot>  Couldn't match expected type `[Int] -> Int'
01:53:51 <Syzygy-> @hoogle [a -> b] -> [a] -> [b]
01:53:53 <lambdabot> No matches, try a more general search
01:54:04 <dmwit_> ?pl \xs -> flip map [l, h] =<< group xs
01:54:04 <lambdabot> (flip map [l, h] =<<) . group
01:54:16 <quicksil1er> > map ($[2,3]) [length,head]
01:54:18 <lambdabot>  [2,2]
01:54:25 <dmwit_> > let l, h :: [Int] -> Int; l = length; h = head in iterate ((flip map [l, h] =<<) . group) [1]
01:54:27 <lambdabot>  Couldn't match expected type `([Int] -> Int) -> b'
01:55:19 <dmwit_> :t ap
01:55:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
01:55:22 <plediii> Why is the type of func after func = map . (*), Integer -> [Integer] -> [Integer], when the type of map .(*) is (Num a) => a -> [a] -> [a]?
01:55:30 <dmwit_> Syzygy-: Like that?
01:55:43 <dmwit_> > ap [(+1), (*2)] [5, 10]
01:55:44 <lambdabot>  [6,11,10,20]
01:55:55 <plediii> why does naming map . (*) reduce the generality of its type?
01:56:18 <dolio> Because of the monomorphism restriction.
01:56:21 <dmwit_> plediii: Probably the monomorphism restriction...
01:56:28 <dmwit_> Syzygy-: Or like this:
01:56:29 <plediii> stereo :)
01:56:40 <dmwit_> > zipWith ($) [(+1), (*2)] [5, 10]
01:56:42 <lambdabot>  [6,20]
01:57:47 <quicksil1er> @quote stereo
01:57:48 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
01:57:53 <dmwit_> Okay, I'm having a little trouble reasoning about the interaction between laziness and monads.
01:57:55 <dmwit_> Here's the setup:
01:58:15 <dmwit_> I want to do a depth-first search.
01:58:41 <dmwit_> But at each node, I plan to reorder the list of choices by permuting a list in a State monad holding a StdGen.
01:59:12 <dmwit_> The plan is to use this to "create" the list of all possible solutions, but in a random order.
01:59:30 <dmwit_> If I take the head of this list, will it do what I want?
01:59:42 <dmwit_> i.e. will it follow enough paths to get the first solution, but nothing more?
01:59:56 <hpaste>  LeCamarade annotated "error on cons" with "(no title)" at http://hpaste.org/1439#a1
02:00:06 <quicksil1er> dmwit: that's not really a question about monads in general, it's a very specific question about the state monad
02:00:06 <LeCamarade> campusblo: I sent it in.
02:00:16 <LeCamarade> @seen campusblo
02:00:17 <lambdabot> campusblo is in #haskell. I last heard campusblo speak 7m 15s ago.
02:00:18 <campusblo> thanks ill check it out n ow
02:00:33 * osfameron tried to work through http://www.randomhacks.net/articles/2007/03/12/monads-in-15-minutes
02:00:36 <dmwit_> quicksil1er: Well... okay.
02:00:36 <lambdabot> Title: Monads in 15 minutes: Backtracking and Maybe, http://tinyurl.com/2xlyze
02:00:40 <osfameron> his 15 minutes are not my 15 minutes :-)
02:00:56 <osfameron> I did sort of get the code examples by the end of it, except for guard - which makes no sense whatsoever
02:01:29 <osfameron> it's kind of like a map or a grep clause, except that instead of returning the thing grepped, it returns [()], which somehow magically becomes that thing
02:01:43 <campusblo> le camarade im gonna read this and sort it out and come back in a sec. thanks a lot again
02:01:54 <LeCamarade> campusblo: Yep.
02:02:03 <LeCamarade> osfameron: What do you mean?
02:02:04 <dmwit_> osfameron: The key is that you later return x.
02:02:06 <osfameron> And I still don't understand why it's a monad, or why we needed to put Choice [] instead of just [] which seemed to work for a lot of the examples on its own
02:02:25 <osfameron> dmwit_: but return just returns [x] ?
02:02:26 <dmwit_> osfameron: Since it is inside a closure, that x either becomes [x] or [] depending on whether it got passed [()] or []...
02:02:33 <osfameron> so that would return [[()]], no?
02:02:57 * LeCamarade hopes dmwit_ will remove the trailing _ on his nick, as it implies he is not to be bothered ...
02:03:09 <campusblo> lecamarade main = putStrLn $ show $ hWords
02:03:23 <campusblo> whats that? IO?
02:03:23 <LeCamarade> campusblo: Yeah?
02:03:25 <dmwit_> osfameron: But remember! x is bound before we start using guard, so it isn't bound to () -- it's bound to a value!
02:03:30 <osfameron> dmwit_: oh.. because return of an empty list returns the empty list you mean?
02:03:39 <dmwit_> LeCamarade: You'll notice that there is also a dmwit here.  I'm logged on twice.
02:03:47 <LeCamarade> campusblo: No. Just see this:
02:03:52 <dmwit_> osfameron: well... kind of, yes.
02:04:00 <dmwit_> > [] >>= return 32
02:04:01 <lambdabot>   add an instance declaration for (Num [b])
02:04:05 <LeCamarade> > take 5 [1 ..]
02:04:06 <lambdabot>  [1,2,3,4,5]
02:04:18 <quicksil1er> dmwit_: I think what you want will work, but to be sure I'd need to check the source of the state monad :)
02:04:19 <dmwit_> > [] >>= (\x -> return 32)
02:04:21 <lambdabot>  []
02:04:29 <quicksil1er> dmwit_: laziness is controlled by data dependencies
02:04:39 <LeCamarade> campusblo: Seen? take 5 [1 ..] returns [1, 2, 3, 4, 5]. But ...
02:04:40 <dmwit_> quicksil1er: Okay, would you mind if I hpaste'd it?
02:04:50 <quicksil1er> dmwit_: so it just depends which values you demand, and what evaluation is required to produce them
02:04:53 <LeCamarade> > length take 5 [1 ..]
02:04:55 <lambdabot>  Couldn't match expected type `[a]'
02:04:57 <osfameron> dmwit_: but guard doesn't do anything with x and y, it just assigns an output to _ wihch is apparently ignored
02:05:17 <LeCamarade> campusblo: Do you have GHCi running?
02:05:20 <quicksil1er> dmwit_: sure although I don't promise to have time for a detailed look :)
02:05:21 <norpan> what's everybodys take on record accessor naming conventions?
02:05:24 <campusblo> yes
02:05:26 <dmwit_> =)
02:05:33 <campusblo> i test in hugs first though
02:05:44 <campusblo> that'll work right?
02:05:54 <LeCamarade> campusblo: Okay, Hugs will do. Do the following.
02:06:21 <LeCamarade> take 5 [1 ..]
02:06:27 <norpan> I'm thinking put each record in separate module and use M.name to avoid namespace pollution
02:06:30 <LeCamarade> That returns [1, 2, 3, 4, 5]
02:06:35 <osfameron> dmwit_: pah, I'll take another "15 minutes" tonight or tomorrow night to have a look at it.  Maybe I should set the Advertising Standards Authority on him! ;-)
02:06:40 <LeCamarade> Then, do length [1, 2, 3, 4,5]
02:06:44 <LeCamarade> That returns 5
02:07:05 <campusblo> yip
02:07:06 <LeCamarade> Then, do: length take 5 [1 ..]
02:07:18 <LeCamarade> That gives an error. You know why?
02:07:38 <campusblo> nope
02:08:10 <campusblo> well i know its a type error
02:08:20 <campusblo> one function returns a type that the other cant use
02:08:23 <LeCamarade> Because everything after the first func call (length) is passed to length. So, to prevent that, you use the $ sign. before I go on, do this:
02:08:29 <LeCamarade> length $ take 5 [1 ..]
02:08:30 <matthew-_> norpan: I tend to use $constructorName_fieldName
02:08:39 <LeCamarade> It works, this time.
02:09:02 <campusblo> ok now it works
02:09:04 <LeCamarade> Right?
02:09:06 <matthew-_> campusblo: or use brackets a la lengeth (take 5 [1..])
02:09:13 <norpan> matthew-_: $?
02:09:21 <campusblo> ok thats how i usually do it
02:09:33 <matthew-_> norpan: err, well as in what's the actual constructor name.
02:09:36 <LeCamarade> Yes, so using the dollar is like using a one-sided bracket.
02:09:37 <norpan> ah
02:09:50 <campusblo> ok cool thanks
02:09:53 <norpan> matthew-_: i do that too, but it leads to very long names
02:09:56 <LeCamarade> length (take 5 [1 ..]) is the same as length $ take 5 [1 ..]
02:10:02 <LeCamarade> But ...
02:10:10 <earthy> no, it isn't
02:10:15 <matthew-_> norpan: eg data Foo = Bar { bar_vodka :: String, bar_tequilla :: String ... }
02:10:19 <campusblo> oh right i got it
02:10:20 <earthy> it evaluates to the same
02:10:34 <earthy> but the second form has a function call more
02:10:37 <vali> oh no, the tutorial i am reading just started a chapter called "the monad"
02:10:38 <LeCamarade> campusblo: The dollar only works when what coming after it is of the type a -> b (where b and a may be the same type).
02:10:52 <norpan> earthy: not if the compiler inlines $
02:10:55 <earthy> @type $
02:10:57 <lambdabot> parse error on input `$'
02:11:02 <earthy> @type ($)
02:11:04 <LeCamarade> campusblo: Such as a function (take, in our case)
02:11:04 <lambdabot> forall a b. (a -> b) -> a -> b
02:11:10 <matthew-_> norpan: yep, but I regularly write functions which are constants with long names to give meaning to the constant...
02:11:11 <campusblo> i got it
02:11:46 <earthy> LeCamarade: what comes *before* the $ has to be of type (a -> b), what comes after it has to have type a
02:11:54 <campusblo> suppose i wanted to put the output as a variable?
02:12:07 <hpaste>  dmwit pasted "A random monad, and some code using it to permute lists" at http://hpaste.org/1440
02:12:13 <campusblo> or to a variable . could i do that without side effecting?
02:12:26 <LeCamarade> campusblo: The output of $, you mean?
02:12:29 <campusblo> well im not sure how to ask the question
02:12:39 <campusblo> i could put it in a stack right?
02:12:42 <LeCamarade> earthy: Yeah, you're right. :oD
02:13:07 <dmwit_> quicksil1er: Okay, I posted it.  The permutation part is untested though, I was planning on asking here before I went ahead with it. =P
02:13:16 <LeCamarade> earthy: Only I usually want to keep the arrows hidden until we are past some point. :oD
02:14:36 <dmwit_> > let cycle n xs = drop n xs ++ take n xs in cycle 3 [0,1,4,5,6]
02:14:37 <lambdabot>  [5,6,0,1,4]
02:14:44 <dmwit_> > let cycle n xs = drop n xs ++ take n xs in cycle 0 [0,1,4,5,6]
02:14:46 <lambdabot>  [0,1,4,5,6]
02:14:49 <campusblo> ok im gone for a bit. thanks again
02:14:56 <dmwit_> > let cycle n xs = drop n xs ++ take n xs in cycle 30 [0,1,4,5,6]
02:14:58 <lambdabot>  [0,1,4,5,6]
02:15:06 <dmwit_> > let cycle n xs = drop n xs ++ take n xs in cycle 31 [0,1,4,5,6]
02:15:08 <lambdabot>  [0,1,4,5,6]
02:21:02 <quicksil1er> dmwit_: ok, well the key point is the following
02:21:14 <quicksil1er> dmwit_: the 'list' part (what you return) is lazily generated, and that's fine
02:21:27 <quicksil1er> dmwit_: but, if you "force" the StdGen part (the 'state' part of 'State')
02:21:40 <quicksil1er> dmwit_: then, in order to calculate the final value it's got to do all the work
02:22:22 <quicksil1er> dmwit_: what I don't actually know, is whether the State Monad by default forces the state part strict, or not
02:23:01 <dmwit_> quicksil1er: Okay, I can check that myself by looking in the module, maybe.
02:23:08 <dolio> State is lazy by default, I think.
02:23:15 <dmwit_> quicksil1er: More importantly, how can I learn to answer this question on my own in the future?
02:23:54 <dmwit_> For example, if I'm doing DFS,
02:25:02 <dmwit_> Say at depth 1 I have the list [N,S,E,W], so I follow N.  Why come getting a random number at depth 2 doesn't force the evaluation of [S,E,W]?
02:25:10 <dmwit_> Or...
02:25:10 <dmwit_> oh!
02:25:18 <dmwit_> I get it, the advantage comes at depth 3.
02:25:41 <dmwit_> Because you don't have to create all the sibling lists for nodes S, E, and W at depth 2.
02:27:25 <haraldk> hm, can the $ operator can be though of as a "(" where the ")" is at the very end of the expression?
02:27:47 <dmwit_> haraldk: usually
02:28:05 <haraldk> think how readable scheme had been if that worked there :-)
02:28:14 <dmwit_> =)
02:28:25 <dmwit_> How do you tell what the end of the expression is?
02:28:44 <LeCamarade> haraldk: dmwit_ is right. Although it must be after and before a member of type a -> b
02:28:57 <dmwit_> LeCamarade: Only after.
02:29:01 <dmwit_> > head $ [1,2,3]
02:29:03 <lambdabot>  1
02:29:13 <matthew-_> @src ($)
02:29:14 <lambdabot> f $ x = f x
02:29:16 <dmwit_> LeCamarade: (.) is the one that has to be both before and after.
02:29:35 <haraldk> yes, so the parentheses in this expression (1) can't be replaced by a $, obviously
02:29:46 <LeCamarade> dmwit_: A list is of type a -> b
02:29:53 <dmwit_> :t [1,2,3]
02:29:55 <lambdabot> forall t. (Num t) => [t]
02:29:58 <dmwit_> Lies!
02:30:03 <dmwit_> And, even so:
02:30:07 <dmwit_> > (+1) $ 2
02:30:09 <lambdabot>  3
02:30:21 <LeCamarade> dmwit_ the syntactic sugra hides it from you. Try it with a non-list, alright.
02:30:22 <haraldk> but
02:30:26 <haraldk> > $ 1
02:30:27 <lambdabot>  Parse error
02:30:28 <LeCamarade> hm ...
02:30:34 <LeCamarade> Wiat.
02:30:37 <LeCamarade> s/ia/ai/
02:30:42 <dmwit_> :t ($) -- ;-)
02:30:45 <lambdabot> forall a b. (a -> b) -> a -> b
02:31:13 <dmwit_> ($) = id -- it doesn't do anything but change the order of application!
02:31:37 <LeCamarade> Oh, yeah. Only after.
02:32:00 <haraldk> :t id
02:32:02 <lambdabot> forall a. a -> a
02:32:08 <dmwit_> haraldk: Yeah, it's a little different.
02:32:13 <dmwit_> It's a specialization to functions.
02:32:39 * LeCamarade wonders where he got the before idea ...
02:32:41 <haraldk> > head `id` [1,2,3]
02:32:42 <lambdabot>  1
02:33:03 <dmwit_> LeCamarade: It's good style to put it before a function, but not required.
02:33:21 <dmwit_> haraldk: Great for obfuscating code. =)
02:33:40 <haraldk> I didn't expect that to work :-)
02:33:48 <LeCamarade> dmwit_: Yeah. And imagine my shock on discovering it worked with types too ...
02:34:07 <LeCamarade> > Just $ 2
02:34:09 <lambdabot>  Just 2
02:34:18 <dmwit_> That's a type constructor. ;-)
02:34:25 <LeCamarade> @type Just 2
02:34:27 <Ulfalizer> haraldk: f $ x = f x   is the definition from the prelude. it just applies the left operand to the right, and the associativity fixes it so that you don't have to type a bunch of parens (that's the point :)
02:34:27 <lambdabot> forall t. (Num t) => Maybe t
02:34:28 <dmwit_> Err... data constructor.
02:34:45 <LeCamarade> I meant type constructor. Oh, Lord! I need to sleep!
02:34:58 <quicksil1er> constructors 'are' functions in haskell
02:35:10 <quicksil1er> or, for every constructor there is a function with the same name, at least
02:35:24 <Ulfalizer> so e.g. f $ g $ h $ x = f $ (g $ (h $ x)) = f (g (h x))
02:35:48 <haraldk> ulfa: yes, I just used to have some trouble seeing when I could apply it to reduce the need for parentheses
02:35:49 <LeCamarade> quicksil1er: It wouldn't have been obvoius to me at the time.
02:35:52 <quicksil1er> = f . g . h $ x
02:35:56 <quicksil1er> (which is preferred to me)
02:35:57 <dmwit_> IMO that's better as f . g $ h x.
02:36:17 <quicksil1er> LeCamarade: :)
02:36:33 <haraldk> it surprises me that a section of a unary function works, though...
02:36:46 <haraldk> except of course that they are all unary
02:36:53 <Ulfalizer> haraldk: usually when you're passing a value through a bunch of functions
02:37:08 <quicksil1er> haraldk: right, they're all unary, that's "why" it works :)
02:37:19 <quicksil1er> haraldk: although, it's a GHC extension isn't it?
02:37:22 <matthew-_> dmwit_: I'd have that as f . g . h $ x
02:37:42 <LeCamarade> quicksil1er: No! I use only GHC, but I think 'tis standard.
02:37:48 <dmwit_> matthew-_: Really?
02:38:02 <quicksil1er> dmwit_: definitely
02:38:08 <quicksil1er> dmwit_: because then you can convert
02:38:08 <LeCamarade> It's in ML, so it is standard, I think.
02:38:13 <matthew-_> yeah, it seems to make it clearer to me what the "chain of functions" is and what the arguement is
02:38:15 <LeCamarade> Kinda.
02:38:18 <quicksil1er> foo x = f . g . h $ x ----> foox = f . g . h
02:38:23 <dmwit_> Ah, that's a good point.
02:38:45 * dmwit_ mentally switches his preferred style
02:38:46 <quicksil1er> and that shows you how you can write map (f . g . h)
02:38:50 <quicksil1er> and so on and so forth
02:39:01 <dmwit_> Cool!  I like it.
02:39:04 <quicksil1er> (you can't write map (f . g $ h))
02:39:11 <quicksil1er> (or rather, that means something completely different)
02:39:14 <dmwit_> I think my preferred style will soon be
02:39:23 <Ulfalizer> unless f . g $ h gives a function :)
02:39:25 <quicksil1er> :t f . g . h
02:39:26 <dmwit_> x >>> h >>> g >>> f
02:39:27 <lambdabot> Not in scope: `f'
02:39:28 <lambdabot>  
02:39:28 <lambdabot> <interactive>:1:4: Not in scope: `g'
02:39:34 <dmwit_> Or so
02:39:45 <LeCamarade> f . g $ h would fail, because $ passes a param, while . just welds funcs together.
02:40:23 <Ulfalizer> but f . g $ h  could still return a function
02:40:29 <LeCamarade> The . is better when the composed func is to be packed off and shipped to China. best.
02:40:53 <LeCamarade> Ulfalizer: Yes, it will return a function, but it will fail the type-check.
02:41:17 <Ulfalizer> i thought you were talking about arbitrary functions f and g
02:41:44 <dmwit_> If (f . g . h) is the intended thing, then certainly (f . g $ h) will be different.
02:42:01 <dmwit_> But (f . g $ h) certainly may sometime be what you want.
02:42:11 <dmwit_> (Though why you wouldn't do (f . g h) is beyond me. =)
02:43:21 <mux> is it the kind system that prevents, for instance, to pass a function of type (a -> m b) when the expected type is (a -> b) ?
02:43:27 <LeCamarade> Ulfalizer: Yeah. Along the way, I specialised it. My bad.
02:43:44 <Ulfalizer> i'd use f $ g $ h if i'm just passing a value through some functions in an ad-hoc way in a single location, and . if i'm passing compositions around
02:43:45 <dmwit_> mux: No, that's the type system.
02:44:02 <mux> dmwit_: then how does it do that?
02:44:21 <dmwit_> mux: Err, are a and b consistent between those two type signatures?
02:44:24 <mux> you can pass a (a -> b) type when just a 'a' type is expected
02:44:33 <mux> no, they are arbitrary.
02:44:38 <dmwit_> ah
02:44:40 <dcoutts> mux: it's the kind system that prevents you writing illegal *type* expressions
02:44:57 <dmwit_> mux: I don't think such a thing would be prevented in general.
02:45:09 <dmwit_> Unless there's more context, from which something about the (a -> b) function could be deduced.
02:45:10 <mux> in the case of map vs mapM, is it just the constraint Monad m => ... or the kind system?
02:45:21 <mux> or something else? :-)
02:45:40 <dmwit_> mux: You can pass a (a -> m b) to map if you really want... =)
02:45:51 <mux> I don't think you can
02:45:57 <dmwit_> > map print [1,2,3]
02:45:59 <lambdabot>  [<IO ()>,<IO ()>,<IO ()>]
02:46:10 <mux> ah
02:46:10 <dcoutts> @src mapM
02:46:10 <dmwit_> Empirically, you can.
02:46:11 <lambdabot> mapM f as = sequence (map f as)
02:46:19 <dcoutts> and it's usefull too ^^
02:46:24 <mux> yes that makes sense
02:46:44 <LeCamarade> mux: The result is a list of actions. Yes, makes sense.
02:46:54 <mux> yeeah I get that
02:46:57 <mux> I actually already used it
02:47:13 <mux> I was a bit puzzled as to how it would be prevented when it isn't
02:47:25 <dmwit_> :D
02:47:29 <LeCamarade> mux: Of course. I knew. :oD
02:47:58 <quicksil1er> dmwit_: btw (f . g h) is different *again* from (f . g $ h)
02:48:17 <quicksil1er> dmwit_: (f . g . h), (f . g h) and (f . g $ h) all have different types
02:48:30 <quicksil1er> :t \f g h -> f.g.h
02:48:33 <lambdabot> forall c b c1 a. (c1 -> c) -> (b -> c1) -> (a -> b) -> a -> c
02:48:40 <quicksil1er> :t \f g h -> f.g$h
02:48:42 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
02:48:47 <quicksil1er> :t \f g h -> f . g h
02:48:49 <lambdabot> forall t b c a. (b -> c) -> (t -> a -> b) -> t -> a -> c
02:49:36 <Ulfalizer> yeah, because $ has a higher precedence than ., while function application has a higher precedance than . . so (f . g h) = f . (g h), while (f . g $ h) = (f . g) $ h = (f . g) h
02:49:54 <quicksil1er> right :)
02:50:00 <dmwit_> Ah, so (g h) must produce a function for the one to work.
02:50:04 <quicksil1er> well what you said was wrong
02:50:05 <Ulfalizer> yep
02:50:07 <dmwit_> Where as (f . g) h needn't.
02:50:09 <quicksil1er> but what you concluded was right
02:50:16 <quicksil1er> $ has a LOWER precedence than .
02:50:34 <Ulfalizer> ah, yes, sorry :)
02:51:08 <dmwit_> Where as in (f . g) h, (g h) could just produce a value.  huh
02:51:11 <eumenides> is Data.Array faster than Data.Array.IArray?
02:51:46 <Ulfalizer> dmwit_: g has to accept h, and f has to accept (g h)
02:52:20 <Ulfalizer> (f . g) h = f $ g $ h = f (g h)
02:52:26 <dmwit_> eumenides: Looks like they're the same thing, no?
02:52:37 <dmwit_> Meaning, Array is an instance of IArray.
02:53:16 <eumenides> dmwit_: ah. hm. okay
03:04:58 <LeCamarade> :t (.)
03:05:00 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
03:05:24 <LeCamarade> :t (..)
03:05:34 <lambdabot> parse error on input `..'
03:06:14 <LeCamarade> Inconsistency. .. Should be just a usual operator. Not that I complaining.
03:09:10 <dcoutts> no, it's part of the lexical syntax due to things like: [0..]
03:09:30 <dcoutts> so (.) is not special, (...) isn't either, but (..) is special.
03:10:30 <LeCamarade> dcoutts: Yeah. Because [1 ..] would require over-loading (for when there is another args and when there's none), which doesn't work Haskell.
03:20:10 <ndm> @seen dons
03:20:11 <lambdabot> dons is in #haskell-soc and #haskell. I last heard dons speak 5h 44m 49s ago.
03:20:57 <earthy> he's probably fast asleep given as his local time currently is 03:19 or somesuch
03:21:15 <ivanm> isn't dons in sydney anymore?
03:21:29 <earthy> nah, he's visiting people in western US at the moment
03:22:14 <ndm> thats no excuse
03:22:14 <lambdabot> ndm: You have 3 new messages. '/msg lambdabot @messages' to read them.
03:23:10 <ndm> dcoutts, TMR article sounds like a good plan
03:23:31 <dcoutts> ndm: dons was thinking about something along these lines too
03:23:52 <dcoutts> basically telling those who don't yet know, this is the way you should write libs!
03:24:14 * ivanm doesn't know... what's this about?
03:24:50 <dcoutts> ivanm: Haskell software engineering
03:24:58 <dcoutts> how to develop libraries
03:25:04 <haraldk> where is this TMR article?
03:25:13 <dcoutts> in our heads :-)
03:25:16 <pejo> dcoutts, sounds like an excellent idea.
03:25:28 <ivanm> lol... you plan on writing guidelines on the correct way to do so?
03:25:29 <haraldk> can't wait to pry it out
03:25:35 <goltrpoat> ok, this is just weird.  i'm sitting outside, there's a raccoon and a possum sitting about three feet away from me.
03:25:41 <ndm> dcoutts, yep - there is the original pretty printer combinator library from Hughes, but we could do with something newer (his was before QuickCheck) and more accessible
03:25:58 <goltrpoat> the raccoon keeps standing up on his hind legs and looking at me in a general "who the hell are you" type way.
03:26:06 <ndm> that was a paper all about combinators and properties
03:26:07 <dcoutts> ndm: I also want to talk about the performance side of things, as well as correctness
03:26:20 <dcoutts> ndm: we want new exciting examples
03:26:32 <ndm> dcoutts, with rules you mean?
03:26:37 <haraldk> but what kind of libraries are we talking about? Combinator libraries?
03:26:44 <dcoutts> ndm: that's not necessary
03:26:58 <mauke> hello
03:27:00 <dcoutts> ndm: I think bytestring, filepath and binary are great examples
03:27:05 <ndm> dcoutts,  or the ability to optimise later without breaking stuff?
03:27:19 <mauke> I have a new version of my type inference algorithm
03:27:23 * Ulfalizer looks up possum on wikipedia
03:27:44 <dcoutts> ndm: the ability to take an idea, prototype it, specify it, and then iteratively make it 600x faster without breaking anything is pretty compelling imho.
03:27:51 <mauke> this time it's functional, not requiring STRefs anymore, and it can handle recursive types
03:28:28 <goltrpoat> Ulfalizer:  think 'giant rat.'
03:28:43 <ndm> dcoutts, yep - agreed - although i haven't got to the "make it faster" in FilePath, but i will if anyone complains
03:29:00 <ivanm> goltrpoat: where are you from that you've got possums _and_ raccoons?
03:29:07 <Ulfalizer> goltrpoat: yeah, looks like it in the picture. dunno if i've ever heard of them before though.
03:29:12 <dcoutts> ndm: no, that's not a problem, we can use a range of examples to illustrate the point.
03:29:12 <goltrpoat> i'm in texas right now
03:29:15 * ivanm thought possums where only in Oz and imported into NZ as pests :p
03:29:21 <haraldk> the "over the hedge" cartoon?
03:29:34 <ndm> dcoutts, cool - next issue? are you still aiming for HW?
03:29:52 <dcoutts> ndm: yeah, we're aiming for something on binary stuff for HW
03:29:59 <ndm> dcoutts, i read your review in TMR - looks good
03:30:04 <Ulfalizer> wikipedia says they're native to australia, new guinea and sulawesi (wherever that is). what's it doing in texas?
03:30:14 <mrchebas_> dcoutts: QuickCheck works well with higher-order functions in practice?
03:30:15 <dcoutts> ndm: ta, I've got a couple things to update
03:30:17 <goltrpoat> not sure.  there's a lot of them here
03:30:19 <earthy> mrchebas!
03:30:22 <dcoutts> mrchebas_: yep.
03:30:25 <mrchebas_> hey earthy :)
03:30:38 <ndm> only thing is i wasn't sure how you are meant to refer to the author throughout, i was kind of expecting "Dr Hutton"
03:30:44 <haraldk> Sulawesi is that island next to Borneo, isn't it? But I thought it had another name these days
03:30:50 <haraldk> Sumatra
03:31:02 <dcoutts> ndm: I'm not sure either, I suppose I was kind of informal.
03:31:03 <LeCamarade> @google Sulawesi
03:31:05 <lambdabot> http://en.wikipedia.org/wiki/Sulawesi
03:31:05 <lambdabot> Title: Sulawesi - Wikipedia, the free encyclopedia
03:31:06 <Ulfalizer> yeah, sumatra i've heard off
03:31:10 <dcoutts> ndm: he didn't seem to mind.
03:31:17 <mauke> hmm, but it assigns (:) the type "(a -> (b@[a] -> b))"
03:31:30 <goltrpoat> ah.  http://en.wikipedia.org/wiki/Opossum
03:31:31 <lambdabot> Title: Didelphimorphia - Wikipedia, the free encyclopedia
03:31:33 <haraldk> ah, Celebes was it
03:31:40 <dcoutts> ndm: he made a couple comments on the review but didn't mention that so I assume that's fine.
03:31:44 <goltrpoat> different beast.
03:32:09 <ndm> dcoutts, as long as he's happy thats fine
03:32:09 <dcoutts> ndm: as for schedule, probably post-HW is best.
03:32:19 <ndm> agreed :)
03:32:19 <dcoutts> ndm: post-deadline I mean
03:32:38 <ivanm> goltrpoat: AFAIK, possum =/= opossum ;-)
03:32:39 <dcoutts> ndm: are you after HW too :-)
03:32:46 <ndm> yep, with Play
03:32:49 <dcoutts> cool
03:32:52 <haraldk> I'd love to look at something about this paper/idea thing you've got, dcoutts and ndm
03:33:06 <goltrpoat> ivanm:  yeah.  they contract it to 'possum here.
03:33:20 <haraldk> Objective Possum
03:33:23 <ndm> haraldk, the idea is new to me as of 10 minutes ago - there isn't much
03:33:33 <ivanm> goltrpoat: *nod*
03:33:35 <ivanm> haraldk: lol
03:33:50 <haraldk> what? things move that slowly? ;-)
03:34:01 * Ulfalizer tries hard to stop his urges to come up with a "pussy" joke every time he reads "possum"
03:34:06 <dcoutts> haraldk: people have asked dons and myself before to write something about what techniques to use in designing/building/optimising Haskell libs.
03:34:26 <ivanm> down boy, Ulfalizer :p
03:34:49 <Phas> http://hpaste.org/1441#a1 <- HAppS / template haskell error :/
03:34:59 <dcoutts> haraldk: and we think that's a good idea, we've learnt a lot in the last couple years on how to do that.
03:35:01 <haraldk> I'd sure like to know. The lazy/functional world is alien enough to me that I can't think of an obvious way to see what a good design looks like
03:35:44 <haraldk> except when I use it, of course :-)
03:37:08 <goltrpoat> the general principles translate fairly well from the imperative world, i think.  probably the only thing that translates in any sort of a useful manner.
03:39:11 <dcoutts> goltrpoat: but we have an advantage in that it's much easier for us to specify and test our designs because they're pure
03:40:07 <ndm> and that our types specify more, which lets us do the testing automatically to some degree
03:40:36 <ndm> dcoutts, one thing we really need is a unified QuickCheck/SmallCheck driver that combines all the bits out of all your projects and FilePath plus more
03:40:52 <dcoutts> yes
03:40:57 <ndm> i.e. that parses code, extracts properties based on RULE's and instances, and explicitly written
03:41:08 <dcoutts> and the SmallCheck.Partial lib for specifying strictness properties
03:41:22 <ndm> basically the one "go to" tool for all these bits
03:42:01 <ndm> yeah, everything
03:42:07 <haraldk> Hmm, smallcheck isn't distributed with GHC, is it?
03:42:07 <dcoutts> ndm: and/or something to allow you to include the properties in the module but only have to import and depend on quickcheck/smallcheck etc when running the tests, so it's not a hard dependency
03:42:49 <dcoutts> ndm: there's always the temptation to put the tests in a separate module so your main one doesn't depend on the testing libs
03:42:56 <goltrpoat> dcoutts:  i'm talking about a higher level of design, i think.  these are the logical components of the library, this component is a client of this component, this is the required interface, etc
03:43:05 <haraldk> @where SmallCheck
03:43:06 <lambdabot> http://www.cs.york.ac.uk/fp/smallcheck0.2.tar
03:43:14 <dcoutts> haraldk: no, it's not. It needs a home on hackage
03:43:47 <dcoutts> it needs a little bit of love, it needs to be cabalised and put on hackage
03:43:53 <dcoutts> and it needs a darcs repo
03:44:03 <ndm> dcoutts, and a fecking web page!
03:44:09 <dcoutts> that too :-)
03:44:21 <dcoutts> ndm: though a hackage one would be sufficient possibly
03:44:28 <dcoutts> it's better than nothing and it's easy
03:44:31 <ndm> dcoutts, we can easily do the separate testing instances etc - have you seen how FilePath does it?
03:44:44 <ndm> --
03:44:47 <dcoutts> ndm: I've not looked at it in detail, no.
03:44:53 <ndm> -- > property is a test
03:45:06 <ndm> so it appears in the haddocks, and is a comment, and can easily be extracted
03:45:23 <ndm> then it extracts those bits, and links in to the rest of the library like it was a library (because it is)
03:45:24 <therp> cross merging between separate branches in darcs is pure horror
03:45:38 <ndm> so it tests the library from the outside using the properties
03:45:42 <dcoutts> ndm: can I have properties about internal functions that are not exported?
03:45:56 <ndm> dcoutts, #ifdef TESTING :-)
03:45:59 <dcoutts> ndm: and can I use extra utility functions that are internal to the lib?
03:46:01 <dcoutts> ah ok :-)
03:46:03 <ndm> dcoutts, and do
03:46:19 <ndm> its not idea, but i'm sure a clever preprocessor could get round all these issues
03:46:56 <dcoutts> ndm: we should make whatever we come up with work with cabal test
03:47:49 <ndm> dcoutts, easy enough to do, i assume - the hard bit will be a coherent design - the implementation is rather easier...
03:48:00 <dcoutts> aye
03:48:23 <dcoutts> ndm: and then the next project after all that is QuickBench! :-)
03:48:28 <ndm> dcoutts - this would be a good thing to do as part of the article
03:48:44 <dcoutts> ndm: what exactly?
03:48:50 <ndm> dcoutts - once i finish -O11 performance will be solved, then we won't have to worry :-)
03:48:57 <dcoutts> hah
03:49:01 <ndm> dcoutts, this property testing tool
03:49:17 <ndm> since at the moment we've all had to write custom drivers to get our testing infrastructure working
03:49:18 <dcoutts> right, we can describe it in the article
03:49:23 <dcoutts> yeah
03:49:54 <dcoutts> the QuickCheck and SmallCheck batch drivers are pretty poor imho
03:50:05 <ndm> yep, suck totally i'd say
03:50:11 <ndm> unless you are manually doing one single test
03:50:17 <ndm> which i guess is what they were designed for
03:50:20 <dcoutts> and we have no framework at all for benchmarking
03:50:26 <ndm> i do keep pestering colin to make things better
03:50:31 <dcoutts> each project builds it from scratch
03:50:35 <ndm> indeed
03:50:38 <dcoutts> that's what QuickBench is for
03:50:45 <ndm> i wonder if the property and benchmarking could be combined?
03:50:49 <mrchebas_> dcoutts, how do you deal with printing function counter examples found by QuickCheck? Explicit function terms?
03:51:28 <dcoutts> mrchebas_: SmallCheck has this cunning system, it shows input/output pairs for a few smallish examples
03:51:59 <dcoutts> ndm: some of the driver/reporting infrastructure probably could
03:52:17 <dcoutts> ndm: the spec language and the data generation instances are different though
03:52:30 <ndm> dcoutts, cool - may try and spec something up and send it to you for review today - it will take quite a few iterations to get right though
03:52:40 <dcoutts> but it could certainly be more coherent
03:52:58 <dcoutts> ndm: I thought we were doing this post-HW deadline ;-)
03:52:58 <ndm> dcoutts, do you just generate something with arbitrary, then serialise it and use that as a test case?
03:53:19 <ndm> writing bores me :)
03:53:23 <dcoutts> ndm: for binary? or are you talking about this QuickBench vapourware?
03:53:30 <ndm> QuickBench
03:53:31 <mrchebas_> dcoutts: so if i understand if "f" if the counter example, what you show is sort of: [ (i,f i) |  i <- inputs] ?
03:53:45 <dcoutts> ndm: it only exists in my and dons heads.
03:53:52 <ndm> i would have thought you specified > time: computation
03:54:06 <ndm> then it quickchecks it, using random data, saves the data, then reuses that data in future runs
03:54:22 <ndm> thats what i did for my Play benchmarking
03:55:16 <dcoutts> ndm: we'd use a system much like quick/small check to generate increasing sizes of data for the various inputs and then time them and then do more tests to find interesting points in the performance curve and try to fit a polynomial to it. Or something like that.
03:55:36 <dcoutts> ndm: so all the inputs would have a measurable numeric size
03:56:02 <dcoutts> so the perf is then hopefully a function of those numeric variables
03:56:13 <dcoutts> in however many dimensions you need
03:56:17 <ndm> dcoutts, the polynomial sounds a bit dubious - i doubt performance works that...
03:56:32 <ndm> unless you are doing something like binary serialisation, i suppose :-)
03:56:45 <ndm> things like FilePath wouldn't fit any curve, neither will play
03:57:12 <dcoutts> in lots of interesting cases performance is usually mostly continuous
03:57:30 <ndm> in play the data is too context dependant
03:57:42 <dcoutts> ndm: not counting things like number of path components etc etc
03:57:51 <ndm> (i think, testing often proves me wrong on performance intution)
03:58:26 <dcoutts> ndm: sure picking the right things is important, one can easily pick things where random data of all the same 'size' gives very different running times
03:58:39 <dcoutts> so getting a measure isn't always easy or possible
03:58:46 <ndm> how about Arbitrary to generate the data, then a function to classify the data
03:58:57 <dolio> If you guys do that, Haskell will be the language of choice for undergraduate algorithms students.
03:58:59 <ndm> so the data stays fixed, but you can reclassify it after as your performance intution changes
03:59:18 <ndm> true, having "your algorithm is O(n^2)" would be uber neat
03:59:22 <dcoutts> right, I was just going to say, it might be easier to look at the input to give it a size measure than trying to generate data of a particular size
03:59:23 <dolio> Step 1: Implement algorithm in haskell. Step 2: Get big-O answer for homework. :)
03:59:39 <ndm> and you can change the classify without changing the test data set
04:00:01 <dcoutts> ndm: though we'd also like to be able to try more data points around more 'interesting' points in the graph
04:00:13 <ndm> dcoutts, yeah - manual data injection
04:00:24 <dcoutts> ndm: ie ares where the variance or derivative look high
04:00:39 <ndm> dcoutts, although that does imply either the old versions have less info, or we "archive" old performance pieces of code
04:00:52 <goltrpoat> you'll probably want something like pade' approximants instead of a polynomial fit, if you want to come up with a reasonable extrapolation
04:00:57 <ndm> dcoutts, and that requries to archive the binary - anything else is too unreliable (if you are hacking libraries etc)
04:01:20 <dcoutts> ndm: I'm not thinking about changes in code over time especially, just trying to find out about a particular function
04:01:45 <ndm> dcoutts, ah - i'd like to do some "over time" measure as well, so you can check you are getting better
04:01:53 <dcoutts> that'd certainly be useful
04:02:01 <dcoutts> link it into your buildbot or whatever
04:02:07 <ndm> exactly :)
04:02:08 <quicksil1er> I worked with/for a guy who had automatic performance metrics for java algorithms
04:02:16 <quicksil1er> the students wrote their 'merge sort'
04:02:25 <quicksil1er> it tested both correctness and asymptotic complexity
04:02:41 <dcoutts> ndm: so that probably just needs a batch driver and a sensible output format and tool for looking at stuff over time.
04:02:54 <quicksil1er> of course, you can't do it perfectly. but it was good enough to be interesting
04:03:06 <quicksil1er> it's almost impossible to distinguish between n and n log n
04:03:13 <quicksil1er> (which is actually a good lesson to learn...)
04:03:14 <dcoutts> quicksil1er: I bet
04:03:45 <quicksil1er> n log n really isn't much worse than n, since in *practice* log n is almost always bounded :)
04:04:01 <dcoutts> very hard to distinguish from a constant + noise
04:04:05 * quicksil1er nods
04:04:23 <quicksil1er> also, the nature of computer architectures is to introduce logarithmic constants
04:04:32 <quicksil1er> memory access is supposed to be constant time but it's actually log n
04:04:47 <dcoutts> so for performance you want a quick estimate of asymptotic complexity, but then the constants do matter
04:04:56 <koala_man> quicksil1er: why is that?
04:05:02 <dcoutts> you want to see that your code changes are improving the constants
04:05:13 <quicksil1er> koala_man: the three levels of caches are each an order of magnitude faster than the next
04:05:34 <quicksil1er> koala_man: and 'normal memory' is and order of magnitude slower than the slowest cache, but 3 orders faster than a swap file
04:05:37 <dcoutts> quicksil1er: it's usually O(fast) or O(slow), cached or uncached :-)
04:05:56 <quicksil1er> dcoutts: there are at least 2 levels of cache, RAM, and swap, on most modern systems
04:06:02 <quicksil1er> dcoutts: so at least 4 levels...
04:06:10 <dcoutts> ok really really slow
04:06:21 <dcoutts> I'm not sure I'd call it log n
04:06:27 <koala_man> quicksil1er: it's faster, but it doesn't scale better/worse
04:06:35 <goltrpoat> what's n here?
04:06:51 <dcoutts> good question
04:06:55 <quicksil1er> koala_man: but your algorithm scales, as you move from a small data set which fits in the cache, to a larger one which doesn't
04:07:05 <quicksil1er> goltrpoat: memory footprint, approximately
04:07:10 <quicksil1er> goltrpoat: although my argument isn't precise
04:07:23 <quicksil1er> there is also the log n factor from 'word sizze'
04:07:39 <goltrpoat> right, i figured you meant word size when you first said log n
04:08:04 <quicksil1er> all kinds of detail which means you never really see linear scaling
04:08:26 <quicksil1er> which makes the curve-fitting tricky
04:08:46 <quicksil1er> what you *can* do reliably, though, is distinguish exponential, quadratic, and sub-quadratic
04:08:53 <quicksil1er> i.e., 'bad' from 'ok' :)
04:09:27 <goltrpoat> sounds like a job for the generalized hough transform.
04:09:37 <ndm> can you distinguish P and NP?
04:10:05 <goltrpoat> ndm:  yes.  the latter has an N in front of it.
04:10:18 <mauke> > "P" == "NP"
04:10:20 <lambdabot>  False
04:10:32 <mauke> weird, it's true in Perl :-)
04:10:38 <goltrpoat> haha
04:10:56 <ndm> > "PSPACE" == "NPSPACE"
04:10:58 <lambdabot>  False
04:11:03 <ndm> it got that one wrong :)
04:11:48 <mauke> why doesn't haskell allow recursive types?
04:12:10 <igli> lmao
04:12:36 <igli> er sorry.
04:12:54 <quicksil1er> mauke: you mean like List a = Nil | Cons a (List a) ?
04:13:05 <mauke> no, like \f -> f f
04:13:22 <quicksil1er> mauke: because they aren't system F
04:13:35 <MarcWeber> In HaXml what does i represent:  data Content i = CElem (Element i) i .... The documentation still contains the older version (prior to 1.14) which didn't contain this type parameter. i is only used to attach a custom type right?
04:13:44 <therp> mauka: what's the legal type for f in this case?
04:13:45 <mauke> (should have type a@(a -> b) -> b)
04:14:00 <mauke> the type of f is a@(a -> b)
04:14:05 <quicksil1er> but a = a->b is not inhabited in system F
04:14:18 <mauke> what is system F?
04:14:26 <quicksil1er> a mathematical framework
04:14:32 <quicksil1er> upon which haskell lies
04:14:47 <quicksil1er> actually haskell lies on System Fc which is a relatively conservative extension of System F
04:15:56 <mauke> hmm, I wonder how hard it would be to check for/disallow recursive types my checker
04:17:10 <quicksil1er> that's not a recursive type, I don't think
04:17:15 <quicksil1er> it's an infinite type
04:17:23 <doserj> the type of f suspiciously looks like curry's paradox
04:17:25 <quicksil1er> a recursive type is like the List example I gave, which is fine
04:17:44 <quicksil1er> :t \f -> f f
04:17:46 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
04:17:47 <lambdabot>     Probable cause: `f' is applied to too many arguments
04:17:54 <doserj> I don't think there is a reasonable type system that allows this...
04:17:55 <quicksil1er> yup, it's an infinite type
04:18:03 <mauke> ocaml -rectypes allows it
04:18:34 <mauke> and I call it recursive because it uses a type variable in its own definition
04:19:04 <goltrpoat> how is that actually used in ocaml?
04:19:05 <quicksil1er> I understand why you'd calling it recursive, just pointing out that that has a different widely accepted meaning :)
04:19:35 <haraldk> @where hIDE
04:19:35 <lambdabot> http://haskell.org/haskellwiki/HIDE
04:20:26 <mauke> goltrpoat: what do you mean?
04:20:55 <qwr> goltrpoat: you can create function that returns itself
04:21:11 <joelr1> good morning
04:21:17 <quicksil1er> http://groups.google.com/group/comp.lang.functional/browse_thread/thread/8ccaf9b51924b24e/003c558d7bceb6ae
04:21:20 <lambdabot> Title: Inferring Recursive Types - comp.lang.functional | Google Groups, http://tinyurl.com/ynq7kv
04:21:25 <goltrpoat> ah
04:21:35 <quicksil1er> mauke: the above thread has some relevant discussion
04:21:39 <qwr> goltrpoat: (or at least something with same type)
04:21:44 <quicksil1er> mauke: including a link to a haskell-cafe thread about it
04:21:57 <quicksil1er> goltrpoat: that link is fairly illuminating, and includes ocmal and haskell examples
04:23:36 <quicksil1er> mauke: oh, and you're right: the link to recursive types is closer than I remembered
04:23:37 <mauke> I see
04:23:50 <quicksil1er> mauke: these are a more general thing than the sort we  have built in
04:23:57 <quicksil1er> http://www.haskell.org/pipermail/haskell-cafe/2006-December/020074.html
04:23:59 <lambdabot> Title: [Haskell-cafe] There's nothing wrong with infinite types!, http://tinyurl.com/3akknx
04:24:09 <quicksil1er> the above post is ajb explaining why he thinks they are a bad thing :)
04:25:03 <goltrpoat> quicksil1er:  thanks
04:25:04 <goltrpoat> reading
04:25:20 <goltrpoat> oh actually i remember ajb's post
04:25:33 <mauke> oh, let me try that in my checker
04:26:08 <quicksil1er> goltrpoat: so do I now I read it again, but I had forgotten it :)
04:28:40 <mauke> *Main> test (App (App (Lam "s" (Lam "k" (App (App (Var "s") (Var "k")) (Var "k")))) (Lam "f" (Lam "g" (Lam "x" (App (App (Var "f") (Var "x")) (App (Var "g") (Var "x"))))))) (Lam "x" (Lam "y" (Var "x"))))
04:28:44 <mauke> Right "(w -> w)"
04:29:22 <qwr> http://pauillac.inria.fr/~remy/cours/appsem/ocaml-ml.html#htoc15
04:30:13 <doserj> As ajb observes, if you allow equirecursive types, it is hard to write a recursive function that does not typecheck...
04:31:14 <Lor> So require explicit type annotations for them then.
04:31:39 <quicksil1er> Lor: we do, in certain cases
04:31:48 <quicksil1er> Lor: where there is a rank 2 solution, you can annotate it
04:31:54 <quicksil1er> (and it will work, in GHC)
04:35:33 <mauke> oh, crap. infinite loop
04:36:23 <quicksil1er> in ghci, the following type-checks :
04:36:28 <quicksil1er> :t (\f -> f f) :: forall b. (forall a. a -> b) -> b
04:36:31 <lambdabot> forall b. (forall a. a -> b) -> b :: forall b. (forall a. a -> b) -> b
04:36:35 <qwr> "All terms of the lambda-calculus without constants are well-typed with recursive types."
04:36:43 <quicksil1er> ah, in lambdabot too
04:37:02 <quicksil1er> so the moral of the story is 'ghc supports abitrary rank types but doesn't try to infer them'
04:37:34 <quicksil1er> I'm not sure that's the only way to typecheck that term, though
04:38:51 <dmwit> quicksil1er: That makes a heavy demand on f.
04:38:59 <dmwit> It has to be able to turn any type into a b!
04:39:18 <quicksil1er> dmwit: agreed
04:39:31 <quicksil1er> dmwit: like I say, there are probably other ways to type it
04:39:40 <quicksil1er> dmwit: that one I copied from the thread
04:39:50 <dolio> :type const undefined
04:40:06 <quicksil1er> :t const undefined
04:40:08 <lambdabot> forall a b. b -> a
04:40:13 <goltrpoat> :t (\f -> f f) :: (forall a. a) -> b
04:40:16 <lambdabot> (forall a. a) -> b :: forall b. (forall a. a) -> b
04:40:29 <mauke> :t undefined :: a->b
04:40:32 <lambdabot> a->b :: forall a b. a -> b
04:40:32 <dmwit> That may very well be the only possible f for that type signature...
04:40:49 <dmwit> ...which isn't very useful in practice. =P
04:41:08 <quicksil1er> ah, I'm not sure that lambdabot really understands what we're donig here
04:41:19 <goltrpoat> nah, that typechecks in ghci too
04:41:20 <quicksil1er> I think it might be mis-parsing
04:41:38 <goltrpoat> the (forall a. a) -> b bit, i mean.  makes sense, really.
04:41:50 <goltrpoat> follows from what dmwit said
04:42:32 <dolio> Are there rank-2 annotations that let you specify the Y-combinator in the traditional way?
04:45:05 <eumenides> > let y f = f (y f) in y (\f n -> case n of 1 -> 1; n -> n * f (n - 1)) 10
04:45:07 <lambdabot>  3628800
04:45:32 <quicksil1er> :t let y f = f (y f) in y
04:45:35 <lambdabot> forall t. (t -> t) -> t
04:45:44 <dolio> That's cheating, though, because you're using built-in recursion to make your primitive recursion combinator.
04:45:56 <quicksil1er> yup :)
04:46:31 <dolio> The usual non-cheating way is 'y = \f -> (\g -> f (g g)) (\g -> f (g g))' no?
04:46:55 <dolio> But 'g g' leads to infinite types.
04:47:41 <quicksil1er> :let y f = (\g -> f (g g)) (\g -> f (g g)) in y
04:47:49 <quicksil1er> :t let y f = (\g -> f (g g)) (\g -> f (g g)) in y
04:47:51 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
04:47:51 <lambdabot>     Probable cause: `g' is applied to too many arguments
04:48:50 <quicksil1er> dolio: yes, I think there is, but I can't get my head around it right now :)
04:49:05 <dolio> :) Yeah, it's no simple task.
04:49:21 <pejo> What are you guys trying to do, define fix without using the built in recursion, yet have it type check?
04:49:30 <dolio> The trick is, you not only have to figure out the right types for parts, you have to decide where to put the annotations. :)
04:49:53 <quicksil1er> dolio: I imagine it's g you have to annotate, since it's g that's being used at a recursive type
04:50:01 <quicksil1er> dolio: y and f both have well behaved types
04:50:08 <dolio> Yeah.
04:50:18 <quicksil1er> pejo: yes
04:50:28 <dolio> But, for instance, in (\f -> f f), you don't annotate f.
04:50:58 <quicksil1er> dolio: I could have, though
04:51:12 <SamB_XP_> quicksil1er: oh really?
04:56:27 <goltrpoat> bedtime.
05:07:36 <quicksil1er> dolio: bah, I'm sure it's possible but my brain is full and I have work to do
05:07:50 <quicksil1er> dolio: there was an interesting related thread on haskell 2 weeks back
05:08:10 <dolio> :) I was trying, too, but I got complaints about not being able to instantiate some variables to concrete types or something.
05:08:46 <dolio> Don't worry about it.
05:08:53 <SamB_XP_> why does "haskell 2" not fill me with the same feeling of doom and gloom as "Python 3000"
05:10:00 <SamB_XP_> perhaps related to the fact that I know haskell is unlikely to ever be without lambdas ;-)
05:10:11 <Lor> Wait for another 2998 iterations and we'll see then.
05:10:52 <SamB_XP_> Lor: I think python 3000 is like simcity 3000 or something.
05:11:07 <dolio> Sim City 3000 was good, though.
05:11:15 <SamB_XP_> other than that!
05:11:22 <dolio> :)
05:11:31 <SamB_XP_> I meant namewise
05:12:21 * SamB_XP_ wishes for a list on which to write shopping items...
05:13:01 <SamB_XP_> interesting how they decided to call the next one "simcity 4"
05:14:53 <quicksil1er> haskell 3000, with monadic arcologies?
05:15:18 <SamB_XP_> would these monadic arcologies launch into space?
05:15:42 <Botje> each arcology would receive a portion of SPJ's cremated remains
05:15:56 <SamB_XP_> hmm. fictional cremated remains?
05:15:58 <Botje> they would fight massive wars to retrieve the others
05:16:08 <Botje> ehh, sure. fictional :)
05:16:29 <SamB_XP_> or are you saying this would be happening in 993 years?
05:16:49 <pixel> can't find a function doing same as "abcd".find("bc") in python (or index in C)
05:17:09 <Botje> indexOf, perhaps?
05:17:12 <earthy> @type indexOf
05:17:14 <lambdabot> Not in scope: `indexOf'
05:17:18 <SamB_XP_> @hoogle [a]->[a]->Int
05:17:19 <lambdabot> No matches, try a more general search
05:17:41 <quicksil1er> isPrefixOf, possibly
05:17:49 <earthy> nope
05:17:53 <quicksil1er> > "bc" `isInfixOf` "abcd"
05:17:55 <lambdabot>  True
05:17:56 <allbery_b> you could write one with isPrefixOf
05:18:00 <SamB_XP_> @hoogle findFirst
05:18:00 <lambdabot> System.Win32.File.findFirstChangeNotification :: String -> Bool -> FileNotificationFlag -> IO HANDLE
05:18:01 <lambdabot> System.Win32.File.c_FindFirstChangeNotification :: LPCTSTR -> Bool -> FileNotificationFlag -> IO HANDLE
05:18:04 <allbery_b> there's no standard one though
05:18:34 <SamB_XP_> @hoogle lookupBy
05:18:35 <lambdabot> No matches found
05:19:10 <quicksil1er> > findIndex ("bc" `isPrefixOf`) (tails "abcd")
05:19:12 <lambdabot>  Just 1
05:19:14 <quicksil1er> ta-da!
05:19:18 <Botje> > let heh
05:19:19 <lambdabot>  Parse error
05:19:33 <SamB_XP_> ooooooh
05:19:36 <quicksil1er> pixel: did you see that?
05:19:43 <SamB_XP_> that is much shorter than what I was going to find...
05:19:49 <SamB_XP_> @type findIndex
05:19:52 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
05:19:54 <pixel> quicksil1er: nice one, thanks
05:20:05 <SamB_XP_> nice.
05:20:14 * allbery_b always forgets about tails...
05:20:16 * SamB_XP_ should have thought of that idea, though
05:20:24 <SamB_XP_> I was going to use tails
05:20:41 <SamB_XP_> but for some reason I was thinking I had to zip it with [0..]
05:20:42 <quicksil1er> > findIndices ("bc" `isPrefixOf`) (tails "abcd lkjhlkj ebcd")
05:20:44 <lambdabot>  [1,14]
05:20:50 <allbery_b> I was starting to test a solution but as usual forgot about tail so was writing it inline :/
05:20:53 <allbery_b> durrr
05:20:55 <quicksil1er> if it might occur more than once
05:21:06 <allbery_b> er, tails
05:21:13 <SamB_XP_> quicksil1er: I don't think the python way does that ;-)
05:21:54 <quicksil1er> tails is awesome because it *looks* (to someone from a strict evaluation background) like a stupidly expensive thing to calculate but because of laziness and tail-sharing it isn't at all
05:22:35 <SamB_XP_> quicksil1er: well, it does require the list to exist
05:22:43 <SamB_XP_> I think
05:22:53 <SamB_XP_> ... yeah, I'm pretty sure it does ;-)
05:22:54 <haraldk> :t tails
05:22:56 <lambdabot> forall a. [a] -> [[a]]
05:23:09 <dolio> @src tails
05:23:10 <lambdabot> tails []         = [[]]
05:23:10 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
05:23:35 <qwr> > take 0 (tails undefined)
05:23:37 <lambdabot>  Undefined
05:24:06 <haraldk> > take 1237126387126387126318723618723618345345 [1..]
05:24:08 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
05:24:12 <Botje> > tail []
05:24:14 <lambdabot>  Exception: Prelude.tail: empty list
05:24:17 <haraldk> what?
05:24:23 <haraldk> > take 1237126387126387126318723618723618345345345345345345342423413232 [1..]
05:24:25 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
05:24:26 <quicksil1er> SamB_XP_: well yes, but tails written naively in python or perl, say, would quadratic-ise your list
05:24:40 <quicksil1er> SamB_XP_: it would build n^2 / 2 cells for all the tailses
05:24:41 <SamB_XP_> quicksil1er: quite so
05:24:48 <quicksil1er> SamB_XP_: that's the only point I was trying to make
05:25:19 <qwr> > take 0 undefined
05:25:20 <SamB_XP_> the point I'm making is that, in Haskell, it builds n cells ;-)
05:25:21 <lambdabot>  Undefined
05:25:24 <haraldk> :t take
05:25:27 <lambdabot> forall a. Int -> [a] -> [a]
05:25:46 <haraldk> take takes an Int
05:25:47 <SamB_XP_> (unless the list is already built)
05:26:04 <haraldk> and I could have sworn i got a weird result trying that in ghci
05:26:28 <ToRA> @src take
05:26:29 <lambdabot> take n _      | n <= 0 =  []
05:26:29 <SamB_XP_> but, I mean, unlike map, it can't be made to build no cells
05:26:29 <lambdabot> take _ []              =  []
05:26:29 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
05:26:34 <haraldk> namely take (some huge number) [1..] ----> []
05:26:48 <dolio> > 1237126387126387126318723618723618345345345345345345342423413232 :: Int
05:26:50 <lambdabot>  408924656
05:27:06 <dolio> Maybe you picked something equivalent to 0.
05:27:14 <haraldk> or to something negative...
05:27:27 <haraldk> > 312312312312312312 :: Int
05:27:29 <lambdabot>  -1302646280
05:27:37 <dolio> Yeah, that'd do it, too.
05:27:37 <haraldk> > take 312312312312312312 [1..]
05:27:40 <lambdabot>  []
05:27:49 <haraldk> an explanation at last :-)
05:27:55 <ToRA> anyone know why lb thinks take 0 undefined is undefined?
05:28:12 <quicksil1er> SamB_XP_: erm, it's exactly like map
05:28:23 <SamB_XP_> quicksil1er: not true!
05:28:25 <quicksil1er> SamB_XP_: it builds no cells if it's given a good producer
05:28:38 <SamB_XP_> unpossible
05:28:38 <haraldk> > take 0 undefined
05:28:40 <lambdabot>  Undefined
05:28:45 <haraldk> strange!
05:28:54 <rahikkala> > take undefined []
05:28:55 <quicksil1er> because it is
05:28:56 <lambdabot>  Undefined
05:29:07 <dolio> Not according to the code listing.
05:29:10 <haraldk> ghci gives [] for "take 0 undefined"
05:29:30 <quicksil1er> oh, oops
05:29:34 <quicksil1er> missed the first clause :)
05:29:38 <quicksil1er> SamB_XP_'s comment split it up
05:29:47 <dolio> :)
05:29:59 <quicksil1er> is it an accidental side-effect of the undefined-hack to make undefined showable?
05:30:40 <ToRA> > (take 0 undefined) :: [Int]
05:30:41 <lambdabot>  Undefined
05:31:26 <qwr> > take 0 (undefined :: [Int])
05:31:27 <lambdabot>  Undefined
05:31:56 <SamB> does stream fusion do that?
05:32:33 <quicksil1er> don't think LB does stream fusion...
05:32:52 <SamB> point
05:33:38 <ToRA> > take 0 (error "smelly" :: [Int])
05:33:39 <lambdabot>  Exception: smelly
05:34:05 <Lemmih> ?src take
05:34:05 <lambdabot> take n _      | n <= 0 =  []
05:34:05 <lambdabot> take _ []              =  []
05:34:05 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
05:35:20 <ToRA> > let x = x in take 0 (x::[Int])
05:35:21 <lambdabot>  []
05:35:23 <ToRA> \o/
05:36:19 <quicksil1er> that's very off
05:36:20 <quicksil1er> odd
05:38:28 <haraldk> > take 5 "Dave Brubeck"
05:38:30 <lambdabot>  "Dave "
05:39:39 <haraldk> > map undefined []
05:39:40 <lambdabot>  []
05:39:57 <haraldk> filter undefined []
05:40:07 <haraldk> > filter undefined []
05:40:09 <lambdabot>  []
05:40:12 <SamB_XP_> quicksil1er: huh. the tails in Data.List.Stream isn't fused at all yet!
05:41:16 <haraldk> > drop undefined []
05:41:18 <lambdabot>  Undefined
05:41:29 <haraldk> > drop 0 undefined
05:41:30 <lambdabot>  Undefined
05:41:44 <haraldk> well, that was expected I suppose :-)
05:42:04 <haraldk> @src drop
05:42:05 <lambdabot> drop n xs     | n <= 0 =  xs
05:42:05 <lambdabot> drop _ []              =  []
05:42:05 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
05:43:20 <haraldk> a lot of you with chalmers adresses I see :-)
05:44:40 <vali> hmm, is there a modulus operator in Haskell?
05:45:01 <ToRA> > 3 `mod` 2
05:45:02 <lambdabot>  1
05:45:11 <haraldk> :t rem
05:45:12 <vali> ToRA: thank you
05:45:14 <lambdabot> forall a. (Integral a) => a -> a -> a
05:45:33 <haraldk> > 3 `rem` -2
05:45:35 <lambdabot>      precedence parsing error
05:45:35 <lambdabot>         cannot mix `rem' [infixl 7] and prefix ...
05:45:42 <haraldk> > 3 `rem` (-2)
05:45:44 <lambdabot>  1
05:45:54 <quicksil1er> > 3 `mod` (-2)
05:45:55 <lambdabot>  -1
05:46:02 <haraldk> > (-3) `rem` 2
05:46:04 <lambdabot>  -1
05:46:38 <haraldk> > (-3) `mod` 2
05:46:40 <lambdabot>  1
05:47:17 <vali> > mod 30 4
05:47:19 <lambdabot>  2
05:47:33 <doserj> 'rem' belongs to 'quot', and 'mod' belongs to 'div'
05:47:51 <vali> hmm, why 2? the answer is 7.5... is the remaining 0.5 = 2/4 or something?
05:48:15 <quicksil1er> that's one way of looking at it
05:48:29 <quicksil1er> I'd say, 30 divided by 7 is 4, with 2 left over
05:48:31 <doserj> vali: 30 == 7*4 + 2
05:48:44 <vali> aah
05:48:54 <haraldk> mod 3 4
05:48:56 <haraldk> > mod 3 4
05:48:58 <lambdabot>  3
05:49:01 <haraldk> > mod 4 4
05:49:02 <lambdabot>  0
05:49:05 <haraldk> > mod 5 4
05:49:07 <lambdabot>  1
05:49:13 <[sid]> are there any large databases of commonly used haskell functions available online anywhere?
05:49:22 <haraldk> hoogle?
05:49:25 <ToRA> @where hoogle
05:49:26 <lambdabot> http://www.haskell.org/hoogle
05:49:35 <ToRA> @where Prelude
05:49:36 <lambdabot> I know nothing about prelude.
05:49:38 <haraldk> @hoogle rem
05:49:40 <lambdabot> Prelude.rem :: Integral a => a -> a -> a
05:49:40 <lambdabot> Directory.removeDirectory :: FilePath -> IO ()
05:49:40 <lambdabot> Directory.removeFile :: FilePath -> IO ()
05:49:40 <[sid]> nice, ta
05:50:23 <haraldk> I hear there's an offline version of hoogle avaliable now
05:52:48 <ndm> haraldk: i think i broke it, as it happens
05:53:02 * ndm learns an important lesson about branching and time management
05:53:06 <quicksil1er> n
05:53:12 <quicksil1er> n. d. 'The Breaker' m.
05:53:18 <haraldk> wish I had the courage to break things ;-)
05:53:42 <haraldk> like yi's nano binding
05:54:01 <haraldk> return doesn't work as in nano, which makes it a _little_ useless
05:54:12 <ndm> @seen joelr1
05:54:13 <lambdabot> joelr1 is in #haskell. I last heard joelr1 speak 1h 33m 1s ago.
05:54:25 <joelr1> ndm: hi neil
05:54:32 <haraldk> it was easy to fix, but I'm not sure I want to send the patch back, i might have changed something else
05:54:32 <ndm> haraldk: i wish i didn't break applications which had massive numbers of users :)
05:54:39 <ndm> joelr1: can you hpaste your syntax tree
05:54:47 <joelr1> ndm: the whole thing?!
05:54:57 <ndm> joelr1: i meant the data type that describes it
05:55:15 <ndm> joelr1: then a short overview of what you mean by "strip positions" - i think Play may do it for you with no new instances
05:55:26 <haraldk> nano mode I mean of course
05:55:45 <joelr1> ndm: i'd rather not. although i can send it to you in confidence that you won't share it :) except with stefan of course. hang on.
05:56:09 <ndm> joelr1: thats fine too - just any way of showing it to me
05:56:36 <ndm> joelr1: and feel free to delete some constructors if they are similar to others, or some data types that aren't that interesting to the problem
05:56:44 <ndm> i don't want to run the code, just see the position structure etc
05:56:50 <haraldk> can i rollback a single file with darcs?
05:56:59 <vali> how can i make a list with all the numbers from 1 to 1000?
05:57:08 <doserj> > [1..1000]
05:57:09 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
05:57:16 <joelr1> ndm: one sec
05:57:17 <vali> doserj: ah, thank you
05:57:47 <joelr1> ndm: catch!
05:57:49 <LeCamarade> vali: [1 ..]
05:58:05 <LeCamarade> > take 1000 [1 ..]
05:58:07 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
05:58:21 <vali> LeCamarade: aah, i se
05:58:51 <LeCamarade> vali: Yeah, no need to limit to 1000 when you can go to infinity. :oD
05:58:57 <ndm> joelr1: caught, have you seen Play? or even SYB for this one?
05:58:59 <vali> LeCamarade: good thinking
05:59:10 <joelr1> ndm: no
05:59:15 <joelr1> ndm: not recently anyway
05:59:19 <ndm> joelr1: everywhere (mkT $ \(TokenPos a _) -> a)
05:59:23 <ndm> and you're done!
05:59:40 <joelr1> ndm: ugh... is that part of Play? Syb?
05:59:43 <ndm> joelr1: add deriving (Data, Typeable) to everyone
05:59:57 <ndm> joelr1: thats part of SYB, the Play is equally short
06:00:05 <joelr1> ndm: and that's it?! including lists?
06:00:20 <joelr1> ndm: i'm not familiar with play.
06:00:21 <ndm> actually: everywhere (mkT f), where f (TokenPos a _) = a; f x = x
06:00:33 <ndm> joelr1: thats in SYB, Play is equally short - there will be a paper on it shortly
06:00:43 <ndm> if you're going for production use, i'd recommend SYB for now
06:00:50 <joelr1> ndm: do i need to include any  options for ghc?
06:01:15 <ndm> joelr1: -fglasogow-exts, import Data.Generics, deriving (Data, Typeable) on all data structures
06:02:29 <joelr1> ndm: give me a second to scrap my boilerplate :D
06:02:31 <joelr1> code
06:02:33 <ndm> in Play you'd write the same thing, but you'd leave out the mkT, and it wouldn't require rank-2 types - but for your purposes thats probably irrelevant
06:02:44 <ndm> joelr1: read the first SYB paper, it will save you time if you have an AST that big :)
06:02:50 <ivanm> hey, I'm doing up my own haskell version of the perl "this t-shirt is a munition" shirts
06:02:51 <ivanm> here is the design I'm thinking of for the back: http://omploader.org/file/shirt%20back.png
06:02:55 <ivanm> what do you all think?
06:03:05 <joelr1> ndm: changing my code... then will ask you about part 2 of my question
06:03:18 <haraldk> can anyone tell me how I extract a bundle from darcs without mailing it straight away?
06:03:33 <ndm> joelr1: cool cool
06:03:41 <ndm> haraldk: darcs send -o filename
06:04:22 <ndm> ivanm: why the john launchbury?
06:04:28 <haraldk> thanks, ndm.
06:04:39 <ivanm> ndm: because that's the whole program...
06:04:53 <ivanm> dons gave me the link for that, and john launchbury is presumably the guy who wrote it
06:06:09 <joelr1> ndm: is that a comma before where?
06:06:14 <joelr1> @google SYB
06:06:16 <lambdabot> http://www.syb.com/
06:06:16 <lambdabot> Title: Stock Yards Bank & Trust Company
06:06:55 <joelr1> ndm: i have something like 5 papers on SYB :)
06:06:55 <vali> are there any API docs for haskell? i would like to read about "filter"
06:06:56 <ivanm> ndm: the "with unknown types" bit was my feeble attempt at combining the concept of any unknown type of munition with the fact that the functions there aren't typed
06:07:27 <ndm> joelr1: only read the first one :)
06:07:34 <qwr> ?doc filter
06:07:35 <lambdabot> filter not available
06:07:39 <ndm> vali: go to hoogle, type in filter
06:07:42 <ndm> @where hoogle
06:07:43 <lambdabot> http://www.haskell.org/hoogle
06:07:43 <qwr> ?doc Data.List.filter
06:07:44 <lambdabot> Data.List.filter not available
06:07:48 <joelr1> ndm: the "examined" paper?
06:07:48 <qwr> ?doc Data.List
06:07:49 <vali> ndm: oh, thanks!
06:07:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
06:07:53 <ndm> joelr1: the first one
06:08:04 <ndm> ivanm: do you really need the Haskell 1.3 compatability bits in there?
06:08:12 <joelr1> ndm: Scrap Your Boilerplate: A Practical Design Pattern for Generic Programming?
06:08:18 <ndm> joelr1:
06:08:22 <ndm> joelr1: yes, i think
06:08:41 <ndm> ivanm: and concat.map == concatMap - its really old code
06:09:28 <ivanm> ndm: I didn't touch the code...
06:10:16 <ivanm> dons: took it from here: http://www.cse.unsw.edu.au/~dons/code/nobench/imaginary/jl_rsa/jl_rsa.hs
06:10:17 <lambdabot> http://tinyurl.com/2yakxj
06:12:25 <syntaxfree> @get-shapr
06:12:26 <lambdabot> shapr!!
06:12:56 <ivanm> lol
06:13:04 <joelr1> ndm: ran into trouble with SourcePos. the constructor is not exported from Parsec. how do I go about deriving that? ghc complains that there's no Data instance for it which is true
06:13:32 <joelr1> ndm: fact is that i don't even need this particular bit since I'm skipping that constructor
06:13:58 <ndm> joelr1: you don't want to go inside it, so instance Data SourcePos where gfoldl r k x = r x (i think)
06:14:18 <joelr1> ndm: aha!
06:15:13 <joelr1> ndm: what about Typeable?
06:15:16 <joelr1> ndm: same thing?
06:15:36 <ndm> joelr1: yep, look at how --derive Typeable works and copy something similar, Typeable is easy enough to do
06:15:49 <LeCamarade> @quote higher level
06:15:49 <lambdabot> No quotes for this person. Just what do you think you're doing Dave?
06:16:15 <syntaxfree> @quote
06:16:16 <lambdabot> fsbot says: English -> English: no matching translation services found.
06:16:21 <joelr1> ndm: how do i look at how --derive Typeable works? /silly question, i know/
06:16:36 <syntaxfree> @quote drive
06:16:37 <lambdabot> dons says: keroppi: i was thinking of a similar thing recently, on a bus travelling between the hotel and the google summer of code summit, sitting next to guys from apache, python, freebsd, netbsd,
06:16:37 <lambdabot> perl, gentoo... the end of open source was a drunk driver away, with only php goons left to run the show
06:17:13 <LeCamarade> :oD
06:17:32 <ndm> joelr1: runhaskell Derive.hs Example.hs -n --derive=Typeable
06:17:49 <joelr1> ndm: doing
06:18:52 <ndm> joelr1: i can't remember what they look like, but its pretty easy - only a couple of lines at most
06:19:15 <joelr1> ndm: hmm... runhaskell doesn't recognize the cmdline options
06:19:21 <joelr1> ndm: are you using 6.7?
06:19:29 <ndm> joelr1: 6.6, works fine for me...
06:19:46 <ddarius> @quote higher.level
06:19:47 <lambdabot> No quotes match. Just what do you think you're doing Dave?
06:19:48 <ndm> joelr1: is that in the root of the derive repo?
06:19:56 <syntaxfree> @quote derive
06:19:57 <lambdabot> ghc says: You need -fglasgow-exts to derive an instance for this class
06:20:00 <joelr1> ndm: yes, it is
06:20:03 <joelr1> unrecognized option `-n'
06:20:03 <joelr1> unrecognized option `--derive=Typeable'
06:20:10 <syntaxfree> @quote typeable
06:20:10 <lambdabot> LoganCapaldo says: <sorear> I am not having any luck converting Chris Kuklewicz :( <LoganCapaldo> Does he implement Typeable?
06:20:33 <vali> filter :: (a -> Bool) -> [a] -> [a] ... hmm this means that filter takes an argument (a -> Bool) and [a] and then returns [a]? and if that's right, what kind of argument is (a -> Bool)?
06:21:00 <quicksil1er> vali: it's a function which takes as and returns Bools
06:21:13 <ndm> joelr1: wah? i don't understand... - that command line exactly as above gives those errors?
06:21:19 <ddarius> > filter (<10) [1..]
06:21:23 <joelr1> ndm: yep
06:21:23 <lambdabot> Terminated
06:21:35 <ndm> joelr1: when did you last pull?
06:21:52 <[sid]> http://www.youngteam.eu/bst.txt
06:21:52 <[sid]>  and feel free to delete some constructors if they are similar to others, or so
06:21:54 <joelr1> ndm: i don't pull, i have the ghc from macports
06:21:58 <vali> quicksil1er: hmm, doesn't whatever the function returns come last in the list of -> ?
06:21:58 <joelr1> ghc Derive.hs examples/Example.hs -n --derive=Typeable
06:21:58 <joelr1> ghc-6.6: unrecognised flags: --derive=Typeable
06:22:00 <[sid]> oops
06:22:00 <[sid]> ERROR file:.\ex2.txt:88 - Syntax error in declaration (unexpected `}', possibly due to bad layout)
06:22:07 <LeCamarade> vali: It is a function that, when given a member of the list, will return a Bool to say whether we should keep it or not.
06:22:15 <ndm> joelr1: oh, you'll need to have a copy of derive from the darcs first, to get it working
06:22:35 <ndm> joelr1: puls runhaskell, not ghc - plus no examples/ directory needed
06:22:41 <LeCamarade> > filter even [1 .. 10]
06:22:42 <ndm> runhaskell /= ghc
06:22:43 <lambdabot>  [2,4,6,8,10]
06:22:46 <quicksil1er> vali: you misunderstand me
06:22:50 <LeCamarade> vali: Seen?
06:22:58 <quicksil1er> vali: I was answering your question 'what kind of argument is (a -> Bool)'
06:23:01 <joelr1> ndm: i have some sort of a derive
06:23:03 <joelr1> derive
06:23:03 <joelr1> no files specified
06:23:03 <joelr1> Usage: derive [OPTION...] files...
06:23:09 <vali> quicksil1er: oh
06:23:15 <quicksil1er> vali: the argument is a function which takes as and returns Bools
06:23:19 <LeCamarade> vali: even takes a number and says if it is even. If it is even, we keep it.
06:23:29 <[sid]> can anyone see why i'm getting the following error here ( http://www.youngteam.eu/bst.txt ) : ERROR file:.\ex2.txt:88 - Syntax error in declaration (unexpected `}', possibly due to bad layout)
06:23:35 <vali> LeCamarade: aah, hmm. i think i know what it does now, but i am trying to understand that notation with the ->
06:23:36 <ndm> joelr1: just do "runhaskell Derive.hs Example.hs -n --derive=Typeable"
06:23:43 <ndm> not ghc, but runhaskell
06:23:56 <quicksil1er> vali: filter takes two arguments, the first is a function and the second is a list. The function that is its first argument must take 'a's and return Bools
06:24:18 <LeCamarade> a -> Bool means `takes a value and returns either True of False´. Any value. See ...
06:25:01 <LeCamarade> In short, if a function takes one arg and returns a Bool, it qualifies.
06:25:23 <joelr1> ndm: my derive doesn't take -n :( and --derive :( i must have an old version or something
06:25:27 <quicksil1er> LeCamarade: in isolation that would be true. but this 'a' is bound at a higher level
06:25:36 <quicksil1er> LeCamarade: it must be the same 'a' as the list given
06:26:33 <vali> aah, hmm so when the argument is enclosed in () it means it's a function argument... oh wait, a function is a number. i think i get it. filter takes two arguments. the first is a function that takes a and says True/False and the second it takes is [a] and then it returns a new [a]?
06:26:56 <quicksil1er> vali: I agree with your final sentence
06:27:04 <quicksil1er> vali: I don't know what you mean by "a function is a number"
06:27:08 <LeCamarade> quicksilver: Yes. I mean in isolation. I used to have trouble with answers that tried to be theoretically correct, when I was starting out, though. So I avoid passing QuickTest. :oD
06:27:13 <vali> quicksil1er: hehe, thank you. that is the essence of it. good
06:27:20 <vali> quicksil1er: don't mind the first part of what i said
06:27:32 <joelr1> ndm: would you be kind enough to paste the output from your derive?
06:27:38 <quicksil1er> vali: for example isSpace is a function of type (Char -> Bool)
06:27:44 <LeCamarade> :t even
06:27:47 <lambdabot> forall a. (Integral a) => a -> Bool
06:27:56 <quicksil1er> > filter isSpace "the quick brown fox"
06:27:58 <lambdabot>  "   "
06:28:05 <LeCamarade> vali: See the last part of that test for even's type?
06:28:08 <ndm> joelr1: my derive copy seems to be going slightly crazy - it has patches i know aren't in teh tree, and its refusing to pull new patches in...
06:28:15 <LeCamarade> @src even
06:28:15 <quicksil1er> vali: not . isSpace is another function of type char->bool
06:28:15 <lambdabot> even n = n `rem` 2 == 0
06:28:21 <quicksil1er> > filter (not.isSpace) "the quick brown fox"
06:28:23 <lambdabot>  "thequickbrownfox"
06:28:24 <ndm> joelr1: i would have pasted them by now if it wasn't going crazy - give me a few mins to do a fresh pull
06:28:30 <hpaste>  mdmkolbe-work pasted "ghc build fails (missing OpenAL?)" at http://hpaste.org/1442
06:28:40 <vali> i see. thank you! i understand now
06:33:47 <ndm> weird, my drive has mounted itself read only (i think), and is currently going totally crazy
06:33:48 <qwr> vali: (here is something) doesn't mean anything other, than telling to parser that here is something is one expression
06:34:26 <ndm> @hpaste
06:34:27 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:34:53 <hpaste>  ndm pasted "joelr1, Typeable instances" at http://hpaste.org/1443
06:36:03 <quicksil1er> qwr: these weren't actually expressions, they were types :) although it's analogous
06:36:08 <joelr1> ndm: thanks, let me try...
06:36:34 * ndm reboots, back in half an hour...
06:38:21 <dylan> that's a long reboot.
06:40:42 <LeCamarade> 30-minute reboot? Wow.
06:41:46 <igli> lol
06:41:50 <igli> must be doze
06:42:11 <igli> <ndm> weird, my drive has mounted itself read only (i think), and is currently going totally crazy # definitely
06:43:53 <osfameron> nope, that happened to me on a linux ext3 external drive too
06:44:46 <osfameron> admittedly because it was a piece of crap Porsche LaCie that had got corrupted due to the lead into the power supply falling out (because it was too short and didn't fit properly)
06:45:34 <igli> lmao
06:45:50 <igli> e2fsck ffs
06:45:59 <quicksil1er> dons: bah, the problem with weekly news is there is too much interesting stuff
06:46:04 <quicksil1er> dons: I can't read it in a lunchbreak :P
06:47:03 <joelr1> anybody understands gfoldl?
06:47:33 <quicksil1er> :t gfoldl
06:47:35 <lambdabot> forall (c :: * -> *) a. (Data a) => (forall a1 b. (Data a1) => c (a1 -> b) -> a1 -> c b) -> (forall g. g -> c g) -> a -> c a
06:47:53 <quicksil1er> mostly people whose name is Simon, I suspect
06:47:53 <joelr1> instance Data SourcePos where gfoldl r k x = r x
06:48:00 <LeCamarade> @where gfoldl
06:48:00 <quicksil1er> that's a distinctly Simonic type
06:48:00 <lambdabot> I know nothing about gfoldl.
06:48:11 <quicksil1er> LeCamarade: it's Data.Generics, aka scrap your boilerplate
06:48:13 <quicksil1er> I think
06:48:14 <joelr1> this doesn't seem to work. my intent is to "skip over" SourcePos since the constructor for it is not exported
06:48:29 <LeCamarade> quicksil1er: Hmm ... quite an Oleg type, no?
06:48:39 <LeCamarade> @quote oleg
06:48:40 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
06:48:41 <joelr1> @tell ndm instance Data SourcePos where gfoldl r k x = r x doesn't seem to work :-(
06:48:41 <lambdabot> Consider it noted.
06:48:50 <quicksil1er> LeCamarade: no, it doesn't have enough type classes in to be olegic
06:49:11 <LeCamarade> quicksil1er: :oD
06:49:39 <Syzygy-> Is it still an N log N solution if the compilation takes N! time? :P
06:49:44 <LeCamarade> I wouldn't want to be too close to Oleg when he is in his element ... :oD
06:50:03 <dolio> joelr1: 'gfoldl r k x = k x' is more type appropriate.
06:50:21 <joelr1> dolio: let me try, thanks
06:50:23 <dolio> I think.
06:51:50 <mdmkolbe-work> joelr1: could you just use 'deriving (Typeable, Data)' (those might have changed their names in recent GHCs?
06:52:32 <joelr1> mdmkolbe-work: SourcePos is in some other library
06:52:42 <joelr1> mdmkolbe-work: so i can't
06:53:48 <mdmkolbe-work> joelr1: how much do you already know about gfoldl?  do you already understand the purpose of the arguments to gfoldl?  what does the declaration of SourcePose look like?
06:54:36 <joelr1> mdmkolbe-work: i know nothing about gfoldl apart from ndm saying i need it to create an instance of Data
06:55:23 <joelr1> mdmkolbe-work: SourcePos is in Parsec
06:55:27 <mdmkolbe-work> joelr1: 'gfoldl r k (Foo a b)' should do the equivalent of '(k Foo) `r` a `r` b' for any functions r and k
06:55:47 <mdmkolbe-work> @info Parsec.SourcePos
06:55:48 <lambdabot> Parsec.SourcePos
06:57:03 <joelr1> looks like i also need gunfold, toConstr and dataTypeOf
06:58:15 <mdmkolbe-work> @src Data.Generics.Basics
06:58:16 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
06:58:51 <LeCamarade> Are comprehensions optimised (well, at least more than map)?
06:59:37 <mauke> s(skk)(skk) has the type "(b@(b -> a) -> a)"
07:00:14 <mdmkolbe-work> joelr1: hmm, since SourcePos is an opeque type I'm not sure you can make a proper Data instance.  What do you need the instance for?
07:00:50 <joelr1> mdmkolbe-work: without it the derive (Data, Typeable) doesn't work
07:01:19 <joelr1> mdmkolbe-work: i'm skipping over the constructor that has SourcePos but using derive for the overall data structure
07:01:38 <chessguy_work> 'morning
07:01:40 <joelr1> mdmkolbe-work: so i just need enough glue for derive to do ... something
07:01:46 <szabi> what does ':' mean here:
07:01:51 <szabi> data Edit = Add Pos Range
07:01:57 <szabi> f = (Add p r :)
07:01:59 <szabi> ?
07:02:36 <dolio> a:b means prepend a to the list b.
07:02:43 <Philippa> the same it usually does - it's cons, prepending an item to a list. That's a section you're looking at, so it's "prepend Add p r to a list"
07:03:17 <chessguy_work> @type (?Add ?p ?r :)
07:03:17 <szabi> ah, ok
07:03:19 <lambdabot> parse error on input `)'
07:03:45 <chessguy_work> darn :)
07:05:29 <LeCamarade> szabi: Try passing f an empty list, to get a good picture. f []
07:05:32 <mdmkolbe-work> joelr1: well you can do 'gfoldl r k x = error "fake gfoldl"' or 'gfoldl r k x = k x' (The later would be correct if SourcePos was an atomic value (like Int); I'm not sure if that is a fair assumption in this case.)
07:05:42 <roconnor> > 0x22A5
07:05:44 <lambdabot>  8869
07:06:10 <joelr1> mdmkolbe-work: the k x version seems to compile fine
07:06:48 <joelr1> mdmkolbe-work: source pos is actually SourcePos Int Int but, again, i'm not using it. i just need the dummy defs to make things go
07:07:29 <joelr1> mdmkolbe-work: and it now looks like I scraped 2-3 pages of boilerplate code with SYB and replaced all that with a simple
07:07:30 <joelr1> mdmkolbe-work: strip = everywhere (mkT f)
07:07:30 <joelr1>     where f (TokenPos a _) = a
07:07:31 <joelr1>           f x = x
07:11:05 <kuribas> Where are the concrete instances for Graphs?
07:12:42 <mauke> has anyone written a type checker in the type system yet?
07:13:17 <dcnstrct> guys I'm trying to get ghc setup on a mac for the first time, I'm getting this error:  http://rafb.net/p/CJ3L2C34.html   Any ideas what to do ? Is this just a matter of adding something to my path ?
07:13:19 <lambdabot> Title: Nopaste - No description
07:14:50 <chessguy_work> surely f = (Add p r :) is an error?
07:15:28 <chessguy_work> well, i guess p and r could be constants
07:16:10 <chessguy_work> but even at that, shouldn't it be ((Add p r) :)
07:16:19 <doserj> dcnstrct: is this the same problem as in http://hackage.haskell.org/trac/ghc/ticket/1110 ?
07:16:20 <lambdabot> Title: #1110 (Setting PATH needed in Windows Vista) - GHC - Trac
07:16:56 * edwardk waves hello.
07:17:11 <chessguy_work> hi edwardk
07:17:36 <dcnstrct> doserj,  yea I think this is the problem.  I'll make sure that ghc/bin and ghc/gcc-lib find their way into my path
07:17:41 <dcnstrct> thanks for your help
07:18:48 <petekaz> @seen dons
07:18:49 <lambdabot> dons is in #haskell-soc and #haskell. I last heard dons speak 9h 43m 28s ago.
07:22:36 <ndm> joelr1: did you get the data instance working then?
07:22:51 <joelr1> ndm: yep, thanks!
07:23:13 <joelr1> ndm: syb saved me a couple of pages of code :) including some bugs that i introduced
07:23:30 <ndm> joelr1: cool, its handy :)
07:23:38 <LeCamarade> ndm: A 30-minute reboot must be a real problem. :oD
07:23:44 <joelr1> ndm: now i can proceed with type checking
07:23:48 <ndm> LeCamarade: i managed to not reboot in the end
07:23:55 <szabi> what's @ in a pattern: (Add x y@(Range y1 y2) : diff)
07:24:41 <LeCamarade> szabi: It's called an as pattern. You use it when you want both the pattern and the original. See ...
07:24:56 <dylan> x86 machines boot too slowly anyway
07:25:00 <hpaste>  tfc pasted "binary tree help" at http://hpaste.org/1444
07:25:06 <mauke> szabi: aliasing
07:25:15 <tfc> http://hpaste.org/1444
07:25:28 <tfc> help please :)
07:25:41 <mauke> > let xs@(x : _) = [1,2,3,4] in (xs, x)
07:25:43 <lambdabot>  ([1,2,3,4],1)
07:26:06 <mauke> tfc: that depends on your tree type
07:26:09 <LeCamarade> both a@(x:xs) = "The head of " ++ a ++ " is " ++ [x] ", and the tail is " ++ xs
07:26:15 <szabi> LeCamarade: so it's like (Add x (Range y1 y2) : diff) and then let y = Range y1 y2?
07:26:23 <szabi> LeCamarade: thanks
07:26:32 <LeCamarade> Run both with a string.
07:26:32 <tfc> yeah i dont know what tree type to give?
07:26:57 <tfc> Leaf a | Node (Tree a) a (Tree a)?
07:27:33 <LeCamarade> tfc: Watch ...
07:27:57 <mauke> tfc: data Tree a = Leaf a | Branch (Tree a) (Tree a)
07:27:58 <joelr1> ndm: i think the type checker is another candidate for SYB since i need to walk the tree again and focus on expressions
07:28:15 <tfc> what about empty nodes though?
07:28:18 <ndm> joelr1: probably, but type checkers usually require more boilerplate
07:28:20 <LeCamarade> tfc: Yeah, mauke got it.
07:28:23 <mauke> tfc: those don't exist
07:28:27 <joelr1> ndm: so it looks to me like another strip where the set of patterns is larger
07:28:45 <mauke> Maybe (Tree a) or Tree (Maybe a)
07:29:08 <tfc> so that particular tree would be?
07:29:41 <mauke> Branch (Leaf 4) (Branch (Leaf 2) (Leaf 1))
07:30:05 <tfc> ah ok
07:30:07 <tfc> i get it
07:30:10 <tfc> thanks :)
07:30:31 <chessguy_work> you can define a tree so that empty nodes exist
07:30:43 <tfc> how?
07:31:02 <chessguy_work> Data Tree a = Empty | Leaf a | Branch (Tree a) (Tree a)
07:31:08 <chessguy_work> (for example)
07:35:09 <dylan> why not Tree (Maybe a)?
07:36:59 <tfc> whats wrong with this?
07:37:00 <tfc> data Tree1 Int = Leaf Int | Branch (Tree Int) (Tree Int)
07:37:00 <tfc> tree1 :: Tree1
07:37:00 <tfc> tree1 = Branch (Leaf 4) (Branch (Leaf 2) (Leaf 1))
07:37:12 <tfc> getting "Illegal left hand side in data type declaration
07:37:44 <kpreid> tfc: the problem is the "Int" after Tree1.
07:37:46 <kpreid> tfc: remove it.
07:37:49 <tfc> k
07:38:11 <kpreid> only type variables need be on the left side
07:39:00 <tfc> "Illegal type "Tree1 Int" in constructor application
07:39:38 <tfc> data Tree1 = Leaf Int | Branch (Tree1 Int) (Tree1 Int)
07:39:39 <tfc> 	     deriving Show
07:39:39 <tfc> tree1 :: Tree1
07:39:39 <tfc> tree1 = Branch (Leaf 4) (Branch (Leaf 2) (Leaf 1))
07:39:49 <mauke> remove the other Ints
07:39:50 <mgoetze> tfc: you probably also want "Tree1" instead of "Tree" on the right hand side
07:40:04 <tfc> i do
07:42:51 <tfc> any ideas?
07:43:42 <dolio> You're trying to apply Tree1 to Int in the data definition. It should just be Tree1.
07:45:24 <tfc> awesome done
07:45:27 <tfc> cheers
07:55:57 <hpaste>  ozzi pasted "timsheet" at http://hpaste.org/1445
07:56:40 <ozzilee> Could someone help me out? I'm just learning Haskell and I'm not sure why the above code doesn't work when I try to do "map getHoursForDays days"
07:56:54 <ozzilee> *getHoursForDay
07:57:36 <dolio> getHoursForDay has type String -> IO Float
07:57:52 <dolio> So, when you map it across that list, the result will be [IO Float].
07:58:22 <joelr1> @hoogle Error
07:58:23 <lambdabot> Control.Monad.Error :: module
07:58:23 <lambdabot> Foreign.C.Error :: module
07:58:23 <lambdabot> Foreign.Marshal.Error :: module
07:58:30 <ozzilee> Ok, so I guess that explains why I get " No instance for (Show (IO Float))"
07:58:33 <joelr1> :t Error
07:58:35 <lambdabot> Not in scope: data constructor `Error'
07:58:36 <dolio> Which is a list of IO actions. If you want them to be performed, you're going to have to use sequence to turn it into 'IO [Float]' which can be run.
07:58:56 <LeCamarade> ozzilee: Yes. You are probably trying to print the result of the map, right?
07:59:33 <ozzilee> LeCamarade: Well, ghci is trying to print it I guess. In any case what I really want is [Float], I think
07:59:57 <LeCamarade> ozzilee: Try: sequence (map getHoursForDay days) >>= putStrLn . show
08:00:24 <LeCamarade> It will work, and then I'll explain why. Now, lemme go annotate your pasted code. If you will wait.
08:00:29 <dolio> And, actually the 'sequence (map ...)' combination is called mapM.
08:00:38 <ozzilee> Yep, works perfectly, thanks.
08:01:19 <joelr1> how can I combine a monad with Either where error is Left and right value is Right? i see that Either is a Functor but not a Monad
08:01:38 <dolio> Either is a monad, too.
08:01:45 <LeCamarade> ozzilee: Are you waiting for the annotations at hpaste?
08:01:55 <dolio> 'Error e => Either e' as the instances go.
08:02:00 <ozzilee> LeCamarade: yeah, I will, thanks.
08:02:23 <ozzilee> Still haven't gotten my head quite around monads, but I only started looking at haskell a couple days ago.
08:02:30 <joelr1> dolio: where is that defined? doesn't seem to be in the docs for Either
08:03:16 <dolio> Hmm...
08:03:33 <joelr1> dolio: Control.Monad.Error, i see
08:03:58 <quicksilver> > Right 4 >> Right 5 >> Right 6
08:03:59 <lambdabot>  Add a type signature
08:04:07 <quicksilver> > Right 4 >> Right 5 >> Right 6 :: (Either String Int)
08:04:09 <lambdabot>  Right 6
08:04:17 <quicksilver> > Left "Oh bother" >> Right 5 >> Right 6 :: (Either String Int)
08:04:19 <lambdabot>  Left "Oh bother"
08:04:24 <quicksilver> monad instance for either in action :)
08:04:39 <joelr1> cool
08:04:53 <quicksilver> the semantics is fail-at-first-Left
08:05:08 <quicksilver> so it's strictly analogous to Maybe, but you can 'annotate your Nothings'
08:05:14 <Syzygy-> Ah.
08:05:15 <joelr1> i'm thinking of implementing my type checker such that it either returns a type-enhanced syntax tree or the error with location
08:05:22 <Syzygy-> And so Left is the Nothing and Right is the value?
08:05:28 <quicksilver> Syzygy-: indeed
08:05:41 <Syzygy-> > liftM2 (+) (Right 4) (Right 7)
08:05:42 <lambdabot>  Add a type signature
08:05:44 <Botje> > Nothing >> Just "foo" >> Just "return value"
08:05:45 <quicksilver> :t maybe (Left "something went wrong") Right
08:05:47 <lambdabot>  Nothing
08:05:48 <lambdabot> forall a. Maybe a -> Either [Char] a
08:05:49 <Syzygy-> > liftM2 (+) (Right 4) (Right 7) :: Either String Int
08:05:51 <lambdabot>  Right 11
08:05:54 <quicksilver> is the embedding one way
08:06:02 <Syzygy-> > liftM2 (+) (Right 4) (Left "I don't want to be added") :: Either String Int
08:06:05 <lambdabot>  Left "I don't want to be added"
08:06:06 <quicksilver> :t either (const Nothing) (id)
08:06:08 <Syzygy-> :P
08:06:09 <lambdabot> forall a a1. Either a1 (Maybe a) -> Maybe a
08:06:14 <quicksilver> is the projection the other way
08:06:58 <ozzilee> LeCamarade: I'm stepping out for a few minutes, but I'll check out the paste when I get back. Thanks.
08:08:34 <dolio> :t either (const Nothing) (Just)
08:08:37 <lambdabot> forall a b. Either a b -> Maybe b
08:08:44 <LeCamarade> ozzilee: Okay.
08:08:45 <dolio> That's the right one.
08:08:47 <LeCamarade> w
08:08:49 <quicksilver> dolio: oops, yes :)
08:09:10 <quicksilver> Syzygy-: note that liftM2 is strict in side-effects, though
08:09:27 <quicksilver> > liftM2 const (Right 4) (Left "I should be ignored but I'm not")
08:09:29 <lambdabot>  Left "I should be ignored but I'm not"
08:10:17 <hpaste>  LeCamarade annotated "timsheet" with "(no title)" at http://hpaste.org/1445#a1
08:10:44 <LeCamarade> ozzilee: Your's was my biggest problem, too, when I was starting out with Haskell.
08:10:51 <dolio> > liftM2 const (+1) undefined 2
08:10:53 <lambdabot>  3
08:12:47 <Syzygy-> quicksilver: Is there something corresponding but non-strict?
08:12:57 <quicksilver> Syzygy-: no
08:13:15 <Syzygy-> Is there a good reason for it not to be?
08:13:17 <quicksilver> Syzygy-: it's not immediately clear that their can be, really
08:13:19 <Syzygy-> for there not to be
08:13:22 <Syzygy-> Ah.
08:13:47 <quicksilver> it varies on the monad, though
08:14:12 <dolio> liftM2 is non-strict in the reader monad, as above.
08:14:12 <quicksilver> as dolio points out, the e-> monad is side-effect free, so it doesn't apply there
08:15:06 <Syzygy-> Aren't [], Maybe a and Either a b  also side-effect free?
08:15:13 <Syzygy-> Or am I missing something vital about those?
08:17:25 <quicksilver> Syzygy-: yes
08:17:33 <quicksilver> Syzygy-: they're very side-effectful :)
08:17:55 <quicksilver> Syzygy-: in Maybe and Either the only possible side effect is to abort the computation early
08:18:03 <quicksilver> Syzygy-: but that's a pretty important one
08:18:26 <quicksilver> Syzygy-: in [], the side effect is to multiply into branched alternative computations
08:18:35 <int-e> Syzygy-: in all these three monads, liftM2 f a b is strict in a.
08:19:04 <quicksilver> > [1,2,3] >> ["foo"]
08:19:05 <lambdabot>  ["foo","foo","foo"]
08:19:17 <quicksilver> (in a side-effect-free monad, a >> b === b)
08:21:54 <chessguy_work> > Right '2' >> "foo"
08:21:55 <ozzilee> LeCamarade: Thanks, I'll dig into that. Hopefully once I get through the Monad section in YAHT I'll understand it better. For now, it's back to "real" work.
08:21:55 <lambdabot>  Couldn't match expected type `Either a' against inferred type `[]'
08:22:14 <quicksilver> > Right 2 >> Right "foo"
08:22:15 <lambdabot>  Add a type signature
08:22:30 <quicksilver> > Right 2 >> Right "foo" :: (Either String String)
08:22:32 <lambdabot>  Right "foo"
08:22:55 <chessguy_work> > Left 2 >> Right "foo" :: (Either String String)
08:22:56 <lambdabot>   add an instance declaration for (Num String)
08:23:06 <chessguy_work> > Left 2 >> Right "foo" :: (Either Num String)
08:23:07 <lambdabot>      Class `Num' used as a type
08:23:07 <lambdabot>     In the type `Num'
08:23:07 <lambdabot>     In the type `Either...
08:23:14 <chessguy_work> > Left 2 >> Right "foo" :: (Either Int String)
08:23:15 <lambdabot>   add an instance declaration for (Error Int)
08:23:15 <lambdabot>     In the expression: (Left 2)...
08:23:18 <chessguy_work> sigh
08:23:33 <ski> 'Error' is stupid, imo
08:23:35 <chessguy_work> > Left "2" >> Right "foo" :: (Either String String)
08:23:37 <lambdabot>  Left "2"
08:23:45 <int-e> ski: I agree
08:23:56 <chessguy_work> @src Error
08:23:57 <lambdabot> class Error a where
08:23:57 <lambdabot>     noMsg  :: a
08:23:57 <lambdabot>     strMsg :: String -> a
08:24:13 <int-e> or at least the Either a monad instance is bad
08:24:25 <ski> 'instance Monad (Either err)' with no restriction on 'err' is the obviously wanted instance
08:24:33 <ski> int-e : exactly
08:24:39 <quicksilver> the whole maybe - either - error - fail - monad concept loop is a bit unsatisfactory
08:25:03 <ski> 'fail' should be removed, merged with 'mzero', or moved into a subclass, imo
08:25:44 <quicksilver> make monaderror a subclass or monadzero with a default definition of mzero as 'fail "no message given"' ?
08:26:04 <quicksilver> or do I mean, monadstringerror..
08:26:16 <ski> 'MonadError String'
08:26:29 <int-e> I suppose people wanted to be able to write    do Just x <- foo; return y   in any monad.
08:27:03 <quicksilver> I think that's part of it, yes
08:28:35 <ski> hm, maybe the consistent thing to do in such case would be to disallow '<refutable pattern> = <expr>' bindings as well ?
08:28:40 <int-e> and that pattern match failure has two possible interpretations, sadly. a) it's a bug  b) it's a failed guard.
08:28:59 <ski> int-e : pattern guards ?
08:29:06 <int-e> no. monad guards
08:29:14 <int-e> @type guard
08:29:29 <lambdabot> thread killed
08:29:50 <dmhouse> ?botsnack
08:29:51 <lambdabot> :)
08:29:59 <LoganCapaldo> The guard commited sepukku?
08:29:59 <ski> guard :: MonadPlus a => Bool -> a ()
08:30:05 <dmhouse> ?src guard
08:30:06 <lambdabot> guard True  =  return ()
08:30:06 <lambdabot> guard False =  mzero
08:30:12 <ski> @type guard
08:30:25 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
08:31:26 <ski> int-e : are you suggesting rewriting refutable 'do'-bindings to use 'guard' ?
08:32:06 <int-e> ski: not really.
08:32:25 <chessguy_work> > (length . show) 2^(266666666)
08:32:30 <lambdabot>  1
08:32:32 <int-e> ski: in the list monad, pattern matches pretty much act in that way though.
08:32:35 <chessguy_work> where's that 1 coming from?
08:32:42 <dolio> :t length
08:32:46 <lambdabot> forall a. [a] -> Int
08:32:50 <int-e> chessguy_work: 1^266666666
08:33:23 <dmhouse> > (length $ show 1) ^ 2666666666
08:33:25 <lambdabot>  1
08:33:43 <dmhouse> > length . show $ 2^66666666
08:33:43 <chessguy_work> huh?
08:33:47 <lambdabot> Terminated
08:34:06 <dolio> It's not parsing how you think it is.
08:34:11 <joelr1> is there a way to create a monadic Either t1 t2 without resorting to Error?
08:34:21 <dmhouse> chessguy_work: operator precedence. Prefix application binds tighter than infix, so the (length . show) gets applied to the 2 before (^) does its stuff.
08:34:24 <joelr1> for example, I don't want to return Left String
08:34:32 <chessguy_work> ohhhhhh
08:34:34 <joelr1> i want a type of mine instead of String
08:34:40 <chessguy_work> > (length . show) $ 2^(266666666)
08:34:41 <dmhouse> joelr1: use MonadError.
08:34:44 <lambdabot> Terminated
08:34:47 <chessguy_work> gotcha
08:34:52 <int-e> joelr1: define your own   instance Monad (Either a)
08:34:52 <joelr1> dmhouse: thanks
08:35:03 <joelr1> @hoogle MonadError
08:35:04 <lambdabot> Control.Monad.Error.MonadError :: class Monad m => MonadError e m
08:35:29 <dmhouse> Err, or perhaps I'm thinking of something else.
08:35:42 <dmhouse> ?src instance Monad (Either e)
08:35:43 <lambdabot> Source not found. Maybe if you used more than just two fingers...
08:36:09 <ski> joelr1 : using a newtype, or a new 'Either'
08:36:16 <joelr1> dmhouse: i'm type checking a syntax tree and want to return either the tree or the position of an error
08:36:22 <joelr1> where the position is a type
08:36:24 <dmhouse> Isn't that parametised like instance Error e => Monad (Either e)?
08:36:41 <joelr1> class Monad m => MonadError e m | m -> e where
08:36:41 <dolio> MonadError doesn't even constrain e to being an instance of Error...
08:36:45 <dmhouse> So just declare an instance Error YourErrorType.
08:37:09 <dmhouse> instance (Error e) => Monad (Either e) where ...
08:37:09 <joelr1> dmhouse: you mean instance MonadError?
08:37:12 <dmhouse> That's from the source.
08:37:12 <joelr1> oh
08:37:16 <dmhouse> joelr1: no, an instance Error.
08:37:18 <LeCamarade> Pray for me, lambdamen. My boss has pitted me against himself - him using C, me using Haskell. It's a heavily-data-intensive app. Lots of compression happens. And I'm not dons. And he said if he wins, no more forgiving me when he catches me doing Haskell in office hours.
08:37:35 <Syzygy-> Oh dear.
08:37:39 <Syzygy-> Is this really a good idea?
08:37:48 <dmhouse> LeCamarade: who's claiming Haskell is faster than C?
08:37:51 * dmhouse looks around
08:38:08 <LeCamarade> dmhouse: Not faster. It's about who will get it done first.
08:38:12 <Syzygy-> Ah.
08:38:14 <Syzygy-> Right.
08:38:20 <Syzygy-> Yeah, that might be worth doing.
08:38:45 <chessguy_work> so what happens if you win?
08:38:48 <LeCamarade> Syzygy-: I though so. And I didn't have much choice, anyway.
08:39:22 <dmhouse> joelr1: MonadError is a typeclass for error monads in general (not necessarily based on Either) that gets you access to the throwError and catchError functions, just like MonadReader is a typeclass for reader monads in general (not necessarily based on pairs), and gets you access to ask etc.
08:39:29 <LeCamarade> chessguy_work: I dunno. Maybe then he'll consider it worth letting me do stuff in, which is what I want ...
08:40:04 <joelr1> dmhouse: i thought Error a always implied Either String a
08:40:11 <joelr1> dmhouse: so i
08:40:20 * LeCamarade sees the spec land in his INBOX. Oh, mon dieu. Restez avec moi, ce fois-ci.
08:40:32 <joelr1> dmhouse: so i'm not really grasping and instance declaration that you are suggesting
08:40:55 <dmhouse> joelr1: nope, Error is the typeclass for error types to be used with the Either monad. String is among them, but you can use a different type if you want.
08:41:10 * joelr1 is learning French by playing Call of Duty 3 
08:41:24 * dmhouse is learning French in a classroom :)
08:41:25 <joelr1> lots of boxes "everything in spanish!" were shipped to tenerife with the french disks inside
08:41:49 <dmhouse> joelr1: so if you want to use Either as an error monad, the type of your error has to be an instance of Error.
08:41:57 <dmhouse> (But it doesn't have to be String.)
08:42:02 <joelr1> dmhouse: so a here "class Error a where" is what exactly?
08:42:07 <chessguy_work> @instances-importing Error
08:42:07 * LeCamarade then wonders why #haskell-fr is so like empty ...
08:42:09 <lambdabot> IOError, [Char]
08:42:16 <joelr1> oh maybe i have it all reversed
08:42:17 <joelr1> darn
08:42:27 <chessguy_work> @hoogle IOError
08:42:28 <lambdabot> Prelude.IOError :: type IOError
08:42:28 <lambdabot> Prelude.ioError :: IOError -> IO a
08:42:28 <lambdabot> System.IO.Error.IOErrorType :: data IOErrorType
08:43:08 <dmhouse> joelr1: see http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Error.html
08:43:10 <lambdabot> http://tinyurl.com/sw72f
08:43:17 <joelr1> dmhouse: i'm looking at that page, thanks
08:43:27 <joelr1> dmhouse: so what am i really saying with this decl: instance (Error e) => Monad (Either (String, Pos)) where
08:43:48 <dmhouse> joelr1: no, that's not what you want.
08:43:55 <joelr1> dmhouse: or should i have said (Error (String, Pos) ...
08:43:56 <dmhouse> You don't declare an instance of Monad.
08:44:08 <dmhouse> joelr1: you want instance Error (String, Pos) where ...
08:44:42 <joelr1> dmhouse: ah, right but... what type would this return on success and what type on error?
08:46:09 <dmhouse> joelr1: if you had a function with type Either (String, Pos) a, it'd either return a 'Right (something of type a)' on success, or a 'Left (something of type (String, Pos))' on failure.
08:46:56 <joelr1> dmhouse: i guess i'm getting confused by not seeing that type 'a' anywhere
08:47:24 <dmhouse> joelr1: well, look at some instance declarations for Monad. None of them mention the a.
08:47:40 <dmhouse> instance Monad Maybe where ..., instance Monad [] where ..., instance Monad IO where ...
08:48:02 <joelr1> dmhouse: so then noMsg would return ("", Pos) and strMsg s = (s, Pos) right?
08:48:02 <dmhouse> Monads have to be parametrically polymorphic in their container type.
08:48:13 <joelr1> dmhouse: so much to learn. thank a lot
08:48:25 <dmhouse> (Which is e.g. why Set can't be a monad, it's only polymorphic in Ord types.)
08:48:29 <dmhouse> joelr1: something like that, yep.
08:48:50 <Philippa> dmhouse: more accurately, instances of Monad do
08:49:03 <dmhouse> Philippa: sorry, yeah.
08:49:04 <chessguy_work> dmhouse: didn't i just hear some complaining about that on one of the mailing lists?
08:49:17 <Philippa> Set's still as much a category-theoretic monad as Maybe is
08:50:03 <hpaste>  dmhouse pasted "Error typeclass example" at http://hpaste.org/1446
08:50:12 <dmhouse> Oh, he left. Great. :)
08:50:46 <dmhouse> ?tell joelr1 http://hpaste.org/1446 might help, was about it show it to you when you left. :)
08:50:46 <lambdabot> Consider it noted.
08:50:49 <chessguy_work> as i recall, there was even a proposal for how to change Monad (or add a new constructor class) to be able to handle the case where the types were constrained
08:51:24 <dmhouse> Philippa: I sometimes use a capital 'M' to distinguish between CT-monads and instances of the Monad class, but as that was at the beginning of a sentence I probably should've been clearer. :)
08:51:59 <dmhouse> And it should have been 'Set can't be a Monad', that was just sloppy.
08:52:15 <chessguy_work> dmhouse: i thought it was pretty clear what you meant
08:53:11 <Philippa> chessguy_work: subject to background. It's clear to you and I...
08:53:12 <chessguy_work> usually if you say "Monads..." in the context of haskell (as opposed to CT), it's pretty clear that you mean "Instances of Monad"
08:53:42 <Philippa> sure. What's less clear to those not in the know is whether there are monads expressible in haskell that aren't instances of Monad
08:53:55 <dylan> I wonder if you could have a subclass of Monad, OrdMonad, which required a to be instances of Ord, so you could have base a Set monad on that...
08:54:08 <dmhouse> dylan: of course, it just wouldn't be very useful.
08:54:28 <dylan> would >>, etc, work on OrdMonad?
08:54:31 <Philippa> you'd start by redefining Monad to be a two-parm class, with one of the parms being a
08:54:38 <chessguy_work> yeah, unless you want to rewrite all the monad functions to
08:54:40 <chessguy_work> o
08:54:48 <dylan> hmm..
08:55:01 <dmwit> I guess do notation wouldn't work quite right, huh.
08:55:05 <dmhouse> dylan: in theory your idea is quite simple.
08:55:05 <Philippa> well, you can define an ExtMonad class first, and have all instances of Monad be instances of ExtMonad
08:55:14 <Philippa> and then it'll more or less just work
08:55:20 <ski> 'ExtMonad' ?
08:55:29 <chessguy_work> Extended?
08:55:32 <dylan> ski: Extended Monad, I assume.
08:55:55 <Philippa> yeah, extended to cover all the other monads that the existing Monad class doesn't handle
08:55:59 <dylan> I'd called Gonad, but that's because I like puns.
08:55:59 <chessguy_work> so an Extended Monad would be a Monad which would allow a type class constraint on its parameter
08:56:12 <Philippa> so's to not screw over existing code that uses Monad as-is
08:56:24 <dmhouse> You just have 'class OrdMonad m where return :: Ord a => a -> m a; (>>=) :: Ord a => m a -> (a -> m b) -> m b', and an instance Monad m => OrdMonad m and instance OrdMonad Set
08:56:26 <dylan> *called = call it
08:57:02 <Philippa> dmhouse: that's insufficiently general, why only allow one new constraint?
08:57:05 <dmhouse> dylan: but it's not that useful, because everyone would have to switch to using OrdMonad to reap any benefits, and it's only a matter of time before someone comes up with a monad which isn't a Monad because it's polymorphic only over, say, Eq types.
08:57:11 <dmhouse> Philippa: exactly.
08:57:22 <ski> (dmhouse : nitpick .. monad( type constructor)s aren't parametrically polymorphic, they're just parametric)
08:57:22 <Philippa> so you use a second parameter to the class
08:57:35 <Philippa> which is the subcategory of haskell that it's a monad over
08:57:39 <dmhouse> So 'class Monad m a where ...'.
08:58:02 <dmhouse> Then you can have 'instance Monad Maybe a', etc., and 'instance Ord a => Monad Set a'.
08:58:07 <dmhouse> ski: what's the difference/
08:58:08 <ski> it think it would be more sane to have the second parameter be a *kind* and not a *type*
08:58:16 <Philippa> or "class ExtMonad m c where..., instance Monad m => instance ExtMonad m a"
08:58:29 <Philippa> ski: not in Haskell
08:58:44 <Philippa> in Haskell, it's a type, possibly polymorphic and qualified by a typeclass
08:59:12 <Philippa> and because there're MPTCs, that's actually more expressive than the obvious approach with kinds
09:01:18 <ski> dmhouse : 'data Maybe a = Nothing | Just a' could be thought of as something like 'Maybe :: * -> *; Maybe = \a -> data Nothing | Just a', i.e. it is a type function .. otoh polymorphism is things like 'catMaybes :: forall a :: *. [Maybe a] -> [a]' i.e the *'forall'* makes it (parametrically) polymorphic .. you can use parametric types without using polymorphism 'parse :: String -> Maybe Expr' .. however parametric types *enab
09:01:39 <Phas_> @paste
09:01:40 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:01:40 <campusblo> hello folks
09:02:12 <hpaste>  Phas pasted "Weird HAppS types" at http://hpaste.org/1447
09:02:20 <ski> Philippa : indeed, not in (current) Haskell .. (i just believe trying to use a type instead is wrong in any case)
09:02:28 <LeCamarade> campusblo: Ah. You're back.
09:02:31 <campusblo> im trying to remove the last element from a list. why does this not work
09:02:33 <campusblo> dequeBack :: [ a ] -> (a, [a])
09:02:33 <campusblo> dequeBack  (qs:q) = (q, [qs])
09:02:38 <dmhouse> ski: so 'parametric' applies to type functions, and 'parametrically polymorphic' to value functions?
09:02:44 <campusblo> yeh im back
09:02:49 <LeCamarade> campusblo: init does it.
09:02:57 <hpaste>  Phas annotated "Weird HAppS types" with "correct paste" at http://hpaste.org/1447#a1
09:02:58 <campusblo> will be working on my project all day today
09:02:58 <LeCamarade> > init [1 .. 10]
09:02:59 <dmhouse> campusblo: because qs:q means "bind qs to the first element and q to the tail of the list."
09:03:00 <lambdabot>  [1,2,3,4,5,6,7,8,9]
09:03:01 <Philippa> ski: that more or less amounts to "I think type classes are wrong" though
09:03:08 <LeCamarade> @src init
09:03:08 <ski> yes (or other values, like 'emptyMap :: forall k v. Map k v')
09:03:08 <lambdabot> init [x]    = []
09:03:09 <lambdabot> init (x:xs) = x : init xs
09:03:09 <lambdabot> init []     = undefined
09:03:10 <campusblo> yeh i know i can do it with a function but i dont understand why that doestn work
09:03:17 <nominolo> campusblo: [qs] is of type [[a]]
09:03:26 <nominolo> oh, no
09:03:33 <nominolo> sorry
09:03:43 <campusblo> oh ok
09:03:44 <dmhouse> campusblo: x:y always means x is the head, and y the tail.
09:03:52 <mauke> > let dequeBack (qs:q) = (q, [qs]) in dequeBack [1,2,3,4,5]
09:03:53 <lambdabot>  ([2,3,4,5],[1])
09:03:54 <campusblo> so it shoud be of type qs then and itll work
09:03:57 <nominolo> campusblo: bad naming, though ..
09:04:02 <campusblo> i know
09:04:05 <ski> Philippa : i don't think so .. i'm not saying they are right either, but maybe one could use a type class framework in which you allow kind parameters to the type classes ..
09:04:12 <campusblo> im actually trying to create a queue
09:04:27 <campusblo> but i do this function first to help me to see whats going on
09:04:32 <LeCamarade> campusblo: Okay, so what do you want dequBack to return?
09:04:35 <ski> (Philippa : obviously 'right' and 'wrong' here refers to this particular situation)
09:04:45 <Philippa> ski: ...what does that have to do with the current situation? Really, it's conflating two different things used for two different purposes
09:04:51 <campusblo> last element in the queue and the rest of the elements
09:05:00 <dcnstrct> wow this concurrent portscanner in haskell blows my mind.   I would have to write 20x this much code to do it in sraight C; and at least 8x as much code to do it in Ruby/C
09:05:02 <campusblo> but i had seen it done with using last
09:05:12 <campusblo> and i wondered if this would work as easily
09:05:13 <ski> Philippa : how do you mean ?
09:05:18 <Philippa> type classes constrain types, kinds tell us what's a well-formed type in the first place
09:05:27 <campusblo> once i get this function to work ill go ahead and create the type
09:05:45 <mauke> @src last
09:05:45 <lambdabot> last [x]    = x
09:05:46 <lambdabot> last (_:xs) = last xs
09:05:46 <lambdabot> last []     = undefined
09:05:48 <LeCamarade> > let dB x = (last x, init x) in dB [1 .. 10]
09:05:49 <lambdabot>  (10,[1,2,3,4,5,6,7,8,9])
09:05:59 <LeCamarade> > let dB x = (last x, init x) in dB [1 .. 10]
09:06:01 <lambdabot>  (10,[1,2,3,4,5,6,7,8,9])
09:06:05 <Philippa> to do the same thing using kinds, you need a much more complex kind system, and one that doesn't behave analogously to our types - we don't have extensible types, but you'd need extensible kinds
09:06:08 <LeCamarade> Is that the result you want?
09:06:10 <dmhouse> campusblo: explain how you think your function works.
09:06:14 <dmhouse> (Or should work.)
09:06:30 <campusblo> dequeBack :: [ a ] -> (a, [a])
09:06:30 <campusblo> dequeBack  (qs:q) = (q, qs)
09:06:35 <campusblo> thats the new function
09:06:45 <Philippa> and you'd still not get back what you get from MPTCs
09:06:49 <campusblo> takes a list and returns the last element of the list and all the other elements in a list
09:06:57 <ski> Philippa : in this case the kinds parameter would (hopefully) allow us to talk about monads not just over '*', but also over the subkind of that, that only contains types supporting 'Ord'
09:06:58 <mauke> campusblo: no, it doesn't
09:07:16 <mauke> campusblo: matching on (:) always gives you the first element and the rest
09:07:17 <campusblo> oh ok
09:07:22 <campusblo> ok
09:07:27 <campusblo> i understand
09:07:28 <nominolo> > let deq ([], []) = undefined; deq (xs,[]) = deq ([], reverse xs); deq (xs, y:ys) = (y, (xs, ys)) in deq ([1..3],[])
09:07:29 <ski> (Philippa : this is speculation, of course)
09:07:29 <lambdabot>  (3,([],[2,1]))
09:07:33 <campusblo> so i cant switch q and qs
09:07:35 <campusblo> got it
09:07:41 <LeCamarade> campusblo: Okay, here is a similar thing. But we'll do it another way with you. Does this work as you want?
09:07:43 <LeCamarade> > let dB x = (last x, init x) in dB [1 .. 10]
09:07:45 <lambdabot>  (10,[1,2,3,4,5,6,7,8,9])
09:07:57 <campusblo> yeh that does what i want
09:08:05 <campusblo> i understand now
09:08:09 <dmhouse> campusblo: Haskell doesn't care how your variables are named, they're just labelled. The fact that you called the head 'qs' and the tail 'q' is inconsequential to the compiler.
09:08:21 <campusblo> i was just trying to see if i could get around using last
09:08:22 <dmhouse> LeCamarade: I think he wanted to build the function himself to understand it, though.
09:08:46 <Philippa> ski: sure. Like I say, this gives us a kind system that's drastically different to the type system underneath it, and which doesn't give us any new expressive power compared to qualified types but also lacks some
09:08:47 <LeCamarade> dmhouse: Yes, it's why I had offered to carry him through it. I think he's got it, though.
09:08:56 <dmhouse> campusblo: any function that accesses the last element in a list is neccessarily O(n), because it has to traverse the entire list, starting from the head, to get to the last element.
09:09:03 <LeCamarade> campusblo: Do you still want a finer example? I have it ready ...
09:09:13 <Philippa> where it lacks is that it can't express "give me n types, where some relationship exists between them"
09:09:13 <nominolo> > let enq x (xs, ys) = (x:xs,ys); deq ([],[]) = undefined; deq (xs,[]) = deq ([], reverse xs); deq (xs, y:ys) = (y, (xs, ys)) in deq (enc 1 ([],[2..4]))
09:09:14 <campusblo> yeh cool
09:09:14 <lambdabot>   Not in scope: `enc'
09:09:23 <nominolo> > let enq x (xs, ys) = (x:xs,ys); deq ([],[]) = undefined; deq (xs,[]) = deq ([], reverse xs); deq (xs, y:ys) = (y, (xs, ys)) in deq (enq 1 ([],[2..4]))
09:09:24 <lambdabot>  (2,([1],[3,4]))
09:09:30 <LPhas> http://hpaste.org/1447#a1 <- is this an HAppS bug?
09:10:06 <Philippa> why invoke new kinding machinery as well when the typeclass machinery already handles it and better?
09:10:10 <campusblo> im gonna be doing my project all day today for the next part i have to do a fuction that does the following scan::[String]-> Stack State ->Queue HToken -> Queue HToken
09:10:27 <ski> Philippa : huh .. i'm not talking about removing qualified types .. only to add to that system
09:10:42 <Syzygy-> ?index group
09:10:43 <lambdabot> Data.List
09:11:29 <Philippa> ski: yeah, but it doesn't give us any new expressive power
09:12:12 <campusblo> if im not mistaken it takes a list of strings. puts letters in a stack and places the letters in a queue once it reaches a space
09:12:17 <campusblo> but ill be back for that
09:12:20 <ski> Philippa : being about to have classes which relate not only types, but also kinds is not new expressive power ?
09:12:26 <campusblo> thanks folks bbiab
09:12:27 <ski> s/about/able/
09:12:56 <Philippa> ski: okay, that is, but the subkinding you're asking for isn't - and worse, it's malformed
09:13:07 <campusblo> LeCamarde did you paste your last example?
09:13:22 <Philippa> at the moment, our kind system isn't really powerful enough to be able to do interesting things with typeclasses working on kinds, either
09:13:31 * ski nods
09:13:40 <LeCamarade> campusblo: I'm about to, hang on.
09:14:11 <Philippa> and if typeclasses relate kinds to types then there's likely a whole pile of hell that comes with it
09:14:18 <ski> (the subkinding would be used in conjunction with this more expressive class system to hopefully give us monads over types supporting 'Ord')
09:14:26 <Philippa> ...it's *not necessary*
09:14:42 <Philippa> we already have the power to express that
09:14:42 <ski> yeah .. it seems to have some dep. types in it .. question is how much
09:15:02 <Philippa> and the subkinding is too ad-hoc
09:15:06 <LoganCapaldo> But do we have the responsibility?
09:15:07 <ski> which way are you referring to ?
09:15:08 <Philippa> it only works for single-parm classes
09:15:29 <Philippa> typeclasses express the same thing that your subkinding would express, only better
09:15:40 <nomeata> Hi
09:16:04 <Philippa> where you just relate monad type constructors to the types they can accept
09:16:07 <ski> (but i'm suggesting using subkinding in *conjunction* with typeclasses !)
09:16:26 <Philippa> yes. Again, it's not necessary and it's a theoretical hellhole and the mechanisms involved are kludges
09:16:27 <nomeata> Are implicit parameters really that bad? Or should I always go with something like the reader monad for âalmost-constantâ things :-)
09:16:53 <ski> Philippa : well, i think the 'Monad m a' thing is a kludge ;)
09:17:01 <LeCamarade> campusblo: I'm pasting ...
09:17:08 <campusblo> cool
09:17:13 <Philippa> it directly expresses what we want to express
09:17:24 <Philippa> turning a into a kind instead of a type doesn't gain any elegance
09:17:25 <ski> nomeata : i don't think they are so bad .. (maybe they could be expressed better, though)
09:17:35 <nomeata> In my case, I call a bunch of pattern matching functions that tranform my internal data representation into a HTML page.
09:17:53 <nomeata> And suddently I need to know, deep inside, what level the currently generated page is for
09:18:05 <nomeata> So I need to pass that information all the way through. What would you do?
09:18:07 <Philippa> and it'd have to appear in the class definition, because m has to have a fixed kind
09:18:24 <ski> yes
09:18:27 <Philippa> so really, where's the gain in elegance?
09:18:29 <hpaste>  LeCamarade pasted "For campusblo" at http://hpaste.org/1448
09:18:43 <dmhouse> nomeata: implicit parameters affect type signatures anyway.
09:18:47 <campusblo> hey nometa how do you do that html? Could I see that?
09:18:59 <dmhouse> campusblo: tried Text.XHtml?
09:19:03 <LeCamarade> campusblo: Ask about every line that's not clear.
09:19:27 <campusblo> ok LeCamarde
09:19:33 <ski> Philippa : as said, i believe 'Monad m a' to be not elegant at all .. however i'm currently unable to explicate why (read : this is a fuzzy warm feeling that could well be wrong)
09:19:54 <nomeata> dmhouse: I usually never write my type signatures, so thatâs not a problem.
09:20:00 <araujo> morning
09:20:06 <LeCamarade> campusblo: I didn't use the fold functions, because I am not sure you're familiar with them (they can look esoteric). So, I used continual-passing, which I don't encourage.
09:20:38 <LeCamarade> araujo: Hola¡ Morning!
09:20:59 <mauke> nomeata: http://www.cs.rutgers.edu/~ccshan/prepose/p1214-kiselyov.pdf
09:21:18 <Philippa> ski: I suspect it is. It's a perfect use of typeclasses, it covers what's intended to be covered precisely
09:21:33 <Philippa> I suspect what's actually going on is that it uses typeclasses in a way you're not used to seeing?
09:21:54 <campusblo> ok LeCamarade
09:22:11 <ski> (LeCamarade : 'continual-passing' ?)
09:22:21 <dolio> Philippa: What exactly does the Set instance look like? I played a bit, and GHC doesn't seem to recognize that b is an instance of Ord for bind...
09:22:49 <Philippa> it also means you don't have to invoke some flavour of kind unification mechanism in the middle of code that's polymorphic on the type constructor
09:23:20 <LeCamarade> ski: It is where you pass some accumulating value back into a function, so yoy can use it at some point. It's usually achieve by impurity and a var, in other languages.
09:23:36 <araujo> LeCamarade, Hola!
09:23:54 <Philippa> dolio: have you forgotten to constrain the RHS parm of >>= appropriately?
09:24:08 <LeCamarade> ski: Continual-passing funcs always have an arg meant to be a collector. Like ...
09:24:11 <ski> Philippa : could you point me to the alternative 'Monad' definition that you're referring to here ?
09:24:33 <Philippa> ski: I don't know that I've seen it written out explicitly before
09:24:40 <Philippa> class Monad m a where
09:24:45 <Philippa>   return :: a -> m a
09:24:52 <dolio> Philippa: It's possible. I currently have 'bind :: ExtMonad m b => m a (a -> m b) -> m b'
09:25:08 <LeCamarade> araujo: ¡Hola!
09:25:22 <dolio> There should be another arrow there, of course.
09:25:24 <ski> LeCamarade : ok .. i think i'd call that "accumulator-passing"
09:25:55 <LeCamarade> Many names, same thing. Like the village dog.
09:25:57 <Philippa> dolio: that looks like it should be sufficient to me
09:25:58 <LeCamarade> :oD
09:26:23 <Philippa> however, there could be another instance, so that's not enough to encode that b's in Ord
09:26:24 <ski> LeCamarade : however, there's something called "continuation-passing", which is not the same as this (but related)
09:26:38 <LeCamarade> ski: Proceed ...
09:26:57 <dmhouse> LeCamarade: as in continuation passing style.
09:27:09 <Philippa> odds are what you then need is a way to enforce it on the type constructor, or on its data constructors
09:27:26 <dmhouse> LeCamarade: http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
09:27:32 <LeCamarade> dmhouse: I call that continual passing. I wonder why I call it that ... the YAHT?
09:27:35 <ski> LeCamarade : in "continuation-passing-style", you pass an extra argument, being a function that reprents what to do after the current function is done (so instead of just returning you're result, you call the continuation on it)
09:27:40 <Philippa> that might need an extension to the type system - it's much lighter-weight though
09:27:44 <campusblo> what does that do ? dequeBackCP y (x:xs) = dequeBackCP (y ++ [x]) xs
09:27:55 <dolio> Philippa: Oh, okay. Yeah, maybe it could be done with the GADT syntax.
09:27:59 <campusblo> LeCamarade?
09:28:17 <ski> (LeCamarade : and one connection with accumulators is that often one can thing of this continuation parameter as an accumulator (of a special kind))
09:29:56 <Philippa> ski: still want me to sketch out the class declaration for you?
09:30:00 <ski> Philippa : this seems to be topical <http://www.cse.unsw.edu.au/~dons/haskell-1990-2000/msg02182.html>
09:30:02 <Philippa> though I think dolio's already written it
09:30:06 <ski> Philippa : i'd like that, yes
09:30:32 <ski> (i've browsed many different variants and can't keep them apart :)
09:31:00 <LeCamarade> campusblo: It puts the first element if the list passed in (the list is broken up into its head and tail, x being the head, and xs the tail), and puts it at the end of y (which is a list, which I start out as []). That way, you keep the value of the list as you go, until you get to the end, when you have only one element left in the list, and the function with [x] is called, which returns the last element (pulled from between the [x] -- the x) and the 
09:31:25 * LeCamarade apologises for the flood ...
09:32:08 <ski> LeCamarade : fyi, it's better to replace 'y ++ [x]' with 'x:y' and also replace '(x, y)' by '(x,reverse y)'
09:32:40 <LeCamarade> ski: This will confuse campusblo. He is learning.
09:33:11 * ski is sorry
09:33:16 <LeCamarade> ski: I did the func in one line up there, but that was not the kind of stuff you give to him.
09:33:23 <intergalacti> actually i get that . the last will be the head in a reverse
09:33:45 <LeCamarade> ski: And what that Wikibooks page calls a continuation is not a continuation. It is wrong.
09:33:47 <intergalacti> dequeBackCP y (x:xs) = dequeBackCP (y ++ [x]) xs whats this?
09:34:11 <intergalacti> oh this is campusblo i got kicked
09:34:21 <LeCamarade> http://en.wikipedia.org/wiki/Continuation_(computer_science)
09:34:26 <intergalacti> and i think i signed back on with another name by accident
09:34:32 <intergalacti> automatically
09:34:43 <intergalacti> i think it happened in the flood
09:35:10 <LeCamarade> intergalacti: You are campusblo?
09:35:38 <campusblo> ok back
09:35:58 <campusblo> "dequeBackCP y (x:xs) = dequeBackCP (y ++ [x]) xs" thats the line i dont understand
09:35:58 <LeCamarade> campusblo: Okay, so you got it?
09:36:14 <campusblo> not that line
09:37:16 <LeCamarade> campusblo: Okay, that y starts out as []. It is where I keep adding x inside the function, until that function stops being called.
09:37:18 <SyntaxNinja> @seen shapr
09:37:26 <lambdabot> I saw shapr leaving #haskell 1d 18h 23m 25s ago, and .
09:37:38 <LeCamarade> campusblo: That function stops being called when the one above it is called, and that is when there is only one element left in the list, as you can see ...
09:38:00 <LeCamarade> dequeBack y [x] = ...
09:38:32 <LeCamarade> That is the one that gets called when there is only one element left.
09:38:53 <campusblo> ok got it
09:38:55 <LeCamarade> When it is called, the y has all the stuff we've been adding to it all along. Are you with me?
09:39:06 <campusblo> yeh
09:39:41 <LeCamarade> So, it is at that point that you put what we've been collecting into the second part of the tuple, and then the remaining element into the first part.
09:40:00 <LeCamarade> dequeBack y [x] = (x, y)
09:40:34 <campusblo> thats pretty cool actually
09:40:41 <campusblo> i would not have automatically seen that
09:41:05 <campusblo> i usually look at the end function but i dindnt expect the base case to flip the tuple
09:41:07 <campusblo> cool
09:41:08 <hpaste>  ski annotated "For campusblo" with "hand evaluation example" at http://hpaste.org/1448#a1
09:41:14 <LeCamarade> That is the line that finishes it off. In all the calls before, it is the other version of the function that was being called. And all it did was promise that at some point, we will return with the necessary data (by calling itself, albeit with with different data). Good. Next question?
09:42:04 <Philippa> dolio: actually stuff the GADTs, use a fundep in the Monad class
09:42:11 <LeCamarade> campusblo: ski has added something for us ...
09:42:43 <LeCamarade> campusblo: Go now and look at what ski has added./
09:42:49 <ski> just an example, to perhaps easier grasp what is being done
09:42:52 <dolio> Philippa: I'll paste what I have so far (which doesn't work) so you can suggest something.
09:42:58 <campusblo> i did
09:42:58 * LeCamarade thanks ski for his comradely assistance.
09:42:59 <campusblo> i get it
09:43:04 <LeCamarade> @karma+ ski
09:43:04 <lambdabot> ski's karma raised to 12.
09:43:09 <Philippa> dolio: I can't hang about much, got stuff to make happen here unfortunately
09:43:13 <campusblo> its the flup that i didnt see
09:43:16 <campusblo> flip
09:43:33 <LeCamarade> campusblo: flip? Is there a flip?
09:43:35 * ski wonders how he got all that karma .. he remembers have 3 or something
09:43:39 <campusblo> well not really
09:43:43 <campusblo> im calling it a flip
09:43:55 <Philippa> dolio: paste away though
09:43:56 <LeCamarade> Okay ...
09:44:10 <campusblo> putting the last element in front
09:44:16 <campusblo> ok so ill be back in a while
09:44:24 <campusblo> im sure ill ahve more questions
09:44:28 <hpaste>  dolio pasted "First pass ExtMonad" at http://hpaste.org/1449
09:44:30 <ddarius> People like the SKI combinators...
09:44:34 <campusblo> thanks later
09:45:34 <dolio> The GADT isn't holding on to the Ord dictionary, which I thought it was supposed to. Maybe I'm doing it wrong.
09:45:58 <Philippa> dolio: nah, I messed up
09:46:10 <Philippa> use a fundep, m -> a
09:47:21 <chessguy_work> dolio: SList = Set?
09:48:06 <dolio> chessguy_work: SList is a sorted list type.
09:48:27 <chessguy_work> ah
09:49:42 <ski> (dolio : that uses the recent restriction lifting on constraints on 'data' type parameters, for GADT, yes ?)
09:49:53 <ski> hm
09:50:03 <dolio> ski: That's what I was trying for, but it doesn't seem to work.
09:50:22 * ski tries to recall which GHC version's supposed to allow this
09:52:42 <LeCamarade> Lambdamen ... which module would help me take a byte apart? Not to tweak many bytes. Just to to do some bit-level hacking.
09:53:02 <int-e> Data.Bits
09:53:15 * LeCamarade is feeling naive. And ashamed.
09:57:33 <Cheery> is there a combinator library for outputting sound in haskell?
09:59:13 <ClaudiusMaximus> Cheery: there are bindings to SuperCollider3 server, i've toyed with it only briefly though
09:59:24 <thetallguy> Cheery: search for Haskore
09:59:36 <Cheery> I'd just like to output something, even random noise
09:59:50 <thetallguy> Cheery: Paul Hudak generates music from Haskell.
10:01:23 <ddarius> Cheery: There wouldn't be a -combinator- library for -outputting- sound, there would for manipulating it in various ways, or there would be a set of functions to output sound.
10:04:16 <chessguy_work> > sqrt 791
10:04:18 <lambdabot>  28.124722220850465
10:05:17 <opqdonut> > sum $ map ((791%).(-1)) [1..29]
10:05:19 <lambdabot>   add an instance declaration for (Num (a -> t))
10:05:29 <opqdonut> hmm
10:05:31 <opqdonut> :t %
10:05:34 <lambdabot> parse error on input `%'
10:05:37 <opqdonut> :t (%)
10:05:40 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
10:05:44 <opqdonut> ahhh
10:05:48 <dolio> ski: I guess what I'm looking for is HEAD only.
10:06:25 <opqdonut> > sum $ map ((mod 791).(-1)) [1..29]
10:06:26 <lambdabot>   add an instance declaration for (Num (a1 -> a))
10:06:31 <thedward> > sum $ map ((791%).(flip (-) 1) [1..29]
10:06:32 <lambdabot>  Parse error
10:06:39 <thedward> > sum $ map ((791%).(flip (-) 1)) [1..29]
10:06:41 <lambdabot>  Exception: Ratio.%: zero denominator
10:06:43 <chessguy_work> > sum $ map ((`mod` 791).(-1)) [1..29]
10:06:44 <lambdabot>   add an instance declaration for (Num (a -> b))
10:07:07 <thedward> > sum $ map ((791%).(\x -> x - 1)) [1..29]
10:07:09 <lambdabot>  Exception: Ratio.%: zero denominator
10:07:14 <opqdonut> gyaah
10:07:27 <thedward> what are you trying to do?
10:07:36 <chessguy_work> > sum $ map ((791%).(\x -> x - 1)) [2..29]
10:07:37 <lambdabot>  35640718546039%11473347600
10:07:41 <chessguy_work> ack!
10:07:49 <opqdonut> ?pl \x -> 791 `mod` x
10:07:50 <lambdabot> (791 `mod`)
10:07:52 <thedward> (-1) is a number literal and not a section
10:07:54 <opqdonut> test for primeness
10:07:56 <opqdonut> ahh
10:08:04 <opqdonut> ?pl \x -> (791 `mod` x)-1
10:08:05 <lambdabot> subtract 1 . (791 `mod`)
10:08:16 <opqdonut> > sum $ map (subtract 1 . (791 `mod`)) [1..29]
10:08:18 <lambdabot>  222
10:08:22 <opqdonut> there, not prime :)
10:08:27 <chessguy_work> haha
10:08:33 <opqdonut> > sum $ map (subtract 1 . (17 `mod`)) [1..10]
10:08:35 <lambdabot>  20
10:08:39 <opqdonut> hrmmm?
10:08:52 <opqdonut> > map (subtract 1 . (17 `mod`)) [1..10]
10:08:54 <lambdabot>  [-1,0,1,0,1,4,2,0,7,6]
10:09:01 <opqdonut> ah, yes, nvm
10:09:27 <opqdonut> > map (\x -> (17 `mod` x) == 0) [1..10]
10:09:29 <lambdabot>  [True,False,False,False,False,False,False,False,False,False]
10:09:41 <opqdonut> > or $ map (\x -> (17 `mod` x) == 0) [1..10]
10:09:43 <lambdabot>  True
10:09:59 <chessguy_work> i'm glad to know that the number of square feet in the apartment i'm looking at is not prime :)
10:09:59 <opqdonut> > or $ map (\x -> (17 `mod` x) == 0) [2..10]
10:10:01 <lambdabot>  False
10:10:09 <dmwit> :t or
10:10:10 <opqdonut> yes, we don't mod 1 :P
10:10:12 <lambdabot> [Bool] -> Bool
10:10:18 <dmwit> :t any
10:10:20 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
10:10:24 <dmhouse> > let fac n = product [1..n] in filter (\x -> (fact (x - 1) `mod` x) == x - 1) [2..]
10:10:26 <lambdabot>   Not in scope: `fact'
10:10:27 <opqdonut> > or $ map (\x -> (791 `mod` x) == 0) [2..29]
10:10:29 <lambdabot>  True
10:10:30 <dmhouse> > let fac n = product [1..n] in filter (\x -> (fac (x - 1) `mod` x) == x - 1) [2..]
10:10:34 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
10:10:37 <opqdonut> ^_^
10:10:49 <Cheery> haskore does not seem to work
10:10:59 <dmhouse> (http://en.wikipedia.org/wiki/Wilson%27s_theorem)
10:11:01 <lambdabot> Title: Wilson's theorem - Wikipedia, the free encyclopedia
10:11:17 <thedward> let sieve (x:xs) = x : [ y | y <- sieve xs , (y `mod` x) /= 0 ] in sieve [2..]
10:11:32 <thedward> > let sieve (x:xs) = x : [ y | y <- sieve xs , (y `mod` x) /= 0 ] in sieve [2..]
10:11:34 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
10:11:57 <dmhouse> Yes, yes, there are much more sensible ways of doing it, I just thought Wilson's theorem was cool. :)
10:12:05 <dmwit> Three points to the last person to post the nubBy one. ;-)
10:12:10 <thedward> not a critique, just playing
10:12:34 <emu> > 2^^16 `mod` 17
10:12:36 <lambdabot>  Add a type signature
10:12:42 <emu> > (2^16) `mod` 17
10:12:43 <lambdabot>  1
10:13:01 <emu> > (3^16) `mod` 17
10:13:03 <lambdabot>  1
10:13:42 <dmwit> > (5^16) `mod` 17
10:13:43 <lambdabot>  1
10:13:50 <emu> it's fermat's little thm
10:13:54 <dmwit> Prime powa!
10:15:01 <gour> anyone uses shim?
10:16:25 <emu> i've tried it
10:18:26 <tfc_3000> whats the OR symbol in haskell?
10:18:28 <tfc_3000> ||?
10:18:32 <emu> yep
10:18:44 <emu> thats logical
10:18:48 <tfc_3000> whats equivales?
10:18:50 <tfc_3000> ==?
10:18:55 <emu> yes
10:19:02 <Cheery> oh well, I installed OpenAL then, just hoping it had stuff to put out nonsense
10:19:03 <emu> do you need a tutorial or doc link?
10:19:13 <TheArthur> total nube: which haskell ubuntu package should i install?
10:19:29 <emu> TheArthur: search for ghc, i have no idea what they have
10:19:43 <TheArthur> emu thanks
10:19:49 <dmwit> TheArthur: ghc6 and libghc6-.*-dev
10:19:51 <emu> if it's like debian, then ghc6.6 probably
10:19:56 <emu> er ghc6 yea
10:20:02 <gour> emu: how do you like it? any news regarding vim support?
10:20:09 <dmwit> (From Dapper, YMMV)
10:20:28 <emu> gour: it's got the right idea, but i don't think it's ready for prime-time yet.  for one thing, there was no REPL when i tried it.  perhaps that' schanged.
10:21:02 * gour also thinks the idea is right...
10:21:15 <emu> @where shim
10:21:16 <lambdabot> I know nothing about shim.
10:21:45 <gour> it is here http://shim.haskellco.de/trac/
10:21:47 <lambdabot> Title: shim - Trac
10:22:08 <emu> yea
10:22:15 <emu> the author is sometimes here
10:23:19 <emu> as beschimi
10:23:22 <gour> what time?
10:23:27 <gour> (usually)
10:23:28 <emu> @seen beschimi
10:23:29 <lambdabot> I haven't seen beschimi.
10:23:34 * emu shrugs
10:23:38 <gour> @seen beshcmi
10:23:39 <lambdabot> I haven't seen beshcmi.
10:23:51 <gour> @seen beschmi
10:23:52 <lambdabot> I haven't seen beschmi.
10:24:15 <emu> well it appears that he recorded some kind of vim support
10:25:06 <LeCamarade> @where+ shim http://shim.haskellco.de/trac/
10:25:07 <lambdabot> Done.
10:25:33 <hpaste>  Phas annotated "HAppS learing" with "Learning HAppS" at http://hpaste.org/1441#a2
10:25:42 <gour> i saw that, but after puling from repo and reading readme, there is only emacs support
10:25:51 <hpaste>  Phas annotated "HAppS learing" with "Error" at http://hpaste.org/1441#a3
10:26:01 <gour> it looks majority of haskell hackers are using it
10:26:29 <gour> considering it has the best haskell support
10:26:46 <dmwit> gour: Or the vim users are lazy... ;-)
10:26:48 <emu> emacs? it's about half / half
10:27:04 <emu> i suspect  most emacs users are using monnier's haskell-mode
10:27:27 <emu> and vim users just use a ghci terminal
10:27:43 <dmwit> Right, that's what I do.
10:27:55 <Cheery> metoo
10:28:20 <gour> dmwit, ChanServ : use ghci?
10:28:38 <Cheery> yes
10:28:40 <dmwit> yes
10:29:11 <gour> :-)
10:29:29 <gour> what do you think about shim with vim support'
10:29:35 <emu> haskell-mode is basically just running ghci inside emacs, with some handy keybindings to load files, query types, etc
10:29:49 <dmwit> gour: I haven't tried it, it looked like there was only one (barely important) functionality.
10:29:50 <emu> (strictly speaking, that's inf-haskell mode)
10:30:30 <rictic> What would you suggest for a data type that behaves like a dictionary/hash/map optimized for fast lookup?
10:30:41 <rictic> And for the meta-problem, how should I answer this question for myself in the future
10:30:59 <emu> rictic: Data.Map, and haskell.org
10:31:27 <dmwit> rictic: Data.HashMap is also available, but probably not worthwhile.
10:31:31 <gour> dmead: shim is supposed to improve auto-completion?
10:31:49 <rictic> (google didn't help much, mostly pointed me at various interesting-looking papers)
10:32:00 <emu> @doc Data.Map
10:32:01 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
10:32:34 <rictic> Ah, many thanks :)
10:33:15 <emu> > 'a' `M.lookup` (M.fromList [('b',1),('a',2)]) :: Just Int
10:33:17 <lambdabot>   Not in scope: type constructor or class `Just'
10:33:20 <emu> > 'a' `M.lookup` (M.fromList [('b',1),('a',2)]) :: Maybe Int
10:33:22 <lambdabot>  Just 2
10:34:30 <gour> dmead: sorry. wrong nick-completion :-(
10:35:02 <emu> hopefully i will get a chance to poke at shim some more in a month :/
10:35:31 <gour> ok
10:36:38 <dmhouse> rictic: in general, browsing http://haskell.org/ghc/docs/latest/html/libraries/index.html can help.
10:37:01 <dmhouse> (Scroll down a bit to see the module hierarchy.)
10:37:04 <mux> and soon we'll have GMap :-)
10:37:18 <dmwit> mux: What's GMap?
10:37:33 <mux> generalized maps using associated types
10:37:53 <mux> with that you can use whatever data structure suits best for a given type
10:38:04 <mux> thus Data.IntMap becomes unnecessary
10:38:38 <dmhouse> mux: how does that make IntMap unnecessary?
10:38:44 <nominolo> emu: same plans here ..
10:38:53 <rictic> dmhouse: Yeah, that's fantastic.  Very discoverable.  Many useful looking libraries that I can see myself using
10:39:03 <dmhouse> mux: and specifically, how is that different from fmap?
10:39:30 <dmhouse> Well, I suppose some things (e.g. ByteString, IntMap) aren't strictly functors, but still.
10:39:36 <mux> it makes IntMap unnecessary because you can already use the best data structure when for Ints
10:39:46 <mux> I don't see how fmap allows this
10:40:03 <dmhouse> Aha.
10:40:15 <mux> it's not about having the same interface when using the data structure
10:40:43 <dmhouse> Although that, I presume, would be a part of it.
10:40:52 <mux> yes
10:41:03 <mux> http://hackage.haskell.org/trac/ghc/wiki/TypeFunctionsExamples
10:41:05 <lambdabot> Title: TypeFunctionsExamples - GHC - Trac
10:43:24 <mux> this also allows you to have optimized Array representations depending on the type you're storing
10:43:36 <mux> like automatically using bitfields for booleans, etc
10:43:54 <mux> I think this is the example SPJ is using in his paper
10:45:55 * mux likes associated types very very much
10:47:02 * dmwit . o O (Hasn't C++ had this for ages?  Why are we just getting around to it now?)
10:47:14 <mux> C++ has something similar called traits, yes
10:47:27 <emu> C++ doesn't have type inference
10:47:28 <mux> SPJ talks about it in the said paper
10:47:58 <dmwit> Specialized versions of templatizations, I mean.
10:48:36 <mux> I guess that's what "traits" are?
10:48:49 <dmwit> ok
10:48:58 <mux> I'm not sure at all
10:49:12 <dmwit> Yeah, type inference makes it slightly more interesting, good point.
10:49:14 <mux> never used those, but SPJ says that ATs somehow correspond to C++ traits, so...
10:49:29 <dmwit> C++ constantly needs reminders of what type is going where in templates.
10:50:13 <quicksilver> C++ does do typ einference
10:50:19 <quicksilver> but only in templates
10:50:27 <quicksilver> and ti's a little odd :)
10:50:29 <dmwit> quicksilver: Yes, but it's terrible!  It's often wrong or unsure.
10:50:31 <boegel> dons: ping!
10:50:42 <boegel> @localtime dons
10:50:44 <lambdabot> Local time for dons is Thu Apr 19 03:49:35 2007
10:51:00 <boegel> hmm, ok, it's unlikely he's awake, I admit :)
10:51:24 <mux> boegel: I've seen dons online at 5am before :)
10:51:25 <yetAnotherOne> c++-for-loops used for maps and vectors looks very odd
10:51:41 <mux> @seen dons
10:51:41 <lambdabot> dons is in #haskell-soc and #haskell. I last heard dons speak 13h 16m 19s ago.
10:51:53 <mux> 13h idle sounds bad though :-P
10:53:17 <emu> i sleep for like 13h
10:53:29 <emu> (i wish)
10:53:52 <yetAnotherOne> if i could sleep 13h ...
10:55:15 <boegel> mux: ah, ok, cool
10:55:28 <boegel> mux: but that was when he was overseas probably?
10:55:43 <boegel> emu: hehe
10:56:03 <mux> boegel: no idea
10:56:39 <boegel> 13h idle seems like he had better things todo than hanging out on IRC ;-)
10:57:02 <quicksilver> boegel: heresy
10:57:13 <boegel> quicksilver: stone him!
10:59:01 <mux> noone is to stone anybody until *I* blow this whistle!
10:59:17 <mux> even if he says Jehova!
10:59:29 * quicksilver stones boegel
11:00:09 * yetAnotherOne stones mux (Â»he said jehovaÂ«)
11:00:16 <mux> :-)
11:00:29 <dmwit> You know, my first year at college they gave me a whistle.
11:00:33 <mux> that makes me want to see that movie again
11:00:37 <dmwit> They told me it was a rape whistle.
11:00:45 <dmwit> But no matter how hard I blew, I never got raped. =(
11:00:50 <mux> hahaha
11:00:55 <yetAnotherOne> you are an odd person
11:01:05 <mux> @karma+ dmwit
11:01:06 <lambdabot> dmwit's karma raised to 4.
11:02:55 <LeCamarade> dmwit: You're crazy!
11:03:13 <kuribas> Is there a generic words?  Like splitting a string on other charachters than just whitespace?
11:03:49 <emu> @hoogle splitRegex
11:03:50 <lambdabot> Text.Regex.splitRegex :: Regex -> String -> [String]
11:03:56 <Saizan> ?where filepath
11:03:57 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php#filepath
11:04:57 <dmwit> > let wordsBy chars string = groupBy (\x y -> x `elem` chars == y `elem` chars) string in wordsBy ",.?" "Hi there, how are you? I'm fine, thanks. Hah!"
11:04:58 <lambdabot>      precedence parsing error
11:04:59 <lambdabot>         cannot mix `(==)' [infix 4] and `elem' ...
11:05:21 <dmwit> > let wordsBy chars string = groupBy (\x y -> elem x chars == elem y chars) string in wordsBy ",.?" "Hi there, how are you? I'm fine, thanks. Hah!"
11:05:22 <lambdabot>  ["Hi there",","," how are you","?"," I'm fine",","," thanks","."," Hah!"]
11:05:30 <ndm> ?where+ filepath http://www-users.cs.york.ac.uk/~ndm/filepath/
11:05:30 <dmwit> Hmmm, close, but not quite.
11:05:31 <lambdabot> Done.
11:05:47 <ndm> ?flush
11:05:48 <lambdabot> Not enough privileges
11:07:59 <LeCamarade> let vvords f a = foldr (\x y -> if f x then (y !! 0):vvords f a else ([y !! 0] ++ [x]):y) [] a
11:08:27 <LeCamarade> > let vvords f a = foldr (\x y -> if f x then (y !! 0):vvords f a else ([y !! 0] ++ [x]):y) [] a in vvords (== 5) [1 .. 10]
11:08:28 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
11:08:28 <lambdabot>       Expected...
11:08:53 <LeCamarade> > let vvords f a = foldr (\x y -> if f x then (y !! 0):vvords f a else ((y !! 0) ++ [x]):y) [] a in vvords (== 5) [1 .. 10]
11:08:55 <lambdabot>  Exception: Prelude.(!!): index too large
11:09:25 <LeCamarade> kuribas: Are you still there?
11:09:32 <kuribas> LeCamarade: yes
11:11:08 <dmwit> > let vvords _ [] = []; vvords p s = let bigTail = dropWhile p s in takeWhile p bigTail ++ vvords p bigTail in vvords (== 5) [1..10]
11:11:12 <lambdabot> Terminated
11:11:18 <pixel> is there a better way to write:  map (-1 +) [1,2,3]
11:11:36 <dmwit> > let vvords _ [] = []; vvords p s = let bigTail = dropWhile p s in takeWhile p bigTail ++ vvords p (dropWhile (not . p) bigTail) in vvords (== 5) [1..10]
11:11:37 <lambdabot>  []
11:12:04 <dmwit> > let vvords _ [] = []; vvords p s = let bigTail = dropWhile p s in takeWhile p bigTail ++ vvords p (dropWhile (not . p) bigTail) in vvords (/= 5) [1..10]
11:12:05 <lambdabot>  []
11:12:41 <dmwit> > let vvords _ [] = []; vvords p s = let bigTail = dropWhile p s in takeWhile (not . p) bigTail ++ vvords p (dropWhile (not . p) bigTail) in vvords (== 5) [1..10]
11:12:43 <lambdabot>  [1,2,3,4,6,7,8,9,10]
11:12:52 <dmwit> > let vvords _ [] = []; vvords p s = let bigTail = dropWhile p s in takeWhile (not . p) bigTail : vvords p (dropWhile (not . p) bigTail) in vvords (== 5) [1..10]
11:12:54 <lambdabot>  [[1,2,3,4],[6,7,8,9,10]]
11:12:59 <dmwit> Hoo!
11:13:34 <dmwit> > let vvords _ [] = []; vvords p s = let bigTail = dropWhile p s in takeWhile (not . p) bigTail : vvords p (dropWhile (not . p) bigTail) in vvords (`elem` ",.?!") "Hi,test.what?do!you,want"
11:13:36 <lambdabot>  ["Hi","test","what","do","you","want"]
11:14:00 <LeCamarade> dmwit: Okay. You got it. :oD I wanted to foldr. Grrr.
11:14:04 <dmwit> :t span
11:14:06 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
11:14:18 <dmwit> LeCamarade: Don't let me stop you!
11:14:20 <LeCamarade> kuribas: dmwit got it.
11:14:22 <dmwit> Play with it, for sure. =)
11:14:49 <kuribas> nice =)
11:15:59 <dmwit> > let vvords _ [] = []; vvords p s = let (_, t) = break p s; (b, e) = span p t in b : vvords p e in vvords (`elem` ",.?!") "Hi,test.what?do!you,want"
11:16:00 <lambdabot>  [",",".","?","!",",",""]
11:16:05 <LeCamarade> > let vvords f a = foldr (\x y -> if f x then else (if null y then [] else (y !! 0)):vvords f a else (if null y then [] else (y !! 0)) ++ [x]):y) [] a in vvords (== 5) [1 .. 10]
11:16:06 <lambdabot>  Parse error
11:16:12 <LeCamarade> Gack!
11:16:23 <dmwit> > let vvords _ [] = []; vvords p s = let (_, t) = span p s; (b, e) = break p t in b : vvords p e in vvords (`elem` ",.?!") "Hi,test.what?do!you,want"
11:16:25 <lambdabot>  ["Hi","test","what","do","you","want"]
11:16:38 <dmwit> > let vvords _ [] = []; vvords p s = let (_, t) = span p s; (b, e) = break p t in b : vvords p e in vvords (`elem` ",.?!") ",,,Hi,test.what?do!you,want,,,"
11:16:39 <lambdabot>  ["Hi","test","what","do","you","want",""]
11:16:50 <dmwit> Ooo, that last piece isn't so pretty.
11:17:41 <LeCamarade> > let vvords f a = foldr (\x y -> if f x then else (if null y then [] else (y !! 0)):vvords f a else (if null y then [] else (y !! 0)) ++ [x]):y) [] a in vvords (== 5) [1 .. 10] -- Can no longer follow the parens :o(
11:17:42 <lambdabot>  Parse error
11:18:29 <LeCamarade> > let vvords f a = foldr (\x y -> if f x then else ((if null y then [] else (y !! 0)):vvords f a else (if null y then [] else (y !! 0)) ++ [x]):y) [] a in vvords (== 5) [1 .. 10] -- Can no longer follow the parens :o(
11:18:29 <lambdabot>  Parse error
11:18:39 <LeCamarade> Gaaaaacccckkkkkk!!!
11:20:04 <ski__> 'then else' ?
11:20:26 * LeCamarade goes off to do it in GHCi, pretending to the boss that he is writing HTML by saying `BOLD' ... oh! ski_!
11:20:33 <LeCamarade> yes!
11:20:52 <LeCamarade> > let vvords f a = foldr (\x y -> if f x then ((if null y then [] else (y !! 0)):vvords f a else (if null y then [] else (y !! 0)) ++ [x]):y) [] a in vvords (== 5) [1 .. 10] -- Can no longer follow the parens :o(
11:20:53 <lambdabot>  Parse error
11:21:35 <LeCamarade> > let vvords f a = foldr (\x y -> if f x then (if null y then [] else (y !! 0)):vvords f a else (if null y then [] else (y !! 0)) ++ [x]):y) [] a in vvords (== 5) [1 .. 10] -- Last time, and I go to GHCi
11:21:35 <lambdabot>  Parse error
11:21:41 <ski__> maybe 'if f x then ((..(..)) else ..'
11:22:37 <yetAnotherOne> > (\x y -> map ((!!) [x..y]) [y..x]))
11:22:39 <ski__> 'foldr (.. ++ [x]):y) [] a ..'
11:22:48 <lambdabot>  Parse error
11:23:03 <yetAnotherOne> > (\x y -> map ((!!) [x..y]) [y..x])) 12 24
11:23:03 <lambdabot>  Parse error
11:29:19 <szabi_> where can I find documentation on the various operators in haskell? Currently I'm interested in >> but it would be nice to have a nice doc...
11:31:08 <Cale> szabi: any combination of symbols can be the name of an infix function
11:31:22 <LeCamarade> szabi: Are you on a Debian-derived Linux? It's easyt to get docs there.
11:31:25 <Cale> They're documented along with all the other functions at http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
11:31:42 <LeCamarade> Ubuntu, Debian. You can apt-get them.
11:31:45 <pixel> szabi_: http://haskell.org/ghc/docs/latest/html/libraries/doc-index-60.html gives you operators starting with <
11:31:47 <lambdabot> http://tinyurl.com/3xjx3j
11:32:23 <szabi_> thanks
11:32:24 <Cale> (>>) is a monad related operator -- are you working with a particular monad, or would you like the general explanation?
11:32:48 <LeCamarade> If on Debian or Ubuntu, do apt-get install haskell-doc haskell98-report
11:32:55 <Cale> Basically, if x and y are monadic actions of some sort, then (x >> y) is an action which performs x, then performs y, returning the result of y.
11:33:24 <Cale> I usually don't bother installing the docs locally as they're on the web anyway :)
11:33:25 <szabi_> Cale: I'm converting a haskell program to python to see the advantages :)
11:33:50 <szabi_> Cale: thanks for the explanation, that's enough for now
11:33:53 <LeCamarade> szabi_: Is it long? May want to tweak that, too ...
11:33:55 <Cale> Oh, that's going to take some interpretation then.
11:34:13 <LeCamarade> Cale: I think it is by hand.
11:34:21 <szabi_> lambdabot: it's the Diff.hs file
11:34:32 <Cale> LeCamarade: Yes, I mean, (>>) doesn't have a direct equivalent in Python.
11:34:33 <szabi_> Cale: by hand
11:35:02 <yetAnotherOne> haskell to python? i once tried this. it was hard and i missed the sugar of haskell after some seconds
11:35:15 <ski__> ('(>>)' is overloaded)
11:35:27 <szabi_> Cale: it's no use to use something equivalent to monads in python. Just simply write what it does...
11:35:56 <Cale> Yeah. If it's just the IO monad, that should work out okay.
11:36:45 <szabi_> LeCamarade: I'm working on this: http://andrew.bromage.org/darcs/diff/Diff.hs
11:38:39 <Cale> ah, okay, the use of >> there is fairly trivial.
11:39:35 <LeCamarade> Oh, you mean Haskell to Python? No, I can't do that. I'd like it the other way 'round.
11:39:58 <szabi_> LeCamarade: that will be the next step :)
11:40:53 <szabi_> LeCamarade: I have a small unfinished code in python which would be nice to have in haskell. I will let you know when I start working on that one
11:51:49 <LeCamarade> szabi_: Okay.
11:56:28 <inverselimit> how do I cast length of a list into a Rational?
11:56:57 <dylan> @hoogle a -> Rational
11:56:58 <lambdabot> Prelude.toRational :: Real a => a -> Rational
11:56:59 <Cale> inverselimit: fromIntegral
11:57:26 <dylan> fromIntegral (length [1..20]) :: Rational
11:57:30 <inverselimit> thanks
11:57:32 <dylan> > fromIntegral (length [1..20]) :: Rational
11:57:34 <lambdabot>  20%1
11:57:55 <tibbe> @seen dons
11:57:56 <lambdabot> dons is in #haskell-soc and #haskell. I last heard dons speak 14h 22m 34s ago.
12:00:36 <inverselimit> Did I hear some discussion of haskell/python linking?  OR just manual translation?
12:02:36 <LoganCapaldo> Using Typeable would it be feasible to take a [String] feed it into some function f, of arbitrary arity whose argument types were a well-defined subset of all the types, using read or similar to convert the strings to the expected types?
12:03:30 <LoganCapaldo> (Even if for instance you had to hardcode what possible argument types f could take)
12:04:02 <LoganCapaldo> Allthough it would be cooler if its args could be any instance of Read
12:04:33 <Saizan> i think the problem is  arbitrary arity
12:04:49 <fasta> Do you know of an article that handles top down splay trees in detail without using an extremely obscure language or preferably an implementation of said trees in a purely functional language?
12:05:08 <LoganCapaldo> well I was thinking you could find the arity out via typeOf called on f
12:05:55 <LoganCapaldo> So yeah you're right maybe not arbitrary but lets say between 0 and 10 argguments
12:06:18 <dmwit> LoganCapaldo: What would the return type be?
12:06:27 <LoganCapaldo> dmwit most likely a string
12:06:46 <LoganCapaldo> my idea is to map URLs in a web app to functions
12:07:10 <dmwit> LoganCapaldo: You may be interested in how printf is created in Haskell.
12:07:12 <LoganCapaldo> where you could write function as a pure function using the types you wanted and wouldn't have to think about conversion etc. within the function
12:07:19 <LoganCapaldo> dmwit: yeah
12:07:30 <mauke> blah, my type checker still has infinite loops :/
12:07:38 <hpaste>  tfc pasted "(no title)" at http://hpaste.org/1450
12:07:48 <tfc> http://hpaste.org/1450
12:07:54 <tfc> help please :)
12:07:59 <mauke> tfc: homework?
12:08:00 <LoganCapaldo> But I'm shooting for moving as much complexity as possible into the framework so that the functions themselves could be as "normal looking' as possible
12:08:10 <tfc> uni work yes
12:08:16 <tfc> almost finished
12:08:21 <LoganCapaldo> Even if that means its more limited than something like printf
12:08:24 <mauke> where are you stuck?
12:08:43 <tfc> no idea where to start with that function?
12:09:24 <mauke> well, the function has to take an argument and do stuff based on the value of that argument
12:09:39 <doserj> tfc: do you know what "eval (Val 5)" should return?
12:09:53 <pejo> mauke, infinite loops in the algorithm, or implementation?
12:10:05 <mauke> pejo: the implementation is the algorithm
12:10:11 <tfc> doserj: 5
12:10:16 <LoganCapaldo> eg.: add :: Int -> Int -> String; add a b = show (a + b); and then in the configuration you may http://yourapp.com/add/<some integer>/some integer> to call that function
12:10:18 <fasta> pejo: algorithms cannot run forever
12:10:25 <fasta> pejo: by definition
12:10:28 <doserj> so, "eval (Val n) = ???"
12:10:36 <tfc> n
12:10:43 <doserj> there is your start
12:11:07 <LoganCapaldo> The framework would use typeable to ask add about its type and do the appropiate conversion and check the length, etc.
12:11:30 <tfc> what then do it recursively?
12:11:36 <doserj> yes
12:11:47 <tfc> k
12:12:20 <LoganCapaldo> I pretty much grok how printf works, but I dont want to write add like printf
12:12:45 <tfc> eval Add (Val n) (Val n) = n + n
12:13:03 <mauke> precedence problem
12:13:08 <mauke> also, not recursive enough
12:13:56 <tfc> ?
12:14:13 <mauke> eval (Add ...)
12:14:19 <mauke> you need parens around the argument
12:14:37 <tfc> eval (Add (Val n) (Val n)) = n + n
12:14:52 <Saizan> also, what if the operands are themselves expressions?
12:14:52 <doserj> eval (Add e1 e2) = ???
12:15:04 <tfc> oh yeah
12:15:11 * tfc is rubbish at haskell
12:15:32 * fasta wished people stopped inventing new languages....
12:15:39 <tfc> eval (Add e1 e2) = e1 + e2 ?
12:15:52 <mauke> tfc: how would you do it in a non-haskell language?
12:16:16 <tfc> what like java?
12:16:23 <mauke> yeah, for example
12:17:06 <lispy> well, you'd need to create an Evalable interface
12:17:16 <lispy> and an Addable interface
12:17:25 <mauke> class Add extends Exp { Exp a, b; int eval() {
12:17:26 <lispy> then you'd make Addables instances of Evalable
12:17:41 <eumenides> eval (Add e1 e2) = eval e1 + eval e2
12:18:01 <mauke>     return a.eval() + b.eval(); }
12:18:27 <yetAnotherOne> ... and soon you see that haskell is much easier
12:18:29 <tibbe> if I want to separate my library and my QC properties into two files but the properties need some data contructors I don't want to provide in the public interface what do I do?
12:19:08 <LoganCapaldo> tibbe another layer of indirection?
12:19:24 <tibbe> LoganCapaldo, I'm not sure if I understand
12:19:31 <LoganCapaldo> public imports sem-public stuff hididng the stuff you need for QC?
12:19:35 <tibbe> a seperate module that imports and reexports?
12:19:36 <tfc> cheers :) think i can do it now
12:19:41 <LoganCapaldo> yeah
12:19:55 <tibbe> like MyLib.Base for private stuff and then a MyLib module
12:20:06 <LoganCapaldo> yeah
12:20:08 <tibbe> is there an idiomatic naming scheme for these things?
12:20:16 <LoganCapaldo> i have no idea :)
12:20:20 <tibbe> oki :)
12:20:33 <Taral> @seen JohnMeacham
12:20:34 <lambdabot> JohnMeacham is in #haskell-blah and #haskell. I don't know when JohnMeacham last spoke.
12:20:57 <sjanssen> tibbe: using .Base for private things is typical.  See Data.ByteString.Base and Data.Array.Base for two examples
12:22:53 <tfc> "Instance of Fractional Int required for definition of eval
12:23:02 <tfc> on line eval (Add e1 e2) = eval e1 + eval e2
12:23:03 <tfc> eh?
12:23:04 <tibbe> sjanssen, ok, thanks
12:23:55 <LoganCapaldo> tfc: did you declare your data type to only use Ints?
12:24:29 <LoganCapaldo> If so realize Ints don't know how to do division
12:24:38 <LoganCapaldo> you need to use fromIntegral or similar
12:24:44 <tfc> bbl
12:24:46 <LoganCapaldo> when you use /
12:25:42 <fuzan> > 1 / (3::Int)
12:25:43 <lambdabot>   add an instance declaration for (Fractional Int)
12:25:43 <lambdabot>     In the expression: 1 /...
12:25:51 <fuzan> > 1 / (fromIntegral 3)
12:25:53 <lambdabot>  0.3333333333333333
12:26:03 <fuzan> > 1 / 3
12:26:05 <lambdabot>  0.3333333333333333
12:26:47 <mauke> tfc: that's probably for Div
12:26:50 <mauke> don't use /
12:28:46 <LoganCapaldo> @source printf
12:28:47 <lambdabot> printf not available
12:28:53 <LoganCapaldo> @index printf
12:28:54 <lambdabot> Text.Printf
12:29:01 <pixel> @source delete
12:29:01 <lambdabot> delete not available
12:29:13 <LoganCapaldo> @help source
12:29:14 <lambdabot> source <lib>. Lookup the url of fptools libraries
12:29:19 <LoganCapaldo> aha
12:29:25 <LoganCapaldo> I always confuse source and index
12:29:42 <LoganCapaldo> My brain must search and replace / with . :)
12:30:22 <pixel> @source List.delete
12:30:23 <lambdabot> List.delete not available
12:30:27 <mauke> @src delete
12:30:28 <lambdabot> delete = deleteBy (==)
12:31:02 <pixel> mauke: thanks :-/
12:32:18 <pixel> @src deleteBy
12:32:19 <lambdabot> Source not found. Where did you learn to type?
12:32:43 <mauke> @src Data.List.deleteBy
12:32:43 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
12:33:20 <LoganCapaldo> @type deleteBy
12:33:23 <lambdabot> forall a. (a -> a -> Bool) -> a -> [a] -> [a]
12:33:42 <LoganCapaldo> odd
12:34:04 * LoganCapaldo would have expected (a -> Bool) -> [a] -> [a]
12:34:29 <chessguy> > deleteBy (<) 5 [1..10]
12:34:30 <lambdabot>  [1,2,3,4,5,7,8,9,10]
12:34:39 <chessguy> eh?
12:34:45 <LoganCapaldo> lol
12:34:47 <LoganCapaldo> what>
12:34:54 <emu> @type deleteBye
12:34:55 <emu> @type deleteBy
12:34:56 <lambdabot> Not in scope: `deleteBye'
12:34:59 <lambdabot> forall a. (a -> a -> Bool) -> a -> [a] -> [a]
12:35:17 <emu> @src deleteBy
12:35:17 <lambdabot> Source not found. Wrong!  You cheating scum!
12:35:32 <pixel> chessguy: only 6 is removed
12:35:33 <LoganCapaldo> > deleteBy (>) 5 [1..10]
12:35:35 <lambdabot>  [2,3,4,5,6,7,8,9,10]
12:35:45 <emu> aye, it's not filter
12:35:49 <LoganCapaldo> oh its delete first
12:35:52 <LoganCapaldo> der
12:35:54 <chessguy> pixel: i can see that, thanks
12:36:23 <chessguy> "The deleteBy function behaves like delete, but takes a user-supplied equality predicate."
12:36:27 <fuzan> > foldr (deleteBy (>) 5) [1..10]
12:36:28 <lambdabot>  Couldn't match expected type `b -> b' against inferred type `[a]'
12:36:42 <fuzan> > foldl (deleteBy (>) 5) [1..10]
12:36:44 <lambdabot>  Couldn't match expected type `b -> [a]' against inferred type `[a]'
12:36:50 <fuzan> i'm stupid.
12:37:00 <pixel> chessguy: sorry :)
12:37:05 <LoganCapaldo> I just don't see why deleteBy (>) 5 [1..10] over deleteBy (>5) [1..10]
12:37:23 <LoganCapaldo> errm, s/(>5)/(5>)/
12:37:27 <emu> to correspond to delete :: a -> [a] -> [a]
12:37:29 <pixel> anayway, i was looking for something alike (\\) but where [ 2, 2 ] \\ [ 2 ] would return []
12:37:33 <dylan> @type foldl (flip id) []
12:37:37 <lambdabot> forall a. [[a] -> [a]] -> [a]
12:37:46 <emu> > [2,2] \\ [2]
12:37:48 <lambdabot>  [2]
12:37:53 <dylan> ^ RPN evaluator? :)
12:38:00 <LoganCapaldo> delete = deleteBy . (==)
12:38:01 <emu> > filter (/=2) [2,2]
12:38:02 <xerox> pixel, is the input list ordered?
12:38:03 <lambdabot>  []
12:38:08 <sjanssen> @src deleteBy
12:38:09 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
12:38:35 <LoganCapaldo> maybe I'm just a weird
12:38:37 <emu> > delete 2 $ map head $ group [1,2,2,3]
12:38:38 <lambdabot>  [1,3]
12:38:45 <chessguy> deleteBy                :: (a -> a -> Bool) -> a -> [a] -> [a]
12:38:46 <chessguy> deleteBy _  _ []        = []
12:38:46 <chessguy> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
12:39:21 <mauke> that interface looks broken
12:39:37 <dylan> it's impossible to print the value in a Dynamic without knowing its type, right?
12:40:19 <pixel> xerox: nope.   a bigger example  [ 1, 1, 2, 3, 3, 4, 5 ] \\ [ 1, 2, 4 ]
12:40:33 <tfc> back
12:40:40 <tfc> what do i need to do for / then?
12:40:46 <mauke> tfc: `div`
12:40:50 <pixel> xerox: i was trying to mimick [ 1, 1, 2, 2, 3, 3, 3, 4, 5 ] - [ 1, 2, 4 ]  ==  [3, 3, 3, 5]  in groovy
12:40:54 <sjanssen> :t \xs0 ys -> foldl (\xs y -> filter (/= y) xs) xs0 y
12:40:56 <lambdabot> Not in scope: `y'
12:41:08 <sjanssen> :t \xs0 ys -> foldl (\xs y -> filter (/= y) xs) xs0 ys
12:41:09 <earthy> dylan: obviously.
12:41:11 <lambdabot> forall b. (Eq b) => [b] -> [b] -> [b]
12:41:17 <yetAnotherOne> > delete 2 $ map head [1,2,2,3]
12:41:18 <lambdabot>   add an instance declaration for (Num [a])
12:41:18 <lambdabot>     In the expression: 3
12:41:20 <sjanssen> pixel: ^^^ that should do it
12:41:23 <emu> > filter (`notElem` [1,2,4]) [1,1,2,3,3,4,5]
12:41:25 <lambdabot>  [3,3,5]
12:41:29 <mauke> > let f x y = filter (not . (`elem` y)) x in f [ 1, 1, 2, 3, 3, 4, 5 ]  [ 1, 2, 4 ]
12:41:31 <lambdabot>  [3,3,5]
12:41:37 <dylan> earthy: obviousity depends on knowledge. :)
12:42:15 <sjanssen> > (\xs0 ys -> foldl (\xs y -> filter (/= y) xs) xs0 ys)  [ 1, 1, 2, 3, 3, 4, 5 ]  [ 1, 2, 4 ]
12:42:17 <lambdabot>  [3,3,5]
12:42:29 <pixel> sjanssen, mauke: now i have 2 solutions ;)   which one is best?
12:42:43 <mauke> emu's
12:42:44 <sjanssen> pixel: you really should be using a Data.Set if you want these operations
12:42:56 <earthy> dylan: there is no Show instance for Dynamic, and the only way to get something from a Dynamic is to turn one back into a statically known type
12:42:58 <emu> well he wants a Multiset
12:43:00 <yetAnotherOne> @type group
12:43:02 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
12:43:10 <LoganCapaldo> sjanssen: wouldn't he want a multi set?
12:43:11 <sjanssen> emu: ah, right
12:43:14 <xerox> sjanssen, S.fromList would nub every element
12:43:15 <earthy> so that makes it obvious
12:43:19 <LoganCapaldo> damn I am slow
12:43:21 <LoganCapaldo> :(
12:43:32 <sjanssen> okay, Data.Map a Integer (where Integer is a count)
12:43:35 <dylan> earthy: there is a Show instance for dynamic
12:43:58 <pixel> well, i'll mention all this, that should be enough
12:44:19 <dylan> it doesn't show anything other than the name of the type, but that is pretty useful.
12:44:51 <LoganCapaldo> @hoogle Data.Map a b -> Data.Map a b -> (b -> b -> b) -> Data.Map a b
12:44:52 <lambdabot> No matches, try a more general search
12:44:56 <sjanssen> :t \xs ys -> filter (`Data.Set.notMember` Data.Set.fromList ys) xs -- the best solution
12:44:59 <lambdabot> forall a. (Ord a) => [a] -> [a] -> [a]
12:45:52 <sjanssen> that is O(length xs * log (length ys) + length ys * log (length ys))
12:46:25 <sjanssen> all other solutions are O(length xs * length ys)
12:48:21 <sjanssen> so it's better whenever log (length ys) is O(length xs) (ie. ys is not exponentially larger than xs)
12:49:22 * sjanssen killed the channel
12:49:29 <dons> wow, is it just me or is -cafe@ a bit ranty today?
12:49:51 <sjanssen> I haven't read my ml emails yet
12:49:57 <chessguy> heh. amusing translation of haskell to harry potter on -cafe
12:51:15 <LoganCapaldo> Is there a webified version of -cafe@?
12:51:27 <Saizan> gmail :D
12:51:32 <pejo> Logan, it's on gmane.
12:52:06 <LoganCapaldo> Saizan: Last I check gmail didn't have time travel capabilities to go look at emails from before I subscribed to something :)
12:52:55 <dons> gmane.org
12:56:21 <chessguy> heh. http://gmane.org/plot-rate.php?group=gmane.comp.lang.haskell.cafe is cool
12:56:28 <LoganCapaldo> Just in case anyone else is equally ignorant as regards -cafe@ as I, HP reference: http://permalink.gmane.org/gmane.comp.lang.haskell.cafe/21675
12:56:31 <lambdabot> Title: gmane.comp.lang.haskell.cafe
12:57:21 <tibbe> @docs Data.Array.Base
12:57:22 <lambdabot> Data.Array.Base not available
13:00:38 <tibbe> if I have several functions that takes ByteString as arguments but I want QuickCheck to generate different kinds of strings for the different tests
13:00:45 <tibbe> how would I do that?
13:01:26 <Orphi> hello... I have a Haskell program and truckloads of profiling data. anybody know how to make sense of it? :-}
13:01:35 <emu> newtype and write arbitrary functions which generate the kind of string you want
13:01:36 <sjanssen> tibbe: perhaps you could use a newtype of a ByteString?
13:01:53 <emu> Orphi: ghc prof data?
13:01:58 <Orphi> emu: indeed.
13:02:04 <emu> it should have a summary at the top
13:02:12 <tibbe> sjanssen, but could I use it instead of a ByteString in the property?
13:02:39 <thorat> ok, so which one is better, HSoE by Hudak, or ItFPuH by Bird & Wadler?
13:02:53 <thorat> :)
13:02:55 <tibbe> sjanssen, i.e. I add an: instance Arbitrary Literal where ..." but my prop_ will use instance Arbitrary ByteString right beacuse that's what the function expects
13:03:01 <emu> tibbe: you write, prop_foo (MyByteString ...) = ...
13:03:30 <tibbe> ok
13:03:32 <thorat> (just curious since I already own HSoE)
13:03:32 <Orphi> emu: I tried running with the +s RTS option, and I got a file that contains the line "  %GC time      62.9%  (62.8% elapsed)"
13:03:33 <tibbe> thanks
13:03:34 <emu> where newtype MyByteString = MyByteString ByteString or something
13:03:54 <Orphi> emu: does that mean my program is spending 60% of its time running the GC?
13:03:55 <emu> Orphi: oh, +s is a summary of run time
13:04:00 <emu> yes
13:04:04 <Orphi> o_O
13:04:11 <Orphi> that's a LOT of GC for a compute-bounded problem...
13:04:18 <kolmodin_> @tell dons could you bump the version of binary on the binary homepage? perhaps we could put it under haskell.org/binary so any of us can update it?
13:04:19 <lambdabot> Consider it noted.
13:04:31 <emu> Orphi: if you compile with -prof and run with -p then it will output a .prof file
13:04:42 <Orphi> emu: yeah, I have that too
13:04:55 <Orphi> emu: only seems to give time info, nothing about GC
13:05:08 <Saizan> there's also the allocation %
13:05:25 <emu> and memory info
13:05:44 <emu> GC time is not necessarily a bad thing
13:05:44 <Orphi> I see the memory usage info - but that's not the same as 'time spent sorting out memory' ;)
13:05:54 <emu> it's a bit counterintuitive
13:06:22 <emu> it's quite possible for GC time to be the significant %, but the overall time to be much better than expected
13:06:30 <Orphi> if you want counterintuitive... 30% of the runtime is being spent on 'quant8'
13:06:41 <Orphi> the source of this function is:
13:06:46 <Orphi> quant8 :: Double -> Word8
13:06:53 <emu> so the usual wisdom with haskell efficiency is: make it lazier, or make it stricter
13:06:59 <emu> @paste
13:06:59 <Orphi> quant8 x = floor $ x * 0xFF
13:06:59 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:07:17 <Orphi> that's IT. that's the whole function.
13:07:29 <Orphi> it performs 1 multiplication and converts a double to a word8
13:07:31 <emu> and it's invoked a ton?
13:07:46 <Orphi> several billion times, yes.
13:07:59 <emu> so 0xFF is 2^8-1
13:08:08 <Orphi> but so is the main "useful" function, and that's way more complex but only using 20% CPU...
13:08:34 <Orphi> so my program seems to be spending more time converting doubles to bytes then doing the calculations... :S
13:09:41 <Saizan> mmh it's probably not strict enough
13:09:44 <emu> could you arrange to convert the double first, then shift it left?
13:10:04 <Orphi> emu: 0 <= x <= 1 is the input
13:10:13 <Orphi> emu: the output is then 0 <= x <= 255
13:10:20 <emu> so you're mapping 0 to 1 onto 0 to 255
13:10:24 <Orphi> if I convert to double first, I'll just get lots of 0s...
13:10:30 <Orphi> emu: indeed.
13:11:24 <Orphi> is replacing lists with strict arrays likely to affect performance? (and in which direction?)
13:11:48 <emu> depends on the way you use them
13:12:10 <Orphi> program generates a sequence of image files; each image depends on the previous one
13:12:13 <randomity> Orphi, are you doing lots of lookups on static data?
13:12:21 <norpan> random access -> arrays
13:12:21 <Orphi> currently, each image is a (large) list
13:12:27 * LeCamarade goes off to sleep.
13:12:37 <randomity> Orphi, what operations do you perform on the list?
13:12:41 <emu> are they sharing structure?
13:12:42 <Orphi> just map, really
13:13:06 <Orphi> each new frame is generated by mapping a function over the old frame
13:13:07 <norpan> if you just map, then why do you need a list at all? :)
13:13:18 <dons> so anyone applying to Credit Suisse? :-)
13:13:19 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
13:13:31 <Orphi> ...wuh?
13:13:32 <dons> you want to hack haskell for a living, right?
13:13:47 <emu> no. it becomes no fun when it's a job.
13:14:10 <dons> heh
13:14:49 <dons> http://article.gmane.org/gmane.comp.lang.haskell.cafe/21652
13:14:51 <lambdabot> Title: Gmane -- Mail To News And Back Again
13:15:15 <Orphi> so... if I hold each frame in a strict array instead of a list, is it likely to go faster / use less RAM?
13:15:46 <emu> not necessarily
13:15:53 <emu> do you discard the old frames?
13:15:58 <Orphi> yes.
13:16:04 <Saizan> i do something similar and runs in constant space
13:16:06 <Orphi> only ever need the current one and the previous one.
13:16:17 <Orphi> I was thinking about *gasp* mutable arrays, actually...
13:16:32 <Orphi> might reduce GC load?
13:16:50 <emu> it could. you might try a Diff Array first.
13:17:19 <Saizan> Orphi, i use UArray and i think GHC managed to just use 2 allocated arrays and reuse their memory
13:17:42 <emu> sure they both share the Immutable interface.
13:17:44 <Orphi> Saizan: that sounds like less work for the GC...
13:17:44 <eumenides> what's CAF?
13:17:48 <Saizan> DiffArrays are no good when you are going to replace all the elements
13:17:59 <Orphi> CAF = Constant Applicative Form?
13:18:04 <Saizan> yes
13:18:07 <emu> something like that.
13:18:10 <emu> top level stuff
13:18:16 <eumenides> something in my .prof file
13:18:22 <Orphi> Saizan: yeah, I didn't think DiffArray would be good
13:18:25 <Saizan> eumenides, it's a value binded to a name, that doens't take parameters
13:18:40 <Orphi> Saizan: and since I definitely *need* ALL of the values, might as well be a strict array...
13:18:42 <Saizan> let caf = ...; notcaf x = ...
13:18:57 <Orphi> sadly, AFAIK, I can't "unbox" it
13:19:04 <bd_> Saizan: let isthisacaf = \x -> ... ?
13:19:06 <eumenides> Saizan: ahh. so... 80% of my memory use is global constants
13:19:07 <emu> Word8s?
13:19:16 <Saizan> bd_, yes
13:19:29 <bd_> Interesting. So it depends on the optimizer in the end I guess?
13:19:31 <Saizan> eumenides, not necessarily global
13:19:45 <Orphi> emu: each pixel is a semi-complicated data structure from which a colour is computed, not an actual colour value.
13:19:55 <Saizan> bd_: yeah, it's an implementation detail rather than a semantic one
13:20:19 <emu> if it's a tuple, you could use a tuple of arrays instead of an array of tuples
13:20:34 <Orphi> actually it's a pair of 2-vectors of doubles...
13:20:39 <randomity> Orphi, when you're actually using your data, do you go through it from start to end or do you need to hop around randomly?
13:21:06 <Orphi> randomity: order is unimportant. each new value depends only on the corresponding old value.
13:21:24 <Orphi> I'd *like* to make it go parallel... but I don't know how
13:21:38 <emu> @where dph
13:21:39 <lambdabot> http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
13:23:34 <Orphi> ...looks like it's not very finished yet.
13:23:43 <Orphi> (this seems to be common in Haskell... lol!)
13:23:46 <Saizan> Control.Parallel
13:24:11 <chessguy> Orphi: yeah, sometimes i think haskell's motto is "Patches are welcome!"
13:24:30 <Orphi> lol @ chessguy
13:24:40 <dons> oh, its in pretty good shape
13:24:42 <Cheery> any smart's people's motto is "Patches are welcome!"
13:24:43 <Orphi> you know, I keep misreading your name as "cheeseguy"...
13:24:49 <dons> check hackage.haskell.org for 'finished' things
13:24:58 <chessguy> Orphi: you have no idea how often i hear that
13:25:05 <Orphi> lolz again!
13:25:07 <Cheery> this is because one can always improve
13:25:09 <dons> for easy parallel arrays, well, no language has them :-) haskell comes close.
13:25:24 <dons> we at least have a library that works somewhat
13:25:30 <chessguy> dons: "patches are welcome" doesn't necessarily mean 'unfinished'
13:25:37 <Orphi> well, ya know, I have 2 cores, and a program that only maps a function over an array
13:25:39 <dons> yeah, patches are always welcome
13:25:46 <chessguy> yes, it's a good thing
13:25:59 <Gu1> i have a neophyte question... i'm working through this book i just bought "Programming in Haskell by Graham Hutton"  and i enter in the example code letter for letter, and still most of it doesn't work...
13:25:59 <Orphi> would be nice if it would "just work",,,
13:26:01 <dons> Orphi: well, there's already Control.Parallel for parMap on lists
13:26:14 <dons> Gu1: are you handling the symbols correctly?
13:26:14 <Gu1> isDigit  :: Char ->
13:26:24 <emu> parMap works nicely I can attest.
13:26:24 <dons> oh, you're putting that in a soruce file?
13:26:26 <Cheery> Gu1: then stop entering the example code letter for letter!
13:26:38 <emu> @paste
13:26:39 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:26:40 <Gu1> isDigit c  = c >= '0' && 'c' <= '9'
13:26:44 <dons> Gu1: those code fragments are expected to go into a source file.
13:26:50 <emu> Gu1: 'c'
13:26:51 <dons> which you can then load in hugs or ghci
13:26:57 <dons> ah also that.
13:27:00 <mauke> Gu1: missing Bool
13:27:10 <emu> well i guess that would compile
13:27:19 <Cheery> > let isDigit c = c >= '0' && 'c' <= '9'
13:27:19 <lambdabot>  Parse error
13:27:27 <Cheery> > let isDigit c = c >= '0' && 'c' <= '9' in isdigit 'E'
13:27:28 <lambdabot>   Not in scope: `isdigit'
13:27:34 <Cheery> > let isDigit c = c >= '0' && 'c' <= '9' in isigit 'E'
13:27:36 <lambdabot>   Not in scope: `isigit'
13:27:38 <Cheery> > let isDigit c = c >= '0' && 'c' <= '9' in isDigit 'E'
13:27:40 <lambdabot>  False
13:27:42 * Orphi looks up Control.Parallel
13:27:45 <Cheery> > let isDigit c = c >= '0' && 'c' <= '9' in isDigit '4'
13:27:47 <lambdabot>  False
13:27:51 <dons> ?docs Control.Parallel.Strategies
13:27:52 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Parallel-Strategies.html
13:27:53 <Cheery> .. :D
13:27:57 <emu> > 'c' <= '9'
13:27:58 <lambdabot>  False
13:28:01 <Cheery> > let isDigit c = c >= '0' || 'c' <= '9' in isDigit '4'
13:28:03 <lambdabot>  True
13:28:07 <Cheery> > let isDigit c = c >= '0' || 'c' <= '9' in isDigit 'E'
13:28:09 <lambdabot>  True
13:28:12 <emu> cheery.
13:28:13 <dons> Orphi: but you'll want to read up on concurrency in haskell a bit, and how to use multiple cores. check the ghc user's guide.
13:28:24 <tibbe> why is it important to declare a coarbitrary when using QuickCheck?
13:28:26 <Cheery> > let isDigit c = c <= '0' && 'c' <= '9' in isDigit 'E'
13:28:27 <emu> 'c' is not less than '9'
13:28:27 <lambdabot>  False
13:28:30 <dylan> 'c' <= '9' is always false...
13:28:32 <Cheery> > let isDigit c = c <= '0' && 'c' <= '9' in isDigit '5'
13:28:33 <lambdabot>  False
13:28:56 <Orphi> dons: hmm... ok... I think the *first* thing I'm going to do is switch from lists to strict arrays and see what that does to the speed.
13:28:57 <Cheery> oh, that bad thing
13:29:11 <Cheery> > let isDigit c = c <= '0' && c <= '9' in isDigit '5'
13:29:13 <Gu1> its a ^, and the book said that if i see a ^ to replace with &&
13:29:13 <lambdabot>  False
13:29:25 <Cheery> > let isDigit c = c >= '0' && c <= '9' in isDigit '5'
13:29:27 <lambdabot>  True
13:29:32 <Cheery> > let isDigit c = c >= '0' && c <= '9' in isDigit '#'
13:29:33 <lambdabot>  False
13:29:38 <Cheery> > let isDigit c = c >= '0' && c <= '9' in isDigit 'E'
13:29:39 <dylan> Cheery: you can talk to lambdabot in private
13:29:40 <lambdabot>  False
13:29:40 <dylan> btw
13:29:48 <chessguy> > let isDigit x = (read x) `elem` [1,2,3,4,5,6,7,8,9,0] in isDigit '2'
13:29:49 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
13:30:03 <emu> lambdabot offers private counseling services
13:30:17 <emu>  /msg lambdabot @yow
13:30:26 <Cheery> dylan: yes, but what's the point? I could then fire up ghci as well.
13:30:32 <Gu1> thanks for the help
13:30:58 <chessguy> > let isDigit x = (read [x]) `elem` [1,2,3,4,5,6,7,8,9,0] in isDigit '2'
13:30:59 <lambdabot>  True
13:31:06 <chessguy> > let isDigit x = (read [x]) `elem` [1,2,3,4,5,6,7,8,9,0] in isDigit 'a'
13:31:08 <lambdabot>  Exception: Prelude.read: no parse
13:31:17 <dylan> Cheery: @hoogle, etc
13:31:53 <Cheery> hmm, I see... thanks for the tip
13:31:58 <chessguy> > let isDigit x = (read $ show x) `elem` [1,2,3,4,5,6,7,8,9,0] in isDigit 'a'
13:32:00 <lambdabot>  Exception: Prelude.read: no parse
13:32:50 <dylan> > ['0' .. '9']
13:32:52 <lambdabot>  "0123456789"
13:32:52 <mauke> > let isDigit = (`elem` ['0' .. '9']) in isDigit 'a'
13:32:52 <Saizan> > let isDigit x = x `elem` "1234567890" in isDigit 'a'
13:32:55 <lambdabot>  False
13:32:55 <lambdabot>  False
13:33:11 <Saizan> stereo again?:D
13:33:22 <Cheery> > isDigit '2'
13:33:23 <lambdabot>  True
13:33:29 <dylan> > let isDigit x = x `elem` ['0' .. '9'] in isDigit 'a'
13:33:31 <lambdabot>  False
13:33:33 <dylan> > let isDigit x = x `elem` ['0' .. '9'] in isDigit '1'
13:33:35 <lambdabot>  True
13:33:38 <chessguy> @pl \x -> x `elem` "foo"
13:33:38 <lambdabot> (`elem` "foo")
13:33:52 <dylan> @pl isDigit x = x `elem` ['0' .. '9'] in isDigit '1'
13:33:53 <lambdabot> (line 1, column 35):
13:33:53 <lambdabot> unexpected reserved word "in" or "i"
13:33:53 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
13:34:00 <dylan> @pl isDigit x = x `elem` ['0' .. '9']
13:34:00 <lambdabot> isDigit = (`elem` ['0'..'9'])
13:34:07 <chessguy> nice
13:34:14 <Cheery> hmm
13:34:35 <Cheery> > (flip elem ['0'..'9']) 'E'
13:34:36 <Gu1> wow i'm amazed at how smart you guys are
13:34:36 <mauke> > let isdigit x = x == '2' in isDigit '3'
13:34:37 <lambdabot>  False
13:34:37 <lambdabot>  True
13:34:55 <Cheery> Gu1: this is not smart, this is wanking off
13:35:04 <Orphi> o_O
13:35:05 <Gu1> lol
13:35:12 <chessguy> @pl \x -> x == '2'
13:35:13 <lambdabot> ('2' ==)
13:35:52 <dylan> Cheery++
13:35:58 * Orphi groans
13:36:10 <Orphi> ok, which of the 47 array types is the one that's strict and immutable?
13:36:24 <Saizan> UArray
13:36:28 <Orphi> ty.
13:36:29 <Saizan> bbut unboxed
13:36:39 <Orphi> oh...
13:36:53 <Orphi> I need to use a custom data type - which, AFAIK, means it has to be boxed...?
13:37:08 <Saizan> mmh i think so
13:37:14 <Saizan> so just Array
13:37:19 <Cheery> Gu1: you are learning right? Best thing you could do is fire the ghci up yourself and toy with it
13:37:51 <Orphi> Saizan: not IArray?
13:38:06 <Saizan> IArray is the interface class
13:38:21 <Cheery> try this:   :t map (\a -> a + 20)
13:38:37 * Orphi is confused
13:38:45 <Orphi> so many arrays... so little time... lol!
13:38:47 <Cheery> then try: map (\a -> a + 20) [1..5]
13:39:05 <Saizan> IArray is a typeclass, UArray and Array are instances of it
13:39:19 <Saizan> ?wiki modern arrays
13:39:20 <lambdabot> http://www.haskell.org/haskellwiki/modern arrays
13:39:24 <Saizan> mmh
13:39:59 <Orphi> lol... stupid IRC client!
13:40:03 * Orphi types it manually
13:40:32 <Saizan> it's not right
13:40:39 <Orphi> you're right.
13:40:42 <Saizan> http://www.haskell.org/haskellwiki/Modern_array_libraries <-- here
13:40:44 <lambdabot> Title: Modern array libraries - HaskellWiki
13:40:48 <Orphi> still, the IRC client is stupid for missing out the rest... heh
13:41:52 <Saizan> http://www.haskell.org/haskellwiki/Modern_array_libraries#Unsafe_indexing.2C_freezing.2Fthawing.2C_running_over_array_elements <-- this is useful to know when mapping to the whole array
13:41:55 <lambdabot> Title: Modern array libraries - HaskellWiki, http://tinyurl.com/2hpyfg
13:42:23 <Orphi> ....right...so...I need the Array defined in Data.Array.IArray, not the one from Data.Array...?
13:42:24 <Saizan> mmh, maybe not
13:42:48 <Saizan> yes
13:43:08 <Orphi> ...ok then.
13:43:16 <Saizan> well, you just need to import Data.Array.IArray
13:43:25 <Saizan> ?docs Data.Array.IArray
13:43:26 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-IArray.html
13:43:41 <Orphi> ok. well now I know which package to read the docs for... lol
13:44:15 <Saizan> ?type amap
13:44:17 <lambdabot> Not in scope: `amap'
13:44:22 * SamB wonders if this is a good way to write tails on Streams
13:44:42 * Orphi looks at watch
13:44:55 <Orphi> hmm... so I think we can safely say I won't get this done tonight :-}
13:44:55 <pixel> if i understand correctly Modern_array_libraries, Data.Array is quite bad, Data.Array.Diff is the way to go?
13:45:28 <Orphi> pixel: I think it's saying Data.Array is superceeded by Data.Array.IArray (which contains an "Array")...
13:45:30 <Orphi> sheesh o_O
13:45:49 <Saizan> Data.Arrya.Diff is nice when you don't change so many items
13:45:56 <Orphi> indeed.
13:45:59 <Orphi> but I do ;)
13:46:03 <SamB> pixel: you do not understand correctly
13:46:17 <SamB> the situation is considerably more complicated
13:46:39 <Saizan> Orphi, they are actually the same Array
13:46:46 <SamB> apparantly, plain Arrays are more efficient sometimes
13:47:51 <Saizan> for example when the compiler can safely assume that you won't use older versions and just overwrites them
13:49:34 <pixel> SamB: if i understand correctly, when you don't use the old array (the non-modified one), it's always better to use DiffArray over Array
13:49:56 <SamB> pixel: not quite
13:50:05 <SamB> see, the MVar is not without cost
13:50:20 <SamB> or MVars...
13:50:53 <Saizan> pixel there are performance problems keeping the log of the changes to let you access the older versions
13:51:21 <SamB> they told me that it depends on how large the array is and how much you change at one time
13:52:26 * Saizan has experienced this
13:53:12 <Saizan> though they where not so bad as a comonadic [[a]]
13:53:18 * SamB probably should not be using it in the program he was working on when they told him this
13:53:51 <pixel> SamB, Saizan: is this issue mentionned anywhere?
13:54:05 <SamB> pixel: good question
13:54:11 <tibbe> they QuickCheck homepage is down, is there a mirror somewhere?
13:54:12 <pixel> i've not seen anything in Modern_array_libraries
13:54:54 <Saizan> ?where quickcheck
13:54:55 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
13:55:03 <dons> tibbe: QuickCheck is on hackage, if you need the src
13:55:08 <dons> ?hackage QuickCheck
13:55:08 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/QuickCheck
13:55:35 <pixel> talking about arrays, is there a better way to do: listToArray l = listArray (0, length l - 1) l
13:55:50 <dons> that's reasonable.
13:56:01 <[sid]> hi there. im new to haskell and im trying to get my head round the usage of the term "empty" before a variable?
13:56:06 <tibbe> dons, I need some explanation of coarbitrary and how to use it properly
13:56:11 <dons> [sid]: hmm?
13:56:12 <pixel> (fromList may be a better name though)
13:56:21 <dons> [sid]: do you have an example?
13:56:24 <[sid]> im looking at this function:
13:56:25 <[sid]> fetch :: Eq a => Tree a -> K -> Maybe (Entry a)
13:56:44 <[sid]> i understand taht it's taking a "tree a", a string "k" and maybe returning "entry a"
13:56:55 <[sid]> is k necessarily a string?
13:56:58 <emu> K is a type. not necessary a string
13:57:02 <[sid]> right ok
13:57:07 <kpreid> K is a particular type
13:57:09 <[sid]> K is a type, not a variable?
13:57:10 <kpreid> it will be defined somewhere
13:57:16 <kpreid> yes, because it is capitalized
13:57:17 <emu> [sid]: it's on the RHS of ::
13:57:23 <emu> and yes, it's capitalized
13:57:37 <dons> tibbe: basically , coarbitrary is used to generate random functoins over some type, given a generate for one argument to the function
13:57:52 <dons> tibbe: i foudn the source for Test.QuickCheck.hs the best way to see how to write coarbitraries
13:58:02 <dons> note that you only need them if you want QC to generate random functions for your type
13:58:07 <tibbe> dons, ok, I'll have a look, thanks
13:58:08 <[sid]> "Tree a", "K" and "Entry a" are all types?
13:58:15 <emu> [sid]: indeed
13:58:24 <dons> everything on the rhs of ::are types :-)
13:58:25 <tibbe> dons, I want to get rid of the warnings I get when running my QC tests
13:58:33 <hpaste>  SamB pasted "tails for streams?" at http://hpaste.org/1451
13:58:33 <dons> oh, coarbitrary = undefined
13:58:34 <dons> :-)
13:58:41 <tibbe> dons, :)
13:58:44 <dons> tibbe: then that'll get hit only if you ask for random functions
13:58:47 <dons> so i often do that
13:58:53 <emu> that's my most common defn of coarbitrary!
13:58:59 <[sid]> is "Entry a" just an arbitrary name?
13:59:05 <tibbe> dons, great, I'm not interested in random functions
13:59:08 <[sid]> i assume "Entry" was some kind of term?
13:59:15 <emu> [sid]: it is a type, defined somewhere
13:59:26 <emu> it has a type-parameter
13:59:27 <tibbe> dons, did you have something to color Core output?
13:59:31 <SamB> so how long until GHC uses .sos?
13:59:42 <norpan> Entry is a type constructor
13:59:44 <[sid]> is that function (maybe) returning 2 values?
13:59:44 <dons> tibbe: yeah, I use HsColour -tty
13:59:48 <ski> ~
13:59:48 <ski> /window 1
13:59:49 <norpan> Entry a is a type
14:00:00 <SyntaxNinja> @seen shapr
14:00:01 <lambdabot> I saw shapr leaving #haskell 1d 22h 45m 59s ago, and .
14:00:05 <[sid]> are "entry" and "a" seperate?
14:00:11 <emu> [sid]: Maybe is a type constructor as well
14:00:26 <SamB> dons: does that tails look reasonable? how would I test it?
14:00:27 <emu> data Maybe a = Nothing | Just a
14:00:31 <tibbe> dons, and why I have you on the line, is there a Show like class for ByteStrings?
14:00:51 <SamB> why the heck does it take so long to compile it...
14:01:00 <kpreid> [sid]: Entry is a type constructor, which takes one parameter, which is a type, and its result is a type.
14:01:18 <kpreid> Entry, Maybe, and [] are all type constructors with one parameter.
14:01:36 <emu> so Entry Char is a type formed by supplying the type Char to the type-constructor Entry
14:02:12 <[sid]> can i think of Entry, Maybe etc. as functions?
14:02:37 <dons> tibbe: there's Show for bytestrings
14:02:43 <emu> that might lead to confusion
14:02:51 <[sid]> im having problems getting my head around this, sorry for my ignorance, by the way.
14:03:13 <dons> tibbe: oh, you want to show values into bytestrings directly?
14:03:17 <SamB> dons: something is wrong...
14:03:24 <Saizan> they are a bit like functions, but they work on types, rather than on values
14:03:28 <dons> we don't have such a class. we do have Data.Binary, which serialises values into bytestrings.
14:03:28 <tibbe> dons, yes
14:03:30 <[sid]> ah right
14:03:35 <[sid]> ok
14:03:43 <SamB> when these tests fail, they don't report *what* function values they failed on!
14:03:45 <tibbe> dons, so right now I wrote a showTemplate instead
14:03:52 <emu> [sid]: basically... given any type "a", then "Entry a" is also a type
14:04:04 <dons> SamB: showing function values is a little tricky
14:04:13 <SamB> dons: not that tricky!
14:04:22 <tibbe> dons, the String type steals the good name "show" :)
14:04:23 <dons> less talk, more code.
14:04:26 <[sid]> why do you think "Entry" has been placed before "a"?
14:04:28 <dons> tibbe: indeed!
14:04:36 <[sid]> rather than just returning "a"
14:04:41 <emu> [sid]: it is the convention of haskell to place the constructor before the parameters
14:04:49 <emu> because the type is Entry a, not a
14:04:51 <SamB> @scheck \f x -> (f.f) x == (x :: I)
14:04:54 <lambdabot>   Failed test no. 3. Test values follow.: {-3->0;-2->0;-1->0;0->-1;1->0;2->0;...
14:04:59 <kpreid> [sid]: look at the definition of Entry; that will tell you why it is being used
14:05:34 <[sid]> ok
14:05:37 <[sid]> thanks
14:05:47 <tibbe> dons, I was thinking that you might have adopted some idiomatic way of writing it like "display"
14:06:28 <dons> no, but it would be useful to have a Show-ish class that packed into bytestrings instead
14:06:40 <dons> though not as useful as binary packing into bytestrings, i'd argue
14:07:13 <tibbe> dons, what do you mean by binary packaging?
14:07:35 <dons> using the Binary class to read/show data into bytestrings
14:07:39 <dons> ?hackage binary
14:07:39 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
14:08:31 <tibbe> dons, I represent my string templates as BSs and it's sometimes useful to be able to give the user the actual template as a BS instead of rendering it
14:08:56 <tibbe> dons, oh, I see
14:09:41 <tibbe> perhaps we could make a Stringable class ;)
14:09:48 <tibbe> does polymorphism cost that much?
14:13:13 <dons> Stringable scares me
14:13:16 <SamB> dons: hey, the tests for darcs "lists" are dying on me:
14:13:23 <SamB> Properties/Monomorphic/StreamList.hs:341:28:
14:13:23 <SamB>     Not in scope: `Stream.lines'
14:13:26 <tibbe> dons, why?
14:13:28 <sjanssen> a Stringable class is okay for reading strings, but it isn't so good for creating strings
14:13:39 <dons> SamB: hmm, let me see.
14:13:50 <SamB> also some fail
14:13:50 <sjanssen> the strategies for efficiently creating [Char] vs. ByteString are so very different
14:14:07 <dons> SamB: a couple are expected to fail (for issues of strictness)
14:14:16 <tibbe> dons, will we have bytestring literals in ghc 6.8, if so, how will they work? i.e. will I be able to use both String and ByteString literals?
14:14:40 <dons> hmm, just about.
14:14:48 <dons> we have the string literal overloading now
14:14:49 <sjanssen> unfoldr is the only common efficient builder, but I can't see writing a Show-like framework with it
14:14:52 <dons> its just not been widely tested
14:15:08 <bluestorm> hm
14:15:14 <bluestorm> http://haskell.org/haskellwiki/Image:Haskellwiki_logo_big.png
14:15:16 <lambdabot> Title: Image:Haskellwiki logo big.png - HaskellWiki
14:15:18 <bluestorm> is it "recent content" ?
14:15:20 <tibbe> sjanssen, my interface would be easier to use if I allow the user to pass either [(ByteString, ByteString)] (or a Map) for efficiency but a [(String, String)] for convenience
14:15:28 <bluestorm> (i was considering using it on wikipedia)
14:15:48 <sjanssen> tibbe: oh?  What are you writing?
14:16:02 <bluestorm> ( dons : did you create that image yourself ? )
14:16:24 <dons> bluestorm: yeah, its recent content ,free for all
14:16:45 <tibbe> sjanssen, a small string substitution library: i.e. "substitute (B.pack "Hi there $name") [("name", "sjanssen")]"
14:16:46 <bluestorm> hm, great
14:17:07 <SamB> so is someone using tests like these to compare Data.List with "Spec.List"
14:17:12 <SamB> ?
14:17:15 <tibbe> right now I have a Context class that defines lookup which have both String and ByteString instances
14:17:36 <tibbe> sjanssen, internally the templates are stored in an efficient bytestring representation
14:18:14 <dons> SamB: we are. that's all.
14:18:23 <dons> SamB: ah I get it.
14:18:23 <dons> Properties/Monomorphic/StreamList.hs:341:28:
14:18:23 <dons>     Not in scope: `Stream.lines'
14:18:32 <dons> let me check. oh, its because we don't provide Stream.lines anymore
14:18:36 <dons> since our code was too strict
14:18:48 <dons> and its not obvious how to do it fully lazily on streams, efficiently
14:18:51 <tibbe> sjanssen, I imagine that anyone who uses it for performance will go bytestrings all the way but it would be nice to use: substitute "Hello, $name!" [("name", "sjanssen")] for convenience
14:18:57 <SamB> what happened to running tests before committing?
14:18:58 <sjanssen> how safe is it to put your SSH public key online?
14:19:03 <sjanssen> can they be brute forced?
14:19:15 <emu> as secure as ssh is
14:19:41 <SamB> sjanssen: well, if you are handing it out to random people on the internet so that they will let you use their computers anyway...
14:19:54 <SamB> ... how do you know they have not already done that?
14:20:07 <sjanssen> SamB: you can't know, but you can be reasonably certain
14:20:30 <SamB> not that they would have done it with any kind of ill-intent
14:20:52 <SamB> anyway they are called "public keys"
14:21:03 <dons> btw, i've a new talk on stream fusion available now, http://www.cse.unsw.edu.au/~dons/talks/talks/lists-streams-nothing-07.ps.gz
14:21:05 <lambdabot> http://tinyurl.com/227g4d
14:21:09 <dons> though that url looks wrong..
14:21:29 <emu> "breaking" the public key is effectively equivalent to factoring the really large number
14:21:31 <SamB> so if they are of a secure enough type
14:21:53 <SamB> emu: is this a normal number or some wierd type?
14:22:01 <dons> here, http://www.cse.unsw.edu.au/~dons/talks/lists-streams-nothing-07.ps.gz
14:22:02 <lambdabot> http://tinyurl.com/29ogk5
14:22:04 <emu> it's a number which is the product of two large prime numbers
14:22:29 <emu> prime numbers p and q, the number N = pq, and the totient of N is (p-1) (q-1)
14:22:39 <SamB> emu: isn't it actually modulo some base?
14:22:49 <SamB> or something.
14:22:53 * SamB is confused
14:22:54 <sjanssen> emu: is it computationally feasible to attack a SSH pubkey?
14:22:56 <emu> so the public key is (e,N) where e is relatively prime to N
14:23:19 <emu> the private key is (d,N) where d is congruent to e^(-1) mod totient(N)
14:23:39 <emu> sjanssen: generally no, otherwise SSH would be insecure
14:23:45 <emu> maybe if you are the NSA
14:23:52 <SamB> sjanssen: make sure you are using the more recent kinds
14:24:06 <emu> we're talking about RSA here, right?
14:24:08 <dons> sjanssen: re. releasing, i suppose we host the tar balls on hackage, for xmonad and X11-extras
14:26:11 <emu> factoring is in NP and co-NP, for what its worth
14:27:54 <randomity> emu, really?
14:28:34 <randomity> is factoring really in NP?
14:28:46 <emu> yes
14:28:53 <randomity> has it been proven?
14:29:10 <DRMacIver`> It's not known to be NP complete though is it?
14:29:10 <emu> the decision problem is "Can N be factored with fewer than k primes"
14:29:19 <emu> i hope it's not NP complete
14:29:25 <emu> because that would collapse NP and coNP
14:30:07 <Saizan> http://www.rsa.com/rsalabs/node.asp?id=2093 <-- they are quite intractable it seems :)
14:30:08 <emu> randomity: to show that it is in NP, all you need to do is show that a proof of a solution is polynomial in length
14:30:10 <lambdabot> Title: RSA Laboratories - The RSA Challenge Numbers
14:30:30 <randomity> emu, yes, sorry. I thought you meant in NP but not in P
14:30:37 <emu> randomity: a proof of "Can N be factored with fewer than k primes" would be a set of primes
14:30:43 <emu> ok
14:30:50 <emu> yea i don't know about P =)
14:30:58 <monochrom> The thought of a "functional axiom of choice" blows my mind!
14:31:18 <DRMacIver`> Oddly, a proof that it wasn't in P would be rather significant. :)
14:31:38 <emu> yes, that would be
14:31:40 <randomity> yes, which I why I was surprised when I wrongly thought that's what emu said
14:31:49 <monochrom> An exam question asked me "is this in P? is this in NP?"  I answered "P" and forgot to add "NP".  Lost one mark.
14:32:01 <emu> hehe
14:32:05 <emu> and coNP
14:32:15 <randomity> and EXPTIME
14:33:11 <randomity> monochrom, what is this functional axiom of choice you mentioned?
14:33:12 <tibbe> @paste
14:33:13 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:34:10 <hpaste>  tibbe pasted "How can I force type to (Map ByteString ByteString)?" at http://hpaste.org/1452
14:34:21 <emu> primality is in P, though
14:34:27 <emu> crazy stuff
14:34:40 * emu needs to go look that up
14:34:55 <randomity> yes, that is strange
14:35:15 <monochrom> On the ghc mailing list some exotic type was mentioned. A witness of that type is akin to the axiom of choice. (The type is full of forall, exists, and ->)
14:35:48 <randomity> oh dear god
14:35:50 <randomity> wonderful
14:36:18 <randomity> here's something almost as randomly idiotic: repeat 1 ++ repeat 2
14:36:28 <randomity> the second 2 is at position omega+1
14:36:39 <randomity> where omega is the first transfinite ordinal ;-)
14:36:43 <emu> lemme try that
14:36:51 <emu> > (repeat 1 ++ repeat 2) !! (omega+1)
14:36:52 <lambdabot>   Not in scope: `omega'
14:36:55 <emu> doh
14:37:16 <emu> stupid lambdabot, doesn't know about transfinite ordinals
14:37:27 <randomity> silly
14:38:06 <randomity> here: omega = foldl1 max [1..]
14:38:17 <Saizan> there's nothing that prevents the first repeat to continue after reaching the cardinality of N if you assume the existence of transfinite lists
14:38:41 <Saizan> (imo)
14:39:03 <doserj> saizan: we are in a least fixed point world here
14:39:43 <Saizan> in fact i's say repeat 1 ++ repeat 2 == repeat 1
14:40:10 <Saizan> s/i's/i'd/
14:40:17 <randomity> Saizan, only if you *don't* assume the existence of transfinite lists
14:40:29 <randomity> which of course, don't exist, so you're right, I suppose
14:40:50 <emu> hmm, forall x\in [1..] union [0,-1,..] then (x>0)?
14:40:58 <DRMacIver> One needs to make a few concessions to implementation details. :)
14:41:54 <Saizan> well even with transfinite lists you can have transfinite copies of 1
14:42:00 <monochrom> Physical computation cannot attain transfinite ordinals.
14:42:03 <Heffalump> clearly you need to think more like a mathematician
14:42:32 <randomity> (concat $ repeat $ repeat 1) ++ repeat 2
14:42:41 <randomity> has the first 2 at index omega^2
14:42:43 <randomity> I think...
14:42:48 <randomity> :D
14:43:24 <Heffalump> how does omega^2 differ from omega?
14:43:31 <Saizan> mmh it depends on how you define repeat anyway
14:43:34 <randomity> it's bigger
14:43:44 <norpan> omega^2 contains an infinite number of omegas
14:43:45 <randomity> these are ordinals, not cardinalities
14:43:54 <emu> powerset of omega
14:44:01 <randomity> is it?
14:44:06 <emu> or is that 2^omeg
14:44:09 <emu> lol
14:44:11 <randomity> :D
14:44:20 <Heffalump> it's not bigger
14:44:26 <randomity> yes it is
14:44:33 <Heffalump> consider the standard diagonalisation argument for why Q = Z
14:44:36 <randomity> these aren't cardinalities
14:44:38 <DRMacIver> It's bigger in ordinality, not cardinality.
14:44:40 <Saizan> as omega+1 is bigger than omega
14:44:44 <Heffalump> oh, I see.
14:44:57 <Heffalump> I still don't buy this argument.
14:45:04 <Heffalump> what does an infinite ordinal mean?
14:45:14 <monochrom> do you already know ordinals?
14:45:22 <randomity> one which is a proper superset of all of the natural number's ordinals
14:45:29 <DRMacIver> An ordinal is a canonical representation of a isomorphism type of well ordered sets.
14:45:44 <randomity> Or, an ordinal is the set of all ordinals less than it
14:45:47 <DRMacIver> e.g. omega is the ordinal corresponding to the natural numbers.
14:46:02 <Heffalump> ok, perhaps I'm just ignorant
14:46:13 <DRMacIver> omega + 1 is the ordinal corresponding to the natural numbers with an extra element that is defined to be greater than all the natural numbers.
14:46:14 <monochrom> http://www.cs.toronto.edu/~trebla/transfinite.txt  helps
14:46:16 <DRMacIver> etc.
14:50:05 <sjanssen> hmm, what is the correct way to tell Cabal to package a README in Setup sdist?
14:52:34 <bos31337> sjanssen: extra-source-files
15:01:40 * dmwit starts trying to factor RSA-896 in ghci
15:02:04 <dons> i'd use ghc -O2 ;-)
15:03:02 <dmwit> Eh, I'm not worried, its square root is only 6.4e134.
15:03:09 <dmwit> How long can it possibly take?
15:03:40 <dons> heh
15:03:51 <dmwit> Don't worry, I'll run it in the background. ;-)
15:03:53 <sorear> hello!
15:03:59 <dmwit> Hi sorear!
15:04:00 <t0mas> hi
15:04:02 <sorear> actually, ghci should be as fast as ghc for this.
15:04:16 <sorear> since GMP is always hand-optimized, even with --interactive
15:04:44 * dmwit . o O (sorear has magical reverse-time lag so he can read things that happened before he arrived!)
15:04:52 <t0mas> I think I've been working for a bit too long.. but I need a function like this: func :: Int -> Int
15:05:05 <t0mas> which pops up a wxHaskell dialog
15:05:17 <t0mas> with two buttons to raise or lower the number..
15:05:33 <t0mas> but.. then I guess I need an Int -> IO(Int) function.. or something?
15:05:42 <t0mas> and that's not what fits in the other part of my application :(
15:05:42 <sorear> you really, really, really want that to be in IO, yes
15:05:46 <dmwit> I'm not familiar with wxHaskell, but it sounds like it would have to be Int -> IO Int...
15:06:11 <t0mas> but.. Int -> IO Int doesn't fit in the place where I need this..
15:06:18 <t0mas> how do I get IO Int back to Int?
15:06:22 <sorear> dmwit: indeed, I have a shell script that automates it. 'l i -0'
15:06:33 <sorear> t0mas: use >>=
15:06:58 <t0mas> where?
15:08:05 <dmwit> t0mas: You will have to do the dialog popup in the IO monad, then pass the value out from the monad to a pure function.
15:08:16 <dmwit> For example, something like:
15:08:40 <dmwit> main = popup >>= print . purefunc
15:09:39 <kuribas> Does haskell have something like printf or format?
15:09:44 <t0mas> hmz.. but.. I'm doing this now: otherFunc (x:xs) = (func x) : xs
15:09:51 <t0mas> (the simplest example possible)
15:10:03 <t0mas> where func is my Int -> Int function
15:10:26 <Saizan> > printf "%.3f" (1/3)
15:10:28 <lambdabot>  Add a type signature
15:10:36 <Saizan> > printf "%.3f" (1/3) ""
15:10:37 <lambdabot>  Add a type signature
15:10:44 <Saizan> > printf "%.3f" (1/3) :: String
15:10:46 <lambdabot>  "0.333"
15:10:55 <dmwit> t0mas: You'll have to shuffle things around a little... =(
15:11:15 <t0mas> oh ow :)
15:11:55 <t0mas> is there a way to wrap it up in another function?
15:12:10 <t0mas> like: wrapper :: Int -> Int
15:12:18 <t0mas> and do something with the func :: Int -> IO Int?
15:12:20 <kuribas> Saizan: Ah, thanks.
15:12:24 <dmwit> t0mas: Not really, unless you have some hex diagrams handy to summon demons from the pits of hell.
15:12:36 <Saizan> they will still be in IO
15:12:53 <procyon112> I hate those hex demons... They bite
15:12:53 <dmwit> t0mas: Without some more context, it will probably be a little bit difficult for us to help you more than to say, "Refactor!"
15:13:15 <t0mas> hmhm, I'll try to cut and paste this part out of the code?
15:13:24 <dmwit> procyon112: Hex demons are friendly, it's the decimal demons that are really killer. ;-)
15:13:48 <nominolo> @where hpaste
15:13:48 <lambdabot> I know nothing about hpaste.
15:13:58 <Saizan> !paste
15:13:58 <hpaste> Haskell paste bin: http://hpaste.org/
15:14:01 <eumenides> @type System.IO.Unsafe.unsafePerformIO
15:14:04 <lambdabot> forall a. IO a -> a
15:14:08 <nominolo> there you go
15:14:18 <t0mas> quick context: I have a datatype consisting of some Int's and Strings.. and I need a dialog to edit it.. and then put it back in the list where it was..
15:15:14 <dmwit> t0mas: The quick answer is, write a function to take an old list and a new entry, and that yields the new list.  Then call that from inside the IO monad.
15:15:51 <dmwit> Wow, there's a whole System.IO.Unsafe *module*?
15:15:58 * dmwit goes hoogling
15:15:59 <Saizan> you are going to use mapM i think
15:16:45 <hpaste>  Ts pasted "IO trouble" at http://hpaste.org/1453
15:16:48 <nominolo> t0mas: do (ints', strings') <- displayDialog (ints, strings); doStuffWith (ints', strings')
15:16:54 <dmwit> Oh, there's only two functions in it. =P
15:16:57 <t0mas> Ts was m :)
15:16:59 <t0mas> *me
15:17:31 <t0mas> the edit function takes a list of items, and an index for which one to edit
15:17:31 <sorear> @seen
15:17:43 <dmwit> :t foldM
15:17:46 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
15:17:59 <nominolo> t0mas: that's all?
15:18:08 <t0mas> that's the smallest possible example?
15:18:26 <t0mas> didn't want to bother you with a huge file?
15:18:33 <nominolo> hm, but I guess you problem is how to integrate this with IO
15:18:59 <nominolo> so it would be helpful to know the context of where you want to use these functions
15:19:13 <t0mas> yes the problem is where to integrate with IO..
15:19:49 <t0mas> it gets called from a wxHaskell event handler.. on a ListCtrl
15:20:53 <nomeata> I wonder: Shoudnât ByteStringâs concat or append functions check first if the strings are already adjungent in the memory?
15:21:29 <nomeata> Otherwise going through a file and escaping just a few characters will involve a lot of memcpy
15:21:48 <sjanssen> nomeata: it certainly could, but it doesn't sound like a frequently useful thing
15:22:05 <t0mas> but there is no easy way to do something like this?
15:22:06 <sjanssen> nomeata: if you're doing any modifications, the strings won't be adjacent anymore
15:22:17 <sorear> nomeata: use lazy bytestrings!
15:22:38 <sorear> then only one memcpy will be needed.
15:22:52 <SamB> nomeata: you want to concatMap an escaping function over a bytestring?
15:22:55 <sorear> or perhaps better yet, Data.Binary.Builder
15:23:07 <sorear> @uptime
15:23:08 <lambdabot> uptime: 2d 19h 56m 51s, longest uptime: 5d 3h 40m 45s
15:23:11 <sorear> @users
15:23:12 <lambdabot> Maximum users seen in #haskell: 336, currently: 318 (94.6%), active: 45 (14.2%)
15:23:21 <nomeata> sjanssen: well, if i use a code similar to this: escape (c:r) = (fromMaybe [c] $ lookup c escapes)  ++ escape r (using ByteString functions) it would chop it all up, woudnât it?
15:23:35 <nomeata> SamB : something like that, yes
15:23:46 <sjanssen> nomeata: don't write ByteString code that does frequent appends
15:24:13 <SamB> sjanssen: what would be a nice way to write escaping code?
15:24:40 <cddar> is this appropriate for tail recursion: "rest <- myRecursiveFunction someVar; return rest" ?? Or do I need to write "(myRecursiveFunction someVar) >>= return" ? Or what is tail recursion in IO functions?
15:25:03 <nomeata> ?paste
15:25:04 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:25:08 <SamB> cddar: you can skip the >>= return
15:25:10 <sjanssen> cddar: both of those are the same as myRecursiveFunction someVar
15:25:36 <sjanssen> according to the monad laws: m >>= return = m
15:25:37 <hpaste>  (anonymous) pasted "good way to do it?" at http://hpaste.org/1454
15:25:45 <Heffalump> to think about what tail recursion is in IO, thing of it as a state monad
15:26:16 <cddar> hmm
15:26:25 <sjanssen> SamB: I'd use span to find chunks that don't need escaping, then only append when escaping is necessary
15:26:32 <cddar> thanks
15:26:34 <hpaste>  nomeata annotated "good way to do it?" with "typo" at http://hpaste.org/1454#a1
15:26:41 <nomeata> sjanssen: just what Iâm doing there :-)
15:26:46 <SamB> sjanssen: that doesn't sound very pretty :-(
15:26:46 <sjanssen> SamB: I'd also use a lazy ByteString to make the appends cheap (essentially free)
15:27:07 <nomeata> sjanssen: but you still donât want so chop it up into single chars
15:27:12 <sjanssen> nomeata: the code you pasted doesn't do that
15:27:15 <nomeata> sjanssen: then you can just use [Char] directly :-)
15:27:27 <nomeata> sjanssen: I mean the hpaste, not the in channel paste
15:28:11 <sjanssen> nomeata: yeah, that code looks good
15:28:13 <SamB> sjanssen: is there no one-liner?
15:28:23 <dmwit> Whoa, nomeata, is dat sum fancy single-quote?
15:28:51 <SamB> (minus the code to actually do escaping / determine if it is needed)
15:28:51 <sjanssen> SamB: nomeata's version is only 4 lines
15:28:51 <sorear> Who should and who shouldn't set Milestone: fields in trac?
15:29:14 <sjanssen> sorear: I'd say GHC HQ should
15:29:25 <nomeata> dmwit: you mean this âââ?
15:29:35 <dmwit> yep
15:29:56 <sorear> nomeata: why so many ?s ? ;)
15:30:50 <dmwit> sorear: He's copy-pasting from Microsoft Word. ;-)
15:30:58 * sorear barfs
15:31:01 <cddar> what is the mtl package?
15:31:09 <dmwit> ?hackage mtl
15:31:10 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mtl
15:31:13 <sorear> monad transformer library
15:31:20 <narain> ?help hackage
15:31:21 <lambdabot> Plugin `help' failed with: IRCRaised Plugin/Dummy.hs:(23,19)-(46,62): Non-exhaustive patterns in case
15:31:24 <sorear> you need it to do more or less anything.
15:32:02 <sorear> you really really ought to install it, your distro maints should be flogged if they didn't add a Recommends: or equivalent
15:33:12 <Saizan> i wonder why it's not just packaged inside ghc6 in debian for example
15:33:23 <SamB> has Igloo been duly flogged?
15:33:34 <sorear> Igloo is a distro maint?!
15:33:54 <qwr> sorear: debian ghc6 package doesn't recommend anything ;)
15:33:59 <sorear> iirc dcoutts is gentoo, arjanoosting is debian
15:34:10 <nomeata> sorear: no, thatâs UTF8. Nice to write things like Î»Î± â Î±Â·Î±
15:34:10 <SamB> sorear: he is the maintainer for most GHC-related debian packages, afaik!
15:34:49 <Adamant> how do you write UTF with an English keyboard?
15:34:58 <sorear> he maintains ghc, i see
15:35:01 <Adamant> I mean, the extra symbols
15:35:02 * sorear glares at Igloo
15:35:17 <sorear> Adamant: M-S-: (insert-char 1000)  ;)
15:36:01 <Saizan> sorear: how i'd like to write code that way!
15:36:09 <Adamant> lol, I have an aversion to using Emacs as my IRC client. :)
15:36:22 <SamB> Saizan: it isn't packaged inside because... that would remove all benefit of packaging it seperately?
15:36:36 * Igloo isn't planning on bundling any random libs into the ghc package, nor having it recommend them
15:36:56 <Saizan> SamB which are?
15:36:57 <Igloo> as I can't see why one would be bundled/recommended and another not
15:37:12 <sorear> because everyone uses mtl?
15:37:18 <SamB> Saizan: ... ask igloo ;-)
15:37:22 <Igloo> Not true
15:37:27 <sorear> and it would kill the #-single-digit bugrep on #haskell
15:37:35 <qwr> because you can't do almost anything useful without mtl?
15:37:44 <SamB> Igloo: because we say so?
15:37:54 <SamB> and we are the users, and the users are not always wrong.
15:38:10 <Igloo> Saizan: Separate libs can have newer versions released without recompiling the whole thing
15:38:22 <Igloo> Also, less time is wasted when a ghc6 build fails
15:38:43 <Igloo> And the same lib source can be used for all the implementations
15:38:45 <SamB> Igloo: anyway, the mtl is one of the first extra libraries many of us reach for
15:38:51 <dmwit> But not a recommended?
15:38:56 * qwr remembers wondering where the fuck are List functions when first using debian ghc
15:38:59 <Saizan> so, a meta package maybe?
15:39:13 <SamB> quickcheck should get the same treatment...
15:39:18 <qwr> suggests or recommends would be enough imho
15:39:23 * Heffalump thinks a meta package would be good
15:39:27 <SamB> qwr: they are in Data.List
15:39:28 <sorear> Igloo: your arguments only apply to bundling.  bundling /= recommending
15:39:57 <sjanssen> how does Debian respond to a 'recommending'?
15:39:59 <SamB> sorear: Saizan wanted to know why it was not bundled ;-)
15:40:12 <SamB> sjanssen: ask not how Debian responds
15:40:24 <qwr> SamB: or was it liftM... i don't remember exactly. something common
15:40:28 <SamB> ask instead how aptitude, synaptic, etc. respond
15:40:41 <Igloo> sorear: Why recommend one library and not another?
15:40:42 <sjanssen> SamB: how the install tools respond, then
15:40:56 <sorear> Igloo: allow me to quote debian policy at you...
15:41:08 <sorear> 7.2: The Recommends field should list packages that would be found together with this one in all but unusual installations.
15:41:12 <SamB> Igloo: why recommend one game and not another?
15:41:44 <SamB> also notice the frequency with which people have run into problems due to not having the mtl
15:41:47 <sorear> show of hands: who has GHC but not MTL installed?
15:41:53 <sorear> who has GHC and MTL?
15:41:54 <Igloo> sorear: IMO the ghc tarball is a normal installation, and extralibs are abnormal
15:42:01 <SamB> I have both!
15:42:05 <Igloo> SamB: Eh?
15:42:06 <SamB> I hope!
15:42:12 <sorear> is the ratio high enough for MTL to be considered unusal?
15:42:50 <SamB> sorear: at this rate one wonders why Igloo bothers to package it ;-P
15:44:23 <SamB> (nobody else says they have GHC at all yet!)
15:44:37 * sjanssen refuses to vote
15:44:40 <Saizan> i have two!
15:44:54 <Saizan> both with extralibs
15:44:59 <nomeata> Adamant: Iâve set some characters using xmodmap
15:45:06 <qwr> it would be easier to ask, who has ghc without mtl ;)
15:45:13 <clanehin> Perhaps there is some way to make popularity context notice when certain packages are always installed together?
15:45:22 <clanehin> Then we won't have to take irc polls.
15:45:32 <sjanssen> clanehin: yeah, like amazon.com!
15:45:47 <SamB> clanehin: what if you have a bunch of people who haven't figured out what they are doing
15:45:51 <SamB> or have older GHCs
15:45:59 <Adamant> nomeata, thanks
15:46:12 <sjanssen> Users that have installed 'ghc' typically install 'mtl', would you like to install 'mtl'?
15:46:34 <clanehin> SamB: I think the lack of any sound science underlying it is why they call it "popularity contest", as though running for high school student council or something
15:46:37 <dmwit> Users who searched for this package also looked at: ...
15:46:37 <dmwit> =)
15:47:08 <clanehin> sjassen: maybe popcon-clippy only talks to DDs, not users
15:47:08 <SamB> clanehin: I thought it was called that because it counted how popular a given package was among users of popularity-contest
15:47:29 <Saizan> sjanssen, with some newspaper quotes on how mtl is cool?
15:48:08 <qwr> yes and how all girls like mtl
15:49:21 * eumenides wishes ghc could just infer to derive Show/Read based on my use of show/read instead of having to tell it so explicitly
15:49:56 <SamB> eumenides: it has to be sure you didn't plan to define your own instance!
15:50:04 <nomeata> Adamant: http://www.joachim-breitner.de/blog/archives/188-Typographische-Anfuehrungszeichen.html (in German though)
15:50:07 <lambdabot> Title: Typographische AnfÃ¼hrungszeichen - nomeata's mind shares, http://tinyurl.com/27spex
15:50:39 <huschi> what is a good name for a function with type "Monad m => String -> Maybe a -> m a" and definition "\msg -> maybe (fail msg) return"?
15:50:47 <huschi> maybeFail?
15:50:50 <sorear> Igloo: according to popcon, mtl is the most popular haskell lib by a factor of 2
15:50:54 <huschi> or maybeToMonad?
15:51:15 <SamB> cool!
15:51:23 <SamB> solid evidence!
15:52:09 <sorear> Igloo: and libghc6-doc has 0 users, btw ;)
15:52:15 <sorear> s/lib//
15:52:43 <LordBrain> where do you get the stats from popcon?
15:53:03 <dons> oh nice. i'd expect that to be the case though: mtl is almost core haskell :-)
15:53:05 <Saizan> huschi, do you need the String? i'd use mzero if not
15:53:20 <sorear> Oh, I see I was misreading the figures.
15:53:28 <sorear> it's even cooler now
15:53:42 <sorear> > 100 * 164 / 175
15:53:43 <lambdabot>  93.71428571428571
15:53:56 <sorear> 93% of people who actively use GHC have MTL installed.
15:53:57 <huschi> Saizan: I want an message that describes the error somehow. without, tracking it down becomes to difficult.
15:54:40 <LordBrain> what does the acronym stand for? mtl
15:54:51 <sorear> monad transformer library
15:55:02 <sorear> LordBrain: popcon.debian.org
15:55:17 <nomeata> good night everyone
15:55:24 <sorear> goodnight!
15:55:36 <SamB> Igloo: is that good enough for you?
15:56:51 <clanehin> As long as we're giving Igloo a hard time and/or he's actually adding recommends, there's also 405227
15:57:17 <sorear> ghc6 suggests a package with 0 users (ghc6-doc), but doesn't mention a package with >150 users (libghc6-mtl-dev)
15:57:36 <sorear> clanehin: 405227 in what db?
15:57:46 <clanehin> debian bugs
15:59:50 <vali> hmm, is there any site where i can find example usage of functions in haskell? i am trying to figure out how to use "filter"
16:00:42 <qwr> > filter isUpper "Monad Transformer Library"
16:00:44 <lambdabot>  "MTL"
16:01:14 <sorear> > iterate (filter isDigit . show . group) "1"
16:01:16 <lambdabot>  ["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"...
16:01:28 <vali> qwr: hmm. how is isUpper defined? it's a function that takes "a" and returns "Bool"?
16:01:29 <sorear> > iterate (filter isDigit . show . map (length &&& head) . group) "1"
16:01:30 <lambdabot>  ["1","11","21","1211","111221","312211","13112221","1113213211","31131211131...
16:01:50 <narain> :t isUpper
16:01:53 <lambdabot> Char -> Bool
16:02:04 <narain> vali: ^^^
16:02:05 <qwr> vali: no, it takes Char. like 'A'. String is [Char]
16:02:11 <qwr> :t filter
16:02:14 <vali> oh
16:02:14 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
16:02:27 <ddarius> @google zvon
16:02:29 <lambdabot> http://www.zvon.org/
16:02:29 <lambdabot> Title: ZVON.org - ZVON
16:03:44 <ddarius> vali: http://www.zvon.org/other/haskell/Outputglobal/index.html
16:03:48 <lambdabot> Title: Haskell
16:04:25 <narain> hey, that does look like a nice reference for beginners
16:04:50 <vali> ddarius: ooooh, exactly what i need. thank you!
16:05:10 <narain> vali: you are aware that in the type of filter above ((a -> Bool) -> [a] -> [a]), a is a variable?
16:05:37 <vali> narain: i just understood that now
16:07:07 <vali> i am trying to filter a list returning only the values that are multiples of x and y
16:07:18 <vali> x or y i mean
16:08:53 <qwr> :t \x y -> filter (\z -> mod z x == 0 || mod z y == 0)
16:08:55 <lambdabot> forall a. (Integral a) => a -> a -> [a] -> [a]
16:09:16 <vali> and of course i automatically start thinking: if mod x 3 or mod x 5 then True
16:09:40 <narain> vali: you can do that too
16:09:57 <vali> narain: if there is a more haskellish way i would like to use that
16:10:25 <qwr> vali: i just gave it ;)
16:10:35 <vali> qwr: thank you
16:10:56 <narain> :t filter (\x -> if x `mod` 3 == 0 || x `mod` 5 == 0 then True else False) -- let's take this through a little Haskellification
16:10:59 <lambdabot> forall a. (Integral a) => [a] -> [a]
16:11:12 <narain> :t filter (\x -> x `mod` 3 == 0 || x `mod` 5 == 0)
16:11:15 <lambdabot> forall a. (Integral a) => [a] -> [a]
16:11:54 <sorear> :t filter (let dv x y = flip (((==0) .) . mod) in liftM2 (dv 3) (dv 5))
16:11:57 <lambdabot>     Couldn't match expected type `Bool'
16:11:57 <lambdabot>            against inferred type `t -> a2 -> Bool'
16:12:14 <vali> sorear: ???
16:12:14 <sorear> :t filter (let dv = flip (((==0) .) . mod) in liftM2 (dv 3) (dv 5))
16:12:17 <lambdabot>     Couldn't match expected type `a2 -> r' against inferred type `Bool'
16:12:17 <lambdabot>     In the first argument of `liftM2', namely `(dv 3)'
16:12:32 <narain> :t filter ((==0) . (flip mod 3)) -- um, no easy way to do both 3 and 5?
16:12:35 <lambdabot> forall a. (Integral a) => [a] -> [a]
16:13:22 <narain> :t filter (liftM2 (||) ((==0) . (flip mod 3)) ((==0) . (flip mod 5))) -- hmm
16:13:25 <lambdabot> forall a. (Integral a) => [a] -> [a]
16:13:32 <narain> ok, that's just obfuscated
16:13:33 <qwr> > filter (\x -> any $ map (mod x) [2,3,7]) [21..26]
16:13:35 <lambdabot>  Couldn't match expected type `a -> Bool'
16:14:18 <narain> > filter (\x -> any $ map ((==0) . mod x) [3,5]) [1..10]
16:14:18 <qwr> > filter (\x -> any $ map ((== 0) . mod x) [2,3,7]) [21..26]
16:14:19 <lambdabot>  Couldn't match expected type `a -> Bool'
16:14:20 <lambdabot>  Couldn't match expected type `a -> Bool'
16:15:21 <mux> > filter (any $ \x -> map ((== 0) . mod x) [2,3,7]) [21..26]
16:15:22 <lambdabot>  Couldn't match expected type `Bool' against inferred type `[Bool]'
16:15:39 <qwr> > filter (\x -> any ((== 0) . mod x) [2,3,7]) [21..26]
16:15:41 <lambdabot>  [21,22,24,26]
16:15:44 <Ulfalizer> vali: you could use 'filter' like this if you wanted to find the multiples of 5 in a list: filter (\x -> x `mod` 5 == 0) list
16:15:58 <narain> > filter (\x -> or $ map ((==0) . mod x) [3,5]) [1..10]
16:15:59 <lambdabot>  [3,5,6,9,10]
16:16:35 <Ulfalizer> narain: i think he'll find that a bit harder to follow as a beginner :)
16:16:37 <vali> checkMod x = filter (\x -> if x `mod` 3 == 0 || x `mod` 5 == 0 then True else False) ... where do i linebreak something like this? i don't like it when lines wrap
16:17:12 <narain> vali: you don't need the if
16:17:18 <mux> use the last version from qwr :-)
16:17:23 <narain> if x then True else False == x
16:17:33 <Saizan> you can do it at every whitespace, just indent the second line more
16:17:51 <vali> ah, okay
16:18:12 <Ulfalizer> vali: || already gives a truth value in itself, so wrapping an if around it in that way is redundant
16:18:30 <vali> oh, okay
16:19:58 <ddarius> if x then True else False == x is the same principle behind foldr (:) [] == id, all instances of the uniqueness of initial algebras (random PLT/CT factoid of the day)
16:20:55 <vali> hmm, i see
16:23:36 <vali> checkMod :: [Int] -> [Int]
16:23:39 <vali> checkMod x = filter (\x -> x `mod` 3 == 0 || x `mod` 5 == 0)
16:24:26 <narain> vali: either don't place an argument on the left, or use it on the right
16:25:02 <narain> er, that's not actually a general rule, but it looks like what's wrong in this case
16:25:17 <narain> :t filter (\x -> x `mod` 3 == 0 || x `mod` 5 == 0)
16:25:20 <lambdabot> forall a. (Integral a) => [a] -> [a]
16:26:09 <narain> checkMod = filter (...)  or  checkMod xs = filter (...) xs
16:26:36 <sorear> @web1913 idempotent
16:26:38 <lambdabot> No match for "idempotent".
16:26:49 <narain> web1913?
16:27:08 <jcreigh> webster's 1913 dictionary, I assume.
16:27:18 <narain> oh, ok
16:27:30 <SamB_XP_> quite so
16:27:35 <sjanssen> http://en.wikipedia.org/wiki/Idempotent
16:27:36 <lambdabot> Title: Idempotence - Wikipedia, the free encyclopedia
16:28:07 <sorear> well, someone used it wrong... I'm trying to find the word he wanted
16:28:31 <vali> narain: why do they call it "xs"?
16:28:53 <sorear> x, plural
16:28:58 <vali> aah
16:29:35 <narain> is that common haskell style though? it's a habit i have from ML
16:29:47 <sorear> yeah, very common haskell
16:29:50 <jcreigh> yeah, it's pretty common
16:29:55 <sorear> dons: I'm pretty sure you wanted 'involution'
16:29:56 <narain> good to hear
16:30:00 <Saizan> idiomatic i'd say
16:30:29 <jaapweel> talking about OCaml... (completely coincidentally) am I right to conclude, after looking over the Haskell report a bit, that there is no direct equivalent for the following OCaml idiom:
16:30:35 <jaapweel> match 3 with 0 | 1 -> "small" | _ -> "big"
16:30:44 <jaapweel> ?
16:31:01 <sorear> 3 `elem` [0,1] is the closest we have
16:31:13 <dons> sorear: no, i wanted idempotent.
16:31:38 <dons> that is, forall s :: StackSet . promote s == promote (promote s)
16:31:45 <jaapweel> sorear: that's what i figured. it's a pity, there are many cases where it comes in useful.
16:31:59 <dons> ah, even wikipedia agrees with me,
16:31:59 <dons>   * A unary operation (i.e., a function), is idempotent if, whenever it is applied twice to any
16:32:02 <dons>     element, it gives the same result as if it were applied once.
16:32:06 <jaapweel> sorear: but thank for telling me, i am no longer in doubt
16:32:08 <Cale> case 3 of n | n `elem` [0,1] -> "small" | otherwise -> "big"
16:32:12 <dons> given the unary operation promote :-)
16:32:16 <sorear> dons: ok, I misunderstood the rest of the message then
16:32:38 <sorear> dons: I thought promote turns 'a' 'bcDe'  into 'd' 'bcAe'  and back again
16:32:54 <jaapweel> Cale: I actually did that, but the neat thing about the OCaml thing was that you could check statically that you hadn't missed any of the alternatives
16:33:01 <Cale> In general a function is idempotent of degree k if when applied k times, it gives the same result as if it were applied once.
16:33:02 <narain> jaapweel: did you mean  match 3 with 0 -> "small" | 1 -> "small" | _ -> "big"  or is that some OCaml syntax i wasn't aware of?
16:33:23 <dons> sorear: and back again? no. since focus is unchanged
16:33:37 <Cale> narain: I think it was an or-pattern
16:33:37 <hpaste>  LPhas pasted "HAppS learning" at http://hpaste.org/1455
16:33:38 <jaapweel> narain: note that the | in ocaml match statements separates clauses, and does not introduce guards, like it does in haskell.
16:34:02 <sorear> dons: You said focus is unchanged.  I thought that meant focus position.  You actually meant focus window.
16:34:18 <dons> yes. we need to distinguish frames and windows i think, in tiling mode.
16:34:20 <dons> or windows and clients
16:34:29 <dons> focus stays with the client. it moves to a new window.
16:34:36 <dons> or, focus stays with the window, it moves to a new frame.
16:34:38 <narain> jaapweel: yes, i can't see a right-hand-side for the clause matching 0
16:34:53 <narain> which is why i asked if this was special syntax
16:34:58 <jaapweel> narain: that's the point. you can leave those out in some cases
16:35:03 <jaapweel> narain: ah, i see. yes, it is.
16:35:22 <Cale> do you have to write it as (0 | 1) -> ... ?
16:35:51 <jaapweel> Cale: the expression as i originally typed it is literally valid in ocaml
16:35:56 <narain> jaapweel: so it uses the result of the next clause?
16:36:03 <Cale> okay
16:36:05 <jaapweel> yes.
16:36:54 <narain> like the C case statement. interesting. SML doesn't have this, as far as i know
16:37:20 <Cale> Does it check that the variables bound are the same in all the cases?
16:38:21 <dhart> hello
16:38:22 <jcreigh> dons++ promote moves window to master. thank you.
16:38:27 <Cale> Hello
16:38:40 <dhart> I have question regarding when it is good to use classes. Can someone point me towaqrds an article on such a question?
16:39:01 <Cale> Um, well, what's the question, perhaps we can just answer it.
16:39:10 <dhart> Coming from an OOP abckground, I tend to want to use them, but I am not sure what is a "good practice" in haskell...
16:39:26 <Cale> Classes aren't quite the same thing in Haskell as they are in OO
16:39:36 <Cale> They're closer to Java's interfaces.
16:39:39 <narain> Cale: i guess it would interpret  p1 | p2 -> e  as  p1 -> e | p2 -> e  leading to a standard unbound variable error if you use different variables in p1 and p2
16:39:45 <dons> jcreigh: note that it swaps master and window.
16:39:45 <Cale> (But that doesn't *quite* capture it)
16:39:56 <dons> and leaves the other unmodified. i think this is more predictable.
16:40:00 <dons> whaddya think?
16:40:18 <Cale> narain: yeah, that would be the sane thing to do :)
16:40:25 <dhart> Cale: The specific question I have is as so: I have a type which can take different form, each form changes the way functions around that type work.
16:40:30 <jcreigh> yeah. that's cool. What did it do in the first version of promote? Just a no-op when focused on master?
16:40:31 <dhart> Cale: Is that enough to create a class?
16:40:32 * SamB_XP_ wonders if he should have paid state income tax on some money he earned last year...
16:40:41 <Cale> dhart: yeah
16:40:52 <Cale> dhart: Er, if they're different types
16:41:04 <dhart> Cale: Thx. I guess seeing them as java interfaces helps me to understand them.
16:41:05 <Cale> If it's just one type with multiple constructors, don't bother.
16:41:10 <narain> dhart: what do you mean by "can take different forms?"
16:41:32 <Cale> But if you want to abstract over your data representation, they're perfect for that.
16:41:38 <sjanssen> SamB_XP_: a little late to be wondering about that, I think
16:41:46 <dons> jcreigh: it shifted focus to whatever window was now in the frame the former window was in
16:41:55 <hpaste>  vali pasted "mod" at http://hpaste.org/1456
16:42:03 <jaapweel> narain: I'm not exactly sure what you mean by checking that the variables bound are the same. you can use the same pattern variable in different places in different clauses that have the same right-hand side, as long as it is of the same type
16:42:11 <narain> yes, "type classes are like java interfaces" is a good first approximation
16:42:12 <jaapweel> match (3,4) with (3,a) | (a,3) -> a | _ -> 2;; is valid
16:42:24 <dhart> Ok, I'll go into the gritty details. I have a Cell type, which has different types of terrain (Grass, Mountain, Water, etc...). And depending on what type of terrain it is, functions like "isTraversable :: Cell -> Bool" (and much more complicated ones, will work differently
16:42:37 <vali> it complains that my "foldr" doesn't match the right type
16:42:45 <Cale> dhart: Oh, you don't need classes for that
16:43:00 <dhart> Cale: why so? I'd like to understand the incensitive.
16:43:01 <SamB> sjanssen: point
16:43:03 <Cale> dhart: You'd need classes if you wanted functions to work with different Cell types.
16:43:23 <Cale> You can just pattern match against the value passed to isTraversable
16:43:24 * dons happily hacks up QC properties
16:43:36 <Cale> You have something like:
16:43:37 <dons> the cool thing about QC is that you *want* to write tests!
16:43:44 <jaapweel> vali: the function (+) wants integers, not lists of integers
16:43:48 * SamB waves hands at dons
16:43:50 <Cale> data Cell = Grass | Mountain | Water | ...
16:43:51 <Cale> right?
16:43:54 <SamB> *you want to test tests*
16:44:00 <Cale> So you can do:
16:44:01 <dhart> Cale: But the Cell type is more than just "data Cell = Grass | Mountain", it has some values, it's more of a structure.
16:44:05 <narain> jaapweel: sure, i was just attempting to answer Cale's question about what would happen with, say,  match 3 with x | y -> y+1
16:44:07 <Cale> isTraversable Grass = True
16:44:11 <Cale> isTraversable Water = False
16:44:24 <dhart> Currently, but not finished:
16:44:25 <dhart> data Cell = Cell {
16:44:25 <dhart> 	terrain		:: Terrain,
16:44:25 <dhart> 	creatures	:: [Creature] }
16:44:27 <Cale> Or sure, you can pattern match against the contents in that case
16:44:30 <SamB_XP_> shouldn't that depend on the unittype?
16:44:30 <jaapweel> vali: i'm sorry, i'm wrong, actually, you are simply supplying too many args to foldr.
16:44:45 <jaapweel> vali: it only takes 3 of them
16:45:03 <Cale> isTraversable (Cell {terrain = Grass, creatures = xs}) = null creatures
16:45:13 <Cale> isTraversable (Cell {terrain = Water}) = False
16:45:17 <Cale> for instance
16:45:44 <SamB_XP_> what about the adjacent cells?
16:45:55 <SamB_XP_> don't you need to know about what is in those?
16:46:16 <Cale> Maybe not :)
16:46:34 * narain looks back and forth between SamB and SamB_XP_
16:46:35 <dhart> Cale: The thing is that all my functions acting on Cell will do pattern matching on the type of terrain. It rings my OOP bell that "Whenever you use a switch statement, isn't Inheritance hiding somewhere?"
16:46:43 <SamB_XP_> narain: hehe
16:47:11 <ddarius> dhart: Ever use the visitor pattern?
16:47:11 <SamB_XP_> narain: I am too lazy to learn irssi or figure out how to connect twice to the same screen(1)
16:47:25 <dhart> SamB_XP_: What would cell adjacency change in this problem of class/pattern amtching?
16:47:32 <dhart> ddarius: I have.
16:47:35 <Cale> dhart: Well, you might be able to abstract things further, but it depends on what kind of extensibility you're looking for.
16:47:49 <jaapweel> SamB_XP_: screen -r
16:48:28 <SamB_XP_> jaapweel: yeah well so far I only know how to use x-chat and mIRC. (I don't actually *use* mIRC, of course)
16:48:37 <Cale> dhart: There's no such thing as subtypes or inheritance in Haskell though.
16:49:17 <dhart> Cale: true, but "interfaces" allow me to seperate the code for each type of terrain in different files
16:49:39 <dhart> Cale: but I don't know what the cost in cpu is to sue classes and if it's really necessary
16:50:19 <hpaste>  vali pasted "mod" at http://hpaste.org/1457
16:50:22 <Cale> You could go so far as to use existential types, which basically let you take some set of classes and forget everything about a piece of data except that they it implements those classes.
16:50:47 <Cale> (which is something like an OO up-cast, with no hope of ever down-casting)
16:51:07 <sorear> actually, down-casting is available, as a class.
16:51:09 <sorear> Typeable
16:51:09 <narain> classes/interfaces and algebraic data types divide the implementation space along orthogonal directions
16:51:23 <Cale> Well okay :)
16:51:43 <narain> (possibly not immediately relevant rant follows)
16:52:26 <dhart> I'll google existancial classes
16:52:29 <dhart> types even
16:52:48 <Cale> They're an extension in GHC
16:52:48 <sorear> existan*t*ial even :)
16:53:04 <narain> with classes, you can add new kinds of things easily, but you can't add new kinds of computations because youd have to add new methods to every class separately
16:53:19 <Cale> For example:
16:53:23 <sorear> dhart: also existential types is a butchered phrase
16:53:33 <Cale> data Showable = forall a. (Show a) => Showable a
16:53:41 <Cale> instance Show Showable where
16:53:42 <sorear> you'll probably get better results with 'existentially quantified types'
16:53:44 <narain> with algebraic data types, you can add new kinds of computations easily, but you can't add new kinds of objects easily because then youd have to add new clauses to all your function definitions
16:53:48 <Cale>    show (Showable x) = show x
16:53:59 <Cale> Then you can do something like:
16:54:12 <Cale> show [Showable 5, Showable [1,2,3], Showable "Hello"]
16:54:14 <sorear> Cale: what, you can't just use data Showable = Showable (Int -> ShowS) :)
16:54:15 <narain> depends on in which direction you need extensibility
16:54:38 <Cale> and it'll give you "[5,[1,2,3],\"Hello\"]", in response
16:54:49 <Cale> [Showable 5, Showable [1,2,3], Showable "Hello"] :: Showable
16:55:05 <Cale> The types of the things you apply the Showable constructor to are forgotten.
16:55:21 <Cale> Basically just the class dictionary for Show is remembered.
16:55:39 <ddarius> And getting extensibility on both axis is the expression problem and there are solutions to it in Haskell.
16:55:52 <GeoBes1> Evening -- has anyone compiled 6.7 on RedHat or Fedora 7 on an ia64 platform?
16:56:17 <Cale> sorear raises a valid point, in that you can always abstract this away and not use existential types by simply creating a record of the functions involved in the class, as applied to the specific case of your values
16:56:32 <ddarius> Always?
16:56:43 <sorear> Oh, you are still using existential quantification.
16:56:47 <narain> ddarius: thanks for pointing out the name of the problem
16:56:51 <Cale> Pretty much, I think.
16:57:07 <Cale> ddarius: I'd be interested if you can come up with a counterexample :)
16:57:08 <sorear> Haskell 98 provides one (and only one) existentially quantified "type", the partial application.
16:57:17 * sorear would too
16:57:22 <narain> ddarius: it'll be useful in googling for more information
16:57:40 <ddarius> I believe there are times when it gets very hairy.
16:57:54 <sorear> very hairy I'll accept.
16:58:25 <vali> good night!
16:58:28 <ddarius> I'm not sure if you always can.  Certainly with higher ranked types though it may get CPSy.
16:58:31 <dhart> By reading a doc on existantial types, I seem to understand that it will help me if I want a list of cells, and these cells might be of different types
16:58:45 <Cale> Yeah.
16:58:58 <Cale> It lets you forget about the differences in implementation.
16:59:14 <Cale> So it's sort of the core of what OO programming is about.
16:59:41 <Cale> But it's sort of a rare technique in Haskell.
17:00:11 <narain> clueless question: are existential types related to codata/comonads?
17:00:49 <Cale> narain: Not in any way which is immediately obvious to me.
17:01:01 <ddarius_> Hmm, how about types with negative occurences.
17:02:06 <narain> i seem to recall in the comonads paper (not that i understood much of it) that codata is data of an opaque type which exposes only a set of functions to manipulate it
17:02:25 <Cale> hmm
17:03:17 <dhart> The doc I am reading seems to say that another way of doing existantials is to pack the function types into the Cell object
17:03:19 <narain> ddarius: what are the solutions to the expression problem in haskell you mentioned?
17:03:24 <Cale> dhart: yes.
17:03:40 <dons> people might be interested in this, http://www.linuxdevices.com/news/NS2277402289.html
17:03:40 <lambdabot> Title: Startup touts virtualizing microkernel
17:03:43 <Cale> dhart: For example, you could just record whether the cell is traversable as a field of the record.
17:03:56 <dons> (same guys who do the L4/haskell kernel, and other verified kernel/haskell/isabelle-ish things)
17:04:03 <ddarius_> narain: See the extensible interpreter in the OOHaskell source code (it doesn't actually use OOHaskell, though OOHaskell should itself be another solution)
17:05:10 <dhart> But the fact if a cell is traversable or not is dynamic, even a mountain type can be traversable depending on the context.
17:06:03 <Saizan> so you can save it as isTraversable :: Context -> Bool, and not just Bool
17:06:07 <Cale> dhart: ah, okay -- so that's going to take some information from the player to work as well
17:06:25 <Cale> But yeah, you can still pack a function from that context to Bool into the record :)
17:06:29 <narain> ddarius_: interesting! i was looking forward to more idiomatic solutions, but this is quite interesting too
17:06:53 <ddarius_> narain: It's not too bad.
17:07:09 <ddarius_> Even OOHaskell isn't that bad.  But yes, it is not idiomatic.
17:08:12 <dhart> Cale: the problem with putting the functions in the records, is that compared to before, where a Cell value represented an acutal cell in the world, now, a cell value also packs the functions, meaning it also represents the type of cell :S
17:08:48 <ddarius_> @roll 1d2
17:08:48 <lambdabot> Consider it noted.
17:08:54 <ddarius_> Doh
17:08:57 <ddarius_> @dice 1d2
17:08:57 <lambdabot> 1d2 => 2
17:09:06 <ddarius_> Stupid "spellcheck".
17:09:06 <Cale> dhart: Well, it all depends on how you want it to be carried out and how much flexibility you need.
17:09:49 <narain> ddarius_: intriguing nonetheless. thanks
17:09:54 <dhart> Ok, I'll roll a dice to. On a 1, I go back to using C#, on a 2, I continue banging my head on haskell until I think everythign in functional
17:10:02 <Cale> dhart: hehe
17:10:08 <dhart> @dice 1d2
17:10:09 <lambdabot> 1d2 => 2
17:10:17 <ddarius_> narain: Such code could become idiomatic or more idiomatic in the future.
17:10:18 <dhart> Ok, I guess that's Haskell for me
17:10:51 <dmead> dhart: it takes a while
17:11:04 <dmead> but eventually you'll be doing java or c# and whatever
17:11:08 <dmead> and start thinking like
17:11:12 <dmead> o snaps i could use a pattern here
17:11:14 <dmead> BUT WAIT
17:11:17 <dmead> it's not haskell
17:11:23 <sorear> ddarius_: Musing a bit - eliminating existantial quantification is (no I think, I've an informal proof) a special case of (equivalent to?) finding monomorphic representations for higher rank polymorphic types (forall a. (a -> a) -> a -> a ==> [()])
17:12:17 <fantasma> @seen sjanssen
17:12:18 <lambdabot> sjanssen is in #haskell, #gentoo-haskell, #haskell-overflow, #ghc and #haskell-soc. I last heard sjanssen speak 24m 32s ago.
17:12:29 <sorear> hello!
17:12:35 <fantasma> hey
17:12:37 <dmead> hi
17:12:39 <dmead> :o
17:13:55 <Saizan> is it standard for a darcs pull from ghc HEAD to take forever without even starting fetching patchs?
17:14:08 <ddarius_> Certainly if you could do that you could eliminate the existential, e.g. by replacing exists x.F x with forall r.(forall x.F x -> r) -> r
17:14:20 <sorear> where forever == ~10 s, yes.
17:14:53 <Saizan> we are over the minute here..
17:15:04 <Saizan> oh! i got one
17:15:07 <sjanssen> fantasma: what's up?
17:16:19 <dhart> dmead: Well I started the project in C#, and at one point I was: "Oh, I need a type for a pair of values. In Haskell it's simply (i,j), but now I have to write a whole struct", and then later on "Ok, I need a priority list, damn I got to write one. But Haskell has it in it's library".
17:16:34 <dmead> yep
17:16:55 <dmead> i'm writting some tools in java
17:17:00 <dmead> and it's getting very verbose
17:17:03 <dmead> sooo annoying
17:17:11 <dhart> I understands the basics of Haskell, but I guess I need to read a tutorial/article/book on how to build a more massive application than the usual small teaching example
17:17:12 <sorear> Haskell doesn't actually have priority lists standard.  However, you can fake an asymptotically optimal one with a Map and findMin
17:17:17 <sorear> er, Set
17:17:26 <dhart> sorer: I thought they had Heap
17:17:36 <sorear> nope. :(
17:17:42 <dhart> Data.Graph.Something.Heap
17:17:48 <ddarius_> Those are easy.  Wait until you have things like, "Oh, I want non-deterministic backtracking with logic variable here".
17:18:00 <dhart> Data.Graph.Inductive.Internal.Heap to be precise
17:18:14 <sorear> ddarius_: bah, logic variables take be 15 lines to define :(
17:18:19 <sorear> s/be/me
17:19:22 <qwr> dmead: kawa/jython/etc? depends whether you need java or jvm ;)
17:19:47 <dmead> i need jvm really
17:19:53 <dmead> cross platform is essential
17:20:17 <sorear> dmead: ghc runs on half a gillion platforms already, yhc a full gillion
17:20:31 <dmead> yeaa
17:20:36 <dmead> i really should have done it in haskell
17:20:44 <dmead> but it's 80% done already
17:20:54 <sorear> or are you users too stupid to run compilers, so a source release is impossible? ;)
17:21:07 <jcreigh> isn't scale supposed to be decent? (I've never used it.)
17:21:11 <jcreigh> *scala
17:21:17 <dmead> i'm making a tool that lets you configure 10 pages of xml with menus
17:21:22 <dmead> it's really icky
17:21:29 <dmead> yea
17:21:30 <dmead> it is
17:21:30 <dhart> sorear: Isn't Data.Graph.Inductive.Internal.Heap a priority heap?
17:21:32 <ddarius> Users don't need to know how to run compilers to use a source release.
17:21:33 <dmead> but i've never touched it
17:21:33 <qwr> i'd take nice over scala...
17:22:43 <sorear> dhart: It sounds like a module you shouldn't be using unless your name is Martin Erwig, or you are planning on sending him patches
17:22:44 <qwr> scala looks like perl syntactic madness applied to java
17:23:15 <qwr> inline xml and whatnot
17:23:33 <sjanssen> dhart: Data.Map can work as a heap in a pinch
17:23:36 <procyon112> ?src liftA2
17:23:37 <lambdabot> liftA2 f a b = f <$> a <*> b
17:23:39 <jcreigh> inline xml?
17:23:41 <jcreigh> strange.
17:24:13 <Saizan> how do you delete a newline in vi?
17:24:20 <jcreigh> dd
17:24:27 <jcreigh> removes a while line...
17:24:40 <jcreigh> not sure exactly what you mean by "newline"
17:25:02 <dhart> sorear: Martin Erwig? patches? Am I missing o joke or an advice somewhere?
17:25:13 <qwr> jcreigh: http://www.scala-lang.org/docu/examples/files/addressbook.html
17:25:15 <lambdabot> Title: sources/docu/examples/files/addressbook.scala
17:25:23 <fantasmaa> @where emacs
17:25:24 <lambdabot> I know nothing about emacs.
17:25:29 <fantasmaa> ...
17:25:58 <sorear> dhart: did you not see the word "Internal" in the module name?  Martin Erwig is the Data.Graph.* author.
17:26:00 <Saizan> jcreigh, you got it right :)
17:26:06 <jcreigh> qwr: gah...it's like PHP or Coldfusion...
17:26:17 <fantasmaa> @where+ emacs http://haskell.org/haskellwiki/Haskell_mode_for_Emacs
17:26:17 <lambdabot> Done.
17:26:18 * sorear decides that could probably have been said better
17:26:18 <dhart> sorear: ohhhh ok
17:26:47 <jcreigh> I would not like to see that parser...
17:26:49 <sorear> shouln't that be gnu.org/emacs or somesuch? ;)
17:27:18 <dhart> sorear: In that case I'm buggered because I haven't been able to find a priority queue implementation anywhere. Of course I could always implement one, but I'm not "lazy" enough to write good effecient haskell code yet (I think).
17:27:32 <sjanssen> dhart: check out edison
17:27:35 <sjanssen> @where edison
17:27:36 <lambdabot> http://www.eecs.tufts.edu/~rdocki01/edison.html
17:29:00 <dhart> thx, I'll check it out
17:31:14 <ddarius> The free chapter of "The Fun of Programming" has a cute simple efficient implementation.
17:31:58 <ddarius> @dice 1d2
17:31:59 <lambdabot> 1d2 => 2
17:32:01 <ddarius> @dice 1d2
17:32:01 <lambdabot> 1d2 => 2
17:32:02 <ddarius> @dice 1d2
17:32:02 <lambdabot> 1d2 => 2
17:32:05 <ddarius> Hmm.
17:32:21 <dhart> The Edison ppl like to use barbaric names for their data-structures :S
17:32:25 <fantasmaa> ?dice 1d6
17:32:25 <lambdabot> 1d6 => 5
17:33:17 <QtPlatypus> dhart: What names do they use?
17:33:59 <QtPlatypus> ... Oh I see.
17:34:27 <dhart> "Leftist Heaps", "Lazy Paring Heaps", "PatriciaLoMap"
17:43:02 <TomMD> Whats the slick/easy way to define the order (as in, Ord class) of enumerated types (data Color = Red | Green | Blue) ?
17:43:13 <dmwit> ?hoogle index
17:43:14 <lambdabot> Ix.index :: Ix a => (a, a) -> a -> Int
17:43:15 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
17:43:15 <lambdabot> Data.Generics.Basics.indexConstr :: DataType -> ConIndex -> Constr
17:43:25 <dmwit> ?hoogle a -> [a] -> Int
17:43:26 <lambdabot> No matches, try a more general search
17:43:26 <sjanssen> TomMD: data Color = ... deriving Ord
17:43:47 <dmwit> ?hoogle (Eq a) => a -> [a] -> Int
17:43:48 <lambdabot> No matches, try a more general search
17:44:05 <TomMD> sjanssen: No, I mean, will Red > Green > Blue
17:44:16 <TomMD> And if so, is that a language specification so I can count on it.
17:44:16 <sorear> TomMD: other way
17:44:20 <TomMD> ok, sounds good
17:44:24 <sorear> TomMD: yes, it's in the spec
17:44:32 <Cale> What's wrong with those names?
17:44:43 <sorear> http://www.haskell.org/onlinereport/derived.html -- from memory
17:44:44 <lambdabot> Title: The Haskell 98 Report: Derived Instances
17:44:50 <sjanssen> sorear++
17:44:54 <Cale> er, just noticed that I was responding to something not current :)
17:45:06 <Cale> and that dhart seems to be gone
17:45:29 <TomMD> Cale: I was wondering if something was wrong with the constructor "Red" :-)
17:45:41 <dmwit> > span isSpace "  hi"
17:45:43 <lambdabot>  ("  ","hi")
17:45:53 <Philippa> TomMD: it's supposed to be written EvilCommieBastard, duh
17:47:05 <sorear> @remember Philippa <TomMD> Cale: I was wondering if something was wrong with the constructor "Red" :-) <Philippa> TomMD: it's supposed to be written EvilCommieBastard, duh
17:47:05 <lambdabot> Done.
17:54:19 <Cale> http://www.kolumbus.fi/fishu/trash/skoreagold.jpg -- why having automatically constructed "Related News" boxes might not be the best idea.
17:55:50 <sorear> Obviously, they need to refine their typesystem and statically distinguish between goodshoot and badshoot.
17:58:31 <sorear> @where HList
17:58:32 <lambdabot> http://homepages.cwi.nl/~ralf/HList
18:02:50 <sorear> @seen oren
18:02:51 <lambdabot> oren is in #haskell. I don't know when oren last spoke.
18:04:45 <stepcut> maybe we should add a feature to the eval plugin that lets you load definitions from hpaste
18:05:03 * LoganCapaldo has had the same thought as stepcut
18:05:09 * sorear has too
18:05:21 <stepcut> well, if we all think hard enough, maybe it will get done :)
18:05:40 <jcreigh> @load-http would be more general
18:05:41 <lambdabot> Unknown command, try @list
18:06:31 <jcreigh> and then @load-paste N could @load-http http://hpaste.org/N/0/plain
18:06:34 <jcreigh> hmm.
18:06:35 <stepcut> first, I need to patch haskell-mode so that when you do C-c C-l, it temporarily removes anything that is already on the ghci prompt, runs the load command, and then puts the text back
18:06:57 <dmwit> THIS SHOULDN'T BE SO HARD
18:07:25 <jcreigh> dmwit: hmm?
18:07:47 <dmwit> jcreigh: I need a function like break, but that puts the break *after* the first success.
18:07:57 <dmwit> > break (== 2) [1..5]
18:07:58 <lambdabot>  ([1],[2,3,4,5])
18:08:08 <dmwit> Where I would prefer it to be ([1,2],[3,4,5])
18:08:11 <dmwit> o
18:08:15 <dmwit> k
18:08:22 <Saizan> > span (== 2) [1..5]
18:08:24 <lambdabot>  ([],[1,2,3,4,5])
18:08:31 <Saizan> gh
18:08:41 <jcreigh> > span (/= 2) [1..5]
18:08:42 <lambdabot>  ([1],[2,3,4,5])
18:08:47 <jcreigh> oh, same deal.
18:09:06 <stepcut> dmwit: I wrote that function once
18:09:40 <stepcut> well, I think mine was takeWhile + 1
18:10:04 <pirothezero> So i have this .hs file that I made and I need to test certain test cases...how can I batch run them. Do i Make another .hs file and put all the commands in there and then run a load command of some kind?
18:10:06 <Saizan> ?src span
18:10:07 <lambdabot> Source not found. It can only be attributed to human error.
18:10:21 <LoganCapaldo> lambdabot can be so cruel
18:12:03 * ddarius__ likes the Tunisian simple stitch.
18:12:43 * LoganCapaldo wonders if ddarius__ is talking about sewing or knitting or what
18:12:50 <ddarius__> Crochet.
18:13:12 * LoganCapaldo needs wonder no more
18:13:38 <ddarius__> Though one cool thing is that you can get a knitting like effect with the Tunisian knit/purl stitch.
18:15:02 <pirothezero> test suites anyone? one file with function calls to each defined function to test to make sure everything works properly without typing stuff in one line at a time
18:15:07 <LoganCapaldo> I wouldn't know the difference between something knitted and something with a knitted like effect if it came up and bit me :)
18:15:21 <ddarius__> That's the idea.
18:16:10 <ddarius__> LoganCapaldo: You should learn to knit and crochet.  They are ridiculously easy to pick up and relaxing to do and potentially useful.
18:16:16 * LoganCapaldo is also interested in the answer to pirothezero's question
18:16:27 <LoganCapaldo> Only potentially useful?
18:16:35 <LoganCapaldo> I can sew buttons
18:16:41 <LoganCapaldo> Or I could anyway
18:16:46 <LoganCapaldo> I may be out of practice
18:16:51 <LoganCapaldo> buttons and patches
18:17:03 * LoganCapaldo was a boy scout
18:17:03 <Cale> pirothezero: Have you looked at HUnit and QuickCheck?
18:17:17 <ddarius__> Most of the time it's cheaper to buy premade clothing (even not factoring in time), but of course then you are limited to what's provided.
18:17:28 <SamB_XP_> LoganCapaldo: that is only useful if you encounter a missing button
18:17:34 <LoganCapaldo> indeed
18:17:43 <ddarius__> SamB_XP_: But when you do!
18:17:45 <resistor_> the ghc man page mentions optimization levels. "-On" . how many optimization levels are there?
18:17:50 <sorear> 2
18:17:58 <ddarius__> 3, 0,1, and 2
18:18:09 <pirothezero> no Cale I haven't
18:18:13 <sorear> and btw, -O3 generates worse code than -O2 due to a compiler bug
18:18:14 <pirothezero> didn't know what to look for
18:18:15 <Cale> dmead: That used to exist, but seems to have been removed.
18:18:22 <SamB_XP_> but -O255 should work fine too
18:18:23 <rahikkala> ddarius__: What a beautifully hard-to-parse way of saying a simple thing ;)
18:18:25 <sorear> -O3 is basically parsed as -O0
18:18:29 <pirothezero> thanks for the direction :)
18:18:35 <SamB_XP_> sorear: what!
18:18:41 <dmwit> sjanssen: I have a patch for dwm-style promote, but it won't record... =(
18:18:43 <Cale> pirothezero: They both come with GHC now, but I think the best documentation for HUnit is not in the hierarchical libraries.
18:18:43 <ddarius__> rahikkala: I know, I impressed even myself.
18:18:43 <sorear> SamB_XP_: optimization levels are not monotonic
18:18:46 <Cale> http://hunit.sourceforge.net/HUnit-1.0/Guide.html
18:18:49 <lambdabot> Title: HUnit 1.0 User's Guide
18:18:50 <sjanssen> -Ono!
18:19:05 <sorear> SamB_XP_: most optimizations are enabled at [1,2], [2], or [0,1,2]
18:19:10 <dmwit> It says /bin/sh: ./loc: No such file or directory\nTest failed!
18:19:11 <sorear> SamB_XP_: yes, it uses `elem`
18:19:12 <ddarius__> Or sorear's(?) favorite, -Omg
18:19:18 <dmwit> Oy, I have to go, but ?tell me if you have a hint.
18:19:25 <LoganCapaldo> -Omagnesium ?
18:19:33 <SamB_XP_> sorear: quickcheck for great justice!
18:19:50 * sorear knows how to crochet, and has a nasty habit of crocheting anything in sight when bored ... esp power cored
18:19:53 <sorear> *cords
18:19:58 <sjanssen> dmwit: dons beat you to it, I think
18:20:04 <ddarius__> I made my first crochet hooks.
18:20:26 <ddarius__> And the first thing I crocheted was a hyperbolic disc.
18:20:43 * sorear doesn't need crochet hooks
18:20:54 <ddarius__> No, you don't.
18:20:59 <SamB_XP_> sorear: clearly!
18:21:09 <ddarius__> I knew how to finger weave in elementary school.
18:21:14 <dcoutts> now for a kleine bottle?
18:21:15 * LoganCapaldo wonders if sorear has claws for hands
18:21:15 <SamB_XP_> they don't come in power-cord size!
18:21:26 <ddarius__> dcoutts: There are patterns out there.
18:21:32 <Cale> sorear: you should implement some experimental optimisations for GHC and use the flag -Orear
18:21:34 <dcoutts> cool :-)
18:21:36 <ddarius__> Since you can just crochet right through the fabric.
18:22:32 <ddarius__> SamB_XP_: There are some really fat hooks out there.  Anyway, crochet is the only skill where you have books titled "The Happy Hooker" that aren't disreputable.
18:22:49 * LoganCapaldo would pay good money for a moebius scarf
18:23:36 <ddarius__> LoganCapaldo: Again, patterns exist.  That's actually pretty easy.
18:23:38 <sorear> convieniently, that's just about the only thing I know how to make
18:23:45 <stepcut> LoganCapaldo: how about a mobius shoe ? http://deepfun.com/images/shoe.gif
18:23:56 * sorear never really put much time into learning patterns and whatnot
18:24:06 <sorear> @remember ddarius Crochet is the only skill where you have books titled "The Happy Hooker" that aren't disreputable.
18:24:07 <lambdabot> Done.
18:24:15 * ddarius__ neither.
18:25:35 <dons> oh that's interesting. with newtype deriving
18:25:51 <dons> you can implement a newtype that derives Num, and then never need its constructor
18:25:53 <sorear> dons: eh?  is it the same as my bug *finds number*
18:26:08 <sorear> oh.
18:26:09 <dons> that is, you can export your newtype abstractly, have ghc complain you never use the constructor
18:26:29 <dons> which is a bit annoying, since I know i never need the constructor.
18:26:33 <sorear> @bug
18:26:34 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
18:26:38 <sorear> :)
18:26:43 <dons> its not obviously a bug.
18:27:01 <sorear> any unsuppressable warning is ?
18:27:04 <dons> its just that the constructor's use in the derived code isn't counted as 'exported'
18:27:24 <LoganCapaldo> dons: hwo do you never need the constructor? newtype Foo = Foo Int deriving Num; fromIntegral 3 :: Foo ?
18:27:33 <dons> right.
18:27:34 <sorear> LoganCapaldo: yes.
18:27:36 <dons> or 3 :: Foo
18:27:43 <dons> fromIntegral (2 :: Int) :: Foo
18:28:01 <sorear> fromIntegral 3 == 3 in every way
18:28:24 <sorear> ok, the left triggers a warning with -Wall
18:28:24 <sjanssen> @src fromIntegral
18:28:25 <lambdabot> fromIntegral = fromInteger . toInteger
18:28:25 <sorear> :)
18:28:49 <Saizan> defaulting?
18:28:52 <sjanssen> sorear: you can use defaulting to make them different
18:29:02 <sjanssen> defaulting + broken Num/Integral instances
18:29:49 <LoganCapaldo> So if I do something like data Bar = Boo | ...; and I make it an instance of Num, I can write nonsense like Boo + 4 ?
18:30:20 <sjanssen> yep
18:30:25 <dons> or 4 :: Boo
18:30:29 <dons> sorry, Bar
18:30:39 <dons> that is, use numeric literals instead of your constructors
18:30:43 <dons> fun fun!
18:30:43 <LoganCapaldo> yeah
18:30:47 <LoganCapaldo> wacky
18:30:55 <sorear> sjanssen: I knew about defaulting, I just forgot it was configurable :)
18:30:59 <dons> now, who wants to derive IsString, and then use string literals for , say, regexes
18:31:02 <dons> or other dsls
18:31:10 <jcreigh> xml! :)
18:31:12 <dons> printf's format string could be properly typed :-)
18:31:14 <LoganCapaldo> waaaaaaaa?
18:31:24 <LoganCapaldo> theres an IsString class?
18:31:32 <sjanssen> there are many many fun uses for overloaded strings
18:31:38 <LoganCapaldo> @instances IsString
18:31:38 <dons> PrintfExpr = [ConversionChars] --> "%d%f" :: PrintFExpr
18:31:39 <sorear> LoganCapaldo: sjanssen addedit!
18:31:39 <lambdabot> Couldn't find class `IsString'. Try @instances-importing
18:31:48 <sorear> LoganCapaldo: head only
18:31:55 <sjanssen> instance IsString (CharParser ())
18:32:02 <dons> yeah, i think overloaded strings are more useful than overloaded numerics
18:32:06 <sorear> instance IsString Doc
18:32:07 <sjanssen> sorear: nah, that was augustss
18:32:09 <LoganCapaldo> addedit?
18:32:14 <dons> and overloaded numeric literals only really become useful with deriving Num
18:32:48 <sorear> dons: surely as the fps maintainer you've wanted machine Ints a few times :)
18:32:50 <ndm> sorear, that trick in All is very cool :)
18:33:03 <sorear> ndm: thanks :)
18:33:03 <sjanssen> instance IsString (IO ()) where fromString = putStr
18:33:17 <LoganCapaldo> Eeek
18:33:20 <dons> mmm
18:33:24 <LoganCapaldo> You're scaring me now
18:33:25 <sorear> LoganCapaldo: added + it
18:33:30 <jcreigh> so you could write
18:33:32 <sjanssen> do "hello world\n"
18:33:34 <jcreigh> main = "Hello, world!"
18:33:35 <ndm> dons, you changed the instances of Binary on the home page and in the haddock - was that they new way you want them doing?
18:33:37 <jcreigh> right?
18:33:41 * LoganCapaldo doesn't want literals to have side effects
18:33:42 <sjanssen> jcreigh: correct
18:33:55 <jcreigh> LoganCapaldo: only in the IO monad.
18:34:14 <dons> ndm, hmm, so you mean i didn't update the docs?
18:34:14 <tz_> I am reading a haskell tutorial, it says that data Tree a = Leaf a | Branch a (Tree a) (Tree a)  should work, but :t Tree returns  Not in scope: data constructor `Tree'
18:34:17 <dons> when 0.3 came out.
18:34:19 <ddarius> LoganCapaldo: addedit is like reddit only much more constructive.
18:34:24 * LoganCapaldo doesn't want literals to have side-effects
18:34:32 <LoganCapaldo> ddarius: heh
18:34:38 <dibblego> tz_, try :t Leaf 7
18:34:50 <sjanssen> LoganCapaldo: they don't really have side effects
18:34:54 <ndm> dons, you did update the docs, with different instances - i.e. put (1 :: Word8) instead of putWord8
18:35:05 <dons> oh, that's fine though.
18:35:11 <dons> that's just stylistic, isn't it?
18:35:23 <LoganCapaldo> well if you do that main = "Hello, world!" thing they do
18:35:25 <sjanssen> LoganCapaldo: remember that a value :: IO () is just like any other pure value
18:35:25 <ndm> dons, i was just checking that it is just stylistic :)
18:35:29 <ddarius> :k Tree
18:35:31 <lambdabot> * -> *
18:36:13 * ddarius agrees with LoganCapaldo that that would be disgusting.
18:36:13 <tz_> dibblego: ahh I get it now, only leaf and branch are the constructors
18:36:17 <jcreigh> LoganCapaldo: sure, but it's not like it's unsafePerformIO or anything...everything that has side-effects would still be in IO...but I agree, it's not a really good idea, just a cool hack.
18:36:19 <LoganCapaldo> sjanssen: Ok, I don't want literals to have side effects in actuality whether or not from a purity stand point they do or not :)
18:36:28 <dibblego> tz_, correct, Tree *is* the type
18:36:33 <ddarius> tz_: To be more specific, they are data constructors.  Tree is a type constructor.
18:36:59 * LoganCapaldo is not suggesting the removal of IsString for this reason, just that he hopes no one seriously uses instance IsString IO ()
18:37:20 * sorear wants types of kind Int -> *
18:37:37 <sjanssen> sorear: yes!
18:37:39 <ddarius> We never should have pointed sorear at dependent types.
18:37:46 <sjanssen> we need some limited value kinds
18:38:19 <ddarius> Tuple 1729
18:38:21 <dons> sjanssen: ok. i pushed the patch for polymorphc stackset
18:38:21 <sjanssen> not full on dependent types, just convenient syntax (and efficient implementation) for type class numerals
18:40:00 <sorear> ddarius: you think I'm more dangerous than McBride?! ;)
18:40:07 <sjanssen> sorear: identityMatrix :: Matrix 2 2 looks much better than identityMatrix :: Matrix (Succ Zero) (Succ Zero) :)
18:40:27 <ndm> sorear, not until you reach legal drinking age
18:40:33 <sorear> sjanssen: huh?  why are you comparing the syntax of inequivalent objects?
18:40:55 <ddarius> sorear: No, just more voluble on #haskell.
18:40:55 <sjanssen> s/Zero/(Succ Zero)/
18:41:07 <sorear>  /g ;)
18:41:07 <sjanssen> see, it's so lengthy I got it wrong!
18:41:17 <ddarius> Matrix D2 D2
18:41:30 <jcreigh> dons: hmm? Why does StackSet need to be parameterized like that?
18:42:03 <sorear> I look forward to type functions.  (I like MPTC + FD, but see ugliness)
18:42:18 <sjanssen> Matrix 232 232 is better than Matrix (D2 (D3 D2)) (D2 (D3 D2))
18:42:35 <sjanssen> sorear: type functions ala associated types?
18:42:46 <sorear> yes.
18:42:53 <sorear> same technology
18:43:00 <sorear> see the ghc wiki for details
18:43:06 <ddarius> (D2 D3 D2) (D2 D3 D2)
18:43:11 <dons> jcreigh: since its supposed to be a general purpose structure (originally), but we'd inlined WorkspaceId and ScreenId, which aren't really specific to the concept of a 3 level table structure
18:43:29 <ddarius> Such as could be used for a page table.
18:43:33 <dons> that is, we just statically enforce that the two index levels are different types, but are polymorphic in those types.
18:43:44 <dons> then we instantiate StackSet to the Workspace type in XMonad.
18:43:47 <sorear> ddarius: not all the world is ia32
18:43:51 <dons> no lines of code change , but StackSet becomes more general
18:44:02 <sorear> ddarius: some systems use 4-level tables
18:44:06 * ddarius 's world falls apart.
18:44:13 <sorear> ddarius: a chance for type nats! ;)
18:44:21 <dons> jcreigh: make sense?
18:44:34 <jcreigh> dons: yeah
18:45:13 <jcreigh> I don't know if I like the name "Workspace" for StackSet WorkspaceId ScreenId Window, though.
18:45:34 <jcreigh> 1) we were thinking about maybe a Workspace type that bundles the window list, focus, and layout desc.
18:45:45 <sjanssen> yeah, Workspace is a bad name
18:45:48 <jcreigh> 2) we have WorkspaceId which refers to workspaces in the StackSet.
18:45:50 <sjanssen> Workspaces might be okay
18:46:15 <dons> jcreigh: yeah, its a two level thing now.
18:46:40 <dons> that is, we have physical screens onto virtual screens, which are stacks of windows containing clients
18:47:45 <sjanssen> hmm, what should this thing be called?
18:48:36 <dons> hmm.
18:48:48 <LoganCapaldo> WarmFuzzy?
18:48:55 <dons> btw, we're writing some really nice QC tests now.
18:49:08 <dons> i.e. there's a test that asserts promote never modifies other windows, than the master and focused
18:49:24 <dons> which is a moderately high level property
18:49:43 <sjanssen> is it a WindowSet?
18:50:20 <jcreigh> hmm. Yeah, that could work.
18:50:23 <dons> hmm. a ScreenSet ?
18:50:34 <jcreigh> oh, I'm torn now. :)
18:50:34 <dons> we have a set of screens. each screen is a set of windows. isn't it?
18:50:34 <sjanssen> well, it's actually both of those things
18:51:06 <sjanssen> dons: but there are also windows that aren't contained in screens
18:51:37 <sjanssen> next suggestion: View
18:51:39 <ddarius> ndm: What is left in the language then?
18:51:57 <dons> StackSet instantiated to windows sounds like a WindowSet to me :-)
18:52:40 <jcreigh> I think WindowSet is good. It is certainly less confusing than "Workspace"
18:52:48 <dons> yeah.
18:52:48 <ddarius> ndm: Incidentally, cool reference.
18:53:09 <LoganCapaldo> WorkingSet ;)
18:53:15 <jcreigh> JetSet
18:54:27 <sjanssen> okay, I'll change it to WindowSet now
18:54:35 <ndm> ddarius, how do you mean - what is left? we have left either data, or higher-order functions - nothing else
18:54:47 <ndm> ddarius, which ref?
18:55:41 <sorear> ddarius: I replied on the ML
18:55:47 <ddarius> The Efficient Interpretation one.
18:56:10 <ddarius> ndm: You wanted something with only first-order functions and laziness.
18:56:22 <sorear> ddarius: err, there was no efficient interpretation one
18:56:31 <sorear> you're mixing words from his two refs
18:56:46 <ddarius> "Efficient Interpretation by
18:56:46 <ddarius> Transforming Data Types and Patterns to Functions"
18:57:02 <sorear> bah, *I* misread it :(
18:57:20 <sorear> so I see I was beaten again to that invention :)
18:58:16 <sorear> ndm: so you agree joelr1 should get a credit?
18:58:34 <ndm> ddarius, ideally, yes - but as sorear says, thats not possible
18:58:53 <ndm> sorear, yep, thats fine by me - patches all applied
18:59:27 <sjanssen> so, I see only a couple things before xmonad 0.1:  update the website, make sure the killClient bug is fixed, get tarballs on hackage
18:59:39 <sjanssen> dons, jcreigh, dmwit, anybody: am I missing anything?
18:59:43 <ddarius> ndm: Well, with Integers you could do Goedel encoding.
18:59:49 <jcreigh> does xmonad 0.1 also mean X11-extras 0.1?
18:59:56 <sjanssen> jcreigh: yeah
19:00:07 <ddarius> With just Ints you are kind of limited, though I guess you could use a function of many many Ints.
19:00:22 <dons> sjanssen: right i'm doing some more QC tests now.
19:00:31 <jcreigh> I think accessor names of some of the records in X11-extras need to be changed before X11-extras 0.1
19:00:40 <sjanssen> right
19:00:42 <dons> sjanssen: and get DavidR to check the xclock bug is gone
19:00:58 <sorear> ddarius: see my point about turing strength though
19:01:11 <sjanssen> dons: right, I'm waiting on a reply
19:01:12 <sorear> and by recursive I meant 'infinite information capacity'
19:01:23 <dons> yeah, then website. and some beta testing.
19:01:31 <dons> just get everyone on the list to take a tarball, build it, check it works
19:01:33 <jcreigh> what's the standard way? X11 seems to use lowercase+underscore (rect_x) but some types in X11-extras useCamelCase.
19:01:44 <dons> sjanssen: so perhaps a release candidate just circulated on xmonad@ ?
19:01:54 <ndm> ddarius, i specificially limited to Int for  that very reason :)
19:02:03 <sjanssen> dons: sure
19:02:06 <ddarius> I guess you could number the functions and have a dispatch function a la defunctionalization...
19:02:09 * ddarius thinks.
19:02:29 <ndm> ddarius - requires an unbounded number of functions, i.e. Integer once more
19:03:21 <ddarius> ndm: Well, yes in theory we're SOL, there are only a finite number of functions Int -> Int -> ... a finite number of times -> Int
19:03:52 <sorear> ddarius: there are countably many, since the finite number is unbounded.
19:04:05 <jcreigh> sjanssen: do you think e_ is enough of a prefix for Event?
19:04:07 <sorear> ddarius: but any *particular* such function is finitely complex
19:04:10 <ddarius> sorear: If you have an infinite amount of source.
19:04:25 <sjanssen> jcreigh: I'd rather avoid a prefix
19:04:42 <sjanssen> jcreigh: that is what module qualification is meant for, in my opinion
19:04:53 * sorear thinks it's really neat that the integers are an infinite well ordered set where every element has a finite number of predecessor
19:04:58 <atp> hey guys, i'm a haskell newbie, i'm trying to understand some notation.  looking at yaht right now, on page 120, and i see the following definition: search2 g@(Graph vl el) src dest ... what does the @ mean here?
19:05:09 <jcreigh> sjanssen: but the rest of the X11 library prefixes.
19:05:09 <sorear> at pattern
19:05:11 <jcreigh> (AFAICT)
19:05:20 <atp> sorear: at pattern?
19:05:23 <dons> atp, high. the @ is a variable binding
19:05:30 <sjanssen> jcreigh: yes, this seems to be the case
19:05:30 <sorear> atp: it binds g to '(Graph vl el)'
19:05:35 <sorear> atp: shorthand
19:05:39 <dons> atp, it introduces a new variable 'g' bound to the pattern that matched
19:05:45 <sjanssen> jcreigh: nobody has said that the X11 library is nice, though ;)
19:05:45 <atp> ah, i see
19:05:53 <atp> so g refers to a Graph vl el then?
19:06:03 <ddarius> Adenosine triphosphate?
19:06:06 <sjanssen> jcreigh: but, maybe we should match it anyway
19:06:15 <sjanssen> atp: correct
19:06:29 <jcreigh> sjanssen: that is my feeling. Even a bad coding convention followed all the time is better than a good one half the time.
19:06:29 <atp> g is the whole Graph ... type, and vl and el are the constituents or whatever in the following function definition
19:06:43 <atp> (i'm not sure about the right words for these concepts yet)
19:07:02 <sjanssen> atp: you can read the @ as the word "as"
19:07:10 <atp> that makes sense actually, that way in recursion i can pass the g back to search2, and yet still operate on vl and el
19:07:34 <atp> thanks guys, i'm not sure where i missed that ... appreciate the help :)
19:08:06 <atp> ddarius: no, my initials :)
19:08:07 <jcreigh> sjanssen: so I was thinking maybe e_ for event, wa_ for window attibutes and wc_ for window changes.
19:10:36 <sjanssen> jcreigh: that sounds fine
19:10:56 <sjanssen> what does X11 do for multi word fields?  All _'s?
19:10:56 <sorear> people use Hungarian notation in Haskell? :)
19:11:09 <jcreigh> sjanssen: I think so...lemme check...
19:11:18 <sjanssen> sorear: when the record system bites you, yes :(
19:11:46 <sjanssen> I think a C struct style namespace would be nicer for records
19:13:26 <jcreigh> hmm, I can't quickly find anything where X11 wraps a multi word field. But I think, eg, "wc_border_width" would be most consistent.
19:13:42 <sjanssen> sounds fine by me
19:13:46 <araujo> ibid, ping
19:14:02 <jcreigh> okay.
19:28:35 * jcreigh repents of single character prefixes, and decides to go with at least ev_
19:30:27 <sorear> Today's entry for the Lispy Haskell Contest:
19:30:28 <sorear>         norm = showParen' (vr 'p' >: lit 10)
19:30:28 <sorear>                ((.::) (intersperse (l1 "showChar" (lit ' '))
19:30:28 <sorear>                        (ssl pname : map (l2 "showsPrec" (lit 11)) (ctv 'x'))))
19:30:40 <jcreigh> hmm, now I think I can get rid of that trailing underscore that's used to avoid conflicts in certain places.
19:31:25 <araujo> http://araujoluis.blogspot.org
19:31:34 <araujo> comments welcome :-)
19:31:48 <sorear> araujo: bad link
19:32:01 <araujo> http://araujoluis.blogspot.com
19:32:03 <lambdabot> Title: araujo's blog
19:32:08 <araujo> ya!
19:32:23 <sorear> araujo: http://planet.haskell.org/policy.html
19:32:33 <RyanT5000> is it possible to run a serious website on HSP?
19:32:58 <RyanT5000> (or some other haskell system)
19:32:58 <lambdabot> Title: Membership policy - Planet Haskell
19:32:58 <sorear> araujo: the url is a bit misleading
19:33:04 <sorear> RyanT5000: I don't know, but serious websites have been run on HAppS (also haskell)
19:33:08 <sorear> @paste
19:33:09 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:33:14 <sorear> written in haskell!
19:33:19 <araujo> sorear, i sent an email to the contact of planet haskell
19:33:19 <RyanT5000> sorear: cool
19:34:46 <araujo> sorear, what do you mean?
19:35:56 <araujo> sorear, if you say it for the _long_ name, i could consider to point fmap.us to it :-)
19:39:16 <sorear> araujo: huh?
19:40:00 <araujo> sorear, about your comment of the url a bit misleading
19:40:26 <sorear> I was referring to this one -->http://planet.haskell.org/policy.html<--
19:40:37 <sorear> sorry ;)
19:40:43 <araujo> hah ok :-)
20:09:13 <plediii> does anyone else have problems with haskell-mode causing emacs to freeze?
20:09:48 <sorear> no
20:10:04 <sorear> it causes emacs to freeze, but that isn't a problem for anyone else :)
20:10:19 <plediii> fantastic :)
20:10:29 <sorear> hit C-g, and in the future make sure the ghci prompt has no text on it before trying to reload
20:11:10 <plediii> ok.  I've been killing ghc.
20:11:26 <sorear> C-g is nicer, it kills nobody ;)
20:15:22 <dons> ?yow
20:15:23 <lambdabot> YOW!!  Now I understand advanced MICROBIOLOGY and th' new TAX REFORM
20:15:23 <lambdabot> laws!!
20:15:28 <dons> cool!
20:15:48 <dons> sjanssen: got some QC tests working on the tiling algo now :-)
20:15:50 <dons> e.g. tile 1 window fullsize   : OK, 100 tests.
20:15:57 <sorear> dons++
20:16:04 <dons> given 1 window on the screen, tiling it always returns a mazimised window
20:16:28 <dons> world's best specified window manager, yeah!
20:17:09 <sorear> I presume you aren't counting your QC props in the LoC ;)
20:17:22 <sjanssen> a desired property: windows never overlap in tile mode
20:17:32 <sorear> dons: also, did you catch the edit sjanssen made to the README?
20:17:35 <petekaz> is xmonad better than dwm now?
20:17:36 <dons> yeah, trying to do that now.
20:17:56 <sjanssen> petekaz: for some definitions of better, yes
20:18:24 <petekaz> haskell programmers are nerdy even with their witty responses.
20:18:24 <sorear> For instance, xmonad has a longer name.
20:18:29 <sjanssen> xmonad is also worse than dwm, for some definitions of worse
20:18:31 <dons> sjanssen: also, is there some inversion property?
20:18:41 <sjanssen> dons: inversion?
20:18:46 <dons> tile . vtile . tile x == tile x ?
20:18:59 * dons trys to work out the relation between vtile and tile
20:19:05 <sjanssen> hmm, can't remember
20:20:47 <jcreigh> flipRect . flipRect == id
20:21:02 <jcreigh> flipRect could be better named mirrorRect, I now realize.
20:21:14 <sjanssen> jcreigh: therefore vtile . vtile == id?
20:21:24 <jcreigh> hmm.
20:22:04 <sjanssen> eh, that isn't quite right
20:22:12 <jcreigh> what would that mean? You can't apply tile twice.
20:22:30 <sjanssen> yeah, that's why it isn't quite right
20:23:54 <sjanssen> jcreigh: so are you currently changing names in X11-extras?
20:24:23 <jcreigh> yup. just send patch for X11-extras. Now recording changes to xmonad, that patch will follow in a minute.
20:25:53 <jcreigh> haha, LOC check runs after record.
20:26:12 <sorear> yay!
20:26:31 <dons> cute eh? david r sent us that.
20:26:34 <jcreigh> sent xmonad patch.
20:26:56 <dons> yeah, you can't apply tile twice.
20:26:59 <SamB_XP> does it fail if it goes over x00?
20:27:00 <jcreigh> so I used ev_ wa_ and wc_ followed by the C struct name.
20:27:11 <jcreigh> if anybody wants it different, now is the time to change it.
20:27:13 <sorear> dons: Interestingly, the test is inconsistant with the docs.
20:27:18 <dons> there's not really any concept of multiple tiling affecting each other.
20:27:24 <dons> sorear: whiihc test is that?
20:27:34 <sorear> dons: the loc one
20:27:52 <SamB_XP> should test the docs too ;-P
20:28:02 <dons> do i have to guess why? or do you want to tell me? :-)
20:28:03 <sorear> oh, nm, the test was updated too
20:28:18 <dons> yes, we made a decision. its all very secret hush hush
20:28:25 <sjanssen> jcreigh: pushed
20:29:02 <sjanssen> sorear: I had to fix the test, or all my records would fail
20:29:31 <jcreigh> cool. Now the naming convention matches the rest of X11. WindowAttributes is still incomplete, but that matches the rest of X11 too. :)
20:31:35 <sorear> sjanssen: you couldn't be bothered to refactor? :)
20:32:15 <sjanssen> sorear: 70 LOC in one refactoring patch?  I don't have those mad skillz
20:32:39 <dons> sure, 70 type signatures we don't need ;-)
20:32:41 <dons> mwhahaha
20:33:06 <sjanssen> ull... we've got 11 LOC left
20:33:16 <sorear> With this SoC thing I'm sure we'll be able to get it down to 200 LoC.
20:34:26 <SamB_XP> 11 LoC?
20:34:44 <sjanssen> SamB_XP: xmonad is 11 lines of code away from the 500 cap
20:34:54 <SamB_XP> ah.
20:35:01 <dons> hehe
20:35:04 <dons> i think that's fine though.
20:35:11 <sjanssen> yeah
20:35:12 <dons> 500 lines is nice and round for a 0.1 release.
20:35:23 <SamB_XP> I was going to say, what did you do with the other 390 something lines?
20:35:24 <sjanssen> might have to bump up to 550 for 0.2
20:35:34 <sorear> really, we ought to be able to shrink it a lot ... are we using any hofs yet?
20:35:35 <dons> yeah, there'll be a small increase.
20:35:39 <SamB_XP> er, s/something/+/
20:35:45 <dons> sorear: any? lots.
20:35:53 <dons> but there's some room for nice refactoring.
20:35:58 <sjanssen> sorear: I suspect much of the code will be resistant to shrinking
20:36:02 <dons> as long as we don't compromise proper development practices.
20:36:11 <SamB_XP> sorear: how do you write Haskell without hofs?
20:36:17 <sjanssen> a lot of it is just X11 calls
20:36:27 <dons> right. and logic that we can't fix much.
20:36:28 <sorear> SamB_XP: cases, recursion, ...
20:38:31 <jcreigh> darcs is really rather nice.
20:38:32 <SamB_XP> sorear: ... slightly better than programming in C...
20:38:45 <jcreigh> interactive record and revert have been really handy.
20:38:52 <sorear> SamB_XP: quite a bit, judging from my experiments a few days ago
20:39:03 <sjanssen> @remember jcreigh darcs is really rather nice.
20:39:04 <lambdabot> Done.
20:39:10 <SamB_XP> okay, so a couple orders of magnitude
20:39:17 <sorear> SamB_XP: massively hack-tuned haskell is less prone to segfaults than naive C
20:39:34 <sorear> and I mean glasgow haskell#
20:40:17 <jcreigh> some of the nice things about darcs could be in, eg, subversion just by making the client nicer, however.
20:41:34 <dibblego> wtf is with this ACM mob? trying to charge me to read a flippin paper
20:42:09 <sorear> dibblego: google the name, citeseer is very good about giving me free pdfs
20:42:27 <jcreigh> "Effective Business Models in Academia: A Case Study"
20:42:28 <dibblego> sorear, I tried that
20:42:47 <SamB_XP> coca-cola ads in your pdfs!
20:42:58 <dibblego> Delta storage for arbitrary non-text files, Christoph Reichenberger
20:43:25 <jcreigh> Be the envy of your friends with the new Apple iCurry!
20:43:38 <SamB_XP> iCurry?
20:43:59 <SamB_XP> is that the new name for the Haskell support for XCode?
20:44:01 <sorear> @remember dibblego wtf is with this ACM mob? trying to charge me to read a flippin paper
20:44:01 <lambdabot> Done.
20:44:06 <jcreigh> SamB_XP: I was imagining what kind of ads would be in whitepapers.
20:44:06 <sorear> @flush
20:44:20 <SamB_XP> @quote
20:44:21 <lambdabot> zeeeeeee says: so aside from the refactoring, there's no other (major) improvements i can make to my program?
20:46:47 <jcreigh> sjanssen: oh, I just remember. We might want to think about DefaultConfig.hs again before 0.1
20:46:55 <jcreigh> s/remember/&ed/
20:52:15 <dons> hmm do we?
20:53:47 <jcreigh> "might" I said. I don't know...if the user doesn't change the default config, it's kinda nice just to have stuff merge magically on "darcs pull"
20:54:21 <jcreigh> OTOH, I don't like have to not record a bunch of changes in my Config.hs whenever I send a patch...
20:54:37 <jcreigh> maybe just let it go for now since there's no obvious right thing yet.
20:55:23 <petekaz> how do I lowercase a bytestring?
20:56:38 <dons> map toLower
20:56:42 <dons> using the .Char8 module
20:57:12 <petekaz> Hmmm ... I must have overlooked that, perhaps I was looking in the wrong module.
20:57:13 <petekaz> thanks.
20:57:58 <dons> ?docs Data.ByteString.Char8
20:57:59 <lambdabot> Data.ByteString.Char8 not available
20:58:04 <LoganCapaldo> toLower is an idempotent function
20:58:05 <dons> that's the module
20:58:07 <LoganCapaldo> hooray
20:58:11 <dons> yeah :-)
20:58:31 <sorear> dons: I suppose you have a RULE for that :)
20:58:38 <dons> #haskell's word of the day is "idempotent"
20:58:51 <dons> and is brought to you by the number 7 and the latter Lambda
20:59:15 <Cale> As in (map toLower) is idempotent.
20:59:16 <jcreigh> ya know, I always thought that idempotent meant "non-side-effecting". but that turns out not to be the case.
20:59:34 <dons> sjanssen:
20:59:34 <dons> tile 1 window fullsize   : OK, 100 tests.
20:59:34 <dons> tiles never overlap      : OK, 100 tests.
20:59:36 <dons> :-)
20:59:46 <ddarius> And we can figure that out from idempotency of toLower and the free theorems.
21:00:02 <Cale> Well, that is something which ought to be true of idempotent functions in an impure language.
21:00:12 <sorear> ddarius: no.
21:00:14 <LoganCapaldo> ddarius: that's right. Totaly sweet
21:00:32 <LoganCapaldo> or maybe its not right??
21:00:34 <Cale> But the converse isn't true.
21:00:46 <sorear> ddarius: mapReverse satisfies the same free theorems as map (it has the same type!), but mapReverse toLower is *not* idempotent.
21:00:49 <TSC> Cale: What about a procedure that sets a global variable to zero?  It's idempotent, but has a side effect
21:01:03 <jcreigh> @check (\c -> (toLower c) == (toLower . toLower $ c))
21:01:05 <lambdabot>  OK, passed 500 tests.
21:01:29 <sorear> ddarius: where mapReverse f x = map f (reverse x)
21:01:29 <Cale> Oh, I suppose that might work -- supposing there's no concurrency.
21:01:56 <LoganCapaldo> Yes apprently idempotence has nothing to do with side effects :)
21:02:03 <LoganCapaldo> hooray side effects
21:02:11 <Cale> Well, that's an idempotent side-effect :)
21:02:40 <jcreigh> hmm...this changes the whole GET vs. POST thing around for me. :)
21:05:03 <jcreigh> dons: how are you testing the tiling functions? You must have generalized the type.
21:05:03 <dons> no?
21:05:03 <LoganCapaldo> Your type sir, is general. I wish to specialize it.
21:05:03 <jcreigh> hmm? How do you get Windows to feed in?
21:05:03 <jcreigh> tile :: Rational -> Rectangle -> [Window] -> [(Window, Rectangle)]
21:05:03 <dons> Window is Int, iirc :-)
21:05:08 <dons> its a XPID
21:05:14 <LoganCapaldo> :type undefined :: Window
21:05:48 <jcreigh> type Window = XID
21:05:49 <LoganCapaldo> > let paddle _ = "Ouch!" in paddle undefined
21:05:51 <lambdabot>  "Ouch!"
21:05:52 <jcreigh> type XID = Word32
21:05:56 <jcreigh> so yes.
21:06:16 <sorear> Do we usually break before or after operators?
21:06:30 <sorear> foo . \n bar        vs        foo \n . bar
21:06:46 <LoganCapaldo> ewww
21:06:58 <LoganCapaldo> is foo . bar an option?
21:07:31 <sorear> LoganCapaldo: yes, but when my 128-ch screen wraps it's time to insert newlines ;)
21:07:54 <LoganCapaldo> maybe foo . bar where foo = long subexpression \n bar = long subexpression
21:08:03 <jcreigh> sometimes I do a vert split in vim to bring my width to ~80ch to force myself to make my code more readable.
21:08:28 <jcreigh> whenever I get sloppy in Haskell, it seems to spawn very long lines.
21:08:29 <LoganCapaldo> sometimes I maximize my window to force myself to stop thinking about hard column limits
21:09:16 <dylan> 80 column code is good
21:09:24 <jcreigh> I find very long lines hard to read, and view them as a codesmell.
21:09:36 <dylan> I can fit 4 88x29 terminals on my display
21:10:12 <dylan> in typsetting, lines are usually cut at like 70 letters
21:10:17 <dylan> IIRC.
21:10:30 <dylan> I've read some pretty badly typeset textbooks though.
21:11:20 * LoganCapaldo thinks breaking at operators does not solve the "long line" problem and that giving meaningful names to sub expressions is beneficial in more than just shorter lines
21:11:42 <LoganCapaldo> But everybody seems to use variables named with single letters here
21:11:48 <LoganCapaldo> So I may be the weirdo :)
21:12:14 <dylan> okay
21:12:26 <dylan> my touchpad is broken. :(
21:15:19 <dons> sjanssen, jcreigh. ok. i'm done with QC properties now.
21:15:27 <dons> should be in the repo
21:15:58 <jcreigh> LoganCapaldo: right, totally. I'm saying long lines are generally bad, but short lines are not nessesarily good.
21:16:25 <jcreigh> ...in other news, I can't spell.
21:16:35 <LoganCapaldo> Its ok, I can't read :)
21:16:40 <jcreigh> heh
21:18:05 <jcreigh> hmm, runghc tests/Properties.hs fails for me.
21:19:45 <dons> sjanssen: ok. so David R says the kill bug is gone. and i haven't seen it today. looks good
21:20:11 <jcreigh> dons: is runghc tests/Properties.hs the canonical way to run tests?
21:20:29 <dons> not now, we actually need to compile it
21:20:38 <jcreigh> ah, the linker thing is a known issue?
21:20:40 <dons> ghc --make tests/Properties.hs ; tests/Properties
21:20:42 <dons> yeah.
21:21:02 <dons> might be we left the cbits in X11 out of the .cabal file?
21:21:18 <dons> cool . the only thing left on the todo list is the website :-)
21:22:28 <TSC> Is xmonad supposed to react if a window changes size by itself?
21:22:49 <TSC> For example, in gnome-terminal, if I change the font size, the window size changes and xmonad doesn't notice
21:22:59 <TSC> (until I do something like Mod-l)
21:23:20 <dons> yeah, we don't attempt to handle that (yet)
21:23:27 <dons> similar in xv or gv
21:23:41 <dons> tends not to be annoying, i've found. is that your experience too TSC?
21:23:58 <TSC> It's not really annoying, because it's only a keypress to fix
21:24:02 <dons> yeah.
21:25:20 <jcreigh> handling that could be tricky...I could envision certain apps resizing themselves after they notice the WM resized them. Some applications are just X11 sociopaths, that's all.
21:26:27 <jcreigh> it would be trivial to bind a key to "refresh" though. but maybe it's not required, since it's so simple just to mod-j or whatever.
21:27:09 <ed1t> wats better scheme or haskell?
21:27:29 <jcreigh> ed1t: depends on what you want to do.
21:27:43 <jcreigh> (and whether you like lisp)
21:27:46 <sorear> ed1t: haskell, since this is #haskell.
21:28:02 <ed1t> jcreigh just for normal programming...
21:28:09 <sorear> ed1t: curiously, if you ask on #scheme you will probably get more insults than "scheme"s
21:28:13 <dons> hmm
21:28:53 <jcreigh> could not find instance Ord for type ProgrammingLanguage
21:29:01 <dons> hehe
21:30:28 <LeCamarade> ed1t: Scheme is good to know, because it edifies a lot, and improves the thining quality that goes into your code. Haskell improves on where the second-best language (whichever it is)) stops.
21:30:54 <dons> i think we should have a policy of not debating "which is better, Haskell or $prog" issues ;-)
21:31:14 <dons> unless $prog `elem` [Epigram,Isabelle] mwhaha
21:31:30 <jcreigh> Which is better, Haskell or Global Thermonuclear War?
21:31:39 <LeCamarade> dons: Yeah, I agree. Of course it means we'll all get arrested. :oD
21:31:55 <sjanssen> jcreigh++
21:31:56 <LeCamarade> jcreigh: Global Thermonuclear War, of course.
21:32:07 <sjanssen> @remember jcreigh could not find instance Ord for type ProgrammingLanguage
21:32:08 <lambdabot> Done.
21:32:35 <sorear> LeCamarade: you guys are all such wimps.  haskell isn't really that bad!
21:32:54 <jcreigh> Sometimes I say something witty hoping that someone will @remember it...pathetic, I know. :)
21:33:16 <sorear> @flush
21:33:23 <sjanssen> @remember jcreigh Sometimes I say something witty hoping that someone will @remember it...pathetic, I know. :)
21:33:24 <lambdabot> Done.
21:33:26 <sjanssen> @flush
21:33:34 <jcreigh> ed1t: How familar are you with recursion, first class functions and/or closures?
21:33:36 <sjanssen> now *that* is a good quote
21:33:56 <jcreigh> heh heh. You've played right into my hands. :P
21:34:12 <dons> sjanssen: so do we have a draft web page, and announce doc? or can we do that on friday when i get back to sydney?
21:34:22 <dons> i think all the technical stuff is done now.
21:34:36 <dons> you could perhaps roll a tarball and put it onto xmonad@ as a release candidate
21:35:20 <LeCamarade> sorear: Nuclear War, contrary to what dons says, has no monads in it. It _is_ better! :oD
21:35:31 <LeCamarade> @quote apples
21:35:32 <lambdabot> dons says: think of a monad as a spacesuite full of nuclear waste in the ocean next to a container of apples.  now, you can't put oranges in the space suite or the nucelar waste falls in the ocean, *
21:35:32 <lambdabot> but* the apples are carried around anyway, and you just take what you need.
21:35:45 <LeCamarade> :oD
21:35:47 <sjanssen> dons: yeah, I'll make an RC and wait 48 hours or so before announcing
21:35:53 <Heffalump> what's with those *s?
21:35:59 <hyrax42> I love that quote
21:36:02 <Heffalump> they seem a slightly odd way to mark continuations
21:36:10 <jcreigh> Heffalump: I think it's part of the quote
21:36:21 <jcreigh> "...in the ocean, *but* the apples..."
21:36:25 <Heffalump> oh, I see, yeah
21:36:29 <LeCamarade> Heffalump: No, just broke the line in the middle of an *emphasis*.
21:36:38 <dons> sjanssen: yeah, if you can wait till i get back to sydney (leaving in the morning)
21:36:41 <Heffalump> in that case the word breaking is broken :-)
21:36:46 <dons> since i'd like to chip in with the web page and announce stuff
21:37:13 * sorear just finished implementing Read/Show deriving for Data.Derive
21:37:19 <sjanssen> dons: yeah, I'd appreciate the help
21:38:07 <dons> hey Heffalump, did you hear- we wrote a window manager? :-)
21:38:30 <Heffalump> dons: I heard, yeah. I should try it :-) Though I don't actually want a tiling window manager.
21:38:44 <jcreigh> Heffalump: oh. You might be disappointed, then.
21:39:01 <dons> because it is a tiling window manager? :-)
21:39:06 <jcreigh> yes. :)
21:39:18 <jcreigh> so when xmonad goes 0.1, do I get my stock options, or is that later?
21:39:32 <dons> hehe
21:39:54 <Heffalump> I said try it, not switch to it :_)
21:39:57 <Heffalump> s/_/-/
21:40:21 <sjanssen> dons: when will be in .au and back in hacking mode?
21:40:35 <dons> 2 days?
21:40:46 <ed1t> jcreigh im not that good with recursion....but im not bad either
21:41:00 <dons> sjanssen: so we could release maybe sunday, given no issues coming up
21:41:11 <sjanssen> dons: sounds good
21:41:54 <jcreigh> ed1t: well, "The Little Schemer" is a great introduction to thinking recursively. (Which, as the name suggests, uses Scheme)
21:42:54 <jcreigh> ed1t: but it sounds like you might not need, although it's still a fun read.
21:43:20 <jcreigh> ed1t: ...but yeah, I'd say, try to learn both Haskell and scheme. They're both good to know.
21:43:20 <LeCamarade> ed1t: If you're not good at recursion, you'll learn. Thing is, if you do Haskell before Scheme, you won't do Scheme.
21:43:46 <ed1t> so do scheme before haskell?
21:45:13 <LeCamarade> ed1t: I'd say yes. Do Scheme, then move on to Haskell. Because, while Scheme is very important for you, you won't want to go back once you've done Haskell.
21:45:28 <ed1t> k
21:45:34 <dons> i'm not sure there's any point learning scheme now, though.
21:45:40 <dons> we have good success teaching just haskell
21:46:13 <dons> and scheme is just haskell without a good handle on side effects or types ;-)
21:46:18 <ed1t> in software developement world is either one used?
21:46:30 <dons> they're both used.
21:46:31 <LeCamarade> dons: It is the ideas of macros, Polish notation, and that very generic syntax that should be emphasised, and Haskell doesn't have them.
21:46:36 <jcreigh> I think Lisp is cool for the moment when you realize how much is possible with only lambdas and cons.
21:46:37 <johnnowak>  LeCamarade that's debatable. :)
21:46:42 <int-e> dons: but also without a lot of possibly confusing syntax sugar.
21:46:42 <jcreigh> Once you HOF, you never go back.
21:46:50 <dons> yeah, not sure macros matter that much. you get the same skills writing an interpreter
21:46:59 <dons> i.e. an understanding of term rewriting and ASTs
21:47:03 <LeCamarade> ed1t: They are used equally. Not much, by the way. Almost too little. Haskell more than Scheme, but not much for Haskell.
21:48:14 <ed1t> thx guys
21:48:40 <LeCamarade> dons: Actually, Scheme will present FP to students as it was done then (pre-ML, pre-Miranda), and then Haskell presents it as it will be done in the future. car/cdr, et al => Pattern Matching.
21:53:51 <LoganCapaldo> type People = [Person]
21:53:56 <LoganCapaldo> heh
21:53:57 <dmwit> Is there an "svn blame"-alike in darcs?
21:54:05 <LoganCapaldo> svn blame??
21:54:20 <dmwit> It tells who last changed a given line.
21:54:27 <abz_> darcs changes <file> | grep
21:54:27 <LoganCapaldo> oh
21:54:28 <lispy> dmwit: annotate is probably as close as you'll get
21:54:36 <LoganCapaldo> not as fun as I was hoping
21:54:45 <dmwit> Ah, annotate, sounds close enough.
21:54:47 <dmwit> thanks.
21:55:32 <dmwit> But that doesn't tell who submitted it at all!
21:55:41 <dmwit> I want a *name* to rail against. =P
21:55:52 <lispy> it tells me
21:56:00 <kilimanjaro> You can write a Scheme from scratch without much effort. That's enough reason to study it, if even for a short period of time
21:56:01 <lispy> it says who recorded the patch
21:56:16 <lispy> dmwit: let's move to #darcs, shall we?
21:56:21 <dmwit> Ah, grep had filtered them out.
21:56:35 * LeCamarade is glad to finally have found a project that requires the Awkward squad. :oD
21:56:52 <kilimanjaro> LeCamarade, what project is that? Writing a Scheme interpreter?
21:57:25 <LeCamarade> Nope. Something akin to a web server. Why is your nick after a mountain?
21:57:26 <LeCamarade> :oD
21:57:33 <kilimanjaro> LeCamarade, because I am tall and african
21:57:52 <LeCamarade> And you are located around the mountain?
21:58:06 <kilimanjaro> There are no mountains in Dallas :)
21:58:22 <LoganCapaldo> Dallas is pretty flat
21:58:22 <resistor> can named fields have default values?
21:58:30 <LeCamarade> Oh, I though we could have a two-man Haskell Hackathon. I'm in Uganda. :oD
21:59:03 <LoganCapaldo> resistor: I don't think so but you can fake it by starting off with a function
21:59:58 <kilimanjaro> LeCamarade, when you hack Haskell, you never hack alone
22:00:03 <LoganCapaldo> data Pair = Pair { x :: Int, y :: Int }; makePair = Pair { x = 0, y = 0 }; fooPair = makePair { x = 3 } -- y will be 0 by "default"
22:01:05 <LeCamarade> kilimanjaro: Yeah. Sure. Especially with #haskell staying around. Never alone. An army of Australian profs ready to take the monad torture for us ... ;oD
22:01:41 <hpaste>  dolio annotated "First pass ExtMonad" with "sorted, non-empty list" at http://hpaste.org/1449#a1
22:01:56 <dolio> @seen Philippa
22:01:57 <lambdabot> Philippa is in #scannedinavian, #oasis, #haskell-soc, #haskell-overflow, #haskell-blah and #haskell. I last heard Philippa speak 4h 16m 3s ago.
22:03:16 <sorear> @where polyparse
22:03:17 <lambdabot> I know nothing about polyparse.
22:03:25 <sorear> @google polyparse
22:03:26 <resistor> LoganCapaldo: cool, that worked.
22:03:26 <LoganCapaldo> @why not
22:03:27 <lambdabot> Maybe you meant: ghc what wn
22:03:28 <lambdabot> http://www.cs.york.ac.uk/fp/polyparse/
22:03:28 <lambdabot> Title: polyparse: alternative parser combinator libraries
22:03:40 <sorear> @where+ polyparse http://www.cs.york.ac.uk/fp/polyparse/
22:03:41 <lambdabot> Done.
22:03:44 <LoganCapaldo> resistor: glad to help
22:03:46 <dmwit> ?help wn
22:03:47 <lambdabot> I perform dictionary lookups via the following 13 commands:
22:03:47 <lambdabot> all-dicts ... Query all databases on dict.org
22:03:47 <lambdabot> devils ...... The Devil's Dictionary
22:03:47 <lambdabot> easton ...... Easton's 1897 Bible Dictionary
22:03:47 <lambdabot> elements .... Elements database
22:03:49 <lambdabot> [9 @more lines]
22:04:15 <lispy> wn?
22:04:26 <lispy> ?wn dictionary
22:04:28 <lambdabot> *** "dictionary" wn "WordNet (r) 2.0"
22:04:28 <lambdabot> dictionary
22:04:28 <lambdabot>      n : a reference book containing an alphabetical list of words
22:04:28 <lambdabot>          with information about them [syn: {lexicon}]
22:04:43 <lispy> oh, i bet it's named that because of 'wordnet'?
22:05:13 <dmwit> Ack!
22:05:26 <dmwit> xmonad now no longer uses Xinerama... =(
22:05:47 <sjanssen> dmwit: oh?  the configure check isn't working?
22:05:58 <dmwit> ...
22:06:01 <dmwit> How do I tell?
22:06:08 <sjanssen> dmwit: try re-running clean and configure in X11-extras
22:07:23 <sjanssen> clean configure install, that is.  You'll need to clean xmonad too
22:08:04 <dmwit> Still no good.
22:08:21 <sjanssen> hmm
22:08:28 <sjanssen> jcreigh: ping
22:08:31 <sorear> @seen malcolmw
22:08:32 <lambdabot> I saw malcolmw leaving #haskell-soc, #ghc, #haskell-overflow and #haskell 1d 12h 24m 7s ago, and .
22:08:51 <sjanssen> dmwit: oh, I forgot a key part
22:09:11 <sjanssen> run autoreconf in X11-extras, then repeat the clean/configure/build/install dance
22:09:34 <dmwit> okay...
22:10:25 <sjanssen> look for "checking for X11/extensions/Xinerama.h... yes" in the configure output
22:11:14 <LoganCapaldo> Xtreme Inerama
22:12:11 <dmwit> I've now aliased s=./Setup.lhs...
22:13:36 <sjanssen> I've considered teaching zsh to tab complete the options to Setup
22:13:44 <sjanssen> I don't know anything about it's tab completion, though
22:14:26 <dmwit> Ah, much better.
22:14:28 <resistor> if I have data Data = Data (Maybe Bigtype) (Maybe Bigtype); does "Data Nothing Nothing" use as much memory as "Data (Just poo) (Just poo)"?
22:14:29 <dmwit> Thanks!
22:14:39 <sorear> resistor: no!
22:14:42 <resistor> i mean does the constructor i use determine the size of the data
22:14:54 <sorear> resistor: no, haskell is very pointer-happy
22:15:00 <sorear> resistor: er yes
22:15:27 <resistor> good to know. thanks
22:15:37 <sorear> think of that as 'struct data { bigtype *a, *b; }' - the pointers can individually point to large or small objects
22:15:51 <dmwit> ?karma+ sjanssen , who always handles my emergencies
22:15:52 <lambdabot> sjanssen's karma raised to 48.
22:16:06 <sorear> good night all.
22:16:51 <dons> sjanssen: do you reckon you could get a release candidate out to the list tonight/tomorrow
22:16:58 <dons> so there's a couple of days of testing before we put it out?
22:17:14 <sjanssen> yeah, I could do it now
22:17:38 <jcreigh> sjanssen: pong
22:17:44 <sjanssen> jcreigh: false alarm
22:20:35 <sjanssen> is there a canonical way to indicate rc status in a Cabal version field?
22:20:43 <jcreigh> dmwit: so you somehow got an X11-extras compiled that didn't have Xinerama support?
22:20:44 <sjanssen> just 0.1-rc1?
22:21:16 <dons> hmm. i don't know of a way.
22:21:20 <dons> i'd just darcs dist to do it.
22:21:37 <dons> darcs dist -d xmonad-0.1rc1 or something like that
22:21:43 <dons> but also, we'll need X11-extras too
22:21:48 <sjanssen> meh, I'll just leave the version field at 0.0
22:21:50 <dons> since it's a simultaneous relesae
22:21:51 <jcreigh> ya'know, this *is* a 0.1 one release. Maybe people will figure out it's beta from that. :)
22:21:52 <dons> yeah
22:25:01 <dons> yay, xmonad! woot!
22:25:29 <dons> i love rewriting old C programs quickly, with smaller , nicer haskell programs
22:25:33 <dons> its so satisfying
22:26:11 <LeCamarade> dons: You said it!
22:26:50 <LeCamarade> dons: And when you show 'em around, people start asking about the speed. Man, isn't premature optimisation a sin?
22:27:23 <dons> good thing haskell is damn fast.
22:27:31 <jcreigh> But C *is* fast. When I do:
22:27:33 <jcreigh> ./a.out
22:27:38 <jcreigh> Segmentation Fault
22:27:42 <dons> whoa!
22:27:44 <dons> that *was* fast
22:27:45 <jcreigh> The message comes back almost instantly!
22:27:47 <dons> C is cool
22:27:56 <LeCamarade> :oD
22:28:45 * johnnowak wonders how many more years these sorts of conversations will go on for
22:29:08 <dons> 15 ?
22:29:13 <LeCamarade> johnnowak: Forever.
22:29:28 <johnnowak> dons: Any then what happens?
22:29:32 <johnnowak> *and
22:29:37 <dons> we start complaining Epigram is too slow
22:29:45 <dons> and our old buggy haskell apps are way better
22:30:15 <johnnowak> ah. :)
22:30:46 <johnnowak> maybe jcreigh's c programming will improve by then too. :)
22:32:12 <LoganCapaldo> signal(SIGSEGV, SIG_IGN)
22:32:36 <jcreigh> johnnowak: I doubt it. I'm probably always going to do stupid off-by-ones. So I think that, rather than basing your hope of correctness on not making "trivial" errors, it's better to use a language where it's easier to find them and fix them.
22:33:15 <LoganCapaldo> woah thats a nice compiler, giving you seg faults on off by one errors instead of just reading or writing (possibly dangerous) nonsense :)
22:33:23 <jcreigh> cue "Office Space" quote aboute trivial errors...
22:33:49 * johnnowak just uses dynamic arrays for most of his c programming
22:34:44 <geezusfreeek> i have discovered that translating semi-directly from a haskell program to c is difficult when your teacher requires that you index all your arrays starting at 1 :(
22:35:05 <LoganCapaldo> why for index arrays at 1?
22:35:09 <johnnowak> geezusfreeek: you may need to shoot the teacher
22:35:10 <geezusfreeek> he's an idiot
22:35:36 <LoganCapaldo> Option Base 1
22:35:36 <johnnowak> is he the author of numerical recipes?
22:35:49 * LoganCapaldo waits for his beatdown
22:36:01 <jcreigh> there is a really nasty trick you can do (make a pointer to the start of the array minus one) but you really don't want to do that.
22:36:32 <geezusfreeek> he marked off points on my last two assignments because he required some global constants, but not only did he not see any #defines, he noticed my int consts and marked off yet more points for using global "variables"
22:36:54 <jcreigh> What the heck? He want's #defines over int consts?
22:36:55 <LeCamarade> geezusfreeek: He's trying to make you invent a data structure. I'd give that test, too.
22:37:14 <sjanssen> geezusfreeek: do you have a professor above his head to go to?
22:37:39 <dons> hey geezusfreeek. i know you from reddit?
22:37:42 <geezusfreeek> i get the impression he's been teaching a long time... i bet everybody's already heard the complaints about him
22:37:46 <LeCamarade> geezusfreeek: On second thoughts, tell him to get some sleep.
22:37:49 <geezusfreeek> dons: probably :)
22:38:00 <jcreigh> I don't think geezusfreeek is jesusphreak
22:38:12 <geezusfreeek> yeah, jesusphreak is somebody else
22:38:17 <geezusfreeek> i run into him all the time though
22:38:22 <dons> but i've seen geezusfreeek too, or something similar
22:38:30 <geezusfreeek> i am also on reddit
22:38:37 <geezusfreeek> only kind of recently though
22:38:41 <dons> yeah
22:39:04 <dolio> He must have been attracted here by hearing that Haskell is a pile of shiny misfeatures. :)
22:39:44 <dons> hehe
22:39:49 <dons> shiny!
22:39:53 <geezusfreeek> anyway, i started learning some haskell a couple nights ago (no, not thanks to the torrent of haskell propaganda on reddit), and i implemented my entire next homework assignment in haskell in just 29 lines of code...
22:39:54 <LeCamarade> How about we start a Road to Haskell page? It'd be interesting to know why people picked it up.
22:40:01 <sjanssen> @smack aynrieu -- or however you spell it
22:40:02 <lambdabot> Unknown command, try @list
22:40:02 <dons> geezusfreeek: sweet
22:40:03 <geezusfreeek> my c version to turn in is at 550 lines and counting
22:40:09 <dons> that's exactly what we hope for :-)
22:40:09 <jcreigh> gah
22:40:15 <jcreigh> geezusfreeek: what's the assignment?
22:40:17 <dons> geezusfreeek: so what's the difference, data structures?
22:40:18 <geezusfreeek> but that's mostly thanks to my teacher's retarded requirements
22:40:42 <geezusfreeek> it's just an algorithms class
22:40:43 <sjanssen> > 550 / 29
22:40:44 <lambdabot>  18.96551724137931
22:40:49 <dons> mmm. tasty
22:40:54 <geezusfreeek> should be easy, but nooo
22:41:01 <sjanssen> geezusfreeek: what're you implementing?
22:41:01 <dmwit> jcreigh: Yeah, when I recompiled X11-extras it didn't have Xinerama support.
22:41:04 <dons> sjanssen: we're such slackers with xmonad ;-) 1/4th, bah!
22:41:13 <dmwit> But I hadn't known about the autoconf switchover, so...
22:41:24 <geezusfreeek> i also have had points marked off for not placing random @@@ stuff in front of my comments "to further set it apart from my code"
22:41:28 <jcreigh> dmwit: oh, you just did "runghc Setup build" after a "darcs pull"?
22:41:44 <dmwit> jcreigh: Right.
22:41:45 <geezusfreeek> i'm implementing the boyer-moore algorithm (and a bunch of driver code)
22:42:07 <dmwit> jcreigh: After I discovered that xmonad didn't build any more...
22:42:09 <LeCamarade> @google Boyer-Moore Algorithm
22:42:12 <lambdabot> http://www-igm.univ-mlv.fr/~lecroq/string/node14.html
22:42:14 <lambdabot> Title: Boyer-Moore algorithm
22:42:23 <dmwit> I found out you were the one that broke it, so I figured X11-extras got an update. ;-)
22:42:56 <jcreigh> yeah, I break stuff left and right. :)
22:43:04 <dons> dmwit: X11-extras working for you now?
22:43:17 <dons> dmwit: we're preparing a release, so any beta/build testing reports welcome
22:43:24 <jcreigh> X11-extras now has autoconf magic that allows it to be built and expose Graphics.X11.Xinerama even if Xinerama libs are not installed.
22:43:34 <dmwit> dons: Yeah, everything is back to normal now.
22:44:01 <dmwit> jcreigh: Ah, cool!
22:47:18 <dons> ok night all. see you on the other side of the pacific :-)
22:53:19 <sjanssen> xmonad rc1 has hit the mailing list
22:53:46 <int-e> is there a difference between [| $(foo) |] and just  foo  in Template Haskell?
23:21:22 <LeCamarade> Not a sound for so long? Echoes bouncing through the lambda hall [... ouncing through the lam ... [... ing through ...] ... bda hall ... [... the lambda hall ... [... ambda hall ... [...]]]]
23:22:07 <LeCamarade> Hey, can someone simulate echoes with Haskell? Would be good to add into lambdabot ...
23:22:16 <TSC> tails?
23:22:46 <Cale> > map unwords . tails . words $ "Echoes bouncing through the lambda hall"
23:22:47 <lambdabot>  ["Echoes bouncing through the lambda hall","bouncing through the lambda hall...
23:22:52 <LeCamarade> TSC: Tails, and then tails of tails, and then tails of tails of tails ... until it's finished ...
23:23:04 <Cale> > tails "abcde"
23:23:06 <lambdabot>  ["abcde","bcde","cde","de","e",""]
23:23:33 <LeCamarade> Remember that "cde" also generates an echo ...
23:24:28 <Cale> Well, then you'd end up with an infinitely deep nesting of lists, which isn't allowed, but you could do it with a tree.
23:24:53 <LeCamarade> Cale, when there is nothing left to echo (""), that stops.
23:25:14 <LeCamarade> > tails "abcde"
23:25:16 <lambdabot>  ["abcde","bcde","cde","de","e",""]
23:25:51 <Cale> > map tails (tails "abcde")
23:25:52 <lambdabot>  [["abcde","bcde","cde","de","e",""],["bcde","cde","de","e",""],["cde","de","...
23:26:26 <LeCamarade> > let echo x = map (tails . init) $ tails x in "abcde"
23:26:27 <lambdabot>  "abcde"
23:26:46 <LeCamarade> > let echo x = map (echo . init) $ tails x in echo "abcde"
23:26:48 <lambdabot>      Occurs check: cannot construct the infinite type: c = [c]
23:26:48 <lambdabot>       Expected...
23:27:21 <LeCamarade> > let echo x = map (tails . init) $ tails x in echo "abcde" -- I'm not thinking straight, am I?
23:27:23 <lambdabot>  Exception: Prelude.init: empty list
23:27:44 * LeCamarade goes of to blink a bit.
23:30:39 <dolio> > tails ""
23:30:40 <lambdabot>  [""]
23:31:23 <int-e> > (tail . inits) "foob" >>= init . tails
23:31:24 <lambdabot>  ["f","fo","o","foo","oo","o","foob","oob","ob","b"]
23:32:30 <Cale> > let catTails = concat . tails in return "abcde" >>= catTails >>= catTails >>= catTails
23:32:31 <lambdabot>  Couldn't match expected type `Char' against inferred type `[a]'
23:32:37 <Cale> err...
23:33:05 <int-e> > let catTails = concat . tails in iterate catTails "abcde" !! 3
23:33:06 <lambdabot>  "abcdebcdecdedeebcdebcdecdedeecdebcdecdedeedebcdecdedeeebcdecdedeebcdecdedee...
23:33:21 <Cale> ah, yeah, that's all I wanted :)
23:33:57 <Cale> Might be time for me to sleep. There's the temptation to wait up for this torrent to finish so I can watch it right away.
23:34:03 <ibid> araujo: pong
23:34:27 <araujo> hello ibid !
23:34:57 <Cale> > let catTails = concat . tails in length (iterate catTails "abcde" !! 4)
23:35:01 <lambdabot> Terminated
23:35:17 <Cale> 26357430
23:35:59 <int-e> > let l n = n*(n+1) `div` 2 in iterate l (length "abcde") !! 4
23:36:00 <lambdabot>  26357430
23:36:36 <ibid> good morning :)
23:37:01 <ejt_> hi all
23:37:37 <LeCamarade> Hi!
23:37:59 <araujo> ibid, you the responsible of planet.haskell.org?
23:39:04 <ibid> araujo: that's ominous :) yes
23:39:53 <araujo> hah, that's good
23:40:17 <araujo> ibid, can you add me to the fun? :-) http://araujoluis.blogspot.com
23:40:19 <lambdabot> Title: araujo's blog
23:41:41 <ibid> araujo: i usually use people's real names, but nicknames are acceptable. what shall i use?
23:42:26 <araujo> ibid, that's my real name
23:42:57 <araujo> use that one :-)
23:43:47 <ibid> araujo: you'll have to be more specific, please :)
23:44:21 <ibid> araujo: how do you want it spelled? ;)
23:45:09 <qebab> > map tails (tails 'echo')
23:45:10 <lambdabot>  Improperly terminated character constant
23:45:16 <qebab> okay :(
23:45:28 <kolmodin_> he spells it Araujo Luis, with a lemon on the side. shaken, not stirred
23:45:55 <QtPlatypus> > tails $ tails 'echo'
23:45:56 <lambdabot>  Improperly terminated character constant
23:46:07 <QtPlatypus> > tails 'echo'
23:46:08 <lambdabot>  Improperly terminated character constant
23:46:10 <araujo> haha
23:46:13 <QtPlatypus> > tails "echo"
23:46:14 <lambdabot>  ["echo","cho","ho","o",""]
23:46:14 <araujo> ibid, Luis Araujo
23:46:17 <araujo> :-)
23:46:34 <QtPlatypus> > map tails (tails "echo")
23:46:36 <lambdabot>  [["echo","cho","ho","o",""],["cho","ho","o",""],["ho","o",""],["o",""],[""]]
23:46:49 <ibid> added, planet is updating
23:46:59 <araujo> ibid++
23:47:04 <araujo> Thanks ibid
23:47:16 <kolmodin_> cool, I'm looking forward to more posts of araujo
23:47:25 <araujo> @yarr!
23:47:26 <lambdabot> Yarrr!
23:47:47 <araujo> kolmodin_, remember i am new on this blogging fever :-)
23:48:00 <kolmodin_> araujo: so am I :)
23:48:13 <ivanm> araujo: you have a blog?
23:48:18 * ivanm feels so left out...
23:48:25 <araujo> oh yeah ivanm
23:48:32 <araujo> check it out , the site above
23:48:41 <ivanm> yep, looking at it now...
23:48:44 <araujo> ivanm, it's because it is very new :-)
23:48:59 <ivanm> lol, I noticed...
23:49:00 <araujo> you will know it by the number of posts ;-)
23:49:03 <ivanm> two articles!!! wow!!!
23:49:07 <kolmodin_> ivanm: not really, he's just piping his private mails to it
23:49:12 <ivanm> that's like 2 more than I have ;-)
23:49:12 <araujo> haha
23:49:15 <ivanm> kolmodin_: heh
23:49:19 <kolmodin_> :)
23:49:49 <araujo> kolmodin_ blog inspired me to do some blogging :-)
23:49:55 <ivanm> lol
23:50:00 <kolmodin_> hmm.. yeah..
23:50:16 <ivanm> I want to start blogging, but I waste enough time as it is, and don't really want to have it at some generic blogging site
23:50:19 <kolmodin_> ok, rain or no rain (rain, in my case), I have to go to work. see you guys later
23:50:32 <araujo> later kolmodin_
23:50:39 <ivanm> cya
23:51:14 <LeCamarade> ivanm: I also hate generic weblog engines.
23:51:19 <araujo> ivanm, get a blogger on Haskell, and i change :-)
23:51:30 <ivanm> heh
23:51:40 <ivanm> now there's an idea... ;-)
23:51:46 <LeCamarade> Write one in Haskell. May have to run CGI.
23:52:17 <ivanm> I'd really like to have it on my own site... but that requires me to _have_ a site first :p
23:52:17 <ivanm> LeCamarade: I think someone was saying the other day that other people already have...
23:55:31 <LeCamarade> ivanm: Well ... I like to build my own engines and stuff. Especially since Haskell is a language for learning stuff ...
23:55:42 <ivanm> true
23:55:57 <LeCamarade> ivanm: I'd not write my own in PHP. or Python or Ruby. In Haskell, yes.
